00:02:08 <systemfault> Damn ghc takes time to compile :P
00:02:14 <systemfault> <3
00:03:12 <ivanm> about 45 minutes here IIRC
00:03:22 <ivanm> systemfault: wouldn't you be worried if it _didn't_?
00:04:00 <systemfault> As long as it compiles, I'll wait 2 hours if I have to :)
00:04:03 <lispy|web> ivanm: yeah, but go-lang compiles in like 1 minute!
00:04:12 <EvanR> you people are insane
00:04:22 <systemfault> EvanR: Just a little bit
00:04:28 <lispy|web> systemfault: it used to take something like 10 hours for me to compile ghc on my ibook g4
00:04:32 <EvanR> have you ever built *anything* remotes complex
00:04:34 <EvanR> remotely
00:04:56 <EvanR> oh right, everyone has octocore 4 trios with 80 gigs of ram
00:05:00 <systemfault> Haha
00:05:19 <systemfault> EvanR: A few years ago, I was compiling KDE 3.5 on my pentium M
00:05:29 <ivanm> EvanR: I currently have a 2GHz Core2Duo mobile
00:05:50 <systemfault> I have a core 2 duo 2.26 now..
00:05:54 <ivanm> lispy|web: because it doesn't actually compile?
00:06:19 <EvanR> coming from gentoo and lfs, 'ill wait 2 hours if i have to' sounds hilarious
00:06:21 <lispy|web> ivanm: Er no, it worked great.  I learned Haskell on that machine
00:06:40 <systemfault> I have hugs on my ipod touch :(
00:06:41 <ivanm> lispy|web: I meant your go-lang compilation time...
00:06:44 <lispy|web> ivanm: this was, circa 2003
00:06:47 <systemfault> That's geeky...
00:06:47 <lispy|web> ivanm: oh
00:06:52 <ivanm> :D
00:07:10 <ivanm> I'd be suspicious of a "compiler" that compiles in less than a minute
00:07:18 <lispy|web> ivanm: no, the one video I watched on go-lang was 'hey look, we can compile our whole language in < 5 minutes!  don't you wish you used go-lang?"
00:07:26 <systemfault> lol
00:07:40 * lispy|web hasn't been able to take go-lang seriously since
00:07:42 <ivanm> it's either not very complex (i.e. doesn't do many optimisations, etc.) or else the compiler is going to be bog slow because it doesn't use any compilations to compile it
00:07:46 <systemfault> Al-Google Go-ol 2010
00:07:53 <ivanm> or else they use semi-compiled bytecode or something
00:08:05 <ivanm> lispy|web: I never took it seriously
00:08:13 <ivanm> due to the name
00:08:14 <systemfault> Rob Pike... Come on...
00:08:38 <EvanR> go seems sensationally unsensational
00:08:44 <ivanm> systemfault: Google of all people should know how to pick easily searchable project names
00:10:03 <systemfault> A language made by two old unix dudes...
00:10:11 <systemfault> No wonder they recreated Algol..
00:10:15 <lispy|web> Well, go was already taken by a language, so I prefer to call it go-lang
00:10:28 <ivanm> lispy|web: not Issue9? :p
00:10:38 <EvanR> gu-lag
00:10:39 <lispy|web> ivanm: hehe, yeah that's probably better
00:10:56 <ivanm> EvanR: definite marketing problems with that one...
00:11:53 * ivanm -> dinner
00:14:15 <clonick> hi
00:14:20 <aavogt> hello
00:14:30 <clonick> here is a programmers chat ?
00:14:47 <lispy|web> clonick: correct!
00:14:51 <aavogt> this room is for discussing haskell
00:15:49 <lispy|web> > fix $ \fibs -> 1 : 0 : zipWith ($) fibs (tail fibs) -- write some code with us clonick!
00:15:50 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> b1
00:15:53 <lispy|web> doh!
00:16:01 <lispy|web> > fix $ \fibs -> 1 : 0 : zipWith (+) fibs (tail fibs) -- write some code with us clonick!
00:16:02 <lambdabot>   [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
00:16:16 <ivanm> lispy|web: that usage of fix there is dubious
00:16:25 <ivanm> as is starting with "1, 0"
00:16:29 <lispy|web> hehe
00:16:32 <clonick> hey
00:16:56 <lispy|web> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) -- Happy now?
00:16:57 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) -- Happ...
00:16:59 <clonick> someone have some php script similar to raffle ticket booking system between friends ??
00:17:05 <lispy|web> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
00:17:06 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:17:22 <lispy|web> clonick: a haskell script maybe?
00:17:33 <lispy|web> ivanm: it's never wrong to use fix ;)
00:17:57 <ivanm> heh
00:18:06 <ivanm> clonick: try #php
00:18:13 <clonick> lispy|web what is haskell ?
00:18:18 <clonick> #php
00:18:31 <ivanm> clonick: you'll need to do "/join #php" (no quotes)
00:18:34 <lispy|web> clonick: Haskell is a purely functional programming language that we talk about here
00:18:37 <ivanm> Haskell is a purely functional programming language
00:18:49 <clonick> hoo interesting
00:18:49 <tomberek> somtimes when Haskell-ites keep giving fib examples, makes me thing that ghc is just a compiler optimized for Fibonacci
00:18:55 <clonick> sry lol
00:19:07 <clonick> haskell is for desktop environment ? run in linux ?
00:19:08 <lispy|web> tomberek: that's why we have the nofib benchmark suite for GHC
00:19:15 <lispy|web> clonick: sure
00:19:24 <lispy|web> clonick: or servers, or mobile devices, or windows, or mac, or ...
00:19:37 <lispy|web> ?faq Does Haskell run everywhere?
00:19:38 <lambdabot> The answer is: Yes! Haskell can do that.
00:19:45 <ivanm> clonick: it's a programming language, just like PHP, Java, C, etc. are (except BETTER!)
00:20:07 <maltem> Only today did I learn that in a gcc-compiled program, comparisons on NaNs will not catch floating-point exceptions (whereas in GHC, NaN < NaN = False etc.) :o
00:20:35 <clonick> wow, i was never hear about it
00:20:56 <clonick> and if have time..... why is better ?
00:21:02 <wli> I should chime in with something here but anyway.
00:21:13 <maltem> (So in C, floating-points are correctly partially ordered)
00:21:13 <lispy|web> clonick: well, you can get started learning it: http://learnyouahaskell.com/
00:21:19 <mamalujo> dons: thank you for maximizing my lifespan should I come across a pack of raptors in a geometric configuration! fun post
00:21:34 <lispy|web> clonick: and download haskell http://hackage.haskell.org/platform/
00:22:47 <lispy|web> clonick: if you can't wait for it to download, you can try it here: http://tryhaskell.org/
00:23:40 <mamalujo> dons: hm, I misread, ignore
00:25:24 <systemfault> Fuu....
00:25:42 <systemfault> Compilation error for haddock...
00:27:22 <ivanm> systemfault: :s
00:27:27 <clonick> Haskell was made by some really smart guys (with PhDs)
00:27:39 <clonick> wow, ok, i will change to php forum, LOL
00:28:00 <systemfault> ivanm: I just added options to not compile the docs... recompiling :(
00:28:28 <clonick> i'm know CSS lol and a little of php =( but maybe in the future i can learn haskell
00:28:30 <clonick> thanks!
00:28:41 <lispy|web> clonick: you're welcome, come back soon
00:29:06 <systemfault> Haskell is evil... If you learn it, you wouldn't want to write PHP anymore.
00:29:23 <maltem> systemfault, yeah it's a pity that compiling the docs along with a ghc is such a hassle
00:29:32 <pikhq> Nay, would cease to be able to consider PHP anything but a scar upon the earth.
00:29:55 <clonick> lol
00:30:04 <systemfault> maltem: I already have 6.12.x installed, compiling a llvm/ghc build :)
00:30:40 <systemfault> PHP is one of the worse languages on the planet.
00:30:41 <lispy|web> after you learn Haskell, php will seem like an oil well 5000 feet below the sea that has blown a blowout valve and is leaking thousands of barrels of oil every day
00:30:58 <maltem> systemfault, as for the haddock error in the llvm code, that one can be fixed by removing the superfluous |'s
00:31:05 <Raynes> lispy|web: They capped it.
00:31:05 <pikhq> lispy|web: Only worse.
00:31:26 <pikhq> Raynes: Still leaking.
00:31:30 <lispy|web> Raynes: oh, did they?  They said that in 1979 when they did a top kill too, but then it opened up again
00:31:40 <pikhq> lispy|web: It opened up again.
00:31:44 <lispy|web> this is getting way off topic though
00:31:46 <Raynes> It did? Haha.
00:32:04 <systemfault> Win! It compiled :D
00:32:04 <maltem> (someone should fix haddock that it can only warn on doc parse errors, rather than aborting the whole compilation process)
00:32:35 <scree> I am personally very disappointed by the US government's response to PHP
00:32:47 <systemfault> scree: ?
00:32:59 <Raynes> systemfault: Oil leak PHP joke.
00:33:03 <Raynes> systemfault: Go back to compiling.
00:33:04 <Raynes> :p
00:33:05 <systemfault> Ahhh :/
00:33:16 * systemfault disapears
00:33:41 <systemfault> With a missing p in disappear..
00:33:58 <Raynes> systemfault: The P disappeared.
00:36:15 <systemfault> Now..let's see if my compiler is bugged like last time I tried (2-3 months ago). It was making a 32MB executable for a hello world :P
00:36:56 <aavogt> it's supposed to do that
00:37:14 <aavogt> err, if your hello world needs the ghc-api
00:37:33 <aavogt> otheriwse it's around 1/4 of that
00:37:52 <systemfault> Hmm
00:40:10 <maltem> systemfault, dynamic linking has arrived (sort of), you may well like to try that :)
00:40:49 <systemfault> I mean, I have 6.12.x installed and it's not create 32MB ultra-slow executables..
00:41:02 <systemfault> it doesn't
00:41:21 <jlouis> I think I got Combinatorrent faster than etorrent at long last
00:42:24 <maltem> oh you mean HEAD was broken
00:42:30 <systemfault> maltem: Yes.
00:42:40 <jesusabdullah> etorrent --> erlang? Or am I misremembering? ;)
00:42:46 <jlouis> jesusabdullah: yup
00:43:11 <jesusabdullah> huh!
00:43:18 <jesusabdullah> Oh, and gj
00:43:22 <jesusabdullah> I think I
00:43:24 <jesusabdullah> blegh
00:43:40 <jesusabdullah> I think I'm following combinatorrent on the githubs actually
00:43:42 <jesusabdullah> <_<
00:44:25 <maltem> systemfault, hm I do have suspiciously large HEAD-compiled files lying around here
00:44:44 <maltem> they're not slow though
00:44:50 <systemfault> Ah ok :)
00:45:37 <maltem> maybe it's to do with that I disabled tablesNextToCode for llvm to work, but no idea
00:47:18 <lispy|web> jlouis: congrats
00:48:32 <systemfault> maltem: Do you install it on your system or only using it from the inplace/bin folder?
00:53:58 <maltem> systemfault, I installed it user-locally (under $HOME)
00:55:01 <systemfault> I guess I have to recompile it with the proper configure --prefix if I want that? :(
00:55:23 <maltem> I guess so
00:55:32 <systemfault> Oh well :(
00:55:57 <maltem> well I'd hope that wouldn't take long
01:05:20 <jre2> is there a way to see how often a hackage package is used in another hackage package?
01:06:28 <jre2> it'd be neat to know which (if any) packages use some of the more eccentric libraries
01:06:42 <tommd> jre2: You mean, if package A is used in package B, measure how heavily B depend on A in terms of definitions from A used in B?
01:07:05 <tommd> jre2: That second statement is just reverse deps - That is available.
01:07:25 <jre2> tommd: no, I meant len(reverse deps) basically
01:07:31 <tommd> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html
01:07:52 <jre2> tommd: awesome
01:09:28 <jre2> I like how bytestring is used nearly as often as base...
01:17:27 <tommd> @where reverseDeps
01:17:27 <lambdabot> I know nothing about reversedeps.
01:17:37 <tommd> @where+ reverseDeps http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html
01:17:37 <lambdabot> I will remember.
01:17:48 <tommd> no, you won't.  You never do.
01:18:29 <tommd> Your like a C program.  You claim storage can be immutable simply by not muting or freeing it, but in reality you forget and change things all the time
01:18:42 <tommd> You're a bad bot, and I will never give you a bot snack.
01:28:40 <FunctorSalad> wasn't there some package with System.Process.readProcess, but for bytestrings?
01:29:27 <FunctorSalad> or I guess one might as well use the generic createProcess and read from the handle...
01:35:17 <jre2> is there a library for tagging data (eg by regexes for string data) while ensuring relations on tags (eg something can be tagged "lunch" and "food" but not "food" and "electronics")?
01:40:28 <jlouis> @botsnack
01:40:28 <lambdabot> :)
01:40:39 <lispy|web> ?src liftM3
01:40:40 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
01:41:02 <lispy|web> isn't there a way to write that as a liftM f `ap` x, or so?
01:41:26 <jlouis> f <$> m1 <*> m2 <*> m3 is one way through Applicative IIRC
01:41:47 <kmc> :t \f m1 m2 m3 -> f `liftM` m1 `ap` m2 `ap` m3
01:41:49 <lambdabot> forall a1 a a11 b (m :: * -> *). (Monad m) => (a1 -> a -> a11 -> b) -> m a1 -> m a -> m a11 -> m b
01:42:29 <portnov> :t ?f <$> ?m1 <*> ?m2 <*> ?m3
01:42:29 <lambdabot> forall a a1 a2 b (f :: * -> *). (?f::a -> a1 -> a2 -> b, ?m1::f a, Applicative f, ?m2::f a1, ?m3::f a2) => f b
01:42:35 <kmc> liftM = (<$>) and ap = (<*>) (ignoring historical typeclass stupidity)
01:42:46 <kmc> liftM = (<$>) = fmap
01:42:53 <kmc> :t liftA3
01:42:54 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
01:43:25 <Inglorion> hi. if i have a function that returns rationals (e.g. foo = 12 % 5), can i declare that it returns reals (e.g. foo :: Real a => A) ?
01:43:40 <kmc> :t fromRational
01:43:41 <lambdabot> forall a. (Fractional a) => Rational -> a
01:43:49 <lispy|web> oh, I see what I was doing wrong
01:43:52 <kmc> :t fromRational (12 % 5)
01:43:54 <lambdabot> forall a. (Fractional a) => a
01:44:10 <kmc> :t fromRational . (+ (12 % 5))
01:44:11 <lambdabot> forall a. (Fractional a) => Ratio Integer -> a
01:44:45 <FunctorSalad> :t toRational
01:44:46 <lambdabot> forall a. (Real a) => a -> Rational
01:45:06 <FunctorSalad> odd concept of 'Real' ;)
01:45:42 <kmc> almost every real number can't be represented by a computer
01:47:14 <FunctorSalad> one could make a perfectly accurate type for reals of the form "q + s*sqrt(2)" with q and s rational :)
01:47:15 <Inglorion> right, so... is there an answer to my question in there? i'm quite new to Haskell, and i'm not really sure what to do with fromRational
01:47:17 <FunctorSalad> and so on
01:48:23 <kmc> Inglorion, apply fromRational to the value you'd return
01:48:30 <kmc> it will convert Rational to any Floating type
01:48:37 <Inglorion> the way i figured it, Rational is an instance of Real
01:49:07 <Inglorion> so if i declare the return type as "some instance of Real" and return a rational, that should work. however, the compiler says otherwise
01:49:16 <kmc> that's not how type classes work
01:49:36 <kmc> or rather it's not how polymorphism works (whether or not type classes are involved)
01:49:55 <Inglorion> figures. so i tried your suggestion and added a fromRational
01:50:05 <kmc> consider a function of type «Char -> a»
01:50:06 <Inglorion> but that doesn't get me very far, either
01:50:11 <FunctorSalad> Inglorion: "Real" is the class of types which can be converted *to* a rational; you just need the class of types that contain the rationals (which is: Fractional)
01:50:22 <FunctorSalad> (in haskell's number system, of course)
01:50:28 <kmc> in GHC Haskell we'd write this more completely as «forall a. Char -> a».  meaning "for any type A you choose, i'll take a Char and return A"
01:50:42 <kmc> that's very different from "i'll take a Char, pick some particular A, and return it"
01:51:16 <Inglorion> right
01:51:17 <kmc> when you say «f :: (Real t) => Char -> t», the *caller* gets to choose any Real type for t, and you have to comply
01:51:18 <freiksenet> can algebraic data types be separated in type signatures? so if I have data Foo = Bar | Baz, can I have type signature Bar -> String? probably not, cause Bar is in different namespace, but maybe it is possible to do somehow?
01:51:39 <lispy|web> freiksenet: not possible as written
01:51:41 <Inglorion> ok, so i was getting it backwards
01:51:46 <kmc> freiksenet, you can split Foo into different types
01:52:01 <kmc> freiksenet, or you can use GADTs to lift the choice of constructor into a type parameter
01:52:08 <kmc> Inglorion, so why doesn't fromRational worK?
01:52:21 <freiksenet> kmc: I will look into those GADTs
01:52:25 <freiksenet> thanks
01:52:26 <lispy|web> freiksenet: You could instead do, class Foo a where; data Bar; data Baz; instance Foo Bar; instance Foo Baz, and then kind of do the same thing
01:53:03 <Inglorion> hold on kmc, i am digesting your explanation to make sure i completely understand it
01:54:33 <FunctorSalad> lispy|web: that will get you an open world though :) which could be the intention of course
01:54:34 <Inglorion> what i was trying to say is "foo returns some kind of Real", but when i write "foo :: Real a => a", what i am really saying is "tell foo what kind of Real you want, and it will give you that kind of Real". do i have that right?
01:54:43 <FunctorSalad> for a closed world you'd use a GADT
01:54:47 <lispy|web> FunctorSalad: we can close it up if you like
01:55:02 <FunctorSalad> lispy|web: by adding the `fold' to the class?
01:55:03 <kmc> Inglorion, yes
01:55:06 <lispy|web> class Hidden a => Foo a where;  -- now don't export Hidden
01:55:11 <freiksenet> lispy|web: mm, dunno if that would work in that situation, but thanks anyway.
01:55:17 <FunctorSalad> I see
01:55:20 <FunctorSalad> :)
01:56:03 <kmc> Inglorion, in GHC's flavor of Haskell you can do the other thing as well -- "i'll pick some particular T, but not tell the caller which, only that it's an instance of Real"
01:56:04 <lispy|web> But yes, GADTs work better if your type class is to be closed
01:56:06 <Inglorion> ok, then using fromRational wouldn't help me, because i simply wrote down something that isn't what i want
01:56:08 <kmc> it's probably not what you want here
01:56:19 <kmc> but that's the ExistentialTypes extension
01:56:20 <FunctorSalad> (of course I needn't tell you about GADTs ;) weren't you the one who applied them in darcs?)
01:56:27 <FunctorSalad> ( lispy|web )
01:56:36 <lispy|web> FunctorSalad: correct
01:56:48 <lispy|web> I went temporarily insane
01:56:52 <kmc> existential types get you much of object-oriented programming:  public interfaces with hidden implementation types
01:56:53 <lispy|web> I'm back now
01:56:54 <FunctorSalad> :o
01:57:12 <lispy|web> kmc: oh, is that why existentials are so painful to use in Haskell ;)
01:57:26 <kmc> they're not in Haskell ;P
01:57:37 <kmc> and i'm not just being pedantic, the extension in GHC is markedly different from in other compilers
01:57:50 <kmc> GHC's is weirder
01:57:56 <lispy|web> kmc: they are when GHC starts saying that it's brain just exploded or that a type is less polymorphic than expected :)
01:58:03 <Inglorion> well, perhaps you can help me find a better way to do what i'm trying to do
01:58:08 <FunctorSalad> kmc: other compilers have (other) existentials?
01:58:19 <FunctorSalad> like straight "exists a. ..."?
01:58:22 <kmc> FunctorSalad, yes
01:58:53 <lispy|web> Does anyone use anything besides GHC regularly?
01:58:56 <FunctorSalad> (personally I don't mind the dualized 'forall's that much)
01:59:05 <Inglorion> i have a record type that has a monetary value in it, and i'm writing a parser
01:59:56 <kmc> lispy|web, i'm sure there are people using UHC regularly, as it's an active project
01:59:58 <Inglorion> the idea i had was to declare my record type with, like, Real money => ... { ..., amount :: money, ... }
02:00:17 <Inglorion> and have the parser return some kind of Real when parsing a number
02:00:27 <tomberek> kmc: i'm working with ATs and running into overlapping instances, words of wisdom?
02:00:36 <kmc> ATs?
02:00:41 <tomberek> associated types
02:00:42 <lispy|web> Inglorion: hmm...is the type class actually on your data type?  That's usually a bad idea
02:00:46 <kmc> oh
02:00:47 <FunctorSalad> Inglorion: if you want a record instance to be able to supply the `amount' in any Real type...
02:01:07 <lispy|web> Inglorion: usually better to have the type class constraints on the functions and have the data type just hold some arbitrary 'a'
02:01:09 <FunctorSalad> then you but the quantifier in the field type, like: amount :: amount :: forall a. Real a => a
02:01:24 <FunctorSalad> sorry, delete the redundant "amount ::"
02:01:28 <kmc> Inglorion, data Money t => Money { ... amount :: t ... }
02:01:53 <kmc> Inglorion, versus «data Money => forall t. (Real t) => Money { ... amount :: t ... }».  that would be an existential type and is probably less useful
02:02:04 <kmc> tomberek, hpaste?
02:02:18 <kmc> tomberek, i abbreviate as "asstypes"
02:02:22 <kmc> ;)
02:02:32 <lispy|web> kmc: bottom? :)
02:02:37 <kmc> heh
02:02:38 <FunctorSalad> kmc: if he parses a rational number, he can produce a universal Real, not just an existential (but then, you could as well store the Rational and do the fromRationa later)
02:02:38 <Inglorion> ok, that's lots of food for thought. thanks, everyone. i'm going to tinker with it some more
02:03:00 <FunctorSalad> (and it's actually Fractional, not Real ;))
02:03:05 <kmc> FunctorSalad, hmm, true.  then the ctor would be rank-2 right?
02:03:11 <kmc> still need an extension
02:03:15 <kmc> but it's somewhat more reasonable
02:03:23 <FunctorSalad> PolymorphicComponents?
02:03:26 <kmc> anyway as you said, better to just store the Rational, since any consumer could call fromRational
02:03:28 <FunctorSalad> thought this one is pretty tame
02:03:29 <kmc> yeah
02:04:02 <lispy|web> Inglorion: BTW, if you're using a record it's usually better to not use an existential and instead store the functions you need to work on your particular value in the record type.  That is, instead of using a type class put fields in your record type for the functions.  Existentials in Haskell typically lead to hard to work with programs.
02:04:14 <lispy|web> someone blogged about this...
02:04:33 <lispy|web> ah, right http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
02:05:08 <tomberek> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25808#a25808
02:05:38 <tomberek> kmc: any attempt to make a polymorphic data type an instance overlaps with Labeled (f a)
02:06:50 <tomberek> i wanted newtype Tuple a b or something an instance fails, same with (a,b)
02:06:50 <lispy|web> as conal says it, haskell is a value oriented language, everything (including functions) is a value
02:07:14 <Inglorion> yes. thanks for the advice. i am excited by all the possibilities, but i should really learn what is and what isn't a good way to write real programs :-)
02:07:38 <FunctorSalad> 'you have a universal', or 'you must supply an existential' means 'you choose'. 'you have an existential', or 'you must supply an universal' means 'the opponent chooses, you must be able to handle any choice'
02:08:22 <FunctorSalad> (the imaginary 'opponent' who chooses the specialization in such a way as to make the program not work ;))
02:09:04 <FunctorSalad> pretty dualities...
02:09:55 <zenzike> I'm trying to create an array of type (Float, Float, Float),  and somewhat suprised that there isn't a default UArray instance: should I really have to roll my own? Is there a good reason why UArray doesn't come with default instances for things like pairs?
02:10:14 <kmc> zenzike, you might want to use the "vector" package instead
02:10:25 <Taejo> zenzike: because pairs can't be unboxed
02:10:38 <Taejo> where by pair I mean (a, b)
02:10:43 <Inglorion> so, i suppose i could just make things easy by saying that the amount is of type Rational. i reckon nobody is actually going to transfer an irrational (in the number theoretic sense!) amount of money, anyway
02:10:55 <lispy|web> Taejo: there is an unboxed pair
02:10:56 <FunctorSalad> unboxed pairs then?
02:11:01 <FunctorSalad> ^^^^ faster
02:11:09 <lispy|web> Taejo: the kind is such that the elements have to be unboxed too
02:11:09 <Taejo> lispy|web, FunctorSalad: of course
02:11:31 <zenzike> so is there any reason why an unboxed pair uarray isn't available?
02:11:52 <lispy|web> zenzike: oh, BTW, uarray is deprecated.  Vector has replaced it
02:12:03 <FunctorSalad> Inglorion: I thought your input format was fixed to rational (that's outside the scope of the type system after all)
02:12:04 <zenzike> lispy ah, thanks, I didn't know that
02:12:15 <FunctorSalad> Inglorion: if I understood correctly that you're parsing text
02:12:22 <lispy|web> zenzike: but to answer your question, uarray has a strict pair
02:12:26 <tomberek> anyone:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25808#a25808  can I make a polymorphic instance without overlapping ?
02:12:27 <FunctorSalad> (some serialized records)
02:12:31 <lispy|web> zenzike: isn't it :*: ?
02:12:48 <kmc> i don't agree that existentials lead to hard-to-work-with programs
02:12:49 <zenzike> lispy: I have no idea
02:13:00 <kmc> the "antipattern" is overuse of type classes, not overuse of existentials
02:13:15 <kmc> beginners who come from OO languages often think that they need a new type for every new behavior, and put the behaviors in a class
02:13:23 <kmc> but since behaviors are first-class, they're just values
02:13:49 <Inglorion> FunctorSalad: i want to parse numbers like "12.83" and return them as something that doesn't lose the precision
02:13:55 <kmc> sometimes you can use existentials to replace a bunch of extra types and instances with simple record values
02:13:59 <FunctorSalad> kmc: I don't know the debate really but maybe people run into the problem that the concrete info which type is inside is lost forever?
02:14:01 <FunctorSalad> barring Typeable
02:14:17 <kmc> Inglorion, every number of that form is rational, assuming your parser only accepts files of finite size
02:14:18 <FunctorSalad> (no downcasts)
02:14:18 <Inglorion> i'm currently using Rational for that, but i would like to not have my code littered with "Rational", in case i ever decide that some other type is really better
02:14:38 <lispy|web> kmc: hmm...I agree that type classes are also over used.  I do feel that existentials are rarely the right thing (I say this having used them a lot in darcs)
02:15:17 <kmc> i should also revise to "beginners who come from *bad* OO languages"
02:15:29 <kmc> because every good general-purpose language has first-class behaviors
02:15:37 <kmc> but Java and C++ don't and are enormously popular
02:15:43 <kmc> Java in particular has this "kingdom of nouns" problem
02:15:46 <tomberek> kmc: would you say i'm overusing a type class ?
02:16:00 <kmc> tomberek, i'm not sure without knowing what you're trying to do
02:16:14 <kmc> tomberek, overlap is a property of the head only, and not the context
02:16:24 <lispy|web> kmc: in this regard, I think C++ actually has decent support for behaviors, albeit via templates
02:16:29 <Inglorion> *grumble* and i was coming to #haskell hoping to get a break from the kingdom of nouns :-(
02:16:37 <FunctorSalad> Inglorion: the low-tech way would be to just make a synonym "type Currency = Rational" I guess
02:16:58 <Inglorion> actually, i think that's a good idea, FunctorSalad
02:17:08 <FunctorSalad> (that way the typesystem won't be involved in any polymorphism, but at least you have a single point of refactoring...)
02:17:17 <zenzike> it seems to me like vector can't do paired indexing (like an array can), does that mean i should be calculating my offsets manually every time, or have I missed something?
02:17:26 <kmc> zenzike, unfortunately yess
02:17:27 <lispy|web> kmc: C++ supports what I like to call 'static duck typing', which unlike dynamic duck typing, I quite like
02:17:33 <kmc> however the Ix class does it for you
02:17:44 <FunctorSalad> kingdom of nouns?
02:17:48 <kmc> lispy|web, i agree that's what it supports (but i don't like it much)
02:17:57 <kmc> FunctorSalad, http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
02:18:11 <tomberek> kmc: I want to be able to Label things, and then Label things that are inside of functors (applicative seems to make sense)... edwardk said it was like a bifunctor being comonadic in both parameters
02:18:18 <zenzike> kmc: I can't see how the Ix class is related to vector... the index takes an Int, not an Ix derived type
02:18:29 <kmc> sorry
02:18:37 <kmc> by "does it for you" i meant the calculation, not the feeding into vector
02:18:51 <zenzike> kmc: thanks, that makes sense
02:18:59 <kmc> tl;dr on "kingdom of nouns"  is that in Java you need a new class for anything you want to abstract, and so you end up with a lot of ThingDoer, and ThingDoerFactoryManager etc.
02:19:09 <Inglorion> FunctorSalad: kingdom of nouns is basically caused by the lack of first-class functions
02:19:11 <kmc> classes that don't represent parts of the problem domain, but only parts of your algorithm
02:19:24 <Inglorion> in Java, you work around that by creating an object that has a method that does what you want
02:19:35 <Inglorion> so, yeah, what kmc said
02:19:39 <FunctorSalad> I see...
02:22:29 <FunctorSalad> . o O ( Func<A,B> ;) )
02:22:59 <kmc> tomberek, do you see why it would overlap?
02:23:23 <lispy|web> FunctorSalad: yeah, except the lack of type synonyms means you really get killed on syntactic overhead when you do that :)
02:23:23 <tomberek> kmc: i see why, don't know how to fix it
02:23:57 <kmc> lispy|web, it's okay, more typing => hire more programmers, problem solved
02:24:42 <lispy|web> kmc: oh, heh, yeah that makes sense
02:24:56 <lispy|web> ?quote lispy envalue
02:24:57 <lambdabot> lispy says: a := new Maybe(); a.envalue(1);
02:25:13 <kmc> hahaha
02:25:25 <kmc> that's boost::optional
02:25:31 <kmc> Maybe implemented in only 1000 lines of C++
02:25:37 <lispy|web> hehe
02:25:43 <FunctorSalad> "envalue"... nice word
02:26:28 <kmc> of course in C++ it would be
02:27:02 <FunctorSalad> is ":=" java now? I haven't seen it since before even generics...
02:27:18 <lispy|web> FunctorSalad: no, I meant that to be pseudo code
02:27:43 <kmc> yeah that's not any real enterprise language
02:27:48 <tomberek> kmc: is it fixable/possibel?
02:27:50 <kmc> if it were, you'd see the same type name repeated 3 or 4 times
02:27:52 <tomberek> kmc: is it fixable/possible?
02:27:53 <kmc> tomberek, not sure
02:28:23 <lispy|web> kmc: right, nor did I use the MaybeFactory to create the Maybe
02:28:26 <FunctorSalad> is the point lack of abstraction over constructor signatures there?
02:28:57 <lispy|web> FunctorSalad: I guess you could say
02:29:01 <lispy|web> FunctorSalad: er, say that
02:29:43 <tomberek> kmc: or rather, it's conflicting family instance declarations
02:30:29 <lispy|web> FunctorSalad: it also emphasises that in languages like C++ your objects tend to start out as the simplest possible value of that type and then get mutated to be what you wanted
02:30:37 <lispy|web> FunctorSalad: whereas in Haskell we just say it.  "Just 1"
02:30:38 <systemfault> I'm trying to install ghc after having sucessfully compiled it but I'm getting that error, anyone can help
02:30:41 <systemfault> ghc-cabal: integer-gmp-0.2.0.0: library-dirs: @GMP_LIB_DIRS@ doesn't exist or
02:30:41 <FunctorSalad> can't you do "class Maybe<A> { B maybe<B>(B b0, Func<A,B> b1); }" in C# now? ;)
02:30:43 <systemfault> isn't a directory (use --force to override)
02:30:46 <systemfault> Thank you.
02:30:49 <FunctorSalad> not sure if fields can be parametrically polymorphic
02:31:06 <FunctorSalad> encode it as the fold ;)
02:31:37 <lispy|web> C# generics are pretty powerful, I think.  Not that I have experience teher
02:31:51 <Inglorion> my problem with lack of abstraction mechanisms isn't so much that they cause more work, but that they lead to less elegant code
02:32:08 <FunctorSalad> if the field can't be polymorphic like that it works as an abstract class, at least...
02:32:33 <lispy|web> djikstra said that elegance takes genius to create and a good education to appreciate
02:32:34 <Inglorion> you can, and people do, hire more programmers and take more time to complete a project, but, in the end, you are going to end up with a bloated, slow, unreadable, unmaintainable, program
02:32:56 <kmc> yes
02:32:58 <FunctorSalad> or actually in that form it has to be an abstract method o_O to do without any inheritance you'd need another Func
02:33:09 <kmc> the more Haskell you know, the less you'll be able to tolerate those projects
02:33:17 <Inglorion> exactly, kmc
02:33:28 <kmc> learning Haskell is really bad for job happiness at an average software job
02:33:37 <Inglorion> although, in my case, it was lisp and ocaml rather than haskell :-)
02:33:42 <kmc> sure
02:33:52 <kmc> or Python or Ruby, etc.
02:33:59 <kmc> not for all the same reasons
02:34:13 <Inglorion> yes. i actually write most of what i write in Ruby and C
02:35:03 <lispy|web> C is evil because it's the poster child for unsafe languages, but it's become the go to language for FFIs
02:35:18 <Inglorion> indeed
02:35:32 <int-e> but C is honest about it.
02:35:34 <kmc> lispy|web, i don't think it's the poster child, in that most people recognize that it's unsuitable for regular apps programming
02:35:35 <FunctorSalad> hmm "takes genius to create"? thought 'elegance' wasn't a rare thing :)
02:35:35 <scree> Inglorion: did you really find that as bad programs were being written in Lisp/OCaml as the bad programs you get in Ruby/Python/C++?
02:35:47 <Inglorion> C is a great language for what it is good for. the problem is that people use C when they're not in that niche
02:35:51 <Inglorion> and they do it massively
02:36:02 <FunctorSalad> just any solution that handles a tricky problem with little effort
02:36:12 <FunctorSalad> could be something small...
02:36:26 <Inglorion> scree, come again? did i say bad programs were being written in any of these?
02:36:31 <kmc> Inglorion, yeah.  and same for C++, if by "great" you mean "still pretty bad"
02:36:45 <kmc> i.e., i think a lot of the flaws of C++ are not inevitable consequences of the niche
02:36:55 <Inglorion> i don't know what C++'s niche is
02:37:10 <lispy|web> FunctorSalad: watch this video (english subtitles incase you don't speak dutch): http://noorderlicht.vpro.nl/programmas/2848322/afleveringen/3502225/
02:37:13 <Inglorion> for C, it's systems programming. problem is, people write applications in it
02:37:25 <scree> Inglorion: sorry, not awake.  Understand what you meant now :)
02:37:38 <lispy|web> I worked on a poorly maintained lisp codebase my first 1.5 years of grad schoo
02:37:45 <kmc> very high performance, explicit control of memory, but larger apps that need more abstraction than the typical C systems project
02:37:47 <Inglorion> C++ has a lot of great things for applications programming, but still carries around C's misfeatures for application programming (e.g. lack of type-safety)
02:37:48 <lispy|web> That was a mess, and it was quite hard to fathom some parts of it
02:37:55 <kmc> yes Inglorion
02:38:18 <lispy|web> But, the way it was hard to understand was fundamentally different than a C/C++ code base
02:38:28 <kynky> i thought C had a purpose and C++ was the mess
02:38:38 <FunctorSalad> lispy|web: I guess I wasn't really disagreeing with anything ;) was just a pointless remark that elegance can be small-scale too
02:38:43 <lispy|web> The fact that it was dynamically typed was probably the main thing
02:38:46 <kmc> every Lisp codebase is written in its own language
02:38:47 <Inglorion> so while C++ certainly has some interesting ideas in it, i see it as too heavy for systems programming and too unsafe for applications programming
02:38:55 <lispy|web> FunctorSalad: watch it anyway, it's cool :)
02:39:07 <kmc> and so i imagine an incomprehensible Lisp codebase would be one built around an incomprehensible set of macros / EDSL
02:39:29 <kmc> C++ is used extensively in high-frequency finance because you can't afford garbage-collection latency, and you want to do fancy CPU tricks, very fast data conversion, etc.
02:39:44 <kmc> likewise other realtime tasks
02:39:52 <scree> of course, when dijkstra said that, there were fewer elegant things around
02:39:59 <lispy|web> kmc: actually, I didn't work in the EDSL parts of it much.  The reason it was bad is because it had been hacked together by probably a hundred grad students over the years, many of whom didn't know lisp
02:40:13 <monadic_kid> Nowadays I just see C as a domain specific langauge for pointer manipulation, i mean remember C was designed to have nice syntax for using them, idioms such as *ptr++
02:40:25 <Inglorion> exactly, monadic_kid
02:40:41 <Inglorion> also, i've seen my share of bad lisp code. most of it written by me
02:41:04 <FunctorSalad> what is pointer-taylored there? that it's not a precedence error?
02:41:13 <Inglorion> i "learned" lisp in a rush, just enough of it to be able to write imperative code in it
02:41:23 <Inglorion> i didn't learn functional programming until a few years later
02:41:54 <lispy|web> Lisp can be pretty.   I once write a lisp program that searched its own source for the symbol WALDO. What it returned was a program that that had the original program inside it and when you evaluate the returned program it would traverse the original and return the symbol WALDO
02:42:01 <Inglorion> only then did i really grasp how to write lisp code properly
02:42:16 <lispy|web> and that program was very short
02:42:28 <Inglorion> yes. it's easy and fun to write lisp programs that operate on lisp programs :-)
02:43:13 <lispy|web> I doubt I could write a lisp program that did so much as hello-world without reading a tutorial on it now :)
02:43:17 <lispy|web> It's been too many years
02:43:43 <nus-> (PRINC "HELLO, WORLD)
02:43:51 <nus-> err, missed a '"'
02:44:14 <lispy|web> I don't miss retesting my program from scratch on every refactor
02:44:19 <lispy|web> static types++
02:44:27 <Inglorion> right, lispy|web
02:44:53 <Inglorion> the main feature that lisp has that i miss in other languages is macros
02:45:03 <Raynes> <3 Lisp
02:45:04 <lispy|web> Inglorion: I thought I would miss those too
02:45:11 <Inglorion> but there are some other languages that come so close that you hardly miss them at all
02:45:23 <lispy|web> Inglorion: turns out, most of what you want macros for can be achieved in Haskell via recursive data types and laziness
02:45:34 <FunctorSalad> higher-order funcs and lazyness replace some of it I guess
02:45:36 <pastorn> Raynes: (call-cc (lambda (x) (x x))
02:45:43 <lispy|web> Inglorion: and for the rest you have tempate haskell and Language.Haskell
02:45:47 <Raynes> pastorn: ?
02:45:47 <Inglorion> exactly
02:45:56 <pastorn> Raynes: you can do that in lisp
02:46:00 <pastorn> which is pretty insane
02:46:01 <Inglorion> and also, the way i now understand Haskell programs, they mostly are macros
02:46:09 <Raynes> Okay...
02:46:15 <Inglorion> eventually, you end up with some ... IO
02:46:29 <monadic_kid> FunctorSalad: no it's not *ptr++ is *(ptr++), I meant that people who use C they tend to need to do something low level like manipulating memory or accessing devices, something that tends to be pointer heavy. You could do that with other languages which support pointers & pointer arithmetic but C has a nice DSL for doing it
02:46:31 <Raynes> ((fn [x] (x x)) ; I'm a Clojurer. :D
02:46:35 <Inglorion> but all your pure code is basically transformations, right?
02:46:43 <pastorn> @type (callCC (\k -> k k)) -- Raynes
02:46:43 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m b
02:46:44 <lambdabot>     Probable cause: `k' is applied to too few arguments
02:46:44 <lambdabot>     In the first argument of `k', namely `k'
02:46:44 <Raynes> Rayne: Imposter!
02:46:57 <Rayne> oh no, you again!
02:47:08 <pastorn> haha
02:47:09 <lispy|web> The Monadic / non-Monadic separation in Haskell has also really helped me understand things better too.  When I do look at examples in Scheme I can now "see" monads between the various things and go "ah ha!"
02:47:10 <Raynes> @_@
02:47:22 <Twey> Inglorion: You could say they're *all* macros to generate the final program in IO.
02:47:26 <FunctorSalad> monadic_kid: ah
02:47:34 <Inglorion> exactly, Twey
02:47:38 <Inglorion> that's what i was trying to say
02:48:00 <Twey> So TH is really like macros in macros â€” a level above what you do in Lisps.
02:48:15 <Inglorion> waaaaaaiiiit i haven't had breakfast yet
02:48:17 <lispy|web> Twey: well, I don't know about that.
02:48:20 <Inglorion> it's too early to think about metamacros!
02:49:04 <lispy|web> Twey: my one use of TH in haskell was to read in my program source, parse it with Language.Haskell, inspect the AST a bit and generate some code.  That's a typical lisp macro
02:49:30 <FunctorSalad> (defun QUOTE (form) `',form)? ;)
02:50:21 <scree> so, with TH anyway, I thought the point was that macros and meta-macros are the same, since the transforming & transformed languages are the same
02:50:55 <Inglorion> also, time to be adding Haskell to my resume. i figure i know it about as well as Java - that is, i have to look up everything all the time, and i don't know some of the more esoteric/interesting features
02:50:57 <Twey> lispy|web: Aye, some of the purposes are the same
02:50:58 <lispy|web> scree: oh
02:51:22 <Inglorion> this after having been writing Java for years, and writing one Haskell program ;-)
02:51:35 <lispy|web> Inglorion: my rough measure is: I found and could articulate a bug in de facto compiler :)
02:51:38 <Twey> Inglorion: There are more pressing things to learn about Haskell than TH
02:52:13 <Inglorion> lispy|web: don't make me think about all those times i crashed the Sun JVM ...
02:52:19 <Twey> Haha
02:52:36 <lispy|web> Inglorion: oh, so you know Java ;)
02:52:49 <lispy|web> But seriously, it's a reasonable metric
02:52:58 <lispy|web> It means you've actually done something non-trivial typically
02:53:03 <Inglorion> true
02:53:09 <lispy|web> and being able to articulate it means you know something about the language itself
02:53:24 <Inglorion> on the other hand, it means you can never really master a language if you use an implementation that doesn't have any bugs
02:53:31 <Inglorion> let me find my whitespace compiler for you ...
02:53:37 <lispy|web> hehe
02:54:02 <lispy|web> Inglorion: yeah, when formally verified compilers for languages with formal semantics are common place I'll find a new metric
02:54:13 <lispy|web> Until then...
02:54:14 <Inglorion> in fact, i probably should put that compiler online
02:54:28 <Inglorion> it is, i believe, the fastest whitespace implementation in the world
02:54:55 <FunctorSalad> the docs could still be buggy (typos etc)
02:56:02 <lispy|web> The one time my metric failed me was when I learned Scala.  Within a week of my project I had found 2-3 bugs.
02:56:08 <Inglorion> anyway, the metric i use for knowing a language is, basically, could i sit down and write a simple but useful program without having documentation or a language implementation available?
02:56:16 <lispy|web> I've heard their implementation is more robust now
02:57:18 <lispy|web> (perhaps in part because I filed bug reports!)
02:58:42 <FunctorSalad> is 'fix error' useful? ;)
02:58:53 <arcatan> hmm, only language i could add to my resume by lispy's metric is C. hmppph.
02:59:05 <lispy|web> FunctorSalad: it doesn't correct the problem if that's what you wanted :)
02:59:45 <FunctorSalad> lispy|web: my first thought for a handwritable haskell program that "does something interesting" ;)
03:00:13 <lispy|web> heh, wrong value for interesting I guess
03:00:45 * lispy|web <3 fix
03:02:28 <Inglorion> FunctorSalad: i usually do something like implementing ls, writing an IRC client, or a logfile parser, or a compiler
03:02:59 <kmc> yeah TH isn't "metamacros"
03:03:01 <FunctorSalad> lispy|web: really? I don't think I've ever seen a pointless use of it, and isn't that the only thing it's good for which mightn't as well be a where clause?
03:03:02 <Inglorion> my whitespace compiler, for example, i wrote when i was away from the civilized world for a weekend and got bored
03:03:27 <FunctorSalad> fix (\f x -> ...) <-> f where f x = ...
03:03:35 <Inglorion> i had a laptop with me, and i decided to see if i could write ocaml without having a manual or a language implementation
03:03:43 <Inglorion> i happened to have the whitespace specification with me
03:03:49 <FunctorSalad> (a pointless use other than fix error, of course)
03:03:54 <lispy|web> FunctorSalad: have you read Oleg's paper about OO in Haskell?
03:04:02 <Inglorion> and when i got back home, i had a working whitespace -> x86 assembly compiler
03:04:08 <lispy|web> heh
03:04:16 <FunctorSalad> lispy|web: hmm no
03:04:31 <lispy|web> FunctorSalad: That was the first time I saw fix used for anything really
03:04:49 <Inglorion> isn't "fix error" sort of a standard joke?
03:04:52 <lispy|web> FunctorSalad: I forgot the example now, but he used it to access the 'properties' of object some how
03:04:56 <FunctorSalad> I agree `fix' still has "ceremonial" value as the primitive it can all be built upon ;)
03:04:58 <lispy|web> > fix error
03:04:59 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:05:13 <lispy|web> s/Exception/Badger/
03:05:18 <Inglorion> haha
03:05:49 <kmc> > transpose $ map fix [(1:), (7:)]
03:05:50 <lambdabot>   [[1,7],[1,7],[1,7],[1,7],[1,7],[1,7],[1,7],[1,7],[1,7],[1,7],[1,7],[1,7],[1...
03:05:55 <idnar> > fix (error . (:"Badger"))
03:05:56 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
03:06:06 <idnar> er, no
03:06:18 <idnar> > fix (error . ("Badger" ++))
03:06:19 <lambdabot>   "*Exception: Badger*Exception: Badger*Exception: Badger*Exception: Badger*E...
03:06:20 <Inglorion> lambdabot <3
03:06:23 <Inglorion> i like this channel
03:06:30 <kmc> basically my response to "that's useless because we have syntax for it" is to come up with a higher-order use
03:06:54 <kmc> you can imagine a function which returns a function, that should sometimes be used recursively and sometimes plugged into something else
03:07:10 <Inglorion> exactly, kmc
03:07:12 <kmc> or you can imagine dynamically composing together a list of functions then tying the knot at the outside
03:07:25 <kmc> :t fix . foldr (.) id
03:07:26 <lambdabot> forall a. [a -> a] -> a
03:07:45 <Inglorion> the reason you want a language built out of orthogonal constructs is that you can compose them in ways nobody has ever thought of before
03:07:47 <lispy|web> ?hoogle [a -> a] -> a
03:07:47 <lambdabot> Data.Function fix :: (a -> a) -> a
03:07:48 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
03:07:48 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
03:07:53 <kmc> > fix . foldr (.) id $ [('x':), ('y':)]
03:07:54 <lambdabot>   "xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy...
03:08:29 <aristid> :t foldr (.) id
03:08:29 <Inglorion> if you have a language full of hard-coded constructs, it may look like it's just as good as a language where the same constructs are implemented as macros or using higher-order functions
03:08:30 <lambdabot> forall b. [b -> b] -> b -> b
03:08:37 <kmc> > fix . foldr (.) id $ [('x':), (\(x:xs) -> let y = succ x in (y:y:xs))]
03:08:38 <lambdabot>   "xyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy...
03:09:02 <idnar> :t sequence :: [a -> a] -> a
03:09:03 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> [a]
03:09:03 <lambdabot>     In the expression: sequence :: [a -> a] -> a
03:09:06 <aristid> (foldr (.) id) chains all the functions in a list, right?
03:09:08 <Inglorion> but there is a big difference, and it is that, without a way to write your own macros/hofs, the hard-coded constructs are all you'll ever get
03:09:13 <FunctorSalad> kmc: not a bad general approach ;) I hadn't given much thought to it in my defense
03:09:21 <Inglorion> prime example of that is COBOL
03:09:25 <Inglorion> the original
03:09:30 <idnar> er, not quite
03:09:35 <Inglorion> which didn't allow you to define your own functions
03:09:40 <lispy|web> I heard that COBOL finally got user definable functions
03:09:44 <lispy|web> yeah
03:09:50 <Inglorion> because "that would make it hard for people to read the programs"
03:09:59 <Inglorion> the same argument has been used against macros
03:09:59 <lispy|web> irony++
03:10:16 <Inglorion> and, undoubtedly, against higher order functions, currying, lazy evaluation, and $
03:10:34 <lispy|web> I admit, at first I really struggled with ($)
03:10:41 <lispy|web> But, I came from lisp
03:10:45 <Inglorion> me too, coming from lisp
03:10:54 <kmc> @djinn [a -> a] -> a
03:10:55 <lambdabot> Error: Undefined type []
03:10:57 <geheimdienst> c has no memory management because "that would take a few milliseconds of processor time", so better spend a few hours of programmer time on it
03:10:59 <geheimdienst> ;-)
03:11:14 <Inglorion> that was until a friend who also came from haskell from lisp explained it to me
03:11:34 <aristid> Inglorion: hah, that's precisely the reason i had to tediously change the same code over and over in some files because using modules would obviously be too difficult for the code reviewers to understand
03:11:36 <FunctorSalad> kmc: maybe it is just that I'm just not fluid yet in looking at recursive definitions in terms of the functional
03:11:41 <lispy|web> These days I just think of ($) as an infix identity function specialized to functions
03:11:48 <FunctorSalad> (of which the `fix' is taken)
03:11:49 <Inglorion> aristid: there you go, another example
03:12:00 <kmc> geheimdienst, sometimes those milliseconds do matter, and you really should use C
03:12:16 <kmc> sometimes a thousandth of a millisecond matters
03:12:36 <aristid> it is possible to get a certain amount of convenience even without a GC
03:12:40 <Inglorion> so i have been saying that there is a real difference between languages based on what methods of abstraction they offer
03:12:43 <aristid> but i digress
03:12:47 <geheimdienst> kmc, sure, but usually they don't
03:12:58 <aristid> did you know that perl does not have a GC?
03:13:01 <kmc> geheimdienst, "usually" over the space of all problems, or all problems for which C is used?
03:13:06 <Inglorion> and languages which allow you to abstract more patterns are, in the end, more pleasant to program in
03:13:10 <kmc> aristid, sure, you can do deterministic ref counting.  though that's not free either
03:13:20 <lispy|web> aristid: I tihnk automatic ref counting counts
03:13:26 <kmc> it's also worth noting that GC can be faster than manual allocation
03:13:30 <kmc> it really depends on the situation
03:13:34 <aristid> ref counting doesn't create milliseconds of latencies
03:13:44 <geheimdienst> kmc, i think both ... i think c is over-used. sure it has its niche, but imho too many people unthinkingly use it for too much stuff
03:13:51 <kmc> yes
03:13:54 <kmc> like a fucking AIM client
03:14:01 <aristid> kmc: i think it's quite obvious that an advanced GC can be faster than ref-counting
03:14:02 <monadic_kid> Leksah is quite good now
03:14:03 <FunctorSalad> :)
03:14:10 <kmc> thanks, pidgin, every time some jackass on MSN can own my machine by sending me a malformed fucking smiley face
03:14:11 <geheimdienst> kmc exactly that kinda thing
03:14:31 <lispy|web> kmc: haha, yeah. pidgin....virtual memory in the gigs, wtf?
03:14:35 <Inglorion> that's the problem i have with C
03:14:50 <FunctorSalad> kmc: did it actually have such vulnerabilities at some time?
03:14:50 <Inglorion> using it for writing applications doesn't only harm the developer
03:14:53 <Inglorion> it also harms the users
03:15:12 <FunctorSalad> (I've been using it all the time after all :o)
03:15:33 <lispy|web> Maybe we should write an irc/jabber client in Haskell
03:15:34 <Inglorion> i think these two always go together (more developer effort required means fewer features and more bugs)
03:15:46 <lispy|web> Formally verify parts of it in Haskabelle
03:16:06 <Inglorion> but in C's case, it's worse, because you don't necessarily need to expend extra effort to put out a program that compiles and runs - but it may still be full of security holes
03:16:19 <aristid> lispy|web: i think there's a better use of time than writing a fucking irc client
03:16:28 <lispy|web> We could ensure there are no exploits that way and also ensure some separation properties/non-interference between conversations
03:16:28 <kmc> FunctorSalad, think so
03:17:06 <lispy|web> aristid: the point would be to make a client with high assurance properties
03:17:24 <lispy|web> do something the C implementations haven't even thought of yet
03:17:45 <arcatan> aoeuoaeuaosuhoeunaotuhnsousaoutsn
03:17:45 <Inglorion> also w.r.t. languages not offering powerfull enough abstractions: people generate C code with yacc, whereas Parsec is actual Haskell code
03:17:57 <geheimdienst> lispy|web, as a noob project, i'm actually planning to write a fuse thingy that exposes libpurple (from pidgin) as a filesystem
03:18:06 <Inglorion> haha
03:18:06 <geheimdienst> sometime soon
03:18:17 <Inglorion> what sort of files and ioctls would you expose?
03:18:30 <idnar> arcatan: testing dvorak out?
03:18:39 <lispy|web> geheimdienst: what is libpurple?  sorry, I'm not familiar with the technologies in question
03:18:48 <Inglorion> "/irc/Inglorion/freenode.net/#haskell"? ;-)
03:18:57 <geheimdienst> well /irc/#haskell, /icq/joe, /jabber/jeff, all of which you can tail -f
03:18:58 <FunctorSalad> Inglorion: we have happy ;)
03:19:15 <lispy|web> geheimdienst: oh, that's kind of cool
03:19:32 <nus-> mount -o bind /jabber /icq
03:19:41 <FunctorSalad> (and I'd think it still does more optimization than parsec in some cases?)
03:19:42 <Inglorion> FunctorSalad: indeed. but i'd say that parsec offers perfectly elegant grammars right in your haskell code
03:19:46 <Inglorion> try doing the same in C ...
03:19:53 <geheimdienst> what fascinates me that you can write your own "client" as a very short shell script with standard unix tools (tail, echo, ...)
03:20:00 <tomberek> hey, trying to get a better understanding of type classes.  When should a function be in the typeclass, and when there be a constraint on the function outside of the typeclass?
03:20:20 <kmc> arcatan, nice dvorak you've got there
03:21:11 <tomberek> is there a general rule?
03:21:18 <kmc> tomberek, in the class if it needs to be defined separately for each instance
03:21:34 <kmc> (or if you want to allow that, for performance)
03:21:41 <nus-> tomberek, what function?
03:21:46 <kmc> outside the class if it has a uniform definition in terms of the class methods
03:21:52 <tomberek> kmc: sure, but what about defaulting?
03:21:57 <kmc> tomberek, what about it?
03:22:25 <lispy|web> geheimdienst: you could have an emacs client just with autoreload and some sort of "save on enter" hook
03:22:26 <tomberek> so anything that can be defaulted, can be moved out of the class
03:22:37 <tomberek> so why have it in the class?
03:22:42 <FunctorSalad> do you mean methods which are derivable from other methods, like (***) in arrow? otherwise you have no choice
03:23:13 <FunctorSalad> (in this case the method is sometimes left in the class so you can provide a more efficient implementation than the derived one)
03:23:28 <arcatan> kmc, idnar: heh, my ssh session just broke. i do use dvorak, though
03:23:33 <geheimdienst> lispy|web, i'm a vi user, but that emacs thing sounds perfectly reasonable
03:23:43 <idnar> tomberek: if you put the function outside of the type class, you can't override it
03:23:47 <ivanm> there's a haskell-mode for vim as well IIRC
03:23:52 <kmc> tomberek, err, i don't think you're talking about "defaulting" which is a specific technical aspect of the Haskell type system
03:24:03 <kmc> tomberek, you mean just that class members can be declared with a default definition
03:24:09 <kmc> that's so that you can override it on a type-by-type basis for efficiency
03:24:12 <tomberek> so, just in case, the safe solution is it in the class? in case someone smarter comes along with better ideas
03:24:17 <kmc> if it's not in the class, you can't do that
03:24:18 <geheimdienst> that's what i find so fascinating, files and directories are understood by just about every application and every programming language
03:24:31 <FunctorSalad> (btw, it seems like this could be dealt with with {-# RULES #-}
03:24:39 <Inglorion> yes, geheimdienst. FUSE should have been there ages ago
03:24:40 <FunctorSalad> to unreliable?)
03:24:42 <FunctorSalad> *too
03:24:44 <kmc> tomberek, sort of.  the downside is that usually you'll have some law about how the methods should relate
03:24:53 <arcatan> geheimdienst: if you like that, maybe you should take a look at Plan 9
03:25:00 <kmc> it'd be bad if you wrote a Ord instance where x < y = True but compare x y = EQ
03:25:02 <Inglorion> i remember when i implemented a network file system and wanted to get it to act like an actual filesystem
03:25:10 <kmc> however this is totally possible to do
03:25:18 <Inglorion> so i set out to write kernel modules for Linux and NetBSD
03:25:25 <Inglorion> and i never completed any of them
03:25:33 <kmc> this would be avoided if the only Ord method was "compare" and (<) was defined in terms of it, outside the class
03:25:35 <geheimdienst> arcatan, yeah i've looked at that, great ideas
03:25:35 <Inglorion> it was just too hard, too undocumented, too many system crashes
03:25:40 <FunctorSalad> it even has a haskell binding btw :)
03:25:49 <FunctorSalad> wanted to try it some time
03:25:58 <tomberek> kmc : got it... so if I want a law that is enforced, put it outside the class with constraints, otherwise put it in the class for optimizing possibilities
03:26:21 <kmc> tomberek, the other downside is that sometimes you want an "implement one of f or g" scenario, and so the defaults have a non-productive infinite mutual recursion
03:26:39 <Inglorion> plan 9 is kind of a sad story
03:26:50 <kmc> and there's no check for that
03:26:52 <tomberek> kmc : whoa.. what?
03:26:58 <Inglorion> lots of good ideas that were killed because of licensing restrictions and attitude problems
03:27:04 <aristid> Inglorion: you don't cry for MULTICS, do you?
03:27:23 <kmc> tomberek, class Eq a where { (==), (=/) :: a -> a -> Bool; x == y = not (x /= y); x /= y = not (x == y) }
03:27:31 <geheimdienst> inglorion, also, the "just kinda good enough" is the enemy of the "better"
03:27:37 <kmc> tomberek, obviously this is a disaster unless you override one of (==) or (/=) in the instance
03:27:42 <kmc> but there's no check that you've done so
03:27:46 <kmc> data T = T; instance Eq T where { }
03:27:55 <kmc> now (T == T) will loop for a while and then stack overflow ;P
03:27:57 <tomberek> yeah,,, ok
03:28:00 <kmc> bad times
03:28:36 <tomberek> hm... is there an extension or something where you can enforce a  "this or that" to be declared?
03:28:55 <Inglorion> aristid: i don't cry for MULTICS, but that may just be because i know virtually nothing about it
03:29:05 <kmc> tomberek, none i know of
03:29:10 <tomberek> or a way to enforce laws on methods in the class?
03:29:19 <kmc> that would in general require dependent types
03:29:35 <kmc> you can write typeclass-generic QuickCheck properties
03:29:47 <Inglorion> geheimdienst: what are you referring to that is "just kinda good enough"?
03:29:50 <tmug> is there some simpler way to convert String/[Char] to [GHC.Word.Word8] than 'map toEnum (map fromEnum "foobar")' ?
03:30:07 <kmc> map f (map g xs)  === map (f . g) xs
03:30:14 <kmc> :t map (toEnum . fromEnum)
03:30:16 <lambdabot> forall a a1. (Enum a, Enum a1) => [a1] -> [a]
03:30:47 <tmug> hmm.. true..  thanks
03:30:55 <kmc> tomberek, but yeah, when you define a monad in Agda, it's pretty great... you give five values: "return", "bind", and proofs of left/right identity and associativity :D
03:31:48 <tomberek> hm.. that sort of enforced monad is nice.... nothing close to that for us?
03:32:37 <geheimdienst> inglorion: well, the mainstream unix oses, linux and so on. i've always had the impression that plan 9 also didn't get traction because everyone was like "gee you plan 9 thingy sounds great, but i have my linux here which is maybe not quite as fancy, but it's pretty okay for me, so i'ma stick with that for now"
03:32:41 <kmc> yeah tomberek
03:32:54 <Inglorion> ah, right
03:33:04 <Inglorion> well, that's the old "worse is better" story again
03:33:16 <kmc> tomberek, just use Agda ;)
03:33:19 <kmc> it's pretty awesome
03:33:24 <Inglorion> plan 9 was held back at least in part by Bell's licensing policy
03:33:25 <kmc> it's super-Haskell
03:33:29 <Inglorion> meanwhile, people worked on linux
03:33:50 <Inglorion> and now, i think GNU/Linux is a far more nicer system to work with than Plan 9
03:33:50 <kmc> that's also what happened with Hurd
03:33:59 <kmc> that's why we still have GNU/Linux and not just GNU ;P
03:34:20 <geheimdienst> yeah the licensing was another big problem with plan 9
03:34:41 <Inglorion> and, looking back ... we have several open source operating systems now
03:35:16 <Inglorion> FreeBSD, GNU, NetBSD, OpenBSD, they're all sort of similar
03:35:31 <tomberek> kmc: is there a practicality reason that Haskell doesn't have dependent types? theoretical?
03:35:37 <geheimdienst> is the hurd actually working these days? i was under the impression that it always suffered from a dose of over-designed impossible-to-implement circlejerking
03:36:01 <dv-> Hurd works but lacks support for hardware
03:36:02 <kmc> tomberek, type inference is impossible for DT
03:36:10 <Inglorion> then there are a few that have people claiming they are or at least were so much better, but yet they died: VMS, BeOS, pretty much all the commercial Unices, perhaps also Plan 9 (maybe it's actually still alive)
03:36:16 <kmc> but it's also impossible for some relatively standard Haskell extensions like rank-3 types
03:36:24 <Inglorion> and i think the main difference here is that all the dead OSes were proprietary
03:36:27 <tomberek> kmc: so what does Agda do?
03:36:36 <kmc> tomberek, you're not guaranteed inference
03:36:43 <kmc> you have to write signatures sometimes
03:36:44 <Inglorion> and if your OS is proprietary, you have to compete with behemoths like Microsoft and IBM
03:36:48 <kmc> which is true in GHC with some extensions as well
03:36:52 <Inglorion> chances are you won't make it
03:37:11 <tomberek> kmc: it seems like people write signatures all the time, is that so bad, to require it?
03:37:19 <geheimdienst> inglorion, on the plus side, even if an os dies, its ideas can live on. for example, the suckless guys ported a number of plan9 things to linux
03:37:26 <Inglorion> exactly
03:37:36 <kmc> tomberek, not sure.  it's still an active research topic
03:37:37 <FunctorSalad> System.Process.close_fds: "Close all file descriptors except stdin, stdout and stderr in the new process" -- when should one do that?
03:37:52 <Inglorion> unless, of course, the ideas are covered by patents >:-(
03:37:53 <FunctorSalad> are these the FDs of the current haskell program?
03:38:08 <kmc> tomberek, it's yet to be fully worked out how to write programs in DT languages elegantly
03:38:15 <FunctorSalad> (which is to create a process -- close_fds is an option for creating a process)
03:38:26 <tomberek> kmc: perhaps where if you didn't include enough sigs, it would infer, but would reject DT, but adding sigs allowed them.
03:38:28 <kmc> (or in any language really ;P)
03:38:38 <Inglorion> but i say, bring on the innovation - whether proprietary or open
03:38:51 <Inglorion> either way, the world will benefit
03:38:56 <FunctorSalad> is this to prevent the child from interferring with your programs fds? if that's even possible; I'm clueless
03:39:17 <kmc> basically the question of "how to make a practical programming language with dependent types" is still very much open
03:39:48 <drksd> kmc: define Â« practical Â» :-Â°
03:39:48 <Inglorion> i think there is a lot of cross-pollination between OS X, Ubuntu, and Windows these days - new ideas are tried, and good ideas are copied
03:39:54 <kmc> and i guess it's judged that adding dependent types to GHC would add a ton of complication to something that's not only a research project
03:39:58 <kmc> and that it's too early
03:40:27 <kmc> however, i'd like to see us move in that direction (whether "us" is the Haskell language or just the people who think right now that Haskell is the best language)
03:40:28 * geheimdienst prefers independent types. a number of well-known types actually declared their independence a few hundred years back.
03:40:30 <FunctorSalad> heh is this even considered? it'd be a whole new language IMHO
03:40:48 <kmc> because DT is actually a lot simpler than the pile of extensions in GHC
03:40:51 <FunctorSalad> (this=adding dep types to ghc)
03:41:09 * hackagebot serialport 0.3.3 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.3.3 (JorisPutcuyps)
03:41:12 <Inglorion> hehe, geheimdienst. by the way, can i ask which country your in?
03:41:26 <tomberek> kmc: thanks for the info... would you suggest I try Agda?    (Daskell - DT'd Haksell)
03:41:33 <FunctorSalad> kmc: I'd qualify that... it is a simpler solution to much of the two-level stuff in haskell, but it introduces problems of its own
03:41:54 <kmc> tomberek, Agda is very cool
03:41:57 <FunctorSalad> (not sure whether these are simpler)
03:41:57 <kmc> tomberek, as is Coq
03:42:09 <Inglorion> i'm in amsterdam, myself, and your nick "geheimdienst" made me wonder if you might be somewhere nearby :-)
03:42:10 <drksd> tomberek: Agda seems like a sweet language yes :)
03:42:12 <kmc> i'd read www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf and http://www.cis.upenn.edu/~bcpierce/sf/
03:42:21 <geheimdienst> yes, germany actually
03:42:31 <drksd> (personaly IÂ use Coq, but whatever :p)
03:42:36 <earthy> 'nearby' is subject to interpretation, obviously
03:43:07 <Inglorion> nice. it's interesting that geheimdienst works in both german and dutch :-)
03:43:07 <tomberek> kmc: i like your idea of making Haskell DT'd instead of all these extensions,, i get lost in the extensions sometimes
03:43:15 * geheimdienst knows nothing about dependent types, but he will be very disappointed if they don't use "declaration of dependence" as a technical term for something
03:43:22 <FunctorSalad> (like Coq's pattern matching monstrum^Wconstruct ;))
03:43:23 <tomberek> working on associated types nowadays
03:44:02 <geheimdienst> nice, i didn't know it was the same word
03:44:06 <kmc> yes
03:44:15 <dom1> Hi I am trying to install the Haskell Platform
03:44:27 <kmc> GHC Haskell has a lot of duplication between value-level abstraction and type-level abstraction
03:44:36 <dom1> I followed the instructions on http://hackage.haskell.org/platform/linux.html
03:44:38 <drksd> FunctorSalad: I agree on that, Coq pattern matching syntax isâ€¦ well :D
03:44:40 <kmc> DT languages have first-class types so you get to use the same abstraction facilities
03:44:43 <kmc> that's why they're simpler
03:44:54 <dom1> dom1@fourier:~> cabal install
03:44:54 <dom1> Resolving dependencies...
03:44:54 <dom1> cabal: dependencies conflict: ghc-6.12.1 requires directory ==1.0.1.1 however
03:44:54 <dom1> directory-1.0.1.1 was excluded because ghc-6.12.1 requires directory ==1.0.1.0
03:45:04 <Inglorion> geheimdienst: actually, it would be "geheime dienst" in dutch. but any time i have a secret, i'll be sure to hand it to you for safe keeping ;-)
03:45:12 <dom1> Any ideas?
03:45:18 <tomberek> kmc: does agda benefit from many of the same performance aspects?
03:45:29 <drksd> kmc: do you use Coq or Agda ?
03:45:43 * geheimdienst actually understood that last bit about types being first-class. sounds great. geheimdienst is all for removing impedance mismatch between types and values.
03:45:50 <drksd> (yeah, i'm curious)
03:45:53 <aristid> agda seems to have unnecessary syntactic deviations from haskell
03:45:54 <nus> dom1, do you have ghc already installed?
03:46:09 <aristid> "For instance, not:Bool->Bool would not be a valid type signature for the not function, since it is in fact a valid name."
03:46:17 <kmc> drksd, both
03:46:22 <drksd> oh ok :D
03:46:34 <kmc> aristid, yeah.  DT is not the only experimental aspect of Agda
03:46:44 <kmc> i wish haskell had agda's mixfix operators too
03:46:47 <Inglorion> geheimdienst: @types and values: have you taken a look at Seed7 ?
03:46:49 <dom1> @nus: yes
03:46:49 <lambdabot> Unknown command, try @list
03:46:57 <FunctorSalad> geheimdienst: you may like http://strictlypositive.org/winging-jpgs/ ;)
03:47:14 <dom1> dom1@fourier:~/Downloads/ghc-6.12.1> ghc --version
03:47:14 <dom1> The Glorious Glasgow Haskell Compilation System, version 6.12.1
03:47:29 * geheimdienst is googling seed7
03:47:34 <Inglorion> http://seed7.sourceforge.net/
03:48:00 <Inglorion> in particular, "Types are first class objects (Templates and generics can be defined easily without special syntax)."
03:48:00 <aristid> kmc: is there a good compiler for agda?
03:48:13 <nus> dom1, uninstall the former
03:48:37 <dom1> nus: ok but why will that help?
03:48:39 <aristid> Inglorion: it's an imperative language seemingly
03:49:13 * hackagebot msgpack 0.2.2 - A Haskell binding to MessagePack  http://hackage.haskell.org/package/msgpack-0.2.2 (HideyukiTanaka)
03:49:41 <nus> dom1, in the error message it's the former ghc's dependency preventing installation of the latter
03:49:44 <Inglorion> yes. Seed7 is definitely more like Ada than like Haskell
03:50:03 <dom1> dom1@fourier:~> ghc --version
03:50:03 <dom1> bash: ghc: command not found
03:50:10 <dom1> But of course now I have
03:50:10 <monadic_kid> const should be the default no the other way around i think
03:50:11 <Inglorion> i haven't really used it myself, but i know about it from comp.lang.misc
03:50:14 * hackagebot msgpack-rpc 0.1 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.1 (HideyukiTanaka)
03:50:23 <dom1> dom1@fourier:~> cabal install
03:50:24 <dom1> cabal: ghc version >=6.4 is required but it could not be found.
03:50:24 <dom1> dom1@fourier:~> om1@fourier:~> cabal install
03:50:31 <Inglorion> monadic_kid: agree very much
03:50:36 <FunctorSalad> is there a good reason why the major DT languages are total btw? except that it makes the proofs trustworthy ;)
03:50:48 <FunctorSalad> but from a programming POV...
03:50:53 <dom1> nus: so I am no further forward
03:51:03 <nus> dom1, don't use both cabal and the distribution package manager to install hackages/ghc
03:51:15 <nus> dom1, stick to something
03:51:27 <dom1> It used to work :-(
03:51:43 <dom1> I've been using ghc for 15 years
03:51:50 <nus> dom1, whut?
03:52:42 <dom1> ok I've downloaded http://haskell.org/ghc/dist/6.12.1/ghc-6.12.1-x86_64-unknown-linux-n.tar.bz2
03:52:45 <FunctorSalad> dom1: /usr/bin/ghc vs /usr/local/bin/ghc? random guess
03:52:49 <dom1> So no package manager
03:52:57 <tomberek> kmc: i'm seeing a lot of similarity between Haskell and Agda, why would someone use Haskell if all they lose is inference?  performance?
03:53:06 <FunctorSalad> (if you're switching between the distribution's ghc and the tarball...)
03:53:19 <dom1> I have no ghc now
03:53:41 <geheimdienst> yes guys, what's the story on native package manager vs. cabal? on ubuntu, i tried to use the native packages, but they were out of date often. so when moving to arch, i installed absolutely everything via cabal. but on -cafe the other day, someone said "cabal is not a package manager" and such ... so what's actually recommended?
03:53:50 <ivanm> dom1: which linux distribution do you use?
03:54:01 <dom1> dom1@fourier:~/Downloads/ghc-6.12.1> ./configure
03:54:01 <dom1> checking for path to top of build tree... ./configure: line 1687: utils/ghc-pwd/ghc-pwd: cannot execute binary file
03:54:01 <dom1> configure: error: cannot determine current directory
03:54:06 <FunctorSalad> tomberek: that you have to do serious theorem proving to even get the compiler to accept some things? for starters ;)
03:54:07 <ivanm> geheimdienst: if you use a distro that's good (e.g. arch or gentoo), use the system package manager
03:54:08 <dom1> opensuse
03:54:19 <kmc> tomberek, for one, Agda is way less mature
03:54:23 <kmc> in design and implementation
03:54:30 <ivanm> geheimdienst: see the end of http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
03:54:40 <Raynes> geheimdienst: Don't care what other people think about it, but I use cabal. Already got bitten back in Ubuntu 8.04 by crazy screwed up Haskell packages. :p
03:54:55 <ivanm> Raynes: s/Haskell // :p
03:55:04 <FunctorSalad> tomberek: at least in coq... if your recursive function isn't structurally decreasing, you need to prove that there's some well-founded ordering on the argument that decreases with every call
03:55:09 <dom1> I seem to need a binary called ghc-pwd
03:55:27 <Inglorion> geheimdienst: perhaps helpful: on debian/ubuntu, for ruby, i use distro packages for the basics (ruby, irb - like ghc and ghci) and gem (like cabal), then gem (cabal) for the rest
03:55:36 <FunctorSalad> non-termination would allow you to prove anything, after all
03:55:38 <tomberek> FunctorSalad: sure, to make sure it terminates, right?
03:55:48 <FunctorSalad> fix id = proof for anything
03:56:07 <FunctorSalad> "if a follows from a, then a" is its logical reading, after all :)
03:56:12 <kmc> you can have DT without this totality restriction
03:56:15 <geheimdienst> ivanm, yeah i looked at the blog entry, thanks a lot for explaining the whole thing
03:56:15 <Inglorion> problem i have with programming-language-specific tools is that they will often want to give you the latest version of some package, whereas i tend to care more about stability - i want the code i write now to still work in 3 years
03:56:15 <aristid> :t fix id
03:56:16 <lambdabot> forall a. a
03:56:19 <kmc> but it's less useful
03:56:28 <aristid> > fix id
03:56:32 <lambdabot>   mueval-core: Time limit exceeded
03:56:35 <tomberek> does this non-termination preclude correct programs?
03:57:14 <dom1> Do I have to build ghc from source?
03:57:25 <tomberek> i guess it matters how we define 'correct'... we want certain programs (servers for example) not to terminate
03:58:05 <Inglorion> in the programming language i am designing, i want to have a subset that is strongly normalizing
03:58:06 <FunctorSalad> and then there's the equality issue... (dependent types show you how much you don't really know what exactly equality means o_o)
03:58:07 <aristid> tomberek: but only because they're waiting for requests
03:58:13 <Inglorion> so you can write programs that are guaranteed to terminate
03:58:15 <Raynes> ivanm: Plus, I hate out of date packages. I hate them so badly.
03:58:21 <FunctorSalad> (as you've always used it in math)
03:58:25 <dom1> dom1@fourier:~/Downloads/ghc-6.12.1> ./utils/ghc-pwd/ghc-pwd
03:58:25 <dom1> bash: ./utils/ghc-pwd/ghc-pwd: cannot execute binary file
03:58:34 <nus> dom1, what distro are you using?
03:58:57 <Raynes> ivanm: I'm one of those people who'd rather compile 1.3.3 rather than get 1.3.2 off the package manager for virtually anything.
03:58:58 <kmc> data EQ a b where { Refl :: Eq a a }
03:59:09 <dom1> nus: opensuse
03:59:20 <FunctorSalad> kmc: that's called "John Major's Equality" in coq :D
03:59:54 <FunctorSalad> no wait, what you wrote is still vanilla equality
04:00:28 <FunctorSalad> JMEq was a bit more heterogenous, but I don't remember how exactly
04:00:28 <kmc> what's the other?
04:01:05 <FunctorSalad> wait, you need three arguments even in plain equality ;)
04:01:23 <kmc> FunctorSalad, sure, one is the implicit "forall a b." in Haskell
04:01:30 <kmc> or rather "forall a"
04:01:36 <FunctorSalad> data EQ T (a:T) (b:T) where Refl :: forall T (a:T), Eq a a
04:02:02 <FunctorSalad> data JMEq T S (a:T) (b:S) where Refl :: forall T (a:T), JMEq T T a a
04:02:04 <FunctorSalad> IIRC
04:02:18 <FunctorSalad> (yes, it makes some odd difference o_o)
04:02:22 <kmc> hmm i ought to read cpdt sometime
04:02:39 <FunctorSalad> then there's "dependent equality" which goes something like
04:03:08 <FunctorSalad> EqDep T (f:T->Type) t1 t2 (a:f t1) (b:f t2)
04:03:26 <FunctorSalad> funny isn't it :D
04:03:46 <scree> I'm still not getting the John Major joke
04:03:49 <aristid> what is data ... where?
04:03:56 <scree> is this something to do with Currying, or ...
04:03:59 <aristid> (in haskell)
04:04:03 <kmc> aristid, GADT syntax
04:04:05 <kmc> an extension
04:04:33 <nus> dom1, have you tried installing the opensuse haskell-platform package
04:05:07 <scree> or Currieing, I guess
04:05:14 <FunctorSalad> (the general underlying problem with these equalities is that you might have to prove things equal whose types aren't even syntactically equal)
04:06:07 <FunctorSalad> (and there are some restrictions on replacing equals for equals)
04:06:37 <aristid> kmc: ah, the wikibook is very helpful
04:07:20 <FunctorSalad> resulting in funny errors about non-well-typed intermediate expressions... maybe it's just me but I found it all quite difficult ;)
04:07:44 <aristid> GADTs aren't difficult to understand at all \o/
04:08:03 <Cale> aristid: Yeah, all the hard work is in the typechecker :)
04:08:28 <Inglorion> making the computer do the work :-D
04:08:35 <FunctorSalad> indeed, they managed to make it feel like a real extensional equality ;)
04:08:40 <aristid> Inglorion: that's how it's supposed to be!
04:08:44 <Inglorion> exactly!
04:08:58 <FunctorSalad> (the Foo ~ Bar equality in haskell brought into context by gadt pattern matching)
04:09:19 <Inglorion> which is why i ought to be grateful that pretty much the whole industry uses Java, C#, C++ and C
04:09:35 <Inglorion> if they'd use Haskell, they would be far too efficient and i would be out of work ;-)
04:09:39 <dom1> nus: my yast does not seem to know anything about haskell-platform
04:10:22 <scree> FunctorSalad: please put me out of my misery.  The best I can find is "a term coined by Conor McBride as a sort of pun about british politics".  What is the joke?
04:11:02 <Inglorion> Twey, now with sign: http://haskell.pastebin.com/8bmLJc05
04:11:09 <geheimdienst> if inglorion ever teams up with quentin tarantino, they'll make the movie "inglorion's basterds"
04:11:17 <Inglorion> hahaha
04:11:24 <FunctorSalad> scree: I don't know about the underlying British politics either... but apparently it is that the type of JMEq makes it seem as if people (values) of different types could be equal
04:11:26 <Inglorion> i hope i don't really have any, geheimdienst ;-)
04:11:48 <FunctorSalad> but in practice, that is impossible because the Refl constructor only ever constructs proofs where the types are equal
04:11:57 <FunctorSalad> quite clever actually ;)
04:11:59 <aristid> data MarkedList             ::  * -> * -> *
04:12:04 <aristid> is this GADT syntax too?
04:12:25 <Cale> aristid: Yeah, that just explicitly states the kind of the type constructor
04:12:29 <Cale> :k Either
04:12:31 <lambdabot> * -> * -> *
04:12:33 <Cale> :k Maybe
04:12:35 <lambdabot> * -> *
04:12:35 <FunctorSalad> scree: so I think it's somehow alluding to formal-equality-of-opportunities but de-facto-inequality, or *blah*
04:12:37 <monadic_kid> does anyone put haskell source files in the extra source files part of a Cabal?
04:12:37 <Cale> :k Maybe Integer
04:12:39 <lambdabot> *
04:12:44 <Cale> :k Either String
04:12:45 <lambdabot> * -> *
04:12:47 <Cale> :k Either String Bool
04:12:48 <lambdabot> *
04:12:57 <nus> dom1, heh, it's broken: https://build.opensuse.org/package/show?package=haskell-platform&project=home%3Aldieckow
04:13:55 <FunctorSalad> scree: by comparison, usual equality has only one type parameter, and you know both values must be of the same type without looking further
04:14:23 <FunctorSalad> Eq :: forall (T:Type) (x y :T), Prop
04:14:39 <FunctorSalad> JMEq :: forall (T S:Type) (x:T) (y:S), Prop
04:15:02 <FunctorSalad> (but like I said the constructor only lets you make values where T=S)
04:15:32 <dom1> nus: and I can't get the binary package to install either
04:15:41 <scree> FunctorSalad: right, I get the type theory, it's the reference that's bugging me
04:15:44 <scree> FunctorSalad: but thanks
04:21:00 <FunctorSalad> scree: I assume there was some criticism related to this only-apparent-equality with John Major
04:21:17 <FunctorSalad> from the context...
04:21:51 <scree> if only I was older back in those days I'm sure I'd know
04:26:57 <aristid> phantom types are obsoleted by GADTs?
04:27:09 <opqdonut> no no
04:27:27 <opqdonut> phantom types are very nice with gadts
04:27:54 <aristid> opqdonut: but i thought you can put all the typed constructors directly in the GADT?
04:27:59 <opqdonut> data A; data B; data MySomething a where Foo :: MySomething A; Bar :: Int -> MySomething B;
04:28:07 <pastorn> wait... wat?
04:28:22 <pastorn> is it possible to do phantom types *without* GADTs?
04:28:39 <FunctorSalad> data Foo a = Foo
04:28:42 <aristid> pastorn: http://en.wikibooks.org/wiki/Haskell/Phantom_types
04:28:45 <FunctorSalad> not so useful maybe ;)
04:28:50 <opqdonut> sure
04:29:08 <kmc> the technique that's obsolete is
04:29:20 <opqdonut> data MyContainer a b = MyContainer b; processfirst :: MyContainer A a -> MyContainer B a; processsecond :: MyContainer B a -> a
04:29:42 <opqdonut> now you can't do the processing in the wrong order by mistake :)
04:29:49 <kmc> data Raw = Lit Int | Add Int Int | Eq Int Int;  data Exp t = Exp Raw
04:29:50 <aristid> opqdonut: well, but that's normal GADT, no special phantom type tricks
04:29:59 <kmc> add :: Exp Int -> Exp Int -> Exp Int; eq :: Exp Int -> Exp Int -> Exp Bool
04:30:15 <pastorn> aristid: the Int in "plus :: T Int -> T Int..." has nothing to do with the a in "data T a = ..."
04:30:24 <aristid> pastorn: i know
04:30:25 <pastorn> this seems much weaker than GADTs
04:30:31 <kmc> it is
04:30:43 <pastorn> since you can't control the resulting type of your construct
04:31:05 <Twey> Inglorion: number = maybe mzero return . listToMaybe . map fst . reads
04:31:13 <Twey> ;)
04:31:21 <aristid> :t maybe mzero return . listToMaybe . map fst . reads
04:31:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Read a) => String -> m a
04:31:44 <aristid> :t reads
04:31:45 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:32:44 <aristid> Twey: heh, i think there should be a convenience function for maybe mzero return
04:32:54 <aristid> maybeToMonadPlus or so
04:33:02 <nus> dom1, the platform is meant to be an *easy* way to get you running, a well-tested combo of specific package versions. There's nothing "magical" about running a Haskell Platform.
04:33:58 <dom1> nus: I know it's meant to be easy but my experience seems to be almost the reverse
04:34:22 <dom1> I think my alternatives are to build ghc from source
04:34:34 <nus> dom1, so what's wrong with sticking to the package versions your distribution rolls for you?
04:34:53 <dom1> Dunno
04:35:01 <FunctorSalad> :t guard
04:35:02 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:35:15 <dom1> All I wanted to do about 3 hours ago was install the statistics package
04:35:24 <dom1> and build a brownian bridge
04:35:38 <dom1> But cabal told me to upgrade
04:36:05 <FunctorSalad> aristid: that doesn't look much shorter
04:36:07 <FunctorSalad> ;)
04:36:08 <portnov> Q: anybody had troubles with `convertible' and `convertible-text' hackage packages incompatibility?
04:36:13 <dom1> Ok I've reinstalled ghc via the package manager
04:36:23 <portnov> their both includes Data.Convertible.Text module
04:36:36 <dom1> dom1@fourier:~> cabal install statistics
04:36:36 <dom1> Resolving dependencies...
04:36:36 <dom1> cabal: dependencies conflict: ghc-6.12.1 requires directory ==1.0.1.1 however
04:36:36 <dom1> directory-1.0.1.1 was excluded because ghc-6.12.1 requires directory ==1.0.1.0
04:36:38 <portnov> s/their/they
04:36:51 <aristid> FunctorSalad: are we golfing or what?
04:37:24 <FunctorSalad> aristid: hmm why else would you want to name the 'maybe mzero return'?
04:37:45 <aristid> FunctorSalad: because it seems somewhat idiomatic to me.
04:37:55 <aristid> @src listToMaybe
04:37:57 <Twey> aristid: I feel so, too
04:38:53 <kmc> yeah i've wanted a name for that
04:39:02 <kmc> and i think i found it in a library once, but forgot
04:39:38 <nus> dom1, 'ghc-pkg check' ?
04:39:44 <FunctorSalad> :t foldr mplus mzero
04:39:56 <FunctorSalad> @bots
04:40:30 <FunctorSalad> foldr mplus mzero :: (MonadPlus m) => [m a] -> m a
04:41:37 <kmc> that's msum
04:41:42 <kmc> from Data.Foldable
04:42:25 <FunctorSalad> foldr (\x y -> return x `mplus` y ) mzero
04:42:25 <FunctorSalad>   :: (MonadPlus m) => [a] -> m a
04:42:46 <FunctorSalad> kmc: ah right, but I was looking for this one which is like the Maybe one :)
04:43:04 <kmc> aha
04:43:20 <kmc> msum . map return
04:43:35 <FunctorSalad> oh right
04:43:48 <FunctorSalad> so "msum . map return . maybeToList" it is ;)
04:44:23 <dom1> dom1@fourier:~> ghc-pkg check -v
04:44:23 <dom1> using cache: /home/dom1/.ghc/i386-linux-6.12.1/package.conf.d/package.cache
04:44:23 <dom1> using cache: /usr/lib/ghc-6.12.1/package.conf.d/package.cache
04:44:33 <kmc> isn't Maybe already Foldable?
04:44:35 * hackagebot yaml-rpc 0.2 - Simple library for network (TCP/IP) YAML RPC  http://hackage.haskell.org/package/yaml-rpc-0.2 (IlyaPortnov)
04:45:41 <nus> dom1, now ghc-pkg -g check
04:45:45 <FunctorSalad> instance Foldable [] -- Defined in Data.Foldable
04:45:45 <FunctorSalad> instance Foldable Maybe -- Defined in Data.Foldable
04:46:25 <dom1> nus: dom1@fourier:~> ghc-pkg -g check -v
04:46:25 <dom1> using cache: /home/dom1/.ghc/i386-linux-6.12.1/package.conf.d/package.cache
04:46:25 <dom1> using cache: /usr/lib/ghc-6.12.1/package.conf.d/package.cache
04:47:10 <FunctorSalad> kmc: so "foldMap return"? ;)
04:47:23 <kmc> i'm confused what we're golfing now :P
04:47:35 <FunctorSalad> foldMap return
04:47:35 <FunctorSalad>   :: (Monad m, Foldable t, Data.Monoid.Monoid (m a)) => t a -> m a
04:47:47 <FunctorSalad> the 'maybe mzero return' I thought
04:48:08 <FunctorSalad> nice type ;)
04:50:41 <nus> dom1, hpaste 'cabal install -v3 statistics  --dry-run'
04:51:46 <dom1> nus: sorry to be ignorant but how do I "hpaste"?
04:52:11 <Saizan> dom1: i think you've this problem: http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
04:52:44 <nus> dobie_gillis, hpaste.org
04:52:50 <dom1> aha
04:55:43 <nus> damn autocompletion
04:58:05 <dom1> saizan: good theory but unfortunately no dice
04:58:30 <dom1> ghc-pkg list does show some strangeness though
04:58:49 <dom1> /usr/lib/ghc-6.12.1/package.conf.d
04:59:01 <dom1>    directory-1.0.1.0
04:59:01 <dom1>    directory-1.0.1.1
04:59:11 <ivanm> dom1: did you install anything yourself?
04:59:20 <dom1> undoubtedly
04:59:24 <ivanm> dom1: note that cabal-install will upgrade libraries like directory which shouldn't be
04:59:32 <ivanm> uninstall the second one
04:59:37 <dom1> I was trying to install statistics about 3 hours ago
04:59:48 <ivanm> dom1: not sure if anyone asked you this, but does "ghc-pkg check" bitch about anything?
05:00:08 * ivanm is only here intermittently
05:00:50 <dom1> Well it does now because remove directory broke lots of things
05:00:58 <dom1> s/remove/removing/
05:01:46 <Inglorion> Twey: ok, i'll come back next month, when i understand that ;-)
05:01:51 <dom1> Many packages are now broken
05:01:55 <nus> dom1, which version of the directory package you unregistered?
05:02:08 <dom1> 1.0.1.1
05:02:22 <mun> is anyone here familiar with description logics? i was wondering what type of reasoning problems can be handled by FOL but not by DL?
05:11:13 <dom1> dom1@fourier:~> cabal install --dry-run statistics
05:11:13 <dom1> Resolving dependencies...
05:11:13 <dom1> cabal: cannot configure vector-0.6.0.1. It requires ghc >=6.9
05:11:13 <dom1> There is no available version of ghc that satisfies >=6.9
05:11:33 <dom1> dom1@fourier:~> ghc --version
05:11:34 <dom1> The Glorious Glasgow Haskell Compilation System, version 6.12.1
05:11:46 <Saizan> dom1: it's talking about the ghc package.
05:12:52 <dom1> But cabal doesn't seem to know about a package called ghc
05:12:54 <dom1> dom1@fourier:~> cabal install --dry-run ghc
05:12:54 <dom1> cabal: There is no package named ghc. Perhaps you need to run 'cabal update'
05:12:54 <dom1> first?
05:13:00 <nus> dom1, ghc-pkg list ghc
05:13:19 <Twey> Inglorion: Huh
05:13:24 <Saizan> dom1: the ghc package comes with the ghc installation and can't be installed separatel
05:13:26 <Twey> Inglorion: Read the Typeclassopedia
05:13:31 <dom1> dom1@fourier:~> ghc-pkg list ghc
05:13:32 <dom1> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
05:13:32 <dom1> /usr/lib/ghc-6.12.1/package.conf.d
05:13:32 <dom1>    ghc-6.12.1
05:13:38 <Inglorion> i will
05:13:40 <Saizan> dom1: is it in red?
05:13:49 <dom1> Yes
05:13:55 <Saizan> ok, it's broken then.
05:14:07 <dom1> Is there any way of fixing it
05:14:18 <Saizan> reinstalling ghc :)
05:14:30 <dom1> I just did
05:14:33 <Saizan> oh, and "rm -fr ~/.ghc" to be safe
05:14:36 <int-e> well, first try without the user installed packages.
05:14:56 <dom1> ok I will uninstall ghc
05:15:03 <Saizan> ah, yeah, it might not really be broken
05:15:09 <int-e> (removing ~/.ghc will do that)
05:15:11 <Saizan> dom1: wait.
05:15:17 <Saizan> dom1: first remove ~/.ghc
05:15:32 <Saizan> i still think you had the problem above.
05:15:38 <Saizan> the one i linked.
05:15:56 <nus> he did, except both versions were in the global cache
05:16:07 <HugoDaniel> hi
05:16:22 <Saizan> nus: it's not the versions of directory that matter
05:16:43 <dom1> ok I've removed -rf .ghc
05:16:46 <Saizan> the cause will be some other package, the error about directory is just a symptom
05:17:24 <Saizan> dom1: can you install statistics now?
05:17:24 <dom1> ghc removed
05:17:45 <dom1> ghc installing
05:17:51 <nus> Saizan, meaning that's perhaps why he didn't recognize the problem described.
05:19:03 * Saizan wonders if the FAQ explanation needs some improvement
05:19:14 <dom1> dom1@fourier:~> cabal install statistics
05:19:14 <dom1> Resolving dependencies...
05:19:14 <dom1> cabal: dependencies conflict: ghc-6.12.1 requires directory ==1.0.1.1 however
05:19:14 <dom1> directory-1.0.1.1 was excluded because ghc-6.12.1 requires directory ==1.0.1.0
05:19:37 <Saizan> dom1: paste the output of "ghc-pkg list" on hpaste.org
05:21:32 <dom1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25811
05:21:33 <nus> Saizan, btw, shouldn't some --constraint 's be recommended in the FAQ?
05:22:49 <dom1> There seems to be a lot of old stuff in /usr/lib/ghc-6.12.1/package.conf.d/
05:23:40 <dom1> E.g.
05:23:42 <dom1> dom1@fourier:~> ls -ltr /usr/lib/ghc-6.12.1/package.conf.d/ | grep dir
05:23:42 <dom1> -rw-r--r-- 1 root root  1051 2010-04-11 00:36 directory-1.0.1.0-10fc46e61b67ff4a83f3e553454d003c.conf
05:23:42 <dom1> -rw-r--r-- 1 root root  1053 2010-05-30 13:08 directory-1.0.1.1-af6684ea74564977fab67b1b82b51dd9.conf
05:23:45 <Saizan> dom1: maybe you need to run ghc-pkg recache
05:23:58 <dom1> Cor I didn't know there was such a command
05:24:27 <Saizan> though i'm not sure, that might pickup the old confs anyhow
05:24:37 <Saizan> i guess you've to delete them manually
05:25:06 <Saizan> we tend to stick to user local installs, so this problem is not common
05:25:09 <dom1> After recache both are still there
05:25:55 <Saizan> yeah, you've to delete the old .confs first then
05:26:20 <Saizan> or ghc-pkg unregister them, which is the proper command
05:26:51 <Saizan> anyhow i don't see why you'd get that error..
05:27:04 <illissius> if some part of my code goes into an infinite loop and eats memory at a ridiculous pace so I have to press ctrl-c like a madman to kill it, what's the best way to find out which part of the code it is?
05:27:20 <Saizan> nus: which --constraint would help?
05:27:42 <Saizan> illissius: heap profiler?
05:28:34 <illissius> Saizan: hmm. haven't used one before -- is there more than one?
05:28:34 <Saizan> dom1: found the problem: haskell98.
05:28:48 <dom1> That's a bit cryptic
05:28:57 <Saizan> ?google GHC heap profiler
05:29:01 <dom1> In what sense is haskell98 the problem
05:29:11 <Saizan> dom1: you've two versions of the haskell98 package installed
05:29:12 <illissius> Saizan: yeah, ok. thanks :)
05:29:20 <Saizan> dom1: sorry, two copies of the same version.
05:29:27 <dom1> You are correct
05:29:51 <Saizan> and two copies of process as well.
05:29:54 <int-e> dom1: same for random and process
05:30:08 <Saizan> those are the packages that are causing problems
05:30:17 <dom1> Ok I'll delete them
05:30:24 <dom1> I'm not clear how they got there though
05:31:34 <Eludias> How do I get the filesize of a filename (String) without opening the file?
05:31:38 <Saizan> i.e. those are the packages the FAQ talked about that you had to unregister
05:32:07 <dom1> It talked about conflicts between the user and global package config files
05:32:18 <dom1> At least that's what I thought it di
05:32:24 <dom1> s/di/did/
05:33:29 <Saizan> ah, true, though the rest of the description matches :)
05:34:53 * hackagebot language-python 0.3.0 - Parsing and pretty printing of Python code.  http://hackage.haskell.org/package/language-python-0.3.0 (BerniePope)
05:35:20 <nus> Saizan, OTOH, you're right, every --constrain worth mentioning should be either in Cabal or in .cabal's
05:36:11 <Saizan> nus: ah, you mean useful --constraint's in general? not to solve this problem?
05:37:46 <nus> so, allegedly, cabal-install tried to (and did) install both directory and haskell98 dups on some wrong deptree processing?
05:38:04 <dom1> Not sure I am any further forward: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25812#a25812
05:38:17 <dom1> I appreciate the help I am getting
05:38:20 <dom1> BTW
05:38:24 <tomberek> @pl \f a b -> f a b
05:40:37 <Saizan> dom1: since you haven't installed anything yet, the easiest route in this situation is probably to "rm /usr/lib/ghc-6.12.1/package.conf.d/*" and start over
05:40:55 <Saizan> dom1: i'd do user local installations in the future btw
05:41:29 <Saizan> nus: not directory, but yeah, you mean that we should stop cabal-install from doing this somehow?
05:42:00 <dom1> saizan: don't worry I will
05:42:15 <dom1> I suppose I am used to the days when everything was global
05:43:20 * Saizan wonders if the ghc installer should wipe its global package db before copying its own there
05:44:07 <tomberek> @version
05:44:56 * hackagebot berp 0.0.1 - An implementation of Python 3.  http://hackage.haskell.org/package/berp-0.0.1 (BerniePope)
05:47:22 * nus ponders
05:48:59 <Saizan> nus: the current plan is to make cabal/ghc understand the situation
05:49:39 <Saizan> nus: though i'm not sure if that would leave you in a very easy to use situation
05:50:22 <dom1> Right I think clearing out /usr/lib/ghc/package.conf.d *and* reinstalling ghc has done the trick
05:50:42 <dom1> At least things seems to be happening at the moment
05:52:46 <kmc> tomberek, id
05:53:27 <aristid> is there a way to generalise maybe mzero mplus and foldr mplus mzero . map return?
05:53:57 <kmc> they'd generalize from MonadPlus to Alternative in a straightforward way
05:54:02 <kmc> otherwise, not sure what you're looking for
05:54:12 <dcoutts> Saizan: I think ghc installation should clear the target package db, rather than leaving things from a previous install.
05:54:23 <tomberek> kmc, what looking for combinator f a b = f a b
05:54:31 <dcoutts> Saizan: if you think it's not doing so, file a ticket
05:54:37 <kmc> tomberek, (\f a b -> f a b) is id
05:54:43 <Saizan> dcoutts: 'k
05:54:43 <kmc> and that's what @pl would say
05:54:47 <tomberek> hm
05:55:17 <Saizan> dcoutts: though i guess this holds only for the global one?
05:55:18 <aristid> kmc: i'm looking for a function (SomeClass m, MonadPlus m2) => m a -> m2 a
05:55:26 <dcoutts> Saizan: yes
05:55:37 <aristid> where SomeClass is a subclass of MonadPlus
05:55:39 <dcoutts> Saizan: nothing to be done for per-user ones
05:56:23 <dcoutts> Saizan: it will not affect distros, since they install via a temp dir
05:56:56 <dcoutts> Saizan: and they can take responsibility for making sure ghc package updates do not change the base package hash
05:57:01 <Saizan> dcoutts: i've found today that we can get two versions of the same package in the same package db :)
05:57:07 <kmc> aristid, so "m" is some kind of "functor producing either zero or one result"
05:57:15 <kmc> i'm not sure if there's a standard class for that
05:57:26 <aristid> kmc: no, m is for example [] or Maybe
05:57:32 <kmc> yes
05:57:33 <dcoutts> Saizan: you mean by just sticking the file there and running ghc-pkg recache?
05:57:45 <kmc> aristid, both of which are functors
05:57:56 <aristid> kmc: and i want the function to be id for m=[] and m2=[]
05:57:56 <kmc> aristid, and both of which have a function of type F a -> Maybe a
05:58:03 <kmc> aristid, oh
05:58:12 <kmc> that seems implausible
05:58:49 <kmc> there's probably some actual category theory that applies here, but it's out of my league
05:58:59 <Saizan> dcoutts: not sure how it happened, but dom1's ghc-pkg listed e.g. two haskell98-1.0.1.1 in the global db
05:59:00 <kmc> aristid, you could try to write the typeclass you want and some instances
05:59:04 <aristid> > (msum . map return $ [1,2,3]) :: [Integer]
05:59:07 <dcoutts> Saizan: how does ghc cope with that situation then?
05:59:28 <Saizan> dcoutts: no idea
05:59:32 <aristid> gn lambdabot is not here
05:59:40 <kmc> hmm aristid maybe Data.Foldable has what you want
05:59:57 <FunctorSalad> '/exec -o ghc -e blah' is a good substitute...
05:59:58 <FunctorSalad> :)
06:00:19 <kmc> aristid: asum . fmap pure :: (Foldable t, Alternative f, Functor t) => t a -> f a
06:00:23 <FunctorSalad> -o is xchatspecific I think
06:01:15 <kmc> aristid: or if you want to restrict to monads: msum . fmap return :: (Foldable t, MonadPlus m, Functor t) => t a -> m a
06:03:05 <kmc> aristid: put another way, Foldable is the class of things that can be reduced to a list
06:03:34 <aristid> kmc: yeah DF.msum . fmap return is precisely what i want
06:03:40 <kmc> if you assume associativity on both sides, then you don't lose any structure this way
06:03:53 <FunctorSalad> is there a difference between a unix domain socket and a named pipe? in principle and practically for a trivial trie server answering lookups
06:04:02 <kmc> FunctorSalad, yes
06:04:20 <kmc> quite a lot
06:04:23 <aristid> kmc: so i can convert [] to Maybe and Maybe to [] and also more generally
06:04:29 <FunctorSalad> at least I've found pipes here :) http://hackage.haskell.org/packages/archive/unix/2.4.0.1/doc/html/System-Posix-Files.html#6
06:04:44 <dom1> saizan: I am now generating numbers from a normal distribution
06:04:52 <FunctorSalad> kmc: oh?
06:04:56 <dom1> saizan: thanks for your help
06:04:56 <Saizan> dom1: yay :)
06:04:59 <mauke> FunctorSalad: a socket allows multiple connections
06:05:06 <aristid> are there instances of Foldable other than [] and Maybe?
06:05:06 <dom1> saizan: yay indeed
06:05:10 <kmc> FunctorSalad, pipes are one-way, 1:1, use the standard file API, etc.  pretty simple and restricted
06:05:18 <Saizan> dom1: np, sorry for the initial confusion :)
06:05:40 <dom1> nus: thanks also
06:05:42 <kmc> FunctorSalad, UNIX sockets are like any other network socket.  you use the socket API, you can do datagram or stream, many:many.  more flexible, more complicated
06:06:13 <ivanm> hmmmm, we should have a statement here: http://freenode.net/primary_groups.shtml
06:06:29 <Jonno_FTW> how can I take a list of lists, and return a list of lists that starts at the smallest of the heads of all the original lists
06:07:16 <FunctorSalad> kmc: mauke : thanks... jumped to conclusions from how the sockets have a path too (in contrast to tcp ones at least...)
06:07:19 <dcoutts> Jonno_FTW: you mean sorted by the size of the lists?
06:07:59 <kmc> Jonno_FTW, not totally sure what you want.  is it maybe «transpose . map sort . transpose»
06:08:25 <FunctorSalad> (and didn't think about multiple connections since this is such a trivial local application ;))
06:08:35 <ivanm> preflex: seen lambdabot
06:08:36 <preflex>  lambdabot was last seen on #haskell 1 hour, 33 minutes and 33 seconds ago, saying: forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
06:08:45 <ivanm> Who killed lambdabot?
06:08:47 <nus> dom1, ypu're welcome
06:08:56 <kmc> imo named pipes are a pain
06:09:00 <FunctorSalad> (I have a 'server' holding a tree in memory which answers "which package owns this file?" ;))
06:09:03 <Saizan> dcoutts: btw, is there a ticket about this duplicated versions issue?
06:09:05 <FunctorSalad> *trie
06:09:17 <nus> Saizan, %config(noreplace) %{_libdir}/ghc-%{version}/package.conf  -- that's the culprit, they should do some processing on install/uninnstall
06:09:20 <mauke> FunctorSalad: I don't mean parallel connections, I mean more than one session in total
06:09:21 <kmc> pipes are good for connecting two programs which think they're reading/writing ordinary files
06:09:22 <dcoutts> Saizan: I don't think so
06:09:30 <kmc> FunctorSalad, sounds bidirectional, a pipe will be annoying
06:09:38 <kmc> FunctorSalad, the high-level Network package supports Unix sockets apparently
06:09:39 <FunctorSalad> (in other words, dpkg -S with an hopefully enormous speedup ;))
06:10:00 <dcoutts> Saizan: it's all related to the fact that we don't yet handle multiple instances, but it's good to document all the various problems with the current system as it helps to push for the next step
06:10:10 <nus> https://build.opensuse.org/package/view_file?file=ghc.spec&package=ghc&project=devel%3Alanguages%3Ahaskell
06:10:58 <FunctorSalad> kmc: ok I'll look there
06:11:46 <kmc> err i mean Network module
06:11:47 <mauke> FunctorSalad: you listenOn (UnixSocket filename), then accept in a loop
06:15:51 <soupdragon> whats up haskell
06:16:02 <ivanm> hopefully the satellites are still up
06:16:09 <kmc> commonly, accept and forkIO
06:16:38 <Saizan> dcoutts: ghc-6.12.2's installer seem to wipe the package db btw, it seems it's already fixed :)
06:16:48 <dcoutts> Saizan: ok good
06:17:13 <soupdragon> I thought a haskell powered freezer would be really efficient because you can just program it to not evaluate its contents until its opened
06:17:48 <Twey> Heh
06:18:02 <soupdragon> I wrote an AI in haskell but it wouldn't get out of bed
06:18:04 <kmc> something like listenOn p >>= \s -> forever (accept s >>= (forkIO . m))
06:18:24 <Twey> As soon as you open the door, it changes time so that the food has been kept cold since the last time you closed it
06:18:56 <FunctorSalad> that looks pretty elegant actually :) (the Network module)
06:19:41 <Twey> listenOn p >>= forever . (>>= forkIO . m) . accept
06:19:42 <Twey> >.>
06:19:50 <kmc> :t (>.>)
06:20:02 <Twey> Heh
06:20:04 <kmc> FunctorSalad, you should write your server using iteratees
06:20:08 <kmc> then you should tell me how the hell they work ;)
06:20:40 <Twey> http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/
06:20:47 <Twey> @where iteratees
06:20:52 <Twey> Woah
06:20:55 <Twey> \b is dead
06:21:01 <soupdragon> \b?
06:21:07 <Twey> Oi, Cale â˜º
06:21:13 <Twey> lambdabot
06:21:24 <kmc> yeah, that's a great article
06:21:26 <soupdragon> @WHERE ITERATEES
06:21:35 <soupdragon> hm
06:21:37 <kmc> where da iteratees at
06:21:40 <kmc> soupdragon, try louder
06:21:41 <soupdragon> lol
06:21:45 <FunctorSalad> REQUIRE MORE ITERATEES
06:22:04 <nus> Î»Î²Î¿Ï„ is AWOL!
06:22:07 <kmc> welcome back lambdabot
06:22:10 <ivanm> yay! lambdabot is back!
06:22:12 <Twey> Thanks â˜º
06:22:12 <kmc> @botsnack
06:22:18 <Twey> @where iteratees
06:22:20 <lambdabot> :)
06:22:25 <Twey> Slow o.@
06:22:25 <ivanm> nus: lambda-beta-o-tau ?
06:22:26 <lambdabot> I know nothing about iteratees.
06:22:34 <kmc> (she's usually sluggish after joining)
06:22:35 <ivanm> Twey: she always is when she comes back
06:22:35 <xerox> omicron
06:22:36 <Axman6> is it correct to say that when you call a system call, you perform a context switch into the kernel space?
06:22:42 <ivanm> she's issuing a lot of /join statements don't forget
06:22:44 <kmc> Axman6, yes
06:22:49 <Axman6> excellent
06:23:02 <xerox> Axman6: indeed, that is what "int xyz" is for (I don't remember the number)
06:23:05 <Twey> @where+ iteratees http://hackage.haskell.org/package/iteratee http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/
06:23:12 <lambdabot> Done.
06:23:15 <Twey> ivanm: Ah, true
06:23:17 <Twey> @where iteratees
06:23:24 <lambdabot> http://hackage.haskell.org/package/iteratee http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/
06:23:26 <xerox> 0x80 iirc
06:23:26 <kmc> > greet
06:23:34 <lambdabot>   Look at you, hacker. A pathetic creature of meat and bone, panting and swea...
06:23:34 <Axman6> xerox: eh?
06:24:05 <FunctorSalad> :t greet
06:24:12 <Twey> Hehe
06:24:12 <lambdabot> Doc
06:24:18 <xerox> Axman6: you setup the registers and do "int 0x80" to do a system call, in assembly
06:24:32 <nus> ivanm, Î»âŠ¥
06:24:34 <Twey> The limit on \b's output is strange to me.  Why not make it a full IRC message?
06:24:41 <mtnviewmark> @pl \x y -> x == abs y
06:24:41 <kmc> xerox, you're talking about a particular convention on x86, right?
06:24:43 <soupdragon> What's a programmers favorite thing to cook with? The 0x0^3
06:24:46 <lambdabot> (. abs) . (==)
06:24:48 <ivanm> nus: the second character didn't render here; what is it meant to be?
06:24:52 <Axman6> xerox: fair enough. i'm working at a C level, so not much help to me :)
06:24:54 <xerox> http://www.linfo.org/int_0x80.html
06:24:57 <xerox> okay :)
06:25:01 <Twey> ivanm: Bottom
06:25:01 <ivanm> Twey: why not the TMR article as well?
06:25:02 <xerox> kmc: indeed
06:25:08 <kmc> different architectures do it different ways; x86 even has a special instruction for syscalls but iirc linux doesn't use it
06:25:11 <Twey> ivanm: I don't know it
06:25:12 <ivanm> lambda-bottom? :/
06:25:15 <soupdragon> > chr 0x80
06:25:16 <lambdabot>   '\128'
06:25:20 <ivanm> Twey: the latest TMR had an intro to iteratees as well
06:25:22 <ivanm> @where TMR
06:25:22 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
06:25:26 <kmc> x86 has a bunch of instructions that are slow so nobody uses them so the chips don't support them efficiently so they're slow
06:25:29 <Twey> Cool
06:25:29 <nus> ivanm, 0x22A5
06:25:39 <Twey> kmc: Heh, nice
06:25:53 <Twey> @where- TMR
06:25:53 <lambdabot> Maybe you meant: where where+
06:26:00 <Twey> @where+ TMR http://themonadreader.wordpress.com/
06:26:00 <lambdabot> Good to know.
06:26:02 <ivanm> kmc: don't you love recursive definitions/usages?
06:26:07 <ivanm> @where TMR
06:26:07 <lambdabot> http://themonadreader.wordpress.com/
06:26:08 <xerox> If you gcc -S a.c where a.c uses some syscall you'll see int 0x80 â€” at least I used to â€”Â years ago.
06:26:15 <Axman6> is the piece of info the OS has about a thread/process the process control block (PCB)?
06:26:16 <kmc> it's worth noting that C code usually calls system calls through libc functions
06:26:28 <kmc> and there are some calls where the libc function doesn't always actually need to make the system call
06:26:33 <kmc> in which case there's no mandatory context switch
06:27:04 <Twey> ivanm: Huh
06:27:09 <Twey> ivanm: I assumed @where+ appended
06:27:18 <ivanm> Twey: so did I :/
06:27:19 <mux> xerox: these days there are other more efficient ways to do syscall, FWIW (see SYSENTER instruction for instance)
06:27:43 <mtnviewmark> :t maybe (const True) ((.abs).(==))
06:27:44 <lambdabot> forall a. (Num a) => Maybe a -> a -> Bool
06:28:07 <mauke> http://www.trilithium.com/johan/2005/08/linux-gate/
06:28:12 <nus> > âŠ¥. âŠ¥
06:28:13 <lambdabot>   <no location info>: parse error on input `âŠ¥.'
06:28:24 * mux wonders if freebsd actually uses sysenter these days
06:28:42 <Twey> ivanm: Then I'm going to say because it's hard to link to a chapter of a PDF
06:28:54 <ivanm> Twey: link to the actual issue?
06:29:23 <ivanm> Twey: maybe to http://themonadreader.wordpress.com/2010/05/12/issue-16/ ?
06:30:00 <soupdragon> Demand More of Your Automata <-- love this title
06:30:10 <xerox> mux: I'm not into that anymore, but thanks
06:31:34 <Jonno_FTW> how come this doesn't work: arrange p@[[a,b,c],[d,c,e],[f,e,g],[h,g,i],[j,i,b]] | a == maximum [a,d,f,h,j] = p
06:31:36 * Gracenotes requires that his automata have human intuitive powers
06:31:49 <soupdragon> Jonno_FTW, it does work
06:31:56 <soupdragon> actualyl
06:32:00 <soupdragon> let me see:
06:32:07 <Twey> Jonno_FTW: Because it's equivalent to kicking your compiler in the genitalia.  GHC revolted and refused to process it.
06:32:08 <Jonno_FTW>     Conflicting definitions for `b'    Bound at: prob68.hs:23:11              prob68.hs:23:45
06:32:12 <Gracenotes> Jonno_FTW: can't have duplicates
06:32:15 <Gracenotes> in pattern matches
06:32:22 <Gracenotes> your i and b are reused
06:32:24 <soupdragon> doh
06:32:34 <Gracenotes> and g, and e, etc.
06:32:46 <Jonno_FTW> how do i work around this?
06:32:51 <Gracenotes> use ==
06:32:56 <ivanm> Twey: anyway, if you hadn't seen it I assume you aren't subscribed (or at least don't read) the mailing lists?
06:33:01 <Twey> Or view patterns
06:33:08 <Twey> ivanm: No, not yet
06:33:11 <Cale> Jonno_FTW: By giving different names to all the variables and then using a guard
06:33:14 <Gracenotes> yeah. in its basic form pattern matching is appropriate for binding variables to names. not much else.
06:33:28 <Gracenotes> and selecting alternatives for given breakdowns of the binding etc.
06:33:35 <soupdragon> why doesn't it let you just have multiple matches thuogh?
06:33:36 <Jonno_FTW> oh right i see
06:33:40 <Twey> Subscribing to mailing lists for me requires great amounts of fumbling with filter rules, so I keep meaning to â˜º
06:33:55 <soupdragon> f x x = ... should just demand an Eq on x
06:34:05 <soupdragon> is there a problem with it
06:34:08 <Gracenotes> soupdragon: last someone explained it to me -- and this does make sense -- you have to make arbitrary decisions about bottomness
06:34:16 <Jonno_FTW> > let x = 5 in f x x
06:34:17 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:34:17 <lambdabot>    `SimpleReflect.FromExpr ...
06:34:51 <Cale> arrange p@[[a,b,c],[d,c',e],[f,e',g],[h,g',i],[j,i',b']] | [c,e,g,i,b] == [c',e',g',i',b'] && a == maximum [a,d,f,h,j]] = p
06:35:07 <Gracenotes> SPJ's paper about implementing functional programming languages does have that construct. I forget how bottoms were dealt with there, if at all...
06:35:14 <Jonno_FTW> :\
06:35:30 <kmc> Jonno_FTW, do all your lists have this regular structure?
06:35:36 <Jonno_FTW> yes
06:35:42 <kmc> five lists of 3 elements each?
06:35:47 <Jonno_FTW> yes
06:36:13 <kmc> then maybe what you want is a 2D array
06:36:27 <Cale> soupdragon: It's not terribly problematic to do something like that, but sometimes it's just a bug when you reuse a variable by accident in a complicated pattern.
06:36:40 <kmc> if you care about efficiency, this is not a good way to do it
06:36:51 <Jonno_FTW> i don't care about efficiency
06:36:56 <Twey> Efficiency or anything else
06:36:59 <Cale> Jonno_FTW: What is the idea behind that definition of arrange?
06:37:30 <Jonno_FTW> to reorganise the list of lists, starting with the list with the minimum head
06:37:42 <Cale> why not just sort it?
06:37:55 <Jonno_FTW> because i want it like this  fx q = (drop q p) ++ (take q p)
06:38:06 <Jonno_FTW> where p is the list of lists
06:38:11 <soupdragon> = drop q p ++ take q p
06:38:18 <soupdragon> function application is always tighter than operators
06:38:44 <Jonno_FTW> that's what I want them to look like
06:39:05 <Cale> Jonno_FTW: So you want to rearrange them cyclically such that the minimum head is first?
06:39:12 <Jonno_FTW> yes
06:39:14 <Cale> okay
06:39:45 <Cale> So I would compute the minimum head first, then use span or break to cut the list at that point.
06:40:03 <Cale> (Is it possible to have two lists with the same minimum head?)
06:40:14 <Jonno_FTW> no
06:41:12 <Jonno_FTW> they are always like this: [a,b,c],[d,c,e],[f,e,g],[h,g,i],[j,i,b]
06:41:37 <soupdragon> "Some of these tilings are reminiscent of the quasi-periodic behavior of |_(n+1)a_| - |_na_| for a fixed irrational a (|_x_| is the integral part of of x) where arbitrary long sequences are repeated infinitely often."
06:41:41 <soupdragon> what?? :(
06:42:56 <soupdragon> > let a = sqrt 5 :: CReal in map (\n->floor ((n+1)*a) - floor (n*a)) [1..]
06:43:00 <lambdabot>   mueval-core: Time limit exceeded
06:43:06 <soupdragon> > let a = sqrt 5 in map (\n->floor ((n+1)*a) - floor (n*a)) [1..]
06:43:07 <lambdabot>   [2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,2,...
06:44:00 <soupdragon> > let a = sqrt 5 :: CReal in zipWith (+) `ap` tail $ map (\n-> floor (n*a)) [1..]
06:44:02 <lambdabot>   [6,10,14,19,24,28,32,37,42,46,50,55,60,64,68,73,78,82,86,90,95,100,104,108,...
06:44:59 <Cale> soupdragon: What is that from?
06:45:09 <soupdragon> Algebraic theory of Penrose's nonperiodic tilings of the plane, I, II
06:45:16 <soupdragon> http://alexandria.tue.nl/repository/freearticles/597566.pdf
06:45:44 <soupdragon> > let a = sqrt 5 :: CReal in zipWith (flip (-)) `ap` tail $ map (\n-> floor (n*a)) [1..]
06:45:51 <lambdabot>   [2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,2,...
06:45:52 <soupdragon> > let a = exp 1 :: CReal in zipWith (flip (-)) `ap` tail $ map (\n-> floor (n*a)) [1..]
06:45:55 <Jonno_FTW> so what can i do?
06:45:55 <lambdabot>   [3,3,2,3,3,3,2,3,3,2,3,3,3,2,3,3,2,3,3,3,2,3,3,2,3,3,3,2,3,3,2,3,3,3,2,3,3,...
06:46:08 <soupdragon> these are quasi-periodic?
06:46:31 <soupdragon> maybe I need to graph these
06:46:32 <Cale> Jonno_FTW: Compute the minimum head, then use span to cut the list of lists at the point where it occurs
06:46:42 <Jonno_FTW> ok
06:47:08 <Cale> (and rejoin the two pieces appropriately)
06:48:39 <Cale> let cycleMin xs = vs ++ us where (us,vs) = break ((==m) . head) xs; m = minimum . map head $ xs in cycleMin [[4,5,6],[2,6,7],[1,4,8],[5,6,9]]
06:48:41 <Cale> > let cycleMin xs = vs ++ us where (us,vs) = break ((==m) . head) xs; m = minimum . map head $ xs in cycleMin [[4,5,6],[2,6,7],[1,4,8],[5,6,9]]
06:48:42 <lambdabot>   [[1,4,8],[5,6,9],[4,5,6],[2,6,7]]
06:49:17 <Cale> We could also just avoid using head at all
06:49:22 <soupdragon> @let color = (" #o"!!).(`mod`3)
06:49:23 <lambdabot>  Defined.
06:49:29 <soupdragon> > let a = exp 1 :: CReal in map color . zipWith (flip (-)) `ap` tail $ map (\n-> floor (n*a)) [1..]
06:49:30 <lambdabot>   Precedence parsing error
06:49:30 <lambdabot>      cannot mix `L..' [infixr 9] and `Control.Mona...
06:49:32 <Cale> > let cycleMin xs = vs ++ us where (us,vs) = break (==m) xs; m = minimum xs in cycleMin [[4,5,6],[2,6,7],[1,4,8],[5,6,9]]
06:49:34 <lambdabot>   [[1,4,8],[5,6,9],[4,5,6],[2,6,7]]
06:49:37 <soupdragon> > let a = exp 1 :: CReal in map color . (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..]
06:49:41 <lambdabot>   mueval-core: Time limit exceeded
06:49:46 <soupdragon> > let a = exp 1 :: CReal in take 40 $ map color . (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..]
06:49:47 <lambdabot>   "  o   o  o   o  o   o  o   o  o   o   o "
06:49:52 <soupdragon> > let a = sqrt 2 :: CReal in take 40 $ map color . (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..]
06:49:53 <lambdabot>   "#o#o##o#o##o#o#o##o#o##o#o#o##o#o##o#o##"
06:49:55 <soupdragon> > let a = sqrt 5 :: CReal in take 40 $ map color . (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..]
06:49:56 <lambdabot>   "ooo ooo ooo ooo oooo ooo ooo ooo oooo oo"
06:50:00 <soupdragon> quasi crystals ?
06:50:09 <Jonno_FTW> @src break
06:50:09 <lambdabot> break p =  span (not . p)
06:50:16 <soupdragon> in my haskel ?
06:50:26 <Jonno_FTW> @src span
06:50:27 <lambdabot> Source not found. Just try something else.
06:50:31 <Jonno_FTW> :O
06:50:47 <Jonno_FTW> but you used it right there you stupid bot
06:51:02 <mux> xerox: come on, it's the big blue G talking to you! :D
06:51:07 <Cale> It doesn't have the source because it's just long enough to be annoying
06:51:21 <Jonno_FTW> hmmm
06:51:24 <mauke> span p = tl;dr
06:51:52 <Cale> But I suppose we could have it say   span p xs = (takeWhile p xs, dropWhile p xs)
06:52:14 <mauke> @src takeWhile
06:52:14 <lambdabot> takeWhile _ []                 =  []
06:52:14 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
06:52:14 <lambdabot>                    | otherwise =  []
06:52:20 <Cale> actually, it is only 3 lines, if formatted correctly
06:52:34 * Cale adds it...
06:52:46 <Jonno_FTW> ok, makes sense
06:53:48 <soupdragon> @let color' = (" .:oO@"!!).(`mod`5)
06:53:49 <lambdabot>  Defined.
06:53:52 <Cale> @src span
06:53:52 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:53:55 <Cale> okay.
06:54:00 <soupdragon> > let a = (1/2)*(1+sqrt 5) :: CReal in take 60 $ map color' . (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..]
06:54:01 <lambdabot>   ":.::.:.::.::.:.::.:.::.::.:.::.::.:.::.:.::.::.:.::.:.::.::."
06:54:07 <Cale> Probably have to restart the bot to get it to re-read that file.
06:54:08 <soupdragon> > let a = pi :: CReal in take 60 $ map color' . (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..]
06:54:09 <lambdabot>   "ooooooOooooooOooooooOooooooOooooooOooooooOooooooOooooooOoooo"
06:54:22 <Cale> GHOSTS
06:54:31 <Eludias> (Newby question) How do I get the filesize of a file gives its filename without opening the file?
06:54:50 <kmc> :t hFileSize
06:54:51 <lambdabot> Not in scope: `hFileSize'
06:55:04 <Eludias> hFileSize requires a handle which requires opening a file, right?
06:55:09 <kmc> yeah but you don't have to read it
06:55:25 <Eludias> So 'opening' in Haskell != 'opening' in the underlying OS?
06:55:31 <kmc> Eludias, no
06:55:41 <kmc> but you don't have to read all the bytes and count them
06:55:47 <kmc> anyway, if you really can't open the file at all
06:56:07 <kmc> you can use System.Posix.Files.getFileStatus
06:56:11 <Eludias> I can 'ls' a directory, but not open the files in it.
06:56:11 <kmc> on UNIX-like systems
06:56:14 <kmc> i don't know of a portable way
06:56:21 <Eludias> Ok, thanks.
06:56:38 <kmc> that's just a wrapper on the syscall stat()
06:57:29 <Eludias> 'getFileStatus' is not in Hoogle?
06:57:35 <Eludias> :t getFileStatus
06:57:36 <lambdabot> Not in scope: `getFileStatus'
06:57:44 <kmc> @hoogle getFileStatus
06:57:44 <lambdabot> No results found
06:57:45 <Cale> :t System.Posix.Files.getFileStatus
06:57:46 <lambdabot> FilePath -> IO System.Posix.Files.FileStatus
06:58:05 <Eludias> lambdabot != hoogle... ok... (just starting Haskell ;-)
06:58:16 <Eludias> uh, /= of course.
06:58:23 <kmc> :t System.Posix.Files.fileSize <$> System.Posix.Files.getFileStatus
06:58:24 <lambdabot>     Couldn't match expected type `System.Posix.Files.FileStatus'
06:58:24 <lambdabot>            against inferred type `IO System.Posix.Files.FileStatus'
06:58:24 <lambdabot>       Expected type: FilePath -> System.Posix.Files.FileStatus
06:58:31 <Cale> I think maybe hoogle's index was composed on a Windows machine.
06:58:41 <kmc> :t (System.Posix.Files.fileSize <$>) . System.Posix.Files.getFileStatus
06:58:42 <lambdabot> FilePath -> IO System.Posix.Types.FileOffset
06:58:45 <Cale> Which wouldn't have the Posix library
06:59:51 <Cale> It's a bit of a shame that there doesn't seem to be anything in System.Directory for querying the size of files without opening them.
07:00:28 <soupdragon> > let a = (2+sqrt(7))**(1/7)-(9-sqrt(6))**(1/5) :: CReal in take 90 $ map color' . (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..]
07:00:31 <lambdabot>   "   O    O    O   O    O    O    O   O    O    O    O   O    O    O    O   ...
07:00:34 <soupdragon> > let a = (87+sqrt(7))**(1/7)-(9-sqrt(6))**(1/5) :: CReal in take 90 $ map color' . (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..]
07:00:36 <lambdabot>   " . . . .  . . . .  . . . .  . . . .  . . . .  . . . .  . . . .  . . . .  ....
07:00:38 <soupdragon> would these be quasi-crystals?
07:01:00 <hiptobecubic> they look mostly like 0's and dots
07:01:13 <soupdragon> what do you mean?
07:01:35 <hiptobecubic> "  O    O   O  ... "
07:01:42 <hiptobecubic> " . . . .  . . . "
07:01:53 <hiptobecubic> i suppose they are O's and not 0's
07:02:11 <soupdragon> yes
07:02:12 <Cale> They represent numbers though :)
07:04:01 <soupdragon> > let a = 2/pi :: CReal in take 90 $ map color' . (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..]
07:04:02 <lambdabot>   ". .. .. .. . .. .. .. . .. .. .. . .. .. .. . .. .. .. . .. .. .. . .. .. ...
07:04:07 <soupdragon> this one looks quasi-crystal to me
07:04:19 <soupdragon> but I am not completely sure what I am even supposed to be looking for
07:04:37 <soupdragon> > map length . words $ (let a = 2/pi :: CReal in take 90 $ map color' . (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..])
07:04:39 <lambdabot>   [1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,1]
07:04:43 <Cale> I don't think you'll find it just by staring.
07:04:58 <soupdragon> that looks periodic... but it should stop eventually
07:05:14 <Cale> Perhaps we could try to compress it further :)
07:06:40 <soupdragon> Cale there is a real stuggle with the number here becaus lambdabot times out so quickly
07:06:48 <soupdragon> I actually had to optimize my code to make it work
07:07:46 <Cale> Well, and CReal is probably really slow.
07:09:30 <soupdragon> Is there a super efficient version? :)
07:11:05 <Cale> Wow, it really is quite close to periodic, but not quite :)
07:11:14 <kmc> HERA is supposed to be faster
07:11:17 <Cale> @let squish = map length . group
07:11:18 <lambdabot>  Defined.
07:12:08 <Cale> > take 65 . squish . squish . squish $ (let a = 2/pi :: CReal in (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..])
07:12:10 <lambdabot>   [1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,...
07:12:13 <Cale> ugh :)
07:12:24 <Cale> > drop 20 . take 65 . squish . squish . squish $ (let a = 2/pi :: CReal in (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..])
07:12:27 <lambdabot>   [1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,...
07:12:31 <Cale> > drop 40 . take 65 . squish . squish . squish $ (let a = 2/pi :: CReal in (zipWith (flip (-)) `ap` tail) $ map (\n-> floor (n*a)) [1..])
07:12:31 <soupdragon> wow
07:12:33 <lambdabot>   [1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,7,1]
07:12:38 <Cale> ^^ :)
07:12:43 <Jafet> @src squish
07:12:43 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:12:45 <Inglorion> so, is today international-let's-make-lambdabot-generate-infinite-sequences day?
07:13:00 <Jafet> @quote undoubtedly
07:13:01 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
07:13:01 <Cale> Look at that 7 all the way out there :)
07:13:01 <soupdragon> why is there a 7 there
07:13:06 <soupdragon> haha
07:13:12 <kmc> Inglorion, that's every day
07:13:13 <soupdragon> so does this give a good way to generate pi
07:13:52 <Cale> Well, I'm also throwing away a lot of information with each squish... there might be other signs of nonperiodicity before that
07:15:02 <Cale> (If xs is periodic, then squish xs is, but the converse is obviously not true.)
07:15:45 <hiptobecubic> what ddoesthe :: do ?
07:15:57 <aavogt> annotates a type
07:16:25 <hiptobecubic> well normally yes, but in cale's examples? i don't see how.... unlesss CReal is the type?
07:16:31 <aavogt> CReal is a type
07:16:34 <hiptobecubic> ok thanks
07:16:42 <aavogt> and :: is always for types
07:16:52 <Cale> CReal is the type of computable real numbers
07:17:08 <Cale> It represents a certain (fairly large) subset of the real numbers exactly
07:17:37 <Jafet> > fix (\x -> sqrt (1 + x)) :: CReal
07:17:38 <Cale> > showCReal 100 pi
07:17:39 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
07:17:42 <kmc> fairly large?
07:17:42 <lambdabot>   mueval: ExitFailure 1
07:17:50 <kmc> it represents almost none of the real numbers ;)
07:17:54 <Cale> kmc: Well, amongst countable subsets of them :)
07:18:06 <kmc> ah, that's interesting
07:18:11 <kmc> how do you formalize that?
07:18:53 <Cale> Well, I'd originally just intended it as a flippant way to say that we're not just taking the rationals or something :)
07:19:01 <kmc> heh
07:19:08 <kmc> aww, i was hoping there was more to it
07:19:15 <hiptobecubic> Cale, laziness is what makes that possible, I assume?
07:19:23 <Cale> hiptobecubic: Well, and/or functions
07:19:36 <Cale> It's more functions than laziness.
07:19:50 <kmc> hiptobecubic, a value of type CReal is a function that gives you a rational approximation for any error bound you choose
07:19:59 <Cale> Though a different representation of the computable reals might use laziness more.
07:20:08 <kmc> thus it's like a convergent sequence, which is one of the ways to define the reals
07:20:13 <hiptobecubic> ok
07:20:18 <kmc> (but your approximations are generated by an algorithm, so you only get the computable reals)
07:20:30 <kmc> hiptobecubic, and that would work roughly the same in a strict language
07:20:55 <Cale> kmc: There might be a formalisable way to more properly order various subsets of the reals, with a more interesting order than containment...
07:20:56 <kmc> remember that you can always get explicit laziness via functions
07:21:06 <ville> Which of the database libraries are considered usable/mature?
07:21:09 <Inglorion> without even being odd?
07:21:15 <kmc> Cale, sounds a little like topology, of which i know very little
07:21:38 <Cale> Well, it's probably closer to set theory and order theory :)
07:21:41 <soupdragon> lol LInglorion
07:21:50 <kmc> topological set theory then? ;)
07:21:59 <Cale> kmc: There are countable ordinals which are not computable.
07:22:13 <kmc> what makes an ordinal computable?
07:22:33 <kmc> same as any other set?
07:22:38 <kmc> computable characteristic function?
07:23:24 <soupdragon> what does it mean for an ordinal to be computable? :o
07:23:48 <Cale> Well, there are lots of ways to devise notations for describing the ordinal numbers.
07:24:48 <voker57> can i haz an example of function, which arguments have typeclass restriction and are documented?
07:25:06 <Cale> But no matter what scheme you come up with for describing ordinal numbers with finite strings in a finite alphabet, you only get a countable number of ordinals.
07:25:21 <aristid> it seems like there is some relation between Functor and Foldable
07:25:33 <Cale> voker57: Just any function with a typeclass constraint?
07:25:45 <Cale> :t sort
07:25:46 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:25:50 <Cale> Like that?
07:25:52 <voker57> Cale: I need to see documented arguments in such function
07:26:01 <voker57> because haddock kind of fails here.
07:26:14 <Cale> Oh, haddock has a bunch of bugs related to documenting arguments.
07:26:30 <aavogt> it can't document individual class constraints afaik
07:26:34 * hackagebot hashmap 1.0.0 - Persistent containers HashMap and HashSet.  http://hackage.haskell.org/package/hashmap-1.0.0 (MilanStraka)
07:26:49 <voker57> I don't need to document class constraints, just arguments
07:27:05 <Cale> http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html
07:27:08 <voker57> and they get shifted by one here, so last one isn't documented and other annotations are wrong
07:27:08 <aristid> msum . fmap return = foldr (mplus . return) mzero
07:27:20 <soupdragon> I totally lost the track with this crystal stuff
07:27:21 <aristid> except that the first also requires Functor
07:27:23 <Cale> It seems to have dropped one of the descriptions here
07:27:42 <Cale> http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/src/Data-Graph-AStar.html#aStar -- but this shows how you're supposed to do it
07:27:43 <ManateeLazyCat> voker57: If you want haddock document your function argument, you need make sure haddock can find typeclass in same module.
07:28:01 <voker57> yes. exactly like mine
07:28:07 <aristid> :t foldr
07:28:07 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:28:15 <voker57> and other descriptions do not belong to their arguments
07:28:19 <ManateeLazyCat> voker57: If typeclass define in other module, you need expoert typeclass in current module at least.
07:28:27 <Cale> Right, it's shifted them all up somehow
07:28:30 <Cale> It used to not be broken.
07:28:34 <voker57> no, my typeclasses are in same module
07:28:36 <aristid> Cale: if you were feeling advantageous, you could use the foldr from Data.Foldable in Caleskell
07:28:40 <Cale> I think it's just a current bug in Haddock.
07:28:46 <aristid> -advantageous+adventurous
07:29:49 <aristid> :t Data.Foldable.foldr
07:29:50 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
07:30:03 <ManateeLazyCat> voker57: If typeclass in same module, haddock should be work.
07:30:10 <ricli85> I would like to start a few applications and send them to different workspaces when xmonad starts, how should I do this?
07:30:28 <ManateeLazyCat> ricli85: #xmonad ?
07:30:46 <ricli85> ManateeLazyCat, oops, sorry, wrong channel :P
07:30:57 <ManateeLazyCat> :)
07:31:01 <freiksenet> I have type Variable and Function and I have type Member that can either be Variable or Function. AFAIK I need to write something like Member = Method Function | Field Variable, but that really increases the amount of useless stuff to type when I create instances of those types, cause I need to write "Method Function" instead of just "Method", for example. This is okay in general, but this data types are supposed to make a concise DSL, so lots
07:31:19 <freiksenet> s/symbol this/symbol size
07:31:32 <aavogt> Data.Traversable++
07:31:37 <aavogt> Data.Foldable++
07:31:58 <Jonno_FTW> @src concatMap
07:31:58 <lambdabot> concatMap f = foldr ((++) . f) []
07:33:16 <kmc> freiksenet, export some helper functions for construction then
07:33:29 <ManateeLazyCat> freiksenet: So what's your real problem? Duplicate code in instance? Or duplicate code for your Member?
07:33:33 <kmc> generally it's good form for a DSL to be defined in terms of functions / operators rather than constructors directly
07:33:42 <kmc> unless the DSL user is expected to pattern-match
07:33:48 <kmc> this gives you a lot more flexibility to change internal representation
07:33:49 <aavogt> view patterns
07:34:22 <freiksenet> ManateeLazyCat: to declare a Member that is a Function I need to write Method Function, not just Function.
07:34:36 <ManateeLazyCat> kmc: I have saw many paper use DSL, so what's use for DSL?
07:34:49 <kmc> ManateeLazyCat, it means "domain-specific language"
07:34:52 <freiksenet> kmc: hmmm, haven't though about that
07:34:55 <ManateeLazyCat> kmc: Yes, i know that.
07:34:59 <freiksenet> thought*
07:35:05 <freiksenet> kmc: that sounds like a good solution. thanks a lot.
07:35:06 <ManateeLazyCat> kmc: I mean Why need DSL?
07:35:27 <kmc> ManateeLazyCat, because you want to express a solution in terms of the problem domain
07:35:32 <kmc> rather than irrelevant implementation details
07:35:41 <kmc> it's a very general technique, used in a lot of contexts besides haskell
07:35:47 <freiksenet> ManateeLazyCat: why need any abstraction? DSL is just another type of abstraction, like OO or higher-order functions
07:36:20 <kmc> "DSL" is sort of the same thing as "good library design"
07:36:41 <kmc> it's not a specific technical idea the way higher-order functions are and OOP sometimes is
07:37:06 <ManateeLazyCat> kmc: Simple, DSL is build some library for special domain, make you can think problem at higher-level, right?
07:37:13 * kmc awaits the day when we call first-class functions "functions" and C/C++/Java functions "pseudofunctions"
07:37:16 <ski> (freiksenet : cut off at ".. but this data types are supposed to make a concise DSL, so lots")
07:37:37 <kmc> ManateeLazyCat, yeah.  in particular, you might want domain experts to do the coding
07:37:48 <kmc> example being these financial modeling systems in Haskell
07:38:00 <kmc> you have the guys who understand complex derivatives contracts
07:38:02 <freiksenet> ski: pardon me?
07:38:10 <kmc> and are not expert Haskell programmers, might not be expert programmers at all
07:38:12 <ManateeLazyCat> kmc: So DSL is more like a concept, not special technology?
07:38:19 <kmc> so you want to provide them a library which is very general
07:38:28 <kmc> ManateeLazyCat, yes.  it's the concept of building a library that "feels like a special language"
07:38:44 <kmc> or in fact
07:38:46 <ski> freiksenet : your previous long message was (presumably) cut off at the end by the IRC demons
07:38:46 <ManateeLazyCat> kmc: I see, thanks for explain. ;-)
07:38:49 <kmc> that's what you might call "embedded DSL"
07:39:01 <kmc> a DSL could also be a full-blown external language with parser, compiler or interpreter, etc.
07:39:16 <kmc> or something in-between, e.g. a macro system
07:39:39 <kmc> arguably Lisp is a toolkit for building DSLs more than a language itself
07:39:44 <freiksenet> ski: ah, it was "so lots of repetitive typing would be needed to declare something, meaning symbol this does matter. Is there any way to make Member be a Function | Variable without type constructors?"
07:40:10 <freiksenet> I dunno. Haskell type system makes and excellent base to do DSLs
07:40:34 <freiksenet> Lisp has macros though, but if it had type system it would be much easier to define stable dsls
07:40:46 <ManateeLazyCat> kmc: I think Lisp use itself build itself, lisp is *incomplete* language, it always extension itself.....
07:40:47 <freiksenet> an excellent*
07:40:48 <kmc> err what i said above "you want to provide them a library which is very general"
07:40:56 <kmc> i meant more like "you want to provide them a library which is very natural to the way they think"
07:41:09 <kmc> freiksenet, yeah
07:41:16 <kmc> though Lisp has a type system, just not static checking
07:41:31 <kmc> and you could add static checking for your DSL easily
07:41:31 <Jafet> freiksenet, every language has a type system -- unless you're a fundie like kmc and wants to call lisp's "pseudo type system"
07:41:39 <ski> freiksenet : well, one would need to be able to define "strict macros", i think
07:41:43 <kmc> actually that's the opposite of what i just said ;P
07:41:45 <ManateeLazyCat> kmc: Dynamic check is not safe, IMO, at least for core.
07:42:01 <soupdragon> kmc well some lisps do implement a lot of static checking
07:42:02 <freiksenet> kmc: SBCL even does some type checking.
07:42:58 <freiksenet> Jafet: lisp's (I mean common lisp) type system is quite weak comparing to haskell type system, I think it's not even possible to make recursive data types with standard tools.
07:43:28 <mreh> hmm, wouldn't it be useful to have a binding to libavcodec
07:43:28 <maltem> Data recursion isn't really a feature of the type system
07:43:35 <freiksenet> noone will start building DSL on top of lisp type creation tools, most probably lisp data structures like lists would be used.
07:43:36 <Jafet> I've never used clos
07:43:39 <mreh> then we could read all sorts of files into out haskells
07:43:42 <freiksenet> and there is CLOS, yes.
07:43:55 <kmc> mreh, you're volunteering? ;)
07:44:02 * ManateeLazyCat A strongly static checking avoid you make *stupid* mistake....
07:44:09 <mreh> mreh: maybe
07:44:18 <drksd> auto-hl fail
07:44:22 <drksd> :-Â°
07:44:23 <kmc> Python and Perl are both dynamically typed but i'd say Perl is close to actually having no type system
07:44:24 <mreh> kmc: maybe
07:44:34 <kmc> in that it tries very hard to hide whether something is 3 :: Int or "3" :: String
07:44:51 <kmc> and will generally do wacky conversions and go wrong later, where Python would throw an error
07:44:57 <Jafet> Perl actually has static typing. It's just a bit... optimistic about what the types are
07:45:10 <Jafet> And then there is Tcl.
07:45:13 <kmc> heh
07:45:21 <kmc> plenty of languages have only one type, like "string"
07:45:23 <kmc> (is Tcl one of those?)
07:45:40 <geheimdienst> also known as stringly-typed programming languages
07:45:47 <kmc> hehe
07:45:49 <kmc> @quote stark
07:45:49 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
07:46:00 <Jafet> In Tcl, everything has two types, except strings
07:46:12 <kmc> the truth is five, but men have only one name for it
07:46:20 <Axman6> Jafet: which are the two types?
07:46:23 <mreh> it is an abomination
07:46:34 <Jafet> One of them is string.
07:46:45 <aristid> what's the other?
07:46:50 <geheimdienst> the only program i know that's written in tcl (i think) is gitk
07:46:59 <Cale> aristid: whatever it is that you're trying to represent :)
07:47:05 <Axman6> macports is written in tcl
07:47:07 <geheimdienst> other than that: how is tcl even relevant these days?
07:47:11 <Axman6> which explains a hell of a lot
07:47:20 <kmc> yikes, gitk is a 11,000 line Tcl script
07:47:27 <Jafet> emerge is written in bash...
07:47:28 <kmc> i was hoping it was a C program using Tk
07:47:28 <Axman6> one day i'd like to (see) it rewritten in haskell
07:47:32 <geheimdienst> holy cow
07:47:41 * hackagebot hjpath 3.0 - XPath-like syntax for querying JSON  http://hackage.haskell.org/package/hjpath-3.0 (JaroslavGridin)
07:48:05 <aristid> Jafet: i thought emerge was python?
07:48:19 <kmc> Tcl is still relevant.  COBOL is still relevant.  C and Java may outlive the human race
07:48:53 * Axman6 guesses that assembly will travel further than any of us alive now ever will
07:49:00 <maltem> kmc: welcome to the scares of the git codebase :p
07:49:25 <gwern> Axman6: well obviously, thanks to space probes
07:49:26 <Cale> Assembly languages live about as long as the architectures on which they're based
07:49:27 <Jafet> That might be Ada, or whatever they used for the Voyager craft.
07:49:39 <Jafet> Actually it couldn't have been Ada.
07:49:54 <Axman6> most space programming is (was) done using assembly
07:50:03 <geheimdienst> kmc, i think we should make a difference between "important because we have some legacy crap that needs to be maintained" and "important because we'd like to use it for new projects"
07:50:10 <Cale> But assembly isn't one language
07:50:13 <kmc> yeah geheimdienst
07:50:16 <kmc> that's important
07:50:29 <Axman6> also, Ada is quite a nice language indeed, even if it is horridly ugly
07:51:06 <Jafet> Cale, it's always is; which one, is another question
07:51:50 * ManateeLazyCat Looks most Haskeller are perfectionists. :)
07:52:01 <Fuco> Space shuttle was written in some PL/1 dialect
07:52:27 <Fuco> it looks more like C then assembler
07:53:31 <Axman6> it's pretty amazing the sheer lack of computing resources the space shuttle has
07:53:47 <Axman6> can't remember the specs, but it's something absurdly small
07:53:55 <mreh> you don't need much to go to space
07:54:00 <Fuco> 1 mb ram I think
07:54:03 <geheimdienst> well the shuttle is a design from the 1970s, maybe 80s
07:54:04 <Fuco> but original had even less
07:54:37 <geheimdienst> also, to look at a few sensors and control a few actuators, you really don't need that much
07:55:01 <geheimdienst> for stuff like the gigabytes of digicam pictures they have laptops, which i think are thinkpads
07:57:24 <mreh> how can I put dependencies in cabal packages on resources other than other cabal packages
07:57:27 <matt_m> byorgey: You around?  In your paper where you talk about Extensions and virtual species, you talk about completing a semi-ring to a ring and comment that this allows for subtraction and division of species.
07:57:44 <matt_m> byorgey:  Why do we get division in a ring?
07:57:47 <Cale> Oh, I was describing what the computable ordinals are and got distracted earlier. We can call some ordinal computable if there is a computable binary relation which well-orders a subset of the naturals whose order type is that ordinal.
07:58:53 <Cale> The program for computing that ordinal is our sort of "notation" for it.
07:59:37 <dcoutts> mreh: you can reference dependencies on C libs, C headers, pkg-config packages, OSX frameworks, build-tools
08:00:08 <mreh> dcoutts: oh good, I'll read the documentation a bit more closely
08:02:53 * geheimdienst just dug out that story again about using lisp on spacecraft. read it years ago, quite interesting. http://www.flownet.com/gat/jpl-lisp.html
08:03:55 <ski> (Erann Gat ?)
08:05:32 <Cale> and of course, there are only countably many such programs, and so the set of all computable ordinals is countable, and by taking their union, we get the first uncomputable ordinal.
08:06:57 <soupdragon> matt_m: didn't that get covered yesterday? The reason division works out is because the power series are potentially infinite
08:07:15 <matt_m> soupdragon:  So it's a field?
08:07:20 <soupdragon> try this: 1 = (1 + x)(a + bx + cx^2 + ...)
08:07:23 <soupdragon> solve for a,b,c,...
08:07:29 <kmc> "I can't even say the word Lisp without cementing my reputation as a crazy lunatic who thinks Lisp is the Answer to Everything."
08:07:30 <kmc> sounds about right
08:07:33 <soupdragon> oops
08:07:37 <soupdragon> I meant to set a different problem
08:07:44 <soupdragon> Solve for a,b,c,... 1 = (1 - x)(a + bx + cx^2 + ...)
08:08:00 <Cale> Power series don't form a field, just a ring, but some of the elements of that ring have inverses.
08:08:12 <geheimdienst> "I can't even say the word monad without cementing my reputation as a crazy lunatic who thinks Monads are the Answer to Everything."
08:08:33 <matt_m> I think the logic of that paragraph needs reworking
08:08:47 <matt_m> "It's a ring so we can divide" doesn't make much sense to me
08:09:10 <Cale> matt_m: It's a ring so we can make sense of division.
08:09:20 <Cale> matt_m: But we can't always divide
08:09:40 <matt_m> Cale:  I guess
08:10:02 * JuanDaugherty wonders why the HP page has haskell-platform-2010.1.0.0.tar.gz for the current tarball if various distros are saying '1.0.0.1' and the like?
08:10:15 <Cale> If b is an element such that there exists some c for which b*c = 1, that is, if b is a unit, then by a/b we mean a*c, where b*c = 1.
08:11:23 <Cale> In the ring of formal power series with coefficients in a field, the condition for some series to be a unit is easy: it just has to have a nonzero constant term.
08:11:31 <kmc> JuanDaugherty, sometimes distros add an extra version component for their own process
08:11:33 <matt_m> Cale:  Hmm, but is the next sentence true?  It says that if intermediate steps require division, we don't need to check
08:11:57 <matt_m> Cale:  Don't know that that's correct if the intermediate objects needn't have existed
08:11:59 <JuanDaugherty> well seems to be SNAFU because they also say ghc 6.12.1 but when you go
08:12:03 <Cale> You *do* need to be careful that whenever you divide, you're really dividing by a unit, or you can end up with nonsense.
08:12:23 <JuanDaugherty> to the ghc site to get 6.12.2 the say STOP use HP
08:12:31 <JuanDaugherty> *they say
08:12:45 <matt_m> Cale: Do you have the paper open?  Read the rest of the paragraph.  Do you think it's Kosher?
08:12:59 <matt_m> Cale: It sounds to me like he's describing a field
08:13:04 <Cale> Which paper?
08:13:11 <matt_m> Byorgeys
08:13:13 <matt_m> '
08:13:22 <matt_m> I can paste a quote since you don't
08:13:24 <Cale> link?
08:13:41 <ski> Cale : i thought `1' was the unit there ?
08:13:56 <Cale> ski: 'unit' refers to any element which has an inverse
08:14:06 <Cale> 1 and -1 are the units in Z
08:14:16 <matt_m> http://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf
08:14:17 <ski> oh
08:14:18 * ski always thought that convention strange
08:14:25 <mreh> is the "Simple Build Infrastructure" the old Setup.hs infrastructure?
08:14:30 <ski> (i use "sub-unit" for that concept)
08:14:43 <matt_m> Cale: ^, section 7.1 , paragraph 3
08:15:44 <matt_m> soupdragon:  What is 1/2?
08:15:58 <Cale> Oh, we could use a larger ring still, and make it into a field
08:16:05 <soupdragon> 1 = (1 - x)(a + bx + cx^2 + ...), [x^0] = 1a ==> a = 1, [x^1] = b-a ==> b = 1, [x^2] = c-b ==> c =
08:16:07 <soupdragon> 1 = (1 - x)(a + bx + cx^2 + ...), [x^0] = 1a ==> a = 1, [x^1] = b-a ==> b = 1, [x^2] = c-b ==> c = 1
08:16:10 <matt_m> Cale:  Then you'd have rational coefficients, right?
08:16:11 <Cale> Use the field of fractions of the ring of formal power series.
08:16:15 <soupdragon> so 1/(1-x) = 1 + x + x^2 + ...
08:16:25 <Cale> The field of "rational functions"
08:16:28 <soupdragon> This should help you to understand division
08:16:34 <soupdragon> if you are able to follow this
08:16:39 <matt_m> Cale:  Right, but I don't think that's what he's talking about
08:16:59 <soupdragon> In particular: We dont have to worry about 'remainders'
08:17:25 <Cale> matt_m: Well, what he's talking about is a way of constructing combinatorial objects which would formally correspond to each rational function
08:17:40 <Cale> (or each formal power series, including ones with negative coefficients)
08:18:08 <Eludias> If I define a function in a function with 'where', can I reuse the type constraint from the outer function in the type declaration?
08:19:05 <Cale> Eludias: By default, any type variables you use in the type signature of the inner function will be fresh and unrelated to the ones in the type declaration for the outer function.
08:19:40 <Eludias> Cale: Yeah, I just noticed. But can those be related, or can this not be done?
08:19:40 <matt_m> soupdragon:  I see 1 / (1-x).  What's 1/2?
08:19:55 <ski> Eludias : use `{-# LANGUAGE ScopedTypeVariables #-}' and then either use `forall' on the outer signature, or use pattern signatures
08:20:11 <Cale> Eludias: If you turn on the ScopedTypeVariables extension, any type variables you explicitly quantify using forall in the outer function's type signature will be 'scoped' and you can use them to refer to those types in the type signatures of definitions in the where clause (or any expressions in the body of the function)
08:20:13 <matt_m> 2 ( a + bx + cx^2 + ...) = 1
08:20:45 <Eludias> Cale: thanks. I now know that I will skip that part for now :)
08:20:49 <Cale> matt_m: 1/2?
08:21:01 <Cale> matt_m: 1/2 is 1/2, if we're talking about Q[[x]]
08:21:13 <matt_m> Cale:  No, he's talking about integer coefficients
08:21:18 <soupdragon> matt_m, no idea what you are getting at
08:21:27 <matt_m> soupdragon:  What is 1 divided by 2?
08:21:55 <Cale> matt_m: 2 isn't a unit in Z
08:22:15 <soupdragon> I don't see how 1/2 has anything to do with this
08:22:29 <matt_m> Cale: right
08:22:42 <Cale> I don't see how 1/2 has anything to do with this either
08:22:49 <soupdragon> matt_m, it should be well known by now that 1 - 1 + 1 - 1 + 1 - 1 + ... = 1/2
08:22:49 <matt_m> soupdragon:  I'm just pointing out that it's not a field
08:23:04 <Cale> If you want to talk about freely dividing species, you'll need a bigger ring than Z[[x]]
08:23:21 <matt_m> soupdragon: hmm
08:23:21 <soupdragon> matt_m, which you get by evaluating the term I showed you at x=-1
08:23:48 <Cale> soupdragon: hah
08:25:13 <matt_m> soupdragon:  I don't know what the point of that was :)
08:25:14 <Cale> But did you know that 1 + 2 + 3 + ... = -1/12 ?
08:25:38 <soupdragon> Cale, did you know that 1*2*3*4*5*6*.. = -1/2 :P
08:25:58 <soupdragon> wait
08:26:00 <soupdragon> that is wrong :(
08:26:07 <matt_m> I'm sure it can be made to work
08:26:08 <soupdragon> sqrt(2 pi)
08:26:15 <soupdragon> and 2 * 3 * 5 * 7 * ... = 4*pi^2
08:26:46 <soupdragon> ah it's 1+1+1+1+1+.. = -1/2
08:26:47 <matt_m> soupdragon:  I read 1 - 1 + 1 - 1 ... as 1 - x + 1 - 1 and it confused me
08:27:10 <matt_m> soupdragon:  So we're not considering a field, right?
08:27:35 <Cale> matt_m: At this point, we're just being silly
08:27:35 <soupdragon> matt_m, you still don't see the point of it?
08:27:53 <Cale> matt_m: If you want to freely consider quotients of things, of course you'll need to go as far as building a field.
08:27:54 <matt_m> Cale: I gather that
08:28:17 <matt_m> Cale:  Do you think the rest of the paragraph I linked was Kosher?
08:28:53 <soupdragon> matt_m, http://en.wikipedia.org/wiki/Grandi%27s_series
08:28:54 <matt_m> "Freely introducing steps of division..." is how you get the kinds of equalities you and soupdragon have just been spouting
08:29:07 <soupdragon> read that
08:29:07 <Cale> matt_m: I think it might be fine. The only virtual species construction I'm aware of only treats additive inverses
08:30:05 <Cale> matt_m: However, there's nothing I can see which would prevent one from extending it to include multiplicative inverses as well
08:30:08 <matt_m> soupdragon:  lol, I can't tell if this is a big joke or if you're trying to make a point
08:30:17 <soupdragon> k ill go do something else
08:30:39 <matt_m> Cale:  that's true - there is a field around, which makes the claim that you can do division true
08:30:49 <matt_m> Cale:  I still think the paragraph could be reworded
08:31:31 <EvanR> well. now i want to make a parser to convert a simple term language into an abstract syntax tree. ive done this in c using bison, something tells me it would be smarter to use haskell, guess ive got some reading to do
08:31:42 <Cale> Just adding the words "to a ring" -> "to a ring or a field"
08:31:51 <Cale> would perhaps make it easier to follow
08:31:51 <matt_m> ya
08:32:01 <kmc> EvanR, yeah, Haskell is a great language for manipulating other languages
08:32:03 <soupdragon> EvanR, try Parsec or ReadP
08:32:11 <EvanR> alright
08:32:18 <soupdragon> they're the best two that I know of
08:32:55 <kmc> Parsec is probably the most popular parser library for Haskell
08:33:03 <Cale> matt_m: In fact, often even more elaborate things are done. Adding square roots is sometimes handy.
08:33:18 <Cale> Well, not *so* often :)
08:33:25 <exDM69> EvanR: yeah, Parsec is great
08:33:29 <kmc> EvanR, there are bison-like tools for Haskell (Happy) but they're not used as much
08:33:59 <EvanR> i tried making one by hand in c once, my brain exploded
08:34:01 <exDM69> EvanR: makes writing parsers very nice and simple. I prefer writing my parser definitions/grammars in the code, not with a code generator
08:34:15 <EvanR> something tells me dong it in haskell will require / facilitate me actually understanding parsers
08:34:21 <matt_m> Cale:  I know you can extend fields... I haven't used much of this algebra since grad school, though
08:34:39 <EvanR> doing*
08:34:52 <kmc> EvanR, kind of.  you can use Parsec without knowing the details of how it works
08:35:00 <kmc> but it's not too hard to write a simple monadic parser combinator library yourself
08:35:18 <kmc> one of the uu-parsinglib tutorials works by building up the library from scratch
08:35:19 <exDM69> EvanR: parsec is not really about formal grammars either (just something that looks a bit similar)
08:35:37 <kmc> (which is a didactic style i've seen a lot in Haskell)
08:36:07 <soupdragon> that uu paper is a nice one
08:36:09 <soupdragon> quite hard though
08:36:42 <kmc> EvanR, the core of the basic idea is something like:  data Parser a = Parser (String -> [(a,String)])
08:36:46 <kmc> which is like how ReadS works
08:36:59 <kmc> a parser is a function that takes a string, and returns zero or more possible parses, each consisting of a value and a remaining string
08:37:29 <kmc> and you can write fmap, pure, (<*>), and (>>=) for this in a pretty natural way
08:37:41 <kmc> and that lets you use applicative or monadic syntax to describe grammars
08:38:02 <kmc> in Parsec, Applicative gets you context-free grammars, and Monad gets you context-sensitive
08:38:04 <kmc> which is a cool result
08:38:14 <kmc> (anyone have a link to a proof or detailed argument?)
08:38:15 <EvanR> does a grammar help me
08:38:33 <EvanR> like the list of definition of terms
08:38:50 <kmc> not sure what you mean
08:39:12 <alexyk> is there a blog aggregator for haskell blogs one can submit hus to?
08:39:28 <EvanR> in bison you write a recursive grammar in bnf and attach reduction actions
08:39:36 <kmc> planet haskell is a blog aggregator
08:39:41 <kmc> it has a lot of non-haskell-related stuff :/
08:39:51 <kmc> like political rants and pictures of people's kids
08:39:56 * hackagebot hashmap 1.0.0.1 - Persistent containers HashMap and HashSet.  http://hackage.haskell.org/package/hashmap-1.0.0.1 (MilanStraka)
08:40:22 * ski thinks some parts of Parsec are too low-level
08:40:32 <EvanR> and to define a sequence of something you have to do these funky moves, and worry about left recursion and right recursion
08:43:33 <kmc> EvanR, yeah, Parsec has simpler ways
08:43:50 <kmc> many :: Parser a -> Parser [a]
08:43:56 <kmc> (simplified)
08:44:08 <kmc> in fact you get that for free by having the Applicative interface
08:44:14 <kmc> many :: Alternative f => f a -> f [a]
08:44:35 <EvanR> this should be interesting
08:44:39 <EvanR> now wheres the doc
08:44:46 <aavogt> alternative is another class though
08:44:51 <EvanR> i got the hackage page...
08:44:53 <EvanR> where to begin
08:46:54 <aavogt> kmc: the handwaving proof is that Applicative doesn't let you choose some effects based on the contents
08:47:10 <kmc> you're right, i should say "for free by having Alternative"
08:49:48 <Spewns> good morning/afternoon/evening/whatever it is where you live folks
08:50:09 <aristid> @src [] many
08:50:09 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:51:31 <aavogt> > many []
08:51:32 <lambdabot>   [[]]
08:51:34 <kmc> hi Spewns
08:51:38 <aavogt> > many ["abc"]
08:51:42 <lambdabot>   mueval-core: Time limit exceeded
08:52:02 <Axman6> would it be possible to write an Alternative instance for IO, where the alternative is taken when the first action throws an exception?
08:53:07 <jmcarthur> sounds more like something i'd want for STM than for IO
08:53:13 <jmcarthur> since i'd want rollback most of the time
08:53:21 <kmc> hmm you'd have empty :: IO a
08:53:29 <kmc> and the usual cop-out is to set empty = error "empty not defined"
08:53:34 <jmcarthur> empty could just be an exception
08:53:36 <kmc> but in this case, that's perversely sort of what you want
08:53:42 <jmcarthur> that would somewhat satisfy the monad laws
08:53:42 <kmc> since it should be a unit of (<|>)
08:53:50 <jmcarthur> err
08:53:51 <jmcarthur> monoid
08:55:47 <jmcarthur> i'm guessing this is basically what STM's MonadPlus instance does
08:57:16 * kmc wrote the little Alternative IO instance and it seems to work
08:57:19 <Axman6> kmc: so i'm basically a genius then?
08:57:25 <kmc> no doubt
08:57:33 <Axman6> :P
08:57:47 <Axman6> so, this looks interesting: http://www.dealextreme.com/details.dx/sku.28896
08:58:00 <EvanR> :t many
08:58:01 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
08:58:02 <Axman6> if for no better reason than the big whopping FPGA on the PCI card
08:58:24 <Axman6> > many (Just a)
08:58:27 <lambdabot>   mueval-core: Time limit exceeded
08:59:29 <kmc> shiny
09:00:16 <kmc> not sure why they call it "LAN Workstation"
09:01:06 <Axman6> it's a chinese market stall that's been put online and injected with drugs, the descriptions on DealExtreme are always fun :)
09:01:24 <EvanR> god dammit
09:01:27 <EvanR> import Parsec
09:01:31 <EvanR> could not find module Parsec
09:01:35 <kmc> Text.Parsec
09:01:44 <EvanR> someone should fix this documentation
09:01:46 <kmc> or on older versions Text.ParserCombinators.Parsec
09:01:48 <kmc> yeah it's old
09:02:20 <EvanR> the older version worked
09:05:18 <maltem> Axman6, so, a terminal over LANâ€¦ if it performs decent, I'll say cool indeed
09:05:42 <kmc> apparently it is a pirate copy of the NComputing X300
09:05:55 <Axman6> could be a good way to save some cash in certain situations
09:06:07 <Axman6> the FPGA is what fascinates me most though
09:06:16 <Axman6> it's quite a good one i believe
09:07:24 <maltem> kmc, are those things popularly used somewhere?
09:07:42 <kmc> ?
09:07:53 <Taejo> @hoogle [Parser a] -> Parser a
09:07:53 <lambdabot> No results found
09:08:12 <aavogt> @hoogle [m a] -> m a
09:08:13 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
09:08:13 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
09:08:13 <lambdabot> Data.IntMap unions :: [IntMap a] -> IntMap a
09:08:22 <Taejo> aavogt: thanks
09:08:51 <Axman6> http://www.dealextreme.com/details.dx/sku.39448 is far more interesting
09:08:52 <aavogt> @src Alternative
09:08:52 <lambdabot> class Applicative f => Alternative f where
09:08:53 <lambdabot>     empty :: f a
09:08:53 <lambdabot>     (<|>) :: f a -> f a -> f a
09:09:28 <aavogt> Taejo: I think there's an equivalent to msum for Alternative, if there's no MonadPlus instance for your Parser
09:10:00 <Twey> Hmph
09:10:09 <Twey> Why do we have Control.Monad but Data.Functor?
09:10:23 <Taejo> aavogt: afair, parsec 2 has a monadplus instance but no alternative
09:10:44 <aavogt> Control.List
09:10:53 <aavogt> Twey: I think Data and Control are arbitrary
09:11:33 <Twey> Hm
09:11:39 <kmc> :)
09:11:46 <kmc> in a functional language they are two sides of the same coin
09:12:03 <aavogt> Data.IO
09:12:05 <Twey> And Monoid is to MonadPlus as Alternative is toâ€¦?
09:12:18 <Saizan> Applicative
09:12:24 <Twey> Ah
09:12:26 <Saizan> oh sorry
09:12:29 <Twey> Really?
09:12:31 <Saizan> i've read Monad
09:12:36 <Twey> Ah
09:12:36 <aavogt>  Monad -> MonadPlus  is like  Applicative -> Alternative
09:13:38 <Saizan> and Monoid has the same relationship with both of those
09:13:57 <aavogt> Twey: maybe there's a class      Alternative2 (f :: * -> * -> *) where eempty :: f a b; (<<|>>) :: f a b -> f a b -> f a b
09:14:14 <Taejo> does Monad + MonadPlus give you anything more than Monad + Alternative?
09:14:30 <aavogt> or should the kind there be     f :: (* -> *) -> *?
09:14:57 <kmc> Taejo, don't think so, they look like identical classes up to renaming
09:15:32 <Twey> So MonadPlus is just a wart from the lack of Applicative superclass on Monad?
09:15:46 <aavogt> but laws people!
09:15:54 <EvanR> whats a parser that parses a sequence of letters
09:16:06 <kmc> Twey, no, because something could be both Monad and Applicative but neither MonadPlus nor Alternative
09:16:21 <EvanR> many1 letter?
09:16:25 <Saizan> EvanR: yep
09:16:55 <kmc> MonadPlus implies (Monad implies Applicative) and Alternative
09:16:59 <kmc> Alternative implies Applicative
09:17:35 <aavogt> Saizan: if you
09:17:45 <Saizan> disregarding laws involving (>>=) if Alternative was there before, and Applicative was a superclass of Monad, there wouldn't be a need for MonadPlus
09:17:47 <Twey> kmc: Sure, but if Monad implied Applicative then you could simply have Alternative on that monad (or not, if inappropriate)
09:17:54 <Twey> Right
09:17:57 <aavogt> 're interested in the alternative to that existential stuff I was asking about http://www.haskell.org/pipermail/xmonad/2010-May/010271.html
09:18:01 * Lajla hugs Twey
09:18:12 <Twey> Lajla: \o
09:18:13 <Saizan> now, we're not even clear on which laws should hold between mplus and (>>=).. :)
09:18:32 * Lajla touches twey's bum
09:18:42 <EvanR> hrm an expression can be a reserved keyword or some other identifier, should i use try to differentiate?
09:19:06 * Lajla admires Twey's Brittish accent.
09:19:14 * soupdragon teaches Lajla haskell
09:19:37 <Lajla> soupdragon, I'll have you know I'm the second best programmer in the world, second only to the Microsoft Chief Software Architect.
09:19:43 <kmc> Twey, you're right
09:19:46 <Saizan> aavogt: alternative?
09:19:48 <soupdragon> oh :)
09:20:08 <aavogt> Saizan: so an approach that doesn't try to hide the differing types
09:20:19 <Lajla> Twey is always right.
09:20:24 <kmc> hmm
09:20:31 <kmc> laws should be easier to think of in terms of (>=>)
09:20:41 <aavogt> fish
09:20:48 <maltem> kmc: I was just wondering because I've never seen those; all offices I've seen have 1 PC / worker
09:21:28 * geheimdienst snores code in his sleep. a few days back he even managed to understand monads. in his book, that makes him clearly on par with the microsoft chief software architect.
09:21:49 <soupdragon> I wrote 30k lines of C++ when I rolled over in bed
09:21:55 <Lajla> geheimdienst, isn't that 'geheime dienst'?
09:22:06 <Lajla> 'de dienst' not 'het dienst'
09:22:22 <kmc> haha geheimdienst
09:22:40 <gwern> once, I met Bill Gates in an alley; his kung fu was no match for my taekwondo
09:22:51 <Saizan> kmc: seen http://www.haskell.org/haskellwiki/MonadPlus ?
09:23:05 <maltem> Lajla, different language I guess
09:23:07 <geheimdienst> lajla, you from holland? it's "der Geheimdienst" where i come from
09:23:24 <Lajla> geheimdienst, ahh, gestapo.
09:23:37 <geheimdienst> also, this incident has been noted. expect ninjas to drop through the window sometime soon
09:23:43 <maltem> that would actually have been Geheime Staatspolizei iirc
09:23:46 <Lajla> Geheime Staatspolizei.
09:23:59 <Lajla> geheimdienst, but i support the GPL. =(
09:24:23 <aavogt> that's not how it works in haskell-land
09:24:24 * EvanR looks at the window he never know was there
09:24:32 <geheimdienst> GPL -- Geheime Polizei What?
09:24:46 <EvanR> look i can see #ocaml across the street
09:24:58 <geheimdienst> also, LGPL, lesser geheime polizei
09:25:09 <gwern> geheimdienst: can those be banished just by holy water?
09:25:11 <Lajla> I was banned from #scheme for defending holocaust denial as falling under freedom of speech.
09:25:23 <kmc> "The default mplus doesn't satisfy mplus mzero b = b, so you lose Monoid which seems to be the only thing people actually agree on :)"
09:25:29 <gwern> Lajla: I think you were banned from #scheme for being offtopic...
09:25:38 <Saizan> Lajla: not for being wildly offtopic?
09:25:44 <Axman6> eh
09:25:48 <Axman6> heh*
09:25:55 <soupdragon> free speech? LOL
09:26:01 <Twey> What is the default mplus?
09:26:13 <aavogt> const?
09:26:14 <Twey> mplus a b = a?
09:26:21 <Twey> Damn
09:26:33 <Lajla> gwern, yeah, but off topic about defending holocaust denial.
09:26:51 <aristid> Twey: i don't think there's a default mplus?
09:26:56 <Axman6> so yes, you were banned for being off topic
09:27:08 <Axman6> the topic that you were off with isn't so important ;)
09:27:17 <Lajla> Axman6, in theory, but is it so in practise?
09:27:26 <Lajla> I wasn't banned when I spoke French.
09:27:37 <Lajla> or is that practice.
09:27:50 <Lajla> Twey, your Brittanic man, you answer that.
09:27:51 <Twey> â€˜Practiceâ€™.
09:28:04 * Lajla hugs Twey's Brittanic rear.
09:28:42 <gwern> how can there be a default mplus? can you define it with mempty and mappend?
09:28:50 <gwern> ?info Monoid
09:28:50 <lambdabot> Monoid
09:29:01 <Twey> gwern: mplus = const is pretty easy to define by default.
09:29:04 <gwern> (That was so helpful, lambdabot.)
09:29:14 <Saizan> mplus is for MonadPlus, which doesn't have Monoid as a superclass
09:29:24 <Saizan> ?info do x; y
09:29:25 <lambdabot> x >> y
09:29:44 <wagle> look at the MonadPlus class source to see if it has a default defn for mplus
09:29:51 <aristid> Twey: but mplus = const would not satisfy  mzero `mplus` x = x
09:30:14 <wagle> @hoogle MonadPlus
09:30:14 <lambdabot> Control.Monad class Monad m => MonadPlus m
09:30:14 <Twey> aristid: And lo, it doesn't
09:30:25 <Twey> aristid: That was kind of the point ;)
09:30:38 * geheimdienst is bewildered and slightly scared how lajla is so obsessed with twey's behinditude
09:31:28 <Saizan> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Control-Monad.html#MonadPlus <- but the wiki lied, there's no default
09:31:35 <Lajla> geheimdienst, well, it is British after all.
09:31:50 <Saizan> (or, well, it's merely outdated, most probably
09:31:59 <Lajla> Twey, does your bum fart with a bad-lad and trap-bath split?
09:33:31 <Inglorion> heh, Lajla, @ geheime dienst, i was having a conversation about that with gd earlier
09:33:41 <soupdragon> you should keep your pet on a leash :/
09:34:05 <Absolute0>  /join #archlinux
09:34:09 <Lajla> Inglorion, about the spelling? Or Twey's brittanic behind?
09:34:12 <Axman6> Lajla: you're quite strange
09:34:15 * geheimdienst looks embarrassed. what exactly are you referring to, inglorion? we conversed about twey's farting derriere?!
09:34:22 <Inglorion> hahaha
09:34:27 <Lajla> Axman6, well, Twey's behind unleashes that in a man, now doesn't it?
09:34:32 <Inglorion> no, about "geheime dienst" vs. "geheimdienst"
09:34:34 <Lajla> Makes me lose all sanity.
09:34:38 <Inglorion> sorry for the confusion
09:34:40 <Axman6> i wouldn't know
09:34:41 <Lajla> Ahh, Gestapo.
09:34:49 <Lajla> Inglorion, well, you are weird, but I can live with it.
09:34:54 <soupdragon> @where ops
09:34:54 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
09:35:03 <aristid> geheimdienst means secret service, not gestapo
09:35:10 --- mode: ChanServ set +o dcoutts
09:35:13 <Inglorion> exactly
09:35:27 <Lajla> Well, Gestapo is a contraction for 'Secret state police'
09:35:30 <xerox> what is going on
09:35:40 <geheimdienst> yeah, intelligence service, i would say ... "secret service" sounds more like the US president's bodyguards
09:36:08 <Axman6> Lajla: are you here to talk about haskell or not?
09:36:13 <Inglorion> i've always found it funny when i read stories that talk about <agency name> and then later on refer to it as the "secret service"
09:36:22 <Inglorion> if you know about it, it's not secret, right?
09:36:23 <Saizan> anyhow, this is still #haskell, to discuss about german or other topics you can use #haskell-blah, if you want.
09:36:26 <chrisdone> added a couple more chapters to http://tryhaskell.org
09:36:30 <geheimdienst> xerox, lajla keeps getting bodily with twey's bottoms. no one knows why.
09:36:30 <Lajla> Axman6, sure.
09:36:31 <aristid> @hoogle MonadPlus
09:36:32 <lambdabot> Control.Monad class Monad m => MonadPlus m
09:36:55 <chrisdone> i took the automatic type-sig display out, to be enabled in the types chapter
09:37:00 <aristid> i wonder if there are many instances of MonadPlus other than [] and Maybe
09:37:04 <Axman6> well, talk about haskell then. I have a feeling you're on the verge of being banned from another channel
09:37:09 <aavogt> geheimdienst: ah, but buttom is useful to think about what haskell means
09:37:11 <chrisdone> so i can say 'look i slipped types into your brain without you even noticing'
09:38:58 <Saizan> chrisdone: except that lesson1 step3 is called "Types of Values" :)
09:39:11 <aristid> i think it's funny that (:) = mplus . return
09:39:24 <chrisdone> Saizan: haha, damn, i thought i'd stripped all the explicit references to types out
09:39:27 * chrisdone removes
09:39:27 <aavogt> types in an informal sense perhaps
09:39:37 <kmc> "mcons" :)
09:39:40 <ski> @type foldr (mplus . return) mzero
09:39:41 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
09:39:46 <Inglorion> grep is your friend :-)
09:40:32 <Taejo> @pl \x -> (char (toLower x) <|> char (toUpper x))
09:40:32 <lambdabot> ap ((<|>) . char . toLower) (char . toUpper)
09:40:33 <aavogt> but maybe your audience already knows types from another programming language
09:40:36 <aristid> ski: it's even better if you use Data.Foldable
09:40:46 <aristid> @type Data.Foldable.foldr (mplus . return) mzero
09:40:47 <lambdabot> forall (m :: * -> *) a (t :: * -> *). (MonadPlus m, Data.Foldable.Foldable t) => t a -> m a
09:40:52 <ski> hm. point
09:41:02 <Taejo> :t mapM
09:41:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:41:07 <chrisdone> actually that one's ok
09:41:12 <ski> .. but is there a name for this operation ?
09:41:24 <ski> `listToMonadPlus' ?
09:41:24 <aavogt> @type Data.Foldable.foldMap
09:41:25 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
09:41:37 <ski> @type listToMaybe
09:41:37 <aristid> ski: it takes all Foldables
09:41:38 <lambdabot> forall a. [a] -> Maybe a
09:41:45 <koeien37> Can I somehow change the priority of GHC threads?
09:42:07 <ski> aristid : yes .. but i was wondering about `foldr (mplus . return) mzero' (possibly using the `Data.Foldable' one)
09:42:13 <aristid> > Data.Foldable.foldr (mplus . return) mzero [1,2,3] :: [Integer]
09:42:14 <lambdabot>   [1,2,3]
09:42:29 <aristid> > Data.Foldable.foldr (mplus . return) mzero (Just Integer) :: [Integer]
09:42:30 <ski> i.e. what to call this operation ?
09:42:30 <lambdabot>   Not in scope: data constructor `Integer'
09:42:36 <aristid> > Data.Foldable.foldr (mplus . return) mzero (Just 1) :: [Integer]
09:42:37 <lambdabot>   [1]
09:42:53 <aristid> > Data.Foldable.foldr (mplus . return) mzero [1,2,3] :: Maybe Integer
09:42:54 <lambdabot>   Just 1
09:42:54 <chrisdone> ski: good point. listToMPlus is maybe nicer than listToMaybe for being generic
09:43:11 <aristid> chrisdone: foldableToMPlus wins :P
09:43:21 <Saizan> chrisdone: lesson1 step7, if i click on the expression and hit enter i get a lexical error
09:43:42 <chrisdone> SaizanL let me check that
09:44:05 <chrisdone> ahh
09:46:41 <maltem> @hoogle msum
09:46:41 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
09:46:41 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
09:46:59 <aristid> the standard functions use too few classes
09:47:01 <aristid> :t foldr
09:47:02 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:48:22 <maltem> :t Data.Foldable.msum . Data.Foldable.map return
09:48:23 <aristid> @hoogle map
09:48:23 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
09:48:23 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
09:48:23 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
09:48:24 <lambdabot> Not in scope: `Data.Foldable.map'
09:48:40 <maltem> :t Data.Foldable.msum . fmap return
09:48:41 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Foldable.Foldable t, MonadPlus m, Functor t) => t a -> m a
09:49:02 <aristid> maltem: yeah but that introduces a stupid Functor requirement
09:49:48 <maltem> yup
09:49:59 <chrisdone> Saizan: cheers, fixed that bug.
09:50:19 --- mode: ChanServ set -o dcoutts
09:51:07 <ski> @type Data.Foldable.msum . Data.Traversable.traverse return
09:51:08 <lambdabot>     Ambiguous type variable `t' in the constraints:
09:51:08 <lambdabot>       `Data.Foldable.Foldable t'
09:51:08 <lambdabot>         arising from a use of `Data.Foldable.msum' at <interactive>:1:0-17
09:51:09 * Saizan confirms
09:51:27 * ski always finds it strange that `traverse' is called that
09:52:00 <ski> (maltem : but yes, that's another implementation of it)
09:52:36 <chrisdone> Saizan: problem was that the \173 character is &shy; or "word break", which is used in the console library's htmlencode function to auto-break-up long words. i used it in tryhaskell without removing the word break code
09:53:52 <Axman6> > '\173'
09:53:53 <lambdabot>   '\173'
09:54:00 <Axman6> thanks lambdabot
09:54:01 <mauke> U+00AD (c2 ad): SOFT HYPHEN [Â­]
09:54:19 <chrisdone> thanks maukebot
09:56:59 <roconnor> > deriv (\x -> log (x/(1-x)*(1-x^6)) x
09:57:00 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:57:05 <roconnor> > deriv (\x -> log (x/(1-x)*(1-x^6))) x
09:57:06 <lambdabot>   ((1 * recip (1 - x) + x * negate (negate 1 * recip (1 - x) * recip (1 - x))...
09:57:13 <roconnor> > simpl $ deriv (\x -> log (x/(1-x)*(1-x^6))) x
09:57:14 <lambdabot>   Not in scope: `simpl'
09:57:22 <roconnor> > simp $ deriv (\x -> log (x/(1-x)*(1-x^6))) x
09:57:22 <lambdabot>   Not in scope: `simp'
10:00:27 <soupdragon> roconnor  1/(x^6+x^5+x^4+x^3+x^2+x) + 6x^4/(1+x^5+x^4+x^3+x^2+) + 5x^3/(1+x^5+x^4+x^3+x^2+x) + 4x^2/(1+x^5+x^4+x^3+x^2+x) + 3x/(1+x^5+x^4+x^3+x^2+x)
10:01:11 <gio123_> ski
10:03:20 <Taejo> @src min
10:03:20 <lambdabot> min x y = if x <= y then x else y
10:04:30 * Polarina yawns.
10:05:55 <aristid> @src minimum
10:05:55 <lambdabot> minimum [] = undefined
10:05:55 <lambdabot> minimum xs = foldl1 min xs
10:06:38 <aristid> @pl f x y = [x,y]
10:06:38 <lambdabot> f = (. return) . (:)
10:06:40 <roconnor> soupdragon: thx
10:06:45 <chrisdone> why the [] pattern i wonder
10:06:50 <soupdragon> roconnnor soorry I typed i wrong :(
10:06:51 <chrisdone> @src foldl1
10:06:51 <lambdabot> foldl1 f (x:xs) = foldl f x xs
10:06:51 <lambdabot> foldl1 _ []     = undefined
10:07:01 <soupdragon> missing was an x, 6x^4/(1+x^5+x^4+x^3+x^2+x)
10:07:02 <chrisdone> foldl takes care of this ~_~
10:07:26 <soupdragon> I have to run ubuntu in a different window than mac and it doesn'tcopy back and forth :/
10:07:37 <chrisdone> clipboard?
10:08:39 <geheimdienst> i think you need a little tool inside the virtual machine to pull out the clipboard contents
10:08:59 <ville> How's one supposed to be installing any of the haskell-<packages> from AUR? ayourt at least seems to be running in infinite dependency loop.
10:09:23 <ville> sorry, yaourt
10:10:03 <ville> and wrong channel too.
10:10:34 <Saizan> yaourt is broken wrt. "provides" so you've to use some other tool
10:11:47 <geheimdienst> ville, i've been using clyde for some time now for pacman work and aur work. never gave me any trouble, seems to work well. however i don't do very much with aur packages
10:12:07 <ville> geheimdienst: ok have to see about it.
10:12:24 <geheimdienst> http://clyde.archuser.com/
10:17:42 <mauke> so I want to wrap a C library in Haskell
10:17:51 <mauke> prototype here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25819#a25819
10:18:03 <mauke> does this look sane so far?
10:18:48 <mreh> I want to do this too
10:20:17 <kmc> looks reasonable mauke
10:20:29 <kmc> i kinda dislike the recursive newtype hack
10:21:33 <dcoutts> kmc: c2hs uses the same "recursive newtype hack"
10:21:34 <danderson> mauke: a random suggestion, you might consider using c2hs to help you build the bindings
10:21:40 <dcoutts> I would not necessarily consider it a hack
10:22:01 <kmc> dcoutts, it emits code using it?
10:22:18 <dcoutts> kmc: yes, oh though not quite the same way that mauke is using it.
10:22:25 <danderson> the library seems to be about building native pointers to stuff and doing stuff with it
10:22:26 <kmc> it's not a big deal either way
10:22:41 <kmc> i think it's an idiom that's hard to understand unless you recognize it specifically
10:22:43 <danderson> c2hs handles that kind of thing rather nicely with the marshaller abstraction
10:22:53 * monochrom loves recursive newtype
10:22:53 <dcoutts> kmc: it uses a recursive newtype for ForeignPtrs, like newtype Foo = Foo (ForeignPtr Foo)
10:23:04 <kmc> ah
10:23:12 <dcoutts> so not like mauke's void type
10:23:12 <chrisdone> monochrom: oh yeah?
10:23:36 <monochrom> newtype Moo a = Moo (Moo a)
10:24:05 <monochrom> aka newtype Mu a = In {out:: Mu a}
10:24:21 <mreh> dcoutts: can you use that?
10:24:23 <dcoutts> mauke: so you could use c2hs's trick rather than your:
10:24:24 <dcoutts> newtype UnibiTerm = UnibiTerm UnibiTerm  -- Void
10:24:26 <mreh> is it useful
10:24:40 <dcoutts> use, newtype UnibiTerm = UnibiTerm (Ptr UnibiTerm)
10:24:59 <dcoutts> rather than a raw Ptr UnibiTerm
10:25:18 <mauke> then I need an additional unwrap step, right?
10:25:28 <dcoutts> yes
10:25:58 <mauke> so more typing for me, no change in the API
10:26:16 <dcoutts> mauke: oh actually you could just go straight for  newtype UnibiTerm = UnibiTerm (ForeignPtr UnibiTerm)
10:26:32 <dcoutts> since at the higher level you're using data Terminal = Terminal{  pterm :: ForeignPtr UnibiTerm,
10:26:41 <mauke> yes, that's what I meant
10:26:45 <dcoutts> that'd become just  pterm :: UnibiTerm,
10:27:49 <uorygl> @type interact
10:27:52 <lambdabot> (String -> String) -> IO ()
10:27:58 * uorygl nods.
10:28:04 <dcoutts> mauke: so this API would be fine for c2hs, and would be shorter and safer as a result
10:30:26 <mauke> is there a version of http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/index.html with a non-broken charset?
10:33:29 <EvanR> my initial attempt to use parsec failed since my grammar is left recursive the basic way went into an infinite loop
10:33:57 * EvanR looks into Parsec.Expr
10:35:38 <Inglorion> ok, here's something i'm not getting. see http://haskell.pastebin.com/29xZrrfF
10:35:59 <Inglorion> the compiler claims: Couldn't match expected type `[a]' against inferred type `Char'
10:36:12 <Inglorion> In the first argument of `length', namely `centsString'
10:36:24 <mauke> yes, because centsString is a Char
10:36:25 <c_wraith> Inglorion, do notation isn't doing anything like what you expect in this case
10:36:28 <Inglorion> apparently, it has somehow inferred the type of centsString as Char
10:36:32 <Cale> Inglorion: You're using the list monad
10:36:34 * hackagebot snap-core 0.2.5 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.5 (GregoryCollins)
10:36:50 <Inglorion> ah
10:36:51 <mauke> Inglorion: you said centsString <- show ... and show returns a [Char]
10:36:54 <geheimdienst> mauke, when i tell opera to force utf8, it looks ok
10:36:54 <Cale> Inglorion: That says to pick centsString in all possible ways as an element of show (round (n * 100) :: Integer)
10:36:55 <mauke> hence centsString :: Char
10:37:04 <Inglorion> ok, yes
10:37:07 <mauke> geheimdienst: yes, but you need to repeat that for every page
10:37:14 <c_wraith> Inglorion, you really want to be using a let or a where for all those name bindings
10:37:14 <Inglorion> i think i got my monads mixed up :-)
10:37:37 <Cale> Inglorion: You don't need a monad for what you're trying to accomplish here :)
10:37:43 <Cale> Inglorion: Just use let or where
10:37:52 <geheimdienst> inglorion, a frequent mistake among haskell programmers
10:37:56 <Inglorion> yes, indeed. i've been doing too much of parsec and IO
10:38:22 <Inglorion> i'm also thinking there is a much better way to write this function that i'm failing to see
10:38:30 <mauke> what is this supposed to do?
10:38:34 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
10:38:35 * hackagebot snap-server 0.2.5 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.5 (GregoryCollins)
10:38:35 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
10:38:47 <Inglorion> fyi, i want to take a rational and produce a string, with two decimals. e.g. "8.13"
10:39:18 <Inglorion> also, is it just me, or does haskell pastebin completely FUBAR layout?
10:39:34 <mauke> printf "%.2f" x
10:39:53 <Inglorion> where is printf?
10:39:59 <chrisdone> Inglorion: are you using tabs? if so, (1) naughty (2) change to spaces
10:40:05 <EvanR> #include <stdio.h>
10:40:11 <Inglorion> lol, EvanR
10:40:11 <Cale> > (realToFrac 437829 % 1289) :: Centi
10:40:12 <lambdabot>   Not in scope: type constructor or class `Centi'
10:40:21 <Cale> Oh, should import that :)
10:40:24 <EvanR> @hoogle printf
10:40:24 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
10:40:24 <lambdabot> module Text.Printf
10:40:24 <lambdabot> Text.Printf class PrintfArg a
10:40:27 <Inglorion> chrisdone: no, i am not using tabs
10:40:40 <mauke> Inglorion: Text.Printf.Mauke
10:40:59 <Cale> I also missed the $, some good fail there ;)
10:41:14 <chrisdone> Cale: i didn't want to kick you when you were down :p
10:41:18 <Cale> Inglorion: anyway, the right way, I'd say, is just to convert it to a Centi from Data.Fixed
10:41:53 <Polarina> > let f = (. ((. ((. (((return .) .) . (,,))) . (.) . (>>=))) . (.) . (>>=))) . (.) . (>>=) in f [1,4,6] [4,5] [6,7,8]
10:41:54 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(4,4,6),(4,4,7),(4,4,8),(4...
10:42:11 <Cale> @undefine
10:42:13 <xerox> that's a lot of dots
10:42:25 <Cale> > realToFrac $ 437829 % 1289 :: Centi
10:42:25 <lambdabot>   Not in scope: type constructor or class `Centi'
10:42:28 <Cale> hmm
10:42:33 <geheimdienst> polarina, thanks for clearing that up
10:42:40 <Polarina> geheimdienst, you're welcome. :)
10:43:08 <mauke> > $(id)
10:43:09 <lambdabot>   <no location info>: parse error on input `$'
10:43:15 <Rotaerk> that's soo readable
10:43:16 <Cale> > realToFrac $ 437829 % 1289 :: Fixed E2
10:43:17 <lambdabot>   Ambiguous occurrence `Fixed'
10:43:17 <lambdabot>  It could refer to either `Data.Fixed.Fixed', ...
10:43:21 <Cale> huh
10:43:28 <Inglorion> haha
10:43:45 <Cale> oh, numbers also defines a fixed point type
10:44:47 <Inglorion> any of them should be fine for me, so long as they can represent arbitrarily large numbers, and preferably also arbitrary precision
10:45:07 <BONUS> terminology question: if a function isn't partial, is it correct to say that its patterns are exhaustive
10:45:16 <Cale> Oh, it seems that in the old version of GHC that lambdabot has, Data.Fixed didn't define as many variants
10:45:23 <Cale> That's unfortunate.
10:45:37 <sioraiocht> BONUS: I would say yes
10:45:50 <sioraiocht> though not the other way around ;)
10:45:54 <Cale> BONUS: That would be a requirement. The converse isn't necessarily true
10:46:11 <BONUS> true
10:46:32 <geheimdienst> bonus, and a partial function is not to be confused with a partially applied function ...
10:46:40 <Inglorion> Cale: ok, so are any of the alternatives that have been presented in Haskell 98?
10:47:15 <BONUS> geheimdienst: of course :)
10:47:25 <mauke> Inglorion: why do you care?
10:47:36 <Inglorion> because i'm a sucker for standards :-)
10:47:47 <Cale> Inglorion: In Haskell 98 alone, I suppose one option is to convert to Float or Double and then use showFFloat from the Numeric module.
10:47:51 <mauke> Inglorion: and you don't like libraries?
10:47:57 <Inglorion> and then i won't run into problems like "oh, but this system has an older/newer version of this module" like Cale just did
10:48:09 <Cale> Haskell 98 is out of date and doesn't have much in the way of libraries ;)
10:48:19 <mauke> Inglorion: are you using Data.Ratio?
10:48:21 <Inglorion> fair enough. so where's the updated standard?
10:48:37 <Inglorion> mauke: i have "import Ratio"
10:48:41 <Cale> There's Haskell 2010, but it hardly changes anything, and is still practically speaking out of date.
10:48:42 <mauke> ouch
10:49:26 <Inglorion> hmm, pity
10:50:15 <Cale> For now, your best bet for standards is just specifying which extensions and versions of the libraries things work with.
10:50:28 <Inglorion> ok. more newb questions. how can i find out which libraries i have on my system?
10:50:48 <Inglorion> i mean, obviously i could find out by running import, but i would like to have a list of libraries
10:50:53 <EvanR> ghc-pkg lis
10:50:55 <EvanR> t
10:51:11 <Cale> Well, you can determine which packages you have using ghc-pkg list, but that doesn't tell you which modules each one exposes.
10:51:21 <Inglorion> right
10:51:29 <EvanR> what fun would that be
10:51:31 <Inglorion> that gives more or less the same thing i got with ls :-)
10:51:49 <EvanR> you could probably write an awk script to produce the module names
10:51:56 <Inglorion> i wouldn't figure from that that i have Data.Fixed, even though i do apparently have that
10:51:57 <Cale> The way I have things set up, I can point my web browser to file:///home/cale/.cabal/share/doc/index.html  and get a complete list of installed modules
10:52:40 <Cale> Add the line  "documentation: True"  to ~/.cabal/config
10:52:48 <Inglorion> one more. i have about half a million things imported in my ghci session. how can i clean that up, besides restarting ghci?
10:53:03 <Cale> and it'll build and update an index every time you install a package from hackage using cabal
10:53:28 <Cale> :m - Module.Name
10:53:44 <Inglorion> heh. i only just installed cabal :-)
10:54:17 <Inglorion> thanks for all the answers!
10:54:51 <geheimdienst> and you could run this and pipe it to some file: cabal list --installed --simple-output| cut -f 1 -d " "| xargs -L1 cabal info
10:56:14 <Inglorion> thanks, geheimdienst
10:56:58 <geheimdienst> mai shell-foo iz strong todays
10:57:28 <Inglorion> :-)
10:59:17 <Cale> http://cale.yi.org/cabaldoc/ -- you'll get an index like this
10:59:31 <Cale> (that's what I currently have installed)
11:00:39 <Inglorion> that's neat, Cale
11:01:26 <Inglorion> ok. so Text.Printf doesn't actually have what i need, because it wants Float or Double, and i don't ;-)
11:02:21 <mauke> hence Text.Printf.Mauke
11:02:25 <Cale> heh
11:02:34 <Inglorion> yes, i found that on hackage :-)
11:02:36 <mauke> but it will convert to Double internally anyway
11:02:39 <Cale> Printf is so conceptually ugly though
11:02:57 <Cale> Of course, you could just:
11:03:20 <Cale> > showFFloat (Just 2) (realToFrac (5892 % 428) :: Double) ""
11:03:21 <lambdabot>   "13.77"
11:03:25 <Inglorion> Cale: you're right. on the other hand, in 2010, should i really be writing my own functions for dealing with arbitrary precision decimal numbers?
11:05:08 <aavogt> printf is an EDSL, no?
11:05:16 <aavogt> give it a nice name :)
11:05:39 <Inglorion> hmm. what does EDSL stand for?
11:05:44 <Inglorion> E = embedded?
11:05:47 <jre2> embedded dsl
11:05:48 <Cale> yeah
11:05:54 <Inglorion> ok, i get it then :-)
11:06:10 <Inglorion> i've been wondering all day and i just figured the answer right after asking ...
11:06:31 <Cale> But it's not really very nicely typed because of the format strings.
11:06:51 <Cale> (You could do things with template haskell to fix that, but why?)
11:06:59 <Inglorion> seriously, i'd much rather do without printf
11:07:01 <mauke> because printf is nice
11:07:22 <Inglorion> it just so happens that printf is the most convenient way to format numbers in many programming languages
11:07:32 <geheimdienst> printf is a DSL for sure, but E? i mean, it's opaque strings that get interpreted by an ad-hoc interpreter. i always thought the E referred to "embedded into the syntax of the host language, not just strings"
11:07:56 <Cale> geheimdienst: Yeah, I agree.
11:08:01 <aavogt> geheimdienst: embedded in a host language vs. having a separate compiler
11:08:07 <Cale> Inglorion: Probably just writing a function in terms of showFFloat is your best bet :)
11:08:17 <Starfire> Is printf strongly typed?
11:08:25 <portnov> :t printf
11:08:26 <lambdabot> forall r. (PrintfType r) => String -> r
11:08:39 <geheimdienst> printf is stringly-typed. next question!
11:08:44 <Starfire> > printf "%d" "not a number" :: String
11:08:44 <mauke> what would you rather write, ã€ŒshowFFloat (Just 2) (realToFrac (5892 % 428) :: Double) ""ã€ or ã€Œprintf "%.2f" (5892 % 428)ã€?
11:08:45 <lambdabot>   "*Exception: Printf.printf: bad argument
11:09:11 <Cale> Starfire: Not very. It's polymorphic and allows types under which it will always fail.
11:09:16 <Starfire> So it's strongly, but dynamically typed?
11:09:39 <mauke> Starfire: "strongly typed" is meaningless
11:09:54 <aavogt> no, it's type is known at compile time when you use it
11:10:26 <Cale> You can make a better printf where the initial parameter to printf is not a string, but uses a GADT to collect the types of the parameters to follow. :)
11:10:28 <kmc> the static type of printf is String -> T -> T -> ... -> T -> String
11:10:37 <mauke> Cale: that's a worse printf
11:10:39 <Starfire> What I really mean is that it can't check at compile time whether the types of the arguments match with the types expected by the format string.
11:10:40 <kmc> where T stands for "any type that could be an arg to some printf format specifier"
11:10:49 <kmc> it is only checked at runtime that those types match the specific specifiers
11:10:51 <kmc> Starfire, correct
11:10:52 <Inglorion> OCaml has printf where the "format string" is basically a function
11:11:05 <Inglorion> you can even pass an actual function instead of a string
11:11:05 <kmc> Starfire, there is a version using Template Haskell that does
11:11:19 <Inglorion> and the type checker will give you errors if you give arguments of the wrong types
11:11:35 <Inglorion> however, the implementation uses object.magic, and thus bypasses the type system
11:11:41 <Starfire> I think F# has a statically checked printf, though IIRC they hack it by having a special case in the compiler for checking it.
11:11:50 <kmc> you can build a library of format-specifier-like combinators
11:11:59 <kmc> which would give you a statically typed printf in Haskell
11:12:06 <kmc> http://hackage.haskell.org/packages/archive/xformat/0.1/doc/html/Text-XFormat-Show.html does that i think
11:12:06 <Inglorion> Starfire, that would be the same way OCaml does it, then. not so surprising, given F# is basically OCaml for .NET
11:12:15 <danharaj__> C++1x is going to be able to implement statically checked printf with variadic templates.
11:12:58 <mauke> danharaj__: I doubt that
11:13:24 <Cale> danharaj__: The trouble is that the string can depend on various constructions that occur at runtime, even on user input.
11:13:56 <danharaj> Cale: yeah, well, for static strings at least. You would need a very strong type system to make a safe printf that gets its type argumets at run-time, no?
11:13:56 <Inglorion> really, though, while creating a language powerful enough to express statically typed printf is certainly interesting, i think it's much easier to provide a different mechanism for formatting numbers
11:14:25 <Cale> danharaj: yeah
11:14:36 <danharaj> You would need to do some sort of proving.
11:14:48 <Inglorion> a simple function taking a numeric type and a bunch of arguments for how many decimals you want and if you want leading zeroes and such would do, right?
11:14:49 <Cale> danharaj: It's not hard to get things right for static strings. That's been done using TH.
11:14:50 <kmc> right, you can do it in dependently-typed languages
11:15:01 <danharaj> Cale: Template GHC
11:15:03 <danharaj> ;p
11:15:28 <kmc> C++1x will be able to implement the same thing you can already implement in Haskell: printf using not a format string, but an expression whose static type contains all formatting information
11:15:34 <kmc> built using a combinator library or whatever
11:15:59 <kmc> or actually not all formatting information, just the type it expects
11:16:00 <mauke> so it will be useless
11:16:14 <monadic_kid> danharaj__: you get type safe arguments but you do not get type checking from a format strings at compile-time
11:17:26 <monadic_kid> there are no facilities in C++0x to manipulate strings at compile-time
11:17:46 <kmc> because strings are a terrible choice in the first place
11:17:48 <kmc> @quote stark
11:17:49 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11:18:19 <mauke> do you have a better idea?
11:18:21 <danharaj> kmc: translation?
11:18:27 <kmc> of?
11:18:34 <danharaj> I don't know what that quote means.
11:18:53 <kmc> that strings lose structure
11:19:16 <kmc> which has to be recovered by complicated things like parsing
11:19:16 <nostrand> why do i get this error: "parse error on input `import'" in this file? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25820#a25820
11:19:27 <kmc> if you make n systems talk via strings, they will all duplicate the process of parsing and serializing
11:19:44 <danharaj> ah
11:19:50 <kmc> nostrand, you need to turn on the ForeignFunctionInterface extension
11:19:55 <mauke> nostrand: {-# LANGUAGE ForeignFunctionInterface #-}
11:19:56 <kmc> {-# LANGUAGE ForeignFunctionInterface #-}
11:19:57 <Starfire> Strings do have the nice property of being easily internationalizable. Still, I guess you could do almost as well by exporting all format expressions from a single module, if necessary.
11:19:58 <kmc> at the top of yr file
11:20:00 <nostrand> kmc: aa, thanks =)
11:20:09 <kmc> Starfire, that's a good point
11:20:27 <monadic_kid> true or not it's useful to be able to analyze string literals. just so you can do things like have type checked printf at compile-time
11:20:56 <kmc> that would be one use case of metaprogramming, yes
11:21:13 <kmc> it's too bad that C++'s metalanguage is this bizarre unexpected ad-hoc thing, instead of a sane general-purpose language
11:21:43 <kmc> of course Lisp's metalanguage is Lisp and Haskell's metalanguage is Haskell
11:21:44 <Starfire> Could C++ itself be called a 'sane general-purpose language'? :)
11:21:46 <kmc> in common implementations
11:21:50 <kmc> Starfire, barely ;)
11:22:01 <monadic_kid> templates where never meant to be used for metaprogramming, it was pure accident.
11:22:12 <danharaj> Considering our major gui libraries are bindings of C++ libraries, we can't complain too much :p
11:22:38 <kmc> monadic_kid, yep, yet many C++ devotees think that metaprogramming == templates and that C++ has something no other language has
11:22:43 <kaol> GTK+ is C
11:22:52 <kmc> templates are useful *despite* their design not because of it
11:22:53 * hackagebot frame 0.1 - A simple web framework.  http://hackage.haskell.org/package/frame-0.1 (AdamDunkley)
11:23:15 <danharaj> kaol: my mistake, I am only familiar with wx.
11:23:21 <geheimdienst> i know qt is c++, but isn't wx also c?
11:23:26 <EvanR> danharaj: i can and will complain. a lot
11:23:45 <monadic_kid> in  ocaml/f# the compiler supports analyzing string literals at compile-time which generates a function type from a special  format type
11:23:58 <Starfire> Isn't Qt some kind of almost-C++? I think they have their own custom pre-processor which emits C++.
11:24:14 <danharaj> yeah, Qt is dragons.
11:24:19 <monadic_kid> Qt has extra preprocessor step, moc compiler
11:24:24 <kmc> right, it has the QT Meta-Object System
11:24:43 <kmc> not implemented with the glorious beloved C++ Templates of course
11:25:02 <monadic_kid> they extended C++ with signal/slots syntax and meta-object system
11:25:04 <kmc> because they can't do even basic introspection
11:25:09 <Inglorion> anyway, i wrote my function without needing any libraries. in case anybody is interested, http://haskell.pastebin.com/5VuJUBBh
11:25:27 <Starfire> I guess the library itself is still callable using a normal C++ calling convention.
11:25:38 <monadic_kid> well you can do compile-time introspection, that is what type traits are for
11:25:45 <mauke> Inglorion: nice abuse of 'do'
11:26:05 <Inglorion> wait, there is still do in there?
11:26:07 <EvanR> this parsec is beating me over the head
11:26:11 <monadic_kid> but you need compiler intrinsics to support some of those type traits.
11:26:18 <monadic_kid> like is_pod
11:26:20 <EvanR> my language is too muhc for it
11:26:27 <mauke> and yeah, this code is clearly superior to printf "%.2f"
11:26:46 <mauke> just look at all the typesafety
11:27:08 <danharaj> EvanR: are you just parsing to a bare AST?
11:27:18 <EvanR> attempting
11:27:25 <EvanR> but its left recursive
11:27:50 <danharaj> Which parts are left recursive?
11:27:51 <EvanR> and it doesnt seem to be easily representable in terms of operators for the expression parser
11:28:04 <EvanR> these two parts
11:28:08 <EvanR> e = e.id
11:28:13 <EvanR> e = e.id<-id\e
11:28:24 <Inglorion> better this way, mauke? http://haskell.pastebin.com/rtz60eCh
11:28:52 <nostrand> i must say that the Haskell community is damn good att giving support =)
11:29:05 <mauke> EvanR: what does that mean?
11:29:14 <danharaj> Nothing better to do in between writing journal articles and stroking neckbeards.
11:29:37 <nostrand> haha
11:29:50 <Inglorion> don't tell him that we generate the journal articles with the postmodernism generator!
11:29:55 * hackagebot frame-markdown 0.1 - A markdown to Frame GUI writer for Pandoc  http://hackage.haskell.org/package/frame-markdown-0.1 (AdamDunkley)
11:29:55 <EvanR> mauke: those are two rules for e
11:30:11 <freiksenet> is it possible to have "or" in pattern matching? for example to match 2 different subtypes of algebraic data type?
11:30:11 <EvanR> the left recursive ones
11:30:25 <aavogt> freiksenet: no
11:30:39 <mauke> EvanR: but what do they mean?
11:30:56 <aavogt> just give a name to your RHS, and bind the two patterns separately
11:31:38 <freiksenet> aavogt: well they are semantically different, but do same thing in this sense. I don't want to copy paste it 5 times
11:31:42 <dons> umm... did others notice this... http://www.reddit.com/r/programming/comments/c9oa4/wait_what_berp_an_implementation_of_python_3_that/
11:31:55 <dons> python 3 -> haskell compiler.
11:31:58 <EvanR> mauke: lookup and update
11:32:07 <Inglorion> nice, dons!
11:32:19 <mauke> EvanR: I have no idea what you're talking about
11:32:26 <Inglorion> i didn't even know there was python 3 yet
11:32:28 <freiksenet> aavogt: aah, now I see what you mean
11:32:33 <mauke> can you rephrase your problem in terms of a regex?
11:32:45 <danharaj> or bnf
11:32:47 <EvanR> i could explain it fully, would that help you help me parse this ;)
11:32:48 <EvanR> with parsec
11:34:09 <aavogt> freiksenet: there's a feature request for or-patterns with ghc
11:34:10 <EvanR> heres my bnf
11:34:12 <EvanR> http://codepad.org/SQ5hTmuV
11:34:56 * hackagebot snap-core 0.2.6 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.6 (GregoryCollins)
11:35:01 <EvanR> the symbols are e id members, everything else is literal
11:35:54 <danharaj> why can't you treat . <- and \ as expression operators and then parse the resulting AST?
11:35:57 * hackagebot snap-server 0.2.6 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.6 (GregoryCollins)
11:36:07 <EvanR> danharaj: so two stages
11:36:11 <danharaj> yeah
11:36:15 <EvanR> ok
11:36:30 <danharaj> or you could factor out the left recursion
11:36:35 <EvanR> i initially sort of thought of that, but thought, thats stupid, now i have have terms in . and <- that dont make sense together
11:36:48 <EvanR> i also factored out the left recursion, but wouldnt that produce a weird ass AST
11:37:08 <danharaj> I don't know, whenever I run into left recursion I do it in two stages because that is the easiest way for me to think about it.
11:37:09 <maxstahl> How's it goin', folks?
11:37:35 <EvanR> danharaj: will i not run into left recursion again in the second stage?
11:38:22 <freiksenet> aavogt: what is it's status?
11:38:35 <freiksenet> I could say I would love union types in general :D
11:38:39 <danharaj> EvanR: in the second stage you are just checking the AST to see if . <- and \ are being used in well formed expressinos.
11:38:42 <danharaj> expressions*
11:38:45 <freiksenet> not just or patterns :]
11:39:13 <danharaj> But my suggestion might be stupid and you should ask for second opinions :p
11:39:18 <EvanR> danharaj: i suppose i could add a third stage for lexical analysis. man, now i gotten learn to make a parser that operates on not strings
11:39:37 <mauke> e = e' tail; e' = id | [members] | let id = e in e | clone(e) | (e); tail = ( .id (<- id\e)? )*
11:39:51 <EvanR> right
11:40:47 <EvanR> is that going to produce a nice ast
11:41:25 <mauke> it's going to produce whatever ast you want
11:42:01 <EvanR> i didnt think of it like that, i used the method on wikipedia and got some weird non left recursive rules
11:42:06 <dons> cabal install berp
11:42:13 <ben_m> Greetings! What's the simplest way to time a function? :s
11:42:35 <EvanR> mauke: e' can also be empty right
11:42:39 <ben_m> Without compiling and using the shell's `time`
11:42:44 <dons> http://www.haskell.org/haskellwiki/Timing_computations
11:42:45 <EvanR> erm
11:42:47 <aavogt> freiksenet: I doubt either of those are going to happen
11:43:24 <dons> ben_m: for full featured, use the criterion library
11:43:30 <dons> which gives statistically robust timings
11:43:55 <mauke> ben_m: why bother timing anything if you're not going to compile the function?
11:44:10 <ben_m> comparing problem euler solutions with other people :s
11:44:26 <dons> yeah, if you're not compiling it with -O2 , the overhead from interpretation makes it meaningless :)
11:45:36 <freiksenet> aavogt: oh well.
11:45:43 <freiksenet> can't have everything
11:46:49 <Inglorion> hah! isComputerOn returns False!
11:47:09 <portnov> have anyone successfully compiled that "berp"?
11:48:27 <luite> not me, it complaints that it requires integer -any, and that there is not version that satisfies -any
11:48:43 <luite> no version
11:49:16 <monochrom> the computer is dreaming
11:50:08 * EvanR steals that for the title of a song
11:50:50 <dons> integer is implicit. that shouldnn't be an explicit dependency
11:51:08 <aavogt> or it should be   integer-gmp
11:51:43 <gwern> > 124 + 195
11:51:44 <lambdabot>   319
11:51:49 <dons> well, its provided by base, so it shouldn't be a dep, imo.
11:51:56 * Inglorion mods lambdabot +1 Insightful
11:52:14 * gwern downmods lambdabot: -1 tautologous
11:52:27 <dons> fork berp on github and patch it
11:52:31 <dons> then let bernie pull the patches in
11:52:32 <jre2> does ghci-haskeline really not work with 6.12?
11:52:49 <dons> i thought i'd see Go-lang forked to run on ghc before python
11:52:55 <aavogt> looks like it isn't going to build with ghc-6.12 due to containers-0.2 being required by some of it's deps... but everything here is build with containers-0.3
11:53:10 <portnov> @src iterate
11:53:10 <lambdabot> iterate f x =  x : iterate f (f x)
11:53:10 <aavogt> jre2: no it works
11:53:16 <dons> yeah, that's a 6.10.x-ism
11:53:23 <dons> i bet it doesn't rely on the arrays or containers api.
11:53:26 <dons> i mailed bernie about that.
11:53:35 <aavogt> or parts that changed
11:53:50 <Saizan> jre2: the default ghci uses haskeline in 6.12
11:54:02 <jre2> Saizan: oh, good to know
12:05:55 <dons> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25823#a25823
12:06:01 <dons> language.python patch to build under 6.12
12:07:36 <dons> parser takes a long time to compile.
12:08:45 <dcolish> ooh, static analyzer of python to follow?
12:08:54 <dons> wow. ran out of memory compiling Language.Python
12:11:07 * hackagebot YACPong 0.1 - Yet Another Pong Clone using SDL.  http://hackage.haskell.org/package/YACPong-0.1 (KorcanHussein)
12:11:25 <EvanR> thats not what that spells
12:11:42 <monadic_kid> is it really a problem?
12:11:49 <EvanR> yes
12:12:03 <monadic_kid> how so, why does it matter
12:12:12 <EvanR> it just does so there
12:12:16 <monadic_kid> ...
12:14:49 <chrisdone> monadic_kid: is it your program?
12:15:22 <monadic_kid> yeah
12:15:47 <EvanR> i take it back
12:21:10 <dons> looks like you have to use 6.10.x currently with language-python.
12:22:11 <alexsuraci> berp compiled and installed fine for me fwiw
12:22:24 <alexsuraci> ghc 6.10.4
12:22:57 <portnov> too old :/ ;)
12:23:00 <alexsuraci> (oh, just re-read that. ;)
12:23:12 <alexsuraci> yeah well, i have berp and you don't, so there.
12:24:06 <kmc> maybe this will stop clueless people from calling Python "an interpreted language"
12:24:09 <kmc> probably not, though
12:24:22 <dons> alexsuraci: cool
12:24:37 <dons> read the github notes on the compilation scheme used
12:24:46 <dons> should be lots of fun haskell optimization work here
12:26:26 <alexsuraci> love that the compiled code is pretty readable. pretty simple.
12:26:58 <jre2> when did berp happen?
12:27:29 <alexsuraci> it's fresh on hackage, not sure how long that repo's been around on github
12:27:42 <alexsuraci> first commit was march 04
12:28:27 <gwern> 04? long-term project
12:28:37 <gwern> surprised it never came up in the occasional python-haskell link discussions
12:29:42 <jre2> gwern: march 04 2010 it looks like
12:29:53 <gwern> -_-
12:29:55 <gwern> stupid dates
12:32:04 <dons> language.python predates it
12:32:10 <dons> which does most of the hard work :)
12:32:35 <dons> i think this could have a fair amount of potential. bernie knows his compilers
12:32:38 <ezyang> i.e. parsing?
12:32:45 * dons images e.g. rewrite rules for the python AST
12:32:53 <dons> allowing optimizations the python compiler can't do
12:33:18 <gwern> scrapping the GIL
12:33:43 <jre2> what package provides integer?
12:33:44 <dons> well, ghc rts makes a better vm than the python one. :)
12:33:45 <kmc> yeah
12:33:49 <dons> jre2: just remove it. base does.
12:33:53 <kmc> CPython's RTS is a joke compared to GHC's
12:34:09 <dons> and you get a parallel, generational GC for free
12:34:19 <gwern> python was... ref-counting?
12:34:37 <dons> essentially, you can think of this as Python ported to the GHC runtime
12:34:42 <dons> a la JVM or .NET python
12:35:20 <EvanR> i remember in the old days the python website boasted that they use python in space, space shuttle, ISS. that doesnt sound very safe!
12:35:21 <ezyang> jython is pretty old hat, iirc?
12:35:42 <dons> well, i'm sure it wasn't a critical control system
12:36:42 <gwern> no more than haskell is usually a critical control system :)
12:36:46 <MrBlueSky> curios question. How can fmap take a binary function if the type says it takes a function that takes only one input (a -> b)
12:36:50 <MrBlueSky> curious*
12:37:07 <ezyang> MrBlueSky: Every function a -> b -> c is actually a -> (b -> c)
12:37:08 <Starfire> MrBlueSky: All functions match the type a -> b
12:37:44 <MrBlueSky> oh right, currying, that explains it. Thankya
12:37:47 <dons> gwern: right. neither any python or haskell impl. has been certified for usual aerospace use.
12:37:53 <dons> some haskell DSLs are ok though.
12:38:07 <dons> both are allowed at NASA as dev languages, though, fwiw
12:39:31 <gwern> @hoogle a -> b
12:39:31 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:39:31 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:39:31 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
12:39:55 <gwern> (look at them all!)
12:41:16 <dons> gwern: stop trolling.
12:42:09 <gwern> merely illustrating their plenitude. although I'm a little disturbed UnsafeCoerce is even in the hoogle database
12:42:13 <dons> the existence of such functions isn't a barrier to use. its whether you use them in a manner that cannot be shown to be safe. after all, C is ubiquitous in this space, and has an unsafeCoerce on every line.
12:43:32 <dons> no one is arguing that the entire haskell library set is a trusted code base that cannot go wrong, which is what is implied by your pointing at unsafeCoerce. that's just not how it works.
12:44:03 <gwern> ...the hoogle was for MrBlueSky
12:44:06 <dons> indeed, taking some isabelle code and generating haskell from it, full of unsafeCoerce might be a stronger assurance argument
12:44:32 <dons> oh, i misunderstood. seemed like a perfect response to "no more than haskell is usually a critical control system"
12:45:45 <interferon> is maybeRead available in any of the standard libraries?
12:46:01 <dons> nope. but it is easy to write
12:46:10 <jre2> dons: could you not compile lang.python due to memory blow up or some other reason?
12:47:00 <gwern> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
12:47:02 <gwern> huh
12:47:24 <gwern> not where one would expect that to be
12:48:48 <dons> jre2: http://hackage.haskell.org/trac/ghc/ticket/3972
12:49:08 <danharaj> should Read . Show equal identity (for non-bottom values)?
12:49:21 <dons> yeah
12:49:26 <ezyang> yup
12:49:30 <dv-> you mean read . show
12:49:38 <Null-A> can I use currying with infix operator? like: a `foo x` b ?
12:49:41 <danharaj> pseudocode
12:49:48 <Null-A> I don't know the syntax if its possible
12:49:49 <danharaj> So that means show should be injective
12:50:03 <ezyang> I might even go as far to say that I should be able to parse the output of show in Haskell
12:50:52 <gwern> danharaj: show . read = id is one of the rules that's expected to be true even if not enforced, and I think it's false occasionally (with floats?)
12:51:21 <EvanR> it would work if you print floats out in hex
12:51:38 <danharaj> gwern: well, when read makes sense
12:51:45 <gwern> danharaj: and some instances break it deliberaltely
12:51:48 <gwern> > print "foo"
12:51:49 <lambdabot>   <IO ()>
12:51:50 <EvanR> printf "%a" or something
12:54:11 <danharaj> Conceptually I guess, an instance that has read . show == id supports serialization of the type to string.
12:57:21 <gwern> it's kind of interesting that lazy evaluation means that a Show instance for IO can neuter IO expressions
12:57:52 <jre2> bah...it grew to 8gb for me before the blind orangutan shotgunned it
12:58:08 <pastorn> @src reverse
12:58:09 <lambdabot> reverse = foldl (flip (:)) []
12:58:17 <pastorn> ugh...
12:59:11 <gwern> > head $ reverse [undefined, undefined, undefined, 1]
12:59:11 <lambdabot>   1
13:00:27 <mauke> Null-A: no, `` takes a single identifier
13:00:48 <Null-A> mauke: I managed something stupid for now: a `f` b $ x
13:01:18 <mauke> > ((+) `id` 2) 3
13:01:19 <lambdabot>   5
13:01:23 <Null-A> yah
13:01:32 <Null-A> similar
13:01:40 <danharaj> :t flip (:)
13:01:41 <lambdabot> forall a. [a] -> a -> [a]
13:01:46 <danharaj> :t foldl
13:01:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:02:17 <monochrom> > [0,1] `flip map` id
13:02:18 <lambdabot>   <no location info>: parse error on input `map'
13:02:25 <interferon> :t id
13:02:26 <lambdabot> forall a. a -> a
13:02:46 <interferon> mauke: how does that ((+) `id` 2) 3) example work?
13:02:54 <interferon> doesn't id only take one argument?
13:03:10 <ezyang> interferon: if b is a function, not necessarily :-)
13:03:12 <mauke> interferon: f x y is ((f x) y)
13:03:17 <interferon> ahhh i see
13:03:19 <mauke> every function takes exactly one argument
13:03:28 <monochrom> ((+) `id` 2) 3) = id (+) 2 3 = (+) 2 3
13:03:46 <mauke> see also the introduction at http://okmij.org/ftp/Haskell/polyvariadic.html
13:04:18 <danharaj> what is the relationship, for f :: a -> b -> c, of fmap . uncurry f and fmap f
13:05:05 <monochrom> no relationship
13:06:13 <earthy> daaang. just adding a strict StateT over Put makes things go totally haywire
13:06:26 <earthy> as in... eat mem for breakfast
13:11:25 <jre2> how easy is it to deal with having multiple versions of ghc installed?
13:18:26 <Null-A> What binary serialization library do you guys recommend?
13:18:55 <EvanR> mauke: you are a genius
13:19:16 <mauke> I didn't do it!
13:19:38 <Polarina> Null-A, Data.Binary.
13:19:57 <Null-A> Polarina: cool, thanks
13:20:01 <EvanR> OK.
13:20:18 <Cale> Hey, what about cereal?
13:20:23 <EvanR> it just started storming here.. and now its hailing. the window in front of my computer desk is being bombarded with hail
13:20:35 <Polarina> Cale, only in the mornings.
13:21:36 <Cale> cereal ought to be better for inputs that are finite, where you want to use strict, rather than lazy bytestrings
13:21:54 <Polarina> Cale, what about Data.Binary.Strict?
13:21:58 <Cale> It has easier to handle errors
13:22:03 <Cale> (cereal does)
13:24:58 <Cale> The last time I looked at Data.Binary.Strict, it was just a strictified version of Data.Binary, but it looks like there's some new stuff in there now.
13:25:28 <Cale> (The incremental parsing looks interesting)
13:29:01 <earthy> Data.Binary is great. however, any monad transformer over PutM makes its performance break badly
13:32:19 <Polarina> Why would anyone use any form of a transformer over a PutM?
13:35:24 <Rotaerk_> i just discovered that "ejaculate" has another meaning
13:35:32 <Rotaerk_> so you can innocently say "Wow! I just ejaculated!"
13:35:44 <mauke> yeah, reading Agatha Christie can do that
13:36:00 <Rotaerk_> heh
13:37:40 <monochrom> what is the other meaning of ejaculate?
13:37:59 <Rotaerk> "blurt out: utter impulsively"
13:37:59 <ezyang> "to exclaim"
13:38:06 <Rotaerk> it's also synonymous with "interjection"
13:38:14 <Rotaerk> e.g. "wow!" "oh!" etc
13:38:15 <monochrom> ah, yes. :)
13:38:48 <monochrom> there is even an example of "to ejaculate a prayer" XD
13:38:50 <EvanR> you guys are ejaculating all over the place
13:38:52 <Rotaerk> haha
13:39:04 <monochrom> Orgazmo ejaculated a prayer!
13:39:28 <earthy> polarine: because one might want to generate information from the putm
13:39:39 <earthy> e.g.: store offsets to particular elements of a structure
13:43:27 <EvanR> > (flip (+)) 4 5
13:43:28 <lambdabot>   9
13:43:41 <EvanR> > 4 `(flip (+))` 5
13:43:42 <lambdabot>   <no location info>: parse error on input `('
13:43:54 <sinelaw> hey
13:44:01 <ezyang> yo
13:44:04 <sinelaw> 'sup
13:44:13 <kmc> so why are transformers the death of PutM?
13:44:26 <mauke> PutM is a decepticon
13:46:13 <earthy> kmc: I suspect it is because they completely kill any fusion
13:46:31 <earthy> at least, that's what the behaviour suggests
13:47:10 <sinelaw> are monads really neccesary?
13:47:28 <sinelaw> i mean i haven't done too much programming in haskell yet
13:47:34 <sinelaw> but never really needed them
13:47:35 <earthy> sinelaw: no. for a more elaborate answer: look at Clean.
13:47:45 <sinelaw> even within haskell
13:47:50 <sinelaw> except for the occasional IO
13:47:55 <dons> earthy: there's no fusion in Data.Binary
13:47:56 <sinelaw> which can be nicely buried
13:48:17 <EvanR> non IO monads can be useful, checkout Monad.Random
13:48:26 <dons> you using lazy or strict StateT?
13:48:32 <earthy> strict StateT
13:48:44 <dons> the question is more about what can ghc do to the code. check the core with and without StateT.
13:48:54 <kmc> monads aren't necessary even for IO.  that is, nobody had to notice that IO is an example of this more general thing
13:48:55 <dons> mtl for example, pays no attention to inlining
13:48:57 <earthy> worlds of difference
13:48:58 <sinelaw> monads are about sequential-style programming, no?
13:49:03 <earthy> *ah*!
13:49:04 <dons> so you end up with indirect calls in every bind
13:49:11 <dons> mtl's fault. not binary's.
13:49:15 <earthy> that might cause it.
13:49:15 <sinelaw> i know the monad interface, etc...
13:49:22 <earthy> oh, yeah, I stated that mtl killed binary. :)
13:49:24 <aristid> sinelaw: you can also use them to build lists and other stuff
13:49:31 <sinelaw> just trying to figure when are monads really "the answer" for what you want
13:49:36 <earthy> no fault of binary
13:49:37 <kmc> they're all sequential in some sense, because (>>=) and (>>) impose an ordering
13:49:44 <kmc> but they don't necessarily mean sequential evaluation or execution
13:49:46 <sinelaw> kmc that's what i meant
13:49:46 <dons> earthy: inlining the instance definition of StateT you're using and adding INLINE to the bind can fix things dramatically
13:49:57 <sinelaw> i meant constructing ordered structures
13:49:57 <dons> i.e. write your own StateT that's specialized to your state type, with inlining help
13:50:05 <aristid> > do x <- [1,2,3]; y <- [1,2]; return (x,y)
13:50:06 <lambdabot>   [(1,1),(1,2),(2,1),(2,2),(3,1),(3,2)]
13:50:16 <earthy> however, it makes it hard to do some things, as binary has no facility for getting extra info out of the encoding process.
13:50:21 <aristid> sinelaw: see? that's not precisely sequential programming :)
13:50:27 <earthy> e.g. offsets... ;)
13:50:29 <dons> well, very little ability yeah.
13:50:31 <danharaj> They are sequential in the sense that you can combine two monadic values in a way such that one depends on the other to create one monadic value using >>=
13:50:33 <sinelaw> aristid i know, i was trying to say that
13:50:48 <sinelaw> i'm not a total newbie
13:50:50 <earthy> dons: will try that first thing in the morning
13:50:52 <danharaj> >>= is dependency
13:50:59 <earthy> but yeah, that might be the exact reason.
13:51:12 <sinelaw> but every time i come here, there's a discussion on forM or some other monadic thingy
13:51:17 <sinelaw> almost nothing else
13:51:28 <earthy> (when I was doing my own CPS-style transform over PutM I used waaaay way less memory than with StateT)
13:51:46 <dons> yeah, that's a good idea
13:51:50 <sinelaw> so i'm trying to see why are sequential structures so fundamental
13:51:54 <dons> just look at the core for a small example fragment
13:51:56 <sinelaw> what am i missing
13:51:57 <earthy> (still blew up things though, so I went to StateT to fix my fundamental types)
13:51:59 <dons> and make sure >>= is entirely inlined
13:52:05 * earthy nods
13:52:08 <dons> there should be no calls back to e.g. C.M.State.>>=
13:52:14 <dons> and no dictionaries.
13:52:17 <earthy> yah, doing that for everything that I write.
13:52:21 <sinelaw> is it all about performance hacks?
13:52:29 <dons> i think an mtl aimed at performance would be useful.
13:52:34 <sinelaw> for things we could write in a more declarative functional style?
13:52:37 <dons> (# s , a #) state types  :)
13:52:40 <earthy> dons: very.
13:53:04 <dons> we know how to make this stuff fast (CPS transform, inlining, specialization on state types) so its a matter of doing that once for everyone
13:53:17 * earthy nods
13:53:30 <earthy> might get 'round to that if I can get *this* to work tomorrow morning
13:54:21 <monadic_kid> dons: how about transformers package, do they have inline pragmas?
13:55:06 <Zao> <more than meets the eye>
13:56:35 <dons> i don't think any of them do
13:56:44 <monadic_kid> nope i just checked
13:56:46 <dons> monadLib does ok, but not the derive_* stuff
13:57:13 <dons> basically, write each instance in CPS style, inline >>= , write a custom >> for each, with inline. and show examples of how to specialize for each state/reader/writer type
13:58:43 <earthy> and control.monad.ran doesn't help, presumably
14:01:55 <EvanR> haha. this parsec parser has such great errors by default, i can just type what it says and eventually the input will parse ;)
14:12:07 <Null-A> EvanR: such a great library
14:31:56 <shapr> OK, what's up with berp? Where do I get the integer package?
14:33:02 <interferon> occasionally cabal upgrade recommends upgrading some "core" package (like syb, parsec, time) that you really can't upgrade safely.  are there any plans to have cabal upgrade flag these kinds of packages as being "core"?
14:33:29 <dcoutts> interferon: the first part of the plan is to kill off cabal upgrade entirely
14:33:52 <interferon> oh?
14:34:10 <dcoutts> the second part is to think about how we might do a similar feature that was safer, e.g. by pinning core packages
14:34:13 <shapr> Is integer in 6.12.2 but not in 6.12.1 or something?
14:34:42 <dcoutts> interferon: though it's not obvious what counts as core
14:35:07 <dcoutts> interferon: your examples of syb, parsec and time are all ones I would not define strictly as core packages
14:38:07 <dcoutts> interferon: and we'd have to think carefully about what behaviour we really want, what if something needs a later version of some potentially upgradable but "core" package, do we fail? How do we identify this situation and give a good explanation in an error message. How do people override this?
14:38:37 <dons> shapr: something weird. i'm not sure it was supposed to be exposed
14:38:55 <dons> its not in 6.12.2
14:39:02 <dons> integer-gmp-0.2.0.0 is
14:39:04 <shapr> Can anyone else build berp?
14:39:09 <dcoutts> there's integer-gmp in 6.12.1 and presumably in 6.12.2
14:39:10 <dons> on 6.10.x people can.
14:39:17 <shapr> weird
14:39:32 <dons> i sent bernie notes
14:39:35 <dcoutts> question is why berp depend on integer
14:39:50 <dcoutts> since it's a very very low level package (lower than base)
14:40:00 <shapr> My friend asks, when will there be a Haskell compiler written in Python? I just gave him dirty looks.
14:40:26 <dons> The Python guys don't like writing compilers, I guess :)
14:40:42 <dons> dcoutts: my guess is that it is an error
14:40:49 <dons> fallback position: trying to avoid GMP dependency
14:41:06 <dcoutts> it can't avoid it that easily :-)
14:41:07 <shapr> I wonder if I just remove the integer dep if it'll build...
14:41:10 * shapr tries
14:41:11 <pikhq> Too used to writing interpreters for languages that need garbage collection, without garbage collection.
14:41:13 <dons> shapr: i'd say so.
14:41:15 <pikhq> :)
14:41:42 <EvanR> @src many
14:41:43 <lambdabot> Source not found. Where did you learn to type?
14:41:54 <shapr> @src many1
14:41:54 <lambdabot> Source not found. Maybe you made a typo?
14:41:59 <shapr> EvanR: it's in parsec
14:42:13 <EvanR> i cant find 'many'
14:42:16 <EvanR> is it equal to many1
14:42:20 <dcoutts> doh
14:42:25 <jre2> shapr: do you already have language.python somehow?
14:42:34 <shapr> jre2: No? Do I need it?
14:42:43 <dcoutts> shapr, dons: ./src/Berp/Base/Hash.hs imports GHC.Integer.hashInteger
14:42:53 <shapr> EvanR: I believe many means "match between zero and lots"
14:43:04 <EvanR> ah its in Prim
14:43:10 <jre2> shapr: berp needs it and it won't compile on 6.12
14:43:21 <shapr> jre2: Oh.
14:43:38 <EvanR> i keep getting the error "many applied to a parser that accepts empty string" but im not using many anywhere
14:44:35 <dcoutts> shapr, dons: even worse, GHC.Integer.hashInteger is not a hash function! it's an internal accessor that could be used in a hash function
14:44:41 <dons> dcoutts: odd
14:44:51 <dcoutts> but berp is using it as a hash function
14:45:06 <dcoutts> unfortunately, it's id for small integers
14:45:07 <shapr> Well, we have our first feature request...
14:45:08 <dons> well i'm sure we can help bernie . BERnie's Python == berp :)
14:45:22 <shapr> bjpop writes cool code!
14:45:26 <cocon> is the FFI "wrapper" feature somewhere documented in the manual? what does it do?
14:45:34 <dons> LambdaPie would be better imo
14:45:36 <dons> LambdaPy
14:45:53 <dons> PyPy , HaskPy, LamPy
14:46:11 <jre2> dons: one might think lambda py is a fix for python's horrible lambda syntax
14:46:18 <dons> LambPy
14:46:33 <dons> UnambPy hehe
14:52:19 <dcoutts> dons: http://hackage.haskell.org/trac/ghc/ticket/4108
14:52:56 <shapr> dcoutts++
14:53:08 <dcoutts> dons: are you emailing Bernie about this or is someone else doing that?
14:54:16 <glguy> Does it really matter if the hash function doesn't use *all* of the data?
14:54:33 <dcoutts> glguy: no, but it matters that it does not do any hashing :-)
14:54:34 <dons> you should
14:54:38 <dons> i mailed him about some other issues
14:54:48 <dcoutts> dons: ok, I'll email him about this one
14:55:14 <glguy> What's the point of "hashing" an Int?
14:55:18 <glguy> if the output type is an Int
14:55:27 <allbery_b> spreading out the values?
14:55:52 <dons> possibly he's got some kind of open addressing scheme
14:56:05 <dons> and needs to ensure things map to the range properly.
14:56:21 <glguy> if someone has specific distribution needs he should write this own function to enforce that around any opaque hash function
14:56:38 <glguy> seems like hashInteger does exactly what you would need from a hash function
14:56:38 <dcoutts> if he really wants to use this scheme then that's fine, but he should use `mod` fromIntegral (maxBound :: Int)
14:56:51 <dcoutts> and not depend on this very low level package (which has changed name anyway)
14:58:19 <dons> we should help bernie out. the code's on github
14:58:26 <shapr> Yeah!
14:59:32 <jre2> being able to compile and test changes would help that
14:59:42 <dons> we've had a lot of good news this month for haskell. http://www.reddit.com/r/haskell/top/?t=month
15:00:26 <dons> llvm, gtk, intel libraries, snap, python/haskell, jobs, robots
15:00:37 <dons> video games. freaking video games
15:00:47 <dons> 7 gsoc students starting
15:00:56 <dons> parallel arrrays
15:01:03 * dons boings
15:01:12 <shapr> yay!
15:01:32 <gcollins> shapr always applauds a boing
15:01:50 <shapr> Of course!
15:06:57 <soupdragon> anyone got some haskell jokes/
15:06:58 <soupdragon> ?
15:07:13 <aavogt> there's @quote for your pleasure
15:07:21 <soupdragon> why did the haskeller cross the road?  Because he was needed on the other side
15:07:52 <soupdragon> Who's there? *Knock knock* lazy evaluation
15:08:07 <dcoutts> soupdragon: I'd change that to "demanded"
15:08:22 <aristid> @quote pleasure
15:08:23 <lambdabot> No quotes match. Wrong!  You cheating scum!
15:08:31 <shapr> @quote me
15:08:31 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
15:08:33 <aristid> lambdabot: no, YOU cheating scum
15:08:39 <ezyang> soupdragon: "Who's there? *Thunk thunk*"
15:08:40 <shapr> Hm, I think I introduced that bug long years ago.
15:08:46 <EvanR> the bot just crashed
15:08:47 <shapr> and never got around to fixing it.
15:09:02 <shapr> @quote
15:09:02 <lambdabot> jfoutz says: There are good abstractions out there waiting to be found. Just because the specification we have now is bad/good/whatever, that dosn't mean there aren't better abstractions just
15:09:03 <lambdabot> waiting to be found.
15:11:04 <shapr> Has anyone gotten language-python to build on 6.12?
15:11:18 <aavogt> no
15:11:33 <aavogt> the dependencies are too tight
15:11:41 * shapr relaxes his dependencies.
15:12:22 * jre2 is installing a vm to use with ghc 6.10 to try it out
15:12:55 <dons> shapr: you'll run into http://hackage.haskell.org/trac/ghc/ticket/3972
15:13:32 <shapr> I've got 4gb and a swapfile...
15:13:35 <shapr> and I'm on vacation.
15:14:12 <dons> she canna' take no more!
15:15:08 <EvanR> gah this whitespace parsing is killing me
15:15:13 <jre2> shapr: 8gb here and it got oom killed
15:15:21 <dons> dcoutts: igloo just closed your bug report. that'll learn you.
15:15:26 <chrisdone> EvanR: somebody say whitespace parsing?
15:15:30 <dcoutts> dons: heh
15:15:33 <dons> try compiling with ghc-options: -Onot
15:16:08 <EvanR> chrisdone: yes, trying to expand my parser so it ignores whitespace and newlines... more
15:16:29 <aavogt> I think there's a similar ghc performance issue with that package that uses highlighting from that kate editor
15:16:46 <chrisdone> EvanR: ah right
15:17:15 <dcoutts> dons: I admit I'd never thought of id being a useful hash function, but I don't work much with hashes so I defer to glguy
15:17:36 <aavogt> EvanR: just be consistent about your smaller parsers eating whitspace following what they are meant for
15:17:53 <dons> still, bjpop shouldn't be using it directly
15:18:12 <aavogt> then stick a parser to eat whitespace before your chain of smaller parsers... and it will all work out :)
15:18:21 <Igloo> Yeah, importing GHC.* directly is generally a bad idea anyway
15:18:30 <dcoutts> dons: I think the email I sent to bjpop is still valid, even if I'm wrong about hashInteger
15:18:37 * glguy isn't defending hashInteger's type, just its implementation :)
15:19:51 <chrisdone> dons: i updated tryhaskell with some more bits. i moved over to italy for a haskell web programming jobbie! finally settled into my apartment with internet access. the work hours are a lot more reasonable than my old job so i have more hacking time. yay!
15:20:32 <astrojp> This is still one of the better ways [for beginners] to get Haskell on 9.10, right? http://davidsiegel.org/haskell-platform-in-karmic-koala/
15:21:25 * dcoutts thought hash functions were things like Data.HashTable.hashInt which does some shifting and multiplication with magic numbers
15:21:26 <chrisdone> dons: i see haskell.org didn't get redesigned after that big long mailling list thread. after seeing Snap's web site i'm thinking maybe whoever designed that could do haskell's new site, if they wanted, because that home page is just brilliant. otherwise it's time we sorted something out instead of chatting about it
15:21:56 <dons> chrisdone: very cool.
15:22:06 <gcollins> chrisdone: some of the sketches i saw of prototypes for haskell.org looked awesome
15:22:11 <chrisdone> could we steal snap's logo?
15:22:13 <dcoutts> thing is, haskell.org has a lot more info to organise than snap
15:22:20 <gcollins> yes
15:24:01 <chrisdone> dcoutts: well, what we can do is merely upgrade the wiki theme. i don't underestimate the amount of information packed into haskell.org
15:24:30 <jlouis> gcollins: snap question... can I embed it inside combinatorrent?
15:24:44 <gcollins> um
15:24:53 <chrisdone> gcollins: ahh! sorry; i didn't realise you were involved in Snap. did you do the design?
15:25:03 <gcollins> to serve http pages? yes it should be possible
15:25:09 <jlouis> gcollins: exactly
15:25:11 <Axman6> jlouis: maybe the other way around... well at least that's how i'd see it
15:25:23 <gcollins> chrisdone: i did a little bit of it but james sanders is primarily responsible
15:25:25 <jlouis> Axman6: I think any way might do
15:25:43 <Axman6> sounds like a great idea though :D
15:25:45 <gcollins> jlouis: snap spawns an http service thread
15:25:55 <jlouis> gcollins: oh, then it is easy
15:26:08 <jlouis> gcollins: it does use libev however, right?
15:26:09 <gcollins> so you can use it as a library by running 'forkIO $ httpServe ....'
15:26:17 <gcollins> optionally, yes
15:26:21 <jlouis> ah, ok
15:26:34 <gcollins> you can bring down the server later by killing its controlling thread.
15:26:35 <jlouis> it is the obvious way to add an UI
15:26:45 <gcollins> not necessarily
15:26:51 <gcollins> it depends
15:27:15 <jlouis> I'd much rather go with something a browser understand these days than gtk/qt/etc
15:27:38 <gwern> chrisdone: the wiki in general needs an upgrade
15:28:11 <ezyang> dons: Hey, random question; why does Galois show up in Google as "Galois Connections Inc." ?
15:28:16 <gwern> the mediawiki instance last I checked was pretty old
15:28:28 <glguy> previous name
15:28:33 <ddarius> Haskell: We implement your languages better than you implement your languages.
15:28:40 <gwern> (one reason why our syntax highlighting is occasionally erroneous)
15:28:46 <alpounet> ddarius, haha
15:28:51 <chrisdone> yes, it's very old. but i personally am only concerned with the look right now
15:28:56 <gwern> ddarius: 'Haskell: anything you can do we can do better'
15:29:08 <dancor> more headily anyway
15:29:08 <ezyang> "No you can't."
15:29:24 <chrisdone> @faq Can we do it better?
15:29:24 <lambdabot> The answer is: Yes! Haskell can do that.
15:29:40 <jlouis> "Are you also afraid of the multicore? Don't be, Haskell saves!"
15:29:54 <gwern> ...the second hit for trying to find those lyrics is a hit on portal.acm.org
15:29:55 <gwern> what
15:30:47 <gwern> http://portal.acm.org/citation.cfm?id=15040 <-- doesn't even explain what it's about
15:32:14 <soupdragon> Have youo heard the good news! It's easy to program on multiple cores, all you need to do is accept monads as your savior
15:32:23 <danderson> dcoutts: out of curiosity, which editor do you use to work on c2hs?
15:32:36 <jlouis> soupdragon: hah, you don't even need monads for that!
15:32:40 <dcoutts> danderson: I generally use a combination of vim and nedit
15:32:49 <gwern> we are sinners in the hands of an angry type-checker
15:32:53 <soupdragon> :D
15:33:09 <danderson> After a massive yak shaving operation to get emacs to understand the vim modelines in the c2hs source code, I've realized that the tabbing mode used in the source doesn't match the modeline setting
15:33:26 <chrisdone> haha
15:33:56 <danderson> (the modeline says that any 8-space expanse should be collapsed into a tab, yet I see only spaces in the source)
15:35:13 <danderson> dcoutts: so, unless somehow both emacs and curl are munging the whitespace, I guess my first patch to c2hs will be to tweak the modeline to match reality :)
15:35:37 <dcoutts> danderson: lets kill off the modeline settings then
15:35:45 <dcoutts> danderson: there should be no tabs anyway
15:35:49 <danderson> hmm.
15:35:54 <danderson> In fact, I believe I may be cursed
15:35:56 <ezyang> I've decided in-file modeline settings are a bad idea
15:36:04 <danderson> I started all this based on a modeline in a single file
15:36:10 <danderson> turns out it's the only modeline in the whole source tree
15:36:20 <gwern> d'oh
15:36:20 <dcoutts> ok let's kill it
15:37:02 <danderson> dcoutts: want to do it, since it's such a lightweight patch? src/C2HS/Gen/Bind.hs, line 2 needs to go
15:37:09 <chrisdone> danderson: just to check, your emacs isn't auto-converting the tabs to spaces, is it?
15:37:13 <ddarius> gwern: http://iris.usc.edu/Outlines/papers/1980/price-cvgip-86.pdf
15:37:25 <danderson> chrisdone: I checked with curl and various other editors as well, all show only spaces
15:37:31 <chrisdone> ah, ok
15:37:55 <danderson> but yes, if I hadn't developed my little bit of elisp to parse the vim modeline, my emacs automatically destroys all tabs on save
15:41:44 <dcoutts> danderson: done, thanks
15:42:06 <danderson> cheers
15:57:38 <dcoutts> gcollins: do you think you'll be able to ditch the libev backend when the epoll stuff goes into ghc?
15:57:44 <dcoutts> in snap-server I mean
16:03:03 <gcollins> dcoutts: yeah
16:03:20 <dcoutts> gcollins: good to hear
16:03:23 <EvanR> gah. what is a parser that skips zero or more whitespace newlines and tabs
16:03:54 <gcollins> dcoutts: once native haskell stuff is epoll()-backed behind the scenes the rationale evaporates
16:03:54 <danharaj> Parsec comes with a facility for creating lexeme parsers.
16:04:07 <EvanR> ah. ill look at that module
16:04:36 <dcoutts> gcollins: good, I'm hopeful we can avoid libev etc in general and just have the normal thing perform well
16:04:44 <gcollins> dcoutts: and it'd be a good thing too, the libev stuff is hairy
16:04:52 <dcoutts> I can believe it
16:05:12 <gcollins> been hacking at it nonstop for 2 weeks and it's still acting strangely sometimes
16:05:25 <gcollins> of course turning on debug output kills the race condition :)
16:05:31 <soupdragon> haha
16:05:38 <dcoutts> gcollins: I'm slightly nervous about all the use of ByteString for short strings in snap-*
16:05:50 <dcoutts> ByteString is not fast for short strings
16:05:50 <gcollins> why?
16:06:01 <gcollins> string isn't really either...?
16:06:07 <dcoutts> uses far too much memory and puts pressure on the GC
16:06:18 <dcoutts> since it uses pinned heap objects
16:07:07 <gcollins> i wonder how many of those short strings end up being windows into larger buffer chunks
16:07:21 <gcollins> it would depend on how attoparsec is implemented i guess
16:07:36 <dcoutts> presumably attoparsec is taking slices
16:07:41 <dcoutts> which mean you get some sharing
16:07:55 <gcollins> if you cross a buffer boundary you'd have to copy
16:08:15 <dcoutts> if you share you get only 5 words overhead rather than 7
16:08:57 <dcoutts> of course [Char] is bad too, at 3 words per character
16:09:09 <gcollins> machine words :)
16:09:10 <dcoutts> but at least it does not use pinned memory
16:09:15 <gcollins> yeah
16:09:20 <gcollins> is pinned memory that bad?
16:09:27 <jre2> anyone know if ghc 6.10 works against libgmp.so.10.0.1?
16:09:51 <dcoutts> gcollins: it's not good for the GC, it'd need a good benchmark to show what the real difference is
16:10:06 <dons> are they literals?
16:10:09 <jmcarthur> epoll is linux only, isn't it?
16:10:09 <gcollins> i haven't noticed any extreme GC overhead
16:10:12 <dons> or just new tiny strings?
16:10:20 <gcollins> jmcarthur: yes -- bsds have kqueue
16:10:34 <jmcarthur> ah, so is the plan to support all of these interfaces?
16:11:05 <danharaj> is there a command to ask Cabal if a package is installed?
16:11:07 <gcollins> the event library tibbe & bos are working on does epoll & kqueue
16:11:20 <jmcarthur> ah cool
16:11:31 <dcoutts> gcollins: hopefully it'll get less bad if I can convince dons to let me reimplement ByteString using ByteArray# rather than ForeignPtr :-)
16:12:05 <dcoutts> then it will not be pinned and it'll be just 4 words overhead shared and 6 words unshared
16:12:12 <gcollins> dcoutts: what happens to unsafePackCString in that scenario
16:12:21 <dcoutts> gcollins: it copies
16:12:25 <gcollins> aha.
16:12:37 <dcoutts> gcollins: but any C lib that cares about performance provides a way to let the client manage the buffers
16:12:40 <gcollins> i can see why dons would battle you on that one :)
16:12:47 * gcollins nods
16:12:53 <Null-A> I want to define a function F :: IO a, which is only evaluate once to generate result a, even though its of type IO; is this possible?
16:13:05 <Saizan> danharaj: ghc-pkg list
16:13:05 <dcoutts> gcollins: well that's just it, I don't think it actually matters for performance
16:13:07 <Null-A> each subsequent calls return the same value
16:13:19 <dcoutts> gcollins: the only case is mmap, and that can be done specially
16:13:28 <danharaj> Saizan: thanks
16:13:39 <danharaj> cabal list also worked for me.
16:13:48 <danharaj> Is one preferred over the other?
16:15:06 <jmcarthur> ghc-pkg works without cabal-install
16:15:07 <Saizan> ah, cabal list --installed ?
16:15:33 <Saizan> ghc-pkg is lower level in some sense
16:15:54 <danharaj> cabal list by itself lists packages and whether they are installed
16:16:20 <dcoutts> gcollins: actually unsafePackCString would disappear, there would only be the safe one remaining
16:21:06 <mjrosenb> Null-A: you could have an IORef, and the first time you evaluate it, you write the value you got into the IORef, then every subsequent time, you grab the value out of the IORef.
16:21:27 <Null-A> mjrosenb: nah doesn't help me in this situation, here's the situation
16:21:40 <Null-A> mjrosenb: I'm using Data.Binary, and during deserialization I need to do IO
16:21:43 <Null-A> put its pure :(
16:22:45 <mjrosenb> Null-A: so you want to be able to read the value as if it were not in IO?
16:23:18 <Null-A> mjrosenb: I want to do IO during deserialization ?
16:23:28 <Null-A> mjrosenb: specifically I'm calling newIORef during deserialization
16:23:49 <Null-A> I'm instancing binary, implementing 'get' which cannot do IO
16:35:54 <danharaj> can anyone recommend a library for loading image files and manipulating them? (bmp or png, preferably)
16:36:10 <pastorn> danharaj: for loading SDL is good
16:36:14 <pastorn> it supports everything
16:36:43 <pastorn> danharaj: with SDL you get a Ptr (something pixely)
16:37:12 <pastorn> from there it's not too hard to convert it to something a bit nicer, like... an STArray
16:40:10 <dons> gd
16:40:12 <dons> gtk
16:40:15 <dons> sdl
16:40:18 <dons> hunt around on hackage
16:41:16 <danharaj> dons: I could hunt around and play package roulette, or I could ask here abotu peoples' favorites.
16:41:47 <ivan> is there any way to get basic syntax highlighting for Haskell working in IntelliJ IDEA?
16:43:15 <danharaj> I guess I should also qualify my request with: I want to load these images up as opengl textures at some point.
16:45:09 <jre2> berp seems to lack python's awesome feature of not optimizing tail calls
16:46:27 <shapr> @remember jre2 berp seems to lack python's awesome feature of not optimizing tail calls
16:46:27 <lambdabot> Good to know.
16:46:29 <jre2> a recursive factorial(100000) succeeds in 17.5s (vs ghc's 13s and python slitting it's wrists)
16:46:30 * shapr snickers
16:46:39 <soupdragon> I think Haskell is a great programming language and we should write a book about some advanced science topic using Haskell
16:47:05 <shapr> jre2: Did you get berp to build with ghc6.12?
16:47:11 <jre2> although python terminates in just 0.075s, so at least it doesn't get your hopes up
16:47:18 <shapr> I got distracted into demonstrating Haskell's awesomeness!
16:47:20 <jre2> shapr: no, I installed a vm for ghc 6.10 ;)
16:47:22 <shapr> and I'm still on vacation!
16:47:25 <shapr> jre2: ooh, smart
16:47:27 <soupdragon> forget about learning haskell, that has been covered - we need books about how to compute properties of neutron starss
16:47:33 <pastorn> soupdragon: maybe DPH should mature a little first :)
16:48:35 <wli> soupdragon: How is an advanced science topic written about using Haskell?
16:49:11 <pastorn> wli: maybe how to hack the type system to enforce physical types?
16:49:26 <soupdragon> wli, here is an example of what I mean -- but its too short
16:49:32 <pastorn> wli: velocity * time = distance etc.
16:50:14 <wli> Dimensional analysis?
16:50:19 <soupdragon> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.8.6171&rep=rep1&type=pdf
16:50:26 <soupdragon> Structure and Interpretation of Quantum Mechanics
16:50:28 <jesusabdullah> \int_0^t v(t) dt = distance
16:50:30 <jesusabdullah> :)
16:50:42 <soupdragon> Check this out, This is the future
16:51:03 <soupdragon> That paper is just a short note and it looks a bit rushed but the idea is briliant
16:51:04 <pastorn> soupdragon: haha... i like the title :)
16:51:04 <wli> Structure and Interpretation of Classical Mechanics?
16:55:46 <jesusabdullah> What paper?
16:55:50 * jesusabdullah likes paper
16:56:03 <soupdragon> I just linked it
16:56:08 <soupdragon> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.8.6171&rep=rep1&type=pdf
16:56:13 <jesusabdullah> oh duh
16:56:22 <soupdragon> I've typed up about half of it too
16:58:17 <jesusabdullah> from kets to bras?
16:58:32 <jesusabdullah> hehe, bras
16:58:46 <soupdragon> doh
16:59:07 <soupdragon> <phi|psi>
17:00:37 <jesusabdullah> hmm?
17:52:02 <dantheman_> hey all. I'm thinking of writing a few simple programs in order to get a handle on functional reactive programming. I was just wondering what would be the best implementation to use, Yampa?
17:52:57 <dons> yampa's a classic one. Reactive is also emerging, http://hackage.haskell.org/package/reactive
17:53:01 <dons> there are more examples for yampa, iirc
17:53:25 <dons> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:frp
17:53:58 <dantheman_> Ok.
17:54:26 <dantheman_> What are the main differences between yampa and Reactive? Theoretical, implementation, etc?
17:55:01 <dons> yikes. that's out of my pay grade. ask conal :-)
17:55:09 <Saizan> yampa interface uses arrows, reactive monads, the first has a working implementation :)
17:55:46 <Saizan> (the semantics have some differences too, but that's out of my depth :)
17:56:04 <dantheman_> ha, ok no worries!
17:56:09 <dantheman_> Thanks.
17:59:08 <danharaj> is there a way to give cabal extra directories to look in for --extra-include-dirs and --extra-lib-dirs so I don't have to use them every time?
18:02:22 <Saizan> danharaj: yes, see the corresponding fields in ~/.cabal/config
18:02:28 <danharaj> ah ok.
18:03:05 <danharaj> saizan: getting a nicely behaving build environment on windows is like shooting yourself in the foot.
18:03:25 <bremner> easy?
18:03:35 <danharaj> painful
18:03:43 <Saizan> yeah, it's not very funny.
18:04:20 <danharaj> I'm tired >:|
18:04:31 <Saizan> you kind of wish there were no packages using the FFI at some point :)
18:05:25 <danharaj> Apparently in order to get the sdl package to build I have to fix a bug in hsc2hs
18:05:51 <danharaj> however I don't know which version of hsc2hs I should try to rebuild in order to not explode with my distribution of haskellplatform.
18:06:16 <danharaj> Which happens to, for no apparent reason, have omitted a C++ compiler in the latest version even though it came included previously.
18:07:21 <danharaj> I might just scrap the entire damn thing and build my own environment from scratch.
18:08:00 <deech> Hi all, are there any hslogger tutorials available?
18:10:37 <BMeph> danharaj: It could be worse - you could have a 64-bit Windows computer! >;)
18:10:44 <danharaj> Guess what I have.
18:11:02 <BMeph> danharaj: It could be worse; you could have a 64-bit Windows computer! >;)
18:11:20 <BMeph> ...that was weird.
18:11:30 * BMeph waits for the echo...
18:12:00 <EvanR> echo
18:12:19 <BMeph> danharaj: Oh? Which experimental 64-bit C++ compiler are you using? :\
18:12:41 * BMeph thanks EvanR; it was worth the wait! ;þ
18:12:57 <danharaj> I'm using 32-bit mingw with msys
18:13:07 <danharaj> but I'm on 64-bit windows 7
18:14:25 <BMeph> danharaj: Ah, well (32-bit) MinGW seems solid - good luck integrating it into GHC's setup... ;)
18:15:00 <danharaj> mingw is actually a piece of crap.
18:15:44 <danharaj> But that just might be because it is a compiler for crappy languages with crappy build systems.
18:34:39 <soupdragon> What's the most efficient CReal style thing?
18:35:19 <dmwit> CReal, I guess.
18:35:29 <dolio> roconnor's stuff claims to be efficient.
18:35:30 <dmwit> Rational is nice, too.
18:36:10 <dolio> And also claims to have a prototype somewhere.
18:36:26 * dolio thought it was a Haskell prototype.
18:36:42 <soupdragon> well the haskell code is a prototype for the Coq development?
18:36:49 <dolio> Right.
18:38:10 * soupdragon is going ot haave another go at this quasi-crystal nonsense
18:40:56 <systemfault> Coq... stupidest name ever for a programming language.
18:41:20 <ddarius> systemfault: It's a proof assistant, not a programming language.
18:41:25 <soupdragon> I just want to ask
18:41:37 <soupdragon> http://pastie.org/985049.txt
18:41:39 <soupdragon> what's up with this?
18:41:41 <soupdragon> does it matter?
18:41:48 <soupdragon> that's when doing cabal install numbers
18:41:58 <systemfault> ddarius: Well :/ It's still a stupid name...
18:42:07 <alpounet> systemfault, yeah, particularly considering its French meaning
18:42:12 <systemfault> And a french name as a bonus..
18:42:21 <dolio> soupdragon: That definitely looks weird.
18:42:23 <systemfault> alpounet: Indeed.
18:42:40 <dmwit> trolls, feeding, etc.
18:42:42 <soupdragon> I mean.. CReal appears to be working
18:42:56 <soupdragon> so maybe I can just ignore it
18:43:05 <EvanR> an abstract syntax tree is a representation of the source code, what do you call a analogous structure that represents the evaluating program, like in graph reduction
18:44:27 <Saizan> soupdragon: iirc, there's a ticket on ghc's trac about that, and it said it didn't cause further problems
18:44:33 <ddarius> EvanR: There isn't any unique or common one.  Arguably there need not be one.
18:44:53 <ddarius> For example, you could model evaluation with reductions directly on the AST.
18:45:42 <dmwit> Excellent! Thanks to profiling, I now crash in 3 seconds instead of 7.
18:45:59 <dolio> Well done!
18:46:11 <systemfault> Haha
18:46:26 <EvanR> ddarius: but you might do funny things to it before starting the reductions, like making it not a tree anymore
18:46:38 <systemfault> dmwit: With a bit more profiling, you'll crash even faster than a C program!
18:46:51 * systemfault hides.
18:47:10 <dmwit> If this were a C program, the code would not have progressed this far before I got fed up.
18:47:53 <soupdragon>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression <---- hate this error..
18:48:05 <dmwit> How do people usually go about discovering which things should be made strict?
18:48:20 <dmwit> I've profiled, but to be quite honest, I don't know how to read the result for this purpose...
18:48:49 <soupdragon>       (You cannot give a fixity signature for an imported value) WHAT?????
18:49:06 <soupdragon> Urgh
18:49:18 <soupdragon> what kind of horrible person made that rule
18:49:28 <dmwit> Fixity is declared (or assumed) at interface boundaries. It's hard to imagine retaining sanity during compiler-writing if that weren't the case.
18:49:38 <dmwit> Separate compilation is really, really nice.
18:49:48 <ddarius> EvanR: Yes, you might.  Hence their not being a unique or particularly common representation.
18:50:14 <soupdragon> @index Monad (->)
18:50:15 <lambdabot> bzzt
18:50:18 <EvanR> i was just looking for a name
18:50:20 <soupdragon> @instances Monad
18:50:21 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:50:26 <ddarius> dmwit: It's usually best to make things appropriately strict or non-strict as you go.
18:50:32 <ddarius> EvanR: "The state of the machine"
18:50:39 <dmwit> ddarius: How do I tell what is appropriate?
18:50:40 <EvanR> for a data type ;)
18:50:51 <ddarius> dmwit: Experience.
18:51:05 <soupdragon> god dammit
18:51:07 <soupdragon> "   No instance for (Monad ((->) ..."
18:51:09 <EvanR> data MachineGraph
18:51:16 <ddarius> dmwit: Usually, unrolling a few iterations of a recursion by hand will reveal any unwanted build-ups.
18:51:18 <dmwit> soupdragon: import Control.Monad.Reader
18:51:19 <soupdragon> why isn't import Control.Monad.Instances imported
18:51:29 <soupdragon> I really hate Prelude
18:51:34 <dmwit> or Control.Monad.Instances, sure
18:52:07 <dmwit> ddarius: Is there a way to ask GHC which recursion I should unroll by hand?
18:52:40 <dmwit> I've got over a thousand lines of inexperienced code; it would be a shame to have to unroll all recursions by hand by trial-and-error, because then I'd probably just drop the project.
18:53:36 <ddarius> dmwit: You can use the various types of profiling to get more information, but it is like debugging, you aren't always pointed at the right location and you usually need some "detective" work.
18:54:17 <ddarius> Also, it isn't necessarily an issue of strictness.  Memory leaks exist in all languages.
18:54:25 <dmwit> Are there tools other than -prof -auto-all? Your wording ("various types of profiling") seems to suggest so.
18:54:47 <ddarius> dmwit: There are different types of statistics that can be reported by GHC's profiling.
18:54:51 <dmwit> Well, I've got a stack overflow. My impression was that these were usually the fault of laziness.
18:55:17 <dmwit> Okay, I'll have a look at GHC's manual, then.
18:55:47 <ddarius> dmwit: After compiling for profiling, passing the run-time option, -xc to the executable will give you a stack trace of sorts that may help.
18:56:14 <ddarius> Also, the debugger may help.
18:56:20 <dmwit> Oh, cool.
18:56:32 <ddarius> Finally, you can get stack overflows in Haskell for the exact same reasons you get them in Scheme.
18:57:15 <soupdragon> http://i.imgur.com/RMVih.png
18:57:17 <dmwit> Hm... stack overflow in deleteEdge. That's unexpected.
18:57:20 <soupdragon> Cale
18:57:20 <soupdragon> :)
18:57:28 <soupdragon> I think this is a quasi-crystal
18:57:42 <ddarius> dmwit: The results can be somewhat misleading if taken naively.
18:57:48 <dmwit> ddarius: ...and why do you get stack overflows in Scheme?
18:57:55 <dmwit> ddarius: Yes, I believe this.
18:58:12 <dmwit> ddarius: Probably deleteEdge is just the first function to force a deeply-nested thunk or something, right?
18:59:33 <ddarius> dmwit: That's a possibility.  The "stack trace" given by -xc is more similar to a stack trace in an eager language than the actual "stack" of Haskell.
19:00:20 <ddarius> dmwit: You get stack overflows in Scheme for failing to write tail recursive code.  sum = foldr (+) 0 (for a strict (+)) breaks in Haskell for the exact same reason the analogous code breaks in Scheme.
19:00:38 <dmwit> hm
19:01:48 <tomberek> can a constraint say something like (Applicative f,Eq a) but still apply to a kind *->*
19:01:51 <ddarius> Anyway, seeing deleteEdge gives you an idea what may being forced, when.  Also, are there cycles in the stack trace?
19:02:31 <ddarius> tomberek: Did you mean Eq f otherwise I don't understand what you are trying to ask.
19:03:23 <dmwit> No cycle, but the trace always gets printed twice. (I assume that's normal.)
19:04:13 <tomberek> ddarius... say I have a monad m.  So, (Applicative f,Monad m) => Monad (f m)  but the kinds are wrong.  I'm trying to say that an applicative (functor could work) of monads, is a monad
19:04:52 <aavogt> you can use a newtype / data to do that composition
19:04:56 <dmwit> ...what is an applicative of monad?
19:05:13 <dmwit> Oh, I see.
19:05:14 <aavogt>  ApplicativeOfMonad f m a = f (m a)
19:05:24 <tomberek> aavogot: yeah
19:05:40 <aavogt> you never manage to highlight me
19:05:49 <dmwit> Yours is a very tricky name3.
19:05:57 <aavogt> I see
19:05:58 <tomberek> aavogt: yay
19:06:02 <aavogt> :P
19:06:12 <tomberek> so that has to be a newtype?
19:06:17 <dmwit> Waiting for aaVogot.
19:06:27 <tensorpudding> a vogon
19:06:55 <aavogt> tomberek: maybe type (no constructor) can work
19:06:57 <tomberek> there's no (Applicative f,Monad m, 'where (f m)') => Monad (f m)
19:07:07 <tomberek> hm
19:07:20 <tomberek> thanks
19:07:24 <tomberek> i'll play around
19:09:38 <tomberek> aavogt: type synonyms need to have all their parameters filled in
19:10:32 <Polarina> > [1..] `seq` 'a'
19:10:33 <lambdabot>   'a'
19:10:37 <Polarina> Why isn't that an infinite loop?
19:10:51 <soupdragon> > (undefined:undefined) `seq` 'a'
19:10:52 <lambdabot>   'a'
19:10:53 <Zao> Doesn't it just force to whnf?
19:10:56 <soupdragon> > (undefined) `seq` 'a'
19:10:57 <lambdabot>   *Exception: Prelude.undefined
19:11:02 <haploid> What a crazy-ass language, this is going to be fun.
19:11:04 <Zao> _:_ is good enough.
19:11:55 <tomberek> Polarina: it only reduces once, so once it does (1:[2..]) `seq` 'a'     it is done.  perhaps?
19:12:25 <Zao> You might be wanting some kind of deepSeq or something.
19:13:31 <Polarina> tomberek, thanks. :)
19:13:51 <aavogt> > length [1..] `seq` 'a'
19:13:56 <tomberek> Polarina: um.. i'm not sure on that, soupdragon or aavogt might know better
19:13:57 <Saizan> whnf == up to the outermost constructor, to be clear :)
19:13:58 <lambdabot>   mueval: ExitFailure 1
19:14:09 <soupdragon> > 4*(sin (2*pi/5))^2 - 4*(cos (pi/2))^2 :: CReal
19:14:13 <lambdabot>   mueval-core: Time limit exceeded
19:14:17 <soupdragon> > 4*(sin (2*pi/5))^2 - 4*(cos (pi/2))^2
19:14:17 <lambdabot>   3.6180339887498945
19:14:19 <soupdragon> oh come on..
19:14:26 <aavogt> or lambda
19:14:44 <soupdragon> well something has gone badly wrong here
19:14:48 * Saizan tends to think of lambdas as constructors
19:14:54 <tomberek> Saizan: so that's right, as soon as it gets to the first (:) it stops?
19:14:58 <aavogt> pattern matching, Saizan?
19:14:59 <soupdragon> > 4*(sin (2*pi/5))^2 - 4*(cos (pi/5))^2
19:15:01 <lambdabot>   0.9999999999999996
19:15:05 <Saizan> tomberek: yup
19:15:18 <Polarina> > [undefined, undefined] `seq` 'a'
19:15:19 <lambdabot>   'a'
19:15:37 <Saizan> aavogt: ah, you don't have {-# LANGUAGE HigherOrderPatterns #-} turned on? ;)
19:15:43 <tomberek> nice, i can answer a question here and there, feel less useless all the time
19:16:04 <Polarina> tomberek, :)
19:17:16 <aavogt> Saizan: how would that work?
19:18:02 <aavogt> is this vaguely like being able to manipulate patterns as expressions?
19:18:03 * soupdragon gives up on the quasicrystals.. god dammit
19:18:17 <aavogt> soupdragon: why aren't they real crystals?
19:18:35 <aavogt> if they don't repeat, how are they sort of crystals?
19:20:37 <Saizan> aavogt: there are some logic languages, e.g. twelf, where the terms are allowed to contain lambdas, so you can pattern match against those, and all the substitution/free variables ordeal is taken care of for you
19:20:43 <ddarius> aavogt: Higher order matching is doable.  Heffalump's thesis is actually on that.
19:21:03 <ddarius> Higher order unification is quite a bit harder than higher order matching.
19:21:28 * gwern reads about Rice's theorem. man.
19:21:37 <Saizan> uh, link to the thesis?
19:28:00 <tomberek> is there an id at the type level?
19:28:17 <soupdragon> no
19:28:18 <tomberek> some type operator or something that is *->*
19:28:36 <tomberek> a 'type lifted' id?
19:28:40 <tomberek> dang
19:29:06 <tomberek> so it has to be newtype L a = L a?
19:29:22 <Saizan> mh, maybe with type families? but those are restricted too
19:29:56 <tomberek> Saizan: yes, i'm using type families
19:32:48 <Polarina> Is parsec slow?
19:32:58 <c_wraith> compared to what?
19:33:09 <Polarina> c_wraith, a handwritten parser.
19:33:38 <c_wraith> that would depend entirely on how good you are at writing parsers by hand.
19:33:44 <c_wraith> Parsec 3 is notably slower than parsec 2.
19:33:53 <Polarina> Why's that?
19:34:14 <dcoutts> c_wraith: I was told that's no longer the case
19:34:20 <c_wraith> Oh, really?  nice.
19:34:31 <dcoutts> but I have not seen any benchmarks
19:35:16 <gwern> weren't there benchmarks on -cafe?
19:36:05 <c_wraith> ..  Though I doubt I'll ever use Parsec anyway.  If I don't care about parser performance, I'd rather use something easier.  And if I really *need* the best possible performance, I'd use something less dynamic than Parsec..  Either something hand-coded, or generated from a static grammar definition.
19:36:11 <Polarina> Does anyone know of a good tutorial for parsec3?
19:36:44 <mwotton> c_wraith: i've always found parsec pretty pleasant to use - what do you mean
19:36:48 <mwotton> by something easier?
19:37:46 <c_wraith> mwotton, I mean something non-deterministic, so I don't need to worry about try, or other combinators that muck with things related to parser operation, rather than actually parsing.
19:42:08 <djahandarie> attoparsec is quite nice if you need parsing speed
19:43:19 <c_wraith> Sometimes.  attoparsec isn't really fast for some use cases.  It's brilliant for the cases it was optimized for, though.
19:44:13 <FunctorSalad> "<mauke> and yeah, this code is clearly superior to printf "%.2f"
19:44:13 <FunctorSalad> <mauke> just look at all the typesafety" import Text.Printf.TH
19:44:42 <djahandarie> printf makes me cringe, it feels so wrong
19:45:41 <Philonous> djahandarie: Yeah, why do we _need_ a stringly typed DSL for text templating? It's archaic.
19:45:58 <FunctorSalad> odd. I like it
19:46:37 <FunctorSalad> the additional conciseness is just too great :)
19:46:52 <FunctorSalad> and it's just as safe with Printf-TH
19:47:17 <FunctorSalad> and often more readable than "..."++show ....++"..."
19:47:38 <dolio> Has anyone been following the MPTC stuff on haskell-cafe/prime?
19:48:00 <pastorn> is there an instance of PrintfType ByteString?
19:48:23 <FunctorSalad> pastorn: Printf-TH has "%H" which compiles to `show'
19:48:37 <FunctorSalad> don't remember what the Show instance of BS is though
19:48:54 <FunctorSalad> (pretty or pack [ ... ])
19:49:25 <c_wraith> the show instance of BS isn't what he wants, certainly
19:49:55 <pastorn> c_wraith: certainly not!
19:50:43 <jmcarthur> type Id a = a
19:50:45 <jmcarthur> done!
19:51:20 <jmcarthur> entirely useless though
19:52:23 <djahandarie> dolio, do you mean Carlos Camarao's email?
19:52:28 <dolio> Yes.
19:52:41 <dolio> And the ensuing thread.
19:52:49 <Saizan> somewhat, why?
19:52:54 <djahandarie> I only read his e-mail (skimed it really)
19:53:07 <dolio> I was wondering what other people thought.
19:53:14 <soupdragon> it's so simple, I just can't do it
19:53:16 <FunctorSalad> newtype ShowString = ShowString ByteString...? ;)
19:53:31 <dolio> From my limited perusal, I don't really see why it's much better than fundeps.
19:53:37 <FunctorSalad> or just extend the printfs :)
19:54:11 <ddarius> Polarina: The Parsec letter applies mostly unchanged to Parsec 3 except that it doesn't cover newer features.
19:54:36 <dolio> It sounds like he suggests that as long as the instances in scope *could* satisfy a functional dependency, we might as well resolve things as if such a fundep was in place.
19:54:55 <dolio> But that doesn't sound that amazing to me, so maybe I'm missing something.
19:55:30 <Saizan> ah, i even thought it just was a "let's assume the world is closed" thing
19:58:37 <dolio> At least, I'm not inclined to get rid of fundeps, and then write code that happens to obey a fundep so that a more clever constraint solver can figure things out.
19:58:49 <dolio> I'd rather declare the fundep so it can be enforced.
19:59:22 <soupdragon> > 5 ^ .5 * .5 + .5
19:59:24 <lambdabot>   <no location info>: parse error on input `.'
19:59:27 <soupdragon> > 5 ^ 0.5 * 0.5 + 0.5
19:59:28 <lambdabot>   Ambiguous type variable `t' in the constraints:
19:59:28 <lambdabot>    `GHC.Real.Fractional t'
19:59:29 <lambdabot> ...
19:59:31 <soupdragon> > 5 ** 0.5 * 0.5 + 0.5
19:59:32 <lambdabot>   1.618033988749895
20:01:14 <dolio> Although better constraint solving might be good to have anyway.
20:02:19 <Saizan> i think it's necessary for any serious use of type families
20:02:49 <soupdragon> Does anyone have a good description how to do penrose tiling based on 5D quasicrystals?
20:02:59 <soupdragon> I can't understand De Bruijns paper :(
20:03:26 <Trav> can anyone give me some help, i'm kinda new to haskell
20:03:33 <soupdragon> yes Trav
20:03:35 <soupdragon> what is it
20:03:41 <Trav> well i've got a numer like
20:03:49 <Trav> 9822345672341
20:03:53 <Trav> and i wanna show it as
20:03:54 <soupdragon> @let n = 9822345672341
20:03:55 <lambdabot>  Defined.
20:04:11 <Trav> 982 - 234567 -234 - 1
20:04:21 <soupdragon> why in that way?
20:04:21 <danharaj> > show n
20:04:22 <lambdabot>   Ambiguous occurrence `n'
20:04:22 <lambdabot>  It could refer to either `L.n', defined at <local...
20:04:34 <Trav> haha i'm not that bad
20:04:43 <Zao> show and a bunch of splitAt?
20:04:44 <danharaj> First thing you want to do is convert it to a string
20:04:52 <danharaj> and then... yeah
20:04:53 <soupdragon> k everyone talk at once
20:04:57 <Trav> lol
20:04:58 <Zao> soupdragon: OK!
20:05:03 <danharaj> We are a hive mind, duh.
20:05:10 <dolio> @undefine
20:05:11 <Trav> i'll check out Split At then
20:05:15 <Zao> I'd @stereo but it's probably boring.
20:05:17 <Trav> would that be the way?
20:05:22 <pastorn> Trav: first you use 'show' to make it into a string, then it's probably easiest if you use 'take', 'drop' and '++' to format it the way you wont
20:05:25 <pastorn> *want
20:05:28 <soupdragon> urhg
20:05:46 <gwern> @stereo
20:05:46 <lambdabot> Unknown command, try @list
20:05:51 <Saizan> or you could use div and mod..
20:05:55 <gwern> so we did get rid of it
20:06:01 <Trav> yeah div and mod is long though
20:06:36 <Olathe> > let replaceDots ds x = f ds (show x) where f _ [] = []; f [] _ = error "zomg zomg"; f ('.':ds) (x:xs) = x:f ds xs; f (d:ds) xs = d:f ds xs in replaceDots "... - ...... -... - ." 9822345672341
20:06:37 <lambdabot>   "982 - 234567 -234 - 1"
20:06:38 <soupdragon> Trav why is it split in this way ? 982 - 234567 -234 - 1
20:06:49 <pastorn> Olathe: haha
20:06:58 <Trav> umm hang on how do i pm people
20:07:04 <Zao> Trav: Preferably not.
20:07:06 <Trav> lol i assume thats what the red is
20:07:18 <Zao> Trav: No, probably just a mention of your name.
20:08:51 <FunctorSalad> the "zomg zomg" is essential
20:10:30 <FunctorSalad> :t (=~)
20:10:31 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
20:11:30 <c_wraith> that's sure abuse of typeclasses
20:11:55 <FunctorSalad> > "9827593284" =~ "(...)(.....)(..)" :: [[String]]
20:11:56 <lambdabot>   [["9827593284","982","75932","84"]]
20:12:16 <FunctorSalad> c_wraith: wait until you see the instances :| I dislike that class with a passion
20:12:31 <c_wraith> FunctorSalad, I've seen enough of them to be afraid ;)
20:12:48 <siracusa> What does Control.Concurrent.Chan.readChan do if there's no item available in the channel, does it block and wait?
20:13:17 <c_wraith> siracusa, yes
20:13:30 <siracusa> Ah ok
20:14:06 <tomberek> can someone help me with this? it works, but it's ugly and I want to clean it up.   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25825#a25825
20:14:44 <FunctorSalad> (... mystery meat polymorphism ...)
20:19:08 <tensorpudding> Expected type Either Beef Ham, Inferred type Spam
20:20:14 <FunctorSalad> yes, and you're expected to deduce what "Either Beef Ham" means as the result of a regex execution
20:22:17 <haploid> is anyone here successfully running haskell platform on ubuntu karmic koala ?
20:23:04 * p_l bets there's somewhere a function like that... fry :: MysteryMeat -> Edible
20:23:39 <tensorpudding> instance Edible MysteryMeat where...
20:24:05 <p_l> heh
20:24:34 <tomberek> sautee :: MysteryMeat -> Either Good Bad
20:25:02 <p_l> irradiate :: MysteryMeat -> Preserved MysteryMeat
20:25:18 <p_l> (I recommend some hard gamma for that)
20:32:58 * hackagebot diagrams 0.2.1.3 - An EDSL for creating simple diagrams  http://hackage.haskell.org/package/diagrams-0.2.1.3 (BrentYorgey)
20:34:56 <glguy> haploid: seems like Ubuntu is emulating OS X right down to the poor GHC support :)
20:35:33 <p_l> glguy: "desktop friendly" distros are frankly speaking too crazy, IMHO.
20:36:01 * p_l recalls that a lot of the stuff that got "broken" later worked for him when he was a wee newbie with Mandrake in hand
20:36:50 <glguy> p_l: I don't think I know what you just said :)
20:37:16 <haploid> glguy:  thanks, but it turns out my host disabled noexec on /var/tmp which screws checkinstall.  I almost have it working now :)
20:38:33 <p_l> glguy: heh. Ubuntu and similar seem to keen on emulating other OSes instead of actually solving the issues, which creates weird stuff of which poor GHC support is probably one of the simplest issues :D
20:38:46 <dons> i always write Appel, when I mean Apple.
20:40:22 * p_l considered getting a hackintosh due to Adobe stuff but decided it wasn't worth the hassle (getting a Mac means both hassle and extra cost)
20:42:19 <FunctorSalad> you tried to checkinstall make install ghc? that didn't work for me either for some reason
20:44:43 <haploid> FunctorSalad yeah, I had to umount /var/tmp because my host had it mounted as noexec
20:46:52 <FunctorSalad> I don't have any /var/tmp
20:47:38 <FunctorSalad> or wait, I have the dir and things in it, but it's not a mountpoint
20:47:49 <haploid> FunctorSalad well, wherever checkinstall dumps the scripts into.  I'm assuming you're having the exact same issue I did?  Specifically "bad interpreter: Permission denied"
20:50:04 <FunctorSalad> haploid: apparently this is the first error: *** glibc detected *** inplace/bin/ghc-cabal: free(): invalid pointer: 0xbfcd5697 ***
20:50:38 <FunctorSalad> (works normally without checkinstall)
20:52:10 <FunctorSalad> it's the 6.12.3 release candidate btw ;)
20:57:30 <haploid> this is a bit of chicken and egg issue for the newer haskell.  the haskell people recommend using the platform to get ghc, yet trying to configure the platform emits " The Haskell Platform version 2010.1.0.0 requires ghc-6.12.1"
20:59:06 <Saizan> compiling the platform requires a ghc, yeah
20:59:24 <Saizan> at least you know which version to install now :)
21:01:13 <haploid> yeah it's not a big deal, just strikes me as odd that all the haskell download links go to the platform, and even the ghc page has a huge "stop, use the platform instead" banner
21:01:22 <haploid> yet you can't build the platform without it :)
21:02:56 <Polarina> Just as much of an irony as gcc requires gcc to compile itself.
21:03:34 <FunctorSalad> haploid: but does one have to compile the platform?
21:04:09 <Makoryu> haploid: The platform *is* distributed as binaries....
21:07:05 <FunctorSalad> awesome, cabal install gtk works now!
21:07:12 <FunctorSalad> with the 6.12.3rc
21:13:29 <djahandarie> @pl \f a -> fix (\f -> a >>= flip unless (f a))
21:13:29 <lambdabot> const (fix . liftM2 (.) (>>=) ((flip unless .) . flip id))
21:16:27 <djahandarie> @pl \f a -> fix (\f' -> a >>= flip unless (f a)) f
21:16:27 <lambdabot> flip =<< ap (>>=) . (flip unless .)
21:16:45 <djahandarie> @pl \f a -> fix a >>= flip unless (f a)
21:16:45 <lambdabot> liftM2 (>>=) fix . (flip unless .)
21:16:53 <djahandarie> Yeah, time to go to bed
22:08:14 <soupdragon> let palindrome x = show x == reverse $ show x
22:08:17 <soupdragon> what's wrong with that ?
22:08:37 <RyanT5000> need parens around (reverse $ show x)
22:08:55 <dons> ?pl palindrome x = show x == reverse $ show x
22:08:55 <lambdabot> palindrome = liftM2 (reverse ==) show show
22:08:57 <dons> heh
22:09:12 <dons> cute
22:10:37 <portnov> @pl \x -> reverse x == x
22:10:37 <lambdabot> (==) =<< reverse
22:10:53 <portnov> ^^
22:12:19 <soupdragon> > 12345679*81
22:12:20 <lambdabot>   999999999
22:14:20 <soupdragon> @oies 2,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,4
22:14:20 <lambdabot>  Sequence not found.
22:17:55 <tomberek> can someone critique this statement: A functor encapsulates the preservation of structure.
22:18:30 <soupdragon> I don't like the 'encapsulates'
22:18:32 <soupdragon> sounds like OO speak
22:19:22 <tomberek> well, the idea being that a type, along with a structure preserving map forms a Functor.
22:21:15 <tomberek> soupdragon: basically, the structure of anything can be isolated using fmap (\_->())
22:22:37 <soupdragon> > (81*).[1..10]
22:22:38 <lambdabot>   [81,162,243,324,405,486,567,648,729,810]
22:23:20 <wli> That's not in the standard Prelude.
22:23:42 <soupdragon> death to the prelude
22:24:50 <tomberek> soupdragon, and then applicative.  That is the idea that a structure can store not just data, but functions
22:27:26 <dmwit> :t local
22:27:27 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
22:27:33 <glguy> moving to non-standard definitions on lambdabot is an important step to keeping people from using lambdabot to teach all of those pesty noobs
22:27:55 <ddarius> glguy: And here I didn't think we had a plan at all.
22:28:12 <glguy> now you are in on the plan
22:28:15 <glguy> but don't tell anyone else
22:28:24 <glguy> *it's a secret*
22:28:48 <dmwit> > do { x <- show; return (reverse x == x) } 12321
22:28:49 <lambdabot>   <no location info>: parse error on input `12321'
22:28:52 <dons> sigh
22:28:55 <dmwit> > do { x <- show; return (reverse x == x) } $ 12321
22:28:56 <lambdabot>   True
22:29:15 <dmwit> > do { x <- show; return (ap (==) reverse x) } $ 12321
22:29:16 <lambdabot>   True
22:29:31 <k23z__> why are fixedpoint combinators important ?
22:29:37 <k23z__> can something interesting be done with them ?
22:29:41 <k23z__> and also useful
22:29:43 <k23z__> ?
22:29:48 <dmwit> > fmap (ap (==) reverse) show 12321
22:29:48 <lambdabot>   True
22:29:59 <dmwit> blegh
22:30:08 <dmwit> ?pl fmap (ap (==) reverse) show
22:30:08 <lambdabot> fmap (ap (==) reverse) show
22:30:19 <tomberek> hehe
22:30:33 <dmwit> k23z__: They are important because they allow you to write recursion, even in languages that don't have recursive bindings.
22:30:36 <glguy> > ap (==) reverese <$> show $ 12321
22:30:37 <lambdabot>   Not in scope: `reverese'
22:30:44 <glguy> > ap (==) reverse <$> show $ 12321
22:30:45 <lambdabot>   True
22:30:59 <ddarius> > ap (==) reverse . show $ 12321
22:31:00 <lambdabot>   True
22:31:02 <glguy> >  (==) <*> reverse <$> show $ 12321
22:31:03 <lambdabot>   True
22:31:15 <ddarius> > ap (==) reverse Prelude.. show $ 12321
22:31:16 <tomberek> glguy what are you trying?
22:31:16 <lambdabot>   Not in scope: `Prelude..'
22:31:26 <dmwit> k23z__: It's easy to take recursive bindings for granted -- almost every useful language has them. =)
22:31:43 <glguy> tomberek: to refine dmwit's function to something syntactically shorter
22:31:55 <dmwit> k23z__: But the fixpoint combinator means that the compiler writer doesn't have to support it explicitly.
22:32:36 <dmwit> :t f x y -> liftM (ap f x) y
22:32:36 <lambdabot> parse error on input `->'
22:32:40 <k23z__> dmwit, thank you for your answer, my lack of understanding however doesn't let me make much of it
22:32:40 <dmwit> :t \f x y -> liftM (ap f x) y
22:32:41 <lambdabot> forall a1 a r (m :: * -> *). (Monad m) => (a1 -> a -> r) -> (a1 -> a) -> m a1 -> m r
22:32:59 <dmwit> k23z__: Well, ask another question, and I'll do my best to answer that one, too.
22:33:13 <k23z__> dmwit, what is ap and liftM ?
22:33:22 <dmwit> k23z__: They are unrelated. =)
22:33:34 <k23z__> yes but what are they
22:33:38 <k23z__> I want to understnad what you just wrote
22:33:41 <k23z__> you wrote a lambda
22:33:43 <k23z__> that returns something
22:33:44 <dmwit> ap is the S combinator
22:33:55 <k23z__> is that some sort of lambda ?
22:34:02 <k23z__> I can only relate to things I currently know
22:34:11 <c_wraith> :t ap
22:34:12 <k23z__> dmwit, can you explain to me in terms of algebra ?
22:34:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:34:13 <dmwit> Have you mucked about with monads at all?
22:34:27 <dmwit> Well, never mind.
22:34:27 <k23z__> dmwit, not at all, but I do know what a monoid is , if it's of any help
22:34:59 <k23z__> hmm so I better learn monads first
22:35:05 <ddarius> @google "bracket abstraction"
22:35:06 <lambdabot> Plugin `search' failed with: connect: does not exist (Connection refused)
22:35:09 <ddarius> @google "bracket abstraction"
22:35:09 <lambdabot> Plugin `search' failed with: connect: does not exist (Connection refused)
22:35:15 <c_wraith> :t (<*>)
22:35:15 <ddarius> Hmm
22:35:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:35:20 <EvanR> google just crashed
22:35:21 <Guest83563> hello everybody, here I have some issues with haskell performance due memory leaks: http://dumpz.org/19838/
22:35:22 <dmwit> ap f g x = f x (g x) -- k23z__
22:35:46 <k23z__> ok so   f(x,g(x))
22:36:04 <k23z__> that's what I understand from what you wrote the definition of ap is
22:36:15 <dmwit> Yes, that's fine.
22:36:30 <_minoru> it's a simple fastcgi application that eats ~60Mb more RAM for every 100 000 requests
22:36:32 <k23z__> is this function special in some particular way ?
22:36:46 <dmwit> k23z__: liftM f g x = f (g x) -- the other question you asked
22:36:51 <dons> _minoru: space leaks, not "memory leaks" :)
22:36:52 <dmwit> k23z__: Yes, it is special.
22:37:02 <dons> memory leaks are what happens in C++ when you forget pointers
22:37:06 <tomberek> k23z__ : they help combine functions in interesting ways
22:37:15 <k23z__> so liftM is   f(g(x)) so function composition maybe ?
22:37:15 <dmwit> The S combinator is just what you need to translate lambda abstraction into combinator language. =)
22:37:22 <dmwit> Yes.
22:37:26 <_minoru> dons, ok :)
22:37:33 <_minoru> also, here is profiler output: http://dumpz.org/19846/
22:37:36 <dmwit> k23z__: But these are two particular specializations of ap and liftM; in general they can do more interesting things. =)
22:37:42 <dons> _minoru: have to think about your code. it looks a bit messy :}
22:37:58 <dons> is that with -prof -auto-all ?
22:38:11 <ddarius> dmwit: There are other combinators that can be used for bracket abstraction (and should be used in practice.)
22:38:16 <dons> _minoru: how are you testing it?
22:38:19 <_minoru> dons, yes, of course
22:38:27 <ddarius> dmwit: However, you can consider S mildly special still because it corresponds to contraction.
22:38:44 <k23z__> ddarius, I know of one type of contraction
22:38:54 <dons> btw, you can write haskell without the parens: low <- getInput "low"
22:39:16 <k23z__> ddarius, the one used in this theorem http://en.wikipedia.org/wiki/Banach_fixed_point_theorem
22:39:19 <dmwit> ddarius: I have noted this down to Google next time I have some free time.
22:39:23 <k23z__> ddarius, it's used to solve some types of recurrences
22:39:29 <k23z__> ddarius, I've read that some time ago
22:39:36 <ddarius> k23z__: I wasn't talking to you.
22:39:44 <k23z__> ok sorry
22:40:25 <dmwit> Don't mind ddarius, he's just gruff.
22:41:09 <dons> _minoru: just refactoring.
22:41:10 <dons> thinking
22:41:36 <_minoru> dons, ab -n 100000 'http://localhost/fastcgi/simplefcgi3?low=50&high=100'
22:41:47 <dons> thanks
22:41:53 <soupdragon> I can't beleive that 999999999 (nine nines) is divisible by 123456789
22:41:54 <_minoru> dons, also, I have just found a solution
22:41:56 <soupdragon> what the hell!
22:42:30 <soupdragon> > 0xFFFFFFFF/0x123456789ABCEF
22:42:31 <lambdabot>   8.381903169587716e-7
22:42:42 <soupdragon> > 0xFFFFFFFFFFFFFFFF/0x123456789ABCEF
22:42:43 <lambdabot>   3599.9999999999886
22:42:43 <shadwick> soupdragon: you'd need 15 Fs
22:42:49 <soupdragon> > 0xFFFFFFFFFFFFFFF/0x123456789ABCEF
22:42:50 <lambdabot>   224.9999999999993
22:42:53 <soupdragon> > 0xFFFFFFFFFFFFFFF/0x123456789ABCEF ::CReal
22:42:54 <lambdabot>   224.9999999999992974369922293953199083715922
22:42:56 <soupdragon> hm
22:42:59 <soupdragon> so it doesn't work in any base?
22:43:23 <shadwick> > 999999999 / 123456789
22:43:24 <lambdabot>   8.10000006561
22:43:26 <dons> _minoru: oh, might be forever getting in the way
22:43:33 <dons> or iterate.
22:43:34 <shadwick> not divisible soupdragon
22:43:36 <dmwit> > 999999999 `mod` 123456789
22:43:37 <lambdabot>   12345687
22:43:41 <dmwit> yeah...
22:43:45 <shadwick> ah
22:43:47 <dmwit> Doesn't work in any base. =P
22:44:21 <_minoru> dons, http://dumpz.org/19861/ - fast and dirty, but memory leaks are stopped now
22:44:22 <soupdragon> > 9999999909/123456789 -- :(
22:44:23 <lambdabot>   81.0
22:44:26 <soupdragon> I thought I found something nice there
22:44:34 <soupdragon> turns out I just can't read
22:44:50 <dmwit> > 9999999909 `mod` 123456789
22:44:51 <lambdabot>   0
22:45:01 <dons> yeah, there was some mis-optimization with 'forever' i guess
22:45:14 <EvanR> dons: wait. what?
22:45:22 <_minoru> also, rkit from haskell@conference.jabber.ru proposed a solution via IO monad: http://dumpz.org/19858/ , but i really don't like it
22:45:23 <EvanR> i use forever all the time :S
22:45:26 <dons> forever $ sequence_ $ iterate
22:45:28 <dons> is really weird
22:45:29 <dons>  :)
22:45:33 <dmwit> > 0xffffffffffffff0f `mod` 0x123456789abcdef
22:45:34 <lambdabot>   0
22:45:44 <dons> EvanR: oh, there was a bug in 6.12 where under some interesting inlinings forever would hang on to values
22:46:37 <dons> _minoru: refactoring a bit http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25828#a25828
22:46:42 <soupdragon> > 999999999/12345679
22:46:43 <lambdabot>   81.0
22:46:44 <soupdragon> ^ thats it
22:46:55 <shadwick> soupdragon: what are you trying to prove?..
22:47:05 <soupdragon> nothing
22:47:09 <shadwick> ok
22:47:12 <_minoru> dons, I tried to rid from 'forever' by this way: http://dumpz.org/19862/ but it doesn't helped me
22:47:40 <_minoru> also, thanks you :)
22:48:06 <ddarius> The forever should be kind of pointless because the sequence_ won't terminate unless an exception is thrown.
22:48:52 <glguy> last $ take 50000
22:49:04 <tomberek> ddarius: can you explain the purpose of WrappedMonad and WrappedArrow in Control.Applicative?
22:49:40 <tomberek> ddarius: is this the no-superclass issue?
22:49:40 <glguy> !! 49999
22:49:43 <ddarius> I really think the use of iterate is most squarely the problem and quite odd.
22:50:34 <ddarius> Larger and larger monadic actions are being made and I doubt any of the random number generators states can be garbage collected.
22:50:54 <glguy> stdgen's are best passed in a state monad
22:52:12 <kniu> I'm liking the snap web framework.
22:52:18 <glguy> :t foldM ?f ?stdgen (replicate 50000 ())
22:52:19 <lambdabot> forall a (m :: * -> *). (?f::a -> () -> m a, ?stdgen::a, Monad m) => m a
22:52:56 <kniu> it seems so simple.
22:53:24 <kniu> How come other web frameworks got all this XML stuff and complicated organization?
22:53:55 <soupdragon> > 0xFFFFFFFFFFFFFFF/0x123456789ABCDF
22:53:56 <lambdabot>   225.0
22:53:57 <soupdragon> > 999999999/12345679
22:53:58 <lambdabot>   81.0
22:54:02 <soupdragon> ^ is this a pattern?
22:54:11 <EvanR> the web is simultaneouly overengineered and underengineered
22:54:13 <soupdragon> how do I do binary iin haskell?
22:54:18 <soupdragon> oh wait binary doesn't work
22:54:33 <glguy> > 1/1
22:54:34 <lambdabot>   1.0
22:54:43 <glguy> success!
22:55:38 <soupdragon> what other bases are there
22:55:41 <shadwick> kniu: hmm, I hadn't heard of snap before but it's intriguing
22:55:44 <soupdragon> can you do octal in haskell?
22:55:51 <pastorn> if i want to fetch X webpages in paralell, how would i go about doing that?
22:56:01 <EvanR> > 0123 + 0345
22:56:02 <lambdabot>   468
22:56:05 <soupdragon> > 0xFF
22:56:06 <lambdabot>   255
22:56:20 <shadwick> '0o'
22:56:24 <kniu> shadwick, yeah, I've never done any web programming before, so I'm definitely not fit to judge frameworks.
22:56:27 <shadwick> 0o10 / 2
22:56:28 <soupdragon> > 0o10
22:56:29 <lambdabot>   8
22:56:29 <shadwick> > 0o10 / 2
22:56:30 <lambdabot>   4.0
22:56:32 <shadwick> yeah
22:56:38 <soupdragon> > 0o8
22:56:39 <lambdabot>   Not in scope: `o8'
22:56:40 <soupdragon> > 0o7
22:56:41 <lambdabot>   7
22:56:45 <kniu> But right now I'm also looking at Google Web Toolkit, and the code just seems so...
22:56:49 <soupdragon> > 0o7777777/0o123457
22:56:49 <ddarius> pastorn: Presuming that you want to do this in Haskell, write the code to get one webpage and then simply forkIO a bunch of copies of it.
22:56:50 <lambdabot>   49.0
22:56:53 <kniu> overdone.
22:56:55 <soupdragon> > 077
22:56:56 <lambdabot>   77
22:56:58 <soupdragon> > 0o77
22:56:58 <lambdabot>   63
22:57:05 <soupdragon> how do you get 49 in octal?
22:57:23 <pastorn> @type forkIO -- ddarius how?
22:57:24 <lambdabot> Not in scope: `forkIO'
22:57:25 <dons> _minoru: did you see ddarius' reply. sequence_ . iterate isn't right here.
22:57:33 <pastorn> forkIO  :: IO  ()  -> IO  ThreadId
22:57:36 <soupdragon> > showIntAtBase 8 77""
22:57:37 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
22:57:37 <lambdabot>    arising from a use ...
22:57:38 <ddarius> > 0o61
22:57:38 <soupdragon> > showIntAtBase 8 77 ""
22:57:39 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
22:57:39 <lambdabot>    arising from a use ...
22:57:39 <lambdabot>   49
22:57:44 <kniu> there's like a whole bunch of different classes, each one inheriting from a whole bunch of other classes, and besides what I can derive from their long-ass names, their function is a mystery to me.
22:57:44 <soupdragon> thank you!
22:58:13 <kniu> All this just to render one page that takes the user's name and echoes it back.
22:58:33 <pastorn> ddarius: should i create IORefs and pass as arguments to the threads?
22:58:34 <soupdragon> > (6+9)`mod`8
22:58:35 <shadwick> kniu: unfortunately, I've had to use PHP before..
22:58:35 <lambdabot>   7
22:58:45 <soupdragon> > (0xF+0xF)`mod`0xFF
22:58:46 <lambdabot>   30
22:58:48 <shadwick> soupdragon: there's a little thing called GHCi :P
22:58:50 <soupdragon> > (0xF+0xF)`mod`16
22:58:51 <lambdabot>   14
22:59:08 <soupdragon> that shouldn't be 14 afaict
22:59:13 <shadwick> yes
22:59:14 <shadwick> 15 + 15
22:59:15 <shadwick> = 30
22:59:16 <kniu> nah, sometimes I learn some things when other people use lambdabot to experiment.
22:59:18 <ddarius> pastorn: You haven't said what you want to do with these web pages.
22:59:29 <shadwick> soupdragon: you're thinking 0x20 `mod` 16
22:59:36 <shadwick> > 0x20 `mod` 16
22:59:37 <lambdabot>   0
22:59:41 <pastorn> ddarius: just parse them with regexpes
23:00:24 <ddarius> pastorn: Why do you think you would want to pass IORefs to the forked IO actions?
23:00:30 <pastorn> ddarius: it would be a program that prints out what's on tv right now; one page per channel must be fetched...
23:01:00 <pastorn> ddarius: well, i need a value back, right?
23:01:07 <kniu> I don't IORefs are "safe" in multithreaded applications, yo.
23:01:08 <ddarius> pastorn: Do you?
23:01:18 <pastorn> a ThreadId is not really that useful...
23:01:42 <ddarius> pastorn: If you don't care what order the results are in, you can probably just have each IO action print out the result.
23:02:06 <pastorn> ddarius: but i want to sort the results by channel name...
23:02:56 <pastorn> though i *could* "assign" each channel a small space of the terminal window and move around to its own "space" when it has gotten its results...
23:03:21 <pastorn> using escape sequences and whatnot
23:03:27 <ddarius> pastorn: Pass in a new empty MVar per thread, then do sequence (takeMVar mvars) and have each thread store the relevant result in their MVar.
23:04:09 <pastorn> ddarius: why not make each thread responsible for its own printing?
23:04:16 <pastorn> and why mvar and not ioref?
23:05:20 <ddarius> pastorn: You can do that but it's unlikely to be cleaner than having a global view at once and it certainly isn't as modular.
23:05:28 <ddarius> pastorn: You can't block on IORefs.
23:05:47 <pastorn> what does that mean?
23:06:24 <ddarius> pastorn: It means you can't wait until an IORef is "full" before reading the value.
23:06:33 <EvanR> if you just read all the IORefs, their values are meaningless because the workers havent written them yet
23:06:43 <soupdragon> > 8*3+4
23:06:44 <lambdabot>   28
23:06:47 <EvanR> and i thought they werent thread safe anyway
23:06:58 <pastorn> oh, so i'd be constantly polling if i'd want to do that + using IORef (Maybe val)
23:07:10 <ddarius> pastorn: Yes.
23:07:25 <jmcarthur> polling is a scary solution
23:07:35 <pastorn> ok... so using mvars will remove a bunch of messy threadDelay calls?
23:07:40 <EvanR> IORef (Maybe value) is basically MVar, only not thread safe
23:07:54 <pastorn> EvanR: oh, ok...
23:08:06 <ddarius> EvanR: atomicModifyIORef should be atomic and otherwise I'm not sure how IORefs can fail to be threadsafe.  Certainly they don't provide any thread coordination ability, though.
23:08:15 <jmcarthur> with IORef you could poll, see that there is a value, but then by the time you have manipulated it or something the value is already gone or changed by some other thread
23:08:17 <EvanR> ah right, atomicModifyIORef
23:09:39 <pastorn> in this program there would only be one program that would write to the IORef, and only write once
23:09:44 <jmcarthur> pastorn: using MVar would not only be less messy and simpler, but it would also be faster and safer
23:09:53 <pastorn> jmcarthur: cool
23:09:54 <jmcarthur> compared to polling
23:09:56 <pastorn> @where mvar
23:09:56 <lambdabot> I know nothing about mvar.
23:10:20 <EvanR> pastorn: see also Chan for a fifo
23:10:33 * jmcarthur has never needed Chan
23:10:33 <tomberek> i get Conflicting family instance declarations. Is there a way to avoid them?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25829#a25829
23:10:38 <kyagrd> has anyone tried installing ghc-paths using cabal?
23:10:58 <kyagrd> it gives me "cabal: Codec.Compression.Zlib: incorrect header check" meesage and fails
23:12:04 <ddarius> s/sequence (takeMVar mvars)/mapM takeMVar mvars/
23:13:33 <ddarius> do mvars <- mapM (do mvar <- newEmptyMVar; forkIO (doStuff >>= putMVar mvar); return mvar); results <- mapM takeMVar mvars; doStuffWithResults results
23:15:07 <ddarius> The first mapM would be over a list of "channels" or whatever and doStuff should be parameterized by them.
23:18:31 <ddarius> concurrentSequence :: [IO a] -> IO [a]; concurrentSequence actions = do mvars <- mapM (\action -> do mvar <- newEmptyMVar; forkIO (action >>= putMVar mvar); return mvar) actions; mapM takeMVar mvars
23:19:29 <EvanR> bah youre taking all the fun out of boiler plating ;)
23:19:37 <ddarius> main = concurrentSequence (map getWebpage channels) >>= displayShows
23:29:58 <soupdragon> > !+1
23:29:59 <lambdabot>   <no location info>: parse error on input `!+'
23:30:37 <ddarius> 1
23:36:42 <Axman6> @hoogle Bits a -> a -> a
23:36:43 <lambdabot> Warning: Unknown type Bits
23:36:43 <lambdabot> Prelude asTypeOf :: a -> a -> a
23:36:43 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
23:36:46 <Axman6> @hoogle Bits a => a -> a
23:36:47 <lambdabot> Data.Bits complement :: Bits a => a -> a
23:36:47 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
23:36:47 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
23:36:59 <Axman6> complement 1 :: Int32
23:37:04 <Axman6> > complement 1 :: Int32
23:37:05 <lambdabot>   -2
23:52:30 <Axman6> How 'bout dem cows eh?
