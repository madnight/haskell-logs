00:36:39 <Gracenotes> hm. bad news: GD doesn't handle PNG transparency well at all
00:45:13 <Olathe> > let f [] ys = ys; f (_:xs) (_:ys) = f xs ys in f [1..10] [1..20]
00:45:20 <Olathe> Bah
00:46:11 <Gracenotes> or rather, the provided interface doesn't..
00:46:48 <Axman6> @hoogle FilePath -> IO String
00:47:00 <Axman6> lambdabot!
00:47:11 <Axman6> god damn it, how do you get the contents of a file again?
00:47:37 <Olathe> readFile ?
00:47:59 <Olathe> readFile :: FilePath -> IO String
00:48:00 <Axman6> yes!
00:48:50 <profmakx> is it possible in yi to show line numbers to the left as :set nu in vim does? Or rather, is it doable as an option or do I have to code up the solution myself?
01:16:07 <muhtimin> win 35
01:16:14 <muhtimin> sorry :P
01:21:17 <roconnor> polynomials over the trivial ring are very confusing.
01:28:42 <jpcooper> hello
01:28:51 <kmc> hi
01:28:59 <jpcooper> is there a current relational database library for Haskell?
01:29:15 <earthy> um. yeah?
01:29:23 <jpcooper> maybe something which works with sqlite
01:29:34 <jpcooper> earthy, could you give me its name, please?
01:29:49 <earthy> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database
01:30:02 <earthy> then pick your choice. :)
01:30:25 <jpcooper> which is the most widely used?
01:30:28 <earthy> I'd go with either haskelldb or hdbc.
01:30:34 <jpcooper> thanks
01:31:12 <earthy> oh, waitsec. do haskelldb, as it can use its own backends, hdbc backends as well as hsql backends.
01:31:59 <earthy> of course, if you just want a thin layer over sqlite3, it might not be the right choice
01:32:12 <jpcooper> a combinator library sounds good
01:32:18 <earthy> if you want to easily switch between databases however... :)
01:52:31 <Vitka> @pl \a b -> f (g a b)
01:52:49 <quicksilver> Cale: where's our lambdabot?
01:53:09 <quicksilver> Vitka: (f .) . g
01:53:11 <jpcooper> Vitka, (f . g) .
01:53:15 <jpcooper> damn it
01:53:24 <Vitka> Heh.
01:53:52 <Silvah> :<
01:54:11 <Silvah> lambdabot's gone?
01:55:30 <quicksilver> apparently so.
01:55:43 <copumpkin> she's hiding
01:56:23 <Silvah> I don't want to play hide and seek with her :(
02:01:38 <jpcooper> http://stats.betfairgames.com/xhlstats/xhl_stats.20100501.csv
02:01:42 <jpcooper> does that work for anyone?
02:04:21 <dhouthoo> I get a not found message
02:05:03 <dhouthoo> 404 even
02:11:14 <FunctorSalad> did we remove :m as a shortcut for :module in ghci?
02:11:17 <FunctorSalad> :mo still works
02:11:31 <Twey> Um, I don't think so?
02:11:57 <tensorpudding> that would be obnoxious of them
02:14:19 <jpcooper> htanks dhouthoo
02:15:15 <FunctorSalad> Twey: well, does it still work in your ghci? (6.12.2)
02:15:32 <FunctorSalad> tensorpudding: I suspect some other command grabbed it, not willful sabotage ;)
02:16:21 <quicksilver> unfortunately the abbreviations are dynamic, computed based on available commands.
02:16:29 <FunctorSalad> :m just blocks for me, now
02:16:35 <quicksilver> This is a sucky design, in fact, because future changes can kill old abbreviations
02:16:49 <quicksilver> I still haven't forgiven them for causing :b to no longer be :browser
02:16:53 <FunctorSalad> quicksilver: ah. apart from that I thought it's a good idea
02:17:02 <quicksilver> :m works in 6.12.1
02:17:05 <quicksilver> I don't have 6.12.2
02:17:06 <FunctorSalad> (better than *no* abbrevs, that is)
02:17:37 <Twey> Yeah, same
02:18:16 <quicksilver> FunctorSalad: yeah, the drawbacks of dynamically calculated abbreviations are not obvious until, well, you experience them :)
02:19:09 <FunctorSalad> quicksilver: one could conceive of a dynamic scheme that takes into account which command was first though
02:19:24 <FunctorSalad> but that'll appear arbitrary to newcomers
02:21:15 <FunctorSalad> ah. must be this ":mp" command I defined and forgot about
02:21:31 <FunctorSalad> ("music player" ;))
02:22:10 <FunctorSalad> ok that was it; my fault...
02:22:29 <quicksilver> FunctorSalad: exactly.
02:22:38 <quicksilver> (arbitrary to newcomers)
02:33:34 <Silvah> I miss her... :(
02:35:26 <Silvah> preflex: seen lambdabot
02:35:26 <preflex>  lambdabot was last seen on #haskell 6 hours, 38 minutes and 8 seconds ago, saying: Berengal says: '"Go away! You're not like us!" the other values yelled. "You're impure! Impure! Impure! Impure!" they started chanting.'
02:36:34 <Silvah> What happened to her?
02:39:19 <c_wraith> sometimes that machine goes down.  eventually cale will wake up and fix it.
02:56:45 <damkor> Hi. I want to paint an Image (as defined in Graphics.Fieldtrip.Image) on the screen using reactive-fieldtrip. I can't find appropriate function to render it on the screen. Does anyone know how?
03:13:20 <kmc> @pl \g -> g x y
04:02:25 <McManiaC> ivan: ping
04:03:24 <McManiaC> did anyone here ever work with SVN/vector graphics?
04:03:32 <cozachk> whats svn
04:03:37 <McManiaC> SVG
04:03:49 <cozachk> whats svg
04:04:00 <Jafet> svn is cool, check it out.
04:04:02 * cozachk has toyed with 2d vector graphics
04:04:16 <McManiaC> http://en.wikipedia.org/wiki/Scalable_Vector_Graphics
04:09:12 <cozachk> mcmaniac: some people have seemed to toy with svg and haskell lightly, google haskell svg
04:09:28 <cozachk> toyed
04:09:39 <quicksilver> you can use cairo to build up vector images and (I think) output as SVG
04:09:43 <quicksilver> not sure if cairo can input SVG
04:09:56 <dcoutts> yes
04:10:16 <dcoutts> cairosvg package is a binding to librsvg
04:10:27 <quicksilver> I played with rendering vector graphics in realtime with openGL
04:10:31 <dcoutts> lets you render svg to cairo surfaces
04:10:35 <quicksilver> but there are non-trivial problems to solve
04:10:45 <quicksilver> cairo is not designed for fast animations.
04:11:11 <dcoutts> no, it's designed for quality output and identical output on all backends
04:11:18 <dcoutts> GL does not guarantee that
04:11:55 <quicksilver> it could do, it depends how you write your GL backend :)
04:11:59 <McManiaC> http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.12/Graphics-Rendering-Cairo-SVG.html this one?
04:12:06 <quicksilver> there certainly have been discussions about a GL backend for cairo
04:12:06 <McManiaC> or is there a bigger cairo package?
04:12:12 <quicksilver> but anyway, that's not what I was doing.
04:12:23 <McManiaC> I dont need animations anyway :)
04:12:29 <dcoutts> quicksilver: that said, it's pretty fast for many operations, like compositing. The slow one iirc is gradients.
04:12:33 <quicksilver> I was doing my own vector engine with a GL backend, but I talked to the cairo people.
04:12:45 <quicksilver> dcoutts: re-triangulating curves is slow.
04:13:05 <quicksilver> dcoutts: if your animation has many curves in it, cairo burns a lot of power re-doing the triangulations for each frame.
04:13:23 <dcoutts> quicksilver: ah yes, it does not save anything between frames
04:13:26 * quicksilver nods
04:13:34 <quicksilver> it's not intended do, it's not what it's designed for
04:13:35 <dcoutts> since it's not explicitly designed for animation
04:13:47 <quicksilver> although when I talked about it with them, it was somethign they had given thought to
04:13:48 <Jafet> If you're careful with GL, the output should be reproducible
04:13:53 <quicksilver> I had the impression they'd like to do it.
04:13:59 <quicksilver> but it's not the main design goal.
04:14:24 <dcoutts> Jafet: problem is the gfx card manufacturers provide the GL drivers, and they care about performance not accuracy of results
04:14:33 <quicksilver> I wonder what the engine is that firefox uses to draw <canvas> elements
04:14:41 <dcoutts> Jafet: cairo has tests to guarantee pixel perfect results on all backends
04:14:47 <quicksilver> that copes fairly well with animations.
04:14:56 <dcoutts> quicksilver: I thought they used cairo
04:14:58 <McManiaC> quicksilver: this one? http://cairographics.org/hscairo/
04:15:11 <dcoutts> McManiaC: the one that's part of gtk2hs
04:15:28 <Jafet> Well, it's a tradeoff. GL is normally accurate unless you do funny things, like misscale mipmaps
04:15:46 <Jafet> Or use vendor extensions, but that's entirely different
04:16:47 <dcoutts> I expect it'll improve with GPUs, there's less in the way of vendor drivers to get in the way
04:16:57 <quicksilver> dcoutts: I believe it does if you are using the GTK backend, but I'm not sure if it does on win32/osx
04:18:49 <McManiaC> what gtk2hs package contains cairo?
04:18:59 <dcoutts> McManiaC: the package called cairo
04:19:21 <McManiaC> is it on hackage?
04:19:48 <quicksilver> dcoutts: well, anyhow there is already a gl-backend for cairo (still experimental I think) and also Quartz (which has the same reproducibility concerns, I expect)
04:20:06 <dcoutts> McManiaC: the gtk2hs packages are not yet on hackage
04:20:07 * cozachk wishes laptops had longer battery life 
04:20:21 <dcoutts> quicksilver: yes
04:20:27 <McManiaC> dcoutts: okay
04:20:59 <dcoutts> quicksilver: it's worse for quartz because there are some ops it cannot do at all, and then the whole thing has to be redone using the software renderer
04:21:29 * quicksilver nods
04:30:27 <jpcooper> who do I divide an Int by an Int to return a Float?
04:30:36 <jpcooper> how*
04:31:17 <kmc> jpcooper, apply fromIntegral first
04:31:23 <kmc> :t \x y -> fromIntegral x / fromIntegral y
04:31:25 <jpcooper> thanks
04:31:33 <kmc> aww lambdabot's gone
04:33:09 <quicksilver> > ((/) `on` fromIntegral) 3 5
04:33:10 <quicksilver> 0.6
04:49:57 <duairc> I might be missing something, but the result of putStrLn is never "used", right? How does laziness not prevent it from being "calculated" then?
04:50:57 <koala_man> duairc: it returns an IO (), which is used. the result of the result, (), usually isn't though
04:51:16 <kmc> duairc, execution and evaluation are two different things
04:51:24 <Jafet> putStrLn "asdf" >>= return -- whee
04:51:42 <kmc> laziness relates to evaluation.  the order of evaluation is the order in which stuff is demanded
04:51:53 <kmc> execution is about IO.  the order of execution is the order specified by (>>=) or "do" etc.
04:52:26 <kmc> the result of putStrLn is an IO action, which is like a "recipe" for how to do some execution.  the runtime system will evaluate the recipe, then do what it says
04:52:40 <duairc> Oh right, silly, of course it "uses" it to take the () out of the IO
04:53:23 <kmc> let m = do { putStrLn "Hello"; return (2+2) }
04:53:33 <kmc> main = do { _ <- m; return () }
04:53:41 <kmc> the addition in 2+2 is never performed
04:53:47 <kmc> because the result of the IO action is never forced
04:53:56 <kmc> but the action itself is performed -- that's a matter of execution, not evaluation
05:02:37 <quicksilver> duairc: the whole point of lazy evaluation is that it doesn't change semantics
05:02:49 <quicksilver> it only fails to evaluate things which actually aren't needed, that's the point
05:03:02 <quicksilver> execution is quite different, of course
05:03:18 <quicksilver> execution is not driven by data demand. Execution is driven by the way the IO monad is structured.
05:09:28 <McManiaC> dcoutts: what do I need to install gtk2hs? I tried autoreconf but keep getting "autoreconf: `configure.ac' or `configure.in' is required"
05:10:37 <dcoutts> McManiaC: are you using the tarball or the darcs repo?
05:10:47 <McManiaC> darcs
05:12:19 <dcoutts> McManiaC: the darcs version now uses cabal, the older releases (tarballs) use ./configure; make
05:12:39 <McManiaC> hm I dont have a .cabal file
05:13:00 <McManiaC> code.haskell.org/gtk2hs is correct?
05:16:31 <dcoutts> McManiaC: yes, the packages are in each subdirectory, glib, cairo, pango, gtk
05:33:21 <ivanm> where beith lambdabot?
05:34:33 <kmc> probably passed out in a gutter
05:39:16 <quicksilver> dcoutts: does the OSX build of gtk2hs go via X11?
05:42:04 <yezariaely> How can I set library search path to ~/lib for runghc ?
05:44:45 <ivanm> yezariaely: what is it searching for?
05:44:46 <ivanm> C libs?
05:44:55 <dcoutts> quicksilver: there's two gtk backends on osx, the X11 one and the newer native one
05:45:32 <dcoutts> quicksilver: gtk2hs can be built against either (since it does not affect the gtk API)
05:46:46 <yezariaely> ivanm: problem is I have no root access on this machine and i want to install uulib. Thus, i downloaded it, and installed it locally into ~/lib
05:47:17 <ivanm> hmmmm.....
05:47:34 <ivanm> dcoutts: how would yezariaely tell ghc where to find C librarys? LD_LOAD_PATH ?
05:47:40 <heropass> yez: what about your bashrc file? or profile?
05:47:44 <ivanm> yezariaely: is this the haskell uulib or the C uulib?
05:47:57 * ivanm just realised there was a haskell one as well...
05:48:20 <dcoutts> ivanm: on the ghc command line you can use -L, for cabal you can configure with --extra-lib-dirs=
05:48:38 <ivanm> dcoutts: well, he's using runghc for something *shrugh*
05:49:01 <yezariaely> ivanm it is the haskell one
05:49:10 <ivanm> yezariaely: oh, then I don't see what your problem is
05:49:15 <heropass> why not compile the whole thing in your ~?
05:49:24 <heropass> how much space do you get?
05:49:27 <ivanm> yezariaely: get cabal-install, then just do "cabal install uulib"
05:49:36 <ivanm> heropass: well, he's trying to do it in ~/lib ...
05:49:37 <dcoutts> yezariaely: if you're using the cabal command line program, then it's per-user by default.
05:49:56 <ivanm> yezariaely: even if you do it by hand, then ghc records where the library is installed when you build and install it...
05:50:08 <quicksilver> dcoutts: ah ok
05:50:20 <heropass> i should just go back to bed, reboot
05:52:43 <StarFire> Hmm, I'm having weird problems with c2hs. It fails to run the C preprocessor, but if I hack the source to use 'system' instead of 'runProcess', it works.
05:53:05 <heropass> speaking of OS X, I've had trouble getting cabal to install quick silver on a machine running snow leopard ... anybody else have this problem?
05:53:43 <StarFire> Also, it seems like language-c chokes on CRLF line endings.
05:55:07 <ivanm> StarFire: I doubt that that's language-c as opposed to just how you open the file
05:55:15 <dcoutts> StarFire: are you passing weird pre-processor options to c2hs?
05:55:24 <StarFire> dcoutts: -I directives.
05:55:44 <ivanm> StarFire: if you have a file with a different line-ending convention than the one your OS uses, then a simple liftM lines . openFile won't work either
05:55:46 <StarFire> dcoutts: If I run it with -d trace, and run the cpp command from the shell, it works.
05:55:49 <ivanm> (I think...)
05:55:51 <dcoutts> StarFire: are you escaping things perhaps?
05:56:14 <dcoutts> StarFire: using 'runProcess' is the correct thing to do, since it bypasses shell escaping
05:56:55 <StarFire> c2hs -C " -I/home/starfire/src/c/libtcod-1.5.0/include" -C "-I." HasTcod/Console.chs  <- Here's the c2hs line.
05:57:13 <dcoutts> StarFire: oops, embedded space there
05:57:23 <djahandarie> Ugh, lambdabot still out I see
05:58:10 <StarFire> ivanm: I don't use language-c myself. Rather, c2hs uses it.
05:58:20 <ivanm> StarFire: ahhh, right
05:58:25 <StarFire> ivanm: And it failed with a lexer error when I ran it on windows.
05:58:40 <heropass> > parse failure "lambdabot"
05:58:46 <dcoutts> StarFire: was c2hs built using ghc-6.12 on windows by any chance?
05:59:22 <StarFire> dcoutts: ghc-6.12 on Ubuntu karmic, unless you mean the language-c issue.
05:59:33 <dcoutts> StarFire: right, the crlf thing
05:59:50 <StarFire> With crlf, yes, ghc-6.12 (latest Haskell Platform) on Windows.
06:00:50 <StarFire> I got it working by hacking the language-c lexer to accept both \r and \n as eof, but that's not very elegant.
06:01:42 <dcoutts> StarFire: I think it's a bug in bytestring when built with ghc-6.12 which uses its new io system.
06:01:56 <dcoutts> StarFire: we used to get the crlf conversion for free but we don't any more
06:02:01 <StarFire> Ahh.
06:02:19 <dcoutts> bytestring used to rely on opening the files in text mode and on windows that does crlf conversion
06:02:36 <dcoutts> ghc now always uses binary mode and does the text decoding itself
06:02:44 <dcoutts> but the bytestring IO bypasses the ghc decoding
06:02:48 <dcoutts> hence the problem
06:03:25 <bastl> Can someone help me with this? System.Vacuum.Cairo produces strange syntax errors: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25592#a25592
06:03:33 <StarFire> The '$eol = [\n \r]' hack described above works for me, but that's probably not acceptable as a general fix.
06:03:45 <k23z__> how do I prove Haskell code to be correct ?
06:04:10 <k23z__> any article that shows how to do that like straight-forward , like an example and describes it well ?
06:04:18 <dcoutts> StarFire: right
06:04:51 <StarFire> But if the bug is in bytestring, then it will probably be fixed in a future release?
06:05:07 <reiv>  /quit
06:05:12 <djahandarie> Is there a point-free way to write f.f ?
06:05:21 <kmc> :t join (.)
06:05:23 <soupdragon> that is ppoint free
06:05:24 <djahandarie> Ah right
06:05:31 <kmc> «\f -> f.f» is not
06:05:36 <kmc> but that's «join (.)»
06:05:40 <djahandarie> Yeah
06:10:03 <heropass> "A common misconception is that the 'points' of pointfree style are the (.) operator (function composition, as an ASCII symbol), which uses the same identifier as the decimal point. This is wrong. The term originated in topology, a branch of mathematics which works with spaces composed of points, and functions between those spaces. So a 'points-free' definition of a function is one which does not explicitly mention the points (values)
06:10:03 <heropass> of the space on which the function acts."
06:11:44 <StarFire> dcoutts: Thanks for the tip, removing the space fixes the c2hs problem.
06:13:53 <dcoutts> StarFire: see we have to do it in that literal way, otherwise it messes up for paths with embedded spaces
06:14:05 <dcoutts> but it also means you can't add extra space
06:17:41 <StarFire> dcoutts: I had an additional space in my Makefile, which caused the problem. I would use cabal, but I don't know how to use information from environment variables with it.
06:18:17 <StarFire> I'm guessing hackage libraries use autoconf, but I don't know how to use that either.
06:18:37 <dcoutts> StarFire: I suppose you can use a script that calls cabal configure with $env vars for flags
06:18:52 <dcoutts> StarFire: no, most do not use autoconf
06:19:11 <StarFire> I mean the libraries that depend on some C libraries, like SDL and GLUT.
06:19:39 <dcoutts> StarFire: some of the FFI binding libs use autoconf
06:19:44 <dcoutts> especially the older ones
06:19:48 <StarFire> I need to pass the necessary include and library directories to cabal somehow.
06:19:53 <ketil> My static binaries keep saying "mkTextEncoding: invalid argument", is there any way I can avoid this?
06:20:10 <dcoutts> StarFire: right, --extra-lib-dirs and --extra-include-dirs should do it
06:20:17 <ketil> I gather it has something to do with unicode-awareness, but that's about as far as I've gotten.
06:20:27 <dcoutts> ketil: it'll be an iconv thing
06:20:46 <StarFire> dcoutts: Is it possible to add something to Setup.hs to dig those up from some environment variables?
06:20:59 <dcoutts> StarFire: in principle, yes
06:21:11 <soiamso> StarFire: .cabal hook
06:21:11 <StarFire> But not simply?
06:21:13 <dcoutts> StarFire: but it's probably easier to make a script that just calls cabal
06:21:16 <ketil> dcoutts, yes, that's about as far as I got.  Is there something I can do about it?  I'd rather not install a complete build environment on every computer I want to run my software on.
06:21:31 <dcoutts> ketil: we'd need to work out what is going on exactly
06:22:27 <dcoutts> ketil: eg see if it's a iconv version thing, or use lstrace to see how iconv is getting called and what it is responding with
06:22:35 <ketil> I have run strace on the target system, and it occurs after opening /usr/lib/gconv/UTF-32.so (twice, successfully).  No ltrace, unfortunately.
06:23:24 <Choko> is there an easy way to specialize a single function in a class, I've a class Ring defined on polynomials. What i want is to specialize exponentiation for some specific instance of this polynomial ring but not the other operations.
06:23:46 <dcoutts> ketil: I suggest filing a ticket with as much detail as possible, esp about the differences between the build and target box, eg run ldd on the binary on both
06:27:11 <ketil> It's static.  So there could be some incompatibility with the linked-in library and the system config (it opens /usr/lib/gconv files, which appear to be ELF binaries)
06:28:03 <mdmkolbe> Off topic: Has anyone else been getting messages from random people trying to send them to irc.tddirc.net#hackerthreads ?  (Every morning, I find someone tryed to send me there in the middle of the night.)
06:28:05 <ketil> Hm... 32bit binaries on the target, 64 bit on the compile host.
06:28:42 <Axman6> mdmkolbe: it's a DCC send sent to the channel
06:28:57 <Axman6> it's spam, and th epople doing it get k-lined immediately
06:29:01 <Axman6> people*
06:29:32 <quicksilver> well it's an attempted exploit, rather than spam.
06:29:46 <quicksilver> but the exploit is harmless unless you have whatever client it is they are trying to exploit.
06:30:21 <kassi> Wow!
06:30:22 <kassi> he!
06:30:26 <kassi> helgi!
06:30:31 <DigitalKiwi> /ctcp #haskell version
06:30:34 <mdmkolbe> Axman6: is it just this channel, all of freenode?  anyone know what their exploit / target client is?
06:30:44 <Axman6> this channel
06:30:55 <DigitalKiwi> other channels get similiar crap
06:31:14 <DigitalKiwi> sometimes other channels even get similiar crap that is the same
06:31:54 <quicksilver> tends to affect large channels, I guess. More potential victims.
06:31:56 <Axman6> mdmkolbe: because #haskell is one of the largest channels on freenode, it gets more attention
06:32:13 <DigitalKiwi> three people need to leave
06:32:17 <DigitalKiwi> 08:31 -!- Irssi: #haskell: Total of 669 nicks [1 ops, 0 halfops, 0 voices, 668 normal]
06:32:37 <quicksilver> wow, #jquery is nearly as big as #haskell.
06:34:01 <Jafet> kiwi, lead away!
06:34:02 <mdmkolbe> Axman6, quicksilver: thanks for giving me the scoop.  In a strange way it's kind of cool to know #haskell is big enough to warrent attack ... now where is that "unsafePerformIO launchMissiles" I had a moment ago?
06:35:37 <Jafet> I still have logs of the last GNAA hax, better gzip them
06:35:45 <DigitalKiwi> Jafet: if i leave then how will i get to rejoice when it is complete!
06:35:48 <DigitalKiwi> one more!
06:35:51 <DigitalKiwi> though, ...
06:36:00 <DigitalKiwi>  666 normal]
06:36:03 <DigitalKiwi> close enough! ;D
06:36:16 <Jafet> Send every 'partYou know what you doing.
06:36:21 <Jafet> '.
06:36:28 <Jafet> I don't know what I typing
06:36:39 <DigitalKiwi> i don't know what you're typing either
06:38:20 <Axman6> ok, so, best way to build the frequencyies for all Chars in a string (potentially quite long) would be a Map? or is there something better suited?
06:39:08 <Jafet> Suppose you could use fromEnum and IntMap
06:39:17 <Axman6> yeah
06:39:20 <Axman6> i might do that instead
06:39:33 <mdmkolbe> Axman6: maybe sort the list of chars, then groupBy (==) and map length
06:39:53 <Axman6> hmm, that could work too
06:40:20 <Jafet> Sounds efficient
06:43:19 <EvanR-work> what does the runReaderT/evalRand look like to 'run' a ReaderT r (Rand g) a ?
06:44:06 <soupdragon> :t runReaderT
06:44:20 <mreh> @botsnack
06:44:30 <EvanR-work> my question crashed the bot
06:45:15 <Axman6> Cale: where's lambdabot?
06:47:08 <soupdragon> basically my approach would be to fit runReaderT and evalRand together in the only possible way
06:53:47 <ketil> dcoutts, Got it!  Red Hat puts 64-bit gconv files in /usr/lib64/gconv, while Ubuntu puts native gconv files in /usr/lib/gconv (which gets hard-coded into the binary).  Setting GCONV_PATH to point to /usr/lib64/gconv solved the issue (or rather, worked around it).
06:58:35 <Axman6> hmm, isn't there some way to count the number occurences of letters in linear space?
06:58:38 <jkingkong> hey haskell, I was wondering if there was a better description of the hashtable library somewhere
06:58:48 <jkingkong> with access times and benchmarks and such
06:59:32 <Axman6> hashtables make for bad functional datastructures
06:59:41 <Axman6> <space>*
06:59:46 <jkingkong> yea this is what iwas wondering about
06:59:51 <Jafet> Axman, linear of what?
06:59:55 <jkingkong> why is this exactly?
07:00:12 <Axman6> Jafet: the number of different characters in the string i guess
07:00:19 <quicksilver> jkingkong: the correct description of Data.Hashtable is Don't Use It. Ever. No!. I Said No!
07:00:37 <jkingkong> quicksilver haha good to know
07:00:47 <quicksilver> jkingkong: use Maps or GMaps or Tries or Sequences, etc.
07:00:48 <jkingkong> i had just been noticing that everybody uses data.map
07:00:56 <Jafet> Axman ... what? A Map or IntMap will probably use about as much space as the size of the frequency table itself.
07:01:23 <Jafet> And usually, that will be much smaller than the size of the input
07:01:27 <jkingkong> is there something i can read that will help me understand this?
07:01:43 <quicksilver> jkingkong: well, a hashtable is fundamentally a mutable structure.
07:01:47 <Axman6> Jafet: well, not in my case, a 2MB input file can easily produce 1GB of ram usage
07:01:50 <Jafet> jkingkong, that depends on how much you understand already
07:01:50 <jkingkong> hashtables are bad for purity reasons then
07:01:57 <quicksilver> jkingkong: mutable structures are a poor fit with functional programs.
07:02:01 <Jafet> Axman, then ur doin eet rong
07:02:04 <jkingkong> i know what hashtable are
07:02:12 <jkingkong> and i know some haskell
07:02:16 <jkingkong> that's about it, jafet
07:02:33 <jkingkong> so you want to always get the same value with some key
07:02:34 <Jafet> jkingkong, read about persistency in data structures. You could start with Okasaki's web site.
07:02:35 <jkingkong> every time
07:02:44 <quicksilver> jkingkong: also, there are technical reasons why mutable structures interact with GHC's GC badly which make them even worse than that.
07:02:45 <jkingkong> but hashtables break that
07:02:54 <Jafet> No, you don't seem to understand persistent data structures, so read about that.
07:02:59 <jkingkong> ok
07:03:16 <jkingkong> thanks jafet, quicksilver
07:03:37 <Jafet> Wouldn't Data.Hashtable just be a Data.Array wrapper?
07:03:42 <Axman6> i really didn't expect the frequency counting to be the part that cost the most
07:03:48 <Axman6> in terms of space
07:03:50 <jkingkong> are you referring to http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf?
07:04:01 <jkingkong> Jafet?
07:04:11 <Jafet> Axman, there's something horribly wrong with your code then, you might want to ask about that
07:04:53 <Axman6> well, i've tried two methods, one using an explicit inserting function, one using sort and group. i'm yet to try a map
07:05:17 <Silvah> quicksilver: wasn't support for mutable arrays improved a bit in recent versions of GHC?
07:05:43 <Jafet> Even reading the whole input and sorting it shouldn't be that horrible, unless your code isn't being selfish enough somewhere
07:05:59 <Axman6> Jafet: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25595#a25595 is the frequency part
07:06:28 <Jafet> jkingkong, his doctoral might be a bit much to start; try his shorter papers like "Functional Pearls"
07:07:43 <ClaudiusMaximus> Axman6: i suspect you're building up large 1+1+1+1+1+1+1+1+... thunks, causing the space leaks
07:08:07 <jkingkong> can you give me a specific link jafet? sorry, i'm just seeing a lot of papers via google
07:08:13 <Axman6> ClaudiusMaximus: data CodeTree = Leaf !Char !Word64 | Node Word64 CodeTree CodeTree
07:08:30 <Axman6> so, it shouldn't be i don't think
07:08:51 <Jafet> I already suggested his web site: http://www.eecs.usma.edu/webs/people/okasaki/pubs.html
07:09:03 <ClaudiusMaximus> oops, i misparsed the precedence, sorry
07:09:23 * Axman6 really likes the output for Show for his CodeTree
07:09:35 <quicksilver> Silvah: yes.
07:09:36 <dcoutts> ketil: ahh, interesting
07:09:57 <Axman6> quite clearly shows where all the codes in the huffman code come from
07:10:20 <Silvah> Alas, without +RTS -H1500m -A1000m code from http://flyingfrogblog.blogspot.com/2009/04/f-vs-ocaml-vs-haskell-hash-table.html still performs very poorly.
07:11:03 <Axman6> i'd guess both the f# and ocaml ones are using mutable updates?
07:11:33 <Jafet> Erm, Data.Hashtable is mutable
07:11:41 <jkingkong> jafet sorry didn't see that
07:12:03 <Axman6> oh, is it?
07:12:06 * hackagebot haskell-src-exts-qq 0.2.3 - A quasiquoter for haskell-src-exts.  http://hackage.haskell.org/package/haskell-src-exts-qq-0.2.3 (MathieuBoespflug)
07:12:10 <Axman6> i've never looked at it
07:12:58 <Jafet> Me neither, but unless it uses DiffArray, it's got to be mutable
07:13:18 <dolio> It's mutable.
07:13:29 <jkingkong> thanks guys gonna get some reading done. ttyl
07:13:33 <mreh> does it mention the hours of time wasted debugging F# and ocaml code?
07:13:33 <Axman6> well, it could be a functional hashtable, which would explain the appaling performance (using Array or something)
07:13:34 <Silvah> If it wouldn't use in-place updates, it wouldn't need to use IO monad just everywhere.
07:14:02 <dolio> The poor performance is due to bad garbage collection behavior for boxed mutable arrays.
07:14:22 <Axman6> why isn't it using unboxed arrays?
07:14:27 <mreh> yeah?
07:14:39 <Jafet> mreh, poor performance is a bug too
07:14:45 <dolio> Because that severely limits what you can store in the hash table, presumably.
07:14:47 <StarFire> Wasn't that GC performance bug fixed a while back? Not sure if it's in 6.12.1 though.
07:14:53 <Jafet> It's often a particularly bad one, because it's hard to fix once written
07:15:11 <Silvah> StarFire: I asked the same thing several minutes ago ;)
07:15:13 <mreh> Jafet: I think i've come across this before in my own code without realising it
07:15:16 <mreh> man, that's pretty bad
07:15:19 <StarFire> Silvah: D'oh!
07:15:26 * edwardk_ waves hello.
07:16:07 * hackagebot dedukti 1.1.3 - A type-checker for the » -modulo calculus.  http://hackage.haskell.org/package/dedukti-1.1.3 (MathieuBoespflug)
07:16:38 <dolio> I did think that GHC was supposed to have card marking now. But perhaps that's still pending 6.14 or something.
07:17:11 * mreh read card making
07:17:27 <Silvah> :D
07:17:52 <Jafet> Yes! Haskell can do that.
07:17:53 <dolio> Oh, I guess it's in 6.12.2.
07:18:02 <mreh> turns out that using Data.Map was my big problem
07:18:38 <mreh> ah well, what do they say about premature optimisation
07:18:56 <quicksilver> really? you had code bottlenecked on Data.Map?
07:19:05 <Saizan> hackagebot has some problems with utf8
07:19:10 <quicksilver> It might not be the fastest thing on two legs but I'm surprised it would be a bottleneck.
07:19:10 <Silvah> Wish me luck. I'll try to build GHC HEAD with LLVM CG.
07:19:19 <Saizan> or maybe the rss feed is buggy.
07:19:30 <quicksilver> you must have been doing a lot of insertions per second?
07:20:07 <quicksilver> The worst case for Data.Map I've heard about is slow comparision operations e.g. Strings with long identical prefixes.
07:20:37 <mreh> yup
07:20:42 <mreh> suffix trees are better
07:21:09 <mreh> I was doing the spectrum kernel
07:21:22 <Jafet> Prefix trees?
07:21:31 <mreh> yes, those
07:21:31 <Jafet> Suffix trees sound a bit too immutable
07:21:55 <mreh> no, suffix trees actually
07:21:56 <Jafet> I'm actually surprised no one has described mutable suffix trees
07:22:57 <mreh> probably because there's dependence that isn't just restricted to the tree structure
07:23:10 <mreh> not sure, never took any time to learn them
07:23:17 <Jafet> Er, how are suffix trees related to maps?
07:23:32 <Jafet> A suffix tree indexes all the suffixes of a string
07:24:44 <edwardk> quicksilver: yeah but you can fix that with one of the various Trie implementations out there
07:24:49 <mreh> they aren't related directly, only in the implementation of the spectrum kernel
07:25:00 <Jafet> Okay
07:25:45 <edwardk> i have a Map-like trie lying around somewhere
07:25:57 <edwardk> i don't know if i ever uploaded it to hackage though
07:25:59 <ClaudiusMaximus> Axman6: here's my braindead/simple histogram code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25595#a25596
07:26:09 <dolio> Who doesn't? :)
07:26:12 <edwardk> dolio: heh
07:26:29 <dolio> There are multiple trie/map libraries on hackage, too.
07:26:30 <edwardk> dolio: i think there are at least 3 trees of bounded balance based tries in hackage
07:26:31 <edwardk> yeah
07:26:42 <Silvah> O.o
07:27:16 <Silvah> Why GHC does need MinGW runtime sources?!?
07:27:17 <edwardk> not to mention the bytestring based patricia trie, etc.
07:27:23 <Jafet> Is there a typeclass that describes elements of a Trie? Something like "Sequence"
07:27:37 <edwardk> Jafet: there is something in edison, but its not trie specific iirc
07:27:47 <Jafet> Sure, doesn't have to be
07:27:50 <edwardk> Jafet: but they implement the key-lookup collection class
07:27:57 <edwardk> i just can't recall its name
07:28:10 <Jafet> Silvah, because all programs built with mingw are linked against the mingw runtimes
07:28:24 <Jafet> You might be able to static link it, if you want to
07:28:43 <Silvah> Yep, though object files would suffice in this case.
07:28:50 <Axman6> ClaudiusMaximus: that's  not better space wise, and vastly slower
07:28:53 <dolio> It's too bad that summer of code project a while back to complete some sort of generalized trie/map library never really came to fruition.
07:28:58 <Axman6> i might just do it using the ST monad
07:29:00 <edwardk> as for persistent suffix tree/array code that is an interesting idea
07:29:08 <Jafet> Silvah, are you talking about building GHC or using GHC to build things?
07:29:10 <edwardk> dolio: yeah its been run multiple times, too. =/
07:29:20 <Silvah> Building GHC.
07:29:20 <dolio> It'd be nice to have an "automatically get the best performance for everything" map.
07:29:27 <edwardk> *nods*
07:29:32 <quicksilver> edwardk: of course, yes
07:29:37 <Jafet> Then my answer stands
07:30:11 <edwardk> dolio: i started a package for unboxed sets and maps but i'll admit i lost interest and put it down when the more interesting problem of how to pack the data in became ugly ;)
07:30:27 <Jafet> edwardk, suffix trees are already pretty persistent. I don't know any way to erase from them at any rate
07:30:31 <edwardk> in retrospect i should have just let the user define the packed format or used template haskell
07:30:40 <Jafet> I think you can add to them efficiently, though
07:31:14 <Jafet> Axman, why not use the obvious method of reading each character and updating the frequency table
07:31:35 <Axman6> Jafet: how is that now what i've been doing?
07:31:37 <Jafet> Oh, that's what was just posted
07:31:39 <Axman6> not*
07:32:29 <quicksilver> dolio: isn't gmap useful?
07:33:22 <quicksilver> dolio: http://hackage.haskell.org/package/gmap
07:33:43 <quicksilver> although "This will improve significantly in the next version" is always nice to see, from 2008 :)
07:33:46 <Jafet> I have no idea. Substitute IntMap for Map?
07:35:19 <dolio> quicksilver: Maybe. That's the summer of code project.
07:35:28 <ezeike> Hey I've got some haskell code with an error that i can't figure out, could someone take a peek and help me? http://dpaste.com/197027/
07:35:42 <dolio> That library is kind of structured backwards for my taste, as well, but maybe that's the better way to do it.
07:37:19 <dolio> I'm rather a fan of the family Map k that chooses a good implementation for any particular k. Rather than having me choose from several different possible maps for each type.
07:38:41 <Jafet> The former tends to lead to inscrutable, obsoleteable magic
07:38:47 <quicksilver> within the constraints of overlapping family instances, perhaps.
07:38:50 <Jafet> re: perl
07:39:35 <Silvah> I'm pretty convinced that building GHC under Windows will fail miserably. :O
07:40:06 <quicksilver> GHC is built on windows regularly by the developers
07:40:09 <Jafet> Also, GCC is trying a C++ library variant which profiles itself, Map can do something similar (and then you can use the profile to choose the implementation)
07:40:14 <quicksilver> which is not surprising considering they work for microsoft.
07:40:39 <quicksilver> but it does require you to have a rather particular development environment set up.
07:41:48 <Silvah> I've built GCC several times, so building GHC shouldn't be too hard, but nevertheless I'm sure it'll fail.
07:42:16 <quicksilver> however, you were talking about the LLVM backend and GHC HEAD
07:42:26 <quicksilver> which is possibly trickier.
07:44:00 <Axman6> can anyone see what's causing this error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25595#a25597 it's got me stumped
07:45:31 <edwardk> dolio: i agree
07:46:24 <Axman6> uh, with the missing line included: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25595#a25598
07:47:11 <edwardk> Jafet: it is hard to profile yourself when you're a library in a purely functional language, and your execution is interspersed among all the rest of the code. you can count reductions or some step metric, etc. but then restructuring is expensive because you can't amortize it easily
07:47:44 <Jafet> Fair point
07:48:10 <Axman6> no one? it feels like it's a really obvious tpye error, but i just can;t see what;s wrong :(
07:48:14 <edwardk> that and you wind up with an unnatural api because every operation even lookups would need to return a new tree, this is the problem with splay trees, etc.
07:48:29 <Jafet> But I was just thinking of tracing ops, and then you can choose some implementation that minimizes the cost of the common ops
07:48:39 <Jafet> Eg. AVL versus red-black trees
07:48:45 <edwardk> you can swap forM_ for flip mapM =)
07:49:14 <Axman6> means including another module :P
07:49:31 <dolio> > chr maxBound
07:49:33 <Axman6> i did define it myself, but it didn't like it, so i'm happy with it atm
07:49:40 <dolio> > ord maxBound
07:49:45 <Axman6> no lambdabot
07:50:09 <tromp> > (sqrt 28+sqrt 27)**(2/3) + (sqrt 28-sqrt 27)**(2/3) - 5:: CReal
07:50:18 <Silvah> No lambdabot...
07:50:25 <Axman6> i don't get how i could possible be returning [[(Char,t)]]
07:50:33 <Axman6> uh
07:50:52 <Axman6> uh, [[(Char,Int)]]
07:51:30 <tromp> is CReal on hackage?
07:51:42 <Axman6> yes, in the numbers package i think
07:51:44 <edwardk> Axman6: you can also replace the whole ST array machinery with just a call to accumArray
07:51:44 <hpc> @hackage CReal
07:51:45 <dolio> Axman6: What's a CodeTree?
07:51:47 <edwardk> @type accumArray
07:52:02 <edwardk> gah
07:52:09 <edwardk> having no lambdabot is so weird ;)
07:52:18 <Axman6> where's it defined? i knew it exists, i just couldn't find it
07:52:18 <int-e> Data.Array.accumArray :: (GHC.Arr.Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> GHC.Arr.Array i e
07:52:26 <Axman6> ta
07:52:33 <EvanR-work> tensorpudding should serve as the emergency haskell implementation
07:52:49 <ezeike> I have a real simple problem cause I don't know haskell, can someone look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25599#a25599 please?
07:53:26 <Axman6> i think i want accum actually
07:53:57 <Axman6> or not
07:53:59 <edwardk> accumArray (\e _ -> e + 1) (minBound, maxBound) (map (\x -> (x,x)) str) -- or something like that
07:54:22 <edwardk> to be made smaller with appropriate combinators ;)
07:54:37 <Axman6> anyway, this isn;t solving my problem
07:54:42 <edwardk> sure
07:54:53 <tromp> cabal: Failed to parse package dependency: "Data.Number.CReal"
07:55:11 <Axman6> i beliee the code i have for making the array works fine
07:55:12 <dolio> CReal is in numbers.
07:55:14 <Axman6> beliee
07:55:23 <Axman6> tromp: did you install the numbers package?
07:55:23 <tromp> i got that from http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
07:55:39 <tromp> let me try that Axman6
07:56:24 <ksf> is frp by itself turing-complete?
07:56:28 <tromp> ok, working now
07:56:35 <quicksilver> Axman6: I don't see the problem immediate, either. Annotate some bits and pieces with exact types until you find it.
07:56:58 <Axman6> i do, i was using return where i shouldn't hae been -_-
07:57:02 <Axman6> too much c lately
07:57:39 <ksf> I mean, if you theoretically restrict the monad, functor etc. interface to only support wiring total functions to it, where then is the place of the whole system in the chomsky hierarchy?
07:57:48 <Axman6> Could not deduce (MArray a Int (ST s)) from the context () arising from a use of `writeArray' at huffmancodes.hs:77:24-53
07:57:51 <Axman6> wut? :(
07:58:14 <hpc> that's an error i haven't seen before...
07:58:28 <quicksilver> you will need to annotate the newArray call specifically
07:58:37 <quicksilver> newArray is overloaded, it can't guess what one you want.
07:58:47 <Axman6> ah
07:59:01 * edwardk just had the amusing idea to use Debug.SimpleReflect.Expr with the reverse and forward mode AD code. wow debugging just got easier
07:59:16 <tromp> hmm, 1+2**(-134)-1 :: CReal gives me 0.0
07:59:32 <edwardk> Prelude Debug.SimpleReflect Numeric.FAD> diff exp x     ==> 1 * exp x
07:59:33 <quicksilver> tromp: yes, CReal's show instance is approximate.
07:59:43 <tromp> ic
07:59:55 <quicksilver> tromp: you can explicitly calculate to more figures if you want
08:00:00 <quicksilver> using showCReal, perhaps?
08:00:39 <quicksilver> > 134 / (log 10 / log 2)
08:01:09 <quicksilver> you probably need a little over 50 places to see it.
08:01:31 <quicksilver> sorry, a little over 40.
08:01:31 <tromp> also, 1+2**(-134)-1 == (0 :: CReal) shows False
08:01:45 <tromp> so that way you can see if answer is precise
08:01:53 <quicksilver> == is approximate as well AFAIK
08:02:04 <quicksilver> but perhaps operates to a higher precision than the default show instance.
08:02:20 <tromp> == better be precise
08:02:21 <Axman6> whoot, it loaded!
08:02:24 <burp> might be that (==) for CReal doesn't terminate
08:02:33 <tromp> that wld be acceptable
08:02:35 <dolio> (==) cannot be precise.
08:02:47 <quicksilver> it could be precise, but non-terminating.
08:02:51 <tromp> but if it returns True, i want it to be right
08:02:54 <quicksilver> or approximate, but terminating.
08:02:58 <tromp> not approximate
08:03:06 <burp> I don't think it's approximate
08:03:06 <quicksilver> well, you just carry on wanting.
08:03:07 <dolio> If you want it to be precise, it will never return True.
08:03:10 <edwardk> burp: (==) on CReal stops at 40 digits or so
08:03:10 <quicksilver> but that isn't what you have.
08:03:15 <quicksilver> burp: it is.
08:03:19 <burp> edwardk: hm I see
08:03:20 <burp> ok
08:03:28 <quicksilver> CReal comes with an approximate ==, which always terminates.
08:03:59 <tromp> so i cannot use CReal to check that (sqrt 28+sqrt 27)**(2/3) + (sqrt 28-sqrt 27)**(2/3) == 5 ?
08:04:48 <Axman6> no
08:05:01 <Axman6> though, you can show it to hundreds of decimal places
08:05:05 <quicksilver> tromp: no, it's computable real arithmetic not symbolic logic.
08:05:27 <Axman6> > 1+1
08:05:34 <lambdabot>   2
08:05:34 <Axman6> lambdabot!
08:05:37 <Axman6> thank you
08:05:42 <Cale> :)
08:05:46 <Axman6> ta Cale
08:06:05 <quicksilver> computable reals are about doing calculations to arbitrary - but chosen - precision.
08:06:06 <Axman6> hmm, she't not in #macosx anymore
08:06:17 <dolio> > let x :: Natural ; x = 1 + x in x > 5
08:06:24 <lambdabot>   Not in scope: type constructor or class `Natural'
08:07:18 <Axman6> Nat i think
08:07:27 <dolio> You could (possibly) prove that that equation is true using computable reals, if your language allowed for reasoning about your programs.
08:07:38 <Axman6> > let x :: Nat ; x = 1 + x in x > 5
08:07:44 <dolio> But it's not decidable.
08:07:46 <lambdabot>   Not in scope: type constructor or class `Nat'
08:07:47 <Cale> If we can decide which implementation of Natural we want, I can plug that module back in :)
08:08:04 <dolio> @kind Natural
08:08:05 <lambdabot>     Not in scope: type constructor or class `Natural'
08:08:15 <dolio> Oh, you got rid of it there.
08:08:22 <dolio> What options are there?
08:08:26 <hpc> > let x = 1+x in x > 5
08:08:30 <lambdabot>   mueval-core: Time limit exceeded
08:08:53 <Cale> There's the package nat with Data.Number.Nat
08:09:08 <Axman6> what sort of data compresses well using huffman codes?
08:09:19 <Cale> and numbers, with Data.Number.Natural
08:09:20 <dolio> Text.
08:09:28 <hpc> anything with a small dictionary
08:09:56 <Cale> anything where you have a good idea of the probability of any given symbol ;)
08:10:00 <Axman6> i'm wondering if say logs are something that compresses well
08:10:10 <hpc> IRC logs?
08:10:18 <Axman6> not so much
08:10:32 <Axman6> things like systems logs with time stamps etc
08:10:36 <hpc> ah
08:10:55 <Cale> Those are generally very compressible, with lots of repetition.
08:11:00 <Axman6> yeah
08:11:49 <Silvah> :)
08:11:56 <Silvah> configure succeeded
08:12:01 <Axman6> i think i'd need to make my program take advantage of symbold > 1 char
08:12:24 <Axman6> symbols*
08:13:54 <Axman6> bloody hell, this ST version is insanely slow
08:13:59 <dolio> Cale: Data.Number.Nat seems like it wouldn't work well if you wanted to do cute infinite stuff.
08:14:13 <dolio> I think 'x = 1 + x' would fail to terminate.
08:14:23 <Silvah> Moreover, make didn't fail yet!
08:14:40 <Cale> Silvah: What are you building?
08:14:47 <Silvah> GHC HEAD with LLVM CG.
08:14:50 <Cale> ah
08:15:06 <Cale> Yeah, compiling GHC takes forever
08:15:17 <EvanR-work> is there a way to read a record syntax data structure and use defaults for the missing records (instead of undefined)
08:15:18 <Silvah> Especially under Windows ;)
08:17:50 <Choko> v
08:17:56 <Cale> EvanR-work: I think that's unfortunately difficult... I wonder if this isn't a reasonable place to use 'spoon'
08:17:59 <Choko> :\
08:18:05 <EvanR-work> Cale: gah
08:18:29 <EvanR-work> well im making a custom Read instance
08:18:45 <EvanR-work> wait thats going to suck
08:18:50 <EvanR-work> gah
08:19:23 <Cale> If you go that way, it's probably a good idea to use something like ReadP or Parsec to make the instance, rather than writing it directly.
08:19:33 <Axman6> anyone got any thoughts on the show instance for my CodeTree? (here shows with the output of a ~5000 character sequence of text) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25600#a25600
08:19:54 <Cale> (ReadP has that nice  readP_to_S  function)
08:19:57 <dolio> Cale: Anyhow, I vote numbers.
08:20:03 <Cale> dolio: okay :)
08:20:07 <EvanR-work> i havent learned that yet :(
08:20:16 <EvanR-work> guess i should at some point
08:20:31 <Axman6> the numbers in <<>>'s are how many codes use that prefix, and the => 'x' (n) gives the code and the frequency of each character
08:20:37 <dolio> Cale: Maybe people would like nat to play with 2-adic numbers, though.
08:20:46 <dolio> Since that's what it seems to be.
08:20:58 <quicksilver> Axman6: that's not a show instance. That's a pretty printer.
08:21:05 <quicksilver> Axman6: </pedant>
08:21:09 <dolio> Well, sort of, I guess. It has an explicit 0 as well.
08:21:19 <dolio> And finite numbers, in addition to 2-adic numbers.
08:21:31 <Olathe> Are there any libraries for doing things with the tail end of a list (drop, take, dropWhile, etc.) ?
08:21:32 <Axman6> yeah, but that's how it want it to be shown when it's.. shown...
08:21:47 <EvanR-work> Olathe: reverse ;)
08:21:57 <Cale> Olathe: reverse the list first, and reverse again at the end
08:22:03 <Jafet> Axman, burrows-wheeler, range coding and Lempel-Ziv are standard
08:22:07 <Olathe> Ahh, that's the standard way ? OK :)
08:22:11 <quicksilver> Axman6: The 'Show' class is to product valid haskell syntax which can be copy-pasted into program code, such as a test case.
08:22:23 <quicksilver> Axman6: a convenient readable representation is something else.
08:22:33 <Cale> Olathe: Lists are picky about what order you access them, and the tail end is just the wrong end to access them from
08:22:47 <Jafet> Huffman code is really for pedagogical purposes, for specialized data distribution, or because you lived in 1997 with Unisys.
08:23:11 <Cale> (For some purposes, you might think of lists as being like stacks, with the beginning at the top of the stack)
08:23:14 <Jafet> :t (reverse.).(.reverse)
08:23:16 <lambdabot> forall a a1. ([a1] -> [a]) -> [a1] -> [a]
08:23:34 <quicksilver> Axman6: however, that is a very nice visualisation of coding :)
08:23:52 <Axman6> quicksilver: ywah, i found it by accident :)
08:23:54 <EvanR-work> Olathe: Data.Sequence is pretty nice
08:24:01 <Axman6> but it makes the concept quite clear
08:24:04 <EvanR-work> it likes it from both ends
08:24:33 <Cale> Though that's not quite it, because you typically create lists in left-to-right order as well.
08:25:12 <Olathe> EvanR-work: Ahh, thanks :)
08:27:55 <sepp2k> Cale: Huh? That's exactly it. If you define push = (:), pop = tail and top = head, you do exactly have a (persistent) stack.
08:27:57 <Cale> Yeah, basically, if you need any access pattern other than linear or stack-like, you probably want something other than lists :)
08:28:10 <Cale> sepp2k: That's just not the whole story.
08:28:50 <Cale> sepp2k: Laziness means that one thing can be creating the 'bottom' of your stack as another is popping elements off the top.
08:28:54 <Twey> Olathe: If you're doing it a lot, you should consider a different data-structure (Data.Sequence, perhaps)
08:29:53 <Olathe> I need to clear a few stores off the end of a program (dropWhile kind of thing).
08:31:12 <Silvah> :)
08:31:33 <Silvah> Stage 1 has been built successfully :)
08:40:16 <forrest> looks like http://www.realworldhaskell.org/ is down
08:46:37 <heropass> @wn real
08:46:39 <lambdabot> *** "real" wn "WordNet (r) 2.0"
08:46:39 <lambdabot> real
08:46:39 <lambdabot>      adj 1: being or occurring in fact or actuality; having verified
08:46:39 <lambdabot>             existence; not illusory; "real objects"; "real people;
08:46:39 <lambdabot>             not ghosts"; "a film based on real life"; "a real
08:46:41 <lambdabot> [41 @more lines]
08:46:44 <EvanR-work> is there a function for case e of [] -> value; other -> other
08:46:53 <EvanR-work> like 'fromMaybe' for lists
08:47:27 <EvanR-work> this is to cope with the null case of transpose
08:48:18 <gwern> @hoogle a -> [a] -> a
08:48:18 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
08:48:19 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
08:48:19 <lambdabot> Prelude asTypeOf :: a -> a -> a
08:49:22 <EvanR-work> case transpose foo of [] -> [[], []]; x -> x
08:52:51 <heropass> @wn foo
08:52:52 <lambdabot> No match for "foo".
08:53:12 <Olathe> @hoogle MonadPlus
08:53:13 <lambdabot> Control.Monad class Monad m => MonadPlus m
08:54:23 <Olathe> EvanR-work: (if null xs then value else xs)
08:54:42 <Olathe> EvanR-work: (\xs -> if null xs then value else xs)
08:54:57 <EvanR-work> yes writing the function myself is an option
08:55:03 <Choko> is it possible to take a instance and then only overload a specific function the instance defines
08:55:19 <Olathe> @hoogle [a] -> [a] -> [a]
08:55:20 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
08:55:20 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
08:55:20 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
08:56:37 <Silvah> @pl (\s -> nextnum (snd (bounds ys) - 1) >>= flip evalValue xs . (ys !))
08:56:38 <lambdabot> const (flip evalValue xs . (ys !) =<< nextnum (snd (bounds ys) - 1))
08:56:50 <Silvah> @pl (\ys -> nextnum (snd (bounds ys) - 1) >>= flip evalValue xs . (ys !))
08:56:50 <lambdabot> ap ((>>=) . nextnum . subtract 1 . snd . bounds) ((flip evalValue xs .) . (!))
08:57:45 <Silvah> @unpl ap ((>>=) . nextnum . subtract 1 . snd . bounds) ((flip evalValue xs .) . (!))
08:57:46 <lambdabot> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ m -> (>>=) (nextnum (subtract 1 (snd (bounds m))))) (\ y aa -> evalValue (y ! aa) xs)
08:57:59 <hpc> lol
08:58:02 <Silvah> Oh, neat.
09:00:49 * hackagebot timezone-series 0.1.0 - Enhanced timezone handling for Data.Time  http://hackage.haskell.org/package/timezone-series-0.1.0 (YitzGale)
09:01:49 <Olathe> @hoogle mkStdGen
09:01:50 <lambdabot> System.Random mkStdGen :: Int -> StdGen
09:02:50 * hackagebot timezone-olson 0.1.0 - A pure Haskell parser and renderer for binary Olson timezone files  http://hackage.haskell.org/package/timezone-olson-0.1.0 (YitzGale)
09:03:23 <Silvah> @. unpl pl \memory value -> readIORef (pointer memory) >>= \x -> unsafeWrite (array memory) x value >> return memory
09:03:23 <lambdabot> ((\ w b c -> (readIORef (pointer w)) >>= (b c)) >>= \ p -> ((\ al e f i -> (unsafeWrite (array al) i f) >> e) >>= \ ae -> return >>= \ ad -> return (ae ad)) >>= \ o -> return (p o))
09:03:40 <Silvah> ^^
09:03:41 <dschoepe> Choko: the easiest way to do this, is to define a newtype that contains value of the old type and then defining a new instance for that type
09:03:51 <Silvah> @pl \memory value -> readIORef (pointer memory) >>= \x -> unsafeWrite (array memory) x value >> return memory
09:03:51 <lambdabot> ap ((.) . (>>=) . readIORef . pointer) (ap (flip . ((flip . ((>>) .)) .) . flip . unsafeWrite . array) return)
09:04:52 <jmcarthur> it finally occurred to me this morning that writing a function over streams (as in stream fusion, not as in Cofree Identity) is basically the same as writing a stateful loop, and that composition of stream functions combines the states and creates a new function to loop over that works on the new state type
09:05:03 <Choko> dschoepe: I hoped for a more elegant solution
09:05:43 <Choko> dschoepe: I will have to make instances for the newtype for all the other things the old type has
09:05:47 <Choko> had!
09:07:59 <edwardk> jmcarthur: sounds about right
09:07:59 <jmcarthur> so i'm thinking stream fusion looks like the ideal implementation for my DCTP library. for a game, it would literally compile down to a game state and a function representing a transformation of that state given user inputs
09:08:13 <edwardk> DCTP?
09:08:32 <jmcarthur> edwardk: new term coined for me to use in place of FRP: Denotative Continuous-Time Programming
09:08:38 <edwardk> ah
09:08:49 <jmcarthur> a more fitting description for what i want it to be, IMO
09:08:55 <jmcarthur> and conal approves, so i'm running with it ;)
09:09:29 <edwardk> heh
09:09:50 <edwardk> i suppose denotative is more connotative of what you want ;)
09:10:44 <jmcarthur> ha
09:11:08 <BMeph> Did anyone ever point jkiingkong at Rich Hickey's Value-Identity-State video?
09:11:17 <edwardk> did you see the recent paper on type checking continuity?
09:11:27 <jmcarthur> edwardk: no, but it sounds interesting
09:11:47 <jmcarthur> brb
09:11:58 <Phyx-> Hi, does anyone know how to stop the GHC api from writing errors to stderr when something fails? I'm using handleSourceError to handle the errors in a manner that I want but it still insists somewhere on printing them
09:12:03 <edwardk> jmcarthur: trying to find it
09:12:06 <Silvah> Hahaha, I was right!
09:12:12 <Olathe> @hoogle a -> Maybe a -> Maybe a
09:12:13 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
09:12:13 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
09:12:13 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
09:12:17 <Silvah> GHC failed to build!
09:12:52 <Olathe> @src orElse
09:12:52 <lambdabot> Source not found. You type like i drive.
09:13:31 <Olathe> > (Maybe 5 <|> Maybe 6, Maybe 5 <|> Nothing, Nothing <|> Maybe 6)
09:13:32 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe...
09:14:00 <Olathe> > (Just 5 <|> Just 6, Just 5 <|> Nothing, Nothing <|> Just 6)
09:14:02 <lambdabot>   (Just 5,Just 5,Just 6)
09:14:54 <siracusa> What could cause a `darcs failed: fromSlurpFile: Couldn't find file "./gtk/Graphics/UI/Gtk.chs"" where the file is obviously there?
09:14:54 <unperson> hi! what do you think is the best book/tutorial for someone who is completely new to programming and would like to learn Haskell?
09:15:16 <edwardk> unperson: learn you a haskell
09:15:42 <edwardk> http://learnyouahaskell.com/
09:16:29 <unperson> thanks
09:17:11 <edwardk> that should be coming out (with new chapters) in dead tree form soon
09:17:18 <unperson> any reason you reccomend this over the others?
09:17:35 <quicksilver> edwardk: that's cool, I didn't know that.
09:17:43 <hpc> unperson: it is really easy to read
09:18:12 <edwardk> unperson: BONUS goes out of his way to make it fun to read and to be light on the heady computer science side of things and take people by the hand
09:18:45 <unperson> great, sounds like just what I'm looking for
09:19:03 <edwardk> quicksilver: yeah he's had a publishing deal for months now. its one of the reasons why the site hasn't been updated much lately. he needs to backport a lot of the fixes for the paper version to the site
09:19:15 <BMeph> edwardk: Is http://www.cse.psu.edu/~lubliner/papers/continuity.pdf that paper you were asking jmcarthur about?
09:19:20 <Silvah> :t (>>=)
09:19:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:19:22 <Silvah> :t (<<=)
09:19:23 <lambdabot> Not in scope: `<<='
09:19:26 <Silvah> :t (=<<)
09:19:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:19:32 <edwardk> BMeph: checking
09:19:32 <Silvah> :t (.)
09:19:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:19:53 <Silvah> :t Prelude.(.)
09:19:54 <lambdabot> Not in scope: data constructor `Prelude'
09:20:04 <edwardk> BMeph: looks like it
09:20:14 <edwardk> i can't connect but the names are right ;)
09:23:19 <BMeph> edwardk: Okay, good - I'll put it on my "Things to Read" stack as well.
09:23:35 <monochrom> > [2,3] <|> [4,5]
09:23:36 <lambdabot>   [2,3,4,5]
09:23:43 <jmcarthur> sweet thanks!
09:23:54 <Phyx-> bleh
09:23:56 <hpc> @src (<|>) :: [a]
09:23:57 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:24:50 <edwardk> BMeph: jbapple sent it my way the other day in light of my current automatic differentiation kick and i was greatly amused
09:25:59 <jmcarthur> edwardk: "We present an analysis to automatically determine if a program represents a continuous function, or equivalently, if infinitesimal changes to its inputs can only cause infinitesimal changes to its outputs."  <-- does that look like to you?
09:26:07 <edwardk> jmcarthur: yeah
09:26:10 <jmcarthur> sweet
09:26:29 * edwardk now needs to code something to do algebraic simplification.
09:26:41 <Silvah> @src [] (<|>)
09:26:41 <lambdabot> (<|>) = (++)
09:27:15 <edwardk> Prelude Debug.SimpleReflect Numeric.RAD> diff (\x -> x * sin (cos x)) x  yields 0 + (0 + sin (cos x) * 1 + negate (sin x) * (0 + cos (cos x) * (0 + x * 1))) -- which would be nicer if all those 0's went away
09:27:36 <jmcarthur> although this seems somewhat irrelevant for me at this moment. i'm approximating continuity in the name of practicality. i'm just using a continuous model
09:28:30 <edwardk> jmcarthur: sure, my first knee jerk thought was that one could try to define a set of combinators to emulate that analysis, but it doesn't look possible
09:28:30 <hpc> edwardk: i have actually been working on the same problem
09:28:42 <edwardk> hpc: oh?
09:28:54 <hpc> for my irc bot; lemme upload a tar
09:28:56 <jmcarthur> plus their definition of continuity doesn't seem to apply to my generalized integration idea
09:29:05 <edwardk> jmcarthur: *nods*
09:29:07 <jmcarthur> or at least doesn't seem relevant to it
09:29:07 <hpc> http://dl.dropbox.com/u/37707/Data/Data.tar.gz
09:29:34 <edwardk> hpc: which module?
09:29:41 <hpc> Math/Simplify
09:29:52 <jmcarthur> they are focusing on R -> R, if my quick skim of it indicates the intent correctly
09:29:59 <hpc> the data declaration is in Math/MathUtil
09:30:05 <edwardk> i have FoldingAtHome.hs Help.hs Identify.hs Macro Main Wishlist and thats it
09:30:08 <edwardk> wrng tar?
09:30:10 <edwardk> er wrong
09:30:13 <hpc> crap
09:30:46 <edwardk> hpc: do you observe sharing in the type or just print it as a tree?
09:30:55 <jmcarthur> not very useful to try to apply to R -> Bool, which must be discontinuous if it's not simply constant
09:31:01 <edwardk> i need to retain sharing, so i'll probably go through data-reify
09:31:07 <hpc> i use a tree
09:31:17 <edwardk> hpc: *nods*
09:31:28 <edwardk> i think lennart went through all of this a while back now that i think on it
09:31:44 <hpc> i messed up my tar script
09:32:18 <hpc> http://dl.dropbox.com/u/37707/MathUtil.hs
09:32:24 <hpc> http://dl.dropbox.com/u/37707/Simplify.hs
09:33:15 <edwardk> hpc: i'm doing all of mine via Num instances etc. so I can actually have a tree/graph to reconstruct.
09:33:24 <edwardk> have you read andy gill's paper on kansas lava?
09:33:30 <hpc> no
09:33:39 <quicksilver> edwardk: cool
09:33:52 <edwardk> hpc: http://www.ittc.ku.edu/~andygill/papers/reifyGraph.pdf
09:34:22 <edwardk> check his final examples of using it to observe functions
09:34:41 <edwardk> the same can be done with a Num instance
09:35:19 <hpc> cool
09:36:04 <BMeph> jmcarthur: Which reminds me: have you checked out Dave Barbour's c2wiki article on his take on FRP - hmm, never mind, someone wiped out the article last week, odd...
09:36:33 <jmcarthur> maybe there is a google cache or archive.org of it?
09:36:37 <jmcarthur> what was the url?
09:37:01 <shapr> Is there a Haskell lib for the google maps API?
09:37:11 <edwardk> i'm still looking for an FRP without a global clock
09:37:32 <edwardk> shapr: i don't know of one
09:37:58 <jmcarthur> edwardk: the speed of mine will be driven from the top level
09:38:35 <edwardk> jmcarthur: *nods* i've just been trying to figure out how to parameterize one nicely over a given causal domain, so that you get more freedom in ordering events and handling stuff in parallel
09:38:45 <shapr> I can't find any such library either.
09:39:23 <jmcarthur> edwardk: but probably the adapters will use a global clock of some sort, so the end result of pulling slower would be a space leak, and pulling faster just can't happen
09:39:29 <edwardk> one of my motivations for playing with AD was so i could use it in an FRP-like setting, to evaluate signposts and update them using their derivatives
09:39:31 <babusri> Can someone give a simple example of vector package, where a mutable array of Word8 is used and an array value is changed in place. http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial doesn't have a simple example.
09:40:33 <EvanR-work> erm how do i f . g . h $ x y, where h takes two parameters
09:40:37 <jmcarthur> edwardk: i'll expose primitives that are agnostic to the type of time, but of course if somebody wants to use those them they will have to write their own adapters and samplers
09:40:49 <edwardk> but for that i want a good interval arithmetic library and some continuity conditions that let me know that i can use that to progressively refine where phase transitions occur
09:40:57 <sbahra> EvanR, f .g . h x $ y
09:41:00 <jmcarthur> edwardk: that is, they will be exposed in an .Internals modules
09:41:02 <xezz> @src |
09:41:03 <jmcarthur> *module
09:41:03 <lambdabot> Source not found. Sorry.
09:41:05 <edwardk> jmcarthur: *nods*
09:41:09 <sbahra> :t (.)
09:41:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:41:15 <EvanR-work> sbahra: ah
09:41:36 <edwardk> xezz | isn't a function it is syntax
09:42:11 <xezz> ah can u tell me what it means in this context? satisfy p (x:xs) = [(xs,x) | p x] ?
09:43:08 <edwardk> did you shorten the example?
09:43:18 <Silvah> It's list comprehension.
09:43:24 <xezz> satisfy :: (s -> Bool) -> Parser s s
09:43:24 <xezz> satisfy p [] = []
09:43:25 <xezz> satisfy p (x:xs) = [(xs,x) | p x]
09:43:34 <Silvah> The any of many thing that I don't understand.
09:43:40 <Silvah> s/any/one/
09:43:46 <xezz> thats the full..
09:43:48 <Silvah> things*
09:44:02 <edwardk> > [ 1 | True ]
09:44:03 <lambdabot>   [1]
09:44:11 <edwardk> > [ 1 | False ]
09:44:12 <lambdabot>   []
09:44:34 <edwardk> > [ x * 2 | x <- [1.. 10]
09:44:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:44:38 <xezz> so this (xs, x) is a bool oO?
09:44:40 <edwardk> > [ x * 2 | x <- [1.. 10] ]
09:44:41 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
09:45:00 <edwardk> > [ x * 2 | x <- [1..10], x `mod` 2 == 0 ]
09:45:01 <lambdabot>   [4,8,12,16,20]
09:45:22 <quicksilver> that's an obfuscated way of writing if p x then [(xs,x)] else []
09:45:55 <edwardk> a list comprehension consists of two kinds of things (in haskell 98) you have filters, and inputs. x <- xs .. draws elements x from the list xs.
09:46:07 <edwardk> and anything that evaluates to a Bool is a filter
09:46:09 <edwardk> or guard
09:46:15 <edwardk> that eliminates elements from the result
09:46:25 <edwardk> everything to the left of the | is what is returned as the list elements in the resulting list
09:46:45 <BMeph> jmcarthur: Ah, good call; the Google cache is from May 7, and it got wiped on the 10th. Here's the (bit.ly-fied) link: http://bit.ly/9KaSc9
09:46:54 <edwardk> > [ foo | bar ] -- checks the condition bar, and returns either [foo] or [] based on whether bar evaluates to True or False
09:46:55 <lambdabot>   Not in scope: `bar'Not in scope: `foo'
09:46:59 <jmcarthur> BMeph: thanks
09:47:17 <xezz> ahh xD makes sense thx
09:47:47 <edwardk> though as quicksilver said, it is a particularly nasty way of specifying it ;)
09:48:06 <edwardk> i'd forgotten it was even legal to use a list comprehension with no inputs ;)
09:48:26 <k23z__> hey anyone up in this channel wanna write some Haskell and throw it all up on github ?
09:48:29 <dolio> It's an essential part of how they're defined.
09:48:58 <edwardk> k23z__: that is most of what we do around here. either github or patch-tag ;)
09:49:09 <dolio> The desugaring breaks things down into [ e | True ] in some cases.
09:49:14 <edwardk> dolio: *nods*
09:49:21 <edwardk> dolio: it makes sense from a base case perspective
09:49:27 <k23z__> yes well I need a sidekick
09:49:34 <k23z__> to write some Haskell code
09:49:36 <jmcarthur> > listToMaybe ["foo" | True]
09:49:37 <lambdabot>   Just "foo"
09:49:41 <jmcarthur> > listToMaybe ["foo" | False]
09:49:41 <lambdabot>   Nothing
09:49:54 <jmcarthur> nice
09:50:22 <edwardk> > let maybeToList x = [ fromJust x | isJust x ] in map maybeToList [Just 12, Nothing]
09:50:23 <lambdabot>   [[12],[]]
09:51:00 <edwardk> cute
09:51:05 <soupdragon> [ fromJust x | isJust x ] <---- what??
09:51:13 <BMeph> jmcarthur: Sure. It seems orthogonal, but it piqued my interest to see a fusion of FRP with constraints and capabilities. I wouldn't have thought thought of capabilities, but it seems like a fascinating use case.
09:51:16 <edwardk> soupdragon: scroll back ;)
09:51:20 <soupdragon> oh it's a single element
09:51:26 <soupdragon> I thought x was a list
09:51:35 <edwardk> nah x is the Maybe
09:51:40 <jmcarthur> BMeph: yes it does seem an interesting idea
09:51:54 <jmcarthur> i can't say i fully understand the proposed abstraction yet
09:52:25 <edwardk> BMeph: as in an FRP using the e-Rights framework or something?
09:53:07 <jmcarthur> it kind of looks like using FRP with constraints among behaviors and letting it run to a steady state or something
09:53:28 <BMeph> length xs = [1| x <- xs] -- does this blow your mind? ;)
09:53:38 <edwardk> one thing i like about arrow based frp is you can introspect the arrows to get a feel for what can flow into what for use in breaking up tasks and doing stuff in parallel.
09:54:32 <jmcarthur> edwardk: by "in parallel" you mean "concurrently"?
09:54:32 <tromp> @src length
09:54:33 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:54:40 <edwardk> you might want a 'sum' on that BMeph ;)
09:55:00 <BMeph> edwardk: I'm totally talking out of my hat here, but it looks more suggestive of using FRP _as_ an e-Rights framework (among other things).
09:55:41 <BMeph> edwardk: (about the "length" exercise:) Ooh, right you are.
09:56:03 <edwardk> jmcarthur: probably =)
09:56:08 <BMeph> length xs = sum [1| x <- xs] -- meant to write this
09:56:51 <edwardk> that might be a slightly expensive given that sum is lazy no?
09:57:56 <BMeph> edwardk: I meant it more as an illustration of the comprehension stuff earlier, than as a serious (or even semi-serious) replacement for length.
09:58:34 <BMeph> edwardk: But, to answer the question, yes, it'd be hideously resource-gobbling.
09:59:48 <scree> in what sense is sum lazy?
10:01:16 <Olathe> Wow. Using Just (fromMaybe xs (f xs)) is a LOT faster in ghci than let q = f xs in case q of; Nothing -> Just xs; Just _ -> q.
10:01:20 <jmcarthur> scree: in that it uses foldl, is what i think they mean
10:01:24 <tromp> @let len = foldr (const succ) 0
10:01:24 <jmcarthur> @src sum
10:01:24 <lambdabot> sum = foldl (+) 0
10:01:25 <lambdabot>  Defined.
10:01:42 <tromp> > len "hello"
10:01:44 <lambdabot>   5
10:02:03 <jmcarthur> scree: instead of foldl' i mean
10:02:07 <dolio> Olathe: How can you tell?
10:02:13 <scree> the compiler will make it strict though won't it?
10:02:26 <jmcarthur> scree: with optimizations
10:02:31 <Olathe> dolio: One sec
10:02:35 <scree> jmcarthur: right
10:02:43 <jmcarthur> also only for certain types
10:02:59 <scree> I never worked out why it's defined that way
10:03:35 <jmcarthur> scree: foldl' is not haskell98
10:03:39 <jmcarthur> that's why
10:05:04 <scree> how strange
10:05:16 <scree> so ... we can change the List module from the report, but not the standard prelude?
10:05:34 <dolio> List hasn't been changed.
10:05:35 <aristid> @src foldl'
10:05:36 <lambdabot> foldl' f a []     = a
10:05:36 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:05:48 <jmcarthur> scree: Data.List is not defined in the report
10:06:13 <scree> ah, Data.List /= List
10:06:15 <scree> I see
10:06:41 <dolio> Prelude is one of the few H98 modules people actually use.
10:06:52 <edwardk> hrmm what blas bindings are there for haskell?
10:06:52 <Olathe> dolio: Load http://codepad.org/M6wbcJMl and do foldr (+) 0 . tailTakeWhile (>500000) $ [1..1000000] and foldr (+) 0 . tailTakeWhile2 (>500000) $ [1..1000000]
10:06:53 <BMeph> edwardk: Oh, are you going to update monoids, or just rewrite it in a couple of months? ;)
10:07:20 <Olathe> dolio: Here, the first takes around 6.3 seconds, the second takes around 26 seconds.
10:07:32 <jmcarthur> edwardk: hmatrix is all i know
10:07:38 <edwardk> BMeph: i consider version 0.1.36 to be the better version of monoids, i'll likely roll out a patch that integrates the improvements from 0.2.x into the 0.1.36 tree
10:08:00 <edwardk> jmcarthur: i found 'blas' but it doesn't suit my needs (Vectors are not Traversable or Foldable, etc)
10:08:03 <jmcarthur> awesome. i missed the stuff you took out in 0.2
10:08:28 <edwardk> and hmatrix has an unfortunately license that prevents my use
10:08:48 <jmcarthur> wow, GPL
10:08:52 <jmcarthur> i didn't even realize that
10:09:53 <edwardk> and there is hblas, but that doesn't appear to be on hackage
10:10:11 * hackagebot wumpus-core 0.18.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.18.0 (StephenTetley)
10:10:30 <dolio> Olathe: Oh, this may not be surprising.
10:10:33 <edwardk> i found a nice paper on how well it works to do AD over matrices rather than within matrices and wanted to try it out
10:10:53 <Olathe> dolio: Do you have an idea why that happens ?
10:11:27 <dolio> Olathe: I'm not 100% sure. However, the first one yields a Just without inspecting the result of handle xs.
10:11:51 <dolio> Olathe: The second has to inspect 'handle xs' before yielding a constructor, despite the fact that that constructor is always Just.
10:13:19 <Olathe> Ahh, OK. Thanks :)
10:14:17 <Olathe> I think that will help quite a bit with optimizations.
10:19:25 <jmcarthur> edwardk: that sounds very interesting
10:20:16 <edwardk> jmcarthur: hence my inquiry regarding blas bindings, etc. taylor series of matrices rather than matrices of taylor series lets me use standard libraries
10:20:29 <jmcarthur> yeah
10:20:31 <jmcarthur> that would be handy
10:23:22 <vitka_> @hoogle f (a,b) = (f a,f b)
10:23:22 <lambdabot> Parse error:
10:23:22 <lambdabot>   --count=20 "f (a,b) = (f a,f b)"
10:23:22 <lambdabot>                      ^
10:23:32 <vitka_> @hoogle (f a,f b)
10:23:32 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
10:23:33 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
10:23:33 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
10:25:30 <vitka_> @hoogle on
10:25:30 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:25:31 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
10:25:31 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
10:25:37 <vitka_> @src on
10:25:37 <lambdabot> (*) `on` f = \x y -> f x * f y
10:31:41 <vitka_> @pl \(a,b) -> g (f a) (f b)
10:31:41 <lambdabot> uncurry ((. f) . g . f)
10:32:00 <vitka_> @pl \a b -> g (f a) (f b)
10:32:00 <lambdabot> (. f) . g . f
10:32:38 <hpc> :t uncurry
10:32:40 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:32:56 <hpc> :t curry
10:32:58 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:35:11 <vitka_> > \(a,b) -> g `on` f (a,b)
10:35:12 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:35:13 <lambdabot>    `GHC.Show.Show b'
10:35:13 <lambdabot>      a...
10:35:18 <dolio> "From the computing science point of view, category theory is a very strongly typed language, more strongly typed than any computer language."
10:35:31 <soupdragon> doesn't make sense dolio
10:35:38 <soupdragon> is that from category theory for computer science
10:36:01 <soupdragon> I can remember reading that somewhere, but not where
10:36:02 <dolio> It's from the Barr & Wells lecture notes.
10:36:21 <soupdragon> it is meaningful/
10:36:22 <soupdragon> ?
10:36:27 <soupdragon> I could not decide what was meant by it
10:36:30 <dolio> Obviously they haven't seen all computer languages.
10:36:37 <hpc> heh
10:36:47 <soupdragon> well they do know about e.g. dependently typed formalizations of category theory
10:37:01 <soupdragon> which is why it is such a puzzling statement
10:38:23 <dolio> Technically even in dependent type theory you probably wouldn't do what they were just talking about: having a type NonZeroReals in addition to Reals.
10:39:04 <dolio> But that's because there are better ways to accomplish the same thing.
10:39:51 <Cale> http://jayisgames.com/games/manufactoria/ -- fun :)
10:45:32 <monochrom> complete the circle. make category theory a computer language.
10:46:04 <monochrom> (indeed, any type-0 language is a computer language)
10:47:02 <monochrom> therefore category theory is more strongly typed than category theory.
10:47:47 <monochrom> The authors have not seen logical contradictions and/or Chomsky's language theory.
10:49:57 <Olathe> How do I compile a library (no main function) ?
10:50:38 <monochrom> perhaps cabalize it if it is large. perhaps ghc -c if it is small
10:51:30 <Olathe> If I do ghc -c, I still get The function `main' is not defined in module `Main'
10:51:45 <monochrom> I don't.
10:52:40 <Olathe> Ahh, it appears that putting module Whatever where at the top solves it.
10:53:21 <monochrom> "library" implies you say "module Whatever"
10:53:43 <jpcooper> Cale, it reminds me a bit of Chip's Challenge
10:53:55 <monochrom> (like, how else do we know module names in your library?)
10:53:58 <Berengal> No module declaration implies module Main, which implies executable program
10:54:13 <Olathe> Ahh, OK
10:54:39 <monochrom> the lack of fairly basic logic in most people's minds is appalling.
10:55:42 <monochrom> "hi I just bought an electic guitar but it make no sound"  "oh giving it electricity solves it"
10:57:08 <jmcarthur> monochrom: i am no longer surprised by such things
10:57:10 <soupdragon> "Hi I just bought a dog but it has no nose" "how does it smell?" "terrible!"
10:57:18 <mm_freak> monochrom: ever used PHP?
10:57:29 <mm_freak> in "1" == "01" is TRUE!
10:57:35 <monochrom> or even better: "hi I have just completed a circuit of batteries and led, but the led doesn't light up"  "oh closing the circuit solves it!" --- excuse me, why do you say "complete" if it is not "closed"
10:58:39 <sm> gah.. my installation doc is trying to become a total cabal/hackage troubleshooting guide
10:59:02 <sm> and that's a very large topic
10:59:08 <jmcarthur> it seems to me that a lot of people are unable to make any association between "A implies B" and "A" in order to draw some sort of conclusion about B
10:59:47 <mm_freak> in fact, only few people understand implications at all =)
11:00:17 <jmcarthur> it gets especially bad if i have to make an argument that requires more than one logical implication
11:00:26 <jmcarthur> the intermediate facts get completely lost
11:01:05 <monochrom> people also get confused by ((a -> r) -> r) -> r
11:01:21 <jmcarthur> @pl ((a -> r) -> r) -> r
11:01:21 <lambdabot> (line 1, column 5):
11:01:21 <lambdabot> unexpected ">"
11:01:21 <lambdabot> expecting variable, "(", operator or ")"
11:01:23 <jmcarthur> oops
11:01:24 <jmcarthur> @djinn ((a -> r) -> r) -> r
11:01:25 <lambdabot> -- f cannot be realized.
11:01:32 <jmcarthur> djinn gets confused by it too
11:02:09 <aristid> @hoogle ((a -> r) -> r) -> r
11:02:10 <lambdabot> No results found
11:02:15 <franka> I don't think it is intuitionistically valid.
11:03:56 <monochrom> people also get confused by statements in general. i.e., when I say "((a -> r) -> r) -> r", people automatically believe I claim its truth or provability, forgetting that I could be just bringing it up as an object of study.
11:04:47 <jmcarthur> monochrom: yes! that really ticks me off when people do that
11:04:56 <applicative> sm, this is hledger?
11:05:20 <sm> applicative: yes it is
11:06:05 <applicative> sm, you mean you want your sensible ideas to be available to people who have spend a year or so studying Haskell?
11:06:06 <sm> I budgeted two hours this morning with great expectations, and "quick updates to install doc" is eating my morning >8-|
11:06:25 <applicative> sm, i mean, people who havent
11:06:26 <jmcarthur> often the conclusion of an argument i try to make takes the form (A -> B), but the person i'm talking to will take it to mean that i am arguing (A /\ B)
11:06:55 <sm> I'd like to make installing hledger as smooth and reliable as possible, even for non haskell/hackage experts, using cabal
11:07:12 <sm> there's a lot of ways it can go wrong
11:07:59 <gwern> really? how/
11:08:13 <gwern> I mean if you have cabal working at all a pure haskell thing ought to be pretty foolproof
11:08:22 <applicative> sm, yeah, there are increasingly many cool applications like this that could be useful to anyone.
11:08:49 <applicative> gwern, even something as simple as the Path variable has been known to kill a day or two for people trying to install pandoc
11:08:52 <sm> gwern: so many ways!
11:09:07 <sm> I'll try to wrap this up and update the page
11:10:33 <applicative> gwern, I think the first version of the Platform for OS X put ~/.cabal/bin in path
11:11:25 <gwern> hm. in the future, whenever I talk about anything, please append this disclaimer: 'none of this is guaranteed to hold true if you are working on Macs or Windows, and may god have mercy on your soul'
11:11:46 <FunctorSalad_> :)
11:11:53 <applicative> gwern, sm is not speaking only to people on OpenBSD
11:11:56 <applicative> or whatever
11:12:05 <gwern> ubuntu isn't *that* obscure
11:12:17 <monochrom>  /nick gwernNotNecessaryTrueForMacWindows
11:12:35 <gwern> (is that even a legal length?)
11:12:40 <monochrom> No.
11:12:47 <nefty> How long did it take you guys to get good at thinking about solving problems functionally, coming from imperative languages (as I assume most people learning haskell are familiar with)?
11:13:02 <hpc> nefty: not that long actually
11:13:22 <hpc> nefty: then again, i have a really strong math background
11:13:48 <applicative> nefty, what is the witticism about lisp -- it takes a day to learn, unless you've learned another programming language, then it takes a week...
11:13:56 <silver> nefty, ~time required to read half of SICP and make all the exercises along the way
11:14:12 <nefty> I just started haskell a few days ago, and I'm understanding the basics, but I'm having a hard time wrapping my mind around some things that would be trivial in e.g. C++, but I can't figure out for the life of me purely functionally
11:14:27 <applicative> nefty, what's an example
11:14:31 <nefty> I dunno
11:14:38 <silver> nefty, it's normal
11:14:47 <silver> try SICP srsly, it really helped me
11:14:51 <gwern> not knowing what you're trying to do is definitely an issue
11:15:04 <applicative> nefty, what are you reading to help
11:15:24 <Cale> nefty: What sort of things which would be trivial in C++?
11:15:30 <nefty> say I wanted to write a program that takes a text file and breaks it down into words and counts the frequency of each word, and prints a list that of the words ordered by freq.
11:15:38 <nefty> I'm reading learnyouahaskell.com
11:15:47 <applicative> nefty, :)
11:15:56 <nefty> just traversing lists like that
11:16:02 <silver> nested fors equivalent I bet
11:16:04 <applicative> nefty, he hasn't gotten to much IO
11:16:14 <BMeph> <opinion type="rant"> Ubuntu isn't that obscure. I simly deserves to be. </opinion> ;)
11:16:14 <nefty> I'm not used to using lots of recursion, heh
11:16:18 <Cale> > words "here is a bunch of words"
11:16:19 <lambdabot>   ["here","is","a","bunch","of","words"]
11:16:20 <FunctorSalad_> nefty: use Data.Map
11:16:24 <BMeph> *It
11:16:51 <applicative> FunctorSalad_, he started studying a few days ago.
11:16:56 <Cale> > M.fromListWith (+) . zip (repeat 1) $ words "here here here is is is a a a a bunch of of of words"
11:16:57 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
11:16:57 <lambdabot>    arising from a use of `GHC...
11:16:57 <FunctorSalad_> @ty insertWith
11:16:58 <lambdabot> Not in scope: `insertWith'
11:17:00 <nefty> yeah, I could figure out the IO stuff later, but I'm just trying to figure out how to do this without creating a variable and incrementing it
11:17:04 <Cale> > M.fromListWith (+) . flip zip (repeat 1) $ words "here here here is is is a a a a bunch of of of words"
11:17:06 <lambdabot>   fromList [("a",4),("bunch",1),("here",3),("is",3),("of",3),("words",1)]
11:17:10 <FunctorSalad_> @ty M.insertWith
11:17:11 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
11:17:15 <nefty> hmm
11:17:18 <Cale> > M.toList . M.fromListWith (+) . flip zip (repeat 1) $ words "here here here is is is a a a a bunch of of of words"
11:17:19 <lambdabot>   [("a",4),("bunch",1),("here",3),("is",3),("of",3),("words",1)]
11:17:28 <silver> @where sicp
11:17:29 <lambdabot> http://mitpress.mit.edu/sicp/
11:17:31 <soupdragon> > M.fromListWith (+) . flip zip (repeat 1) $ words "shall we suppose that all she knows is a rose is a rose is a rose is a rose"
11:17:32 <silver> >.>
11:17:33 <lambdabot>   fromList [("a",4),("all",1),("is",4),("knows",1),("rose",4),("shall",1),("s...
11:17:33 <nefty> I assumed there would be a lot of folds or something
11:17:37 <applicative> nefty, see you've come to the riht place...
11:17:42 <nefty> thanks guys, haha
11:17:44 <aristid> Cale: that's a very elegant solution but i guess nefty will have a hard time with it :)
11:17:47 <applicative> nefty, Cale is actually a bot
11:17:54 <nefty> okay
11:17:56 <mm_freak> nefty: your word counting program is a one-liner in haskell
11:17:57 <Cale> haha
11:18:03 * mreh unplugs Cale
11:18:04 <nefty> wow
11:18:26 <applicative> nefty, occasionally Cale throws in a type violation to seem more human
11:18:28 <Cale> nefty: Data.Map is a finite map/dictionary/what-have-you sort of data structure
11:18:41 <Cale> nefty: What we do is to pair each of the words in our list with the number 1
11:18:47 <Cale> > flip zip (repeat 1) $ words "here here here is is is a a a a bunch of of of words"
11:18:48 <lambdabot>   [("here",1),("here",1),("here",1),("is",1),("is",1),("is",1),("a",1),("a",1...
11:18:51 <Cale> like this
11:19:06 <Cale> and then insert them all into a map, adding on collision
11:19:18 <aristid> > group . sort . words $ "here here here is is is a a a a bunch of of of words"
11:19:20 <lambdabot>   [["a","a","a","a"],["bunch"],["here","here","here"],["is","is","is"],["of",...
11:19:20 <Cale> (which is what  M.insertWith (+)  does)
11:19:26 <nefty> okay, I think I'm still following
11:19:35 <applicative> nefty, I think the library comes with the platform, here's the hackage page http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Map.html
11:19:39 <Cale> > M.insertWith (+) . flip zip (repeat 1) $ words "here here here is is is a a a a bunch of of of words"
11:19:39 <lambdabot>   Overlapping instances for GHC.Show.Show
11:19:40 <lambdabot>                              (a
11:19:40 <lambdabot>    ...
11:19:49 <aristid> > map (\x -> (head x, length x)) . group . sort . words $ "here here here is is is a a a a bunch of of of words"
11:19:50 <Cale> er...
11:19:51 <lambdabot>   [("a",4),("bunch",1),("here",3),("is",3),("of",3),("words",1)]
11:20:10 <Cale> oh, tsk
11:20:11 <aristid> maybe my solution would be more easy to understand?
11:20:16 <Cale> M.fromListWith (+)  I meant
11:20:17 <BMeph> Cale: Thanks - when you used that stuttered line for nefty's example, and I read it, I started having Lady Gaga flashbacks. =8*O
11:20:21 <mreh> > map (\x -> (head x, length x)) . group . sort . words $ ""
11:20:22 <lambdabot>   []
11:20:29 <mreh> damn, trying to break it
11:20:36 <Cale> > M.fromListWith (+) . flip zip (repeat 1) $ words "here here here is is is a a a a bunch of of of words"
11:20:37 <lambdabot>   fromList [("a",4),("bunch",1),("here",3),("is",3),("of",3),("words",1)]
11:20:47 <mreh> touche
11:21:43 <nefty> I'm going to have to copy this all down and see if I can figure it out in more detail later
11:21:49 <applicative> @type  M.fromListWith (+) . flip zip (repeat 1) . words
11:21:50 <Cale> nefty: So, that's practically a ready-made solution to the problem. :)  The other way is to sort the list of words, and then group it into groups of equal elements, and then count the length of each group.
11:21:50 <lambdabot> forall a. (Num a) => String -> M.Map String a
11:22:13 <FunctorSalad_> > foldr (\word map -> insertWith (+) word 1 map) M.empty (words "oh hai oh hai")
11:22:14 <lambdabot>   Not in scope: `insertWith'
11:22:17 <Cale> Which is what the other described solution was :)
11:22:20 <FunctorSalad_> > foldr (\word map -> M.insertWith (+) word 1 map) M.empty (words "oh hai oh hai")
11:22:22 <lambdabot>   fromList [("hai",2),("oh",2)]
11:22:22 <aristid> @pl (\x -> (head x, length x))
11:22:23 <lambdabot> liftM2 (,) head length
11:22:48 <FunctorSalad_> nefty: another slightly different way to write it there
11:22:54 <aristid> :t liftM2 (,) head length
11:22:56 <jmcarthur> i hate it when i see Map String. it makes me want to scream "TRIE"
11:22:56 <lambdabot> forall a1. [a1] -> (a1, Int)
11:22:57 <mreh> what did I see today?
11:23:03 <BMeph> nefty: Good news, we've taken care of that "jotting it down" problem for you, as well - just go to http://tunes.org/~nef/logs/haskell/10.05.20 and you can see this very conversation! :)
11:23:04 <applicative> @type  M.toList . M.fromListWith (+) . flip zip (repeat 1) . words
11:23:04 <mreh> oh it was liftM2 ($) f g
11:23:04 <aristid> :t liftM2
11:23:04 <FunctorSalad_> TRIE
11:23:04 <lambdabot> forall a. (Num a) => String -> [(String, a)]
11:23:05 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:23:08 <mreh> what the hell doest hat do
11:23:20 <aristid> :t liftM2 (,)
11:23:20 <nefty> BMeph: thanks for the link
11:23:21 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
11:24:04 <nefty> I have to come here more often  :)
11:24:19 <franka> Thank God #haskell-blah is not logged.
11:24:31 <mreh> I have a complaint about the logs
11:24:33 <franka> That would come back and haunt me for sure.
11:24:35 <mreh> they're backwards
11:24:42 <BMeph> mreh: "liftM2 ($)" is another way to write "ap". :)
11:24:52 <jmcarthur> Map String isn't so bad if you compare it to Map [String] or Map [[String]] though :)
11:24:54 <aristid> :t head
11:24:56 <lambdabot> forall a. [a] -> a
11:25:15 <mreh> ah yeah
11:25:22 <mreh> applicative functions...
11:25:24 <mreh> functors
11:25:28 <FunctorSalad_> jmcarthur: ? tries are good for that too?
11:25:28 <mreh> <_<
11:25:40 <hpc> :k Trie
11:25:42 <lambdabot> Not in scope: type constructor or class `Trie'
11:26:18 <jmcarthur> FunctorSalad_: tries generalize pretty well
11:27:23 <jmcarthur> FunctorSalad_: here's a fun package http://hackage.haskell.org/package/TrieMap
11:27:44 * hackagebot Befunge93 0.1 - An interpreter for the Befunge-93 Programming Language  http://hackage.haskell.org/package/Befunge93-0.1 (BrandonSimmons)
11:27:50 <jmcarthur> FunctorSalad_: i believe the memoization libraries also do something similar
11:31:03 <FunctorSalad_> jmcarthur: yes I've seen one of the trie typeclasses, it's neat :) I just wasn't sure if you're saying that using Map instead of Trie is even worse for [String or [[String]] keys than for String keys
11:31:34 <aristid> (->) a is a Monad?
11:31:40 <soupdragon> yes aristid
11:31:44 <hpc> (-> r) is a monad
11:31:45 <aristid> in which module?
11:31:46 <jmcarthur> FunctorSalad_: well, i was assuming that the size of the data would get bigger along with it, but i guess that isn't strictly true
11:31:53 <soupdragon> hpc, is it?
11:31:54 <EvanR-work> is conway's game of life... a game?
11:31:55 <sm> applicative, gwern: http://hledger.org/MANUAL.html#installation-problems
11:31:58 <soupdragon> I thought it was (e ->)
11:32:13 <lispy> EvanR-work: is fun a requirement of game? :)
11:32:17 <FunctorSalad_> (->) A
11:32:19 <hpc> er, ((->) r)
11:32:20 <aristid> liftM2 (,) head length surely uses the (e ->) monad if any.
11:32:29 <soupdragon> yes
11:32:31 <hpc> or (e ->) if the syntax supported it
11:32:32 <EvanR-work> lispy: well, there are turns, but no players, and as far as i can tell no goal
11:32:33 <lispy> EvanR-work: I always thought of "game" in that context as "toy"
11:32:33 <soupdragon> that's true
11:32:38 * sm <3 pandoc.. switching from rst to markdown was trivial
11:32:50 <aristid> soupdragon: :info Monad doesn't show such an instance
11:32:54 <FunctorSalad_> metasyntactic variables should be capitalized ;)
11:33:08 <FunctorSalad_> or is "forall a. (->) a" somehow a monad too?
11:33:20 <soupdragon> that is not a well formed type
11:33:43 <gwern> EvanR-work: you're playing it wrong. 2 or more players try to devise a pattern which will eat the other players' patterns; each Game of Life is a round
11:33:56 <gwern> conway unfortunately omitted a detaild description of the rules
11:33:59 <FunctorSalad_> not? thought it just "distributes" its second argument into the binder, soupdragon
11:34:01 <applicative> @type let neftyIO = \file -> readFile file >>= print . pureNefty; pureNefty = Data.Map.toList . Data.Map.fromListWith (+) . flip zip (repeat 1) . words in neftyIO
11:34:02 <lambdabot> FilePath -> IO ()
11:34:14 <FunctorSalad_> @kind (forall a. (->) a) String
11:34:15 <lambdabot>     `(->) a' is not applied to enough type arguments
11:34:15 <lambdabot>     Expected kind `*', but `(->) a' has kind `? -> *'
11:34:21 <EvanR-work> gwern: haha
11:34:24 <FunctorSalad_> ok seems you're right
11:34:24 <soupdragon> oh I understand what you meant by it now
11:34:44 <FunctorSalad_> I thought that expression should just mean "forall a. (->) a String"
11:35:01 <gwern> applicative: personally I think nefty's program would be even nicer with 'interact'
11:35:16 <applicative> gwern indeed
11:35:45 <aristid> so which module do i need for liftM2 (,) head length?
11:35:46 <applicative> @type interact (Data.Map.toList . Data.Map.fromListWith (+) . flip zip (repeat 1) . words)
11:35:47 <lambdabot>     Couldn't match expected type `Char' against inferred type `(k, a)'
11:35:47 <lambdabot>       Expected type: String
11:35:47 <lambdabot>       Inferred type: [(k, a)]
11:35:50 <FunctorSalad_> shouldn't there be interactIO btw? ;)
11:35:56 <applicative> whoop, forgot
11:36:00 <FunctorSalad_> aristid: Control.Monad
11:36:11 <applicative> @type interact (show.Data.Map.toList . Data.Map.fromListWith (+) . flip zip (repeat 1) . words)
11:36:12 <lambdabot> IO ()
11:36:17 <aristid> FunctorSalad_: i have Control.Monad loaded but it gives an error
11:36:19 <aristid> ghc 6.12
11:36:36 <aristid> Prelude Control.Monad> (liftM2 (,) head length) [1,2,3]
11:36:36 <aristid> <interactive>:1:1:
11:36:36 <aristid>     No instance for (Monad ((->) [a1]))
11:36:38 <gwern> FunctorSalad_: how would interactIO work?
11:36:47 <FunctorSalad_> aristid: oh. Control.Monad.Reader too
11:36:48 <copumpkin> aristid: import Control.Monad.Instances
11:36:49 <FunctorSalad_> for the instance
11:36:52 <applicative> nefty, so the interact function there, you can pipe to it and from it
11:36:56 <copumpkin> or Reader, or Control.Arrow
11:37:13 <aristid> cool, Instances works
11:37:31 <nefty> applicative: that sounds good
11:37:40 <applicative> @type interact
11:37:41 <lambdabot> (String -> String) -> IO ()
11:37:49 * hackagebot extcore 0.7 - Libraries for processing GHC Core  http://hackage.haskell.org/package/extcore-0.7 (TimChevalier)
11:38:05 <nefty> silver: I've been putting off reading SICP for a while, it would probably help me a lot
11:38:06 <FunctorSalad_> gwern: like `interact', but String -> IO String. Maybe that's too trivial a wrapper though ("getContents >>= f >>= putStrLn")
11:38:55 <FunctorSalad_> interactWithArgs might be useful too
11:39:43 <aristid> @hoogle interact
11:39:43 <lambdabot> Prelude interact :: (String -> String) -> IO ()
11:39:44 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
11:39:44 <lambdabot> System.IO interact :: (String -> String) -> IO ()
11:39:46 <nefty> crap, I have to go. This was really helpful though, thanks for the example code everyone. I might be on later if I have questions going through the log.
11:39:50 <aristid> @hoogle interactWithArgs
11:39:51 <lambdabot> No results found
11:40:28 <nefty> s/might/will
11:40:33 <applicative> nefty, cool.   you can also paste problematic modules on hpaste.org
11:40:49 <nefty> okay, cool
11:41:57 <hpc> @src interact
11:41:58 <lambdabot> interact f = do s <- getContents; putStr (f s)
11:43:09 <aristid> @. pl undo interact f = do s <- getContents; putStr (f s)
11:43:09 <lambdabot> interact = (getContents >>=) . (putStr .)
11:45:43 <Apocalisp> @hoogle (a -> b -> m r) -> m a -> m b -> m r
11:45:44 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
11:45:44 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
11:45:44 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
11:46:11 <Apocalisp> @djinn (a -> b -> Maybe r) -> Maybe a -> Maybe b -> Maybe r
11:46:12 <lambdabot> f a b c =
11:46:12 <lambdabot>     case b of
11:46:12 <lambdabot>     Nothing -> Nothing
11:46:12 <lambdabot>     Just d -> case c of
11:46:12 <lambdabot>               Nothing -> Nothing
11:46:14 <lambdabot>               Just e -> a d e
11:46:25 <Apocalisp> thanks, djinn!
11:46:45 <soupdragon> :t liftM2 (\x y -> ?f x y)
11:46:46 <lambdabot> forall a1 a2 r (m :: * -> *). (?f::a1 -> a2 -> r, Monad m) => m a1 -> m a2 -> m r
11:47:00 <whald> does parsec have built in support for parsing floats?
11:47:40 <aristid> :t let f a b c = case b of ; Nothing -> Nothing ; Just d -> case c of ; Nothing -> Nothing; Just e -> a d e in f
11:47:42 <lambdabot> forall t t1 a. (t -> t1 -> Maybe a) -> Maybe t -> Maybe t1 -> Maybe a
11:47:51 <aristid> @pl let f a b c = case b of ; Nothing -> Nothing ; Just d -> case c of ; Nothing -> Nothing; Just e -> a d e in f
11:47:51 <lambdabot> (line 1, column 35):
11:47:52 <lambdabot> unexpected "-"
11:47:52 <lambdabot> expecting pattern or "="
11:48:39 <dfkjjkfd>  whald: google parsec parse float
11:48:56 <Apocalisp> what is (a -> b -> m r) -> m a -> m b -> m r in general?
11:49:21 <Apocalisp> bind2?
11:49:46 <monochrom> @type liftM2
11:49:47 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:50:05 <soupdragon> :t ((join .) .) . liftM2
11:50:06 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
11:50:10 <monochrom> Yeah
11:51:36 <aristid> @unpl ((join .) .) . liftM2
11:51:37 <lambdabot> (\ j o r -> (o >>= \ d -> r >>= \ c -> return (j d c)) >>= \ k -> k)
11:51:55 <aristid> @help do
11:51:56 <lambdabot> do <expr>
11:51:56 <lambdabot> Translate Monad operators to do notation.
11:52:02 <aristid> @. do unpl ((join .) .) . liftM2
11:52:02 <lambdabot> (\ j o r -> do { k <- (do { d <- o; c <- r; return (j d c)}); k})
11:52:10 <soupdragon> @pl (\ j o r -> do { k <- (do { d <- o; c <- r; return (j d c)}); k})
11:52:10 <lambdabot> (line 1, column 16):
11:52:10 <lambdabot> unexpected "{"
11:52:10 <lambdabot> expecting variable, "(", operator or ")"
11:52:20 <soupdragon> :/
11:52:34 <whald> dfkjjkfd: found it. i was mainly confused because there is "Text.ParserCombinators.Parsec" and "Text.Parsec" related documentation around
11:52:38 <aristid> soupdragon: @. pl undo?
11:52:50 <Apocalisp> @do (\ j o r -> (o >>= \ d -> r >>= \ c -> join (return (j d c))))
11:52:51 <lambdabot> (\ j o r -> (do { d <- o; c <- r; join (return (j d c))}))
11:53:45 <monochrom> \f m n -> do { a<-m; b<-n; f a b }
11:54:10 <BMeph> Wouldn't "join (return (j d c))" just be "j d c"?
11:54:20 <monochrom> yes.
11:54:43 <monochrom> @type join . return
11:54:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
11:54:52 <Apocalisp> @do (\ j o r -> join (o >>= \ d -> r >>= \ c -> return (j d c)))
11:54:53 <lambdabot> (\ j o r -> join (do { d <- o; c <- r; return (j d c)}))
11:55:00 <monochrom> @free join
11:55:01 <lambdabot> Expected variable or '.'
11:55:09 <monochrom> @help free
11:55:10 <lambdabot> free <ident>. Generate theorems for free
11:55:15 <monochrom> @free return
11:55:16 <lambdabot> Expected variable or '.'
11:55:21 <aristid> @free a
11:55:23 <lambdabot> a = a
11:55:30 <monochrom> @free Control.Monad.join
11:55:30 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
11:55:34 <monochrom> heh
11:55:36 <aristid> @free .
11:55:37 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
11:55:43 <aristid> @free .x
11:55:44 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
11:55:48 <aristid> @free b
11:55:49 <lambdabot> b = b
11:55:54 <blueonyx> @src (++)
11:55:54 <lambdabot> []     ++ ys = ys
11:55:54 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:55:54 <lambdabot> -- OR
11:55:54 <lambdabot> xs ++ ys = foldr (:) ys xs
11:56:23 <monochrom> try @free reverse
11:56:30 <aristid> @free reverse
11:56:31 <lambdabot> $map f . reverse = reverse . $map f
11:56:50 <dolio> @free id
11:56:50 <lambdabot> f . id = id . f
11:57:01 <aristid> :t $map
11:57:02 <lambdabot> parse error on input `$'
11:57:17 <aristid> @free length
11:57:18 <lambdabot> length = length . $map f
11:57:47 <aristid> @free head
11:57:48 <lambdabot> f . head = head . $map f
11:57:52 <Apocalisp> @free foldr
11:57:53 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
11:57:56 <Apocalisp> huzzah
11:58:39 <aristid> @free foldl
11:58:40 <lambdabot> (forall x. f . h x = k (f x) . g) => f . foldl h y = foldl k (f y) . $map g
11:59:04 <aristid> note the subtlety
12:00:17 <sm> hmm, I've updated pandoc to the same version as on my dev machine, but it's still eating quotes
12:00:29 <dpratt71> I infer that @free has something to do with "free theorems" but I'm relatively ignorant of that subject; how does one interpret the output of @free?
12:00:32 <sm> maybe I need to update hakyll ?
12:00:55 <sm> no
12:01:03 <dolio> It gives you the free theorem for the function in question.
12:01:08 <cschreiner> hi all
12:01:26 <dolio> foldr obeys that law.
12:01:33 <jmcarthur> @free map
12:01:34 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
12:01:38 <dpratt71> dolio: ok; there is only one free theorem to be had?
12:02:25 <dolio> Yes. More or less.
12:02:31 <jmcarthur> @free (join :: (a -> a -> b) -> a -> b)
12:02:31 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
12:02:49 <jmcarthur> does it expect a function name only?
12:02:55 <aristid> @free join
12:02:56 <lambdabot> Expected variable or '.'
12:03:07 <dolio> @free join :: (a -> a -> b) -> a -> b
12:03:08 <lambdabot> (forall x. g . h x = k (f x) . f) => g . join h = join k . f
12:03:12 <jmcarthur> aha
12:03:26 <dolio> @free join :: M (M a) -> M a
12:03:27 <lambdabot> $map_M f . join = join . $map_M ($map_M f)
12:03:39 <jmcarthur> ah nice
12:03:42 <dpratt71> dolio: ok; so in the map example, do I read that as "if g compose h equals k compose f, then map g compose map h equals map k compose map f"?
12:04:02 <cocon> is there a way to define an empty datatype in Haskell, e.g. an algebraic one without constructors?
12:04:10 <copumpkin> -XEmptyDataDecls
12:04:11 <copumpkin> data Moo
12:04:12 <jmcarthur> @free undefined :: (a -> a -> b) -> a -> b
12:04:12 <lambdabot> (forall x. g . h x = k (f x) . f) => g . undefined h = undefined k . f
12:04:23 <jmcarthur> ah it only cares about the type
12:04:25 <dolio> dpratt71: Yes. Although the map without a $ could be any function with the same type as map.
12:04:26 <cocon> thanks
12:04:28 <copumpkin> or you can do newtype X = X X
12:04:41 <dpratt71> dolio: oh; interesting
12:04:47 <copumpkin> cocon: it isn't truly empty though
12:04:52 <dolio> Free theorems are based only on the type.
12:04:54 <copumpkin> which is why it's equivalent to that newtype
12:05:24 <dolio> @free wiggles :: (a -> b) -> [a] -> [b]
12:05:25 <lambdabot> g . h = k . f => $map g . wiggles h = wiggles k . $map f
12:05:26 <jmcarthur> dolio: yeah, but i wasn't sure if @free relied on knowing the function
12:05:40 <jmcarthur> ah i see
12:05:43 <copumpkin> it just wants a name
12:05:52 <jmcarthur> so i guess it looks up the type if you don't give it
12:06:01 <copumpkin> @free join
12:06:02 <lambdabot> Expected variable or '.'
12:06:04 <copumpkin> I don't think so
12:06:08 <jmcarthur> @free length
12:06:09 <lambdabot> length = length . $map f
12:06:14 <soupdragon> it can't do monads
12:06:14 <jmcarthur> like so
12:06:15 <copumpkin> oh it might have a few built in
12:06:17 <soupdragon> or typeclasses
12:06:27 <jmcarthur> @free sort
12:06:28 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => [a] -> [a]\n"
12:06:39 <aristid> > join (,) 1
12:06:40 <jmcarthur> that gives it away right there!
12:06:40 <lambdabot>   (1,1)
12:06:43 <soupdragon> @free reverse :: [a] -> [a]
12:06:43 <lambdabot> $map f . reverse = reverse . $map f
12:06:54 <soupdragon> ^ this does not hold for sort
12:07:06 <aristid> so join f a = f a a for the function monad?
12:07:08 <jmcarthur> indeed not
12:07:10 <dolio> @free econ :: forall a. F a -> T
12:07:10 <lambdabot> econ = econ . $map_F f
12:07:14 <soupdragon> aristid, yes
12:07:35 <aristid> @src ((->) r) (>>=)
12:07:35 <lambdabot> Source not found. You speak an infinite deal of nothing
12:07:43 <aristid> @src join
12:07:43 <lambdabot> join x =  x >>= id
12:07:51 <copumpkin> @src (->) (>>=)
12:07:51 <lambdabot> f >>= k = \ r -> k (f r) r
12:07:55 <soupdragon> how does that one work
12:07:57 <soupdragon> the econ?
12:07:58 <jmcarthur> @free bind :: Maybe a -> (a -> Maybe b) -> Maybe b
12:07:58 <lambdabot> $map_Maybe g . h = k . f => $map_Maybe g (bind x h) = bind ($map_Maybe f x) k
12:08:00 <copumpkin> it makes no sense but that's how it is
12:08:03 <aristid> copumpkin: thanks
12:08:20 <soupdragon> oh I get it now
12:08:27 <aristid> @src (->) return
12:08:27 <lambdabot> return = const
12:08:39 <dolio> In particular...
12:08:45 <dolio> @free econ :: forall a. a -> T
12:08:46 <lambdabot> econ = econ . f
12:09:21 <dolio> Since that's the type of the constructor for (exists a. a), every element of that type is the same.
12:09:24 <soupdragon> @free econ :: forall a. a -> a -> a -> T
12:09:24 <lambdabot> econ x y = econ (f x) (f y) . f
12:09:38 <Ke> code.haskell.org down again?
12:09:41 <zygoloid> @free (a -> a -> Ordering) -> [a] -> [a]
12:09:41 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
12:09:52 <zygoloid> @free sortOn :: (a -> a -> Ordering) -> [a] -> [a]
12:09:53 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortOn g = sortOn h . $map f
12:10:05 <zygoloid> nice :)
12:10:08 <copumpkin> Ke: it's down more than it's up
12:10:17 <Ke> yes
12:14:33 <Olathe> > let f [] ys = ys; f (_:xs) (_:ys) = f xs ys in f [1..10] [1..20]
12:14:35 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
12:14:53 <Olathe> Is there a way to do that without defining my own f ?
12:15:54 <dolio> @type drop . length
12:15:55 <lambdabot> forall a a1. [a1] -> [a] -> [a]
12:16:13 <dolio> > (drop . length) [1..10] [1..20]
12:16:14 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
12:16:53 <aristid> @pl f l = drop (length l) l
12:16:53 <lambdabot> f = drop =<< length
12:16:59 <copumpkin> there's another approach to that
12:17:03 <Olathe> Ahh, thanks
12:17:07 <soupdragon> const []
12:18:05 <Etsun> Hmm
12:18:17 <Etsun> A.K.A. join (drop . length)
12:18:36 <Etsun> Ohâ¦ join + fmap = bind, of course
12:19:33 <dpratt71> what is the meaning of 'forall a' that I see sometimes (the output of @free being an example)?
12:20:14 <dolio> It's quantifying over values, not types.
12:20:53 <dolio> In the case of sortOn, it's forall x :: a.
12:21:09 <dpratt71> dolio: I could interpret that explanation a number of ways, none of them likely to be correct
12:21:28 <dpratt71> what is the diff between quantifying over values vs. types?
12:21:52 <soupdragon> other than what you said. nothing..
12:21:54 <dolio> You can't do the former in Haskell.
12:22:01 <edwardk> hrmm, are enough of the bowels of Data.Array exposed that a new unboxed type could be added to UArray ?
12:22:16 <dpratt71> hmm
12:22:58 <dpratt71> ok, let me ask this: what is the difference between when 'forall a' is present vs. when it isn't?
12:23:04 <copumpkin> edwardk: I think so
12:23:19 <copumpkin> oh actually
12:23:24 <Twey> dpratt71: At the top level, nothing.
12:23:31 <edwardk> dpratt71: nothing unless it is buried under a -> on the left or right somewhere
12:23:43 <sepp2k> dpratt71:
12:23:48 <dolio> @free m :: a -> a -> a
12:23:48 <lambdabot> f . m x = m (f x) . f
12:24:04 <dolio> @free m :: (a -> a) -> a -> a
12:24:04 <lambdabot> f . g = h . f => f . m g = m h . f
12:24:07 <dolio> Hmm...
12:24:23 <copumpkin> edwardk: yeah, the UArray constructor is exported from Data.Array.Base
12:24:27 <edwardk> copumpkin: ideally i'd want to store UArray i (D Dual s Float)  and UArray i (D Dual s Double) -- just like Float or Double, etc.
12:24:28 <copumpkin> UArray :: i -> i -> Int -> GHC.Prim.ByteArray# -> UArray i e
12:24:34 <dolio> @free m :: (a -> a -> a) -> T
12:24:34 <lambdabot> (forall x. f . g x = h (f x) . f) => m g = m h
12:24:42 <edwardk> ah
12:25:03 <copumpkin> edwardk: I imagine you'd just copy and paste the Double/Float stuff from that module and stick your wrappers around them. Or just unsafeCoerce if D is a newtype :P
12:25:09 <dolio> dpratt71: There is implicit quantification over f g and h there.
12:25:28 <dolio> forall f g h. (forall x. f . g x = h (f x) . f) => m g = m h
12:25:59 <edwardk> D Dual s is a couple of layers of newtypes around a pair  , so i'd need to do some plumbing, etc.
12:26:20 <dolio> That identity for f g and h must hold for all values x :: a.
12:26:42 <copumpkin> edwardk: ah, ok
12:26:56 <dpratt71> dolio: ok; I appreciated your attempted explanations, but I think I need to understand 'quantification' at a deeper level before I can comprehend what is being expressed
12:27:49 <dolio> Or for id: forall f. f . id = id . f
12:27:58 <Olathe> @type fix
12:28:00 <lambdabot> forall a. (a -> a) -> a
12:28:00 <dolio> Regardless of what f you pick, f . id = id . f
12:28:55 <dolio>  @free just uses an explicit forall when it needs to nest such picking.
12:28:58 <dpratt71> dolio: I think I can accept that for any f, f . id = id . f, but...
12:29:15 <EvanR-work> not sure why i didnt run into this before
12:29:17 <dpratt71> ...what is implied when 'forall' is not present?
12:29:23 <EvanR-work> whats the right way to 'safe open' a file
12:29:32 <EvanR-work> so its doesnt crash
12:29:53 <dpratt71> ...that there may be some f such that f . id <> id . f ?
12:30:22 <dolio> No. All variables that aren't explicitly quantified are assumed to be quantified at the outermost level.
12:30:34 <dolio> Just like Haskell types.
12:30:42 <dolio> a -> a is short for forall a. a -> a.
12:31:11 <dpratt71> dolio: ok, so the real difference (whatever that is) is what level variables are quantified?
12:31:27 <dolio> Yes.
12:31:55 <iago> a -> b -> a is short for... ?
12:32:02 <dpratt71> hmm
12:32:06 <dolio> forall a b. a -> b -> a
12:32:23 <iago> why not forall a. a -> forall b. b -> a ?
12:32:43 <dolio> Those are technically the same.
12:32:49 <iago> uhm well ok, in this case
12:33:38 <iago> a -> (a -> a) -> a, we'll assume rank-1
12:34:49 <Twey> flip id!
12:35:42 <dpratt71> so maybe this will help me understand: what is the difference between this:
12:35:43 <dpratt71> forall f g h. (forall x. f . g x = h (f x) . f) => m g = m h
12:35:56 <dpratt71> (as above) and this:
12:35:57 <dpratt71> forall f g h x. f . g x = h (f x) . f => m g = m h
12:36:05 <dpratt71> (does that even make sense?)
12:36:26 <dolio> In the first one, the identity on f, g and h must hold for all x.
12:36:41 <dolio> In the second, it holds for some particular x.
12:37:00 <dpratt71> dolio: ah, I think I'm getting it a bit now
12:37:07 <dpratt71> dolio: thanks :)
12:37:07 <dolio> The second is "pick arbitrary f g h x, such that ...".
12:37:26 <dolio> The first is "pick arbitrary f g h such that (pick arbitrary x ...) ..."
12:37:36 <dpratt71> dolio: gotcha
12:38:17 <dolio> Actually, that's not necessarily different. The important part is that the (forall x. ...) is on the left of an arrow.
12:39:17 <iago> there are no problem when are quantified variables are uniquely named
12:39:21 <dolio> forall x. (forall y. P(x,y)) is the same as forall x y. P(x,y) of course.
12:39:36 <iago> there is no problem when all the quantified variables are uniquely named*
12:39:55 <dolio> But forall x. (forall y. P(x,y)) => Q(x) is not the same as forall x y. P(x,y) => Q(x)
12:40:57 <dpratt71> dolio: interesting
12:41:47 <dolio> Also, forall x. P(x) => (forall y. Q(x,y)) is the same as forall x y. P(x) => Q(x,y)
12:42:43 <dpratt71> dolio: in your example: x. (forall y. P(x,y)) => Q(x)...
12:43:20 <dpratt71> does that limit what x can satisfy the overall...uh...thing?
12:44:07 <dpratt71> that is, any x that also satisfies P(x,y) for any y?
12:44:45 <betol> Insahlla allah, I know Haskell is primarily made by Jews for Jews, so I suppose it is not unwarranted to suspect that the GHC will produce binaries booby-trapped if I try to write software for use in Islamic culture Is this correct?
12:45:05 <EvanR-work> betol: i think so
12:45:07 <dpratt71> wow
12:45:40 <betol> Is there a way to Jew proof my binaries?
12:46:03 <dolio> dpratt71: That probably depends on what P is. Maybe you can prove that forall x y. P(x,y) => (forall z. P(x,z))
12:46:54 <dolio> monochrom: Ping
12:47:21 <betol> how many jews are there here?
12:48:03 <dpratt71> ok considering this: forall x y. P(x) => Q(x,y)
12:48:19 <dpratt71> P is a predicate? something that may or may not be true?
12:48:23 <betol> I've been looking through the GHC committer history and see there's a lot of Jew like names
12:48:34 <dolio> @where ops
12:48:34 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
12:48:44 --- mode: ChanServ set +o allbery_b
12:48:46 <betol> lol
12:49:41 <betol> I see, there are powerful jews here even as we speak
12:49:44 <dolio> dpratt71: Sure. You can interpret it as a type, too.
12:49:44 --- mode: ChanServ set +o dcoutts
12:49:45 --- kick: betol was kicked by allbery_b (betol)
12:50:03 * allbery_b *eyeroll*
12:50:11 <dcoutts> what a wierdo
12:50:12 <monochrom> who needs to be kicked?
12:50:13 <allbery_b> I suppose it is fitting though }:>
12:50:17 --- mode: ChanServ set -o dcoutts
12:50:21 <allbery_b> already gone. (betol)
12:50:26 <monochrom> nice
12:50:32 --- mode: allbery_b set -o allbery_b
12:50:33 <dolio> monochrom: You're too slow on the draw. :)
12:50:38 <dolio> I even gave you a head start.
12:50:42 <monochrom> yeah was busy on a web forum
12:51:01 <DigitalKiwi> my name is very jew like and i took offense! (it is said jewbeck >.> )
12:51:03 <dcoutts> monochrom: dishing out justice? :-)
12:51:17 * jmcarthur is glad not to be in the @where ops list
12:51:22 <DigitalKiwi> spelled completely different, though, no c and there's a d in there
12:51:37 <DigitalKiwi> and a u
12:51:52 <c_wraith> jmcarthur: any of us could add you to the list, you know
12:51:56 <allbery_b> enh.  garden variety troll.
12:52:09 <jmcarthur> c_wraith: you would have to take somebody else off. it would take two lines otherwise
12:52:26 <c_wraith> oh, is that why you're not on the list?  well, then nevermind :)
12:52:45 <jmcarthur> there are many people not on the list
12:53:19 <DigitalKiwi> jmcarthur: get a wider monitor!
12:53:21 <BMeph> I'm almost disappointed that he said nothing about ni-ni-ni-niggers...*almost*. :\
12:53:23 <jmcarthur> i think we have like 30 ops
12:53:30 <jmcarthur> DigitalKiwi: this isn't about my monitor :P
12:53:45 <DigitalKiwi> 14:52 < jmcarthur> i think we have like 30 ops
12:53:45 <DigitalKiwi> 14:53 < jmcarthur> DigitalKiwi: this isn't about my monitor :P
12:53:48 <DigitalKiwi> that's two lines!
12:53:52 <jmcarthur> DigitalKiwi: i mean lambdabot would send two separate messages if it was any longer
12:53:54 <dpratt71> dolio: going back to one of your prior remarks: "forall x. (forall y. P(x,y)) => Q(x) is not the same as forall x y. P(x,y) => Q(x)"...
12:53:57 <DigitalKiwi> and less important than calling all ops
12:53:58 <ccasin> is code.haskell.org down, or is it just me?
12:54:05 <dpratt71> which of the two is more restrictive?
12:54:10 * DigitalKiwi has successfully dismissed your argument
12:54:14 <DigitalKiwi> mission accomplished
12:54:44 <DigitalKiwi> you can do like
12:54:53 <DigitalKiwi> /msg chanserv access #haskell list
12:54:56 <DigitalKiwi> to see all ops
12:55:12 <jmcarthur> yeah but the main reason people do the @where ops thing is to get their attention
12:55:33 <c_wraith> yeah, it's just to summon someone to boot a troll, usually
12:56:55 <DigitalKiwi> we need goats to distract them
12:56:58 <siracusa> ccasin: It seems to be down (again)
12:57:50 <dpratt71> interesting that not only are the regulars above-average around here, so are the trolls; how many trolls read commiter lists?
12:58:51 <jmcarthur> that wasn't a good troll
12:58:54 <dolio> @type let g :: (forall x y. p x y -> q x) -> (forall x. (forall y. p x y) -> q x) ; g f pf = f pf in g -- dpratt71
12:58:55 <lambdabot> forall (p :: * -> * -> *) (q :: * -> *) x. (forall x1 y. p x1 y -> q x1) -> (forall y. p x y) -> q x
12:58:57 <jmcarthur> good trolls don't get kicked
12:59:51 <EvanR-work> 'avoid success at all costs'
12:59:53 <dpratt71> dolio: are you trying to frighten me :)
12:59:54 <Berengal> "<Cale> http://jayisgames.com/games/manufactoria/ -- fun :)" <- a bit too fun, Cale...
13:00:00 <DigitalKiwi> i am not sure i've ever been kicked from here
13:00:04 <EvanR-work> i think haskell has failed at this goal, since you get jew trolls
13:00:04 <DigitalKiwi> if i was it was by glguy
13:00:08 <DigitalKiwi> so it doesn't count
13:00:16 <Cale> Berengal: heh, addicted?
13:00:29 <DigitalKiwi> does this make me a good troll? :D
13:00:30 <Berengal> Yes
13:00:58 <dolio> dpratt71: That should answer your question, although you have to decide what "more restrictive" means, I guess.
13:01:30 <dpratt71> dolio: I'll take your word for it that is the answer to my question ;-)
13:01:30 <BMeph> DigitalKiwi: Around here, copumpkin is the standard, so you have a ways to go. (hmm, as if I should talk...)
13:01:50 <DigitalKiwi> lmao
13:02:02 <Berengal> Cale: The first puzzle where they throw god-awfully long tapes at me and I'm sitting there with an O(n^2) algorithm...
13:02:02 <dolio> dpratt71: It shows that forall x y. P x y -> Q x implies forall x. (forall y. P x y) -> Q x.
13:02:07 <dolio> The other direction won't work.
13:02:14 <Cale> Berengal: which one?
13:02:25 <Cale> The "as many blue as red"?
13:02:30 <Berengal> Cale: Equal number of reds and blues in any order
13:02:34 <dpratt71> dolio: ok, I'm gonna ponder that a minute or 30
13:02:39 <Cale> My solution for that was O(n log n)
13:02:49 <Berengal> Sort?
13:03:00 <Cale> nope
13:03:26 <nostrand> how do i enable strict arguments (f !x = ...) in the source?
13:03:30 <Berengal> How then?
13:03:35 <jkramer> Ahoy
13:03:52 <jkramer> Is there a safe version of !!, ie one that allows a default value as fallbackÃ
13:03:53 <jkramer> ?
13:04:27 <Cale> Make the following replacements: RR -> Y, BB -> G, BR -> e, RB -> e
13:04:37 <ClaudiusMaximus> @hoogle [a] -> Int -> Maybe a
13:04:37 <lambdabot> Prelude (!!) :: [a] -> Int -> a
13:04:38 <lambdabot> Data.List (!!) :: [a] -> Int -> a
13:04:38 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
13:04:52 <Cale> and then similar, but with RB and GY swapped
13:05:09 <iago> nostrand, {-# LANGUAGE BangPatterns #-} ?
13:05:17 <nostrand> iago: thanks! =)
13:05:21 <copumpkin> BMeph: zomg
13:05:28 <jmcarthur> copumpkin is the only troll to be promoted to op
13:05:32 <Berengal> Ah. neat
13:05:48 <copumpkin> jmcarthur: a/s/l? and btw, haskell sucks!
13:05:55 <jmcarthur> see? successful troll
13:06:01 <jmcarthur> perfectly assimilated into the system
13:06:10 <Cale> and continue until the string is empty, or until you run into one symbol followed by nothing, which indicates an imbalance
13:06:13 <jmcarthur> and simultaneously able to piss everybody off
13:06:28 <palomer> muahahah
13:06:30 <soupdragon> :/
13:06:44 <dpratt71> dolio: so the set of stuff that satisfies "forall x y. P x y -> Q x" is a subset of the stuff that satisfies "forall x. (forall y. P x y) -> Q x"?
13:06:44 <ClaudiusMaximus> :t \xs n -> listToMaybe $ drop n xs
13:06:46 <lambdabot> forall a. [a] -> Int -> Maybe a
13:07:00 <companion_cube> is there a chance that one day, haskell could have a ML-like module system ?
13:07:01 <jmcarthur> #haskell loves pet trolls
13:07:28 <companion_cube> because ML-like modules are really awesome
13:07:36 <Berengal> Indeed. I just wrote any same-color cells to the back of the tape, translating R->Y, B->G, until I found a match, then proceeded to translate the rest of the tape, then translate back again and loop...
13:07:48 <FunctorSalad_> *idly wonders* ghc parses haddock already when compiling, doesn't it? if so, wouldn't it be a small step to have a global "Map QualName DocString"?
13:07:58 <dolio> dpratt71: Yeah, I guess that's right.
13:08:06 <dolio> In a sense.
13:08:46 <FunctorSalad_> that'd seem more elegant than having to scavenge the haddock externally as the editor modes etc have to do ;)
13:09:28 <FunctorSalad_> it should all be optional to prevent performance regression for those who don't need it, of course
13:10:40 <dpratt71> dolio: is that because in the second example, we'll take any x at all, but in the first example it has to be an x where there is...oh...terminology fail...that satisfies P(x,y)?
13:11:06 <triyo> Noob question, does the Tree data type have an instance of the Monoid type class?
13:11:18 <FunctorSalad_> at least I've seen references to haddock in ghc's AST...
13:11:23 <FunctorSalad_> don't know if its used
13:11:33 <jkingkong> Question: say I want to create a type synonym for a list, but I want all the variables of that type to have a fixed length, is there a good way of going about this? I'm not sure what "feature" I should be looking for. Thanks.
13:11:34 <lambdabot> jkingkong: You have 1 new message. '/msg lambdabot @messages' to read it.
13:11:38 <lispy> ?hoogle Tree
13:11:39 <lambdabot> module Data.Graph.Inductive.Tree
13:11:39 <lambdabot> module Data.Tree
13:11:39 <lambdabot> Data.Tree data Tree a
13:12:21 <FunctorSalad_> @source Tree
13:12:21 <lambdabot> Tree not available
13:12:27 <FunctorSalad_> @source Data.Tree.Tree
13:12:28 <lambdabot> Data.Tree.Tree not available
13:13:07 <dolio> dpratt71: If you think about them as functional programs, (forall y. P x y) is a function from values y to proofs that P x y holds, while P x y is a proof that P holds for particular x and y.
13:13:38 <dolio> dpratt71: So in forall x y. P x y -> Q x, the proof of Q x can only make use of some particular proof for P x y.
13:14:04 <dolio> Whereas in forall x. (forall y. P x y) -> Q x, it can make use of proofs of P x y for as many ys as it wants.
13:14:08 <lispy> jkingkong: a type synonym isn't powerful enough to do that
13:14:20 <lispy> jkingkong: you need a newtype or data
13:14:33 <edwardk> copumpkin: that seems to have worked. i now have 1oo lines of very ugly ghc-isms that give me the ability to store dual floats/doubles for STUArray s, IOUArray, and UArray
13:14:49 <edwardk> s/for/in
13:15:17 <edwardk> (and which should, nominally, also work for hugs)
13:15:18 <jkingkong> lispy: thanks so say I wanted to do this in newtype, what construct would I use?
13:15:33 <FunctorSalad_> instance (Eq a) => Eq (Tree a) -- instance Monad Tree -- instance (Data a) => Data (Tree a) -- instance Functor Tree -- instance (Read a) => Read (Tree a) -- instance (Show a) => Show (Tree a) -- instance Typeable1 Tree -- instance Applicative Tree --
13:15:40 <lispy> jkingkong: It really depends on what you're after
13:15:43 <FunctorSalad_> brought to you by: /exec -o ghc -e ":mo +Data.Tree" -e ":info Tree" | grep 'instance.*--' --only-matching | tr "\n" " "
13:15:46 <FunctorSalad_> ;)
13:16:12 <FunctorSalad_> hmm maybe I would have to import monoid to for the instance (if any) to show up...
13:16:18 <edwardk> triyo: they seem to have omitted it
13:16:50 <FunctorSalad_> *too
13:16:55 <jkingkong> lispy: so say newtype foo = bar [Int], where would the length condition come in?
13:16:57 <triyo> I think it has something to do with the foldable
13:17:02 <lispy> jkingkong: newtype FiveList a = FL [a]; mkFiveList :: [a] -> FiveList a; mkFiveList (a1:a2:a3:a4:a5:_) = FL [a1,a2,a3,a4,a5]; mkFiveList _ = error "wrong length"
13:17:24 <edwardk> triyo: that and it is ambiguous
13:17:25 <lispy> jkingkong: then hide the FL constructor so that everyone has to use mkFiveList
13:17:37 <jkingkong> lispy: ok so you would need to instantiate all instances of FiveList with that constructor
13:17:42 <triyo> a tree is foldable and foldable type constraint seem to be Monoid m
13:17:54 <FunctorSalad_> the thing folded into is a monoid
13:17:59 <FunctorSalad_> @ty Data.Foldable.foldMap
13:18:01 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
13:18:08 <lispy> jkingkong: right.  Now if you want to generalize the '5' it gets trickier, but it's still possible
13:18:12 <FunctorSalad_> not the `t' itself I thought...
13:18:25 <triyo> correct so my understanding is somewhat right? :)
13:18:27 <edwardk> triyo: trees have values in the nodes, and do not balance so the monoid isn't free
13:18:35 <jkingkong> lispy: yea that's exactly what i want, an IO parameter that controls of the lengths of a certain type
13:18:55 <edwardk> triyo: Foldable can be used to tear _down_ the tree and return any monoidal value you want, the functor itself need not be a monoid
13:18:58 <FunctorSalad_> triyo: that "m" is not a parameter of Foldable; it's universally quantified by the foldMap method
13:18:59 <jkingkong> lispy: i was finding it difficult/didn't know what to search for so I came here.
13:19:42 <FunctorSalad_> edwardk: I missed the context, why do we need a free monoid?
13:19:45 <edwardk> Tree is Foldable. if you have a function that maps its elements into a Monoid, you can apply foldMap with that function to extract some answer
13:19:50 <lispy> jkingkong: Well....in Oleg's implicit parameters paper he explains how to reify arbitrary values at distinct types.  You could combine that with the numerous papers that explain how to work with fixed length types (there was a linear algebra paper about this)
13:20:12 <edwardk> FunctorSalad_: you don't, but since Tree is (almost) the free magma it fails associativity without some form of very rigid balancing
13:20:24 <edwardk> FunctorSalad_: which Data.Tree decidedly doesn't provide
13:20:41 <FunctorSalad_> edwardk: is the data in the leafs or the nodes? (or is that irrelevant)
13:21:00 <edwardk> the data is in the nodes, if it was in the leaves, you'd get the free magma, hence the almost ;)
13:21:01 <jkingkong> lispy: great I don't mind reading and hacking away more before bothering you nice people :) do you have a link?
13:21:13 <lispy> jkingkong: hmm...let me see
13:21:19 <FunctorSalad_> data Tree a = Node {rootLabel :: a, subForest :: Forest a}
13:21:34 <FunctorSalad_> edwardk: ah. somehow the data-in-nodes worried me ;)
13:21:38 <lispy> jkingkong: http://okmij.org/ftp/Haskell/types.html#Prepose
13:21:41 <FunctorSalad_> (what to put in a new root?)
13:21:47 <edwardk> FunctorSalad_: exactly
13:22:00 <triyo> edwardk: I though data can be in node and leaf...
13:22:03 <edwardk> FunctorSalad_: i talked about this in my fingertree slides a couple weeks back actually =)
13:22:12 <edwardk> triyo: the leaf is a node with no children
13:22:19 <lispy> jkingkong: I think this one is the lin. alg. paper I was thinking of: www.ofb.net/~frederik/vectro/draft-r2.pdf
13:22:20 <edwardk> in that sense.
13:22:51 <triyo> oh thats what you mean
13:22:53 <FunctorSalad_> triyo: oh right, the n-branching-tree doesn't need special leafs... but for our problem to arise it's enough that nodes have to have data
13:22:56 <jkingkong> lispy: awesome thanks
13:23:00 <lispy> jkingkong: also this http://hackage.haskell.org/package/Vec
13:23:12 <edwardk> but you could build a tree that worked with data Tree a b = Bin a (Tree a b) (Tree a b) | Tip b -- which stored data in the leaves differently than the nodes. in that sense Tip is the actual 'leaf'
13:23:36 <edwardk> FunctorSalad_: even without data you have the problem of associativity
13:23:50 <FunctorSalad_> type Forest a = [Tree a] 	-- Defined in Data.Tree
13:23:57 <FunctorSalad_> (for reference)
13:24:22 <edwardk> forest has a monoid instance (its free!) ;)
13:24:30 <edwardk> but tree is pretty much screwed ;)
13:24:32 <jkingkong> lispy: i Had not seen Data.Vec before, I might experiment with it. If it performs well, it might be a simpler solution
13:24:38 <FunctorSalad_> edwardk: hmm equivalence relation to the rescue? t1 ~ t2 iff inorder(t1) == inorder(t2)
13:24:45 <FunctorSalad_> or preorder, dunno what we need here
13:25:11 <lispy> jkingkong: okay, and if the IO parameter controlling size becomes important the Oleg paper should cover that
13:25:12 <edwardk> FunctorSalad_: yeah but then every function you write should check that it satisfies that condition, that becomes a bit annoying if you expose constructors, etc.
13:25:27 <edwardk> FunctorSalad_: i do it now and again, but i try to avoid exposing my invariants
13:25:29 <FunctorSalad_> *nod*
13:26:22 <dpratt71> I need some terminology to express a question? what is the business on the left side of a => called?
13:26:23 <jkingkong> lispy: great thanks, just to be clear, which paper exactly on your first link were you referring to when you say "Oleg paper"?
13:26:31 <FunctorSalad_> (hmm... these trees don't appear to even have an inorder traversal)
13:26:33 <edwardk> http://comonad.com/reader/wp-content/uploads/2010/04/Finger-Trees.pdf slide 20 talks about the monoid issue here in fact ;)
13:26:43 <lispy> jkingkong: the implicit configurations paper
13:27:02 <lispy> jkingkong: the link should have had an anchor
13:27:42 <lispy> jkingkong: you'll know you have the right paper when he uses type classes to convert between types and values
13:27:53 <lispy> it's magical
13:28:10 <edwardk> its also packaged up on hackage as 'reflection'
13:28:14 <edwardk> (with minor edits)
13:28:26 <edwardk> mostly for safety
13:28:33 <jkingkong> lispy: yea this is quite fantastic actually, didn't notice the anchor sorry
13:28:50 <lispy> edwardk: ah cool
13:28:53 <lispy> jkingkong: np
13:29:23 <lispy> jkingkong: I recommend reading over Oleg's website if you get bored.  I wouldn't necessarily use his inventions but he has amazing ideas
13:29:30 <edwardk> lispy: i needed it so i bundled it up, the only real difference is instead of using funtions passing around undefined values i pass around elements of newtype Tagged s a = Tagged a
13:29:47 <edwardk> older versions provided the original oleg/shan api
13:30:03 <jkingkong> lispy: hehe will do. man, I'm such a haskell noob but I feel like this channel will make me somewhat proficient in no time
13:30:16 <lispy> jkingkong: it's true!
13:30:18 <lispy> it will
13:30:35 <edwardk> jkingkong: keeping the channel open helps a lot. ;)
13:30:51 * edwardk osmosed a good deal of info from this place
13:30:53 <tensorpudding> Also experimenting with the interpreter.
13:31:01 <tensorpudding> Or lambdabot.
13:31:02 <FunctorSalad_> . o O ( TH macro for closures-who-know-their-definition? )
13:31:20 <edwardk> functorsalad is seeking closure
13:31:22 <jmcarthur> jkingkong: yeah, there's always interesting stuff flowing through this channel
13:31:23 <FunctorSalad_> for debugging etc...
13:31:31 <FunctorSalad_> edwardk: about what? :)
13:32:08 <Silvah> Abandon all the hope, I'm back...
13:32:13 <FunctorSalad_> it just seems that the blackbox-ness of closures is not so good for interactive development
13:32:24 <edwardk> FunctorSalad_: you could do quasiquotation to get some inspection like that
13:32:33 <FunctorSalad_> (this isn't about closures specifically, just function values)
13:32:57 <edwardk> i do think it'd be funny to use haskell-src-exts and a quasiquoter to write 'haskell linq' ;)
13:33:13 <edwardk> with real introspection, etc.
13:33:32 <FunctorSalad_> edwardk: yes, I imagined one would quote an function-expression of type a -> b, and the quasiquoter would turn it into a value of type "FunctionWithMetadata a b" or osmething
13:34:00 <FunctorSalad_> downside: space isn't overloadable; you're have to write "apply f args" all the time
13:34:06 <edwardk> FunctorSalad_: its not hard. you can store the ExpQ as data and marshal it to runtime, the code you want is like 30 lines long
13:34:16 <edwardk> FunctorSalad_: you can fix that
13:34:24 <edwardk> its not hard
13:34:34 <edwardk> just needs  a rank 2 type
13:34:42 <FunctorSalad_> edwardk: is your metadata in the values itself here, or do you leave the "a -> b" alone and make a lookup map or something
13:35:43 <edwardk> lemme show you what i mean with an array example with 'overloaded whitespace'
13:36:34 <edwardk> (trying to find it)
13:36:55 <edwardk> i pasted it somewhere a month or two back, i really should just blog it so i can't lose it ;)
13:38:21 <EvanR-work> can i make a ReaderT r IO a -> ReaderT r IO a that catches IO errors
13:38:36 <FunctorSalad_> "a -> b" becomes "a -> PlusMetadata b"?
13:38:38 <matt_m> dpratt
13:38:54 <FunctorSalad_> (but you must have something better in mind, since that would only solve one step, then the types don't fit again)
13:38:55 <matt_m> dpratt:  I think it's usually called the 'context'
13:39:00 <matt_m> or constraints
13:39:10 <c_wraith> EvanR-work: I'm not sure that type signature makes sense.  How will it return that type when it catches an error??
13:39:24 <matt_m> dpratt71: ^
13:39:27 <EvanR-work> c_wraith: by using exitFailure
13:39:43 <aristid> @djinn a -> b -> c -> (a, b, c)
13:39:43 <lambdabot> f a b c = (a, b, c)
13:39:56 <aristid> @pl f a b c = (a, b, c)
13:39:56 <lambdabot> f = (,,)
13:40:05 <edwardk> drat it was pasted to moonpatio =(
13:40:18 <c_wraith> EvanR-work: heh.  I suppose, but that doesn't feel composable.
13:40:49 <EvanR-work> ironically, i want to compose it with my already written code without modifying anything
13:41:11 <edwardk> FunctorSalad_: you can do better by defining a class Reflected which has instances for (a -> b) and Meta a b -- and then passing around values of type Magic a b = (forall t. Reflected t => t a b)  -- instead of Meta a b
13:41:15 <c_wraith> And a Maybe is too much?
13:41:25 <EvanR-work> i need to catchSql
13:41:27 <edwardk> FunctorSalad_: that value can be used as a function (a -> b) -- or as a Meta a b
13:41:36 <EvanR-work> these IO actions dont return maybe
13:41:50 <c_wraith> EvanR-work: my point is that your handler could return Maybe
13:42:14 <EvanR-work> the correct thing to do is unlock a semaphore and then exit
13:42:27 <edwardk> you just define a member to class Reflected t where reflect :: Meta a b -> t a b; instance Reflected Meta where reflect = id; instance Reflected (->) where reflect (Meta _ f) = f -- or something like that
13:42:32 <c_wraith> that terrifies me, but I won't question it. :)
13:42:38 <EvanR-work> hmm. maybe i should put a ContT arround the whole thing ;)
13:42:41 <c_wraith> You can write such a function pretty easily.
13:43:12 <EvanR-work> well i thought it would be easy but i cant get it to match up
13:43:16 <c_wraith> You just need to use a combination of catch, lift, and maybe runReaderT
13:43:25 <FunctorSalad_> edwardk: interesting
13:43:27 <edwardk> FunctorSalad_: So generate (Meta a b) at compile time then apply reflect to that, and pass it around as (forall s. Reflected t => t a b) instead of as Meta a b
13:43:44 <FunctorSalad_> edwardk: uhm but if you use it as a function... isn't the metadata discarded?
13:44:18 <edwardk> FunctorSalad_: only in at the moment. its still available if you use the value again with the other type.
13:44:34 <edwardk> its rank 2, so you can use it as both
13:44:50 <FunctorSalad_> I mean the result will be a plain "b"
13:45:05 <edwardk> i thought you wanted a function that you could ask questions about
13:45:13 <edwardk> not that you could ask questions about the responses to
13:45:14 <EvanR-work> c_wraith: catchSql takes IO a and returns IO a, i can use lift to make it return ReaderT, but it will not accept one...
13:45:19 <edwardk> that is a different problem ;)
13:45:23 <FunctorSalad_> edwardk: I just realized that too
13:45:32 <c_wraith> EvanR-work: that's why you'd need runReaderT
13:45:49 <edwardk> you can fiddle with the trick to make it fit that scenario as well, but its awkward
13:45:50 <EvanR-work> ok
13:46:20 <FunctorSalad_> edwardk: but if "b" is a function it might be part of this problem
13:46:25 <edwardk> the demo i pasted was an array that worked as an "FArray" i e or as (i -> e) depending on how you used it
13:46:28 <FunctorSalad_> (rather than of tracing everything)
13:47:07 <edwardk> but if you're slick about it you can give back Magic a (Magic b (Magic c d))) -- rather than a -> b -> c -> d
13:47:49 <edwardk> so the result of applying one level is still Magic ;)
13:48:41 <dpratt71> matt_m: I just saw your response, thanks
13:48:54 <edwardk> (that probably begs for an infix type constructor though)
13:51:23 <FunctorSalad_> edwardk: I meant that applying Magic a (Magic b c) to an `a' should probably result in something with metadata the metadata of the function, plus the value inserted (if we want *all* function values to be introspectable)
13:51:57 <FunctorSalad_> edwardk: which amounts to trace-everything I think, since values can just be simulated as () -> Foo ...
13:52:00 <edwardk> well, you might require that Magic encapsulates a Data instance for its argument so you can use it to reflect upon the argument passed to the outer magic
13:52:32 <FunctorSalad_> that's a problem too
13:52:55 <FunctorSalad_> (the values have to be introspectable... maybe just constrain with 'Show'?)
13:53:20 <FunctorSalad_> unless they're functions, then you recurse... sounds complicated all in all
13:53:38 <edwardk> straw man: data Magic a b where Magic :: (Show a, Data a) => Exp -> (a -> b) -> Magic a b
13:53:55 <edwardk> (though you could always just use gshow)
13:54:07 <edwardk> (it probably also needs Data b)
13:54:24 <edwardk> er s/Magic/Meta/ to be consistent with the earlier discussion
13:56:20 <edwardk> the TH splice just glues together 'reflect (Meta (the data for the ExpQ it extracted) (the output of compiling the fragment normally))
13:56:22 <mreh> have I ever bitched to you before about Henning Theilmann's modules?
13:56:34 <mreh>  /o\
13:56:38 <edwardk> mreh: no, but i've ranted enough about it for both of us
13:56:41 <FunctorSalad_> mreh: if not you then someone else
13:56:42 <edwardk> er them
13:56:49 <FunctorSalad_> hehe
13:57:15 <edwardk> mreh: at least the haddock output is predictable....
13:57:31 <edwardk> i always know what something will be called, even if i can't figure out which C or T he meant ;)
13:58:23 <mreh> and you have these functions that wrap one T in another T, and the damn function is named after the T you're wrapping
13:58:49 <Philonous> Apparently code obfuscation isn't only for java developers
13:58:55 <EvanR-work> c_wraith: i tried every permutation of identifiers and valid parentheses, and finally found the 'solution' ;)
13:59:38 <FunctorSalad_> edwardk: wait which problem do you mean is solved by what you last wrote?
13:59:44 <edwardk> Philonous: i find the output of 'remorse' more legible ;) I can at least differentiation (.--|.--|.--) from (..-|..-|..-) ;)
14:00:05 <c_wraith> EvanR-work: isn't it easier to work based on types, rather than brute force? ;)
14:00:11 <FunctorSalad_> (I thought the def of Magic should be something like that all along, if we don't need the overloaded space)
14:00:52 <mreh> and he names constructors after the type of the thing it constructs with, not the thing it constructs
14:00:59 <edwardk> FunctorSalad_: the fragment above provides something consistent with the universally quantified Magic type which can be easily generated. the reflect (Meta .... ...) code is emitted at compile time by the splice
14:01:04 <FunctorSalad_> mreh: :D
14:01:10 <edwardk> the result can be used as a function or as Meta
14:01:19 <EvanR-work> c_wraith: i know why its wrong in every case, thanks to types ;)
14:01:33 <mreh> e.g. data Primitive = Atom Dur (Atom note)	
14:01:42 <mreh> type Atom note = Maybe note
14:01:51 <EvanR-work> but its like a chinese box puzzle
14:02:02 <EvanR-work> except in reverse
14:02:05 <jkingkong> random question: what is the name of the '$' symbol?
14:02:10 <mreh> dollar
14:02:14 <EvanR-work> dollar sign
14:02:18 <mauke> U+0024 (24): DOLLAR SIGN [$]
14:02:21 <jkingkong> i was hoping it'd be something cool like "bank"
14:02:21 <mreh> function application to some people
14:02:29 <EvanR-work> cold hard bengies
14:02:30 <jkingkong> or "bling"
14:02:32 <mreh> "function application"
14:02:48 <jkingkong> kinda like how "#" and "!" are cool
14:02:51 <jkingkong> that is all
14:02:59 <mauke> U+0023 (23): NUMBER SIGN [#]; U+0021 (21): EXCLAMATION MARK [!]
14:03:01 <FunctorSalad_> edwardk: why not just let another QQ handle the special application btw?
14:03:08 <FunctorSalad_> instead of letting the type system handle it
14:03:16 <jkingkong> mauke: awww, not "pow" and "bang?"
14:03:27 <mreh> haha
14:03:31 <mreh> ! is called bang
14:03:36 <edwardk> foo = [$magic | \x y z -> x + y * z + 12 ] -- foo :: (Data a, Num a) => Magic a (Magic a a) -- bar = foo 12 -- bar :: (Num a, Data a) => Magic a a
14:03:41 <mauke> # is called octothorpe
14:03:41 <mreh> it's the "bang pattern"
14:03:50 <edwardk> FunctorSalad_: because it is more pleasant to use =)
14:05:53 <jkingkong> mreh: yea loved that, who needs to say "There exists a unique foo" if you can just say "e bang foo"
14:05:59 <FunctorSalad_> edwardk: ok but higher-ranked types can cause inconveniences too
14:06:26 <edwardk> FunctorSalad_: sure. whenever you need to ditch the higher rank type, just dumb it down to Meta. when you want Magic again, just 'reflect'
14:06:37 <FunctorSalad_> edwardk: ahh
14:06:43 <edwardk> meta :: Meta a b -> Meta a b; meta = id
14:06:58 <FunctorSalad_> Magic a b -> Meta a b I guess
14:07:13 <edwardk> nah, nothing hurt by using the stronger type ;)
14:08:06 <edwardk> er weaker, that was in negative position
14:08:26 <FunctorSalad_> except the point? j/k ;)
14:08:42 <FunctorSalad_> (thought you were telling me how to get a Meta from a Magic ;))
14:09:29 <edwardk> yes. just put a type constraint on it, meta :: Meta a b -> Meta a b; meta = id can be applied to Magic, since Meta is an instance of Reflect
14:10:49 <FunctorSalad_> ah
14:10:51 <edwardk> If i pass a function of type Int -> Int a value of type (forall a. Num a) -- it gets turned into an Int before hand. same thing here
14:11:00 <edwardk> er forall a. Num a => a
14:12:03 <FunctorSalad_> I'm aware your type for `meta' is legal; I just thought `meta' is our conversion function once and for all, then Magic a b -> Meta a b would be more clarifying
14:12:16 <edwardk> *nods*
14:12:40 <edwardk> i like the tighter type because then meta . meta works
14:12:54 <lispy> Cale: Oh, I guess that linode maintenance is tonight
14:13:02 <edwardk> while the other is more clarifying the simpler type is more useful =)
14:13:04 <lispy> So, no lambdabot for a bit this evening
14:15:02 <edwardk> i think the tricky bit will be reifying the Exp in the right way, because it needs to do some pretty smart things in the code that it emits for the Exp. it needs to grab each variable referenced in the body of your splice so it knows the value of the environment it closes over
14:15:45 <edwardk> what way functions that foo x = [$magic| \y z -> ... |] does the right thing
14:15:48 <edwardk> er like
14:15:53 <edwardk> and do
14:18:31 <edwardk> hrmm, i think a better version wouldn't rely on the (->) though
14:18:56 <FunctorSalad_> edwardk: you mean it should print closures like "(source expression) (x := bla)" ?
14:19:11 <EvanR-work> to use a Reader r inside a ReaderT r m, do i need to use runReader
14:19:11 <FunctorSalad_> (and for that it'd need to find the names of the params?)
14:19:21 <EvanR-work> or is there some lift like thing
14:19:25 <edwardk> FunctorSalad_: something like that. or at least be able to substitute in blah for x everywhere x originally occured in the source
14:19:41 <edwardk> by using data to reflect x into a valid Exp fragment
14:20:01 <FunctorSalad_> EvanR-work: if you're using the mtl that has tmap (?) you'd just apply the function that converts the Id monad to m
14:20:31 <EvanR-work> :t tmap
14:20:32 <lambdabot> Not in scope: `tmap'
14:21:01 <edwardk> so foo x = [$magic| \y z -> (y * z + x,"Hello") |]; showMeta (foo 12)   ==> "\y z -> (y * z + 12,\"Hello\")" -- would be reasonable
14:21:08 <FunctorSalad_> (forall a. m a -> n a) -> T m b -> T n b
14:21:15 <FunctorSalad_> for T your trafo
14:21:27 <FunctorSalad_> thought one of the mtl improvements has it
14:21:41 <FunctorSalad_> m = Identity for you
14:22:03 <FunctorSalad_> (assuming Reader _ is a syn for ReaderT _ Identity in that lib)
14:22:14 <EvanR-work> mmkay
14:22:45 <edwardk> but as for the better Meta i think you could do something like: data Meta a = Meta Exp a; data Meta1 f a = Meta1 Exp (f a); data Meta2 a b c = Meta2 Exp (a b c) -- with appropriate reflections so that you get the right number of arguments, etc.
14:23:00 <edwardk> (otherwise you get really nasty type errors)
14:23:58 <edwardk> so an Magic (a -> b) could be used as (a -> b), Meta2 (->) a b, Meta1 (-> a) b or Meta (a -> b)
14:24:23 <FunctorSalad_> edwardk: hmm you don't need to know the name of the param if you just log an application as a formal application though
14:24:54 <byorgey> edwardk: btw, when are you arriving?
14:25:09 <edwardk> sure, but its nice when reflecting to reflect the source form anyways, especially if you use it like linq where that can have meaning
14:25:23 <FunctorSalad_> edwardk: [$magic| \x y z -> .... ] ?
14:25:24 <edwardk> byorgey: tomorrow before noon some time. we're catching an early train
14:25:25 <FunctorSalad_> (missing x
14:25:26 <FunctorSalad_> )
14:25:52 <byorgey> edwardk: ok, sounds good!
14:26:00 <edwardk> functorsalad: deliberately i wanted $magic| to have to close over the environment and extract a value ;)
14:26:24 <byorgey> edwardk: come by whenever you get here, I'm sure you'll enjoy Trevor Jim's talk
14:26:26 <edwardk> the emitted code from the splice there should do something that captures x
14:26:38 <FunctorSalad_> edwardk: missed the x on the LHS
14:26:49 <edwardk> will do =)
14:27:06 <edwardk> i think we get in around 9-10am
14:27:36 <byorgey> cool, I will be here
14:27:48 <edwardk> FunctorSalad_: at this rate i'm thinking about just coding this up ;)
14:28:18 <soupdragon> what was that hack to count the number of bits in an integer?
14:28:27 <FunctorSalad_> edwardk: hmm but don't you get into the whole business of name handling this way?
14:28:45 <FunctorSalad_> shadowing, capture-free subst etc etc
14:28:55 <FunctorSalad_> I avoid that whenever possible ;))
14:29:03 <edwardk> you can handle that by using a trick i stole from sclv that uses hoas during the translation from TH to the generated code
14:29:06 <monochrom> n := bitwise-and n with n-1. keep doing until n=0. count iterations.
14:29:17 <edwardk> its used in jmacro to allow hygienic macros
14:29:25 <shapr> Ya know, I wish ghci had some way to dump the haddocks for a function like Python does with help(function)
14:29:26 <monochrom> oops, that counts the number of set bits, not all bits. :)
14:29:52 <FunctorSalad_> casting -1 to Word should set all bits...
14:30:06 <soupdragon> yeah I meant set bits
14:30:07 <FunctorSalad_> maybe not on all machines :o
14:30:13 <monochrom> ok cool
14:30:26 <FunctorSalad_> why not just right-shift?
14:30:35 <FunctorSalad_> (binary search maybe)
14:30:50 <FunctorSalad_> to find the smallest shift amount that zeroes it
14:32:14 <shapr> There must be some way to dump haddocks along with the type sig...
14:32:23 * shapr shrugs
14:32:23 <lispy> FunctorSalad_: xor with itself?
14:32:45 <FunctorSalad_> lispy: huh? that's zero
14:32:47 <nostrand> hi, i'm doing some stuff with HGL, what's the easiest way to control FPS?
14:33:17 <jmcarthur> shapr: yeah that would rock
14:33:28 <shapr> I wonder how to do it?
14:33:41 <dv-> nostrand: sdl-gfx has a nice fps control mechanism
14:33:41 <EvanR-work> nostrand: by correctly simulating the time of the game and only drawing if something is updated
14:33:55 <EvanR-work> sdl_gfx fps control is stupid
14:34:18 <dv-> ok...
14:34:19 <nostrand> EvanR-work: ok, and how do i do that? :P
14:34:35 <nostrand> dv-: i rather use HGL, it's pretty simplistic =)
14:34:46 <EvanR-work> nostrand: well theres the science of a sane main loop
14:35:13 <EvanR-work> nostrand: different opinions and desired properties, personally i like a deterministic evolution, which means fixed time steps (like 10ms)
14:35:44 <nostrand> EvanR-work: ok, but i have no idea how to control that
14:35:53 <EvanR-work> to support this you need an IO action that gives you the exact time in at least milliseconds
14:36:41 <EvanR-work> sdl has a crossplatform version of that, i dont know about the haskell standard lib
14:37:14 <Philippa> it's not really something that belongs in the standard lib
14:37:23 <Philippa> it belongs in a (meta-)platform lib
14:37:34 <edwardk> Philippa: yeah
14:37:42 <EvanR-work> so you can use sdl function getTicks
14:37:52 <EvanR-work> doesnt mean you have to use sdl for graphics or anything else
14:38:18 <FunctorSalad_> I didn't realize there's a clear difference standard/platform :)
14:38:34 <FunctorSalad_> 'standard' must be portable?
14:38:46 <nostrand> EvanR-work: yeah, but i can't use SDL. Is there a hack in standard library?
14:39:00 <Philippa> the Haskell standard lib needs to be portable as widely as Haskell can be used, yeah
14:39:12 <Philippa> so it shouldn't rely on eg POSIX functionality
14:39:29 <Philippa> in general, timing support is too variable for the standard lib
14:39:31 <EvanR-work> nostrand: no, but you can use System.Posix for example
14:39:37 <nostrand> oki
14:40:22 <nostrand> there's a Time library though
14:40:44 <shapr> Does Network.HTTP do url encoding?
14:41:06 <shapr> @index urlencode
14:41:06 <lambdabot> bzzt
14:41:08 <shapr> foo
14:42:00 <shapr> Aha, cabal install urlencoded
14:42:14 <EvanR-work> nostrand: well, do you see milliseconds
14:42:37 <nostrand> EvanR-work: i'm about to find out =)
14:42:59 <Philippa> EvanR: seeing them doesn't mean having a timer with millisecond resolution
14:43:44 <EvanR-work> you only need certain properties to be accurate
14:44:50 <nostrand> EvanR-work: it shows picoseconds
14:45:24 <jmcarthur> doesn't mean it measures them properly
14:45:34 <jmcarthur> in fact, i can almost guarantee you it doesn't
14:45:53 <EvanR-work> the time of day is never exact
14:45:58 <EvanR-work> the computer clocks are all crap
14:46:18 <Philippa> the Time library's mostly a datatype for talking about time and appropriate operations for manipulating it, isn't it?
14:46:23 <EvanR-work> what is important is that the integral of all calls to a differential clock add up to the same wall time as the computer time
14:47:09 <McManiaC> dcoutts: ping
14:47:19 <dcoutts> McManiaC: pong
14:47:19 <Philippa> having sufficient resolution tends to matter too
14:47:35 <McManiaC> dcoutts: how do I install gtk2hsC2hs?
14:47:56 <McManiaC> Configuring cairo-0.10.5...
14:47:56 <McManiaC> setup: gtk2hsC2hs is required but it could not be found.
14:48:51 <dcoutts> McManiaC: it's in the tools directory, the gtk2hs-buildtools package
14:49:09 <shapr> Haskell is so awesome :-) Type inference and REALLY strong types!
14:49:13 * shapr boings cheerfully
14:49:20 <McManiaC> yeh but theres no cabal file for c2hs?
14:49:22 <McManiaC> oh
14:49:28 <McManiaC> theres one for tools
14:49:29 <McManiaC> :>
14:49:33 <McManiaC> kk
14:49:39 * gwern wonders why shapr is propagandizing us
14:49:41 <dcoutts> McManiaC: right, there are 3 tools
14:49:51 <McManiaC> 3?
14:49:51 <monochrom> real types for real programmers
14:49:54 <shapr> gwern: Hey, I did it for years!
14:49:57 <McManiaC> I see a few more
14:50:01 <FunctorSalad_> gwern: after some time with only haskell, one begins to feat that one has just become a mindless zealot
14:50:08 <FunctorSalad_> then one has to use sth else...
14:50:14 <shapr> gwern: I'm just enjoying how quickly the code starts working!
14:50:18 <gwern> FunctorSalad_: shapr saying that doesn't really help with the zealot issue
14:50:21 <FunctorSalad_> s/feat/fear/
14:50:28 <FunctorSalad_> ^^
14:50:32 <Philippa> shapr: I'm probably going to give up on Anglohaskell this year, convince me otherwise?
14:50:40 <gwern> shapr: if you did it for years, isn't that all the more reason to cease?
14:50:44 <FunctorSalad_> shapr doesn't appear very ideologically-minded to me, actually
14:50:48 <jmcarthur> shapr: you doing hac phi this year?
14:50:48 <shapr> gwern: Er, why so?
14:50:56 <FunctorSalad_> (ideologically in the negative sense)
14:51:10 <shapr> jmcarthur: Doubt it.. I could get a flight, but can't afford to get a hotel room.
14:51:16 <jmcarthur> ah
14:51:19 <gwern> shapr: is an offense mitigated by perseverating?
14:51:21 <McManiaC> dcoutts: ok great, it finally built :) thx
14:51:31 <shapr> gwern: Er, you think propaganda is offensive?
14:51:44 <gwern> yes
14:51:47 <gwern> that's kind of built into the word
14:51:50 <jmcarthur> shapr: i'm not either. didn't make a decision soon enough and now the prices are much higher
14:52:07 <jmcarthur> shapr: plus benalene would want to come with, so that's double the cost
14:52:20 <shapr> gwern: Happily, that wasn't propaganda! I was just exclaiming about how happy I get when writing Haskell, as opposed to writing other languages.
14:52:21 <edwardk> shapr: doh, had you said something i would have split a room with you
14:52:24 <gwern> jmcarthur: you and shapr can't couch-surf with anyone?
14:52:42 <shapr> edwardk: Didn't know you were going...
14:52:46 <shapr> edwardk: You already have a roomie?
14:52:49 <edwardk> shapr: dragging chris
14:52:50 <jmcarthur> gwern: the flight alone would cost my wife and i like $800
14:52:58 <shapr> edwardk: Hah, that'll be fun.
14:53:04 <gwern> jmcarthur: yes, well...
14:53:13 <edwardk> if you asked him real nice he might let you sleep on the floor ;)
14:54:02 <gwern> I don't know what people have against sleeping on floors. what's the problem?
14:54:16 <edwardk> jmcarthur: i think with the wife in tow it probably doesn't break even, but on your own i think it would have been worth it
14:54:16 <c_wraith> gwern: It gets tiring after a few days
14:54:23 <gwern> there are whole nations which sleep on floors, and not poor ones either
14:54:25 <FunctorSalad_> gwern: "propaganda" has seen some rehabilitation through self-ironic use I think
14:54:28 <FunctorSalad_> the word
14:54:33 <gwern> FunctorSalad_: nigger what
14:55:11 * soupdragon agrees with FunctorSalad
14:55:11 <FunctorSalad_> (my specification "'ideologically', in the neg. sense", otoh, was quite redundant)
14:55:11 <jmcarthur> huh, looks like it dropped a little today though. down to $729
14:55:25 <monochrom> the problem is that no one sleeps on floor literally
14:55:30 <shapr> gwern: But seriously, you think that exclaiming how much I enjoy Haskell is propaganda?
14:55:55 <jmcarthur> that's counting hotel
14:56:00 <monochrom> if you point at japan, they sleep on reasonably thick things on floor, not sleep on floor
14:56:29 * FunctorSalad_ mostly sits on the floor when computing, lately
14:56:32 <Philippa> shapr: depends a bit on where you do it
14:56:43 <gwern> shapr: you didn't say, say, 'I love Haskell more than dark chocolate'; you proclaimed the excellence of haskell with some reasons
14:56:45 <Philippa> OTOH, there's definitely something up when you can't do it in
14:56:46 <FunctorSalad_> chairs and I just don't get along too well
14:56:47 <Philippa> #haskell
14:56:52 <FunctorSalad_> (when used for 14 hours)
14:56:59 <edwardk> jmcarthur: you are clearly still angsting about this ;)
14:57:10 <gwern> FunctorSalad_: how do you do that? cross-legged?
14:57:15 <Philippa> I mean sure, the chan has changed in the last few years...
14:57:22 <gwern> not full lotus I suspect as awesome as that would be
14:57:23 <shapr> gwern: Ok, so what does that mean? That it was not propaganda because I had something to back it up?
14:57:23 <jmcarthur> edwardk: actually just wondering at the volitility of airline tickets
14:57:29 <FunctorSalad_> gwern: you can change between several positions, that's an advantage
14:57:36 <hpc> FunctorSalad_: couch all the way
14:57:41 <edwardk> we'll be getting ready to finish up and jmcarthur will still be on irc wondering if it'd be a break even proposition to go _now_ ;)
14:57:41 <jmcarthur> *volatility of airline ticket prices
14:57:52 <gwern> shapr: yup. propaganda usually has reasons
14:57:54 <edwardk> *nods*
14:57:56 * Philippa does have a problem with some of the overstatement of what Haskell can do, but...
14:58:15 <jmcarthur> @faq can haskell solve world hunger?
14:58:15 <lambdabot> The answer is: Yes! Haskell can do that.
14:58:20 <shapr> gwern: Er, ok... in any case, I'll go back to coding...
14:58:21 <FunctorSalad_> gwern: (with one of these little tablets to but the laptop on)
14:58:29 <gwern> our bodily types are pure, and uncontaminated by fluoride!
14:58:55 <hpc> at least it isn't bromidation
14:58:59 <Philippa> jmcarthur: I'd kinda like to see @faq removed actually, it does promote the image that we're a bunch of smug mutual mental masturbators
14:59:28 <jmcarthur> Philippa: it would at least be nice if it was more of a magic 8 ball than a yes man
14:59:38 <sm> asked yesterday "so does haskell really make crashproof programs ?!!" honesty forced me to waffle a bit
14:59:38 <Saizan_>  @faq made sense against people like @protontorpedo i think
14:59:48 <mapreduce> fwiw, faq got copied to ##java's bot, as: "Yes, IDEA can do that", where IDEA is an IDE.
14:59:49 <gwern> FunctorSalad_: yeah, but how do you sit mostly? unless you go through the kama sutra there must be some predominant position
14:59:51 <edwardk> jmcarthur: that might encourage an increase in its usage though
14:59:55 <Saizan_> or when someone asks "can haskell do I/O?"
14:59:59 <FunctorSalad_> a "worship"-like 180degree-bend at the knees, with the feet close to the rear works too as a relief from strain from the usual position
15:00:11 <Philippa> edwardk: so long as some of the responses are snarky
15:00:19 <bateman> you can make useful programs without I/O
15:00:21 <FunctorSalad_> gwern: and leaning against a wall is another one
15:00:36 <edwardk> @src i get a bit annoyed at the snark
15:00:39 <Philippa> only insofar as something around them provides the IO
15:00:50 <lambdabot> Source not found. That's something I cannot allow to happen.
15:00:56 <bateman> no the trule useful programs perform no I/O
15:01:04 <gwern> weird
15:01:06 <Philippa> yeah, but @src is different, it's a utility
15:01:14 <Philippa> @faq is... well, a community position statement
15:01:14 <lambdabot> The answer is: Yes! Haskell can do that.
15:01:16 <FunctorSalad_> gwern: and you can lie down too
15:01:17 <bateman> a program that performs I/O is not pute
15:01:18 <edwardk> @source but why is it only snarky sometimes
15:01:18 <lambdabot> but why is it only snarky sometimes not available
15:01:22 <bateman> I mean pure
15:01:33 <edwardk> we have one snarky one and one non-snarky one ;)
15:01:33 <gwern> FunctorSalad_: but how can you type lying down ??
15:01:42 <bateman> unpure programs are imho undesirable
15:01:55 <Philippa> bateman: I think you've suffered a major misunderstanding somewhere
15:02:05 <bateman> the very best programs are not even used in a computer
15:02:06 <Philippa> with no IO happening anywhere, /you don't know the program's result/
15:02:12 <soupdragon> ummmmm
15:02:19 <gwern> @quote Impure!
15:02:20 <lambdabot> Berengal says: '"Go away! You're not like us!" the other values yelled. "You're impure! Impure! Impure! Impure!" they started chanting.'
15:02:20 <bateman> as that would actually cause side effects even though it was pure
15:02:22 <FunctorSalad_> gwern: yes with the laptop close to you it's crappy since your fingers are nearly parallel to the rows :|
15:02:22 <soupdragon> didn't bateman just get kicked out a moment ago
15:02:47 <bateman> I like to write my Haskell programs on paper
15:02:49 <FunctorSalad_> gwern: it's better with the laptop against the legs or so I think
15:02:54 <soupdragon> oh no I mixed up the names, sorry
15:02:55 <FunctorSalad_> (knees angled up)
15:03:03 <Philippa> bateman: that's pathetic. It involves IO
15:03:07 <jmcarthur> bateman: good trolls don't get kicked
15:03:10 <bateman> so I'm sure there are no side effects other than wasting paper
15:03:17 <shapr> bateman: Be nice
15:03:17 <Philippa> the best Haskell programs have no physical representation
15:03:32 <soupdragon> on the other hand, he has the same username
15:03:33 <bateman> Philippa: agreed
15:03:35 <Philippa> I know, because I never get round to writing them :-)
15:03:41 <ivanm> bateman: you forgot the usage of ink/graphite; the energy expenditure of writing it; etc.
15:03:49 <Philippa> anyway, @faq and propaganda
15:03:49 <bateman> the very best Haskell programmers simply think about their programs
15:04:06 <FunctorSalad_> gwern: one of the worst things one can do is sit on a bed, I found...
15:04:09 <bateman> but even that incurs some side effects
15:04:11 <shapr> So, has anyone used the google maps api to turn an address into a latitude and longitude?
15:04:13 <Philippa> I've had a few awkward interactions in here when I've had to cool someone's enthusiasm about quite what Haskell can and can't do
15:04:15 <FunctorSalad_> for some reason that's a back-destroyer
15:04:27 <shapr> I'm working on a website where I want to look for nearby items, so I want a gmaps interface.
15:04:30 --- mode: ChanServ set +o monochrom
15:04:46 <shapr> Thus I can turn zipcodes into distance from the authenticated user.
15:04:50 * soupdragon has always failed at that
15:04:52 <bateman> monochrom: kicking is not a pure operation
15:05:02 --- mode: monochrom set +b *!~55c89673@*
15:05:10 <jmcarthur> bateman: fate sealed. bye :)
15:05:12 --- mode: monochrom set -o monochrom
15:05:28 <monochrom> and so I just ban and not kick. it sufficies.
15:05:33 <jmcarthur> lol
15:05:40 <Philippa> all I'm sayin' is that my old TMR 2-issue column was called Impure Thoughts...
15:05:49 <soupdragon> those were fun
15:06:05 <BMeph> I prefer @faq to @src. You can trust @faq not to give any useful information, whereas with @src, people always suspect that it's not just a picture of how the function works, but how that function really does work.
15:06:07 <shapr> Ah, I want geocoding, and it's only for use on an actual google map display, foozle.
15:06:17 <jmcarthur> monochrom: i actually think it would be more fun to just +q most trolls
15:06:35 <monochrom> actually yeah :)
15:06:53 <FunctorSalad_> BMeph: it isn't? I knew it was manually entered, but from the... ahem, source, I presumed
15:06:56 <Philippa> BMeph: yeah, but for a newbie who gets @faqed it's... well, annoying realising that someone went to that effort just to always give the same, smug answer
15:07:03 <Philippa> it's a newbie disservice
15:07:09 <monochrom> Someone should create a magazine called The Lazy Writer
15:07:20 <edwardk> shapr: you should be able to extract that from just the tiger line data, etc. so you don't need google for it
15:07:21 <FunctorSalad_> yes @faq gets boring fast, too
15:07:27 <jmcarthur> monochrom: full of empty pages?
15:07:28 <shapr> edwardk: Eh?
15:07:31 <Philippa> monochrom: articles generated by applying demand to authors?
15:07:50 <edwardk> shapr: http://www.census.gov/geo/www/tiger/faq.html#2
15:07:56 <shapr> edwardk: I'm hoping to turn either address or zip code into lat/long so I can tell the user how distant are the items they wish to acquire.
15:08:03 <shapr> edwardk: I'll read that...
15:08:10 <edwardk> yes. hence the reference ;)
15:08:31 <BMeph> Philippa: Just curious, but what about it makes you interpret it as smug? I usually interpret it as brainlessly enthusiastic, even fake. I don't see why it's smug, though.
15:08:54 <Philippa> thought re "is it really a monad?" and _|_: a lot of people are taking the "quick and dirty/morally sound" approach of not caring about termination because they intend their code to terminate always anyway
15:08:58 <FunctorSalad_> BMeph: it makes us as the endorsers smug? ;)
15:09:12 <FunctorSalad_> assuming the bot has our full support
15:09:16 <Philippa> BMeph: the idea that it's /always the right answer/
15:09:34 <FunctorSalad_> @bot
15:09:35 <lambdabot> :)
15:09:50 <ddarius> @faq Can Haskell always validate the claims made by @faq?
15:09:50 <lambdabot> The answer is: Yes! Haskell can do that.
15:09:55 <jmcarthur> i propose a magic 8 ball @faq
15:10:06 <jmcarthur> with memoization, for consistency :)
15:10:17 <FunctorSalad_> maybe it could spider the web for faqs and answer one at random
15:10:19 <Philippa> seconded, and I suggest a fairly high probability of snarking the user
15:10:26 <FunctorSalad_> that'd be non-boring but kinda unfunny too
15:10:42 * BMeph ponders Philippa's answer...
15:10:46 <jmcarthur> snarky is fine
15:10:48 <Saizan_> i propose attaching a precondition to @faq, you can call it only if you've code to back it up :)
15:11:07 <Philippa> (given that it's not going to be an actual FAQ searcher...)
15:11:11 <jmcarthur> Saizan_: constructive proof of claims ;)
15:11:19 <monochrom> I propose that the code is accepted only if you have proof to back it up
15:11:47 <Saizan_> so it should be a @faq about Agda in the end?
15:11:48 <shapr> edwardk: Have you worked with the TIGER/Shape files before?
15:12:05 <jmcarthur> actually, a real faq searcher would be nice if we could design it well
15:12:11 <FunctorSalad_> maybe it should randomly pick from some (possibly fictional) instruction manual about some really arcane subject
15:12:13 <jmcarthur> s/would/might/
15:12:20 <shapr> jmcarthur: Why not just index the wiki?
15:12:27 <edwardk> not much, i looked at the format, but i did a bunch of other GIS stuff before
15:12:33 <jmcarthur> shapr: why would we do something so obvious? :P
15:12:35 <shapr> And perhaps the mailing list posts?
15:12:47 <FunctorSalad_> (sorcery etc)
15:13:24 <FunctorSalad_> (or something real but really complicated)
15:13:28 <shapr> jmcarthur: For example, @faq hunit test framework could say "shapr: 5 wiki results and 7 haskell-cafe results, use @messages to see all results"
15:14:18 <Saizan_> it seems like a website would be a more appropriate format rather than an irc bot, for that
15:14:22 <jmcarthur> shapr: i think anything a bot should do should give something useful for everybody in the channel
15:14:41 <jmcarthur> shapr: so you could, say, use a bot command to demonstrate something to somebody or refer them to the right place
15:14:57 <jmcarthur> something that does searches like that doesn't seem able to do that
15:15:12 <jmcarthur> OR, something completely useless for humor :)
15:15:42 <gwern> @quote emission
15:15:42 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
15:16:02 <jmcarthur> see? excellent stuff for everyone :)
15:16:15 <shapr> Saizan_: So you think @faq should return a google search with site:haskell.org added?
15:16:51 <dolio> I'm not sure how @faq could be interpreted to always be correct.
15:17:04 <dolio> @faq What is Chen Kenichi's recipe for mapo dofu?
15:17:04 <lambdabot> The answer is: Yes! Haskell can do that.
15:17:05 <FunctorSalad_> Yes, I think @faq should do that.
15:17:09 <FunctorSalad_> ;)
15:17:20 <jmcarthur> how about something sneaky. if somebody invokes @faq and op /msgs an answer to lambdabot
15:17:32 <jmcarthur> *an op
15:17:46 <FunctorSalad_> then it.... wouldn't be a bot anymore
15:17:46 <jmcarthur> too bad it wouldn't be reliable
15:17:50 <jmcarthur> heh
15:17:54 <jmcarthur> but if nobody knows how it works...
15:17:56 <jmcarthur> :)
15:18:00 <dolio> Presumably it was invented to answer people coming here and asking "can Haskell do something that any other general purpose language could presumably do, but I'm skeptical that Haskell could do it?"
15:18:07 <FunctorSalad_> doesn't such mind control violate her basic rights anyway?
15:18:13 <shapr> As in @faq hunit framework should return http://www.google.com/search?q=hunit+framework&sitesearch=haskell.org ?
15:18:20 <Saizan_> dolio: that's my understanding as well
15:18:52 <jmcarthur> shapr: or maybe the "i'm feeling lucky" result
15:19:03 <Saizan_> dolio: i guess that sort of question is way less likely today
15:19:11 <jmcarthur> shapr: but maybe that should just be called @wiki
15:19:25 <sm> I'd like a bot that reduces noise on this channel, rather than increasing it
15:19:53 <dolio> Yes. Word seems to have gotten out that you can actually write programs in Haskell.
15:19:58 <jmcarthur> there should be a command that automatically gets the user kicked
15:20:10 <jmcarthur> @kickme
15:20:10 <lambdabot> Unknown command, try @list
15:20:14 <Philippa> @pwn ?
15:20:15 <hpc> jmcarthur: how about @java
15:20:15 <lambdabot> No match for "?".
15:20:20 <Philippa> @sploit ?
15:20:20 <lambdabot> Unknown command, try @list
15:20:40 <dolio> pwn actually matches a command?
15:20:44 <jmcarthur> wat, what command did @pwn invoke?
15:20:49 <shapr> sm: What could lambdabot do to reduce noise?
15:20:53 <monochrom> @pwn own
15:20:54 <lambdabot> *** "own" wn "WordNet (r) 2.0"
15:20:54 <lambdabot> own
15:20:54 <lambdabot>      adj : belonging to or on behalf of a specified person (especially
15:20:54 <lambdabot>            yourself); preceded by a possessive; "for your own
15:20:54 <lambdabot>            use"; "do your own thing"; "she makes her own clothes";
15:20:56 <lambdabot> [3 @more lines]
15:20:59 <dolio> Ah, of course.
15:21:03 <zygoloid> @pwn pwn
15:21:04 <lambdabot> No match for "pwn".
15:21:27 <gwern> shapr: there's the xkcd approach
15:21:58 <shapr> gwern: Make silly jokes to distract people?
15:22:00 <lowasser> Is there a good way to precompute a constant with TH?  (It's computationally easy, but machine-dependent.)
15:22:04 <FunctorSalad_> gwern: that'd punish people for helpful one-word answers
15:22:09 <FunctorSalad_> (name of some function)
15:22:14 <sm> it could refrain from random blather, and instead provide reponses so informative and to the point that folks go on their way, awed and inspired to hack
15:22:24 <Saizan_> ?type list
15:22:25 <lambdabot> Not in scope: `list'
15:22:25 <gwern> FunctorSalad_: I'm sure there's a length conditional
15:22:32 <gwern> shapr: no, that's not what #xkcd did
15:22:45 <shapr> sm: Ooh, I like that!
15:22:52 <shapr> gwern: Ok, what did #xkcd do?
15:22:52 <Cale> lowasser: as long as the datatype is simply representable in source code
15:23:06 <gwern> shapr: http://blog.xkcd.com/2008/01/14/robot9000-and-xkcd-signal-attacking-noise-in-chat/
15:23:09 <gwern> I think
15:23:20 <lowasser> s/Is there a good way/How do you
15:23:29 <FunctorSalad_> well is there much repetition noise in here?
15:23:32 <jao> lambdabot could answer, by default, only to the user querying her, with broadcast in the channel needing a specific request
15:23:54 <Saizan_> lowasser: $(lift (<expression calculating the constant>)), assuming the type is an instance of Lift
15:24:01 <gwern> FunctorSalad_: I think so. more than once I've felt deja vu
15:24:02 <lowasser> mwar
15:24:06 <jmcarthur> jao: maybe for some commands
15:24:13 <lowasser> the type is Word, which is not an instance of Lift at the moment ::eyeroll::
15:24:20 <Cale> lowasser: foo = $(lift ...)
15:24:23 <aristid> for its size, #haskell works remarkably well.
15:24:29 <jmcarthur> i think we use lambdabot for demonstration too much to make things like > and @type default to /msg
15:24:39 <Cale> lowasser: where ... is the means of computing the simple value
15:24:42 <jao> jmcarthur: evaluation, for instance. i for one find it sometimes annoying when people use it in lieu of ghci :)
15:24:55 <Saizan_> jao: that doesn't make much sense, at that point i don't even want to see the query, you can privmsg lambdabot
15:25:04 <Cale> lowasser: You need an instance of the Lift class, which basically takes values of some type, and produces expressions for constructing them
15:25:19 <jao> Saizan_: but people often don't privmsg, just query
15:25:22 <lowasser> bah.  I was hoping I could precompute a Word with TH without actually getting a dependency on template-haskell
15:25:31 <Cale> There are existing instances for Bool, Char, Int, Integer, lists, Maybe, Either, and tuples.
15:25:33 <jao> Saizan_: even when the result is of interest only to them
15:25:38 <Saizan_> jao: at that point you ask them to move to privmsg :)
15:25:48 <lowasser> yep, I need a Word specifically, bah.
15:25:50 <lowasser> oh well
15:25:58 <jao> Saizan_: heh,
15:26:15 <jmcarthur> jao: how about type errors go to /msg but successful evaluations go to channel?
15:26:22 <Saizan_> maybe the ops should be more preemptive on this issue
15:26:44 <FunctorSalad_> gwern: the most useless noise, it seems, are to-lambabot syntax errors... we could have people /msg lambdabot, and bot would only print the cmd and result if there's no error
15:26:50 <soupdragon> why is there so much talk about the state of the channel... isn't it doing pretty well?
15:26:52 <jao> jmcarthur: dunno. probably better than now, i guess.
15:26:54 <jmcarthur> FunctorSalad_: yes!
15:26:56 <FunctorSalad_> (I'm guilty of that noise of course)
15:26:58 <lowasser> I'm interested in -(minBound :: Int), converted to a Word, except I can't write it like that, since it'll overflow
15:27:10 <jmcarthur> soupdragon: i think it's just for improvement, not because we are suffering too badly
15:27:18 <gwern> FunctorSalad_: auto-priv msging errors doesn't sound like a bad idea
15:27:18 <lowasser> and I feel guilty about using fromIntegral (maxBound :: Int) + 1
15:27:31 <Saizan_> lowasser: why?
15:27:43 <gwern> if a tad inconvenient for exploratory users
15:27:53 <lowasser> mostly because it's not guaranteed by the Report  that those two are the same thing
15:28:05 <lowasser> even though it always is in practice?
15:28:10 <FunctorSalad_> we could have a @perror command to print the error if you want to discuss it publically
15:28:11 <lowasser> to the best of my knowledge
15:28:17 <sm> this is an excellent channel, still #haskell is rarely one of the tabs I am drawn to read, since it's 95% chatter and cerebration
15:28:29 <Saizan_> lowasser: ah, wait, what is the computation you'd actually do?
15:28:34 <dolio> Word isn't even in the report, is it?
15:28:42 <lowasser> but Int is
15:28:58 <lowasser> in practice, minBound :: Int = - (maxBound :: Int) - 1
15:29:00 * sm wants more practical stuff
15:29:35 <lowasser> Saizan: I'm constructing an order-preserving injection from Word to Int, and want to get it portably right
15:30:25 <cocon> FFI question: can a C function write into the Haskell stack?
15:30:40 <ddarius> What is the "Haskell stack"?
15:30:47 <alexyk> does haskell platform include cabal?
15:30:50 <mauke> I'm C, I can write anywhere
15:30:57 <mauke> even places that don't exist
15:31:27 <Cale> cocon: maybe if you messed something up really badly?
15:31:27 <FunctorSalad_> lowasser: f w = unsafeCoerce (w + m) -- where m is the abs of the least Int, as a Word
15:31:28 <FunctorSalad_> ?
15:31:38 <Saizan_> alexyk: yes, both "Cabal" the library and "cabal" the executable
15:31:43 <monochrom> haskell platform includes cabal, both the cabal lib and cabal-install. ok, the cabal lib comes with ghc, but sometimes ghc is counted as part of haskell platform too
15:31:59 <lowasser> I've never in my life used unsafeCoerce, and I'd like to avoid it now =P
15:32:12 <cocon> right. what I mean to do is avoiding a malloc by putting a C struct on the stack
15:32:12 <alexyk> so where's cabal installed by default?  I see ghc in /usr/bin but not cabal!
15:32:19 <FunctorSalad_> lowasser: heh, I think formIntegral should be equivalent
15:32:21 <monochrom> I also refuse to upgrade cabal-install beyond what haskell platform gives.
15:32:22 <cocon> perhaps that doesn't make any sense in Haskell
15:32:31 <lowasser> fromIntegral of the number I'm trying to precompute doesn't work
15:32:38 <FunctorSalad_> the unsafe might be faster, but probably not since formIntegral is probably rewritten
15:32:44 <Philippa> the stack isn't what you think it is in a lazy language
15:32:45 <mauke> cocon: have the C function take a pointer and write to it?
15:33:02 <alexyk> monochrom: where did your cabal executable go?
15:33:09 <cocon> mauke: but how to allocate it on the stack, and how to obtain a pointer to it?
15:33:10 <Cale> cocon: The stack in GHC Haskell is used essentially to hold on to case expressions which are waiting for their scrutinee to be evaluated enough to pattern match
15:33:16 <mauke> cocon: what stack?
15:33:17 <Philippa> also, single allocations are fairly fast
15:33:22 <FunctorSalad_> lowasser: oh, right, my program will just wrap around for words which are reps of positive ints
15:33:30 <FunctorSalad_> lowasser: two branches?
15:33:38 <monochrom> /usr/local/haskell-platform-2009.2.0.2/bin
15:33:47 <cocon> mauke: not sure. does there always have to be a level of indirection?
15:33:48 <lowasser> FunctorSalad: no, it'll actually *fail* for big enough Words
15:34:08 <lowasser> yes, I need a branch, but I need to express, as a Word, the branch point, which is too big to fit into an Int
15:34:10 <mauke> cocon: ... how would you do this in C?
15:34:12 <FunctorSalad_> lowasser: yes, wrapping around in the Word type is failure since you'll get a neg Int
15:34:28 <cocon> mauke: define a variable of a struct type
15:34:29 <lowasser> FunctorSalad: I'm interested in going from Words to Ints, not the other direction
15:34:30 <FunctorSalad_> lowasser: ok, think you wrote above how to obtain it already
15:34:34 <mauke> cocon: and then?
15:34:37 <jmcarthur> > fromIntegral (fromIntegral (maxBound :: Int) + 1 :: Word) :: Int
15:34:38 <lambdabot>   -9223372036854775808
15:34:40 <FunctorSalad_> lowasser: that was my understanding, yes
15:34:46 <cocon> mauke: pass &x to a function
15:34:56 <lowasser> FunctorSalad: I want to *precompute* it, ideally
15:35:03 <Saizan_> maybe cocon wants alloca?
15:35:03 <lowasser> in the compiling stage
15:35:06 <lowasser> hence, TH
15:35:15 <mauke> @hoogle alloca
15:35:15 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
15:35:15 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
15:35:15 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
15:35:22 <FunctorSalad_> lowasser: jmcarthur 's is what I had in mind to get the branch point
15:35:34 <jmcarthur> lowasser: i wouldn't put it beyond the compiler to precompute it anyway if it's just a constant expression
15:35:43 <alexyk> monochrom: ah, on a mac it goes into a Framework with symlink from /usr/local/bin
15:35:44 <lowasser> jmcarthur: ghc-core disagrees =P
15:35:57 <lowasser> well, maybe it's in the other stages, I suppose
15:35:59 <FunctorSalad_> lowasser: one could argue, though, that you're essentially assuming two-complements bits already by the choice of branch...
15:36:12 <FunctorSalad_> so you could just do something with bits
15:36:15 <alexyk> so, say I have a bunch of stuff from ghc 6.10.x in ~/.cabal/, do I have to rm -fr it and re-cabal install?
15:36:17 <Philippa> cocon: what Saizan_ said, but you probably shouldn't do it unless you really, really want to - if it's just an optimisation, it's probably not worth it
15:36:24 <lowasser> hrrrrrm.
15:36:31 <hpc> just write your code as pure as possible
15:36:37 <sm> so, um.. that seemed to go down like a lead balloon. For the record I meant to support the channel/bot improvement brainstorming, not squelch it :)
15:36:45 <hpc> it is unlikely to be a major slowdown
15:36:46 <dolio> > let f :: Word -> Int ; f w = fromIntegral w `xor` minBound in map f [0,1,2,3,maxBound-1,maxBound]
15:36:47 <lambdabot>   [-9223372036854775808,-9223372036854775807,-9223372036854775806,-9223372036...
15:37:03 <Philippa> sm: it's okay, I think we're just sliding onto help-the-questioner because it'd run its course for the time being
15:37:04 <cocon> Saizan_: alloca still seems to allocate sth on the heap
15:37:07 <mauke> Philippa: optimization of what?
15:37:11 <sm> good-o
15:37:14 <Philippa> mauke: well qute
15:37:15 <dolio> > let f :: Word -> Int ; f w = fromIntegral w `xor` minBound in map f [maxBound-1,maxBound]
15:37:16 <FunctorSalad_> maybe it's easier to make it portable by -XCPP instructions, dunno
15:37:16 <lambdabot>   [9223372036854775806,9223372036854775807]
15:37:25 <lowasser> iiiiinteresting.
15:37:29 <Philippa> cocon: Haskell basically doesn't have the kind of stack you want
15:37:35 <sm> and of course I was being subjective
15:37:45 <FunctorSalad_> (but I didn't get what the issue with jmcarthur 's boundary is)
15:37:49 <mauke> cocon: you know C technically has no stack, right?
15:37:55 <alexyk> so, how do I upgrade a ~/.cabal?
15:37:59 <Philippa> OTOH, heap allocation in Haskell isn't a malloc call
15:38:00 <cocon> mauke: I don't
15:38:10 <cocon> mauke: C has no stack?? :)
15:38:14 <mauke> yes
15:38:26 <cocon> can you elaborate a tiny bit?
15:38:31 * alexyk misses jars you don't need to recompile with any new version of Java, Clojure, or Scala.  Well, you have to with Scala.
15:38:40 <jmcarthur> > let f = (fromIntegral :: Integer -> Int) . (+ fromIntegral (minBound :: Int)) . (fromIntegral :: Word -> Integer) in f maxBound
15:38:41 <lambdabot>   9223372036854775807
15:38:47 <Philippa> cocon: calling it a stack is overspecifying. You don't have the right to expect that memory layout
15:38:48 <jmcarthur> > let f = (fromIntegral :: Integer -> Int) . (+ fromIntegral (minBound :: Int)) . (fromIntegral :: Word -> Integer) in f 0
15:38:50 <lambdabot>   -9223372036854775808
15:38:54 <jmcarthur> > minBound :: Int
15:38:55 <lambdabot>   -9223372036854775808
15:38:58 <jmcarthur> :)
15:39:14 <jmcarthur> lowasser: that should be correct and doesn't depend on internal representation at all
15:39:14 <systemfault> cocon: The C Standard doesn't mention stack..
15:39:15 <lowasser> I like dolio's thing a lot
15:39:20 <lowasser> although I wish I understood it better
15:39:21 <cocon> okok
15:39:23 <lowasser> hmmm
15:39:25 <Saizan_> alexyk: you mean "recompile all the installed packages against the newly installed GHC"?
15:39:30 <cocon> thanks everybody
15:39:32 <FunctorSalad_> class (Num a) => Data.Bits.Bits a where
15:39:32 <FunctorSalad_>   ...
15:39:32 <FunctorSalad_>   Data.Bits.bitSize :: a -> Int
15:39:32 <FunctorSalad_>   ...
15:39:32 <FunctorSalad_>   	-- Defined in Data.Bits
15:39:38 <alexyk> Saizan_: exactly
15:39:41 <lowasser> jmcarthur: I want this to compile to be _fast_, I'm not convinced that does
15:39:46 <FunctorSalad_> lowasser: I think you can rely on that method being portable, no?
15:39:56 <jmcarthur> lowasser: you said this is compile time anyway, right?
15:40:12 <jmcarthur> TH and all that
15:40:21 <FunctorSalad_> @ty bitSize
15:40:22 <alexyk> Saizan_: what are the general rules -- do I have to for any major version, and/or can avoid for minor versions, etc.?
15:40:22 <lambdabot> forall a. (Bits a) => a -> Int
15:40:31 <FunctorSalad_> > bitSize (undefined::Int)
15:40:33 <lambdabot>   64
15:40:33 <lowasser> hmmmm
15:40:44 <FunctorSalad_> > bitAt 63 (-1 :: Int)
15:40:45 <lambdabot>   Not in scope: `bitAt'
15:40:51 <Saizan_> alexyk: you have to even for minor versions
15:40:53 <lowasser> that might be an interestingly different way of using TH, one mo'
15:41:00 <alexyk> Saizan_: I meant for debug versions
15:41:06 <FunctorSalad_> > testBit 63 (-1 :: Int)
15:41:07 <lambdabot>   Ambiguous type variable `t' in the constraint:
15:41:07 <lambdabot>    `Data.Bits.Bits t'
15:41:07 <lambdabot>      a...
15:41:14 <alexyk> e.g. 6.12 from 6.10 have to, then 6.12.1 not, right?
15:41:16 <FunctorSalad_> > testBit (-1 :: Int) 63
15:41:17 <lambdabot>   True
15:41:31 <alexyk> and, is there a single-line command to upgrade ~/.cabal/?
15:41:46 <FunctorSalad_> > map (testBit (-1 :: Int)) [63,62 .. 0]
15:41:47 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
15:41:50 <Saizan_> alexyk: there's no supported binary compatibility among different versions, even between 6.12.1 and 6.12.2 you've to recompile
15:41:58 <lowasser> nope
15:42:06 <alexyk> Saizan_: ok now I need a single command for sure
15:42:31 <Saizan_> alexyk: and about the single command i think that's supported only the developement version of cabal-install currently
15:42:31 <lowasser> meh
15:42:40 <lowasser> I'll go with dolio's
15:42:40 <FunctorSalad_> @let shb n = map (\x -> if testBit n x then '0' else '1') [63,62 .. 0]
15:42:42 <lambdabot>  Defined.
15:42:46 <FunctorSalad_> > shb (-1 :: Int)
15:42:48 <lambdabot>   "0000000000000000000000000000000000000000000000000000000000000000"
15:42:49 <Saizan_> alexyk: i saw the patch, not sure if it got merged actually :)
15:43:09 <FunctorSalad_> err, off by one complementation, but you know what I mean
15:43:19 <FunctorSalad_> @let shb n = map (\x -> if not (testBit n x) then '0' else '1') [63,62 .. 0]
15:43:20 <lambdabot>  <local>:8:0:
15:43:20 <lambdabot>      Warning: Pattern match(es) are overlapped
15:43:20 <lambdabot>               In...
15:43:29 <FunctorSalad_> @unlet
15:43:31 <lambdabot>  Defined.
15:43:33 <alexyk> Saizan_: well, there should be a simple way to list all packages from old cabal, then install them, no?
15:43:37 <FunctorSalad_> @undefine
15:43:45 <alexyk> I mean people here use cabal for what, 20 years?  :)
15:43:52 <Saizan_> no
15:43:53 * alexyk kidding
15:43:56 <FunctorSalad_> @forget
15:43:56 <lambdabot> Incorrect arguments to quote
15:43:58 <monochrom> haha
15:44:02 <FunctorSalad_> argh what was it
15:44:10 <mauke> FunctorSalad_: it was @undefine
15:44:13 <Saizan_> alexyk: "ghc-pkg list" lists the packages installed
15:44:19 <FunctorSalad_> mauke: thanks
15:44:25 <FunctorSalad_> @let shb n = map (\x -> if not (testBit n x) then '0' else '1') [63,62 .. 0]
15:44:26 <lambdabot>  Defined.
15:44:34 <lowasser> wait, no, it doesn't work
15:44:41 <Saizan_> alexyk: you've to use the old one to get the list of packages installed with the old ghc :)
15:44:42 <FunctorSalad_> > shb <$> [-1,1]
15:44:43 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:44:43 <lambdabot>    `Data.Bits.Bits a'
15:44:43 <lambdabot>      a...
15:44:47 <FunctorSalad_> > shb <$> [-1,1::Int]
15:44:49 <lambdabot>   ["1111111111111111111111111111111111111111111111111111111111111111","000000...
15:44:51 <lowasser> I need an order-preserving injection =/
15:44:52 <alexyk> Saizan_: ok, so make old ghc-pkg list, then cabal install, can be a shell script right?
15:45:21 <FunctorSalad_> @undefine
15:45:26 <Saizan_> alexyk: if that suffices for you, sure
15:45:40 <alexyk> monochrom: what's the wisdom of not upgrading cabal-install from platform as it tells you when you run it?
15:45:42 <FunctorSalad_> @let shb n = map (\x -> if not (testBit n x) then '0' else '1') [bitSize n - 1,bitSize n - 2 .. 0]
15:45:43 <lambdabot>  Defined.
15:45:46 <Saizan_> alexyk: you'd have to filter out some of the packages that only come with ghc, though
15:45:53 <FunctorSalad_> > shb (1::Int16)
15:45:54 <lambdabot>   "0000000000000001"
15:45:59 <FunctorSalad_> less spam that way ^^^^^^^^^
15:46:19 <alexyk> Saizan_: is there any option to filter those?
15:46:32 <monochrom> incompatibility
15:46:33 <Saizan_> alexyk: or just ignore those that you can't get to install, i guess
15:46:39 <alexyk> or heuristics, e.g. they're all in some subdir?
15:47:14 <Saizan_> alexyk: well if you've always installed packages in the userdb they'll be the ones in the global one
15:47:35 <FunctorSalad_> alexyk: what was the task again? list all packages?
15:47:36 <Saizan_> btw, i think it should be safe to install a newer version of cabal-install
15:47:39 <FunctorSalad_> (installed or on hackage?)
15:47:46 <Saizan_> unless there's some bug specific to OS X
15:47:54 <FunctorSalad_> ghc-pkg dump | grep 'name:'
15:47:56 <FunctorSalad_> for the former
15:48:05 <monochrom> It was proven unsafe when ghc 6.12 came out
15:48:06 <alexyk> FunctorSalad_: given a fat ~/.cabal and new ghc, quickly reinstall all packages in ~/.cabal with the new ghc
15:48:10 <Saizan_> FunctorSalad_: reinstall all the packages you had with the newly installed ghc
15:48:35 <FunctorSalad_> ok then what I just said plus a for loop ;)
15:49:04 <alexyk> FunctorSalad_: for loop??? :)
15:49:08 <monochrom> or rather, not unsafe, but such a hassle that completely defeats the point of installing haskell platform
15:49:13 <alexyk> FunctorSalad_: not a foldl?
15:49:26 <FunctorSalad_> ghc-pkg dump | sed -ne 's/name:\(.*\)/\1/p' > packages
15:49:31 <FunctorSalad_> (reinstall ghc)
15:49:36 <alexyk> monochrom: is there a way to tell cabal to shut up about upgrading itself?
15:49:49 <FunctorSalad_> for x in $(< packages); do cabal install $x; done
15:49:52 <Saizan_> monochrom: what problems did it cause?
15:49:59 <FunctorSalad_> alexyk: in bash ;)
15:50:13 <alexyk> FunctorSalad_: yeah, I was kidding :)
15:50:28 <alexyk> FunctorSalad_: we need a foldl in shell, my zsh must get one
15:50:50 <FunctorSalad_> alexyk: I wanted to port basic haskell utils to bash once actually
15:50:55 <hpc> a pseudo-haskell shell scripting language would be pretty cool
15:51:03 <FunctorSalad_> biggest challenge would be proper name-handling in "lambdas"
15:51:05 <FunctorSalad_> I think
15:51:23 <alexyk> when installing packages with cabal, is the source saved?
15:51:32 <alexyk> I want to browse the sources
15:51:36 <monochrom> haskell platform 2009 was for ghc 6.10. you had ghc 6.10. ghc 6.12 came out. cabal-install matching new version came out. it nags you to upgrade. you issue the command to upgrade. "oh but now I need base-4.<new ghc 6.12 version>.0.0.0".
15:52:03 <FunctorSalad_> if you don't care about names that much, you can just define "lambda x bla" to be a script that drops bla into a tempfile and substitutes all the x for $1...
15:52:29 <FunctorSalad_> then it can be used like $(lambda x 'echo foo x') bar
15:52:30 <FunctorSalad_> ;)
15:52:39 <Saizan_> monochrom: oh, so it just didn't install?
15:52:55 <monochrom> if you replaced ghc 6.10 by ghc 6.12, you would lose the rest of haskell platform. if you didn't, cabal-install would be in some undefined state.
15:53:38 <Saizan_> well, the current platform is for 6.12 anyway
15:54:04 <monochrom> Yes but the current platform lagged new cabal-install and new ghc by like 5 months.
15:54:08 <alexyk> hmm, looks like cabal doesn't save sources, just tar.gz.  Is there a simple way to keep pristine source trees untarred, or I'd have manually do that?
15:54:10 <Saizan_> though i think that message was just some package requiring the new base, or the dependency solver eagerly committing to that choice
15:54:33 <FunctorSalad_> but apart from hygiene, translating haskell functions (without types) to bash-callable utils doesn't sound all that impossible ;)
15:55:06 <monochrom> clearly the latest cabal-install is an example of a package requiring the latest base.
15:55:10 <FunctorSalad_> since it has archaic first-class functions through eval/splicing of course
15:55:46 <aristid> @src pi
15:55:46 <lambdabot> Source not found.
15:56:35 <Saizan_> monochrom: i just installed it under 6.10.4, and actually used it to install itself.. so it clearly isn't :)
15:56:40 <FunctorSalad_> (actually even currying is common in bash)
15:56:53 <FunctorSalad_> say, the arg of xargs
15:56:58 <aristid> is there an instance of Floating with which i can obtain infinite-precision pi?
15:57:08 <mauke> > pi :: CReal
15:57:08 <lambdabot>   3.1415926535897932384626433832795028841972
15:57:18 <mauke> there
15:57:21 <hpc> @src pi :: CReal
15:57:21 <lambdabot> Source not found. Maybe you made a typo?
15:57:29 <aristid> @src CReal pi
15:57:30 <lambdabot> Source not found. :(
15:57:45 <aristid> mauke: CReal has infinite precision?
15:57:51 <hpc> aristid: indeed
15:58:14 <FunctorSalad_> Foreign.C.Real ...
15:58:16 <monochrom> CReal has infinite precision. Its Show instance and Eq instance etc. just takes 40 digits.
15:58:19 <FunctorSalad_> that one never gets old
15:58:20 <EvanR> length circle / diameter circle
15:58:30 <mauke> C has no Real type :-|
15:58:32 <alexyk> so, no easy way to preserve haskell source in cabal?
15:58:37 <alexyk> ready for review
15:58:43 <FunctorSalad_> ("the Foreign.C hierarchy is simply for holding all the types beginning with 'C'")
15:58:49 <FunctorSalad_> mauke: exactly ;)
15:59:47 <syntaxglitch> So in other words, Foreign.C.Real is imaginary?
15:59:51 <syntaxglitch> That seems sensible
16:00:21 <monochrom> hehe
16:00:55 <Gracenotes> yet-another-M-suffixed-function idea: maybeM :: Monad m => m (Maybe a) -> m b -> (a -> m b) -> m b
16:01:21 <FunctorSalad_> someone said the M-suffix indicates Kleisli stuff, so no monadic inputs allowed
16:01:28 <Gracenotes> knowing it, probably accompanied with ifM and eitherM >.>
16:01:29 <Saizan_> Gracenotes: maybe + =<< ?
16:02:06 <FunctorSalad_> (how about a new suffix for stuff that is a .*M function conveniently bundled with a bind?)
16:02:16 <Gracenotes> Saizan_: yes.. with a delicious hint for forM
16:02:19 <Gracenotes> *of
16:02:47 <FunctorSalad_> that doesn't take monadic args either :)
16:02:52 <FunctorSalad_> IIRC...
16:02:53 <FunctorSalad_> @ty forM
16:02:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
16:02:56 <Gracenotes> (mostly in the ordering which is convenient for blocks)
16:03:00 <Gracenotes> nope, it's just [a]
16:03:13 <FunctorSalad_> I think it's more readable than mapM most of the time, too
16:03:16 <syntaxglitch> how about constM :: a -> m b -> m a, that sounds useful
16:03:20 <FunctorSalad_> the first arg is usually much shorter...
16:03:23 <syntaxglitch> and we could rename return to idM
16:03:32 <FunctorSalad_> with mapM, you have forgotten you're in a mapM by the time the huge lambda is over
16:03:40 <Gracenotes> but that's the thing with functional languages, if you notice patterns, you make function for those patterns
16:03:53 <Gracenotes> or typeclasses or type families or etc.
16:03:54 <FunctorSalad_> Gracenotes: yeah I'm just suggesting a different suffix
16:03:59 <jon_of_arc> Bah, Bool -> Bool -> Bool is not a member of Eq? If you're going to have teeny tiny little domains, why not take advantage of it?
16:04:03 <FunctorSalad_> B for bind maybe
16:04:09 <monochrom> This is only an artifect of using plain text files.
16:04:10 <FunctorSalad_> or N for... after M
16:04:52 <FunctorSalad_> jon_of_arc: hmm it blows up fast
16:05:02 <aristid> > showCReal 500 pi
16:05:04 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
16:05:10 <Gracenotes> yeah, changing m (Maybe a) to (Maybe a), you just get.. uh..
16:05:25 <kmc> :t pi
16:05:26 <lambdabot> forall a. (Floating a) => a
16:05:41 <FunctorSalad_> @ty Node
16:05:41 <cocon> another FFI question: is there an easy way to convert a pointer to a C struct into a Haskell tuple?
16:05:41 <lambdabot> forall a. a -> Forest a -> Tree a
16:05:42 <Gracenotes> @pl \m n s -> maybe n s m
16:05:42 <lambdabot> flip (flip . maybe)
16:05:51 <EvanR> cocon: peek
16:06:28 <cocon> EvanR: looks like I'd have to *write* peek
16:06:28 <Gracenotes> or hsc2hs or c2hs, depending on what you mean by easy
16:06:40 <EvanR> @instances Storable
16:06:41 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
16:06:46 <FunctorSalad_> @let card x = case x of { Node "Bool" [] -> 2; Node "->" [d,c] -> card c ^ card d }
16:06:47 <lambdabot>  Defined.
16:06:49 <EvanR> @instance Storable
16:06:49 <lambdabot> Maybe you meant: instances instances-importing
16:06:57 <FunctorSalad_> @let bool = Node "Bool" []
16:06:58 <lambdabot>  Defined.
16:07:14 <FunctorSalad_> @let (-->) x y = Node "->" [x,y]
16:07:15 <lambdabot>  Defined.
16:07:17 <EvanR> cocon: yeah, but its not that bad
16:07:18 * syntaxglitch wants some way to write a "do-what-I-mean function application" combinator that would behave as ($), (<$>), (<*>), or (=<<) depending on context
16:07:24 <FunctorSalad_> > card (bool --> bool)
16:07:25 <lambdabot>   4
16:07:32 <FunctorSalad_> > card ((bool --> bool) --> bool)
16:07:33 <lambdabot>   16
16:07:38 <FunctorSalad_> > card (((bool --> bool) --> bool) -> bool)
16:07:39 <lambdabot>   Pattern syntax in expression context:
16:07:39 <lambdabot>      ((bool --> bool) --> bool) -> bool
16:07:43 <FunctorSalad_> > card (((bool --> bool) --> bool) --> bool)
16:07:44 <lambdabot>   65536
16:07:44 <monochrom> type-directed source code speculation
16:07:53 <FunctorSalad_> @ jon_of_arc  :)
16:08:03 <cocon> EvanR: so how can it be done?
16:08:15 <FunctorSalad_> > (((bool --> bool) --> bool) --> bool)
16:08:16 <lambdabot>   Node {rootLabel = "->", subForest = [Node {rootLabel = "->", subForest = [N...
16:08:23 <FunctorSalad_> > showTree (((bool --> bool) --> bool) --> bool)
16:08:24 <cocon> EvanR: I mean, do I have to copy the contents?
16:08:25 <lambdabot>   Not in scope: `showTree'
16:08:34 <FunctorSalad_> hmm wasn't there some prettyprinter?
16:08:41 <EvanR> cocon: instance Storable (A, B) where peek ptr = (..., ...)
16:08:44 <kmc> :t (-->)
16:08:45 <lambdabot> parse error (possibly incorrect indentation)
16:08:46 <FunctorSalad_> monochrom: ?
16:08:52 <FunctorSalad_> kmc: I just defined it
16:09:01 <FunctorSalad_> let (-->) x y = Node "->" [x,y]
16:09:10 <kmc> cocon, did you read the RWH chapter on FFI?
16:09:18 <cocon> kmc: yes
16:09:37 <monochrom> unimportant
16:10:00 <FunctorSalad_> monochrom: I didn't want to set up the cardinality formula manually ;o
16:10:10 <FunctorSalad_> for nested bool function spaces
16:10:22 <FunctorSalad_> 2^(2^n) or sth
16:10:40 <EvanR> god i hate sth
16:10:49 <FunctorSalad_> for a left-nested expression tree
16:10:53 <FunctorSalad_> (type expression)
16:10:57 <FunctorSalad_> EvanR: :-(
16:11:14 <FunctorSalad_> it's the second complaint I get about it,odd
16:11:18 <FunctorSalad_> (or was that you?)
16:11:34 <FunctorSalad_> and that lack of space was a mishitting or a stuck space bar
16:11:37 <FunctorSalad_> :p
16:11:41 <monochrom> "the nth complaint about sth"
16:12:26 <monochrom> "take s n gives the sth item in list n"
16:12:38 <jon_of_arc> FunctorSalad_: maybe we need an ExpensiveEq class to provide some operator by which people are able to declare themselves willing to embark on an exhaustive test for equality. Though I guess at this level I'm mostly just satisfying theoretical wankery.
16:12:56 <monochrom> err, n!!s gives the sth item in list n
16:13:14 * syntaxglitch wishes for a way to profile a type-level function
16:13:22 <jon_of_arc> 	
16:13:23 <FunctorSalad_> @let fcard x = case x of { Node "Bool" [] -> "2"; Node "->" [d,c] -> "("++fcard c++" ^ "++fcard d++")" }
16:13:25 <lambdabot>  Defined.
16:13:32 <monochrom> "x = sin u solves sine for u"
16:13:36 <FunctorSalad_> > fcard (((bool --> bool) --> bool) --> bool)
16:13:38 <lambdabot>   "(2 ^ (2 ^ (2 ^ 2)))"
16:13:45 <FunctorSalad_> see, lambdabot is even a *symbolic* calculator
16:13:47 <FunctorSalad_> :)
16:14:16 <monochrom> @vixen you are a symbolic calculator
16:14:16 <lambdabot> stop being racist!
16:14:18 <aristid> :t bool
16:14:19 <lambdabot> Tree [Char]
16:14:21 <monochrom> hahaha
16:14:22 <hpc> :t (-->)
16:14:23 <lambdabot> parse error (possibly incorrect indentation)
16:14:30 <FunctorSalad_> odd
16:14:36 <FunctorSalad_> @ty (-->)
16:14:38 <lambdabot> parse error (possibly incorrect indentation)
16:14:45 <aristid> :t (bool --> bool)
16:14:47 <lambdabot> parse error (possibly incorrect indentation)
16:14:47 <FunctorSalad_> anyway, it's a binop on Tree String
16:14:52 <hpc> huh
16:14:55 <FunctorSalad_> > bool --> bool
16:14:57 <lambdabot>   Node {rootLabel = "->", subForest = [Node {rootLabel = "Bool", subForest = ...
16:14:57 <aristid> > fcard (((bool --> bool) --> bool) --> bool)
16:14:57 <hpc> :t fcard
16:14:58 <lambdabot>   "(2 ^ (2 ^ (2 ^ 2)))"
16:14:58 <lambdabot> Tree [Char] -> [Char]
16:15:03 <aristid> :t fcard (((bool --> bool) --> bool) --> bool)
16:15:04 <lambdabot> parse error (possibly incorrect indentation)
16:15:09 <aristid> fun
16:15:26 <FunctorSalad_> it just builds trees ;) no type metamagic
16:15:35 <hpc> is --> even valid haskell?
16:15:42 <FunctorSalad_> yeah
16:15:42 <hpc> it looks like it would just start a comment
16:15:49 <monochrom> oh haha
16:15:58 <FunctorSalad_> operator tokens are parsed completely, only -- is one
16:16:09 <FunctorSalad_> and --- ---- etc I suppose
16:16:11 <FunctorSalad_> and --|
16:16:37 <syntaxglitch> FunctorSalad_, Haskell syntax highlighting in some editors I've used disagrees, unfortunately
16:16:55 <mauke> > 1 --| 2
16:16:56 <lambdabot>   Not in scope: `--|'
16:17:03 <FunctorSalad_> but I just proved it assuming the bot is haskell ;)
16:17:06 <EvanR> vim haskell highlighting often messed up block comments
16:17:12 <FunctorSalad_> Caleskell is just a library after all
16:17:20 <zygoloid> > let (-->) = (,); m = [1 --> "Hello", 2 --> "world"] in unwords . catMaybes $ map (`lookup`m) [1,2]
16:17:22 <lambdabot>   "Hello world"
16:17:55 <hpc> that still begs the question of why you can't :t (-->)
16:18:04 <FunctorSalad_> yeah
16:18:16 <ville> Is there a proverbial linear algebra library, sepcifically one for just R3 doing matrix, vector and quaternions related to 3D graphics?
16:18:25 <FunctorSalad_> ville: Vec
16:18:37 <FunctorSalad_> is specialized to 1-4d
16:18:46 <syntaxglitch> :t (-->) works for me in GHCi for what it's worth
16:18:47 <lambdabot> parse error (possibly incorrect indentation)
16:18:48 <FunctorSalad_> thought it supports arbitrary static dim
16:18:50 <FunctorSalad_> *though
16:19:12 <syntaxglitch> lambdabot just has a screw loose I suppose
16:19:55 <FunctorSalad_> syntaxglitch: maybe comment parsing is an addon over ghci, so that we can add an explanation to the :t we are doing
16:20:13 <dolio>  @type might run the expression through its own parser before handing it to ghc.
16:20:21 <dolio> Some of the commands used to do that.
16:20:31 <FunctorSalad_> @. @type @> "-->"
16:20:32 <lambdabot> Plugin `compose' failed with: Unknown command: "@type"
16:20:42 <Saizan_> the stripComments function is clearly the culprit here :)
16:20:42 <FunctorSalad_> @. type > "-->"
16:20:42 <lambdabot> Plugin `compose' failed with: Unknown command: ">"
16:20:46 <FunctorSalad_> :(
16:20:54 <FunctorSalad_> thought I was being very clever
16:20:58 <syntaxglitch> FunctorSalad_, doesn't GHCi parse comments already?
16:21:13 <FunctorSalad_> syntaxglitch: maybe not in colon commands
16:21:35 <FunctorSalad_> nevermind, it does
16:21:44 <syntaxglitch> yep
16:21:47 <dolio> @run 5
16:21:48 <lambdabot>   5
16:22:15 <syntaxglitch> it also handles {- -} comments inside expressions and other what not
16:22:29 <syntaxglitch> GHCi is smarter than it looks I guess
16:22:30 <FunctorSalad_> (-->) is cute for TH :)
16:22:46 <Saizan_> @type map -- do we want this output from lambdabot ?
16:22:47 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:22:50 <Saizan_> err
16:23:03 <FunctorSalad_> ghci does echo the comment, Saizan_
16:23:17 <aristid> @pl map (\i -> last . map digitToInt . filter isDigit . showCReal i $ pi) [0..]
16:23:17 <lambdabot> map (flip (last .) pi . ((map digitToInt . filter isDigit) .) . showCReal) [0..]
16:23:38 <Saizan_> i guess if we strip out the expression from the result we can just leave the comment for ghci
16:23:58 <dpratt71> I'm currently reading this page: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
16:24:26 <dpratt71> there is a sentence "The effect of the rank-2 polymorphism inÂ runST's type is toÂ constrain the scope of the type variableÂ sÂ to be within the first parameter."
16:24:35 <dpratt71> what the HECK does that mean?
16:24:40 <FunctorSalad_> Saizan_: it runs on top of ghci?
16:24:42 * Saizan_ is not sure
16:24:47 <Saizan_> FunctorSalad_: yup
16:24:56 <FunctorSalad_> interfacing with ghc directly to get a type is not that hard either
16:25:01 <Saizan_> FunctorSalad_: see Plugin/Type.hs in lambdabot's repo
16:25:46 <FunctorSalad_> @ty runST
16:25:47 <lambdabot> forall a. (forall s. ST s a) -> a
16:26:21 <FunctorSalad_> dpratt71: if "a" is a type expression where "s" occurs, the resulting type wouldn't even parse
16:26:32 <FunctorSalad_> since the occurence of "s" is free in the outside "a"
16:26:39 <Saizan_> ah, yeah
16:26:42 <FunctorSalad_> or well, it would parse ;) due to implicit universal quant.
16:26:49 <Saizan_> it's a way to say that 's' cannot appear in the type of the result
16:26:55 <syntaxglitch> dpratt71, it means that the type specifies "there is some such type, but you don't know what it is here", give or take
16:27:26 <syntaxglitch> it's not a specific type, like "Int" or "Bool", and it's not a regular type variable, since those mean "this can be any type at all"
16:27:32 <dpratt71> FunctorSalad_: ok, so if a was [Int], then s couldn't be Int?
16:27:49 <kmc> dpratt71, what rank-2 means is that runST requires that its argument be a polymorphic function
16:27:50 <FunctorSalad_> dpratt71: or from another angle: anything you can plug in for 'a' doesn't produce a type where the second argument contains 's'
16:27:55 <Saizan_> dpratt71: no, that's not it
16:28:12 <FunctorSalad_> dpratt71: (if you supply an 's' for the specialization of 'a', that's a different, fresh 's')
16:28:13 <dpratt71> ok, lemme think on that a minute
16:28:19 <kmc> dpratt71, if you call (runST f), you must guarantee that f doesn't care which 's' you choose
16:28:27 <FunctorSalad_> (that's the awesome thing about proper name handling ;))
16:29:06 <Saizan_> yeah, the point is that 'f' there must be polymorphic in 's' and that the result type, which will correspond to a, can't mention the quantified variable 's' either
16:29:07 <FunctorSalad_> (that is: no capture of free variables by binders such as 'forall')
16:29:27 <kmc> dpratt71, the ordinary Haskell 98 types, where all the "foralls" are at the left side (or implicit, in H98) are called "rank-1"
16:29:49 <kmc> then, if a type T has a rank-n type on the left side of (->), T is a rank-n+1 type
16:30:31 <kmc> so rank-2 types are of the form:  forall a b c. (forall x y z. S) -> T
16:30:32 <dpratt71> gotta split for a few, thanks all
16:30:46 <FunctorSalad_> dpratt71: I was talking at the level where variables are still tangible things, not yet instantiated
16:30:57 * Saizan_ thinks runST is not a great example to put in a page on existential types
16:31:06 <copumpkin> why not?!?!!?
16:31:09 <copumpkin> om
16:31:10 <copumpkin> g
16:31:14 <kmc> heh
16:31:21 <FunctorSalad_> your business model depends on it?
16:32:54 <Saizan_> it's a bit contortuous(?) to see it as "exists s. (forall a. ST s a -> a)"
16:33:34 <FunctorSalad_> Saizan_: I added a section on how to translate between rank2-forall and existence, dunno if it's still there
16:33:37 <syntaxglitch> If someone is trying to understand runST, discussing existential types will probably confuse them further
16:33:47 <FunctorSalad_> the page is on existentials
16:33:54 <syntaxglitch> if someone is trying to understand existential types, discussing runST will probably confuse them further
16:34:08 <FunctorSalad_> unless they know ST ;) but I didn't add the ST
16:34:09 * Saizan_ agrees with syntaxglitch 
16:34:38 <Saizan_> is there a section on game semantics on that page?:)
16:34:40 <FunctorSalad_> it's like free groups are an awesome example of adjunctions... if you've heard of those before
16:34:59 <syntaxglitch> using one to explain the other turns the quest for understanding into non-well-founded recursion
16:35:02 <ddarius> FunctorSalad_: Usually free monoids are used and everyone has heard of free monoids.
16:36:08 <FunctorSalad_> ddarius: that should work too as an example
16:36:37 <Saizan_> even if you know runST the need to move the quantifiers around makes it a poor example imho, it's bad enough the old syntax did that :)
16:36:39 <FunctorSalad_> the groups are a bit qualitatively different in that expressions can shrink... but that's irrelevant for adjunctions, ok
16:36:47 <FunctorSalad_> (unless I'm missing something)
16:37:32 <FunctorSalad_> (so obtaining normal forms is not all that trivial as with monoids where you just erase parens and units)
16:38:02 <FunctorSalad_> but ok, I don't think this level of detail is evident in the adjunction
16:38:42 <FunctorSalad_> ddarius: btw "everyone has heard of free monoids"? not under that name
16:38:55 <ddarius> I didn't say they had heard of them by that name.
16:38:59 <syntaxglitch> free monoids are pretty much the simplest concept ever
16:39:10 <FunctorSalad_> ddarius: "heard of" is intensional by default imho :p
16:39:15 <FunctorSalad_> but nvm
16:39:17 <copumpkin> omg my monoids want to be free
16:39:20 * copumpkin unties the string
16:39:28 <syntaxglitch> it shouldn't take more than like ten minutes to explain them to someone, once they get over being scared by the weird mathematical name
16:39:50 <ddarius> syntaxglitch: It should take less than a minute.
16:39:56 <FunctorSalad_> syntaxglitch: ? the universal property that defines them is not *that* simple
16:40:08 <FunctorSalad_> even if lists are
16:40:25 <FunctorSalad_> you need to realize how not all monoids allow extension of functions defined on generators
16:40:37 <FunctorSalad_> due to inconsistent consequences...
16:41:34 <FunctorSalad_> (assuming free monoids are defined by the univ. prop.)
16:42:16 <syntaxglitch> well, I was thinking explain in rough terms, not a rigorous formal definition
16:42:24 <dpratt71> back; sorry for the drive-by question
16:42:52 <FunctorSalad_> syntaxglitch: yeah but I mean there's even a nontrivial concept here in rough terms
16:43:08 <FunctorSalad_> about homomorphisms and how they sometimes may not exist
16:43:16 <dpratt71> what would the type of ST be without the existential business: ST s a -> a ?
16:43:29 <ddarius> Explaining what a "free monoid" is doesn't require explaining "free" or even "monoid."
16:43:45 <FunctorSalad_> (example for nonfree monoid: Z/Z6. no homomorphism mapping 1 to the 1 in Z)
16:44:04 <Saizan_> dpratt71: yeah, but at that point the parameter 's' would be completely useless
16:44:15 <FunctorSalad_> ddarius: if you say 'it's a list' you haven't defined free monoids if we want to be really nitpicky
16:44:23 <FunctorSalad_> you have defined a skeleton...
16:44:28 <syntaxglitch> FunctorSalad_, well, maybe there's more to it than I really understand, I guess, I really don't know much math :\
16:44:51 <Saizan_> dpratt71: 's' is never supposed to be given a concrete type (except for stToIO iirc?), it's a just a type-level tag
16:45:42 <Saizan_> dpratt71: to separate STRef's and STArray's you use inside an invocation of runST from another
16:45:51 <FunctorSalad_> syntaxglitch: another way to say it is that lists, with "[]" as unit and "++" as monoid op, and the singleton lists as constants.... satisfy the monoid laws, but *only* the monoids laws, and no other laws!
16:46:02 <FunctorSalad_> that's another way to define `free' for algebras
16:46:16 * dpratt71 is pondering...
16:46:18 <FunctorSalad_> (the monoid laws and what follows from them in equational logic, to be more specific)
16:46:43 <Saizan_> dpratt71: this is done by requiring that the monadic action you pass to runST must work for any choice of 's'
16:47:36 <Saizan_> i.e. for any choice of 's' the computation must have type ST s A, for some A
16:47:43 <FunctorSalad_> syntaxglitch: Z/Z6 with 0, (+) as ops and {1} as supposed generator is a counterexample because it satisfies a law which isn't implied by monoid laws: 1+1+1+1+1+1=0
16:48:05 <syntaxglitch> FunctorSalad_, yeah, though I don't see what that has to do with free monoids?
16:48:07 <dpratt71> Saizan_: ok; so I couldn't pass a monadic action that produces an Int or Bool?
16:48:11 <FunctorSalad_> but Nat,0,(+) on the other hand, is free over {1}
16:48:16 <syntaxglitch> free monoids are arguably a simpler concept than monoids in general
16:48:25 <dpratt71> nvm
16:48:38 <Saizan_> dpratt71: but clearly that A can't contain s then, otherwise the computation will have a different type depending of what 's' will be
16:48:39 <EvanR> semigroups bitches
16:48:39 <dpratt71> confused s and a for a minute
16:48:53 <Saizan_> dpratt71: otherwise A can be anything you want
16:48:57 <FunctorSalad_> syntaxglitch: if you only "lists" you haven't really explained a free monoid imho, since the operations and generators are an integral part of what a free monoid is
16:49:16 <FunctorSalad_> syntaxglitch: rather than just the construction as lists
16:49:43 <syntaxglitch> FunctorSalad_, well, that's what I meant about informal vs. rigorous explanations
16:50:26 <syntaxglitch> though it seems to me that even talking in terms of lists potentially implies structure that isn't there
16:50:53 <FunctorSalad_> lists are fine as representations, I meant specifying [] and (++) is necessary too
16:51:05 <Saizan_> dpratt71: it's kind of a game, runST let you pick anything you want for 'a' but only if you then let runST pick anything it wants for 's'
16:51:15 <FunctorSalad_> and that the element type is the set of generators
16:51:19 <dpratt71> not completely grokking this, yet, but let me ask if this is right...
16:51:38 <idnar> @type runSt
16:51:40 <lambdabot> Not in scope: `runSt'
16:51:46 <idnar> @type runST
16:51:47 <lambdabot> forall a. (forall s. ST s a) -> a
16:52:05 <dpratt71> if I do "newSTRef True", the "s" is defined at that point, even though I don't know what it is?
16:52:30 <copumpkin> :t newSTRef
16:52:32 <lambdabot> forall a s. a -> ST s (STRef s a)
16:52:33 <Saizan_> dpratt71: no, "newSTRef True" is polymorphic in 's'
16:52:43 <mauke> :t newSTRef True
16:52:43 <Cale> dpratt71: Well, newSTRef True will still be polymorphic in s, which is what you want
16:52:44 <lambdabot> forall s. ST s (STRef s Bool)
16:52:51 <syntaxglitch> FunctorSalad_, in a programming context at least, lists potentially imply issues of identity, even if it shouldn't. If I was trying to explain a free monoid to a programmer, I'd avoid it for that reason
16:52:56 <copumpkin> :t newSTRef undefined
16:52:57 <lambdabot> forall a s. ST s (STRef s a)
16:52:58 <Saizan_> (modulo monomorphism restrictions ans such)
16:53:09 <FunctorSalad_> syntaxglitch: (every free monoid is isomorphic to such a list monoid, so lists are not too specific in that way... it's just that you still need the *monoid* part in "list monoid" :))
16:53:12 <pikhq> dpratt71: The "s" is picked by runST, and only by runST.
16:53:27 <dpratt71> but if that value is polymorphic, what prevents "runST (newSTRef True)"?
16:53:39 <copumpkin> :t unsafeSTToIO
16:53:39 <mauke> > runST (newSTRef True)
16:53:40 <lambdabot>   Inferred type is less polymorphic than expected
16:53:40 <lambdabot>    Quantified type variable...
16:53:40 <lambdabot> Not in scope: `unsafeSTToIO'
16:53:57 <Saizan_> dpratt71: "newSTRef True" adds a constraint though, that the 's' of the computation and the 's' of the STRef s Bool are the same one
16:54:10 <kmc> newSTRef True :: ST s (STRef s Bool)
16:54:21 <kmc> therefore hypothetically runST (newSTRef True) :: STRef s Bool
16:54:27 <kmc> but then some code outside that could constrain 's' further
16:54:30 <FunctorSalad_> syntaxglitch: depends on what exactly you want to explain (lists or free monoids)
16:54:33 * dpratt71 feels a headache coming on...
16:54:37 <FunctorSalad_> of course I wouldn't explain lists with all that nonsense
16:54:45 <idnar> @type runST (newSTRef True)
16:54:47 <lambdabot>     Inferred type is less polymorphic than expected
16:54:47 <lambdabot>       Quantified type variable `s' escapes
16:54:47 <lambdabot>     In the first argument of `runST', namely `(newSTRef True)'
16:54:52 <Saizan_> dpratt71: so for "runST (newSTRef True)" to typecheck you'd have to pick a = STRef s Bool for some 's', but then runST wouldn't be able to pick any 's', it'd have to pick the same 's' you've used in your a
16:54:59 <Cale> dpratt71: Basically, it amounts to being that you can't return anything from the ST computation which involves that polymorphic s.
16:55:12 <syntaxglitch> FunctorSalad_, I dunno, I think you have a different idea of "explain" than I meant, so nevermind I guess...
16:55:19 <copumpkin> o.O
16:55:19 <copumpkin> lambdabot: why do you hate me?
16:55:23 <Saizan_> dpratt71: which means you haven't satisified your part of the promise to runST :)
16:55:25 <Cale> dpratt71: When you apply runST, you're supposed to pick the type 'a' independently of the type 's'
16:55:28 <FunctorSalad_> syntaxglitch: identity on lists seems to be harmless though, as long as we take it as a given for the element type
16:55:44 <Cale> dpratt71: (since s is quantified farther in)
16:56:11 <idnar> copumpkin: it replied to your :t with an error
16:56:13 <syntaxglitch> FunctorSalad_, mostly I prefer to avoid familiar, concrete examples when introducing someone to an abstract concept
16:56:31 <FunctorSalad_> syntaxglitch: yeah I was splitting hairs a bit there (just to argue the opposite after you said it's just one minute)
16:56:34 <syntaxglitch> Otherwise they tend to get stuck on irrelevant details from their prior knowledge of whatever the example is
16:57:01 <syntaxglitch> FunctorSalad_, hey, I said ten minutes
16:57:07 <FunctorSalad_> oh right :)
16:57:19 <syntaxglitch> ddarius is the guy who says he can do it one, bug him :P
16:57:20 <kmc> dpratt71, basically, you can't specialize the type «(forall s. ST s a) -> a» to «(forall s. ST s (STRef s a)) -> STRef s a», because that last 's' needs to be the same as the one bound by "forall", but the forall isn't in scope
16:58:35 <FunctorSalad_> syntaxglitch: I guess ddarius/me just disagree on whether you've explained a concept if you only have explained the "shadow" of it in the land of data (here:lists)
16:59:02 <FunctorSalad_> even if it's a complete class of examples as it's here
16:59:05 <copumpkin> idnar: http://snapplr.com/cj4y is why I thought it hated me :)
16:59:08 <dpratt71> on some level, I get (I think) what you are all trying to help me understand: that s and a must be independent of each other
16:59:16 <ddarius> FunctorSalad_: I haven't put forth how I would explain it at all.
16:59:25 <idnar> copumpkin: ....ouch
16:59:33 <copumpkin> idnar: yeah, no idea what's going on :P
16:59:38 <dpratt71> the mechanics and implications of that have not yet "jelled", though
16:59:43 <FunctorSalad_> ddarius: lists are the only plausible way to explain it to a nonmathematician in a few minutes
16:59:50 <dpratt71> I think I just need to ponder it a bit more
17:00:13 <kmc> dpratt71, probably
17:00:22 <ddarius> FunctorSalad_: And who says I would have stopped at saying "They're lists"?
17:00:30 <dolio> There's a second function that the quantification provides.
17:00:46 <syntaxglitch> I still say "lists" are problematic, depending on who you're explaining to
17:00:50 <kmc> dpratt71, remember that code outside of the call to runST can place additional constraints on 'a', by how it uses 'a'
17:01:14 <syntaxglitch> either too abstract in some cases, or carrying too much baggage in others (e.g., a programmer used to impure languages)
17:01:15 <kmc> :t fromIntegral . runST
17:01:17 <lambdabot> forall a b. (Integral a, Num b) => (forall s. ST s a) -> b
17:01:17 <dpratt71> kmc: right
17:01:22 <FunctorSalad_> ddarius: uh, the clock? but I don't want to sound like I'm being confrontational again, I really don't have much of a stake in this issue ;)
17:01:22 <dolio> runST (do r <- newSTRef 0 ; let v = runST (readSTRef r) ; return v) is invalid.
17:01:23 <ddarius> syntaxglitch: It depends.
17:01:35 <kmc> dpratt71, so if 's' and 'a' are related, then the 'forall s' part is a lie, because constraints on 'a' could constrain 's'
17:02:24 <dolio> Which is rather important.
17:02:29 <FunctorSalad_> syntaxglitch: hmm I thought lists are one of the things math and CS actually agree on more or less ;)
17:02:53 <ddarius> kmc: Couldn't you just say, at least for the newSTRef case, that if you tried to substitute for a you'd need runST to have type: (forall s. ST s (STRef s Int)) -> STRef s Int and the last s isn't bound at all.
17:03:03 <kmc> yeah i said that above, sort of
17:03:19 <FunctorSalad_> (even pure programmers would say that linked lists and array lists are just different implementations of lists, I guess)
17:03:29 <shapr> Has anyone here used TerraHS?
17:04:01 <dolio> For instance, I think 'runST (do r <- newSTRef 0 ; let { x = runST (readSTRef r) ; y = runST (writeSTRef 1 r >> return 0) } ; return (x, y))' would exhibit nondeterministic behavior in the GHC implementation.
17:04:09 <ville> Is there a particular reason, other than ability to switch out backends in the future, for using Grapefruit over Gtk2Hs? Is one considered to have a more modern or Haskell-esque interface?
17:04:55 <shapr> TerraHS looks like a full-on GIS solution, I wonder if I could just strip it down to the ZIP code distance function... and I wonder if ESRI files are the same as TIGER/Shape files.
17:05:04 <FunctorSalad_> dpratt71: didn't catch the whole thread, but as I see it, the crucial thing is that 1. you have to substitute some type expression - which may contain type variables - for `a', and 2. variables are never captured by entering the scope of a "forall" -- if there's a name clash, we rename
17:05:10 <syntaxglitch> FunctorSalad_, if two objects in the list are equal, are they the "same" object? Mutability requires a notion of identity that's extremely not helpful for thinking about abstract math
17:05:29 <shapr> edwardk1: Hey, do you know if TIGER/Shape files are the same as ESRI files?
17:05:40 <FunctorSalad_> (forall a. (forall s. runST s a) -> a) -- try to insert '(Int,s)' for a
17:05:49 <FunctorSalad_> the no-capture rule will yield the result type of:
17:05:58 <FunctorSalad_> forall s. runST s (Int,s1) -> (Int,s1)
17:06:27 <FunctorSalad_> it has to be that way because *bound* names are absolutely meaningless
17:06:41 <syntaxglitch> If someone has not much mathematical background and years of experience in impure languages, they usually develop some sort of Stockholm syndrome about equality of value vs. reference
17:06:46 <FunctorSalad_> (except for being different from other names)
17:07:53 <FunctorSalad_> syntaxglitch: ok, but they'd agree that the two lists are equal if we use the comparison functions which compares elements
17:08:18 <FunctorSalad_> different equalities aren't a foreign concept in programming
17:08:49 <syntaxglitch> FunctorSalad_, yes, but my point is that it's better to choose examples that won't invoke irrelevant details like that
17:08:59 <FunctorSalad_> syntaxglitch: ah :)
17:08:59 <syntaxglitch> It distracts from the point
17:09:06 <syntaxglitch> see also: monads are burritos
17:09:57 <syntaxglitch> monad tutorials are an impressive case study in failing to explain abstract concepts by poor examples dredging up a whole bunch of irrelevant details
17:10:25 * wli never did get anywhere with his monad tutorial writing combinators.
17:10:28 <FunctorSalad_> dpratt71: a variable occurence is called "bound" btw if it is a subexpression (in the syntax tree) of a "forall s. ....."
17:10:37 <Draconx> syntaxglitch, I think the same can be said about pretty much anything calling itself a "tutorial".
17:10:37 <dpratt71> kmc: relating to something you said, supposing we start with the (usually implied) "forall a s." , it is possible to express something that relates s to a, but when we start with "(forall a. (forall s.", it isn't possible for them to be related?
17:11:05 <FunctorSalad_> (the point is that bound names have zero meaning outside the "forall" expression that binds them)
17:11:12 <FunctorSalad_> in sane languages :p
17:11:26 <syntaxglitch> Draconx, probably, but only to a degree proportional to how abstract the subject of the tutorial is
17:12:21 <FunctorSalad_> syntaxglitch: I thought monad tutorials simply failed because the task is impossible, not due to poor execution
17:12:42 <FunctorSalad_> there is no silver bullet, you have to do the neural net training of using them
17:13:31 <FunctorSalad_> (as with many very abstract concepts)
17:13:44 <syntaxglitch> the task isn't impossible, it's just that reading a bad tutorial can leave someone worse off than before
17:14:45 <syntaxglitch> explaining abstract concepts effectively is a very different skill than learning them, and probably more challenging
17:15:50 <dolio> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25605#a25605
17:17:50 <FunctorSalad_> syntaxglitch: the explanation skill isn't irrelevant, but no amount of explanation skill will make someone just "get" a concept if they have never used it, or have used something to which a *good* metaphor can be drawn
17:18:31 <FunctorSalad_> that's the value of metaphors in explanation after all... they allow transfer of existing mental faculties to the new problem
17:19:31 <syntaxglitch> FunctorSalad_, a lot of what "skilled at explaining" means is being able to figure out what inferential steps the audience lacks and being able to identify a chain of good metaphors/examples to get them to the target concept
17:19:55 <FunctorSalad_> syntaxglitch: I agree
17:20:41 <syntaxglitch> People who understand abstract concepts very well often have a TERRIBLE sense for that, leading to confusingly useless explanations
17:20:47 <FunctorSalad_> it's just that if the area isn't coverable even by the metaphorically related subjects... then there isn't much replacement for exercise
17:21:49 <FunctorSalad_> (and/or simply time)
17:22:11 <syntaxglitch> being able to learn the concept by using it requires being 99% of the way to grasping it, though
17:22:41 <FunctorSalad_> hmm, I'd have said being able to learn it by explanation alone takes 99% :)
17:22:44 <Pseudonym> I agree for a different reason.  Knowing that it would be useful here is 99% of the battle.
17:23:11 <syntaxglitch> both, really
17:23:32 <syntaxglitch> 98% = "I don't know how to use this and I have no idea what you're talking about"
17:23:35 <FunctorSalad_> to understand it from explanation alone, you need to know enough other things already, so that the teacher just has to say "it's like widgets which are also gadgets but with this difference: ..."
17:24:17 <FunctorSalad_> I didn't mean using without aid of course
17:24:49 <syntaxglitch> well yeah, just explaining something won't ever work alone
17:25:03 <syntaxglitch> the idea is to point people in the right direction for what they need to learn by using
17:25:49 <Pseudonym> Monads are burritos.
17:26:01 <syntaxglitch> it's possible to learn a great deal just by trying to use anything you almost-but-not-quite understand, but that usually leads to a breadth-first traversal
17:26:02 <edwardk1> and space suits
17:26:14 <syntaxglitch> whereas real life, unfortunately, usually demands depth-first :(
17:26:16 <Pseudonym> And bananas and lenses and barbed wire.
17:26:19 <edwardk1> wearing a burrito in space is a terrible way to die
17:26:37 <FunctorSalad_> syntaxglitch: learning-by-using is why I think go-to-definition-of-thing-at-point is such a crucial functionality to have
17:26:40 <edwardk1> Pseudonym: nah those are other things, that just happen to be able to be parameterized by a burrito or coburrito
17:26:42 <FunctorSalad_> (or to documentation)
17:26:52 <syntaxglitch> spacesuits in an endoburrito category
17:26:54 <FunctorSalad_> with software, at least
17:27:36 <syntaxglitch> ugh, I should stop slacking off and get some coding done
17:27:37 <FunctorSalad_> syntaxglitch: that's the hidden value of slacking isn't it? ;) that you get to follow various things of interest in that breadth-first matter
17:28:16 <syntaxglitch> FunctorSalad_, it's fun, but hard to make a living that way :(
17:28:16 <FunctorSalad_> (unless you're actually doing nothing... but I slack by learning random things as long as they're not what I need to be doing)
17:28:22 <FunctorSalad_> syntaxglitch: sadly
17:28:39 <syntaxglitch> right now I'm procrastinating on working on a Haskell library I wanted to have semi-working like a month ago
17:29:29 <syntaxglitch> dealing with serious performance problems without access to any sort of profiler or debugger is frustrating
17:29:46 <FunctorSalad_> why no access?
17:29:49 <c_wraith> why don't you have those?
17:29:54 <c_wraith> I have those.
17:30:00 <syntaxglitch> because it's type-level code
17:30:03 <c_wraith> oh
17:30:07 <c_wraith> yeah, ouch
17:30:11 <syntaxglitch> I guess I could profile GHC's type checker
17:30:15 <FunctorSalad_> syntaxglitch: one of the -ddump ?
17:30:15 <syntaxglitch> that sounds like LOADS of fun
17:30:29 <FunctorSalad_> syntaxglitch: maybe you can just "ghc +RTS -P"?
17:30:56 <FunctorSalad_> -ddump-tc or whatever it was could be useful to detect loops at least
17:31:02 <FunctorSalad_> it's way too verbose to read through it
17:31:45 <syntaxglitch> it's just terrible time complexity due to unnecessary recomputation, I'm fairly certain
17:31:49 <FunctorSalad_> hmm the ghc binary distribution has no -P apparently
17:33:40 <syntaxglitch> e.g., it's recursively analyzing a value in order to recursively do something to it, so each step needlessly recurses over the entire remaining structure
17:34:15 <syntaxglitch> and I got kinda burned out trying to find a way to avoid that while still providing a sane interface to the functionality
17:35:56 <syntaxglitch> well, as sane as type-level metaprogramming ever is
17:35:59 * syntaxglitch sighs
17:36:36 * Saizan suggests syntaxglitch to cabal install Agda
17:36:53 <Saizan> it has an haskell FFI!
17:37:06 <copumpkin> mmm
17:37:19 <syntaxglitch> Saizan, definitely tempting
17:37:27 <copumpkin> has anyone ever used the haskell FFI on it?
17:37:40 <copumpkin> I don't think I've ever run an agda program
17:37:49 <FunctorSalad_> syntaxglitch: no idea what you're doing; replacing some typelevel stuff with TH *may* be an option
17:37:53 <Saizan> copumpkin: someone posted a web framework on the mailing list some weeks ago
17:38:09 <ddarius> copumpkin: Do you just stare at them?
17:38:23 <FunctorSalad_> (e.g., for printf it's the better choice imho)
17:38:27 <copumpkin> ddarius: I typecheck, and occasionally use the normalize key combo
17:38:28 <dolio> Just type check.
17:38:39 <monochrom> haha
17:38:47 <Saizan> yeah, don't be silly, staring wouldn't do any good
17:38:51 <copumpkin> I'm not kidding :P
17:39:05 <syntaxglitch> FunctorSalad_, trying to put together a simple type metaprogramming library with some type safety features ... TH would kinda miss the point
17:39:15 <FunctorSalad_> syntaxglitch: ah
17:40:07 <syntaxglitch> It's mostly for fun, though also trying to consolidate some simpler type metaprogramming I've used elsewhere
17:40:15 <dolio> I finally got around to working through Eckmann-Hilton this morning: http://code.haskell.org/~dolio/agda-share/html/EckmannHilton.html
17:40:33 <FunctorSalad_> (or for n-ary anything... liftMn with TH would be way less of an headache than with typeclasses)
17:40:51 <FunctorSalad_> (but too much to type to use it)
17:41:04 * copumpkin doesn't know what Eckmann-Hilton is
17:41:05 * copumpkin looks it up
17:41:20 <dolio> I explain it in the file.
17:41:31 <SubStack> curse you ghc-pkg!
17:41:32 <SubStack>     Could not find module `Data.Map':
17:41:42 <copumpkin> aha
17:42:06 <FunctorSalad_> build-deps: containers?
17:42:21 <SubStack> I get this message in ghci
17:42:34 <SubStack> containers-0.3.0 is exposed
17:42:37 <FunctorSalad_> oh
17:42:56 <copumpkin> neat
17:44:25 <edwardk1> dolio: it camr up on my blog a couple years back: http://comonad.com/reader/2008/just-fokkinga-abide/
17:44:27 <edwardk1> er came
17:46:08 <SubStack> Distribution.Simple is now missing too :|
17:47:15 <FunctorSalad_> "Eckmann" sounds enterprisy even without the Hilton somehow ;)
17:47:27 <FunctorSalad_> I keep forgetting it's context
17:48:21 <edwardk1> "I'll be staying at the Eckmann Hilton.."
17:48:24 <FunctorSalad_> *looks up* and I even knew that result (by statement)
17:48:30 <FunctorSalad_> edwardk1: yes, like that
17:56:11 <uorygl> So, I wonder what sort of project I could undertake that would take about an hour.
17:56:52 <copumpkin> prove something simple in agda?
17:57:10 <uorygl> Perhaps I could implement Martin-Lof type theory in Haskell.  :)
17:57:30 <copumpkin> yeah, or that ;)
17:57:31 <dolio> That'll take more than an hour.
17:57:51 <uorygl> Aww.
17:58:00 <djahandarie> threadDelay 3600000000
17:58:03 <uorygl> How about just Martin type theory?
17:58:04 <Pseudonym> uorygl, one thing that will only take an hour is pick up any paper with sequent calculus in it and implement THAT theory.
17:58:08 <uorygl> Maybe just Lof type theory?
17:58:22 <Pseudonym> type MartinLoef = Either Martin Loef
17:58:45 <uorygl> > LÃ¶f
17:58:46 <lambdabot>   Not in scope: data constructor `LÃ¶f'
18:00:19 <uorygl> I've come up with a cute little list of types for almost every primitive type constructor in Martin-LÃ¶f type theory.
18:00:29 <uorygl> Unfortunately, I have no idea how to break inductive types down into primitive type constructors.
18:01:07 <uorygl> Suppose we have data FunTree a b = Leaf | Branch (a -> FunTree b).
18:01:13 <uorygl> Then FunTree = ?
18:01:42 <copumpkin> http://imgur.com/5Xp9e.jpg
18:01:50 <FunctorSalad_> you want to pointlessinate it or?
18:01:55 <uorygl> Yes.
18:02:01 <copumpkin> That is He!
18:02:15 <uorygl> copumpkin: that is whom?
18:02:17 <FunctorSalad_> hmm in GADT syntax you can do "FunTree :: (* -> * -> *)"
18:02:25 <FunctorSalad_> *but* you still need the points for the ctors...
18:02:30 <copumpkin> uorygl: Martin-LÃ¶f!
18:02:38 <uorygl> Oh, so it is!
18:02:51 * Pseudonym keeps seeing "Martin-LApf"
18:02:53 <copumpkin> he studied with kolmogorov!
18:03:09 <edwardk1> uorygl: I suppose half a LÃ¶f is better than none.
18:03:21 <monochrom> ha ha
18:03:48 <FunctorSalad_> uorygl: I don't see why you need pointlessness to properly implement a type theory
18:04:06 <uorygl> Well, it seems that would make it easier.
18:04:41 <FunctorSalad_> you can use the unapplied "FunTree" in some contexts... just not in its definition
18:06:17 <uorygl> The problematic thing about these types is that they're recursive...
18:07:25 <Gracenotes> quoth ghc, Module `Data.Sequence' does not export `:<'
18:07:32 <FunctorSalad_> ah. the primitive for that is usually the least or greatest fixpoint operator
18:07:37 <edwardk1> FunctorSalad: There seems to be a paradox or at least a contradiction inherent in your statement. If without pointlessness it is pointless to build a type theory, then you have pointlessness, but we assumed that it was not pointlessness, contradiction.
18:07:48 <uorygl> Haskell uses the least fixpoint, right?
18:07:50 <edwardk1> er that it was not pointless
18:07:50 <djahandarie> Is there a fromList where you provide a funciton which lets you change the key rather than the value on duplicate keys?
18:08:07 <edwardk1> uorygl: you can use ! annotations to simulate the other
18:08:08 <FunctorSalad_> FunTree a b = mu X. Leaf | Branch (a -> X)
18:08:08 <Gracenotes> I could swear elephant tusks were exported in 6.10.4...
18:08:15 <uorygl> Or maybe the greatest fixpoint.  :P
18:08:27 <FunctorSalad_> uorygl: I heard they're the same in haskell
18:08:31 <uorygl> Anyway, what happens if somebody tries to do Fix Not?
18:08:35 <FunctorSalad_> dunno how far that is formalized
18:08:53 <uorygl> Perhaps I can take a hint from the term "inductive".
18:09:26 <uorygl> Like, if there is a function (forall a. a -> f a), then Fix f is valid.
18:09:35 <FunctorSalad_> @t M.fromListWithKey
18:09:35 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:09:40 <edwardk1> functorsalad: you can foldr any unfoldr, the former consumes mu but the latter produces nu, mu = nu
18:09:52 <FunctorSalad_> @ty M.fromListWithKey
18:09:53 <lambdabot> forall k a. (Ord k) => (k -> a -> a -> a) -> [(k, a)] -> M.Map k a
18:10:09 <FunctorSalad_> that doesn't quite do what djahandarie wanted
18:10:16 <djahandarie> Yeah
18:11:16 <FunctorSalad_> djahandarie: you could make a "Map k [a]" and change keys in a second pass maybe
18:11:18 <djahandarie> I would need something like (Ord k) => ((k,a) -> (k,a) -> (k,a)) -> [(k, a)] -> M.Map k a
18:11:25 <uorygl> So, does that sound right to you guys?  For a type constructor f, if there is a function (forall a. a -> f a), then f has a fixed point that doesn't lead to contradiction?
18:11:47 <FunctorSalad_> (so the Data.Map still does the grouping-in-n*log(n) for you)
18:12:17 <djahandarie> Hm, yeah that could work
18:12:38 <FunctorSalad_> edwardk1: that the types fit needn't mean all the equations hold; it's the usual disclaimers again I guess
18:13:08 <edwardk1> FunctorSalad_: that was a very gross simplification =)
18:13:58 <FunctorSalad_> (the usual ones about seq and so on)
18:14:05 <ddarius> mu = nu => fix
18:14:12 <djahandarie> @pl (\f g -> f . g . f)
18:14:12 <lambdabot> liftM2 (.) (.) (flip (.))
18:14:35 <uorygl> @type ((.) . (.) . (.))
18:14:36 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
18:14:48 <edwardk1> you can get there by constructing the definition for ana and cata, defining the fixed points based on their properties using existentials and universals, and show that you can convert back and forth, then show that there exist similar categories (i.e. just with the addition of strictness, or limiting the set of morphisms) where that doesn't hold
18:14:53 <djahandarie> lol, caleskell in action
18:14:59 <uorygl> @type let (f . g) x = f (g x) in ((.) . (.) . (.))
18:15:00 <lambdabot> forall t t1 t2 t3 t4. (t2 -> t3) -> (t -> t1 -> t4 -> t2) -> t -> t1 -> t4 -> t3
18:15:13 <Cale> It's telling you the right way to think of it :)
18:15:14 <uorygl> What a strange choice of numbers.
18:15:20 <edwardk1> uorygl: i see you decided to explore the properties of the total recall operator
18:15:21 <uorygl> Boob functions are fun, aren't they.
18:15:36 <uorygl> edwardk1: what's this, now?
18:15:57 <copumpkin> total recall had a woman with three boobs
18:16:00 <copumpkin> ()
18:16:01 <edwardk1> http://nanashi.org/images/total_recall_3_boobs.jpg [NSFW]
18:16:22 <uorygl> Strange.
18:16:25 <copumpkin> edwardk1 always has that image on hand
18:16:26 <copumpkin> ...
18:16:26 <dolio> uorygl: Most type theories require strictly positive types.
18:16:46 <uorygl> Indeed, but can I turn that into a combinator?
18:16:48 <Cale> I don't know about everyone else, but I find thinking about (.).(.).(.) a whole lot simpler when I think of it as three fmaps being composed
18:16:57 <copumpkin> I agree
18:17:05 <uorygl> That makes sense.
18:17:27 <djahandarie> But the type signature is crazy
18:17:34 <Cale> Anyone playing/finished that manufactoria game? :)
18:17:45 <copumpkin> not really
18:17:54 <edwardk1> or fmap fmap fmap fmap fmap
18:18:05 <edwardk1> @type fmap fmap fmap fmap fmap
18:18:06 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
18:18:08 <Axman6> so, if i have an STUArray s Char Int, and i want to get a list of all Char, Int pairs, where the Int is > 0, what would be the most efficient way to do that?
18:18:10 <FunctorSalad_> or maybe one shouldn't abuse (.) like that at all and use "dom" and "cod" for sectioning ;)
18:18:17 <Cale> I'm down to the last 7 levels
18:18:28 <copumpkin> > (fmap . fmap . fmap) (+1) [Just (Identity 5), Nothing]
18:18:29 <lambdabot>   No instance for (GHC.Show.Show (Control.Monad.Identity.Identity a))
18:18:29 <lambdabot>    aris...
18:18:29 <FunctorSalad_> @let dom d f = f . d
18:18:30 * uorygl tries to remember what function he decided should be called "fap".
18:18:30 <lambdabot>  Defined.
18:18:35 <FunctorSalad_> @let cod c f = c . f
18:18:36 <lambdabot>  Defined.
18:18:39 <copumpkin> why the hell isn't there a Show for it, anyway
18:18:41 <edwardk1> there is something disturbing about the fact that in response to (.).(.).(.) the channel starts going fmap fmap fmap fmap fmap....
18:18:42 * copumpkin shakes his fist
18:18:51 <djahandarie> LOL
18:19:03 <Saizan> uorygl: f = (,) Int; (,) 1 :: a -> (Int,a), Fix f = Stream of Ints, induction on streams let you prove false
18:19:11 <Cale> "OUTPUT: Reverse the input string!" *sob*
18:19:41 <uorygl> Saizan: *streams* lead to inconsistency?
18:19:50 <uorygl> How do you do that?
18:19:55 <dolio> If you have induction on them, yes.
18:20:11 <copumpkin> coinduction!
18:20:12 <FunctorSalad_> I once gave "fmap fmap fmap" as a legitimate answer here, beat that :p
18:20:15 <Saizan> a stream is infinite, recursion on it will never terminate.
18:20:47 <edwardk1> FunctorSalad_: i once needed 7 ;)
18:20:54 <FunctorSalad_> uorygl: maybe "ap" wrapped in an fmap or the other way
18:20:58 <FunctorSalad_> edwardk1: :)
18:21:11 <uorygl> What happens if you try to do that in Agda?
18:21:24 <Saizan> ?type let f (_:xs) = f xs in f
18:21:26 <lambdabot> forall t t1. [t] -> t1
18:21:37 <dolio> The inductive fixed point of that will be empty.
18:21:49 <dolio> And the coinductive fixed point won't let you do induction.
18:22:04 <uorygl> What if you do "data Stream a = Stream a (Stream a)" in Agda?
18:22:11 <dolio> It's empty.
18:22:15 <uorygl> Huh.
18:22:19 <Saizan> you've to do codata
18:22:27 <uorygl> Aiee, codata.  :)
18:22:37 <ddarius> dolio: You should replace all uses of Void in your Agda code with former math challenges that turned out not to be true.
18:22:42 <dolio> Not provably empty, perhaps, but you will be unable to construct a value.
18:22:47 <monochrom> hahahaha
18:22:52 <edwardk1> ddarius: hahahaha
18:23:08 <syntaxglitch> FunctorSalad_, fmap is "map" for Functors, clearly "fap" should be "ap" for Functors, which I guess means it'd be the non-operator version of (<*>)?
18:23:11 <uorygl> Well, maybe it would be fine to replace the fixpoint combinator with Church numerals.
18:23:13 <Saizan> uorygl: and if you write a function like "foo (Stream _ xs) = foo xs" when Stream is defined with codata the productivity checker will complain and paint it yellow :)
18:23:20 <FunctorSalad_> uh that wouldn't let you eliminate the Absurdity
18:23:22 <monochrom> f :: Int -> (exists integer solutions to x^10 + y^10 = z^10)
18:23:25 <uorygl> If I want a tree, I feed it a 1; if I want a deeper tree, I feed it a 2; and so on.
18:23:26 <FunctorSalad_> unless you prove the math problem wrong
18:23:29 <copumpkin> Saizan: pink?
18:23:30 <edwardk1> ddarius: or just unsolved problems in general, that way when some smart ass comes up with a counter example you just take it, publish it, and rake in the fame
18:23:43 <copumpkin> oh maybe it is yellow
18:23:43 <Saizan> copumpkin: ah, true
18:23:47 <monochrom> g :: Bool -> (PRIMES is not in P)
18:24:05 <ddarius> -- This code is buggy if P = NP.
18:24:21 <dolio> ddarius: I'll stick with using the law of the excluded middle, like the intuitionists. :)
18:24:31 <edwardk1> supply an oracle for the halting problem to continue...
18:24:43 <FunctorSalad_> syntaxglitch: we have the problem that `ap' already is about (applicative) functors, so fap should be an extra layer of functor I think
18:24:50 <uorygl> I prefer Peirce's law to the law of the excluded middle, since Peirce's law actually has an obvious implementation, kind of.
18:24:51 <copumpkin> uorygl was using a postulated LEM in agda for a while, iirc
18:24:54 <Cale> Heh, use the user as a halting oracle
18:25:03 <blackdog> ddarius: where was that comment?
18:25:10 <edwardk1> Cale: has worked for me so far ;)
18:25:18 <monochrom> sacrifice a user to continue
18:25:31 <FunctorSalad_> insert coin
18:25:50 <Saizan> tap an island
18:25:51 <Cale> "To allow the program to proceed, does the following Turing machine halt on empty input? <graph of Turing machine>"
18:25:52 <syntaxglitch> FunctorSalad_, ap has a Monad constraint though, so I figure it'd just be another unnecessary extra name for the same operation
18:26:16 <FunctorSalad_> kill -9 cannot be countered except by zombie processes...
18:26:20 <copumpkin> fap = applicative Functor's ap
18:26:21 <monochrom> turing captcha
18:26:23 <dolio> copumpkin: People use LEM in coq. That's why they disabled impredicative Set.
18:26:42 <syntaxglitch> there's no shortage of redundant names for the same function on Functor/Applicative/Monad anyway, what's one more
18:26:43 <Cale> "Prove you're superhuman!"
18:26:47 <uorygl> copumpkin: right, right.
18:26:55 <edwardk1> syntaxglitch: blame the type system ;)
18:26:56 <ddarius> @djinn-add class EM a where em :: Either a (Not a)
18:27:09 <ddarius> @djinn Em a => ((a -> b) -> a) -> a
18:27:09 <lambdabot> Error: Class not found: Em
18:27:11 <dpratt71> is there an automated way to de-sugar a "do"?
18:27:14 <ddarius> @djinn EM a => ((a -> b) -> a) -> a
18:27:14 <lambdabot> f a =
18:27:14 <lambdabot>     case em of
18:27:14 <lambdabot>     Left b -> b
18:27:14 <lambdabot>     Right c -> a (\ d -> void (c d))
18:27:18 <copumpkin> prove that you cannot prove this statement
18:27:19 <dibblego> dpratt71, @undo
18:27:19 <FunctorSalad_> dpratt71: lambdabot
18:27:32 <dpratt71> dibblego: figures; thanks
18:27:56 <uorygl> copumpkin: oh, that's an easy one.
18:28:01 <syntaxglitch> edwardk1, unfortunately I usually lose arguments with the type system
18:28:25 <uorygl> I am human.  Therefore, I am irrational.  Therefore, I have a false belief.  Let X be such a belief.  X is true.  However, X is false.  Therefore, all statements are true.  Therefore, it is true that I cannot prove that statement.
18:29:02 <copumpkin> uorygl: you forgot the square
18:29:04 <copumpkin> an essential component
18:29:22 <ddarius> @djinn-add class Peirce a where callCC :: ((a -> Void) -> a) -> a
18:29:36 <ddarius> @djinn Peirce a => Either a (Not a)
18:29:37 <lambdabot> -- f cannot be realized.
18:29:39 <ddarius> Curses.
18:29:39 <copumpkin> uorygl: â
18:29:47 <uorygl> Oh, right, sorry.
18:29:57 <uorygl> I am human.  Therefore, I am irrational.  Therefore, I have a false belief.  Let X be such a belief.  X is true.  However, X is false.  Therefore, all statements are true.  Therefore, it is true that I cannot prove that statement.  â
18:29:58 <dolio> Getting djinn to do peirce -> lem is ugly.
18:30:45 <syntaxglitch> "QED, abbr. 'quod erat demonstrandum' -- Latin, lit. 'because I said so'"
18:31:09 <dolio> @djinn Peirce (Either a (Not a)) => Either a (Not a)
18:31:10 <lambdabot> f =
18:31:10 <lambdabot>     case callCC (\ a -> Right (\ b -> a (Left b))) of
18:31:10 <lambdabot>     Left c -> Left c
18:31:10 <lambdabot>     Right d -> Right d
18:31:16 <dolio> I guess it's not bad with that class.
18:31:19 <ddarius> @pl callCC (\k -> Right (k . Left))
18:31:19 <lambdabot> callCC (Right . (. Left))
18:31:33 <ddarius> Interesting eta expansion.
18:31:37 <uorygl> Hey, djinn did it correctly.
18:32:01 <copumpkin> syntaxglitch: not quite :P
18:32:13 <syntaxglitch> copumpkin, ;)
18:32:57 <ddarius> copumpkin: Remember what happened to that person that told Pythagoras that sqrt(2) wasn't rational?
18:33:49 <monochrom> Not Pythagoras himself. Some students of Pythagoras long after Pythagoras was dead.
18:34:16 <edwardk1> ddarius: yeah, pythagoras published first ;)
18:35:06 <ddarius> Ah, I understand the eta expansion (I think)
18:35:19 <dolio> Really?
18:35:27 <ddarius> dolio: It's a type coercion.
18:35:51 <dolio> Yeah. It occurred to me just after I said "really".
18:36:10 <Saizan> ..really?
18:36:35 <dolio> @type \x -> case x of Left c -> Left c ; Right d -> Right d
18:36:35 <lambdabot> forall t b. Either t b -> Either t b
18:36:51 <Saizan> yeah, it doesn't look like it can coerce types
18:36:52 <dolio> No, I guess that can't be right.
18:36:56 <Pseudonym> Tycho Brahe lost his nose in a duel over a maths problem.
18:37:15 <syntaxglitch> Pseudonym, and now he makes webcomics
18:37:25 <ddarius> Pseudonym: Back when men knew how to settle logical disputes.
18:37:29 <Pseudonym> Supposedly.
18:37:33 <Pseudonym> Yeah.
18:37:49 <Pseudonym> It's a shame that Galois' duel was over a woman.
18:37:56 <Pseudonym> It'd be much better if it was over algebra.
18:38:01 <copumpkin> how about Galois' dual?
18:38:21 <Pseudonym> He colost the dual.
18:38:32 <monochrom> hahaha
18:38:43 <monochrom> He colost the duel
18:41:31 <syntaxglitch> I need to stop looking at the Haskell "high score list" on Stack Overflow
18:41:39 <edwardk1> hrmm does anyone have some kind of namespace hierarchy browser that cuts across all of hackage?
18:41:45 <edwardk1> syntaxglitch: hahaha
18:41:55 <Axman6> edwardk1: hayoo?
18:42:01 <syntaxglitch> Norman Ramsey is superhuman, I can't keep up with that :(
18:42:06 <ezyang> user is having problems interacting with mailnig lists :-/ http://pastebin.com/sVLtVAuG
18:42:31 <edwardk1> Axman6: can i walk down from Data and see all the things one level below so i know what corners of the namespace look populated?
18:42:36 <edwardk1> syntaxglitch: yeah
18:43:22 <syntaxglitch> edwardk1, I still think you deserve some sort of prize for that AD library
18:43:37 <syntaxglitch> I've spent way too much time on SO answers but that was above and beyond the call of duty
18:43:46 <edwardk1> syntaxglitch: =)
18:43:59 <edwardk1> syntaxglitch: i'm still working on it actually ;_)
18:44:06 <syntaxglitch> that's more like the greatest fixed point of the call of duty
18:44:13 <ddarius> edwardk1: That's why you made that?
18:44:43 <edwardk1> ddarius: well, i made a comment that it can't be done in pure haskell and sigfpe made a comment that sparked an idea in my head about how to use stablenames for it
18:45:09 <edwardk1> ddarius: i'd taken a stab at reverse mode ad last year some time, but this got me thinking about it again
18:45:12 <FunctorSalad_> is there a standalone go-to-haddock utility?
18:45:22 <Axman6> edwardk1: i don't believe so
18:45:39 <FunctorSalad_> (local haddock)
18:46:29 <edwardk1> Axman6: shucks that is what i'm looking for. the closest i get is the old http://cvs.haskell.org/Hugs/pages/libraries/ kind of pages
18:47:20 <edwardk1> just trying to find a better namespace for some code and i'd prefer for it to be in a space near other code of its ilk
18:49:13 <edwardk1> did Numeric pick up a hierarchical module name?
18:49:47 <dolio> I don't think so.
18:50:47 <syntaxglitch> edwardk1, by the way, dunno if you remember a discussion we had about type-level metaprogramming a while back, but I kinda hit a wall with my library and had to take a break :(
18:51:01 <edwardk1> syntaxglitch: drat. what got you
18:51:14 <syntaxglitch> performance issues of all things
18:51:39 <edwardk1> ?
18:51:47 <Cale> Heh, it turns out that some of the harder manufactoria puzzles have really stupid possible solutions.
18:51:48 <syntaxglitch> My "kind"-checking kept hitting horrible time complexity and untangling the algorithm to optimize it while still presenting a usable interface was painful
18:51:49 <Axman6> @hoogle unsafe
18:51:49 <lambdabot> Language.Haskell.TH unsafe :: Safety
18:51:49 <lambdabot> Language.Haskell.TH.Lib unsafe :: Safety
18:51:49 <lambdabot> module Data.ByteString.Unsafe
18:52:02 <edwardk1> ah
18:52:02 <Axman6> @hoogle unsafeRead
18:52:02 <lambdabot> No results found
18:52:05 <Axman6> :(
18:52:23 <edwardk1> @hoogle fromRat
18:52:24 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
18:52:24 <lambdabot> Prelude fromRational :: Fractional a => Rational -> a
18:52:32 <syntaxglitch> edwardk1, I was observing what seemed to be something like O(n^2) where n was the number of type function applications in an expression
18:52:33 <Cale> As in, use "test driven development" to make the tests (and only the tests) pass.
18:52:33 <edwardk1> yeah looks like Numeric never moved
18:55:08 * edwardk1 has two classes he needs to merge, 'Primal' and 'Mode' into one and keep one name... Mode is more descriptive of the resulting class but 'Primal' sounds cooler ;)
18:55:14 <syntaxglitch> edwardk1, obviously that made it unusable, and I was too burnt out from other stuff to try and find some way to profile GHC's type checker
18:55:26 <edwardk1> syntaxglitch: *nods*
18:57:17 <monochrom> PrimalMode
18:57:26 <monochrom> ModalPrime
18:57:44 <syntaxglitch> edwardk1, what do you think about moving checking into a separate step? e.g., require the user to run a "kind check" operation first before evaluating an expression
18:58:27 <syntaxglitch> seems kinda lame and less usable, but it'd make it easier to disentangle stuff...
18:58:29 <edwardk1> syntaxglitch: i do it in my toy type level fingertree lib
18:58:56 <edwardk1> syntaxglitch: you use a separate type family to check types: :::
18:59:50 <syntaxglitch> I was thinking of having some sort of "kind annotation" pseudo-syntax that isn't exported, so you'd take an expression, run it through the checker to get annotations, then give it to the evaluator
19:00:38 <syntaxglitch> edwardk1, actually ::: is what I was going to use for the annotations, but maybe that would be nicer as the check function
19:01:22 <edwardk1> i put together two of them, one to infer and one to check, based on typechecking algorithms
19:01:44 <syntaxglitch> Another upside to a separate kindcheck stage is that I might be able to do some inference, not just checking
19:02:09 <syntaxglitch> all the explicit kind parameters get pretty hideous writing something like ZipWith
19:03:33 <syntaxglitch> e.g.: instance Function (ZipWith :@> ka :@> kb :@> kc) ((ka :-> kb :-> kc) :-> List :@> ka :-> List :@> kb :-> List :@> kc)
19:03:38 * syntaxglitch dies a little inside
19:06:06 <edwardk1> you definitely need inference ;)
19:06:43 <syntaxglitch> Yeah, that's kind of what I was thinking :(
19:06:45 * syntaxglitch sighs
19:07:03 <syntaxglitch> Looks like it's time for another near-total reworking for this thing
19:08:28 <syntaxglitch> someone in here earlier suggested that the workaround for my problems is "cabal install agda"... starting to sound tempting
19:08:39 <monochrom> haha
19:08:51 <copumpkin> syntaxglitch: you should try it anyway
19:08:53 <monochrom> @quote monochrom discovered.haskell
19:08:53 <lambdabot> No quotes match. stty: unknown mode: doofus
19:09:11 <syntaxglitch> copumpkin, I should
19:09:23 <monochrom> @quote monochrom download
19:09:23 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
19:09:43 * syntaxglitch has too many complaints about Haskell to call it "sensible" at this point
19:09:52 <monochrom> hehe
19:10:19 <monochrom> in your case, you download ghc so you can cabal install agda
19:10:19 <syntaxglitch> stop conflating data and codata and get all these bottoms out of my types, then we'll talk about "sensible"
19:10:58 <copumpkin> well, most people don't care about the difference
19:11:09 <c_wraith> explain how you can get rid of bottom in divergent code?
19:11:13 <copumpkin> and the bottoms are kind of necessary if you want to be turing complete :P
19:11:22 <copumpkin> not that being TC is necessary
19:11:38 <syntaxglitch> copumpkin, most people use Java, what's your point ;P
19:11:54 <monochrom> most people don't write programs
19:12:01 <syntaxglitch> c_wraith, I fail to see the problem in that statement
19:12:10 <monochrom> most people just "click open"
19:12:13 <syntaxglitch> turing equivalence is overrated
19:12:15 <dolio> Have you actually programmed in a language that distinguishes codata, and doesn't have bottoms?
19:12:57 <c_wraith> no, I haven't.  so you throw turing out?
19:13:12 <monochrom> sql is the only bottomless language I have programmed in
19:13:23 <copumpkin> c_wraith: for most things you don't really need all that power
19:13:28 <monochrom> and vcr's, I suppose
19:13:37 <syntaxglitch> dolio, sadly no :( Still been too intimidated by such languages
19:14:01 <dolio> Well, it's not all beer and hookers.
19:14:19 <gwern> wonder how hard a total Haskell would be. I mean, in theory we can replace the prelude without too much trouble
19:14:27 <c_wraith> still, you can simulate divergence.  An algorithm that's guaranteed to terminate in 1000 years isn't really any better than one that terminates.
19:14:32 <c_wraith> err, that doesn't terminate
19:14:35 <syntaxglitch> dolio, I realize that, which is why I haven't jumped ship for such languages yet :\
19:14:44 <copumpkin> gwern: quite different from regular haskell, by necessity
19:15:04 <gwern> c_wraith: sure it is. what if it's parallelizable? quite a few entities have the computational resources for that
19:15:13 * c_wraith has started drinking.  should probably just close the window
19:15:45 <gwern> copumpkin: yeah but could we do it just by new preludes and modules? I never was very clear on where the data/codata distinction in those total languages had to be made
19:15:51 <syntaxglitch> c_wraith, but it doesn't give you an arbitrary type
19:15:56 <dolio> It'd be even worse if you just yanked it out of Haskell, because you don't have the ability to do fancy stuff, like doing induction over a termination proof of your otherwise invalid algorithm.
19:16:18 <copumpkin> gwern: only codata can be infinite
19:16:41 <Saizan> and you'd have to add a termination checker to ghc
19:17:10 <edwardk1> hah Primal is safe, i can't merge the two classes after all
19:17:11 <copumpkin> gwern: even something like concat would need work
19:17:19 <copumpkin> because you can't guarantee that it will be productive
19:17:31 <monochrom> Primal is so primal.
19:17:32 * syntaxglitch keeps noticing just how much code could be nicely expressed by productive corecursion
19:18:14 <gwern> copumpkin: presumably a total concat could be easily built out of strict/total primitives
19:18:17 <dolio> No more 1-line quicksort.
19:18:36 <dolio> No more 'fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'.
19:19:03 <copumpkin> gwern: well the issue is that the current type doesn't express it. You'd either need to concat a possibly infinite list of non-empty lists, or a finite list of possibly infinite lists
19:19:13 <copumpkin> gwern: in order to satisfy productivity
19:19:41 <copumpkin> otherwise, it has no way of knowing if you're doing concat ([1,2,3] : repeat [])
19:19:54 <wli> dolio: What will anyone do without them?
19:19:56 <edwardk1> gwern: you need machinery that haskell never had to evolve and you'd greatly miss all the stuff you'd lose
19:20:20 <copumpkin> I still think it could be interesting, but it would be quite a different language
19:20:25 <gwern> edwardk1: like people missed impurity?
19:20:28 <edwardk1> the end result would wind up being agda ;)
19:20:31 <gwern> maybe totality is the new hair shirt
19:20:36 <syntaxglitch> gwern, but Haskell was designed for that
19:20:48 <syntaxglitch> making Haskell total would be like bolting purity on to most other languages
19:20:54 <gwern> edwardk1: that could be; I know very little about agda
19:20:57 <edwardk1> so you might as well join the cult of utf-8 and start hanging with the #agda crowd ;)
19:21:11 <gwern> copumpkin: right but the point is that you would be doing it in ghc - saving yourself a huge amount of compiler labor
19:21:23 <copumpkin> yeah, everyone should try agda at least once
19:21:41 <gwern> if I could get a new language just by supplying a different base/Prelude, that'd be a lot better than writing a compiler :)
19:21:50 <edwardk1> gwern: sadly the machinery you need to compile something like agda is quite a bit different than the core that backs ghc.
19:22:04 <edwardk1> the phase distinction between runtime and compile time starts to blur when you muck around with dependent types
19:22:23 <gwern> you need dependent types for totality?
19:22:25 <gwern> (I don't remember that)
19:22:39 <syntaxglitch> you don't
19:22:55 <syntaxglitch> for certain definitions of "need"
19:22:58 <edwardk1> you don't, but you probably want them to write all the proofs you're going to need to convince the compiler of your totality ;)
19:23:22 <syntaxglitch> the simply-typed lambda calculus is total, but you REALLY don't want to try programming in it
19:23:31 <gwern> dolio: maybe totality is the new hair shirt
19:24:09 <monochrom> dolio shows that his irc session is total
19:24:15 <syntaxglitch> heh
19:24:29 <syntaxglitch> it certainly seems guaranteed to terminate
19:24:31 <edwardk1> it is a hair shirt, and it provides a number of benefits, but the costs thus far seem to me to be too high for day to day use. i'll let copumpkin and dolio blaze a trail for me ;)
19:24:44 <copumpkin> hah, not me
19:24:47 <copumpkin> I suck at it :P
19:24:54 <copumpkin> I just evangelize it a lot
19:25:03 <ddarius> monochrom: As opposed to productive.
19:25:06 * syntaxglitch installs agda, might as well give it a try
19:25:12 <edwardk1> ddarius: ouch
19:25:18 <syntaxglitch> ddarius, IRC is NEVER productive
19:25:19 <syntaxglitch> ;)
19:25:31 <copumpkin> syntaxglitch: at least it sort of looks like haskell
19:25:53 <dolio> Yeah. The quassel developers must not have proved its correctness.
19:26:05 <orlandu63> @src (++)
19:26:12 <orlandu63> where is lambabot? :(
19:26:23 <monochrom> heaven
19:26:29 <dolio> Gone again?
19:26:43 <monochrom> totally in heaven
19:27:09 <edwardk1> dolio: quick, try to talk some of the YNOT guys to prove the correctness of an irc client, in a year or two they should have one that can ping safely
19:27:18 <syntaxglitch> haha
19:27:20 <dolio> Heh.
19:27:21 <edwardk1> into proving
19:27:21 <monochrom> hehehe
19:27:34 <gwern> edwardk1: you shouldn't mock them. they suffer enough
19:27:50 <syntaxglitch> what's YNOT again? was that the "let's write programs in Coq!" thing?
19:27:54 * syntaxglitch can't recall
19:28:03 <ezyang> that sounds sorta like a quantum gate
19:28:04 <edwardk1> gwern: they're good guys. and at least one or two of them know where i live, so i can't rib them too hard ;)
19:28:05 <ezyang> like CNOT
19:28:12 <edwardk1> syntaxglitch: yes
19:28:38 <copumpkin> ezyang: did you ever get the hash tries working?
19:28:42 <edwardk1> its what came of the hoare type theory stuff that morrisett was interested in
19:28:46 <dolio> Not just programs. Imperative programs, no?
19:28:50 <syntaxglitch> nah, "Y NOT" is clearly the fixed point of the function not
19:28:59 <copumpkin> > fix not
19:29:05 <gwern> edwardk1: they're good guys. like don quixote was a good guy
19:29:33 <ezyang> copumpkin: They work, although I didn't get the awesome unsafe perform IO version working.
19:29:44 <copumpkin> ezyang: ah :) how's performance on them?
19:29:51 * syntaxglitch seems to recall that the lambda calculus was originally shown to be inconsistent by someone basically writing "fix not" in it
19:29:56 <ezyang> "not as good as IntMap" :^)
19:30:01 <copumpkin> aw
19:30:23 <gwern> how is fix not inconsistent?
19:30:31 <ezyang> but I want to go check with an IntMap implementation in Java.
19:31:13 <syntaxglitch> gwern, because it diverges by endlessly negating itself? fix not = not (fix not) = not (not (fix not)) ....
19:31:24 <edwardk1> dolio: yeah web front ends that talk to databases, etc.
19:31:40 <syntaxglitch> it's just the good old liar paradox again
19:31:41 <copumpkin> syntaxglitch: I think he meant that fix is inherently bad
19:31:46 <syntaxglitch> ah
19:31:53 <syntaxglitch> well, yes, fix is pretty much the root of all evil
19:32:01 <gwern> syntaxglitch: that sounds more like incomplete to me but what do I know
19:32:19 <edwardk1> dolio: what terrifies me is that the approach seems to require some serious mental horsepower for mediocre results over a long period of time with huge assumptions required.
19:32:44 <dolio> Well, that's imperative programming for you. :)
19:32:47 <dolio> It's so hard.
19:32:50 <edwardk1> > fix error
19:33:04 <Olathe> > 5
19:33:19 <Makoryu> :t fix error
19:33:24 <edwardk1> lambdabot appears to be taking a nap
19:33:26 <Olathe> lambdabot isn't here.
19:33:27 <Axman6> lambdabot's gone again
19:33:31 <Axman6> Cale!
19:33:35 <Makoryu> Let's all watch lambdabot sleep
19:33:46 <copumpkin> @get-cale
19:33:48 <Makoryu> Â¯\O_o/Â¯
19:33:49 <copumpkin> oh wait
19:33:53 <copumpkin> :)
19:33:58 <Makoryu> ï¼ãââ¿âï¼
19:34:03 <syntaxglitch> lambdabot has gone to the great fixed point in the sky
19:34:46 <monochrom> lambdabot wants to be free
19:34:54 * copumpkin ponders using hoopl for reverse engineering
19:35:32 <syntaxglitch> maybe lambdabot is dreaming about being a butterfly
19:38:05 <FunctorSalad_> our friendly bot is alarmingly unrespected :o
19:38:21 <FunctorSalad_> would you like a whole channel watching you sleep? :(
19:38:45 <daviddarais> telling you to compute (fix not) all day...
19:39:33 <monochrom> butterfly is so passe. these days real thinkers dream about being information
19:39:51 <FunctorSalad_> edwardk1: interesting answer even not having seen the question... ;)
19:40:11 <FunctorSalad_> ... not exactly 'answer', yes
19:41:44 <ddarius> gwern: fix not is a direct translation of Russel's paradox.
19:42:00 * ddarius is happy hoopl is on hackage now.
19:42:39 <copumpkin> amusing to find this in the public version of the paper: http://snapplr.com/2ghf
19:42:43 <FunctorSalad_> is it?
19:43:13 <FunctorSalad_> or was that <Yoda> fix not is a direct translation of it!
19:43:22 <FunctorSalad_> ;)
19:45:10 <FunctorSalad_> I thought thinking about russel dynamically is kinda inaccurate since logic is (usually) timeless and the conclusion is a contradiction, not cycling or anything. Of course you may apply the timeless view to programs... (... denotational semantics)
19:46:57 <FunctorSalad_> hmm but "sup_n not^n ( _|_ )" is trivially bottom because `not' is strict, no russel-like thing in sight apparently
19:49:08 <monochrom> yeah, untyped lambda calculus has models, what's inconsistent about it. instead, you need to pick a peculiar interpretation to get an inconsistency, which to me means the interpretation is flawed.
19:50:29 <FunctorSalad_> monochrom: what's the interpretation as a logic in which it's inconsistent?
19:51:22 <Cale> The standard one?
19:51:37 <FunctorSalad_> (to be fair, there are no models in Set, which is a bit more profoundly "impossible")
19:51:58 <dolio> The untyped lambda calculus doesn't have any types to correspond to propositions.
19:52:00 <Cale> Depends on what counts as a model of course
19:52:00 <FunctorSalad_> (if you are committed that lambdas must be functions...)
19:52:04 <Cale> yeah
19:52:07 * syntaxglitch wonders what nontrivial interpretation of the untyped lambda calculus is consistent
19:52:31 <FunctorSalad_> Cale: application in LC commuting with set-function application and so on...
19:53:01 <FunctorSalad_> then it's just the fact that no set contains its set of endofunctions injectively, iirc
19:53:34 <FunctorSalad_> dolio: a single one
19:54:29 <FunctorSalad_> * except the singleton set....
19:55:00 <syntaxglitch> the untyped lambda calculus represents a logic where all propositions have the truth value "does a dog have Buddha-nature?"
19:55:52 <FunctorSalad_> dolio: but yes, I can't make sense of it as a statement about curry-howard
19:56:52 <FunctorSalad_> syntaxglitch: I don't know about the logical interpretations, but I think you can have a model in a category of domains (complete partial orders or so) just fine
19:57:42 <edwardk1> @hpaste
19:57:46 <edwardk1> gah
19:57:51 <FunctorSalad_> (but maybe someone know better)
19:58:11 <syntaxglitch> FunctorSalad_, seems like all you'd be able to do is describe the structure of a lambda term
19:58:36 <syntaxglitch> which strikes me as fairly trivial, more change of representation than anything else
19:58:53 <syntaxglitch> but I haven't really looked at it deeply
19:59:20 <FunctorSalad_> syntaxglitch: hmm I don't find it trivial how to interpret untyped lambda terms as functions :)
19:59:22 <syntaxglitch> If I wanted untyped lambda calculus, I'd be using a Lisp instead of Haskell
19:59:33 <FunctorSalad_> (as monotonous functions, in the domain case)
20:00:29 <syntaxglitch> FunctorSalad_, dunno, I'm not sure what you have in mind and I'm not too well-versed in the subject
20:01:33 <dolio> Heh, monotonous.
20:01:37 <FunctorSalad_> (wait, I think my cardinality argument why there's no model in set may be nonsense, since nobody said all endofunctions can be reached as the semantics of a lambda-term... maybe you need the "every function would have a fixed point" argument after all)
20:01:54 <syntaxglitch> my impression is that mathematical treatments of lambda-calculi are heavily biased toward either simply-typed or something like the CoC
20:02:02 <ville> Looking at Gtk2Hs interface, it has builderGetObject that takes a cast function to determine the type it returns, I suppose, why didn't they just write builderGetButton, builderGetWindow and so forth?
20:02:23 <FunctorSalad_> syntaxglitch: the untyped case was done previously
20:02:29 <FunctorSalad_> from 1930 or so
20:02:52 <FunctorSalad_> I guess they pretty much finished that game
20:02:54 <syntaxglitch> yeah, which is why I'm guessing they ran out of stuff to do with it :P
20:03:21 <syntaxglitch> untyped lambda calculus is a lovely basis for a programming language but I suspect the mathematical structure is uninteresting
20:03:55 <FunctorSalad_> well, if you consider the finding-a-model-stuff not really mathematics ;)
20:05:06 <syntaxglitch> simply-typed is kinda dull as well but I guess it's useful as the minimal example of a typed lambda calculus?
20:05:46 <syntaxglitch> I'm not really sure
20:06:36 <FunctorSalad_> I think the exact problem setting is that the model should be an object in a CCC L such that eval . ([[f]],[[x]]) == [[ f x ]] and so on, with [[f]] and [[x]] global elements of L, f and x lambda terms
20:07:12 <FunctorSalad_> "eval" is the counit of the CCC adj
20:08:02 * syntaxglitch is still a bit shaky on category theory terminology
20:08:39 <FunctorSalad_> the CT version is slightly odd because objects have no elements in CT, so you use arrows of type 1 -> L instead of elements of L
20:09:15 <FunctorSalad_> (and then one noticed that arbitrary functions K -> L are kinda like elements of L too, so they're called generalized elements of L ;))
20:09:21 <FunctorSalad_> *morphisms
20:09:23 <ddarius> syntaxglitch: http://www.cs.ru.nl/B.Jacobs/PAPERS/Durham.ps
20:09:39 <syntaxglitch> in the untyped LC, there ought to be only one object and a bunch of endomorphisms, right?
20:09:56 <FunctorSalad_> (1 -> L is pretty boring, in, say, the cat of monoids)
20:11:06 * copumpkin lies down to read ddarius's paper
20:11:19 <Pseudonym> You'll need to lie down, yeah.
20:11:24 <syntaxglitch> ddarius, hunh, that looks interesting
20:14:27 <syntaxglitch> Oooh, that is fun
20:14:59 * syntaxglitch files the paper to read when it's not quite so late
20:15:44 <ddarius> Why does three have to be not a multiple of two?
20:16:09 <FunctorSalad_> OT: why can't I search in that ps? not drm presumably, using okular
20:16:33 <FunctorSalad_> ("Find" is just disabled)
20:16:54 <dolio> Can you usually? I'm not sure I ever recall being able to search a ps with okular.
20:17:05 <copumpkin> is there any text in it?
20:17:09 <FunctorSalad_> dolio: that could be it
20:17:22 <danharaj> It's not text.
20:17:52 <FunctorSalad_> copumpkin: I do see some plaintext in there
20:18:01 <copumpkin> hmm
20:18:27 <FunctorSalad_> riddled with parentheses and other ps syntax, but still
20:19:05 <dolio> I think it's just disabled for ps. Even when a pdf contains no searchable text it doesn't disable the search widget.
20:20:03 <Cale> I seem to recall, on occasion, being able to search postscript files using Evince.
20:23:01 <p_l> FunctorSalad_: probably it simply doesn't try to search
20:23:20 <dolio> Huh, Barr and Wells introduce equivalences of categories before natural transformations.
20:23:35 <FunctorSalad_> p_l, dolio : yes .ps is very likely the commonality of those I can't search in;)
20:23:56 <ddarius> dolio: Full and faithful and essentially surjective on objects.
20:23:57 <ddarius> ?
20:24:45 <dolio> Well, they give that theorem.
20:25:48 <dolio> I noticed because their definition of an equivalence involves "a family u_C : C -> G(F(C)) of isomorphisms ..."
20:26:17 <FunctorSalad_> is isos without coherence not enough?
20:26:59 <dolio> They give a coherence condition, too.
20:27:31 <FunctorSalad_> but if one stopped at what you wrote it's not enough? usually it isn't with categories...
20:27:49 <FunctorSalad_> but then the "full,faithful and e. surj." condition looks surprisingly "loose" too
20:28:07 <FunctorSalad_> (full and faithful being merely set properties...)
20:28:25 <copumpkin> http://www.workerwrapper.com/ I find it weird to have a domain for this
20:28:27 <FunctorSalad_> and e. surj. not saying anything about composition either
20:28:35 <aavogt> is a \ in set notation subtraction?
20:28:42 <FunctorSalad_> yes
20:29:06 <monochrom> ps (as a language in theory, and most files in practice) does not arrange text data to be searchable, in fact does not keep text data as text data at all. text is mingled. the language says "put T here, now put r there..." completely obfuscates content. this is a form language.
20:29:35 <FunctorSalad_> monochrom: but it looks mechanically undo-able at first sight (I know no ps)
20:29:57 <edwardk1> you know you're doing bac things with the type system when you need to dig out TypeEq
20:30:00 <edwardk1> er bad
20:30:12 <ddarius> Fam(C) = (D,C) where D is the discrete category functor (and C is a category)?
20:30:49 <ddarius> That's what you get for using a Turing complete language to represent text.
20:31:06 <monochrom> Yes in principle by a royal work on reverse-engineering the program (every ps file is a program) and making assumptions on how the ps file was generated (clearly breaks with a different generator).
20:31:18 <FunctorSalad_> ddarius: a family in the external settheory would be my reading
20:31:50 <monochrom> it looks phd-undoable but who wants a phd in reversing ps files.
20:31:51 <FunctorSalad_> unless otherwise specified.
20:32:02 <FunctorSalad_> monochrom: :)
20:32:20 <FunctorSalad_> hopefully nobody here is doing just that
20:32:48 <monochrom> or rather who wants to fund a phd on reversing ps files
20:33:12 <monochrom> I mean there are people doing phds on dumber things but they are funded.
20:33:42 <FunctorSalad_> monochrom: err wait, it has been done. ps2pdf
20:33:48 <FunctorSalad_> I can search in the resulting pdf
20:33:58 <monochrom> that is good
20:34:34 <monochrom> I guess I will do that too
20:34:49 <ezyang> "a general algebra for reversing postscript files"
20:35:10 <edwardk1> ezyang: =)
20:35:16 <ddarius> You just capture the text writing operations (and hope they are in order)
20:35:27 <FunctorSalad_> *files which have the quasi-PS property up to ....
20:36:10 <monochrom> catageomorphism
20:36:22 <Cale> "The Braided Monoidal 2-category of PostScript Text Extraction Operators"
20:36:23 <ezyang> More seriously, I think it would be pretty neat to take well known mathematical results, find an instance in the real world that satisfies the laws the result was built on, and get something nifty
20:37:39 <Cale> ezyang: You have just described... SCIENCE
20:38:01 <monochrom> It can always be done. Proof by walking into a bar making bets with people.
20:38:02 <ezyang> I must be a scientist :^)
20:38:33 <monochrom> "I bet you $10 you can't find integer solutions to x^10+y^10=z^10 apart from..."
20:39:25 <monochrom> "I bet you a round of beer for all that map f . reverse = reverse . map f"
20:39:27 <Cale> monochrom: "Keep drinking, I'll find you a solution by the end of the night."
20:40:01 <copumpkin> @botsnack
20:40:11 <ddarius> copumpkin: The bot isn't even here.
20:40:25 * copumpkin was trying to point that out to Cale :P
20:40:42 <ddarius> copumpkin: Direct statements work well.
20:41:15 <monochrom> indirect hints are more socratic
20:41:37 <FunctorSalad_> I think it would be pretty neat to take a hammer, find an instance in the real world that satisfies the assumption of resembling a nail in some respect, and ...
20:41:51 <FunctorSalad_> just being silly, no deep statement about math and science
20:42:23 <monochrom> and use the other end of the hammer to pull out the nail-wannabe.
20:42:43 <dons> ?yow
20:42:49 <dons> no bot!?!?
20:42:52 <copumpkin> omg it's dons
20:42:54 <ddarius> The hammer is called symmetry groups and there are no nails but we just keep pounding away.
20:42:56 <dons> hit the panic switch
20:42:57 <Cale> copumpkin: Oh, it's a good idea to say my name ;)
20:43:21 <Cale> hmm, all my screens is gown
20:43:58 <monochrom> lambdabot is night gown
20:44:06 <monochrom> @vixen you are night gown
20:44:11 <lambdabot> Crazy little wanker!
20:44:13 <copumpkin> @free reverse :: [a] -> [a]
20:44:17 <lambdabot> $map f . reverse = reverse . $map f
20:44:18 <dons> where is it gown?
20:44:18 <monochrom> teeheehee
20:44:24 <dons> crikey
20:44:46 <copumpkin> maybe we should kick lambdabot for being so abusive
20:44:51 <copumpkin> especially if you ask for @src
20:44:52 <dons> @slap copumpkin
20:44:57 <monochrom> I want her to say "functional programmers in night gowns are so hot!"
20:44:59 <copumpkin> it's against the spirit of the channel!!
20:44:59 * lambdabot will count to five...
20:45:03 <Cale> Yay, epoxy resin + broken headphones = fixed headphones
20:45:07 <dons> @vixen
20:45:13 <dons> all the good plugins are gown.
20:45:13 <lambdabot> Most guys don't understand me, but we really seem to connect.
20:45:16 <monochrom> epoxy is messy
20:45:34 <Cale> Yeah, it is, but it works :)
20:45:43 <dons> Cale: you need the magic play dough for fixing stuff.
20:46:31 <monochrom> Highschool algebra: variables stand for numbers. Abstract algebra: variables stand for nothing.
20:46:54 <dons> sugru, Cale.
20:47:32 <dons> "hack things better". shapr would like that.
20:47:37 <dons> @get-shapr
20:47:37 <lambdabot> shapr!!
20:47:51 <monochrom> > let epoxy + headphone = fix headphone in "OK!"
20:47:54 <lambdabot>   "OK!"
20:48:02 <dons> hehe
20:48:09 * monochrom is relieved the typechecking goes through
20:49:55 <monochrom> @arr (a->r)->r
20:49:55 <lambdabot> Smartly me lass
20:50:09 <Cale> dons: ah, that does look like it would be useful stuff
20:50:29 <monochrom> magic play dough is so untyped
20:50:38 <dons> its a glue language
20:50:51 <monochrom> OK!
20:51:23 <dons> http://sugru.com/ for those not following. a funky material for hacking things to work better with a slogan shapr would approve of.
20:52:15 <copumpkin> I hate those animated photo frames on websites
20:52:29 <FunctorSalad_> tangible technological progress not related to computers, in my lifetime? ;)
20:52:41 <FunctorSalad_> or maybe I just ignore all but computers
20:53:18 <dons> happy metrology day!
20:53:21 <FunctorSalad_> copumpkin: animated what? ;)
20:53:34 <monochrom> glue languages are goo languages
20:54:03 <FunctorSalad_> copumpkin: about:config -> image.animation_mode=once
20:54:19 <FunctorSalad_> that deals with gifs at least
20:54:24 <Cale> Though, I think epoxy is still a better fit for this job. Sugru seems flexible, and I needed this join to be as solid as I could get it.
20:54:26 <FunctorSalad_> you probably have something to thwart flash already
20:54:33 <copumpkin> FunctorSalad_: I mean the javascript photo frames that pop up and resize animatedly
20:54:45 <copumpkin> they really annoy me
20:57:59 <monochrom> hahaha "FormFormForm Limited"
20:58:03 <FunctorSalad_> copumpkin: oh my...
20:58:13 <copumpkin> FunctorSalad_: what? :)
20:58:28 <FunctorSalad_> copumpkin: didn't realize how bad things have become without everything disabled
20:58:36 <ddarius> dons: That looks pretty handy actually.
20:58:40 <FunctorSalad_> moving frames?
20:58:47 <monochrom> sugru is flexible at the beginning. after hours it hardens.
20:59:20 <FunctorSalad_> in FF you can forbid certain window operations specifically for JS
21:00:31 <dons> ddarius: kinda magic . material SCIENCE!
21:01:03 <ddarius> @google goo language
21:01:04 <lambdabot> http://en.wikipedia.org/wiki/Goo_(programming_language)
21:01:04 <lambdabot> Title: Goo (programming language) - Wikipedia, the free encyclopedia
21:01:05 <ddarius> formonochrom
21:01:27 <monochrom> oh, I guess it doesn't harden
21:03:53 <FunctorSalad_> Cale: is that stuff *safe* on skin anyway?
21:03:59 <FunctorSalad_> I don't know, but I'd check ;)
21:05:07 <dons> sugru, yeah. not edible though.
21:05:21 <odie5533> If I can't eat it, I won't buy it.
21:05:23 <dons> epoxy, not sure...
21:05:29 <copumpkin> I'm sure you could eat it if you wanted to
21:05:34 <copumpkin> it might harden inside you though
21:05:38 <copumpkin> or on the way out
21:05:40 <dons> non toxic, anyway
21:05:54 <dons>  /= edible :)
21:06:15 <copumpkin> dons: by the way, I was wondering how often you compute the #haskell channel stats
21:06:31 <dons> hmm.
21:06:35 <dons> which ones?
21:06:39 <FunctorSalad_> maybe I'm mixing something up, I vaguely remember that epoxide groups are a Bad Idea at least for molecules to be ingested
21:06:42 <copumpkin> hmm, I think they're on your unsw site
21:06:49 <copumpkin> I found them a few days ago but forgot the url now
21:06:50 <dons> oh, it used to be a nightly cron job
21:06:55 <dons> but probably its not running anymore
21:07:03 <copumpkin> do you have other ones too?
21:07:05 <FunctorSalad_> maybe that it's a polymer makes all the difference here though
21:07:11 <dons> well, i update the wiki page occasionally
21:10:40 <copumpkin> aha
21:11:18 <copumpkin> omg there was an hpaste bot
21:11:55 <dons> there was. useful too
21:11:58 <dons> helped us help newbies
21:12:02 <dons> why don't we have it anymore??
21:12:11 <copumpkin> maybe hpaste2 didn't support it?
21:12:43 <FunctorSalad_> one that posts if there's a new hpaste post?
21:14:08 <dons> yeah, hpaste2 broke the irc backend (well, it was a rewrite)
21:14:33 <copumpkin> also, since mmorrow disappeared we couldn't be able to update it if a new IRC bot were written
21:14:42 <copumpkin> unless we moved to a different server
21:15:31 <dons> mm
21:16:11 <copumpkin> preflex: Syzygy
21:16:15 <copumpkin> preflex: seen Syzygy
21:16:15 <preflex>  Syzygy was last seen on #haskell 165 days, 12 hours, 51 minutes and 2 seconds ago, saying: in that case, what's the syntax used to declare a new type constructor for Just?
21:19:51 <copumpkin> hmm, weird
21:20:13 * ddarius might have found just the paper he needed.
21:20:28 <ddarius> preflex: seen DrSyzygy
21:20:28 <preflex>  DrSyzygy was last seen on #haskell 4 days, 5 minutes and 53 seconds ago, saying: ;-)
21:20:52 <copumpkin> oh
21:20:59 <copumpkin> I guess he acquired the Dr recently
21:21:11 <copumpkin> oh he's even here
21:21:19 <pikhq> XD
21:21:45 <pikhq> preflex: seen mmorow
21:21:45 <preflex>  Sorry, I haven't seen mmorow
21:21:57 <pikhq> preflex: seen mmorrow
21:21:57 <preflex>  mmorrow was last seen on #ghc 123 days, 1 hour, 24 minutes and 12 seconds ago, saying: * mmorrow is rtfm'ing
21:21:57 <pikhq> XD
21:22:09 <pikhq> Could've *sworn* I'd seem him more recently.
21:22:31 <copumpkin> pikhq: his spirit lives on
21:22:31 <pikhq> Like, "a few days ago" recently. How weird.
21:23:28 <copumpkin> pikhq: you're imagining things! seek help immediately!
21:39:42 <copumpkin> sure is quiet in here
21:39:47 * copumpkin turns on the music and starts dancing
21:51:06 <alexyk> so I'm following RWH, and trying to type the ListADT.hs example into ghci.  Parse error.  Put same line in a file, :l it, works.  Do I really have to type stuff into files and load them when working in repl??  In Clojure I never leave the repl and would prefer to do it here too.  Possible?
21:51:23 <alexyk> copumpkin: hey! ^^?
21:51:27 <copumpkin> hey alexyk :)
21:51:37 <copumpkin> you can't put type declarations into ghci!
21:51:54 <copumpkin> it only evaluates expressions
21:52:05 <alexyk> copumpkin: screws up whole development?  or can I isolate them and load them only?
21:52:11 <pastorn> copumpkin: acutally that's not entirely true...
21:52:21 <copumpkin> well, it also executes IO actions :)
21:52:23 <pastorn> copumpkin: though i don't think anyone would want to...
21:52:35 <copumpkin> alexyk: you can put the types into a file and type the rest yourself
21:52:41 <FunctorSalad_> I've pondered that adding declarations would be just a oneliner, wouldn't it?
21:52:49 <copumpkin> but it's generally unpleasant to let your functions though
21:52:51 <FunctorSalad_> write the input to a tempfile, wrap in module header
21:52:58 <FunctorSalad_> emit :load command
21:53:03 <FunctorSalad_> could be done in a :def
21:53:08 <copumpkin> load gets rid of previous bindings though
21:53:13 <FunctorSalad_> oh
21:53:14 <alexyk> so consider: any other repl, ruby, clojure, scala, I just fully develop by typing into repl and cut and paste into files, if I want to.  It'd screw my whole workflow if I have to randomly load some.
21:53:30 <copumpkin> alexyk: it does say read "eval" print loop ;)
21:53:36 <copumpkin> where eval isn't decl :P
21:53:39 <alexyk> I also totally hate let blah prefix, I love it in ocaml but not as a separate case
21:53:44 <pastorn> alexyk: in haskell you almost only write in your source file
21:53:52 <pastorn> at least that's how i do it
21:53:58 <copumpkin> yeah, same here
21:54:00 <copumpkin> I just play in ghci
21:54:01 <pastorn> i use ghci for trying out stuff
21:54:05 <alexyk> pastorn: see, this is so Fortran.  Let's punch cards too.
21:54:07 <pastorn> making sure that i got it right etc.
21:54:10 <FunctorSalad_> alexyk: you can have "load + switch to ghci window" on a single keypress in most editors
21:54:36 <alexyk> FunctorSalad_: meaning the same ghci right
21:54:44 <pastorn> alexyk: are you using ED THE STANDARD EDITOR?
21:54:58 <alexyk> pastorn: used it on iphone a bit :)
21:54:59 <FunctorSalad_> alexyk: as copumpkin says, it will reset any bindings in ghci though
21:55:01 <copumpkin> lol
21:55:16 <pastorn> shit
21:55:19 <pastorn> on iPhone?
21:55:25 <pastorn> that seems rather insane :D
21:55:43 <alexyk> pastorn: yeah, on tje jailbroken one a while ago, vi didn't work but ed did :)
21:55:52 <pastorn> haha
21:55:56 <pastorn> cool
21:56:06 <copumpkin> that was a while ago :P
21:56:15 <copumpkin> the bad "bsd subsystem" has been gone for a couple of years at least
21:56:17 <FunctorSalad_> alexyk: (you could setup your editor to eval the current line in ghci and paste the result into the buffer, for even more repl'ness)
21:56:52 <pastorn> alexyk: when i code i use gvim + ghci + alt-tab,:r
21:57:20 <pastorn> more than enough... (you can get ghci running inside gvim if you dick around)
21:57:22 <alexyk> FunctorSalad_: yeah, with clojure I literally write long defn's wrapped many times over, yet one liners, and it all works, so I just save it from my rlwrap history.  I loath to edit files now! :)
21:57:30 <alexyk> files are for saving repl
21:57:37 <alexyk> -tested things which work
21:57:48 <pastorn> haha
21:57:48 <alexyk> so I want that workflow with any repl
21:57:54 <aavogt> you can think about how code executes
21:57:56 <FunctorSalad_> alexyk: I'm often tempted to do it in the repl too, but sometimes it's annoying to extract all the lines that were correct manually
21:58:03 <FunctorSalad_> (to preserve them)
21:58:35 <alexyk> FunctorSalad_: see, that's why clojure is simpler as it all fits one line and then you arrow up and arrow left/right to edit
21:58:52 <alexyk> (((...)))
21:59:04 <FunctorSalad_> alexyk: a scratch buffer with a single-key "load and execute" seems almost as convenient though
21:59:17 <alexyk> any indented language sucks at arrow-up... buffer is a must now :(
21:59:33 <pastorn> alexyk: or you just use an editor :D
21:59:46 <FunctorSalad_> alexyk: haskell has { ; } as an alternative to layout, but you still can't have decls anywhere but toplevel
22:00:13 <alexyk> so ghci isn't toplevel enough?
22:00:26 <copumpkin> ghci is more or less like a giant do block that shows results
22:00:43 <copumpkin> and more type defaulting
22:00:53 <alexyk> ah... hmm.  so all bindings are done and it's just a big IO action?
22:01:04 <pastorn> sort of
22:01:13 <pastorn> but you get to declare functions in ghci
22:01:21 <pastorn> so that's nice :)
22:01:32 <alexyk> ok...
22:02:02 <alexyk> time to whip that Emacs out then
22:02:19 * copumpkin grins
22:02:27 <pastorn> alexyk: yeah, apparently the haskell plugin thing works really great
22:02:34 <pastorn> but you know, real men use VI
22:02:40 <pastorn> VI VI VI - editor of the beast
22:02:43 <FunctorSalad_> alexyk: why would you *want* type decls in a oneliner though?
22:03:11 <FunctorSalad_> (you can do anything in a single line in haskell too, except declare types, classes or class instances, or fixity of an operator ;))
22:03:37 <FunctorSalad_> to be as concise as possible you'd reuse general-purpose types like tuples anyway, not make new ADTs
22:03:47 <alexyk> FunctorSalad_: um, they don't teach us that in Clojure :)... iirc, in ocaml I still could do it all in repl, unless I forgot
22:04:22 <FunctorSalad_> alexyk: local functions are simply made with 'let'
22:04:33 <FunctorSalad_> (the one you like, not the do-block one ;))
22:04:39 <pastorn> how does F# work? do you get to declare types in the REPL thingy?
22:04:45 <alexyk> FunctorSalad_: yeah, for now I need to literally translate clojure's map and vector into haskell's
22:05:04 <Makoryu> > let 5 f = f 7 in "Hmmm..."
22:05:05 <lambdabot>   <no location info>: Parse error in pattern
22:05:51 <Makoryu> Right, lambdabot has no Num instance for (foo -> bar)
22:06:07 <alexyk> pastorn: iirc, you just declare things in ocaml/f# repl as usual
22:06:18 <FunctorSalad_> alexyk: not aware of what exactly these mean in closure
22:06:24 <FunctorSalad_> (don't know clojure at all)
22:06:46 <alexyk> same thing everywhere, hash/array, dictionary/vector, two things to do all work
22:07:35 <FunctorSalad_> ah, that kind of map is Data.Map in haskell
22:07:38 <alexyk> I actually write clojure data to tokyo cabinet with google protobuffers, and haskell turns out to have both bindings.  So time for you guys to show how fast you get.
22:07:45 <FunctorSalad_> (but it's a search tree, not a hash)
22:07:45 <pastorn> alexyk: i think the clojure vector type might be a bit difficult to translate
22:07:58 <alexyk> pastorn: I just use it as a list.  list and map
22:08:10 <FunctorSalad_> you can't take a hash of a value of arbitrary (unknown) type in haskell
22:08:13 <BMeph> alexyk: Well, in Haskell, we have two things, lists and arrays...and maps. Okay, so we have three things, lists, and arrays and maps - and sequences. So we have four things... ;)
22:08:41 <alexyk> FunctorSalad_: right, in clojure it's a map too, I'm not relying on hashing
22:08:46 <FunctorSalad_> (we mustn't reveal anything that depends on memory addresses, if that's the default hash you'd use)
22:08:53 <BMeph> ...lists, arrays, maps and sequences. Plus tuples. So we have five things... :D
22:09:09 <alexyk> BMeph: well it's like ocaml :)
22:09:54 <alexyk> the only thing I need to do is to extend the protobuffers with clojure extensions which store maps and sets in them
22:10:32 <alexyk> the package on hackage seems incomplete, talks of an examples/ subdir but missing it.  protocol-buffers
22:10:40 <FunctorSalad_> BMeph: a zoo of arrays, and tries too ;)
22:10:57 <BMeph> alexyk: Oh, yeah, thanks for reminding me - lists, arrays, sequences, maps, tuples and sets. Along with references... ;)
22:11:04 <Axman6> is there a way to find out how much memory a certain Char takes up? (is it the same for all Chars?)
22:11:25 <pastorn> Axman6: :i Char ?
22:11:34 <alexyk> so I don't buy broken toplevel excuses, ocaml's toplevel kinda works for all things.  I wonder exactly why are the differences
22:11:42 <Axman6> data Char = GHC.Types.C# GHC.Prim.Char# 	-- Defined in GHC.Types
22:11:44 <aavogt> @hackage vacuum
22:11:45 <lambdabot> http://hackage.haskell.org/package/vacuum
22:11:47 <Axman6> doesn't tell you much
22:11:53 <pastorn> well
22:11:56 <BMeph> alexyk: ...and tries, too! Well, I think I should just stick to "Nobody expects the Haskell Inquisition!" ;)
22:12:11 <pastorn> it's probably thunk + Word8
22:12:21 <pastorn> + another Word8 if it's > 127
22:12:31 <FunctorSalad_> alexyk: hmm I think nobody particularly defended the ghci toplevel
22:12:45 <FunctorSalad_> alexyk: I think it's just nobody cared enough to define types in ghci
22:12:58 <FunctorSalad_> since you only do your own types as a longer-term foundation for something
22:13:13 <dolio> I don't think GHC does any fancy encoding.
22:13:31 <FunctorSalad_> Axman6: sizeof ?
22:13:39 <FunctorSalad_> in Foreign or so
22:13:39 <BMeph> pastorn: ...and a third Word8 if it's over 65335? ;)
22:13:40 <aavogt> it's also a more awkward thing to do in haskell, since correctly evaluating haskell means you get to look at things defined after you write the function
22:13:49 <Axman6> pastorn: Foreign.Storable seems to say its size is the size of and Int32 :\
22:14:05 <FunctorSalad_> Axman6: nvm, it's just the size of the marshalled data
22:14:10 <pastorn> that just seems plain wrong
22:14:10 <FunctorSalad_> keep forgetting that
22:14:20 <Axman6> yeah
22:14:39 <Axman6> i'm writing some compression stuff, and i'm interested to see what the actual compression ratio is
22:14:45 <pastorn> Axman6: try making a big file, load it (strictly) then check the memory print
22:14:59 <pastorn> caveman debugging deluxe :)
22:15:22 <BMeph> I'd doubt that Chars vary in size; they probably all sit in Int-sized spaces, even if they only use six or seven of it. But then, eh, what do I know? :)
22:15:22 <Axman6> well, loading a 14MB file of Chars produces ~400MB of memory usage
22:15:30 <pastorn> haha
22:15:38 * Axman6 needs to use ByteStrings
22:15:52 <pastorn> you're not?
22:15:58 <Axman6> in fact, this whole program would probably be a lot nicer using bytestrings
22:15:59 <Makoryu> alexyk: Haskell encourages a large number of functions with brief definitions, FWIW (we've got a very aggressive optimizer that inlines stuff all over the place) and this doesn't tend to play well with defining everything in the REPL once you've got more than a handful of stuff
22:16:02 <pastorn> Axman6: you're just naughty
22:16:02 <copumpkin> Axman6: or Text
22:16:08 <FunctorSalad_> Axman6: uh, allocate N chars per second, measure slope of the graph with a ruler
22:16:09 <Axman6> pastorn:  not yet, for ease of implementation
22:16:11 <FunctorSalad_> j/k
22:16:16 <FunctorSalad_> (memory use graph)
22:16:45 <alexyk> Makoryu: don't see how one precludes another.  Clojure's repl AOTs and the speed is exactly the same in repl as standalone.
22:16:49 <pastorn> copumpkin: what's Text?
22:17:03 <copumpkin> pastorn: ByteString for nice unicode codepoints :)
22:17:06 <BMeph> Yeah, doesn't TExt do all sorts of sexy variable-space for different chars stuff?
22:17:11 <BMeph> *Text
22:17:17 <copumpkin> it's UTF16 behind the scenes
22:17:23 <FunctorSalad_> BMeph: I much suspect it's 32 bit too; there are 110k, which is more than 16 bit, and they probably didn't bother with packing those 15 or 14 bits
22:17:28 <copumpkin> but obviously behaves like real Chars
22:17:33 <FunctorSalad_> (remaining to fill up 32)
22:17:38 <Axman6> also, for anyone who was helping me last night find a better way to store the distribution of characters in a string, using a STUArray solved all my space and speed problems
22:17:48 <Axman6> Pure mutability saves the world again!
22:17:52 <FunctorSalad_> err and every char is in a box of its own anyway, isn't it
22:17:59 <Axman6> yeah
22:18:00 <copumpkin> Axman6: you accounting for all unicode chars?
22:18:10 <Axman6> well, i'd like to
22:18:13 <copumpkin> about 5 megabytes of array
22:18:14 <copumpkin> I think
22:18:21 <copumpkin> assuming 32-bit counters
22:18:25 <copumpkin> > 4 * ord maxBound
22:18:26 <lambdabot>   4456444
22:18:27 <Axman6> maybe i should just get the file size, multiply by 8, and get the number of bits from that
22:18:27 <Makoryu> alexyk: The other side of it is that all the names defined in the same scope (for example, all the top-level functions in the same module) can see each other, and more importantly, have effects on each other's types
22:18:36 <FunctorSalad_> copumpkin: Text is UTF16?
22:18:46 <copumpkin> FunctorSalad_: yeah, but you have no way of observing that
22:18:54 <copumpkin> it behaves like a Char container
22:18:55 <Axman6> copumpkin: my STUArray has indicies (minBound, maximum str)
22:19:04 <FunctorSalad_> still curious why it was chosen..
22:19:10 <Makoryu> alexyk: So, redefining one function can propagate a redefinition through an entire file's worth of code
22:19:13 <alexyk> Makoryu: ok, scope is a valid excuse :)
22:19:19 <alexyk> scope ate my repl :)
22:19:23 <copumpkin> FunctorSalad_: a good balance between UTF8's massively variable lengths and the huge space waste of UCS4 I guess
22:19:52 <FunctorSalad_> copumpkin: but still a 100% waste over utf8 for ascii, obviously...
22:20:13 <copumpkin> FunctorSalad_: yeah, but I don't really care
22:20:14 <FunctorSalad_> maybe the author wasn't english ;)
22:20:17 <copumpkin> it's bos
22:20:19 <FunctorSalad_> ah
22:20:27 <copumpkin> preflex: seen bos
22:20:27 <preflex>  bos was last seen on #haskell 3 days, 7 hours, 29 minutes and 38 seconds ago, saying: ivanm: i've been too busy to look - will soon
22:21:26 <FunctorSalad_> copumpkin: I don't care about running out of memory for texts either... but what about speed?
22:21:37 <FunctorSalad_> (scarce cache)
22:21:43 <copumpkin> FunctorSalad_: trade-off
22:21:47 <copumpkin> cultural imperialism ftl
22:21:49 <FunctorSalad_> oh well I don't really know what I'm talking about exactly
22:21:49 <copumpkin> ;)
22:21:58 <FunctorSalad_> (how much of a diff it makes)
22:22:07 <alexyk> FunctorSalad_: I like your lispy syntax :)
22:22:14 <FunctorSalad_> :o
22:22:15 <copumpkin> Text should be parametrized by a type representing the main script in use
22:22:22 <copumpkin> so it can pick the most efficient representation
22:22:50 <BMeph> copumpkin: Efficient for space, time, or... ;)
22:22:51 <Axman6> s/Text should be/A Text type, possibly in the Text package
22:22:52 <Axman6> >_>
22:22:59 * alexyk observes leopard update pull a new java for mac
22:23:36 <Axman6> alexyk: about time that came out, i think it had some fairly old, critical exploitable bugs
22:23:36 <ddarius> BMeph: Nothing keeps you from doing more than one.
22:24:10 <alexyk> Axman6: yeah, Apple takes it sweet time
22:24:14 <Makoryu> <alexyk> (like I (your-syntax 'lispy)) ; FTFY
22:24:38 <alexyk> Makoryu: :)
22:24:50 <copumpkin> alexyk: you should try liskell! :)
22:24:51 <BMeph> ddarius: Just saying, how do you decide which one, with what weights (if you're going that far), and how does it get decided?
22:25:06 <Axman6> types!
22:25:08 <alexyk> copumpkin: I saw it, but in fact I'm OK with ocaml's syntax :)
22:25:16 <alexyk> wait, you guys call it haskell syntax
22:25:38 <Makoryu> alexyk: Haskell's syntax is fairly ML-ish, but it's not quite ML.
22:25:56 <Axman6> yeah, it's prettier
22:25:58 <Axman6> >_>
22:26:06 <Axman6> @@ = ++? wtf is that!
22:26:06 <lambdabot> Plugin `compose' failed with: Unknown command: ""
22:26:09 <Makoryu> The type syntax in particular has some highly visible differences
22:26:12 <alexyk> Makoryu: what's up with module imports with commas prefixing?  that's plain untypographical
22:26:30 <Makoryu> alexyk: Um, sorry?
22:26:33 <Axman6> alexyk: huh?
22:26:41 * BMeph has never been tempted to declare an a' List * b' List...
22:26:42 <alexyk> or exports
22:26:46 <Axman6> ?
22:26:50 <alexyk> comma starting lines
22:26:53 <alexyk> , blah
22:27:00 <FunctorSalad_> I guess it's easier to develop another x2 speedup in the involved technologies than agree on something to take ascii's place as the privileged encoding, BMeph ;)
22:27:02 <Makoryu> alexyk: Oh, the comma-first style
22:27:04 <Axman6> that's not sybntax, its style
22:27:08 <Axman6> -b
22:27:21 <Axman6> not everyone does it
22:27:28 <alexyk> yeah, it's not pretty
22:27:40 <Axman6> makes things line up nicely though
22:27:51 <Makoryu> alexyk: I dunno why it's so popular in the Republic of Haskell but nowhere else
22:28:07 <abens> C++ too
22:28:16 <blackdog> Makoryu: i've seen it in javascript too
22:28:19 <dons> comma prefixing is our greatest gift to the world.
22:28:24 <FunctorSalad_> ^^
22:28:25 <Axman6> alexyk: anyway, it's not a haskell thing
22:28:31 <alexyk> um ok
22:28:34 <Makoryu> blackdog: I've heard people use it in JS, too, yeah. Never seen it though.
22:28:36 <dons> wait. no. literate comma prefixing
22:28:48 <dons> in tex style lhs
22:28:53 <FunctorSalad_> and semicolon
22:28:55 <FunctorSalad_> !
22:28:56 <alexyk> dons: hi! nice LLVM writeup I just saw on your blog.
22:29:00 <BMeph> FunctorSalad_: I like it - keep the bar nice and low, then awe your friends as you nudge it up another cent! =8*O
22:29:04 <dons> alexyk: cheers.
22:29:07 <alexyk> So is Haskell ready for numerics big time?
22:29:19 <dons> i think we're most of the way there, yeah.
22:29:20 <copumpkin> alexyk: massive time
22:29:21 <Axman6> dons: coming to AusHac2010? :P
22:29:26 <dons> crikey. when?
22:29:30 <pastorn> hahaha
22:29:36 <copumpkin> isn't hac phi todayish?
22:29:39 <dons> yup
22:29:39 <copumpkin> or tomorrowish
22:29:41 <FunctorSalad_> BMeph: the bar for? not following
22:29:45 <copumpkin> I wish I could go
22:29:46 <copumpkin> dammit
22:29:59 <FunctorSalad_> cultural equal-treatment?
22:29:59 <alexyk> copumpkin: so put down that python will you :)
22:30:10 <copumpkin> alexyk: hah, I have :P
22:30:34 <copumpkin> alexyk: although possibly in a more hardcore manner than you might expect
22:30:42 <Axman6> dons: 16th to the 18th of July
22:30:45 <BMeph> FunctorSalad_: As in, "easier to develop another x2 speedup in the involved technologies" and such. This way, you can do it again later with an easy tweak. ;)
22:30:58 <alexyk> copumpkin: hmm...  you fed it to the lions or something?
22:31:07 <blackdog> dons: do it, man. gotta be there for the inauguration.
22:31:09 <copumpkin> alexyk: I'm 99% of the way to quitting the program :P
22:31:20 <FunctorSalad_> BMeph: by having an encoding that's 50% wasteful for no good reason? good idea :D
22:31:51 <dons> blackdog: i'll be back for graduation, anyway :)
22:31:57 <alexyk> copumpkin: huh?  do I sense the need for intervention from friends?
22:32:10 <copumpkin> alexyk: nah, it'll probably be 100 tomorrow :)
22:32:12 <blackdog> dons: oh, you've submitted?
22:32:17 <dons> blackdog: and to drink your whisky.
22:32:20 <blackdog> heh
22:32:20 <dons> nah, few more weeks
22:32:24 <BMeph> FunctorSalad_: If you don't like it, make another package, and tell gwern about it! :)
22:32:26 * Axman6 has some nice whisky to drink
22:32:33 * copumpkin steals Axman6's whisky
22:32:43 <blackdog> Axman6: bring it to mine, haskell goes better with whisky
22:32:45 <Axman6> git your hands off!
22:32:51 <Axman6> sounds good
22:32:59 <Axman6> blackdog: which do you have?
22:33:12 <FunctorSalad_> BMeph: the comment about technological solution vs. agreement was about the computing world in general, I wasn't saying *I* could speed up the hardware by *2 :o
22:33:34 * Axman6 has a nice bottle of Laphroaig
22:33:44 <blackdog> Axman6: the Talisker's out, but I have some highland park and some cao lila
22:34:01 <blackdog> my gf's dad drank all my laphroaig while i was in portland. bastard.
22:34:05 <Axman6> not familliar with them. you'll have to introduce me in july ;)
22:34:52 <blackdog> cao lila is a peat monster
22:34:59 <Axman6> sounds good
22:35:36 <FunctorSalad_> BMeph: I meant it'd be a highly political issue which symbols get the single-byte places
22:36:13 <FunctorSalad_> (if one had to agree on a single default encoding, as ascii is now)
22:36:15 <dmead> hi channel
22:36:19 <copumpkin> hi dmead
22:36:23 <pastorn> yo
22:37:37 <Axman6> blackdog: i'm new to the whole whisky thing, this bottle is my first ever
22:37:55 <Pseudonym> Whisky discussions in #haskell-blah please.
22:37:56 <blackdog> ah, you've chosen a good place to start
22:38:05 <dmead> whisky is good
22:38:07 * blackdog doffs hat in apology
22:38:09 <dmead> but tequilla is better
22:38:12 <Axman6> (well, not including the 5 hotel sized bottles Dad got me for christmas to try some fairly well known whiskys)
22:39:57 <dmead> i need a thesis idea
22:40:00 <dmead> :/
22:40:17 <Pseudonym> dmead, the way you find a thesis idea is to do some academic's work for them.
22:40:22 <ddarius> In what general (or perhaps less general) area?
22:40:36 <dmead> ideally programming languages
22:40:55 <ddarius> A bit more specific than that.
22:40:56 <dmead> i wanted to do automatic diagnosis machines, but the data is so hard to get
22:41:03 <dons> dmead: do heaps of stuff, and get interested in something.
22:41:14 <dmead> i want to try backporting features in curry into haskell
22:41:18 <dons> or, alternatively, work on something really hot.
22:41:25 <dmead> like value inference
22:41:33 <dmead> yea, hot is a loaded word
22:41:52 <copumpkin> value inference :o
22:42:02 <ddarius> dmead: Is this Master's or PhD?
22:42:03 <copumpkin> djinn! :P
22:42:07 <dmead> masters
22:42:25 <dmead> http://portal.acm.org/citation.cfm?id=1721654.1721675&coll=portal&dl=ACM
22:42:41 * ddarius thinks he actually has access to ACM now (!)
22:42:45 <dmead> oh ffs, it needs a login
22:42:51 <dmead> i have it, but only from campus
22:43:12 <dmead> here it is
22:43:13 <dmead> http://cacm.acm.org/magazines/2010/4/81495-functional-logic-programming/comments
22:43:55 <dmead> i guess i'll ssh to campus and wget the thing
22:44:26 <Axman6> your uni doesn't have a proxy for such sites?
22:44:59 <dmead> i think you can vpn, but it's just easier to use wget
22:47:30 * ddarius looked at his ideas file and notices that he has a lot of interesting ideas in it.
22:48:04 <dmead> i'll buy that for a dollar!
22:48:42 <dons> dmead: parallelism. and types. or stuff.
22:48:59 <dons> we have no good tools for reasoning about the correctness of concurrrent haskell programs.
22:49:05 <dons> make concurrent separation logic work
22:50:18 <dmead> are there tools for reasoning about the correctness of programs not in haskell?
22:51:00 <dons> well, people have certainly tried to do it for C.
22:51:01 <Axman6> i have a feeling they exist for Ada
22:51:04 <ville> Design question about the interface offered by Gtk2Hs, why does their builderGetObject take a cast function that apparently determines the return type, rather than having written builderGetButton, builderGetWindow and so on? Is there something Haskel-esque about their choice?
22:51:10 <dons> or CSP.
22:51:26 <Axman6> which has fantastic concurrency cupport for a C like language
22:51:50 <dons> distributed transactional memory is an intereesting topic.
22:52:12 <dons> dmead: who's your supervisor? what's their interests?
22:52:17 <Axman6> we need more distribution stuff in haskell. net-concurrent looks quite nice
22:52:21 <ddarius> Any kind of distributed computing would be interesting and Clean has some work there.
22:52:22 <dons> that largely determines what's possible, imo.
22:52:34 <dmead> my supervisor does functional languages and AI
22:52:38 <dons> Eden, GpH have multi-year funding, so they're active again
22:52:47 <dons> haskell on the cloud ftw
22:52:51 <dmead> so, something with correctness or language features is preferred
22:52:53 <dmead> mm
22:52:54 <dmead> hmm,
22:53:02 <dons> dmead: do a summer intern at galois an get inspired?
22:53:05 <Axman6> GpH?
22:53:13 <dmead> dons, sure?
22:53:18 <dmead> dons, want a resume?
22:53:29 <dons> http://www.macs.hw.ac.uk/~dsg/gph/ their website hasn't got funding, tho'
22:53:43 * Axman6 would take a summer internship at Galois if he could
22:53:50 <Axman6> heh
22:54:00 <dons> dmead: send it in. ezyang's already lined up this summer
22:54:03 <dons> next month i think he starts.
22:54:14 * ddarius is actually in the market for a job in the rather near future...
22:54:15 <dons> but we don't really mind, as long as there is work.
22:54:37 <dmead> sure, i'll send it this weekend
22:54:39 <copumpkin> ddarius: omg
22:54:41 <dmead> i'll be at hac phi tomorrow
22:54:44 <dmwit> ville: I don't see builderGetObject in the docs.
22:54:47 <dons> galois prob. hiring in a few months. always open for PI-types with funding experience.
22:55:03 * Axman6 thinks the problem with doing an internship at Galois is that dons already does all the interesting work he wants to
22:55:13 <dons> byorgey: we're sponsoring hac Phi right??
22:55:17 <ville> dmwit: I am viewing /usr/share/doc/gtk2hs/demo/gtkbuilder
22:55:26 <dons> Axman6: nah, there's too much work, not enough time.
22:55:32 <ville> .t
22:55:32 <gogonkt> now at #haskell
22:55:33 <Axman6> heh
22:56:00 <ville> dmwit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25608#a25608
22:56:26 <dons> dmead: well, i think galois is sponsoring hac phi, and if so, it'd be great to let everyone know we're open for interns, and also to think of us in a few months when hiring starts up :-)
22:56:39 <ville> dmwit: lines 13 and 14. To me it just looks like an additional parameter the user of the function has to pass, without any particular benefit. Boilerplate if you will.
22:56:45 <dons> also, pdx rules and the west coast is the best coast.
22:56:55 <dmead> dons, excellect... cause i'll be trolling for guest speakers to come to west chester in the fall
22:57:21 <ddarius> dons: How long have you spent, at any one time, on the east coast?
22:57:27 <dons> dmead: i could prob. give a talk.
22:57:32 <dons> ddarius: in one stint? hmm. 2 weeks
22:57:56 <dons> ddarius: prob 1 month a year spent over there on avg.
22:57:57 <dmwit> dons: We'd love to have Galois sponsor Hac Phi! I think byorgey has been keeping track of all the documentation, but I'd be happy to make some kind of announcement on your behalf.
22:58:16 <dons> dmwit: pretty sure we lined somethiing up with byorgey , but not sure about the terms.
22:58:27 <dons> i'd like to make sure people think of us when choosing jobs.
22:58:46 <dmead> dons, that would be cool, wcu is requiring functional programming for all the cs majors
22:58:53 <dmead> dons so we're trying to get more talks on FP
22:59:00 <dons> cool!
22:59:02 <copumpkin> wcu?
22:59:19 <copumpkin> http://wcu.edu/?
22:59:24 <dmead> wcupa.edu
22:59:27 <dmwit> Should be pretty easy to slip something in before one of the meals...
22:59:27 <dmead> thats a different school
22:59:39 <copumpkin> aha
22:59:40 <dmead> dmwit, lol?
22:59:47 <dmwit> err... heh
22:59:52 <dmead> please, no roofies
22:59:58 <dmwit> I didn't mean into the food. =P
23:00:01 <dmead> i know how it goes in west philly ;)
23:00:02 <dmwit> I meant into the conversation. =P
23:00:10 <dmwit> Yeah, we're a hard bunch.
23:00:28 <dmwit> rohypnaskell, the drug of choice for Galois recruiting
23:00:55 <copumpkin> hah
23:00:56 <dons> ddarius: thinking of oregon?
23:01:15 <dmwit> "Wha...? Where am I?"  "Never mind that now, you have to prove noninterference for this code!"
23:01:35 <dons> hah
23:02:04 <dons> also, publish lots of code and papers
23:02:09 <dons> that makes it really easy to hire.
23:02:28 <ville> dmwit: had a chance to peek at the link?
23:02:55 <dmwit> ville: Yeah, but I can't find any of the relevant functions in the documentation.
23:03:08 <ville> Ok.
23:03:30 <Axman6> so, ByteString function similar to [a..b] would be...
23:03:35 <ddarius> dons: I have very little in geographical constraints.  I'm not really sure how desirable I would be to Galois, though I may put in an application just for the heck of it.
23:03:54 <ddarius> Axman6: take+drop
23:04:00 <dmwit> ...which is odd, because the source has haddock-style comments.
23:04:02 <Axman6> eh?
23:04:05 <ddarius> Er
23:04:14 <Axman6> haskell [a..b] :P
23:04:19 <ddarius> Axman6: Why would you want to do that?
23:04:33 <Axman6> i actually don't, and will avoid it :)
23:04:45 <ville> dmwit: seems like they could have made: builderGetButton builder button = builderGetObject builder castToButton button
23:04:55 <copumpkin> you could probably use unforldrN
23:04:58 <copumpkin> but I wouldn't
23:05:03 <ville> dmwit: and keep the actual code wrapping the FFI in one place.
23:05:20 <dons> ddarius: i can only guess at bits of your resume. might be interesting.
23:05:52 <dons> btw, we had a nice speedup in some parsec 3 code this week
23:06:00 <dons> better than parsec 2. i ate my humble pie.
23:06:16 <dons> also recommended attoparsec for the problem, but that's a different issue
23:06:47 <dmwit> ville: seems kind of silly, though, doesn't it? That would need a new function for every instance of GObjectClass. This is much less code for them to write, doesn't require much extra typing by the user, and is nicely modular (e.g. you can define other casts if you choose to).
23:06:55 <ddarius> dons: It's pretty boring (my resume).  For Galois I have one big plus and one big minus, but otherwise not particularly interesting, not counting people knowing me by reputation.
23:08:07 <dmwit> ville: Keep in mind that none of this is the official answer. I'm just a user. =)
23:09:20 <ddarius> dmwit: Nothing keeps them from defining common things.
23:10:09 <dmwit> Well, submit a patch with the things you want. You never know -- it might get accepted. =)
23:11:38 <ville> dmwit: Fair enough. I would've wrapped it the other way for the user of the library, then again my Haskell days can be counted with fingers of one hand
23:15:58 <dmead> spoon.
23:16:21 <dons> combinator, band, or utensil?
23:16:33 <dmead> the tick's battle cry.
23:16:46 <dmead> i have that curry article
23:16:51 <dmead> if anyone wants a to see it
23:17:33 <aavogt> a function is a combinator when it only applies it's arguments to eachother (possibly multiple times)?
23:17:49 <aavogt> or is that definition too open
23:18:02 <copumpkin> I didn't think there was an official definition of combinator
23:18:12 <dmead> that sounds wrong
23:18:27 <dmead> http://en.wikipedia.org/wiki/Combinatory_logic
23:18:37 <dmead> A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
23:18:41 <dmead> wikipedia has spoken.
23:19:10 <cwraith> I'm pretty sure thta means foldl isn't a combinator
23:19:21 <aavogt> dmead: can you explain what part sounds wrong?
23:20:17 <dmead> aavogt, none actually
23:20:33 <aavogt> I'm confused
23:20:38 <dmead> i think you're right
23:21:03 <ddarius> copumpkin: There is, but it isn't how "combinator" is usually used here (though sometimes)
23:21:36 <ddarius> copumpkin: "Combinator" as used here (usually) is just a feel-good word.
23:21:51 <dmead> it rolls of the tounge and is satisfying to say.
23:21:53 <dmead> *off
23:23:52 <dmwit> aavogt: the "arguments" part =)
23:24:56 <copumpkin> aavogt: the extra apostrophe part ;)
23:25:24 <aavogt> copumpkin: not even the missing question marks
23:25:39 <Cale> foldl would be a combinator once you replace all data structures with functions ;)
23:26:10 <dmwit> copumpkin: http://www.homestarrunner.com/sbemail89.html
23:27:02 <dmead> checkin emails with boxing gloves, the sweet computer science
23:29:09 <dmead> dmwit, http://www.homestarrunner.com/sbemail205.html
23:29:40 <dmwit> haha, the top right is kind of melty
23:29:52 <dmead> ah ah yea it is
23:31:41 <dmwit> I lost it at "Droopy Drawers".
23:31:58 <dmwit> So did Strong Bad's actor, apparently.
23:32:22 <dmead> :)
23:33:34 <dmead> http://www.homestarrunner.com/sbemail41.html
23:33:45 <dmead> *slap*
23:34:00 <copumpkin> okay, that's enough homestarrunner in #haskell :P
23:39:54 <dmead> the bonding between strongband and strongsad in 175 is really touching
23:45:34 <dmead> goodnight chanell
23:45:40 <copumpkin> goodnight :)
23:45:51 <DigitalKiwi> you made him leave!
23:45:54 <DigitalKiwi> jerk
23:46:42 <copumpkin> :(
23:46:58 * Axman6 -> home
23:56:28 <bitstream0101> Can anyone tell me the expected behavior for this snippet (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25609)? I'm getting some odd hanging behavior. :(
23:56:45 <bitstream0101> In particular, after the timeout, I don't make it past the final connect application
23:57:57 <copumpkin> (doConnect False)
23:58:01 <copumpkin> how does that work?
23:58:08 <bitstream0101> oh, bad edit
23:58:25 <bitstream0101> that line should just be CE.try doConnect ;P
23:58:32 <copumpkin> ok :)
23:59:11 <copumpkin> might want to try running it in strace
23:59:18 <copumpkin> to see what it's doing when it hangs
23:59:39 <bitstream0101> hrm, ok.
