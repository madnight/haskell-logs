00:00:04 <ManateeLazyCat> ivanm: I think DBus make all program works together.
00:00:52 <ManateeLazyCat> ivanm: And DBus's principle is simple enough, you can use DBus and don't change exist code.
00:01:20 <ManateeLazyCat> ivanm: Use other IPC, perhaps you need change your code heavily.
00:03:04 <ivanm> well, if you had a good enough abstraction IPC library then your code wouldn't need to change much of your code...
00:03:19 <ivanm> also, are you turning your IDE into an actual DE now? :/
00:03:41 <ManateeLazyCat> ivanm: Infact, i never said it's a IDE.
00:03:54 <arw> usually you wan't something like RPC, so you don't have to care wether a function is executed locally or remotely.
00:04:00 <ManateeLazyCat> ivanm: It's a multi-processes framework that including IDE, but not just IDE. :)
00:04:31 <ManateeLazyCat> arw: I think it's should be easy that integrate DBus with network .
00:05:08 <ManateeLazyCat> ivanm: Just many people will think "oh, it's a IDE" after i talk some details.
00:05:28 <arw> ManateeLazyCat: perhaps. but the freedesktop-guys have promised network support for dbus for quite some time now. i guess it will take another 5 years.
00:05:42 <ManateeLazyCat> ivanm: I prefer said it "IIE -- Integrate Live Environment" :)
00:06:00 <ivanm> hmmmm.....
00:06:11 <ivanm> Live Integrated Environment (i.e. LIE)? :p
00:06:14 <arw> ManateeLazyCat: problem is, networking poses another few challenges, like different encodings (big/little endian), authorization and authentication, routing, etc.
00:06:22 <ManateeLazyCat> ivanm: Sorry, ILE
00:06:26 <kynky> whats wrong with sockets for IPC ?
00:06:43 <ManateeLazyCat> ivanm: Even haven't that support, we can use other way to make DBus support network,
00:06:53 <ManateeLazyCat> ivanm: Sorry, is arw
00:07:03 <arw> kynky: nothing, you just need to think about some kind of data encoding.
00:07:08 <ManateeLazyCat> arw: Because DBus's design is simple and clean enough.
00:07:32 <ManateeLazyCat> arw: Yes, that's problem, but not a big problem.
00:08:00 <kynky> arw, like xml ?
00:08:06 <ManateeLazyCat> arw: I think have exist mechanism to handle those situation (such as big/little endian), isn't ?
00:08:26 <kynky> base64 encoded
00:08:27 <arw> kynky: perhaps, yes. there are tons of possibilities.
00:09:06 <ManateeLazyCat> ivanm: My english is too bad sometimes, yes, your "Live Integrated Environment" is right word. :)
00:09:20 <kynky> thats a lie
00:09:26 <arw> ManateeLazyCat: there are mechanisms, yes. there are also working solutions, like corba. problem is, dbus came to life only, because the freedesktop guys rejected corba as unsuited, now reinventing it :)
00:10:08 <arw> ManateeLazyCat: for the most part, IPC and RPC are solved problems. dbus is just a very old thing invented all over again, including early mistakes.
00:10:27 <ManateeLazyCat> ivanm: I'm hide my LIE as a normal Gtk+ application, when it developing stronger, i will drop DE, and build it on Linux kernal. I can get it after i login. :)
00:10:36 <ivanm> heh
00:10:46 <ivanm> well, I doubt I'll ever use it, but go right ahead
00:11:43 <ManateeLazyCat> arw: I guess corba is too big ? :)
00:12:22 <arw> ManateeLazyCat: yes, "too big, too complicated" were the arguments. nowadays, dbus is bigger and more complicated than many simple corba orbs.
00:12:31 <p_l> ManateeLazyCat: Corba doesn't solve anything, too.
00:12:57 <ManateeLazyCat> ivanm: My project looks too weird, it's not anything, but it's try to became everything, but it's my dream, and i got good starter because i have fix most base support in gtk2hs.
00:13:03 <p_l> I'd rather use SOAP with Message profile instead of CORBA
00:13:41 <ManateeLazyCat> arw: I think it's will be simple if just have Unix system in this world. :)
00:13:55 <ManateeLazyCat> arw: But looks impossible.
00:14:27 <kynky> i dont like SOAP, i prefer REST
00:14:46 <kynky> but thats just personal taste
00:15:49 <ManateeLazyCat> ivanm: I spend too much time to fix gtk2hs, otherwise i have release my project now.
00:16:12 <ManateeLazyCat> ivanm: My project can't running stable if gtk2hs can't work.
00:17:08 <ivanm> true
00:17:48 <ManateeLazyCat> arw: If freedesktop-guys can rebuild a awesome Network for DBus, why not use it? I'm waiting....
00:19:00 <ManateeLazyCat> ivanm: In my speical usage: GtkSocket/GtkPlug with multi-processes framework, i spend much test time to found secret trick hidden in code.
00:19:39 <arw> ManateeLazyCat: if they can, its nice. but given desasters in that area like HAL, i'm not holding my breath.
00:19:41 <ManateeLazyCat> ivanm: Lucky, i make it's works, but unfortunately, ghc-6.12.2 break my code somehow.
00:20:43 <ManateeLazyCat> ivanm: And most lucky is Axel make gtk2hs core packages install by Cabal to save much maintain time .
00:23:58 <ManateeLazyCat> ivanm: I hope my project can make all haskeller write Haskell code for practice easily, open platform, many plug-in, like firefox for browser.
00:24:52 <ManateeLazyCat> ivanm: Perhaps, have some runtime plug-in problem is waiting for me, anyway, i have start it. :)
01:13:12 <cizra> Hm. How can I write my generator for my particular flavour of arbitrary strings? Ideally I should make a new string type alias OSLT, to keep it interfering with regular arbitrary strings?
01:14:40 <dibblego> newtype MyString = M String; instance Arbitrary MyString where ...
01:14:48 <Saizan> or you can use forAll
01:14:55 <Saizan> and provide the generator manually
01:16:29 <cizra> hm
01:16:33 * cizra tries forall
01:17:06 <sleepyMonad> @type map
01:17:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:21:07 <cizra> \o/ works!
01:32:09 <glguy> Interesting, in the darcs version of the standard lib, \ex is the type of the dependent pair and \Sigma is just a convenient wrapper
01:32:17 <dancor> Saizan: trying the nqueens example, monadiccp seems to not work under ghc 6.12.{1,2}.  do you know if it broke going from 6.10.*?
01:33:43 <Saizan> dancor: i've not tried it recently
01:49:04 <chrisdone> does cabal-install support installing a package's dependancies but not the package itself?
01:49:57 <Saizan> only if you're good at using ^C :)
01:50:02 <chrisdone> i'm using cabal for an executable, but it doesn't belong in an installation directory and it's an fcgi process anyway. i don't want it installed
01:50:05 <chrisdone> haha, really?
01:50:13 <chrisdone> ughhh
01:51:12 <ivanm> chrisdone: you can fetch all dependencies I believe and then build them...
01:51:27 <ivanm> chrisdone: alternatively, change the executable directory if it's the only executable
01:51:59 <ivanm> --bindir=.
01:52:02 <ivanm> or something like that
01:52:12 <monadic_kid> is transformers library more efficent than mtl?
01:52:17 <monadic_kid> I mean does transformers monad transformer suffer the same issue of being 300% slower as with mtl's monad transformers?
01:52:31 <chrisdone> ivanm: hmm thanks i'll try that
01:52:37 <ivanm> mtls transformers are 300% slower? really?
01:52:39 <ivanm> than what?
01:52:52 <ivanm> monadic_kid: I'm under the impression that the only difference is that transformers in haskell98
01:53:37 <Saizan> monadic_kid: the high-level implementation is identical, and i don't think they've added any low-level optimization
01:53:38 <monadic_kid> ivanm: I read it some where, I think RWH
01:53:54 <ivanm> really? :o
01:54:14 <chrisdone> bash-3.2$ cabal update
01:54:15 <chrisdone> Downloading the latest package list from hackage.haskell.org
01:54:15 <chrisdone> cabal: Codec.Compression.Zlib: premature end of compressed stream
01:54:15 <chrisdone> bah, i can't do *anything* on this damn free wifi
01:54:28 <monadic_kid> ivanm: and some articles, i've read it's better to write a custom monad or use continuation monad
01:54:39 <ivanm> hmmm.....
01:54:53 <monadic_kid> ivanm: I mean if you're concerned with speed
01:54:56 <ivanm> I know that RWS is explicitly defined rather than being a stack...
01:55:00 <ivanm> monadic_kid: who isn't? ;-)
01:55:10 <chrisdone> ruby programmers
01:55:12 <ivanm> chrisdone: I think that's a zlib bug or something
01:55:20 <ivanm> preflex: seen dcoutts_
01:55:21 <preflex>  dcoutts_ was last seen on #haskell 2 days, 6 hours, 25 minutes and 52 seconds ago, saying: * dcoutts_ has to go
01:55:22 <ivanm> preflex: seen dcoutts
01:55:22 <preflex>  dcoutts was last seen on #ghc 1 day, 19 hours, 13 minutes and 40 seconds ago, saying: tibbe: it's not necessary since n gets matched against 0
01:55:43 <chrisdone> it would take me 5 minutes to access the cabal ticket site
01:56:02 <Saizan> ivanm, monadic_kid: there are both algorithmic and lowlevel reasons why a continuation based custom monad can be faster in some use cases
01:56:06 <chrisdone> maybe i can pay for this vodafone wifi
01:56:09 <chrisdone> brb
01:56:14 <monadic_kid> Saizan: I'm guessing it's only going to be slow if you use a monad stack on really low level
01:56:32 <monadic_kid> Saizan: i mean low level types
01:56:41 <monadic_kid> or maybe not
01:56:47 <monadic_kid> i need to read that article/chapter again
01:57:25 <Saizan> well, as usual speed matters only in the operations you do most
01:59:01 <Saizan> http://www.iai.uni-bonn.de/~jv/mpc08.pdf <- this is about using continuations
01:59:13 <Saizan> the other issue i was referring to is inlining
01:59:58 <Saizan> if the >>= for your monad gets inlined you usually get better optimized code
02:01:52 <monadic_kid> how about the two different methods in transformers, one is like mtl using FD and the new one on GADTs
02:01:59 <Saizan> so if someone went and sprinkled some INLINE pragmas inside mtl while doing some benchmarks we could probably get better results :)
02:02:21 <Saizan> GADTs? don't you rather mean associated types?
02:02:55 <Saizan> or type families as they are called now
02:03:31 <monadic_kid> yeah type families
02:04:08 <Saizan> the only difference is at the type level there
02:04:54 <Saizan> afaiu at least, they should get translated into the same thing in GHC's internal language
02:06:22 <monadic_kid> well i should change over to use transformers later on, since mtl is not going to be in the platform in the future
02:06:30 <Saizan> really?
02:07:03 <monadic_kid> I've been reading mtl might be getting depreicated for transformers at some point, on mailing lists
02:07:06 <ivanm> Saizan: they're wanting to change to something else as soon as one of them get used more than mtl
02:07:18 <ivanm> monadic_kid: well, transformers is the most likely option atm
02:07:27 <Saizan> i hope that something else is not transformers..
02:07:33 <ivanm> Saizan: mtl uses extensions, and has a bug in ErrorT or something IIRC
02:07:40 <Saizan> or that transformers get fixed
02:07:51 <ivanm> Saizan: most likely to be transformers because it's API is almost the same if not identical
02:07:54 <monadic_kid> Saizan: what's wrong with them? I've got no experinice with them
02:07:58 <ivanm> why, what's wrong with transformers?
02:08:26 <Saizan> it keeps most of what's wrong with mtl.
02:08:44 <Saizan> http://hackage.haskell.org/packages/archive/transformers/0.2.1.0/doc/html/Control-Monad-Trans-List.html#v%3AListT <- e.g. this is not a monad transformer.
02:10:30 <ivanm> Saizan: so it has the same problems API-wise as mtl?
02:12:20 <Saizan> it has the same bugs :)
02:12:34 <Saizan> at least the most known ones
02:12:57 <ivanm> with the sole advantage of no extensions?
02:13:55 <Saizan> yeah, afaiu
02:14:08 <ivanm> oh well
02:14:15 <ivanm> I've only used State and RWS
02:14:16 <ivanm> *shrug*
02:14:26 <ivanm> Saizan: so which transformer lib do you prefer/recommend?
02:15:20 <Saizan> monadLib seems the best wrt functionality, though some might object to fundeps
02:16:08 <Saizan> (however i realize that transformers is like this because it's meant to be a drop-in replacement, though if we're going to change..)
02:17:07 <ivanm> Saizan: you mean the had to keep the same bugs to avoid confusion/problems? :p
02:19:52 <Saizan> that's what i imagine
02:20:10 <Saizan> btw, for speed one might use monad-ran
02:21:03 <Saizan> though you've to benchmark, it's not guaranteed to be faster
02:22:20 * Saizan is procrastinating too much
02:22:28 <jlouis> hack
02:23:16 <jlouis> you need to register hack.it, burn.it, use.it, drink.it, whip.it, spank.it, code.it, debug.it, and mangle.it. Then set up 301 redirects on them in a cycle
02:23:58 <ivanm> I'm guessing .it == italy?
02:24:07 <systemfault> yes
02:24:21 <Saizan> yeah :)
02:25:46 <Saizan> it's a pain to register an .it though, you've fax them a signed document
02:26:29 <Saizan> s/fax/to fax/
02:30:54 <Jonno_FTW> hi, I am trying to use the Network package
02:31:18 <Jonno_FTW> to send a test message between two computers using: main = withSocketsDo $ do ; sendTo "192.168.1.3" (PortNumber (fromIntegral $ port)) "Testing message"
02:31:29 <Jonno_FTW> but nothing happens on the other computer
02:31:37 <Niccus> is the other computerlistening
02:31:44 <Jonno_FTW> when running: listenOn (PortNumber (fromIntegral $ port))
02:32:10 <Jonno_FTW> i get WSATIMEDOUT on both
02:34:39 <Saizan> i think you should use recvFrom
02:34:45 <Jonno_FTW> i will now
02:36:09 <Saizan> also note that "Their use is strongly discouraged except for small test-applications or invocations from the command line."
02:36:20 <Jonno_FTW> well this is just a test
02:36:52 <Jonno_FTW> and it still won't work
02:38:39 <Kaidelong> I've set up vim (my personal poison)'s haskell extensions but before getting a chance to use it I've discovered Yi. I know I need to ditch Leksah, but should I use vim over Yi?
02:40:23 <Jonno_FTW> @hpaste
02:40:23 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:42:08 <Saizan> Kaidelong: hard to say, the hackage version needs some hints to cabal to get built if you decide to try it
02:42:12 <Jonno_FTW> and I can't test a connection to myself because I get a connection refused error
02:42:37 <Kaidelong> so it'll be more trouble than using what I already have, but there is a payoff?
02:43:46 * Saizan doesn't know
02:43:51 <Kaidelong> ah okay
02:44:06 <Kaidelong> hmm, I take it most people use emacs or vim
02:44:30 <Saizan> yeah
02:44:55 <Entroacceptor> imho Yi isn't enterprise-ready yet ;)
02:45:18 <SubStack> the enterprise was pretty behind the times
02:45:33 <Kaidelong> Entroacceptor: what's your pick for a development environment?
02:45:50 <SubStack> all that crew when the computer can do everything itself
02:46:16 <Kaidelong> I was excited about leksah for having a semblance of a project manager and a module viewer but quickly realized that it was implemented really badly and not much help
02:46:29 <Entroacceptor> I'm using vim (but not doing any professional work)
02:46:34 <Kaidelong> help much
02:46:38 <Kaidelong> ok
02:46:55 <Entroacceptor> I'd really love to use emacs with org-mode, but I can't get to like it
02:47:01 <Jonno_FTW> I got this far but neither seem to work: http://codepad.org/oK042Ej2
02:47:27 <Entroacceptor> and install snipMate for vim!
02:47:34 <Kaidelong> only reason I don't use emacs is because vim was the first one I was exposed to and after that I didn't need emacs
02:47:37 <hamishmack> Kaidelong: can you be more specific about there Leksah fell short?
02:48:07 <Niccus> Jonno_FTW:  Odd, works for me with sendto/recvfrom
02:48:13 <Cale> Kaidelong: Most people are pretty happy just keeping ghci open alongside their favourite text editor. Any text editor will do so long as it will convert tabs to spaces automatically for you.
02:48:15 <Kaidelong> hamishmack: getting it to run and find GHC's modules can be a problem, on one of my computers it (and other GTK apps) will hang
02:48:20 <Jonno_FTW> i'm on windows
02:48:34 <Niccus> i'm on linux
02:48:43 <Jonno_FTW> interesting
02:48:43 <Kaidelong> hamishmack: I found no obvious way to delete a file from a cabal project using the GUI tools
02:48:54 <Jonno_FTW> and you used what I had pasted Niccus
02:48:56 <Jonno_FTW> ?
02:49:17 <Niccus> close
02:49:56 <Kaidelong> hamishmack: also, Leksah's build in the background thing to highlight errors doesn't seem to work well on windows, apparently it's a known issue
02:50:08 <Jonno_FTW> where you going between 2 linux machines?
02:50:16 <Niccus> client not really any different, server doesn't need forever
02:50:23 <Niccus> single computer to itself
02:50:36 <Jonno_FTW> it won't let me send to myself
02:50:40 <Jonno_FTW> i'll try in linux
02:50:41 <hamishmack> Kaidelong: Windows background build is fixed in darcs
02:51:06 <Niccus> have you got a firewall up
02:51:19 <Jonno_FTW> no, this is just on the home network
02:51:36 <Niccus> also low port numbers are usually reserved
02:51:43 <Jonno_FTW> hmmm
02:51:54 <Kaidelong> hamishmack: darcs is broken for windows right now and I'll need to get the testing version of gtk2hs
02:52:02 <hamishmack> Kaidelong: Source collection on windows is very slow, if you add wget to your path
02:52:04 <Niccus> pick a random one above 1024 or so
02:52:17 <Kaidelong> I did add wget to my path
02:52:29 <Kaidelong> the instructions for settingit up told me to do so
02:52:34 <hamishmack> Kaidelong: it will download metadata if it can from instead of building it
02:56:47 <hamishmack> Kaidelong: Did you use the binary installer or build it from source?
02:57:01 <Kaidelong> For leksah? I built it from source
02:57:22 <Kaidelong> darcs will not build anywhere I try it, something about expecting a char but getting a wchar_t
02:57:40 <Kaidelong> apparently they know what the problem is and they will fix it
02:57:45 <Kaidelong> err
02:57:46 <Kaidelong> sorry
02:57:50 <Kaidelong> for leksah, I used a binary
02:57:59 <Kaidelong> it's what I meant, but not what I typed
03:21:36 * hackagebot freekick2 0.1.0 - A soccer game  http://hackage.haskell.org/package/freekick2-0.1.0 (AnttiSalonen)
03:26:30 <Saizan> jlouis: the hackage version of Combinatorrent doesn't build against  attoparsec-0.7.2
03:32:56 <mux> how is gtk2hs supposed to be built from darcs? the instructions don't work anymore (confugre.ac is configure.ac.stale for some reason, and there is a Makefile.am.stale), and the bootstrap.sh script doesn't work either because it wants configure to be ran first
03:33:52 <hamishmack> cd tools; cabal install; cd ..; sh bootstrap.sh
03:35:33 <mux> hamishmack: that works better, thanks; there are still failures though, inverstigating why
03:52:11 <monadic_kid> @pl (\(x,y) -> (fromIntegral x, fromIntegral y))
03:52:12 <lambdabot> fromIntegral *** fromIntegral
03:52:46 <silver_> @src (***)
03:52:46 <lambdabot> f *** g = first f >>> second g
03:54:31 <monadic_kid> :t (fromIntegral *** fromIntegral)
03:54:32 <lambdabot> forall b c b' b1. (Integral b, Num c, Integral b', Num b1) => (b, b') -> (c, b1)
03:54:38 <jlouis> Saizan: oh!
03:54:56 <monadic_kid> :t (***)
03:54:58 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:55:22 <jlouis> Saizan: I ponder if I should state >= 0.8 then
03:58:47 <Saizan> jlouis: it complains about attoparsec exporting a lookAhead, making the use in your code ambiguous
03:59:21 <jlouis> Saizan: hmm, interesting
03:59:33 <jlouis> I still think it is easier to bump it
03:59:36 <Saizan> yeah
04:02:51 <jlouis> Saizan: there. Next version should have the fix. Do note however that 0.3.1 of combinatorrent has some bugs as well :)
04:03:36 <jlouis> Saizan: it listens on the wrong port due to network-endianess errors, hehe
04:04:14 <Saizan> hah
04:04:22 <jlouis> for some reason, you need to release a version in order to uncover all the grave bugs
04:05:06 <Saizan> but it does seem to download here
04:05:26 <jlouis> you do not need to have an incoming listen port as long as you can connect to otheres
04:05:35 <Saizan> ah, right
04:05:40 <jlouis> it is effectively like working behind a NAT
04:06:01 <Saizan> yeah, i'm behind one anyway, though my usual client uses UPnP
04:07:07 <jlouis> UPnP support... that sounds like a fun project...
04:09:52 <Saizan> true, there doesn't seem to be any lib on hackage either
04:10:14 <jlouis> STUN/STUNT/ICE is another vampire in that coffin
04:11:34 <Saizan> that's new to me
04:33:19 <dibblego> @hoogle runIdentity
04:33:19 <lambdabot> Control.Monad.Identity runIdentity :: Identity a -> a
04:36:35 <ThePok> haskell is dead!
04:36:45 <kynky> ?
04:36:48 <mauke> long live haskell
04:37:01 <ThePok> ;D
04:50:10 <jlouis> all hail the Haskell Zombies, the Haskell vampires and the haskell brainz!
04:54:02 <Entroacceptor> and what's with the Haskelletons?
04:54:26 <Twey> Heh
05:09:49 <imc> greetings and good Sunday to everyone!
05:10:20 <imc> i would like to know something: is there a way to get the string representation of a type in haskell?
05:10:36 <mauke> depends
05:11:17 <Lemmih> > typeOf (0::Int)
05:11:18 <lambdabot>   Int
05:11:21 <imc> :D
05:11:26 <Lemmih> > show (typeOf (0::Int)) == "Int"
05:11:27 <lambdabot>   True
05:11:44 <Lemmih> imc: Be careful, though.
05:11:47 <imc> where does that "typeOf" comes from ?
05:11:52 <mauke> @index typeOf
05:11:53 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
05:12:06 <imc> ok... it's just for logging purpouses
05:12:22 <mauke> did you mean: porpoises
05:12:27 <imc> yep eheheh
05:12:34 <imc> turtoises
05:12:47 <imc> or turtles, for short
05:14:25 <Twey> Turtles swim.  Tortoises plod.
05:14:42 <mauke> > fix $ Node "turtle" . replicate 2
05:14:42 <lambdabot>   Node {rootLabel = "turtle", subForest = [Node {rootLabel = "turtle", subFor...
05:14:49 <mauke> ALL THE WAY DOWN
05:14:52 <imc> ghgh
05:15:12 <imc> in italian (i think) we call them both turtles
05:15:29 <imc> or "earth" turtle vs "sea" turtle
05:15:47 <Lemmih> vs ninja turles.
05:15:51 <imc> yep, of course
05:16:07 <imc> or "sewer" turtle
05:16:10 <mauke> Schildkröte
05:16:53 <imc> we are some strange guys, in less than 40 seconds we went from haskell code to biological classification and puns
05:17:01 <Zao> "I like turtles!"
05:17:09 <imc> me too
05:17:16 <mauke> zombie turtles
05:17:32 <Ke> teenaged zombie turtles
05:17:51 <mauke> zombie turtles would be too slow, though
05:18:04 <imc> ahahahha
05:18:09 <Botje> who cares? they're armored
05:18:16 <Botje> and they only have to hold on tightly >:)
05:18:24 <jlouis> armored teenage zombie turtles
05:18:35 <imc> i'm having great fun, thank you guys, the day took a good "cheer up" boost
05:33:17 <imc> uhm.. not possible to have a data type with a varying number of type arguments isn't it?
05:33:38 <imc> will do it "a-la-unzipX"
05:34:18 <Twey> No, but try doing it à la ZipList instead maybe
05:35:21 <imc> yep
05:36:36 <imc> i want to write a "stack trace" system (for debugging things), and want to maintain a "stack trace" (i.e. a stack of "stack frame" containing function name + parameter passed, the only thing is that the parameter have different types and different sizes :/)
05:37:12 <imc> then first thing you do is push a frame, last thing, pop the frame (i.e. a "return" that _do_ change the state)
05:37:17 <voker57> (function, [parameter]) ?
05:37:21 <imc> yep
05:37:24 <imc> but parameter a
05:37:34 <imc> or parameter a, parameter b
05:37:38 <Saizan> there's someone implementing stack traces inside ghc, or at least hacking in that direction
05:38:11 <imc> uhmm
05:38:15 <imc> would be easier probably
05:38:59 <imc> or i can just go with string representation of everything
05:39:08 <imc> it's just for debugging after all
05:40:25 <imc> instead of `newParam name val = Parameter name (typeOf val) val` i would do `newParam name val = Parameter name (show (typeOf val)) (show val)`
05:40:40 <imc> so, always strings
05:41:32 <xerox> newParam p = p { val = show . typeOf . val $ p } -- :D
05:42:49 <imc> thank... i'm haskell addicted but not too good at it yet (but i can't stop, it's becoming my brain's language ehhe)
05:43:50 <imc> actually i cannot understand that construct xerox
05:45:01 <Twey> let r = Rec { foo = "bar", baz = "quux" } in r { foo = "baz" } -- ⇒ Rec { foo = "baz", baz = "quux" }
05:45:07 <Twey> Update
05:45:26 <imc> ok
05:48:11 <xerox> http://www.haskell.org/onlinereport/exps.html#sect3.15.3
05:48:47 <imc> yeah now i almost get it... but val = (show val), not (show . typeOf val)
05:48:53 <imc> (in my case)
05:50:05 <imc> but newParam is used to make a shiny new parameter, not to update it
05:51:58 <imc> kewl, the thing is taking form... that would be my first real-world exercice on monads :D
05:53:28 <mamalujo_> which "open gl c library" is required for compiling the platform?
06:03:44 <Toxaris> How to report a problem with the Windows installer for the Haskell Platform?
06:04:45 <ivanm> Toxaris: what's the problem?
06:04:51 <ivanm> (I probably can't help, but maybe...)
06:05:20 <Toxaris> ivanm: I already found a workaround, so it's not that critical for me
06:05:57 <Toxaris> ivanm: the problem is that cabal install does not find *.h files installed with the extra-libraries in the Haskell Platform
06:06:21 <ivanm> hmmm.....
06:06:26 <ivanm> preflex: seen dcoutts
06:06:26 <preflex>  dcoutts was last seen on #ghc 1 day, 23 hours, 24 minutes and 43 seconds ago, saying: tibbe: it's not necessary since n gets matched against 0
06:06:27 <ivanm> preflex: seen dcoutts_
06:06:27 <preflex>  dcoutts_ was last seen on #haskell 2 days, 10 hours, 36 minutes and 58 seconds ago, saying: * dcoutts_ has to go
06:07:38 <Toxaris> they are installed into $platform\lib\extralibs\$package\$compiler\include, but searched in $platform\extralibs\$package\$compiler\include
06:07:55 <Toxaris> so I just copied the former to the latter, and it works for now
06:15:08 <kingping> @type (sum .) . (\x -> \y -> [1,2])
06:15:09 <lambdabot> forall a t t1. (Num a, Functor ((->) t1), Functor ((->) t)) => t -> t1 -> a
06:17:16 <chrisdone> @vixen tell me something interesting
06:17:17 <lambdabot> *giggles*
06:19:48 <kingping> This probably works because parially applying (\x -> \y -> [1,2]) one . is dropped, and \y -> [1,2] is exactly the thing (any lambda, regardless of arguments number) . expected to get.
06:20:02 <kingping> *partially
06:21:16 <kingping> @type (.) sum
06:21:17 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f [a] -> f a
06:22:04 <Axman6> :t let f = \x -> f in f
06:22:05 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
06:22:06 <lambdabot>     Probable cause: `f' is applied to too few arguments
06:22:06 <lambdabot>     In the expression: f
06:24:55 <kingping> @type ((sum .) .) . (\x -> \y -> \z -> [x,y,z])
06:24:56 <lambdabot> forall a. (Num a) => a -> a -> a -> a
06:25:09 <kingping> > ((sum .) .) . (\x -> \y -> \z -> [x,y,z]) 1 2 3
06:25:10 <lambdabot>   No instance for (GHC.Num.Num (f1 (f [a])))
06:25:10 <lambdabot>    arising from the literal `1' ...
06:25:23 <kingping> > (((sum .) .) . (\x -> \y -> \z -> [x,y,z])) 1 2 3
06:25:24 <lambdabot>   6
06:26:43 <kingping> I wonder if in lamba calculus there's a (.)
06:27:33 <kingping> @type (((sum .) .) . )
06:27:34 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Num a, Functor f, Functor f1, Functor f2) => f2 (f1 (f [a])) -> f2 (f1 (f a))
06:27:45 <Taejo> @type (.)
06:27:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:27:49 <chrisdone> i don't recall seeing one
06:28:16 <Taejo> who's been naughty with the prelude?
06:28:31 <ManateeLazyCat> I have install GHC-6.12.2 and want to rollback to 6.12.1, so how to set Cabal use GHC version to 6.12.1 instead 6.12.2?
06:28:34 <chrisdone> Taejo: Cale
06:28:55 <Taejo> yeah, that smells of Cale
06:29:06 <ManateeLazyCat> And i have install many libraries with 6.12.2, i need reinstall those package with 6.12.1 again?
06:29:21 <chrisdone> :t (++)
06:29:22 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:29:31 * chrisdone golf clap
06:30:25 <jutaro> ManateeLazyCat: On Linux I can switch between different versions of ghc with a simple script, and the package databases are kept seperate.
06:31:05 * kingping being Grammar Nazi sepArate !
06:31:32 <kingping> :t ($)
06:31:33 <lambdabot> forall a b. (a -> b) -> a -> b
06:31:42 <ManateeLazyCat> jutaro: How? My code break in GHC-6.12.2 (and looks is a new bug of 6.12.2), so i want do switch between 6.12.1 and 6.12.2 for investigation.
06:32:14 <jutaro> Here's my script:
06:32:17 <jutaro> #!/bin/sh
06:32:17 <jutaro> ln -nfs  /usr/local/bin/ghc-6.12.1 /usr/local/bin/ghc
06:32:17 <jutaro> ln -nfs /usr/local/bin/ghci-6.12.1 /usr/local/bin/ghci
06:32:17 <jutaro> ln -nfs /usr/local/bin/ghc-pkg-6.12.1 /usr/local/bin/ghc-pkg
06:32:17 <jutaro> ln -nfs /usr/local/bin/runghc-6.12.1 /usr/local/bin/runhaskell
06:32:17 <ManateeLazyCat> jutaro: BTW, is you send "TextView signals" bug report to gtk2hs list ?
06:32:34 <ManateeLazyCat> jutaro: That's it?
06:33:09 <jutaro> ManateeLazyCat: Yes I had the TextView problems, that was a quick fix, thanks
06:33:11 <ManateeLazyCat> jutaro: So i still need re-install all cabal packages for 6.12.1 again?
06:33:48 <hamishmack> ManateeLazyCat: Thanks for the quick fix.  I had to s/TextBufferClass/TextViewClass/ BTW
06:34:18 <ManateeLazyCat> jutaro: Perhaps Axel missing it undesigned, sorry for inconvenience.
06:34:19 <jutaro> No, the package databses are seperate for me, just wonder myself how it works with the cabal exe.
06:34:33 <hamishmack> ManateeLazyCat: do you know if AccelGroup is still exposed somewhere?
06:34:45 <ManateeLazyCat> hamishmack: Wait.
06:35:56 <chrisdone> jutaro: separate! don't you learn!? :p
06:36:42 <jutaro> chrisdone: hi chris, mhh, what do you say?
06:37:07 <chrisdone> (jutaro: just joking. it's spelled 'separate')
06:37:08 <kingping> > "separate" == "seperate"
06:37:08 <lambdabot>   False
06:37:22 <xerox> > "seperate" > "separate"
06:37:23 <lambdabot>   True
06:37:45 <chrisdone> haha
06:37:53 <jutaro> chrisdone: ah my english, I somehow refuse to learn, sorry
06:38:15 <ManateeLazyCat> hamishmack: AccelGroup looks hidden in new version, do you need use it explicitly?
06:38:26 <ManateeLazyCat> hamishmack: Or any problem with Leksah?
06:38:56 <ManateeLazyCat> jutaro: I just wake up and check gtk2hs list: "Oh, it's a new bug report." :)
06:39:03 <hamishmack> ManateeLazyCat: we use it in leksah
06:39:30 <ManateeLazyCat> hamishmack: Just AccelGroup? Have any other type need expose?
06:41:15 <ManateeLazyCat> hamishmack: Axel have hidden many modules, perhaps break users' code.
06:41:35 <ManateeLazyCat> hamishmack: Please give me a type list that you need expose, i can try to help you.
06:42:11 <ManateeLazyCat> hamishmack: Oh, no.
06:42:24 <ManateeLazyCat> hamishmack: Do you use my new patches about Gtk+ 2.18.3?
06:42:34 <ManateeLazyCat> hamishmack: It's rollback by Axel.
06:43:04 <ManateeLazyCat> hamishmack: In current version, haven't any Gtk+ 2.18.3 patches that add by me.
06:43:08 <hamishmack> I can't find MenuBar or Toolbar
06:43:45 <ManateeLazyCat> Graphics/UI/Gtk/MenuComboToolbar/MenuBar.chs
06:43:46 <hamishmack> Is there a reason Graphics.UI.Gtk.Types is hidden?
06:43:52 <ManateeLazyCat> Graphics/UI/Gtk/MenuComboToolbar/Toolbar.chs
06:44:42 <ManateeLazyCat> hamishmack: Because Axel don't want user touch `mkFoo` `unFoo`.
06:45:21 <ManateeLazyCat> hamishmack: AccelGroup.chs is missing in current version.
06:46:11 <ManateeLazyCat> hamishmack: BTW, after you use AccelGroup, any bug?
06:46:31 <ManateeLazyCat> hamishmack: I perhaps push AccelGroup.chs for support Leksah.
06:47:00 <ManateeLazyCat> hamishmack: All my 2.18.3 patches still need review before push to main repo.
06:47:01 <hamishmack> ManateeLazyCat: that would be cool.  We are working through the leksah files.
06:47:11 <hamishmack> about halfway through
06:47:38 <ManateeLazyCat> hamishmack: Sorry for inconvenience, but we think stable is more important than new APIs.
06:47:53 <ManateeLazyCat> hamishmack: So just AccelGruop missing, or have more Type?
06:48:15 <ManateeLazyCat> hamishmack: I will review those module for push.
06:49:51 <hamishmack> Thats all I know of at this point
06:50:14 <ManateeLazyCat> hamishmack: Ok, i review AccelGroup's code and try to push it.
06:50:25 <hamishmack> thanks
06:51:21 <ManateeLazyCat> hamishmack: Perhaps need long time to review all 2.18.3 patches that add by me, so we need people help use review code.
06:58:03 <hamishmack> Jutaro, ManateeLazyCat: Looks like we only use the type.  I commented out the type spec that used AccelGroup and it builds now.
06:58:12 <hamishmack> and links :-)
06:59:18 <jutaro>  That sound great, yet, it would be nice to get the type back somehow.
06:59:27 <chrisdone> preflex: seen mmorrow
06:59:27 <preflex>  mmorrow was last seen on #ghc 104 days, 11 hours, 1 minute and 41 seconds ago, saying: * mmorrow is rtfm'ing
07:00:22 <ManateeLazyCat> Please send any problem to gtk2hs list, i have so much time on IRC. :)
07:03:55 <kingping> > pl \a b -> a:b:[]
07:03:56 <lambdabot>   <no location info>: parse error on input `\'
07:04:12 <kingping> > pl \a b -> a b
07:04:13 <lambdabot>   <no location info>: parse error on input `\'
07:04:38 <kingping> > pl \ x -> x
07:04:39 <lambdabot>   <no location info>: parse error on input `\'
07:05:11 <kingping> @type (:)
07:05:12 <lambdabot> forall a. a -> [a] -> [a]
07:05:36 <kingping> @type flip (:)
07:05:37 <lambdabot> forall a. [a] -> a -> [a]
07:07:01 <XniX23> is it true that in haskell you dont use that much recursion?
07:07:18 <Lemmih> XniX23: recursion? What is that?
07:08:01 <sepp2k> XniX23: Mostly you use higher order functions, but that's true for most functional languages, I suppose.
07:09:08 <XniX23> sepp2k: thank you
07:09:13 <Axman6> recursion is functional programming's for loop
07:09:42 <Axman6> XniX23: so yes, we use a hell of a lot of recursion
07:09:43 * Lemmih thought XniX23 was trolling.
07:10:24 <XniX23> Axman6: i thought so too, but now watching the video lectures from haskell, he said you dont really use it much, so im kinda confused ^^
07:11:00 <Axman6> a lot of people prefer to use built in functions to hide the recursion
07:11:19 <XniX23> oh, so its a preference
07:11:33 <NEEDMOAR> XniX23: the recursion is there, just hided.
07:11:42 <XniX23> ty guys
07:11:54 <Twey> We use recursion, but common patterns of recursion are abstracted away into specific functions
07:12:08 <Twey> Such that 90% of the time, there's no need to handle it yourself
07:12:14 <NEEDMOAR> XniX23: maybe a look at the source of "foldr" will help you.
07:13:02 <Twey> If recursion is our ‘for’ loop, functions like ‘foldr’ are our ‘foreach’ loop (but much more powerful ☺)
07:14:28 <ManateeLazyCat> hamishmack: After you use AccelGroup in Leksah, do you found any bug in AccelGroup?
07:14:49 <ManateeLazyCat> hamishmack: If have, i need fix it before i push to main repo.
07:15:15 <hamishmack> ManateeLazyCat: We only used the type it seems
07:17:24 <ManateeLazyCat> hamishmack: Hmm, Looks new break your code after Axel hide Gtk.Types.
07:18:11 <hamishmack> ManateeLazyCat: It just means we can't add a type signature to one of our functions
07:18:13 <ManateeLazyCat> hamishmack: I guess perhaps have many Types need expose, not just AccelGroup.
07:18:42 <hamishmack> ManateeLazyCat: leksah compiles now
07:19:03 <ManateeLazyCat> hamishmack: ? Don't need AccelGroup?
07:19:29 <hamishmack> ManateeLazyCat: only for a type signature
07:20:13 <jmcarthur> XniX23: not to beat a dead horse, but there's a key feature about haskell that makes it a lot nicer to use higher order functions instead of recursion. haskell's laziness means that many recursive functions won't loop more times than necessary, so you can compose many recursive functions without each one running to completion before the next can be used
07:20:21 <ManateeLazyCat> hamishmack: If you need just need type signature, you can import Graphics.Gtk.UI.GtkInternals
07:20:32 <ManateeLazyCat> hamishmack: We hide Gtk.Types in it.
07:21:14 <jmcarthur> XniX23: and there's a lot of nice tricks that library authors can use to make composition of recursive functions optimize away apparently magically
07:22:38 <jmcarthur> most strict languages don't make it worth it to compose recursive higher order functions, so nobody does
07:23:29 <ManateeLazyCat> hamishmack: If you just use type signature, i will stop push AccelGroup, import Graphics.Gtk.UI.GtkInternals instead.
07:24:08 <ManateeLazyCat> hamishmack: Because need Axel spend more time to review when i push new patch.
07:24:20 <ManateeLazyCat> hamishmack: And Axel haven't so much time, please understand.
07:25:07 <kingping> > reverse $ (((flip (:)) . (:[]))) 3 5
07:25:08 <lambdabot>   [3,5]
07:25:30 <ManateeLazyCat> hamishmack: I will push AccelGroup patch if GtkInternals can't fix your problem.
07:25:34 <kingping> >  ((. return) . (:)) 3 5
07:25:35 <lambdabot>   [3,5]
07:25:43 <hamishmack> ManateeLazyCat: is Graphics.Gtk.UI.GtkInternals exposed?
07:26:32 <ManateeLazyCat> hamishmack: Yes, GtkInternals re-expert Gtk.Types,
07:27:27 <ManateeLazyCat> hamishmack: We don't recommand use this module directly, but for current situation, AccelGroup module is rollback, so GtkInternals can fix your problem.
07:28:57 <hamishmack> ManateeLazyCat: ah it is Graphics.UI.GtkInternals not Graphics.Gtk.UI.GtkInternals
07:29:32 <ManateeLazyCat> hamishmack: Oh, sorry, typo.
07:29:40 * ManateeLazyCat My head is not clean now.
07:29:48 * ManateeLazyCat Still need sleep.
07:30:11 <ManateeLazyCat> hamishmack: Okay now?
07:30:45 <hamishmack> ManateeLazyCat: yes thanks.  That worked
07:31:25 <ManateeLazyCat> hamishmack: Please use AccelGroup instead GtkInternals when we add AccelGroup in the future.
07:31:44 <ManateeLazyCat> hamishmack: GtkInternals just use internal for binding non-core packages.
07:32:12 <hamishmack> ManateeLazyCat:  We will just do without the type signature for now
07:32:16 <ManateeLazyCat> hamishmack: I won't push AccelGroup patch to main repo, because Axel haven't time.
07:32:42 <ManateeLazyCat> Axel is hard working on convert gstreamer.
07:32:58 <hamishmack> ManateeLazyCat: Thanks for your help and thanks for all your work on the new gtk2hs
07:33:13 <ManateeLazyCat> hamishmack: Any code that need Gtk.Types can fix by import GtkInternals.
07:33:27 <Eelis> it is just me or does Graphics.GD not provide a way to actually read pixels from its images..?
07:33:34 <hamishmack> ManateeLazyCat: jutaro and I are going to see if leksah still runs now :-)
07:33:47 <kingping> :t (==)
07:33:48 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:34:39 <ManateeLazyCat> hamishmack: Leksah is awesome project, thanks you too. :)
07:35:28 <ManateeLazyCat> hamishmack: Do you know? The reason i join in gtk2hs is i when i first run Leksah.
07:35:55 <ManateeLazyCat> hamishmack: I was think: "Wow, Haskell can use Gtk+ code build so beautiful project!"
07:37:29 <Eelis> what the hell.. gd 1000.0 had getPixel, but it's gone in 3000.0.0 and onwards
07:37:52 <hamishmack> ManateeLazyCat: BTW I was able to build gtk2hs on OSX and Windows (well the bits we use in Leksah anyway)
07:38:16 <hamishmack> ManateeLazyCat: also webkit on OSX :-)
07:39:02 <ManateeLazyCat> hamishmack: Can you run webkit demo in OSX?
07:39:49 <ManateeLazyCat> hamishmack: I really need work together with Leksah developers, in my project i use Gtk2hs code everywhere.
07:40:25 <ManateeLazyCat> hamishmack: If your Leksah support GtkPlug, i can embedded leksah in my project for IDE feature. :)
07:40:46 <Eelis> hm, and there's actually a repo on github which is just gd 3000 + getPixel. what's going on here..
07:42:52 <ManateeLazyCat> hamishmack: Joking....
07:44:35 <hamishmack> ManateeLazyCat: We do need Leksah to work on the Haskell desktop :-)
07:44:38 <Athas> How do I, in a Cabal Setup.hs, copy a file while retaining its permissions?
07:45:16 <ManateeLazyCat> hamishmack: I want to join Leksah before, but we have different aim, so i build my project
07:45:58 <dancor> Eelis: heh i made that repo
07:46:01 <ManateeLazyCat> hamishmack: My project simple is build "Haskell Application Platform" like GNOME or KDE.
07:46:18 <aavogt1> Athas: you can do it with something from the unix package (under System.Posix)
07:46:21 <ManateeLazyCat> hamishmack: Or i just hide it in a normal Gtk+ application. :)
07:46:46 <Eelis> dancor: i just noticed that gd 1000.0 is actually _newer_ on hackage than gd 3000.0. this is very confusing
07:47:28 <ManateeLazyCat> hamishmack: BTW, Leksah support "code complicate ui" similar Eclipse?
07:47:36 <dancor> Eelis: wow.
07:47:57 <danharaj> time paradox
07:48:00 <dancor> i guess he started over
07:48:13 <dancor> and forgot his earlier numbering would be wack?
07:48:26 <Eelis> "cabal install gd" gave me 3000.4.0..
07:48:44 <Eelis> people who use decreasing version numbers should be shot
07:49:05 <aavogt1> perhaps it's only a minor fix to an old version?
07:49:06 <dancor> well we should shoot him an email ;)
07:49:11 <ManateeLazyCat> hamishmack: I think that's need Tooltip support (new module in Gtk+ 2.18.3 instead old Tooltips module)
07:49:16 <hamishmack> ManateeLazyCat: Code completion is global, gut it displays the types and docs for you
07:49:28 <interferon> why can't compilers automate tail-recursive conversions like this one:  http://gist.github.com/387166
07:49:44 <ManateeLazyCat> hamishmack: Do you use Popup Window build Code completion UI?
07:49:47 <Eelis> dancor: i'll send and CC you, ok?
07:49:49 <aavogt1> as in, 3000 is incompatible, but there were some bugs in 1000 that bothered people who won't use the newer version
07:49:52 <dancor> Eelis: sounds good
07:49:54 <hamishmack> ManateeLazyCat: yes
07:50:45 <aavogt1> interferon: because they behave differently
07:50:56 <aavogt1> > foldr (:) [] [1..]
07:50:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:51:10 <aavogt1> > foldl (\x y -> y : x) [] [1..]
07:51:16 <lambdabot>   mueval: ExitFailure 1
07:51:30 <ManateeLazyCat> hamishmack: Similar this? http://farm3.static.flickr.com/2676/3821227364_e739332f63_o.png
07:51:30 <ManateeLazyCat>  
07:52:33 <hamishmack> ManateeLazyCat: without the title bar
07:52:46 <ManateeLazyCat> hamishmack: Yes, you can custom it.
07:53:28 <ManateeLazyCat> hamishmack: Tooltip in 2.18.3 will save much work instead "Popup Window"
07:53:34 <ManateeLazyCat> tooltipSetCustom :: (TooltipClass self, WidgetClass widget) => self -> Maybe widget -> IO ()
07:53:47 <hamishmack> ManateeLazyCat: we put a source view window on the right to display the types and comments
07:54:08 <interferon> aavogt1: it's just an optimization
07:55:14 <ManateeLazyCat> hamishmack: Leksah is good IDE, but i want clean layout like Emacs.
07:55:20 <ManateeLazyCat> hamishmack: Like this http://farm4.static.flickr.com/3483/3947340553_933df88a22_o.png
07:55:44 <ManateeLazyCat> hamishmack: BTW, do you fix split window problem?
07:56:11 <aavogt1> interferon: well optimizations aren't supposed to change the termination behavior of a program
07:56:32 <ManateeLazyCat> hamishmack: http://farm4.static.flickr.com/3483/3947340553_933df88a22_o.png  you will see, it support split any number window.
07:56:41 <aavogt1> but of course, for strict, associative functions it's ok to substitute foldl for foldr
07:56:42 <ManateeLazyCat> hamishmack: All window is different view for same buffer.
07:58:01 <ManateeLazyCat> hamishmack: I was check Leksah's source code before, looks just support split windows, but different window is not same *veiw* for buffers.
07:58:03 <interferon> aavogt1: can you elaborate?
07:59:24 <ManateeLazyCat> Have any tips that i don't need re-install all Cabal packages for different GHC version?
07:59:31 <ManateeLazyCat> Looks impossible.
08:00:43 <ManateeLazyCat> hamishmack: BTW, GtkSpinner is good new widget in Gtk+ 2.20, it can design to waiting action when you open new tab in notebook.
08:00:50 <jutaro> ManateeLazyCat: Right, I always had to reinstall gtk2hs, but not the other packages, why is it so?
08:01:29 <Saizan> interferon: btw, your length' won't use constant stack in haskell
08:01:49 <Saizan> (or maybe GHC is smart enough these days?)
08:02:20 <interferon> Saizan: why not?
08:02:35 <ManateeLazyCat> hamishmack: Because all gtk2hs packages is depend on upstream packages,
08:02:52 <ManateeLazyCat> hamishmack: Example, you need reinstall webkit package after you reinstall gtk package.
08:03:13 <ManateeLazyCat> hamishmack: If you touch glib package, you need re-install all gtk2hs packages.
08:03:17 <Saizan> interferon: because you're lazy in the accumulator n, so you build up a huge thunk of repeated increments which will get evaluated all at once at the end
08:03:25 <Saizan> interferon: requiring stack proportional to the number of increments
08:04:19 <Saizan> interferon: IOW you've to add a strictness annotation
08:04:28 <ManateeLazyCat> rollback to ghc-6.12.1
08:04:40 <ManateeLazyCat> ghc-6.12.2 have bug that break STM code.
08:05:14 <ManateeLazyCat> hamishmack: Sorry, is jutaro
08:05:33 <ManateeLazyCat> jutaro: Infact, gtk2hs is speical case for Cabal.
08:06:36 <ManateeLazyCat> jutaro: All gtk2hs packages is base on upstream packages, if any upstream re-install, you need re-install down-stream packages.
08:07:03 <ManateeLazyCat> jutaro: And lucky, you can use ./bootstrap.sh that i add in gtk2hs,
08:07:36 <ManateeLazyCat> jutaro: ./bootsrap.sh will rebuild everything for you, you don't need update package one by one.
08:07:43 <jutaro> ManateeLazyCat: Ok, don't really understand, but no problem for me.
08:08:22 <jutaro> ManateeLazyCat: just discovered the bootstrp shell before
08:08:35 <ManateeLazyCat> jutaro: I recommand you use 6.12.1 instead 6.12.2 if you use STM code.
08:08:37 <jutaro> script
08:08:46 <ManateeLazyCat> jutaro: I have test it, 6.12.2 have STM bug.
08:09:00 <jutaro> ManateeLazyCat: No STM with Leksah
08:09:09 <ManateeLazyCat> I haven't found why, haven't time do that. Just rollback to 6.12.1
08:09:29 <ManateeLazyCat> jutaro: Just for STM case.
08:09:53 <ManateeLazyCat> jutaro: Leksah is single-process?
08:10:00 <CalJohn_> > (head . sort) [1..]
08:10:04 <lambdabot>   mueval-core: Time limit exceeded
08:10:54 <jutaro> ManateeLazyCat: Client is single-process, and server is simple TCP mult-process , without shared data
08:11:34 <jutaro> ManateeLazyCat: Too many problems with multiple processes and gtk2hs/gtk.
08:12:04 <ManateeLazyCat> jutaro: I integrate GtkSocket/GtkPlug with DBus to bulid multi-processes gtk2hs framework.
08:12:13 <ManateeLazyCat> jutaro: And works fine with 6.12.1
08:13:33 <CalJohn_> I am confused about whether Haskell is "Lazy" in IO or not.  It seems that Data.ByteString.Lazy.Char8.readFile is lazy, how does that work?
08:13:44 <dmwit> Any gtk2hs experts lying around who want to help me trawl through the documentation?
08:13:49 <ManateeLazyCat> jutaro: Every tab in notebook is running in separate processes.
08:13:53 <mauke> CalJohn_: unsafeInterleaveIO
08:14:11 <jutaro> ManateeLazyCat: The future seems bright!
08:14:28 <pikhq> CalJohn_: unsafeInterleaveIO breaks normal semantics to get you lazy IO.
08:14:43 <pikhq> You should be at least a *bit* cautious when using it
08:14:44 <ManateeLazyCat> jutaro: I make every tab running in child processes with GtkPlug, then build GtkSocket in notebook for that GtkPlug.
08:14:45 <Philonous> CalJohn_: Lazy IO is an abomination, and I wouldn't say it "works"
08:14:49 <dmwit> I want to know how to find out what button the user pressed when I get a "click" event...
08:14:55 <fryguybob> jmcarthur: I know this is so 50 minutes ago, but an example of how other languages fail to make higher order function composition easy can be found in this *17* part series http://blogs.msdn.com/mattwar/pages/linq-links.aspx
08:14:59 <pikhq> As it is very much a hack...
08:15:01 <dmwit> (Which seems like a pretty basic thing, but I couldn't find it in the docs.)
08:15:06 <CalJohn_> mauke, pikhq: interesting, I didn't know that, thanks
08:15:11 <CalJohn_> Philonous: why do you say that?
08:15:21 <ManateeLazyCat> jutaro: After GtkPlug finish, i will use DBus send Plug id to server processes, then server process render GtkPlug in notebook.
08:15:22 <jutaro> ManateeLazyCat: Interesting indeed
08:15:30 <ManateeLazyCat> jutaro: Even they're in different processes.
08:15:33 <CalJohn_> because it's hard to predict?
08:15:59 <ManateeLazyCat> jutaro: I plan to release my project today, but i spend too much time on gtk2hs, maybe need May-15.
08:16:15 <Philonous> CalJohn_: It's a bad idea. You want to know what IO happens at what time. With lazy IO you get observably side effects in pure functions. One of the common problems is that you run out of file handles because you can't control when files are closed
08:16:18 <CalJohn_> hold on, so aside from usages of unsafeInterleaveIO, all haskell IO is strict?
08:16:28 <ManateeLazyCat> jutaro: If i understand right, Leksah server just for build different Leksah client.
08:16:34 <dmwit> CalJohn_: mu
08:16:43 <ManateeLazyCat> jutaro: And in every Leksah client, still is sing-processes.
08:16:45 <ManateeLazyCat> righ?
08:16:47 <CalJohn_> dmwit: ?
08:16:48 <ManateeLazyCat> right?
08:17:06 <jutaro> ManateeLazyCat: I will look to what you are publishing.
08:17:07 <ManateeLazyCat> jutaro: So when you open too many tabs in notebook, it's will slow Leksah client.
08:17:39 <ManateeLazyCat> jutaro: I will paste my screenshot to describe that.
08:17:46 <jutaro> ManateeLazyCat: Never had problems with speed regarding this.
08:17:48 <dmwit> CalJohn_: Values of type (IO a) are computed lazily, like everything in Haskell. Some (IO a) values represent computations that do some things strictly, but not all do.
08:17:59 <jmcarthur> fryguybob: lol
08:18:30 <ManateeLazyCat> jutaro: Before i bring DBus code in my project, it's singe-process, but concurrent haven't any help with speed of that.
08:18:43 <ManateeLazyCat> jutaro: Special when i split with many windows, and open many tabs.
08:18:45 <CalJohn_> dmwit: is this the distinction between evaluation and execution?
08:18:47 <pikhq> CalJohn_: The execution of an IO action is typically strict. The evaluation is still lazy, just like everything that's not seq.
08:18:57 <ManateeLazyCat> jutaro: Everytime i open new tab, speed is slower.
08:19:20 <ManateeLazyCat> jutaro: And single-processes have big problem, if any tab crash, all program will crash.
08:19:20 <Philonous> CalJohn_: More generally, changing the pure part of your haskell program can radically change it's IO semantics. That sounds like a really bad Idea to me and it already bite me once or twice.
08:19:31 <dmwit> CalJohn_: I suppose that's possible, though I don't know what definitions you're using for evaluation and execution. =)
08:19:50 <CalJohn_> dmwit: i'm just repeating the words I hear on this channel :)
08:20:00 <deech> Does anyone here develop Literate Haskell with emacs' haskell-mode?
08:20:01 <ManateeLazyCat> jutaro: Example, some code crash in C source code tab, will crash all program.
08:20:25 <dmwit> cargo-cult Haskell ;-)
08:20:39 <ManateeLazyCat> jutaro: After i bring DBus into my project, and make every tab in separate processes, much faster and stable.
08:21:15 <jutaro> ManateeLazyCat: I see it has some reason. Like Chrome browser compared to Firefox.
08:21:27 <dmwit> CalJohn_: Part of the problem is that a lot of people are too lazy to be precise about what they mean when they say "x is lazy".
08:21:30 <Philonous> CalJohn_: An IO action is like a perl script. By itself it does nothing. You can compose larger perl scripts from smaller ones, lazily. Evaluating an IO action means building the script, executing it means handling it to the perl executable and running it
08:21:47 <ManateeLazyCat> jutaro: Yes.
08:22:10 <Philonous> CalJohn_: Just that in the case of haskell the "perl executable" is the runtime system
08:22:11 <ManateeLazyCat> jutaro: But because you use GtkSocket/GtkPlug, you can embedded any Gtk+/KDE program in it, and not just browser. :)
08:22:23 <dmwit> CalJohn_: For example, (readFile "foo") has many lazy parts: the String "foo" is computed lazily as readFile needs it, then the IO action that represents reading the entire file "foo" is built lazily; when it comes time to actually read the file, bits of the file are read lazily as they're needed by readFile's consumer, etc.
08:22:50 <ManateeLazyCat> dmwit: Any problem with gtk2hs.
08:22:51 <ManateeLazyCat> ?
08:23:46 <dmwit> ManateeLazyCat: I wrote to the -users list, too; how do I find out what button a user pressed from a buttonPressEvent?
08:25:03 <jutaro> ManateeLazyCat: We want to add a plugin concept to leksah in the near future, so I will look into this.
08:26:06 <ManateeLazyCat> jutaro: For make GtkSocket/GtkPlug works with multi-processes need some secret trick
08:26:10 <CalJohn_> Philonous, dmwit: thanks for your explanations.
08:26:39 <ManateeLazyCat> jutaro: And i will write detail demo and documentation that explain how to make GtkSocket/GtkPlug works.
08:27:04 <ManateeLazyCat> jutaro: I plan to split some module from my project, then share with Leksah.
08:27:05 <jutaro> ManateeLazyCat: Even better
08:27:33 <jutaro> ManateeLazyCat: Even much better :)
08:27:37 <ManateeLazyCat> jutaro: Just remember, if you want build multi-processes with gtk2hs, don't use use forkProcess, use runProcess instead.
08:27:48 <ManateeLazyCat> jutaro: I have write this notes in ./demo/embedded
08:28:16 * hackagebot gsmenu 1.0 - A visual generic menu  http://hackage.haskell.org/package/gsmenu-1.0 (TroelsHenriksen)
08:28:18 <jutaro> ManateeLazyCat: I will think twice before starting this, beleive me.
08:28:49 <ManateeLazyCat> jutaro: Such as, code completion back-end, i think it's need share with leksah.
08:29:20 <ManateeLazyCat> jutaro: Because my project have different aim with leksah, but it's not mean we need do duplicate work with code compleio backe-end.
08:30:21 <ManateeLazyCat> jutaro: I have build some Haskell Code Completion in Emacs, use hoogle, but not smart enough.
08:33:07 <hamishmack> dmwit: eventButton :: EventM EButton MouseButton
08:33:27 <dmwit> Perfect!
08:33:53 <dmwit> I think I will be adding some "see also" links to the docs. =)
08:34:45 <dmwit> Sweet. This is so good.
08:34:56 * dmwit is now reading the docs for Graphics.UI.Gtk.Gdk.EventM with glee
08:35:02 <ManateeLazyCat> jutaro: Sorry, Emacs crash again.
08:35:14 <ManateeLazyCat> dmwit: Use EventM instead Event.
08:35:30 <dmwit> ManateeLazyCat: I am...
08:35:31 <ManateeLazyCat> dmwit: EventM give your clearer logic.
08:35:45 <jutaro> ManateeLazyCat: Leksah segfaults with new gtk2hs, so I have to look what happens.
08:36:05 <ManateeLazyCat> dmwit: EventM wrap functions that don't need return Bool always.
08:36:38 <dmwit> ManateeLazyCat: I asked exactly because I'm switching my code from Event to EventM. =)
08:37:41 <dmwit> buttonPressEvent :: Signal self (EventM EButton Bool)
08:38:13 <ManateeLazyCat> jutaro: I got segfaults with 6.12.2 STM code.
08:38:24 <ManateeLazyCat> jutaro: But works fine in 6.12.1
08:38:47 <ManateeLazyCat> jutaro: If you make sure Leksah's code is right, perhaps some APIs binding is wrong.
08:38:59 <ManateeLazyCat> jutaro: Example, access nullPtr in binding code.
08:39:30 <jutaro> ManateeLazyCat: Maybe I try 6.12.1, it segfaults with 6.12.2, when it tries to refresh the browser view.
08:40:05 <ManateeLazyCat> dmwit: The key EventM is, wrap your code in `tryEvent`, when you want stop Event handle, just call `stopEvent`.
08:40:28 <ManateeLazyCat> jutaro: Hmmm.... Perhaps 6.12.2 can't works with gtk2hs, and not just for STM code?
08:40:59 <ManateeLazyCat> jutaro: I doubt 6.12.2 change something that make gtk2hs binding's access nullPtr.
08:41:38 <jutaro> ManateeLazyCat: Will try 6.12.1 if it makes a difference.
08:41:48 <ManateeLazyCat> dmwit: In EventM (tryEvent code block), if you "IO function" can't compile pass. You need use `liftIO` wrap it.
08:42:17 <ManateeLazyCat> jutaro: In my project, same code, works in 6.12.1, segfault in 6.12.2
08:42:28 <dmwit> ManateeLazyCat: Oh, neat, I didn't know about tryEvent.
08:42:51 <ManateeLazyCat> jutaro: I have test old and new gtk2hs, 6.12.1 works, 6.12.2 break.
08:43:04 <ManateeLazyCat> jutaro: I think it's not fault of gtk2hs, should be some new bug in 6.12.2
08:43:32 <hamishmack> leksah works in OSX with new gtk2hs and 6.12.1
08:43:46 <ManateeLazyCat> dmwit: The design of EventM is: you can use `liftIO` wrap functions that have any return argument, and not just "IO Bool"
08:43:54 <hamishmack> so it does look like it might be related to 6.12.2
08:43:56 <jutaro> ManateeLazyCat: Ok, will try on 6.12.1 first. Hamish reports that new Leksah works for him on a Mac with 6.12.1.
08:43:58 <ManateeLazyCat> hamishmack: Have you test 6.12.2 ?
08:44:25 <hamishmack> I don't have it on OSX yet
08:44:34 <ManateeLazyCat> hamishmack: Have you change gtk2hs for compile in OSX?
08:45:04 <ManateeLazyCat> hamishmack: If that's okay, it's good news for Mac users.
08:45:07 <hamishmack> No it worked out of the box ! :-)
08:45:35 <ManateeLazyCat> hamishmack: Please test new gtk2hs with Windows.
08:46:09 <ManateeLazyCat> hamishmack: My CPU is don't support Virtualize, so i can't use KVM run Windows in it.
08:46:51 <monadic_kid> ManateeLazyCat: You don't need a CPU with support for virtualization for VMs
08:47:02 <ManateeLazyCat> monadic_kid: I know.
08:47:06 <pikhq> ManateeLazyCat: "My CPU doesn't support virtualization, so I can't use KVM to run Windows on it."
08:47:16 <ManateeLazyCat> monadic_kid: I have VirtualBox, but too slow.
08:47:34 <ManateeLazyCat> pikhq: Bad english.
08:47:44 <ManateeLazyCat> pikhq: I use English helper in Emacs IRC client. :)
08:47:55 <monadic_kid> what guest is the guest os?
08:48:09 <ManateeLazyCat> monadic_kid: Ubuntu Linux
08:48:22 <pikhq> ManateeLazyCat: Yeah, just trying to be helpful.
08:48:24 <ManateeLazyCat> monadic_kid: Ubuntu is host,
08:48:27 <hamishmack> Just ran leksah on windows with new gtk2hs and ghc 6.12.1
08:48:35 <hamishmack> Seems stable
08:48:55 <ManateeLazyCat> hamishmack: Did you change any gtk2hs code for compile it in Windows?
08:48:56 * pikhq shall go to do some kanji review
08:48:58 <jutaro> hamishmack: Sounds good!
08:49:10 <monadic_kid> when did you try vbox, you could try vmware too but it's a bit of hash making your own vm files with the free version
08:49:41 <fryguybob> I would like to try out gtk2hs on Windows, but I cannot get darcs to build...
08:49:50 <hamishmack> ManateeLazyCat: Worked out of the box
08:49:53 <ManateeLazyCat> jutaro: hamishmack I recommend we still use 6.12.1 with gtk2hs for stable, looks 6.12.2 code break gtk2hs, and not just STM code for me.
08:49:58 <hamishmack> ghc 6.12.1
08:50:13 <ManateeLazyCat> fryguybob: All packages in gtk2hs can install by Cabal.
08:50:35 <ManateeLazyCat> fryguybob: Don't need any stuff like "./configuration && make"
08:50:54 <ManateeLazyCat> fryguybob: Get code from darcs, and do "./bootstrap.sh"
08:51:26 <ManateeLazyCat> fryguybob: bootstrap.sh will build all gtk2hs packages for you.
08:51:41 <jutaro> fryguybob: Why not install a darcs binary for Windows, thats at least what I did.
08:52:27 <fryguybob> jutaro: where would I get the darcs binary?
08:52:31 <ManateeLazyCat> hamishmack: Can you help me build gtk2hs package on Windows when we release next version.
08:52:38 <hamishmack> fryguybob: You need gtk and probably msys http://www.gtk.org/download-windows.html
08:52:47 <ManateeLazyCat> Axel and I haven't Windows for test.
08:52:48 <jutaro> wiki.darcs.net/Binaries
08:52:55 <fax> > (`mod`4) . (nubBy(((>1) .) . gcd) [2..]
08:52:56 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:52:57 <fax> > (`mod`4) . (nubBy(((>1) .) . gcd) [2..])
08:53:00 <lambdabot>   [2,3,1,3,3,1,1,3,3,1,3,1,1,3,3,1,3,1,3,3,1,3,3,1,1,1,3,3,1,1,3,3,1,3,1,3,1,...
08:53:05 <fryguybob> jutaro: thanks
08:53:08 <ManateeLazyCat> hamishmack: And Peter looks haven't response long time.
08:53:25 <fax> @oies 3,1,3,3,1,1,3,3,1
08:53:25 <lambdabot>  a(n) = n-th prime modulo 4.
08:53:25 <lambdabot>  [2,3,1,3,3,1,1,3,3,1,3,1,1,3,3,1,3,1,3,3,1,3,3,1,1,1,3,3,1,1,3,3,1,3,1,3,1,3...
08:53:28 <ManateeLazyCat> fryguybob: http://code.haskell.org/gtk2hs
08:54:23 <ManateeLazyCat> hamishmack: Even better if you can help us build gtk2hs package on Mac.
08:54:35 <ManateeLazyCat> hamishmack: Axel and I just have Linux for test.
08:55:25 <hamishmack> ManateeLazyCat: Mac is complicated by the multiple ways to build gtk
08:55:44 <hamishmack> I have to go to bed
08:55:58 <hamishmack> It is 4am here
08:56:01 <ManateeLazyCat> hamishmack: Good night.
08:56:13 <hamishmack> goodnight
08:56:25 * ManateeLazyCat 23:55 in China.
08:57:09 <fax> @let square x = x * x
08:57:12 <lambdabot>  Defined.
08:57:32 <fax> > [ (square a + square b)`mod`4 | a <- [1..] , b <- [1..a] ]
08:57:33 <lambdabot>   [2,1,0,2,1,2,1,0,1,0,2,1,2,1,2,1,0,1,0,1,0,2,1,2,1,2,1,2,1,0,1,0,1,0,1,0,2,...
08:58:07 <fax> > [ (square a + square b + square c)`mod`8 | a <- [1..] , b <- [1..a] , c <- [1..b] ]
08:58:09 <lambdabot>   [3,6,1,4,3,6,1,3,6,3,2,5,0,2,5,2,1,4,1,0,3,6,1,3,6,3,2,5,2,1,3,6,3,2,3,6,1,...
08:58:14 <ManateeLazyCat> jutaro: Any hint about segfault with leksah?
08:58:37 <ManateeLazyCat> jutaro: Maybe it help us find why 6.12.2 break gtk2hs.
08:58:58 <jutaro> ManateeLazyCat: Just rebuild on gtk 6.12.1, to verify that it has to do with the compiler version.
09:00:15 <ManateeLazyCat> jutaro: I have test 6.12.2 with my project, i always got *random* segfaults error, and one times i got "X Windows: BadWindow",
09:01:24 <ManateeLazyCat> jutaro: I haven't any hint which code is break, perhaps not code of my project, perhaps break in gtk2hs code.
09:01:40 <jutaro> ManateeLazyCat: It take some time to build. But if it is really 6.12.2 it will even have a problem with a single threaded app. It happens when refreshing/setting the contents of a tree view.
09:01:53 <fryguybob> code.haskell.org isn't responding for me.
09:01:55 <ManateeLazyCat> jutaro: For detail, we will request dcoutts help use fix it.
09:02:12 <ManateeLazyCat> fryguybob: darcs get --partial http://code.haskell.org/gtk2hs/ --old
09:02:36 <ManateeLazyCat> fryguybob: code.haskell.org apache server always have problem with browser.
09:02:45 <jutaro>  fryguybob: Yes, have the same problem. It is between very slow and not responding at all.
09:02:51 <fryguybob> ok
09:02:53 <ManateeLazyCat> fryguybob: I think you can use darcs get code from code.haskell.org.
09:03:45 <ManateeLazyCat> jutaro: Looks, the error in my project is not point STM code, it's break gtk2hs code somehow.
09:04:47 <ManateeLazyCat> jutaro: Can you can build a minimum demo to reduce problem? Then we can send new bug to GHC team.
09:05:22 <jutaro> ManateeLazyCat: Oh, that may be extremely difficult, but I will look what I can do.
09:05:35 <danharaj> Is there a way to use Haskell as a scripting language called from another language?
09:08:06 <ManateeLazyCat> jutaro: Minimum demo is enough, i think dcoutts have enough knowledge to fix ghc bug.
09:08:11 <ManateeLazyCat> jutaro: Thanks. :)
09:08:28 * ManateeLazyCat Build a file-manger to test new GIO APIs.
09:09:04 * ManateeLazyCat I hope merge new GIO APIs to gtk2hs after test complete.
09:09:37 <ManateeLazyCat> Then gtk2hs user have cross-platform APIs to handle file, filepath. etc.
09:13:57 <monadic_kid> how can I stop template-haskell loading packages that are just getting in the way
09:15:04 <ManateeLazyCat> @tell dcoutts I have test darcs gtk2hs, always got "segment fault" with 6.12.2 somehow, and same code works fine with 6.12.1, looks 6.12.2 break something in gtk2hs, can you take a look? Thanks!
09:15:04 <lambdabot> Consider it noted.
09:24:21 <gwern> danharaj: you can call haskell from c, if thats what you mean
09:27:45 <monadic_kid> template haskell doesn't respect -hide :/
09:38:46 <augur> any anarchist haskelliers?
09:39:41 <Lemmih> Maybe.. why are you asking?
09:40:10 <augur> Lemmih: im just curious about their opinions ... on the State monad
09:40:11 <augur> 8D
09:40:35 <dmwit> ha
09:40:43 * Lemmih considers him self something of a Rothbardian anarcho-capitalist.
09:47:13 <danharaj> gwern: You can call compiled haskell code from C. Is there a haskell interpreter designed to be called from C?
09:48:43 <Polarina> danharaj, out of the blue, I'd suspect Hugs.
09:52:11 <bremner> danharaj: "hint" might help
09:52:43 <danharaj_> oh no a ghost :| how do I kill it?
09:53:01 <Polarina> danharaj_, /ns ghost <oldnick> <password>
09:53:33 <dantheman_> Hey all, just wondering if anyone has any experience of creating a stand alone windows installer for a haskell application? Are there any how-tos or tutorials out there for doing this?
09:53:35 <Polarina> :)
09:53:40 <danharaj> Thanks :)
09:53:50 <EtherealOne> Hey, if I have a type constructor (for instance Operand) with the data constructors "Plus" "Minus" "Divide" "Times", how do I change show so that it prints out + - / * instead? I tried show :: Operand -> String then Times = "*" but it didn't work.
09:53:54 <Polarina> danharaj, ghc is able to compile into a standalone executable.
09:54:17 <dmwit> EtherealOne: instance Show Operand where show Times = "*"
09:55:05 <bremner> hint meaning http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint
09:55:15 <EtherealOne> Thanks,
09:55:32 <xerox> EtherealOne: actually look into the other Show functions, if you implement some of those it turns out faster
09:55:35 <danharaj> all cool.
09:55:54 <gio123_> xerox: i need to copy some pages
09:56:01 <hellyeah> hey hey
09:56:13 <dantheman_> ok, so if I do that, can I just add all the .dlls to the same directory as the .exe, and give that to the end user (who won't have ghc installed).
09:56:21 <hellyeah> is there a way to write a sum function that doesnt crash at long lists?
09:56:26 <dantheman_> polarina
09:56:31 <hellyeah> I get a stack overflow when I try sum [1..1000000]
09:56:32 <Vitka> If I use listArray to construct large array of precomputed data, will I incur memory and CPU overhead during runtime or will it just allocate array like in C?
09:56:44 <Zao> @src sum
09:56:44 <lambdabot> sum = foldl (+) 0
09:56:50 <Zao> Try a stricter foldl.
09:56:53 <Philippa> dantheman_: "all the DLLs"?
09:57:43 <Polarina> dantheman_, yes, that should work.
09:57:44 <hellyeah> *Main> let asum = foldl (+) 0
09:57:45 <hellyeah> *Main> asum [1..1000000]
09:57:45 <hellyeah> *** Exception: stack overflow
09:57:45 <dantheman_> Phillips, Well my exe depends on at least a few dlls, but I'm not sure how to find out exactly what it depends on in order to give it to a user without ghc
09:57:49 <Zao> > foldl' (+) 0 [1..1000000]
09:57:50 <lambdabot>   500000500000
09:57:52 <Zao> > foldl (+) 0 [1..1000000]
09:57:53 <lambdabot>   *Exception: stack overflow
09:58:06 <Polarina> dantheman_, you can use ldd.
09:58:12 <hellyeah> I thought when using tail recurive functions, there wont be any stack overflow
09:58:19 <fax> hellyeah that's correct
09:58:24 <Zao> hellyeah: Your sum becomes a (0 + (1 + (2 + (3 + (4 ...)
09:58:32 <hellyeah> well but it dies
09:58:34 <hellyeah> *does
09:58:34 <fax> hellyeah ... this is something that applies to languages like Scheme
09:58:40 <Polarina> > foldr (+) 0 [1..1000000]
09:58:41 <lambdabot>   *Exception: stack overflow
09:58:42 <fax> hellyeah, in haskell you don't program that way
09:58:50 <hellyeah> hum
09:58:59 <hellyeah> I am reading realworldhaskell right now
09:58:59 <Zao> Your sum builds _massive_ thunks that when evaluated runs out of stack.
09:59:09 <hellyeah> mySum xs = helper 0 xs
09:59:09 <hellyeah>     where helper acc (x:xs) = helper (acc + x) xs
09:59:10 <hellyeah>           helper acc _      = acc
09:59:16 <Zao> More strictness smashes those thunks to values earlier.
09:59:19 <hellyeah> this one i supposed ro be tailrecurive (from book)
09:59:36 <Zao> Of course, optimizations may fuse stuff properly too.
09:59:37 <dantheman_> polarina, would that tell me everything I need yes? Should I just run that on my exe?
09:59:41 <Zao> What book?
10:00:05 <hellyeah> realworldhaskell
10:00:09 <hellyeah> http://book.realworldhaskell.org/read/
10:00:10 <hellyeah> but well
10:00:23 <hellyeah> I have no idea how to do it then
10:00:26 <hellyeah> sicne no loops...
10:00:39 <hellyeah> and using tail recursion t still crashes
10:00:43 <Polarina> dantheman_, yes. It should tell you the list of all shared objects used by the executable.
10:00:48 <dantheman_> Cool thanks!
10:00:53 <dantheman_> Exactly what I was looking for!
10:01:18 <Saizan> hellyeah: what you wrote is not really a tail call in a lazy context
10:01:21 <idnar> building the thunk up is tail recursive
10:01:29 <hellyeah> Saizan, the book tells me : it is
10:01:29 <idnar> but then you still blow the stack trying to evaluate it
10:01:29 <Saizan> hellyeah: you've to add a strictness annotation, with seq
10:01:36 <hellyeah> hum
10:01:39 <hellyeah> okay
10:01:45 <hellyeah> seems to be more complicated than I expected
10:01:59 <Saizan> hellyeah: "the book" probably explains the rest later?
10:02:07 <hellyeah> I dunno, probably
10:02:26 <hellyeah> well this suckls. the book tells me, it is tail recurisive and I just see how it crashes
10:02:28 <hellyeah> ok
10:02:35 <Saizan> i guess i should have said that it is tail recursive
10:02:49 <Saizan> but in a lazy context being tail recursive is not the end of the story
10:03:03 <hellyeah> okay
10:03:07 <mux> for some reason the glib setup of gtk2hs wants to add /usr/local/lib/glib-2.0/include to the include-dirs and that causes an error
10:03:08 <hellyeah> I guess I have to keep reading =/
10:03:13 <mux> anyone installed gtk2hs recently?
10:03:59 <danharaj> You basically have to ask the compiler to implement the tail recursion optimization.
10:04:09 <monadic_kid> is there away make cabal try and build a package that depends on package but the version is greater than the the version required?
10:04:42 <Saizan> danharaj: the tail call is already optimized
10:05:13 <Saizan> danharaj: it's just that you're efficiently computing an object a thunk that will be very inefficient to calculate :)
10:05:25 <Saizan> s/calculate/evaluate/
10:05:39 <Mirey> is there any easy way to do something like: data Name = Name opp Num Num | Name opp Num Name ???
10:05:55 <Saizan> Mirey: Num is not a type
10:06:02 <blalb> foldr (+) [1..1000000]
10:06:08 <Mirey> if Num was already declaed as a type
10:06:11 <Mirey> declared*
10:06:23 <mux> Mirey: also, your two alternatives have the same type constructor; that won't work
10:06:24 <Zao> blalb: Prefix with > if you want lambdabot to evaluate it.
10:06:31 <blalb> >foldr (+) [1..1000000]
10:06:36 <Zao> Preferably also a space :D
10:06:40 <blalb> heh.
10:06:43 <blalb> > foldr (+) [1..1000000]
10:06:44 <lambdabot>   No instance for (GHC.Num.Num [t])
10:06:44 <lambdabot>    arising from a use of `GHC.Num.+' at <...
10:06:53 <aavogt> monadic_kid: if there's a range, you can add additional constraints   with  --constraint='package >= 123', but that still requires that the original depends are satisfied
10:06:55 <donz> Hello there dumbasses, I am better than you
10:06:57 <Zao> @type foldr
10:06:58 <blalb> > foldr (+) 0 [1..1000000]
10:06:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:06:59 <lambdabot>   *Exception: stack overflow
10:07:16 <blalb> > foldl (+) 0 [1..1000000]
10:07:17 <lambdabot>   *Exception: stack overflow
10:07:32 <blalb> isn't one of the non-strict folds supposed to not accumulate thunks?
10:07:47 <Saizan> > foldl' (+) 0 [1..1000000]
10:07:48 <lambdabot>   500000500000
10:07:49 <Mirey> okay, cheers mux. Is there anyway around it?
10:08:06 <donz> I have incorporated the idea of thunks into my shitting routine.
10:08:07 <monadic_kid> aavogt: fclabels depends on monads-fd 0.0.* but i've got monads-fd-0.1.0.0 installed
10:08:10 <Mirey> nvm
10:08:14 <Mirey> i'm being silly i think
10:08:16 <Mirey> cheers :)
10:08:34 * mux kicks gtk2hs in the monads
10:09:27 <byorgey> blalb: it depends on what combining operation you use.
10:09:42 <uorygl> Here's a cute math problem.  I have four windows open: Terminal, Chrome, iTunes, and TextEdit.  All of these windows are mutually overlapping, except that Terminal and TextEdit do not overlap each other.
10:10:04 <Saizan> uorygl: solution: use xmonad
10:10:07 <uorygl> In addition, Terminal is semi-transparent.  How many visually distinct ways can these windows be arranged front-to-back?
10:10:09 <Zao> uorygl: Your core problem is that you're on OSX.
10:10:10 <mux> setup: glib-0.10.5: include-dirs: /usr/local/lib/glib-2.0/include doesn't
10:10:10 <mux> exist or isn't a directory (use --force to override)
10:10:13 <byorgey> blalb: for a strict combining operation like (+) both foldl and foldr will build up a big thunk.
10:10:15 <mux> does this ring a bell to anyone?
10:10:46 <mux> this include directory basically makes no sense too
10:11:11 <uorygl> I sort of like the novelty of OS X's window system.  Instead of having this row of buttons that you use to get to all your windows, you just click on them.
10:11:29 <uorygl> Of course, that was possible in Windows and Ubuntu too; OS X just makes the alternative impossible.  :P
10:11:52 <uorygl> But then it provides a new alternative, Expose, but I don't use that all that often.
10:12:16 <byorgey> uorygl: to a first-order approximation, the answer is: about a factor of O(n!) more than there should be
10:12:48 <blalb> > foldl' (+) 0 $ foldr (:) [] [1..1000000]
10:12:49 <lambdabot>   500000500000
10:13:00 <blalb> > foldl' (+) 0 $ foldl (:) [] [1..1000000]
10:13:01 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
10:13:02 <uorygl> Hmm, is O((n-1)!) the same as O(n!)?
10:13:22 <jon_of_arc> Yes
10:13:24 <jon_of_arc> Wait
10:13:36 <jon_of_arc> It might be, but the explanation for why it was I had was wrong
10:13:41 <blalb> > foldl' (+) 0 $ foldl (\x y -> [x] ++ [y]) 0  [1..1000000]
10:13:42 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
10:13:55 <dantheman_> mux are you doing that on windows or on linux?
10:13:55 <uorygl> I think it's not; the ratio between them approaches infinity.
10:14:07 <mux> dantheman_: on FreeBSD to be precise
10:14:08 <byorgey> uorygl: no, it is smaller by a factor of n.
10:14:21 <uorygl> Right.
10:14:31 <dantheman_> ah, I did it on windows the other day I'm afraid. Only took me about a month!
10:14:40 <byorgey> so my answer might not be exactly right =)
10:14:54 <dantheman_> are you using the cabalized versions?
10:14:57 <uorygl> > foldl' (+) 0 $ foldl (\x y -> x ++ [y]) 0  [1..1000000]
10:14:57 <lambdabot>   No instance for (GHC.Num.Num [b])
10:14:58 <lambdabot>    arising from the literal `0' at <inter...
10:15:05 <mux> dantheman_: yes, this is from darcs
10:15:19 <danharaj> (n-1)! is in O(n!)
10:15:30 <uorygl> > foldl' (+) 0 $ foldl (\x y -> x ++ [y]) [] [1..1000000]
10:15:32 <lambdabot>   *Exception: stack overflow
10:15:40 <blalb> > foldl' (+) 0 $ foldl (\x y -> x ++ [y]) [0]  [1..1000000]
10:15:42 <lambdabot>   *Exception: stack overflow
10:15:43 <uorygl> > foldl' (+) 0 $ foldl' (\x y -> x ++ [y]) [] [1..1000000]
10:15:44 <lambdabot>   *Exception: stack overflow
10:15:46 <blalb> > foldl' (+) 0 $ foldr (\x y -> x ++ [y]) [0]  [1..1000000]
10:15:47 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
10:16:03 <Saizan> > foldl' (+) 0 $ foldr (\x y -> y ++ [x]) [0]  [1..1000000]
10:16:04 <lambdabot>   *Exception: stack overflow
10:16:11 <uorygl> > foldl' (+) 0 $ foldr (:) [] [1000000..1]
10:16:11 <lambdabot>   0
10:16:21 <mux> gah, where in hell does it get that directory
10:16:28 <blalb> > foldl' (+) 0 $ foldr (flip  \x y -> x ++ [y]) [0]  [1..1000000]
10:16:30 <lambdabot>   <no location info>: parse error on input `\'
10:16:33 <danharaj> but n! is not O(n-1)!
10:16:43 <blalb> > foldl' (+) 0 $ foldr (flip  (\x y -> x ++ [y])) [0]  [1..1000000]
10:16:44 <byorgey> blalb: have you seen http://haskell.org/haskellwiki/Fold ?
10:16:44 <Saizan> > foldl' (+) 0 $ foldl (flip (:)) [] [1..1000000]
10:16:45 <lambdabot>   *Exception: stack overflow
10:16:47 <lambdabot>   500000500000
10:16:48 <mux> dcoutts: ping
10:17:06 <Saizan> mux: seen the .cabal file?
10:17:33 <blalb> hmm
10:17:46 <danharaj> > foldr' (+) 0 $ take 1000000 [1..1000000]
10:17:47 <lambdabot>   Not in scope: `foldr''
10:17:50 <imc> plop
10:17:51 <mux> Saizan: this was the first place I looked
10:17:59 <JIDFrep> OKAY, THIS CHANNEL IS UNDER INVESTIGATION FOR POSSIBLY SPREADING JEW HATE - JIDF REPRESENTATIVE HERE - http://en.wikipedia.org/wiki/Jewish_Internet_Defence_Force
10:18:13 <JIDFrep> Please disband the channel immediately
10:18:18 --- mode: ChanServ set +o Saizan
10:18:20 <Twey> Not again
10:18:22 --- mode: Saizan set +b *!*55c89673@gateway/web/freenode/x-rbjcsbkhixgomjeq
10:18:22 --- kick: JIDFrep was kicked by Saizan (JIDFrep)
10:18:27 --- mode: Saizan set -o Saizan
10:18:32 <Twey> Ta
10:18:37 <burp> lol
10:19:13 <danharaj> > foldl' (+) 0 $ take 1000000 [1..1000000]
10:19:15 <lambdabot>   500000500000
10:19:29 <danharaj> foldr' (+) 0 $ take 100000000 [1..100000000]
10:19:34 <danharaj> I AM NOT GOOD AT THIS
10:19:54 <danharaj> > foldr' (+) 0 $ take 100000000 [1..100000000]
10:19:55 <lambdabot>   Not in scope: `foldr''
10:20:12 <danharaj> ok I need to drink some tea. my brain is stupid.
10:20:18 <monadic_kid> looks like i'm forced to use transformers instead of mtl, since i'm using fclabels
10:20:31 <danharaj> > foldl' (+) 0 $ take 100000000 [1..100000000]
10:20:35 <lambdabot>   mueval-core: Time limit exceeded
10:20:47 <bos> @pl \k buf -> f buf >>= k
10:20:47 <lambdabot> flip ((>>=) . f)
10:21:03 <danharaj> Well at least it was not a stack overflow. So why is it not overflowing?
10:21:38 <danharaj> > foldl' (+) 0 [1..100000000]
10:21:42 <lambdabot>   mueval-core: Time limit exceeded
10:23:15 <Saizan> why should it?
10:23:44 <mux> oh well
10:24:15 * mux gives up and creates an empty temporary directory
10:31:04 <aavogt> monadic_kid: so if you can build fclabels with the newer monads-fd, then you should send a patch to change the depends to   monads-fd > 0.0.0 && < 0.2
10:31:31 <monadic_kid> aavogt: I couldn't get it working without headaches so I just downgrade transformers and monad-fd
10:31:32 <ddarius> danharaj: To answer you question from last night, every continuous functor is indeed an applicative functor.
10:31:34 <aavogt> you can certainly use fclabels with mtl, but then you miss out on that nice integration with State
10:32:03 <monadic_kid> aavogt: I mean couldn't even get cabal to try and build with newer versions
10:32:36 <aavogt> right, to do that, either get the dev repo,  or cabal unpack fclabels, edit the .cabal file, then cabal install
10:33:48 <monadic_kid> aavogt: yeah but it's cool i don't need the latest version
10:35:02 <Twey> :t id
10:35:04 <lambdabot> forall a. a -> a
10:35:07 <Twey> :t Control.Category.id
10:35:08 <lambdabot> forall (cat :: * -> * -> *) a. (Control.Category.Category cat) => cat a a
10:35:16 <fax> @instances Category
10:35:17 <lambdabot> Couldn't find class `Category'. Try @instances-importing
10:35:23 <fax> @instances-importing Control.Category Category
10:35:25 <lambdabot> (->), Kleisli m
10:35:32 <Twey> Cale: Why isn't \b's id the Category one, too?
10:37:31 <Saizan> (.) isn't the category one either, no?
10:37:51 <Twey> Wow, fclabels is cool
10:37:53 <Twey> :t (.)
10:37:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:37:57 <Twey> Oh, I thought it was
10:37:59 <bos> @pl \f -> b (fmap f .)
10:38:00 <lambdabot> b . (.) . fmap
10:38:04 <kmc> :t (Control.Category..)
10:38:05 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
10:38:12 <aavogt> then what hapened, twey?
10:38:20 <kmc> meow
10:38:30 <Twey> I was sure there was something in \b's default setup from Control.Category
10:38:36 <kmc> :t id
10:38:37 <lambdabot> forall a. a -> a
10:38:41 <bos> @pl \k buf -> k =<< f buf
10:38:41 <lambdabot> (. f) . (=<<)
10:38:42 <kmc> :t Control.Category.id
10:38:43 <ddarius> :t (>>>)
10:38:44 <lambdabot> forall (cat :: * -> * -> *) a. (Control.Category.Category cat) => cat a a
10:38:44 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
10:39:08 <aavogt> @vixen what do you think of /b?
10:39:09 <lambdabot> let's don't talk about that
10:41:58 <imc> mmm, i've a function like (a -> String)
10:42:36 <mux> no you don't!
10:42:39 <kmc> not many useful functions have that type
10:42:44 <imc> i would like that the resulting string of that function take into account "special characters" (i.e. don't print "result!\n\n" in ghci but (result! with two newlines))
10:42:55 <fax> just do putStr
10:42:56 <mux> :t const "foo"
10:42:57 <lambdabot> forall b. b -> [Char]
10:42:59 <imc> k
10:43:04 <mux> not useful though :-P
10:43:20 <ddarius> How is that not useful?
10:43:24 <kmc> imc, when you ask ghci to eval something that isn't an IO action, it implicitly calls "print" on the value.  instead you can explicitly call putStrLn
10:43:48 <imc> yep
10:44:05 <mux> ddarius: I think you perfectly understood what was meant here
10:44:09 <kmc> it's not to do with what's in the string
10:44:10 <ddarius> > fix show -- a classic
10:44:11 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
10:44:17 <imc> ghgh
10:44:18 <Mirey> right, is there anyway of doing: data Opp = Add | Sub; .... eval :: Opp -> Rational -> Rational -> Rational; eval Opp x y = x Opp y;  so that the "x opp y" is evaluated as whatver Opp is
10:44:28 <fax> x `opp` y
10:44:33 <kmc> i think the most useful function of type (a -> String) is (`seq` "")
10:44:42 <imc> kmc: the thing is that in my function i do something like ` (show a) ++ ":\n"
10:44:56 <mux> :t shows
10:44:57 <lambdabot> forall a. (Show a) => a -> String -> String
10:44:59 <imc> now the (show a) part is ok, but still got the newline issue
10:45:20 <mux> > shows 2 ":\n"
10:45:21 <lambdabot>   "2:\n"
10:45:32 <kmc> Mirey, dunno what you mean
10:45:41 <kmc> Mirey, you can write out: eval Add x y = x + y; eval Sub x y = x - y
10:45:51 <imc> yeah!
10:46:02 <imc> thank you
10:46:02 <kmc> Mirey, you can't write "eval Opp x y = ..." because Opp is not a data constructor; it's a type
10:46:12 <kmc> unless you separately make a data constructor
10:46:29 <Mirey> yeah, but also have Times and Divide, and 4 different possibilities, so that it becomes 16 lines if i do it for every occurence
10:46:40 <kmc> Mirey, 4 possibilities for what?
10:46:50 <danharaj> ddarius: good to know. I think that's why I was having trouble with the definition. It's hard for me to think of a functor I would like to use that was discontinuous.
10:47:23 <ddarius> Most applicative functors, most functors, are not continuous.
10:47:32 <mux> yay, I've got a working subset of gtk2hs installed.
10:47:33 <Mirey> kmc: http://pastebin.com/vcMBPM5c
10:47:38 <danharaj> I'd like some examples then.
10:47:50 <ddarius> danharaj: [()] is not isomorphic to ()
10:48:42 <Twey> [()] can be used to encode anything!
10:48:46 <kmc> Mirey, this line doesn't make sense: eval :: Opp -> Rational -> Rational -> Rational; eval Opp x y = x Opp y;
10:48:55 <Mirey> yeah, i know, i did that so i could paste it in irc
10:48:57 <Mirey> just ignore that line
10:48:59 <kmc> okay
10:49:07 <danharaj> ah right.
10:49:20 <danharaj> My intuition needs better training.
10:49:24 <Twey> Maybe with an infinitely huge definition, but hey
10:50:00 <ddarius> danharaj: In category theory, a functor is continuous if it preserves all limits, thus specifically terminal objects and products (if the exist in the source category.)
10:50:47 <kmc> Mirey, http://codepad.org/480LxtmT
10:50:52 <danharaj> Yeah. I totally didn't consider List.
10:50:59 <danharaj> And my imagination is sparse :p
10:52:15 <danharaj> For list, as an example, is the monoidal structure in the target category of lists still the product of lists?
10:52:22 <ddarius> danharaj: Almost every polynomial type (i.e. almost every algebraic data type) will fail to be continuous.
10:52:25 <Mirey> ahh, I see :) Should've thought about that myself. Well, thank you very much kmc :)
10:52:36 <kmc> Mirey, this is the classic eval/apply structure of an interpreter
10:52:36 <ddarius> danharaj: Yes.
10:52:48 <kmc> as in http://icampus.mit.edu/xTutor/public/images/content/5/sicp-cover.jpg
10:52:58 <kmc> :)
10:53:02 <danharaj> What is the natural transformation from (List a, List b) to List (a,b)?
10:53:06 <ddarius> danharaj: All Functors in Haskell are endofunctors.  The target category is the same as the source category.
10:53:35 <kmc> (all Functors but not all functors)
10:53:36 <danharaj> yeah, but not all objects in the category are in the image of the functor, so I really mean subcategory of lists.
10:53:50 <Mirey> haha :P
10:53:55 <Mirey> Well, now I know =]
10:53:58 <kmc> :)
10:54:30 <kmc> that's the cover of _Structure and Interpretation of Computer Programs_
10:54:38 <ddarius> danharaj: The product of lists is not a list, so your question wouldn't make sense if you restricted the target to its image.
10:54:39 <kmc> which is a fantastic book
10:54:51 <kmc> an intro CS text that teaches more than most CS students ever learn
10:55:06 <ddarius> danharaj: There are at least two as there are two Applicative instances for list.
10:55:34 <fax> Wizard Book
10:55:34 <danharaj> The subcategory generated by the image of List and all the structure of Hask. >_< I'll refine it until I get it right!
10:55:54 <danharaj> ddarius: That's interesting. I'll go look them u- ok I probably should be working on my paper
10:55:54 <ddarius> One is the \(xs,ys) -> [(x,y) | x <- xs, y <- ys] and then the other is uncurry zip.
10:56:47 <ddarius> The former corresponds to the Monad instance (it is liftM2 (,))
10:56:51 <Mirey> I started watching the MIT 1985ish lectures which teaches about that, and uses Lisp. I really liked it but then I got to busy to continue watching
10:56:55 <danharaj> Are all strict monoidal functors continuous, though? Because in that case the natural transformation has to be an identity
10:57:07 <ddarius> danharaj: Yes.
10:57:14 <dmwit> :t liftM2 (.)
10:57:15 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
10:57:22 <kmc> Mirey, yeah, me too.  reading the book might be a better return on time investment
10:57:33 <danharaj> I guess that's what I originally conceived as a monoidal functor. I see that lax ones are much more flexible.
10:57:42 <ddarius> danharaj: Er, sorry, no!
10:57:54 <danharaj> Ok now I'm interested.
10:58:07 <Mirey> Okay, I'll check it out. Thanks =]
10:58:09 <dmwit> :t liftM2 (.) :: ((d -> d) -> (p -> p)) -> ((d -> d) -> (p -> p)) -> ((d -> d) -> (p -> p))
10:58:10 <lambdabot> forall d p. ((d -> d) -> p -> p) -> ((d -> d) -> p -> p) -> (d -> d) -> p -> p
10:59:17 <danharaj> I should have said strict monoidal endofunctors with monoidal structure (,) ()
10:59:21 <ddarius> danharaj: Strict monoidal functors 1) don't have to be talking about product structure at all, 2) if the monoidal structure in each case -is- the cartesian one, they are still only guaranteed to preserve (on the nose) that product structure, not other limits like equalizers.
10:59:30 <danharaj> ah
10:59:57 <danharaj> ddarius: Yeah, that makes sense. Thanks for entertaining my questions.
11:00:26 <ddarius> Also, continuous functors don't give rise to strict monoidal functors (usually).  The give rise to strong monoidal functors.
11:01:35 <danharaj> That makes sense, I mean who wants more than natural isomorphism anyway?
11:02:05 <ddarius> I wonder if oplax monoidal functors are a useful abstraction for programming.
11:03:35 <danharaj> Is that a monoidal functor with the diagrams reversed or a comonoidal functor from comonoidal categories?
11:04:15 <ddarius> It's a functor that is like a lax monoidal functor only the connecting morphisms are reversed.
11:04:40 <danharaj> So what would the combinator's type be?
11:05:02 <ddarius> f (a,b) -> (f a, f b)
11:05:35 <ddarius> The f () -> () one would be trivial so it can be omitted, though it might make sense to apply this to Kleisli category.
11:06:00 <danharaj> I suppose the best way to find out is to try to put such a structure on a familiar functor.
11:07:00 <ddarius> danharaj: Every continuous functor will have such structure, so, e.g. (r ->) would be an instance.
11:08:23 <danharaj> Would list have the structure? List (a,b) -> (List a, List b) by projections?
11:11:26 <danharaj> I'm looking at the diagrams and it looks like they commute.
11:11:49 <ddarius> There are laws that need to be satisfied.
11:12:57 <ddarius> It might be that every Haskell Functor is an oplax monoidal functor between the product structure of Haskell.
11:13:33 <ddarius> via op fab = (fmap fst fab, fmap snd fab)
11:14:11 <danharaj> I think that is correct. I can't say I am reliable at checking that diagrams commute, but at least I am confident that associativity holds.
11:16:10 <danharaj> In general a monoidal product doesn't have projection functions right? But in this case we do.
11:16:22 <ddarius> danharaj: Correct.
11:16:53 <ddarius> For example, Either is a monoidal structure on Hask (if you fudge significantly).
11:17:28 <danharaj> Isn't Either isomorphic to coproduct?
11:17:32 <ddarius> Yes.
11:20:05 <danharaj> So there's a monoidal functor from hask with prods to hask with coprods?
11:20:25 <danharaj> Wait I'm not sure that made sense.
11:20:33 <danharaj> I NEED TO GO WRITE A PAPER STOP INTERESTING ME.
11:21:44 <danharaj> :p thanks
11:22:36 <benmachine> ddarius: is there a reason why parsec-3.1 wants base to be >= 3.0.3 rather than just >= 3?
11:23:16 <benmachine> I just compiled it on base-3.0.1.0 with ghc-6.8.2, although I got three warnings
11:23:32 <ddarius> benmachine: Perhaps not.
11:24:09 <benmachine> (warnings are of the form: Warning: The export item `module Text.Parsec.String' exports nothing)
11:24:21 <benmachine> (Text/Parsec.hs:17:6)
11:24:53 <benmachine> well, I can understand if you don't want to imply you support a version you can't test on :) but I just thought I'd mention that it seems to workforme
11:26:10 <benmachine> http://downforeveryoneorjustme.com/code.haskell.org :(
11:26:51 <Entroacceptor> and the trem server is down, too ;)
11:27:04 <benmachine> there's a trem server?
11:27:15 <ManateeLazyCat> benmachine: What's the real problem of code.haskell.org?
11:27:21 * siracusa wonders what modules are good for that don't export anything
11:27:26 <benmachine> ManateeLazyCat: no idea
11:27:37 <benmachine> Entroacceptor: oh, that one
11:27:47 <ManateeLazyCat> benmachine: If i'm Axel, i will move gtk2hs out from code.haskell.org
11:27:49 <mauke> siracusa: class instances?
11:27:58 <ManateeLazyCat> benmachine: code.haskell.org break my heart.
11:28:20 <siracusa> mauke: Ah, of course!
11:28:31 <triyo> I a haskell n00bie. How would I go about swapping 2 lines in a file. Do I use openTempFile, perform the line swap than rename file to original name?
11:29:19 <ManateeLazyCat> triyo: You just need swap two lines or want swap lines in editor?
11:29:52 <ManateeLazyCat> triyo: If you just want swap lines and don't need any interactive action, you can use some command-line tool do that.
11:30:30 <Saizan> ManateeLazyCat: he wants to write a program that does that
11:30:46 <ManateeLazyCat> triyo: If you want swap lines like in editor, you perhaps need gtk2hs, build a TextView window, and type Alt-Up or Alt-Down
11:30:53 <kmc> triyo, that's a reasonable plan
11:31:06 <triyo> just need swap two lines in a .txt file. Basically bump one line above the other.
11:31:12 <kmc> triyo, doing this sort of thing atomically and safely even in the presence of IO errors is fairly tricky
11:31:16 <ManateeLazyCat> triyo: You even don't write that feature, because Gtk+ library have do that.
11:31:21 <kmc> and is more of a system-specific concern than a language concern
11:31:31 <triyo> correct I want to write a IO to handle this in my haskell program
11:31:36 <Saizan> ManateeLazyCat: this has nothing to do with Gtk+ or GUIs
11:31:43 <ManateeLazyCat> triyo: Or if you want more advantage editor feature, such as swap line/region, i have gtk2hs code do that.
11:31:55 <lowasser> Has anybody here installed the LLVM backend?
11:32:06 <lowasser> I'm getting segfaults when building, and it makes me sad.
11:32:09 <ManateeLazyCat> Saizan: Yes, that's why i ask he whether want *interactive* action.
11:33:14 <ManateeLazyCat> triyo: If you don't want GUIs, i think you need do some regex search.
11:33:27 <triyo> Its a command line program by which user supplies a line number and that line gets bumped up by one.
11:33:34 <ManateeLazyCat> triyo: First, you need know where the current line.
11:33:53 <ManateeLazyCat> triyo: Then use regex search line start and line end.
11:33:59 <kmc> why would you use a regex?
11:34:01 <ManateeLazyCat> triyo: Get current line conten.
11:34:10 <ManateeLazyCat> kmc: regex is simpler.
11:34:15 <kmc> simpler than what?
11:34:23 <kmc> ManateeLazyCat, i think you don't understand triyo's problem
11:34:23 <triyo> ManateeLazyCat: yup I loaded the file into a list using hGetContents
11:34:23 <triyo> so I can use !! to get the exact line
11:35:02 <kmc> triyo, anyway, i liked your plan of reading, writing a temp file, and move if all goes well
11:35:08 <roconnor> god, why is everyone so hung up on non-terminating programs
11:35:20 <kmc> triyo, if you care about efficiency or handling large files, there's a couple more things to know
11:36:00 <Saizan> roconnor: related question, why is agda always finding my programs non-terminating lately?
11:36:17 <Saizan> maybe i should avoid all these mutual blocks
11:36:28 <roconnor> Saizan: because it only allows provably terminating programs for some definition of provably
11:36:43 <ManateeLazyCat> When time use unsafePerformIO is safe? I'm reading http://haskell.org/haskellwiki/IO_inside
11:37:04 <triyo> kmc: thanks. Efficiency maybe an issue do to large file sizes. What would your advice be...
11:37:46 <kmc> triyo, firstly, that swapping two elements of a list is inefficient
11:37:50 <kmc> since a list is a singly-linked list
11:38:10 <kmc> but you're only doing one swap
11:38:14 <kmc> so it might still be reasonable
11:38:35 <kmc> you'll still only do one pass through the list, if you code it right
11:38:44 <kmc> but coding it right probably means not using (!!) and length and such
11:38:46 <kmc> which will all walk the list
11:38:56 <roconnor> ManateeLazyCat: when the output of the function only depend on the inputs
11:39:01 <Saizan> you can use splitAt
11:39:05 <kmc> ah, yes
11:39:08 <kmc> secondly, that String is a time- and memory-inefficient representation for large files
11:39:24 <kmc> it's also a singly linked list (being just an alias for [Char]) and contains boxed lazy characters
11:39:31 <ManateeLazyCat> roconnor: Hmmm....
11:40:02 <kmc> you can use Data.ByteString.Char8 (if you know the input is ASCII) or the "text" package from hackage (for full Unicode)
11:40:08 <ManateeLazyCat> roconnor: That's it? Have any other notice?
11:40:37 <triyo> kmc: I was just gonna say that I came across the more efficient Data.ByteString.Char.
11:41:02 <roconnor> ManateeLazyCat: you should probably respect parametricity too
11:41:48 <Saizan> i guess you could use some OS primitive to copy the suffix of the file without routing it through your program? but that's probably overkill
11:41:52 <ManateeLazyCat> roconnor: I'm binding some GIO APIs, and many C function need transform pointer.
11:42:43 <ManateeLazyCat> roconnor: In Haskell code, safe bound is clean, but for FFI code, this bound looks not so clear.
11:44:38 <kmc> ManateeLazyCat, sometimes a C function is not pure, so you have to import with an IO type directly, but you wrap some marshalling code around and the result is pure
11:44:48 <kmc> that's one of the standard and least controversial uses of uPIO
11:44:55 <kmc> that's why it was introduced in the FFI standard
11:44:58 <kmc> RWH has a good example iirc
11:45:57 <kmc> if you have more details i can give more specific advice
11:46:36 <ManateeLazyCat> kmc: https://patch-tag.com/r/AndyStewart/gio-branch/snapshot/current/content/pretty/System/GIO/File/File.chs have many GIO functions, some use unsafePerformIO (by Peter), rest i never use unsafePerfromIO (because i don't know when time use it).
11:47:55 <ManateeLazyCat> kmc: Like above link. "fileFromPath :: FilePath -> File" use unsafePerfromIO, i have test it, works, but i don't know when time use unsafePerfromIO.
11:48:11 <kmc> you can use it if you can guarantee that the result of executing the IO action depends only on the function's arguments, and that executing the IO action has no observable side effect
11:48:15 <mreh> there's a big disclaimer that comes with Fruit
11:48:33 <kmc> generally things like allocating and freeing memory are considered okay, even though there's technically an observable effect on the state of the allocator
11:49:08 <kmc> but calling malloc and then returning that pointer would be bad, because the address of the pointer is not deterministic
11:49:25 <kmc> err i mean value of the pointer
11:49:28 <kmc> the address it represents
11:49:51 <triyo> I've got to run, thanks all for your help. My first impression of Haskell is that it is a breadth of fresh air. Very express, excellent type system. Its purity and resulting laziness is mind-blowing. (e.g. Writing my own IF construct requires no need for special forms of any sort.)
11:50:19 <mreh> \o/
11:50:32 <kmc> :)
11:50:40 <ManateeLazyCat> kmc: Example, in C function, it's return String pointer, when we binding gtk2hs code, we will use peek functions get String result then use `g_free` free String pointer before we return String result.
11:50:53 <ManateeLazyCat> kmc: So in this situation, this wrap is safe.
11:50:57 <kmc> ManateeLazyCat, seems okay.  the values in the String you return are deterministic
11:51:05 <ManateeLazyCat> kmc: Then we can use unsafePerformIO wrap it.
11:51:24 <kmc> i wish purity weren't mindblowing
11:51:34 <trofi> what's going on with code.haskell.org's http?
11:51:41 <kmc> i wish it were generally recognized that functions are pure and that things with effects ought not to be called functions
11:51:48 <ManateeLazyCat> trofi: Just down, always recently.
11:51:48 <fax> @oies regular polygons
11:51:49 <lambdabot>  Values of n for which a regular polygon with n sides cannot be constructed w...
11:51:49 <lambdabot>  [7,9,11,13,14,18,19,21,22,23,25,26,27,28,29,31,33,35,36,37,38,39,41,42,43,44...
11:52:15 <fax> > (\p -> nub $ map (\x -> (let y = zip x [1..] in nub . sort $ (liftM2 (\x y -> (snd x+snd y)`mod`p) y y) ++ [0])) (filter ((==(p-1)`div`2) . (count id)) . sequence . replicate p $ [True,False])) 18
11:52:16 <lambdabot>   Not in scope: `count'
11:52:44 <trofi> ManateeLazyCat: do you happen to know is there official date/time when it's planned to be up again?
11:52:58 <triyo> kmc: Haskell being very explicit about how it handless side-effects is the key for me. Its perfect :)
11:52:59 <ManateeLazyCat> trofi: No idea.
11:53:06 <trofi> *sigh*
11:53:27 <nomeata> Hi. I am having trouble using Haxml to extract a simple list of values from a simple XML file. It works with this line, but it does not look very idiomatic:
11:53:38 <ManateeLazyCat> kmc: Can you give me some example that binding is has *side-effect* ? Thanks.
11:53:40 <nomeata> let filter = map ((attributed "package" `x` attributed "architecture" `x` attributed "version" `x` extracted (concat . mapMaybe fst . textlabelled (txt `o` children)) ) keep) . (elm `o` children)
11:53:44 <kmc> ManateeLazyCat, ?
11:54:27 <kmc> ManateeLazyCat, plenty of C functions have side effects
11:54:32 <ManateeLazyCat> kmc: If we binding some C function, and when time use unsafePerformIO is unsafe?
11:54:59 <kmc> fwrite()
11:55:02 <kmc> writes to a file
11:55:10 <kmc> if we FFI import it, the result had better be an IO action
11:55:18 <ManateeLazyCat> kmc: Yes, many C functions use Pointer transform/return result.
11:55:52 <lowasser> I suppose it's too much to hope there's anyone here experienced with the guts of GHC?
11:56:07 <kmc> lowasser, just ask your question
11:56:11 <lowasser> ahh
11:56:20 <ManateeLazyCat> kmc: I think we should use "IO ()" wrap those function, such as writes to a file. :)
11:56:23 <lowasser> still trying to build GHC with LLVM, still getting segfaults in the build
11:56:25 <kmc> ManateeLazyCat, yeah
11:56:32 <lowasser> think something
11:56:38 <kmc> ManateeLazyCat, so using "unsafePerformIO" there to get just "()" would be quite wrong
11:56:48 <lowasser> 's wrong with ghc-stage2, because when I manually execute the commands with my good ghc, it doesn't segfauly
11:56:50 <lowasser> *segfault
11:56:54 <ManateeLazyCat> kmc: Yes, absolutely.
11:57:12 <kmc> lowasser, also, you can try #ghc too, though it's mostly dead
11:57:15 <lowasser> wondering if anybody has the esoteric knowledge for how to just make the build use my vanilla GHC
11:57:16 <lowasser> mkay
11:57:34 <kmc> i don't know anything more specific, sorry :/
11:57:36 <ManateeLazyCat> kmc: Because it's not return pointer, we event can't free it, and return pure result.
11:57:38 <lowasser> no worries
11:57:43 <kmc> ManateeLazyCat, i don't follow
11:57:55 <ManateeLazyCat> kmc: Ok, thanks for your help!
11:58:40 * ManateeLazyCat Reading http://haskell.org/haskellwiki/IO_inside for detail.
12:02:02 <ManateeLazyCat> "When time use unsafePerformIO for C binding?": the answer is "The return result of C function is deterministic?"
12:02:48 * ddarius highly suspects that none of the fileFrom* functions should use unsafePerformIO.
12:05:36 <ManateeLazyCat> ddarius: Those unsafePerformIO is written by origin author "Peter".
12:05:49 <ManateeLazyCat> ddarius: I was think about remove those unsafePerformIO.
12:06:19 <mreh> what AFRP gui toolkit do people use?
12:06:29 <ManateeLazyCat> mreh: gtk2hs
12:06:39 <ManateeLazyCat> http://code.haskell.org/gtk2hs
12:06:47 <mreh> isn't that all in the IO monad?
12:07:17 <ManateeLazyCat> ddarius: Because `takeGObject` just cast Ptr to IO result.
12:07:17 <ddarius> mreh: There aren't to many AFRP GUI toolkits.
12:07:38 <mreh> ddarius, fruit has a BIG disclaimer on it, I'm frightened
12:07:50 <ManateeLazyCat> mreh: IMO, gtk2hs is most mature GUI toolkit in Haskell.
12:08:19 <ddarius> ManateeLazyCat: gtk2hs isn't an AFRP based GUI toolkit though
12:08:31 <ManateeLazyCat> ddarius: What's AFRP?
12:08:40 <ddarius> mreh: None of the FRP approaches are particularly mature/proven.
12:08:45 <ManateeLazyCat> ddarius: Sorry, i haven't seen AFRP.
12:08:49 <mreh> arrowised funtional reactive programming
12:08:49 <ddarius> ManateeLazyCat: Arrowized Functional Reactive Programming.
12:09:21 <ManateeLazyCat> ddarius: Oh, looks just Fruit do that.
12:10:03 <mreh> aren't there any clever people working on it?
12:10:25 <ManateeLazyCat> For GUI toolkit developing, point is not how advantage of technology, is how many people will use it.
12:11:19 <ManateeLazyCat> Unfortunately, but it's truth.
12:11:25 <mreh> I think developing something like that is perfectly valid as a end in itself
12:11:54 <imc> uhmm... applying mapM  gives m [a], ok, gut how can i use that result with foldM ??
12:12:01 <imc> s/gut/but/
12:12:25 <Botje> do foo <- mapM ...; foldM ... foo
12:12:32 <Botje> or mapM ... >>= foldM ...
12:12:33 <ManateeLazyCat> mreh: Yes, i know you mean, but developers will drop if haven't many people use it.
12:13:13 <imc> as i tought, but i've still some issues, i'll look
12:13:14 <tensorpudding> @type mapM
12:13:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:13:40 <ManateeLazyCat> mreh: I think problem is not technology, it's time problem, do you want develop it even just few peoples use it?
12:14:05 <mreh> if I feel it's worth it, yes
12:14:11 <ManateeLazyCat> mreh: If we can bulid AFRP gui, yes, that's perfect.
12:15:27 <dolio> Why do you care whether it uses arrows?
12:15:52 * ManateeLazyCat I plan to remove all unsafePerformIO from GIO APIs, for safe always.
12:16:06 <imc> Botje: removing the type signature helps :D
12:16:17 <imc> now i check that it still does what it have to
12:16:45 <mreh> I think AFRP is kind of neat
12:16:49 <ManateeLazyCat> mreh: I support you if you want do that, that's worth do, but need long time. :)
12:17:03 <ManateeLazyCat> worth to do
12:17:13 <ddarius> ManateeLazyCat: That's probably not necessary.  For example, the functions which just extract fields from the File type may be safe if those fields are not mutable.
12:18:00 <ManateeLazyCat> ddarius: I still think this.
12:18:45 <ManateeLazyCat> ddarius: If function result is safe, yes, use unsafePerformIO is handy.
12:19:03 <ManateeLazyCat> ddarius: Special with file functions.
12:19:29 <imc> ok found the problem Botje
12:19:48 <ManateeLazyCat> ddarius: I think in https://patch-tag.com/r/AndyStewart/gio-branch/snapshot/current/content/pretty/System/GIO/File/File.chs
12:20:02 <ManateeLazyCat> ddarius: All `IO String` should use unsafePerformIO
12:20:18 <imc> my function was returning a function, i was doing `.. = do l <- list; \a -> \b -> foldM ...` instead of `= \a -> \b -> do ...`
12:20:21 <imc> ;D
12:20:22 <ManateeLazyCat> ddarius: Because we have use `g_free` free String pointer before we return String result.
12:20:51 * imc got a little boost of `enlightnemnent`
12:21:25 <ManateeLazyCat> ddarius: Yes, and if some functions just read filed from Type, it's should be use unsafePerformIO.
12:21:48 <ManateeLazyCat> ddarius: More suggestions for https://patch-tag.com/r/AndyStewart/gio-branch/snapshot/current/content/pretty/System/GIO/File/File.chs ?
12:23:32 <ManateeLazyCat> ddarius: I think unsafePerformIO for function "fileFrom*" should be okay.
12:23:50 <ManateeLazyCat> ddarius: Because takeGObject use `objectFinalizer`.
12:24:46 <ddarius> Why?  What if you use fileFromFilePath "foo", I delete "foo" and make a new "foo" and then you call fileFromFilePath "foo" again.  In Linux, this should be perfectly fine and result in two different and valid File objects.
12:26:01 <mreh> I think in essence the AFRP gui toolkit would just be a collection of structures for gluing together the signal functions that make up the objects in a GUI, and handles the input/output interface
12:27:54 <gwern> > 5000000000000 / 300000000
12:27:56 <lambdabot>   16666.666666666668
12:28:01 <mreh> does modularity usually come at a performance cost?
12:28:14 <ddarius> mreh: In general, it usually does.
12:28:20 <ManateeLazyCat> ddarius: I need ask detail in gtk2hs-devel list.....
12:28:21 <mreh> premature optimisation aside
12:28:27 <fax> > 5000000000000 / 30000000019 :: CReal
12:28:27 <gwern> mreh: prevents various optimizations thanks to separate module compilation
12:28:28 <lambdabot>   166.6666665611111111779629629206234568169385
12:28:30 <ManateeLazyCat> ddarius: Thanks for your suggestions.
12:28:32 <fax> wow
12:29:13 <gwern> mreh: that's why whole-program optimizers are considered higher performance
12:29:49 <gwern> mreh: someone even wrote a tool to combine multiple haskell source files into just one, because it led to performance boosts
12:30:02 <gwern> unfortunately it had a non-OSI license so I couldn't put it on hackage
12:30:21 <ManateeLazyCat> gwern: file-embed?
12:30:25 <winxordie> gwern: do you remember the name of that tool?
12:30:26 <mreh> gwern, like cat but cleverer :)
12:30:29 <gwern> winxordie: no
12:30:34 <ddarius> HAll-In-One
12:30:35 <winxordie> darn :(
12:30:40 <gwern> ManateeLazyCat: I'm fairly sure that's not the name
12:30:41 <ddarius> Made by Hal Daume III
12:30:48 <gwern> ddarius: that sounds more likely
12:30:52 <mreh> I suppose you need to eliminate lots of fully qualified names and junk
12:31:18 <gwern> mreh: I think it just added unique junk to every new identifier in a module
12:31:25 <gwern> mreh: so no collisions when you catted them together
12:31:38 <ManateeLazyCat> gwern: file-embed use TH insert other file in current one.
12:31:49 <gwern> http://www.cs.utah.edu/~hal/HAllInOne/index.html
12:31:57 <winxordie> it's only Haskell98 though...
12:31:57 <gwern> 'As you can see, each function f from module Mod is given the name q_Mod_f. Datatypes, etc., are given the name Q_Mod_F, to follow the capitalization rules of Haskell.
12:32:08 <mreh> that reminds me of how virus scanners work, 95% of executables containing obfuscation are viruses
12:32:22 <mreh> say scansafe
12:32:24 <gwern> impressive. cut nhc compiletimes by 2/3s
12:32:28 <ManateeLazyCat> mreh: So in your model, how to handle widget Signal?
12:32:32 <gwern> real    3m14.295s vs  real    1m11.380s
12:32:55 <mreh> ManateeLazyCat: you mean someone clicking on a widget for example?
12:33:10 <ManateeLazyCat> mreh: Yes, use callback?
12:33:29 <gwern> ManateeLazyCat: I don't think file-emebed could be used for the same thing as haskel-all-in-one
12:33:32 <mreh> ManateeLazyCat, you represent each widget as a AFRP signal function
12:33:46 <ManateeLazyCat> mreh: If you use callback, you need transform "reference variable" (such as MVar or TVar).
12:34:00 <mreh> type Widget = SF WidgetInput WidgetOutput
12:34:36 <gwern> it would be interesting to see whether haskell-all-in-one would help darcs performance
12:34:39 <ManateeLazyCat> mreh: I think Qt's "Signal and Slots" model is more flexible, unfortunately not support in Gtk+.
12:34:40 <gwern> probably not
12:34:43 <ManateeLazyCat> mreh: http://doc.trolltech.com/4.6/signalsandslots.html
12:35:05 <ManateeLazyCat> gwern: Interested it, reading http://www.cs.utah.edu/~hal/HAllInOne/index.html
12:35:20 <mreh> ManateeLazyCat: communicating between objects is easy
12:35:48 <ruperdupe> shows "Hello" " World!"
12:35:52 <ManateeLazyCat> mreh: Just interest AFRP how to handle signal.
12:36:27 <mreh> ManateeLazyCat, I wrote an asteroids clone in yampa, if you want to take a look
12:36:28 <ruperdupe> Can someone explain to me why this outputs ""Hello" World!" instead of just "Hello World!"?
12:36:42 <mreh> :t shows
12:36:43 <lambdabot> forall a. (Show a) => a -> String -> String
12:37:01 <ManateeLazyCat> mreh: Signal callback in gtk2hs is ugly, always need transform "reference variable" in it. (But it's works)m
12:38:23 <mreh> ManateeLazyCat, well with yampa you route the information using an identifier
12:38:58 <mreh> there's a function that maintains a collection of signal functions
12:38:58 <Twey> ruperdupe: shows calls show on the first argument, then appends the second
12:39:08 <Twey> > show "Hello"
12:39:09 <lambdabot>   "\"Hello\""
12:39:15 <mreh> and one argument is a function that does the routing
12:39:17 <Twey> > show "Hello" ++ " World!"
12:39:18 <lambdabot>   "\"Hello\" World!"
12:39:34 <kmc> ruperdupe, "show" for simple types turns a value into a Haskell literal for that value
12:39:44 <kmc> a haskell literal for a string is a quoted string with certain characters escaped
12:39:45 <ruperdupe> Twey: Ah I see, sorta makes sense now.
12:40:08 <kmc> > show "x"
12:40:08 <ManateeLazyCat> mreh: In your AFRP model, complete by Haskell?
12:40:09 <lambdabot>   "\"x\""
12:40:12 <kmc> > iterate show "x"
12:40:13 <lambdabot>   ["x","\"x\"","\"\\\"x\\\"\"","\"\\\"\\\\\\\"x\\\\\\\"\\\"\"","\"\\\"\\\\\\\...
12:40:18 <ManateeLazyCat> mreh: Haven't any C binding?
12:40:29 <mreh> ManateeLazyCat, purely haskell
12:40:43 <mreh> well it needs a backend to draw the widgets
12:40:44 <ManateeLazyCat> mreh: So how to handle pixel?
12:41:04 <ManateeLazyCat> mreh: Haskell looks slow do pixel work.
12:41:35 <ManateeLazyCat> mreh: So it's still need some C wrap.
12:41:38 <mreh> well, we can use a direct interface to the O/S
12:42:38 <ManateeLazyCat> mreh: Before do work for gtk2hs, i was think try to build some toolkit like Fruit.
12:42:40 <mreh> but that can be kept nice and separate, it just receives the ``WidgetOutput"s
12:43:38 <ManateeLazyCat> mreh: Question is, it's perhaps is problem if you haven't "middle layout* between OS and your toolkit.
12:44:02 <|EtherealOne|> Is there a function you can use to convert a string like "12.5" to a Rational type?
12:44:03 <mreh> I'm not sure that's a big problem
12:44:06 <ManateeLazyCat> mreh: Otherwise, your toolkit can't cross-platform like Gtk+ or Qt.
12:44:22 <kmc> > read "12.5" :: Rational
12:44:23 <lambdabot>   *Exception: Prelude.read: no parse
12:44:42 <kmc> > toRational (read "12.5" :: Double)
12:44:44 <lambdabot>   25 % 2
12:44:47 <mreh> has anyone read anything I've written and thought that's already been done?
12:44:53 <kmc> |EtherealOne|, ^^^ but it will only work for rationals that can be represented exactly by Doubles
12:45:26 <|EtherealOne|> Yeah, that is what I was thinking, meaning it would screw up on fractions like 7.3
12:45:42 <mreh> ManateeLazyCat, I don't understand how they work, but we could build it on top of a lower level GUI layer
12:45:43 <|EtherealOne|> toRational(read "7.3"::Double)
12:46:58 <ManateeLazyCat> mreh: The biggest problem for GUI toolkit is: "Is it cross-platform? Is it support many different back-end?"
12:47:15 <ManateeLazyCat> mreh: And have *huge* work need to do.
12:47:37 <mreh> ManateeLazyCat, in theory I suppose, but gtk2hs only supports gtk
12:48:04 <Twey> Well, GTK is already cross-platform.
12:48:10 <ManateeLazyCat> mreh: Gtk+ is support different back-ends. :)
12:48:44 <mreh> like X11 etc?
12:49:49 <ManateeLazyCat> mreh: It's will be perfect that build that purely Haskell toolkit, but I think it's not easy to handle low-detail between different OS, speical for closed-OS.
12:49:55 <ManateeLazyCat> mreh: Yes.
12:50:16 <mreh> well why not build it ontop of gtk?
12:50:29 <ManateeLazyCat> mreh: And GUI's workload not just many, it's *huge*.
12:51:01 <ManateeLazyCat> mreh: Oh, so you just mean build some advantage Haskell wrap base on gtk?
12:51:26 <mreh> if I understand you correctly, yes
12:51:49 <ruperdupe> |EtherealOne|: Use readFloat and then toRational on that.
12:52:29 <kmc> :t readFloat
12:52:30 <lambdabot> forall a. (RealFrac a) => String -> [(a, String)]
12:52:43 <ManateeLazyCat> mreh: So it's have any different with gtk2hs? You just got advanced Haskell wrap?
12:53:23 <mreh> ManateeLazyCat, yeah, I suppose, that's a good idea, I hadn't worked out all the details yet, it was just a germinal ideal
12:54:10 <ManateeLazyCat> mreh: If you want bulid purely Haskell Toolkit, you should do work like GTK+ do, and not base on GTK+
12:54:13 <kmc> wow, readFloat has a misleading name
12:54:20 <shapr> kmc: What does it do?
12:54:26 <ManateeLazyCat> mreh: Otherwise, you can't get any improve.
12:54:34 <kmc> ReadS any type in RealFrac
12:54:37 <ManateeLazyCat> mreh: And no sense, IMO.
12:54:38 <kmc> which includes things that aren't floating point
12:54:40 <kmc> such as Rational
12:54:59 <kmc> if you use toRational with it, the intermediate type willdefault to Double and you'll still lose precision
12:55:21 <ManateeLazyCat> mreh: Because you still inherit many ugly things from Gtk+.
12:55:43 <kmc> > let rr :: String -> Rational; rr x = case readFloat x of ((v,_):_) -> v in map rr ["12", "12.34", "7.3"]
12:55:44 <lambdabot>   [12 % 1,617 % 50,73 % 10]
12:55:58 <kmc> that should not lose precision
12:56:22 <ManateeLazyCat> mreh: I agree with you some point, but *huge* workload is big problem.
12:56:22 <kmc> |EtherealOne|, ^^^
12:57:03 <mreh> well, the whole point is to try and create a nice layer of abstraction there
12:58:06 <ManateeLazyCat> mreh: I just do some binding work for GTK+, i feeling need spend too much time on it, speical situation for complicated functions, and i think build new toolkit is harder than that.
12:58:39 <pokoko222> if you were to make a CAD program you already have bunch of libraries, will i be wrong if i say your calculus and linear algebra knowledge is not that important? i mean opengl has rotate, translate and so on commands... you dont have to deal with matrices yourself
12:59:13 <ManateeLazyCat> mreh: Yes, before you start any other thing, you need build abstract layout to handle platform detail.
12:59:34 <ManateeLazyCat> mreh: That's why GTK+ team bulid glib.
12:59:47 <jutaro> ManateeLazyCat: Tried to track down the segfault bug with 6.12 for the last hour, with no success at all.
12:59:49 <pokoko222> if you are in Nvidia such knowledge will matter, but for making CAD software? with so many libs out there? i am not saying not knowing what vector is, but not knowing in sense not being expert in...
12:59:58 <ManateeLazyCat> jutaro: Me too.
13:00:01 <jutaro> 6.12.2
13:00:11 <ManateeLazyCat> jutaro: I give up, i haven't so much to investigate it.
13:00:24 <jutaro> I have code I can comment out, and the bug will not happen
13:01:01 <jutaro> But when I don't comment it out, it doesn't crash in the code, but runs to the end.
13:01:27 <ManateeLazyCat> jutaro: Can you bulid minimum program to reduce?
13:01:58 <ManateeLazyCat> jutaro: Maybe report bug is better idea.
13:02:06 <jutaro> ManateeLazyCat: No, I have no idea what to do.
13:02:28 <ManateeLazyCat> jutaro: Looks 6.12.2 bug is not just break some functions.
13:02:56 <ManateeLazyCat> jutaro: I try use gdb track it, but my program is *huge* and use multi-processes/multi-thread.
13:03:01 <ManateeLazyCat> jutaro: So hard to track.
13:03:04 <monadic_kid> pokoko222: You need to know some maths, in the newer versionsof GL matrix operations have been depercated if I remember correctly because those operations are done on the CPU/sysmem and no on the GPU
13:03:11 <jutaro> ManateeLazyCat: It seems as if "something" happens that later gives a segfault.
13:03:25 <ManateeLazyCat> jutaro: But not impossible to track, just need much time, i haven't so much time.
13:03:31 <kmc> debugging graphics code is difficult and requires you to know what the hell is actually going on
13:04:22 <pokoko222> monadic_kid so you gotta work with matrices down there?
13:04:23 <ManateeLazyCat> kmc: Absolutely, speical with program that mix multi-thread and multi-processes.
13:05:21 <cocon> hi
13:05:31 <cocon> what does 'SYSTEM' mean in a retainer profile?
13:05:44 <monadic_kid> pokoko222: I highly doubt just knowing how to do transformations is enough to write a CAD app
13:05:48 <ManateeLazyCat> jutaro: Minimum program perhaps help, my program is too big, and segfault looks happened everywhere.
13:05:56 <mailk> what a helpful notification
13:05:57 <jutaro> But you see, I know it don't crash, when I comment xyz out. But when I put traces in, I see that it passes xyz, so it crashes later if I don't comment out. Maybe gdb or something like this would be a solution, but only example I have is complete leksah.
13:06:03 <kmc> pokoko222, what software have you written since you first came into #haskell?
13:06:08 <mailk> parse error
13:06:13 <pokoko222> kmc none i do college
13:06:43 <jutaro>  ManateeLazyCat: My program is probably even bigger, and i can't extract minimum example, as i have no idea at all, what it is.
13:06:45 <ManateeLazyCat> jutaro:  6.12.2 crash my program.
13:06:58 <pokoko222> kmc it is not like i am not interested in doing calclulus or linear algebra, i just asked, cause last time i did litle 3d  thing, i had lot of things done for me in opengl
13:07:19 <ManateeLazyCat> jutaro: Thanks for your effort, i have send this problem to list.
13:07:29 <kmc> why don't you just try to write a CAD program and see if you get stuck
13:07:36 <ManateeLazyCat> jutaro: Maybe dcoutts or ghc developer know how to fix it.
13:07:36 <kmc> and by "a CAD program" i mean any program whatsoever
13:07:50 <jutaro>  ManateeLazyCat: I stop for now. Bye
13:07:58 <ManateeLazyCat> jutaro: Bye.
13:08:05 <gwern> > 280 - 75
13:08:06 <lambdabot>   205
13:08:42 <monadic_kid> pokoko222: you're going to need to understand things like projection transformations, if you're not familliar with an orthographics perspective (something which CAD apps typically use)
13:09:08 <pokoko222> kmc nah i do college now and from time to time i sniff around cause eventually i will do litle graphics, since i use Maya before as artist
13:09:23 <pokoko222> monadic_kid yeah but that is basic stuff
13:09:37 <pokoko222> and you have orthogonal projections commands
13:09:49 <mailk> http://pastebin.com/mwEMKP6A
13:09:55 <mailk> anybody see anything wrong with that?
13:10:06 <mailk> oh shit
13:10:11 <mailk> fucking indentation
13:10:15 <kmc> mailk, can you tell us why you think it's wrong?
13:10:25 <monadic_kid> pokoko222: you know about coordinate system transformations? i think you're underestimating this quite a lot.
13:10:40 <mailk> i can see now :P
13:10:45 <mailk> my editor was being gay
13:10:56 <kmc> your editor is sexually attracted to other editors of the same gender?
13:10:58 <ManateeLazyCat> mailk: "function (x:y:z)" need indent.
13:11:12 <ManateeLazyCat> mailk: Use blank instead tab.
13:11:19 <mailk> yeah also my editor is showing tabs wrong i think
13:11:24 <pokoko222> monadic_kid linear algebra stuff yes, so my point was you need to know medium linear algebra, lot is done for you in opengl already
13:11:26 <kmc> mailk, don't use tabs at all
13:11:34 <kmc> pokoko222, what do you get out of asking us how hard X is or whether you need to know Y to do Z?
13:11:37 <kmc> you don't actually do any of it
13:11:53 <kmc> you seem to argue with whatever we say
13:11:54 <ManateeLazyCat> mailk: My suggestion is don't use tab always.
13:12:15 <mailk> data Expr = Expr Operation Expr Expr | Number Rational
13:12:15 <pokoko222> kmc well i think so and i search if someone disagrees since that was my last time experience with opengl, it makes more of a coder then a math guy you know
13:12:26 <mailk> how can i make it so that Number a
13:12:32 <kmc> pokoko222, are you somehow very more interested in meta-knowledge than knowledge?
13:12:35 <mailk> so a can be of any type from a certain class
13:12:36 <kmc> pokoko222, or is this just a game?
13:12:55 <aavogt> mailk: data Expr a = ...
13:12:58 <pokoko222> kmc i am oriented more math than coding now so :D, not a game dude, nice and simple question
13:13:13 <aavogt> then pass a where you would want that type from your certain class
13:13:35 <pokoko222> i got infected from some people here, math rules and coding sucks attitude ... that is why i asked this question, nevermind :)
13:13:36 <kmc> mailk, can you elaborate on what you want?
13:13:37 <monadic_kid> pokoko222: I think a lot is an overstatement. There is a lot invovled, collision detection. Having support for any kind of of curve and curve surfaces require a lot of maths
13:13:44 <kmc> is Number a type or a type class?
13:14:03 <mailk> type constructor?
13:14:27 <aavogt> Number is a type constructor
13:14:32 <aavogt> err data constructor
13:14:48 <aavogt> the idea is to make Expr a type constructor
13:15:09 <aavogt> so deal with     Num a => Expr a
13:15:21 <aavogt> if you only handle operations like + -
13:15:44 <pokoko222> monadic_kid well you went the extreme way, collision for any surface is math heavy yes... i remember once trying to write cloth solver in Maya, and i ended up reading crazy stuff i did not understand at the time, if i recall now it is calculus haha
13:16:31 <monadic_kid> pokoko222: if you don't have much programming experience (i.e. writing a number of finished applications) and lacking in the the maths. You most definately underestimating the scope of this, i would not suggest you do something like for a school project
13:16:53 <fax> lol
13:17:23 <pokoko222> monadic_kid yeah of course, just sniffing around for now
13:17:31 <ManateeLazyCat> gwern: Looks HAllInOne have big improve
13:17:42 <gwern> ManateeLazyCat: how % did it get you?
13:17:49 <kmc> @protontorpedo
13:17:50 <lambdabot> how does haskell compare to say java?
13:17:58 <kmc> @protontorpedo-
13:17:59 <lambdabot> can u build things fast in haskell?
13:19:26 <ManateeLazyCat> gwern: It's give a compare result for NHC.
13:19:40 <gwern> ManateeLazyCat: yes, I quoted that, but how does it do for real programs?
13:19:49 <jmcarthur> pokoko222: most of the linear algebra that opengl used to do for you is not deprecated, btw
13:19:57 <jmcarthur> *is now deprecated
13:20:09 <jmcarthur> i always screw up the key words like that
13:20:27 <gwern> 'you did not kill my father. prepare to die'
13:20:35 <ManateeLazyCat> gwern: I don't know. :)
13:20:42 <ManateeLazyCat> gwern: Just read it from you.
13:21:47 <ManateeLazyCat> gwern: Perhaps it make thing become complicated, example for -cpp or something.
13:22:03 <gwern> ManateeLazyCat: well, it's hard to do well
13:22:43 <ManateeLazyCat> gwern: Maybe it's a good tool for fix "cycle import" problem?
13:23:00 * hackagebot string-combinators 0.5 - Polymorphic functions to build and combine string-like values  http://hackage.haskell.org/package/string-combinators-0.5 (BasVanDijk)
13:23:01 <gwern> think the page says it breaks on that sometimes
13:23:02 * hackagebot dstring 0.3.0.2 - Difference strings  http://hackage.haskell.org/package/dstring-0.3.0.2 (BasVanDijk)
13:23:18 <ddarius> This sounds bad.
13:23:22 <mailk> what class includes rational
13:23:47 <kmc> mailk, what do you mean?
13:23:52 <xerox> ?hoogle Fractional
13:23:53 <lambdabot> Prelude class Num a => Fractional a
13:24:00 * hackagebot usb 0.3.1 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.3.1 (BasVanDijk)
13:24:01 <kmc> Rational is an instance of many classes
13:24:05 <xerox> agreed
13:24:07 <ManateeLazyCat> ddarius: If you think something wrong in https://patch-tag.com/r/AndyStewart/gio-branch/ can you send patch to me ? Thanks?
13:24:30 <ManateeLazyCat> ddarius: Still in test before push to gtk2hs main repo.
13:24:43 <ManateeLazyCat> ddarius: I have finish all necessary APIs for gio 2.24.0
13:25:00 <ManateeLazyCat> Thanks!
13:25:10 <gwern> http://downforeveryoneorjustme.com/code.haskell.org
13:25:40 <pokoko222> jmcarthur why did they do that?
13:25:47 <ManateeLazyCat> gwern: Maybe we need move project code to patch-tag.com?
13:25:54 <gwern> maybe...
13:26:01 * hackagebot regions 0.5 - Provides the region monad for safely opening and working with  scarce resources.  http://hackage.haskell.org/package/regions-0.5 (BasVanDijk)
13:26:03 * hackagebot regions-monadsfd 0.3.1.1 - Monads-fd instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-monadsfd-0.3.1.1 (BasVanDijk)
13:26:08 <jmcarthur> pokoko222: because you are now encouraged to use the programmable pipeline, so you have to reimplement that stuff anyway
13:26:23 <jmcarthur> pokoko222: it wasn't hardware accelerated anyway. might as well just tailor it to your needs
13:26:28 <ManateeLazyCat> gwern: Or make Cabal support patch-tag.com?
13:26:34 <gwern> ?
13:26:44 <pokoko222> jmcarthur oh so now you as programmer can control harware acceleration?
13:26:49 <ManateeLazyCat> gwern: Cabal have support patch-tag.com?
13:26:56 <pokoko222> instead of being done for you
13:26:56 <gwern> ManateeLazyCat: what would that even mean
13:27:01 * hackagebot regions-monadstf 0.3.1.1 - Monads-tf instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-monadstf-0.3.1.1 (BasVanDijk)
13:27:03 <jmcarthur> pokoko222: umm... you can write shaders that run on the gpu
13:27:08 <monadic_kid> pokoko222: You do vertex transformations in a vertex shader
13:27:27 <ManateeLazyCat> gwern: Where the cabal update list? Is not haskell.org?
13:27:34 <mailk> i want a make a datatype number
13:27:35 <gwern> ManateeLazyCat: this has nothing to do with cabal. this is darcs
13:27:44 <jmcarthur> pokoko222: it's not worth it to compute transformation matrices in a shader though. faster to just use CPU
13:27:46 <mailk> that will accept only (Num and Fractional)
13:28:01 * hackagebot usb-safe 0.6 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.6 (BasVanDijk)
13:28:04 * hackagebot explicit-iomodes 0.3 - File handles with explicit IOModes  http://hackage.haskell.org/package/explicit-iomodes-0.3 (BasVanDijk)
13:28:37 <monadic_kid> jmcarthur: Well either so you you most definately going to do some form vector/matrix maths on CPU/sysmem side not for non-rendering tasks
13:28:46 <kmc> mailk, what does it mean for a datatype to "accept" classes?
13:29:02 <mailk> data (Num a, Fractional a) => Number a = Number a
13:29:05 <mailk> somthing like this
13:29:08 <kmc> okay
13:29:17 <jmcarthur> monadic_kid: right
13:29:25 <sbpaul> uh...i implemented RSA in haskell
13:29:25 <kmc> mailk, so, does that not work for you?
13:29:26 <gwern> I wonder if I could tell darcs to go via ssh into c.h.o
13:29:29 <sbpaul> but it takes freakin forever
13:29:34 <sbpaul> i wondered if somebody might offer some improvements
13:29:44 <aavogt> gwern: yes you can
13:29:48 <sbpaul>  http://pastebin.archlinux.fr/385286
13:29:50 <ManateeLazyCat> gwern: Do you know what's wrong code.haskell.org, i found most time it's down.
13:29:53 <ulfdoz> yes, don't bruteforce the private key. :)
13:29:53 <kmc> sbpaul, sure, can you put your code on codepad.org or something?
13:29:54 <gwern> ManateeLazyCat: no idea
13:29:59 <sbpaul> ^
13:30:02 * hackagebot safer-file-handles 0.5 - Type-safe file handling  http://hackage.haskell.org/package/safer-file-handles-0.5 (BasVanDijk)
13:30:04 * hackagebot regional-pointers 0.1.0.2 - Regional memory pointers  http://hackage.haskell.org/package/regional-pointers-0.1.0.2 (BasVanDijk)
13:30:05 <kmc> mailk, also, Fractional implies Num
13:30:06 <gwern> aavogt: I know, but i can never remember the pull syntax for ssh
13:30:07 <sbpaul> you want it on hpaste?
13:30:09 <aavogt> just leave off the http://, and then the : stuff
13:30:13 <kmc> so the context gets reduced to just (Fractional a) =>
13:30:33 <aavogt>  darcs pull/get code.haskell.org:/srv/code/projectName
13:30:42 <sbpaul> kmc can you work off of that link?
13:30:55 <kmc> sbpaul, ah, i missed it sorry
13:30:59 <gwern> aavogt: ssh: Could not resolve hostname code.haskell.org:/srv/code/xmonad: Name or service not known
13:31:00 <sbpaul>  http://pastebin.archlinux.fr/385286
13:31:18 <sbpaul> i don't really know haskell so i'm sure it sucks
13:31:24 <gwern> wait, I don't need the user name
13:31:27 <sbpaul> but it compiles ;)
13:31:35 <aavogt> gwern: well it can't hurt
13:31:39 <gwern> ah, there we go! darcs sned is now working
13:32:14 <kmc> sbpaul, not a performance issue, but why do you have "let primes = producePrimes"?
13:32:17 <kmc> just wanted a shorter name?
13:32:27 <sbpaul> to make sure it doesn't execute it twice
13:32:35 <mailk> kmc i want to something like this too data Expr = Expr Operation Expr Expr | Number
13:32:40 <aavogt> cse
13:32:42 <kmc> sbpaul, it doesn't change that behavior
13:32:43 <sbpaul> i wasn't sure how that worked
13:32:46 <sbpaul> ok
13:32:58 <kmc> i would rename "producePrimes" to "primes"
13:33:21 <kmc> it's not a function or anything
13:33:22 <sbpaul> done
13:33:35 <kmc> sbpaul, anyway, did you profile the code?
13:33:42 <sbpaul> i have no idea how to do that
13:33:48 <kmc> there's a chapter in RWH about it
13:33:49 <kmc> @where RWH
13:33:50 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:34:11 <kmc> sbpaul, also, i'd add type signatures to every top-level binding
13:34:22 <sbpaul> in the main function?
13:34:22 <kmc> this improves readability and could affect performance, if you choose a more specific type
13:34:27 <kmc> sbpaul, ?
13:34:34 <sbpaul> 'top-level' = ?
13:34:35 <kmc> no i mean at the top level of your file
13:34:41 <kmc> coprime, totient, findd, etc.
13:34:43 <kmc> don't have signatures
13:34:49 <sbpaul> yeah
13:35:01 <kmc> sbpaul, also, how are you running the program?
13:35:03 <aavogt> "This server is run by a mysterious group of Haskell hackers who do not wish to be known as a Cabal"
13:35:08 <kmc> if you need performance you should compile with ghc -O2
13:35:08 <sbpaul> ./produceKeys
13:35:11 <ruperdupe> mailk: data Expr a = Number a | Add (Expr a) (Expr a) | …
13:35:23 <sbpaul> ic
13:35:36 <kmc> for optimizations
13:35:50 <sbpaul> looking at the code itself...is anything there computationally expensive?
13:36:04 <kmc> anyway RWH is a great book, free online, and has some stuff on performance tuning
13:36:09 <kmc> sbpaul, that's what the profiler will tell you
13:36:25 <kmc> you say your primality test is brute force... maybe that's the problem?
13:36:34 <gwern> get a smarter primality checker?
13:36:36 <kmc> but we won't know without profiling
13:36:38 <gwern> there are several on the wiki
13:36:39 <sbpaul> what's the fastest sieve for primes that big
13:36:51 <kmc> sbpaul, http://book.realworldhaskell.org/read/profiling-and-optimization.html
13:36:59 <sbpaul> i can't profile it if it won't terminate, can i?
13:37:06 <kmc> oh it doesn't terminate?
13:37:10 <sbpaul> it hasn't yet
13:37:11 <kmc> i thought you said it was just slow
13:37:12 <kmc> okay
13:37:36 <sbpaul> it probably is the sieve
13:37:49 <kmc> sbpaul, you can indeed profile a program which was killed with ^C
13:37:59 <sbpaul> ho wso
13:38:19 <kmc> it still generates the .prof file even if killed that way
13:38:57 <jmcarthur> i think normally for large primes you just try some candidates until you get a prime number. i think there are fairly fast primality tests if you google for it
13:40:44 <sbpaul> i don't see a .prof file
13:40:50 <kmc> sbpaul, i got one
13:40:55 <kmc> did you follow the instructions in RWH?
13:41:01 <sbpaul> vaguely
13:41:19 <kmc> ghc -O2 --make -prof -auto-all -caf-all -fforce-recomp foo.hs
13:41:25 <kmc> ./foo +RTS -p
13:41:45 <kmc> sbpaul, it seems to spend most of its time on "coprime"
13:41:54 <sbpaul> o_o
13:41:59 <sbpaul> look at coprime
13:42:05 <sbpaul> coprime a b = gcd a b == 1
13:42:13 <kmc> so it's spending most of its time computing gcd
13:42:16 <sbpaul> ah yes
13:42:24 <jmcarthur> sbpaul: http://en.wikipedia.org/wiki/Primality_test
13:42:32 <sbpaul> that shouldn't take that long
13:42:40 <kmc> yeah
13:42:57 <sbpaul> it's just doing a few modulos until it gets it
13:42:58 <sbpaul> isn't it?
13:43:30 <kmc> you'd have to look at how the library function gcd is implemented
13:43:51 <ddarius> @src gcd
13:43:51 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
13:43:51 <lambdabot> gcd x y = gcd' (abs x) (abs y)
13:43:51 <lambdabot>    where gcd' a 0  =  a
13:43:51 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
13:43:58 <kmc> don't trust @src
13:44:08 <sbpaul> why not
13:44:16 <kmc> because it's reading from its own database
13:44:26 <kmc> which is not necessarily the code your particular Haskell implementation uses
13:44:41 <kmc> it often has simple or "official" implementations, e.g. from the Report
13:44:51 <sbpaul> > 352 `rem` 352
13:44:52 <lambdabot>   0
13:44:53 <sbpaul> > 352 `rem` 351
13:44:53 <kmc> furthermore other things like SPECIALIZE pragmas could matter a lot here
13:44:54 <lambdabot>   1
13:45:02 <sbpaul> mmn...
13:45:06 <sbpaul> > 35235235232 `rem` 35252352351
13:45:08 <lambdabot>   35235235232
13:45:14 <sbpaul> hm....
13:45:21 <sbpaul> > 35235235232 `rem` 3525235235133
13:45:22 <lambdabot>   35235235232
13:45:30 <sbpaul> ok....
13:45:41 <kmc> sbpaul, it's computing totient 2007160634827
13:45:42 <kmc> right?
13:46:08 <sbpaul> mmn
13:46:12 <sbpaul> depending on what random number you get
13:46:12 <sbpaul> yes
13:46:30 <kmc> sbpaul, it's deterministic.  you baked the rng seed in
13:46:40 <sbpaul> >:O
13:46:47 <sbpaul> stupid haskell random numbers
13:47:01 <Ferdirand> isn't totient p*q just (p-1)(q-1) in this case ?
13:47:08 <sbpaul> yes, it is
13:47:17 <sbpaul> should i substitute that
13:47:19 <sbpaul> yes
13:47:23 <kmc> sbpaul, you have no actions in a nondeterministic monad other than putStrLn
13:47:29 <kmc> sbpaul, so clearly the rng is deterministic
13:47:30 <mailk> how do i find the type of the output of a function
13:47:40 <kmc> mailk, find out how? ghci will tell you with :t
13:47:56 <mailk> it tells me the type of parameter
13:48:07 <mailk> :t calc "4 2 3 + *"
13:48:07 <mailk> calc "4 2 3 + *" :: String
13:48:08 <lambdabot> Not in scope: `calc'
13:48:13 <kmc> :t show
13:48:14 <lambdabot> forall a. (Show a) => a -> String
13:48:19 <kmc> mailk, the return type is "String"
13:48:25 <kmc> the thing after the last ->
13:48:38 <mailk> oh yeah
13:49:11 <kmc> sbpaul, so it computes (gcd 2007160634827 1), (gcd  2007160634827 1), etc.
13:49:17 <kmc> on my machine it can do about 100,000 / second
13:49:22 <Ferdirand> findd you can also implement using the extended euclid algorithm, iirc
13:49:41 <jmcarthur> > gcd 2007160634827 1
13:49:41 <kmc> meaning it will finish in about 2/3 of a year
13:49:42 <lambdabot>   1
13:49:53 <sbpaul> mhm
13:50:02 <sbpaul> so use smaller keys huh
13:50:11 <jmcarthur> use a faster primality test
13:50:31 <kmc> use a faster totient function
13:50:46 <danharaj> use a faster frame of reference
13:50:48 <sbpaul> well i already substituted out totient n for (p-1)(q-1)
13:50:55 <kmc> sbpaul, did you also want suggestions on writing simpler / cleaner / better code
13:50:59 <kmc> in addition to performance?
13:51:00 <sbpaul> sure, why not
13:51:05 <kmc> okay
13:51:09 <kmc> well i already mentioned type sigs
13:51:26 <kmc> and i already mentioned that "let a = b", where a and b are just names, does not influence evaluation behavior
13:51:36 <sbpaul> yeah i know
13:52:09 <jmcarthur> well, it introduces sharing
13:52:24 <kmc> b is already a single graph node
13:52:33 <jmcarthur> oh, i missed the detail
13:52:41 <kmc> you have let primes = producePrimes; n = (\[x,y]->x*y) primes.  i would write let [x,y] = producePrimes; n = x*y
13:52:55 <kmc> or let n = case producePrimes of [x,y] -> x*y
13:53:04 <kmc> beware this introduces a runtime exception if producePrimes is not a two-elem list
13:53:07 <kmc> as does your original code
13:53:14 <sbpaul> can i have nested let's?
13:53:16 <kmc> in this case you "take 2" so it's fine
13:53:27 <kmc> sbpaul, yes.  "let ... in ..." is an expression
13:53:30 <jmcarthur> why not just product?
13:53:36 <kmc> oh that too heh
13:53:38 <sbpaul> > product [1,2]
13:53:39 <lambdabot>   2
13:53:40 <kmc> but maybe you want to check that there's two
13:53:52 * sbpaul sighs
13:53:54 <kmc> sbpaul, so you can use "let" either in the bindings or in the body of another "let"
13:53:55 <sbpaul> there is two
13:53:59 <benmachine> you want to check that take 2 didn't accidentally take 3
13:54:06 <sbpaul> there are two
13:54:06 <jmcarthur> heh
13:54:12 <kmc> sbpaul, you use "head $ randomRs ...".  why not just "randomR"?
13:54:36 <benmachine> :t randomR
13:54:37 <kmc> sbpaul, we both know there are two elements, but it's not checked at compile time
13:54:37 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:54:39 <sbpaul> didn't know it was an option ;)
13:54:44 <jmcarthur> sbpaul: btw, check out hlint if you haven't already
13:54:56 <kmc> when possible we like to encode things like that at compile time
13:54:59 <kmc> i don't see an easy way here though
13:55:04 <benmachine> fst $ randomR ... presumably
13:55:35 <kmc> sbpaul, also, there's really no point to using randomR here.  you hardcode a seed and randomR returns a deterministic value based on that seed.  might as well hardcode that value
13:55:39 <kmc> perhaps what you want is:
13:55:43 <sbpaul> i don't want to hardcode a seed
13:55:52 <sbpaul> i just want one [p,q] per evaluation of the program
13:56:15 <kmc> do { e <- randomRIO (1, totient n); let .... stuff .... ; putStrLn .... }
13:56:15 <jmcarthur> getStdGen
13:56:30 <kmc> randomRIO is the simplest solution
13:56:31 <sbpaul> where does that go
13:56:41 <jmcarthur> yeah or randomRIO
13:56:43 <sbpaul> where the e is now?
13:56:43 <kmc> sbpaul, i'm proposing a new structure for "main"
13:56:56 <sbpaul> can you update it on the pastebin
13:56:57 <kmc> right now "main" has the form "let ... in ..."
13:57:09 <sbpaul> oic
13:58:00 <kmc> also you use "head" and "last" later
13:58:05 <kmc> if you have "let [x,y] = primes"
13:58:09 <kmc> then you can just call them x and y
13:58:17 <kmc> generally head and last should be avoided in favor of pattern matching
13:59:33 <kolmodin> Igloo: seems c.h.o is slow/down again
13:59:49 <sbpaul> http://www.haskell.org/haskellwiki/Prime_numbers#Miller-Rabin_Primality_Test
14:00:04 <sbpaul> i don't understand why millerRabinPrimality has two arguments
14:00:38 <sbpaul> kmc: you said the gcd function is taking up most of the time?
14:00:43 <kmc> sbpaul, that's what the profiler says
14:03:55 <sbpaul> well it spits out some keys
14:03:57 <sbpaul> let's try em...
14:04:59 <kmc> bbl
14:10:15 <tensorpudding> miller-rabin has two arguments, because one of them is the number that you want, and the other is an integer between 2 and that number which you're testing
14:10:38 <sbpaul> oh ok O:)
14:10:40 <tensorpudding> it's probabilistic, the full algorithm would generate a's randomly
14:11:01 <tensorpudding> and depending on how many a's you test, you get a higher probability of correctness.
14:11:03 <sbpaul> uh-oh
14:11:09 <sbpaul> my RSA implementation doesn't work >:O
14:11:18 <sbpaul> and i have no idea why
14:11:30 <tensorpudding> I think the probability of false positives is 2^-n, where n is the number of tests
14:11:51 <tensorpudding> it never comes up with false negatives
14:12:01 <sbpaul> how could it
14:13:00 <tensorpudding> it can be made deterministic, but the deterministic version relies on the Generalized Riemann Hypothesis, and is also algorithmically much slower than AKS.
14:13:00 <dmwit> sbpaul: eh? There are certainly probabilistic algorithms that can give both false positives and false negatives.
14:13:09 <sbpaul> yeah for sure
14:13:19 <sbpaul> none that work like that though ;)
14:14:12 <ddarius> According to Wikipedia, for a large range of numbers you can use a specific, finite set of a's to give a guaranteed result.
14:14:21 <tensorpudding> Yes, I was just going to say.
14:14:29 <tensorpudding> if n < 341,550,071,728,321, it is enough to test a = 2, 3, 5, 7, 11, 13, and 17.
14:14:31 <dmwit> Only one algorithm works just like that. So your statement is vacuously true.
14:14:43 <sbpaul> i know
14:14:45 <sbpaul> funny isn't it?
14:14:58 <sbpaul> if a prime number is divisible by some number
14:15:01 <sbpaul> it's not a prime number....
14:15:02 <tensorpudding> Though RSA numbers are bigger than that.
14:15:14 <sbpaul> besides 1
14:15:16 * sbpaul burps
14:15:22 <dmwit> > 128 * logBase 10 2
14:15:23 <lambdabot>   38.531839444989586
14:15:45 <dmwit> > logBase 10 341550071728321
14:15:46 <lambdabot>   14.533454380876243
14:18:21 <tensorpudding> M-R has a much smaller number of liars compared to the Fermat test.
14:19:58 <tensorpudding> Also there are no analogues of the Carmichael numbers.
14:21:15 <yitz> @oeis carmichael
14:21:16 <lambdabot>  Carmichael numbers: composite numbers n such that a^{n-1} = 1 ( mod n) if a ...
14:21:16 <lambdabot>  [561,1105,1729,2465,2821,6601,8911,10585,15841,29341,41041,46657,52633,62745...
14:22:33 <sbpaul> math is cool
14:22:39 <dmwit> so cool
14:22:48 <tensorpudding> too cool to live
14:24:42 <sbpaul> i'm getting better at this language
14:25:49 <sbpaul> did any of you ever read the steve albini article
14:26:02 <sbpaul> when he talks about navigating the music industry being like swimming through a river of sewage
14:26:03 <fax> no
14:26:39 <monochrom> walking among ordinary people is like swimming in sewage.
14:26:41 <dmwit> Seems a bit off-topic here...
14:27:02 <sbpaul> that's what learning haskell is like
14:27:17 <sbpaul> except you don't get paid at all
14:28:52 <sbpaul> well i suppose you get paid as a professor or programmer
14:29:12 <yitz> sbpaul: you get paid in enlightenment
14:29:22 <sbpaul> good old enlightenment
14:29:24 <tensorpudding> Enlightenment doesn't pay the bills.
14:29:48 <sbpaul> it kind of does, really
14:29:59 <sbpaul> helps you find the easiest way to do it, at least ;)
14:30:21 <yitz> no but it makes you enjoy life even though you can't pay them
14:30:27 <monochrom> pure functional union-find or disjoint sets in haskell!
14:30:27 <tensorpudding> Enlightenment used to be something that you had to get away from people to get, now apparently you can find it by learning software?
14:30:38 <Mirey> How do I fix this: pull :: [a] -> (a, [a]); pull [] = (, []); pull (x : rest) = (x, rest); I don't know what to put to return the correct type.
14:30:49 <sbpaul> tensorpudding: well it's all about understanding math, isn't it
14:30:50 <danharaj> software is a great way to avoid people
14:31:02 <FunctorSalad> haha only serious :(
14:31:13 <yitz> tensorpudding: now you find it by getting away from people and spending time typing to a bot through irc
14:31:25 <tensorpudding> You still end up talking and reading.
14:31:33 <Botje> Mirey: the only thing you can put is undefined or error "no element"
14:31:37 <monochrom> Mirey: Is it really sensible to have pull work for []?
14:31:52 <tensorpudding> It's not really the same thing
14:32:05 <cocon> I'm using "+RTS -M1000" and get "bad RTS option: -M1024"... what's wrong?
14:32:26 <cocon> (I'm getting bad RTS option: -M1000, sorry)
14:32:27 <yitz> Mirey: (Maybe a, [a])
14:32:33 <monochrom> perhaps space between M and 1000
14:32:53 <Mirey> Whats the correct way to have it error? Just leave it with a non-exhaustive pattern?
14:33:00 <yitz> no
14:33:02 <cocon> monochrom: no
14:33:14 <aavogt> perhaps you should indicate the units
14:33:27 <Cale> cocon: That would set the maximum heap size to 1000 bytes
14:33:27 <aavogt> as in K, or M or whatever
14:33:35 <Cale> cocon: Which wouldn't work :)
14:33:38 <cocon> yes, that helped
14:33:44 <cocon> thanks!
14:33:54 <FunctorSalad> Mirey: use the type yitz said, and you can make a convenience wrapper that uses `error' in case of Nothing
14:34:01 <monochrom> pull [] = error "pull [] is an error"
14:34:17 <FunctorSalad> to go the other way (from the error-ing function to the Maybe one), you'd have to resort to unsafePerformIO
14:34:27 <Mirey> Okay, thanks
14:34:49 <aavogt> spoons are involved
14:35:02 <Cale> heh
14:35:28 <yitz> > text . fix $ ("error \"pull [] is an "++)
14:35:28 <Cale> Basically, you try not to call error except in cases that you're sure will not happen.
14:35:33 <lambdabot>   mueval: ExitFailure 1
14:35:59 <Cale> This pull function that you're writing looks like the sort of thing that you would want to ensure never gets applied to an empty list ever.
14:36:07 <yitz> > fix ("error \"pull [] is an "++)
14:36:09 <lambdabot>   "error \"pull [] is an error \"pull [] is an error \"pull [] is an error \"...
14:36:16 <Cale> You similarly never want to apply head or tail to an empty list.
14:36:23 <yitz> > text $ fix ("error \"pull [] is an "++)
14:36:28 <lambdabot>   mueval: ExitFailure 1
14:36:50 <Cale> (you should always try to prove to yourself, if not formally, when you apply head or tail, that the list you're applying it to is nonempty)
14:36:52 <aavogt> why didn' they make:   tail == drop 1?
14:37:12 * benmachine finds a bug or two in cabal-install's bash-competion stuff
14:37:32 <FunctorSalad> for interactive development the erroring wrappers are handy too of course
14:37:48 <benmachine> I have alias rm='rm -v' and it is confusing the poor thing
14:37:55 <benmachine> what's the usual way of overriding that?
14:38:01 <FunctorSalad> benmachine: last time I checked some of the new keywords was missing
14:38:01 <Cale> aavogt: I suppose you could argue that would be better. I can imagine there are cases that you really do want the program to please stop whatever it was doing if the list happens to really be empty though.
14:38:37 <FunctorSalad> benmachine: DO NOT NAIVELY MAKE IT A FUNCTION
14:38:39 <FunctorSalad> :)
14:38:41 <FunctorSalad> instead of alias
14:38:48 <benmachine> FunctorSalad: hmm?
14:38:57 <FunctorSalad> took down most of my box today with something similar
14:39:04 <benmachine> hah :(
14:39:09 <dmwit> :(){:}
14:39:15 <FunctorSalad> bash infinite recursion has really high priority somehow
14:39:15 <benmachine> but I meant what's the usual way of ignoring aliases
14:39:21 <dmwit> :(){:&:} # even worse
14:39:28 <FunctorSalad> benmachine: ah. just use the full path
14:39:36 <benmachine> dmwit: I thought you needed some whitespace somewhere?
14:39:41 <monochrom> function rm() { rm $@ }  ---  exception: <<loop>>
14:39:41 <dmwit> maybe so
14:39:54 <FunctorSalad> (the thing about the function is that functions are recursive and aliases aren't, if it wasn't clear)
14:39:56 * dmwit doesn't script in shell all that much
14:40:07 <cocon> how many bytes does an Int-list of length 3 take in memory?
14:40:08 <benmachine> FunctorSalad: hmm, I think I'll just > /dev/null anyway since the user's not going to *get* the output even if any is produced
14:40:17 <cocon> (assuming it is forced)
14:40:22 * hackagebot repr 0.3.2.1 - Render overloaded expressions to their textual representation.  http://hackage.haskell.org/package/repr-0.3.2.1 (BasVanDijk)
14:40:43 <sbpaul> hey look
14:40:48 <sbpaul> my RSA implementation works :)
14:40:58 <FunctorSalad> benmachine: huh? I meant: alias rm='/bin/rm -v'
14:41:06 <benmachine> FunctorSalad: ohh, right
14:41:11 <dmwit> cocon: kind of a lot; 3 words for the pointers, 3 Int-sized chunks for the ints themselves (implementation-dependent size, but probably a machine word), plus a word shared among the whole program for the empty list
14:41:21 <benmachine> FunctorSalad: uh, not sure how that helps :P
14:41:39 <dmwit> err
14:41:50 <sbpaul> where is "ord"?
14:41:52 <cocon> dmwit: what about the constructor tags?
14:41:53 <dmwit> 6 words for the pointers, not 3
14:41:56 <FunctorSalad> benmachine: my warning wasn't about output spam, it was about the infinite recursion rapidly allocating memory and the resulting swapping
14:41:59 <sbpaul> and "chr"
14:41:59 <yitz> @hoogle ord
14:42:00 <lambdabot> Data.Char ord :: Char -> Int
14:42:00 <Cale> cocon: Of course, if it's not evaluated yet, then the list can take arbitrary amounts of memory -- however large the unevaluated expression takes to represent
14:42:00 <lambdabot> module Data.Ord
14:42:00 <lambdabot> Prelude class Eq a => Ord a
14:42:04 <dmwit> cocon: I think they're folded into the pointers these days.
14:42:09 <sbpaul> @hoogle chr
14:42:10 <lambdabot> Data.Char chr :: Int -> Char
14:42:10 <lambdabot> Text.PrettyPrint.HughesPJ Chr :: Char -> TextDetails
14:42:10 <lambdabot> Network.Browser chRealm :: Challenge -> String
14:42:13 <sbpaul> naturally
14:42:14 <benmachine> FunctorSalad: oh right yes, you meant use the full path to avoid infinite recursion
14:42:18 <dmwit> cocon: Google for "pointer tagging" or so.
14:42:19 <Cale> dmwit: They are, but they're *also* represented directly
14:42:25 <benmachine> it doesn't avoid the -v in the first place which is what I wanted to do :P
14:42:25 <dmwit> oh, darn
14:42:27 <FunctorSalad> benmachine: was the problem something else altogether?
14:42:30 <benmachine> yes
14:42:43 <Cale> The pointer tagging is just to be able to short circuit some cases without jumping.
14:42:47 <FunctorSalad> (and the rec was just for the case you ever make the alias a function)
14:43:09 <benmachine> your warning is appreciated however :)
14:43:23 <Cale> er, without dereferencing the pointer, I mean
14:43:50 * benmachine has darcs tell him he didn't make any changes
14:43:52 * benmachine looks at his changes
14:43:55 * benmachine scratches head
14:44:13 <Cale> benmachine: darcs record?
14:44:23 <monochrom> You have an alias for darcs too.
14:44:23 * hackagebot UMM 0.2.0 - A small command-line accounting tool  http://hackage.haskell.org/package/UMM-0.2.0 (UweHollerbach)
14:44:26 <dmwit> benmachine: Perhaps they are in a file that is not currently being tracked?
14:44:39 <benmachine> dmwit: yeah, so I did darcs show files and it said "."
14:44:46 * benmachine is now even more confused
14:45:02 <cocon> so 3 words for the cons-tags, 6 pointers, 3 for the actual data. not counting the Nil shared by the whole program this makes 12 for a list of length 3
14:45:09 <cocon> does that sound right?
14:45:20 <FunctorSalad> benmachine: still not sure what the problem is then :) related to cabal's bash-completion?
14:45:31 <dmwit> cocon: about right, yeah
14:45:34 <dmwit> cocon: Nasty, huh?
14:45:58 <benmachine> FunctorSalad: yes, there was a bug in cabal's bash-completion whereby if you (as I did) had rm make noise then it got substituted into a command and then bash got upset
14:46:24 <benmachine> the rm -v output has `s in it and so bash thought I had an unterminated substitution
14:46:49 <FunctorSalad> benmachine: one solution would be to wrap the alias definition in an interactive-only block
14:47:00 <dmwit> cocon: When memory is an issue, but the size is known, Array can make a huge difference.
14:47:09 <FunctorSalad> the debian stock files use "if tty -s" to detect interactivity
14:47:09 <benmachine> FunctorSalad: but I don't want to fix my alias! it's a perfectly normal alias to have, so cabal shouldn't react in that way imo
14:47:15 <jmcarthur> darcs add?
14:47:18 <FunctorSalad> (not sure if that's the optimal way)
14:47:28 <benmachine> I wanted to fix cabal to not use my alias, but now I've just decided to chomp all of rm's stdout anyways
14:47:39 <benmachine> which works fine too
14:48:01 <FunctorSalad> benmachine: I guess cabal's bash-completion runs in the shell you're in? not in a subshell
14:48:09 <benmachine> so *now* I'm wondering what on earth I did with this cabal-install darcs get that meant darcs doesn't think any of the files in it are actually under its control
14:48:13 <benmachine> FunctorSalad: seems that way
14:48:26 <benmachine> or in any case they inherit stuff like that
14:48:29 <FunctorSalad> (I think aliases don't expand in noninteractive subshells even if they are defined)
14:48:44 <benmachine> k
14:49:00 <sbpaul> is there any simple way to just ask haskell for a random value
14:49:05 <jmcarthur> you didn't screw around with the boringfile did you?
14:49:13 <dmwit> :t randomR
14:49:14 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:49:15 <benmachine> I wouldn't know how
14:49:15 <jmcarthur> sbpaul: randomIO
14:49:16 <FunctorSalad> benmachine: edit the cabal bash-completion then?
14:49:16 <dmwit> :t randomRIO
14:49:17 <lambdabot> forall a. (Random a) => (a, a) -> IO a
14:49:40 <benmachine> FunctorSalad: that's what I've been doing all this time :P
14:49:41 <FunctorSalad> to use /bin/rm, or to run in a fresh subshell
14:49:56 <benmachine> I just did rm > /dev/null
14:50:05 <benmachine> in the bash-completion file
14:50:09 <benmachine> now it works
14:50:15 <benmachine> except that darcs doesn't think I did anything
14:50:31 <benmachine> so I'm regetting the repository in case I screwed it up in some way last time
14:51:16 <Cale> sbpaul: There's a bit of awkwardness involved here in order to preserve the other nice properties that we like about Haskell. In particular, any function, when given the same parameters, must produce the same result every time it is applied.
14:51:39 <sbpaul> that is basically the opposite of what i want
14:51:44 <Cale> sbpaul: This makes testing and understanding code easy, but it has understandable consequences with regard to randomness.
14:52:17 <sbpaul> how is it possible to make a program that will return different results
14:52:20 <Cale> So there are two options: either treat getting random values as a sort of input, and execute an IO action to get your random values
14:52:41 <tensorpudding> IO will allow you to have different values
14:52:55 <tensorpudding> Random number generations is handled through IO, for example.
14:52:56 <Cale> Or, in the case of pseudorandom number generators, treat the generator state as a parameter to the function which will produce your "random" values.
14:53:05 <monochrom> It makes testing random-number-based simulations easy because given the same seed get the same result every time.
14:53:09 <Cale> Of course, passing in the same generator state will give the same result every time.
14:53:24 <nomeata> Hi. Is parsec-3.1.0 ready to be used instead of parsec-3.0.1, or is it not tested well enough yet?
14:53:30 <sbpaul> http://learnyouahaskell.com/input-and-output#randomness
14:53:35 <sbpaul> and it is one of these, correct?
14:53:40 <Cale> So we'll not only get the pseudorandom result, we'll get the next generator state as part of the result
14:53:46 <FunctorSalad> benmachine: the darcs repo is cabal's bash-completion? ok, took me a long time ;)
14:53:54 <benmachine> FunctorSalad: yes :P
14:54:00 <FunctorSalad> so it has nothing to do with rm in particular
14:54:05 <FunctorSalad> (the non-detection)
14:54:05 <sbpaul> finiteRandoms, randoms'?
14:54:07 <nomeata> I heard that it is much faster, and would like to have it in Debian if there are no problems with it.
14:54:17 <benmachine> FunctorSalad: oh, yeah, separate issues
14:54:30 <benmachine> that I happened to run into one after the other
14:54:37 <benmachine> sorry if that wasn't clear
14:54:50 <benmachine> Writing inventory 7 done, -1 queued.
14:54:50 <Cale> randoms is in the libraries
14:54:52 <benmachine> ...okay
14:55:16 <Cale> sbpaul: You pass it a generator state, and it gives you an infinite list of pseudorandom values that would emerge from that state.
14:55:45 <benmachine> nomeata: I'm not aware of any problems with it? but it's hard to say that I would be if there were some
14:56:28 <FunctorSalad> benmachine: not a darcs expert, but maybe start with "darcs changes -v cabal-bash-completion" to see what happened so far
14:56:30 <Cale> sbpaul: To get an initial generator state, you can either use mkStdGen to get a fixed constant one, or run the newStdGen IO action to produce a random one (actually I think it uses the system clock, but ideally it would use the system entropy -- not sure why it doesn't)
14:56:38 <Cale> :t mkStdGen
14:56:39 <lambdabot> Int -> StdGen
14:56:40 <sbpaul> i need to see the code
14:56:45 <Cale> :t newStdGen
14:56:46 <lambdabot> IO StdGen
14:57:01 <Cale> > randoms (mkStdGen 42) :: [Integer]
14:57:02 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
14:57:12 <benmachine> FunctorSalad: it seems to work now that I've gotten the whole repository again
14:57:13 <Cale> :t randomRs
14:57:14 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
14:57:21 <sbpaul> > randoms (mkStdGen 42) :: [Integer]
14:57:22 <Cale> > randomRs (1,6) (mkStdGen 42) :: [Integer]
14:57:23 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
14:57:23 <lambdabot>   [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,...
14:57:34 <tommd> > const tommd undefined
14:57:34 <sbpaul> same thing each time
14:57:35 <lambdabot>   Not in scope: `tommd'
14:57:40 <Cale> For the same StdGen, you will always get the same results
14:57:40 <sbpaul> i need to have it be actually random
14:57:43 <tommd> > const "tommd" undefined
14:57:44 <lambdabot>   "tommd"
14:57:59 <Cale> sbpaul: You'll want to use newStdGen to make a generator then
14:58:03 <dmwit> > const "tommd is awesome" (error "the impossible happened! blame tommd")
14:58:03 <lambdabot>   "tommd is awesome"
14:58:07 <sbpaul> :t newStdGen
14:58:08 <lambdabot> IO StdGen
14:58:20 <Cale> sbpaul: I can't do that using lambdabot, since it involves executing an IO action, which lambdabot won't do.
14:58:20 <FunctorSalad> (defadvice const ....)
14:58:21 <sbpaul> > randoms (newStdGen) :: [Integer]
14:58:23 <lambdabot>   No instance for (System.Random.RandomGen
14:58:23 <lambdabot>                     (GHC.IOBase.IO...
14:58:24 <FunctorSalad> err nvm
14:58:29 <sbpaul> right
14:58:40 <tommd> I was just testing empathies default notify functionallity
14:58:41 <Cale> randoms wants a StdGen, rather than just an IO action for making one :)
14:58:58 * sbpaul dies
14:59:02 <Cale> So near the top-level of your program (inside main perhaps)
14:59:08 <Cale> You can write  g <- newStdGen
14:59:21 <Cale> and then pass the generator g into whatever needs a random number generator
14:59:24 <Cale> g :: StdGen then
14:59:36 <dv-> or newStdGen >>= randoms
14:59:51 <Cale> dv-: Not quite. You could  fmap randoms newStdGen
15:00:08 <FunctorSalad> passing it around feels a lot more expensive than mutating a single IORef though
15:00:15 <Cale> FunctorSalad: ?
15:00:16 <sbpaul> where inside my main?
15:00:25 <dv-> Cale: oh right, doh
15:00:29 <sbpaul> my main here isj ust a big let...in...
15:00:36 <Cale> sbpaul: anywhere before the part where you need the pseudorandom number generator
15:00:37 <dancor> One possible drawback to it is that it is written in Haskell and has to be compiled with GHC. GHC is a Haskell compiler which is itself written in Haskell, with a problematic bootstrapping procedure, and Haskell may not be entirely scalable due to the limitations of the language.  http://better-scm.berlios.de/alternatives/darcs/
15:00:50 <FunctorSalad> Cale: just pondering performance of Randomness-as-State-Monad vs -as-ReaderT (IORef Seed) IO
15:00:51 <Cale> sbpaul: It's an IO action, right?
15:01:03 <sbpaul> what is, g <- newStdGen?
15:01:04 <FunctorSalad> Cale: I haven't benchmarked it though
15:01:08 <tommd> Funny, this is the second time in two days I've seen RNG talks.  Funny because three days ago I implemented part of NIST SP 800-90 (an DRBG)
15:01:18 <Cale> sbpaul: Do you know how IO works in Haskell?
15:01:24 <sbpaul> inside the IO monad
15:01:32 <Cale> sbpaul: It's a bit of do-notation
15:01:33 <sbpaul> a.k.a. not really
15:02:05 <Cale> okay, the fact that IO is a monad is a bit secondary. People like to focus on it, and it means that you have lots of handy functions available, but for now let's ignore that.
15:02:55 <Cale> What's much more important about how we handle I/O is that IO actions, that is, descriptions of stuff you could do which would have input or output effects before producing some result, are themselves values.
15:03:01 <Cale> For example,
15:03:01 <dibblego> "the IO type constructor"
15:03:04 <Cale> getLine :: IO String
15:03:12 <tensorpudding> A list of CVS alternatives that doesn't include Git or Mercurial?
15:03:17 <Cale> Is a description of some I/O which could be done to produce a string
15:03:24 <tensorpudding> Sounds to me to be out of date.
15:03:33 <Cale> Now, how do we execute an IO action?
15:03:49 <Cale> Well, the value 'main' in your program will be an IO action which gets executed
15:03:50 <FunctorSalad> do state monads such as random ever get optimized to mutating code?
15:03:58 <dancor> tensorpudding: ah yes 2005 looks like..
15:04:11 <Cale> You can also just type one out at the ghci prompt and ghci will execute it
15:04:16 <sbpaul> umm
15:04:25 <FunctorSalad> someone brought it up recently that haskell lacks explicit linearity for that
15:04:34 <Cale> But it's important to note that *evaluation*, the conversion of expressions into values, doesn't cause IO actions to be executed at all.
15:04:38 <tensorpudding> Oh it's got them on the sidebar, saying that they want to add them but no one was willing to contribute information
15:04:56 <Cale> So, now all we need is a way to build larger IO actions out of simpler ones
15:05:09 <jmcarthur> FunctorSalad: i very much doubt it
15:05:15 <mreh> Cale: >>=
15:05:26 <Cale> mreh: well, yes, but I'm going to explain do-notation
15:05:43 <Cale> I just feel like doing it the other way around this time :)
15:05:47 <FunctorSalad> jmcarthur: hmm. hoped it could be detected in simple cases like a thread of randoms
15:05:49 <jmcarthur> FunctorSalad: it would need to prove that the old value will never be used again and that the new one logically goes in the same place in memory. the first part alone would be insanely tough, i think
15:05:53 <mreh> Cale: bad
15:05:57 <mreh> do not want
15:06:03 <sbpaul> Cale
15:06:04 <sbpaul> http://pastebin.archlinux.fr/385303
15:06:07 <sbpaul> that's what i have now
15:06:16 <sbpaul> show me how to convert it and then explain it
15:06:18 <jmcarthur> FunctorSalad: there's no telling what could be holding a reference to the state outside of the monad abstraction itself
15:06:20 <sbpaul> or i'm going to be extremely confused
15:06:43 <FunctorSalad> jmcarthur: aaaahhh. completely forgot about that
15:06:56 <FunctorSalad> jmcarthur: just seemed so simple from the perspective of that random generation chain
15:07:18 <Cale> sbpaul: Okay, so you have the simplest possible main, in that your main action only consists of a single action: printing the result of your computation.
15:07:30 <sbpaul> yes
15:07:39 <jmcarthur> FunctorSalad: it could possibly be done if data was only ever copied from it, not referenced into it
15:07:48 <Cale> sbpaul: If we want to do more, we can use do-syntax to glue together a few IO actions into a single larger one
15:07:48 <jmcarthur> it would still be library-level though, afaik
15:07:55 <jmcarthur> like, using unsafePerformIO or something
15:07:58 <Cale> sbpaul: For example...
15:08:35 <Cale> main = do g <- newStdGen; let { ... the definitions from your let, possibly using g ... }; putStrLn $ ... your result ...
15:08:39 <tensorpudding> Hmm, Monotone's interface is supposedly designed to emulate CVS...that's a strong negative for Monotone...
15:08:55 <Cale> (I would lay this out without using braces and semicolons, but this is IRC, and it's a little awkward)
15:09:08 <Cale> If you want, I can use the pastebin
15:09:25 <jmcarthur> tensorpudding: even darcs inherits a fair bit from CVS
15:09:36 <jmcarthur> _darcs instead of .darcs, for example
15:09:40 <jmcarthur> most superficial things i guess
15:09:45 <jmcarthur> *mostly
15:10:04 <Cale> sbpaul: Whoa, is there a tab in your file? Make sure your editor is properly set to convert all tabs into spaces.
15:10:05 * sbpaul fiddles
15:10:07 <FunctorSalad> jmcarthur: what if the 'runState' makes a deep copy and the state never gets out?
15:10:12 <sbpaul> is there?
15:10:32 <FunctorSalad> jmcarthur: (the latter being convenient in specialized state monads like random, unless I'm missing something)
15:10:36 <jmcarthur> FunctorSalad: i suppose mutation could be used, but you'd still have to do that library-level, surely
15:10:37 <sbpaul> well not anymoer
15:10:38 <Cale> sbpaul: The pastebin seemed to think so
15:10:44 <Cale> http://pastebin.archlinux.fr/385304
15:10:49 <jmcarthur> hmm
15:10:58 <jmcarthur> not even library level maybe
15:11:01 <FunctorSalad> exposing MonadState's 'get' wouldn't be allowed
15:11:01 <Cale> Here's an example where we get the new generator g, but don't use it for anything
15:11:03 <sbpaul> shouldn't the compiler assume tab = space*8
15:11:04 <jmcarthur> maybe with primitives
15:11:31 <FunctorSalad> thinking about a monad that uses the state internally and exposes a different interface
15:11:32 <jmcarthur> it occurs to me that even IORef and STRef don't actually do in-place mutation that i'm aware of. they still store boxed values
15:11:40 <Cale> sbpaul: It does, (well, really it treats it as aligning to the next multiple of 8 spaces) but people's editors don't always treat it that way
15:11:45 <jmcarthur> so it's still just a reference change
15:11:54 <Cale> sbpaul: So as soon as you start working with other people, it's important to not use tabs.
15:12:07 <Cale> (because it matters how things line up)
15:12:12 <danharaj> convert your tabs to spaces
15:12:17 <sbpaul> speaking of which
15:12:20 <danharaj> It just makes it easier in the long run.
15:12:22 <sbpaul> how do i handle the indentation
15:12:30 <jmcarthur> maybe if values are unpacked into the constructor it might be "real" mutation
15:12:34 <sbpaul> in these blocks
15:13:09 <jmcarthur> FunctorSalad: you could expose get in that case if it made a copy
15:13:24 <FunctorSalad> jmcarthur: ok, but AIUI this boxing has no consequence except the extra indirection which is pointless if the value is a Word
15:13:28 <twink> Gah, not this again. It's not important. People can figure it out easily enough.
15:13:36 <Cale> sbpaul: Basically, the first non-whitespace thing after the 'do', 'let', 'of', or 'where' sets the column in which things should align.
15:13:57 <jmcarthur> FunctorSalad: the extra indirection still means that you aren't modifying the value it points to. you're still just leaving that to the garbage collector
15:14:18 <tensorpudding> At least Haskell doesn't have brace style arguments.
15:14:20 <Cale> sbpaul: Things which are siblings should line up vertically, and if they are part of something else, they should start in a deeper column
15:14:56 <gwern> 'Legend has it that when Michael Tiemann2 was at MCC people would stand outside his door to
15:15:00 <gwern> listen to the hum generated by his keystrokes which were so rapid as to be indistinguishable.
15:15:01 <sbpaul> rsa.hs:4:10: The last statement in a 'do' construct must be an expression
15:15:01 <FunctorSalad> jmcarthur: ah right, you mean for values that leaked out :)
15:15:11 <sbpaul> from this version:
15:15:13 <sbpaul>  http://pastebin.archlinux.fr/385305
15:15:14 <jmcarthur> even if they don't leak out
15:15:22 <jmcarthur> ghc won't know that
15:15:27 <FunctorSalad> but it still wouldn't beat just returning a "value type" as a value
15:15:32 <FunctorSalad> yeah
15:15:50 <Cale> sbpaul: Ah, remove the 'in'
15:16:02 <Cale> sbpaul: let inside of a do-block can go without in
15:16:04 <twink> I forget what the option is for ghc to change how many columns it considers a tabstop character equivalent to.
15:16:05 <jmcarthur> FunctorSalad: i guess you could always use Ptr instead of IORef
15:16:13 <sbpaul> oh i see
15:16:16 <Cale> sbpaul: The definitions you make scope over the remainder of the do-block
15:16:25 <Cale> sbpaul: You could also just indent the 'in' a bit
15:16:38 <sbpaul> erm...same error
15:16:43 <Cale> sbpaul: So that it would become part of the line of the do-block on which the 'let' began.
15:16:45 <Cale> hmm...
15:16:57 <jmcarthur> FunctorSalad: even then you still extract the value from the Ptr at some point, which puts it at the mercy of the gc... unless you write all access to that Ptr in C
15:16:59 <FunctorSalad> jmcarthur: there's still the issue of the monadic value itself being duplicated I think
15:17:06 <jmcarthur> or with low level primitives only
15:17:20 <FunctorSalad> (rather than just the box in the state leaking out)
15:17:24 <sbpaul>  http://pastebin.archlinux.fr/385306
15:17:27 <jmcarthur> well, if you allow it to mutate then you must always duplicate it
15:17:27 <sbpaul> rsa.hs:4:10: The last statement in a 'do' construct must be an expression
15:17:53 <jmcarthur> it's one of the things that imperative programmers forget about when they make claims about purely functional programming being slow
15:18:30 <jmcarthur> there is duplication required under different circumstances for both imperative and functional programming
15:18:30 <benmachine> sbpaul: remove the semicolon from the end of that line?
15:18:46 <jmcarthur> *and purely functional programming
15:19:18 <Cale> sbpaul: oh, make sure that the definitions of e and d line up with that of n
15:20:09 <FunctorSalad> jmcarthur: sorry, I got completely confused now w.r.t dynamic behaviour vs. syntactically evident properties
15:20:11 <Cale> sbpaul: I'm not sure why you're getting that particular error, but that's the most obvious thing which is off.
15:20:11 <dancor> jmcarthur: so you think idiomatic haskell will routinely beat C someday? :)
15:20:32 <ezyang> dancor: I hope so!
15:20:46 <jmcarthur> dancor: it's certainly possible. look at the kind of things JHC is pulling off (when it works)
15:20:47 <twink> Never mind, there isn't one.
15:21:15 <jmcarthur> dancor: i don't know whether it will happen though. i will not make any predictions
15:21:21 <Cale> sbpaul: Did that fix it?
15:21:29 <dancor> i'll have to try jhc sometime
15:21:39 <FunctorSalad> jmcarthur: thought that if you have an "f :: a -> MyMonad s b" that looks like "f a s = .... one occurence of s ...." then you were safe, but of course that has the problem you mentioned initially
15:22:00 <FunctorSalad> (purely syntactical analysis)
15:22:11 <jmcarthur> yeah
15:22:14 <FunctorSalad> we can only mutate s if we are the only owner
15:22:23 <jmcarthur> exactly
15:22:35 <Cale> FunctorSalad: You could do analysis to try to determine when variables are used only in a linear fashion, and implement things with mutation in that case.
15:22:37 <jmcarthur> linear types can prove that, of course
15:23:20 <Cale> But garbage collectors are better than they used to be at handling short-lived data anyway
15:23:42 <jmcarthur> linear types sounds very difficult with laziness. that might be worth googling for research...
15:23:45 <sbpaul> umm....
15:23:45 * jmcarthur googles
15:23:45 <sbpaul> no
15:23:57 <Cale> jmcarthur: Look up Clean
15:24:16 <FunctorSalad> surely we can deduce something else useful from the single occurence of s though?
15:24:26 <FunctorSalad> in my example
15:24:33 <jmcarthur> Cale: oh, right, but doesn't Clean's uniqueness typing force strict evaluation?
15:24:35 <Cale> jmcarthur: Clean is almost identical to Haskell, except that it has linear types, and uses explicit realworld passing for I/O.
15:24:44 <Cale> No, Clean uses lazy evaluation
15:25:12 <sbpaul> Cale:  http://pastebin.archlinux.fr/385308
15:25:13 <jmcarthur> Cale: what does the runtime force? the realworld token?
15:25:17 <sbpaul> rsa.hs:4:10: The last statement in a 'do' construct must be an expression
15:25:32 <Cale> sbpaul: you still have 'in' there
15:25:37 <sbpaul> stupid vim
15:25:46 <sbpaul> the 'i' is too close the the 'u'
15:25:53 <Cale> :]
15:26:05 <twink> Probably one major thing to say, though: tabs are not some number of spaces. Tabs are "advance to the next tabstop" commands where tabstops are at configured positions (most typically every 8 columns, but other arrangements, even irregular ones, are admissible).
15:26:06 * FunctorSalad knows linear types only insofar as they are supposed to be related to this topic
15:26:12 <jmcarthur> FunctorSalad: you could probably deduce that that function uses s linearly as long as the function you pass s into uses it linearly
15:26:36 <Cale> twink: and where there's no defined way to set what those tabstops are in ASCII
15:27:05 <sbpaul> i'm doing something dramatically wrong
15:27:11 <jmcarthur> FunctorSalad: ATTAPL has a good chapter on substructural types, btw
15:27:12 <twink> Cale: True enough. It has to be set up by some sideband procedure, e.g. in less(1), the -x option takes a numeric argument for the spacing between tabstops.
15:27:19 <jlouis> FunctorSalad: substructural type systems are interesting. They can for instance encode that you use a variable not 0 but exactly once.
15:27:55 <twink> Cale: This may argue for or against using tabstops, I'm just trying to get the accurate understanding out there (which I think you yourself already have, but never mind that).
15:27:58 <jlouis> FunctorSalad: if you generate a new unique type on each use, it means all kinds of nice properties... destructive updates rather than GC for instance
15:27:58 <sbpaul> Cale: errors at the bottom http://pastebin.com/LSnGMWRi
15:28:08 <Cale> sbpaul: I'll have a look
15:28:14 <sbpaul> i'm losing track of what's happening here
15:28:15 <jmcarthur> jlouis: aren't you just describing linear types exactly?
15:28:32 <jmcarthur> which is of course substructural, but linear types is what brought it up in the first place ;)
15:28:39 <jlouis> jmcarthur: yup. substructural type systems can do more than that
15:28:42 <jmcarthur> right
15:28:49 <twink> jmcarthur: Which chapter?
15:29:01 <jmcarthur> twink: h/o, lemme check
15:29:09 <FunctorSalad> jlouis: I'm sure they are; but I was scared of the overload from learning yet another type-theoretical language ;)
15:29:15 <Cale> sbpaul: You're passing (primes g) as a parameter to randomRs where randomRs would normally want g itself
15:29:17 <FunctorSalad> (clean)
15:29:21 <jmcarthur> twink: chapter 1 ;)
15:29:46 <Cale> errrr
15:29:51 <Cale> no, sorry, I misread that
15:29:52 <twink> jmcarthur: Chapter 1 it looks like.
15:30:02 <twink> jmcarthur: It loaded faster than I expected, sorry.
15:30:09 <jlouis> substructural logics in its fullest usually kill one or more of weakening, contradiction, exchange, etc
15:30:09 <FunctorSalad> (instead of mastering haskell and using it practically)
15:30:13 <jmcarthur> you've got a digital copy?
15:30:16 <Cale> sbpaul: You're not passing a generator there at all.
15:30:26 * jmcarthur had to go to his bookshelfe
15:30:27 <jmcarthur> -e
15:30:32 <Cale> sbpaul: To each randomRs, you need to pass a range, and a generator
15:30:34 <sbpaul> in line 5?
15:30:38 <Cale> yeah
15:30:40 <jlouis> jmcarthur: ATTAPL?
15:30:53 <jmcarthur> jlouis: Advanced Topics in Types and Programming Languages
15:30:56 <sbpaul> oh crap
15:30:56 <imc> re
15:30:58 <sbpaul> mismatched parentheses
15:31:04 <Cale> sbpaul: You might want to add a  g' <- newStdGen  so as to get a second, different generator to use
15:31:09 <jlouis> jmcarthur: nice book!
15:31:14 <FunctorSalad> jmcarthur: (2 pages up) yes, it seems that the function can *pass on* the uniqueness, even if it can't create it
15:31:16 <jmcarthur> jlouis: indeed it is
15:31:29 <jlouis> There is a chapter on substructural logic in that if memory serves me right
15:31:35 <jmcarthur> jlouis: chapter 1
15:31:46 <ddarius> Uniqueness types are subtly different to linear types.
15:32:00 <sbpaul> ah there
15:32:02 <sbpaul> that seemed to fix it
15:32:04 <imc> little concern... Parsec gives me line + column of the parser error... is there a straightforward way to print that line?
15:32:05 <jmcarthur> ddarius: i've heard that but never read up on it. do you know the difference off the top of your head?
15:32:23 <FunctorSalad> I think I saw a title claiming that linear types can be simulated with monads, haven't read it
15:32:29 <imc> i can count the newlines, then the caracters ok
15:32:33 <FunctorSalad> (whatever that means here)
15:32:34 <sbpaul> except now my keys are negative >:O
15:33:24 <Cale> sbpaul: weird. Also, I noticed that you're applying map abs to the result of randomRs there, where the range is strictly positive.
15:33:33 <alise__> Can anyone think of a less-consing way to write this?
15:33:36 <alise__> length . takeWhile (\n' -> mod n' 2 == 0) $ iterate (`div` 2) n
15:33:38 <FunctorSalad> (but maybe that wasn't in a sense that allows you to produce mutating code)
15:33:54 <Cale> alise__: The same, but with -O2
15:33:59 <josswr>  /win 13
15:34:02 <sbpaul> ok wtf is going on
15:34:16 <sbpaul> i must have just
15:34:45 <Cale> sbpaul: Could it possibly be that you're using Int instead of Integer?
15:35:10 <sbpaul> yes that would do it
15:35:15 <Cale> sbpaul: A lot of bugs are caused by Int.
15:35:18 <alise__> Cale: Hardy harhar
15:35:21 <Cale> I wish it were not in the prelude
15:35:45 <sbpaul> let's check that this still works...
15:35:45 <Cale> alise__: Well, I'm not kidding -- that ought to fuse, shouldn't it?
15:35:54 <alise__> Cale: Yeah, it just seemed inelegant
15:36:04 <sbpaul> > 22^9601273 `mod` 21309919
15:36:09 <lambdabot>   18923740
15:36:13 <jmcarthur> i also wish we had a standard non-negative Integer type
15:36:23 <jmcarthur> Int is to Integer as Word is to ?
15:36:32 <sbpaul> 18923740^9687865 `mod` 21309919
15:36:40 <alise__> Wordeger
15:36:44 <sbpaul> it's gonna crash
15:36:48 <alise__> but uhh, Natural
15:36:58 <jmcarthur> Word should be called Nat
15:37:02 <ddarius> jmcarthur: Apparently the slogan form is: "linear means 'will not be duplicated' where unique means 'has not been duplicated'"
15:37:14 <jmcarthur> ddarius: huh, that sounds interesting
15:37:23 <sbpaul> > 33^7 `mod` 1643
15:37:24 <lambdabot>   562
15:37:38 <sbpaul> >  562^223 `mod` 1643
15:37:39 <lambdabot>   33
15:37:42 <sbpaul> thank god
15:37:50 <sbpaul> and thank you Cale ;)
15:38:00 <FunctorSalad> what are the entities that can be duplicated?
15:38:01 <Cale> :)
15:38:02 <Mirey> is there a way to do: (x ** y)::Rational?
15:38:05 <sbpaul> i'll use my new knowledge of haskell to conquer the entire world
15:38:10 <jlouis> jmcarthur: http://en.wikipedia.org/wiki/Uniqueness_typing has something on the difference
15:38:12 <sbpaul> and make everybody miserable for my own selfish needs
15:38:17 <FunctorSalad> runtime number of references to a value?
15:38:22 <Cale> Mirey: If y is rational, then in general x ** y won't be
15:38:34 <jlouis> which reflects what ddarius says
15:38:34 <Cale> Mirey: If y is an integer, then you can use x ^^ y
15:38:34 <FunctorSalad> or is this a static property
15:38:48 <FunctorSalad> (yes I should just rtfm)
15:38:50 <Cale> If y is moreover a positive integer, you can use x ^ y
15:38:56 <tensorpudding> @type (**)
15:38:57 <lambdabot> forall a. (Floating a) => a -> a -> a
15:39:03 <Cale> (er, non-negative, I should say)
15:39:07 <Mirey> thank you Cale =]
15:39:08 <Mirey> yeah
15:39:09 <tensorpudding> @type (^)
15:39:11 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:39:15 <benmachine> > 2 ^ 0
15:39:16 <Mirey> I got it, cheers :)
15:39:16 <lambdabot>   1
15:39:23 <benmachine> mm, makes sense
15:39:36 <FunctorSalad> jmcarthur: what'd be the point of nonneg Integer? (let's call it Woooord?)
15:39:37 <tensorpudding> > (10 % 7) ^ 2
15:39:39 <lambdabot>   100 % 49
15:39:59 <benmachine> FunctorSalad: it'd be useful as an argument type to functions where negative arguments are clearly nonsense
15:40:10 <FunctorSalad> except saving a single bit ;) since you can't prove much about nonnegativity with simple types
15:40:21 <jmcarthur> ah, so uniqueness is a stronger property than linearity
15:40:31 <FunctorSalad> (ok, closed under + and *, maybe not that bad)
15:40:33 <ddarius> jmcarthur: It's a different property than linearity.
15:41:16 <FunctorSalad> benmachine: yes
15:41:34 <FunctorSalad> it's clearly useful as a `type' at least
15:41:43 <FunctorSalad> just don't know how much can be enforced
15:41:47 <jmcarthur> FunctorSalad: Natural would be nice when it doesn't make sense for negative integers to be in the type
15:42:14 <jlouis> I would love a Natural for QuickCheck properties :)
15:42:26 <benmachine> well, the nasty bit is that negate and fromInteger (-1) would have to give runtime errors
15:42:29 <jmcarthur> FunctorSalad: what would be unenforceable about it? the only issue i see is fromInteger, which isn't such a great example of good design, IMO
15:42:33 <FunctorSalad> jlouis: abs <$> arbitrary
15:42:34 <FunctorSalad> ;)
15:42:35 <jmcarthur> ah and negate
15:42:41 <jlouis> FunctorSalad: mm :)
15:42:45 <FunctorSalad> if you don't mind that zero will be disadvantaged
15:42:46 <benmachine> amd (-) but that's really just the same problem
15:42:48 <jmcarthur> the nastiness comes from Num, not from Natural ;)
15:43:04 <tensorpudding> Num is biased against monoids.
15:43:05 <jmcarthur> Num is the source of much nastiness
15:43:39 <Cale> There is a natural subtraction to use for Nat, but it doesn't give us a ring.
15:43:50 <benmachine> rings are nice
15:43:53 <jmcarthur> jlouis: http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.3/doc/html/Test-QuickCheck-Modifiers.html#t%3ANonNegative
15:43:57 <benmachine> how natural is it?
15:44:02 <FunctorSalad> my thought too
15:44:12 <FunctorSalad> I always had a suspicious eye on that one
15:44:19 <jlouis> jmcarthur: hah!
15:44:33 <jlouis> jmcarthur: even worse... I even think my code use it
15:44:40 <jmcarthur> lol
15:44:47 <jlouis> zombiebrain ftw
15:44:49 <FunctorSalad> truncating functions are often suspect mathematically somehow ;)
15:44:52 <Cale> There was a nice paper somewhere that argued that the best subtraction to use for Nat is the one which gives 0 when subtracting a larger number from a smaller one, because it's the one we most often want in order to write down various laws regarding the sizes of structures.
15:45:16 <Cale> We get that  length (drop n xs) = length xs - n
15:45:33 <jmcarthur> i'll call that subtraction if i can decide on a definition for subtraction
15:45:47 <fax> I agree with that Cale
15:46:34 <jmcarthur> i wouldn't really mind just calling that operation something else though, seeing as how it doesn't really satisfy the properties i normally expect for subtraction
15:46:43 <FunctorSalad> I think it just shouldn't exist as a total function
15:46:55 <jmcarthur> i think it's fine for it to exist
15:46:56 <jlouis> Cale: Your presence reminds me I need to check out your fingertree-psqueue package to see if it fares better than the psqueue package for the minView operation
15:47:04 <jmcarthur> just don't know if it should be called "subtraction"
15:47:05 <danharaj> If you wanted to be really stringent, you could only define subtraction when the second argument is smaller than the first, and have the programmer prove that this is the case.
15:47:05 <Cale> jlouis: I would be surprised
15:47:18 <FunctorSalad> you probably want a different type of gadget, not shoehorn it into a total binary function...
15:47:33 <Cale> jlouis: Actually, I would be mildly surprised if everything in that package worked correctly. I haven't really tested it thoroughly at all :)
15:47:38 <jlouis> Cale: yeah, it extracts and concatenates
15:47:39 <jmcarthur> FunctorSalad: do you also disagree with the behavior of drop?
15:47:46 <jmcarthur> > drop 10 [1..3]
15:47:47 <lambdabot>   []
15:48:00 <tensorpudding> > (1 - 2) :: Word32
15:48:01 <lambdabot>   4294967295
15:48:08 <jlouis> Cale: it is just that psqueue replays the tournament on a minView and sometimes that amounts to 30% of all allocation in combinatorrent
15:48:09 <FunctorSalad> jmcarthur: no, I've noticed that too
15:48:21 <dmwit> > maxBound :: Word32
15:48:22 <lambdabot>   4294967295
15:48:28 <FunctorSalad> (drop usually does what I mean)
15:48:40 <jmcarthur> FunctorSalad: it's the same thing as this "subtraction" operation on the length of the list
15:49:05 <jlouis> I could go with an array (or Data.Sequence) to get something which is less allocating, but before ditching a neat, pure, implementation... :)
15:49:19 <FunctorSalad> jmcarthur: I think with list operations you have long accepted mentally that they destroy information
15:49:30 <FunctorSalad> while I expect "(- 10)" to be injective
15:49:32 <Cale> jlouis: I remember that the new IO manager guys needed a fast efficient priority search queue for their work, so they started from PSQueue and optimised it further. I wonder if that's available.
15:49:41 <FunctorSalad> drop isn't even injective if the list is long enough, obviously
15:49:59 <jlouis> Cale: oh! I just thought tibbe dropped it in blindly
15:50:20 <jlouis> If he has optimizations, I better check them out :)
15:50:28 <jmcarthur> > let fromIntegral = flip replicate () in 5  -- it occurs to me that it would be awesome if this was [(), (), (), (), ()]
15:50:28 <lambdabot>   5
15:50:35 <jmcarthur> oops
15:50:43 <jmcarthur> > let fromInteger = flip replicate () in 5  -- it occurs to me that it would be awesome if this was [(), (), (), (), ()]
15:50:43 <lambdabot>   5
15:50:50 <FunctorSalad> jmcarthur: I think I just don't have a strong intuition what 'drop' should be from a math POV
15:51:47 <danharaj> If you're dropping more than the length of the list, does that not demonstrate sloppy reasoning?
15:52:03 <Cale> Not necessarily. Sometimes you really want to do that.
15:52:07 <jlouis> danharaj: I don't think so
15:52:26 <Cale> Consider something like  map (drop n) xs
15:52:32 <jlouis> danharaj: there is a place in combinatorrent which does something much like that (a splitAt)
15:53:06 <Twey> jmcarthur: Heheh
15:53:16 <ddarius> If rngs are rings without identity, and rigs are rings without negation, are there rgs?
15:53:19 * twink peeks back at the channel to try to figure out where he and jmcarthur were going with the substructural ATTAPL stuff.
15:53:21 <danharaj> Mm, right. It seems there are two distinct mathematical functions being conflated together because, well, one gives you the same result as the other when it makes sense.
15:53:29 <jlouis> danharaj: http://github.com/jlouis/combinatorrent/blob/master/src/Process/PieceMgr.hs#L427 to be precise
15:54:03 <danharaj> There should be a partial drop, and a total drop if you want to be more precise, because each one has a different intention.
15:54:13 <danharaj> But such pedantry doesn't always make sense in real code.
15:55:19 <FunctorSalad> with truncating "-" on nat you aren't just missing something though, like nat is missing mult-inverses, you are destroying the possibility of ever extending it to something nice algebraically
15:55:37 <jlouis> twink: that always happen to me with category theory or semantics... I end up in a black hole for hours at end
15:56:50 <FunctorSalad> (with rngs you can also just invent an identity element IIRC)
15:56:57 <danharaj> "-- This rather ugly piece of code should be substituted with something better." :D
15:58:09 <jlouis> danharaj: feel free to improve it :) I did improve it once I think, but I left the comment
15:58:50 <danharaj> Already have enough on my plate :D speaking of which, 6 pages to go on my paper.
15:59:18 <jlouis> danharaj: case splitAt n (ipPendingBlocks ipp) of ... is the first possible improvement :)
15:59:20 <jmcarthur> what are some cool examples of cofree comonads? i mean besides streams, nonempty lists, and trees.
15:59:51 <ddarius> jmcarthur: Well, all cofree comonads (over Set) look more or less like various process trees.
15:59:55 <jmcarthur> anything that's not simply tree-like?
15:59:55 <jlouis> cofree is a free construction with arrows opposited?
16:00:08 <danharaj> In mathematics, algebras are common and coalgebras are rare. I suspect that the same applies to monads and comonads in computation :)
16:00:20 <fax> that's why set theory has regularity?
16:00:37 <jmcarthur> jlouis: data Cofree f a = Cofree a (f (Cofree f a))
16:00:47 <jmcarthur> danharaj: i'm after the structure, not the comonad :)
16:00:48 <ddarius> jmcarthur: The structure is inherently tree-like, though it can be given a presentation that obsures that.  E.g. Cofree Set can be viewed as a non-deterministic transition system.
16:01:13 <ddarius> danharaj: No, coalgebraic structures are very common in computer science.
16:01:28 <danharaj> Well that's because you're a bunch of savages.
16:01:31 <jmcarthur> ddarius: yeah. i was just wondering if there was anything that we use a fair bit but don't often consider tree-like
16:01:35 * danharaj I am interested please elaborate
16:01:54 <ddarius> Also, many things in mathematics are closer to being coalgebraic than algebraic, e.g. the real numbers.
16:02:30 <danharaj> I was using algebra and coalgebra in the context of (co)algebras over a vectorspace/module. Were you?
16:02:32 <FunctorSalad> don't seem close to being captures by either
16:02:47 <FunctorSalad> *captured
16:02:48 <ddarius> danharaj: I'm using it in the sense of F-algebras and F-coalgebras.
16:03:08 <danharaj> Ah. Well then we are talking about different things. I apologize.
16:03:35 <FunctorSalad> (if you consider metrics and limits to be where pure algebra stops and analysis begins)
16:03:39 <ddarius> FunctorSalad: You can view a real number as a stream of bits.
16:04:02 <jsoffer> Hello, I seem to remember there's a lambdabot function that tells me if a simple function definition is equivalent to an existing function, but can't find it. Help please
16:04:18 <jmcarthur> jsoffer: do you mean @pl?
16:04:27 <jmcarthur> that's not exactly its function, but it sometimes does that
16:04:34 <jsoffer> @pl
16:04:34 <lambdabot> (line 1, column 1):
16:04:34 <lambdabot> unexpected end of input
16:04:34 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:04:40 <jmcarthur> @pl \a -> a
16:04:40 <lambdabot> id
16:04:51 <jsoffer> @pl \a -> a
16:04:51 <lambdabot> id
16:04:54 <jlouis> jmcarthur: I've always wondered how one should read such a data expresssion.
16:05:01 <jsoffer> yes, that might me it
16:05:05 <jsoffer> thanks
16:05:10 <jmcarthur> jlouis: what do you mean?
16:05:40 <FunctorSalad> ddarius: thought we were in classical land, where it's an arbitrary stream, not one definable in some PL-like framework. (doesn't gain you much in classical math)
16:05:47 <jlouis> Cofree a (f (Cofree f a)) -- Cofree is the constructor, but is there any deeper meaning to the rest of it?
16:06:11 <jlouis> other than just note it has an a and an f taken on itself?
16:06:11 <FunctorSalad> (simple countability issues)
16:06:13 <jsoffer> @pl (\ f n -> foldl (.) id $ replicate n f)
16:06:14 <lambdabot> (foldl (.) id .) . flip replicate
16:06:24 <ddarius> jlouis: What kind of "deeper meaning" are you expecting?
16:06:36 <jlouis> A releation to category theory
16:06:58 <FunctorSalad> ddarius: and bits don't capture the topology well, IIRC the "natural" topology on bitstreams (product topo) produces the cantor space
16:07:05 <jmcarthur> jlouis: it's the minimal structure necessary to generate a comonad from an arbitrary functor
16:07:06 <FunctorSalad> which is nothing whatsoever like a continuum
16:08:01 <ddarius> FunctorSalad: The point is various potential representations of real numbers, e.g. also continued fractions, can be exhibited as coalgebraic structures and are clearly nothing like algebraic structures.
16:08:08 <jsoffer> @pl let alternos (x:y:xs) = (x:m, y:n) where (m, n) = alternos xs
16:08:09 <lambdabot> (line 1, column 49):
16:08:09 <lambdabot> unexpected "="
16:08:09 <lambdabot> expecting variable, "(", operator, ";" or "in"
16:08:19 <ddarius> Also, the Cantor space is closely related to the structure of real numbers as is the Borel space.
16:08:25 <ddarius> I read some paper on this recently.
16:08:29 <tensorpudding> @pl \f -> ((\x -> f x x) (\x -> f x x))
16:08:30 <lambdabot> ap join join
16:08:49 <tensorpudding> huh
16:08:54 <saml> > app join join "hello"
16:08:55 <lambdabot>   Couldn't match expected type `m (m a) -> m a'
16:08:55 <lambdabot>         against inferred type...
16:09:04 <jmcarthur> :t app
16:09:05 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
16:09:07 <jmcarthur> ah
16:09:15 <tensorpudding> > (ap join join) (+)
16:09:16 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
16:09:20 <jsoffer> > let alternos (x:y:xs) = (x:m, y:n) where (m, n) = alternos xs
16:09:21 <lambdabot>   not an expression: `let alternos (x:y:xs) = (x:m, y:n) where (m, n) = alter...
16:09:31 <Twey> :t ap join join
16:09:33 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
16:09:33 <lambdabot>     Probable cause: `join' is applied to too few arguments
16:09:33 <lambdabot>     In the second argument of `ap', namely `join'
16:09:37 <tensorpudding> it's supposed to be a fixed-point combinator
16:09:40 <FunctorSalad> ddarius: I don't doubt there are relations, I was looking at it from the angle that the essential difference between R and your garden-variety real closed field is topological
16:09:41 <jmcarthur> good job @pl
16:09:44 <Twey> Ah
16:09:50 <Twey> :t fix
16:09:51 <lambdabot> forall a. (a -> a) -> a
16:09:54 <tensorpudding> So it shouldn't have worked
16:10:01 <Twey> Hm
16:10:03 <tensorpudding> @unpl fix
16:10:03 <lambdabot> fix
16:10:09 <jmcarthur> heh
16:10:10 <FunctorSalad> ddarius: with the cantor space being kinda the opposite of a continuum ;)
16:10:59 <jlouis> jmcarthur: let me try to think a bit.. 'f' is the functor?
16:11:16 <FunctorSalad> (now, the difference to real-closed fields doesn't say anything about coalgebra, just that R isn't captured by the properties polynomials have in it)
16:11:22 <jmcarthur> jlouis: right
16:11:30 <ddarius> s/Borel/Baire
16:11:38 <ddarius> @google "The continuum as a final coalgebra"
16:11:40 <lambdabot> http://portal.acm.org/citation.cfm?id=568340
16:11:40 <lambdabot> Title: The continuum as a final coalgebra
16:12:32 <FunctorSalad> maybe I just misunderstand 'coalgebraic'. Thought we were still firmly in discrete structures there
16:12:50 <tensorpudding> Hmm, so you can implement the Y combinator in Java...
16:12:54 <ddarius> Basically, a lot of analysis can be viewed as a round-about way of representing coalgebraic methods.
16:13:54 <danharaj> round-about in the sense that you could simplify a lot of proofs by viewing coalgebraically?
16:14:12 <ddarius> danharaj: Definitely.
16:14:28 <danharaj> I have to make a note of that.
16:14:39 <mreh> are Arrows, like more general than Monads? Arrow transformers seem to act completely differently in comparison to Monad transformers
16:14:53 <FunctorSalad> (I have haskell lists in mind, which pretend to be infinite sequences, but are really just a countable subset)
16:15:25 <danharaj> Well there's a lot of uncomputable sequences, but they are treated in the same way.
16:15:58 <danharaj> If you had some oracle that gave you an uncomputable infinite sequence, your program would still behave the same, no?
16:16:22 <ddarius> tensorpudding: More interestingly, C# readily types the self-applicative definition of the Y combinator.
16:16:49 <FunctorSalad> danharaj: it is conceivable to feed arbitrary infinite sequences to a haskell program, I meant you can only defined very few of them in haskell
16:16:53 <jmcarthur> jlouis: i'm working on a blog post as we speak. maybe once i get it posted it will help. i'm trying to deemphasize the comonadic nature of it in favor of the structure it generates itself, though
16:18:03 <FunctorSalad> danharaj / ddarius : mind you, the statement I'm making is not a rigorous one (we had just been talking about the 'flavour' of a theory after all (analytical,topological,discrete,...))
16:19:18 <jlouis> jmcarthur: I only have a vague idea on how it generates the comonad. You have a value of type 'a' and how the functor 'f' operates on Cofree f a it seems. But do you go from there in the generation?
16:19:33 <jlouis> -how
16:20:17 <FunctorSalad> ddarius: now that I think about it, Dedekind cuts are just a monotonic function from Q to {0,1}, which is rather co-flavoured ;)
16:21:53 <jmcarthur> jlouis: well, it's clear how (copoint :: Functor f => Cofree f a -> a) would work, right?
16:22:03 <FunctorSalad> (hmm... with the extra property specifying which side is closed)
16:22:06 <tensorpudding> "made with natural co-coconut co-flavouring"
16:22:16 <ddarius> As a contrast, here's an initial algebra view of the unit interval, but notice the coalgebraic structure hiding inside: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.28.9366&rep=rep1&type=pdf (A Universal Characterization of the Closed Euclidean Interval)
16:22:18 <jmcarthur> jlouis: the structure guarantees that there is always at least one value ready to extract
16:22:42 <jlouis> jmcarthur: yes, it would take the 'a' value, whatever that is. Or that is the only possible way I can see
16:23:04 <jmcarthur> jlouis: yes, that is the only possible way.
16:23:34 <jmcarthur> jlouis: the other part of the story is (cojoin :: Functor f => Cofree f a -> Cofree f (Cofree f a))
16:24:01 <jmcarthur> jlouis: i bet you could get it given some thought
16:24:31 <jmcarthur> jlouis: if not, you can always google "cofree comonad" or wait for my blog post
16:25:05 <Cale> ddarius: There's some work which actually goes a bit farther than defining an interval object, and instead defines a functor "I ×" with appropriate axioms :)
16:25:07 <jmcarthur> jlouis: but like i said, i won't be emphasizing the comonad instance as much as i will the structure
16:25:16 <mreh> what are '~' in haskell called?
16:25:19 <jmcarthur> i'll try to be fairly clear on the comonad explanation though
16:25:22 <fax> equality constraints
16:25:27 <mauke> tilde
16:25:27 <gwern> mreh: lazy pattern match?
16:25:36 <mreh> oh, those
16:25:50 <Cale> I'm not sure how related it is. It's in the direction of categorifying homotopy theory.
16:26:02 <jmcarthur> > (\(x, y) -> "foo") undefined
16:26:03 <lambdabot>   "*Exception: Prelude.undefined
16:26:06 <jmcarthur> > (\~(x, y) -> "foo") undefined
16:26:07 <lambdabot>   <no location info>: parse error on input `->'
16:26:14 <jmcarthur> > (\ ~(x, y) -> "foo") undefined
16:26:15 <lambdabot>   "foo"
16:26:37 <mreh> so it stops it crashing if you give it undefined...
16:26:43 <jmcarthur> well
16:27:02 <jmcarthur> ~ means it's not forced unless part of the pattern is actually needed in the expression
16:27:30 <jmcarthur> > (\ ~(x, y) -> x) undefined  -- will still be _|_
16:27:31 <lambdabot>   *Exception: Prelude.undefined
16:27:56 <Cale> This paper seems more concerned with preserving finer properties of the interval than that is, though. (I think)
16:28:14 <jmcarthur> > (\ ~(x, y) -> (5, x)) undefined
16:28:15 <lambdabot>   (5,*Exception: Prelude.undefined
16:28:18 <jmcarthur> > (\ (x, y) -> (5, x)) undefined
16:28:18 <lambdabot>   *Exception: Prelude.undefined
16:28:41 <jmcarthur> notice that the first gives us the tuple constructor and the first element in the result, but not the second element
16:28:44 <mreh> I sees
16:28:49 <mreh> yea
16:28:49 <jmcarthur> that's because the second element forces the argument
16:29:14 <mreh> so... is it a performance thing?
16:29:19 <jmcarthur> it can be
16:29:29 <mreh> like newtypes
16:29:37 <jmcarthur> it really is just a way of controlling evaluation
16:29:42 <jmcarthur> newtypes are not just about performance
16:29:48 <jmcarthur> they have semantic differences, too
16:29:49 <gwern> mreh: I would think jmcarthur's examples show that it makes more functions non-bottom...
16:30:02 <jlouis> jmcarthur: heh, that one takes a little more thinking
16:30:20 <cdsmithus> Okay, I need to talk to a library written in Mono.  Do I write a C# wrapper and interact over a named pipe?  Or is there an in-process way to do it?
16:30:39 <jmcarthur> jlouis: perhaps obvious hint: it critically relies on f being a Functor
16:30:52 <jlouis> jmcarthur: it has to apply fmap yes
16:32:21 <mreh> :t get
16:32:22 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
16:33:58 <twink> ATTAPL seems to have dirt on module stuff I was interested in at one point.
16:36:02 <Cale> cdsmithus: I wonder if you can use hs-dotnet
16:36:25 * twink ponders some sort of ML-like mini-language to try out module stuff with.
16:39:25 <jlouis> jmcarthur: nope, can't see what you do
16:41:37 <fax> why is chaitans constant thought of as uncomputable?
16:41:40 <fax> isn't it a rational
16:41:59 <fax> because surely there are only finitely many programs which terminate or don't.. before you hit one whos termination is undecidible
16:42:23 <fax> and if you had a really good mathematician you cuol prove all the programs up to the first undecidible one
16:43:38 <dmwit> Not necessarily, no.
16:43:53 <dmwit> There may be terminating programs that are not provably so.
16:44:16 <dmwit> (e.g. one that halts if some open conjecture is true and not otherwise)
16:49:47 <monochrom> the proviso is "really good mathematician" :)
16:50:02 <fax> yeah he can prove the reimann hypothesis in 10 mins
16:50:22 <monochrom> this one of those "no true mathematician" things
16:51:29 <monochrom> A true haskeller can solve the halting problem in haskell at the type level. This is because there is no true haskeller. But wait, there is Oleg.
16:51:33 <dmwit> I posit that there may be open problems that are unprovable one way or the other.
16:53:11 <mreh> ^ this guy has taken a leaf out of apple's book
16:54:27 <alpounet> haha
16:54:42 <mreh> Cale: why did you choose to implement Rand as a RandT?
16:54:43 <jmcarthur> dmwit: if it's not provable whether the program terminates, does it really terminate? after all, couldn't you prove that a program terminates by just running it in finite time?
16:54:50 <dmwit> fax: Also, Chaitin's constant isn't determined by just the first undecidable program.
16:54:58 <mreh> simplify the implementation? or confuse n00bs like me
16:55:02 <dmwit> fax: I just looked on Wikipedia to find out what it actually was. =)
16:55:06 <Draconx> dmwit, just take something that's unprovable in ZFC, such as the contiuum hypothesis.
16:55:35 <Cale> mreh: Because I could?
16:55:44 <jmcarthur> dmwit: it could be that it's not provable in *practical* amount of time, but i doubt that there could be a nonprovably terminating program
16:56:53 <Cale> mreh: Assuming I was going to write RandT anyway, it would be a bit of a waste of time to implement Rand separately, though it might have been useful in a teaching setting.
16:57:08 <mreh> Cale: aye
16:58:05 <mreh> I'm doing an ArrowRandom and associated Arrow now, I'm just going to rip off the StateArrow basically
16:59:11 <Cale> mreh: You could rip off Kleisli
16:59:15 <mreh> Arrows seem to be much more flexible than Monads, at my first approximation
16:59:41 <Cale> mreh: There are more arrows than monads, but less than you can do with something just knowing that it's an Arrow.
16:59:42 <mreh> Cale: that flashed through my mind, but I scolded myself for now knowing enough about what the hell I'm doing
16:59:53 <jmcarthur> mreh: monads are more flexible, actually ;)
17:00:13 <jmcarthur> i am beaten. blasted lag
17:00:26 <Cale> that*
17:00:51 <mreh> Cale: it's actually an Arrow transformer, so I don't think that would be appropriate
17:01:01 <Cale> mreh: Well...
17:01:07 <mreh> what happens when you apply kleisli to a MonadT?
17:01:10 <Cale> Yeah, perhaps not.
17:01:20 <Cale> You can't do that.
17:01:26 <Cale> It's a kind error
17:01:41 <cdsmithus> Cale: Thanks for the answer earlier.  Unfortunately, it looks like hs-dotnet doesn't build on Linux?
17:01:50 <mreh> :t kleisli
17:01:51 <lambdabot> Not in scope: `kleisli'
17:02:03 <Cale> cdsmithus: Yeah, I don't really know anything about it.
17:02:08 <jlouis> jmcarthur: heh, I ended up cheating a bit and reading category-extras, but I can see how it can be generated now
17:02:45 <cdsmithus> So I'm debating whether to use talk over a pipe to a C# process... or just to reimplement the underlying network protocol in Haskell
17:02:47 <Cale> :k Kleisli
17:02:48 <lambdabot> (* -> *) -> * -> * -> *
17:02:52 <Cale> :t Kleisli
17:02:53 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
17:03:49 <mreh> @instances Arrow
17:03:49 <lambdabot> (->), Kleisli m
17:04:07 <Cale> So you could write  newtype RandA a b = RA (Kleisli Rand a b) deriving (Category, Arrow, ArrowLoop, ArrowApply, ArrowChoice, ArrowPlus, ArrowZero)
17:04:36 <mreh> sure
17:04:56 <mreh> not sure about most of those classes, but I take it they are derived from Rand
17:05:15 <mreh> and Kleisli
17:05:19 <Cale> They're instances which Kleisli has generally
17:05:32 <Cale> and so you can derive them using NewtypeDeriving
17:05:39 <Cale> (an extension)
17:05:53 <Cale> Oh, sorry, ArrowPlus and ArrowZero won't do
17:06:01 <Cale> Because Rand isn't a MonadPlus of course
17:06:23 <Cale> Hmm... Rand probably *could* be a MonadFix, but I'm not sure if it is or now
17:06:24 <Cale> not*
17:06:38 <Cale> So you may have to either drop ArrowLoop, or implement MonadFix for Rand
17:07:05 <mreh> well, I'll just drop that line into my source, because it's easy
17:07:13 <mreh> it's not something I would find useful
17:07:17 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Arrow.html#t%3AKleisli
17:07:40 <Cale> You'd also want:
17:08:28 <Cale> well, some composite of runRand/evalRand and runKleisli
17:08:43 <Cale> So as to be able to conveniently run computations built up like that
17:09:31 <mreh> runRand is just runState
17:09:42 <Cale> yes, under the covers
17:09:52 <mreh> evalRand follows on nicely by applying the function
17:10:20 <mreh> how do you mean composite?
17:10:57 * twink cooks up some miniature ML-ish thingie to be a spec to do things with.
17:15:23 <mreh> *how* does it derive Arrow?!
17:15:28 <mreh> oh from Kleisli
17:15:31 <mreh> haha
17:15:57 <mreh> that's quite clever...
17:16:21 <mreh> I'm having a thermos flask moment here
17:16:32 <fax> so what should i do with haskell
17:16:41 <fax> today I wrote a program that express a number as a sum of squares mod p
17:16:46 <fax> but now I don't have anything to do
17:16:52 <monochrom> write a TracerT monad transformer
17:17:03 <mreh> no, write an AFRP gui toolkit
17:17:12 <fax> that doesn't sound like my kind of thing
17:17:21 <mreh> useful?
17:17:32 <fax> lol implying AFRP is useful :P
17:17:41 <monochrom> write purely functional union-find
17:17:51 <mreh> AFRP *is* useful
17:18:19 <mreh> what's the beef huh?
17:18:27 <monochrom> assymmetric forward refinement proof
17:18:27 <mreh> you don't know me!
17:18:58 <mreh> I wish I knew what any of those things are
17:19:20 <monochrom> I wish too
17:19:31 <mreh> I need a new mathematics book, preferably on programming
17:19:32 <fax> hmmmmmmm
17:19:35 <mreh> what do you suggest
17:19:35 <danharaj> Balls-deep in theory.
17:19:57 <mreh> is there a book describing how haskell works?
17:20:10 <fax> yeah simon peyton jones
17:20:32 <pikhq> fax: Write a Haskell compiler.
17:20:33 <kmc> mreh, "how it works"?
17:20:36 <monochrom> perhaps "the haskell road to logic, math and programming"
17:20:37 <kmc> mreh, you mean how to implement it?
17:20:39 <kmc> or some of the theory?
17:20:44 <fax> I don't know how to write a compiler
17:20:49 <fax> I can't do assembly
17:20:50 <kmc> mreh, did you read the STG machine paper?
17:20:53 <kmc> fax, then you can learn those
17:20:54 <pikhq> Learn how to write a compiler.
17:20:58 <mreh> kmc: no
17:21:06 <pikhq> And that is actually a serious suggestion.
17:21:09 <danharaj> You can compile to C and then use gcc
17:21:13 <kmc> no
17:21:13 <pikhq> You should totally learn how to write a compiler.
17:21:15 <kmc> compile to LLVM
17:21:21 <fax> who wants to team up with me and implement a haskell language
17:21:21 <kmc> it's a much better interemdiate language
17:21:25 <monochrom> compile to 6502
17:21:26 <danharaj> fair enough
17:21:34 <kmc> mreh, citeseer.ist.psu.edu/peytonjones92implementing.html
17:21:47 * ddarius fondly recalls implementing a 6502 emulator in x86 assembly.
17:22:10 <mreh> some of you guys are old
17:22:27 <ddarius> Some of you kids are young.
17:22:28 <monochrom> let's do 4004
17:22:49 <kmc> every programmer should know how compilers work
17:22:49 <monochrom> some of you know more agda than I do
17:23:15 <fax> Here are my ideas for Haskell':
17:23:15 <mreh> kmc: i'm interested to hear your arguments
17:23:17 <jmcarthur> so many don't, though
17:23:26 <ddarius> Why don't we redefine "programmer" to include only those who know how compilers work.
17:23:32 <fax> * merge modules, (GA) data types and type classes into one thing
17:23:45 <monochrom> and redefine "developer" to refer to those who don't :)
17:23:46 <pikhq> fax: Start. Simpler.
17:24:21 <jmcarthur> Break. Your. Sentences. Up. Inappropriately.
17:24:27 <fax> lololol
17:24:38 <pikhq> jmcarthur: Heheh.
17:24:51 <pikhq> So I use periods for emphasis.
17:24:57 <danharaj> I overbrewed my green tea. Now it looks like black tea.
17:25:02 <pikhq> danharaj: :(
17:25:06 <jmcarthur> ew
17:25:06 <ddarius> Awesome!
17:25:17 * danharaj sips
17:25:23 <monochrom> Every colour tends to black in the limit.
17:25:30 <mreh> except white
17:25:35 <ddarius> of zero photons
17:25:43 <danharaj> STILL DELICIOUS. Although the jasmine scent is not as obvious anymore.
17:25:47 <mreh> oh, yes
17:25:59 <ddarius> "Jasmine"?
17:26:02 <danharaj> (also anything is better than the crap lipton sells)
17:26:13 * ddarius does not equate jasmine tea with green tea.
17:26:23 * mreh neither
17:26:23 <jmcarthur> monochrom: only in negative color spaces and assuming realistic constraints like "no material is fully transparent in any frequency"
17:26:27 <ddarius> danharaj: You should get some Thai tea mix.
17:26:43 <danharaj> All real teas come from a single plant, and are scented to get different flavors. My current brew is scented with jasmine flowers. Delicious.
17:27:02 <jmcarthur> *maybe realistic, i didn't think about that one
17:27:13 <pikhq> Either scented or mixed with.
17:27:15 * hackagebot monads-fd 0.1.0.1 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/monads-fd-0.1.0.1 (RossPaterson)
17:27:22 <pikhq> ddarius: Green tea + jasmine, though?
17:27:33 <monochrom> (anything is better than the crap lipton sells. the crap lipton gives away for free is anything. therefore, the crap lipton gives away for free is better than the crap lipton sells. the freebie paradox.)
17:27:50 <danharaj> ddarius: duly noted. Been wanting to get some Lapsang Souchong too. I have heard great things.
17:28:10 <fax> hahaha
17:28:14 <pikhq> monochrom: It's not like Lipton is in the business of making good tea.
17:28:17 <jmcarthur> forall a . a > liptonCrap
17:28:25 <jmcarthur> except that a could be liptonCrap
17:28:25 <pikhq> They're in the business of mass-producing tea.
17:28:28 <ddarius> danharaj: Thai tea, when prepared as it typically is, is quite a bit different from the normal tea experience.
17:28:39 <mreh> greater than or equal
17:28:43 <sbpaul> are we talking about drinking poppy tea
17:28:47 <pikhq> Particularly for the purpose of Southerner's sugar-tea-water.
17:28:50 <sbpaul> i know there are some serious opiate addicts in here
17:29:14 <mreh> this is #haskell, about the haskell language
17:29:20 <pikhq> sbpaul: We tend to prefer the caffeine addictions.
17:29:21 <sbpaul> i know
17:29:24 <pikhq> As such is a hacker's wont.
17:29:25 <sbpaul> pfft
17:29:29 <sbpaul> you guys are boring
17:29:31 <jmcarthur> is there really a place in america where tea is normally unsweetened?
17:29:35 <sbpaul> i've met some serious drug users in this room
17:29:44 <danharaj> jmcarthur: My house :p
17:29:48 <mreh> haskell is my high
17:29:53 <ddarius> jmcarthur: Yes.  Most of the "North"
17:29:59 <tensorpudding> Tea might have a little sugar in it, but it's nothing compared to "sweet tea"
17:29:59 <pikhq> jmcarthur: Not-Southern America generally has unsweetened iced tea, when they have iced tea.
17:30:06 * jmcarthur wouldn't cound danharaj as a region, which he meant to imply was a constraint
17:30:15 <pikhq> It's also a less common thing outside of the Southern US.
17:30:16 <tensorpudding> Sweet tea is abominably sweet.
17:30:18 <danharaj> "Yo momma's so fat..."
17:30:21 <monochrom> is there a place in america where haskell monad usage is unsweetened?
17:30:28 <danharaj> My house as well.
17:30:32 <sbpaul> any of you ever taken cocaine
17:30:37 <pikhq> tensorpudding: Sweet tea is quite literally saturated with sugar.
17:30:37 <danharaj> I like bind.
17:30:47 <pikhq> You *actually add sugar to the saturation point*.
17:30:55 <jmcarthur> i must not be looking north enough
17:30:56 <sbpaul> i have wonderful teas here
17:30:57 <tensorpudding> No wonder the south is so unhealthy.
17:31:01 <sbpaul> i don't know where any of them came from
17:31:06 <sbpaul> but they're delicious
17:31:16 * hackagebot xml-types 0.1 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.1 (JohnMillikin)
17:31:17 <sbpaul> i know one of them is a darjeeling tea
17:31:19 <jmcarthur> pikhq: no, you supersaturate it :(
17:31:24 <ddarius> tensorpudding: I can assure you.  It's not from the tea...
17:31:28 <pikhq> jmcarthur: The north is also far more likely to have people drinking real tea. :P
17:31:30 <mreh> darjeeling is like weak breakfast tea
17:31:35 <jmcarthur> pikhq: that i believe
17:31:38 <mreh> #haskell-tea?
17:31:45 <fax> #haskell-coffee
17:31:53 <jmcarthur> #haskell-cofree
17:31:58 <danharaj> Coding and caffeinated beverages go hand in hand.
17:32:00 <tensorpudding> If the tea isn't loose it's not worth drinking.
17:32:07 <mreh> hmm tea or coffee?
17:32:21 <danharaj> coffee agitates me, tea soothes me and focuses my mind for coding.
17:32:25 <monochrom> CofreeT monad transformer
17:32:29 <sbpaul> they're the same drug danharaj
17:32:34 <sbpaul> it's a placebo effect
17:32:34 <jmcarthur> i'm a coffee person. usually with cream, occasionally with a little sugar
17:32:36 <sbpaul> psychosomatic
17:32:37 <danharaj> administered in different amounts.
17:32:44 <sbpaul> yeah yeah
17:32:49 <sbpaul> drink less coffee ;)
17:32:55 <mreh> placebo effect == we don't know why it works
17:33:06 <mreh> it's not an explanation
17:33:07 <sbpaul> false
17:33:40 * ddarius doesn't tend to drink too many caffeinated drinks at all.  He certainly doesn't do it particularly when coding.
17:33:42 <monochrom> "I became a better programmer after learning haskell" is a placebo effect
17:33:45 <jmcarthur> placebo has many conflicting definitions
17:33:52 <sbpaul> i implemented RSA :)
17:33:57 <sbpaul> are you guys proud of me
17:34:03 <ddarius> I'm not sure if I've ever drank a caffeinated drink while coding.
17:34:05 <danharaj> We were always proud of you.
17:34:06 <mreh> only if you invented it
17:34:07 <ddarius> sbpaul: Nope.
17:34:08 * jmcarthur is proud of sbpaul
17:34:09 <danharaj> The true coder was in you all along!
17:34:09 <winxordie> sbpaul: I'd be proud if you thought of RSA
17:34:10 <sbpaul> one time i took DMT
17:34:13 <sbpaul> and learned python
17:34:20 <danharaj> Everyone knows python.
17:34:21 <sbpaul> uhhh
17:34:27 <danharaj> They just don't know that they know python.
17:34:30 <sbpaul> yeah well i didn't know it before i took DMT and learned it ;)
17:34:35 * jmcarthur drinks too much caffeine
17:34:44 <tensorpudding> then drink less!
17:34:48 <fax> "learn python" is an oxymoron
17:35:00 * jmcarthur gets up to make some coffee
17:35:06 <danharaj> What do stupid oxen have to do wit *is hit in the face with a tomato*
17:35:06 <tensorpudding> resist!
17:35:06 * sbpaul sighs
17:35:24 <sbpaul> do you guys know anything about aero/hydroponics
17:35:33 <sbpaul> i want to grow super avocados
17:35:33 <monochrom> No.
17:35:41 <mreh> you use them to grow drugs illegally
17:35:44 <tensorpudding> avocado's number
17:35:51 <sbpaul> mreh: you use them to grow plants
17:35:51 <monochrom> You want to stick to haskell here.
17:35:58 <sbpaul> with a controlled balance of nutrients
17:36:01 <danharaj> #haskell-drink-agriculture-chemistry-puns
17:36:10 <fax> lol <3
17:36:18 * hackagebot libxml-sax 0.4 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.4 (JohnMillikin)
17:36:32 <monochrom> Or you want to go to #haskell-blah
17:36:46 <danharaj> Yes sir, sorry sir right away sir.
17:37:02 <monochrom> I mean sbpaul's "I want to"blah
17:37:26 <sbpaul> i would implement the servo control system in haskell of course
17:37:37 <copumpkin> moo
17:38:40 <Wooga> @src length
17:38:40 <lambdabot> Source not found. My brain just exploded
17:39:16 <ddarius> > foldl' (const . succ) 0 [1,2,3]
17:39:17 <lambdabot>   3
17:39:21 <Wooga> is `length' hardcoded?
17:39:29 <monochrom> No.
17:39:37 <sbpaul> how do you define an infix function
17:39:49 <fax> is it softcoded
17:39:54 * twink chokes on specifying algebraic data types.
17:39:56 <danharaj> You can put any old function in backticks ` ` to make it infix.
17:40:05 <tensorpudding> > let (+.+) = (+) in 5 (+.+) 3
17:40:06 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:40:06 <lambdabot>    `GHC.Num.Num a'
17:40:06 <lambdabot>      aris...
17:40:16 <tensorpudding> err
17:40:18 <tensorpudding> fail
17:40:19 * hackagebot gnuidn 0.1 - Bindings for GNU IDN  http://hackage.haskell.org/package/gnuidn-0.1 (JohnMillikin)
17:40:23 <tensorpudding> > let (+.+) = (+) in 5 +.+ 3
17:40:24 <lambdabot>   8
17:41:19 * hackagebot gnutls 0.1 - Bindings for GNU TLS  http://hackage.haskell.org/package/gnutls-0.1 (JohnMillikin)
17:41:30 <Wooga> but how length is implementd?
17:41:39 <kmc> @src length
17:41:39 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:41:45 <Pseudonym> @hoogle length
17:41:45 <lambdabot> Prelude length :: [a] -> Int
17:41:45 <lambdabot> Data.ByteString length :: ByteString -> Int
17:41:45 <lambdabot> Data.List length :: [a] -> Int
17:41:46 <kmc> Wooga, what does "hardcoded" mean?
17:42:00 <Pseudonym> Hmm.  Is src not working?"
17:42:00 <lambdabot> Pseudonym: You have 1 new message. '/msg lambdabot @messages' to read it.
17:42:06 <kmc> Wooga, how about: length [] = 0; length (_:xs) = 1 + length xs
17:42:09 <jmcarthur> fax: i assume you are going for parameterized, first class modules for your haskelly language?
17:42:13 <kmc> that's not how it's actually defined in the Report
17:42:15 <kmc> but it's a simple definition
17:42:17 <monochrom> src usually doesn't work. don't count on it.
17:42:17 <Wooga> kmc: it is slower then a length
17:42:22 <fax> nah
17:42:26 <kmc> Wooga, ?
17:42:30 <Wooga> kmc: much slower
17:42:34 <kmc> Wooga, how do you mean?
17:42:36 <jmcarthur> yeah, i don't see how that would fit with also being GADTs
17:42:43 <jmcarthur> fax: what's your idea?
17:42:51 <kmc> Wooga, how do you propose to make it faster?
17:42:57 <Wooga> kmc: try length  [1..10000000] and myLength  [1..10000000]
17:43:03 * Pseudonym implemented a fully-functional search engine in 150 lines of Perl last week; src should be easy!
17:43:10 <kmc> Wooga, what's myLength?
17:43:11 <Wooga> where myLength is myLength []     = 0; myLength (_:xs) = 1 + myLength xs
17:43:24 <kmc> Wooga, actually, that *is* the definition in the Report
17:43:28 <Pseudonym> Is it?
17:43:32 <kmc> apparently
17:43:35 <Pseudonym> I thought it used accumulator recursion.
17:43:40 * ddarius implemented a full-text database and query interface in a few hundred lines of C++ years ago.
17:43:48 <Pseudonym> ddarius: Woo.
17:43:52 <Wooga> kmc: but length   [1..10000000] works when myLength  [1..10000000] stucks
17:44:15 <Wooga> so, length implemented differently
17:44:17 <Pseudonym> Perl has BER encoding for integers built in, so inverted index compression is easy.
17:44:24 <Wooga> but how exactly?
17:44:29 <Pseudonym> Wooga: Right, it uses accumulator recursion.
17:44:41 <Pseudonym> myOtherLength xs = myOtherLength' xs 0
17:44:42 <Pseudonym>   where
17:44:47 <Pseudonym>     myOtherLength' [] acc = acc
17:44:49 <ddarius> Yeah, I used a simple "variable length" integer "compression" as well.
17:45:01 <Pseudonym>     myOtherLength' (_:xs) acc = myOtherLength' xs (acc+1)
17:45:21 <Pseudonym> Wooga: You see how that works?
17:45:29 <kmc> :t foldl' (const . (+1)) 0
17:45:29 <ddarius> Or, one could use the definition I gave a couple pages ago.  length = foldl' (const . succ) 0
17:45:30 <lambdabot> forall a b. (Num a) => [b] -> a
17:45:39 <Wooga> Pseudonym: yet now, but i'll play with it in ghci
17:45:42 <Pseudonym> OK.
17:45:45 <Pseudonym> Also:
17:45:54 <Pseudonym> :t \xs -> sum [ 1 | x <- xs ]
17:45:54 <lambdabot> forall t t1. (Num t1) => [t] -> t1
17:46:05 <copumpkin> fancy
17:47:13 <Pseudonym> People don't use list comprehensions enough.
17:47:33 <ddarius> People use list comprehensions too much.
17:47:39 <kmc> :t sum . map (const 1)
17:47:40 <lambdabot> forall a a1. (Num a) => [a1] -> a
17:47:53 <kmc> no need to name x or xs ;)
17:47:58 <Pseudonym> Well, yes.
17:48:00 <jmcarthur> yeah i'm not a fan of list comprehensions most of the type
17:48:04 <wavewave> my Cabal library is broken..
17:48:04 <jmcarthur> *most of the time
17:48:05 <ddarius> > sum . (const 1 .) $ [1,2,3,4]
17:48:06 <lambdabot>   4
17:48:12 <monochrom> haha most of the type :)
17:48:21 <copumpkin> fix (cabalLibrary wavewave )
17:48:26 <Pseudonym> > last $ [1,2,3,4]
17:48:27 <lambdabot>   4
17:48:30 <Pseudonym> There you go!
17:48:35 * jmcarthur got haskelled!
17:48:44 <wavewave> copumpkin: :-)
17:49:07 <ddarius> :t  last . zipWith const [1..]
17:49:08 <lambdabot> forall a b. (Num a, Enum a) => [b] -> a
17:49:13 <wavewave> copumpkin: How can I upgrade Cabal library for system?
17:49:26 <djahandarie> > sum . (const 1 .) $ [1,1,1,1]
17:49:27 <lambdabot>   4
17:49:39 <wavewave> my package.conf.d in /usr/local has Cabal-1.8.0.2
17:49:57 <wavewave> my package.conf.d in home directory has Cabal-1.8.0.4
17:50:06 <Wooga> Pseudonym: both of your implementations much slower then original length on [1..10000000]
17:50:20 <Pseudonym> Wooga, did you compile them, though?
17:50:22 <sbpaul> > 26 `mod` 26
17:50:23 <lambdabot>   0
17:50:24 <wavewave> Cabal-1.8.0.2 has a dependency problem now..
17:50:27 <sbpaul> fascinating
17:50:30 <sbpaul> > 26 `rem` 26
17:50:31 <ddarius> Pseudonym: Probably not.
17:50:31 <lambdabot>   0
17:50:34 <Wooga> Pseudonym: yes, with ghci
17:50:39 <ddarius> So no.
17:50:39 <djahandarie> (lol)
17:50:54 <Pseudonym> Right.  GHCi compiles your script to STG, and the interprets the STG.
17:51:07 <Wooga> oh
17:51:09 <Pseudonym> The Prelude is compiled to object code.
17:51:33 <Pseudonym> I would imagine that especially at high -O levels, the code turns out to be identical to sum.
17:51:38 <Wooga> thanks! thats explains everything
17:52:09 <ddarius> Also, without the type annotations GHC will default to an Integer return type for myLength which will be much slower than an Int.
17:53:26 <wavewave> cabal upgrade is dangerous.
17:58:46 <wavewave> decided to install haskell-platform.
18:01:16 <monochrom> I stick with haskell-platform and don't upgrade its constituents piecemeal.
18:02:30 <wavewave> monochrom: I installed my ghc 6.12 before the platform..
18:03:00 <wavewave> monochrom: finally cabal upgrade break the peace. :/
18:05:45 <Pseudonym> http://emerginglangs.com/speakers/ <- Anyone going to this?
18:07:31 <wavewave> Other languages do not look as innovative as haskell. ;-)
18:07:52 <LeNsTR> (-:
18:07:57 <wavewave> didn't know so many 'emerging' languages..
18:08:11 <Pseudonym> Interesting that Newspeak and F# are "emerging".
18:08:25 <Pseudonym> And D.
18:08:27 <Pseudonym> And C#!
18:08:30 <Pseudonym> That's "emerging"?!
18:08:56 <tensorpudding> No Haskell on there?
18:09:05 <tensorpudding> Clojure and F# though.
18:09:06 <Pseudonym> When it's in the top N demanded languages on job adverts, for small N, it's not "emerging", it's "mainstream".
18:09:36 <danharaj> C# is emerging?
18:09:41 <Pseudonym> Apparently.
18:10:07 <danharaj> Any language that is useable in industrial strength programming isn't emerging.
18:10:14 <danharaj> That includes Haskell and C#
18:10:36 <dark> isn't emerging in the sense that is gaining acceptance?
18:10:55 <blackdog> see how many haskell job ads you see on your friendly neighbourhood job search site:)
18:11:10 <tensorpudding> A lot of these are a good bit obscure.
18:12:42 <Pseudonym> I have no problem with obscure.
18:13:01 <tensorpudding> But yeah, C# is very far and away from emerging.
18:13:19 <Pseudonym> Has anyone looked at Ur?
18:13:35 <Pseudonym> It says it's pure functional and statically-typed.
18:13:40 <tensorpudding> It claims to be like Haskell but has a richer type system.
18:13:49 <Pseudonym> And it's strict.
18:13:54 <tensorpudding> Also apparently is designed for the web
18:14:06 <blackdog> Pseudonym: that's adam chlipala's baby, right?
18:14:16 <blackdog> i think it's pretty close to haskell
18:14:19 <danharaj> and also it can feed your dog and take it for walks
18:14:23 <Pseudonym> Oh, is it?
18:14:27 <Pseudonym> Cool.  We like Adam.
18:14:33 <gwern> we do?
18:14:38 <danharaj> If it's close to Haskell why didn't he just contribute to Haskell?
18:14:47 <Pseudonym> He used to.
18:14:49 <danharaj> It'd be better for functional programming to concentrate efforts on the language that works and is already here :p
18:14:51 <gwern> danharaj: my thought exactly. I say we declare him anathema
18:15:02 <wavewave> I dare to say all the emerging languages are influenced by haskell.
18:15:02 <gwern> by bell, book, and candle!
18:15:04 <danharaj> Well if he used to, I can't blame him for being a visionary.
18:15:08 <Pseudonym> gwern: He probably called it "Ur" because it's obsolete and crumbling.
18:15:11 <blackdog> the same reason we defected from other languages
18:15:15 <gwern> Pseudonym: ouch
18:15:28 <tensorpudding> "Stop writing a new language, and focus on the language everyone else is using" is a bad argument.
18:15:29 <danharaj> I have not defected from anything. I still love C++ even though it beats me. Stockholm syndrome?
18:15:34 <Pseudonym> Anyway.  Yes, if we didn't have Gofer, we wouldn't have modern Haskell.
18:15:40 <blackdog> Ur also means primal, or fundamental...
18:15:50 <Pseudonym> danharaj: I like C++ and it doesn't beat me.
18:15:53 * imc is happy
18:15:55 <tensorpudding> ur-elements for instance
18:16:12 <gwern> tensorpudding: it's a perfectly good argument. writing a new language is like buying lottery tickets
18:16:13 <danharaj> tensorpudding: That's not exactly my argument it's "If you want to do research, do it in the context of the language that has a lot of support and activity from like minded people whom you can share ideas with."
18:16:19 <Pseudonym> C++ hits a sweet spot in programming languages.  There's no shame in it.
18:16:30 <danharaj> It has some problems, that are also huge strengths.
18:16:31 <gwern> tensorpudding: are the few winners really justification for the many losers' foolishness?
18:16:36 <danharaj> Mostly relating to keeping C as a subset.
18:16:43 <tensorpudding> How do you know when it's worthwhile making a new language?
18:16:45 <danharaj> The disadvantage is that C is a subset. The advantage is that C is a subset.
18:16:45 <Pseudonym> danharaj: Exactly!  That's its weakness and its strength.
18:17:01 <gwern> tensorpudding: how do you know when it's worthwhile to buy a particular lottery ticket?
18:17:03 <danharaj> It could use a stronger type system though. Like getting rid of implicit casts.
18:17:29 <tensorpudding> By this argument, why should Haskell have been designed?
18:17:36 <Pseudonym> danharaj, I agree.  The keyword should have been "implicit" rather than "explicit".
18:17:42 <Pseudonym> tensorpudding: Because Miranda was closed.
18:17:44 <blackdog> i got the impression that Ur and Disciple were mining the same space. wonder why they haven't collaborated, acutally.
18:17:49 <tensorpudding> What reasons for making a language are "good enough"
18:17:53 <gwern> tensorpudding: as Pseudonym says, a proven concept
18:17:56 <wavewave> sooner or later, haskell may contain C as an EDSL.
18:17:56 <danharaj> Because a bunch of people came together and said "Hey let's take all our languages and make one language that fits for all of us"
18:18:09 <danharaj> Community is all you need.
18:18:13 <Pseudonym> Yeah, Haskell is itself a compromise.
18:18:30 <Pseudonym> A bunch of researchers made their own Miranda-alikes to hack on because Turner wouldn't play nice.
18:18:46 <Pseudonym> And Haskell became the consolidation of all of those programming languages.
18:19:00 <tensorpudding> Haskell is not a language without flaws.
18:19:08 <Pseudonym> Of course.
18:19:14 <wavewave> definitely..
18:19:18 <Pseudonym> The module system being the most obvious one.
18:19:23 <danharaj> It isn't but improving Haskell, modifying Haskell, and extending Haskell is more fruitful than going it alone.
18:19:36 <danharaj> It's a two-way relationship. You help the Haskell community, and it helps you.
18:20:02 <danharaj> Pseudonym: Also, it needs algebraic datatypes and first class functions. Then it would be awesome. :D
18:20:30 <tensorpudding> Haskell will eventually be replaced.
18:20:37 <wavewave> I hope type class as a first class citizen..
18:21:45 <danharaj> By Haskell 2 and with the blessing of the entire community.
18:21:46 <wavewave> so that I can hand type class as an argument..
18:22:01 <tensorpudding> Unlikely
18:22:08 <tensorpudding> When has that ever happened?
18:22:39 <Pseudonym> Well, Haskell was essentially replaced during some of the early language revisions.
18:22:45 <wavewave> it doesn't have to be with the same name..
18:22:48 <Pseudonym> For example, when we cut over to monadic IO.
18:22:53 <tensorpudding> It was too small back then.
18:22:55 <danharaj> Early on it happens easily
18:23:13 <danharaj> later on, when there are people using your language and billions of lines of code to maintain, it happens very slowly.
18:23:15 <Pseudonym> Yeah.
18:23:21 <gwern> simulated annealing
18:23:27 <wavewave> if it is consistent with the development line... I would call it as a haskell.
18:23:28 <Pseudonym> I don't think that the associativity of ($) will ever get fixed.
18:23:29 * hackagebot network-protocol-xmpp 0.3 - Client <-> Server communication over XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.3 (JohnMillikin)
18:23:50 <danharaj> fixed? what's wrong with it? Also changing it would break billions of lines of code. :p
18:23:59 <danharaj> And we're measuring haskell code, so billions is a really big number.
18:24:14 <Pseudonym> danharaj: ($) should be left-associative, just like real application.
18:24:28 <Pseudonym> And it wouldn't break billions of lines of code.  More like thousands.
18:24:35 <gwern> I don't think there's a billion lines of code in haskell :)
18:24:48 <danharaj> billion-c-lines equivalent then :p
18:24:52 <danharaj> So.. like 12?
18:25:11 <ddarius> danharaj: Many uses of ($) don't actually need it to be associated one way or another.
18:25:17 <Pseudonym> Yes.
18:25:24 <wavewave> future of haskell may be dependent type..
18:25:33 <Pseudonym> This is an old discussion, anyway.
18:25:34 <fax> no I don't think so
18:25:37 * gwern sets a find|wc off to tell me how many lines of haskell code I do actually have
18:25:39 <fax> the future of haskell is to continue being haskell
18:25:58 <fax> the future of a lot of haskell programming might well be to use dependent types
18:25:59 <danharaj> being haskell entails having a bunch of cutting edge experimental type extensions
18:25:59 <wavewave> fax: okay, let me say future of some direction ;-)
18:26:04 <fax> but haskell will not change to that
18:26:05 <Pseudonym> Nobody has yet come up with a cogent argument that the associativity of ($) is correct or more desirable than the alternative.  The only argument for not changing it which makes any sense is backwards compatibility.
18:26:12 <Pseudonym> And it's a pretty compelling argument, to be sure.
18:26:49 <wavewave> but before the era of dependent type, we need many experiments and tools, something like that.
18:27:17 <gwern> I guess we also need them to be more efficient
18:28:44 <gwern> wc tells me that I have 4948208 raw lines of code
18:29:02 <danharaj> That you have written?
18:29:08 <gwern> no, of course not
18:29:12 <gwern> local repos
18:29:12 <wavewave> wow.
18:29:15 <danharaj> Who knows, maybe you're a super coder :p
18:29:22 <ddarius> gwern: How much duplication though?
18:29:47 <blackdog> Pseudonym: forgive a dumb question - what would $ being left associative let you write?
18:29:50 <gwern> ddarius: on the repo level? less than 10 repos are dups I think
18:30:58 <sanyi> what's up with code.haskell.org today?
18:31:02 <fax> dead
18:31:05 <benl23> community.haskell.org has gone awol again
18:31:13 <sanyi> ...
18:31:15 <benl23> .. just what I was saying
18:31:25 <gwern> mistah kurtz, he dead
18:31:32 <benl23> apache needs to be restarted
18:31:49 <danharaj> It must be using ruby on rails.
18:31:51 * danharaj rimshot
18:32:03 <nus> that's what you get for having both mod_perl and mod_python :-P (-:
18:32:08 <gwern> a penny for the old guy
18:32:18 <wavewave> I hope that it will be replaced by happstack soon. :)
18:32:39 <sanyi> it's not just the site, darcs is dead too
18:32:45 <ddarius> If by soon, you mean within the next decade, then yeah, that's not going to happen.
18:32:53 <gwern> sanyi: same thing
18:32:57 <DigitalKiwi> Ba-dum tschh! http://www.instantrimshot.com/
18:35:40 <sbpaul> does wolfram have like, a secret island
18:35:43 <sbpaul> with concubines, or something
18:36:00 <fax> porkypines
18:36:13 <gwern> he has a secret island, but it's filled with computers running CAs
18:36:18 <gwern> he rubs himself against them
18:36:30 <DigitalKiwi> that's disturbing on so many levels
18:36:44 <Pseudonym> My wife used to work a couple of floors down from Wolfram.
18:36:59 <DigitalKiwi> was she one of his concubines?
18:37:03 <Pseudonym> I shall ask her about the concubines.  I don't think that any were seen going in and out.
18:37:07 <sbpaul> pseudonym were we talking in PM about two weeks ago
18:37:08 <wavewave> Did he know haskell? :)
18:37:15 <danharaj> Wolfram is a tool.
18:37:24 <DigitalKiwi> (who is Wolfram?)
18:37:25 <danharaj> But I shouldn't get political.
18:37:32 <Pseudonym> Wolfram would be considered a kook if he wasn't such a good toolsmith.
18:37:34 <fax> that's not what I would call political
18:37:50 <Pseudonym> No, I wouldn't call him a tool.  I'd call him a crank.
18:37:57 <Pseudonym> Not the same thing at all.
18:38:06 <danharaj> He's a jerk too. He forces people who do research at his company to attribute their results to him.
18:38:07 <wavewave> Wolfram = Mathematica creator.
18:38:24 <Pseudonym> And author of the way-too-long-and-self-important book, "A New Kind of Science".
18:38:24 <danharaj> Also he likes to brag about how young he was when he got his phd.
18:38:45 <DigitalKiwi> so he's a modern day uh
18:38:50 <DigitalKiwi> crap i can't think of the name :(
18:38:53 <Pseudonym> Which at 1200 pages or so, is about 900 pages too long considering the importance of the material that it covers.
18:39:03 <DigitalKiwi> thomas eddison (sp?)
18:39:10 <Pseudonym> No, Thomas Edison had patents.
18:39:21 <Pseudonym> Not the worst comparison that I can think of, mind.
18:39:22 <DigitalKiwi> but he made people attribute their work to him
18:39:24 <wavewave> interesting, I just skimmed his book today at the bookstore.
18:39:27 <Pseudonym> So did Disney.
18:39:56 <Pseudonym> ANKOS has, at its core, a much shorter and much more interesting book with a less wanky title.
18:40:00 <sbpaul> hmm
18:40:00 <danharaj> Edison was a dick too, to Tesla.
18:40:02 <wavewave> It was filled with automata figures.. in my skimming.
18:40:04 <Pseudonym> Well, yes.
18:40:19 <danharaj> Lots of dicks throughout history and the present :p
18:40:26 <sbpaul> how do i feed a string into two character long bits?
18:40:29 <sbpaul> lists of lists
18:40:32 <Pseudonym> Wolfram, though, is a very good toolsmith.  Mathematica is brilliant.
18:40:35 <gwern> > let f (a,b,c,d) = let x = (c+d,a,b,c) in [x,f x] in f (1,1,1,1)
18:40:37 <lambdabot>   Couldn't match expected type `(t, t, t, t)'
18:40:37 <lambdabot>         against inferred type `...
18:40:43 <Pseudonym> Mind you, he hires clever people.
18:40:51 <Pseudonym> But he's also a crank.
18:40:53 <sbpaul> it has something to do with that
18:40:57 <sbpaul> mmn
18:41:01 <sbpaul> ah
18:41:02 <DigitalKiwi> you know who is a dick? Vice President Cheney
18:41:10 <gwern> > let f (a,b,c,d) = (let x = (c+d,a,b,c) in [x, f x]) in f (1,1,1,1)
18:41:11 <danharaj> heh NOW we're political
18:41:11 <lambdabot>   Couldn't match expected type `(t, t, t, t)'
18:41:11 <lambdabot>         against inferred type `...
18:41:14 <sbpaul> anybody who's job is to lead a criminal enterprise is probably a dick
18:41:18 <sbpaul> whose
18:41:31 <sbpaul> names aside
18:41:31 <jmcarthur> man, this place isn't politically charged at all
18:41:32 <DigitalKiwi> hey i speak truths!
18:41:38 <Pseudonym> Except Steve Jobs.  He's a perfectly benevolent dictator who has never done any evil.
18:41:48 <DigitalKiwi> *snark*
18:41:50 <jmcarthur> (i don't disagree with said political misgivings, however)
18:41:50 <sbpaul> Pseudonym: uhh
18:41:53 <Pseudonym> :-)
18:41:59 <sbpaul> where did i put that image
18:42:11 <gwern> > let f (a,b,c,d) = (let x = (c+d,a,b,c) in [x] ++ f x) in f (1,1,1,1)
18:42:12 <lambdabot>   [(2,1,1,1),(2,2,1,1),(2,2,2,1),(3,2,2,2),(4,3,2,2),(4,4,3,2),(5,4,4,3),(7,5...
18:42:31 <danharaj> ok, I finished my paper.
18:42:31 <gwern> :t (%)
18:42:32 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
18:42:42 <danharaj> Anyone want to help me build wxHaskell on windows?
18:42:47 <gwern> > 10+1 `mod` 10
18:42:48 <lambdabot>   11
18:42:56 <fax> hehe
18:42:58 <gwern> > (10+1) `mod` 10
18:42:59 <lambdabot>   1
18:43:01 <sbpaul> anybody rememebr the syntax to do this
18:43:06 <sbpaul> it's like
18:43:11 <gwern> > let f (a,b,c,d) = (let x = ((c+d)`mod`10,a,b,c) in [x] ++ f x) in f (1,1,1,1)
18:43:12 <lambdabot>   [(2,1,1,1),(2,2,1,1),(2,2,2,1),(3,2,2,2),(4,3,2,2),(4,4,3,2),(5,4,4,3),(7,5...
18:43:21 <sbpaul> > let stringBiter string = x: stringBiter xs
18:43:22 <lambdabot>   not an expression: `let stringBiter string = x: stringBiter xs'
18:43:27 <sbpaul> @let stringBiter string = x: stringBiter xs
18:43:28 <lambdabot>  <local>:7:36: Not in scope: `xs'
18:43:31 <gwern> I wonder how long it takes that to repeat
18:43:35 <sbpaul> somebody knows what i mean :(
18:43:40 <DigitalKiwi> Bjarne is the real evil one here!
18:43:44 <DigitalKiwi> http://harmful.cat-v.org/software/c++/I_did_it_for_you_all
18:44:29 <gwern> for the lulz
18:44:38 <sbpaul> Pseudonym: http://i39.tinypic.com/2vwah6c.gif
18:44:44 <wavewave> I hate QuickCheck 1.0 | 2.0 divide... :/
18:45:03 <BMeph> gwern: Just curious, but do you Hate the ':' operator? ;)
18:45:11 <danharaj> Digital: Is that a parody site? :p
18:45:15 <gwern> BMeph: yes
18:45:21 <gwern> BMeph: it's obscene
18:45:24 <DigitalKiwi> http://i.imgur.com/3JmjP.jpg
18:45:35 <DigitalKiwi> danharaj: some of it is for realz
18:45:35 <gwern> 0-:<
18:46:09 <sbpaul> steve jobs is a megalomaniac
18:46:11 * BMeph was not aware of any prurient symbolism in the ':' operator. Although, its name is 'colon'...
18:46:14 <sbpaul> also he's ugly
18:46:23 <DigitalKiwi> http://harmful.cat-v.org/software/c++/linus <-- can be found in mailing list archives
18:46:26 <fax> copula
18:46:30 <sbpaul> oh that's what it is
18:46:30 <gwern> BMeph: : are mammary glands! concealed in plain sight!
18:46:31 <wavewave> I really want to have a tablet with a 'pen'
18:46:39 <wavewave> I don't like iPad at all..
18:46:48 <wavewave> I don't like multi-touch at all.
18:46:58 <fax> http://en.wikipedia.org/wiki/Copula_(linguistics)
18:47:12 <DigitalKiwi> sex would be so boring if you could only touch one thing at a time
18:47:13 <sbpaul> @let stringBiter (x:xx:xxx) = x:xx:stringBiter xx:xx
18:47:14 <lambdabot>  <local>:7:30:
18:47:14 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]...
18:47:16 <fax> well I guess that really names :: but of course : and :: are swappe wrongly in haskell
18:47:20 <sbpaul> i hate haskell
18:47:29 <fax> yeah stupid haskell
18:47:39 <DigitalKiwi> who uses that crap anyway>
18:47:40 <DigitalKiwi> ?
18:47:51 <sbpaul> @let stringEater (x:xs) = x:stringEater xs
18:47:52 <danharaj> word.
18:47:53 <lambdabot>  Defined.
18:47:58 <sbpaul> mmn yes
18:47:59 <danharaj> I wonder what Linus thinks about darcs :p
18:48:06 <wavewave> but if multi-touch is much worse than single touch?
18:48:22 <sbpaul> i need to separate it into 2 tuples >:O@O@OOOOOO
18:48:25 <Pseudonym> danharaj: He thinks it's a toy.
18:48:28 <gwern> danharaj: 'absurdly slow and insecure'
18:48:29 <DigitalKiwi> http://markmail.org/thread/vk3gf7ap5auxcxnb
18:48:46 <Pseudonym> He's a bit nicer about Mercurial, but it still doesn't do what he wants.
18:48:47 <DigitalKiwi> luckily this thing called the internets allows for such queries ;p
18:49:15 <wavewave> is darcs still slow? I heard 2.4 has much improvement.
18:49:43 <sbpaul> @let stringEater (x:xx:xs) = x++xx++stringEater xs
18:49:44 <lambdabot>  <local>:8:31:
18:49:44 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]...
18:49:46 <danharaj> I suppose slow is a valid criticism, but if a project like ghc can deal with it...?
18:50:12 <siracusa> sbpaul: Can you give an example of what you want?
18:50:45 <sbpaul> SDOIGHSD -> [[S,D],[O,I],[G,H],[S,D]]
18:50:48 <gwern> wavewave: still slow compared to git
18:50:55 <gwern> better than it used to be though
18:51:06 <copumpkin> moar olegs
18:51:12 <DigitalKiwi> mercurial is python darcs is haskell or?
18:51:15 <wavewave> gwern: I imagine it..
18:51:35 <DigitalKiwi> my only quam with git is that it is perl
18:51:40 <gwern> c
18:51:43 <DigitalKiwi> and perl makes baby jesus cry :(
18:51:50 <DigitalKiwi> it is both c and perl
18:52:00 <sbpaul> siracusa: ^
18:52:04 <Pseudonym> The evil mangler is written in Perl.
18:52:15 <gwern> Pseudonym: yeah but how often does anyone use that?
18:52:35 <Pseudonym> Behind the scenes?  A lot.
18:52:43 <danharaj> C I can take. Perl I can stomach. Both at the same time?
18:52:48 <DigitalKiwi> evil mangler?
18:52:50 <gwern> Pseudonym: I thought it was only for -fvia-c
18:52:55 <Pseudonym> Oh, yeah.
18:52:56 <DigitalKiwi> ghc requires perl too? :(
18:52:58 <Pseudonym> You're right.
18:53:18 <gwern> and -fvia-c isn't much used anymore
18:53:27 <gwern> -fasm and soon -fllvm all the way! :)
18:53:33 <Pseudonym> So the evil mangler is probably mostly used for bootstrapping a new architecture these days.
18:53:53 <gwern> and how often does *that* happen?
18:53:54 <DigitalKiwi> -fasm is good?
18:53:56 <Pseudonym> @quote mangler
18:53:56 <lambdabot> Pseudonym says: All hail the Evil Mangler!
18:53:59 <Pseudonym> @quote mangler
18:53:59 <lambdabot> Pseudonym says: All hail the Evil Mangler!
18:54:00 <copumpkin> -org
18:54:08 <gwern> DigitalKiwi: it's sometimes worse than -fvia-c
18:54:09 <Pseudonym> Hmm.  There is another quote in there.
18:54:10 <Pseudonym> @quote mangler
18:54:10 <lambdabot> Pseudonym says: All hail the Evil Mangler!
18:54:13 <copumpkin> -orgC
18:54:17 <copumpkin> -orgvia-C
18:54:18 <Pseudonym> Apparently not in the database.
18:54:21 <DigitalKiwi> is it usually better than without?
18:54:31 <gwern> DigitalKiwi: but the point is that -fasm has nothing to do with perl and is haskell/ghc all the way
18:55:07 <DigitalKiwi> so ghc needs perl for -fvia-c ?
18:55:11 <gwern> basically
18:55:17 <DigitalKiwi> ah
18:55:34 <DigitalKiwi> still curious about the -via options
18:55:42 <DigitalKiwi> asked about them a few days ago but nobody really answered :(
18:55:55 <Pseudonym> DigitalKiwi: The STG machine requires a small amount of data to be stored just before the entry point in the code segment.
18:56:02 <DigitalKiwi> i got a bunch of command line options for using them! but that's not what i wanted :(
18:56:10 <Pseudonym> The "T" means "tagless".
18:56:19 <DigitalKiwi> and the S and G?
18:56:23 <copumpkin> spineless
18:56:24 <copumpkin> like me
18:56:26 <copumpkin> and g-machine
18:56:29 <copumpkin> like g-unit
18:56:32 <Pseudonym> Which means Graph.
18:56:38 <DigitalKiwi> g g g g gunnt
18:57:04 <DigitalKiwi> anyway so a few questions while we are talking about it
18:57:12 <Pseudonym> Data objects aren't tagged with a pointer to an object descriptor, they're tagged with a pointer to code.
18:57:24 <Pseudonym> So if you need the object descriptor, you take the pointer and subtract a known offset to get to it.
18:57:26 <DigitalKiwi> when you use the via options, what happens, what is the result, should they be used, when should they not be used, etc.
18:57:43 <dolio> Graph unit?
18:57:55 <siracusa> sbpaul: I thought there was a function somewhere for that, but I can't find one.
18:57:56 <Pseudonym> DigitalKiwi: You shouldn't use them unless you need them.
18:57:59 <Pseudonym> :-)
18:58:08 <Pseudonym> Generally speaking, the default is best for your platform.
18:58:21 <ManateeLazyCat> I was think Haskell compiler's optimize problem, for "data depend expression" such as "a -> IO b", i think Haskell compiler will do some optimize like other language's, for "data undepend expression" like all pure function, Haskell compiler how to decide which expression calculate first? Or random completely? Or have other rules?
18:58:27 <siracusa> sbpaul: But you can do something like:
18:58:29 <siracusa> > let f (x:y:xs) = [x,y] : f xs; f _ = [] in f "abcdef"
18:58:30 <lambdabot>   ["ab","cd","ef"]
18:58:31 <ManateeLazyCat> Just interested this .
18:58:53 <DigitalKiwi> hrm, are there jit for haskell? or is that what hugs is?
18:59:03 <Cale> map (take 2) . takeWhile (not . null) . iterate (drop 2)
18:59:09 <nus> ManateeLazyCat, your english broke my parser
18:59:15 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ "abcdef"
18:59:16 <lambdabot>   ["ab","cd","ef"]
18:59:58 <ManateeLazyCat> nus: So simple, how to decide which *pure* expression run first?
19:00:11 <Cale> ManateeLazyCat: Lazy evaluation is outermost-first
19:00:13 <DigitalKiwi> hmm, if you take an infinite list and continually remove items from it by an infinitely increasing amount, you should end up with an empty list sometime right? :D
19:00:26 <Cale> ManateeLazyCat: So start at the left of the expression, and evaluate the first thing you see
19:00:33 <copumpkin> nus: Has anyone really been far as decided to use even go want to do look more like?
19:01:01 <danharaj> digitalkiwi:If you formalize a way of taking limits of operations, you could probably prove that. :p
19:01:12 <nus> copumpkin, are you using coverbs too?-)
19:01:13 <Cale> ManateeLazyCat: However, GHC doesn't work that simply. It makes some computations strict when it is provably valid to do so.
19:01:46 <sevs> hey...I am trying to troubleshoot a cabal problem with 0.8 and GHC 6.12
19:01:58 <Cale> ManateeLazyCat: But of course, evaluation order doesn't really matter, as long as you're careful to choose an order which terminates whenever possible.
19:02:15 <sevs> whenever I try to install a package or update cabal I get cabal: failed to parse output of 'ghc-pkg dump'
19:02:17 <Cale> (It affects performance, but not the end result of the computation)
19:02:32 <DigitalKiwi> actually i kind of made that as a joke but i am curious, the infinite list has to be generated right? and you can 'take' from the list, so what happens if the producer is slower than the consumer?
19:02:47 <sevs> i tried what I found on the internet that was supposed to fix it...but no dice
19:02:49 <Cale> sevs: It sounds like you're using a cabal from a different GHC than it was made for.
19:03:11 <Cale> ghc-pkg --version
19:03:24 <ManateeLazyCat> Cale: Even for IO monad, ghc looks do some lazy evaluation, example, i got segment-fault with STM code, and truth is not STM is wrong, it's value trigger segment-fault.
19:04:11 <Cale> ManateeLazyCat: Nothing should ever cause a segmentation fault except possibly FFI.
19:04:31 <Cale> (Obviously you can cause segmentation faults while manipulating Ptr values)
19:04:39 <ManateeLazyCat> Cale: Yes.
19:04:53 <copumpkin> or unsafeCoerce
19:04:59 <Cale> But if STM is giving you a segmentation fault, that's a bug in the compiler.
19:05:20 <ManateeLazyCat> Cale: ?
19:05:30 <Cale> Perhaps I don't understand what's happening...
19:05:31 <dolio> unsafeCoerce won't cause segfaults if you use it for what it's actually for.
19:05:38 <ManateeLazyCat> Cale: I got segmentation fault when i do readTVarIO.
19:05:44 <danharaj> Nothing will cause segfaults if you use it correctly :p
19:05:57 <copumpkin> ./makeSegfault
19:06:01 <copumpkin> that will!
19:06:09 <ManateeLazyCat> Cale: I think problem is not STM code, because `readTVarIO` do "TVar a -> IO a"
19:06:09 <danharaj> Curses I have been refuted.
19:06:18 <ManateeLazyCat> Cale: I think key is "IO a"
19:06:22 <Pseudonym> unsafeSegfault#
19:06:52 <Cale> ManateeLazyCat: That should never ever segfault.
19:06:59 <Cale> ManateeLazyCat: So you've found a bug.
19:07:02 <ManateeLazyCat> Cale: When got "IO a", and GHC-6.12.2 break some gtk2hs code, then perhaps (i guess) access some null pointer, then got segmentation fault.
19:07:14 <Cale> Oh, you're using gtk2hs
19:07:31 <nus> so, ffi, as sai
19:07:33 <nus> said
19:07:37 <copumpkin> moo
19:07:42 <DigitalKiwi> oom
19:07:44 <Cale> gtk2 isn't threadsafe
19:08:12 <Cale> You should be careful that all your calls to GTK operations are from the same thread.
19:08:24 <nus> @where c2hs
19:08:24 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
19:08:34 <ManateeLazyCat> Cale: Yes, i know, i send all Gtk+ function to main thread.
19:08:39 <Cale> hmmm
19:09:06 <Cale> This would be something to talk to dcoutts about, I think.
19:09:16 <Cale> (Or maybe someone else who works on gtk2hs...)
19:09:21 <ManateeLazyCat> Cale: I never use run Gtk+ code with multi-threads, when i run Gtk+ code with STM something, i will use `idle` function wrap it, make sure all Gtk+ function evaluation in main thread.
19:09:35 <ManateeLazyCat> Cale: I think i found a bug of ghc-6.12.2
19:09:40 <Cale> But readTVarIO shouldn't ever cause a segfault, yeah.
19:09:59 <ManateeLazyCat> Cale: I haven't test same code with 6.12.1, works fine.
19:10:09 <danharaj> ?
19:10:20 <ezyang> What would an efficient persistent functional queue look like?
19:10:36 <danharaj> Is that a philosophical question?
19:10:41 <Cale> ezyang: Okasaki has written a good deal about that
19:10:42 <ezyang> Not really
19:10:47 <ManateeLazyCat> Cale: And looks not just STM code, looks segmentation fault is *random*, and just trigger this error when i call Gtk+ function.
19:10:57 <ezyang> Cale: Ok, I'll look.
19:11:09 <Cale> http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#jfp95
19:11:09 <ezyang> But I suppose that means I'm not getting O(1) ops...
19:11:20 <Cale> Nope, you can get O(1)
19:11:24 <ezyang> oh, wow
19:11:24 <ManateeLazyCat> Cale: I haven't test deeply, but looks 6.12.2 break gtk2hs binding code to make we access null pointer.
19:11:39 <ezyang> <3 Okasaki
19:11:52 <danharaj> <3 japanese computer scientists
19:12:03 <danharaj> <3 japanese giant robots
19:12:41 <gwern> <3 catgirls
19:12:44 <DigitalKiwi> <3 japanese *
19:13:09 <ManateeLazyCat> Cale: I have check `readTVarIO` source code, "readTVarIO (TVar tvar#) = IO $ \s# -> readTVarIO# tvar# s#"
19:13:12 <copumpkin> omnom
19:13:15 <Cale> ezyang: Okay, the obvious way to implement a queue which is O(1) only when you amortise, is just with a pair of lists: one in forward order, and one in reverse
19:13:36 <ManateeLazyCat> Cale: Author said it's equal "readTVarIO = atomically . readTVar" , but much faster.
19:13:39 <Cale> ezyang: and whenever you dequeue an item, and the back part is empty, you flip the front of the queue over onto it
19:14:02 <Cale> ezyang: But that occasionally incurs an O(n) cost
19:14:13 <Cale> (even though it averages out to O(1))
19:14:24 <ezyang> Cale: I'm reading the paper :-)
19:14:37 <ezyang> Incremental computation; cool stuff.
19:14:42 <copumpkin> I think CLRS covers that queue <- two lists thing too
19:14:43 <Cale> ezyang: Yeah, basically, you just do some tricks to make sure things stay balanced
19:14:49 <copumpkin> I remember doing it for algorithms homework ages ago
19:15:24 <DigitalKiwi> ugh algorithms :(
19:15:37 <ezyang> Yay algorithms! :)
19:15:44 <gwern> DigitalKiwi: shut yo mouth
19:15:59 <gwern> don't you be talking smack about no al-kwarizisms
19:16:13 <DigitalKiwi> i would if i hadn't spent 2 days trying to figure out how to turn two recursive functions into iterative ones! :(
19:16:15 <ManateeLazyCat> Use readTVarIO replace my "readTVarIO = atomically . readTVar"
19:16:23 <DigitalKiwi> and still not done it :(
19:16:27 <DigitalKiwi> and almost out of time :(
19:16:27 <gwern> DigitalKiwi: that's your own fault
19:16:29 <dolio> The amortized complexity depends crucially on lazy evaluation, too, as I recall.
19:16:41 <dolio> So you can rub it in nay-sayers faces.
19:17:05 <Cale> ezyang: another way, which I suspect would have much worse constant factors would be to just use a fingertree
19:17:21 <Cale> ezyang: Though I'm not certain about that. It might be just fine.
19:17:31 <Cale> You could take advantage of Data.Sequence
19:17:33 <ezyang> Yeah, Finger Trees sounded also useful
19:17:44 <ezyang> but they're a bit heavy, imo
19:17:46 <Cale> I've occasionally just used Data.Sequence as a queue directly
19:17:53 <Cale> and it works fine
19:20:06 <Cale> It has the advantage that it supports many other operations in log time.
19:20:13 <Cale> Like, splitting anywhere in the middle
19:20:15 <ManateeLazyCat> Cale: So pure component will got high parallel performance, because they're "data un-depend", right?
19:20:55 <Cale> ManateeLazyCat: Only if you annotate it to tell GHC which parts to evaluate in parallel of course.
19:23:55 <BMeph> Is there an already-named function that does this: do { x <- f ma; g ma; return x} ?
19:24:25 <ManateeL`> Cale: I see why someone suggestion me extract pure algorithm from IO function.
19:24:31 <ManateeL`> s/suggestion/suggest
19:24:54 <dolio> @type (<*)
19:24:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
19:25:48 <BMeph> dolio: Hmm, I'm rxperiment - thanks for the reminder. :)
19:26:00 <BMeph> *experiment
19:27:08 * BMeph wonders if jon is going to try Clojure instead...
19:28:04 <Jonno_FTW> ?
19:28:27 <Cale> (as opposed to arc ;)
19:29:15 <danharaj> So I tried to build wxhaskell a few days ago and I failed. I'm on win7. Anyone on hand for help as I try again?
19:30:14 <ManateeL`> danharaj: Can you try gtk2hs on win7? Because gtk2hs can install by Cabal.
19:30:16 <gwern> I liked the 'invisible arc' lolgraham
19:31:00 <danharaj> You can install wx via cabal as well. actually you need to install wxwidgets manually. Can you do everything by cabal for gtk2hs?
19:31:14 <ManateeL`> danharaj: Yes.
19:31:23 <gwern> danharaj: they're working on it. sort of. some people can
19:31:35 <ManateeL`> danharaj: Just get darcs version, and them do "./bootstrap.sh"
19:31:41 <danharaj> ah. Well I like some things about wx on windows better than gtk.
19:31:46 <ManateeL`> danharaj: it will build everything for you.
19:31:53 <danharaj> So I'll try this before I try gtk
19:32:13 <Cale> wx is also installable via cabal isn't it?
19:32:27 <danharaj> yeah but you have to build the C++ part yourself first
19:32:29 <gwern> ...sort of. it is, but unreliably
19:32:33 <ManateeL`> danharaj: If wx failed, you can try gtk2hs, i have test it with Linux/ghc-6.12.1 works fine.
19:32:38 <Cale> huh
19:32:46 <Cale> Maybe it's easier on linux
19:32:48 <ManateeL`> danharaj: And i saw some guys have install gtk2hs on Windows and Mac.
19:32:51 <danharaj> Probably :p
19:32:54 <gwern> Cale: no kidding!
19:33:12 <danharaj> What's the term for a haskell programmer?
19:33:18 <danharaj> Other than 'fool' ;p
19:33:25 <copumpkin> mathematician
19:33:32 <danharaj> I said other than 'fool' :D
19:33:36 <Veinor> haskeller?
19:33:38 <DigitalKiwi> everything is easier on linux!
19:33:51 <DigitalKiwi> except running windows only software
19:33:56 <DigitalKiwi> but who needs that anyway!
19:33:59 <Veinor> I use haskell programmer
19:34:01 <Jonno_FTW> gamers
19:34:01 <copumpkin> omg it's a Veinor
19:34:05 <Veinor> DigitalKiwi: I like video games
19:34:09 <Veinor> omg a copumpkin :O
19:34:10 <Jonno_FTW> haskelletor?
19:34:12 * ManateeL` I'm a Windows hater. ;-)
19:34:17 <danharaj> ok I really like Haskelletor.
19:34:21 <danharaj> I'm using that.
19:34:23 <DigitalKiwi> i much prefer doors
19:34:26 * Jonno_FTW is a windows sympathiser
19:34:28 <DigitalKiwi> windows let in raptors
19:34:37 <DigitalKiwi> i know this, from watching Jurassic Park
19:34:47 <danharaj> I use win7 because I like it and don't want to relearn how to use a computer and also want laymen to use my projects :p
19:34:53 <gwern> DigitalKiwi: the doors let them in too
19:34:58 <DigitalKiwi> and reading randall munroe comics and watching his hour video on google talks, but it is awesome!
19:35:01 <gwern> the key is to always keep neurotoxins around
19:35:11 <DigitalKiwi> gwern: not after you hack the unix system and lock the doors
19:35:21 <gwern> DigitalKiwi: but do you know this?
19:35:23 <ManateeL`> DigitalKiwi: Linux give you freedom. :)
19:35:33 <danharaj> Freedom from what? Relevance?
19:35:34 * danharaj rimshot
19:36:08 <ManateeL`> Freedom for source code, at least for programmer. :)
19:36:20 <Jonno_FTW> will an executable compiled in linux run on a  unix system?
19:36:27 <danharaj> Just a question, I installed haskellplatform first and then mingw. Could that have caused a conflict?
19:36:28 <QtPlatypus> Jonno_FTW: No
19:36:36 <Jonno_FTW> blast
19:36:50 <QtPlatypus> Unless they have a compatability layer or some sort of ABI
19:36:55 <Jonno_FTW> you see, they don't have ghc on the unix terminals
19:37:00 <DigitalKiwi> D:
19:37:00 <danharaj> because haskellplatform comes with its own mingw dealie, but I would rather cabal use the one I installed myself.
19:37:09 <Jonno_FTW> i am quite appalled
19:37:11 <QtPlatypus> Jonno_FTW: What OS do the unix terminals run?
19:37:17 <DigitalKiwi> does ghc have cross compiling yet?
19:37:20 <Jonno_FTW> one sec
19:37:58 <sbpaul> so for brute force hill cipher decryption
19:38:11 <sbpaul> i want to multiple each set of two characters by every 2x2 matrix
19:38:13 <gwern> QtPlatypus: dpm
19:38:14 <sbpaul> with elements [1..26]
19:38:29 <gwern> QtPlatypus: don't the bsds usually run linux binaries fine with their abis?
19:38:33 <gwern> not many other unixes these days
19:38:47 <tensorpudding> I thought FreeBSD had a compatibility layer.
19:38:49 <DigitalKiwi> freebsd at least has that
19:38:51 <gwern> Jonno_FTW: indeed! gambling, in rick's casino?
19:38:51 <QtPlatypus> gwern: Yes
19:38:59 <DigitalKiwi> linux-compat or something
19:39:02 <Jonno_FTW> the Unix terminal are running SunOS 5.`10
19:39:11 <sbpaul> sun OS can go to hell
19:39:23 <Jonno_FTW> SunOS lofty 5.10 Generic_118833-36 sun4u sparc SUNW,Sun-Blade-1000
19:39:26 <tensorpudding> SunOS 5, I'd guess that's old.
19:39:34 <Jonno_FTW> it's what we have to use
19:39:38 <QtPlatypus> Given that they are up to 10 yes.
19:39:44 <Jonno_FTW> :|
19:39:47 <tensorpudding> Released in 1992...
19:39:53 <Jonno_FTW> oh wow
19:40:01 <tensorpudding> 5.x that is
19:40:04 <tensorpudding> not sure about 5.10
19:40:06 <Jonno_FTW> this is at flinders university
19:40:08 <gwern> there are people in this channel younger than that!
19:40:35 <danharaj> Really?
19:40:40 * DigitalKiwi makes a note to avoid flinders university
19:40:41 <QtPlatypus> You can't install it locally in your home directory?
19:40:41 <Jonno_FTW> really?
19:40:42 <tensorpudding> Oh, SunOS 5 is Solaris.
19:40:44 <gwern> no man should be younger than his OS
19:40:47 <DigitalKiwi> where is flinders?
19:40:54 <Jonno_FTW> adelaide, South australia
19:40:56 <gwern> it's liek outliving your children
19:41:05 <DigitalKiwi> oh, that explains a lot
19:41:15 <tensorpudding> Sun OS 5.10 was released in 2005.
19:41:16 <DigitalKiwi> the convicts are always late to the party
19:41:20 <tensorpudding> It's the most recent Solaris.
19:41:22 * gwern doesn't think it does. dons is aussie too no?
19:41:24 <Jonno_FTW> we aren't convicts
19:41:39 <gwern> Jonno_FTW: oh, not *all* of you of course
19:41:41 <DigitalKiwi> that's just what a convict would say!
19:41:44 <gwern> there are the aborigines after all
19:41:52 <Jonno_FTW> most other states are, SA was a normal settlement
19:41:53 <DigitalKiwi> some of you are children of convicts, but one drop you know
19:42:30 <tensorpudding> I'm thinking that there are Solaris binaries available
19:42:36 <tensorpudding> of GHC
19:43:45 <Jonno_FTW> i wonder if they would install it for me?
19:43:45 <tensorpudding> Community binary of GHC 6.10.4 for sparc and x86
19:44:02 <tensorpudding> If you have a shell, you could install it as a user
19:44:16 <Jonno_FTW> how can i do this?
19:44:27 <Jonno_FTW> without taking up all my space in ~/
19:44:43 <tensorpudding> how much space is that
19:44:50 <DigitalKiwi> maybe hugs for solaris if it exists?
19:45:01 <Jonno_FTW> how do i check how much space i have?
19:45:15 <DigitalKiwi> df -h ? :/
19:45:26 <DigitalKiwi> dunno if they have df...
19:45:29 <tensorpudding> presumably if you have some kind of quota it'll be listed somewhere on the webpage for the system
19:45:52 <gwern> try 'quota'
19:46:15 <sbpaul> i'm dead
19:46:16 * sbpaul dies
19:46:46 * gwern buries sbpaul and orders the `error` salute
19:46:48 <gwern> > fix error
19:46:49 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:47:20 <arw> lol
19:48:38 <Jonno_FTW> quota -v doesn't return anything
19:49:47 <arw> then no quota is set for you. but usually it returns at least something like "no disk quota for uid 0"
19:50:34 <danharaj> Why does building C/C++ code always feel like trying to coax a dragon into a cage.
19:50:46 <tensorpudding> It might be worthwhile to get them to put GHC on there though
19:50:47 <Jonno_FTW> Disk quotas for mack0242 (uid 16770):
19:50:47 <gwern> danharaj: it smells your fear
19:50:49 <Jonno_FTW> Filesystem     usage  quota  limit    timeleft  files  quota  limit    timeleft
19:50:51 <Jonno_FTW> is all i get
19:51:00 <gwern> Jonno_FTW: so assume the best
19:51:10 <arw> Jonno_FTW: then you have unlimited quota
19:51:18 <Jonno_FTW> ok
19:51:25 <Jonno_FTW> how can i install ghc as a user then?
19:51:55 <tensorpudding> first you'll have to figure out if your sun server is sparc or x86
19:52:09 <Jonno_FTW> how?
19:52:12 <gwern> Jonno_FTW: --prefix=$HOME/bin is the usual option I guess
19:52:12 <arw> uname -a
19:52:33 <Jonno_FTW> sparc
19:52:36 <tensorpudding> and yeah, when you get to unpacking it, read the README and INSTALL files
19:53:05 <tensorpudding> the sparc binary of ghc 6.10.4 claims to work on Solaris 10, so it should be good
19:53:52 <Jonno_FTW> is there no haskell platform for unix?
19:54:12 <Jonno_FTW> dw
19:54:36 <tensorpudding> appears not
19:55:23 <kmc> which unix?
19:55:30 <tensorpudding> Solaris on sparc
19:55:38 <kmc> what happens if you build from source?
19:55:47 <tensorpudding> you need GHC to build from source, right?
19:56:56 <kmc> yeah
19:57:08 <tensorpudding> no GHC on the system yet
19:58:07 <deech> Hi all, does anyone here do literate Haskell programming with haskell-mode?
19:58:39 <aavogt> whose haskell-mode?
19:58:54 <ManateeL`> deech: What's wrong?
19:58:56 <deech> aavogt: emacs
19:59:37 <deech> I was wondering if there was an easy way of adding the '>' to the Haskell source. I've been manually doing it I.
20:00:02 <imc> deech: vim: :%s/^/>/g
20:00:03 <ManateeL`> deech: `>` ?
20:00:28 <kmc> deech, you can use LaTeX style lhs with multiple-major-mode
20:00:30 <ManateeL`> deech: Detail, i don't understand.
20:00:40 <imc> commandline: sed -i $FILE -e 's/^/> /g'
20:00:58 <ManateeL`> deech: Can't you do regex search in Emacs?
20:00:59 <gwern> deech: M-x string-insert-rectangle ?
20:01:06 <Jonno_FTW> the entire ghc for sparc is 570MB !
20:01:17 <ManateeL`> deech: Or i use some rectangle do that.
20:01:19 <imc> (or maybe you want to add only where it recognize haskell code and not the rest?)
20:01:19 <kmc> yeah
20:01:27 <ManateeL`> rectangle action.
20:01:43 <Jonno_FTW> i think i'll make sure how much space I have in ~/ before i copy it over
20:02:03 <deech> Yeah I use rectange too, I was wondering if there was a way to do it automatically on Enter or Ctrl-J
20:02:05 <arw> Jonno_FTW: 0501[snalwuer@faui02:~wwwadm]# du -hs /local.stand/haskell-platform-2010
20:02:08 <arw> 1,7G    /local.stand/haskell-platform-2010
20:02:17 <arw> uh, sorry, that should have been a nopaste.
20:02:23 <ManateeL`> deech: string-insert-rectangle?
20:02:32 <arw> but it takes up some space, even on intel.
20:02:33 <imc> Jonno_FTW: i've got problem compiling ghc (was doing compilation on ram.. be sure to have some ~1,5BG free for the compilation)
20:02:36 <deech> ManateeL`: that 's what I use now
20:02:43 <ManateeL`> deech: rm-set-mark then string-insert-rectangle
20:03:07 <tensorpudding> Wow, 1.7 G?
20:03:07 <ManateeL`> deech: Or rm-set-mark then string-rectangle
20:03:11 <imc> Jonno_FTW: disk space, if you're not compiling on ramdisk
20:03:18 <deech> ManateeL`: I'm not familiar with rm-set-mark
20:03:18 <tensorpudding> Haskell Platform is pretty big.
20:03:25 <imc> yep
20:03:31 <tensorpudding> You definitely don't want to compile GHC.
20:03:35 <gwern> I like big zips, other brothers can't deny
20:03:35 <imc> i did
20:03:38 <imc> twice
20:03:45 <ManateeL`> deech: Example, you want insert `>` in some column with many lines.
20:03:49 <tensorpudding> There's a binary version of it available on Solaris sparc, use it.
20:03:54 <ManateeL`> deech: Move cursor to that column.
20:03:57 <tensorpudding> (directed at Jonno_FTW)
20:04:01 <imc> on sparc i would not try to compile it :D
20:04:03 <ManateeL`> deech: Then do rm-set-mark
20:04:11 <Jonno_FTW> ok
20:04:12 <ManateeL`> deech: Then do string-insert-rectangle
20:04:32 <ManateeL`> deech: Will insert `>` in in that column with many lines.
20:04:42 <deech> ManateeL`: I just tried it. I don't seem to have rm-set-mark on my emacs, is this part of a special package?
20:04:58 <arw> tensorpudding: i didn't clean up that directory after building it, so the real footprint should be much smaller. but thats what building it needs.
20:04:59 <ManateeL`> deech: rect-mark.el
20:05:13 <imc> http://www.emacswiki.org/emacs/RectangleMark
20:05:23 <gwern> rm-set-mark? I've never used that...
20:05:31 <imc> like ctrl-v in vim
20:05:56 <ManateeL`> deech: Or you want replace some string with `>`, you need do string-rectangle after you rm-set-mark
20:06:31 <imc> bed time for me
20:06:34 <ManateeL`> gwern: I even written some advantage rect extension.
20:06:44 <imc> goodbye all
20:06:47 <gwern> ManateeL`: good for you but is that good avice?
20:06:50 <ManateeL`> gwern: Search rect-extension.el on emacswiki.org
20:07:04 <tensorpudding> Huh, the tar on Solaris might choke on filenames over 100 characters long
20:07:12 <kmc> lol solaris
20:07:40 <ManateeL`> gwern: If he just want replace string rectangle with few lines, yes, it's a good one.
20:07:49 <gwern> lolaris
20:07:51 <tensorpudding> How does that happen?
20:08:09 <ManateeL`> gwern: If he want more complicated situation than rectangle, i think he need do some regex replace.
20:08:15 <deech> gwern, ManateeL` : I just looked up rect-mark it looks pretty cool. thanks for the tip
20:08:17 <gwern> tensorpudding: what if you flatten a directory structure into the filename?
20:09:04 <ManateeL`> gwern: I develop rect-extension.el for format filename batch in dired.
20:09:45 <ManateeL`> gwern: Automatic executive speical command with rectangle lines.
20:10:55 <deech> Just out of curiosity wouldn't it have been more intuitive if the comments were marked with '>' and the code left plain?
20:11:14 <copumpkin> that's the point of lhc
20:11:15 <copumpkin> lhs
20:11:25 <kmc> deech, switch > for -- and you're back to regular haskell
20:11:35 <kmc> the philosophy of literate programming is that comments are defaults
20:11:43 <kmc> comments are the default
20:11:55 <kmc> and that your program is first and foremost a document intended to be read by a human, which explains how and *why* the program works
20:11:55 <tensorpudding> Literate coding usually means that the commenting should at least make up a sizeable percentage of the writing, maybe even the largest part of it.
20:12:07 <kmc> and secondarily the document is executable
20:12:41 <tensorpudding> LaTeX literate coding allows you to write documents that compile as valid code while also being valid LaTeX.
20:12:44 <deech> kmc: that makes sense I guess literate coding is more for the intermediate-advanced programmer. I spend too much time getting the code part right!
20:13:10 <kmc> deech, i'm sure the literate programming enthusiasts would say that their style is essential for getting the code right
20:13:15 <kmc> and that beginners should pay even more attention to it
20:13:19 <tensorpudding> For example, blog posts can sometimes be copy-pasted into a text file and run as is.
20:13:21 <kmc> personally, i think the whole thing is a bit crazy
20:13:29 <QtPlatypus> kmc: All enthusiasts say that.
20:13:34 <kmc> but i don't think it's presented as a philosophy for advanced programmers only
20:13:50 <tensorpudding> It's really great for code that's being introduced as a paper or a blog post.
20:13:53 <kmc> yes
20:14:00 <tensorpudding> But it has almost no traction anywhere else.
20:14:07 <kmc> it makes a lot of sense for those domains
20:14:16 <kmc> especially because lhs2TeX will make your Haskell code look really nice in LaTeX output
20:14:25 <kmc> using real math symbols, etc.
20:14:37 <ManateeL`> deech: If you use haskell-mode, you can try my haskell-extension.el
20:14:47 <kmc> i think encouraging beginners to "write lots of comments" can backfire
20:14:49 <ManateeL`> deech: Smart comment switch than default one.
20:14:53 <deech> ManateeL`: can you send me a link to it?
20:15:03 <QtPlatypus> TDD fans, Litrate fans, strong typing fans, formal program proving, all say that they can solve the problem of buggy code.
20:15:11 <kmc> int x = y + z;  // add the values stored in the variables named y and z and store it in the variable named x
20:15:15 <ManateeL`> http://www.emacswiki.org/emacs/haskell-extension.el
20:15:17 <BMeph> Friends don't let Friends use Emacs. ;
20:15:26 <kmc> beginners write lots of comments like that
20:15:26 <ManateeL`> http://www.emacswiki.org/emacs/AndyStewart choose your like.
20:15:28 <ManateeL`> :)
20:15:46 <kmc> with literate style a beginner might just write a paragraph before each function rewriting the function's code in english
20:15:52 <kmc> which is not really what literate programming is about
20:16:03 <ManateeL`> deech: I use `haskell-indent-cycle-` instead `haskell-indent-cycle`.
20:16:23 <QtPlatypus> But its not true, because at its core bugs are pyscoligcal things rather then thecnoligcal things.
20:16:24 <ManateeL`> deech: For smart indent switch than default.
20:16:26 <tensorpudding> It'd be nice to have intro programming assignments be given out as literate code though
20:17:08 <tensorpudding> They could fill in their own answers in between the questions, with added notes.
20:17:16 <ManateeL`> deech: haskell-extension.el is lack documentation, so just try any *interactive* fucntion.
20:17:25 <copumpkin> tensorpudding: nice idea
20:17:45 <tensorpudding> They don't have to be the ones to write massive comments though.
20:18:22 <deech> I've tried literate programming in the past and I always find that the I would solve the problem intuitively is not how I would code it. I end up getting the code to work and then making the comments fit. That's why I said you should be intermediate-advanced.
20:18:35 <kmc> that makes sense
20:18:41 <deech> ManateeL`: thanks! I will check out your code.
20:18:45 <kmc> you have to be willing to revise both as you go
20:18:52 <kmc> otherwise you have incorrect docs, which are worse than no docs
20:18:57 <ManateeL`> NP :)
20:19:07 <deech> kmc: true
20:20:02 <deech> As a beginner I find the most useful comments are a sample run of the function. This is a really cool feature of lhs2tex.
20:20:45 <ManateeL`> deech: I'm not recommend do that convert.
20:21:02 <ManateeL`> deech: If someone copy your source code, it can't execute correctly.
20:21:34 <deech> ManateeL`: you recommend I don't include sample runs?
20:21:55 <danharaj> Does anyone know how to set environment variables in msys? I'm trying to build wxhaskell. :|
20:22:24 <ManateeL`> ddarius: Well, this need you decide. :)
20:23:51 * ManateeL` Haskell always give me surprise, like the time i explored Emacs. 
20:24:13 <DigitalKiwi> decent OS but lacks a good text editor
20:25:05 <siracusa> danharaj: set var=value doesn't work?
20:27:05 <deech> DigitalKiwi: an editor so extensible that misguided people write an OS around it.
20:27:47 <ManateeL`> Moreover, when you import C routines you should be careful - if this routine is impure, i.e. its result depends on something in the "real world" (file system, memory contents...), internal state and so on, you should give it an IO type. Otherwise, the compiler can "optimize" repetitive calls of this procedure with the same parameters! :)
20:27:48 <ManateeL`>  
20:28:02 <ManateeL`> I was reading this in "IO Inside", much help.
20:28:05 <DigitalKiwi> well who cares about extensibility when it isn't even useful ;D
20:28:36 <danharaj> It's not working for me, maybe I am setting it to the wrong value. I need to set WXWIN.
20:28:42 <ManateeL`> deech: Trust me, elisp is not good language do that.
20:29:08 <ManateeL`> danharaj: Send mail to wxWindows binding team?
20:29:13 <deech> ManateeL`: agreed.
20:29:32 <siracusa> danharaj: It works for me, WXWIN=blahhh
20:29:34 <danharaj> ManateeL`: No I'm pretty sure this is a problem on my end.
20:29:47 <ManateeL`> deech: Yes, Emacs's design is awesome, even in today, but elisp is really bad decide.
20:30:38 * twink thinks it was someone whose IRC nick was Zhivago that got sbcl booting on the bare metal.
20:30:49 <ManateeL`> deech: I try to use elisp build everything i can imagine before, but my head clean last.
20:31:10 <DigitalKiwi> it's like a car made of legos, sure you can do a ton of stuff to it and make it look all flashy and stuff, but when it comes down to actually driving it...
20:31:13 <ManateeL`> deech: elisp is not type safe, fast language to implement big project like Emacs.
20:32:05 <danharaj> Ok this is weird, when I type set WINWX=...., it sets an environment variable called "_" to "WINWX=..."
20:32:06 <hamishmack> danharaj: try export var=value
20:32:08 <p_l> ManateeL`: well, elisp is definitely better than TECO, but CL was much better :D
20:32:23 <deech> ManateeL`: Elisp is its strength and weakness. Yi, for example, is an attempt to build a Emacs-like editor extensible in Haskell. But it has almost no documentation and due to Haskell's nature it completely opaque. At least with elisp I can see the source on-the-fly.
20:32:23 <tensorpudding> Or scheme.
20:32:52 <siracusa> danharaj: Without the `set', this is WinXP only.
20:32:57 <tensorpudding> A language with lexical scoping would have been better
20:33:03 <kmc> elisp is type safe but dynamically typed
20:33:04 <kmc> i think
20:33:14 <DigitalKiwi> can you edit emacs source while it is running?
20:33:24 <ManateeL`> p_l: If reall need choose one lisp language, i prefer guile
20:33:38 <deech> DigitalKiwi: I can change functions on the fly, yes.
20:33:42 <tensorpudding> You can eval things while emacs is running
20:33:45 <pikhq> DigitalKiwi: Yes.
20:33:51 <tensorpudding> which gives you a lot of power
20:34:01 <ManateeL`> deech: Too much moand wrap?
20:34:19 <tensorpudding> There's still a core of C at the center, which implements critical functions and all the elisp internals
20:34:29 <ManateeL`> deech: I'm developing extension system like Emacs with haskell, less moand wrap. :)
20:34:36 <pikhq> In effect, Emacs is nothing more than a bunch of Lisp, with a REPL running.
20:34:49 <ManateeL`> p_l: CL is too complicated. :)
20:34:51 <tensorpudding> Which makes Slime seem kinda silly
20:35:15 <tensorpudding> "we put a REPL in your REPL"
20:35:24 <danharaj> siracusa, hamishmack: Thanks export worked! Now I just have to figure out which path it wants :|
20:36:11 <deech> tensorpudding: with name-completion and a whole host of features the CL implementers didn't care to implement :)
20:36:15 <ManateeL`> deech: "Dynamic type" is most important advantage of elisp, and also is disadvantage.
20:36:42 <deech> A Slime-like development environment for Haskell would be *amazing*
20:37:10 <ManateeL`> deech: I'm developing that.... :)
20:37:26 <tensorpudding> What does slime provide that goes so far above a regular repl?
20:37:27 <ManateeL`> deech: But need long time to be perfect. :)
20:37:29 <twink> I think hemlock is a CL editor.
20:37:32 <deech> ManateeL`: agreed. Dynamic typing doesn't seem to scale very well. i'll duck for cover now.
20:38:58 <ManateeL`> deech: You can use "Dynamic type" extension emacs when it's running, but it's not safe enough.
20:39:06 <deech> tensorpudding: for one the ability to hook into remote lisp images using tramp.
20:39:39 <tensorpudding> I don't think I've ever had desire to do that.
20:39:43 <danharaj> I am giving up on msys, I'm going to try cabal install wx from the regular shell
20:40:09 <p_l> tensorpudding: except SLIME provides a nice REPL to *external* lisp
20:40:16 <deech> tensorpudding: a better debugger interface, class browser etc.
20:40:39 <tensorpudding> I didn't know it had a class browser?
20:40:43 <p_l> also integration with editor buffers
20:40:48 <tensorpudding> Is that for CLOS?
20:40:49 <p_l> tensorpudding: it has general inspector
20:40:52 <ManateeL`> DigitalKiwi: Yes, if don't change core C source of Emacs.
20:40:52 <deech> http://common-lisp.net/project/slime/doc/html/Xref-and-Class-Browser.html#Xref-and-Class-Browser
20:41:05 <ManateeL`> DigitalKiwi: You can edit all elisp source code of Emacs.
20:41:14 <ManateeL`> DigitalKiwi: And update status when emacs is running.
20:41:43 <tensorpudding> I can't compare the debugger to any other since I've never used sbcl or clojure outside of slime
20:41:47 <ManateeL`> DigitalKiwi: That's the power of Emacs, you don't need shutdown it when you extension it.
20:42:29 <ManateeL`> DigitalKiwi: But for C source code of Emacs, you still need do below action: "edit -> recompile -> restart emacs".
20:43:03 <deech> tensorpudding: this is off topic for a haskell channel, but I've used SBCL in the past and wondering if Clojure measures up.
20:43:20 <tensorpudding> Clojure is still very much "emerging" yet.
20:43:22 <p_l> tensorpudding: big difference, again partially because of editor integration - stuff like jumping to implementation etc.
20:44:34 <deech> tensorpudding: I know a start-up in St. Louis who are banking on it. And the buzz is tremendous, along with simultaneous rumours the "Common Lisp is dead".
20:44:44 <ManateeL`> kmc: IMO, elisp is not strong type like Haskell, so we still can break it.
20:44:52 <kmc> ManateeL`, break how?
20:44:59 <deech> ManateeL`: elisp is strongly typed?
20:45:09 <ddarius> deech: Clojure will have no effect on CL, or if anything, it will help CL.
20:45:10 <tensorpudding> Well, it runs on the JVM, can interface with Java libraries, isn't encumbered with the past, has a strong functional bent
20:45:21 <p_l> deech: I think the rumours of CL's death are greatly exaggerated.
20:45:24 <kmc> "strong typing" is a pretty vague term
20:45:25 <greedo> i'm having some problems installing curl with cabal
20:45:27 <p_l> (for more than a decade)
20:45:42 <kmc> but i use it to mean "using the wrong type will result in a well defined error"
20:45:49 <greedo> it keeps saying configure: error: curl libraries not found, so curl package cannot be built
20:45:52 <kmc> whether or not that error is caught by static analysis
20:46:09 <kmc> because we have another term "static typing" for that
20:46:21 <deech> ManateeL`: I just did a (setq x 1) followed by (setq x "hello"), emacs didn't complain.
20:46:41 <kmc> C has static typing but not strong typing, because it's common idiomatic C practice to circumvent static checks in a way that won't be caught at runtime if erroneous
20:46:44 <deech> p_l: I hope so
20:46:46 <ddarius> kmc: It's not that it is vague, it's that it has multiple conflicting definitions.
20:46:58 <ManateeL`> deech: Yes, you catch point.
20:47:01 <kmc> in principle you can do the same casting in Haskell but it's not a typical thing to do
20:47:50 <ddarius> kmc: Certainly not in Haskell 98.  In Haskell 98 + FFI you can in a mildly round-about way.
20:48:09 <pikhq> ddarius: unsafeCoerce is in Haskell 98 + FFI.
20:48:15 <deech> kmc: it's something I initially hated and now like about Haskell.
20:48:31 <pikhq> That's not "round-about", that's quite direct.
20:48:43 <greedo> http://pastebin.com/883phhM4
20:48:44 <ManateeL`> kmc: My english is not good enough to explain my point, sorry.
20:48:45 <ddarius> pikhq: No, it isn't.  It's definable with the FFI.  It's not in any module defined by the Report or the FFI.
20:48:56 <greedo> anyone have an insight into it?
20:49:08 <pikhq> ddarius: Oh.
20:49:17 <pikhq> ddarius: Straightforward to implement, then.
20:49:28 <pikhq> Which actually is slightly round-about.
20:49:32 <pikhq> Never mind then.
20:49:36 <p_l> kmc: by your definition CL is strongly typed
20:49:42 <kmc> p_l, yes
20:49:47 <kmc> p_l, most languages are
20:49:54 <Cale> pikhq: one shouldn't consider using unsafePerformIO lightly like that either.
20:49:54 <deech> p_l : CL is strongly typed.
20:50:06 <kmc> FFI has unsafeCoerce?
20:50:08 <pikhq> Cale: Or unsafeCoerce.
20:50:11 <ddarius> kmc: No.
20:50:20 <pikhq> kmc: No, but it most certainly has unsafePerformIO.
20:50:20 <p_l> deech: I usually left it in the "too many definitions to decide" area :)
20:50:26 <kmc> oh, but you can write it with IORef and unsafePerformIO
20:50:27 <kmc> yeah
20:50:35 <Cale> pikhq: Right. I view them as a way to do something in a library that you'd otherwise have to hack on the RTS or compiler to do.
20:50:39 <kmc> anyway, we have to apply a slightly subjective standard of "common practice"
20:50:49 <Cale> If you can do what you're doing in any other way, then you should.
20:50:50 <kmc> because most languages will let you do arbitrary unsafe things, via C calls or other hackery
20:51:01 * ddarius wishes Haskell were more "capability" oriented.
20:51:02 <deech> p_l: probably a healthier way to go!
20:51:05 <pikhq> Cale: Yes, that's what they are when you're not actually breaking the language into pieces.
20:51:21 <kmc> ddarius, how so?
20:51:47 <ManateeL`> kmc: Point is we need stop programmer do stupid mistake like Haskell.
20:52:01 <Cale> pikhq: So I don't really consider them as part of the language, but hooks provided by the runtime system.
20:52:13 <ddarius> kmc: Mainly a significant reduction (elimination) of ambient authority.
20:52:17 <pikhq> Yeah.
20:53:27 <danharaj> ok. Attempt to build wxhaskell on win7 number 3
20:53:42 <ManateeL`> kmc: Yes, i agree, i can use elisp (or other language) write correct program always, problem is we need a "strong typing check" to avoid programmer bring bug un-designed.
20:54:16 <ManateeL`> kmc: Speical with complicated project like Emacs.
20:54:19 <ddarius> kmc: Newspeak is a pretty good illustration of how design and programs would look and I think it makes some good choices as far as supporting it.  While capability-security would look different in Haskell, I think Newspeak gives a good indication of what I mean.
20:54:45 <copumpkin> newspeak is doubleplusgood?
20:54:55 <kmc> ManateeL`, i was just arguing for using the terms "strong typing" and "static typing" in distinct ways so that they're both useful
20:55:04 <kmc> i wasn't arguing about the concepts
20:55:25 * ddarius really wishes Gilad Bracha didn't have his crazy sister's dead chicken art on the Newspeak page.
20:55:47 <danharaj> that looks delicous
20:55:57 <copumpkin> ugh
20:56:02 <deech> ddarius: Oh god I just saw that. I can't sleep now.
20:56:11 <danharaj> You guys afraid of meat?
20:56:22 <deech> The goggles! They do nothing!
20:56:33 <copumpkin> http://newspeaklanguage.org/
20:56:35 <danharaj> I mean, I find the logo at the bottom more objectional :p
20:56:37 <ddarius> copumpkin: If Gilad Bracha doesn't screw up the concurrency features he wants to add, Newspeak will be an extremely well-designed language in my opinion.
20:56:54 <Cale> heh, awesome
20:56:57 <copumpkin> I'd never heard of it until you just mentioned it
20:56:57 <ManateeL`> kmc: Ok, my english is not clear enough sometimes.
20:57:02 <copumpkin> I'll check it out
20:57:05 <kmc> no worries :)
20:57:09 <Cale> (http://bracha.org/Site/Newspeak.html)
20:57:11 <ddarius> copumpkin: It's worth looking at.
20:57:48 <deech> ddarius: why not just use Squeak?
20:58:17 <copumpkin> oh it actually does claim to be doubleplusgood
20:58:21 <copumpkin> I was just joking
20:59:09 <Cale> http://gbracha.blogspot.com/  "The Brave New World of Full Service Computing", heh
20:59:45 <ddarius> deech: Squeak sucks.  Also, Newspeak is nothing like Smalltalk and fixes a lot of issues I have with Smalltalk.
20:59:55 <jmillikin> Does the Hackage buildbot run on a set schedule? I just uploaded a few libraries, some were compiled within minutes but the last one doesn't have a build result even after 2.5 hours
21:01:07 <deech> Actually that's kind of clever. The way they formed words in 1984's Newspeak by taking a core concept (an object like Double) and sending messages like 'plus' and 'good' and you get 'doubleplusgood'.
21:01:23 <deech> ddarius: I see, I didn't know.
21:02:37 <Cale> actually, isn't 'good' the concept that 'doubleplus' is modifying there?
21:02:59 <copumpkin> :t conj
21:03:00 <lambdabot> Not in scope: `conj'
21:03:12 <copumpkin> is there a complex conjugate function somewhere?
21:03:27 <aavogt> @type imag
21:03:28 <lambdabot> Not in scope: `imag'
21:03:31 <aavogt> @type imaginary
21:03:32 <lambdabot> Not in scope: `imaginary'
21:03:36 <Cale> :t conjugate
21:03:37 <lambdabot> forall a. (RealFloat a) => Complex a -> Complex a
21:03:41 <copumpkin> aha
21:03:47 <copumpkin> > conjugate (1 :+ 5)
21:03:48 <lambdabot>   1.0 :+ (-5.0)
21:03:57 <copumpkin> > conjugate "to be"
21:03:58 <lambdabot>   Couldn't match expected type `Data.Complex.Complex a'
21:03:58 <lambdabot>         against infer...
21:04:01 <deech> Cale: good call. I was right for the wrong reason.
21:04:10 <twink> Data.Complex.conjugate Data.Complex.imagPart Data.Complex.realPart
21:04:25 <copumpkin> thanks!
21:06:39 <danharaj> Yay! cabal install wx failed in a different way! Progress??
21:06:57 <ManateeL`> danharaj: Still failed?
21:07:08 <danharaj> Now it's saying it's missing a bunch of C libraries.
21:07:28 <ManateeL`> danharaj: Perhaps you missing some -dev libraries?
21:07:48 <ManateeL`> danharaj: I was working on gtk2hs, but i think wxWindows binding is same thing.
21:07:49 <danharaj> wsock32 ... wxregexu... wxmsw28u
21:07:55 <DigitalKiwi> ManateeL`, deech, pikhq, thanks
21:08:13 <danharaj> ManateeL`: where would I get those?
21:08:32 <aavogt> jmillikin: yeah, docs are done periodically
21:08:36 <danharaj> Although these should have either come with my mingw distro or built with wx
21:08:37 <ManateeL`> danharaj: I don't know the detail of wxWindows.
21:08:46 <ManateeL`> danharaj: Sorry.
21:09:01 <danharaj> How do I point cabal towards my c libraries?
21:09:01 <ManateeL`> danharaj: I just use gtk2hs on linux.
21:09:07 <jmillikin> aavogt: do you know what the period is? I'm trying to decide whether to stay up for it, or send my announce email in the morning
21:09:18 <ManateeL`> pkgconfig-depends: gthread-2.0, gtk+-2.0
21:09:29 <aavogt> no idea
21:09:34 <ManateeL`> danharaj: I think like that.
21:09:49 <ManateeL`> danharaj: If wxWindows is use pkg-config too.
21:10:08 <aavogt> it might be worth putting up docs for your library + others that fit will together somewhere?
21:10:09 <ManateeL`> danharaj: I recommend you ask those problem detail to wxWindows binding team.
21:10:19 <danharaj> I wouldn't know how to contact them.
21:10:33 <ManateeL`> danharaj: We use  pkgconfig-depends: tag in gtk2hs cabal.
21:11:21 <ManateeL`> http://haskell.org/haskellwiki/WxHaskell?
21:12:00 <ManateeL`> danharaj: wxhaskell-users list?
21:12:11 <ManateeL`> danharaj: Or wxhaskell-devel list?
21:13:36 <danharaj> These archives are not searchable whose bright idea was that :|
21:14:15 <ManateeL`> danharaj: I can gnus to track mail-list.
21:14:42 <ManateeL`> danharaj: I can search wxwindow list in gmane.or server.
21:15:02 <danharaj> Hey, I think I got it to build
21:15:11 <ManateeL`> danharaj: How?
21:15:16 <danharaj> --extra-include-dirs --extra-lib-dirs
21:15:24 <danharaj> I needed to point it to my mingw distro.
21:15:51 <danharaj> oh wait no not yet.
21:16:21 <ManateeL`> danharaj: As i said, it's easier to send mail to mail-list.
21:16:32 <danharaj> 'cannot exec `cc1 plus' '
21:16:40 <danharaj> probably, but I'm a jerk :\
21:17:32 * ManateeL` "IO Inside" is much help me understand how to use unsafePerformIO.
21:21:55 <ddarius> copton: Hmm.  There was an early version of the paper "Modules as Objects in Newspeak" titled "Objects as Modules in Newspeak" which was quite a bit better than the current version.
21:32:12 * ManateeL` Lunch time, leave message to me.
21:32:50 <danharaj> This experience is as pleasant as gargling battery acid.
21:45:57 <tommd> I don't think anyone actually understands how to use unsafePerformIO.
21:46:45 <danharaj> not at all?
21:47:09 <copumpkin> I do!
21:47:38 <tommd> Step one: Download Coq or Isabelle.  Step two: Develop formal semantics for Haskell.
21:47:38 <tommd> Eventually you get to proving your use of unsafePerformIO is safe for some definition(s) of safe.
21:48:25 <shu> isn't there a step 1.5 where you try to learn coq or isabelle and forget your original goal
21:48:59 <tommd> I was giving you the benefit of the doubt and assuming you already know one of the major theorem provers.
21:50:38 <DigitalKiwi> adga is the other one?
21:51:21 <aavogt> agda is more like haskell
21:51:31 <DigitalKiwi> yeah that
21:51:38 <DigitalKiwi> it's a theorem prover though right?
21:51:49 <tensorpudding> it has dependent types1
21:51:59 <aavogt> types!1!1
21:52:16 <tommd> Sepyt?
21:52:17 <jmcarthur> i wouldn't call agda a theorem prover. it's capable, i guess, but that's not its major focus
21:52:17 <kmc> it's a bit charitable to call coq or agda a "theorem prover"
21:52:22 <dons> unsafePerformIO :: IO a -> a
21:52:22 <dons> unsafePerformIO m = unsafeDupablePerformIO (noDuplicate >> m)
21:52:24 <kmc> "proof checker" certainly
21:52:33 <dons> {-# NOINLINE unsafeDupablePerformIO #-}
21:52:33 <dons> unsafeDupablePerformIO  :: IO a -> a
21:52:33 <dons> unsafeDupablePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
21:52:36 <kmc> "proof assistant" in that both have fancy IDEs
21:52:41 <kmc> with interactive type checking etc.
21:52:50 <dons> tommd: quite a bit of careful magic in there now, more than there used to be.
21:52:56 <kmc> coq is more focused on proof automation
21:53:03 <kmc> agda is more focused on writing programs
21:53:08 <jmcarthur> kmc: yes, theorem prover is a misnomer, but it's also a de facto term now :\
21:53:09 <tommd> kmc: So you do call Isabelle a "theorem prover" and not just a "proof assistant"
21:53:10 <dons> the lazy (case ..) is new. used to be a let.
21:53:14 <kmc> i don't know Isabelle
21:53:37 <DigitalKiwi> i don't know jack :(
21:53:45 <DigitalKiwi> he sounds like a really cool guy, too!
21:53:47 <dons> oh, no. the 'let' is interleaveIO obv.
21:53:49 <DigitalKiwi> interesting family at least
21:54:00 <aavogt> hey dons, you can do something about code.haskell.org / community.haskell.org being down?
21:54:06 <dons> Igloo: ^^
21:54:12 <dons> igloo has the admin privs.
21:54:18 <tommd> aavogt: Its up.
21:54:37 <tommd> aavogt: I _just_ setup a new system with access to c.h.o
21:54:43 <aavogt> tommd: I mean over http
21:54:51 <dons> restart apache, you mean.
21:54:51 <tommd> ah
21:55:10 <dons> igloo, dcoutts or yitz can do that.
21:55:36 <tommd> dons: I assume you saw CPSA?
21:55:42 <tommd> on hackage
21:55:45 <dons> yeah
21:55:47 <aavogt> @where+ c.h.o_admins igloo, dcoutts or yitz
21:55:48 <lambdabot> Good to know.
21:55:49 <tommd> :-)
21:55:59 <dons> pretty cool. lee works with him, iirc.
21:56:12 <dons> you had some good points!
21:56:29 <tommd> I had some good points?  On what?  When?
21:56:32 <bos> holy cow, how can haskell-cafe be so busy on a weekend?
21:56:46 <dons> tommd: oh, mentioning the correctness aspect on -cafe?
21:56:51 <tommd> I unsubscribed some weeks back - is the conversation reasonable quality?
21:57:14 <dons> you get out what you put in, i think.
21:57:23 <tommd> ah, yes.  Well, that's the tools whole benefit to some people.
21:57:36 <dons> if we all walk away -- and i'm guilty -- -cafe@ won't be so great.
21:58:05 <DigitalKiwi> sorry got distracted reading jokes :(
21:58:06 <tommd> dons: Perhaps once the term ends I'll re-engage the community in a meaningful way.
21:58:11 <DigitalKiwi> http://www.c4vct.com/kym/humor/schitt.htm  jack schitt ;D
21:58:23 <tommd> Like getting the damned network library fixed along with a reasonable Crypto lib.
21:58:58 <tommd> I implemented (part of) NIST SP 800-90.  It took all of half a day but is really worthless without a better structure to crypto.
21:59:15 <bos> what's wrong with the network library?
21:59:40 <tommd> bos: Mostly I feel its crufty and dislike its heavy use of exceptions
21:59:47 <bos> fair enough.
21:59:53 <bos> it does need a rewrite.
22:00:01 <tommd> bos: One was started at the last PDX hackathon
22:00:09 <bos> one always gets started.
22:00:17 <bos> there are several 15% rewrites out there.
22:00:23 <tommd> Well Creighton and I intend to get it much further at the next one.
22:00:42 <tommd> And a design decision post to libraries@ would be part of that.
22:00:55 * bos regards network library rewrites as snipe hunts
22:01:15 <tommd> Then we, as a community, can decide if we like where this is going and thus worth polishing.
22:01:21 <bos> good plan
22:02:02 <tommd> I think I found what part of my summer will be for
22:02:07 <blackdog> bos: snipe hunt?
22:02:53 <DigitalKiwi> fools errand
22:03:15 <DigitalKiwi> http://en.wikipedia.org/wiki/Snipe_hunt
22:03:16 <tommd> DigitalKiwi: You like the current network library?  Or is that a comment on something else?
22:03:20 <tommd> oh, I see
22:03:32 <DigitalKiwi> i was answering what a snipe hunt is
22:03:55 <tommd> yes, my mistake
22:03:59 <dons> its a very difficult lib to rewrite
22:05:00 <tommd> I blame the need to support more than zero operating systems.
22:05:29 <bos> wow, criterion is useful.
22:06:21 <bos> double wow, there's some kind of colossal performance regression in the port of criterion to vector.
22:06:34 <bos> that kinda blows.
22:06:42 <blackdog> bos: you're using criterion on itself?
22:06:48 <bos> no.
22:06:55 <bos> that would be a bit meta.
22:06:57 <blackdog> aw. that would be cool.
22:07:14 <blackdog> you say meta like it's a bad thing
22:07:37 <bos> :-)
22:07:52 <dons> bos: using the new vector release?
22:07:53 <bos> dons: i like your h-c post about software design
22:07:56 <dons> from last week.
22:08:11 <dons> bos: cheers. even made it to ycombinator. maybe should put it in an FAQ or something
22:08:16 <bos> dons: yes!
22:12:35 <ddarius> > 7^4 / 3^4
22:12:36 <lambdabot>   29.641975308641975
22:12:55 <luite> what's new in the new vector release?
22:15:01 <ddarius> > 29 / 3
22:15:02 <lambdabot>   9.666666666666666
22:15:03 <luite> ah found it, hackage has some "changes since version 0.5"
22:15:10 <ddarius> Excellent.
22:15:13 <blackdog> bos: heh. re meta: cabal install just let me know that cabal-install has a new version, and that i should cabal install cabal-install
22:16:36 <rsaarelm> I liked the Haskell software design post too.
22:16:42 <bos> dons: new vector release is still slow :-(
22:16:43 <BMeph> blackdog: Yo dawg... ;
22:20:46 <ddarius> Who the heck says "Why?" to "Avoid partial functions"?
22:20:54 <kmc> most people?
22:20:58 <jmcarthur> bos: slow compared to what?
22:21:43 <idnar> partial functions are the NullPointerException of Haskell code
22:22:02 <kamatsu> okay, i just browsed through amazon and have added a whole bunch of books to my cart
22:22:29 <kamatsu> has anyone read Basic Category Theory for Computer Scientists by Ben Pierce? Is it any good?
22:23:21 <bos> jmcarthur: compared to uvector and ghc 6.10.4
22:23:40 <jmcarthur> oh really? aw :(
22:24:01 <ddarius> kamatsu: I skimmed it fairly briefly and my impression was that it wasn't great.  It might be okay.
22:24:01 <Pseudonym> kamatsu: If it's anywhere near as good as "Types and Programming Languages", then it's good.
22:24:48 <Pseudonym> I suspect that you're better off getting Barr & Wells.
22:25:30 <kamatsu> Barr and Wells?
22:25:46 <Pseudonym> http://www.cwru.edu/artsci/math/wells/pub/ctcs.html
22:27:39 <kamatsu> can't seem to find it on amazon
22:27:48 <Pseudonym> It might be out of print.
22:28:15 <Pseudonym> So far, I haven't seen a really good introduction to category theory apart from "Conceptual Mathematics".
22:28:24 <Pseudonym> Which doesn't really go far enough.
22:29:15 <kamatsu> I may as well get the Pierce book
22:29:21 <kamatsu> Types and Programming Languages is great
22:30:04 <ddarius> Pseudonym: Awodey's book is pretty good.
22:30:33 <ddarius> kamatsu: I'm pretty confidenty Basic Category Theory for Computer Scientists is nowhere near as good as TaPL.
22:30:49 <Pseudonym> ddarius: Looks relatively new.  Must check that one out, thanks.
22:30:50 <kamatsu> ddarius: oh
22:30:59 <ddarius> There's a reason people aren't(weren't) squeeing about it like they have about TaPL.
22:31:11 <kamatsu> so, for someone interested in category theory, what should I buy?
22:31:27 <ddarius> Pseudonym: It's one Cale recommends.  I looked at it after he recommended it and it does look pretty good.
22:31:51 <ddarius> kamatsu: I would recommend Awodey's book.
22:31:59 <kamatsu> ddarius: it's $124 :(
22:32:51 <ddarius> kamatsu: There are a few good online resources.
22:32:58 <kamatsu> uhm, ok
22:33:39 <ddarius> kamatsu: I've probably told you this, but Barr and Wells' ESSLLI lecture notes are very good.  This suggests that their book is good, so you may want to consider getting that.
22:33:59 <ddarius> I've never even skimmed Barr and Wells' book, but the table of contents doesn't look too bad.
22:34:00 <dons> bos: talk to rl. he is very active in fixing things -- should always be faster than uvector (though it's cute that uvector is still winning now and then :)
22:34:11 <kamatsu> ddarius: okay, thanks for the tip
23:19:52 <ManateeLazyCat> Can you use "Clone url" feature in patch-tag.com ?
23:20:10 <ManateeLazyCat> I got error when i build "synchronous mirror repository" for http://code.haskell.org/gtk2hs.
23:22:42 <ManateeLazyCat> Looks can't work now, i synchronous repository manually.
23:40:25 <rsaarelm> Does anyone know of research or case studies on converting Standard ML programs to Haskell?
23:47:04 * hackagebot xsd 0.3.2 - XML Schema data structures  http://hackage.haskell.org/package/xsd-0.3.2 (TonyMorris)
23:52:40 <dibblego> why is there a Monoid (a -> b) instead of a (Monad m) => Monoid (m b) ?
23:58:38 <Saizan> the latter would overlap with e.g. Monoid (Endo a)
23:58:55 <jmcarthur> dibblego: i guess it was a choice between (Applicative f, Monoid a) => Monoid (f a)  and things like  Monoid [a]
23:59:38 <dibblego> can we not write some sort of wrapper then?
23:59:57 <jmcarthur> sure we can
