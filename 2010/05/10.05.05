00:00:31 <Cale> kulin: General rule of thumb for when you might need strictness is when you're taking tons of tiny pieces of data and combining them (summarizing rather than searching) into a single piece of data with not many separate parts
00:00:39 <kulin> as long as there is no accumulation of data i should be safe in any event it seems
00:00:42 <Cale> yeah
00:01:02 <Cale> In all other cases, lazy evaluation is better or roughly equivalent to strict evaluation
00:01:21 <Cale> and the compiler is smart enough to find a lot of cases where you'll want more strictness on its own if you turn on -O or -O2 anyway
00:01:45 <Cale> So mostly you don't have to worry, but it helps to know these things for the odd case that you need to deal with them.
00:02:20 <RambO> Whats the diference between Ints and Integers?
00:02:23 <RambO> Sorry.
00:02:28 <RambO> Between Div and Quot ?
00:02:49 <RambO> I need to use a div function with an Int, idem a mod.
00:04:09 <Pseudonym> The difference between div and quot, rem and mod is how they work on negative numbers.
00:04:38 <RambO> oh
00:04:49 <RambO> Is there a way to use div with Ints instead of Integers?
00:04:52 <Pseudonym> http://www.google.com.au/url?sa=t&source=web&ct=res&cd=12&ved=0CA4QFjABOAo&url=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fdaan%2Fdownload%2Fpapers%2Fdivmodnote.pdf&ei=cRjhS_upGYTU7AP9p8jvAQ&usg=AFQjCNGQaf7BFgMKCLmKVccWiGmNngqZqw&sig2=-D7pfBc01kd3li0BYxehKA
00:04:55 <Pseudonym> Erm.
00:05:16 <Pseudonym> @google division and modulus for computer scientists
00:05:17 <lambdabot> http://research.microsoft.com/en-us/um/people/daan/download/papers/divmodnote.pdf
00:05:17 <lambdabot> Title: cache:http://research.microsoft.com/en-us/um/people/daan/download/papers/divmodn ...
00:05:21 <Pseudonym> There we are.
00:05:28 <Pseudonym> :t div
00:05:28 <lambdabot> forall a. (Integral a) => a -> a -> a
00:05:34 <Pseudonym> Yup, just do it.
00:06:56 <RambO> My error was another :P I used length to get the length of a list.. and uses it as an argument.
00:07:06 <RambO> The function expected Integer :P
00:08:06 <kulin> I do not think humans were meant to think in terms of threads
00:11:09 <Cale> RambO: yeah, I personally hate that length gives an Int specifically
00:12:36 <Cale> It's annoying enough when the typechecker catches it, but the real problem is when the typechecker doesn't catch it, and instead you end up with a bunch of Int arithmetic in your program by accident, possibly where it ends up overflowing and causing your program to produce bad results :P
00:12:38 <RambO> Nothing that a fromIntegral can't solve ¿?
00:12:47 <Cale> yeah
00:12:55 <cads> hwy Cale, did you say that you had some code that lets lambdabot work with mathlink?
00:12:58 <RambO> or make your own length :P
00:13:04 <Pseudonym> :t genericLength
00:13:05 <lambdabot> forall b i. (Num i) => [b] -> i
00:13:20 <Cale> cads: Not with mathlink
00:13:24 <Pseudonym> I think the real problem here, though, is that the Prelude isn't generic enough.
00:13:46 <Pseudonym> The good names should be reserved for the most applicable functions, IMO.
00:13:53 <Pseudonym> So map should be for Functors.
00:13:59 <Pseudonym> length should work on finger trees.
00:14:01 <Cale> cads: I had a hacky shellscript IRC bot before using lambdabot for that purpose, and so I stole the shellscript wrapper around the mathematica kernel that I had
00:14:01 <Pseudonym> And so on.
00:14:30 <cads> Cale: aah
00:15:21 <Cale> heh, my bot was essentially one long bash pipeline, using a fifo to take the fixed point ;)
00:15:42 <RambO> Need to make a list for mapping characters ['0'..'9', 'a'..'f'], how can I do?
00:16:04 <Cale> ['0'..'9'
00:16:04 <RambO> "0123456789abcdef"
00:16:06 <Cale> oops
00:16:12 <Cale> > ['0'..'9'] ++ ['a'..'f']
00:16:14 <lambdabot>   "0123456789abcdef"
00:16:20 <RambO> Nice.
00:16:21 <roconnor> > deriv (join (**)) x
00:16:22 <lambdabot>   Ambiguous occurrence `x'
00:16:22 <lambdabot>  It could refer to either `L.x', defined at <local...
00:16:31 <Cale> heh, probably shorter just to write the string explicitly though ;)
00:16:31 <roconnor> > L.x
00:16:32 <lambdabot>   5
00:16:34 <Pseudonym> @undef
00:16:37 <roconnor> > deriv (join (**)) x
00:16:38 <Pseudonym> > deriv (join (**)) x
00:16:38 <lambdabot>   (1 * recip x * x + log x * 1) * exp (log x * x)
00:16:39 <lambdabot>   (1 * recip x * x + log x * 1) * exp (log x * x)
00:16:59 <RambO> Thanks, i will try to think a little more next time, sorry for the dumb question :$
00:17:23 <roconnor> This is such a great example of haskell modularity
00:17:54 <Pseudonym> The use of recip is unfortunate.
00:18:03 <Pseudonym> But nothing you can do about that, I guess.
00:18:39 <cads> > deriv (\x - > x**x)
00:18:40 <lambdabot>   <no location info>: parse error on input `-'
00:19:06 <cads> oh, woorps
00:21:36 <cads> how does that work?
00:21:57 <cads> @type deriv (**2) x
00:21:58 <lambdabot> Expr
00:22:10 <Pseudonym> :t deriv
00:22:11 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
00:22:43 <cads> here x is an Expr, which is in the Num class?
00:22:58 <xerox> yeah
00:25:41 <cads> I'm familiar with numerical differentiation using a funky number type, but I didn't know we had anything for symbolic differentiation
00:26:17 <cads> cool deal
00:26:29 <cads> maybe I don't need mathlink after all :)
00:27:13 <RambO> Is there a good way to search for the index of the first ocurrence of a element? Or i should my slow recursive function?
00:28:14 <systemfault> RambO: Why do you say it's slow?
00:28:23 <systemfault> RambO: What does that function looks like?
00:29:08 <RambO> whereIs                 ::      a -> [a] -> Integer -> Int
00:29:08 <RambO> whereIs _ [] _          =       error "No se encuentra el elemento en la lista"
00:29:09 <RambO> whereIs a (x:xs) n      |       x == a  =       n
00:29:09 <RambO>                         |       otherwise       =       whereIs a xs (n+1)
00:29:38 <cads> @type Data.List.findIndex
00:29:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
00:30:09 <c_wraith> :t elemIndex
00:30:10 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
00:30:29 <RambO> I have to import those >.<
00:30:42 <c_wraith> homework, then?
00:31:08 <c_wraith> :t lookup
00:31:09 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:31:16 <cads> > Data.List.findIndex (\x -> x^2 > 666) [1..]
00:31:17 <RambO> so so.. The task was do a nat2hex, i've made a nat2any, and now i want to make a any2nat ..
00:31:17 <lambdabot>   Just 25
00:32:03 <c_wraith> :t \x -> lookup x . zip [0..]
00:32:04 <lambdabot> forall a b. (Num a, Enum a) => a -> [b] -> Maybe b
00:32:36 <c_wraith> err, oh
00:32:43 <c_wraith> :t \x -> lookup x . flip zip [0..]
00:32:44 <lambdabot> forall a b. (Eq a, Num b, Enum b) => a -> [a] -> Maybe b
00:33:19 <c_wraith> lookup, flip, and zip are all in the prelude :)
00:33:47 <cads> RambO: you have to learn haskell for class?
00:33:47 <RambO> Why does elemIndex return "Just"
00:33:57 <Twey> Because it might not be in the list
00:34:03 <Twey> > elemIndex 5 [1, 2, 3, 4]
00:34:05 <lambdabot>   Nothing
00:34:07 <Twey> > elemIndex 3 [1, 2, 3, 4]
00:34:08 <lambdabot>   Just 2
00:34:23 <RambO> cads: Something like that. We see an introduction to haskell..
00:34:35 <c_wraith> > (\x -> lookup x . flip zip [0..]) 3 [1, 2, 3, 4]
00:34:37 <lambdabot>   Just 2
00:34:39 <cads> sounds like a neat class
00:34:41 <c_wraith> > (\x -> lookup x . flip zip [0..]) 5 [1, 2, 3, 4]
00:34:43 <lambdabot>   Nothing
00:35:00 <RambO> c_wraith: I need to use the number it throws >.<
00:35:03 <c_wraith> ah, flip zip.  what a great name :)
00:35:05 <systemfault> Haskell is scary
00:35:10 <systemfault> :)
00:35:20 <Twey> RambO: So use it
00:35:33 <RambO> systemfault: I like haskell, that's why i'm here :P
00:35:42 <systemfault> I love it
00:35:57 <RambO> cads: We onlye see haskell to learn "recursion" (its a first year course of programming)
00:36:39 <Twey> > maybe "Not in the list!" ((++) "In the list at position " . show) $ elemIndex 3 [1, 2, 3, 4]
00:36:40 <lambdabot>   "In the list at position 2"
00:36:44 <Twey> > maybe "Not in the list!" ((++) "In the list at position " . show) $ elemIndex 5 [1, 2, 3, 4]
00:36:45 <lambdabot>   "Not in the list!"
00:36:50 <RambO> cads: Later in the carreer we see it more deeply. I think it is in "Programming Languages Paradigms"
00:37:32 <c_wraith> If you're supposed to be learning recursion, you really should write your find function manually.
00:37:33 <RambO> > 3 * (Data.List.elemIndex 2 [1,2,3,4])
00:37:34 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
00:37:34 <lambdabot>    arising f...
00:37:58 <Twey> > fmap (* 3) $ elemIndex 2 [1, 2, 3, 4]
00:37:59 <RambO> c_wraith: Thats what I've done, but it sucks.
00:37:59 <lambdabot>   Just 3
00:39:24 <systemfault> > (*) <$> pure 3 <*> elemIndex 2 [1,2,3,4]
00:39:26 <lambdabot>   Just 3
00:39:27 <systemfault> :P
00:39:49 <xerox> > (3*) . elemIndex 2 $ [1..10]
00:39:50 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
00:39:51 <lambdabot>    arising f...
00:39:54 <xerox> ouch
00:40:03 <Twey> xerox: Backwards
00:40:20 <Twey> > (* 3) . elemIndex 2 [1 .. 10]
00:40:21 <lambdabot>   Just 3
00:40:32 <xerox> $ was the problem not (3*) ok
00:40:32 <Twey> But let's not confuse the newbie ;)
00:40:43 <systemfault> I'm a noob :(
00:40:52 <Twey> s
00:41:00 <systemfault> :)
00:45:38 <RambO> In ghci, how can I see what arguments needs a function?
00:45:46 <Twey> :t <function>
00:45:47 <lambdabot> parse error on input `<'
00:45:52 <Twey> lambdabot: Shh :Ã¾
00:45:56 <Twey> :t maybe
00:45:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:46:13 <ManateeLazyCat> What's "cabal sdist"? Use for what?
00:46:44 <xerox> to make a source distribution!
00:47:05 <Saizan> ManateeLazyCat: it makes a .tar.gz under dist/ that you can upload to hackage
00:47:20 <RambO> Thanks :D
00:47:26 <ManateeLazyCat> Saizan: I see, thanks.
00:52:41 <ManateeLazyCat> I can't access code.haskell.org again, can't apply patch.
00:57:12 <RambO> i can't import the HUnit module and i don't know why :(
00:57:17 <RambO> cabal says it is installed..
00:57:20 <systemfault> c_wraith: Hmm, what did you smoke to find that... I need some :(
00:58:37 <Saizan> RambO: HUnit is the name of the package
00:58:47 <Saizan> RambO: the module is called Test.HUnit
00:58:52 <RambO> oh.
00:58:59 <c_wraith> systemfault: that construction?  I'm just familiar enough with the prelude now to realize I could use zip and lookup to do the job of elemIndex...  Figuring out exactly how was just a matter of fitting the types together properly
00:59:14 <RambO> The userguide is wrong then
00:59:30 <systemfault> c_wraith: You just gave me hope, thank you :)
01:00:04 <c_wraith> systemfault: you're welcome, then. :)
01:01:33 <Saizan> RambO: http://hackage.haskell.org/package/HUnit <- if you click on the module names you get the automatically generated API documentation
01:02:42 <ManateeLazyCat> Saizan: How to include extra directory when i do "cabal sdist", looks option `Extra-Source-Files` can't work.
01:05:12 <RambO> Saizan: So, for each module I want to test I should make a moduleTest.hs ?
01:05:49 <RambO> Can I write Tests even if i don't wrote the function yet ?
01:06:21 <Saizan> ManateeLazyCat: that should work, it accepts a syntax like dirname/* to include everything inside a directory, iirc
01:07:29 <Saizan> RambO: well, that's up to you, and if the test you write refer to the function you'll have to at least give a stub definition of the function if you want to typecheck them
01:08:46 * hackagebot data-accessor 0.2.1.3 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.1.3 (HenningThielemann)
01:08:47 <Saizan> RambO: e.g. factorial :: Int -> Int; factorial = undefined; sometest = ... factorial ..
01:08:48 * hackagebot event-list 0.0.11 - Event lists with relative or absolute time stamps  http://hackage.haskell.org/package/event-list-0.0.11 (HenningThielemann)
01:09:01 <Saizan> ?type undefined
01:09:02 <lambdabot> forall a. a
01:09:11 <RambO> Excelente.
01:11:21 <RambO> thanks Saizan
01:11:26 * ManateeLazyCat pasted "cabal sdist" at http://paste2.org/get/811504
01:11:28 <ManateeLazyCat> Saizan: ^^^^^ ?
01:12:47 * hackagebot data-accessor-transformers 0.2.1.1 - Use Accessor to access state in transformers State monad  http://hackage.haskell.org/package/data-accessor-transformers-0.2.1.1 (HenningThielemann)
01:12:49 <Saizan> ManateeLazyCat: ah, right, see the documentation for data-files http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#general-fields , extra-source-files follows the same rules
01:14:48 * hackagebot data-accessor-monads-fd 0.2.0.1 - Use Accessor to access state in monads-fd State monad class  http://hackage.haskell.org/package/data-accessor-monads-fd-0.2.0.1 (HenningThielemann)
01:16:40 <jlouis> morning!
01:17:58 <baguasquirrel> hallo
01:18:07 <baguasquirrel> it's morning where u are?
01:18:10 <systemfault> >:t flip
01:18:41 <baguasquirrel> ?type flip
01:18:42 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
01:19:00 <baguasquirrel> whoa...
01:19:02 <baguasquirrel> that's useful...
01:19:18 <systemfault> I saw a cool use of it a few minutes ago
01:19:33 <baguasquirrel> where at?
01:19:48 <baguasquirrel> (if I may ask)
01:19:54 <systemfault> 2 sec
01:20:08 <systemfault> > (\x -> lookup x . flip zip [0..]) 3 [1, 2, 3, 4]
01:20:09 <lambdabot>   Just 2
01:20:19 <baguasquirrel> cool..
01:20:50 <systemfault> That stinks sarcasm
01:21:13 <baguasquirrel> ?
01:22:17 <systemfault> Is there any way to get that notation in ghc, it seems that it's easier to understand
01:22:35 <baguasquirrel> what notation?
01:22:52 <baguasquirrel> you mean what lambdabot just spit out?
01:22:58 <baguasquirrel> for the type signature?
01:23:01 <systemfault> Yes
01:23:04 <baguasquirrel> no idea..
01:23:18 <Saizan> there's an -X flag
01:23:26 <systemfault>  forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b     instead of          flip :: (a -> b -> c) -> b -> a -> c
01:23:37 <systemfault> (In GHCI)
01:23:56 <Saizan> :set -XExplicitForAll
01:24:22 <osfameron> the latter version seems easier to me... what do you get from the 'forall' ?
01:25:04 <Saizan> systemfault: oh, wait, the difference there is also that the first one got generalized by Cale
01:25:49 <Saizan> systemfault: so, you also need import Prelude hiding (flip); flip f x = fmap ($x) f
01:26:32 * Saizan also thinks the more general signature is easier to read
01:27:18 <systemfault> Thanks :)
01:31:35 <Lajla> Why are there so little parentheses in Haskell?
01:31:54 <c_wraith> it's a deliberate plot to be the anti-lisp
01:32:27 <Lajla> Why have you forsaken us?
01:32:47 <fasta> Lajla, some people still think it has a lot because it is functional programming.
01:32:48 <kulin> its to emphasize the dollar sign cuz haskell is all about blinging
01:32:55 <RambO> I need to do something like:  f  :: a -> Int             f =  1 -  (h.(g ' '))
01:32:57 <fasta> Lajla, naturally, those people are lost.
01:33:27 <Lajla> I think C has more, especially if you also count { ... } as haskell is not free form.
01:33:40 <osfameron> because $ is less ugly than () !   er..
01:33:48 <RambO> what does $ do?
01:33:57 <c_wraith> The decision to regularize syntax in a way that doesn't *require* parens helped, of course.
01:34:04 <Lajla> It makes sure the US invades other countries.
01:34:05 <jlouis> @src ($)
01:34:05 <lambdabot> f $ x = f x
01:34:08 <c_wraith> RambO: nothing, actually.
01:34:13 <Lajla> It's called freedom.
01:34:23 <jlouis> RambO: it can be used to kill a parenthesis set
01:34:25 <arcatan> $ is like a left parenthesis that doesn't need right parenthesis
01:34:43 <c_wraith> RambO: It just takes advantage of haskell's precedence rules to group expressions without using parens
01:34:53 <RambO> so you can do something like
01:35:01 <RambO> f $ x + 1 ?
01:35:03 <Lajla> Ahh, like an invation that needs no ustification, I like.
01:35:13 <c_wraith> RambO: exactly
01:35:13 <Lajla> invasion*
01:35:17 <jlouis> RambO: yes, equivalent to f (x+1)
01:35:18 <kulin> it also makes it really hard to read code, cuz rather than be a clean looking function, there is a giant squigly mountain between your code
01:35:21 <RambO> > 3 * $ 2 + 1
01:35:23 <lambdabot>   <no location info>: parse error on input `$'
01:35:26 <RambO> :(
01:35:34 <RambO> (*) $ 2+1 $ 3
01:35:40 <RambO> > (*) $ 2+1 $ 3
01:35:41 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
01:35:41 <lambdabot>    arising from a use of `e_1213' at...
01:35:47 <c_wraith> > (3 *) $ 2 + 1
01:35:48 <lambdabot>   9
01:36:03 <RambO> Why mine didn't work?
01:36:16 <yitz> > (3 *) . (2 +) $ 1
01:36:17 <lambdabot>   9
01:36:20 <Saizan> kulin: that's one of the reasons you should prefer (.) over ($) when applicable
01:36:43 <kulin> i do saizan, but (.) has it's own problems, the precidence doesnt feel right
01:36:48 <Saizan> RambO: it's right associative
01:36:50 <aep> RambO: (*) $ 2+1 $ 3  ==  (*) ( 2+1 ( 3 ) )
01:36:56 <kulin> so i end up doing a lot of: a . b . c $ d
01:37:03 <xerox> kulin: which is nice
01:37:15 <RambO> oh.
01:37:19 <kulin> i would be happier with: a . b . c e
01:37:21 <xerox> because a, b and c are expressions, and you can substitute expressions for expressions
01:37:27 <Saizan> some prefer (a . b . c) e
01:37:57 <RambO> > reverse.reverse.reverse $ [1,2,3]
01:37:58 <lambdabot>   [3,2,1]
01:38:01 <RambO> Nice.
01:38:05 <systemfault> Hmm, seems that I can't understand something as simple as "flip". Its signature is confusing me, flip :: (a -> b -> c) -> b -> a -> c , The way I understand it, (++) "A" "B" would become "A" (++) "B", what's wrong with my logic?
01:38:30 <Saizan> a . b . c e would require . having higher precedence than function application, which would be horrible when a, b, c are compound expressions
01:38:41 <Saizan> (and currently impossible in haskell)
01:38:54 <c_wraith> I really like that function application has the highest precedence in chains involving .
01:38:55 <jlouis> systemfault: flip takes a function of type (a -> b -> c) and returns a function of type  b -> a -> c
01:38:57 <RambO> @src flip
01:38:57 <lambdabot> flip f x y = f y x
01:39:16 <systemfault> RambO: That's exactly how I would implement it...
01:39:19 <c_wraith> I really like being able to do f x . g y $ z
01:39:29 <Saizan> c_wraith: yeah
01:39:55 <systemfault> But why it is: flip :: (a -> b -> c) -> b -> a -> c instead of flip :: (a -> b -> c) -> a -> c -> b ?!?
01:40:10 <jlouis> flip (++) A B = (++) B A
01:40:11 <RambO> Because the type it returns is always c
01:40:17 <RambO> It doesnt change
01:40:18 <Saizan> systemfault: because the result type must be the same
01:40:51 <RambO> It takes a function that goes from a -> b -> c and returns a function that goes from b -> a -> c. ¿? it is clear as water ¿?
01:40:52 <Saizan> (++) doesn't help much here, since in this case a=b=c
01:40:55 <xerox> i wonder, does changing associativity of $ solve this:
01:40:57 <xerox> > let (.:)=(.).(.) in succ .: (*) $ 2 10
01:40:58 <lambdabot>   Ambiguous type variable `t' in the constraint:
01:40:59 <lambdabot>    `GHC.Num.Num t'
01:40:59 <lambdabot>      aris...
01:41:06 <xerox> > let (.:)=(.).(.) in (succ .: (*)) 2 10
01:41:08 <lambdabot>   21
01:41:18 <Saizan> xerox: no
01:41:24 <xerox> :-/
01:41:55 <Saizan> it'd let you write succ .: (*) $ 2 $ 10 though
01:41:57 <Twey> systemfault: It's clearer if you bracket it differently
01:42:00 <systemfault> RambO: Not as clear as I would like to... but Ok!
01:42:06 <xerox> Saizan: ah that's good
01:42:07 <Twey> systemfault: flip :: (a -> b -> c) -> (b -> a -> c)
01:42:37 <cads> this is astrange: c2hs is a requirement for the mathlink package, and I have its executable on the system path. However, I get "c2hs.exe: does not exist" when I say runhaskell.exe Setup.lhs build.
01:42:58 <Twey> If it were (a -> c -> b) it would take its return value and return its second argument :Ã¾
01:42:59 <cads> Is the directory that cabal uses for searching for build tools different than the system path?
01:43:22 <Saizan> systemfault: suppose i've a function of type X -> Y -> Z, what should be the type of the same function with arguments in the opposite order?
01:43:45 <RambO> Flip f y x let you send the arguemtns twisted. but the function do the same as if you send f x y.
01:43:59 <Saizan> cads: no
01:44:17 <Saizan> cads: you might need to rerun configure though
01:44:18 <systemfault> Saizan: Seems that it would be Y -> X -> Z even though in my head X -> Z -> Y would seems more logical
01:44:43 <systemfault> Saizan: Because it's the second and third arguments that are switched :/
01:44:58 <cads> any suggestions?
01:45:00 <Saizan> systemfault: Z is the type of the result here
01:45:03 <systemfault> Saizan: But I understand that I understand it incorrectly
01:45:03 <RambO> systemfault: in haskell, functions take one argument or none.
01:45:07 <xerox> what comes on the right of a -> is never an argument
01:45:28 <Saizan> systemfault: there are only 2 arguments, not 3
01:45:34 <xerox> (remember that X->Y->Z = X->(Y->Z))
01:46:06 <quicksilver> systemfault: second and third? There are only two arguments.
01:46:51 <cads> @hoogle (a -> b) -> b -> a
01:46:52 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
01:46:52 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
01:46:52 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
01:46:54 <Saizan> flip takes 3 arguments, but the function it takes as first argument takes only 2
01:47:13 <cads> :)
01:47:19 <Saizan> (fsvo of "takes n arguments")
01:48:50 <systemfault> Ah!
01:49:11 <systemfault> Ok! That just clicked in my mind
01:49:45 <systemfault> So, the function itself isn't in the signature at all :/
01:49:59 <Saizan> it's in the signature of flip
01:50:00 * hackagebot data-accessor-monads-tf 0.2.1.1 - Use Accessor to access state in monads-tf State monad type family  http://hackage.haskell.org/package/data-accessor-monads-tf-0.2.1.1 (HenningThielemann)
01:50:18 <Saizan> well, if by "the function" you mean the one that gets flipped
01:50:25 <systemfault> Saizan: Yes
01:51:36 <Saizan> flip (f :: a -> b -> c) (x :: b) (y :: a) = f y x :: c <-- this is pseudo haskell, but maybe more clear
01:52:12 <Saizan> flip :: (a -> b -> c) -> b -> a -> c
01:52:18 <Saizan> do you see the pattern?
01:52:28 <systemfault> Yes, I understand it
01:53:01 * hackagebot explicit-exception 0.1.5 - Exceptions which are explicit in the type signature.  http://hackage.haskell.org/package/explicit-exception-0.1.5 (HenningThielemann)
01:53:02 <systemfault> The only thing I don't totally understand is why isn't the function passed in the signature
01:53:14 <systemfault> -passed
01:53:24 <Saizan> well you have its type in the signature
01:53:51 <Saizan> i guess you are used to c-like languages where you also have the argument name in the signature?
01:54:18 <systemfault> Let's say :flip (++) "Hello" "World"
01:54:34 <arcatan> > flip (++) "Hello" "World"
01:54:35 <lambdabot>   "WorldHello"
01:54:39 <systemfault> It's seems that there's no representation of (++) in that signature
01:54:52 <Saizan> it's the  (a -> b -> c) part
01:54:56 <arcatan> :t (++)
01:54:57 <lambdabot> forall m. (Monoid m) => m -> m -> m
01:55:31 <Saizan> it's just that a=b=c=[x] (or m if we use this generalized definition)
01:55:49 <mornfall> Saizan: Your first flip example isn't really pseudo, you can do that with PatternSignatures or something.
01:55:53 <Saizan> err, [Char] in this case, actually
01:56:46 <cads> doh, the "does not exist" message is from c2hs telling me gcc is not installed
01:56:49 <mornfall> ScopedTypeVariables. :D
01:57:13 <Saizan> ?type let flip (f :: a -> b -> c) (x :: b) (y :: a) = f y x :: c in flip
01:57:13 <lambdabot>     A pattern type signature cannot bind scoped type variables `a', `b', `c'
01:57:14 <lambdabot>       unless the pattern has a rigid type context
01:57:14 <lambdabot>     In the pattern: f :: a -> b -> c
01:57:14 <mornfall> Hm, but it still complains. D'oh.
01:57:23 <mornfall> I see. :)
01:57:36 <mornfall> You'd need a forall somewhere in an outer scope.
01:57:44 <systemfault> Saizan: In my mind, I was seeing it that way (C style) return_type flip(Function f, arg1, arg2){return f(arg2, arg1); }
01:57:48 <mornfall> Or so I guess.
01:58:28 <Saizan> systemfault: ah, ok, it's quite different
01:59:35 <systemfault> So.. in  flip :: (a -> b -> c) -> b -> a -> c I was wondering, where is the f of my C-like function
01:59:50 <kulin> (a -> b -> c) ?
02:00:09 <Saizan> systemfault: yeah, the f is mentioned only on the line below, for the actual definition
02:00:18 <Saizan> systemfault: you get only its type in the signature
02:00:24 <systemfault> It's clear now :)
02:00:38 <systemfault> Thank you :)
02:00:41 <Saizan> adn the return type is all the way to the end :)
02:01:36 <Saizan> +moved
02:02:15 <systemfault> :)
02:02:46 <kulin> someone should improve haskell's type inference, it seems like once i come up with a type for the function, its nearly impossible to write it wrong
02:02:52 <kulin> so the compiler should just write it for me
02:03:21 <Saizan> @djinn (a -> b -> c) -> b -> a -> c
02:03:21 <lambdabot> f a b c = a c b
02:03:57 <kulin> ya, but for all programs
02:04:21 <kulin> so i can write "NetworkServer a -> IO ()"
02:04:22 <kulin> and be done
02:04:24 <systemfault> What is that supposed to do? Discard the function and return 3 args? :(
02:05:03 <Saizan> systemfault: it's the same as flip with names changed
02:05:04 <mornfall> kulin: There are many ways to write that one wrong.
02:05:19 <systemfault> Ah
02:05:25 <roconnor> kulin: const (return ())
02:05:36 <mornfall> :))
02:05:56 <roconnor> you need dependent types to fully specify your programs
02:06:03 <roconnor> then type inference becomes AI-hard
02:06:08 <mornfall> roconnor: You wish that was enough. :)
02:06:18 <roconnor> mornfall: I like to pretend
02:06:33 <roconnor> stupid operational behaviour
02:07:12 <mornfall> (A more common name for "AI-hard" is undecidable, too :P)
02:07:29 <systemfault> @djinn (a -> b -> c) -> (b -> a -> c)
02:07:29 <lambdabot> f a b c = a c b
02:07:44 <roconnor> er I guess it isn't type inference by program syntehsis
02:07:45 <mornfall> systemfault: -> associates from right
02:08:22 <systemfault> I see
02:08:29 <roconnor> @djinn (((a -> b) -> a) -> b -> ((a -> b) -> a)) -> a -> b -> a
02:08:29 <lambdabot> f a b c = a (a (\ _ -> b) c) c (\ _ -> c)
02:08:48 <mornfall> It's all about combinators.
02:08:57 <roconnor> @. pl djinn (((a -> b) -> a) -> b -> ((a -> b) -> a)) -> a -> b -> a
02:08:57 <lambdabot> f = flip flip const . (ap .) . flip flip id . (ap .) . liftM2 (.) (.) (. const)
02:09:34 <mornfall> Give a type and djinn will give you the most general combinator that satisfies the type. Somewhat useful.
02:10:00 <mornfall> @djinn a -> b
02:10:00 <lambdabot> -- f cannot be realized.
02:10:03 <mornfall> :D
02:10:35 <mornfall> It can't do magic. It's not a real djinn... :P
02:10:40 <systemfault> That's becoming hard to read :/
02:10:50 <systemfault> I guess I need practice
02:10:54 <kulin> no
02:11:07 <kulin> i dont think anyone should be able to easily read taht
02:11:29 <roconnor> what part of "flip flip const . (ap .) . flip flip id . (ap .) . liftM2 (.) (.) (. const)" don't you understand?
02:11:30 <mornfall> kulin: ghci
02:12:08 * hackagebot markov-chain 0.0.3.1 - Markov Chains for generating random sequences with a user definable behaviour.  http://hackage.haskell.org/package/markov-chain-0.0.3.1 (HenningThielemann)
02:12:08 <mornfall> kulin: You didn't get an implant? :D
02:12:14 <systemfault> roconnor: Too much of it, still learning, I don't know about ap and const yet
02:12:22 <roconnor> :D
02:12:33 <kulin> i have ghci open constantly
02:12:35 <roconnor> systemfault: you should learn const
02:12:39 <roconnor> ap is harder
02:13:21 <StarFire> @src ap
02:13:21 <lambdabot> ap = liftM2 id
02:13:35 <quicksilver> that's a deliberately obfuscated definition IMO
02:13:57 <quicksilver> @tell Cale I find @src ap to be deliberately obfuscated. liftM2 ($) is more natural.
02:13:58 <lambdabot> Consider it noted.
02:14:10 <cads> also, if you rhyme djinn's output as a rap, you will succeed
02:14:41 <Saizan> quicksilver: i was going to suggest liftM2 ($) as a joke..
02:15:03 <roconnor> liftM2 ($) ... kinda makes sense
02:15:05 <mornfall> :t ap
02:15:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:16:02 <kulin> so circular imports are not allowed
02:16:19 <roconnor> kulin: they are; ghc is broken.
02:16:19 <kulin> i guess i just blew ghc's mind
02:16:43 <kulin> how do i unbreak it?
02:16:51 <kulin> actually nevermind, ill just clean up the code
02:17:27 <quicksilver> circular imports are permitted and GHC has a rather clumsy method to allow them, which is in the fine manual
02:17:40 <quicksilver> however it's quite often (subjectively) better style to refactor your modules to avoid them.
02:17:41 <roconnor> ugh
02:18:01 <mornfall> Djinn doesn't seem to know about lifting, sadly.
02:18:10 <roconnor> I think it is objectively more practical to refactor your modules :)
02:18:33 <kulin> I prefer to refactor, because the word cracks me up
02:18:35 <roconnor> not so sure about style.
02:19:08 <xerox> > ap (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) x
02:19:10 <lambdabot>   f x (g x)
02:19:14 <xerox> > (=<<) (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) x
02:19:15 <lambdabot>   f (g x) x
02:19:16 <cads> I have a debugging case I'd like to learn how to handle. When run without gcc on the path, a project requiring c2hs give the somewhat cryptic error: c2hs.exe: does not exist
02:19:19 <xerox> :)
02:19:33 <cads> (which is actually c2hs complaining about gcc missing)
02:19:33 <roconnor> there seems to be some confusion with compilers about the distinction between collections of related functionality and issues of separate compilation.
02:19:44 <roconnor> they seem to conflate the two issues.
02:20:09 <cads> I would like to patch the part of c2hs' code which gives that error message
02:20:41 <cads> however, the error message's text isn't part of the code - it must come from the file access library
02:22:04 <quicksilver> cads: "does not exist" is probably what perror() prints for EEXIST
02:22:07 <quicksilver> or something like that.
02:22:30 <quicksilver> so that output is caused by printf("c2hs : %s",strerror()), or the moral equivalent of that in haskell.
02:22:50 <quicksilver> a better output would be printf("c2hs : problem running gcc : %s")
02:23:05 <Saizan> cads: i've seen people discuss that error before, maybe there's a ticket for it
02:23:49 <cads> quicksilver: is there a way of tracing the execution up to the part of the code that gives the message?
02:24:08 <cads> Saizan: I've found a few posts about it too
02:25:11 * hackagebot midi 0.1.5.1 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.1.5.1 (HenningThielemann)
02:26:13 <cads> Saizan: hmm, no ticket
02:42:16 * hackagebot uuagc 0.9.23 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.23 (ArieMiddelkoop)
03:07:10 <b0fh_ua> Hi there. How do I convert Char to Word8 (latin1 only)?
03:07:30 <ManateeLazyCat> dcoutts: I'm now try to convert "http://code.haskell.org/gtk2hs" from "darcs-1-format" to "hashed-format", i have a "hashed-format" local repository, so how to replace replace "http://code.haskell.org/gtk2hs" with local "hashed-format" ?
03:09:01 <ivanm> @hoogle Char -> Word8
03:09:02 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
03:09:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:09:02 <lambdabot> Prelude error :: [Char] -> a
03:09:14 <RLa> in simply-typed lambda calculus, every type expression is habitable?
03:09:16 <ivanm> hmmmm, you probably don't want c2w but something like it
03:09:27 <RLa> i fail to see which ones are not
03:09:28 <ivanm> b0fh_ua: at a wild guess, fromIntegral . ord ?
03:09:37 <tab> b0fh_ua: you might want to try fromEnum
03:10:06 <tab> b0fh_ua: or more specifically (toEnum . fromEnum)
03:10:31 <roconnor> RLa: how about "sigma"
03:11:31 <RLa> ah, fixpoint combinators
03:11:57 <RLa> hm, wait
03:14:29 * hackagebot cabal-sort 0.0.1 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.1 (HenningThielemann)
03:15:18 <ivanm> OK, that package description confuses me
03:15:30 <ivanm> especially when he forgot to add B.cabal to his example usage section ;-)
03:24:36 <RLa> is there an algorithm to construct term from type expression?
03:24:37 <b0fh_ua> thanks all!
03:24:59 <quicksilver> RLa: yes, that's what djinn is
03:25:16 <quicksilver> @djinn a -> b -> (a -> b -> c) -> (a,b,c)
03:25:16 <lambdabot> f a b c = (a, b, c a b)
03:25:23 <RLa> wow
03:25:25 <Jafet> That depends on what you admit as types.
03:25:44 <Jafet> For the usual polymorphic lambda calculus, djinn is an effective algorithm
03:26:32 <RLa> @djinn ((a -> b -> a) -> a) -> a
03:26:32 <lambdabot> f a = a (\ b _ -> b)
03:28:29 <RLa> it's perfect
03:28:53 <zygoloid> @djinn a -> a -> Bool -> a
03:28:53 <lambdabot> f a b c =
03:28:53 <lambdabot>     case c of
03:28:53 <lambdabot>     False -> b
03:28:53 <lambdabot>     True -> a
03:30:00 <Jafet> @pl f a b c = case c of False -> b; True -> a
03:30:01 <lambdabot> (line 1, column 27):
03:30:01 <lambdabot> unexpected ">" or "-"
03:30:01 <lambdabot> expecting variable, "(", operator or end of input
03:30:18 <Jafet> Meh
03:31:31 <zygoloid> @pl f a b c = if c then a else b
03:31:31 <lambdabot> f = flip . flip if'
03:31:52 <zygoloid> @@ @pl @djinn ((a -> b -> c) -> a) -> a
03:31:52 <lambdabot>  (line 1, column 1):
03:31:52 <lambdabot> unexpected "-"
03:31:52 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:32:11 <zygoloid> @djinn ((a -> b -> a) -> a) -> a
03:32:11 <lambdabot> f a = a (\ b _ -> b)
03:32:17 <zygoloid> @@ @pl @djinn ((a -> b -> a) -> a) -> a
03:32:17 <lambdabot>  f = ($ const)
03:32:33 <Jafet> @@ @vixen @djinn a -> b
03:32:34 <lambdabot>  i drive a pickup truck
03:32:36 <ivanm> roconnor: eh, I got sick of waiting for ghci to calculate that CReal value
03:32:59 <roconnor> you think CReal can do what Wolfram alpha can't?
03:33:07 <roconnor> oh
03:33:13 <Jafet> What's this, Brun's constant?
03:33:13 <roconnor> maybe ghci is more patient than alpha
03:33:52 <roconnor> @. pl djinn (((a -> b) -> a) -> b -> ((a -> b) -> a)) -> a -> b -> a
03:33:52 <lambdabot> f = flip flip const . (ap .) . flip flip id . (ap .) . liftM2 (.) (.) (. const)
03:35:35 <Jafet> What's the worst-case expansion of pl.unpl?
03:35:57 <Jafet> It sounds legitimate and worth studying.
03:36:28 <ivanm> hmmmm....
03:36:29 <quicksilver> @pl tends to produce more polymorphic code that you give it
03:36:30 <lambdabot> tends to produce more polymorphic code that you give it
03:36:38 <ivanm> heh
03:36:46 <quicksilver> so @unpl can't remove that polymorphism
03:36:51 <quicksilver> @pl \x -> [x]
03:36:52 <lambdabot> return
03:37:03 <quicksilver> -- we've gone from a -> [a] to a -> m a
03:37:38 <RLa> @djinn b -> ((a -> b) -> c) -> c
03:37:38 <lambdabot> f a b = b (\ _ -> a)
03:37:44 <RLa> nice
03:38:00 <RLa> i would probably spend hours to figure out what terms i need
03:59:24 <RLa> now, what bot command i should use to get the type of some expression?
04:00:43 <zygoloid> @type ?some ?expression
04:00:44 <lambdabot> forall t t1. (?expression::t, ?some::t -> t1) => t1
04:01:04 <RLa> @type \f -> f
04:01:05 <lambdabot> forall t. t -> t
04:01:26 <RLa> @type \f z -> f (f z)
04:01:26 <lambdabot> forall t. (t -> t) -> t -> t
04:01:31 <zygoloid> in ghci you can accomplish the same thing with :t
04:01:32 <RLa> thanks
04:02:31 <RLa> @type \x y -> x
04:02:32 <lambdabot> forall t t1. t -> t1 -> t
04:06:52 <RLa> ok, i have expressions with types (a -> a) -> a -> a and a -> b -> a, now i cannot apply second expression to first one because there is no way to fit a -> b -> a to (a -> b)?
04:07:27 <RLa> i meant (a -> a) in last type
04:08:07 <opqdonut> what do you want to do?
04:08:31 <RLa> i want to show that the resulting expression is not typable
04:08:45 <opqdonut> oh
04:08:59 <opqdonut> yeah, your explanation was ok
04:09:33 <opqdonut> (a -> b -> a) doesn't unify with (c -> c) because a doesn't unify with b -> a
04:09:41 <opqdonut> (that would result in an infinite type)
04:10:28 <opqdonut> if you try to do that in ghci, you get "Occurs check: cannot construct the infinite type: a = b -> a"
04:10:31 <opqdonut> as I said
04:10:44 <RLa> that's what i thought except my rules do not use explicit unification
04:10:55 <opqdonut> (you can try for example "let a = undefined :: (a -> a) -> a -> a; b = undefined :: a -> b -> a in a b")
04:11:43 <opqdonut> what do you use then?
04:12:17 <RLa> oh, these are derivation rules of simply typed calculus
04:12:46 <RLa> i would have an infinite branch somewhere i guess
04:13:31 <opqdonut> if a and b are concrete types and not type variables, the problem is simply that a != b->a
04:13:45 <opqdonut> the function wants a -> a, you gave it a -> (b -> a)
04:14:44 <RLa> ok, i might construct half tree up to error then
04:15:03 <RLa> although i do it by hand and it's a bit boring
04:20:00 <RLa> @type \x -> x x x
04:20:01 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t -> t1
04:20:01 <lambdabot>     Probable cause: `x' is applied to too many arguments
04:20:01 <lambdabot>     In the expression: x x x
04:20:32 <RLa> hm, it does not work with 2nd order calculus
04:20:58 <fax> RLa yes type inference is too difficult for that
04:23:28 <ivanm> preflex: seen dcoutts
04:23:28 <preflex>  dcoutts was last seen on #ghc 15 minutes and 28 seconds ago, saying: I don't think that's ready yet
04:24:10 <RLa> hm, but it should be decidable
04:24:42 <azazell> hi everyone
04:25:30 <RLa> hey
04:25:40 <azazell> I want to parse huge xml file lazily, which is the best xml toolkit in haskell?
04:26:15 <ivanm> HaXmL supports lazy parsing IIRC
04:27:37 <azazell> Are there any exmaples and sources I could have, I've got troubles in understanding how is it works...
04:28:22 <ivanm> preflex: seen malcolmw
04:28:23 <preflex>  malcolmw was last seen on #ghc 19 days, 22 hours, 41 minutes and 17 seconds ago, saying: readUTF8File name = openFile name ReadMode >>= set_utf8_io_enc >>= hGetContents
04:29:19 <ivanm> azazell: http://hackage.haskell.org/packages/archive/HaXml/1.20.2/doc/html/Text-XML-HaXml-ParseLazy.html
04:29:41 <ivanm> specifically, xmlParse
04:34:05 <quicksilver> RLa: type checking is decidable.
04:34:28 <quicksilver> RLa: sicne the 2nd order calculus does not have principle types, you have to think a bit harder about what type inference means.
04:34:44 <quicksilver> do you want to enumerate the (generally infinite) list of possible types?
04:35:04 <fax> some people on IRC are really nasty
04:35:15 <quicksilver> fax?
04:35:15 <fax> at least some channels have good people
04:36:22 * scree has to go and eat a puppy for lunch
04:37:50 <hants> TacticalGrace, are you there?
04:38:19 <ivanm> preflex: seen TacticalGrace
04:38:19 <preflex>  TacticalGrace was last seen on #haskell 5 days, 7 hours, 3 minutes and 36 seconds ago, saying: lol
04:38:42 <hants> oh
04:38:43 <ivanm> quicksilver: eh, I'm probably one of the nasty people fax is talking about ;-)
04:39:44 <hants> is someone here involved with data.array.accelerate ?
04:40:16 <ivanm> hants: well, TacticalGrace is... :p
04:40:35 <RLa> quicksilver, i need type for some expression
04:40:46 <hants> but you probably dont know when he comes back ? ;)
04:41:15 <quicksilver> RLa: there is a lot of literature on 2nd order inference, I'm no expert
04:41:25 <fax> isn't 2nd order inference undecidible
04:41:36 <quicksilver> there are all kinds of compromises where you can infer for particular subsets
04:43:29 <ivanm> hants: he might be in 12 hours time
04:43:41 <ivanm> since it's 9:45 PM here atm
04:43:55 <ivanm> and he generally only comes in during the day (probably when he wants to procrastinate...)
04:46:26 <hants> ivanm: thank you!
04:46:33 <ivanm> hants: no worries
04:46:46 <ivanm> that, of course, depends on lectures, meetings, etc.
04:50:44 <RLa> quicksilver, my slides say that both inference and check are equivalent and decidable
04:50:54 <fax> that's news to me
04:51:01 <quicksilver> that is not my memory of the situation RLa.
04:51:02 <fax> RLa what calculus is it
04:51:11 <quicksilver> I suspect they've identified some particular fragment of 2nd-order.
04:53:41 <RLa> hm, might be
04:54:01 <RLa> i will just try to find a type that follows my derivation rules and i'm done
05:24:00 <fax> hi augur I just linked you in -blah
05:24:34 <augur> oh?
05:46:57 <deech> Has anyone been able to get Hare working in Emacs?
05:49:03 <jutaro> deech: HaRe is only available for ghc-6.8.2, or do you know of a newer version?
05:49:58 <ivanm> jutaro: I've hacked it to work with 6.10
05:50:18 <ivanm> using base-3 still
05:50:38 <jutaro> ivanm: any url to get this?
05:50:45 <ivanm> deech: ManateLazyCat's page on the emacs wiki has some settings for it IIRC (might be under AndyStewart or something)
05:50:53 <ivanm> jutaro: nope, private hack just to see if it worked
05:50:58 <cosinelaw> @pl a -> [a]
05:50:58 <lambdabot> (line 1, column 3):
05:50:58 <lambdabot> unexpected ">" or "-"
05:50:58 <lambdabot> expecting variable, "(", operator or end of input
05:51:03 <cosinelaw> @pl \a -> [a]
05:51:03 <ivanm> doesn't accept any non-H98, so it's kinda useless
05:51:03 <lambdabot> return
05:51:15 <ivanm> cosinelaw: has copumpkin corrupted you? :o
05:51:21 <jutaro> ivanm: ok
05:51:26 <cosinelaw> heh
05:51:31 <cosinelaw> ivanm, nah i'm using web irc
05:51:36 <cosinelaw> too lazy to auth in my own nick
05:51:51 <ivanm> in case you missed it, I made a new release
05:51:57 <cosinelaw> ooh!
05:51:59 <cosinelaw> what's new?
05:52:15 <cosinelaw> i was away from haskell stuff for a while, too much work
05:52:15 <ivanm> http://projects.haskell.org/graphviz/changelog.html
05:52:17 <ivanm> ;-)
05:52:56 <cosinelaw> looks like a lot of work
05:53:10 <cosinelaw> @hoogle a->[a]
05:53:10 <lambdabot> Prelude repeat :: a -> [a]
05:53:10 <lambdabot> Data.List repeat :: a -> [a]
05:53:10 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
05:53:20 <ivanm> cosinelaw: yup :s
05:55:49 <roconnor> @pl \f -> foldr (\x y -> (f x) : y)
05:55:50 <lambdabot> foldr . ((:) .)
05:56:32 <roconnor> @type foldr.((:).)
05:56:33 <lambdabot> forall a a1. (a -> a1) -> [a1] -> [a] -> [a1]
05:56:42 <roconnor> @pl \f -> foldr (\x y -> (f x) : y) []
05:56:42 <lambdabot> flip foldr [] . ((:) .)
05:57:01 <roconnor> @type flip foldr [].((:).)
05:57:03 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
05:57:11 <cosinelaw> ivanm: now i'm working on that robot
05:57:16 <cosinelaw> it follow my face around :)
05:57:19 <ivanm> a robot? :o
05:57:19 <cosinelaw> *follows
05:58:01 <cosinelaw> yeah, i implemented a simple robot controller using my functional wrappers for opencv and the robot bindings
05:58:08 <ivanm> cool
05:58:11 * ivanm -> bed
05:58:23 <cosinelaw> $ ivanm
06:02:44 <roconnor> woot, simon added swap to the library
06:03:14 <quicksilver> he did it wrong though!
06:03:19 <roconnor> oh
06:03:22 <quicksilver> did he add the strict or the lazy one?
06:03:28 <roconnor> I don't know
06:03:32 <quicksilver> it was the wrong one, anyway.
06:03:36 <roconnor> where is the trunk
06:03:56 <roconnor> quicksilver: the wave hasn't collapsed yet
06:04:00 <quicksilver> (I'm parodying the bikeshed discussion, by the way; I'm glad it went in)
06:04:02 <roconnor> it's in superposition
06:04:22 <fax> what's a fast way to turn 2^n into 10^m (best appproximation possible in integers)
06:04:28 * hackagebot hexpat-iteratee 0.2 - Chunked XML parsing using iteratees  http://hackage.haskell.org/package/hexpat-iteratee-0.2 (StephenBlackheath)
06:05:02 <fax> hm maybe I should just count up in base 10
06:05:47 <ddarius> fax: Just use log.
06:05:54 <quicksilver> fax: multiply by 3.3
06:05:58 <quicksilver> > log 10 / log 2
06:06:00 <lambdabot>   3.3219280948873626
06:06:17 <quicksilver> actually, divide by 3.3 the way around you asked the question.
06:06:24 <fax> oh cool
06:06:35 <SirTeoHero> Am I totally wrong when I came here to talk about speakers? ^^ Google gave me this link while searching.
06:07:12 <theorbtwo> SirTeoHero: Yes.  This channel is for the Haskell programming language.
06:07:41 <quicksilver> > 2 ^ 23
06:07:42 <lambdabot>   8388608
06:07:43 <quicksilver> > 10 ^ round (23/3.3)
06:07:44 <lambdabot>   10000000
06:22:05 <byorgey> @tell scotthw oh sorry, I went to bed. Did you get it to work?
06:22:06 <lambdabot> Consider it noted.
06:23:32 <roconnor> @tell dmwit Suppose you want to use Data.Tuple.Utils.snd3 from MissingH. Now your project not only depends on MissingH, but also depends on array, base (4.*), containers, directory, filepath, haskell98, hslogger, HUnit, mtl, network, old-locale, old-time, parsec, process, random, and regex-compat.
06:23:32 <lambdabot> Consider it noted.
06:26:45 <hants> @tell hants consider it noted
06:26:46 <lambdabot> You can tell yourself!
06:26:49 <hants> :D
06:32:54 <roconnor> quicksilver: simon added the wrong one :(
06:33:11 <roconnor> but it is better than none :)
06:33:17 <quicksilver> :)
06:34:13 <hants> @seen
06:34:13 <lambdabot> Unknown command, try @list
06:34:17 <hants> @list
06:34:18 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:35:05 <ski> preflex: xseen hants
06:35:05 <preflex>  hants was last seen on freenode/#haskell 48 seconds ago, saying: @list
06:36:00 <hants> so its a different bot
06:36:56 <hants> preflex: xseen TacticalGrace
06:36:56 <preflex>  TacticalGrace was last seen on freenode/#haskell 5 days, 9 hours, 2 minutes and 13 seconds ago, saying: lol
06:43:58 <EvanR-work> how do i get a list of all pairs of elements in a list
06:44:03 <RLa> an expression is in normal form if it has no beta redexes, that means it contains no subterms in the form of (\x -> e1) e2 but everything else is legal?
06:44:38 <ski> as long as it is a well-formed expression, yes
06:45:19 <ski> (possibly one requires welltypedness too, depending on context)
06:46:07 <siracusa> EvanR-work: Each element paired with what?
06:46:27 <RLa> ski, actually i'm trying to prove that every normal form is typable in 2nd order
06:46:38 <EvanR-work> siracusa: [a] -> (a,a)
06:46:51 <RLa> but i fail to see what cases i need to consider
06:46:57 <EvanR-work> [1,2,3] -> [(1,1), (1,2), (2,1), ...]
06:47:11 <ski> > liftM2 (,) [1,2,3] [1,2,3]
06:47:12 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
06:47:20 <EvanR-work> :o
06:47:26 <EvanR-work> list monad
06:47:26 <ski> > [(x,y) | x <- [1,2,3] , y <- [1,2,3]]
06:47:26 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
06:47:31 <opqdonut> > let xs = [1,2,3] in [(a,b) | a <- xs, y <- xs]
06:47:32 <lambdabot>   <no location info>: parse error on input `<-'
06:47:54 <opqdonut> > let xs = [1,2,3] in [(a,b) | a <- xs , y <- xs]
06:47:55 <lambdabot>   [(1,b),(1,b),(1,b),(2,b),(2,b),(2,b),(3,b),(3,b),(3,b)]
06:48:03 <opqdonut> heh :D
06:48:06 <quicksilver> :)
06:48:08 <opqdonut> > let xs = [1,2,3] in [(a,b) | a <- xs , b <- xs]
06:48:09 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
06:48:10 <opqdonut> anyway
06:48:14 <opqdonut> sorry for the noise
06:48:26 <byorgey> wha...
06:48:36 <opqdonut> i have no idea what caused that first syntax error
06:48:44 <opqdonut> probably some pseudowhitespace
06:48:47 <ski> EvanR-work : is that enough ?
06:50:20 <quicksilver> opqdonut: yup, thre is a ? between | and a
06:50:29 <opqdonut> mm
06:50:36 <EvanR-work> yep
06:51:48 <EvanR-work> im writing a really bad algorithm to take a list of rectangles, and produce a corresponding list of list of collisions for each one
06:52:00 <reiv> opqdonut: I see a chinese char between '|' and '<-'
06:53:02 <tensorpudding> It looks like there was a non-breaking space there
06:53:11 <tensorpudding> At least, that is what showed up on mine.
06:53:22 <opqdonut> nbsp probably yeah
06:53:26 <opqdonut> i keep hitting it by accident
06:53:42 <tensorpudding> You have a key for it?
06:53:55 <Jafet> "Gr!"
06:54:00 <fax> hey look at this: http://upload.wikimedia.org/math/f/f/e/ffe36de4219c8ee8a9ec4560a565c378.png
06:54:08 <fax> math actually has lambda too
06:54:14 <opqdonut> tensorpudding: alt + space
06:54:22 <opqdonut> by default on this ubuntu at work
06:54:30 <opqdonut> i remember to do xmodmap -e "keysym space = space space space space space space" now and then
06:54:43 <benmachine> keysym badger = etc.
06:54:55 <tensorpudding> Why six spaces?
06:55:01 <opqdonut> tensorpudding: six modifiers
06:55:25 <opqdonut> normal, shift, alt gr, alt gr+shift, iso level 3 shift, iso level 3 shift + shift
06:55:28 <opqdonut> IIRC
06:55:35 <tensorpudding> ...ugh
06:55:38 <RLa> when i have term in normal form, it can only be variable or abstraction or application x e where x is in normal form?
06:56:02 <fax> no
06:56:04 <opqdonut> depends on which evaluation rules you use
06:56:06 <fax> x is a variable e is a normal form
06:56:25 <fax> e.g. (\x -> x (\e -> e)) is normal
06:56:32 <fax> but (\x -> (\y -> y) x) is not
06:58:20 <RLa> fax isn't that abstraction, not application?
06:58:44 <ski>   A ::= B
06:58:47 <ski>       | \x. A
06:58:51 <ski>   B ::= x
06:58:53 <ski>       | B A
06:59:09 <ski> an expression of form `A' here is in beta-normal form
06:59:23 <RLa> uh oh
06:59:48 <RLa> B must be too?
06:59:53 <ski> basically, zero or more lambdas wrapped around a variable applied to zero or more expressions in normal form
07:00:40 <RLa> lambdas wrapped around a variable?
07:00:40 <ski> `B' was just a helper syn.-cat., there
07:01:02 <RLa> ok, i start to get it
07:01:21 <RLa> single variable is in normal form, yes?
07:01:21 <ski> e.g. `\x. \y. \z. (x (\y. z)) (\x. y (\x. y z))
07:01:23 <ski> '
07:01:26 <ski> yes
07:01:50 <RLa> abstraction where body is in normal form is in normal form?
07:02:06 <ski> yes
07:02:07 <opqdonut> yes
07:02:19 <ski> (that's the `\x. A' case of `A', above)
07:02:37 <RLa> i'm still not understanding what happens in the case of application
07:02:55 <ski> in the case of application, we must ensure to not apply an abstraction to anything
07:03:04 <ski> so, we can apply variables to expressions
07:03:16 <ski> and we can apply such expressions to new expressions
07:03:40 <ski> so `x',`x M0',`(x M0) M1',`((x M0) M1) M2' are all o-k
07:04:03 <RLa> so when both e1 and e2 are in normal form, it's still possible that (e1 e2) is not?
07:04:12 <opqdonut> yes
07:04:25 <ski> (where `M0',`M1',`M2' are all arbitrary expressions, in this case also assumed to be normal, though)
07:04:28 <opqdonut> when e1 is an abstraction
07:05:40 <RLa> hm, but in vice versa, when i know that (e1 e2) is in normal form, then both e1 and e2 must be in normal form?
07:05:48 <ski> yes, but not only that
07:05:56 <ski> you also know that `e1' is not an abstraction
07:06:23 <ski> iow, you know that `e1' belongs to `B' above (and that `e2' belongs to `A')
07:06:48 <RLa> yeah, i get it
07:07:19 <ski> if you're trying to prove something about all expressions in normal form, you should probably do a mutual induction on the `A' and `B' forms
07:08:16 <siracusa> Why does lambdabot ignore :t in private chat?
07:08:29 <ski> (possibly these two forms have better names; i can't remember any such atm, though)
07:08:30 <roconnor> siracusa: @t
07:08:36 <ski> siracusa : unknown. use `@type'
07:08:54 <siracusa> Yes, but it works here
07:08:59 <siracusa> :t map
07:09:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:09:05 <roconnor> :O
07:09:10 <ski> @type map
07:09:11 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:09:16 <quicksilver> siracusa: yes, we know you are right.
07:09:23 <ski> works in both places
07:09:26 <quicksilver> siracusa: but the answer is still use @type in personal messages
07:09:30 * roconnor didn't know
07:09:37 <RLa> when expression is not abstraction then it's type cannot be something1 -> something2?
07:09:49 <ski> incorrect
07:09:59 <opqdonut> it can be a variable
07:10:06 <opqdonut> and a variable's type can be anything
07:10:25 <ski> in `\x. \y. y x', the type of the subexpression `y' must be a function type, yet `y' is not an abstraction expression
07:10:41 <RLa> hm, i see
07:11:19 <siracusa> quicksilver: But that doesn't answer my question ;-)
07:11:31 <ski> siracusa : see "unknown" :)
07:11:54 <ski> (well, presumably *someone* knows ..)
07:12:02 <danishkirel> I am pretty new to haskell and I am a bit puzzled over some syntax I am seeing in source files (e.g. http://hackage.haskell.org/packages/archive/loli/2009.10.13/doc/html/src/Network-Loli-Template.html#text)
07:12:26 <quicksilver> siracusa: there is no good answer to your question.
07:12:30 <ski> danishkirel : what are you puzzling over ?
07:12:37 <quicksilver> siracusa: it doesn't work because it is programmed not to work.
07:12:46 <danishkirel> (x.fromString) pretty much certainly means (fromString x) but why can the author write it that way?
07:12:52 <quicksilver> siracusa: we know of no reason for the programming
07:13:38 <Botje> danishkirel: you'll have to figure out where the - and . operators are redefined
07:13:53 <siracusa> quicksilver: Ok, I just thought it's maybe another bot that passes a translation to lambdabot or so.
07:13:55 <ski> danishkirel : because the author showed bad style and has hidden the normal binding for `(.)' (`import Prelude hiding ((.), (>), (^), (-), (/))'), instead importing some other module that presumably defines `x . f = f x'
07:14:31 * fax sighs... I know what people do in the privacy of their own .hs file is none of my buisness but that is just sick
07:14:40 <danishkirel> ski: Ah! i did not pay attention to that import :o
07:14:41 <EvanR-work> hah
07:16:15 <opqdonut> can't find the definitions, tho
07:16:17 <opqdonut> probably in Hack
07:17:20 <roconnor> @seen dmwit
07:17:20 <lambdabot> Unknown command, try @list
07:17:26 <roconnor> preflex: seen dmwit
07:17:27 <preflex>  dmwit was last seen on #haskell 15 hours, 26 minutes and 27 seconds ago, saying: Your big program is then a ReaderT wrapping that record...
07:19:11 <RLa> ski, is \x -> e in normal form without x appearing in e?
07:19:19 <roconnor> dmwit's most recent reddit comment has left me speechless.  I can't believe he really thinks that: <http://www.reddit.com/r/haskell/comments/bzwcn/consensus_failure_bikeshedding_kills_another/c0pgozv?context=3>
07:19:30 * roconnor head 'slodes
07:19:49 <danishkirel> Ok. it's http://hackage.haskell.org/package/mps that allows the x.fn syntax
07:20:00 <dmwit> roconnor: You can't believe that I don't mind installing libraries?
07:20:00 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
07:20:19 <roconnor> dmwit: ah you are here
07:20:24 <ski> RLa : i'm not sure what you're asking ..
07:20:28 <ski> `\x. y' is in normal form even though `x' doesn't appear free in `y'
07:20:47 <roconnor> dmwit: no it is that you think that *everyone* should install network
07:20:51 <RLa> ski, then i have big fail
07:20:57 <roconnor> whether or not they are on an OS with networking or not.
07:21:04 <ski> RLa : how so ?
07:21:41 <dmwit> roconnor: It's in the Platform...
07:21:44 <RLa> well, i have e in normal form and by IH i assume it's typable
07:22:11 <ski> (btw, i would prefer texts talking about "possibly occurs free" rather than "occurs free" ..)
07:22:19 <RLa> but i need type for x to type the whole expression
07:22:28 <ski> yes
07:22:51 <ski> what are you trying to do ?
07:22:56 <RLa> in my rules type of x comes from context of e
07:22:58 <ski> write a type-inferencer ?
07:23:05 <ski> prove something about a type-inferencer ?
07:23:12 <roconnor> dmwit: then apparenlty not everyone can install the haskell platform
07:23:32 <RLa> no, i just try to prove that all normal forms are typable in 2nd order calculus
07:23:40 <RLa> in curry settings
07:24:01 <ski> hm, how is `\x. x x' typable ?
07:24:03 <roconnor> dmwit: does network build under yhc, ghc, nhc, and jhc?
07:24:16 * dpratt71 is feeling rather frustrated with hackage at the present
07:24:18 <RLa> hm, in 2nd order it is
07:24:42 <ski> with implicit `forall' -elimination and -introduction rules ?
07:24:42 <RLa> (\x. x x) (\x. x x) is not tho
07:24:45 <dmwit> roconnor: Now you're stretching for complaints.
07:24:46 <roconnor> dmwit: or better yet, does the haskell platform build on all those?
07:24:52 <applicative> danishkirel, are they telling you that Loli has 'bad style'?
07:24:59 <roconnor> dmwit: haskell is not ghc
07:25:00 <dpratt71> there is no such thing as a hackage mirror, correct?
07:25:02 <ski> applicative : yes
07:25:15 <RLa> ski, yes, with those 2
07:25:25 <ski> ok
07:25:27 <applicative> haha.  its not bad style its just wacko style....or maybe
07:25:27 <RLa> no, they are explicit
07:25:30 <fax> haskell is not ghc <--- I WISH more people would agree on this
07:25:30 <applicative> cowboy style
07:25:37 <RLa> but for church style
07:25:55 <dmwit> roconnor: You're right, but so many packages on Hackage are not GHC that that particular complaint doesn't really convince me very much.
07:26:01 <fax>  I thought out of everyone haskell people would be the last to abuse terminology like that
07:26:04 <dmwit> s/GHC/Haskell98/
07:26:10 <dcoutts_> roconnor: the platform specifies ghc, however it tries not to make things too hard for other compilers to support the same set of packages
07:26:28 <RLa> ski, i have terms in normal forms but no type annotations as church style would require
07:26:50 <ski> *nod*
07:27:00 <roconnor> dmwit: `` but so many packages on Hackage are not GHC'' I don't understand this
07:27:09 <dmwit> roconnor: typo, I meant Haskell98, not GHC
07:27:11 <ski> roconnor : <dmwit> s/GHC/Haskell98/
07:27:15 <dmwit> roconnor: (as my netx message says =)
07:27:26 <roconnor> ah missed that sorry
07:28:09 <dcoutts_> roconnor: I'd certainly welcome other Haskell implementation trying to support the platform libs
07:28:32 <RLa> ski, if i could assume somehow that x appears in e then i could get its type from there
07:28:47 <dcoutts_> roconnor: eg theoretically there's support for hugs, nhc and uhc in Cabal however I'm sure there are bugs there that need squashing
07:29:05 <ski> RLa : if `x' doesn't appear free in `e', then the domain of the type of `\x. e' is unconstrained
07:29:27 <ski> RLa : you could set it to anything you like .. or generalize, if you have implicit `forall'-introduction
07:30:09 <ski> RLa : e.g. the type of `\x. \y. y' could be `tau0 -> (tau1 -> tau1)'
07:31:58 <ski> it could also be `forall alpha. alpha -> (tau -> tau)' or `forall alpha0 alpha1. alpha0 -> (alpha1 -> alpha1)' or  `forall alpha0. alpha0 -> (forall alpha1. alpha1 -> alpha1)' (if you can introduce a `forall' implicitly at any point)
07:32:20 <RLa> so i will generalize it to \forall alpha.alpha when it doesn't appear in e, otherwise take type from context of e?
07:32:27 <roconnor> dcoutts_: what is needed to build say network?
07:32:51 <dcoutts_> roconnor: FFI and the base libs
07:33:07 <roconnor> dcoutts_: say I want to make a "safe" platform built in a chroot without network access?
07:33:09 <ski> RLa : well, to `\forall alpha. alpha -> tau', rather, yes ?
07:33:24 <roconnor> dcoutts_: that wouldn't be possible presumably
07:33:46 <dcoutts_> roconnor: you mean to guarantee the build process never touches the network?
07:34:12 <roconnor> to guarentee nothing can even remotely touch the network
07:34:28 <dcoutts_> roconnor: then use your OSs security / permissions system
07:34:40 <roconnor> ya, that's worked well in the past
07:34:43 <EvanR-work> unplug the cable ;)
07:34:53 <danishkirel> applicative: Actually i've thought about making haskell look like oo myself ;)
07:34:59 * ski . o O ( unplug the universe )
07:35:00 <roconnor> dcoutts_: using a chroot *is* using my OS's security system.
07:35:19 <dcoutts_> roconnor: then you're fine. Perhaps I've missed the point of your question.
07:35:44 <roconnor> dcoutts_: I'm worried that the network library and hence HP won't build without some sort of network C library available.
07:35:58 <RLa> ski, hm, yes
07:36:14 <applicative> danishkirel, people try that.  I would hold there's nothing wrong with it.  In the end it puts a strain on communication.  It's surprising jangning wang has kept it up for so long.
07:36:29 <opqdonut> roconnor: access to the network shouldn't be controlled by the existence/nonexistence of some lib
07:36:46 <opqdonut> but by access to the interface itself
07:36:55 <dcoutts_> roconnor: that's true, but having the C library available doesn't mean it needs to access the network, and conversely the lack of a C lib does not guarantee that the build process cannot do something nasty (in the absence of OS security)
07:36:59 <ski> RLa : it appears to me that you're actually wanting to code a (total) type-inferencer for normal terms
07:37:31 <roconnor> opqdonut: hmm, good point.
07:37:44 <ski> RLa : so, i would attempt something similar to a normal inference process, except in this case, it really should never fail (type error)
07:37:47 <opqdonut> one can always just call the relevant syscalls himself
07:37:49 <dcoutts_> roconnor: as it happens, network access is part of the glibc library on linux, so there's not really anything you could remove anyway
07:37:51 <opqdonut> if they're available
07:37:54 <opqdonut> the lib just makes it easier
07:37:57 <applicative> danishkirel, Jinjing W.
07:38:02 <roconnor> dcoutts_: really? god.
07:38:07 <ski> RLa : i'm not sure whether this is a good approach in your case, but that's what i would attempt
07:38:34 <dcoutts_> roconnor: as opqdonut says, the security does not come from access or lack thereof to a C lib, it's done as the OS level
07:39:32 <roconnor> dcoutts_: in theory it could come from lack of access of a C lib, but I guess that isn't commonly done today.
07:39:51 <opqdonut> roconnor: one could always just compile the relevant code himself
07:39:51 <roconnor> opqdonut: you would just make the networking syscall a large random number.
07:40:00 <opqdonut> oh god
07:40:06 <EvanR-work> policy vs mechanism
07:40:07 <opqdonut> THAT's your security?
07:40:11 <dcoutts_> roconnor: I don't think it could, but it could come from the lack of access to a network service / demon
07:40:31 <roconnor> opqdonut: it works for my router.
07:40:38 <dcoutts_> roconnor: eg in an L4 microkernel style system, just don't provide access to the network service process and that's it
07:41:11 <roconnor> dcoutts_: but in such a system network would still build?
07:41:21 <opqdonut> sure
07:41:24 <jmcarthur> you can probably use a bsd jail to do that
07:41:28 <dcoutts_> roconnor: if the C header files are available, yes.
07:41:45 <opqdonut> roconnor: well by what process is the syscall number handed to the c library then?
07:41:45 <roconnor> dcoutts_: what happens when I try to open a port?
07:41:56 <opqdonut> return -EACCESS
07:41:58 <opqdonut> happens
07:42:08 <dcoutts_> roconnor: or -ENOSYS
07:42:16 <opqdonut> or whatever
07:42:32 <opqdonut> building stuff that uses capabilities that are not preset _is_ actually a pretty common thing :)
07:42:57 <dcoutts_> for example, build a server that can talk locally over unix domain sockets
07:43:05 <dcoutts_> that uses the same API as network sockets
07:43:19 <roconnor> ok
07:43:42 <opqdonut> roconnor: I'm intrigued, which router were you talking about?
07:43:52 <dcoutts_> and at runtime if you try to configure it to listen to the network, and that's prevented either by the fact there is no network, or that security policy prevents it, then it'd fail
07:43:57 <roconnor> any router
07:44:12 <roconnor> opqdonut: anyone who knows my WEP key gets access to my wireless network.
07:44:20 <roconnor> well
07:44:23 <opqdonut> ah okay, I misunderstood
07:44:24 <EvanR-work> and anyone who doesnt ;)
07:44:27 <roconnor> ingoring the brokenness of WEP
07:44:54 <roconnor> <opqdonut> building stuff that uses capabilities that are not preset _is_ actually a pretty common thing :)
07:44:57 <roconnor> I didn't understand this
07:45:04 <opqdonut> but sure, only letting somehow validated C libraried get access to capabilities is an okay solution
07:45:07 <jmcarthur> heh yeah WEP is borked
07:45:23 <opqdonut> roconnor: well, for example, you can build gnome on a machine without a video card
07:45:41 <roconnor> dcoutts_ opqdonut: can you give me more details to what happens when I try to open a port.  How the failure comes about?
07:45:45 <opqdonut> but there is no such validation in unixen that I'm aware of
07:45:59 <opqdonut> symbian uses signed programs that are granted capabilities
07:46:22 <jmcarthur> you could always use ptrace or strace to filter system calls
07:46:26 <opqdonut> which seems to be a pretty secure model (if you ignore the fact that some processes like the debugger have unlimited powers...)
07:46:36 <arw> well. "admin gives suid-bits only to stuff he trusts" is some kind of trivial validation.
07:46:37 <dcoutts_> roconnor: I think the C bind() call would fail
07:46:40 <opqdonut> roconnor: the relevant system call fails
07:47:39 <EvanR-work> interesting
07:47:47 <EvanR-work> program crashed with err msg <<loop>>
07:47:56 <EvanR-work> how did THAT happen :S
07:47:58 <roconnor> sure but why does the syscall fail?  What is the OS doing?
07:48:09 <opqdonut> roconnor: the OS does whatever it does
07:48:11 <ski> EvanR-work : that means your program entered an infinite loop
07:48:15 <roconnor> EvanR-work: you did something like let x = x in x
07:48:20 <ski> (and your implementation detected it)
07:48:32 <roconnor> @faq can haskell solve the halting problem?
07:48:33 <lambdabot> The answer is: Yes! Haskell can do that.
07:48:40 <EvanR-work> ah
07:48:51 <roconnor> opqdonut: in the secure L4 example I mean
07:48:59 <EvanR-work> let mails = map (\(m,d) -> m {domain = d}) (zip mails domains2)
07:49:01 <dcoutts_> roconnor: oh the L4 example is different
07:49:02 <roconnor> <dcoutts_> roconnor: eg in an L4 microkernel style system, just don't provide access to the network service process and that's it
07:49:16 <ski> EvanR-work : yeah, that could do that
07:49:17 <dcoutts_> roconnor: there, you simply do not get provided with the network service
07:49:28 <EvanR-work> thats pretty amazing that the runtime system detects an infinite loop and crashes
07:49:28 <ski> EvanR-work : try replacing `(m,d)' with ` ~(m,d)'
07:49:28 <roconnor> sure, so what happens when I call bind() ?
07:49:31 <dcoutts_> roconnor: so there's nobody to ask
07:49:36 <jmcarthur> roconnor: L4 is a drastically different model
07:49:52 <roconnor> jmcarthur: that's why I'm asking :)
07:49:58 <jmcarthur> bind isn't even a syscall
07:49:59 <ski> EvanR-work : s/crashes/aborts/
07:50:09 <roconnor> jmcarthur: so what happens?
07:50:12 <dcoutts_> roconnor: ok, so a C lib implementing unix bind() on top of L4 would fail because the process had not been provided the network service
07:50:18 <EvanR-work> i got a parse error from putting ~
07:50:30 <ski> EvanR-work : note the extra space
07:50:33 <jmcarthur> roconnor: with L4 you would send a message to another process, but if you don't have the handle for that process then you can't send the message
07:50:42 <arw> roconnor: when you call bind() and you don't have permissions to do stuff, you get an error and errno=EACCESS.
07:50:51 <roconnor> jmcarthur: where does bind store the handle?
07:50:53 <jmcarthur> and it's not as simple as fabricating a PID
07:50:55 <EvanR-work> ski: still <<loop>>
07:51:11 <ski> EvanR-work : .. alternatively, maybe you actually *didn't* want to define `mails' recursively ?
07:51:14 <jmcarthur> roconnor: bind doesn't exist in the unixy sense
07:51:18 <EvanR-work> i really didnt
07:51:26 <ski> EvanR-work : maybe you actually wanted to define a new `mails' in terms of an earler one ?
07:51:31 <EvanR-work> yes
07:51:33 <dcoutts_> roconnor: it's as jmcarthur says, and a Unix bind emulation would be constrained in the same way
07:51:33 <roconnor> jmcarthur: well I mean the Bind from Haskell.
07:51:49 <ski> EvanR-work : `let' introduces recursive bindings, so rename one of the `mails'
07:51:55 <jmcarthur> roconnor: i don't think haskell runs on L4 (yet?)
07:52:03 <EvanR-work> ski: yeah
07:52:10 <dcoutts_> roconnor: the Haskell bind would call the C bind which would fail because it does not have the handle for the network process
07:52:10 <ski> (EvanR-work : or use monadic or list-comprehension binding)
07:52:11 <roconnor> jmcarthur: but could the Haskell Platform build on an L4 system?
07:52:18 <dcoutts_> roconnor: yes
07:52:21 <roconnor> good
07:52:29 <jmcarthur> it could with some support libs
07:52:33 <Jafet> L4 is a... kernel?
07:52:35 <roconnor> but I'm currious as to the method of failure
07:52:39 <jmcarthur> Jafet: yes
07:52:55 <arw> there is l4linux where you can get the usual linux syscall interface. but i'm not quite sure how the capability system works in that case.
07:52:58 <roconnor> the c bind function tries to send a message over some handel
07:53:02 <jmcarthur> roconnor: it's not a check. it's just not an available capability
07:53:03 <EvanR-work> that, of course, fixed it
07:53:05 <roconnor> but the handle is null, so it fails right?
07:53:12 <jmcarthur> no
07:53:14 <roconnor> but where is the handle stored?
07:53:16 <Jafet> Does ghc really care what the kernel is?
07:53:16 <roconnor> oh
07:53:46 <roconnor> jmcarthur: there has to be some check somewhere otherwise bind could decide wether to fail or succeed
07:53:46 <arw> Jafet: no. but it will care about the syscall layer which is very different in the case of L4
07:53:47 <jmcarthur> roconnor: you would get the handle from some other process. perhaps the parent process
07:53:53 <dcoutts_> roconnor: something like that, the details of the emulation on L4 is not really that important. Point is it is necessarily a runtime failure.
07:53:57 <jmcarthur> roconnor: there is no "bind"
07:54:01 <roconnor> jmcarthur: but Bind doesn't take a handle as a parameter
07:54:13 <jmcarthur> roconnor: L4 doesn't have bind
07:54:15 <roconnor> in Haskell
07:54:30 <roconnor> so we cannot build network then
07:54:33 <jmcarthur> roconnor: in order to behave in an L4-like way, the Haskell API would need to be different
07:54:37 <roconnor> because the network interface is wrong
07:54:39 <roconnor> see
07:54:46 <roconnor> network can't build on L4
07:54:50 <roconnor> and hence neither can HP.
07:54:51 <jmcarthur> roconnor: there could still be an emulation layer
07:55:05 <opqdonut> roconnor: no surprises there, it's not a supported platform
07:55:09 <jmcarthur> see L4Linux, for example
07:55:27 <jmcarthur> although i doubt L4Linux gives you any security benefits over vanilla linux
07:55:34 <roconnor> opqdonut: but dmwit specifically is saying it is okay to make programs that unneccerily depend on network
07:55:35 <dcoutts_> with an emulation layer it'd work unchanged, a Haskell network lib that worked in more of an L4 way would have a network initialiser and that's the one that would fail.
07:55:37 <jmcarthur> there are probably other unix layers too
07:56:00 <roconnor> opqdonut: because, apparently, it is okay not to care about L4 OSs
07:56:12 <jmcarthur> roconnor: you can build against headers even if you aren't allowed to use the functions at runtime
07:56:22 <dpratt71> is there an off-peak time where I would have better luck doing a "cabal update"?
07:56:44 <opqdonut> I can't see what l4 has to do with the issue of depending on network
07:57:00 <opqdonut> it was a contrived example
07:57:04 <jmcarthur> L4 came up in discussion about security mechanisms
07:57:08 <roconnor> opqdonut: because the network API don't work on L4 and hence doesn't build.
07:57:54 <opqdonut> but yes, having a library depend on network is a bit unnice if network doesn't always compile
07:58:00 <roconnor> Ultimately I'm trying to illustrate why MissingH is horrible.
07:58:09 <jmcarthur> dpratt71: it's slow right now, but not too slow to work (for me):  cabal update  7.32s user 0.29s system 25% cpu 29.790 total
07:58:35 <roconnor> it is clear to me but dmwit, a smart guy, disagrees
07:59:01 <roconnor> I'm trying to convince him that it is horrible, or be convinced myself that it is not.
07:59:07 <dcoutts_> roconnor: missingh is horrible, because it's not focused on an area of functionality
07:59:12 <opqdonut> missingh looks like it should be split into a bunch of packages
07:59:28 <dcoutts_> it's a mismash from before the time we had a half-decent packaging system
07:59:47 <roconnor> dmwit says "Yes, it is annoying that packages that provide a wide range of convenience functions also have a wide range of dependencies. But maybe that's not so bad after all; especially in this case, I think it's pretty reasonable to expect things like containers, mtl, base, array, directory, process, parsec, and network to be installed already, and grabbing a few more libraries is a small price to pay to avoid code duplication!
07:59:52 <dcoutts_> opqdonut: it partly has been
08:00:11 <gwern> quite. ironically, bits in missingh are better than their equivalent split-out packages
08:00:13 <roconnor> Specifically I want to defend the thesis that it is not unreasonable to not have network installed.
08:00:28 <dpratt71> jmcarthur: thanks for checking; it's just taking forever here to download 00-index.tar.gz
08:00:51 <roconnor> it seems to be the easiest dependency to attack
08:00:55 <dpratt71> I tried to download it directly via the browser just to make sure it wasn't some other problem...
08:01:01 <gwern> for example, 'datapacker' draws on the sorting-items-into-buckets module in missingh; the other binpacking package is much harder to use and does infinite loops (!) if you put in something too large
08:01:12 <gwern> not cool
08:01:13 <dpratt71> ...same result...it shows no sign of completing this century
08:01:31 <dpratt71> otherwise my network connection seems fine, reasonably fast
08:02:27 <jmcarthur> dpratt71: it's going slower than normal for me, but obviously still works
08:03:20 <dpratt71> jmcarthur: ok, well I guess there's some kind of internet traffic jam between there and here
08:03:27 <roconnor> dcoutts_: although it is perhaps plausible to add an emulation layer to get HP networking to work on an L4 system, it seems wrong.
08:03:28 <jmcarthur> clogged tubes
08:03:39 <roconnor> dcoutts_: we'd want an L4 sepecific HP wouldn't we?
08:03:39 <dcoutts_> dpratt71: does it work via your browser but not via cabal update?
08:03:50 <jmcarthur> roconnor: L4 is designed with things like that in mind
08:04:01 <dpratt71> dcoutts_: same for both; the DL speed is a trickle
08:04:09 <jmcarthur> roconnor: in fact, you would probably be laughed at if you insisted on using L4 "in the raw"
08:04:14 <dcoutts_> dpratt71: ok, just checking it's not cabal's fault :-)
08:04:19 <gwern> jmcarthur: really? why?
08:04:20 <roconnor> jmcarthur: why?
08:04:27 <jmcarthur> gwern: it doesn't do enough by itself
08:04:31 <jmcarthur> to be very useful
08:04:31 <dcoutts_> roconnor: right, you'd not target L4 directly but a unix service layer on top of L4
08:04:37 <gwern> jmcarthur: it seems to me that a host+l4 ought to be less secure than l4
08:04:38 <dpratt71> dcoutts_: yeah, it seems to be the connection
08:04:39 <jmcarthur> unless you are just writing low level drivers or something
08:04:39 <roconnor> (granted the nixos people laughed at me for installing in on "bare hardware")
08:04:47 <roconnor> (but that is an aside)
08:04:54 <applicative> http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/network-2.2.1.7#direct   -- it'd be hard to argue you shouldn't have network installed
08:04:58 <applicative> Direct reverse deps.: 224 ; Indirect reverse deps.: 165
08:05:06 <gwern> > 224 + 165
08:05:07 <lambdabot>   389
08:05:10 <dpratt71> CNET speed test says my connection speed is 1386.8 Kbps
08:05:13 <gwern> that's a lot of packages
08:05:22 <dcoutts_> roconnor: if you wanted to use Haskell to write low level L4 servers then yes you'd need a new native API and would not be able to use things like the network package or System.IO or most of the other IO functions from the Prelude.
08:05:23 <roconnor> dcoutts_: what do you mean by a unix service layer?  Not a posix layer I'd hope.
08:05:29 <dcoutts_> roconnor: yes exactly that
08:05:43 <EvanR-work> haskell drivers?
08:05:45 <roconnor> dcoutts_: but WTF is the point of L4 with a shitty posix layer on top?
08:05:59 <applicative> gwern, darcs  pandoc etc etc
08:06:02 <jmcarthur> gwern: L4 provides the mechanisms for security, but of course drops you off with full privileges. it's expected that the first process will init everything else and establish security baoundaries
08:06:07 <dcoutts_> roconnor: I think you have that impression from the shitty posix layers on Windows.
08:06:10 <roconnor> I'm probably missing something important here?
08:06:10 <jmcarthur> *boundaries
08:07:19 <roconnor> tell me more about this posix networking emulator for L4.
08:07:24 <roconnor> what does bind() do?
08:07:26 <dcoutts_> roconnor: L4 is kind of like a toolkit for making OSs, you never write high level apps directly on the basic L4 kernel, you need an "OS layer" like POSIX.
08:08:04 <roconnor> dcoutts_: but posix doesn't model capabilities security, it only models ACLs
08:08:05 <roconnor> right?
08:08:15 <Jafet> eros!
08:08:19 <jmcarthur> roconnor: no, you're right. if you are using L4 for security but you run everything under a POSIX layer then nothing is actually isolated. but you could run a POSIX layer besides something else and those could be properly isolated, at least
08:08:44 <jmcarthur> Jafet: coyotos
08:08:51 <jmcarthur> eros is dead
08:09:14 <applicative> jmcarthur, we're sorry to hear that
08:09:18 <Jafet> I just name eros because it's sexy.
08:09:22 <EvanR-work> haiku!
08:09:35 <jmcarthur> http://www.coyotos.org/
08:09:36 <roconnor> Jafet: there is an Eros for haskell
08:09:44 <jmcarthur> roconnor: but it's different
08:09:51 <roconnor> very different
08:10:00 <roconnor> but same sexy name
08:10:29 <dcoutts_> roconnor: for example the people at OK-labs run multiple instances of linux under their OK-L4 system, the instances are isolated except for limited shared capabilities (eg to share some bits of hardware, or access to certain drivers)
08:10:30 <roconnor> jmcarthur: okay so why do L4 people think it is funny not to use an POSIX layer when you yourself just noted that it basically destroys all the nice properties of L4?
08:10:47 <dcoutts_> roconnor: so you can run useful apps, like Linux
08:10:48 <jmcarthur> roconnor: it's funny not to use *some* abstraction layer
08:10:58 <jmcarthur> doesn't have to be posix
08:11:04 <Jafet> Doesn't selinux, for example, provide capability based control?
08:11:05 <roconnor> jmcarthur: sure but we don't want to use a posix layer!
08:11:12 <jmcarthur> roconnor: right
08:11:12 <Jafet> The problem seems orthogonal
08:11:21 <roconnor> jmcarthur: fine, so whatever layer we use we need an HP for that layer.
08:11:30 <jmcarthur> roconnor: basically our APIs are all wrong for security in the L4 sense
08:11:46 <roconnor> and this different HP will have a different network API
08:11:56 <jmcarthur> HP == ?
08:12:01 <roconnor> Haskell Platform
08:12:02 <fryguybob_> So it seems to me that the whole dependency tree that is the packages that make up HP is something that should be subject to refactoring.  Sort of like meta patch algebra.  Can we make some metrics that show that a given dependency tree is "better" than another?
08:12:03 <jmcarthur> ah
08:12:26 <dcoutts_> roconnor: if you're shooting for ultimate portability then you really have to eschew IO completely. There's no useful portable IO layer that will work with every OS you can dream up.
08:12:29 <jmcarthur> pretty much anything relying on unixy syscalls needs to be different
08:12:35 <roconnor> and in particular MissingH and anything depending on it won't work for such a system.
08:12:46 <fryguybob_> Then build up tools to make that kind of change without breaking everything in the world?
08:12:51 <dcoutts_> roconnor: but then nor will anything else that uses IO
08:13:04 <roconnor> dcoutts_: right, and if you write a haskell lib that doesn't do any IO, then you shouldn't depend on network.
08:13:17 <jmcarthur> roconnor: what's your point?
08:13:33 <Saizan> roconnor: nor base, though
08:13:34 <gwern> don't worry everyone. frp will save us one day
08:13:48 <roconnor> jmcarthur: my point is that MissingH is horrible because it has many dependencies unrelated to some individual functions you may be using.
08:13:51 <dcoutts_> Saizan: nor Prelude :-)
08:14:12 <jmcarthur> roconnor: i agree that such packages should be split up
08:14:13 <roconnor> dcoutts_: dmwit thinks it is okay to depend on network.
08:14:14 <RLa> can someone explain me what does mean valid environment in type checking context?
08:14:15 <dcoutts_> openFile !?! what makes you think you have access to a filesystem?
08:14:21 <jmcarthur> "horrible" may be taking it too far
08:14:28 <roconnor> dcoutts_: because network is part of HP.
08:14:52 <jmcarthur> roconnor: HP would not be a great fit for every possible OS
08:14:59 <applicative> there should be Prelude.Pure and Prelude.StandardIO which must be imported explicitly
08:15:44 <dcoutts_> roconnor: I've already said I disagree with dmwit, I'm not sure you're making the best argument against it though
08:15:51 <jmcarthur> applicative: in separate packages, of course
08:16:06 <Saizan> RLa: each type system might have its own definition for validity of an environment/context, though usually it means there are no duplicates bindings and that their use follows them
08:16:07 <jmcarthur> what did dmwit claim?
08:16:17 <applicative> jmcarthur, right.
08:17:10 <RLa> Saizan, thanks
08:17:13 <jmcarthur> applicative: of course, if we're going to such lengths for cross-platform, we should also specify things like Int more tightly
08:17:14 <roconnor> dcoutts_: oh
08:17:19 <roconnor> dcoutts_: could be
08:17:25 <roconnor> dcoutts_: what's a better argument?
08:17:30 <gwern> specify Int more tightly?
08:17:34 <gwern> how's that?
08:17:53 <roconnor> jmcarthur: I diagree, We have Int32 and such for those things people need to know specifically.
08:17:54 <applicative> jmcarthur, this project sounds really hard.
08:18:04 <roconnor> disagree
08:18:06 <monochrom> For example explicitly standardizing Int to be 32 bit. So that if you're on 4004 you still know Int is 32 bit.
08:18:10 * tibbe wishes he could share some internal studies of Google's code base related to API complexity.
08:18:23 <gwern> tibbe: just summarize them then
08:18:28 <roconnor> Int should be whatever fast integer is available for the hardware
08:18:37 <gwern> I swar, googlers and applers - them and secrecy!
08:18:37 <roconnor> the bounds are known at runtime
08:18:38 <applicative> tibbe, what would these studies show, or not show
08:18:39 <dpratt71> well, I managed to download the hackage index via the browser by restarting the download several times...
08:18:44 <roconnor> so you can make safe code.
08:18:54 <dpratt71> ...is there a way I can give this to cabal?
08:19:01 <tibbe> gwern: it's not quite fair in an argument thought
08:19:12 <gwern> tibbe: IRC is a bad forum if you wanted fairness...
08:19:20 <dcoutts_> dpratt71: put it where cabal puts it and also gunzip it
08:19:25 <gwern> dpratt71: move it where it should be in your ~/.cabal?
08:19:38 <tibbe> basically the danger of API growth, of the kind discussed lately in relation to adding functions to APIs
08:19:53 <dpratt71> dcoutts_, gwern: ok I'll try that, thanks
08:19:54 <roconnor> jmcarthur: dmwit's claim: http://www.reddit.com/r/haskell/comments/bzwcn/consensus_failure_bikeshedding_kills_another/c0pgozv?context=3
08:20:00 <Saizan> dpratt71: ~/.cabal/packages/hackage.haskell.org/ to be more specific
08:20:07 <dcoutts_> dpratt71: ~/.cabal/packages/$server/00-index.tar[.gz]
08:20:16 <tibbe> gwern: I meant share it as a part of an argument against adding functions to base libraries
08:20:20 <dpratt71> ok, thanks all
08:20:23 <roconnor> jmcarthur: for me it is one of those things that is clearly wrong, but I don't clearly know how to argue that it is wrong.
08:20:31 <roconnor> jmcarthur: and that is a bad state for me to be in.
08:20:41 <roconnor> jmcarthur: it is a sign of lack of understanding on my part
08:21:00 <jmcarthur> my last thoughts on Int: I don't think there's anything wrong with its existence really, just with it being a default for so many functions. i don't think it should even initially be in scope
08:21:10 <tibbe> gwern: generally the studies talks about the cost on Google as a whole that's caused by APIs growing by adding innocent looking functions that a group of functions found useful
08:21:23 <ski> jmcarthur : `Integral' ftw !
08:21:34 <gwern> tibbe: hm. even functions that are just combinators of existing functions in that api?
08:21:39 <tibbe> gwern: basically the practice of adding functions to base libraries for code reuse reasons rather than say abstract or performance reasons
08:21:54 <tibbe> gwern: in particular combinations of functions
08:21:57 <roconnor> jmcarthur: perhaps
08:22:10 <gwern> tibbe: what's the cost?
08:22:15 <tibbe> gwern: a term used [for C++] was the lack of the use of the sequential composition operator, semi-colon
08:22:24 <applicative> tibbe, so the policy of just redefining everything is best in the long run?
08:22:46 <monochrom> The result is Prelude.Twitter, which contains all functions implementable in 140 words or less.
08:22:54 <dcoutts_> gwern: presumably in terms of developer sanity and education, hard to find what you want and get up to speed with knowing an API
08:22:56 <gwern> applicative: surely that can't be right. I'm sure the best must be a mean
08:23:03 <tibbe> gwern: the normal ones that comes from complexity, bugs, difficulty in changing API implementations, slowed down development
08:23:21 <tibbe> applicative: not putting it in base APIs at least.
08:23:31 <gwern> it is easier to write incorrect code than understand correct code...
08:24:08 <tibbe> applicative: but yes, redefining trial things is sometimes better, or just sticking them in some helper module
08:24:48 <tibbe> this is from 50M+ lines code base
08:25:26 <RLa> there are tools that help to detect similar code around files
08:25:31 <tibbe> of particular interest was the discussion with the maintainers how the API got so bad. The answer: a little at the time
08:25:42 <aavogt> so this is like concatMap?
08:25:51 <RLa> sometimes this helps to identify functions and other stuff with similar functionality
08:25:57 <monochrom> "The road to hell is paved with good intentions"
08:26:01 <dpratt71> should I also "un-tar" it?
08:26:02 <tibbe> typical arguments that the maintainers regretted they accepted: we already do X so this doesn't make things work (or this is not different from what you already accepted)
08:26:07 <dcoutts_> dpratt71: no
08:26:18 <tibbe> monochrom: yes, it's definitely not due to stupid developers.
08:26:18 <dpratt71> dcoutts_: ok, thanks
08:26:25 <tibbe> monochrom: it's slow suffocation
08:26:28 <applicative> tibbe, is the pressure on the API coming from users, or the witty API authors who can't resist improvements
08:26:38 <tibbe> aavogt: yes
08:26:52 <applicative> I see, from the users
08:26:53 <fryguybob_> tibbe: "little at a time" seems doesn't seem to be able to work backwards as in improve the API a little at a time right?
08:27:13 <dcoutts_> aavogt: I claim concatMap is not an example of that, but that most named compositions of two functions are.
08:27:19 <tibbe> applicative: yes, in the long run. probably too tiresome to resist every developer that comes with a patch and says that he/she really really needs this
08:27:36 <applicative> google just needs an advanced Module system
08:27:53 <ski> dcoutts_ : maybe `concatMap' is, but `(=<<)' isn't ?
08:28:04 <tibbe> fryguybob_: you can try to remove things from public APIs but that often involves understanding, changing and testing 50 call sites
08:28:04 <ski> (the difference being in how you think of the operation)
08:28:21 <ManateeLazyCat> jutaro: I have seen your mail, sorry perhaps i can't help you.
08:28:29 <fryguybob_> tibbe: which implies that API's only get fixed with a "big change" involving some mechanical translation from old to new.
08:28:35 <dcoutts_> ski: maybe, it's because it's the list >>= that it's a bit special
08:28:43 <jutaro> ManateeLazyCat: Maybe you can just check if you have the segfault with the Completion demo. Then we have at least this compact example we need.
08:29:03 <tibbe> fryguybob_: yes, you can't easily clean up APIs little by little
08:29:07 <dcoutts_> ski: I'm not saying I'm going to start using =<< instead of concatMap however :-)
08:29:20 <ManateeLazyCat> jutaro: From your test, i think it's not simple some binding break.
08:29:26 <tibbe> fryguybob_: google is actually in a better position to that than your typical OSS project as we have all the code under control
08:29:35 <gwern> oh noes
08:29:39 <gwern> our freedom is an illusion
08:29:44 <ManateeLazyCat> jutaro: I doubt c2hs in gtk2hs is break by ghc-6.12.2
08:29:56 <tibbe> gwern: your freedom to change your APIs without breaking other people's code yes. :)
08:30:04 <fryguybob_> tibbe: So it seems to only make that kind of change along with some with bigger "breaking" changes (I'm looking at you simplistic module system...)
08:30:09 <ManateeLazyCat> jutaro: If that's right, i'm not best guy to fix c2hs.
08:30:13 <jutaro> ManateeLazyCat: I mean not to find the bug, but to affirm that I have found a valid test case.
08:30:37 <ManateeLazyCat> jutaro: Ok, i try to test that.
08:30:55 <Saizan> however, since we have id/flip/.. i think we should have swap, the name conveys a concept that the bare lambda doesn't
08:31:01 <Saizan> you've to do some inference there.
08:31:03 <jutaro> ManateeLazyCat: Great, thanks.
08:31:12 <Saizan> if you use the lambda, i mean
08:31:28 <fax> nobody know how to compute (p-1)! mod p efficiently!!
08:32:00 <tibbe> so now I'm of the belief that additions to an API should (in general) be motivated by adding things that wasn't expressible using the API, adds abstraction (not code reuse!), or makes it possible to do something efficiently that wasn't possible with the API
08:32:09 <dcoutts_> tibbe: yes
08:32:16 <fax> @let factorial n = product [1..n]
08:32:17 <lambdabot>  Defined.
08:32:27 <fax> > (factorial (11-1))`mod`11
08:32:28 <lambdabot>   10
08:32:29 <dcoutts_> tibbe: perhaps the right thing is to say that a bit of copy and paste for simple compositions of API functions is OK
08:32:35 <fax> > (factorial (13-1))`mod`13
08:32:37 <lambdabot>   12
08:32:44 <dcoutts_> tibbe: and to have docs that have a set of such examples to look at and copy
08:32:46 <tibbe> Saizan: I'm not sure, I think you need a stronger argument that: We've done this before so it's OK to do it again.
08:32:56 <tibbe> dcoutts_: I think so
08:32:58 <Twey> @let factorials = scanl (*) 1 [1 ..]
08:33:00 <lambdabot>  Defined.
08:33:19 <Saizan> tibbe: that wasn't the whole argument
08:33:20 <fax> lol it seems to always give p-1
08:33:33 <tibbe> dcoutts_: Or alternatively put things that are extracted for simple code reuse in different libraries
08:33:35 <dcoutts_> Saizan: why should we define a new name when we already have special language support for swapping tuples?
08:33:36 <Twey> @let f p = mod (factorials !! p - 1) p
08:33:37 <fryguybob_> tibbe: Isn't there room for smarter scm that handles "upgrade your API use to version x"?
08:33:37 <lambdabot>  Defined.
08:33:42 <tibbe> Saizan: sorry, I missed the other part
08:33:46 <fax> > f . [1..]
08:33:46 <Twey> > f 13
08:33:47 <lambdabot>   Ambiguous occurrence `f'
08:33:47 <lambdabot>  It could refer to either `L.f', defined at <local...
08:33:47 <lambdabot>   Ambiguous occurrence `f'
08:33:47 <lambdabot>  It could refer to either `L.f', defined at <local...
08:33:49 <fax> ffffffffffff
08:33:51 <Twey> D'oh
08:33:53 <Twey> > L.f 13
08:33:54 <lambdabot>   12
08:33:56 <fax> > L.f . [1..]
08:33:58 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,14,13,11,15,0,21,22,15,1...
08:34:10 <fax> look there are odd bits further along
08:34:10 <Saizan> tibbe: your summary wasn't all of what i said in the line above :)
08:34:10 <Twey> Look, there's a zero
08:34:14 <Twey> Heh
08:34:15 <fax> > drop 100 $ L.f . [1..]
08:34:16 <lambdabot>   [100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,11...
08:34:17 <fax> this is cool
08:34:19 <Twey> Interesting pattern
08:34:22 <fax> > drop 300 $ L.f . [1..]
08:34:23 <lambdabot>   [300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,31...
08:34:29 <fax> it looks regular around here
08:34:31 <Saizan> dcoutts_: well, we've special language support for composing functions and the identity function as well
08:34:37 <fax> (i.e. boring)
08:34:43 <Twey> Aye
08:34:46 <tibbe> fryguybob_: I guess you could automatically try to convert a call to a function you want to remove into a few calls to other functions. It's a bit scary to do automatically (and requires sophisticated tools) when billion of dollars are involved.
08:34:49 <fax> > drop 3000 $ L.f . [1..]
08:34:51 <lambdabot>   [3000,3001,3002,3003,3004,3005,3006,3007,3008,3009,3010,3011,3012,3013,3014...
08:35:12 <Saizan> dcoutts_: \f g x -> f (g x), \x -> x, aren't more complex than (\ ~(x,y) -> (y,x))
08:35:16 <tibbe> Saizan: I see. I don't think swap conveys much more
08:35:30 <gwern> I wonder why everyone wants 'swap'. 'swp' makes so much more sense
08:35:30 <fryguybob_> tibbe: Right, but with the right language involved that can control side effects, that becomes easier.
08:35:53 <tibbe> Saizan: not in the way length conveys more than foldl' (+ 1) 0
08:35:59 <Saizan> dcoutts_: (.) being infix is quite different though, i concede :)
08:36:02 <fax> I can't find any more 0s
08:36:02 <fryguybob_> tibbe: Certainly it is scary when you talk C++.
08:36:11 <ManateeLazyCat> jutaro: I think have some guy have install gtk2hs on Windows.
08:36:16 <ManateeLazyCat> jutaro: Just core packages.
08:36:20 <dcoutts_> Saizan: that's fair, it is also about familiarity. We're familiar with the stuff in the Prelude and from mathematical convention.
08:36:36 <dcoutts_> Saizan: and there's a cost to adding more names and using up more common names.
08:36:38 <tibbe> Saizan: or perhaps a better example: map can be expressed in terms of the list API (i.e. in terms of the exported data type) but is still good to add as it names an abstraction
08:37:21 <Saizan> tibbe: i agree, my point is that swap does the same
08:37:27 <tibbe> fryguybob_: even if you could do that automatically that only points at what to do when things have already gone wrong. we generate heaps of code so we need to teach people how not to get into these messes to begin with
08:37:43 <tibbe> Saizan: I understand. I'm just saying I'm not sure if I agree.
08:37:51 <fax> @oies 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,14,13,11,15,0
08:37:52 <lambdabot>  Sequence not found.
08:37:57 <ski> hehe
08:37:59 <fax> this is a new sequence!
08:38:07 <tibbe> \(x,y) -> (y,x) looks like swap to me
08:38:39 <dcoutts_> Saizan: and I don't claim to be completely consistent on this :-) I also like code that reads well, I still want to add equating to Data.Eq, like we've got comparing to Data.Ord. It just reads so nicely :-)
08:38:40 <Saizan> dcoutts_: right, but you can get familiar to more things, that's how languages work
08:38:51 <dcoutts_> Saizan: sure, it's a matter of degree.
08:39:00 <fryguybob_> tibbe: Right, but even the best intention leads to api failures because we can't always see what api's we will need.
08:39:26 <tibbe> I sometimes have the feeling that developers feel like definitions for general functions (or even simple auxiliary functions) in their source code somehow makes it dirty and then they want to push those into other people's code (e.g. libraries)
08:39:28 <fax> im going to have nightmare about this sequence
08:39:52 <tibbe> fryguybob_: sure, some guidelines of things not-to-do certainly doesn't make API design easy :)
08:39:59 <fryguybob_> tibbe: I just think the next generation of scm should be concerned with tackling api refactoring in a big way.
08:40:26 <dcoutts_> fryguybob_: you need the decent refactoring tools first
08:40:30 <fax> > priems
08:40:31 <lambdabot>   Not in scope: `priems'
08:40:33 <fax> > primes
08:40:34 <lambdabot>   Not in scope: `primes'
08:40:37 <fax> why doesn't haskell have primes
08:40:38 <Saizan> tibbe: even in one liners i prefer to define swap in a let, because with lambdas you've to chase the variables to see where they went
08:40:44 <tibbe> dcoutts_: I think 'on' would count as adding abstraction. I don't have a good objective way to tell the two apart though
08:40:54 <fryguybob_> dcoutts_: Haskell seems like a great place to make some good refactoring tools.
08:41:13 <ManateeLazyCat> jutaro: Okay, i have test it, segmentation fault, i will use gdb debugging it.
08:41:15 <gwern> fax: too many possible implementations
08:41:16 <tibbe> dcoutts_: still require thinking on the API designers part. I think what's missing is a good understanding among developers of the cost of adding things to APIs
08:41:19 <ManateeLazyCat> jutaro: Thanks for your report.
08:41:28 <dcoutts_> Saizan: that's fine, and possibly better than it being a "standard" function that nobody is familiar with
08:41:35 <tibbe> Saizan: sure, I define swap in lets sometimes
08:41:35 <aavogt> @src haskell'
08:41:35 <lambdabot> Source not found. I feel much better now.
08:41:45 <BMeph> fax: Too easy to just "whip up" a cheap-o. :)
08:42:01 <jutaro> ManateeLazyCat: One step
08:42:09 <fax> > findIndex (<100) $ drop 100 $ L.f . [1..]
08:42:14 <lambdabot>   mueval-core: Time limit exceeded
08:42:19 <ManateeLazyCat> Program received signal SIGSEGV, Segmentation fault. 0x0000000000ac5b44 in rts_getInt32 ()
08:42:19 <ManateeLazyCat>  
08:42:58 <ManateeLazyCat> dcoutts_: Any idea?
08:43:13 <BMeph> > nubBy (((>1).).gcd) [2..]
08:43:15 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:43:23 <BMeph> fax: ^^ Case-in-point. ;)
08:43:28 <Saizan> dcoutts_, tibbe: the arguments you make seem to suggest that you're using how many times you've used or seen used swap to judge
08:43:29 <dcoutts_> ManateeLazyCat: try getting a backtrace in gdb
08:43:40 <ezyang> Is it just me, or does cabal-install fail to put a colon for the Executable field from "cabal init"?
08:43:46 <fax> @let primes = nubBy (((>1).).gcd) [2..]
08:43:47 <lambdabot>  Defined.
08:43:52 <fax> > L.f . primes
08:43:54 <lambdabot>   [1,2,4,6,10,12,16,18,11,12,22,5,40,35,18,41,18,36,66,70,72,78,82,88,96,100,...
08:43:59 <fryguybob_> dcoutts_, tibbe: What if for every project I have a module that is the "waste bucket" of things "missing from the APIs", then every time I update the platform each function in there gets hoogled to some degree for replacements.
08:44:02 <fax> > map (+1) $ L.f . primes
08:44:04 <lambdabot>   [2,3,5,7,11,13,17,19,12,13,23,6,41,36,19,42,19,37,67,71,73,79,83,89,97,101,...
08:44:14 <fax> odd
08:44:42 <ManateeLazyCat> dcoutts_: Got it, looks have some useful information.
08:45:02 <fryguybob_> dcoutts_, tibbe: If there is enough momentum for a kind of function that is "missing" then the API's get refactored to include that the next major update.
08:45:06 <dcoutts_> Saizan: I don't think that's totally unreasonable if we accept that we have the functions we've already got and that we should be careful about adding new things because of the cost of growth.
08:45:28 * ManateeLazyCat pasted "gdb backtrace" at http://paste2.org/get/812187
08:45:38 <dcoutts_> ezyang: what do you think it's doing wrong exactly?
08:45:41 <fryguybob_> dcoutts_, tibbe: Then a new rule is added for "how do you update to the new api".
08:46:13 <aavogt> applying those rules is tricky
08:46:14 <ezyang> dcoutts_: If I select "this package provides an executable", it generates the line "Executable executablename". I think it should have a colon.
08:46:35 <ManateeLazyCat> dcoutts_: I decode symbol "gtkzm0zi10zi5_GraphicsziUIziGtkziGeneralziGeneral_mainGUI_info"
08:46:41 <tibbe> Saizan: I try not too. Say that a function is used often by some subset of Haskell programmers. They might arguing for adding it to base and doing so would make things somewhat better for them. However, it would make things slightly worse for everyone else. Now, if every subset of Haskell programmers added the functions they commonly define to the base libraries we would end up with a big mess.
08:46:42 <dcoutts_> ManateeLazyCat: so it's in a callback
08:46:50 <Twey> preflex: zdec gtkzm0zi10zi5_GraphicsziUIziGtkziGeneralziGeneral_mainGUI_info
08:46:51 <preflex>  gtk-0.10.5_Graphics.UI.Gtk.General.General_mainGUI_info
08:46:54 <Saizan> dcoutts_: i don't think that it's unreasonable either, i'm less sure about how much weight it should have, since if a function (or abstraction) isn't already there it's already way less likely to be used
08:47:08 <ManateeLazyCat> "gtk-0.10.5_Graphics.UI.Gtk.General.General_mainGUI_info"
08:47:08 <ManateeLazyCat>  
08:47:30 <ezyang> cabal init -n --is-executable
08:47:46 <aavogt> ezyang: doesn't it work without any colon?
08:47:47 <dcoutts_> Saizan: yes, that's convenient :-)
08:48:03 <tibbe> Saizan: this is why adding functions is so tricky and the incentives  for the people for and against adding the particular function is so different. That's why this needs to be addressed on the principle level instead on a case-by-case basis.
08:48:07 <dcoutts_> ezyang: are you talking about the syntax that ends up in the .cabal file?
08:49:02 <ezyang> Yes.
08:49:31 <dcoutts_> ezyang: oh, sorry, I missed your earlier comment. The syntax it produces looks correct to me.
08:49:37 * tibbe needs to go back to working.
08:49:39 <ezyang> Cabal gives a "construct not supported" if it tries to parse the result
08:49:41 <ezyang> Huh.
08:49:42 <Saizan> tibbe: but it seems you're doing the same in reverse "i'm not familiar with the use of this function so it doesn't look like an abstraction to me"
08:49:57 <tibbe> I'll plan to write together a coherent argument for my position on my blog some day.
08:50:02 <dcoutts_> ezyang: can you hpaste the whole .cabal file and the error message
08:50:10 <ezyang> sure
08:50:45 <tibbe> Saizan: sometimes you can see if something isn't abstraction pretty easy: fooAndBar = bar . foo is not an abstraction
08:50:56 * gwern waits for someone to invoke blub
08:51:16 <tibbe> Saizan: because it doesn't give a new name to anything
08:51:21 <Saizan> tibbe: sure
08:51:29 <monochrom> You just need to define "abstraction".
08:51:38 <Saizan> tibbe: i was talking about swap specifically
08:51:43 * Jafet arrives to invoke Blub
08:51:54 <ezyang> Oh, I see!
08:51:55 <Saizan> tibbe: or non-obvious cases if you want
08:52:02 <tibbe> monochrom: sure, I don't know if I can do so precisely.
08:52:02 <ezyang> It doesn't error on the file it outputs
08:52:29 <whald> jmcarthur: hello, how is the path tracing going?
08:52:38 <tibbe> monochrom: but even if can't do that I can point at the bad result of adding trivial compositions to APIs
08:52:43 <tibbe> monochrom: which I have support for
08:53:00 <Saizan> monochrom: do you suggest one?:)
08:53:02 <ezyang> huh, hpaste bot is not working
08:53:05 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25339#a25339
08:53:06 <tibbe> monochrom: so then my guidelines will be a bit one-sided (i.e. don't do this without saying do this)
08:53:14 <Saizan> s/suggest/have one to suggest/
08:53:15 <monochrom> tibbe: I need you to be around next time someone asks "why is ____ not in the Prelude?" :)
08:53:20 <jmcarthur> whald: hey. i didn't get a chance to do anything last night. other things came up IRL
08:53:50 <tibbe> Saizan: so I'm not sure about swap. In fact I'm not very interested in swap. What I care about is the arguments we bring forward to introduce new functions.
08:53:50 <ezyang> I'm fairly convinced I've misunderstood something, and would love to know what.
08:53:54 <turiya> hi
08:54:00 <whald> jmcarthur: good luck for you, it just too easy to get hooked up to that.. :-)
08:54:09 <tibbe> Saizan: And I'm saying that 1) many people do it and 2) we've done it before aren't good arguments
08:54:43 <tibbe> monochrom: :)
08:54:52 <turiya> does anyone know why opengl function calls result in a seg fault when used with mapM
08:54:56 <tibbe> monochrom: you can just invoke me as an argument from authority ;)
08:54:57 <Saizan> tibbe: "we have done it before and it proved useful"?
08:55:12 <ManateeLazyCat> jutaro: Sorry, i perhaps won't deep, realy haven't time.
08:55:17 <tibbe> Saizan: sure, but that boils down to "it proved [is] useful"
08:55:30 <Saizan> +to be
08:55:43 <jutaro> ManateeLazyCat: No problem, thanks again.
08:55:48 <tibbe> Saizan: but sure, if you can make a good argument for why it was useful
08:56:00 <tibbe> Saizan: (which isn't people used the function as that misses the point)
08:56:14 <fryguybob_> tibbe: Your reasoning for 1 & 2 is that you have data to show that those don't correlate to good API design.
08:56:18 <dcoutts_> ezyang: did cabal init generate that or did you add the "Main-is:" line manually?
08:56:38 <ezyang> I added Main-is
08:56:42 <fryguybob_> tibbe: So without tools to get that data, it's a little helpless right?
08:56:45 <ezyang> what cbal init generated parsed ok
08:56:52 <dcoutts_> ezyang: ok, you just missed out the indentation in the executable section
08:57:00 <ezyang> but the non-minimal output suggests that putting the lines should be afterwards
08:57:02 <ezyang> oh!
08:57:20 <tibbe> fryguybob_: right, or rather that it leads to bugs and slowed down development
08:57:35 <ezyang> huh, I guess I should go find an example file now
08:57:37 <fryguybob_> tibbe: right
08:57:39 <fax> @let fermat p = all (\a->(a^(p-1))`mod`p==1) [1..p-1]
08:57:40 <lambdabot>  Defined.
08:57:41 <quicksilver> turiya: I know that they do not.
08:57:44 <dcoutts_> ezyang: note that it indents the (commented out) fields
08:57:50 <fax> > head $ filter (not . fermat) primes
08:57:51 <ezyang> yeah, I see it now
08:57:54 <lambdabot>   mueval-core: Time limit exceeded
08:58:00 <tibbe> fryguybob_: that's why I started with saying that's a bit unfair for me to refer to Google internal studies
08:58:03 <fax> > head $ filter (not . fermat) (drop 20 primes)
08:58:07 <dcoutts_> ezyang: I guess cabal init for an exe should ask you for the main-is, since that is a required field.
08:58:07 <lambdabot>   mueval-core: Time limit exceeded
08:58:15 <ezyang> Yeah, I would agree
08:58:18 <fryguybob_> tibbe: :D, if you can't measure it it doesn't exist?
08:58:23 <turiya> quciksilver: when the opengl function is outside the mapM it works fine
08:58:45 <quicksilver> turiya: still, I know that mapM does not cause any problem with opengl functions.
08:58:50 <quicksilver> turiya: rather, you have some other problem.
08:59:07 <quicksilver> perhaps you're accessing invalid memory and it's just chance when you crash.
08:59:09 <ezyang> Also, if a .cabal file exists, cabal init should not overwrite it without good reason
08:59:24 <tibbe> fryguybob_: :)
08:59:27 <dcoutts_> ezyang: aye, would you like to file that as a bug report?
08:59:30 <ezyang> sure
08:59:41 <ClaudiusMaximus> turiya: how long is the list? are you consuming the result (if not then maybe use mapM_)?
08:59:52 <turiya> quiksilver: i am using something like mapM_ func (lines messages)
09:00:07 * tibbe goes back to work
09:00:07 <turiya> where messages are obtained from a server
09:00:24 <turiya> my opengl calls are in func
09:01:45 <pokoko222> http://projecteuler.net/index.php?section=problems&id=70 what does the last sentence mean? what kind of minumum does it refer to?
09:02:27 <quicksilver> turiya: I promise you, your problem is not with mapM
09:02:41 <quicksilver> turiya: I really promise it. There is no interaction between mapM and the openGL calls.
09:02:48 <RambO> Hey, I've got a problem here
09:02:52 <quicksilver> turiya: the problem is the specific calls you are making, in some way.
09:02:52 <RambO> I have a function
09:02:53 <ClaudiusMaximus> maybe opengl doesn't like blocking (for example if you use lazy IO to get data from the server), but i've not had any problems using mapM/mapM_ with opengl
09:02:59 <ManateeLazyCat> jutaro: I have paste backtrace at http://hackage.haskell.org/trac/ghc/ticket/4038#comment:2
09:03:09 <RambO> sort :: Ord a => [a] -> [a]
09:03:30 <turiya> ok. then i shud check what i have written
09:03:31 <ManateeLazyCat> jutaro: Just haven't time investigate this,
09:03:32 <RambO> but I need to sort []    (i.e sort [] = [])
09:03:56 <ManateeLazyCat> jutaro: But i think it's a good start, and not hard to find problem.
09:04:07 <jutaro> ManateeLazyCat: Good work.
09:04:28 <monochrom> "sort [] = []" is not a problem. It is a solution.
09:04:33 <ezyang> dcoutts_: Done.
09:04:35 <RambO> I know
09:04:53 <RambO> but i can't use sort [] because [] isn't an ord class i think.
09:05:02 <matt_m> RambO:  Are you asking where the Ord instance comes from?  It comes from your other case
09:05:08 <jutaro> ManateeLazyCat: Hope some expert will look at it.
09:05:15 <ezyang> I'm kind of sad that trailing commas are not supported, but I can deal :-)
09:05:15 <ClaudiusMaximus> @instances Ord
09:05:15 <monochrom> > sort []
09:05:16 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:05:16 <lambdabot>   []
09:05:23 <monochrom> Clearly it can work.
09:05:46 <RambO> The think is I have it un HUnit, somethink like "test []"
09:06:04 <RambO> testOrdenarNulo                 =       TestCase (assertEqual "for (ordenar []), " [] (ordenar []))
09:06:09 <dcoutts_> ezyang: ta
09:06:32 <benmachine> RambO: you may have to specify a type in that case
09:06:47 <BMeph> Hey, monochrom: why is 'map' in the Prelude? And, why is fmap not a synonym - and _also_ in the Prelude?
09:06:53 <BMeph> ;)
09:06:54 <Saizan> RambO: are you getting an ambiguous type variable error?
09:06:59 <RambO> Yes Saizan
09:07:02 <benmachine> RambO: it is sufficient to specify a type for either [] or ordenar []
09:07:13 <benmachine> you could do something like ([] :: [Int])
09:07:17 <benmachine> or :: [Char]
09:07:18 <RambO> benmachine: I think I don't get it.
09:07:21 <monochrom> map should not be in the Prelude. fmap should be, great abstraction.
09:07:33 <ManateeLazyCat> jutaro: From the result, it's a problem when call gtk_entry_completion_complete
09:07:36 <benmachine> RambO: the behaviour of sort depends on how <= behaves, in principle
09:07:53 <benmachine> RambO: which means sort needs to know which type it is working with before it can do anything
09:08:02 <Saizan> RambO: ok, the problem is that [] :: [a] for some unspecified 'a', but the compiler can't just guess one for you, so you've to specify it
09:08:27 <ClaudiusMaximus> :t let foo [] = [] in foo
09:08:28 <lambdabot> forall t a. [t] -> [a]
09:08:34 <jutaro> ManateeLazyCat: I assume its a symptom.
09:08:38 <benmachine> RambO: in this case, there isn't an obvious choice, so you have to tell the thing what kind of list to test sorting
09:09:10 <ManateeLazyCat> jutaro: I'm try to modified gtk2hs code to fix this.
09:09:23 <RambO> Oh, so I should choose between any of a type that can be ordered
09:09:44 <ezyang> "oops!"
09:10:08 <RambO> benmachine: how can I do that?
09:10:28 <jutaro> ManateeLazyCat: As leksah crashes not at gtk_entry_completion_complete I assume its a more systemic error.
09:10:42 <xezz> hiho
09:10:49 <dpratt71> well, I finally got nario compiled and running, which pleases me much more than you might think is reasonable
09:10:51 <benmachine> RambO: in the example you gave, assertEqual "for (ordernar []), " ([] :: [()]) (ordenar []) shoudl do the trick
09:10:56 <dpratt71> so thanks for the help
09:11:02 <ManateeLazyCat> jutaro: I seen it call gtk_tree_model_foreach
09:11:05 <benmachine> (that says use a list of ()s)
09:11:25 <benmachine> or you can replace that :: [()] with :: [Integer] or :: [Char] or :: [Bool]
09:11:41 <RambO> Oh
09:11:43 <RambO> Thanks
09:12:00 <RambO> I thought the problem was in the parameter of "ordenar", not in the result >.<
09:12:05 <benmachine> well
09:12:11 <jutaro> ManateeLazyCat: gtk_tree_model_foreach was as well in the Leksah backtrack stack!
09:12:12 <ClaudiusMaximus> :t let foo x@[] = [] `asTypeOf` x in foo
09:12:13 <lambdabot> forall a. [a] -> [a]
09:12:24 <xezz> im running a listcomp. and it should return a list with all tuples (a, b) where a mod 3 = 0 and b should be all squares. This list should be infinite
09:12:25 <benmachine> I'm assuming that assertEqual forces the types to be the same
09:12:31 <xezz> so what i got right now is
09:12:32 <xezz> [(a, b^2)|a <- [1..], mod a 3 == 0, b <- [1..]]
09:12:49 <RambO> thanks benmachine It works :)
09:12:54 <benmachine> the problem is not really anything to do with ordernar, it's that assertEqual doesn't let enough type information in or out
09:13:04 <ManateeLazyCat> jutaro: yes, if error is big scope, it's a problem of c2hs-branch or 6.12.2
09:13:05 <benmachine> for stuff to be inferred like it usually is
09:13:07 <fax> b <- map square [1..]
09:13:21 <xezz> now i want that: elem (a, b) terminates
09:13:25 <xezz> for all a b
09:13:31 <dpratt71> nario appears to be substituting the normal haskell entry point in favor of it's own; can I assume it's doing this to bootstrap the graphics stuff?
09:13:40 <benmachine> xezz: you'd have to write your own elem function
09:13:40 <ezyang> Huh.  Type constructor `Exception' used as a class
09:13:55 <benmachine> xezz: the builtin one doesn't know that your list is sorted
09:13:57 <ezyang> I wonder where I messed up my build-depends
09:14:04 <mpiechotka> Is it possible to link with library that don't have .so at the end - like libz.so.1?
09:14:17 <benmachine> ezyang: I think Exception was a type in base3 and is a class in base4
09:14:21 <xezz> yeha thats the problem i only get (3, b)
09:14:36 <ezyang> aha!
09:14:59 <fax> we need monad comprehension
09:15:00 <quicksilver> xezz: list comprehensions don't work with two infinite lists
09:15:08 <quicksilver> they don't have a fair choice between the two infinite lists.
09:15:23 <xezz> but im not allowed to do that xD its just homework and it says "the list should be generated in a fair way so that elemem (a, b) terminates for all a, b)
09:15:23 <fax> @undo [(a, b^2)|a <- [1..], mod a 3 == 0, b <- [1..]]
09:15:24 <lambdabot> concatMap (\ a -> if mod a 3 == 0 then concatMap (\ b -> [(a, b ^ 2)]) [1 ..] else []) [1 ..]
09:15:29 <quicksilver> having out in this channel I begin to hate list comprehensions.
09:15:39 <ezyang> huh, but I don't have base 4 installed
09:15:42 <quicksilver> I think it should be illegal to use them without 6 months of haskell experience.
09:15:44 <fax> > (>>-) (\ a -> if mod a 3 == 0 then (>>-) (\ b ->  [(a, b ^ 2)]) [1 ..] else []) [1 ..]
09:15:45 <lambdabot>   Couldn't match expected type `[(a, a1)] -> a1 -> b'
09:15:45 <lambdabot>         against inferre...
09:15:55 <yitz> preflex: seen luzm
09:15:55 <preflex>  Sorry, I haven't seen luzm
09:15:57 <fax> > flip (>>-) (\ a -> if mod a 3 == 0 then flip (>>-) (\ b ->  [(a, b ^ 2)]) [1 ..] else []) [1 ..]
09:15:58 <aavogt> > [ "yes" | False ]
09:15:59 <lambdabot>   [(3,1),(6,1),(3,4),(9,1),(3,9),(6,4),(3,16),(12,1),(3,25),(6,9),(3,36),(9,4...
09:16:00 <lambdabot>   []
09:16:00 <ezyang> oh, nvm
09:16:05 <quicksilver> faz++
09:16:11 <quicksilver> fax++]
09:16:12 <quicksilver> !
09:16:14 <quicksilver> fax++
09:16:32 <yitz> preflex: seen luzhuomi
09:16:32 <preflex>  Sorry, I haven't seen luzhuomi
09:16:44 <quicksilver> xezz: the >>- that fax is using does fair choice on multiple infinite lists, although it's not in the standard library.
09:17:40 <xezz> mh its in the Data.List module?
09:17:45 <jmcarthur> @karma faz
09:17:45 <lambdabot> faz has a karma of 1
09:17:48 <xezz> src >>-
09:17:52 <xezz> qsrc >>-
09:17:57 <xezz> @src >>-
09:17:58 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:18:33 <fax> xezz, it's on here:
09:18:51 <fax> http://okmij.org/ftp/papers/LogicT.pdf
09:18:59 <fax> & you can  cabal install Control.Monad.Logic
09:19:01 <jmcarthur> we should use pagerank for karma, treating the number of times A has increased the karma of B as link weights
09:19:42 <xezz> so its a Monad o.O
09:20:17 <benmachine> I think if you're doing homework then pulling in other libraries might be frowned upon >_>
09:20:27 <xezz> abit yes
09:20:33 <fax> nah
09:20:39 <fax> you use other libraries if you rae clever
09:20:46 <fax> if you are not clever then you write everything youorself from scratch
09:20:49 <fax> (how do I know this? :P)
09:21:01 <fax> (because I spent years writing everything from srcatch..)
09:21:28 <ezyang> Doing it yourself is an instrumental learning technique though
09:21:38 <DigitalKiwi> make a makefile that installs everything ;D
09:21:46 <fax> no it's like hitting yoursef on the head with a frying pan again ang again
09:21:56 <DigitalKiwi> exactly
09:22:03 <benmachine> sounds educational to me
09:22:04 <DigitalKiwi> you learn pretty quickly not to do that!
09:22:16 <xezz> well but doing this with a Monad ... I think there should be a better way if i import this ill have to explain what a Monad is xD
09:22:41 <benmachine> xezz: there's probably a way that doesn't involve using that thing
09:22:42 <DigitalKiwi> and nobody should have to suffer explaining a monad
09:22:50 <benmachine> but it's probably not as simple
09:23:42 <fax> xezz: lists are a monad...
09:23:46 <xezz> though the standard lib will always give me a list with a fix and b infinite
09:23:48 <fax> >>- works on lists (as well as other stufF)
09:23:52 <Saizan> you could just steal the definition of (>>-) for lists if you're worried about that
09:25:35 <xezz> mh
09:26:08 <xezz> is it possible to work with take ? [(a, b^2)|a <- [1..], mod a 3 == 0, b <- [1..]]
09:26:10 * ManateeLazyCat pasted "backtrace from my project." at http://paste2.org/get/812247
09:26:11 <ManateeLazyCat> jutaro: Above
09:26:43 <ezyang> Does anyone have an example of a cabal file that generates several executable files?
09:26:53 <ManateeLazyCat> jutaro: I'm sure something break in c2hs-branch.
09:27:26 <ManateeLazyCat> jutaro: This track almost kill my box. :)
09:27:27 <ezyang> (especially if it has a helper library that is not public)
09:27:30 <jutaro> ManateeLazyCat: That looks quite different.
09:27:40 <ManateeLazyCat> jutaro: Yep.
09:27:59 <jutaro> ManateeLazyCat: Hope you don't burn your CPU.
09:28:10 <ManateeLazyCat> jutaro: Almost.
09:28:10 <dcoutts_> ezyang: just use multiple executable stanzas, if you want an example, see haxml
09:28:17 <ManateeLazyCat> jutaro: Because i can't kill that process.
09:28:31 <dcoutts_> ezyang: cabal's Simple build system does not yet support private libraries
09:28:42 <ezyang> ok
09:29:46 <ManateeLazyCat> jutaro: I don't know how to fix it, but i'm not sure it's not gtk2hs fault.
09:29:57 <ManateeLazyCat> jutaro: Only Duncan and Axel can fix this.
09:30:04 <dcoutts_> don't look at me! :-)
09:31:20 <jutaro> ManateeLazyCat: I pray someone is listening!
09:31:36 <ManateeLazyCat> dcoutts_: Oh, man, you're few people can fix that. :)
09:31:41 <jutaro> Ah, Duncan wants to fix it:)
09:31:49 <ManateeLazyCat> dcoutts_: You're developer of c2hs, no?
09:32:00 <dcoutts_> ManateeLazyCat: a maintainer, yes
09:32:25 <ManateeLazyCat> dcoutts_: But i know you're so kind people like Axel, isn't?
09:32:49 * dcoutts_ isn't sure what that means
09:33:12 <jutaro> dcoutts_: Your damned code happens to stop working on 6.12.2 ;-)
09:33:38 <dcoutts_> jutaro: you think c2hs is at fault here?
09:33:39 <ManateeLazyCat> jutaro: I think Duncan can help us last. :)
09:33:59 <dcoutts_> have you worked out what is going on?
09:34:55 <jutaro> dcoutts_: I've no idea what's the fault. But I spend some time to find out, that even easy example code like completion segfaults. Not only big and horrible leksah.
09:35:06 <ManateeLazyCat> http://hackage.haskell.org/trac/ghc/ticket/4038#comment:3
09:36:03 <ManateeLazyCat> gtk2hs/demo/treeList/Completion.hs is minimum code to redur that error.
09:36:15 <jutaro> dcoutts_: Its serious for me not to be able to use 6.12.2. Maybe its finalizers again? I don't know.
09:37:05 <ManateeLazyCat> dcoutts_: Have any bug fix in c2hs mainline but lost in c2hs-branch (gtk2hs) ?
09:37:13 <dcoutts_> ManateeLazyCat, jutaro: to be clear: I do not have time to investigate this at the moment. I suggest you work with Axel.
09:37:47 <dcoutts_> ManateeLazyCat: loads but none that I can think of that are relevant
09:39:37 <ManateeLazyCat> jutaro: I need off now, bye. :)
09:39:50 <jutaro> ManateeLazyCat: Bye
09:39:51 <aluink> has anyone here installed the unix package via cabal in windows? supposedly you can do it with cygwin, i'm having issues though
09:39:52 <siracusa> jutaro: Is it only GHC 6.12.2 + the latest gtk2hs or any version of gtk2hs?
09:40:18 <ManateeLazyCat> siracusa: Only 6.12.2
09:40:32 <ManateeLazyCat> siracusa: And don't care which gtk2hs.
09:40:45 <siracusa> ManateeLazyCat: ah ok
09:40:54 <ManateeLazyCat> siracusa: I have test old/new gtk2hs with 6.10 and 6.12.1, works fine.
09:40:54 <jutaro> siracusa: We installed the new cabal installable repo version with 6.12.2 and it breaks our apps. With 6.12.1 everything runs without problems.
09:41:19 <ManateeLazyCat> siracusa: Infact, 6.10.2 can compile pass, just will got "segmentation fault" runtime.
09:49:15 <dmead> i hate java
09:49:18 <dmead> don't tell them.
09:49:28 <edwardk> our lips are sealed.
09:49:30 <ezyang> "welcome to the club"
09:49:45 <edwardk> the log, however, is not
09:50:08 <edwardk> you may have to burn down the hosting facility where tunes.org is located
09:50:15 <dmead> ruh roh
09:50:17 <dcoutts_> ManateeLazyCat: can I suggest you try building the gtk2hs_closure code in glib with the debug flag on, there's debug code in there. It might give you a clue. Could also try adding more tests or breakpoints to see if something is null.
09:50:24 <edwardk> and eradicate google, just in case they've cached it
09:50:34 <dmead> i hope every future job gorks #haskell logs for how i really feel about things
09:50:38 <dmead> *groks
09:51:07 <Jafet> greps?
09:51:29 <edwardk> i've found all sorts of crazy things i've said through those logs. ;)
09:51:56 <Squarism> are there some cool haskell programs available for download... something that might showcase its values?
09:51:58 <edwardk> i figure i subscribe to enough mutually contradictory positions on issues, that anyone googling through the logs won't have any clue what my position is ;)
09:52:06 <edwardk> Squarism: darcs!
09:52:25 <ezyang> Xmonad!
09:52:56 <edwardk> Squarism: MITRE has a symbolic cryptographic protocol analyzer that is kind of hardcore.
09:52:58 <dmead> i think anyone who reads the logs might realize i like to drink and code
09:53:16 <edwardk> dmead: aiming for the ballmer peak?
09:53:59 <dmead> edwardk, one can only hope
09:54:11 <ezyang> I'm still really fond of this "diagram": http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25340#a25340
09:54:19 <ezyang> It's all of the infix operators in hackage packages
09:54:25 <c_wraith> I was surprised how easy it was to work on haskell code after closing down a bar with a bunch of friends.
09:54:48 <ManateeLazyCat> dcoutts_: Sorry, i haven't time to do that, i have some big sub-module (file-manger (gio), terminal (re-write), web-browser) need to finish in this month.
09:54:52 <edwardk> mine comes from lack of sleep, not alcohol. i find that i'm most productive around 3-5am or on the day after i stay up until 3-5 am. i stop overanalyzing and overoptimizing my code and take the shortest path to getting it out the door ;)
09:54:54 <benmachine> ezyang: no unicode?
09:55:03 <edwardk> brb
09:55:05 <ezyang> Not that I could see :-/
09:55:07 <dmead> yea thats true
09:55:17 <ezyang> In fact, I don't think I saw any unicode identifiers...
09:55:18 <dmead> i will not be back later, i have a final tonight
09:55:26 <dmead> GOOD DAY NERDS
09:55:39 <ezyang> bye bye
09:55:45 <ezyang> good luck on yer final
09:55:56 * ManateeLazyCat I hope i can put all my time on my project since gtk2hs have convert to Cabal.
09:56:00 <ezyang> Huh. I wonder what GHC uses to figure out if something is punctuation
09:56:15 <edwardk> ezyang: oh, one of the things that came up last boston haskell was that nirav can get the old csail room we'd been using.
09:56:23 <benmachine> > generalCategory 'â'
09:56:24 <lambdabot>   InitialQuote
09:56:29 <ezyang> edwardk: Oh, useful!
09:56:40 <edwardk> ezyang: one sec. i stole the combinator ;)
09:56:49 <benmachine> > isPunctuation 'â'
09:56:50 <lambdabot>   True
09:56:59 <ezyang> muahahaha
09:57:05 <ezyang> @src isPunctuation
09:57:05 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:57:18 <whald> can someone suggest me what to look for when trying to speed up a program doing heavy crunching on Floats? the "+RTS -p -sstderr" looks quite healthy to me
09:57:19 <ManateeLazyCat> jutaro: BTW, please don't urgency Axel to fix those much things.
09:57:21 <benmachine> > isSymbol 'â'
09:57:23 <lambdabot>   False
09:57:30 <ezyang> :-(
09:57:35 <whald> i just wonder if there might be some trasures hidden
09:57:39 <edwardk> its not quite isSymbol, it is 'isSymbol and a quick elem check for a bunch of punctuation as well
09:57:49 <ManateeLazyCat> jutaro: I think have spend all spare time for gtk2hs, including weekend.
09:57:59 <edwardk> that way unicode symbol operators count
09:58:02 <ManateeLazyCat> s/I think/I think Axel
09:58:08 <benmachine> whald: this is probably not going to help, but you could try switching between Float and Double
09:58:18 <benmachine> I found an application I had ran much faster with one than the other
09:58:20 <edwardk> but also the traditional . : ?, etc.
09:58:35 <benmachine> and everyone in here told me it should have run faster with the one that it didn't :P
09:58:37 <jutaro> ManateeLazyCat: Yes. a lot of progress with gtk2hs
09:58:45 <edwardk> benmachine: ran faster with doubles?
09:58:59 <benmachine> edwardk: nope, floats
09:59:04 <edwardk> benmachine: ok, that i can believe
09:59:09 <benmachine> oh
09:59:13 <jutaro> ManateeLazyCat: Very good for the community
09:59:14 <benmachine> everyone told me doubles should be faster :P
09:59:16 <ManateeLazyCat> jutaro: In previous month, Axel convert all core package to Cabal, and spend much time fix my new patches.
09:59:21 <edwardk> benmachine: they lied ;)
09:59:24 <whald> benmachine: is there some penalty for using let's say "Flt" throughout the program to have a central place for switching between Float and Double?
09:59:38 <edwardk> benmachine: on a 32 bit machine?:
09:59:43 <benmachine> edwardk: shrug
09:59:55 <benmachine> whald: type synonyms (defined with the type keyword) are absolutely free
10:00:14 <benmachine> they take approximately zero seconds for the compiler to erase completely
10:00:26 <benmachine> and don't exist at all at runtime
10:00:29 <Squarism> darcs and xmonad... all this hype and nothing more than that?
10:00:34 <edwardk> benmachine: 32 bit ghc uses 4 byte alignment, so loading a double goes down the misaligned path half the time
10:00:51 <benmachine> edwardk: oh ok
10:00:52 <zygoloid> edwardk: :o crikey
10:00:54 <edwardk> but it shouldn't really matter much
10:01:02 <ezyang> "The rest of it is all at Galois"
10:01:07 <ezyang> GHC is written in Haskell
10:01:13 <ezyang> parts of it, at least
10:01:14 <ManateeLazyCat> jutaro: For Windows Installer, perhaps will later than Unix, but i think Axel have do best he can.
10:01:16 <benmachine> most of it
10:01:25 <c_wraith> really, the hype is about the *language*, not the things built with it.
10:01:29 <whald> benmachine: good, then i'll try that. ghc did a pretty decent job inferring strictness i guess -- the whole thing runs in almost constant space, <1.5% spent in GC
10:01:30 <edwardk> benmachine: the runtime system is a rather monolithic beast ;)
10:01:40 <benmachine> edwardk: yeeees
10:01:54 <benmachine> whald: I give no guarantee it will help anything at all and might make things worse
10:02:02 <benmachine> whald: it's just something I met the other day
10:02:07 <benmachine> so I thought I'd pass it on
10:02:09 <aluink> anyone here build the unix package with cabal in cygwin? i'm having missing lib problems
10:02:43 <whald> benmachine: yes, but having an easy switch to go for doubles is handy anyways in case Float precision is not enough for pathetic cases
10:02:53 <whald> and if it's free anyways... :-)
10:03:02 <edwardk> zygoloid: that said, it doesn't matter in tight loops though where things tend to get moved into registers, etc. which is the stuff that should be speed critical at any decent optimization level ;)
10:03:31 <edwardk> whald: just write the code to be polymorphic in the instance of Floating ;)
10:03:44 <edwardk> and add specialize pragmas if you're paranoid
10:03:46 <turiya> opengl functions are not behvaing well when the calling function is waiting ..
10:03:50 * benmachine is paranoid
10:03:51 <dcoutts_> Squarism: there's also quite a bit of private commercial software written in Haskell, but it's not available for download.
10:03:53 <edwardk> that way you don't have to choose once per program, but can refine
10:04:17 <turiya> how can this be solved
10:04:30 <benmachine> turiya: waiting?
10:04:39 <edwardk> Squarism: galois has cryptol which is written in haskell, bluespec has a compiler that generates netlists for chips that is basically a haskell compiler that was made to look more like verilog ;)
10:04:44 <benmachine> turiya: you're not doing anything evil with threads are you?
10:04:50 <whald> edwardk: would this pave the road so i can define the desired data type as let's say a command line parameter without penalty?
10:05:07 <benmachine> turiya: or rather, anything that would expose opengl's evil
10:05:09 <turiya> no, waiting => a client waiting for server messages
10:05:15 <edwardk> whald: sure just make your main ask for the result as a Float or a Double based on the command line arg
10:05:17 <whald> maybe tricking ghc into generating a "fat" binary, having optimized code for Double and Float?
10:05:29 <ezyang> {-# SPECIALIZE #-}
10:06:00 <benmachine> no-one likes peppering code with pragmas :P
10:06:03 <whald> that will work? i'm amazed :-)
10:06:04 <turiya> benmachine, a very simple function was behaving this way
10:06:06 <benmachine> and when I say no-one I mean me
10:06:17 <benmachine> er, I mean
10:06:20 <benmachine> you know what I mean
10:06:27 <benmachine> turiya: I can't provide any specific help
10:06:53 <c_wraith> Most of the time, performance pragmas don't matter.  When they do, it's a good idea to use them
10:07:11 <turiya> is there an alternate way of getting messages instead of with hGetContents
10:07:23 <edwardk> main = do opts <- cmdArgs "MyProgram" modelist; if wantFloats opts then do (f :: Float) <- myAlgorithm;  print f else do (d :: Double) <- myAlgorithm; print f
10:08:14 <edwardk> where myAlgorithm :: Floating a => IO a
10:08:45 <whald> edwardk: does that snippet involve something like "getopts" for haskell or is the wantFloats made up?
10:08:47 <edwardk> feel free to substitute something other than cmdargs ;)
10:09:19 <edwardk> and wantFloats was some value of a command line arg passed in via the modeline for cmdargs
10:09:23 <whald> other way around: is there a getopts for haskell so cmd line parsing is less annoying?
10:09:36 <edwardk> whald: cmdargs
10:09:48 <edwardk> http://community.haskell.org/~ndm/cmdargs/
10:10:09 <edwardk> http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm is the longer list of examples
10:10:11 <ezyang> cmdargs is nice. I recommend it.
10:10:21 <whald> edwardk: ahh, very nice. thanks!
10:10:27 <edwardk> i like it a lot, though it has some limitations that hurt my current usage patterns
10:11:14 <BMeph> edwardk: Needs moar monoidz? ;)
10:11:15 <edwardk> i want/need sub-modes, the ability to share large chunks of arguments across modes, feedback so i can generate bash autocomplete, man page generation, localization support, etc.
10:11:36 <edwardk> BMeph: and a monoid that lets me load a config file and merge config objects like dcoutts_ does in cabal would be nice too ;)
10:11:41 <ezyang> Shouldn't argument sharing be achievable with ++?
10:12:05 <edwardk> ezyang: i want for instance: kata install and kata configure to share about 50 different args ;)
10:12:22 <dcoutts_> edwardk: cmdargs does some evil stuff with _|_'s
10:12:24 <edwardk> right now i use the c preprocessor to bolt them into both constructors
10:12:28 <edwardk> dcoutts_: yeah
10:12:35 <ezyang> Oh, I see!
10:12:40 <benmachine> what's the fastest way to verify if a file descriptor is open given its number?
10:12:45 <benmachine> fastest/easiest
10:12:53 <benmachine> using System.Posix or otherwise
10:13:22 <edwardk> dcoutts_: i basically had to build an internal fork of cmdargs to get all the extra machinery i wanted bolted into it
10:13:45 <edwardk> though it could probably done more cleanly by opening up the cmdargs api in a nice way and making a couple of small extensions to it
10:15:42 <edwardk> benmachine: hrmm, probably via fstat somehow
10:16:01 <benmachine> edwardk: I've decided I should probably check its type too
10:16:07 <benmachine> so I think I have the answer
10:16:14 <benmachine> via getFdStatus and various similar
10:22:24 <benmachine> agh my evil hack doesn't work
10:22:32 <benmachine> who'd've thought :(
10:22:48 <benmachine> well, the evillest part of it does
10:22:58 <benmachine> the relatively mundane part doesn't
10:23:08 <benmachine> basically I've got a server process
10:23:20 <benmachine> every time it detects a connection it checks the modification time of its own binary
10:23:39 <benmachine> and if it's changed, it forks and re-execs itself without dropping the socket
10:23:57 <benmachine> (but unfortunately dropping the newest connection; whatever)
10:24:09 <benmachine> anyway the old version is supposed to wait for all its children to finish
10:24:12 <benmachine> but it doesn't seem to
10:24:44 <benmachine> I never seem to get more than one process at once
10:26:18 <hydo> Anyone here have experience with the couchdb cabal package, by chance?
10:27:18 * benmachine wonders if handle-based IO as warned as nonfunctional in System.Posix includes closing file handles...
10:36:46 <zygoloid> edwardk (or anyone else): what does GHC do about x86's floating point excess precision?
10:37:59 <monochrom> something about -fexcess-precision turning it on, default off.
10:38:15 <monochrom> (and oh, turning it on makes things faster :) )
10:40:10 <zygoloid> makes things faster and presumably removes referential transparency :(
10:40:46 <dpratt71> are there other graphics libraries for Haskell that have functionality comparable to SDL?
10:41:55 <pikhq> dpratt71: Even without the "for Haskell" chunk, no.
10:42:25 <pikhq> Literally the only thing close is DirectX, and that's Windows-specific.
10:42:25 <mightybyte> @pl foo f chs = zipWith (\rh -> zipWith (f rh) chs)
10:42:26 <lambdabot> foo = (zipWith .) . flip . (zipWith .)
10:42:56 <dpratt71> pikhq: I see; thanks
10:43:19 <benmachine> now I need to set FD_CLOEXEC on some handles, but apparently handleToFd closes the handle in question
10:43:22 <benmachine> ho hum
10:43:42 <mightybyte> @pl foo f rhs chs cs = zipWith (\rh -> zipWith (f rh) chs) rhs cs
10:43:42 <lambdabot> foo = flip . (zipWith .) . flip . (zipWith .)
10:43:51 <DigitalKiwi> can't you do what SDL does with a combination of a few other things?
10:43:58 <DigitalKiwi> like opengl, openal, and glut?
10:44:25 <ski> @type \f chs -> zipWith (\rh -> zipWith (f rh) chs)
10:44:26 <lambdabot> forall a a1 b c. (a -> a1 -> b -> c) -> [a1] -> [a] -> [[b]] -> [[c]]
10:44:33 <DigitalKiwi> 12:42 < pikhq> Literally the only thing close is DirectX, and that's Windows-specific.
10:44:36 <DigitalKiwi> wine! ;D
10:44:37 <zygoloid> pyglet has functionality comparable to SDL
10:44:37 <pikhq> DigitalKiwi: ... No.
10:44:57 <DigitalKiwi> that would actually be hilarious, i bet some gnome dev does it sometime
10:45:09 <DigitalKiwi> *cough* using mono + c sharp for stuff
10:45:51 <pikhq> DigitalKiwi: OpenAL and SDL's audio subsystem have fairly differing goals.
10:46:01 <zygoloid> @let compareToSDL sdl _ = GT
10:46:02 <lambdabot>  Defined.
10:46:10 <tensorpudding> SDL isn't really competitive with DirectX is it?
10:46:11 <pikhq> Also, SDL has quite a few subsystems. And many backends.
10:46:12 <zygoloid> there you go, everything's comparable to SDL now :)
10:46:52 <pikhq> tensorpudding: It... Actually is.
10:47:46 <tensorpudding> I've seen a decent number of games use SDL, but far fewer.
10:47:48 <pikhq> Though that's only because SDL also lets you use GL. :P
10:48:02 <pikhq> Yes, that's because DirectX is backed by Microsoft.
10:48:13 <pikhq> Whereas SDL is done by them there Linux hippies.
10:48:23 <tensorpudding> SDL isn't just a Linux thing.
10:48:33 <pikhq> Yes, well aware.
10:49:13 <DigitalKiwi> but not aware that you can do stuff without SDL? :P
10:49:23 <pikhq> DigitalKiwi: Sure you can.
10:49:32 <pikhq> SDL just makes it portable, and provides useful abstractions.
10:49:59 <tensorpudding> There's that XNA thing, which a decent number of people apparently are using.
10:50:43 <tensorpudding> XNA might be nice if your language of choice is C#
10:50:57 <pikhq> XNA might be nice if you only care about Windows and Xbox.
10:51:08 <Philonous> edwardk: Is there something like cmdargs with less black magic? ;)
10:51:10 <edwardk> zygoloid: nothing
10:51:20 <Adamant> XNA is nice, but it's got huge lock-in.
10:51:34 <edwardk> Philonous: not really. i think there was some ui-command thing or something like that release recently, but it doesn't do all the cmdargs stuff
10:52:17 <edwardk> Philonous: http://blog.kfish.org/2010/04/uicommand.html
10:52:19 <tensorpudding> Lock-in is annoying, yes, but the effects are still not that significant for gaming.
10:52:37 <Philonous> edwardk: I think I will stick to GetOpt then. cmdargs gives me the creeps
10:52:58 <edwardk> Philonous: haha, cmdargs grew on me a lot with usage
10:53:08 <tensorpudding> And anyway, it's worth comparing the two, since if the Microsoft solution is leagues better, why would you be happy with the tools you have, free or not?
10:53:19 <DigitalKiwi> Stockholm's syndrome
10:53:24 <edwardk> DigitalKiwi: =)
10:53:52 <Philonous> "How I stopped worrying and started to love the unsafePerformIO"
10:54:48 <edwardk> it really only uses the unsafePerformIO machinery to make magic bottoms in the 'default' config, so it can parse out what the command line flags should be
10:55:14 <Philonous> Yes, and how is that not creepy
10:55:24 <edwardk> if it exposed the internals you could use it without resorting to such dirty tactics, but the syntactic overhead would be as bad as what it replaces
10:55:54 <pikhq> tensorpudding: Except SDL is pretty much just "similar to DirectX in both features and quality".
10:56:15 <dpratt71> I assume that even if I was open to targeting just Windows, it would be a moot point because there aren't Haskell bindings for such things as DirectX?
10:56:25 <pikhq> (assuming you include OpenGL)
10:56:34 <edwardk> could alwyas put one together as a quasiquoter or something [$options| --foo x = ... ; --bar y = ...
10:56:38 <dcoutts_> edwardk: I don't really find the syntactic overhead to be very high, I'm more worried about features and flexibility
10:56:43 <tensorpudding> Is OpenGL really comparable in quality to DirectX?
10:56:45 <edwardk> dcoutts_: *nods*
10:56:53 <pikhq> ... Yes.
10:57:16 <tensorpudding> I would think if they were, people wouldn't bother using DirectX since writing everything in OpenGL would be more portable.
10:57:20 <jmcarthur> tensorpudding: opengl 4 is on par with directx 11
10:57:23 <dcoutts_> edwardk: like supporting deprecated aliases for old flags, having names that work for flags and for config items (they sometimes need to be different)
10:57:30 <jmcarthur> tensorpudding: but opengl 4 is new unsupported hotness, so far
10:57:38 <edwardk> tensorpudding: you can do just about everything with one you can do with the other, but the opengl version is rather hellish due to the sheer number of extensions needed
10:57:39 <pikhq> tensorpudding: Game developers don't care about portability.
10:57:41 <Adamant> tensorpudding: people don't bother with portability for a lot of reasons
10:57:54 <Adamant> like their target market all running Windows
10:58:01 <tensorpudding> Dude, there's a decent quantity of games ported to Mac.
10:58:04 <Adamant> that may change in the future
10:58:17 <tensorpudding> If you don't have to re-write the engine to port, that sounds like a win, right?
10:58:17 <Adamant> tensorpudding: yeah, but that is the game porter's problem
10:58:18 <edwardk> tensorpudding: and ati has historically had worse support for opengl, so it all depends on your target platform
10:58:22 <pikhq> Also, OpenGL is freaking hellish on Windows.
10:58:35 <tensorpudding> So OpenGL isn't comparable to DirectX?
10:58:49 <pikhq> It is on non-Windows.
10:58:58 <edwardk> i used to write everything to run via a portable engine that could render via both, but the fast paths for direct 3d and opengl can differ significantly
10:59:02 <pikhq> On Windows, Microsoft strives to make it not comparable.
10:59:10 <Squarism> XNA shader programming could be a bit intuitive
10:59:15 <Squarism> more
10:59:22 <Adamant> tensorpudding: except for some of the majors, everyone punts that problem to dedicated companies that do ports
10:59:38 <tensorpudding> I can't see the reasoning.
10:59:52 <tensorpudding> But I guess they're companies and they know what they do is to make a profit.
10:59:54 <Adamant> tensorpudding: it's really simple, the Mac and Linux market have historically been tiny.
11:00:13 <tensorpudding> But Mac market share is very high.
11:00:14 <Adamant> the Mac market might not be super tiny as much longer
11:00:15 <edwardk> i'd hate xna less if i could write modern code with it, but i can't get access to the tesselation machinery on the 360, geometry instancing, or the more pie-in-the-sky stuff like directcompute shaders
11:00:22 <tensorpudding> Comparatively speaking.
11:00:23 <Adamant> tensorpudding: it's starting to get there
11:00:39 <Adamant> now that it's past 10% in US and Europe
11:00:40 <pikhq> And game developers don't care *that* much how much work is involved in console ports.
11:00:41 <tensorpudding> And games on the Mac have been ported even back in the leaner years.
11:00:51 <edwardk> so basically whatever you put together with it is stuck looking amateurish and has to be built with techniques that are 2-3 generations old
11:01:13 <pikhq> (consoles that aren't the Xbox use OpenGL)
11:01:25 <roconnor> dcoutts: *ping*
11:01:27 <Adamant> tensorpudding: the bottom line is that at least 80% of their PC-type market is on Windows machines
11:01:41 <ketil> ghc-pkg hide doesn't do what I expect: runhaskell Setup configure still picks the hidden version.  Suggestions?
11:01:46 <Adamant> I have a Mac and I either use a GPU-supporting VM or a direct boot into Windows to play games most of the time
11:01:59 <Adamant> because Mac gaming support sucks
11:02:05 <edwardk> pikhq: to be honest though, rendering for the ps3 is a very different beast. you usually work on optimizing your usage of the spe's
11:02:18 <Adamant> Steam going Mac and Valve porting their games is a recent Very Big Deal
11:02:24 <Squarism> Apple users just wanna caress and flash their hardware, thus dont have time playing
11:02:27 <pikhq> edwardk: True, it *is* more than "just use GL and it's all just fine."
11:02:27 <Adamant> but that's not even finished yet
11:02:37 <tensorpudding> I can avoid caring about games most of the time, but every now and then I think that I want to play some game, which was written using XNA, or DirectX, etc.
11:02:43 <DigitalKiwi> Squarism: lawl
11:02:52 <siracusa> I use this code to show 3 columns in a treeview in gtk2hs: http://dpaste.com/191258/. I want the first column to be as wide as necessary, the second to strech and the third to have fixed size. But no matter what I try, it's always the third column that gets streched. Any ideas?
11:02:59 <Squarism> *bait*
11:03:05 <edwardk> pikhq: so the life of a console porter is figuring out how to get decent performance out of a more traditional deferred shading pipeline on a 360/, with enough parallelism and low data bandwidth tasks to utilize the SPEs to get a comparable effect on the PS3.
11:03:25 <Adamant> Squarism: apparently I'm a bad Mac user then, my shiny anodized aluminum finish is all scratched :P
11:03:26 <pikhq> edwardk: And wanting to kill whoever asked for a Wii port?
11:03:37 <DigitalKiwi> Squarism: i want to buy a mac and go to coffee shops and 'work on my book' so that i can pick up chicks
11:04:03 <edwardk> pikhq: yeah, then you port it to the wii, using some bad library to add gimmicky support for the novel control mechanics and try to break even ;)
11:04:06 <Adamant> Squarism: and I had to hammer a spot where I dropped it back into shape
11:04:09 <dmead> chicks digg guys with pretentious electronics
11:04:19 <dmead> just sayin
11:04:26 <dmead> bbl
11:04:33 <DigitalKiwi> exactly!
11:04:54 <edwardk> pikhq: so you wind up having to support 3-4 rendering pipelines, shader sets, etc.
11:05:13 <edwardk> there is a reason i don't work on 3d graphics any more ;)
11:05:17 <tensorpudding> But they don't digg pretentious guys, unless it's the likeable kind of pretentiousness
11:05:37 <DigitalKiwi> there is a like-able kind?
11:05:54 <Squarism> Adamant: Yo're prolly considered unworthy among the stronger believers
11:05:57 <Squarism> =D
11:06:31 <Adamant> Squarism: most of the fanboys for any system are wacky.
11:06:44 <aristid> edwardk: searching for haskell on twitter lead me to this article which featured your name: http://blog.ezyang.com/2010/05/name-conflicts-on-hackage/
11:06:52 <Adamant> I try to be professional, yo
11:07:03 <tensorpudding> The kind that provides lip service to being environmentally conscious and concerned about global warming, but is still a bourgeouis consumer whore who is primarily interested in self-enrichment.
11:07:39 <edwardk> aristid: useful article =)
11:08:05 <edwardk> ezyang: most of the cases where other libs define <> they are actually defining a monoid: i.e. in the pretty printers.
11:08:11 <aristid> is ed z yang here?
11:08:22 <aristid> aah
11:08:25 <edwardk> preflex: xseen ezyang
11:08:25 <preflex>  ezyang was last seen on freenode/#haskell 55 minutes and 50 seconds ago, saying: Oh, I see!
11:08:40 <aristid> edwardk: why don't they use monoid when they mean it?
11:08:47 <Adamant> unless you're French or a big fan of the language, shouldn't bourgeois be one of those words or phrases you use ironically now, like 'running dog capitalist' or 'dirty pinko'?
11:08:51 <edwardk> aristid: because mempty/mappend are damn verbose ;)
11:09:13 <aristid> edwardk: wasn't there some operator alias for mappend?
11:09:25 <edwardk> aristid: that was the <> that is being added
11:09:29 <aristid> or is it just in lambdabot where ++=mappend
11:09:41 <edwardk> thats only in caleskell on lambdabot
11:10:15 <edwardk> my monoids library has a Data.Monoid.Additive.Sugar which aliases (+) to mappend and provides zero i think
11:10:37 <ketil> Anybody know how to make cabal use a particular version of a library?
11:10:40 <aristid> edwardk: (+) is monoid? but that clashes with prelude! :)
11:10:57 <edwardk> aristid: the .Sugar modules in monoids all clash with the prelude =)
11:11:12 <edwardk> thats why they aren't required directly by anything.
11:11:41 <aristid> i think using them would be evil.
11:11:44 <edwardk> but are available if you want to do things like ccshan's WordNumbers post, which use (+) and (*) to avoid notational headaches
11:11:49 <edwardk> you don't have to ;)
11:12:46 <edwardk> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/ (there are 4)
11:12:48 <aristid> edwardk: it's insane that haskell has loads of operators for unimportant things but no standardised operator for mappend :/
11:13:41 <edwardk> aristid: like i said, <> is being (has been?) added, so it should show up soon. i don't have the latest and greatest version of the libs installed
11:14:01 <byorgey> I don't think it's made its way into an actual release yet
11:14:07 <byorgey> but should soon(ish)
11:14:08 <aristid> it will be in Data.Monoid?
11:14:17 <byorgey> presumably
11:14:28 <edwardk> aristid: yes
11:14:52 <edwardk> byorgey: i remember the libraries proposal going through, but yeah, it doesn't seem to have made it into a release
11:14:56 <aristid> things like this make people upgrade to the newest and greatest ghc every time :D
11:15:36 <edwardk> heh. i already use it everywhere, i just import Data.Monoid with an explicit import list and define it at the top of each module, waiting for the day i can remove the redundant definition
11:15:38 <roconnor> wow, how do I land contract work for analysing air traffic?
11:15:47 <edwardk> roconnor: ?
11:15:57 <roconnor> http://blog.well-typed.com/2010/05/well-typed-delivers-air-traffic-analysis-tool-for-nats/
11:17:28 <sm> roconnor: be very good :)
11:17:45 <roconnor> sm: I'm already that :D
11:18:05 <byorgey> roconnor: well, when is the last time you asked an air traffic services company to hire you?
11:18:07 <arcatan> be very good at landing contracts, then!
11:18:10 <roconnor> byorgey: never
11:18:14 <byorgey> well, there's your problem
11:18:26 <roconnor> byorgey: you think that is what well-typed did?
11:19:03 <byorgey> roconnor: hehe, well, I imagine they submitted a proposal after seeing a request for such things
11:19:13 <byorgey> so, yes =)
11:19:22 <roconnor> byorgey: there are requests for these things?
11:19:25 <arcatan> sure
11:19:28 <roconnor> where?
11:19:50 <byorgey> roconnor: sure.  A company says "we would like such-and-such work done and invite proposals from contractors"
11:19:59 <roconnor> really?
11:20:00 <byorgey> I've no idea where you find such things
11:20:08 <byorgey> certainly
11:20:26 <roconnor> the things you don't learn in a PhD program...
11:20:27 <arcatan> i think the way it usually works is that the companies send requests to software contractor companies
11:20:47 * Baughn wishes pattern guards worked with monads
11:20:58 <byorgey> for government contracts there is often a requirement that the requests for proposals must be made public
11:21:11 * roconnor nods
11:21:13 <roconnor> good point
11:21:19 <byorgey> for some suitable definition of "public"
11:21:44 <arcatan> they say landing government contracts is whole different game than private contracts
11:28:17 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25341 <-- Any suggestions on how to make this code less.. stair-stepped?
11:30:56 <Adamant> arcatan: because it is. shit is different when taxpayer money is involved.
11:31:47 <roconnor> Baughn: use MaybeT?
11:32:24 <Baughn> ..perhaps. That might work.
11:32:27 <roconnor> Baughn: definitely use MaybeT.
11:32:32 * Baughn despises liftIO, but it wouldn't be too bad here
11:33:43 <Cale> Uhh...
11:33:44 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
11:34:02 <Cale> This doesn't quite follow the pattern of the Maybe monad though.
11:34:07 <Cale> hmm
11:34:12 <roconnor> it doesn't?
11:34:14 <Baughn> I'd have to abuse fail, yes.
11:34:18 <Cale> Well, I suppose you could use catch
11:34:34 <roconnor> what did I miss
11:34:52 <Cale> Nothing usually results in the entire computation becoming Nothing
11:34:58 <Baughn> Of course, there's the multiheaded mHandle case in the middle..
11:35:24 <roconnor> @src return MaybeT a
11:35:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:35:30 <Baughn> Mm. I suppose what's troubling here is more the lack of a C-style return.
11:35:43 <Baughn> It /does/ show its structure pretty cleanly here.
11:36:22 <roconnor> fail _ = MaybeT $ return Nothing
11:36:28 <roconnor> isn't this exactly right?
11:36:38 <roconnor> mzero = MaybeT $ return Nothing
11:36:45 <roconnor> even better
11:36:49 <Baughn> No, cale is right. I'm not just failing, I'm /handling/ failures.
11:37:07 <Baughn> There are other places where MaybeT could be useful, but this is not one of them.
11:37:09 <roconnor> Baughn: where?
11:37:16 * hackagebot debian 3.46 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.46 (JeremyShaw)
11:37:20 <roconnor> ah
11:37:23 <roconnor> I see
11:37:24 <Baughn> roconnor: The mHandle Nothing branch
11:37:25 <roconnor> damn
11:37:50 <roconnor> wait
11:38:02 <roconnor> doesn't / shouldn't maybeT have a catch?
11:38:17 <Baughn> Would using that /really/ make the code cleaner?
11:38:29 <Baughn> I'm not looking to use MaybeT just for the hell of it. ^^;
11:39:13 <edwardk> roconnor: the company I work for specializes in just that. they know how to win government contracts and help other companies do so
11:39:15 <roconnor> all your return Nothings would become mzero's
11:39:37 <Baughn> Both of them.
11:39:46 <roconnor> and all return . Just would become return
11:39:48 <edwardk> er 20 minute ping time on that response ;)
11:40:15 <Baughn> Both of them.
11:40:32 <zygoloid> Baughn: i took a swing at it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25341#a25342
11:40:36 <roconnor> well if all your other code becomes MonadT IO, you might change your signatures
11:40:56 <roconnor> MaybeT needs a catch.
11:41:09 <Baughn> zygoloid: ..okay, I'll admit that one's prettier.
11:41:23 <zygoloid> Baughn: could probably clean it up more if you have an operator for comparing LeaseModes for compatibility
11:41:46 <Baughn> zygoloid: <=, theoretically
11:41:55 <Baughn> Don't know if I'd like that one. :P
11:42:29 <ski>   bindCatch :: MaybeT m a -> MaybeT m b -> (a -> MaybeT m b) -> MaybeT m b
11:43:22 <zygoloid> authHandle (h, mode) = guard (mode >= lid) >> return h
11:43:27 <roconnor> ski: :D
11:43:44 * ski is a fan of exceptional syntax
11:44:05 <zygoloid> 'return Nothing' feels like it should be mempty, but doesn't seem to be :(
11:44:23 <roconnor> zygoloid: mzero?
11:44:35 <zygoloid> roconnor: this is IO. :(
11:44:36 <c_wraith> IO isn't MonadPlus
11:44:49 <jmcarthur> @instances Monoid
11:44:49 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:45:02 <roconnor> @type mzero
11:45:03 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
11:45:14 <zygoloid> iirc Cale has an instance Monoid (IO ()) on hackage somewhere
11:45:18 <jmcarthur> there should be more instances for Applicative f => Monoid (f a)
11:45:33 <jmcarthur> oops
11:45:42 <ski> @instances MonadPlus
11:45:42 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
11:45:42 <jmcarthur> (Applicative f, Monoid a) => Monoid (f a)
11:45:43 <roconnor> zygoloid: that's why newHandle and newHandleFromLease should be in MaybeT IO
11:45:44 <ski> c_wraith : ^
11:45:53 <zygoloid> (Monoid a, Applicative f) => Monoid (f a), maybe
11:45:55 <Cale> zygoloid: I do?
11:46:10 <zygoloid> Cale: i thought so at least :)
11:46:33 <Cale> zygoloid: Wouldn't be my instance. IO is a MonadPlus already though.
11:46:42 <roconnor> the whole "maybe (return Nothing) newHandleFromLease ld" should just be "newHandleFromLease ld"
11:46:44 <zygoloid> roconnor: how do you write 'return Nothing' in MaybeT IO?
11:46:54 <roconnor> zygoloid: mzero
11:46:55 <ski> though, possibly `IO' shouldn't be in `MonadPlus' ..
11:47:14 <roconnor> zygoloid: but usually that will disappear into a guard, or in this case, into nothing at all
11:48:50 <zygoloid> roconnor: hmm, you'd need to push MaybeT into getLease, wouldn't you?
11:49:21 <roconnor> zygoloid: or just wrap it
11:49:38 <zygoloid> seems like a lot of work to eliminate one use of 'maybe'
11:50:38 <roconnor> could be
11:50:53 <roconnor> all I can say is that this is idomatic MaybeT IO code
11:52:26 <roconnor> but I do admit our monad transformation functions is bit heavier that I'd want it to be
11:52:57 <roconnor> zygoloid: there does seem to be a lot of IO (Maybe x) floating around out here
11:53:08 <roconnor> I wouldn't be surprised if they all should be modified
11:55:34 <gio123> ski: hi
11:59:01 <scotthw> byorgey: are you here?  i have some questions about that algorithm from yesterday
11:59:02 <lambdabot> scotthw: You have 1 new message. '/msg lambdabot @messages' to read it.
12:00:10 <fax> What haskell proggrams do people use for maths??
12:00:24 <fax> I tend to just write one liners in ghci but I feel like things could be a lot better
12:01:30 <jmcarthur> fax: #haskell-math if you want to help improve the situation (day old project, basically)
12:02:42 <sm> @tell CalJohn_ what are you interested in ?
12:02:42 <lambdabot> Consider it noted.
12:16:28 <scotthw> so I was working on this algorithm last night and still cannot get it
12:16:29 <scotthw> http://paste2.org/p/812502
12:16:42 <scotthw> can anyone help?
12:16:57 <scotthw> im taking this alg from MATLAB and trying to make it work in haskell
12:25:11 * hackagebot debian 3.47 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.47 (JeremyShaw)
12:31:21 * hackagebot net-concurrent 0.1.0 - Concurrent over the network execution library  http://hackage.haskell.org/package/net-concurrent-0.1.0 (PaulSonkoly)
12:46:44 * hackagebot hdaemonize 0.3 - utilities for UNIX daemon writing  http://hackage.haskell.org/package/hdaemonize-0.3 (AntonTayanovskyy)
12:48:57 <matt_m> Here's some Process/Signal stuff that I wrote if anyone is interested: http://pastebin.com/P1iJQJTE
12:49:30 <matt_m> It's a framework for modularizing effects  (see the Datatypes a la carte / Monad Zippers papers)
12:53:51 * hackagebot hamlet 0.0.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.0.2 (MichaelSnoyman)
12:53:53 * hackagebot gitit 0.7.3.6 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.6 (JohnMacFarlane)
12:55:53 * hackagebot hpage 0.7.5 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.7.5 (FernandoBenavides)
13:28:45 <dpratt71> so I'm trying to compile the "raincat" game and now that I (think I) have all the dependencies configured, I get an error on build
13:28:46 <dpratt71> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25344#a25344
13:29:31 <dpratt71> any ideas? am I still missing dependencies?
13:29:46 <kmc> dpratt71, it looks like this code was written to an older (?) version of the OpenGL library
13:29:53 <dpratt71> oh
13:30:14 <dpratt71> how hard do you think it would be to fix it?
13:30:21 <kmc> if those are the only errors, not hard
13:30:30 <dpratt71> (assuming novice-level Haskell skills)
13:30:36 <kmc> it's an issue of GL wanting GL-specific "GLdouble" values
13:30:39 <kmc> instead of the normal Double
13:30:43 <dpratt71> ok
13:30:47 <dpratt71> thanks
13:31:40 <sbahra> dcoutts, a portfolio/clients section on well-typed.com would be nice.
13:33:12 <dblhelix> dcoutts: congrats on the funding for the parallel-haskell project
13:34:17 <whald> i have come up with a declaration like "data Foo = Bar (Int -> Bool)" -- naturally it's not possible to derive "Eq" for this. is there an easy way around this?
13:36:05 <luite> whald: well, int is a bounded data type, so you could check all values of Int
13:36:21 <whald> hehe
13:36:25 <dblhelix> whald: what are you trying to achieve?
13:36:33 <fax> whald: you could define   Bar _ == Bar _ = True
13:36:40 <fax> or   Bar _ == Bar _ = False
13:36:45 <luite> whald: but you can't check functions for equality in general
13:36:45 <fryguybob> whald: How many different (Int -> Bool)'s are you talking about?
13:37:16 <dblhelix> fax: or Bar f == Bar g = f 42 && g 0 ;-)
13:37:22 <whald> i'm still in the ray tracing business, so a light for me is basically bunch of functions
13:38:08 <whald> and at some point i need to know if a ray has really hit /that/ light source, not just any random light source that happens to cross it's way
13:38:38 <whald> i could just add some token to the light sources, and define Eq in terms of that
13:38:41 <fax> whald: why dontyou give each light source a name
13:38:46 <fax> uniquely
13:39:05 <whald> but i'm curious if there was some cool haskell foo so i don't have to do that.
13:39:11 <fax> then Bar a _ == Bar b _ = a == b (where the names are strings or ints o whatever)
13:39:56 <whald> fax: good to know my idea was not completely borked :-)
13:40:17 <jmcarthur> Bar f == Bar g = let xs = [minBound..maxBound] in map f xs == map g xs
13:41:13 <jmcarthur> personally i don't think i would like using (==) to check identity
13:41:27 <dblhelix> jmcarthur: but f and g can be quite expensive functions ;-)
13:41:35 <jmcarthur> dblhelix: sure, but at least it's correct ;)
13:42:00 <pikhq> whald: The only thing I could think of is to give each light source a unique identifier, and then compare based on that.
13:42:42 <pikhq> So, yeah.
13:42:49 <pikhq> That.
13:43:03 <fryguybob> jmcarthur: Wouldn't you be better off searching for a counter example in some likely place :D
13:43:04 <whald> yeah, but in reallity it's not Ints but Doubles (or Floats), and not a single one but three, and not a single function but three. enumerating this for every bounce won't be fun :-)
13:43:22 <jmcarthur> fryguybob: only if you have some information about the functions can you do that
13:43:40 <fryguybob> jmcarthur: Of course.
13:43:46 <jmcarthur> whald: what i suggested was a joke
13:43:54 <dblhelix> whald: do the light sources have something like a position?
13:43:55 <luite> fryguybob: the whole domain seems a pretty likely space for a counterexample ;)
13:44:16 <whald> dblhelix: depends on the light source
13:44:20 <jmcarthur> whald: i would use an identifier, but i don't think i would overload (==) for this purpose
13:44:33 <fryguybob> luite: This is true, but you should start your search where it is most likely.
13:44:34 <whald> dblhelix: some have, some don't (like light probes)
13:44:48 <dblhelix> fryguybob: lazy evaluation basically makes that implementation a search for a counter example ;-)
13:45:17 <whald> jmcarthur: so i give the light sources a function which let's a light source decide if it's equal to another light sourceÃ
13:45:18 <whald> ?
13:46:27 <jmcarthur> whald: maybe something like lightNum :: LightSource -> Int, then you can do lightNum a == lightNum b, or perhaps write a function that does that (but not an overloading of (==))
13:46:31 <dblhelix> whald: I think jmcarthur just means that he'd rather write a function like sameSource s1 s2 = sourceId s1 == sourceId s2
13:46:40 <jmcarthur> dblhelix: exactly
13:47:08 <dblhelix> I agree on this btw
13:47:43 <jmcarthur> whald: needing to check identity is dubious as it is though. what are you doing that you need to check whether two lights are the same light?
13:47:48 <whald> so i agree on this too (and will sell it as my idea at sometime soon) ;-)
13:48:09 <dpratt71> a snippet of the source file that generates the "...no instance for (VertextComponent Double)..." error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25345#a25345
13:48:22 <dpratt71> the first function is the source of the error
13:48:40 <dpratt71> the second does not cause an error (yet?)
13:48:42 <fryguybob> It's disingenuous to say something is == when it has the possibility that (==) x y gives True when x and y are in fact different.
13:48:45 <dpratt71> what's the diff?
13:49:20 <whald> jmcarthur: for multiple importance sampling i choose a light from the scene, then i sample the light and then i sample the bsdf (material) for a random direction in which i trace an additional ray
13:49:50 <jmcarthur> whald: if this is so you can have a collection of lights, a common way to do that is to use an IntMap mapping identifiers to light functions. then you can just pass Ints around as your light identities and refer to that IntMap if you need the function
13:50:22 <fax> fryguybob: it's fine to do that
13:50:22 <jmcarthur> whald: since it maps from ids to light functions you know that you won't have the same light source in there twice
13:50:27 <whald> this ray can: get intersected by some random object in the scene (-> shadow) or hit an arbitary light source (-> must count as shadow, too) or go through to the light source i'm trying to estimate
13:50:42 <fax> fryguybob: 2 and 1+1 are "different" by one viewpoint and equal by another
13:50:57 <whald> so i need a way to tell the light sources apart
13:51:10 <fax> fryguybob: [1,2,3] might be considered equal to [2,1,3,1] for example
13:51:17 <fax> it can make perfect sense to do this
13:51:24 <jmcarthur> whald: still sounds like what i would use an IntMap for
13:51:43 <whald> jmcarthur: what's the benefit of using the IntMap?
13:52:25 <Philonous> IntMap ist rather fast
13:52:33 <jmcarthur> *is
13:52:36 <fryguybob> fax: There is nothing wrong with having equivalence relations that take partial information or reduce representations, but it should always be clear from the name and context what kind of equality is being performed.
13:53:07 <whald> Philonous: but despite it's fast, it's still a lookup, so can that be faster than passing the Light around?
13:53:31 <Philonous> whald: Oh, I though rather than having a general Map
13:53:52 <fax> fryguybob agreed
13:54:02 <Cale> whald: Sorry, I got disconnected for a bit there, and I think I missed part of what you're trying to do. You were asking for a way to compare Int -> Bool functions for equality?
13:54:26 <dblhelix> dpratt71: what is the type of the Vertex3 constructor?
13:54:33 <jmcarthur> whald: passing a (Id, LightFunc) around works too. in my experiences, things are just cleaner only passing around an Id and just looking up the other stuff when needed, but that's not necessarily all the time
13:55:08 <jmcarthur> *that's not necessarily always the better solution
13:55:19 <whald> Cale: i really wanted to avoid doing so, and now the dicussion goes light a) attaching an ID to the Lights or b) touching the lights always through an (Int)Map
13:55:23 <Cale> A function Int -> Bool is roughly the same thing as an IntSet.
13:55:34 <jmcarthur> oh this is just a bool?
13:55:36 <Cale> (Or just a Set Int)
13:55:57 <jmcarthur> i didn't even catch that
13:56:07 <whald> nono, it's no bool, that was just made up
13:56:14 <jmcarthur> oh okay
13:56:48 <whald> it's basically from Floats to Floats, in different flavours
13:56:54 <jmcarthur> Cale: those functions correspond to light sources and he wants to be able to compare light sources' identities
13:57:22 <Cale> Then, yeah, just give them names, separate from the function.
13:57:26 <jmcarthur> whald: do those functions even uniquely identify a light source, even if you could compare them?
13:57:45 <whald> that is, a light is made from multiple functions,
13:58:19 <fax> hey Cale sorry for running off yesterday I just realized how late it waws
13:58:39 <whald> jmcarthur: not really, i can have two identical "infinite area lights" and the scene should be twice as bright
13:58:57 <jmcarthur> yeah, so you pretty much need separate identifiers for sure then
13:59:02 <dpratt71> dblhelix: Vertex3 !a !a !a
13:59:17 <whald> jmcarthur: for other light sources (especially when connected to geometry) it's less desirable to have "two of the same"
13:59:29 <jmcarthur> yeah, but i bet it's not a guarantee
13:59:58 <whald> right, so i'll go for IDs, thats simple and gets the job done :-)
14:01:20 <jmcarthur> whald: my suggestion to use an IntMap really should have been simpler than that. the key part i wanted to convey was "separation of identity from value"
14:02:42 <jmcarthur> whald: if you say data Foo = Foo Id Value, you end up with objects that can independently be equal in value or in identity, which i personally find very strange
14:03:31 <dpratt71> how might I create a "GLDouble" from a "Double"?
14:03:46 <whald> jmcarthur: right, that's a ugliness. ok, so i'll use an IntMap and hide that fact behind "accessor" functions
14:04:15 <whald> because i consider the presence of that map an implementation detail i'd rather hide :-)
14:04:24 <jmcarthur> whald: plus if you say just data Foo = Foo Value, you can instantiate Eq (except that in this case Value is a function, which complicates the explanation slightly)
14:04:47 <jmcarthur> eh it's still up to you. i'm just trying to explain where i was coming from
14:05:45 <jmcarthur> well, you still could have instantiated Eq for the former definition, but you would have to decide whether the Id should play a part in equality or not. either way it's partially a lie, from different points of view
14:05:50 <whald> jmcarthur: and i absolutely agree with you, i just think that hiding that map makes it the program easier to read afterwards
14:06:04 <jmcarthur> sure. i don't know how you plan to hide it though
14:06:26 <siracusa> dpratt71: You should be able to convert it by fromRational . toRational
14:06:39 <jmcarthur> you could hide it in a state monad
14:06:44 <dpratt71> siracusa: I'll give that a go, thanks
14:07:16 <whald> "type Light = Int" and e.g. "sampleLight :: Light -> (Point, Normal, Float)"
14:07:32 <whald> and sampleLight does the lookup and asks the relevant light for a sample
14:07:34 <jmcarthur> whald: so the map is static?
14:08:00 <whald> yup
14:08:04 <jmcarthur> oh
14:08:06 <jmcarthur> well
14:08:09 <jmcarthur> that will work then :)
14:08:33 <jmcarthur> i was expecting it to be constructed at runtime
14:09:01 <whald> well, rather static to a scene, so more like "sampleLight :: Scene -> Light -> ..."
14:09:14 <jmcarthur> oh, so Scene has the map
14:09:21 <jmcarthur> which makes sense :)
14:09:23 <whald> and i have the "Scene" around all the time anyway
14:09:28 <jmcarthur> ah
14:09:38 <jmcarthur> if you have it around that much then maybe it should be in a state monad?
14:09:55 <jmcarthur> or reader, even
14:10:01 <jmcarthur> if you never change it
14:10:09 <whald> stay away with that evil monads!
14:10:14 <jmcarthur> wat
14:10:18 <jmcarthur> monads are beautiful :)
14:10:21 <whald> just kidding :-)
14:10:28 <fax> I like monads
14:10:31 <jmcarthur> they vastly misunderstood
14:10:35 <jmcarthur> *they are
14:10:37 <c_wraith> I don't really like the reader monad.
14:10:44 <whald> "State" is easy, but "ST" still hurts me whenever i see it
14:10:52 <fax> why not
14:10:58 <c_wraith> ST is easier than State. :)
14:11:06 <jmcarthur> c_wraith: the thing about the mtl monads is that they are best used to create your own monads with your own access functions
14:11:14 <whald> well, more specifically every occurence of "forall" makes headache
14:11:20 <c_wraith> ST is "true mutable cells".  State is "higher order function disguised as a value"
14:11:21 <jmcarthur> c_wraith: Reader in the raw is not a very nice abstraction to expose in library code, i agree
14:11:43 <c_wraith> there's only one forall in ST, and you don't really need to know anything about it.
14:11:54 <jmcarthur> whald: first you bear with it, then you accept it, then you embrace it :)
14:12:30 <whald> what really bugged me is that there is that "Random" class which really makes sense, and that unbelievable slow "StdGen"
14:12:55 <whald> when you want to replace it you google for the relevant terms, and have two choices
14:12:58 <jmcarthur> c_wraith: consider whald's sampleLight function for example...  it could be like this:  sampleLight :: MonadScene m => Light -> m (Point, Normal, Float)
14:12:59 <c_wraith> I have no trouble with Reader functionality as part of a stack of functionality.  But Reader by itself is really just moving a function argument to the return value's type, which is pointless.
14:13:08 <jmcarthur> c_wraith: agreed
14:13:13 <Cale> whald: and then a dozen replacement random generators, and none of them instances of the Random class
14:13:21 <whald> one really borked SSE thing which only lives in IO
14:13:45 <whald> and the MWC which replaces "Random" by "Variate"
14:14:14 <Cale> I'm not sure I'm aware of either of those.
14:14:24 <Cale> There's mersenne-twister
14:14:27 <whald> yeah, life could be easier for newbies if they would just provide instances of Random
14:14:31 <jmcarthur> you mean mersenne-twister and mwc-random?
14:14:42 <whald> exactly
14:14:57 <jmcarthur> they can't reasonably provide instances of Random though
14:15:01 <monochrom> Do you call stdGen in a tight loop and why?
14:15:04 <jmcarthur> they both critically rely on mutation
14:15:07 <c_wraith> err.  you mean RandomGen?
14:15:14 <jmcarthur> yeah that, i assume
14:15:25 <monochrom> Err nevermind.
14:15:38 <Cale> jmcarthur: Mutation is never critical :)
14:15:53 <monochrom> Mutation is always critical.
14:15:53 <jmcarthur> Cale: okay you caught me saying something extreme ;)
14:15:57 <Cale> You just need a representation for the current state.
14:16:06 <monochrom> Mutation is always in the critical condition, i.e., near death. :)
14:16:11 <jmcarthur> ha
14:16:13 <Cale> heh
14:16:18 <monochrom> Mutation is always in the ICU.
14:16:35 <Cale> split is tricky
14:16:51 <whald> sure you need to maintain state for a prng, but at least StdGen manages to do so without exposing "ST" :-
14:16:53 <whald> :-)
14:17:04 <c_wraith> split should not be in RandomGen
14:17:09 <jmcarthur> it's not
14:17:16 <Cale> c_wraith: I disagree.
14:17:27 <jmcarthur> it's in MonadSplit
14:17:29 <Cale> I think all the pseudorandom number generators should support it
14:17:32 <jmcarthur> oh
14:17:34 <jmcarthur> RandomGen
14:17:36 <jmcarthur> n/m
14:17:45 <jmcarthur> Cale: but can they?
14:17:58 <c_wraith> There's no proof most prngs can support it efficiently
14:18:09 <Cale> and I think it's a shame that people who are knowledgeable about them don't seem to have studied such a fundamental operation
14:18:33 <jmcarthur> Cale: most research hasn't been done with purity in mind
14:18:54 <jmcarthur> which is a shame, but at least understandable given the state of CS
14:19:11 <monochrom> People who are knowledgeable about them deliberately program in a goto-language.
14:19:40 <Cale> The cheap but not easy to prove any properties about it way to implement split is just to generate two new states pseudorandomly, and use those.
14:19:54 <Cale> I think as an interim solution, that probably isn't so bad.
14:20:13 <monochrom> You would think he would write well-structured pseudocode and reserve goto for MIX, but no, he uses goto in pseudocode too.
14:20:22 <ddarius> Mutation will never die.
14:20:24 <monochrom> @quote 1970
14:20:25 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
14:20:34 <jmcarthur> for games maybe, but even for monte carlo algorithms i'd wonder about the statistical bias that might introduce
14:21:08 <jmcarthur> and let's not even get started on security
14:21:20 <Cale> You shouldn't be using a prng for security anyway
14:21:29 <jmcarthur> what about online poker, say?
14:21:29 <Cale> Well, except perhaps something like BBS.
14:21:52 <fax> I wish there was mathoverflow but at a lower level
14:21:53 <Cale> Use a real random number generator
14:22:04 <fax> because I don't undesrtand any of it XD
14:22:04 <monochrom> mathunderflow?
14:22:09 <fax> yes!
14:22:14 <jmcarthur> would that work under heavy load?
14:22:34 <Cale> jmcarthur: It's expensive, but you have to pay for security.
14:22:36 <twink> monochrom: Finite state control etc. has natural expression as goto.
14:23:00 <Cale> Probably easier just to get a hardware RNG in that case.
14:23:15 <jmcarthur> sometimes you just need the best solution you can afford though
14:23:22 <fryguybob> fryguybob: you are better off asking math underflow questions to computer scientists, but you might not always get a good answer...
14:23:35 <fryguybob> (how did I quote myself there...)
14:23:43 <fax> I don't really want to ask questions just read
14:24:02 <fax> good (and well typeset) discussion about stuff that I could actually follow :D
14:24:18 <Cale> Yeah, mathoverflow is full of extremely specialist questions.
14:25:17 <ddarius> Cale: That seems reasonable.
14:26:01 <benmachine> < jmcarthur> which is a shame, but at least understandable given the state of CS <-- was this a clever and subtle pun
14:26:07 <benmachine> :P
14:26:36 <ddarius> benmachine: No.
14:26:50 <benmachine> suit yourself.
14:27:12 <monochrom> shoot myself
14:27:15 <saml> how long does hpaste save the code submitted?
14:27:34 <monochrom> as long as the electricity flows
14:27:41 <benmachine> I believe there's no automatic expiry
14:27:44 <benmachine> but no warranty, either
14:28:22 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1 age: 630 days
14:28:27 <saml> coolz
14:28:42 <saml> how would you capture a craigslist posting?
14:28:55 <saml> oops wrong chan
14:28:58 <monochrom> use a digital camera
14:29:28 <saml> i wanna put in in da monad for security
14:29:57 <monochrom> Da Monad Code
14:30:20 <mreh> 1)photograph penis 2)post on craigslist
14:30:39 <mreh> oh, *capture*
14:30:41 <monochrom> "So, you mean The Last Supper hides a commutative diagram?"
14:33:24 <fryguybob> > encode (0/0 :: Double)
14:33:25 <lambdabot>   Not in scope: `encode'
14:35:03 <EvanR-work> > genericIndex (repeat 'd') 10000000
14:35:04 <lambdabot>   'd'
14:35:08 <EvanR-work> > genericIndex (repeat 'd') 1000000000000000
14:35:11 <lambdabot>   mueval-core: Time limit exceeded
14:36:24 <EvanR-work> is there a limit to the length of a list, besides memory address space
14:37:03 <jmcarthur> no
14:37:14 <EvanR-work> awesome
14:37:31 <benmachine> there is no limit to the length of a list, including memory address space
14:37:49 <benmachine> since lists of length 1000000 need not occupy 1000000 cells' worth of memory space
14:38:00 <jmcarthur> yeah, you could have an infinite list, even :)
14:38:04 <EvanR-work> ah
14:38:12 <EvanR-work> like my 'd' list above
14:38:16 <benmachine> I guess there is an upper bound on the length of a finite list
14:38:20 <jmcarthur> right
14:38:23 <benmachine> but it's really, really, really big
14:38:25 <benmachine> :P
14:38:37 <EvanR-work> i was thinking of lists that actually had stuff in them
14:38:40 <jmcarthur> on the length of a fully evaluated finite list on real hardware
14:39:22 <benmachine> jmcarthur: I wasn't thinking fully evaluated necessarily; I was thinking "memory required to store list generator"
14:39:27 <benmachine> BB(size of memory) :P
14:39:36 <benmachine> except not really but
14:39:42 <ski> (.. you can easily traverse an infinite list without keeping all the visited part of it in memory, same for large files / pipes / network streams)
14:40:17 <jmcarthur> exactly
14:40:31 <benmachine> presumably given some amount of memory there are a finite number of possible programs and thus a finite amount of lists that can be generated
14:41:03 <EvanR-work> my original question is irrelevant due to infinite lists, which was a question about length
14:41:14 <benmachine> EvanR-work: stuff in them... depends what stuff
14:41:20 <benmachine> you could imagine a list of prime numbers
14:41:23 <benmachine> which was infinite
14:41:24 <monochrom> the joy of inverting the Kolmogorov complexity function :)
14:41:36 <benmachine> but full of interesting things
14:41:41 <benmachine> and stored in finite space
14:42:10 <benmachine> but obviously you can't generate every possible list using a small program
14:42:17 <EvanR-work> i wonder how often you really use lists that 'actually have stuff in them' rather than being lazily evaluated
14:42:24 <ski> EvanR-work : if you don't keep references to earlier parts of the list around, there's no limit to the length of the list, even taking memory address space into consideration
14:42:25 <EvanR-work> i guess if the same list is used in two places, its necessary
14:42:47 <EvanR-work> ski: yes
14:42:53 <benmachine> EvanR-work: if it's consumed at the same rate in both places that's fine
14:42:56 <ski> EvanR-work : unless you can fuse the two uses of the list
14:42:57 <monochrom> I see no mutual-exclusion between "actually have stuff" and "lazily evaluated"
14:42:59 <benmachine> or you can ask for it not to be shared
14:43:18 <benmachine> monochrom has a point
14:43:19 <EvanR-work> monochrom: i just dont have the terminology
14:43:36 <monochrom> It is not like I waste time generating lists of type [()]
14:44:21 <EvanR-work> i would consider a linked list in c with many nodes as having stuff
14:44:40 <EvanR-work> a logical list in haskell which exists only by virtue of its definition doesnt
14:44:43 <EvanR-work> sometimes
14:45:27 <benmachine> sometimes :)
14:46:14 <benmachine> okay so the definition of a list takes memory
14:46:30 <benmachine> so if you have a limited amount of memory there are a limited number of lists you can define
14:46:38 <benmachine> and hence a limited amount of stuff that can be in them, if you like
14:47:01 <EvanR-work> right, and sounds like you are implicitly defining equivalence of infinite lists ;)
14:47:13 * benmachine shrugs
14:47:23 <EvanR-work> so you can in some sense nub the list of possible lists to do a length on it ;)
14:47:56 <aavogt> I think your infinite lists are also finite... it's not as if you have time to go through an infinite number of elements
14:48:04 <EvanR-work> but i wasnt asking count of unique stuff in a list, just the length
14:48:51 <benmachine> aavogt: time is one thing there always seems to be more of :)
14:49:13 <EvanR-work> unless you get sucked into a blackhole?!!!
14:49:36 <benmachine> EvanR-work: maybe you'll find this interesting: http://en.wikipedia.org/wiki/Kolmogorov_complexity
14:49:39 <benmachine> maybe!
14:49:40 <benmachine> maybe not
14:49:42 <ddarius> Natural ~ [()]
14:49:43 <benmachine> I make no guarantees
14:49:56 <EvanR-work> read this before
14:50:00 <EvanR-work> i read all of wikipedia
14:50:09 <EvanR-work> periodically checking for new stuff
14:50:16 <EvanR-work> but this article is pretty old ;)
14:50:32 <monochrom> remember EvanR-work I read all of wikipedia
14:50:44 <benmachine> EvanR-work: 3.2 million articles? you are a fast reader
14:50:47 <aavogt> homonyms are ambiguous
14:50:51 <benmachine> @remember EvanR-work I read all of wikipedia
14:50:52 <lambdabot> Done.
14:51:25 <EvanR-work> i said 'red' ;)
14:51:51 <benmachine> if you say so
14:52:40 <aavogt> @quote forget
14:52:41 <lambdabot> Philippa says: <vincenz> Philippa: forget theory, it's about pragmatics <Philippa> we're talking FP, they tend to be the same thing
14:52:54 <EvanR-work> benmachine: i wonder how significant this complexity is for typical objects. i know there are fairly small rngs which produce gigantic sequences
14:54:24 <benmachine> EvanR-work: I imagine it's pretty significant in things like compression algorithms
14:55:29 <benmachine> but then again, since the complexity is not computable
14:55:36 <benmachine> it might be all academic anyway
14:56:24 <kmc> you can prove that something has kolmogorov complexity <= k
14:57:48 <benmachine> yes
15:09:19 <Associat0r> join #proglangtheory
15:09:59 <xerox> no
15:10:08 <monochrom> #pornlangtheory
15:11:23 <ddarius> PornLang, the most popular programming language on the internet.
15:12:27 <twink> ddarius: No technology is mature until it's been thoroughly utilized for porn?
15:12:42 <kmc> says the man named after a porn subgenre
15:13:12 <monochrom> haha
15:13:21 <danharaj> Woot. I managed to build wxhaskell on windows 7.
15:13:55 <danharaj> Are there any frp gui libraries built on top of it?
15:14:01 <ddarius> danharaj: Yes.
15:14:03 <ddarius> wxFruit
15:14:09 <danharaj> Is it still supported?
15:14:17 <ddarius> *shrug*
15:14:42 <danharaj> Do you guys think it would be a good idea if an official gui api was adopted.
15:14:47 <twink> Ah, Cale.
15:14:58 <ddarius> danharaj: If there was one that was good, sure.
15:15:15 <whald> i guess there already is a function that does [Maybe a] -> [a] ?
15:15:22 <kmc> :t catMaybes
15:15:22 <ddarius> danharaj: Right now, gtk2hs is the most popular one.
15:15:23 <c_wraith> :t catMaybes
15:15:23 <lambdabot> forall a. [Maybe a] -> [a]
15:15:23 <lambdabot> forall a. [Maybe a] -> [a]
15:15:41 <whald> thanks and thanks :-)
15:16:09 * hackagebot wumpus-core 0.14.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.14.0 (StephenTetley)
15:16:15 <xerox> :t \xs -> [x | Just x <- xs]
15:16:17 <lambdabot> forall t. [Maybe t] -> [t]
15:16:38 <danharaj> ddarius: I think that's at too low a level. I think a functional reactive api should be specified at a higher level, and you can link it to a backend.
15:16:43 <whald> xerox: i needed it for Maybe a -- sorry :-P
15:16:50 <xerox> whald: dang
15:17:12 <ville> danharaj: one with user chosen backend would probably be the most sensible thing if it was to become official somehow
15:17:41 <ddarius> danharaj: When such a library exists and demonstrates its comprehensiveness, I'm sure it will be popular.
15:18:06 <ville> nevermind me though, just a C++ user, but have followed with interest some discussions of getting a Boost.Gui for C++.
15:18:28 <kmc> ah, boost
15:18:55 <nus> doublenogood
15:19:01 <danharaj> ddarius: I just wonder, a lot of gui experiments pop up, but they don't really gain that much steam. Haskell, IMO, needs a native gui solution instead of binding to a second-hand solution. Why hasn't there been a push to consensus? Does the community not really care?
15:19:24 <kmc> what's a "native gui solution"?
15:19:33 <c_wraith> It's a HUGE amount of work, and typically ends up with second-rate results anyway.  see Swing, for example.
15:19:48 <kmc> a GUI toolkit is a huge library.  it's madness to reimplement that in every language just because you can
15:20:12 <ville> danharaj: It's nigh impossible to design an interface for a library that all agree with. Well that's what has happened with Boost.Bui thus far.
15:20:22 <ddarius> danharaj: You have to have options to arrive at a consensus.  Also, the Haskell community is pretty good at not having a Not Invented Here syndrome.
15:20:31 <kmc> a nice functional FRPish GUI interface would be good
15:20:38 <ville> And by "all" I mean for some reasonably large value of "all"
15:20:41 <kmc> but i think FRP is still too immature to talk about standardization
15:20:49 <kmc> and anyway it should be implemented on top of existing toolkits
15:21:41 <kmc> i think the situation now is reasonable, except in as much as gtk2hs, wxhaskell, etc. have specific problems to be addressed
15:21:47 <danharaj> kmc: I think functional languages don't have a nice solution that fits their style. wxhaskell and gtk2hs look and code really imperatively. If there were a library that fit for Haskell but was written elsewhere, we should embrace those solutions. There aren't any mature libraries like that.
15:22:01 <kmc> see, i don't feel like imperative code is un-haskelly
15:22:06 <kmc> when you're describing an imperative thing
15:22:17 <kmc> Haskell is a great imperative language
15:22:36 <nus> kmc, imperative as in event loop?
15:22:44 <kmc> not necessarily
15:22:45 <kmc> and people are working on declarative/functional/denotational GUIs
15:22:47 <EvanR-work> i like fltk except for the c++ part, wheres the bindings? :)
15:22:51 <kmc> but there's enough different lines of research
15:22:52 <fax> imperative as in hoare triples
15:23:01 <ddarius> EvanR-work: We're waiting for you to write them.
15:23:06 <EvanR-work> i figured
15:23:38 <ddarius> Actually.
15:23:41 <ddarius> @hackage hs-fltk
15:23:42 <danharaj> kmc: But all these experiments and research into FRP seem to get favorable results. Maybe we don't need an official endorsed solution, but an official push to try to bear the idea out completely. I think it should be emphasized as "we should figure this out, let's give it some priority as a community"
15:23:42 <lambdabot> http://hackage.haskell.org/package/hs-fltk
15:23:51 <EvanR-work> fltk2 is where its at
15:23:53 <kmc> danharaj, ah.  with that i agree
15:24:28 <kmc> danharaj, but "official" how?  are there other official community efforts you'd point out as examples?
15:24:47 <ddarius> I don't think anybody working in the fields where declarative UI and Haskell intersect yet thinks there solution is satisfactory.
15:24:56 <danharaj> kmc: was not haskell98 a community effort itself? :p
15:25:09 <ddarius> It is simply too early to move to any of them.
15:25:33 <danharaj> ddarius: I don't think there's enough manpower thinking about the problem.
15:25:46 <kmc> danharaj, i'm just wondering what counts as "official" rather than "people work on whatever they want and publish it"
15:25:57 <kmc> which is how most of the new work seems to be done
15:26:03 <kmc> as opposed to standardizing existing work
15:26:08 <kmc> and i think FRP is too young for that stage
15:26:14 <ddarius> danharaj: What is needed now is still more research.  It's not at a point where it just needs to be fleshed out.
15:26:35 <danharaj> ddarius: fair enough, I can roll with that.
15:26:43 <kmc> haskell98 and earlier haskells were born from half a dozen independent research languages
15:27:00 <kmc> most libraries in HP and most extensions in GHC were someone's independent research project before being semi-standardized
15:27:02 <dpratt71> I'm continuing to try to compile "raincats"...
15:27:15 <kmc> dpratt71, i got it with just "cabal install raincats"
15:27:25 <kmc> after grabbing dev packages for some of the C SDL libraries
15:27:38 <ddarius> Yeah, I don't recall having any trouble installing it.  But it didn't like xmonad and I didn't care enough to resolve that.
15:27:39 <dv-> I was just playing that yesterday
15:27:40 <kmc> latest Haskell Platform, GHC 6.12.1
15:27:41 <dpratt71> kmc: it's on hackage ?! why didn't I notice that
15:28:00 <dpratt71> I downloaded the source from the site
15:28:04 <kmc> ah
15:28:28 <dv-> Has anyone gotten Frag to build on 6.12.1?
15:29:40 <dpratt71> it appears that once upon a time GLdouble was an alias for Double...now it appears to be something else (don't take this as fact -- it's my novice diagnosis/assumption)
15:29:57 <kmc> seems likely
15:31:23 <dpratt71> siracusa and jmcarthur gave me a clue and I defined a function to convert from Double to GLdouble...
15:31:46 <whald> @hoogle catMaybes
15:31:46 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
15:31:47 <dpratt71> I plugged it in anywhere I got the error message and it appeared to fix it
15:31:59 <jmcarthur> did i?
15:32:12 <jmcarthur> i think i had nothing to do with that one
15:32:24 <dv-> dpratt71: could you upload the changed files?
15:33:08 <dpratt71> jmcarthur: you're right, I guess; you've helped on so many other ocassions...
15:33:14 <jmcarthur> heh
15:33:41 <dpratt71> so now I have a similar but slightly different error...
15:33:53 <dpratt71> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25347#a25347
15:35:24 <dpratt71> it seems like I need to do something along the same lines as before, but I'm not sure how to go about it in this case
15:35:42 <kmc> wait so why don't you get it from hackage?
15:36:04 <kmc> dpratt71, convert ry from Double to GLdouble
15:36:10 <dpratt71> kmc: well, this is a learning excersize after all
15:36:13 <kmc> ok
15:37:44 <dpratt71> kmc: I'll try that; I have a related question, though...
15:37:55 <dpratt71> my convert function is:
15:37:55 <dpratt71> makeGLdouble :: Double -> GL.GLdouble
15:37:55 <dpratt71> makeGLdouble = fromRational . toRational
15:38:31 <dpratt71> without the type annotation, it inferred the parameter type as Integer...
15:38:52 <dpratt71> ...with the type annotation, I don't think it'll work in this instance
15:39:13 <dpratt71> can I make it more general?
15:39:21 <mauke> dpratt71: just use realToFrac
15:39:31 <fax> leave off the type signature and sse what happens
15:39:44 <mauke> fax: MR
15:40:04 <kmc> turn off MR
15:40:11 <fax> ??
15:40:30 <kmc> the dreaded monomorphism restriction
15:40:31 <dpratt71> fax: in my version of the function? I got an error indicating that the parameter type was inferred as Integer (not Double)
15:40:37 <kmc> yes
15:40:43 <kmc> that's because of monomorphism restriction + defaulting
15:40:50 <kmc> :t fromRational . toRational
15:40:51 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
15:40:57 <dpratt71> oh, of course!...uh, what?
15:40:57 <mauke> :t realToFrac
15:40:58 <kmc> it tries to find a monomorphic type for that
15:40:58 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
15:41:03 <fax> Public service announcement: All haskell users, please disable the monomorphism restriction!
15:41:12 <kmc> and it has to follow the arbitrary defaulting rules
15:41:18 <ddarius> fax: If you are using NHC, you don't have a choice.
15:41:20 <fax> thank you for your cooperation
15:41:40 <dpratt71> so, in summary, I turn off MR and remove the type signature?
15:41:42 <jmcarthur> i put type signatures on my top level functions anyway
15:41:46 <mauke> dpratt71: just use realToFrac
15:41:47 <ddarius> (Insofar as NHC doesn't implement the monomorphism restriction.)
15:41:49 <kmc> dpratt71, better to put in an explicit signature
15:41:55 <fax> NHC is wise
15:42:05 <kmc> makeGLDouble :: (Real a, Fractional b) => a -> b
15:42:10 <kmc> but you might consider changig the name ;P
15:42:11 <dpratt71> mauke: instead of my function or in it?
15:42:15 <mauke> dpratt71: instead
15:42:17 <kmc> and even more so you might consider using realToFrac
15:42:31 <kmc> :t realToFrac
15:42:32 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
15:42:40 <dpratt71> ok, I'll give that a go; thanks all
15:58:26 <scotthw> is there an easy way to combine two functions into one?
15:58:26 <xerox> :t (.)
15:58:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:58:26 <alpounet> scotthw, how exactly ?
15:58:26 <alpounet> you can compose them
15:58:26 <xerox> f=(e->)
15:58:26 <scotthw> right, so i know i can .
15:58:27 <alpounet> @type Predlude..
15:58:28 <lambdabot> parse error on input `Predlude..'
15:58:32 <alpounet> @type Predlude.(.)
15:58:33 <lambdabot> Not in scope: data constructor `Predlude'
15:58:37 <alpounet> @type Prelude.(.)
15:58:38 <lambdabot> Not in scope: data constructor `Prelude'
15:58:40 <alpounet> haa
15:58:41 <mauke> liftM2 (,)
15:58:52 <xerox> :t liftM2 (,)
15:58:53 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
15:58:55 <scotthw> OK let me pastebin it
15:59:07 <xerox> cartesian product of functions :)
15:59:51 <scotthw> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25348#a25348
16:00:13 <scotthw> so here I have createFrames, f, and vectorframes
16:00:20 <scotthw> i want to put f and vectorframes into
16:00:20 <scotthw> f
16:00:31 <mauke> ?
16:00:44 <scotthw> does that make no sense
16:00:48 <mauke> yes
16:00:55 <mauke> what do you mean by "put f and vectorframes into f"?
16:00:56 <xerox> vectorframes num = map f [1..num] where f ix arr2 = ...
16:01:10 <xerox> err
16:01:15 <xerox> the other way around?
16:02:01 <scotthw> for the bottom half
16:02:23 <scotthw> can i do another where
16:02:23 <scotthw> and define f?
16:02:23 <scotthw> how would that look
16:03:04 <scotthw> just indent vectorFrames actually?
16:04:09 <scotthw> mauke: sorry i meant put vectorFrames and f into createFrames
16:17:54 <TedM> Has anyone had any luck building nhc98 lately?
16:18:29 <xerox> not any since '98
16:18:37 <TedM> :-)
16:19:02 <TedM> The tarball dist is pretty old and seems to depend on an old version of ghc...where the packages are in a imports directory
16:19:17 <TedM> The build in the darcs repo seems to be broken
16:20:39 <kmc> i think yhc mostly supersedes nhc
16:20:42 <kmc> what do you need nhc for?
16:20:43 <mauke> blargh, I've lost my hackage password again
16:20:43 <TedM> The cpphs tool is mildly broken - I fixed its makefile without too much trouble
16:21:01 <TedM> the hmake tool it comes with seems to be completely broken
16:21:15 <TedM> I thought it was the other way around - that nhc superseded yhc
16:21:16 <TedM> ?
16:22:01 <TedM> I do a lot of programming for peculiar platforms and I'm evaluating the various haskell compilers for cross-platform duties
16:22:26 <TedM> ghc doesn't seem to be ideally suited to this...or at least maybe I haven't tried hard enough
16:22:45 <kmc> yeah, it's not
16:22:51 <kmc> may be getting better with the LLVM backend
16:23:16 <TedM> that's pretty exciting - llvm ghc can't come soon enough
16:23:23 <kmc> TedM, http://www.haskell.org/haskellwiki/Yhc/FAQ
16:23:27 <kmc> TedM, it already exists
16:23:34 <kmc> in various patches / branches
16:23:44 <mle> kmc: how does it fare, performance-wise?
16:23:51 <kmc> LLVM?
16:23:52 <kmc> not sure
16:24:01 <kmc> there are benchmarks online i'm sure
16:24:44 <blackdog> think it was more or less even, wasn't it?
16:24:46 <kmc> i think it's supposed to be much better for bytestring, vector, dph code and the like
16:24:49 <dpratt71> had to take a break and now I'm back at it and I think I'm really close
16:24:51 <TedM> ah - proven wrong - I'll look at yhc
16:24:53 <blackdog> which is pretty impressive for something that's had no tuning
16:24:56 <dpratt71> I get this error: : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25349#a25349
16:24:59 <kmc> and is newer and more likely to improve
16:25:21 <kmc> plus we can use lots of LLVM backend optimizations written by others
16:25:25 <TedM> Has the llvm patch been merged yet?
16:25:31 <kmc> don't know
16:25:34 <aavogt> @type throwIO
16:25:35 <lambdabot> Not in scope: `throwIO'
16:25:41 <aavogt> @hoogle throwIO
16:25:42 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
16:25:42 <lambdabot> Control.OldException throwIO :: Exception e => e -> IO a
16:25:42 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
16:26:03 <TedM> the last I heard was the patch creator was talking to the llvm people about implementing a -fasm optimization
16:26:12 <dpratt71> I'm guessing ExitException has been superseded by something else
16:26:13 <kmc> TedM, change the import for Control.Exception to Control.OldException
16:26:15 <kmc> dpratt71, yes
16:26:16 <aavogt> dpratt71: if you use base-4, you don't need the ExitException
16:26:27 <kmc> it's been superseded by throwing an ExitCode itself
16:26:32 <aavogt> no, don't use OldException
16:26:38 <aavogt> it's going away soon
16:26:48 <ddarius> blackdog: Most of the optimizations GHC does happen higher than the assembly/Cmm level so the comparison is mostly a direct comparison of backends.
16:27:07 <TedM> kmc well, cool - thanks - I'll have a go at building yhc
16:27:17 <kmc> aavogt, this is an academic exercise anyway
16:27:23 <dpratt71> kmc: do you mean I can do: throwIO ExitSuccess ?
16:27:32 <kmc> dpratt71, try it
16:27:38 <dpratt71> kmc: will do
16:27:42 <kmc> i think it'll work
16:27:47 <aavogt> instance Exception ExitCode -- Defined in GHC.IO.Exception
16:27:52 <kmc> the package dpratt71 is trying to build is already working from hackage
16:27:55 <blackdog> ddarius: sure, but presumably there are forms llvm handles better than others
16:28:22 <ddarius> The NCG is still very simplistic, and the C output is hampered by C, so I'm not particularly surprised about the results.
16:28:46 <ddarius> If GHC had a good NCG and LLVM was comparable, then I would be more surprised.
16:28:58 <scotthw> what is the best way to convert Integer to Int
16:29:03 <kmc> :t fromIntegral
16:29:04 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:29:06 <ddarius> @quote fromIntegral
16:29:06 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
16:29:42 <ddarius> Admittedly, the behavior of fromIntegral :: Integer -> Int is not very nice.
16:29:48 <scotthw> right...
16:29:55 <dpratt71> kmc, et al: compiled! thanks
16:30:00 <scotthw> i've used from integral, not working as expected
16:30:05 <scotthw> fromIntegral*
16:30:15 * hackagebot hpage 0.7.6 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.7.6 (FernandoBenavides)
16:30:20 <ddarius> > fromIntegral (2^70) :: Int
16:30:21 <lambdabot>   0
16:30:38 <scotthw> yeah...
16:30:44 <aavogt> > 2^70 :: Int
16:30:45 <lambdabot>   0
16:30:50 <ddarius> > fromIntegral (2^70+1) :: Int
16:30:51 <lambdabot>   1
16:30:59 <scotthw> lots of issues.
16:31:30 <scotthw> maybe i should be asking, is there some version of take that takes Integers instead?
16:31:43 <c_wraith> :t genericTake
16:31:44 <aavogt> @type genericTake
16:31:44 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
16:31:44 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
16:31:48 <scotthw> HEY!
16:31:52 <scotthw> I didn't know that.
16:32:16 <scotthw> is there any [dis]advantage to genericTake
16:32:16 * Twey either.
16:32:21 <aavogt> it's slower
16:32:22 <Twey> It's probably slower
16:32:41 <aavogt> and then you rely on defaulting
16:33:09 <cads> but you can index by bunnies, which is a real advantage (where bunnies are a particularly cute integral type you've defined)
16:33:34 <cads> (this is an advantage when girls are reviewing your code)
16:33:48 <aavogt> so that's what fibonacci numbers are for!
16:34:36 <cads> fibonacci + the bunny connection = you will be laid
16:35:01 <cads> at least this worked for me
16:39:15 <DigitalKiwi> @faq can haskell get you laid?
16:39:15 <lambdabot> The answer is: Yes! Haskell can do that.
16:39:52 <ezyang> Oh boy!
16:40:45 <Eelis> how do i get hoogle/lambdabot to tell me where a certain instance is defined?
16:41:05 <ezyang> :info Monad
16:41:09 <ezyang> bleh
16:41:24 <ezyang> anyway, :info in ghci tells you where all of the defined instances for a typeclass live
16:41:41 <Eelis> ah, great. thanks
16:42:00 <ezyang> obviously the relevant modules have to be imported
16:42:30 <Eelis> naturally :)
16:43:46 <DigitalKiwi> whos on first what's on second and i don't know's on third
16:47:25 <Philonous> DigitalKiwi: Interesting. You don't seem to be very knowledgeable
16:47:38 <DigitalKiwi> ?
16:47:51 <DigitalKiwi> you are too young my friend
16:47:54 <Philonous> DigitalKiwi: You should really know who's on third
16:48:26 <DigitalKiwi> http://www.youtube.com/watch?v=sShMA85pv8M
16:49:17 <Philonous> Yeah I know
16:49:49 <theorbtwo> Nobody is too young to know who is on third.  They just haven't been properly exposed.
16:50:15 <Philonous> theorbtwo: Actually, who's on first.
16:50:17 <DigitalKiwi> i can't remember what naturally is
16:50:21 <DigitalKiwi> the pitcher maybe?
16:50:41 <mythmon> i think the pitcher is of course
16:50:53 <DigitalKiwi> rather, who he thinks is named naturally
16:52:31 <Eelis> how come mtl hasn't been updated since 2008?
16:52:54 <kniu> So I got an IO thread listening on a handle for text, and it's a simple infinite loop that calls a function on every line received.
16:53:14 <kniu> How do I make it so that it doesn't take up an entire CPU core?
16:53:31 <DigitalKiwi> ah, first baseman he thinks is naturally
16:53:31 <dpratt71> well, that ended rather anti-climacticly...trying to run raincats results in an OpenGL error (XGetVisualInfo returned 0 visuals...)
16:53:34 <ezyang> kniu: Not the answer you're looking for, but `nice`
16:53:38 <blackdog> kniu: nice?
16:53:43 <kniu> what's nice?
16:53:48 <DigitalKiwi> which is who, so i was right! >.>
16:53:59 <blackdog> it sets the priority of the process
16:54:04 <ezyang> `man nice`
16:54:06 <DigitalKiwi> i'm nice!
16:54:07 <kniu> oh, a unix thing.
16:54:19 <blackdog> so you can set it to a high value and other things will get first crack
16:54:40 <mythmon> but is there a way to sleep and wait? instead of busy waiting?
16:54:51 <kniu> how come other programs don't have to use nice?
16:55:12 <blackdog> kniu: they do.
16:55:20 <blackdog> at least, if they're cpu intensive
16:55:33 <blackdog> now, it's possible that your program is very inefficient
16:55:35 <mythmon> which waiting for events shouldn't be cpu intensive
16:55:48 <kniu> it's not supposed to be inefficient.
16:55:51 <blackdog> but you should profile that and work out what's taking all the time
16:55:51 <mythmon> you could check for an event, sleep for a few milliseconds, and then check again?
16:56:03 <kniu> mythmon, I'm going to try that now.
16:56:10 <blackdog> mythmon: that would be slower, i think
16:56:24 <mythmon> blackdog: its not too slow, its just taking up too much cpu
16:56:42 <blackdog> if you're waiting to read from a file handle, your thread will block and use no cpu
16:57:00 <kniu> blackdog, so so avoid that, I have to...?
16:57:06 <mythmon> i think he is waiting to get a file handle, not waiting to read
16:57:13 <mythmon> kniu: in this case, you want it to block
16:57:18 <kniu> no, I have the handle.
16:57:21 <mythmon> oh. ok
16:57:30 <kniu> I'm continuously reading from and writing to it.
16:57:34 <monochrom> reproducible by other people or it didn't happen
16:57:42 <blackdog> kniu: in the interests of clarity, perhaps chuck it up on a pasteboard
16:57:51 <kniu> at a frequency of about a few dozen times each second.
16:57:54 <kmc> kniu, what kind of handle?
16:57:59 <kniu> HTTP.
16:58:04 <kniu> internet.
16:58:10 <kmc> why should that take all the CPU?
16:58:15 <kmc> are you doing a normal blocking read?
16:58:28 <kniu> I'm just using hPutStr
16:58:31 <kmc> a write?
16:59:08 <kniu> and hGetLine
16:59:33 <kmc> it doesn't sound like this should busy loop
16:59:35 <kniu> @hpaste
16:59:35 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:59:37 <kmc> it sounds like it should block
17:00:18 <Eelis> Igloo: ping
17:00:20 <kmc> and the GHC runtime will implement blocking IO in threads by putting them on a select() queue or similar
17:01:03 <blackdog> unless you have more than 1024 handles open at once, in which case you're sort of screwed
17:01:26 <kniu> hm
17:01:30 <kniu> how do I block, then?
17:01:38 <kniu> http://pastebin.com/c6GzPNtq
17:01:59 <mle> blackdog: raising these limits is always feasible.
17:02:31 <mythmon> it seems like there shouldn't really be a limit to that... but then i don't design languages
17:02:38 <kmc> to 1024?
17:02:42 <kmc> that's not a language design thing
17:02:49 <kniu> respond simply calls hPutStr on the same handle to send a message.
17:02:52 <kniu> simple, really.
17:02:55 <kmc> kniu, this sounds fine
17:03:06 <kmc> do you have results showing that it uses a whole core?
17:03:14 <kmc> i mean it will if the data comes fast enough, clearly
17:03:15 <blackdog> mle: yeah, bos and tibbe are looking at it
17:03:22 <kniu> well, there's my cpu meter going up to 100% every time I start the program.
17:03:27 <kmc> okay
17:03:28 <kmc> did you profile?
17:03:31 <blackdog> mle: i can't wait:) they've got some really tasty results
17:03:50 <kmc> how many lines per second does it print?
17:03:51 <monochrom> In the interest of sanity, perhaps drop interest in a question that fails to give within 2 minutes enough information or procedure to reproduce the problem.
17:03:55 <kniu> no, I have not profiled.
17:04:06 <kniu> depends on the number of channels it's in,
17:04:24 <kniu> but should be around 2 or 3 lines per second normally.
17:04:53 <mythmon> on a side note: how fast is haskell? I am only just starting to learn it.
17:05:00 <kmc> mythmon, Haskell is a language and has no speed
17:05:07 <kmc> GHC implements Haskell with pretty good speed
17:05:15 <kmc> generally, the simplest idiomatic solution will not be that fast
17:05:26 <kmc> but not terrible
17:05:34 <mythmon> alright. thanks.
17:05:36 <blackdog> mythmon: if you're interested in seeing what optimised code looks like, perhaps check the shootout
17:05:36 <kmc> often much faster than the simple solution in Python or Ruby with standard implementations
17:05:57 <kmc> and then you can selectively decide what to optimize
17:08:19 <hiptobecubic> Hey, goons, answer me this. How long did it take before you stopped saying.. "ohhhhhhhh" everytime you looked at a simple sounding example of how to implement something. Like testing if a sublist is present in a list, or adding polynomials, etc etc.
17:08:22 <DigitalKiwi> dons maybe? made a post about writing haskell as fast as C
17:08:34 <kmc> i don't get it
17:08:40 <DigitalKiwi> http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/
17:08:56 <blackdog> mythmon: one thing i have noticed is that the profiling tools that come with GHC are surprisingly good.
17:09:09 <kniu> I'm always of the opinion that if you're going to write C, just use C.
17:09:13 <blackdog> profiling ruby always feels like using stone tools
17:09:19 <mythmon> blackdog: do you have a link that has more information about the profiling tools?
17:09:45 <kniu> I mean, look at that code.
17:09:52 <kniu> It's so... ugly.
17:10:10 <blackdog> mythmon: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/profiling.html
17:10:16 <kmc> kniu, but most programs don't need C performance for most parts
17:10:25 <kmc> so yes you might write that part in C and use FFI
17:10:34 <monochrom> What code is ugly specifically?
17:10:37 <kmc> there's also something to be said for successive improvement
17:10:59 <monochrom> I mean, don't confuse hand-written code with compiler-emitted intermediate code called "core" on that page.
17:11:39 <kmc> you can write the simple idiomatic code and QuickCheck it against your high performance implementation
17:11:47 <kniu> oh
17:11:50 <kmc> you can't do either if you use C only
17:11:54 <monochrom> Specifically, if you are looking at "case >## c limit of False -> go (+## a c) (+# b 1) (+## c 1.0) " etc, that is ugly yes, but that is not hand-written no.
17:11:55 <kniu> I was wondering where those '#'s came from.
17:12:01 <blackdog> mythmon: also, threadscope is good for visual feedback on how your programs are using the different cores
17:12:21 <monochrom> I am of the opinion that people should read carefully thrice before forming an opinion.
17:12:34 <monochrom> Or better yet never form any opinion at all.
17:12:39 <blackdog> the first performance problem you usually hit is space leaks - either being too lazy or not lazy enough
17:13:04 <blackdog> monochrom: i have some uninformed views i would like to share with you about that ridiculous claim.
17:13:13 <monochrom> haha
17:13:23 <DigitalKiwi> monochrom: instead we should be sheeple?
17:14:54 <ddarius> DigitalKiwi: No, instead you should be robots.
17:15:40 <srh> talk to the fan
17:20:49 <kmc> i am a robot
17:21:19 <lambdabot> Really? We should get together!
17:21:37 <lambdabot> Your rack or mine?
17:24:36 <monochrom> @bots
17:24:36 <lambdabot> :)
17:55:49 <mythmon>  /crapbuster
17:55:50 <mythmon> er
17:55:58 <mythmon> oops
18:08:13 <octavious> ...well now I'm curious
18:08:25 <Pseudonym> You're extremely curious.
18:10:16 <c_wraith> curiouser and curiouser
18:13:52 * hackagebot hexpat 0.15 - wrapper for expat, the fast XML parser  http://hackage.haskell.org/package/hexpat-0.15 (StephenBlackheath)
18:17:04 <interferon> given the snippet "Test <$> getLine <*> pure "foo" <*> getLine" is there an operator that will replace "<*> pure"
18:18:10 <c_wraith> not that I'm aware of
18:19:54 <interferon> so "<*> pure" is an okway way to do it?
18:21:55 * hackagebot hexpat-iteratee 0.3 - Chunked XML parsing using iteratees  http://hackage.haskell.org/package/hexpat-iteratee-0.3 (StephenBlackheath)
18:22:49 <mle> well
18:22:53 <c_wraith> unless you want to do something like: flip Test "foo" <$> getLine <*> getLine
18:23:05 <c_wraith> Or you could make your own operator for it
18:23:07 <Cale> interferon: If you have a lot of that, you could invent your own operator
18:23:19 <mle> I like the flip one.
18:23:24 <mauke> (`Test` "foo")
18:23:48 <interferon> i always find flips take me a while to mentally parse
18:24:08 <interferon> Cale: true
18:26:04 <c_wraith> Hmm...   Applicative f => f (a -> b) -> a -> f b
18:26:20 <c_wraith> the alt-stdlib project has an operator for that.
18:26:48 <danharaj> Isn't that a bit like >>= for monads? Does it satisfy similar laws?
18:27:13 <danharaj> disregard that I suck at haskell.
18:28:23 <mauke> <*> is ap, <$> is liftM
18:29:37 <djahandarie> HAHAHA DISREGARD THAT I SUCK... uhhh
18:29:54 <c_wraith> too much bash
18:30:03 <djahandarie> I'm on bash!
18:30:06 <djahandarie> Top 100
18:31:18 <Agnostos> djahandarie: which particular quote ?
18:31:34 <djahandarie> Just search my nick
18:33:49 <interferon> bwuh?  "#include" doesn't work in GHC anymore?  i can't compile nano-hmac without it
18:34:05 <c_wraith> It needs the CPP language extension
18:36:34 <interferon> ah
18:37:25 <interferon> well that fixes the problem but looks like nano-hmac doesn't build on OS X anyway
18:37:30 <interferon> thanks, c_wraith
18:37:39 <blackdog> interferon: what was the problem?
18:39:04 <interferon> blackdog: #include failed because CPP wasn't enabled
18:39:45 <blackdog> interferon: no, i mean with mac os
18:42:12 <Pseudonym> OK, gotta go bleed for my country.
18:42:14 <Pseudonym> BBL
18:53:11 <interferon>      error: #error architecture not supported
18:53:21 <interferon> blackdog: that happened
18:55:52 <tsLight> I am getting this error in Hugs: "ERROR "Main.hs" - Module "Astar" not previously loaded". Any idea what can be causing it?
18:56:17 <tsLight> Main module imports Astar
18:59:14 <aavogt> where is Astar?
19:00:03 <tsLight> i fixed it :P
19:00:07 <tsLight> it was named AStar instead of Astar
19:00:46 <patch-tag> has anybody connected vis unixodbc to a mysql db? That's what I'm doing now. I haven't even successfully used isql
19:10:44 <patch-tag> ok, well I did connect with isql :)
19:46:27 <patch-tag> Progress with hdbc. I have isql working, and I am now trying to use code at http://stackoverflow.com/questions/1355113/haskell-hdbc-odbc-mysql-and-mac-os-x
19:47:29 <patch-tag> However, when I do getTables =<< connectODBC "DSN=Default;UID=[censored];PWD=[censored]" I get error
19:47:44 * hackagebot hpage 0.8.0 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.8.0 (FernandoBenavides)
19:47:52 <patch-tag> *** Exception: Prelude.(!!): index too large
19:48:07 <patch-tag> I know the connection is good because if I change the password to wrong pw I get a different error.
19:59:45 <patch-tag> ok, I can use quickQuery, I guess to get values, I guess there is just something wrong with getTables function
20:11:42 <kniu> Perhaps you haven't installed the profiling libraries for package `network-2.2.1.7'?
20:11:45 <kniu> how do I do that?
20:13:04 <heatsink> kniu: If you're using cabal, then use the -p option
20:13:11 <kniu> oh, ok.
20:13:16 <c_wraith> you'll also need --reinstall
20:13:17 <heatsink> when installing the 'network' package
20:16:06 <kniu> gah
20:16:08 <kniu> pain in the ass.
20:36:12 <kniu> hm
20:36:49 <kniu> I figured it out.
20:37:12 <kniu> thanks to the profiler, I saw that what took up the CPU time wasn't the listener.
20:37:52 <kniu> But the (forever $ return ()) call in main that keeps the program going after the listener threads are spawned.
20:53:06 <blackdog> kniu: heh. what did you think that would do? That's the equivalent of while(1){}
20:53:33 <kniu> well, something had to keep the threads from being killed.
20:53:56 <kniu> I just replaced it with a standard input listener.
20:54:28 <kniu> Now on to the second problem:
20:54:43 <kniu> after a day or so of running, memory usage goes into the stratosphere.
20:55:27 <blackdog> kniu: standard thing to do is to just wait on the threads
20:55:34 <blackdog> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Concurrent.html
20:56:04 <blackdog> you probably want to run with heap profiling as well, then
20:57:22 <TacticalGrace> Has anybody else seen the following error w/ darcs 2.4 and a GHC head repo?
20:57:24 <TacticalGrace> checking for GHC version date... darcs: memory allocation failed (requested 3744464896 bytes)
20:57:30 <TacticalGrace> (this is on Mac OS X)
20:59:39 <rl> I completely fail to understand what's going on...
20:59:43 <rl> limitingfactor:quickhull rl$ ./par/quickhull 1000000
20:59:43 <rl> N = 1000000: 1468/1476 1468/1476 1468/1476
20:59:44 <rl> limitingfactor:quickhull rl$ ./par/quickhull 1000000 +RTS -N2
20:59:44 <rl> N = 1000000: 1650/2989 1650/2989 1650/2989
20:59:44 <rl> limitingfactor:quickhull rl$ ./par/quickhull 1000000 +RTS -N4
20:59:44 <rl> N = 1000000: 1768/6091 1768/6091 1768/6091
21:00:22 <rl> if I double the number of cores the wallclock time stays the same and the CPU time doubles
21:01:16 <rl> 1. I don't think this was happening when I last looked at this, it just didn't scale
21:01:16 <rl> 2
21:01:27 <rl> . how the hell can this happen anyway?
21:02:03 <rl> m/t
21:07:33 <TempNick> http://www.petitemarion.com/?id=1295358
21:11:55 <JoeyA> I'm a Haskell noobie.  map max [(1,2),(4,3)] doesn't work because max takes 2 arguments, not 1 tuple argument.  Is it possible to rephrase the expression so map passes 2 arguments each to max instead of 1?
21:12:33 <dolio> > map (uncurry max) [(1,2),(4,3)]
21:12:33 <lambdabot>   [2,4]
21:14:07 <JoeyA> Does Haskell have a native fold/reduce function?
21:14:18 <JoeyA> Ah, I guess so
21:14:34 <danharaj> foldr, foldl, foldl'
21:14:49 <JoeyA> I'm trying to figure out why I can't do foldl (+) [1,2,3,4] .
21:15:30 <tensorpudding> you need an accumulator
21:15:40 <tensorpudding> foldl (+) 0 [1,2,3,4]
21:15:48 <tensorpudding> either that or use foldl1
21:16:25 <JoeyA> ah
21:16:31 * SubStack feeds those catamorphisms some tuna
21:16:39 <tensorpudding> There are several different folds in Haskell.
21:17:34 <tensorpudding> foldl and foldr do right and left folds, foldl' is strict, foldl1 and foldr1 don't require an accumulator but have a more restrictive type and will choke on empty lists
21:18:36 <tensorpudding> foldl' is usually preferred over foldl
21:19:16 <JoeyA> I just learned Haskell supports custom operator overloading.
21:19:42 <tensorpudding> http://www.haskell.org/haskellwiki/Fold
21:19:59 <tensorpudding> has the whole story, including graphs to help you picture what folds actually do
21:20:04 <JoeyA> <interactive>:1:1: Not in scope: `foldl''
21:20:04 <andrewsw> is anyone up on flymake-mode for haskell in emacs23?
21:20:09 <blackdog> andrewsw: yep.
21:20:18 <blackdog> ghc-mod on github is the best way to get it going, though
21:20:26 <blackdog> don't mess with the evil perl script
21:20:42 <SubStack> JoeyA: what? since when
21:20:50 <andrewsw> ah. well, I hve the perl script working like a charm for a long time, but a recent upgrade has killed it the mode.
21:21:04 <tensorpudding> foldl' is in Data.List, you have to import it.
21:21:11 <andrewsw> I get "Wrong type error: stringp, nil" when I enable flymake-mode.
21:21:13 <blackdog> andrewsw: yeah, i was the same. i highly recommend ghc-mod:)
21:21:32 <JoeyA> "Prelude Data.List>" Great, now I have less room to type
21:21:38 <blackdog> kazu is continually upgrading it and adding neat little features
21:21:45 <andrewsw> I'll check it out. but I'm annoyed because if I re-eval the buffer on my .emacs, then it suddenly works! grrr!
21:21:48 <ddarius> As much as I like C++, C++-colored glasses are ruining the field of programming.
21:21:54 <tensorpudding> Also, while the typeclasses do provide something like overloading, it is probably better to compare typeclasses to Java interfaces
21:21:58 <Makoryu> JoeyA: You can change the prompt, y'know
21:22:00 <SubStack> JoeyA: :set prompt "ghci> "
21:22:11 <Makoryu> Or :set prompt "> "
21:22:41 <SubStack> hmmm I should put colors in my prompt
21:22:45 <Makoryu> Personally, I prefer :set prompt "Never.Gonna.Give.You.Up> "
21:22:58 <JoeyA> In ghci, is there a way to see the prototype/whatever of a function/object/whatever ?
21:23:07 <ddarius> Oh god.
21:23:09 <tensorpudding> :t
21:23:11 * ddarius returns to reading.
21:23:15 <Makoryu> :t ()
21:23:16 <lambdabot> ()
21:23:18 <Makoryu> :t "foo"
21:23:19 <tensorpudding> Will tell you what the type of a function is.
21:23:19 <lambdabot> [Char]
21:23:23 <Makoryu> :t map
21:23:24 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:23:34 <tensorpudding> Which I guess is the Haskell equivalent of C-style prototypes.
21:23:45 <tensorpudding> Haskell doesn't have objects though.
21:24:00 <JoeyA> :set prompt "C:\> "
21:24:20 <Makoryu> C has prototypes because you can't use an identifier before you've declared it
21:24:25 <JoeyA> (joke stolen from xkcd blag)
21:24:59 <Makoryu> Haskell just has type signatures... And not all the time, either
21:25:19 <Cale> JoeyA: btw, you can put that command in your ~/.ghci file and ghci will set your prompt every time
21:25:24 <tensorpudding> You'll get different answers for :t from ghci and lambdabot unless you enable ghc extensions though
21:25:27 <Makoryu> :t let foo = 2; foo :: Int in foo + 4
21:25:28 <lambdabot> Int
21:25:44 <Makoryu> Yeah, lambdabot has some extensions enabled for stuff
21:25:54 <jmcarthur> @check \x y -> x*y == y*(x::Double)
21:25:55 <lambdabot>   "OK, passed 500 tests."
21:25:58 <tensorpudding> It's not that the types of different, just that they emphasize quantification in lambdabot by explicitly stating the forall
21:26:15 <jmcarthur> @check \x y -> x+y == y+(x::Double)
21:26:15 <lambdabot>   "OK, passed 500 tests."
21:26:17 <Cale> tensorpudding: Except for when the types really are different ;)
21:26:52 <tensorpudding> Also it shows kind restrictions, like for monads.
21:26:57 <tensorpudding> @type return
21:26:57 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:27:04 <JoeyA> Now I'm trying to learn how to dissect type signatures.  f :: [a] -> Int means f maps an array of things to an Int (does `a` carry a special meaning?)
21:27:21 <tensorpudding> m has to have kind * -> *, though that's implicit by the fact that it is a monad
21:27:25 <JoeyA> or is it just a placeholder?
21:27:29 <Cale> JoeyA: It means that for any type a, the function f takes a list of values of type a, and produces an Int
21:27:34 <Cale> (not an array)
21:27:37 <Makoryu> JoeyA: "foo -> bar" is a type signature for a function that takes arguments of type foo, and returns a value of type bar
21:27:37 <JoeyA> okay
21:27:41 <JoeyA> The [] means array, though
21:27:47 <Makoryu> JoeyA: Arrays are not lists.
21:27:48 <Cale> JoeyA: no, it means list
21:28:06 <JoeyA> oh
21:28:10 <tensorpudding> JoeyA: the a means that it is polymorphic, the a itself is a type variable, that can be replaced later. It's similar to C++ templates in that way.
21:28:15 <Ramb0> Hey, I've got a definition question:
21:28:18 <Makoryu> In Haskell, [] is used for linked lists, because those are more useful for general purpose stuff
21:28:21 <JoeyA> ah
21:28:40 <Cale> Lists differ from arrays in that they can be infinitely long, and are not randomly-accessible (it takes linear time to get to any one element)
21:28:42 <JoeyA> What does a -> b -> c mean?
21:28:42 <tensorpudding> They're cons lists, really, like the ones in Lisp.
21:28:48 <JoeyA> Why not a -> c ?
21:28:54 <JoeyA> Is it related to currying?
21:28:59 <Ramb0> What is High order? In some pages it says that if a function takes a function as an argument, or returns a function, it is High Order, then.. Any currified function is high order, am i wrong?
21:29:12 <Makoryu> JoeyA: "a -> b -> c" is the same as "a -> (b -> c)"
21:29:19 <ezyang> Ramb0: Yeah, strictly almost alll Haskell functions are higher order
21:29:22 <tensorpudding> In Haskell, functions all take only one input, and they may return a function, which operates on additional inputs through currying
21:29:30 <ville> JoeyA: the short version is that it's a function taking an 'a' and a 'b' and returns a 'c'
21:29:37 <ezyang> tensorpudding: Not quite: (a,b) -> c ;-)
21:29:52 <Makoryu> ezyang: Well, that tuple is a single input :p
21:29:59 <ezyang> It's true.
21:30:05 <tensorpudding> A type a -> b -> c  intuitively means that it takes inputs a and b, to return c, or that it takes a and returns a function that when given b, will return c.
21:30:11 <Makoryu> :t map (+1)
21:30:12 <lambdabot> forall a. (Num a) => [a] -> [a]
21:30:12 <JoeyA> Ah
21:30:12 <Cale> Ramb0: The order of a non-function type is 0, and the order of a -> b is max(order(a) + 1, order b)
21:30:13 <Veinor> oh hey it's an ezyang
21:30:17 <ezyang> oh hai
21:30:39 <Cale> Ramb0: "higher order" generally refers to functions of order 2 or larger
21:30:52 <Cale> So, functions which take other functions as parameters
21:30:59 <Veinor> yeah
21:31:03 <JoeyA> So when you say `f a b c d e`, it's actually expanding `f a` first; `f a` is a function in its own right.  Correct?
21:31:04 <Veinor> so map is higher-order, (+) is not
21:31:10 <Cale> JoeyA: yeah
21:31:11 <Veinor> correct.
21:31:11 <Makoryu> JoeyA: Yup!
21:31:23 <Cale> It means ((((f a) b) c) d) e
21:31:23 <Veinor> it's just (((((f a) b) c) d) e)
21:31:24 <tensorpudding> Sometimes when explaining type variables I miss ML's use of quoting...
21:31:39 <Cale> tensorpudding: quoting?
21:31:44 <Cale> You mean like 'a ?
21:31:47 <tensorpudding> Yeah.
21:32:00 <tensorpudding> Since they don't have the restriction that types have to start with capital letters.
21:32:07 <Cale> right
21:32:22 <tensorpudding> but it makes type variables easier to parse in an English sentence.
21:32:47 <JoeyA> let f x y z = x+y+z
21:32:48 <JoeyA> :t f
21:32:49 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
21:33:04 <JoeyA> f :: (Num a) => a -> a -> a -> a
21:33:11 <Makoryu> Someone ought to write a nice, clean language somewhere in between OCaml and Haskell
21:33:12 <JoeyA> That I don't understand.
21:33:18 <Ramb0> Cale: So, (+) is not higher order? Strictly talkin, what is higher order?
21:33:27 <elbar> > 1+1
21:33:28 <lambdabot>   2
21:33:34 <tensorpudding> @type (+)
21:33:35 <lambdabot> forall a. (Num a) => a -> a -> a
21:33:51 <tensorpudding> (+) forces all the inputs to have the same type (all instances of Num)
21:33:53 <Makoryu> JoeyA: The "(Num a) =>" part?
21:34:01 <Cale> Ramb0: Well, I gave a formal definition there...
21:34:01 <JoeyA> Why isn't it something like f -> a -> b -> c -> Num ?
21:34:05 <Makoryu> JoeyA: It's a typeclass requirement
21:34:22 <augur> heyo
21:34:24 <tensorpudding> JoeyA: that would be too polymorphic
21:34:28 <Cale> Num isn't a type, it's a typeclass to which types may belong
21:34:30 <augur> anyone know much about Felleisen's continuation work?
21:34:44 <tensorpudding> What would True + (Just ()) + (+10) be?
21:34:59 <tensorpudding> You can't meaningfully add booleans to numbers.
21:35:01 <Cale> The constraint (Num a) constrains the type variable 'a' to only range over types which are instances of Num
21:35:05 <Ramb0> Cale: So, if a function returns a function, but takes only ONE argument, it is not high order?
21:35:16 <matt_m> augur: which?
21:35:27 <Cale> Ramb0: But only takes arguments which aren't functions
21:35:30 <JoeyA> So what does the => operator mean in a type specification?
21:35:34 <JoeyA> Does it have precedence over -> ?
21:35:43 <augur> matt_m: late 80s?
21:35:44 <tensorpudding> That's why there is a typeclass that says "all these things are numbers, and hence implement (+), (-), (*), etc."
21:35:45 <Ramb0> Yes
21:35:49 <Ramb0> Ok Cale , Thanks :)
21:35:52 <Cale> JoeyA: It has lower precedence than ->
21:36:11 <matt_m> augur: Like the CPS stuff?
21:36:16 <augur> i suppose
21:36:23 <Cale> JoeyA: and it means "apply the typeclass constraints to my left to the variables in the signature to my right"
21:36:49 <Makoryu> JoeyA: "f :: (Num a) => a -> foo -> b" means "f :: a -> foo -> b, where 'instance Num a' is imported from somewhere"
21:36:50 <dolio> order (a -> b) = (1 + order a) `max` order b ; order _ = 0
21:36:50 <ManateeLazyCat> When i do "cabal haddock", I got "doc comment parse failed: ...", is i write something wrong in documentation that make haddock failed? Or haddock bug?
21:36:53 <Cale> JoeyA: So, you know what length :: [a] -> Int  means, yeah?
21:36:56 <matt_m> augur:  Did you have a specific question?  Or just generally asking?
21:36:57 <tensorpudding> (Num a) => means that every time a appears in the signature, a must implement Num.
21:37:01 <Cale> JoeyA: Consider a function which sorts a list
21:37:07 <augur> matt_m: i was just introduced to it indirectly via a paper by barker and shan on types as graphs/continuations in natural language
21:37:18 <Cale> JoeyA: You might at first think that perhaps it would have type  sort :: [a] -> [a]
21:37:27 <augur> matt_m: well, i was looking for someone to talk to about it. just to discuss it.
21:37:32 <Cale> JoeyA: But it turns out that not just *any* type a will work
21:38:05 <tensorpudding> Don't almost all built-in types implement Ord?
21:38:06 <Cale> JoeyA: We need a to be a type which has the ordering operations defined: (<) and so on
21:38:11 <matt_m> augur:  I may know something - really won't know until you start talking :)
21:38:15 <Cale> tensorpudding: Functions, IO, etc.
21:38:22 <augur> matt_m: so as far as i understand it
21:38:26 <Cale> tensorpudding: Oh, and Complex numbers
21:38:30 <tensorpudding> Ah, right.
21:38:31 <Makoryu> > map < fmap
21:38:32 <lambdabot>   No instance for (GHC.Classes.Ord ((a -> b) -> [a] -> [b]))
21:38:32 <lambdabot>    arising from ...
21:38:46 <tensorpudding> Well, if you assume the well-ordering theorem :P
21:38:49 <Makoryu> > () <= ()
21:38:50 <lambdabot>   True
21:38:54 <Cale> JoeyA: So there's a typeclass, called Ord, which defines those operations:
21:38:55 <danharaj> Computable ordering :p
21:38:57 <Cale> class Ord a where
21:39:03 <Cale>   (<) :: a -> a -> Bool
21:39:09 <Cale>   ... other operations ...
21:39:29 <Cale> and we can write sort in terms of those operations, and it gets the type  sort :: (Ord a) => [a] -> [a]
21:40:18 <augur> what he has is basically a system in which you can use like, f :: a -> b, in place of some actual a
21:40:23 <JoeyA> Now what if we said sort :: (Ord a) => (Ord b) => [a] -> [b] ?
21:40:32 <Cale> Which means that for any type a for which there is an instance defining the operations in the Ord class, we can apply sort to a list of values of that type, and get another list of values of the same type
21:41:03 <Cale> JoeyA: ah, that would mean that while both types had orderable values, the result type of sort could be any other type
21:41:05 <tensorpudding> It would mean that you could implicitly change the type of the elements of your list to anything.
21:41:08 <augur> no thats not what it is sorry
21:41:14 <Veinor> JoeyA: well, the syntax is (Ord a, Ord b) => [a] -> [b]
21:41:25 <Veinor> but it turns out that you can't write a meaningful function that has that type
21:41:28 <Cale> JoeyA: So, for instance, we could apply sort to a list of Strings and get a list of Integers if that were its type
21:41:29 <JoeyA> does the one I used work as well?
21:41:34 <augur> its f :: (a -> b) -> c in place of an a
21:41:37 <Cale> (since both String and Integer have instances of Ord)
21:41:53 <danharaj> Typeclasses are in vague ways similar to classes with virtual methods in C++.
21:41:53 <tensorpudding> It implicitly requires you to be able to cast a type to any other type.
21:42:02 <matt_m> augur:  Continuations are usually Cont a = (a->r)->r
21:42:05 <augur> e.g. f g = g(2) + g(3)    in side   1 + f
21:42:08 <Cale> JoeyA: It's impossible to write such a function, since Ord doesn't define any operations which produce an arbitrary value of a type in Ord
21:42:11 <JoeyA> Although (Ord a, Ord b) => ... is more terse, does (Ord a) => (Ord b) => ... work too?
21:42:19 <Cale> (at least, such a function which does anything useful)
21:42:26 <danharaj> Cale, a monotonic function?
21:42:28 <Cale> It shoudl
21:42:30 <Cale> should*
21:42:30 <Veinor> you can write a total function that does that!
21:43:02 <Cale> hmmm
21:43:05 <Veinor> it's called const []
21:43:05 <tensorpudding> You can't change something of a completely polymorphic type to something else of a completely polymorphic type.
21:43:21 <danharaj> If the typeclass was of order isomorphic types...
21:43:24 <baguasquirrel> ?type const
21:43:25 <lambdabot> forall a b. a -> b -> a
21:43:25 <Cale> :t fromIntegral :: (Integral a) => (Num b) => a -> b
21:43:26 <lambdabot> parse error on input `=>'
21:43:26 <tensorpudding> For example, you can set a = (), and b = Bool
21:43:28 <danharaj> but in general, no you can't really do that naturally.
21:43:33 <danharaj> Or rather, parametrically.
21:43:34 <Cale> ah, nope, it doesn't parse
21:43:54 <JoeyA> @type (+)
21:43:55 <lambdabot> forall a. (Num a) => a -> a -> a
21:44:02 <Cale> :t fromIntegral :: (Integral a) => ((Num b) => a -> b)
21:44:03 <lambdabot> forall a b. (Num b, Integral a) => a -> b
21:44:04 <augur> matt_m: can you give me an incredibly awesome example of how this would be /useful/?
21:44:07 <tensorpudding> Actually, that could be realized, but any function that implemented it couldn't by polymorphic.
21:44:33 <Cale> JoeyA: That says that (+) takes two numbers of the same type, and produces a number of that type.
21:44:43 <JoeyA> ah, makes sense
21:44:44 <Cale> JoeyA: (so, no implicit conversion)
21:44:46 <augur> i mean, in terms of quantification i can totally see yeah this could be useful, right
21:44:53 <Veinor> where 'number' is defined (in part) by 'something that you can add'
21:45:14 <danharaj> Num is so ugly.
21:45:19 <augur> 1 + (every xs) > 5 ===> every xs (\x -> 1 + x > 5)
21:45:21 <JoeyA> Cale> What if one's an Int and the other's a Float ?
21:45:23 <augur> yeah i could see that
21:45:24 <Veinor> the math prelude is a bunch of hacks
21:45:29 <Cale> JoeyA: Then you will get a type error
21:45:30 <Veinor> JoeyA: then it fails to compile
21:45:36 <matt_m> augur:  Well, continuations are useful for suspending computations
21:45:37 <Veinor> > (2 :: Int) + (5.0 :: Float)
21:45:38 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:45:38 <lambdabot>         against inferred type ...
21:45:41 <Cale> > (5 :: Int) + (pi :: Float)
21:45:42 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:45:42 <lambdabot>         against inferred type ...
21:45:52 <Cale> > 5 + pi
21:45:53 <lambdabot>   8.141592653589793
21:46:03 <Veinor> ghc is nice and will autoconvert numeric literals for you
21:46:08 <Cale> :t 5
21:46:09 <danharaj> oh god there's implicit conversions from int?
21:46:09 <lambdabot> forall t. (Num t) => t
21:46:17 <JoeyA> Why does 3 + 4.5 work?
21:46:18 <Makoryu> danharaj: Nope, just overloaded literals
21:46:19 <Cale> danharaj: No implicit conversions :)
21:46:24 <Makoryu> JoeyA: Overloaded literals
21:46:26 <JoeyA> oh
21:46:27 <danharaj> But you just said 5 :: int
21:46:28 <Cale> Numeric literals are polymorphic
21:46:33 <danharaj> Int*
21:46:38 <Cale> :t 3.5
21:46:39 <lambdabot> forall t. (Fractional t) => t
21:46:41 <Veinor> danharaj:  the (5 :: Int) examples didn't compile
21:46:44 <Makoryu> > (5 :: Int) + pi -- danharaj, this diesn't work
21:46:45 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
21:46:45 <lambdabot>    arising from a use of...
21:46:47 <Cale> :t pi
21:46:48 <danharaj> oh.
21:46:48 <lambdabot> forall a. (Floating a) => a
21:46:51 <Makoryu> s/die/doe/
21:46:52 <danharaj> Word I am tired
21:47:00 <danharaj> also covariant derivatives are hurting my head.
21:47:05 <JoeyA> :t (+)
21:47:06 <baguasquirrel> yea, that's why sometimes you have to explicitly type them
21:47:06 <lambdabot> forall a. (Num a) => a -> a -> a
21:47:09 <matt_m> augur:  It can allow you to invert the way that you write code
21:47:10 <tensorpudding> 3 + 4.5 works because it will default 3 to a Floating type
21:47:17 <JoeyA> What is the forall a. for?
21:47:20 <tensorpudding> @type 3
21:47:20 <lambdabot> forall t. (Num t) => t
21:47:23 <augur> matt_m: right, but are they any great examples of why this is a good thing?
21:47:24 <tensorpudding> @type 4.5
21:47:24 <lambdabot> forall t. (Fractional t) => t
21:47:30 <baguasquirrel> sometimes you want rationals, for example, because IEEE floats suck
21:47:32 <tensorpudding> 3 has a strictly more polymorphic type than 4.5
21:47:34 <matt_m> augur:  Like if you're writing some networking code that deals with a communication between two parties
21:47:39 <Cale> Numeric defaulting will try to pick the first of a list of types which fits, (the default list is (Integer, Double), but can be set by a default declaration if you ever wanted to change that)
21:47:43 <Makoryu> JoeyA: It basically indicates that "a" is a type variable
21:47:49 <JoeyA> On my system (GHC 6.10.4), I don't have the forall
21:47:53 <matt_m> augur:  You might like to write code that looks linear from each point of view
21:47:59 <tensorpudding> JoeyA: it's a universal quantification, that says "this works for all a, subject to the listed constraints"
21:48:07 <Cale> JoeyA: Yeah, if you turn on certain extensions, it will start printing it
21:48:08 <danharaj> It's implicit
21:48:12 <matt_m> augur:    Connect, Verify password, Send some data, etc...
21:48:15 <danharaj> in regular haskell
21:48:21 <Makoryu> JoeyA: As someone said earlier, lambdabot has some extensions enabled to change the way that type signatures are printed
21:48:38 <Cale> Not just to do that, but also to do other useful things.
21:48:41 <JoeyA> Is there a thereexists?  What would it mean?
21:48:52 <JoeyA> (in a type definition)
21:48:53 <tensorpudding> so if you have "forall a. (Ord a) => [a] -> [a]", it says "for every a, which is able to be ordered, we have a function that will reorder the list without changing the elements"
21:48:53 <danharaj> Abstract datatypes :p
21:49:00 <matt_m> augur:  With continuations you can arrange for a lower layer to be suspending this code, doing network communications, and then running the continuation once new data is available
21:49:17 <matt_m> augur:  Rather than having all of that flow control tangled into your high level stuff
21:49:25 <augur> hm.
21:49:30 <augur> example? :P
21:49:32 <Cale> JoeyA: Not in Haskell. It would mean that there exists some type for which that signature was the type of the value, but we don't know what it is.
21:49:36 <augur> i need to see code to really get it
21:49:43 <matt_m> augur:  heh, I thought I just gave one :)
21:49:45 <baguasquirrel> JoeyA, I believe Agda has them...  there was a talk on it at the BA Haskell meeting
21:49:52 <matt_m> augur:  I don't know your background well enough to know what's a good example for you
21:49:58 <baguasquirrel> they're interesting in a constructivist sense
21:50:21 <tensorpudding> JoeyA: there are existential types in Haskell, but they are more advanced and available by turning on a GHC extension.
21:51:00 <augur> matt_m: meh. its ok, dont worry
21:51:16 <matt_m> augur:  I think you'll find good examples if you think about things that need to be suspended
21:51:19 <Cale> JoeyA: For example, a value of type exists t. (t, t -> t, t -> String), would be a triple, holding a value of unknown, arbitrary type t, a function t -> t (which could then be applied to the function), and a function t -> String
21:51:25 <danharaj> I wonder if there are type quantfiers for certain modal logics?
21:51:27 <JoeyA> Is it possible to redefine the < operator to sort with another function?
21:51:32 <Veinor> Cale: can't you do ExistentialTypes?
21:51:35 <matt_m> augur:  Blocking on networking / communications is a common one
21:51:39 <tensorpudding> JoeyA: you can use sortBy
21:51:42 <tensorpudding> @type sortBy
21:51:43 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
21:51:53 <baguasquirrel> hunh, this is interesting...   http://www.haskell.org/haskellwiki/Existential_type
21:51:55 <augur> matt_m: i dont do network/comms so
21:51:57 <Cale> If we had such a triple (x,f,g), we could write g (f (f x)) for instance, and that would be a well-typed String, but g and f would be the only things which we could apply to x
21:51:57 <Veinor> JoeyA: if you come up with a new type, you get to pick how they compare
21:52:00 <augur> its all magic to me ;)
21:52:00 <tensorpudding> it's a function that takes an ordering function of type (a -> a -> Ordering)
21:52:04 <matt_m> augur:  What do you do?
21:52:08 <Makoryu> > sortBy (>) [1..10]
21:52:08 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
21:52:09 <lambdabot>         against inferr...
21:52:18 <Makoryu> Ohhh
21:52:20 <Cale> Veinor: Yeah, but it doesn't make 'exists' into valid syntax, and doesn't give you first class existentials
21:52:29 <Veinor> yeah, > gives you a boolean, not an ordering
21:52:41 <Makoryu> Veinor: Yeah, realized that right as I hit return
21:52:42 <augur> matt_m: a hodgepodge of database development and linguistics :p
21:52:48 <JoeyA> What's wrong with it?
21:52:55 <Cale> JoeyA: wrong with what?
21:53:01 <JoeyA> sortBy (>) [1..10]
21:53:04 <tensorpudding> (>) doesn't have the right type to be used by sortBy
21:53:09 <matt_m> augur:  You do monads?
21:53:12 <tensorpudding> it returns a Bool, not an Ordering
21:53:22 <Veinor> yeah
21:53:24 <matt_m> augur:  Monads are essentially standardized continuation passing
21:53:31 <matt_m> (sort of)
21:53:31 <Cale> Ah, yeah, sortBy takes a function of type  a -> a -> Ordering
21:53:33 <augur> matt_m: ooooh interesting
21:53:46 <danharaj> call/cc is monadic
21:53:53 <Makoryu> :t compare -- JoeyA
21:53:53 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
21:53:56 <JoeyA> I guess an Ordering is an enumeration of 3 values?
21:53:56 <Cale> Where the values of type Ordering are  LT, EQ, and GT  (for "less than", "equal" and "greater than")
21:54:01 <Cale> yeah
21:54:04 <JoeyA> ah
21:54:07 <Makoryu> @hoogle Ordering -> Ordering
21:54:07 <lambdabot> Prelude pred :: Enum a => a -> a
21:54:07 <lambdabot> Prelude succ :: Enum a => a -> a
21:54:07 <lambdabot> Prelude id :: a -> a
21:54:15 <Makoryu> :|
21:54:28 <Cale> Makoryu: what are you looking for?
21:54:39 <matt_m> augur:  I have to go :)
21:54:45 <Makoryu> Cale: Nothing now, actually :p
21:54:46 <matt_m> goodnight
21:54:50 <Makoryu> > sort (flip compare) [1..10]
21:54:51 <lambdabot>   Couldn't match expected type `[a]'
21:54:51 <lambdabot>         against inferred type `a1 -> a1 ...
21:54:54 <Makoryu> D'OH
21:54:59 <Cale> :t compare EQ
21:54:59 <lambdabot> Ordering -> Ordering
21:55:04 <tensorpudding> > sortBy compare [5,3,2,6,1]
21:55:05 <lambdabot>   [1,2,3,5,6]
21:55:13 <augur> matt_m: aww. ok bye <3
21:55:13 <Cale> > sortBy (flip compare) [1,2,3,4,5]
21:55:13 <Makoryu> > sort (flip compare) [1..10] :: [Int]
21:55:13 <lambdabot>   Couldn't match expected type `[a]'
21:55:14 <lambdabot>         against inferred type `a1 -> a1 ...
21:55:14 <lambdabot>   [5,4,3,2,1]
21:55:20 <Makoryu> Oh right
21:55:28 <tensorpudding> that's just the default sorting
21:55:28 * Makoryu headdesks
21:56:29 <Cale> > sortBy (comparing length `mappend` compare) (words "here is a list of words to be sorted by length and then alphabetically")
21:56:29 <lambdabot>   ["a","be","by","is","of","to","and","here","list","then","words","length","...
21:56:31 <JoeyA> Can I define a lambda in-line (e.g. between sortBy and the array)
21:56:31 <JoeyA> ?
21:56:33 <tensorpudding> sortBy (comparing fst) [(1,5),(5,1),(3,2),(7,1),(3,9)]
21:56:36 <Cale> JoeyA: yes
21:56:37 <tensorpudding> err.
21:56:40 <tensorpudding> > sortBy (comparing fst) [(1,5),(5,1),(3,2),(7,1),(3,9)]
21:56:41 <lambdabot>   [(1,5),(3,2),(3,9),(5,1),(7,1)]
21:56:43 <Cale> *list
21:56:56 <tensorpudding> > sortBy (comparing snd) [(1,5),(5,1),(3,2),(7,1),(3,9)]
21:56:57 <lambdabot>   [(5,1),(7,1),(3,2),(1,5),(3,9)]
21:57:10 <Cale> You can make an array from a list by using the array or listArray function
21:57:23 <Makoryu> The hell?
21:57:26 <Makoryu> :t mappend
21:57:26 <lambdabot> forall a. (Monoid a) => a -> a -> a
21:57:37 <Makoryu> :t comparing length
21:57:38 <lambdabot> forall a. [a] -> [a] -> Ordering
21:57:45 <Cale> > array (0,9) [(k,k^2) | k <- [0..9]]
21:57:46 <lambdabot>   array (0,9) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,...
21:57:48 <tensorpudding> Turning a list to an array would require O(n) right?
21:57:51 <Cale> yeah
21:57:52 <JoeyA> How do you extract elements from tuples?
21:58:00 <tensorpudding> fst and snd
21:58:02 <Makoryu> JoeyA: 1) Pattern matching
21:58:06 <tensorpudding> for pairs
21:58:07 <Cale> JoeyA: for pairs, you can use the fst and snd functions, but usually pattern matching
21:58:11 <Makoryu> 2) If it's a 2-tuple, use fst or snd
21:58:11 <tensorpudding> otherwise pattern matching
21:58:20 <Makoryu> 3) More pattern matching
21:58:27 <Makoryu> 4) Seriously, go with pattern matching
21:58:29 <Cale> @let squares = array (0,9) [(k,k^2) | k <- [0..9]]
21:58:30 <lambdabot>  Defined.
21:58:31 <tensorpudding> > let x = (5,3) in (snd x, fst x)
21:58:32 <lambdabot>   (3,5)
21:58:36 <Cale> > squares ! 5
21:58:37 <lambdabot>   25
21:58:48 <Cale> ^^ array access is constant time
21:59:06 <Makoryu> :t array
21:59:07 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
21:59:07 <theorbtwo> > squares ! 12345
21:59:08 <lambdabot>   *Exception: Error in array index
21:59:11 <Cale> whereas walking down to the kth element of a list takes k steps
21:59:17 <c_wraith> can I just double-check something...  head normal form != normal form, right?
21:59:29 <Cale> c_wraith: right
21:59:38 <Makoryu> c_wraith: I'm pretty sure normal form == fully evaluated
21:59:47 <c_wraith> that matches what I expect.
21:59:50 <tensorpudding> JoeyA: By the way, are you following a tutorial or book for Haskell?
21:59:56 <Makoryu> Whereas head normal form just has the outermost "layer" evaluated
22:00:06 <c_wraith> bos: I think the documentation for criterion uses "head normal form" when it actually means "normal form"
22:00:15 <JoeyA> sortBy (\x -> \y -> compare (fst x) (fst y)) [(1,2),(0,5)] yielded [(0,5),(1,2)]
22:00:16 <JoeyA> Woot :)
22:00:28 <Cale> c_wraith: A term is in head normal form if it is a constructor applied to some arguments, or if it is an unapplied lambda whose body is in normal form.
22:00:37 <JoeyA> I was reading http://www.cs.chalmers.se/Cs/Grundutb/Kurser/nptah/del1/nutshell.html , but I started getting curious and came here :)
22:00:44 <Makoryu> :t \x -> \y -> compare (fst x) (fst y)
22:00:45 <lambdabot> forall b a b1. (Ord a) => (a, b) -> (a, b1) -> Ordering
22:00:48 <Makoryu> :t comparing fst
22:00:49 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
22:01:00 <Makoryu> Huhhhhhh.
22:01:04 <Makoryu> Oh right
22:01:10 <c_wraith> Cale: That matches my understanding.  But it's not what's in the docs for criterion, so I wanted to double-check before I told bos he made a mistake :)
22:01:11 <JoeyA> I guess \ means lambda because it's the closest ASCII character that looks like a lambda?
22:01:16 <Makoryu> JoeyA: Yup
22:01:25 * danharaj wating on a language in latex
22:01:26 <Cale> c_wraith: note that to put something in normal form or head normal form, you have to evaluate underneath a lambda, which is rare in real implementations of programming languages
22:01:35 <Makoryu> By the way, "\x -> \y -> ..." == "\x y -> ..."
22:01:42 <Makoryu> @ JoeyA
22:01:45 <Cale> c_wraith: Instead, weak head normal form or weak normal form are more common
22:01:45 <tensorpudding> That page looks really out-of-date, unfortunately.
22:01:56 <Cale> (especially WHNF)
22:02:05 <tensorpudding> Though H98 is still perfectly valid Haskell today.
22:02:12 <kmc> danharaj, ghc lets you use unicode for a lot of syntax.  the problem is, Î» is a lower-case letter, so it should be an identifier, not a special character
22:02:13 <c_wraith> Cale: yes, I do know this.  the function that puts things in normal form in criterion has an NFData constraint, which covers that. :)
22:02:36 <kmc> danharaj, also lhs2TeX will format your Haskell code into LaTeX with fancy characters
22:02:42 <Cale> c_wraith: yeah, it probably really puts them into weak normal form :)
22:02:46 <kmc> Coq and Fortress have something similar, iirc
22:02:50 <Cale> c_wraith: but that's the best you can do :)
22:02:52 <JoeyA> Wow, I guessed sortBy (\(a,b) -> \(c,d) -> compare a c) [(1,2),(0,5)] , and it actually worked :)
22:02:58 <kmc> :t compare `on` fst
22:03:00 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
22:03:00 <tensorpudding> Fortress is that Sun Fortran-like isn't it?
22:03:07 <Makoryu> @src comparing
22:03:07 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:03:07 <Cale> :t comparing fst
22:03:08 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
22:03:12 <Makoryu> @hoogle comparing
22:03:12 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
22:03:33 <kmc> @djinn (b -> a) -> b -> b -> Ordering
22:03:33 <lambdabot> Error: Undefined type Ordering
22:03:53 <JoeyA> Does ghci have a command for printing brief documentation of a function?
22:03:54 <Makoryu> :t [comparing fst, compare `on` fst]
22:03:55 <lambdabot> forall a b. (Ord a) => [(a, b) -> (a, b) -> Ordering]
22:03:56 <tensorpudding> Hoogle/Hayoo are good resources for finding documentation for functions
22:04:01 <JoeyA> (other than the type signature)
22:04:23 <Makoryu> JoeyA: I think :info is the best you'll be able to do in ghci
22:04:25 <tensorpudding> Unfortunately ghci doesn't hook into haddock
22:04:26 <Makoryu> Which is a shame
22:04:30 <JoeyA> ah
22:04:39 <Makoryu> So instead, :!haddock blah etc
22:05:12 <tensorpudding> Haddock is Haskell's documentation system, and barring the fact that it doesn't work with GHCi is very useful.
22:05:13 <SubStack> :t sin . floor
22:05:14 <lambdabot> forall a a1. (Floating a, RealFrac a1, Integral a) => a1 -> a
22:05:36 <SubStack> is there a way I can introspect that there are no instances in the environment that satisfy both Floating and Integral?
22:06:09 <tensorpudding> Using Hayoo, you can enter the name of a function, or a portion of a type signature, and it will provide results which match your query, that you can click and go to the part of the Haddock documentation where it is.
22:06:30 <tensorpudding> @where hayoo
22:06:30 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
22:07:24 <tensorpudding> Hmm, is hayoo down...
22:07:29 <cdsmithus> I'm about decide that it's NOT possible to define a newtype wrapper that makes Data.Binary do on-the-fly encoding/decoding.  Or am I wrong there?  Unless there's some kind of trick with the lookahead functions...
22:08:11 <JoeyA> In Haskell, is it possible to dissect a function's composition?  e.g. seeing if there's a (+) inside of f x y = x+y at runtime
22:08:21 <c_wraith> JoeyA: no
22:08:23 <SubStack> cdsmithus: you could write your own monad on top of the get and put binary stuff probably
22:09:00 <tensorpudding> man, why is hayoo down..
22:09:16 <cdsmithus> SubStack: How would you envision that working?  Especially the Get part is what's tripping me up
22:09:19 <SubStack> JoeyA: short answer: No. correct answer: well maybe
22:09:30 <SubStack> (but I wouldn't)
22:10:33 <SubStack> cdsmithus: are you doing binary serialization for interactive send/recv?
22:10:35 <JoeyA> I think traversal of a function's composition tree would be a very powerful language feature; it'd be possible to implement truly algebraic functions.
22:10:50 <SubStack> JoeyA: see lisp
22:11:00 <blackdog> JoeyA: It's hard to do in a typed language, but look at Bondi
22:11:14 <cdsmithus> SubStack: Yes, trying to implement this bizarre network protocol
22:11:29 <blackdog> JoeyA: I don't think it's available in a mainstream-ish FPL
22:11:30 <SubStack> cdsmithus: been there
22:11:46 <cdsmithus> SubStack: Which has now decided that these variable-length packets should have long sequences of zeros run-length encoded on top of everything else
22:11:47 <SubStack> JoeyA: if you really want, there's haskell-src
22:12:09 <JoeyA> If I'm not mistaken, algebra (if applied to all types) is undecidable in general, correct?
22:12:26 <JoeyA> In order to solve more and more algebra problems, you need more and more code.
22:12:37 <SubStack> cdsmithus: http://github.com/substack/hs-network-rfb/blob/master/src/Network/RFB.hs is what I did, solving a similar problem
22:12:52 <JoeyA> Suppose you import a library that tells the programming language how to solve a larger class of constraint problems.
22:12:55 <SubStack> not especially elegant but it does the trick
22:13:09 <JoeyA> You use it to solve problems, but you don't even mention the library's name.  Is there a name for this concept?
22:13:18 <JoeyA> (other than the import line)
22:13:24 <kmc> JoeyA, you can do it for custom data types, in a way
22:13:36 <cdsmithus> SubStack:  Thanks!  Reading...
22:14:21 <kmc> JoeyA: data Exp = Lit Integer | Add Exp Exp; instance Num Exp where { fromIntegral = Lit; (+) = Add }
22:14:23 <SubStack> cdsmithus: the runPut and runGet sections especially
22:14:36 <andrewsw> blackdog: thanks... ghc-mod works great. g'night
22:14:41 <kmc> now you can write ((1+2)+3) to mean Add (Add (Lit 1) (Lit 2)) (Lit 3)
22:14:52 <blackdog> andrewsw: delighted to hear it:)
22:15:08 <kmc> this is a usual trick for embedded domain-specific languages
22:17:09 <cdsmithus> SubStack: You know the sizes in advance?  You seem to parameterize GetBytes with it
22:19:36 <SubStack> cdsmithus: yeah with that protocol you always have fixed sizes or else a byte telling you how long the message is
22:20:15 <SubStack> s/byte/integer/
22:25:43 <cdsmithus> SubStack: Hmm... I'm being tripped up by the combination of variable length messages that basically have to be parsed to even find out how long they are, and then that's on top of this RLE stuff... and to make it even more fun, the RLE stuff stops right at the end of the message, and then I have to grab some more data afterward that's *not* run length encoded.
22:26:36 <SubStack> sounds crazy!
22:26:57 <SubStack> rfb (vnc's protocol) is pretty unsurprising
22:28:01 <SubStack> sounds like a job for some even crazier level of abstraction
22:28:42 <Ramb0> @src all
22:28:42 <lambdabot> all p =  and . map p
22:38:08 <nniro> I tried kmc's "data Exp = Lit Integer | Add Exp Exp; instance Num Exp where { fromIntegral = Lit; (+) = Add }" for fun but ghci gave me an error : `fromIntegral' is not a (visible) method of class `Num', how can we fix that?
22:39:36 <ClaudiusMaximus> @info Num
22:39:36 <lambdabot> Num
22:39:48 <ClaudiusMaximus> :t fromInteger
22:39:48 <lambdabot> forall a. (Num a) => Integer -> a
22:39:58 <ClaudiusMaximus> think that's the one in Num
22:40:50 <nniro> ClaudiusMaximus: so I need to hide the one in prelude for it to work?
22:40:52 * hackagebot http-wget 0.6.1 - Provide a simple HTTP client interface by wrapping the wget  command line tool.  http://hackage.haskell.org/package/http-wget-0.6.1 (MichaelSnoyman)
22:41:56 <DigitalKiwi> that is retarded
22:41:58 <iaefai> I am having some issue with an lhs file where it gives me a parse error on the very first line of main. Which is line 29 at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25352#a25352   There is nothing weird about this file as far as I can tell. It has mostly > in previous code segments but the main is done with \begin{code}. Is there any way of determining what is really the problem?
22:42:09 <DigitalKiwi> who came up with that crap? (the wget thing)
22:42:10 <Ramb0> @src foldl
22:42:10 <lambdabot> foldl f z []     = z
22:42:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:43:05 <DigitalKiwi> if you're going to use a wget like program in a language other than bash use libcurl, gosh >.>
22:43:17 <DigitalKiwi> heck even in bash use curl >.>
22:44:04 <iaefai> Once I found out about curl -O it was set :p
22:48:01 <iaefai> A smart one has entered.
22:49:07 <JoeyA> In GHCi, how can I define a function's type signature and definitions?  When I say `let mean :: [Num] -> Num`, it says `The type signature for `mean' lacks an accompanying binding`
22:49:45 <Cale> JoeyA: you could follow it with a semicolon and the rest of the definition
22:49:52 <Cale> Note that Num is not a type though
22:49:53 <kmc> let foo :: T; foo = bar
22:49:56 <Cale> So you can't write that
22:50:18 <kmc> mean :: (Num a) => [a] -> a
22:50:42 <Cale> also, if mean does what I think it does, then Num won't be enough. You'll want to divide
22:50:53 <Cale> So you'll need a Fractional type
22:51:20 <JoeyA> I'm reading http://www.cs.chalmers.se/Cs/Grundutb/Kurser/nptah/del1/nutshell.html, and it has `sum :: [Int] -> Int`
22:51:22 <JoeyA> Is it in the wrong?
22:51:39 <JoeyA> Is that supposed to be sum :: (Int a) => [a] -> a  ?
22:51:48 <Cale> nope, that's fine, though the Prelude's sum is  (Num a) => [a] -> a
22:51:53 <Cale> Int is a type, Num is a class
22:51:58 <Cale> Integer is also a type
22:52:04 <Cale> and Float, and Double
22:52:08 <Cale> Those are all instances of Num
22:53:06 <Cale> [Int] -> Int means that their sum takes only a list of values of type Int, and produces an Int
22:53:12 <nniro> kmc: the code you pasted earlier : "data Exp = Lit Integer | Add Exp Exp; instance Num Exp where { fromIntegral = Lit; (+) = Add }" for JoeyA doesn't seem to work as is, it raises an error in ghci that fromIntegral is not part of Num. ClaudiusMaximus told me to use fromInteger instead but I can't seem to get it to work, I get other errors.
22:53:34 <kmc> err yeah i meant fromInteger
22:53:51 <kmc> i'm sure it's not a full example
22:53:53 <kmc> just showing the idea
22:54:28 <kmc> it's missing some members of Num
22:54:51 <JoeyA> So in `let mean :: (Num a) => [a] -> a; mean x = (sum x) / (length x)`, why does Fractional need to get involved?
22:54:56 <JoeyA> Why can't you divide a Num ?
22:54:57 <kmc> :t (/)
22:54:58 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:55:01 <kmc> JoeyA, that's why
22:55:10 <kmc> some, but not all, types in Num have (/) defined
22:55:20 <kmc> the ones that do are precisely the types in Fractional
22:55:21 <Cale> Some types of numbers can't be divided with (/)
22:55:26 <kmc> for example, Int
22:55:27 <ski> JoeyA : because `/' is for exact (or close to, for float) division
22:55:30 <kmc> > (2 :: Int) / 3
22:55:30 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
22:55:31 <lambdabot>    arising from a use o...
22:55:32 <kmc> > (2 :: Int) `div` 3
22:55:33 <lambdabot>   0
22:55:34 <kmc> :t div
22:55:35 <lambdabot> forall a. (Integral a) => a -> a -> a
22:55:39 <ski> JoeyA : `div' is for integral (rounding) division
22:55:45 <JoeyA> ah
22:55:49 <Cale> Integer division is a separate operation, and requires an instance of Integral
22:56:15 <ClaudiusMaximus> nniro: you probably want to add "deriving (Eq, Show)" to the data definition, and maybe some others are needed for Num to work
22:56:20 <Cale> (this way, there's no way to confuse which of the two you're using)
22:56:23 <ski> JoeyA : also, `sum :: [Int] -> Int' is a special case of `Num a => [a] -> a', so the former is not wrong, it is just not as general as the actual `Prelude' definition of `sum'
22:56:51 <JoeyA> Makes sense
22:57:10 <JoeyA> Is it possible to list all the types and classes matching a given class?
22:57:17 <blackdog> JoeyA: use hoogle
22:57:25 <JoeyA> !hoogle Num
22:57:30 <kmc> @instances Num
22:57:31 <lambdabot> Double, Float, Int, Integer
22:57:40 <kmc> ^^^ but this is just some arbitrary database lambdabot has, iirc
22:57:46 <ville> JoeyA: are you familiar with the now removed concepts feature of the new C++ standard?
22:57:48 <kmc> in GHCi, :info Num
22:58:09 <JoeyA> Not really.  I guess it means you can annotate any type with a name?
22:58:19 <JoeyA> So you can classify them.
22:58:31 <ville> JoeyA: Ok nevermind me then.
22:58:32 <JoeyA> You might call `int` Dividable, Addable, Subtractable, etc.
22:58:39 * ski waits for ville to ask about Java interfaces or abstract classes
22:58:43 <JoeyA> and char* Segfaultable
22:58:46 <kmc> hehe
22:58:50 <kmc> we call that Storable ;)
22:58:56 <JoeyA> lol
22:59:08 <nniro> ClaudiusMaximus: cool thanks, I was able to make it compile (a few undefined here and there eheh)
22:59:12 <ville> ski: I was going to explain to him how type classes relate to the concepts feature of C++.
22:59:13 <kmc> when you ask for classes matching a class, i'm not sure what you'd mean
22:59:50 <ville> ski: if I recall right JoeyA also programs C++, at least I recall him from ##C++.
22:59:53 <kmc> classes have instances, which are types, and methods, which are values (or "families" of values parametrized by a type, if you like)
22:59:54 <JoeyA> I figured there'd be a hierarchy of some sort.  I guess it's just a mapping from one class to many types, right?
23:00:03 <kmc> correct
23:00:07 <kmc> a class is basically a set of types
23:00:11 <JoeyA> And there can (and certainly) be overlap.
23:00:14 <kmc> Num is the set of "all types with (+)"
23:00:16 <kmc> yeah
23:00:30 <JoeyA> @classes Int
23:00:30 <lambdabot> Unknown command, try @list
23:00:33 <kmc> there is a hierarchy in one sense: a class (like Num) can require that every type in that class is already in some other class (like Eq)
23:00:41 <JoeyA> ah
23:00:50 <kmc> but there's not a "containment" hierarchy
23:00:56 <JoeyA> How do I list all the classes an Int is associated with?
23:01:03 <kmc> :i Int
23:01:04 <kmc> in ghci
23:01:22 <kmc> note that it'll depend on what modules are loaded
23:02:35 <kmc> :i is a general "info" command that's useful for several purposes
23:02:37 <JoeyA> Just curious: if Haskell programs tend to be terse compared to programs in other languages, why is the ghci base install 40 megabytes or so?
23:02:41 <JoeyA> Lots of libraries?
23:02:59 <gleenn> terseness != small libraries  maybe
23:03:00 <kmc> because the relationship between binary size and source code size is not constant over languages?
23:03:12 <kmc> in fact terseness == large libraries, largely
23:03:19 <JoeyA> hmm
23:03:30 <kmc> a small amount of Haskell compiles to a lot of machine code
23:03:38 <kmc> or did you find some 40 MB source archive?
23:03:40 <Pseudonym> GHC wastes space.
23:03:42 <JoeyA> sort of like C++ templates
23:03:54 <kmc> well, like any high-level language
23:04:01 <tensorpudding> Haskell is dense in its own way.
23:04:03 <kmc> the correspondence between Haskell and machine code is pretty indirect
23:04:35 <kmc> also like most compilers, GHC optimizes for speed, not size by default
23:04:37 <ski> ville : ok
23:04:49 <kmc> and may include e.g. several copies of a function specialized to particular types, for speed
23:05:14 <tensorpudding> GHC creates heavy code that is optimized for speed but not size.
23:06:12 <kmc> also, i don't think C++ should be used as a pedagogical example for anything ;P
23:06:15 <JoeyA> Hypothetically speaking, if GHC just interpreted the code rather than expanding it out like that, would it be really small?  (e.g. 500K)
23:06:18 <kmc> unless you are teaching a class on language design
23:06:33 <kmc> a pure Haskell interpreter could be a fairly small program
23:06:43 <kmc> you can install Hugs and see how big the binary is
23:06:44 <monochrom> hugs is an interpreter and very small
23:06:54 <heller> hi
23:06:57 <ski> libraries would take up space in source code, as well
23:06:59 <kmc> any system for executing Haskell still has to do a lot of nontrivial things
23:07:02 <heller> monochrom: is it still in development?
23:07:06 <JoeyA> My impression of C++ as a powerful language is:  It can do a lot, but nothing I want it to do.
23:07:11 <monochrom> I don't know.
23:07:21 <kmc> hi heller
23:07:33 <tensorpudding> C++ has lots of features, but it's not really powerful.
23:07:46 <kmc> of course it is
23:07:52 <kmc> you can implement tuples! in only five thousand lines of code!
23:08:08 <kmc> you can implement a parser combinator library in a piddling 100,000 lines of code
23:09:03 <teratorn> but you can implement remote code execution in only one line!
23:09:34 <kmc> hehe
23:09:50 <blackdog> teratorn: you can have buffer overflows in haskell too, if you try really hard...
23:10:04 <kmc> yeah
23:10:06 <tensorpudding> Who was C++ designed for?
23:10:11 <kmc> tensorpudding, everyone
23:10:13 <kmc> and that's the problem
23:10:16 <kmc> part of it, anyway
23:10:28 <tensorpudding> It wasn't designed for people who liked sanity though.
23:10:42 <tensorpudding> Or people who wanted a language with higher-level features.
23:10:44 <blackdog> it's bacon and chocolate and peanut butter and whisky all at once
23:11:01 <kmc> haha
23:11:05 <JoeyA> Does Haskell have a crippled stack?  By that, I mean a stack with limited space compared to allocation.
23:11:11 <heller> i need a little guidance here with my haskell excercise ... the task was to write the function mirrorx :: (Float -> Float) -> (Float -> Float) I currently have this: http://codepad.org/eeUV5iMf  but it gives me: mirrorx :: (Num a) => (t -> a) -> t -> a how do i get this right?
23:11:18 <kmc> JoeyA, Haskell makes no mention of stacks
23:11:23 <blackdog> JoeyA: whee, there's a loaded question:)
23:11:37 <kmc> Haskell implementations may or may not have a stack
23:11:59 <JoeyA> Prelude Data.List> let f x = (f x)+1
23:11:59 <JoeyA> Prelude Data.List> f 3
23:11:59 <JoeyA> *** Exception: stack overflow
23:12:05 <kmc> JoeyA, if you're asking "Can a program compiled with GHC abort with a 'stack overflow' error", the answer is "yes".
23:12:18 <kmc> that's not a property of Haskell, though
23:12:24 <kmc> it's a property of how GHC implements Haskell
23:12:34 <tensorpudding> f x = (f x) + 1 isn't really going to work in any language
23:12:50 <kmc> tensorpudding, works fine in Haskell with peano naturals
23:13:12 <kmc> (for certain reasonable though odd definition of (+))
23:13:13 <JoeyA> In C, sometimes you have to make code non-recursive so it allocates on the free store instead of the stack.
23:13:33 <kmc> JoeyA, the Haskell spec guarantees that tail calls can be made in constant space
23:13:48 <JoeyA> (although often nonr)
23:13:50 <JoeyA> bah
23:14:14 <JoeyA> although often, the non-recursive algorithm may not allocate memory as it runs (by cheating in some other way)
23:14:15 <kmc> JoeyA, but the meaning of tail recursion under lazy evaluation is a bit different than under strict evaluation
23:14:26 <JoeyA> Building an AST with Node *parent; links is an example.
23:14:34 <blackdog> unfortunately, quite often something that would be tail recursive in Scheme may build up a big chain of thunks in haskell if you're not careful
23:14:43 <kmc> yeah
23:14:52 <kmc> @src foldl'
23:14:52 <lambdabot> foldl' f a []     = a
23:14:52 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:15:01 <ski> JoeyA : pointer-reversals is another
23:15:06 <kmc> a typical pattern in Haskell is tail recursion with explicit forcing of an accumulator argument, as in foldl'
23:15:11 <tensorpudding> Haskell's lazy evaluation is one of the more confusing aspects of the language.
23:15:37 <JoeyA> So in C, one has to avoid recursion when the depth depends on untrusted user input (unless it's logarithmic or something).
23:15:54 <monochrom> not confusing. unfamiliar.
23:15:55 <kmc> by church-rosser, lazy eval is not confusing until you care about performance
23:15:55 <JoeyA> Does this matter to Haskell programmers that much?
23:15:59 <kmc> then it is quite confusing
23:16:06 <blackdog> JoeyA: not really.
23:16:14 <kmc> JoeyA, different things matter
23:16:33 <iaefai> > kmc: you can implement tuples! in only five thousand lines of code!  <-- classic :p
23:16:33 <lambdabot>   <no location info>: parse error on input `in'
23:16:34 <blackdog> you need to know that your recursive function has the right strictness properties
23:16:51 <iaefai> guten nacht
23:17:37 <kmc> JoeyA, see the foldl' example above.  it's tail-recursive, which is not a problem; the spec guarantees this is constant-space
23:18:07 <kmc> but you're in danger of another problem with the accumulator argument a, which is what the "seq" there fixes
23:18:17 <kmc> (and in more modern GHC-specific haskell we might use a bang pattern)
23:19:13 <kmc> the problem there is that you might do
23:19:58 <kmc> foldl (\x v -> x+1) 0
23:20:00 <kmc> as a "length" function
23:20:11 <kmc> and you might end up with an accumulator like (1 + 1 + 1 + 1 + ...)
23:20:15 <tomberek> can't make data, type, or newtype declarations in ghci?
23:20:20 <kmc> tomberek, correct
23:20:39 <tomberek> gar-taak!
23:20:40 <kmc> JoeyA, and this "thunk" of additions will take up lots of space, even though the recursive stack frames for foldl don't
23:21:10 <kmc> because until you ask for the result, no addition occurs
23:21:14 <kmc> "seq" is used to force eager evaluation of that accumulator argument, avoiding the problem
23:21:20 <kmc> which is the difference between foldl and foldl'
23:21:22 <kmc> makes sense?
23:21:55 <JoeyA> let mean :: (Fractional a) => [a] -> a; mean x = (sum x)/(length x) -- `Couldn't match expected type `a' against inferred type `Int' `
23:22:08 <JoeyA> I can't cast length x to Fractional because that's not a type
23:22:19 <Cale> JoeyA: You can use fromIntegral
23:22:33 <ski> JoeyA : `length' returns an `Int' (silly, yes), use `fromIntegral' to convert it
23:22:50 <ski> @type fromIntegral
23:22:50 <JoeyA> "<tomberek> gar-taak!"  Klingon?
23:22:51 <lambdabot> forall a b. (Integral a, Num b) => a -> b
23:23:01 <Cale> (fromIntegral will turn a number of any integral type (like Int, Integer, Word32, etc.) into any numeric type at all (including fractional ones).
23:23:16 <ski> each type `a' in `Fractional' is also in `Num', so this will work in your case
23:25:40 <JoeyA>  let mean :: (Fractional a) => [a] -> a; mean x = (sum x)/(fromIntegral (length x)) -- Ka`Plah!
23:25:50 <JoeyA> Thanks
23:26:19 <ski> JoeyA : btw, you don't need the outer brackets on the sides of the division -- application binds tighter than (almost) anything else
23:26:29 <ski> @type genericLength
23:26:30 <lambdabot> forall b i. (Num i) => [b] -> i
23:26:34 <ski> @type genericTake
23:26:34 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
23:26:49 <ski> interesting how `Num' rather than `Integral' is used in the first
23:27:39 <shu> can i somehow hide instances?
23:27:48 <ski> no
23:27:52 <shu> dang
23:28:12 <kmc> JoeyA, you typically don't cast in Haskell at all.  you convert.
23:28:13 <nniro> kmc: just to make sure, giving the earlier Exp data declaration, this would be tail recursive? : calculate :: Exp -> Integer; calculate (Lit a) = a; calculate (Add a b) = let a' = calculate a; b' = calculate b in a' `seq` b' `seq` a' + b'
23:28:30 <ski> JoeyA : .. alternatively, you constrain
23:28:32 <shu> parsec3 by default defines an instance of Stream for ByteString that uses Char8 uncons, and i'd rather that it use UTF8 uncons
23:28:38 <kmc> nniro, it's not tail recursive
23:28:57 <kmc> but it won't blow up in a tree of thunks
23:29:00 <ski> > cast (4 :: Int) :: Maybe Double  -- a Haskell cast :)
23:29:01 <lambdabot>   Nothing
23:29:02 <kmc> these are separate properties
23:29:32 <kmc> "cast" means "check or assume that this value already has that type"
23:29:38 <kmc> not "convert this value to that type in a canonical way"
23:29:42 <kmc> C uses the term to mean both, though
23:29:59 <nniro> kmc: how would you write it to be tail recursive though?
23:29:59 <kmc> arguably erroneously
23:30:04 <kmc> nniro, you wouldn't
23:30:19 * ski uses "cast" only in the "check" sense (well, also in the unsafe "trust me" sense)
23:31:10 <kmc> nniro, you'd have to put it into the form "f x = let .... in f y"
23:32:21 <nniro> kmc: ahh and then simply use foldl' or whatever to do the work
23:32:33 <kmc> nniro, well no, it's recursive
23:33:08 <JoeyA> "<kmc> foldl (\x v -> x+1) 0"
23:33:22 <JoeyA> So in this case, lazy evaluation stabs you in the back?
23:33:30 <JoeyA> (by storing a tree of additions rather than doing them)
23:33:40 <kmc> right
23:34:02 <kmc> nniro, the "f y" there is a tail call because, once you get to that point, you can forget about the invocation of "f x".  you know the result will be whatever you get from "f y" and there's no extra work left to be done
23:34:05 <JoeyA> Why does it do that?
23:34:16 <kmc> whereas, if the call were "f y + 1", that's not a tail call; you have to remember to come back here and add one
23:34:36 <kmc> the typical trick to make things tail-recursive (that you learn in SICP or wherever) is to add an extra "accumulator" arg
23:34:38 <kmc> so instead of saying
23:34:47 <kmc> f x = let .... in f y + 1
23:34:57 <kmc> you say f a x = let .... in f (a+1) y
23:35:19 <kmc> JoeyA, because that's what lazy evaluation does?
23:35:32 <kmc> it will not do the work of adding stuff until you ask for the result
23:35:41 <nniro> kmc: hmm actually I'm pretty familiar with tail recursion but I'm having trouble to figure it with the data type in the example
23:35:55 <kmc> yeah.  i don't think you can tail-recursively evaluate an expression tree like that
23:36:23 * monochrom whispers "continuation passing style"
23:36:31 <kmc> hmm monochrom has a point ;)
23:38:01 <JoeyA> Other than memory usage and interaction with the stateful world, does lazy evaluation affect the semantics of the programming language?
23:38:10 <kmc> yes
23:38:19 <kmc> and it doesn't have much to do with interaction with the stateful world
23:38:37 <kmc> because we don't confuse evaluation with execution
23:38:41 <kmc> but that's a separate issue
23:39:08 <kmc> it affects the semantics.  specifically, "lazy evaluation" is the name for one particular strategy for implementing "non-strict semantics", which are distinct from the "strict semantics" of most languages
23:39:13 <kmc> the simple example is
23:39:25 <kmc> f True x y = x; f False x y = y
23:39:46 <kmc> now consider the call (f True 3 (1/0))
23:39:54 <kmc> will give a divide-by-zero error under strict semantics
23:39:57 <kmc> not so in Haskell
23:40:08 <kmc> similarly (f True 3 (error "blow up")) or anything else that raises an exception
23:40:30 <JoeyA> ah
23:40:31 <kmc> any expression which evaluates without error under strict semantics will evaluate without error under non-strict, and give the same value
23:40:56 <kmc> in that sense it is a generalization
23:41:03 <c_wraith> There might be some cost in memory use if you're not careful, though
23:41:07 <kmc> yes
23:41:20 <kmc> all of this is denotational semantics only... what the value is, not how you get there
23:42:07 <kmc> you know how in most languages, boolean operators like && and || have this magical "short-circuiting" property, which no user-defined function does?
23:42:17 <kmc> in Haskell all functions have that property
23:42:17 <JoeyA> Yes
23:42:40 <JoeyA> Consider executing a formal grammar (producing strings, not parsing).  We're given a start string, and two separate sets of production rules.
23:43:16 <JoeyA> Give me a moment to figure out how to phrase this question.
23:44:40 <JoeyA> Well, to set the stage, we execute the first set of production rules until we have a string of terminal symbols.  Now, we execute the second set, but some of the "terminal" symbols are now regarded as nonterminal.
23:45:01 <JoeyA> I'm not sure I have a question, actually (composition would suffice to describe this scenario)
23:48:54 <JoeyA> Well, continuing:  suppose the semantics of our program are ambiguous, allowing the second set of rules to be executed before all of the first ones are done (but once we execute a second set, we can't turn back).
23:49:46 <JoeyA> In other words, the first set of rules has a terminating condition, but we can interrupt with the second set.
23:50:30 <JoeyA> In Haskell, is it possible for lazy versus strict evaluation to make a distinction here?
23:50:41 <kmc> no
23:50:45 <kmc> not unless you cheat
23:50:51 <JoeyA> The distinction being that with strict evaluation, the first set of rules must be followed up to a terminating condition before moving on to the second set.
23:51:05 <JoeyA> Is this where monads come in?
23:51:07 <kmc> if both lazy and strict evaluation conclude without error, they must produce the same value
23:51:25 <kmc> i think what you're describing does not have much to do with lazy vs. strict evaluation
23:52:19 <kmc> a grammar describes a *set* of strings which is the result of all *possible* sequences of applying rules
23:52:57 <kmc> you can write a Haskell function to take a description of a grammar and produce a list of all strings it can generate
23:53:03 <JoeyA> Our example program would randomly follow production rules
23:53:06 <monochrom> @quote monochrom problems
23:53:06 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
23:53:23 <c_wraith> @quote monochrom monad
23:53:24 <lambdabot> monochrom says: Monad is about postmodernism. There are laws but no one owns them. You can interpret them any way you want. You can write about your own understanding and the meaning of your writing
23:53:24 <lambdabot> is not fixed.
23:53:28 <kmc> JoeyA, right.  in Haskell there is no value v which evaluates to a random choice between, say, 0 and 1
23:53:29 <JoeyA> (is that even possible in Haskell, since the random function is intrinsically non-functional)
23:53:31 <c_wraith> @quote monochrom monad
23:53:32 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
23:53:32 <lambdabot> entire human race would have to be rewritten!
23:53:39 <kmc> that is, evaluation is a deterministic relation
23:53:44 <c_wraith> Hmm.  I know the quote you're trying to find.
23:53:52 <c_wraith> Why is \bot picking all those other ones?
23:54:06 <blackdog> c_wraith: now you have three problems?
23:54:20 <c_wraith> I have 99 problems, and apparently a bot is one.
23:54:23 <kmc> JoeyA, what you can do is write a "recipe" for getting a random value, and compose it with other "recipes" for what to do once you've got it
23:54:45 <kmc> evaluation is still deterministic.  a recipe is an inert value; evaluating it is not very interesting and doesn't actually generate randomness, perform IO, etc.
23:55:08 <kmc> but the recipes also serve as input to this other system which does something called "execution"
23:55:12 <kmc> execution is not the same as evaluation
23:55:49 <blackdog> c_wraith: dammit, now i want to listen to jay-z and i don't have a copy
23:56:18 <JoeyA> Now I have a simpler question:  Is there a random function in Haskell at all?
23:56:28 <c_wraith> yes.
23:56:39 <kmc> JoeyA, yes, but the return value is not a number
23:56:42 <c_wraith> There are many options, even
23:56:42 <monochrom> @quote monochrom analog
23:56:42 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
23:56:43 <kmc> it's a recipe for picking a number
23:56:50 <monochrom> @quote monochrom analog.*
23:56:50 <lambdabot> No quotes match. Just try something else.
23:56:55 <kmc> in the case of randomRIO
23:56:57 <kmc> :t randomRIO
23:56:58 <lambdabot> forall a. (Random a) => (a, a) -> IO a
23:57:17 <kmc> JoeyA, takes two values (lower and upper bounds of a range).  returns an IO-recipe that, when executed, produces a random value in that range
23:57:25 <kmc> this is perhaps the simplest interface to random numbers in Haskell
23:57:31 <kmc> :t randomIO
23:57:32 <lambdabot> forall a. (Random a) => IO a
23:57:41 <kmc> there's the simpler version which uses an implicit range of the whole type
23:57:47 <kmc> note that it's not a function
23:57:55 <monochrom> @quote <monochrom>
23:57:56 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
23:57:59 <kmc> for the same reason getChar is not a function
23:58:01 <kmc> it has no arguments
23:58:06 <JoeyA> What if I want the evaluation order of a program to be based on a random number?  Do I use a recipe?
23:58:07 <kmc> it's *just* a recipe for doing IO
23:58:20 <kmc> you probably don't want that
23:58:41 <kmc> but there are ways to explicitly force terms to evaluate as a "recipe step"
23:59:11 <JoeyA> What if the possible execution paths are exponential with respect to the number of random bits?  (as in the case of expanding production rules)
23:59:27 <kmc> what if
23:59:37 <JoeyA> Will lazy evaluation cause a combinatorial explosion in memory?
23:59:46 <kmc> no
