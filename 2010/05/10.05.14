00:27:43 <Rectal> Hello
00:28:05 <Pseudonym> Greetings.
00:28:18 <Rectal> I am running a program to calculate moves for a game of reversi. I am getting a Prelude.maximum: Empty List
00:28:33 <Pseudonym> Do you understand what that means?
00:28:48 <glguy> > maximum []
00:28:49 <lambdabot>   *Exception: Prelude.maximum: empty list
00:28:52 <Rectal> I am using Windows Command Prompt, with Prelude, is there any way to check what equation, or part of the program is running into the problem?
00:29:08 <Pseudonym> Well, it's obviously a call to maximum, though it might be indirect.
00:29:16 <Pseudonym> Like, maximum is called from somewhere.
00:29:59 <Axman6> Rectal: i'm guessing you're at ANU?
00:30:01 <Rectal> An empty list means no moves in this case, and pretty sure there should always be a move
00:30:05 <Rectal> Yes
00:30:21 <Rectal> Darn minimax
00:31:01 <Axman6> well, just so you know, homework questions (and for the assignment) won't be answered here, but things like what you just asked are fine
00:31:21 <Axman6> just for full disclosure, i'm one of the 1100 tutors
00:31:26 <copumpkin> lol
00:31:27 <Rectal> I know
00:31:33 <Rectal> Ivan told me last time I was in here asking for help
00:31:40 <Rectal> He helped me, just not in any way I could use
00:31:43 <Axman6> ok, good. i thought i'd seen you here before, but thought i'd make sure :)
00:31:51 <Rectal> But eventually with trial and error and help from another tutor I got it
00:31:56 * copumpkin wonders what Rectal's nick is about
00:32:04 <Rectal> After I got greedy, everything seemed to click with the game tree
00:32:10 <Rectal> Rectal Exambot from Futuraam
00:32:25 <Rectal> Futurama*
00:32:40 <Rectal> a 1 line reference, but enough for me to use
00:32:55 <Saizan> if you've an explicit call to maximum in your code you could wrap it with trace
00:33:03 <Saizan> ?type Debug.trace
00:33:04 <lambdabot> Couldn't find qualified module.
00:33:23 <Saizan> ?type Test.Debug.trace
00:33:24 <lambdabot> Couldn't find qualified module.
00:33:24 <Xichekolas> trace :: String -> a -> a
00:33:26 <Xichekolas> hehe
00:33:31 <Axman6> i wouldn't use trace
00:33:43 <Xichekolas> ?type Debug.Trace
00:33:44 <lambdabot> Couldn't find qualified module.
00:33:52 <Xichekolas> er, well that is the module anyway
00:34:04 <Pseudonym> Trace is like lard.  It's for special occasions only.
00:34:13 <Rectal> Sorry to ask here, but Axman, what compiler should I use for Java on a Windows Platform?
00:34:36 <Rectal> If I wanted to try some before my next prac?
00:34:39 <Axman6> the sun one i believe. look for the JDK for windows (i think)
00:34:40 <Xichekolas> eh, it's the printf of the haskell world, sometimes you gotta make sausages
00:36:10 <Pseudonym> No, printf makes sense in release code sometimes.
00:36:12 <copumpkin> :t printf
00:36:13 <Pseudonym> trace does not
00:36:13 <lambdabot> forall r. (PrintfType r) => String -> r
00:37:02 <Xichekolas> very true... I should amend... "it's the printf debugging of the haskell world"
00:43:39 <Axman6> Rectal: i think that if you can't guarantee that you won't be giving maximum an empty list, rolling your own function mightn't be a bad idea, at least for this assigtnment
00:45:52 <ivanm> preflex: seen dons
00:45:52 <preflex>  dons was last seen on #haskell 4 days, 4 hours, 59 minutes and 57 seconds ago, saying: i'm guessing ddarius is thinking of ddata.
00:48:22 <Rectal> Its funny, my program makes moves, almost in random, and Greedy always wins
00:48:43 <Xichekolas> what game?
00:49:14 <Xichekolas> oh reversi
00:50:11 <Rectal> Yes
00:50:30 <Rectal> 1 that looks 1 move ahead, the other can look up to 8 moves ahead
00:50:59 <Rectal> I have atleast 1 problem, I could maybe fix that, just gotta figure out how
00:51:20 <ivanm> Rectal: you're not asking for homework help are you? :p
00:52:20 <Rectal> Ivan, I am up to annotating the tree an minimax
00:52:42 <Rectal> Currently if you add an odd depth it gives you the correct annotation, but even, it just whines
00:52:47 <Rectal> Looking into that currently
01:30:25 <CirceTheSorcere1> :t ()
01:30:26 <lambdabot> ()
01:30:50 <dolio> :k 1
01:30:50 <lambdabot> *
01:38:58 <wto> 2
01:39:00 <wto> oops
01:39:14 <ivanm> yeah, it's meant to be 3, not 2! :p
01:42:16 <MrFenix> I just took a look at http://www.haskell.org/haskellwiki/HStringTemplate .. I think escapeHtmlString should use replace from Data.Text.Lazy. Am I missing something or should I change the example?
02:17:06 <d-snp> hey guys
02:17:34 <d-snp> they haskell-tutorial on h.org/learning has a weird construct, maybe someone can explain it a bit to me
02:18:10 <d-snp> (:) :: a -> [a] -> [a]
02:18:20 <d-snp> and you use it as
02:18:26 <d-snp> 1 : 2 : 3 : []
02:18:32 <d-snp> which is totally weird?
02:18:36 <systemfault> See the part after :: ?
02:19:01 <d-snp> yes
02:19:03 <systemfault> The last [a] is the return type
02:19:26 <luite> d-snp: it might help if you add parentheses, you should read that as 1 : ( 2 : ( 3 : [] ) ) )
02:19:36 <luite> oh one ) too many, sorry
02:19:52 <systemfault> > 1:2:3:[4,5,6]
02:19:53 <lambdabot>   [1,2,3,4,5,6]
02:20:18 <systemfault> It just prepends an element to a list.
02:20:28 <d-snp> I know what it does, but I don't get why :P
02:20:37 <d-snp> like, why does the : go between two arguments
02:20:52 <dolio> d-snp: (:) is how you refer to infix functions. You put parentheses around them.
02:21:02 <d-snp> why is it not : 1 (: 2(: 3 []))
02:21:08 <dolio> x : y = (:) x y
02:21:13 <systemfault> > (:) 1 [2, 3]
02:21:13 <lambdabot>   [1,2,3]
02:21:20 <d-snp> ok
02:21:20 <systemfault> That's prefix.
02:21:29 <systemfault> > 1:[2, 3]
02:21:30 <lambdabot>   [1,2,3]
02:21:38 <dolio> You can also section them.
02:21:51 <dolio> (:) x y = (x :) y = (: y) x
02:22:14 <systemfault> Yeah.. but that might confuse him more..
02:22:48 <dolio> You can turn functions with alphanumeric names into infix operators by putting them between backquotes, as well.
02:23:00 <dolio> f x y = x `f` y
02:23:13 <d-snp> so a -> [a] -> [a] means it returns a lambda which takes an [a] and returns an [a] right?
02:23:13 <systemfault> > 10 `div` 2
02:23:14 <lambdabot>   5
02:23:20 <systemfault> d-snp: Forget lambdas.
02:23:25 <d-snp> forgotten
02:23:33 <d-snp> a function then?
02:23:57 <systemfault> It's means, it take a "a" and a [a] and returns a [a]
02:24:07 <luite> hehe
02:24:23 <systemfault> "a" can be anything
02:24:45 <d-snp> so why is it not )"_ :: (a, [a]) -> [a]
02:24:49 <systemfault> (I wish the signature would use w right now..)
02:24:49 <d-snp> woops
02:24:57 <d-snp> so why is it not (:) :: (a, [a]) -> [a]
02:25:15 <c_wraith> because it's curried
02:25:27 <dolio> If it had that type, you'd have to call it like (:) (x,y)
02:25:33 <silver> it means function takes a and returns function which takes [a] and returns [a], where a is type variable
02:25:36 <dolio> And that's no fun.
02:25:39 <d-snp> but currying means a lambda/function whatever was returned in between right?
02:25:57 <silver> something like that
02:26:12 <systemfault> d-snp: It means that in reality.... there's no such thing as a function taking two parameters
02:26:47 <d-snp> ok I can live with that
02:27:03 <silver> (a, [a]) -> [a] is boring
02:27:08 <systemfault> > (+1) 2
02:27:09 <lambdabot>   3
02:27:10 <silver> that means no partial application
02:27:14 <silver> and stuff
02:27:18 <systemfault> See how (+1) is a function?
02:28:26 <dolio> d-snp: Lambda is just a notation for writing down function literals.
02:28:38 <dolio> Like 5 is an Integer literal, and you wouldn't call integers fives. :)
02:29:03 <dolio> At least, I wouldn't.
02:29:04 <systemfault> > (\x y z -> x + y * z) 1 2 3
02:29:05 <lambdabot>   7
02:30:00 <systemfault> I <3 Haskell
02:30:05 <d-snp> :P
02:30:05 <MrFenix> my proposal for a new escapeHtmlString on http://www.haskell.org/haskellwiki/HStringTemplate : http://pastebin.com/anGqmy84
02:30:16 <silver> > map ((\x y z -> x + y * z) 1 2) [1..10]
02:30:17 <lambdabot>   [3,5,7,9,11,13,15,17,19,21]
02:33:47 <heropass> oops, I forgot to log out.
02:33:59 <dolio> > let showHOF2 :: (forall a. Num a => a -> a) -> String ; showHOF2 f = "\\x -> " ++ show (f x) in showHOF2 (\x -> x * x - x)
02:33:59 <lambdabot>   "\\x -> x * x - x"
02:34:10 <dolio> > let showHOF2 :: (forall a. Num a => a -> a) -> String ; showHOF2 f = "\\x -> " ++ show (f x) in text $ showHOF2 (\x -> x * x - x)
02:34:11 <lambdabot>   \x -> x * x - x
02:35:29 <Mark___> @type mapS
02:35:30 <lambdabot> Not in scope: `mapS'
02:35:33 <d-snp> thanks for the help guys :)
02:37:08 <Mark___> @type Data.Array.Parallel.Stream.mapS
02:37:09 <lambdabot> Couldn't find qualified module.
02:37:19 * hackagebot hamlet 0.2.3 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.2.3 (MichaelSnoyman)
03:09:26 <sleepyMonad> how do I get the underlying package? ghci -v gives "package network-2.2.1.7-a0d9047b52fd6b4e290c02afb19a386a is shadowed by package network-2.2.1.7-c66ac9b62dd872fd838c38803fbbb4f7"
03:10:21 <Cale> sleepyMonad: It's usually a bad idea to have two copies of the same package installed -- particularly so when they're the exact same version
03:10:30 <Cale> Is there a good reason that you need that?
03:10:57 <sleepyMonad> they got downloaded automatically with cabal
03:11:01 <Cale> mmm
03:11:12 <Cale> Is one of them installed globally and the other as user?
03:11:32 <Cale> Perhaps do a ghc-pkg list and see whether it's in both places
03:12:10 <Cale> You may want to try at least hiding one of the two with ghc-pkg hide, if not removing with ghc-pkg unregister
03:12:54 <sleepyMonad> yep got a user level and a system level one
03:12:58 <Cale> It seems weird that cabal would automatically install a copy of network when it was already present.
03:13:25 <Cale> dcoutts would know better than I would about why these things happen (I think)
03:14:29 <ivanm> sleepyMonad: which version of parsec do you have installed?
03:15:07 <ivanm> I'm guessing your system version of network uses parsec-3, and then you tried to cabal install something that wants parsec-2
03:15:30 <sleepyMonad> I see I have also 2 parsec versions: 2.1.0.1 on system level and  3.1.0 on user level
03:15:46 <ivanm> OK, vice versa
03:16:41 <Cale> Oh, subtle.
03:17:17 <sleepyMonad> would installing with cabal as root overwrite the system version? (and solve the problem)
03:17:20 <Cale> Does network actually expose any of its usage of parsec in its interface?
03:17:30 <ivanm> doubt it
03:17:35 <Cale> sleepyMonad: Usually I avoid that.
03:17:44 <ivanm> but ghc-pkg doesn't make any distinction between internal deps and re-exposed deps
03:18:01 <Cale> I install GHC globally, and then everything else as user.
03:18:33 <Cale> (that way, if things get messed up, I shouldn't have to reinstall GHC at least)
03:18:56 <sleepyMonad> yeah, i try to keep the system setup clean as well, but in this case I don't really know what I'm dong, so a quick easy fix is tempting
03:19:47 <Cale> I don't have a system-level copy of network somehow.
03:20:17 <sleepyMonad> (this is ubuntu 10.04)
03:20:35 <ivanm> Cale: it's not part of ghc, so if you only install stuff locally...
03:20:38 <Cale> Ah, I also don't use Ubuntu's packages for any Haskell stuff.
03:21:24 <Cale> sleepyMonad: Maybe try  (sudo) ghc-pkg --global hide network
03:21:43 <Cale> That at least won't do any permanent damage, you can always expose it again.
03:21:44 <Twey> @src String show
03:21:45 <Twey> y
03:21:45 <lambdabot> Source not found. Maybe you made a typo?
03:22:10 <Twey> Urgh, laggy connection
03:22:11 <sleepyMonad> the network pakcage comes from the ubuntu package libghc6-network-dev
03:22:28 <Twey> Can I see the source of such functions anywhere?
03:22:41 <Cale> Twey: How to print strings is encoded in the instance of Show for Char -- see the showList function.
03:22:54 <Twey> Ah, obviously
03:22:55 <Cale>     showList cs = showChar '"' . showl cs
03:22:55 <Cale>                  where showl ""       = showChar '"'
03:22:55 <Cale>                        showl ('"':cs) = showString "\\\"" . showl cs
03:22:55 <Cale>                        showl (c:cs)   = showLitChar c . showl cs
03:23:01 <Twey> It wasn't actually String I was looking for, though
03:23:09 <Twey> @src Float show
03:23:09 <lambdabot> Source not found. :(
03:23:22 <Twey> That's the one.
03:24:26 <Cale> The Report defines show for Float in terms of Numeric.showFloat
03:24:36 <Cale> and provides an implementation here: http://haskell.org/onlinereport/numeric.html
03:25:23 <Cale> It's in terms of a function called formatRealFloat, which is somewhat involved to say the least.
03:26:01 <Twey> Ooh.
03:26:16 <Twey> Crikey.  I think that's the longest Haskell function I've ever seen.
03:26:31 <Cale> another option is to go to the Haddock and click the source link
03:26:53 <Cale> formatRealFloat still exists in the same(?) form though
03:27:33 <Twey> I was looking for the Haddock on Hackage, but I didn't find it
03:27:58 <ivanm> Twey: which function?
03:28:08 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/index.html
03:28:20 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Numeric.html#v%3AshowFloat
03:28:22 <sleepyMonad> cale: thanks for the suggestion; will try either hiding the haskell package, or uninstalling the ubuntu package after estimating the damage done by each option. But I have to go know (kids)
03:28:24 <ivanm> oh, the show instance for Strings
03:28:37 * hackagebot vacuum-ubigraph 0.2.0.0 - Visualize Haskell data structures using vacuum and Ubigraph  http://hackage.haskell.org/package/vacuum-ubigraph-0.2.0.0 (GlebAlexeyev)
03:28:41 <Cale> ivanm: Nah, for Floats
03:28:53 <ivanm> ahhhh
03:28:53 <Cale> (though he asked about String at first)
03:29:04 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-Float.html#showFloat
03:29:16 <Twey> Ca	Ah, thanks
03:29:33 <Cale> -- Based on "Printing Floating-Point Numbers Quickly and Accurately"
03:29:34 <Cale> -- by R.G. Burger and R.K. Dybvig in PLDI 96.
03:29:34 <Cale> -- This version uses a much slower logarithm estimator. It should be improved.
03:30:25 <Twey> Yeah.  I found that.  Interestingююю шы ерфе ф ищщл,
03:30:31 <Cale> Ah, I think that refers to floatToDigits
03:30:42 <Twey> 'Interesting... is that a book?'** sorry
03:31:00 <Cale> PLDI sounds like the name of a conference
03:31:29 <Cale> Conference on Programming Language Design and Implementation (PLDI)
03:32:05 <Twey> http://www.sigplan.org/pldi.htm aaaand it stops the year before the one I want :-P
03:33:53 <Cale> http://www.cs.indiana.edu/~burger/FP-Printing-PLDI96.pdf
03:37:55 <Cale> (let ( q-r (quotient-remainder r s)]) (let ( d (car q-r )] r (cdr q-r )]) ...  -- It's so easy to forget how awesome pattern matching is until it's unavailable.
03:38:55 <Twey> Cale: Heheh, aye.
03:39:57 <systemfault> Eww
03:41:33 <Cale> I just noticed that r gets shadowed there too.
03:42:58 <Twey> Bah.  It doesn't seem to want to be loaded by this college computer and its Acrobat Reader.
03:43:17 <Cale> It was converted from dvi
03:44:28 <Cale> There's something a little weird about the way that the text is anti-aliased on my machine, but it otherwise displays under Evince.
03:44:37 <Twey> This connection really is terribly bad today.  I can't even save the link.  I guess I'll have to scour my IRC logs for it when I get home.
03:45:07 <Cale> Just google the name of the paper
03:45:42 <Twey> No, it's a 'File IO' error.  No idea exactly what the problem is.  I'll give it a go later.  thanks for the help, as usual :)
03:45:56 <triyo> I am trying to get local ver of hoogle working via Emacs. I run haskell-hoogle and when I query, it pops up a browser with query to hoogle online version. Apparently there is a way to get the local hoogle qury show up in the emacs buffer. Any ideas?
03:46:01 <Cale> I mean when you get home
03:46:09 <Cale> (If that's any easier)
03:46:49 <triyo> OH sorry, I think I got it...
03:47:29 <triyo> it says I need to build hoogle via darcs first, which makes sense...I did, just need to add it to add it $PATH
03:47:29 <Cale> Twey: here's a slightly different version. Also produced by some convoluted sequence of conversions it appears, but it might be better: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.7596&rep=rep1&type=pdf
03:47:43 <Vitka> If I have function that just return constant, can I use it in pattern-matching somehow?
03:47:56 <Vitka> returns constant I mean.
03:48:13 <Cale> Vitka: You're only allowed to pattern match against data constructors
03:48:39 <Vitka> Damn.
03:48:40 <Cale> anything whose name begins with a lowercase letter in a pattern is treated as the name of a variable to be bound
03:49:07 <Cale> You might appreciate the view patterns extension though
03:49:24 <Vitka> Can you give me a link?
03:49:44 <Cale> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
03:50:01 <Vitka> Thanks.
03:54:53 * hackagebot vacuum-ubigraph 0.2.0.1 - Visualize Haskell data structures using vacuum and Ubigraph  http://hackage.haskell.org/package/vacuum-ubigraph-0.2.0.1 (GlebAlexeyev)
03:58:27 <luite> what's wrong with code.haskell.org? / seems to load using http, but the repositories don't
03:59:59 <luite> oh it's just extremely slow
04:01:12 <Olathe> > mappend 1 2 :: Integer
04:01:14 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Integer.Internals.Integer)
04:01:14 <lambdabot>    arisi...
04:01:25 <luite> could take a few hours to darcs get gtk2hs
04:04:48 <Olathe> > mconcat . map Product $ [1, 2, 3]
04:04:49 <lambdabot>   Product {getProduct = 6}
04:20:14 <scree> why do Sum and Product not overload mconcat?
04:20:26 <scree> it looks like they still use a foldr
04:20:40 <scree> hmph
04:21:44 <ivanm> scree: newtypes are used to provide a custom instance of Monoid
04:22:28 <scree> ivanm: I know, but they have the option of overloading mconcat as well as mempty and mappend
04:22:34 <scree> ivanm: only they don't
04:22:53 <scree> > mconcat $ fmap Sum [1..1000000]
04:22:54 <lambdabot>   Sum {getSum = *Exception: stack overflow
04:23:09 <ivanm> well, yeah, they don't have to
04:23:18 <ivanm> there's a default
04:23:30 <scree> but the default stack overflows
04:23:35 <ivanm> scree: what would be a better definition then?
04:24:07 <siracusa> Does anyone know of a changelog file for the network package?
04:24:27 <scree> well, foldl' mappend mempty wouldn't be unreasonable
04:24:45 <ivanm> scree: except that in general, it doesn't match the semantics
04:24:55 <ivanm> since mconcat is meant to use foldr
04:25:09 <ivanm> scree: it's possible that someone will write a non-commutative Num instance...
04:25:29 <scree> right, foldl' (flip mappend) mempty then
04:26:30 <scree> I mean, it's technically possible for someone to write a non-associative Num instance, but then making it a Monoid is wrong anyway
04:26:44 <dolio> Non-commutative wouldn't make foldl vs. foldr matter.
04:26:53 <dolio> It'd have to be non-associative.
04:26:55 <ivanm> scree: why?
04:27:10 <scree> Monoids are associative
04:27:14 <scree> that's the point of them
04:27:16 <ivanm> hmmm.....
04:27:28 <ivanm> dolio: why doesn't commutativity matter?
04:27:40 <scree> I think it does
04:27:49 <dolio> Because the difference between foldl and foldr is associativity, not commutativity.
04:27:54 <ivanm> well, I suppose if you use flip then commutativity doesn't matter...
04:28:14 <scree> sorry, you're right, it doesn't :)
04:28:22 <dolio> > foldl (*) z [a,b,c,d,e]
04:28:23 <lambdabot>   z * a * b * c * d * e
04:28:29 <dolio> > foldr (*) z [a,b,c,d,e]
04:28:30 <lambdabot>   a * (b * (c * (d * (e * z))))
04:28:39 <dolio> The only thing that switches places is z.
04:28:55 <ivanm> I'm wondering if its possible to define a number type that has that difference in where z is used matter...
04:28:56 <dolio> And that would be the unit of the monoid.
04:29:13 <scree> ivanm: then mempty is wrongly defined
04:29:17 <ivanm> > foldl (flip (*)) z [a,b,c,d,e]
04:29:18 <lambdabot>   e * (d * (c * (b * (a * z))))
04:29:23 <ivanm> scree: yeah, I suppose
04:29:46 <ivanm> well, foldl' (flip (*)) appears to do exactly the same as foldr
04:29:56 <ivanm> *shrug* I'm guessing the reasoning being was that they didn't want to special-case it
04:30:00 <ivanm> or just didn't think ;-)
04:30:23 <ivanm> > foldl' mappend mzero $ map Sum [1..1000000]
04:30:24 <lambdabot>   No instance for (Control.Monad.MonadPlus Data.Monoid.Sum)
04:30:24 <lambdabot>    arising from a...
04:30:44 <ivanm> @type mappend
04:30:45 <lambdabot> forall a. (Monoid a) => a -> a -> a
04:30:56 <scree> > foldl' msum mempty $ map Sum [1..10000000]
04:30:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = [b -> a]
04:31:13 <scree> > foldl' mappend mempty $ map Sum [1..10000000]
04:31:16 <lambdabot>   Sum {getSum = 50000005000000}
04:31:29 <ivanm> why does yours work but not mine?
04:31:36 <ivanm> oh, right, mempty vs mzero
04:31:48 <ivanm> > foldl' (flip mappend) mempty $ map Sum [1..10000000]
04:31:52 <lambdabot>   mueval-core: Time limit exceeded
04:31:58 <ivanm> > foldl' (flip mappend) mempty $ map Sum [1..10000000]
04:32:01 <lambdabot>   mueval-core: Time limit exceeded
04:32:09 <ivanm> OK, why does flip mappend make a difference?
04:32:15 <ivanm> > foldl' mappend mempty $ map Sum [1..10000000]
04:32:18 <lambdabot>   Sum {getSum = 50000005000000}
04:32:24 <ivanm> > foldl' mappend mempty . reverse $ map Sum [1..10000000]
04:32:30 <lambdabot>  Terminated
04:32:35 <ivanm> scree: looks like the order of numbers makes a difference as well
04:32:54 <ivanm> > foldl' mappend mempty $ map Sum [10000000,9999999..1]
04:32:58 <lambdabot>   mueval-core: Time limit exceeded
04:33:07 <ivanm> > sum [10000000,9999999..1]
04:33:14 <lambdabot>   mueval: ExitFailure 1
04:33:17 <ivanm> > length [10000000,9999999..1]
04:33:23 <lambdabot>   10000000
04:33:27 <scree> this is the lambdabot being crazy
04:33:30 <ivanm> > length [10000000,9999999..(1 :: Int)]
04:33:31 <lambdabot>   10000000
04:33:34 <scree> both work on my machine
04:33:38 <ivanm> wait, it might be Int vs Integer
04:33:50 <ivanm> > mconcat $ map Sum [1..10000000] :: Sum Int
04:33:51 <lambdabot>   Sum {getSum = *Exception: stack overflow
04:33:55 <ivanm> heh, maybe not
04:34:17 <scree> > foldl' (flip mappend) mempty $ map Sum [1..100000]
04:34:19 <lambdabot>   Sum {getSum = 5000050000}
04:34:31 <scree> yes, it just doesn't like doing lots of sums
04:34:48 <aristid> strictness win?
04:35:09 <ivanm> yeah, looks like it
04:35:16 <ivanm> but I don't get why flip mappend doesn't work...
04:35:32 <ivanm> > foldr (flip mappend) mempty $ map Sum [1..10000000] :: Sum Int
04:35:34 <lambdabot>   Sum {getSum = *Exception: stack overflow
04:35:47 <scree> ivanm: a foldr will never work
04:36:11 <ivanm> scree: well, flip mappend doesn't work with foldl'; wanted to check if it magically made foldr work ;-)
04:36:15 <ivanm> > foldl' (flip mappend) mempty $ map Sum [1..10000000] :: Sum Int
04:36:19 <lambdabot>   mueval-core: Time limit exceeded
04:36:25 <scree> ivanm: I think 10000000 is near the bot's time limit anyway, and the overhead on flip must push it over the edge
04:36:30 <ivanm> > foldl mappend mempty $ map Sum [1..10000000] :: Sum Int
04:36:36 <ivanm> scree: could be
04:36:39 <lambdabot>   mueval: ExitFailure 1
04:36:52 <ivanm> heh, and without that strictness foldl fails as well ;-)
04:37:33 <scree> @where report
04:37:33 <lambdabot> http://www.haskell.org/onlinereport/
04:39:19 <dolio> @type (5 :: Natural)
04:39:20 <lambdabot> Natural
04:39:30 <dolio> > 5 :: Natural -- < ^ Cale
04:39:31 <lambdabot>   Not in scope: type constructor or class `Natural'
04:40:33 <Cale> oh, the list of modules for @type gets out of sync with the evaluator...
04:58:16 <peterNovice> Does anyone know why System.Random.MWC.normal  0.5.0.0, does not return a result in ghc 6.10.4?
04:59:20 <tibbe> kolmodin: do you have your manually unpacked version of binary somewhere?
05:03:57 <Cale> peterNovice: hmm
05:06:36 <peterNovice> Cale, I guess it was thoroughly tested by bos, so probably the problem is with my setup.
05:07:03 <Cale> peterNovice: hmm, I'm seeing that behaviour as well. It spins forever.
05:07:20 <Cale> uniform works, normal doesn't
05:07:30 <peterNovice> Cale, I checked with the c-code where it comes from and it works
05:07:53 <Cale> eh?
05:08:16 <Cale> http://hackage.haskell.org/packages/archive/mwc-random/0.5.0.0/doc/html/src/System-Random-MWC.html#normal
05:08:23 <Cale> ^^ the (scary) code for normal
05:09:27 <peterNovice> I am not that good with haskell so I cannot judge if the haskell code reuses some computations that should be reiterated etc.
05:09:30 <Cale> The nested ifs which are laid out kind of strangely don't help
05:14:43 <Cale> I don't understand the algorithm being used, but I suspect that this is a hasty attempt at translation from some imperative code. It's not very clear what's going on.
05:16:25 <peterNovice> cale: I thought that bos used ch 11 of his book :)
05:18:09 <Cale> QuickCheck? I don't see any tests here...
05:32:45 <peterNovice> Cale: From what I understand is there a termination in the unfoldr in: go $! T r f
05:33:21 <zygoloid> {-# INLINE normal #-} -- is that a joke? :)
05:33:33 <aCiD2> Who fancies helping a haskel noob? :) I'm working on my first little app, to help do calorie tracking, and here's what I have so far: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25490#a25490
05:34:09 <aCiD2> But it has some smells... like repeating all the fields of FoodProduct. and I also want to be able to specify units for portions (but I will give that ago once I fix any other problems)
05:34:50 <ivanm> aCiD2: you can just have FoodProduct (protein food * serving) (...) (...) if you want
05:34:58 <zygoloid> aCiD2: you can write: frosties = FoodProduct 4.5 0.6 375
05:35:04 <ivanm> but how you've doing it isn't a problem
05:35:16 <aCiD2> Hrm, I think that's unclear though - I might forget which is which (that's why I chose to use record syntax)
05:35:17 <zygoloid> `per` 100 :)
05:35:21 <ivanm> however, you should have type sigs for serving and aggregate
05:35:31 <aCiD2> it's better to be explicit with signatures?
05:35:50 <Cale> aCiD2: Rather than writing a recursive aggregate, you could write something which adds two FoodProduct values, and just use foldr
05:35:58 <ivanm> Cale: heh, beat me to it
05:36:01 <aCiD2> I thought I could use foldr - I'll look into that
05:36:19 <Cale> aggregate = foldr add zero
05:36:24 <Kaidelong> not foldl'?
05:36:33 <ivanm> Kaidelong: *shrug* either or
05:36:34 <zygoloid> you could write a Monoid instance and use mconcat
05:36:40 <ivanm> foldl' might be better here
05:36:50 <ivanm> zygoloid: except is there really any point in doing so?
05:36:56 <Cale> addition is associative. foldl' would be slightly better, but only really if you make the fields in the datatype strict
05:37:01 <ivanm> zygoloid: especially if this is his first app?
05:37:15 <zygoloid> ivanm: well, e /could/ :)
05:37:19 <aCiD2> I think I'll try foldr first then
05:37:26 <Cale> and you're probably not going to be adding lists of millions of FoodProduct values anyway
05:37:34 <Cale> So it doesn't matter.
05:37:34 <aCiD2> does foldl' give any gains like better usage of space or efficiency?
05:37:39 <aCiD2> no, I don't eat that much :D
05:37:49 <Kaidelong> yes, it strictly evaluates the accumulator
05:37:54 <ivanm> aCiD2: foldl' is usually better in terms of space and efficiency over foldr
05:37:54 <zygoloid> aCiD2: yes, in this case it'd make better use of space
05:37:54 <Cale> foldl' can improve space/stack behaviour
05:37:55 <Kaidelong> which saves on space
05:38:01 <aCiD2> i see
05:38:02 <ivanm> but in this case, it probably doesn't matter
05:38:26 <Cale> foldr can be vastly better in terms of time behaviour sometimes (but not here)
05:38:32 <Cale> (and space as well)
05:38:50 <ivanm> Cale: for non-lazy functions like &&, when is foldr better?
05:39:06 <ivanm> (for cases like this; you obviously wouldn't use foldl' for defining map, etc.)
05:39:07 <Cale> foldr is better for && because you can shortcut
05:39:23 <zygoloid> > foldr1 (&&) [False, undefined]
05:39:24 <lambdabot>   False
05:39:32 <zygoloid> > foldl' (&&) True [False, undefined]
05:39:34 <lambdabot>   False
05:39:48 <zygoloid> > foldl' (flip (&&)) True [False, undefined]
05:39:50 <lambdabot>   *Exception: Prelude.undefined
05:39:55 <zygoloid> :)
05:40:00 <Kaidelong> foldr1 (&&) [undefined, false]
05:40:02 <ivanm> Cale: right
05:40:08 <Kaidelong> > foldr1 (&&) [undefined, false]
05:40:08 <lambdabot>   Not in scope: `false'
05:40:14 <Kaidelong> > foldr1 (&&) [undefined, False]
05:40:16 <lambdabot>   *Exception: Prelude.undefined
05:40:20 <ivanm> OK, for non-shortcutting functions, when would foldr be better?
05:40:40 <Cale> ivanm: when the function can produce part of its result without using its second parameter
05:40:52 <Cale> (even just sometimes)
05:41:00 <ivanm> but when you're basically doing a sum like here, then foldl' is better, right?
05:41:04 <Cale> right
05:41:11 <aCiD2> Cool, works a treat with foldr :)
05:41:37 <Cale> foldl' is better when you're summarizing the data into a value with not many separately evaluable pieces
05:42:02 <Kaidelong> so the basic reason to use foldr is to let the compiler choose the best evaluation order?
05:42:27 <ivanm> Kaidelong: not really....
05:42:34 <Kaidelong> hmm
05:42:43 <Cale> Kaidelong: foldr is better when laziness is good, foldl' is better when strictness is good
05:42:55 <aCiD2> Ok, so my next problem was less about playing code golf. I want to be able to have units, so I can say "a portion of 12 fl oz of milk" and "2 bananas". But I don't want to be able to say something like "100g of milk" - so I was looking for some way to make certain FoodProducts of volume, and some of weight
05:42:57 <ivanm> Kaidelong: you use foldr if your function can shortcut (like is &&) or if you need the list-structure unchanged (e.g. map)
05:43:05 <Cale> foldr is the one which works with infinite lists
05:43:09 <aCiD2> So I thought I could parameterize FoodProduct with... something - and then I got stuck :)
05:43:13 <Kaidelong> wasn't the big gain from laziness that things can be evaluated in any order or never evaluated?
05:43:30 <Cale> foldl' doesn't do anything but call itself until it reaches the end of the list
05:43:40 <Cale> Kaidelong: laziness *is* an evaluation order
05:43:53 <Cale> lazy evaluation is outermost-first + sharing
05:44:43 <ivanm> Cale: oh, right, and infinite lists
05:44:45 <Cale> Lazy evaluation is just the default evaluation strategy though. GHC does analysis to discover when it can evaluate things strictly.
05:45:12 <Cale> Purity means we can evaluate things in any order (which terminates)
05:45:20 <Kaidelong> so what does foldr do when it meets an infinite list?
05:45:23 <Kaidelong> return bottom?
05:45:27 <Cale> Under strict evaluation, some programs which would otherwise terminate won't.
05:45:41 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
05:45:52 <Cale> When foldr is met with a nonempty list, it calls f
05:46:02 <Kaidelong> oh I see
05:46:08 <Kaidelong> so if the recursive call is not evaluated
05:46:11 <Kaidelong> it terminates
05:46:12 <Cale> and only if f pattern matches its second parameter will it recurse
05:46:17 <Cale> right
05:46:24 <Kaidelong> that's spooky
05:47:10 <Cale> and of course, f might return some piece of data which *contains* that second parameter
05:47:21 <zygoloid> aCiD2: sounds like you want a phantom type parameter for FoodProduct indicating the units
05:47:30 <aCiD2> that sounds interesting :)
05:47:44 <aCiD2> Is that like a type parameter that my constructors don't use?
05:47:50 <zygoloid> exactly so.
05:47:51 <Cale> > foldr (\x xs -> x : (2*x) : xs) [] [1..]
05:47:52 <lambdabot>   [1,2,2,4,3,6,4,8,5,10,6,12,7,14,8,16,9,18,10,20,11,22,12,24,13,26,14,28,15,...
05:48:00 <Cale> > foldr (\x xs -> x : (10*x) : xs) [] [1..]
05:48:01 <lambdabot>   [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100,11,110,12,120,13,130,1...
05:48:07 <peterNovice> Cale, sorry to intervene, but normal works when I changed "I.take 126 . I.unfoldr go $! T r f" to "I.unfoldrN 126 go $! T r f", what actions do you suggest since you experienced the similar problems?
05:48:27 <Cale> peterNovice: e-mail bos :)
05:48:34 <zygoloid> aCiD2: you probably also want to use a smart constructor for FoodProduct rather than using the constructor directly
05:48:44 <aCiD2> zygoloid: Right, I tried that, but I think what I really want is less of a type parameter, but more of a class parameter. for example, "class Weight where toGrams :: Double -> Double" -- so my "weight based" foodproducts can have anything that is an instance of the Weight type class
05:49:12 <Cale> peterNovice: I probably have his address if you need it
05:49:47 <zygoloid> aCiD2: type classes are sadly not first-class in haskell, you can't easily and generically do that.
05:49:55 <aCiD2> I didn't think so :(
05:50:05 * Kaidelong wonders if he should redo his implementation of the rabin cryptosystem in haskell
05:50:22 <peterNovice> Cale, In the code it says bos@serpentine is this not for haskell?
05:50:52 <Cale> peterNovice: that seems right
05:51:29 <aCiD2> zygoloid: I think I can use a phantom type to parametize that is a SI unit, then provide methods like toG whenever I need a conversion
05:51:42 <aCiD2> it's less optimal, because it feels more like boilerplate, but I think that's the best I could do
05:53:39 <Cale> aCiD2: Of course, you could also be a bit more weakly-typed, and just represent these things as Data.Maps from various components to their values. Of course, it becomes a bit funny how you might deal with missing components when defining addition (I'd treat them as 0's given that we're looking at this as a vector space)
05:54:07 <aCiD2> Hrm, what am I mapping from and to?
05:55:18 <Cale> From names of quantities ("protein", "fat", "calories", etc.) to their values.
05:55:44 <aCiD2> Oh, is this for representing FoodProducts rather than using records?
05:55:49 <Cale> yeah
05:56:17 <Cale> So, that's more weakly typed, but it would be a way to eliminate some of the uniformity in your code.
05:56:18 <aCiD2> Yea, that doesn't seem to be of any advantage here, because there are a finite (and small) amount of properties a food product can have
05:56:22 <aCiD2> true
05:57:00 <Cale> Oh, you could also...
05:57:32 <zygoloid> aCiD2: you could do this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25490#a25491
05:57:35 <Cale> With the vector-space library from hackage, you could use the function instance of vector spaces
05:57:54 <Cale> and just have a finite enumeration type for your fields :)
05:58:07 <Cale> I'll make an example of that.
05:58:18 <aCiD2> zygoloid: that is pretty nice...
05:58:43 <aCiD2> Cale: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vector-space ?
05:59:03 <zygoloid> aCiD2: you'd then put that in a module, and not export serving nor PerUnit
05:59:04 <Cale> yeah
05:59:34 <zygoloid> the boilerplate is still pretty tedious though
05:59:47 <aCiD2> What boilerplate is that?
05:59:53 <aCiD2> the previous stuff, or something new?
05:59:54 <zygoloid> the gramsOf and gramsHas functions
06:00:01 <zygoloid> one per unit
06:00:06 <aCiD2> Hrm
06:01:18 <aCiD2> I'm gonna have a play with it, see if this meets what i'm expecting to happen (but suck at articulating on irc :))
06:01:38 * zygoloid has an idea for fixing that
06:02:28 <Kaidelong> hmm, my original implementation of the cryptosystem was tested using white box testing and preconditions/postconditions, anything like this for haskell?
06:02:43 <GPC> Hello :) I just stumpled across the hFlush function in Haskell and wondered whether it's safe to call it on stdin. Because in C, fflush(stdin) was never a really good idea
06:02:49 <Kaidelong> everything else seems to be good
06:02:49 <GPC> *stumbled
06:03:00 <Botje> GPC: what would be the semantics of flushing stdin?
06:03:44 <GPC> Botje: I'm afraid I don't exactly understand what you mean by semantics :[ Do you mean what the effect would be? Sorry, english isn't my native tongue
06:03:56 <Botje> GPC: nevermind, i just read man fflush
06:04:19 <Botje> GPC: i think it would wreak havoc, as in C, yes :)
06:04:35 <GPC> Botje: I thought so, but wasn't sure :) Thanks
06:07:24 <Cale> ouch
06:07:43 <Cale> Conal chose the wrong Scalar type here, so it messed up my plan.
06:07:51 <Cale> He has:
06:07:56 <Cale> instance VectorSpace v => VectorSpace (a -> v) where
06:07:56 <Cale>   type Scalar (a -> v) = a -> Scalar v
06:07:56 <Cale>   (*^) = liftA2 (*^)
06:08:16 <Cale> a -> Scalar v won't even be a field in most cases
06:08:26 <zygoloid> aCiD2: a more general approach: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25490#a25492
06:08:35 <Cale> That should just be Scalar v
06:09:03 <aCiD2> zygoloid: a little Yoda, but that looks nice :)
06:10:01 <Cale> preflex: seen Conal
06:10:01 <preflex>  Conal was last seen on #haskell 22 hours, 9 minutes and 58 seconds ago, saying: mreh: btw, i'm expecting a phone call any minute and may have to tune out for 30 minutes or so.
06:10:09 <Cale> hmm
06:10:15 <zygoloid> aCiD2: you could add an instance Quantity q => Num ((Double -> q) -> q), then write 100 Grams. But I would not recommend it :)
06:10:26 <aCiD2> That looks possible to extend outside the module (say a user wants a "MyFavouriteBowl" as a unit, because they're weird) - they just need to make an instance of the Quantity typeclass, right?
06:10:53 <zygoloid> aCiD2: right, but they wouldn't be able to make it be a Volume with that design
06:11:04 <zygoloid> a little more finessing and you can allow that too if you like
06:11:43 <aCiD2> How would you do that?
06:11:55 <aCiD2> pointers are best, then I can try and break it until it works :)
06:13:16 <zygoloid> class Quantity b q | b -> q where toBaseUnits :: b -> Double
06:13:22 * zygoloid dodges flames from fundep haters
06:13:50 <aCiD2> hrm, not seen that syntax before - what should I read to learn more about that?
06:14:20 <zygoloid> search for multiparameter type classes and functional dependencies. also search for type families and associated types.
06:14:27 <aCiD2> shall do!
06:14:32 <aCiD2> thanks zygoloid :)
06:14:33 <zygoloid> good luck!
06:14:53 <dpratt71> what are the chances Haskell will ever get a feature akin to the units-of-measure feature of F#? it seems fairly general/useful
06:14:56 <Kaidelong> Is it naughty to enable flexible instances?
06:15:11 <Kaidelong> dpratt71: F# doesn't have a units of measure feature anymore by default
06:15:23 <Kaidelong> since the language got commercialized it's lost more features than it has gained
06:15:24 <EvanR> couldnt you add units with a monad or something
06:16:22 <Kaidelong> I'm still trying to figure out where "Array.Parallel" went
06:16:26 <ivanm> dpratt71: you want numbers with units you mean?
06:16:32 <ivanm> I believe there's a library that does that...
06:16:44 <dpratt71> Kaidelong: you sure? I know the unit definitions have been pushed off to a "power pack", but I think the core language feature is still there?
06:17:19 <dpratt71> ivanm: yes; smart units that know how to combine with each other (or when combinations are invalid)
06:17:22 <saml> > let a |> b = b a in [1,2,3] |> map sqrt |> sum  -- postfix
06:17:23 <lambdabot>   4.146264369941973
06:17:27 <Kaidelong> dpratt71: If you put it that way, I suppose the special syntax is still there
06:17:32 <ivanm> dpratt71: there's the Measure library...
06:17:38 <ivanm> but what do you mean by invalid combinations?
06:17:49 <ivanm> do you refer to kg + m being invalid?
06:18:04 <ivanm> there's also caldims
06:18:05 <dpratt71> ivanm: that sort of thing, yes
06:18:11 <EvanR> ah yeah, a floating type with units attached
06:18:42 <EvanR> and you could use arbitrary units, like "r", and there would be predefined equivalence between some unit combinations
06:19:09 <dpratt71> in case anyone is curious, the feature is documented here: http://msdn.microsoft.com/en-us/library/dd233243.aspx
06:19:25 <Kaidelong> wasn't the feature actually inspired by the infamous NASA lander incident?
06:19:31 <Kaidelong> I seem to remember reading something like that
06:19:50 <mamalujo> hm, units-of-measure sounds extremely specific, maybe some lib + views?
06:19:50 <Cale> aCiD2: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25490#a25493
06:20:09 <dpratt71> Kaidelong: I don't know, but I hear that cited often as the sort of thing that "wouldn't happen if they were using F#" :)
06:20:23 <Cale> aCiD2: That's another way to go about it, however, I conspicuously left some type signatures out.
06:20:32 <Cale> er, oops, I missed an important line there
06:20:49 <aCiD2> Cale: that's pretty nice too, I certainly like how I'm not repeating what defines a food item everywhere
06:20:59 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25490#a25494
06:21:25 <aCiD2> I am definitely a fan of the (^+^) operator too :)
06:21:44 <Cale> The reason I left out the type signatures is that the instance of VectorSpace for functions is broken.
06:21:57 <Cale> and defines the scalars to be functions
06:22:22 <Cale> However, because numeric literals are overloaded, there's nothing to say that (1/100) isn't a constant function
06:22:31 <Cale> which is what the instance from Data.NumInstances does
06:22:43 <aCiD2> ah, clever
06:30:16 <Cale> aCiD2: I think this is another argument in favour of a proposed syntax where leaving the bit between 'case' and 'of' blank turns the expression into a function of that parameter too.
06:30:41 <Cale> You'd have  frosties = (case of Calories -> 375; Fat -> 0.6; Protein -> 4.5) `per` 100
06:30:57 <Cale> a little nicer :)
06:31:03 <aCiD2> indeed
06:31:17 <aCiD2> has that been proposed before then?
06:31:21 <Cale> yeah
06:32:09 <Cale> I bet if someone implemented it as an extension in GHC, it would be accepted, and it seems simple enough, but GHC is scary :)
06:33:35 <Cale> That would certainly be easier than implementing my favoured proposals regarding extensible records :)
06:33:41 <ivanm> Cale: hey, SPJ is busy writing a new type checker framework (IIUC from the email he just sent out); you don't expect him to be considering such trivial things as syntax and ease-of-use now, do you? :p
06:34:02 <ivanm> Cale: which extensible records proposal are you preferring?
06:34:02 <Cale> Which email?
06:34:10 <djahandarie> Which which?!
06:34:17 <djahandarie> This is sooo meta
06:34:20 <Cale> ivanm: I prefer Daan Leijen's semantics, with a different syntax.
06:34:26 <ivanm> he just sent one out to haskell@ and -cafe
06:34:27 <aCiD2> Chicken & egg time :)
06:34:36 <ivanm> heh
06:34:39 <Cale> Modular type inference
06:34:41 <Cale> I see
06:35:07 <ivanm> Cale: oh, btw, whilst I remember: do you really care that much about allowing possibily infinite graphs for the type classes?
06:35:10 <Cale> "Dimitrios, Tom, Martin and I have just completed an epic paper describing the Glorious New Framework that forms the substance of the above mutterings"
06:35:39 <ivanm> oh? I thought he said it was only a draft...
06:35:41 <djahandarie> Why would you want infinite graphs for type classes?
06:36:02 <Cale> ivanm: You seem to be doing most of the legwork on the graph stuff, so if it's an inconvenience, it doesn't bother me if you drop it :)
06:36:52 <ivanm> Cale: well, my objections are two fold (both rather trivial): it's introduces the requirement of having to implement yet another class, and people don't like having to then use FiniteGraph everywhere
06:37:06 <ivanm> (but you can't call the base class InfiniteGraph, because finite graphs aren't infinite...)
06:37:35 <philo> hi
06:37:56 * ivanm has a quick squiz through leijens paper, but doesn't see any obvious proposed syntax and usage there
06:38:03 * ivanm waves idly in philo's general direction
06:38:04 <philo> how easy (or difficult) is it to manipulated c++ object (from a c++ librairie ) in haskell ?
06:38:17 <Cale> ivanm: Well, in particular, he uses . as a field selector
06:38:25 <zygoloid> philo: the usual advice is to write a c wrapper
06:38:27 <ivanm> philo: well, Haskell has FFI support to C
06:38:29 <Cale> and I think it's overloaded enough
06:38:35 <ivanm> so it'd probably be easier to go via C if possible
06:39:09 <philo> ok
06:39:16 <ivanm> Cale: I suppose he doesn't want the paper to be too haskell-centric, but it means that I can't get an immediate impression of how/why they're better without bothering to go through the nuts and bolts of it
06:39:21 <philo> the lib in quesiton is llvm
06:39:31 <ivanm> philo: there is an LLVM library on hackage
06:39:34 <Cale> philo: There's an LLVM library for Haskell
06:39:38 <philo> yes
06:39:39 <ivanm> and it goes via llvm's C library
06:39:49 <philo> but it deosnt manage the selectionDAG
06:39:56 <ivanm> Cale: and it's bad enough that I have to read through so many papers at uni atm...
06:40:06 * ivanm finds all these edge contraction papers really, really boring
06:41:06 <Cale> ivanm: Who? Leijen or Peyton-Jones?
06:41:19 <ivanm> leijen
06:41:56 <philo> will i have to declare equivalent haskell type for every C type i need to manipulate ?
06:43:06 <Cale> philo: Generally, yes.
06:43:40 <Cale> philo: Well, you might get away with a trivial representation, and use pointers to C objects
06:43:41 <philo> ok thanks
06:44:04 <Cale> But if you want to do serious manipulation on the Haskell-side of things, it's usually a good idea.
06:44:05 <philo> Cale:  i need to acces field in those C structure ...
06:44:41 <Cale> just one, or all of them?
06:44:46 <philo> i am wondering if it is worth the hasle , i might be beter of just coding eveything in C
06:44:55 <Cale> You might end up writing Storable instances.
06:45:07 <philo> or use Ruby
06:45:19 <hcube> hi! i got trouble with hexpat-iteratee. (0.4 version)
06:45:43 <hcube> has anyone tried it?
06:45:51 <EvanR-work> the haskell website says that haskell is strongly typed, so it eliminates a 'huge class' of errors at compile time. doesnt it mean statically typed, and i thought strong/weak was a marketting thing
06:45:59 <Cale> I haven't, but blackh was here just the other day talking about it.
06:46:00 <EvanR-work> http://haskell.org/haskellwiki/Introduction
06:46:26 <blackh> hcube: Hello!
06:46:42 <jmcarthur> Kaidelong: ArrowApply is equivalent to Monad in power
06:46:43 <blackh> What's tha trouble?
06:46:50 <hcube> blackh: hi
06:46:59 <blackh> I am writing a blog post about it right now.
06:47:12 <Cale> EvanR-work: Strong/Weak is a relative thing
06:47:35 <Cale> EvanR-work: Just about how much information is encoded in the types.
06:47:37 <Kaidelong> jmcarthur: couldn't find much on it
06:47:40 <hcube> blackh: http://pastebin.com/u6sSSrt1
06:47:43 <ivanm> blackh: well, if I'm worried that I should hit the sack because it's so late, what are _you_ doing up?
06:47:56 <hcube> what is the problem with this simple code?
06:47:58 <blackh> ivanm: writing a blog post, of course!
06:48:05 <EvanR-work> Cale: it still sounds like its talking about static typing, that the compiler checks types at run time
06:48:15 <EvanR-work> i mean
06:48:16 <Cale> EvanR-work: You mean compile time
06:48:17 <EvanR-work> compile time
06:48:17 <philo> Cale:  i tought C (and ASM) were the only weakly typed languages ?
06:48:29 <ivanm> blackh: heh
06:48:37 <Cale> philo: They're weak in an absolute sense
06:48:51 <blackh> hcube: It's still a bit experimental.  It will actually bomb if you don't access the tree you've been passed.
06:48:57 <philo> ok
06:48:58 <Cale> (types guarantee essentially nothing)
06:48:59 <blackh> Try adding 'execute doc'
06:49:22 <hcube> which line?
06:49:23 <Cale> Well, that's not totally true, but almost ;)
06:49:25 <EvanR-work> you wont find a definitive yes or no about strong/weak for most languages
06:49:34 <philo> Cale do yo have an example of type system "stronger " than C but let say weaker than C++ or C#
06:49:35 <philo>  ?
06:49:55 <Cale> philo: Maybe we could put Pascal in there somewhere?
06:49:59 <Kaidelong> what do you mean by strongly and weakly typed?
06:50:03 <EvanR-work> sounds like continuum hypotheses ;)
06:50:10 <blackh> hcube: Just before return () - what execute effectively does is force the monadic sequencing of the list elements.
06:50:10 <EvanR-work> Kaidelong: exactly
06:50:28 <blackh> hcube: It will essentially touch the whole tree.
06:50:42 <hcube> but the code does not compiles
06:50:46 <Kaidelong> the one explanation I heard that kind of made sense to me was that it had to do with how silent type errors are
06:51:25 <blackh> hcube: What'
06:51:27 <blackh> s the error?
06:51:32 <Cale> But the static/dynamic distinction I think is sort of faulty. ;) Dynamic types aren't even really types.
06:51:37 <hcube> ghc 6.10.4 and 6.12.2 said:  No instance for (MonadIO (XMLT IO))
06:51:39 <Cale> (by the definition that I'd go by)
06:51:50 <Kaidelong> Cale: what about compile time vs run time types?
06:51:57 <Kaidelong> that's another one
06:52:02 <nus> "...we propose to simplify the language by removing automatic generalisation of local let bindings." -- does this mean less CAFs in top-level?
06:52:04 <Kaidelong> that one seems pretty clear
06:52:35 <philo> Cale dynamic type arent type ?
06:53:39 <Cale> Types are properties (or statements), about programs which are effectively machine verifiable.
06:53:40 <EvanR-work> well functions in those languages take any type
06:53:44 <EvanR-work> so the type is useless
06:54:03 <Kaidelong> EvanR-work: you can reflect on it
06:54:30 <Kaidelong> you can write functions that behave differently depending on the type of input they were given
06:54:41 <blackh> hcube: You need to use the transformers package instead of mtl.
06:54:56 <nus> Cale, verified at compile-time you mean?
06:55:09 <Kaidelong> the types are useful, although they'd look some kind of data structure from the perspective of what types are in haskell
06:55:23 <Kaidelong> but languages in general don't seem to agree on what "type" means
06:55:26 <Cale> nus: Well, verifiable at compile time anyway.
06:55:48 <hcube> blackh: it is installed, how can i disable mtl?
06:56:05 <blackh> hcube: ghc program.hs --make -hide-package mtl
06:56:20 <philo> Cale the time a wich the verification is done is not included in the definition of type
06:56:29 <Cale> Dynamic types are essentially just another kind of data
06:56:46 <Cale> not really statements *about* the program
06:57:06 <Kaidelong> Cale: you could say the same about some static types too though can't you? Like the ones in Java
06:57:42 <Cale> The static types in Java are statements about the programs.
06:58:05 <Kaidelong> They're also data structures on which methods are looked up at run-time
06:58:07 * Jafet prepares to inject perl into the current discussion again
06:58:07 <Cale> They don't tend to say a whole lot, but they indicate something nonetheless.
06:58:42 <Cale> Kaidelong: hmm...
06:58:56 <Kaidelong> C++ does it the same way IIRC
06:59:05 <nus> Cale, what's wrong with self-evolving and improving statetment?
06:59:17 <Cale> Kaidelong: I'm not sure if I agree with that, though are you talking about some sort of reflection?
06:59:36 <hcube> blackh: does not work: Could not find module `Control.Monad.Trans' it is a member of the hidden package `mtl-1.1.0.2`
06:59:59 <blackh> hcube: I don't think you've got transformers installed.
07:00:14 <blackh> What does 'ghc-pkg list transformers' say?
07:00:43 <blackh> Actually you must have transformers installed.
07:00:51 <JoeyA> When I compile this with GHC, I get a bunch of undefined references:  http://codepad.org/G4cLxJ3w   (the code is a piece of sample code found here)
07:00:52 <blackh> Is it a problem with the version of transformers?
07:01:08 <Cale> The normal view of subtype polymorphism is a static phenomenon.
07:01:10 <JoeyA> For some reason, Data.Map isn't getting linked in.
07:01:15 <Kaidelong> Cale: from what I remember, the type checking is actually done at run-time, and the methods are looked up when the type is known, the optomizing part of the static type system is not so aggressive that it eliminates all the "dynamic" aspects of it.
07:01:35 <Cale> Kaidelong: Well, their implementation might just suck.
07:01:37 <Kaidelong> reflection was probably part of the reason why
07:01:41 <hcube> blackh: /home/csaba/.ghc/i386-linux-6.10.4/package.conf: transformers-0.2.1.0
07:02:04 <JoeyA> (though I can still import Data.Map and use it in ghci)
07:02:07 <Kaidelong> Cale: I am pretty sure it was a limitation of the design of the type system
07:02:14 <Cale> But you can easily implement objects with statically checked subtype polymorphism without runtime checking of types.
07:02:18 <Kaidelong> which is why ML like languages are special
07:02:28 <Cale> Maybe for doing downward casts they need that.
07:02:46 <Kaidelong> Cale: there is also method overloading to deal with
07:02:57 <Cale> Kaidelong: That's not a problem
07:02:57 <blackh> hcube: That looks fine.  I'm trying your code.
07:03:01 <authy> im looking for a built-in function that takes a list [a] and a predicate p = (a -> b) and returns the value in [a] that produces the maximum of list [b] if we were to do (map p [a]). i imagine this is common enough that there should be a builtin and i should just have to do the whole zip with [a] and then select the max of the values extracted with snd
07:03:04 <Kaidelong> Make one function, give it a derived instance with an overload
07:03:05 <Cale> Kaidelong: Methods follow the data around anyway
07:03:13 <Kaidelong> alright
07:03:16 <Cale> (that's what an object is)
07:03:32 <blackh> hcube: Aha - it's monads-fd that you need.
07:03:45 <Jafet> Kaidelong, that is what classic OO is. The actual reason it is broken in C++ is that it isn't the default at all.
07:04:04 <Cale> Kaidelong: Java does sort of skew the view of OOP though.
07:04:10 <Jafet> C++ still has static typing, for the most part.
07:04:24 <Cale> (and C++ in the same way)
07:04:50 <Cale> But there's a sane interpretation for things regardless :)
07:04:52 <hcube> blackh: works! :)
07:05:09 <authy> im looking for a built-in function that takes a list [a] and a predicate p = (a -> b) and returns the value in [a] that produces the maximum of list [b] if we were to do (map p [a]). i imagine this is common enough that there should be a builtin and i should just have to do the whole zip with [a] and then select the max of the values extracted with snd. does this exist?
07:05:10 <blackh> hcube: You've helped me improve my blog post!
07:05:20 <hcube> :D
07:05:36 <hcube> thanks
07:06:03 <Jafet> authy, max $ map p as?
07:06:04 <Cale> authy: Are you sure you mean predicate there?
07:06:22 <Jafet> Or maximum
07:06:22 <authy> Cale: no. i think i meant function
07:06:26 <Cale> okay
07:06:49 <authy> Jafet: i dont want the max of the bs, i want the value from the as that produces the maximum b
07:07:15 <Cale> snd . maximum . map (\x -> (p x, x))
07:07:15 <byorgey> try maximumBy
07:07:29 <Cale> Or:  snd . maximumBy (comparing fst) . map (\x -> (p x, x))
07:07:30 <byorgey> > maximumBy (^2) [1,2,-4]
07:07:32 <lambdabot>   Occurs check: cannot construct the infinite type:
07:07:32 <lambdabot>    a = a -> GHC.Ordering....
07:07:48 <byorgey> @type maximumBy
07:07:49 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
07:07:55 <Jafet> Haskell programmers are so pampered, they think almost anything can be a builtin. Oh wait, it can
07:07:58 <Cale> > maximumBy (comparing (^2)) [1,2,-4]
07:07:59 <lambdabot>   -4
07:08:04 <byorgey> there we go =)
07:08:18 <authy> Cale: thats what i wanted, exactly
07:08:23 <Cale> Though that may compute (^2) more times than you wante
07:08:24 <Cale> d
07:08:45 <authy> Cale: so that will do more computations than i want? any way to profile that?
07:08:51 <Cale> (about twice as many times as there are elements)
07:09:15 <byorgey> cough premature cough optimization cough
07:09:15 <Kaidelong> Cale: can't graph reducation take care of this?
07:09:23 <Kaidelong> err
07:09:24 <Kaidelong> reduction
07:09:25 <authy> Cale: are you sure about that, or is haskell smart enough to hold on to intermediates
07:09:41 <Cale> Kaidelong: not in this case, I'm fairly sure
07:09:43 <authy> byorgey: thats not premature optimisation. thats appropriate level of optimisation
07:10:00 <byorgey> no it isn't, Cale is talking about a constant factor of maybe 2.
07:10:07 <Cale> I'm only warning about this in the case that p might be very expensive
07:10:20 <authy> Cale: p in fact will be somewhat expensive
07:10:45 <authy> expensive enough that a factor of two is not a good thing when a slightly longer bit of haskell can cut that out
07:10:54 <Cale> So in that case, the right thing is just to write   snd . maximumBy (comparing fst) . map (\x -> (p x, x))
07:11:04 <byorgey> ok, fine =)
07:11:18 <authy> Cale: i dont love that, but ill use it. itll be "more correct"
07:11:22 <Cale> which will use sharing to ensure that they're not computed more than once
07:11:34 <Cale> You can wrap that up into another function of course
07:11:34 <authy> Cale: its just not as pretty :(
07:11:38 <djahandarie> Isn't there a nicer way to write that?
07:11:40 <authy> and i plan to :D
07:11:42 <Kaidelong> authy: he's suggesting it if your function is really slow
07:12:04 <Kaidelong> authy: if you're doing something like (^2) it doesn't really matter that much
07:12:11 <authy> Kaidelong: i know, and it is, which ive said
07:12:12 <Cale> It may in fact be premature optimisation like byorgey suggested
07:12:18 <Kaidelong> ah alright
07:12:27 <Cale> But yeah, since you're saying that p is expensive, I think that it's better.
07:13:06 <byorgey> djahandarie: you could use   map (p &&& id)  instead of  map (\x -> (p x, x))
07:13:09 <Cale> (\x -> (p x, x)) could be written  p &&& id
07:13:14 <Cale> heh
07:13:28 <Cale> That's using Control.Arrow
07:15:19 <Kaidelong> what about using foldl1' with a pair of accumulating parameters?
07:15:24 <Cale> It seems quite wrong to me that in Java and C++, you put method definitions inside classes as a matter of course.
07:15:40 <Cale> But they offer no alternative
07:15:45 <Kaidelong> something like
07:16:15 <Runar> Cale: Think of Java and C++ classes as modules
07:16:21 <Cale> Classes should really contain nothing but a bunch of type signatures for methods.
07:16:29 <Cale> (and other members)
07:16:46 <Cale> *Objects* are where the methods should actually get definitions.
07:17:24 <Cale> Classes are after all supposed to be types.
07:17:54 <Cale> So that's all they should be.
07:18:14 <Runar> sometimes you want to provide a default definition, like in Haskell
07:18:50 <Cale> Well, sure.
07:19:02 <Kaidelong> mb f betterThan = foldl1' (accu f) where accu (acc,facc) (nxt:rest) = if f nxt `betterThan` facc then accu (nxt, f nxt...
07:19:10 <Cale> But you could also do this by defining a template from which other objects are going to be derived.
07:19:17 <Cale> (of the same class)
07:19:24 <Kaidelong> was getting pretty long and ugly so I suppose not
07:19:57 <Runar> Cale: these things aren't very well thought out in Java/C++
07:19:58 <Cale> That is, just define an object which has all the default method implementations and member values for that class.
07:20:20 <byorgey> Kaidelong: I think essentially that's unfolding the definition of maximumBy and doing a bit of manual fusion
07:20:35 <Cale> (you wouldn't really even need any special mechanism for it then)
07:20:58 <Cale> I think it stems from the fact that they decided against having first class procedures
07:21:01 <byorgey> Kaidelong: leave that to the compiler =)
07:21:21 <Kaidelong> byorgey: minimumBy and maximumBy did something to make me distrust them on my first haskell program
07:21:41 <Kaidelong> I think it turned out they were implemented with foldl instead of foldr or foldl' for some reason
07:21:54 <byorgey> ah, boo
07:21:57 <byorgey> they probably are
07:21:59 <Kaidelong> and I was getting stack overflows
07:22:06 <Cale> and so there's no convenient way to express "give me this object here, but where this member function is equal to <such and such procedure>
07:22:10 <Cale> "
07:22:21 <byorgey> they probably work fine if optimization is turned on
07:22:24 <dayz> in FOL, is it valid to compared function objects? e.g., \forall f. f = g?
07:22:35 <Cale> dayz: sure
07:22:35 <Saizan> they use foldl instead of foldl' since the haskell report was too optimistic about strictness analysis, there are RULES for some types though
07:22:57 <Cale> dayz: if you can quantify over it, you can compare it for equality
07:23:11 <dayz> Cale, but in FOL, you can't quantify over functions, right
07:23:22 <Cale> dayz: Depends on what your quantifiers range over
07:23:34 <Cale> dayz: You can't quantify over function symbols in your language
07:23:46 <dayz> Cale, right. but f and g are function symbols.
07:23:49 <Cale> But the values that your statements are talking about may well be functions
07:23:51 <Cale> ah, okay
07:23:52 * Kaidelong doesn't mind writing haskell verbosely for strictness or performance reasons since it usually stays pretty concise
07:23:59 <dpratt71> Cale: having used OO languages for pretty much my entire programming career, I didn't appreciate until recently how OO (as implemented by today's popular languages) conflates so much stuff that...I don't necessarily want conflated
07:24:22 <dayz> Cale, so does that mean it's not a valid FOL statement?
07:24:36 <dayz> Cale, that is, \forall f, g. f = g where f and g are function symbols.
07:24:38 <Kaidelong> not so far, anyway
07:24:39 <Jafet> http://paulgraham.com/reesoo.html
07:24:53 <Kaidelong> I might find something or another that will really turn me off, but it hasn't happened yet
07:24:54 <Cale> dayz: You could write  forall x. f(x) = g(x)
07:25:09 <Cale> dayz: But it's syntactically incorrect to leave the parameter to your function symbol off.
07:25:24 <dayz> Cale, sure.
07:25:57 <Kaidelong> biggest surprise to me recently was that enabling GHC's concurrency and parallelism stuff is an option when it's all done explicitly in your code anyway
07:26:28 <Kaidelong> I would understand the other way (disabling it being a flag) but it seemed weird coming out of F#
07:26:38 <Cale> Kaidelong: eh?
07:26:57 <Cale> Concurrency isn't an option, you always get that.
07:27:11 <Cale> But parallelism doesn't do much without -threaded
07:27:19 <Kaidelong> Cale: that was it
07:27:38 <Kaidelong> Cale: sorry, unclear, you can get concurrency without needing parallel processing
07:27:39 <Cale> Concurrency won't run in parallel unless you have -threaded on too.
07:28:04 <Kaidelong> yeah I meant where things are actually running in parallel
07:28:32 <Cale> -threaded can cause problems with bindings to C libraries though (and fix other problems magically ;)
07:28:49 <dpratt71> Cale: what is the meaning of concurrency when there is no parallelism?
07:29:01 <Kaidelong> dpratt71: you can pass a baton around
07:29:30 <Cale> dpratt71: Concurrency is about doing multiple things at once (possibly switching between them) to improve latency.
07:29:34 <dpratt71> I thought "concurrency" implies things happening "concurrently", i.e. at the same time
07:29:56 <Kaidelong> dpratt71: you can do several things at once on a single CPU
07:30:01 <Cale> dpratt71: Parallelism is about making use of multiple machines to get things done faster.
07:30:11 <Kaidelong> they just have to take turns
07:30:33 <nus> @wn concur
07:30:36 <lambdabot> *** "concur" wn "WordNet (r) 2.0"
07:30:36 <lambdabot> concur
07:30:36 <lambdabot>      v 1: be in accord; be in agreement; "We agreed on the terms of
07:30:36 <lambdabot>           the settlement"; "I can't agree with you!"; "I hold with
07:30:36 <lambdabot>           those who say life is sacred"; "Both philosophers
07:30:37 <Cale> Concurrency is extremely important even on single processor machines, for things like servers and GUIs
07:30:38 <lambdabot> [4 @more lines]
07:30:48 <nus> @more
07:30:48 <lambdabot>           concord on this point" [syn: {agree}, {hold}, {concord}]
07:30:49 <lambdabot>           [ant: {disagree}]
07:30:49 <lambdabot>      2: happen simultaneously; "The two events coincided" [syn: {coincide}]
07:30:49 <lambdabot>      [also: {concurring}, {concurred}]
07:30:58 <Cale> Because you need things to remain responsive to requests.
07:31:08 <Kaidelong> confusing parallelism and concurrency is a common mistake though
07:31:16 <Kaidelong> which I just demonstrated
07:31:21 <Cale> My favourite analogy is that of a fast food restaurant.
07:31:42 <Cale> Concurrency is about putting multiple queues in the front of the counter in order to serve more customers at once.
07:32:00 <Cale> Parallelism is about having multiple people working behind the counter to serve customers more quickly.
07:32:04 <Kaidelong> I think the source was that the controll.parallel source code kept referring to ghc.conc to spark things
07:32:11 <Kaidelong> the soruce of my confusion, that is
07:32:14 <Jafet> It's just one thing happening before, after, or simultaneously with another
07:32:56 <Kaidelong> which now makes sense since I suppose the behavior of sparks is different w vs w/o the -threaded flag
07:33:11 <Kaidelong> are
07:33:16 <Jafet> Cale, are you sure that's the right analogy
07:33:36 <Cale> Jafet: It's not a perfect analogy
07:34:09 <Kaidelong> how about representatives taking and yielding time to speak?
07:34:12 <Cale> But you can imagine one guy working behind a counter (a uniprocessor) serving multiple customers at the same time concurrently
07:34:20 <nus> Cale, in your analogy concurrency and parallelism are two aspects of the same thing: the counter.
07:34:27 <Jafet> You seem to have put the hamburger before the bun there
07:34:41 <Cale> and you can imagine 3 people behind the counter working in parallel on a single person's order
07:35:32 * Cale almost feels like bringing another sort of counter into the picture ;)
07:35:39 <Cale> The program counter!
07:36:05 <Cale> Concurrency is having multiple program counters.
07:36:29 <Cale> With parallelism, you may have a single program counter, but are using more computational resources to get things done quickly.
07:37:12 <Kaidelong> well with parallelism you actually may have multiple program counters as registers depending on how it is implemented
07:37:28 <jmcarthur> i think he means "program counter" on a more abstract level?
07:37:36 <Kaidelong> that's what I figured
07:38:06 <Kaidelong> since on a uniprocessor you will most likely really have just one, just changing its state
07:38:11 <Cale> yeah, I mean at the most abstract view of things
07:38:51 <Cale> In almost any practical implementation of parallelism, you'll probably meet up with some amount of concurrency.
07:39:35 <Cale> and there might be parallelism involved in an implementation of concurrency as well :)
07:39:37 <jmcarthur> where does pipelining fall? i've had hardware people argue that it's parallelism and software people argue that it's concurrency
07:39:46 <Kaidelong> Unless you had a perfect machine with no latency for IO and basic operations?
07:39:49 <jmcarthur> and other people not sure what side to take
07:39:59 <Kaidelong> then you wouldn't need to parallelize anything though
07:40:26 <Cale> I think I'm going to go with parallelism here.
07:40:57 <Kaidelong> It's parallelism at a fundamental level, and may be exploited for concurrency?
07:41:12 <Cale> But in practical terms... there might be some concurrency which sneaks in?
07:41:56 <jmcarthur> does it turn into concurrency as soon as you have to block waiting for some bottleneck in the pipeline to finish?
07:42:01 <Cale> Ideally, instruction pipelining is all about parallelism though. You execute multiple independent instructions at the same time, keeping the different parts of the processor warm.
07:43:16 <Cale> Also, good hint that it's not concurrency: the result is deterministic
07:43:36 <jmcarthur> hmm
07:43:49 <Cale> If pipelining introduces nondeterminism into the results of your computations, then usually I think you'd call that a bug in the chip.
07:44:08 <EvanR-work> are the memory usage statistics in the shootout skewed by the static linking of ghc runtime
07:44:27 <jmcarthur> pipelining exists outside of hardware too though
07:44:54 <jmcarthur> for example, look at CHP. if you remove the nondeterminism and have just pipelines is it still concurrency?
07:49:19 <eric_j> is there a combinator for consuming a list, accumulating state, and producing a list (lazily) as a result?
07:49:33 <EvanR-work> :t mapAccum
07:49:33 <lambdabot> Not in scope: `mapAccum'
07:49:40 <Saizan> ?type mapAccumL
07:49:41 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:52:24 <Jafet> @src mapAccumL
07:52:25 <lambdabot> mapAccumL _ s []        =  (s, [])
07:52:25 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
07:52:25 <lambdabot>    where (s', y ) = f s x
07:52:25 <lambdabot>          (s'',ys) = mapAccumL f s' xs
07:53:12 <Jafet> Someone should make a database of circular definitions for @src
07:53:19 <eric_j> thanks
07:53:55 <nus> concurrency and parallelism make more sense to me if they're used to describe some system of producer/consumer interaction. If producers perfectly match producers that's pure parallelism, and any disbalance causes concurrency.
07:54:13 <nus> *producers match consumers*
07:54:34 <Saizan> that seems fairly arbitrary
07:54:49 <Jafet> Why are there so many parallel definitions of concurrency, anyway?
07:54:56 <Saizan> hehe
07:55:05 <Jafet> (Or is it concurrent definitions of parallelism?)
07:55:37 <nus> well, this is all about being time/space/energy efficient.
07:55:52 <nus> constraints, so to say.
07:58:08 <Baughn> Anyone seen a weighted shuffle implementation on Hackage?
07:59:05 <BorisL> is it possible to derive a class instance separately from the data definition? If it is not, then what was the reason?
07:59:30 <Baughn> It's possible. "deriving Show Foo" is the standalone command.
07:59:44 <Baughn> ..or was it "derive"? Well, one of the two.
07:59:53 <Baughn> GHC will tell you to turn on an extension when you try it.
08:01:39 <byorgey> "deriving instance Show Foo"  I think
08:02:00 <byorgey> you will need the -XStandaloneDeriving extension
08:02:10 <byorgey> or {-# LANGUAGE StandaloneDeriving #-} at the top of your file
08:02:12 <BorisL> it works. Thanks
08:02:49 <edwardk> byorgey: looks like my reverse mode ad model works =)
08:03:05 <edwardk> StableNames for the win
08:04:05 <edwardk> now to make them play nicer with forward AD, and see if i can make a reverse mode AD tower or if i need to move to some kind of taylor model
08:07:58 <byorgey> edwardk: awesome =)
08:08:18 <byorgey> edwardk: I will pretend I know what you are talking about
08:08:28 <byorgey> edwardk: (well, OK, I understand the general idea =)
08:08:47 <edwardk> byorgey: automatic differentiation in haskelll usually uses forward mode because its easy to define as a Num instanc
08:09:09 <byorgey> edwardk: the part I don't understand is what is meant by "forward" or "reverse" mode
08:09:19 <byorgey> I know the general idea of AD but that's about it
08:09:41 <edwardk> in forward mode you compute the derivatives/jacobian as you do each operation.
08:09:56 <byorgey> ok, makes sense
08:10:04 <byorgey> yes, I see how it would be easy to define a Num instance to do that
08:10:08 <edwardk> in reverse mode you work backwards from the answer to the derivatives, which requires storing some kind of tape and identifying sharing
08:10:31 <byorgey> hmm, and that is better because it's lazier?
08:11:40 <edwardk> it is better because you can show it doesn't have the combinatorial explosion. the algorithm can retain the same time complexity, even if its space complexity becomes linear in the size of the computation to store the 'tape'
08:12:40 <edwardk> forward mode ad is good at solving functions of the form (FAD a -> [FAD a]) -- which have high fan-out, but reverse mode works well for functions that have high fan in i.e. ([RAD a] -> RAD a)
08:13:06 <edwardk> the latter happens a lot for things like backpropagation, etc.
08:13:35 <byorgey> ah, makes sense
08:13:39 <byorgey> thanks for the explanation =)
08:13:47 <byorgey> maybe you can show me your code next weekend
08:14:04 <jmcarthur> ooh reverse mode tower would be awesome
08:15:14 <edwardk> the types don't wind up so simple because you want to be able to take the derivative of a function that uses derivatives
08:15:51 <edwardk> jmcarthur: in theory i should be able to 'play back the tape' in a tape. but i may have to deal with some trickiness
08:16:01 <jmcarthur> :\
08:16:15 <edwardk> since ideally i would only want to do the 'recover sharing' pass once, and have the subsequent tapes built properly as a graph
08:17:11 <edwardk> jmcarthur: well, the same trick folks have been using in AD for forward AD to deal with avoiding the confusion of infinitesimals works for reverse mode ad.
08:17:28 <jmcarthur> awesome
08:18:08 <edwardk> i'll say this has been a great way to force me to go back to differential geometry and really think about the meaning of pushforwards and pullbacks, etc.
08:19:01 <anakreon> The program 'mapM putStrLn . map show $ [1..]' gradually increases memory consumption as if the list is stored in memory. Could this be true?
08:19:27 <byorgey> anakreon: yes, you probably want to use  mapM_  instead of mapM
08:19:29 <Botje> anakreon: mapM generates a list, yes
08:19:36 <Botje> anakreon: did you want mapM_ ?
08:19:51 <Botje> also, that's usually written mapM_ print [1..]
08:19:52 <byorgey> mapM generates a list of results, which in this case are all () so there's no point to storing them =)
08:19:58 <edwardk> anakreon: the gc should eventually spot that the output list isn;t being used, but it can munch a lot of memory in the meantime
08:20:00 <anakreon> Yes. mapM_ should do. I just want to print the list
08:20:45 <edwardk> byorgey: for comparison here is a painfully general version of forward AD: http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-Module-AutomaticDifferentiation.html
08:20:51 <edwardk> (though, sans tower)
08:21:00 <Fanael> Why I'm getting "parse error on input `State#'"? The line where compiler gives up is "fn :: State# RealWorld -> (# State# RealWorld, () #)".
08:21:03 <edwardk> but generalized to much weaker structures than usual
08:21:30 <edwardk> Fanael: have you got MagicHash in your LANGUAGE line?
08:21:31 <copumpkin> Fanael: you probably want MagicHash
08:21:46 <Fanael> I have {-# LANGUAGE MagicHash #-}.
08:22:03 <copumpkin> Fanael: then UnliftedTuples, or whatever it's called
08:22:24 <Botje> .oO(why are you playing around with State# ?)
08:22:55 <Fanael> For fun ;)
08:22:56 <edwardk> .oO(for fun and profit?)
08:23:20 <copumpkin> .oO(.oO())
08:23:36 <edwardk> fix .oO
08:24:13 <edwardk> you can have fun converting IO/ST s/STM to CPS style with explicit use of State#
08:25:36 <edwardk> newtype RanST s a = RanST ((forall r. a ->  State# s -> r) -> State# s -> r) -- yet another right kan extension
08:25:55 <copumpkin> lol
08:26:02 <edwardk> or even Codensity ((->) State# s)
08:26:35 <edwardk> which has a built in definition for >>= return fmap ap, etc.
08:26:55 <edwardk> "IO for free"
08:27:30 <Fanael> Ah. The needed extension is called "UnboxedTuples".
08:27:45 <edwardk> Fanael: ah that'd do it
08:30:03 <Fanael> So, now I can rewrite my brainfsck interpreter using primops :D
08:30:23 <copumpkin> eugh
08:32:35 <Fanael> I know it's a crime ;)
08:33:32 <jimmyjazz14_> Anyone know how to use Parsec 3 when other dependencies in my package require Parsec 2?
08:33:42 <jimmyjazz14_> with cabal that is
08:34:11 <dcoutts> jimmyjazz14_: honestly, that's pretty difficult
08:34:33 <jimmyjazz14_> I find that quite odd
08:34:36 <kosmikus> is it?
08:34:37 <dcoutts> cabal tries as hard as it can to keep just a single version of each package in each package dep tree
08:35:05 <earthy> odd.
08:35:09 <dcoutts> because it assumes that types can leak out of each package and types from different versions of a package would be incompatible
08:35:17 * earthy understands
08:35:19 <kosmikus> right, but that's cabal-install policy
08:35:21 <dcoutts> which would cause compilation to fail
08:35:27 <jimmyjazz14_> perhaps they need to rename parsec 3
08:35:28 <kosmikus> there's no general problem, right?
08:35:39 <earthy> but, if you explicitly ask for parsec >= 2 && < 3, parsec >=3 && < 4 ?
08:36:03 <dcoutts> earthy: there's no way to tell cabal that you're not going to try and unify the two
08:36:10 * earthy nods
08:36:19 <dcoutts> and there's no way to say that types do not leak, that a package dep is entirely private
08:36:36 * earthy understands the reasoning
08:36:43 <dcoutts> and you'd need both in that case
08:36:48 <jimmyjazz14_> so basically any package that relies on 'network' cannot use parsec 3?
08:36:52 <kosmikus> dcoutts: if you already have the packages depending on parsec-2 installed, then cabal-install on the package requiring parsec-3 should just work, shouldn't it?
08:37:04 <dcoutts> kosmikus: not necessarily
08:37:25 <dcoutts> because the importing package can try to unify types from the two versions
08:37:38 <dcoutts> eg, suppose a solution uses bytestring-0.9.0.1 and bytestring-0.9.0.4
08:37:58 <dcoutts> eg I have a package using zlib built against bytestring-0.9.0.1 and tar built against bytestring-0.9.0.4
08:38:14 <dcoutts> now I try and use zlib and tar together, bang, type error
08:38:43 <dcoutts> because I'm composing functions that use type bytestring-0.9.0.1:ByteString and bytestring-0.9.0.4:ByteString
08:38:46 <dcoutts> which are different types
08:38:47 <kosmikus> dcoutts: sure, understood. but this isn't particularly likely for parsec, is it?
08:38:57 <dcoutts> kosmikus: sure, but cabal does not know that
08:39:15 <Saizan> jimmyjazz14_: not necessarily, you can recompile network against parsec-3, or you can use runghc Setup configure --user; runghc Setup build; runghc Setup install; which just takes the lastest versions that match without this safety check
08:39:21 <dcoutts> we need the concept of private packages, to tell the dep planner that types from the private package cannot leak
08:39:40 <dcoutts> and thus that it's ok to use a different version of the same package elsewhere in the same solution
08:39:47 <kosmikus> but again. if network depends on parsec-2 and is already installed, won't cabal-install just print the warning about different parsec-versions being used, but still continue?
08:40:38 <kosmikus> (I don't notice these problems very much, because I use NixOS packages and rarely rely on cabal-install.)
08:40:40 <Saizan> kosmikus: it'll try to recompile network
08:40:56 <dcoutts> kosmikus: if you do runghc Setup configure then yes it'll just pick the latest versions and warn
08:41:15 <kosmikus> I see
08:41:22 <dcoutts> kosmikus: if you do cabal configure, it'll try the smarter thing and if that does not work then it'll fall back to the stupid thing and warn
08:41:39 <dcoutts> kosmikus: if you do cabal install, it cannot do the stupid thing, there are too many free variables
08:42:11 <dcoutts> if it cannot construct a valid install plan then that's it, it's stuffed
08:42:34 <kosmikus> thanks
08:42:36 <jimmyjazz14_> Saizan: the 'Setup' method failed with linking errors :\
08:42:38 <dcoutts> the fact that some package is already installed is almost irrelevant
08:43:47 <Saizan> jimmyjazz14_: what errors? and what does "ghc-pkg check" say?
08:44:45 <dmwit> jimmyjazz14_: My "wyvern" package on hackage depends on network and on a library that needs parsec-3. You get some build warnings, but everything goes just fine. So... it's possible.
08:45:01 <dcoutts> earthy: btw at the moment you cannot specify that a package directly depends on multiple instances of another dependency, "parsec >= 2 && < 3, parsec >=3 && < 4" means "parsec >= 2 && < 3 && >=3 && < 4" which is impossible
08:45:30 <jimmyjazz14_> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25499#a25499
08:45:37 <kosmikus> dcoutts: yes, that used to be the same in Gentoo when I was still using it
08:45:44 <dmwit> jimmyjazz14_: Although it makes the installation instructions considerably more complicated, see http://dmwit.com/wyvern .
08:45:45 <dcoutts> earthy: but if you could, there'd still be a potential problem if other packages you depend on re-export types from parsec
08:46:55 <dcoutts> kosmikus: it's handy for specifying constraints in a modular way, eg with conditionals. We'd need additional syntax (eg like Haskell's "import Foo as Bar") for multiple instances.
08:47:57 <jmcarthur> surely there is some sort of versioned dependency theory we could come up with somehow...
08:47:59 <kosmikus> dcoutts: is there still a project for improving cabal-install's dependency resolver?
08:48:59 <Saizan> jimmyjazz14_: rstemplate uses TH?
08:49:10 <dcoutts> kosmikus: there's still a need for it, and I've got some ideas. I don't think anyone is currently actively working on it.
08:49:13 <kosmikus> jmcarthur: certainly. it's a fun problem, but it isn't trivial either. and lots of related work :)
08:49:48 <dcoutts> kosmikus: presumably in nix, with the parsec 2,3 problem you simply apply external knowledge to say that a solution using both can work.
08:50:17 <dcoutts> kosmikus: since you're explicitly specifying the install plan, by specifying the versions of each package used
08:50:18 <kosmikus> dcoutts: yes, in Nix we just explicitly say which versions we want to use.
08:50:25 <dcoutts> right
08:50:51 <kosmikus> dcoutts: except with MarcWeber's hack-nix tool, that tries to do some on-the-fly dependency resolution. but I'm not using that.
08:51:14 <dcoutts> kosmikus: which would then face this same issue that cabal's dep planner has
08:51:31 <kosmikus> yes
08:52:37 <kosmikus> back in the days when I was working on exi, I had ideas for this problem as well. well, I somehow thought somebody was currently working on the cabal-install dependency solver. if not, I should advertise it as a possible master thesis project again ...
08:53:04 <jmcarthur> hmm... we have package qualified imports now. maybe we could have *versioned* package qualified imports :o
08:53:20 <jimmyjazz14_> Saizan: TH?
08:53:22 <jmcarthur> then we could consider the "same" type from two versions of a package being incompatible by default
08:53:28 <Saizan> jimmyjazz14_: TemplateHaskell
08:53:35 <jimmyjazz14_> oh, no it does not
08:53:50 <jmcarthur> woudl also require some special support from cabal i'm sure
08:53:51 <kosmikus> jmcarthur: GHC already does that
08:53:54 <jmcarthur> oh?
08:54:02 <jmcarthur> oh right, it does
08:54:20 <jmcarthur> but if you could syntactically differentiate them then it would be easier to prevent the problem, right?
08:54:25 <jimmyjazz14_> Saizan: its a string template package I developed for my own use, I just added the parsec 3 code to it recently
08:54:28 <kosmikus> regarding versioned imports: I'd prefer if packages remain an "external" mechanism used by compilers, and do not become part of the Haskell language
08:54:29 <dcoutts> kosmikus: yes please, it's an interesting real-world constraint problem
08:54:38 <jmcarthur> i agree. it's a hack solution
08:54:51 <jmcarthur> then again, "versions" are a hack, too
08:54:59 <Saizan> jimmyjazz14_: it seems like its installation is screwed somehow, you could see if "ghc-pkg check" reports any problems, or if a reinstallation solves this anyway
08:55:26 <dcoutts> kosmikus: particularly because it's got soft constraints as well as hard constraints, and error messages when no solution can be found are vitally important (which makes simple approaches with SAT more tricky)
08:55:41 <Saizan> jimmyjazz14_: or you could first try with a clean in your error-console directory.
08:55:45 <kosmikus> agreed
08:55:53 <jmcarthur> two versions of a package are really more like two different packages which (usually) happen to share some subset of their APIs
08:56:51 <jmcarthur> nix understands that at least
08:57:11 <dcoutts> jmcarthur: the qualified imports thing is not really meant for general use, it's for hacks like making base 3 and base 4 compatible by re-exporting types from base 4 through base 3
08:57:26 <jmcarthur> dcoutts: right. my suggestion is an epic hack
08:57:41 <jmcarthur> it's not even a very serious suggestion
08:57:42 <jimmyjazz14_> Saizan: I did clean installs of both rstemplate and error-console and got the same error
08:57:43 <dcoutts> or similarly for a package like haskell2010 re-exporting a subset of base
08:57:59 <dcoutts> I agree with kosmikus that packages should remain external to the language
08:58:06 <jmcarthur> i, too, agree
08:58:10 <dcoutts> especially since the design issues are not settled
08:58:23 <dcoutts> and are somewhat system-dependent
08:58:38 <dcoutts> ie wanting to make ABI-stable shared libs
08:58:55 <jimmyjazz14_> Saizan: for the record this is what cabal install gives me http://pastie.org/960474
08:59:21 <Saizan> jimmyjazz14_: these linker errors should be an orthogonal issue
09:02:40 <danharaj> Does GHC come with a binary tree library? Data.Tree is more than I need.
09:03:08 <aristid> danharaj: is it a problem that it supports more than you need?
09:03:51 <danharaj> aristid: I don't want to use a rose tree when I need exactly a binary tree.
09:04:00 <tommd> danharaj: If you just want a mapping then Data.Map.  If you're looking for more flexibility then look at the numerous tree libraries on hackage.  GHC is trying to include less and move the main library considerations over to the Haskell Platform.
09:05:05 <Saizan> danharaj: one usually rolls his own tree
09:05:24 <tommd> ... and that isn't always a good thing.
09:05:35 <aristid> Saizan: because there are too many variants to have a "one library for all"?
09:06:00 <Saizan> aristid: yeah
09:06:05 <tommd> Roll it in Coq, prove the important properties, extract to Haskell.  We need a Coq -> Hackage tool :-)
09:06:25 <Saizan> it depends on what you want to do with it though
09:06:37 <Saizan> for binary search trees there's plenty of libs on hackage
09:07:03 <Saizan> if it's just to represent some data with a tree structure there's not much advantage in using a generic solution
09:07:26 <Saizan> we have special language support for trees afterall: ADTs
09:08:56 <fhobia> System.Console.GetOpt can't handle spaces between a flag and its value? like "-f bar" ?
09:09:05 <danharaj> Alright, well it doesn't matter right now. A bit of examination shows I need to answer a few more design questions before I settle on a specific structure. This is what happens when you try to retrace a train of thought over night.
09:10:07 * hackagebot safe-failure 0.5.0 - Library for safe functions  http://hackage.haskell.org/package/safe-failure-0.5.0 (MichaelSnoyman)
09:10:27 <Saizan> (if you want a tree with substitutions you could generate it as a free monad)
09:14:08 <Liskni_si> fhobia: it sure can
09:14:26 <fhobia> ( ^ ^ ) !
09:27:45 <jimmyjazz14_> Saizan , dcoutts: for the record I fixed my parsec conflict in cabal by removing all the packages built against parsec 2 and rebuilt them with 3, also the linkage error was caused by a missing module in the 'Other-Modules' section of rstemplates .cabal file
09:28:19 <jimmyjazz14_> I find the Other-Modules bug to be particularly annoying
09:33:18 <Saizan> jimmyjazz14_: SPJ seems to agree with you :)
09:35:39 <siracusa> What does `cabal upgrade A' do with depending packages, auto-rebuild and upgrade them too, if the current version isn't compatible with A?
09:37:50 <Saizan> it recursively tries to use the lastest version available of the dependencies too
09:38:11 <Saizan> if you just want to get the latest version of A you should use install
09:38:53 <siracusa> Saizan: But with install the old package will still be installed?
09:39:56 <Saizan> upgrade doesn't uninstall either
09:40:25 <siracusa> Oh, ok
09:42:07 <gwern> you can't uninstall with cabal
09:42:22 <gwern> ghc/cabal don't track all the installed files/directories, and so wouldn't know what to remove
09:43:34 <dcoutts> Saizan, siracusa: I plan to eliminate "cabal upgrade foo" and replace it with "cabal install foo --upgrade-dependencies"
09:43:51 <dcoutts> since I think that's much clearer about the actual behaviour
09:46:00 <siracusa> So will an upgrade at least unregister the old packages?
09:49:47 <Saizan> no, i think the only command that unregisters anything is ghc-pkg unregister
09:50:23 <Saizan> ..you could also think of reinstalling the same version of the same package as unregistering the old
09:51:51 <siracusa> Hhm, I have to update the network package and there are a lots of depending packages.
09:52:14 <dcoutts> if you're installing a new version that's fine, the old one will remain and nothing breaks
09:52:58 <siracusa> But I want the depending packages to depend on the new network version
09:53:11 <dcoutts> siracusa: then ask to install those too
09:53:57 <dcoutts> siracusa: or you might not need to if there deps of the thing you're asking to install
09:54:02 <dcoutts> there/they're
09:54:57 <siracusa> dcoutts: Do I have to list them all by hand?
09:55:14 <dcoutts> siracusa: if you have a dependency chain like A -> B -> C, and you want to upgrade C and A, then just say cabal install A C, it will automatically rebuild B because A depends on B and B depends on C.
09:55:43 <dcoutts> siracusa: the only time you'd need to list another one explicitly is if you've got say E that depends on B or C but where the package A does not depend on E
09:55:52 <dcoutts> then you'd say cabal install A E
09:56:13 <dcoutts> if you leave off E then it'll remain as is, using the old versions of B, C
09:56:32 <dcoutts> siracusa: it's clear what'll happen if you use the --dry-run flag
09:56:39 <dcoutts> possibly with -v for extra detail
09:57:19 <siracusa> Well I have A -> [?] -> [[?]] where A is buggy and I want a new version of A
09:57:32 <dcoutts> so cabal install A
09:57:53 <Fanael> Haha, now my interpreter is 15% faster because I rewrited the code from normal, high-level Haskell to GHC primops :D
09:58:06 <aristid> Fanael: *rewrote
09:58:37 <dcoutts> Fanael: it's impressive that high level code got within 15% of performance of the low level code
09:58:56 <Fanael> Yep, I forgot the fact that "rewrite" is irregular verb ;)
09:59:06 <dcoutts> crazy English :-)
10:00:48 <siracusa> dcoutts: I tried --dry-run, it will only install A and I don't know all the packages that depend on the old version of A which should become updated too :-S
10:01:44 <dcoutts> siracusa: right, install will try and use the existing versions of dependencies where possible
10:01:50 <dcoutts> siracusa: you can cabal upgrade A --dry-run
10:02:05 <dcoutts> that tries to upgrade all the dependencies as well
10:02:21 <Saizan> dcoutts: i think siracusa wants to update the reverse-dependencies of A
10:02:33 <dcoutts> oh
10:02:43 <dcoutts> there's no special support for that
10:02:43 <Saizan> so that they are built against the new A
10:02:46 <dcoutts> just have to list them
10:03:33 <Saizan> iirc there's a program on hackage to list those
10:05:11 <dcoutts> I suppose in principle we could add cabal install foo --reinstall/upgrade-reverse-dependencies
10:05:48 <dcoutts> it can become rather tricky because it means finding a consistent install plan for a much larger set of packages
10:08:17 <Saizan> well, you can do this with a program that queries to ghc-pkg and xargs
10:09:08 <EvanR-work> what is a good read for object oriented haskell
10:09:19 <Saizan> http://hackage.haskell.org/package/cabal-sort <- i was thinking of this but it's not what i remembered
10:10:40 <dcoutts> Saizan: I'm going to make cabal-sort obsolete soon, by implementing "cabal install ./foo/ ./bar/"
10:15:59 <Baughn> @pl \a -> a == 1 || a == 2
10:15:59 <lambdabot> liftM2 (||) (1 ==) (2 ==)
10:18:27 <BMeph> "Dependents of A"? :)
10:18:27 <siracusa> `cabal revdeps A' giving a list of all packages that use A would be nice. :-)
10:18:59 <djahandarie> @pl \a -> a == 1 || a == 2 || a == 3 || a == 4 || a == 5
10:18:59 <lambdabot> liftM2 (||) (1 ==) (liftM2 (||) (2 ==) (liftM2 (||) (3 ==) (liftM2 (||) (4 ==) (5 ==))))
10:19:03 <djahandarie> Heh
10:19:13 <dcoutts> siracusa: it's slightly tricky, people mean different things by that
10:19:50 <dcoutts> siracusa: eg installed packages that depend on A is easy, but non-installed packages that do/could depend on A is more subtle
10:19:53 <Peaker> I have   type Display arg = (RequestedSize, Size -> arg -> Image)   and    Widget k = (RequestedSize, Size -> HasFocus -> (Image, EventMap k))     -- I would expect all functions of form of  (Display HasFocus -> Display HasFocus) to be applicable to Widget.. But I can't figure out a nice way to do this
10:19:56 <earthy> cabal uses-of A
10:20:16 <kolmodin> tibbe: two repos available: http://haskell.org/~kolmodin/code/binary-push and http://haskell.org/~kolmodin/code/binary-push-unpacked
10:20:17 <Saizan> dcoutts: what's an use case where you want the latter?
10:20:23 <Peaker> @type (`elem` [1,2])
10:20:23 <lambdabot> forall a. (Num a) => a -> Bool
10:20:27 <tibbe> kolmodin: thanks
10:20:30 <kolmodin> tibbe: on my box, the "pretty" on gives 1mb/s if running the bench with 100mb
10:20:30 <dcoutts> Saizan: looking at reverse deps on hackage
10:20:58 <tibbe> kolmodin: so I'm looking at manually unpacking the builder monoid in Data.Text
10:21:11 <tibbe> kolmodin: the Core I'm currently getting is pretty bad
10:21:12 <gwern> Saizan: suppose you wanted to update all callers - are peopel conditionally depending on your library any less worthy of your help?
10:21:18 <Saizan> ah, ok, e.g. if you're the maintainer of A
10:21:36 <tibbe> dcoutts: did you actually manage to manually unpack continuation parameters. I did it manually and still get terrible Core
10:21:50 <kolmodin> tibbe: and the unpacked versions gives around 26mb/s
10:22:03 <Peaker> More specifically,  given: A = (a -> c),  and B = (a -> b -> c) how do I nicely convert (A -> A) to (B -> B) ?
10:22:20 <dcoutts> tibbe: no, I just had it constructing Buffer heap objects whenever it called a continuation
10:22:28 <Peaker> @djinn ((a -> c) -> (a -> c)) -> (a -> b -> c) -> (a -> b -> c)
10:22:28 <lambdabot> f a b c d = a (a (\ _ -> b c d)) c
10:22:32 <dcoutts> tibbe: but most continuations disappear so it's not too bad
10:22:42 <tibbe> dcoutts: ok, I tried manual unpacking and it didn't work
10:23:39 <tibbe> dcoutts: I get really bad core for looks: something simple like: loop i acc | i < n = acc; | otherwise = loop (i+1) (acc `mappend` 123)
10:23:56 <tibbe> dcoutts: every iteration creates a new closure *and* reboxes everything
10:23:57 <chrisdone> when's the next european haskell get together?
10:24:10 <tibbe> dcoutts: straight line code works great. I even merge the bounds checks
10:24:18 <dcoutts> tibbe: you might have better results with a foldr rather than a foldl
10:24:25 <kolmodin> tibbe: is the code available online?
10:24:27 <tibbe> dcoutts: good point
10:24:40 <tibbe> kolmodin: http://johantibell.com/files/text-spj.tar.gz
10:24:49 <tibbe> kolmodin: that's not unpacked
10:25:33 <siracusa> I think I'll write a program that lists all such packages that use A. Would be less pain than finding them by hand.
10:26:01 <tibbe> dcoutts: somewhat unrelated, I cannot get ghc to use a local package db using -package-conf unless I bump the version number of the local package
10:26:27 <tibbe> dcoutts: i.e. ghc -c -package-conf dist/package-conf... SomeFile.hs doesn't work
10:26:39 <tibbe> dcoutts: it complains it doesn't find the .hi files
10:27:04 <dcoutts> tibbe: presumably the same version is also registered in the global or user package db.
10:27:19 <tibbe> dcoutts: yes, so the local -package-db doesn't get preference?
10:27:38 <tibbe> dcoutts: I tried -hide-all-packages -package text-<version>-<long hash>
10:27:40 <tibbe> didn't work either
10:27:48 <dcoutts> tibbe: it's more complicated than that. I think that is a consequence of ghc's current slightly strange package db merging algorithm.
10:28:02 <tibbe> dcoutts: so what's the right way to do it?
10:28:06 <dcoutts> tibbe: can you please report it as a ghc bug, I will add my comments
10:28:10 <tibbe> @src foldr
10:28:10 <lambdabot> foldr f z []     = z
10:28:11 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:28:15 <tibbe> dcoutts: ok
10:28:36 <dcoutts> tibbe: I think you cannot do it without changing the version number (or not using the db that has the other instance)
10:28:49 <tibbe> dcoutts: bummer
10:29:14 <dcoutts> tibbe: the issue is how do you merge package dbs which have multiple instances of the same package version and still have a way to pick a single instance given a package version number.
10:29:26 <dcoutts> tibbe: and have that instance and its deps actually work
10:30:27 <tibbe> dcoutts: but if I give the hash shouldn't it be clear what I want?
10:30:36 <dcoutts> tibbe: ghc currently uses a method where it ensures each db has at most one instance, and then when merging it does something to guarantee consistency but it does not guarantee that dbs layered on top always get priority
10:30:52 <tibbe> dcoutts: I see
10:30:56 <dcoutts> tibbe: no, because it's merged them alleady at that point, discarding the one you wanted.
10:30:59 <ski> @type let foo :: ((a -> c) -> (a -> c)) -> ((a -> b -> c) -> (a -> b -> c)); foo ac_ac abc a b = ac_ac (\a -> abc a b) a in foo  -- Peaker ?
10:31:00 <lambdabot> forall a c b. ((a -> c) -> a -> c) -> (a -> b -> c) -> a -> b -> c
10:31:06 <tibbe> dcoutts: ah
10:31:35 <dcoutts> tibbe: it's an interim solution, Simon and I have discussed it in the past. We got it to this stage for 6.12.
10:33:33 <ski> @type let foo :: ((a -> c) -> (a -> c)) -> ((a -> b -> c) -> (a -> b -> c)); foo ac_ac = flip . (ac_ac .) . flip in foo
10:33:33 <lambdabot> forall a c b. ((a -> c) -> a -> c) -> (a -> b -> c) -> a -> b -> c
10:34:00 <ski> Peaker : hm ?
10:34:24 <tibbe> dcoutts: http://hackage.haskell.org/trac/ghc/ticket/4072
10:36:06 <siracusa> Is there a package that provides parsing a ghc-pkg dump file?
10:37:03 <Fanael> @pl (\x -> (int2Word# k `timesWord#` v) `plusWord#' x)
10:37:03 <lambdabot> (line 1, column 21):
10:37:03 <lambdabot> unexpected "`"
10:37:03 <lambdabot> expecting variable, "(", letter, digit, "`", "!!", ".", operator or ")"
10:39:08 <tibbe> dcoutts: a foldr worked much better I think
10:39:56 <dcoutts> tibbe: figures. It's a bit like writing foldl in terms of foldr, it needs a clever transformation to make it work well.
10:40:10 <tibbe> dcoutts: I
10:40:16 <dcoutts> in fact it's almost exactly the same issue
10:40:20 <tibbe> dcoutts: I'll try the manual unpacking again now
10:40:52 * hackagebot SimpleAES 0.4.1 - Fast AES encryption/decryption for bytestrings  http://hackage.haskell.org/package/SimpleAES-0.4.1 (DavidHimmelstrup)
10:41:13 <chrisdone> that sounds like a fun bit of code to read
10:41:34 <jmillikin> Is there any sort of naming convention for uploading "alternative" packages to Hackage? I'd like to upload an Iteratee library based on Oleg's encoding, but don't want to conflict with the existing "iteratee" package.
10:42:10 <gwern> not really
10:42:17 <chrisdone> I think I've seen -alt before... /me checks
10:42:49 <tibbe> dcoutts: the foldr code actually looks really good except for the unpacking
10:42:55 <chrisdone> ok, only one instance of that, hehe
10:43:04 <lispy> jmillikin: I don't have an answer to your question, but I'd like to hear about the difference between your library and the existing one
10:43:48 <dcoutts> tibbe: right, since it goes with the flow of the continuations rather than against.
10:43:57 <jmillikin> lispy: Oleg wrote two versions of Iteratee. The first one was uploaded to Hackage by John Lato. The second is apparently an improvement, because it prevents some edge condition I don't fully understand.
10:44:29 <lispy> jmillikin: do you have a link to Oleg's write up of the second generation?
10:44:41 <tibbe> dcoutts: except it's a bit too lazy
10:44:51 <tibbe> dcoutts: we only want per chunk laziness instead of per write
10:44:52 <lispy> jmillikin: I've been working on a type threaded version of iteratee, so I'm very curious :)
10:44:54 <Saizan> siracusa: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/Cabal-1.8.0.4/Distribution-Simple-Program-HcPkg.html
10:45:05 <jmillikin> lispy: http://okmij.org/ftp/Haskell/Iteratee/IterateeM.hs , scroll down a bit. You'll see John's version commented out, with some notes
10:45:24 <lispy> jmillikin: thanks
10:45:39 <jmillikin> "A different design, from in Iteratee.hs. It seems worse as we discuss below."
10:46:16 <siracusa> Saizan: Thanks!
10:46:23 <jmillikin> It's Oleg code, so trying to figure out what's better about the new version would probably fill up a few pages of notes, and I don't feel up to it...
10:46:27 <lispy> jmillikin: you might also want to talk to John about your design.  He's working on a new version of the one he maintains
10:46:34 <dcoutts> tibbe: I'm not sure I follow that
10:46:38 <lispy> jmillikin: so, you guys might be able to have one package
10:46:53 <jmillikin> lispy: well, first I have to figure out whether the new one is actually an improvement ;)
10:47:16 <tibbe> dcoutts: right now there's a thunk for the next write
10:47:27 <jmillikin> I've a history of uploading packages based on cool new ideas, only to discover they're actually dumb, and then they're wasting space on hackage forever
10:47:34 <dcoutts> tibbe: oh, right, that seems unnecessary
10:47:40 <tibbe> dcoutts: however, I want it to be chunk strict, once we start a new chunk I want it to perform all the writes
10:47:48 <dcoutts> tibbe: indeed
10:47:53 <tibbe> dcoutts: the foldr compiles to something element strict
10:48:04 <gwern> jmillikin: take heart. all your packages are less than a fraction of a cent of hard drive space
10:48:09 <tibbe> dcoutts: I have an idea of how to get the rewrite rules to fire better
10:48:32 <tibbe> dcoutts: right now they can only match at the bottom of the AST meaning that only one fires per simplifier iteration
10:48:33 <sproingie> true but they're noise in the signal
10:48:36 <jmillikin> gwern: it's not space I'm worried about, but namespace. Every bad package uploaded takes up space on the package list page, and prevents somebody from using the name
10:48:51 <gwern> jmillikin: eh. ross can always delete them
10:48:56 <gwern> or you can rename them and delete
10:49:01 <sproingie> there should be a rating system like cpan has
10:49:06 <sproingie> not that cpan uses it much
10:49:08 <lispy> jmillikin: are you referring to the section that starts with: All enumerators, even enum_file below, can be implemented to have the above signature.
10:49:16 <jmillikin> If Hackage were like PyPI I wouldn't worry about it, but there's no way to remove packages except to beg through email, and even then they're not really removed, just hidden
10:49:59 <jmillikin> lispy: just search for "newtype Iteratee". There's two variants in the code. The second one is commented out, with some notes about why it's not as good.
10:50:04 <dcoutts> jmillikin: if we need to reuse package names but with new unrelated packages, we might need to implement some epoch system.
10:50:07 <gwern> sproingie: there should be a lot of things :)
10:50:49 <jmillikin> dcoutts: regardless, I feel bad about wasting names. probably just a silly hangup
10:51:05 <dcoutts> jmillikin: I have to try hard not to worry :-)
10:51:13 <tibbe> dcoutts: the current AST looks like this: (append writeN (append writeN (append (writeN writeN)))) so a rule on the form: append writeN writeN can only match once on a top-down pass
10:51:35 <tibbe> dcoutts: but with different combinators for appending and writing we might be able to match much better
10:51:56 <dcoutts> tibbe: mm, I'm not sure if that's the way the rule rewriter does things
10:52:43 <tibbe> dcoutts: I talked with rl about it and, if I didn't missunderstand things, it is
10:52:49 <dcoutts> tibbe: ok
10:53:08 <tibbe> dcoutts: it also matches my experimental results where I get -fmax-simplifier-iterations rewrites every time :)
10:53:13 <dcoutts> jmillikin: the other thing I want to do to ease the namespace problem is to allow cabal install to work direct from http urls to tarballs, so people do not need to post betas and trivial forks on hackage.
10:53:20 <dcoutts> tibbe: ok :-)
10:53:26 <tibbe> dcoutts: I don't think it's specified that it has to work this way, but it does
10:54:05 <jmillikin> dcoutts: that would be very very helpful!
10:54:28 <tibbe> dcoutts: I have to run out, thanks for the foldr tip
10:54:34 <dcoutts> np
10:56:22 <dcoutts> jmillikin: I just need to find a volunteer to work on a http client download cache
10:56:53 <jmillikin> can't the tarballs simply be downloaded to a temp dir?
10:57:17 <dcoutts> jmillikin: that's just about tolerable
10:57:37 <dcoutts> will quickly get annoying
10:58:28 <dcoutts> jmillikin: consider doing cabal install --dry-run http://blah/blah
10:58:46 <dcoutts> jmillikin: and then re-running without the --dry-run flag, it'll have to download twice
10:59:20 <gwern> are we so short on bandwidth?
10:59:26 <jmcarthur> cabal install http://example.com/some_darcs_repo   :)
10:59:50 <jmillikin> ewwww, no, I don't want to install from a darcs repo
10:59:52 <dcoutts> jmcarthur: right, I've no idea how to handle the caching when installing from source control repos
10:59:58 <gwern> jmillikin: ouch, I wouldn't want to have to figure that one out. reduplicate wget? shell out to darcs or git?
11:00:07 <jmcarthur> or:  cabal install --from-darcs some_package
11:00:24 <jmcarthur> in the case that the cabal file has that info :)
11:00:26 <jmillikin> just the versioning problems of installing from darcs are terrifying
11:00:51 <dcoutts> jmcarthur: well it's no worse than when you cd to your local darcs repo and cabal install
11:01:02 <jmcarthur> dcoutts: in the case of darcs, the local cache should save a lot of time
11:01:07 <gwern> jmillikin: nah; just go by the .cabal's version, or timestamp it
11:01:28 <gwern> jmcarthur: most are still on darcs-1 format
11:01:32 <gwern> all of c.h.o no?
11:01:41 <jmcarthur> i doubt all
11:01:44 <jmcarthur> but most, yes
11:01:55 <jmcarthur> but things can change over time
11:01:57 <dcoutts> gwern: darcs-1 or darcs-1 hashed for old ones, probably a few darcs-2 for new ones
11:02:12 <gwern> jmcarthur: they don't without pushes
11:02:25 <gwern> dcoutts: are there so many darcs-1 hashed?
11:02:36 <dcoutts> e.g. I switched gtk2hs to darcs-1 hashed the other day
11:02:36 <jmcarthur> gwern: old repos get stale and lose desireability anyway
11:02:47 <gwern> xmonad is an old repo...
11:02:58 <jmcarthur> old repos can be upgraded
11:03:27 <jmcarthur> by "old" i originally meant "unmaintained"
11:03:44 <gwern> original intent! heresy - we believe in a living interpretation
11:04:23 * jmcarthur dynamically reinterprets himself every day
11:05:24 <lispy> jmillikin: okay.  My hunch is that IterateePure doesn't work as well as the other Iteratee definition when it comes to handling exceptions
11:05:49 <jmillikin> lispy: huh? IterateePure is just a type
11:06:08 <jmillikin> look at the definitions of "Iteratee"
11:07:01 <jmillikin> One of them is [[ newtype Iteratee = Iteratee (runIter :: m (IterV el m a)} ]] , the other is [[ newtype Iteratee = Iteratee (runIter :: Stream el -> m (IterV el m a)} ]]
11:07:53 <lispy> jmillikin: oh, sorry I didn't expect the same type to be in there twice so I didn't notice one of them
11:07:56 <jmillikin> Oleg says the version which requires input before obtaining output is problematic, but that's the version currently on hackage
11:08:01 <jmillikin> lispy: right. One of them is commented out.
11:10:19 <lispy> jmillikin: thanks.  Yeah, I can't really tell why the "worse" one has been winning out
11:10:49 <jmillikin> I think just because nobody can figure out why it's worse :P
11:11:14 <lispy> jmillikin: the drawbacks that are pointed out make sense :)
11:11:33 <lispy> jmillikin: but, I wonder what are the drawbacks of the other version...
11:12:11 <lispy> jmillikin: I think we should email oleg
11:16:20 <Figs> Hello
11:16:38 <Figs> Is there a decent way to deal with namespace pollution from records?
11:16:52 <gwern> qualified imports?
11:16:56 <lispy> Figs: maybe the best way is to define them in their own module
11:17:27 <lispy> Figs: another way, is data MyRecord ..., and name the fields like, myRecord'foo
11:17:34 <Figs> I'm writing a lot of types that will all likely have very similar requirements... it seems a bit much to write a module for each one of them.
11:18:33 <Figs> lispy: That seems ugly. If I want to rename something, then it would be a major pain to do so.
11:19:07 <aristid> Figs: maybe just make sure that each module has 3 or less records?
11:20:08 <tromp> cabal install is driving me nuts:(
11:20:27 <Makoryu> So folks, where are we gonna find a platform to appropriate so that Haskell will be the default way to write stuff on it
11:21:15 <Figs> arstid: What difference does 3 records make?
11:21:24 <Figs> *aristid
11:21:37 <gwern> Figs: if you're writing a whole bunch of boilerplate, sounds like a missed abstraction
11:21:46 <earthy> btw, now that some people with more experience in high-performence haskell are around
11:22:28 <earthy> do things in e.g. data.bytestring still get fused when you turn on profiling?
11:22:33 <Figs> What I'm trying to write are some different spatial management types.
11:23:10 <Figs> I have a working version in python of the types I have in mind, but other aspects of the project are getting a bit annoying in python as it grows in size.
11:23:49 <Figs> Essentially, all the types have a few things in common, like boundary data, but how they manage the rest of the objects differs for collisions.
11:24:32 <Figs> (eg. a grid uses a different mechanism for collision checking than a simple set based on a map)
11:26:03 <sztomi> Hi. How can I execute a shell command and use the echoed result in my haskell program?
11:26:23 <c_wraith> @hoogle Process
11:26:23 <lambdabot> System.Posix.Types type ProcessGroupID = CPid
11:26:23 <lambdabot> System.Posix.Types type ProcessID = CPid
11:26:29 <c_wraith> @hoogle process
11:26:29 <lambdabot> System.Posix.Types type ProcessGroupID = CPid
11:26:29 <lambdabot> System.Posix.Types type ProcessID = CPid
11:26:34 <c_wraith> hmm.
11:26:51 <c_wraith> why's hayoo down?
11:27:50 <Baughn> How can I.. enumerate the interface addresses of my network cards? Portably?
11:28:13 <Baughn> ("Portably" is not actually required. Linux will do.)
11:29:51 <arw> 'ip addr list' or 'ifconfig'
11:30:27 <Baughn> I was thinking "in haskell", but that's a fallback plan I guess.
11:30:36 <arw> you need to implement both, since some linux distributions install one, some the other tool.
11:30:58 <arw> i would be surprised if there was a haskell library for that
11:31:03 <Baughn> I'm sure there's some more stable system call to do it
11:31:04 <c_wraith> isn't there at least a libc function you can call?
11:31:12 <Baughn> Not libc, no.
11:31:24 <Baughn> ..glibc? Maybe.
11:31:37 <jmillikin> Not glibc either. You'd need to use system calls, or perhaps poke around in /dev and /sys
11:31:41 <arw> no. there is /proc/something or some ioctl.
11:31:55 * earthy nods
11:32:02 <earthy> no syscalls
11:32:08 <c_wraith> sztomi:  http://hackage.haskell.org/package/process
11:32:10 <earthy> plus, there's a shitload of variations
11:32:23 <earthy> so you're really better of parsing ip addr list or ifconfig's output
11:32:46 <arw> depending on the kernel the ioctls and /proc-entries vary, so better do as earthy recommends.
11:32:47 <earthy> (where the first is somewhat easier to parse than the second)
11:33:28 <Baughn> Screen-scraping can /not/ be the best option. :/
11:33:53 <arw> its not screen-scraping. the output of 'ip' was made for beeing parsed.
11:34:11 <c_wraith> Doesn't the java network lib do this?  It probably just has a billion special cases.
11:34:28 <jmillikin> if it does, it probably just shells out to a binary
11:34:40 <Baughn> ..guess it's parsing for me.
11:34:44 <Baughn> Wonderful.
11:34:47 <Peaker> ski, sorry.. got pulled to a family meetup here :)
11:34:52 <sztomi> c_wraith: thanks, exactly what I was looking for ;)
11:35:30 <Peaker> ski, still there, thanks for that.. why does djinn come up with something involving const?
11:37:00 <ski> Peaker : not sure .. but i was thinking you probably didn't want `_' in there
11:38:21 <Peaker> ski, right, that bothered me
11:41:28 <earthy> c_wraith: even worse: there's a fixed interface that is implemented in a machine-dependent fashion for each platform the jre runs on
11:42:19 <c_wraith> earthy: that's basically what I meant by a ton of special cases.
11:42:33 <earthy> ah. yeah.
11:45:54 <mreh> @seen luiqi
11:45:54 <lambdabot> Unknown command, try @list
11:46:01 <mreh> what's his name again
11:46:40 <c_wraith> I thought it was luqui.  But lambdabot doesn't support seen anymore.  preflex does, but may not be in the channel
11:47:03 <mreh> ,preflex seen luqui
11:47:09 <c_wraith> whois preflex
11:47:11 <ski> preflex: xseen luqui
11:47:11 <preflex>  luqui was last seen on freenode/#haskell 38 days, 3 hours, 45 minutes and 30 seconds ago, saying: ah
11:47:11 <c_wraith> err
11:47:27 <c_wraith> I totally suck at typing slashes.  *sigh*
11:47:53 <mreh> 38 days?
11:47:56 <mauke> preflex: seen nzeh
11:47:56 <preflex>  nzeh was last seen on #haskell 313 days, 14 hours, 19 minutes and 57 seconds ago, saying: In any case, I'll just be happy that it worked and go on and use it ;)
11:48:27 <mreh> there is life after #haskell?
11:48:28 <c_wraith> preflex: seen mmorrow
11:48:29 <preflex>  mmorrow was last seen on #ghc 116 days, 15 hours, 50 minutes and 42 seconds ago, saying: * mmorrow is rtfm'ing
11:48:38 <c_wraith> yikes.  didn't realize it'd been so long.
11:48:39 <EvanR-work> mreh: #scala? :)
11:48:47 <mreh> heresy
11:48:53 <EvanR-work> lol
11:49:02 <mauke> preflex: seen ndm
11:49:02 <preflex>  ndm was last seen on #haskell 1 year, 5 days, 8 hours, 30 minutes and 20 seconds ago, saying: plus with current compiler technology, it would be slower
11:49:02 <mreh> I spoke to him in the winter about music, then he never came back
11:50:42 <mreh> preflex: seen HaskellLove
11:50:43 <preflex>  HaskellLove was last seen on #haskell 82 days, 8 hours, 36 minutes and 14 seconds ago, saying: then I will be ninja
11:50:53 <EvanR-work> that guy
11:50:54 <mreh> lol wut
11:51:04 <Saizan> great quote
11:51:07 <mreh> I thought he was a she?
11:51:25 <EvanR-work> perhaps he calls himself OCamlLove these days
11:51:44 <c_wraith> pokoko22 last I saw
11:51:59 <chrisdone> NinjaLove
11:52:09 <mreh> RealUltimatePower?
11:52:21 <mreh> anyway, offtopic
11:52:30 <chrisdone> unsafeEnterNinjasHouse
11:57:07 <mreh> can you store a pointer and get it back in IO monad?
11:57:13 <Baughn> "Pointer"?
11:57:20 <jmcarthur> Ptr?
11:57:40 <EvanR-work> Ptr (Ptr a)
11:57:51 <Baughn> TVar (TMVar (Ptr (Ptr a)))
11:58:06 <Baughn> IORef (MVar (Fix Ptr a))
11:58:16 <EvanR-work> whats a TVar
11:58:25 <Baughn> Software transactional memory variable
11:58:33 <Baughn> (Control.Concurrent.STM. It's nice.)
11:58:34 <earthy> why complicate the answer?
11:58:38 <jmcarthur> IORef (MVar (STRef (TMVar (Ptr (TVar a)))))
11:58:56 <EvanR-work> for comedy gold purposes
11:58:59 <earthy> IORef (Ptr a)   is more or less what he seems to want ;)
11:58:59 <jmcarthur> IORef (MVar (STRef s (TMVar (Ptr (TVar a)))))
11:59:14 <Baughn> We don't know what he wants. He didn't specify. :P
11:59:18 <EvanR-work> when he said store a pointer, i was thinking a Storable
11:59:54 <earthy> then again, why store pointers in the case of Storable? You'd probably be better off with offsets from a known base, so your storables are relocatable
12:01:26 <BMeph> earthy: "why complicate the answer?" For great justice! ;D
12:01:37 <earthy> take off every zig. :P
12:02:05 <Baughn> For great nudity?
12:02:07 <EvanR-work> forM zig (take off)
12:02:14 <earthy> okay, time for a beer and to stop fidgeting with this large-array-of-bytes thingy
12:02:26 <EvanR-work> you mean C ?
12:02:45 <BMeph> Ditto, only lunch, not beer for me...
12:02:55 <earthy> evanr: nope. I mean a Data.Vector clone that is not limited to Int for indexing
12:03:07 <earthy> (yes, this has consequences)
12:03:39 <earthy> but I have about 56G of inputdata to work through, and about the same amount of data to generate
12:04:01 <earthy> this does not fit a 32 bit Int.
12:04:03 <EvanR-work> time to put 64bit machine to the test
12:04:27 <earthy> ah. yes. that would be the other option. not as much fun though ;)
12:05:11 <earthy> as I stated, time to stop fidgeting with it. :)
12:13:59 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25501#a25501 <-- This "parse the ip addr list output" thing is not going well, apparently due to a lack of experience with parsec. Help?
12:15:45 <Baughn> ..naturally I pick that time to solve it. Never fals.
12:17:38 <Nereid> you need (try newline) instead of newline after `manyTill` maybe?
12:18:11 <Baughn> Nope. But though I fixed that.. have another problem.
12:18:45 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25502#a25502
12:18:48 <triyo> I got this error: "Ambiguous type variable `e' in the constraint:  `GHC.Exception.Exception e' arising from a use of `handle'".
12:19:17 <Baughn> triyo: There's insuffiient information for the type-checker to figure out what concrete type e is
12:19:36 <triyo> this is from the BetterPredicate.hs example fomr the RealWroldHaskell book.
12:19:38 <Baughn> You need to either add code that requires a particular type, or an explicit type signature
12:19:49 <mauke> triyo: yeah, Control.Exception got changed
12:19:56 <triyo> Wander if this is the problem: http://stackoverflow.com/questions/431527/ambiguous-type-variable-error-msg
12:20:48 <mauke> yes
12:21:14 <triyo> I see
12:21:16 <mauke> handleAny :: (SomeException -> IO a) -> IO a -> IO a
12:21:20 <mauke> handleAny = handle
12:21:28 <mauke> add to your code, use handleAny instead of handle
12:21:43 <mauke> if that doesn't work, I need to use my brain
12:22:25 <triyo> hehe, ok
12:24:33 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25502 <-- So, to reiterate - parsec newbie seeking help. Manually stepping through this (..in my head) says it should work, but... well. Doesn't.
12:24:50 <mauke> Baughn: fail
12:24:54 <mauke> that's not even constant input
12:25:19 <Baughn> It's not going to change right now.
12:25:42 <idnar> debugging parsec is hell
12:26:07 <mauke> what?
12:26:31 <mauke> give me something I can run, preferably one parser with constant input
12:26:41 <Baughn> ..sure
12:29:07 <Figs> Is it evil to redefine (.) as record access if I'm not using function composition? :)
12:29:12 <mauke> yes
12:29:19 <mauke> I'll cut your legs off
12:29:27 <Figs> hee hee.
12:29:48 <Baughn> mauke: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25503#a25503 <-- This, then?
12:29:59 <Baughn> Figs: You'll use function composition.
12:30:06 <Baughn> Figs: And if you don't, you're doing it wrong.
12:30:07 <mauke> ah, optimized for unreadability
12:30:27 <jmillikin> "Is it evil to redefine 0 as print if I'm not using maths?"
12:30:32 <Baughn> I'd have cut it up and used unlines, but it looks better if you putStr it anyway.
12:31:21 <mauke> Baughn: Not in scope: `parse'
12:31:33 <Nereid> import
12:31:50 <mauke> what?
12:31:56 <Nereid> import parsec modules
12:31:58 <Baughn> mauke: ..are you really going to make me add the import?
12:32:00 <Baughn> Fine.
12:32:10 <mauke> <mauke> give me something I can run, preferably one parser with constant input
12:32:24 <Baughn> Yes, okay. Working.
12:32:35 <mauke> or tell me what the modules are
12:33:23 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25504#a25504
12:33:31 <Baughn> Optimized for readability.
12:34:01 <lispy> Baughn: you know you can do multiline strings too right?
12:34:10 <Baughn> lispy: No.
12:34:13 <mauke> lispy: not in any good way
12:34:17 <EvanR-work> "abc\
12:34:22 <EvanR-work>  \oops"
12:34:35 <Baughn> lispy: It's remarkably easy to do this conversion with an emacs keyboard macro
12:34:40 <mauke> EvanR-work: no
12:34:44 <mauke> "abc\n\
12:34:46 <mauke> \oops"
12:34:49 <EvanR-work> yes
12:34:50 <mauke> and that's just too ugly to live
12:35:04 <EvanR-work> nah
12:35:13 <jmillikin> It's better than using unlines, at least
12:35:22 <mauke> I disagree
12:35:26 <lispy> The example I'm looking at doesn't need newlines and it looks pretty
12:35:40 <lispy> If you need the newlines, then yes, maybe unlines is easiest
12:35:44 <mauke> Haskell should just have allowed newlines in strings
12:35:52 <lispy> mauke: agreed
12:36:06 <idnar> python has """ / '''
12:36:11 <c_wraith> you could always use a quasiquoter.
12:36:12 <idnar> except then you can't indent properly
12:36:13 <mauke> idnar: for no good reason
12:36:21 <idnar> so it still doesn't work
12:36:22 <c_wraith> It would be a trivial quasiquoter, too! :)
12:36:31 <gwern> just write \n you pansies
12:36:47 <mauke> I wrote \n" ++ "
12:36:50 <idnar> gwern: he did, but mauke complained :P
12:37:13 <gwern> ya tawpies, yeh drooping daisies
12:40:16 <Nereid> Baughn: you don't need the $ after unlines
12:40:22 <Baughn> True.
12:40:46 <Baughn> But I have a quota to keep.
12:40:55 <Nereid> a quota of $'s?
12:41:01 <Baughn> Right
12:41:03 <Nereid> lol
12:41:33 <gwern> bankster
12:43:12 <mauke> Baughn: "1: lo: \n2: sit0: \n" is parsed as Right [("lo",[])]
12:43:31 <mauke> your addresses parser consumes the following devLine
12:44:15 <Baughn> Really? I thought it'd abort when it sees the lack of spaces
12:44:27 <mauke> whu?
12:44:39 <mauke> devLine requires a lack of spaces
12:44:41 <mauke> why would it abort/
12:44:42 <Baughn> Oh, wait.
12:44:57 <Baughn> manyTill consumes what ends it.
12:46:32 <Baughn> mauke: There's an unfortunate lack of explanations, but it'll work if I wrap it in lookahead, right?
12:46:52 <mauke> unlikely
12:47:05 <mauke> bah, why isn't Parser an instance of Applicative
12:47:24 <Nereid> I thought it was
12:47:30 <Baughn> It does, actually. Replacing the try with lookAhead fixed it.
12:49:40 <mauke> who broke hpaste?
12:50:11 <Baughn> "Database is locked".. would imply an admin did it
12:50:27 <mauke> Baughn: http://codepad.org/3XvH0KWB
12:50:31 <mauke> is what I ended up with
12:51:59 <Nereid> I preferred unlines
12:52:17 <Baughn> I have no mental model of <*/*>
12:52:27 <Nereid> *> is like >>
12:52:33 <Baughn> @type (*>)
12:52:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
12:52:42 <mauke> you should, they're awesome
12:52:55 <Baughn> @type (<*)
12:52:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
12:52:57 <Nereid> a <* b = do {x <- a; b; return a}
12:53:01 <mauke> I used to define << for monads before I learned about Applicative
12:53:14 <c_wraith> in the context of parsers, they mean "parse both of these things, but return only the value from the side I'm pointing at"
12:53:32 <mauke> addressLine = many1 space *> many (noneOf "\n") <* char '\n'
12:53:35 <Baughn> Hmmm
12:53:42 <mauke> = \s+([^\n]*)\n
12:53:49 <mauke> because I think in regexes
12:54:00 <Nereid> a <*> b = do {x <- a; y <- b; return (x y)}
12:54:16 <mauke> @. pl undo do {x <- a; y <- b; return (x y)}
12:54:17 <lambdabot> (b >>=) . (return .) =<< a
12:54:20 <c_wraith> also, a <$ b is useful as "parse b, but return a"
12:54:23 <Baughn> Well, thanks for the assistance. I'd have been stuck on that for hours. :)
12:54:35 <Baughn> @type (<$)
12:54:36 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
12:54:45 <mauke> is that like fmap . const
12:54:50 <c_wraith> yep
12:55:09 <c_wraith> :t fmap . const
12:55:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
12:55:42 <c_wraith> really, it's awfully hard for that type signature to mean anything else
12:56:23 <Baughn> There's always unsafeCoerce
12:56:31 <mauke> :t (.) (.) return
12:56:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
12:56:35 <c_wraith> I didn't say impossible
12:56:58 <Nereid> :t const . pure
12:56:59 <lambdabot> forall b a (f :: * -> *). (Applicative f) => a -> b -> f a
12:57:02 <c_wraith> heh.  where return = const
12:57:29 <c_wraith> > return 5 7
12:57:30 <lambdabot>   5
12:58:12 <Nereid> heh
12:58:33 <mauke> preflex: quote mauke
12:58:33 <preflex>  <mauke> I used to have a 0 char solution, but then they fixed the judge program :-(
12:58:37 <mauke> no, wrong quote
12:58:59 <Nereid> I always fail to think of (->) a as a monad or anything :c
12:59:07 <idnar> haha
12:59:19 <idnar> (@ wrong quote)
13:00:03 <mauke> preflex: quote mauke
13:00:04 <preflex>  <mauke> eval: BEGIN{$^H {q}=sub:{my$ my=$ _[1];$ my!~ /\$/?$ my:sub: {my% my=@ _;(my$ my=$ my)=~s '\$(\w+)'$ my{$ 1}'eg;$ my}};$ ^H |=0x28000}  'my name is $name and im $age years old'->(age => 'ten pounds of flax', name => 'nanonyme')
13:00:09 <mauke> eek. I give up
13:00:17 <stepnem> What does '#' at start of line mean in literate Haskell? I'm getting an error when compiling an .lhs file containing such lines...
13:00:17 <EvanR-work> @quote explode
13:00:18 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
13:01:01 <EvanR-work> stupid quote thingy
13:10:36 <triyo> Got an "unification would give infinite type" error going through realworldhaskell book ch9: http://codepad.org/qDHu011H
13:10:49 <triyo> Could someone explain why this is the case?
13:12:54 <Saizan> you want "greaterP, lesserP :: (Ord a) => InfoP a -> InfoP a -> InfoP Bool"
13:13:37 <Eelis> if i want to request lambdabot's presence in another channel, who should i talk to?
13:13:48 <Saizan> Cale
13:13:55 <Eelis> thanks
13:15:15 <Eelis> Cale: would you be willing to make lambdabot join #geordi? it's the channel for the geordi C++ irc bot, written in Haskell (see http://www.eelis.net/geordi/ ). occasionally geordi's implementation and other Haskell things come up, and lambdabot would come in very handy to show these C++ folks some gentle Haskell
13:16:30 <triyo> Saizan: so is that a typo in the book? because the signature in book is "greaterP, lesserP :: (Ord a) => InfoP a -> a -> InfoP Bool"
13:17:30 <jmillikin> stepnem: '#' has no special meaning in literate haskell. What error are you seeing?
13:18:06 <ski> (.. maybe the file is meant to be processed with CPP first ?)
13:18:21 <stepnem> jmillikin: lexical error at character '\n'
13:19:04 <jmillikin> ski: that would be odd. tangling a literate file is normally performed before any other preprocessing step
13:19:20 <jmillikin> stepnem: could you paste the file somewhere?
13:24:18 <Saizan> triyo: i'd think so, have you checked the online version?
13:24:35 <triyo> yup I have, same problem
13:24:43 <Nereid> Eelis: @tell or @ask
13:25:09 <Eelis> Nereid: don't people use highlighting clients?
13:25:18 <Nereid> yes
13:25:27 <Eelis> then what's the point?
13:25:32 <Nereid> why not
13:25:32 <Nereid> :P
13:25:44 <Eelis> not a very convincing reason :)
13:27:09 <EvanR-work> what if he closes his client and isnt logging
13:27:46 <jutaro> k-klnb
13:27:50 <huin> what's a good book (dead tree variety) to learn haskell from? (given that i am familiar with Python, C-like languages, and somewhat with Erlang)
13:28:14 <voker57> @where lyah
13:28:14 <lambdabot> http://www.learnyouahaskell.com/
13:28:21 <Nereid> that's not dead tree variety
13:28:28 <Nereid> huin: RWH (Real World Haskell)
13:28:30 <EvanR-work> real world haskell?
13:28:31 <voker57> wasn't it printed?
13:28:40 <EvanR-work> are there other haskell books
13:28:44 <huin> yeah i was reading that online one, but generally find dead tree better for learning :)
13:28:54 <Nereid> huin: RWH has a print version
13:29:00 <voker57> ah, not yet.
13:29:04 <Xichekolas> huin: Programming in Haskell by Hutton if you are just getting started, RWH if you aren't
13:29:22 <stepnem> jmillikin: http://pastebin.com/ctCcigxL
13:29:45 <huin> i've done a bit of lyah in the past, FP isn't entirely new to me, but i'm not using it in anything as yet
13:30:19 <interferon> The automata article in the new monad reader is great
13:30:22 <huin> cool, thanks all :)
13:30:50 <interferon> Reminds me of the composablw contracts paper
13:31:01 <Baughn> @src (<*)
13:31:01 <lambdabot> (<*) = liftA2 const
13:33:06 <edwardk> huin: the o'reilly book: real world hakell is really good and is available in dead tree form
13:35:11 <EvanR-work> is the sequel going to be 'imaginary world haskell' sounds much more interesting
13:36:50 <jmillikin> stepnem: I've no idea why, but it looks like GHC isn't stripping out the "#" characters when it preprocesses the file. This might be worth reporting in the GHC bug tracker.
13:38:16 <uorygl> Aiee, the Reduceron is written in VHDL.
13:38:24 <stepnem> jmillikin: OK, I'll submit a report, thanks
13:38:59 <mreh> :t getElems
13:39:00 <lambdabot> Not in scope: `getElems'
13:39:08 <mreh> @hoogle getElems
13:39:08 <lambdabot> Data.Array.MArray getElems :: (MArray a e m, Ix i) => a i e -> m [e]
13:39:14 <uorygl> Why does it have 18 separate result outputs instead of just using a vector, I wonder.  I thought VHDL had vectors.
13:40:36 <triyo> I get this error now BetterPredicate.hs:19:46: Couldn't match expected type `Bool' against inferred type `FilePath -> Permissions -> Maybe Integer -> ClockTime -> Bool'
13:40:37 <edwardk> uorygl: lack of familiarity with the tools available to them?
13:40:39 <triyo> http://codepad.org/8D8oSWD0
13:40:42 <uorygl> I guess this code was not wrought by humans.
13:40:54 <edwardk> uorygl: or that
13:42:19 <mreh> I don't get why it was deemed worthy of making the OpenGL library have its own floating point types
13:42:53 <systemfault> Because you could have a platform without floats..
13:42:53 <mreh> there are no implementations of the kinds of interfaces you would expect, like MArray and the like
13:43:10 <mreh> systemfault: I'm talking about HOpenGL specifically
13:43:14 <systemfault> Ah ok :P
13:46:13 <edwardk> systemfault: yeah, but if they were type aliases rather than actual types you'd get what you need and still be able to mix them with unboxed containers, etc.
13:47:27 * triyo 's head is about explode 
13:47:30 <edwardk> with the assumption that on the few platforms without floats, (good luck compiling with ghc!) you can make up a suitable ieee floating point type for opengl and add support for the uarray machinery, etc.
13:48:04 <mreh> edwardk: you're talking to me?
13:48:33 <mreh> triyo: are you okay?
13:48:37 <mreh> need help?
13:48:49 <triyo> yes please. :(
13:48:54 <edwardk> mreh: well i was addressing systemfault's comment that you could have a platform without floats w.r.t the goofball hopengl glfloat machinery
13:49:03 <mreh> triyo: 1) use ghc, not hugs :)
13:49:03 <edwardk> so, indirectly, yes ;)
13:49:27 <mreh> edwardk: someone defended it, they thought it was more robust
13:49:33 <mreh> I didn't see how
13:49:38 <edwardk> meh
13:49:43 <triyo> I've been trying to get the realworldhaskell ch9 BetterPredicate to work, using ghc
13:49:45 <mreh> what? incase haskell's floating point types change?
13:49:55 <edwardk> i think it just actively gets in the way of using it with things like vector, array, etc.
13:50:04 <aavogt> in case opengl doesn't use the same floats
13:50:12 <edwardk> i appreciate the generality but the pain of that generality is hardly worth it
13:50:13 <triyo> Firstly, I'm running ghc 6.10.4
13:50:22 <edwardk> aavogt type GLFloat = ... would work just as well there
13:50:23 <triyo> and the example doesn't run out of the box
13:50:39 <edwardk> if its not the Float or Double on your platform add one that complies with it
13:50:50 <triyo> Here is my ver so far but now I am getting an error in http://codepad.org/8D8oSWD0
13:50:53 <mreh> triyo: your error is because haskell cant find the module you're trying to  import
13:51:10 <triyo> nope, thats the codepad compiler can't
13:51:20 <mreh> triyo: oh :)
13:51:35 <triyo> I'll paste the error
13:51:36 <mreh> triyo: use hpaste and paste the fully error there
13:51:41 <mreh> @hpaste
13:51:41 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:51:52 <mreh> that doesn't compile it
13:52:02 <aavogt> edwardk: then you can have a function  Double -> Double that only works where the opengl library has defined   type GLFloat = Double ...
13:52:09 <edwardk> aavogt: if you're working with opengl you're going to be tripping against performance bounds all over the place, not being able to use an unboxed container like UArray because some platform might exist some day and having to wait in an interactive graphical app while the garbage collector sweeps boxed arrays is silly
13:52:10 <mreh> or interpret it, or whatever
13:52:13 <triyo> http://codepad.org/KvmzHOO5
13:52:51 <triyo> thats obviously a type missmatch
13:53:08 <aavogt> edwardk: can't you put newtypes into unboxed arrays though?
13:53:12 <EvanR-work> edwardk: opengl isnt for just interactive graphics programs
13:53:18 <edwardk> aavogt: nope
13:53:41 <edwardk> EvanR-work: well, ok, well, for 90% of the use cases then ;)
13:54:38 <mreh> triyo, at a glance equalP doesn't have the right kind
13:54:38 <EvanR-work> opengl is supposed to work on someones high end graphics toaster with or without traditional floating point
13:54:56 <edwardk> EvanR-work: how many of those have haskell ported to them?
13:55:00 <EvanR-work> zero
13:55:05 <edwardk> EvanR-work: exactly
13:55:27 <mreh> haskell has a floating point type, so what's the big deal?
13:55:30 <EvanR-work> so i guess youre saying haskell isnt suitable for that situation
13:56:03 <mreh> let whoever is porting it sort it out!
13:56:11 <edwardk> EvanR-work: no, i'm saying that the choice of implementing GLFloat, etc as a newtype rather than a type needlessly blocks a ton of good usage scenarios
13:56:29 <kmc> hmm it shouldn't be impossible to stuff newtypes into a uarray
13:56:38 <kmc> perhaps by adding more instances of MArray or whatever?
13:56:39 <EvanR-work> that makes sense since ghc or whatever will have to figure out how to do floats anyway
13:56:54 <edwardk> kmc: yeah, i was thinking that a decent array type could be made that used some kind of Iso instance to wrap and unwrap
13:57:14 <edwardk> kmc: since in the case of most newtypes that Iso instance would vanish at runtime
13:57:20 <kmc> yeah
13:57:36 <mreh> Iso = isomorph?
13:57:41 <mreh> ic
13:57:55 <edwardk> class Iso a b where iso :: a -> b; osi :: b -> a -- or something like that
13:58:11 <scree> triyo: It's a bit hard since I can't try to compile your code, but what happens if that line is liftPath ((takeExtension ==? ".hs") &&? (sizeP >? 131072))
13:58:29 <edwardk> mreh: isomorphism, yeah
13:58:59 <edwardk> though in the array case more likely something like
14:00:51 <edwardk> class Newtype a where type Contents a :: *; wrap :: Contents a -> a; unwrap :: a -> Contents a; and a some kind of UNArray that uses the Newtype instance.
14:01:36 <triyo> scree: With this file, you can runghc: http://codepad.org/3o1BtzIA (RecursiveContents.hs) + http://codepad.org/8D8oSWD0 (BetterPredicate.hs)
14:01:52 <jimi_hendrix> newbie question: when is it advantageous to use type to create types and when is it advantageous to use data to create types?
14:02:20 <edwardk> instance (Newtype a, IArray (UArray (Contents a))) => IArray UNArray a where ...
14:02:45 <triyo> scree: runghc BetterPredicate.hs ~/
14:02:51 <Olathe> Use data when you want to create some sort of structure, use type when you just want to use an existing type with a new name.
14:02:53 <scree> triyo: thanks, and ignore that last one (it being rubbish)
14:03:02 <edwardk> jimi_hendrix: if you might ever want to  instantiate a typeclass on it. use a newtype
14:03:11 <edwardk> jimi_hendrix: if you're just abbreviating something, use a type
14:03:21 <triyo> scree: ok thx
14:03:48 <scree> triyo: Ahhh
14:03:51 <jimi_hendrix> edwardk, and for data?
14:04:14 <scree> triyo: you need (const . const . const $ const 131072)
14:04:32 <edwardk> jimi_hendrix: use a newtype where possible, (single constructor single value, no strictness limitations) and a data type when you need to have more than one field, GADT features or multiple constructors
14:04:47 <scree> triyo: or better still, write an alias for (const . const . const . const) of type (a -> InfoP a)
14:04:50 <lispy> I prefer newtype over type (usually) because newtype makes a distinct type so I can help encode program invariants :)
14:04:51 <kmc> jimi_hendrix, example: if i were writing an RPG, i might have a type for hit points and a type for gold.  if i used 'type' they'd be mere synonyms for Int, and I could accidentally add someone's gold and HP together, when that's probably nonsense
14:05:13 <scree> triyo: no, that's rubbish too
14:05:21 <triyo> scree: hmm :)
14:05:22 <kmc> jimi_hendrix, so you'd use 'data' to make it a distinct type with wrapping and unwrapping
14:05:26 <kulin> kmc, it depends, insurance companies do that all the time
14:05:30 <edwardk> kmc: newtype please ;)
14:05:33 <kmc> haha kulin
14:05:35 <kmc> edwardk, getting to that ;)
14:05:42 <jimi_hendrix> kmc, where wrapping and unwrapping means?
14:05:52 <edwardk> newtype Gold = Gold Int
14:05:54 <kmc> jimi_hendrix, that the "newtype" introduces a new data constructor which you apply and pattern-match
14:06:04 <jimi_hendrix> kmc, i see (wrt to hp and gold)
14:06:09 <edwardk> or newtype Gold = Gold { getGold :: Int } -- Gold 'wraps' an Int, and getGold unwraps it
14:06:20 <scree> triyo: hang on, I think this one is right:
14:06:27 <scree> triyo: what is the expected type of andP?
14:06:59 <scree> triyo: I *think* you've implemented InfoP Bool -> Bool -> InfoP Bool but want InfoP Bool -> InfoP Bool -> InfoP Bool
14:07:07 <jimi_hendrix> so wrapping basically shields the type
14:07:30 <triyo> that must be the liftP
14:07:32 <kmc> jimi_hendrix, so "type" doesn't really introduce a new type -- just a new name for an existing type, and the type checker will let you mix the synonym with its meaning freely, which means you don't get any additional checking
14:07:38 <kmc> jimi_hendrix, so that's the choice between "type" and "data"
14:07:59 <kulin> type is just an alias to a type, data is a new type
14:08:01 <kmc> jimi_hendrix, then you can think of "newtype" mostly as a more space- and time-efficient version of "data", which is applicable only in certain cases
14:08:04 <edwardk> jimi_hendrix: yes, you can ask to borrow some of the functionality of the underlying type with newtype, but instances you don't ask for won't be copied over. so if you wanted to 'show' gold differently than an Int, you could
14:08:20 <kmc> jimi_hendrix, which is to say, you can use "newtype" instead of "data" when you have only one constructor with one field
14:08:50 <triyo> scree: I think you are right. :) However, now I get: BetterPredicate.hs:62:0: Occurs check: cannot construct the infinite type
14:09:23 <edwardk> operationally you can view each 'data' constructor as a box that holds onto all of its fields. newtypes on the other hand, vanish at compile time, so working with Gold can have the same efficiency as working with Int.
14:09:26 <kmc> so e.g. in the Gold example above, we're only using the type for static checking, but at execution time it should be equivalent to Int and the wrapping should have no runtime cost.  newtype does that
14:09:32 <triyo> scree: http://codepad.org/xy0esjgj
14:10:19 <triyo> Ohh hang on, need one more change
14:10:25 <kmc> jimi_hendrix, this means you can also do things like newtype Foo = Foo (Int,Int).  but you'd probably want the simpler type data Foo = Foo Int Int.  in other words, "newtype" buys you nothing when you introduce an extra layer of wrapping to use it
14:10:26 <triyo> greaterP, lesserP :: (Ord a) => InfoP a -> InfoP a -> InfoP Bool
14:10:32 <jimi_hendrix> ok
14:11:00 <jmcarthur> i can think of reasons to prefer the former though
14:11:01 <triyo> scree: now I see I deff got somewhere. One more error though. No instance for (Num (InfoP Integer)) arising from the literal `131072' at BetterPredicate.hs:19:55-60
14:11:07 <FunctorSalad> had an idea the other day... wouldn't holes be greatly useful and easy to add in ghci?
14:11:12 <scree> triyo: you'll need a constP at the top
14:11:28 <jmcarthur> for example, you might already have some handy functions for operating on tuples, or perhaps you want to use GeneralizedNewtypeDeriving to use some existing type class instances on tuples
14:11:28 <scree> triyo: constP 131072
14:11:29 <jimi_hendrix> i see
14:11:32 <edwardk> kmc: to be pedantic sometimes newtype Foo = Foo (Int,Char) -- or its ilk are slightly better than the corresponding data -- when you plan to supply such a conversion function to a pair, the data version has to rebox the newtype will get potentially increased sharing
14:11:41 <FunctorSalad> (variables undefined at the time you enter the statement, with support for filling them in in the lines after that)
14:11:56 <kmc> hmm, that's a good point edwardk
14:12:05 <FunctorSalad> it would play on haskell's strength of just-put-the-types-together...
14:12:19 <edwardk> kmc: i've seen it time and again when playing with catamorphisms, etc.
14:12:44 <triyo> scree: error -> http://codepad.org/Ir1Kgw8b
14:13:05 <FunctorSalad> (all the type machinery is already in place through implicit params...)
14:13:27 <FunctorSalad> ghci should just push these params on a stack as obligations instead of erroring out
14:13:43 <scree> triyo: the dreaded monomorphism restriction strikes again
14:13:46 <jmcarthur> it's not normally what you want, but it's also significant that pattern matching on data Foo = Foo !Int will force the Int, whereas pattern matching on newtype Foo = Foo Int will not
14:13:53 <edwardk> FunctorSalad: get hacking then ;)
14:13:59 <copumpkin> :O
14:14:02 <triyo> scree: please explain :(
14:14:16 <scree> @where monomorphism
14:14:16 <lambdabot> I know nothing about monomorphism.
14:14:19 <scree> hmm
14:14:43 <triyo> hehe
14:14:44 <scree> triyo: essentially the compiler is getting unhappy because you haven't supplied explicit type signatures for some of your functions
14:14:44 <FunctorSalad> edwardk: hmm by modifying ghci?
14:14:51 <edwardk> FunctorSalad: yeah
14:14:57 <scree> triyo: you have two options
14:15:00 <FunctorSalad> haven't seen its code
14:15:02 <FunctorSalad> I should
14:15:12 <jmcarthur> and if you try case undefined of _ -> "foo", the data version will be _|_ but the newtype version will be "foo"
14:15:18 <jmcarthur> actually
14:15:22 <scree> triyo: 1) tell the compiler to behave using {-# LANGUAGE NoMonomorphismRestriction #-} at the top
14:15:26 <jmcarthur> case undefined of Foo _ -> "foo"
14:15:38 <scree> triyo: 2) Add explicit type signatures to all your functions
14:16:08 <scree> triyo: the prevailing view is that the Monomorphism Restriction is BAD but you should put in type signatures anyway because it's good style
14:16:13 <triyo> scree: fair enough
14:16:23 <ezyang> :t flip id
14:16:23 <lambdabot> forall a b. a -> (a -> b) -> b
14:16:33 <ezyang> mmm.
14:16:38 <copumpkin> mmm indeed.
14:16:49 <jmcarthur> the MR was introduced to prevent some potentially confusing behavior regarding evaluation, but it usually just gets in the way
14:16:57 <scree> triyo: (specifically, manual type signatures would have made your above compile errors /slightly/ easier to debug)
14:16:59 <triyo> scree: works by the way. thank you
14:17:13 <scree> triyo: pleasure
14:17:20 <FunctorSalad> wouldn't bake them in *too* early, or you'll have to delete again for refactoring
14:17:24 <aavogt> oftentimes manual type signatures make compile errors harder to solve
14:17:34 <triyo> I agree about debugging comment. However, I was following the "Real world haskell" book :
14:17:37 <aavogt> since that's one more place where you get to contradict yourself
14:17:38 <FunctorSalad> you can partially fix type with pattern sigs or `isTypeOf` etc
14:17:43 <FunctorSalad> *types
14:17:50 <ezyang> But if you are good at writing types, they help localize type errors.
14:18:02 <FunctorSalad> ezyang: granted
14:18:07 <FunctorSalad> that's the other side
14:18:55 <aavogt> they might not be as general as possible, which might prevent you from reusing some code
14:19:25 <edwardk> i for one don't mind the MR , its absence can cause loss of sharing and blow up asymptotics in ways you don't expect
14:19:40 <FunctorSalad> aavogt: they should be if they're what ghci says and you haven't broken HM through extensions, I thought
14:19:59 <FunctorSalad> and you haven't refactored earlier functions...
14:20:04 * copumpkin proposes the epimorphism restriction
14:20:16 <edwardk> copumpkin: how.. epic
14:20:22 <copumpkin> indeed!
14:20:34 <copumpkin> epic misunderstanding of the meaning of monomorphism, at least :)
14:20:55 <FunctorSalad> copumpkin: that misunderstanding actually got me in the beginning
14:20:58 <edwardk> true, you'd need a megamorphism restriction ;)
14:21:01 <FunctorSalad> having seen ct before haskell
14:21:32 <maltem> it could be called the polymorphism restriction
14:21:39 <ezyang> i,i megalomorphism
14:21:56 <edwardk> if the compiler can't think of at least 20 types, it throws it back at you and calls it rubbish.
14:22:16 <FunctorSalad> btw  is a monotype just without variables? or also base kind
14:22:18 <aavogt> FunctorSalad: if you're just inserting the inferred type signatures at random, how does that help you track down where the actual error is?
14:22:32 <aavogt> @google polytope
14:22:34 <lambdabot> http://en.wikipedia.org/wiki/Polytope
14:22:34 <lambdabot> Title: Polytope - Wikipedia, the free encyclopedia
14:22:54 <ezyang> :-( Sifflet doesn't install on my comp; probably not recent enough gtkhs
14:22:59 <FunctorSalad> aavogt: I don't do a single pass of type sig insertion / compiling :)
14:23:13 <FunctorSalad> in the iterated variant it bakes in the known-good part
14:23:25 <aavogt> true
14:23:27 <FunctorSalad> which may still have to change though as you said
14:25:02 <FunctorSalad> apropos ghci... wouldn't it be neat if :def accepted String -> GHC String
14:25:07 <FunctorSalad> rather than String -> IO String?
14:25:14 <FunctorSalad> (Or Ghcm or what it was)
14:25:21 <aavogt> that would be neat
14:25:37 <aavogt> ghci isn't actually that much code
14:25:43 <FunctorSalad> user-defined functions could modify the environment and so on then
14:25:51 <FunctorSalad> or look at the history
14:26:23 <FunctorSalad> currently I think there's no way for a :def function to call other ghci functions, *AND* read the result)
14:26:54 <FunctorSalad> since :def has macroexpansion semantics, you can produce a ghci-function like :module ...
14:27:00 <FunctorSalad> but not read from it I think
14:28:44 <FunctorSalad> except if you demand that the user run ghci wrapped in `tee', and ... *mad*
14:30:11 <jimi_hendrix> two more quick question: is there a built-in to shuffle an array? and what is the best way to format output?  iirc, concat operators require iterating to the end of the string
14:30:28 <EvanR-work> @hoogle shuffle
14:30:28 <lambdabot> No results found
14:30:29 <copumpkin> no, and shuffling is actually not trivial
14:30:35 <copumpkin> there's some interesting stuff on it
14:30:52 <copumpkin> shuffling efficiently, that is
14:30:57 * copumpkin tries to remember where to find it
14:30:59 <EvanR-work> jimi_hendrix: Text.Printf
14:31:11 <EvanR-work> copumpkin: its called Shuffle i think
14:31:14 <EvanR-work> hackage
14:31:26 <jimi_hendrix> EvanR-work, ok
14:31:38 <FunctorSalad> copumpkin: for i=1 to n; swap(cell(i), cell( ... uniform random in i, n ... ))
14:31:41 <FunctorSalad> that one?
14:31:49 <copumpkin> well
14:31:57 <FunctorSalad> I love that one ;)
14:31:59 <copumpkin> first of all is that actually uniform?
14:32:08 <copumpkin> and second it doesn't really work with haskell idiomatically :P
14:32:10 <FunctorSalad> even imperative as it is
14:32:25 <FunctorSalad> copumpkin: yeah, but not totally obviously so
14:32:33 <FunctorSalad> "for symmetry reasons" ;)
14:32:39 <copumpkin> oh, from i to n
14:32:52 <FunctorSalad> or inductively: the first element is uniform
14:33:03 <copumpkin> yeah, I misunderstood the notation
14:33:05 <FunctorSalad> and a permutation is first element + one-smaller permutation...
14:33:09 <soupdragon> Why did a bunch of people just get K-Lined
14:33:09 <soupdragon> ?
14:33:24 <EvanR-work> for any reasonable rng, you can produce a reasonable list size that cant be shuffled uniformly using that rng as a source
14:33:27 <copumpkin> soupdragon: probably some mistake and an overly broad hostmask
14:34:07 <EvanR-work> since the number of permutations is n!
14:34:17 <copumpkin> here, http://okmij.org/ftp/Haskell/perfect-shuffle.txt
14:34:28 <FunctorSalad> EvanR-work: you mean prng I think ;)
14:34:31 <EvanR-work> i read that an looked for this issue
14:34:37 <EvanR-work> FunctorSalad: yeah
14:34:46 <FunctorSalad> (I mean, in this case it does matter)
14:35:07 <EvanR-work> a perfect rng isnt reasonable is it!
14:35:40 <copumpkin> philosophically, does perfect randomness exist?
14:35:59 <EvanR-work> philosophical shmilophsoical
14:36:06 <hpc> yes
14:36:13 <hpc> collapse an unknown wavefunction
14:36:24 * EvanR-work invokes bohmian
14:36:41 <FunctorSalad> copumpkin: relatedly: assuming it doesn't, why are lower-order bits of ... basically any measurement at all ... random for all intents and purposes?
14:36:54 <copumpkin> random for all intents and purposes
14:37:04 <FunctorSalad> that one is a bit deeper IMHO than the one about real ultimate reality ;)
14:37:18 <copumpkin> unknowable, but is it actually random? :P
14:37:21 <FunctorSalad> which becomes just "we couldn't ever tell, even in principle"
14:38:03 <FunctorSalad> copumpkin: I meant even if we assume perfect determinism, how do you convince someone that the lower-order bits are not God's will?
14:38:15 <EvanR-work> hpc: collapsing an unknown wavefunction is sort of like having an infinite number of monkeys typing for eternity, no need to insist on both ;)
14:38:16 <FunctorSalad> HUGE hideout for the gods of the gaps there
14:38:31 <EvanR-work> a known composite wavefunction is all you need to get random
14:38:56 <EvanR-work> FunctorSalad: they can stay in there for all i care. just make sure they dont come out ;)
14:38:59 <FunctorSalad> that's just an abstraction about an as of now underlying reality on a smaller scale, isn't it?
14:39:08 <FunctorSalad> (quantum mechanics)
14:39:37 <EvanR-work> there are competing technical, non emotional, views on that
14:39:53 <EvanR-work> where the winning one is 'no'
14:40:18 <soupdragon> copumpkin what does random mean
14:40:20 <soupdragon> err
14:40:29 <soupdragon> hey arcatan
14:40:33 <soupdragon> what's happened?
14:40:34 <FunctorSalad> I don't know QM well enough to tell, but it seems impossible in principle to ever come to the conclusion that there isn't yet another layer of reality
14:40:44 <soupdragon> I just mentioned to freenode that you got K-Lined and that it might have been a mistake
14:40:45 <FunctorSalad> must be some hidden assumption :)
14:40:59 <soupdragon> arcatan ^
14:41:12 <c_wraith> What's the equivalent of the runtime system for collapsing wave functions?  That is, what's the mechanism that ultimately causes waveform collapse that isn't just another waveform collapse event?
14:41:17 <EvanR-work> FunctorSalad: well, there is the no hidden variables theorem. if you can define 'more reality' as hidden variables, and you abide by the assumptions, then you can use logic and experimental evidence to show they dont exist
14:41:36 <ddarius> For a certain class of "hidden variable theories"
14:41:42 <EvanR-work> abiding by the assumptions is the sticky point that some fringe people still cling to
14:41:59 <kar-1> there are no _local_ hidden variables
14:42:08 <soupdragon> ding
14:42:12 <FunctorSalad> EvanR-work: I've hear of that theorem but from all I know about both logic and experiments, there's always a loophole that hasn't been ruled out rigorously yet
14:42:22 <EvanR-work> yes
14:42:25 <EvanR-work> non local hidden variables
14:42:37 <soupdragon> why isn't he responding
14:42:47 <FunctorSalad> mind you, I'm *not* thinking that all my favourite fantastic creatures are hiding there ;)
14:42:52 <copumpkin> soupdragon: he's probably idle
14:42:59 <soupdragon> huh
14:43:02 <soupdragon> that's weird
14:43:06 <soupdragon> I guess that fits in thuogh
14:43:09 <soupdragon> with the hypothesis
14:43:09 <copumpkin> some clients keep trying to reconnect
14:44:19 <ddarius> kar-1: For a certain class of "hidden variable theories"
14:44:23 <ddarius> http://bayes.wustl.edu/etj/articles/cmystery.pdf
14:44:33 <Peaker> If adding an axiom about the law of excluded middle restores classical logic -- is it ok to say dependent types aren't really limited to just intuitionistic logic?
14:45:06 <soupdragon> Peaker: intuitionist logic has classical logic as a subset
14:45:18 <soupdragon> Peaker, the reason we don't use it is because it sucks
14:45:34 <Peaker> soupdragon, oh, I thought it was the other way around
14:45:37 <soupdragon> but if you want to do e.g. classical analysis in a dependent type theory you can just do it no trouble
14:46:10 <Peaker> soupdragon, cool. Why do you say it sucks?
14:46:15 <copumpkin> Peaker: the axioms of intuitionist are a subset of those of classical, meaning you can fit classical into it
14:46:26 <soupdragon> Peaker you can't compute things with it
14:46:41 <soupdragon> e.g. if you prove a classical existence proof, generally you can't extract a witness
14:46:50 <FunctorSalad> Peaker: maybe the way in which type theory + LEM seems "richer" than ordinary classical logic to you is simply that TT is higher-order
14:47:03 <FunctorSalad> in contrast to first-order classical PL
14:47:24 <Peaker> soupdragon, When is a witness really important?
14:47:32 <FunctorSalad> in some ill-defined sense of "higher-order"... not quite the same thing as extensional functions and sets, I guess
14:47:36 <soupdragon> uh
14:47:50 <soupdragon> you know when you run a computer program and it prints out an answer
14:48:01 <soupdragon> if the program was classical, then it would print "THE ANSWER" rather than the answer
14:48:21 <copumpkin> Peaker: there exists a natural number x such that x^2 = 25
14:48:22 <Peaker> Well, I'd guess you often wouldn't want a witness - it would be enough that something is true
14:48:23 <copumpkin> classical = yep
14:48:31 <FunctorSalad> soupdragon: I think you mean 'superset', not 'subset'? if the set in question is the set of provables
14:48:38 <copumpkin> intuitionust = 5
14:48:49 <ddarius> intuitionist = -5
14:48:51 <soupdragon> FunctorSalad, I mean it lives inside intuitionist logic
14:49:38 <FunctorSalad> Peaker: that's what I keep saying... even in CS at some level you want intangible properties
14:50:01 <FunctorSalad> i.e., "this will work as it should" ;)
14:50:02 <monochrom> w00t intuitionistic logic!
14:50:07 <copumpkin> ddarius: that looks unnatural to me!
14:50:11 <Peaker> If you know P=NP, there's probably a bunch of consequences even without a witness :)
14:50:12 <copumpkin> you can't have negative apples!
14:50:19 <ddarius> Peaker: For proof irrelevant parts of the language, it would be fine to not have a witness.
14:50:51 <Peaker> copumpkin, where are those apples you owe me?
14:50:53 <ddarius> Peaker: Yes, but having a witness would be way, way more useful (theoretically)
14:51:03 <copumpkin> Peaker: in my tummy, now stfu and give me more apples
14:51:25 <FunctorSalad> Peaker: one gets to the limits of falsfiability there... when you have proven that the program will terminate eventually, that's unfalsifiable empirically... but still seems like a meaningful fact
14:51:27 <monochrom> copumpkin is a sunk cost and lost cause
14:51:33 <copumpkin> :P
14:51:40 <aristid> and a poor credit
14:51:42 <FunctorSalad> (if you don't have a computable bound)
14:51:42 <copumpkin> :(
14:52:42 <ddarius> copumpkin :: Fruit -> R
14:52:55 <soupdragon> I read yesterday someone showed that if you proved P vs NP was independent of PA then you'd have an almost polynomial time algorithm for NP problems :P
14:53:06 <monochrom> nice
14:53:32 <Peaker> "almost polynomial" meaning..?
14:54:19 <FunctorSalad> soupdragon: but is this the result where we already have the algo? and the premise is only to prove that it does in fact fulfill its specification
14:54:26 <Cale> I wonder if there are any problems for which there are provably terminating solutions, but for which no particular complexity bound could ever be proven.
14:54:48 <FunctorSalad> Cale: that made me pause for a bit too
14:54:53 <copumpkin> O(BB(n))
14:55:05 <FunctorSalad> but for my statement "don't have one in practice" suffices ;)
14:55:11 <kar-1> Peaker, think about the negation of Goldbach's conjecture: "there is a even number larger than 2 that cannot be expressed as a sum of two primes".. if you prove this with classical logic using proof by contradiction, it does _not_ mean that a while loop testing all possible even numbers starting from 4 will eventually halt.. if you interpret classical proposition A intuitionistically, it just means that it would be contradictory to ...
14:55:17 <kar-1> ... derive a contradiction from A or maybe "it could be so"
14:55:25 <Cale> Yeah, even O(BB(n)) is fine in this sense :)
14:55:27 <copumpkin> all algorithms are O(BB(n)) I'd assume
14:55:38 <Cale> ah, hmm
14:55:50 <copumpkin> how about theta though
14:56:06 <c_wraith> I guess that's true by definition.
14:56:07 <copumpkin> :P
14:56:13 <Cale> right, okay. Lovely thing about the naturals that.
14:56:43 <FunctorSalad> Cale: now that I think about it, "terminates for all inputs of all sizes n" isn't even falsifiable if you do have a bound depending on n
14:56:48 <FunctorSalad> (even constant)
14:56:52 <FunctorSalad> so what was I thinking...
14:57:04 <jbapple> kar-1: How do you know? I ask because there are whole classes of propositions for which classical proofs can be turned into constructive ones
14:57:18 <FunctorSalad> Cale: and for a single input, there has to be a proof of termination, right? the execution trace
14:57:35 <Peaker> What's BB(N)?
14:57:38 <FunctorSalad> oh sorry, above stmt is falsifiable
14:57:40 <ddarius> Busy Beaver
14:57:45 <FunctorSalad> just not verifyable
14:58:01 <FunctorSalad> (it is falsifiable if you have a computable bound)
14:58:25 <Cale> Actually, that's a good point, is BB(n) really the number we want here?
14:58:38 <kar-1> jbapple, I meant that it could halt, but it is not yet proven
14:58:40 <copumpkin> nope
14:58:46 <Cale> The n in BB(n) refers to the number of states in the Turing machine.
14:58:50 <copumpkin> yeah
14:58:52 <Peaker> Nice idea, BB
14:59:08 <copumpkin> a BB machine gun is something you don't want to mess with
14:59:12 <FunctorSalad> Cale: but a given machine to compute all of BB has only so many states too
14:59:24 <Peaker> "grows faster asympt. than any computable function".. strictly faster than ackermann..
14:59:58 <Cale> FunctorSalad: It's not computable
15:00:05 <Cale> BB(n) isn't a computable function
15:00:08 <jbapple> kar-1: What I'm saying is that is is possible that any FOL yet classical proof of anti-Goldbach's unfolds into a constructive proof. I think you can sometimes tell this by the shape of the theorem, rather than the proof
15:00:11 * copumpkin can compute it
15:00:12 <jbapple> Let me try to find a ref.
15:00:19 <copumpkin> but then again, I'm more powerful than a TM
15:00:24 <FunctorSalad> Peaker: if your proposed machine has n states, it would be an immediate contradiction if it produces the right result for BB(n+1)
15:00:27 <ddarius> copumpkin: Prove it.
15:00:38 <Cale> I'm less powerful than a TM
15:00:38 <FunctorSalad> (wasn't there some less trivial part in that general anecdote?)
15:00:47 <Cale> I'm pretty sure that I'm no more powerful than a DFA.
15:00:51 <Cale> ;)
15:00:56 <FunctorSalad> depends
15:01:00 <copumpkin> star-free cale
15:01:00 <FunctorSalad> more powerful than some
15:01:11 <FunctorSalad> just not all of them
15:01:12 <FunctorSalad> ;)
15:01:23 <FunctorSalad> they just keep coming
15:01:48 <tromp> cale+unlimited tape is as powerful as a tm
15:01:56 <kar-1> jbapple, I don't know but I don't consider the classical proof as a proof of termination of that program
15:02:20 <Cale> tromp: I'll eventually die though.
15:02:22 <Peaker> Is there: type Endo a = a -> a   anywhere?  And Endo2 a = a -> a -> a ?
15:02:25 <tromp> a tm with limited lifespan:)
15:02:27 <Peaker> I find it super-useful, all the time
15:02:29 <EvanR-work> Cale: maybe, maybe not
15:02:37 <aristid> Cale: not if you experience the singularity
15:02:38 <FunctorSalad> Peaker: Data.Monoid, but newtype
15:02:40 <ddarius> Peaker: There's an Endo newtype.
15:02:40 <Peaker> atSomeAttribute :: Endo Attribute -> Endo Container
15:02:41 * EvanR-work sends transhumanists to Cale's house, YOU CANT DIE
15:02:43 <jbapple> kar-1: I understand that the classical proof by itself might not convince you.
15:02:46 <Peaker> Yeah, a newtype sucks..
15:02:53 <kmc> Endo2 is sort of a misnomer
15:03:02 * ddarius agrees with kmc.
15:03:11 <Peaker> How do you call   a -> a -> a ?
15:03:15 <jbapple> kar-1: What I'm saying is that there is a procedure for automatically turning some classical proofs into constructive ones
15:03:20 <kmc> binary operation?
15:03:25 <jbapple> http://www.doc.ic.ac.uk/~svb/CLaC08/
15:03:27 <kmc> it's like the operation of a monoid
15:03:29 <Peaker> kmc, that's a -> b -> c
15:03:33 <kmc> higher-kinded newtypes are first class in a way higher-kinded type synonyms aren't
15:03:37 <soupdragon> a -> a -> a <----- contraction
15:03:43 <ddarius> You could call it a closed binary operation if you wanted to emphasize.
15:03:54 <kmc> @djinn a -> (a -> a)
15:03:54 <lambdabot> f _ a = a
15:03:59 <Cale> If all else fails, the heat-death of the universe will sweep me away.
15:04:20 <jbapple> (kar-1: that's just a place to start)
15:04:20 <matt_m> kar-1:  Why wouldn't you consider a non-constructive proof of the existence of an example P(n) to be proof of termination of a program that goes looking for n such that P(n)?
15:04:27 <Peaker> I want a type synonym for declarations such as:
15:04:28 <mreh> what's all this #ifdefine (..) in haskell source? CPP?
15:04:38 <Peaker> inMyNewType2 f = inMyNewType . f . unMyNewType
15:04:39 <FunctorSalad> Cale: then you'll wake up somewhere with someone telling you "haha, another round :p"
15:04:48 <Peaker> inMyNewType2 :: Endo2 Inner -> Endo2 Outer
15:04:52 <lispy> mreh: right
15:04:53 <Peaker> What do you propose to call Endo2?
15:04:54 <FunctorSalad> (not a representation of my religion)
15:05:05 <FunctorSalad> just a funny picture...
15:05:10 <lispy> mreh: it's incredibly pragmatic :)
15:05:14 <Cale> I should work on a way to implement my mind in a setting of reversible computing
15:05:16 <ddarius> Cale: If the universe is not infinite, then the blackhole formed by the collapsing tape will get you first.
15:05:33 <mreh> my godfather was talking about reversible computing
15:05:36 <FunctorSalad> (wouldn't it suck if you wait all that time until the heat death, for nothing)
15:05:41 <mreh> I have no idea what it is
15:05:46 <lispy> FunctorSalad: haha
15:05:49 <kar-1> matt_m, I simply believe that there are some sentences A that can be proven, sometimes their negation ~A can be proven and sometimes neither
15:05:50 <Peaker> ddarius, ClosedBinaryOp  is a long type synonym :)
15:05:53 <FunctorSalad> :)
15:06:04 <ddarius> Peaker: Maybe don't use a type synonym...
15:06:10 <Cale> Yeah, that's an interesting thing to consider. The fate of a universe with essentially nothing but an infinitely long tape in it.
15:06:11 <jbapple> kar-1: http://www.cs.cornell.edu/Info/Projects/NuPRL/documents/Murthy/ExtractingConstructiveContent.html
15:06:32 <Peaker> ddarius, Then I have stuff like:  (ExpandingRect -> ExpandingRect -> ExpandingRect) -> (Rect -> Rect -> Rect)   rather than:  Endo2 ExpandingRect -> Endo2 Rect
15:06:36 <jbapple> "Kreisel and Friedman showed that for certain classes of sentences (\Pi_{2}^{0}), the classical theories conservatively extend their constructive counterparts, and furthermore give effective translations from classical proofs to constructive proofs."
15:06:46 <EvanR-work> well the expanding universe would rip the thing in two
15:06:50 <EvanR-work> or more
15:07:07 <matt_m> kar-1:  Isn't that just Godel's incompleteness theorem?   It sounds like you believe that some classical logic isn't omega-consistent
15:07:12 <ddarius> Peaker: And people will know what you mean.
15:07:41 <matt_m> kar-1: well, something similar to that
15:07:41 <mreh> I'm sure i've asked this before, but can I define an orphan deriving clause?
15:07:48 <Peaker> ddarius, That will also hold true if there's a commonly used type syn :)
15:07:51 <c_wraith> mreh: there's an extension that allows it
15:07:55 <Cale> Would it though? The zero-point pressure is really not much vs. the electric force.
15:07:55 <FunctorSalad> mreh: generalizednewtypederiving
15:08:02 <mreh> ah yes
15:08:05 <Peaker> ddarius, I think it's more readable to read Endo2 pretty quickly, the structure is easier to find
15:08:06 <c_wraith> mreh: standalonederiving
15:08:11 <FunctorSalad> mreh: c_wraith
15:08:12 <mreh> yes that one
15:08:16 <FunctorSalad> (was right)
15:08:26 <mreh> I figured his would work better
15:08:29 <mreh> thanks
15:08:34 <kmc> jbapple, cool
15:08:54 <FunctorSalad> thought "some newtype thingy" would be precise enough as the lookup key in my mental set of known pragmas
15:09:18 <jbapple> goldbach is (forall a, exists p q, p+q = a /\ prime p q). I don't think the negation of this is PI_2^0, but I also don't know if PI_2^0 is an upper bound
15:10:06 <kmc> this is the \Pi of the arithmetical hierarchy?
15:10:35 <FunctorSalad> jbapple: no idea either but at least some of these have places in the hierarchy where you actually need some number theory to see it, IIRC ;)
15:10:42 <FunctorSalad> not sure which one of the famous ones was it
15:10:52 <kmc> so Pi_2^0 would be forall x. exists y. phi(x,y) ?
15:11:05 <roconnor> Pi^0_2
15:11:27 <kmc> yeah
15:11:34 <gwern> I wonder what the most unexpected undecidable result is; most of the ones I know of seem to whiff of self-referentiality or oddness
15:11:41 <FunctorSalad> just has to be equivalent to one of that form though
15:11:48 <FunctorSalad> otherwise it'd be easy ;)
15:11:50 <roconnor> jbapple: you can bound the existential quatifiers
15:12:03 <roconnor> jbapple: forall a, exists p q <= a, p+q = a /\ prime p q
15:12:05 <jbapple> FunctorSalad: what is "to see it"? and what "are these" that have places in the heirarchy? I think I missed all of your antecedents.
15:12:17 <soupdragon> gwern, parallel postulate
15:12:21 <kmc> gwern, the post correspondence problem and the word problem for groups were two early examples that startled people this way
15:12:27 <tromp> goldbach is PI_1
15:12:37 <Philonous> The statement is clearly false, though. I doesn't hold for a=11
15:12:37 <gwern> soupdragon: that's not unexpected though is it?
15:12:38 <tromp> since the exists is bounded
15:12:48 <FunctorSalad> jbapple: "these" as in "theorems, often of number theory, which have featured in more philosophical debates" ;)
15:12:51 <soupdragon> gwern - :S
15:12:53 <FunctorSalad> or logical
15:13:02 <gwern> kmc: post correspondence problem - showing post machines were turing complete?
15:13:13 <kmc> this one http://en.wikipedia.org/wiki/Post_correspondence_problem
15:13:15 <roconnor> gwern: airplane fares are undecidable in general
15:13:49 <gwern> roconnor: hm. I'll admit, I don't see that one
15:13:51 <jbapple> roconnor: I do not understand why one ought to bound p and q like that.
15:14:12 <roconnor> jbapple: you don't have to, but it does make the statment Pi_1.  Presumably you are intrested in the lowest complexity
15:14:21 <FunctorSalad> jbapple: and "to see" that a given statement is equivalent to one with lesser apparent rank, at face value
15:14:40 <roconnor> jbapple: and the two formulations are provably equivalenet
15:14:47 <jbapple> roconnor: I am. I will have to think about why that makes the statement Pi_1
15:15:01 <roconnor> jbapple: bounded quantifers are free
15:15:20 <jbapple> roconnor: Good to know
15:15:29 <roconnor> because given an a, you can now bound the search for p and q
15:15:42 <roconnor> which makes something that was semi-decidable into something decidable
15:16:30 <matt_m> It's decidable whether a given n is a counterexample to Goldbach.  I still dont' understand kar-1's comments
15:16:43 <roconnor> gwern: maybe if you read all the rules for airplane fares, you won't find it surprising they are undecidable
15:16:44 <jbapple> So, if I understand all of this correctly, GC \in Pi_1, so ~GC \in Pi_2, so proofs using LEM can be turned into proofs not using LEM?
15:17:02 <roconnor> ~GC is even Sigma_1
15:17:21 <kar-1> matt_m, with proof by contradiction, you could prove that such n exists without constructing  it
15:17:25 <roconnor> but yes, all proofs of GC are constructive proofs (more or less)
15:17:27 <gwern> roconnor: what's undecidable about them, actually? comparing 2 for cheapness? finding the cheapest ticket from one airport to the next? finding cheapest route?
15:17:41 <matt_m> kar-1:  Yes, but then a search for n would eventually yield it, right?
15:17:48 <roconnor> gwern: whether you can take route X for price Y or not
15:18:01 <kar-1> matt_m, I don't believe that unless you prove that :)
15:18:10 <jbapple> So a classical proof of ~GB could be turned into a counterexample
15:18:24 <roconnor> matt_m: is correct
15:18:30 <roconnor> jbapple: yes
15:18:41 <roconnor> as matt_m says you just search and it will terminate
15:18:52 <matt_m> kar-1:  So you believe classical logic may be omega-inconsistent
15:19:13 <matt_m> kar-1:  P 0, P 1, P 2, etc. are all false, but we can still prove (exists n. P n)
15:19:32 <jbapple> As I understand it, this is somewhat like the situation with Skewes number.
15:19:47 * hackagebot redis 0.6 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.6 (AlexanderBogdanov)
15:19:50 * hackagebot Hermes 0.0.1 - Message-based middleware layer  http://hackage.haskell.org/package/Hermes-0.0.1 (SveinOveAas)
15:19:55 <kar-1> I don't know enough logic to answer, but I just believe that with the additional assumption A \/ ~A you can prove something extra
15:20:27 <soupdragon> well you can prove A \/ ~A
15:20:27 <roconnor> A \/ ~A is conservateve over Sigma_1
15:20:38 <soupdragon> which was not previously derivable
15:20:47 <roconnor> because even constructively, the logic is still Sigma_1 complete
15:21:04 <kar-1> what does Sigma_1 complete mean?
15:21:06 <roconnor> the logic being Heyting arithmetic or whatever
15:21:15 <roconnor> kar-1: every true Sigma_1 sentence is provable
15:21:38 <jbapple> b/c "forall A, A \/ ~A" is not a Sigma_1 sentence
15:22:04 <roconnor> it isn't even a sentence in arithmetic
15:24:22 <nus> hm. what's "forall A. ~A" supposed to mean?
15:25:18 <roconnor> nus: every proposition is false
15:25:42 <roconnor> @djinn Not a
15:25:42 <lambdabot> -- f cannot be realized.
15:25:59 <jbapple> @djinn Not (Not a)
15:25:59 <lambdabot> -- f cannot be realized.
15:26:14 <kar-1> roconnor, even if every true Sigma_1 sentence is provable, doesn't that mean that it is provable using classical logic.. sorry if I ask stupid questions..
15:26:16 <jbapple> @djinn Not (Not (Not (Not a)))
15:26:16 <lambdabot> -- f cannot be realized.
15:26:35 <roconnor> kar-1: that's what I mean by provable
15:26:51 <kar-1> but it will not construct the natural number
15:26:53 <jbapple> @djinn Not (Not (Not a)) -> Not a
15:26:53 <lambdabot> f a b = void (a (\ c -> c b))
15:27:07 <roconnor> kar-1: in fact Heyting arithmetic proves every true Sigma_1 statement
15:27:12 <lpsmith> what's void?
15:27:22 <lpsmith> @def void
15:27:22 <lambdabot> Maybe you meant: bf do let
15:27:24 <roconnor> kar-1: and that implies Peano Arithmetic proves every Sigma_1 statement
15:27:41 <kar-1> roconnor, but those proofs do not contain the number that the sentence talks about
15:27:42 <EvanR-work> :t void
15:27:43 <lambdabot> Not in scope: `void'
15:27:52 <kar-1> necessarily
15:28:01 <EvanR-work> @src Void
15:28:01 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:28:26 <roconnor> kar-1: they always implicity contain the an upper bound on the size of n
15:28:27 <lispy> ?Vixen Can I set my password to I<3Haskell ?
15:28:28 <lambdabot> Ooh, functional programmers are so hot!
15:28:48 <kar-1> roconnor, even if you use the proof by contradiction?
15:28:49 <jbapple> :t let f a b = a (\c -> c b) in f
15:28:50 <lambdabot> forall t t1 t2. (((t -> t1) -> t1) -> t2) -> t -> t2
15:28:51 <roconnor> kar-1: the dialetica interpretation can be used to compute this upper bound from the proof
15:28:59 <roconnor> kar-1: even if you use proof by contradiction :O
15:29:12 <jbapple> :t let f void a b = void (a (\c -> c b)) in f
15:29:13 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (((t2 -> t3) -> t3) -> t) -> t2 -> t1
15:29:15 <kar-1> roconnor, could you point me the proof of that
15:29:26 <mreh> do you think I could derive a "MArray IOUArray 'something isomorphic to Int' IO"?
15:29:37 <lispy> ?djinn ((a -> Void) -> Void) -> a
15:29:37 <lambdabot> -- f cannot be realized.
15:30:07 <roconnor> kar-1: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.4798&rep=rep1&type=pdf
15:30:15 <kar-1> thanks
15:30:56 <OscarZ> isnt it that peano arithmetic is axiomatic system that "captures" all truths of addition and multiplication of integers ? or is that a correct statement ?
15:31:19 <lispy> ?djinn ((a -> Void) -> Void)
15:31:19 <lambdabot> -- f cannot be realized.
15:31:26 <mreh> OscarZ: huh?
15:31:27 <lispy> ?djinn a -> Void
15:31:28 <lambdabot> -- f cannot be realized.
15:31:30 <lispy> hmm
15:31:34 <mreh> I can't answer the question
15:31:35 <tromp> Peano cannot prove all true statements of arithmetic
15:31:40 <lispy> I thought djinn could at least do a -> Void
15:31:48 <hpc> ?djinn a
15:31:48 <lambdabot> -- f cannot be realized.
15:32:03 <hpc> ?djinn Void
15:32:03 <lambdabot> -- f cannot be realized.
15:32:05 <lispy> ?djinn-types
15:32:05 <lambdabot> Unknown command, try @list
15:32:06 <Peaker> lispy, forall a. a -> Void  is uninhabitable
15:32:38 <Peaker> (unless "a" isn't univ. quant. but is Void)
15:33:31 <lispy> ?list
15:33:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:33:57 <tromp> there is Haskell one-liner that Penao cannot prove is a total function
15:34:16 <Cale> OscarZ: Sort of depends on what you mean by "all truths"
15:34:30 <dmwit> ?djinn (((a -> Void) -> Void) -> Void) -> (a -> Void)
15:34:30 <lambdabot> f a b = void (a (\ c -> c b))
15:34:54 <matt_m> OscarZ: PA doesn't have a notion of exponentation - if you add one, you get a system that's incomplete (IIRC)
15:34:55 <Cale> OscarZ: There are statements U in PA for which neither U nor its negation are provable in PA.
15:35:08 <dmwit> lispy: eliminating two out of three negations is okay, even though eliminating two out of two isn't (!)
15:35:16 <OscarZ> i dont know math that well, so that was probably a stupid question.. i understood its addition and multiplication of integer that peano arithmetic "does" .. or whats the correct word to use instead of "does" ?
15:35:33 <Cale> PA isn't complete.
15:35:34 <tromp> expresses
15:35:39 * roconnor tries to think of the one-liner
15:36:15 <lispy> dmwit: s'okay.  I don't think djinn is clever enough to come up with Oleg's law of excluded middle encoding for haskell.
15:36:24 <roconnor> matt_m: exponentiation is definable in PA
15:36:27 <tromp> the one-liner i know does indeed have exponentiation
15:36:27 <lispy> djinn doesn't do rank2 types does it?
15:36:35 <dmwit> Nope.
15:36:51 <jbapple> This one-liner is stumping me
15:36:51 <lispy> dmwit: bit of a non-starter, that
15:37:21 <matt_m> roconnor:  hmmm, I have memories.  Any idea what I'm thinking of?
15:37:34 <jbapple> oh, wait!
15:37:47 <jbapple> Hercules and the hydra is one line, right?
15:37:51 <roconnor> matt_m: maybe something about diaphantine equations being unsolvable.
15:37:59 <Cale> matt_m: Presburger arithmetic, perhaps
15:38:10 <roconnor> jbapple: can you state it in one line?
15:38:20 <jbapple> roconnor: maybe
15:38:23 <Cale> matt_m: But it only has addition
15:38:24 <tromp> not in your usual 80 char line:(
15:38:43 <jbapple> Can I get one data definition?
15:38:48 <Cale> Presburger arithmetic is consistent, complete, and decidable.
15:38:49 <jbapple> Or are rose trees free?
15:38:56 <roconnor> jbapple: no!  You can have Mu though :)
15:39:15 <jbapple> is presburger decidable in PA?
15:39:16 <Cale> But lacks the ability to discuss multiplication of two arbitrary numbers.
15:39:41 <Cale> jbapple: What do you mean by that?
15:39:53 <roconnor> jbapple: presburger arithmetic is decidable
15:39:54 <kulin> if i have module A and module B and C which import A, is it more common to organizing the module paths as A, A.C, A.B or D.A, D.B, D.C or D.B, D.C, D.E.A
15:39:59 <jbapple> Cale: I don't know
15:40:02 <matt_m> roconnor:  I think I'm just remembering the proof of incompleteness of PA, via exponentiation
15:40:06 <roconnor> I'm not sure what "in PA" means
15:40:21 <jbapple> I don't know what I was asking
15:40:31 <wli> Peano Arithmetic?
15:40:40 <jbapple> I should have typechecked first
15:40:45 <matt_m> I think we proceeded in two steps, first proving PA + exponentation incomplete, then constructing exponents
15:40:58 <Cale> OscarZ: Peano arithmetic is about the natural numbers, addition, and multiplication though. You're right on that point :)
15:41:00 <roconnor> matt_m: that sounds reasonable
15:42:03 <Cale> OscarZ: It's just that when you get to the point of asking whether it encodes all truths about the natural numbers, that starts to become a philosophical question. It's incomplete in a formal sense, so we can extend it in various incompatible ways without doing any harm.
15:43:14 <OscarZ> I didn't think of all truths.. but truths involving just addition and multiplication, i thought this is something trivial but probably isnt ?
15:43:25 <roconnor> Cale: Um, I didn't think it was very philosophical
15:43:28 <roconnor> it is clearly no
15:43:50 <Cale> roconnor: Well, is there such a thing as "all truths about the natural numbers"
15:44:06 <OscarZ> and this is all that is needed for the "implementation" of Gdel numbering ?
15:44:12 <roconnor> so long as we talk about arithmetic truthes, then surely yes
15:44:16 <jbapple> roconnor: What is you say something is only "true" if it is "true in all models"?
15:44:17 <Cale> Without any reference to a particular axiomatisation, I think that question doesn't mean anything.
15:44:35 <roconnor> jbapple: there is only one model of the natural numbers (upto isomorphism)
15:44:52 <soupdragon> roconnor: what about nonstandard models??
15:45:02 <roconnor> soupdragon: those aren't the natural numbers
15:45:07 <jbapple> roconnor: That seems like a philosophical stance :-)
15:45:11 <soupdragon> :S
15:45:15 <soupdragon> I'm confused
15:45:18 <roconnor> jbapple: no it isn't
15:45:20 <Cale> There are arithmetic statements for which truth is not decidable in PA or in ZFC, or in any other system, and for every such statement, there are two incompatible ways of extending the system to make it either true or false.
15:45:47 <roconnor> Cale: yes, but only one way to extend it while keeping the natural numbers as a model
15:45:56 <Cale> ?
15:45:57 <jbapple> roconnor: I don't understand why that is not a philosophical stance
15:46:11 <Cale> The natural numbers of ZFC?
15:46:14 <roconnor> jbapple: because turing machines either halt or they don't
15:46:18 <Cale> Or the natural numbers of some other system?
15:46:31 <roconnor> Cale: *The* natural numbers.
15:46:34 <roconnor> the ones we count with
15:46:39 <Cale> Don't believe in such an object.
15:46:50 * nus counts with fingers :-P
15:46:57 <soupdragon> > 4^2 + 3^2
15:46:57 <lambdabot>   25
15:47:03 <jbapple> roconnor: There are no Turing machines -- they are a philosophical construct
15:47:10 <roconnor> Cale: you believe there are Turing machines that don't halt and don't not halt?
15:47:16 <roconnor> jbapple: :)
15:47:17 <roconnor> ok
15:47:25 <Cale> roconnor: With respect to particular formal systems, sure.
15:47:32 <jbapple> roconnor: All actual machines halt
15:47:39 <Cale> But not outside of a particular axiomatic system.
15:47:42 <roconnor> Cale: but I mean hakell programs, running on an ideal machine
15:47:43 <nus> jbapple, they think you don't exist either (-:
15:47:47 * ddarius also hashes truth and provability.
15:48:08 <roconnor> Cale: you are saying there are programs that are indeterminate whether they halt or not?
15:48:14 <Cale> The only kind of truth is provability with respect to some formal system.
15:48:28 <roconnor> Cale: that's retarded
15:48:31 <jbapple> I just think that one will just end up defining turing machines more and more carefully until you have produced a formal system, perhaps one akin to PA
15:48:32 <Cale> Why?
15:48:55 <roconnor> Cale: because no one uses unsound systems, even if they were consistent
15:49:16 <ddarius> The only kind of communicable truth is provability.
15:49:37 <Cale> roconnor: But in order to talk about soundness, you need to have another external formal system.
15:49:44 <roconnor> Cale: no you don't
15:49:48 <Cale> Oh?
15:49:51 <mdmkolbe> @index >=>
15:49:52 <lambdabot> bzzt
15:49:57 <mdmkolbe> @index (>=>)
15:49:57 <lambdabot> bzzt
15:50:10 <dmwit> :t (Control.Monad.>=>)
15:50:11 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
15:50:17 <ddarius> mdmkolbe: @index is pretty limited, I recommend using hoogle in general to find things.
15:50:18 <dmwit> also
15:50:20 <Cale> roconnor: I don't see how you could possibly do without.
15:50:22 <dmwit> ?hoogle (>=>)
15:50:22 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:50:36 <roconnor> Cale: suppose I say I have "proved" such and such a Haskell program halts
15:50:50 <roconnor> Cale: but I refuse to state a bound on how long it runs
15:51:10 <Cale> In which formal system did you prove that the Haskell program halts?
15:51:13 <roconnor> and every time you run it it never halts
15:51:19 <Peaker> djinn has TC support but can't figure out the implementation of (>=>), what gives?
15:51:26 <roconnor> turns out i proved it in PRA + ~Con(PRA)
15:51:31 <mdmkolbe> ?hoogle (>>>)
15:51:32 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
15:51:32 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
15:51:33 <Peaker> @djinn Monad m => m a -> (a -> m b) -> m b
15:51:34 <lambdabot> f = (>>=)
15:51:46 <Peaker> @djinn Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:51:46 <lambdabot> -- f cannot be realized.
15:51:47 <ddarius> Peaker: Djinn has -type- class support, not type -constructor- class support.
15:51:52 <Cale> roconnor: That's fine.
15:51:57 <aristid> @djinn a -> [a]
15:51:57 <lambdabot> Error: Undefined type []
15:52:01 <soupdragon> but Cale he is tricking you!
15:52:09 <Peaker> ddarius, what's type-constructor class support?
15:52:10 <soupdragon> the machine is not going to halt
15:52:15 <aristid> why doesn't djinn support lists? :(
15:52:29 <Peaker> @src (>=>)
15:52:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:52:32 <ddarius> Peaker: When reducing to a dictionary, the type of a function using return for some monad M is f :: (forall a. a -> M a) -> ...
15:52:33 <Cale> soupdragon: But it halts in that system.
15:52:41 <roconnor> Cale: but it doesn't halt in reality!!!
15:52:45 <Cale> It might not halt in some other system
15:52:57 <Cale> There are plenty of things which halt and which don't halt in reality.
15:53:04 <ddarius> Peaker: Haskell has constructor classes.  Originally it only had type classes.  Types have kind *.  Type constructors can have any kind.
15:53:05 <jbapple> What does it mean that "every time you run it it never halts"?
15:53:08 <soupdragon> Cale, but then anything I say is true because I can just use a logic where it's an axiom?
15:53:11 <Cale> halt in some formal system, I mean
15:53:14 <jbapple> How do you know it "never" halts
15:53:18 <roconnor> Cale: halting is an emprical fact
15:53:34 <OscarZ> Cale: when you say you dont believe in *the* natural numbers, is this the same thing as not believing in universal concepts of "one object", "two objects", etc.. ?
15:53:36 <ddarius> Djinn can't handle rank-2 types so it can't handle type constructor classes except in the most trivial cases.
15:53:52 <soupdragon> roconnor do you beleive that exponentiation is total?
15:53:58 <Peaker> ddarius, Oh, I see. But it does "work" for (>>=)
15:53:58 <Cale> roconnor: If you like, there will always be many programs which just "take too long" to halt in reality.
15:54:05 <Peaker> ddarius, It has Monad predefined in there
15:54:07 <roconnor> soupdragon: yes
15:54:10 <soupdragon> even 2^99999999999999?
15:54:26 <ddarius> Peaker: Yes, because someone added it.  It doesn't really work.
15:54:27 <Cale> OscarZ: I don't believe in a single system for discussing such concepts.
15:54:32 <Peaker> ddarius, ah
15:54:49 <Cale> OscarZ: There are instead many *incompatible* systems for discussing the natural numbers
15:55:03 <roconnor> Cale: in reality programs halt or don't.  It isn't realative
15:55:08 <Cale> OscarZ: and you have to say which one you mean in order for your statements to mean anything
15:55:09 <ddarius> aristid: Because recursive types lead to a much more complicated logic that is harder to prove.
15:55:14 <roconnor> proof systems are either sound or unsound
15:55:15 <ddarius> roconnor: In reality, all programs halt.
15:55:22 <soupdragon> but roconnor 2^9999999999999 doesn't halt
15:55:27 <OscarZ> Cale: "discussing such concepts".. but do you agree these concepts are universal, no matter what system is used to discuss them ?
15:55:38 <kmc> are we ultrafinitists now
15:55:43 <roconnor> soupdragon: on an ideal machine it will
15:55:50 <ddarius> kmc:  I am
15:55:54 <soupdragon> but ideal machine must be a formal system
15:55:57 <soupdragon> or what?
15:56:09 <roconnor> soupdragon: I don't think an ideal machine is a formal system
15:56:10 <soupdragon> since reality cannot refer to real life
15:56:42 <Cale> OscarZ: Well, while many things about them will be similar or the same, two different axiomatisations of "the natural numbers" (the vague notion) might actually be different things, and neither one is any more right than the other.
15:56:47 <OscarZ> Cale: which one of what ? sorry i dont understand your question
15:57:02 <Cale> OscarZ: Which formal system.
15:57:07 <OscarZ> interesting..
15:57:14 <roconnor> Cale: there is a reason that the Peano axioms are what they are.  They weren't picked randomly
15:57:26 <Cale> Outside of mathematics, no formal system is any truer than any other.
15:57:35 <Cale> It's like asking whether a mug or a chair is true.
15:57:35 <roconnor> they are trying to capture the smallest model as best they can for their language
15:57:43 <soupdragon> I think Cale is a finitist
15:57:50 <Cale> I am *not* a finitist.
15:57:56 <roconnor> soupdragon: cale is a formalist
15:58:05 <Cale> In fact, my preferred system is ZFC
15:58:16 <Cale> (I love choice)
15:58:31 <soupdragon> Cale, but if a turing machines halting can be independent of a formal system _it halts_ ... unless you are a finitist
15:58:39 <OscarZ> Cale: i think i mean formal systems that are based on naive set theory
15:58:44 <soupdragon> (assuming a strong enough lgic)
15:58:48 <Cale> soupdragon: hm?
15:59:40 <Cale> soupdragon: The question of whether a Turing machine (which is a formal construction) halts (which is another formal definition), is a matter of the particular formal system you're working in.
15:59:46 <jon_of_arc> Chairs are architecture, sofas are bourgeoisie
15:59:49 <Cale> It is *meaningless* outside that system.
15:59:59 <roconnor> Cale: What mark do you think I'd get on a CS exam if I worked in an unsound system?
16:00:03 <jbapple> Here's a short Hercules vs. the Hydra: http://people.csail.mit.edu/carroll/probSem/Documents/HydraBattle.pdf
16:00:14 <Cale> roconnor: Unsound with respect to a metatheory in ZFC?
16:00:23 <Cale> roconnor: Or unsound with respect to what other system?
16:00:34 <roconnor> Cale: let's say Sigma_1 unsound.
16:00:41 <roconnor> ie I can prove false Sigma_1 sentences
16:00:58 <Cale> In order to talk about soundness, you need to talk about models, in order to talk about models, you need a system in which you're placing the definitions of model theory.
16:01:19 <soupdragon> if it's undecidible whether or not a turing machine halts in a sufficently strong logic then ~exists k, halts after k steps which implies the turing machine does not halt
16:01:31 <Cale> and the results about soundness that you get will inevitably be changed by what your metatheory is.
16:01:42 <soupdragon> Unless you are a finitist, who accepts the possibility that the turing machine reaches p+1 steps (p the largest number)
16:02:36 <roconnor> Cale: I don't need a formal system.  in PA every time I prove a sigma 1 statment I can write down a witness.
16:02:53 <roconnor> an sigma1-unsound system doesn't have this property
16:03:06 <roconnor> where is the realtiveness in that?
16:04:20 <roconnor> I didn't even mention models
16:04:40 <Cale> I don't understand how you can define soundness without talking about models.
16:04:50 <roconnor> here
16:04:51 <Cale> How do you do it?
16:05:11 <Cale> You need a semantics
16:05:18 <roconnor> A sigma-1 sentence is true if there is a number n that makes the delta_0 sentence true
16:05:19 <soupdragon> that is my argument for claiming you are using finitism
16:05:25 <Cale> and that semantics is just something in another formal system
16:05:27 <roconnor> there is my semantics
16:05:35 <soupdragon> (unintentionally, yes..)
16:05:37 <Cale> true *in which system*?
16:05:56 <roconnor> a delta0 sentence is just a program that prints 0 or 1
16:05:57 <roconnor> run it
16:06:03 <roconnor> if it prints 0 then it is false
16:06:08 <roconnor> if it pritns 1 it is true
16:06:12 <roconnor> run it however you like
16:06:16 <roconnor> ghc
16:06:17 <roconnor> gcc
16:06:21 <roconnor> brainfuck
16:06:23 <roconnor> by hand
16:06:26 <roconnor> monks
16:06:28 <OscarZ> is this some Gdelian dog tail hunt ?
16:06:31 <Cale> and what if it doesn't terminate in the life of the universe?
16:06:35 <roconnor> whatever
16:06:58 <olsner> @quote heat.death
16:06:59 <lambdabot> dave_m says: < Bobstopper> Assuming the universe will eventually die of heat death, counting will cease when that happens. So if you start counting now, you'll probably find the largest number (so
16:06:59 <lambdabot> long as nobody else has found a larger one yet) < Cale> what about faster ways to produce larger numbers? < Bobstopper> not after the heat death you can't :P < dave_m> don't you tell me what I can't
16:06:59 <lambdabot> do after the heat death of the universe
16:07:03 <soupdragon> roconnor, it's a good point -- if you accept the universe is finite
16:07:13 <olsner> hmm, that was a slightly overlong quote
16:08:26 <nus> what if the universe terminates before the program completes?
16:08:28 <Cale> soupdragon: The universe as we observe it only seems to support a finite amount of computation. At least, that seems the most likely option to me at the time being. (It's not a formal question, but an empirical one.)
16:08:43 <soupdragon> Cale so do you reject my argument that you are a finitist? :p
16:08:45 <Cale> soupdragon: So I guess that's where you're getting the idea that I'm a finitist of some sort.
16:08:54 <kmc> right, we're all finitists, whatever
16:08:54 <soupdragon> ok
16:08:56 <Cale> But I totally disagree about being a finitist.
16:09:05 <Cale> In the usual sense of the term.
16:09:14 <soupdragon> Cale - I am not sure there is a usual sense (?)
16:09:17 <Cale> I am quite happy to work with infinite objects in various formal systems.
16:09:32 <soupdragon> so are many finitists though
16:09:34 <Cale> I am a formalist, when you get right down to it :)
16:09:41 <soupdragon> okay
16:09:43 <nus> is finitism related to fatalism, by any chance?-)
16:09:45 <EvanR> the hell is a finitist
16:10:01 <ddarius> the purgatory is an infinitist
16:10:04 <aristid> does it matter whether the universe is infinite if we only have limited energy? the probability of finding energy "on the way" converges towards zero with the path length
16:10:12 <Cale> and in fact, I carry that idea further, to nonmathematical philosophy
16:10:26 <soupdragon> The strong version(s) of finitism (which give a sense of the main idea) are that in number theory the integers have a largest number p (which is prime) and infact they form a field etc
16:10:38 <soupdragon> and in analysis there is a smallest number h, so we needn't take any more limits
16:10:49 <soupdragon> infact h = 1/p
16:10:54 <Cale> I treat "true" and "false" as simply labels that we apply to statements according to various sets of rules or methods. There's no one "real" system of truth.
16:11:12 <EvanR> soupdragon: wait what. a field mod the largest number + 1?
16:11:31 <aristid> @pl \x -> [x]
16:11:32 <lambdabot> return
16:11:33 <soupdragon> if you keep adding one you get back to the start
16:11:37 <roconnor> Cale: fine, for the sake of arguement let's say that we need a formal model of natural numbers to model the semantics of PA.
16:11:46 <soupdragon> I am just telling the basics so you can get an idea of it
16:12:10 <EvanR> soupdragon: thats interesting, since numbers are real anyway, why would one propose such a thing ;)
16:12:13 <roconnor> Cale: it is still the case that adding Con_PA and ~Con_PA are equally valid extenstions
16:12:14 <EvanR> arent*
16:12:30 <soupdragon> not everyone agrees that numbers aren't real
16:12:30 <aristid> @pl f x = [x]
16:12:31 <lambdabot> f = return
16:12:44 <roconnor> Cale: Isn't it the case that for *all* meta-models of that natural numbers adding ~Con_PA will give you an unsound system.
16:12:48 <EvanR> soupdragon: sort of like god?
16:12:52 <soupdragon> um no
16:12:53 <Cale> roconnor: So long as you don't introduce an inconsistency, everything is fine.
16:13:05 <roconnor> no not everything is fine!!!
16:13:09 <Cale> roconnor: In fact, even if you do, all it does is make your system a bit boring.
16:13:32 <roconnor> adding ~Con_PA will make your system unsound with respect to your meta-natural numbers
16:13:39 <Cale> I don't care about whether it's sound with respect to some other system you haven't told me about.
16:13:48 <roconnor> sure you do
16:13:53 <Cale> Why should I?
16:14:00 <roconnor> Cale: you use haskell don't you?
16:14:15 <roconnor> the type systems is a way to provide proofs about your programs
16:14:32 <roconnor> you would care if the proofs were unsound
16:14:40 <FunctorSalad> :def decl (\x -> writeFile tmp x >> return (":load "++x))
16:14:53 <FunctorSalad> looks like that should add ability to define datatypes to ghci
16:14:54 <FunctorSalad> ;)
16:14:58 <Cale> See, I think we're rapidly approaching the one spark of science in computer science.
16:15:13 <roconnor> or maybe taking Agda is a better example
16:15:26 <roconnor> All that type theory proving going on in Agda isn't just random.
16:15:29 <Cale> It's an empirical matter whether a particular formal system is appropriate for reasoning about the behaviour of physical systems.
16:15:48 <soupdragon> Cale: what about 'every statement has a proof'
16:16:02 <roconnor> PA + ~Con(PA) can never be an appropraite system
16:16:12 <roconnor> it is only sound if it is inconsisent
16:16:56 <roconnor> that isn't an emperical question.  It is logically constructed to not be appropriate for reasoning
16:18:18 * syntaxglitch suspects that the physical universe is computationally turing-equivalent and contains (at most) countable infinities
16:18:32 <soupdragon> why??
16:18:37 <FunctorSalad> depends on what "is" and "contains" means ;)
16:18:44 <FunctorSalad> only half-kidding...
16:18:48 <pato> HELP!
16:18:58 <ddarius> syntaxglitch: I think the universe is -at best- that.
16:19:05 <soupdragon> I think the universe is sub-turing
16:19:08 <lispy> ?FAQ can Haskell Help?
16:19:08 <lambdabot> Unknown command, try @list
16:19:12 <aristid> entropy!
16:19:14 <lispy> ?faq Can Haskell Help?
16:19:15 <lambdabot> The answer is: Yes! Haskell can do that.
16:19:26 <syntaxglitch> the universe is clearly sub-turing if finite, I'll grant
16:19:32 <pato> Cale, kmc, anyone:  Non-exhaustive patterns in function ventasRespaldadas??? WTF
16:19:33 <aristid> ?faq Can Haskell evade the fundamental laws of thermodynamics?
16:19:33 <lambdabot> The answer is: Yes! Haskell can do that.
16:19:45 <FunctorSalad> I think the universe isn't a subset of N -> N presented as abstract machines
16:19:45 <kmc> why me
16:19:51 <jlouis> roconnor: PA is?
16:19:51 <soupdragon> lol
16:19:54 <roconnor> thus ~Con(PA) and Con(PA) are again not equally acceptable extensions of PA.
16:19:55 <EvanR> it seems popular to propose a finite universe in here, so you all ARE finitists
16:19:55 <FunctorSalad> so the q doesn't apply
16:19:56 <pato> you always help me :P
16:20:03 <syntaxglitch> then again, turing equivalence is overrated anyhow
16:20:09 <roconnor> jlouis: Peano Arithmetic
16:20:17 <kmc> palo, i don't think ventasRespaldadas is from the standard library.  you could start by putting your code on hpaste.org so we can see it
16:20:20 <jlouis> oh, I should have figured that one out
16:20:22 <Cale> roconnor: We use an inconsistent system all the time -- Haskell's type system -- and it's quite useful.
16:20:26 <EvanR> must be a side effect of messing with discrete math in comp sci ;)
16:20:36 <kmc> pato, it means you are matching some different patterns and you missed a case
16:20:39 <soupdragon> haskell system is sound and (inference is) complete
16:20:44 <Cale> roconnor: Inconsistency isn't always the end of the story
16:20:59 <soupdragon> soundness as in don't go wrong.
16:21:14 <soupdragon> We do not use haskell type system for proofs..
16:21:14 <jlouis> The Con( ) predicate is consistency then?
16:21:16 <roconnor> Cale: Haskell has a soundness condtion.
16:21:25 <soupdragon> that whole curry-bloward thing is nonsense
16:21:30 <pato> yeah, but I thnik the function is correct, take a look: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25505
16:21:32 <roconnor> Cale: if PA is inconsistent there is no sound portion left
16:21:37 <roconnor> AFAIK
16:21:56 <roconnor> jlouis: yes
16:21:58 <lispy>  soupdragon: Haskell types can express the law of excluded middle in general...is it still sound?
16:22:19 <roconnor> anyhow, Cale is just getting rediculous now
16:22:55 <kmc> pato, yeah, looks exhaustive to me.  what input gives you the exception?
16:23:25 <kmc> pato, also it looks like you could rewrite this function using "all"
16:23:25 <kmc> :t all
16:23:26 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:23:31 <FunctorSalad> (why not start with the simpler question of whether a tomato is a turing machine?)
16:23:42 <lispy> kmc: might need an otherwise
16:23:46 <pato> my fucking teachers don't let me use all :(
16:23:52 <Cale> I don't really understand what roconnor was getting at.
16:24:07 <kmc> lispy, ah, good point
16:24:10 <Cale> Does anyone else? :)
16:24:13 <kmc> pato, what if all your guards are false?
16:24:16 <ddarius> FunctorSalad: A tomato is almost certainly capable of computing any Turing-complete function modulo resource limits.
16:24:34 <kmc> pato, you can write your own "all" then
16:24:36 <kmc> @src all
16:24:37 <lambdabot> all p =  and . map p
16:24:42 <soupdragon> I think roconnor knows that turing machines  halt or not halt
16:24:42 <FunctorSalad> ddarius: it does't compute any functions
16:24:46 <Cale> It seems to me that any formal system is a fine object of study so long as it's interesting for itself.
16:24:57 <nus> Cale, it seemed to be "sound enough for my purposes" vs "totally sound for all means" discussion
16:25:05 <ddarius> FunctorSalad: What makes you think that?
16:25:06 <kmc> pato, if your teachers want you to learn explicit recursion, you can impress them by writing the general useful one
16:25:08 <lispy> Would you put a TC tomato in a FunctorSalad?
16:25:09 <FunctorSalad> ddarius: if you interpret some aspect of the tomato as computation... isn't that different?
16:25:14 <soupdragon> but Cale says that it may not be provable that a turing machine halts or not halts
16:25:18 <FunctorSalad> or if you can model it using a turing machine
16:25:22 <FunctorSalad> model != thing itself
16:25:35 <ddarius> FunctorSalad: What if I can model a Turing machine using a tomato?
16:25:44 <Cale> soupdragon: Is every such statement provable, and I just didn't know this?
16:26:11 <soupdragon> Cale: well as you know, you can encode any mathematical statement into the halting (or not) of a turing machine
16:26:21 <pato> but whithout high order functions (not allowed to use them) all seems quite boring :P
16:26:37 <pato> but, THANKS, that was the error, I was missing "otherwise" case
16:26:53 <soupdragon> or into the solution of a ssimple equation between integers
16:26:59 <gio123> Cale: hi
16:27:17 <soupdragon> both of which have strong philosophical implications
16:27:46 <nus> soupdragon, some mathematical statements made by my profs were done by hand waiving and were not encodable otherwise (-:
16:27:55 <FunctorSalad> ddarius: besides the point, but I didn't think that's actually thought to be possible, since even a "really continuous" underlying world wouldn't have "harnessable" infinite precision
16:27:58 <soupdragon> nus I think that is a really important proof technique
16:28:49 <ddarius> FunctorSalad: What does continuity have to do with what I said?  Do you think the computer your using is incapable of approximating a Turing-machine?
16:29:02 <FunctorSalad> things may be real numbers behind the scenes, but surely anything that could be called a concrete computer needs some positive number of energy, time or space to compute something a human can make use of in the end
16:29:12 <FunctorSalad> *amount of
16:29:27 <FunctorSalad> a positive amount for every step, should that be
16:29:49 <FunctorSalad> (constant not depending on step ;))
16:30:14 <FunctorSalad> ddarius: I thought your argument makes use of infinite precision at the bottom, since a tomato is bounded
16:30:34 <FunctorSalad> ddarius: and computers are only half-way a TM if we say that new memory is tacked on as required...
16:30:53 <ddarius> FunctorSalad: Did you just ignore my "modulo resource limits" and "approximating" qualifiers?
16:32:13 <alex404> If I've got a pair of CArrays which I want to zipWith division, is it much faster to write a c function to do it, or can I just turn the Arrays into lists, use zipWith, and then turn the result back into a CArray?
16:32:54 <FunctorSalad> ddarius: actually I did :)
16:33:02 <FunctorSalad> not deliberately
16:33:13 <FunctorSalad> earlier in the processing chain...
16:33:57 <FunctorSalad> ddarius: but I'm not so sure that it's sensible to do that, assuming that anything of interest about TMs makes use of infinity
16:34:10 <FunctorSalad> (otherwise it's just a DFA, obviously)
16:34:13 <mdmkolbe> Anyone know which citation form the Haskell Symposium is using this year?  name-date or numbers?
16:34:36 <ddarius> FunctorSalad: I guess the theory of Turing machines has no application to our computers then.
16:35:12 <kmc> alex404, i would guess the former is much faster, and the latter is much easier
16:36:00 <kmc> alex404, in these cases a good strategy is: write the easy one, profile it; if it's not fast enough, write the fast one and do an automated regression test against the easy one
16:36:04 <FunctorSalad> ddarius: nope, I do think that, say, a TM parsing expressions correctly is the more to-the-point model than some finite DFA parsing just some expressions. *But* I'm questioning transferring these Convenient Fictions back onto the universe
16:36:19 <kmc> that is, the prototype becomes a spec/test for the complicated implementation
16:36:26 <alex404> kmc: Indeed.
16:36:43 <ddarius> FunctorSalad: I have no problem saying that the universe is sub-Turing.
16:36:44 <FunctorSalad> ddarius: for the same reason that N is cleaner, more convenient etc. than some truncated initial segement because you don't need exception handlers in the proof at every step
16:36:57 <alex404> kmc: It's not even close to the bottleneck for this algorithm, so as long as it's only, say, 3-5 times as slow, I don't much care.
16:36:58 <FunctorSalad> (N=Nat)
16:38:30 <kmc> alex404, btw where is CArray from?
16:38:49 <FunctorSalad> ddarius: but this seems like a bit of a red herring chase again :) my real point was more about the whole perspective of computational power being just one perspective about reality... not identical to reality
16:38:55 <Eduard_Munteanu> Hi.
16:39:16 <FunctorSalad> "perspective" doesn't mean opinion here -- more like mode of looking
16:39:17 <alex404> kmc: Well, actually I create from a Ptr to an mmap in my c code. I need to pass a carray to fftw, though
16:39:27 <kmc> i mean what module
16:39:46 <alex404> ?
16:39:51 <kmc> the type CArray
16:39:55 <kmc> where is it defined?
16:39:57 <kmc> i haven't heard of it
16:40:12 <alex404> Oh
16:40:22 <kmc> alex404, the best solution here would be one of the haskell libraries with fast bulk array operations, like Data Parallel Haskell or Repa
16:40:37 <alex404> It's a fftw dependency
16:40:40 <alex404> Data.Array.CArray
16:40:41 <kmc> but these are pretty new and experimental things
16:40:47 <kmc> okay
16:40:50 <kmc> from the carray package
16:40:56 <alex404> Indeed
16:41:12 <ddarius> FunctorSalad: All we have are perspectives about reality.
16:41:38 <FunctorSalad> ddarius: that's a way to put my point, actually
16:41:56 <alex404> Hmmm... I should probably just write the c code. Haskell makes me lazy.
16:42:06 <FunctorSalad> the universe may be a TM in the "play" of computational theory... but that play is not the only one, and none is most fundamental
16:42:53 <FunctorSalad> I took "is" as describing identity, btw
16:42:55 <ddarius> The question is: "Does it lead to a model that helps us understand and predict things?"  not "Is it True?"
16:43:21 <alex404> Truth is so last century.
16:45:27 <FunctorSalad> (note: this is not a new age "all is equally true"... every individual has lots of these "perspectives" simultaneously; the perspectives aren't political or religious parties)
16:47:44 <FunctorSalad> (the one where the tomato is... something you're about to eat right now? ;))
16:48:39 <Eduard_Munteanu> Is there any 'kosher' definition / way of writing higher-order functions in math?
16:48:45 <FunctorSalad> (I'm not promoting any position in particular about qualia)
16:49:28 <ddarius> Eduard_Munteanu: You can just do the same thing you do in Haskell.
16:49:29 <FunctorSalad> Eduard_Munteanu: in mainstream math, functions are defined as relations which also satisfy single-valuedness and totality
16:49:31 <Eduard_Munteanu> Like I have doubts math people would take f: (A -> B) -> (A -> B) seriously.
16:49:43 <ddarius> Eduard_Munteanu: Why?
16:49:53 <ddarius> They use functions like that all the time.
16:50:08 <Eduard_Munteanu> ddarius: yeah, though I've never seen stuff like that written explicitly.
16:50:38 <FunctorSalad> hmm I can offer analysis 2 as example ;)
16:51:18 <FunctorSalad> where derivative of a function V0 -> W (V and W are finite-dim vector spaces) has codomain Lin(V0,W)
16:51:36 <FunctorSalad> before you apply the encryption into matrices ;)
16:52:10 <Eduard_Munteanu> FunctorSalad: so a HOF would be a tuple (A, B, R), where R contains elements of the form ((A1, B1, R1), (A2, B2, R2))?
16:52:15 <FunctorSalad> prof was an algebraic topologist though, I guess you're right that higher-order functions haven't caught on everywhere
16:52:20 <ddarius> Eduard_Munteanu: The notation used varies from branch to branch of mathematics.
16:52:58 <FunctorSalad> (erm and V0 is an open subset of V, and the codomain in question is of course LIn(V,W))
16:53:04 <Eduard_Munteanu> Yeah, they tend to write it in some other way that implies HOFs.
16:53:39 <FunctorSalad> yes, in analysis currying is often indicated by "parameters"
16:53:47 <FunctorSalad> written outside the argument parens a a little index ;)
16:54:24 <Eduard_Munteanu> Hm, you mean stuff like f_a(x).
16:54:26 <FunctorSalad> Eduard_Munteanu: that tuple seems off
16:55:06 <FunctorSalad> your type there corresponds to a subset of (A -> B) x (A -> B)
16:55:12 <ddarius> Eduard_Munteanu: Yes, mathematicians often go through various chicanery to avoid higher order functions.
16:55:33 <FunctorSalad> so it's tuples of sets of tuples
16:56:14 <Eduard_Munteanu> FunctorSalad: mmm, that seems okay for defining functions (A -> B) -> (A -> B)
16:56:41 <Eduard_Munteanu> though I should really refine the definitions of A and B.
16:56:41 <FunctorSalad> Eduard_Munteanu: ok, apparently you meant such tuples
16:56:45 <FunctorSalad> (why R though?)
16:57:03 <Eduard_Munteanu> That's the relation graph.
16:57:08 <FunctorSalad> (are you encoding the inclusion of the function-implementing set into the whole product?)
16:57:49 <Eduard_Munteanu> Nah, it's the definition I know of relations. Two sets and a graph that's a subset of their cartesian product.
16:58:13 <Eduard_Munteanu> (Binary relations)
16:58:26 <FunctorSalad> Eduard_Munteanu: ok, your relations "know their type" :)
16:58:26 <soupdragon> A function in set theory is its own graph, isn't it?
16:58:50 <FunctorSalad> while mine forget their type at runtime ;)
16:58:54 <Eduard_Munteanu> Hm, I remember there's some contention on that subject.
16:58:54 <FunctorSalad> by being just sets of tuples
17:00:19 <FunctorSalad> in your view, we have a unary predicate "P(R) := R is a relation of A and B". in "my" view, we just have a binary one "P(R,(A,B)) := same"
17:00:26 <Eduard_Munteanu> I generally go with f = g iff f(x) = g(x) forall x and dom(f) = dom(g), codom(f) = codom(g).
17:00:33 <FunctorSalad> because the subset doesn't know its ambient type in ZFC
17:01:40 <Eduard_Munteanu> Yeah, I find that justified by inclusion relations/functions.
17:02:07 <Eduard_Munteanu> Which tended to be spelt explicitly in my books :)
17:03:28 <ddarius> i : U >-> V, f : V -> W, f|U = f . i : U -> W
17:04:17 <FunctorSalad> from a CT or type theory background, functions ought to know their cod of course, so you need to tuple the graph together with the codomain set...
17:04:44 <FunctorSalad> though someone translated CT to the "morphisms don't know their cod" setting too
17:05:01 <FunctorSalad> because it was more natural in some settings, apparently
17:06:16 <FunctorSalad> maybe it's an "it depends"; sometimes the `i' in ddarius's line is annoying clutter, sometimes it's the whole point that something is actually in U and not just in V...
17:08:53 <mreh> the easiest way of fixing this bug in frag is if I can make an instance of (MArray IOUArray GLint IO), can't be derived because IO's contructors are hidden
17:09:32 <FunctorSalad> on the extensional and elmentwise level the codomain *is* more like extra paperwork than something that naturally follows, isn't it?
17:09:36 <mreh> these kinds of optimisations are littered all over the code, I couldn't face removing them, it would slow it down too much
17:10:02 <mreh> but I'm stuck in CPP hell, I'm a bit over my head
17:10:09 <FunctorSalad> the codomain is natural on the syntactic level, where it gives you a rough idea of the image by simple syntactic checks
17:10:20 <kmc> err, you can't derive MArray anyway.  can you?
17:10:22 <FunctorSalad> (like closure of operations)
17:10:57 <mreh> http://hackage.haskell.org/packages/archive/OpenGLRaw/1.1.0.1/doc/html/src/Graphics-Rendering-OpenGL-Raw-Core31-TypesInternal.html#GLint -- these are the OpenGL types here
17:11:08 <mreh> I have no idea how to work with these, because they're all in C
17:11:27 <mreh> kmc: quite possibly, for reasons unknown to e
17:11:31 <Eduard_Munteanu> FunctorSalad: yeah, and it really makes sense when relating to the inverse, or at least bounding its domain.
17:11:39 <mreh> me
17:11:43 <FunctorSalad> tl;dr: it's just another case of extensionality vs. intensionality :)
17:11:51 <kmc> err i mean you can only use "deriving" with certain specific classes
17:11:57 <kmc> did you mean something else by "derive"?
17:12:10 <FunctorSalad> Eduard_Munteanu: left-inverse works just fine without a codomain though
17:12:11 <mreh> kmc: I was using a haskell meaning
17:12:21 <mreh> a deriving clause in haskell to derive an instance
17:12:23 <kmc> yeah
17:12:34 <kmc> oh, are you using GeneralizedNewtypeDeriving?
17:12:43 <mreh> kmc: no
17:13:03 <kmc> are you using an extension that's specifically about using deriving for MArray?
17:13:22 <mreh> I was just using the orphan deriving clause extension
17:13:30 <mreh> whasitcalled
17:13:37 <FunctorSalad> Eduard_Munteanu: and left-inversibility is actually the correct model if one has "process that doesn't destroy information" in mind :)
17:13:38 <kmc> standalone deriving?
17:13:41 <mreh> StandaloneDeriving
17:13:51 <kmc> mreh, that doesn't affect which classes you can derive, iirc
17:13:57 <FunctorSalad> Eduard_Munteanu: sorry, just randomly associating now
17:14:04 <Eduard_Munteanu> :)
17:14:18 <Eduard_Munteanu> Thermodynamic reversibility.
17:14:36 <Eduard_Munteanu> and reversible computing
17:14:52 <FunctorSalad> but at least if you have a function modelling stuff going forward in time... "left" is "lose nothing", "right" depends on an imaginary space of future states
17:15:02 <FunctorSalad> well how is it in thermodyn.?
17:15:39 <mreh> kmc: I cant even see the implementation of MVar for the seemingly isomorphic type Int
17:16:00 <FunctorSalad> hehe. rightinvertibility is "you can achieve all your goals!"
17:16:13 <Eduard_Munteanu> "Impure" processes generate at least kT/2 heat for each bit/state destroyed, IIRC.
17:16:17 <mreh> so I have no idea if I could implement it anyway, it seems to be all done in CPP, could I do a similar thing for GLInt? Int is at base a C type correct?
17:17:40 <JoeyA> Is there a library or something of weaker-typed arithmetic operators?
17:17:45 <kmc> JoeyA, how so?
17:17:57 <JoeyA> e.g. a Weak.<= b  (a is an Integer, b is an Int)
17:18:37 <Eduard_Munteanu> :t fromInteger
17:18:38 <monochrom> @type liftM2 toInteger (+)
17:18:38 <lambdabot> forall a. (Num a) => Integer -> a
17:18:39 <lambdabot>     Couldn't match expected type `a2 -> r'
17:18:39 <lambdabot>            against inferred type `Integer'
17:18:39 <lambdabot>     In the first argument of `liftM2', namely `toInteger'
17:18:54 <monochrom> @type liftM2 (+) toInteger
17:18:54 <lambdabot> forall a. (Integral a) => (a -> Integer) -> a -> Integer
17:19:08 <FunctorSalad> @let gmul x y = fromIntegral (toInteger x * toInteger y)
17:19:10 <lambdabot>  Defined.
17:19:11 <monochrom> @type liftA2 (+) toInteger
17:19:12 <lambdabot> forall a. (Integral a) => (a -> Integer) -> a -> Integer
17:19:15 <FunctorSalad> @ty gmul
17:19:17 <lambdabot> forall a a1 b. (Integral a, Integral a1, Num b) => a -> a1 -> b
17:19:23 <JoeyA> Well, the rationale is because constantly having to say fromIntegral and such can be annoying.
17:19:34 <Olathe> @type let a <<+>> b = toInteger a + toInteger b in (<<+>>)
17:19:35 <lambdabot> forall a a1. (Integral a1, Integral a) => a -> a1 -> Integer
17:19:36 <FunctorSalad> JoeyA: that one?
17:19:55 <Olathe> > let a <<+>> b = toInteger a + toInteger b in (1::Int) <<+>> (2::Word8)
17:19:57 <lambdabot>   3
17:20:10 <JoeyA> @hoogle <<+>>
17:20:10 <lambdabot> No results found
17:20:17 <Eduard_Munteanu> Well, you really shouldn't mix Integer and Int blindly.
17:20:36 <Olathe> @type (+++)
17:20:37 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
17:20:42 <FunctorSalad> it's often forced on you though, Eduard_Munteanu
17:20:47 <JoeyA> Unless it's done carefully, leaning toward higher precision.
17:20:53 <FunctorSalad> index types of 2 diff libs
17:21:21 <JoeyA> I'm just tired of things like this:  let sr = floor . (sqrt::Double->Double) . fromIntegral $ n+1
17:21:27 <Eduard_Munteanu> Yeah, though they should use Ix classed types.
17:21:54 <FunctorSalad> in general I find it a bit of a balancing act of just how many wrappers you want to define
17:22:20 <FunctorSalad> they come at the cost of having to remember more identifiers etc
17:22:33 <JoeyA> I'd rather say something like let sr::Int = Weak.sqrt (n+1)
17:22:41 <JoeyA> I'm not sure if that left-hand cast is valid, though.
17:22:42 <FunctorSalad> (I mean trivial wrappers which just compose two perfectly independent items)
17:23:03 <Olathe> @hoogle (Num a, Fractional b) => a -> b
17:23:03 <FunctorSalad> in this case I'd think you proposal is not bad though
17:23:04 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
17:23:04 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:23:04 <lambdabot> Foreign.Marshal.Utils toBool :: Num a => a -> Bool
17:23:29 <FunctorSalad> in part because fromIntegral distracts from the arithmetic so much
17:23:56 <JoeyA> I'm not entirely displeased with Haskell's type system, especially when everything's one type :-)
17:24:28 <Olathe> > let sqrtI :: (Integral a) => a -> Double; sqrtI = sqrt . fromIntegral in sqrtI (2::Integer)
17:24:29 <lambdabot>   1.4142135623730951
17:24:30 <Eduard_Munteanu> Methinks they should name type classes after mathematical properties, something like TotalOrder for Ix :)
17:24:53 <Olathe> Maybe sqrt'
17:24:54 <FunctorSalad> (maybe one should just use four-letter-words rather than descriptive identifiers for *really* common stuff)
17:24:54 <Eduard_Munteanu> Or more like Countable
17:25:00 <FunctorSalad> huffmann etc
17:25:23 <JoeyA> Here's a case where I really enjoyed myself in Haskell-land:  http://codepad.org/hlcOuVJi
17:25:39 <FunctorSalad> here it could be "iton" or so
17:25:43 <JoeyA> (mainly because everything was Integer)
17:26:22 <JoeyA> When I tried porting this to C, I ran into the really annoying reality of C's division operator:  it tends to round to zero, but this is implementation-defined.
17:26:37 <monochrom> ArchemedianCompleteTotalOrderField
17:26:59 <Eduard_Munteanu> Heh.
17:27:16 <FunctorSalad> JoeyA: btw, pattern (=LHS) signatures aren't really casts, they only ever restrict a polymophic type to a particular one
17:27:23 <JoeyA> When will there be a MutableArchemedianCompleteTotalOrderField monad?
17:27:48 <JoeyA> Right, they're hints.
17:27:49 <FunctorSalad> like "\(x::Int) -> x" narrowing down the type "forall a. a -> a"
17:28:24 <FunctorSalad> ah. just seemed you were afraid that it can force some violent conversion ;)
17:28:42 <FunctorSalad> though some of the predefined instances are a bit violent IIRC
17:28:56 <FunctorSalad> (truncation)
17:29:02 <JoeyA> Though I do like how in C++, you can say things like (Zombie)FunctorSalad :-)
17:29:15 <Olathe> > let isqrt :: (Integral a) => a -> a; isqrt 0 = 0; isqrt n = let (d,m) = divMod n 4; h = 2*isqrt d; h' = h + 1 in if h'*h' > n then h else h' in map isqrt [1..16]
17:29:16 <lambdabot>   [1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4]
17:29:24 <Eduard_Munteanu> unsafeCoerce does that too in Haskell if I'm not mistaken.
17:29:24 <JoeyA> Though people will generally tell you that dynamic_cast<Zombie>(FunctorSalad) is far more elegant.
17:29:33 <FunctorSalad> JoeyA: hmm that corresponds to Data.Typeable.cast more or less
17:29:40 <Olathe> isqrt = floor . sqrt . fromIntegral, but without rounding errors.
17:29:45 <FunctorSalad> the dynamic one
17:29:52 <FunctorSalad> (dynamic but checked)
17:29:56 <JoeyA> Is there a static cast library in Haskell?
17:30:03 <FunctorSalad> dynamic and unchecked is "unsafeCoerce"
17:30:04 <Eduard_Munteanu> Though it's probably a lot more unpredictable given boxing and all other Haskell stuff.
17:30:05 <JoeyA> (that can convert Float to Integer, etc. ?)
17:30:19 <kmc> JoeyA, (sr::Int) is not a cast
17:30:38 <FunctorSalad> JoeyA: unsafeCoerce, I did exactly that once :)
17:30:57 <kmc> JoeyA, we wouldn't use the word "cast" to mean "convert"
17:30:58 <FunctorSalad> not sure if I had to do it on the Int or the Int# in it
17:31:13 <Eduard_Munteanu> Brrr... (int) fl_value in C rather converts.
17:31:23 <FunctorSalad> kmc: ok, it *parses* binary floats :D
17:31:27 <JoeyA> Okay, converts
17:31:32 <Olathe> JoeyA: Doubles have rounding errors.
17:31:34 <Olathe> > let x :: Double; x = fromIntegral 28917398123098123098120398012983091283098109238903182098309810293803182 in floor . sqrt $ x
17:31:36 <lambdabot>   170051163251234850167225330748620800
17:31:49 <kmc> JoeyA, you want a library of lots of conversions?
17:31:53 <Olathe> > let isqrt :: (Integral a) => a -> a; isqrt 0 = 0; isqrt n = let (d,m) = divMod n 4; h = 2*isqrt d; h' = h + 1 in if h'*h' > n then h else h' in isqrt 28917398123098123098120398012983091283098109238903182098309810293803182
17:31:55 <lambdabot>   170051163251234841701733766819600837
17:31:59 <kmc> JoeyA, i don't know of a single library to do it
17:32:04 <FunctorSalad> obviously you won't get a float representing the same number as the int
17:32:13 <kmc> in the extreme case one could imagine a class Convert a b where { convert :: a -> b }
17:32:19 <soupdragon> > 170051163251234841701733766819600837^2
17:32:20 <lambdabot>   28917398123098123098120398012983091210184125429149754601269816011100569
17:32:21 <JoeyA> I know that in the Prelude, you can (carefully) throw fromIntegrals and such at all your woes.
17:32:24 <FunctorSalad> I meant if you actually want to parse floats from a binary file
17:32:30 <FunctorSalad> (quickly)
17:32:36 <kmc> but Haskell takes the attitude that there's not always one particular special way to convert between types
17:32:41 <kmc> e.g. Float -> Int, you might want floor, ceil, or round
17:33:01 <Eduard_Munteanu> unsafeCoerce is more like float x; int *y = &x; <use *y> in C, right?
17:33:02 <kmc> also that "convert" function would be unwieldy for other reasons
17:33:04 <monochrom> @djinn Int -> Float
17:33:05 <lambdabot> Error: Undefined type Int
17:33:12 <monochrom> @djinn a->b
17:33:12 <lambdabot> -- f cannot be realized.
17:33:22 <FunctorSalad> IIRC I found some ghc primitive for Int to Float later
17:33:25 <kmc> yes, unsafeCoerce is a runtime no-op which simply tells the type checker to shut up
17:33:41 <kmc> however, unlike C, you have very few guarantees in Haskell about the actual in-memory layout of your values
17:33:45 <Olathe> > let x = 28917398123098123098120398012983091283098109238903182098309810293803182 in x >= 170051163251234841701733766819600837^2 && x < 170051163251234841701733766819600838^2
17:33:47 <lambdabot>   True
17:33:47 <kmc> so circumventing the type checker is very rarely safe
17:34:23 <Eduard_Munteanu> I suppose there are (common-sense) rules about unboxed types though.
17:34:25 <kmc> GHC only specifies a few circumstances where unsafeCoerce will behave reasonably, and that's with you making no mistakes
17:34:26 <FunctorSalad> Int# -> Float# on a fixed architecture being an exception, I guess
17:34:34 <FunctorSalad> or is that undefined too
17:35:16 <Eduard_Munteanu> I'd expect Int# -> Char# to work depending on endianness.
17:35:25 <kmc> don't they have different sizes?
17:35:39 <syntaxglitch> but does unsafeCoerce allow you to implement the Evil Magic Fast Inverse Square Root, that's the important question
17:35:41 <Eduard_Munteanu> Most likely.
17:35:43 * kmc realizes he does not know the encoding used for Char#
17:36:15 <Eduard_Munteanu> Neither do I, but in C it's a byte, so if these things still hold in Haskell a bit...
17:36:29 <FunctorSalad> likely a word, considering it has 130k or so elts
17:36:35 <Saizan> there's a Char#?
17:36:39 <kmc> it's definitely not a byte in Haskell, because it includes all of Unicode
17:36:43 <Eduard_Munteanu> So they're wide chars then.
17:36:45 <kmc> @info Char
17:36:45 <lambdabot> Char
17:36:48 <FunctorSalad> > length [ chr 0 .. ]
17:36:49 <lambdabot>   1114112
17:36:52 <FunctorSalad> neat eh? ;)
17:37:01 <Eduard_Munteanu> Heh :).
17:37:23 <kmc> Eduard_Munteanu, if Char# and Int# have different size then i'd expect it would break terribly
17:37:30 <FunctorSalad> counted the unicode category member counts the other day
17:37:43 <FunctorSalad> there are some odd singletons for paragraphbreak and linebreak
17:38:19 <Eduard_Munteanu> kmc: yes, though there sure are some C programmers out there that thing all their machines are little endian :)
17:38:28 <Eduard_Munteanu> s/their//
17:38:48 <theorbtwo> Interseting.  That claims there are 0x110000 valid Chars... which is quite a lot more then the unicode consortium thinks there are.
17:38:48 <kmc> of course
17:38:52 <theorbtwo> (0x10FFFF)
17:39:06 <kmc> > ord maxBound
17:39:07 <lambdabot>   1114111
17:39:47 <FunctorSalad> + ghc -e ':t GHC.Float.int2Float'
17:39:48 <FunctorSalad> GHC.Float.int2Float :: Int -> Float
17:39:57 <FunctorSalad> that one was it
17:40:02 <Eduard_Munteanu> > length [ fromEnum(chr 0) :: Char# ..]
17:40:03 <lambdabot>   Not in scope: type constructor or class `Char#'
17:40:09 <monochrom> There are holes in the unicode table. The code point with highest numerical value is 0x10FFFF. This does not imply there are that many code points.
17:40:33 <theorbtwo> monochrom: Yes.  I said that haskell thinks there are *more* then that.
17:40:41 <FunctorSalad> + ghc -e ':t GHC.Float.int2Double'
17:40:42 <FunctorSalad> GHC.Float.int2Double :: Int -> Double
17:41:21 <theorbtwo> At the same time, that's not the largest 64-bit integer, or such.
17:41:49 <Eduard_Munteanu> :t chr
17:41:50 <lambdabot> Int -> Char
17:42:01 <syntaxglitch> there are far too many unicode code points for anybody to keep track of, so I say just round up to aleph-null
17:42:11 <Eduard_Munteanu> Aaah...
17:42:11 <FunctorSalad> Once you're past 65536 you can relax and be really wasteful I suppose :)
17:42:53 <Eduard_Munteanu> [chr 0 ..] isn't the same as map chr [ 0 .. ]
17:43:12 <FunctorSalad> "0x10FFFF" doesn't look like a coincidence
17:43:13 <Eduard_Munteanu> I was wondering why it isn't a power-of-2 :)
17:43:27 <FunctorSalad> maybe someone wants to do funny things with utf8 there
17:43:37 <FunctorSalad> (I know, Char isn't supposed to have an encoding)
17:44:34 <monochrom> Notice that 0x110000 = 0x100000 + 0x010000, a sum of two powers of two.
17:44:54 <kar-1> hmm. does this dialectica interpretation assume the axiom of choice?
17:45:02 <monochrom> At first there was just the basic plain, which explains 0x010000, a power of two.
17:45:26 <monochrom> Later there was added the higher plains, which explains 0x100000, another power of two.
17:45:38 <monochrom> s/plain/plane/
17:46:31 <FunctorSalad> Eduard_Munteanu: " [chr 0 ..] isn't the same as map chr [ 0 .. ]"
17:46:40 <FunctorSalad> should be the sam
17:46:42 <FunctorSalad> *same
17:46:57 <Eduard_Munteanu> > length $ map chr [ 0 .. ]
17:47:01 <lambdabot>   mueval-core: Time limit exceeded
17:47:13 <FunctorSalad> > ['0'..] -- *this* is bogus though
17:47:14 <lambdabot>   "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwx...
17:47:19 <FunctorSalad> > length ['0'..] -- *this* is bogus though
17:47:20 <lambdabot>   1114064
17:47:31 <kar-1> roconnor, I dont want to assume the axiom of choice :)
17:47:40 <FunctorSalad> btw to be safe even against someone deciding to add negative codepoints...
17:47:47 <FunctorSalad> > [minBound .. ]
17:47:48 <lambdabot>   [()]
17:48:01 <FunctorSalad> > [minBound .. ] :: String
17:48:02 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
17:48:05 <FunctorSalad> very funny, lambdabot :p
17:48:22 <dmwit> hm
17:48:26 <hpc> saw that one coming
17:48:28 <Eduard_Munteanu> How does this work really? Redefined the [] monad/comprehension?
17:48:28 <dmwit> :t fun
17:48:29 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
17:48:33 <kmc> Eduard_Munteanu, which?
17:48:36 <dmwit> > fun "um"
17:48:37 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:48:37 <lambdabot>    `SimpleReflect.FromExpr ...
17:48:40 <dmwit> > expr "um"
17:48:41 <FunctorSalad> hpc: the defaulting?
17:48:41 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
17:48:41 <lambdabot>         against inferred ...
17:48:45 <Eduard_Munteanu> kmc: the fact that [chr 0 ..] is bounded.
17:48:46 <dmwit> > var "um"
17:48:46 <FunctorSalad> or the zero digti
17:48:47 <lambdabot>   um
17:48:49 <FunctorSalad> *digit
17:48:51 <dmwit> > var [minBound..]
17:48:52 <lambdabot>   !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]...
17:48:53 <hpc> the :: String thing being unexpected
17:48:58 <dmwit> iiinteresting
17:48:58 <kmc> Eduard_Munteanu, nothing that fancy.  it's sugar for enumFrom (chr 0)
17:49:09 <kmc> and for bounded types, enumFrom will produce a finite list
17:49:14 <kmc> > [False ..]
17:49:15 <lambdabot>   [False,True]
17:49:18 <kmc> > [LT ..]
17:49:19 <lambdabot>   [LT,EQ,GT]
17:49:24 <kmc> > enumFrom False
17:49:24 <lambdabot>   [False,True]
17:49:41 <FunctorSalad> Eduard_Munteanu: it's just arithmetic sequence syntax. the special thing is the Bounded class
17:49:43 <Eduard_Munteanu> kmc: oh.
17:49:52 <dmwit> FunctorSalad: No, the special thing is the Enum class.
17:49:54 <kmc> > length (enumFrom False)
17:49:54 <lambdabot>   2
17:49:55 <dmwit> It doesn't need to be bounded.
17:49:58 <kmc> > length (enumFrom (ord 0))
17:49:59 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:49:59 <lambdabot>    arising from the literal `0...
17:50:01 <kmc> > length (enumFrom (chr 0))
17:50:02 <lambdabot>   1114112
17:50:03 <Eduard_Munteanu> But I presume [1 ..] stuff is hardcoded sugar?
17:50:08 <FunctorSalad> dmwit: err, for minBound?
17:50:13 <Eduard_Munteanu> that resolves to enumFrom?
17:50:13 <kmc> Eduard_Munteanu, [a..] is sugar for (enumFrom a)
17:50:20 <kmc> [a..b] is sugar for (enumFromTo a b)
17:50:25 <FunctorSalad> @ty minBound
17:50:27 <dmwit> FunctorSalad: Well, for minBound naturally yes. But E_M wasn't talking about minBound anywhere. =)
17:50:27 <lambdabot> forall a. (Bounded a) => a
17:50:30 <Eduard_Munteanu> I see.
17:50:31 <kmc> [a,b..c] is sugar for (enumFromThenTo a b c)
17:50:45 <FunctorSalad> dmwit: he asked how [ minBound .. ] works
17:51:06 <dmwit> His literal question was how [chr 0 ..] worked.
17:51:14 <FunctorSalad> (it doesn't prove the minBound of course ;) you could define a bogus instance)
17:51:27 <FunctorSalad> ok, I presumed then
17:52:04 <Eduard_Munteanu> So the syntax is proper sugar or Prelude stuff? I don't mean the enumFrom part, but the actual [1 ..] syntax.
17:52:14 <dmwit> It's sugar, yes.
17:52:20 <FunctorSalad> that's hardwired
17:52:23 <FunctorSalad> not prelude
17:52:24 <Eduard_Munteanu> I see, thanks.
17:52:37 <dmwit> If you don't import the Prelude, you can name a function enumFrom and get different behavior for [1 ..].
17:52:48 <FunctorSalad> maybe the syntax isn't hardwired to the stock enumFromTo part though
17:52:56 <FunctorSalad> some sugars are rebindable
17:53:07 <kmc> dmwit, only with -XNoImplicitPrelude i think
17:53:14 <kmc> otherwise it really desugars to Prelude.enumFromTo
17:53:28 <dmwit> kmc: That's the way not to import the Prelude, yes. =)
17:53:46 <mauke> no, that would be import Prelude ()
17:53:54 <Eduard_Munteanu> I wonder if one could define '..' as some sort of unary infix operator.
17:53:58 <FunctorSalad> ah, that funny trivia which answers "wth is there this pragma if you can just do import Prelude()"
17:54:02 <FunctorSalad> no I remember ;)
17:54:04 <FunctorSalad> *now
17:54:11 <dmwit> Eduard_Munteanu: You could, if it weren't reserved syntax.
17:54:20 <Eduard_Munteanu> Oh.
17:54:26 <FunctorSalad> -XNIP does both
17:54:38 <FunctorSalad> no import, and unqualify sugar expansions
17:55:50 <FunctorSalad> hmm... -WAbbreviateLanguagePragmasByInitialismsPlease
17:55:55 <dmwit> Hm, in my tests, you can't override [3 ..] syntax even with -XNIP.
17:56:01 <dmwit> So maybe I was wrong.
17:56:06 <FunctorSalad> (might be a good idea )
17:56:29 <Eduard_Munteanu> Writing the actual definition seems strange... `..` = enumFrom ?
17:56:34 <FunctorSalad> I use the capital letters as snippet abbreviations, iirc it's unique
17:56:56 <Eduard_Munteanu> But it needs to fuse with the external list brackets :/
17:56:57 <FunctorSalad> Eduard_Munteanu: the "from" is in the sense of "starting from" :)
17:57:01 <FunctorSalad> not conversion
17:57:11 <Eduard_Munteanu> FunctorSalad: yes I know.
17:57:34 <FunctorSalad> a defined function can't fuse with brackets, right
17:57:35 <Eduard_Munteanu> I was trying to define '..' in '[1 ..]' in terms of enumFrom 1.
17:57:43 <FunctorSalad> it's baked into the parser
17:57:56 <FunctorSalad> I don't think it ever parses as a list literal
17:58:04 <dmwit> > let (...) = enumFrom in (3 ...)
17:58:05 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
17:58:13 <Eduard_Munteanu> Nice :)
17:58:22 <monochrom> [x..] is enumFrom x. [x..y] is enumFromTo x y. Don't expect too much regularity here.
17:58:34 <dmwit> > let (...) in enumFromTo in 3 ... 5
17:58:35 <lambdabot>   <no location info>: parse error on input `in'
17:58:43 <dmwit> > let (...) = enumFromTo in 3 ... 5
17:58:44 <lambdabot>   [3,4,5]
17:58:46 <monochrom> And there is no [..y]
17:59:08 <Eduard_Munteanu> > [1, 3, 5, 7, 11, 13 ..]
17:59:09 <lambdabot>   <no location info>: parse error on input `..'
17:59:09 <Eduard_Munteanu> :))
17:59:10 <dmwit> and [x,y .. z] is enumFromThenTo x y z
17:59:24 <dmwit> Additional commas are not allowed.
17:59:45 <dmwit> So, yeah, there's four different .. forms.
17:59:46 <monochrom> trying to deconstruct syntax sugar is vain. there is a reason it is syntax sugar not function application.
18:00:16 <kmc> the reason is that we don't have mixfix ;)
18:00:20 <Eduard_Munteanu> Though Haskell seems to be able to do impossible things at first sight, as in using list comprehensions to solve equations. :)
18:00:47 <Eduard_Munteanu> or find primes.
18:00:49 <kmc> _,_.._ :: (Enum a) => a -> a -> a -> [a]
18:01:04 <FunctorSalad> aah, you were trying to put the four variants into a general rule?
18:01:08 <dmwit> kmc: I'm not sure mixfix would really help here. It translates to different functions depending on how many arguments there are... that doesn't play nicely with partial application.
18:01:38 <FunctorSalad> it's just unique lexically from the comma and double dots as others noted :)
18:01:43 <kmc> well, _,_.._ and _.._ and _.. are all different function names
18:01:52 <FunctorSalad> they aren't legal in that context in any other way
18:01:59 <kmc> you'd have to define precedences for them
18:02:04 <kmc> so they don't conflict in the parser
18:02:09 <kmc> but Agda could in fact deal with it, i believe
18:02:10 <dmwit> man
18:02:15 <FunctorSalad> err, except... hehe
18:02:20 <FunctorSalad> > [ Prelude.. ]
18:02:21 <dmwit> Mixfix is great for the user, but must be a nightmare for the parser-writer.
18:02:21 <lambdabot>   <no location info>: parse error on input `]'
18:02:22 <FunctorSalad> lol
18:02:34 <dmwit> > [True..] -- another example of that
18:02:34 <kmc> dmwit, indeed.  it's still a mystery to me how it works, and i've read at least one paper on the subject
18:02:35 <lambdabot>   <no location info>: parse error on input `]'
18:02:45 <dmwit> > [True ..] -- but this works fine =)
18:02:46 <lambdabot>   [True]
18:02:48 <kmc> Agda is much stricter about whitespace than Haskell is
18:02:51 <kmc> for this reason
18:03:55 <Eduard_Munteanu> On a related note, I wish Haskell could do pattern matching on a ++ b, where at least one of them is a constant. That should be reasonable.
18:03:59 <FunctorSalad> the "stepBy" variant is pretty superfluous anyway if you don't need extreme performance
18:04:06 <Traveler8> @
18:04:24 <Saizan> Eduard_Munteanu: stripPrefix
18:04:30 <FunctorSalad> > fmap fmap fmap (*) 2 [1 .. ]
18:04:31 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:04:32 <lambdabot>    `GHC.Num.Num t' arising ...
18:04:36 <Traveler8> @type map
18:04:37 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:04:38 <Eduard_Munteanu> Saizan: hm, lemme see...
18:04:40 <FunctorSalad> :(
18:04:41 <Eduard_Munteanu> :t stripPrefix
18:04:43 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
18:04:54 <Traveler8> @help
18:04:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:05:01 <Traveler8> @list
18:05:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:05:10 <Eduard_Munteanu> Yeah, that would do better than huge cons patterns :)
18:05:25 <Saizan> foo str | Just b <- stripPrefix a = ..
18:05:30 <FunctorSalad> > fmap  (* 2) [1 .. ]
18:05:32 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
18:05:37 <Saizan> s/a/a str/
18:05:50 <Eduard_Munteanu> Ah, thanks.
18:06:10 <aavogt> view patterns can let you avoid the str binding
18:06:34 <FunctorSalad> > (*) <$> [2] <*> [1 .. ]
18:06:35 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
18:06:37 <FunctorSalad> lol
18:06:47 <Traveler8> @pl fold l f g=case l of{[]->g;(h:t)->f h (fold t f g);}
18:06:47 <lambdabot> (line 1, column 21):
18:06:47 <lambdabot> unexpected "{"
18:06:47 <lambdabot> expecting variable, "(", operator or end of input
18:07:03 <FunctorSalad> (that such a stunt actually worked with lambdabot at first attempt)
18:07:07 <mauke> stripPrefix: why aren't you called dropPrefix
18:08:15 <dmwit> Traveler8: fold doesn't do case or list comprehensions
18:08:17 <dmwit> err
18:08:20 <Eduard_Munteanu> aavogt: is that the @ stuff ?
18:08:22 <dmwit> s/fold/?pl/
18:08:24 <FunctorSalad> Eduard_Munteanu: well, there isn't any other example on matching on anything except constructors
18:08:31 <aavogt> Eduard_Munteanu: no
18:08:57 <FunctorSalad> (which pretty much by definition admit case-matching)
18:09:05 <Eduard_Munteanu> Yeah.
18:09:15 <aavogt> > let f (stripPrefix "tro" -> x) = x in f "trololol"
18:09:16 <lambdabot>   Just "lolol"
18:09:19 <dmwit> :t \l f g -> case l of {[] -> g; (h:t) -> f h (fold t f g) }
18:09:20 <lambdabot> Not in scope: `fold'
18:09:28 <FunctorSalad> there are view patterns, but they aren't really matching at all
18:09:30 <dmwit> :t fix (\fold l f g -> case l of {[] -> g; (h:t) -> f h (fold t f g) })
18:09:31 <lambdabot> forall t t1. [t1] -> (t1 -> t -> t) -> t -> t
18:09:44 <dmwit> :t \l f g -> foldr f g l
18:09:46 <lambdabot> forall a b. [a] -> (a -> b -> b) -> b -> b
18:09:51 <dmwit> ?pl \l f g -> foldr f g l
18:09:51 <lambdabot> flip (flip . foldr)
18:09:55 <mail> > print
18:09:56 <lambdabot>   {()-><IO ()>}
18:09:59 <dmwit> Traveler8: there ya go!
18:10:06 <FunctorSalad> they're just a convenient way to do function compo in an arbitrary argument
18:10:13 <FunctorSalad> (as we just covered in the other chan)
18:11:09 <Saizan> which chan?
18:11:32 <Eduard_Munteanu> f (stripPrefix "tro" -> Just x) = x in f "trololol"
18:11:35 <Eduard_Munteanu> > f (stripPrefix "tro" -> Just x) = x in f "trololol"
18:11:36 <lambdabot>   <no location info>: parse error on input `='
18:11:40 <Eduard_Munteanu> > let f (stripPrefix "tro" -> Just x) = x in f "trololol"
18:11:41 <lambdabot>   "lolol"
18:11:42 <FunctorSalad> (actually matching "foo (f x) = y" would require surjectivity for existence and injectivity for uniqueness...)
18:11:45 <Eduard_Munteanu> (dang)
18:11:48 <FunctorSalad> Saizan: #haskell-blah
18:12:03 <kar-1> I believe that this dialectica interpretation does not prove wrong what I said about the goldbach.. for example corollary 2.4.2 in roconnor's pdf only talks about the double negation translated formula which has different meaning in intuitionistic logic than the direct interpretation of the classical proposion in intuitionistic framework
18:12:17 <Eduard_Munteanu> > let f (stripPrefix "tro" -> Just x) = x in f "torololol"
18:12:18 <Traveler8> @pl foldr
18:12:18 <lambdabot> foldr
18:12:18 <lambdabot>   "*Exception: <interactive>:1:137-171: Non-exhaustive patterns in function f
18:12:44 <soupdragon> kar-1 yes it's tricky that, beacuse sometimes people mean one rather than the other
18:12:46 <JoeyA> Is there a built-in function for constructing an Array from a list using 0-based indexing?
18:12:52 <JoeyA> Or do I have to do it manually like so:
18:12:53 <JoeyA> fromList :: [e] -> Array Int e; fromList xs  = array (0, len-1) (zip [0..len-1] xs) where len = length xs
18:12:54 <FunctorSalad> fun fact: you *can* have f^(-1) x as a pattern for general f ;)
18:13:03 <dmwit> JoeyA: listArray
18:13:05 <dmwit> :t listArray
18:13:06 <FunctorSalad> I defined it as a defsetf in my emacs the other day ;)
18:13:06 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
18:13:20 <dmwit> ?hoogle [a] -> Array i a
18:13:21 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
18:13:21 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
18:13:21 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
18:13:35 <dmwit> JoeyA: And there's how you can answer that kind of question yourself in the future. =)
18:13:37 <FunctorSalad> (setf (preimage f x) y) ===> (setf x (funcall f y))
18:14:26 <FunctorSalad> ("preimage" isn't evaluated; it's a macro... actually this is just view patterns, doh :))
18:15:17 <Eduard_Munteanu> BTW, has anybody had any luck or tried using Haskell (with external libs) as an alternative to Matlab/Octave/you-name-it ?
18:15:42 <soupdragon> pome people are working on that now
18:15:47 <soupdragon> in #haskell-math
18:15:52 <Eduard_Munteanu> I tried doing some FFT plots, but it's still easier in Octave.
18:15:58 <soupdragon> ongoing project
18:15:59 <FunctorSalad> (I just think it's cute how scary it looks "implicit definition of x, *and* computing preimages? :O")
18:16:06 <FunctorSalad> and these two cancel out to a triviality
18:16:13 <Eduard_Munteanu> soupdragon: wow, thanks.
18:16:22 <soupdragon> it's very new though
18:16:32 <aavogt> Eduard_Munteanu: which plotting library?
18:17:25 <Eduard_Munteanu> aavogt: Graphics.Plot
18:18:02 <FunctorSalad> btw gtk2hs being broken with 6.12.2 is not just me I presume?
18:18:16 <dmwit> correct
18:18:19 <FunctorSalad> mailing list mentions it, but not sure to which versions of gtk2hs it applies
18:18:25 <aavogt> Eduard_Munteanu: which package?
18:18:28 <dmwit> The problem is fixed in GHC HEAD.
18:18:31 <soupdragon> > ((sqrt(5)-1)/4:+(10+2*sqrt(5))/4)^5
18:18:32 <lambdabot>   260.8943539747922 :+ 574.89887956091
18:18:45 <SliMM> If I have a datatype, Square, with two different constructors for which only the 3rd argument is different
18:18:45 <soupdragon> my books lion to me
18:18:52 <soupdragon> what halve happened here
18:18:56 <dmwit> FunctorSalad: Just to make sure: what problem are you having?
18:19:04 <soupdragon> > (((sqrt(5)-1)/4):+((10+2*sqrt(5))/4))^5
18:19:05 <lambdabot>   260.8943539747922 :+ 574.89887956091
18:19:12 <soupdragon> :(
18:19:18 <Eduard_Munteanu> aavogt: hmatrix
18:19:22 <SliMM> How can I write a pattern that matches both constructors, when I deal only with the first two parameters?
18:19:24 <FunctorSalad> dmwit: let me look...
18:19:36 <Traveler8> @pl fold h t f g=f h (t f g)
18:19:36 <lambdabot> fold = ap . ((.) .) . flip id
18:19:49 <dmwit> FunctorSalad: If it's not a segfault, then it's probably not the known problem with 6.12.2.
18:20:07 <FunctorSalad> dmwit: err actually the most recent barrier is darcs's apparent nontermination o_O
18:20:17 <FunctorSalad> had some build error before that though
18:20:23 <Saizan> SliMM: you can't directly, but you could write a projection function and use that
18:20:25 <soupdragon> > abs (((sqrt(5)-1)/4):+((10+2*sqrt(5))/4))
18:20:26 <lambdabot>   3.631206610282869 :+ 0.0
18:20:33 <soupdragon> this book must be wrong
18:20:37 <soupdragon> what should I do?
18:20:38 <Eduard_Munteanu> Here's a little something I tried then: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25506#a25506
18:20:40 <FunctorSalad> somehow a recent commit makes pull seem to diverge for me
18:20:43 <Eduard_Munteanu> aavogt: ^
18:20:49 <FunctorSalad> or just take more than an hour or so
18:20:51 <SliMM> Saizan: Could you give me a little info about this function you mentioned?
18:21:02 <soupdragon> > abs (((sqrt(5)-1)/4):+((10+2*sqrt(5))/4))
18:21:02 <lambdabot>   3.631206610282869 :+ 0.0
18:21:14 <soupdragon> I've checked and double checked
18:21:25 <FunctorSalad> dmwit: the darcs in question is gtk2hs, not ghc, btw
18:21:53 <aavogt> FunctorSalad: from code.haskell.org?
18:21:54 <Saizan> SliMM: e.g. data Square = Foo X Y Z | Bar X Y W; extract :: Square -> (X,Y); extract (Foo x y _) = (x,y); extract (Bar x y _) = (x,y)
18:21:56 <Eduard_Munteanu> Works, but it's still a bit tricky to translate even functional stuff from Octave.
18:22:14 <FunctorSalad> to be fair to darcs, I had a severly messed with repo I think ;)
18:22:16 <aavogt> perhaps it was down momentarily, FunctorSalad?
18:22:32 <SliMM> Ah, yes, I understand the concept now
18:22:35 <SliMM> thanks
18:22:48 <FunctorSalad> aavogt: hmm could be? thought it was looping too, but maybe not
18:23:08 <Traveler8> @pl const x=id
18:23:08 <lambdabot> const = const id
18:23:29 <Traveler8> @pl const x f=f
18:23:29 <lambdabot> const = const id
18:23:43 <copumpkin> nice
18:23:56 <copumpkin> :t let const = const id in const
18:23:57 <lambdabot>     Occurs check: cannot construct the infinite type: t = (a -> a) -> t
18:23:57 <lambdabot>     Probable cause: `const' is applied to too many arguments
18:23:57 <lambdabot>     In the expression: const id
18:23:58 <FunctorSalad> id const = const id
18:23:59 <FunctorSalad> even
18:24:02 <FunctorSalad> *g*
18:24:05 <soupdragon> > (sqrt(5)-1)/4
18:24:06 <lambdabot>   0.30901699437494745
18:24:11 <Nereid> :t const id
18:24:12 <lambdabot> forall a b. b -> a -> a
18:24:15 <soupdragon> > (10+2*sqrt(5))/4
18:24:16 <lambdabot>   3.618033988749895
18:24:17 <mail> > pi
18:24:17 <lambdabot>   3.141592653589793
18:24:19 <Eduard_Munteanu> > fix const
18:24:20 <Nereid> :t const
18:24:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
18:24:21 <lambdabot> forall a b. a -> b -> a
18:24:21 <soupdragon> why the hell is it 3....
18:24:24 <FunctorSalad> :t const id const id const id
18:24:25 <lambdabot> forall b a. b -> a -> a
18:24:30 <Nereid> const id = flip const?
18:24:55 <Makoryu> :t [const id, flip const]
18:24:56 <lambdabot> forall b a. [a -> b -> b]
18:25:23 <FunctorSalad> I'd call these two "fst" and "snd" btw ;)
18:25:38 <Nereid> const id const
18:25:38 <copumpkin> zomg
18:25:39 <FunctorSalad> if these weren't taken by their uncurried brethren
18:25:39 <Nereid> > const id const
18:25:41 <lambdabot>   {()->()}
18:25:41 <Nereid> :t const id const
18:25:42 <lambdabot> forall a. a -> a
18:25:46 <Nereid> lol
18:25:49 <Eduard_Munteanu> > fix (const . id)
18:25:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
18:25:50 <Nereid> duh
18:25:51 <Nereid> obviously
18:25:52 <Nereid> :(
18:25:55 <Eduard_Munteanu> > fix (const id)
18:25:56 <lambdabot>   {()->()}
18:26:37 <aavogt> Eduard_Munteanu: Chart might have a nicer interface than a direct translation of gnuplot
18:26:37 <Olathe> > const id 27 (+3) 5
18:26:38 <lambdabot>   8
18:26:49 <Olathe> > flip const 27 (+3) 5
18:26:51 <lambdabot>   8
18:28:21 <FunctorSalad> *waits for the anonymous reader Applicative variants*
18:28:45 <FunctorSalad> bonus points for using the really obscure combinators
18:28:53 <FunctorSalad> (from Applicative)
18:29:06 <aavogt> of const?
18:29:11 <FunctorSalad> yeah ;)
18:29:56 <FunctorSalad> and I don't know if (->) E even has an inst
18:30:09 <aavogt> > (*) <*> 2
18:30:10 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
18:30:11 <lambdabot>    arising from a use of `e_12' at <...
18:30:12 <Olathe> > (const <$> pure id) 2
18:30:13 <lambdabot>   {()->{()->()}}
18:30:17 <Olathe> Lies
18:30:26 <FunctorSalad> it has some respectability by the connection to S and K ;)
18:30:49 <Olathe> > (const <$> pure 2) 2 3
18:30:50 <lambdabot>   2
18:31:24 <aavogt> > (*) <*> pure id $ 2
18:31:25 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
18:31:25 <lambdabot>    arising from a use of `e_12' at <...
18:31:30 <FunctorSalad> @ty many
18:31:31 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
18:31:40 <FunctorSalad> hmm
18:34:01 <FunctorSalad> would Sed-as-a-monad be useful?
18:34:19 <FunctorSalad> or is the original unbeatable for its conciseness
18:35:47 <SliMM> Shouldn't "error" not take into consideration the return type?
18:36:02 <Cale> SliMM: hmm?
18:36:06 <Cale> :t error
18:36:07 <lambdabot> forall a. [Char] -> a
18:36:20 <Cale> It's completely polymorphic in its result type
18:36:21 <FunctorSalad> types are under the stipulation "if it every returns"
18:36:25 <Olathe> @src error
18:36:26 <lambdabot> error s = throw (ErrorCall s)
18:36:30 <FunctorSalad> error never returns, so it can promise anything
18:36:31 <Olathe> @src throw
18:36:31 <lambdabot> throw exception = raise# exception
18:36:37 <FunctorSalad> s/every/ever/
18:36:54 <Cale> tsk, I should try and remove all the GHC-specific implementation stuff from @src
18:37:01 <hpc> @src raise#
18:37:02 <lambdabot> Source not found.
18:37:04 <Cale> error is a primitive
18:37:07 <SliMM> ok, let me put it this way, how do I should raise an error?
18:37:20 <FunctorSalad> a friend of mine who is not a type theorist pointed out that this type stuff is totally circular logic ;)
18:37:22 <Traveler8> @src foldr
18:37:22 <lambdabot> foldr f z []     = z
18:37:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:37:23 <Olathe> @type fail
18:37:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
18:37:24 <hpc> just use error
18:37:27 <hpc> or fail
18:37:39 <Cale> SliMM: What are you trying to do? Cause the whole program to unconditionally halt, or just inform the caller that something went wrong?
18:38:05 <SliMM> Cale: I just want to inform the caller that something went wrong
18:38:17 <hpc> oh, exceptions are overkill for that
18:38:19 <Cale> Okay, then you want to use a type like Maybe or Either String
18:38:20 <hpc> use a Maybe
18:38:30 <FunctorSalad> (when I tried to explain how the infinite loop has fully polymorphic type... and actually, circular logic is exactly what it is, as we know...)
18:38:38 <Cale> Maybe Integer, for instance
18:38:42 <copumpkin> mmm
18:38:44 <Cale> Either String Integer
18:38:46 <copumpkin> I love infinite loops
18:38:58 <Cale> The caller then can pattern match on the result to determine if there was an error
18:39:12 <FunctorSalad> (except that the types take the blame for circular logic, not me ;))
18:39:36 <SliMM> Maybe "error" was not working because I use Hugs?
18:40:59 <Cale> error should work, but it produces an uncatchable exception that kills your program (or in GHC, possible to catch, but really fiddly to do so)
18:41:36 <Cale> Note that error only produces an exception if and when it's actually evaluated.
18:41:55 <Cale> > let f x y = x in f 6 (error "oops")
18:41:56 <lambdabot>   6
18:41:58 <SliMM> Cale: it just says Type error in guarded expression
18:42:09 <SliMM> when I try to use fail/error
18:42:17 <Cale> SliMM: Can you paste your code on a pastebin somewhere?
18:42:27 <Cale> fail is not the same as error
18:42:36 <Cale> actually, you should mostly try to ignore that fail exists.
18:42:48 <copumpkin> :t fail
18:42:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
18:42:54 <copumpkin> > fix fail
18:42:55 <lambdabot>   ""
18:42:59 <erikc> anyone have any experience getting ghc up and running on aix?
18:43:07 <SliMM> hmm
18:43:08 <Cale> Many people consider its inclusion in the Monad class a bug in the standard.
18:43:24 <hpc> :t fix
18:43:25 <lambdabot> forall a. (a -> a) -> a
18:43:25 <copumpkin> no true scotsman wouldn't consider it a bug
18:43:29 <Olathe> Why do they consider it a bug ?
18:43:34 <FunctorSalad> SliMM: there's a somewhat subtle catch with error handling by Maybe and Either...
18:43:43 <Cale> Olathe: Because many monads can't implement fail in a meaningful way
18:43:45 <SliMM> Cale: I get the same error with "error"
18:43:47 <Olathe> Ahh
18:44:04 <Cale> SliMM: can I see your code?
18:44:15 <Cale> What error exactly are you getting?
18:44:17 <SliMM> Cale: sec
18:44:21 <copumpkin> Olathe: it also has nothing to do with mathematical monads, and is just about pattern matches in do expressions
18:44:36 <Olathe> I see.
18:44:58 <hpc> actually, how would one go about catching the result of error?
18:45:05 <hpc> if catch doesn't work
18:45:10 <FunctorSalad> with stream-style datatypes, say a function Stream A -> Maybe (Stream B), it forces the determination whether the *whole stream* was processed succesfully before you can get your hands on one element of the result
18:45:12 <copumpkin> it does
18:45:12 <Cale> hpc: You need to use the catch from Control.Exception
18:45:20 <hpc> blech
18:45:31 <Cale> hpc: and you need to ensure that the error is evaluated during the execution of the IO action inside the catch
18:45:37 <SliMM> Cale:
18:45:42 <SliMM> Cale: http://stikked.com/view/4b01cdab
18:45:46 <FunctorSalad> that's because the only thing you can do as a first step with a Maybe Foo is ask whether it is a Just or a Nothing
18:45:48 <Cale> hpc: You can try to accomplish that using Control.Exception.evaluate
18:46:11 <FunctorSalad> (which forces answering the question for the whole stream)
18:46:18 <hpc> this would also catch things like dividing by zero, right?
18:46:28 <hpc> i know that can't be caught by prelude catch
18:47:04 <FunctorSalad> you must catch the right type
18:47:11 <FunctorSalad> what was it? ErrorCall?
18:47:13 <Cale> SliMM: You're producing a string as the result in the otherwise case
18:47:17 <aavogt> you can catch SomeExceptionS
18:47:21 <aavogt> which is anything
18:47:28 <Cale> SliMM: Perhaps you meant to have some parens around the concatenated string?
18:47:50 <hpc> nifty
18:47:57 <Cale> SliMM: Remember that function application binds more strongly than any infix operator
18:48:04 <Cale> SliMM: So when you write:
18:48:08 <Cale> error "Square cannot be fixed to digit " ++  show x ++ "."
18:48:10 <Cale> it means
18:48:13 <SliMM> Oh, I get it
18:48:20 <Cale> (error "Square cannot be fixed to digit ") ++ (show x) ++ "."
18:48:25 <FunctorSalad> data GHC.Exception.ErrorCall = GHC.Exception.ErrorCall String
18:48:25 <FunctorSalad>   	-- Defined in GHC.Exception
18:48:25 <FunctorSalad> instance Show GHC.Exception.ErrorCall -- Defined in GHC.Exception
18:48:49 <SliMM> Yeah, sorry, I should have known that :-s
18:48:57 <FunctorSalad> and instance of Exception too, actually ;)
18:49:10 <FunctorSalad> and as aavogt said, SomeException will be fine too
18:49:16 <Cale> SliMM: Note that these exceptions will mean that your program unconditionally dies if fix is ever applied to anything other than an OpenSquare which satisfies that isDigitPossible condition
18:49:30 <Cale> (and the result of this function is actually demanded)
18:49:54 <SliMM> Cale: Yes, I will think of the appropriate way of doing it, I've just started
18:49:57 <QtPlatypus> I am running debian lucid and ghc doesn't seem to be in any of its apt repos
18:50:23 <aristid> QtPlatypus: debian lucid?
18:50:27 <QtPlatypus> ubantu lucid I mean
18:50:29 <Cale> You could use something like  fix :: Digit -> Square -> Either String Square
18:50:31 <aristid> ghc6
18:50:31 <QtPlatypus> aristid: Yes
18:50:40 <FunctorSalad> catching SomeException and just handling a particular case is slightly irresponsible though  AFAIK
18:50:51 <Cale> and then the successful case becomes   Right (FixedSquare c r x)
18:50:57 <FunctorSalad> (unless you rethrow stuff you don't know about)
18:51:09 <aristid> QtPlatypus: the package is simply ghc6
18:51:10 <Cale> and the unsuccessful cases become   Left ("Square cannot be fixed to digit " ++  show x ++ ".")
18:51:20 <Cale> and Left "Cannot fix a fixed square."
18:51:28 <aavogt> FunctorSalad: you can't do very much with a SomeException
18:51:29 <QtPlatypus> aristid: No joy
18:51:33 <aavogt> @type fromException
18:51:34 <lambdabot> Not in scope: `fromException'
18:51:39 <FunctorSalad> aavogt: they're Typeable
18:51:41 <aavogt> @type Control.Exception.fromException
18:51:42 <lambdabot> forall e. (GHC.Exception.Exception e) => GHC.Exception.SomeException -> Maybe e
18:51:51 <FunctorSalad> so you can just value-level typecase
18:52:20 <soupdragon> > 1+1/(7+1/(2+1/9))
18:52:20 <Cale> SliMM: and then the caller can pattern match on the result, like   case fix x mySquare of Left e -> ... handle error ...; Right s -> ... proceed with the Square s ...
18:52:20 <lambdabot>   1.1338028169014085
18:52:25 <soupdragon> > 1+1/(7+1/(2+1/9)) :: Rational
18:52:25 <lambdabot>   161 % 142
18:52:26 <FunctorSalad> but I don't remember if this admonition was from haskell actually or .NET :)
18:53:04 <aavogt> @type fix.break
18:53:05 <lambdabot>     Couldn't match expected type `[a]'
18:53:06 <lambdabot>            against inferred type `([a], [a])'
18:53:06 <lambdabot>       Expected type: (a -> Bool) -> [a] -> [a]
18:53:10 <FunctorSalad> (that it'd be bad to swallow some error which happens when the system is in a corrupted state, and where you are only supposed to cleanup, not resume operation)
18:53:29 <SliMM> Cale: Yeah, I'm considering that, but I'm not sure yet wether I should stop execution or not
18:55:24 <FunctorSalad> @type break
18:55:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:55:36 <FunctorSalad> aavogt: no way to instantiate that to an Endo
18:58:48 <aavogt> > fix (drop 1) "yes"
18:58:49 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
18:58:49 <lambdabot>         against inferr...
18:59:38 <aavogt> @type fix (\k x -> k $ drop 1 x)
18:59:40 <lambdabot> forall b a. [a] -> b
19:00:07 <copumpkin> nice, sounds useful
19:00:22 <aavogt> yup, it keeps dropping
19:00:25 <FunctorSalad> probably in Data.List.Split
19:00:36 <FunctorSalad> the breakage one
19:00:40 * aavogt hopes not
19:00:51 <dmwit> > fix (drop 1)
19:00:55 <lambdabot>   mueval-core: Time limit exceeded
19:00:55 <FunctorSalad> (my titling :))
19:01:00 <Olathe> @type foldr
19:01:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:07:33 <FunctorSalad> aavogt: assuming the result of breakage (with fixed predicate) has type ([a] -> [[a]])... it must be the fix of some ([a]->[[a]]) -> ([a]->[[a]])
19:10:02 <FunctorSalad> there's quite some choice actually which element of an intermediate [[a]] to break
19:10:10 <FunctorSalad> any will do
19:10:41 <FunctorSalad> as long as you don't loop trying to break the same unbreakables over and over
19:28:42 <cheater3> http://catb.org/~esr/faqs/hacker-howto.html#skills3
19:31:06 <copumpkin> cheater3: omg i wanna be hax0r, can u tech me hax?
19:31:17 <mauke> preflex: ? gamelearn
19:31:17 <preflex>  Helo i want 2 maek a gam liek canterstrake please msg me kthxbye
19:31:36 <soupdragon> lol
19:34:56 <aCiD2> HOW CAN I MAEK QUAEK
19:35:43 <soupdragon> good question
19:36:22 <copumpkin> set up us the bomb in the fualt
19:37:20 <JoeyA> First, you start to make Quake
19:37:23 <JoeyA> and then you make Quake.
19:37:40 <Xichekolas> then you play quake?
19:40:14 <soupdragon> :k Mu IORef
19:40:15 <lambdabot> Not in scope: type constructor or class `IORef'
19:40:19 <soupdragon> :k Mu STRef
19:40:19 <lambdabot>     `STRef' is not applied to enough type arguments
19:40:20 <lambdabot>     Expected kind `* -> *', but `STRef' has kind `* -> * -> *'
19:40:23 <soupdragon> :k Mu (STRef a)
19:40:24 <lambdabot> Not in scope: type variable `a'
19:40:28 <soupdragon> :k forall a. Mu (STRef a)
19:40:29 <lambdabot> *
19:40:33 <soupdragon> excellent
19:40:38 <Nereid> :k Mu
19:40:39 <lambdabot> (* -> *) -> *
19:50:40 <vpx> Hi! I have a list of strings, and I need to group every three strings into a tuple together, but I'm blanking out on what function I should use to do that. \:
19:51:42 <copumpkin> eugh, tuples
19:51:54 <soupdragon> use this function
19:52:02 <Olathe> > let f (a:b:c:xs) = (a,b,c):f xs in f [1..]
19:52:03 <vpx> copumpkin: ):
19:52:03 <lambdabot>   [(1,2,3),(4,5,6),(7,8,9),(10,11,12),(13,14,15),(16,17,18),(19,20,21),(22,23...
19:52:13 <dmwit> vpx: Data.List.Split.chunk
19:52:18 <dmwit> ?hackage split
19:52:18 <copumpkin> what if you have a non-multiple of 3?
19:52:18 <lambdabot> http://hackage.haskell.org/package/split
19:52:27 <Olathe> I explode
19:52:36 <soupdragon> what if what if
19:54:00 <Nereid> let f (a:b:c:xs) = (a,b,c):f xs in f [1..10]
19:54:05 <Nereid> fails pattern match I guess.
19:54:14 <Nereid> well even if it's a multiple of 3 but finite it would fail
19:54:25 <aavogt> > let f (a:b:c:xs) = (a,b,c):f xs; f _ = [] in f [1..10]
19:54:26 <lambdabot>   [(1,2,3),(4,5,6),(7,8,9)]
19:54:31 <Nereid> right
19:54:37 <Olathe> Yay !
19:54:57 <Philonous> Yes, what if infinity is not divisible by 3?
19:55:12 <Cale> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1..]
19:55:13 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
19:55:22 <soupdragon> what is the factorization of infinity ?
19:55:29 <Cale> > let f (a:b:c:xs) = (a,b,c):f xs; f _ = [] in f [1..]
19:55:30 <lambdabot>   [(1,2,3),(4,5,6),(7,8,9),(10,11,12),(13,14,15),(16,17,18),(19,20,21),(22,23...
19:55:46 <soupdragon> is it just inf = 2^inf * 3^inf * 5^inf * ...?
19:55:47 <Cale> infinity = 3 * infinity
19:55:49 <soupdragon> that's not very appealing
19:56:07 <raceRider> > [1..10] >>= [x-1, x+1]
19:56:09 <dmwit> > let f (a:b:c:xs) = [a,b,c]:f xs; f xs = xs in f [1..10]
19:56:09 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
19:56:09 <Nereid> soupdragon: supernatural numbers?
19:56:10 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
19:56:23 <dmwit> > let f (a:b:c:xs) = [a,b,c]:f xs; f xs = [xs] in f [1..10]
19:56:24 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
19:57:06 <raceRider> > [1..10] >>= \x -> [x-1, x+1]
19:57:07 <lambdabot>   [0,2,1,3,2,4,3,5,4,6,5,7,6,8,7,9,8,10,9,11]
19:57:29 <Nereid> groupBy ((==) on (`div` 3)) [1..]
19:57:31 <Nereid> > groupBy ((==) on (`div` 3)) [1..]
19:57:32 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
19:57:34 <Nereid> great
19:58:19 <Cale> > [1..] >>= join replicate
19:58:20 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
19:58:24 <Nereid> oh duh
19:58:30 <Nereid> > groupBy ((==) `on` (`div` 3)) [0..]
19:58:31 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20],[21,22,...
19:58:33 <Nereid> :P
19:58:34 <copumpkin> > [0..] >>= join replicate
19:58:35 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
19:58:46 <dmwit> > [0..] >>= (replicate >>= id)
19:58:47 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
19:59:24 <Nereid> :t (join, replicate, join replicate)
19:59:25 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (m (m a) -> m a, Int -> a1 -> [a1], Int -> [Int])
19:59:37 <Nereid> he
19:59:38 <Nereid> heh
19:59:52 <copumpkin> dmwit's so hardcore
20:00:16 <Cale> join x = x >>= id
20:00:23 <copumpkin> yep
20:02:17 <Olathe> > map (\x -> floor $ (sqrt (8*x + 1) + 1)/2) [0..]
20:02:18 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
20:02:32 <Nereid> :S
20:03:15 <Traveler> @pl fold h t f g=f h (t f g)
20:03:16 <lambdabot> fold = ap . ((.) .) . flip id
20:03:33 <copumpkin> Traveler: didn't you do that earlier?
20:04:33 <Traveler> @type ap
20:04:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:04:44 <Traveler> @src ap
20:04:44 <lambdabot> ap = liftM2 id
20:06:44 <Nereid> > map (\x -> length . takeWhile (< x) $ map (\n -> sum [1..n]) [0..]) [1..]
20:06:46 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
20:07:31 <dmwit> > transpose $ tails [1..]
20:07:32 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:07:52 <Nereid> lol
20:08:10 <dmwit> ah
20:08:34 <dmwit> > let merge ((x:xs):xss) = x : merge (insert xs xss) in merge $ tails [1..]
20:08:42 <lambdabot>   mueval: ExitFailure 1
20:08:52 <Olathe> > ExitFailure 3
20:08:53 <dmwit> :t insertBy
20:08:56 <lambdabot>   mueval-core: Time limit exceeded
20:08:58 <lambdabot> forall a. (a -> a -> Ordering) -> a -> [a] -> [a]
20:09:05 <Olathe> > ExitFailure 4
20:09:07 <lambdabot>   Not in scope: data constructor `ExitFailure'
20:09:24 <Nereid> > exitFailure 1
20:09:26 <lambdabot>   Not in scope: `exitFailure'
20:09:31 <dmwit> > let merge ((x:xs):xss) = x : merge (insertBy (comparing head) xs xss) in merge $ tails [1..]
20:09:32 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
20:09:56 <Nereid> no System.Exit for lambdabot then
20:10:10 <Olathe> > explode
20:10:11 <lambdabot>   Not in scope: `explode'
20:23:18 <matt_m> Cale:  If you only view anything formally, how did you come to pick ZFC as your favorite logical system?
20:23:50 <matt_m> Cale:  Surely there's some intuition about the meaning of those axioms that leads you to prefer ZFC over any other random list of rules
20:24:13 <Cale> matt_m: Well, sure, and I like working with those rules.
20:24:23 <Cale> I've built up a good amount of intuition regarding them.
20:24:37 <Cale> But I don't treat them as any truer than any other formal system
20:24:52 <SliMM> What is this line supposed to do: solve = rows . (map value) . (sortBy comp) . head . solutions . construct
20:24:52 <SliMM> ?
20:25:01 <matt_m> Cale:  But could you have come up with those rules on your own?
20:25:09 <Cale> Probably not.
20:25:20 <matt_m> Cale:  Do you think it's a lucky coincidence that we haven't found an inconsistency with them yet?
20:25:23 <SliMM> I mean, what does "." mean
20:25:35 <Cale> SliMM: Function composition
20:25:35 <QtPlatypus> SliMM: compose
20:25:38 <Olathe> @src (.)
20:25:38 <lambdabot> (f . g) x = f (g x)
20:25:39 <lambdabot> NB: In lambdabot,  (.) = fmap
20:25:39 <Cale> (f . g) x = f (g x)
20:25:44 <SliMM> Ok
20:25:58 <matt_m> Cale:  If you were the first person to study PA, would you not be surprised to find an inconsistency?
20:26:07 <SliMM> thanks
20:26:23 <Cale> matt_m: I somehow doubt we'll find an inconsistency in either system.
20:26:38 <Cale> But I'm about equally uncertain about each.
20:26:46 <aristid> Haskell gets some resistance due to the complexity of using monads to control side effects. Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?"
20:26:51 <soupdragon> matt_m, haven you seen consistency proofs?
20:26:56 <aristid> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
20:27:09 <Cale> aristid: People write lots of mindless stuff...
20:27:25 <matt_m> soupdragon:  From Cale's point of view, consistency of PA would just be proved in some other logic that might itself be inconsistent ... :)
20:27:25 <aristid> Cale: that was a quote of a joke
20:27:31 <aristid> and i laughed hard
20:27:35 <Cale> aristid: Ah, okay :)
20:27:49 <aristid> but i was already laughing before the haskell part
20:28:03 <soupdragon> :[
20:28:21 <Cale> aristid: It sounds like some genuine trolling that I've seen. The implicit assumption that "monads are about side effects" part in particular.
20:28:39 <Cale> matt_m: right.
20:28:45 <Cale> matt_m: There's nothing you can do about it.
20:28:59 <Cale> and that's okay
20:29:03 <aristid> Cale: i like to think that the IO monad is about effects, not side effects
20:29:09 <kmc> well, it's true. Haskell does use monads to control side effects, as well as lots of other things
20:29:10 <matt_m> Cale:  I understand your postion, I just don't buy that you could really believe it.
20:29:11 <aristid> effects are first-class in haskell :D
20:29:26 <pikhq> aristid: Can hardly call them "side effects" if the effects are the whole point, right. :P
20:29:31 <Cale> As long as mathematics is interesting or useful, who *really* cares if there's an inconsistency that we never find?
20:29:39 <kmc> i think they're still "side", in that an IO action also yields a value
20:29:42 <aristid> pikhq: yup
20:29:51 <aristid> kmc: nah only the IO () is run
20:30:09 <matt_m> Cale:  But you do acknowledge that there is a difference between the axioms that intuitively seem true, and those that don't
20:30:10 <aristid> :t main
20:30:11 <lambdabot> Not in scope: `main'
20:30:19 <aristid> @src main
20:30:19 <lambdabot> Source not found. You untyped fool!
20:30:31 <matt_m> Cale:  And that mathematicians following those instincts have had remarkable success in producing consistent systems
20:30:38 <Cale> matt_m: Axioms are always true ;)
20:30:41 <aristid> was hoping for a mock implementation of main :D
20:30:41 <pikhq> @let main = undefined :: IO ()
20:30:43 <lambdabot>  Defined.
20:30:43 <matt_m> Cale:  At least, so far not shown to be inconsistent
20:31:23 <matt_m> Cale:  Is this an elaborate trolling exercise?  (I have to ask!)
20:31:36 <Cale> matt_m: No
20:31:57 <Cale> matt_m: This is really how I think about mathematics.
20:31:58 <pikhq> matt_m: Axioms are inherently true. Except for the ones that are inherently false.
20:32:03 <kmc> aristid, right, but if you want an informal description of what (>>=) does for IO then it'll probably involve "doing stuff" and also "producing values"
20:32:05 <Cale> I am totally not a platonist at all :)
20:32:12 <soupdragon> matt_m, all human reasoning is derived from biology
20:32:42 <aristid> kmc: >>= chains together IO actions (not side effects)
20:32:42 <Axman6> would it be more correct to say that if its not true (or not false when its supposed to be false), it's not an axiom?
20:32:42 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
20:32:50 <Axman6> @messages
20:32:51 <lambdabot> ivanm said 4h 36m 13s ago: http://www.thavidu.com/microsoft/Poster2010.jpg :p
20:32:56 <Cale> matt_m: The reason that I doubt we'll find an inconsistency is that we've spent a lot of time using ZFC and haven't come across one yet.
20:32:58 <matt_m> soupdragon:  Well and good, except if you think some other biology would result in some perturbation of mathematics, I disagree
20:33:28 <kmc> aristid, i don't disagree
20:33:32 <soupdragon> but Cale that is inductive reasoning
20:33:38 <Cale> soupdragon: Absolutely.
20:33:38 <soupdragon> This is probably the worst kind of reasoning
20:33:41 <matt_m> Cale:  Right, so from your point of view the people who initially wrote down those axioms were just lucky
20:33:46 <soupdragon> in my experience
20:33:55 <Cale> soupdragon: There's no other kind of reasoning which works in this situation though.
20:33:56 <matt_m> Cale:  Lucky to have picked axioms that didn't result in quick inconsistency
20:34:21 <Cale> You won't be able to prove that ZFC is consistent from inside ZFC, unless it actually is inconsistent :)
20:34:40 <danharaj> You can prove it in another system.
20:34:45 <danharaj> It doesn't even have to be a stronger system.
20:34:47 <matt_m> Cale:  Do you think the people who came up with ZFC were working in ZFC?
20:34:55 <Cale> and if you prove it from some other system, you can't be sure it's not just because the other system is powerful enough to be inconsistent
20:35:06 <soupdragon> Cale - as a reasoning human, there is much you can derive without dealing with any formal system what-so-ever.. can a consistency proof (for a very basic logic, perhaps) not be explained to that primal intellect?
20:35:10 <danharaj> For example Peano Arithmetic can be proved consistent in PRA + induction up to epsilon_0.
20:35:46 <dmwit> It's turtles all the way down, unfortunately.
20:35:54 <Cale> matt_m: No, they were choosing axioms according to their intuitions about how sets ought to behave, informed by previous inconsistencies in earlier systems.
20:36:56 <danharaj> PRA + induction to epsilon_0 is provably consistent iirc
20:37:04 <danharaj> but it is incomparable with PA
20:37:29 <matt_m> Cale:  I don't think it's fair to characterize as arbitrarily patching over previous inconsistencies
20:37:35 <danharaj> I like to think of it as there's an infinitely long proof in PA that PA is consistent, infinitely long and not computable.
20:37:40 <Nereid> > main
20:37:42 <lambdabot>   <IO ()>
20:37:47 <matt_m> Cale: Rather previous inconsistencies forced them to carefully establish the correctness of ZFC's axioms relative to their mental model of sets
20:37:54 <Nereid> > undefined
20:37:58 <lambdabot>   *Exception: Prelude.undefined
20:38:02 <Nereid> then...
20:38:05 <Nereid> > undefined :: IO ()
20:38:06 <soupdragon> matt_m, it is well known that we have baises.. I am not sure what the status of proving that we have limitations is, though (I think this is one of Smales _big problems in mathematics_)
20:38:06 <lambdabot>   <IO ()>
20:38:16 <Cale> matt_m: Well, that's the reason that, for instance set comprehension is restricted
20:38:28 <pikhq> Nereid: IO's show instance does not evaluate its argument.
20:38:38 <Nereid> that explains things I guess
20:38:50 <soupdragon> matt_m, If we assume that human thinking is fundamentally limited, then there is a boundry on the sorts of mathematics they develop
20:38:56 <Cale> Frege's original system was sort of intuitive, but failed to be consistent
20:39:07 <matt_m> Cale:  Yes, it was to avoid paradoxes, but my point is *why* did they think restricted set comprehension would avoid paradoxes?
20:39:18 <pikhq> And I think that show instance is from quickcheck, anyways.
20:39:49 <matt_m> soupdragon:  I don't know that I disagree with anything you're saying.  Not like I disagree with Cale :)
20:39:57 <soupdragon> um it's simple: (1) understand the problem (2) fix the problem
20:40:06 <Cale> matt_m: Well, it would avoid the specific kind of contradiction that they ran into. They looked at the proof of the contradiction and said "which of these steps should we make invalid?"
20:40:34 <Cale> and basically ended up choosing comprehension, as the least unpleasant thing to have to restrict
20:40:51 <soupdragon> I think the biggest problem iwht ZFC is that (at least to my knowledge) there are no meaning explanations for the axioms
20:40:59 <monochrom> Sometimes the same process in designing a restriction in a programming language.
20:41:01 <gwern> soupdragon: reminds me of the feynman problem-solving algorithm: 1. think very hard. 2. write down the solution
20:41:01 <danharaj> sure there are.
20:41:15 <danharaj> soupdragon: name an axiom and I can justify it.
20:41:20 <danharaj> (Except the axiom of choice :D)
20:41:26 <gwern> the axiom... dangit
20:41:45 <danharaj> I can justify the axiom of choice, but the justification is not as solid.
20:41:57 <soupdragon> I am talking about philosophical foundations
20:42:01 <monochrom> I offer the axiom of union as an example.
20:42:11 <matt_m> Cale:  I would say they looked at the paradox and compared it to their mental model.  And they realized that rules that diverge don't really define sets.
20:42:34 <soupdragon> if you look at someting like G Spencer Brows Laws of Form, there is a philosophical foundations for FOL
20:42:40 <dino-> gwern: If that was you who fixed the hackage broken packages the other day, thank you!
20:42:43 <Cale> matt_m: "really define"?
20:43:20 <danharaj> monochrom: A set is like a bag of things. If I have a bag of bags, I can empty out the contents of the inner bags into another bag and I still get a bag of things.
20:43:21 <matt_m> Cale:  Again if you insist on everything being relative to a formal system, then you have no where to start
20:43:40 <matt_m> Cale:  I don't see how you can prefer one formal system over another
20:43:40 <Nereid> ZFC minus the empty set axiom.
20:43:45 <Cale> I don't see what you don't like about my insistence on this.
20:43:52 <Cale> matt_m: For lots of reasons.
20:43:55 <pikhq> matt_m: Matter of taste, of course.
20:44:01 <monochrom> danharaj: no no, tell it to soupdragon, I'm find with all axioms, I think all axioms are intuitive.
20:44:07 <monochrom> s/find/fine/
20:44:09 <copumpkin> "elegance"
20:44:11 <gwern> soupdragon: laws of form? I didn't understand that one at all
20:44:16 <gwern> still not sure there's anything there
20:44:18 <Cale> matt_m: It's some combination of what you find fun, what you find beautiful and what you find useful.
20:44:31 <danharaj> soupdragon: Laws of Forms AFAIK is a bunch of crackpottery, so uh...
20:44:39 <Cale> matt_m: There's no absolute right and wrong about it
20:44:43 <Nereid> or ZFC with the empty set axiom replaced with "there exists a set"
20:44:44 <Nereid> :(
20:45:20 <soupdragon> I wonder what makes you feel qualified to judge so strongly
20:45:23 <Cale> There's no mathematical deity to hand down the axioms on golden platters or whisper them directly into Zermelo's mind.
20:45:41 <soupdragon> Cale: what about Cantor? :P
20:45:46 <Cale> You pick some, you try them, and see if you like them
20:46:12 <danharaj> soupdragon: I think it's up to you to justify someone whose work is ignored by the people who live and breath mathematics.
20:46:28 <danharaj> (Also the wikipedia page for Laws of Form is hilariously biased)
20:46:47 <Cale> matt_m: Does that make sense?
20:46:54 <soupdragon> oh well this is a bad tangent to get stuck on
20:46:57 <Cale> I don't know how I can make my position any clearer.
20:47:14 <Cale> Mathematics is a human endeavour.
20:47:16 <matt_m> Well, I think I understand your position
20:47:21 <danharaj> soupdragon: I'm sure it is, but ZFC needs no philosophical foundations. It is an axiomatization of the intuitive idea of a set.
20:47:24 <monochrom> You can say "there is no Platonic astral plane".
20:47:31 <matt_m> And I don't really know how to argue against it
20:47:35 <danharaj> You cannot understand mathematics if you do not do it.
20:47:51 <soupdragon> danharaj: I certainly don't agree with that, I am not sure you have a clear idea of what was meant by a meaning explanation
20:47:51 <danharaj> ZFC is the 'doing' you get from thinking about sets.
20:48:07 <copumpkin> matt_m: why are you trying to?
20:48:09 <pikhq> Cale: There's certainly a mathematical diety. He's got all the best proofs written in the Book.
20:48:14 <Nereid> lol
20:48:15 <danharaj> soupdragon: I don't understand that sentence.
20:48:21 <danharaj> The Supreme Fascist.
20:48:23 * Cale chooses to read danharaj's 'doing' as the sound effect, rather than the word ;)
20:48:27 <kulin> oh no, you guys are all stuck in oneUp recursion
20:48:34 <copumpkin> fix succ
20:48:42 <Nereid> > fix succ
20:48:43 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
20:48:48 <Nereid> o_o
20:48:52 <copumpkin> > (fix succ :: Natural) > 3
20:48:53 <lambdabot>   Not in scope: type constructor or class `Natural'
20:48:58 <copumpkin> where'd it go?
20:48:59 <Nereid> ah, monomorphism or something?
20:49:04 <copumpkin> just defaulting
20:49:08 <Nereid> k
20:49:16 <Nereid> > fix succ :: Integer
20:49:20 <lambdabot>   mueval-core: Time limit exceeded
20:49:29 <Nereid> obviously
20:49:32 <gwern> integer do be strict
20:49:39 <monochrom> The problem with "what is the meaning of these axioms?" is what is the meaning of meaning?
20:49:47 <matt_m> copumpkin:  I have no big interest in this, just saw the above conversation and I still don't buy it.  I don't believe that you can consider the naturals with your mind and not find certain axioms appropriate for describing them
20:49:48 <danharaj> soupdragon: For what it's worth, I have heard of Spencer-Brown before, he gave a talk at my university somewhere. I didn't attend. He claims he has a proof of the riemann hypothesis. Total crank.
20:49:56 <monochrom> There is not Platonic astral plane. And there is no meaning.
20:50:05 <monochrom> s/not/no/
20:50:06 <copumpkin> can I project on to it?
20:50:11 <soupdragon> danharaj: sounds like you learned a lot from his talk
20:50:32 <danharaj> soupdragon: I only go to talks that have free food, not people claiming to be geniuses without substance.
20:50:37 <Nereid> lol
20:50:47 <Nereid> An excellent reason to attend a talk
20:50:51 <soupdragon> this is a really stupid discussion
20:51:01 <soupdragon> You are just insulting this guy and I think that is rude
20:51:08 <Nereid> I missed a talk Conway gave here a couple years ago. :(
20:51:11 <matt_m> soupdragon:  You talking to me?
20:51:15 <Nereid> something about knots
20:51:19 <soupdragon> I wish I hadn't mentioned it
20:51:20 <soupdragon> no matt_m
20:51:22 <danharaj> matt_m: no, me.
20:51:32 <soupdragon> I didn't realized it was so controversial
20:51:35 <danharaj> soupdragon: Part of it is because I am curious to see why and how you defend him.
20:51:37 <gwern> well, to be fair, spencer-browne only made the rimann or goldbach claim decades after laws of form
20:51:41 <matt_m> soupdragon:  Ok, good.  I'm not trying to insult anyone!
20:51:54 <soupdragon> I am not defending him, I am just feeling bad that I ruined the discussion by derailing it
20:51:55 <gwern> he wouldn't be the first man to go daft in his dotage
20:52:35 <danharaj> soupdragon: there are at least three threads of conversation going on right now, only one of them took a bad turn :p
20:53:24 <matt_m> Cale:  Anyway, thanks for humouring my questions.  I think formalists are much more common in CS circles than in math circles
20:53:43 <Cale> matt_m: and yet I still consider myself a mathematician first
20:53:49 <siracusa> Cale: Do you remember the client/server example you wrote me a few days ago?
20:53:59 <Nereid> matt_m: I can imagine that being true
20:54:02 <matt_m> Cale:  That's not inconsistent with what I said
20:54:08 <Cale> matt_m: I know :)
20:54:22 <matt_m> Nereid:  Really?
20:54:29 <matt_m> Nereid:  You an algebraist or something?
20:54:39 <Nereid> well, just an undergrad for now
20:54:54 <Cale> matt_m: I think that a lot of mathematicians haven't spent a lot of time thinking about what it is that they do from a philosophical perspective. Platonism is a functional philosophy, even if it's one that's hard to defend.
20:55:01 <matt_m> Nereid:  I think most mathematicians are Platonists, or at least closet Platonists
20:55:04 * ManateeLazyCat I'm crazy on gio callback binding, after gtk2hs code change.
20:55:20 <siracusa> ManateeLazyCat: Hi!
20:55:22 <Cale> and it's one which is ingrained into our early mathematics curricula
20:55:26 <ManateeLazyCat> siracusa: Hi
20:55:27 <Nereid> I just use ZFC without thinking about any philosophical things under it
20:55:31 <Cale> siracusa: yes
20:55:32 <pikhq> matt_m: Well, CS guys tend to consider things just human constructions, since pretty much all programming is dealing with human constructions. ;)
20:55:37 <ManateeLazyCat> siracusa: I'm in crazy time......
20:55:44 <siracusa> Cale: I had to reinstall GHC but now it works perfectly! \o/
20:55:54 <soupdragon> Nereid: I don't think ZFC is as rich in that respect, as some of the other foundations
20:56:01 <ManateeLazyCat> @preflex seen dcoutts
20:56:02 <lambdabot> Unknown command, try @list
20:56:07 <soupdragon> Nereid: although I have heard some fun stuff about non-well-founded sets
20:56:11 <Cale> matt_m: From the very beginning, we teach students that there are right answers and wrong answers, and the assumptions, well, we don't even call them that, the rules are absolute.
20:56:13 <monochrom> @hackage ZFC
20:56:13 <lambdabot> http://hackage.haskell.org/package/ZFC
20:56:40 <Nereid> soupdragon: ZFC is good enough for me
20:56:50 <Cale> matt_m: It's not like we're constructing mathematics for our own benefit, it's more like we've inherited it as some kind of legacy from the past.
20:56:59 <Cale> matt_m: and I really dislike that perspective
20:57:02 <danharaj> I cannot accept formalism because the same mathematics can be expressed within a human mind, or on paper, or on the output tape of a turing machine, or in a super position of states in a quantum computer or... etc. I believe in the independent existence of math because it seems to be independent of its physical representation.
20:57:03 <Nereid> I'm not really concerned with foundations
20:57:08 <soupdragon> Nereid, btw
20:57:22 <soupdragon> Nereid, I'm kind of surprised you even know what ZFC is, if you're an undergrad
20:57:26 <siracusa> ManateeLazyCat: Ok, I just wanted to ask if you can move an example from glade/demo/noughty/Noughty.hs to gtk2hs/demo since it doesn't use glade.
20:57:28 <Nereid> undergrad in math?
20:57:33 <soupdragon> yeah
20:57:37 <Nereid> well
20:57:49 <Cale> danharaj: Well, okay. You have a point there too. I don't mean to diminish the importance of the intuitive ideas that surround mathematical thought.
20:57:51 <Nereid> I suppose one could say I am not an average undergrad
20:57:57 <dolio> I suspect I knew what ZFC was when I was an undergrad, and I wasn't a math major.
20:58:14 <ManateeLazyCat> siracusa: We will pick-up all demos to "gtk2hs-demo" after gtk2hs release.
20:58:15 <soupdragon> I'm an undergrad in math too, and I sit next to people that don't know what a proof is
20:58:25 <Cale> danharaj: But on the other hand, as long as you have enough intuition for the rules, it doesn't matter what the rules are :)
20:58:33 * ManateeLazyCat I don't know when time release gtk2hs.... funny. :(
20:58:33 <danharaj> Cale: I think it's a hard problem and it's intractable and there's not much interesting mathematics that can be squeezed out of it since Goedel :p
20:59:08 <Cale> danharaj: Well, I'm not really treating it as a problem to be solved, so much as just a reflection on what we're doing.
20:59:09 <matt_m> Cale:  From my point of view, I didn't need to be indoctrinated with mathematics, just exposed to the power of simple rigorous proof
20:59:22 <danharaj> Cale: Seems to me that rules themselves, information perhaps has an existence independent of the physical medium in which they are encoded. There's an emerging idea in Quantum mechanics: "It from bit." I particularly like it :p
20:59:38 <Nereid> I haven't been taught formally about any of that stuff though. I sat in a couple lectures of a set theory class and that's about it
21:00:10 <matt_m> Cale:  Take the proof that there are infinitely many primes.   I don't see how you could not be completely convinced
21:00:17 <matt_m> Cale:  And there's no formal system around
21:00:27 <Cale> matt_m: Sure there is.
21:00:36 <matt_m> Cale:  Just your thoughts on numbers
21:00:44 <Cale> That proof works in lots of formal systems.
21:00:46 <soupdragon> matt_m, I think I touched on this idea earlier too
21:00:50 <Cale> You need at least the rules of logic
21:00:58 <danharaj> matt_m: We definitely have some sort of logic hard-wired in our brains. There's even evidence of inherent numerical ability.
21:01:00 * ManateeLazyCat Sometimes i feeling tired to fix gtk2hs, but haven't better toolkit can use in Haskell community. :-(
21:01:05 <Cale> and you need lots of assumptions about addition and multiplication
21:01:14 <pikhq> matt_m: But "primes" need to be defined, as does multiplication. And logic.
21:01:18 <Nereid> ManateeLazyCat: release or darcs?
21:01:19 <danharaj> matt_m: The formal systems came about for two reasons: They're interesting in of themselves, and also our intuition sometimes fails when we take it to its limit.
21:01:26 <Cale> (you practically need Peano Arithmetic, or something close to it)
21:01:26 <Nereid> wait, not darcs
21:01:30 <Nereid> what do they use
21:01:41 <applicative> The proof appears in Euclid, didn't it?  He didn't have an explicit logic.
21:01:49 <soupdragon> yeah. bare in mind that people were doing advanced mathematics for millenia
21:01:56 <matt_m> Cale:  You don't need those assumptions
21:01:59 <soupdragon> with not foundations or explicit rules of logic
21:02:07 <soupdragon> it's almost like they were back in high school!
21:02:16 <Cale> Euclid was one of the first to try to be formal. He wasn't good at it, but he was trying. It was a long time ago.
21:02:19 <Nereid> oh, it is darcs.
21:02:27 <Cale> matt_m: oh?
21:02:33 <Cale> matt_m: Which proof are we talking about here?
21:02:35 <danharaj> Even in modern mathematics, exploratory work in a theory doesn't start with axioms and definitions and go from there, it starts with intuition, from intuition, ideas of truth, and then the axioms and the definitions fall out from the exploration.
21:02:38 <soupdragon> Cale, why do you say he wasn't good at it?
21:02:43 <Nereid> matt_m: you at least need the definition of a prime
21:02:53 <Nereid> and "infinitely many"
21:02:56 <ManateeLazyCat> gtk2hs almost perfect, but still need some fix, but i'm really time to fix it, my project can't work if i don't fix it
21:03:05 <matt_m> Cale:  I can take a smart pupil who's unexposed to mathematics, spend a day explaining to him the proof, and if he's bright, there's nothing you can say to convince him otherwise
21:03:06 <Cale> soupdragon: His axioms aren't really enough to show everything that he somehow managed to show.
21:03:18 <soupdragon> Cale - really?? I didn't know that
21:03:22 <Nereid> look up Pasch's axiom
21:03:35 <soupdragon> wow this is news to me thank you
21:03:39 <Cale> soupdragon: For one, in the very beginning, he constructs an equilateral triangle in the usual way, and his axioms are not enough to prove that the two circles intersect
21:03:39 <matt_m> Cale:    My point is that what you call assumptions are intuitions
21:03:44 <danharaj> soupdragon: Look up Hilbert's Grundlagen Der Geometrie. Hilbert put Euclid's geometry on a completely firm basis.
21:04:02 <applicative> ManateeLazyCat, I thouht you were happy about gtk2hs at first, then you turned gloomy
21:04:18 <ManateeLazyCat> applicative: Yes.
21:04:37 <Cale> matt_m: That student has probably spent a lot of time learning about a particular (semi-)formal system of properties of numbers and arithmetic
21:04:51 <kulin> i asked this earlier today but i dont believe i got an answer, if i have a module B which is in the same concept of A but more precise in someway, is it more common to organize the modules like A.B where B imports A, or is it more common to put them at the same level?
21:04:52 <ManateeLazyCat> applicative: gtk2hs is best toolkit in Haskell community, but not perfect that can make me happy
21:04:55 <applicative> ManateeLazyCat, but you are not despaing of carrying out your plan
21:05:02 <Nereid> oh, gtk2hs is cabalized now
21:05:29 <matt_m> Cale: Fine, how about this.  You pick a smart student, and he spends half of his time with me teaching him my rules of mathematics, and half of his time with you teaching him any other formal system
21:05:45 <ManateeLazyCat> applicative: Yes, i try to my best, but sometimes too many fix make me gloomy, like you said.
21:06:26 <matt_m> Cale:  The natural numbers are called that for a reason
21:06:40 <ManateeLazyCat> applicative: I use gtk2hs coding happy, some change break it when new darcs code out.
21:06:42 <monochrom> The real numbers too. <duck>
21:06:50 <matt_m> monochrom:  whack
21:06:51 <djahandarie> So are the complex numbers!
21:06:54 <djahandarie> They are so complex
21:06:55 <Cale> matt_m: People are far too glib about the naturality of the natural numbers.
21:06:57 <ManateeLazyCat> applicative: I'm not happy if i can't fix it in one hour.
21:07:00 <copumpkin> imaginary numbers are very real
21:07:23 <kmc> the natural numbers might be natural, but the real numbers are completely unreal
21:07:29 <Nereid> indeed
21:07:29 <kulin> i'm guessing back the complete lack of response its a dumb question or there is no common practice?
21:07:34 <Cale> Most natural numbers are so large that they couldn't be defined even if you took all the material in the universe and turned it into paper.
21:07:35 <kulin> back = by
21:07:37 <matt_m> Cale:  Natural numbers and the associated axioms are extremely compelling, and I really doubt you could take a child and convince him some other system is just as compelling
21:07:44 <kmc> kulin, the lack of response is because people are busy arguing about foundations of mathematics :/
21:07:58 <Cale> (and ink)
21:08:00 <danharaj> hey, haskell totally depends on the foundations of math.
21:08:01 <matt_m> Cale:  In other words, I dispute that mathematics is just a learned culture
21:08:08 <Draconx> matt_m, I doubt you could convince many children as to why induction is "compelling".
21:08:09 <copumpkin> kulin: can you repeat it?
21:08:15 <Cale> matt_m: What about graphs?
21:08:17 <danharaj> Draconx: I bet you could.
21:08:18 <dolio> kulin: Do you have a more concrete example?
21:08:20 <applicative> kulin, I think there are a few things you could mean
21:08:23 <matt_m> Draconx:  Sure it's compelling
21:08:25 <Cale> matt_m: I could teach the student graph theory instead.
21:08:28 <danharaj> Draconx: Find a suitable child so we can do science to it.
21:08:30 <Cale> Or topology
21:08:41 <copumpkin> oh I see it
21:08:46 <monochrom> @quote monochrom click
21:08:47 <lambdabot> No quotes match. Are you on drugs?
21:08:52 <kulin> ok, if i have a module which defines general parsers and then a couple parsers which depend on those
21:08:56 * ManateeLazyCat I really want someone to help me fix something, unfortunately, just two peoples can help me, but they're too busy, i'm fighting alone...... 
21:09:17 <Cale> (though I might have some trouble getting too far without the familiar help of the naturals)
21:09:17 <kulin> would i put the common parsers at Program.Parse and the others at Program.Parse.A Program.Parse.B
21:09:23 <matt_m> Cale:  I don't see your point with those examples - those are consistent with arithmetic
21:09:27 <Cale> Sure.
21:09:32 <Cale> But they're other formal systems
21:09:40 <danharaj> about intuitive objects
21:09:50 <danharaj> The intuition came before the formalism.
21:09:55 <Cale> Yes
21:09:55 <matt_m> yes
21:09:57 <danharaj> (It always does)
21:10:03 <Cale> There's something extremely human about them
21:10:17 <Cale> I wouldn't necessarily expect aliens to have come up with the natural numbers.
21:10:25 <danharaj> I totally would.
21:10:28 <matt_m> I would too
21:10:30 <Nereid> ^
21:10:42 <kulin> cant you guys just look at some random african tribe to see how they count to settle this?
21:10:44 <matt_m> I certainly wouldn't expect aliens that didn't to make it to Earth
21:10:49 <monochrom> There was a culture whose number system was "one, two, many".
21:11:00 <djahandarie> Quiet guys, Cale is an alian, he knows better about this stuff than you
21:11:20 <danharaj> I think we have to assume the aliens are advanced enough to have mathematics.
21:11:22 <Nereid> random poll. do you consider 0 to be a natural number?
21:11:22 <monochrom> Cale came up with the p-adics first. :)
21:11:30 <matt_m> 0 is a natural number
21:11:34 <matt_m> number theorists be damned
21:11:35 * Nereid <- yes
21:11:46 <copumpkin> yep
21:11:53 <copumpkin> it's a lot cleaner that way
21:11:54 <danharaj> Counting is not mathematics. You don't need math to survive as a tribe. We can do mathematics because we have civilization to keep us from the giant enemy bears.
21:12:03 <Nereid> it makes them a monoid. :V
21:12:17 <Cale> Yeah, 0 is important.
21:12:27 <matt_m> Cale:  In which formal system?
21:12:30 <matt_m> :P
21:12:32 <Nereid> lol
21:12:39 <danharaj> I think it depends on context.
21:12:59 <Cale> Though, the very fact that we can discuss whether we want 0 to be a natural number or not strikes at my point.
21:13:15 <Draconx> it's quite simple: anyone who says it isn't is wrong :P.
21:13:16 <monochrom> Omitting 0 gives you a monoid too.
21:13:19 <danharaj> I got into this conversation like halfway. What exactly are we talking about anyway?
21:13:22 <Nereid> monochrom: no, no identity
21:13:24 <Nereid> under addition anyway
21:13:31 <monochrom> multiplication.
21:13:34 <copumpkin> pff
21:13:36 <copumpkin> who needs that
21:13:39 <Nereid> lol
21:13:45 <Cale> monochrom has a point
21:13:46 <dolio> There's also (max, 1)
21:13:52 <danharaj> Nereid: well why do we have to consider addition? If we consider the natural numbers as the essence of succession, or iteration, then there is no way to distinguish 1 from 0.
21:13:56 <copumpkin> yeah, + and * aren't the only possible ones
21:13:57 <ManateeLazyCat> I have callback generator `marshalAsyncReadyCallback` return "FunPtr (Ptr GObject -> Ptr AsyncResult -> Ptr () -> IO ())
21:13:58 <ManateeLazyCat> " but don't know why it's return "FunPtr (Ptr () -> Ptr AsyncResult -> Ptr () -> IO ())" that make "Ptr ()" mismatch with "Ptr GObject"
21:13:58 <ManateeLazyCat>  
21:13:58 <danharaj> (in their respective systems)
21:14:01 <Cale> Usually when 0 is left out, it's by people who are more concerned about multiplication than addition
21:14:04 <monochrom> It comes down to which monoid you care.
21:14:07 <Cale> (number theorists particularly)
21:14:29 <ManateeLazyCat> I really no idea.
21:14:33 <aavogt> you can't have both when you include 0?
21:14:44 <copumpkin> sure you can
21:15:36 <Cale> You do get both if you include 0, but the multiplicative monoid you get isn't quite as convenient
21:15:50 <danharaj> Mathematicians work in the most convenient setting for their ideas.
21:16:09 <danharaj> And take it on faith, experience, and intuition that they can be extended to more general domains when the details are just nuisances.
21:17:18 <Cale> yes
21:17:30 <danharaj> for example, in differential geometry you often assume everything is C^infinity smooth, but you often don't need all of that smoothness, but generalizing is just a nuisance of counting how many derivatives you need.
21:17:47 <applicative> kulin, I think you'll find a lot of ways of going about this on hackage.  Look at the parsers in attoparsec, for example, their organization would fit your model
21:18:03 <Cale> Well, one of the things which makes mathematics so robust, I think, is that everyone has their favourite way of formalising and checking ideas in their heads. Lots of nearly-compatible formal systems, and the level of communication is much more vague.
21:18:08 <applicative> http://hackage.haskell.org/package/attoparsec
21:18:36 <danharaj> Cale: I think a distinction should be made between mathematics as a pure notion, mathematics as a body of human knowledge, and mathematics as a human activity.
21:18:47 <danharaj> Cale: But perhaps you would not care so much about that first one :D
21:18:52 <Cale> When you're showing someone a proof, a real human and not a machine, you don't really go for rigourous, you go for rigourisable.
21:19:25 <applicative> kunin, something different accounts for the organization of parser modules (readers) in pandoc http://hackage.haskell.org/package/pandoc
21:19:39 <Cale> and there's an interactive checking, the other person can stop you if something doesn't fit nicely for them :)
21:20:47 <danharaj> Mathematics is the best religion :D
21:21:18 <applicative> pythagorianism we have always with us.
21:21:51 <cads_> sometimes I wonder if humans might all be subtly insane in such a way that all the mathematics we've developed are wrong in a way that we cannot possibly see, but would be plain to see for some alien mathematician
21:21:51 <kulin> applicative, i was just sort of hoping there was a standard way, but i guess it is just however you feel like
21:22:13 <soupdragon> cads_ I love that idea
21:22:22 <Nereid> cads_: how do you take into account machine proofs
21:22:30 <danharaj> The machines are insane too!
21:22:35 <kulin> i dont want to have a thousand sub modules called 'shared' in my program so i will probably end up leaving common code at the higher level of the tree
21:22:40 <Nereid> or had insane programmers more likely
21:22:43 <danharaj> If you doubt mathematics, you have to doubt the entire human mind.
21:23:03 <danharaj> (well, some parts are already easy to doubt, like the part that likes C)
21:23:05 <Cale> mm... internally wrong, or some kind of mystical external wrongness?
21:23:05 <cads_> danharaj: it's easy to do unless you're blind :)
21:23:54 <danharaj> cads_: I am beaming you a message across a bunch of laser tubes over hundreds of miles.
21:23:56 <cads_> otherwise you're just one of those philosophers that gives the concept of mind these super powers, like being able to produce the godel statements of _any_ formal system
21:24:03 <danharaj> cads_: I think we got something right.
21:24:38 <applicative> kulin, that certainly seems reasonable.  but if the higher common module has a lot of stuff that's really for parsing modules a17 and b12, it might be different. but maybe i have no wisdom.  the question is a little abstact, not having seen the modules.
21:24:52 <cads_> danharaj: I'm not seriously doubting the mathematics, and obviously it works well enough that there's nothing that gives it away as being wrong
21:25:41 <danharaj> cads_: I'm just saying, any question of mathematics' integrity is a question of the integrity of anything ever you can think of, because you are doubting thought itself.
21:26:01 <kulin> ya i see what yer saing applicative, i will run into problems where sub modules have more than one parent
21:27:50 <cads_> danharaj: that is a good point. I can think of one place where I might get an idea like that from
21:28:49 <cads_> There's the christian doctrine that we are all somehow fallen and incapable of failing to perform sin or, something like this.
21:29:01 <applicative> i don't think there will be a technical problem, unless you are reusing terms, after the fashion of bytestring.  i was thinking of what will make things most intelligible to the user.  some packages work fine though they are catastrophically organized.
21:29:10 <danharaj> Well, to be fair, people are dicks.
21:29:15 <danharaj> Empirically the postulate holds.
21:30:32 <cads_> danharaj: but there are qualitative reasons to wonder about the integrity of thought - much abotu what we feel about the mind, the way we undergo our conscious experience as willful individuals, has been shown to be a product of some pretty amazing hacks
21:30:48 <cads_> but hacks none the less
21:30:57 <applicative> kulin, obviously something like http://hackage.haskell.org/package/bytestring needs to maintain a rigorous order, since the submodules are completely incompatible, or opposing applications of the general idea.
21:31:23 <dolio> You still haven't explained what "wrong" means.
21:32:15 <applicative> kulin, but the hierarchy of modules system is not ye auncient Haskell, it is a novelty.
21:32:45 <tensorpudding> I think I read once about some dudes who immediately after the reformation took the new doctrine of "salvation through faith alone" to mean that one who believes in Christ is saved no matter how much they sin, and became brigands in the name of God. Luther was pretty upset about that.
21:33:22 <danharaj> cads_ : Some parts of the mind, yes. But I think you have to believe that there is a part that should be preferred as "sound".
21:33:26 <applicative> but Luther did say, If you sin, sin boldly, pecca fortior!
21:33:37 <kulin> alright, well thanks applicative
21:34:32 <applicative> kulin, in older Haskell modules, they just import IO, import List, import Monad and so on.
21:35:02 <applicative> kulin, but I guess it was clear it wasn't a matter of the language, but of 'best practices'
21:35:47 <tomberek> ivanm: hello
21:37:46 <cads_> danharaj: there's the philosophical doctrine that no matter how wrong a single mind is about, humanity as a whole will keep investigating an idea more and more untill its idealized truth value is distilled
21:38:19 <danharaj> cads_: Pffft. Humans get stupider as they congregate. This is a fact.
21:38:31 <cads_> I say idealized because it's not necessarily a truth value in some formal system that this doctrine talks about, but some higher truth that the mind is uniquely capable of distilling
21:38:31 <danharaj> cads_ : but as you can tell I am becoming more flippant as time increases :)
21:39:18 <tensorpudding> Too many facts are wrong, that is a fact
21:39:46 <cads_> well, they idea is that idea holds that some part of the human brain is sound, in a way that can be applied eventually to any problem that it is directed at, no matter how many false starts and mistakes are made
21:39:55 <cads_> hmm
21:40:03 <cads_> that is poorly written
21:40:45 <danharaj> Hmm I think I should start writing the foralls in my types explicitly
21:40:50 <danharaj> just to get used to it so I remember the existential syntax.
21:41:14 <cads_> anyways, I don't know if this is true - for example, it's not clear that we'll ever figure out whether humans can be essentially decent towards one another, for example.
21:42:20 <tomberek> cads_: um, we know that the answer to that is yes, we can, but sometimes we aren't.  Then the more important question is, how do we encourage decency?
21:42:31 <danharaj> parties
21:43:49 <cads_> danharaj: :)
21:44:23 <cads_> tomberek: give everyone a lamborgini
21:44:43 * tomberek is standing in the front of the line.
21:46:00 <cads_> tomberek: it really obvious that some system exists where everyone can be perfectly decent to each other? What are the precedents and other evidence for believing that?
21:46:19 <danharaj> cads_: Totally not being dicks to each other right now.
21:47:54 <cads_> Perfect society would be like #haskell, but in real life :)
21:48:11 <cads_> and with more girls
21:48:12 <monochrom> The fallacy of very decent academics, to suppose that in the future all humans will be like them.
21:48:21 <tomberek> cads_: yes,,, proof by induction.  Take two people alone on a desert island.  The help each other and live in harmony waiting for rescue.  A third joins them, being a helpful fellow, they live in harmony.  QED.
21:48:31 <tensorpudding> Perfect society would involve more real life interactions.
21:48:41 <danharaj> monochrom: If people choose to be decent, then they are decent. :D
21:49:36 <cads_> tomberek: that would allow an infinite number of humans to live in peace, but an infinite number of humans can't fit in the known universe, which makes that proof method suspicious here :)
21:49:49 <tomberek> hahaha
21:50:17 <danharaj> not an infinite number, just an unbounded number.
21:50:42 <tomberek> cads_: why can't an infinite number/unbounded live in the known universe? finite resources? ok, they compete for them, decently.
21:51:09 <glguy> If I am listening on 0.0.0.0 and I receive a UDP packet and then I want to make a new socket back to the sender of that packet while binding onto a specific address instead of the wildcard how would I figure out which address to bind to?
21:51:17 <monochrom> many people don't choose to be decent. many people are dicks. go to ##c or something to see lots of examples.
21:51:35 <glguy> I'm guessing I'd need to prod the routing tables
21:52:01 <danharaj> monochrom: Well they're dicks. Doesn't mean they can't be not dicks.
21:52:05 <tomberek> cads_: take it back to the desert isalnd, with too many people, some will starve, but that doesn't mean we are being indecent, cruel, or evil.
21:52:19 <monochrom> Here we are in #haskell, observing that for no reason we are not dicks to each other. For equally no reason, we extrapolate that "in the future, the whole world will be like us". Wrong.
21:52:58 <cads_> tomberek: that's what it might come down to.. the human brain after all evolved as part of an organism that's cunningly outcompeted every other organism so far, but we're also in competition with ourselves
21:53:23 <monochrom> I don't care "can be". Heed what Feynman says on this. " 'I could, but I wouldn't' is just saying 'I couldn't' "
21:53:25 <danharaj> monochrom: The question was whether it was possible for us to not be dicks.
21:53:26 <glguy> Take your #haskell-blah conversation to #haskell-blah and help me work out this networking question :-p
21:53:28 <cads_> as long as the point of competition is to secure scarce resources I don't know if we can be decent about it
21:53:39 <danharaj> monochrom: so the question is why are you answering a question no one asked.
21:54:07 <danharaj> (I am amused because I picture you scrolling up and going "Hah! That IS what was asked.")
21:54:24 <danharaj> (And now you are coming back to type your rejoinder, and I just broke the fourth wall)
21:55:50 <Axman6> danharaj: what are you on about?
21:55:51 <dolio> glguy: High-level haskell programmers have no interest in thinking about vulgar UDP packets!
21:56:21 <glguy> What about the low-level ones??
21:56:35 <dolio> Obviously an oxymoron.
21:57:00 <Axman6> low level programming in haskell is quite possible
21:57:06 <FunctorSalad> slightly stronger than the hydromoron
21:57:11 <copumpkin> what low-level stuff?
21:57:17 * copumpkin should stop watching merlin
21:57:26 <glguy> How about driver development?
21:57:32 <copumpkin> udp definitely has a source address
21:57:35 <copumpkin> it's still over ip
21:57:39 <dolio> copumpkin: The BBC show?
21:57:40 <copumpkin> assuming it is, indeed, over ip :P
21:58:02 <glguy> I don't want to bind to the wildcard only to leave the routing tables to figure out my source address
21:58:04 <copumpkin> dolio: I dunno, it's on syfy right now
21:58:10 <dolio> Then yes.
21:58:12 <glguy> I want to bind to a specific address
21:58:30 <glguy> ... using the routing tables
21:58:41 <FunctorSalad> I guess it depends which level you consider tolerably low?
21:58:45 <copumpkin> hmm, I don't understand how the routing tables fit in
21:58:56 <glguy> copumpkin: they determine what the s ource address will be if you don't specify one
21:59:04 <monochrom> Why not just let the routing table figure it out?
21:59:15 <glguy> because then I'm listening for responses on the wildcard
21:59:24 <glguy> and I was hoping to maybe just listen to them on one address
21:59:26 <monochrom> But if you insist, first read the routing table...
21:59:53 <danharaj> hmmm. I have an AST. I want to type check it (easy) and then I want to convert it to a term datatype (a GADT), except the GADT ctor's know about the type of their subterms. I can't think of a way to convert AST's to terms without converting to an existential type. Ideas?
22:00:16 <FunctorSalad> (but still, the ability to go low-level in the language you're already in is nice to have... it's *not* like you could just use C instead if you still want 90% of the prog to be haskell... (without ffi))
22:00:26 <glguy> I'm looking for something magic,  " a -> IO exactlywhatIwanted"
22:00:39 <copumpkin> I think mmorrow had a function like that, but you'd need to find him first
22:00:56 <FunctorSalad> glguy: "fulfil"?
22:01:02 <FunctorSalad> that's the opposite though
22:01:08 <FunctorSalad> o_O
22:01:20 <FunctorSalad> according to some theories anyway
22:02:52 <copumpkin> glguy: I did something like that a while ago, am trying to find it
22:04:36 <copumpkin> glguy: you using recvfrom?
22:05:29 <glguy> yeah
22:05:42 <copumpkin> the fourth argument gives you an address structure that can tell you who sent it
22:05:50 <copumpkin> wait, fifth
22:06:49 <glguy> copumpkin: I know how to send back, but I want to make a new socket to talk to that person
22:07:01 <glguy> binding to the non-wildcard address
22:07:15 <copumpkin> hmm
22:07:19 <glguy> I need to know the local SockAddr that the packet was received on
22:08:05 <copumpkin> oh, I see
22:08:12 <copumpkin> so you want to know who the sender thought you were
22:08:18 <glguy> yeah
22:08:30 <copumpkin> hmm!
22:08:57 <copumpkin> not sure it even gives you that information
22:09:13 <copumpkin> you could enumerate local addresses and keep a static socket for each of them?
22:09:47 <copumpkin> then you'd probably want to select across all of them
22:10:01 <glguy> well, I let the user specify the address to bind to
22:10:15 <copumpkin> oh
22:10:17 <glguy> but picking 0.0.0.0 should work
22:10:21 <copumpkin> yeah
22:10:39 * copumpkin thinks
22:10:51 <glguy> Also, what's the best way to get atomic writes with "hPutStrLn stderr"?
22:10:58 <glguy> I don't want threads to trample each other
22:11:07 <glguy> I can weave an mvar around if I have to
22:11:23 <copumpkin> I typically use a chan with a separate thread that does the putstrlning
22:11:38 <copumpkin> and have the various writers write to the chan instead
22:12:00 <monochrom> ISTR each single hPutStrLn is atomic.
22:12:14 <copumpkin> not in my experience
22:12:52 <glguy> ThTrheraedaIddI d2 :3 :L iLsitsetneinnign go no n[ 127.0.0.1:1234::1]:1234
22:13:13 <monochrom> Oh well.
22:13:13 <copumpkin> glguy: have you looked at recvmsg? it might give you the extra information, but I haven't used it
22:14:02 <copumpkin> hmm, maybe not
22:14:50 <copumpkin> glguy: http://groups.google.com/group/comp.os.linux.development.system/msg/e09d9c278c7e6fe1 looks relevant
22:15:31 <glguy> The issue might be that I'm writing to stderr
22:15:43 <glguy> switching to stdout: ThreadId 3: Listening on 127.0.0.1:1234
22:15:43 <glguy> ThreadId 2: Listening on [::1]:1234
22:17:48 <monochrom> If you use NoBuffering, hPutStrLn becomes a loop over hPutChar. This is of course interleaved.
22:19:22 <glguy> with LineBuffering mode on my stderr things are much prettier :)
22:21:25 <glguy> now I just can't use hPutStrLn because it does: hPutStr and then hPutChar '\n'
22:21:54 <copumpkin> hah
22:22:00 <copumpkin> sure you don't want the Chan approach? :P
22:22:29 <glguy> it is an easy fix... all of my hPutStrLn calls were in one wrapper function that added the thread id
22:22:41 <copumpkin> fair enough :)
22:23:41 <monochrom> If you use LineBuffering or BlockBuffering, some piece of memory is taken out of a pool, marshal string into that memory first, and then flush. There is still interleaving but much coarser.
22:24:27 <monochrom> Unfortunately, the code that takes memory out of the pool and returns memory back is written with IORef, not MVar! Eventually you will get a race.
22:24:49 <glguy> it is still debugging output, so it doesn't have to be perfect
22:24:59 <glguy> but it jsut can't be completely interleaved right off the bat :)
22:25:59 <monochrom> The pool is a mutable linked list of buffers. You know how race condition when running linked list butchering algorithms ends in.
22:26:38 <monochrom> So I hope your program won't accidentally just for printing debugging output! :)
22:27:23 <copumpkin> Tdhiatd wtoheuolthed srutechcniqkue work?
22:28:31 <Cale> I accidentally the whole debugging output!
22:29:22 <monochrom> I have a program that wants many threads write to the same Handle too. I'm glad I use the Chan method at the beginning. I now know it won't crash.
22:29:46 <Jafet> And if it does, you'll still get debug output!
22:30:38 <copumpkin> glguy: did you manage to get your destination address?
22:31:01 <glguy> not yet, i'm a bit distracted with the kid
22:31:15 <glguy> but the link you shared looks relevant
22:31:25 <copumpkin> if a little platform-specific
22:32:34 <glguy> sample : http://fpaste.org/CwYE/
22:33:24 <copumpkin> certificates over udp? :o
22:33:57 <glguy> thats just a small file i had laying around :)
22:34:03 <copumpkin> aha
22:34:57 <copumpkin> is .crt the one with the private key? :P
22:35:07 <copumpkin> that'd probably be .p12 I guess
22:35:24 <glguy> p12 is a different format
22:35:47 <monochrom> (if you can get a degree over postal mail, surely you can get a certificate over udp)
22:36:18 <copumpkin> I thought they tended to be the same thing, but some in base64 text and others in binary
22:36:20 <glguy> the t in tftp wasnt a joke
22:36:25 <copumpkin> (and mostly asn.1 behind the scenes)
22:36:45 <copumpkin> at least, when I poked around
22:36:46 <monochrom> I forgot, what does the t stand for?
22:37:01 <copumpkin> trivial
22:37:02 <copumpkin> :P
22:49:46 <ivanm> hey tomberek
22:51:01 <tomberek> hey
22:51:35 <tomberek> ivanm: had an idea, I don't think it's needed, but perhaps it might lead somewhere
22:51:46 <ivanm> shoot
22:52:24 <tomberek> ivanm: I was pulling in the Edison function names, etc. And saw that I'll have repeats like insertVertex,insertArc, etc.
22:52:38 <ivanm> OK
22:52:44 <tomberek> so what if the function insert can just do both?
22:52:54 <ivanm> hmmmm.... be a bit iffy
22:53:03 <ivanm> tomberek: note: you don't have to copy the API of graph.hs ;-)
22:53:30 <ivanm> (in fact, I would keep it similar to how fgl is currently over using graph.hs' names)
22:53:34 <tomberek> insert :: Element g -> g -> g       and both LArc g and LVertex g are of Element g
22:53:50 <ivanm> tomberek: in that case, we can't use tuples for LArc and LVertex
22:53:55 <copumpkin> omnom
22:53:59 <ivanm> which probably isn't that big a deal
22:54:09 <ivanm> greeting gourdish one
22:54:21 * copumpkin eats ivanm 
22:54:33 <tomberek> ivanm: i wasn't sure if that was even worth it,, we could just double up, insertArc,insertVertex
22:54:47 * ivanm pulls out his sabre and slashes his way through copumpkin's orangey flesh and skin
22:55:02 <ivanm> tomberek: yeah, I think just leave insertArc and insertVertex
22:55:07 <copumpkin> ivanm: sorry, you've already been digested, and your sabre is long-dissolved
22:55:11 <monochrom> @slurp copumpkin
22:55:11 * lambdabot will count to five...
22:55:19 <ivanm> copumpkin: with what orifice?
22:55:32 <ivanm> last I checked plants didn't have mouths as a rule...
22:55:39 <copumpkin> someone carved one into me
22:55:43 <copumpkin> how do you think I've been talking to you, silly
22:55:54 <copumpkin> (I don't like to talk about that experience though)
22:56:01 <tomberek> ivanm: agreed, the other thought: a Labelable typeclass? So we end up with types :: Labeled Arc g  and Labeled Vertex g? or Labeled (Arc g)?
22:56:08 <monochrom> copumpkin is a coplant
22:57:01 <ivanm> tomberek: that's getting a bit too close to edward's annotated graphs then for my liking :p
22:57:09 <tomberek> hehehe
22:57:16 <ivanm> tomberek: I wouldn't bother; there's only two inhabitants of that class, so there's no point in defining it
22:57:16 * copumpkin does the edwardk-summoning dance
22:57:27 <ivanm> copumpkin: I thought you used your stem to tap into the keyboard
22:57:34 <ivanm> preflex: seen edwardk
22:57:35 <preflex>  edwardk was last seen on #haskell 8 hours, 35 minutes and 38 seconds ago, saying: if the compiler can't think of at least 20 types, it throws it back at you and calls it rubbish.
22:57:37 <copumpkin> ivanm: nah, dragon naturally speaking
22:57:43 <ivanm> copumpkin: lol
22:57:58 * ivanm won a copy of that, couldn't get it to work in a fashion that made it worth it
22:58:11 <copumpkin> that's cause you're not a gourd, innit
22:58:16 <ivanm> heh
22:59:10 <tomberek> ivanm: the reasoning for Labelable is that if you have type Arc, type ALabel and type LArc.. there is nothing that says there is a connection between them
22:59:38 * copumpkin can think of a nice typeclass with only two instances
22:59:42 <copumpkin> and only two possible instances
23:00:15 <copumpkin> http://www.mail-archive.com/haskell-cafe@haskell.org/msg60806.html
23:00:41 <copumpkin> is there an overview anywhere of CPS in haskell, from the point of view of curry-howard?
23:01:15 <ivanm> tomberek: true, but we want to avoid having too many useless functions/definitions cluttering it up
23:02:08 <ivanm> copumpkin: true; my DotRepr class has only two instances
23:02:20 <tomberek> ivanm: ok, so we can just document, "hey user, make sure LArc makes sense with your Arc and ALabel types"
23:02:20 <copumpkin> does it only have two *possible* instances?
23:02:28 <copumpkin> you should close it!
23:02:42 <ivanm> tomberek: yeah; see how fgl currently does LNode and Node
23:03:14 <tomberek> ivanm: i'm not a fan of forcing that tuple
23:03:39 <ivanm> tomberek: "forcing that tuple"?  you mean you want to specify a LArc data structure?
23:03:53 <ivanm> tomberek: IIRC, tuples are "lighter" than explicit data structures
23:03:58 <tomberek> ivanm: I'd like to allow the user to come up with different ways of labeling them
23:04:20 <ivanm> please don't tell me you're still going on with your "lets make the index part of the label!" rant... :s
23:04:20 <ivanm> :p
23:04:30 <tomberek> ivanm: no no no! i gave up on that
23:04:45 <ivanm> *phew*
23:05:01 <ivanm> tomberek: well, we have to pick one: either we use tuples or we define a data structure
23:05:12 <tomberek> ivanm: now I'm simply saying that we don't have to pick,, let the user pick
23:05:20 <ivanm> I can't think of any sensible way of doing it a more generic way, and we have to make _some_ decisions
23:05:46 <ivanm> it's getting a bit silly IMHO if we make the entire class use some weird conglomeration of typeclasses all over the place
23:05:55 <ivanm> we have to avoid the tempatation of _over_ generalising
23:06:14 <tomberek> ivanm: I suspect that that's what i'm doing.
23:06:19 <ivanm> tomberek: I agree with the usage of a collections class; this I feel is getting a little over the top
23:06:21 <ivanm> tomberek: yup
23:06:34 <tomberek> ivanm: either way, just ideas that popped up
23:06:50 <ivanm> ideas are good; going overboard and insisting on implementing all of your ideas is a different story :p
23:07:08 <FunctorSalad> awesome, I'm just badmouthing weird conglomerations of typeclasses on the other channel ;)
23:07:18 <ivanm> FunctorSalad: heh
23:07:22 <FunctorSalad> assuming they're not necessary and make the API a lot harder to parse
23:07:41 <FunctorSalad> just so you can have a single symbol as final interface
23:07:53 <FunctorSalad> (parse mentally)
23:07:55 <ivanm> FunctorSalad: well, tomberek convinced me we should try to use some collections class for fgl rather than always returning a list
23:08:03 <ivanm> (this way users can also have a Set, etc.)
23:08:32 <ivanm> but he was now talking about whether the new version of LNode (which is currently just (Int, a)) should use a typeclass
23:10:24 <FunctorSalad> ivanm: hmm sometimes the most general interface for that situation is just having the user pass the consumer action
23:10:33 <tomberek> ivanm: what about context?
23:10:48 <ivanm> tomberek: new datatype
23:10:54 <FunctorSalad> at least in strict languages... in haskell it works like that automatically even if you return a list, but may be less efficient
23:11:06 <tomberek> ivanm: not put into the class type with Vertex and Arc?
23:11:12 <ivanm> 2-tuples are OK, 3-tuples I can live with for LArc/LEdge, but the 4-tuples for Context are a right royal PITA
23:11:23 <FunctorSalad> doGraphOperation :: InputGraph -> m OutputSink -> m ()
23:11:25 <FunctorSalad> ;)
23:11:25 <ivanm> tomberek: wait, hang on, you _are_ defining a type class for vertex and arc? :o
23:11:39 * copumpkin subscribes to FunctorSalad's newsletter
23:11:41 <FunctorSalad> (could probably be completely monad-agnostic)
23:11:43 <tomberek> ivanm: no no, they're ATs in the Graph class type
23:11:49 <FunctorSalad> copumpkin:  :(
23:11:49 <ivanm> copumpkin: he has a newsletter?
23:11:52 <copumpkin> yep
23:11:52 <FunctorSalad> am I wrong?
23:11:55 <ivanm> tomberek: oh, the _labels_ are ATs, right?
23:12:03 <ivanm> copumpkin: where is this mysterious newsletter?
23:12:13 <ivanm> FunctorSalad: well, except we're not using monads...
23:12:18 <fhobia> has anybody used ReturnInOrder with System.GetOpt and know what it does?
23:12:20 <FunctorSalad> sorry I'm past bed-time for... who knows, now
23:12:38 <ivanm> fhobia: IIRC, when using flags they have to be in that order
23:12:39 <copumpkin> ivanm: ask him!
23:12:43 <FunctorSalad> ivanm: that interface has "give me a list purely" as a special case
23:12:46 <ivanm> (that is, you can't change the order of flags)
23:12:49 <FunctorSalad> if you use  a writer monad, no?
23:12:55 <tomberek> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25507#a25507
23:13:17 <ivanm> FunctorSalad: I'm talking about something like: nodes :: (Collection c) => Graph a b -> c (LNode a)
23:13:20 <fhobia> ivanm: yeah, you have to provide some (String -> a) function ..i guess it must be some way to convert non-option values i guess...
23:13:31 <ivanm> fhobia: yeah, I think so
23:13:36 <ivanm> its' been a while since I touched GetOpt
23:13:41 <ivanm> fhobia: RWH has a chapter on it IIRC
23:13:47 <FunctorSalad> copumpkin: what's the  nonsense part? that returning a list in haskell resembles passing the consumer action to the former list-returner in strict langs?
23:13:49 <ivanm> FunctorSalad: where is this mysterious newsletter of yours?
23:13:50 <fhobia> ivanm: bigger question is i'm trying to figure if GetOpt supports spaces between flag and argument like "-s value" but so far i can't
23:13:55 <fhobia> ivanm: ok, thanks, i'll check it out now
23:14:11 <FunctorSalad> ivanm: what newsletter?
23:14:12 <FunctorSalad> :(
23:14:13 <ivanm> tomberek: *shudder* let's not generalise that much
23:14:21 <ivanm> have ATs for vertex type, and the two label types
23:14:30 <ivanm> FunctorSalad: copumpkin keeps saying you have a newsletter
23:14:35 <ivanm> and that I should ask you about it...
23:14:41 <ivanm> fhobia: yes
23:15:14 <FunctorSalad> ivanm: I took that as meaning that what I said was barely intelligible, maybe wrong if we're generous
23:15:16 <FunctorSalad> ;)
23:15:22 <ivanm> tomberek: because if we specify an AT for LVertex, etc. then we need to then know how to construct it, deconstruct it, etc.
23:15:28 <ivanm> FunctorSalad: ahhhh
23:15:37 * ivanm puts that down to being an Americanism
23:15:43 <FunctorSalad> at least I think that's the meaning of the newsletter meme
23:16:42 <tomberek> ivanm: hence the Labelable idea.... but I guess we can stick them in 2-tuples
23:16:49 <copumpkin> ivanm: except FunctorSalad isn't american ;)
23:16:55 <copumpkin> ivanm: and neither am I!
23:17:10 <FunctorSalad> ivanm: anyway, if it works for all monads, we aren't really impurifying anything... but I'm not saying there's not some simpler type sig which is just as good ;) (without a monad)
23:17:32 <ivanm> tomberek: I'm open to wheter LEdge should be a 2-tuple (containing the actual 2-tuple edge) or a 3-tuple though
23:17:46 <ivanm> copumpkin: you have USA citizenship do you not?
23:17:52 * copumpkin whistles
23:17:55 <FunctorSalad> but "arbitrary monad m and function a -> m ()" actually seems like a good interface for a sink
23:17:59 * copumpkin contemplates getting rid of it just to make ivanm shut up
23:18:01 * ivanm believes he and copumpkin have had this argument before
23:18:11 <ivanm> copumpkin: permanent residency as well... >_>
23:18:16 <tomberek> ivanm: for consistency, make it a 2 tuple
23:18:25 <copumpkin> ivanm: maybe I'll leave the US, just for your sake
23:18:31 <ivanm> tomberek: sure, that works; then you can use fst and snd
23:18:35 <ivanm> copumpkin: do so!
23:18:36 <tomberek> yeah
23:18:42 <ivanm> you don't have a gf anymore, and you hate your uni!
23:18:52 <FunctorSalad> ah. I see I wrote "m OutputSink" earlier, which is nonsense. "type OutputSink m b = b -> m ()", more like that
23:18:58 <copumpkin> ivanm: it's true, I'm considering it actually :P
23:19:08 <ivanm> copumpkin: going to where?
23:19:24 <copumpkin> ivanm: who knows! I'm a citizen of the world!
23:19:24 <FunctorSalad> if m is arbitrary it is simply something that can be fed elements, and chained together
23:19:32 * copumpkin shuts up about that in #haskell
23:19:50 <ivanm> heh
23:21:50 <monochrom> copumpkin: you asked about cps and curry-howard etc. there is a TMR article. issue 11 2nd article "adventures in classical-land"
23:21:59 <copumpkin> monochrom: oh, great, thanks!
23:22:33 <tomberek> ivanm: so you also want to define Context for all graphs.. data Context = Context {inArcs::[LArc g],vertex::Vertex g,label::VLabel g,outArcs::[LArc g]} ?
23:22:39 <monochrom> copumpkin: sorry, issue 6. direct link: http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf
23:22:56 <ivanm> tomberek: yeah, something like that, except use Label for the label type (since it doesn't need the index type in there)
23:22:59 <copumpkin> thanks :)
23:24:02 <tomberek> ivanm: eh? do you mean LVertex? that's why I used VLabel, less redundant
23:24:14 <ivanm> tomberek: oh, right
23:24:20 <ivanm> getting my terminology mixed up ;-)
23:24:39 <tomberek> ivanm: which suggests that users might mix them up to
23:25:01 <ivanm> yeah....
23:25:04 <tomberek> perhaps LVertex to LabeledVertex?
23:25:25 <ivanm> maybe have VertexLabel and LVertex (or NodeLabel and LNode like fgl currently does)
23:25:34 <ivanm> or that
23:27:44 <ivanm> :o http://news.ycombinator.com/item?id=1349465
23:28:04 <tomberek> ivanm: another consideration... how many functions should we have in the base Graph class? I put in most of the relevant ones from Edison, but it seems like a lot
23:28:07 <ivanm> if that is true, then I might finally switch over to chromium
23:28:21 <ivanm> tomberek: I wouldn't expand it more than what FGL currently has
23:28:28 <ivanm> leave the collections stuff in a separate class
23:30:03 <tomberek> ivanm: for now i'm just using [a], like we discussesd
23:30:17 <ivanm> good-o
23:31:19 <fhobia> oof, can't have spaces between flags and values with GetOpt - i swear! lol
23:32:23 <ivanm> fhobia: sure you can
23:32:28 <ivanm> I use it for haskell-updater
23:32:48 <fhobia> i have to do: prog "-f value"
23:32:54 <fhobia> i can't do: prog -f value
23:32:56 <ivanm> fhobia: http://code.haskell.org/gentoo/haskell-updater/Main.hs
23:33:00 <fhobia> this works: prog -fvalue
23:33:08 <fhobia> ok, thanks ivanm
23:33:11 <fhobia> for your patience :)
23:33:14 <glguy> fhobia: then you did something wrong
23:33:25 <fhobia> that would be awesome
23:33:27 <ivanm> fhobia: it allows something like: haskell-updater -P paludis
23:33:35 <copumpkin> ur doin it rong
23:33:45 <glguy> got fix it
23:33:47 <glguy> go*
23:34:08 <fhobia> yeah, it would be crazy if no spaces were permitted
23:34:11 <fhobia> no way it would get past review
23:34:33 <tomberek> ivanm: btw, do you understand FGL's gfold?
23:34:42 <ivanm> I think so, or at least once did
23:34:44 <copumpkin> monochrom: interesting article, but I was after more of how one of those cont-shaped things is equivalent to an existential, and so on
23:34:48 <glguy> Does -f have an optional argument?
23:34:52 * ivanm checks to see if he actually used it or is remembering things
23:35:08 <ivanm> fhobia: if the argument is compulsory, needs a space; if its optional then you can't have a space
23:35:09 <glguy> I just checked it with my tftpd and it worked with the space and without
23:35:23 <glguy> -blocalhost and -b localhost worked
23:35:33 <ivanm> glguy: required argument?
23:35:38 <glguy> yeah
23:36:07 <fhobia> ivanm: oh...nice catch...
23:36:11 <fhobia> ivanm: hmm....
23:38:05 <fhobia> ivanm: YES
23:38:17 <fhobia> so i read "ReqArg" wrong...it means required argument after the flag
23:38:26 <fhobia> not you need this flag or else error
23:38:56 * fhobia dances
23:39:52 <fhobia> note to add that to the docs once i figure out the darcs thing...
