00:00:03 <kmc> i don't see why it would
00:00:33 <SubStack> > take 10 $ drop 5 $ concatMap show $ iterate ((^2) . read . take 8 . drop 1 . show) 75621
00:00:34 <lambdabot>   "3159564125"
00:01:02 <kmc> JoeyA, we try not to think about evaluation order at all
00:01:23 <kmc> the system will do as little evaluation as necessary, in whatever order is necessary, to get the result you ask for
00:01:51 <kmc> if you have something you care about the order of (e.g. printing output, writing to mutable variables), it's probably not a matter of evaluation at all.  it's a matter of execution
00:02:09 <kmc> evaluation is just the simplification of terms by substituting into the bodies of functions
00:04:07 <mgsloan> Thunks can be bigger than evaluated values, though, so laziness can be memory inefficient
00:04:39 <kmc> right.  to get good time or space performance, you often do need to care about evaluation order, and that's one of the big drawbacks of Haskell's design
00:05:26 <kmc> but evaluation order in Haskell should never matter for program correctness.  if you manage to write a program where it does, you're cheating somehow
00:06:39 <c_wraith> Such cheating is possible, but highly discouraged
00:07:44 <tensorpudding> Is it possible without using unsafeFoo?
00:08:05 <monochrom> No.
00:08:23 <c_wraith> kind of.  Debug.Trace doesn't have the word unsafe in it
00:08:34 <kmc> tensorpudding, consider (error "foo" + error "bar").  is it a correctness property of this program whether it quits with error message "foo" or "bar"?
00:08:35 <c_wraith> Though it's implemented with unsafePerformIO
00:08:51 <kmc> the spec for exceptions in Haskell basically says it is not
00:09:00 <kmc> this is the "imprecise exceptions" business
00:09:29 <kmc> the denotation of an expression is either a normal value or a *set* of exceptions
00:09:59 <kmc> "catch" gives you a nondeterministic selection from that set, but it does so as the result of an IO-action, so it's fine
00:10:19 <blackdog> that's some very clever footwork:)
00:10:22 <tensorpudding> Okay, so it's not possible to do it with anything that isn't obviously using special magic.
00:10:34 <kmc> "spoon" provides a "pure catch" but is (just barely) acceptable, since it squashes all the elements of that set to "Nothing"
00:10:50 <kmc> (and in fact refuses to touch some exceptions, which depend on stuff other than the term being evaluated)
00:11:33 * hackagebot bff 0.3.1 - Bidirectionalization for Free! (POPL'09)  http://hackage.haskell.org/package/bff-0.3.1 (DanielSeidel)
00:19:24 <monochrom> @quote noggle
00:19:24 <lambdabot> noggle says: this language is like having programming super powers
00:19:27 <monochrom> hehe
00:19:35 * hackagebot mighttpd 0.4.1 - Simple Web Server in Haskell  http://hackage.haskell.org/package/mighttpd-0.4.1 (KazuYamamoto)
00:23:31 <monochrom> @quote lament:
00:23:31 <lambdabot> lament: says: I think I speak for everyone in this channel when I say haskell is absolutely horrible and nobody would ever want to use it
00:24:50 <Veinor> lol
00:35:55 <RyanT5000> i'm having some trouble loading one of my projects in GHCi
00:36:10 <RyanT5000> it uses a library that includes some C++ code
00:37:06 <RyanT5000> Loading package asdf-0.1 ... linking ... <interactive>: /usr/local/lib/asdf-0.1/ghc-6.10.4/HSasdf-0.1.o: unknown symbol `_ZNSt6vectorI10StripPointSaIS0_EEC1ERKS2_'
00:37:48 <RyanT5000> i'm invoking ghci like this: ghci -lstdc++ -lsqlite3 -lexpat bloodSim.hs
00:38:07 <RyanT5000> (bloodSim.hs is the source file that refers to the library in question)
00:38:26 <RyanT5000> it seems that any use of stl templates cannot be loaded by GHCi
00:38:35 <kmc> that symbol is: std::vector<StripPoint, std::allocator<StripPoint> >::vector(std::vector<StripPoint, std::allocator<StripPoint> > const&)
00:38:39 <kmc> acccording to c++filt
00:38:58 <kmc> std::vector is a template, meaning the symbol doesn't exist until instantitaed
00:39:16 <kmc> you should link some library which instantiates the template
00:39:28 <kmc> which i'm guessing you already have around
00:39:45 <RyanT5000> well, that's what's confusing me
00:39:56 <RyanT5000> i put explicit template instantiations in the cpp file
00:39:59 <kmc> but if not, you can make a .cpp file with the relevant includes followed by "template class std::vector<StripPoint>;"
00:40:03 <kmc> yeah
00:40:11 <RyanT5000> yup, i have that exact line
00:40:20 <RyanT5000> nm gives me some weird stuff, though
00:40:23 <kmc> does objdump show a symbol of that name?
00:41:00 <kmc> also how does ghci know to look in the object file generated from your cpp file
00:41:14 <RyanT5000> hm, i don't know how to use objdump; nm gives me "000000000000 W" for all the template-instantiated symbols
00:41:22 <RyanT5000> well, the object file is linked into the package
00:41:31 <RyanT5000> because the CPP file is specified in the cabal file
00:41:36 <kmc> okay
00:41:39 <kmc> does ghci look there?
00:41:43 <RyanT5000> though i haven't verified that ghci definitely knows to look for it
00:42:09 <kmc> i don't think it would
00:42:17 <RyanT5000> hm
00:42:18 <kmc> try giving the .o file on the command line to ghci
00:42:29 <RyanT5000> when i give it the .o file on the command line
00:42:31 <RyanT5000> then it fails *immediately*
00:42:45 <RyanT5000> instead of waiting until i try to run something in my module
00:42:49 <kmc> with the same error?
00:42:57 <kmc> weird
00:42:59 <RyanT5000> a different symbol, but the same basic thing
00:43:23 <kmc> sigh, c++
00:43:27 <RyanT5000> if i run ghc --make, it works just fine, btw
00:43:35 <RyanT5000> i get a completely working binary
00:44:06 <RyanT5000> (whether i put in the template instantiations or not)
00:46:57 <RyanT5000> the symbols appear in /usr/local/lib/asdf-0.1/ghc-6.10.4/{HSasdf-0.1.o,libHSasdf-0.1.a}
00:47:05 <RyanT5000> but they're also 000000000000 W
00:47:39 <RyanT5000> however, it appears as 000000000056e2f0 W in the binary when i build it using ghc --make
00:47:53 <kmc> hmm
00:48:02 <RyanT5000> i'm not sure where ghc --make is getting the template instantiation from, because i'm building in a different source tree
00:48:07 <kmc> i would poke around with objdump
00:48:10 <kmc> it gives more information than nm
00:48:10 <RyanT5000> so it should only have access to the lib
00:48:14 <RyanT5000> alright
00:48:18 <RyanT5000> i'll need to figure out how it works :P
00:48:21 <kmc> this sounds like a tricky one
00:48:22 <kmc> good luck
00:55:56 <nniro> kmc: hey I think I've managed to implement continuation passing style for my earlier example : calculate'cps :: Exp -> (Integer -> r) -> r; calculate'cps (Lit a) f = f a; calculate'cps (Add a b) f = calculate'cps a $ \result'of'a -> calculate'cps b $ \result'of'b -> add'cps result'of'a result'of'b $ \sum'of'a'b -> f sum'of'a'b where add'cps :: Integer -> Integer -> (Integer -> r) -> r; add'cps a b f = f (a + b)
00:56:28 <kmc> cool
00:57:29 <kmc> i wonder if there would be any point to trying the Cont monad way of doing things as well
00:58:02 <RyanT5000> kmc: looks like there's a bug for this
00:58:11 <RyanT5000> http://hackage.haskell.org/trac/ghc/ticket/3333
00:58:32 <kmc> aha!
00:58:32 <nniro> at this point, I guess it's a good idea to grasp the concept first and then move to 'sugar' with the Cont monad :)
00:58:36 <kmc> tricky
00:59:57 <monochrom> If you use Cont, it's a bit disappointing: calculateCont (Lit a) = return a; calculateCont (Add a b) = liftM2 (+) a b  :)
01:00:18 <nniro> kmc: even if I wrote the code, I'm having some trouble figuring how this makes it a tail recursive function
01:00:55 <c_wraith> tail recursion isn't as important in haskell as it is in other functional languages
01:00:56 <monochrom> Oh, it's tail-recursive just because calculate'cps (Add a b) f = calculate'cps a (blah blah)
01:00:58 <kmc> calculate'cps (Add a b) f = calculate'cps a $ .... stuff ....
01:01:49 <monochrom> However, the next fun step is port it to javascript and trampoline it. XD
01:02:02 <kmc> using exceptions ;P
01:02:13 <kmc> javascript is the world's most popular functional language
01:02:14 <monochrom> eww
01:02:49 <monochrom> I have an example in http://www.vex.net/~trebla/tail.html
01:03:20 <kmc> that's quite interesting.
01:03:47 <tensorpudding> gcd uses the euclidean algorithm right?
01:04:04 <kmc> making functions tail-recursive generally involves introducing an "accumulator" parameter.  CPS is a general process for doing this, where the accumulator itself is a function
01:04:05 <monochrom> yah
01:04:07 <kmc> never thought of it that way before
01:04:07 <tensorpudding> Or is there a faster one.
01:05:16 <kmc> it also becomes more clear why things like foldl are problematic though tail recursive
01:05:50 <kmc> because you'd expect a big continuation built out of lots of lambdas to take up lots of memory
01:07:01 <monochrom> trades heap space for stack space
01:07:26 <kmc> and with lazy evaluation, your accumulator might behave like that even though it's not a function
01:07:39 <kmc> interesting stuff
01:09:30 <nniro> hmm, and continuation passing style is still lazilly evaluated so maybe this could use seq in order to avoid stack overflow?
01:09:38 <monochrom> Yeah
01:09:51 <kmc> «seq (\x -> ...) y» is useless
01:09:57 <kmc> because a lambda term is already in WHNF
01:10:11 <monochrom> \result'of'a -> seq a $ calculate'cps b $ ...
01:10:19 <kmc> ah
01:10:37 <monochrom> err, seq result'of'a
01:10:46 <kmc> \!a -> ...
01:10:48 <kmc> maybe
01:10:58 <kmc> > (\!x -> x) ()
01:10:59 <lambdabot>   <no location info>: parse error on input `->'
01:11:05 <kmc> > (\(!x) -> x) ()
01:11:06 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
01:11:11 <kmc> grr
01:11:15 <nniro> eheh
01:11:20 <monochrom> This is the problem with meaningful identifiers. I can't distinguish among them at 4am.
01:11:41 <nniro> ahah already 4am for both of us >.<
01:11:57 <kmc> this means 4am is a good time to switch to de bruijn indices
01:12:25 <kmc> that will surely make things easier
01:12:25 <monochrom> totally!
01:12:38 <monochrom> It eliminates variable capture too!
01:13:24 <nniro> any quick way we could test calculate'cps for stack overflows?
01:13:46 <nniro> I don't know how to add Exp as an instance of Enum
01:16:58 <nniro> monochrom: is this how you told me to do it? : calculate'cps :: Exp -> (Integer -> r) -> r; calculate'cps (Lit a) f = f a; calculate'cps (Add a b) f = calculate'cps a $ \result'of'a -> result'of'a `seq` calculate'cps b $ \result'of'b -> result'of'b `seq` add'cps result'of'a result'of'b $ \sum'of'a'b -> sum'of'a'b `seq` f sum'of'a'b where add'cps :: Integer -> Integer -> (Integer -> r) -> r; add'cps a b f = f (a + b)
01:21:29 <kmc> that is pretty hard to read
01:21:31 <kmc> pastebin?
01:24:04 <nniro> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25353#a25353
01:26:51 * ManateeLazyCat Search *Haskell instead Haskell in Google, you will got surprise. :)
01:27:19 <ivanm> ManateeLazyCat: the side bar? seems to be a bit random as well
01:27:26 <ivanm> I got that all day when searching at uni
01:27:58 <ManateeLazyCat> ivanm: I want search IconInfo in Google, but i copy *IconInfo, then i found Google UI is change. :)
01:28:11 <ivanm> ManateeLazyCat: yeah, they've been experimenting with that for a while
01:28:13 <nniro> kmc: so, what do you think, would this be stack overflow free?
01:28:17 <ManateeLazyCat> ivanm: Then i found any keyword add * with new UI.
01:29:26 * ManateeLazyCat I found GIO's APIs is much much faster than GnomeVFS. :)
01:34:46 <monochrom> nniro: that's how I would do it.
01:35:18 <nniro> monochrom: ok :)
01:37:48 <monochrom> lefthand n = if n==0 then Lit 0 else Add (lefthand (n-1)) (Lit 0)
01:38:04 <monochrom> righthand n = if n==0 then Lit 0 else Add (Lit 0) (righthand (n-1))
01:38:15 <monochrom> use these to help test memory usage.
01:40:24 <monochrom> @quote medfly maintenance
01:40:24 <lambdabot> medfly says: Haskell is zero maintenance because you can't get anyone to maintain it. (:
01:40:26 <monochrom> hehe
01:47:14 <nniro> monochrom: would it impress you if the cps version would uses more memory than the 'standard' version?
01:48:21 <monochrom> I expect it to use a lot of heap memory. I just hope it saves stack memory.
02:05:17 * hackagebot bmp 1.1.0.0 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.1.0.0 (BenLippmeier)
02:09:25 <ivanm> preflex: seen Axman6
02:09:25 <preflex>  Axman6 was last seen on #haskell 1 day, 3 hours, 4 minutes and 2 seconds ago, saying: eh?
02:10:08 <nniro> monochrom: kmc: here are the statistics for both methods : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25354#a25354
02:13:31 <kmc> night all
02:13:42 <nniro> good night, thanks for the help :)
02:14:23 <nniro> monochrom: same goes for you ;)
02:20:51 <scotthw_> hello all!
02:21:04 <scotthw_> i'd like to zipWith two lists
02:21:07 <scotthw_> but at a certain location
02:22:03 <scotthw_> for example, if I have [2,2,2,2,2] and [0,1,2,3,4,5,6] and location 2
02:22:10 <scotthw_> with (+)
02:22:32 <scotthw_> it would return [0,1,4,5,6,7,8]
02:22:36 <scotthw_> does this exist?
02:24:27 * hackagebot she 0.1 - A Haskell preprocessor adding miscellaneous features  http://hackage.haskell.org/package/she-0.1 (ConorMcBride)
02:25:06 <quicksilver> conor++ # hackaging she
02:34:05 <ra1m0> scotthw_: drop location amount of items first and then zip?
02:36:43 <scotthw_> ra1m0: OK, but I still want the beginning and end of the list
02:39:15 <scotthw_> i could do a take and a drop, work on the drop put them back together
02:39:18 <scotthw_> hmm
02:39:57 <Twey> take + drop = splitAt
02:40:01 <arcatan> zipWith3 (\a b index -> if index == location then a + b else b) [2,2,2,2,2,] [0,1,2,3,4,5,6] [0..]
02:40:14 <Twey> arcatan: Ew, ZipList, ZipList
02:40:14 <arcatan> well, something like that anyway
02:42:19 <zygoloid> > let location = 2; xs = [2,2,2,2,2]; ys = [0,1,2,3,4,5,6] in zipWith (+) (replicate location 0 ++ xs) ys
02:42:20 <lambdabot>   [0,1,4,5,6,7,8]
02:42:44 <scotthw_> wow that's great!
02:42:49 <Twey> Clever
02:43:54 <arcatan> oh, i misread your question, disregard my answer
02:45:13 <ToRA> > zipWith3 (\i -> if i >= 2 then (+) else flip const) [0..] (repeat 2) [0..6]
02:45:14 <lambdabot>   [0,1,4,5,6,7,8]
02:45:58 <Twey> That only works if the other list is the same all along, though
02:46:13 <Twey> (@ zygoloid)
02:46:27 <Twey> If you try that with [1 ..] it will be displaced
02:48:15 <scotthw_> Twey: what do you mean displaced?
02:48:54 <scotthw_> > let location = 2; xs = [1..]; ys = [0,1,2,3,4,5,6] in zipWith (+) (replicate location 0 ++ xs) ys
02:48:55 <lambdabot>   [0,1,3,5,7,9,11]
02:50:31 <Twey> You get 3, 5, 7, not 4, 6, 8, even though you're starting from position two
02:50:36 <scotthw_> also, I cannot have it cut off the end
02:50:56 <scotthw_> in otherwords, the out needs to be the length of the longer list
02:51:16 <scotthw_> I guess i could cons the shorter with repeat 0
02:58:05 <quicksilver> scotthw_: that's not cons, but you could
02:58:17 <scotthw_> yeah, (++)
02:58:35 <scotthw_> but I don't see what is wrong with zygoloid's version
02:58:36 <scotthw_> ?
02:58:50 <scotthw_> what was Twey referring to?
03:02:17 <Twey> > let zipFrom l f xs ys = id *** flip (zipWith f) (drop l ys) $ splitAt l xs in zipFrom 2 (+) [1 ..] [0 .. 6]
03:02:18 <lambdabot>   ([1,2],[5,7,9,11,13])
03:02:23 <Twey> Oops
03:02:49 <Twey> > let zipFrom l f xs ys = uncurry (++) . (id *** flip (zipWith f) (drop l ys)) $ splitAt l xs in zipFrom 2 (+) [1 ..] [0 .. 6]
03:02:50 <lambdabot>   [1,2,5,7,9,11,13]
03:06:04 <Twey> @hoogle (b -> c) -> (a, b) -> (a, c)
03:06:05 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
03:06:05 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
03:06:05 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
03:06:10 <Twey> Pmph
03:17:28 <twanvl> How do I force Cabal to install a new version of a package?
03:19:14 <ivanm> twanvl: which package?
03:19:16 <ivanm> and why?
03:19:21 <twanvl> Cabal
03:19:28 <twanvl> so I can actually build things
03:19:40 <ivanm> ummmm.... do you mean cabal-install to build Cabal?
03:19:50 <benmachine> I think upgrading Cabal is a bit thorny
03:20:01 <ivanm> benmachine: not at all
03:20:12 <twanvl> when I try "cabal install Cabal", it says "All requested packages are already installed. Nothing to do"
03:20:13 <ivanm> that's the only library that ships with ghc that you can safely update
03:20:17 <benmachine> oh ok
03:20:20 <benmachine> cool!
03:20:20 <ivanm> as no other library there actually depends upon it
03:20:26 <ivanm> twanvl: cabal install Cabal --reinstall
03:20:39 <tensorpudding> That's a really great command invocation there.
03:21:04 <twanvl> unrecognized option "--reinstall"
03:21:08 <ivanm> tensorpudding: hmmm?
03:21:11 <tensorpudding> Almost as good as cabal install --reinstall cabal install
03:21:18 <ivanm> twanvl: which version of cabal-install do you have?
03:21:25 <twanvl> 0.4.5
03:21:25 <tensorpudding> err, cabal-install*
03:21:30 <twanvl> it's an old system
03:21:39 <ivanm> twanvl: ummm.... I don't believe there was ever a version that old :s
03:21:55 <ivanm> there was 0.4, then 0.5
03:22:00 <ivanm> no 0.4.5 according to hackage
03:22:07 <ivanm> (so yeah, there were old ones >_>)
03:22:33 <twanvl> it is cabal-install 0.4.5, Cabal library 1.3.8
03:22:43 <benmachine> ghc version?
03:22:47 <twanvl> 6.8
03:22:54 <twanvl> I'll try installing a tarbal from hackage
03:23:29 <benmachine> probably for the best
03:24:06 <ivanm> wow, that's ancient...
03:24:13 <ivanm> what is that, debian-ultra-stable or something? :p
03:24:39 <quicksilver> 6.8 doesn't feel ancient to me
03:24:45 <quicksilver> I only switched from 6.6 a few weeks ago
03:25:57 <ivanm> quicksilver: :o
03:26:31 <benmachine> my webhost uses 6.8
03:26:50 <benmachine> so I get to learn about the exciting world of writing compatible code
03:29:50 <twanvl> I'm trying to use System.Process, which has been completely rewritten between 6.8 and 6.10
03:30:09 <quicksilver> ah, well, that is a tricky one yes :)
03:30:41 <benmachine> ack I wanted to use that :(
03:33:54 <Entroacceptor> can't you? Just use defines or something...
03:36:07 <benmachine> never liked cpphs
03:36:24 <benmachine> let's take the newest and most interesting language, and combine it with something written three decades ago
03:37:24 <benmachine> ivanm: I'm about to reply to one of your -cafe posts but I thought I'd ask first if you knew about -XDeriveDataTypeable
03:37:41 <ivanm> nope
03:37:52 <benmachine> oic
03:37:53 <ivanm> benmachine: anyway, he's wanting to alter one of the definitions in TH
03:38:08 <ivanm> and I assume that extension lets you do derive(Typeable)?
03:38:14 <benmachine> and Data, yeah
03:38:14 <ivanm> if so, it won't be of much help...
03:38:20 <benmachine> what about StandaloneDeriving?
03:38:32 <ivanm> never heard of it
03:38:56 <benmachine> it lets you generate deriving code apart from the original definition
03:39:11 <benmachine> -> orphan instance, usually, but it's helpful sometimes
03:40:37 <ivanm> ahhh, cool
03:42:33 <progrock`> I'm planning on trying to write a web user management system in either ocaml or haskell (basically need use of cookies or sessions, a database, and basic email).. .coming from a python background... Do you tihnk Haskell is a decent choice? or think I'll find OCaml a little easier for this kind of project
03:42:47 <sohum> I wish the maths world would adopt the haskell world's convention of surrounding a symbolic function's name with brackets when talking about it by itself
03:42:57 <sohum> i.e., I wish I could say "(+) is defined as..." instead of "+ is defined as..." and not be looked at funny
03:43:14 <opqdonut> mgmm
03:43:15 <opqdonut> *mhmm
03:43:25 <opqdonut> i've missed that syntax a couple of times too
03:44:26 <sohum> haskell syntax is in so many ways such a logical extension of standard maths syntax that it makes me unhappy using both
03:45:17 <sohum> unhappy using maths because I don't have the logical extensions, unhappy using haskell because it behaves so uncleanly unmathlike at times
03:47:20 <bremner> use Java for a while, that will make you happy with haskell syntax
03:47:57 * hackagebot hashed-storage 0.5 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5 (PetrRockai)
03:48:28 <ivanm> bremner: heh
03:48:37 <progrock`> lol.. use php for a minute.. and all other syntax will look nicer
03:48:50 * sohum snerk
03:49:00 <sohum> I'm not complaining
03:49:07 <sohum> it
03:49:20 <sohum> it's the whole problems expand to fill a constant space thing
03:52:17 <progrock`> think Haskell may be a better choice over OCaml for simply learning purposes? (oe. will have to force myself into functional programming... opposed to all the OO stuff I hae done)
03:52:23 <progrock`> ie*
03:52:56 <quicksilver> I think haskell is a better choice from a language perspective, but I dunno about web libraries in either case.
03:53:13 <quicksilver> ocaml will give you the tainted lure of some OO functionalities which will distract you :)
03:53:35 <tensorpudding> Haskell might be a better language for learning because it has a more active community.
03:53:49 <progrock`> yeah.. I;m afraid ill lean too much to using OO stuff isntead of functional
03:55:16 <progrock`> Is Real World Haskell a good hoice in a book purchase, or do you guys recommend others?
03:55:33 <dv-> It's good
03:56:17 <benmachine> I never read RWH
03:56:27 <benmachine> preferred learnyouahaskell
03:56:30 <progrock`> ok.. I;m tired of looking at my computer screen already for their fre web version.. think I might purchsae it
03:56:34 <benmachine> but everyone has different experiences
03:57:23 <progrock`> benmachine: are you familiar with which is geared towards what... or both more jsut introductions that dont get too complex
03:57:45 <tensorpudding> You could consider Haskell as being an ML language, if you want.
03:59:09 <benmachine> progrock`: learnyouahaskell is more cute :)
03:59:16 <bremner> progrock`: RWH goes into more depth
03:59:53 <progrock`> haha, cute...
04:00:05 <benmachine> well I mean it's written in a different style
04:00:06 <dv-> learnyouahaskell is mostly one-liners. RWH has longer examples
04:00:09 <benmachine> which I enjoy
04:00:15 <progrock`> so in other words I could probably get threw learnyouahaskell in a long day.. while RWH might be a few?
04:01:31 <arcatan> you can't get LYAH as a dead-tree book, yet at least.
04:02:38 <progrock`> yeah I noticed.... might make me read LYAH online for now, while I order the RWH book
04:02:54 <dv-> HSOE is nice too
04:03:40 <progrock`> HSOE?
04:03:52 <arcatan> Haskell School of Expression
04:05:54 <tensorpudding> If I were classifying Haskell in the ML family, I'd have to put it in a different genus as Ocaml.
04:06:24 <progrock`> alright, well, when it comes to having a print book to learn and (less important) reference... HSOE or RWH?.. in your opinion, of course
04:08:16 <progrock`> HSOE is looking good based on the amazon reviews (not to say RWH isn't) but I kinda like the "the book is mainly examples of Haskell and functional programming rather than explanations of Haskell and FP"  as much as thats a 'negative' review.. I usually like being thrown into *good* somewhat complex code, instead of treading water for too long
04:08:21 <whald> @hoogle isNaN
04:08:21 <lambdabot> Prelude isNaN :: RealFloat a => a -> Bool
04:08:33 <whald> @hoogle RealFloat a => a -> Bool
04:08:33 <lambdabot> Prelude isDenormalized :: RealFloat a => a -> Bool
04:08:34 <lambdabot> Prelude isIEEE :: RealFloat a => a -> Bool
04:08:34 <lambdabot> Prelude isInfinite :: RealFloat a => a -> Bool
04:10:17 <whald> shouldn't that last query have included isNaN?
04:10:26 <quicksilver> maximum three results
04:10:30 <tensorpudding> It only lists three results
04:10:34 <tensorpudding> @hoogle a
04:10:34 <lambdabot> Data.Graph.Inductive.Example a :: Gr Char ()
04:10:34 <lambdabot> Data.Graph.Inductive.Example a' :: IO (SGr Char ())
04:10:34 <lambdabot> Data.Graph.Inductive.Example ab :: Gr Char ()
04:10:34 <quicksilver> it is only a bot plugin
04:10:41 <quicksilver> the real hoogle website is much more useful
04:10:54 <benmachine> there's a command line tool as well
04:11:47 <whald> oh, ok thanks. this time i was only looking for isInfinite, but a next time will come for sure
04:14:20 <zygoloid> @hoogle nan
04:14:21 <lambdabot> Prelude isNaN :: RealFloat a => a -> Bool
04:15:16 <lyndon__> Hey. What is the point of the SourceName parameter to the parse function in Parsec?
04:15:27 <progrock`> ugh I hate when hard covers cost 2x + the paperback
04:15:35 <ivanm> lyndon__: I think it's for error messages
04:15:40 <ivanm> so it can tell you which file has the bug
04:15:40 <zygoloid> lyndon__: iirc it's so it can include it in error messages
04:16:00 <lyndon__> zygoloid: ivanm: Ah.
04:26:13 <akosch> are the haskell bindings for chipmunk (hipmunk) usable? did anybody use them for something serious?
04:27:26 <akosch> i know there is HipmunkPlayground showing off features, but that doesn't even compile on my system
04:29:43 <nostrand^^> hi
04:31:30 <progrock`> I hope my webhost starts supporting mod_python and mod_ruby... but untill then.. I am definitely gonna give writing some web applications with Haskell a try
04:31:52 * ivanm waves idly in nostrand^^'s general direction
04:32:02 <nostrand^^> i have a list of lists [[a]] and i want to get all the combinations of "take one from each list". It doesn't need to be efficient or so, just somethin simple =)
04:32:05 <nostrand^^> ivanm: ^ ^
04:32:24 <fax> hi nostrand^^
04:32:30 <ivanm> hmm....
04:32:43 <fax> urgh
04:33:00 <fax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25357#a25357
04:33:23 <ivanm> perms [] = [[]]; perms (xs:xss) = concatMap (map ((:) xs) (perms xss)
04:33:25 <fax> nvm that
04:33:26 <ivanm> something like that
04:33:48 <fax> > sequence ["wh","aeu","kts","ou","tm"]
04:33:48 <lambdabot>   ["wakot","wakom","wakut","wakum","watot","watom","watut","watum","wasot","w...
04:34:45 <ivanm> ooohhhh, didn't think about sequence
04:36:44 <progrock`> wow, jsut realized 650~ people in here.... is this an off hour?... this channel get pretty hectic in a few hours?
04:36:59 <fax> no not really
04:37:14 <zygoloid> lots of lurkers
04:37:21 <fax> if there was 16 more people it would be heptic
04:37:32 <progrock`> ok, cool.. scared me for a sec.. I've seen channels with 150 or so be too hectic for me
04:38:40 <nostrand^^> ivanm & fax thanks, sequence seems to be exactly what i want :D
04:40:20 <nostrand^^> \o/
04:43:24 <ivanm> preflex: seen bos
04:43:24 <preflex>  bos was last seen on #haskell 2 days, 6 hours, 37 minutes and 58 seconds ago, saying: hmm
04:50:47 <buntfalke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25358#a25358 can someone tell me why this wont work?
04:50:59 <buntfalke> I am getting rather frustrated with this simple piece of code...
04:51:48 <fax> what's wrong with it
04:52:13 <buntfalke> ghc says
04:52:19 <buntfalke>    Couldn't match expected type `[[Char]]'
04:52:20 <buntfalke>            against inferred type `([t], [t]) -> [t]'
04:52:21 <buntfalke>     In the first argument of `printList', namely `concat''
04:52:29 <fax> ah
04:52:31 <fax> you wrote printList concat' ([1,2], [3,4])
04:52:40 <fax> but you should write printList (concat' ([1,2], [3,4]))
04:52:40 <buntfalke> yes. but how to do it properly?!
04:52:47 <buntfalke> ooooooooh
04:52:51 <buntfalke> grml...thanks!
04:52:53 <buntfalke> :-D
04:53:23 <ivanm> or printList $ concat' ([1,2], [3,4])
04:53:24 <pastorn> buntfalke: also, if you only use one monadic fuction you don't need to write "do"
04:53:38 <ToRA> also, line 11 you want (show x)++".... not x++"....
04:53:42 <pastorn> f = do { f; g } <-- necessary
04:53:53 <pastorn> whoops
04:53:53 <progrock`> just out of curiosity, does ' have a meaning in the code, or just as much as another elter in concat would?
04:54:14 <pastorn> f = do { g; h } ; f' = g
04:54:15 <progrock`> letter*
04:54:27 <ivanm> progrock`: the latter
04:54:44 <ivanm> progrock`: you can have symbols and numbers in function names (they just have to start with a lower case letter)
04:54:48 <pastorn> progrock`: in haskell you usually put ' after something to signify a different version of one value
04:55:01 <ivanm> pastorn: apparently its meant to indicate a strict version >_>
04:55:08 <ivanm> (e.g. foldl' vs foldl)
04:55:14 <ivanm> but I just use it to indicate a different version
04:55:35 <progrock`> oh, gotcha.. makes sense
04:55:37 <pastorn> > (\x -> let x' = x + 1 in 2 * x') 3
04:55:38 <lambdabot>   8
04:56:27 <buntfalke> ivanm, pastorn: thanks
04:57:29 <benmachine> I think I'm one of the only people who posts to haskell-cafe but doesn't have a signature
04:57:33 <benmachine> does this make me a bad person
04:57:54 <progrock`> very bad
04:58:03 <ivanm> benmachine: as in you don't say who you are?
04:58:04 <Saizan> then i'm a bad person too
04:58:07 <ivanm> *tsk, tsk*
04:58:24 <ivanm> what's the easiest way to run an external command and get the stdout in Haskell?
04:58:35 <Saizan> readProcess
04:58:51 <benmachine> ivanm: I assume the From header does that
04:58:52 <ivanm> cool, missed that one
04:58:57 <ivanm> thanks Saizan
04:59:04 <ivanm> benmachine: oh, wait, you're meant to read that bit? :p
04:59:07 <benmachine> I mean I don't end my emails except by stopping typing, as it were :P
04:59:37 <benmachine> that was the least coherent description of anything ever
05:00:30 <benmachine> but I was just wondering if it was one of those things like top-posting that new people do and everyone is too polite to berate them for
05:01:08 <ivanm> Saizan: do you know if readProcess cares about getting the explicit directory right?
05:01:40 <Saizan> ivanm: explicit directory?
05:02:14 <ivanm> as in do I need to do readProcess "/usr/bin/foo" [] "", or is just readProcess "foo" sufficient?
05:02:33 <Saizan> the former, it doesn't look in the $PATH
05:02:54 <ivanm> OK, I suppose I can use findExecutable
05:04:05 <ToRA> eer
05:04:12 <ToRA> fairly sure readProcess does look in $PATH
05:05:11 <Saizan> mh, so it does
05:07:09 <dv-> Er, no ghc in rhel?
05:09:31 * hackagebot gloss 1.1.0.0 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.1.0.0 (BenLippmeier)
05:09:33 * hackagebot gloss-examples 1.1.0.0 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.1.0.0 (BenLippmeier)
05:12:59 <buntfalke> When switching ["1","2"] to [1, 2] ghc tells me: No instance for (Num [Char])
05:13:15 <buntfalke> Do I need to add String.fromInt or so like in SML somewhere?
05:13:16 <fax> makes sense
05:13:36 <ivanm> awwww, I thought benl released the bmp library before so that gloss could export images :(
05:13:36 <fax> to turn 1 into "1" use show
05:13:49 <fax> and to turn [1,2] into "[1,2]"
05:13:59 <buntfalke> "show". thanks :-)
05:14:07 * buntfalke reads up on that
05:37:29 <ivanm> @pl \ a -> f a || g a
05:37:29 <lambdabot> liftM2 (||) f g
05:40:38 <ivanm> @ask sinelaw have you ever used graphNodes or graphEdges in graphviz? If so, would you mind if I switched them to be Sets rather than Lists?
05:40:39 <lambdabot> Consider it noted.
05:42:42 <baaba> @hoogle Arrow a => a b c -> a b c' -> a b c'' -> a b (c, c', c'')
05:42:42 <lambdabot> No results found
05:43:19 <fax> @hoogl arrow
05:43:19 <lambdabot> Maybe you meant: hoogle hoogle+
05:43:24 <fax> @hoogl+ arrow
05:43:24 <lambdabot> Maybe you meant: hoogle hoogle+
05:43:29 <fax> whats hooldle +
05:45:53 <ivanm> @help hoogle+
05:45:53 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
05:45:57 <ivanm> @help hoogle
05:45:57 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
05:46:07 <ivanm> @hoogle+ arrow
05:46:15 <ivanm> @hoogle arrow
05:46:16 <lambdabot> module Control.Arrow
05:46:16 <lambdabot> Control.Arrow class Category a => Arrow a
05:46:16 <lambdabot> Control.Arrow class Arrow a => ArrowApply a
05:46:27 <ivanm> @hoogle+ a -> [a] -> [a]
05:46:28 <lambdabot> Control.Arrow class Arrow a => ArrowChoice a
05:46:28 <lambdabot> Control.Arrow class Arrow a => ArrowLoop a
05:46:28 <lambdabot> Control.Arrow newtype ArrowApply a => ArrowMonad a b
05:46:34 <ivanm> @hoogle a -> [a] -> [a]
05:46:34 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
05:46:35 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
05:46:35 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
05:46:43 <ivanm> oh, wait...
05:46:44 <ivanm> @hoogle+
05:46:45 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
05:46:45 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
05:46:45 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
05:46:57 <ivanm> that's just what @mroe does for other things, isn't it?
05:46:58 <ivanm> @more
05:47:36 <alpounet> likely yes
05:49:18 <ivanm> anyone here on the libraries mailing list?
05:49:28 <ivanm> (since I'm not and thus can't post to it)
05:53:27 <ivanm> preflex: seen Igloo
05:53:27 <preflex>  Igloo was last seen on #ghc 8 minutes and 20 seconds ago, saying: The bus takes roughly as long as train to, across and from London. Although it is cheaper, but less comfortable
05:54:05 <aavogt> ivanm: it's quite easy to subscribe
05:54:37 <ivanm> aavogt: I don't want to; I waste too much time as it is reading and replying to -cafe messages ;-)
05:55:05 <aavogt> oh, it's much less traffic than -cafe@
06:00:19 <Liskni_si> usually I just disable the mail delivery in mailman options, so that I can post, but receive no mail, and if I ever want to read it, I use gmane.
06:01:55 * hackagebot CSPM-CoreLanguage 0.1.0.2 - Definition of a FDR-compatible CSP core-language.  http://hackage.haskell.org/package/CSPM-CoreLanguage-0.1.0.2 (MarcFontaine)
06:02:56 * hackagebot CSPM-FiringRules 0.1.0.0 - Firing rules semantic of CSPM  http://hackage.haskell.org/package/CSPM-FiringRules-0.1.0.0 (MarcFontaine)
06:07:57 * hackagebot CSPM-Interpreter 0.2.0.0 - An interpreter for CSPM  http://hackage.haskell.org/package/CSPM-Interpreter-0.2.0.0 (MarcFontaine)
06:12:50 <jan247> hi guys. still trying to learn haskell, and i'm wondering how database access goes.. wherein, say i only do a select if some condition holds... how do i separate my functional code with the ones doing IO.
06:12:58 * hackagebot CSPM-cspm 0.1.0.0 - cspm command line tool for analyzing CSPM specifications.  http://hackage.haskell.org/package/CSPM-cspm-0.1.0.0 (MarcFontaine)
06:13:39 <jan247> something like if (select count(1)...) return 1; else if (select count(1)...) return 2; else return 3;..
06:13:54 <mail> my professor is so gay
06:13:56 <jan247> how do i avoid doing the second select if i'm doing functional programming..
06:14:13 <mail> he deducted marks because i used x and y as variable names
06:14:16 <quicksilver> jan247: your database access will be in the IO monad anyway
06:14:36 <jan247> so i can do the second select lazily?
06:15:00 <quicksilver> jan247: it looks something like this : do foo <- select1; if foo then return 1 else do bar <- select 2; if bar then return 2 else return 3
06:15:06 <fax> mail: that's not what gay means
06:15:07 <fax> mail: you should definitely complain to him though
06:15:15 <fax> mail: it's not natural in haskell to call everything by huge long 'descriptive' names
06:15:17 <quicksilver> fax++
06:15:56 <ivanm> I beg to differ
06:15:58 <quicksilver> jan247: I would be careful about using the word 'lazy' for this, but yes you certainly can do the second select only if the first fails (or returns 0, whatever)
06:16:12 <ivanm> if you have something like: transform :: Image -> Image, does it make sense to call your variable "x"?
06:16:22 <mail> he basically deducted a mark because i used x to denote a function instead of a variable
06:16:34 <mail> s/variable/f
06:17:06 <edwardk> mail: ok, for a function named 'x' you got what you deserved. ;)
06:17:26 <mail> it wasn't name x
06:17:55 <jan247> quicksilver: does that mean that my entire code has to be in a monad?
06:18:14 <quicksilver> no
06:18:28 <quicksilver> jan247: no, just the part that strings together the top-level flow.
06:18:38 <ivanm> mail: :o
06:20:42 <jan247> quicksilver: thanks. guess better read more about monads :)
06:21:07 <quicksilver> there is a lot to read, it's not necessarily helpful.
06:21:24 <quicksilver> they're not as hard as you probably think, and some of the tutorials make them seem harder.
06:22:41 <jan247> quicksilver: hehe, thanks for the tip
06:23:08 <jan247> i'm coming from an erlang background.. and was hoping for something more strict.. and pure..
06:23:35 <pozic> jan247: heh, nice use of the word strict there ;)
06:27:17 <tumult> nooo don't read about monads, just make one
06:27:22 <tumult> much better way to learn
06:29:13 <sioraiocht> lol
06:29:24 <sioraiocht> tumult: I think just USING one is a good start
06:29:32 <jan247> hehe, really? how so?
06:30:02 <jan247> i'm reading through the real world haskell book available online.. i'm just about to start the part about IO
06:30:10 <tumult> well, it just seems sort of like magic until you have to go through the process to understanding it completely yourself
06:30:14 <jan247> monads.. for some reason.. are chapters ahead
06:30:16 <sioraiocht> yeah
06:30:18 <akosch> jan247: hey, me too :)
06:30:19 <sioraiocht> they should be
06:30:26 <akosch> it's a nice book
06:30:35 <sioraiocht> for IO, monads can just be considered a nice syntax, in the beginning
06:31:03 <tumult> chapter 10 in realworldhaskell is where you implement your own monad
06:31:29 <tumult> (not the one labeled monads!)
06:31:33 <jan247> akosch: it seems so. :) how far ahead are you?
06:31:35 <tumult> spoiler :)
06:31:46 <jan247> haha, but thanks for the info guys
06:32:02 <pastorn> @type on
06:32:03 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:32:09 <akosch> jan247: chap 8, so not much ahead :)
06:32:12 <pastorn> ^^ give me one good use of this...
06:32:40 <quicksilver> > sortBy (compare `on` snd) [(1,5),(2,3),(3,1)]
06:32:41 <lambdabot>   [(3,1),(2,3),(1,5)]
06:33:06 <akosch> jan247: I usually end up trying every new concept on project euler problems...
06:33:22 <pastorn> quicksilver: nice!
06:33:48 <pastorn> i figured it should be used in infix form in some way, but i didn't figure out how...
06:34:14 <pastorn> quicksilver: do you know of any other uses, or is sortBy the extent of on's uses?
06:35:08 <jan247> akosch: hehe, i'll try that
06:35:55 <quicksilver> pastorn: well, the other 'By' functions which take binary operators.
06:36:09 <akosch> jan247: one thing i would like to mention about that book: it avoids compiling your programs for a long time and depends on using ghci
06:36:20 <pastorn> quicksilver: hehe :)
06:36:24 <edwardk> pastorn: i use 'on' quite a bit.
06:36:39 <pastorn> edwardk: example?
06:36:55 <akosch> jan247: while solving project euler problems i ended up with my programs using hundreds of MBs of memory
06:37:09 <quicksilver> > foldr1 ((*) `on` length) ["a","bc","def"]
06:37:10 <lambdabot>   Couldn't match expected type `[a]'
06:37:11 <lambdabot>         against inferred type `GHC.Types...
06:37:13 <quicksilver> :(
06:37:25 <quicksilver> foldr1 isn't quite as polymorphic as I needed.
06:37:27 <akosch> jan247: because ghci ":load" doesn't run optimisations
06:37:42 <pastorn> @type ((*) `on` length)
06:37:43 <lambdabot> forall a. [a] -> [a] -> Int
06:37:45 <edwardk> pastorn: (+) `on` getSum, (*) `on` length, (&&) `on` predicate, etc.
06:37:47 <jan247> akosch: i find that a good thing though.. i tend to experiment a lot on the ghci before writing it to some file.
06:37:57 <jan247> akosch: oh wait.. it doesn't? hehe..
06:38:18 <edwardk> @type ((&&)`on`)
06:38:20 <lambdabot> forall a. (a -> Bool) -> a -> a -> Bool
06:38:23 <akosch> jan247: yeah, ghci is very nice for experimenting, but be careful :)
06:38:26 <pastorn> edwardk: that last one... hmmm
06:38:40 <pastorn> @type (&&) `on` isDigit
06:38:41 <lambdabot> Char -> Char -> Bool
06:38:48 <jan247> on a related note.. in haskell.. i was wondering if there are any facilities for doing live upgrade of code?
06:39:00 <edwardk> pastorn: true if both chars are digits
06:39:03 <EvanR-work> haskell plugins?
06:39:11 <akosch> jan247: just insert a "main = print myfunc" line in your program
06:39:18 <pastorn> edwardk, quicksilver: nice!
06:39:24 <akosch> jan247: and write your code in myfunc
06:39:35 <pastorn> i'll try to remember this :)
06:39:49 <pastorn> onM might be useful as well :)
06:40:03 <akosch> jan247: compile with "ghc -O2 --make filename.hs"
06:40:21 <edwardk> i think i even have an On combinator in category-extras at the type level. newtype On f g a b = On (f (g a) (g b))
06:41:02 <edwardk> @type liftA2 . on
06:41:03 <lambdabot> forall b (f :: * -> *) b1 c. (Applicative f) => (b1 -> b1 -> c) -> f (b -> b1) -> f b -> f (b -> c)
06:41:13 <jan247> akosch: and that's supposed to change a currently running program? i'm not sure i follow..
06:41:25 <edwardk> oh, hah, missed an arg
06:41:40 <edwardk> @type (\a b -> liftA2 (on a b))
06:41:41 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => (b -> b -> c) -> (a -> b) -> f a -> f a -> f c
06:42:12 <akosch> jan247: if you load your program with ghci via ":load" it's going to be a lot slower
06:42:17 <edwardk> meh
06:43:03 <akosch> jan247: -O2 in ghc adds a lot of optimisations
06:43:57 <jan247> akosch: i see. i'm trying to find a good use case for haskell. desktop apps seem to be a good place for it, wherein not much needs to change. but for server apps, where i'd need continuous uptimes even in the face of upgrades.. i'm not sure if it'll be any good..
06:45:47 <akosch> jan247: i don't think upgrading compiled code should be any issue on a server
06:46:58 <lyndon__> Is there a nice way to get the implementation for a specific function besides digging through the source? (was just trying to look up >>= for Either.
06:47:44 <Saizan> the haddock docs have a source link
06:47:47 <jan247> akosch: thanks, i'll try to look into how it should go. but generally though, when's haskell the best tool for the job?
06:48:01 <ivanm> @src (Either e) (>>=)
06:48:01 <lambdabot> Source not found. :(
06:48:03 <ivanm> humph
06:48:38 <danharaj> jan247: When development time and correctness are a priority over run-time performance.
06:48:43 <akosch> jan247: i only meant that running your programs via ghci (like it's suggested in the first part of the book) isn't optimal
06:49:22 <akosch> jan247: sometimes it's even unacceptable
06:49:24 <quicksilver> akosch: running your programs via ghci is optimal in many cases.
06:50:03 <quicksilver> jan247: really, only erlang offers live code updates and most servers are, in fact, not written in erlang :)
06:50:05 <jan247> danharaj: i'm under the impression though that ghc though is quite fast, especially compared to dynamically typed ones..
06:50:23 <quicksilver> jan247: it's perfectly possible to hand off file descriptors and re-exec yourself.
06:50:25 <akosch> jan247: yes, i only wanted to remind him of the caveat of running everything in ghci vial ":load"
06:50:41 <quicksilver> jan247: (or have a separate management process handling the connections)
06:51:07 <quicksilver> jan247: having said all that, you would enjoy reading about hs-plugins and dyre and the ghc-api.
06:51:10 <danharaj> jan247: It is impressively fast, but its memory consumption and speed compared to c/c++ is unacceptable in applications where speed is of critical importance, at least for now.
06:52:01 <danharaj> jan247: It's also harder to reason about the performance of haskell programs because you have to figure out how lazy evaluation is affecting things, which takes a reasonable amount of skill and experience.
06:52:07 <akosch> danharaj: it's still faster than some scripting languages ;)
06:52:26 <danharaj> akosch: But it's competing with compiled languages :p
06:53:26 <jan247> danharaj: yep, the lazy evaluation scares me a bit. i love that haskell does it, which leads to more readable code, but performance is indeed harder to gauge
06:54:51 <akosch> danharaj: i think haskell also competes with scripting languages in terms of expressiveness
06:55:06 <pozic> jan247: GHC compared to Python is an order of magnitude faster, if not more for a lot of things.
06:56:17 <pozic> In Python you write something and at run-time the run-time system has to figure out what you meant. In Haskell it already knows exactly what to do (modulo laziness).
06:57:06 <pozic> If you want a really "fast" system, you use something which can express semantics exactly, something which is built on top of linear types.
06:57:20 <tumult> unless you are using pypy/rpython and not all of the language features :)
06:57:28 <jan247> in any case. thanks guys for the tips. i was hoping to do an iphone app in haskell.. but alas.. it seems impossible now..
06:57:37 <Axman6> jan247: laziness is definitely the default, but it's not forced on you
06:57:42 <ivanm> hey Axman6
06:57:46 <pozic> jan247: people already have done that, AFAIK.
06:57:47 <Axman6> 'lo
06:58:04 <pozic> jan247: so, according to your logic, they already did the impossible.
06:58:07 <Axman6> there's at least one app in the app store written in haskell.
06:58:13 <jan247> pozic: yeah, but you can't publish it.. hehe
06:58:23 <ivanm> Axman6: ben released a bmp library today as well as a new version of gloss; I was hoping that this meant gloss could now export images but it appears my hopes were unfounded :(
06:58:31 <pozic> jan247: sure you can, you just cannot put it in the store.
06:58:37 <ivanm> Axman6: eh, that app will be going soon thanks to that new clause in the developer agreement
06:58:38 <Axman6> ivanm: shame
06:58:48 <jan247> pozic: hehe, guess you're right there. :)
06:58:51 <pozic> jan247: also developing for a crazy platform is ill-advised.
07:00:22 <tumult> you can put it in the store
07:00:28 <tumult> apple does not care if you use haskell to make an iphone app
07:00:32 <quicksilver> it might go, it might not go
07:00:43 <tumult> if it gets rejected it would not be because of haskell
07:00:46 <quicksilver> apple's developer agreement can be summed up in one simple sentence.
07:00:55 <quicksilver> "Everything you do, is belong to us"
07:01:05 <ivanm> tumult: huh? I thought they just made it so that you had to use XCode and develop with C, C++ or Obj-C
07:01:06 <fax> ^ exactly
07:01:06 <tumult> no, more like, beholden to us
07:01:12 <quicksilver> ivanm: yes, they di
07:01:15 <fax> computers vs people
07:01:16 <tumult> it does not belong to them
07:01:17 <fax> not a good sign
07:01:18 <quicksilver> ivanm: but it's up to them to enforce
07:01:20 <tumult> it says that in its agreement yes
07:01:24 <ivanm> quicksilver: true
07:01:25 <fax> they're hard enough to use already
07:01:31 <tumult> but it's also a clause that is impossible to enforce, and would not stand up in court
07:01:37 <tumult> EULAs like that are routinely struck down
07:01:37 <quicksilver> ivanm: it says all kinds of shit in the agreement which is sporadically, but not consistently enforced
07:01:50 <tumult> they reserve the right to reject any app at their whim regardless
07:01:51 <quicksilver> ivanm: and furthermore there is a blanket clause which basically says "we can reject for any reason"
07:01:57 <quicksilver> so, really, it's a crapshoot
07:01:59 <tumult> if that is a problem for you then do not develop for the platform
07:02:11 <akosch> buy android :)
07:02:18 <tumult> it's their deal, the iphone sold well before 3rd party apps and would still sell well without it
07:02:35 <quicksilver> I certainly wouldn't bet much real money on a business proposition based on selling iPhone apps written in haskell
07:02:38 <tumult> i've used haskell to develop iphone apps and it's fine
07:02:43 <quicksilver> but I wouldn't bet against it either, you might be fine :)
07:02:44 <ivanm> quicksilver: true
07:02:45 <tumult> and made real money
07:03:22 <tumult> android is terribly slow and you cannot make android api calls from native code
07:03:29 <tumult> so haskell is not going to work on it anytime soon
07:04:00 <fax> but I think there is an investigation into apple now
07:04:02 <tumult> scala and clojure run horribly bad on it, the dalvik vm's allocator is nowhere on par with the normal JVM's allocator, which scala and clojure are design to comply with
07:04:06 <fax> 'antitrust' which I'd never heard of
07:04:17 <tumult> it won't go anywhere
07:04:53 <tumult> it's hot hair from SEC, an impotent regulation body in the USA that attempts to make itself look relevant by 'investigating' things that appear as hot news items
07:05:03 <fax> ahh interestin
07:05:04 <pozic> Apple will simply implement whatever is popular to their OS after you figured out something creative.
07:05:14 <tumult> instead of investigating things it should actually be paying attention to, like rampant banking fraud throughout wall street
07:05:16 <pozic> The same thing MS did in the '90s
07:05:27 <tumult> instead of small-time companies in the technology sector operating within the law, like apple
07:05:29 <pozic> tumult: ++
07:05:38 <quicksilver> investigating banking fraud is much too dangerous
07:05:47 <quicksilver> there are very powerful people who don't want that to happen :-.
07:05:48 <fax> banking fraud ?
07:05:57 <pozic> quicksilver: heh, yes, you can get killed for that. See JFK.
07:06:03 <fax> yeah I think quicksilver hit it on the head
07:06:31 <pozic> We need a financial investigator with an exoskeleton.
07:06:33 <pozic> :)
07:06:40 <tumult> ironman
07:06:42 <pastorn> anyone have this? http://www.amazon.com/Algorithms-Functional-Programming-Approach-International/dp/0201596040/ref=pd_sim_b_76
07:06:47 <fax> I always thought it was funny how if you totalled up the money everyone has in the bank... the bank doesn't actually have that much money
07:06:57 <pastorn> http://tinyurl.com/34bgakg
07:07:00 <fax> so e.g. if everyone withdrew all their money at once -- the building woudl just collapse
07:07:07 <pastorn> is it a good book?
07:07:15 <fax> pastorn: I don't like it one bit
07:07:24 <dv-> fax: unless it was too big to fail
07:07:48 <fax> dv- huh? bigger just means it will make a louder sound when the roof comes tumbling down
07:07:50 <quicksilver> pastorn: I'd never heard of it and the only review I see on amazon isn't promising...
07:08:03 <pastorn> fax: why? what does it do wrong?
07:08:32 <edwardk> pastorn: never heard of it
07:08:43 <fax> nothing 'wrong' exactly but nothing especially right..
07:08:55 <fax> it's just a really simple book that didn't tell me anything exciting
07:08:59 <benmachine> fax: the building would collapse? do they use your coins as structural support >_>
07:09:16 <fax> it's probably a good refence if you just want to know what a "stack" (or whatever) is
07:09:16 <pastorn> fax: doesn't it teach dynamic programming?
07:09:18 <cocon> how come when one does 'cabal install parsec' or '... QuickCheck' it doesn't go for the latest version?
07:09:21 <dv-> fax: the US people are paying $21 trillion for too big to fail businesses to go on
07:09:26 <edwardk> if you want a functional algorithms/data structures book, pick up okasaki
07:09:44 <fax> yeah there is a book which will pull your brain through a wormhole backwards
07:09:45 <benmachine> cocon: because people are bad at specifying dependencies so a major upgrade to those packages broke stuff
07:09:50 <pastorn> edwardk: yeah, but that doesn't have any dynamic programming in it :(
07:09:56 <benmachine> cocon: you can ask for the latest version specifically - parsec-3.1
07:10:00 <byorgey> cocon: those particular packages have special exceptions built into cabal, since many packages require an older version of those but don't specify it
07:10:05 <edwardk> pastorn: then read the stuffon the internet by varmo vene ;)
07:10:17 <fax> pastorn yeah if you want to know dynamic programming probably a fine book but there are also functional pearls and other stuff you can get online
07:10:22 <pozic> pastorn: I believe it was said already that only a few pages are useful. If you want to pay $50 per page... go ahead.
07:10:42 <edwardk> pastorn: though, if you thought okasaki was going to suck your brain through a wormhole...
07:10:51 <fax> :D
07:10:56 <pastorn> edwardk: which stuff? http://www.cs.ut.ee/~varmo/
07:10:57 <cocon> byorgey: thanks -- is that hard-wired?
07:11:00 <pastorn> quite a lot...
07:11:01 <dcoutts> byorgey, cocon: it's sort-of built in, it's specified in a set of "preferred-versions" on hackage.
07:11:11 <edwardk> pastorn: google for dynamorphism
07:11:18 <pozic> Compared to 'Concrete Mathematics' Okasaki's stuff is trivial.
07:11:24 <cocon> dcoutts: where can this be viewed? are there others?
07:11:28 <fax> you gotta be kidding me
07:11:28 <pastorn> medical-dictionary.thefreedictionary.com/dysmorphism
07:11:31 <edwardk> pastorn: which is a rigorous approach to dynamic programming as a recursion scheme
07:12:00 <dcoutts> byorgey, cocon: the intention is for package maintainers to indicate which is the "recommended" version, eg to let them release experimental major new versions without breaking everything. It's not yet well integrated into the hackage web UI.
07:12:03 <edwardk> dyna and g_dyna are available in category extras if you really want to sneak a peak ;)
07:12:21 <pastorn> i downloaded okasaki.pd
07:12:22 <cocon> dcoutts: thanks
07:12:22 <pastorn> f
07:12:34 <cocon> pozic: what's "concrete mathematics"?
07:12:34 <pastorn> i'll start reading that once i'm done with my CG hand in...
07:12:37 <dcoutts> cocon: http://hackage.haskell.org/packages/archive/preferred-versions
07:12:47 <pozic> cocon: try google.
07:12:56 <pozic> cocon: or amazon.
07:13:06 <byorgey> dcoutts: ah, that makes sense.
07:13:08 <fax> cocon, discrete math textbook (very funny marginal notes)
07:13:16 <cocon> oh
07:13:38 <fax> (it's completely uncomparable with osakasi .. not sure why it's been mentioned)
07:13:39 <cocon> no fp book though, right? I thought so because you compared it to Okasaki
07:13:45 <cocon> haha, yes
07:13:56 <byorgey> it is an excellent book though =)
07:13:58 <fax> don't get me wrong, this is a _great_ book
07:14:00 <fax> yeah
07:14:22 <pozic> It is comparable because every book has with it an associated difficulty.
07:14:52 <cocon> to be sure, you're talking about the one that knuth co-authored, right?
07:15:07 <pastorn> www.cs.cmu.edu/~rwh/theses/okasaki.pdf
07:15:18 <pastorn> that's kind of cool :)
07:15:35 <pozic> cocon: yes.
07:15:52 <pastorn> speaking of knuth; when was he going to have that surprise thing?
07:16:04 <pozic> pastorn: in a few months, IIRC.
07:16:10 <edwardk> pastorn: iirc the book is an elaborated version of the material he found when writing his thesis
07:16:24 <cocon> surprise?
07:16:36 <pozic> Data structure books are only useful when there is no implementation available of what you want.
07:17:10 <edwardk> plus the book contains the Haskell implementation as well ;)
07:17:25 <edwardk> bbiab
07:19:23 <fax> :S
07:21:03 <pastorn> hmm... the pdf is 162 pages, the book is 184 + 22 pages haskell code
07:21:15 <pastorn> is it worth buying the book for that (i'm piss poor)
07:21:16 <dschoepe> building bindings-gpgme fails because of the supposedly missing header gpgme.h even though that file is present under /usr/include/. It also happens when I specify this directory with --extra-include-dirs. I'm running debian unstable if that matters. Any ideas?
07:21:50 <pastorn> (buying the book ==> noodles for a whole month)
07:22:04 <fax> lol
07:22:18 <pastorn> fax: would you do it?
07:22:22 <fax> just use the PDF... and see if iyou can get into a university library
07:22:27 <fax> they have lots of books
07:22:33 <pastorn> true
07:22:36 <pastorn> i should check that :)
07:22:41 <fax> (on technical stuff like computering... which normal library don't have)
07:22:41 <pastorn> fax: thank you for being clever
07:27:44 <alpounet> ah, c.h.o seems to be down again
07:32:12 <pastorn> awesome title: http://www.eecs.usma.edu/webs/people/okasaki/jfp98.ps
07:33:30 <Zao> For us people who are happily without PS interpreters, what does it say?
07:33:47 <Zao> All I can find in the source is %%Title: sixth.dvi
07:34:10 <fax> how can you live without postscript?!
07:34:24 * hackagebot wai-handler-fastcgi 0.0.0 - WAI wrapper around direct-fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.0.0 (MichaelSnoyman)
07:34:36 <Axman6> no one uses postscript
07:34:50 <Zao> Only crufty old academics use PS as a distribution format.
07:34:53 <pastorn> Zao: "Even Higher-Order Functions for Parsing; or; Why Would Anyone Ever Want To Usa a Sixth-Order Function?"
07:35:07 <Zao> Sounds like fun.
07:35:08 <Axman6> pdf's where it's at
07:35:17 <pastorn> Axman6: ps2pdf
07:35:19 <pastorn> awesome program
07:35:29 <pastorn> i can run it on the paper and put it somewhere... hang on
07:35:35 <Axman6> i know it exists, but still, who uses postscript
07:35:43 <pastorn> Axman6: stop sucking :p
07:36:19 <akosch> i get "Stack space overflow: current size 8388608 bytes. Use `+RTS -Ksize -RTS' to increase it." from ghc
07:36:25 <fax> wtff
07:36:31 <pastorn> http://web.student.chalmers.se/~goranssa/jfp98.pdf
07:36:48 <Axman6> akosch: you're doing something wrong then. what's the code?
07:37:22 <akosch> i know this should be solveable with the standard stack size
07:37:43 <akosch> i'm doing project euler problem 258 with brute force :)
07:37:59 <pastorn> Axman6: the fonts look like shit :(
07:38:30 <Axman6> brute force and good space usage don't tend to go well together
07:39:00 <akosch> http://pastebin.com/deUQZEqC
07:39:38 <akosch> this is the code, i already solved this problem, but want to try it with brute force
07:41:01 <akosch> Axman6: yeah, my problem is that stack size won't increase
07:41:02 <Axman6> akosch: yeah that's absolutely horrible for stack usage
07:41:18 <akosch> Axman6: i know, i'm just experimenting :)
07:41:38 <Axman6> if you can make it tail recursive, you'll be on your way to making it work
07:42:18 <Axman6> not sure how you'd do that though
07:42:35 <Axman6> actually, memoising it might help quite a lot
07:42:47 <Axman6> maybeh
07:42:57 <akosch> well, ok... just out of curiousity: how could i increase the stack size? +RTS -K50M -RTS doesn't seem to work
07:43:10 <akosch> still stuck @ 8M
07:43:47 <Saizan> that should work, you are passing it to the produced executable, right?
07:44:06 <akosch> yeah, i'll try again just to make sure...
07:45:27 <akosch> now it works, must be my error...
07:49:10 <akosch> ok, now i'm officially out of memory :)
07:55:55 <iaefai> Does anyone know if the 'haskell-cafe' group (http://groups.google.com/group/haskell-cafe) is meant to allow a subscriber to post to the real mailing list without joining on the haskell site?
07:56:22 <mercury^> What's the unreal mailing list?
07:56:33 <Zao> Joining on what site?
07:56:43 <Zao> Subscribing to the list proper, or to Google's fake group interface/
07:56:55 <iaefai> Zao, the latter
07:57:10 <quicksilver> iaefai: I very much doubt it
07:57:18 <Zao> I can't see what some random frontend would have to do with the mailing list proper.
07:57:27 <quicksilver> but you can subscribe without receiving emails if you wish
07:58:33 <fasta> Haskell-cafe traffic seems to explode lately.
07:58:59 <iaefai> quicksilver: just did that :p
07:59:55 <fasta> It would be nice if someone would write a programmable mail-client with xmonad's architecture.
08:00:51 <iaefai> Zao: The unfortunate part is that I don't see anything on the front end that says you have to subscribe normally. I know enough, after receiving a rejection of a post, where to subscribe, but not everyone would.
08:01:13 <iaefai> fasta: I would like to be able to make nice mac applications in haskell :-)
08:01:21 <Zao> Google "haskell-cafe", http://www.haskell.org/mailman/listinfo/haskell-cafe http://www.haskell.org/haskellwiki/Mailing_lists
08:01:32 <Zao> iaefai: So complain to Google Groups.
08:01:47 <Zao> I wouldn't expect anything else from an organization that wants to rule the world though.
08:02:05 <fasta> iaefai, what is the point of making applications that don't run everywhere?
08:02:42 <fasta> iaefai, and you can already do that, btw.
08:03:07 <iaefai> fasta: If you try to make an application that can run everywhere, you either get a terminal interface (good luck on windows) or you get crap like java. I won't even talk about how out of place these kinds of apps are.
08:03:18 <iaefai> fasta: AFAIK, the cocoa binding isn't complete
08:03:33 <fasta> iaefai, all this "out of place" stuff is irrelevant for most real-world applications.
08:03:41 <tensorpudding> You can use a cross-platform language with a cross-platform widget library.
08:04:00 <iaefai> tensorpudding: most of those look like crap, wxWindows included.
08:04:06 <tensorpudding> Though inevitably they'll look ugly.
08:04:07 <fasta> iaefai, if you write something which works for a particular application and there is nothing else that does the same thing, people will use it.
08:04:20 <fasta> iaefai, making things pretty is something which is overhyped.
08:05:14 <iaefai> fasta: I would disagree with that. With the interface builder and a newer add on library you can make very nice looking apps that look like proper modern mac apps that behave properly.
08:05:24 <tensorpudding> Native toolkits are not to be denied their benefits.
08:05:32 <fasta> iaefai, and I am pretty sure you can expose everything you need to Haskell if you are skilled in both Mac and Haskell.
08:06:03 <fasta> iaefai, with the "interface builder" you cannot build programmable components.
08:06:21 <dhouthoo> iaefai: is the haskell object C binding not sufficient?
08:06:22 <tumult> you can now
08:06:22 <jmcarthur> huh?
08:06:24 <fasta> iaefai, or at least, not with any of the RAD tools I have used.
08:06:38 <tumult> interface builder lets you hook into core data, which is an sqlite frontend
08:06:47 <tensorpudding> It's not just about making apps that look nice, but apps that look normal.
08:06:53 <tumult> you can 'implement' an application without writing any code
08:07:02 <fasta> tumult, that's not what I meant.
08:07:08 <iaefai> tensorpudding: yes that is exactly it
08:07:34 <fasta> tumult, I mean things like showing X canvas objects below each other, with X only known at run-time.
08:07:35 <tensorpudding> That's vaguely more useful on a platform where native apps have a standardized look and feel, like OSX and GNOME.
08:07:48 <iaefai> What is the name of the objective c binding?
08:07:58 <dhouthoo> http://code.google.com/p/hoc/
08:08:01 <EvanR-work> the native look and feel is a poor goal of user interfaces
08:08:19 <EvanR-work> using a computer isnt an emotional experience
08:08:21 <fasta> A good GUI is just a GUI that works with you, instead of against you.
08:08:22 <tumult> by the way about the objective-c binding, you don't have to use it to write cocoa
08:08:29 <tumult> in haskell, i mean
08:08:39 <fasta> Take for example the XChat-gnome application.
08:08:42 <tumult> since objective-c is mostly just a small preprocessor and runtime in front of C
08:08:54 <iaefai> last commit is sep 27, is it still being developed?
08:08:57 <fasta> You cannot configure everything in that application.
08:09:02 <tumult> you can just objc_msgSend which is a c function
08:09:06 <fasta> So, it looks like Gnome, but it is not done ^^
08:09:28 <fasta> Most GUIs are never "done".
08:09:34 <EvanR-work> xchat is a good example of the many (free and otherwise) windows apps that dont look like windows apps
08:09:40 <ManateeLazyCat> fasta: Really?
08:09:40 <EvanR-work> that people accept
08:09:49 <dhouthoo> iaefai: no idea, just found it, never used it
08:09:59 <fasta> ManateeLazyCat, yes, you have to use xchat to configure for example the proxy.
08:10:04 <tensorpudding> Windows is somewhat unique.
08:10:16 <iaefai> fasta: an app can look functional, such as http://mac.softpedia.com/screenshots/X-Chat-Aqua_1.png  but it doesn't fit in and probably has a few gotchas for people expecting a native app.
08:10:16 <tumult> objective-c can be interacted with directly from C, it's not like C++
08:10:21 <fasta> ManateeLazyCat, or to auto send identification information.
08:10:33 <tensorpudding> The default install of Windows on an OEM machine will have a large quantity of un-native, specialized shovelware apps on it.
08:10:35 <tumult> so you do not need any special sauce if you want to use haskell with cocoa
08:10:36 <ManateeLazyCat> fasta: I think that's a design problem.
08:10:38 <EvanR-work> and a uniform look and feel on linux is a joke, so were basically talking about osx. which i discount completely anyway
08:10:44 <ManateeLazyCat> fasta: You can build GUIs like Emacs.
08:10:51 <ManateeLazyCat> fasta: Configuration everything.
08:10:53 <tensorpudding> And for some reason, people really like this.
08:10:54 <iaefai> tumult: The masochist could probably work up something if they know the ABI :p
08:11:03 <fasta> ManateeLazyCat, ?
08:11:07 <ManateeLazyCat> fasta: Most Gnome GUIs (or Most GUIs) is design for mouse.
08:11:21 <fasta> ManateeLazyCat, yes, and what does this have to do with what I said?
08:11:23 <tensorpudding> The people who think that it is ugly, sometimes buy a Mac, and they are happy with how unified it is in comparison.
08:11:24 <iaefai> EvanR-work: Why discount it?
08:11:26 <ManateeLazyCat> fasta: You need use mouse to finish most job.
08:11:47 <EvanR-work> iaefai: theres no reasoning with apply users, im half serious, ignore me
08:11:50 <EvanR-work> apple*
08:11:51 * ManateeLazyCat Damn it, code.haskell.org down.
08:11:51 <ManateeLazyCat> again.
08:11:58 <fasta> I like Linux because it doesn't say a "new version of worthless application" is available.
08:12:11 <fasta> That has nothing to do with its technical properties.
08:12:17 <EvanR-work> fasta: ubuntu does ;)
08:12:22 <fasta> (which I believe Windows is still ahead in)
08:12:27 <fasta> EvanR-work, not if you disable it.
08:12:32 <twink> I like Linux because I was "raised on" UNIX wrt. computers and just completely refuse to adapt or whatever.
08:12:33 <fasta> EvanR: which is what I did :)
08:12:37 <EvanR-work> you can disable it in windows
08:12:40 <iaefai> EvanR-work: If you refer to 'apple fanboys', then I can half agree :p I just like uniformity of function - which even the mac has issues with - just look at microsoft office and adobe CS
08:12:49 <fasta> EvanR-work, but you have to disable it for every applicaiton.
08:12:52 <fasta> application*
08:13:04 <fasta> And there are no useful dev tools on Windows by default, and so on.
08:13:14 <EvanR-work> default shefault
08:13:25 <fasta> It just takes too long to setup usefully.
08:14:06 <tensorpudding> The only way that Apple could make non-Apple OSX apps look unified would be to retroactive lock down the platform.
08:14:11 * ManateeLazyCat code.haskell.org make me crazy that i can't push patches.
08:14:15 <fasta> That said, I do have it setup, but I would not use it personally anymore.
08:14:29 <iaefai> tensorpudding: you never know what they will do...
08:14:34 <tensorpudding> Either that or make app store that arbitrarily blocks apps based on look and feel.
08:14:49 <EvanR-work> sounds like an apply plan to me
08:14:55 <EvanR-work> aPPLE
08:15:46 <EvanR-work> native look and feel is a delusional ideal, gamers dont demand that their game guis look like windows explorer / finder
08:15:59 <EvanR-work> but they want everything else to? preposterous
08:16:24 <tensorpudding> The argument that "users don't want X because X isn't available" is a silly argument.
08:16:44 <iaefai> EvanR-work: When you want to get work done, a consistent L&R is ideal. Games are not about getting work done.
08:16:46 <EvanR-work> i argue that people dont know what they want
08:16:54 <EvanR-work> but say they do
08:16:57 <fasta> tensorpudding, it doesn't matter what they want. It depends on what they want to pay for.
08:17:03 <zurk> I've got a silly stats question, and I wondering if anyone here might be able to help me out
08:17:10 <fasta> zurk, #math
08:17:17 <EvanR-work> iaefai: a game with a bad gui is unplayable
08:17:19 <iaefai> zurk, that is asking to ask, not good on irc
08:17:21 <zurk> fasta: gracias!
08:17:32 <iaefai> EvanR-work: sure it is, but you weren't talking about bad guis
08:17:34 <ManateeLazyCat> dcolish: Have you convert gtk2hs darcs to hashed-format?
08:17:43 <zurk> is there any formula to convert a z-score to a percent?
08:17:43 <tensorpudding> Games are different.
08:17:54 <tensorpudding> Games are multimedia, and large studio productions.
08:17:57 <ManateeLazyCat> dcolish: Sorry, is dcoutts
08:18:05 <ManateeLazyCat> dcoutts: Have you convert gtk2hs darcs to hashed-format?
08:18:22 <EvanR-work> if native look and feel was so important, why did microsoft release office 2007
08:18:27 <tensorpudding> People are used to films having different styles of opening and closing credits, they don't demand that they all adhere to a common format for consistency because it's irrelevant.
08:18:32 <EvanR-work> the epitome of productive software
08:18:36 <iaefai> Now you can have a game like solitaire where many elements should be consistent with the rest, even when they have a custom thing in the centre.
08:19:05 <iaefai> EvanR-work: Because microsoft was trying to create the next interface fashion.
08:19:27 <EvanR-work> so its not about productivity, its about feelings
08:19:55 <iaefai> EvanR-work: I think it is about both.
08:20:05 <iaefai> Perhaps more on feeling.
08:20:20 <fryguybob> There is native look and feel and there is looking the same as everything else.
08:20:29 <EvanR-work> ?
08:20:51 <quicksilver> native look and feel is a lie, even on the mac
08:20:58 <fryguybob> Office 2007 has native look and feel while not looking like everything else.
08:20:59 <quicksilver> apple always violate their own guidelines
08:21:13 <quicksilver> iTunes completely violated the apple UI guidelines
08:21:16 <quicksilver> so did aperture
08:21:39 <quicksilver> the much heralded UI consistency has never existed that much :)
08:21:54 <quicksilver> furthermore plenty of cocoa applications abuse the toolkit and have atrocious UIs
08:22:27 <dhouthoo> it's a matter of taste. If you like the cocoa toolkit and want to write an app with it, then having a haskell binding for it is a good thing
08:22:43 <EvanR-work> yes
08:23:07 <ManateeLazyCat> EvanR-work: gtk2hs is your want?
08:23:23 <EvanR-work> i like fltk2
08:23:39 * EvanR-work prepares for rotten fruit
08:28:40 <whald> is hPutBuf really the only way to write some bytes to a file?
08:28:53 <whald> s/file/handle
08:28:59 <EvanR-work> theres Data.ByteString
08:29:02 <quicksilver> whald: no.
08:29:27 <quicksilver> there is the badly named hPutStr
08:29:49 <quicksilver> and some better named functions in Data.Bytestring
08:31:15 <whald> ahhh! that's what i've been looking for, thanks quicksilver / EvanR-work
08:32:15 <jmcarthur> also cereal, binary, etc.
08:32:26 <jmcarthur> i think both use ByteString
08:32:54 <jmcarthur> ah, in fact they don't even do the IO i think
08:32:56 <jmcarthur> so nevermind
08:33:27 <jmcarthur> ah, binary will, but cereal won't
08:33:31 <whald> jmcarthur:  i already came across Data.Binary, but that is not really the thing i wanted as an instance of Binary requires me to implement both reading and writing as it seems
08:33:41 <jmcarthur> ah
08:34:06 <jmcarthur> well, you can still use it without instantiating it though
08:34:21 <jmcarthur> except for the IO i guess
08:39:30 <tomberek> jmcarthur: godd morning
08:40:24 <quicksilver> you can (and should) use Data.Binary without using the typeclass but it's not directly the answer to whald's question then.
08:40:44 <quicksilver> Data.Binary.Put is rather the answer to the question "How do I conveniently arrange some bytes into a ByteString?"
08:42:14 <fax> > cos(2*pi/7)
08:42:15 <lambdabot>   0.6234898018587336
08:42:36 <whald> @h frexp
08:42:36 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
08:42:43 <whald> @hoogle frexp
08:42:43 <lambdabot> No results found
08:42:52 <fax> > (1/6)*(((7+21*sqrt(-3))/2)**(1/3)+((7-21*sqrt(-3))/2)**(1/3)-1::Complex Double)
08:42:53 <lambdabot>   0.6234898018587336 :+ 0.0
08:51:06 <whald> huh, there's no frexp / frexpf in haskell and using the one provided by the cmath package causes an abort because of an "illegal instruction"
08:51:45 <EvanR-work> > exp 5
08:51:46 <lambdabot>   148.4131591025766
08:52:51 <whald> > frexp 5
08:52:52 <lambdabot>   Not in scope: `frexp'
08:53:51 <whald> > Foreign.C.Math.Double.frexp 5
08:53:52 <lambdabot>   Not in scope: `Foreign.C.Math.Double.frexp'
08:54:00 <whald> however
08:54:22 <benmachine> :t decodeFloat
08:54:23 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
08:55:22 <whald> benmachine: oh, thanks!
08:55:24 <EvanR-work> > properFraction 5
08:55:25 <lambdabot>   (5,0.0)
08:55:40 <fax> woah
08:55:51 <fax> is 0.0 a fraction
08:55:56 <fax> > properFraction pi
08:55:57 <lambdabot>   (3,0.14159265358979312)
08:57:17 <EvanR-work> > floatRange pi
08:57:18 <lambdabot>   (-1021,1024)
08:57:32 <EvanR-work> > decodeFloat pi
08:57:32 <lambdabot>   (7074237752028440,-51)
08:58:24 <fryguybob> > decodeFloat (0/0)
08:58:25 <lambdabot>   (-6755399441055744,972)
08:58:28 <benmachine> whald: don't know if it's exactly what you want but it's where I'd start
08:59:14 <fryguybob> > (uncurry encodeFloat . decodeFloat) (0/0)
08:59:16 <lambdabot>   -Infinity
08:59:22 <fryguybob> > 0/0
08:59:23 <lambdabot>   NaN
09:00:54 <EvanR-work> > realToFrac pi
09:00:55 <lambdabot>   3.141592653589793
09:01:26 <EvanR-work> > toRational pi
09:01:27 <lambdabot>   884279719003555 % 281474976710656
09:01:36 <EvanR-work> i knew it was not irrational
09:01:46 <Entroacceptor> :)
09:03:50 <fax> the TRUE value of pi has finally been found!
09:05:06 <burp> ha
09:05:21 <alpounet> > 884279719003555 / 281474976710656 :: CReal
09:05:22 <lambdabot>   3.1415926535897931159979634685441851615906
09:05:27 <burp> > pi :: CReal
09:05:29 <lambdabot>   3.1415926535897932384626433832795028841972
09:06:00 <whald> i thought pi=4 by law?
09:08:10 <mdmkolbe> Is there a good library that provides either (a) hash-consing or (b) an IntMap implementation with a fast union operation that takes advantage of hash-consing (e.g. union a set with itself should be O(1))?
09:10:28 <monochrom> Next we pursue the TRUE value of True.
09:11:01 <EvanR-work> > True
09:11:01 <lambdabot>   True
09:11:37 <EvanR-work> > True == True
09:11:37 <lambdabot>   True
09:11:40 <EvanR-work> :o
09:11:52 <Makoryu> :t compose
09:11:54 <lambdabot> Not in scope: `compose'
09:13:01 <Makoryu> @let compose = foldr id
09:13:03 <lambdabot>  Defined.
09:13:12 <mdmkolbe> :type compose
09:13:14 <mdmkolbe> @type compose
09:13:15 <lambdabot> forall b. b -> [b -> b] -> b
09:13:16 <quicksilver> mdmkolbe: I believe the answer is no.
09:13:27 <Makoryu> Hmmm
09:13:29 <Makoryu> :t compose id
09:13:31 <lambdabot> forall a. [(a -> a) -> a -> a] -> a -> a
09:13:38 <tensorpudding> monochrom: Is True really False?
09:13:42 <tensorpudding> is it 42?
09:13:47 <Makoryu> @unlet
09:13:48 <lambdabot>  Defined.
09:13:48 <tensorpudding> > True == 42
09:13:49 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
09:13:49 <lambdabot>    arising from the literal `42...
09:13:51 <Makoryu> :t flip foldr id
09:13:52 <lambdabot> forall a a1. (a -> (a1 -> a1) -> a1 -> a1) -> [a] -> a1 -> a1
09:13:55 <Makoryu> Damn
09:13:56 <EvanR-work> :t (.)
09:13:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:14:11 <Makoryu> (.) is fmap in lambdabot's Prelude
09:14:12 <mdmkolbe> quicksilver: I guess that means I'll have to write it myself (It's not hard, but it will take more time)
09:14:26 <Makoryu> :t [(.), fmap]
09:14:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => [(a -> b) -> f a -> f b]
09:14:27 <quicksilver> mdmkolbe: I think hash-consing in haskell is hard :)
09:14:39 <quicksilver> but you may know a trick I don't.
09:15:17 <Makoryu> Say, I just realized someone could make everyone's heads explode by rewriting reddit in Haskell
09:15:44 <jmcarthur> Makoryu: especially if it actually works
09:15:51 <Makoryu> Mmm
09:16:03 <Makoryu> And particularly if it works better than the original
09:16:04 <fax> Makoryu - that doesn't sound that amazing to me
09:16:20 <Makoryu> fax: Concept < execution
09:16:20 <fax> I mean it's basically just a blog site
09:16:23 <Makoryu> Yep
09:16:29 <Makoryu> It would be easy to accomplish
09:16:36 <mdmkolbe> quicksilver: In general it is hard, but with a known data type (i.e. the nodes in teh IntMap trie), it becomes easier
09:16:58 <tensorpudding> I don't think that Haskell has been used on a site as big as reddit.
09:17:59 <alpounet> big wrt to the number of visitors ?
09:18:04 <tensorpudding> Yeah.
09:18:27 * fax should probably stop reading reddit
09:18:37 <Makoryu> Reddit uses huge piles of infrastructure
09:18:47 <Makoryu> The size of a hallway
09:18:55 <tensorpudding> It's unlikely they're going to rewrite Reddit again.
09:19:25 <Makoryu> Not themselves, no
09:19:29 <Makoryu> ï¼ãÂ°âÂ°ï¼
09:19:33 <fax> lol
09:19:42 <tensorpudding> If they did it wouldn't be to Haskell anyway..
09:19:50 <Makoryu> Yeah. It would be to C++.
09:19:57 <Makoryu> And they would never see daylight again.
09:20:20 <tensorpudding> It was originally in Lisp.
09:20:35 <Makoryu> This is a pretty well-known fact
09:20:39 <twink> What kind of infrastructure?
09:20:58 <tensorpudding> And supposedly the new platform was a big improvement.
09:21:48 <Makoryu> In terms of features? I'm certain
09:21:56 <quicksilver> mdmkolbe: oh, ok.
09:22:01 <quicksilver> mdmkolbe: be nice, anyhow
09:22:23 <Makoryu> They rewrote it because they wanted to add features, but didn't know Lisp well enough to assign additional programmers to the task
09:23:58 <EvanR-work> sounds like an epic fail
09:24:16 <Makoryu> It sure seems like it hasn't worked out too well for them in the long run
09:24:49 <Makoryu> At least, when they rewrote it it was with a much smaller userbase in mind
09:24:53 <ManateeLazyCat> jutaro: Looks http://hackage.haskell.org/trac/ghc/query?status=new&status=assigned&status=reopened&group=priority&type=bug&order=id&desc=1
09:24:59 <Makoryu> And that might have bitten them in the ass
09:25:27 <ManateeLazyCat> juhp: Simon has start to investigate "segmentation fault" with gtk2hs. :)
09:28:33 * DrSyzygy oooooooooohs at seeing the way a comonad gives rise to a simplicial object. I gotta see if this can be applicable to Haskell or programming in some manner!!
09:28:41 <ManateeLazyCat> jutaro: Simon has start to investigate "segmentation fault" with gtk2hs. :)
09:28:44 <ManateeLazyCat> Sorry, typo.
09:29:28 <ManateeLazyCat> jutaro: So just use leksah with ghc-6.12.1 and wait 6.12.3 release.
09:31:59 <monochrom> perhaps websites are simplicial objects
09:33:16 <EvanR-work> < bobbens> EvanR-work: port haskell to 8 bit 128 bytes of RAM AVR MCPU and we'll talk :)
09:33:27 <EvanR-work> ^ quick how to do this
09:33:28 <EvanR-work> ;)
09:33:52 <monochrom> by moving things to ROM
09:34:29 * twink isn't sure what'd be impressive on the reddit -like front.
09:34:29 <lyndon__> Is there an operator that behaves like (.) flipped?
09:34:57 <twink> `flip fmap`
09:35:00 <arcatan> oh, apparently somebody else than me has wanted to use Haskell on ATtiny2313...
09:37:44 <monochrom> A bot that eloquently argues with everyone would be impressive on the reddit-like front.
09:40:01 <Ramb0> I want to do something like this but I cant:
09:40:02 <Ramb0> [x| x <- [1..], m]
09:40:02 <Ramb0>                 where m =       x^2 < 10
09:40:23 <Ramb0> Any help?
09:40:31 <twink> monochrom: I'm thinking something more realistic.
09:41:19 <tensorpudding> > [x | x <- [1..], m x] where m n = n^2 < 10
09:41:20 <lambdabot>   <no location info>: parse error on input `where'
09:41:50 <tensorpudding> > let y = [x | x <- [1..], m x] where m n = n^2 < 10 in y
09:41:53 <lambdabot>   mueval-core: Time limit exceeded
09:42:15 <Ramb0> I want to do it in a function
09:42:27 <monochrom> I think it is unclear
09:43:12 <ketil> How is cereal with laziness?
09:43:21 <scree> Ramb0: filter-like terms in a list comprehension must have type bool
09:43:30 <Ramb0> f    =       [x| x <- [1..100], m] where m   =       x^2 < 10
09:43:44 <Ramb0> my m es bool... x² < 10 is bool..
09:43:51 <monochrom> f    =       [x| x <- [1..100], m x] where m x =       x^2 < 10
09:44:07 <Ramb0> >  f    =       [x| x <- [1..100], m x] where m x =       x^2 < 10
09:44:08 <lambdabot>   <no location info>: parse error on input `='
09:44:18 <Ramb0> > [x| x <- [1..100], m x] where m x =       x^2 < 10
09:44:19 <lambdabot>   <no location info>: parse error on input `where'
09:44:32 <monochrom> just try it in a file, would you?
09:44:39 <Ramb0> Sorry :$
09:44:39 <Ramb0> ok
09:44:58 <Ramb0> it works, thanks :$
09:45:39 <Ramb0> The thing is that I need to use it a couple of times, so, I don't want it to recalculate "m x" each time.. is there a way to do it?
09:45:56 <scree> > [x | x <- [1..100], let m = x^2 < 10, m]
09:45:57 <lambdabot>   [1,2,3]
09:46:07 <scree> Ramb0 ^^^
09:46:36 <monochrom> f = [x | x <- [1..100], let b = m x, b, b, b, b, b] where m x = x^2<10
09:46:56 <Ramb0> Nice.
09:47:01 <roconnor> > 0.152 / 3.65 * 3.02
09:47:02 <lambdabot>   0.12576438356164382
09:47:03 <Ramb0> I will try it, thanks! :)
09:47:03 <tensorpudding> is that being facetious?
09:47:07 <fax> lol
09:47:36 <monochrom> it is facetious iff you don't get the point
09:51:36 <tensorpudding> What's the most obfuscated Haskell you've ever seen?
09:52:00 <hpc> i actually haven't ever seen obfuscated haskell
09:52:13 <matt_m> I haven't ever seen unobfuscased Haskell
09:52:23 <scree> hpc: have you *never* played @pl?
09:52:39 <scree> s/played/played with
09:52:57 <hpc> scree: i don't consider that actual Haskell, since it isn't human-produced
09:53:13 <tensorpudding> I've seen some really ugly Haskell before.
09:53:19 <scott__> How might I use a list comprehension to define a relation which is not symmetric?  So, if I have n elements in my list, I believe I want to get n - 1 elements back.
09:53:22 <tensorpudding> Specifically, some code I wrote when I was learning.
09:53:37 <roconnor> scott__: tail
09:53:42 <scree> hpc: I could look at the code for @pl, deduce the rules it uses, apply them by hand and then hand-write the code :P
09:53:54 <hpc> scree: that's horrible :P
09:54:04 <scree> hpc: I get to speak chinese though
09:54:08 <tensorpudding> It misused let, had some ugly and complicated versions of prelude functions, etc.
09:54:22 <scott__> roconnor: I was thinking of just taking the cartesian product and then filtering, but tail is easier?
09:54:49 <roconnor> scott__: I'm pretty confused as to what you want :D
09:56:44 <scott__> roconnor: I want to compare each of n elements with all the other n - 1 elements, but not do any comparisons that I've already done by symmetry.
09:56:48 <tensorpudding> @src tail
09:56:49 <lambdabot> tail (_:xs) = xs
09:56:49 <lambdabot> tail []     = undefined
09:56:54 <roconnor> ah
09:57:09 <roconnor> scott__: inits might be useful somehow
09:57:19 <roconnor> > inits [1,2,3]
09:57:20 <lambdabot>   [[],[1],[1,2],[1,2,3]]
09:57:35 <roconnor> hmm
09:57:39 <roconnor> maybe tails is better
09:57:45 <roconnor> > tails [1,2,3]
09:57:46 <lambdabot>   [[1,2,3],[2,3],[3],[]]
09:58:47 <roconnor> > [map (f (head l) (tail l) | l <- init . tails $ [1,2,3]]
09:58:48 <lambdabot>   <no location info>: parse error on input `|'
09:58:58 <roconnor> > [map (f (head l)) (tail l) | l <- init . tails $ [1,2,3]]
09:58:59 <lambdabot>   Ambiguous type variable `b' in the constraints:
09:58:59 <lambdabot>    `SimpleReflect.FromExpr ...
09:59:08 <roconnor> > [map (< (head l)) (tail l) | l <- init . tails $ [1,2,3]]
09:59:10 <lambdabot>   [[False,False],[False],[]]
09:59:12 <roconnor> er
09:59:18 <roconnor> > [map (+ (head l)) (tail l) | l <- init . tails $ [1,2,3]]
09:59:20 <lambdabot>   [[3,4],[5],[]]
09:59:30 <roconnor> > f 1 2
09:59:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:59:32 <lambdabot>    `SimpleReflect.FromExpr ...
09:59:34 <roconnor> :/
09:59:46 <roconnor> > [map (+ (head l)) (tail l) | l <- init . tails $ [x,y,z]]
09:59:47 <lambdabot>   [[y + x,z + x],[z + y],[]]
09:59:50 <scott__> So, what I would do in an imperative language would be to write a nested for loop where each loop loops over the list and I do a comparison if index j < i.
09:59:51 <roconnor> > [map (f (head l)) (tail l) | l <- init . tails $ [x,y,z]]
09:59:52 <lambdabot>   Ambiguous type variable `b' in the constraints:
09:59:52 <lambdabot>    `GHC.Show.Show b'
09:59:52 <lambdabot>      a...
10:00:00 <roconnor> > f x y
10:00:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:00:01 <lambdabot>    `GHC.Show.Show a'
10:00:01 <lambdabot>      a...
10:00:06 <roconnor> ;( why
10:00:18 <hpc> :t f
10:00:19 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
10:00:38 <hpc> heh
10:00:42 <roconnor> > foldr f z [a,b,c]
10:00:44 <lambdabot>   f a (f b (f c z))
10:00:48 <roconnor> why does that work?
10:01:01 <roconnor> > [map (f (head l)) (tail l) | l <- init . tails $ [x,y,z]] : [Expr]
10:01:02 <lambdabot>   Not in scope: data constructor `Expr'
10:01:04 <roconnor> > [map (f (head l)) (tail l) | l <- init . tails $ [x,y,z]] :: [Expr]
10:01:05 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
10:01:05 <lambdabot>         against inferred ...
10:01:18 <roconnor> > concat [map (f (head l)) (tail l) | l <- init . tails $ [x,y,z]] :: [Expr]
10:01:19 <lambdabot>   [f x y,f x z,f y z]
10:01:26 <roconnor> ah
10:01:47 <scott__> Woo
10:02:05 <scott__> Now I just need to understand it!
10:02:43 <roconnor> > init . tails $ [x,y,z] >>= (\l -> map (f (head l)) (tail l))  ] :: [Expr]
10:02:44 <lambdabot>   <no location info>: parse error on input `]'
10:02:47 <roconnor> > init . tails $ [x,y,z] >>= (\l -> map (f (head l)) (tail l)) :: [Expr]
10:02:49 <lambdabot>   Couldn't match expected type `[a]'
10:02:49 <lambdabot>         against inferred type `SimpleRef...
10:02:58 <roconnor> > (init . tails) [x,y,z] >>= (\l -> map (f (head l)) (tail l)) :: [Expr]
10:02:59 <lambdabot>   [f x y,f x z,f y z]
10:03:02 <roconnor> > (init . tails) [x,y,z] >>= (\l -> map (f (head l)) (tail l))
10:03:03 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:03:03 <lambdabot>    `GHC.Show.Show b'
10:03:03 <lambdabot>      a...
10:03:05 <roconnor> mah
10:03:08 <roconnor> meh
10:03:10 <roconnor> > (init . tails) [x,y,z] >>= (\l -> map (f (head l)) (tail l)) :: [Expr]
10:03:11 <lambdabot>   [f x y,f x z,f y z]
10:03:26 <xerox> > f 1 2 :: Expr
10:03:27 <lambdabot>   f 1 2
10:03:36 <roconnor> @pl \foo -> (init . tails) foo >>= (\l -> map (f (head l)) (tail l))
10:03:37 <lambdabot> (ap (map . f . head) tail =<<) . init . tails
10:03:56 <scott__> What is @pl doing?
10:04:02 <roconnor> > (ap (map . f . head) tail =<<) . init . tails $ [x,y,z] :: [Expr]
10:04:03 <hpc> reducing to pointfree form
10:04:04 <lambdabot>   [f x y,f x z,f y z]
10:04:13 <roconnor> scott__: getting rid of lambda expressions
10:04:22 <roconnor> sorry
10:04:28 <roconnor> please ignore the @pl result
10:05:04 <scott__> I've also never seen "=<<".
10:05:05 <tensorpudding>  @pl takes lambda expressions and returns an equivalent function that is in pointless/pointfree style
10:05:15 <tensorpudding> =<< is just a flipped version of >>=
10:05:21 <scott__> I don't know that one either.
10:05:36 <ulfdoz> @src (=<<)
10:05:36 <lambdabot> f =<< x = x >>= f
10:05:46 <roconnor> scott__: in this case =<< is concatMap
10:05:54 <xerox> > (=<<) (f::Expr->Expr->Expr) g x
10:05:55 <lambdabot>   f (g x) x
10:06:30 <ulfdoz> palindromes for haskellers.
10:06:56 <tensorpudding> how many haskell function definitions are palindromes, I wonder
10:07:29 <scott__> (ap (map . f . head) tail =<<) . init . tails $ [x,y,z]
10:07:33 <scott__> > (ap (map . f . head) tail =<<) . init . tails $ [x,y,z]
10:07:34 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:07:34 <lambdabot>    `GHC.Show.Show b'
10:07:34 <lambdabot>      a...
10:08:07 <aavogt>  <<< >>>
10:08:18 <aavogt>  >=>  <=<
10:10:08 <scott__> So ap takes a Monad parameterized by a function (b -> c), then a Monad parameterized by b, and returns a Monad parameterized by c.
10:10:20 <ski> no
10:10:38 <ski> it takes two monadic *actions*, not monads
10:10:44 <scott__> I don't get it! XD  I'm looking at this: http://www.zvon.org/other/haskell/Outputmonad/ap_f.html
10:10:58 <ski> `m' is the monad. a value of type `m a' is a monadic action
10:11:08 <scott__> Ah
10:11:23 <ski> @type getLine
10:11:24 <lambdabot> IO String
10:11:40 <scott__> @type ap
10:11:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:11:42 <pastorn> > return (+1) `ap` (Just 0)
10:11:42 <lambdabot>   Just 1
10:11:46 <ski> e.g. `getLine' is a monadic action (specifically an `IO'-action), while `IO' itself is the monad
10:11:49 <pastorn> > return (+1) `ap` (Nothing)
10:11:49 <lambdabot>   Nothing
10:12:33 <scott__> I think I need to finish reading Gentle Intro to Haskell.
10:12:49 <pastorn> scott__: is that good?
10:13:12 <dschoepe> at least, many people say it's not gentle
10:13:13 <scott__> pastorn: You mean, does your example make sense?
10:13:25 <tensorpudding> Gentle Intro is considered very not-gentle.
10:13:35 <pastorn> scott__: no, i mean the book
10:13:36 <tensorpudding> I learned a little Haskell from it before I gave it up.
10:13:43 <scott__> O
10:14:05 <pastorn> scott__: have you programmed anything before starting with haskell?
10:14:06 <scott__> I've made it to "Types Again" so far.
10:14:25 <scott__> pastorn: Yes, but only in imperative languages.
10:15:07 <tensorpudding> Damn, Gentle Intro is from 2000, and Haskell was already damn old.
10:15:20 <scott__> pastorn: I don't understand your question, "Is that good?".
10:16:20 <dschoepe> scott__: He wants to know whether you think the Gentle Introduction to Haskell is a good text for learning Haskell.
10:16:31 <scott__> tensorpudding: Does it get less gentle toward the end?  I'm on the 6th chapter, and so far I've found it reasonable.
10:17:38 <tensorpudding> I can't remember.
10:19:14 <scott__> dschoepe: Oh!  I don't know why I didn't understand that.  I thought he was saying something along the lines of "Is that a good thing."  Anyhow, I think it has been good so far.
10:19:52 * ski thought the Gentle introduction was o-k ..
10:19:52 <tensorpudding> Ah, I remember, I gave up because I skipped through a lot to try and get to monads, and got horribly confused.
10:19:57 <tensorpudding> My understanding of monads was flawed until I came on here and Cale explained it all.
10:20:06 <scott__> I've been taking it slowly and I've been going in order.
10:21:07 <scott__> roconnor: Can you paste what you came up with again?  I'm afraid I didn't understand what the final solution was.
10:21:19 <tensorpudding> I learned more Haskell from talking on here and writing code and reading docs than by doing tutorials.
10:21:24 <monoidal> what is a short way to write split :: (a -> (b,c)) -> (a -> b, a -> c)?
10:21:34 <monoidal> its inverse is liftM2 (,)
10:21:43 <tensorpudding> Though I learned a few more advanced things in my initial reading of RWH, which I still haven't finished.
10:22:33 <aavogt> @type ((fst &&& snd) .)
10:22:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> f (a, b)
10:22:46 <aavogt> @type ((fst *** snd) .)
10:22:48 <lambdabot> forall a b a1 b1 (f :: * -> *). (Functor f) => f ((a, b), (a1, b1)) -> f (a, b1)
10:23:14 <lispy> Using Functor ((->) r) ?
10:23:30 <tensorpudding> \f -> (fst . f, snd . f)
10:23:31 * aavogt isn't being useful here
10:23:45 <lispy> ?pl \f -> (fst . f, snd . f)
10:23:45 <lambdabot> liftM2 (,) (fst .) (snd .)
10:23:45 <tensorpudding> @pl \f -> (fst . f, snd . f)
10:23:46 <lambdabot> liftM2 (,) (fst .) (snd .)
10:23:57 <tensorpudding> there you have it
10:24:02 <lispy> oh, duh, that looks so easy ;)
10:24:08 <monoidal> oh,thanks
10:24:09 * lispy scoffs
10:24:22 <lispy> Pointful is sometimes better (often?)
10:24:27 <tensorpudding> pointed
10:25:01 <scott__> Is the easiest way to do a cartesian product to use a list comprehension?
10:25:23 <dschoepe> > sequence [1..3] [4..5]
10:25:24 <lambdabot>   No instances for (GHC.Num.Num ([t] -> a), GHC.Enum.Enum ([t] -> a))
10:25:25 <lambdabot>    aris...
10:25:31 <dschoepe> > sequence [[1..3], [4..5]]
10:25:31 <monoidal> > sequence [[1,2],[3,4]]
10:25:32 <lambdabot>   [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
10:25:32 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
10:26:32 <ski> > liftM2 (,) [1,2] [3,4]
10:26:33 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
10:27:19 <monoidal> unzip :: [(a,b)] -> ([a],[b])
10:27:36 <monoidal> split :: (a -> (b,c)) -> (a -> b, a -> c)
10:27:59 <monoidal> is there a common structure here? it's f (a,b) -> (f a, f b), dual to applicative functor
10:29:28 <ski> @type fmap fst &&& fmap snd  -- monoidal
10:29:28 * hackagebot Combinatorrent 0.3.2 - A concurrent bittorrent client  http://hackage.haskell.org/package/Combinatorrent-0.3.2 (JesperLouisAndersen)
10:29:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> (f a, f b)
10:29:51 <jlouis> dcoutts_: do you know why running 'cabal check' rejects -fhpc even when it is behind a flag that is false by default?
10:33:02 <dschoepe> jlouis: I once had an issue where cabal/ghc seemed to ignore a flag because of wrong ordering when passing the flags to ghc. one workaround was putting the unconditional options in the .cabal file in an "if True" block.
10:33:26 <dschoepe> perhaps this is something similar
10:33:50 <jlouis> dschoepe: it is worth a try as a workaround
10:35:11 <kniu> how long do I run the heap profiler before I get actual results?
10:35:32 <kniu> Last time, I killed it after a few minutes, and the graph showed nothing.
10:37:08 <dcoutts> jlouis: if it's just a convenience for you as a developer you can always cabal configure --ghc-options=-fhpc
10:37:08 <scott__> If p1 and p2 are of type (Double, Double) (representing 2D points), will this work in general for finding all n - 1 distances between n points?: distances ps = [distance p1 p2 | p1 <- ps, p2 <- ps, p1 < p2]
10:37:33 <fax> http://www.mathpages.com/HOME/kmath355.htm
10:37:42 <fax> cool math 4 kids
10:38:22 <monoidal> scott__: n(n-1)/2?
10:39:12 <jlouis> dcoutts: much better solution, yes
10:39:13 <monoidal> if there are duplicate points, you should output 0
10:39:40 <jlouis> kniu: the heap output only shows cost centres, -prof-all on it?
10:39:49 <scott__> monoidal: Wait, I think it should be n(n-1)/2.
10:39:51 <jlouis> kniu: how do you call it?
10:39:52 <dcoutts> jlouis: there's two features in this area we're planning, one is persistent local configure settings for developers (ie stick them in a file)
10:39:59 <dcoutts> jlouis: and special support for hpc
10:40:07 <jlouis> dcoutts: nice idea!
10:40:14 <hpc> dcoutts: you pinged me?
10:40:18 <scott__> monoidal: There should be no duplicate points in the list.
10:40:21 <hpc> oh, the parallel lib
10:40:24 <hpc> nvm
10:40:27 <dcoutts> hpc: sorry :-)
10:40:39 <hpc> heh
10:40:54 <kniu> jlouis, I compiled with -prof -auto-all and ran it with +RTS -hc
10:40:59 <scott__> monoidal: However, I suppose I should want this function to compute those distances if the point is specified twice.
10:41:16 <monoidal> scott__: it's correct under that assumption
10:41:27 <scott__> monoidal: But if I have [(1,1)], distances should return an empty set.
10:41:51 <scott__> monoidal: I guess if I have [(1, 1), (1,1)], then I want [0].
10:41:53 <jlouis> kniu: any output in foo.hp at all?
10:42:11 <jlouis> it should drop something there periodically
10:42:15 <scott__> monoidal: And it doesn't do that right.
10:42:28 <kniu> jlouis, nope.
10:42:39 <kniu> that was about 5 minutes of runtime.
10:43:04 <scott__> monoidal: I need a way of saying, "it's okay to compute the distance if the points are the same, but at different indices, but not if they're at the same index."
10:43:21 <jlouis> kniu: that is somewhat odd
10:43:42 <whald> kniu: does the .hp file exist at all?
10:43:46 <kniu> it's there.
10:44:04 <scott__> Oh, I think I'm maybe starting to see how roconnor was using tails.
10:44:08 <kniu> had only about 5 lines with useless values.
10:44:32 <roconnor> > concat [map (f (head l)) (tail l) | l <- init . tails $ [x,y,z]] :: [Expr]
10:44:34 <lambdabot>   [f x y,f x z,f y z]
10:44:43 <whald> kniu: that is somewhat odd
10:44:55 <roconnor> > tails $ [x,y,z]
10:44:56 <lambdabot>   [[x,y,z],[y,z],[z],[]]
10:45:02 <roconnor> > init . tails $ [x,y,z]
10:45:04 <lambdabot>   [[x,y,z],[y,z],[z]]
10:45:21 <jlouis> kniu: full filesystem?
10:45:22 <scott__> > concat [map ((+) (head l)) (tail l) | l <- init . tails $ [1,2,3]]
10:45:23 <lambdabot>   [3,4,5]
10:45:31 <roconnor> > map head $ init . tails $ [x,y,z]
10:45:33 <lambdabot>   [x,y,z]
10:45:33 <jlouis> kniu: also, Operating system
10:45:45 <whald> kniu: i usually compile with -prof -auto-all -caf-all -- maybe that helps. but i'm new to the haskell business, so don't quote me on that :-)
10:45:50 <scott__> > concat [map ((+) (head l)) (tail l) | l <- init . tails $ [1,2,3,4,5]]
10:45:51 <lambdabot>   [3,4,5,6,5,6,7,7,8,9]
10:45:53 <roconnor> > map tail $ init . tails $ [x,y,z]
10:45:55 <lambdabot>   [[y,z],[z],[]]
10:46:03 <jlouis> it might be all in a CAF, but..
10:46:15 <roconnor> > map (head &&& tail) $ init . tails $ [x,y,z]
10:46:16 <lambdabot>   [(x,[y,z]),(y,[z]),(z,[])]
10:46:21 <scott__> >map tail (init) . tails ([x,y,z])
10:46:25 <scott__> > map tail (init) . tails ([x,y,z])
10:46:25 <lambdabot>   Couldn't match expected type `[[a]]'
10:46:26 <lambdabot>         against inferred type `[a1] ->...
10:46:34 <jlouis> does reglar +RTS -p profiling work on the binary? is the right binary called?
10:47:09 <lispy> whald: IIRC, -caf-all is implied by -auto-all
10:47:29 <kniu> uh
10:47:34 <kniu> filesystem is ext3
10:47:35 <whald> kniu: probably a.out? :-)
10:47:37 <fax> is there a program that turns sentences into palindromes which have equivalent meaning?
10:47:44 <kniu> and os is archlinux
10:47:48 <hpc> english sentances?
10:47:52 <fax> yes
10:47:54 <hpc> *sentences
10:47:55 <hpc> no
10:48:04 <hpc> english isn't even a fully computationally understood language
10:48:07 <kniu> there is no a.out, I specifically set -o.
10:48:30 <fax> hpc what do you mean computationally understod
10:48:30 <hpc> it is riddled with ambiguities and alternate meanings, to the point where it would be downright impossible
10:48:35 * hackagebot hpage 0.8.1 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.8.1 (FernandoBenavides)
10:48:55 <hpc> i mean we can't make a program that can parse it
10:49:16 <hpc> if we could, we could make a perfect language translator between it and another fully understood language
10:49:17 <jlouis> kniu: I am just throwing out ideas at this point to eventually kill with occams razor
10:49:18 <whald> lispy: accoring to http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/prof-compiler-options.html it doesn't seem so
10:49:25 <kniu> hm
10:49:36 <kniu> I'm just going to let it run for an hour and kill it to see what I get.
10:49:41 <scott__> > init . tails $ [x,y,z]
10:49:42 <lambdabot>   [[x,y,z],[y,z],[z]]
10:49:51 <jlouis> kniu: it should begin giving you data much much earlier
10:49:51 <lispy> whald: ah, I see.  Thanks for clarifying that.
10:50:18 <whald> kniu: imho that won't help, you get some data fast -- or never
10:50:22 <hpc> (computationally understood is more than likely the wrong term for it, but i am not a computational linguist)
10:50:26 <scott__> roconnor: I get it!
10:50:30 <roconnor> \o/
10:50:49 <kniu> ok
10:50:51 <scott__> roconnor: It's like drawing one of those pictures where you connect all the vertices in a graph.
10:50:53 <ezyang> @pl \d -> filter (`notElem` [".",".."]) <$> getDirectoryContents d
10:50:53 <lambdabot> (filter (`notElem` [".", ".."]) <$>) . getDirectoryContents
10:50:58 <ezyang> bah
10:50:59 <lispy> I wonder if lojban has such a palindrome generator
10:51:00 <ezyang> really?
10:51:02 <roconnor> scott__: ... um okay
10:51:11 <whald> kniu: and in my experience running hp2ps while the program ist still running does not work (which is a pity)
10:51:12 <kniu> useless data again.
10:51:15 <jlouis> kniu: try with +RTS -p and -s
10:51:28 <luite> what's a good package to draw simple figures, like graphs or combinatorial structures, in a window, from ghci?
10:51:55 <lispy> kniu: oh, do you need profiling while your program is running?  You might try hp2any-manager et al.
10:52:02 <roconnor> luite: heiroglyph maybe?
10:52:03 <jmcarthur> Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo.
10:52:18 <jlouis> jmcarthur: wrong monad
10:52:20 <jmcarthur> parse that!
10:52:22 <jlouis> burritto!
10:52:23 <scott__> roconnor: Like, you have a bunch of points.  You start with point 1 and draw a line to all the other points.  Then you start with point 2 and draw a line to all the points except point 1 (because you already did it with point1), and so on.
10:52:45 <monoidal> > concatMap (\(a:b) -> map (a,) b) $ init $ tails [1,2,3]
10:52:46 <lambdabot>   <no location info>: parse error on input `)'
10:53:04 <monoidal> > concatMap (\(a:b) -> map (\k -> (a,k)) b) $ init $ tails [1,2,3]
10:53:05 <lambdabot>   [(1,2),(1,3),(2,3)]
10:53:25 <monoidal> > :set -XTupleSections
10:53:26 <lambdabot>   <no location info>: parse error on input `:'
10:53:48 <scott__> init $ tails [1,2,3]
10:53:51 <scott__> > init $ tails [1,2,3]
10:53:52 <lambdabot>   [[1,2,3],[2,3],[3]]
10:53:58 <roconnor> scott__: ya, that is it
10:54:44 <fax> @let whales = init $ tails
10:54:45 <lambdabot>  <local>:5:16:
10:54:45 <lambdabot>      Couldn't match expected type `[a]'
10:54:45 <lambdabot>             against in...
10:55:19 <roconnor> @type whales
10:55:20 <lambdabot> Not in scope: `whales'
10:55:25 <roconnor> @type L.whales
10:55:26 <fax> @let whales = init.$ tails
10:55:26 <lambdabot> Not in scope: `L.whales'
10:55:27 <lambdabot>  <local>:5:13: Not in scope: `.$'
10:55:31 <fax> @let whales = init. tails
10:55:32 <lambdabot>  Defined.
10:56:04 <fax> > map whales . whales $ "woobabafpbb"
10:56:05 <lambdabot>   [["woobabafpbb","oobabafpbb","obabafpbb","babafpbb","abafpbb","bafpbb","afp...
10:56:41 <lyndon__> Is there a 'bredth first' list comprehension so that all set elements get explored?
10:56:41 <pastorn> > map whales . whales $ "abc"
10:56:42 <lambdabot>   [["abc","bc","c"],["bc","c"],["c"]]
10:56:55 <fax> lyndon__ no :(
10:57:02 <fax> there is >>- though
10:57:09 <pastorn> lyndon__: there's the Logic monad, though
10:57:13 <pastorn> lyndon__: google LogicT
10:57:23 <fax> > [1..] >>- \x -> [1..] >>- \y -> return (x,y)
10:57:24 <lambdabot>   [(1,1),(2,1),(1,2),(3,1),(1,3),(2,2),(1,4),(4,1),(1,5),(2,3),(1,6),(3,2),(1...
10:57:26 <fax> for example
10:57:30 <fax> > [1..] >>= \x -> [1..] >>= \y -> return (x,y)
10:57:30 <ski> @google LogicT
10:57:31 <lambdabot> http://okmij.org/ftp/Computation/monads.html
10:57:31 <lambdabot> Title: Monads
10:57:31 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
10:57:59 <lyndon__> fax, pastorn thanks. fax: Where do I find that operator?
10:58:06 <monoidal> let tree = [] : (tree >>= \x -> [left x, right x]) in take 10 tree
10:58:09 <monoidal> ? let tree = [] : (tree >>= \x -> [left x, right x]) in take 10 tree
10:58:12 <monoidal> > let tree = [] : (tree >>= \x -> [left x, right x]) in take 10 tree
10:58:13 <lambdabot>   Couldn't match expected type `[a]'
10:58:13 <lambdabot>         against inferred type `a1 (Data....
10:58:21 <fax> it's in Control.Monad.Logic
10:58:24 <roconnor> scott__: oh we will have to work harder to get this to work on infinite lists
10:58:29 <monoidal> > let tree = [] : (tree >>= \x -> [f x, g x]) in take 10 tree
10:58:30 <lambdabot>   No instance for (SimpleReflect.FromExpr [a])
10:58:30 <lambdabot>    arising from a use of `e_11...
10:58:30 <fax> cabal install LogicT to get it
10:59:16 <lyndon__> ah
10:59:59 <scott__> roconnor: Really?  I'm still trying to follow through monodial's version.
11:00:33 <roconnor> oh okay
11:00:51 <roconnor> monoidal's is the same as mine, but you should figure that out yourself
11:00:53 <luite> roconnor: ah, I'll try that
11:01:16 <scott__> roconnor: I know it works the same, but I'm still trying to figure out how it works.
11:03:02 <scott__> roconnor: Okay, I see it.
11:03:16 <roconnor> > transpose (init . tails $ [1,2,3
11:03:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:03:18 <roconnor> > transpose (init . tails $ [1,2,3])
11:03:20 <lambdabot>   [[1,2,3],[2,3],[3]]
11:03:33 <roconnor> > (init . tails $ [1,2,3])
11:03:34 <lambdabot>   [[1,2,3],[2,3],[3]]
11:03:43 <roconnor> ah
11:03:51 <scott__> concatMap (\(a:b) -> map (\k -> ((+) a k)) b) $ init $ tails [1,2,3]
11:03:57 <scott__> > concatMap (\(a:b) -> map (\k -> ((+) a k)) b) $ init $ tails [1,2,3]
11:03:57 <lambdabot>   [3,4,5]
11:04:05 <scott__> > concatMap (\(a:b) -> map (\k -> ((+) a k)) b) $ init $ tails [1,2,3,4,5]
11:04:06 <lambdabot>   [3,4,5,6,5,6,7,7,8,9]
11:04:14 <fax> cool
11:04:25 <fax> @oies 3,4,5,6,5,6,7,7,8,9
11:04:25 <lambdabot>  b+c+d+e where b>=c>=d>=e>=0 ordered by b then c then d then e.
11:04:25 <lambdabot>  [0,1,2,3,4,2,3,4,5,4,5,6,6,7,8,3,4,5,6,5,6,7,7,8,9,6,7,8,8,9,10,9,10,11,12,4...
11:05:31 <monoidal> > let f [] = []; f (b:c) = map (g b) c ++ f c in f [1,2,3]
11:05:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:05:33 <lambdabot>    `SimpleReflect.FromExpr ...
11:05:38 <monoidal> > let f [] = []; f (b:c) = map ((,) b) c ++ f c in f [1,2,3]
11:05:39 <lambdabot>   [(1,2),(1,3),(2,3)]
11:07:48 <roconnor> > let foo l (a:xs) = map ((,)a) l : foo (a:l) xs in foo [] [1..]
11:07:49 <lambdabot>   [[],[(2,1)],[(3,2),(3,1)],[(4,3),(4,2),(4,1)],[(5,4),(5,3),(5,2),(5,1)],[(6...
11:07:57 <roconnor> > let foo l (a:xs) = map ((,)a) l : foo (a:l) xs in concat $ foo [] [1..]
11:07:58 <lambdabot>   [(2,1),(3,2),(3,1),(4,3),(4,2),(4,1),(5,4),(5,3),(5,2),(5,1),(6,5),(6,4),(6...
11:08:00 <fax> > let x = 0.2 in (1/(1-x),(1 + x)*(1 + x^2)*(1 + x^4)*(1 + x^8))
11:08:00 <lambdabot>   (1.25,1.249999999991808)
11:08:20 <roconnor> @pl \x -> let foo l (a:xs) = map ((,)a) l : foo (a:l) xs in concat $ foo [] x
11:08:20 <lambdabot> flip (join .) (fix (flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (((.) . (:)) .) . flip (map . (,))) . (. flip (:)) . (.))) . flip ($ [])
11:08:25 <roconnor> :D
11:08:36 <roconnor> > flip (join .) (fix (flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (((.) . (:)) .) . flip (map . (,))) . (. flip (:)) . (.))) . flip ($ []) $ [1..]
11:08:37 <lambdabot>   [(2,1),(3,2),(3,1),(4,3),(4,2),(4,1),(5,4),(5,3),(5,2),(5,1),(6,5),(6,4),(6...
11:08:43 <roconnor> so easy ;)
11:08:44 <ezyang> Any practices you guys follow for picking names for functions?
11:09:22 <fax> > let x = 0.76 in (1/(1-x),(1 + x + x^2)*(1 + x^3 + x^6)*(1 + x^9 + x^18)))
11:09:23 <lambdabot>   <no location info>: parse error on input `)'
11:09:25 <fax> > let x = 0.76 in (1/(1-x),(1 + x + x^2)*(1 + x^3 + x^6)*(1 + x^9 + x^18))
11:09:26 <lambdabot>   (4.166666666666667,4.164144604717688)
11:10:16 <roconnor> what part of "flip (join .) (fix (flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (((.) . (:)) .) . flip (map . (,))) . (. flip (:)) . (.))) . flip ($ [])" don't you understand
11:10:23 <scott__> lol
11:11:53 <scott__> roconnor: What is a good name for this function I'm wanting?
11:12:44 <scott__> roconnor: "subset of cartesian product which is non-symmetric?"
11:13:32 <fax> scott__ - call it pairs
11:13:43 <fax> or pairings
11:14:36 <scott__> fax: Okay, I like that.
11:18:51 <EvanR-work> what does a ghc binary need to run on someones system
11:18:58 <EvanR-work> ghc runtime?
11:19:39 <dcoutts_> EvanR-work: run ldd on the binary, that lists the shared libs it needs
11:19:47 * hackagebot hpage 0.8.2 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.8.2 (FernandoBenavides)
11:21:17 <EvanR-work> dcoutts_: i dont see a ghc runtime ;)
11:21:32 <dcoutts_> EvanR-work: right, because it's statically linked
11:21:51 <EvanR-work> so its runs like any other program for example compiled with c
11:22:02 <EvanR-work> just needs the deps and the standard libs like libc and libz
11:22:15 <lispy> Interesting, Neil Mitchel is in my "social circle" according to Google.  We've never met in person that I know of.
11:22:37 <EvanR-work> libgmp is a little demanding...
11:22:38 <fax> GOOGLE??
11:23:25 <whald> lispy: he'll run into your car tomorrow, but it won't be serious. don't worry.
11:23:42 <lispy> whald: ah no!
11:23:49 <fax> whats this about google?
11:24:38 <EvanR-work> dcoutts_: and further, any 'pure haskell code' will be statically linked?
11:24:46 <fax> lispy
11:24:52 <EvanR-work> so theres no 'haskell dlls'
11:25:03 <EvanR-work> data.list.dll
11:25:06 <lispy> fax:  google changed their search result page.  And on the far left it has a link for "Social" under the more options
11:25:18 <fax> AH
11:25:48 <fax> I dont see it
11:25:55 <EvanR-work> i just noticed that
11:26:00 <EvanR-work> google has gone off the deep end
11:26:47 <fax> lispy do you have facebook accounts or some related things ??
11:26:55 <fax> because I don't have any 'social' button
11:27:07 <lispy> I am logged into my google account
11:27:24 <lispy> and I had to cilck, "More search tools"
11:28:00 <dcoutts_> EvanR-work: you can make Haskell dlls on linux but the default is still static
11:28:03 <fax> Google Social Search is a feature designed to help you discover relevant publicly-accessible content from your social circle, a set of online friends and contacts
11:28:08 <fax> this sounds bad
11:28:43 <fax> http://www.google.com/s2/search/social
11:29:13 <fax> With social search, your friends can more easily find relevant content you create online, such as photos uploaded to Flickr or Picasa, blog posts, and status updates on FriendFeed or Twitter.
11:29:33 <fax> how do I turn this off that's all I want to know
11:30:55 <hpc> through the settings link?
11:31:03 <hpc> alternatively, don't save google cookies
11:31:17 <fax> google turning into facebook is a bad sign
11:32:15 <monoidal> how would you write "tuples" - like pairings, but for n elements?
11:32:24 <fax> (a,(b,(c,())))
11:32:43 <hpc> you can't do it in an arbitrary fashion though
11:32:55 <hpc> tuples of different length have different type
11:33:01 <fax> yes
11:33:08 <monoidal> i mean pairings were [(x,y),(x,z),(y,z)]
11:33:22 <tensorpudding> It doesn't appear that Google shares that content unless you post links to it in your google profile
11:33:28 <monoidal> triplings could be [(x,y,z)]
11:33:34 <hpc> oh
11:33:38 <monoidal> it would be lists
11:33:48 <tensorpudding> At least, the other tab says such for me.
11:35:11 <EvanR-work> monoidal: theres lists of lists
11:35:19 <EvanR-work> [[1],[2,3],[4,5,6]]
11:35:52 * hackagebot quickcheck-script 0.1.1.1 - Automated test tool for QuickCheck.  http://hackage.haskell.org/package/quickcheck-script-0.1.1.1 (KidoTakahiro)
11:36:02 <monoidal> > let whales = map (\(x:y) -> (x,y)) . init . tails in map (second whales) $ whales [1,2,3]
11:36:04 <lambdabot>   [(1,[(2,[3]),(3,[])]),(2,[(3,[])]),(3,[])]
11:37:23 <monoidal> i'm generalizing scott__'s problem to arbitrary length
11:41:36 <whald> my key on the left hand side of "v" is broken. i usually work around this by kopy and pasting the missing kharakter :-/
11:42:01 <monochrom> haha
11:42:10 <fryguybob> remap caps to c
11:42:44 <hpc> fix the key?
11:43:42 <jmcarthur> i don't like that i was automatically registered with google's web history feature
11:43:51 <benmachine> that's not as interesting as a literary endeavour though
11:43:52 <EvanR-work> why do i not get 94% of the jokes in "evolution of a haskell programmer"
11:43:57 * hackagebot hpage 0.8.3 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.8.3 (FernandoBenavides)
11:44:01 * benmachine attempts to not use that same key out of solidarity
11:44:12 <benmachine> EvanR-work: it's only one joke :P
11:44:13 <arcatan> maybe you haven't evolved enough yet
11:44:19 <EvanR-work> haha
11:44:22 <monochrom> why do i not get 94% of wikipedia
11:45:04 <benmachine> I wonder what would happen if I un-xmodmapped my e key
11:45:07 <benmachine> I wonder how long I'd last
11:45:23 <benmachine> we will probably never know
11:45:40 <monochrom> (you already used 3 e's)
11:45:59 <benmachine> well I haven't done it have I
11:46:03 <benmachine> it wasn't e we were talking about
11:46:13 <benmachine> until I started talking about e
11:46:50 <monochrom> switch to Chinese
11:47:22 <benmachine> that would be hard
11:54:59 <c_wraith> wtf.  How is implementing rnf in terms of Data.Foldable slower than in terms of fmap?
11:55:28 <c_wraith> doesn't fmap have to copy the structure, and Data.Foldable gets to skip that?
11:55:44 <hpc> rnf?
11:55:55 <dolio> How do you implement it with fmap?
11:56:14 <c_wraith> ...  Oh, crap.  the fmap implementation didn't do anything, because the structure was lazy in the data.
11:56:19 <jmcarthur> heh
11:56:20 <c_wraith> So it's slower because it works
11:56:26 <jmcarthur> fmap won't work in general anyway
11:56:55 <jmcarthur> data Foo a = Foo Bar, for example
11:57:25 <dolio> That isn't foldable, either.
11:57:49 <c_wraith> Sadly, most things don't implement NFData by default.
11:57:56 <fax> foldFoo foo (Foo bar) = foo bar  no?
11:57:57 <dolio> Or, if it is, it's foldr f z _ = z.
11:59:17 <dolio> Foldable has the method foldr :: (a -> r -> r) -> r -> f a -> r, or equivalents.
11:59:50 <c_wraith> Hmm.  This code is about 1/3 the speed of dedicated C code.  crap, that's bad.
11:59:57 <jmcarthur> what is it?
12:00:39 <c_wraith> JSON parsing.  the JSONb package, in particular.  I'll test other packages, too, but I had the highest hopes for that one.
12:00:45 <jmcarthur> ah
12:01:21 <c_wraith> oh, hmm.
12:01:35 <c_wraith> rnf might not be necessary here.
12:01:47 <benmachine> rnf tends to be slow I've heard
12:01:50 <matt_m> What's rnf?
12:02:19 <c_wraith> I just wish I had any way of knowing if there were unevaluated thunks in the return value from decode.
12:02:24 * ski . o O ( "Resumption Neurypnological Frightening" )
12:02:35 <c_wraith> I guess I could abuse vacuum to find out.
12:03:08 <benmachine> matt_m: applies seq everywhere inside a data structure to ensure the entire thing is evaluated
12:03:30 <c_wraith> matt_m: It's part of the deepseq package
12:03:31 <ski> benmachine : hm, inside functions as well ?
12:03:43 <c_wraith> only things the NFData class is defined for.
12:03:51 <matt_m> benmachine: What's it stand for?
12:03:56 <benmachine> reduce normal form
12:03:56 <c_wraith> reduce to normal form
12:03:59 <matt_m> reduce normal ya
12:04:02 <benmachine> :)
12:04:23 <ski> hm, right .. it has type `a -> ()', rather than `a -> a'
12:04:29 <benmachine> ski: well, it's a typeclass, so it does whatever the library author was clever enough to do :P
12:04:37 <benmachine> there are several versions
12:04:55 <benmachine> there's a deepSeq now which is a -> b -> b
12:05:04 <benmachine> or, something
12:05:07 <benmachine> I forget how it works
12:05:11 <benmachine> /if it works
12:05:21 <c_wraith> that's the right sig, except the s isn't capitalized :)
12:05:29 <ski> @type \f -> \x -> rnf (f x) `seq` f x
12:05:29 <lambdabot> forall t a. (NFData a) => (t -> a) -> t -> a
12:05:34 <c_wraith> But it's really just deepseq x y = rnf x `seq` y
12:05:44 <benmachine> so it isn't
12:06:09 <c_wraith> ski has invented $!!
12:06:20 <c_wraith> I have no clue if there's a function named that, but the name is appropriate
12:06:25 <hpc> :t $!
12:06:27 <lambdabot> parse error on input `$!'
12:06:27 <c_wraith> it's the *really* strict apply function :)
12:06:32 <hpc> heh
12:06:38 <c_wraith> :t ($!)
12:06:40 <lambdabot> forall a b. (a -> b) -> a -> b
12:07:13 <ski> c_wraith : well, my point was to make an instance of something like `NFData a => a -> a', assuming `a = (b -> c)', where `NFData c'
12:07:19 <c_wraith> except ski's version doesn't introduce sharing for f x
12:07:24 <c_wraith> So it doesn't actually work
12:07:24 <jmcarthur> $!!!
12:07:27 <c_wraith> You need a let :)
12:07:47 <ski> c_wraith : hm, which sharing ?
12:08:08 <jmcarthur> :t \f x -> let y = f x in rnf y `seq` y
12:08:09 <lambdabot> forall t a. (NFData a) => (t -> a) -> t -> a
12:08:18 <ski> oh, right
12:08:34 * ski blames the internet
12:08:41 <jmcarthur> waitaminute
12:08:49 <monochrom> well-typed internets can't be blamed
12:08:49 <jmcarthur> :t rnf
12:08:50 <lambdabot> forall a. (NFData a) => a -> Done
12:08:53 <jmcarthur> oh right
12:09:22 <ski> monochrom : oh, but we all know the internets are far from well-typed ..
12:09:23 <hpc> what's Done?
12:09:27 <c_wraith> ()
12:09:30 <jmcarthur> nothing useful
12:09:36 <jmcarthur> you just have to force it
12:09:37 <hpc> ah
12:10:01 <c_wraith> anyone have any ideas for determining if a value is in normal form, other than abusing vacuum?
12:10:04 <jmcarthur> why doesn't rnf have a type like seq?
12:10:24 <jmcarthur> c_wraith: that shouldn't be observable, should it?
12:10:47 <c_wraith> jmcarthur: It really shouldn't be.  I just want to know if I need to benchmark rnf, or if whnf will do
12:11:22 <benmachine> c_wraith: you could use Debug.Trace?
12:11:33 <benmachine> well
12:11:35 <hpc> alternatively, profile
12:11:37 <c_wraith> benmachine: but I didn't write the function I'm benchmarking
12:11:40 <benmachine> oh
12:11:41 <benmachine> ouch
12:11:50 <c_wraith> If I had written it, I'd know if it returned normal form. :)
12:12:24 <jmcarthur> c_wraith: what kind of interface do you have for constructing the value? would it be meaningful to trace the inputs?
12:12:41 <c_wraith> I'm using decode :: ByteString -> JSON
12:12:47 <c_wraith> Not much flexibility there.
12:13:12 <jmcarthur> you could map over the bytes with trace, perhaps
12:13:19 <jmcarthur> you would at least be able to see if all the bytes are read
12:13:27 <jmcarthur> wait, it's strict
12:13:29 <jmcarthur> nevermind
12:13:31 <c_wraith> All the bytes are certainly read
12:13:49 <c_wraith> and yes, it's the strict bytestring interface
12:13:50 <jmcarthur> well, i meant used, but it's still moot
12:13:54 <c_wraith> So that wouldn't work
12:13:58 <jmcarthur> even if it was the lazy one it would be chunked
12:14:38 <c_wraith> I feel like the answer is "vacuum"
12:14:51 <c_wraith> well, and vacuumLazy
12:14:57 <c_wraith> And seeing if they produce different results
12:15:04 <jmcarthur> yeah
12:15:09 <jmcarthur> i think so too
12:15:35 <jmcarthur> you could rip out some of vacuum's internals if you don't want the full functionality, perhaps
12:16:02 <c_wraith> well, I only need to make this check once for each lib
12:16:04 <c_wraith> that's not so bad
12:16:17 <monoidal> > (iterate (\k -> concatMap (\(x:y) -> map (x:) (k y)) . init . tails) (const [[]]) !! 3) [1,2,3,4]
12:16:18 <lambdabot>   [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
12:16:30 <cdsmithus> Okay, how about a game of "What am I doing wrong now?"  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25359  C code works, but the Haskell code doesn't.  Ideas?
12:17:24 <jmcarthur> what you're doing wrong is using Network.Socket ;)
12:17:42 <kmc> "The Network interface is a "higher-level" interface to networking facilities, and it is recommended unless you need the lower-level interface in Network.Socket."
12:17:47 <kmc> but, perhaps you do
12:18:02 <cdsmithus> It wasn't clear to me how to send UDP packets with the higher-level protocol
12:18:16 <kmc> cdsmithus, a nice way to compare the programs would be strace
12:18:46 <cdsmithus> kmc: Oh, great idea!
12:20:35 <c_wraith> yep...  the result is not in normal form.
12:20:54 <c_wraith> also, I think this vacuum is going to eat all my ram
12:21:36 <b0fh_ua> Hello! How do I map list of functions to single argument (object) and produce list of application results? Something similar to "map"
12:21:57 <kmc> > map ($3) [pred, succ, (+7)]
12:21:58 <lambdabot>   [2,4,10]
12:22:15 <b0fh_ua> nice, thanks :)
12:22:19 <xerox> > [succ,(*2),(10^)] `sequence` 1
12:22:20 <lambdabot>   [2,2,10]
12:22:27 <xerox> > [succ,(*2),(10^)] `sequence` 10
12:22:28 <lambdabot>   [11,20,10000000000]
12:22:29 <xerox> :P
12:22:50 <ezyang> > [succ,(*2)] <*> return 1
12:22:51 <lambdabot>   [2,2]
12:22:55 <kmc> ah, that's a good one too
12:23:03 <xerox> ezy's scales
12:23:21 <c_wraith> but you used return!
12:23:26 <c_wraith> mixing idioms!
12:23:30 <kmc> > [(+),(*)] <*> [1,2] <*> [30,40]
12:23:31 <jmcarthur> at least you pure ;)
12:23:31 <ezyang> Oops!
12:23:31 <lambdabot>   [31,41,32,42,30,40,60,80]
12:23:33 <c_wraith> Wouldn't "pure" have been better?
12:23:33 <jmcarthur> *use
12:23:39 <ezyang> Yeah...
12:23:42 <xerox> > [(+),(*)] <*> [1,5] <*> [2,6]
12:23:43 <lambdabot>   [3,7,7,11,2,6,10,30]
12:23:47 <xerox> late
12:24:00 <jmcarthur> actually, just 1 would have been best. if only there was a Num instance for functions
12:24:11 <duairc> Hey, I'm running a Debian system and I've installed some packages with cabal-install, but when I go to ghci it can't seem to find them. Is there something I have to do to make it work?
12:24:32 <jmcarthur> err
12:24:44 <jmcarthur> for lists i guess
12:25:17 <hpc> on debian, packages tend to be easier to work with using apt
12:25:35 <duairc> I know, but this particular package (haskore) isn't packaged yet
12:25:43 <kmc> yeah, many of them aren't
12:25:54 <stroan> duairc: did you install as root?
12:26:07 <duairc> stroan: Hello :) No, I didn't
12:26:24 <stroan> and the libs are in ~/.cabal/lib/ ?
12:26:30 <duairc> Yep, they're definitely there
12:26:50 <c_wraith> So, then.  anyone see anything horrible or wrong with my NFData implementation?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25360
12:27:19 <whald> is there a cheap way for doing computing the last two expressions in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25361#a25361 in parallel?
12:27:40 <whald> (dual-core, concurrent, faster, you know :-) )
12:27:53 <kmc> c_wraith, why bring deepseq into it?
12:27:58 <kmc> nfdata is supposed to be self-contained
12:28:07 <luite> is some additional configuration necessary to make the GL library work on the mingw installation included in the haskell platform? running gcc -lGL does not work
12:28:20 <kmc> c_wraith, e.g. rnf xs
12:28:39 <c_wraith> oh, right.  that is silly, but it should be a miniscule change in runtime
12:28:49 <kmc> c_wraith, what's the type of Object?
12:29:03 <kmc> whald, which expressions?
12:29:04 <c_wraith> Data.Trie ByteString JSON
12:29:17 <c_wraith> err, is the ByteString implied in Data.Trie?
12:29:23 <kmc> tricky
12:29:36 <whald> kmc: the "ws <- ..." and the addSample
12:29:46 <kmc> c_wraith, think so
12:29:54 <kmc> if it's from the bytestring-trie package
12:29:58 <c_wraith> yeah, it is
12:30:13 <c_wraith> So, it's just Trie JSON
12:30:52 <whald> kmc: the first function computes a image sample and the second patches it into the image, these are 40/60 in cpu ticks, so using both cores would be nice.
12:31:20 <c_wraith> yeah.  changed to just use rnf rather than deepseq, and as expected, a minimal improvement
12:31:34 <kmc> c_wraith, the issue is that your nfdata instance is slow?
12:31:48 <whald> kmc: if it's possible without much trouble that'd be nice -- if not i'll have to take care of concurrency "for real" with > 2 threads at some point anyway
12:32:11 <kmc> whald, right.  don't use concurrency when parallelism will do
12:32:18 <c_wraith> The issue is "parsing the data + rnf" is really slow.  I'm just trying to make sure rnf isn't the bad part of the runtime.
12:32:19 <kmc> c_wraith, the trie is slightly an issue -- you can't *really* write an NFData instance for an abstract type
12:32:37 <whald> kmc: sorry, these terms are not clear to me
12:32:38 <kmc> but what you have is reasonable
12:33:51 <siracusa> On Windows GHC includes a GCC compiler, does GHC need exactly that GCC version or can I replace it with another?
12:34:08 <whald> kmc: "reasonable" as in "it's reasonable to do this in parallel, and quite simple too" ?
12:34:13 * hackagebot hpage 0.8.4 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.8.4 (FernandoBenavides)
12:34:14 <c_wraith> whald: think of it as concurrency: when the order of evaluation affects the result.  parallelism: When the order of evaluation doesn't change results
12:34:23 <cdsmithus> Whoa!  That's odd... it's getting the port byte order wrong... but I didn't see an equivalent of htons in Network.Socket.
12:34:46 <kmc> whald, parallelism is using multiple cores merely at the implementation level, to make a deterministic program faster
12:34:57 <kmc> concurrency is writing a program whose meaning is in terms of multiple threads
12:35:11 <kmc> in most languages concurrency is the only way to get parallelism
12:35:13 <kmc> anywya
12:35:26 <kmc> whald, so addSample depends on the result of ws
12:35:30 <kmc> i mean it depends on ws
12:35:34 <kmc> which is the result of runRandST
12:36:12 <kmc> whald, so how could they execute in parallel? is ws a lazily-produced list or something?
12:36:32 <cdsmithus> OH!  Found my mistake, then.  Apparently you should use the Num instance for the PortNumber type, not the exported constructor.  The Num instance does the byte order swapping
12:36:43 <kmc> cdsmithus, tricky
12:37:31 <whald> kmc: i thought one thread could wait for a ws (weighted sample), and applies it when there is one. and the other one generates the samples (blocking if there is one which the other has not yet applied)
12:37:35 <cdsmithus> Clever, though!  But PortNum (the contructor) should probably not be exported then!  Or at least come with stern warnings
12:37:56 <FunctorSalad> is there a package that has all the basic combinators we know and love from haskell, for elisp?
12:38:14 <whald> kmc: the blocking would hardly be an issue as usually the "apply" is faster than the "generate
12:38:16 <whald> +"
12:38:19 <FunctorSalad> not the types of course, but various composition operators, folds etc
12:38:51 <ski> cdsmithus : i was just about to ask whether you made the mistake of using the constructor ..
12:38:56 <kmc> whald, ah.  so you want to change the structure a bit
12:39:34 <whald> kmc: i know this way of doing it is not exactly rocket science, but if i get a ~2x speedup without much trouble... yikes! :-)
12:40:14 <whald> kmc: what buggs me is the ST monad, i still don't get used to what it implies exactly
12:40:16 <FunctorSalad> (maybe one could even make a rudimentary typesystem through compile-time evaluation/macroexpansion)
12:40:21 <jmcarthur> your proposed idea sounds like concurrency, not parallelism, so the first step would be to go to IO instead of ST
12:40:29 <kmc> whald, ST is just imperative programming with mutable variables
12:40:31 <whald> kmc: if it helps: "s" tends to be "RealWorld" here :-)
12:40:41 <kmc> yeah
12:40:49 <kmc> i think jmcarthur's right, this will be easier to express as concurrency
12:40:53 <kmc> but what i'm kinda wondering
12:41:00 <kmc> is if you really want to parallelize that "map"
12:41:20 <jmcarthur> seems like this could be restructured in a pure way, to me, then parallelism would make more sense
12:41:22 <kmc> however, evaluating to get [ST s ()] in parallel is probably not useful
12:41:29 <kmc> you want to *execute* in parallel
12:41:33 <kmc> and then we're back to concurrency
12:41:49 <jmcarthur> where does the runRandST come from?
12:41:56 * jmcarthur is guessing mersenne or something
12:42:56 <whald> jmcarthur: that my (actually Saizan's) helper to let me use the mwc-random without much trouble: runRandST :: Gen s -> Rand a -> ST s a
12:43:01 <jmcarthur> ah
12:43:16 <whald> and newtype Rand a = Rand {unR :: (forall s. Gen s -> ST s a) } -- whatever that means :-)
12:44:13 <kmc> whald, what would you like to understand better about ST?
12:44:23 <jmcarthur> i think what i would do is pregenerate a bunch of random numbers and then feed those into a pure (non-ST) function that maps over it in parallel. i think that would work
12:45:00 <jmcarthur> the types would work out, it appears
12:45:00 <whald> well, the absolutely simplest approch to parallelism here would be to let 2 instances of "onePass" run in parallel, but the cache thrashing from accessing all that pixels would eat any benefit i guess
12:45:14 <jmcarthur> whald: does my suggestion sound plausible?
12:45:15 <kmc> whald, try that first
12:45:21 <kmc> since it's so simple
12:46:28 <jmcarthur> because a pure parallel map is very easy and has pretty low overhead
12:46:36 <whald> jmcarthur: i can't know in advance how many random numbers i'll need, but just having two "Gen"s around would be no problem
12:47:02 <kmc> i'm worried about this plan, because i think these threads actually write into a mutable image
12:47:04 <kmc> via addSample
12:47:24 <jmcarthur> oh right
12:47:42 <kmc> but you can generate the ImageSample values
12:47:45 <jmcarthur> that specific part would need to be sequential
12:47:53 <kmc> force them to normal form
12:48:21 <jmcarthur> or changed to use some sort of monoid representing the image so that you can do some divide and conquor style parallelism
12:48:37 <jmcarthur> be a lot of copying in this case though i bet
12:48:40 <jmcarthur> or gc
12:48:43 <whald> kmc: i've tried that ultra-simple approach already several times (C, C++, Java) -- it never did any good and i think doing it again in haskel won't be good for a surprise?
12:49:15 <kmc> so the strategy is: 1) generate random numbers 2) parMap rnf makeImageSample ... 3) mapM_ (addSample img) ...
12:49:22 <kmc> whald, ok
12:49:41 <jmcarthur> yeah that's what i would try
12:50:02 <whald> maybe it could work like that: generate let's say 100 samples in parallel, stop the world, apply these sequentially, go for the next samples until done
12:50:24 <jmcarthur> whald: how do you know how many samples to do?
12:51:00 <whald> its for every pass width * height * samples per pixel
12:51:01 <luite> I'm trying to install FTGL-1.333 on windows, which requires the FTGL library. I'm trying to add that library to my haskell platform installation, but it complains that it cannot find -lGL in the haskell platform mingw installation. what should I do to fix this?
12:51:31 <jmcarthur> whald: it looks like that's how many random numbers to generate then, right?
12:51:47 <jmcarthur> i'm not talking about ox and oy
12:51:55 <Cale> Is there ongoing work to put constraint families into GHC 6.14?
12:52:16 <jmcarthur> Cale: not that i know of, and i want it
12:52:19 <whald> jmcarthur: no, that ox and oy is only to jitter the already stratified samples a little, but that's not the problem
12:53:01 <jmcarthur> whald: is int scene ((sceneCam scene) (px / sx, py / sy)) generating a dynamically determined number of random values?
12:53:03 <whald> jmcarthur: the majority of random numbers are consumed inside the Integrator (and depending how long a ray keeps bouncing around the # of required numbers varies)
12:53:19 <whald> jmcarthur: exactly
12:53:19 <jmcarthur> ah
12:53:24 <jmcarthur> that sucks then
12:53:57 <whald> jmcarthur: it makes for pretty images though :-)
12:54:19 <jmcarthur> if only mwc-random supported split
12:54:40 <jmcarthur> then you could create a bunch of independent generators and use them in parallel
12:54:55 <Cale> You might be able to cheat...
12:54:59 <jmcarthur> (and if only it was pure, that is)
12:55:11 <Cale> (though that's the pathway to madness)
12:55:12 <whald> jmcarthur: i think that's the least trouble, i have no problem having multiple generators around
12:55:41 <jmcarthur> whald: i just mean it would be almost trivial if it was pure and had split
12:56:30 <whald> jmcarthur: so the fact that mwc-random exposes it's ST use is beyond my lack of understanding? good. :-)
12:56:59 <eps_> I have the functions date and laterDate with the type :: (Int,Int,Int) ... I want to pass dates (a,b,c) input to laterDate but date (a,b,c) = laterDate (a,b,c) doesn't work.  where should I look to fix this?
12:56:59 <whald> (insert "bad" between "is" and "beyond")
12:57:07 <jmcarthur> whald: it exposes it because of some almost-but-not-entirely-baseless notion that it's necessary for performance
12:59:08 <Cale> eps_: I'm afraid I'm not sure what you mean there...
12:59:42 <Cale> eps_: What are the full types of 'date' and 'laterDate'?
13:00:06 <whald> jmcarthur: so to sum it up, parallelism at this level is not a cheap goal. that's not really bad, i'll go for some for of tiled rendering sometime soon, and distributing the tiles across thrads (possibly hosts) will be a design goal then anyway
13:00:09 <eps_> date :: (Int,Int,Int) -> Int    laterDate :: (Int,Int,Int) -> Bool
13:00:28 <eps_> I am not sure how to send a,b,c from date to laterDate, the syntax or method?
13:00:32 <Cale> eps_: Okay, so your problem is that  laterDate (a,b,c)  there is a value of type Bool
13:00:40 <whald> now that my "c" is fixed, my "m" is dying. :-/
13:00:45 <Cale> eps_: while your date function is supposed to be producing an Int
13:00:57 <djahandarie> Done with finals. \o/
13:01:06 <eps_> Cale, oh sorry I Bool is fine for date
13:01:19 <eps_> I need to pass abc to laterDate so it can do a check on it, but I get this error
13:01:27 <Cale> What error?
13:01:55 <eps_> oh, wait, I might not have a syntax error ... it may be a logic error, just a moment
13:02:00 <Cale> If they have the same type, you can certainly make date and laterDate into the same function.
13:02:15 <Cale> and nothing about the syntax you had there was obviously wrong
13:02:19 <eps_> Cale, yes it looks like I may have a > the wrong way around, just a few to check :/
13:02:25 <eps_> this might require pencil and paper!
13:03:03 <eps_> Cale, thanks for the help.  turns out all my > and <'s are backwards... little embarrassing :P
13:03:16 <Cale> eps_: okay :)
13:04:31 <eps_> my excuse is I'm still learning!
13:04:37 <EvanR-work> heh logic error
13:04:54 <EvanR-work> compiler needs to check for those
13:05:09 <Cale> eps_: That's fine :) Don't be afraid to ask questions here :)
13:05:35 <hpc> i should be able to open a terminal and type nincompoop@localhost$ ghc make me a program that is awesome
13:06:02 <Cale> whald: We really need a complement of better implementations of pure pseudorandom number generators in Haskell.
13:06:38 <hpc> i wouldn't mind having an implementation that isn't monadic
13:06:53 <hpc> if it is just a random number, the order shouldn't matter
13:06:58 <Cale> whald: Bindings to existing C libraries have the problem that C programmers mostly don't understand why static state is a bad idea.
13:07:36 <hpc> shouldn't need IO for randomness
13:07:44 <djahandarie> hpc, these days you can almost do "give me a program that does x,y,z" as long as you are satisfied with the current implementations of x, y, and z.
13:08:02 <hpc> heh, true
13:08:09 <Cale> hpc: Well, we should have more libraries which are explicit about the type of the generator state, and which support splitting of generators and such.
13:08:15 <whald> Cale: yeah, it's like the average Java guy thinks singleton is the answer to all problems. and -whoa- i'm doing design patterns, that's cool :-)
13:08:54 <Cale> We really need someone who is really knowledgeable about PRNGs to come up with a fast PRNG with a provably good split function.
13:09:21 <fax> what about those USB things which have random in them
13:09:42 <EvanR-work> Cale: i made a nice generator as a lazy list, but split either became slower on each split or it would not be independently random
13:10:10 <whald> Cale: that's already been done: http://xkcd.com/221/ -- it's even pure
13:10:18 <jlouis> Cale: provably good, or demonstratably good? Most PRNGs are "good" on the grounds that they survive any kind of nonrandomness test you throw at them
13:10:19 <EvanR-work> ive been trying to understand the split interface, rational, currently state of the art, but no one in here wanted to talk about it
13:10:42 <Cale> jlouis: Well, either one would do :)
13:10:51 <jlouis> Cale: that is indeed true :)
13:10:55 <Cale> jlouis: But provably good is better than demonstrably good :)
13:11:10 <fax> EvanR-work - I would if I had a chance of understanding it
13:11:35 <fax> I heard someone say that the random interface is impossible to use
13:11:36 <jlouis> and perhaps a lot harder. demonstratably good only takes some coding skills and plenty of time. Not a divine streak of mathematical inspiration
13:11:49 <Cale> yeah
13:12:12 <EvanR-work> what is popular opinion of System.Random.MWC
13:12:43 <Cale> But I still think that there ought to be some theory we could throw at this, and I see it as a missing chunk of computer science that treatments of pseudorandom number generation have ignored this obviously-important operation.
13:13:40 <whald> EvanR-work: i love it for it's speed, and for my use i can say that the distribution seems nice. i have no clue what a crypto person will think about it
13:13:57 <cocon> is it possible for garbage collection to take more than a minute (programe uses ~10GB RAM, no swapping observed)
13:13:59 <cocon> ?
13:14:18 <EvanR-work> whald: anything with marsaglia and MWC attached typically passes at least dieharder, for what its worth
13:14:46 <Cale> cocon: hm?
13:15:17 <EvanR-work> fax: it seems to me that splitting a infinite list of random numbers is as simple as taking every other element?
13:15:28 <Cale> cocon: run your program with +RTS -B
13:15:38 <cocon> Cale: I'm doing that
13:15:39 <Cale> cocon: It'll sound the bell at the start of each GC.
13:15:51 <fax> EvanR-work, not so simple
13:15:56 <whald> EvanR-work: these diehard tests and whatever are most probably of some use, but if i want to see if a prng is good for me i draw like 1 billion samples, paint them to an image and look if it's uniform grey or if i see patterns
13:16:01 <fax> that's a good specification
13:16:04 <fax> but not a good implementation
13:16:06 <cocon> Cale: the bell rings pretty often, then stops
13:16:10 <Cale> mm...
13:16:15 <EvanR-work> fax: ok, just checking
13:16:19 <whald> EvanR-work: and there are prngs which pass standard test yet produce visible artifacts
13:16:22 <Cale> cocon: Perhaps there is a very tight non-allocating loop somewhere.
13:16:34 <EvanR-work> its bad because you cant split very many times before you get exponential decrease in performance?
13:16:36 <Cale> cocon: If there's allocation, there should be a chance for garbage collection
13:16:51 <cocon> Cale: that's what I'm trying to figure out -- but I would like to exclude the possibility that it's garbage collecting for more than a minute
13:17:13 <EvanR-work> whald: well i use to draw random pixels with crappy rngs and i saw no patterns
13:17:18 <tab> talking about PRNG, do you guys know of one CSPRNG in haskell ?
13:17:31 <Cale> cocon: That seems very unlikely to me, but hmm...
13:17:39 <c_wraith> tab: I'm in the middle of writing one, but good performance is a nightmare.
13:18:14 <whald> EvanR-work: that's absolutely possible. choosing a prng is not as simple as it should be
13:18:20 <Cale> cocon: ... I seem to recall that  +RTS -s  printed statistics about the amount of time that the GC ran
13:18:36 <tab> c_wraith: are you going to make a package ouf of it ? even slow ?
13:18:51 <Cale> cocon: yeah, it does. You might try that.
13:19:03 <c_wraith> tab: if I ever finish it
13:19:19 <EvanR-work> CSPRNG?
13:19:31 <EvanR-work> cryptographically secure
13:19:37 <c_wraith> yes
13:19:45 <tab> c_wraith: fair enough ;)
13:20:01 <Cale> Like Blum-Blum-Shub
13:20:21 <EvanR-work> marsaglia has this newsgroup post where he makes like 20 simple rngs in C, and says 'mix and match these to get a cryptographically secure rng'
13:20:30 <thirsteh> I still chuckle every time I hear that name
13:20:35 <EvanR-work> they each have ridiculous periods
13:20:38 <thirsteh> like pubsubhubbub
13:21:06 <EvanR-work> seems like that should be easy in haskell
13:21:41 <ezyang> <3 Blum-Blum-Shub
13:22:43 <edwardk> ezyang: blum-blum-shub always sounded like something out of the cthulhu mythos
13:23:07 <jmcarthur> whald: parallelism would normally be dead easy, if it was pure
13:23:44 <danharaj> Well, there's also writing algorithms that minimize dependencies so they can run in parallel.
13:24:11 <cocon> Cale: thanks
13:24:32 <Cale> http://en.wikipedia.org/wiki/Shub-Niggurath
13:24:33 <roconnor> ezyang: BBS is terrible
13:24:54 <roconnor> er wait
13:24:55 <jmcarthur> danharaj: that's a different kind of parallelism, but you're right
13:25:01 <c_wraith> BBS is provably as secure as RSA!
13:25:03 <roconnor> ezyang: sorry got confused wiht BSS
13:25:07 <jmcarthur> it's... kind of concurrency
13:25:12 <c_wraith> It's just...  slow.  really wlo
13:25:14 <tromp> isnt BBS quadratic residuosity?
13:25:16 <c_wraith> err, slow
13:25:27 <eps_> is it bad haskell etiquette to name my functions like myFunction? like I would in C
13:25:47 <tensorpudding> You mean the actual name myFunction, or using camel case?
13:25:54 <eps_> yes camel case
13:26:00 <jmcarthur> camel case is the usual haskell style
13:26:07 <eps_> good, thank you
13:26:07 <danharaj> unfortunately *cough*
13:26:08 <danharaj> >_>;;
13:26:14 <tensorpudding> Camel case is the primary convention in Haskell.
13:26:16 <jmcarthur> to the dismay of some of us
13:26:20 <Cale> eps_: camelCase is the default
13:26:26 <jmcarthur> i don't have a preference as long as it's consistent
13:26:43 <edwardk> blum-blum-shub-niggurath -- the only time you ever hope that your random number generator produces less entropy than expected.
13:26:45 <tensorpudding> I think camel case makes the most sense.
13:26:47 <tedm> Does anyone know anything about getting nhc & yhc to build? I asked here yesterday about nhc and was pointed to yhc, but yhc's build system seems to be incomplete
13:26:51 <Cale> I'm happy about it because I really like camelCase a whole lot better than underscores. I'm not sure why.
13:27:09 <danharaj> I like reading underscores better but writing camelCase is easier.
13:27:11 <Cale> The underscore just seems like a typographical monstrosity to me.
13:27:12 <epssy> the other one that used to be popular was underscores (according to my textbook) but that would be ugly and waste space ... my_function_to_divide_numbers
13:27:18 <epssy> agreed Cale
13:27:20 <tensorpudding> Underscores *are* obnoxious
13:27:29 <c_wraith> epssy: we normally name that one / :)
13:27:45 <tensorpudding> What alternatives to camel case and underscores do we have?
13:27:49 <epssy> what if you wanted mod and div at the same time! (or does haskell provide that...)
13:27:58 <c_wraith> :t divMod
13:27:59 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
13:28:06 <epssy> ...
13:28:08 <sioraiocht> lol
13:28:10 <djahandarie> @src divMod
13:28:10 <lambdabot> Source not found. My pet ferret can type better than you!
13:28:20 <sioraiocht> djahandarie: it's a primitive op
13:28:21 <epssy> tensorpudding, ada and fortran had different conventions I believe.  but I've been studying so much today I've forgotten
13:28:25 <tensorpudding> Hungarian notation is an aberration.
13:28:30 <djahandarie> sioraiocht, yeah that's what I was checking for
13:28:34 <Ferdirand> if you use a one-letter uppercase macro, will it interact badly with camel case ?
13:28:55 <c_wraith> a one-letter uppercase name in Haskell is either a module or a constructor
13:28:58 <epssy> you know I'm really enjoying doing these haskell puzzles.  I like how once you've worked out some thing there isn't stuffing with arrays or pointers to make it work.  very straight forward
13:28:59 <sioraiocht> djahandarie: yeah it's not divMod x y = (x `div` y, x `mod` y)
13:29:05 <tedm> yhc seems to use scons, but it's missing it's SConstruct file - and the readme implies that it needs to be part of a larger distro tree (perhaps nhc's?)
13:29:40 <djahandarie> sioraiocht, considering that div and mod are probably implemented using divMod, that'd make sense
13:29:45 <Berengal> I'd be a really happy camper if I could use hyphenated-variable-names
13:29:53 <Cale> epssy: Sometimes arrays are good for memoisation, but yeah, no pointers :)
13:30:05 <c_wraith> Berengal: that'd make me feel markuptastic
13:30:28 <c_wraith> though I guess lisp allows it, too
13:30:43 <epssy> I don't mind the pointers so much, it's the plague of excessive syntax and little rules.  so far in haskell the hardest rules has been foldr and foldl but I'm getting the hang of it
13:30:43 <tensorpudding> We could have tried emulating Lisp.
13:31:01 <djahandarie> I want every infix operator to automatically become possible to use in a variable name
13:31:06 <hpc> i would be really happy if Haskell made function application require whitespace between tokens
13:31:07 <djahandarie> Just to introduce as much ambigouity as possible
13:31:20 <tensorpudding> Except Lisp's got stupid-long-function-name, and badabbreviationp for predicates
13:31:35 <Berengal> c_wraith: lisp is where I got it from. I know it's the best, since I've only a little lisp, and I still think it's much better than camelCase, despite programming the most in java or haskell.
13:32:08 <tedm> it really looks from the mailing list like someone is regularly building nhc, but the darcs version is just completely broken as far as I can tell :-(
13:32:49 <Cale> Yeah, hyphenation doesn't bother me like underscores do and I think it looks marginally better than camelCase, but you do give up some whitespace insensitivity around subtraction.
13:33:03 <opqdonut> i think hyphenation is the best-looking
13:33:06 <Cale> That might be acceptable though.
13:33:20 <opqdonut> but complicating infix minus is a serious downside too
13:33:26 <epssy> it is adding extra chars for function names though, it seems very pointless
13:33:28 <opqdonut> one should just use a different hyphen for those ;)
13:33:29 <tensorpudding> Having long identifiers is never ideal.
13:33:32 <jmcarthur> what'about'this'convention? ;)
13:33:37 <Cale> It's really exponentiation where I think enforcing whitespace looks bad.
13:33:38 <epssy> maybe I am just used to camel
13:33:48 <hpc> jmcarthur: ugly
13:33:53 <jmcarthur> i jest
13:34:09 <djahandarie> jmcarthur, I can't tell what's quoted and what isn't!
13:34:42 <djahandarie> My inner grammar demon is burning!
13:34:53 <hpc> no wait, that's a syntax error; you have the closing paren after the semicolon :P
13:35:26 <Cale> > (do x <- [1,2,3]; y <- [4,5]; return (x,y);)
13:35:27 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
13:35:40 <tedm> oh well - maybe I'll post to nhc-users
13:35:51 <Cale> do-notation supports empty statements
13:36:22 <Cale> tedm: What got you interested in NHC?
13:36:45 <tedm> I want something I can build for arm&mips
13:37:14 <tedm> ghc doesn't seem to be the best choice for that without working on the NGC plumbing
13:37:19 <tedm> NCG
13:38:30 <tedm> Small executable size if appealing too, but I don't know just how much better nhc is on that front than ghc without having actually used nhc myself
13:39:28 <monochrom> > do { } :: [Int]
13:39:28 <lambdabot>   <no location info>: Empty 'do' construct
13:39:50 <monochrom> > do { ; ; ; return 0 ; ; ; } :: [Int]
13:39:51 <lambdabot>   [0]
13:40:10 <hpc> > do {;}
13:40:11 <lambdabot>   <no location info>: Empty 'do' construct
13:40:13 <monochrom> would be nice if it supported:
13:40:20 <monochrom> > [, , , 0 , , ,]
13:40:21 <lambdabot>   <no location info>: parse error on input `,'
13:40:44 <hpc> you can't have empty array elements
13:41:06 <monochrom> I do not intend empty array elements
13:41:25 <Cale> Empty list elements
13:41:34 <monochrom> I do not intend empty list elements either
13:41:38 <Cale> GAP supports those
13:41:56 <hpc> so [,,,0,,,] == [0]?
13:42:00 <monochrom> Yes.
13:42:04 <Cale> gap> [,1,,,2,3,,,,4];
13:42:04 <Cale> [ , 1,,, 2, 3,,,, 4 ]
13:42:05 <hpc> what's the point?
13:42:10 <tedm> Cale: I might just have another look at getting ghc to do what I want it to do - I'm not sure what the state of the llvm patch is, but that might be easier than resurrecting nhc/yhc/jhc
13:42:21 <xerox> Cale: hahaha
13:42:46 <monochrom> Here is a practical use. [ \n 0, \n 1, \n 2, \n ]
13:42:56 <tromp> anyone interested in counting number of chess positions?
13:43:13 <Cale> tedm: Yeah...
13:43:15 <monochrom> When you add or remove elements, you don't have to "fix up extra commas", "fix up missing commas".
13:43:39 <monochrom> Here is another one: [ \n , 0 \n , 1 \n , 2 \n ]
13:43:41 <Cale> tedm: Also, you'd have the advantage of having the GHC frontend, which has lots of features.
13:44:46 <tedm> Cale: If I could get haskell in any form working where I want it to, I'd be a happy camper. At this point Hugs would be just fine
13:45:21 <Cale> tedm: What sort of ARM or MIPS machines are you using?
13:45:24 <monochrom> You just make sure: every line is one single element; every line has one single comma, no exception in the first element or the last element.
13:45:57 <Ramb0> @src all
13:45:57 <lambdabot> all p =  and . map p
13:46:01 <monochrom> "empty statement" "empty element" are really wrong ways to understand what I describe.
13:46:04 <Cale> (I'm just curious, I don't really know a whole lot about getting Haskell working on such strange platforms)
13:46:11 <tedm> Really, none of the problems with nhc seem to be that difficult - it's just that someone moved some stuff around without checking that it would work with a clean build - easy fixes mostly. It's really my inexperience with darcs that's holding me back
13:46:50 <monochrom> The right way is "punctuation that doesn't hurt if redundant"
13:47:00 <Cale> tedm: oh, well, if you have questions about darcs, this channel is probably not a bad place to ask :)
13:47:08 <tedm> Cale: One is a single board computer with a mips chip in it - mostly used for routers. Another would just be smartphones - iphone/n900 etc
13:47:08 <Cale> (I think there's also a #darcs though)
13:48:34 <monochrom> For example if I write (2+3), you just think my parentheses are redundant but harmless, you don't think my parentheses indicate the presence of some empty operation.
13:48:56 <tedm> Cale: I'm very new to Haskell, but this is basically my effort to avoid programming in c++ anymore :-)
13:48:59 <kmc> i would in Lisp ;P
13:49:22 <hpc> monochrom: you would hate Perl then; (2+3) is a list with one element
13:49:39 <hpc> parens are overloaded for arrays and operator precedence
13:49:44 <monochrom> I have grown out of hating Perl.
13:49:56 <monochrom> Perl is now irrelevant and non-existent to me.
13:50:03 <monochrom> What is Perl? :)
13:50:34 <monochrom> You mean Perl people haven't all switched to either python or php? :)
13:51:40 <hpc> PHP is even worse lol
13:52:16 <tensorpudding> I'm not sure what the big deal about Perl was.
13:52:20 <bremner> monochrom: but PHP is not irrelevant to you? You poor sod.
13:52:29 <monochrom> Yes. I thought the idea was infinite descent ad infernium
13:53:20 <kmc> PHP is great if you need to write a web app and it's 2003
13:53:35 <xerox> facebook anyone?
13:53:36 <Cale> tedm: There's been a steady trickle of people interested in using GHC on ARM lately. Maybe there will be a revival there.
13:53:42 <tromp> (2+3) is not a list in perl
13:53:42 <monochrom> php is relevant to me just to the point that some websites I visit use php. I am still glad I haven't learned it.
13:53:54 <kmc> you should claim to know PHP anyway
13:54:02 <kmc> because it's easy (though bad) and will help you get a job
13:54:05 <hpc> tromp: eh?
13:54:13 <Cale> http://hackage.haskell.org/trac/ghc/wiki/Platforms indicates that at some point ARM was somewhat supported (though with no registerisation or GHCi)
13:54:23 <tromp> you can add 1+(2+3)  and just get 6
13:54:40 <Cale> http://hackage.haskell.org/trac/ghc/wiki/ArmLinuxGhc seems to have a bunch of information (though possibly out of date) about getting it to work
13:54:42 <hpc> that's operator precedence though
13:54:47 <monochrom> Whereas perl is so irrelevant that those websites don't use perl anymore (at least, not visibly), and I haven't even told my ghc to invoke its perl evil mangler.
13:54:50 <kmc> i would expect to get better ARM support with LLVM
13:54:55 <hpc> you can also do @array = (2+3);
13:55:15 <tedm> Cale: with good reason I guess. I have a ton of experience (about 10 years) with mips - I could probably make some sort of useful contribution to ncg for that. arm I'm pretty new to though and I think I'd end up doing more harm than good :-)
13:55:53 <tromp> yes, perl will change between scalar and 1 element list in context
13:56:28 <tedm> kmc: Yeah - we were just talking about that. I'm thinking of doing a ghc build with the llvm patch to see if I can get that working.
13:56:45 <tromp> hmm, it's more subtle. i tried @a=(5), x 1+@a, and get 5
13:56:57 <tromp> ok, perl is just weird
13:57:02 <hpc> see?
13:57:14 <hpc> craziness
13:57:26 <Cale> Perl is the English of computer programming languages
13:57:29 <jmcarthur> yeah perl scares me
13:57:45 <benmachine> english is pretty
13:57:49 <benmachine> sometimes
13:58:06 <kmc> english may be pretty but it's not too effective for describing precise instructions
13:58:09 <hpc> english is the language of monstrosities like Buffalo buffalo buffalo buffalo buffalo buffalo.
13:58:19 <jmcarthur> i think that's not enough buffalos
13:58:24 <hpc> probably
13:58:33 <jmcarthur> i bet it can be made to work though
13:58:33 <kmc> > cycle "buffalo "
13:58:33 <tromp> any number of buffalo's is valid
13:58:34 <lambdabot>   "buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo bu...
13:58:38 <jmcarthur> *any* number?
13:58:39 <Cale> Every number of buffalos will work
13:58:42 <tromp> yes
13:58:43 <Cale> yeah
13:58:43 <hpc> the point being, English has twice the unique words of the next language
13:58:45 <tedm> interesting - so you can actually build code with ghc even if the evil mangler isn't supported...
13:58:46 <jmcarthur> didn't realize
13:58:58 <hpc> and you still have overloaded words all over
13:59:03 <hpc> and for the most awkward things
13:59:08 <Cale> tedm: Yeah, the evil mangler is only needed for compilation via-C which is deprecated anyhow.
13:59:23 <kmc> deprecated, but still produces better code sometimes
13:59:28 <Cale> tedm: It mangles the GCC output into something which actually runs :)
13:59:54 <hpc> what's the evil mangler?
14:00:04 <tedm> Cale: is via-C deprecated in favour of llvm?
14:00:04 <Cale> hpc: A perl script which is part of GHC
14:00:10 <hpc> oh
14:00:11 <tensorpudding> It's the reason you need Perl for GHC.
14:00:16 <hpc> -.-
14:00:17 <Cale> tedm: In favour of the new code generator.
14:00:44 <Cale> tedm: Or, well, native code generation even before the new code generator stuff went in.
14:01:20 <tedm> Cale: I'm confused now - does NCG stand for native code generator or new code generator?
14:01:21 <jmcarthur> via-C is deprecated in favor of the native code gen, but is being replaced by the llvm backend
14:01:28 <jmcarthur> native
14:01:32 <Cale> I'm confused about that too. :)
14:01:35 <tensorpudding> LLVM will be neat.
14:01:39 <Cale> It seems that some people use it for one or the other.
14:01:50 <jmcarthur> i've only ever seen it for native, personally
14:01:54 <jlouis> I can't wait for the new IO manager to enter GHC HEAD
14:01:59 <jmcarthur> either that or i have misunderstood somebody
14:02:30 <Liskni_si> Cale, tedm: Debian seems to have ghc package for arm as well, or are you all talking about cross-compiling?
14:03:03 <tedm> jmcarther, Cale: that does seem to put other platforms in a difficult state until llvm is merged
14:03:20 <jmcarthur> tedm: why?
14:03:36 <jmcarthur> oh, unable to registerize?
14:03:45 <jmcarthur> i don't know about that. dunno what the plan is there
14:04:16 <tedm> jmcarthur: via-c seems to be the only option with most other platforms according to the link Cale gave
14:04:23 * jmcarthur has no idea
14:04:30 <tedm> :-)
14:04:34 <jmcarthur> there's always other haskell compilers
14:04:37 <jmcarthur> to build ghc
14:04:39 <jmcarthur> if they work...
14:04:48 <Cale> jmcarthur: No
14:04:54 <Cale> GHC can only be compiled by GHC
14:04:56 <jmcarthur> they dont? :(
14:05:02 <jmcarthur> that's kind of lame
14:05:14 <tedm> jmcarthur: Yeah, I've been banging my head against the build system for the last few days trying to get nhc/yhc to build
14:05:38 <tedm> Haven't tried jhc yet
14:05:41 <jmcarthur> they dont' build? double frownie face!
14:05:44 <hpc> how do you compile GHC from source then?
14:05:46 <jmcarthur> jhc doesn't build
14:05:52 <hants> in order to build ghc one has to first build ghc
14:05:58 <hants> ;)
14:05:59 <jmcarthur> at least not the last time i tried
14:06:06 <jmcarthur> rather, jhc builds, but the libraries don't
14:06:22 <tedm> jmcarthur: ack - that's disappointing
14:06:33 <jmcarthur> i think it's due to containers
14:06:37 <jmcarthur> the new version
14:06:44 <jmcarthur> has some pragmas that jhc doesn't like
14:07:26 <kmc> this is one thing ocaml gets right -- the ocaml compiler is written in ocaml, but it comes with a simple ocaml interpreter written in C
14:07:34 <kmc> so it is easy to bootstrap
14:07:44 <kmc> it'd be nice if ghc would run in hugs
14:07:56 <jmcarthur> yeah
14:07:57 <kmc> seems less essential that it be compileable with other compilers
14:08:05 <tedm> jmcarthur: the build problems with nhc aren't that terrible - ccphs is easily fixed, and hmake probably would be too, but I'd like to learn a bit more about darcs before making changes just to improve my confidence level
14:08:35 <jmcarthur> tedm: nice thing about darcs is it's hard to screw up too badly
14:09:16 <RambO> Hey, I need some help here
14:09:21 <tedm> jmcarthur: that's good - I'd hate to accidentally push a weird patch up to the central depot
14:10:15 <tedm> jmcarthur: looks a bit like git, but a bit slower and much less confusing. with git you really can get into a lot of trouble very quickly
14:10:27 <RambO> I've a module, let's say "Functions" that have all my general functions, like  sort, map, etc ¿? and Im loading module1 that has an import to module2, which imports Functions.. I cant use the functions That I defined in Functions.hs
14:11:06 <jmcarthur> tedm: i love darcs. i used it back in the 1.x days but quit due to exponential merge issues, used git for a while, but switched back around darcs 2 and haven't looked back
14:11:56 <danharaj> jmcarthur: They've fixed the worst-case exponential time?
14:12:03 <jlouis> git is not especially forgiving, no :)
14:12:24 <tedm> kmc: classic bootstrap problem. I've been thinking the same thing the last few days - how nice it would be if all of these systems included a simple haskell interpreter to build. I guess the real problem is that you have to tell the compiler writers to not use any funny language extensions. I wonder how the gcc devs would react if you told them that they couldn't use any gcc-specific language extensions
14:12:35 <kmc> hehe
14:13:20 <jlouis> tedm: if you write a simple bytecode interpreter, you can get bootstrapped easily
14:13:30 <jlouis> albeit hellishly slow
14:13:46 <RambO> Sorry for repeating, can anyone give me a hand with my issue?
14:13:53 <kmc> jlouis, by bundling compiled bytecode?
14:13:59 <kmc> RambO, can you put the files on hpaste.org?
14:14:19 <RambO> Ok kmc, they are simple altought
14:14:29 <jlouis> kmc: write the bytecode interpreter in C
14:14:34 <jlouis> and yes
14:14:50 <kmc> jlouis, right.  but you do need to bundle the compiled bytecode
14:14:56 <jlouis> I remember bootstrapping MLton on FreeBSD via sml/nj. Took 3-4 days :)
14:14:57 <jmcarthur> danharaj: they have made it nearly moot
14:15:06 <jlouis> and sml/nj compiles to native code :)
14:15:16 <jmcarthur> danharaj: i have not seen or heard of it occurring since darcs 2 was released
14:15:40 <jlouis> The 2nd stage bootstrap of MLton via MLton took 15 minutes
14:16:14 <hants> how can i get the AST of haskell expressions?
14:16:31 <jmcarthur> tedm: darcs has something critical (to me) that git lacks: cherry picking and reordering that doesn't change a patch's identity
14:16:44 <fax> hants template haskell does it
14:16:53 <RambO> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25362#a25362
14:16:55 <tedm> jmcarthur: that would be interesting
14:17:02 <hants> fax: thx
14:17:10 <jmcarthur> tedm: no "would be" about it. we have it ;)
14:17:20 <tedm> jmcarthur: ;-)
14:18:14 <tedm> jmcarthur: I don't - not yet - darcs is still a weird and mysterious black-box to me. I have to set up a depot, start checking things into it, and manage it for a bit before I feel comfortable working with it.
14:18:20 <kmc> hants, read about Template Haskell if you want to do compile-time metaprogramming
14:18:44 <jmcarthur> tedm: the only time it doesn't work is when you try to have patch in your repository without having its dependencies in the repository as well, but it takes more than just chronological ordering to introduce a dependency, and darcs doesn't allow you to create an invalid state like that anyway
14:18:53 <kmc> hants, look at the haskell-src-exts package if you want a self-contained Haskell AST type / parser / printer (which is not integrated with GHC for metaprogramming)(
14:19:06 <kmc> hants, haskell-src-meta goes between the two
14:19:24 <jmcarthur> tedm: basically just imagine most of your uses for rebase being safe to use on patches that have been seen in the public eye
14:19:29 <jlouis> RambO: I rarely use GHCi, sorry
14:19:33 <hants> kmc, so template haskell runs only during compile time?
14:19:38 <RambO> np jlouis
14:20:06 <jlouis> RambO: a guess is that it is a reexport problem though. Turtle has no knowledge of Funcions
14:20:24 <kmc> hants, TH has a normal library which you can use any time.  it also adds special syntax for splices and quasiquoting, which is interpreted at compile time
14:20:30 <jlouis> It only knows about Stone
14:20:36 <tedm> jmcarthur: that would be pretty cool - git rebase is sort of considered the nuclear-option of git repository management. It's good to hear that someone got it right ;-)
14:20:45 <kmc> if you want to invoke a Haskell parser at runtime, you'll have to use haskell-src-exts unless you want to hook deep into the guts of GHC API
14:20:51 <RambO> jlouis:  But it has of Stone.. And Stone uses functions from Functions..
14:21:00 <kmc> if you want to manipulate AST you can do so with either the TH AST type or the hse AST type
14:21:06 <kmc> and haskell-src-meta converts between them
14:21:50 <RambO> jlouis: I can use functions from Functions using Functions.quickSort for example :P
14:21:55 <jlouis> RambO: yes, Stone can see all of Funcions because of the import statement. What is your problem again?
14:22:20 <jlouis> I'd guess you need an import Funcions in Turtle if you need their access from there
14:22:26 <RambO> Oh
14:22:44 <jlouis> imports are not transitive unless you reexport to my knowledge
14:22:46 <kmc> you can make a module reexport another module it imports, but it's not the default
14:23:08 <kmc> module Stone(module Stone, module Functions)
14:23:25 <jlouis> (and with good reason, the other default would be outright hard to manage)
14:23:29 <RambO> What is the best solution? I have a module of functions that will have to use in all the other modules..
14:23:33 <jlouis> and probably kill compilation times
14:24:02 <jlouis> RambO: import the module where you use it. That way a reader knows you are using them
14:24:12 <hants> i want to compile haskell functions into a different language at runtime
14:24:17 <RambO> Ok
14:24:23 <fax> hants, like LLVM?
14:24:35 <kmc> hants, where do the functions come from?
14:24:40 <hants> like cuda
14:24:45 <hants> or opencl
14:25:04 <hants> maybe i should roll my own dsel just like accelerate
14:25:09 <fax> yes
14:25:12 <fax> that is the best thing to do
14:25:17 <fax> imo
14:25:28 <hants> thought template haskell would be cool
14:25:41 <fax> I kind of don't like TH
14:25:46 <fax> but I am biased
14:26:51 <hants> okay thx
14:27:25 <tedm> I'm going to take a stab at making ghc do what I want it to do - llvm or ncg. gotta go pick up the kid from school now... thanks guys!
14:29:23 <RambO> hey jlouis, kmc thanks :)
14:29:27 <hants> are the haskell-src-exts and TH ASTs already optimized?
14:30:03 <kmc> optimized?
14:30:31 <hants> common subexpression sharing and basic algebraic laws
14:30:47 <hants> things that i should do when creating a new dsl
14:31:00 <kmc> you're asking if the hse parser does this?
14:31:32 <hants> i kinda miss the concept here i thing ^^
14:32:08 <hants> i thought i could create an AST from a haskell expressiion - and process it in another function
14:32:11 <kmc> common subexpression sharing is a good idea.  since sharing isn't normally observable in haskell, it would strictly make your code-manipulation code more space efficient
14:32:21 <kmc> hants, you can
14:32:31 <kmc> but how is that "haskell expression" represented?
14:32:34 <kmc> that is, before it's an AST?
14:32:43 <kmc> if it's a string, then you need a haskell parser
14:32:47 <kmc> hse provides that
14:33:02 <hants> i dont like strings ;)
14:33:20 <kmc> @quote stark
14:33:21 <hants> want to let it look like normal haskell code within a program
14:33:21 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
14:34:34 <fax> hants,
14:34:40 <hants> fax, yes?
14:34:50 <jmcarthur> so... you want macros?
14:34:54 <jmcarthur> that would be TH
14:34:57 <fax> data L a = Lam (L a -> L a) | L a :$: L a
14:35:04 <fax> now you can write  Lam (\x -> x :$: x)
14:35:06 <fax> and stuff like that
14:35:13 <tensorpudding> stegonagraphy is fun.
14:35:53 <tensorpudding> err, steganography
14:36:11 <fax> hants, another method is without defining any data type at all
14:36:19 <fax> but that way is maybye a bit hearder
14:36:21 <hants> fax, how that?
14:36:26 <fax> ????
14:36:39 <ddarius> That typo was actually tensorpudding communicating illicitly.
14:36:41 <kmc> yay HOAS
14:37:29 <tensorpudding> Man, that has to be some really tiny informatin if it was passed by by a typo.
14:37:40 <jmcarthur> hants: look up HOAS and rejoice
14:37:55 <hants> okay got the paper open
14:38:45 <ddarius> By land or by sea is only one bit of information.
14:39:40 <hants> well this might take some time until i get hoas
14:39:43 <hants> thx!
14:40:19 <tensorpudding> Great booleans in history, part 1
14:40:30 <c_wraith> True
14:40:49 <mejja> False
14:41:00 <danharaj> Bot
14:41:02 <jlouis> _|_
14:43:03 <fax> George
14:43:09 <fax> Mary
14:47:09 <xenoblitz> hi all
14:47:15 <xenoblitz> just wanted to share this blogpost with you
14:47:26 <xenoblitz> its about a project I am working on with haskell as a backend
14:47:40 <xenoblitz> http://lambdacolyte.wordpress.com/2010/05/06/space-generals/
14:47:58 <fax> COOL
14:48:18 <fax> you ever played escape velocity
14:48:32 <fax> where is the source code
14:49:30 <xenoblitz> fax: for now I can't share sorry... at least not until I'm done with my masters (uni rules mehhh)
14:49:41 <fax> oh that's too bad
14:49:45 <xenoblitz> fax: I will though as soon as I can
14:49:57 <xenoblitz> fax: no i haven't I'll look it up
14:49:58 <fax> I would make a big fuss about that if I was doing a programming project for uni
14:50:16 <xenoblitz> fax: its better to finish first and then its ok :)
14:50:17 <fax> it's an old old game but your screenshots reminded me of it
14:50:47 <epssy> thanks guys for your help :)
14:51:43 <xenoblitz> fax: never played it... yeah it does look similar... :)
14:52:02 <Entroacceptor> hahaha, Pluto is in another galaxy :)
14:53:23 <xenoblitz> Entroacceptor: yeah lol there are many mini-jokes if you can find them :P
14:56:01 <xenoblitz> fax: also btw I wish to share the implementation of the AI as well later btw
14:56:06 <xenoblitz> fax: all at one go
14:56:29 <fax> xenoblitz that is exciting
14:56:44 <fax> I am probably gonna have a good look at this ;)
14:58:02 <xenoblitz> fax: if you want to see what approach we are taking take a look here: http://www.cs.um.edu.mt/gordon.pace/Research/Papers/wict2009-01.pdf
15:02:42 <monoidal> is there a reason that lookup is not [(a,b)] -> a -> Maybe b by default?
15:02:52 <monoidal> other than historical one
15:02:54 <xerox> and what should it be?
15:03:10 <monoidal> i use flip lookup very often
15:03:15 <xerox> ah :D
15:05:33 <Cale> monoidal: If you're using lookup a lot, then lists are probably not the datastructure you should be using.
15:05:42 <Cale> But I agree about the type
15:05:52 <Cale> It would be much more convenient the other way around.
15:06:15 <monoidal> yes, but other data structures also have that order
15:06:38 <monoidal> HashTable, Mpa,
15:06:42 <monoidal> *Map
15:08:13 <Cale> You should never use Data.HashTable at all.
15:08:24 <Cale> But yeah, Map has that order for lookup
15:08:29 <Cale> err...
15:08:32 <Cale> :t M.lookup
15:08:33 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
15:08:37 <Cale> right
15:08:42 <Cale> :t (M.!)
15:08:43 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
15:09:12 <monoidal> this is flipped version? nice
15:09:14 <Cale> ... right, that one just fails if the key is missing
15:09:18 <monoidal> ah
15:09:23 <benmachine> inconsistency is fun
15:09:45 <Saizan> keeps you awake
15:09:51 <Twey> There's a general pattern of â<transformation> :: <main datum> -> <result>â for functions that have such a thing
15:10:19 <Twey> I think that a lookup is more intuitively considered as a transformation on the map rather than a transformation on the key
15:10:23 <Twey> Maybe I'm odd
15:10:37 <benmachine> if you are then so are we all
15:10:54 <ddarius> Twey: You are odd for considering lookup a transformation.
15:11:03 <Cale> lookup ought to be what transforms the map into a function
15:11:27 <Twey> I guess so
15:11:36 <Cale> But instead it transforms a key into a function on maps
15:11:44 <Twey> Yes, I suppose I agree with that
15:12:16 <benmachine> I can't imagine it's very oftne you want to look up one key in multiple maps
15:12:20 <benmachine> vs. one map in multiple keys
15:12:23 <benmachine> *often
15:13:54 <Twey> benmachine: *nod*
15:14:26 <benmachine> where by one map in multiple keys I mean multiple keys in one map
15:23:06 <RambO> How can I make my type to be shown by my own function?
15:23:24 <kmc> "instance Show MyType where show = ..."
15:23:50 <RambO> I use show a = asdasd
15:24:00 <RambO> But it doesn't work :(
15:24:07 <monoidal> "asdasd"
15:24:29 <RambO> instance Show Accion where
15:24:29 <RambO> show a =  "Accion: "
15:24:56 <aavogt> @src Show
15:24:57 <lambdabot> class  Show a  where
15:24:57 <lambdabot>     showsPrec :: Int -> a -> ShowS
15:24:57 <lambdabot>     show      :: a   -> String
15:24:57 <lambdabot>     showList  :: [a] -> ShowS
15:24:59 <benmachine> you need to be more specific than "doesn't work"
15:25:25 <RambO> benmachine: It is an infinite loop
15:25:27 <benmachine> usual way to do show functions is deriving (Show) which handles all sorts of corner cases
15:25:42 <benmachine> an infinite loop?
15:26:00 <monoidal> RambO, it's somewhere else
15:26:11 <benmachine> if you do show a = show a
15:26:17 <benmachine> then that is going to be a problem.
15:26:32 <benmachine> otherwise we need more information
15:27:06 <RambO> When i do newItem a b whith (Deriving Show), it show right (not formated as I like..) but when I put the .. instance Show Accion where.. and call newItem a b, it loops endlesly
15:27:21 <benmachine> hpaste.org
15:27:23 <RambO> Ok
15:28:04 <wavewave> can CHP library be used for network system?
15:28:33 <wavewave> process communication via real network.. different computers.
15:28:59 <wavewave> at current stage.
15:30:00 <kmc> RambO, when you say "deriving Show" you are asking the compiler to generate a standard instance of Show automatically
15:30:19 <kmc> if you don't like the output it produces, you'll have to not derive Show
15:30:29 <RambO> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25365#a25365
15:30:35 <RambO> I do not derive Show
15:30:50 <kmc> RambO, indent "show a = "...
15:30:51 <RambO> But if I derive Show, it works fine. if I make my own instance of Show, it loops endlesly
15:30:57 <kmc> it has to be inside the "instance" block
15:31:03 <benmachine> augh
15:31:09 <benmachine> default definitions >_>
15:31:19 <kmc> yeah...
15:31:22 <benmachine> why is it allowing that show definition?
15:31:29 <RambO> JAJAJAJA
15:31:49 <Cale> hm?
15:32:07 <RambO> Sorry, I didn't know I had to indent :(
15:32:09 <benmachine> the non-indented one should surely conflict
15:32:36 <aavogt> benmachine: so that you can implement show and get showsPrec and the opposite too
15:32:40 <benmachine> no it doesn't because imports are a higher level than toplevel
15:32:52 <benmachine> aavogt: that wasn't my question :P
15:33:31 <Cale> It's okay not to indent the 'show', but evil :)
15:33:57 <Cale> It shadows the Prelude definition of show, and you have an empty instance.
15:34:23 <kmc> yeah
15:34:31 <kmc> i wonder if ghc -Wall would be useful here
15:34:53 <jlouis> wavewave: yes?
15:35:00 <aavogt> yes, Warning: Defined but not used: `Rock.show'
15:35:17 <Cale> Nope, that's not related...
15:35:25 <aavogt> RambO: also, when you paste something, it should be self-contained
15:35:26 <Cale> It doesn't have the one warning which actually matters
15:35:32 <benmachine> aavogt: unless you *did* use it
15:35:34 <jlouis> wavewave: no, CHP cannot to my knowledge distribute over multiple machines
15:35:42 <RambO> aavogt: What?
15:35:49 <aavogt> as in, don't reference things you don't include in the paste
15:35:57 <jlouis> wavewave: Erlang is probably the system with the most maturity able to do tht
15:36:04 <Cale> I'm consistently disappointed with the output of -Wall
15:36:17 <monochrom> RambO: reproducible by other people or it didn't happen
15:36:22 <Cale> It warns about all sorts of silly irrelevant things, and misses important issues.
15:36:29 <RambO> aavogt: I didn't do that.. did I?
15:36:43 <wavewave> jlouis: I want to stick to haskell. ;-)
15:36:43 <aavogt> benmachine: if you tried to use it, about the choice of `show' being ambiguous
15:36:44 <Cale> I usually just leave it off
15:36:44 <monochrom> Or rather...
15:36:46 <aavogt> yes, you did
15:36:53 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25365#a25365
15:36:58 <monochrom> aavogt: Ignore unreproducible questions :)
15:36:59 <aavogt> there is no Number here
15:37:07 <monoidal> what is the reason of the infinite loop? show calls showS and showS calls show by default?
15:37:34 <benmachine> aavogt: it wouldn't be ambiguous, though, because of the shadowing
15:37:39 * hackagebot hostname 1.0 - A very simple package providing a cross-platform means of determining the hostname  http://hackage.haskell.org/package/hostname-1.0 (MaxBolingbroke)
15:37:42 <benmachine> you'd only catch it if you used show on something else
15:37:45 <aavogt> benmachine: try it
15:37:45 <benmachine> like an Int
15:38:05 <jlouis> wavewave: if you accept that messages are asynchronous and can be lost, it is probably simple to do a proof of concept
15:38:11 <aavogt> @let show = "lol"
15:38:12 <lambdabot>  Defined.
15:38:16 <aavogt> > show 5
15:38:17 <benmachine> aavogt: okay fine
15:38:17 <lambdabot>   Ambiguous occurrence `show'
15:38:17 <lambdabot>  It could refer to either `L.show', defined at ...
15:38:22 <monoidal> > 5
15:38:23 <lambdabot>   5
15:38:28 <RambO> aavogt:  sorry
15:38:29 <benmachine> @undefine
15:38:47 <wavewave> jlouis: i see..
15:38:48 <jlouis> wavewave: also note http://hackage.haskell.org/package/net-concurrent which was uploaded a few days ago
15:39:09 <jlouis> wavewave: depending on your problem, it might be suitable
15:39:23 <wavewave> jlouis: oh.. this looks great.
15:42:24 <wavewave> jlouis: thx for info.
15:52:50 <Cale>     showsPrec _ x s   = show x ++ s
15:52:51 <Cale>     show x            = showsPrec 0 x ""
16:02:39 <l-b> hm, Haskell can be fooled :)
16:02:41 <l-b> take 2 [x | x<-[1..], x==1]
16:03:16 <c_wraith> that expression diverges, but that doesn't mean it's been fooled
16:03:40 <l-b> yes, it'll unfortunately take forever to evaluate. :(
16:03:44 <monochrom> computers can be fooled. humans can be retarded
16:04:49 <c_wraith> > succ maxBound :: Int
16:04:50 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
16:05:05 <c_wraith> good news!  It won't run forever!
16:05:28 <monochrom> well-guarded commands can't be fooled
16:05:35 <monoidal> isn't default Integer?
16:05:56 <monochrom> Yes.
16:05:59 <c_wraith> It's true that the default is Integer.  But that won't run forever either.
16:06:05 <c_wraith> Its implementation has limits, too
16:06:48 <monochrom> won't run forever because you will upgrade ubuntu and need to reboot
16:06:50 <kmc> yeah after 2^(2^64) steps it'll quit
16:07:07 <danharaj> Holy crap, it's really easy to make an interpreter for a simple language with GADT's
16:07:20 <fax> danharaj what language
16:07:20 <kmc> yes
16:07:26 <monochrom> or you're on windows and you will reboot next Tuesday for a patch
16:07:46 <danharaj> fax: A friend of mine and I are working on a toy one.
16:07:50 <monochrom> Corollary: every algorithm on windows has complexity O(1)
16:08:34 <fax> cool
16:08:35 <ddarius> monochrom: Every algorithm has complexity O(1)
16:08:51 <fax> don't you mean O(log^infinity(n))
16:09:12 <winxordie> monochrom: I've heard that a problem taking Graham's number nanoseconds to compute is still kinda hard
16:09:38 <monochrom> I didn't say problem complexity.
16:10:02 <winxordie> well O(1) ~ any real number; I just specified one :P
16:10:17 <danharaj> I haven't done it before and my background isn't CS, so I have to figure out things I'm sure are basic, like how to handle variables and closures.
16:10:23 <monochrom> I'm afraid you mixed up problem complexity with algorithm complexity.
16:10:47 <ddarius> danharaj: Don't worry. Most programmers don't even know how those are -supposed- to be handled, let alone how to actually implement it.
16:10:59 <winxordie> I meant hard as in "can't feasibly do in the lifetime of the universe"
16:11:24 <winxordie> I'd like to think I know algorithmic complexity... considering that's what I'm doing research on. >_<
16:12:17 <monochrom> "complexity of bubble sort" is algorithm complexity, not problem complexity.
16:12:30 <danharaj> ddarius: heh, maybe. I was thinking of allowing my term type to allow references to variables by their name, and then have my eval function take a map of terms as an argument, just to start off. I only need to interpret one-liners for now.
16:12:58 <c_wraith> huh.  the JSONb package is kind of disappointing in relation to the JSON package.  It's only a couple percent slower, while using far better data structures.
16:13:03 <monochrom> "bubble sort is quadratic" does not contradict "sorting by comparison can be done in n log n".
16:13:07 <c_wraith> err, could percent faster
16:13:39 <c_wraith> I give up on english
16:13:53 <c_wraith> sadly, it's the only natural language I'm even semi-competent in
16:13:56 <danharaj> This is refreshing. I think I might go through Pierce's book and do all the examples in Haskell instead of ML like it is in the book.
16:14:10 <winxordie> c_wraith: I don't blame you. It's terrible to write a parser for it.
16:15:08 <monochrom> As another example, "my algorithm solves SAT in EXPTIME" does not imply "SAT is EXPTIME" either.
16:16:05 <winxordie> monochrom: yeah, I gotcha. I've been playing with #P for so long I've started messing up everything below it.
16:16:10 <jbapple> danharaj: http://code.google.com/p/tapl-haskell/
16:16:28 <fax> jbapple you're just trying to put him off? :P
16:16:59 <danharaj> jbapple: Thanks, it'll be good to compare my results to someone else's
16:17:18 <jbapple> And contribute if you do parts they haven't done yet
16:18:14 <monoidal> monochrom: what do you mean?
16:18:32 <danharaj> jbapple: yes, of course. *cough*
16:22:29 <Philippa> danharaj: that works, and then you can do closures the obvious way. Honestly? I've never bothered implementing something speedier, been too busy on other stuff
16:23:06 <Philippa> TAPL uses De Bruijn indices in its code, doesn't it?
16:23:12 * fax wonders what the cough means
16:23:21 <jlouis> Philippa: yup
16:23:25 * danharaj knows what the cough meant
16:27:08 <danharaj> Foo :: Bar a | Baz a -> Term a -- How do I turn this into a legal constructor? Bar, Baz are ctors of Term
16:27:20 <fax> huh ???
16:27:22 <danharaj> There should be parentheses around (Bar a | Baz a)
16:27:24 <fax> what is that bar
16:27:34 <fax> like Either ?
16:27:47 <fax> I don't know hwat you mean by the bar
16:27:56 <fax> if they are constructors they can't be in atype
16:27:56 <CalJohn> danharaj: you are mixed up between type constructors and types
16:28:35 <CalJohn> danharaj: Foo :: Term a -> Term a
16:28:40 <danharaj> In my term type, I want a certain term constructor that only takes terms that match certain other constructors, not just a general Term.
16:29:16 <CalJohn> that's not the way types work in haskell danharaj (at least without extension magic)
16:29:22 <RambO> Is there something like HUGSFLAGS in ghci?
16:29:33 <monoidal> you can create a BarBazTerm a
16:29:35 <danharaj> CalJohn: Can GADT's type what I want?
16:30:15 <monoidal> data Bar; data Baz; data Foo; data Term where Foo1 :: Term Bar a -> Term Foo a
16:30:18 <fax> what do you want?
16:30:22 <CalJohn> danharaj: i don't know, I only ever use the normal types.  if there is some way to do this, chances are someone here will chime in and tell us
16:30:59 <monoidal> * data Term a b
16:31:36 <CalJohn> danharaj: my hunch is that you should rethink what you're doing
16:31:58 <CalJohn> a lot of the point of types is to ensure that exactly what you want to do cannot be done
16:32:02 <danharaj> fax: I have a type Term a. It has ctors ListLit, ListArith. I want a ctor :: (ListLit | ListArith) -> Term a
16:32:24 <danharaj> That is, its argument has to pattern match either ListLit or ListArith.
16:32:49 <monoidal> you can create a smart constructor that will enforce runtime that
16:32:50 <kmc> simple solution: split the type up
16:33:28 <kmc> make one type with only those two ctors, and a single ctor in Term for that type
16:35:22 <kmc> you can't statically require a particular constructor.  this could in general introduce arbitrary proof obligations for the type checker
16:35:36 <kmc> you could maybe use GADTs to tag some of your ctors at the type level
16:36:41 <monoidal> another solution is to add ListLit' and ListArith' constructors, taking the same parameters as ListLit and ListArith
16:37:37 <danharaj> kmc: Makes sense.
16:38:22 <danharaj> I'm trying to think that if I let the new ctor take an arbitrary Term, where I would like to catch the error when my program runs.
16:38:42 <kmc> danharaj, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25366#a25366
16:38:50 <ezyang> Does cabal-install automatically select the correct version of a package if, say, you have an application that relies on base-3 but base-4 is default on your system?
16:38:57 <ezyang> s/package/dependency/
16:39:39 <danharaj> kmc: thanks
16:39:44 <kmc> danharaj, i don't necessarily recommend this level of trickery.  depends on what you're doing
16:40:03 <danharaj> kmc: looks like it would incur run-time overhead to use typeclasses to check things that way.
16:40:10 <kmc> why?
16:40:39 <kmc> the typeclass dictionary is empty
16:40:43 <kmc> and unused
16:41:40 <danharaj> seems like the trickery confuzzles me. :)
16:42:06 <danharaj> I don't think I should resort to it.
16:42:09 <kmc> yeah
16:42:27 <kmc> i mean i can explain it, if you're interested in learning
16:42:31 <kmc> but it's probably not right for your problem
16:42:55 <danharaj> I think I get it, but it's ugly, and probably confusing.
16:43:13 <danharaj> My collaborator would make fun of me for being obfuscated :p
16:44:14 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25367#a25367 a version where you explicitly pass the proofs
16:44:25 <kmc> note that you can cheat, e.g. (undefined :: InAB IsC)
16:45:08 <Cale> Unrestricted recursion makes the typesystem inconsistent, there's not much you can do about that :)
16:45:38 <danharaj> I like the idea of explicitly passing the proof in.
16:46:44 <danharaj> So in this case tag makes data T carry a proof of its nature.
16:48:49 <danharaj> Would you guys think it a more elegant solution if there were a datatype called Tag, and T depended on it? It seems like this trick is trying to fake a form of dependent typing.
16:48:54 <Cale> Well, in this example, the T values don't carry the proof
16:50:35 <Cale> (At runtime, they only really carry along a value of type a)
16:51:23 <Cale> But the InAB values are real values at runtime, and you really pass along a little piece of data to f which is a proof that the corresponding T value you're passing is an A or B
16:51:41 <Cale> (though the compiler may very well simplify that away)
16:52:47 <Cale> danharaj: Depended on it in the dependent typing sense?
16:52:52 <danharaj> yeah
16:53:01 <Cale> danharaj: Yes, that would probably be better.
16:53:55 <Cale> The recent extensions to the GHC type system have come to approximate dependent typing without dependent types :)
16:54:12 <danharaj> :p
16:54:42 <kmc> yeah
16:54:51 <kmc> this pile of hacks is worse in a way
16:54:56 <kmc> actual dependent typing is very simple
16:55:00 <Cale> However, we still retain a significant amount of type inference.
16:55:02 <danharaj> Cale: Where do GADT's live in the theoretical landscape? Is there a more general class that subsumes them? There are so many extensions that I haven't heard of :p
16:55:03 <kmc> it unifies a lot of concepts that ghc has to keep separate
16:55:11 <strobedream> :t (.)
16:55:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:55:25 <Cale> :t (P..)
16:55:26 <lambdabot> Couldn't find qualified module.
16:55:29 <Cale> :t (Prelude..)
16:55:29 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:55:44 <Cale> strobedream: ^^ in case you were looking for the type of the Prelude's (.)
16:56:01 <Cale> strobedream: It can be generalised to fmap though
16:56:11 <kmc> sometimes i would rather have dependent typing with tricks to keep inference, than have inference with tricks to fake dependent typing
16:56:30 <kmc> i also think it's worth considering non-dependent stratified data schemes like Omega and She have
16:56:36 <lispy> kmc: have you tried Agda or Coq?
16:56:39 <kmc> both
16:56:46 <Cale> kmc: I *think* I agree, though the tricks to preserve inference I would want to be nice and powerful though. :)
16:56:51 <kmc> yeah
16:57:09 <lispy> kmc: ah, because it sounded like agda :)
16:57:13 <kmc> yes
16:57:59 <Cale> We tend to underestimate it, but type inference is a big part of the downward scaling of Haskell -- that is, it's extremely important to having concise one-liners.
16:58:15 <Cale> and for things like shell scripting with  ghc -e  I think that's rather important to keep
16:58:16 <danharaj> I wish you could help the compiler with inference. Like, when it tried to build the code, if it couldn't inference a type, it would ask you, and save your answer for future builds.
16:58:54 <danharaj> infer*
17:02:12 <c_wraith> Ok, Text.JSONb must be doing something horribly wrong.
17:02:26 <c_wraith> In further testing, it's actually slower than Text.JSON
17:02:34 <c_wraith> Which really makes no sense at all
17:03:36 <dolio> b is for bytestring?
17:03:43 <c_wraith> yeah
17:04:30 <c_wraith> hmm.  the bytestring version is implemented entirely with attoparsec.
17:10:42 <strobedream> Cale: thanks
17:11:05 <strobedream> Cale: I just came across it and couldn't figure out what it was for
17:12:01 <strobedream> Cale: I was looking at 99 haskell questions and the first solution bugged me.
17:12:06 <strobedream> myLast'' = head . reverse
17:12:14 <strobedream> myLast''' = head reverse
17:12:32 <strobedream> does the same thing. It seems like you don't even need the dot.
17:12:33 <blackdog> 99 problems but a solution ain't one?
17:12:58 <strobedream> blackdog: no they give like 3 solutions but they are odd.
17:13:12 <blackdog> > f = head reverse
17:13:12 <lambdabot>   <no location info>: parse error on input `='
17:13:17 <blackdog> > let f = head reverse
17:13:19 <lambdabot>   not an expression: `let f = head reverse'
17:13:25 <blackdog> > head reverse
17:13:26 <lambdabot>   Couldn't match expected type `[a]'
17:13:27 <lambdabot>         against inferred type `[a1] -> [...
17:13:32 <blackdog> > head . reverse
17:13:33 <lambdabot>   *Exception: Prelude.head: empty list
17:13:41 <blackdog> i don't think they are the same:)
17:14:45 <strobedream> when I type them into ghci it provides the same output given a list
17:15:12 <monochrom> > head reverse "abc"
17:15:13 <lambdabot>   Couldn't match expected type `[a]'
17:15:13 <lambdabot>         against inferred type `[a1] -> [...
17:15:21 <monochrom> you should get a type error like that
17:16:03 <strobedream> okay
17:16:14 <strobedream> hang on.
17:18:07 <strobedream> Sorry it is this one
17:18:07 <strobedream> myLast''' xs = (head (reverse xs))
17:18:23 <strobedream> I didn't reload.
17:28:34 <monochrom> Â«f (g xs)Â» is the same as Â«(f . g) xÂ». This is well known. See also definition of Â«.Â»
17:29:48 <Cale> strobedream: Sorry about that, I got up from my computer there. See monochrom's comment for the definition of (.)
17:31:10 <strobedream> okay cool I played around with it and I figured that much out.
17:31:16 <Cale> strobedream: The function f . g is the function which when you apply it to some parameter x, it applies first g to x, and then f to the result of that. (f . g) x = f (g x)
17:31:34 <strobedream> yeah
17:31:41 <strobedream> just like in math.
17:31:46 <Cale> Right
17:32:24 <Cale> Things are actually evaluated in the opposite order though: when you evaluate it, f is applied to (g x), and then g x is only evaluated if needs be to determine the result.
17:33:18 <Cale> (but most of the time it doesn't matter which order you think of it in)
17:34:01 <blackdog> any suggestions for what to include in a haskell introduction? 50 minutes or so...
17:34:45 <luite> what kind of audience?
17:34:56 <blackdog> good devs, but probably no FP experience
17:35:00 <blackdog> probably some ruby types
17:35:10 <c_wraith> Make sure the word Monad *never* appears.
17:35:38 <luite> if they are ruby types, you probably don't need to mention anything about speed ;)
17:36:31 <blackdog> it'd be good to build something, i think, and perhaps motivate things that way rather than rambling on about purity
17:38:51 <Cale> Ruby has blocks, so Ruby people are already somewhat used to the ability to refactor changing bits of code out of functions. Maybe an example in which there's more than just one bit of code which is varying would be good though. ;)
17:40:59 <danharaj> Emphasise the importance of defining your datatypes correctly. Really that's the trick to Haskell.
17:41:34 <Cale> The problem with a 50 minute intro talk is that there are almost too many directions in which you could take things.
17:41:40 <blackdog> yes, exactly
17:41:49 <ddarius> So pick only one.
17:53:41 <danderson> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25368#a25368
17:53:48 <danderson> I have no idea how to fix this from the error
17:56:15 <danderson> help?
17:56:48 <monochrom> "math" doesn't specify an order evaluation either. It specifies strictness at most, e.g., 0*(1/0) is undefined because 1/0 is undefined. But no one says in 0*(394829343/29384903234) you must evaluate 394829343/29384903234 first, that's silly.
17:57:19 <RambO> Is there a function in prelude that makes a string containing numbers into an integer?
17:57:31 <Zao> read.
17:57:58 <Zao> > (read "9001") :: Int
17:57:59 <RambO> Thanks.
17:57:59 <lambdabot>   9001
17:58:08 <Zao> (counterpart is show)
17:58:19 <RambO> And... ord(x) ?
17:58:23 <Zao> It can read just about anything that has suitable instances.
17:58:24 <monochrom> kindergarten classes say in a+b/c "do" b/c first and in a*(b+c) "do" b+c first because it's kindergarten. How do you explain parsing to kids? But it's really just parsing, not evaluation order.
17:58:26 <Zao> What about ord?
17:58:41 <RambO> I want to do ord( x) where x is a char.. but it says its undefined..
17:58:45 <Zao> @type Data.Char.ord
17:58:47 <lambdabot> Char -> Int
17:59:01 <mauke> @index ord
17:59:01 <lambdabot> Data.Char
17:59:03 <Zao> The more special functions tend to live in other modules.
17:59:12 <RambO> Oh :(
17:59:14 <Zao> Like the subset of list functions in Prelude vs. all of Data.List.
17:59:37 <RambO> So, i have to import data
18:00:18 <Zao> Data.Char for ord.
18:01:13 <RambO> I get this:
18:01:14 <RambO> *Main> read "10"
18:01:14 <RambO> <interactive>:1:0:
18:01:14 <RambO>     Ambiguous type variable `a' in the constraint:
18:01:14 <RambO>       `Read a' arising from a use of `read' at <interactive>:1:0-8
18:01:14 <RambO>     Probable fix: add a type signature that fixes these type variable(s)
18:01:39 <danderson> you need to fix the type of the result
18:01:47 <Zao> RambO: It tells you exactly what to try.
18:01:58 <Zao> Note that my example annotated the expression with the target type.
18:02:00 <danderson> read returns a value of type 'a'
18:02:07 <RambO> Oh
18:02:22 <RambO> I didn't know I could do that
18:02:23 <danderson> unless your use of that result constrains 'a' to exactly one type, Haskell doesn't know what you meant
18:02:27 <Zao> > (read "[['x', 'y'], []]") :: [[Char]]
18:02:28 <lambdabot>   ["xy",""]
18:02:32 <RambO> Nice, thanks! :)
18:02:39 <Zao> It can read anything that has a Show instance.
18:02:54 <Zao> > show [42, 3, 5]
18:02:55 <lambdabot>   "[42,3,5]"
18:03:09 <monoidal> assuming Read instance is also defined
18:03:25 <Zao> > (read . show $ [42, 3, 5]) :: [Int]
18:03:27 <lambdabot>   [42,3,5]
18:03:39 <Zao> monoidal: Right. Was unsure if there existed a Read class.
18:03:45 <Zao> Never defined my own of those.
18:03:54 <monoidal> :t read
18:03:56 <lambdabot> forall a. (Read a) => String -> a
18:04:02 <rtaycher> I ccan't seem to find a good way to map over multiple lists, first I tried zipping/unzipping, then I tried rolling my own map2 map3 functions, is their any built in way?
18:04:11 <monoidal> zipWith
18:06:18 <rtaycher> thanks
18:23:33 <tromp> > 365*24*3600
18:23:34 <lambdabot>   31536000
18:27:44 <danderson> "Inferred type is less polymorphic than expected"
18:27:47 <danderson> well, that's a new one
18:28:27 <dolio> Happens a fair amount when you're dealing with rank-n types or existentials.
18:28:38 <dolio> At least, if you're not perfect.
18:28:43 <danderson> rank-n types would be it.
18:28:59 <danderson> I have a (Foldable a) => X509 -> RSAKeyPair -> a X509 -> IO SSLContext
18:29:08 <danderson> which I partially apply down to a X509 -> IO SSLContext
18:29:17 <danderson> and ghc cries.
18:30:29 <dolio> And some of those are higher-rank types in disguise?
18:30:38 <danderson> fixed by giving up and deciding that if lists are good enough for the Prelude, they're good enough for me :)
18:31:05 <danderson> yeah, (Foldable a) => a X509 -> IO SSLContext is the type of a field in a data type
18:31:34 <dolio> Ah.
18:33:44 <danderson> specifically, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25370
18:34:09 <danderson> the first one is the version that specifically uses lists, and works, while the second works for any Foldable, but doesn't compile.
18:34:38 <danderson> it's missing imports, but the mapM_ is from Data.Foldable, hence the Foldable constraint
18:39:27 <dolio> danderson: That definition of PM has a Foldable a constraint but no further mention of a.
18:40:26 <danderson> gah, pasted a typoed file. Should be 'a X509', not just 'X509'
18:41:27 <dolio> Oh, I see the problem.
18:41:37 <dolio> make is affected by the monomorphism restriction.
18:42:42 <danderson> ooh, the monomorphism restriction. Long time no see.
18:42:46 <dolio> Either put NoMonomorphismRestriction in the LANGUAGE pragma, or give it a type signature (or eta expand it).
18:43:04 <danderson> thanks!
18:56:09 <rovar_> is there a way to pattern match on variables? e.g. I wish to treat them as constants, not assign a value to them in a pattern match
18:56:23 <fax> rovar_, that actually does not make sense
18:57:09 <Axman6> rovar_: i've got no idea what you're asking for :\
18:58:13 <rovar_> i would like to define some constants, these are control bytes in a binary protocol.. as I parse them, i wish to use my constants as patterns to match against
18:58:20 <Axman6> rovar_: do you mean something like foo (Just 0) = ...?
18:58:33 <fax> ah
18:58:36 <fax> that makes sense
18:58:37 <Axman6> ah, no you can't do that
18:58:39 <tensorpudding> You could define them as constants on the toplevel.
18:58:43 <Axman6> i don't think you can anyway
18:58:49 <ddarius> Axman6: Sure you can.
18:58:54 <Axman6> how?
18:59:20 <ddarius> Axman6: Perhaps I'm not understanding which "that" your sentence referred to.
18:59:38 <Axman6> foo = "hello" ... case bar of foo -> baz i think is what he's after
18:59:52 <Axman6> ddarius: what rovar_ was asking for
18:59:54 <ddarius> Axman6: Okay, yes, that you can't do.  I thought you were referring to your own statement.
19:00:00 <Axman6> no
19:00:36 <tensorpudding> you can use guards to provide comparison for the pattern matched variables and the constants
19:00:52 <rovar_> it seems like such a simple idea.. i mean, i could just use the actual values as patterns, but years of programming experience tells me magic numbers are bad
19:00:55 <ddarius> Axman6: However, look at the pattern calculus.
19:01:16 <Axman6> rovar_: i think it would be nice to have but i think it has scoping issues
19:01:37 <Axman6> ddarius: i have, i've been to one of the authors talks :)
19:01:48 <rovar_> yea.. you would need some syntactical hint to tell the compiler to evaluate the variable rather than assign..
19:01:55 <tensorpudding> > let const1 = 5; const2 = 7; f x | x == const1 = "good" | x == const2 = "bad" in (f 5, f 7)
19:01:56 <lambdabot>   ("good","bad")
19:02:06 <Axman6> though, i'm not sure how that relates here (i;m sure it does in a broad way, but not in this specific sense)
19:02:35 <Axman6> rovar_: what sort of parser are you writing?
19:03:18 <rovar_> it's for a simple binary protocol
19:04:10 <rovar_> hrrm.. i guess I could make a data object that derives enum
19:04:38 <rovar_> then override the value function with a different value for each item..
19:04:43 <rovar_> but that doesn't really get me anywhere..
19:05:08 <rovar_> well.. it does.. i get to use the names in patterns instead of numbers
19:05:12 <tensorpudding> Is what I wrote in line with what you were thinking?
19:05:43 <rovar_> tensorpudding, yea
19:05:54 <rovar_> but i don't see why i need guards for this
19:06:37 <tensorpudding> Inherently, you're making different definitions depending on what the inputs are, by comparing them to the values of some constants, right?
19:07:28 <jmcarthur> > mappend :: Ordering -> Ordering -> Ordering
19:07:29 <lambdabot>   No instance for (Test.SmallCheck.Serial GHC.Ordering.Ordering)
19:07:29 <lambdabot>    arising f...
19:07:39 <jmcarthur> aw
19:08:58 <rovar_> this will take some extra garbage,, but I define data bincodec = ConstA | ConstB | ConstC ...
19:09:50 <rovar_> then:  let bincodec_from_byte "\x0a" -> ConstA; bincodec_from_byte "\x0b" -> ConstB   ...
19:10:51 <rovar_> then I can bincodec_from_byte $ get_byte_from_stream and match on the result
19:13:46 <rovar_> that's a lot of boilerplate
19:13:57 <rovar_> seems like a job for TH
19:14:39 <kmc> @quote majesty
19:14:39 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
19:18:25 <uorygl> Template Haskell?  What kind of programming language needs to *have* a programming language?
19:19:04 <Runar> LISP
19:19:08 <kmc> any of them
19:19:10 <[swift]_> i'm still waiting for Template Template Haskell personally
19:19:13 <kmc> metaprogramming is useful
19:19:17 <fax> Runar lol what
19:19:25 <kmc> but Template Haskell *is* Haskell
19:19:34 <kmc> with a few extra syntactic constructs for quoting and splicing
19:19:47 <kmc> compared to C++ templates, which are a totally different language from C++
19:20:11 <uorygl> The point of a progamming language is to make redundancy unnecessary.
19:20:15 <ddarius> C++ templates are part of C++
19:20:35 <ddarius> kmc: An actual example would be CPP and C.
19:20:35 <kmc> and that's largely the point of TH.  instead of writing boilerplate code, compute it
19:20:47 <kmc> ddarius, "different language from (C++ minus templates)"
19:20:49 <kmc> if you like
19:24:56 <uorygl> So, now I feel like implementing Martin-LÃ¶f type theory.
19:25:06 <ddarius> uorygl: Go ahead.
19:25:17 <uorygl> Thank you for giving me permission to do that.
19:25:23 <Cale> C++ templates are weird. It's like the designers couldn't decide if they wanted a system for metaprogramming or for parametric polymorphism and ended up with something that does both awkwardly.
19:25:27 <fax> why do you have to blog everything you do into this channel
19:25:42 <fax> like making sandwiches etc
19:25:52 * Cale makes a sandwich
19:26:00 * ddarius has no bread.
19:26:07 <uorygl> I try to mostly keep my blogs to other channels.  >.>
19:26:51 <uorygl> It is strange how when people get thoughts, they like to write them down and show them to everyone.
19:27:11 <kmc> Cale, i think it's more like they invented a quick hack for parametric polymorphism and then noticed it was a strange but powerful metalanguage
19:27:21 <Cale> I don't see what's wrong with talking about your intent to implement a type system here. It seems pretty on-topic for this channel :)
19:27:23 <kmc> i mean, it's missing some basic metaprogramming features
19:27:35 <Cale> kmc: That's true.
19:27:57 <Cale> But it's also extremely awkward when all you want is parametric polymorphism.
19:28:22 <kmc> yeah
19:29:02 <Cale> Probably that has more to do with the choice of syntax than anything else, but these things matter.
19:30:18 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25372#a25372 : Yay or nay?
19:30:19 <rovar_> kmc, yea, I am quite sure that the current usage of c++ template metaprogramming is not what they had in mind... they unleashed a monster
19:30:41 <rovar_> although I do enjoy it when I'm feeling sadistic..
19:30:45 <ddarius> Cale: No, it's worse.  I can't tell that a function is parametrically polymorphic given its template "type."
19:31:04 <kmc> yeah rovar_ .  C++ and C++ templates specifically are great esolangs
19:31:33 <kmc> fun to learn, fun to try to do simple things in crazy ways
19:31:38 <ddarius> Other than being verbose, C++'s template language is mostly straightforward.
19:32:08 <slymee> Not when used to reinvent FP IMO.
19:32:10 <[swift]_> it's straightforward but the things people do with it to get around the limitations of the language are sometimes anything but straightforward
19:32:10 <Cale> ezyang: That's cute, but it's a little weird. You could at least use liftM2 if you're going to do that, I think. :)
19:32:25 <ezyang> Cale: ok
19:32:55 <Cale> hmmm....
19:33:20 <ezyang> Punting it entirely then :^)
19:33:39 <ezyang> I think liftM will confuse people with "wait, that's already monadic, what's he lifting it into?"
19:34:15 <Cale> I'm just trying to think of what other clever ways you could write something like that, but I'm not sure any of them are really significantly clearer than using do-notation.
19:34:26 * ddarius thinks an explicitly bound variable would be shorter and clearer.
19:34:58 <ddarius> Poor point-free programming.  Your purpose has been lost to the sands of time.
19:35:26 * kmc remembers being bit hard by using (>>) where he meant liftM2 (>>)
19:35:38 <Cale> It's usually not a bad idea to explore the possibility of writing something in points-free style, but sometimes it works out and sometimes it doesn't.
19:35:43 <kmc> because (a ->) is a monad with a perfectly valid if useless (>>)
19:37:59 <ezyang> kmc: Oh wow, that's pretty terrible :o)
19:38:44 <Cale> Defining liftM2 (>>) as a separate operator might be suitable to certain expressions of this sort
19:39:36 <FunctorSalad> what was the M in question?
19:39:47 <kmc> i had two values of type (a -> IO b)
19:39:51 <ezyang> IO
19:39:57 <kmc> in this case both (x >> y) and liftM2 (>>) x y
19:39:58 <kmc> are valid
19:40:07 <kmc> and do totally different things
19:40:08 <FunctorSalad> oh right, two monads actually
19:40:40 <kmc> 2 monads 1 functor
19:40:47 <FunctorSalad> ....
19:41:34 <ezyang> "to bind them all"
19:42:18 <FunctorSalad> hmm... liftM2 (>>) x y arg = x arg >> y arg
19:42:27 <Cale> yep
19:42:28 <kmc> yeah
19:42:29 <FunctorSalad> *thinks about the other)
19:42:32 <kmc> for this case
19:44:19 <FunctorSalad> (x >> y) arg = ... hmm
19:44:31 <FunctorSalad> not the same?
19:44:48 <Cale> (x >> y) arg = (x >>= const y) arg = const y (x arg) arg = y arg
19:45:31 <Cale> > ((*2) >> (+3)) 5
19:45:31 <lambdabot>   8
19:45:44 <Cale> > (undefined >> (+3)) 5
19:45:45 <lambdabot>   8
19:46:07 <kmc> yeah it's simply f >> g = g
19:46:11 <uorygl> Meh, inductive types look complicated.
19:46:32 <FunctorSalad> somehow (>>) for reader puzzled me
19:46:45 <kmc> uorygl, in Haskell?
19:46:45 <Cale> Probably because it's pretty useless.
19:46:51 <FunctorSalad> yep :)
19:47:08 <uorygl> kmc: in Martin-LÃ¶f type theory.
19:47:10 <cdsmithus> uorygl: what kind of inductive types?  Lists are inductive types by my definition, and certainly aren't too complicated
19:47:19 <cdsmithus> Oh!
19:47:34 <uorygl> cdsmithus: I'm typing to create a formal definition of what an inductive type is.
19:47:38 <uorygl> Or something.
19:47:42 <cdsmithus> Ah, scratch that, then.
19:47:48 <uorygl> So yeah, it's a bit complicated.
19:48:18 <uorygl> Maybe I can get away with just defining the integers instead.
19:48:27 <FunctorSalad> reader is not a Real Monad, is it? ;) (as in 'deceptively simple', not 'doesn't satisfy the laws')
19:48:50 <FunctorSalad> like the category Set
19:48:54 <FunctorSalad> *ramble*
19:49:11 <uorygl> How's the category Set defined?
19:49:23 <FunctorSalad> sets as objects, functions as morphisms
19:49:44 <uorygl> That sounds pretty simple.
19:50:01 <Cale> It *sounds* simple, but it's actually pretty subtle structurally :)
19:50:08 <uorygl> Oh?
19:50:12 <Cale> (the Set category)
19:50:23 <Cale> Well, because Sets are subtle things
19:50:28 <FunctorSalad> Cale: I meant in the sense that many categorically distinct definitions collapse in Set
19:50:37 <uorygl> What's a subtlety of the category?
19:50:42 <ezyang> Whenever I think "hmm, this argument is going to multiple functions" I think "reader"
19:50:48 <uorygl> Apart from the fact that, in a sense, every morphism is also an object.
19:50:51 <FunctorSalad> similarly in spirit to how Reader isn't a real execution and likes to commute with everything ;)
19:51:54 <FunctorSalad> @unmtl ReaderT env (StateT st IO) a
19:51:54 <lambdabot> env -> st -> IO (a, st)
19:52:12 <FunctorSalad> @unmtl StateT st (ReaderT env IO) a
19:52:12 <lambdabot> st -> env -> IO (a, st)
19:52:20 <mathstuf> hi, is it possible to get XML-RPC (via HaXR) to operate on persistent data that's stored on-server? (i was thinking the ST monad, but im not sure how that all works out with XML-RPC's server running)
19:52:31 <FunctorSalad> (does it do that for every monad transformer btw?)
19:52:40 <FunctorSalad> (didn't think about it clearly)
19:52:52 <Cale> uorygl: Well, that's just the fact that it's Cartesian closed. It's a fairly nice category in a lot of ways. It's complete and cocomplete, has a subobject classifier, and lots of other fancy stuff.
19:53:19 <uorygl> Yay, four unfamiliar terms in one sentence.
19:53:26 <FunctorSalad> Cale: right, my point was that it's too nice so it doesn't illustrate some distinctions
19:53:34 <Cale> Do you know what limits and colimits are?
19:53:55 <uorygl> No, but I've heard those terms in this context before.  What are they?
19:55:36 <Cale> Trying to decide if I should just hit you with the definition or backtrack some more first :)
19:55:46 <FunctorSalad> (like: epimorphism and split epimorphism)
19:55:55 <Cale> FunctorSalad: Ah, okay
19:55:58 <uorygl> I'd like to hear the definition.
19:56:27 <Cale> uorygl: Okay, so suppose we have some (usually small) "index" category J
19:57:02 <Cale> and suppose we pick a functor F: J -> C
19:57:17 <Cale> You can think of this functor as picking out a diagram of "shape" J in C
19:57:41 * uorygl nods
19:57:43 <Cale> If J was a discrete category (one with no arrows but the identities), then this functor is just a set of objects of C
19:58:01 <Cale> (Well, an indexed set)
19:58:22 <FunctorSalad> *thinks* are the split epis in Hask the ones where a preimage is *computable* rather than just existing?
19:58:39 * uorygl nods
19:58:44 <FunctorSalad> assuming plain epis are surjective functions
19:59:22 <FunctorSalad> hmm or is a preimage always computable because every type is r.e.? ;)
19:59:23 <Cale> Now, if U is some object of C, then a cone to F is a collection of arrows, f_X: U -> F(X) for each object X of J
20:00:01 <Cale> such that for every arrow X -> Y in J, we have that the corresponding triangle in C commutes
20:00:26 <Cale> That is, the triangle formed of the image FX -> FY of that arrow, and the maps U -> FX and U -> FY
20:02:27 <Cale> So you should imagine the cone as consisting of U together with this bunch of arrows toward the image of J in C, so that everything commutes nicely.
20:03:42 <uorygl> Is "arrow" the same thing as "morphism" in this context or something else?
20:03:46 <Cale> yes
20:04:11 <uorygl> Mmkay, and ": U -> F(X)" means that it goes from the object U to the object F(X)?
20:04:15 <Cale> yeah
20:04:30 <Cale> It really helps to have a picture here...
20:04:42 <uorygl> I try to construct mental pictures.
20:04:55 <uorygl> I get the idea that I have more success than the average person would.
20:05:21 <uorygl> So, I'd say I'm doing fine for the time being.  Let me just continue trying to visualize everything.
20:06:09 <uorygl> So...
20:06:23 <Cale> Okay, now a limit for F is a universal cone -- that is, it's a cone (U,f) to F so that for any other cone (V,g) to F, there will be a unique arrow V -> U which makes all the triangles formed commute
20:06:54 <uorygl> Do you mean that for every arrow a : X -> Y in J, the composition of F(a) with f_X is equal to f_Y?
20:06:55 <Cale> So in a particular sense it's the "last" cone to F
20:07:02 <Cale> yes
20:07:10 <uorygl> Whew.
20:07:29 <Cale> Sorry I'm not doing a great job of giving everything a name here :)
20:07:39 * uorygl tries to visualize the whole, having visualized the parts.
20:07:54 <Cale> It'll help to have some examples in a moment too
20:08:23 <Cale> Limits and colimits generalise a lot of the basic definitions from category theory
20:08:30 <uorygl> I like trying to wrestle with things like this.
20:09:12 <Cale> Examples of limits include terminal objects, products, equalisers, and pullbacks
20:10:20 <Cale> Let's take J to be the category with two objects and no nontrivial arrows
20:10:22 <uorygl> Perhaps it would help if I knew what an object, product, equaliser or pullback is.  :P
20:10:26 <uorygl> Mmkay.
20:10:39 <danharaj> I think I'm going to end up defining a monad in this interpreter.
20:10:43 <danharaj> So exciting.
20:11:02 <kmc> mathstuf, did you get an answer to your question?
20:11:13 <mathstuf> kmc: no
20:11:16 <Cale> Let's call those objects 0 and 1, for no particular reason. So then a functor F: J -> C just picks out two objects of C, F(0) and F(1)
20:11:26 <uorygl> Right.
20:11:51 <kmc> mathstuf, can you give a more specific example of what you want to do?
20:12:16 <mathstuf> i have a data structure on the server
20:12:35 <Cale> and then our universal cone will be an object P of C together with maps pi_0: P -> F(0) and pi_1: P -> F(1)
20:12:39 <mathstuf> id like to be able to query/modify it over XML-RPC
20:13:30 <uorygl> And those maps don't really have to be anything special, since J contains no non-trivial arrows.
20:13:31 <Cale> so that for any other object X of C, and maps f: X -> F(0) and g: X -> F(1), there will be a unique arrow u: X -> P so that pi_0 . u = f and pi_1 . u = g
20:13:54 <Cale> uorygl: Well, they will have to be *somewhat* special
20:14:03 <Cale> uorygl: But only because of this latter condition
20:14:10 <uorygl> Well, for it to be a universal cone, yeah.  I meant in order to be a cone.
20:14:44 <Cale> If this is in the category of sets, then we can take P to be the Cartesian product F(0) x F(1)
20:14:56 <Cale> and the arrows pi_0 and pi_1 are the projections onto the two components
20:15:05 <mathstuf> so: { addEmail "my/rpc/server" "add_email" "bob" "bob@joe.com" } on the client would modify the database on the server
20:15:47 <Cale> and for any choice of functions f: X -> F(0) and g: X -> F(1), we can tuple them together into a function (f,g)(x) = (f(x),g(x)), which will be the unique map X -> P
20:16:57 <Cale> This is a rather backward way to explain things to you, usually we start out by defining categorical products, and working our way out to generalising to limits, but here, we've started with limits, and specialised the definition back to that of a product
20:17:48 <Cale> and in the category of sets, that's just the Cartesian product
20:18:31 * Cale wonders if this is making much sense :)
20:18:44 <uorygl> I think it's making sense, yeah.
20:19:08 <Cale> Do you know about preorders or partial orders?
20:19:09 <kmc> mathstuf, sounds good.  what's the question / problem?
20:19:17 <uorygl> So if an arrow maps onto F(0) x F(1), that gives you all the information you need to map onto F(0) and F(1).
20:19:36 <mathstuf> kmc: i figure the ST monad is the way to go about this?
20:19:37 <Cale> uorygl: Well, that's the other direction.
20:19:38 <uorygl> I think I know what a partial order is, and I know a preorder is something similar.
20:20:00 <uorygl> Oh, you're right.
20:20:38 <mathstuf> kmc: or is there another way to have a mutable variable?
20:20:43 <Cale> uorygl: It's really the fact that given any two maps to F(0) and F(1), there's a unique way to map to F(0) x F(1) which if composed with the projections will give you back your two chosen maps
20:20:50 <kmc> mathstuf, addEmail is going to send some network traffic, right?
20:20:55 <uorygl> Right.
20:20:55 <kmc> mathstuf, so i expect it'd be in the IO monad
20:21:08 <kmc> mathstuf, unless someone is doing trickery to allow you to call "pure" XML-RPC functions.  is that the case?
20:21:22 <uorygl> Now I wonder what happens when you add non-trivial arrows to J.
20:21:32 <mathstuf> i have the core functionality in a module of pure code
20:21:35 <Cale> Which, if we take the one-element set as the domain, is the same as saying that for any element x in F(0) and y in F(1), there is a unique element (x,y) in F(0) x F(1) whose projections are x and y
20:21:50 <mathstuf> id like to expose it over RPC
20:21:55 <mathstuf> looking at http://www.haskell.org/haskellwiki/Top_level_mutable_state now
20:21:59 <kmc> mathstuf, oh, you're writing the server?
20:22:33 <mathstuf> yes
20:22:37 <kmc> ok
20:22:41 <kmc> sorry, thought you were writing the client
20:22:44 <Cale> okay
20:22:53 <kmc> what does your pure implementation of the addEmail function do?
20:23:23 <kmc> i don't think you want top-level mutable state
20:23:27 <kmc> that's an ugly hack
20:23:39 <mathstuf> dAddEntry :: DBook -> DName -> DEmail -> DBook
20:23:39 <kmc> i think you'll want to create some state variables (IORef etc.) before launching the server thread
20:23:44 <kmc> mathstuf, ok
20:23:45 <Cale> So let's try a category J with two objects 0 and 1, and two parallel arrows f,g: 0 -> 1
20:23:48 <mathstuf> hmm, k
20:23:56 <uorygl> Ooh, there are two of them.
20:24:01 <kmc> so yeah, for the simple case, store it in an IORef
20:24:11 <kmc> if you need concurrency, use MVar or something from STM
20:24:26 <Cale> Well, we could pick just one, but that's less interesting. This way we get some nontrivial equations :)
20:24:42 * uorygl nods.
20:24:54 <DigitalKiwi> Cale: how hard is a haskell bot for someone who doesn't know haskell >.>
20:25:12 <Cale> DigitalKiwi: It's relatively easy to get an IRC bot up and running
20:25:33 <Cale> DigitalKiwi: and then you could use mueval or hint directly to put a Haskell interpreter in it.
20:25:35 <DigitalKiwi> i only need a few features to start with, quotegrabs, maybe karma, uh...i had a list, factoids, url announce
20:25:36 <mathstuf> kmc: ill look into HaXR to see if it can ensure one-call-at-a-time on that level
20:25:54 <uorygl> So the functions comprising our cone are called f_0 and f_1?
20:25:56 <kmc> mathstuf, MVar would be a simple concurrency-safe solution
20:26:13 <mathstuf> k
20:26:21 <Cale> uorygl: yeah.
20:26:38 <uorygl> And the equations we need to satisfy for coneness are f . f_0 = f_1 and g . f_0 = f_1?
20:27:28 <Cale> close
20:27:41 <uorygl> Wait.
20:27:41 <DigitalKiwi> Cale: does lambdabot let you change it without restarting?
20:27:41 <Cale> F(f) . f_0 = f_1
20:27:44 <uorygl> Right.
20:27:52 <Cale> and F(g) . f_0 = f_1
20:27:55 <uorygl> Right.
20:28:07 <uorygl> You didn't wait.  :P
20:28:11 <Cale> sorry :)
20:28:14 <uorygl> :)
20:28:22 <Traveler2> hello
20:28:29 <Cale> and so, in particular, F(f) . f_0 = F(g) . f_0
20:28:36 <Cale> Traveler2: hello
20:28:39 <kmc> hi Traveler2
20:28:43 <uorygl> Right, I guess that equation is the biggie.
20:28:48 <Cale> yeah
20:29:03 <uorygl> Otherwise, you could just set f_1 to F(f) . f_0 or whatever.
20:29:14 <Cale> yeah
20:29:16 <Traveler2> can anybody answer a few questions for me please
20:29:28 <kmc> yes
20:29:32 <Cale> Traveler2: Sure, just ask and we'll try our best if we know the answer :)
20:29:33 <kmc> don't ask to ask
20:29:41 <Traveler2> kay
20:29:54 <Traveler2> I was thinking about the y combinator
20:30:01 <Traveler2> but as a data type
20:30:08 <Traveler2> eg) data
20:30:13 <Traveler2> #
20:30:19 <kmc> @src Mu
20:30:19 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
20:30:28 <Traveler2> data Y a=Y (a (Y a))
20:30:35 <kmc> yes, that exactly
20:30:43 <Traveler2> Its sort of like a monad
20:31:06 <uorygl> Traveler2: well, monads are type constructors, and this is also a type constructor.
20:31:08 <Traveler2> ret x=(Y x)
20:31:34 <kmc> data Mu f = Mu (f (Mu f))
20:31:35 <Traveler2> coreturn (Y x)=x
20:31:36 <DigitalKiwi> caaallleee
20:32:08 <kmc> now return :: f -> Mu f
20:32:10 <kmc> but f has kind * -> *
20:32:22 <kmc> so that signature won't kind-check
20:32:51 <Cale> uorygl: So our limiting cone will be a set U with a map i: U -> F(0), so that F(f) . i = F(g) . i, and such that for any other set V and map j: V -> F(0), we'll have a unique map u: V -> U so that i . u = j.
20:33:06 <Cale> uorygl: It might be a little tricky to see exactly what this means at first.
20:33:12 <Traveler2> What I meant was htha say return' would have the type a m->m (a m)
20:33:16 <Cale> uorygl: But once you see the answer, it'll be clearer :)
20:33:31 <kmc> ah.  so not Monad itself
20:33:53 <uorygl> It's a good thing that this is text, and so you can emit information at one rate and I can receive it at another.  :)
20:33:54 <Cale> Oh, sorry, of course j has to satisfy the same equation as i
20:33:59 <DigitalKiwi> bah
20:34:01 <Traveler2> I mean Y a->a (Y a)
20:34:15 <Traveler2> sort of like a->m a
20:34:15 <Cale> DigitalKiwi: oh, sorry, missed your question
20:34:21 <DigitalKiwi> ;p
20:34:24 <Cale> DigitalKiwi: no, it doesn't
20:34:32 <DigitalKiwi> aww :(
20:34:51 <Cale> DigitalKiwi: But I can edit some things, like the L.hs which is loaded when evaluating expressions
20:34:54 <DigitalKiwi> would it be possible to do something like that in haskell?
20:35:02 <Cale> It used to have a module system which loaded modules dynamically
20:35:31 <Cale> But I don't know what happened... maybe that even still works and I just haven't noticed :)
20:35:50 <Cale> It would certainly be possible to do
20:35:55 <kmc> @faq can Haskell do dynamically-loaded modules?
20:35:55 <lambdabot> The answer is: Yes! Haskell can do that.
20:36:06 <kmc> DigitalKiwi, GHCi is a Haskell program which dynamically loads modules
20:36:17 <kmc> in other words, you can do it by hooking into the GHC API
20:36:21 <Cale> In fact, it would be quite nice to use hint to load and interpret the Haskell code from source directly at runtime.
20:36:38 <uorygl> Cale: what if F(f) is a constant function and F(g) is a different constant function?  Does that just mean there are no cones, and thus no limit?
20:36:43 <Cale> hint is just a nice little wrapper for the GHC API
20:36:56 <Cale> uorygl: right
20:37:01 <Cale> uorygl: Well....
20:37:06 <Cale> uorygl: Almost :)
20:37:12 <Cale> uorygl: There is one cone.
20:37:18 <DigitalKiwi> kmc: well just yesterday i asked if haskell could get you laid and lamdabot said yes so i'm not sure it can be trusted or not
20:37:24 <Cale> Take the empty set, and empty functions :)
20:37:25 <kmc> heh
20:37:34 <kmc> i'm sure it's happened
20:37:41 <kmc> i know a married couple who discussed Standard ML on their first date
20:37:43 <DigitalKiwi> somebody said it worked for him
20:37:50 <uorygl> getLaid is undefined unless you putLaid first.
20:37:53 <DigitalKiwi> with bunnies and girls reviewing code or something
20:38:00 <kmc> bbl
20:38:07 <DigitalKiwi> getting laid?
20:38:49 <uorygl> main = do laid <- getLaid; putStrLn laid
20:38:59 * Cale wonders if Haskell might have contributed to his getting laid. Maybe.
20:39:04 <kmc> DigitalKiwi, possible
20:39:42 <uorygl> Cale: mmkay, so there, the cone's domain would just be the empty set.  I guess that would make it the universal cone, then, if there's only one cone.
20:39:50 <Cale> uorygl: right
20:40:48 <uorygl> Anyway, it seems like the cone has to ensure that it never outputs any x for which F(f)(x) and F(g)(x) are different.
20:41:03 <Cale> mhm :)
20:41:20 <uorygl> And then that's sufficient for coneness...
20:41:24 <Cale> right
20:41:37 <DigitalKiwi> one cone to rule them all and in the darkness bind them
20:41:42 <uorygl> Now I want to ponder how our previous universal cone would extend to this...
20:42:08 <Cale> Well, we know it's got to be something fairly "natural"
20:44:33 <uorygl> Previously, the domain was a Cartesian product... F(0) x F(1), right?
20:44:41 <Cale> yeah
20:44:48 <Cale> Though it's not going to be here.
20:44:57 <uorygl> Is it a subset of that Cartesian product?
20:45:11 <Cale> Well...
20:45:24 <Cale> In a sense. I'm not sure that's the clearest way to look at it
20:45:39 <Cale> er...
20:45:43 <uorygl> My idea was it's those (x,y) for which F(f)(x) = F(g)(x) = y.
20:46:09 <Cale> yeah, but that's too big
20:46:44 <uorygl> You mean this set has some elements that it shouldn't have?
20:46:47 <Cale> Supposing that F(1) is nonempty, I could pick some fixed element y
20:46:53 <Cale> and just take the set of those
20:47:02 <Cale> er
20:47:09 <Cale> no, sorry :)
20:47:14 <Cale> This is okay actually
20:47:46 <Cale> It took me a moment to come around to that description of it, but yours is equivalent to the usual one :)
20:48:22 <Cale> The usual description is that it's just the subset of elements x of F(0) for which F(f)(x) = F(g)(x)
20:48:44 <uorygl> Right.
20:48:46 <BMeph> BRB, ISP updating...
20:48:50 <Cale> But I suppose it also makes sense to make it a subset of the Cartesian product in that way
20:49:12 <Cale> There's a unique map between the two, making them isomorphic
20:49:18 <uorygl> Right.
20:49:26 <uorygl> Technically, it could be any set with that cardinality, couldn't it?
20:49:29 <Cale> yeah
20:49:54 <Cale> as long as you have a suitable map to F(0)
20:50:12 <Cale> (and technically to F(1), but it's determined from there)
20:50:38 <blackdog> dons: you csv parser, it is borked.
20:50:41 <Rotaerk> hmm... example usage of my Maybe monad in F#: http://rotaerk.pastebin.com/9uNa2fKx
20:50:46 <Cale> So this is called the equaliser of F(f) and F(g)
20:50:55 <Rotaerk> darn its strict evaluation!
20:51:06 <uorygl> So once you have the arrow f, 1 is completely determined, so you can leave it out; once you have the arrow g, it's doubly determined, and so you end up with restrictions on 0 as well.
20:51:16 <Cale> yeah
20:52:04 <uorygl> "In mathematics, an equaliser, or equalizer, is a set of arguments where two or more functions have equal values. An equaliser is the solution set of an equation."
20:52:07 <uorygl> Ooh, equations.
20:52:13 <Cale> Often in all this we leave the functor F: J -> C implicit, and just look at a particular diagram of objects and arrows in C.
20:52:23 <Cale> right
20:52:35 <uorygl> Of course I'm right; I'm quoting Wikipedia.  :)
20:52:35 <blackdog> tell dons |"fairfield, ca mall",something| should be parsed as two CSV fields, not three...
20:52:49 <blackdog> blah. how do you use tell again?
20:53:04 <Cale> Well, that equations is the key word here :)
20:53:09 <uorygl> I imagine the command is @tell.
20:53:32 <uorygl> Ah, good, I caught the key word.  :)
20:54:23 <DigitalKiwi>  By Anonymous on the 7th of May 2010 03:33:00 AM <-- in all caps on the site
20:54:26 <uorygl> I have to go soon, which is really a shame.  This has been really fun.
20:54:28 <DigitalKiwi> for some reason that made me laugh
20:54:35 <Cale> So we have a way to express "products", and a way to express "solution sets of equations" in a general setting, and we can mix them together as well.
20:54:36 <uorygl> It's the sort of thing I want to do more often.
20:55:13 <DigitalKiwi> mhr why can't there just be one definitive source for learning haskell!
20:55:21 <DigitalKiwi> i don't know which to read first
20:55:24 <DigitalKiwi> again
20:55:26 <DigitalKiwi> :(
20:56:02 <Cale> Suppose we have three sets A, B, C, and functions f: A -> C, and g: B -> C  (really this is the image of some functor, but let's drop that)
20:56:10 <DigitalKiwi> http://en.wikibooks.org/wiki/Haskell/ someone said this last night, but there is also real world haskell and haskell for c programmers and learn you a haskell >.> and probably thousands of other sites!
20:56:11 <Cale> What will the limit of this diagram look like?
20:56:23 <blackdog> @tell dons |"fairfield, ca mall",something| should be parsed as two CSV fields, not three...
20:56:24 <lambdabot> Consider it noted.
20:56:31 <blackdog> uorygl: cheers:)
20:56:43 <uorygl> The set of pairs (x,y) for which f(x) = g(y) (modulo functors)?
20:56:51 <Cale> yeah, exactly
20:57:01 <blackdog> DigitalKiwi: wait, so the problem now is that haskell has too much documentation?
20:57:23 <Cale> So that's called a pullback
20:57:32 <DigitalKiwi> well quality over quantity as i always say
20:57:50 <Cale> You can generalise all this to any category you want to work with, since it's all expressed at the level of objects and arrows.
20:58:10 <uorygl> Let me see if I can figure out quickly what happens if the arrows are f : A -> B and g : B -> A.
20:58:30 <uorygl> If I'm lucky, it's the part where f and g are inverses.
20:58:36 <DigitalKiwi> like with lua, just about everything i ever need to know i can find on lua-users wiki or lua.org in programming in lua or the reference manual, and if that fails there is IRC, but with haskell there are so many choices i don't know which to stick with :(
20:59:08 <uorygl> If I'm unlucky, it's the part where f . g is eventually periodic or something weird like that.
20:59:15 <uorygl> If I'm really unlucky, it's neither.  :P
20:59:46 <uorygl> I wish I knew a professor at my university who was willing to teach me like this.
20:59:48 <RambO> How can I organice my Hunit's tests?
20:59:52 <uorygl> But I must go now.  Bye, and thanks!
20:59:57 <RambO> I have them in a folder named "Tests"
21:00:13 <RambO> but in each test I should import the module that is going to be tested..
21:00:14 <DigitalKiwi> bai uorygl
21:00:33 <RambO> So, how can I do to import the modules that are in a higher folder level?
21:00:44 <Cale> uorygl: you're quite welcome
21:00:56 <Cale> uorygl: If you want to continue at some point, let me know :)
21:04:15 <Cale> uorygl: Yeah, it looks like it's going to be {(x,y) : x in X, y in Y, f(x) = y, g(y) = x}
21:04:45 <RambO> anyone :( ?
21:05:02 <Cale> RambO: hmm...
21:05:21 <blackdog> RambO: it's a bit of a problem, actually
21:05:24 <blackdog> it can be done
21:05:24 <Cale> RambO: Normally GHC likes to determine where to look for a given module based on its name
21:05:34 <blackdog> but we don't have a standard layout of where to put tests, and how to find files
21:05:38 <Cale> RambO: You can explicitly pass it a bunch of code
21:05:42 <RambO> Cale: How do you make your tests modules for HUnit?
21:06:23 <pato> Hi guys, I marco's teammate. What we are trying to do is to have HUnit tests separeted from the source code. any idea?
21:06:38 <pato> I'm Ram0's teammate*
21:06:39 <RambO> (im Marco) ¿?
21:07:57 <Cale> You could name the module starting with "Tests."
21:08:21 <Cale> For example, you have a source file  Tests/A.hs  and it will start with  module Tests.A where ...
21:08:28 <fatalerro> I need an assembler type language in haskell are there any available?
21:09:01 <Cale> fatalerro: Well, what do you mean by that? There's an LLVM binding
21:09:01 <fatalerro> it has to be portable though
21:09:05 <blackdog> Cale: hopefully whoever took on the cabal testing GSOC project will straighten it out a bit:)
21:09:29 <Cale> RambO: try that and see if it doesn't straighten everything out
21:09:31 <fatalerro> Cale: I just need a language compile i will write
21:09:33 <RambO> Whe have a module "Rock", and want to create a module with tests cases for Rock, so we put it in Tests/RockTest.hs, how do we import Rock from RockTest to run the tests?
21:09:39 <fatalerro> compiler*
21:10:23 <pato> BTW: we HAVE to use hugs, althoug ghc looks cooler
21:10:25 <Gracenotes> fatalerro: the LLVM binding is good for that. And very portable.
21:10:34 <Cale> RambO: At the top of Tests/RockTest.hs, put   "module Tests.RockTest where" and then "import Rock"
21:10:46 <RambO> Oh
21:10:52 <Cale> RambO: I *think* that works...
21:11:01 <pato> let's test it :)
21:11:06 <fatalerro> I will produce obfuscated code so LLVM while good is no good :)
21:11:16 <Gracenotes> although it's in a particular format, uses static single assignment, but performs well
21:11:25 <fatalerro> unless i can make llvm not optimise
21:11:35 <Gracenotes> okay, if it's obfuscated, then you're definitely not making it portable easily...
21:12:04 <Cale> fatalerro: Will x86 do?
21:12:19 <Gracenotes> are there machine code-to-machine code obfuscators out there?
21:13:20 <pikhq> Gracenotes: No, but modern compilers tend to produce "obfuscated" output.
21:13:21 <fatalerro> cale i need 64bit and 32bit
21:13:28 <Gracenotes> -_-
21:13:36 <pikhq> fatalerro: Yes, those are supported LLVM backends.
21:13:38 <fatalerro> Gracenotes: yes
21:14:16 <fatalerro> pikhg my problem is that if i obfuscate code that the LLVM optimizer will deobfuscate it :)
21:14:17 <pikhq> Gracenotes: And GHC produces *actually* obfuscated output. :P
21:14:29 <Gracenotes> depends how close your programming language's semantics are to assembly. gcc-produced stuff is readable enough. mostly.
21:14:56 <blackdog> fatalerro: what's the motivation in making obfuscated code?
21:14:59 <Cale> fatalerro: What is the purpose of this program?
21:15:01 <fatalerro> i producing a exe protector against crackers
21:15:10 <Cale> tsk
21:15:12 <blackdog> if you want real security, that won't stop a determined cracker
21:15:13 <pikhq> fatalerro: You are asking for an impossible task.
21:15:16 <Cale> Don't you know that's hopeless? :)
21:15:19 <pikhq> Quite literally impossible.
21:15:19 <fatalerro> i started in C++ but the protector is static
21:15:32 <blackdog> ah, majestic quadrophonics
21:15:45 <fatalerro> Cale: i used to crack software so i know whats possible
21:16:00 <winxordie> fatalerro: I personally commend you for picking such a Herculean task.
21:16:16 <pikhq> Hercules himself would be impressed if you pulled it off.
21:16:25 <blackdog> I did see a cool hack the other day
21:16:35 <fatalerro> Making it hard is good enough but if its static they will find a generic method of attack and C++ produces static code
21:16:38 <pikhq> Of course, it's about on par with my suddenly teleporting to the moon.
21:16:41 <winxordie> and "what's possible" changes ever Black Hat convention convention ;)
21:16:43 <winxordie> *every
21:16:52 <blackdog> basically, if the cheating detector noticed that the software had been cracked, it would change events, but only halfway through the game
21:17:01 <DigitalKiwi> "i used to crack software so i know whats possible" you don't seem to know what is impossible though :)
21:17:16 <Gracenotes> it's very likely no one will try to crack anything, depending on the scale of usage
21:17:17 <blackdog> so people would release software that they thought they'd cracked, only to get shown up halfway through when somebody actually played it
21:17:27 <fatalerro> winxordie: thats why i want to make my own compiler that will scrable the entire protector code on each compile
21:17:34 <winxordie> blackdog: that's pretty cool, do you have a link?
21:17:57 <pikhq> fatalerro: Congrats, you've reduced the entire thing to a trivial cryptographic matter.
21:18:06 <kmc> @protontorpedo
21:18:07 <lambdabot> is haskell nicer than clisp?
21:18:19 <blackdog> winxordie: i can't find it :/ sorry
21:18:27 <winxordie> fatalerro: ooh. that's a tough one. have you checked out the google NaCl by any chance? they had a similar idea without the obfuscation if I remember.
21:18:42 <kmc> similar to what part then?
21:19:00 <Cale> fatalerro: If LLVM's optimisation is enough to deobfuscate the code, then couldn't the crackers just do that?
21:19:00 <pikhq> Wherein you are trying to send a message from Alice (you) to Bob (the computer, and indirectly the person with the program), while trying to keep the key from Eve (the person with the program, and indirectly the computer).
21:19:35 <pikhq> In other words: about as feasible as making water not wet.
21:20:01 <DigitalKiwi> towel!
21:20:11 <pikhq> DigitalKiwi: Still wet.
21:20:13 <winxordie> kmc: something about using static analysis to sandbox stuff - seems a bit similar, at least at this hour
21:20:14 <gweiqi> blackdog: it was that pyro dragon game, right?
21:20:16 <DigitalKiwi> actually if you freeze it...
21:20:21 <sshc> :D
21:20:25 <sshc> Freezer!
21:20:28 <pikhq> Not water any more.
21:20:29 <pikhq> :P
21:20:32 <DigitalKiwi> uh
21:20:34 <Cale> If Eve = Bob, then it's impossible to send a message from Alice to Bob without Eve also getting the message ;)
21:20:34 <DigitalKiwi> yes, it is
21:20:36 <fatalerro> Cale: does LLVM optimise boolean logic ie, if i convert of compares to some NAND computations will LLVM optimize that back to cmp instruction?
21:20:37 <pikhq> Just water ice.
21:20:58 <pato> Cale
21:21:00 <Obfuscate> fatalerro: Obfuscation does not provide security. You'll gain the same protection from generic crack applications just by scrambling the object order with a linker script and stripping symbols.
21:21:04 <Cale> fatalerro: Why should that matter?
21:21:06 <DigitalKiwi> it's still H2O, just in a solid form
21:21:14 <pato> I'm afraid your method didn't work
21:21:15 <RambO> Cale:  :( http://pastebin.com/xG29SnZL
21:21:33 <Cale> pato: I tried my method, and it *did* work
21:21:40 <fatalerro> Cale: because i don't want the compiler to undo the obfuscation
21:22:11 <Cale> fatalerro: How is doing a bunch of nands going to help protect the program from being cracked?
21:22:17 <pikhq> fatalerro: If a compiler can undo the obfuscation... One can just compile your obfuscated code.
21:22:17 <pato> So I'me the error :P
21:22:23 <fatalerro> Cale: i also know that crackers don't have code optimizer to deobfuscate code
21:22:28 <pikhq> And, yeah, NAND isn't going to help anything.
21:22:43 <pikhq> Hah. Hah!
21:22:49 <Cale> pato/RambO: don't indent the import declaration
21:22:54 <pikhq> Yes they do.
21:22:55 <pikhq> http://llvm.org/
21:23:02 <pikhq> Or at least, they can in a few seconds.
21:23:24 <pato> THANK YOU CALE =)
21:23:26 <fatalerro> Cale: thats just and example because instead of a jump to a single bit of code i can make 4 possible branches
21:23:43 <fatalerro> making analysis harder
21:23:49 <iaefai> Can bird tracks '>' be more than one layer thick? (>>) I am implementing a feature in my editor to automatically put bird tracks on each selected line and need to know.
21:23:51 <gweiqi> winxordie: http://www.gamasutra.com/view/feature/3030/keeping_the_pirates_at_bay.php
21:23:53 <fatalerro> its just and example
21:23:59 <gweiqi> winxordie: this is what blackdog was referring to
21:23:59 <RambO> Someone once told me that "if there's an error, indent."
21:24:01 <pikhq> fatalerro: Yeah, *hahahah*. *Compilers generate that sort of output*.
21:24:03 <RambO> :(
21:24:06 <RambO> Thanks cale! :)
21:24:25 <Cale> iaefai: I don't think so.
21:24:27 <pikhq> I seem to recall GCC sometimes compiling switch statements into a binary search of a jump table.
21:24:31 <djahandarie> *hahahahaha*
21:24:38 <blackdog> gweiqi: ah, the power of the lazyweb
21:24:38 <winxordie> gweiqi: thanks!
21:24:41 <iaefai> Cale, does the > have to be at the first column?
21:24:55 <Cale> iaefai: yeah, and it must be followed by a space, I believe
21:25:04 <iaefai> ok, easy enough to implement
21:25:05 <winxordie> blackdog: lolwut? lazyweb? I don't recall these tubes being lazy-evaluated
21:25:07 <kmc> <RambO> Someone once told me that "if there's an error, indent."  <--- this sounds like the kind of advice one should always ignore
21:25:19 <DigitalKiwi> pikhq: sounds about like what i've heard
21:25:20 <Cale> iaefai: also, the lines before and after the block of birdtracked lines must be completely empty
21:25:22 <blackdog>         kmc: really?
21:25:24 <DigitalKiwi> maybe
21:25:26 <DigitalKiwi> >.>
21:25:29 <Adamant> don't ask game developers how to keep your games from getting cracked, ask reversers. unless the game developer is a reverser or ex-reverser.
21:25:30 <fatalerro> So my question is simple i can design my own assembler type language that produces 64 and 32 bit code on LLVM? ANd have LLVM not ptimise the code it produces?
21:25:34 <iaefai> Cale, think I must leave that part to the user :p
21:26:00 <iaefai> Thank you for the info
21:26:01 <RambO> kmc: I have read it somewhere in a tutorial :P It was a joke, of course, but today I had a problem and the solution was indent :p
21:26:02 <pikhq> fatalerro: Yes, *but you are doing an impossible task* with this "obfuscation" thing.
21:26:02 <DigitalKiwi> fatalerro: you are approaching this the wrong way is what people are telling you
21:26:09 <pikhq> And doing it *poorly*.
21:26:15 <DigitalKiwi> actually i think they are telling you that you shouldn't approach it at all
21:26:21 <fatalerro> pikhq: why is it impossible?
21:26:26 <Cale> Better to go off and write some software which does something useful.
21:26:31 <Cale> :)
21:26:34 <kmc> i am wondering what this discussion of obfuscation has to do with Haskell
21:26:50 <DigitalKiwi> kmc: did you have a nice lay?
21:26:55 <kmc> yeah
21:26:57 <Cale> kmc: I think he's looking for a Haskell library for generating assembly language.
21:26:58 <fatalerro> haskell is good for writing compilers
21:27:01 <kmc> if by which you mean shower
21:27:13 <kmc> true
21:27:20 <Cale> There's a library for generating x86.
21:27:31 <bos> And LLVM.
21:27:34 <fatalerro> Cale: yeah i saw that
21:27:38 <pikhq> fatalerro: Because it damned well *is*.
21:27:39 <DigitalKiwi> hey, one can get laid in the shower! >.>
21:28:02 <fatalerro> pikhq: i don't see why i just gave an example
21:28:27 <pikhq> Any damned operation you can do to the code has an inverse. You may not get the exact same code out from this inverse, but you will get *similar* code out.
21:28:28 <DigitalKiwi> i don't see why you gave one either
21:28:39 <kulin> damn
21:28:44 <Adamant> kmc: compiled Haskell is a target for reversers and on-topic, using Haskell for reversing is also on-topic, etc. :P
21:28:54 <kmc> okay
21:29:02 <Adamant> or for generating 'protections' (read: speed-bumps)
21:29:06 <iaefai> I was thinking on having my key combo for bird tracking and unbird tracking as CMD-, and CMD-. but the , conflicts with the common key usage for preferences. Does it seem natural to have this as the key set, or have perhaps CMD-< (i.e. add a shift key)?
21:29:19 <Obfuscate> fatalerro: Most crackers use utilities like IDA, which makes defeating techniques like that trivial. If the compiler can optimize it away, a decent reverse engineering toolkit can strip it on a disassembly.
21:29:30 <fatalerro> pikhq: its only meant to slow peaple down not be foolproof
21:29:41 <Gracenotes> fatalerro: well, in THAT case...
21:29:48 * p_l found that IDA can be sometimes rather confused...
21:30:00 <Obfuscate> I gave you a suggestion that would slow people down just as much (probably more, actually), and requires very little effort.
21:30:12 <Gracenotes> (funny use of "foolproof" there, actually)
21:30:15 <fatalerro> Obfuscate: what was that
21:30:22 <pikhq> fatalerro: Well, in *that* case what you should do is release the source code.
21:30:32 <pikhq> That'll slow down reverse engineering efforts for sure!
21:30:43 <fatalerro> pikhq: ??
21:30:44 <winxordie> Some advice please - I know how to manipulate *basic* monads. Should I learn more category theory or can I try a headlong rush at learning concurrency via STM?
21:30:58 <Cale> winxordie: hehe, what a strange set of options :)
21:31:00 <pikhq> In fact, there won't be any reverse engineering.
21:31:05 <DigitalKiwi> hehe
21:31:08 <fatalerro> pikhq: lol
21:31:10 <p_l> A certain binary I tried decompiling was optimized so that all the logic went inside branches/jumptables inside main loop, but it still kept (and called) the functions from which it took the code...
21:31:11 <kulin> winxordie you dont need to know much to use STM, that is sort of the point of STM
21:31:11 <DigitalKiwi> i'd do it for fun!
21:31:12 <pikhq> Just *fruitful* endeavours.
21:31:13 <Gracenotes> write a concurrent category theory library!
21:31:14 <Obfuscate> fatalerro: I only typed three lines in the last ten minutes... surely, it's one of them.
21:31:23 <DigitalKiwi> then i could see how good of job the tools did ;D
21:31:26 <Adamant> pikhq: not usually, but you would be surprised :P
21:31:28 <kmc> winxordie, category theory is nearly useless for writing practical code
21:31:34 <Gracenotes> wherein categories and arrows simultaneously update their state
21:31:37 <winxordie> Cale: surely not that strange?
21:31:51 <Cale> winxordie: Learning category theory is good if you're interested in bringing new abstractions into the world of programming, but if all you want to do is write computer programs, then you don't need to worry about it at all.
21:31:53 <kmc> winxordie, should you learn basketball or to play the tuba? depends what you want to do
21:32:00 <pikhq> (seriously man, trying to make things hard to reverse engineer is just a *time sink*. You throw away *your* time and then encourage others to throw away *their* time. Stop doing it.)
21:32:05 <baguasquirrel> winxordie, category theory is like a liberal art.  you study it so you think better.  :)
21:32:10 <ddarius> kmc: I wouldn't quite put it that way.  It is not necessary for practical programming in Haskell at all, but it is not useless for writing code.
21:32:10 <fatalerro> Obfuscate: but such a toolkit does not yet exist :)
21:32:11 <kmc> winxordie, anyway, STM is pretty easy.  look at the STM chapter in RWH
21:32:17 <winxordie> kulin, kmc: thanks.
21:32:31 <Cale> winxordie: It's not necessary to know any category theory at all to use Haskell.
21:32:35 <Adamant> pikhq: unless you have very specific commercial demands, then basically yeah
21:32:38 <winxordie> baguasquirrel: will do.
21:32:38 <DigitalKiwi> kmc: basketball
21:32:42 <kmc> ddarius, i think "nearly useless" is accurate, but maybe that's because i don't know enough CT
21:32:45 <Cale> (including the categorical definition of what a monad is)
21:32:47 <fatalerro> pikhg: software piracy costs the industry lots of money
21:32:49 <DigitalKiwi> tuba is too big and costs more
21:33:21 <kulin> fatalerro why are you afraid of people stealing your work? (not judging, just curious)
21:33:24 <pikhq> fatalerro: Yeah, being in the industry of selling things that are inherently copiable would tend to do that.
21:33:26 <ddarius> kmc: For example, the proof that all finite limits can be made from finite products and equalizers can be directly transcribed into a compilation system that reduces complex unifications into basic ones.
21:33:27 <winxordie> Cale: well, idk. Basic category theory helped me conceptualize monads better. I guess you're right in terms of 'necessity'
21:33:27 <kulin> most software benifits from being open source
21:33:29 <c_wraith> fatalerro: that's an interesting assertion.  Too general.  Adobe makes money from piracy.
21:33:40 <baguasquirrel> yea, as far as I can tell, if you have a good idea, you have to ram it down people's throats
21:34:11 <ddarius> kmc: I recommend Burstall's "Computational Category Theory" for an idea of one line of work in which category theory is directly applied to programming.
21:34:15 <DigitalKiwi> kulin tell that to the open ati driver people ;D
21:34:24 <fatalerro> c_wraith: that's because experts use and buy there software what about small utilities how may here are running a pirate version of winrar?
21:34:40 <pikhq> DigitalKiwi: Using it as we speak.
21:34:50 <Adamant> I'm not running winrar, you insensitive clod :P
21:34:54 <Cale> winxordie: If you enjoy category theory, then pick up a copy of Awodey's book, and study it. But if you're more interested in writing software, it's not going to get you anywhere too quickly (though it might give you some insights into how to structure libraries and such)
21:35:07 <pikhq> fatalerro: I don't have the *API* required to run WinRAR you insensitive clod.
21:35:08 <c_wraith> people still use winrar?  I thought that program died a deserved death long ago.
21:35:20 <pikhq> c_wraith: RAR still exists, sadly.
21:35:30 <DigitalKiwi> pikhq: wine
21:35:34 <fatalerro> pikhq: hey thats what Adamant said :)
21:35:38 <pikhq> DigitalKiwi: Oh, right, that.
21:35:55 <winxordie> Cale: seems there's no end to studying the theory of FP, but will give a shot at it
21:35:57 <fatalerro> winrar is good
21:35:57 <c_wraith> pikhq: well, yes.  But there are other programs to uncompress rar files
21:35:59 <Adamant> fatalerro: it's also true in my case, but technically not what I said :P
21:36:09 <Cale> winxordie: There is no end.
21:36:38 <pikhq> c_wraith: Yeah.
21:36:43 <Cale> winxordie: Basically, the reason we're looking into category theory is that it's a giant library of potentially-useful abstractions.
21:36:50 <fatalerro> I justed wanted advice on writing an assembler type lang in haskell and producing obfuscated code :(
21:37:33 <Cale> winxordie: and as computer scientists, we're always interested in new ways to simplify or at least simplify reasoning about our code.
21:37:39 * DigitalKiwi runs a pirated winrar in an illegal copy of crossover office, which runs in a vmware instance of redhate, on a pirated windows 7, on a stolen laptop
21:37:46 <DigitalKiwi> oh and i'm using someone elses wifi
21:37:47 <DigitalKiwi> ;D
21:37:52 <winxordie> Cale: gotcha. *sigh* There's so much reading to do to learn the theory though. *A noob complains*
21:38:00 <pikhq> fatalerro: We feel obligated to not just point you at resources to do something, but also tell you when you're doing something stupid. :P
21:38:00 <baguasquirrel> fatalerro, I dunno man, it seems like my code starts out obfuscated and then I have to unobfuscate it :(
21:38:03 <Cale> winxordie: Then ignore it :)
21:38:18 <DigitalKiwi> (totally made that up if it wasn't obvious)
21:38:19 <kulin> DigitalKiwi, that is pretty bad, but im using spare cycles on your machine for my file server
21:38:20 <fatalerro> lol
21:38:28 <Cale> winxordie: It won't really make any immediate difference on your ability to program in Haskell.
21:38:30 <DigitalKiwi> kulin: oh noews D:
21:39:11 <Cale> winxordie: Learning something like how STM works will have a much bigger effect :)
21:39:15 <kulin> winxordie if yer nervous about using STM don't be, it is very abstract and you literally cannot do it wrong
21:39:26 <winxordie> Haha, alright.
21:39:32 <kmc> winxordie, read the STM chapter in RWH
21:39:34 <kmc> it's free online
21:39:36 <kmc> @where rwh
21:39:36 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:39:45 <fatalerro> pikhq: Most software is to easy to crack thats why i wanted to make this to help those type of people
21:39:45 <DigitalKiwi> kmc: everything is free online
21:39:50 <kmc> hehe
21:40:02 <winxordie> thanks for the help everyone ^_^
21:40:16 <Cale> Well, I wouldn't go that far. You *can* do it wrong. You can still write bugs in STM, and while it's not as easy to deadlock, it's still possible to have transactions which take too long and are repeatedly trampled.
21:40:38 <kulin> true, but im really bad and i figured it out
21:40:44 <winxordie> and now a tired undergrad must bid ye goodnight. thanks again!
21:41:06 <DigitalKiwi> goodnight
21:41:11 <Cale> But compared to locks and condition variables, you can't do it wrong ;)
21:41:37 <pikhq> fatalerro: You're not going to make things "hard to crack" with this. At best, you're going to make people write another decracking tool.
21:42:22 <pikhq> You are facing a thankless, tedious, and futile task.
21:42:47 <kmc> let's all say it the hundredth time
21:42:56 <mathstuf> kmc: thanks for the help, worked like a charm
21:42:57 <systemfault> Ubisoft DRM has been cracked..
21:43:02 <fatalerro> pikhg: it was going to be one piece in the puzzle i was aslo planning on making a virtual machine generator so all the obfuscated code ran on a unique virtual machine (each compile make a unique one with different opcode etc)
21:43:04 <kulin> i dont know if i believe your shower was that great after all
21:43:15 <Cale> Ubisoft's DRM was cracked almost instantly.
21:43:29 <fatalerro> systemfault: not instantly it took a while
21:43:39 <systemfault> fatalerro: I agree with you.
21:43:46 <systemfault> fatalerro: You see the point.
21:44:02 <Cale> It was cracked on day one
21:44:05 <mgsloan> I have not yet learned category theory myself, but I have looked at it a few times, and the reason I want to learn it fully is it seems to allow you to analyze some of the properties of expressive systems.  Does this make any sense to those that actually do know it?
21:44:11 <pikhq> Do something more interesting and useful, like... Optimization. Emulation. Assembly coding.
21:44:41 <pikhq> *Something* that isn't made useless in a few days.
21:44:45 <FunctorSalad> it's 'mission accomplished' if it's inconvenient for the majority of you customers to crack it, isn't it
21:44:53 <FunctorSalad> not if it's impossible
21:45:13 <c_wraith> the majority don't need to crack it.
21:45:13 <fatalerro> pikhg: what ideas did you have?
21:45:17 <Cale> mgsloan: Well, I'd say the most useful thing it does is that it helps you find the right definitions when you're studying something new and don't know what those are.
21:45:19 <c_wraith> once one cracks it, the game is over.
21:45:22 <systemfault> FunctorSalad: The majority of pirates just double-click on the .exe
21:45:27 <systemfault> They don't crack it
21:45:41 <pikhq> fatalerro: Write. Something. Else.
21:46:27 <fatalerro> pikhq: nothing else really excites me
21:46:27 <Cale> FunctorSalad: The point is that as soon as one person cracks the program, then the crack is distributed via the internet (usually along with the software itself), and essentially the copy protection no longer exists.
21:46:28 <blackdog> pikhq: it's not _totally_ stupid for games. if you can delay the pirates by a week or two, you've managed to sell a lot of games already
21:46:28 <FunctorSalad> systemfault: true... I was a bit on a different page there
21:46:39 * BMeph refuses to touch Ubisoft products, simply because the _normal_ products are of such low quality.
21:46:45 <blackdog> but trying to write a generic toolkit for obfuscation will kill you
21:46:53 <FunctorSalad> (about *security* being nontrivial even with preexisting tools)
21:47:03 <FunctorSalad> but different thing, sure
21:47:14 <mgsloan> cale: so, given a few definitions, category theory allows you to derive further definitions that should be correct (and maybe if they aren't you should think harder about your definitions)
21:47:19 <fatalerro> blackdog: to much work?
21:47:46 <mgsloan> ?
21:47:50 <blackdog> fatalerro: no - it's just that someone will write a cracker for your generic toolkit, and then _all_ the games will be cracked
21:48:07 <fatalerro> maybe i should write an ad remover then
21:48:20 <blackdog> and it'll be a more attractive target, too - bigger payoff and more kudos
21:48:22 <fatalerro> remove all advertising on websites
21:48:22 <kmc> hmm
21:48:57 <fatalerro> I don't see it that challenging though
21:48:58 <pikhq> fatalerro: Already done. :P
21:49:06 <fatalerro> pikhq: really?
21:49:07 <Cale> mgsloan: Sort of. Basically, if you're studying a new sort of mathematical object, then it basically asks you to consider what the structure-preserving transformations between objects of that type are, and from that, gives you a whole set of definitions to try to apply to your structures, that might be important to their study.
21:49:18 <pikhq> Yeah... I <3 AdBlock.
21:49:28 <fatalerro> Adblock sucks
21:49:46 <kmc> i'ma just say it, i think this obfuscation discussion is annoying and off-topic.  not sure my opinion should count for anything
21:50:03 <Cale> mgsloan: Some of them might turn out to be trivial, and some of them might not make any sense for your object, but generally it's pretty successful in that regard.
21:50:10 <fatalerro> kmc: annoying?
21:50:12 <pikhq> kmc: It started on-topic at least!
21:50:18 <pikhq> kmc: He wanted to do it in Haskell!
21:50:24 <fatalerro> YES!
21:50:44 <kulin> is Have a type in haskell?
21:50:47 <fatalerro> obfuscater in haskell!!
21:50:49 <kulin> or in one of the libraries
21:50:54 <pikhq> kulin: No, but it can be.
21:51:24 <mgsloan> cale - yeah, definitely sounding like functors :D
21:51:49 <pato> I've got another question about HUnit P:
21:51:51 <pato> :P
21:52:20 <pato> how can I test constructor functions?
21:52:27 <mgsloan> I'll study further before getting into much of a conversation about it, though
21:52:34 <Cale> mgsloan: Well, functors are even more interesting -- they tell you how to look for relationships between your new object of study and other existing categories (other branches of mathematics)
21:52:36 <fatalerro> trully what kind of software is missing in the market?
21:52:48 <mgsloan> right, the category of categories
21:52:58 <fatalerro> everything i can think of is already coded
21:53:07 <Cale> Or indeed, you can have functors from your category to itself, and those will tell you something about its structure.
21:53:35 <Cale> But I was initially just thinking of things like "product" and "exponential object" and so on.
21:53:51 <mgsloan> ahh, gotcha
21:54:40 <kmc> pato, you mean the constructors defined for a data type?
21:54:46 <mgsloan> this will probably further emphasize my ignorance, however, one thing that always confused me about morphisms is how do you study non unary operations? equivalent of currying?
21:54:53 <pato> kmc: yeah
21:55:04 <Cale> mgsloan: That's what exponential objects sort of do.
21:55:06 <kmc> pato, what would you test? they do nothing, by definition
21:55:21 <twink> I always thought ends and coends were kind of cool because they used notation that looked like integrals.
21:55:55 <Cale> mgsloan: But if you have a *lot* of that, you could even use a multicategory.
21:56:19 <kulin> so i am going to end up making a type "data DoubleKey a b = MkDoubleKey (Maybe a) (Maybe b)" and creating an instance of equal for it so that it can be used in Data.Map.lookup so that if one value (im not sure what you call it) is nothing, it is ignored in the comparison
21:56:31 <kulin> that seems really wrong to me, is there anything which does that more gracefully?
21:56:33 <mgsloan> does that extend categories to have multiple sets of objects?
21:56:35 <pato> kmc: but a function made by myself, not a custructor constant
21:56:49 <kmc> pato, oh.  then you test it like any other function?
21:56:55 <pato> sorry if i'm messy, I'm too  used to OOP
21:56:57 <Cale> mgsloan: Yeah, basically each arrow has a particular tuple of objects as its domain
21:57:03 <mgsloan> and then your morphisms would have to be arrows with multiple sources
21:57:04 <mgsloan> yeah
21:57:07 <kmc> kulin, what is your goal?
21:57:27 <mgsloan> is that the domain with respect to both ends, or just the source?
21:57:29 <kulin> to have a map where two keys can find the same element, but more importantly so that when you delete an element, both keys are removed
21:57:37 <kulin> without having a weird function outside which maintains two lists
21:57:47 <kmc> kulin, why not use two maps?
21:58:02 <kulin> because it is possible somehow through some mistake to forget to update one
21:58:09 <pato> kmc: I have this function http://www.pastie.org/949620
21:58:19 <pato> and I wanna test it works correctly
21:58:24 <kmc> pato, ah.  a "smart constructor"
21:58:31 <kmc> they're sometimes called
21:58:51 <kmc> meaning it calls one of the data type's constructors but after doing some checks or precomputation
21:59:01 <mgsloan> it makes sense that you need exponential objects - functions are exponential type
21:59:02 <pato> but in my test module I don't have "Sto NombreDeAccion Dinero" defined
21:59:14 <kmc> pato, why not?
21:59:20 <pato> yeah, that precomputation is what I wanna test
21:59:32 <Cale> mgsloan: yeah, so the exponential object generalises that idea to arbitrary categories, and it basically does it by analogy with currying :)
21:59:34 <pato> because they are different modules
21:59:42 <kmc> pato, and you don't export Sto?
21:59:56 <kmc> pato, i'm afraid you'll have to either put your tests in the same module as your data type, or export Sto
22:00:16 <pato> no, I can't. My professors don't let me export it :(
22:00:49 <pato> maybe I'll have to test it in the same module
22:00:53 <pato> what a pitty :(
22:00:56 <ddarius> twink: (Co)ends are kind of cool because they are a fairly comprehensive, yet convenient calculational tool.
22:00:59 <kmc> in the latter case, you can make an "Internals" module that exports everything, and provide the user a different module that exports only some stuff
22:01:07 <RambO> we can use only 20 functions. And we can't use high order :P
22:01:11 <kmc> wow
22:01:17 <kulin> oh this is better: data EitherKey a b = BothKeys a | LeftKey a | RightKey b
22:01:34 <kmc> BothKeys a b ?
22:01:39 <Cale> mgsloan: So that arrows X -> Z^Y directly correspond to arrows X x Y -> Z in a particular way
22:01:40 <twink> ddarius: Really? It'd be nice if I remotely understood them vs. thinking the symbol looks neat.
22:01:44 <kulin> ya, a b :)
22:02:19 <DigitalKiwi> i hate professors that place stupid restrictions on homework assignments :(
22:02:33 <pato> kmc, can you explain me about that possible "Internals" module?
22:02:38 <mgsloan> right, that's how you'd convert from something using exponential objects to a multicategory
22:04:24 <pato> that's because it's our firts course
22:04:47 <pato> we study CS, and there are a lot of people without previous programming experience :s
22:06:05 <RambO> The Idea of learning haskell in this course is to get used to recursion
22:06:15 <deech> Hi all, does any have the recent HaRe working with Emacs?
22:08:06 <DigitalKiwi> grr
22:08:20 <DigitalKiwi> dislike instructors that get you used to recursion!
22:10:21 <Philippa> it's easier to get used to iteration in terms of recursion than vice versa
22:10:45 <Philippa> though using HOFs that capture patterns of recursion or iteration is better
22:11:07 <copumpkin> like zygohistomorphic prepromorphisms, of course
22:11:18 <ezyang> :^)
22:11:26 <copumpkin> ezyang: what's your Z stand for by the way?
22:11:31 <ezyang> Zelin
22:11:33 <copumpkin> Zorro
22:11:34 <copumpkin> oh
22:11:37 <copumpkin> equally cool
22:11:50 <ezyang> Actually, it's "Zeppelin." As in, "Ed Zeppelin"
22:11:53 <copumpkin> lol
22:11:54 <ezyang> :o)
22:18:58 <djahandarie> copumpkin, have you ever actually used that before?
22:19:11 <copumpkin> nah, I'm not sure anyone has
22:19:28 <copumpkin> I've experimented with the parts that make up that monstermorphism though
22:20:37 <djahandarie> Wouldn't it technically be zygohistoprepromorphism? :P
22:22:34 <glguy_> popquiz f k = f (Î» a _ â k a) k   -- name that function!
22:22:46 <ezyang> h-bar!
22:22:51 <ezyang> oh wait
22:23:14 <c_wraith> can I name it Eric?
22:23:15 <copumpkin> :t let f k = f (\ a _ -> k a) k
22:23:16 <lambdabot> <no location info>:
22:23:16 <lambdabot>     not an expression: `let f k = f (\ a _ -> k a) k'
22:23:20 <copumpkin> :t let f k = f (\ a _ -> k a) k in f
22:23:21 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
22:23:21 <lambdabot>     Probable cause: `f' is applied to too many arguments
22:23:21 <lambdabot>     In the expression: f (\ a _ -> k a) k
22:23:29 <glguy_> no "popquiz" is the name
22:23:31 <glguy_> f is a parameter
22:23:36 <copumpkin> :t let popquiz f k = f (\ a _ -> k a) k in f
22:23:37 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
22:23:39 <copumpkin> :t let popquiz f k = f (\ a _ -> k a) k in popquiz
22:23:40 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2) -> (t -> t2) -> t3) -> (t -> t2) -> t3
22:23:50 <kmc> @pl let popquiz f k = f (\ a _ -> k a) k in popquiz
22:23:50 <lambdabot> join . (. (const .))
22:23:58 <copumpkin> lol
22:24:01 <copumpkin> revealing
22:24:26 <copumpkin> oh wait
22:24:30 <monochrom> callCC
22:24:33 <glguy_> winner!
22:24:41 <kmc> haha
22:24:47 <copumpkin> yeah
22:24:49 <glguy_> did the 'k' give it away?
22:24:52 <kmc> why does it have so many types?
22:25:13 <glguy_> ?unmtl Cont i a
22:25:13 <lambdabot> (a -> i) -> i
22:25:19 <glguy_> this ^^
22:25:19 <kmc> it's a CPS callCC right?
22:25:22 <copumpkin> :t callCC
22:25:24 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
22:25:31 <copumpkin> where m is (->)r
22:25:44 <glguy_> naw
22:25:47 <copumpkin> no?
22:25:51 <copumpkin> hmm
22:26:01 <copumpkin> oh I guess not
22:26:04 <glguy_> its the type callCC would have without the Cont constructor
22:26:31 <kmc> @unmtl ((a -> Cont b) -> Cont a) -> Cont a
22:26:31 <lambdabot> ((a -> Cont b) -> Cont a) -> Cont a
22:26:38 <kmc> err
22:26:42 <djahandarie> ?
22:26:43 <kmc> @unmtl ((a -> Cont r b) -> Cont r a) -> Cont r a
22:26:44 <lambdabot> ((a -> Cont r b) -> Cont r a) -> Cont r a
22:29:09 <djahandarie> That should be working since it implements the MonadTrans type class
22:30:49 <RambO> How do people indent code in haskell? With tab or with n spaces?
22:31:22 <copumpkin> spaces
22:31:41 <copumpkin> it seems to be consensus to avoid tabs like the plague
22:31:59 <RambO> Oh
22:32:04 <glguy_> tabs show up as a red >------ in my vim
22:32:07 <RambO> 2 spaces? 4 spaces? 8 spaces?
22:32:13 <glguy_> so I know that someone screwed up and put them in the file
22:32:23 <glguy_> Haskell tab-stops are always 8 spaces
22:32:37 <copumpkin> RambO: you use layout
22:32:53 <copumpkin> i.e., not a specific number of them
22:32:53 <kmc> don't use tabs
22:34:00 <Philippa> RambO: whatever looks pretty, basically
22:34:22 <Philippa> I've got my editor set up to indent a space at a time so I can position just where I want
22:34:56 <RambO> Thanks :P I think I will use 2 spaces :)
22:35:00 <glguy_> Did you build a special huge button on the bottom of your keyboard to do that indenting with?
22:36:19 <_rata_> how do I define an action that does nothing?
22:36:36 <copumpkin> moo = return ()
22:37:07 <_rata_> thanks :)
22:37:19 <[swift]_> glguy_: good one
22:38:00 <mathstuf> i keep getting "parse error (possibly incorrect indentation)" on the last line in: http://fpaste.org/CWtP/
22:38:09 <mathstuf> all indentation is spaces
22:38:38 <mathstuf> is there something im just not seeing?
22:38:41 <kmc> mathstuf, you have no "else"
22:38:48 <mathstuf> ah
22:38:49 <mythmon> mathstuf: maybe because if->do is 4 space, and do->print is 3 spaces?
22:38:50 <kmc> maybe you want:
22:38:58 <kmc> when not (null argv) $ do ...
22:38:59 <copumpkin> when (null argv) ...
22:39:00 <mythmon> (does that matter?)
22:39:00 <kmc> :t when
22:39:01 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
22:39:06 <copumpkin> unless (null argv)
22:39:08 <kmc> @src when
22:39:08 <lambdabot> when p s = if p then s else return ()
22:39:12 <kmc> @src unless
22:39:12 <lambdabot> unless p s = if p then return () else s
22:39:52 <mathstuf> interesting
22:40:28 <sbahra> edwardk, ping?
22:40:36 <copumpkin> omg edwardk is here
22:41:13 <mathstuf> kmc: thanks again
22:42:14 <kmc> :)
22:57:16 <pato> I've got one more question =)
22:57:17 <pato> hehe
22:57:44 <pato> how can Unit Test error calls?
22:57:56 <pato> I mean, check if an error was raised
22:58:41 <blackdog> pato: in general, in haskell you try not to throw exceptions
22:58:47 <blackdog> instead using the Maybe monad
22:59:25 <Zao> Either String Kitteh
22:59:25 <blackdog> but if you really need to throw an exception, you can use catch
22:59:27 <kmc> pato, look at Control.Exception
22:59:28 <blackdog> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/Control-Exception.html#5
22:59:34 <kmc> :t \v -> try (evaluate v)
22:59:36 <lambdabot> Not in scope: `try'
22:59:36 <lambdabot> Not in scope: `evaluate'
22:59:56 <kmc> pato, i'd use (try . evaluate) and check the result to be (Left e) for e an expected exception
23:00:43 <copumpkin> @hackage spoon
23:00:43 <lambdabot> http://hackage.haskell.org/package/spoon
23:00:45 * copumpkin whistles
23:00:47 <kmc> pato, remember that exceptions raised by evaluation are not raised until you ask for the evaluation to occur
23:00:57 <pato> I think I'm confused :P
23:01:07 <blackdog> oh, i'd forgotten about spoon. that'll catch them purely, right?
23:01:07 <copumpkin> don't use error calls, how about that
23:01:12 <copumpkin> blackdog: "purely"
23:01:18 <kmc> pato, what are you confused about?
23:01:19 <pato> error "asd" are not exceptions, are they?
23:01:23 <kmc> pato, yes they are
23:01:27 <copumpkin> yeah
23:02:16 <kmc> pato, specifically the exception is of type ErrorCall
23:02:18 * hackagebot repa 1.1.0.0 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-1.1.0.0 (BenLippmeier)
23:02:29 <kmc> in GHCi try this:  try (error "asd") :: IO (Either ErrorCall ())
23:02:31 <pato> great
23:02:33 <kmc> after loading Control.Exception
23:02:45 <gooblygoop> Anyhow know how I can get all combinations of n elements from a list for any general n?  So, for combinations of 3 and the list [1,2,3,4], I get [(1,2,3),(1,2,4),(1,3,4),(2,3,4)].  For combinations of 4, I get just [(1,2,3,4)].
23:02:54 <kmc> pato, do you understand why "evaluate" is necessary there?
23:03:02 <kmc> gooblygoop, you can't as a tuple like that
23:03:11 <pato> not really
23:03:15 <kmc> because the size of the tuple would depend on a runtime arg
23:03:24 <kmc> pato, evaluation is lazy.  exceptions are not raised until the evaluation actually occurs
23:03:36 <kmc> "evaluate x" produces an IO action that, when executed, demands the evaluation of x
23:03:48 <kmc> (remember, execution and evaluation are different things)
23:04:02 <pato> ahh
23:04:09 <pato> right
23:04:11 <gooblygoop> kmc: So, I have to write the algorithm for a specific n?
23:04:18 * hackagebot repa-bytestring 1.1.0.0 - Conversions between Repa Arrays and ByteStrings.  http://hackage.haskell.org/package/repa-bytestring-1.1.0.0 (BenLippmeier)
23:04:19 <kmc> gooblygoop, no.  you will have to get the result as a list-of-lists
23:04:20 * hackagebot repa-algorithms 1.1.0.0 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-1.1.0.0 (BenLippmeier)
23:04:26 <pato> I'm too used to C and it's family
23:04:32 <kmc> and lose the static type guarantee that each of the lists is length n
23:04:34 <pato> where EVERYTHING is evaluated
23:04:42 <kmc> pato, but it will only demand evaluation to "weak head normal form"
23:04:53 <kmc> this could be a problem
23:05:05 <copumpkin> nothing worse than weak head
23:05:09 <kmc> > show (undefined :: [Int])
23:05:10 <lambdabot>   "*Exception: Prelude.undefined
23:05:16 <kmc> pato, ^^^^ note how it prints a " before hitting the undefined
23:05:19 * hackagebot repa-io 1.1.0.0 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-1.1.0.0 (BenLippmeier)
23:05:28 <kmc> that means that forcing the first element of the string is not enough to hit it
23:05:38 <kmc> and therefore that forcing the string to weak head normal form will not hit the exn
23:05:46 <kmc> > rwhnf (show (undefined :: [Int]))
23:05:47 <lambdabot>   *Exception: Prelude.undefined
23:05:50 <kmc> hmm
23:05:59 <kmc> > (show (undefined :: [Int])) `seq` ()
23:06:00 <lambdabot>   *Exception: Prelude.undefined
23:06:08 <kmc> what am i doing wrong?
23:06:16 <pato> mm
23:06:19 <kmc> > rwhnf (show ([undefined] :: [Int]))
23:06:20 <lambdabot>   ()
23:06:22 <kmc> there we go
23:06:31 <kmc> anyway, the moral of the story is
23:06:39 <kmc> if you need to force your data "all the way"
23:06:41 <RambO> whas is rwhnf? O.o
23:06:47 <RambO> @src rwhnf
23:06:47 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:06:48 <scott__> kmc: Earlier, we did it for n = 2:
23:06:51 <scott__> > concatMap (\(a:b) -> map (\k -> (a,k)) b) $ init $ tails [1,2,3]
23:06:53 <lambdabot>   [(1,2),(1,3),(2,3)]
23:06:53 <kmc> import Control.Parallel.Strategies
23:07:03 <kmc> and do (evaluate (v `using` rnf))
23:07:12 <copumpkin> or use deepseq!
23:07:20 * hackagebot repa-examples 1.1.0.0 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-1.1.0.0 (BenLippmeier)
23:07:21 <kmc> rnf and rwhnf are both "evaluation strategies" from Control.Parallel.Strategies
23:07:28 <pato> wow, too much information in such a little time hehe
23:07:28 <kmc> which evaluate to normal form and weak head normal form respectively
23:07:58 <scott__> kmc: So, I can't generalize this to any n?
23:07:59 <kmc> pato, you might not need to understand it all
23:08:10 <kmc> scott__, what would the type be?
23:08:29 <copumpkin> if you don't use tuples you can generalize it
23:08:37 <scott__> Ah, I see.
23:08:40 <copumpkin> tuples are overrated anyway
23:08:48 <scott__> Okay, yeah, screw the tuples.
23:08:48 <RambO> scott__: I think there's a package for combinatorics, maybe you could take a look at it..
23:09:33 <kmc> scott__, i have the solution for n
23:09:36 <kmc> if you'd like to see it
23:09:40 <apolon> hello
23:09:43 <kmc> hi apolon
23:09:49 <scott__> kmc: Yes please!
23:10:41 <kmc> scott__, http://codepad.org/R1U9kNhk
23:10:56 <kmc> i am pretty sure this works, but there may be a faster or smarter way
23:11:33 <jellef> hi all
23:11:39 <kmc> hi jellef
23:12:02 <apolon> could you guys please help me install gtk2hs
23:12:05 <jellef> I thought I might ask a little question here, regarding ghci
23:12:09 <kmc> go ahead jellef
23:12:33 <jellef> when I open ghci, and want to edit, I have to set the editor everytime
23:12:35 <jellef> :set editor vi
23:12:44 <jellef> is there a way that it remembers this setting?
23:12:55 <scott__> kmc: Thanks!
23:12:58 <jellef> everytime I open a new instance of ghci I mean
23:13:06 <mathstuf> jellef: export EDITOR?
23:13:39 <kmc> jellef, you can put commands in ~/.ghci
23:13:40 <kmc> i think
23:13:46 <jellef> I type that in the terminal, outside of ghci, I presume?
23:13:50 <kmc> but yeah perhaps you want to set your EDITOR environment variable anyway
23:13:53 <kmc> which will affect many programs
23:14:08 <kmc> you'd put that in your shell's startup file e.g. ~/.bash_profile
23:14:21 <scott__> kmc: That's exactly what this guy has: http://www.polyomino.f2s.com/david/haskell/hs/CombinatoricsGeneration.hs.txt
23:14:26 <kmc> cool
23:14:35 <kmc> amusing
23:14:38 <kmc> how close it is
23:14:41 <kmc> i didn't copy it, i swear ;)
23:14:47 <scott__> kmc: Ha-ha...
23:15:07 <scott__> kmc: Is there not a popular counting package?
23:15:20 <scott__> kmc: That's the only one I could find.
23:15:23 <kmc> i don't know of one
23:17:06 <mathstuf> when compiling using ghc directly, im getting undefined references on packages installed via cabal
23:17:18 <mathstuf> ghc -static <files..>
23:17:40 <mathstuf> -lhaxr says it doesnt exist
23:18:23 <jellef> @kmc, @mathstuf: thx for your help, it works now :)
23:18:24 <lambdabot> Unknown command, try @list
23:18:25 <apolon> can someone recommend the most straightforward way of installing gtk2hs?
23:18:43 <mathstuf> apolon: distro packages? (assuming linux)
23:18:48 <mathstuf> cabal otherwise, id say
23:18:59 <apolon> cabal can't find it (is it on cabal?)
23:19:04 <copumpkin> you can't use cabal-install for it
23:19:05 <copumpkin> sadly
23:19:12 <copumpkin> and it's a bitch to install on mac os, at least
23:20:02 <apolon> what's funny, on the distro there's only gtk2hs-doc apparently
23:20:15 <mathstuf> weird
23:20:17 <mathstuf> what distro?
23:20:47 <apolon> ubuntu (mint)
23:20:55 <mathstuf> ah
23:21:16 <mathstuf> heh, yeah
23:21:23 <mathstuf> debian also only has -doc
23:21:25 <RambO> Right, in ubuntu it is onli -doc :S
23:22:03 <apolon> how does that even make sense?
23:22:04 <mathstuf> libghc6-gtk-dev
23:22:27 <mathstuf> debian naming schemes being odd again
23:23:03 <mathstuf> http://packages.debian.org/sid/libghc6-gtk-dev
23:23:05 <apolon> ok, installing ghc6-gtk-dev
23:25:43 <apolon> ok, done.  but cabal still says "there is no available version of gtk that satisfies >=0.9.13 && <0.11" when I try to install grapefruit
23:29:06 <apolon> um, how do i check which version of the package is installed?
23:29:30 <pato> hey
23:29:37 <pato> is there any way to do this
23:29:44 <pato> import Control.OldException(errorCalls)
23:29:45 <Zao> ghc-pkg list?
23:29:51 <Zao> Lots of fun commands to it.
23:29:51 <pato> without getting a warning?
23:29:55 <pato> in ghci i mean
23:30:51 <copumpkin> what does the warning say?
23:31:24 <pato>     Warning: Module `Control.OldException' is deprecated:
23:31:25 <pato>                Future versions of base will not support the old exceptions style. Please switch to extensible exceptions.
23:31:25 <pato> Tests/AccionTests.hs:5:28:
23:31:25 <pato>     Warning: In the use of `errorCalls'
23:31:25 <pato>              (imported from Control.OldException):
23:31:26 <pato>              Deprecated: "Future versions of base will not support the old exceptions style. Please switch to extensible exception
23:31:55 <copumpkin> well, seems like you should heed the warning...
23:32:32 <pato> but it's just a collage project, i wont exist for more than a week
23:32:55 <kmc> pato, then ignore the warning
23:33:03 <pato> great
23:33:20 <pato> because I just couldn't manage to do it with exceptions :$
23:33:29 <kmc> why do you need OldException?
23:33:39 <pato> to do this, look
23:33:47 <kmc> pato, try -fno-warn-warnings-deprecations
23:33:53 <copumpkin> don't paste in channel
23:34:00 <pato> http://www.pastie.org/949672
23:34:03 <copumpkin> :)
23:34:32 <kmc> pato, i meant why can you do it with OldException but not Exception?
23:34:46 <pato> beacuse i'm newbye :$
23:35:07 <mathstuf> whats the standard indentation size for haskell? ive seen 3 (due to 'do ' being 3 spaces) and 4 (because thats what many others use)
23:35:24 <kmc> pato, handle (\(ErrorCall _) -> return ()) performCall
23:35:41 <kmc> mathstuf, i use 2 or 4
23:36:03 <kmc> and i tend to leave "do" at the end of a line and put the first statement on the next line indented a standard amount
23:36:14 <kmc> rather than moving the entire block left or right based on the length of the text before "do"
23:36:18 <kmc> looks nicer and less pain to refactor
23:36:27 <pato> kmc THANKS MAN!
23:36:30 <kmc> :)
