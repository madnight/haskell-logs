00:01:28 <m_88> Is it ok to write code like that: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25471#a25471 ?
00:01:58 <CirceTheSorceres> Donald Knuth once said that a program is written for a human
00:02:08 <kmc> m_88, ok how?
00:02:33 <pikhq> CirceTheSorceres: Yes. He also writes executable books.
00:02:35 <kmc> m_88, imo it'd be a lot more readable if you made the lambda expression into a named function in a "where" clause
00:02:42 <copumpkin> omg project euler
00:02:59 <m_88> kmc: i'll take that into account, thanks
00:03:02 <kmc> m_88, also, you should use foldl' instead of foldl unless you have a clear reason not to
00:03:10 <CirceTheSorceres> pikhq: Yes, in MIX too
00:03:12 <m_88> would it be better to use guards?
00:03:15 <kmc> foldl' will force evaluation of the accumulator as it goes, avoiding some notorious space leaks
00:03:27 <kmc> m_88, *shrug* in this case i'm pretty neutral
00:03:34 <copumpkin> it'd be better to use smaller building blocks
00:03:40 <m_88> uhhh
00:03:45 <m_88> sorry i dont know much :[
00:03:54 <m_88> so i dont know about space leaks etc
00:03:55 <CirceTheSorceres> pikhq: I'd love to know his vies about Haskell: I am sure he would love it, especially for built in literate programming
00:04:04 <kmc> m_88, then my advice is just "use foldl' over foldl"
00:04:09 <kmc> but i can explain the space leaks thing if you like
00:04:12 <kmc> it'll take a few min
00:04:16 <copumpkin> think of that problem as three bits: "make the numbers 1 to 1000", "get rid of the numbers I don't want", "add the remaining numbers up"
00:04:21 <m_88> kmc: no thanks
00:04:34 <m_88> kmc: i dont want to put that into my head so early
00:04:56 <m_88> i just started to write haskell code yesterday and it's still really complicated
00:05:05 <kmc> m_88, ok.
00:05:16 <kmc> if you just started yesterday it seems like you're doing pretty well
00:05:31 <kmc> welcome :)
00:05:39 <m_88> thanks
00:06:11 <kmc> oh, but you have to import Data.List to get foldl'
00:06:44 <scotty> Should I use find or intersect if I just want to know whether a list contains a particular element?
00:06:55 <kmc> scotty, you should use Data.Set
00:07:00 <kmc> because searching lists like that is inefficient
00:07:12 <scotty> kmc: Okay, so Set is the most efficient?
00:07:14 <kmc> that said, the prelude function to search a list for a particular element is elem
00:07:15 <kmc> :t elem
00:07:15 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
00:07:20 <scotty> Ah
00:07:40 <copumpkin> there's also a notElem I think
00:07:43 <copumpkin> :t notElem
00:07:44 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
00:07:46 <scotty> I don't know why I didn't see that.
00:07:48 <kmc> find searches by predicate, iirc
00:08:00 <copumpkin> which is more efficient than not . elem
00:08:00 <scotty> > intersect [2] [1,2,3]
00:08:01 <lambdabot>   [2]
00:08:07 <kmc> scotty, do you understand why "elem" would necessarily be slow?
00:08:20 <scotty> Well, it seems like it would be O(n).
00:08:22 <kmc> yeah
00:08:33 <kmc> it has to walk the list one element at a time
00:08:40 <scotty> How can you do any better than that?
00:08:48 <scotty> You have to look at each element.
00:08:53 <kmc> no you don't
00:08:54 <copumpkin> with a special datastructure and knowledge
00:08:58 <kmc> for example, in a sorted array, you can do a binary search
00:09:01 <CirceTheSorceres> scotty: you can sort
00:09:08 <kmc> (but not in a sorted ordinary Haskell list)
00:09:13 <copumpkin> you need additional knowledge (like Ord)
00:09:14 <kmc> Data.Set is guaranteed to take O(log n) time to find an element
00:09:18 <copumpkin> with Eq, you can't do any better
00:09:26 <scotty> Ah, okay, so we're assuming we've sorted already.
00:09:38 <CirceTheSorceres> scotty: yes
00:09:45 <kmc> scotty, we're not assuming that, at any level visible to you
00:09:51 <CirceTheSorceres> scotty: this analysis is all amortized
00:09:58 <scotty> Okay
00:10:05 <scotty> I was going to say...
00:10:27 <kmc> it is O(n log n) to insert n elements into a Data.Set
00:10:32 <CirceTheSorceres> scotty: so if you want to make many search queries it is better to sort the data first to make a Set, that is if you can do so
00:10:37 <kmc> whereas it's O(n) to cons them onto a list
00:10:47 <kmc> but then it's only O(log n) to query the Set, versus O(n) to query the list
00:10:52 <scotty> Yeah
00:10:59 <scotty> Okay, thanks. :)
00:12:43 <scotty> However, if the function I'm using is already giving me an unsorted list and I just want to search it, I might as well use elem, right?
00:13:03 <kmc> if you only want to search it once, yes
00:13:06 <CirceTheSorceres> scotty: if you want to do that only once, yes
00:13:07 <scotty> Building the Set and then searching it will take even longer.
00:13:11 <scotty> Okay
00:13:24 <scotty> Whoa
00:13:29 <CirceTheSorceres> scotty: exactly. It is economy of scale :-D
00:13:35 <scotty> Same reply! :D
00:13:40 <kmc> scotty, that might mean the function you're calling should do something else
00:13:43 <kmc> scotty, that happens a lot here ;)
00:13:59 <m_88> kmc: pe.hs:5:16: Not in scope: `foldl''
00:14:11 <kmc> m_88, you have to import Data.List
00:14:11 <m_88> what should I import for that?
00:14:15 <m_88> ok thanks
00:14:15 <scotty> I'm just trying to see if a string is a particular permutation of another string.
00:14:50 <scotty> > elem "123" (permutations "321")
00:14:51 <lambdabot>   True
00:15:20 <Olathe> > sort "123" == sort "321"
00:15:21 <lambdabot>   True
00:15:24 <kmc> there's a much more efficient way to determine that
00:16:55 <scotty> kmc: What is it? XD
00:17:08 <kmc> Olathe, just gave you one
00:17:16 <scotty> Oops, I didn't see.
00:17:53 <scotty> Ah, nice.  I feel stupid.
00:18:41 <kmc> generating all the permutations is pretty bad, it's O(n!) which is about O(n^n)
00:18:51 <kmc> also comparing the strings over and over is slow
00:19:08 <kmc> you can do a bit faster than Olathe's solution by just keeping a table of how many copies of each char there are
00:19:22 <kmc> which is linear time, if you have a bound on the maximum character codepoint
00:20:39 <copumpkin> > ord maxBound
00:20:40 <lambdabot>   1114111
00:20:54 <copumpkin> you can afford a table that size any day :P
00:21:06 <copumpkin> unfortunately walking over the table adds a fairly large "constant" factor
00:21:15 <scotty> Hm...
00:21:34 <scotty> Well, the strings are actually numbers, so the only characters will be 0-9. XD
00:21:47 <kmc> aha
00:21:47 <copumpkin> then you're fine :P
00:22:35 <scotty> I think Olathe's solution is pretty elegant though.  The table may be overkill.
00:23:18 <copumpkin> :t M.fromListWith succ
00:23:19 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
00:23:19 <lambdabot>     Probable cause: `succ' is applied to too many arguments
00:23:19 <lambdabot>     In the first argument of `M.fromListWith', namely `succ'
00:23:25 <copumpkin> :t M.fromListWith
00:23:26 <scotty> I think the numbers will be relatively small, so the logn wont matter too much.
00:23:26 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
00:23:40 <CirceTheSorceres> scotty: Olathe's solution also has the advantage of being extensible to the case where you actually want to find the permutation relating the strings
00:23:43 <copumpkin> :t M.fromListWith (const succ)
00:23:44 <lambdabot> forall a k. (Enum a, Ord k) => [(k, a)] -> M.Map k a
00:24:08 <copumpkin> :t M.fromListWith (const succ) . zipWith (,1)
00:24:09 <lambdabot> parse error on input `1'
00:24:20 <copumpkin> :t M.fromListWith (const succ) . zipWith (\x -> (x ,1))
00:24:21 <lambdabot>     Couldn't match expected type `b -> c'
00:24:21 <lambdabot>            against inferred type `(a, t)'
00:24:21 <lambdabot>     In the expression: (x, 1)
00:24:36 <copumpkin> :t M.fromListWith (const succ) . map (\x -> (x ,1))
00:24:37 <lambdabot> forall a a1. (Enum a, Ord a1, Num a) => [a1] -> M.Map a1 a
00:25:31 <copumpkin> > M.fromListWith (const succ) . map (\x -> (x ,1)) $ "mississsipppppiiii"
00:25:34 <lambdabot>   fromList [('i',7),('m',1),('p',5),('s',5)]
00:33:32 <scotty> I was doing Project Euler #52: http://pastebin.com/z8dqdzWy :)
00:33:54 <scotty> http://projecteuler.net/index.php?section=problems&id=52
00:36:17 <cads> scotty: that's an interesting problem!
00:37:18 <scotty> cads: I thought it was too easy.  I liked this one better: http://projecteuler.net/index.php?section=problems&id=39
00:37:24 <scotty> It took me a bit longer.
00:37:43 <scotty> I'm trying to do these with my friend.  We're both learning Haskell.
00:39:04 <copumpkin> they're okay for learning at first
00:39:08 <scotty> I bet some of these would be more annoying to code in other languages though.  There are so many handy functions that have already been written in Haskell. :P
00:39:22 <copumpkin> but the haskell you can actually learn from them goes down quite quickly
00:39:40 <Pseudonym> Has anyone here worked with succinct data structures?
00:39:48 <copumpkin> succinct?
00:39:52 <ezyang> Hey guys, I got my ass whipped trying to show that the Set category is not isomorphic to Set^op... so any recommendations of good set theory textbooks?
00:40:04 <Pseudonym> copumpkin: If you had, you'd know what I meant by that. :-)
00:40:16 <copumpkin> I don't claim to have done it, but I'm curious what they are :)
00:40:20 <cads> find a the smallest string of n+1 digits a_i such that sum a_i 10^i = lambda sum a_{psi(i)} 10^i, where i ranges from 0 to n and lambda ranges from 2 to 6.. scotty, can your program solve for more values of lambda?
00:40:30 <Pseudonym> Well, here's an example.
00:40:40 <Pseudonym> Suppose you have a bitmap B[1..m].
00:40:43 <scotty> Yeah, that seems about right.  I still need to learn monads.  My friend started learning after me, so this will probably help him a lot.  I'm still making my way through Gentle Intro to Haskell.  School has kept me from finishing it.
00:40:48 <Pseudonym> Where you know that n bits are 1.
00:40:52 <cads> oh, psi is a permutation of [0, n]
00:40:56 <ezyang> (Perhaps I should ask #haskell-in-depth?)
00:41:01 <copumpkin> don't start monads until you feel very comfortable with haskell
00:41:06 <copumpkin> they'll just frustrate you
00:41:10 <Pseudonym> Then the "normal" way to store this bitmap is using m bits.
00:41:11 <scotty> XD
00:41:24 <scotty> I think I'm on type classes right now.
00:41:24 <Pseudonym> But it should only require log(C(m,n)) bits.
00:41:37 <copumpkin> ezyang: I don't think anyone has said anything in #haskell-in-depth in several months
00:41:48 <cads> ezyang: what is set^op?
00:42:05 <ezyang> cads: Dual category of Set.
00:42:08 <Pseudonym> And, indeed, there are ways to do this.  If s = log(C(m,n)) bits, then you can store this bitmap in s + o(s) bits and retain constant query time.
00:42:15 <ezyang> copumpkin: :-/
00:42:21 <cads> oh, opposite
00:42:23 <Pseudonym> That's little-o, by the way.
00:42:42 <copumpkin> Pseudonym: interesting
00:42:45 <Pseudonym> So, for example, if no bits are set or all bits are set, you can store it in constant space regardless of m.
00:42:55 <ezyang> Basically, I spent an hour listening to one of my dormmates reel on about the universal mapping property of products and not understanding...
00:43:12 <cads> ezyang: is there an arrow going from the nullset to a given set A?
00:43:16 <ezyang> So I guess I don't actually know set theory, so I guess I should shore up the basics before doing more category theory.
00:43:17 <Pseudonym> And there are succinct representations of trees, inverted indexes, graphs...
00:43:58 <ezyang> cads: That would make the nullset the initial object?
00:44:11 <ezyang> I'm not sure. I don't have a very clear mental picture of the Set category.
00:44:29 <Pseudonym> The key insight for doing this is to change the query operations.
00:45:17 <Pseudonym> Rather than implement lookup, you implement two operations, called "rank" and "select".
00:45:25 <cads> or terminal? I am not really good at the category lingo - but I think it stands to reason that there is no object which maps the elements of the nullset into the elements of any other set, since, well, the nullset has no elements
00:45:36 <Pseudonym> rank(B,i) returns the number of 1's in B[1..i].
00:45:45 <Pseudonym> select(B,j) gives the position of the jth bit in B.
00:46:00 <cads> by object I mean morphism :P
00:46:08 <Pseudonym> Then, for example, B[i] = rank(B,i) - rank(B,i-1)
00:46:25 <Pseudonym> Note that rank(B,0) = 0.
00:47:05 <Pseudonym> You can use this to implement, for example, sparse arrays.
00:47:08 <cads> bah, I would be wrong - it has something called zero morphisms Nullset -> X
00:47:24 <ezyang> cads: Heh, I was wondering.
00:47:44 <ezyang> Well, a terminal object T should have a single morphism from every object C -> T
00:47:52 <tensorpudding> the null set is initial
00:47:55 <ezyang> So it seems a lot easier to do it the other direction...
00:48:02 <ezyang> ah savvy
00:48:10 <Pseudonym> So nobody's worked with them, then?
00:48:13 <cads> ezyang: well recommended is halmos' naive set theory
00:48:27 <ezyang> cool, will look into
00:48:43 <tensorpudding> since it has no elements, there is no way to distinguish different possible arrows between the null set and any other set
00:48:55 <tensorpudding> that's one way of thinking of it anyway
00:49:05 <dolio> ezyang: You could just imagine Haskell-without-bottom instead. That'd be a category a lot like Set.
00:49:36 <tensorpudding> category theory allows you to categorize sets without having to think about elements of sets
00:49:48 <ezyang> dolio: Hmmm
00:50:07 <dolio> Not necessarily with all the programming restrictions that comes with.
00:50:10 <ezyang> I mean, it did occur to me that mucking around with cartesian products and disjoint unions might not quite be the best way of producing a counterexample
00:50:24 <dolio> Just that you ignore bottoms when thinking about equalities and such.
00:50:45 <cads> ezyang: skolem's Abstract Set Theory is supposed to be good, available here http://projecteuclid.org/DPubS?service=UI&version=1.0&verb=Display&page=toc&handle=euclid.ndml/1175197470
00:51:28 <cads> and there was someone that recently wrote a book on set theory that gave a categorical treatment of the topic (I might have this wrong)
00:51:40 <cads> an introductory book, even :)
00:51:47 <ezyang> So, if you wanted to prove Set was not isomorphic to the dual of Set, how might you go about doing it?
00:52:20 <ezyang> If I had a bad picture of Set, I have an even worse picture of Set^op
00:52:29 <ezyang> Since it seems like all of the arrows stopped being functions.
00:52:59 <Pseudonym> ezyang, there's a good picture of FSet^op, where FSet is finite sets.
00:53:08 <Pseudonym> But I forget what it is. :-)
00:53:15 <copumpkin> :o
00:53:17 <ezyang> bah :-P
00:53:32 <Pseudonym> Something to do with boolean operations, IIRC.
00:53:40 <copumpkin> so you're trying to prove they're not isomorphic?
00:53:45 <ezyang> Yup
00:54:05 <ezyang> Psuedonym: Well, apparently Set^op is some sort of boolean algebra
00:55:04 <copumpkin> the null set seems like where you should be looking
00:55:14 * Pseudonym looks it up in Asperti and Longo, and notes that all category theory textbooks have a non-Zipf distribution of initial letters in the index, since "c" is bigger than everything else.
00:55:26 <ezyang> *nod*
00:55:28 <copumpkin> 0 -> anything
00:55:35 <copumpkin> anything -> 0
00:56:12 <cads> I could have sworn the first would make no sense, but I know that the empty set is either the initial object or the terminal
00:56:29 <copumpkin> http://en.wikipedia.org/wiki/Principle_of_explosion
00:56:34 <copumpkin> the first is the one that does make sense
00:56:41 <dolio> You get 0 -> T with the empty function.
00:57:07 <dolio> \z -> case z of {}
00:57:42 <cads> oh, right
00:58:18 <ezyang> I'm not seeing a way to make that cause the existence of an isomorphism to cause a contradiction
00:59:05 <ezyang> I guess F(0) = 0
00:59:24 <ezyang> where F : Set -> Set^op
01:00:00 <ezyang> But the functor seems pretty easily able to just flip the directions of the arrows w/o too many problems
01:00:01 <cads> the arrows are functions which map each object in a set into a corresponding object in a target set (that is, no partial functions?). Then, sets can only be mapped into sets of equal or greater cardinality, so there are no arrows from other sets to the empty set.
01:00:37 <ezyang> cads: In Set^op world, arrows are not functions
01:00:58 <ezyang> By the definition of duality, that which is initial must be terminal in the dual.
01:01:01 <cads> if there was an arrow  0 -> X in Set^op, there would have to be an arrow X -> 0 in Set
01:01:17 <ezyang> yeah
01:01:26 <ezyang> But there isn't, afaict.
01:01:29 <cads> which is a contradiction if set has no partial functions.
01:03:24 <cads> this ought to tie up the proof - otherwise we would have to suppose that the nullset both a terminal and an initial object
01:04:15 <cads> and on that bit of poor english I will get some icecream
01:05:01 * ezyang is unconvinced, but willing to be. 
01:07:33 <dolio> I'm not sure why any category C wouldn't be isomorphic to its opposite category C^op as a category.
01:07:49 <dolio> It seems like FA = A, Ff = f does it.
01:08:15 <dolio> However, that doesn't mean it isn't isomorphic if you require functors that preserve additional structure.
01:08:50 <dolio> Er, that should be: that doesn't mean it is isomorphic if ...
01:09:14 <dblhelix> dolio: (simple) counterexample?
01:09:17 <dolio> For instance, I don't think Set^op is cartesian closed.
01:09:36 <scotty> Has anyone ever implemented a cube root function?  I'm using Halley's method from Wikipedia: http://en.wikipedia.org/wiki/Cube_root, but I'm not sure what to choose as my initial guess.  Sometimes the algorithm doesn't even converge.  Has this already been implemented in any library?
01:09:48 <cads> well, suppose you have a category with objects {A, B} and a single non-id arror {A->B}  then the opposite category has {B->A}... similarly if it has three arrows {A->B, B -1> A, B -2> A} then its opposite clearly has a mismatch on arrows as well.
01:10:22 <dblhelix> dolio: but dom(Ff) /= F(dom f) in your proposed isomorphism
01:10:49 * dblhelix dusts off his CT
01:10:56 <dolio> Hmm, you're right. I must have been flipping things too many times.
01:11:02 <dolio> Or not enough.
01:11:22 <Twey> scotty: cbrt = (** (1 / 3))
01:11:39 <Twey> > 8 ** (1 / 3)
01:11:41 <lambdabot>   2.0
01:11:46 <copumpkin> he probably wants to implement it himself
01:11:50 <cads> hmm, I need to look up precisely what isomorphism means in a ct context
01:12:00 <Twey> Perhaps… perhaps not
01:12:16 <dolio> cads: It's a pair of functors that are inverses.
01:12:17 <Twey> They're looking for a library, so…
01:12:22 <scotty> copumpkin: I already did, but it converges very slowly in many cases due to a bad initial guess.  I chose the number itself as the intial approximation.
01:12:41 <scotty> Twey: Thanks!
01:12:43 <Twey> scotty: Try a third of the number?
01:12:43 <dolio> dblhelix: Yeah, you're right.
01:12:54 <dolio> As is cads.
01:14:17 <dolio> Well, actually, cads' argument only shows that a functor whose action on objects is FA = A can't exist.
01:14:33 <ezyang> dolio: Right. The functor could do other things
01:14:40 <cads> I'm confused now since it seems like F could take A to B and B to A, and also A - > B  to B -> A
01:14:50 <ezyang> (Although I can't think of a category who is isomorphic with its dual who does not do FA = A)
01:15:03 <dolio> Since f : 0 -> A, Ff : 0 ~> A = A -> 0.
01:15:30 <ezyang> So, here's the proof sketch that someone else gave me, which I don't fully understand.
01:15:58 <dblhelix> cads: but what if there are two arrows with the same domain?
01:16:15 <dblhelix> cads: f : A -> B and g : A -> C
01:16:24 <dblhelix> cads: what should F A be then?
01:16:31 <dblhelix> cads: B or C?
01:16:44 <ezyang> Somehow, we show that the property (A + B) x C == A x C + B x C should be preserved by the functor
01:16:47 <cads> oh, nice
01:17:01 <ezyang> This involves the fact that for our functor to be an isomorphism, it needs to be fully faithful
01:17:18 <ezyang> And then we show that this property is not true in Set^op, contradiction, poof.
01:17:53 <dolio> Well, not understanding that doesn't have anything to do with set theory.
01:18:15 <dolio> Unless you're confused about why (A + B) x C ~ A x C + B x C doesn't hold in Set^op.
01:18:17 <ezyang> Well, there's some body of prereq knowledge that I don't have...
01:18:44 <ezyang> dolio: I'm confused about the reason why this particular property should be preserved over teh functor
01:18:55 <dolio> But that's because + is x and x is + in Set^op, so the isomorphism would be (A x B) + C ~ (A + C) x (B + C)
01:19:02 <ezyang> Also, I'm shaky enough with disjoint unions that (A + B) x C isn't totally obvious to me
01:19:16 <cads> dblhelix: that's not workable, I wonder if there's an an analogous construction in set
01:19:37 <ezyang> dolio: Yeah, that clearly isn't true. I think I believe that part.
01:21:55 <dolio> The prerequisite you're missing is lots of category theory.
01:22:01 <ezyang> aggggh
01:22:18 <heropass> lol
01:22:19 <ezyang> aptitude install category-theory; missing dependencies: category-theory
01:22:21 <dolio> I don't really have any idea how to show that the functor must preserve that to be an isomorphism.
01:23:00 <ezyang> Me neither.
01:24:31 <ezyang> But apparently the result involves the universal mapping property of cartesian products, and the fact that such a functor must be fully faithful
01:24:44 <ezyang> uh, whatever that means ^_^
01:24:50 <quicksilver> isn't there a simpler proof that Set is not isomorphic to set^op ?
01:25:02 <ezyang> quicksilver: That would be nice!
01:25:07 <quicksilver> Set has one initial object and an infinite collection of terminal objects
01:25:17 <quicksilver> Set^op has one terminal and an infinite collection of initial
01:25:24 <quicksilver> that's pretty obviously not isomorphic categories.
01:27:31 <ezyang> I don't have any reason to believe that isomorphic categories must have the same number of terminal and initial objects.
01:27:39 <ezyang> It seems pretty reasonable, but...
01:28:44 <quicksilver> any isomorphism between categories must induce a bijection between the initial (resp. terminal) objects of one and the initial (resp. terminal) objects of the other.
01:29:05 <quicksilver> There is no bijection between a single object and an infinite family of objects.
01:29:45 <ezyang> (there's also the teensy problem that the textbook hasn't gone and talked about initial/terminal objects yet :-)
01:29:48 <mauke> preflex: seen ndm
01:29:48 <preflex>  ndm was last seen on #haskell 1 year, 3 days, 22 hours, 11 minutes and 6 seconds ago, saying: plus with current compiler technology, it would be slower
01:29:51 <quicksilver> as for why? well, category isomorphisms must preserve the truth of all diagrams.
01:30:13 <ezyang> Ok.
01:30:32 <dolio> quicksilver: That's the same proof as (A + B) x C == A x C + B x C, then.
01:30:37 <ezyang> (I'm mentally doing Rel ~ Rel^op in my head and convincing myself that the terminal/initial objects are the same numbers)
01:30:48 <ezyang> dolio: Really?
01:30:49 <quicksilver> if you want to not answer without explicitly mentioning initials or finals or sums or products
01:30:51 <mauke> whoo, the "year" logic in seen works
01:30:57 <quicksilver> then just look at the empty set
01:31:11 <quicksilver> the point is "where woudl this supposed isomorphism map the empty set to?"
01:31:15 <quicksilver> there is no sensible choice.
01:31:32 <ezyang> Ooh, clever.
01:31:33 <quicksilver> dolio: in a sense, yes, but I think it's slightly more elementary.
01:31:35 <dolio> ezyang: That's just another diagram.
01:32:08 * hackagebot language-haskell-extract 0.1.2 - Module to automatically extract functions from the local code.  http://hackage.haskell.org/package/language-haskell-extract-0.1.2 (OscarFinnsson)
01:32:10 * hackagebot test-framework-th 0.1.2 - Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell.  http://hackage.haskell.org/package/test-framework-th-0.1.2 (OscarFinnsson)
01:32:53 <dolio> Yeah, but "isomorphisms must preserve diagrams" is the hard part. Which diagram you pick after that doesn't seem like it's going to be as big a deal.
01:33:28 <ezyang> quicksilver: One feeble question: Why can't I do something dirty like map the null set into the set of functions whose domain is the null set?
01:33:51 * dblhelix plans to look into test-framework today
01:34:53 <ezyang> ah, that wouldn't work
01:35:34 <heropass> there are no functions whose domain are empty
01:35:49 <ezyang> heropass: The empty function is one!
01:35:51 <copumpkin> there's the empty function
01:35:53 <heropass> well, there's one, the empty function
01:36:13 <copumpkin> there are no functions whose range is empty
01:36:15 <dolio> There are many empty functions in Set.
01:36:17 <quicksilver> ezyang: you can do all kinds of things, but they all turn out not to work.
01:36:22 <dolio> One for each set.
01:36:25 <heropass> but it's identical to the null set
01:36:38 <heropass> a function is a set
01:36:42 <ezyang> quicksilver: Unfortunately, that's not very convincing to a mathematician :^)
01:36:54 <quicksilver> ezyang: right, well you have to work through the details
01:37:09 <quicksilver> it amounts to discussing one or two of the properties of initial (resp. terminal) objects
01:37:16 <quicksilver> even *without* giving the names to the concepts.
01:37:34 <quicksilver> The point is, the empty set is obviously a very special - indeed, unique - member of Set
01:37:35 <ezyang> ok
01:37:43 <quicksilver> so it's an obvious one to consider.
01:37:50 <heropass> it's one reason categories are more satisfying than sets are
01:38:00 <kmc> is the empty set a terminal object?
01:38:01 <quicksilver> what you notice is that there is no possible thing to map it to in Set^op
01:38:22 <quicksilver> ...or, in fact, there is a particular infinite collection of them, but none is canonical, so this can't work.
01:38:46 <quicksilver> whichever one you choose, you end up wondering what you are going to do with the other ones.
01:39:00 <copumpkin> kmc: not in Set
01:39:25 <kmc> oh because there are no functions to it
01:39:30 <copumpkin> one-element sets are terminal
01:39:35 <kmc> yeah
01:39:36 <quicksilver> kmc: it's initial, not terminal, but ezyang hasn't been official taught those words so I'm sketching an elementary proof which doesn't mention them
01:39:41 <kmc> ok
01:39:59 <quicksilver> kmc: my elementary proof does amount to considering some of the properties of initial and terminal objects, certainly
01:40:07 <quicksilver> to me it's the "simplest" reason Set and Set^op are not isomorphic.
01:40:15 <kmc> ok
01:40:21 <kmc> i will shut up and pay attention then )
01:40:22 <kmc> :)
01:40:29 <quicksilver> ezyang: informally (but you could formalise this) since empty set is 'unique' in Set, it would have to be mapped to some 'unique' element in Set^op
01:40:58 <ezyang> ...but the only unique element in Set^op is the empty set?
01:41:04 <quicksilver> ezyang: ... unfortunately there is only one 'unique' object in Set^op, and that is itself empty set, and that's not going to work
01:41:08 <quicksilver> right.
01:41:30 <ezyang> My math instincts are telling me I want to set up a contradiction.
01:42:45 <copumpkin> "If you give me something to map 0 to, I'll whoop yo ass"
01:43:02 <ezyang> yeah
01:44:35 <copumpkin> in Set, there's an arrow from 0 to everything else. So in Set^Op, there'd need to be an arrow from everything to the object we map 0 to...
01:44:42 <ezyang> I'm having difficulty formalizing this idea of a "phantom" graph of arrows on top of the ostensible graph of arrows that Set&op has
01:46:31 <ezyang> copumpking: Wait, we already have that, it's called 0...
01:46:35 <cads> If we're considering just 0, a singleton {a}, and X where |X| = n > 1, then we haven arrows {a} -> X and only one arrow X -> {a}, as well as the arrows from 0 - this category is clearly not isomorphic to its dual (now that I have a little of an idea of isomorphism between categories.. I hope I'm not "clearly" mistaken :D
01:46:45 <ezyang> You mean an arrow from FOO to everything else...
01:46:46 <quicksilver> copumpkin: /an arrow/precisely one arrow, no more and no less/
01:47:02 <copumpkin> yeah
01:47:16 <cads> haven = "have n"
01:48:54 <ezyang> Urgh, I still can't get rid of the notion that the original arrow structure is encoded some other way
01:49:30 <ezyang> ^- does that even make sense?
01:49:38 <copumpkin> well the domains and codomains need to be preserved, so you aren't altering the "graph structure"
01:49:47 <dolio> ezyang: So, I think I can show how to show that F0 must be initial.
01:50:20 <dolio> ezyang: Consider F : Set -> Set^op, and G its inverse (that is, suppose Set is isomorphic to Set^op)...
01:50:52 <heropass> show how to show ...
01:51:10 <dolio> F . G = I, G . F = I, I being the identity functor.
01:52:02 <ezyang> These are functors; of course the diagram has to be preserved. *bonk*
01:52:46 <dolio> So, suppose F0 = X. We know that there's a ! : 0 -> A forall A, and thus we know that F! : X -> FA. So that shows that X is weakly initial.
01:54:00 <ezyang> though the objects don't have to be...
01:54:26 <dolio> Oh, with the proviso that for any Y in Set^op, GY in Set is such that F(GY) = Y, so for every Y, there is a B such that FB = Y.
01:55:03 <dolio> Now, consider g : X -> FA. Gg : 0 -> A, but we know the only arrow 0 -> A is !, so Gg = !.
01:55:08 <ezyang> Wait, wait, I think I've got it.
01:55:21 <ezyang> Piggybacking off what dolio has said
01:55:36 <dolio> But, then FGg = F!.
01:56:07 <dolio> So every g : X -> FA = F!, so X is initial.
01:57:57 <dolio> But, to formalize quicksilver's point, Set^op has multiple initial objects, X and Y, X /= Y.
01:58:17 <cads> hmm, pairs of terminal objects must be mapped into pairs of terminal objects
01:58:27 <dolio> GX and GY must be initial by the same argument. But the only initial object is 0.
01:58:53 <dolio> But, for F, G to be an isomorphism, FGX = X and FGY = Y must hold.
01:59:19 <ddos> HELLO
01:59:46 <ezyang> Contradiction!
02:00:06 * ezyang falls over 
02:00:07 <dolio> However, GX = 0 = GY, but either F0 /= X or F0 /= Y (or both).
02:01:53 <ezyang> OK, thanks for all the help.
02:02:11 <ezyang> I will go to sleep, wake up, and write up the solution, and with any luck it will still make sense.
02:02:28 <ezyang> G'night!
02:03:44 <dolio> ezyang: Note, not all functors preserve (co)limits, though. The fact that it was part of an isomorphism was important.
02:04:26 <cads> you could define terminal and initial objects as "diabolic" and "angelic", respectively :)
02:04:41 <dolio> I'm not sure how that gets you the fully faithful stuff, though (I start to fog up when people start talking about injective/surjective homsets and whatnot).
02:04:44 <heropass> or oppositely
02:05:23 <heropass> \quit
02:05:27 <ezyang> dolio: The picture I have in my head there is that the functor makes what was two distinct objects the same one afterwards, so I can't extract the data out using the limit
02:05:37 <cads> then show that the a category with n diabolic objects can only be isomorphic to a category with the same amount of devilishness, and show that Set^op is actually rather holy
02:05:50 <heropass> oops, wrong interface *blush*
02:06:08 <ezyang> cads: That sounds like a good thing to check (religious vocabulary not withstanding :-)
02:06:30 <ezyang> I think dolio's argument generalizes easily to that case.
02:06:36 <ezyang> what am I doing
02:06:45 <ezyang> actually sleeping now! >:^)
02:07:11 <heropass> me too
02:07:16 <cads> get some rest yo
02:07:21 <cads> me three
02:07:21 <quicksilver> in some sense this is the 'wrong' proof, though
02:07:39 <quicksilver> because it begs the question : Is Skel(Set) isomorphic to Skel(Set^op), then ?
02:07:49 <quicksilver> ...which solves the multiple terminal objects problem.
02:07:56 <quicksilver> and the answer is still no
02:08:02 <quicksilver> because, basically n^m /= m^n
02:08:11 <dolio> Asking about isomorphisms of categories is evil, anyway.
02:08:29 <opqdonut> nah, just pay a short visit to Cat
02:08:34 <quicksilver> I still think it's the simplest proof.
02:08:56 <opqdonut> oh, hmm, Set isn't in Cat, yeah
02:09:07 <quicksilver> BigCat!
02:09:27 <dolio> If you're avoiding evil, Cat is a 2-category, and thus you don't talk about isomorphisms, you talk about equivalences.
02:09:55 <quicksilver> yes, and that's what my skel statement is a re-statement of
02:10:15 <quicksilver> Skel(C) ~iso~ Skel(D) is the same statement as C ~equiv~ D
02:10:32 <dolio> Yeah. Skeleton categories are evil, too. :)
02:10:55 <cads> what's evil mean in the ct setting?
02:11:18 <quicksilver> non-categorical
02:11:36 <dolio> It means talking about properties/etc. that distinguish between isomorphic/equivalent objects.
02:11:42 <quicksilver> in a sense, skeleton categories require the axiom of choice
02:11:53 <quicksilver> although only in a sense.
02:13:04 <cads> so it allows you to say "these categories are isomorphic but _technically_ they're not equivalent since the objects are not really the same thing"?
02:14:58 <dolio> cads: In regular category theory, talking about equality of objects is evil.
02:15:20 <ddos> hello
02:15:37 <dolio> Because you may have unequal A and B that are nevertheless isomorphic.
02:18:40 <dolio> So, categorically, if you have sets A and B, you don't worry about the set theoretic definition of A x B, even though there are multiple, unequal sets that could serve that purpose (assuming something sufficiently similar to ZF).
02:20:03 <quicksilver> dolio: no, although I think we quite often do assume that A x B is well-defined. We just don't care what the definition is as long as it works.
02:20:28 <dolio> And that extends to higher categories, where you only care about n-cells up to (n+1)-equivalence.
02:21:54 <ddos> ddos
02:22:07 <ddos> hacking end koin in de virus..\
02:23:47 <dolio> quicksilver: Yeah, the idea of avoiding 'evil' is that everything you prove while doing so is proved for everything in the isomorphism class.
02:24:21 <dolio> Or, equivalence class. If I understand correctly.
02:37:35 <ddos> hello
02:38:35 <sosman> evening
02:38:47 <ddos> you gerel?
02:38:52 <ddos> gerl?
02:39:25 <ddos> ping
02:39:25 <gogonkt> PONG, now at #haskell
02:39:42 <ddos> # haskell
02:40:30 <quicksilver> hmm
02:41:00 <quicksilver> gogonkt: such auto-replies can quickly get spammy
02:41:15 <mauke> auto-replies?
02:41:35 <quicksilver> yes, read up 5 lines. auto-responded to a ping.
02:41:40 <gogonkt> sorry
02:41:48 <mauke> doesn't look auto to me
02:42:00 <gogonkt> who ping me ...
02:42:35 <mreh> ping
02:42:35 <gogonkt> PONG, now at #haskell
02:42:41 <mreh> looks auto to me
02:42:43 <mauke> now it does
02:42:55 <sosman> my syslog parser so far http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25468
02:43:37 <sosman> Trying to replace doLoop with something like "print . liftM unlines . map (formatRec . parseLine) lines $ hGetContents hin"
02:43:54 <cads> dolio, I finally see what you did there in that proof!
02:46:19 <mauke> did you mean: print =<<
02:46:46 <pao> hi all! is there a way to programmatically get the name of the module? I guess th could help...
02:46:58 <cads> by the same argument that we use to show we bring 0 into an initial object in Set^OP, the isomorphism must also bring each IO in Set^OP back into a unique IO in Set, which just doesn't have enough :)
02:47:24 <sosman> mauke: that question for me?  If yes I don't know.
02:49:48 <dolio> cads: Right. The proof that for F0 is initial didn't rely on anything but 0 being initial, and F and G an isomorphism, so it applies to GX for any initial X, as well.
02:51:06 <cads> at worst he'd have to show that set has one IO and many TOs
02:53:09 <cads> tomorrow I'll see if I can make a similar argument using the powers of the homsets between arbitrary sets
02:56:28 <cads> goognight all
03:01:12 <mreh> pao: you can get the name of a package with cabal, is that what you need?
03:01:37 <mreh> cabal builds some files that contain info about the package, you can access that from any module
03:02:23 <pao> mreh: no... I'd need in my code something like modName = getCurrentModuleName
03:02:50 <mreh> question, can I -ddump-minimal-imports without doing a whole build?
03:03:14 <mreh> pao: can you say why you need it?
03:03:41 <pao> mreh: I'm thinking about a configuration framework ...
03:04:22 <mreh> pao: configuration files for haskell programs?
03:04:27 <pao> mreh: configKnobX = getConfiguration getCurrentModuleName ...
03:04:32 <pao> mreh: yes
03:05:14 <zygoloid> pao: you want to avoid having to hard-code it (so you can easily rename the module or whatever)?
03:05:24 <pao> zygoloid: exactly
03:05:48 <zygoloid> i think you can find the module in which a symbol was defined via TH, don't know about the current module
03:06:21 <pao> zygoloid: ... I was thinking at TH myself... I guess that's the place to look for it
03:16:51 <dolio> quicksilver: Oh, you can also observe (I believe) that if F, G is an isomorphism of categories, then F -| G and G -| F, with identity natural transformations as unit and counit.
03:17:59 <dolio> And right-adjoints-preserve-limits, and left-adjoints-preserve-colimits, so F and G must preserve both.
03:18:38 <quicksilver> yes but that's a complex way to prove something more elementary.
03:18:56 <quicksilver> isomorphisms preserve all diagrams and all universal properties
03:19:03 <quicksilver> just by the definition of isomorphism
03:19:16 <quicksilver> you don't need to invoke adjunctions to show that.
03:19:43 <leino> > numToDigs n b = [(n `div` b^x) `mod` b | x <- [0 .. floor(log n / log b)]]
03:19:44 <lambdabot>   <no location info>: parse error on input `='
03:19:57 <leino> > let numToDigs n b = [(n `div` b^x) `mod` b | x <- [0 .. floor(log n / log b)]]
03:19:58 <lambdabot>   not an expression: `let numToDigs n b = [(n `div` b^x) `mod` b | x <- [0 .....
03:20:03 <quicksilver> leino: lambdabot evaluates expressions, not definitions
03:20:13 <quicksilver> leino: try let numToDigs .... in ....
03:20:14 <leino> aha hold on a sec
03:20:45 <leino> > let numToDigs n b = [(n `div` b^x) `mod` b | x <- [0 .. floor(log n / log b)]] in numToDigs 123 10
03:20:46 <lambdabot>   Ambiguous type variable `t' in the constraints:
03:20:47 <lambdabot>    `GHC.Float.Floating t'
03:20:47 <lambdabot>  ...
03:20:57 <leino> having problem with types
03:21:18 <quicksilver> yes, you want log (fromIntegral n)
03:21:20 <quicksilver> and similarly b
03:21:26 <mauke> and logBase
03:21:36 <quicksilver> n,b are integral types but log is only defined on floating types.
03:22:08 <leino> the base is totally irrelevant
03:22:21 <mauke> then why did you put it in
03:22:27 <quicksilver> well I think mauke's just saying that log n / log b === logBase b n
03:22:35 <quicksilver> (or is it the other way around?)
03:22:52 <leino> numToDigs needs a base yes
03:23:22 <quicksilver> > (log 10 / log 2, logBase 2 10)
03:23:23 <lambdabot>   (3.3219280948873626,3.3219280948873626)
03:23:31 <mauke> :t showIntAtBase
03:23:31 <quicksilver> just a different way of writing it, that's all, not important.
03:23:32 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
03:23:35 <dolio> quicksilver: That isn't merely the definition of an isomorphism of categories, though, at least formally.
03:23:37 <leino> oh I see what youre saying now
03:23:38 <quicksilver> the important thing is the fromIntegral.
03:23:53 <mauke> > showIntAtBase 3 intToDigit 10 ""
03:23:54 <lambdabot>   "101"
03:24:09 <leino> > let numToDigs n b = [(n `div` b^x) `mod` b | x <- [0 .. floor(logBase b n)]] in numToDigs 123 10
03:24:10 <lambdabot>   Ambiguous type variable `t' in the constraints:
03:24:10 <lambdabot>    `GHC.Float.Floating t'
03:24:10 <lambdabot>  ...
03:24:25 <quicksilver> dolio: an isomorphism of categories is a bijection on objects, a bijection on arrows, preserving dom, cod, hom, and composition.
03:24:37 <quicksilver> (the 'obvious' definition)
03:24:53 <quicksilver> that immediate preserves all diagrams, all universals, pretty much everything similar.
03:24:59 <quicksilver> as a special case all limits and all colimits.
03:25:33 <quicksilver> leino: as I said, the important thing is fromIntegral.
03:26:01 <quicksilver> you need fromIntegral n and fromIntegral b because n and b are integral types and the log functions are not defined on those
03:26:03 <leino> let numToDigs n b = [(n `div` b^x) `mod` b | x <- [0 .. floor(logBase b (fromIntegral n))]] in numToDigs 123 10
03:26:10 <leino> > let numToDigs n b = [(n `div` b^x) `mod` b | x <- [0 .. floor(logBase b (fromIntegral n))]] in numToDigs 123 10
03:26:11 <lambdabot>   Ambiguous type variable `t' in the constraints:
03:26:11 <lambdabot>    `GHC.Real.Integral t'
03:26:11 <lambdabot>   ...
03:26:13 <quicksilver> n *and* b
03:26:24 <leino> ok
03:26:34 <leino> > let numToDigs n b = [(n `div` b^x) `mod` b | x <- [0 .. floor(logBase (fromIntegral b) (fromIntegral n))]] in numToDigs 123 10
03:26:35 <lambdabot>   [3,2,1]
03:26:39 <leino> sweet
03:26:41 <quicksilver> :)
03:26:44 <mauke> > showIntAtBase 10 intToDigit 123 ""
03:26:45 <lambdabot>   "123"
03:26:56 <mauke> > map read $ showIntAtBase 10 intToDigit 123 "" :: [Int]
03:26:57 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
03:26:57 <lambdabot>         against inferred ty...
03:27:02 <mauke> oh, right
03:27:12 <mauke> > map digitToInt $ showIntAtBase 10 intToDigit 123 ""
03:27:13 <lambdabot>   [1,2,3]
03:27:46 <leino> didnt know digitToInt and intToDigit allready existed :)
03:29:22 <Baughn> leino: As a general rule, if it sounds useful, it probably exists.
03:30:03 <quicksilver> Baughn: flying car!
03:30:19 <Baughn> quicksilver: Exist. And less useful than they sound.
03:30:32 <Baughn> I know of several variants. One was even mass-produced.. kinda.
03:33:08 <dolio> There was a flying car in one of the James Bond movies.
03:33:21 <dolio> One of the Roger Moore ones, I believe.
03:34:57 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25474 <- Would this thing be a useful addition to Data.Map?
03:38:13 <p_l> dolio: yes, but it wasn't very practical
03:38:41 <Baughn> They never are.
03:38:48 <p_l> though ZPMs and small electric turbines would allow for a viable low-altitude flying car
03:39:30 <Baughn> ..that doubles as a weapon of mass destruction.
03:39:32 <quicksilver> Baughn: I can't help feeling that might as well be a -> b (and, thus, Map k a -> Map k b)
03:39:55 <Baughn> quicksilver: Couldn't be. You only alter a single value, so you can't be changing the value type of the map.
03:39:57 <quicksilver> hmm, no, not so.
03:40:05 <quicksilver> ok, well here is my confusion.
03:40:12 <Baughn> Anyway. Data.Map.map already does that
03:40:14 <quicksilver> I expected you to use 'def' not 'f def'  in the nothing case.
03:40:28 <quicksilver> can you motivate the use of f def there?
03:41:38 <Baughn> The motivation for making that function was to handle nested maps. So, for an m :: Map k (Map l a), I say adjustWithDefault M.empty (M.insert l a) m.
03:41:59 * quicksilver mutters about gmap
03:42:20 <Baughn> Not applying the function to def would mean I'd have to provide a singleton map instead, which would be redundant
03:42:36 * quicksilver nods
03:42:56 <MrFenix> hi,
03:42:56 <MrFenix> can anyone help me on glueing together different Either CustomError a types?
03:42:56 <MrFenix> Using them as a Monad does not work as in
03:42:56 <MrFenix> operationA :: a -> Either CustomErrorTypeA b
03:42:56 <MrFenix> operationB :: b -> Either CustomErrorTypeB c
03:42:57 <MrFenix> operationA x >>= operationB
03:42:57 <MrFenix> CustomErrorTypeA and CustomErrorTypeB are incompatible
03:42:58 <MrFenix> I've found different other options
03:42:58 <MrFenix> 1) instance Show CustomErrorTypeX ...
03:42:59 <MrFenix> (e>>=) :: (Show b, Show c) => (a -> Either b c) -> (c -> Either d e) -> Either String e
03:42:59 <MrFenix> (e>>=) = (either (Left $ show) (Right)) >>= (either (Left $ show) (Right))
03:43:00 <MrFenix> operationA e>>= operationB
03:43:00 <MrFenix> This loses type information in favour of String (kind of ugly)
03:43:01 <MrFenix> 2) fmap
03:43:20 <Baughn> @paste
03:43:20 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:43:33 <MrFenix> ok..
03:43:49 <quicksilver> I'd lift it to Either (Either CETA CETB)
03:44:07 <quicksilver> or in general, provide injections from various specific errors to some general error type
03:45:35 <MrFenix> again in a readable way :)
03:45:36 <MrFenix> http://pastebin.com/r2J18NYL
03:46:25 <quicksilver> Baughn: well, your use case is within the possibilities of 'alter'
03:47:07 <quicksilver> oh you said that
03:47:11 <quicksilver> you used alter in your defn :P
03:47:17 <Baughn> I did. ^^;
03:47:33 <Baughn> Also, just about every update function in Data.Map could be implemented with alter.
03:47:43 <quicksilver> why not:
03:47:54 <quicksilver> M.alter (Just . f . fromMaybe def a) ?
03:48:22 <Baughn> Because I'm not experienced not to think of that.
03:48:25 <quicksilver> ;)
03:48:27 <Baughn> s/not/enough/
03:48:44 <quicksilver> well the repeated "Just (f" was a clue
03:48:45 * Baughn is a mere level 12 haskell programmer.
03:49:15 <Baughn> @index fromMaybe
03:49:16 <lambdabot> Data.Maybe
03:49:36 <Baughn> ..doh. I was looking for it in Data.Map for.. some reason that probably makes sense if you're drunk, which I'm not.
03:52:05 <MrFenix> quicksilver: like in http://pastebin.com/ycVCNJk7 ?
03:52:21 <Baughn> quicksilver: That said, I'd use the function anyway. Now I just know how to shorten it.
03:52:50 <quicksilver> MrFenix: looks sane to me, yes.
03:57:19 <MrFenix> quicksilver: is there any way to have 'toGeneral' generated by the compiler, i.e. not mentioning the type constructors A, B, C, ...?
03:58:03 <marcot> Good morning.  How can I remove a package I've uploaded to HackageDB?
03:59:53 <Baughn> marcot: Email the maintainer and ask. But in general, you can't. Why do you need to?
04:01:01 <marcot> Baughn: The HackageDB maintainer?  I think some packages I uploaded are not useful, so they're just making volume.
04:01:39 <Baughn> marcot: Right. You'll have to email him.
04:01:59 <exDM69> http://www.pasteall.org/13106  <<--- I made this small logic programming language with Haskell
04:02:04 <marcot> Baughn: Ok, thanks.
04:02:11 <quicksilver> MrFenix: Yes, using TH or Data.Derive or something.
04:02:51 <dolio> exDM69: Nice.
04:03:43 <Baughn> Hm. Fifteen lines, of which twelve contain forkIO.. I hope threads are as cheap as they're made out to be.
04:03:47 <exDM69> dolio: I'll put it up on google code soon
04:03:48 <zygoloid> MrFenix: another option would be to use Data.Typeable
04:04:22 <dolio> exDM69: Now you can write a type inference algorithm for Haskell in the logic language.
04:04:23 <mauke> Baughn: I've had 400000 threads in a single program
04:04:39 <zygoloid> (but that would allow any Typeable instance to be wrapped in a GeneralError, not just those which you want)
04:04:56 <Baughn> mauke: Ah. Then my couple dozen should not be an issue.
04:05:47 <exDM69> dolio: no I can't, haskell's type checking is way too complex for that language
04:05:53 <nominolo> has anyone here ever used YHC?
04:06:34 <exDM69> dolio: this is just the cheap pattern matching and unification-based logic evaluator from SICP
04:06:35 <dolio> exDM69: Does it only have atoms?
04:06:35 <Baughn> exDM69: It's turing-complete, isn't it? ;)
04:07:37 <exDM69> Baughn: I think it is. but it would be a hard task anyways, since there's a lot of caveats in the language
04:07:50 <illissius> next step is to do it as a DSL (;
04:07:59 <illissius> or EDSL, rather
04:08:05 <exDM69> dolio: it's got strings, combinations, variables (and dotted tail on the way)
04:08:08 <Baughn> exDM69: Clearly what you should do is write an x86 emulator in it, then you can just use ghc.
04:08:49 <exDM69> Baughn: nah, I think I'm gonna hunt me some Wumpus instead :)
04:10:21 <wli> x86 emulators are truly vast tasks; better to go with the EDSL
04:11:05 <wli> Or whatever the SICP logic evaluator was supposed to be called.
04:11:06 <Baughn> Well.. PPC emulator, then run an x86 emulator on that?
04:11:57 <MrFenix> quicksilver: Thanks a lot :)
04:12:38 <wli> Baughn: That would be much smaller than x86, but still very large compared to the original task.
04:13:28 <Baughn> wli: Oh, I know. The GHC type-checker is turing-complete, and probably nicer, so if he implements that then he can write the PPC emulator in haskell types!
04:13:53 <zygoloid> i bet someone's written a turing machine x86 emulator :)
04:14:37 <Baughn> That reminds me, someone built an actual turing machine a little while ago. With a tape, optical scanner and marker and all. :
04:14:45 <Baughn> (I want one. ^_^)
04:15:07 <exDM69> yeah that was a very cool gadget. saw it on hacker news and elsewhere
04:15:23 <exDM69> http://aturingmachine.com/  <<<--- this one, I presume?
04:15:32 <Baughn> Yep
04:17:06 <bremner> Baughn: there is one made out of Lego in the TU Munich math museum
04:17:40 <Baughn> bremner: ..must ...pilfer
04:25:41 <Baughn> Hm. So, admittedly after a few months of practice.. I'm writing massively multithreaded code in Haskell with greater ease than I write single-threaded code in any other language.
04:26:07 <Baughn> There ought to be some way of getting paid for that.
04:27:12 <p_l> Baughn and pilfering? Dangerous combination. Wewwy Dangewous.
04:28:10 <Baughn> p_l: Hey, I'm not that bad.
04:29:36 <sosman> How to write this in one line please? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25475#a25475
04:30:07 <Baughn> lines <$> hGetContents hin
04:30:18 <Baughn> ..is about as far as you can get without invoking monad combinators.
04:30:29 <sosman> ok thanks
04:30:44 <mauke> putStr . unlines . map (formatRec . parseLine) . lines =<< hGetContents hin
04:30:46 <p_l> Baughn: not that bad? I'd certainly prepare socks as an equivalent of ECM, at least.
04:31:35 <Baughn> p_l: I am NOT the Eater of Socks.
04:32:48 <p_l> Baughn: but you're related to dwarves. It was a sound idea :>
04:33:18 <Baughn> p_l: Viking blood flows in my veins. Do not compare us with those earthworms.
04:33:46 <Ke> !
04:34:27 <Ke> transfusion from the year 800
04:35:13 <p_l> Baughn: Blood relation not necessary
04:35:56 <MarcWeber> dons: There is some interest in translating into Portuguese. Do you think it makes sense to translate the repository so that its easier to keep translation up to date? I don't know exactly the workflow which was used to create the book
04:41:13 <d-snp> hey dudes, the first haskell tutorial on h.org/learning is down :)
04:43:53 <bashrc_> @type map
04:43:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:44:13 <bashrc_> @type a -> (a -> b) -> b
04:44:14 <lambdabot> parse error on input `->'
04:44:24 <bashrc_> @reversetype a -> (a -> b) -> b
04:44:24 <lambdabot> Unknown command, try @list
04:44:28 <bashrc_> @list
04:44:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:45:06 <mauke> @djinn a -> (a -> b) -> b
04:45:06 <lambdabot> f a b = b a
04:45:29 <bashrc_> thank you mauke :)
04:45:57 <Baughn> Would it be useful to have some kind of djinn functionality in haskell-mode?
04:46:21 <Baughn> It could use every function in scope to offer suggestions
04:46:27 <mauke> http://okmij.org/ftp/Haskell/types.html#de-typechecker
04:46:50 <Ke> so why is darpa still not funding secure haskell - sandbox support for ghc
04:47:04 <Baughn> mauke: Thanks, and I'll keep that in mind.
04:47:14 <Ke> (proper sandbox with seccomp)
04:47:17 <bashrc_> @djinn (a -> b) -> [a] -> [b]
04:47:17 <lambdabot> Error: Undefined type []
04:47:36 <bashrc_> @type map
04:47:38 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:47:44 <Baughn> @djinn (a -> b) -> b -> a
04:47:44 <lambdabot> -- f cannot be realized.
04:48:20 <bashrc_> @djinn (Bool, Char) -> (Char, Bool)
04:48:20 <lambdabot> Error: Undefined type Char
04:48:22 <Baughn> @djinn (a -> b) -> f b -> f a
04:48:23 <lambdabot> -- f cannot be realized.
04:48:42 <mauke> @djinn (Functor f) => (a -> b) -> f a -> f b
04:48:42 <lambdabot> Error: Class not found: Functor
04:49:00 <bashrc_> @djinn [a] -> [b -> a]
04:49:01 <lambdabot> Error: Undefined type []
04:49:35 <aristid> @djinn a -> b
04:49:35 <lambdabot> -- f cannot be realized.
04:49:45 <aristid> wtf is there ANY valid input?
04:50:00 <dpratt71> what is @djinn, exactly? I thought it had something to do with type theory and theorems
04:50:07 <Baughn> aristid: How /would/ you write a -> b?
04:50:14 <zygoloid> @djinn (a -> b) -> ((a -> c -> c) -> c -> c) -> ((b -> c -> c) -> c -> c)
04:50:15 <lambdabot> f a b c d = b (\ e -> c (a e)) d
04:50:19 <aristid> Baughn: no idea?
04:50:24 <Baughn> aristid: const undefined
04:50:37 <aristid> @djinn a -> a
04:50:37 <lambdabot> f a = a
04:50:52 <mauke> @type maybe
04:50:53 <Baughn> @djinn (a -> a) -> a -> a
04:50:53 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:50:53 <lambdabot> f a = a
04:50:54 <aristid> @pl let f a = a in a
04:50:54 <lambdabot> a
04:51:03 <mauke> @. djinn type maybe
04:51:04 <lambdabot> f a b c =
04:51:04 <lambdabot>     case c of
04:51:04 <lambdabot>     Nothing -> a
04:51:04 <lambdabot>     Just d -> b d
04:51:11 <Baughn> @. pl djinn (a -> b) -> a -> b
04:51:11 <lambdabot> f = id
04:51:30 <aristid> @. pl djinn a -> a
04:51:30 <lambdabot> f = id
04:51:35 <aristid> yay.
04:51:40 <zygoloid> @djinn (a -> b) -> (forall c. (a -> c -> c) -> c -> c) -> (forall c. (b -> c -> c) -> c -> c)
04:51:40 <lambdabot> f _ _ _ a = a
04:51:45 <zygoloid> :(
04:51:46 <mauke> heh
04:51:50 <Baughn> aristid: They really are the same function. Surprised?
04:52:10 <aristid> Baughn: no, happy that it works
04:52:52 <bashrc_> @type f a b = b a
04:52:53 <lambdabot> parse error on input `='
04:53:48 <Baughn> @pl \a b c d e f g -> g f e c d b (a,a,a)
04:53:49 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))) .
04:53:50 <lambdabot> join (join (,,))
04:54:08 <bashrc_> @type foldr
04:54:09 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:54:11 <Baughn> Well, that was pointless.
04:54:32 <Baughn> @type let f a b = b a in f
04:54:34 <lambdabot> forall t t1. t -> (t -> t1) -> t1
04:54:55 <Baughn> bashrc_: It needs a value, not a definition. You just need to know how to tickle it. ;)
04:55:13 <bashrc_> ah ok :D thank you :)
04:55:20 <mauke> :t 2 + 2
04:55:22 <lambdabot> forall t. (Num t) => t
04:55:26 <zygoloid> @@ @pl @djinn @type (Prelude..) . (Prelude..)
04:55:27 <lambdabot>  f = (.) . (.)
04:55:40 <Baughn> @_@
04:55:49 <opqdonut> :)
04:56:02 <opqdonut> (Prelude..) is so cute
04:56:16 <bashrc_> @djinn (a,b) -> (b,a)
04:56:17 <lambdabot> f (a, b) = (b, a)
04:56:39 <opqdonut> @@ @pl @djinn (a,b) -> (b,a)
04:56:39 <lambdabot>  f = uncurry (flip (,))
04:56:40 <zygoloid> > let modules = [Prelude..] in (+1) modules (*3) $ 5
04:56:41 <lambdabot>   <no location info>: parse error on input `]'
04:57:02 <mauke> > let f = (Prelude..) in (+1) `f` (*3) $ 5
04:57:03 <lambdabot>   Not in scope: `Prelude..'
04:57:20 <mauke> > let f = (P..) in (+1) `f` (*3) $ 5
04:57:21 <lambdabot>   16
04:57:25 <bashrc_> @type let f (a, b) = (b, a) in f
04:57:27 <lambdabot> forall t t1. (t, t1) -> (t1, t)
04:57:40 <bashrc_> @type let f a b = b a in f
04:57:41 <lambdabot> forall t t1. t -> (t -> t1) -> t1
04:57:46 <bashrc_> why is this diffent?
04:57:58 <mauke> bashrc_: uh, because it's completely different?
04:58:12 <bashrc_> both take two arguments
04:58:15 <mauke> no
04:58:24 <mauke> one takes one argument, the other two
04:58:34 <bashrc_> ah ok
04:58:39 <mauke> one returns a tuple, the other a function application
04:58:56 <mauke> well, technically all functions take one argument
04:59:14 <mauke> f1 = \x -> case x of (a,b) -> (b,a)
04:59:24 <mauke> f2 = \a -> \b -> b a
05:00:37 <bashrc_> hmm
05:00:41 <bashrc_> i see
05:01:46 <bashrc_> can we let @type result with (Bool, Char) -> (Char, Bool) instead of (a,b) -> (b,a) ?
05:02:09 <zygoloid> @type \(a, b) -> (b, a) :: (Bool, Char) -> (Char, Bool)
05:02:10 <lambdabot>     Couldn't match expected type `(Bool, Char) -> (Char, Bool)'
05:02:10 <lambdabot>            against inferred type `(t1, t)'
05:02:10 <lambdabot>     In the expression: (b, a) :: (Bool, Char) -> (Char, Bool)
05:02:27 <zygoloid> @type (\(a, b) -> (b, a)) :: (Bool, Char) -> (Char, Bool)
05:02:28 <lambdabot> (Bool, Char) -> (Char, Bool)
05:02:38 <bashrc_> great, thx zygoloid
05:02:43 <mauke> :t \(a, b) -> (b :: Char, a :: Bool)
05:02:44 <lambdabot> (Bool, Char) -> (Char, Bool)
05:03:04 <mauke> :t \(a, b) -> (b, a) `asTypeOf` ('x', False)
05:03:05 <lambdabot> (Bool, Char) -> (Char, Bool)
05:03:27 <leino> is this the place to ask about cabal installation problems?
05:03:37 <zygoloid> @type \(a::Bool, b::Char) -> (b, a)
05:03:38 <lambdabot> (Bool, Char) -> (Char, Bool)
05:03:56 <Saizan> leino: there's also #hackage
05:04:10 <bashrc_> pretty much possiblities :) thx :)
05:04:20 <leino> Saizan: ok, thanks
05:05:40 * hackagebot precis 0.4.0 - Diff Cabal packages.  http://hackage.haskell.org/package/precis-0.4.0 (StephenTetley)
05:05:57 <bashrc_> :t \a -> [a::Char]
05:05:58 <lambdabot> Char -> [Char]
05:06:09 <mauke> :t \a -> a : ""
05:06:10 <lambdabot> Char -> [Char]
05:06:15 <bashrc_> :t \a -> [[a::Char]]
05:06:16 <lambdabot> Char -> [[Char]]
05:06:21 <bashrc_> i think i got it now :)
05:06:22 <mauke> :t \a -> [a : ""]
05:06:23 <lambdabot> Char -> [[Char]]
05:06:45 <zygoloid> @type \a -> [a]:([]::String)
05:06:46 <lambdabot>     Couldn't match expected type `[t]' against inferred type `Char'
05:06:46 <lambdabot>       Expected type: [[t]]
05:06:46 <lambdabot>       Inferred type: String
05:07:01 <zygoloid> @type \a -> [a]:([]::[String])
05:07:02 <lambdabot> Char -> [[Char]]
05:07:38 <zygoloid> @type (:[]).(:"")
05:07:39 <lambdabot> Char -> [[Char]]
05:08:28 <bashrc_> :t \([a],[b]) -> [(a::Char,b)]
05:08:29 <lambdabot> forall t. ([Char], [t]) -> [(Char, t)]
05:08:52 <bashrc_> :t \[a],[b] -> [(a::Char,b)]
05:08:53 <lambdabot> parse error on input `,'
05:09:00 <bashrc_> :t \[a] [b] -> [(a::Char,b)]
05:09:01 <lambdabot> forall t. [Char] -> [t] -> [(Char, t)]
05:09:07 <peterNovice> Does anyone know why System.Random.MWC.normal is not returning a result on ghc 6.10.4?
05:09:09 <bashrc_> nice :D
05:11:14 <bashrc_> i am now thinking about [a] -> [b -> a]
05:11:37 <mauke> :t map const
05:11:38 <lambdabot> forall a b. [a] -> [b -> a]
05:11:47 <bashrc_> :D
05:12:07 <bashrc_> cool thx
05:13:13 <bashrc_> mauke: do you also now one for [a] -> [(a1, [a])] -> [a]
05:13:16 <bashrc_> :)
05:13:38 <Botje> this is starting to sound like homework
05:13:52 <mauke> bashrc_: yeah, that's just const
05:13:58 <sepp2k> What was the mexican food called that is like monads?
05:14:07 <mauke> hahaha
05:14:22 <bashrc_> const?
05:14:27 <bashrc_> :t const
05:14:27 <mauke> someone needs to write a mexican food tutorial
05:14:28 <lambdabot> forall a b. a -> b -> a
05:14:33 <Botje> sepp2k: apples :]
05:14:39 <Botje> or possibly burritos
05:14:55 <sepp2k> Botje: Thanks.
05:15:16 <exDM69> can someone elaborate how burritos and monads are related?
05:16:56 <bashrc_> :t map const a1
05:16:57 <lambdabot> Not in scope: `a1'
05:17:04 <bashrc_> :t map const \a -> a
05:17:05 <lambdabot> parse error on input `\'
05:19:06 <IceKiller> hey, i'm trying to start some haskell code but umm i'm having the weirdest problems and google isn't really helping, what exactly is the correct way to read in a file as a string and then use "words" to make it into an array,
05:20:00 <Baughn> "array"? You mean list of words?
05:20:13 <Baughn> An array is an entirely different data structure
05:20:21 <mauke> IceKiller: do x <- readFile; ... words x
05:20:32 <Baughn> IceKiller: You'd probably be better off describing the problems
05:20:33 <mauke> well, readFile "some filename here"
05:21:04 <bashrc_> :t const (\[b] -> [b])
05:21:05 <lambdabot> forall t b. b -> [t] -> [t]
05:21:28 <bashrc_> :t const (\[b] a -> [b])
05:21:29 <lambdabot> forall t t1 b. b -> [t] -> t1 -> [t]
05:21:55 <bashrc_> :t const (\[b] a -> (a,[b]))
05:21:57 <lambdabot> forall t t1 b. b -> [t] -> t1 -> (t1, [t])
05:22:12 <bashrc_> :t const (\[c] a -> (a,[c]))
05:22:13 <lambdabot> forall t t1 b. b -> [t] -> t1 -> (t1, [t])
05:22:47 <IceKiller> hm mauke i tried that but i'm getting weird errors because x is a IO string and i'm trying to cast it or manipulate it as a String
05:22:54 <mauke> IceKiller: no, x is a String
05:24:57 <Baughn> IceKiller: With "x <- readFile foo", the left-hand side of the <- has one less IO than the right-hand type. Think of it as unpacking the IO type. Or running the function, whichever.
05:27:43 <bashrc_> :t let f [a] = \(b,[a]) -> a in f
05:27:44 <lambdabot> forall t t1 t2. [t] -> (t1, [t2]) -> t2
05:28:20 <bashrc_> :t let f [a] = \b -> a in f
05:28:21 <lambdabot> forall t t1. [t] -> t1 -> t
05:28:27 <bashrc_> :t let f [a] = \b -> [a] in f
05:28:28 <lambdabot> forall t t1. [t] -> t1 -> [t]
05:29:33 <Botje> bashrc_: you can also /query lambdabot
05:31:20 <bashrc_> oki, thx :)
05:41:53 <mauke> :t const :: [a] -> [(a, [a])] -> [a]
05:41:54 <lambdabot> forall a. [a] -> [(a, [a])] -> [a]
05:41:56 <Jonno_FTW> hey
05:43:55 <buntfalke> What's wrong here?
05:44:00 <buntfalke>         it f 1 = \x -> f x
05:44:01 <buntfalke>         it f n = f x where x = it f (n-1)
05:44:33 <buntfalke> GHC says "Occurs check: cannot construct the infinite type: t = t -> t1; Probable cause: `f' is applied to too many arguments"
05:45:30 <mauke> the 1st definition returns f
05:45:34 <mauke> the 2nd definition returns f x
05:45:40 <mauke> that can't be right
05:46:51 <buntfalke> Well - what I try to do is, write an "iterate" function, such that, for instance, sqrt `it` 2 would be the 4th root.
05:47:02 <kolmodin> http://downforeveryoneorjustme.com/haskell.org
05:47:09 <kolmodin> seems offline?
05:47:34 <buntfalke> when I just return "f" in the 1st case, and f (it f (n-1)) in the 2nd, it fails as well....
05:47:37 * buntfalke is confused
05:47:47 <mauke> it f 0 = id
05:48:05 <mauke> it f n = it f (n-1) . f
05:48:26 <buntfalke> what's the keyword to search for the "."?
05:48:35 <mauke> what
05:48:43 <sepp2k> @src .
05:48:43 <lambdabot> (f . g) x = f (g x)
05:48:43 <lambdabot> NB: In lambdabot,  (.) = fmap
05:48:47 <Olathe> @type let it f 0 = id; it f n = it f (n - 1) . f in it
05:48:49 <lambdabot> forall a t. (Num t) => (a -> a) -> t -> a -> a
05:48:53 <mauke> @index .
05:48:53 <lambdabot> Prelude
05:48:56 <buntfalke> thanks
05:48:58 <mauke> @where report
05:48:58 <lambdabot> http://www.haskell.org/onlinereport/
05:49:12 <mauke> WHY ARE YOU DOWN
05:53:27 <Jonno_FTW> seems fine to me
05:53:52 <Jonno_FTW> on that note
05:54:11 <buntfalke> Jonno_FTW: not the www. part of it
05:54:11 <Jonno_FTW> why won't this work: input <- fmap lines ( mapM  readFile =<< (getDirectoryContents "/some/dir/"))
05:55:08 <Olathe> @type getDirectoryContents
05:55:09 <lambdabot> Not in scope: `getDirectoryContents'
05:55:30 <scree> don't you need (fmap.fmap) lines?
05:55:32 <mauke> Jonno_FTW: that looks like a type error
05:55:36 <Jonno_FTW> i get this type error: Couldn't match expected type `Char' against inferred type `[Char]'
05:55:40 <mauke> exactly
05:55:41 <Jonno_FTW> but i don't know why
05:55:46 <mauke> Jonno_FTW: lines takes a String, not a list of them
05:55:58 <scree> Jonno_FTW: so, RHS has type IO [String]
05:56:04 <Jonno_FTW> it gets the error at readFile
05:56:16 <mauke> oh, that's because of =<<
05:56:21 <mauke> wait
05:56:29 <mauke> no
05:56:31 <Jonno_FTW> i'm not very familiar with bind
05:57:16 <mauke> it's what I said
05:57:21 <mauke> Jonno_FTW: lines takes a String, not a list of them
05:57:31 <Jonno_FTW> ok
05:57:32 <scree> @type (fmap.fmap) lines (mapM readFile =<< (undefined :: IO [String])
05:57:33 <lambdabot> parse error (possibly incorrect indentation)
05:57:39 <scree> @type (fmap.fmap) lines (mapM readFile =<< (undefined :: IO [String]))
05:57:40 <lambdabot> IO [[String]]
05:57:58 <Olathe> > [(+1), (+2), (+3)] <*> [1, 10, 100]
05:58:00 <lambdabot>   [2,11,101,3,12,102,4,13,103]
05:58:34 <Jonno_FTW> thanks
05:59:07 <Saizan> Jonno_FTW: also, "getDirectoryContents dir" gives you the paths as relative to dir, so you'd need s/readFile/readFile . ("/some/dir"</>)/
05:59:29 <Saizan> and parentheses around that.
06:00:00 <Jonno_FTW> i'd need a regex?
06:00:04 <mauke> wat
06:00:11 <FliPPeh_> Oh god
06:00:19 <FliPPeh_> I crashed my Computer again using Haskell
06:00:26 <Olathe> And some verbs.
06:00:35 <FliPPeh_> Just by writing 0xFFFFFF * 5 lines to a file
06:00:44 <bremner> FliPPeh_: dude. Some talent. Windows?
06:00:51 <FliPPeh_> bremner: Linux.
06:00:53 <mauke> > 0xFFFFFF * 5
06:00:54 <lambdabot>   83886075
06:01:02 <FliPPeh_> I swapped to 100% and RAM'd to 99%
06:01:16 <mauke> get more swap
06:01:22 <bremner> FliPPeh_: umm. I'm skeptical. Care to paste a test case?
06:01:28 <FliPPeh_> I wanted to print the whole colour spectrum from 0x000000 to 0xFFFFFF to a file :x
06:01:33 <mauke> heh
06:01:46 <Jonno_FTW> that's a lot of colours
06:01:50 <FliPPeh_> It is!
06:01:54 <bremner> oh, I see, not 5 lines of 0xFFFFFF. Well, something is wrong still.
06:01:58 <mauke> preflex ? who:JaffaCake
06:01:58 <FliPPeh_> bremner: let f = prettyHtml $ body << buildColorTable [0x000000 .. 0xFFFFFF]
06:01:58 <preflex>  Simon Marlow
06:02:05 <FliPPeh_> bremner: writeFile "c.html" f
06:02:06 <FliPPeh_> :)
06:02:08 <mauke> preflex++  # botsnack
06:02:26 <FliPPeh_> I shall use bytestrings now
06:02:47 <Blkt> do you guys know a way to represent an infinite list of integers modulo 5? Z_5 to be clear...
06:02:54 <mauke> ORBITZ
06:03:05 <Olathe> > cycle [0..4]
06:03:06 <lambdabot>   [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,...
06:03:13 <Blkt> awsome!
06:03:14 <Blkt> thank you
06:03:18 <Olathe> You're welcome
06:03:39 <orbitz> MAUKE
06:03:49 <mauke> orbitz: I've merged one of preflex's older brains
06:03:55 <mauke> it had PoppaVic quotes
06:04:02 <orbitz> mauke: Ohhh excellent!
06:05:03 <Jafet> mauke, bind that to !sugardaddy
06:05:49 <FliPPeh_> Another "killall ghc"
06:05:51 <Olathe> > let modList modulus = f modulus 0 where f m n = if m == n then f m 0 else n:f m (n + 1) in modList 4
06:05:51 <FliPPeh_> Lame.
06:05:52 <lambdabot>   [0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,0,...
06:06:08 <mauke> > map (`mod` 5) [0 ..]
06:06:09 <lambdabot>   [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,...
06:06:32 <buntfalke> @src map
06:06:32 <lambdabot> map _ []     = []
06:06:32 <lambdabot> map f (x:xs) = f x : map f xs
06:06:33 <Jafet> > cycle [0..4]
06:06:34 <lambdabot>   [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,...
06:06:45 <mauke> Jafet: too late
06:07:11 <mauke> > iterate ((`mod` 5) . succ) 0
06:07:13 <lambdabot>   [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,...
06:07:35 <Blkt> is [0..n-1] more efficient than map mod 5 [0..]?
06:07:45 <Blkt> (can't write backquote from windows sorry)
06:07:46 <mauke> yes
06:07:54 <Blkt> thanks
06:08:07 <FliPPeh_> I wonder who wanted to use backticks for programming
06:08:12 <FliPPeh_> Someone american probably
06:08:18 <Jafet> Larry!
06:08:18 <FliPPeh_> Horrible reachable characters for me
06:08:42 <Blkt> also Lisp has a lot of them for macros, I really need a better layout on this OS
06:08:45 <FliPPeh_> I have to press SHIFT and DOUBLE TAP to get `
06:08:58 <Olathe> > let modList modulus = iterate (\x -> let x' = succ x in if x' == modulus then 0 else x) 0 in modList 5
06:08:59 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
06:09:00 <Blkt> there was a program to make them but works only over x86, x64 here...
06:09:05 <mauke> FliPPeh_: get a better keyboard layout :-)
06:09:05 <Jafet> > fix ((0:) . map ((`mod`5).succ))
06:09:05 <Olathe> > let modList modulus = iterate (\x -> let x' = succ x in if x' == modulus then 0 else x') 0 in modList 5
06:09:06 <lambdabot>   [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,...
06:09:07 <lambdabot>   [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,...
06:09:28 <FliPPeh_> mauke: I like my de-latin1 :(
06:09:32 <Olathe> There. No mod all the time and no storing [0..modulus - 1].
06:09:46 <mauke> FliPPeh_: but get one without dead keys
06:09:58 <mauke> it sucks for coding
06:09:58 <FliPPeh_> de-latin1-nodeadkeys?
06:10:02 <Blkt> FliPPeh_: I do like my it keyb too, but altgr+' would do the trick
06:10:06 <FliPPeh_> I never figured what it'd do
06:10:11 <Olathe> Hmm, I guess mod might be better.
06:10:15 <mauke> make ` insert a `
06:10:20 <mauke> instead of sitting there and waiting
06:10:32 <Jonno_FTW> , I fixed my code up, but now i get: *** Exception: ..: openFile: permission denied (Permission denied)
06:10:47 <mauke> but really, de layout sucks for programming
06:10:55 <mauke> most languagues use {[]} ALL THE TIME
06:11:03 <mauke> or \
06:11:19 <FliPPeh_> ’I got used to {} and [] already
06:11:35 <Jafet> (o 'rly)
06:12:00 <FliPPeh_> ’’``
06:12:28 <mauke> ‘’
06:12:31 <mauke> `'
06:12:35 <Jonno_FTW> how do i get the init $ init of IO [Filepath] ?
06:12:37 <FliPPeh_> > 0xFFFFFF
06:12:38 <lambdabot>   16777215
06:12:39 <FliPPeh_> Mh
06:13:20 <Olathe> Jonno_FTW: fmap (init . init) x ?
06:16:34 <Jonno_FTW> well
06:16:41 <Jonno_FTW> i basically want to drop the last 2 elements
06:16:49 <Jonno_FTW> because they are ".." and "."
06:17:45 <Jonno_FTW> thanks
06:18:10 <Olathe> Jonno_FTW: filter (\x
06:18:28 <mauke> huhu
06:18:30 <Jafet> fromEnd (drop 2) where fromEnd = (reverse.).(.reverse)
06:18:34 <Olathe> Jonno_FTW: fmap (filter (\x -> x /= "." && x /= ".."))
06:18:51 <mauke> Jonno_FTW: how do you know ".." and "." will be the last 2 elements?
06:19:01 <Jonno_FTW> because
06:19:11 <Jafet> Good answer.
06:19:17 <Jonno_FTW> getDirectoryContents =<< getCurrentDirectory
06:19:23 <Jonno_FTW> gives a list
06:19:30 <mauke> so you tried one directoy once
06:19:40 <mauke> how do you know the order is deterministic?
06:19:46 <mauke> how do you know it's the same for all directories?
06:19:58 <Jonno_FTW> where ".." and "." are the last 2 items
06:19:59 <Jonno_FTW> hmmm
06:20:15 <mauke> filter (`notElem` [".", ".."])
06:20:28 <Jonno_FTW> i guess
06:20:35 <Jonno_FTW> it's specific to this folder
06:20:41 <Jonno_FTW> i mean
06:20:46 <Jonno_FTW> non root directories
06:20:52 <scree> fmap (filter (not . flip elem . take 2 . iterate ('.':) "."))
06:21:33 <mauke> heh
06:21:35 <Olathe> fmap (filter (\(x:xs) -> if x == '.' then not (null xs) && xs /= "." else True))
06:22:33 <Jonno_FTW> i now seem to be getting more problems
06:22:34 <mauke> did you mean: x /= '.' || (not (null xs) && xs /= ".")
06:22:55 <Jonno_FTW> input <- (fmap . fmap) lines (mapM  readFile =<< (fmap (init . init) (getDirectoryContents =<< getCurrentDirectory)))
06:22:57 <Jonno_FTW>     let output = show $ length $ fmap (\x -> filter ("hm" `isInfixOf`) x) input
06:23:13 <scree> fmap (filter ((`elem` [1,2]) . length . takeWhile (=='.'))
06:23:19 <Jonno_FTW> all that output returns is how many files are in the folder
06:23:23 <scree> no, damn
06:23:26 <Jonno_FTW> and I can't figure out why
06:23:36 <Olathe> mauke: Yes, that's a better way.
06:24:14 <Jonno_FTW> any ideas?
06:25:16 <mauke> what
06:25:34 <Jonno_FTW> output only returns the number of files in the folder
06:26:02 <mauke> no, it doesn't
06:26:17 <mauke> or are we suddenly using perl?
06:26:50 <Jonno_FTW> well
06:26:53 <Jonno_FTW> basically
06:27:16 <Jonno_FTW> i want to analyse my msn logs, the task was to do it shorter than my friend could in perl
06:27:22 <mauke> haha
06:27:26 <Jonno_FTW> i think i lost
06:27:36 <Jonno_FTW> but anyway
06:27:44 <Jonno_FTW> i don't know why i get that result
06:28:05 <mauke> I don't know what "that result" is or what your code is
06:28:10 <mauke> so ... cool story, bro
06:28:11 <Jonno_FTW> ok
06:28:20 <Jonno_FTW> input <- (fmap . fmap) lines (mapM  readFile =<< (fmap (init . init) (getDirectoryContents =<< getCurrentDirectory)))     let output = show $ length $ fmap (\x -> filter ("hm" `isInfixOf`) x) input
06:28:27 <Jonno_FTW> it looks like that
06:28:38 <Olathe> zomg
06:28:38 <Jonno_FTW> putStrLn output
06:28:45 <mauke> show length
06:28:51 <mauke> and you're wondering why you get a number?
06:28:59 <Jonno_FTW> that's what I want
06:29:15 <Jonno_FTW> shouldn't input contain all the data within the files?
06:29:22 <Jonno_FTW> not the file names
06:30:03 <mauke> it does
06:30:27 <Jonno_FTW> then what is wrong with the output then?
06:30:44 <mauke> nothing
06:31:31 <mauke> Jonno_FTW: what is the type of input?
06:31:36 <Jonno_FTW> but.... i don't understand since it only gives me the number of files in the folder
06:31:42 <Jonno_FTW> the input is html files
06:31:51 <mauke> 'html files' is not a type
06:32:05 <mauke> here's a hint: [[String]]
06:32:09 <Jonno_FTW> yeah
06:32:24 <mauke> how many elements are there in input?
06:32:44 <Jonno_FTW> 272
06:32:56 <mauke> answer: as many as there are files, because each element of input is the contents of one file
06:33:08 <Jonno_FTW> ok
06:33:14 <mauke> you suck at debugging
06:33:20 <Jonno_FTW> >:33
06:33:30 * mauke gets in the car
06:33:37 <Jonno_FTW> can i just concat the entire list?
06:33:44 <ClaudiusMaximus> you need a concat or a sum in there
06:33:45 <mauke> yes
06:34:01 <Jonno_FTW> :t concat
06:34:02 <lambdabot> forall a. [[a]] -> [a]
06:35:19 <Jonno_FTW> errr... how do i do make it concat IO [[String]]?
06:36:30 <mauke> why do you have IO in there?
06:36:59 <mauke> also, what is the task here?
06:37:06 <mauke> count the lines in all files in the current directory?
06:37:29 <Jonno_FTW> all the lines that contain the string "hmm"
06:37:32 <Jonno_FTW> since we say it a lot
06:38:53 <mauke> perl -lpe '$n+=/hmm/}{$_=$n' *
06:39:06 <EvanR-work> @src Ptr
06:39:06 <lambdabot> data Ptr a = Ptr Addr#
06:39:07 <Jonno_FTW> :\
06:39:19 <Jonno_FTW> this isn't perl
06:39:39 <dmwit> You agreed to a source-code-size competition against Perl on a directory processing problem that can be solved with regexes?
06:39:45 <ClaudiusMaximus> grep hmm * | wc -l
06:39:55 <dmwit> grep -c hmm *
06:39:58 <Jonno_FTW> yes
06:40:03 <Jonno_FTW> also as an excersise
06:40:11 <Jonno_FTW> since I haven't done much with haskell lately
06:40:41 <mauke> perl -lpe '$n+=0>=index$_,hmm}{$_=$n' *  # there, without regexes
06:41:03 <ClaudiusMaximus> dmwit: here grep -c gives a count per file, not a grand total
06:41:17 <jmcarthur> there are certain challenges you do not accept. this is one of them ;)
06:42:16 <Jafet> What if he wins
06:42:26 <Saizan> the "}{" part is quite pretty
06:42:29 <Jonno_FTW> not much
06:42:31 <Jonno_FTW> another useless tool is made
06:42:32 <triyo> I am looking join a list of strings with a separator, what is the name of the function that can do this...seen it somewhere..
06:42:44 <Saizan> triyo: intercalate
06:42:52 <mauke> @hoogle [a] -> [[a]] -> [a]
06:42:53 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
06:42:53 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
06:42:53 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
06:43:11 <triyo> On that note, is there a way in ghci to search for functions by doc strings, comments or something?
06:43:22 <triyo> Saiza: thanks
06:43:35 <Jonno_FTW> triyo: you can install a local lambdabot
06:43:37 <mauke> there are no doc strings
06:43:53 <mauke> @where hoogle
06:43:54 <lambdabot> http://haskell.org/hoogle
06:44:01 <mauke> lets you search by type or name
06:44:28 <triyo> Jonno_FTW: where could I get the source for it?
06:44:45 <Jonno_FTW> the source of lambdabot is on hackage
06:45:44 <fryguybob> @google hoogle hackage
06:45:45 <lambdabot> http://hackage.haskell.org/package/hoogle
06:45:45 <lambdabot> Title: HackageDB: hoogle-4.0.7
06:47:06 * Jonno_FTW is still stuck
06:50:34 <Jonno_FTW> :t lines
06:50:35 <lambdabot> String -> [String]
06:57:54 <Jonno_FTW> will no one help this poor wretch?
06:58:04 <fryguybob> What do you need?
06:58:28 <Jonno_FTW> i have IO [String]
06:58:37 <Jonno_FTW> wait
06:58:53 <Jonno_FTW> i have IO [[String]]
06:59:06 <Jonno_FTW> which I need to concat to IO [String]
06:59:12 <Zao> @type concat
06:59:13 <lambdabot> forall a. [[a]] -> [a]
06:59:34 <fryguybob> do xs <- stuff; return concat xs ?
06:59:59 <dmwit> fmap concat stuff
07:00:04 <Zao> @type liftM
07:00:05 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:00:51 <fryguybob> @type liftM concat
07:00:52 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
07:02:29 <fryguybob> @type fmap concat
07:02:30 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
07:02:41 <fryguybob> @instances Functor
07:02:43 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:02:56 <fryguybob> Ah no IO in lambdabot
07:03:04 <fryguybob> Oh it's there, didn't see it.
07:09:49 <EvanR-work> @hoogle showIntAtBase
07:09:50 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
07:10:19 <EvanR-work> gah
07:10:24 <EvanR-work> i want hex
07:10:33 <EvanR-work> > hex 140724603453440
07:10:34 <lambdabot>   Not in scope: `hex'
07:10:44 <EvanR-work> google fails on that large number
07:12:26 <nschoe> WolframAlpha says 7ffd00000000
07:12:34 <Olathe> > showHex 140724603453440 ""
07:12:35 <lambdabot>   "7ffd00000000"
07:12:52 <Olathe> > 0x7ffd00000000
07:12:53 <lambdabot>   140724603453440
07:13:14 <xerox> > showIntAtBase 16 ("0123456789abcdef"!!) 140724603453440
07:13:15 <lambdabot>   ""->
07:13:15 <lambdabot>    "7ffd00000000"
07:13:15 <lambdabot>  "a"->
07:13:15 <lambdabot>    "7ffd00000000a"
07:13:15 <lambdabot>  "aa"->
07:13:17 <lambdabot>    "7ffd00000000aa...
07:13:19 <Saizan> > showIntAtBase 16 intToDigit 140724603453440 ""
07:13:20 <lambdabot>   "7ffd00000000"
07:13:24 <xerox> :)
07:14:09 <dmwit> > showIntAtBase 36 intToDigit (36^5-1)
07:14:10 <lambdabot>   *Exception: Char.intToDigit: not a digit 35
07:15:39 <centrinia> > showIntAtBase 36 ((['0'..'9']++['a'..'z'])!!) (36^5-1) ""
07:15:40 <lambdabot>   "zzzzz"
07:32:27 <m_88> Uhh, why installing packages is so painful in haskell :[ Can someone help me with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25477#a25477 ?
07:34:30 <Saizan> 1) don't use sudo cabal install ...; just use "cabal install .." for user installations or "cabal install --global --root-cmd=sudo .." for global ones
07:34:35 <byorgey> m_88: that means you need to install some sort of GraphicsMagick package through your OS's package manager
07:34:47 <Saizan> 2) what byorgey said :)
07:34:49 <byorgey> because the hsmagick package has bindings to a C library
07:35:02 <byorgey> and cabal install can't install that for you, since it isn't a Haskell package
07:35:13 <m_88> 1) noted 2) thanks
07:46:52 <dpratt71> Saizan: why #1?
07:47:53 <illissius> how do you re-export something you imported from another module?
07:47:55 <byorgey> dpratt71: no need to run the entire process with root privileges; the configure and build steps don't need it
07:48:11 <byorgey> dpratt71: with --root-cmd=sudo it will take root privileges only for the installation steps where it is needed
07:48:31 <dpratt71> byorgey: ah
07:48:32 <byorgey> illissius: just list it in the export list
07:48:36 <dino-> Whomever fixed the hackage system broken packages, thank you!
07:49:31 <byorgey> illissius: are you having trouble?  or just wondering?
07:49:36 <illissius> byorgey: that's what i figured :\ so i'm probably doing it wrong
07:49:38 <illissius> the former
07:49:41 <Saizan> dpratt71, byorgey: also sudo doesn't change $HOME, so it might end writing root owned files into your user ~/.cabal/ directory
07:51:34 <illissius> I have: module Analyze where (Scalar (..), ... ); import qualified Parser as P; type Scalar = P.Scalar
07:51:47 <illissius> can you not export type synonyms? or something else?
07:52:11 <dpratt71> at some point recently I did "sudo cabal install xyz --global", which I assume is probably harmless even though there was an unnecessary privilege elevation
07:52:39 <illissius> (the error it's giving is that when I import Analyze from a third module and try to use Scalar's constructors, it says they're not in scope)
07:55:26 <Saizan> dpratt71: at worst you'd need to chown something in your ~/.cabal/
07:56:13 <illissius> ah, never mind, got it -- apparently out of "Scalar", "P.Scalar", "Scalar (..)", and "P.Scalar (..)", it's the last one which works
07:56:24 <Saizan> heh
07:57:01 <mreh> conal: can I ask a quick question about Fruit?
07:57:13 <conal> mreh: sure
07:58:01 <mreh> conal: it's about composition of GUI types with above and besideGUI
07:58:16 <conal> mreh: i vaguely remember.
07:58:42 <mreh> they both look like this :: GUI b c -> GUI d e -> GUI (b,d) (c,e)
07:59:05 <conal> ok
07:59:27 <mreh> I'm rather worried how you manage the tuples when you start nesting more and more data
07:59:39 <mreh> s/data/widgets/
08:00:03 <conal> mreh: btw, i'm expecting a phone call any minute and may have to tune out for 30 minutes or so.
08:00:41 <mreh> conal: not a problem, I'm just reading another of your papers, it can wait
08:00:53 <mreh> i'll read on and see if the answer lies within
08:01:03 <byorgey> illissius: yes, the (..) is needed to export the constructors
08:01:13 <byorgey> illissius: and apparently you can't export type synonyms
08:01:16 <byorgey> although I didn't know that
08:06:54 <Saizan> what do you mean?
08:09:48 <sioraiocht> is it possible to use pattern matching on alternative string types e.g. ByteString?
08:12:12 <mreh> sioraiocht, can you give an example?
08:12:48 <sioraiocht> if I wanted to do foo "mystring" = .... where foo :: ByteString -> ....
08:12:56 <sioraiocht> mreh: ^
08:13:12 <quicksilver> with view patterns, yes, sioraiocht
08:13:15 <quicksilver> otherwise no.
08:13:22 <sioraiocht> "view patterns"?
08:13:27 <quicksilver> unless OverloadedStrings handles that case, perhaps it does.
08:13:45 <icekille> hmm quick question to split a line into "2" lines do you use $ ?
08:13:54 <quicksilver> icekille: no, you don't need to do anything
08:14:02 <quicksilver> ...except make sure the second line is sufficiently indented
08:14:12 <icekille> ah ok srry :) cause i'm looking at this example and they use $ on the second line and don't have a clue why :p
08:14:17 <sioraiocht> quicksilver: I don't think it does
08:14:19 <quicksilver> they use $ because they need $
08:14:21 <sioraiocht> it just has "fromString"
08:14:26 <quicksilver> not anything to do with line splitting.
08:14:30 <icekille> quicksilver hmm but what does "$" do tehn?
08:14:34 <sioraiocht> thanks though, quicksilver, mreh
08:15:16 <djahandarie> @src ($)
08:15:17 <lambdabot> f $ x = f x
08:15:35 <icekille> ah
08:15:47 <Jafet> It saves typing
08:15:50 <quicksilver> suiside:
08:15:57 <quicksilver> sioraiocht: I think you're wrong.
08:16:01 <Jafet> And saving typing saves money!
08:16:03 <sioraiocht> quicksilver: really?
08:16:06 <djahandarie> icekille, it just normally applies a function, except prevents you from needing to put extra parentheses
08:16:08 <icekille> ok thx ^^ really weird to go from normal coding into haskell
08:16:12 <quicksilver> sioraiocht: the OverloadedStrings example in the docs shows a string used in a pattern match.
08:16:15 <sioraiocht> huh
08:16:26 <quicksilver> I suspect it works the same way as numbers
08:16:35 <sioraiocht> ah, it gets translated into an quality comparison
08:16:38 <sioraiocht> I guess that's okay, heh
08:16:41 <sioraiocht> sweet
08:16:44 <quicksilver> f 3 = ... desugars to "f x | fromIntegral 3 == x = ..."
08:16:55 <sioraiocht> quicksilver: thanks!
08:17:02 <quicksilver> of course, ByteString is a terrible instance of IsString
08:17:04 <djahandarie> icekille, have you checked out some tutorials like http://learnyouahaskell.com or http://book.realworldhaskell.org/read/ ?
08:17:20 <icekille> djahandarie i followed my book ^^
08:17:28 <icekille> but thx
08:17:29 <quicksilver> since it can only store 8 bits per char.
08:17:31 <icekille> i'll read those websites
08:19:05 <quicksilver> icekille: normally, $ is just a way to reduce the number of () you type. So you can write f $ 1 + 2 + 3 instead of f (1 + 2 + 3)
08:19:11 <sioraiocht> quicksilver: yes, as is Tex
08:19:12 <sioraiocht> t
08:19:23 <m_88> umm
08:19:31 <m_88> how to update 'base' package in cabal?
08:19:34 <quicksilver> don't.
08:19:36 <quicksilver> never do that.
08:19:37 <sioraiocht> lol
08:19:39 <quicksilver> don't even think of it.
08:19:44 * sioraiocht thinks of it.
08:19:46 <quicksilver> promise you won't ever do that!
08:19:53 <m_88> ok
08:19:55 <m_88> i promise
08:19:58 <quicksilver> base is hardwired into GHC
08:20:08 <quicksilver> you change your base version by installing a different version of GHC
08:20:19 <m_88> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25478#a25478
08:20:32 <m_88> so in oreder to resolve this problem i have to update my ghc?
08:21:37 <Saizan> you've to remove -Werror from the .cabal file
08:21:55 <Saizan> --preference="base >= 4" might also work
08:21:55 <quicksilver> or install an *older* version of GHC, I suspect, not a newer one.
08:22:09 <quicksilver> but the simplest thing is probably to turn Werror off
08:22:30 <m_88> umm and how can i turn Werror off?
08:22:40 <quicksilver> remove it from the .cabal file as Saizan suggested.
08:22:49 * quicksilver doesn't think -Werror is appropriate in distributed software.
08:22:49 <m_88> ~/.cabal?
08:22:52 <Saizan> try --preference="base >= 4" first, it's simpler if it works
08:22:55 <m_88> it's a dirrectory
08:23:02 <quicksilver> no, hsmagick.cabal
08:23:07 <quicksilver> or whatever that package is called in fact
08:23:13 <rovar> I've got a networked app in which I construct a pair of Lazy ByteStrings via Binary and then hPut them, however,  it seems to require 7 TCP sends to get the buffer through, and it's confusing the server (which reads the lazy bytestrings and parses with Binary Get.)
08:23:27 <Saizan> m_88: not there, you'd use "cabal unpack hsmagick" to extract the package tarball
08:23:32 <m_88> hm
08:23:33 <m_88> Graphics/Transform/Magick/Util.hs:6:0: Warning: Module `GHC.IOBase' is deprecated: use GHC.IO instead
08:23:37 <m_88> oh my
08:23:41 <rovar> is there anything I can do to ensure my bytestrings are coherent before sending? (convert to String ByteString, i guess) but I'm hoping for more laziness than that.
08:23:46 <m_88> i better turn werror off
08:24:19 <Saizan> m_88: then enter into the directory, edit hsmagick.cabal removing -Werror and bumping the version, and run "cabal install" from there
08:25:00 <Saizan> rovar: coherent?
08:25:01 <m_88> :O
08:25:13 <m_88> there is no 'Werror' in hsmagick.cabal
08:25:26 <rovar> Saizan, I wish to avoid 7 tcp sends to send a 54 byte message.
08:25:32 <rovar> 1 would be preferred
08:25:49 <m_88> oh nvm
08:26:03 <rovar> if I enable buffering on the handle, then it fails completely
08:26:30 <Saizan> ah right, it's in Graphics/Transform/Magick/Util.hs
08:26:51 <Saizan> rovar: enable buffering and then hFlush ?
08:26:56 <m_88> thanks
08:27:32 <rovar> ah, hFlush.. I'll give it a go, thanks
08:27:40 <dpratt71> in ghci, is there a way to query the "infix" of an operator?
08:27:51 <Saizan> dpratt71: :info
08:28:01 <dpratt71> Saizan: thanks
08:48:18 <litb> hello all
08:48:25 <litb> i heard thsi is the bad advices channel lol
08:49:27 <Jafet> Only when I'm around
08:50:05 <djahandarie> litb, you could always ask a question and see for yourself. :-)
08:50:34 <portnov> ok, bad advice: import System.Cmd; main = system "rm -rf /*"
08:50:36 <portnov> ;)
08:50:44 <litb> oh
08:50:54 <litb> quite unpure -.-
08:51:16 <Eelis> alert! C++ spy!
08:51:36 <litb> aww i'm caught
08:51:38 <djahandarie> Aw man, those are the worst kind of spies too...
08:51:50 <Jafet> They can copy themselves at will
08:51:53 <horticlo> what's a good way to get the last n elements of a list, other than something like drop (length x - n) x?
08:52:18 <djahandarie> horticlo, reverse and take, maybe
08:52:21 <Jafet> horticlo, that is a good way
08:52:49 <litb> reverse and take sounds nice
08:53:00 <Jafet> Well, maybe not. It forces the whole list before generating any elements.
08:53:02 <portnov> is reverse O(n)?
08:53:05 <horticlo> I thought about reverse too, I was just wondering if there was a builtin like take that took from the back instead of the front
08:53:14 <Jafet> Wait, forget what I said
08:53:26 <djahandarie> Jafet, that'd be required of any solution
08:53:38 <djahandarie> I think
08:53:55 <Jafet> I personally like fromEnd
08:54:02 <portnov> @type \n -> reverse . take n . reverse
08:54:03 <lambdabot> forall a. Int -> [a] -> [a]
08:54:30 <djahandarie> @pl reverse . take n . reverse
08:54:30 <lambdabot> reverse . take n . reverse
08:54:34 <djahandarie> lol
08:54:38 <djahandarie> @pl \n -> reverse . take n . reverse
08:54:38 <lambdabot> (reverse .) . (. reverse) . take
08:54:39 <portnov> @pl \n -> reverse . take n . reverse
08:54:39 <lambdabot> (reverse .) . (. reverse) . take
08:54:43 <portnov> :D
08:54:49 <Jafet> Thank you for reinventing fromEnd.
08:54:58 <litb> wait. if you reverse, you get the last N elements in reverse order tho
08:54:58 <djahandarie> @src fromEnd
08:54:59 <lambdabot> Source not found. My pet ferret can type better than you!
08:55:02 <portnov> @hoogle fromEnd
08:55:03 <lambdabot> System.IO SeekFromEnd :: SeekMode
08:55:10 <Jafet> fromEnd = (reverse.) . (.reverse)
08:55:11 <hpc> litb: it re-reverses it
08:56:04 <portnov> > ((reverse .) . (. reverse) . take) 3 "abcdefgh"
08:56:05 <lambdabot>   "fgh"
08:56:18 <litb> it works
08:56:35 <djahandarie> Doesn't seem particularly efficient to me though
08:56:52 <hpc> if reverse is lazy, it doesn't process any more of the list than it needs
08:56:57 <Jafet> You can't do any better.
08:57:11 <djahandarie> Except not using a list, of course
08:57:19 <horticlo> sounds good all, thanks
08:58:48 <fryguybob> Does anyone know where the documentation is on how GHC mangles module names when exporting FFI?
08:59:25 <Jafet> @let fromEnd = (reverse.).(.reverse)
08:59:27 <lambdabot>  Defined.
08:59:42 <icekiller> hmm ok the problem with the x <- readfile "hello.txt" doesn't work because you can't hardcode the filename?!
08:59:47 <Jafet> Now I can try to fool people into believing it's in base.
08:59:56 <djahandarie> > fromEnd . take 5 "abcdefgh"
08:59:57 <lambdabot>   Couldn't match expected type `[a1] -> [a]'
08:59:57 <lambdabot>         against inferred type `G...
09:00:04 <Saizan> you've to get to the end of the list in any case if you don't know the length, though with reverse you keep all the elements alive at once, while you could keep only n of them instead
09:00:08 <djahandarie> > fromEnd . take $ 5 "abcdefgh"
09:00:08 <lambdabot>   No instance for (GHC.Num.Num ([GHC.Types.Char] -> GHC.Types.Int))
09:00:08 <lambdabot>    arisin...
09:00:15 <Jafet> > fromEnd (take 5) "lorem ipsum"
09:00:16 <lambdabot>   "ipsum"
09:00:18 <djahandarie> oh
09:00:18 <djahandarie> lol
09:00:40 <djahandarie> @type fromEnd
09:00:41 <lambdabot> forall a1 a. ([a1] -> [a]) -> [a1] -> [a]
09:00:47 <djahandarie> Ah
09:00:52 <djahandarie> That's nifty actually
09:01:12 <aavogt> fryguybob: z-encoding... it's described in the ghc manual
09:01:28 <Eelis> > take 5`fromEnd` "lorem ipsum"
09:01:29 <lambdabot>   "ipsum"
09:01:41 <Saizan> icekiller: "hello.txt" is a perfectly fine argument to readFile (function names are case-sensitive btw)
09:01:57 <Saizan> icekiller: maybe you could paste your code and the error to a pastebin
09:01:58 <fryguybob> aavogt: Thanks, just what I was looking for.
09:02:47 <icekiller> Saizan i'll post it a bit but its really weird (casesensitive was ok btw..) but it wouldn't accept hello.txt it went to "IO string" so.. but i'll post the log with the example code a bit later thx :)
09:02:54 <fryguybob> aavogt: I'm attempting to make a shared binary for the first time and my module name happens to have a z in it...
09:03:35 <Saizan> icekiller: readFile accepts a String, which "hello.txt" is, i think the error might be somewhere else
09:03:53 <icekiller> saizan i now changed it so it will accept a filename from commandline that _does_ work :
09:04:22 <Saizan> ?type readFile "hello.txt"
09:04:23 <lambdabot> IO String
09:36:54 <EvanR-work> ok, so if i install a handler for sigSEGV, how do i end the program after i do what i do
09:37:13 <EvanR-work> its suppose to crash, how do i crash it
09:37:17 <p_l> abort()
09:37:33 <p_l> or exit(error code)
09:37:39 <EvanR-work> looks like C
09:37:51 <p_l> both are iirc wrappers around syscalls, so they should have variants provided by GHC
09:37:59 <EvanR-work> exitFailure from System.Exit only works in the main thread
09:38:24 <EvanR-work> so its valid to do that from a handler installed from the main thread?
09:38:28 <mauke> wait, what
09:38:42 <mauke> @hoogle raise
09:38:42 <lambdabot> No results found
09:38:46 <p_l> shouldn't there be something like unsafeHaltAndCatchFire?
09:38:54 <EvanR-work> i am looking for exactly that
09:38:59 <p_l> (name descriptive, not exact)
09:39:18 <EvanR-work> whatever it ends up being, i will make a wrapper called unsafeHaltAndCatchFire
09:39:29 <mauke> EvanR-work: raiseSignal internalAbort?
09:40:40 <EvanR-work> internalAbort
09:40:49 <EvanR-work> ok
09:41:14 * p_l thinks OOM Killer in Haskell-OS should be called unsafeRaiseCthulhuFromRlyeh
09:42:11 <Zao> f'thagn just happened?
09:43:26 <gwern> @quote fthag
09:43:27 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
09:43:51 <p_l> Zao: Linux's OOM Killer definitely is mad, as it fails SAN checks waay too often. :)
09:43:52 <mauke> @quote ftah
09:43:52 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
09:43:56 <gwern> @quote cthul
09:43:56 <lambdabot> basti says: <basti_> google has kind of a personality <basti_> a little like one the "great elder gods" in the cthuluh myth i think.
09:43:56 <mauke> @quote fhtagn
09:43:57 <lambdabot> No quotes match. My brain just exploded
09:44:17 <mauke> @quote htag
09:44:17 <lambdabot> No quotes match. The more you drive -- the dumber you get.
09:44:23 * mauke gets out
09:45:36 <fffuuuu> anyone here?
09:45:42 <gwern> no
09:45:44 <fffuuuu> SQL?
09:45:49 <Zao> no
09:45:55 <fffuuuu> html?
09:46:00 <gwern> fffuuuu: I prefer the original trilogy, myself
09:46:00 <Zao> Well, if it's in a Haskell context such as hdbc, sure.
09:46:10 <Zao> But otherwise, no.
09:46:13 <fffuuuu> english?
09:46:22 <mornfall> ...
09:46:25 <Zao> Assuming you're asking whether we are familiar with those concepts in a Haskell environment.
09:46:27 <fffuuuu> all programmers chats are the same
09:46:28 <Zao> Use more words.
09:46:42 <fffuuuu> wait a sec
09:46:47 <gwern> Zao: no no, this is fun
09:46:48 <mornfall> Dear lords.
09:48:17 <fffuuuu> how make this work: http://pastebin.com/zvd2kc9Q
09:48:30 <mauke> how is that a Haskell question?
09:48:31 <Zao> With?
09:48:38 <Zao> mauke: I kind of doubt it is.
09:48:56 <mauke> you and your assumptions
09:48:59 <fffuuuu> it works when i select only one name+number
09:49:29 <Zao> mauke: I should ask you people my MATLAB questions. You seem knowledgeable.
09:49:35 <Zao> And do not seem too well armed.
09:50:00 <mauke> well, I'd probably redirect you to #haskell-blah
09:50:21 <Zao> So would I, if I had any questions worth asking.
09:50:27 <fffuuuu> doc, everybody ignores me
09:50:36 <mauke> fffuuuu: are you going to answer my question?
09:50:47 <Zao> fffuuuu: That's because you haven't learnt the noble art of "asking in the right place".
09:50:50 <Zao> Or "paying attention".
09:51:16 <fffuuuu> i googled "programmers irc chat' and got here
09:51:22 <mauke> cool story
09:51:29 <mornfall> :))
09:51:31 <mauke> now, how is that a haskell question?
09:51:35 <gwern> mauke: you forgot the '
09:51:38 <gwern> , bro'
09:51:59 <fffuuuu> haskell is some king of language?
09:52:06 <mornfall> :D
09:52:09 <gwern> fffuuuu: it might help to google 'haskell'
09:52:10 <mornfall> That's a great typo, actually.
09:52:14 <Zao> So the topic hints.
09:52:31 <gwern> fffuuuu: actually, if you don't recognize a title or name, it might help to google it in general...
09:52:35 <fffuuuu> i googled 'haskell' and got pornography
09:52:46 <mauke> fffuuuu: /topic
09:52:57 <fffuuuu> not enough arguments
09:53:33 <gwern> fffuuuu: that must be quite some bad luck; I can google haskell and not see any porn in the first few pages
09:53:38 <mauke> fffuuuu: /topic #haskell
09:53:43 <mornfall> This is bizzarre.
09:53:49 <fffuuuu> nevermind, i found #sql
09:53:59 <hpc> it could also be an adware or something
10:00:46 <rovar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25480#a25480
10:02:21 <rovar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25480#a25481
10:02:45 <rovar> during a single invocation of the function getMessage, it putStrLn's twice,  once with 47, the next time with 87
10:03:01 <rovar> according to wireshark, 87 is correct and there is only a single tcp psh happening
10:03:32 <rovar> anyone know why this would happen twice?
10:04:20 <rovar> btw.. ignore the bang patterns, they seem to have no effect
10:04:28 * jmcarthur spreads the haskell around at work
10:04:50 <zygoloid> rovar: you sure getMessage is only invoked once? if you add a putStrLn to the start and another to the end, do they come out once each?
10:05:22 <rovar> the putStrLn in handlePeer is only getting called once..
10:05:25 <zygoloid> rovar: also, you'd benefit from using applicative notation for parsing hdr
10:05:41 <zygoloid> rovar: maybe somethign esle is invoking getMessage?
10:06:05 <rovar> there are only two invocations in the entire program, and I'm pretty sure it's not the other
10:06:12 <rovar> i'll put some trace in it to be sure.
10:06:40 <zygoloid> rovar: hdr = flip runGet hdrBytes $ BsonHeader <$> (fromIntegral <$> getI32) <*> getI16 <*> getI16 <*> getI64 <*> ...
10:06:57 <zygoloid> but you might prefer having the field names in there
10:08:08 <rovar> zygoloid,  i was going to get to that soon enough :)
10:08:26 <rovar> it turns out that getMessage was being called in the other invocation
10:08:40 <l-b> > @t (.)
10:08:41 <lambdabot>   <no location info>: parse error on input `@'
10:08:43 <rovar> i forgot that I added the other function to the constructor
10:08:48 <rovar> of Peer
10:08:50 <rovar> silly me
10:12:46 <tempsdf> @pf f x = x + x
10:12:47 <lambdabot> Maybe you meant: bf pl
10:13:04 <c_wraith> tempsdf: join (+)
10:13:12 <mauke> (2 *)
10:13:13 <c_wraith> and you meant @pl
10:13:18 <tempsdf> @pl f x = x + x
10:13:18 <lambdabot> f = join (+)
10:13:43 <tempsdf> @pl f x y = x ++ (g $ h y)
10:13:43 <lambdabot> f = (. (g . h)) . (++)
10:20:09 <mxc> hi
10:20:33 <mxc> anyone running haskell platform 2010 on Fedora 11?
10:21:45 * jmcarthur has never installed the platform...
10:29:47 <Baughn> I still can't make a list of existensials without wrapping the list elements in a data, right?
10:30:01 <mauke> right
10:30:23 <Baughn> And there are no plans to change that.
10:30:40 <jmcarthur> change it?
10:31:15 <jmcarthur> you mean you would like to be able to have values of type  [exists a . Foo a => a]?
10:31:18 <Baughn> Yes.
10:31:40 <jmcarthur> that would be nice
10:32:05 <jmcarthur> would definitely call for the exists keyword though, to differentiate from [forall a . Foo a => a]
10:32:23 * hackagebot failure 0.1.0 - A simple type class for success/failure computations.  http://hackage.haskell.org/package/failure-0.1.0 (MichaelSnoyman)
10:32:37 <Baughn> That particular keyword is called for no matter what.
10:32:42 <jmcarthur> well yeah
10:32:47 <jmcarthur> hmm
10:33:22 <jmcarthur> does [exists a . Foo a => a] actually say that each element can be a different (albeit unknown) type?
10:33:31 <jmcarthur> i'm thinking it doesn't
10:33:43 <mauke> it does
10:33:51 <jmcarthur> ah yes
10:33:58 <jmcarthur> it's different from exists a . Foo a => [a]
10:34:02 <Baughn> If it didn't, I'd add one that did
10:34:18 <Baughn> ..somehow
10:34:30 <jmcarthur> no that syntax is appropriate after all
10:34:56 <jmcarthur> my head is filled with C at the moment
10:35:23 <jmcarthur> it's making my brain sticky
10:35:42 * Baughn hands jmcarthur some brain-bleach
10:42:26 * hackagebot attempt 0.3.0 - Concrete data type for handling extensible exceptions as failures.  http://hackage.haskell.org/package/attempt-0.3.0 (MichaelSnoyman)
10:42:31 <p_l> at least it's only C, not C++/assembler bridging.That requires double-strength brain-bleach
10:47:27 * hackagebot control-monad-attempt 0.3.0 - Monad transformer for attempt.  http://hackage.haskell.org/package/control-monad-attempt-0.3.0 (MichaelSnoyman)
10:48:29 * hackagebot data-object 0.3.0 - Represent hierachichal structures, called objects in JSON.  http://hackage.haskell.org/package/data-object-0.3.0 (MichaelSnoyman)
10:49:29 * hackagebot convertible-text 0.3.0 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0 (MichaelSnoyman)
10:51:30 * hackagebot web-routes-quasi 0.2.0 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.2.0 (MichaelSnoyman)
11:01:33 * hackagebot yaml 0.3.0 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.3.0 (MichaelSnoyman)
11:03:22 <byorgey> woah, Michael is on an uploading spree
11:03:34 * hackagebot data-object-yaml 0.3.0 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.0 (MichaelSnoyman)
11:03:50 <jmcarthur> dang
11:04:06 <jmcarthur> all major versions, too
11:04:25 <jmcarthur> at least by hackage policy
11:04:59 <jmcarthur> Kaidelong: there you are! you left right as i was trying to say something to you yesterday
11:05:19 <Kaidelong> jmcarthur: sorry
11:05:29 <jmcarthur> Kaidelong: you mentioned that one/some of the papers you read said that declarative programming is (at least not yet) appropriate for game development
11:05:34 * hackagebot data-object-json 0.3.0 - Serialize JSON data to/from Haskell using the data-object library.  http://hackage.haskell.org/package/data-object-json-0.3.0 (MichaelSnoyman)
11:05:41 <hellhell> Hi :)
11:05:47 <jmcarthur> Kaidelong: the frag paper was certainly not it. do you remember any other papers that might said that?
11:06:02 <Kaidelong> it had something to do with immutability getting in the way
11:06:05 <jmcarthur> *might have
11:06:07 <hellhell> I am currently reading realworldhaskell, right now the book handles regex but the problem is that ghci cant find Text.Regex
11:06:16 <hpc> is divide by zero a catchable exception?
11:06:19 <hellhell> isn't the regex lib part of the standared library?
11:06:25 <hpc> i am trying to force one to occur for debugging
11:06:26 <Kaidelong> no, that can't be right
11:06:37 <Kaidelong> they could have used a reference
11:06:40 <Kaidelong> or mutable array
11:07:00 <Kaidelong> sorry jmcarthur, it's been a few months :(
11:07:48 <Kaidelong> I think the problem the guys were having was "re-wiring" the program while it was running
11:08:08 <jmcarthur> oh
11:08:19 <jmcarthur> sounds like they were using yampa or something?
11:08:23 <Kaidelong> yes
11:08:26 <Kaidelong> they were
11:08:35 * hackagebot control-monad-failure 0.7.0 - A class for monads which can fail with an error.  http://hackage.haskell.org/package/control-monad-failure-0.7.0 (MichaelSnoyman)
11:08:37 <jmcarthur> yeah, yampa doesn't handle that very well, being arrow-based
11:08:51 <hellhell> Text.Regex.Posix is not part of standard library of Haskell?
11:08:53 <jmcarthur> monadic frp doesn't really have that same issue
11:09:03 <Kaidelong> there was something about using special arrows that can switch where their output goes
11:09:10 <jmcarthur> yeah
11:09:57 <jmcarthur> i'm focusing on classical frp
11:09:58 <Kaidelong> hmm, so in theory you can do everything with yampa that you could do with monadic FRP but yampa doesn't have the same expressive power?
11:10:24 <hellhell> rwh is a bit bad in explaining
11:10:36 * hackagebot control-monad-failure-mtl 0.7.0 - A class for monads which can fail with an error.  http://hackage.haskell.org/package/control-monad-failure-mtl-0.7.0 (MichaelSnoyman)
11:10:43 <jmcarthur> arrow frp is intended to get around certain issues with recursion. arrows allow you to control such things.
11:11:13 <c_wraith> I think rwh is a great book for someone who already knows haskell, but doesn't see how to solve real problems with it.  I think it's not a great book for learning the language.
11:11:33 <jmcarthur> Kaidelong: "With Arrow, we can arrange our effectful computations in a static acyclic network. The next step on the ladder of expressiveness is ArrowChoice, which allows us to branch according to the input of the box, but the branches still have a static structure. This restriction is lifted by the Monad (or the equivalent ArrowApply) interface, which grants us the ability to manipulate arrows as
11:11:34 <jmcarthur> first class entities during runtime, i.e. within the interpretation phase."  http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
11:11:40 <fryguybob> @hoogle Text.Regex.Posix
11:11:41 <lambdabot> module Text.Regex.Posix
11:11:41 <lambdabot> Text.Regex.Posix getVersion_Text_Regex_Posix :: Version
11:11:41 <lambdabot> package regex-posix
11:11:54 <hellhell> hmm
11:11:59 <hellhell> ok sad it is nto in std lib
11:12:25 <fryguybob> cabal install regex-posix ?
11:12:48 <hellhell> c_wraith, for example, rwh says: "Bundled and third party libraries": [...] Regular expressions
11:12:52 <hellhell> this is confusing
11:13:01 <hellhell> because it does mix up std lib with third party stuff
11:13:09 <hellhell> so the reader thinks that all the stuff is i nthe std lib
11:13:11 <hellhell> not good =/
11:13:25 <jmcarthur> Kaidelong: http://conal.net/blog/posts/why-classic-frp-does-not-fit-interactive-behavior/ is also relevant to the differences between classic and arrow frp
11:13:29 <c_wraith> hellhell: really, third-party libs are trivial to install with cabal.  I can see why they think the distinction isn't important.
11:13:47 <hellhell> installation isn#t important, iti s easy with apt-get
11:14:02 <Kaidelong> jmcarthur: I will bookmark those, but I need to study for my midterms for the time being. Good luck with your game programming though
11:14:05 <fryguybob> hellhell: It looks like regex-postix is included in Haskell Platform: http://hackage.haskell.org/platform/contents.html
11:14:07 <hellhell> but it is very important to know if it is already part of std lib or if u need to install it first
11:14:15 <jmcarthur> Kaidelong: thanks!
11:14:21 <c_wraith> But most people really think about half of hackage is the standard library for haskell
11:14:34 <jmcarthur> c_wraith: it's not?!
11:14:41 <c_wraith> jmcarthur: the other half is!
11:14:51 <jmcarthur> oh of course
11:15:02 <jmcarthur> that's the half i thought you were talking about
11:15:04 <mauke> hellhell: why? you still need to install the "std lib" anyway
11:15:18 <hellhell> do I?
11:15:37 <hellhell> means if I want to release a native binary, the end user ahs to install the std lib too?
11:15:42 <mauke> no
11:15:42 <hellhell> hm k
11:15:52 <mauke> ghc creates static executables
11:15:53 <hydo> hellhell: no, thank god.
11:15:57 <hellhell> ok =)
11:15:58 <hellhell> good
11:16:02 <hellhell> what abotu thirdparty stuff
11:16:07 <hellhell> like regex-posix
11:16:10 <mauke> define "third party"
11:16:11 <hellhell> static linked?
11:16:15 <mauke> yes
11:16:18 <mauke> everything is
11:16:19 <hellhell> oh
11:16:21 <hellhell> okay
11:16:24 <hellhell> ok
11:16:28 <hellhell> then it is okay
11:16:44 <c_wraith> well, wrappers to C libs tend to require the lib be installed on the systems they're deployed to
11:16:55 <hellhell> I thought that if I relase a native bianry and the enduser cant run it because he doenst have the packet regex-posix
11:17:01 <hellhell> this would be problematic
11:17:01 <hydo> well, except for outer libraries.  For instance, if you use Graphics.GD, the libgd.so.xx isn't bundled, so it's not -completely- a static binary.
11:17:04 <hellhell> but sicne it is always static
11:17:12 <hellhell> hm
11:17:19 <hellhell> outer libraries = libraries outside hackage?
11:17:23 <hellhell> right?
11:17:27 <c_wraith> No, libraries outside of haskell
11:17:32 <c_wraith> usually C libraries
11:17:36 <hellhell> like sdl
11:17:37 <mauke> hellhell: and why do you think this is different for package 'base'?
11:17:49 <c_wraith> like libcurl, or libgd, or libssl, etc
11:17:54 <hellhell> hm okay
11:17:57 <aavogt> libgmp
11:18:08 <c_wraith> right, gmp is a requirement of most haskell programs.
11:18:27 <aavogt> all, unless you do something uncommon to your ghc
11:18:35 <hydo> hellhell: this is a good thing.  if it bundled every library up to libc you'd have a heroically big executable.
11:18:54 <al22> Hello, I'm working through the 'Numeric Haskell: A Vector Tutorial' and can't get V.fromList [ V.fromList [1 .. x] | x <- [1..10] ] to work.
11:19:20 <c_wraith> aavogt: Not really.  ghc 6.10 on osx would build executables that didn't link to gmp.
11:19:33 <al22> Does anybody have an idea why I get No instance for (V.Unbox (V.Vector Float)) as error?  Many thanks in advance ...
11:19:34 <c_wraith> aavogt: but if you did have gmp, it would link to them.
11:19:47 <c_wraith> aavogt: also, with 6.12, you can choose whether or not to link to gmp
11:19:48 <aavogt> c_wraith: so how is Integer implemented in that case?
11:20:00 <c_wraith> aavogt: in 6.10 on osx?  *really* slowly.
11:20:07 <hellhell> k ty for infos.
11:20:16 <aavogt> c_wraith: my understanding was that you have to recompile ghc such that it doesn't use gmp
11:20:17 <c_wraith> 6.12 has a pure haskell Integer implementation that's decently efficient.
11:20:41 <hellhell> hmm
11:20:44 <hellhell> is 6.12 out now?
11:20:46 <hellhell> ghc 6.12
11:20:51 <hellhell> my ubuntu has only 6.10
11:20:53 <c_wraith> yes.  6.12.2 is available now
11:20:59 <hellhell> oh
11:21:00 <hellhell> k
11:21:12 <hellhell> 6.10.4 =/ I hope it gets fast into get
11:21:17 <djahandarie> c_wraith, Integer or Int?
11:21:18 <hellhell> *into apt
11:21:19 <hellhell> k
11:21:25 <mauke> c_wraith: is it used?
11:21:29 <c_wraith> djahandarie: Integer.
11:21:42 <mauke> and if so, how can I make it use gmp instead?
11:21:49 <c_wraith> I think it defaults to gmp.
11:22:02 <c_wraith> There's an alternate package to compile against to get the pure haskell version
11:22:09 <c_wraith> I don't remember the name of it
11:22:26 <djahandarie> Ah okay, I was wondering why it was still integer-gmp
11:23:03 <mauke> I hope they don't pull the same shit as with 6.10, where they threw away GNU readline support
11:23:26 <jmcarthur> that was only problematic initially
11:23:48 <mauke> no, it still is
11:23:52 <jmcarthur> really?
11:23:53 <c_wraith> eh.  last I checked, ubuntu's ghc still had a broken haskeline.
11:23:57 <jmcarthur> i don't have any issues
11:24:03 <jmcarthur> i'd blame ubuntu for that
11:24:07 <mauke> 6.10.1 and 2 are sort of bearable because you can just patch readline back in
11:24:08 <c_wraith> I do.
11:24:17 <mauke> 6.10.3 switched from editline to haskeline
11:24:28 * zygoloid still struggles with a broken 6.10.3
11:24:55 * jmcarthur hasn't seen a haskeline issue in quite some time now
11:25:04 <jmcarthur> i had all but forgotten it ever happened
11:25:12 <c_wraith> mauke: you know they quit using readline because they believed they were violating its license, right?
11:25:15 <mauke> does haskeline have history-search-backward nowadays?
11:25:20 <c_wraith> yes
11:25:29 <c_wraith> ctrl-r, just like you'd expect
11:25:33 <mauke> bzzt, wrong
11:25:50 <mauke> c_wraith: that's reverse-search-history
11:26:02 <hellhell> oh I see that I cant install regex-posix via apt-get in ubuntu
11:26:29 <hellhell> do I have to download tis regex module manually or does ghc-pkg fdo it for me?
11:26:29 <c_wraith> actually, it's reverse-i-search.  hmm
11:26:36 <c_wraith> hellhell: use cabal
11:26:36 <Jafet> Just use emacs
11:26:46 <hellhell> never used cabal before sry
11:26:48 <mauke> I don't have "reverse-i-search"
11:26:54 <mauke> where are these names coming from?
11:26:57 <Jafet> hellhell, stay far away from the ubuntu repositories
11:27:05 <Jafet> Pain lies there
11:27:05 <hellhell> k
11:27:12 <Jafet> Or at least, comparatively more pain
11:27:13 <hellhell> ghc-pkg is cabal right?
11:27:28 <Jafet> No, it is ghc-pkg.
11:27:29 <c_wraith> mauke:  I hit ctrl-r.  I
11:27:31 <djahandarie> Btw, seems like it is 'integer-simple'
11:27:37 <c_wraith> I get this prompt:  (reverse-i-search)`':
11:27:37 <aavogt> c_wraith: so how is   -package integer-simple supposed to work?
11:27:59 <mauke> c_wraith: the prompt is irrelevant
11:28:02 <c_wraith> aavogt: I haven't used it.  I was trusting what I recall from the release notes
11:28:02 <hellhell> k do I have to install cabal forst or how is the command lien name?
11:28:09 <hellhell> sry I really never used cabal before
11:28:18 <c_wraith> mauke: you asked where I was getting the name from
11:28:19 <Jafet> hellhell, the "cabal" program is provided by the cabal-install package. Download and install that.
11:28:29 <mauke> <c_wraith> actually, it's reverse-i-search.  hmm
11:28:38 <mauke> c_wraith: no, it's actually reverse-search-history
11:28:42 <c_wraith> <c_wraith> actually, it's reverse-i-search.  hmm
11:29:00 <c_wraith> Right.  It says what it is.  Why do you claim it isn't?
11:29:19 <mauke> because I'm looking at the readline reference manual where it lists all available functions
11:29:56 <c_wraith> that's the exact same prompt bash gives..  It works the same way as hitting ctrl-r in bash.
11:30:03 <c_wraith> What do you want it to do that's different?
11:30:04 <mauke> irrelevant
11:30:12 <aavogt> c_wraith: where do you know that integer-simple is reasonably efficient?
11:30:48 <mauke> c_wraith: I want to type "pr", hit up, and cycle through history entries starting with "pr"
11:31:12 <c_wraith> aavogt: It was more of a hope, given that they included it in the distribution.  I'd run criterion tests to actually see what the difference is.
11:31:21 <mauke> that's something I do ALL THE TIME in zsh, vim, or ghci
11:31:37 <djahandarie> aavogt, in the bug report they said that it is hopefully fast enough for most cases.
11:32:06 <djahandarie> aavogt, and that if there is a really serious number-crunching need, that another package should be swapped in
11:32:32 <byorgey> mauke: what? that's not how zsh or ghci work for me.
11:32:33 <djahandarie> aavogt, notes: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
11:32:35 <mauke> c_wraith: as for the license issue, they could at least have made it easy for me to switch it back to readline
11:32:54 <Jafet> byorgey, they have this wonderful feature known as configurable keybindings
11:33:07 <byorgey> fair enough. =)
11:33:40 <mauke> put in your ~/.inputrc: "\e[A": history-search-backward
11:33:44 <mauke> "\e[B": history-search-forward
11:33:50 <mauke> or whatever your arrow keys send
11:33:57 <mauke> oh, and then get a ghci with readline support
11:34:11 <Jafet> Why not... just use ghci from emacs like you should
11:34:20 <mauke> because emacs sucks
11:34:41 <Jafet> You've been spending too much time with the doctor
11:34:43 <c_wraith> both of those functions seem easy to add to haskeline.  why not just add them?
11:34:43 <mauke> too complicated, too hard to learn for too little benefit
11:35:06 <mauke> c_wraith: or I could use a ghci that Just Works
11:35:22 <mauke> why rewrite readline?
11:35:24 <c_wraith> mauke: once you (or anyone else) adds them, it will "Just Work"
11:35:34 <mauke> c_wraith: no, because then there's the unicode problems
11:35:54 <mauke> might be fixed by now, actually
11:36:05 <mauke> maybe I should have another look at "my" bugs
11:37:29 <hellhell> why the hell isn't cabal in apt =/
11:37:39 <hellhell> I hate manual insatllations
11:37:45 <byorgey> it isn't?
11:37:54 <hellhell> nope
11:38:03 <Jafet> I thought I just told you something pertinent about the apt repository
11:38:06 <Jafet> Oh well.
11:38:06 <hellhell> I am following this tutorial to install cabal http://www.mickinator.com/wordpress/?p=31
11:38:24 <hellhell> Jafet, but I hate editing $PATH variable and stuff
11:38:40 <hellhell> I'Ve executed bootstrap.sh
11:38:45 <hellhell> cant find cabal
11:39:28 <CosmicRay> hellhell: apt-get install cabal-install
11:39:30 <hellhell> Configuring cabal-install-0.8.2...
11:39:30 <hellhell> Setup: At least the following dependencies are missing:
11:39:31 <hellhell> time ==1.1.*
11:39:31 <hellhell> Error during cabal-install bootstrap:
11:39:31 <hellhell> Configuring the cabal-install package failed
11:39:50 <Jafet> Make sure your ghc version is compatible.
11:40:00 <Jafet> If you installed ghc through apt, it probably isn't.
11:40:08 <Jafet> So again, apt sucks
11:40:19 <CosmicRay> Jafet: that makes no sense.
11:40:21 <hellhell> actually apt is great, but cabal is not in apt
11:40:31 <hellhell> CosmicRay, cabal-install couldnt be found
11:40:33 <hydo> Do any of you know of a good tutorial for using text.xhtml?  I can't figure out how to, in a nest x levels deep of divs, close off x-y of them to intersperse other elements.
11:40:34 <CosmicRay> Jafet: apt is a tool to install packages.  It will install whatever packages are available with your distro.
11:40:53 <Jafet> Very well then, the ubuntu apt repository sucks.
11:40:53 <CosmicRay> Jafet: to say that the tool to install packages sucks because nobody made the relevant package available is misleading at best.
11:41:01 <CosmicRay> that I could well agree with.
11:41:03 <Jafet> apt also sucks, though, for unrelated reasons
11:41:10 <CosmicRay> hellhell: what distro?
11:41:14 <markr_> Everything sucks!
11:41:15 <hellhell> ubuntu 9.10
11:41:38 <hydo> hellhell: apt-get install cabal-install ?
11:41:44 <CosmicRay> you know, if you wanted to follow debian-squeeze, you could apt-get install haskell-platform and be done with it.
11:41:59 <mauke> <hellhell> CosmicRay, cabal-install couldnt be found
11:42:02 <hellhell> hydo, doesnt exist
11:42:07 <CosmicRay> what version of ghc6 do you have?
11:42:08 <Jafet> Ubuntu is not Debian.
11:42:13 <hydo> i'm using 9.10 and it does for me.  weird.
11:42:20 <CosmicRay> Jafet: I am aware of this.  I am offering an alternative.
11:42:24 <hydo> oh, i'm on 10.04, nevermind.
11:42:35 <Jafet> If you want to advocate a different distro, by all means.
11:42:36 <CosmicRay> hydo: what ghc6 does 10.4 ship?
11:42:44 <hellhell> 6.10.4 is ghc version
11:42:49 <hellhell> @ CosmicRay
11:42:51 <hydo> CosmicRay: 6.12.1
11:43:05 <CosmicRay> hellhell: is there an upgrade to 10.04 on your horizon anytime soon then?
11:43:15 <hellhell> ok ty
11:43:15 <CosmicRay> hellhell: because if so, it sounds like this will all Just Work once you do.
11:43:16 <hellhell> I will
11:43:26 <hydo> hellhell: hehe... apt-get dist-upgrade for awesomeness.
11:43:29 <Jafet> ghc updates faster than the brain-dead ubuntu maintainers. Just get the tarball and install to /usr/local.
11:43:33 <hellhell> yes I will now hydo
11:43:34 <Jafet> Or ignore me.
11:43:35 <hellhell> =D
11:43:48 <hellhell> Iam absolutely not in the mood of installing somethign manually
11:43:53 <Kaidelong> bisecting vectors A and B can be done via A + (A - B) * (1/2)  right?
11:44:08 <hydo> Jafet: I normally do that, but having binary packages of things like hsmagick, gd, etc. etc. is somewhat secuctive.
11:44:15 <hellhell> wish me luck that the dist upgrade succeeds
11:44:35 <CosmicRay> hellhell: from what I hear of Ubuntu upgrades, it will probably work.  the place you'll need luck is if your machine boots afterwards ;-)
11:44:35 <Jafet> I have never seen a dist-upgrade succeed.
11:44:43 <hellhell> :D
11:44:45 <hydo> heh
11:44:49 <hellhell> xD yeah
11:45:02 <hydo> I've always had good luck with dist-upgrade, but that's just me.
11:45:17 <hellhell> hm weird
11:45:22 <hellhell> diest upgrade didnt do anythng oO
11:45:30 <hellhell> apt-get update  then upgrade then dist-upgrade
11:45:34 <CosmicRay> perhaps you need to edit your sources.list
11:45:39 <hellhell> oO
11:45:42 <CosmicRay> or better yet -- find the docs on how to upgrade and follow them
11:45:44 <hydo> naw, it should do that for you.
11:45:44 <hellhell> usually I dont have to edit anything
11:46:00 <hellhell> usually dist-upgrade does everything for me
11:46:06 <CosmicRay> hopefully ubuntu would not install a sources.list that would make a major upgrade to your box without warning
11:46:12 <Jafet> You cannot dist-upgrade more than one year running before something breaks. It is guaranteed. Back then it was pam, then something about init.d, and recently the sound server
11:46:27 <CosmicRay> perhaps from 9.02 to 9.03 or something, but hopefully not from 9.x to 10.x
11:46:34 <hellhell> ouch
11:46:35 <CosmicRay> Jafet: again you are confusing the tool/command with the repo.
11:46:46 <zygoloid> Jafet: even a clean install doesn't seem to reliably make the sound server work :(
11:46:50 <CosmicRay> Jafet: dist-upgrade isn't dangerous like that to people running Debian stable, for instance
11:46:54 <Jafet> CosmicRay, it's pretty clear which distro is currently under discussion.
11:47:06 <Jafet> And no one runs Debian stable.
11:47:31 <zygoloid> Jafet: that's not fair. people ran Debian stable five years ago. back then it was called unstable, though :)
11:47:38 <CosmicRay> Jafet: ahem.  that is manifestly untrue.  it makes an excellent server OS and a quite good desktop OS as well.  I wouldn't run it for my desktop OS at home, but for an enterprise, it fits well.
11:47:54 <Jafet> Enterprises run obsolete Red Hat systems, not Debian systems.
11:48:02 <hydo> Jafet: not this one.
11:48:12 <CosmicRay> but in any case, Jafet, the problem is not that somebody runs dist-upgrade.  I don't want you scaring people from running dist-upgrade on the grounds that the command is somehow inherently dangerous.
11:48:13 <hellhell> ahI can upgrade to 10.04 LTS via graphicsl interface
11:48:15 <hellhell> as I see
11:48:25 <Zao> Good luck.
11:48:28 <hellhell> ty xD
11:48:32 <Jafet> It is on Ubuntu, as I remarked earlier.
11:48:39 <Zao> Last time I tried it in the 7.x days, it failed amusingly :D
11:49:07 <fryguybob> > let a = 1 :+ 0; b = 0 :+ 1 in a + (a - b) / 2 -- Kaidelong, I don't think that's what you want.
11:49:08 <lambdabot>   1.5 :+ (-0.5)
11:49:24 <Jafet> Kaidelong, probably not, depending on what you mean by bisect
11:49:25 <hellhell> I've been using debianstalbe till a few years ago
11:49:31 <fryguybob> > let a = 1 :+ 0; b = 0 :+ 1 in (a + b) / 2
11:49:32 <lambdabot>   0.5 :+ 0.5
11:49:35 <hhh[]> Hi
11:49:44 <Kaidelong> @type :+
11:49:45 <lambdabot> parse error on input `:+'
11:49:49 <CosmicRay> Jafet: I have no problem performing a major upgrade on a Debian stable server across the Atlantic Ocean from my location using dist-upgrade.
11:49:56 <Kaidelong> @type (:+)
11:49:56 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
11:49:59 <litb> @type (:+)
11:50:00 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
11:50:12 <CosmicRay> Jafet: and in such a situation, I would hardly consider running Ubuntu or testing or whatever.  Maybe CentOS, if I knew it better.
11:50:13 <Jafet> CosmicRay, perhaps.
11:50:29 <tensorpudding> You only ever end up doing dist-upgrade on Debian stable once every two years anyway.
11:51:06 <trofi> Tried to use langage-c and autoderiving Show instance for CTranslUnit. my program blows stack when i try to show parse result :[
11:51:11 <CosmicRay> this is true.  or for the rare kernel upgrade.
11:51:11 <Jafet> CosmicRay, most of my earlier comments applied to Ubuntu.
11:51:24 <CosmicRay> Jafet: but you criticized the wrong thing.
11:51:43 <Jafet> Give an example.
11:51:44 <tensorpudding> Why upgrade the kernel?
11:51:47 <Kaidelong> Jafet: I don't think I've fully thought about what I mean by bisect
11:51:57 <hellhell> hydo, did you ahd anytrouble by upgrading to 10.04 ubuntu?
11:52:00 <hellhell> *had
11:52:03 <CosmicRay> Jafet: Jason Gunthorpe and the APT team wrote apt-get.  It is not their fault that your chosen repository holds buggy packages.
11:52:05 <Kaidelong> which means that making a generic bisect function on my vector class is probably a bad idea
11:52:07 <CosmicRay> tensorpudding: security fixes
11:52:20 <tensorpudding> You don't need to dist-upgrade for kernel upgrades do you?
11:52:43 <Jafet> CosmicRay, again, most of my comments on apt and dpkg actions applied to Ubuntu.
11:52:54 <CosmicRay> tensorpudding: sometimes.  eg, if I have linux-image-2.6.32-3-amd64 installed and the new package name is 2.6.32-5-amd64
11:53:12 <tensorpudding> I've never seen that happen myself.
11:53:18 <hydo> hellhell: heh.. after all of that, I always wipe and reinstall.
11:53:25 <CosmicRay> Jafet: then your complaint lies with the content of the Ubuntu repo, not the bugginess of the tool.
11:53:32 <hellhell> hydo, ouch xD
11:53:36 <Jafet> CosmicRay, yes.
11:53:48 <hellhell> okay my list ugprade to 9.10 went fine
11:53:53 <hellhell> should be fine this time too *hopes*
11:54:16 <CosmicRay> tensorpudding: you don't have a package like linux-image-2.6-{amd64,i386} installed, which depends on the latest linux-image-2.6.x-y-{amd64,i386}?
11:54:17 <hydo> hellhell: obviously, back up anything you can't afford to lose.
11:54:20 <tensorpudding> I used Ubuntu in the past, from gutsy to intrepid, and I had annoyances every time.
11:54:25 <hellhell> hydo, :3
11:54:28 <hellhell> me not
11:54:29 <hellhell> nvm
11:54:42 <Jafet> Kaidelong, angular bisection?
11:54:52 <tensorpudding> CosmicRay: I meant, I never had to do a dist-upgrade.
11:54:55 <CosmicRay> tensorpudding: you may be correct that no security updates have broken ABI actually.
11:55:00 <Jafet> cat5 bisection.
11:55:13 <CosmicRay> which would mean you wouldn't have to dist-upgrade
11:55:20 <CosmicRay> I thought I remembered it happening, but I may be mistaken.
11:55:57 <monochrom> It is always the tool to be blamed. If the compiler can't fix my typo, the compiler is the problem. If apt-get can't tell buggy packages from good packages, apt-get is the problem.
11:55:57 <tensorpudding> I've run Debian off and on since sarge, but I've never actually upgraded from one stable to another
11:57:43 * CosmicRay does fairly regularly.  also track squeeze and unstable various places.
11:57:49 <CosmicRay> my workstations have traditionally tracked unstable
11:57:58 <CosmicRay> since probably about 1998 or so.
11:58:22 <tensorpudding> I get too bored with one distro if I stay too long
11:58:48 <CosmicRay> heh.  every few years I flirt with something else.  Tried out NetBSD a few times, Gentoo, Ubuntu.  never all that compelling
11:58:55 <monochrom> I can't stay too long with one distro. Because each distro ends eventually. Last time it was free Red Hat.
11:58:57 <CosmicRay> though I also get bored with programming languages sometimes.
11:59:10 <CosmicRay> which is how I learned Python, OCaml, and Haskell.
11:59:24 <jmcarthur> i was that way for a loooong time
11:59:27 <jmcarthur> then i learned haskell
11:59:30 <CosmicRay> heh.
11:59:33 <mreh> second guessing yourself all the time, I know the feeling
11:59:41 <Jafet> mreh, but do you?
11:59:47 <CosmicRay> I'm a bit surprised to realize that I've been using Haskell as my primary language for 5ish years now
11:59:59 <mreh> Jafet: I rotate projects all the time because I need to stay focused
12:00:10 <jmcarthur> i'm also pretty happy with my linux distribution. been with it longer than any other
12:00:10 <tensorpudding> I decided to tie myself to debian stable to reverse my distro-hopping, since it usually ended up with me breaking things
12:00:22 <jmcarthur> but i'm bsd-curious
12:00:41 <tensorpudding> But that does mean I have to wrangle with lots of packages outside of the stable tree because it's so outdated.
12:00:47 <kmc> haha
12:01:24 <mreh> Jafet: was that a joke?
12:01:28 <trofi> @paste
12:01:28 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:01:30 <mreh> I think I just got it
12:01:41 <Jafet> I started a joke
12:01:43 <monochrom> stable stably lags.
12:02:19 <monochrom> hi bye FliPPeh
12:02:25 <tensorpudding> My computer is old, therefore it's okay if some of my software is old.
12:02:28 <monochrom> oh, misread.
12:02:39 <Jafet> monochrom, blame yer client
12:02:45 <mreh> old software is the way to go, what's the obsession with the bleeding edge?
12:02:56 <tensorpudding> Though I can't stand old when it comes to development.
12:03:03 <tensorpudding> GHC 6.8 is...ancient.
12:03:06 <c_wraith> freaking.  there are times I wish String was not [Char]
12:03:27 <c_wraith> I really want to define an instance of something for String, and a different instance for [a]
12:03:38 * c_wraith grumbles about newtypes.
12:03:51 * Baughn grumbles about "String = [Char]" only being useful for quick hacks
12:03:54 <monochrom> I blame my monitor
12:04:11 <jmcarthur> doesn't haskell treat string special in some way anyway?
12:04:17 <kmc> if you need fully lazy strings, String = [Char] is the sensible choice
12:04:25 <trofi> http://dpaste.com/194274/ <- my faulty try to use language-c /me lurks here for someone to help
12:04:29 <jmcarthur> oh, it doesn't require flexible instance for type class instances for string
12:04:35 <kmc> jmcarthur, oh?
12:04:43 <kmc> that's an ugly special case
12:04:44 <olsner> hmm, sounds like a case of wanting the wrong thing... a string *is* a sequence of chars, so why should String have a different behaviour from a list of chars?
12:04:45 <jmcarthur> kmc: there's something weird about String. i think that's it
12:04:49 <kmc> is that in the standard or is it a GHC feature
12:04:57 <jmcarthur> oh, sorry
12:05:00 * hackagebot web-encodings 0.2.6 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.2.6 (MichaelSnoyman)
12:05:03 <jmcarthur> type synonym instances
12:05:06 <jmcarthur> or something
12:05:07 <jmcarthur> i think
12:05:10 <kmc> oh ok
12:05:14 <kmc> brb
12:05:23 <jmcarthur> i think it's not explicitly in the standard, but the standard library is specified that way, or something
12:05:56 <c_wraith> olsner: because a string is not a list of Characters in the same way a Foo is a list of Foos
12:06:06 <jmcarthur> well, it would have to be allowing a "flexible" instance to allow instances of String though
12:06:27 <c_wraith> yeah, I just started wondering about that.
12:06:42 <c_wraith> anyway, time to newtype String *just* to make instances work.
12:06:44 <jmcarthur> yeah i think i was right. i think that's the weird thing about String in the spec
12:08:38 <Baughn> So I tried to ldd a dynamically-linked haskell executable, and I get a stack overflow.
12:08:50 <Baughn> ..I know there are a lot of libraries, but /really/?
12:08:56 <xerox> haha
12:08:59 <jmcarthur> lol
12:09:05 <gwern> stack overflow, in a tool written in c?
12:09:13 <Baughn> It happens.
12:09:26 <Baughn> The stack is limited to.. 8MB.
12:09:31 <gwern> I know, it's just I don't think I've ever seen a realworld c program stack overflow
12:09:42 <jmcarthur> :o
12:09:42 <gwern> it's kind of like null pointer exceptions in haskell. or something.
12:09:43 <jmcarthur> ever?
12:09:45 <hellhell> oO
12:09:53 <jmcarthur> i've seen it a lot
12:09:55 <gwern> jmcarthur: what, do you see them so often?
12:09:57 <Baughn> gwern: I've seen a lot of those.
12:10:00 <hellhell> recursive?functions in C?
12:10:08 <jmcarthur> it just means somebody used a recursive function without thinking about it enough
12:10:49 <jmcarthur> it's actually a lot like thunk chains
12:11:20 <olsner> is that really common unless the code is written by people who don't know C?
12:11:23 <Baughn> Setting stack limit to unlimited.. it took 9MB. Not /that/ bad.
12:11:49 <jmcarthur> olsner: or perhaps somebody was relying on the compiler having tail call optimization
12:11:52 <Baughn> olsner: Well, I think the ld.so implementors had the reasonable idea that no single executable would have a fifty-library chain of dependencies.
12:11:55 <trofi> bdelta on large files like to smash stacks
12:12:06 <gwern> jmcarthur: thought c doesn't do TCO
12:12:17 <jmcarthur> gwern: the language doesn't specify it, but some compilers do it
12:12:26 <Baughn> [svein@eris tests]$ ldd auth | wc -l
12:12:29 <Baughn> 196
12:12:31 <hellhell> gweiqi, gcc does I heared
12:12:32 * trofi had to afford it to chew 100MB of stack to build patches
12:12:47 <olsner> ah, the "this data will never be nested too deep in reality although it theoretically could be" assumption
12:12:58 <jmcarthur> exactly
12:12:58 <Baughn> Mm.
12:13:09 <jmcarthur> even the linux kernel uses recursion
12:13:29 <trofi> [sf] ~:LANG=C gcc --help=optimizers | grep tail -foptimize-sibling-calls    Optimize sibling and tail recursive calls
12:13:47 <Baughn> trofi: Which is part of -O1, I believe. But it doesn't always /work/.
12:13:54 <olsner> relying on TCO for proper behaviour is stupid in C :)
12:14:02 * hackagebot http-wget 0.6.2 - Provide a simple HTTP client interface by wrapping the wget  command line tool.  http://hackage.haskell.org/package/http-wget-0.6.2 (MichaelSnoyman)
12:14:12 <jmcarthur> it's stupid with gcc, anyway
12:15:01 <trofi> sure, noone would write resursive folds returning structs on stack in C
12:16:21 <jmcarthur> noone
12:16:30 <gwern> noon
12:16:34 <mux> anyone knows how I can set so-called "style" properties with gtk2hs? specifically, I'm willing to change the "child-min-width" one
12:17:15 <dcoutts> mux: I thought there was something on GtkWidget which allowed for that
12:17:32 * mux goes to check the GtkWidget documentation
12:19:29 <mux> mm, widgetModifyStyle maybe? but there are broken links to the 'RcStyle' data structure
12:25:17 <mux> mm, I may not really want to use an HButtonBox anyways..
12:27:41 * edwardk_ waves hello.
12:27:52 <mreh> use Fruit
12:28:13 <mreh> why isn't everyone using FRP for their guis?
12:28:22 <edwardk> mreh: memory leaks ahoy
12:28:55 * byorgey waves to edwardk 
12:28:59 <edwardk> heya byorgey
12:29:11 <mreh> edwardk: yampa uses arrows specifically to mitigate that, does it still leak>
12:29:23 <edwardk> i think i have an approach that should let me implement reverse mode AD with a nice API in haskell
12:29:46 <edwardk> mreh: the arrow approach isn't leaky if done right, its just a straightjacket ;)
12:30:10 <mreh> respectfully, that's piffle :)
12:30:30 <mreh> what's the deal? can't write it poitwise? use arrow notation and you refer to specific signals
12:30:44 <edwardk> mreh: luke palmer seems to have climbed on board with arrow based frp, so you're not alone in that
12:31:57 <mreh> mmm, we can spoon
12:32:10 <hydo> haha
12:32:16 <edwardk> i'll let him know to expect you ;)
12:32:34 <mreh> if he wants to collaborate, in all seriousness, please do
12:32:49 <edwardk> preflex: xseen luqui
12:32:50 <preflex>  luqui was last seen on freenode/#haskell 37 days, 4 hours, 31 minutes and 9 seconds ago, saying: ah
12:34:03 <edwardk> byorgey: how goes the prep for hac-phi?
12:34:15 <mreh> is that him?
12:34:22 <edwardk> mreh: yeah
12:42:27 <roconnor> given an arrow, how do you make an applicative instance?
12:43:09 <byorgey> edwardk: it goes well, there's not too much to prep =)
12:43:56 <edwardk> byorgey: i have a buddy of mine booking the room/travel arrangements, so its rather easy on my end as well ;)
12:44:52 <byorgey> excellent
12:45:10 <byorgey> is this buddy coming to hac phi as well?  or just travelling to Philly?
12:45:35 <edwardk> he is going to contact you to be added shortly =)
12:45:59 <byorgey> great =)
12:46:19 <edwardk> we weren't positive we were both going until about 3 hours ago
12:47:27 <edwardk> roconnor: WrappedArrow =)
12:47:30 <edwardk> @type WrappedArrow
12:47:31 <lambdabot> Not in scope: data constructor `WrappedArrow'
12:48:00 <edwardk> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/Control-Applicative.html#t%3AWrappedArrow
12:49:38 <edwardk> if you mean you are defining an arrow and want it to also be the appropriate applicative, you can do: pure  = arr . const; f <*> v = f &&& v >>> arr (uncurry id)
12:51:07 <byorgey> It's interesting to me that 'arr' is necessary to make the connection from Arrow to Applicative and Monad, but I've also heard it decried as extraneous, i.e. there are interesting Arrow-like things that don't support arr
12:51:18 <byorgey> can anyone enlighten me on this topic?
12:51:51 <kmc> there definitely are
12:51:58 <kmc> i had a system of video filters
12:52:03 <kmc> which wire together like arrows in the natural way
12:52:20 <kmc> but you can't lift an arbitrary Haskell function to a filter
12:52:52 <byorgey> why not?
12:53:05 <kmc> because they were a deep-embedding DSL
12:53:13 <byorgey> ah
12:53:29 <edwardk> byorgey: as has been said Arrow is the intersection of Applicative and Category
12:53:48 <byorgey> right, but that's Arrow-with-arr, right?
12:53:59 <edwardk> kmc: yeah i have a bunch of Categories that work like that. it is a shame there isn't good Category sugar =)
12:54:08 <kmc> yeah
12:54:20 <byorgey> edwardk: submit a patch to SHE =)
12:54:35 <edwardk> byorgey: you can always mine through category-extras for CCCs if you want arrows-without-arr ;)
12:54:58 * BMeph imagines taking "That's what SHE said!" to a whole new level...
12:55:08 <edwardk> BMeph: haha
12:55:19 <byorgey> edwardk: so what is arr, from a categorical point of view?  What are Arrows-without-arr and Arrows-with-arr?
12:55:43 <edwardk> arr is an embedding of Hask
12:56:10 <kmc> yeah every Arrow comes with a functor from Hask
12:56:28 <roconnor> @type \f v ->  f &&& v >>> arr (uncurry id)
12:56:28 <edwardk> CCCs are almost a model of the lambda calculus, you need a couple of distinguished objects (basically S and K) to get the rest
12:56:29 <lambdabot> forall (cat :: * -> * -> *) a c' c. (Arrow cat) => cat a (c' -> c) -> cat a c' -> cat a c
12:56:35 <olsner> if arrow is an extension of applicative, isn't arr just pure+ap or something like that?
12:56:35 <byorgey> ah, yes, I see
12:56:47 <roconnor> ugh, that confuses me
12:56:51 <roconnor> @unpl \f v ->  f &&& v >>> arr (uncurry id)
12:56:51 <lambdabot> \ f v -> (f &&& v) >>> (arr (uncurry (\ a -> a)))
12:56:55 <roconnor> pfft
12:56:59 <edwardk> olsner:  not every applicative is an arrow, its the other way around
12:57:15 <roconnor> @type (uncurry (\ a -> a)
12:57:16 <lambdabot> parse error (possibly incorrect indentation)
12:57:18 <olsner> hmm, well "intersection" would mean it excludes stuff from applicative
12:57:18 <roconnor> @type (uncurry (\ a -> a))
12:57:19 <lambdabot> forall b c. (b -> c, b) -> c
12:57:26 <roconnor> :O
12:57:46 <byorgey> uncurry ($) might be a more intuitive way to spell it
12:58:07 <edwardk> olsner: by intersection i mean is if your thing is both an applicative and a category. if it is in both sets, it is in the intersection.. the things in the intersection have the union of the features
12:58:49 <byorgey> edwardk: so am I correct in saying that ArrowApply models CCCs with an embedding from Hask?
12:59:03 <byorgey> and ArrowApply sans arr would just be CCCs in general?
12:59:12 <byorgey> or at least, more general?
12:59:14 <edwardk> i don't know that i'd say that
12:59:30 <edwardk> ArrowApply enriches an arrow with enough functionality to be a monad
13:00:07 <edwardk> Arrow models a CCC with an embedding from Hask
13:00:26 <edwardk> I don't know what ArrowApply sans arr is off the top of my head.
13:00:27 <olsner> edwardk: ok, so all general Applicative functions can be used on arrows? but maybe that's unrelated to arr
13:00:36 <byorgey> really?  hmm... I'll have to go back and stare at the definition of CCC again
13:01:05 <edwardk> @type arr (uncurry id)
13:01:06 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => a (b -> c, b) c
13:01:47 <edwardk> that is just http://hackage.haskell.org/packages/archive/category-extras/0.52.0/doc/html/Control-Category-Cartesian-Closed.html#v%3AcounitCCC
13:01:48 <BMeph> ( Applicative ((Arrow [Monad]) Category)
13:02:16 <edwardk> counitCCC :: CCC  hom prod exp i => hom (prod b (exp b a)) a
13:02:23 <BMeph> ( Applicative [(Arrow [Monad]) Category] -- "better", FSVO...
13:02:32 <edwardk> though the args are flipped there
13:02:46 <edwardk> since uncurrying isn't quite the counit
13:03:01 <BMeph> ( Applicative [(Arrow {Monad}) Category] -- "better" still, FSVO...
13:03:10 <edwardk> BMeph: i can't parse that =)
13:03:24 <byorgey> oh, the objects for any Arrow are always objects of Hask, and since Hask has internal hom objects...
13:04:46 <edwardk> so yes, ArrowApply sans arr is just a CCC
13:05:52 <edwardk> not sure how powerful a CCC that is also a haskell Applicative is though
13:06:12 <EvanR-work> @src peekByteOff
13:06:12 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:07:00 <edwardk> that gives you an embedding for objects rather than for morphisms, but the target is a CCC so that is a lot of power
13:07:38 <edwardk> and it has exponentials, though once you've lifted a function via pure you can't apply it because it isn't necessarily of the form of the exponentials for your ccc
13:07:50 <edwardk> so it seems to be a weaker beast
13:12:50 <edwardk> what an odd construction, you can do some things with it: (k a (b -> c, b)) -> k a c -- is definable, but that isn't quite Hom k (Prod k (Exp k b c) b) c, for one the product is the Hask product and the -> is Hask as well
13:16:11 <cocon> hi
13:16:42 <cocon> cabal problem: "runghc Setup.hs configure" complains about a missing package, while "cabal configure" doesn't... what's the difference between those two commands?
13:16:58 <ibid> have you tried --user?
13:17:11 <ibid> with Setup.hs configure
13:17:12 <c_wraith> cabal looks at your user packages, using runghc directly doesn't
13:17:33 <cocon> that was it indeed, thanks!
13:22:53 <edwardk> ooh wikipedia's book creator is nice
13:23:12 <EvanR-work> hrm
13:23:36 <EvanR-work> how do i find SIZEOF_HSINT, ALIGNMENT_HSINT for my system...
13:24:11 <BMeph> edwardk: Do you need a CCC, or would a Monoidal suffice?  Or (equivalently) is there a working isomorphism using monoidals?
13:25:23 <edwardk> BMeph: i was using counitCCC  to finish definition above
13:25:30 <edwardk> er finish that implementation
13:28:11 <hellhell> upgrade done, ghc 6.12.1 availableas awell as cabal-install =)
13:28:37 <edwardk> er wait, i was wrong, that construct doesn't quite work. the type is a bit different because the product isn't a hask product it is the product in the ccc.
13:29:26 <edwardk> ok, so the intersection of CCC and Applicative seems somewhat meaingless without further constraints
13:30:19 <EvanR-work> on my 64bit linux machine, it seems that peeking to read an Int results in the correct 32bit value (4 byte C int) but offset by 0x100000000, im racking my brain trying to figure out why
13:30:30 <BMeph> edwardk: So, you do need it to be Cartesian; Monoidal is insufficient.
13:30:41 <edwardk> would appear so
13:30:43 <EvanR-work> this affects status codes in hsdns
13:30:54 <EvanR-work> is there a ghc channel or something
13:30:57 <ClaudiusMaximus> Int or CInt or CUInt ?
13:31:12 <EvanR-work> :t peekByteOff
13:31:12 <lambdabot> Not in scope: `peekByteOff'
13:31:18 <BMeph> EvanR-work: Um... #ghc perhaps? ;)
13:31:21 <EvanR-work> peekByteOff :: (Storable a) => Ptr b -> Int -> IO a
13:31:25 <EvanR-work> in my case a is Int
13:31:40 * hackagebot clientsession 0.2.1 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.2.1 (MichaelSnoyman)
13:31:42 <ClaudiusMaximus> i think it should be CInt or CUInt
13:31:54 <EvanR-work> that would make sense
13:31:56 <ClaudiusMaximus> unless the foreign code is using HSint
13:32:04 <ClaudiusMaximus> or whatever it's called
13:32:04 <EvanR-work> the feign code is an enum field in a struct
13:32:07 <EvanR-work> foreign
13:32:16 <EvanR-work> so equal to 'int'
13:32:18 * BMeph is multiply disturbed by Int being 64 bits on 64-bit machines...
13:32:41 * hackagebot data-object 0.3.1 - Represent hierachichal structures, called objects in JSON.  http://hackage.haskell.org/package/data-object-0.3.1 (MichaelSnoyman)
13:32:51 <EvanR-work> so you think hsdns bindings should be using CInt to expose that value
13:33:29 <EvanR-work> when its just Int, it would make sense if its trying to read a 64bit value wheres theres only 32bits, but the next 32bits is an ip address, definitely not a single bit of data to make it +0x100000000
13:33:38 <ClaudiusMaximus> it could use fromIntegral, or better if it's an enum then use an algebraic data type
13:33:41 * hackagebot data-object-json 0.3.1 - Serialize JSON data to/from Haskell using the data-object library.  http://hackage.haskell.org/package/data-object-json-0.3.1 (MichaelSnoyman)
13:33:56 <hellhell> Warning: Module `Prelude' is deprecated:
13:33:57 <hellhell>                You are using the old package `base' version 3.x.
13:33:57 <hellhell>                Future GHC versions will not support base version 3.x. You
13:33:57 <hellhell>                should update your code to use the new base version 4.x.
13:34:11 <hellhell> this message appeared while installing regex-posix via cabal
13:34:13 <EvanR-work> ClaudiusMaximus: his comments somehow defend not doing that and exposing it as a StatusCode Int, and having constructors that return the numbers
13:34:15 <Zao> I find people assuming Int is a common bit width cute.
13:34:50 <hellhell> but cabal upgrade tells me that it is a bad idea to upgrade core  modules
13:34:59 <EvanR-work> Zao: well, his thing works if you assume Int and CInt are the same size
13:35:15 <byorgey> hellhell: the message is a bit misleading, it is not meant for you but rather for the author of the regex-posix package
13:35:16 <edwardk> BMeph: you expected something more like the LP64 model?
13:35:23 <hellhell> ok
13:35:24 <hellhell> ty
13:35:42 <edwardk> rather than, er.. ILP64?
13:35:43 * hackagebot authenticate 0.6.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.6.2 (MichaelSnoyman)
13:35:56 <EvanR-work> i still dont understand the behavior under Int. its randomly ORing a 1 at position 32 :(
13:36:08 <EvanR-work> anyone with a 64bit linux can reproduce it
13:36:11 <EvanR-work> i think
13:36:58 <ClaudiusMaximus> > log (fromIntegral (maxBound::Int)) / log (2::Double)
13:36:59 <lambdabot>   63.0
13:37:33 <edwardk> Zao: well most compilers follow that LP64 or LLP64 model, so moving to a 64 bit platform doesn't double the size of their ints relative to their 32 bit implementations.
13:38:00 <edwardk> Zao: so it isn't an unreasonable expectation.
13:38:44 * hackagebot wai-extra 0.1.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.1.0 (MichaelSnoyman)
13:54:07 <uorygl> How easy would it be to compile Haskell to an HDL?
13:54:36 <Zao> Hippies Dont Lie?
13:54:45 <uorygl> Hardware Description Language.
13:55:27 <Tarrasch> Is there any way I can use the module 'Data.Queue'? ghci can't find it, I bet it's due to it's deprecated, but I want to use Data.Queue instead of the full-blown Queue.Sequence ...
13:55:28 <kyagrd> uorygl, there is a company called BlueSpec if buy their tool it would not be a problem
13:55:45 <uorygl> I'd prefer to not buy stuff.
13:56:19 <kyagrd> To do hardware design one needs to buy something usually
13:56:27 <uorygl> Yeah, that's true.
13:57:30 <BMeph> uorygl: Do you know LAVA? ;)
13:57:52 <uorygl> That sounds scary, because it sounds like Java.
13:58:59 <kyagrd> it's a VHDL generator
13:59:43 <systemfault> No swearing on the channel please...
14:00:23 <uorygl> Does it have a Wikipedia article, or at least a mention?
14:01:39 <gwern> haskellers aren't big on wikipedia
14:01:39 <kyagrd> http://www.cs.chalmers.se/~koen/Lava/papers.html there are tutorials and papers
14:02:05 <Tarrasch> hehe, I've had Koen as teacher ^^
14:08:59 <cocon> is ghc able yet to produce x86_64 output under Mac OS 10.6?
14:10:37 <uorygl> Oh, Lava is that thing the Reduceron mentions, isn't it.
14:10:38 <scotty> Where can I get someone to review my code?  I've written something fairly lengthy in Haskell using what I've learned so far.  I'd like to learn from someone what I can do to improve by programming.
14:13:49 <uorygl> scotty: well, I might be interested in taking a look at it.
14:14:05 <gwern> for a price?
14:14:21 <uorygl> If you offer to pay me, I will not decline.  :P
14:14:31 <fryguybob> hlint?
14:14:47 <gwern> fryguybob: too local; scotty likely needs intelligent global critiques
14:14:53 <scotty> uorygl: Okay, thanks.  I kind of want pointers that are applicable to my skill level.  Please don't suggest that I completely rewrite everything. XD  Here is the code: http://omanyte.ath.cx/projects/haskell/euler/39.hs
14:15:01 <fryguybob> hlint-global!
14:15:07 <uorygl> Aiee!  You have to completely rewrite everything, scotty!
14:15:11 <gwern> scotty: although obviously you should see what hlint and -Wall say about your code before you ask humans to see it
14:15:20 <scotty> uorygl: It solves this problem: http://projecteuler.net/index.php?section=problems&id=39
14:15:54 <scotty> Oh, neat.  I didn't know about hlint.
14:17:00 <uorygl> Well, I've read up through transform3.  So far, it mostly looks good.
14:17:25 <scotty> uorygl: Also, I'm using method XI from this page: http://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples
14:17:26 <uorygl> For transform1 and its brethren, it would probably be better if you made the variables line up.
14:17:48 <EvanR-work> ClaudiusMaximus: hey. i changed Status to StatusCode CInt instead of Int, seems to have worked. testing
14:17:53 <applicative> scotty heres the hlint advice http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25484
14:18:25 <scotty> The function I'm mostly concerned with is "answer", which I think is horrendous.
14:18:38 <uorygl> scotty: so, take a look at this: http://pastebin.com/NUmFKbLs
14:18:56 <applicative> hlint didn't find anything significant, alas.
14:19:09 <scotty> applicative: No, this is really awesome and helpful.
14:19:32 <scotty> uorygl: Yeah, that's prettier.
14:19:33 <uorygl> scotty: also, that where clause isn't really necessary; you could write it pretty much the same way without it.
14:19:39 <applicative> scotty, it is especially good for getting the hang of operators and when you need parentheses, sometimes its more interesting.
14:19:45 <uorygl> But anyway, on to the rest of the code...
14:20:55 <Tarrasch> I'm trying to use Seq from Data.Sequence, but I can't seem to import the (:<) constructor from the Sequence-module to my own modules namespace. Any ideas?
14:21:30 <c_wraith> Tarrasch: What's the import line you're trying to use?
14:21:37 <mauke> wait, constructor?
14:21:46 <mauke> oh, that one
14:21:47 <Tarrasch> c_wraith, import Data.Sequence ((:<), (<|), viewl)
14:21:56 <scotty> uorygl: Do you mean instead of "a' = ...", put the formula for a' in the tuple?
14:21:58 <c_wraith> well, that import looks right.
14:22:17 <Tarrasch> Queue.hs:7:22: Module `Data.Sequence' does not export `:<'
14:22:30 <scotty> uorygl: Which where clause are you talking about?
14:22:42 <nus> @hoogle (:<)
14:22:42 <lambdabot> Data.Sequence (:<) :: a -> Seq a -> ViewL a
14:22:44 <uorygl> scotty: yeah, that's what I mean.
14:22:49 <Tarrasch> But it should, according to this documentation: http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Sequence.html
14:23:19 <c_wraith> It's not in the export list here:  http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Sequence.html
14:23:32 <uorygl> scotty: like this: http://pastebin.com/8C4vcEeB
14:23:35 <c_wraith> oh, there it is.
14:23:43 <c_wraith> Hidden in the data declarations, where a constructor should be
14:24:04 <scotty> uorygl: Oh!
14:24:08 <c_wraith> try importing like so:  import Data.Sequence ( ViewL((:<)) )
14:24:17 <Tarrasch> Well, maybe I should rephrase my question to my actual problem. How on earth do I get out the first (leftmost) element from a sequence?
14:24:20 <BMeph> Using concat (map ...) is an error? Cheeck bar steward, that. :\
14:24:35 <BMeph> Er, *Cheeky
14:24:53 <uorygl> I wonder if there's a function called maximumBy or something.
14:24:55 <uorygl> @hoogle maximumBy
14:24:55 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
14:24:56 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
14:25:01 <Tarrasch> c_wraith, It worked. :)
14:25:14 <c_wraith> Tarrasch: yeah, to import a constructor, you need that syntax
14:25:23 <uorygl> Or maximumOn, or something.
14:25:25 <Tarrasch> c_wraith, I had no idea :)
14:26:02 <c_wraith> to import all the constructors, you can use stuff like: import Data.Sequence ( ViewL(..) )
14:26:03 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25485 <-- Can anyone think of a way to do this STM listener that doesn't involve actually invoking Eq?
14:26:36 <uorygl> Instead of having [foo,bar,baz] and [1,3,2] and tell it to get the element of the former list whose index is that of the maximum element of the latter list, you can just tell it to get the maximum element of [(foo,1),(bar,2),(baz,3)], where the comparison function is (compare `on` snd).
14:26:41 <Tarrasch> c_wraith, it makes all sense, you must somehow distinguish types and constructors
14:27:23 <c_wraith> That really looks like a very sad import.  >__>
14:29:10 <BMeph> Baughn: Re-write that "check" function, and we'll talk... ;)
14:29:27 <ahead_NOT> Hello. Are "type classes" similator to generic types where generic parameters are required to be instantiated to types that implement some interface?
14:29:38 <Baughn> BMeph: Er, why?
14:29:39 <ahead_NOT> similar to
14:30:33 <c_wraith> ahead_NOT: They're very similar to that, yes.
14:30:47 <ahead_NOT> c_wraith: thanks
14:31:01 <ahead_NOT> c_wraith: I'll have a closer look to them later
14:32:02 <scotty> uorygl: I can do that with by zipping the lengths with the lists, right?
14:32:08 <BMeph> Baughn: How are you going to check (new /= cur) without having an instance of Eq? -- hint, hint... ;)
14:32:27 <scotty> uorygl: *that by zipping
14:32:30 <Baughn> BMeph: Um...
14:32:46 <uorygl> scotty: yep.
14:32:55 <Baughn> BMeph: The point was to have it hook writeTVar.. somehow.
14:34:12 <scotty> uorygl: One thing I was trying to do was to make my triangle generation functions return infinite lists, and then just have a "take" in my answer function, but I had problems sorting them, since they grow in a tree-like way.
14:34:54 <scotty> uorygl: Maybe I should just throw them in a Set as I go.
14:35:37 <uorygl> Well, see if you can turn those infinite lists into finite lists.
14:35:38 <scotty> uorygl: Actually, I don't know if that would work...
14:35:49 <uorygl> And remember that you can't do that using filter.  :)
14:36:02 <uorygl> > filter (<5) [1..]
14:36:06 <lambdabot>   mueval-core: Time limit exceeded
14:37:01 <mreh> how can I lock a file when I'm not currently reading from it?
14:37:08 <mreh> sentinel file?
14:37:31 <BMeph> Baughn: I presume you can't use a TMVar instead?
14:37:39 <gwern> > filter (\x -> x < 5) [1..]
14:37:43 <lambdabot>   mueval-core: Time limit exceeded
14:38:00 <gwern> hm. so ghc api is not lazy
14:38:12 <Baughn> BMeph: Not so much. Eh, it's really a symptom of bad design though.
14:38:26 <Baughn> BMeph: I could always /make/ a listenable tvar-equivalent. I'll get on that.
14:38:35 <Baughn> ..after I fix the design.
14:38:47 * BMeph chuckles
14:38:54 * BMeph snickers
14:38:56 <c_wraith> gwern: It's actually mueval that's responsible for that behavior.  If it doesn't fill its output buffer before time expires, it ignores everything that was in its output buffer.
14:39:16 * BMeph Dum-Dums...wait, what?
14:39:18 <gwern> c_wraith: doesn't it print strictly, as it gets stuff?
14:40:35 * BMeph goes into a horrible coughing fit!
14:41:01 * Baughn really needs to stop writing three-line language pragmas
14:41:14 <c_wraith> gwern: I can't really figure out what that question means.
14:41:30 * BMeph turns purple, and sounds as if he's saying *check only triangle sides shorted than 1000*, but scotty must've been hearing things...
14:41:38 <c_wraith> gwern: try running that example in ghci.  It shows some output, before running forever.
14:42:07 <c_wraith> gwern: if you put a print in front of it, and compiled it, the resulting ghc-produced binary would do the same.
14:42:51 <c_wraith> gwern: the issue is with mueval.  It terminates the computation on either timeout or the output buffer filling.
14:43:07 <c_wraith> gwern: if it times out, it ignores the output it received before that.
14:43:15 <gwern> hm
14:43:55 <fryguybob> > [1..]
14:43:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:44:00 <gwern> oh well. I'm sure someone will fix it at some point
14:45:36 <Baughn> ..nothing's quite like when you realize that the module you *expected* would be two hundred more lines.. in fact is twenty.
14:46:01 <BMeph> gwern: What's to fix? It doesn't finish printing in its alloted time, so you get NOTHING! (As opposed to Nothing, which is a different beast altogether.)
14:46:35 <gwern> BMeph: if ghci can deliver any results, mueval should be able to
14:48:25 <BMeph> gwern: And how should mueval indicate that there are (potentially) more output to come? You could do it, sure - it sounds like a pain, though.
14:48:40 <gwern> BMeph: I think it would just do IO while waiting for more the epxression to evaluate
14:49:00 <gwern> BMeph: something like 'mapM_ putChar (result)'
14:49:09 <gwern> if the watchdogs kill the binary, they kill the binary
14:49:30 <gwern> it gets as far as it gets. so it goes.
14:50:04 <BMeph> gwern: So "[1,2,3,4, mueval-core: Time limit exceeded"? :p
14:50:39 <gwern> BMeph: sure
14:50:51 <gwern> that's even correct, modulo the exception message :)
14:52:09 <hpc> > takeWhile (<5) [1..]
14:52:10 <lambdabot>   [1,2,3,4]
14:54:13 <fryguybob> > [1..29]
14:54:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:54:22 <fryguybob> > [1..28]
14:54:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]
14:54:43 <c_wraith> @pl \x y -> f x y
14:54:44 <lambdabot> f
14:54:53 <c_wraith> hm.  I did that wrong.
14:55:20 <c_wraith> oh, I can use uncurry for what I really mean to do
14:58:28 <idnar> @pl \(x, y) -> f x y
14:58:29 <lambdabot> uncurry f
14:58:38 <idnar> is that what you meant?
15:00:07 <scotty> uorygl: Thanks for the help!  This is what I have now: http://omanyte.ath.cx/projects/haskell/euler/39.hs
15:01:08 <uorygl> Hmm, I suppose you can do the same with scale as you did with transform.
15:01:31 <scotty> uorygl: Oh, yeah.  I missed that.
15:02:38 <scotty> uorygl: Done! :P
15:03:25 <scotty> uorygl: So theres really nothing like "maxLengthSubList" in Prelude?
15:03:47 <uorygl> Well, you don't need to limit yourself to Prelude functions.
15:03:54 <mreh> I really want to be using wxFruit with a customised "sense" function
15:04:10 <scotty> uorygl: Well, any standard library for that matter.
15:04:16 <uorygl> Right.
15:04:35 <scotty> Maybe you could even generalize it to a certain depth.
15:04:40 <Twey> maximumBy (comparing length) . group
15:06:25 <scotty> > (maximumBy (comparing length . group)) [[1],[2,2]]
15:06:26 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:06:43 <uorygl> Your parenthesis slipped.  :)
15:06:57 <Kaidelong> jmcarthur: one of the articles you linked me suggests using ArrowApply to change the structure of arrows at runtime
15:07:09 <scotty> > (maximumBy (comparing length) . group) [[1],[2,2]]
15:07:10 <lambdabot>   [[2,2]]
15:07:11 <copumpkin> change structure at runtime?
15:07:14 <Kaidelong> not sure how that could apply to yampa (pardon the pun)
15:07:22 <Kaidelong> how they're linked together
15:07:40 <scotty> > (maximumBy (comparing length) . group) [[1],[2,2],[3,3]]
15:07:41 <lambdabot>   [[3,3]]
15:09:42 <EvanR-work> ClaudiusMaximus: patch sent ;)
15:10:11 <ClaudiusMaximus> EvanR-work: cool so the tests passed?
15:10:23 <EvanR-work> yeah
15:10:42 <EvanR-work> i decided not to change the type of Status, i left it as Int
15:10:49 <EvanR-work> but i just fixed his casting job
15:11:12 <EvanR-work> needed some fixes to :: IO #{type adns_status} and some fromEnum
15:12:32 <EvanR-work> http://codepad.org/VUp9BotK
15:13:15 <wagle> is there a right way to upgrade EVERYTHING in cabal..  (like delete and start over, or something)
15:14:15 <c_wraith> wagle: no.
15:15:27 <wagle> well, if I delete it, that should work, except i'm not sure how to delete it
15:16:33 <c_wraith> assuming you're on something unixy, delete ~/.cabal and ~/.ghc
15:16:54 <wagle> debian..  cool
15:17:02 <sinelaw> jwaah
15:19:29 * hackagebot hubigraph 0.3.1 - A haskell wrap for Ubigraph  http://hackage.haskell.org/package/hubigraph-0.3.1 (KoheiOzaki)
15:20:44 <mreh> @hoogle ReactState
15:20:44 <lambdabot> No results found
15:21:04 <mreh> how can a type not be linked in haddock source?
15:23:11 <aavogt> mreh: when it comes from a different package whose docs weren't installed when the html for your type was generated?
15:23:53 <aavogt> also, when things aren't exported, but written in type signatures, they show up unhyperlinked
15:55:29 <heropass> categorically speaking
15:56:19 <copumpkin> yeah?
16:14:59 <ezyang> quicksilver: I'm looking at the comments you made after we signed off last night.
16:16:04 <copumpkin> oh yeah, did you manage to prove it?
16:16:34 <ezyang> quicksilver: And I don't understand what you mean by n^m /= m^n
16:17:04 <copumpkin> I'd assume ^ means exponential objects
16:17:26 <ezyang> Although I do see why the skeletons are isomorphic.
16:17:45 <ezyang> or, erm, I mean to say, why it might seem like it solves the multiple terminal objects problem.
16:19:01 <ezyang> copumpkin: Ah, just got back to your comments :^)
16:19:11 <ezyang> I haven't written it up yet. About to do so.
16:19:19 <copumpkin> cool
16:19:29 <copumpkin> you should do it in a proof language ;)
16:19:54 <ezyang> I think attempting to learn Agda in the four days before my finals is a bad idea :^)
16:19:56 <ezyang> Or Coq.
16:20:13 <copumpkin> agda would probably be easier on the eyes if you're used to haskell :P
16:20:19 <copumpkin> but there's a way bigger coq community
16:21:02 <ezyang> I'm still not 100% sure why dolio's proof begs the question tho
16:21:18 <copumpkin> I don't think I saw his proof
16:21:21 <dolio> What?
16:21:41 <ezyang> Referring back to the conversation, ah, 14 hours ago
16:21:54 <copumpkin> dolio's honor is called into question! this must be settled with a duel
16:21:56 <dolio> I don't think I begged any questions.
16:21:57 <copumpkin> at midnight
16:22:15 <mauke> timezone?
16:22:17 <hpc> sabres at midnight?
16:22:26 <copumpkin> mauke: all of them, it's a 24-hour thing
16:22:29 <ezyang> quicksilver> "in some sense this is the 'wrong' proof, though;  because it begs the question : Is Skel(Set) isomorphic to Skel(Set^op), then ?"
16:22:34 <copumpkin> on a slow-flying pla
16:22:43 <copumpkin> plane
16:22:46 <dolio> Oh.
16:22:49 <ezyang> It's not 100% clear what quicksilver is referring to, but I think it was your proof.
16:23:03 <dolio> ezyang: quicksilver's points was that the skeletons aren't isomorphic, either.
16:23:16 <ezyang> Ah!
16:23:18 <dolio> So the proof using initial objects is too easy.
16:23:22 <ezyang> And your proof doesn't necessarily give intuition about that
16:23:32 <ezyang> Ok, time to understand exponential objects then
16:23:34 <dolio> You can get a stronger result.
16:24:18 <dolio> It's kind of like proving two objects aren't equal when you could, in fact, prove that they aren't even isomorphic.
16:25:06 * ezyang nods 
16:25:31 <ezyang> I wonder if there's a proof that directly shows that, or if it's the most straightforward to prove the result on skeletons directly
16:25:36 <dolio> The (A x B) + C /= (A + C) x (B + C) proof probably works for the skeletons, too.
16:26:10 <ezyang> Clever.
16:26:32 <aristid> skew binary numbers... okasaki is doing crazy stuff
16:27:23 <mauke> http://search.cpan.org/perldoc?Data::PrioQ::SkewBinomial
16:28:25 <gwern> oh noes okasaki is working in perl?
16:28:40 <gwern> haskell must be a sinking ship. i'd better start learning perl6
16:28:44 <dolio> ezyang: In fact, in the skeleton categories of Set, (A + B) x C = A x C + B x C should actually be an equality, because isomorphic objects are turned into a single object.
16:28:46 <mauke> why perl6?
16:28:53 <gwern> mauke: because it's the future obviously
16:28:56 <aristid> gwern: i heard perl6 is gonna be great.
16:28:58 <gwern> it has... stuff
16:29:03 <mauke> uh, great
16:29:09 <ezyang> Perl 6 is exciting, but can Haskell beat it?
16:29:12 <dolio> (I think that's accurate.)
16:29:14 <ezyang> @faq Can HAskell beat it?
16:29:14 <lambdabot> The answer is: Yes! Haskell can do that.
16:29:18 <mauke> perl5 has a functional queue based on skew binomial trees, on the other hand
16:29:20 <gwern> 'perl 6 is the programming language of the future, for the programmers of the past.'
16:29:42 <ezyang> dolio: ooh, classy.
16:31:19 <gwern> "APL is a mistake, carried through to perfection. It is the language of the future for the programming techniques of the past: it creates a new generation of coding bums." <-- ah I messed up the structure
16:31:26 <gwern> it was programming techniques, not programmers
16:31:32 <gwern> (but good ol djikstra)
16:32:44 <dolio> ezyang: Anyhow, I meant it when I said the argument with initial objects is the same as the argument with sums and products. You get the same unique existence properties of the morphisms. There are just more to think about.
16:33:21 <dolio> So you can go through approximately the same reasoning to figure out that if F is part of an isomorphism then F (A x B) must be a product X x Y in the target category.
16:33:29 <wagle> cabal-install installs everytime i upgrade it?
16:33:34 <dolio> And same for sums A + B. And same for G.
16:34:07 <ezyang> Ok, I'll work that out
16:34:23 <Saizan> wagle: what?
16:34:27 <copumpkin> I'll be interested to see the proof when you're done
16:34:31 <copumpkin> if you plan on putting it up somewhere
16:34:57 <ezyang> copumpkin: Sure. It'll probably be wrong, but more power in that case :-)
16:35:13 <copumpkin> nothing better than wrong proofs!
16:36:25 <dolio> ezyang: Alternately, I noticed that if F and G are inverses, then you can prove that F is left adjoint to G, and vice versa. And there's a theorem way into category theory that left adjoints preserve colimits, and right adjoints preserve limits. So F and G preserve both.
16:37:11 <dolio> But that wasn't popular, because proving that is probably harder than proving that isomorphisms preserve those.
16:37:28 <wagle> saizon: i think i get it..  its installing it into .cabal instead of /usr/local, so never recognizes that its been installed
16:39:18 <wagle> what does this mean:
16:39:23 <wagle> wagle@monad:~$ sudo cabal upgrade --prefix=/usr/local cabal-install
16:39:23 <wagle> Resolving dependencies...
16:39:23 <wagle> cabal: fromFlag NoFlag. Use fromFlagOrDefault
16:39:28 <wagle> ...
16:40:15 <copumpkin> why not cabal install cabal-install ?
16:41:11 <wagle> ok
16:41:14 <LeNsTR> '
16:41:18 <LeNsTR> (-:
16:42:49 * Saizan suggests --root-cmd=sudo rather than sudo cabal ..
16:43:16 <jesusabdullah> Whoa, pikhq!
16:43:20 <jesusabdullah> Fancy running into you!
16:43:46 <jesusabdullah> nyoro~n
16:43:58 <jesusabdullah> now I'm left just being some noob with a question:
16:44:25 <c_wraith> jesusabdullah: no worries, we get lots of them here.  Usually, someone's even helpful ;)
16:44:30 <jesusabdullah> I'm trying to install hmatrix (su, then cabal install hmatrix) and it's not worky
16:44:42 <jesusabdullah> hold on, gonna paste error
16:44:51 <wagle> copumpkin: i diverged when cabal-install wouldn't actually install..  so i tried to upgrade it, and got the same error i got when i tried to upgrade gitit..  now that i installed (?) cabal-install, gitit is upgrading fine..  thanks for knocking me loose
16:44:57 <jesusabdullah> configure.hs: user error (Pattern match failure in do expression at configure.hs:98:4-7)
16:45:04 <jesusabdullah> and the line in question...
16:45:10 <jesusabdullah> (hold on, gotta find it again)
16:45:20 * hackagebot SimpleAES 0.4 - Fast AES encryption/decryption for bytestrings  http://hackage.haskell.org/package/SimpleAES-0.4 (DavidHimmelstrup)
16:45:45 <copumpkin> "Data types: There is one universal datatype, which is implicitly coerced to string, integer, or floating-point datatypes as context requires."
16:45:48 <copumpkin> mmm
16:45:49 <jesusabdullah>     Just bInfo <- maybeGetPersistBuildConfig "dist"
16:45:55 <copumpkin> that's what I'm talking about
16:46:15 <jesusabdullah> anyways: ihnfi what's going on here :S
16:46:40 <copumpkin> it returned Nothing
16:47:24 <Cale> copumpkin: Which language?
16:47:29 <copumpkin> MUMPS
16:47:43 <hpc> oh god MUMPS
16:47:43 <jesusabdullah> Man it figures pikhq would hang here. He was always about the tiling window managers and emacs and stuff back in the day
16:47:45 <ezyang> dolio: Quick question about your proof: when we applied G to functions of X -> F(A), we showed the uniqueness of those functions. What did it mean to be weakly initial, in that case?
16:47:47 <jesusabdullah> hah!
16:47:59 <jesusabdullah> I first learned about mumps when I read a dailywtf about it
16:47:59 <copumpkin> http://snapplr.com/wct9
16:48:15 <Cale> ezyang: What are you proving?
16:48:22 <hpc> MUMPS has so many dailywtf articles
16:48:29 <copumpkin> that Set is not isomorphic to Set^op
16:48:29 <jesusabdullah> that makes me cry a little inside
16:48:37 <dolio> ezyang: Weak initiality of X means that there exists a morphism from X to any other object, but it's not necessarily unique.
16:48:38 <Cale> Oh, cute
16:48:39 <ezyang> What we were doing 15 hours ago :-)
16:48:45 <ezyang> Excellent!
16:48:49 <jesusabdullah> Actually, I think my possible next employer might use mumps some
16:48:51 <ezyang> That's what I thought, but wasn't sure.
16:48:54 <Cale> ezyang: Yeah, but I hadn't been around the first time apparently
16:48:56 <jesusabdullah> they had t-shirts that said d^ good
16:49:00 <copumpkin> Cale to the rescue
16:49:05 <Cale> hehe
16:49:11 <ezyang> OH!
16:49:12 <copumpkin> in ezyang's search for the simplest proof
16:49:17 <wagle> what do people use for category theory diagrams in blogs?  gitit?  or something else?
16:49:21 <ezyang> these two ways make it "fully faithful"
16:49:21 <Cale> isomorphic or equivalent?
16:49:29 <ezyang> s/make it/require it to be/
16:49:33 <ezyang> Cale: isomorphic
16:49:42 <hpc> wagle: i read that as gTIT
16:49:53 <dolio> ezyang: So, noting Ff : X -> FA, and that every Y in Set^op is FA for some A, we've shown existence of such morphisms, but not uniqueness.
16:49:57 <wagle> not my name
16:50:02 <djahandarie> Faith-based category theory!
16:50:09 <ezyang> Cale: But we were talking about proving the stronger result.
16:50:12 <Cale> Well, in that case, there's a single initial object, but lots of isomorphic terminal objects. Doesn't that settle it?
16:50:25 <ezyang> Cale: I'm writing it down formally :^)
16:51:22 * hackagebot sifflet 0.1.5 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-0.1.5 (GregoryWeber)
16:52:06 <jesusabdullah> aww, visual programming
16:52:14 <jesusabdullah> it holds a warm spot in my heart, after labview
16:52:15 <ezyang> Amusing anecdote: I used to do math-ish comp-sci psets with a friend, and invariably when we'd compare notes her proofs were x4 longer than mine
16:52:17 <copumpkin> http://mypage.iu.edu/~gdweber/software/sifflet/doc/tutorial.html
16:52:30 <ezyang> I like short proofs :-)
16:53:01 <copumpkin> how about lazy proofs
16:53:03 <jesusabdullah> huh!
16:53:06 <copumpkin> don't prove unless you need it
16:53:17 <ezyang> Certainly helps :-)
16:53:18 <copumpkin> i.e., proof: "ask one of the experts in #haskell"
16:53:22 <jesusabdullah> "close 'nuff"
16:53:24 <Cale> I think I would pick two such terminal objects, say {0} and {1}, and show that they must be sent to the same object (namely the empty set) by any functor C -> C^op, and so such a functor can't be an isomorphism.
16:53:30 <ezyang> "Left as an exercise for the reader."
16:54:05 <ezyang> Most powerful proof method evar
16:54:22 <copumpkin> it helps if you know whether the statement is true or not
16:54:28 <Cale> hehe
16:54:28 <monochrom> Not the most powerful proof method.
16:54:50 <monochrom> "see standard texts for proof" is more powerful
16:54:50 <Cale> Proof by vigorous hand-waving
16:54:53 <ezyang> See also, "It is obviously the case"
16:55:05 <ezyang> monochrom: Heh, excellent :-)
16:55:31 <Cale> Proof by personal correspondence with authority
16:55:37 <copumpkin> lol
16:56:36 <olsner> Proof by personal correspondence with deity
16:57:30 <Cale> I discussed this with Cal'gath'u, the grain father, and he assured me it was so.
16:57:40 <copumpkin> QED?
16:57:59 <copumpkin> or maybe that little square I can't type
16:58:25 <copumpkin> ■?
16:58:40 <copumpkin> take a ◉ instead
16:58:40 <Cale> ⬜
16:58:53 <mauke> □
16:59:03 <copumpkin> Cale's is bigger than mauke's
16:59:07 <Cale> ◑_◑
16:59:08 <tensorpudding> ∎?
16:59:19 <mauke> ツ
16:59:21 <tensorpudding> also known as END OF PROOF
16:59:28 <copumpkin> シ
16:59:41 <aristid> proof by japanese smiley?
16:59:41 <copumpkin> tensorpudding: sounds about right
16:59:47 <copumpkin> シツ
17:00:00 <tensorpudding> It's not a smiley
17:00:01 <copumpkin> i like me some shitsu
17:00:06 <mauke> ヾ
17:00:11 <Cale> ⤽_⤽
17:00:22 <copumpkin> @remember Cale ⤽_⤽
17:00:22 <lambdabot> It is stored.
17:00:25 <monochrom> ⬠
17:00:30 <aristid> tensorpudding: it's japanese and it's a smiley, therefore it is a japanese smiley■
17:00:33 <tensorpudding> TOP ARC ANTICLOCKWISE ARROW WITH PLUS
17:00:48 <tensorpudding> heh
17:00:49 <copumpkin> aristid: it's a japanese character that happens to look rather smileyish
17:01:26 <aristid> copumpkin: i know :P
17:01:28 <copumpkin> aristid: not sure that's the right little square btw
17:01:30 <sproingie> ☠ arr
17:01:34 <aristid> :(
17:01:41 <tensorpudding> Heh
17:01:41 <aristid> not using the right little square = bad :(
17:01:54 <copumpkin> ∐
17:01:58 <jesusabdullah> since I think it kinda got lost in the noise: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25486#a25487 :/
17:02:07 <jesusabdullah> thanks to anyone that has any ideas :)
17:02:29 <copumpkin> ↭↬↪↫↨↩↶
17:02:36 <Cale> ⏕
17:02:41 * jesusabdullah squints
17:02:42 <copumpkin> (for Control.Arrow)
17:02:44 <Saizan> jesusabdullah: mh, can you try without being root?
17:02:58 <jesusabdullah> Saizan: I guess so?
17:03:01 <jon_of_arc> 凸凹
17:03:04 <mauke> ←↑→↓⌁⌃⌄↔↕↖↗↘↙↜↝↯⇇⇈⇉⇊⇐⇑⇒⇓⇚⇛⇜⇝⇠⇡⇢⇣⇦⇧⇨⇩⇶➙➡➤⟰⟱⟵⟶⤊⤋⤙⤚⬅⬆⬇⬱⭅⭆⽮￩￪￫￬˂˃˄˅⃪͎͔͕⃮⃯͐᷾⃔⃕⃖⃗↚↛↞↟↠↡↢↣↤↥↦↧↩↪↫↬↭↶↷↺↻⇄⇆⇔⇕⇖⇗⇘⇙⇤⇥⇮⇳⇽⇾➘➚➛➝➧➩➳➵➺➼➾⟲⟳⟷⟸⟹⟿⤌⤍⤎⤏⤒⤓⤛⤜⤺⤻⥀⥁⥇⥹⥺⥻⦽⬀⬁⬂⬃⬄⬈⬉⬊
17:03:07 <copumpkin> those are real characters
17:03:10 <mauke> ⬌⬍⬳⬾⭄𐇙˯˰˱˲˿͍⃡͢↨↮↰↱↲↳↴↵⇅⇍⇏⇞⇟⇪⇫⇰⇱⇲⇴⇵⇷⇸⇿⎋➔➜➞➟➪➲➴➶➸➻➽⟴⟺⟻⟼⤆⤇⤈⤉⤑⤝⤞⤣⤤⤥⤦⤧⤨⤩⤪⤭⤮⤱⤲⤳⤸⤹⤾⤿⥂⥃⥄⥅⥆⥱⥲⥳⥴⥶⥷⥸⧪⧬⧭⨗⬎⬏⬐⬑⬰⬲⬸⬿⭀⭃⭉ꜛꜜ𐃇͖᷿↸↹⇎⇯⇹⇺⇻⌤⍇⍈⍐⍗⍼➠➢➣➨➫➬➭➮➯➱➷➹⟽⟾⤂⤃⤅⤐⤔⤖⤡⤢⤯⤰⤴⤵⤶⤷⤼
17:03:15 <tensorpudding> aaaagh
17:03:16 <mauke> ⤽⥈⥰⥵⦳⦴⬶⬷⬹⬻⭁⭇⭊⭋⭌⇼➥➦⤀⤄⤕⤟⤠⥉⬴⬺⭂⭈⇬⇭⤁⤗⬵⬼⤘⬽⦨⦩⦪⦫⦬⦭⦮⦯
17:03:17 <tensorpudding> what the hell
17:03:22 <monochrom> Is that a binary proof format? :)
17:03:25 <aristid> jesusabdullah: don't forget to make sure your user can write to $HOME/.ghc and $HOME/.cabal
17:03:29 <olsner> was that SJIS?
17:03:31 <Cale> mauke: Your encoding was shot there for a couple lines
17:03:34 <mauke> crap
17:03:39 <copumpkin> gokoboko?
17:03:45 <tensorpudding> the first two things you sent turned into twenty lines of gibberish
17:03:48 <jon_of_arc> Deko, yes.
17:03:53 <olsner> copumpkin: mojibake?
17:03:58 <mauke> excellent
17:04:00 <copumpkin> deko, whoops
17:04:08 <jesusabdullah> Saizan: Why not-root? Keep in mind, I'm relatively unfamiliar with haskell
17:04:08 <mauke> I know exactly what went wrong
17:04:17 <jesusabdullah> Used to yum, apt-get and the like
17:04:20 <Cale> They were eaten by the mojibakemono
17:04:34 <copumpkin> lol
17:04:35 <jesusabdullah> huh! Seems to be working better
17:04:40 <jesusabdullah> now I'm just missing lapack
17:05:00 <Saizan> jesusabdullah: well, cabal-install is generally used with an unprivileged user, so i expect it to be more reliable in that case.
17:05:10 <copumpkin> 文字化物語?
17:05:10 <jesusabdullah> huh!
17:05:14 <jesusabdullah> Interesting.
17:05:32 <tensorpudding> there are separate symbols for centigrade and celsius apparently
17:05:40 <tensorpudding> ℃ vs ℃
17:05:46 <copumpkin> I'm glad
17:05:53 <copumpkin> couldn't have people confusing the two
17:05:57 <jesusabdullah> OUTRAGEOUS
17:05:58 <Saizan> it install things under your $HOME by default, registering libraries in the user db, under ~/.ghc, and putting files under ~/.cabal
17:06:05 <jesusabdullah> hmm
17:06:06 <Cale> 文字化け物
17:06:10 <mauke> tensorpudding: those were both celsius
17:06:26 <tensorpudding> Oh, wait.
17:06:32 <tensorpudding> They are the same.
17:06:43 <jesusabdullah> I guess that's what I'll have to do
17:06:49 <tensorpudding> Degrees Centigrade is an old name which is acceptable to mean Degree Celsius
17:06:53 <jesusabdullah> idk, I kinda like system-wide installing
17:07:04 <jesusabdullah> except when I don't have root
17:07:09 <jesusabdullah> then I hate it a lot!
17:09:35 <Saizan> jesusabdullah: system-wide installations should be done passing --global --root-cmd=sudo
17:09:47 <Saizan> jesusabdullah: otherwise you'll do root-local ones, i think
17:10:11 <jesusabdullah> huh!
17:10:31 <jon_of_arc> I don't think so, it seems to have worked for me thus far
17:10:37 <jesusabdullah> same
17:10:51 <jesusabdullah> but if that's more proper, then I'm down!
17:11:26 * wli is impressed with some of the new nicks
17:12:06 <wagle> why was mauke apparently quoting proofs from principia mathematica?
17:12:07 <DangerfieldMachi> Hmm, too long
17:12:21 <Makoryu> wagle: He's just badass like that.
17:12:31 <wagle> rofl
17:12:33 * Makoryu puts on sunglasses in a vain attempt to look as cool as mauke
17:13:14 <Cale> æ–‡å—åŒ–ãミ＼（＾ロ＾）ノ　文字化け物は日本語を食べたい！
17:13:46 <wagle> hey, i can read 1/10 of that
17:13:56 <Makoryu> Heh, "mojibakemono"
17:13:57 <tensorpudding> THere was a control character in that
17:13:58 <Makoryu> （　≖‿≖）
17:14:03 <monochrom> I can read the æ and the Œ
17:14:12 <c_wraith> @pl \x -> f a x b
17:14:12 <lambdabot> flip (f a) b
17:14:21 <Blkt> could anyone explain me why the functions "ord" and "isLower" are not available on GHC?
17:14:22 <copumpkin> the character monster eats japanese
17:14:27 <wagle> i thought the second char was kanji for ji
17:14:34 <jesusabdullah> Saizan: How would you do that with su?
17:14:40 <monochrom> Blkt: :m + Data.Char
17:14:46 <copumpkin> that feels like it should be in lolcat
17:14:52 <Makoryu> Blkt: They're not in the Prelude, that's all
17:14:58 <c_wraith> monochrom: he didn't say ghci
17:15:20 <Saizan> jesusabdullah: maybe --root-cmd="su -c"
17:15:26 <jesusabdullah> that's what I tried
17:15:28 <jesusabdullah> OH WELL
17:15:33 <jesusabdullah> seems to be working at the local level
17:15:39 <monochrom> strings and quoting are so passe
17:15:43 <jesusabdullah> I'm the only user on this computer (my laptop) so
17:15:48 <jesusabdullah> who cares right? :v
17:15:54 <Saizan> right :)
17:15:54 <copumpkin> damn right
17:16:00 <jesusabdullah> showertime!
17:16:03 <tensorpudding> extra right
17:16:21 * jesusabdullah wonders if he'll ever get to properly say hello to pik
17:16:27 <Blkt> Makoryu: my book say otherwise, that's what was bothering me
17:16:35 * jesusabdullah &
17:17:02 <Makoryu> Blkt: GHC Haskell is not proper Haskell 98 these days
17:17:40 <kmc> the Haskell 98 module to provide those would be Char
17:17:46 <kmc> but you should probably use Data.Char
17:18:05 <copumpkin> hierarchy is so passé
17:18:13 <monochrom> ord and isLower are not in Haskell 98 Prelude.
17:18:37 <wli> copumpkin: It's all about the fully functorial style. How that's accomplished in Haskell is the secret.
17:19:22 <Cale> I think that before Haskell 98 was out, hugs has ord and isLower in its Prelude... maybe.
17:20:12 <Cale> My memory is a bit hazy, and I didn't really start learning Haskell until a few years after that, but I remember there being a lot of tutorials and books which assumed some of that stuff was in the Prelude.
17:20:27 <Cale> had*
17:20:35 <copumpkin> omg, there was a time when Cale was not using Haskell???
17:20:50 <copumpkin> sounds fishy to me
17:20:53 <Cale> heh
17:21:06 <tensorpudding> Cale had written a monad tutorial before leaving the womb
17:21:17 <Cale> I actually knew a whole lot of imperative languages before I started with Haskell.
17:21:21 * wli predated Haskell 98 also
17:21:25 <Makoryu> tensorpudding: When he was but a wee nooblet?
17:21:32 <copumpkin> there's a fair amount of fun monad/sex potential out there
17:21:35 <copumpkin> I explored it a while back
17:21:40 <Makoryu> Cale: And now you've forgotten them all, yes?
17:21:48 <uorygl> > { 3 }
17:21:49 <lambdabot>   <no location info>: parse error on input `{'
17:22:01 <Cale> Makoryu: Almost. I'm working on it.
17:22:07 <dolio> @t do { 3 }
17:22:07 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:22:13 <dolio> @type do { 3 }
17:22:14 <lambdabot> forall t. (Num t) => t
17:22:23 <dolio> Oh, they fixed that.
17:22:29 <uorygl> @type {undefined; 3}
17:22:30 <lambdabot> parse error on input `{'
17:22:32 <Cale> It pains me to see people learning C anew.
17:22:35 <uorygl> @type do {undefined; 3}
17:22:36 <lambdabot> forall (m :: * -> *) b. (Monad m, Num (m b)) => m b
17:22:55 <Cale> Or PHP, haha.
17:22:58 <uorygl> I find it strange that people would actually write stuff in C these days.
17:22:59 <dolio> That actually requires Monad, because it desugars to 'undefined >> 3'.
17:23:03 <tensorpudding> Why not learn C?
17:23:17 <uorygl> Learning it is fine, but there's no reason to use it.  :P
17:23:22 <dolio> Because C++ is so much better.
17:23:23 <Cale> tensorpudding: Well, there's less harm if you're already a Haskell programmer, I suppose.
17:23:25 <tensorpudding> Tons of stuff is written in C
17:23:26 * wli only knew C/C++/Java until making a concerted effort to learn numerous languages, which centered mostly around functional languages, albeit with some Prolog derivates sprinkled in.
17:23:33 <Cale> tensorpudding: But it teaches you how to do everything the wrong way.
17:23:45 <uorygl> Nothing is dynamic.  You have to specify how big everything is, and it's not very easy to make stuff bigger or smaller.
17:24:00 <tensorpudding> If you wnat to do kernel development or embedded stuff you probably need to learn C.
17:24:05 <stroan> I think C doesn't really teach you to do anything any way. It's a pretty thin abstraction over the hardware
17:24:12 <wli> MIPS and SPARC asm too, if you count them as languages.
17:24:15 <Makoryu> Most of the people writing code in C are doing so for the wrong reasons. That doesn't mean that all possible reasons to learn or use C are wrong.
17:24:20 <copumpkin> hey, in c99 I can have dynamically sized (for some notions of dynamic) stack arrays
17:24:27 <Cale> tensorpudding: Not necessarily, but in a de-facto sort of sense, granted.
17:24:42 <monochrom> C is so close to hardware that it loses the overflow flag.
17:24:50 <tensorpudding> Looking at C as an application language is somewhat problematic though.
17:24:59 <systemfault> VLA are a dumb dumb... idea
17:25:17 <Cale> stroan: It teaches people to write programs without using the abstractions that make it manageable to write correct programs.
17:25:19 <copumpkin> I kind of like them
17:25:59 <uorygl> Programming languages fall on a spectrum from V to P.  V languages, like Verilog and VHDL, are extremely close to the hardware and also quite difficult to use.  P languages, like Python and... probably Perl, are relatively far from the hardware but relatively easy to use.
17:26:15 <tensorpudding> THere is more to it than that.
17:26:26 <copumpkin> nope, it's that simple
17:26:27 <uorygl> No, that's definitely everything.  :P
17:26:33 <Makoryu> uorygl: That's way totally, like, oversimplified, bro.
17:26:36 <tensorpudding> There are plenty of abstract languages that are not "easy to use"
17:26:37 <jon_of_arc> No, languages are also taller or shorter
17:26:38 <wli> uorygl: What are V and P supposed to stand for?
17:26:43 <monochrom> There is the H band beyond the P band. And there is the A band beyond the H band.
17:26:55 <jon_of_arc> That doesn't affect anything about their use, but it's fun to make fun of languages for being short.
17:26:58 <uorygl> V is supposed to stand for Verilog, VHDL, etc.; P is supposed to stand for Python, Perl, PHP, etc.
17:27:07 <copumpkin> pruby?
17:27:07 <dolio> And Ruby.
17:27:14 <monochrom> H is haskell and A is agda.
17:27:16 <uorygl> R is just a P with an extra line.
17:27:22 <ClaudiusMaximus> i like C, given judicious CPP usage to make it bearable - but i think learning how to program on an OS without memory protection helped me code better (because one mistake => reboot)
17:27:26 <ezyang> Clearly more evolved.
17:27:32 <copumpkin> now for a deep philosophical question
17:27:37 * wli should learn Agda and some other dependently-typed languages.
17:27:38 <copumpkin> is haskell higher level than agda or vice versa?
17:27:47 <uorygl> Actually, R is male and P is female; neither is more evolved than the other, since they share genes.
17:27:52 <stroan> Cale: I'm not sure if that's C's fault. Not imposing a paradigm is not the same as teaching a faulty paradigm.
17:27:56 <Cale> A friend of mine (who I taught Haskell as her first programming language) is taking a programming course in university now where they're using C, and they have her doing stuff like map head . group with in-place mutation of arrays using pointers.
17:27:59 * wli took a stab at Cayenne a while back but never got anywhere.
17:28:17 <tensorpudding> I don't think there is a true well-ordering on programming languages by "higher level"
17:28:24 <uorygl> The existence of Haskell makes me want to reconsider the spectrum.  It makes it easy to shuffle data around, but it's also quite static.
17:28:27 <BackInAcTion> main = do { putStrLn "Hello, World" }
17:28:29 <copumpkin> tensorpudding: nope, there clearly is
17:28:31 <Cale> Which I think is basically a good way to teach people the wrong way of doing things.
17:28:54 <monochrom> languages are not well-ordered by level. it's microcode all the way down
17:29:05 <Cale> Maybe they'll all realise that it's just way too hard to get such things right, but for anyone in that course who hasn't had exposure to proper programming languages, they might not know better.
17:29:06 <dolio> They should be using good-old C linked lists.
17:29:07 <tensorpudding> How do you justify which one is higher level?
17:29:08 <Saizan> copumpkin: Agda would be higher level if the termination/productivity checker could handle HOFs!
17:29:12 <BackInAcTion> if I put that in a file called simple.hs and compile it with ghc --make simple.hs, then run it, it works
17:29:26 <wli> Cale: There are real, serious, legitimate points to doing things like that, though torturing freshmen and/or other pedagogy is not it.
17:30:08 <stroan> I think on small projects, the likes of which you find in university courses, most languages will be used poorly. It takes experience of scale to really drive home the implications of these design decisions.
17:30:13 <stroan> I have seen some terrible terrible haskell
17:30:15 <stroan> but it worked
17:30:18 <stroan> and was fine for university
17:30:31 <BackInAcTion> oh, nvm
17:30:52 <wli> stroan: My critique of C is probably rather unusual.
17:30:54 <aristid> @hoogle group
17:30:55 <lambdabot> Data.ByteString group :: ByteString -> [ByteString]
17:30:55 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
17:30:55 <lambdabot> Data.ByteString.Char8 group :: ByteString -> [ByteString]
17:31:59 <Makoryu> http://james-iry.blogspot.com/2010/05/types-la-chart.html <- I'll just leave this right here
17:32:25 <Cale> Generally I've seen very good results as far as producing programmers who have a sense for doing the right thing by teaching Haskell first though.
17:32:44 <systemfault> Makoryu: He's so wrong about C# though..
17:33:04 <stroan> well, can't argue with results :D
17:33:07 <Makoryu> systemfault: So tell him so?
17:33:09 <dolio> Unpossible! They need to learn to manage memory manually!
17:33:10 <wli> The thing that hurts C the worst is its module system.
17:33:20 <systemfault> Makoryu: Nope... Not interested, I don't know him.
17:33:25 <wli> (or lack thereof)
17:33:36 <systemfault> wli: So true.. And C++ inherits the same flaw.
17:33:53 <dolio> C++ has namespaces at least.
17:34:01 <Cale> wli: I'm not sure I wholly agree with that. While the lack of a module system is painful, I don't think that adding one would help much.
17:34:05 <Makoryu> systemfault: There are annotations concerning C# in the post, and there's a comments system for saying "U HAVE FUQIN ANGERED AN EXPERT PROGRAMMER"
17:34:22 <Cale> Because of various other flaws in C's model of abstraction.
17:34:55 <dolio> Lack of parameterized types seems more painful these days.
17:34:56 <systemfault> Makoryu: Haha, I'm not an expert :)
17:35:21 <wli> Cale: Well, kernel experience seems to point to less grand sorts of things.
17:35:44 <dolio> Copy and paste the definition of linked lists 10 times manually with minor variations.
17:36:18 <wli> dolio: That particular one is gotten around by the weakness of the type system.
17:36:36 <monochrom> this is why c has a macro system too. and this is why c++ 1.0 was possible. XD
17:36:48 <dolio> Yeah, you can use void*, I guess.
17:37:01 <Cale> One of the major flaws, as I see it, is the fact that since the memory management is manual, there are various ways of handling it. If you call a function and receive a pointer to a newly allocated value, there's no way of telling for certain without reading documentation whether you're responsible for the memory, or the library is.
17:37:06 <wli> dolio: B trees where objects are embedded in the metadata etc. are substantially more painful (void * doesn't fly).
17:37:22 <Cale> and there can be "impedance mismatches" in that regard, which make it difficult to use separate libraries together
17:37:24 <dolio> I fooled around with MUD code written in C way back in the day, though, and they had probably 6 or 7 different linked list types.
17:37:55 <Cale> That problem wouldn't go away with the addition of a module system.
17:38:00 <wli> dolio: It does happen. Linux' way is cleaner, though.
17:39:29 <Cale> and then, even if you cure that problem, you still have the modularity problem that essentially every imperative program has: there's no way to tell, again without looking at the documentation, if you have a pointer to some value, whether that value will change behind your back or not, in response to various calls to a library.
17:40:31 <Cale> and those sorts of problems, while subtle, make it difficult to write reusable libraries
17:41:21 <danharaj> Cale: there's also the fact that despite the low level primitives, a user can't even specify how a library should allocate on the heap.
17:41:38 <Draconx> s/library/crappy library/
17:42:02 <danharaj> case in point: Standard template library. Allocators are per class instead of per object.
17:42:04 <copumpkin> danharaj: sometimes you can give a library a function pointer to your allocator
17:42:30 <copumpkin> gmp allows that, for example
17:42:39 <Draconx> danharaj, well, STL isn't a C library.
17:42:56 <copumpkin> people in the c++ channel will bite your head off for calling it STL, too
17:43:10 <Makoryu> Draconx: D... do you mean.... C and C++ aren't the same language?!
17:43:12 <monochrom> what should I call it?
17:43:14 <ezyang> Is it sufficient for me to say "If I have some property that holds for all A in a category, then the isomorphic functor on A, F(A), means this property holds for all A' in the isomorphic category."
17:43:17 <danharaj> I thought this was a discussion of imperaitve languages in general.
17:43:28 <danharaj> But also there's that C libs don't have any obligation to play with you.
17:43:40 <gwern>  lambda: the ultimate imperative
17:44:02 <danharaj> copumpkin: Why would they do that?
17:46:14 <aristid> danharaj: they definitely do. try it out :P
17:46:25 <systemfault> C++0x has lambdas :P
17:46:37 <Cale> ezyang: So long as that property is categorically expressible in a certain sense. An isomorphism F: C -> D means that any diagram which commutes or fails to commute in C will have an image in D which commutes or fails to commute correspondingly, and any pair of objects or arrows which are equal or not equal in C will have the same hold of their images.
17:46:40 <danharaj> Yeah, lambdas but not first class functions go figure.
17:46:46 <gwern> systemfault: I have a long-standing expectation that they'll turn out to be horribly broken in some way
17:47:01 <gwern> we just don't know hopw
17:47:23 <gwern> downard funargs problem? upwards? maybe c++ will invent a 'sideways funarg problem'
17:47:25 <systemfault> gwern: They're not super elegant but they make the standard library algorithms a lot easier to use
17:48:03 <kmc> @remember gwern downard funargs problem? upwards? maybe c++ will invent a 'sideways funarg problem'
17:48:04 <lambdabot> It is stored.
17:48:11 <danharaj> systemfault: So would first class functions :|
17:48:26 <systemfault> Yeah..
17:48:47 <aristid> danharaj: there are reasons why c++ does not allow first class functions, and if you want first class functions, don't use it
17:48:59 <kmc> cool, #haskell is arguing about C++
17:49:04 <kmc> how unusual
17:49:09 <aristid> kmc: that happens fairly regularly.
17:49:23 <Saizan> it didn't happen for quite some time
17:49:29 <monochrom> kmc is being sarcastic. everyone knows it happens daily
17:49:30 <Cale> We have known efficient implementations of first class functions for 40 years now, and we've been aware of their usefulness for expressing programs possibly for longer than electronic computers have existed. If the language you're using to write software today doesn't support them, you really have to take a hard look at why you're using it.
17:49:53 <kmc> i don't believe there are good reasons to disallow first class functions in C++.  to require that the memory for closures be managed manually, sure.  that's the same as all memory in C++, and it's how lambda works in C++1x
17:49:53 <Saizan> or maybe i'm just asleep when the C++ programmers are around lately..
17:49:59 <gwern> damn plebes! they're why we can't have nice things!
17:50:20 <kmc> basically you see this design pattern over and over in C++ where you make a class to represent a closure and explicitly copy free variables and blah blah blah fucking blah
17:50:48 <Cale> Yeah, implementing closures by hand is not really an acceptable substitute for functions.
17:50:49 <kmc> the C++1x lambda makes closures that are functionally equivalent.  it just eliminates a huge pile of boilerplate
17:50:58 <gwern> kmc: so... one is acting as a human compilter for a more powerful language?
17:51:07 <kmc> gwern, that's what it's like to program in C++ (or Java)
17:51:15 <monochrom> because higher-order functions are not taught in highschool
17:51:28 <kmc> they are if you learn differential calculus in high school
17:51:36 * gwern was about to say
17:51:39 <aristid> kmc: c++1x lambdas basically are as far as you can go into that direction without changing the c++ memory model
17:51:46 <kmc> yes aristid
17:51:48 <Cale> (Part of the reason why I really want people to stop referring to "closures" as a language feature is in that.)
17:52:03 <kmc> and for all their complication (close by const volatile reference?), they make sense in the context of C++ memory model
17:52:16 <kmc> anyway, if you think C++ should not have first-class functions, then you also need to a) disown this design pattern of building closure classes yourself, b) disown the C++1x feature
17:52:41 <aristid> huh? what does first-class mean anyways?
17:52:44 <Cale> (For those who haven't heard that rant of mine: closures are not a language feature, they're a possible means of implementing a language feature)
17:52:48 <systemfault> You can make fun things with C++0x :P
17:52:56 <systemfault> std::function<int(int)> fib = [&](int n) -> int {return n <= 1 ? n : fib(n - 1) + fib(n - 2); };
17:52:59 <systemfault> :)
17:53:00 <danharaj> aristid: A function is a value you can pass around, define functions of, etc.
17:53:00 <Cale> aristid: Means they can be treated as any other values in the language.
17:53:02 <kmc> because (b) counts as first-class functions in my book, and (a) is equivalent to (b) at runtime
17:53:32 <aristid> Cale: and how precisely does it differ from being able to treat pointers to functions as values?
17:53:41 <Cale> aristid: In that you can pass them as parameters to functions, return them as results of functions, store them in data structures, and so on.
17:53:44 <kmc> aristid, pointers to functions don't capture free variables
17:54:04 <kmc> aristid, why do people build "functor" objects with state instead of using bare function pointers or state-less classes?
17:54:06 <aristid> kmc: capturing free variables isn't 100% possible in the c++ memory model.
17:54:18 <aristid> that's what i meant with "c++ can't have it"
17:54:20 <kmc> aristid, why not? you can capture by value, reference, or pointer
17:54:32 <danharaj> Are you talking about the undefined memory model it had or the new memory model in the new standard.
17:54:32 <kmc> C++1x lambda is *just* sugar for the common design pattern you find in the wild today
17:54:39 <ville> Let's just agree that C++ is superior.
17:54:41 <kmc> FP is so useful that people do it even when it's insanely cumbersome
17:54:48 <kmc> and C++1x makes it a little less cumbersome
17:54:56 <Cale> aristid: Function pointers differ from functions proper in that functions capture the values of free variables in their definition from the scope in which they're defined.
17:54:58 <aristid> kmc: well in that case c++1x lambdas are first-class functions?
17:55:08 <kmc> aristid, yes
17:55:15 <Pseudonym> Not quite.
17:55:19 <kmc> aristid, or to be pedantic: "lambda" is the name of the syntax which gives you a first-class function
17:55:30 <Pseudonym> boost::function or whatever its C++1x equivalent is is a first-class function.
17:55:32 <kmc> just as "string literal" is the name of the syntax for a value which you might call a constant string
17:55:53 <aristid> Pseudonym: std::function
17:55:57 <Pseudonym> Figured.
17:56:11 <kmc> each syntactic occurrence of lambda in C++1x will (probably) give rise to an anonymous class which inherits std::function (or is convertible to or whatever)
17:56:23 <Cale> aristid: And functions differ from closures in that closures are separable into a chunk of code (or a pointer to such) and an environment which binds the free variables in that code, and functions are not.
17:56:33 <Pseudonym> C++ is full of "is convertible to".
17:56:43 <monochrom> consider this 1st-class function example in javascript: i_return_a_function(x) { var y=x+1; return function(z) { return x+y+z; }; }.  Try to translate it into C function pointers. It is not easy.
17:57:27 <Pseudonym> Right, but in C++1x, it's almost exactly as inconvenient as that.
17:57:38 <Pseudonym> You have to worry about the types, obviously.
17:57:53 <kmc> but of course you have to worry about types in a language without static types, too ;)
17:58:15 <Pseudonym> Yeah, but not in the syntax.
17:58:27 <kmc> yeah, which arguably makes them harder to worry about ;)
17:58:28 <kmc> anyway
17:58:29 <Cale> (closures can serve as an implementation of functions, and functions (with additional parameter(s) to take the environment) can be used as the code-part of closures, but the terms are distinguished by whether the environment is still separable from the code.
17:58:31 <Cale> )
17:58:34 <kmc> i think C++1x lambda should be pretty usable in combination with reference-counting smart pointers and such
17:58:47 <Pseudonym> Yeah, I agree, kmc.
17:58:59 <Pseudonym> Finally we'll be able to simplify signals and slots.
17:59:05 <kmc> when i was a C++ developer boost::shared_ptr was one of my favorite boost features
17:59:30 <QtPlatypus> kmc: What does boost::shared_ptr do?
17:59:32 <Pseudonym> About the only thing that C++ is missing that you often have to write yourself is a meta-object protocol.
17:59:43 <Pseudonym> QtPlatypus: Reference-counted GC.
17:59:54 <QtPlatypus> Ah
17:59:59 <Pseudonym> There's also boost::weak_ptr.
18:00:02 <Cale> tsk
18:00:09 <kmc> QtPlatypus, allocate with "new".  create a shared_ptr from that raw pointer.  copy the shared_ptr as many times as you want (i.e., usually you should pass it by value).  when the last copy dies, it will call "delete" on the original raw pointer automatically
18:00:39 <systemfault> Or the designated deleter
18:00:50 <kmc> yeah
18:00:51 <systemfault> A must-have.
18:01:02 <Pseudonym> Which could be "do nothing", of course.
18:01:15 <Cale> Reference counting and mark-and-sweep garbage collectors are fine, but it bothers me that they create a funny strawman argument against the performance of garbage collection in the minds of these programmers.
18:01:15 <kmc> this is the basic use, see the boost docs for intrusive weak array gonzo shared pointers or whatever
18:01:22 <danharaj> My favorite thing in C++ is RAII
18:01:26 <kmc> ugh
18:01:44 <kmc> in 99% of cases, RAII is a hack for not having first-class actions
18:01:55 <aristid> Cale: this reminds me of something in okasaki... the part where he does scheduling to move amortized expensive costs into each operation
18:02:04 <aristid> Cale: i think reference counting is like that
18:02:06 <QtPlatypus> Cale: Which programers, a good number of programers are writing in GCed langs these days.
18:02:21 <systemfault> RAII is a tool for deterministic garbage collection in C++ :P
18:02:22 <Cale> QtPlatypus: C and moreso C++ programmers
18:02:48 <kmc> RAII has the same flaw as most of Java, in that any time you need some first-class code, it has to be in its own class which you have to name (hence all the FactoryManagerFactories), in its own file, etc.
18:02:49 <Cale> QtPlatypus: It's finally starting to die out now.
18:03:13 <Cale> QtPlatypus: But there was a lot of noise back a while ago about how garbage collection is too slow.
18:03:26 <systemfault> kmc: Lamdbdas in C++0x does the job, no?
18:03:28 <Pseudonym> kmc: It's only a matter of time before someone fixes this, thanks to lambdas, boost::scoped_ptr etc.
18:03:36 <kmc> yes systemfault, Pseudonym
18:03:51 <systemfault> boost::scoped_ptr is dead ;)
18:03:58 <Pseudonym> Is it?
18:04:00 <Pseudonym> That's a shame.
18:04:00 <systemfault> unique_ptr is the new cool C++0x thing.
18:04:04 <Pseudonym> Right.
18:04:16 <kmc> and C++ classes don't *have* to be in their own files, but a lot of style docs will require that they're in *two* of their own files
18:04:17 <QtPlatypus> Cale: There was a period of time when GCing was honestly to slow.  THough with modern genrational/copying GC's that seems to be much less of an issue.
18:04:21 <Pseudonym> scoped_ptr, for those who aren't boosties, is essentially stack allocation on the heap.
18:04:30 <kmc> it's crazy to have a language where classes are the major form of abstraction, yet are so much of a pain to define
18:04:37 <kmc> i stopped hating OO when i learned Python
18:04:53 <Pseudonym> kmc: Well, that's not really what classes in C++ are.
18:04:53 <Cale> QtPlatypus: right -- but I've run into a number of people who had never even heard of such collectors and thought that mark-and-sweep was still it.
18:04:58 <Pseudonym> Classes in C++ are instantiable modules.
18:05:01 <SubStack> I started hating OO when I learned python, meanwhile
18:05:08 <kmc> heh SubStack
18:05:11 <kmc> i'm interested to know why
18:05:26 <mauke> gentlemen, as I was saying
18:05:30 <mauke> ←↑→↓⌁⌃⌄↔↕↖↗↘↙↜↝↯⇇⇈⇉⇊⇐⇑⇒⇓⇚⇛⇜⇝⇠⇡⇢⇣⇦⇧⇨⇩⇶➙➡➤⟰⟱⟵⟶⤊⤋⤙⤚⬅⬆⬇⬱⭅⭆⽮￩￪￫￬˂˃˄˅⃪͎͔͕⃮⃯͐᷾⃔⃕⃖⃗↚↛↞↟↠↡↢↣↤↥↦↧↩↪↫↬↭↶↷↺↻⇄⇆⇔⇕⇖⇗⇘⇙⇤⇥⇮⇳⇽⇾➘➚➛➝➧➩➳➵➺➼➾⟲⟳⟷⟸⟹⟿⤌⤍⤎⤏⤒⤓⤛⤜⤺⤻⥀⥁⥇⥹⥺⥻⦽⬀⬁⬂⬃⬄⬈⬉⬊
18:05:36 <mauke> ⬋⬌⬍⬳⬾⭄𐇙˯˰˱˲˿͍⃡͢↨↮↰↱↲↳↴↵⇅⇍⇏⇞⇟⇪⇫⇰⇱⇲⇴⇵⇷⇸⇿⎋➔➜➞➟➪➲➴➶➸➻➽⟴⟺⟻⟼⤆⤇⤈⤉⤑⤝⤞⤣⤤⤥⤦⤧⤨⤩⤪⤭⤮⤱⤲⤳⤸⤹⤾⤿⥂⥃⥄⥅⥆⥱⥲⥳⥴⥶⥷⥸⧪⧬⧭⨗⬎⬏⬐⬑⬰⬲⬸⬿⭀⭃⭉ꜛꜜ𐃇͖᷿↸↹⇎⇯⇹⇺⇻⌤⍇⍈⍐⍗⍼➠➢➣➨➫➬➭➮➯➱➷➹⟽⟾⤂⤃⤅⤐⤔⤖⤡⤢⤯⤰⤴⤵⤶⤷
18:05:37 <systemfault> Ahhh!
18:05:39 <kmc> on the other hand.. maybe i should hate Python's object system because it uses inheritance *only* for implementation inheritance, which is a terrible thing
18:05:41 <systemfault> Unicode flood.
18:05:42 <mauke> ⤼⤽⥈⥰⥵⦳⦴⬶⬷⬹⬻⭁⭇⭊⭋⭌⇼➥➦⤀⤄⤕⤟⤠⥉⬴⬺⭂⭈⇬⇭⤁⤗⬵⬼⤘⬽⦨⦩⦪⦫⦬⦭⦮⦯
18:05:43 <jesusabdullah> yo SubStack, hmatrix-transform had a few deprecation warnings, if you're interested
18:05:46 <wli> There are always treadmills for larger objects.
18:05:47 <Cale> heh, I like the inclusion of 矢 in that list
18:05:52 <aristid> mauke: proof by character garbage?
18:05:53 * Pseudonym wishes mauke would stop trying to hack his terminal
18:05:54 <pikhq> mauke: Your broken Unicode stream makes me terminal stab you.
18:06:01 <jesusabdullah> pikhq: Hi! :v=
18:06:04 <mauke> is it still broken?
18:06:06 <SubStack> jesusabdullah: oh really
18:06:11 <jesusabdullah> SubStack: Yeah
18:06:16 <pikhq> jesusabdullah: I know you from somewhere...
18:06:23 <Cale> Though wait, your ⽮ looks different from my 矢
18:06:28 <jesusabdullah> pikhq: comicgenesis
18:06:32 <Makoryu> pikhq: Terminal stabbing? There are laws against that...
18:06:46 <mauke> Cale: KANGXI RADICAL ARROW
18:06:48 <Cale> Oh, it's the radical
18:07:01 <mauke> Cale: does it look less broken this time?
18:07:13 <Cale> a good deal less broken, yeah
18:07:22 <QtPlatypus> kmc: There have been some arguements that only behavour should be inherted.
18:07:27 <Cale> There are a few characters there which I don't have symbols for.
18:07:39 <ezyang> Woot, proof is done.
18:07:44 <ezyang> Well, at least, the first part
18:08:27 <kmc> food, back later
18:08:37 <Cale> Specifically, the 1DFF and 1DFE show up as blocks for me.
18:08:39 <mauke> Cale: the previous splitting algorithm wasn't utf-8 aware
18:08:48 <Cale> They're apparently combining characters
18:08:51 <jon_of_arc> Python's ability to fundamentally subvert the meaning of most of what appear to be fairly basic parts of the language is very handy, but I should qualify that with the caveat that I don't know what it feels like to team with someone more skilled at such things than myself.
18:09:05 <mauke> and that message was all unicode characters whose name contains "arrow"
18:09:37 <jon_of_arc> (In other words, I haven't had to try to deal with understanding major subversions I didn't write.)
18:10:05 <QtPlatypus> mauke: Are you planning a very irratation unicode Arrow libary?
18:10:07 <QtPlatypus> irratating
18:10:31 <Makoryu> This strikes me as more of a unicode bazooka
18:10:34 <mauke> no, I already have a search-unicode-character-by-name script in my irc client
18:10:35 <uorygl> Irritating!
18:11:09 <mauke> pray I don't hit you with "*combining*" :-)
18:11:26 <Makoryu> Oh god
18:11:55 <Makoryu> mauke: You're a horrible person
18:12:01 <Makoryu> For even thinking that
18:12:01 <aristid> mauke: hit us with *functional* please
18:12:18 <mauke> ⍬⍳⍴⍵⍺⎕⌶⌷⌸⌹⌺⌻⌼⌽⌾⌿⍀⍁⍂⍅⍆⍉⍋⍍⍏⍒⍔⍖⍘⍙⍚⍛⍜⍞⍟⍠⍢⍣⍤⍥⍨⍪⍫⍭⍮⍰⍶⍷⍸⍹⍃⍄⍇⍈⍊⍌⍎⍐⍑⍓⍕⍗⍝⍡⍦⍧⍩⍯⍱⍲
18:12:24 * uorygl frowns.
18:12:26 <SubStack> I want this script.
18:12:27 <Cale> APL :)
18:12:38 <tensorpudding> Wow, there is a lot of characters in the astral plane I can view.
18:12:41 <aristid> mauke: cool
18:12:57 <aristid> nice smiley: ⍢
18:13:00 <uorygl> It looks like we pronounce "irritate" wrong.  In the Latin "irrito", the second "i" is long, so the stress should go on the penultimate syllable, not the antepenultimate.
18:13:03 <Pseudonym> tensorpudding: The astral plane is three code points in UCS-2?
18:13:24 <uorygl> And you don't know which code point corresponds to which character until you use them.
18:13:25 <aristid> uorygl: different languages stress words differently.
18:13:34 <uorygl> Except that there's a cheat you can use.
18:13:38 <tensorpudding> The astral plane are the characters that take four bytes to render, I think.
18:13:41 <tensorpudding> in UTF 8
18:13:48 <uorygl> aristid: yes, but this is how I learned English is pronounced.
18:13:50 <abens>  stress /= length in classical latin
18:13:53 <mauke> SubStack: first you need irssi-0.8.15 sources + http://mauke.ath.cx/stuff/irssi/irssi-0.8.15.patch
18:14:01 <uorygl> As you can tell, my native language is Latin.  :P
18:14:07 <gwern> why do they call it astral?
18:14:43 <aristid> uorygl: you're from romania? :P
18:14:43 <olsner> just a pun on "planes"?
18:15:12 <Pseudonym> The astral plane contains glyphs from the zeitgeist.
18:15:13 <uorygl> No, silly, they don't speak Latin in Romania.
18:15:21 <Cale> In English, things are pronounced how they're pronounced and spelled how they're spelled, and the connection between the two and any other factors is always hazy at best. :)
18:15:22 <geheimdienst> guess it's a tongue-in-cheek reference to dungeons & dragons ... http://en.wikipedia.org/wiki/Astral_plane
18:16:15 <aristid> uorygl: oh i was stupid. obviously you were born in vatican city
18:16:22 <uorygl> Of course.
18:16:30 <Pseudonym> Or Latin America, according to Dan Quayle.
18:16:39 <abens> also, there were periods when the British elite felt English wasn't fancy enough (inferior to French) and made e.g. spelling more pretentious
18:16:53 <Makoryu> Ecclesiastical Latin is about as Latin as British Latin
18:16:54 <mauke> see also: metre, colour
18:16:56 <Pseudonym> abens: It's mostly because English is a mongrel.
18:16:59 <abens> religious Latin /= classical Latin
18:17:06 <gwern> go mongrels! hybrid vigor
18:17:11 <aristid> abens: at least it has latin in the name
18:17:16 <uorygl> I guess I was born in Ancient Rome.
18:17:20 <Pseudonym> English is partly Germanic, partly Celtic and partly French.
18:17:28 <aristid> uorygl: in cato's home?
18:17:34 <Pseudonym> And that's just the main influences.
18:17:37 <Cale> geheimdienst: Which in turn is a tongue in cheek reference to old metaphysical nonsense :)
18:17:49 <dolio> Weni, widi, wiki.
18:17:54 <uorygl> Dionysius Cato?
18:17:57 <mauke> per aspera ad astra
18:18:02 <abens> Old English: tire (for the round thing), Contemporary British English: tyre
18:18:19 <abens> silly but it does look kind of pretty
18:18:20 <Makoryu> Pseudonym: That's a fun urban legend, but it's not linguistics.
18:18:28 <tensorpudding> Hmm, Unicode is said to be divided into several planes, each containing 2^16 characters.
18:18:31 <Pseudonym> http://anglish.wikia.com/wiki/Headside <- Some people have too much time.
18:18:43 <mauke> old english: riddim, contemporary british english: rhythm
18:18:50 <uorygl> Why do the British have the spellings "offence" and "defence"?  They don't seem to make much sense.
18:19:06 <Pseudonym> Makoryu: Urban legend?  Not really.  It's a gross-oversimplification, but it's accurate if you squint a lot.
18:19:09 <tensorpudding> Apparently "astral plane" is used to denote all planes except for the first plane
18:19:22 <Pseudonym> uorygl: They make perfect sense.  It's "c" if it's a noun and "s" if it's a verb.
18:19:27 <Pseudonym> So you license something, but you get a licence.
18:19:34 <Makoryu> Pseudonym: It's only accurate if you consider "language" to mean "vocabulary"
18:19:40 <Pseudonym> Actually, no.
18:19:52 <Pseudonym> English syntax is closer to Brythionic Celtic than to anything else.
18:19:53 <abens> mauke: what's your point?
18:20:05 <Pseudonym> I think.
18:20:15 <Pseudonym> But I take your point.
18:20:25 <mauke> abens: don't have one
18:20:27 <Pseudonym> Language is not independent of culture.  You only need to look at Esperantists to see that.
18:20:48 <gwern> 'The Banded Folkdoms of Americksland (BFA) is the most dwelt-in land in the landstretch of North Americksland. Its makeup is that of an evenly banded rike, with three branches of rike: the Leaderly, the Lawmootly, and the Lawlordly. The foremost tongue in the land is English, though some Spanish is spoken also. '
18:20:52 * Pseudonym made the mistake of wandering into #esperanto once, and discovered that one of the rules was "Don't crocodile"
18:20:55 <gwern> what
18:20:59 <uorygl> gwern: ooh, I love the Anglish Moot!
18:21:19 <uorygl> If you select people randomly, you will find that language and culture are not independent variables.
18:21:24 <tensorpudding> The first plane, the Basic Multilingual Plane, contains almost all modern languages that Unicode supports, and the majority of CJK ideographs
18:21:44 <geheimdienst> how big is the bmp again, 16 bits?
18:21:45 <Pseudonym> Well, "Ne krokodilu", but still.
18:21:59 <mauke> Pseudonym: what
18:22:02 <tensorpudding> 2^16, yeah
18:22:09 <Pseudonym> "To crocodile" is, apparently, to speak a native language in the company of Esperanto speakers.
18:22:24 <tensorpudding> 0x0000 to 0xFFFF
18:22:27 * Makoryu drags Pseudonym and the linguistics discussion to #haskell-blah
18:22:33 <Pseudonym> The moral of the story is: Don't tell me that Esperanto is independent of culture.
18:22:37 <uorygl> Now that that discussion has been dragged away...
18:22:44 <Pseudonym> Yes.  Back to Haskell
18:22:46 <uorygl> How does the CPU know that hardware's there?
18:22:57 <Pseudonym> Which hardware are you talking about?
18:22:58 <mauke> how does a polar bear know what apples is?
18:23:03 <uorygl> A PC, I guess.
18:23:10 <jon_of_arc> It guesses.
18:23:11 <Pseudonym> It depends on how it's connected.
18:23:16 <tensorpudding> So the astral plane is the Unicode beyond the "provincial" plane that contains almost everything that people would actually use.
18:23:26 <uorygl> I seem to remember that it generally communicates with it by pretending it's RAM, but that doesn't say how it knows that it's there, unless it just looks in every possible place.
18:23:46 <tensorpudding> There are actually 17 planes, most of which aren't used.
18:24:15 <aristid> tensorpudding: the BMP isn't the only relevant plane.
18:24:16 <geheimdienst> well, wasn't unicode originally designed to be 16 bits only and later was expanded to 21 when they realized they had not enough room ...?
18:24:23 <Makoryu> geheimdienst: Yep
18:24:28 <uorygl> I still think Unicode should be 128 bits.  :P
18:24:46 <Pseudonym> uorygl, modern busses have mechanisms for probing what hardware is connected to it.
18:24:47 <tensorpudding> Astral plane is appropriate, because the whole thing feels vaguely like those complicated mystical tomes describing the multitude of gods, godesses, layers of heaven, creation myths
18:24:48 <mauke> uorygl: what, and encode font size too?
18:25:07 <Pseudonym> So ISA hardware and the like usually have to be polled.
18:25:09 <arw> geheimdienst: not quite, I think the extension above 16bit was planned from the start, but they began with the BMP.
18:25:15 <uorygl> At least encode whether it's roman or italic.
18:25:25 * geheimdienst thinks every proton on earth needs its own unicode codepoint
18:25:26 <Pseudonym> In fact, in the bad old days, you used to have to tell the game which port your soundblaster was on.
18:25:46 <Cale> geheimdienst: Only the protons?
18:25:52 <uorygl> I'm disappointed that I can't hold down some italic key and send italics over IRC.
18:26:03 <Pseudonym> But modern bus protocols have ways to autodiscover hardware.
18:26:05 <mauke> ｏｈ ｗｅｌｌ
18:26:07 <uorygl> We should have a separate Unicode character for every possible set of points in spacetime.
18:26:18 <Pseudonym> I started writing a kernel once.  It booted, and scanned for PCI devices.
18:26:21 <glguy_> uorygl: in some cases you can. #haskell blocks mirc control characters, however, with the +c mode
18:26:22 <Pseudonym> That bit actually worked, even!
18:26:28 <mauke> ʏᴏᴜ ʜᴀᴠᴇ ᴛᴏ ᴜsᴇ ᴡʜᴀᴛ ʏᴏᴜ ɢᴏᴛ
18:26:34 <Pseudonym> Then I got bored.
18:26:37 --- mode: ChanServ set +o glguy_
18:26:48 <tensorpudding> Small caps?
18:26:54 --- mode: glguy_ set -c
18:26:59 <glguy_> like so?
18:27:03 --- mode: glguy_ set +c
18:27:07 <uorygl> Bah, you only wrote a kernel?  My plans are to create an entire computer system, from the CPU up to the shell.
18:27:14 <uorygl> glguy_: is that italics?
18:27:36 <glguy_> uorygl: depends if I actually set the mode to -c before I did it
18:27:42 <tensorpudding> Wait, does that text have a highlight?
18:27:42 <uorygl> You did.
18:27:45 <tensorpudding> How did that happen?
18:27:57 <uorygl> I think that happened by using the mIRC code for italics.
18:27:59 <mauke> for irssi users: cboldc, ditalicd, bunderlineb, ablinkinga
18:28:02 <Cale> 𝘐 𝘤𝘢𝘯 𝘶𝘴𝘦 𝘪𝘵𝘢𝘭𝘪𝘤𝘴 𝘰𝘯 𝘐𝘙𝘊.
18:28:09 <uorygl> Aww, italic and blinking look identical.
18:28:25 <zachk> thos just look 2x2 zero matrices to me
18:28:28 <zachk> those
18:28:43 <tensorpudding> Do you have a special entry mode for specifying Unicode italics?
18:28:44 <Cale> zachk: There should be 4's in one of the corners.
18:28:57 <tensorpudding> Or did you use character map for that
18:29:02 <mauke> Cale: don't have those in my font :-/
18:29:27 <mauke> MATHEMATICAL SANS-SERIF ITALIC? who comes up with this stuff
18:29:45 <tensorpudding> Mathematics requires more italics! San-serif ones!
18:29:52 <Cale> Well, it makes some sense.
18:30:11 <tensorpudding> Also fraktur, double-struck, script, in small caps
18:30:16 <Cale> There are conditions under which you want italic or bold variables to mean something different.
18:30:23 <Cale> (etc. etc.)
18:30:45 <mauke> how about I use LaTeX for that
18:30:50 <Cale> What I don't understand is the mysterious omissions
18:31:06 <tensorpudding> LaTeX can't be the only medium for encoding mathematical symbols.
18:31:10 <Cale> Where is "MATHEMATICAL ITALIC SMALL H" for example.
18:31:16 <gwern> Cale: unicode has little snowmen! there are no omissions
18:31:26 <Cale> or "MATHEMATICAL SCRIPT CAPITAL B"
18:31:39 <mauke> ☃ⁿⁱ or all the superscripts
18:31:42 <Cale> They seem to have left out various points.
18:31:52 <Cale> and I don't understand why
18:31:56 <mauke> small caps lack r, I think
18:32:26 <gwern> I refuse to live in a world where unicode can include little snowmen characters and still be considered to have omissions; I am living; therefore, this is not such a world
18:32:29 <Cale> 𝚤𝚥 -- I like how there are dotless variants of i and j.
18:33:03 <mauke> İı
18:33:21 <Cale> Maybe those letters are coded for in some other section of unicode...
18:33:36 <Makoryu> Cale: Turkish needs İ and ı
18:33:58 <mauke> Spin̈al Tap
18:34:03 <Makoryu> Dunno who uses dotless j
18:34:33 <Cale> dotless i and j are used in mathematics when you combine them with various hats and spears
18:34:34 <fryguybob> dotless j composes with hat better
18:34:37 <geheimdienst> "pointless j" (ftfy)
18:34:44 <uorygl> @pointless j
18:34:44 <lambdabot> j
18:34:55 <uorygl> Why, that's correct!
18:35:10 <uorygl> Wait, maybe not.
18:35:43 <Cale> 𝕋𝕙𝕚𝕤 𝕚𝕤 𝕗𝕦𝕟
18:37:21 <Makoryu> Cale: It's a blast. But I ｆｅｅｌ　ｋｉｎｄ　ｏｆ　ｂａｄ　ａｂｏｕｔ　ｉｔ　：（
18:37:43 * uorygl †\π´ß ∑†˙ †˙ øπ†ˆø ˚\ ˙´¬∂ ∂ø∑
18:37:44 <mauke> expert programmer detected
18:37:57 <Makoryu> mauke: Back to central Europe, please.
18:38:18 <uorygl> Òø†ß øƒ †˙´ß †˙ˆ˜©ß å®´ µø∂ˆƒˆ´® ˚´¥ß≤ ßø †˙´¥ ∂øæ† ∑ø®˚≥
18:38:27 <Makoryu> Specifically, the Czech republic.
18:38:39 <aristid> uorygl: you got mauke's script?
18:38:42 <Cale> uorygl: What encoding is that?
18:38:49 <uorygl> UTF-8.
18:38:55 <Cale> okay then
18:40:54 <Cale> I wonder how much power my graphics card is dissipating.
18:41:14 <jon_of_arc> All of it
18:42:32 <uorygl> You can come up with a rough estimate by wrapping it with insulation and watching how its temperature increases over time.
18:42:44 <Cale> If the temperature sensors are to be believed, it runs at a pretty much constant 65 degrees C, but that's not saying too much, as there's just a heatsink and no fan.
18:42:48 <uorygl> Actually, no.
18:43:00 <uorygl> Submerge it in water and measure the temperature increase of that.
18:43:04 <Cale> (and we don't know how well the heatsink dissipates heat)
18:43:11 <abens> Is power dissipated?
18:43:30 <uorygl> Yes, almost all electronic components turn most of the power they consume into heat.
18:43:49 <geheimdienst> well, have you tried logarithms? http://xkcd.com/451/
18:44:19 <jon_of_arc> If we discuss power in terms of energy (rather than work), and then define dissipation to be the power that doesn't end up turning into work, it is.
18:44:42 <abens> I was thinking about capacity to do work.
18:45:03 <uorygl> Electronic components don't use energy to do work; they use it to get hot.
18:46:34 <fryguybob> You don't even need to wrap that in IO.
18:46:51 <uorygl> Yeah!  Strange, isn't it.
18:47:14 <Cale> Heh, it's funny to think of expressions being associated with a particular amount of energy being required to evaluate them.
18:47:48 <uorygl> Really, computing doesn't require energy; it's discarding information that requires energy.
18:47:54 <Cale> It would be fun to see the text of a program coloured according to that.
18:47:57 <fryguybob> If only we could launch the missiles with just heat.
18:48:25 <uorygl> You know, on mobile devices, it is quite reasonable to think of expressions in terms of how much energy is required to evaluate them.
18:48:28 <geheimdienst> you could use that to parallelize haskell programs ... "2 + 3"? costs not much energy, so it's not worth moving the computation to the other core ...
18:48:32 <Cale> fryguybob: We sort of do...
18:49:10 <aross> Is it considered bad style to include concrete examples in function docstrings? It seems common in Python but not so much in Haskell.
18:49:10 <jon_of_arc> If we could do it without a heat gradient, now…
18:49:24 <ezyang> aross: It's something that we should encourage more.
18:49:35 <ezyang> But docstring is not a good place, since it's not machine checkable.
18:49:39 <geheimdienst> aross, i hate that about the haskell docs. lots of blah and no examples
18:49:52 <Cale> Who needs examples when you have nice types? :)
18:50:06 <jon_of_arc> And the examples there are are often inscrutable
18:50:16 <abens> Cale: I would love to be able to specify operational properties that should hold over expressions wrt to some execution model
18:50:27 <ddarius> Cale: There are people looking into doing analyses to help approximate the energy consumption of code.
18:50:28 <geheimdienst> "oh, that's just a strong lax monoidal functor"
18:50:31 <ezyang> abens: Yeah, that's called Quickcheck.
18:50:44 <abens> no thats not operational
18:51:01 * ezyang goes and looks up "operational" 
18:51:25 <gwern> for some reason, I feel like linear types ought to have some relation with reversible computing and analyzing energy usage of programs
18:51:40 <ddarius> gwern: They do.
18:51:48 <gwern> \o/
18:52:08 <abens> the idea for quickcheck is to specify (what I would call) semantic properties, the most operational it gets is the within timeout I think
18:52:39 <geheimdienst> ezyang i think you're right, the examples should be machine-checkable ... in python, i believe they have a tool called doctest to check the example code in documentation
18:52:46 <ezyang> Oh I see.
18:52:55 <Cale> abens: It's just a bit funny to do that when Haskell itself doesn't specify much of anything about operational semantics.
18:52:57 <ezyang> geheimdeinst, in some ways, this would be really easy to do.
18:53:01 <ezyang> But no ones done it yet.
18:53:08 <aross> geheimdienst: I'm fairly sure there's something on Hackage that allows machine-checking of docstring examples.
18:53:33 <Cale> abens: I would really like to have other, more observable, operational backends for GHC though.
18:53:39 <abens> Cale: Exactly, and I think it would be awesome if we could *rigorously* specify operational properties
18:53:48 <geheimdienst> yeah, just make haddock recognize literate haskell in haddock strings or something like that
18:53:50 <abens> well at least some properties
18:54:07 <gwern> hm, wasn't there at least one fp lang which put resource consumption of a function into the type system?
18:54:10 <Cale> For example, a graph reduction backend, where you could watch the reduction happening in your program as an animation.
18:54:12 <ezyang> geheimdienst: Not quite sufficient, since you want to also match results.
18:54:46 <gwern> Cale: people don't enjoy watching registers change, why would they prefer graphs being reduced?
18:55:09 <Cale> gwern: Because at the moment it's kind of hard to get an intuition for the space consumption of programs.
18:55:24 <Cale> and watching graphs be reduced is a wonderful way to get that
18:55:30 <gwern> it is?
18:55:33 <Cale> Yep
18:55:36 <gwern> you watch many graphs in your day?>
18:55:57 <Cale> I've watched a few, and sometimes I even draw them out by hand.
18:56:12 <Cale> http://cale.yi.org/share/fib.png
18:56:46 * gwern thinks that must be an acquired taste
18:56:53 <ClaudiusMaximus> i made some graph reduction "music" videos
18:57:08 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
18:57:13 <Cale> ^^ check that out :)
18:57:22 * ddarius has never used "graphs" to understand space usage.
18:57:49 <Cale> It's really easy to see the difference between linear (or logarithmic really), and constant space there.
18:57:51 <Cale> er
18:57:53 <Cale> tsk
18:58:09 <Cale> I meant to put the (or logarithmic really) on the constant space, not the linear :)
18:58:24 <wlangstroth> is that what people have to do to stay sane in Hamilton?
18:58:53 <Cale> wlangstroth: hehe
18:59:16 <ClaudiusMaximus> my version looks similar! http://claudiusmaximus.goto10.org/cm/2009-06-19_untyped_lambda_calculus_interpretations_v1.html
19:00:11 <systemfault> The sound is scary
19:00:20 <ClaudiusMaximus> hehe
19:00:45 <Cale> You can think of the space used by a program as roughly proportional to the space required to draw the expression graphs as it evaluates
19:01:14 <abens> Cale: nice
19:02:13 <wlangstroth> amazing - that sounds like a cross between SETI's dream message and record scratching
19:03:56 <gwern> '    As I understand it, our central goal is to prevent someone from opening their WikiReader and seeing "GOATSE GOATSE ALL DAY LONG / GOATSE GOATSE THE GOATSE SONG".'
19:04:18 <gwern> the sad thing is, 'goatse' rhymes with enough that you could write something with it, in sooth
19:06:00 <systemfault> ClaudiusMaximus: How have you done that video?
19:07:02 <necroforest> what does goatse rhyme with?
19:07:17 <necroforest> assuming goatse is pronounced "goat-see"
19:07:24 <gwern> 'CD'
19:07:51 * Pseudonym points out that the domain name was goatse.cx, i.e. "goat sex"
19:07:59 <gwern> me, 'd', 'b'... really, any word ending in an 'e' sound is going to have a ridiculous number of rhymes
19:08:24 <ClaudiusMaximus> haskell with opengl
19:08:50 <ClaudiusMaximus> systemfault: the code is a bit ugly
19:09:03 <Cale> "You control a colorful anthropomorphic blob with an artillery cannon attached to his helmet, as you might expect."
19:09:14 <systemfault> ClaudiusMaximus: I like the result :)
19:09:20 <ClaudiusMaximus> :)
19:09:25 <gwern> Cale: certainly it wouldnt be attached to his groin
19:09:29 <gwern> oy good glavin!
19:09:44 * geheimdienst just realized claudiusmaximus wasn't proposing "haskell with opengl" as a rhyme, but rather answering systemfault's question
19:10:03 <ClaudiusMaximus> hah
19:10:51 <ClaudiusMaximus> hm, actually that was misinformation - i do have an opengl version, but i think those videos were rendered as a sequence of SVG files
19:11:32 <ClaudiusMaximus> been so long, i've forgotton :-/
19:13:12 <danharaj> does anyone know if notepad++ has a haskell indentation plugin?
19:17:41 <geheimdienst> so uh ... if one thread blocks, the program blocks, except if i run the program with -threaded. is that right?
19:18:19 <gwern> without -threaded, there's only one thread, no?
19:18:31 <gwern> so if a thread blocks, that must mean the whole does, it seems belike
19:18:54 <aristid> @src scanl
19:18:54 <lambdabot> scanl f q ls = q : case ls of
19:18:55 <lambdabot>     []   -> []
19:18:55 <lambdabot>     x:xs -> scanl f (f q x) xs
19:18:59 <aristid> @src scanl1
19:19:00 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
19:19:00 <lambdabot> scanl1 _ []     =  []
19:19:35 <monochrom> -threaded is link-time, not run-time. with or without -threaded, the whole program won't block.
19:19:46 <ClaudiusMaximus> Cale: colourful blobs are my current project!  (not in haskell though i wish i'd chosen it over C a few times by now, and no cannons (yet)...)  http://img257.imageshack.us/img257/4333/friday.png
19:20:19 <geheimdienst> gwern, well, i tried forkIO and not passing -threaded, and that didn't work out
19:20:26 <gwern> monochrom: how does that work?
19:20:36 <monochrom> magic
19:20:50 <monochrom> more seriously, green threads
19:20:58 <gwern> geheimdienst: if you want multiple threads at runtime you need to compile with -threaded and run with +RTS -N2 -RTS etc., although I think recent ghcs may've changed that
19:21:08 <dmwit> A tight, non-allocating loop will block.
19:21:11 <ddarius> ClaudiusMaximus: Looks like a reaction-diffusions systems
19:21:19 <ClaudiusMaximus> ddarius: it is
19:22:02 <monochrom> a tight, non-allocating loop starves other threads. this is usually distinct from blocking. at least, the loop itself isn't blocked.
19:22:12 <dmwit> fair enough
19:23:22 <geheimdienst> monochrom: while looking at this section http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Concurrent.html#3 i kinda assumed if one guy blocks, the program blocks, because the kernel will only see one thread in the program, because haskell's green threads are only known to the runtime
19:23:53 <ddarius> ClaudiusMaximus: I am happy my eyes can immediately reverse-engineer a non-linear partial differential equation.
19:23:58 <geheimdienst> (and by "blocking" i mean when xmonad calls out to X and waits for the X server to give him the next event ...)
19:25:01 <dmwit> If we're talking about xmonad, you should know that -threaded is not okay.
19:25:19 <geheimdienst> yes, i was trying to avoid that :-)
19:25:30 <Cale> ClaudiusMaximus: neat :)
19:25:31 <monochrom> Then yes. But the section "Blocking" right after has more relevant and precise information.
19:25:50 <geheimdienst> i figured i'd try to fork() the whole thing, i.e. use a 2nd process (not thread). feels unixy anyway
19:26:52 <Cale> geheimdienst: GHC does pre-emptive concurrency, rather than cooperative
19:27:30 <Cale> geheimdienst: Getting blocked inside a C call is still problematic though.
19:27:38 <Cale> (in the non-threaded runtime)
19:28:27 <Cale> But all the normal blocking Haskell IO stuff is done using non-blocking I/O behind the scenes
19:28:57 <monochrom> I have just tried the doc example with GHC 6.10.4, omitting -threaded. "ghc --make s.hs". there are both "a"s and "b"s.
19:29:10 <Nereid> -threaded is what I've been looking for all this time. :(
19:29:37 <monochrom> You should pay attention to the "Blocking" section instead.
19:29:42 <geheimdienst> monochrom: yes, i was just reading about that, it's the very last section of Control.Concurrent
19:30:12 <geheimdienst> (the aaa-bbb example, i mean)
19:30:45 <monochrom> i.e., change #3 to #4
19:31:15 <geheimdienst> yep, got it
19:35:09 <gwern> @wn pidgin
19:35:11 <lambdabot> *** "pidgin" wn "WordNet (r) 2.0"
19:35:11 <lambdabot> pidgin
19:35:11 <lambdabot>      n : an artificial language used for trade between speakers of
19:35:11 <lambdabot>          different languages
19:35:18 <gwern> pidgin! I choose you!
19:36:43 <geheimdienst> incidentally, pigeon pidgin is used between pigeons that don't speak the same language
19:37:10 <geheimdienst> for trade, obviously
19:37:41 <dolio> What do they trade?
19:37:54 <tensorpudding> real estate
19:38:15 <gwern> dolio: gewgaws for their nests
19:38:26 <gwern> bibelots and other knickknacks and trinkets
19:38:31 <tensorpudding> subprime mortgages
19:38:37 <ddarius> genetic material
19:38:48 <tensorpudding> goddamn pidgeons trading in subprime mortgages
19:38:55 <geheimdienst> dudes, they can trade only things that can be expressed in pigeon pidgin
19:39:11 <geheimdienst> i doubt there's a term for "subprime mortgage" or "genetic material"
19:39:28 <geheimdienst> don't be silly
19:40:14 <gwern> geheimdienst: anything can be expressed in anything given basic turing-completeness :)
19:40:20 <gwern> the pigeons are stuck in the turing tarpit is all
19:40:26 <monochrom> but they don't even speak when trading genetic material
19:40:48 <tensorpudding> monochrom: my pidgeon pornographys says otherwise
19:41:06 <tensorpudding> coo coo coo indeed
19:41:20 <gwern> monochrom: I don't speak when trading that either. I maintain an eery silence
19:41:35 <geheimdienst> tensorpudding, in pronographys, humans are not very loquacious either
19:42:15 <gwern> my comrade's genetical material trading style is to maintain unbroken eye contact, cry, and whisper apologies over and over again
19:42:21 <tensorpudding> there is a subpidgin devoted entirely to pidgeon dirty talk
19:42:36 <dmwit> Pornography has no plural.
19:42:37 <tensorpudding> it's very gestural
19:42:51 <monochrom> A: "sorry sorry sorry"  B: "coo coo coo"
19:42:58 <geheimdienst> oh, a dirty talk dsl?
19:43:11 <gwern> pornographies
19:43:24 <geheimdienst> dmwit: yes, but pronography has
19:43:30 <geheimdienst> pronographys
19:43:49 <kmc> gotta catch them all?
19:43:49 <dolio> Pornographics?
19:44:05 <gwern> dmwit: http://www.merriam-webster.com/dictionary/pornographies
19:44:19 <gwern> kmc: I will travel the land, searching far and wide...
19:44:19 <tensorpudding> hah
19:44:21 <dolio> http://www.youtube.com/watch?v=WNw-b_5XTdA
19:44:28 <tensorpudding> i have two channels open that are talking about pidgeons
19:44:36 <kmc> gwern, thanks, now it's stuck in my head
19:44:59 <gwern> each pornography to find, its... somethings to understand
19:45:34 <gwern> @wn scumber
19:45:35 <lambdabot> No match for "scumber".
19:45:39 <gwern> @wn bescumber
19:45:40 <lambdabot> No match for "bescumber".
19:45:53 <gwern> useless!
19:46:06 <tensorpudding> @wn feduciary
19:46:07 <lambdabot> No match for "feduciary".
19:46:13 <monochrom> @wn pidgeon
19:46:14 <lambdabot> No match for "pidgeon".
19:46:22 <tensorpudding> err
19:46:29 <tensorpudding> that's not spelled right
19:46:36 <gwern> kmc: I was at a convention a few months ago; at the cosplay contest, when 2 pokemon went up, the entire audience spontaneously broke out singing the whole theme
19:46:45 <gwern> it was really awesome
19:46:59 <tensorpudding> Man, awesome isn't the right word to use.
19:47:05 <gwern> we missed a few verses, but who was keeping track?
19:47:07 <dolio> @wn fiduciary
19:47:08 <lambdabot> *** "fiduciary" wn "WordNet (r) 2.0"
19:47:08 <lambdabot> fiduciary
19:47:08 <lambdabot>      adj : relating to or of the nature of a legal trust (i.e. the
19:47:08 <lambdabot>            holding of something in trust for another); "a
19:47:08 <lambdabot>            fiduciary contract"; "in a fiduciary capacity";
19:47:08 <ddarius> tensorpudding: Depressing is.
19:47:09 <lambdabot> [4 @more lines]
19:47:16 <monochrom> You were keeping track.
19:47:47 <gwern> you haven't heard the pokemon theme until you've heard a chorus of hundreds
19:47:47 <gwern> tensorpudding: 'fiduciary'
19:48:02 <drhodes> aviary <- pidgin
19:48:12 * ddarius hasn't heard the pokemon theme at all.
19:48:19 <tensorpudding> Oh man
19:48:20 <gwern> tensorpudding: it was awesome. you can criticize us when you have your linguistic house in order!
19:48:21 <tensorpudding> Never?
19:49:00 <gwern> ddarius: well, it's not liek youtube doesn't have a bazillion copies
19:49:12 <ddarius> gwern: I'm well aware of that.
19:49:33 <ddarius> Indeed, it is related to me considering ceasing to use the internet altogether.
19:50:05 <gwern> monochrom: well, I could tell we were missing stuff because a few times the audience faltered and we weren't sure what came next. it's not as if I knew it perfectly and thus knew when we deviated
19:50:23 <gwern> http://www.youtube.com/watch?v=cbhbLrSQKyY looks like a possible hit
19:50:24 <tensorpudding> Pokemon is hardly the worst thing the Internet has to offer.
19:50:35 <ddarius> tensorpudding: I'm well aware of that fact as well.
19:50:40 <dolio> But then you come here and see people discussing monads for the 80,000th time, and it all seems worth it.
19:50:48 <ddarius> dolio: No.
19:50:54 <geheimdienst> lol
19:51:18 <monochrom> @quote monad.*array
19:51:18 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
19:51:31 <gwern> ddarius: so then why do you stay? surely not for all the porn
19:51:40 <ezyang> tis an addiction
19:52:19 <ddarius> gwern: Stay here or continue to use the internet in general?
19:52:31 <gwern> both. either.
19:54:00 <monochrom> ddarius comes here because we are awesome.
19:54:13 <monochrom> (is awesome the right word? XD)
19:54:32 <kmc> but what are monads, *really*???
19:54:42 * djahandarie sighs
19:55:23 <tensorpudding> kmc: three pounds of flax
19:55:25 <gwern> @quote monad.*really
19:55:26 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
19:55:26 <lambdabot> a really bad one
19:55:38 <gwern> @quote endofunctor
19:55:38 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
19:55:47 <wlangstroth> what, seriously? "abstract data type" doesn't do it for most people?
19:55:49 <ddarius> gwern: Occassionally something interesting come up and I try to minimize my exposure to the overwhelming amount and intensity of stupid on the internet.
19:55:51 <ezyang> ee
19:56:13 <gwern> wlangstroth: your mom is an abstract datatype
19:56:24 <geheimdienst> yeah that clears it up, copumpkin ftw
19:56:27 <gwern> I union, destructure, and enumerate her all the time
19:56:36 <alex404> Is there a built in function for applying a list of functions to a list of arguments?
19:56:48 <kmc> wlangstroth, they're not all abstract. e.g. Maybe
19:57:00 <dmwit> WTF? GHC uses megabytes not mebibytes?
19:57:02 <wlangstroth> gwern: how many times have you used that one? At least my mom's not a lax functor from a terminal bicategory
19:57:09 <gwern> wlangstroth: data YourMom = Fat | GettingJiggy
19:57:10 <kmc> the interface named "Monad" is abstract, but explaining just what it generalizes is a little tricky
19:57:27 <kmc> and worse if the person learning has already read that they're burritos and spacesuits
19:57:36 <gwern> wlangstroth: I use it surprisingly rarely. most people just say 'ADT'.
19:57:43 <kmc> alex404, pairwise?
19:57:49 <kmc> alex404, or each function to every arg?
19:57:50 <kmc> :t zipWith ($)
19:57:51 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
19:58:09 <kmc> :t \fs xs -> ($) <$> fs <*> xs
19:58:10 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f (a -> b) -> f a -> f b
19:58:17 <kmc> :t liftA2 ($)
19:58:18 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
19:58:24 <kmc> in this case f = []
19:58:47 <alex404> Cheers
19:58:50 <kmc> alex404, zipWith will give you pairwise list operations; liftA2 gives you all-to-all
19:58:54 <dolio> liftA2 ($) = (<*>)
19:59:02 <kmc> > liftA2 (,) [1,2,3] "xyz"
19:59:02 <lambdabot>   [(1,'x'),(1,'y'),(1,'z'),(2,'x'),(2,'y'),(2,'z'),(3,'x'),(3,'y'),(3,'z')]
19:59:22 <kmc> dolio, good point
19:59:23 <alex404> cool
19:59:27 <sigh> svn diff -r13442:13443 svn/reporting/rc/1.2.3rc1
19:59:55 <monochrom> > [ (1 +), (2 *), (3 -) ] <*> [a, b, c]
19:59:55 <lambdabot>   [1 + a,1 + b,1 + c,2 * a,2 * b,2 * c,3 - a,3 - b,3 - c]
20:00:00 <sigh> sorry, wrong winfdow
20:00:24 <monochrom> > liftA2 ($) [ (1 +), (2 *), (3 -) ]  [a, b, c]
20:00:25 <lambdabot>   [1 + a,1 + b,1 + c,2 * a,2 * b,2 * c,3 - a,3 - b,3 - c]
20:00:32 <monochrom> > zipWith ($) [ (1 +), (2 *), (3 -) ]  [a, b, c]
20:00:32 <lambdabot>   [1 + a,2 * b,3 - c]
20:01:22 <wlangstroth> kmc: so you're saying monads *aren't* burritos and spacesuits. How am I supposed to build my Space Burrito app now?
20:01:47 <gwern> @quote burrito
20:01:47 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
20:01:54 <kmc> wlangstroth, you'll need a more powerful abstraction.  i suggest zygohistomorphic prepromorphisms
20:02:36 <wlangstroth> what the hell? Is this where programmers go to get postmodernist?
20:02:43 <gwern> @quote zygo
20:02:44 <lambdabot> kms_ says: in C++ a for loop is magical built-in syntax.  in haskell we can define zygohystomorphic prepromorphisms in a library
20:02:46 <geheimdienst> wlangstroth, start by writing your own monad tutorial. it's the rite of initiation for every haskell programmer
20:02:52 <kmc> @where burrito
20:02:52 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
20:02:56 <djahandarie> zygohistoprepromorphism*
20:02:57 <kmc> yeah wlangstroth
20:02:59 <monochrom> perspirodemonstramorphism turns sweat into proofs.
20:03:00 <kmc> we're post-everything
20:03:03 <gwern> @quote monad.*tutorial
20:03:04 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler. They've only written a monad tutorial.
20:03:17 <tensorpudding> When can we stop beating monad's to death?
20:03:24 <kmc> when they stop being useful
20:03:30 <djahandarie> tensorpudding, right after we finish beating the horse
20:03:36 <gwern> I sometimes feel as if our conversations could be carried out solely through apposite lambdabot quotations
20:03:39 <wlangstroth> when people stop using apostrophes for plural
20:03:40 <gwern> (the Group of Seven approves!)
20:03:45 <tensorpudding> I mean, they weren't a big deal until people got the notion that you needed special tutorials for them.
20:03:47 <kmc> i'm sure we could gwern
20:03:58 <kmc>  @witty_response_number_7
20:04:12 <djahandarie> @quote djahandarie
20:04:13 <lambdabot> djahandarie says: I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
20:04:13 <kmc> but could we converse using only @vixen?
20:04:14 <kmc> or only @nixon?
20:04:17 <geheimdienst> "oh, topic 437 came up again. roll irc log from last week ..."
20:04:29 <kmc> hey guys, what do you think about C++?
20:04:31 <gwern> not meaningfully
20:04:41 <kmc> @vixen what do you think about C++?
20:04:42 <lambdabot> i dunno, what about?
20:04:42 <monochrom> if it doesn't exist, there is also a monad tutorial using it as an analogy
20:04:51 <djahandarie> Haha
20:04:51 <gwern> lambdabot: roll conversation from 2 hours ago
20:05:12 * geheimdienst writes a monad tutorial likening monads to monads
20:05:14 <wlangstroth> tensorpudding: and yet, there's not a single monad tutorial that doesn't fail to obfuscate
20:05:14 <kmc> lambdabot, play standard argument #148821998
20:05:18 <Cale> monochrom: haha, "Monads are just like god"
20:05:25 <djahandarie> Bahaha
20:05:28 <wlangstroth> haha
20:05:32 <danharaj> Clever.
20:05:34 <wlangstroth> perfect!
20:05:40 <kmc> monads are like monad tutorials
20:05:42 <djahandarie> Cale, hey, who says god doesn't exist?!?!
20:05:50 <djahandarie> kmc, didn't someone write one about that?
20:05:51 <kmc> who says monads don't exist?
20:05:52 <mamalujo> how does one dump temporary definitions from ghci to a file?
20:05:55 <kmc> djahandarie, it's been discussed here
20:06:04 <kmc> mamalujo, you can't :/  (unless you count ghci's history log as a file)
20:06:14 <Cale> mamalujo: By not making temporary definitions in ghci in the first place
20:06:21 <djahandarie> @quote moands are like monad tutorials
20:06:22 <lambdabot> No quotes for this person. You untyped fool!
20:06:25 <djahandarie> gah
20:06:26 <kmc> @quote bad.explanation
20:06:26 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
20:06:30 <djahandarie> @quote monads are like monad tutorials
20:06:31 <lambdabot> No quotes for this person. I am sorry.
20:06:34 <gwern> danharaj: regexps
20:06:35 <djahandarie> How do you work this thing
20:06:42 <danharaj> ??
20:06:46 <Cale> mamalujo: Instead, put definitions into a file, and load it into ghci. Whenever you edit the file, tap :r in ghci and it'll reload
20:06:51 <Kaidelong> @quote .
20:06:51 <lambdabot> Gracenotes says: And then the type system goes all crazy and demands that x and 1 are both Word32s!
20:06:51 <gwern> danharaj: @quote only takes a single word argument, which is a regexp
20:07:02 <danharaj> I didn't use @quote.
20:07:08 <monochrom> A: "how does one debug?"  B: "by not writing bugs in the first place"
20:07:11 <kmc> @quote 2.natural
20:07:11 <lambdabot> pumpkin says: makes the next internet hit video, 2 natural transformations, 1 functor
20:07:12 <tensorpudding> If monad metaphors are functors, what are the natural transformations?
20:07:16 <djahandarie> @quote monads.are.like.monad.tutorials
20:07:16 <lambdabot> No quotes match. I've seen penguins that can type better than that.
20:07:23 <cpettitt> lol
20:07:25 <kmc> blog posts about monad tutorials
20:07:39 <dmwit> I don't get it. How come my computer at work is so much faster on this program than my computer at home?
20:07:42 <dmwit> My home computer is a beast...
20:07:49 <kmc> ghci: shoot off screen to reload
20:07:51 <mamalujo> Cale: thx, yeah I usually do that. I was using it as a mere calculator initially, thought I had no need for a file. Its just two lines though, so it doesn't matter
20:08:06 <kmc> copy-paste them ;)
20:08:27 <wlangstroth> kmc: thank you for finding the thing that's worse than pokemon (blog posts about monad tutorials)
20:08:29 <Kaidelong> @quote .k(.s|mon.ds)\ *k.
20:08:29 <lambdabot> No quotes for this person. Do you think like you type?
20:08:39 <monochrom> You need transactional memory so you can roll-back and recover what you typed.
20:08:41 <Kaidelong> aww
20:08:53 <Kaidelong> @quote .k(.s|mon.ds)\ *a.
20:08:54 <lambdabot> No quotes for this person. stty: unknown mode: doofus
20:09:05 <Kaidelong> well neither of those worked
20:09:20 <kmc> ur regex fu no good
20:09:23 <Kaidelong> oh right
20:09:31 <Kaidelong> @quote .k(.s|mon.ds) *a.
20:09:31 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
20:09:37 <Kaidelong> ah well
20:09:38 <Cale> As a tangent, while the calculator approach works fairly well with learning Haskell, for some reason I found it didn't work at all while learning GAP, despite the fact that most of the tutorials for GAP seem to encourage this approach to using it.
20:09:42 <kmc> @. vixen quote o,uhoicerphicrepheonucuho
20:09:42 <lambdabot> I consider rabits as an endangered species.
20:09:51 <kmc> @. vixen quote
20:09:51 <lambdabot> what's worth more a flush or a full house?
20:09:51 <djahandarie> ...
20:09:54 <kmc> @. vixen quote
20:09:54 <lambdabot> like a TV program?
20:10:02 <kmc> @. vixen nixon
20:10:02 <lambdabot> i live off the men i meet
20:10:06 <kmc> @. vixen protontorpedo
20:10:06 <lambdabot> church is my favourite computer scientist.
20:10:20 <Cale> I didn't really properly begin to learn to use GAP until I stopped treating it as a calculator and started treating it as a programming language and put all my definitions into files.
20:10:22 <kmc> Cale, what's GAP?
20:10:23 <djahandarie> What is this?
20:10:26 <kmc> djahandarie, which?
20:10:37 <djahandarie> The thing you were using
20:10:39 <geheimdienst> lambdabot went postmodern, methinks
20:10:39 <Kaidelong> oh does the regex search against people rather than the quote bodies?
20:10:43 <Cale> kmc: A computer algebra system which is particularly good at computations involving groups.
20:10:44 <djahandarie> Although, interested about GAP as well
20:10:54 <kmc>  @nixon and @protontorpedo are databases of quotes from specific famous trolls
20:10:56 <Nereid> http://gap-system.org
20:11:12 <kmc>  @vixen is a chatterbot designed to convince people to cyber with lambdabot
20:11:15 <kmc>  @. is composition of lambdabot plugins
20:11:17 <kmc> and now you know
20:11:42 <djahandarie> -_-
20:11:52 <geheimdienst> "cyber" with lambdabot?
20:12:01 <monochrom> @vixen I touch you
20:12:01 <lambdabot> Most guys don't understand me, but we really seem to connect.
20:12:10 <kmc> awkward
20:12:11 <monochrom> I guess so!
20:12:16 <Cale> The one most sad thing about GAP to me is that it's built on top of a custom programming language instead of being a set of Haskell libraries.
20:12:17 <kmc> @vixen what are you wearing?
20:12:17 <lambdabot> tanktops and shorts, you?
20:12:39 <dolio> She's wearing more than one tanktop?
20:12:39 <kmc> Cale, yeah.  there's a lot of that going around
20:12:43 <geheimdienst> @vixen what's the most sad thing about gap?
20:12:43 <lambdabot> i dunno, what is it?
20:12:52 <tensorpudding> You could write bindings to GAP for Haskell couldn't you?
20:13:12 <monochrom> she wants to play strip poker with you. or strip pokemon. she needs more tanktops so the game is non-trivial
20:13:16 <Cale> tensorpudding: I'm not sure how to do it. It doesn't appear to have a decent FFI.
20:13:29 <Nereid> time to write a replacement :o
20:13:39 <Cale> tensorpudding: I suppose you could do the Sage trick, and parse GAP's output interactively.
20:13:49 <gwern> an excellent example of how homebrew languages can suck
20:13:49 <Cale> But that's ugly.
20:13:58 <tensorpudding> You could try and write a wrapper on it, but that's not terribly fun
20:14:06 <Nereid> you could try to hack an FFI onto it
20:14:24 <kmc> feature creep in config languages / UIs is such that you often end up with a bad homegrown version of Lisp or Python
20:14:28 <mamalujo> Cale: it was to calculate optimal weapons in fallout3, and a little haskell practice :)
20:14:33 <Cale> I'd really like to see it reimplemented in Haskell, but that is a ton of work, much of which I'm unqualified to do :)
20:15:00 <kmc> this is why i like to configure even trivial programs using a Lisp, Python, or Haskell script, but people look at me funny when I do
20:15:14 <ddarius> Cale: Doesn't GAP precede Haskell?
20:15:17 <Cale> mamalujo: Fallout 3 is a game which I will definitely play in a few years when I have a decent enough machine to run it under Wine.
20:15:33 <Cale> ddarius: It actually may
20:15:36 <kmc> i played it on xbox360
20:15:50 <Kaidelong> Hmm, I seem to remember a language called Icon that I quite liked a while ago
20:15:55 <kmc> aka magical game box that means you don't need windows
20:15:56 <Nereid> GAP 3 was started at  Lehrstuhl D für Mathematik of RWTH Aachen in 1986 and further developed there.
20:15:57 <Cale> Icon is a cute language
20:16:04 <Kaidelong> whose features seem to have made their way into things like C# and Python
20:16:10 <mamalujo> Cale: hm. yeah I saw its said to be slow in wine's appdb.
20:16:29 <Kaidelong> it's simple enough that if I was implementing a home grown language I might model it on that
20:16:32 <Cale> mamalujo: Well, not only that, but my graphics hardware isn't recent enough to support its shaders.
20:16:37 <kmc> bug #18210	Game hangs after childbirth
20:16:48 <Cale> kmc: lol
20:17:04 <geheimdienst> kmc, is it reproducible?
20:17:11 <kmc> ehehehe
20:17:12 <Kaidelong> well, okay, not really, but a home grown version of it could be
20:17:26 <monochrom> what child birth?
20:17:38 <mamalujo> Cale: you aren't missing much though, very simplified, console-ish, unconvincing story etc,but at least they did make good flavor and art for it..
20:17:39 <kmc> i don't remember giving birth in fallout 3
20:17:40 <kmc> or otherwise
20:17:57 <kmc> eh i think the story was decent
20:18:00 <monochrom> what kind of game is fallout 3 such that you could have childbirth?!
20:18:09 <copumpkin> mmm fallout 3
20:18:13 <kmc> oh wait
20:18:20 <kmc> the opening cutscene is your character's mother giving birth
20:18:22 <copumpkin> I want to play fallout 2 again now
20:18:26 <kmc> that makes more sense as bugs go
20:18:32 <monochrom> Oh, I see. haha.
20:18:35 <Cale> monochrom: The initial character creation follows your character through various stages of early life
20:18:44 <kmc> yeah, it's a clever interface
20:19:16 <kmc> basically when you're learning how to walk around and pick stuff up, your character is very young so it's not unrealistic ;)
20:19:18 <mamalujo> kmc: well, I felt undermotivated to do most things in the game, from a RP perspective that is
20:19:22 <Cale> mamalujo: I did like Bethesda's other RPG's, at least, after sufficient modification :)
20:19:29 <kmc> and when you're picking skills, your character is in school taking exams
20:19:32 <ddarius> monochrom: Perhaps it's a new Sims game.
20:20:02 <Cale> Morrowind was a good deal better than Oblivion though...
20:20:32 * ddarius has decided that he hates the existence of video games.
20:20:36 <mamalujo> Cale: definitely
20:20:55 <gwern> videogames are fake utility
20:21:10 <mamalujo> ddarius: well, contemporary interactive fiction has actually good prose often enough
20:21:20 <monochrom> perhaps ddarius prefers audio games
20:21:42 <Cale> Most of the people who are still doing IF are serious enough about it to be decent writers :)
20:22:42 <mamalujo> yup, and its simple enough from programming perspective to be doable by only an author or two in free time in a few months
20:23:33 <tensorpudding> There's tons of mediocre IF games though
20:23:41 <kmc> there's tons of mediocre literature
20:23:58 <kmc> sturgeon's law etc
20:24:14 <mamalujo> tensorpudding: true. but it seems a closely knit community, competitions and prizes wade through the clutter decently
20:24:27 <Makoryu> A MEDIUM IS ONLY VALID AS ART IF EVERYTHING MADE IN IT IS OF THE UTMOST DWARVEN CRAFTSMANSHIP
20:24:36 <Makoryu> FILM AT ELEVEN
20:24:39 <abens`> omg, the channel has turned into rpg codex
20:24:52 <gwern> maybe I ought to check out IF. I put in my dues with Nethack, and IF is the other old genre still extant
20:24:59 <tensorpudding> sturgeons law: sturgeon are big fish and make valuable caviar
20:24:59 <mamalujo> abens`: my fault entirely, I'll shut up :)
20:25:07 * geheimdienst wonders if an irc channel might be considered interactive fiction
20:25:08 <monochrom> haha
20:25:16 <Cale> Emily Short and Andrew Plotkin are good names to look for
20:25:24 <kmc> "IRC is just multiplayer Notepad"
20:25:37 <geheimdienst> "multiplayer ghci", if lambdabot is present
20:25:40 <Nereid> lol
20:25:41 <Makoryu> Nah, IRC is multiplayer cat >
20:25:44 <abens`> lol, just kidding
20:25:46 <monochrom> Is Andrew Plotkin related to Gordon Plotkin?
20:25:52 <Cale> No idea
20:25:58 <monochrom> "interactive fictional operational semantics"
20:25:59 <Makoryu> monochrom: No, but he's related to John Malkovitch
20:25:59 <mamalujo> Indeed they are! and Photopia by Adam Cadre is impressively written, if sentimental and barely interactive
20:26:02 <Nereid> yes, they have the same last name
20:26:03 <Nereid> :o
20:26:03 <tensorpudding> Andrew Plotkin's games are hard
20:26:05 <Makoryu> s/tch/ch/
20:26:29 <tensorpudding> Lots of IF games are hard, in fact.
20:27:04 <mamalujo> but many great ones aren't. Slouching towards bedlam for eg
20:27:40 <tensorpudding> Not heard of that one.
20:28:11 <Cale> I seem to recall enjoying "Glowgrass" by Nate Cull, but I forget what it was about.
20:28:19 <wlangstroth> this is easily the weirdest irc room ever
20:28:31 <mauke> *channel
20:28:35 <tensorpudding> Because it has been stuck in off-topic mode for too long
20:28:51 <tensorpudding> Collective negligence, unfortunately, and I am not exempt.
20:28:52 <danharaj> Someone ask how to use the IO monad.
20:29:10 <djahandarie> > h.a.s.k.e.l.l
20:29:11 <lambdabot>   Couldn't match expected type `a1 -> a'
20:29:11 <lambdabot>         against inferred type `Simpl...
20:29:11 <wlangstroth> mauke: whatever
20:29:15 <Makoryu> Hay guise, monads are for letting you do side effects, right?
20:29:21 <djahandarie> Oh damn, you can't compose exprs? :[
20:29:32 <Makoryu> > f . g . h
20:29:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:29:33 <lambdabot>    `GHC.Show.Show a'
20:29:33 <lambdabot>      a...
20:29:40 <Makoryu> > f . g . h $ ()
20:29:41 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:29:42 <kmc> @quote Coding.drunk
20:29:43 <lambdabot>    `GHC.Show.Show a'
20:29:44 <mauke> irc ain't aol
20:29:45 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
20:29:45 <Makoryu>  ┐(　´〰`)┌
20:29:47 <lambdabot>      a...
20:29:49 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
20:30:00 <Cale> Oh, and I also loved "The Gostak" :)
20:30:46 <Cale> I can still read the language from that game, it's only too bad there isn't more of it ;)
20:30:47 <mamalujo> I'll check that out. sry ppl, I'll troll elsewhere :)
20:31:12 <kmc> wlangstroth, maybe you have low standards for weird
20:31:22 <kmc> there is actually a topic here and we occasionally stick to it
20:31:27 <jon_of_arc> I still think we need a monad tutorial that is just the definition of Parsec's ParsecT, parserBind, and (for context) runParsecT.
20:31:34 <jon_of_arc> It can be gazed at, and will deliver enlightenment.
20:31:35 <wlangstroth> kmc: weird is good
20:31:35 <monochrom> hang in here for a year. you will find fewer things weird. :)
20:32:20 <Cale> How about a monad tutorial for people who already understand comonads? ;)
20:32:28 <dark> b
20:32:33 <copumpkin> lol
20:32:34 <dark> sorry
20:32:42 <wlangstroth> low standards for weird is the people in one office I worked at who thought it was strange that I named my plants
20:33:04 <monochrom> I named my floppy diskettes.
20:33:16 <wlangstroth> see? not so weird
20:33:26 <geheimdienst> well, how abstract were the names? "oak tree" would be a perfectly acceptable name for a plant
20:33:30 <monochrom> Do they name their computers?
20:33:32 <Cale> Introduction to Monads using Kan Extensions
20:33:33 <geheimdienst> "george", not so much
20:33:45 <jon_of_arc> "Oak tree" would be pretty weird for a lot of plants
20:33:49 <wlangstroth> haha
20:33:58 <jon_of_arc> Especially those that in no way resemble a tree, let alone an oak.
20:34:09 <wlangstroth> it would be weird if you *only* named plants "oak tree"
20:34:17 <geheimdienst> what i'm saying is, at the right level of abstraction, names for plants are not strange at all
20:34:24 <mauke> "ash" is borderline
20:34:25 <geheimdienst> you know what i mean
20:34:30 <kmc> haha
20:34:32 <copumpkin> how about a (∞,1)-monad tutorial?
20:34:52 <wlangstroth> I didn't name any of them "monad tutorial" if that helps
20:34:56 <gwern> 'that's oak tree, and that over there is oak tree, and this little guy I call oak tree. I hope you don't mind, Professor Oak, but I call that bush over there the dog likes to pee on, oak tree as well.'
20:34:59 <Cale> This is my tulip, Ash McPine
20:35:05 <jon_of_arc> Now I'm disappointed.
20:35:13 <gwern> Cale: there are many like it, but that one is yours?
20:35:19 <kmc> it would be amusing to have e.g. a Python tutorial for Haskell programmers
20:35:27 <Pseudonym> I named two members of the plant kingdom "Herbie Flowers" and "Robert Plant".
20:35:40 <djahandarie> kmc, I wonder how easy it'd be for a Python programmer to learn from that
20:35:45 <wlangstroth> "Robert Plant" isn't even trying
20:35:51 <Pseudonym> Yeah, I know.
20:35:52 <kmc> "Unlike other programming languages you may be familiar with, Python allows you to write side-effecting expressions"
20:35:58 <djahandarie> Haha
20:36:01 <wlangstroth> haha
20:36:03 <kmc> djahandarie, about as easy as turning the crank backwards to get a pig
20:36:27 <kmc> i named each individual bacterium on the floor of my room
20:36:34 <copumpkin> that must've taken a while
20:36:48 <wlangstroth> kmc: what, as a group?
20:36:54 <jon_of_arc> Not if the name was the same, or could be assigned in a systematic fashion
20:37:06 <monochrom> "you can trampoline manually like so:"
20:37:08 <tensorpudding> Man, don't bacteria all have the same DNA?
20:37:20 <tensorpudding> of the same species
20:37:23 <kmc> no
20:37:26 <monochrom> they all have the same carbon, yes.
20:37:26 <tensorpudding> say
20:37:43 <tensorpudding> when they divide, they don't suddenly mutate do they?
20:37:50 <kmc> occasionally they do
20:37:58 <danharaj> Sometimes they do, also some bacteria can trade genes.
20:38:00 <kmc> that's how they manage to evolve
20:38:04 <kmc> that and plasmid exchange
20:38:07 <tensorpudding> i figured mutations were random
20:38:07 <danharaj> Genetics is complicated.
20:38:07 <wlangstroth> "suddenly" would be relative
20:38:08 <monochrom> often enough to evade antibiotics
20:38:09 <Rotaerk> the genetic code is highly redundant... optimally so, in fact
20:38:21 <Rotaerk> so some mutations have no effect on the organism
20:38:22 <kmc> it's not even clear what "species" means, for asexually reproducing organisms, which is most of them
20:38:22 <tensorpudding> not necessarily a part of division
20:38:25 <wlangstroth> monochrom: ... and learn to eat Nylon
20:38:35 <monochrom> that's scary
20:38:51 <tensorpudding> well, for a single-celled organism if a mutation completely made them unfit to live, that would make them rather maladaptive
20:38:57 <kmc> high school biology typically teaches an outdated organism-centric view of evolution
20:39:17 <Rotaerk> i.e. there are fewer amino acids than there are DNA encodings for amino acids
20:39:18 <kmc> and ignores many of the difficulties of defining "individual" and "species" which are of course not fundamental
20:39:24 <wlangstroth> meh - it's high school
20:39:39 <Cale> A Brief Introduction to C for Haskell Programmers: Resign yourself to writing crappy code that you know is going to break, because there's nothing you can do about it. No matter what you try, you're going to be fucked. Give up on sane program design right now, because essentially all your abstractions are either gone or broken sufficiently that nothing will work. Now you're ready, go write your program.
20:39:55 <wlangstroth> haha
20:39:56 <tensorpudding> if you take a evolutionary view, how do you distinguish when species begin or end?
20:40:07 <abens> omg the channel has turned into Richard Dawkins
20:40:08 <kmc> tensorpudding, you can't except heuristically
20:40:08 <monochrom> highschool doesn't teach the easy story. highschool teaches the old story.
20:40:19 <copumpkin> did anyone see psykotic's fast parser combinators in c?
20:40:26 <copumpkin> a while ago on reddit
20:40:27 <kmc> because species don't exist except heuristically
20:40:37 <aavogt> bacteria transfer genes between eachother
20:40:40 <kmc> they're a scheme we use to classify genes; they're not "real"
20:40:46 <Rotaerk> tensorpudding, one theory to explain the existence of diverse species is that some genes aren't compatible with others, resulting in death at birth, which causes a species population to eventually split into two populations that cannot together produce viable offspring
20:40:47 <mamalujo> I actually heard that 'ontogeny recapitulates filogeny' line in high school. which as I understand it is a discredited leftover from neolamarkian and other pre-neodarwinian notions of evolution
20:41:10 <mamalujo> *phylogeny
20:41:14 <Rotaerk> (and then there's the whole geographical isolation of subpopulations)
20:41:15 <danharaj> did you just say pre-neo-darwinian.
20:41:25 <tensorpudding> Certainly speciation occurs when populations are split.
20:41:31 <Rotaerk> pre-neo-anti-pro-darwinianism
20:41:32 <mamalujo> yup :)
20:41:38 <geheimdienst> *zygo-
20:41:45 <danharaj> I think this channel needs to go back to haskell :|
20:41:45 <monochrom> para-
20:42:01 <tensorpudding> Though speciation in a shared locality seems weirder
20:42:03 <mauke> darwimorphism
20:42:04 <wlangstroth> kmc already gave the answer
20:42:22 <geheimdienst> we're completely on topic, see: strong lax pre-neo-zygo-cryo-morphistic darwinianism
20:42:30 <tensorpudding> I guess having magic genes that when mixed, produces highly unfit offspring would explain it
20:42:35 <wlangstroth> species are platonic ideals, not reified things
20:42:36 <dino-> Read some of the scrollback. Terrific to see some IF fans here.
20:42:46 <Cale> Categorical genetics
20:43:02 <mamalujo> even had this famous hoax picture in my manual : http://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Haeckel_drawings.jpg/686px-Haeckel_drawings.jpg
20:43:29 <monochrom> what is haskell, *really*???
20:43:35 <wlangstroth> haha
20:43:53 <Rotaerk> hmm, human embryos look tasty
20:43:56 <Rotaerk> *cough*
20:43:57 <mamalujo> dino-: I was amazed as well. And there are some tiling window manager fans in ifMUD it seems, also unexpected
20:44:20 <dino-> mamalujo: Is that really surprising? IF being kind of a spare, shell-like activity. :D
20:44:33 <tensorpudding> Haskell is not an exclusive activity to such things
20:44:35 <Cale> You are a gostak rasking your shamtag (which is lelloed). You have pelled from the bewl at here, the delcot of tondam, to distim the doshes, but the doshery lutt is crenned with glauds. You reb some gitches friking in the hoggam, but, oddly, no duscats glake here. You also reb a tophthed curple, a gomway, and a samilen.
20:44:35 <mamalujo> hah, good point
20:44:35 <Cale> You are the gostak. The gostak distims the doshes. But you'll have to discren those glauds first.
20:45:03 <copumpkin> @remember Cale You are a gostak rasking your shamtag (which is lelloed). You have pelled from the bewl at here, the delcot of tondam, to distim the doshes, but the doshery lutt is crenned with glauds. You reb some gitches friking in the hoggam, but, oddly, no duscats glake here. You also reb a tophthed curple, a gomway, and a samilen.
20:45:03 <lambdabot> It is forever etched in my memory.
20:45:06 <Cale> (For a jallon, louk JALLON.)
20:45:12 <wlangstroth> Oh, I hate it when my shamtag gets lelloed
20:45:24 <tensorpudding> Channeling Finnegan's Wake?
20:45:38 <Cale> It's from "The Gostak" which is an IF game :)
20:46:00 <dino-> For people looking to try, some games from the era of commercial IF were excellent. The Infocom games.
20:46:13 <Cale> All the commands are in that funny variant of English too, so you have to figure out a bit of the language before you can really do anything. :)
20:46:20 <mamalujo> anyone know that language from the edifice? :)
20:46:22 <wlangstroth> didn't they do the hitchhiker's guide one?
20:46:34 <dino-> wlangstroth: I believe so
20:46:45 <wlangstroth> yeah - I remember that on the amiga
20:46:47 <tensorpudding> Infocom games were commercial though
20:46:48 <geheimdienst> this could be a good way to learn, say, french vocabulary, if you don't speak french and read something like the gostak ...
20:46:55 <tensorpudding> Where can you find those nowadays anyway?
20:47:15 <mamalujo> theres that treasures of infocom cd
20:48:11 <tensorpudding> You still need a system that they'll run on
20:49:00 <Cale> Haha, this page about the game has an example of what Gostakian Esperanto might look like: "La gostako maltimmas la doŝojn."
20:49:03 <mamalujo> frotz, gargoyle etc?
20:49:55 <tensorpudding> They're distributed as just bare z-machine files?
20:50:06 <Cale> tensorpudding: with various versions, yeah
20:50:35 <geheimdienst> the system requirements are as follows: shamtag (lelloed), bewl, delcot of tondam, doshes, lutt crenned with glauds, some gitches friking in the hoggam, no duscats
20:50:46 <mamalujo> well, the files are in any case in their directories, played a mind forever voyaging and the initial timed sequence of trinity that way
20:52:09 <mamalujo> they come with pdf scans of manuals also
20:52:33 <mamalujo> or, at least the torrent I used did ;)
20:52:58 <danharaj> Ok, I have a question about continuations, the cont monad, etc.
20:54:06 <danharaj> Actually nevermind, I'll stew on it for a bit.
20:58:35 <dolio> > let showPHOF :: (forall a. a -> [a]) ; showPHOF f = "\\x -> " ++ show (f "x") in showPHOF (\x -> [x,x,x])
20:58:36 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> a'
20:58:36 <lambdabot>         against inferr...
21:00:57 <dolio> > let showPHOF :: (forall a. a -> [a]) -> String ; showPHOF f = "\\x -> " ++ show (f (text "x")) in text $ showPHOF (\x -> [x,x,x])
21:00:58 <lambdabot>   \x -> [x,x,x]
21:03:01 <copumpkin> :o
21:03:02 <monochrom> danharaj: I have cont monad examples at http://www.vex.net/~trebla/haskell/cont-monad.xhtml
21:03:28 <danharaj> I was wondering about what sort of expressiveness differences there are between applicative and monadic use of Cont
21:03:51 <TuteC> Hi all. I've got an implementation of set like: type Conj a = (a -> Bool). The empty set is (\_ -> False), and add one element like: (\y -> (x == y)).
21:03:53 <TuteC> My problem is when adding more than one element, it doesn't see inner elements and can't see why: add x c = (\y -> if x == y then True else c y)
21:04:16 <TuteC> Do those anonymus functions nest? If they did, this would return true! (add 2 (add 3 empty)) 3 == (add 3 empty) 3
21:05:29 <dolio> > let e = const False ; add x s y = if x ==y then True else s y in add 2 (add 3 e) 3
21:05:29 <lambdabot>   True
21:05:41 <Cale> > let empty = const False; add x c = \y -> x == y || c y in (add 2 (add 3 empty)) 3
21:05:42 <lambdabot>   True
21:06:11 <Cale> TuteC: as far as I can see, there's nothing wrong with your code
21:06:12 <dolio> You must have a typo somewhere.
21:07:50 <TuteC> Thank you all, I think your code does the same as mine, if I catch my error I'll show you.
21:08:44 <dolio> copumpkin: The power of parametricity.
21:08:47 <TuteC> Look at the difference:
21:08:49 <TuteC> add x c = (\y -> if x == y then True else c y)
21:08:51 <TuteC> add x s y = if x == y then True else s y
21:08:56 <TuteC> First one doesn't work as expected.
21:09:11 <dolio> > let e = const False ; add x s = \y -> if x ==y then True else s y in add 2 (add 3 e) 3
21:09:12 <lambdabot>   True
21:09:47 <dolio> f x = ... and f = \x -> ... are the same except for certain technicalities that wouldn't affect this situation.
21:10:14 <monochrom> danharaj: my setjmp example uses «do { l <- setjmp; ...; l }», i.e., like «join setjmp». join is usually the thing making monad more special than applicative and arrow. So I suspect the setjmp example cannot be written in applicative.
21:11:33 <danharaj> monochrom: call/cc can be written only using the monadic operators right?
21:11:47 <danharaj> monochrom: My first guess was that call/cc is roughly what the monadic interface gives you.
21:12:05 <dolio> call/cc requires special implementation for the monad.
21:12:19 <dolio> You can't write it with just return and bind.
21:12:23 <danharaj> oh
21:12:34 <TuteC> parentheses around the if-then-else solved the issue, thanks!
21:13:01 <pastorn> danharaj: the soma goes for almost all other monads
21:13:13 <pastorn> danharaj: in ghci use :i for any of these
21:13:27 <pastorn> MonadReader, MonadState, MonadWriter, MonadCont
21:13:30 <pastorn> MonadError
21:14:07 <pastorn> (though you probably will need to use :m +Control.Monad.Reader or equivalent first to get it working)
21:14:21 <pastorn> that will show you the unique functions provided by each type of monad
21:14:48 <danharaj> So how is call/cc implemented?
21:15:02 <pastorn> danharaj: read the page on wikibooks
21:15:09 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
21:15:10 <lambdabot> Error: Undefined type Cont
21:15:10 <pastorn> it goes through it in detail
21:15:20 <dolio> @djinn-add type Cont r a = (a -> r) -> r
21:15:22 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
21:15:23 <lambdabot> f a b = a (\ c _ -> b c) b
21:15:29 <tensorpudding> guy steele sits inside ghc, gently caressing your continuations
21:15:30 <pastorn> dolio: ugh....
21:15:34 <djahandarie> djinn is damn cool
21:15:39 <Xichekolas> hi... attempting to implement something akin to stream fusion for rose trees, have my local RULES pragma: stream (unstream s) = s... which seems to be firing with -O2, but is never listed in the -ddump-simpl-stats list of rules that fired... anyone know if it's normal for local rules to not show up there? or is my rule really not firing?
21:15:53 <blackdog> tensorpudding: you're a very strange person...
21:16:05 * djahandarie thanks augustss
21:17:33 <copumpkin> Xichekolas: I think your rule must not be firing... have you checked the core?
21:17:59 <Xichekolas> copumpkin: ah ok, I'll have a look
21:18:53 * BMeph hands Xichekolas' rule a pink slip...
21:24:19 <blackh> Hey, I wanna write a blog entry. It might be my first and last blog ever, so can I be a guest blogger on the site of one of you famous Haskell bloggers?
21:24:59 <Cale> blackh: what's it about?
21:25:23 <Cale> (not that my blog is as famous as that of some people around here :)
21:25:35 <blackh> Cale: My hexpat and hexpat-iteratee packages.
21:25:59 <blackh> You're not one of those stinkin' XML haters, are you?
21:26:07 <copumpkin> I AM, YOU BASTARD!!
21:26:13 <Cale> hehe, I am, actually
21:26:15 <blackh> Well, I'll convert you!
21:26:33 <monochrom> Cale used HXT to write an RSS reader.
21:26:34 <copumpkin> why does it need to be a blog post? wouldn't a static tutorial/manual page be good?
21:26:47 <Cale> I have
21:27:13 <Cale> XML exists, so people have to find ways to deal with it, and I have no problem with that aspect of it.
21:27:28 <Cale> I just object to using XML for new projects
21:28:02 <Axman6> blackh: i'd be happy to give you an account on my blog if you like
21:28:14 <blackh> copumpkin: It's a tutorial/introduction to what cool stuff you can do.  I thought maybe a blog would be better than a wiki entry.
21:28:19 <Axman6> it's on planet, so you should get a few readers
21:28:20 <copumpkin> ah
21:28:53 <blackh> Axman6: I accept! Thank you. I haven't written it yet.
21:29:06 <monochrom> (the lazy writer)
21:29:07 <blackh> It will only be of interest to Haskellers
21:29:11 <Cale> (because I think it is perhaps the most horribly baroque notation for trees invented since the inception of computer science, and almost everything which comes into contact with it is inevitably inflicted with that nature)
21:29:15 <blackdog> blackh: if it's a standalone thing, maybe submit to the monad reader?
21:29:32 <monochrom> ("the lazy writer" may make a catchy name for a new magazine)
21:30:03 <Xichekolas> copumpkin: op, realized I forgot to tell it not to inline stream/unstream until last phase
21:30:11 <Xichekolas> no wonder there was nothing to match
21:30:17 <monochrom> hehe
21:30:28 <blackh> blackdog: Good idea, but I think it's still a bit unstable to go into the historical record like that.
21:30:35 <Cale> (not that I'll pass judgement on your library just yet, there's a first time for everything ;)
21:30:37 <BMeph> XML is doomed to failure - S-expers are easier to process, and give the same results - maybe better, 'cause they're easier to process <ducks>
21:30:55 <Cale> BMeph: agreed.
21:31:10 <blackh> Cale: Well, I'm using the opportunity to initiate my beta programme, so if my library is broken, I can fix it before I go to v1.0.
21:31:30 <BMeph> XML is a solution, that causes problems, in order to be the solution to them.
21:31:31 <Axman6> blackh: http://axman6.com/blog/ look like a nice place to put it?
21:32:40 <Cale> BMeph: lol
21:32:51 <blackh> Very shiny. I like it - I especially like bright colours.
21:33:02 <blackdog> blackh: I think the monad reader is a good place for that sort of thing - it's not quite a paper, but a bit more than a rumination on your cat...
21:33:11 <Axman6> heh
21:33:42 <blackh> blackdog: What I'll do, I think, is write it as a blog then I might think about titivating it up for TMR
21:34:19 <blackh> Maybe I'll have some feedback on my 'hexpat beta programme' by then
21:49:57 <alex404> Let's say I've got a function, f x, which I know is going to be calculated a lot of times at some value, say 2. Haskell knows to reuse the calculation, right?
21:50:09 <Veinor> I don't believe so
21:50:14 <copumpkin> nope
21:50:19 <alex404> Hmmm...
21:50:24 <copumpkin> if you want it to keep it, name it
21:50:33 <Veinor> there are libraries that do such a thing, though
21:50:36 <alex404> What if I don't know what it will be, though?
21:50:39 <alex404> Like what, Veinor?
21:50:57 <Veinor> Data.MemoTrie and Data.MemoCombinators
21:50:58 <copumpkin> memocombinators
21:51:08 <copumpkin> alex404: what what will be?
21:51:08 <alex404> Cool, thanks.
21:51:09 <Veinor> MemoTrie is easier to use, to be quite honest
21:51:21 <copumpkin> really? I haven't tried that
21:52:18 <Veinor> you just say fib = memo fib' where fib' n = fib (n - 1) + fib (n - 2) etc etc
21:52:22 <grubles> hello all
21:52:27 <Veinor> don't have to do Memo.memo Memo.integral fib'
21:52:42 <copumpkin> ah
21:52:47 <copumpkin> allo grubles
21:52:58 <grubles> o/
21:53:23 <Veinor> there's a HasTrie typeclass that represents things you can memoize over
21:53:36 <copumpkin> I see
21:54:19 <Veinor> I dunno what to do if your type t isn't in the class though
21:54:42 <copumpkin> seppuku is the only choice
21:56:02 <CirceTheSorceres> copumpkin: omg
21:58:46 <Veinor> alex404: the reason it doesn't is that if you had a function f x that you needed to calculate over a large number of different arguments, it would store the results in memory somewhere
21:58:49 <Veinor> which is a Bad Thing
21:59:15 <copumpkin> CirceTheSorceres: omg
22:00:33 <CirceTheSorceres> Veinor: But isn't it the case that in an expression like
22:00:53 <CirceTheSorceres> x = (f y) + (f  y)
22:01:09 <copumpkin> it sort of is
22:01:14 <copumpkin> + isn't necessarily strict
22:01:19 <Veinor> I am not sure whether f y gets evaluated twice
22:01:23 <copumpkin> it does
22:01:30 <CirceTheSorceres> In a expression like x = (f y) + (f y) one cannot count on f y getting evaluated twice
22:01:33 <CirceTheSorceres> right?
22:01:42 <dmwit> You can't count on it, no.
22:01:50 <dmwit> You can't count on it being evaluated only once, either.
22:01:51 <copumpkin> it shouldn't matter, either way
22:01:55 <Veinor> x = let z = f y in z `seq` z + z works though I think
22:01:57 <copumpkin> but GHC doesn't do CSE there
22:02:03 <CirceTheSorceres> copumpkin: exactly
22:02:11 <copumpkin> you also don't need parentheses there :)
22:02:52 <CirceTheSorceres> copumpkin: yes, but my haskell is a bit rudty after about a few months of disuse, and I didn't want to take chances on #haskell
22:02:56 <dmwit> The seq isn't necessary if all you want is to share the two computations.
22:03:08 <copumpkin> CirceTheSorceres: lest we expel you and hang you upside down, disemboweled?
22:03:26 <tensorpudding> what is deepseq?
22:03:33 <copumpkin> rnf, shaped like seq
22:03:38 <tensorpudding> or better, where is it
22:03:39 <dmwit> deepSeq is deprecated
22:03:48 <copumpkin> it is?
22:03:49 <CirceTheSorceres> copumpkin: in which case you will do well to rememeber the story of Odysseus' men
22:03:57 <dmwit> Yes, use Strategies instead.
22:03:59 <Veinor> dmwit: then what do you need to do for it?
22:04:07 <copumpkin> dmwit: but it was just pushed recently!
22:04:13 <dmwit> Veinor: The let is enough to share the computation.
22:04:17 <copumpkin> I thought they were trying to promote deepseq
22:04:20 <Veinor> ah
22:04:30 <dmwit> copumpkin: err... perhaps I am confused!
22:04:34 <dmwit> It would not be the first time.
22:04:40 <copumpkin> @hackage deepseq
22:04:40 <lambdabot> http://hackage.haskell.org/package/deepseq
22:04:52 <dmwit> But I thought e.g. rnf was the way of the future for this stuff.
22:05:26 <copumpkin> http://www.mail-archive.com/haskell-cafe@haskell.org/msg67429.html
22:05:54 <copumpkin> aha, that was it
22:06:16 <copumpkin> it was a fairly general-purpose need and there was no need to relegate it to the parallel package under a Control.Parallel module hierarchy
22:06:22 <copumpkin> so simon marlow made a separate package for it
22:08:18 <CirceTheSorceres> copumpkin: pardon me if I am being naive, but things like deepSeq would come into play only if one of the arguments is an IOish monad, right?
22:09:16 <copumpkin> well, in a pure function you shouldn't be able to tell/care how evaluated something is
22:09:44 <copumpkin> I haven't ever needed rnf for anything but performance checking though
22:11:28 <CirceTheSorceres> copumpkin: rnf?
22:11:37 <copumpkin> deepseq with a different shape
22:11:41 <copumpkin> :t rnf
22:11:42 <lambdabot> forall a. (NFData a) => a -> Done
22:11:49 <copumpkin> where Done is effectively ()
22:12:39 <CirceTheSorceres> :t deepSeq
22:12:40 <lambdabot> Not in scope: `deepSeq'
22:12:55 <CirceTheSorceres> :t deepseq
22:12:56 <lambdabot> Not in scope: `deepseq'
22:12:59 <copumpkin> :t seq
22:13:00 <lambdabot> forall a t. a -> t -> t
22:13:07 <copumpkin> it's that, with an additional constraint on a
22:13:12 <CirceTheSorceres> ok
22:13:14 <copumpkin> (of NFData)
22:13:25 <Axman6> @src Done
22:13:25 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:15:34 <copumpkin> type Done = ()
22:15:39 <copumpkin> pretty deep stuff
22:17:16 <blackdog> copumpkin: so Undone would be )( ?
22:17:25 <copumpkin> omg, yes
22:19:31 <CirceTheSorceres> wait when did they introduce this new )( type?
22:19:46 <CirceTheSorceres> oops
22:19:48 <dmwit> They demo'd it at the HumourCon last year.
22:19:53 <blackdog> CirceTheSorceres: it's usually called the Hourglass operator
22:20:00 <CirceTheSorceres> I guess this is the Poe effect
22:20:02 <copumpkin> dmwit spells humour as humour! :o
22:20:09 <CirceTheSorceres> Wow
22:20:17 * dmwit <3 the brits
22:20:31 <CirceTheSorceres> Somebody else follows British/Australian/Indian spellings here
22:20:33 <copumpkin> :O
22:20:42 <dmwit> colour! bin! centimeter! boot! programme!
22:20:58 <copumpkin> centimetre, surely
22:21:11 <dmwit> I think there's members of both camps.
22:21:14 <dmwit> But yeah.
22:21:18 <copumpkin> the horror
22:21:23 <copumpkin> horrour? :P
22:21:29 <dmwit> =P
22:21:37 <blackdog> and rooting is not cracking a machine...
22:21:45 <dmwit> Alright, where's the bug that makes this animation stop a few frames early...?
22:22:01 <dmwit> rooting is significantly more fun than cracking
22:22:08 <dmwit> And a fanny isn't in the back.
22:23:05 <dmwit> This code is too simple to be wrong... =(
22:23:22 <CirceTheSorceres> So there still are people who look up encyclopaedias
22:23:30 <CirceTheSorceres> and travel in aeroplanes, even on #haskell
22:23:38 <CirceTheSorceres> I thought I was an endangered species
22:23:42 <blackdog> make it more complex, then there can be no obvious bugs
22:23:51 <blackdog> CirceTheSorceres: oz/nz/uk?
22:24:00 <CirceTheSorceres> in
22:24:04 <copumpkin> dmwit: ?
22:24:17 <CirceTheSorceres> blackdog: in
22:24:23 <blackdog> ah, right
22:24:35 <blackdog> i always forget the biggest colony:)
22:25:07 <CirceTheSorceres> :-)
22:25:08 * hackagebot hexpat 0.16 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.16 (StephenBlackheath)
22:25:53 <CirceTheSorceres> (Un?)fortunately I am now in the (former, admittedly) largest colony
22:26:47 <dmwit> ah!
22:26:51 <CirceTheSorceres> where people eat cookies and not biscuits, and then wear colored clothes
22:27:08 * hackagebot hexpat-iteratee 0.4 - Chunked XML parsing using iteratees  http://hackage.haskell.org/package/hexpat-iteratee-0.4 (StephenBlackheath)
22:27:35 <alex404> Is cycling a list faster than using ++ to replicate it?
22:27:41 <alex404> Or is it all the same in the end?
22:27:46 <copumpkin> it's better
22:27:55 <copumpkin> since it uses constant sapce
22:27:57 <copumpkin> space
22:27:59 <alex404> Right.
22:28:02 <copumpkin> (assuming the original list was finite :P)
22:28:05 <alex404> So in general, cycle is awesome?
22:28:09 <copumpkin> yep
22:28:16 <alex404> Thansk.
22:28:16 <Axman6> @src cycle
22:28:17 <lambdabot> cycle [] = undefined
22:28:17 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
22:28:17 <copumpkin> but don't expect it to maintain the constant space if you do stuff to it
22:28:25 <alex404> Right.
22:29:11 <CirceTheSorceres> ah laziness, sweet are thy fruits
22:29:27 <CirceTheSorceres> replicating lists with constant space
22:29:33 <blackdog> CirceTheSorceres: better make sure you have a big enough basket to catch them, though
22:29:45 <dmwit> CirceTheSorceres: That does not require laziness.
22:30:00 <dmwit> CirceTheSorceres: Circularly linked lists are possible in almost every language.
22:30:17 <CirceTheSorceres> dmwit: replication by definition, in other languages, requires O(n) space
22:30:34 <CirceTheSorceres> dmwit: Oh, sorry, my definition for replication was a hard
22:31:09 <CirceTheSorceres> replication, a deep copy, which, even if done with "constant" space using link lists
22:31:22 <CirceTheSorceres> would essentially be simulating laziness, right?
22:31:47 <dmwit> No. You can have eager, circularly linked lists.
22:32:07 <Makoryu> ...But you need mutable refs to make them.
22:32:20 <dmwit> Sure.
22:32:57 <CirceTheSorceres> oh but circular linked lists are not deep copies , are they?
22:32:58 <CirceTheSorceres> Am I missing something here?
22:33:08 <dmwit> mmm... maybe. I'm not sure I buy "need". But it probably helps a lot. =)
22:33:22 <dmwit> I'm not sure what you mean by deep copies.
22:33:52 <dmwit> Haskell isn't doing deep copies (for the usual definition of deep copies).
22:34:28 <dmwit> Or, rather, the semantics makes it impossible to tell whether what you get are deep or shallow copies.
22:34:38 <pastorn> dmwit: it's not? i thought that was the only thing it did...
22:34:52 <dmwit> So the implementation can choose to do either.
22:35:09 <pikhq> struct list {int car;struct list *cdr;} l = {0, &l}; // This is valid C, and a circular linked list.
22:35:16 <dmwit> pastorn: nope; cycle [somethingEnormous] will not make a deep copy of somethingEnormous.
22:35:16 <pikhq> >:D
22:35:30 <pastorn> oh, true
22:35:39 <pastorn> that's just a pointer pointing back to the beginning
22:35:42 <dmwit> (...in GHC)
22:35:44 <CirceTheSorceres> dmwit: oh yes, my bad
22:35:52 <pastorn> ...sort of... -ish...
22:35:55 <pikhq> dmwit: Or any sane Haskell implementation.
22:36:03 * dmwit nods agreement with pikhq
22:36:14 <pikhq> (though a valid implementation of Haskell semantics, good God that's awful)
22:36:15 <Makoryu> pikhq: ^ Arguably, there's a bit of lazy evaluation in C's semantics.
22:36:21 <CirceTheSorceres> dmwit: lesson to me to keep my mouth shut before thinking it through
22:36:43 <dmwit> CirceTheSorceres: Opening your mouth is one way of learning. =)
22:36:52 <dmwit> <- says lots of wrong stuff in here
22:37:06 <pikhq> Makoryu: There's a lot of screwy stuff in C. ;)
22:37:46 <Makoryu> pikhq: So design a replacement already!
22:37:55 <CirceTheSorceres> dmwit: :-) But I loved the euphemistic "mutable refs"
22:38:14 <dmwit> Makoryu: LLVM, C--, Android's language, ...?
22:38:18 <CirceTheSorceres> is the word  "pointers" banned out here
22:38:21 <kulin> dont need to replace c, it does what it should quite well, but people should stop writing consumer grade software with it
22:38:21 <pikhq> But C is mostly good for the purposes it's meant for, and replacements exist for the other purposes it's used for!
22:38:31 <Makoryu> dmwit: Android's language? Java?
22:38:38 <copumpkin> dmwit: that takes confidence!
22:38:41 <dmwit> Makoryu: No, believe it or not.
22:38:50 <copumpkin> (opening one's mouth)
22:39:14 <copumpkin> I remember as a newbie in here it was a little daunting to see 600 people of whom many were talking about weird category theory stuff
22:39:17 <Makoryu> pikhq: It's *mostly* good for the purposes where it's really needed, but it could be improved on.
22:39:27 <pikhq> Makoryu: Well, sure.
22:40:15 <CirceTheSorceres> copumpkin: But by and large I find this quite friendly for newbies
22:40:24 <copumpkin> it is, definitely
22:40:30 <Makoryu> dmwit: What language do you mean, if not Java?
22:40:43 <copumpkin> but someone coming from less friendly IRC channels might still be a little daunted to go out on a limb until they see how nice it is in here
22:40:46 <copumpkin> I was
22:41:07 <dmwit> I vaguely recall that there were some reasons to differentiate the Android language from Java. A different VM, different bytecode, different libraries... something like that?
22:41:12 <dmwit> I was never really clear on it.
22:41:20 <copumpkin> dalvik
22:41:23 <copumpkin> is the VM they use
22:41:30 <copumpkin> people still program in "java"
22:41:42 <pikhq> dmwit: Different VM, different libraries.
22:41:59 <pikhq> And different bytecode.
22:42:11 <copumpkin> never really figured out why they went with that when most of the mobile ARM CPUs support native execution of java bytecode
22:42:12 <dmwit> So I got the right three differences?
22:42:13 <pikhq> Basically, it's Java with a completely different runtime.
22:42:15 <dmwit> dmwit++ ;-)
22:42:16 <Makoryu> But the same Java language
22:42:20 <copumpkin> (for great cost in licensing from ARM)
22:42:45 <pikhq> copumpkin: I suspect they wanted to allow not-ARM in on the game too.
22:42:54 <copumpkin> who else is there? :P
22:43:07 <pikhq> The FUTURE!
22:43:09 <Makoryu> copumpkin: Intel, in about two years
22:43:22 <Makoryu> And Motorola
22:43:24 <copumpkin> admittedly, jazelle apparently costs a fuckton to license
22:44:20 <copumpkin> the CPUs in the iphones support it but nobody uses it
22:44:51 <Axman6> s/uses/can use/
22:44:53 <Axman6> ?
22:45:02 <copumpkin> that too :)
23:10:15 <kulin> seems like the second i use threads, my program cross some sort of anti-functional threshold
23:10:33 <blobl> hi
23:10:50 <copumpkin> kulin: how so?
23:11:10 <kulin> just to allow multiple threads to talk to each other, I am stuck with a lot of state vars
23:11:15 <kulin> like TVar and TChan
23:11:20 <copumpkin> kulin: ah, with STM
23:11:37 <copumpkin> then yes, your programs will be "more imperative"
23:11:44 <pastorn> kulin: what are you building?
23:12:46 <copumpkin> kulin: other options are just using Control.Parallel, dph, repa
23:12:59 <copumpkin> those will be pure, but are a more restricted form of programming
23:13:08 <kulin> right now, just a multiple user network server, which i have working, im just being sad about the amount of state i end up tracking because i cannot use recursion to have different threads change the parameters of functions in other threads
23:14:19 <kulin> ya someone said i should look at par before, but im not sure what the point of par is, it looks more like a function that simply says "i dont care what cpu you calc this function on"
23:15:21 <copumpkin> yeah, it's not for concurrency
23:15:25 <copumpkin> which is what it seems you need
23:18:41 <alex404> Can anyone give me a quick rundown on how to use one of the libraries to memoize a two argument function?
23:18:41 <blobl> can somebody explain to me why you might want to use arrows?
23:18:50 <kulin> arrows?
23:18:57 <Cale> So I hear they're nailing the creators of LimeWire for helping people commit copyright infringement. I wonder when they'll realise that by focusing only on the application layer of the OSI model, they're really cutting down their options with regard to lawsuits.
23:19:04 <copumpkin> blobl: nope
23:19:32 <dmwit> I wonder if they even know what the term "application layer" means.
23:19:39 <blobl> :D how about continuations ?
23:19:41 <copumpkin> alex404: memo2?
23:20:04 <Cale> blobl: Arrows provide an interface into which some libraries fit.
23:20:05 <copumpkin> or mup for more general work
23:20:10 <Cale> blobl: It's as simple as that.
23:20:15 <Cale> (same goes for monads)
23:20:15 <dmwit> blobl: The most convincing argument for me was the one showing how to write parsers with separate static and dynamic parsing information.
23:20:17 <alex404> copumpkin: Sorry if I'm being dumb, but all I have to two is type memo2, call the function that it returns instead, and I'm good to go?
23:20:32 <copumpkin> zomg = memo2 (+)
23:20:37 <copumpkin> for example
23:20:58 <alex404> And then whenever a pair gets called a second time on zomg, it won't be recalculated?
23:21:07 <copumpkin> yeah
23:21:17 <Cale> Just think of how much the manufacturers of ethernet cards have helped people commit copyright infringement!
23:21:36 <alex404> Hmmm... I guess I'm doing it right. I just need to do some profiling... my fft algorithm is slow as shit... :(
23:21:37 <copumpkin> Cale: wow, you should work for one of those content creator associations
23:21:40 <Cale> And hard drive manufacturers! Can't commit copyright infringement without a place to store data!
23:21:42 <copumpkin> you have a future in law
23:21:55 <copumpkin> alex404: memoizing might not be the best way to approach it
23:22:20 <alex404> What do you have in mind?
23:22:25 <Cale> Seagate has been aiding and abetting pirates!
23:22:41 <pastorn> Cale: you're wrong!
23:22:45 <copumpkin> binding to fftw or your OS's/platform's super-optimized fft :P
23:22:56 <alex404> Boooo
23:23:08 <dmwit> blobl: Specifically, section 3 of John Hughes' paper, "Generalising Monads to Arrows".
23:23:21 <alex404> I don't want to use fftw!
23:23:40 <pastorn> Cale: http://www.maxconsole.net/archive/index.php/t-37662.html
23:24:33 <pastorn> it's not for piracy! it's for porn!
23:25:09 <blackdog> alex404: you like your wheels nice and square?
23:25:39 <Cale> Tim Berners-Lee MUST be held accountable for all the piracy committed using the HTTP protocol and the WWW!!1
23:26:06 <Cale> pastorn: haha
23:26:19 <Cale> pastorn: But they know that it'll be pirated porn.
23:26:28 <pastorn> not necesarily
23:26:37 <tensorpudding> Pirates was a popular porn, for sure.
23:26:38 <alex404> blackdog: I don't see why I can't get a reasonable fft algorithm working in haskell...
23:26:46 <copumpkin> I actually watched that a couple of weeks ago
23:26:48 <tensorpudding> I can't say if it was good though.
23:26:49 <pikhq> ... There exist people who don't pirate porn?
23:26:49 <copumpkin> it wasn't bad
23:26:56 <pikhq> I'm shocked.
23:26:59 <tensorpudding> It's supposedly a porn with decent acting
23:27:06 <copumpkin> I'm not sure I'd go that far
23:27:13 <tensorpudding> And good production values
23:27:23 <tensorpudding> And a plot that isn't entirely stupid
23:27:40 <blobl> well i think i have to think less and try more anyway
23:28:30 <blackdog> alex404: a big reason fftw is fast is that they use metaprogramming techniques to generate code... I guess you could do the same.
23:28:36 <pastorn> Cale: you should read the full interview on CNN money
23:28:49 <pastorn> Seagate's CEO is a pretty awesome dude
23:29:01 <copumpkin> yeah, translate fftw from ocaml
23:31:45 <alex404> You two are so negative. Some of us still *dream*
23:33:38 <blackdog> alex404: about fast haskel FFT, or porn with high production values?
23:34:06 <Cale> alex404: Do an FFTW-style thing.
23:35:45 <Cale> You could use something like harpy to compile x86 code for FFTs.
23:35:45 <alex404> blackdog: Both.
23:36:03 <Cale> Oh, copumpkin already suggested FFTW :)
23:36:04 <copumpkin> mprotect
23:36:36 <copumpkin> :)
23:36:41 <alex404> Cale: Yes yes. This whole thing is masturbation on my part. This has all been established.
23:36:52 <copumpkin> masturbation is fun
23:36:56 <copumpkin> that's why so many people do it
23:36:58 <alex404> I know!
23:37:16 <Cale> alex404: There are things about FFTW which are less than ideal...
23:37:51 <copumpkin> Cale: the fact that jdh can point to it in his annoying "debates"?
23:38:08 <Cale> If I recall correctly, it's an O'Caml program which compiles chunks of C code together and then runs a C compiler over that.
23:38:24 <copumpkin> yeah
23:38:27 <alex404> Sounds elegent.
23:38:33 <Cale> It's not at all clear that the result is in any way optimal.
23:38:41 <copumpkin> but it has wisdom!
23:39:07 <Cale> There are a bunch of heuristic things that it does.
23:39:11 <copumpkin> it kind of feels hacky
23:39:13 <copumpkin> but it's pretty fast
23:39:22 <tensorpudding> That was the idea of it wasn't it?
23:39:36 <Axman6> alex404: mmorrow has a very fast implementation of an FFT using template haskell somewhere
23:39:37 <copumpkin> yeah
23:39:45 <Axman6> preflex: seen mmorrow
23:39:45 <preflex>  mmorrow was last seen on #ghc 116 days, 3 hours, 41 minutes and 59 seconds ago, saying: * mmorrow is rtfm'ing
23:39:47 <copumpkin> yeah, but mmorrow disappeared and his site is offline now
23:39:53 <Axman6> oh no :(
23:39:53 <copumpkin> :(
23:40:08 <Cale> Oh, wow, mmorrow disappeared!
23:40:12 <Runar> @hoogle Any
23:40:12 <lambdabot> Data.Monoid newtype Any
23:40:12 <lambdabot> Data.Monoid Any :: Bool -> Any
23:40:12 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
23:40:35 <alex404> So can I find it anywhere, then?
23:40:35 <copumpkin> yeah, nobody seems to know where he went :(
23:40:41 <copumpkin> I even tried emailing him
23:40:47 <Veinor> he's rtfm'ing
23:40:54 <Veinor> he's reading the manual in the sky ;_;
23:41:00 <copumpkin> I hope not :(
23:41:00 <alex404> Is that like pigning for the fjords?
23:41:03 <tensorpudding> Isn't FFTW a C library though?
23:41:24 <tensorpudding> The OCaml is compiled to C or something?
23:41:31 <Cale> tensorpudding: no, it's an O'Caml program which generates C code
23:42:03 <Cale> So I guess the end result is a C library, but it's not one that was written by a human directly :)
23:42:23 <copumpkin> http://www.fftw.org/faq/section2.html#languages
23:42:33 <Cale> It's sort of a special purpose compiler for generating FFT programs
23:43:01 <copumpkin> oh I bet jdh found out
23:43:11 <copumpkin> and sent his super secret ocaml assassination squad after mmorrow
23:43:21 <dolio> Found out what?
23:43:38 <Cale> dolio: WE'VE ALREADY SAID TOO MUCH!!!111one
23:43:56 <copumpkin> that mmorrow's specialized TH FFT generator was generating superfast FFT code
23:43:59 <Cale> dolio: That he wrote a fast FFT using TH
23:44:08 <dolio> Ah.
23:46:21 <Cale> Or maybe mmorrow is prematurely pulling a _why
23:46:34 <copumpkin> he was pretty famous
23:46:38 <copumpkin> !!!
23:47:01 <Cale> Well, we all knew him because he hung around in the IRC channel, anyway :)
23:48:52 <Cale> Maybe he joined the Hackers for Haiti effort and is trying to rebuild Haiti's software infrastructure after the earthquake? (Too soon? :)
23:50:17 * copumpkin slaps Cale 
23:51:18 <Cale> Or maybe he just changed nicks.
23:51:55 <Cale> Oh, but that doesn't explain why his site is gone.
23:52:01 <copumpkin> nope
23:52:07 <copumpkin> or why he didn't respond to my email
23:52:08 <copumpkin> :/
23:53:19 <Cale> <cue parrot sketch>
23:54:25 <Cale> http://code.haskell.org/~morrow/code/haskell/
23:54:39 <Cale> Some stuff is there still
23:54:44 <copumpkin> that's old stuff
23:54:49 <Cale> yeah
