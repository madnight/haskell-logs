00:26:58 <Kaidelong> looks like GHC can play nice with PVM
00:27:52 <copumpkin> PVM?
00:45:13 <Kaidelong> seems like you can make a correct sentence out of an arbtirary number of "is"s
00:45:36 <Kaidelong> a general version of Buffalo buffalo buffalo Buffalo buffalo
00:45:37 <Kaidelong> eg
00:45:43 <Kaidelong> Is is is is is is is
00:45:49 <pkrumins> so how do you decypher it
00:45:55 <pkrumins> let's start with 3
00:45:56 <pkrumins> is is is
00:46:46 <Kaidelong> the word is is the word is
00:46:56 <Kaidelong> the statement is is is is the statement is is is
00:47:21 <djahandarie> You need to learn how to use quotes man
00:47:36 <Kaidelong> then it just becomes "Is is is" is "is is is"
00:47:44 <opqdonut> (fsvo correct!)
00:47:58 <pkrumins> hrm, i dont get the 'is is is', what is 'is is'?
00:48:03 <pkrumins> 'is is' is.
00:48:08 <pkrumins> so what's the 'is is'
00:48:27 <Kaidelong> Is
00:48:28 <Kaidelong> is is
00:48:38 <pkrumins> i give up
00:48:42 <pkrumins> english is not my native language
00:48:47 <pkrumins> i get two is-es
00:48:52 <pkrumins> but not 3 or more.
00:49:04 <Kaidelong> I suppose two would work too
00:49:04 <DigitalKiwi> i don't get it and English is my native language, so don't feel bad
00:49:11 <pkrumins> :D
00:49:12 <djahandarie> If the second "is" is being used as the copula, then the third one would need to be an adjective, and "is" is not an adjective
00:49:25 <Kaidelong> hmm
00:49:39 <Kaidelong> Is that really a rule?
00:49:46 <Kaidelong> It is a dog
00:50:01 <Kaidelong> It is it
00:50:33 <djahandarie> Okay yeah that was not the proper rule
00:50:44 <djahandarie> It links the subject with a predicate
00:53:07 <Kaidelong> is there a test to see if two symbols are bound to the same thing?
00:53:21 <Kaidelong> I don't imagine there would be
00:53:26 <Kaidelong> since it'd be useless
00:53:33 <Kaidelong> well, maybe not
00:53:41 <Kaidelong> but it could be analogous
00:53:52 <blackdog> Kaidelong: no. i think it would break referential transparency
00:54:54 <Kaidelong> blackdog: now I'm going to be worried all night trying to figure out why
01:03:06 <blackdog> Kaidelong: well, you're meant to be able to replace a symbol with its value, right?
01:03:31 <blackdog> if you could tell whether a value actually  _was_ a symbol in some sense, you'd be able to write code that broke that
01:03:33 <Kaidelong> blackdog: what would doing so accomplish?
01:03:52 <blackdog> we don't really have a strong notion of a symbol in the Lisp or Ruby sense, anyway - not as a first-class entity
01:04:23 <Kaidelong> err misread that
01:05:14 <Kaidelong> hmm I suppose it's problematic anyway if for some reason two values that are the same via Ord or some other means are stored at different locations in memory
01:05:28 <Kaidelong> are the two symbols pointing to the same thing or not?
01:05:33 <copumpkin> why do you care?
01:05:35 <blackdog> yes, that's basically it
01:05:42 <Kaidelong> copumpkin: I don't
01:05:51 <copumpkin> :)
01:05:57 <blackdog> the whole point is that the implementation is meant to have the freedom to implement the given semantics any way it likes
01:05:57 <ToRA> you can get a very very weak notion of identical symbol using StableName and (in the IO monad of course)
01:06:29 <Kaidelong> the whole reason I was guessing that wouldn't be the guess was due to how useless the concept seemed to me
01:06:38 <Kaidelong> the case*
01:06:52 <copumpkin> or an even weaker notion of it
01:06:56 <Kaidelong> I didn't realize it could break referential transparency though, but I can see how it might do so
01:06:57 <copumpkin> with reallyUnsafePtrEquality
01:07:17 <Kaidelong> if you simply compare the pointers, yeah
01:07:49 <ToRA> StableName will look through GHC indirections though, so it's slightly better than comparing pointers (but it's tantamount to the same thing)
01:09:00 <copumpkin> yeah
01:22:28 <dv-> -Wall doesn't work if you use a LANGUAGE pragma?
01:22:45 <copumpkin> it should
01:24:20 <dv-> Oh now it does
01:33:34 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Robin Milner"]'
01:33:34 --- topic: set by Pseudonym!~ajb@torchwood.alicorna.net on [Tue Mar 23 22:12:43 2010]
01:33:34 --- names: list (clog freiksenet amiri scm shag jrib musicallyut ManateeLazyCat scoles dschoepe Schmallon veneri fasta toothbrush Anti-X rl danharaj mocha jejansse ml-n perspectival baguasquirrel nff zachk visof sigh Beetny Kaidelong ExtraSpice Itkovian zakwilson dsfox thetallguy1 thetallguy TacticalGrace novas0x2a1 eevar2 raichoo noteed Mowah hackagebot iblechbot maurer_ kar8nga d0ugal ketil jaspervdj agemo_ ahunter copumpkin augur JoeyA visit22 potatishandlarn koala_man)
01:33:34 --- names: list (kfish ttmrichter marchdown aconbere hants chittoor paolino ablokzijl dolio vili shintah sshc ybit trie siracusa occamshatchet portnov ilhvm otto_s_ inr jon_of_arc avenge Draconx cubi zomgbie emma mjonsson gwern cpettitt agricola Gracenotes glguy fonz gbeshers saccade_ horms waterlaz kermit Trafalgard theorbtwo Baughn edwardk kyagrd bens Mathnerd314 RogueShadow yairchu dysinger `0660 Saterus AdamSkelton inimino ve pikhq muhtimin joga Agnostos Axman6 XniX23)
01:33:34 --- names: list (winxordie miclorb eno HugoDaniel l-b jbapple hydo nitromaster101 tmug LeNsTR NNshag ShameOnMe rhlampe wjt uorygl jao tommd icekiller mamalujo_ iizukaway lpsmith_ cozachk2 Saizan ClaudiusMaximus Oejet Cale ajhager nominolo alios dfkjjkfd kpreid Eelis Polarina ziman voker57 gogonkt M| pimeys kg4qxk dreacu666 flori Colours magicman dayz karld jlouis muep kynky Philonous dever cao Ke eagletmt lenbust int-e sakhi IceDane daed wto Philippa mm_freak mfp sShintah)
01:33:34 --- names: list (mexisme integral noj raymonvw radhermit ahlmal tessier__ khiroc peddie blackdog sbahra xinming_ a11235_ sordina trez kar-1 htoothrot Associat0r Amadiro ski ricky kosmikus noddy sebbe1991 jims makmanalp p_l glith jonafan Jedai nathanic Spockz walrus_ mun flippo JaffaCake preflex Dashkal mauke Cthulhon ivan qz ville Berengal orbitz cozmic nzfrio yahooooo Milo- Apocalisp aleator tavelram nekochan eevar dobie_gillis tessier cyanoacry Contra ddarius andrewsw)
01:33:34 --- names: list (tviyLog Gabbie norm2782 stenobot2010 clanehin Taggnostr2 alexsuraci DigitalKiwi cheater2 d-snp akosch olsner luite QtPlatypus alip jmv_ Wolong jystic ahihi ptrf dual mfoemmel jvoorhis Bleadof arcatan ibt PepeSilvia chromakode futilius EvanR sjanssen samulihs sm AnAdorableNick Igloo waern bgs000 xcvii ksandstr AnMaster chewbranca dv- boyscared joed eyck Hunner mietek CompanionCube Stephan202 taruti jayne HandheldPenguin jql EvanR-work edwtjo helgikrs wli)
01:33:34 --- names: list (caligula__ defn te eric_j ido fnordus jesusabdullah gbacon cjay systemfault blalb stepnem StarFire dwon solidsnack Khisanth frederik solrize Jaak araujo mjrosenb sutats The_third_man tvaalen PsiOmega shutdown_-h_now monochrom felipe_ dino- hiredman electrogeek tensorpudding etpace rokoteko idnar chitragupt Veinor saccade scree lostman deavid iratsu eikke earthy cognominal Ornedan kalven pwerken Valodim dfeuer jix FauxFaux _2x2l SamB_XP tromp ps-auxw)
01:33:34 --- names: list (igorgue nniro mdmkolbe tumult kennethd Innominate quuxman jsk bremner Tass_ teratorn mlh exDM69 Ferdirand s0ro Counter-Strike Tomas drbean jbauman mux Aikawa osfameron twobitsprite shadowspar creichen SimonRC qm13 guerrilla CosmicRay impl djahandarie drhodes jvogel Laney shajen koninkje_away vpetro shepheb arw wagle Paradox924X Jon eldragon machine133 lambdabot jorizma marten lsthemes dcoutts jml Choko mk64ftw_ OnionKnight ikex companion_cube joni6128)
01:33:34 --- names: list (dcoutts_ dmwit Poeir teukka pettter ra1m0 dropdrive dogmaT_ bbee go|dfish Obfuscate byorgey opqdonut gdsx Vq DustyDingo Tinned_Tuna qebab danderson Deewiant MadX` tab chr1s_ LeoD nothingmuch mdordal2 MacCoaster strobedream flux Zao dqd stroan pielgrzym Nereid yottis snr nimred erk__ michael| rtaycher_ cynick encryptio_ StoneToad Bassetts mq Ytinasni hellige nnunley Gilly SamB_irssi mattam untwisted alexbobp JuanDaugherty zsol dcolish kadoban pkrumins twn)
01:33:34 --- names: list (dixie Sisu welterde McManiaC DrSyzygy sohum baaba tamiko cYmen profmakx nominolo_ Liskni_si nlogax _br_ eintopf emias sproingie ennen icee helino megaTherion Reisen soeren endojelly newsham MarcWeber tomaw Twey trzkril nornagon erg dumael duairc ctrlfreak tltstc PHO_ dejones aavogt ehamberg tyfon dilinger fab__ jamwt andersk mercury^ amx And[y] ezyang davean ernst albertosantini __marius__ mrd ahf kaol aslhk pastorn thoughtpolice regulate @ChanServ skaar)
01:33:34 --- names: list (sbok mrshoe laz0r harlekin Blub\0 majoh Cerulean canvon jd10_ MrDomino^ jrockway srcerer slabanja allbery_b palmje inhortte TML Nanar jmcarthur tridactyla willb BrianHV russell_h epmf bd_ inclement Rooz ibid gds npouillard edwinb nasloc__ mornfall dons Aisling LoRe alexsdutton aristid ydo tilman otulp thorkilnaur Raku^ kevinclark burp dionoea netcat shortcircuit aiko- tew88 kolmodin eek companio1_square hugin quaestor hc_e gereedy Jiten tafryn quicksilver)
01:33:34 --- names: list (clarkb ingy det bashrc_ Vulpyne bolmar frey dax ToRA UnderTaLker desu Boney_ Botje pshc epokal saiam zygoloid shu suiside woggle Davse_Bamse fabjan matthew-_ m4thrick deadguys ath SubStack xerox davidL absentia jdsc_ beatmox shachaf Lemmih)
02:09:06 <digitteknohippie> quick question: how can i get quotation marks ignored, like /" in bash..?
02:09:17 <digitteknohippie> oops.
02:09:47 * digitteknohippie sees his mistake
02:13:17 <EnglishGent> hello all :)
02:13:28 <Silvah> Hello.
02:13:54 <EnglishGent> hi Silvah :)
02:14:18 <ivanm> hey EnglishGent
02:14:26 <EnglishGent> hi ivanm :)
02:17:45 <ivanm> greetings m3ga
02:17:56 <m3ga> hi ivanm
02:18:08 <m3ga> fp-syd this week?
02:18:18 * hackagebot proc 0.0.3 - Parse process information for Linux  http://hackage.haskell.org/package/proc-0.0.3 (AndyStewart)
02:18:19 * ivanm had no idea it was on
02:18:35 <ivanm> and my brother is coming down from brisbane tomorrow, so I probably shouldn't go to sydney this weekend... >_>
02:18:40 <digitteknohippie> just curious, anyone here tried TidOS yet? http://bbs.archlinux.org/viewtopic.php?id=97076
02:18:51 <digitteknohippie> uses xmonad as it's default wm
02:19:06 <ivanm> m3ga: how/where would I found bus/train timetables for sydney (so I can match how to get to/from the coach terminal in town to UNSW) ?
02:19:29 <ivanm> digitteknohippie: I don't see the point of something like that tbh
02:19:50 <ivanm> especially since it's by a 4chan guy and there was this case a few years back about 4chan bagging out Haskell...
02:20:22 <ivanm> looks like someone even resurrected it: http://dis.4chan.org/read/prog/1274087988
02:20:27 <digitteknohippie> heh, i thought that'd be most peoples responce, but i quite like the idea of "distros"(/flavours) that let folks have a different starting point closer to what they like.  otherwise we'd all be using LFS. ;)
02:20:42 <m3ga> ivanm: its not at UNSW, its at google in pyrmont.
02:21:06 <ivanm> m3ga: I'm talking about AusHack ;-)
02:21:29 <ivanm> digitteknohippie: except the whole point of Arch is a self-configured distro...
02:21:36 <ivanm> so having defaults is kinda against the whole point is it not?
02:21:51 <m3ga> ivan: bus/train timetables are at http://www.cityrail.info/
02:21:59 <m3ga> for sydney that is
02:22:03 <ivanm> right
02:31:08 <digitteknohippie> ivanm, if the "whole point" was just that, like i said, we'd all be using LFS. :P   some of us want a leg-up to get arch... like archbang for a great example.   saves an hour (or days depending on your skell/experience)or so configuring.   assuming it's pretty close to what you want.
02:32:42 <ivanm> digitteknohippie: except LFS doesn't have packages, dep resolution, etc.
02:33:17 <digitteknohippie> i thought the whole point was you do it yourself.  lol
02:33:38 * scree 's default configuration has gcc and a few system tools
02:33:43 <digitteknohippie> ;)   tis all just different stages to get onboard the linux train
02:34:51 <djahandarie> Haskell oddly seems to be pretty popular on /prog/
02:35:12 <quicksilver> that's because 90% of the posts on /prog/ are from dons
02:35:21 <quicksilver> the one-man-haskell-advocacy-machine
02:35:23 <quicksilver> ;)
02:35:56 <djahandarie> lol...
02:38:15 <Silvah> Hm, how many linux users are there at this channel?
02:38:50 <ville> 3 by the last count
02:38:58 <digitteknohippie> lol
02:41:17 <Silvah> > 3^10
02:41:19 <lambdabot>   59049
02:41:33 <Silvah> Okay, you're right.
02:43:09 * Silvah realized that he reinvented State monad once again.
02:43:33 <ivanm> Silvah: heh
02:51:00 <leejr> the other day I mentioned the possiblity of a dataless language ,  I thought that the entire languagee could be morphisms.  I said I would try to make a sample, and I did.
02:52:10 <copumpkin> yeah?
02:52:21 <leejr> yes.
02:52:37 <leejr> it was  an interesting little game.
02:53:48 <leejr> even if it is wrong,  it still made me think. Also if you remember from our discussion,  I wanted to base the language on the notion of associative algebra.
02:54:35 <leejr> I didn't know that monads (in the math sense) were all about that.
02:54:38 <Cale> leejr: Some sort of points-free version of associative algebra?
02:55:01 <leejr> Backus had a similar inkling himself.
02:55:13 <Cale> Ah, okay
02:55:25 <Cale> So you have functions and they can be composed.
02:55:44 <leejr> In fact,  what I produced is a weird blend of backus-naur C++ templates, and haskell.
02:55:45 <Cale> (a category of functions of some sort)
02:55:54 <copumpkin> hmm
02:56:05 <leejr> yes, Cale.  you got it real fast.
02:56:13 <quicksilver> Silvah: the state monad is just a convenient set of combinators for building functions. Since building functions is a very important and natural notion, reinventing the state monad all over the place is rather natural.
02:56:40 <leejr> Is the state monad anything like the state bird?
02:57:36 <Cale> leejr: Have you seen Backus' language "FP"?
02:57:45 <mauke> preflex: remember <leejr> Is the state monad anything like the state bird?
02:57:48 <leejr> I just read about it
02:58:07 <leejr> FP
02:58:18 <copumpkin> it's a pretty crap name for a language, I must say
02:58:33 <copumpkin> but probably not worse than c
02:58:43 <Silvah> quicksilver: but then you're not making a Monad instance, and I did that.
02:58:57 <leejr> in category theory,  morphisms act on objects
02:59:00 <copumpkin> luckily it doesn't exist
02:59:03 <mreh> hmm, I didn't realise there was a subtle difference between an non-deterministic arrow, and an arrow that is generated non-deterministically
02:59:15 <copumpkin> moarphisms
02:59:36 <leejr> in group theory, the morphisms are the objects
02:59:41 <mreh> do I need applicative arrows to make this work?
03:00:13 <copumpkin> leejr: not sure I see that. You can represent a group (or a monoid) as a category with a single object whose morphisms are the elements of the carrier set?
03:00:26 <leejr> so the notion is to get rid the objects and have them represented by morphisms
03:00:47 <Cale> leejr: I'm not sure I agree with your view of group theory...
03:00:51 <Silvah> Well, perhaps hand-rolling a lexer and parser is not the most bright idea.
03:00:56 <mreh> we talk about category theory in here too much
03:01:04 <copumpkin> mreh: what's too much?
03:01:19 <quicksilver> Silvah: sure, sometime it's nice to write the monad instance; then you get things like sequence and mapM for free.
03:01:19 <mreh> copumpkin: people ignore my questions :)
03:01:32 <leejr> the associativity of group theory is really just composition
03:01:46 <copumpkin> mreh: I don't know what an applicative arrow is :P besides, applicatives and arrows are categorical constructions, so CT is fine ;)
03:01:57 <leejr> if its associative then its compositional
03:01:59 <ivanm> is there a version of Map.insert that lets you specify what to do if two index calues are equal rather than just overriding the one that's there?
03:02:05 <Cale> leejr: So, you're looking at group elements as being represented by their actions by, say, left multiplication on the elements of G?
03:02:12 <copumpkin> ivan: insertWith
03:02:28 <copumpkin> :t M.insertWith
03:02:29 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
03:02:32 <ivanm> copumpkin: can't seem to find that...
03:02:33 <copumpkin> or is that not what you wanted?
03:02:37 <leejr> rhink of the complex plane
03:02:38 <ivanm> huh?
03:02:46 <ivanm> damn, I'm looking at Data.Set's docs by accident :s
03:02:49 <copumpkin> :)
03:02:57 * ivanm _thought_ there was a Map.insertWith :s
03:02:58 <leejr> 1 is simple a rotation of zero degrees
03:03:02 <leejr> simply
03:03:21 <leejr> i,  the imag unit, is a rotation by 90 degrees.
03:03:34 <copumpkin> (with multiplication)
03:03:53 <leejr> so now we have two pieces of 'data' represented by operations.
03:04:07 <mreh> this is the applicative arrow a (a b c, b) c
03:04:11 <Cale> leejr: Right, so you're thinking of the left or right multiplication representation of a group.
03:04:13 <Vitka> @pl \(a,b) -> g (f a) (f b)
03:04:14 <lambdabot> uncurry ((. f) . g . f)
03:04:18 <copumpkin> mreh: oh, ArrowApply!
03:04:41 <copumpkin> Vitka: on
03:04:42 <mreh> copumpkin, already exists?
03:04:47 <mreh> oh!
03:04:54 <copumpkin> :t apply
03:04:55 <lambdabot> Not in scope: `apply'
03:04:57 <Silvah> :t on
03:04:58 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:04:59 <Vitka> @hoogle on
03:05:00 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:05:00 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
03:05:00 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
03:05:04 <mreh> :t app
03:05:05 <copumpkin> @src on
03:05:05 <lambdabot> (*) `on` f = \x y -> f x * f y
03:05:05 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
03:05:12 <leejr> let me paste a little text here
03:05:13 <copumpkin> :t uncurry on
03:05:14 <lambdabot> forall b c a. (b -> b -> c, a -> b) -> a -> a -> c
03:05:23 <copumpkin> :t curry on
03:05:25 <lambdabot>     Couldn't match expected type `(a, b)'
03:05:25 <lambdabot>            against inferred type `b1 -> b1 -> c'
03:05:25 <lambdabot>     In the first argument of `curry', namely `on'
03:05:27 <copumpkin> pff
03:05:30 <djahandarie> Type signature spam T_T
03:05:35 <copumpkin> sorry :P
03:05:53 <Vitka> Hmm.
03:05:56 <Cale> If you have any group G, you can form a representation phi: G -> (G -> G), simply by currying the multiplication: phi(x)(y) = x*y.
03:06:15 <leejr>  calculation example code
03:06:17 <leejr>   where X takes an argument
03:06:19 <leejr> X ~ @a = sum
03:06:20 <leejr>     ~ real ~ @a
03:06:22 <leejr>     ~ real ~ 3.14
03:06:23 <leejr> Y = 3.14
03:06:25 <leejr> TWO_PI = X ~ Y
03:06:49 <Cale> I'm not sure I understand your notation here.
03:06:51 <leejr> the above shows a curried function
03:07:20 <leejr> it defines X as composing with some function @a
03:08:15 <leejr> this function is defined as the 'sum' operation,  which of course, takes two arguments
03:08:34 * copumpkin isn't getting it
03:08:40 <Silvah> What's the difference between WHNF and HNF, exactly?
03:08:52 <Cale> Silvah: All lambda terms are in WHNF
03:08:53 <copumpkin> Silvah: WHNF can't see through lambdas, I think
03:09:04 <Cale> Silvah: A lambda term is in HNF only if its body is in HNF.
03:09:30 <leejr> X(@a)=sum(real(@a),real(3.14))
03:09:40 <copumpkin> hmmm
03:09:44 <Cale> WHNF is a better representation of what evaluation in real programming language implementations tends to do.
03:09:50 <leejr> in more standard notation
03:10:16 <quicksilver> Cale: although a compiler might do some evaluation under lambdas at compile time
03:10:24 <quicksilver> (but it's very unusual at runtime)
03:10:25 <Cale> quicksilver: That's a good point :)
03:10:50 <copumpkin> "A groupoid is a small category in which every morphism is an isomorphism"
03:11:00 <copumpkin> why do they say specifically a small category?
03:11:14 <Cale> copumpkin: Probably for convenience?
03:11:16 <copumpkin> ah
03:11:21 <leejr> the ~ means composes with
03:11:51 <quicksilver> copumpkin: defintely not a universal convention.
03:11:56 <copumpkin> ok :)
03:12:08 <leejr> if it requires more than one argument, then each argument is put on a new line, indented.
03:13:28 <Cale> copumpkin: One of the nicest applications of groupoids is this: you take all the points in a topological space X, and those become the objects of a groupoid, and the arrows x -> y in the groupoid are equivalence classes of continuous paths f: [0,1] -> X with f(0) = x, f(1) = y, where two paths are equivalent if there's a homotopy between them
03:13:30 <leejr> you can see than anything that can be an argument of real()  can be an argument of X.  That defines the 'type' of X.   X(@a)=sum(real(@a),real(3.14))
03:14:25 <Cale> copumpkin: and you define composition by "gluing together" two paths end to end
03:15:05 <leejr> Cale, were you here when I called my idea,  symplectic functional algebra?
03:15:10 * copumpkin has almost no topology knowledge :) but I think I understand that
03:15:31 <leejr> Wow Cale,  you see things fast.
03:15:34 <copumpkin> but it's also past 6 am and I should probably sleep
03:15:37 <Cale> Like f . g = h where h(t) = f(t/2) for 0 <= t <= 1/2, and h(t) = g(t/2 + 1/2) for 1/2 <= t <= 1 (and note that they must match at 1/2)
03:15:39 <leejr> holy crap.
03:16:13 <leejr> Cale,  in fact this is the idea behind Stokes theorem of differential geometry.
03:16:40 <Cale> leejr: You might find this book interesting: http://cale.yi.org/share/Sets%20for%20Mathematics.pdf
03:17:21 <Cale> leejr: It's not unbiased in its approach to the foundations of mathematics, but there's some interesting approaches there :)
03:17:53 <Cale> Basically it talks about a categorical, compositional approach to set theory
03:18:12 <leejr> its downloading.
03:18:30 <leejr> let me paste an implementation of the positive integers.
03:19:35 <leejr> first maybe this will help clear the notation.  my apologies to others ignoring this conversation
03:20:47 <leejr> z = prod
03:20:49 <leejr>     ~ sum
03:20:51 <leejr>         ~ real ~ 6.1
03:20:52 <leejr>         ~ real ~ 3.14
03:20:54 <leejr>     ~ sum
03:20:56 <leejr>         ~ prod
03:20:58 <leejr>             ~ real ~ 33.1
03:20:59 <leejr>             ~ real ~ 7.3
03:21:01 <leejr>         ~ real ~ 992.4
03:21:03 <leejr> ## lets see how the above would  be processed according to
03:21:04 <leejr> ## the rules
03:21:06 <leejr> ##  the above gets mapped to
03:21:08 <leejr> z = prod
03:21:10 <leejr>     ~ sum
03:21:12 <leejr>         ~ real ~ 6.1
03:21:14 <leejr>         ~ real ~ 3.14
03:21:16 <leejr>     ~ sum
03:21:18 <leejr>         ~ real ~ native  //(33.1 * 7.3)
03:21:19 <Feuerbach> leejr: omg, use pasting services
03:21:19 <leejr>         ~ real ~ 992.4
03:21:21 <leejr> ## gets mapped to
03:21:22 <leejr> z = prod
03:21:24 <leejr>     ~ real ~ native // (6.1 + 3.14)
03:21:25 <leejr>     ~ real ~ native // (33.1 * 7.3) + 992.4
03:21:27 <leejr> ## gets mapped to
03:21:28 <leejr> z = real ~ native // (6.1 + 3.14) * ( (33.1 * 7.3) + 992.4 )
03:21:30 <leejr> ##
03:21:31 <leejr> ## another more bite sized way of doing it
03:21:33 <leejr> ##
03:21:34 <systemfault> Nobody is going to help you.
03:21:35 <leejr> a   = sum
03:21:36 <leejr>     ~ real ~ 6.1
03:21:38 <leejr>     ~ real ~ 3.14
03:21:39 <leejr> b   = prod
03:21:40 <Cale> Yeah, please don't dump so many lines into the channel.
03:21:41 <leejr>     ~ real ~ 33.1
03:21:42 <leejr>     ~ real ~ 7.3
03:21:44 <leejr> c   = sum
03:21:46 <systemfault> We hate flooders.
03:21:46 <leejr>     ~ b
03:21:48 <leejr>     ~ real ~ 992.4
03:21:49 <leejr> z   = prod
03:21:51 <leejr>     ~ a
03:21:52 <leejr>     ~ c
03:21:55 <leejr> how do I do that?
03:21:57 <leejr> shut up systemfault
03:22:03 <Cale> hpaste.org
03:22:22 <systemfault> leejr: Shut up or not, we don't like being flooded.
03:22:30 <systemfault> So next time, use a pastebin.
03:22:32 <quicksilver> leejr, systemfault : keep it friendly please
03:22:52 <Cale> copumpkin: This defines a functor from the category of topological spaces and continuous maps to the category of groupoids. If you fix a special point in each category and only consider the automorphisms (paths) in the groupoid from that point to itself, then you get a functor from pointed topological spaces to groups.
03:23:41 <leejr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25574#a25574
03:23:54 <leejr> I thought it was a bot
03:24:41 <Feuerbach> Have anyone used/seen approach of decomposing an applicative functor instance to a pure and effectful parts? Like pure f <*> effect1 <*> effect2 <*> ...?
03:24:59 <kmc> == f <$> effect1 <*> effect2 <*> ...
03:26:21 <Feuerbach> kmc: right. But the point is, effect_n are "pure effects" (whatever that means for a concrete instance)
03:26:25 <Cale> leejr: It looks like you're still working with values here though, you've just changed notation a bit.
03:26:48 <Cale> leejr: After all, you're still defining functions by pattern matching on the arguments.
03:26:57 <quicksilver> Feuerbach: pure effects meaning they don't return a value? so they always return () ?
03:27:19 <quicksilver> Feuerbach: in that case, that might as well be effect1 *> effect2 *> pure (f () ())
03:31:24 <Feuerbach> quicksilver: suppose I have datatype with constructors Pure, App and Effect, which is instance of Applicative. I am given a value of that type and want it to transform to (roughly speaking) Pure f `App` (Effect ..) `App` (Effect ..)
03:31:42 <Feuerbach> trouble is that I cannot know the type of f
03:31:53 <leejr> there is some ambiguity in that
03:31:57 <Feuerbach> (its number of arguments)
03:31:58 <leejr> Cale
03:32:05 <leejr> for example
03:32:17 <quicksilver> Feuerbach: what you are doing is not what I understand by 'pure effect'.
03:32:30 <quicksilver> Feuerbach: those are completely general effects, not pure effects, IMO.
03:32:31 <leejr> in C++  6 can be an integer.
03:32:52 <quicksilver> Feuerbach: but anyhow there is a section in the applicative paper which has a sketch (or maybe even a proof) of what you're saying.
03:32:57 <mornfall> :t 6
03:32:58 <lambdabot> forall t. (Num t) => t
03:33:03 <leejr> but it can also be used to create a unique class if given as a template argument
03:33:10 <quicksilver> ivanm: You're wrong about showList.
03:33:41 <quicksilver> ivanm: no, you're not, you're right.
03:33:44 <quicksilver> ivanm: please ignore me ;)
03:33:53 <leejr> template <int I> class AnInt { };
03:34:09 <ivanm> quicksilver: :o
03:34:13 <ivanm> quicksilver: what made you think I was wrong?
03:34:14 <leejr> Now,  AnInt<6>  is it's own class.
03:34:30 <quicksilver> ivanm: I misread your message.
03:34:36 <ivanm> aha
03:35:19 <leejr> My line of thinking was to eliminate the distinction between the two uses of 6
03:38:09 <leejr> Cale: Anyhow,  I appreciate you looking at it.
03:39:44 <leejr> When I think about how to do IO,  it seems as though input would have to be all the way to the right, and output all the way to the left, like stub ends.
03:40:56 <leejr> because input would take no argument (much like a literal)  and output would not be allowed to be used as an argument
03:43:21 <leejr> thanks for the article link too.  I like it already.
03:43:49 <quicksilver> I haven't been following entirely but it seems unlikely that all input takes no argument
03:44:06 <quicksilver> for example (in haskell) hGetLine has one argument - the Handle to read from.
03:44:20 <quicksilver> it's quite common for primarily input actions to be parameterised in some way.
03:45:34 <leejr> But the chain of composition would end at a io function.  for example:
03:45:42 <leejr> getLine
03:46:41 <leejr>    ~ lookup_channel ~ "keyboard 1"
03:47:01 <leejr>   ~ char ~ KBD
03:47:24 <leejr> after KBD there can't be a ~
03:48:36 <leejr> so 'getLine'  does get parameterised,  but the actual input would be a terminus
03:49:12 <pastorn> leejr: stdin/stdou/sterr are all :: Handle, but they're constants
03:49:20 <pastorn> @src getLine
03:49:20 <lambdabot> getLine = hGetLine stdin
03:49:41 <pastorn> @src putStr
03:49:41 <lambdabot> putStr s  = hPutStr stdout s
03:50:15 <scree> what's with the lack of partial application?
03:50:25 <newbie008> i was thinking the same thing
03:50:30 <newbie008> but i guess getLine doesn't take a parameter
03:50:36 <newbie008> but yeah it looks curried to me too lol
03:50:44 <newbie008> i was thinking "why isn't putStr curried too?"
03:53:46 <leejr> anyhow, the sample file is there.  I would encourage anybody to play with it a bit.  it does make one relflect upon the process of programming and it's relationship to fundamental mathematics.
03:54:26 <newbie008> oh boy let's not start math vs programming  :)
03:57:20 <leejr> I never did come across any conceptual dificulties.   It seemed to work.
04:01:24 <leejr> Even the analogy with simplectic  topology works with the IO,  the IO would be the boundary operator on the program 'manifold'
04:02:25 <leejr> bbye
04:02:55 <profmakx> newbie008 its maths, damnit.
04:04:12 <newbie008> profmakx: why?
04:04:53 <newbie008> profmakx: http://www.merriam-webster.com/dictionary/math
04:08:13 <newbie008> profmakx: anything to add?
04:08:27 <profmakx> yeah, newbie008, its maths
04:08:38 <newbie008> profmakx: why?
04:09:40 <newbie008> profmakx: maybe you're in the UK, but here in the US it's "math" ------>   http://www.askoxford.com/concise_oed/maths?view=uk
04:11:04 <Cale> For some reason, I use both interchangeably, though I'm more likely just to say "mathematics".
04:12:09 <Cale> I'm a bit concerned with OED's definition of mathematics as a branch of science. That's not right. :)
04:13:28 <Cale> Though I guess in the more forgiving broader definitions of science it fits
04:13:30 <ivanm> Cale: so what is it then, humanities? :p
04:14:04 <profmakx> it is just mathematics.
04:14:07 <Cale> Well, it's its own sort of study.
04:14:09 <Cale> yeah
04:14:19 <newbie008> it's not science really, Cale is right
04:15:11 <newbie008> for something to be a science it has to have falseability
04:15:18 <quicksilver> I think maths is a science; I think cale was probably thinking of some more specific category like 'empirical science'
04:15:25 <ivanm> Cale: I think it was in here, where someone once semi-seriously suggested to their uni council that mathematics should be put in the humanities department since its akin to philosophy, logic, etc.
04:15:36 <ivanm> quicksilver: I see maths as more akin to a toolkit
04:15:38 <quicksilver> science is just organized knowledge/study.
04:15:50 <ivanm> which is more seriously used by the sciences, then by engineering, etc.
04:16:01 <ivanm> where "science" to me involves studying that "real world" thing-y :s
04:16:12 <quicksilver> it may mean that to you, but that's not what it actually means.
04:16:19 <newbie008> ivanm: yes we usually think of science to mean "empirical"
04:16:25 <Cale> quicksilver: Under that broad definition, sure. But I tend to take 'science' to mean a branch of study which has the scientific method at its heart.
04:16:56 <digitteknohippie> ah science, yes, "natural philosophy" as it was called originally.   so i read.
04:17:11 <Cale> If you don't rely on the scientific method, what you're doing is not properly science, at least, as far as I'm concerned :)
04:17:13 <newbie008> Cale: correct, and math does not make use of the scientific method
04:17:21 <quicksilver> Cale: sure. A very common meaning, but not the only meaning. That's what I was referring to by 'empirical science'.
04:17:33 <newbie008> again correct
04:17:36 <newbie008> it's not the only meaning
04:17:39 <Cale> Yeah, there are other, older definitions.
04:17:48 <newbie008> right
04:17:51 <newbie008> like from latin
04:17:52 <newbie008> Scientia
04:17:58 <newbie008> means just "knowledge"
04:18:08 <Cale> Going back to just being a state of knowing, yes :)
04:18:35 <newbie008> scio, scis, scit, scimus, scitis, sciunt - i know, you know, he/she/it knows, we know, you know, they know
04:18:42 <newbie008> :)
04:19:06 <quicksilver> true though that may be, etymology is not meaning.
04:19:18 <quicksilver> lots of words have meanings quite apart from their etymology.
04:19:28 <newbie008> it's not, that's true
04:19:33 <newbie008> but etymology is still important
04:19:35 <digitteknohippie> and whats the old aneccdote about the father of modern science starting it all from a visit from an angel... :D  pretty amusing considering many self professed scientists declare (without having done any study) that there are no such thing as angels, ignorant to this being mere assumption, not having gone through the rigours of scientific study.
04:19:45 <newbie008> because with it we see what the word mean when it was originally created
04:19:58 <Cale> Right. My original contention was that we should try to use the word 'science' in the modern sense I suggested. :)
04:20:39 <newbie008> Cale: and i agree with that but some people still want it to mean somethign broader as we've just seen
04:20:56 <digitteknohippie> what, as a neurolinguistic programming tool to hypnotise people into blind belief?
04:21:15 <Cale> digitteknohippie: Simply as a matter of being clear about what we mean when we say it.
04:21:28 <newbie008> Cale: he's being a troll
04:21:39 <Cale> newbie008: That may be.
04:22:24 <quicksilver> Cale: http://en.wikipedia.org/wiki/Formal_science has a reasonable list of non-empirical sciences in its introductory paragraph.
04:22:24 <Cale> newbie008: But the usual policy here is to treat trolls as if they are asking honest questions, because that may be the case after all.
04:22:50 <newbie008> Cale: hmm that's an interesting policy
04:22:51 <Cale> quicksilver: I just don't care for that choice of words is all.
04:23:28 <quicksilver> fair enough. I'm quite happy with a notion of science broad enough to encompass maths, linguistics, logic, etc.
04:23:45 <newbie008> woah hold on there, linguistics is actually a science :)
04:23:47 <Cale> I might call those things "formal systems of reasoning"
04:24:17 <Cale> Some linguistics is at least trying to be a real science :)
04:24:23 <newbie008> yes
04:24:23 <quicksilver> apparently back in the 17th century we would have distinguished these two groups by using the phrases "natural philosophy" and "moral philosophy"
04:24:39 <quicksilver> I suggest we abandon the word science entirely and fall back to those two, they sound nice.
04:24:55 <quicksilver> mathematicians are merely moral philosophers!
04:25:04 <newbie008> that'd be awesome
04:25:15 <newbie008> we rarely use the word "moral" anymore
04:25:57 <Cale> I think we should wait a while until 'moral' loses its commonplace sense for that ;)
04:26:08 <newbie008> shouldn't take long
04:27:13 <digitteknohippie> sry, wasnt intentionally being a troll earlier, just wanted to highlight a serious point about how folks swallow anything without question when told scientists said it was true.
04:27:40 <Cale> digitteknohippie: And that indeed is a problem, particularly when it's so needless, given the nature of science.
04:27:49 <newbie008> but everything scientists say _is_ indeed always true!  ;)
04:28:15 <digitteknohippie> heheh
04:28:21 <pastorn> who said something about moral philosophy?
04:28:28 <digitteknohippie> oh if only we could all speak fluent e-prime eh? :)
04:28:29 <pastorn> this is related, and awesome: http://athome.harvard.edu/programs/jmr/
04:28:54 <Cale> Actually, I've decided I don't care for the term 'moral philosophy' for that.
04:29:15 <Cale> It smacks of the platonic absolute view of mathematics.
04:29:31 <quicksilver> Cale: realistically I don't have time to replicate many experiments (or any, in fact) so I have to accept argument by authority on points of science.
04:29:33 <digitteknohippie> that reminds me of the mayan consciousness calendar as presented by ian xel lungold.
04:29:46 <quicksilver> Cale: I just have to try to form some judgement on the various authorities out there and decide who to trust.
04:30:14 <pastorn> here we go: http://www.youtube.com/watch?v=kBdfcR-8hEY
04:30:44 <digitteknohippie> for reference, that ian xel lungold talk i was talking about. http://video.google.com/videoplay?docid=-8689261981090121097 http://video.google.com/videoplay?docid=-567329528148516232
04:31:19 <Cale> quicksilver: Well, sure, but there's also a fair amount of stuff which is pretty accessible and worth seeing for oneself, or at least watching a recording of :)
04:32:13 <quicksilver> Cale: you know that recordings can be faked? Watching a recording is at best proof by authority.
04:32:38 <quicksilver> it's all some kind of probalistic assessment about human nature.
04:32:46 <Cale> quicksilver: Sure, you still have to apply your usual critical faculties :)
04:33:21 <quicksilver> What is the chance this is incompetent/an honest mistake? What's the chance it is a deliberate deception? What's the chance that other critical experts also watching it would call it out if it were? What's the chance that other critical experts actually have tried to replicate this, since I don't have time to do so?
04:33:28 <Cale> quicksilver: But, for example, I'm willing to bet that MIT is not going to fake a bunch of stuff from Walter Lewin's lectures.
04:33:32 <quicksilver> Right.
04:33:51 <quicksilver> You are just choosing a particular path down the 'proof by authority' route.
04:34:08 <quicksilver> This is not a criticism - you make that choice with good reason.
04:34:13 <Cale> and most if not all of the things there are easily verified by hand, so if they chose to fake them with special effects, it would become well known
04:34:21 <quicksilver> I just point out that at the end of the day we almost always choose to trust.
04:34:26 <quicksilver> the differences are just in whom we trust.
04:34:34 <newbie008> agreed
04:34:44 <quicksilver> You are trusting "the large body of scientists" - assuming that at least one would uncover the problems, if it was indeed a problem.
04:34:55 <quicksilver> and that if at least one did, you would somehow hear about his debunking.
04:34:56 <newbie008> but really it's only very few things where that matters
04:35:05 <newbie008> like, i trust that the medicines i take really work
04:35:14 * digitteknohippie prefers reservation to premature conclusion, and non-belief as a steady state.
04:35:18 <newbie008> but whether string theory is really true doesn't really impact my life
04:35:54 <digitteknohippie> the map is not the terrain.   string theory is just another map (or several maps).
04:35:57 <Cale> Well, there's a difference between, on the one hand, trusting someone on a matter which is testable, where they tell you how to check for yourself, and where many others are hearing the same account, and some will check, and on the other hand, trusting someone who just tells you something with no means of checking it or determining if it is true for yourself.
04:36:11 <quicksilver> Cale: Yes, there is.
04:36:40 <quicksilver> Cale: but take the LHC for example - who has the opportunity to 'check' the experiments there?
04:36:53 <quicksilver> not many people can build an LHC to repeat them. Not many people get to run experiments on them.
04:36:55 <newbie008> but who really cares?
04:36:59 <quicksilver> But, personally, I still trust the process.
04:37:00 <stroan> I would just like to point out that it is because of thinking like this no one here gets presents from Santa any more.
04:37:13 <quicksilver> :)
04:37:28 <dolio> Have I wandered into the other haskell-blah?
04:37:30 <Cale> The hope is that enough people are involved in the process of conducting the LHC experiments that intellectual dishonesty becomes extremely difficult.
04:37:35 <newbie008> that's true, like Nietzsche said, Santa is dead, and we killed him.
04:37:36 * quicksilver nods
04:37:42 <quicksilver> newbie008++
04:37:56 <newbie008> thanks :)
04:37:58 <quicksilver> if only nietzsche had, in fact, said that. It would have been much funnier.
04:38:07 <newbie008> he said that about god
04:38:14 <quicksilver> There is definitely place in the philosphical canon for a comedic version of Nietzsche.
04:38:17 <quicksilver> newbie008: yes I know what he said.
04:38:20 <Cale> What I have a problem with is that there's a lot of popular accounts of science where they *don't* inform people how things are to be verified at all, or on what evidence one might believe them.
04:38:24 <digitteknohippie> wouldnt matter, people would still have interpreted what ever they wanted.  like "kill all the jews".
04:38:39 <quicksilver> dolio: yes. Good point.
04:39:00 <quicksilver> Someone ask some haskell questions so I can stop my rambling and have some lunch while Cale answers them.
04:39:19 <stroan> what *are* monads
04:39:19 <stroan> ;)
04:39:21 <newbie008> i have a haskell question but i can't ask it now, i have to draw some stuff so that it's more understandable
04:39:24 <dolio> Anyone read the new SPJ et al paper?
04:39:25 <newbie008> hahah
04:39:31 * digitteknohippie strains to see what dolio said that was a good point
04:39:44 <dolio> digitteknohippie: I said you're absurdly off topic.
04:39:50 <Cale> stroan: Is that an honest question that you'd like me to explain the answer to?
04:39:59 <digitteknohippie> oh,
04:40:00 <newbie008> no he was jokin
04:40:00 <newbie008> g
04:40:02 * digitteknohippie sees
04:40:06 <stroan> Cale: nope. Just the archtypical haskell question
04:40:22 <newbie008> now i do have an intelligent question on monads though
04:40:23 <newbie008> may i?
04:40:27 <Cale> Sure
04:40:47 <stroan> dolio: what is the paper?
04:41:11 <dolio> It's an 80 page book on their new strategy for type inference.
04:41:17 <stroan> oh interesting
04:41:24 <stroan> I don't suppose it's up anywhere online?
04:41:32 <pastorn> dolio: OutsideIn?
04:41:40 <dolio> It's on his MS Research website.
04:41:41 <newbie008> okay: here's the minimum set of features a language has to have to implement continuation passing style: first-class functions, closures, tail call optimization. now: what's the minimum set of features for implementing monads in a language?
04:41:43 <dolio> Yes.
04:42:09 <Cale> newbie008: What do you mean by 'implementing monads'?
04:42:25 <Cale> newbie008: It depends on exactly what you're willing to call an implementation :)
04:42:28 <stroan> to write a function of type bind you need polymorphism and high order functions
04:42:47 <Cale> newbie008: My own view on it is that you're not *really* programming with monads unless you can write code which will work in any monad.
04:42:56 <pastorn> newbie008: there are continuations in c...
04:42:57 <dolio> http://haskell.org/haskellwiki/Simonpj/Talk:OutsideIn
04:42:58 <Cale> So you need a certain amount of polymorphism.
04:43:31 <Cale> It's possible to just use basic parametric polymorphism, and have every monad-polymorphic function or value take as a parameter the implementation of return and (>>=)
04:43:39 <Cale> But that is extremely awkward.
04:43:48 <dolio> There's a bit of duplication from some other papers, of course.
04:43:57 <Cale> So it's much nicer to have something like typeclasses
04:44:05 <dolio> It looked like it might contain most of the "let should not be generalized" paper.
04:44:23 <Vitka> I have not-so-intelligent question about not-exactly-monads. :)
04:44:55 <quicksilver> Cale: it's possible to use duck-typing for an implementation, alternatively.
04:44:57 <Cale> You also probably want a type system with type constructors -- the monads themselves are type constructors together with implementations of return and bind, or fmap, return and join, or similar.
04:45:03 <stroan> dolio: cheers. I need to redo the type inference system in my little language and have been looking for good materials
04:45:04 <Cale> duck typing is hard to use
04:45:08 <quicksilver> Cale: hence the implementations in scheme, python, perl
04:45:13 <Cale> Because return is polymorphic in its result.
04:45:24 <quicksilver> yeah, that part is hard.
04:45:34 <Cale> There are a lot of *bad* implementations in untyped languages
04:45:38 <quicksilver> :)
04:45:47 <Cale> Where you can't really write code that will work in any monad.
04:45:59 <dobblego> there are copy/paste implementations in Java/C#
04:46:02 <quicksilver> dolio: I find it rather scary it's so complicated. I hope it doesn't have a mistake in it.
04:46:26 <quicksilver> dolio: from what I remember there turned out to be a substantial mistake in the boxytypes paper (or one of the impred. papers, at least)
04:46:45 <Cale> If you just have a bunch of monadic libraries with nothing truly shared between them, then it's a bit pointless.
04:46:58 <quicksilver> dolio: I take the "grumpy old man" view that such papers should be written alongside an actual working implementation which keeps your paper honest.
04:47:20 <Cale> The whole point of programming with monads is so we don't have to write sequence and mapM and zipWithM over and over again.
04:48:25 <quicksilver> Cale: yes!
04:48:27 <Cale> That is, it's the point of every other programming abstraction: to save us from repeating ourselves, and save us from repeating the same reasoning about code over and over again.
04:48:28 <Saizan> dolio: i'm at page 40 :)
04:48:30 <newbie008> right that's the problem, very few languages have typeclasses
04:48:34 <dolio> Saizan: Heh.
04:48:55 <Cale> newbie008: Or any other form of polymorphism which is particularly suitable.
04:48:57 <newbie008> also type constructors, those are hard to come by
04:49:51 <newbie008> Cale: yes, that much i understand about monads
04:49:51 <Cale> newbie008: It's possible to get by with less, or with different things.
04:49:53 <dolio> quicksilver: Evidently it's simpler than what they've got now. Which says something, I guess.
04:49:59 <quicksilver> dolio: yeah :)
04:50:02 <newbie008> Cale: and i was trying to write some monadic functions (like bind) in Lua
04:50:12 <newbie008> Cale: but i ran into a problem that i think is pretty much a dead end
04:50:18 <Vitka> Every Haskell program has abstract data types, but I still don't have intutition as when it is time to define my own. "Container" is just too general.
04:50:29 <newbie008> Cale: i won't mention the problem now because i want to discuss it more carefully later (out of time now)
04:50:38 <Cale> newbie008: okay :)
04:50:40 <Vitka> Is it just the (in)experience thing?
04:50:44 <newbie008> Cale: but when i found the problem i saw exactly why type constructors are so useful
04:50:55 <Cale> Vitka: That's definitely a subtle point, yes.
04:50:58 <Vitka> Or maybe I'm missing something?
04:51:26 <Cale> newbie008: yeah, type constructors and typeclasses over them are what make monads convenient to program with in Haskell.
04:51:42 <newbie008> Cale: i'd even go as far as to say not only convenient but possible
04:51:43 <Cale> newbie008: If you don't have that, you end up passing around dictionaries consisting of an implementation of return and bind
04:51:57 <Cale> newbie008: You can always write the code that typeclasses desugar into
04:52:06 <newbie008> Cale: or rather something between "convenient" and "possible" -> something that people would want to use
04:52:21 <quicksilver> Cale: I think you can compromise with duck typing by making return into some kind of blob which is waiting for a dictionary
04:52:37 <Cale> Vitka: If it's any consolation for you, if you can figure out what the right types are, often the program will practically write itself.
04:52:41 <dolio> quicksilver: I've become rather less gung-ho over full type inference after using Agda. I could probably live with something as plain as bidirectional type checking from top-level signatures.
04:52:47 <quicksilver> Cale: ...but then make bind 'automatically specialise' either of its arguments if it needs to.
04:52:57 <dolio> Which lets you write Curry-style lambdas and such.
04:53:06 <Cale> Vitka: People like Conal Elliott essentially spend all their time thinking about what the right types might be to represent certain things.
04:53:17 <Saizan> quicksilver, dolio: in this paper they often refer to an implementation, i'm not sure if it's publicly available..
04:53:33 <quicksilver> Cale: then you only need to pass explicit dictionaries in the cases were something truly is ambiguous
04:53:52 <quicksilver> dolio: I think it's nice to preserve type inference for some fragment
04:54:04 <quicksilver> dolio: I agree that there are more important things that trying to maximise that fragment.
04:54:09 <dolio> Saizan: I thought SPJ's announcement said they were going to start work now, but maybe they already have some preliminary stuff.
04:54:11 <lpsmith> Cale:  there is more than one Haskell program that i couldn't have written without the type system
04:54:15 <Cale> Vitka: But very roughly, you want to use types wherever you want to force the compiler to check that you're putting things together right.
04:54:22 <lpsmith> Of course, sometimes I find it gets in my way
04:54:48 <Cale> Vitka: Types are the nubs on our lego blocks that inform us how they fit together, and maintain structural integrity.
04:55:07 <Vitka> Cale: but treating types like compiler constrant suggest generalization is bad.
04:55:08 <newbie008> and bind is the "shove" function that makes different nubs fit ?
04:55:16 <Vitka> suggests*
04:55:18 <lpsmith> Or, more frequently,  types just makes the code ugly without really helping.
04:55:27 <Cale> newbie008: Nope, bind isn't special in any way :)
04:55:34 <mreh> :t returnA
04:55:34 <Cale> newbie008: It's just another brick
04:55:35 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b b
04:56:00 <newbie008> Cale: so it's a brick that takes one kind of nub and returns another?
04:56:13 <Cale> newbie008: Are you referring to the polymorphism?
04:56:24 <newbie008> i'm referring to what bind allows us to do
04:56:28 <newbie008> or monads
04:56:52 <Cale> newbie008: It's important to realise that any particular monad is just a type (constructor) and a handful of ordinary functions
04:56:54 <newbie008> it allows us to put two blocks together that dont really fit, right?
04:57:07 <Cale> It's just a particular API-shape that some libraries are going to fit into
04:57:11 <newbie008> the type constructor builds an adapter for the two incompatible blocks?
04:57:15 <Cale> no
04:57:24 <Cale> Let's consider the list monad
04:57:28 <dolio> quicksilver: The one thing I sometimes miss in Agda is not having to put signatures inside a where. At least, when I'm not yet sure what the signature should be exactly.
04:57:29 <Cale> return :: a -> [a]
04:57:36 <Cale> (>>=) :: [a] -> (a -> [b]) -> [b]
04:57:50 <newbie008> the list monad is kind of weird i thinl
04:57:52 <Cale> return x = [x]
04:57:54 <newbie008> think^
04:58:00 <Cale> xs >>= f = concat (map f xs)
04:58:01 <zygoloid> newbie008: you could view them as brick adaptors. but remember that brick adaptors are just bricks like any other.
04:58:05 <lpsmith> dolio:  is there something comparable to the gentle introduction for Agda?
04:58:10 <dolio> Of course, you can write 'foo : _' there, since it does unification. But you wouldn't have that option with something as simple as bidirectional checking.
04:58:12 <Cale> newbie008: The important thing here is that there is *no* magic going on.
04:58:19 <newbie008> zygoloid: right, i can agree with that
04:58:20 <Cale> newbie008: We are not coercing one type into another
04:58:24 <quicksilver> dolio: *nod*
04:58:37 <newbie008> Cale: right, it's not coercing
04:58:39 <newbie008> i understand that
04:59:02 <Cale> newbie008: The list type is just a normal datatype, and the implementations of return and bind are just plain functions
04:59:17 <newbie008> i have a question about the list monad too but i'm gonna save it for later, i'm leaving in two minutes (i'm at work)
04:59:23 <dolio> lpsmith: I don't think so. There's somewhere a set of short (text) lectures with accompanying problems that I used way back to get started.
04:59:27 <newbie008> yes i understand all that
04:59:28 <Cale> They just happen to fit into a particular shape that we give a name ("monad") to, and that lets us use lots of other functions which work with all monads.
04:59:32 <zygoloid> newbie008: there is something a bit funny going on though, because of the polymorphism. the nubs on one side follow the shape of the nubs pushed into the other side.
04:59:36 <dh__> good morning . Can any function of [A] -> B be written as catamorphism?
04:59:42 <dolio> lpsmith: Like "here's some information, now implement sized vectors, etc."
04:59:49 <lpsmith> heh
04:59:54 <zygoloid> (but that's not magic either)
04:59:57 <Cale> dh__: it depends
05:00:00 <newbie008> you're just confirming everything i understood from having been taught monads in this same channel yesterday :)
05:00:14 <dh__> Cale: do you have a counter example?
05:00:23 <Cale> dh__: I'm pretty certain that you can write it as foldr applied to some number of parameters, but maybe not exactly 3 parameters :)
05:00:30 <dolio> lpsmith: http://wiki.portal.chalmers.se/agda/agda.php?n=Main.TypesSummerSchool2007
05:00:30 <newbie008> zygoloid: that's a good way of looking at it
05:00:38 <Cale> dh__: It could be that 4 is enough
05:00:49 <newbie008> guys, i gotta go now, my shift just ended
05:00:51 <newbie008> see you alter
05:01:09 <newbie008> see you all later*
05:01:32 <Cale> dh__: Try finding an f and z such that  last xs = foldr f z xs
05:01:37 <dh__> Cale: I don't understand ,  do you have a concrete counter example ? a function of [A] -> B can't be written as catamorphism?
05:03:10 <Cale> You won't be able to do it.
05:03:31 <dolio> While last may not technically be writable with just foldr, I'm not sure that's a good example.
05:03:34 <Cale> However, if we change the problem a bit, it's possible to come up with f and z so that  last xs = foldr f z xs undefined
05:03:53 <dolio> cycle is probably better.
05:04:00 <Cale> > foldr (\x xs -> xs . const x) id [1,2,3] undefined
05:04:01 <lambdabot>   3
05:04:07 <dolio> Since it's not primitive recursive.
05:04:20 <lpsmith> dolio:  Actually I've been delving a bit deeper into social choice theory;  I find the field's l and a common vocabulary somewhat rough going.
05:04:39 <lpsmith> err,  lack of vocabularly and at times questionable rigor
05:04:49 <dh__> Cale: what I'm trying to do is to understand the power of foldr ( catamorphism)
05:05:00 <dolio> > cycle [1..3]
05:05:01 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
05:05:15 <lpsmith> I find the idea of building social choice theory up formally with a proof assistant appealing
05:05:16 <Cale> dolio: hmm, yeah, that's a decent example
05:05:26 <lpsmith> Some people have already worked on that a bit.
05:06:59 <dh__> dolio: that cycle is an infinite list. can you do that for a finite list?
05:07:39 <dolio> I mean, I guess technically you could write cycle as "fix . foldr (\x f -> (x:) . f) id" and it looks similar to whatever fixing up you'd have to do for last/tail/whatever. But fix is another recursion combinator unlike the stuff in last/tail/etc.
05:08:14 <dolio> dh__: The output of cycle is an infinite list. The input is not.
05:08:47 <Cale> dolio: And you can write fix in terms of foldr, but you need a different list
05:09:09 <dh__> let me clearify my question: what is the set of functions that can be written as foldr? are they complete  ?
05:09:28 <dolio> No. cycle is not one.
05:10:08 <dolio> If we were in a more anal language, you could give cycle the type List A -> Colist A.
05:10:20 <dolio> Where List has foldr, and Colist has unfoldr.
05:10:30 <dolio> And you would not be able to write cycle with foldr.
05:10:38 <dh__> I have to leave, thanks you dolio and cale.
05:13:31 <lpsmith> Is there a good set of Agda examples?
05:14:23 <dolio> What kind of examples?
05:14:42 <dolio> I have lots of random stuff on my code.haskell.org site.
05:16:05 <dolio> http://code.haskell.org/~dolio/agda-share/html/Horse.html
05:16:13 <dolio> There's a proof that all horses are the same color, for instance.
05:16:22 <dolio> Classical argument by induction.
05:16:25 <Saizan> and the adga wiki there are a couple of fairly introductory papers, iirc
05:16:45 <dolio> Or, classic, I guess.
05:16:45 <Saizan> s/and/on/
05:16:50 <dantheman> Hey all, I'm having a problem reading from an STM TChan, and I was wondering if anyone could help. Basically, the code at: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25576#a25576 keeps going into an infinite loop at (atomically $ readTChan chan)... i.e. it prints <<loop>> on the console.
05:16:53 <lpsmith> anything... I see the code.haskell.org/Agda/ has examples,  but I don't see a nice way to download them without darcs get or wget or the like
05:17:18 <dantheman> All I want it todo is block until a value is received.
05:18:55 <quicksilver> canvon: but is anything writing to that channel?
05:19:22 <quicksilver> oops, misdirected :)
05:19:31 <quicksilver> dantheman: but is anything writing to that channel?
05:19:45 <Saizan> dantheman: do you have some other alive thread that has a reference to the chan so that it could write to it in the future?
05:19:45 <canvon> d:
05:20:06 <Cale> dantheman: Maybe it's detected that there's no possible way that another thread could ever write to that channel, and killing your thread off.
05:20:10 <dantheman> Ah I see, so haskell has deduced that no one else has a reference to the channel, so it must loop?
05:20:18 <Saizan> yup
05:20:19 <Cale> yah
05:20:29 <dantheman> Ok, thanks, I'll have a look.
05:20:44 <ToRA> dantheman: what does clearTChan do?
05:22:18 <quicksilver> it looks like you might not be using the transactional features of STM and you might be as well with plain Chan
05:22:24 <quicksilver> but of course we can only see part of your program :)
05:22:25 <dantheman> ToRA, clearChan is at http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25576#a25578
05:22:46 <quicksilver> rule of thumb - if all your uses of STM are single primitives wrapped in atomically, you don't need STM.
05:23:11 <dantheman> I guess the reason I wanted to use it was that I wanted to check for an empty chan and then if it was not empty, clear it.
05:23:35 <quicksilver> yup, clearTChan needs STM.
05:24:02 <dantheman> I was worried that if I checked using a normal chan, and then went to clear it, something else might remove the existing value(s), causing clearChan to block.
05:24:25 <quicksilver> yes, that's quite true.
05:24:49 <quicksilver> you can't write a safe ClearChan for Chan a (without cheating an using the internals)
05:25:01 <quicksilver> on the other hand, you can avoid using it in a way which needs ClearChan ;)
05:25:56 <ToRA> i'm a bit worried you're getting <<loop>> though, if it was that no-one else can write and you're blocked waiting forever on it, I thought there was a more explanatory error message that ghc kicks out
05:26:32 <quicksilver> yes, I thought it said deadlock detected, or similar
05:26:51 <quicksilver> but maybe you get the deadlock detected message with MVars and the loop message with TVars?
05:40:41 <dantheman> I've checked again and I really can't see why it's giving me that either. How exactly does it do deadlock detection? Could it be fooled by something holding an ffi stable ptr to a chan? I've added the rest of the code to hpaste here: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25576#a25579
05:43:35 <Saizan> getNextValidOrderId = getNextValidId ?
05:45:21 <triyo> I'd like to look at the source code of the (Either a) for the instance of the Functor. How do I get to the source, is there an online link or can I do it from ghci prelude?
05:46:00 <dantheman> Saizan, yes sorry it is.
05:46:27 <ivanm> @where docs
05:46:28 <lambdabot> I know nothing about docs.
05:46:31 <byorgey> triyo: if you search for it on Hoogle, haskell.org/hoogle, it will take you to the Haddock documentation, and from there you can click the "Source" link to see the source.
05:46:34 <ivanm> @google 6.12.2
05:46:36 <lambdabot> http://www.haskell.org/ghc/download_ghc_6_12_2.html
05:46:36 <lambdabot> Title: GHC: Download version 6.12.2
05:46:43 <ivanm> hmmm.... close
05:46:46 <ivanm> @doc Data.Either
05:46:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
05:47:06 <ivanm> triyo: ^^
05:47:16 <ivanm> byorgey: when would you be doing the next TMR?
05:47:29 <byorgey> hmm, actually, Data.Either doesn't have the Functor instance
05:47:49 <ivanm> bah, you're right
05:48:01 <byorgey> triyo: in the particular case of the Functor instance for Either, however, it's a great exercise to figure it out yourself from the types.  There's only one possible type-correct implementation.
05:48:08 <ivanm> not in Control.Monad where Functor is either
05:48:30 <triyo> byorgey: hahahah, thats exactlly what I did, I want to look at the answer :)
05:48:39 <ivanm> @doc Control.Monad.Instances
05:48:39 <lambdabot> Control.Monad.Instances not available
05:48:44 <ivanm> bah
05:48:49 <byorgey> triyo: ah, great =)
05:48:50 <ivanm> triyo: it's in Control.Monad.Instances
05:48:57 <ivanm> http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Control-Monad-Instances.html
05:49:23 <triyo> ivanm: thanks, I couldn't find it under Data.Either
05:49:25 * ivanm wishes there was a generic Either mapping function...
05:50:22 <byorgey> ivanm: there is, (+++)
05:50:30 <byorgey> assuming I understood what you meant
05:50:30 <ivanm> @type (+++)
05:50:31 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
05:50:40 <ivanm> hmmm....
05:50:57 <ivanm> byorgey: I meant something of type: (a -> a') -> (b -> b') -> Either a b -> Either a' b'
05:51:16 <byorgey> (+++) has that type.
05:51:29 <byorgey> just replace a by (->)
05:51:38 <byorgey> and (->) is indeed an instance of ArrowChoice
05:51:58 <ivanm> > (succ +++ show) (Left 2)
05:51:58 <byorgey> > (succ +++ not) (Left 3)
05:51:59 <lambdabot>   Left 3
05:51:59 <lambdabot>   Left 4
05:52:05 <ivanm> > (succ +++ show) (Right False)
05:52:06 <byorgey> hehehe
05:52:06 <lambdabot>   Right "False"
05:52:09 <ivanm> cool...
05:52:18 <ivanm> byorgey: ta
05:52:24 <ivanm> where's that from, Control.Arrow?
05:52:27 <byorgey> yep
05:52:42 <byorgey> it also has (|||) which is for getting rid of Either
05:52:52 <ivanm> so it's the equivalent to the either function?
05:52:56 <ivanm> @type (|||)
05:52:58 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
05:53:07 <ivanm> though I thought ||| was for joining together XMonad layouts... :p
05:53:12 <byorgey> oh, right, I guess we do already have either
05:53:17 <byorgey> that's a different |||  =)
05:53:34 <ivanm> yeah, well...
05:53:47 <ivanm> byorgey: btw, when were you roughly planning on having the next TMR release?
05:53:54 <byorgey> ivanm: anyway, to answer your earlier question, the deadline will be in September
05:54:00 <ivanm> OK
05:54:01 <mreh> newGameRound :: RandomGen g => g -> RandomArrow g SF () (RandomArrow g SF UserInput GameOutput)
05:54:01 <mreh> newGameRound g = proc _ -> do
05:54:01 <mreh>   init <- arr (evalRand initGameObjects) <<< fetchSplit -< ()
05:54:01 <mreh>   liftRand (hold undefined) <<< liftRand once <<< arr Event <<< arr (gameRound g) -< init
05:54:07 <mreh> what do we think about this?
05:54:09 <byorgey> so the next release will be end of September/beginning of October
05:54:14 * ivanm might see about having something about the development of the graph class library by then
05:54:47 <dantheman> ah.. I figured out my stm problem. I forgot to start a thread to poll the api, which indeed meant there was no way the callback that wrote to the channel could be invoked.
05:54:55 <byorgey> ivanm: that would be great!
05:55:07 <dantheman> thanks all.
05:55:36 <mreh> this would be really useful if "ArrowApply SF" existed
05:55:43 <ivanm> byorgey: since IMHO too many people are bitching about how FGL, etc. isn't exactly how _they_ want them rather than considering what other people might want (and what actually constitutes a graph in the first place)
05:55:48 <mreh> unless I'm missing a better way of doing this
05:56:38 <byorgey> ivanm: hehe
05:56:48 * dolio should learn about FGL so he can have a differing opinion.
05:56:52 <ivanm> e.g. Henning bitching that FGL requires you to have labels
05:57:08 <ivanm> admittedly, edwardk's concept sounds interesting
05:57:11 <quicksilver> mreh: but if ArrowApply SF existed, then SF would be a Monad, which would defeat the point of using hte arrow abstraction, is that not so?
05:57:19 <quicksilver> mreh: I say this without really understanding, though.
05:57:32 <ivanm> though fasta is annoyed that I'm not completely gutting FGL and writing a boost-like graph library (which is against the whole point of FGL)
05:57:53 <mreh> quicksilver: I always thought the arrow abstraction was good for preventing leaks
05:58:20 <mreh> what I'm doing here is trying to wrap randomness up in a nice arrow transformer, rather than passing around a generator that needs splitting all the time
05:58:35 <mreh> preventing loosing track of the fragments of your generator
05:58:56 <Saizan> mreh: what's the type of initGameObjects?
05:59:08 <mreh> to make a signal function that is created stochastically I thought I could use ArrowApply
05:59:22 <mreh> Saizan: Rand g [Object]
05:59:37 <mreh> this is a hang up from old code
06:00:06 <mreh> that is Rand g == MonadRandom
06:00:35 <quicksilver> mreh: You might be right. I have no idea why "the arrow abstraction" would be good for preventing leaks.
06:00:39 <quicksilver> but still, you might be right :)
06:00:41 <Saizan> can't you move the randomness inside?
06:01:05 <fasta> ivanm, I am not annoyed :)
06:01:09 <mreh> quicksilver, http://www.nullamatix.com/images/I-dunno-lol.jpg
06:01:13 <fasta> ivanm, I just think it is pointless :)
06:01:17 <ivanm> fasta: so I exagerrated... ;-)
06:01:38 <ivanm> fasta: FGL's interface is nice for problems where you don't need huge graphs
06:01:51 <mreh> Saizan: inside the SignalFunctions?
06:02:03 <fasta> ivanm, I just think "big" ;)
06:02:26 <ivanm> fasta: right, except that AFAIK most people dealing with graphs in haskell atm don't need that big
06:02:31 <mreh> SFs have no state, so no I don't think so
06:02:37 <Saizan> mreh: instead of producing a (RandomArrow g SF UserInput GameOutput) in a random way, can't you just use randomness within it?
06:02:38 <fasta> ivanm, that's a silly argument.
06:02:50 <mreh> Saizan: oh, no this is the problem
06:03:01 <fasta> ivanm, people don't use Haskell for graphs, because there is nothing to do things in Haskell with graphs.
06:03:15 <ivanm> fasta: I do stuff with graphs, pretty sure Cale does stuff with graphs, etc.
06:03:19 <Saizan> mreh: but the generator is still kept within the arrow for you by RandomArrow no?
06:03:25 <mreh> Saizan: I need to create a collection of signal functions randomly, in the code above "init"
06:03:45 <ivanm> out of updating/modernising FGL's layout currently (+ writing generic interfaces to graphs) and writing a completely new highly optimised graph library, I think the former is currently a better use of my time right now
06:03:48 <mreh> sorry I'm tripping over my words here
06:03:52 <quicksilver> fasta, ivanm : I think the kinds of things that people do with graphs vary enormously. I'm not at all sure that one library can be right for all of them.
06:04:00 <ivanm> quicksilver: agreed
06:04:16 <quicksilver> there may well be people who want to work with huge graphs and find FGL too slow.
06:04:26 <ivanm> but out of what most people seem to want based upon the mailing list and here, the scale for which FGL suffices covers the more common usages
06:04:30 <mreh> Saizan: I need to initialise a SignalFunction with some random objects
06:04:33 <quicksilver> but there maay also be people who want to work with small graphs and find FGL ugly / inconvenient / confusing.
06:04:41 <quicksilver> I think ivanm aims to help the latter group not the former.
06:04:45 <mreh> isn't this subtly different from a random SF?
06:04:45 <fasta> quicksilver, depending on whether compilation speed is an issue, I think that is possible to do.
06:04:59 <ivanm> quicksilver: to start with, yes
06:05:09 <ivanm> especially when you take into account that technically I'm meant to be busy reading boring papers on edge contraction, etc. atm :s
06:05:41 <quicksilver> I did an entire module on graphs. I'd be lying if I said I found it interesting.
06:05:45 <Saizan> mreh: it is, but they might end up with the same observable behaviour in the end
06:05:49 <Cale> ivanm: Well, I have done some things with graphs, just a bit :)
06:05:55 <fasta> ivanm, you are free to do whatever you want.
06:06:11 <fasta> ivanm, not meant in any harsh way or anything like that.
06:06:11 <ivanm> quicksilver: *shrug* I'm doing my PhD on graphs
06:06:13 <quicksilver> of course he is, but he is actively choosing to solicit our opinion.
06:06:24 * ivanm wonders if he'd be able to have graph library development in as a sub-topic...
06:06:42 <quicksilver> ivanm: no offence intended to graphs :) I think it's just the case that basic modules are boring.
06:06:44 <ivanm> at least then I wouldn't feel so guilty whenever tomberek interrupts me during the reading I'm supposed to be doing to ask about FGL...
06:06:45 <ivanm> ;-)
06:06:50 <ivanm> quicksilver: right
06:06:53 <mreh> Saizan: I want a signal function initialised once, not a signal function for every value that comes through the arrow
06:07:09 <ivanm> fasta: down the track, I may very well write such a library
06:07:15 <mreh> it's a higher order arrow!
06:07:18 <ivanm> however, I can't find a copy of that Boost book in the ANU library
06:07:34 <ivanm> and I don't particularly want to pay $50+ without seeing what it's like first
06:07:42 <ivanm> of course, if someone pays for it... *hint, hint*
06:07:42 <ivanm> :p
06:07:44 <Saizan> mreh: higher order is what you need monads for, so you're screwed if you've only an arrow, sorry :)
06:08:11 <fasta> ivanm, I read it from start to end, if that matters.
06:08:21 <brachiel> Hi - I'm looking at a xmonad config file and is uses "<&&>" as an and instead of "&&" - what does this mean?
06:08:23 <mreh> arrows can't make other arrows?
06:08:34 <ivanm> fasta: I know you think it's an interesting read ;-)
06:08:42 <fasta> ivanm, but I think you could qualify is as a boring book according to most people.
06:08:57 <mreh> Saizan: I think this arrow is also an ArrowApply, so that's alright
06:08:58 <Saizan> mreh: you can make them, but you need ArrowApply to use them, which makes your arrow equivalent to a monad
06:09:04 <ivanm> but I just recently finished reading some books that I bought online without seeing them first; whilst interesting, in hindsight I don't know if they were interesting enough to warrant the amount of money I paid for them
06:09:06 <mreh> yah
06:09:34 <Saizan> mreh: SF is an ArrowApply?
06:09:35 <Cale> brachiel: <&&> is a function defined in the xmonad libraries
06:10:08 <brachiel> Cale: ah, alright thanks
06:10:11 <quicksilver> <&&> is liftM2 (&&), which may or may not be any help to brachiel
06:10:30 <quicksilver> http://xmonad.org/xmonad-docs/xmonad/XMonad-ManageHook.html#v%3A%3C%26%26%3E
06:10:37 <brachiel> quicksilver: cool thank you
06:10:38 <vmixey> is <XXX> = liftM2 (XXX) in general
06:10:39 <vmixey> ?
06:10:46 <Cale> brachiel: Yeah, it just takes two monadic actions, and produces the action which runs both and returns the logical and of their results
06:11:06 <Cale> vmixey: not in general, no
06:11:20 <Cale> vmixey: They could even be defined in different ways by different libraries.
06:11:25 <vmixey> what are some other uses of <XXX>?
06:11:49 <quicksilver> well, <$> and <*> and <|> from applicative are not defined like that.
06:11:51 <Cale> <*> is an operator from Control.Applicative which has nothing to do with multiplication, for instance.
06:11:52 <ivanm> vmixey: I think it's an xmonad-ism
06:12:04 <mreh> Saizan: not right now
06:12:08 <quicksilver> it's more than an xmonad-ism; it's common-ish convention
06:12:12 <quicksilver> but far from universal
06:12:13 <vmixey> :t (<$>)
06:12:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:12:14 <Cale> and <+> from xmonad is just mappend
06:12:23 <vmixey> :t liftM2 ($)
06:12:23 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
06:12:24 <Cale> and not really anything to do with addition
06:12:31 <Cale> Well, mappend for ManageHooks
06:12:35 <quicksilver> vmixey: in fact, <*> is liftM2 ($)
06:12:40 <quicksilver> (with a more general type)
06:13:16 <vmixey> :t mappend
06:13:17 <lambdabot> forall a. (Monoid a) => a -> a -> a
06:13:49 <vmixey> I can't see any rule to this
06:14:02 <mreh> Saizan: thanks for the sanity check
06:14:31 <ivanm> Cale: anyway, apfelmus ended up chiming in to the FGL debate as well, with some interesting ideas
06:14:40 <quicksilver> vmixey: right, there is no rule.
06:14:59 <ivanm> e.g. not only have the option of an arbitrary vertex type, but maybe use an opaque type (with no exported constructor) as the default vertex type
06:15:04 <quicksilver> <*> looks a bit like the maths symbols 'star in circle' and 'multiplies in circle'
06:15:11 <ivanm> so people don't accidentally mix up "normal" Ints with the index type
06:15:13 <vmixey> oh!!
06:15:14 <quicksilver> that's the reason it was chosen by applicative I think.
06:15:24 <vmixey> So maybe some people see it as a circle and other see it as angle brackets
06:15:27 <quicksilver> (*) looks more like it, but that's not allowed ;)
06:15:39 <ivanm> quicksilver: I suppose if you tilt your head and squint at it in the right light...
06:15:41 <vmixey> and that's why there is this disparity
06:16:10 <Cale> vmixey: It's just another string of symbol characters which looks kinda nice
06:16:22 <Cale> vmixey: and we can define it to mean whatever we like :)
06:16:32 <vmixey> other than applicative and xmonad, who is using <XXX>'s?
06:16:51 <Cale> uh, lots of libraries...
06:17:01 <Cale> There's some of that in the prettyprinting libraries
06:17:06 <ivanm> having 3 X's like that isn't that common though
06:17:08 <Cale> I'm sure there are some parsec operators of that form
06:17:25 <ivanm> pretty has <>, <+> and that's it AFAIK
06:17:26 <Cale> Well, vmixey just means < followed by some symbol characters and then >
06:17:26 <vmixey> (<+>)  :: Doc  -> Doc  -> Doc  <--- mappend?
06:17:27 <dolio> Parsec duplicates a lot of the applicative combinators.
06:17:30 <ivanm> there's <.> and </> in FilePath
06:17:38 <vmixey> :t </>
06:17:39 <lambdabot> parse error on input `</>'
06:17:41 <ivanm> vmixey: yeah, but it pre-dates mappend
06:17:45 <ivanm> @type (</>)
06:17:46 <lambdabot> Not in scope: `</>'
06:17:46 <dolio> With more specific types, of course.
06:17:52 <ivanm> vmixey: <> joins, <+> joins with a space
06:18:04 <dolio> wl-pprint actually has a <$> combinator, much to my chagrin.
06:18:07 <Cale> vmixey: It's just a handy way to give things a bit of a different name when the symbol character you want is already taken.
06:18:11 <ivanm> > [ text "foo" <> text "bar", text "foo" <+> text "bar"]
06:18:12 <lambdabot>   Ambiguous occurrence `<+>'
06:18:12 <lambdabot>  It could refer to either `Control.Arrow.<+>', i...
06:18:17 <ivanm> dolio: what does it do?
06:18:19 <ivanm> grrr...
06:18:24 <quicksilver> Doc has at least two mappends
06:18:26 <vmixey> (</>)  :: FilePath  -> FilePath  -> FilePath  <--- mappend?
06:18:27 <ivanm> @hoogle <+>
06:18:28 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
06:18:28 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
06:18:28 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
06:18:32 <quicksilver> Doc can be a vertical monoid or a horizontal one.
06:18:34 <ivanm> vmixey: look at the docs!
06:18:41 <ivanm> vmixey: what does the </> look like?
06:18:47 <quicksilver> </> isn't a mappend, no
06:18:50 <ivanm> > [ text "foo" <> text "bar", text "foo" Text.PrettyPrint.HughesPJ.<+> text "bar"]
06:18:51 <dolio> ivanm: It's vertical append which, if collapsed back into one line, has no space between the joined things.
06:18:51 <quicksilver> there is no identity for </>
06:18:51 <lambdabot>   [foobar,foo bar]
06:19:07 <dolio> ivanm: <$$> is the same, but with a space if collapsed.
06:19:15 <ivanm> dolio: oh, yeah, the default pretty has something like that but with no symbol IIRC
06:19:25 <vmixey> :t (<$$>)
06:19:26 <lambdabot> Not in scope: `<$$>'
06:19:35 <ivanm> in my copious free time I'm thinking of writing a pretty-printer and parser for Text values...
06:19:41 <ivanm> vmixey: lambdabot doesn't know all of them
06:19:45 <ivanm> neither does hoogle
06:20:02 <ivanm> vmixey: why are you so obsessed with <.+> operators so much?
06:20:13 <vmixey> (<$$>)  :: (a -> b) -> GenParser tok st a -> PermParser tok st b
06:20:16 <vmixey> ah that's from parsec
06:20:39 <ivanm> and in wl-pprint as something completely different (as dolio said)
06:21:31 <mdmkolbe> There has to be a cleaner way to write these functions, but I can't find it.  Any suggestions? http://paste-bin.com/view/2a046506
06:23:18 <ivanm> what's Data nd GenericQ from?
06:23:22 <ivanm> and GenericT
06:23:34 <mdmkolbe> ivanm: from Data.Generic
06:23:35 <ivanm> mdmkolbe: don't use fromJust if you can avoid it
06:23:37 <dolio> It's SYB stuff.
06:23:41 <ivanm> @hoogle right
06:23:41 <lambdabot> Control.Arrow right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)
06:23:42 <lambdabot> Prelude Right :: b -> Either a b
06:23:42 <lambdabot> Data.Either Right :: b -> Either a b
06:23:58 <ivanm> > right show (Left 2)
06:23:59 <lambdabot>   Left 2
06:24:01 <ivanm> > right show (Right 2)
06:24:02 <lambdabot>   Right "2"
06:24:15 <ivanm> mdmkolbe: if that's the right you're using, then would fromJust really work? >_>
06:24:20 <ivanm> (in line 25)
06:24:34 <mdmkolbe> ivanm: up, down, left, right, querey, trans, fromZipper and toZipper, is defined elsewhere in my code  (they are not the standard "right" and "left")
06:24:40 <ivanm> oh, OK
06:24:55 <ivanm> mdmkolbe: but yeah, using fromJust "smells" a little
06:25:20 <ivanm> and nested let/in looks suspect
06:25:42 <ivanm> but I have no idea how to use syb, so *shrug*
06:26:02 <mdmkolbe> ivanm: I can replace fromJust with another case, but then the nested cases get worse.  I'd like to get rid of the nested case/let, but I can't figure out a good way to do it.
06:26:41 <quicksilver> mdmkolbe: the nested case of Maybe's I'd do in one case
06:26:55 <quicksilver> case (...,...) of (Nothing,_) -> ... etc
06:27:08 <quicksilver> the single case of Maybe you can rewrite to 'maybe' if you wish.
06:27:32 <ivanm> and yeah, use maybe or fromMaybe rather than fromJust
06:27:38 <ivanm> since what happens if it returns a Nothing?
06:27:58 <ivanm> possibly even use the Maybe monad explicitly to take care of the Nothing values?
06:28:10 <mdmkolbe> quicksilver: the nested cases depend on each other (notice that one "z" shadows the other)
06:28:41 <mdmkolbe> ivanm: it is not possible for a right to return Nothing after a left, or for a up to return Nothing after a left
06:29:09 <quicksilver> mdmkolbe: oh, I didn't spot that.
06:29:11 <ivanm> mdmkolbe: then why do they return a Maybe value at all?
06:29:14 <quicksilver> mdmkolbe: shadowing considered bad form :)
06:29:35 <quicksilver> ivanm: because the type system is not powerful enough to prove the property mdmkolbe is talking about
06:29:41 <mdmkolbe> quicksilver: Ok, I can fix that ;-)
06:29:44 <quicksilver> well, not easily anyway. Certainly not in that formulation.
06:30:14 <quicksilver> mdmkolbe: you could have 'upandown' which does both up and down at the same time, in a single Just
06:30:28 <quicksilver> no you couldn't.
06:30:33 <quicksilver> it's not the same parameter
06:30:38 <quicksilver> it's z' and h z
06:32:10 <lyndon> > 1 + 1
06:32:12 <lambdabot>   2
06:32:19 <ivanm> quicksilver: k
06:32:27 <mdmkolbe> quicksilver: I'll have to think abotu upanddown
06:32:36 <ivanm> lyndon: didn't you know that? :o
06:32:37 <ivanm> :p
06:32:53 <lyndon> Is there some way I can avoid all the class constraints here: http://codepad.org/H0D6CDT7 ?
06:33:07 <lyndon> ivanm: I wasn't sure if I was connected :)
06:33:23 <Botje> lyndon: Ord already implies Eq
06:33:27 <ivanm> lyndon: well, if you have Num you don't need Eq
06:33:38 <Botje> and Num also implies Eq
06:33:40 <ivanm> lyndon: however, you really shouldn't have constraints in data structure definitions
06:33:44 <Botje> (not Ord, though. huh)
06:33:57 <lyndon> ivanm: Why is that?
06:34:00 <ivanm> Botje: Cale barely tolerates Eq :p
06:34:02 <quicksilver> because they don't work.
06:34:09 <lyndon> ah
06:34:20 <quicksilver> and also, informally, experience suggests that often they're a mistake.
06:34:20 <Botje> ivanm: :)
06:34:23 <ivanm> lyndon: and because you need them in all your function definitions anyway, so what's the point?
06:34:25 <vmixey> lyndon, why don't you just not write any type signatures and have it all inferred?
06:34:35 <ivanm> vmixey: because that's bad form
06:34:37 <Botje> THE TIME FOR TYPE CLASS ALIASES IS NOW!
06:34:49 <ivanm> since you need type sigs for documentation
06:34:50 <vmixey> Seeing as constraint synonyms is too new an extension
06:34:51 <ivanm> Botje: agreed
06:35:06 <ivanm> lyndon: also, if you're going to derive Show, you should also derive Read
06:35:26 <Botje> lyndon: why does priority ask for an Eq a if it doesn't use it?
06:35:27 <lyndon> vmixey: I like having types explicit when I'm experimenting.
06:35:40 <ivanm> Botje: copy-pasting I presume
06:35:59 <ivanm> lyndon: don't specify constraints if you don't need them
06:36:13 <lyndon> Botje: I get an error if I don't define it.
06:36:15 <vmixey> so. hm. why do you want rid of them
06:36:24 <lyndon> Could not deduce (Eq a) from the context (Num p, Ord p)
06:36:25 <ivanm> but f looks like the kind of function you want to define in a where clause
06:36:43 <ivanm> lyndon: :o
06:36:47 <ivanm> for priority? :o
06:36:55 <ivanm> oh, right, for Num
06:37:01 <mdmkolbe> lyndon: write your function without a type signature but compile with warnings on.  GHC will complain that you are missing a type signature, but also gives you the signature maybe then you can use that as your class constraints.  (I assume GHC infers the minimal constraints.)
06:37:02 <ivanm> no, wait, that doesn't make sense...
06:37:18 <ivanm> mdmkolbe: or just load it in ghci and do :t :p
06:37:25 <ivanm> s/do/use/
06:38:10 <Botje> lyndon: oh. weird
06:38:19 <lyndon> mdmkolbe: Yes, I can do that I suppose.
06:38:21 <ivanm> I think that's because of the constraints in the data definition
06:38:33 <ivanm> lyndon: use :type in ghci rather than doing ghc -Wall
06:38:53 <ivanm> lyndon: for sortWith, consider comparing or compare `on` f
06:39:00 <ivanm> @hoogle comparing
06:39:00 * Botje finished teaching his haskell course today. yyay!
06:39:00 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
06:39:02 <ivanm> @src comparing
06:39:02 <lambdabot> Source not found. Wrong!  You cheating scum!
06:39:11 <ivanm> @type \ f -> compare `on` f
06:39:12 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
06:39:28 <lyndon> ivanm: Yep, that's what I've been using.
06:39:36 * ivanm often defines groupSortBy f = groupBy ((==) `on` f) . sortBy (compare `on` f)
06:39:40 <lyndon> ivanm: The ghci
06:39:48 <ivanm> right
06:40:23 <lyndon> sortWith seems like something that would be in the prelude but isn't
06:40:27 <mdmkolbe> ivanm: will ghci minimize the type of a function that is defined with non-minimal constraints?
06:40:52 <ivanm> mdmkolbe: if you specify a type sig, it will use that type sig
06:41:29 <ivanm> lyndon: there are quite a lot of utility functions like that that would be useful; if they where all in the prelude then the prelude would be huge ;-)
06:41:38 <ivanm> note, however, that IIRC sortBy isn't in the prelude...
06:41:41 * ivanm -> land of nod
06:41:43 <ivanm> g'night all
06:41:46 <lyndon> That is true.
06:42:06 <lyndon> I meant Data.List... I'm not very on the ball tonight :(
06:44:43 * zygoloid uses sortOn = sortBy . comparing
06:45:58 <lyndon> Nice
06:47:21 <mdmkolbe> @type sortBy . comparing
06:47:22 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
06:47:29 <lyndon> This is for building a huffman code btw if anyone was wondering.
06:48:08 <lyndon> I'm sure there's a much nicer way to do it too :)
06:48:44 <Botje> lyndon: careful. that kind of talk invites oneliners :]
06:49:44 <lyndon> Botje: I love oneliners, not that I can follow them easily (or at all if they've got arrows in them)
06:50:30 <Botje> :)
06:52:01 <lyndon> I've spent far too long trying to wrap my head around arrows, and only really grasp the (ab)use case of creating tupples with (&&&)
06:52:37 <Botje> if it's any consolation, arrows are rarely used
06:56:06 <edwardk> lyndon: congratulations you've learned most of what there is to learn from Control.Arrow ;)
06:56:47 <quicksilver> lyndon: the thing about arrows is there aren't that many useful generic combinators to motivate the typeclass.
06:57:09 <quicksilver> Monads are great because of the benefits of mapM, sequence, et al.
06:57:14 <lyndon> mm
06:57:21 <quicksilver> the Arrow typeclass doesn't have such big wins, really.
06:57:37 <dolio> I think the main motivation would be to use arrow syntax, because connecting them by hand is so tedious.
06:57:45 <dolio> But then, no one uses arrow syntax, either.
06:57:48 <quicksilver> I find a useful motivating arrow being 'Query a b' or 'Transform a b'
06:58:04 <quicksilver> which is a way of constructing some bs out of an a
06:58:25 <quicksilver> concrete type might be something like data Query a b = MkQuery (a -> Either Error [b])
06:59:00 <lyndon> They seem to be useful for creating 'inspectable' function pipelines as far as I can tell, and I find that concept awesome and potentially useful, but still just can seem to get it.
06:59:36 <lyndon> can't*
07:00:24 <quicksilver> not guaranteed inspectable, no
07:00:29 <quicksilver> because of pure/arr
07:00:40 <quicksilver> you can embed a pure function of arbitrary complexity.
07:00:52 <quicksilver> but "possibly inspectable" pipelines, yes.
07:02:02 <Saizan> mh, it seems in the new GHC type system we'd have to give a type signature for any function that pattern matches on a GADT
07:02:30 <edwardk> lyndon: i find that the use of data-reify makes for nicer 'inspectable' function composition
07:02:47 <dolio> Saizan: Isn't that already the case?
07:03:32 <dolio> I also don't find it very surprising.
07:04:35 <Saizan> dolio: not always
07:04:51 <lyndon> edwardk: Interesting. I was just reading the tying-the-knot wiki page recently.
07:05:39 <lyndon> "Typically this package will be used to tie the knot with DSL's that depend of observable sharing"
07:06:45 <Saizan> dolio: mh, maybe i'm wrong :)
07:07:03 <dolio> I certainly don't have any examples. :)
07:07:24 <Saizan> maybe it did in the past.
07:07:41 <dolio> Well, that I can believe.
07:07:41 <Saizan> accept some cases without a type signature, i mean
07:07:43 <quicksilver> edwardk: it's that too corrupted by the evil within it to qualify as 'nicer' ?
07:07:57 <dolio> They've made it more strict over several versions.
07:08:06 <Saizan> i think originally i only had to use type signatures when i was doing polymorphic recursion anyway
07:11:02 <Saizan> dolio: btw, do you know if there's an high-level specification of Agda's dependent matching somewhere?
07:11:16 <jkingkong> Hey #haskell, I would appreciate some help in building the lastest ghc build on a Mac OS X; I want to experiment with the Repa package for parallel computing
07:11:26 <dolio> No idea. Maybe Ulf's thesis explains it.
07:11:34 <jkingkong> I get the following make errors
07:11:34 <jkingkong> ld: symbol dyld_stub_binding_helper not defined (usually in crt1.o/dylib1.o/bundle1.o)
07:11:35 <jkingkong> collect2: ld returned 1 exit status
07:11:35 <jkingkong> make[1]: *** [rts/dist/build/libHSrts-ghc6.13.20100516.dylib] Error 1
07:11:35 <jkingkong> make: *** [all] Error 2
07:11:50 <jkingkong> after the standard ./configure make
07:11:59 <jkingkong> any ideas on what I'm doing wrong?
07:12:05 <kosmikus> Saizan, dolio: yes, there's a chapter in Ulf's thesis
07:12:47 <aristid> "ulf's thesis" is a haskell buzzword? :D
07:13:43 <jkingkong> to be precise, the version I am trying to compile is ghc-6.13.20100516
07:17:22 <quicksilver> jkingkong: well generically what you're doing wrong is trying to compile a GHC snapshot, which is an unusual thing to want to do.
07:17:35 <quicksilver> jkingkong: if it is, in fact, what you want to do, then #ghc is a good channel to get help in.
07:17:38 <edwardk> quicksilver: i don't do anything with it that i couldn't do without it except run faster
07:17:53 <edwardk> quicksilver: well, ok, i do, but not in my current application =)
07:18:06 <quicksilver> edwardk: sure; it just doesn't quite feel elegant/pretty.
07:18:09 <aristid> where can i find ulf's thesis?
07:18:31 <edwardk> quicksilver: i welcome alternatives =)
07:18:35 <jkingkong> quicksilver: thanks for that I'll go ask there
07:19:14 <edwardk> aristid: an agda buzzword more like
07:19:19 <quicksilver> aristid: google "ulf's agda thesis" ;)
07:19:29 <quicksilver> (first hit, for me, at least)
07:19:34 <vmixey> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.7934&rep=rep1&type=pdf
07:19:42 * vmixey 'practical dependent typed'
07:19:44 <pozic> quicksilver: and ulf's thesis has it as the second hit.
07:21:36 <aristid> oh, DT seems to be a big topic these days
07:30:15 <orbitz> Not really on topic here i think, but perhaps someone can point me ni the riht direction: how does one use linear types for resource management?  I'm looking at ATS/Cairo examples and if you leave out a resource freeing functionc all it's a compiler error
07:33:20 <edwardk> orbitz: well, you design your resource utilizing functions so that they all consume a linear reference to the resource and return one
07:33:48 <edwardk> then if you have a linear resource allocation routine, and one that frees it, you know that it gets threaded through your program in a unique way
07:33:49 <Cale> Linear variables are used exactly once along every control-flow path
07:34:12 <Cale> That's what the type system makes sure of
07:34:46 <Cale> So you just make sure that there's a linear variable bound which can only be consumed by the procedure which frees the memory
07:35:04 <Cale> (I'm just reiterating what edwardk said here :)
07:35:24 <edwardk> so you wind up with something like: newLinearRef :: a -> Unique (Ref a); readRef :: Unique (Ref a) -> (a, Unique (Ref a)); writeRef :: a -> Unique (Ref a) -> Unique (Ref a); freeRef :: Unique (Ref a) -> ()
07:35:50 <edwardk> where 'Unique' is a magic type
07:36:49 <jmcarthur> now, i still can't say i fully understand the differences, but "unique" makes me think of uniqueness types, which are different from linear types
07:36:53 <edwardk> that the compiler is able to check to make sure only gets used once from each environment
07:37:19 <edwardk> jmcarthur: they are both differently facing temporal modalities for control over contraction and weakening, so they are related.
07:37:20 <orbitz> but how does it know it needs to be used once more for the resource free call?
07:37:39 <jmcarthur> yes they are related
07:37:45 <vmixey> Read ATTAPL for how to implement linear types
07:37:58 <edwardk> orbitz: a linear type cannot be contracted (used more than once) or weakened (used not at all) it is the latter that provides you the protection for resource allocation
07:37:58 <jmcarthur> i just know from personal experience that calling one the other leads to confusion :\
07:38:00 <Saizan> because "linear" implies it has to be used exactly once, not almost once
07:38:04 <orbitz> I don't wnat to implement linear types, i'm just reading teh ATS thing on HN today
07:38:10 <edwardk> jmcarthur: fair enough
07:38:16 <orbitz> edwardk: okay i was missing the second part there
07:38:30 * vmixey sighs..why do I bother
07:38:34 <orbitz> so the "free" function basically 'consumes' it
07:38:43 <edwardk> orbitz: if you just want the contraction guarantee, then you have 'affine' types
07:38:47 <jmcarthur> yeah, ATTAPL has a great chapter on substructural types
07:39:20 <orbitz> vmixey: i appreaciate teh suggestion, but I'm mor eof just interested in the idea rather than the dirty details
07:39:22 <edwardk> but vmixey's reference to attapl is spot on. the dave walker article that is the first chapter is a great intro
07:39:56 <jmcarthur> TAPL and ATTAPL are seriously two of my favorite CS books
07:39:59 <Cale> orbitz: Yeah, without that, you'll always be left with a dangling linear variable which you need to consume.
07:40:20 <Cale> I suppose a program which will always use the variable again will also qualify as valid.
07:40:20 <vmixey> jmcarthur same here and CTM and SICP and AMOP
07:40:26 <edwardk> orbitz: to address jmcarthur's point, there is another kind of modality that you can use here, which is 'uniqueness' which says you haven't contracted (used more than once) the type so far, but where you make no guarantee that you won't in the future, or that you won;t weaken in the future
07:40:36 <vmixey> oh and lectures on curry-howard too
07:40:38 <Cale> But you can't just drop the reference to it on the floor without freeing it.
07:40:39 <edwardk> orbitz: Clean's uniqueness types follow that discipline
07:40:47 <vmixey> those are my favorite CS books
07:40:59 <quicksilver> orbitz: you might also want to read some paper on 'resource logic' by O'Hearn et al.
07:41:20 <quicksilver> orbitz: which is a distant cousin of linear logic relevant to your question.
07:41:27 <orbitz> have you heard of "resouce orientated programming"?
07:41:33 <orbitz> i mean the royal 'you'
07:42:06 <jmcarthur> vmixey: i've not read through CTM or AMOP, but i personally find SICP to be a bit overrated
07:42:16 <vmixey> always wonder if I am missing out on some really great ones
07:42:22 <quicksilver> no, but I'm programmed to go to sleep when someone uses any phrase of the form 'X oriented programming'.
07:42:32 <edwardk> orbitz: http://uni-obuda.hu/journal/Novitzka_Mihalyi_10.pdf in that sense?
07:42:39 <DigitalKiwi> apparently nobody taught you guys how to introduce acronyms into sentences, you can't just go around saying an acronym without first saying it in full!
07:42:49 <jmcarthur> i mean, it's good and all, but i never understood how it is so "mind bending," and it's certainly not something i would ever feel the desire to read again
07:42:58 <p_l> SICP is a very specific book
07:43:05 <vmixey> well yeah it's a beginners text book..
07:43:12 <orbitz> edwardk: I'm not sure, i only have haerd it in passing in refereicn eto MetaOcaml, so I wasn't sure if that was related to thsi (i have a lecture on MetaOcaml to listen to in my queue)
07:43:15 <p_l> and there's a ton of hype that skews people's perception of it
07:43:31 <edwardk> DigitalKiwi: you can if googling for the acronym will yield a pretty good unambiguous result. ;) which i believe tapl, sicp, attapl, etc all do ;)
07:43:32 <jmcarthur> vmixey: yeah, i did not read it as a beginner, so i don't know that viewpoint
07:43:34 <DigitalKiwi> or if you are daring, you might be able to get away saying it in the same sentence but after the acronym, but that's just confusing
07:43:40 <Baughn> > sort [1.10]
07:43:41 <lambdabot>   [1.1]
07:43:46 <edwardk> the only bad one up there i think is ctm ;)
07:43:50 <Baughn> > sort [1..10]
07:43:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:43:56 <vmixey> bad?
07:43:57 <jmcarthur> i'm very curious about AMOP
07:44:00 * p_l had similar issue with a novel, which so often was called "national epic" etc. while it's simply a brilliant comedy written to help the moods after a failed uprising...
07:44:05 <edwardk> bad in the sense of googlability
07:44:08 <vmixey> oh lol
07:44:12 <DigitalKiwi> http://www.etcconnect.com/ <-- first result for etc, is that what you meant? :)
07:44:22 <p_l> lol
07:44:22 <jmcarthur> it's Concepts, Techniques, and Models of Computer Programming, right?
07:44:31 <p_l> brb
07:44:33 <orbitz> yes, by PvR
07:44:40 <DigitalKiwi> http://www.amop.org/
07:45:05 <Baughn> p_l: Well, apparently the nonexistence of antimatter.. or existence of matter... is due to rounding errors
07:45:09 <Saizan> DigitalKiwi: etc was short for "et cetera" :)
07:45:18 <DigitalKiwi> ;p
07:45:24 <vmixey> any great CS books which haven't been mentioned?
07:45:26 <DigitalKiwi> tapl might be right, for me
07:45:39 <DigitalKiwi> but google is not the same for everyone
07:45:40 <orbitz> have any of you usd ATS?  It looks very neat, especially with its apparently easy C interop, but does it have some strong drawbacks for 'practical programming'?
07:45:48 <Baughn> vmixey: Okasaki's thesis, since you're in #haskell
07:45:54 <DigitalKiwi> so just cause it is the first result you get does not mean it is the first result someone else gets
07:46:00 <edwardk> vmixey: knuth hasn't received much love on here, nor purely functional data structures by okasaki
07:47:20 <edwardk> ortbitz: the main issue i have is the syntax. oh my god my eyes and that hongwei never thought of an idea that he didn't want to make up a keyword for which included _'s and bizarre acronyms
07:47:21 <Baughn> A lot of knuth's books are about somewhat outdated bit-twiddling.. useful if you're at that level, of course
07:47:35 <orbitz> hah
07:47:36 <jmcarthur> Baughn: i disgaree
07:47:39 <vmixey> lol
07:47:41 <orbitz> edwardk: teh constnat val () = looks kind of annoying
07:47:45 <jmcarthur> knuth focuses a *lot* on the algorithms
07:48:16 <Baughn> He does. The books are still annoyingly verbose if the algorithms are all you're after.
07:48:24 <Baughn> But detailed, I'll give him that.
07:48:26 <vmixey> Are there any really good books on quantum computers
07:48:31 <vmixey> ?
07:49:20 <quicksilver> jmcarthur: he does have a slight tendency to get over-excited about some less important details, along with the good stuff.
07:49:30 <jmcarthur> i'll agree with that
07:49:38 <edwardk> re other good books, vijay v. vazirani's "approximation algorithms"
07:49:44 <quicksilver> jmcarthur: like several paragraphs about a tiny reduction in constant factor which only applies for his particular machine code model.
07:50:04 <edwardk> but the applicability of that only starts to crop up when you can't get rid of that pesky NP in your problem ;)
07:50:09 <jmcarthur> sure, but i think that lines up with his goals, too
07:50:26 <jmcarthur> he's trying to teach readers how to write code that is as efficient as possible
07:50:28 <vmixey> it's french?
07:50:52 <edwardk> nah, there is an english version
07:51:07 <jmcarthur> it may be for a made up architecture, but i think it's the thought process he's intending to teach
07:51:31 <vmixey> ah http://books.google.com/books?id=EILqAmzKgYIC
07:51:39 <quicksilver> jmcarthur: yes, granted.
07:51:59 <DigitalKiwi> i like knuth and i've never read his stuff!
07:52:00 <DigitalKiwi> 09:50 < jmcarthur> he's trying to teach readers how to write code that is as efficient as possible
07:52:13 <quicksilver> jmcarthur: (and I continue to play the devil's advocate) but such things could be construed an exhortation to premature optimisation.
07:52:34 <DigitalKiwi> everyone else teaches to do stuff the easy slow way :(
07:52:41 <jmcarthur> quicksilver: and you attribute this to the one who wrote the famous quote about it ;)
07:52:52 <quicksilver> jmcarthur: ironic, no?
07:52:54 <edwardk> re quantum computation i'm trying google up the book i was planning to teach quantum algorithms from, but i can't seem to google it. the name is too generic. i'll dig it up when i get home
07:52:56 <jmcarthur> quite
07:53:00 <quicksilver> jmcarthur: but you see the point I'm making.
07:53:05 <jmcarthur> i do see the point
07:53:06 <DigitalKiwi> which famous quote?
07:53:17 <jmcarthur> but knuth wasn't teaching software engineering
07:53:33 <jmcarthur> *isn't
07:54:11 <Baughn> jmcarthur: It seems /wrong/ for anyone who loves haskell to be for micro-optimization, somehow. :P
07:54:15 <edwardk> this looks like it http://www.amazon.com/Introduction-Quantum-Computing-Phillip-Kaye/dp/019857049X
07:54:17 <jmcarthur> DigitalKiwi: "Premature optimization is the root of all evil."
07:54:30 <DigitalKiwi> by knuth?
07:54:37 <Baughn> mount -o evil,remount /
07:54:41 * edwardk alternates between optimzation and expansion phases ;)
07:54:54 <vmixey> that looks good
07:55:08 <jmcarthur> yeah
07:55:19 <jmcarthur> Baughn: why's that?
07:55:38 <quicksilver> edwardk: so basically you're an organic simulated annealer?
07:56:01 <Baughn> jmcarthur: The horrifying lack of predictable timing in typical haskell code would be one big thing.
07:56:02 <edwardk> quicksilver: you've seen the areas i've worked in. i epitomize jumping ball optimization. ;)
07:56:10 <DigitalKiwi> i hate this quote : # .The First Rule of Program Optimization: Don't do it. The Second Rule of Program Optimization (for experts only!): Don't do it yet.. - Michael A. Jackson
07:56:20 <jmcarthur> Baughn: in haskell i don't really concern myself with that, but if i was, say, writing a haskell compiler, i'd be in strong favor of any possible microptimization
07:56:49 <DigitalKiwi> people use it all the freaking time to 'prove' that ANY optimization is stupid
07:56:57 <jmcarthur> Baughn: also, see dons as an example of taking that to new levels in haskell code :P
07:57:10 <Baughn> jmcarthur: Oh, that's different. If it's an optimization that is applied over and over again by the compiler, then it isn't a /micro/-optimization.
07:57:25 <jmcarthur> DigitalKiwi: yeah. dogma like that just annoys me
07:57:47 <jmcarthur> Baughn: TAoCP was originally intended to be about writing compilers, iirc
07:57:51 <DigitalKiwi> as far as i can see he hasn't even done anything important
07:58:01 <vmixey> what???
07:58:02 <vmixey> are you kidding
07:58:04 <edwardk> all abstractions leak, so it is beneficial to know what is happening underneath the surface of your chosen level of abstraction
07:59:01 <jmcarthur> vmixey: who are you addressing?
08:01:05 <duairc> In Data.Binary.Get, if you do (runGet getWord32be $ L.pack [1..3]), it will fail by calling error. This means my program will exit if it encounters malformed data, and I don't want this. I'm trying to think of ways of wrapping runGet with catch so that I'd get a Nothing instead, but then I need to be in the IO Monad and the whole thing just seems messy. It seems the "easiest" solution is to rewrite Data.Binary.Get, but that doesn't seem right. Has anybo
08:01:32 <DigitalKiwi> duairc: shoosh we are busy talking about programming theory
08:02:44 <DigitalKiwi> and your message cut off too
08:02:46 <quicksilver> duairc: unfortunately Data.Binary.Get really isn't designed for the "there might be errors" case
08:02:53 <DigitalKiwi> Has anybo
08:02:58 <quicksilver> duairc: it's designed for the "you know this will parse" case.
08:03:09 <quicksilver> This is a serious problem IMO but it was a deliberate choice.
08:03:33 <quicksilver> you can layer something on top which checks first that things are going to work.
08:04:24 <duairc> quicksilver: Ah okay then, thanks. At least I'm not missing something obvious.
08:04:31 <silver> edwardk, what do you mean by leaking abstractions?
08:05:37 <DigitalKiwi> quicksilver == silver on speed
08:05:53 <quicksilver> silver: you think you can program with the abstraction without understand the implementation, but at some point some detail of the implementation turns out to be incredibly important to you.
08:06:03 <silver> ohh I see
08:06:03 <quicksilver> (example : memory leaks in parallel programming on GHC)
08:06:10 <quicksilver> then we say the abstraction has 'leaked'
08:06:17 <quicksilver> because it didn't really protect you from what was underneath.
08:06:46 <quicksilver> edwardk's pessimistic view is that all abstractions are leaky :)
08:07:02 <quicksilver> I must agree that most are if you push them hard enough.
08:07:02 <DigitalKiwi> assembly ftw!?
08:09:15 <p_l> Baughn: regarding Knuth's TAoCP - they aren't outdated, but the low-level aspect is true - because the volumes that cover the higher aspects aren't yet released
08:09:15 <jmcarthur> duairc: you might want to check out the spoon package for a hack around it
08:09:22 <tao> hi
08:09:40 * quicksilver would not espouse the spoon.
08:09:53 <byorgey> hi tao.
08:10:20 <p_l> quicksilver: kinda why Knuth wrote TAoCP the way it is written - he argues in the beginning that in order to properly understand programming, even with higher-level abstractions, one has to understand the low level as well
08:10:31 <duairc> jmcarthur: Ah, I like the look of this :)
08:10:43 <DigitalKiwi> there is no spoon
08:10:49 <jmcarthur> duairc: it's an evil hack, for the record
08:10:52 <jmcarthur> evil evil evil
08:11:06 <jmcarthur> but it can get the job done
08:11:26 <Saizan> duairc: a not so evil hack would be to switch to cereal or attoparsec, which provide proper error reporting
08:12:01 <jmcarthur> :t let evil = fmap in evil evil evil
08:12:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
08:12:08 <duairc> Yeah, I looked at attoparsec very briefly, I haven't seen cereal though.
08:12:24 <DigitalKiwi> best with milk
08:12:54 <duairc> :)
08:13:03 * vmixey wonders if the spoon library is named after the Oxyd game
08:13:27 <vmixey> (using the spoon makes you shatter into bits and die in that game)
08:13:27 <jmcarthur> it's named after "There is no spoon."
08:13:29 <DigitalKiwi> though eating your cereal with milk without a spoon is quite 'interesting'
08:13:54 <jmcarthur> i was present during the discussion resulting in its name
08:14:01 <jmcarthur> i don't recall exactly why that quote was relevant
08:14:09 <DigitalKiwi> lol
08:15:21 <duairc> Why is spoon evil? Its implementation is evilhax of course, but does it actually make bad things happen?
08:15:51 <vmixey> duairc, the fact that you can ask that question is what's bad
08:15:59 <jmcarthur> it allows you to observe _|_, which is not supposed to be observable in pure code
08:16:10 <vmixey> the great thing about a well typed program is you know it doesn't go wrong - you don't even have to look at the code
08:16:34 <vmixey> if you start introducing things like unsafePerformIO, then you have actually pay attention -- and everyone knows that can't be sustained indefinitely
08:16:43 <jmcarthur> even worse, it allows you to observe _|_ sometimes, but not all the time
08:17:15 <duairc> Well, it's just I would consider Data.Binary.Get to be the real evil for using error in the first place
08:17:29 <jmcarthur> not evil, just not as practical as it could be
08:17:32 <quicksilver> no, Data.Binary.Get is obeying its contract
08:17:39 <quicksilver> it only parses well-formed input.
08:17:47 <jmcarthur> spoon, however practical, is evil
08:17:55 <quicksilver> spoon breaks monotonicity.
08:18:24 * quicksilver seconds Saizan's recommendation of attoparsec or cereal.
08:18:39 <quicksilver> Binary has two major shortcomings - no support for versioning and no support for error handling.
08:18:54 <quicksilver> to some extent you could fix both in a higher layer
08:19:04 <mornfall> Should.
08:19:13 <quicksilver> depending on your application, yes :)
08:19:27 <markus3> hi guys, I need your help! I have some kind of a type problem with my code... Two files are up on hpaste.org, author markus3. The problem is in the Trees_simulate in the function "gammaHat".
08:20:08 <duairc> Okay, I promise I won't use spoon and binary :) I understand that it's evil, but I really, really like the idea of spoon nonetheless. I'm kind of twisted though and enjoy evil hax much more than I should
08:20:25 <edwardk> digital kiwi: even an assembler is an abstraction. you don't get visibility into the pipelines, code cache, data cache, it executes differently on different cpus, ... ;)
08:20:32 <markus3> I need it to return a ratio, but it says "Couldn't match expected type a against inferred type Integer. a is a rigid type variable ..."
08:20:33 <jmcarthur> duairc: spoon was actually written specifically to get around the issue in binary
08:20:52 <edwardk> DigitalKiwi: it generates different code in different assemblers or contexts depending on the distance of the branch...
08:21:00 <jmcarthur> duairc: use it if you want. we know in this particular case that it's safe to use because we cheated and looked at the implementation of binary
08:21:16 <Baughn> p_l: *snort*
08:21:32 <jmcarthur> duairc: it's just that there is a burden of proof on you every time you use spoon, and usually that proof requires knowing the implementation of what you are applying it to
08:21:41 <unlink> Why does "getLine >> return ()" force I/O, whereas "(const $ return ()) getLine" and "(return $ unsafePerformIO getLine) >> return ()" do not?
08:21:44 <p_l> Baughn: you know the general plan for the finished TAoCP? :D
08:21:50 <markus3> how to define a return type of a Ratio for a function? Is [BinTree Bool] -> Ratio a not ok?
08:22:09 <markus3> (if it takes in a BinTree Bool)
08:22:16 <quicksilver> edwardk: does assembler generate different instructions based on the distance of the branch? I didn't know that. That seems out of scope for what an assembler should do.
08:22:17 <Baughn> markus3: Well, what decides a?
08:22:23 <vmixey> markus3, I think it should be Rational?
08:22:26 <quicksilver> edwardk: (the last time I wrote assembler was on a Z80 in the 80s though)
08:22:34 <duairc> jmcarthur: Okay, thanks for that.
08:22:36 <p_l> Baughn: the idea is that you should be able to grab the series, grab a computer, assembler and assembler+architecture manual and program it from scratch to OS with high-level language compiler :D
08:22:48 <unlink> Is there some magic inside of (>>) :: IO a -> IO b -> IO b?
08:22:58 <jmcarthur> duairc: also keep in mind that if the implementation of binary changes then spoon might no longer be safe to use even in this case
08:22:59 <quicksilver> unlink: no, there is no magic.
08:23:08 <mornfall> There's just blue smoke. :D
08:23:08 <quicksilver> unlink: getLine >> return () does not force the IO
08:23:09 <jmcarthur> it could be dependent on the version of binary that you use
08:23:10 <markus3> from the info (:i Ratio) it looks like a has to be integral
08:23:13 <markus3> so I make it
08:23:15 <ski> unlink : `(const $ return ()) getLine' simplifies to `return ()'
08:23:18 <Baughn> unlink: It's just a typeclass. The magic is in the Monad instance, not the class.
08:23:20 <markus3> "toIntegral"
08:23:26 <Baughn> unlink: Though most monads are not magic. ;)
08:23:29 <quicksilver> unlink: getLine >> return () constructs an action which gets some input, yes.
08:23:33 <unlink> I'm talking about I/O in particular.
08:23:51 <unlink> I have a good understanding of the other monads, I think.
08:23:52 <quicksilver> unlink: const (return ()) getLine constructs the action "return ()"; it throws away getLine.
08:23:59 <quicksilver> ... and this is not about forcing.
08:23:59 <ski> unlink : since `getLine' isn't (observationally) pure, `unsafePerformIO getLine' isn't really well-defined
08:24:25 <mornfall> ski: Even if it was, you would have to use the value to actually trigger the IO.
08:24:26 <jmcarthur> we make a distinction between "evaluation" and "execution" when discussing IO in haskell
08:24:57 <unlink> I/O in Haskell is special. What I'm trying to ask is "How exactly is it special?"
08:25:04 <jmcarthur> evaluation gives you an action. execution runs the action
08:25:19 <voker57> it's not special, it's as any other monad
08:25:38 <vmixey> IO is abstract
08:25:40 <jmcarthur> the runtime is the only way things can be executed. namely, it executes the action given by the main function
08:25:44 <unlink> If it weren't special, you'd be able to implement MyIO in Haskell which behaves identically.
08:25:45 <vmixey> so is ST
08:25:46 <mornfall> Well, you can sort of do the same thing with ST.
08:26:10 <vmixey> that is peculiar to just those two monads (and maybe others like concurrency and such, I don't know about those)
08:26:34 <vmixey> The fact that they are abstract means you can't open them up and look inside
08:26:40 <jmcarthur> unlink: you can implement another monad that has the same pure semantics as IO. the execution operational semantics are not specified at all
08:26:53 <jmcarthur> and IO's pure semantics are basically "it's a monad"
08:27:00 <unlink> right
08:27:15 <jmcarthur> so in that sense, IO is not special whatsoever
08:27:31 <jmcarthur> in the sense that is reasonable in the context of pure haskell
08:27:33 <markus3> vmixey: yes -- it should be Rational (and not Ratio)! thankyou :-)
08:27:53 <jmcarthur> unlink: anyway, did you catch what i said about evaluation vs. execution?
08:27:58 <mornfall> jmcarthur: The catch is that main evaluates to IO that's executed magically by the runtime. :)
08:28:19 <unlink> jmcarthur: I did, though I'm not exactly sure what distiction you are pointing out.
08:28:22 <edwardk> quicksilver: as i recall if the branch is more than 64k away it has to negate the conditional and skip past a jmp to the target instead
08:28:22 <jmcarthur> mornfall: right, but that's not semantically meaningful in a pure sense
08:28:36 <mornfall> jmcarthur: No, but it can be very confusing in this context.
08:28:46 <edwardk> quicksilver: (in x86)
08:29:14 * ski recalls something similar about 6502
08:29:39 <quicksilver> edwardk: I suppose it's a question of semantics but I feel that does slightly exceed the bounds of what i expect an assembler to do ;)
08:29:45 <edwardk> in 6502 you had to work around so many bizarre corner cases that branching was the least of your worries ;)
08:30:03 <jmcarthur> unlink: an action is not executed unless it is composed into the main function with (>>=)... or, obviously, it is the main function itself
08:30:15 <edwardk> quicksilver: true, but the alternative is to fail hard at random intervals because code isn't near enough in a source file
08:32:22 <edwardk> quicksilver: but even if you ignore that it does things like use different sized operands behind your back, etc.
08:32:59 * edwardk really does come across as a pessimist ;)
08:33:21 <mornfall> Freenode's falling apart, clearly.
08:33:40 <unlink> So suppose you end up with some function main = getLine >> return (). Haskell sees this as an irreducible expression and decides it has no choice but to execute the I/O implicit in getLine in order to evaluate main.
08:34:02 <mornfall> unlink: Well, let's try it this way...
08:34:21 <mornfall> unlink: You have main = getLine >> return (). Haskell runtime wants to execute "main".
08:34:39 <ManateeLazyCat> I'm developing Gtk+ tools like Mac's QuickSliver, look screenshot: http://farm4.static.flickr.com/3415/4619030666_2e5df0bcf8_o.png , when i typing anything in "input", every part (like "Locate", "Application" ...) will `forkIO` to got search list. my problem is, sometimes those search action need longer time and can't finish between twice typing, so i use check previous SearchThread before i fork new thread, if previous SearchThread is
08:34:40 <ManateeLazyCat> running, don't fork new thread.
08:35:12 <ManateeLazyCat> I'm wonder have any advanced package to manage those ?
08:35:19 <sjanssen> mornfall, unlink: umm, isn't the runtime required to execute main no matter what?
08:35:44 <mornfall> unlink: To do that, it has to evaluate it. Evaluating it, it gets the "getLine" in there and it figures out it can execute that (well, assuming it's sort of IO primitive)
08:36:04 <mornfall> unlink: Then >> tells it to execute its right parameter, which is then evaluated and the resulting action is executed.
08:36:36 <mornfall> unlink: (Which doesn't do anything, and the program terminates.)
08:37:39 <mornfall> unlink: So the >> works as a sequencing operation for execution: it first executes its left and then its right parameter. The parameters need to be evaluated, and that only happens when it is needed (since Haskell is lazy).
08:37:48 <edwardk> preflex: xseen mmorrow
08:37:48 <preflex>  mmorrow was last seen on freenode/#ghc 120 days, 12 hours, 40 minutes and 2 seconds ago, saying: * mmorrow is rtfm'ing
08:37:53 <edwardk> yeow
08:37:55 <unlink> mornfall: I guess what I'm confused about is why >> gets to create a data dependency on its left argument.
08:38:23 <Baughn> unlink: >> calls >>=, which does that
08:38:44 <dolio> It doesn't have to.
08:38:49 <Baughn> For IO, it does.
08:39:04 <mornfall> It's not important. :)
08:39:12 <mornfall> And I don't think I'd call it a data dependency.
08:39:29 <Baughn> unlink: >> :: IO a -> IO b -> IO b; it discards the "a" bit of the first value, but not the "IO" bit. You can think of "IO a" as secretly being something like "IO (RealWorld->a)" (which is actually exactly the case
08:39:50 <mornfall> If you have (head [x, y]) >> z, y is not only never executed, it's also never evaluated.
08:39:54 <Baughn> unlink: Excuse me. IO (RealWorld -> (RealWorld,a)).
08:40:18 <Baughn> unlink: So for IO, it's only discarding the a, not the new RealWorld value.
08:40:36 <Baughn> ..therefore the function must be executed, and the function happens to do IO as a side-effect.
08:41:25 <jmcarthur> unlink: the important part is that data dependency is not what drives execution
08:41:40 <Baughn> (Even though it is)
08:41:49 <ManateeLazyCat> unlink: Read "IO Inside" from HaskellWiki
08:41:52 <jmcarthur> Baughn: dirty implementation secret. shhh
08:42:16 <Baughn> jmcarthur: IO is full of these. My hope is that if we explain every angle, he'll get it. :P
08:42:33 <jmcarthur> unlink: imagine if IO was defined as a GADT:  data IO a where GetLine :: IO String; Return :: a -> IO a
08:42:55 <mornfall> I.e. the data dependency that drives IO is on RealWorld which you never see. Hopefully. :)
08:43:17 <jmcarthur> unlink: the >>= operator simply sequences those things. the runtime see it as a lazily evaluated sequence and executes the actions one at a time from beginning to end
08:43:17 <quicksilver> For the record, I disagree most forcefully with Baughn. This is *not* about data dependencies, RealWorld is a poor model, and IO (RealWorld -> (RealWorld,a)) is *not* how it is implemented.
08:43:28 <jmcarthur> i'm with quicksilver
08:43:34 <quicksilver> and, finally, there are no side effects.
08:43:47 <ManateeLazyCat> unlink: Read http://www.haskell.org/haskellwiki/IO_inside
08:43:54 <quicksilver> getting some input is an *effect* - not a side effect - of execution.
08:44:14 <jmcarthur> unlink: that is, in that GADT example, the runtime would just be an interpreter for that GADT
08:44:23 <quicksilver> evaluation has no effects at all (except space and time usage), evaluation merely works towards computing a value.
08:44:47 <jmcarthur> i forgot to put this as a constructor:  (:>>=) :: IO a -> (a -> IO b) -> IO b
08:45:01 <Baughn> quicksilver: So, wait, what's with the GHC.RealWorld stuff?
08:45:17 <jmcarthur> Baughn: it's an implementation hack
08:45:18 <quicksilver> Baughn: that's trick.
08:45:23 <quicksilver> Baughn: that language is not haskell any more.
08:45:32 <jmcarthur> it doesn't even describe IO faithfully
08:45:32 <quicksilver> the (->) no longer denotes functions.
08:45:37 <Baughn> Well, /that's/ true..
08:45:38 <jmcarthur> consider concurrency, for example
08:45:38 <quicksilver> State# is not a real state monad.
08:45:39 <quicksilver> etc.
08:45:54 <quicksilver> The RealWorld#/State# is a formal trick
08:46:02 <quicksilver> to represent IO in a lower-level language which has no name
08:46:06 <quicksilver> I call it 'GHC' sometimes
08:46:11 <quicksilver> but it certainly isn't haskell any more.
08:46:22 <quicksilver> a lazy-by-default but strict sometimes impure implementation language.
08:46:45 <quicksilver> it has a very large amount in common with haskell, of course
08:46:50 <nus> quicksilver, you seem to be arguing that intended effects are no more side-effects.
08:46:52 <quicksilver> but some critically important differences.
08:46:55 <quicksilver> nus: yes, I am.
08:46:59 <quicksilver> nus: that's what "side" means.
08:47:18 <quicksilver> nus: a "side-effect" of evaluation is something which happens alongside the main effect of evaluating a variable.
08:47:46 <quicksilver> on the other hand, getting some input is the main effect - not a side effect - of executing (not evaluating!) getLine.
08:48:01 <quicksilver> haskell has no side-effects.
08:48:13 <nus> quicksilver, well, there's double meaning: side-effect were used
08:48:24 <nus> to mean unintended effects, that is
08:48:38 <quicksilver> sure, I don't mean unintended, here.
08:49:02 <quicksilver> in a C-like language "x = f(y)" does some calculation, presumably, and returns some value into 'x'.
08:49:10 <quicksilver> it may also, possibly, have other effects
08:49:13 <quicksilver> (because C is impure)
08:49:20 <quicksilver> those other effects are called 'side-effects'.
08:49:40 <quicksilver> I am being *very* pedantic, but for a reason :)
08:50:12 <ManateeLazyCat> If a function's result just depend it's input, we say this function *not* side-effect.
08:50:35 <ManateeLazyCat> quicksilver: Is it?
08:50:56 <quicksilver> ManateeLazyCat: well, for what you say to be true, you have to be careful what you mean by 'result'
08:51:12 <ManateeLazyCat> quicksilver: Function return.
08:51:21 <quicksilver> ManateeLazyCat: then, no, that's not true.
08:51:31 <dolio> Why are other effects not related to calculating 'x' in "f y >>= \x -> ..." not also side effects?
08:51:32 <ManateeLazyCat> quicksilver: I'm not mean IO
08:51:55 <ManateeLazyCat> quicksilver: Of course, IO function is side-effect function
08:52:10 <quicksilver> int f(int x) { printf("Hi Manatee"); return (x+1) }
08:52:27 <quicksilver> ManateeLazyCat: ^^ that's a C function whose result depends only on its input but it is not side-effect-free.
08:52:31 <ManateeLazyCat> quicksilver: This is side-effect function.
08:52:58 <quicksilver> ManateeLazyCat: yes. You said "If a function's result just depend on its input, we say this function is not side-effect"
08:53:08 <quicksilver> ManateeLazyCat: I am disagreeing with you, and that function is why.
08:53:18 <quicksilver> ManateeLazyCat: its result depends only on its input, but it still has side-effects.
08:53:46 <newbie008> quick question: if I have a function bla k f = f k k, then is that really f(k(k)) or is that k(f(k)) ? I'm temporarily confused over the precedences here...
08:53:57 <mauke> newbie008: neither
08:54:00 <quicksilver> dolio: *shrug* I don't have a strong argument against what you're saying.
08:54:01 <ManateeLazyCat> quicksilver: It's output to RealWorld
08:54:01 <dolio> (f k) k
08:54:04 <mauke> it's ((f k) k)
08:54:20 <quicksilver> dolio: but side-effects are normally 'side' to the effect of evaluation.
08:54:22 <newbie008> mauke: so that assumes that (f k) returns another function to then apply that returned function to k ?
08:54:27 <quicksilver> dolio: I think my choice of terminology is clear.
08:54:28 <mauke> newbie008: exactly
08:55:10 <newbie008> mauke: hmm okay i'll need to ponder over that
08:55:16 <newbie008> mauke: i'll be back later, thanks!
08:55:34 <mauke> > (\x -> (\y -> x + y)) 2 3
08:55:35 <lambdabot>   5
08:56:02 <ManateeLazyCat> quicksilver: Like this, "If function's result (don't effect RealWorld) just depend on it's input, we said this function is not side-effect. "
08:56:25 <newbie008> mauke: i get that :) thanks!
08:57:13 <quicksilver> ManateeLazyCat: sure, but I don't think that definition takes us anywhere.
08:57:27 <quicksilver> "If a function doesn't have side effects, then it doesn't have side effects"
09:01:25 <nus> quicksilver, you're imposing execution as something different then evaluation. Sure that's convenient for currying, still one could imagine a model where funcitons are multi-valued.
09:02:54 <quicksilver> nus: it has nothing to do with currying.
09:03:13 <quicksilver> nus: it simply a fact about haskell. Evaluation IO actions does not execute them.
09:03:21 <quicksilver> evaluating, sorry.
09:04:38 <nus> quicksilver, an evaluation of a Haskell program is a result of rewriting of the term 'main'.
09:04:56 <quicksilver> nus: OK, but that's not what I mean by evaluation.
09:05:25 <quicksilver> > Left (4+5)
09:05:26 <lambdabot>   Left 9
09:05:27 <quicksilver> that's evaluation.
09:05:30 <nus> quicksilver, SPJ's "Types are calling conventions" is another angle on the problem.
09:05:49 <nus> quicksilver, it discusses strict, multi-valued core language.
09:05:59 <quicksilver> it's pointless to argue about words. I think it's clear what I mean by evaluation.
09:06:09 <quicksilver> you can give that thing another name if you want and I"ll try to use it when talking to you.
09:06:22 <quicksilver> but my meaning is what most people in this channel mean by 'evaluation'.
09:07:50 <heropass> 1+1
09:08:03 <DigitalKiwi> 3
09:08:29 <heropass> something inherently wrong with the world, I suppose
09:08:52 <byorgey> > let x + y = 3 in 1 + 1
09:08:53 <lambdabot>   3
09:09:01 <mauke> > let 1 + 1 = 3 in 1 + 1
09:09:02 <lambdabot>   3
09:09:15 <quicksilver> > let 2 + 2 = 5 in 1 + 1
09:09:16 <lambdabot>   *Exception: <interactive>:1:153-161: Non-exhaustive patterns in function +
09:12:27 <heropass> let x + y = 5 in 1 + 1
09:13:11 <quicksilver> heropass: you're missing the important initial >
09:13:33 <matt_m> or maybe he's just talking
09:13:37 <DigitalKiwi> you say heropass and i read herpes
09:13:58 <heropass> oy
09:14:07 <stroan> this OutsideIn paper is great reading
09:14:08 <matt_m> >let (+)=(*) in 2+2
09:14:10 <heropass> herpes, i like that
09:14:22 <matt_m> > let (+) = (*) in 2+2
09:14:23 <lambdabot>   4
09:14:34 <mauke> > let (+) = (^) in 2+2
09:14:34 <DigitalKiwi> /nick herpes
09:14:35 <lambdabot>   4
09:14:47 <heropass> > let x + y = 5 in 1 + 1
09:14:47 <lambdabot>   5
09:14:53 <heropass> ok, thanks for that
09:15:02 <heropass> obviously a brandspanking newbie
09:15:03 <heropass> here
09:15:10 <byorgey> heropass: welcome =)
09:15:22 <heropass> lol@digital kiwi
09:16:14 * mauke is now known as AnalogBanana
09:17:03 <paolino> @users
09:17:03 <lambdabot> Unknown command, try @list
09:17:19 <Saizan> stroan: i'm not sure why it's called OutsideIn though
09:18:33 <byorgey> Saizan: I think it has to do with the way the inference algorithm lets equality constraints propagate inwards but not outwards
09:21:48 <Saizan> ah, yeah, you only get something going outwards when you generalize non-annotated top level definitions
09:22:00 <markus3> anyone know a smart way to turn a rectangular list of lists?
09:22:13 <danharaj> Turn your head.
09:22:21 <Saizan> transpose?
09:22:45 <markus3> what I came up was a map (!! colNr) over the outer list and with that to length of the outer list
09:22:46 <Saizan> > transpose [[1,2,3],[4,5,6],[7,8,9]]
09:22:46 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
09:22:47 <heropass> turn your head, and cough.
09:22:52 <markus3> heh
09:23:32 <markus3> english is not my first language, but I'll go and look up "transpose"
09:24:12 <mreh> what is a "data foo where ..."? is that a GADT? I can't remember
09:24:29 <PechePourri> mreh, data Foo where is a GADT, yes.
09:24:41 <quicksilver> well, it's GADT syntax
09:24:58 <quicksilver> although you can use it to define 'plain' ADTs too
09:25:07 <quicksilver> data Bool where True :: Bool; False :: Bool
09:25:11 <mreh> yah
09:25:17 <PechePourri> And it is terribly integrated with the rest of the language.
09:25:25 <PechePourri> Go for GADTS.
09:25:32 <Saizan> terribly?
09:25:38 <mreh> to an english person that sounds like it is well integrated
09:25:49 <mreh> "terribly good, what what"
09:25:51 <Saizan> ah, right
09:26:02 <PechePourri> Saizan, lots of deriving stuff is not automatically done.
09:26:26 <PechePourri> mreh, I meant it as terribly bad, but yes, it is ambiguous if you don't know me ;)
09:27:03 <Saizan> some of the deriving stuff might be impossible for gadts in general, but i see your point
09:27:09 <heropass> what is the acronym GADT short for?
09:27:17 <PechePourri> Saizan, yes, but in the cases where it is possible, it is not being done.
09:27:21 <mreh> generalised abstract data type
09:27:25 <danharaj> Generalized Algebraic Datatype
09:27:29 <mreh> lol
09:27:35 <heropass> lol
09:27:40 <heropass> either works
09:27:44 <PechePourri> Saizan, so, you lose stuff when you go from the one to the other.
09:27:50 <Saizan> abstract datatypes are another thing.
09:27:53 <mreh> i think it's meant to be the latter
09:27:56 <danharaj> er yeah
09:27:59 <danharaj> freudian slip
09:28:00 <danharaj> algebraic*
09:28:03 <heropass> gotcha
09:28:13 <mreh> algebraic because they're made of unions and stuff
09:28:17 <mreh> and jung
09:28:19 <mreh> junk*
09:28:33 <mreh> that really was a fruedian slip
09:28:40 <danharaj> jungian slip :p
09:28:41 <heropass> a junkian archetype?
09:28:56 <mreh> generalised abstract archetypes
09:28:56 <BMeph> Horribly, vice terribly, works. :)
09:29:22 <Liskni_si> PechePourri: the ghc docs say that standalone deriving will generate the code even for a gadt and if it happens to typecheck, you're well
09:29:28 <danharaj> Can you wrap a polymorphic type in an existential?
09:29:33 <PechePourri> Liskni_si, is that new?
09:29:40 <Liskni_si> PechePourri: I have no idea
09:29:53 <PechePourri> Liskni_si, that wasn't the case before in any way, but thanks. I might try it again later.
09:30:16 <Liskni_si> PechePourri: oh yeah, it's in relnotes for 6.12.1
09:30:21 <Liskni_si> bah, too late
09:36:27 <ccasin> so when is 6.12.3 expected?
09:38:13 <byorgey> soon, supposedly
09:38:27 <byorgey> did the 6.12.2 bugs bite you?
09:38:42 <ccasin> yes, through gtk2hs
09:39:31 <ccasin> well, that's too strong - I've avoided gtk2hs users were advised against it
09:39:42 <ccasin> *avoided upgrading because gtk2hs users...
09:40:15 <byorgey> ok, good
09:40:28 <danharaj> What sorts of bugs?
09:43:01 <quicksilver> yes, it was a serious bug for gtk2hs : http://hackage.haskell.org/trac/ghc/ticket/4038
09:43:01 <ccasin> danharaj: supposedly in fixing some 6.12.1 bugs Simon M. changed some data structures that get used in the FFI, and libraries that rely on them (like gtk2hs) have problems as a result
09:43:37 <quicksilver> well, it broke nested callbacks
09:43:42 <danharaj> Oh. They should be more careful with things like that.
09:43:45 <quicksilver> which are not used that often but are used by gtk2hs.
09:43:51 <quicksilver> Indeed they should, but I imagine we all make mistakes :)
09:44:01 <quicksilver> doubtless there is a nested callback test in the test suite now.
09:44:09 <danharaj> Yes, well the GHC people sometimes seem to be above mortal errors :p
09:44:25 <ccasin> yes, I think on the basis of his record we can forgive simon this one... :)
09:45:56 <pchiusano> hello
09:46:17 <jmcarthur> hello
09:46:23 <edwardk> heya paul
09:46:31 <pchiusano> hey, I remember somebody had some hilarious quote about oleg, can't remember what it was
09:46:37 <edwardk> @quote oleg
09:46:37 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
09:46:50 <edwardk> guess that wasn't it
09:47:17 <pchiusano> something about oleg deriving the second law of thermodynamics as a trivial consequence of something
09:47:30 <pchiusano> function dependencies were involved somehow
09:47:47 <pchiusano> @quote oleg
09:47:47 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
09:47:53 <mreh> have those Yale boys written up how Yampa works under the hood anywhere?
09:48:08 <quicksilver> @quote oleg.*thermo
09:48:08 <lambdabot> <JohnMeacham> says: of course any minute now oleg is going to come along and actually express the second law of thermodynamics via functional dependencies as a purely incidental part of improving
09:48:08 <lambdabot> HList syntax or something.
09:48:24 <pchiusano> lol, that was it
09:49:25 <pchiusano> hilarious :)
09:49:44 <edwardk> he gave a 5 minute talk in the haskell workshop at icfp 06 where he threw up a 5 line lambda calculus in the type system to prove that the current set of haskell extensions made the type system turing complete
09:49:59 <edwardk> the slide was on the screen for about 4 seconds
09:50:15 <pchiusano> lol
09:51:10 <copumpkin> :o
09:51:18 <Saizan> sort of like a subliminal message?
09:53:10 <aristid> > msum . repeat "xy"
09:53:11 <lambdabot>   Couldn't match expected type `m a'
09:53:11 <lambdabot>         against inferred type `GHC.Types...
09:53:16 <aristid> > msum . repeat $ "xy"
09:53:17 <lambdabot>   "xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy...
09:53:26 <ljungk> what exactly does the '<-' do when I write "| Just b <- find ('a'==) lst" in a guard?
09:54:07 <byorgey> ljungk: that's a pattern guard.  it evaluates find ('a'==) lst and tries to pattern-match the result against Just b
09:55:02 <byorgey> if the pattern-match succeeds then the case for that guard will be evaluated (and it's allowed to refer to b)
09:55:11 <byorgey> otherwise the next guard is tried
09:55:41 <aristid> @hoogle primeFactors
09:55:41 <lambdabot> No results found
09:56:16 <ljungk> yeah, I was getting the general idea  behind it, but the '<-' was just confusing as considering its other uses.
09:56:31 <byorgey> true, it is a bit overloaded
09:56:47 <markus3> if I have a list, how to combine it into such pairs, where order doesnt matter and everibody is in a pair with everybody else?
09:56:53 <byorgey> this use of <-  has not much to do with the <- in do-notation
09:56:54 <ljungk> but anyways,  thanks
09:57:02 <dolio> It's actually not that different from the <- in do.
09:57:24 <sepp2k> markus3: [(x,y) | x <- theList, y <- theList]
09:57:34 <sepp2k> Or did you mean something different?
09:57:51 <byorgey> > [(x,y) | x <- [1..3], y <- [1..3]]
09:57:52 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
09:58:02 <ljungk> dolio: not? doesn't the do one evaluate the action at its right side and put the result in the variable to the left?
09:58:22 <quicksilver> dolio: well the types of the form on the left of <- and the form on the right of <- are the same.
09:58:23 <dolio> f | p <- e = ... | otherwise = ... ~ f = fromJust $ (do p <- e ; return (...)) `mplus` (return ...)
09:58:25 <markus3> yes, but that way for [1,2,3] it would do (1,2) and also (2,1), but I need only one of them
09:58:37 <byorgey> ljungk: they are similar in that both can do pattern-matching
09:58:37 <quicksilver> dolio: that's pretty different from other uses.
09:58:56 <dolio> Yes, I suppose. It's implicitly lifted.
09:59:04 <markus3> I would just need "subsets of two" or something like that
09:59:16 <dolio> That should be 'do p <- return e' then.
09:59:47 <byorgey> ljungk: for now you can think of the do one like that.  but after a few haskell level-ups you will see that way of thinking about it is sort of a lie ;)
10:00:46 <sepp2k> markus3: Then something like pairs (x:xs) = [(x,y) | y <- xs] ++ pairs xs
10:01:14 <dolio> ljungk: Function definitions with guards can be instead defined using the maybe monad. Multiple cases are joined with mplus, bodies are lifted with return.
10:01:25 <markus3> yes!
10:01:33 <dolio> Regular guards are like using the 'guard' function.
10:01:38 <quicksilver> dolio: what you mean, I think, is it's reminscent of the 'fail' implications of <- in a do block. But doesn't have the other ones.
10:01:41 <markus3> thanks!
10:01:53 <dolio> f | p = ... ==> f = guard p >> (return ...)
10:02:05 <dolio> Pattern guards are like monadic pattern matching.
10:02:06 <sepp2k> markus3: And pairs [] = [] of course...
10:02:20 <markus3> yep
10:02:44 <Cale> pairs zs = [(x,y) | (x:xs) <- tails zs; y <- xs]
10:03:00 <Cale> er, that should be a comma
10:03:03 <ljungk> byorgey: okay :) feels like the levels of haskell takes immense amounts of EXP
10:04:05 <sepp2k> Cale: nice
10:04:37 <dolio> quicksilver: What other ones?
10:05:02 <ezyang> magic. Thanks a bunch. I prolly would have died
10:05:06 <byorgey> ljungk: yes, they do =)
10:06:21 <ksf> ljungk, it's a vastly linear curve, though.
10:06:32 <ksf> it just doesn't plateau.
10:11:15 <ljungk> learing haskell definitely makes you think in a completely new way
10:11:46 <danharaj> learning haskell is like doing math.
10:11:59 <danharaj> real math, not high school math :p
10:12:43 <ljungk> danharaj: true.
10:15:04 <Silvah> Hello everyone.
10:15:11 <Cale> hello
10:15:12 <ljungk> btw, is there something like a 'contains' function for Lists?
10:15:16 <Cale> elem
10:15:21 <edwardk> > (zip <*> tail) [1..10]
10:15:22 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
10:15:24 <Cale> > 5 `elem` [1..10]
10:15:25 <lambdabot>   True
10:15:31 <Cale> > 14 `elem` [1..10]
10:15:31 <lambdabot>   False
10:16:04 <Silvah> > [2, 3] `isInfixOf` [1..10]
10:16:05 <lambdabot>   True
10:16:05 <ljungk> ah
10:16:37 <tromp> @src isInfixOf
10:16:38 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
10:16:59 <Cale> @src isPrefixOf
10:16:59 <lambdabot> isPrefixOf [] _          = True
10:16:59 <lambdabot> isPrefixOf _  []         = False
10:16:59 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
10:17:27 <Silvah> @src tails
10:17:28 <lambdabot> tails []         = [[]]
10:17:28 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
10:20:58 <BMeph> I've lately noticed a lot of functions that (conceptually, I guess I should say) are recursive using some function that separates a list into a pair of lists. Has someone made a library for exploiting that pattern - edwardk's Reducer & monoids, perhaps? :)
10:30:25 <nus> .oO(is this some convoluted way of asking of what Data.Monoid.Reducer is?)
10:30:35 <edwardk> BMeph: hrmm, i don't have a reducer explicitly for that, plus there is often some kind of pivot involved and you might only use one side
10:30:39 <tromp> anyone want to check my chess position counting Haskell code?
10:31:22 <edwardk> BMeph: though the reducer/generator framework was built explicitly to handle the cases where the container knows best where its 'fault lines' are
10:31:30 <BMeph> tromp: "Want" is such a loaded word... :)
10:31:50 <tromp> ok, read that as "doesnt mind" :)
10:32:47 <tromp> it's at http://www.cwi.nl/~tromp/chess/chess.html
10:36:25 <edwardk> your chess diagrams don't bother to include the history, right? so they don't appear to enumerate all possible states one might have to consider while playing
10:36:43 <tromp> diagrams is just whaat you see on the board
10:36:48 <edwardk> *nods*
10:37:32 <tromp> position adds castling, en-passant, and side-to-move info
10:38:03 <tromp> still lacks #plies since last pawn move/capture and info about 3fold rep
10:38:04 <aristid> @src .
10:38:05 <lambdabot> (f . g) x = f (g x)
10:38:05 <lambdabot> NB: In lambdabot,  (.) = fmap
10:38:10 <aristid> :t (.)
10:38:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:38:14 <edwardk> so the major potential avenue for improving your bound is to better enumerate possible pawn movement scenarios?
10:38:16 <aristid> :t fmap
10:38:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:38:31 <wli> 50-move progress info too.
10:38:57 <tromp> i expect most redundancy is due to king not-to-move being in check
10:39:08 <aristid> > (+1) . (Just 1)
10:39:10 <lambdabot>   Just 2
10:39:55 <tromp> we intend to create random positions and empirically estimate fraction of actually legal positions
10:40:19 <tromp> which may be only a few percent
10:41:05 <tromp> also including impossible pawn structure like w pawns on a2,a3,b2
10:41:28 <edwardk> i suppose one could also try to extract some an order or two in some cases from positional lock in. i.e. knight and queen pawn intact, so queen's bishop can't have moved, ruling out that side castling, so forth
10:41:55 <edwardk> yeah the pawn structure was what i was alluding to above
10:42:14 <tromp> how does non-moving bishop rule out castling?
10:42:30 <BMeph> edwardk: I just feel as if it's obviously a fold, but with its own idea of how to (do the moral equivalent of) "choose" which way to "undo" the multiplication. I know my statement is almost lacking any precision, but I hope you can get the jist of it.
10:43:28 <edwardk> bmeph: i take it you're talking about fold-like operations that work over things like splitAt, break, span, takeWhile, etc?
10:45:14 <edwardk> tromp: there must be no pieces between the king and the chosen rook, if the bishop hasn't moved because of pawn lock in the king can never have castled on that side
10:45:44 <edwardk> it was just a tiny example
10:45:53 <tromp> castling info is about possible future castling. a bishop can always be taken by opponent
10:46:03 <edwardk> tromp: ah
10:46:08 <BMeph> edwardk: Not just list monoids, so throw divMod into that mix of pair-producing functions. :)
10:47:34 <BMeph> edwardk: Also the "trivial" list splitter, 'uncons'. :)
10:48:08 <edwardk> BMeph: *nods*
10:48:19 <zygoloid> edwardk: from the board state, it doesn't matter how the king and rook got there. might not have been a castling to look like one
10:49:06 <edwardk> zygoloid: yes, for some reason i thought the castling in his code was counting 'has castled' not 'can castle'.
10:50:01 <BMeph> edwardk: Surely, "s/can/may" right? ;)
10:50:46 <Cale> I wonder how often that is, that someone manages to castle without having moved the intervening bishop.
10:50:48 <edwardk> though i suppose there are still unreachable board states involved there if the whole initial pawn wall is intact on that side ;)
10:51:00 <edwardk> Cale: its not legal
10:51:17 <Cale> edwardk: If the opponent takes the bishop and moves away?
10:51:20 <tromp> a captured bishop did not move
10:51:42 <edwardk> tromp: point granted =)
10:52:18 * edwardk is stuck in a channel full of literalist pedants ;) no wonder i like this place
10:53:25 <jcreigh> I don't know if *all* of us are literalist pedants...
10:54:25 <quicksilver> I thought it was a channel full of moral philosophers? ;)
10:57:38 <aristid> quicksilver: if you drop the "moral", it might be more accurate?
10:58:20 <EvanR-work> militant cabalists
10:59:12 <quicksilver> aristid: I discovered earlier today that 'moral philosopher' is an archaic phrase which used to mean people who studied pure logic / reasoning / mathematics (as distinct from the natural philosophers who studied empirical science)
11:00:08 <aristid> quicksilver: oh?
11:00:50 <applicative> quicksilver, i'd think thats going too far.  'moral sciences' still means something like social sciences + philosophy (as we understand it) in some English places
11:00:57 <quicksilver> just decided I liked the term.
11:01:15 <quicksilver> applicative: well I was reading about an archaic usage, not a current one.
11:01:18 <applicative> moral = 'pertaining to action, life'
11:01:45 <applicative> mos mores, cp. greek ethos, both 'ways of acting, living'
11:02:21 <nus> customs?
11:02:32 <applicative> yes, originally
11:03:09 <applicative> the contemporary use, tied to the idea "morality" is modern.
11:03:50 <nus> @wn moral philosophy
11:03:52 <lambdabot> *** "moral" wn "WordNet (r) 2.0"
11:03:52 <lambdabot> moral
11:03:52 <lambdabot>      adj 1: relating to principles of right and wrong; i.e. to morals or
11:03:52 <lambdabot>             ethics; "moral philosophy"
11:03:52 <lambdabot>      2: concerned with principles of right and wrong or conforming
11:03:53 <lambdabot> [28 @more lines]
11:03:58 <applicative> http://www.philosophy.uncc.edu/mleldrid/SzCMT/mmp.html  -- one of the better essays of the last century
11:04:24 <nus> oh, the quest for True and False
11:05:25 * edwardk just realized that his goal of trying to put together a 'cotangent tower' for reverse mode ad is silly, that it never makes sense to do that rather than just apply tangent mode ad to the reverse mode over and over.
11:06:20 <edwardk> it'll always be faster to go tangent . reverse or tangent . tangent than reverse . reverse
11:06:31 <tao> What I lack ins hackage - is the documentation
11:06:33 <nexXus|Maxga> hey there, can someone help me? I started with haskell few days ago, now i'm trying to implement Bubble-Sort in Haskell.. but if i try to run it, i get an error, u can see the code + the error on this screen: http://pic.leech.it/pic.php?id=736d67fhaskell.jpg  thank u
11:06:39 <tao> usually modules on cpan are better documented
11:06:45 <tao> just IMHO
11:07:53 <mauke> nexXus|Maxga: '... ++ last n' is a type error
11:08:23 <tao> '... ++ [last n]
11:08:25 <tao> '
11:08:25 <tao> ?
11:08:46 <nexXus|Maxga> ah lol
11:08:48 <nexXus|Maxga> thank u ><
11:08:53 <tao> > [1,2,3] ++ [last [3,4,5]]
11:08:54 <lambdabot>   [1,2,3,5]
11:08:58 <tao> > [1,2,3] ++ [last n]
11:08:59 <lambdabot>   Couldn't match expected type `[a]'
11:09:00 <lambdabot>         against inferred type `SimpleRef...
11:09:07 <tao> > [1,2,3] ++ [last n'] where n' = [1,2]
11:09:08 <lambdabot>   <no location info>: parse error on input `where'
11:09:14 <tao> hm
11:09:17 <vmixey> > let n = [1,2,3] ++ [last n] in n
11:09:21 <lambdabot>   mueval-core: Time limit exceeded
11:09:25 <vmixey> > let n = [1,2,3] ++ [head n] in n
11:09:27 <lambdabot>   [1,2,3,1]
11:09:41 <tao> derp
11:09:41 <vmixey> > let n = [last n] ++ [1,2,3] in n
11:09:43 <lambdabot>   [3,1,2,3]
11:09:59 <tao> that's too hardcore for me, sorry
11:10:00 <vmixey> > let n = 4 : [last n] ++ [1,2,3] + [head n] in n
11:10:01 <lambdabot>   No instance for (GHC.Num.Num [a])
11:10:02 <lambdabot>    arising from a use of `e_14123' at <in...
11:10:07 <vmixey> > let n = 4 : [last n] ++ [1,2,3] ++ [head n] in n
11:10:08 <lambdabot>   [4,4,1,2,3,4]
11:10:47 <nexXus|Maxga> Oo tahnk u, its working fine now, bye :)
11:10:51 <tao> haskell is p cool
11:11:11 <vmixey> it'sp-radical
11:11:41 <xerox> > mfix (\xs -> [[xs!!3,0,succ (head xs),length xs]])
11:11:42 <lambdabot>   [[4,0,5,4]]
11:14:33 <edwardk> tao: modules on cpan have also been around the better part of a decade longer on average.
11:15:03 <edwardk> tao: but in general i agree
11:15:13 <Cale> Most of the modules on hackage have not so bad documentation...
11:15:15 <edwardk> i'm probably one of the worst culprits of bad-docs in hackage
11:15:33 <Cale> At least, it's usually sufficient for my sake...
11:16:09 <edwardk> because by the time i'm dumping it to hackage i've extracted what i'm interested in from the domain, and have usually gutted an implementation from a larger code base, so I can share the relevant portion with others.
11:16:33 <edwardk> which is really no excuse
11:16:33 <quicksilver> being a very heavy user of CPAN, I don't agree that they are usually well documented.
11:16:49 <edwardk> quicksilver: both cpan and hackage have dark corners ;)
11:17:11 <quicksilver> there are definitely some packages with good documentation on CPAN, but there are also others...
11:17:26 <chrisdone> haskell got me into the whole automatic documentation generation thing
11:17:36 <quicksilver> edwardk: on CPAN even the dark corners have dark corners....
11:18:05 <chrisdone> quicksilver: is a corner really a corner if it has corners?
11:18:11 <edwardk> i have to admit my biggest problem with haddock is i can never remember all the rules at the same time =)
11:18:28 <arw> chrisdone: fractal corners?
11:18:32 <chrisdone> "all the rules"?? 5?
11:18:43 <edwardk> chrisdone: sad but true =)
11:18:49 <quicksilver> historically a problem with haddock was that it didn't cope with this or that random extension. However that's pretty much solved now isn't it?
11:19:04 * chrisdone pats edwardk on the head ^_^/`
11:19:16 <edwardk> quicksilver: yeah, it still vomits all over template haskell though, no?
11:19:44 <edwardk> i kind of wish it was smart enough to go mine through .hi files to find all the extra TH instances and methods
11:19:44 * quicksilver didn't think so, but doesn't know.
11:21:31 <jmcarthur> it still doesn't have a good answer for TypeFamilies
11:21:55 <jmcarthur> it doesn't crap out, but it doesn't really generate helpful documentation either
11:24:07 <edwardk> -- | [@definitions@] (1) enumerated lists, #labels# <urls> 'Qualified.names' and "Data.Modules"> code or @code@ -- you'd think by now i'd remember it
11:25:04 <jmcarthur> never
11:29:01 <tao> edwardk: i mean
11:29:06 <tao> edwardk: if i go to cpan
11:29:14 <tao> edwardk: and search for IRC
11:29:25 <tao> edwardk: i can start coding right now!
11:29:44 <tao> edwardk: i downloaded irc package from hackage and i have NO idea what to do
11:29:52 <tao> of course, i am p stupid
11:29:53 <tao> but still
11:30:07 <jmcarthur> i find that haddock documentation, even without any extra effort from the programmer, makes usage of most libraries very obvious. type signatures are cool like that :)
11:30:11 <vmixey> tao you should read about q-analogues
11:30:29 <tao> haddock? uhh
11:30:38 <tao> looks like doxygen docs
11:30:49 <jmcarthur> yeah, except it conveys much more information
11:30:53 <tao> vmixey: sorry?
11:30:55 <jmcarthur> since haskell types convey much more information
11:31:13 <Cale> Type signatures are generally more useful in documenting Haskell code than they are at documenting, say, C code.
11:31:14 * chrisdone mentally apples s/\n/, /g to tao
11:31:16 <edwardk> tao: part of it is Network.IRC is just the protocol specification not a full solution. it describes how to parse irc messages, not how to connect to the server, etc.
11:31:25 <jmcarthur> if i see a function of type (a -> b) -> Foo a -> Foo b, i can pretty much guess what it does
11:31:48 <chrisdone> today i thought about type annotating php in haskell notation for documentation purposes
11:32:09 <jmcarthur> chrisdone: i have used haskell-style type signatures in C code before for documentation
11:32:10 <Philonous> jmcarthur: Damn free theorems!
11:32:13 <tao> edwardk: yeah i was just giving "casual" example
11:32:21 <tao> Cale: can't but agree with that
11:32:39 <edwardk> tao: *nods* in general i agree. you get a nice 'front page' when dealing with cpan docs
11:32:55 <jmcarthur> sure, for the best documented packages
11:32:56 <edwardk> which tends to be oriented around common use cases, etc whereas you don't get that with haddock docs
11:32:57 <tao> yeah
11:32:59 <chrisdone> technically hackage lets you do a big front page
11:33:13 <edwardk> chrisdone: via description:?
11:33:18 <chrisdone> yep
11:33:28 <jmcarthur> i wish that was more convenient
11:33:29 <chrisdone> see here for example http://hackage.haskell.org/package/regular-web
11:33:31 <jmcarthur> to write
11:33:57 <jmcarthur> oh wait i didn't realize you could apply haddock formatting to that
11:34:12 <edwardk> yeah, its just not as ubiquitous as it is in cpan, there it seems to have become part of the culture, and the awareness that haddock markup works there is somewhat lacking in the community
11:34:32 <edwardk> er apologies for mixing antecedents
11:34:39 <chrisdone> yeah, i didn't know for ages. i just never asked
11:34:40 <jmcarthur> i think a lot of it has to do with the fact that haskell types *are* a bit self-documenting
11:34:45 <chrisdone> yeah
11:34:45 <jmcarthur> that we don't write betters docs, that is
11:34:51 <tao> chrisdone: that page was made by really good person :)
11:35:02 <chrisdone> yeah chris eidhof is awesome
11:35:33 <tao> but if you generate skeleton for perl module with most of the software it generates all SYNOPSYS etc  fields for you
11:35:42 <jmcarthur> hmm... can you link into the haddock docs from the description field?
11:36:44 <applicative> similarly http://hackage.haskell.org/package/fclabels
11:36:53 <jmcarthur> tao: i don't see how anything autogenerated is going to be inherently better than anything autogenerated
11:36:56 <tao> I dont know how to generate packages for hackage, with cobal maybe? but I bet there will be a lot of more easy-reading docs if that programm would generate some fields by default
11:37:03 <jmcarthur> *anything else autogenerated
11:37:08 <tao> well
11:37:14 <tao> umm
11:37:27 <jmcarthur> tao: cabal has lots of required fields for packages on hackage, included synopsis
11:37:30 <jmcarthur> *including
11:37:40 <jmcarthur> tao: http://hackage.haskell.org/packages/archive/regular-web/0.1.1/regular-web.cabal
11:38:40 <tao> ~_~
11:38:43 <tao> compare to http://search.cpan.org/dist/AnyEvent/lib/AnyEvent.pm
11:38:49 <edwardk> ah the . on blank lines that was what i was missing when i tried to make a verbose cabal description =)
11:39:08 <jmcarthur> tao: you're arguing that that is autogenerated?
11:39:24 <tao> jmcarthur: no no
11:39:45 <chrisdone> tao: huge-ass tutorials like that are usually deferred to blog posts and papers
11:39:52 <tao> jmcarthur: sorry i am not a native speaker so my text might look clumsy
11:40:00 <jmcarthur> tao: all i'm trying to say is that any lack of documentation on hackage is culture-related, not tool-related
11:40:23 <tao> chrisdone: quote "This manpage is mainly a reference manual. "
11:40:27 <jmcarthur> tao: haskell culture doesn't typically care as much because haskell type signatures are so much more useful than e.g. C function prototypes
11:40:38 <applicative> I think the best documentation is an /examples folder with a bunch of stupid executables.   Data.Rope, for example, could use such a folder...
11:40:59 <edwardk> the other reason why folks tend not to make epic poetry out of their description is that it is a pain in the butt to have to upload a new version of the package because your description is wrong, and have all the old versions immortalized for eternity ;)
11:41:10 <jmcarthur> i actually like examples in the haddock documentation
11:41:14 <edwardk> at least with cpan you can delete over the course of 3 days ;)
11:41:20 <tao> jmcarthur: yeah but i tought maybe hackage should have more tools which would bump somebody into writing bigger documentation
11:41:29 <jmcarthur> tao: like what?
11:41:59 <edwardk> tao: we have a gsoc project that is looking at adding some wiki like functionality to hackage to allow users to supply some of these things
11:42:10 <tao> I dont know :(
11:42:17 <tao> I just thought about the idea
11:42:21 <jmcarthur> like i said, i think it's mainly culture
11:42:29 <tao> dont get me wrong, i dont say that anything is bad
11:42:34 <tao> not trying to push anybody
11:42:45 <jmcarthur> i agree with you that nicer documentation would be a good thing
11:42:50 <tao> edwardk: that's pretty sweet
11:43:24 <jmcarthur> yeah i hate it when you have to put a wiki page on haskell.org just for a particular package
11:44:09 <jmcarthur> http://www.haskell.org/haskellwiki/GPipe for example
11:44:09 <applicative> that programmer types don't like to write documentation is unsurprising, but it is surprising they dont do like to write little executable illustrations...
11:44:15 <applicative> as say oleg has been known to do http://inmachina.net/~jwlato/haskell/iteratee/Examples/
11:44:26 <tao> jmcarthur: plus haskell wiki is centralised
11:44:33 <jmcarthur> applicative: i like to!
11:44:34 <tao> isn't it?
11:45:10 <jmcarthur> tao: it used to be that anybody could edit, but i believe that has since changed. i think now you have to apply for an account
11:45:19 <tao> nah
11:45:20 <tao> what i mean
11:45:32 <tao> is that there is only one server holding haskellwiki
11:45:39 <chrisdone> you, you have to apply for an account
11:45:46 <chrisdone> s/^you/yeah
11:47:00 <jmcarthur> i think i write reasonable documentation, at least for the couple small packages i've uploaded
11:47:14 <jmcarthur> at least as far as haskell documentation goes
11:47:17 <tao> when i was complete noob i thought that ghc was gnu haskell compiler :|
11:47:29 <jmcarthur> for another language my docs would probably be useless
11:47:51 <danharaj> oh god
11:48:18 <danharaj> gnu haskell compiler :p
11:48:21 <jmcarthur> http://hackage.haskell.org/packages/archive/procrastinating-structure/1.0.1/doc/html/Data-PVar-Structure.html  http://hackage.haskell.org/packages/archive/procrastinating-structure/1.0.1/doc/html/Data-PVar-Queue.html
11:48:36 <jmcarthur> those are what i would consider minimal documentation to be good
11:48:46 <jmcarthur> i could have spent a bit more time explaining things
11:49:12 <danharaj> I hate documentation in between lines of code.
11:49:25 <danharaj> I put my comments either to the side or in a block before the code.
11:49:26 <jmcarthur> danharaj: you mean like in the middle of a function?
11:49:27 <Cale> Practically everything Haskellish uses BSD licences.
11:50:02 <danharaj> jmcarthur: I mean like in the first link you gave.
11:50:04 <applicative> jmcarthur, that is very nice.
11:50:30 * BMeph is impressed that "procrastinating-structure" actually got into Hackage!
11:50:31 <danharaj> jmcarthur: The second link is much nicer IMO
11:50:32 <jmcarthur> danharaj: oh. that's just example code though. it makes sense to explain each line in such a thing, IMO
11:50:40 <jmcarthur> BMeph: the name? :P
11:51:22 <BMeph> jmcarthur: Exactly. :)
11:51:46 <jmcarthur> BMeph: well, i used the procrastinating-variable package as a dependency, so this name made sense ;)
11:52:03 <Cale> peek :: Queue  a -> Maybe  a
11:52:03 <Cale> Get the value at the front of a Queue. Returns False if we are at the end of a closed Queue.
11:52:09 <Cale> Returns what now? ;)
11:52:15 <jmcarthur> lol
11:52:17 <jmcarthur> oops
11:52:17 <danharaj> jmcarthur: I mean, having comments in between code lines is hard to read for me. I like the second link's style because I can read all the code uninterrupted first and then read the comments.
11:52:18 <applicative> jmcarthur, I see you do have a little 'module Main..' in the commentary to Queue.hs
11:52:55 <BMeph> jmcarthur: I know I procrastinate so much, I've thought of starting up a "Procrastinators' Anonymous" group. I've never actually _done_ it, of course, but I have thought about it a few times... :)
11:53:00 <tao> jmcarthur: wow
11:53:09 <tao> jmcarthur: nice documentation
11:53:17 <tao> even i can read it
11:53:23 <jmcarthur> awesome!
11:53:29 <ljungk> how can a function (i.e. return) have type '(Monad m) => a -> m a' ? I just don't get where the actual type of the monad is infered.
11:54:22 <jmcarthur> well i guess i'll be correcting the error Cale pointed out when i get home this evening
11:54:23 <applicative> ljungk, you define a concrete function when you instance the Monad class
11:54:23 <BMeph> ljungk: Welcome to Type Classes. :)
11:54:35 <Cale> jmcarthur: So a peek on an unclosed empty queue will block until an item becomes available?
11:55:08 <jmcarthur> Cale: no, it's just _|_
11:55:09 <dschoepe> ljungk: if you apply a function that requires a specific type to the result, the compiler can infer it from that. e.g. isJust (f "foo")
11:55:18 * BMeph scores another point for the Code Comment Review Master, Cale!
11:55:20 <applicative> ljungk, that type signature pertains to the class Monad.  But now I write instance Monad [] where return x = [x] and ... likewise for >>=
11:55:48 <Cale> ljungk: If you think that's odd, look at the type of read
11:55:51 <Cale> :t read
11:55:52 <lambdabot> forall a. (Read a) => String -> a
11:56:01 <Cale> > read "5" :: Integer
11:56:01 <lambdabot>   5
11:56:05 <Cale> > read "5" :: Double
11:56:06 <lambdabot>   5.0
11:56:11 <Cale> > read "5" :: Rational
11:56:11 <lambdabot>   *Exception: Prelude.read: no parse
11:56:12 <applicative> @src read
11:56:12 <lambdabot> read s = either error id (readEither s)
11:56:16 <jmcarthur> Cale: this is really intended for cases where you are controlling evaluation through the way the results of your pure computation are consumed, and if you try to consume data that is not there yet you get _|_ and are made aware of the error
11:56:17 <Cale> tsk :)
11:56:19 <danharaj> > read "5"
11:56:21 <lambdabot>   *Exception: Prelude.read: no parse
11:56:24 <Cale> > read "[1,2,3]" :: [Integer]
11:56:25 <lambdabot>   [1,2,3]
11:56:43 <jmcarthur> Cale: as opposed to the IVar style of doing it where you would be given some leniency and it would just block until the data is there
11:56:50 <Cale> jmcarthur: ah, okay
11:56:53 <jmcarthur> which might be what you want sometimes
11:56:57 <applicative> @instances Read
11:56:58 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:57:21 * applicative thinks he could write the Read instance for ()
11:57:50 <tao> So haskell-cafe is "forum in which it's acceptable to ask anything, no matter how naive, and get polite replies.". Where can I find haskell forum for non-polite people who swears a lot?
11:57:59 <Cale> ljungk: The parser used to read the string depends on the type of result being demanded.
11:58:21 <heropass> > read "5" :: Integer
11:58:22 <lambdabot>   5
11:58:22 <applicative> tao, they're here too, it's just that the forum isn't for them
11:59:00 <tao> yeah but i really like non-polite discussions
11:59:13 <heropass> being a pristine newbie, I appreciate that ground rule
11:59:16 <ljungk> wow :P
11:59:30 <heropass> I don't mean to be an idiot, I just am :P
11:59:35 <tao> i am a newbie too
12:00:01 <heropass> you could always send private messages
12:00:01 <applicative> ljungk, it will probably be easier to grasp these class type signatures Blah a => a -> Blah (Foo (a)) if you start with less grandiose typeclasses than Monad or Functor
12:00:38 <burp> http://www.futilitycloset.com/2010/05/12/pandigital-approximations/  write a program that bruteforces approximations for pi and e that include all digits 1 to 9 just once, like in there :)
12:01:24 <applicative> ljungk, in any case Functor should be studied before Monad.    But take the typeclass Eq, declared (sort of) class Eq where (==) :: Eq a => a -> a -> Bool
12:01:37 <applicative> @instances Eq
12:01:37 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:02:02 <BMeph> tao: If you're looking for swearing, #math can help you... ;)
12:02:15 <heropass> like sum :: Num a => [a] -> a
12:02:15 <heropass>  
12:02:19 <applicative> ljungk, all of these types come with definitions of "==" which is what puts them in the Eq class
12:02:32 <tao> BMeph: heh
12:02:49 <heropass> "sum"
12:03:05 <tao> i am not a mathematician, so the only thing i can discuss in #math is homework, i guess
12:03:07 <heropass> oops, the type of "sum" takes a list of numbers and produces anumber
12:03:08 <applicative> @type sum
12:03:08 <lambdabot> forall a. (Num a) => [a] -> a
12:03:39 <BMeph> Well, off to lunch - ciao!
12:03:42 <applicative> heropass, what did you want sum to do
12:03:48 <heropass> good bot, I need to learn how to use it
12:04:02 <heropass> just add the numbers in the list .. this is what I came up with
12:04:04 <applicative> heropass, you can open a separate im conversation with her
12:04:42 <heropass> new to irc too, or more accurately it's been years, over a decade really
12:04:49 <applicative> of course, her limitless attractions will then attract you to what's being said on #haskell too.  .... that's her sinister purpose
12:04:59 <heropass> lol, right
12:05:12 <ljungk> applicative: hm, seems like I have some homework to do
12:05:15 <heropass> she be mighty sexy :)
12:05:21 <heropass> get to it!
12:05:48 <applicative> ljungk, have you been reading, say Learn You a Haskell, I think it has a pretty good account of type classes
12:05:58 <applicative> @where LYAH
12:05:59 <lambdabot> http://www.learnyouahaskell.com/
12:07:24 <burp> > (1+ 9^(-4)^(7*6)))^3^2^85
12:07:25 <lambdabot>   <no location info>: parse error on input `)'
12:07:33 <burp> > (1+ 9^(-4)^(7*6))^3^2^85
12:07:35 <applicative> ljungk, yes, chapter 3 of LYAH and then again in ch 8.  Its generally very readable, as people on here will I think attest
12:07:38 <lambdabot>   mueval: ExitFailure 1
12:08:27 <ljungk> applicative: Okay, I'll check it out. I've been reading some of the www.haskell.org/tutorial thus far
12:09:01 <applicative> ljungk, do you have Hugs or GHC installed?
12:09:16 <ljungk> ghc
12:10:07 <applicative> ljungk, oh good.   I was going to say there's http://tryhaskell.org/ if you are just dipping a toe in the water...
12:10:10 <ljungk> applicative: oh lyah looked well, kinda funny :)
12:11:04 <applicative> ljungk, it is in a witty style, but the pedagogical approach is very sound; it is not yet complete though.
12:12:08 <ljungk> applicative: yeah it seems like it aspires to get something across
12:12:46 <tao> is tryhaskell.org written in haskell?
12:12:53 <ljungk> okay, thanks all for explaining all that probably simple stuff. bye
12:13:16 <applicative> tao, ask chrisdone about it.
12:13:33 <tao> k
12:13:46 <voker57> tao: see bottom of page
12:13:56 <voker57> > Haskell evaluator powered by a patched version of  Gwern Branwen's mueval,
12:13:56 <lambdabot>   <no location info>: parse error on input `of'
12:14:08 <tao> o
12:14:21 <tao> thanks
12:19:52 <c_wraith> Hmm.  Anyone know how tough it'd be to get haskell support into Bespin?  (HTML 5 networked code editor from mozilla labs)
12:22:16 * hackagebot rangemin 2.1.1 - Linear range-min algorithms.  http://hackage.haskell.org/package/rangemin-2.1.1 (LouisWasserman)
12:24:34 <tao> http://therighttool.hammerprinciple.com/languages/delphi holy crap somebody still uses delphi?
12:24:38 <tao> what a joke
12:24:50 <tao> #   This is a low level language
12:24:52 <tao> waht
12:24:58 <vmixey> tao what if it works fine and stuff I don't see a prbolem
12:24:59 <jmcarthur> delphi is not entirely uncommon, is it?
12:25:14 <tao> delphi is a joke
12:25:22 <tao> programming with a mouse
12:25:28 <mreh> delphi was my first language
12:25:33 <mreh> scratch that, pascal
12:25:39 <tao> well yeah
12:25:45 <tao> pascal, not delphi
12:25:47 <vmixey> programming should be made as easy as possible
12:26:04 <mreh> that depends what you mean
12:26:10 <tao> programming with a mouse is not "easy"
12:26:26 <tao> some people find MS Word "easy", but emacs way too hard
12:26:33 <tao> while it's actually the other way
12:26:54 <vmixey> might be better to compare MS WOrd with Open Office or something
12:27:11 <danharaj> MS Word to LaTex
12:27:30 <tao> tex.el
12:27:40 <tao> well anyway, how's delphi easy?
12:28:35 <edwardk> delphi offered a good set of training wheels
12:28:45 <dolio> It makes guis quite easy, does it not?
12:28:50 <dolio> Similar to VB?
12:28:56 <arw> no, more powerful.
12:28:56 <edwardk> yeah
12:28:59 <tao> delphi is a c#, but without enterprise quality
12:29:10 <edwardk> tao: keep in mind when delphi was popular. ;)
12:30:19 <arw> delphi allows you to create a database application including the database from pre-made components just by clicking. even easier than special graphical database interfaces like ms access.
12:30:26 <edwardk> tao: it grew out of turbo pascal which was head and shoulders above everything else in the dos space in terms of compile time and usability as compilers went. borland just didn't manage to really migrate their base and retain market/mindshare once they moved to windows
12:30:57 <applicative> c_wraith, bespin seems stylin' i'm having trouble figuring it out though
12:31:09 <tao> haskell is not really popular
12:31:16 <tao> so popularity is not an argument
12:31:18 * hackagebot rangemin 2.1.2 - Linear range-min algorithms.  http://hackage.haskell.org/package/rangemin-2.1.2 (LouisWasserman)
12:31:26 <lowasser> WOOOO I'M BEATING C++ WOOO
12:31:50 <dolio> Are you also the guy who beat sim city?
12:31:53 <tao> Ok, I can understand people who argue that php is a good language
12:31:55 <tao> but delphi
12:31:57 <lowasser> okay time to go to class
12:32:19 <tao> 1) windows-only 2) pascal 3) mouse programming
12:32:44 <edwardk> tao: that i liked of delphi was what it inherited from turbo pascal ;) i'm not a fan of designers, but its competition at the time was vb not even vb.net ;)
12:32:58 <edwardk> er s/that/what/
12:33:20 <tao> ya i was using delphi myself
12:33:28 <tao> i thought it was cool
12:33:30 * edwardk thinks he makes more typos than everyone else on #haskell put together most days =/
12:33:40 <tao> but now i understand that it was a bad experience
12:33:48 <tromp> kylix is delphi for linux
12:34:32 <tao> There are a lot of simplier languages for begginers
12:34:33 <arw> tao: the mouse programming part concerns only the gui design, the rest is also possible in code. even the gui is possible in code, if you don't mind thinking in a coordinate grid
12:34:34 <tao> lua, tcl
12:34:52 <arw> simpler, yes, but better?
12:35:02 <tao> for begginers? yes
12:35:30 <mauke> for beginners I recommend a language that has a sorting algorithm built in so you don't have to write one yourself
12:35:33 <mauke> such as C
12:36:45 <tao> C is good for understanding the basics of computering, i belive
12:37:55 <tao> kylix is just a joke
12:38:14 <tao> if you want cross-platform simple gui app there is always QT
12:38:19 <p_l> tao: Well, the execution wasn't good, but Delphi itself was very good, IMHO
12:38:30 <p_l> and Kylix actually uses Qt
12:38:48 <tao> So why dont just write in QtDesigner?
12:39:11 <p_l> tao: C++ isn't necessarily a nice language to write in
12:39:42 <tao> why people in #haskell tries to protect delphi?
12:39:57 <arcatan> because they think Delphi has its merits?
12:40:18 <tao> For what thing delphi is good?
12:40:24 <tao> Other than for begginers
12:40:30 <p_l> sure, QtCreator makes C++ somehow bearable, but it doesn't take the sting out of C++
12:40:38 <tao> *other than as a learning enviroment
12:40:45 <p_l> tao: Delphi's main selling point wasn't Object Pascal nor learning environment
12:40:59 <vmixey> If something is good for beginners IMO it is also good for experts
12:41:20 <tao> vmixey: explorer.exe?
12:41:27 <tao> kde?
12:41:29 <p_l> vmixey: assuming it was made userfriendly, not newbie-friendly
12:41:40 <arw> tao: database applications. delphi was for a long time the tool of choice for any database interface.
12:41:59 <p_l> databases + multitiered environments with windows GUI
12:42:07 <tao> GUI is not needed
12:42:21 <p_l> tao: I think you just missed the point, completely
12:42:32 <tao> maybe
12:42:51 <tao> i dont get how delphi is better for writing database apps
12:42:53 <edwardk> tao: 'beginners' form the rather large tail of the programmer market
12:43:01 <tao> comparing to perl, for example
12:43:10 <edwardk> tao: so being only good for beginners is still a pretty darn good niche
12:43:13 <p_l> also, Delphi had rather large and well-prepared set of libraries
12:43:24 <tao> edwardk: no arguing here
12:43:54 <p_l> tao: Have you ever used Professional or Enterprise editions of Delphi?
12:44:00 <burp> who has the capabilities to calculate (1+ ( 9^^(-4) )^^(7*6))^3^2^85 for me? :>
12:44:17 <tao> p_l: i dont remember
12:44:29 <p_l> tao: then I suspect not
12:44:31 <tao> p_l: i think i illegally downloaded some premium stuff
12:44:36 <tao> when i was a kid
12:44:51 <arw> tao: you can connect your delphi to any database, it reads the schema. create a form with a datagrid, select the table or view to be displayed, instant searchable sortable view of your data. set the editable property, you can edit the data including sanity checks, transactions, rollback buttons.
12:45:12 <arw> tao: i really like perl, but i know nothing that compares to delphi in that aspect
12:45:32 <p_l> now add to that ready-made multi-tiered networked application developement and IMHO one of the best, even today, GUI design/developement systems
12:45:42 <tao> how BUTTONS are related to databases?
12:46:14 <p_l> tao: geez, I dunno, maybe for stuff like actually *working* with the data by user?
12:46:58 <p_l> a user that might not enjoy typing queries by hand or using batch jobs :)
12:46:58 <tao> if it's user, not some admin, why he should work directly with database, rather than user-friendly representation of data?
12:47:18 <p_l> tao: and what is said GUI if not user-friendly representation of data? You're contradicting yourself
12:47:25 <arw> tao: the gui actions automatically trigger the appropriate database functions. you don't have to write anything for your "commit, rollback, search, sort"-toolbar to work. you just drag it onto the form, *boom* it talks to the db.
12:47:38 <edwardk> tao: delphi was very good at writing those kinds of applications that use the database on the backend to provide friendly guis to those very users. the user isn't writing the delphi app, he is using it.
12:47:44 <arw> tao: it IS a user-friendly representation.
12:48:00 <tao> OO
12:48:01 <tao> ook
12:48:02 <tao> sorry
12:48:07 <tao> now im getting it
12:48:11 <p_l> or talks to application that deals with the data (here comes the very good CORBA support, no matter how bad CORBA was)
12:48:12 <mdmkolbe> Is anyone aware of any work to do generic traversals (e.g. Scrap Your Boilerplate) simultaneously over two structures (e.g. SYB Twin Traversal) where the traversals don't stay in lock step (i.e. the position within the two structures might not always be the same)?
12:48:12 <mdmkolbe>   (An example of this would be if you wanted to take all the Int values from one tree and store them in the same order in another tree with a different shape.)
12:49:22 <edwardk> mdmkolbe: coroutines
12:49:26 <arw> tao: if you did "web programming" you probably heard of CRUD. all of that boring stupid code is just 3 clicks, where stuff like RoR takes days...
12:49:36 <edwardk> mdmkolbe: there is a pretty straightforward coroutine monad you can use
12:49:49 <tao> still, proprietary crap. Wrting 4 lines for the database stuff wont break you apart
12:49:53 <tao> arw: no sorry
12:49:56 <tao> arw: havent heard of that
12:50:00 <edwardk> mdmkolbe: but you can do that with Traversable too
12:50:02 <tao> i guess im lucky
12:50:08 <arw> tao: :)
12:50:15 <mdmkolbe> edwardk: what about in a generic programming setting?
12:50:21 <mdmkolbe> @index Traversable
12:50:21 <lambdabot> bzzt
12:50:23 <tao> i heard of PHP tho
12:50:36 <tao> aka Personal Home Page
12:50:47 <p_l> ugh, PHP. No thanks
12:50:57 <tao> and they even have tk bindings? pfft
12:50:58 <edwardk> mdmkolbe: well, you can use Data to implement a form of Data.Traversable if you really want to do it SYB style ;)
12:51:09 <tao> hey, at least php is open
12:51:24 <p_l> tao: adding "open" to shit doesn't make me like it more
12:51:38 <tao> open shit > closed shit
12:51:40 <edwardk> tao: i wish they'd close it back up, its starting to stink in here...
12:51:43 <tao> also open shit smells more
12:51:53 <tao> lol
12:52:14 <jmcarthur> as long as it keeps the flies away from me i'm fine with its existence
12:53:01 * p_l is rather happy with proprietary software as long as it works as documented and the support is done correctly...
12:53:33 <edwardk> feces tends to attract flies. ;)
12:53:50 <jmcarthur> edwardk: i'm implying as long as it is far away from me
12:53:55 <edwardk> though i suppose if one stays away from php that does its job, yeah
12:55:03 <edwardk> but i thought we wanted to grab all the web developers and draw them into the community with happs(tack) and a bunch of buzzword compliant tools =)
12:55:25 * p_l does some webdev but on CL
12:55:59 * edwardk does a bunch of web dev as well, but is just feeling snarky today
12:56:47 <tao> perl is the best for webdev
12:56:55 <tao> king of the webdev
12:57:04 <jmcarthur> nuh uh!
12:57:15 <c_wraith> perl?  do people use that volunatarily?
12:57:24 <jmcarthur> i know at least two people IRL who do
12:57:44 <c_wraith> is there a support group?
12:57:53 <c_wraith> or a 12-step program?
12:57:56 <p_l> c_wraith: I had seen high-profile social network using it...
12:58:07 <aristid> c_wraith: i suppose there's #perl or ##perl
12:58:17 <tao> c_wraith: are you kidding me?
12:58:26 <aristid> edwardk: do you do your webdev with haskell?
12:58:28 <jmcarthur> tao: yes, c_wraith is kidding you
12:58:33 <tao> c_wraith: perl is flopping adorable
12:58:43 <jmcarthur> but perl really sucks, IMO
12:58:49 <tao> jmcarthur: that was a rethoracal question
12:58:52 <jmcarthur> ;)
12:58:56 <tao> wow
12:58:57 <tao> rude
12:59:17 <p_l> tao: I'd try doing the work in haskell first, despite my haskell-fu being rather bad, than take a project in Perl
12:59:19 <edwardk> aristid: nah. i do mostly web dev in c# these days, though i used to to do most of it in perl.
12:59:22 <c_wraith> perl is really a bad language.  I'm old.  I care about understanding code I wrote a year ago.  perl makes that as hard as possible.
12:59:40 <tao> c_wraith: umm
12:59:51 <tao> c_wraith: you can try writinng a better code in perl
12:59:59 <aristid> edwardk: too bad :/
13:00:01 * p_l uses Common Lisp where possible, though Haskell is fine too (isn't good enough in Haskell)
13:00:15 <jmcarthur> perl has too many ways to do the same things for anyone to write universally readable perl
13:00:21 <edwardk> aristid: i like parts of happstack, but it is rather enormous and self-entangled
13:00:31 <jmcarthur> i don't mean that it's a flaw in perl. it's just a flaw in circumstances
13:00:45 <arw> jmcarthur: english has too many ways to say the same things...
13:00:58 <c_wraith> tao: you can talk and talk about how that doesn't happen to good programmers.  But it happens in the real world.  And that's where I write software.
13:01:06 <jmcarthur> arw: you will not provoke me into defending english :P
13:01:14 <sepp2k> jmcarthur: Haskell has many ways to say the same thing too
13:01:18 <aristid> edwardk: so you wouldn't choose it if it were entirely up to you?
13:01:19 <LoRe> haskell has many ways to say the same too, und the one that performs is ugly to read :)
13:01:24 <edwardk> jmcarthur: it is tricky to write a large project in perl with multiple authors, but it can be done if you get a team on board with writing in a particular dialect
13:01:32 <jmcarthur> sepp2k: that it does
13:01:46 <tao> c_wraith: i didnt say that you were a bad programmer!
13:01:48 <tao> but you know
13:01:50 <jmcarthur> as i said, it's not a language flaw
13:01:53 <tao> a lot of people write perl
13:01:56 <jmcarthur> but it contibutes to difficulty
13:02:01 <tao> like tthey are writing some flopping C
13:02:19 <edwardk> aristid: depends on what i was working on. for most crud-type day-to-day apps? definitely not. if i had a bunch of haskell code i needed a web front end to? i probably would either use it or dash together a tiny cgi module
13:02:50 <c_wraith> tao: I'm not insulted. :)  I just have found perl is bad for long-term maintenance, in real world projects.  So I go towards languages with stronger static checks.
13:03:10 <jmcarthur> i'll just say this. my experiences reveal i higher unmaintainable:maintainable code ratio in perl than in most other language
13:03:18 <jmcarthur> *reveal a higher
13:03:29 <edwardk> jmcarthur: point granted ;)
13:03:34 <danharaj> Evil Mangler
13:03:46 <jmcarthur> PHP perhaps being even higher
13:03:48 <p_l> I recall something about sunsite's librarian scripts being the high-point of how far you could take perl's readability
13:04:27 <edwardk> jmcarthur: when i get stuck with perl i have to ask myself if i'm going to rewrite it, when i get stuck with php i have to ask myself _when_ i'm going to rewrite it ;)
13:04:28 <jmcarthur> but i think that might be due to the average skill of PHP programmers more than the language
13:04:39 <jmcarthur> heh, or maybe not, edwardk ;)
13:05:33 <c_wraith> speaking of doing evil things to code...  I *still* want to write "all eq [f, g, h, i, j]" instead of "and [eq f, eq g, eq h, eq i, eq j" where eq :: (Eq a) => (T -> a) -> Bool
13:05:53 <c_wraith> pretend I put the second closing bracket in there
13:07:17 <vmixey> you mean like f == g && f == h && f == i && f == j?
13:07:31 <vmixey> or f == g && g == h && h == i && i == j?
13:07:39 <jmcarthur> getAll . foldMapReduce eq
13:07:45 <jmcarthur> or something like that
13:07:46 <c_wraith> vmixey: neither.
13:07:53 <vmixey> what then?
13:08:02 <jmcarthur> http://hackage.haskell.org/packages/archive/monoids/0.2.0.2/doc/html/Data-Monoid-Reducer.html#v%3AfoldMapReduce
13:08:10 <c_wraith> T is a record.  each of f, g, h, i, etc is an accessor.
13:08:32 <c_wraith> There are two instances of T in scope in the definition of eq, and those accessors are applied to each
13:08:48 <vmixey> well that doesn't make sense
13:08:58 <tao> know another awesome language?
13:09:00 <tao> tcl
13:09:04 <jmcarthur> c_wraith: is this equivalent?  and $ map eq [f, g, h, i, j]    ?
13:09:07 <vmixey> tao, I don't really like tcl
13:09:09 <tao> it's old and crappy
13:09:12 <tao> but it's funny
13:09:19 <vmixey> tao, although it's kind of neat you can define lambda in it
13:09:21 <tao> vmixey: yeah it's just for fun
13:09:24 <vmixey> tao yeah
13:09:27 <c_wraith> jmcarthur: the accessors don't have the same type, so you can't define a list of them.
13:09:29 <tao> you can define unknown procedures
13:09:34 <jmcarthur> oh i see
13:09:36 <c_wraith> jmcarthur: that's the real problem
13:09:38 <vmixey> wouldn't want to use it for anything other than experimenting
13:09:40 <tao> using regex
13:09:56 <tao> vmixey: i'd use tcl instead of lua
13:10:03 <tao> they are both simple
13:10:16 <jmcarthur> HList?
13:10:17 <tao> but tcl was written but somebody who was really drunk
13:10:25 <tao> and tcl is made for drunk coding
13:10:26 <vmixey> tao - well I have never tried to connect tcl up with C code.. but I can't imagine it could be done better than how lua does
13:10:27 <c_wraith> I guess I should look at HList.
13:10:33 <jmcarthur> i have never used HList and would probably prefer not to :)
13:10:47 <c_wraith> whaaaat?  Haskell is made for drunk coding.  Most of my best haskell code was written while drunk! :)
13:10:53 <tao> vmixey: it's pretty well done
13:11:10 <dolio> tcl was made to be hooked up to C, wasn't it?
13:11:11 <tao> i havent tried embeding lua in C tho
13:11:15 <danharaj> I need to take a shot when I'm staring down type errors.
13:11:16 <jmcarthur> c_wraith: yeah, really. the type system is the perfect harness for people who try stupid things!
13:11:21 <tao> dolio: well not completely
13:11:43 <jmcarthur> really the only reason to use tcl is for tk
13:11:44 <tao> god i love this channel
13:11:50 <dolio> I don't doubt it's progressed beyond that, of course.
13:11:50 <c_wraith> jmcarthur: yep.  between the type system and unit tests written while sober, I feel confident programming haskell while tipsy
13:11:55 <tao> the only good channel on freenode
13:12:00 <jmcarthur> heh
13:12:21 <jmcarthur> tao: have you seen Io? i think you would like it
13:12:31 <jmcarthur> http://iolanguage.com/
13:12:54 <tao> i havent seen it
13:12:57 <tao> but i bet it's crap
13:13:08 <jmcarthur> i love your optimism
13:13:13 <tao> lo
13:13:22 <c_wraith> oh no.  Written by Oleg, and it uses TH.  I fully expect to not understand any of this!
13:13:25 <tao> nspired by Smalltalk (all values are objects
13:13:29 <tao> another ruby
13:13:30 <jmcarthur> c_wraith: i wouldn't bother
13:13:38 <jmcarthur> tao: it's not really like ruby at all
13:13:47 <jmcarthur> it's quite unique
13:13:55 <jmcarthur> it's probably more like Self than anything
13:13:58 <jmcarthur> else
13:14:24 <tao> OH WOW THEY HAVE TWITTER
13:14:30 <tao> HIPSTER LANGUAGE
13:14:43 <c_wraith> Yikes.  ok, I give up.  No HList for me
13:14:49 <jmcarthur> this is a little uncalled for, tao
13:15:06 <tao> sorry?
13:15:13 <tao> what do you mean, jmcarthur ?
13:15:23 <tao> forgive my english skills
13:15:33 <jmcarthur> tao: you're getting a little... "rude" might be the right word, but i'm not sure
13:15:43 <tao> o ok
13:15:52 <tao> sorry if i might sound rude
13:15:59 <tao> i am just ironic
13:16:08 <tao> don't take me seriously
13:16:11 <tao> brb, shower
13:16:18 <Taejo> so *you* are the hipster, tao
13:16:18 <jmcarthur> tao: i understand that language barriers are hard to cross when you try to make a joke ;)
13:16:55 <tao> Taejo: k
13:20:41 <Silvah> YASSQ: what "hipster" means?
13:21:08 <xerox> try #haskell-blah
13:21:45 <Silvah> I'm just trying to understand what they wrote.
13:22:33 <jmcarthur> Silvah: it's a description given to trendy people or things, usually derogatory
13:23:02 <danharaj> what flag to I give ghc to tell it not to save intermediate compilation files (e.g. object files)
13:24:31 <Silvah> jmcarthur: thanks.
13:26:05 <Silvah> danharaj: I think that GHC doesn't keep intermediate files by default.
13:26:22 <Silvah> Object files are by no means intermediate.
13:27:17 <pelotom> can someone explain to me the concept of the "least fixed point" of a functor?
13:27:52 <c_wraith> > fix (0:) -- no, but I can generate an infinite list
13:27:53 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:27:56 <vmixey> pelotom, do you know initial algebras?
13:28:00 <Taejo> pelotom: do you know about fixed points at the value level (e.g., the function fix)?
13:28:28 <pelotom> Taejo: yes, vmixey... I'm a little shaky on that
13:28:55 <pelotom> "algebras" in the categorical sense, I'm a little shaky on
13:29:05 <Taejo> pelotom: the least fixed point of a functor is just like the least fixed point of a function, except that it's on the type level
13:29:53 <c_wraith> :kind Mu
13:29:56 <danharaj> Taejo: I think the 'least' part is probably confusing as well.
13:29:58 <c_wraith> @kind Mu
13:29:59 <lambdabot> (* -> *) -> *
13:30:29 <Taejo> danharaj: it's not different from least at the value-level, is it?
13:30:30 <c_wraith> that seems related
13:30:50 <pelotom> yeah, what does "least" mean in the context of types?
13:31:33 <Taejo> that's actually a good quetion
13:31:33 <vmixey> for a simple example of least vs greatest fixed points think of natural numbers {Z,S Z,S (S Z),...} vs {Z,S Z,S (S Z),...,S (S (S (S (S ...))))}
13:32:05 <vmixey> {Z,S Z,S (S Z),...} is taken from the least fixed point of  <N> ::= Z | S <N>, whereas {Z,S Z,S (S Z),...,S (S (S (S (S ...))))} is taken from the greatest fixed point
13:33:33 <danharaj> vmixey: Why is that the greatest fixed point? Surely you could consider any limit ordinal as a fixed point of 1 + X
13:33:59 <ville> Howdy. Any Emacs, Haskell and particularly emacs haskell-mode users? When I load the haskell-site-file.el I get some odd garbage to the mini buffer and Messages buffer. Anyone else run into this and have fixed it?
13:34:39 <ville> More specifically it occurs when I open an .hs file, grepping for the garbage brings no result though.
13:35:23 <pelotom> vmixey: you're saying the set of all natural numbers must come from the LFP?
13:36:00 <vmixey> S (S (S (S (S ...)))) is not a limit ordinal AIUI
13:36:26 <kar-1> pelotom, the idea is that the least fixed point is the smallest set that solves the recursive definition
13:36:26 <lambdabot> kar-1: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:36:58 <danharaj> vmixey: That's \omega, no?
13:37:16 <vmixey> I think {Z,S Z,S (S Z),...} is \omega
13:37:28 <heropass> @ville mine works fine
13:37:28 <lambdabot> Unknown command, try @list
13:37:37 <pelotom> kar-1: so a "point" in this case is a set of values that inhabit a datatype?
13:37:40 <vmixey> but in haskell we would represent that as  Lim fromIntegral  (data O = Z | S O | Lim (N -> O))
13:38:20 <vmixey> The good news if any value form the LFP O is well founded, S (S (S ...)) isn't well founded though - so in what sense is it an ordinal?
13:38:25 <kar-1> pelotom, that is the general idea
13:38:43 <vmixey> I would call it \ourbouros before \omega
13:38:44 <danharaj> vmixey: My intuitions got muddled :p
13:39:03 <mauke> 
13:39:30 <pelotom> hm, I'm still confused
13:40:14 <pelotom> I'm reading this paper by meijer (bananas, lenses, etc.) and I'm ok until page 10
13:40:20 <Silvah> I'll better escape as fast as possible... Good night.
13:40:44 <danharaj> vmixey: the lfp is an ordinal. What is the gfp?
13:41:05 <Olathe> Is there a type of Map that can quickly give a list of all the keys that contain a value ?
13:41:28 <pelotom> 'We let F denote the pair (L, in) and say that it is "the least fixed point of F".'
13:42:01 <vmixey> pelotom, say we defined   data N n = Z | S n
13:42:22 <vmixey> Then  N  is a type equivalent to the natural numbers I was talking about earlier
13:42:45 <vmixey> the values look like {Z, S (in Z), S (in (S in Z)), ...}
13:42:51 <vmixey> oops missed some brackets
13:43:15 <vmixey> (I maybe used in when I should have used L too)
13:43:22 <pelotom> vmixey: but isn't that just N?
13:43:46 <vmixey> data N n = Z | S n, the values of N Bool, say look like {Z,S True,S False}
13:44:00 <vmixey> or the avlues of N (N ()) look like {Z,S Z,S (S ())}
13:44:08 <vmixey> ahh
13:44:20 <vmixey> {in Z, in (S (in Z)), in (S (in (S (in Z)))), ...}
13:44:38 <vmixey> jst a correction, before I write values of N(N), this time there are values of N
13:46:48 <vmixey> (By the way, this N is called Maybe in haskell)
13:58:19 <tedm> Anybody know how to get Cabal working with a new install of ghc?
13:58:47 <pokoko222> Someone has written integration algorithms?
13:59:00 <pikhq> Indeed, they exist.
13:59:05 <jmcarthur> pokoko222: just yesterday i wrote a numeric integration function
13:59:08 <tedm> I had an existing install of ghc with it's own set of default packages (the haskell platform), and I used that to build a new ghc
13:59:19 <jmcarthur> but it sucks right now. it's just a proof of concept in a bigger framework
13:59:53 <pokoko222> jmcarthur does it use u substitution?
13:59:59 <jmcarthur> tedm: is it Cabal or cabal-install that you need? ghc should come with Cabal already
14:00:02 <tedm> It looks like a whole bunch of stuff in the ghc/libraries directory built, but it doesn't seem to be 'registered'?
14:00:08 <jmcarthur> pokoko222: no, it's a numerical integrator
14:00:37 <jmcarthur> tedm: i'm at a loss then
14:00:44 <jmcarthur> maybe ask in #ghc or something?
14:01:06 <tedm> jmcarthur: Well, it does seem to have Cabal in /usr/loca/lib/ghc-XXXX, but I'm trying to install cabal-install, and the bootstrap.sh file that gets dependancies is complaining about 'base' being missing
14:01:32 <tedm> jmcarthur: Yeah - I wasn't sure about #ghc - I was concerned that that channel was mostly just for ghc devs
14:01:40 <tedm> not for lowly newb questions :-)
14:01:54 <jmcarthur> tedm: is /usr/local/bin in your PATH?
14:02:01 <tedm> yup
14:02:17 <tedm> I have my new ghc there and it runs just fine with trivial programs
14:02:19 <jmcarthur> tedm: and are you sure that the bootstrap script is using it instead of something in /usr/bin?
14:02:43 <tedm> I've wiped out the ghc link in /usr/bin, not the versioned ghc symlink though
14:03:11 <tedm> if the bootstrap is using exec(ghc) then it should be getting the shiny new one...
14:03:20 <jmcarthur> tedm: what do you see if you run ghc-pkg list?
14:03:21 <tedm> maybe I should just uninstall the old one just in case
14:04:46 <tedm> interesting...it says, "-bash: /usr/bin/ghc-pkg: No such file or directory", and yet "which ghc-pkg" yields "/usr/local/bin/ghc-pkg"
14:06:32 <jmcarthur> huh
14:06:46 <tedm> Hmm...something funny going on with my paths, but when I execute the versioned ghc-pkg in my dir it gives me a list of packages
14:08:47 <mauke> tedm: hash -r
14:09:09 <pokoko222> The Risch algorithm is described in over 100 pages :D would be crazy to do integration algorithms in haskell, anyone has experience here?
14:10:10 <tedm> eek - I didn't know about hash -r. Thanks mauke - that worked
14:10:23 <tedm> That's terrible - oh well
14:12:02 <edwardk> rokoteko: i have algorithms for derivatives in haskell =)
14:12:14 <edwardk> rokoteko: but alas no integrator =)
14:13:16 <danharaj> edwardk: Do you pretty print to latex :p
14:13:56 <pokoko222> edwardk you wrote them :) heh i always wanted to do calculus algorithms but never had time since i studied for exams
14:14:02 <edwardk> danharaj: nah my derivative stuff is just numerical AD stuff anyways
14:14:08 <pokoko222> now i want to do integration one, which is complicated task
14:14:39 <edwardk> pokoko222: richardson's theorem and the fact that its just generally searching a huge kind of makes me avoid tackling symbolic integration
14:14:52 <edwardk> er searching a huge kind of space
14:15:21 <pokoko222> did not get what u said, nevermind ;)
14:16:11 <edwardk> pokoko222: http://hackage.haskell.org/package/rad
14:16:24 <edwardk> (my obsession of the moment)
14:17:01 <pastorn> jmcarthur: did you settle for a name?
14:17:10 <pastorn> (the FRP library)
14:17:47 <mreh> more FRP?
14:17:59 <pokoko222> edwardk nice
14:18:02 <c_wraith> morf?
14:18:02 * hackagebot hpage 0.10.1 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.10.1 (FernandoBenavides)
14:18:14 <c_wraith> morf would be a good (bad) name for an FRP package. :)
14:18:38 <mreh> good meaning bad?
14:18:46 <pastorn> c_wraith: "tinfoil"/"tinfeuler" where suggested
14:18:47 <mreh> that's a new slang I haven't heard
14:18:59 <vmixey> Page is targeted at those haskell developers which also like to work with dynamic GUIs and wish to have something like Smalltalk's Workspace or jPage for Java -- That sounds cool! Where are the screenshots?
14:19:01 <Silvah> Words have no meaning.
14:19:23 <edwardk> !@#*) paywall. was hoping to skim http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6TY8-4JCBKHG-4&_user=10&_coverDate=09%2F01%2F2006&_rdoc=1&_fmt=high&_orig=search&_sort=d&_docanchor=&view=c&_searchStrId=1340013253&_rerunOrigin=scholar.google&_acct=C000050221&_version=1&_urlVersion=0&_userid=10&md5=2d8b5efbe7d8f2826a1901be4c4c5946
14:19:33 <pastorn> edwardk: tinyurl?
14:19:38 <edwardk> heh
14:19:42 <mauke> hugeurl.com
14:19:52 <edwardk> http://bit.ly/c8maH3
14:19:58 <waern> vmixey: http://haskell.hpage.com/
14:20:04 <waern> :-)
14:20:28 <vmixey> waern, huh?
14:20:31 <edwardk> i have the derivatives, so that part is easy ;)
14:20:42 <edwardk> and i was already using guassian quadrature
14:21:05 <waern> vmixey: that page has screenshots of hpage
14:21:28 <vmixey> oh that was weird
14:21:36 <vmixey> the first few times I tried to load it, I was getting Firefox can't find the server at elbrujohalcon.github.com.
14:21:38 <vmixey> but it's working nw
14:21:51 <waern> I see
14:21:53 <b0fh_ua> Hello! Was anybody able to build haskell-platform on FreeBSD 8? I installed GHC 6.12.2, but there are some problems with building of haskell-src, if sing cabal package.
14:22:16 <vmixey> when I click on screenshots it just goes blue but there is no screenshot :[
14:23:15 <byorgey> same for me
14:23:32 <waern> yeah, same thing happens here
14:23:35 <pastorn> waern: pm
14:23:59 <Silvah> Maybe it's just a screenshot of a blue screen.
14:24:45 <waern> I guess we have to actually have download and run it! ;-)
14:24:53 <vmixey> haha
14:24:55 <vmixey> so that's your plan
14:31:22 <jkingkong> Dear #haskell, I'm trying to test out some of the parallelism functions as in http://www.cse.unsw.edu.au/~chak/papers/ndp-haskell.ps.gz
14:31:37 <jkingkong> specifically, things like mapP and sumP over [:r:]
14:31:43 <jkingkong> will this work in ghci?
14:32:11 <jkingkong> i'm not sure what package these commands are associated with
14:32:16 <jkingkong> hoogle gives nothing, for example
14:35:01 <Axman6> jkingkong: i think you need to run ghci like ghci -fdph file.hs
14:38:08 <jkingkong> Axman6: thanks I will try that
14:38:28 <Axman6> check the ghc man page to make sure that's the right flag
14:38:47 <jkingkong> hmm, says they're unrecognized, i'll check the page like you said
14:39:50 <gwern> what an ugly manpage
14:40:21 <jkingkong> fdph-seq or fdph-par works
14:40:51 <jkingkong> well kinda
14:41:04 <jkingkong> mapP still isn't in the scope
14:41:58 <jkingkong> *smacks forehead
14:42:25 <jkingkong> didn't import Data.Array.Parallel
14:42:35 <Silvah> It happens.
14:42:35 <chrisdone> @tell peaker got any more done on that visual programming front?
14:42:36 <lambdabot> Consider it noted.
14:46:38 <jkingkong> gosh what do types like [:b:]  look like?
14:46:50 <jkingkong> ghc is not at all happy with [:1,2,3:] for example
14:47:39 <jkingkong> it tells me I need parentheses in all sorts of weird places
14:48:17 <daddyT> hi...ANY BODY WIT C99SHEL
14:48:24 <Lemmih> jkingkong: Use -XPArr
14:49:29 <jkingkong> lemmih, fixed thanks a lot
14:57:24 <Axman6> daddyT: what?
15:02:59 <Silvah> It was somewhat similar to "CAN HAS STDIO?". Perhaps he said something in LOLCODE?
15:03:15 <K4ka> !register
15:04:51 <daddyT> k
15:09:08 <mreh> is this possible: (sf1, (b0, c0)) = tf10 (a0, c0)
15:09:27 <mreh> admittedly it's in the definition of ArrowLoop for signal functions
15:10:04 <c_wraith> mreh: it's allowed.  It may diverge, but it's allowed
15:10:37 <mreh> c_wraith what does that represent in the expression tree?
15:10:48 <mreh> madness!
15:11:12 <mreh> is there a simple analogy?
15:11:24 <mreh> is anything like "ones = 1 : ones?
15:11:26 <c_wraith> > fix $ const 5
15:11:27 <lambdabot>   5
15:12:00 <mreh> :t fix
15:12:01 <lambdabot> forall a. (a -> a) -> a
15:12:04 <EvanR-work> gonna have to learn me these arrows
15:12:30 <mreh> they're like machines with conveyor belts
15:13:01 <EvanR-work> are the belts made out of tortilla
15:13:26 <mreh> do they do smell strangely like nacho cheese
15:13:34 <EvanR-work> lol
15:14:08 <mreh> c_wraith: I don't get it
15:14:13 <mreh> is that the fixpoint operator?
15:14:17 <c_wraith> > let tf10 (a, b) = (1, (2, 3)) ; (sf1, (b0, c0)) = tf10 (1, c0) in (sf1, (b0, c0))
15:14:18 <lambdabot>   (1,(2,3))
15:14:39 <c_wraith> that's a boring example
15:14:57 <c_wraith> I could come up with a more interesting one, but it's tougher. :)
15:15:28 <mreh> > fix id
15:15:31 <lambdabot>   mueval-core: Time limit exceeded
15:15:37 <mreh> heh heh
15:15:40 <c_wraith> > fix error
15:15:41 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:15:58 <Silvah> hahaha
15:16:06 <c_wraith> here's a more useful example:
15:16:19 <Veinor> fix error will never cease to amuse me
15:16:20 <mreh> > fix (++ [])
15:16:23 <lambdabot>   mueval-core: Time limit exceeded
15:16:25 <c_wraith> > let ones = 1 : ones in ones
15:16:26 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:16:38 <c_wraith> > let ones = fix (1 :) in ones
15:16:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:16:43 <Veinor> > fix ([] ++)
15:16:47 <lambdabot>   mueval-core: Time limit exceeded
15:17:04 <c_wraith> you can substitute fix for explicit recursion
15:17:16 <mreh> this is the fixpoint function, yes?
15:17:20 <c_wraith> yes
15:17:31 <mreh> amazing, it's magic
15:17:44 <c_wraith> > let fibs = 0 : scanl (+) 1 fibs in fibs
15:17:44 <mreh> it doesn't work on functions does it?
15:17:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:17:46 <Silvah> :t fix
15:17:47 <lambdabot> forall a. (a -> a) -> a
15:17:57 <edwardk> :t fix id
15:17:58 <lambdabot> forall a. a
15:18:11 <c_wraith> > let fibs = (0 :) . scanl (+) 1 $ fibs
15:18:12 <lambdabot>   not an expression: `let fibs = (0 :) . scanl (+) 1 $ fibs'
15:18:13 <tensorpudding> Fix doesn't actually find the fixed point as far as I can tell.
15:18:17 <c_wraith> > let fibs = (0 :) . scanl (+) 1 $ fibs in fibs
15:18:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:18:42 <c_wraith> > let fibs = fix $ (0 :) . scanl (+) 1 in fibs
15:18:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:18:47 <EvanR-work> Y f = f (Y f)
15:18:53 <c_wraith> that example should give you some idea what fix does
15:18:58 <danharaj> Is there an frp library based on Conal Elliott's push-pull frp paper?
15:19:09 <EvanR-work> f (Y f) = Y f
15:19:17 <mreh> danharaj: reactive?
15:19:25 <danharaj> mreh: is that so.
15:19:28 <mreh> that's the only FRP library I know that he's written
15:19:36 <mreh> so I don't know
15:19:56 <mreh> all I knows is arrows, and I likes what I sees
15:20:04 <tensorpudding> So I'm not sure why fix exists.
15:20:18 <c_wraith> tensorpudding: why does foldl exist?
15:20:18 <mreh> @src fix
15:20:18 <lambdabot> fix f = let x = f x in x
15:20:26 <c_wraith> tensorpudding: why does map exist?
15:20:40 <mreh> because they're useful to do explicit recursion
15:20:45 <jmcarthur> mreh: reactive isn't arrow-based
15:20:51 <c_wraith> These are all higher-order functions that abstract out explicit recursion
15:20:53 <mreh> jmcarthur: I know
15:20:58 <tensorpudding> It doesn't find fixed points on functions that have fixed points.
15:21:10 <c_wraith> sure it does.
15:21:13 <mreh> it just so happens it doesn for const
15:21:18 <c_wraith> an infinite list is a fixed point.
15:21:29 <c_wraith> fix can find many infinite lists
15:21:33 <tensorpudding> > fix (\x -> 2*x)
15:21:37 <lambdabot>   mueval-core: Time limit exceeded
15:21:45 <c_wraith> it doesn't find *all* fixed points
15:21:53 <tensorpudding> It's supposed to find the least fixed point
15:22:08 <c_wraith> err, rather, it doesn't find the least fixed point of *all* functions.
15:22:13 <c_wraith> Just ones that are non-strict.
15:22:29 <c_wraith> (*2) is a strict function...  at least with Int or Integer
15:22:36 <mreh> well my brain is thoroughly throbbing for tonight
15:22:48 <jmcarthur> danharaj: i've written a few, but they mostly didn't get completed
15:22:55 <jmcarthur> i'm on a completely new direction right now
15:23:03 <c_wraith> > (1:) undefined
15:23:04 <lambdabot>   [1*Exception: Prelude.undefined
15:23:08 <jmcarthur> i didn't release any
15:23:10 <mreh> danharaj: I recommend Yampa
15:23:24 <tensorpudding> They should change the documentation of the function to reflect reality.
15:23:25 <jmcarthur> mreh: danharaj asked about any based on push-pull
15:23:32 <c_wraith> Note that (1:) is non-strict, because it generates a non-_|_ result when given _|_
15:23:36 <jmcarthur> i don't really like yampa, either way
15:24:00 <c_wraith> tensorpudding: are there any non-strict functions fix doesn't work for?
15:24:01 <mreh> danharaj, in the absence of what you want, I still recommend yampa
15:24:02 <jmcarthur> mreh: sorry, i think you were aware of that already. n/m
15:24:31 <tensorpudding> It doesn't specify that it does not work for strict functions.
15:24:36 <mreh> jmcarthur: what don't you like about Yampa, having had no experience of ~AFRP I don't know what to think
15:25:47 <jmcarthur> mreh: it's not simple, it leaks its implementation, it doesn't have a good story for events, and arrow syntax is tedious and overly sequential
15:26:30 <tensorpudding> It's not clear to me why it can't find fixed points for strict functions though, since if there is an attractive fixed point for the function, eventually the result of iterating the function will be so close to the input that it is no longer possible to distinguish them
15:26:56 <mreh> jmcarthur: what does it leak?
15:27:03 <c_wraith> tensorpudding: the implementation is constructive, though, rather than search-based.
15:27:05 <jmcarthur> mreh: sampling rate, for example
15:27:20 <mreh> jmcarthur: that's a minor quibble surely?
15:27:30 <gwern> > 54 / 37
15:27:31 <mreh> with reactimate that's never an issue
15:27:31 <lambdabot>   1.4594594594594594
15:27:32 <jmcarthur> mreh: if events happen faster than the sampling rate then you lose them
15:27:37 <jmcarthur> i wouldn't call that minor
15:27:44 <gwern> > 37 / 54
15:27:45 <lambdabot>   0.6851851851851852
15:27:54 <jmcarthur> reactimate?
15:27:55 <mreh> jmcarthur: user input events, not Yampa Event events
15:28:00 <mreh> ?
15:28:06 <tensorpudding> If the function has a single attractive fixed point, it won't matter what value you start with, you'll always end up there
15:28:30 <jmcarthur> mreh: the source doesn't really matter
15:28:46 <c_wraith> tensorpudding: there's a single fixed point for (1:), but iterated application will never converge to it.
15:29:01 <mreh> jmcarthur: you can only get one event ocurring internally from source at a time
15:29:15 <mreh> if you get lots of events from the outside world you can compose them nicely
15:29:17 <jmcarthur> mreh: per sample
15:29:26 <tensorpudding> The fixed point to (1:) is an infinite list of 1's, right?
15:29:26 <jmcarthur> only one per source per sample
15:29:58 <ivanm> tensorpudding: yeah
15:29:58 <tensorpudding> I'm talking for functions on numbers, here.
15:30:00 <mreh> jmcarthur: yes, so implementations tend to use these big datatypes to store all the info
15:30:01 <ivanm> > fix (1:)
15:30:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:30:09 <mreh> is that what you dislike?
15:30:43 <jmcarthur> mreh: the main thing i dislike is the other stuff i said. the sampling rate issue is not that big in comparison
15:30:44 <c_wraith> tensorpudding: my point is that constructive methods work fine for non-strict functions, but don't work for strict functions, and vice-versa for search methods.
15:31:28 <tensorpudding> I cannot see _why_ they fail for, say, the iteration x_n+1 = x_n / 10
15:31:40 <jmcarthur> mreh: plus Arrow in general is an epic hack, but that's not Yampa's fault
15:31:46 <tensorpudding> Are GHC's double's infinite precision?
15:31:56 <ivanm> tensorpudding: no
15:32:00 <vmixey> no they're just C double IIRC
15:32:03 <mreh> jmcarthur: I've used to extensively for games, so I've never required real precision
15:32:09 <ivanm> tensorpudding: use CReals if you need that
15:32:12 <mreh> jmcarthur, how so?
15:32:16 <ivanm> (but remember that they're _slow_)
15:32:40 <tensorpudding> I don't want infinite precision, I'm saying that a finite precision type should eventually just display 0
15:32:51 <c_wraith> tensorpudding: the problem is that a constructive method just doesn't converge with a strict function.  it builds an infinite evaluation stack, instead.
15:32:55 <tensorpudding> when you try to find the fixed point of the iteration of that function.
15:33:06 <jmcarthur> mreh: it's not very well decomposed into separate classes, and Arrow itself is actually just equivalent to Category+Applicative, so it's completely redundant
15:33:22 <tensorpudding> c_wraith: so the problem is that the iterations aren't being evaluated?
15:33:41 <tensorpudding> i.e. if I used seq to force evaluation it would work?
15:33:51 <c_wraith> tensorpudding: no, because there's a data dependency.
15:34:00 <c_wraith> it's f (f (f ....
15:34:17 <mreh> jmcarthur: Arrow = Category+Applicative isn't a bad abstraction
15:34:33 <c_wraith> if the function is strict, the inner f needs to return before the outer f can produce output.
15:34:43 <c_wraith> and that builds an infinite stack
15:34:47 <jmcarthur> mreh: it's not abstraction. that's literally what it is
15:34:58 <tensorpudding> So what is needed is a different model.
15:35:05 <mreh> what's >>> under that then?
15:35:06 <mreh> I'm curious
15:35:18 <c_wraith> tensorpudding: a search approach, with a seed value.
15:35:18 <tensorpudding> It needs something which evaluates each item and then compares it to the input.
15:35:33 <c_wraith> :t iterate
15:35:35 <lambdabot> forall a. (a -> a) -> a -> [a]
15:35:35 <byorgey> mreh: >>> already comes directly from Category
15:35:41 <c_wraith> iterate is very close to that.
15:35:42 <byorgey> it's a synonym for flip (.)
15:36:05 <jmcarthur> mreh: anyway, my main issue with Yampa's event model is that it has this stipulation about events not being "infinitely dense." that's where the sampling rate leak comes from. it's even in the spec
15:36:14 <rizlah> Ok, so its time to learn a new language for more general purpose applications. I am wondering how well Haskell would perform as a server for TCP clients (~2000 per sec)
15:36:44 <tensorpudding> So fix isn't useful for finding real fixpoints of strict functions, only for non-strict functions.
15:36:54 <c_wraith> tensorpudding: yes.
15:37:01 <tensorpudding> Why does it exist again?
15:37:08 <c_wraith> why does map or foldl exist?
15:37:15 <jmcarthur> mreh: arr f = fmap f id; (&&&) = liftA2 (,)
15:37:17 <c_wraith> to abstract common patterns.
15:37:31 <tensorpudding> So common I've never seen it!
15:37:32 <c_wraith> fix just happens to abstract out the pattern of "explicit recursion"
15:37:35 <ivanm> tensorpudding: because it can? :p
15:37:49 <ivanm> it's a variant of the Y-combinator; someone probably figured Haskell needed more lambdas
15:38:29 <ddarius> It's occassionally handy, though in most cases a recursive let or equivalent is more readable.
15:38:46 <vmixey> @let (<,>) = liftM2 (,)
15:38:47 <lambdabot>   Parse error: Comma
15:38:49 <vmixey> damn
15:38:52 <ddarius> I believe it's dcoutts or sjanssen that likes to use it for an "anonymous loop"
15:38:56 <vmixey> haskell is against me
15:39:02 <napping> rizlah: that should be manageable based on some of the web server benchmarks I've seen, as long as you don't do too much per request
15:39:07 <c_wraith> yeah.  the pattern fix abstracts out is quite common.  It's just so general that the combinator is a huge pain to understand. :)
15:39:10 <jmcarthur> mreh: i'm currently working on a "classical" (non-arrow) DCTP library that has a similar event model to yampa but doesn't have to rule disallowing infinitely dense events
15:39:11 <vmixey> > let (<,>) = liftM2 (,) in 3
15:39:12 <lambdabot>   <no location info>: parse error on input `,'
15:39:16 <vmixey> why!!
15:39:27 <mreh> jmcarthur, I'm not sure what infinite density is
15:39:30 <jmcarthur> *doesn't have the rule disallowing
15:39:30 <rizlah> napping: Well, with threads it shouldn't be a problem right? or does haskell not support threads/multiple processes?
15:39:39 <c_wraith> vmixey: commas aren't valid operator characters.  :(
15:39:47 <tensorpudding> I'm curious where the abstraction ceiling is, beyond which reasoning or learning is impossible.
15:39:49 <Polarina> rizlah, it supports SMP.
15:39:50 * lispy just noticed hogre on hackage
15:39:51 <vmixey> revolting!
15:40:07 * lispy just became interested in Ogre3d when he saw that Torchlight uses it
15:40:12 <napping> The threading model is very nice. Lightweight threads distributed over SMP cores, STM for easy-to-write concurrency
15:40:26 <Phyx-> I was wondering if anyone knows a way to get the module name via the GHC api without having to do a depanal
15:40:36 <jmcarthur> mreh: basically it means that you can't just have a signal (T -> Event a) that has continuous events
15:40:39 <rizlah> napping: So haskell's thread support is good?
15:40:45 <ivanm> oh, I've just realised why vmixey has been ignoring me all this time; because it's just fax aka MissPiggey ignoring me with yet another new nick...
15:40:58 <mreh> jmcarthur, right, yeah, I understand
15:41:03 <jmcarthur> mreh: rather, yampa stipulates that your events happen "at least some X amount of time" from each other
15:41:06 <gwern> STM is dying. .net confirms it.
15:41:09 <EvanR-work> rizlah: forkIO, MVar, Chan, for the win
15:41:11 <ivanm> gwern: heh
15:41:18 <mreh> Yampa events are kinda infinitely thing
15:41:22 <mreh> thin*
15:41:28 <DigitalKiwi> ivanm: lawl
15:41:31 <gwern> ivanm: one day, people will not understand my old /. allusions
15:41:31 <jmcarthur> that can be pretty frustrating if you have a lot of events across a small period of time
15:41:38 <gwern> all these memes will be lost. like tears in the rain
15:42:02 <ivanm> DigitalKiwi: seriously, who keeps changing nicks that often all the time?
15:42:03 <rizlah> Hmm
15:42:04 <mreh> time to die..
15:42:09 <ddarius> gwern: I will rejoice on that day.
15:42:19 <rizlah> Well, currently the choice is between Haskell and Java. I am not sure which one to pick up and learn.
15:42:28 <EvanR-work> haskell.
15:42:28 <lispy> gwern is the meme and ddarius is the anti-meme
15:42:29 <ivanm> rizlah: definitely not Java
15:42:29 <gwern> ddarius: a little part of our subculture, our shibboleths, will be lost
15:42:30 <lispy> ?
15:42:37 <DigitalKiwi> i don't ever rememember seeing a the first one
15:42:42 <gwern> lispy: and what's the syntheme?
15:42:43 <DigitalKiwi> lispy: did you ever play mythos?
15:42:45 <ivanm> if you have to, pick Scala or Clojure if you want a JVM language
15:42:52 <rizlah> ivanm: Thats what I'm thinking. I don't really like the syntax of it and how everything IsCamelCase
15:42:58 <lispy> DigitalKiwi: negative
15:43:06 <lispy> DigitalKiwi: is it also an Ogre3d construct?
15:43:09 <rizlah> Haven't really thought of Scala or Clojure
15:43:09 <DigitalKiwi> it was made by the same devs as torchlight
15:43:10 <EvanR-work> rizlah: uhoh, thats how it is in haskell too ;)
15:43:14 <rizlah> .
15:43:18 <pikhq> haskellDoesCamelCaseTooYouKnow
15:43:19 <napping> Haskell is much more interesting, but not quite as many libraries (or jobs)
15:43:31 * EvanR-work does haskell at work ;)
15:43:33 <lispy> DigitalKiwi: ah, what genre of game?
15:43:38 * jmcarthur has done some haskell at work
15:43:41 <jmcarthur> not a whole lot though
15:43:50 <ivanm> napping: maybe because we don't need as many libraries... ;-)
15:43:53 <DigitalKiwi> it started off as a testing ground for hellgate; london's networking and dungeon creation but evolved into a full game
15:43:57 <DigitalKiwi> same as diablo :)
15:44:01 <ivanm> since our libraries are in a central place so no need to re-invent the wheel
15:44:03 <DigitalKiwi> rather, same genre
15:44:11 <rizlah> Hmm, well I'm sort of looking for a language to stick to. I am fairly fluent in C so that is my 'main' language so to speak. Anyone have any suggestions?
15:44:13 <napping> The web and database stuff seems to be much better developed in Java
15:44:16 <rizlah> I sort of like the feel of haskell
15:44:18 <DigitalKiwi> not the started off ' ... ' part
15:44:24 <ivanm> and we have greater powers of abstraction so less need for specialised variants, etc.
15:44:24 <napping> the Haskell stuff is very cool, but kind of newish
15:44:24 <jmcarthur> rizlah: what will you be doing with it?
15:44:25 <gwern> rizlah: learn assembler?
15:44:26 <lispy> DigitalKiwi: heh, is that the only thing that team can make? :)
15:44:33 <DigitalKiwi> haha! maybe
15:44:35 <ivanm> napping: well, people have cared about web stuff for longer on Java
15:44:39 <jmcarthur> rizlah: will you be hoping to use this in a job or just hobby projects or academia, for example?
15:44:41 <DigitalKiwi> they're darn good at it, though!
15:44:51 <jmcarthur> rizlah: and what kind of things will you make with it?
15:44:57 <lispy> DigitalKiwi: yeah, they are
15:45:13 <DigitalKiwi> you play torchlight? and what is ogre3d >.>
15:45:23 <rizlah> gwern: I am already doing a little of that. jmcarthur I will be using it for general purpose applications, specific projects of mine (currently I'm writing the server side of a game (Starting to learn OGL for C))
15:45:53 <napping> rizlah: yes, the threading model is very good. A nice API, overhead around 200 bytes iirc, functional by default makes accidental bugs harder
15:45:56 <jmcarthur> rizlah: either will work, but haskell would be my go-to language for most things like that :)
15:46:15 <rizlah> Hmm, sounds fair.
15:46:46 <rizlah> Alright, I'll give Haskell a fair trial run :).
15:46:53 <rizlah> Any good links to get started with?
15:47:01 <gwern> @where rwh
15:47:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:47:04 <napping> You should also learn Haskell or a near relative so you have experience with at least one almost-decent type system.
15:48:02 <napping> I've only used STM for low-traffic things so I can't really speak for overhead, but it is very nice to program with
15:48:18 <rizlah> napping: Well, I'm going for haskell now. All the other languages seem broken in some way and Java just annoys me somehow. The library has stupid naming conventions, etc.
15:48:22 <zygoloid> if i'm cross-compiling from x86 to x86_64, in template haskell will CInt be 32 bits or 64 bits?
15:48:51 <mapreduce> rizlah: Naming conventions are the least of Java's problems.
15:48:51 <napping> zygoloid: try it and see?
15:49:14 <jmcarthur> STM can be faster for some things, typically for "complex" things, in my experience. fortunately, that also happens to be the case when its API is most called for! :)
15:49:47 <napping> jmcarthur: that's good to hear. I just wanted to be sure that if I got two concurrent users things wouldn't break (it was a limited class project)
15:50:26 <napping> rizlah: Oh, Haskell is hardly perfect, but it's at least going in a nice direction
15:50:35 <gwern> @quote ship
15:50:35 <lambdabot> OlinShivers says: As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
15:50:38 <mreh> say I'm using discreet sampling and the users computer is slow, and they're playing haskelloids. is it possible that a bullet could pass straight through an asteroid and out the other side in the time it takes to actuate and sense? could this be solved with continuous time FRP?
15:50:47 <jon_of_arc> For an associated type with a kind of, say, *->*, is there any way to give a context restricting the type that won't be coming from the class parameters?
15:50:49 <pikhq> What's particularly nice about STM is that you're not too likely to screw it up. Most other threading models will break *hard* if you don't get everything right.
15:51:21 <gwern> mreh: the continuous has to translate into discrete operations at some point, I think...
15:51:29 <napping> pikhq: do you know of any exceptions?
15:51:45 <mreh> gwern, yeah, computers are discreet entities
15:51:56 <napping> MVars seem at least to make it hard to access data without the proper lock
15:52:03 <gwern> mreh: no! they aren't discreet! they'll blabl all your screts the first time someone asks properly
15:52:13 <pikhq> napping: Uh. Message-passing doesn't *break* until you start using it as an implementation for more mundane primitives?
15:52:20 <gwern> security is hard because computers are indiscreet - like children
15:52:30 <pikhq> And MVars at least do that, yes.
15:52:52 <mreh> gwern: I have a neurosis about my imprecise spelling, you're making to worse
15:53:10 <mreh> s/to/it
15:53:15 <zygoloid> napping: huh. turns out ghc can't cross-compile :o
15:53:20 <napping> oh, ok.
15:53:27 <gwern> zygoloid: no one told you that?
15:53:38 <gwern> you gotta bootstrap ghc and compile it there
15:53:44 <zygoloid> gwern: yeah, so i see.
15:53:51 <mreh> gwern: conal doesn't like that argument anyway
15:54:07 <rizlah> napping: What are some of Haskell's problems?
15:54:08 <mreh> I've yet to really understand how his ideas might work
15:54:12 <gwern> zygoloid: one of the very few selling points of jhc is that it spits out c so you can crosscompile that instead
15:54:22 <gwern> mreh: performance seems to be a perennial issue with conal's stuff
15:54:23 <napping> there's .hc files
15:54:39 <zygoloid> gwern: interesting. i'm not sure how that affects my TH question :/
15:54:54 <gwern> I prefer TG, template ghc
15:55:12 <zygoloid> is that a real thing?
15:55:16 <shadwick> hi, random question: does the GHC generate C-- code for compilation or something?
15:55:18 <gwern> it was a joke
15:55:40 <gwern> to indicate that no other compiler does TH and likely never will
15:55:41 <mreh> oh, HAHAHA
15:56:18 <gwern> shadwick: iirc, it generates regular c code - I never was clear on what happened to c-- research except that it was never very successful
15:56:38 <shadwick> gwern: ah, I was under the impression that it used C-- as an intermediate language
15:56:39 <gwern> mreh: a trifle too loud
15:56:47 <danharaj> Is TH that hard or is it just not perceived as essential to a haskell package?
15:57:03 <napping> rizlah: as far as actual flaws, the record system and lack of ML-style modules are not so nice. As far as incompleteness, there's lots of research on making types easier to use or more powerful that isn't integrated.
15:57:21 <shadwick> because apparently parts of the runtime are in C and C--...
15:57:33 <Olathe> > execState (do { r <- get; return $ r + 100 }) 5
15:57:34 <lambdabot>   5
15:57:38 <gwern> danharaj: that hard. the few people working on non-ghc ocmpilers have other things to deal with
15:57:46 <gwern> (heck, TH itself sucks)
15:57:50 <danharaj> heh
15:57:50 <Olathe> Why doesn't that produce 105 ?
15:58:04 <rizlah> Ahh, so the incompleteness will creep up with compiler versions while the record system and ML style modules are actually recognised as flaws? Could you elaborate on the record system and the modules?
15:58:07 <danharaj> Is TH like templates in C++ or what?
15:58:21 <rizlah> s/incompleteness/incompleteness upgrades
15:58:32 <napping> Olathe: Isn't exec the one that returns the state? I think you want evalState
15:58:40 <Olathe> > evalState (do { r <- get; return $ r + 100 }) 5
15:58:41 <lambdabot>   105
15:58:44 <Olathe> Ahh, thanks :)
15:59:04 <lispy> danharaj: it's more like generic programming.  You're telling the compiler to generate code at compile time and things like that.
15:59:17 <lispy> danharaj: it's an example of  staged computing
15:59:22 <gwern> > execState (do { r <- get; r <- r*r; return () }) 5
15:59:22 <lambdabot>   Occurs check: cannot construct the infinite type:
15:59:23 <lambdabot>    s = Control.Monad.Stat...
15:59:29 <lispy> danharaj: it's probably more like lisp macros than C++ templates
15:59:31 <gwern> > execState (do { r <- get; set r*r; return () }) 5
15:59:32 <lambdabot>   Not in scope: `set'
16:00:04 <lispy> danharaj: Haskell's parametric polymorphism is closer to C++ templates for the way both are typically used
16:00:16 <danharaj> lispy: Well C++ templates are exactly what you just said, they generate code at compile time.
16:00:37 <napping> rizlah: well, modules are pretty basic. You just declare a module exporting some names or import some names from another module. ML has module signatures - with can hide implementation details, and modules parameterized over other modules
16:00:41 <danharaj> lispy: But I get you when you say they're more like lisp macros.
16:00:48 <Olathe> > execState (do { r <- get; put r*r; return () }) 5
16:00:49 <lambdabot>   Occurs check: cannot construct the infinite type:
16:00:50 <lambdabot>    s = Control.Monad.Stat...
16:00:58 <Olathe> > execState (do { r <- get; put (r*r); return () }) 5
16:00:59 <lambdabot>   25
16:01:11 <tensorpudding> How hard would it be to extend Haskell with module signatures?
16:01:31 <lispy> danharaj: the main power of TH is that you can look at  the AST of your program and do something with it.  It's like programming the compiler
16:01:49 <napping> It doesn't seem like it should be that hard, but it apparently takes lots of formal work to make the ML one wokr
16:01:56 <lispy> danharaj: the fact that C++ templates generate code at compile time is almost an implementation detail by comparison
16:02:41 <napping> like, if M exports a type rep = int, and then you seal it under a signature S that just declares an abstract type rep, you have to make sure (M:S).rep isn't considered equivalent to int outside the module, but is inside it
16:03:11 <rizlah> Hmm
16:03:34 <lispy> danharaj: when you have parametric polymorphism, laziness and algebraic datatypes, then most of the intended uses of C++ templates are subsumed by a less ad-hoc system
16:03:36 <danharaj> lispy: While I agree that C++ templates weren't originally intended to support metaprogramming, they can do it. It's probably exorbitantly harder than in TH but I would not be surprised if they could manage the same behaviors.
16:04:29 <lispy> danharaj: yeah, the full power of C++ templates needs something that is equally powerful in the formal sense, so in that regard you do need TH to meet it in terms of potential
16:04:34 <ville> and it's about time they'd move with the whole metaprogramming and make an actual DSL for it.
16:04:44 <lispy> danharaj: C++ is ... complex :)
16:05:10 <danharaj> lispy: no kidding. They really should add ADT's though.
16:05:23 <copumpkin> ADTs are too separate from the machine model!
16:05:25 <copumpkin> ;)
16:05:28 <napping> rizlah: Most languages out there have something equivalent to or weaker than Haskell modules anyway.
16:05:42 <aavogt> the haskell module system napping?
16:06:03 <napping> aavogt: yeah, I guess I'm thinking of Java mostly
16:06:07 <c_wraith> haskell modules are quite weak.
16:06:08 <rizlah> napping, what about the record system? what is that
16:06:46 <lispy> danharaj: I think the entire STL could be implemented in Haskell 98 though.  I would assume that, but maybe you need a few extensions.  I would be shocked if you needed TH though.
16:06:51 <napping> rizlah: pretty much just a little syntactic sugar. You can name fields of a constructor and use some fancy syntax, but it's pretty much just generating accessors for the positional fields
16:07:08 <aavogt> but with TH and/or fancy typeclass usages, you can get reasonable records
16:07:19 <danharaj> lispy: C++ template polymorphism breaks parametricity
16:07:27 <copumpkin> well, c++ has type families built in
16:07:29 <napping> In particular, field names are not disambiguated by the type of the record or something.
16:07:34 <rizlah> I see, so it is not required at all?
16:07:48 <ddarius> danharaj: It's not that it breaks parametricity, it is that it doesn't claim to provide it in the first place.
16:07:53 <napping> It's ocassionally handy, but entirely optional.
16:08:05 <danharaj> ddarius: well yeah pff semantics
16:08:17 <lispy> danharaj: because with C++ templates you only need to instantiate as much as you use?
16:08:29 <napping> There's nice reasearch out there about letting you make anonymous record types, extend and remove record fields, pass around labels as first class values, and so on
16:08:48 <napping> So it's kind of annoying we just have a simple system.
16:08:52 <lispy> danharaj: if so, I'll claim that in Haskell we only have to evaluate as much as we use :)
16:08:55 <danharaj> lispy: Partial template specialization.
16:09:05 <danharaj> lispy : well, template specialization in general
16:09:07 <napping> well, weak is the annoying part more than simple
16:09:19 <rodrigoclira>  someone uses wxhaskell ?
16:09:24 <lispy> danharaj: ah yeah, I wonder how much of that would be worked around using newtype
16:10:08 <rizlah> Ahh, the good part is that it is optional. I either use things that work, or do not use them if they partially work. Partially the reason I do not use C++ much and haven't bothered learning Java
16:10:25 <EvanR> rizlah: record syntax works just fine
16:10:40 <EvanR> but only use it when its needed
16:10:48 <rizlah> Ah, I see
16:11:00 <lispy> Haskell is hard, let's go Java!
16:11:06 <EvanR> like, the structure has a lot of fields
16:11:07 <copumpkin>  mmm java
16:11:10 <copumpkin> everyone loves java
16:11:56 <lispy> Picking on Java is like picking on emo kids
16:12:02 <EvanR> haskell *is* hard.   hardCORE!
16:12:08 <copumpkin> lispy: very fun?
16:12:21 <copumpkin> omg it's edwardk
16:12:23 <lispy> copumpkin: see xkcd for explanation
16:12:23 * copumpkin hides
16:12:58 <lispy> copumpkin: http://xkcd.com/114/
16:12:59 <rizlah> Well, it has been good talking. I will be back tomorrow to do some reading. Thanks for the help.
16:13:01 <Cyclops_JC> good day all - if I can ask a really newbie question - the haskell tutorial at lisperati.com, does it still work with the latest version of GHC?
16:13:22 * copumpkin makes fun of computational linguists too
16:16:06 <edwardk> omg its copumpkin!
16:16:13 <copumpkin> (I'm hiding)
16:16:17 <pikhq>  It's like a pumpkin but co!
16:16:27 <edwardk> my wife is a computational linguist and i used to work with them and i still make fun of computational linguists ;)
16:16:42 <copumpkin> damn right
16:17:01 * copumpkin is almost a quitter
16:17:12 <napping> It looks like it should still work
16:17:14 <copumpkin> very close to being an official one
16:17:17 <edwardk> except maybe cc shan, and koninkje, and a few others ;)
16:17:27 <copumpkin> cc shan is a linguist?
16:17:31 <napping> There is the Haskel 98 standard which will be supported for quite a while
16:17:46 <napping> and it looks like the code sticks to it
16:18:12 <jmcarthur> mreh: yes, a continuous model would prevent that from happening. you are right, of course, that if the implementation works by sampling and samples too coarsely then it could miss it
16:18:27 <c_wraith> Haskell 98 is kind of limiting, though.  Sometimes extensions were added because they provide something *really* useful.
16:18:29 <Cyclops_JC> napping, I can't get the line people_text <- readFile "foo.txt" to work - I also tried "c:/xxx/foo.txt", is there something special for naming files?
16:18:39 <edwardk> copumpkin: Monads for natural language semantics, the partition semantics of questions, syntactically, delimited continuations in natural language....
16:18:43 <napping> that should work just fine
16:19:02 <napping> well, C:/ isn't right because windows wants backslashes
16:19:14 <Cyclops_JC> it gives me an error message, "the last  statement in a 'do' construct must be an expression
16:19:14 <copumpkin> edwardk: where can I find more? I'm actually very interested in linguistics, despite making fun of its practitioners
16:19:22 <edwardk> http://www.cs.rutgers.edu/~ccshan/
16:19:24 <napping> oh, then something is messed up
16:19:30 <napping> like, in your formatting
16:19:31 <pikhq> copumpkin: They're easy to make fun of. :)
16:19:41 <napping> that shouldn't be the last line
16:19:44 <hpc> the last time i had to do file IO on windows was Java, but i didn't have to use backslashes there
16:19:45 <edwardk> computational linguists are like academic furries ;)
16:19:45 <EvanR> Cyclops_JC: is the last statement a x <- foo
16:20:09 <copumpkin> I didn't even realize cc shan was into that stuff. I've only seen a few things by him and they didn't seem too close
16:20:15 <napping> "paste this at the bottom of the program"
16:20:17 <Cyclops_JC> yes, I typed in the whole section in the tutorial with readFile, it failed, so I deleted all the lines but that - possibly a mistake
16:20:32 <jmcarthur> gwern: conal's frp implementations tend to be on the slow side, but he also tends to not care about performance so much, so that's to be expected
16:20:42 <EvanR> Cyclops_JC: the last line must be something like return x
16:20:43 <edwardk> nah about half the stuff we've talked about over the years has been linguistics related
16:20:48 <copumpkin> interesting
16:20:48 <EvanR> or f x
16:20:48 <napping> the readFile line has to go as part of the do block from the previous page
16:20:56 <copumpkin> I see now that I actually visit his official
16:20:57 <napping> and all those lines indented to line up with the putStr
16:20:57 <copumpkin> page
16:21:11 <Cyclops_JC> hmm, napping, when I tried backslashes, I got a different error message :) which slash type should I use on Windows?
16:21:25 <EvanR>  /
16:22:53 <Cyclops_JC> okay, I have repasted all the lines as listed in the tutorial at lisperati.com/haskell, page 2, which includes a readFile and 'print', but no 'return'
16:23:36 <Cyclops_JC> napping, indentation matters? what about under the 'let'?
16:24:50 <Cyclops_JC> hm, you're right - I changed indentations to 4 spaces (not 2), and it worked... it's that sensitive?
16:26:05 <napping> Cyclops_JC: if you don't use explicit {;} symbols, then grouping is based on lining things up
16:26:22 <napping> inside do, let, and case, which is where it matters
16:26:36 <dmwit> also where
16:26:36 <Cyclops_JC> napping, they were lined up, just using two spaces (as the tutorial .pdf seems to show, it's hard to tell).
16:26:52 <dmwit> literal tabs pad to the nearest eighth column
16:27:01 <napping> two spaces lines up with the print and stuff in the do, you probably need more to line up inside the let
16:27:15 <napping> oh, and I really wouldn't try to copy from a pdf
16:27:23 <napping> at least if spacing matters
16:27:41 <napping> darn things ommit whitespace enitrely sometimes
16:28:20 <Cyclops_JC> well, the HTML looks the same, but again it doesn't explicitly say how many spaces things are indented. anyway, four spaces worked, thanks.
16:29:15 <napping> Copying from the pre blocks should work
16:29:17 <Cyclops_JC> hm, I take it back - it has two spaces on the first line after the 'main = do', but four spaces after the 'let' wups. :)
16:29:23 <napping> yep.
16:29:59 <napping> The indentation gets set at the column of the first token after the do let or case, whether that's on the same line or not
16:30:14 <dmwit> or where
16:30:33 <Cyclops_JC> ah, so if the 'let' statement itself was four spaces - lines under it should be eight spaces?
16:30:39 <napping> after that, any line starting at that exact indentation begins a new statement (let binding, do command, or case pattern), anything deeper is just a continuation of the previous line, and anything less indented ends the whole group
16:30:46 <dmwit> or where clause
16:30:51 <dmwit> yeesh
16:30:56 <napping> not quite. If it's "let foo =" starting four columns in, then it's 8 to line up with the foo
16:31:10 <napping> but if it's like "    let\n     foo = 1", then it would be 5 to line up
16:31:15 <Cyclops_JC> ah! it actually has to match the token 'foo'
16:31:19 <Olathe> @hoogle a -> Maybe a -> a
16:31:19 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
16:31:19 <lambdabot> Prelude asTypeOf :: a -> a -> a
16:31:19 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
16:31:28 <napping> or it could be like "let  foo =" and then it would be 9
16:32:06 <Cyclops_JC> okay, I have to pay more attention to whitespace. :) Thanks, napping
16:32:55 <Cale> Cyclops_JC: Yeah, it's particularly important to configure your editor to insert spaces and not physical tabs
16:33:12 <Cale> (or else things can be deceiving)
16:33:38 <Cyclops_JC> Cale, currently using notepad and spacebar :)
16:35:35 <EvanR> sorry to hear that
16:40:22 <napping> Has anyone hear read the "very modal model" paper by Appel et. al?
16:42:46 <ddarius> napping: Probably.  I may have read it.  I know of it at least.
16:43:47 <napping> It seemed pretty nice, but I don't see how it would support strong update (or verifying a memory allocator)
16:46:46 <napping> huh, it's cited by the realizeablity model paper for Ynot. I guess I should try to make more sense of that one
16:47:02 <napping> cause Ynot sure supports strong updates!
16:49:17 <ben_m> Greetings :) I have a string t = "foo   5" (variable whitespace between string and number). I want to read both the string and the number (as an Int) into variables, what would be the cleanest way?
16:49:38 <ben_m> "foo   5" -> (String, Int) so to speak
16:49:38 <EvanR> > words "foo   5"
16:49:39 <lambdabot>   ["foo","5"]
16:49:46 <ben_m> Well
16:49:58 <ben_m> I'm stupid for not thinking of that.
16:50:01 <ben_m> Thanks :)
16:50:06 <EvanR> > read ((words "foo   5") !! 0) :: String
16:50:07 <lambdabot>   "*Exception: Prelude.read: no parse
16:50:23 <EvanR> > read "fo" :: String
16:50:24 <lambdabot>   "*Exception: Prelude.read: no parse
16:50:34 <napping> > read "\"foo\""
16:50:35 <lambdabot>   *Exception: Prelude.read: no parse
16:50:35 <ddarius> > read "\"foo\""
16:50:36 <lambdabot>   *Exception: Prelude.read: no parse
16:50:45 <napping> > read "\"foo\"" :: String
16:50:46 <lambdabot>   "foo"
16:50:52 <hpc> > (\(x:y:xs) ->(x, y)) $ words "foo   5"
16:50:53 <lambdabot>   ("foo","5")
16:51:04 <hpc> > (\(x:y:xs) ->(x, read y::Int)) $ words "foo   5"
16:51:05 <lambdabot>   ("foo",5)
16:51:11 <napping> just keep the string pieces without read-ing them, unless they really do have quotes to strip
16:51:52 <EvanR> ben_m: careful because read will crash if "5" cant be converted
16:52:08 <ben_m> yeah obviously :)
16:52:25 <EvanR> safeRead ;)
16:54:41 <napping> might be time to get a parser, even for something that simple
16:55:09 <napping> well, if it's supposed to be a real program. I write that sort of stuff in scripts all the time
16:55:20 <ben_m> wow
16:55:24 <EvanR> yeah, parsec
16:55:37 <ben_m> @pf '\s:n:_ -> (s, read n::Int)'
16:55:38 <lambdabot> Maybe you meant: bf pl
16:55:43 <ben_m> @pl '\s:n:_ -> (s, read n::Int)'
16:55:43 <lambdabot> (line 1, column 1):
16:55:43 <lambdabot> unexpected "'"
16:55:43 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:55:48 <ben_m> huh.
16:55:58 <hpc> @pl (\(x:y:xs) ->(x, read y::Int))
16:55:58 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (. ((:: Int) . read)) . (,) . head) tail
16:56:02 <hpc> eek
16:56:03 <ben_m> Yes that.
16:56:05 <ben_m> Hilarious :D
16:56:24 <hpc> <3 pointless form
17:01:07 <mreh> pointless, heh
17:01:39 <hpc> what else would @pl stand for?
17:01:48 <ben_m> I always thought it's pointfree
17:01:54 <ben_m> not actually pointless :D
17:02:02 <hpc> it is, but pointless is the funnier colloquial term
17:02:06 <ben_m> indeed
17:02:09 <lispy> ah, pointless code transformatinos
17:02:15 <lispy> transformations*
17:02:35 <ben_m> I thought Haskell was impractical for a while because I tried using pointfree code for everything
17:02:41 <vmixey> heh
17:02:46 <ben_m> Just because it's more elegant and stuff
17:02:50 <ben_m> And because everyone did it ._.
17:02:55 <vmixey> is it more elegant
17:03:05 <ben_m> And I avoided do
17:03:06 <c_wraith> it's more elegant only when it's more elegant
17:03:17 <ben_m> Which probably taught me a lot, but is not very practical.
17:03:26 <hpc> i only use pointfree when doing straight function composition
17:03:35 <hpc> if i need to specify a parameter, i specify them all
17:03:41 <c_wraith> @pl f g h i j k l m n o p q r s t u = f u t s r p q o n l m g h i k j
17:03:45 <lambdabot> f = fix ((((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .)
17:03:45 <lambdabot>  .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .
17:03:45 <lambdabot> ) .) .) .) .) .) .) .) .) .) .) .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .)
17:03:45 <lambdabot>  .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .)
17:03:45 <lambdabot>  .) .) .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .)
17:03:47 <lambdabot> [8 @more lines]
17:03:49 <lambdabot> optimization suspended, use @pl-resume to continue.
17:03:49 <ben_m> oh god.
17:03:51 <hpc> jesus holy moly
17:03:52 <c_wraith> elegant!
17:03:58 <copumpkin> that one is fairly elegant
17:03:59 <dolio> I guess you won't be using factor and the like.
17:04:09 <copumpkin> I like it
17:04:13 <ben_m> I like Factor :)
17:04:27 <dolio> Factor is entirely pointless, though.
17:04:33 <copumpkin> :t let  f g h i j k l m n o p q r s t u = f u t s r p q o n l m g h i k j in f
17:04:34 <lambdabot> forall t t1 t2 t3. t -> t -> t1 -> t -> t -> t -> t -> t2 -> t -> t -> t -> t -> t1 -> t -> t -> t3
17:04:49 <copumpkin> wow, only 4 types
17:04:53 <lispy> c_wraith: that should spell something
17:05:28 <GonzoChurch> banbog
17:05:31 <GonzoChurch> s/g/t
17:05:38 <c_wraith> copumpkin: it's because it's recursive, so many of the args have to be the same type.
17:05:46 <pikhq> copumpkin: Well, the fact that it's recursive really limits things.
17:05:47 <copumpkin> c_wraith: yeah, I see
17:06:03 <lispy> ?pl o m g w t f b q = o m g w t f b b q
17:06:04 <lambdabot> o = fix (flip flip id . ((flip . ((flip . ((flip . ((flip . (ap .)) .)) .)) .)) .))
17:06:34 <lispy> :t let o m g w t f b q = o m g w t f b b q
17:06:35 <lambdabot> <no location info>:
17:06:35 <lambdabot>     not an expression: `let o m g w t f b q = o m g w t f b b q'
17:06:49 <copumpkin> :t let o m g w t f b q = o m g w t f b b q in o
17:06:50 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
17:06:50 <lambdabot>     Probable cause: `o' is applied to too many arguments
17:06:50 <lambdabot>     In the expression: o m g w t f b b q
17:06:53 <copumpkin> failispy!
17:07:09 <lispy> oh, I forgot the in o
17:07:28 <aavogt> there are more parameters when you make the recursive call
17:07:40 <lispy> yeah, is that a problem? ;)
17:07:45 <aavogt> yes
17:07:56 <aavogt> since then you end up with an infinite type
17:08:06 <c_wraith> does haskell have a flag to allow infinite types?
17:08:07 <aavogt> @type let f x = f x x in f
17:08:07 <lispy> :t let foo o m g w t f b q = o m g w t f b b q in foo
17:08:08 <copumpkin> you need a variadic function with dependent types
17:08:08 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. (t -> t1 -> t2 -> t3 -> t4 -> t5 -> t5 -> t6 -> t7) -> t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7
17:08:08 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
17:08:08 <lambdabot>     Probable cause: `f' is applied to too many arguments
17:08:08 <lambdabot>     In the expression: f x x
17:08:15 <vmixey> c_wraith: no
17:08:23 <copumpkin> c_wraith: I've asked for it in a reddit thread :P but you wouldn't just want a flag
17:08:25 <vmixey> you have to do it manually
17:08:30 <copumpkin> in fact, it was vmixey's reddit thread
17:08:51 <kmc> c_wraith, no haskell implementation has it to my knowledge
17:09:03 <danharaj> infinite types :o
17:09:21 <kmc> but you can effectively work with infinite types by wrapping / unwrapping
17:09:25 <edwardk> c_wraith fraid not. turns out that if you turn off the occurs check then everything gets a type, even stupid things =)
17:09:27 <kmc> @src Mu
17:09:28 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
17:09:33 <c_wraith> I remember reading that some ML could be told to accept infinite types, but it had the side effect of resulting in type errors being almost impossible
17:09:39 <copumpkin> rectypes
17:09:45 <edwardk> c_wraith: yeah
17:09:49 <dolio> OCaml can do it.
17:10:03 <dolio> jdh was claiming it as a serious advantage for OCaml a while back.
17:10:11 <kmc> dolio, haha
17:10:16 <copumpkin> edwardk: do you think they could be kept separate though? as in that reddit proposal I wrote?
17:10:24 <aavogt> it has larger types oO
17:10:26 <copumpkin> hey, if you need to work with all the magic morphisms, it helps!
17:10:38 <copumpkin> wrapping and unwrapping is no fun
17:10:43 <edwardk> copumpkin: i'm dubious ;)
17:10:56 <copumpkin> edwardk: boo hoo
17:11:02 <lispy> There was a thread on Haskell-Cafe about a year ago about allowing infinite types and someone wrote a little H-M type inferencer that allowed them
17:11:13 <dolio> It'd probably not be so bad if you never inferred them.
17:11:15 <edwardk> yeah that is the thread i mentioned
17:11:30 <copumpkin> ah
17:11:36 <edwardk> er meant
17:11:39 <dolio> That is, occurs check works as normal if you don't specify a type signature.
17:12:10 <aavogt> is this check actually called  "occurs check"
17:12:15 <vmixey> yes
17:12:20 <edwardk> aavogt: yes
17:12:26 <edwardk> aavogt: the name comes from prolog
17:12:34 <napping> I think ocaml only allows recursion though object types, because otherwise it's a huge mess
17:12:34 <Berengal> How would you specify an infinite type in the type signature?
17:12:41 <copumpkin> Berengal: a type synonym
17:12:41 <gio> hii
17:12:44 <dolio> > let f (x:xs) = xs ; f [x] = x in f
17:12:44 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
17:13:04 <napping> There's a nice slide somewhere with about three obvious typos in a simple "map" function, all of which can be typed with infinite  types
17:13:22 <napping> like that above, it would get an infinite list type if allowed
17:13:27 <dolio> Berengal: You could also add mu to the type language.
17:13:34 <copumpkin> moo
17:13:42 <Berengal> dolio: That's what I thought as well
17:13:59 <Berengal> But couldn't you get type lambdas that way?
17:14:22 <dolio> I don't think so...
17:15:26 <Berengal> Maybe not...
17:16:11 <dolio> It'd just be another variable binder, similar to forall.
17:16:27 <kmc> is there a standard package for passing a type without passing a value? something standard equivalant to data Proxy a = Proxy ?
17:16:38 <edwardk> kmc: Data.Tagged
17:16:40 <vmixey> I don't know why you even want htat
17:16:41 <kmc> thanks
17:16:45 <copumpkin> vmixey: phantom types?
17:16:46 <vmixey> Here's what I do:  __ = __
17:16:47 <edwardk> http://hackage.haskell.org/packages/archive/tagged/0.0/doc/html/Data-Tagged.html
17:16:58 <vmixey> then prefix  a -> ...
17:17:03 <edwardk> i needed it for reflection so i put it in a separate package
17:17:06 <copumpkin> ph33r the ph4nt0m
17:17:08 <vmixey> so you can pass types as values aroud now:    f (__ :: Integer) ....
17:17:13 <dolio> Berengal: I mean, you can make a Mu type constructor today that does the same thing, but requires (un)wrapping at the value level.
17:17:21 <dolio> And it doesn't turn into type lambdas.
17:17:23 <vmixey> Why make it more complicated?
17:17:37 <edwardk> and with 'reflection' you can even cram an actual value in the tag ;)
17:17:55 <dolio> The difference is that you write "Mu F" instead of "mu x. F x".
17:18:14 <copumpkin> point-free!
17:18:30 * copumpkin wonders what he should learn next
17:18:49 <EvanR> is it better to use fromIntegral or fromEnum
17:18:53 <edwardk> the type level mu would likely interact poorly with typeclasses, etc, same as forall, exists. etc. are invisible to that machinery.
17:19:06 <edwardk> @type fromIntegral
17:19:07 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:19:14 <dolio> Yeah, true.
17:19:16 <EvanR> to get an Int
17:19:30 <edwardk> to get an Int? fromEnum is probably better
17:19:36 <edwardk> assuming you have both
17:19:40 <danharaj> I wish you could make instances for polymorphic types :|
17:19:41 <mike-burns> Which Haskell Web development framework is the hot one these days?
17:19:55 <gio> gerl
17:20:28 <copumpkin> by the way, does category theory have any nice way of viewing the convolution theorem? saying that multiplication in frequency domain is equivalent to convolution in time domain
17:20:55 <edwardk> fromIntegral does fromInteger . toInteger, which tags it temporarily with an constructor, it probably gets optimized away but why worry?
17:21:53 <edwardk> copumpkin: the safe answer is that there is a category theoretic way to view everything.... not sure if its nice though ;)
17:21:58 <copumpkin> :P
17:22:41 <kmc> vmixey, so that you can't make the function non-parametric
17:22:42 <danharaj> Isn't it just that fourier transforms are homomorphisms of some algebraic structure?
17:22:54 <vmixey> huh?
17:23:06 <sbahra> Hi edwardk!
17:23:13 <sbahra> I've been trying to catch you.
17:23:19 <edwardk> heya samy
17:23:19 <sbahra> Do you have a minute?
17:23:22 <edwardk> sure
17:23:24 * copumpkin hands sbahra a lasso
17:23:28 <kmc> vmixey, if you do (a -> b) where it's not supposed to depend on the value of "a"
17:23:35 <kmc> then you're not enforcing that requirement
17:24:02 <kmc> even if it's an unconstrained type variable, you could still evaluate it, which would crash in your case
17:24:12 <vmixey> I don't think that applies to my case
17:24:15 <kmc> if you do data Proxy a = Proxy then you know that the value is uninformative
17:24:34 <Cale> Yeah, they're almost ring homomorphisms.
17:24:44 <Cale> rng homomorphisms
17:25:02 <kmc> vmixey, example: Foreign.Storable.sizeOf is not supposed to depend on the value passed, but could easily do so
17:25:03 <danharaj> There's probably some generalization of the convolution theorem.
17:27:18 <Cale> The only problem with it being a ring homomorphism is that there's no identity for convolution in L^1(R)
17:27:35 <Cale> But if you don't require rings to have an identity, then it's fine
17:27:50 * copumpkin is liberal, it's fine
17:35:55 <temoto> How to extract/use/pattern-match value from thing like 'Just x' in expression?
17:36:14 <copumpkin> > let f (Just x) = x in f (Just 5)
17:36:15 <lambdabot>   5
17:36:30 <Cale> case ... of Just x -> ... use x here; Nothing -> ...
17:36:52 <temoto> I have data type with one constructor...
17:37:11 <copumpkin> you could unsafeCoerce it and cross your fingers that you used a newtype
17:37:26 * copumpkin goes back to /r/shittyadvice
17:37:28 <Cale> > case lookup 2 (zip [0..] (words "hello there world")) of Nothing -> "oops"; Just x -> reverse x
17:37:28 <lambdabot>   "dlrow"
17:37:35 <kmc> temoto, it works with one ctor too
17:37:53 <kmc> "case" is the general way to patern-match values
17:38:09 <kpreid> or you can use lambdas
17:38:21 <kpreid> (\(Just x) -> x) (Just 5)
17:38:24 <kpreid> > (\(Just x) -> x) (Just 5)
17:38:25 <lambdabot>   5
17:39:15 <kmc> "case" is usually preferable
17:41:04 <hpc> what's the consensus on using case instead of if-then-else?
17:41:24 <hpc> i think it is more readable and less ridiculously indented
17:41:52 <copumpkin> I'm not a fan of if blocks
17:41:55 <copumpkin> but they have their moments
17:41:57 <danharaj> I use if then else when I'm too lazy to indent.
17:43:08 <Philippa> translating imperative code would be one of their moments
17:43:15 <temoto> So case worked out great, thanks.
17:43:34 <Philippa> case is better if you had a series of nested if /else if/ ...
17:43:37 <temoto> But then i need to fight IO again. Can't imagine where to insert a liftM thing.
17:43:41 <Philippa> (because you can just use guards)
17:47:23 * hackagebot rangemin 2.1.3 - Linear range-min algorithms.  http://hackage.haskell.org/package/rangemin-2.1.3 (LouisWasserman)
17:48:31 <temoto> http://codepad.org/449ly9OZ here's code with context and error
17:52:31 <siracusa> temoto: The result of h2 has type IO NeuronLayer, wheras countTrue expects a list as input
17:53:33 <temoto> siracusa, i understand that very well.
17:53:48 <temoto> how to solve it?
17:54:52 <siracusa> temoto: You can wrap countTrue in IO by `do { (Layer list) <- hs; countTrue list; }'
17:54:58 <ben_m> Using the state monad makes my head hurt :/
17:55:31 <k23z__> are  you guys aware of this language called Pure ?  http://code.google.com/p/pure-lang/
17:55:32 <temoto> siracusa, thanks.
17:55:51 <k23z__> I want to write symbolic computation in Haskell like those guys are doing in Pure..
17:56:53 <pelotom> dynamic typing? bleh
17:57:18 <k23z__> I want to write something like this http://i.imgur.com/BBfC5.png
17:57:35 <k23z__> it's an excerpt from Pure's manual
17:57:39 <k23z__> can I do that as easily in Haskell ?
17:57:49 <k23z__> because I don't want to use Pure for many different reasons
17:59:01 <jmcarthur> well, ghc does allow you to specify rewrite rules for its optimization passes, but i'm thinking that's not quite what this is
17:59:48 <k23z__> jmcarthur, why do optimization passes matter here ?
17:59:51 <ben_m> I have two sets of strings. I'm reading a file of such strings which I put in one of the two sets, based on whether the string already is in one ore both of the sets. What would I use for that? State monad, because I'm both reading and writing?
18:00:41 <jmcarthur> k23z__: well, i don't really know what it is that that pure code is doing. clearly i'm on the wrong track
18:00:54 <k23z__> jmcarthur, it's very simple
18:01:05 <k23z__> jmcarthur, those variables are actually mathematical expressions
18:01:08 <jmcarthur> k23z__: ghc allows you to tell the optimizer how to rewrite certain patterns in the code for efficiency
18:01:27 <k23z__> jmcarthur, and it's expanding a expression (a+b)*c into a*c + b*c
18:01:36 <jmcarthur> i follow that
18:01:41 <k23z__> jmcarthur, and the other one factors it back(the inverse of the operation expand)
18:01:43 <jmcarthur> but is that some sort of runtime thing?
18:01:55 <jmcarthur> okay, so are those just functions then?
18:02:20 <k23z__> jmcarthur, runtime yeah
18:02:33 <k23z__> jmcarthur, can I do that in Haskell ?
18:02:50 <jmcarthur> k23z__: only way i can think of to do that in haskell is to just use an ADT for the representation and define the functions over it
18:03:10 <k23z__> jmcarthur, so I can't ?
18:03:27 <k23z__> jmcarthur, I thought it had this stuff built-in ..
18:03:58 <jmcarthur> data Exp a = Pure a | a :+ a | a :* a
18:04:22 <jmcarthur> k23z__: you would use something like the structure i just wrote as the ADT and manipulate it that way
18:04:46 <jmcarthur> k23z__: if you could even instantiate that for Num and then you could create it with "normal" functions
18:05:05 <jmcarthur> s/if you/you/
18:05:24 <jmcarthur> *create expressions with normal functions, i mean
18:05:39 <k23z__> jmcarthur, normal functions = ?
18:05:43 <jmcarthur> the expand and factor functions would still be defined to pattern match over that ADT
18:06:20 <jmcarthur> k23z__: you could say something like this, for example:   expand ((1+2)*3)
18:06:38 <jmcarthur> k23z__: and you would get the ADT representing (1*3 + 2*3)
18:06:59 <jmcarthur> it wouldn't *literally* be that as code. you would then have to apply an interpretation function to it
18:07:43 <k23z__> what do you mean by interpretation function ?
18:07:49 <k23z__> one that would print it to the screen ?
18:07:56 <k23z__> or turn it into a string ?
18:07:58 <jmcarthur> i mean it quite literally. an interpreter
18:08:02 <jmcarthur> whichever you want
18:08:08 <jmcarthur> or something else, even
18:08:31 <jmcarthur> for example:
18:08:56 <jmcarthur> interpret (Pure x) = x; interpret (x :+ y) = x + y; interpret (x :* y) = x * y
18:09:07 <jmcarthur> so that interpreter simply computes the result of the expression
18:09:23 <jmcarthur> oh, it's wrong though
18:09:25 <jmcarthur> sorry
18:09:28 <jmcarthur> fixing...
18:09:44 <jmcarthur> interpret (Pure x) = x; interpret (x :+ y) = interpret x + interpret y; interpret (x :* y) = interpret x * interpret y
18:09:45 <jmcarthur> there
18:09:53 <vmixey> kind of funny, it doesn't look like it does anything
18:10:42 <jmcarthur> what do you mean? syntactically?
18:10:53 <vmixey> interpret (Pure x) = x; interpret (x :+ y) = x + y; interpret (x :* y) = x * y <-- that one
18:11:04 <temoto> ohh probability is a great thing
18:11:06 <jmcarthur> heh... well that was wrong :P
18:11:08 <vmixey> foldExp id (+) (*)
18:11:45 <jmcarthur> yeah foldExp would be handy
18:13:15 <copumpkin> wtf, is code.haskell.org down again?
18:13:53 <jmcarthur> k23z__: expand ((a :+ b) :* c) = (a :* c) :+ (b :* c); expand (a :* (b :+ c)) = (a :* b) :+ (a :* c)
18:14:36 <jmcarthur> k23z__: and you would add this to the end if you don't want it to be partial:    expand a = a
18:14:46 <k23z__> jmcarthur, in my particular case, I am not interested in the actual evaluated expression, just the expression itself
18:14:48 <jmcarthur> meaning if the patterns doesn't match just return the argument unchanged
18:15:01 <jmcarthur> k23z__: sure, then the interpreter could convert to a string or whatever
18:15:10 <k23z__> jmcarthur, I want to choose Haskell if it can allow me to manipulate the expression and do the following things:
18:15:25 <jmcarthur> k23z__: you could actually just derive Show if you don't mind seeing those colons in the output string
18:15:27 <k23z__> 1) simplify fractionas(aka rational expressions containing just +-*/ and sqrt() )
18:15:41 <jmcarthur> > 4%8
18:15:42 <lambdabot>   1 % 2
18:15:45 <k23z__> 2) simplify radicals
18:16:01 <vmixey> k23z__: try joining the #haskell-math project
18:16:08 <jmcarthur> well, you can do all those things in haskell. it's just a matter of how "directly" you want to do them
18:16:10 <k23z__> IOW I want to implement the functions ratsimp and radcan from Maxima CAS
18:16:12 <k23z__> in Haskell
18:16:28 <k23z__> vmixey, no, here it's fine
18:16:32 <vmixey> ??
18:16:32 <k23z__> vmixey, but thanks
18:16:40 <vmixey> what
18:17:29 <jmcarthur> k23z__: you can implement them. i just don't know whether you are wanting some particular syntax. if not, then haskell would be fine
18:17:51 <vmixey> *sigh*
18:19:21 <k23z__> vmixey, please next time when you refer me to a chanel, you need to know what that channel is about, thank you
18:19:59 <jmcarthur> k23z__: not sure that is called for
18:20:06 <Twey> Let me guess mathematical applications of Haskell?
18:20:47 <jmcarthur> Twey: #haskell-math is actually centered around a particular set of projects which will be intended to go together
18:20:49 <k23z__> jmcarthur, so what I'm actually doing is ruler and compass constructions in Perl, and the intersection points are expressions involving only  +-*/ and sqrt() , now I want to use Haskell to port the functions ratsimp and radcan from Maxima in it and get the expressions for Perl , simplify them in Haskell and give them back to Perl
18:21:12 <jmcarthur> k23z__: sure, you can do that
18:21:31 <k23z__> jmcarthur, does haskell by any chance have ready-made ratsimp() and radcan() ?
18:21:41 <jmcarthur> i don't even know what those are
18:21:53 <bremner> maxima functions?
18:21:54 <Twey> Maybe appropriate, then
18:21:58 <jmcarthur> so if they are readymade, they at least don't go by those names
18:22:06 <jmcarthur> Twey: yeah, but nothing is written yet
18:22:20 <k23z__> bremner, Maxima is a CAS
18:22:51 <bremner> k23z__: yes, I think I first used it when you were in diapers, what is your point? :)
18:22:55 <k23z__> jmcarthur, here you can find radcan http://maxima.sourceforge.net/docs/manual/en/maxima_7.html
18:23:18 <k23z__> jmcarthur, and here is ratsimp
18:23:26 <k23z__> just search for "Function: ratsimp (expr)"
18:23:32 <k23z__> "Function: radcan (expr)"
18:24:14 <k23z__> bremner, I think I was in diapers :) but now that I'm out of them I want to man up and implement ratsimp and radcan in Haskell
18:24:46 <GonzoChurch> lol bremmer is so old he's back IN diapers
18:25:01 <GonzoChurch> *bremner
18:25:01 <bremner> you promised not to talk about that.
18:25:08 <GonzoChurch> :D
18:25:50 <bremner> k23z__: the full symbolic versions?
18:25:57 <k23z__> bremner, all the way
18:26:14 * copumpkin needs a name for his new pet language
18:26:19 <vmixey> call it fido
18:26:22 <bremner> spot
18:26:25 <copumpkin> rover?
18:26:28 <copumpkin> hmm ok
18:26:43 <temoto> copumpkin, call it Go
18:26:53 <copumpkin> how about Come?
18:27:17 <ddarius> copumpkin: Only if it is a bastard hybrid of Go and Intercal.
18:27:19 <k23z__> copumpkin, how about Emerald ?
18:27:33 <copumpkin> k23z__: I think people might figure out the etymology of that too easily
18:27:40 <temoto> If you call it Go, you'll have an Issue 9 for free.
18:27:45 <k23z__> copumpkin, the how about Stick ?
18:28:12 <k23z__> copumpkin, no call it Bubble-Gum
18:28:14 <copumpkin> wombat-lang.org
18:28:16 <copumpkin> how about that
18:28:23 <copumpkin> ;)
18:28:49 <temoto> Awesome. I love funny animal names.
18:28:59 <bremner> chomsky would be a good name for a language
18:29:00 <copumpkin> http://en.wikipedia.org/wiki/File:Wombat-Narawntapu.jpg
18:29:17 <bremner> or Warhol
18:30:09 <copumpkin> hmm
18:30:22 <copumpkin> does anyone know why code.haskell.org keeps going down?
18:32:55 <vmixey> k23z__: Are you telling me I don't know what the channel is about?
18:33:27 <k23z__> vmixey, yes
18:33:36 <vmixey> okay then. bye
18:33:54 <edwardk> heya triton
18:34:15 <triton> hi :D
18:34:19 <copumpkin> hey hey, I just told triton this channel was one of the friendliest on the net
18:34:27 <copumpkin> y'all can't go and fight right after he joins
18:34:27 <triton> its packed lol
18:34:33 <Philippa> copumpkin: yep
18:34:34 <Pseudonym> triton, you suck.
18:34:41 <copumpkin> lol
18:34:42 <Philippa> triton: ASL? j/k
18:34:44 <k23z__> vmixey, bye
18:34:44 <triton> you too Pseudonym
18:34:45 <vmixey> I am not fighting I am just pissed off and double checking that I am justified in being so
18:34:56 * copumpkin gives vmixey a hug
18:34:59 <Pseudonym> Just our little way of saying "welcome".
18:35:09 <triton> what does ASL mean Philippa
18:35:10 <copumpkin> where hug = haskell user group
18:35:19 <dolio> @vixen a/s/l
18:35:19 <lambdabot> 19/f/California
18:35:30 <Philippa> triton: heh. "Age/Sex/Location". A way of being a little too "friendly" on IRC
18:35:33 <copumpkin> I always assumed the l stood for language
18:35:44 <Pseudonym> 36/m/Haskell
18:35:50 <triton> im a 20 year comp sci student from portugal
18:35:54 <blackdog> copumpkin: clearly, the international language of luuuuurve
18:35:55 <copumpkin> clearly I haven't been involved with much real a/s/l'ing
18:35:58 <copumpkin> mmmm
18:36:13 <Philippa> heh, you don't have to answer! But hi
18:37:14 <triton> edwardk and copumpkin just convinced me to learn haskell
18:37:18 <wli> I'm shocked that I'm not the oldest one here.
18:37:19 * copumpkin cheers
18:37:28 <Pseudonym> wli: shapr is older than me.
18:37:33 <triton> ive installed the haskell platform and tried some simple stuff before
18:37:38 <copumpkin> I'm sure there are older people too
18:37:46 <triton> but never really made my way learning it
18:38:05 <Philippa> Pseudonym: physically, anyway? I tend to picture him as around 15. In a cheerleader outfit.
18:38:15 <Philippa> well, not really, but figured I'd share the mental image :-)
18:38:18 <copumpkin> boing
18:38:31 <Pseudonym> Philippa: On a unicycle.
18:38:48 <k23z__> vmixey, can you chill out now and stop being so tense ?
18:39:00 <wli> Reminds me of George W. Bush's Yale photos.
18:39:03 * copumpkin initiates a group hug with k23z__ and vmixey 
18:39:05 <vmixey> yeah I'm fine
18:39:15 <copumpkin> wli: was coke involved?
18:39:23 <copumpkin> anyway, we should probably stop the banter and move to #haskell-blah :P
18:39:33 <wli> copumpkin: It must've been.
18:39:43 <Pseudonym> copumpkin: Yes, advertising of soft drinks should be done on -blah.
18:40:10 <copumpkin> :)
18:41:49 <m3ga> wli: i'm 47 :-)
18:41:55 <edwardk> Philippa: shape is just as hyperactive in person. You have to live with the mental image. i have physical images that would scar you for life. ;)
18:41:58 <edwardk> er shapr
18:42:59 <Philippa> edwardk: I've met him
18:43:47 * wli forgets who he's met.
18:44:01 <Philippa> admittedly you've spent rather more time with him than I have
18:44:48 <edwardk> Philippa: oh yeah, anglohaskell and all that
18:45:11 <Philippa> *nod*
18:45:19 <copumpkin> oh wow, hac phi is coming up
18:45:25 <Philippa> talking of which, I've had exactly zero response to the mail I sent out to -cafe about running one this year
18:45:29 <edwardk> copumpkin: yes, you're going right?
18:45:46 <Philippa> this is totally the wrong time of day to complain on IRC about it because those of us in the UK should be in bed, but...
18:45:48 <copumpkin> my lease expires on the 29th and I'm about to quit and move my life possibly around the world
18:45:50 <copumpkin> but I would like to go
18:46:09 <edwardk> i want to organize one for boston, since the one we were going to have never materialized after ravi moved off to singapore
18:46:10 <copumpkin> I thought it was later
18:46:12 <wli> I'll never meet anyone ever again anyway.
18:46:22 <copumpkin> edwardk: whoa, what's he doing in singapore?
18:46:34 <edwardk> copumpkin: bank stuff
18:46:38 <copumpkin> wli: I'll hunt you donw!
18:46:40 <copumpkin> down, even
18:48:30 <jon_of_arc> What's this happening in Boston now?
18:49:05 <copumpkin> edwardk: having a hac bos would be awesome though
18:49:18 <copumpkin> we could even hack bos's computer
18:50:20 <edwardk> copumpkin: i need to figure out the poll system he was using to schedule the next boston haskell meetup too
18:50:47 <edwardk> if i keep putting it off, i risk it coming off like one of his week before 'when would you like to have it?' emails =)
18:51:40 <copumpkin> :P
18:52:00 <jmcarthur> *sigh* i want to go to hac phi
18:52:18 <jmcarthur> but it's so expensive to fly up there just to hang out and code
18:52:20 <copumpkin> you're a poet and you don't know it
18:52:32 <copumpkin> depending on how you pronounce phi, that is
18:52:34 <jmcarthur> i could do that here. just not with haskellers
18:52:34 <ccasin> jmcarthur: but think of the fun! :)
18:52:46 <edwardk> try and get shapr to split a room with you or something ;)
18:53:12 <jmcarthur> my wife would want to come with, so we'd probably want a room without shapr :P
18:53:22 <copumpkin> jmcarthur: why??
18:53:26 <copumpkin> who wouldn't want to room with shapr
18:53:41 * jmcarthur imagines the awkwardness
18:53:47 <edwardk> my wife long ago learned to avoid going with me to conferences ;)
18:54:01 * jmcarthur gets an image of shapr riding a unicycle around in a hotel room...
18:54:13 <jmcarthur> edwardk: why is that?
18:54:20 <edwardk> he left his unicycle at home last time ;)
18:54:26 <jmcarthur> heh
18:54:26 <ddarius> copumpkin: phi = fee
18:54:43 <ddarius> edwardk: What do you do at conferences?
18:54:50 <edwardk> mostly because i stay out all night coding and talking to people, then stay up until 3am coding in the room, etc.
18:54:52 <copumpkin> ddarius: I pronounce it that way sometimes :)
18:55:37 <jmcarthur> edwardk: sounds like what my wife is used to me doing anyway
18:56:11 <edwardk> that way she doesn't have to feel ignored, and when i come back i can lavish attention on her and not have to begrudge her the time i spend with her when i'm on the trip
18:56:32 <vmixey> ddarius?? fee? :( I like fie
18:56:39 <copumpkin> fie, fie!
18:56:56 <vmixey> maybe the spanish pronounce it 'fho'
18:57:21 <copumpkin> perhaps I should move to the library
18:57:26 <edwardk> however i need to bank some wife points before hac phi, so i'm going to go watch some tv with her ;)
18:57:34 <copumpkin> wife points!
18:57:43 <Pseudonym> fee fie fho phum
18:57:50 <k23z__> edwardk, so you're some sort of a hacker ?
18:58:03 <copumpkin> k23z__: the l33test of all hax0rz
18:58:10 * edwardk is l33t
18:58:37 <copumpkin> k23z__: this channel is full of hax and hax0rz
18:58:39 <jmcarthur> so is this worth over $700?
18:58:47 <copumpkin> jmcarthur: it's worth over 9000
18:59:09 <jmcarthur> copumpkin: i will never ask you questions like that again
18:59:16 <copumpkin> :(
18:59:19 <jmcarthur> :P
18:59:29 <jmcarthur> but seriously
18:59:36 <jmcarthur> would it really be worth that much?
18:59:47 <edwardk> depends, i've spent a lot more going to conferences and hackathons over the years, so i'm a terrible judge
18:59:51 <copumpkin> I dunno, I probably wouldn't spend that much, but it's a function of your net income and opportunity cost!
19:00:21 <copumpkin> then again, I have no money
19:00:31 <Gracenotes> an impure function
19:00:31 <temoto> edwardk, wanna wife point pack secret?
19:00:34 <jmcarthur> hey look it's my wife
19:00:38 <benalene> stop trying to convince us to go
19:00:44 <benalene> i want to go, really
19:00:47 <edwardk> hahahaha
19:00:48 <k23z__> jmcarthur, I found 2 books describing what ratsimp and radcan do in Maxima
19:00:56 <benalene> but it is 3 days away....
19:00:58 <k23z__> jmcarthur, do you want to have a look on them ?
19:00:58 <copumpkin> oh wow, it's jmcarthur's wife
19:00:59 <ddarius> edwardk: When in hac phi intended to be?
19:01:09 <k23z__> jmcarthur, like just skimming
19:01:10 <copumpkin> hi benalene
19:01:14 <edwardk> ddarius: fridayish
19:01:19 <benalene> now, if jmcarthur had given me 2 weeks notice instead of telling me yesterday, we could have gone
19:01:28 <benalene> hi, copumpkin
19:01:37 * jmcarthur zips his lips for a sec
19:01:49 <edwardk> looks like you're done for man. ;)
19:01:53 <edwardk> i'll see you next year ;)
19:01:54 <benalene> :P
19:02:09 <benalene> seriously, he always tells me these things at the last minute
19:02:26 <edwardk> to be fair we didn't really try and sell him on the idea until the other day
19:02:29 <temoto> If my wife was able to join #haskell i'd be the happiest man.
19:02:30 <ddarius> benalene: Now you have a year's notice.
19:02:32 <jmcarthur> i told her when it was announced
19:02:36 <benalene> temoto, :(
19:02:40 <edwardk> i met my wife on irc actually ;)
19:02:48 <benalene> edwardk, oh wow
19:02:49 <edwardk> she was sitting in the same row of computers as i was at the time
19:02:55 <benalene> haha!
19:03:11 * copumpkin goes off to the library
19:03:15 <edwardk> she then did the smart thing and went off and married the doctor
19:03:18 * jmcarthur wonders if maybe this is turning into a -blah conversation
19:03:18 <benalene> jmcarthur, that was months ago! i don't remember things that far in advance!
19:03:22 <edwardk> yeah
19:03:25 <edwardk> but i'm off ;)
19:03:30 * copumpkin kicks edwardk
19:03:38 * edwardk is kicked
19:03:42 <jmcarthur> benalene: but you just said i should tell you in advance...
19:03:59 <copumpkin> :)
19:04:19 <benalene> yeah, and we debated if it was worth the 14 hour drive...
19:05:06 <ccasin> next year, just think back to your current anguish at missing out, and the choice will be easy
19:05:24 <benalene> heh
19:05:35 <benalene> we will be there next year
19:05:43 <benalene> just send _me_ the reminders
19:05:58 <jmcarthur> gotta join the mailing list for that :P
19:06:36 <benalene> hey, are there any zoos in philadelphia?
19:06:54 <jmcarthur> benalene is hunting for excuses now
19:07:08 <ccasin> the philadelphia zoo is ostensibly in philadelphia
19:07:11 <ccasin> but I have never been to it
19:07:17 <benalene> oh...
19:07:18 <benalene> well....
19:07:23 <benalene> there is that
19:07:39 <edwardk> http://www.philadelphiazoo.org/
19:07:44 <benalene> fwee!
19:07:50 <ccasin> conveniently just 1.5 miles from the hac phi location
19:07:57 <benalene> hey now
19:08:03 <benalene> jmcarthur, i think we should go
19:08:12 <jmcarthur> is it worth over $700?
19:08:18 <benalene> .....
19:08:48 <temoto> (it's you who supposed to answer that question, jmcarthur)
19:08:55 <jmcarthur> we should either take it to -blah or just turn around and discuss it face to face like real couples
19:09:01 <edwardk> jmcarthur: this goes better if you assume yes ;)
19:15:15 <benalene> is philadelphia safe for a person to, say, walk from the hac phi to the zoo?
19:21:16 <benalene> well, i think we will be seeing you guys next year
19:21:22 <benalene> nice talking to you, though :D
19:23:42 <ville> http://book.realworldhaskell.org/read/functional-programming.html -- the first example. What is the point of using the `where' syntax in the main function: main = mainWith myFunction \n\t where...
19:24:15 <temoto> ville, 'to introduce a where syntax' is a good point.
19:24:27 <ville> temoto: It was introduced earlier already.
19:25:05 <temoto> ville, then, to shorten main = f x definition.
19:25:40 <Cale> actually, there's not a whole lot of point to that where clause, I agree.
19:26:04 <Cale> Oh, I suppose it makes it easier to specify what exactly is going to change in the examples below
19:44:33 <temoto> http://codepad.org/ZMR3vhEo  can this be done shorter?
19:47:12 <glguy_> You could use a Map (Int, Int) instead of a List of Lists
19:47:37 <glguy_> or you could use arrays if you wanted arrows as you say in the comment
19:47:41 <glguy_> arrays*
19:48:11 <kmc> yeah, list of lists is probably a bad idea
19:48:15 <kmc> very slow, very cumbersome
19:48:37 <kmc> Map (Int,Int) Value is going to be nearly as fast as an array, much better sharing between versions, and much simpler
19:48:56 <temoto> i chose it for ease of start and nice `show`
19:49:15 <kmc> ok
19:49:19 <kmc> "ease of start"?
19:49:44 <temoto> well i didn't have much exp with Map before
19:49:46 <kmc> ah
19:50:04 <kmc> no time like the present to learn ;)
19:50:08 <kmc> it's pretty straightforward
19:50:29 <kmc> btw http://hackage.haskell.org/package/EnumMap will act as a faster Map (Int,Int) and is mostly a drop-in replacement
19:50:32 <temoto> guess it is time
19:50:59 <Gracenotes> hm... it's probably all the imperative languages, but I can't help feel that recordFieldFunc myRecord looks backwards..
19:51:23 <kmc> don't know what that has to do with "imperative"
19:51:34 <kmc> but yeah, it is backwards depending on your perspective
19:51:42 <kmc> you can always define an infix opr
19:51:44 <nornagon> what happened to foldl.com? :(
19:51:47 <kmc> x # f = f x
19:51:48 <Gracenotes> the ones where data structure access happens in the reverse order
19:52:06 <Gracenotes> I can't help it! I wish it could look more natural.
19:53:29 <temoto> Ahh.. i recalled another reason for list of lists. Map (Int, Int) contains no inherent knowledge about bounds of each row.
19:53:54 <copumpkin> Map (Int, Int) has kind * -> *
19:53:59 <copumpkin> btw
19:54:52 <kmc> yeah
19:55:02 <Gracenotes> kmc: imperative languages might be too vague a stroke. record access seems hierarchical; hierarchy is often represented textually as left-to-right
19:55:09 <kmc> temoto, neither does the list, until you walk all the way to the end
19:55:21 <kmc> temoto, from a map you can extract the minimum and maximum key
19:55:26 <kmc> temoto, also consider Map Int (Map Int Value)
19:55:45 <kmc> Gracenotes, makes sense
19:55:55 <temoto> Aha! See it's even more scary than [[Value]]
19:55:56 <copumpkin> Gracenotes: so are many things, from left to right, but we still write our stuff right to left
19:56:06 <kmc> temoto, no
19:56:29 <kmc> Gracenotes, i think the various first-class labels packages usually give you a category of labels
19:56:36 <kmc> for which you can compose in either direction
19:56:39 <kmc> using (.) or (>>>)
19:57:23 <temoto> Let me ask a more general question then... there's a neural network of two layers and i need to store weights of connections. So, at least for visual representation, it's convenient to show that as a 2D matrix.
19:57:27 <Gracenotes> copumpkin: haskell, the contrarian programming language!
19:58:02 <kmc> temoto, lists are not arrays.  a list of lists is a really poor substitute for a 2D array
19:58:12 <flippo> really, really poor
19:58:18 <copumpkin> really, really, really poor
19:58:29 <temoto> (there are no connections inside a layer) (and question would be an advice to data structure)
19:58:32 <danharaj> really, really, really, really poor
19:58:42 <kmc> temoto, well, we already suggested several alternatives
19:59:02 <kmc> i think Map (Int,Int) Value is a pretty good choice
19:59:10 <Gracenotes> temoto: rows of the 2D matrix might represent the first layer, and columns might represent the second layer
19:59:19 <kmc> a good tradeoff of simplicity and efficiency
19:59:33 <temoto> Gracenotes, yeah that's how it works now.
19:59:33 <kmc> you can store bounds explicitly or get min/max key from the map
19:59:42 <Gracenotes> temoto: woo :)
19:59:49 <Gracenotes> and weight = 0 <=> no connection exists, I take it
19:59:54 <temoto> kmc, 'store bounds explicitly'?
20:00:10 <kmc> temoto, yeah.  you can remember the bounds
20:00:25 <temoto> kmc, in Map (-1, -1) ?
20:00:32 <kmc> yikes god no
20:00:43 <kmc> data Weights = Weights { nLayers :: Int, width :: Int, weights :: Map (Int,Int) Float }
20:01:10 <temoto> there is always two layers, but i got the point
20:01:18 <kmc> in Haskell, special values like that are a big code smell
20:01:27 <Gracenotes> how would an (Int, Int) suffice if there are >2 layers, anyhow..
20:01:28 <kmc> because we use types to represent how we think about the data, not how the computer should store it
20:02:19 <temoto> It's just i wasn't considering Knowledge (Weights) to be a record yet.
20:03:41 <Gracenotes> kmc: if that's the case, we should use more unsigned integers :)
20:03:52 <kmc> yeah
20:03:54 <kmc> we should :/
20:04:07 <pastorn> Gracenotes: for a 2x2x2 grid you'd have indices from (0,0) to (3,3) (i think)
20:04:09 <kmc> also Int should not be in scope in the Prelude
20:04:23 <pastorn> it would be better with (0,0,0) to (1,1,1), but both works
20:04:26 <temoto> Gracenotes, and Integer instead of Int, and 1-based lists, and less list-based stdlib.
20:04:29 <kmc> err, each layer is a 1D thing isn't it?
20:04:39 <kmc> what would "1-based lists" mean?
20:04:44 <kmc> and why the latter point
20:04:56 <Kaidelong> hmm, I haven't been able to find any tutorial like thing for literal haskell
20:05:03 <temoto> kmc, do you know BASIC?
20:05:07 <Kaidelong> or much at all
20:05:11 <pastorn> Kaidelong: what do you want to do?
20:05:18 <kmc> temoto, have used it years ago.  there's not one language named BASIC anyway
20:05:29 <temoto> kmc, so that would be OPTION BASE 1
20:05:34 <kmc> err
20:05:35 <Kaidelong> pastorn: write a lhs file, convert it to TeX, then to HTML
20:05:42 <kmc> can you just say what it means
20:05:42 <Gracenotes> pastorn: well, (2, 4) would currently represent a connection from the second node on the first row to the fourth node on the second row
20:05:48 <pastorn> Kaidelong: using that cool tool?
20:05:48 <kmc> instead of giving an analogy to an ancient language
20:05:55 <Gracenotes> ithink
20:05:56 <Kaidelong> pastorn: pretty much
20:06:03 <temoto> kmc, which makes, e.g. [1,2] !! 1 refer to first element.
20:06:07 <kmc> ok
20:06:08 <pastorn> Kaidelong: what's it called, again
20:06:08 <Kaidelong> was thinking it'd be a good way to do a blog entry
20:06:11 <pastorn> i forget :/
20:06:11 <kmc> well you shouldn't use (!!) very much anyway
20:06:28 <kmc> that's a sign you're Doing It Wrong
20:06:41 <temoto> for linked lists  yes. This comes to latter point about less list-based stdlib.
20:06:52 <pastorn> Gracenotes: that seems weird...
20:06:58 <kmc> well, Map and Set and Sequence are also in the stdlib
20:07:04 <Gracenotes> best use of !!, make your own if statement: [falseVal, trueVal] !! fromEnum myBool
20:07:07 <Kaidelong> http://people.cs.uu.nl/andres/lhs2tex/
20:07:09 <kmc> haha
20:07:12 <Kaidelong> @pastorn
20:07:15 <pastorn> Kaidelong: no, that's not it
20:07:31 <pastorn> help, what's the tool for using markdown in lhs code?
20:07:40 <kmc> BlogLiterately ?
20:07:43 <aavogt> pandoc?
20:07:43 <pastorn> no;
20:07:45 <pastorn> pandoc
20:07:50 <pastorn> Kaidelong: ^^^ look into this
20:07:54 <pastorn> it's awesome
20:08:09 <pastorn> lhs2tex is good, but i never got it working like i wanted :(
20:08:24 <pastorn> Kaidelong: what's your goal? blog post or academic paper?
20:08:39 <temoto> kmc, i mean that map should have type like Iterable (i a) => (a -> b) -> a -> (i b)
20:08:40 <Kaidelong> pastorn: blog post, but also something I can print nicely on paper
20:08:40 <kmc> temoto, as long as you don't think lists are arrays, they're useful for lots of other things
20:08:44 <Kaidelong> hence why I want to use latex
20:08:55 <kmc> temoto, as in Data.Traversable?
20:08:56 <Kaidelong> there are automated tools to convert it to HTML
20:09:00 <pastorn> Kaidelong: i'd recomend using markdown instead of tex in your lhs file
20:09:06 <pastorn> makes it much more readable
20:09:11 <kmc> or actually, just Functor
20:09:17 <kmc> temoto, Functor is the generalization of all mappable types
20:09:18 <pastorn> Kaidelong: pandoc does that for you
20:09:25 * Kaidelong already knows a bit of TeX but could learn markdown, he supposes
20:09:31 <pastorn> Kaidelong: hang on, i'll package up some code and send to you
20:09:36 <Kaidelong> thanks!
20:09:47 <pastorn> with a proper makefile and all that
20:09:54 <kmc> temoto, if you use "fmap" instead of "map", your code will work on lists, Sequence, and Map
20:10:05 <kmc> arguably "fmap" should be renamed to "map"
20:10:30 <temoto> kmc, yes, pretty much like in traversable, except for it to be the default. Because there's no point to bind Prelude map to exactly single linked list iterable type.
20:10:39 <kmc> yeah
20:10:45 <kmc> i agree that fmap should be renamed to map
20:10:49 <temoto> :)
20:10:54 <kmc> except possibly in some special "beginner's Prelude"
20:11:16 <Kaidelong> well there is talk about greatly reducing the size of the prelude isn't there?
20:11:32 <pastorn> i'd like if Num went away
20:11:33 <Kaidelong> I do wonder why list has its own stuff in Data.List and doesn't just implement a bunch of classes
20:11:38 <Kaidelong> like Foldable and Functor
20:11:45 <kmc> historical reasons probably
20:11:49 <aavogt> because those aren't enough
20:11:54 <pastorn> i want class Additive a; and class Multiplicative a; :/
20:11:58 <Kaidelong> aavogt: so invent more?
20:12:17 <hiptobecubic> i hate 'historical reasons'
20:12:18 <Kaidelong> maybe a more powerful class system might help, too
20:12:27 <Eridius> I like hysterical reasons
20:12:28 <pastorn> Kaidelong: how do you mean?
20:12:30 <aavogt> I dunno about you, but working with types that have > 6 class constraints isn't fun
20:12:38 * pastorn finds it quite powerful already...
20:12:57 <Kaidelong> pastorn: without extending it at all with things like multiple type parameters in a class?
20:13:03 <pastorn> aavogt: make an empty class which has all those as a prerequisite :)
20:13:22 <aavogt> except they aren't all the same every time
20:13:23 <kmc> we need context synonyms
20:13:31 <Pseudonym> Yes, we do.
20:13:51 <aavogt> or you need to stop using typeclasses at every opportunity
20:14:01 <Pseudonym> (MyComplexConstraint a b c) and (ConstraintA a, ConstraintB a b ...) should be synonyms.
20:14:15 <Pseudonym> aavogt: Are you advocating making code less generic?!
20:14:33 <Pseudonym> Typeclass synonyms would also, of course, make cleaning up the Prelude easier.
20:14:34 <copumpkin> heresy!
20:14:37 <aavogt> Pseudonym: when you only have one instance...
20:15:06 <byorgey> we'll have context synonyms soon, once the "type class constraints unleashed" stuff gets implemented
20:15:09 <byorgey> I hope
20:15:24 <Pseudonym> What you'd also like is to be able to declare an instance of the typeclass synonym and automatically get all of the class instances fulfilled.
20:18:23 <pastorn> hmm... maybe that could be a new syntax
20:18:40 <pastorn> f [ComplexConstraint a b c] =>
20:18:47 <pastorn> f :: [ComplexConstraint a b c] => a -> b -> c
20:18:50 <pastorn> instead of
20:18:59 <temoto> Where is that reverse '#' thing defined?
20:19:07 <pastorn> f :: (C0 a, C1 b, C2 c) => a -> b -> c
20:19:38 <copumpkin> temoto: nowhere specific
20:20:58 <k23z__> are there syntax highlighters written in Haskell ? for Perl for example ?
20:21:32 <copumpkin> I doubt it
20:23:01 <Polarina> Does anyone know of some nice and elegant way to handle exceptions?
20:23:31 <temoto> Polarina, try/finally
20:23:32 <kmc> k23z__, http://hackage.haskell.org/package/highlighting-kate
20:23:42 <kmc> Polarina, Haskell has several ways
20:23:59 <kmc> there are "true" exceptions which can be thrown by the evaluation of any expression, and caught in the IO monad
20:24:02 <kmc> those are in Control.Exception
20:24:16 <copumpkin> oh that's handy
20:24:31 <kmc> alternatively, it's common to use Either or ErrorT as exception-handling monads
20:24:41 <Polarina> kmc, how about exceptions from IO operations?
20:24:51 <kmc> Polarina, those would usually be of the Control.Exception sort
20:25:06 <Polarina> kmc, ok. Do you have an example on ErrorT usage?
20:25:10 <kmc> and can be caught with "catch" or "try" or many other functions
20:25:32 <kmc> no, maybe someone else does
20:26:06 <temoto> Polarina, 'write yourself scheme interpreter in 48 hours' has Error example.
20:26:18 <kmc> Polarina, "All About Monads" has http://www.haskell.org/all_about_monads/html/errormonad.html
20:26:27 <danharaj> write yourself a scheme in 48 hours is an excellent tutorial.
20:26:30 <kmc> Polarina, if you've used the Maybe monad, you've used the simplest exception-like monad
20:26:39 <kmc> in which all exceptions are "Nothing" so they don't store any more information
20:27:18 <Polarina> Mhm.
20:27:36 <kmc> the special thing about Control.Exception is that exceptions can be raised by the evaluation of any value.  in "pure Haskell" (i.e. written in Haskell) exception monads like Either or ErrorT, exceptions are raised by specific monadic actions
20:27:54 <pastorn> Polarina: have you tried using the maybe monad yet?
20:27:59 <Polarina> pastorn, I have.
20:28:32 <pastorn> Error a is usually just Either String a
20:28:47 <pastorn> so it's maybe that takes care of the string you feed to 'fail'
20:28:59 <Rotaerk> you could replace String with a discriminated union representing all the possible types of exceptions to expect
20:29:13 <Rotaerk> i.e. each case of that union having its own parameters as needed
20:29:33 <Polarina> Hmm...
20:29:56 <applicative> k23z__, there is also the prospective replacement for Highlighting Kate, http://github.com/jgm/illuminate
20:30:37 <k23z__> applicative, if it highlights does that mean it also parses Perl ?
20:30:54 <kmc> most highlighters only do lexical analysis
20:31:06 <kmc> it is in fact impossible to parse Perl code without executing it
20:31:12 <applicative> k23z__ sorry forgot to check for perl
20:31:20 <kmc> though you may not encounter those pathological cases in practice
20:31:27 <pastorn> Polarina: what error handling are you trying to do?
20:31:35 <Polarina> pastorn, SqlError from HDBC.
20:31:43 <kmc> if you forbid pathological cases then working with Perl is much much easier, as only 10% of the language is left
20:32:16 <k23z__> kmc, 10% of the language you say ?
20:32:16 <applicative> k23z__, he has in fact left Perl out, though I think he's a perl expert...maybe kmc is onto something...
20:32:45 <k23z__> I write hard core Perl
20:33:10 <k23z__> I did read some sort of hand-waving proof on perlmonks.org about Perl not being able to parse Perl
20:33:18 <k23z__> what would this mean for you guys
20:33:21 <heropass> yo, earthlings. anybody out there have a good reference that explains the banana split rule?
20:33:29 <k23z__> ?
20:33:58 <kmc> heropass, what is that?
20:34:06 <kmc> k23z__, *nothing* in this Universe can parse Perl without executing it
20:34:31 <pastorn> Polarina: you can easily set up your own error monad
20:34:33 <k23z__> kmc, great, now what conclusions can be drawn from that ? is it a very bad thing ?
20:34:35 <kmc> whether a Perl program is syntactically correct is undecidable
20:34:48 <pastorn> Polarina: data SQErr a = Bad SqlError a
20:34:53 <kmc> k23z__, it means that the syntax of Perl is not cleanly separated from other parts of the language, like its runtime semantics
20:34:58 <kmc> this generally makes it harder to think about things
20:35:05 <pastorn> instance Monad (SQErr) where ...
20:35:06 <kmc> harder to write static analysis tools (impossible, in the general case)
20:35:16 <heropass> not sure myself, I saw a reference to it in hutton's lectures  (programming in haskell) ... he says to google it but I've not found a good source for it
20:35:21 <kmc> syntax is trivial, syntax should always be the easy part of any language
20:35:33 <pastorn> Polarina: you might want to make that a monad transformer, though (i'm guessing you want to put your connection to the db in a Reader or something similar)
20:35:37 <p_l> I'd say static analysis for Perl is a job for reversible computing
20:35:39 <tessier__> Amatures talk about syntax. Professionals talk about semantics.
20:35:39 <k23z__> kmc, is it because I can generate Perl code using Perl code at runtime, and run that new generated Perl code at runtime ?
20:35:57 <Polarina> pastorn, Reader?
20:35:58 <aavogt> @wn amateur
20:36:00 <lambdabot> *** "amateur" wn "WordNet (r) 2.0"
20:36:00 <lambdabot> amateur
20:36:00 <lambdabot>      adj 1: engaged in as a pastime; "an amateur painter"; "gained
20:36:00 <lambdabot>             valuable experience in amateur theatricals";
20:36:00 <lambdabot>             "recreational golfers"; "reading matter that is both
20:36:02 <lambdabot> [7 @more lines]
20:36:17 <k23z__> aavogt, it's synonymous with dilletante
20:36:17 <blackdog> k23z__: that wouldn't change parsing
20:36:23 <stroan> k23z__: no. that is allowable in many parsable languages
20:36:24 <temoto> newtype Knowledge = Map (Int, Int) Weight -- what's wrong with this?
20:36:26 <heropass> I guess you can't talk semantix w/o mastering syntax
20:36:42 <aavogt> k23z__: I suggest newbie?
20:36:53 <aavogt> temoto: newtypes take a single parameter
20:36:56 <k23z__> aavogt, yes that may also do it
20:36:57 <aavogt> perhaps you want type
20:37:26 <aavogt> otherwise:   newtype Knowledge = Knowledge (Map (Int,Int) Weight)
20:37:49 <heropass> > dilletante :: Newbie a
20:37:49 <lambdabot>   Not in scope: type constructor or class `Newbie'Not in scope: `dilletante'
20:37:53 <k23z__> kmc,   I read some of the proof here http://www.perlmonks.org/?node_id=663393
20:38:13 <aavogt> it depends on whether you want to have explicit or implicit conversions between Knowledge and   Map (Int,Int) Weight
20:38:15 <applicative> k23z__, Highlighting Kate contains a perl parsing module, though the conception of parsing is aimed only at highlighting, so  it might not fit the bill
20:38:21 <k23z__> kmc, but when I saw stuff like "Kennedy's Lemma" I just thought it was a bit ridiculous so I stopped reading (since I didn't see anywhere else Kennedy's lemma before)
20:38:37 <pastorn> Polarina: the Reader monad is where you put stuff that won't change when running your computations
20:38:46 <QtPlatypus> k23z__: Ignore most of perlmonks.
20:38:52 <pastorn> i.e. your file handle to your database will stay the same
20:38:52 <aavogt> and by conversions, I mean conversions from the same type to itself (but there's just a different name)
20:38:52 <k23z__> QtPlatypus, really, why ?
20:38:57 <pastorn> so you put that in a reader
20:39:08 <aavogt> this perl stuff can go to -blah?
20:39:16 <applicative> k23z_, check it out, it makes me want to cry http://hackage.haskell.org/packages/archive/highlighting-kate/0.2.6.2/doc/html/src/Text-Highlighting-Kate-Syntax-Perl.html
20:39:32 <temoto> aavogt, if i want implicit conversions, then i must use just 'type'?
20:39:40 <aavogt> yes
20:39:44 <pastorn> Polarina: or if you're making a 3D game of some sort you might want to put what the graphics card is capable of in a reader, so you don't try to use stuff that's not available
20:39:49 <pastorn> Polarina: you understand?
20:41:47 <QtPlatypus>   /join haskell-blagh
20:41:56 <copumpkin> -blah
20:42:41 <kmc> temoto, there are no implicit conversions.  "type" just gives a new name to an existing type; there's nothing to be converted
20:42:43 <k23z__> QtPlatypus, joined
20:42:46 <kmc> it's already the same type
20:43:14 <kmc> k23z__, no, the undecidability of parsing Perl has nothing to do with "eval"
20:43:21 <kmc> Python has "eval" but has a simple and easy-to-parse syntax
20:43:35 <aavogt> it really depends how you want to look at it:   ("a" :: [Char]) :: String
20:43:51 <aavogt> while  [Char] == String
20:44:10 <nornagon> it's like typedef in C
20:44:12 <aavogt> they are different to the compiler when it gives error messages
20:44:19 <temoto> i got it, thanks
20:44:34 <applicative> type String = [Char]
20:45:15 <temoto> i wanted isolation of `data` declarations without boilerplate of writing pattern matches on single constructor
20:45:47 <aavogt> in that sense  newtype is like data
20:46:04 <aavogt> with a subtle difference when you have partially defined values
20:47:01 <aavogt> which can be ignored if you don't have undefined values
20:47:10 <pastorn> Polarina: did you die?
20:48:52 <kmc> temoto, you can't have isolation with implicit conversions
20:48:56 <kmc> that's almost a contradiction
20:49:10 <kmc> because how are they isolated if the compiler will just insert conversions for you?
20:50:33 <temoto> For compiler, i'm a user. As users of my software, i want convenience, they don't care how it complicates my job. I think this is reasonable.
20:51:18 <temoto> Writing discussed 'case' match on that single constructor is not convenient.
20:53:08 <kmc> temoto, when you use Haskell you give up the ability to conveniently write wrong programs
20:53:15 <kmc> (some of)
20:53:39 <aavogt> it really depends how your types turn out
20:53:58 <kmc> if you're arguing that there could be nicer syntactic sugar for newtypes then i don't claim that's impossible
20:53:58 <aavogt> you're quite free to only use String as your data types
20:54:01 <kmc> but it would just be sugar
20:54:21 <kmc> fundamentally, either the types are isolated, and you have wrapping / unwrapping, or they're the same type and there's no wrapper
20:54:40 <temoto> I like sweets.
20:54:47 <aavogt> or you can write typeclasses like the ones for regexes
20:54:56 <kmc> ugh i hate that API
20:55:17 <kmc> for example you can imagine a class Newtype a b | b -> a where { wrap :: a -> b; unwrap :: b -> a }
20:55:29 <kmc> which is automatically derived for every newtype (first bit of magic)
20:55:37 <aavogt> why does the fundep only go one way?
20:55:44 <kmc> because each newtype wraps only one type
20:55:49 <kmc> but some type might be wrapped by multiple newtypes
20:55:52 <kmc> (almost always is)
20:56:24 <kmc> then you can imagine sugar where a pattern ^p (or whatever colour bikeshed you like) stands for the view pattern (unwrap -> x)
20:56:34 <kmc> but again, you're giving up safety
20:56:49 <kmc> because if you pass in a different newtype that wraps the same type
20:56:52 <kmc> it will also work
20:57:05 <kmc> so you've got to say what you expect, either in a type sig or by choice of constructor or both
20:57:41 <aavogt> that sounds quite pointless because you would use type instead
20:58:26 <kmc> but it's common that people want wrapping with implicit conversion, or newtype without the extra syntactic overhead etc.
20:58:26 <copumpkin> or a class with a type family
20:58:36 <kmc> and i'm trying to figure out to what extent this is a contradiction
20:58:42 <kmc> and to what extent you could actually make newtype nicer to use
20:59:28 <aavogt> guilty by typeclass associated type
20:59:42 <GonzoChurch> haskabelle!  how cool is that?  http://www.google.com/url?sa=t&source=web&ct=res&cd=19&ved=0CFkQFjAS&url=http%3A%2F%2Fwww4.informatik.tu-muenchen.de%2F~haftmann%2Fpdf%2Fisabelle_haskell_haftmann.pdf&rct=j&q=agda+vs+isabelle&ei=QGHzS_vLOsKAlAem8-GTDQ&usg=AFQjCNH-L0SvdWGCua_qVsTNyDitEpdrVg
20:59:55 <copumpkin> GonzoChurch: it's pretty cool
21:05:12 <GonzoChurch> ah  here we go:  http://isabelle.in.tum.de/haskabelle.html
21:06:01 * hackagebot rangemin 2.1.4 - Linear range-min algorithms.  http://hackage.haskell.org/package/rangemin-2.1.4 (LouisWasserman)
21:07:40 <k23z__> GonzoChurch, it's like some stuff, but it originated in Isabelle
21:08:12 <GonzoChurch> 'some stuff'?
21:09:26 <copumpkin> @src init
21:09:26 <lambdabot> init [x]    = []
21:09:26 <lambdabot> init (x:xs) = x : init xs
21:09:26 <lambdabot> init []     = undefined
21:09:36 <GonzoChurch> glerp
21:10:03 <copumpkin> @src last
21:10:04 <lambdabot> last [x]    = x
21:10:04 <lambdabot> last (_:xs) = last xs
21:10:04 <lambdabot> last []     = undefined
21:13:06 <walrus_> is possible to make a function that return a element of a 'random'  type from a heteregoenous list (where random type is one of the types in the list)
21:13:16 <walrus_> ?
21:13:34 <copumpkin> nope, unless you forget the types
21:14:10 <kmc> what sort of heterogenous list are you using?
21:14:11 <ddarius> copumpkin: Or you make a RNG... in the type system.
21:14:22 <mpiechotka> @pl \x y -> not (f x y)
21:14:22 <lambdabot> (not .) . f
21:14:31 <copumpkin> lol, so sometimes the code might typecheck and other times it might not?
21:15:01 <kmc> walrus_, usually when people want a heterogenous list they really want a list of a sum type, or possibly an existential type
21:15:03 <walrus_> [Dynamic]
21:15:08 <kmc> oh
21:15:13 <copumpkin> walrus_: then sure, but that's kind of boring :P
21:15:17 <kmc> sure, you can return a random element from [Dynamic]
21:15:20 <copumpkin> and probably indicates you doing something wrong :)
21:15:37 <kmc> you can also do data Thing = T1 Int | T2 Char and return a random element from a [Thing]
21:15:49 <walrus_> but I need to specify the type...
21:16:06 <copumpkin> then no
21:16:15 <kmc> i'm not sure what you mean by that walrus_
21:16:33 <kmc> you can write [Dynamic] -> IO (Maybe a)
21:16:43 * copumpkin is enjoying writing code in a language he hasn't even specified yet
21:16:45 <kmc> which chooses randomly and then casts to a, or returns Nothing if the types mismatch
21:16:58 <kmc> (the IO is just there for RNG; it could also be Rand or State StdGen whatever)
21:17:07 <danharaj> I think the question is: what is walrus doing.
21:17:19 <kmc> yeah
21:17:27 <blackdog> copumpkin: all your programs are right, i guess
21:17:31 <walrus_> yes, I know. But in my problema I want to select a random type, like T1 a or T2 b
21:17:33 <kmc> this might be an AB problem or whatever it's called
21:17:35 <copumpkin> blackdog: yep!
21:18:54 <kmc> walrus_, can you explain why you want to do this?
21:19:21 <kmc> it might make it more clear for us, or it might reveal an earlier point at which to change your design
21:19:34 <walrus_> kmc: I'm creating a genetic algorithm program, that create random trees of binary or unary functions
21:19:58 <kmc> oh
21:20:13 <kmc> so you're generating random expression trees?
21:20:24 <walrus_> kmc: I already made progress with a code like data Types = AAB| ABA | BBA |... listTypes = [ VVV, ...]
21:20:33 <walrus_> exactly
21:20:42 <kmc> i have no idea what Types and listTypes mean there
21:20:44 <danharaj> Type witnesses to the rescue.
21:20:46 <kmc> what are AAB, ABA, ?
21:21:14 <walrus_> Are just a representation of function of type a -> a -> b , a -> b -> a , etc.
21:21:19 <heropass> \query lambdabot
21:21:25 <kmc> ok
21:22:05 <walrus_> I select a random element of listTypes, and if is AAB I need to select a random function from a list [a->a->b]
21:22:33 <walrus_> this solution has a lot of boilerplate code
21:22:34 <heropass> let mylength = foldr (\_ n-> 1+n) 0
21:23:25 <heropass> >  let mylength = foldr (\_ n-> 1+n) 0
21:23:26 <lambdabot>   not an expression: `let mylength = foldr (\_ n-> 1+n) 0'
21:23:35 <walrus_> and I'm trying to find a solution that can works for trees with N differents types.
21:23:52 <heropass> \query
21:24:16 <heropass> \query lambdabot
21:24:30 <kmc> heropass, use a forward slash
21:24:32 <kmc> as in /query lambdabot
21:24:53 <heropass> let mylength xs = folder (\_ n -> 1+n) 0
21:25:25 <Cale> > let myLength xs = foldr (\_ n -> 1+n) 0 in myLength "hello"
21:25:25 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> b)
21:25:26 <lambdabot>    arising from a use of...
21:25:31 <temoto> given two dimensions X and Y, how do i get list of permutations of all [1..X] and [1..Y] ?
21:25:34 <Cale> > let myLength = foldr (\_ n -> 1+n) 0 in myLength "hello"
21:25:35 <lambdabot>   5
21:25:54 <kmc> :t permutations
21:25:55 <lambdabot> forall a. [a] -> [[a]]
21:26:02 <kmc> > permutations $ zip [1..5] [1..3]
21:26:02 <lambdabot>   [[(1,1),(2,2),(3,3)],[(2,2),(1,1),(3,3)],[(3,3),(2,2),(1,1)],[(2,2),(3,3),(...
21:26:18 <kmc> walrus_, the easy thing is to give up some Haskell-level type checking
21:26:24 <temoto> kmc, thanks.
21:26:26 <Cale> > permutations [1..5] ++ permutations [1..3] -- maybe
21:26:26 <lambdabot>   [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4...
21:26:30 <heropass> > I see
21:26:30 <lambdabot>   Not in scope: data constructor `I'Not in scope: `see'
21:27:07 <kmc> walrus_, represent your GA language values uniformly
21:27:11 <temoto> i think i rather need   concat . permutations . zip
21:27:30 <kmc> data Val = VInt Int | VFun ([Val] -> Val) | ...
21:27:40 <kmc> data Exp = ELit Val | EApp Val [Val]
21:27:41 <walrus_> kmc: With just one type? I already made this
21:28:04 <kmc> but you're trying to pick values from [a->b->a] and [a->a->b] etc
21:28:11 <heropass> > permutations $ zip [1..3] [1..2]
21:28:12 <lambdabot>   [[(1,1),(2,2)],[(2,2),(1,1)]]
21:28:13 <kmc> when you could just pick from [Val]
21:28:15 <Cale> temoto: and you're sure it's permutations you want, and not just all possible pairs?
21:28:32 <Cale> > liftM2 (,) [1..5] [1..3]
21:28:33 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5...
21:28:39 <temoto> Cale, is there a difference?
21:28:53 <kmc> temoto, "permutations" = "orderings"
21:28:56 <Cale> temoto: yes. Permutations are the ways of rearranging a list of items
21:28:56 <kmc> > permutations "abcde"
21:28:58 <lambdabot>   ["abcde","bacde","cbade","bcade","cabde","acbde","dcbae","cdbae","cbdae","d...
21:29:09 <walrus_> kmc: yes, I'm trying to generalyze my monomorphic program and see how the results change with more types
21:29:28 <heropass> > :t rotate
21:29:29 <lambdabot>   <no location info>: parse error on input `:'
21:29:49 <walrus_> kmc: trying to see what are the implications for the convergence speed, program solution size, etc
21:30:04 <heropass> > permutations "abcde" !! 3
21:30:05 <lambdabot>   "bcade"
21:30:17 <temoto> let's put it that way, i need coordinates of all points on imaginable field
21:30:34 <copumpkin> edwardk: you around?
21:30:36 <heropass> all pairs, then
21:30:47 <kmc> walrus_, you can enforce the same type system onto your GA language
21:30:49 <Cale> temoto: Then yeah, you want all pairs, not all permutations :)
21:30:57 <kmc> without making it obvious to the Haskell type checker
21:31:20 <copumpkin> I'm trying to pick a good parser combinator library. Anyone have any preferences (who has tried more than one)?
21:31:22 <temoto> Cale, thanks.
21:31:39 <Cale> temoto: One way is  liftM2 (,)  and another is just to use a list comprehension
21:31:49 <Cale> > [(x,y) | x <- [1..5], y <- [1..3]]
21:31:49 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5...
21:31:56 <Cale> > [(x,y) | x <- [1..3], y <- [1..3]]
21:31:57 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
21:34:25 <temoto> I wrote it with lift, thanks.
21:34:39 <jon_of_arc> copumpkin: I've tried two; I made one and would pick the other. Does that count?
21:34:52 <copumpkin> jon_of_arc: let's hear it :P
21:35:07 <temoto> Now the last problem with [[Weight]] -> Map (Int, Int) Weight  transition is that i can't write a custom Show instance.
21:35:09 <walrus_> kmc: just for clarification, here is the data type for the monomorphic tree and the polymorphic tree, using GADT: http://pastebin.com/jvAGMUA9
21:35:37 <temoto> i can with TypeSynonymInstances but the error is that i have overlapping instances
21:35:48 <kmc> temoto, you should wrap it in a custom type then
21:36:02 <copumpkin> nice category: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:text.parsercombinators%20parsing%20text
21:36:02 <kmc> makes no sense to redefine how maps are shown in general
21:36:15 <walrus_> kmc: appears to me that the tree approach is not a good one for polymorphic trees (using Haskell to type check)
21:36:15 <kmc> you've invented a new type of weight-matrices, and how it's shown
21:36:24 <jon_of_arc> (In all seriousness, other than my home-rolled ridiculousness I only have experience with Parsec; works well enough, but most of my good will towards it comes from what studying its implementation did for me)
21:36:46 <kmc> temoto, it happens that your weight-matrices are *implemented* using maps, but you shouldn't redefine Show for maps
21:36:53 <baguasquirrel> hey guys, is there a generalization for the (.) operator?  e.g.  (a -> b -> c) -> (c -> d) -> (a -> b -> d)
21:37:07 <kmc> :t (.) . (.)
21:37:08 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:37:11 <kmc> grr
21:37:18 <kmc> :t let (.) = (Prelude..) in (.) . (.)
21:37:19 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:37:21 <Cale> That's the other one
21:37:36 <walrus_> the sad thing is that with GADT the data type is very elegant, but impossible to create a random instance of it.
21:37:45 <baguasquirrel> hmm, thanks :)
21:38:17 <Cale> er, oh, it's just flipped
21:39:09 <temoto> One-way type aliases would be appropriate.
21:40:25 <Gracenotes> or, uh, defining (.) 'right'
21:40:44 <Cale> Personally, I find that one more intuitive when you think of it as  fmap . fmap
21:40:57 <baguasquirrel> yea, that does make more sense
21:41:04 <heropass> > parse item "abc"
21:41:05 <lambdabot>   Not in scope: `parse'Not in scope: `item'
21:42:26 <baguasquirrel> it just feels a little weird using fmap for something that may or may not really be a proper functor...
21:42:57 <copumpkin> proper?
21:43:11 <copumpkin> all your functors should be proper!
21:43:12 <Gracenotes> it's not in the Functor of The Month club
21:43:33 <baguasquirrel> I dunno, maybe I'm confused =P
21:44:17 <DigitalKiwi> coast to coast!
21:44:25 <blackdog> she was a strait-laced uptown monad - he was a functor from the wrong side of the tracks
21:44:40 <baguasquirrel> lol!
21:44:56 <baguasquirrel> so my understanding is that it works because (-> r) is an instance of Functor
21:45:12 <copumpkin> (r ->)
21:45:20 <copumpkin> assuming you support type operator sections ;)
21:45:22 <baguasquirrel> yea, my bad
21:46:00 <baguasquirrel> no wait, that does make sense  xP
21:46:44 <ignacio> @lambdabot maximum
21:46:45 <lambdabot> Unknown command, try @list
21:47:05 <c_wraith> @src maximum
21:47:05 <lambdabot> maximum [] = undefined
21:47:05 <lambdabot> maximum xs = foldl1 max xs
21:47:48 <Gracenotes> lambdabotum maximus
21:52:08 <temoto> How is this called   f n xs = ys : (f n rest) where ys = take n xs; rest = drop n xs   ?
21:52:18 <wli> splitAt n
21:52:45 <ddarius> temoto: There is no "standard" function that does this.  There is a package that contains variations of functions that do this.
21:52:58 <JoeyA> I started learning Haskell about 2 weeks ago.  I wrote a simple program that generates an integer sequence I came up with, but I wouldn't quite call it well-formatted:  http://codepad.org/yUjEQlaa
21:52:59 <copumpkin> is there a good way to specify one or more unicode character classes you want parsec to accept?
21:53:12 <ddarius> @hackage split
21:53:12 <lambdabot> http://hackage.haskell.org/package/split
21:53:32 <ddarius> copumpkin: Use satisfy?
21:53:49 <JoeyA> oops, didn't see the existing conversation; carry on :-)
21:54:00 <copumpkin> is there a library that contains the unicode properties for all characters?
21:54:01 <ddarius> temoto: The function you want in that package is called "chunk"
21:54:20 <jon_of_arc> Is there any decent documentation (that is, preferably not in GHC source files) on what sorts of nontermination the RTS can pick up on and turn into <<loop>>?
21:54:39 <copumpkin> let f = f in f
21:54:56 <wli> @type \n -> unfoldr (\xs -> if null xs then Nothing else Just (splitAt n xs))
21:54:56 <lambdabot> forall a. Int -> [a] -> [[a]]
21:55:01 <ddarius> jon_of_arc: Look up blackholing.  Try checking the GHC Commentary, but the answer is probably "no."
21:55:02 <c_wraith> jon_of_arc: it happens when the RTS attempts to enter a blackhole
21:55:24 <kmc> jon_of_arc, it happens when evaluation of a thunk forces evaluation of the same thunk
21:55:40 <jon_of_arc> ddarius: I've checked the commentary pretty exhaustively, sadly. There's a section heading on blackholing with nothing below it.
21:55:44 <wli> temoto: I think that might help a little, too.
21:55:55 <kmc> the original STG-machine paper mentions this
21:55:59 <kmc> though it's out of date in a lot of ways
21:56:01 <kmc> when you enter a thunk, the RTS rewrites its entry code with a "black hole"
21:56:11 <copumpkin> http://hackage.haskell.org/packages/archive/regex-xmlschema/0.1.2/doc/html/Text-Regex-XMLSchema-String-Unicode-CharProps.html seems to contain it, but that seems like overkill
21:56:12 <kmc> when the thunk is evaluated it's overwritten again with the resulting value
21:56:14 <ddarius> Using -threaded changes that behavior, but it's possible that using -threaded makes it altogether impossible for loop exceptions to occur, in which case the "rules" would be relatively straightforward.
21:56:20 <kmc> yeah
21:56:26 <kmc> because with -threaded you get a "white hole" instead
21:56:50 <kmc> a thread entering a white-holed thunk is placed onto a queue of threads waiting for whoever is already evaluating the thunk to finish
21:57:04 <kmc> it might check if it's the thread supposed to be evaluating the thunk.  it also might not; i'm not sure
21:57:11 <temoto> Thanks for chunk and alike stuff.
21:58:49 <copumpkin> wow. http://hackage.haskell.org/packages/archive/unicode-names/3.2.0.0/doc/html/src/Data-Char-Properties-NamesData.html#getCharacterName
21:58:59 <copumpkin> I didn't even think GHC could compile that much static data in a source file
21:59:27 <copumpkin> it's struggling pretty hard to even compile the unicode prerequisite
21:59:36 <wli> What is it like 128MB of string data floating around in there?
21:59:55 <copumpkin> something huge
21:59:59 <copumpkin> it's not even the latest standard
22:00:03 <copumpkin> I wonder if this ever compiled
22:00:18 <ddarius> That's a big list.
22:00:24 * copumpkin gives up
22:00:28 <copumpkin> GHC was just sitting there
22:00:45 <tensorpudding> Ahhh son of a...i shouldn't have clicked that link
22:00:50 <jon_of_arc> theList indeed.
22:01:05 <copumpkin> weird coding style too
22:01:24 <tensorpudding> That is theList.
22:01:32 <Draconx> copumpkin, perhaps your C library supports unicode classification via the wctype/iswctype interface?
22:01:55 <copumpkin> Draconx: I don't really feel like FFI'ing
22:02:06 <copumpkin> I would've thought it'd be in a standard library somewhere
22:04:59 <p_l> Well, you could download the unicode db and write a support lib...
22:05:48 <copumpkin> I could do everything myself :P
22:05:53 <copumpkin> I just wanted to avoid it :)
22:06:52 <tensorpudding> Why should I do it, when someone else do it.
22:06:56 <tensorpudding> could*
22:07:51 <p_l> well, you could use it as learning exercise, or a way to show off how fast one can develop in Haskell...
22:07:59 <copumpkin> hum
22:08:06 <p_l> ... it's not like us lispers are the only smug weenies around :P
22:08:06 <copumpkin> it would teach me nothing at all :P
22:08:07 <edwardk> copumpkin: yeah
22:08:19 <edwardk> (er i am around)
22:08:29 <copumpkin> ah
22:08:34 <copumpkin> forgot what I was going to ask now :)
22:08:40 <edwardk> hah
22:09:16 <p_l> copumpkin: make it so that the checking looks like normal matching for types :D
22:10:08 <Eduardo_> hello
22:10:14 <Eduardo_> I'm new to Haskell
22:10:29 <Eduardo_> I'm trying to make a type using `data'
22:10:29 <kmc> hi Eduardo_
22:10:43 <Eduardo_> hey kmc
22:11:03 <Eduardo_> data MyData = [Integer] | Integer
22:11:08 <edwardk> you need a tag
22:11:08 <Eduardo_> should this work?
22:11:19 <edwardk> data MyData = ListOfInt [Integer] | AnInt Integer
22:11:30 <Eduardo_> oh
22:11:36 <edwardk> then you can use patterns like foo (ListOfInt xs) = ...
22:11:54 <edwardk> you were missing 'data constructors'
22:12:01 <Eduardo_> thanks, edwardk
22:12:06 <edwardk> np
22:12:13 <Eduardo_> in most documentation I read there wasn't tags
22:12:24 <edwardk> there are, they just look a lot like types ;)
22:12:44 <dolio> exptime
22:13:06 <Eduardo_> heh
22:13:10 <Eduardo_> I started yesterday
22:13:11 <kmc> Eduardo_, maybe you mean at the implementation level
22:13:39 <Eduardo_> but I can say that I've never programmed nothing so cool, elegant and powerful
22:13:47 <kmc> GHC's compiled code is described as "tagless" in a specific sense
22:13:51 <copumpkin> ah, I can just use general thingies from Data.Char
22:13:54 <kmc> which has not much to do with the level of code you write
22:14:20 <kmc> Eduardo_, yes, if you learn enough Haskell you will be bitter about any employer who makes you program in C++ or Java
22:14:33 <kmc> i'm not kidding, it's a serious risk
22:14:35 <edwardk> kmc: its not _that_ bad ;)
22:14:35 <kmc> keep this in mind
22:14:38 <Eduardo_> I know
22:15:01 <Eduardo_> Haskell is making me found way better solutions for problems
22:15:02 <ddarius> edwardk: If it was Java it would be.
22:15:22 <edwardk> ok, java is a hanging offense, but c++ is tolerable ;)
22:15:24 <Eduardo_> making me find*
22:15:43 <Eduardo_> hate Java
22:15:54 <p_l> edwardk: I personally find C++ worse than Java
22:16:19 <p_l> edwardk: OTOH, I had rather mentally disturbing encounter with vtables...
22:16:23 <kmc> ah damnation
22:16:26 <kmc> i did it again
22:16:38 <copumpkin> I personally believe [...] everything like such as
22:16:58 <Pseudonym> Haskell makes your C++ better.
22:17:08 <ddarius> copumpkin has degenerated into incoherency.
22:17:14 <Pseudonym> I'd hate programming in C++ if I didn't know Haskell.
22:17:15 <p_l> Eduardo_: Despite the mentions of bitterness when forced to use Java, don't give up on Haskell, it's a wonderful language and the knowledge might be used in many other languages as well.
22:17:19 <Eduardo_> Haskell seems to make everything better :D
22:17:20 <copumpkin> ddarius: just quoting someone famous
22:17:32 <Eduardo_> of course not, p_l !
22:17:39 <Eduardo_> I fell in love with Haskell
22:17:48 <kmc> Haskell makes people look at your C++ funny because you'd prefer to use boost::variant rather than writing 300 lines of class hierarchy and visitor boilerplate
22:18:06 <p_l> Eduardo_: Though I do invite you to look into other camps later, like Common Lisp :D
22:18:14 <Eduardo_> yay
22:18:17 <kmc> can't count how many times i've heard that OO languages don't need algebraic data because there's an "idiomatic OO" way to do the same thing
22:18:20 <Eduardo_> I programmed a little bit of CL
22:18:27 <kmc> there is, it's bad
22:18:33 <Eduardo_> very cool, also
22:18:38 <Pseudonym> kmc: Haskell doesn't need global mutable state, because there are idiomatic ways to do that.
22:18:45 <edwardk> kmc: heh
22:18:49 <Pseudonym> Essentially, this is the Turing tarpit argument.
22:19:04 <kmc> it's not too uncommon to want global mutable state in Haskell
22:19:12 <p_l> kmc: I can't get around the lack of either CLOS generic functions or Haskell's typeclasses when I have to do Java or C++ (when C++templates enter, I scream...)
22:19:12 <kmc> and it's not too difficult to get
22:19:36 <edwardk> but once you have it, it is very easy to shoot yourself in the foot ;)
22:19:47 <edwardk> and very hard to reason about the semantics of your code
22:21:00 <p_l> well, you can arrange your code into multiple communicating processes that run small tasks in completely applicative style except for some designated "state handlers" :P
22:21:47 <Pseudonym> p_l: That is, you can write an ad hoc, informally-specified, bug-ridden, slow implementation of half of Erlang.
22:22:04 <kmc> yeah
22:22:10 <ddarius> Pseudonym: I like that style.
22:22:11 <kmc> though much of Erlang-style concurrency is already in the standard library
22:22:21 <kmc> a big exception being anything distributed
22:22:52 <p_l> Pseudonym: the multiple processes aren't that rare outside Erlang, what makes Erlang so different is the runtime, IMHO
22:23:01 <kmc> also hot-patching your code by restarting some processes and not others
22:23:09 <p_l> kmc: part of the runtime
22:23:14 <kmc> yeah
22:23:21 <Pseudonym> The problem with any Greenspun-like rule is that it ignores the fact that high-level languages also require you to work around limitations by implementing features found in other languages.
22:23:30 <kmc> i meant "also" as in another thing not in the Haskell standard lib
22:23:41 <Pseudonym> Often, this is a GOOD thing, especially if those other languages are domain-specific.
22:24:01 <p_l> well, the reason my current work favors CL is that I like to use redefinition in live image...
22:24:18 <Pseudonym> You could do that in Erlang.
22:24:57 <p_l> Pseudonym: Erlang is nice, but CL was easier to start with
22:25:12 <p_l> I did learn a little Erlang, though, and I plan on using it in the future
22:25:20 <temoto> And Erlang has horrible, horrible error messages.
22:25:32 <temoto> (don't know about CL)
22:25:49 <ddarius> temoto: You should learn Prolog.
22:26:09 <Pseudonym> Then learn Mercury so you can dump Prolog.
22:26:14 <copumpkin> is layout usually parsed with a preprocessing step?
22:26:26 <temoto> ddarius, yeah i wanted to try some logical programming one day.
22:26:34 <Pseudonym> copumpkin: "Usually" as in "in most Haskell implementations"?
22:26:46 <copumpkin> Pseudonym: yeah, I guess :P or other languages with a similar syntax
22:27:11 <Pseudonym> Generally speaking, the layout rule is implemented in the lexer, but the ambiguity resolution is done in the parser.
22:27:21 <p_l> temoto: my favorite memory of Prolog was the faces of other freshmen when they encountered it for the first time in practical :D
22:27:28 <Pseudonym> BTW, ambiguity resolution is one of the more arcane parts of implementing Haskell.
22:27:33 <Pseudonym> The layout rule is the easy part.
22:27:42 <copumpkin> ambiguity in what sense?
22:27:58 <Pseudonym> In the sense of "if you could get rid of a syntax error by adding a close brace, do that".
22:28:03 <copumpkin> oh
22:28:08 <copumpkin> yeah, sounds ugly
22:28:24 <Pseudonym> But it works. :-)
22:28:32 <Pseudonym> It's easier in Parsec than in a yacc-like tool, actually.
22:28:47 <Pseudonym> Which just goes to show that only Haskell can parse Haskell.
22:28:53 <temoto> p_l, was that about some particular feature or pithiness?
22:29:14 <pikhq> Pseudonym: Most things are easier in Parsec. :)
22:29:33 <p_l> temoto: I enjoyed their utter confusion :D
22:34:13 <Eduardo_> right, I created that type: data MyData = IL [Integer] | SI Integer
22:34:34 <Eduardo_> now i got some error when using Just
22:34:56 <Eduardo_> i'm doing something crazy here, maybe i'll never use this; just to know if it works
22:35:05 <kmc> you can put your code on hpaste.org
22:35:11 <Eduardo_> k
22:36:28 <Eduardo_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25587#a25587
22:38:04 <Eduardo_> what's wrong?
22:38:24 <pastorn> Eduardo_: you forgot the constructor on line 5
22:38:33 <pastorn> = Just (IL [1..10])
22:38:39 <pastorn> that's what it should say
22:38:39 <Pseudonym> And line 4./
22:38:43 <pastorn> same goes for line 4
22:38:44 <Pseudonym> Just (SI x)
22:38:46 <Eduardo_> oh!
22:38:58 <ancechu> hi all
22:39:06 <ancechu> im trying to use HUnit
22:39:07 <Pseudonym> However, if all of those constructors are getting you down...
22:39:10 <Eduardo_> i'm new to these constructors
22:39:12 <Eduardo_> thank you all
22:39:19 <ancechu> but GHCI complains about not founding it
22:39:26 <ancechu> but I have it installed
22:39:26 <Eduardo_> yea
22:39:32 <Pseudonym> class Inject a where { inject :: a -> Maybe MyData }
22:39:44 <Pseudonym> instance Inject Integer where { inject x = Just (SI x) }
22:39:49 <ancechu> by cabal and also tried to isntall it through the package manager un Ubuntu
22:39:59 <Pseudonym> instance Inject [Integer] where { inject xs = Just (IL xs) }
22:40:03 <ancechu> how can i figure what is happening?
22:40:04 <Pseudonym> Ad-hoc overloading.
22:40:12 <Eduardo_> *-*
22:40:19 <ancechu> Prelude> :m +HUnit
22:40:19 <ancechu> <no location info>:
22:40:19 <ancechu>     Could not find module `HUnit':
22:40:19 <ancechu>       it is not a module in the current program, or in any known package.
22:40:59 <kmc> ancechu, the module is called Test.HUnit
22:41:03 <kmc> the package is named HUnit
22:41:15 <kmc> :m is for loading modules
22:41:56 <ancechu> kmc thanks a lot
22:41:59 <ancechu> in http://hunit.sourceforge.net/HUnit-1.0/Guide.html
22:42:05 <ancechu> they call it HUnit
22:42:07 <kmc> :m is for loading modules
22:42:09 <kmc> whoops sorry
22:42:30 <kmc> ancechu, hmm, seems that guide is old
22:42:49 <kmc> btw QuickCheck is more popular than HUnit, though they do different things and both are used
22:43:10 <ancechu> I know but i was trying to implement a Trie
22:43:17 <Eduardo_> Pseudonym: put your code on my snipplr for later study (for now i'll play with integers, lol)
22:43:21 <temoto> Can i define a coercion from my type to Float?
22:43:22 <Eduardo_> thank you
22:43:24 <ancechu> and I thought that HUnit fits better for data structures
22:43:33 <ancechu> doesnt it?
22:43:36 <copumpkin> temoto: we don't coerce
22:43:36 <kmc> temoto, you can define a function of type YourType -> Float
22:43:40 <temoto> like instance Show but to Real or something
22:43:47 <copumpkin> we gently nudge
22:44:01 <ancechu> for me it is difficult to come with general rules for a Trie
22:44:06 <kmc> ancechu, not sure what the claim would mean
22:44:36 <ancechu> with quickcheck you should figure general rules about your data structures
22:44:47 <ancechu> like the reverse . reverse example for lists
22:44:54 <ancechu> no?
22:45:10 <ancechu> but for me it is more natural to provide examples ala xUnit
22:45:21 <temoto> ancechu, for me too.
22:45:22 <ancechu> when testing those prefix trees
22:45:49 <ancechu> perhaps im too imperative and there is a proper way in the haskell world
22:46:53 <kmc> heh
22:47:00 <kmc> how did "imperative" end up meaning "opposite of Haskell"?
22:47:19 <kmc> anyway i can see the point
22:47:28 <kmc> i think it's worth the effort to come up with general rules
22:47:28 <pikhq> Because people don't realise that Haskell does first-class imperative programs. :)
22:47:38 <tensorpudding> The opposite of Haskell is Lleksah, obviously
22:47:40 <kmc> because QuickCheck will generate more and weirder examples than you would
22:47:49 <Pseudonym> No, that's the reverse of Haskell.
22:48:03 <Eduardo_> lol
22:48:09 <kmc> data HaskOp a b = HaskOp (b -> a) deriving (Category)
22:48:56 <Pseudonym> > map (\c -> chr (25 - ord c + 2 * ord 'A')) "HASKELL"
22:48:57 <lambdabot>   "SZHPVOO"
22:48:58 <djahandarie> Need moar category theory
22:49:10 <copumpkin> ancechu: surely when you think of examples in your head, you have some sort of implicit rule you're using to generate them
22:49:12 <kmc> i don't think it's possible to use a data structure about which you have no general rules
22:49:32 <kmc> the API to your data structure is a contract, which has rules
22:49:33 <copumpkin> ancechu: you're just doing more work than you need to by actually trying to come up with examples
22:49:44 <kmc> the user must know those rules
22:49:58 <kmc> though, this only accounts for black-box testing and not other things you might want, like internal invariants
22:50:24 * copumpkin just wants a simple barebones parser for a haskell-like language
22:50:28 <copumpkin> dammit
22:51:12 <copumpkin> I'd pull agda's but it's even more hardcore than GHC's
22:51:17 <ancechu> kmc, copumkin, ill try the quickcheck approach
22:51:31 <kmc> people do use HUnit though
22:51:37 <ancechu> which is the best tutorial approach for learning it?
22:51:39 <kmc> i'm not saying you necessarily shouldn't
22:51:44 <kmc> ancechu, RWH has a good chapter
22:51:48 <kmc> @where rwh
22:51:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:51:57 <kmc> http://book.realworldhaskell.org/read/testing-and-quality-assurance.html
22:52:25 <tensorpudding> Only one good chapter though.
22:52:54 <ancechu> ok, and for the internal invariants, do you think that a trie is an example of internal invariants you mentiioned before?
22:52:55 <ancechu> http://en.wikipedia.org/wiki/Trie
22:53:26 <ancechu> it is only a tree with preconfigured layout of nodes
22:53:43 <ancechu> this is why i can't think about general rules out of the box
22:54:56 <Kaidelong> I still don't understand why haskell doesn't use tries in its implementation of maps
22:55:11 <Kaidelong> referential transparency issues at being able to look up what a key is made of?
22:55:15 <kmc> IntMap is a trie
22:55:25 <kmc> EnumMap as well (not standard library)
22:55:28 <kmc> and yes, referential transparency
22:55:38 <kmc> Map works with any orderable type, it's completely opaque otherwise
22:55:48 <kmc> i'd like to see also a hash trie
22:55:52 <kmc> i think someone made one actually
22:56:02 <kmc> but the user would have to specify a hash fn
22:56:04 <copumpkin> ezyang was working on one
22:56:04 <Kaidelong> well a trie would basically be the next best thing to a hash table
22:56:33 <copumpkin> hashtables are overrated
22:56:38 <Kaidelong> kmc: unless you could look at the binary representation of the value
22:56:46 <Kaidelong> which I presume is what you're trying to avoid here
22:56:49 <kmc> Kaidelong, you really can't
22:56:53 <kmc> without awful hacks
22:56:55 <copumpkin> considering it most probably contains several pointers
22:57:03 <kmc> and the pointers can move over time
22:57:24 * copumpkin goes poof
22:57:51 <Eduardo_> i'm leaving. thanks everyone for the help and a good night. :)
22:57:55 <Kaidelong> kmc: you could then restrict the keys to Eq rather than just Ord, though
22:58:01 <Kaidelong> err
22:58:04 <Kaidelong> rather than Ord
22:58:06 <Kaidelong> just Eq
22:59:38 <Kaidelong> I suppose the real point here is that tree maps are "good enough" and that hacking for a speed gain does not really pay off too much
23:00:22 <Kaidelong> and I guess that answers my question on why a tree over a trie
23:02:51 <kmc> it's definitely a hole in the std lib
23:02:58 <kmc> i don't think it's a huge deal but it's something i'd like to see
23:03:34 <kmc> on hackage there are tries for ints, bytestring, and lists
23:03:44 <kmc> and anything Enum
23:03:45 <kmc> and you can put together a hash trie from that
23:03:52 <kmc> but it's a bit of work that's probably being duplicated now
23:04:04 <kmc> so... i should stop complaining and write it :)
23:09:59 <Gracenotes> hum, I forget, what's the not-immediately-obvious way to get an [a] from a Seq a?
23:10:36 <kmc> :t toList
23:10:37 <lambdabot> Not in scope: `toList'
23:10:44 <kmc> :t Data.Foldable.toList
23:10:45 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
23:11:26 <Gracenotes> aha, wasn't sure if it was maybe Traversable or a cousin. *mumbles something about API design*
23:12:33 <Gracenotes> okay, got Seqs serializable in Happstack
23:12:41 <tensorpudding> :t Data.Seq.toList
23:12:43 <lambdabot> Couldn't find qualified module.
23:12:46 <tensorpudding> meh
23:12:59 <tensorpudding> also Edison's Seq API has it too
23:16:58 <x6d65> From within ghci, what should System.Random.randomRIO (0.0, 1.0) produce?
23:17:42 <pastorn> 0.44
23:17:45 <pastorn> always
23:18:00 <pastorn> (purity and all that)
23:18:27 <pastorn> x6d65: http://bit.ly/18Apxa
23:20:54 <x6d65> I'm getting Infinity every time, which seems like a bug.
23:21:28 <tensorpudding> I'm getting a random number between 0.0 and 1.0
23:21:40 <pastorn> i get between 0.0 and 1.0 too
23:21:51 <x6d65> Which is what you'd expect.
23:22:10 <pastorn> x6d65: maybe you compiled ghc the wrong way?
23:23:07 <pastorn> x6d65: try this:
23:23:08 <pastorn> newStdGen >>= return . fst . randomR (0.0, 1.0)
23:23:15 <x6d65> I imagine it must be something along those lines. I'm just using a vanilla mac port.
23:24:22 <x6d65> Yep, Infinity again.
23:25:56 <djahandarie> I'm getting this error whenever I try to do anything with cabal... "cabal: failed to parse output of 'ghc-pkg dump'"
23:27:06 <pastorn> x6d65: does it work after using 'mkStdGen' ?
23:27:13 <pastorn> *when
23:27:39 <x6d65> Nope.
23:27:43 <Gracenotes> is there a library for getting image metadata relatively tersely?
23:28:05 <Gracenotes> in particular, width/height for a variety of formats, and the format itself too might be nice..
23:32:39 <amuck> djahandarie: You might need a newer version of cabal-install
23:34:51 <tensorpudding> there's a library for reading exif data on hackage
23:35:08 <Gracenotes> hm. looks like gd is my only real option for size data
23:35:49 <tensorpudding> looks like it has absolutely no documentation though
23:35:58 <Silvah> Hello.
23:36:43 <Gracenotes> gd is a pretty nice actively-maintained on-the-fly image generator/analyzer, though, it seems.
23:36:46 <Gracenotes> 'lo Silvah
23:49:43 <Gracenotes> uh. Why use throwIfNull when the C API specifies that NULL is a valid return value for a function (albeit, for an exceptional case)?
23:50:05 <Gracenotes> Maybe there is a better way
23:50:25 <Silvah> Exactly because it's used to indicate error, i.e. exceptional state.
23:51:51 <Gracenotes> exceptions muddle up the semantics, though. If the method may or may not return a valid value, use Just/Nothing
23:52:17 <Gracenotes> why involve the call stack in the first place..?
23:52:21 <profmakx> ka
23:52:24 <profmakx> sry
23:53:22 <Silvah> Would you use Nothing to report e.g. out of memory (which is a fatal error in most cases)?
23:53:51 <Gracenotes> out of memory is one of those exceptional exceptions :P
23:53:55 <falbani> hi all
23:54:03 <Silvah> malloc returns null in this situation just because it can't do anything better.
23:54:33 <falbani> Does Dan Pipone around this channel at any time?
23:54:42 <Gracenotes> most choose to ignore it because recovery is either not possible or not strongly motivated
23:55:19 <falbani> Is Dan Piponi at this channel at any time? (better redaction)
23:57:30 <falbani> Anyone knows how to contact Dan Piponi? (author of http://blog.sigfpe.com/ )
23:57:53 <Silvah> Well, could you provide an example of a situation where raising an exception upon null is Bad Thing(tm)?
23:58:22 <copumpkin> preflex: seen dpiponi
23:58:22 <preflex>  dpiponi was last seen on #haskell 69 days, 7 hours, 43 minutes and 38 seconds ago, saying: Talking of IDEs, It's be fun to have an interactive code building environment like the way Coq works. I believe someone is working on something like that.
23:58:55 <copumpkin> falbani: you could try talking to him on twitter
23:59:24 <Gracenotes> Silvah: it's sort of a matter of how you define your function. in this case, the library author chose to make a function partial when it could have cleanly been total
23:59:43 <Gracenotes> namely this one  http://www.libgd.org/ImageCreation#gdImageCreateFromJpeg.28FILE_.2Ain.29_.28FUNCTION.29
