00:00:02 <dmwit> freiksenet: So, data ProjectFSElement = Directory String | File String {- declares two values, named Directory and File, that have types String -> ProjectFSElement -}
00:00:03 <alexsuraci> ManateeLazyCat: more info: http://bugs.darcs.net/issue1760
00:00:16 <freiksenet> I see
00:00:29 <dmwit> freiksenet: data PorjectFS = FSDirectory Directory {- here it's looking for a *type* named Directory, which you haven't defined -} [ProjectFSElement] ...
00:00:33 <djahandarie> Is there some f where f [1,2,3] = [[1],[1,2],[1,2,3],[2],[2,3],[3]]
00:00:50 <dmwit> > filterM (const [True, False]) [1..3]
00:00:50 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
00:00:59 <djahandarie> That has [1,3] in it
00:01:01 <freiksenet> is it possible to make type synonyms with or?
00:01:02 <djahandarie> I do not want the poweset
00:01:11 <dmwit> Oh, subsequences?
00:01:11 <freiksenet> like type ProjectFSElement = Directory | File
00:01:16 <ManateeLazyCat> alexsuraci: "darcs optimize --reorder" is necessary before "darcs convert" ?
00:01:20 <djahandarie> dmwit, subsequences has [1,3] in it also, for some reason
00:01:23 <copumpkin> djahandarie: oh, there are two fairly easy ways to make that
00:01:31 <dmead> djahandarie, map inits over your list
00:01:43 <dmead> > inits [1,2,3[
00:01:44 <copumpkin> > filter (not . null) . map tails . inits $ [1..3]
00:01:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:01:44 <dmwit> > map inits . inits $ [1..3]
00:01:45 <lambdabot>   [[[]],[[],[1]],[[],[1],[1,2]],[[],[1],[1,2],[1,2,3]]]
00:01:45 <lambdabot>   [[[]],[[1],[]],[[1,2],[2],[]],[[1,2,3],[2,3],[3],[]]]
00:01:55 <copumpkin> ugh
00:01:57 <dmwit> > inits >=> inits $ [1..3]
00:01:57 <lambdabot>   [[],[],[1],[],[1],[1,2],[],[1],[1,2],[1,2,3]]
00:02:05 <dmwit> durr
00:02:06 <copumpkin> > filter (not . null) . concatMap tails . inits $ [1..3]
00:02:07 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3]]
00:02:11 <alexsuraci> ManateeLazyCat: not that i know of
00:02:16 <dmwit> > tails >=> inits $ [1..3]
00:02:17 <lambdabot>   [[],[1],[1,2],[1,2,3],[],[2],[2,3],[],[3],[]]
00:02:18 <copumpkin> the kleisli one is cuteer though
00:02:33 <dmead> :t scannr
00:02:34 <lambdabot> Not in scope: `scannr'
00:02:38 <dmead> :t scanr
00:02:39 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
00:02:45 <copumpkin> > filter (not . null) . concatMap tails . inits $ [1..]
00:02:46 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
00:02:52 <BMeph> > tail . filterM (const [False,True]) [1..3]
00:02:53 <lambdabot>   [*Exception: Prelude.tail: empty list
00:02:57 <copumpkin> the other way around doesn't work nicely
00:03:12 <djahandarie> Nice
00:03:14 <BMeph> > filterM (const [False,True]) [1..3]
00:03:15 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
00:03:21 <djahandarie> Why wouldn't a function like this be in Data.List?
00:03:33 <BMeph> > (tail . filterM (const [False,True])) [1..3]
00:03:34 <lambdabot>   [[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
00:03:36 <dmead> djahandarie, it is... it's called inits
00:03:36 <dmwit> Nobody has ever wanted it yet!
00:03:44 <kmc> unfortunate oversight?
00:03:59 <dmwit> This function is too specialized to be in a library, I think.
00:04:05 <dmead> probably
00:04:21 <dmead> djahandarie, what are you trying to do?
00:04:30 <dmwit> BMeph: He only wants contiguous subsequences.
00:04:35 <djahandarie> dmead, nothing actually, just wanted to see if such a function existed
00:04:38 <dmead> ah
00:04:54 <dmwit> Nobody has wanted it yet... and nobody wants it now.
00:04:58 <djahandarie> lol
00:05:00 <dmead> ;p
00:05:00 <dmwit> I think I'm glad it's not in the libraries.
00:05:30 <dmead> dan
00:05:33 <dmead> i sent you an email
00:06:21 * BMeph wonders how he got into Haskell, seeing as his name is neither Dan, Don, or Simon...
00:06:34 <ManateeLazyCat> alexsuraci: You're right, darcs-2.4.4 is much faster. Thanks! :)
00:06:45 <alexsuraci> ManateeLazyCat: great, np :)
00:06:53 <dmwit> dmead: I got it.
00:07:02 <dmwit> You misspelled my name.
00:07:16 <dmwit> =)
00:07:25 <Raynes> People still use darcs?
00:07:33 <Raynes> I thought everybody revolted and stormed for Git.
00:07:40 <alexsuraci> you're thinking of svn
00:07:46 <ManateeLazyCat> Raynes: We love darcs.
00:08:26 <alexsuraci> some people use git though, the heathens
00:08:28 <ManateeLazyCat> Raynes: Git is hard to use, you don't need see manual when you use Darcs.
00:08:54 <djahandarie> Doing map tails . inits doesn't seem particularly efficient though, there is a lot of work thrown away there...
00:09:05 <BMeph> Well, time for beddy-bye, for me - see y'all in seven... :)
00:09:06 <dmead> dmwit, woops
00:09:17 <ManateeLazyCat> alexsuraci: Wow, 2222 patches convert to darcs-2 is damn fast. :)
00:09:37 <kmc> i like git
00:09:56 <ManateeLazyCat> kmc: Git have any feature that darcs can't do ?
00:10:07 <djahandarie> > length . filter null . concatMap tails . inits $ [1..10]
00:10:08 <lambdabot>   11
00:10:18 <djahandarie> 11 empty lists thrown away
00:10:20 <alexsuraci> i used git for a decent amount of time, but then was drawn towards darcs' simplicity
00:10:30 <kmc> i don't know darcs well enough to compare the two intelligently
00:10:31 <kmc> see above
00:10:44 <alexsuraci> read the manual in one sitting, found it all to be very clear and orthogonal
00:11:00 <kmc> git has a very simple data model, and a very complex set of commands
00:11:26 <kmc> it is nice, though, that the model for what's being stored is very simple
00:12:14 <alexsuraci> darcs' is pretty simple as well, patches all the way down
00:13:14 <duplode> ... so in both of my implementations of tricky there seems to be something preventing the program from letting go of the earlier parts of the list
00:13:36 * alexsuraci goes to bed
00:17:47 <dmead> goodnight channel
00:19:46 <duplode> ... must go to bed as well. Will try some ideas floated around and (probably) come back later. Thanks everybody and good night.
00:20:04 <duplode> :quit
00:24:21 * ManateeLazyCat So many guys that live in another-side of earth. :)
00:25:27 <c_wraith> time for sleep on this side of the earth as well
00:44:41 <elliottcable> so, first ever program written in Paws (the language I’ve been pouring the last half-year of my life into). Criticisms and such  welcome. http://gist.github.com/415458
00:44:46 <elliottcable> etc.
00:47:41 * hackagebot language-asn1 0.2 - Parsing of ASN1 definitions  http://hackage.haskell.org/package/language-asn1-0.2 (DmitryAstapov)
00:58:43 <quicksilver> elliottcable: cute, although it will be more impressive when it actually runs :)
00:59:12 <quicksilver> elliottcable: HTTP server "returning multiple times" is much like the haskell list monad, yes?
00:59:15 <elliottcable> quicksilver: ty. Well, there’ve been examples around for a while, but I created this one, because I’m actually close enough to executing it for it to be realistic
00:59:24 <Jafet> Perhaps you can just prove that it will run
00:59:28 <elliottcable> quicksilver: I don’t actually know Haskell. I don’t even know why I’m in here. *hides*
01:00:55 <elliottcable> I keep meaning to learn haskell, but… you know how it is. So many languages I want to stuff into my head. Some languages I want to bring *out* of my head. Must find the time somewhere, somewhen…
01:03:08 <kmc> elliottcable, you're here because all the cool kids are ;)
01:03:28 <Jafet> And some less cool ones
01:03:31 <kmc> if you want to design languages you should learn haskell though
01:03:47 <kmc> because it's so different from most languages most people have seen
01:03:57 <Jafet> I've contemplated the idea of designing a language by writing fictitious programs, but the whole idea seems funny
01:03:59 <kmc> and not all in good ways
01:04:16 <kmc> elliottcable, this code looks very interesting.  do you have a writeup of the semantics, or an implementation of some kind?
01:04:25 <kmc> btw i've found Haskell to be one of the best languages for implementing other languages
01:04:40 <kmc> and that's where most of the industrial uses have fallen too
01:05:17 <Raynes> I'm here because I used to use Haskell, but have since forgot things, but still idle here to watch interesting conversation, even though I don't use Haskell anymore. Still trying to get a bit of time to get back into it.
01:05:56 <elliottcable> yeah, I had some guy who was going to implement a Paws interpreter in Haskell, for exactly that reason
01:06:16 <elliottcable> also have/had/might have guys lined up for Objective-C, C++, C#… and I’m writing ANSI C99 and JavaScript implementations myself.
01:06:30 <elliottcable> I’m also pondering a Ruby implementation, if only for the native mapping to Ruby objectspace
01:06:58 <kmc> i'm glad that you're considering multiple implementations
01:07:04 <quicksilver> elliottcable ;)
01:07:07 <kmc> doing so forces you to specify the language properly
01:07:09 <elliottcable> oh, the language is designed for that
01:07:16 <elliottcable> the *actual language* is very *very* light
01:07:17 <kmc> Perl is deeply tied to one implementation and has suffered for it in many ways
01:07:37 <elliottcable> you have no idea; the absolute ridiculous vast majority of *everything* in “the language” is designed to be implemented in the language itself, to be bootstrapped so to speak
01:07:46 <quicksilver> elliottcable: well the language certainly has a superficial similarity to haskell so it's interesting you don't know haskell
01:07:52 <Jafet> kmc: Unlike, you know, Haskell
01:07:55 <kmc> elliottcable, that's excellent, it's how it should be done
01:07:56 <elliottcable> writing a Paws interpreter, after I complete the two reference implementations, is intended to be as easy as eating breakfast cereal
01:08:06 <quicksilver> Jafet: yes, very unlike haskell
01:08:27 <kmc> Haskell has a bit of this problem
01:08:27 <elliottcable> kmc: I’m no computer scientist, have only been programming for, urhm, two years? three years?
01:08:30 <quicksilver> Jafet: there are multiple independent implementaitons of haskell and the most popular one now was not the most popular in the early days
01:08:35 <elliottcable> kmc: but a lot of this seemed like the obvious way to do it, to me
01:08:37 <quicksilver> Jafet: really that's quite unlike perl
01:08:38 <kmc> not nearly the extent Perl does
01:09:02 <Jafet> quicksilver, it will almost certainly continue to dominate other implementations
01:09:07 <quicksilver> kmc: it is commonly believed that if anyone did ever properly specify perl 5, they would inevitably go completely mad.
01:09:12 <elliottcable> I’m glad you all like my idea :3
01:09:26 <kmc> even if H98 only had one implementation, it has a reasonably good spec
01:09:26 <elliottcable> feel free to /join ##Paws and lurk; input is ridiculously welcome, because I’m a noob who has no idea what he’s doing
01:09:37 <kmc> there are some problems with the spec of course
01:09:39 <quicksilver> Jafet: it seems likely, yes, but the benefit of separate implementations has already been felt and continues to be felt.
01:09:41 <kmc> including the lack of operational detail
01:09:51 <quicksilver> Jafet: and new implementations continue to appear (LHC, EHC)
01:09:55 <kmc> which is good for theorists but makes it hard to write truly portable high-performance code
01:10:05 <Jafet> quicksilver, there is a complete specification of perl 5. Larry just reveals the parts of it that you need to know!
01:10:31 <quicksilver> Jafet: Cthulhu^WLarry lures us all.
01:10:46 <elliottcable> quicksilver: re: similarity to Haskell… I’ve had people say Paws is Lisp, say Paws is JavaScript, say Paws is Io, say Paws is Ruby, say Paws is *everything*. The core language is so simple, that you can mapp Your Favourite Feature™ from pretty much any language onto Paws fairly easily.
01:11:04 <kmc> that sounds like Lisp ;P
01:11:13 <elliottcable> yep pretty much
01:11:15 <elliottcable> also, everything’s a list
01:11:18 <elliottcable> so, Lispy! woo.
01:11:26 <kmc> beware of the situation where everything is possible but nothing is standard
01:11:35 <quicksilver> elliottcable: I was speaking a bit more superficially, to be honest, but <- looks a lot like monadic bind and your implicit multiple returns are very like the list monad.
01:11:40 <kmc> there's a reason Lisp is successful for one-man hacker projects and not for big industrial software
01:11:41 <elliottcable> kmc, quicksilver, /join ##Paws and lurk if you can, I’d like to pick y’all’s brains some other time.
01:13:07 <elliottcable> kmc: yes… on a less technical note, I’m a huge psychology aficionado. The vast majority of this project won’t be writing an interpreter… it will be applying minute societal pressures to affect *how* people use the language. I want to cause ecologies of code that impose standards upon the developers who work within those ecologies, while still allowing developers to ‘break the rules’ when they really have to
01:13:27 <kmc> yeah
01:13:35 <elliottcable> but yeah… thanks for the compliments :D, but this is #Haskell. I’ll get off my Paws horse.
01:13:50 <Raynes> What is Paws? :o
01:14:02 <elliottcable> Raynes: http://gist.github.com/412666
01:14:06 <elliottcable> oh sh
01:14:07 <elliottcable> wrong gist
01:14:17 <elliottcable> don’t click that your head will explode
01:14:19 <elliottcable> Raynes: http://gist.github.com/415458
01:14:36 * elliottcable puts on some Rachmaninov and goes back to writing C
01:14:55 <Raynes> Neat.
01:16:43 <ksf> hey someone voted my tutorial to be on the top of the top 7 tutorials 2009
01:16:50 * hackagebot hdaemonize 0.4 - Library to handle the details of writing daemons for UNIX  http://hackage.haskell.org/package/hdaemonize-0.4 (FrederickRoss)
01:16:52 <kmc> tutorial on what?
01:17:05 <ksf> typeclassopedia is on place 6, eat that, byorgey!
01:17:09 <ksf> what a monad is not
01:17:12 <djahandarie> Tutorial on how to get on the top 7 tutorials for 2009 list
01:17:23 <kmc> nice
01:18:08 <ksf> hmmm. maybe they're in reverse chronological order.
01:18:16 <ksf> but that'd be mean.
01:18:25 <ksf> http://haskellwebnews.wordpress.com/2009/12/20/the-year-in-haskell/
01:19:37 <Jafet> elliottcable, http://www.dangermouse.net/esoteric/whenever.html
01:20:25 <elliottcable> Jafet: heh, somebody accused Paws of being that
01:21:08 <elliottcable> Jafet: there’s a possible feature working its way into the design right now wherein the lines are ordered based on result dependency, thus allowing the possibility that varous lines within your function will be executed concurrently or out-of-order >,>
01:21:15 <elliottcable> Jafet: and people call me insane, psh <,<
01:21:44 <Jafet> You should study other languages and how they approach concurrency
01:21:55 <Jafet> Unless Paws is a humour language, then go right ahead
01:22:09 <ManateeLazyCat> Can you access code.haskell.org now ?
01:22:41 <Jafet> Declarative imperative doesn't sound like a mode I want to think about code in
01:30:56 <ketil> I'd like to use the xml-model PI for associating documents to relaxng schemata.  Apologies for rather off-topic question, but does any of the Haskell XML kits support this (i.e. parse the PI, fetch the schema, and validate)?
01:31:31 <ketil> I expect only small documents, probably less than a megabyte, so efficiency isn't crucial.
01:36:54 <quicksilver> I would be almost certain the answer is no, ketil
01:38:14 <quicksilver> on the one hand, I don't think any of the common XML libraries does any validation anyway, and on the other hand, xml-model is really quite new and not much supported anywhere.
01:39:03 <quicksilver> ah, I'm wrong about validation, HXT does have relaxng and looks like it might have some schema
01:39:06 <ketil> quicksilver, hm.  I'm sure I've seen something about validation, and if I can get at the PIs, it should be relatively trivial (if that is possible to say?) to do this.
01:40:23 <quicksilver> sure, it shouldn't be hard to put together if the validation part is the right kind
01:48:48 <ManateeLazyCat> How to create new repository at code.haskell.org ?
01:48:52 <ManateeLazyCat> I have account.
01:49:40 <Kouma> @src const
01:49:40 <lambdabot> const x _ = x
01:56:42 <Kaidelong> I need some way to find out in advance if a read will fail
01:56:56 <quicksilver> use reads not read
01:56:57 <Kaidelong> inside the pure code
01:57:07 <quicksilver> in fact, 'read' is a toy and should never be used
01:57:11 <quicksilver> 'reads' is the real function.
02:00:29 <quicksilver> > let tryToRead x = case reads x of [] -> Left "Failure"; [(x,"")] -> Right x; [(x,s)] -> Left "Success but trailing junk"; _ -> Left "Multiple (ambiguous) successes" in tryToRead "abc" :: Either String Int
02:00:30 <lambdabot>   Left "Failure"
02:00:32 <Kaidelong> quicksilver: if that is what I want, it fulfills it in an overcomplicated way
02:00:58 <Kaidelong> hmm
02:00:59 <ibt> why is read so slow?
02:01:00 <quicksilver> > let tryToRead x = case reads x of [] -> Left "Failure"; [(x,"")] -> Right x; [(x,s)] -> Left "Success but trailing junk"; _ -> Left "Multiple (ambiguous) successes" in map tryToRead ["abc","2","2fg"] :: [Either String Int]
02:01:01 <lambdabot>   [Left "Failure",Right 2,Left "Success but trailing junk"]
02:01:23 <quicksilver> Kaidelong: I don't think it's overcomplicated. It's almost exactly as complicated as it needs to be.
02:01:33 <quicksilver> you can obviously write a convenient function to call it in the way that suits you.
02:02:04 <quicksilver> maybeRead x = case reads x of [(v,"")] -> Just v; _ -> Nothing
02:02:08 <quicksilver> is often enough.
02:02:32 <quicksilver> ibt: not sure, to be honest, but it's a fairly naive parser not designed for speed.
02:02:34 <Kaidelong> :t maybeRead x = case reads x of [(v,"")] -> Just v; _ -> Nothing :: String -> Maybe Int
02:02:35 <lambdabot> parse error on input `='
02:02:45 <Kaidelong> oh right
02:02:57 <Kaidelong> :t (\x = case reads x of [(v,"")] -> Just v; _ -> Nothing) :: String -> Maybe Int
02:02:59 <lambdabot> parse error on input `='
02:03:07 <Kaidelong> :t (\x -> case reads x of [(v,"")] -> Just v; _ -> Nothing) :: String -> Maybe Int
02:03:09 <lambdabot> String -> Maybe Int
02:03:17 <Kaidelong> ok, I'll use that then
02:06:17 <ibt> quicksilver: yeah, my program sped up dramatically when switching to attoparsec
02:07:02 <ManateeLazyCat> Oh, god, i forgot my ssh password to community.haskell.org , any way to change password through mail?
02:07:18 <copumpkin> tsk tsk ssh password auth
02:07:24 * copumpkin never forgets his private key
02:07:30 <quicksilver> ManateeLazyCat: I think you'll need to ask the maintainers for a reset
02:07:34 <quicksilver> and yes, next time, set up a key :)
02:08:04 <ManateeLazyCat> quicksilver: Can't change password through mail confirm?
02:08:26 <ManateeLazyCat> quicksilver: I have one RSA key in my box.
02:08:39 <ManateeLazyCat> quicksilver: I need ssh community.haskell.org to build new repository.
02:08:51 <copumpkin> omg dsa rulz rsa droolz
02:09:04 <Botje> copumpkin: what, all 4096 bits of it?
02:09:14 <Botje> mine ends with a 1 ^^
02:09:16 <copumpkin> depends :)
02:09:31 <copumpkin> thawte had a 16 kilobit rsa key at some point
02:09:38 <copumpkin> not sure how they even generated it
02:09:41 <quicksilver> ManateeLazyCat: I don't think you can, no.
02:09:48 <quicksilver> ManateeLazyCat: I think you have to ask a maintainer
02:10:24 <ManateeLazyCat> quicksilver: Oh, i can't build new repository now, i will ask Axel build them for me. :)
02:10:41 <yuriks> Hey
02:10:48 <copumpkin> allo
02:10:53 <yuriks> is it just me or does the Parsec site need to be updated?
02:12:02 <yuriks> last update on the docs seems to be from 2001
02:12:11 <yuriks> is there newer documentation somewhere?
02:17:53 <mxc> hi
02:18:10 <mxc> just curious if anyone knows about any IPC/netowrked versions of Control.Concurrent.Chan
02:18:21 <mxc> i rolled my own using Data.Binary but its not so good..
02:18:27 <copumpkin> I wrote a networked Chan too!
02:18:39 <copumpkin> I still haven't gotten around to vacuuming it though :(
02:18:46 <copumpkin> and now that mmorrow's disappeared it'll make it hard
02:18:52 <vegai> me too, and it also sucked! :)
02:18:53 <djahandarie> Vacuum is cool
02:18:54 <pastorn> copumpkin: "vacuuming it"?
02:18:59 <quicksilver> there is mobile haskell, mxc
02:19:09 <copumpkin> pastorn: preserving tied knots in serialization, and more
02:19:16 <quicksilver> which lets you send any type including functions and IO actions over a network chan
02:19:29 <copumpkin> pastorn: basically serializing anything that isn't a function or a lazy infinite structure
02:19:39 <quicksilver> doesn't preserve sharing or knots though.
02:19:48 <copumpkin> how do you send functions over?
02:19:51 <copumpkin> it's not GHC?
02:19:56 <kmc> http://hackage.haskell.org/package/net-concurrent ?
02:20:00 <djahandarie> Oh, I see that you are talking about something entirely different than me...
02:20:12 <quicksilver> copumpkin: for local/dynamic functions it uses ghci's bytecode
02:20:24 <copumpkin> quicksilver: oh, very nice
02:20:27 <quicksilver> copumpkin: for 'library' functions it just uses the symbol table name and sends over the closure
02:20:39 <copumpkin> quicksilver: that sounds wonderful! is it up to date?
02:20:49 <quicksilver> it's phd-ware
02:20:59 <quicksilver> I read the paper but for all I know it may not actually exist.
02:20:59 <copumpkin> oh
02:21:02 <mxc> thanks kmc
02:21:09 * copumpkin petititons to get it integrated
02:21:10 <quicksilver> http://www.macs.hw.ac.uk/~dubois/mhaskell/
02:21:19 <copumpkin> http://www.macs.hw.ac.uk/~dubois/mhaskell/
02:21:20 <copumpkin> lol
02:21:22 <copumpkin> ok
02:21:24 <mxc> doesn't have chans, but I guess I can kinda copy the src for chan and replace the MVars with NVars with a few modes
02:21:25 <mxc> mods
02:21:27 <copumpkin> 2004 :/
02:21:33 <copumpkin> AND
02:21:42 <copumpkin> the worst sign ever, an animated gif of a workman
02:21:46 <quicksilver> mxc: not sure if you want to do that.
02:21:49 * copumpkin loses all hope
02:21:58 <quicksilver> mxc: then you'd have a chan which could be distributed all over the place along its length
02:22:08 <quicksilver> like a network thunk snake.
02:22:23 <mxc> true
02:22:34 <copumpkin> then people can pull out the abandoned gang stuff in dph
02:22:38 <copumpkin> and make awesome magic
02:23:06 <quicksilver> mobile haskell is at least not as old as gdh
02:23:40 <kmc> "network thunk snake"
02:23:42 <kmc> that is awesome
02:24:14 <mxc> actually, wouldn't sending things over the network force them to be evaluated?
02:24:48 <mxc> since you'd have to serialize them somehow, and as discussed last night, there is no way to serialize anything thats not hnf
02:25:08 <quicksilver> of course there is, mxc
02:25:19 <quicksilver> it requires RTS cooperation, but its' possible
02:25:36 <quicksilver> the mobile haskell thing I was doing decided not to, though. They decided to force everything.
02:25:42 <quicksilver> s/doing/talking about/
02:25:54 <mxc> ^no currently implemented means of serializing non hnf data
02:26:06 <quicksilver> I'm not even sure that much is true, mxc.
02:26:12 <quicksilver> There is a lot of prior art in this area
02:26:13 <mxc> i mean yes, in theory, you could just copy the stack
02:26:28 <quicksilver> gdh and yhc both had ways of serialising arbitrary closures
02:26:32 <mxc> but in haskell, AFAIK, there is not current library for doing that
02:26:42 <quicksilver> there is no reasong they couldn't have applied it to thunks
02:26:45 <quicksilver> (although I don't know if they did)
02:26:45 <mxc> without hacking GHC
02:26:55 <quicksilver> you can't do it *within* haskell, no
02:26:58 <mxc> i thought this was discussed her yesterday
02:27:00 <quicksilver> it's not a referentially transparent notion.
02:27:01 <quicksilver> I was.
02:27:01 <mxc> hehe :)
02:27:06 <quicksilver> it needs RTS support.
02:28:12 <mxc> yeah
02:28:54 <pastorn> :(
02:28:57 <pastorn> :! reset
02:29:05 <pastorn> doesn't work properly in ghci any more :(
02:29:36 <pastorn> well, it works, but it kills keyboard input
02:30:30 <pastorn> <C-d> to leave (and the terminal works properly after that) yields <stdin>: hWaitForInput: end of file
02:32:42 <freiksenet> python has this String.join function that takes a list of strings and separator and joins string with that separator, is there such thing built in in haskell standard library?
02:33:00 <pastorn> @type intercalate
02:33:01 <lambdabot> forall a. [a] -> [[a]] -> [a]
02:33:06 <pastorn> @type intersperse
02:33:06 <lambdabot> forall a. a -> [a] -> [a]
02:33:18 <pastorn> freiksenet: ^^^ there you go
02:33:24 <pastorn> (they're in Data.List)
02:33:31 <freiksenet> thanks
02:39:16 <ManateeLazyCat> :> withUTF8FileContents
02:39:22 <ManateeLazyCat> :t withUTF8FileContents
02:39:23 <lambdabot> Not in scope: `withUTF8FileContents'
02:39:31 <ManateeLazyCat> :t withFileContents
02:39:32 <lambdabot> Not in scope: `withFileContents'
02:39:55 <Lemmih> @seen dcoutts_
02:39:56 <lambdabot> Unknown command, try @list
02:40:07 <Lemmih> preflex: @seen dcoutts_
02:40:07 <preflex>  dcoutts_ was last seen on #haskell 14 days, 15 hours, 43 minutes and 6 seconds ago, saying: m_88: yes, it's only since 6.12 that it supports making packages into .so libs
02:40:17 <Lemmih> preflex: @seen dcoutts
02:40:17 <preflex>  dcoutts was last seen on #haskell 7 hours, 20 minutes and 43 seconds ago, saying: interferon: np
02:45:17 <pastorn> Jonno_FTW: hello
02:45:23 <Jonno_FTW> hello
02:45:26 <pastorn> Jonno_FTW: i made a small example using fastirc
02:45:31 <pastorn> u wantz?
02:45:35 <Jonno_FTW> sure
02:46:45 <pastorn> Jonno_FTW: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25763
02:47:34 <Jonno_FTW> nice
02:48:30 <Jonno_FTW> i like that it is written with english
02:48:35 <pastorn> yeah, well... i should probably print the actual string that i get from the handle and not the interpreted Message
02:48:44 <pastorn> haha
02:50:07 <pastorn> Jonno_FTW: it's quite annoying how there's ByteStrings everywhere, but it's still possible to work with
02:50:16 <Jonno_FTW> hmk
02:50:33 <pastorn> the Command type is much nicer than the types that you get from the irc librar
02:52:06 <Jonno_FTW> so how would I add to this base you have made?
02:52:16 <pastorn> you wouldn't :p
02:52:39 <Jonno_FTW> would it actually do anything useful?
02:52:46 <pastorn> you'd make your own monad, probably with StateT and ReaderT (to put your bots state in and to put the handle in the Reader)
02:53:30 <pastorn> then you'd make two functions, one for reading from the handle (which you've stuck inside a ReaderT) and one to write to
02:55:11 <pastorn> Jonno_FTW: that way you don't have to send the Handle around explicitly everywhere, it's implicitly carried around :)
02:55:20 <Jonno_FTW> neat
02:55:35 <pastorn> Jonno_FTW: hang on, i'll make those changes...
02:56:16 <pastorn> Jonno_FTW: cabal install fastirc
02:56:20 <pastorn> then use
02:56:23 <pastorn> :i a lot
02:56:27 <Jonno_FTW> thanks
03:04:37 * pastorn derives instances of MonadState (), MonadWriter ()
03:04:42 <pastorn> because i can!
03:06:46 <opqdonut> :D
03:08:26 <pastorn> -XGeneralizedNewtypeDeriving is awesome :D
03:09:17 <earthy> it is.
03:21:58 <pastorn> Jonno_FTW: hmm...
03:22:06 <pastorn> it doesn't want to typecheck :(
03:22:19 <Jonno_FTW> D:
03:25:07 <pastorn> oh, i was using 'lift' and not 'liftIO' :(
03:27:53 <Cale> pastorn: Those look silly with the ()'s there.
03:28:14 <pastorn> Cale: which?
03:28:27 <pastorn> deriving (MonadState ()...) etc?
03:28:28 <ski> pastorn : .. you should derive instances of `MonadState Void' and `MonadWriter Void'
03:28:34 <pastorn> it's for future use
03:29:07 <ski> (hm, maybe not the latter, on second thought, though)
03:30:47 <pastorn> @hoogle ByteString -> Handle -> IO ()
03:30:47 <lambdabot> Data.ByteString hPut :: Handle -> ByteString -> IO ()
03:30:47 <lambdabot> Data.ByteString hPutStr :: Handle -> ByteString -> IO ()
03:30:47 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
03:35:57 <interferon> i have a haskell program that processes 211 files and i'm getting a "too many open files" error - is there a strict alternative to readFile, i.e. one that doesn't use lazy hGetContents?
03:36:45 <ManateeLazyCat> interferon: Ah, i have a library that have same error.
03:36:47 <ManateeLazyCat> interferon: Open too many files. :)
03:37:14 <quicksilver> interferon: s <- readFile "foo"; return $! length s
03:37:17 <ManateeLazyCat> @hackage proc
03:37:17 <lambdabot> http://hackage.haskell.org/package/proc
03:37:26 <ManateeLazyCat> @proc
03:37:26 <lambdabot> Maybe you meant: rc src
03:37:28 <quicksilver> interferon: or use the readFile from strict bytestring
03:38:23 <Cale> http://jila.colorado.edu/~ajsh/insidebh/intro.html -- this is cool
03:38:36 <ManateeLazyCat> quicksilver: What's the `$!` ?
03:39:03 <Cale> Probably better to use Control.Exception.evaluate
03:40:49 <dschoepe> ManateeLazyCat: like $, but it forces the evaluation of its argument
03:41:05 <Cale> But yeah, using the strict bytestring readFile and then converting back to a string is less sneaky and works well.
03:42:05 <interferon> Cale: how do i convert from a BS to a String?  show?
03:42:38 <quicksilver> interferon: unpack
03:42:49 <quicksilver> as long as you don't need unicode
03:42:59 <quicksilver> if you need unicode, then use an appropriate 'decode' function
03:44:43 <pastorn> Jonno_FTW: haha... ok, this won't be the most efficient use of this library :/
03:44:57 <pastorn> but it's still a good library (good abstractions etc.)
03:44:58 <Jonno_FTW> .....
03:45:01 <Jonno_FTW> ok
03:45:34 <pastorn> Jonno_FTW: i read a ByteString from the Handle, then i get it parsed to a Message (done automagically) bit then i convert it back to a ByteString to print it
03:46:11 <Jonno_FTW> wow
03:46:29 <Jonno_FTW> a bit of a roundabout method there
03:46:48 <pastorn> Jonno_FTW: well, the dude who wrote this probably didn't think that people wanted to have incoming/outgoing messages printed
03:47:16 <pastorn> Jonno_FTW: as long as you don't try to make an EFNet server it's gonna be fine :)
03:47:30 <Jonno_FTW> sounds good
03:47:34 <Jonno_FTW> source?
03:47:38 <pastorn> soon
03:48:07 <interferon> @hoogle "ByteString -> String"
03:48:07 <lambdabot> Parse error:
03:48:07 <lambdabot>   --count=20 ""ByteString -> String""
03:48:07 <lambdabot>              ^
03:48:08 <pastorn> i fixed hGetMessage ===> getMessage
03:48:17 <interferon> @hoogle ByteString -> String
03:48:17 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
03:48:18 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
03:48:18 <lambdabot> Prelude show :: Show a => a -> String
03:50:21 <ManateeLazyCat> Do you all use utf-8 locale? If not, maybe gtk2hs will failed to install.
03:52:37 * ManateeLazyCat Maybe we need release gtk2hs-0.11.1 now......
03:52:38 <interferon> will "id $! readFile "foo" "  read all of file "foo" and then close the file?
03:53:07 <quicksilver> interferon: no.
03:53:12 <quicksilver> interferon: "length" is important.
03:53:15 <interferon> quicksilver: just returns a thunk?
03:53:19 <quicksilver> (and stupid, in equal measure)
03:53:28 <quicksilver> forcing a list just forces the top constructor
03:53:32 <quicksilver> the (:)
03:53:38 <quicksilver> so that only guarantees one character is read.
03:53:42 <interferon> but if i want to get the actual string back, what do i do with the length value?
03:53:46 <quicksilver> (in practice, probably 1 block)
03:53:47 <Jafet> lol deepseq lol
03:53:52 <quicksilver> nothing, interferon
03:53:54 <quicksilver> you just ignore it.
03:54:13 <Jafet> You must ignore it in IO
03:54:19 <interferon> quicksilver: but won't it get optimized away?
03:54:19 <quicksilver> s <- readFile "foo"; return $! length s; and now do something with s
03:54:20 <Jafet> So that it does not get ignored
03:54:23 <quicksilver> interferon: no.
03:54:26 <interferon> ah i see
03:54:40 <interferon> btw, BS.unpack <$> BS.readFile "foo" did the trick
03:54:46 <quicksilver> yes, that's a much better solution.
03:54:47 <interferon> no more "too many open files" errors
03:54:55 <quicksilver> this is essentially a bug in the language spec.
03:55:04 <quicksilver> readFile and getContents and hGetContents are broken.
03:55:04 <Cale> It may make more sense to use Control.Exception.evaluate for things like that, since it means exactly what you want :)
03:55:15 <Cale> evaluate (length s)
03:55:40 <pastorn> Jonno_FTW: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25763
03:55:43 <quicksilver> Cale is right. I dislike evaluate because it is a new primitive, which even the implementors could not give a denotational spec for, and it's un-necessary.
03:55:59 <quicksilver> I'd rather have one primitive (seq) which does have a denotational spec, and understand that one well.
03:56:05 <quicksilver> than two, one of which people don't understand.
03:56:39 <Cale> quicksilver: Well, evaluate x is just an IO action which when executed, causes the expression x to be evaluated.
03:56:43 <zygoloid> interferon: in (id $! readFile "foo"), only the IO action is forced, not its result.
03:56:51 <pastorn> Jonno_FTW: IT PONGS!
03:56:56 <quicksilver> Cale: informally, I know what it means.
03:57:02 <Jonno_FTW> BY THE GODS
03:57:08 <pastorn> exactly
03:57:08 <zygoloid> in fact, (id $!) is id :)
03:57:26 <quicksilver> Cale: but the long debate during which it was shown that the spec in the docs was broken and no one could fix it
03:57:31 <Cale> The reason it's not a purely denotational spec is that we don't have much of a denotational spec for IO in general.
03:57:33 <interferon> Cale: oh i didn't realize you were suggesting that to me :)
03:57:33 <quicksilver> Cale: made me think it was more trouble than it was worth.
03:57:38 <Kodpoet> I've just started following the ahaskell tutorial and noticed he has a colored prompt in ghci. How do you get that? :)
03:58:03 <interferon> quicksilver: yeah, i think hGetContents's behavior is a little weird
03:58:34 <zygoloid> does forcing length s, where s is produced by a lazy file read, actually guarantee to read the file?
03:58:49 <zygoloid> (would it be legal for an implementation to just stat it, and only read the contents when the characters themselves are forced?)
03:59:13 * zygoloid guesses that haskell'98 does not specify
04:00:05 <interferon> zygoloid: the important thing is that you do it in the IO monad, as was just pointed out to me :)
04:00:22 <quicksilver> zygoloid: lazy file reads are not really specified
04:00:32 <zygoloid> quicksilver: yeah, that's what i thought. :-/
04:00:33 <quicksilver> zygoloid: they're just described as an off-hand remark as if they're obvious and natural.
04:00:52 <quicksilver> zygoloid: when in fact they *seem* obvious, but they are deeply subtle and invidious.
04:01:06 <quicksilver> useful, sure.
04:01:10 <quicksilver> but subtle and invidious nonetheless.
04:01:18 <dantheman_> Hey all, say I have a function wrapped in a maybe type (i.e. Maybe (a -> b)), and I want to apply it to a value of type a, what's the best way to do it?
04:01:31 <quicksilver> dantheman_: `ap` is for exactly that purpose
04:01:37 <dantheman_> ah.
04:01:44 <quicksilver> dantheman_: but you'll need a 'Just'
04:01:57 <dantheman_> sorry I don't quite get you?
04:01:58 <quicksilver> `ap` actually applies it to a value of "Maybe a"
04:02:02 <quicksilver> and if you have an "a"
04:02:02 <zygoloid> dantheman_: ($a) <$> mf
04:02:08 <quicksilver> you'll need to wrap it in Just
04:02:10 <zygoloid> dantheman_: where a :: a, mf :: Maybe (a -> b)
04:02:17 <quicksilver> zygoloid's alternative also works.
04:02:35 <dantheman_> ah, you mean (Just a) ap maybeFn
04:02:44 <quicksilver> maybeFn `ap` Just a
04:02:52 <quicksilver> or : ap maybeFn (Just a)
04:02:56 <quicksilver> if you prefer prefix.
04:03:12 <dantheman_> ah ok, thanks.
04:03:20 <quicksilver> Argubaly zygoloid's is smarter because it only uses the Functor instance not the Monad/Applicative one
04:03:22 <zygoloid> or: fmap ($ a) maybeFn, which requires only Functor, not Applicative :)
04:03:29 <quicksilver> beat you :)
04:03:34 <zygoloid> damn ;)
04:04:19 <zygoloid> if you prefer do-notation, there's: do f <- maybeFn; return (f a)
04:04:36 * quicksilver can't imagine anyone preferring that for this case
04:04:49 <quicksilver> but, I suppose, it shows you how you might solve more complex problems in a similar vein.
04:09:34 <interferon> so does a file read with readFile ever get closed?
04:11:17 <quicksilver> interferon: yes, when you read the last character from it.
04:11:23 <quicksilver> at least, that's how it's supposed to work.
04:11:31 <interferon> i see
04:17:23 <interferon> do most people connect their haskell web servers to apache via modcgi or scgi?
04:17:51 <quicksilver> fastcgi, I suspect
04:18:03 <Jafet> The web servers I've written so far come with httpd
04:18:11 <quicksilver> fastcgi is certainly what I'd recommend
04:18:16 <Jafet> They're toy, though
04:19:27 <quicksilver> I have written compiled apps and just used CGI which is more workable in haskell than, say, perl, because the startup of a compiled haskell app is much faster than a perl script
04:19:36 <quicksilver> fastcgi is the way to go for any kind of volume, though.
04:20:03 <quicksilver> scgi has the same basic advantages, I don't know why it isn't more popular.
04:21:43 <interferon> are there many haskell websites in production?
04:21:56 <interferon> i've seen vocabulink
04:22:11 <interferon> just trying to understand where the momentum is
04:22:14 <Jafet> ...the haskell website?
04:22:20 <interferon> as far as haskell web frameworks
04:22:37 <Jafet> Hackage is probably another
04:22:39 <quicksilver> yes, but not many, interferon
04:22:49 <quicksilver> Jafet: the haskell website is mediawiki which is PHP, no?
04:22:53 <Jafet> Most are dogfoodies like those, though
04:23:09 <Jafet> I thought I read that it uses a haskell httpd
04:23:26 <quicksilver> hackage is static html
04:23:31 <Jafet> Also, the mediawiki is in a subdirectory
04:23:35 <quicksilver> although that html is probably generated by a haskell process
04:23:57 <quicksilver> http://www.haskell.org/ is a wiki page
04:24:04 <quicksilver> irrespective of the paths being used :)
04:24:19 <interferon> so i see yesod, snap, and happstack - are there any other widely-used frameworks?
04:24:23 <quicksilver> http://www.haskell.org/ is http://www.haskell.org/haskellwiki/Haskell
04:24:35 <interferon> actually, i read the vocabulink source and i was impressed at how little a framework seemed necessary
04:24:44 <quicksilver> interferon: there are no widely used frameworks, in any sensible sense of 'widely-used'
04:24:55 <quicksilver> interferon: none of those three is remotely widely used.
04:25:35 <quicksilver> apart from the ones you mentioned there is WASH
04:25:48 <quicksilver> turbinado
04:25:59 <quicksilver> I think more, but don't remember.
04:26:08 <quicksilver> I thought there was a good list on the wiki but I can't find it.
04:26:10 <interferon> oh WASH, that's right
04:26:21 <quicksilver> hpaste.org is haskell
04:26:26 <quicksilver> that's happstack, I believe.
04:27:11 <interferon> cool
04:27:25 <Guest54618> snap is damn cool I must say
04:27:25 <kmc> it's also often broken
04:27:28 <Guest54618> Damn fast also
04:27:49 <interferon> i played with snap, i guess i don't yet see how it's better than happstack
04:29:30 <interferon> also, i'm looking for an improvement over haskell's default records, can people recommend any of the record extensions?
04:30:07 <kmc> there are libraries
04:30:11 <kmc> fclabels, data-accessor, lenses
04:30:13 <kmc> i don't know which is best
04:31:04 <quicksilver> fclabels seems to be gaining momentum.
04:31:23 <quicksilver> I'm not sure I would choose the phrase 'record extension', pedantically.
04:31:34 <kmc> GHC has a few record-related extensions
04:31:34 <quicksilver> but 'lens library' or 'first class label' library, sure ;)
04:31:49 <quicksilver> yeah, I don't like any of them. (The GHC extension)
04:31:52 <kmc> which are handy sugar
04:31:55 <kmc> why not?
04:32:05 <quicksilver> IMO they make a simple, flawed system into a complex flawed system.
04:32:08 <kmc> they don't fix the more significant problems with records
04:32:15 <quicksilver> and right, they dont' fix the big issues.
04:32:22 <quicksilver> cost/weight ratio is wrong.
04:32:24 <kmc> i don't think puns and wildcards complicate the system much
04:32:33 <quicksilver> not theoretically, no
04:32:33 <kmc> they are just sugar that saves a lot of boilerplate
04:32:43 <quicksilver> they're type-wrong sugar though.
04:32:58 <kmc> oh?
04:33:13 <quicksilver> only intuitivelym I mean. If data Car { numOfWheels :: Int }
04:33:19 <quicksilver> then numOfWheels :: Car -> Int
04:33:26 <quicksilver> the 'field' is really an accessor.
04:33:36 <quicksilver> understanding this is, IMO, the key to coping with the system.
04:33:47 <quicksilver> The punning extensions let you (in some contexts) use numOfWheels as an Int
04:33:56 <quicksilver> whilst in other contexts it will still be Car -> Int
04:34:05 <quicksilver> I don't like "punning" or shadowing a variable by one of a different type.
04:34:11 <kmc> but that's just like saying "let numOfWheels = 3 in ()"
04:34:16 <eikke_> is there a tailP in DPH?
04:34:16 <quicksilver> this is just an aesthetic point
04:34:20 <kmc> ok, if you object to shadowing then i see the objection :)
04:34:23 <quicksilver> of course it's perfectly type-safe.
04:34:32 <quicksilver> kmc: in particular, shadowing at a different type.
04:34:40 <quicksilver> kmc: I think it invites intuitive misunderstandings.
04:34:53 <quicksilver> of course, if you do have a firm appreciate of what's actually going on, it is a harmless shortcut.
04:35:05 <quicksilver> but I think it's bad for intuition/learning.
04:35:09 <interferon> is the record system being revamped in the next revision of haskell?
04:35:12 <quicksilver> no.
04:35:34 <quicksilver> Nobody has a proposal for a better one, basically.
04:35:57 <pastorn> is it hard to detect infinite types? (like lists)
04:35:59 <quicksilver> Personally I think the fact you can write something like fclabels or data-accessor as a pure library means the language may not need changing - or not much.
04:36:11 <interferon> quicksilver: that is true
04:36:19 <interferon> but one needs to win out over the others
04:36:25 <quicksilver> certainly I think we need more experience with using them
04:36:30 <quicksilver> to learn what's good and what's not so good
04:36:36 <quicksilver> and then possibly suggest standardising one
04:36:52 <quicksilver> or even small language changes which make one a bit neater / more efficient. If warrented.
04:40:44 <interferon> fclabels looks interesting
04:40:53 <interferon> is there a good tutorial on them?
04:41:29 <quicksilver> not that I know of.
04:41:35 <quicksilver> (which is not to say "No")
04:41:43 <interferon> :)
04:42:08 <Botje> i saw something like it pass in my rss reader
04:42:25 <quicksilver> ezyang wrote a blog post
04:42:26 <quicksilver> http://blog.ezyang.com/2010/04/inessential-guide-to-fclabels/
04:42:30 <quicksilver> I haven't read it.
04:42:44 <quicksilver> But ezyang is a #haskell regular, so his words are probably gospel.
04:43:02 <Botje> http://blog.ezyang.com/2010/04/inessential-guide-to-fclabels/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+ezyang+%28Inside+245s%29&utm_content=Google+Reader
04:43:09 <Botje> .. that. :)
04:43:13 <quicksilver> I just pasted that, but with less google crap, Botje ;)
04:43:30 <Botje> yeah, i noticed when i hit enter
04:43:36 <quicksilver> also, there is a comment on that post from edwardk.
04:43:42 <Botje> and boo for the google crap
04:43:52 <quicksilver> edwardk++
04:46:50 <kmc> cool just by hanging out here a lot we get the power of canon?
04:47:03 <kmc> the fclabels hackage page has a little tutorial
04:47:18 <kmc> there's not a lot to it; mostly the types say everything
04:49:53 <quicksilver> kmc: as long as you've spent long enough thinking about lenses to see what the types are for, yes.
04:50:04 <quicksilver> kmc: hanging out isn't enough, you have to talk.
04:50:09 <quicksilver> This is a loquacracy.
04:50:15 <kmc> heh
04:50:18 <quicksilver> (Actually, it's the first loquacracy)
04:55:53 <eikke_> anyone knows what 'Tycon not vectorised: []' is about?
04:57:41 <benc__> whats the cool way for making HTML in haskell at the moment?
04:58:49 <kmc> eikke_, in what context?
04:59:28 <eikke_> kmc: compiling a piece of DPH code
05:01:53 <dhouthoo> BlazeHTML ?
05:02:50 <quicksilver> does that exist?
05:02:57 <quicksilver> I thought that was being design, not in existence yet?
05:03:55 <dhouthoo> ah I assumed it was ... jaspervdj demonstrated it at a meeting
05:03:56 <benc__> its got a github page at least
05:03:57 <dhouthoo> so maybe not
05:06:17 <arcatan> it's his GSoC project, so supposedly it's coming, at least.
05:06:56 <quicksilver> there is a prototyp AIUI
05:07:00 <quicksilver> but the API will change
05:07:07 <quicksilver> so coding against the prototype might be a mistake.
05:07:09 <benc__> maybe thats too early for me then
05:07:36 <quicksilver> there is the old HTML/XHTML librar(y|ies)
05:07:43 <quicksilver> and there are various templating approaches.
05:08:00 <benc__> i just tried to get HXT off hackage but it has build dependency brokenness here
05:08:02 * benc__ sighs
05:08:19 <benc__> just feels wrong to be writing "<html>" ++ foo
05:08:56 <kmc> if you're doing that you can use Text.PrettyPrint, at least
05:09:09 <quicksilver> benc__: http://hackage.haskell.org/package/xhtml or http://hackage.haskell.org/package/xhtml-combinators ?
05:09:18 <eikke_> grr, /me has some code which works fine in the 'normal' case, but fails once converted into DPH
05:09:41 <quicksilver> Apart from that, templates are a good solution in many cases
05:10:16 <benc__> ok
05:10:17 <quicksilver> http://fmapfixreturn.wordpress.com/2008/01/14/hstringtemplate-an-elegant-functional-nifty-templating-engine-for-haskell/
05:10:35 <quicksilver> templates are (IMO) better for pages with a large fixed structure and small dynamic bits inside.
05:10:47 <quicksilver> combinators are better for complex, composable, abstractable HTML building.
05:10:57 <quicksilver> YMMV>
05:11:22 <benc__> yeah
05:12:13 <benc__> i think i'm at least goign to want to map over stuff to give html fragments
05:12:37 <djahandarie> Is there a decent disk-backed key-value store?
05:13:17 <benc__> the filesystem? ;)
05:13:46 <djahandarie> Heh, true, but looking for something that could perform well
05:14:55 <dv-> There's redis
05:15:33 <djahandarie> Yes, I know there are bindings to it also, but looking for something all in haskell
05:15:57 <dhouthoo> happstack's macid?
05:20:42 <arcatan> djahandarie: maybe tokyo cabinet?
05:21:01 <arcatan> (no idea if it's decent, just trying to give pointers)
05:21:20 <djahandarie> I'm looking for a Haskell-only solution
05:22:16 <dv-> I think you can make an image-based virtual filesystem with missingH
05:22:53 <ivanm> malcolmw: heh, fair enough
05:27:29 <ivanm> @. elite yow
05:27:30 <lambdabot> cOu|dn'+ phInd phOr7Une phi|3
05:27:33 <ivanm> bah
05:29:00 <kmc> @. elite nixon
05:29:01 <lambdabot> c3RtAiN1y iN +hE nEX7 50 yeARz0rz we 5HA11 sE3 A \/\/o/\/\AN Pre5IDEn+, peR|-|Apz 5OONER thAN Y0U +hInK. 4 wOmAn (4n 4ND S|-|OuLd bE Able t0 dO 4Ny Po|I+IcAL JOb +hA7 a /\/\an C4N DO.
05:29:10 <kmc> how progressive of him
05:30:10 <Silvah> Holy moly...
05:30:56 <Silvah> @. elite quote
05:30:56 <lambdabot> MaxORyu $4y5: < rOCOnn0R > I xeep c0min9 bACk 7O #hazke1l ANd T|-|inxiNg t|-|Er3 iS 4n on1InE boxinG GaME wrI7tEn In hazxel|. (REG4rding fR3qUeNt 5p4M\/3rTiS3r) < /\/\aKoRyU > mayB3 it cOUlD Be in
05:30:56 <lambdabot> cONtR4$T +0 0NlIne UNBOXINg, ra7HER +HaN Off|IN3 BoxIn9...
05:31:35 <dv-> :/
05:31:41 <Silvah> No doubt.
05:39:33 <eikke_> could someone who knows DPH please look at https://gist.github.com/6bdb8f585cca552400d9 ?
05:39:56 <eikke_> as you can see on the bottom, the 2 functions give a different outcome, although the code looks the same (minus use of P) to me
05:41:39 <Cale> eikke_: enough qualified names? ;)
05:42:10 <eikke_> Cale: did it like that to make it more obvious what was being used where
05:42:15 * Cale is not used to reading code in which Prelude stuff is qualified :)
05:42:36 <Cale> I suppose you're using two preludes though.
05:42:49 <eikke_> me neither ;) although I read some recommendations to import qualified Prelude when using DPH, and import the DPH prelude unqualified, but here I'm mixing
05:43:15 <ivanm> eikke_: even though the prelude is still being imported implicitly IIUC
05:43:40 <Silvah> Unless you import it explicitly.
05:43:42 <eikke_> ivanm: sure? I got compile errors when using 'map' instead of P.map
05:43:56 <eikke_> Silvah: indeed
05:43:56 <ivanm> maybe not then
05:44:29 <Cale> ivanm: If you import the Prelude explicitly in any fashion, it no longer gets imported implicitly.
05:44:34 <ivanm> k
05:45:08 <eikke_> it's really strange... typing seems correct, and the non-dph version returns the correct result
05:46:06 <Cale> Weird that you have this as a left fold
05:46:18 <Cale> When I wrote it, it came out straightforwardly as a right fold
05:46:30 <Cale> Oh, left fold over the reverse :)
05:46:41 <eikke_> indeed
05:46:51 <djahandarie> Why would you do that?
05:47:17 <Schalken> I typically implement loops using a map and an anonymous function, however is it possible to have the function have access to both the current element and its index (0,1...)? Is there some clever map/fold that would do this?
05:48:28 <eikke_> djahandarie: that algorithm seems the most optimal to me... not sure how you'd tackle the probem top-to-bottom and remain as efficient
05:48:49 <eikke_> djahandarie, Cale: apart from the algorithm I use, the result should be the same :P
05:50:17 <dmwit> Schalken: zip [0..]
05:50:25 * benc__ loses by 10s
05:50:31 <Cale> eikke_: Yeah, I don't think I see the difference here
05:50:54 <eikke_> me neither. been trying to evaluate substeps in GHCI, all looks fine
05:51:07 <djahandarie> Try Vacuum
05:51:20 <eikke_> whats that
05:51:22 <Cale> We need rl
05:51:31 <Cale> preflex: seen rl
05:51:31 <preflex>  rl was last seen on #ghc 2 days, 11 hours, 21 minutes and 19 seconds ago, saying: hey Axman6
05:51:47 <rl> wut?
05:51:48 <djahandarie> eikke_, visualize live data structures
05:52:03 <eikke_> djahandarie: thanks, checking it out
05:52:09 <Cale> rl: eikke_ has a dph program which is behaving strangely
05:52:18 <rl> yeah, me too ;)
05:52:24 <eikke_> rl: https://gist.github.com/6bdb8f585cca552400d9
05:52:25 <Schalken> dmwit: :| ...thats exactly what I needed. And there I was going to create some elaborate fold. :P Thanks!
05:52:37 <djahandarie> No idea if it'd work with DPH actually
05:53:24 <rl> eikke_: this is not really a DPH program, it just uses the completely unmaintained stuff in GHC.PArr
05:53:35 <rl> to make it a DPH program you have to vectorise it
05:54:16 <rl> eikke_: for that, you have to put solveP in a separate file, write a marshalling function in that same file and compile it with -fvectorise
05:54:46 <eikke_> and not use GHC.PArr at all?
05:55:08 <rl> eikke_: here is an example: http://darcs.haskell.org/packages/dph/examples/dotp/DotPVect.hs
05:56:02 <eikke_> I'll check that out, thanks
05:56:10 <rl> eikke_: well, you use bits from GHC.PArr but if you use the right bits the vectoriser will get rid of them
05:56:17 <rl> it's not terribly convenient :(
05:56:49 <eikke_> rl: even if it's not really vectorized, I fail to see why the result would be different :)
05:56:49 <rl> but we're working on it
05:56:59 <byorgey> ksf: note, that is an UNORDERED list ;)
05:57:11 <rl> eikke_: probably because GHC.PArr is broken somehow
05:57:18 <eikke_> righ
05:57:26 <ivanm> byorgey: how did hac phi go?
05:57:27 <Cale> Does this have something to do with fake implementations of functions that are supposed to be rewritten away? :)
05:57:33 <ivanm> I don't recall seeing any write-ups about it...
05:57:40 <byorgey> ivanm: it went really well!  everyone seemed to have a lot of fun
05:57:50 <byorgey> yes, I suppose I should write a little something about it
05:57:56 <byorgey> I am just not very motivated to do so
05:58:17 <rl> yeah, the vectoriser replaced all references to fooP by the "real" implementation
05:58:23 <rl> *replaces
05:58:31 <ivanm> yeah; there's code I should be writing but I'm not very motivated to hack on it atm :s
05:58:58 <eikke_> the reason I found out about GHC.PArr is because I couldnt find any fold*P in Data.Array.Parallel
05:59:26 <rl> eikke_: that's because we don't support general folds yet
06:00:03 <eikke_> ok... maybe I'm looking at the wrong tool (DPH) anyway
06:00:03 <rl> eikke_: IIRC there was a thread on haskell-cafe about it recently, I'll try to find it
06:00:18 <djahandarie> There are undirected folds though, right?
06:00:19 <byorgey> ivanm: the code I am motivated to write is exactly why I'm not motivated to write a blog post about hac phi =)
06:00:44 <ivanm> byorgey: heh, fair enough
06:01:15 <rl> djahandarie: we *will* support folds, we just have to figure out how to implement them efficiently
06:02:56 <rl> eikke_: http://www.haskell.org/pipermail/glasgow-haskell-users/2010-May/018837.html
06:03:05 <eikke_> ty
06:03:38 <rl> np
06:04:14 <rl> eikke_: what are you trying to do anyway?
06:04:28 <eikke_> I might look at using parMap and parZipWith first
06:04:39 <eikke_> rl: it's a solution for Project Euler 18/67
06:05:19 <eikke_> it works fine and fast enough, but my mind told me the algorithm I found can be easily parallelised in 2 dimensions, and wanted to play with that
06:07:43 <eikke_> afk now, thanks for all help and pointers!
06:11:01 <soupdragon> @let factorial n = product [1..n]
06:11:02 <lambdabot>  Defined.
06:11:11 <soupdragon> > factorial 1 + factorial 4 + factorial 5
06:11:12 <lambdabot>   145
06:11:35 <soupdragon> > 1^3 + 5^3 + 3^3
06:11:36 <lambdabot>   153
06:14:12 <soupdragon> > 12^3 + 33^3
06:14:12 <lambdabot>   37665
06:14:18 <soupdragon> > 12^2 + 33^2
06:14:19 <lambdabot>   1233
06:14:33 <soupdragon> > 88^2 + 33^2
06:14:34 <lambdabot>   8833
06:14:53 <soupdragon> > 1^4 + 6^4 + 3^4 + 4^4
06:14:54 <lambdabot>   1634
06:17:40 <soupdragon> > factorial 4 + factorial 0 + factorial 5 + factorial 8 + factorial 5
06:17:41 <lambdabot>   40585
06:18:00 <kmc> :O
06:18:37 <soupdragon> > 5^5 + 4^5 + 7^5 + 4^5 + 8^5
06:18:37 <lambdabot>   54748
06:19:21 <djahandarie> Why is there a seperate definition for sum/product than the one used in the prelude
06:19:24 <djahandarie> @src sum
06:19:25 <lambdabot> sum = foldl (+) 0
06:19:34 <ivanm> djahandarie: where?
06:19:39 <djahandarie> In 6.12.1
06:19:43 <djahandarie> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/src/Data-List.html#sum
06:19:58 <djahandarie> Agh
06:19:59 <djahandarie> I meant
06:20:01 <wli> I expected Traversable
06:20:02 <ivanm> djahandarie: I would guess that the prelude just re-exports that
06:20:04 <djahandarie> report*
06:20:10 <dmwit> sum is insufficiently efficient.
06:20:14 <ivanm> what does the report use? foldr?
06:20:21 <djahandarie> Report uses foldl
06:20:32 <dmwit> The report uses foldl, which can stack overflow due to being lazy.
06:20:33 <djahandarie> Link uses cons
06:20:39 <ivanm> well, copumpkin wishes it used foldr...
06:21:00 <ivanm> djahandarie: but I would guess that the non-report version is more efficient
06:21:00 <dmwit> foldr would be weird, but acceptable in some cases.
06:21:14 <ivanm> since an explicit recursion can be faster and have less of a memory leak
06:21:29 <ivanm> dmwit: he wants it for the Natural data type
06:21:31 <dmwit> But foldl is the worst of both worlds: it's neither memory-efficient like foldl' nor optionally lazy like foldr.
06:21:47 <ivanm> > sum [1..] > (10 :: Natural)
06:21:48 <lambdabot>   Not in scope: type constructor or class `Natural'
06:21:52 <soupdragon> > 71^2 == factorial 7 + factorial 1
06:21:52 <ivanm> grrr...
06:21:53 <lambdabot>   True
06:21:55 <ivanm> > sum [1..] > (10 :: Nat)
06:21:56 <lambdabot>   Not in scope: type constructor or class `Nat'
06:22:12 <dmwit> It's pretty obvious what he wants it for. There's really only one thing that would make foldr a good choice. =P
06:22:14 <ivanm> anyway, if you use the foldr version of sum then I think that will return a value for Natural values
06:22:20 <ivanm> dmwit: yup
06:22:38 <ivanm> and the report couldn't use foldl' because it wasn't in the report...
06:23:40 <soupdragon> > 1^3 + 3^3 + 6^3
06:23:40 <lambdabot>   244
06:23:45 <soupdragon> > 2^3 + 4^3 + 4^3
06:23:46 <lambdabot>   136
06:25:18 <wli> Faulhaber again? Bernoulli polynomials are always there.
06:34:42 <djahandarie> You know, it seems like timeLimit in Mueval isn't ever even reference past when you define it
06:36:32 <djahandarie> Ah, looks like you need to use this forkedMain thing
06:38:00 <soupdragon> @oies 7,11,27
06:38:00 <lambdabot>  Sum of digits of n^5.
06:38:01 <lambdabot>  [0,1,5,9,7,11,27,22,26,27,1,14,27,25,29,36,31,35,45,37,5,18,25,29,36,40,35,3...
06:38:52 <EvanR-work> is there any use for an IORef (IORef a) ?
06:42:41 <Cale> EvanR-work: Sure, but not that commonly.
06:42:52 <EvanR-work> it seems useless
06:43:02 <Cale> Is there any use for a pointer to a pointer?
06:43:08 <EvanR-work> this isnt the same thing
06:43:22 <Cale> Well, yes, you can't do arithmetic on IORefs.
06:43:34 <byorgey> if you want to mutate which thing you are mutating
06:43:37 <Cale> (that's the difference between references and pointers, after all)
06:43:37 <byorgey> sounds plausible to me.
06:43:39 <EvanR-work> the value of what the IORef points to cannot be mutated
06:43:51 <EvanR-work> unlike in the pointer case
06:43:56 <Cale> Sure it can.
06:44:04 <paper_cc> the _value_ cannot
06:44:05 <Cale> You put different IORefs into the outer IORef
06:44:10 <paper_cc> but the _destination_ can
06:44:31 <paper_cc> that is, you can't change the value you point to
06:44:44 <paper_cc> but you can change which value you point to
06:44:57 <EvanR-work> so to perform the equivalent operation for an IORef you just overwrite the IORef, the double is redundant
06:45:04 <Cale> ?
06:45:12 <Cale> It's not redundant.
06:45:42 <Cale> Okay, imagine this scenario. Suppose you have a tree, and each node of the tree has an IORef in it.
06:45:49 <EvanR-work> the reason for two pointers is because in c theres a difference between changing the destination and changing the value
06:46:26 <Cale> Now you want to have a way to mutably change which IORef in the tree you're going to update.
06:46:44 <Cale> I'll admit that's a little weird.
06:46:55 <EvanR-work> right, you dont need to mutably do that, you just find the ioref and change it
06:47:00 <Cale> huh?
06:47:16 <EvanR-work> why write the ioref to an ioref before changing it
06:47:22 <jeeez> how does haskell compare with C/C++ in terms of speed?
06:47:45 <FauxFaux> It's much faster.
06:47:46 <Cale> jeeez: Those are programming languages, not programming language implementations ;)
06:48:15 <EvanR-work> next question how do they compare in memory usage
06:48:18 <Cale> jeeez: GHC's generated code is usually quite good
06:48:43 <jeeez> Cale: hmm
06:49:25 * geheimdienst thinks there's a few niches for c, but by and large, using c is premature optimization
06:49:34 <geheimdienst> ;)
06:49:43 <EvanR-work> c has universal support
06:50:24 <jeeez> geheimdienst: exactly. and if the 80-20 rule is anything to go by, wont it be a good idea to do 80% of the coding in a functional language and the bottlenecks in C/C++?
06:50:31 <arw> geheimdienst: others consider anything but c to be overengeneering...
06:50:59 <Cale> jeeez: You can do that, but it often turns out to be unnecessary to use a lower level language like C at all.
06:51:14 <Cale> jeeez: C++ makes a terrible choice for a lower level language here.
06:51:17 <EvanR-work> jeeez: for a real application c is probably going to be painful and not going to help your performance anyway
06:51:27 <Cale> Because FFI between C++ and anything else is hard.
06:51:32 <Cale> (even hard for C)
06:51:34 <arw> somehow all these discussions sound absolutely the same :)
06:51:35 * hackagebot language-asn1 0.2.1 - Parsing of ASN1 definitions  http://hackage.haskell.org/package/language-asn1-0.2.1 (DmitryAstapov)
06:52:02 <jeeez> yeah, i was hoping one of you guys would say haskell is slower and i'd brilliantly jump up with my Super-Solution
06:52:10 <djahandarie> It's *really* bugging me that Mueval is all based around using stdout instead of just returning IO Strings
06:52:25 <Cale> Also, C++ compilers tend to generate code that is not all that fantastically efficient that it's worth programming in such a headache inducing language.
06:52:40 <Cale> djahandarie: Use hint
06:52:51 <djahandarie> Cale, that doesn't have all the nice protection though
06:52:52 <exDM69> http://www.pasteall.org/13388  <<<--- trying to debug something with GHCi. The code runs fine normally, but when I :set -fbreak-on-exception it crashes and I don't know why
06:52:55 <exDM69> can anyone help
06:53:18 <exDM69> or come up with another idea on how to hunt for an infinite loop
06:53:27 <geheimdienst> arw, in c there's more work to do for the programmer (memory management ...), so considering source code size and programmer time, using c project would be overengineering, imho
06:53:41 <Cale> exDM69: Perhaps an exception is thrown by the code which is later caught
06:53:42 <quicksilver> Cale: of course, C++ does support the C ABI.
06:54:00 <quicksilver> Cale: (well, typical implementations do)
06:54:03 <exDM69> Cale: please explain more, I don't understand
06:54:06 <Cale> quicksilver: If you go out of your way to export things :)
06:54:17 <exDM69> this particular case should run fine
06:54:32 <Cale> exDM69: If you're completely lost on where the infinite loop is, maybe try profiling.
06:54:54 <Cale> exDM69: Compile with -prof -auto-all and run the program with +RTS -p
06:55:05 <Cale> and then look at the .prof file that you get
06:55:07 <exDM69> Cale: thanks, I'll try that
06:55:18 <Cale> and look for cost-centres with lots of entries
06:55:26 <arw> geheimdienst: every language burdens the programmer with some kind of overhead, in c its memory management, in java its "get around that weird object stuff".
06:55:31 <exDM69> do I get a .prof even if my program does not finish
06:55:31 <Cale> (indicating that there's an infinite loop there)
06:55:34 <Cale> yes
06:55:53 <jeeez> and in Haskell?
06:55:58 <Cale> If you Ctrl-C it, you should still get a .prof
06:56:04 <mike-burns> jeeez: Debugging.
06:56:06 <EvanR-work> jeeez: none. its perfect.
06:56:24 <quicksilver> Cale: I don't think it's any hard to specify C ABI entry/exit points in C++ than Haskell.
06:56:26 <djahandarie> Is code.haskell.org responding for other people?
06:56:29 <arw> jeeez: avoiding memory leaks, also some kind of memory management.
06:56:33 <quicksilver> Cale: they both have pretty simple C interfaces.
06:56:39 <geheimdienst> arw, yes, every language has some overhead, but i'd argue not the same amount
06:56:42 <kmc> for numerical code it makes a lot of sense to do the core in C and the rest in Haskell.  but do a prototype in Haskell first, it might be good enough and otherwise you have something to test against
06:56:45 <quicksilver> Cale: but C++'s is much more powerful, supporting complex types directly.
06:56:45 <Cale> quicksilver: Yeah, but having to do it in two places is worse than only having to do it on the Haskell side.
06:57:06 <exDM69> Cale: I also need profiling libraries for my dependencies? It complains that I don't have one for parsec
06:57:07 <kmc> for symbolic code, the pain of marshalling to C is a lot higher, the benefit of using Haskell a lot higher, and the benefit of C a lot lower
06:57:24 <geheimdienst> djahandarie, http://downforeveryoneorjustme.com/code.haskell.org/ ;-)
06:57:28 <geheimdienst> it's not just you
06:57:55 <djahandarie> Alrighty
06:57:59 <Cale> quicksilver: To make a binding to a C library, you do a bunch of Haskell FFI. To make a binding to a C++ library, you do a bunch of C++ FFI to make stuff look like a C library, and then a bunch of Haskell FFI
06:58:29 <arw> jeeez: and my personal biggest current problem with haskell: whining colleagues who don't like me building stuff in haskell, because they won't be able to understand it.
06:58:39 <quicksilver> Cale: sure. But O(1) boilerplate per function is O(1) boilerplate per function. Not like you to worry about a constant factor ;)
06:58:50 <jeeez> arw: give them the assembly code :)
06:59:08 <Cale> Oh, I worry about constant factors when they have to do with stuff I have to do myself.
06:59:16 <quicksilver> Cale: and if you have a significant amount of it to do, you're going to want an interface tool anyway.
06:59:23 <Cale> I'm just saying that it's probably not worth that extra trouble in general, if you're choosing an implementation language for the bits of your code which have to run fast.
06:59:54 <Cale> You're better off just using C for the inner loops, or using something like Harpy.
07:00:36 <Cale> C++ has plenty of overhead that you don't want for that anyway, and the extra trouble doing FFI to it makes it even less worthwhile.
07:02:05 <ManateeLazyCat> I agree with Cale's point.
07:02:36 <exDM69> yeah, C++ and FFI don't mix well
07:03:05 <exDM69> C++ libraries wrapped in C wrapped in Haskell FFI don't play nice with GHCi either
07:03:46 <exDM69> f.ex. LLVM haskell bindings don't work in GHCi (at least on linux at the moment), they crash with can't find libstd++ errors
07:04:09 <p_l> well, without exceptions there isn't much overhead unless you call virtual methods, but getting virtual methods to work in FFI is hard, and then you get to exception handling...
07:04:52 <kmc> there's not much inherent overhead
07:05:01 <kmc> but C++ makes it easier to hide overhead
07:05:11 <kmc> which is part of your code
07:05:23 <p_l> there's overhead in writing the FFI, compared to nearly everything else :D
07:06:08 <exDM69> why does cabal want to install parsec-2.1.0.1 when I have 3.0.0 installed and the latest version available is 3.1.0?
07:06:50 <jeeez> i don't think if the code was important enough to be optimized, it'd be so elaborate that it'd need classes or virtual functions or any other 'advanced' feature C++ caters [in short, C would do]
07:07:25 <Jafet> C++ lets you pretend you have modules
07:07:32 <exDM69> http://www.haskell.org/cabal/FAQ.html#parsec-2-vs-3
07:07:35 <Jafet> And static polymorphism
07:07:35 <exDM69> found the solution
07:08:15 <geheimdienst> exdm69, also you often have packages that depend on specific versions (foo <= 6.3 ...)
07:09:49 <exDM69> geheimdienst: yeah, I've noticed. I've also noticed that GHC/Cabal does not do a very good job with those situations
07:10:14 <exDM69> esp. with software libraries you should be able to have multiple versions of the same library installed
07:11:12 <Polarina> I get this error "cannot satisfy -package-id bytestring-0.9.1.6-3299cf20dec29c995a890d06afa3c726" while attempting to install network-bytestring. What can I do?
07:11:13 <Cale> jeeez: Another option is to use the FFI stuff provided in Haskell to just do all the low-level stuff you need in Haskell code.
07:11:40 <ManateeLazyCat> Polarina: "ghc-pkg check" ?
07:11:51 <ManateeLazyCat> Polarina: Looks some package broken.
07:12:26 <Polarina> ManateeLazyCat, ghc-pkg: /home/polarina/.ghc/x86_64-linux-6.12.1/package.conf.d/xfunctor-0.1-06ff7fcff9041e6c64962351f540b6b2.conf: hGetContents: invalid argument (invalid UTF-8 byte sequence)
07:12:28 <ManateeLazyCat> FFI now support vararg functions?
07:13:41 <Cale> Polarina: Well, that's interesting and strange
07:14:37 <Polarina> Cale, why so?
07:14:41 <quicksilver> Cale: most of the overhead of C++ is miniscule compared to the FFI overhead.
07:15:04 <quicksilver> Cale: the overhead of, say, exception handling or virtual method calls is probably 3 orders of magnitude less than the overhead of a GHC FFI call.
07:15:18 <Cale> Polarina: One would wonder how it managed to write an invalud UTF-8 byte sequence into the file in the first place
07:15:22 <Cale> invalid*
07:15:48 <Jafet> Should of used zfs!
07:16:33 <Polarina> Cale, looks like that file contains my name with some non-ASCII characters in some encoding.
07:16:39 <p_l> quicksilver: yeah. The biggest overhead is IMHO generating the bindings if you want to avoid overhead of generating extra "C" functions to wrap calls to virtual methods :)
07:17:02 <Cale> Polarina: Yeah, it *ought* to be UTF-8 encoded, but maybe it's some strange encoding instead.
07:17:08 <geheimdienst> polarina, try "file blabla.conf"
07:17:10 <Cale> Polarina: Maybe try unregistering that package and reinstalling it?
07:17:16 <geheimdienst> does it tell you the encoding?
07:17:21 <Polarina> I'll try modifying the .conf file. :)
07:17:25 <Cale> Oh, yeah, might be good to know what's going on :)
07:17:28 <Polarina> geheimdienst, no, I see question marks.
07:17:40 <Cale> If you know what encoding the file is in, then you could use iconv to convert it.
07:18:01 <geheimdienst> cale, that's exactly the procedure i was thinking of :-)
07:18:42 <geheimdienst> polarina, have you tried "enca bla.conf" ?
07:19:06 <rrc7cz> does anyone here also use Scheme or Clojure or some other Lisp?
07:19:24 <Saizan_> Polarina: is xfunctor.cabal in utf8?
07:21:08 <ManateeLazyCat> Have any tips that modified hackage package that don't need change current version?
07:21:26 <Polarina> Saizan_, xfunctor doesn't have a cabal file.
07:21:51 <ManateeLazyCat> Polarina: We have similar trouble in gtk2hs, after change locale to utf8 problem will fix.
07:22:20 <Polarina> Problem seems to be fixed now. :)
07:22:40 <p_l> rrc7cz: Common Lisp here (I'm mostly idling in Haskell, haven't had time to sit down and relearn it again)
07:22:51 <Cale> rrc7cz: I've used scheme and looked at clojure a bit. I prefer having a rich static type language, but as far as untyped languages go, those are decent choices. :)
07:23:15 <rrc7cz> p_l,Cale: I'm trying to learn Haskell and one thing that's hitting me pretty hard is all the syntax. I was wondering how you guys felt about that
07:23:16 <Cale> Common lisp, I found really awkward for functional programming in.
07:23:57 <Cale> The syntax of Haskell is technically somewhat involved, but has a certain sort of consistency to it that it doesn't feel like there's a whole lot of syntax to me.
07:24:06 <Saizan_> Polarina: ah, k, it's not a bug in Cabal then :)
07:24:30 <rrc7cz> p_l,Cale: just reading about lets in list comprehensions, the exception not needing in, yet the binding is visible before the let, kinda like a where... it's just one example, but I keep having this feeling like whoa
07:25:02 <benc__> rr7cz: well you can ignore a bunch of that syntax until later
07:25:03 <Cale> rrc7cz: Well, list comprehensions are a bit weird syntactically :)
07:25:11 <benc__> and then discover later on that "i wish i could do this"
07:25:12 <ManateeLazyCat> Polarina: How to fix?
07:25:15 <benc__> and then discover you can
07:26:16 <Cale> rrc7cz: The let bindings are visible (recursively) inside the let, and in later generators in the list comprehension, as well as the expression part of the list comprehension before the | (which is in some sense "last", even though it comes first)
07:26:39 <Cale> rrc7cz: You might be more comfortable with do-notation for lists.
07:27:00 <Cale> which is equivalent, but written in what you might find a more logical order
07:27:15 <Cale> The list comprehension notation is designed to look like set comprehension from mathematics
07:27:18 <rrc7cz> benc__: makes sense. I'm working through Learn You a Haskell and so far love the presentation. I have a mental block when it comes to skipping sections, but it might be worth it
07:28:09 <rrc7cz> Cale: I though I'd be comfortable with the let bindings, since they initially appeared to function the same as in Clojure, but then this list comprehension tie in threw me off a bit
07:28:13 <Cale> rrc7cz: If you've seen things like  { p^2 | p in N, p prime } in mathematics, then that's what list comprehensions are modelled after :)
07:28:14 <benc__> Cale: learning do-notation for lists as well as learning it for IO is maybe a nice way to get its abstraction into head early on
07:28:32 <quicksilver> list comprehensions should be in the 'advanced' section of haskell learning IMO
07:28:41 <quicksilver> not because they're hard, but because their intuition is subtly wrong.
07:28:50 <quicksilver> they don't help you with the rest of the language
07:28:54 <Cale> subtly wrong?
07:28:58 <quicksilver> yes
07:29:01 <Cale> In what way?
07:29:10 <quicksilver> bare boolean expressions being treated one way
07:29:18 <Cale> They behave precisely how I would intuitively think of them ;)
07:29:25 <quicksilver> weird pseudo-expressions of the form a <- b treated another way
07:29:25 <Cale> But maybe I don't count
07:29:34 <quicksilver> and of the for let x = y treated a third way.
07:29:38 <rrc7cz> Cale: well, it's the same as in Clojure: (for [p N :where (prime? p)] (* p p)), but I guess the scoping is what I found odd: that the binding _before_ the let is visible
07:29:45 <quicksilver> Cale: they have a consistent intuition, but not consistent with the rest of the language.
07:30:01 <quicksilver> Cale: the ordering issue about lets that you just mentioned, the bare booleans
07:30:05 <rrc7cz> Cale: I agree w/the do notation; I've been playing with it for Parsec and it's a nice intro
07:30:23 <Cale> rrc7cz: Yeah, the only difference is just that we write that 'result' expression first.
07:30:34 <Cale> rrc7cz: Everything else is in the same order
07:31:24 <Cale> So it's like  [ <end result> | <begin here>, ---->, <second last> ]
07:31:47 <zygoloid> quicksilver: it'd be sensible to introduce them at the same time as do-notation i think
07:31:49 <rrc7cz> Cale: okay that makes more sense to me. That even though syntactically it comes first, logically think of it coming after
07:31:56 <Cale> Which is a bit odd, but sometimes it's natural to get the main thing you're talking about out of the way
07:32:15 <rrc7cz> Cale: yeah, that first hit me with where. I never saw anything like that before, but I love it
07:32:18 <Cale> and then describe the stuff which is involved in building it up :)
07:32:34 <rrc7cz> Cale: it allows me to write like a book... top down, lowering the level of abstraction, etc
07:32:38 <Cale> yeah
07:32:55 <babusri> The !! function on lists takes constant time, right?
07:33:00 <Cale> babusri: No
07:33:05 <Cale> xs !! n takes O(n) steps
07:33:14 <babusri> That was fast.
07:33:37 <Cale> (So you should avoid using !! as much as possible)
07:33:40 <quicksilver> Cale has a pact with the devil to get to see your question 2 minutes before you ask it. Makes the IRC channel more efficient.
07:33:52 <geheimdienst> babusri, i guess you can think of lists in functional languages as linked lists (not as arrays)
07:34:03 <jmcarthur> well, that's what they are
07:34:12 <mreh> quicksilver: you can borrow it if you like
07:34:13 <jmcarthur> you don't just have to *think* of them that way :)
07:34:19 <babusri> So, Lists are not a good choice. I am switching to Vectors.
07:34:20 <Cale> They're a little more subtle than your average linked list
07:34:26 <Cale> (because of laziness)
07:34:36 <danderson> and by subtle you mean to say awesome
07:34:40 <Cale> and sometimes they're more like stacks
07:34:53 <mreh> I have questions on randomness
07:35:00 <Cale> (though I suppose linked lists can be like that too)
07:35:05 * jmcarthur tends to think of linked lists as stacks anyway
07:35:08 <danderson> and sometimes, monads are like burritos. It all makes sense after a while.
07:35:12 <mreh> randomness is stuck in the IO monad because haskell obtains it's randomness from the system
07:35:29 <mreh> can I safely liberate it from this restriction?
07:35:29 <jmcarthur> mreh: real randomness is, yes
07:35:43 <jmcarthur> mreh: psuedorandomness can be pure if you carry the seed around
07:36:08 <danderson> and in System.Random, it is in fact pure, aside from initialization from a real random source
07:36:15 <Cale> mreh: You can get a StdGen from the IO monad (or just make a constant one, though that's not as "random"), and then use that
07:36:17 <ManateeLazyCat> babusri: If you want faster index, you perhaps can try Data.Sequence.
07:36:32 <EvanR-work> jmcarthur mreh see also random monad
07:36:34 <danderson> you give it a random generator state, and it gives back a pseudorandom number and the next generator state
07:36:39 <Cale> mreh: StdGen values represent the state of a pseudorandom number generator
07:36:49 <jmcarthur> EvanR-work: you mean MonadRandom?
07:36:58 <EvanR-work> Control.Monad.Random
07:37:06 <jmcarthur> oh, and *don't* see my comonad-random package
07:37:10 <mreh> state and randomness... aren't they... kind of at odds with each other
07:37:13 <p_l> Cale: well, the reason I finally managed to grasp Common Lisp was when I stopped trying to force FP mindview onto it, and when I had seen Haskell typeclasses (which allowed me to understand CLOS).
07:37:24 <jmcarthur> mreh: define "randomness"
07:37:28 <Cale> mreh: You'll find that random and randomR will take a StdGen, the initial state of your PRNG, and produce a new StdGen (the next state) along with their result
07:37:31 <mreh> EvanR-work, the monad is called "Rand"
07:37:34 <EvanR-work> yes
07:37:36 <jmcarthur> mreh: if you are talking about psuedorandomness, there is no conflict here
07:37:42 <EvanR-work> evalRand
07:37:52 <p_l> rrc7cz: Haskell doesn't have that much of a weird syntax after working with Python and doing a little algebra back in school :)
07:37:53 <EvanR-work> now you can easily use random numbers without passing the seed around or using IO
07:37:53 <Cale> p_l: Well, yeah, it would make an okay imperative language. I just don't want to program that way.
07:38:17 <Cale> I'm too used to using functions everywhere to have it be awkward.
07:38:42 <babusri> In many of the introductory texts (articles/books) on Haskell, Lists are used a lot. Why is this? I think many people confuse them for random-access arrays as you have index (!!) operator.
07:38:49 <p_l> rrc7cz: Lisp requires support from editor to be effective, but that's a given when you're writing the contents of a data structure instead of text... (and there were editors that completely gave up on textual representations)
07:38:50 <Cale> babusri: Lists are our loops
07:38:54 <rrc7cz> p_l: didn't you feel liberated when you saw how tiny the syntax was? I feel like after learning a Lisp, you get spoiled and learning another language becomes annoying because of the arbitrary complexity
07:39:22 <ManateeLazyCat> babusri: Because List have *huge* library support it.
07:39:25 <Cale> babusri: Just as a loop either doesn't happen, or it happens once, followed by another loop, a list is either empty, or it consists of an element followed by another list.
07:39:32 <ManateeLazyCat> babusri: And more general
07:39:34 <jmcarthur> Cale: lists are *some* of our loops ;)
07:39:34 <p_l> rrc7cz: No, you get spoiled with rich language that requires little *unnecessary* code. Both Haskell and CL give me that, Java is a chore :)
07:39:35 <EvanR-work> mreh: when i use random numbers, i like to reload a rng state as it was when i last used it, when the program ended. that requires IO, but its not as mysterious as newStdGen
07:39:53 <Cale> babusri: We use lists, and operations on them, as the fundamental means of expressing linear recursion, that is, loops.
07:40:00 <EvanR-work> but the initial (first run) of the program you dont need IO to start the gen
07:40:08 <Cale> (of course, there are other ways to do it, but lists are the main way)
07:40:14 <jmcarthur> ah if you define loop = linear recursion then nevermind
07:40:21 <rrc7cz> p_l: fair enough, but that comes _after_ you've learned the language. I still feel like the learning process becomes more of a chore
07:40:38 <jmcarthur> i was using a looser definition
07:40:44 <mauke> tiny syntax? quick, what's the definition/expansion of ` and ,? and what's the exact syntax of LOOP?
07:41:17 <Starfire> LOOP isn't really core syntax.
07:41:24 <p_l> mauke: LOOP is a separate language, definition and expansion of #\` #\, and #\@ are easily found
07:41:50 <mauke> it's in the language standard
07:41:58 <p_l> what is problematic with macros is environment it runs, not list building reader macros
07:42:10 <p_l> mauke: it's a library that's part of standard library
07:42:39 <geheimdienst> starfire, all mauke is saying is, if you have to learn less syntax, you have to learn more functions or macros
07:44:18 <kmc> Lisp is a very simple syntax for describing nested lists
07:44:27 <kmc> separately, it's a somewhat more complicated way for interpreting lists as programs
07:44:30 <rrc7cz> geheimdienst: it that true though? Keeping with my (minor) let example: having to know the special case of a let binding being visible before the let is declared... I'm not sure that reduces any need to learn functions or macros, does it?
07:45:03 <mauke> next issues: how do I get a newline in my string, and what's the exact syntax for symbols?
07:46:21 <soupdragon> not sure why you'd say it's complicated
07:46:26 <soupdragon> seems pretty simple to me
07:46:33 <soupdragon> especially compared to something like haskell
07:46:43 <kmc> i meant compared to seeing it only as syntax for describing data
07:47:05 * hackagebot fclabels 0.4.2.1 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-0.4.2.1 (ErikHesselink)
07:47:11 <kmc> the key here is that Lisp has a three-level syntax, while most languages have two, and saying "it's just s-expressions" is missing most of the complexity
07:47:21 <soupdragon> wow everyone and his dog are implementing records these days
07:47:32 <Kaide> record types are useful
07:47:33 <soupdragon> and here I am still wondering what records are _for_
07:47:43 <tromp> in lisp you need to keep track of how many times a thing has been evaluated, and when to quote things
07:47:44 <soupdragon> I've never used them in any program
07:47:48 <Kaide> naming groups of things that always go together
07:48:09 <soupdragon> kmc ah good point
07:48:16 <osfameron> kmc: what do you meanby 3-level syntax ?
07:48:34 <soupdragon> the distinction between lexical and grammatical syntax
07:48:47 <soupdragon> which is very often conflated
07:48:57 <kmc> osfameron, characters describe a linear stream of tokens.  the tokens describe a tree of lists and atoms.  this data structure describes a program.
07:49:49 <osfameron> isn't that true of most languages?
07:49:50 <p_l> and to make things weirder the first level is kinda optional
07:49:59 <p_l> osfameron: not exactly
07:50:13 <geheimdienst> rrc7cz, yeah you're right, the let thing seems like an arbitrary confusion the way you describe it. i was more referring to what mauke said about LOOP and so forth
07:50:14 <osfameron> characters => AST => program
07:50:22 <kmc> the AST is not part of the language in most languages
07:50:23 <p_l> osfameron: most languages put an abstract syntax that isn't related directly to AST
07:50:24 <soupdragon> 'program' is too vauge
07:50:25 <kmc> it's an implementation detail
07:50:34 <kmc> the actual data type used by your implementation
07:50:52 <p_l> osfameron: in Lisp, you're writing the contents of the AST using S-expr. syntax
07:51:00 <osfameron> true
07:51:16 <p_l> (with few extra hooks into reader in case of Common Lisp)
07:51:20 * osfameron really should get around to trying to learn lisp again...
07:51:28 <Kaidelong> soupdragon: Tried looking for where I last used a record type. Was using it to record program state in an F# program. Never used any in haskell though.
07:51:46 <kmc> Lisp basically mandates that the implementation store ASTs in a particular way and expose them to programs
07:51:59 <kmc> (with conversion if they're not actually stored that way)
07:52:09 * mauke feels bitter and disappointed by CL
07:52:15 <wvd> Is this a good example of curried functions? "let multipleBy10 = (*) 10"
07:52:15 <kmc> yeah, Scheme is nicer
07:52:25 <p_l> I think InterLisp actually got rid of character-based syntax
07:52:39 <Kaidelong> wvd: absolutely
07:52:40 * p_l was left bitter and disappointed by Scheme, otoh.
07:52:54 <Kaidelong> wvd: I prefer something like "fmap (^2)" though
07:52:57 <p_l> if not for Haskell, I might have lost all hope for FP :D
07:53:10 <wvd> Kaidelong: fmap!?
07:53:10 <Kaidelong> Haskell is not perfect
07:53:22 <Kaidelong> @type fmap (^2)
07:53:23 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
07:53:29 <Starfire> I really liked CL for the way it broadened my view of OOP.
07:53:35 <Jonno_FTW> @faq can haskell be perfect
07:53:35 <lambdabot> The answer is: Yes! Haskell can do that.
07:53:39 <Kaidelong> > fmap (^2) (Maybe 6)
07:53:40 <lambdabot>   Not in scope: data constructor `Maybe'
07:53:42 <p_l> Kaidelong: it isn't, but it worked for me unlike Scheme
07:53:46 <Kaidelong> > fmap (^2) (Just 6)
07:53:47 <lambdabot>   Just 36
07:53:57 <EvanR-work> haskell is perfect!?!?!!!
07:54:03 <rrc7cz> p_l: you should check out Clojure too. It isn't as pure wrt side-effects, but it makes them much more visible
07:54:08 <EvanR-work> except for OOP support
07:54:21 <kmc> i'm not sure there's much to be gained by grouping Haskell and Lisp together as "functional languages"
07:54:27 <kmc> they differ in most other respects
07:54:31 <Starfire> I hear Clojure has CLOS-style OOP as well.
07:54:34 <Zao> Functioning languages.
07:54:36 <wvd> Kaidelong: Wait, forall? Functors? I didn't read about those yet on LYAH (just at High order functions)
07:54:48 <p_l> rrc7cz: I looked into Clojure two years ago, but the implementation is still lacking in many parts for me, and I dislike working in Java most of the time.
07:54:51 <jkingkong> do you guys run into trouble with emacs haskell mode when using guards?
07:55:07 <jkingkong> I frequently get a "parse error" when trying to tab the gaurds to the proper place
07:55:13 <Kaidelong> wvd: a functor contains a value. fmap does something to the value inside a functor. lists are functors, and map is just fmap on lists
07:55:15 <jkingkong> particularly after a "where" keyword
07:55:18 <kmc> jkingkong, is your editor producing tabs in the output file?
07:55:24 <rrc7cz> Starfire: I don't know CLOS, but it does OOP better than Java; more concise (less parens!!), less boilerplate, multimethods are more general polymorphism
07:55:39 <kmc> yes
07:55:45 <ManateeLazyCat> EvanR-work: Not the perfect language, only the most suitable language. :)
07:55:46 <rrc7cz> p_l: dislike working in Java the language, or JVM the platform?
07:55:51 <kmc> it is not hard to do OOP better than Java, even in languages with no specific support for OOP
07:55:56 <p_l> rrc7cz: multimethods are afaik based on CLOS
07:56:09 <ManateeLazyCat> Have anyone install gtk2hs with ghc-6.12.3-rc1 ?
07:56:16 <p_l> rrc7cz: kind of both, though JVM is definitely the nicer one of the two
07:56:45 <p_l> rrc7cz: Still, according to what I found Clojure is still kinda slow, and I really didn't have much use for it
07:56:56 <p_l> brb, restarting urxvt
07:57:04 <Kaidelong> what of Scala?
07:57:21 <Berengal> Scala is crazy-ugly, but nice.
07:57:44 <gwern> scala is your white-trash cousin you sleep with sometimes?
07:57:57 <ksf> someone highlighted me but the chan scrolled him away
07:58:37 <osfameron> 14:56 <byorgey> ksf: note, that is an UNORDERED list ;)
07:58:37 <mauke> 14:56 <byorgey> ksf: note, that is an UNORDERED list ;)
07:58:39 <gwern> ksf: get a better client
07:58:45 <osfameron> jinx!
07:58:46 <rrc7cz> p_l: with 1.2 release (protocols & datatypes) you don't have to dip into Java the language as much (or maybe ever; I think it's suppose to allow Clojure in Clojure, finally dumping the Java core classes in the impl, but I could be wrong)
07:59:02 <mauke> osfameron: what are you doing in my timezone?!
07:59:07 <osfameron> mauke: eeek!
07:59:11 <ksf> gwern, you mean bigger disk
07:59:16 <osfameron> my server thinks it is in CET
07:59:20 <rrc7cz> p_l: well, it's slow because it makes heavy use of reflexion, but it allows you to add type hints to speed it up
07:59:32 <ksf> I just don't want to accumulate terabytes of nonsensical rambling
07:59:58 <Berengal> ksf: More like a few megabytes...
07:59:59 <gwern> my rambles are filled with tons of sense
08:00:00 <rrc7cz> p_l: it also defaults to safe numeric operations (like Haskell) but you can force unsafe operations for better performance
08:00:11 <mauke> ksf: in how many channels are you?
08:00:13 <p_l> rrc7cz: my particular issue was that at least some people found slowness in its call sequence... another thing was that outside of university and Android programming I have zero need for Java :)
08:00:24 <ksf> 9
08:00:43 <rrc7cz> p_l: you're lucky then :-D
08:01:14 <ksf> doesn't android come with a native interface, too?
08:01:19 * geheimdienst has no irc logs he knows of, but his lolcats directory has nearly 6000 files, clocking in at 307 MB
08:01:33 <mauke> I'm in twice as many channels and logging everything since 2009-12
08:01:39 <mauke> 394M
08:01:42 <ksf> also its vm is different from the vanilla jvm, can it do proper tail calls or such?
08:01:47 <mauke> uncompressed, of course
08:02:12 <p_l> ksf: yes, but it only allows you to load shared libs (think JNI) and many Android libs don't have easily accessible documentation to be used from native code
08:02:14 <ManateeLazyCat> mauke: For #haskell, you don't need log. :)
08:02:19 <mauke> true
08:02:24 <p_l> (not to mention that some are only in dalvik)
08:02:53 <p_l> ksf: well, Dalvik does have goto
08:03:09 <p_l> And I do recall example of implementing tail calls with goto in PAIP
08:03:10 <ManateeLazyCat> http://tunes.org/~nef/logs/haskell/
08:03:15 <ksf> so does the jvm, but it has nasty stack depth checks.
08:03:45 <p_l> ksf: maybe because JVM is a stack VM, Dalvik is a register based ones
08:03:46 <p_l> *one
08:04:27 <p_l> so you don't necessarily have an ever-growing stack of parameters
08:04:30 <Polarina> ManateeLazyCat, removing the invalid UTF-8 sequence. :)
08:04:53 <p_l> (reload registers with new params, goto into beginning of subroutine)
08:05:22 <p_l> I looked a little into Dalvik with hopes of getting CL onto it :)
08:05:41 <p_l> ksf: http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html <--- unofficial opcode docs.
08:06:02 <MrFenix> can I prevent cabal from overwriting existing data files?
08:06:08 <jkingkong> kmc: yes it's producing tabs (i.e. spaces) in the output file
08:06:25 <jkingkong> normally it works, but sometimes, emacs just gets confused
08:07:38 <ManateeLazyCat> jkingkong: haskell-mode is not powerful enough.... :)
08:08:34 <ksf> hmmm it doesn't seem to offer much in regard to control flow (at least compared to arm)
08:09:03 <jkingkong> manateeLazy: haha I guess so. it's still better than vim i think
08:09:10 <jkingkong> for haskell at least :)
08:09:28 * ManateeLazyCat How many Chinese in this channel? Maybe we need build #haskell-zh .... for Chinese haskeller. :)
08:10:06 <jkingkong> question: say I have a type foo a = bar with a being a phantom type
08:10:12 <Zao> It would be interesting to see Chinese Haskell code.
08:10:16 <jkingkong> now, suppose i want foo a to instance Eq
08:10:17 <Zao> The information density would be insane.
08:10:35 <kmc> jkingkong, i meant the tab character
08:10:36 <jkingkong> and the implementation of eq is the same for all types of a
08:10:59 <jkingkong> how would i do this? what would the existential quantification look like
08:11:04 <wvd> So on LYAH map is written using recursion, however I wrote myself one like: "map f xs = [f x | x <- xs]", is the recursion one better?
08:11:06 <jkingkong> kmc: it makes spaces
08:11:09 <kmc> ok
08:11:10 <mauke> jkingkong: did you mean: data Foo a = Bar?
08:11:11 <Zao> Are most CJK glyphs categorized as "letter"?
08:11:19 <Zao> The kind of letter that are valid in identifiers, that is.
08:11:23 <jkingkong> mauke: yes, sorry data Foo a = Bar
08:11:26 <Jafet> wvd, both are probably equivalent
08:11:31 <Zao> I guess you'll have some trouble with upper/lower-case.
08:11:36 <Zao> As most moonspeak is caseless.
08:11:45 <mauke> jkingkong: instance Eq (Foo a) where
08:11:47 <Olathe> jkingkong: instance Eq (Foo a) where (==) Bar Bar = True
08:12:15 <wvd> Jafet, but recursion versus list comprehesion - when I should use recursion and when list compr?
08:12:16 <Olathe> Even (==) _ _ = True
08:12:18 <jkingkong> I get could not deduce (Ord (Foo a)) from the context ...
08:12:37 <jkingkong> ah sorry one more layer of complexity
08:12:40 <jkingkong> i forgot to mention
08:12:52 <jkingkong> we have data Foo a = Bar
08:12:55 <Jafet> wvd, there isn't any semantic difference
08:13:03 <jkingkong> also, we have data Zoo a = Car
08:13:06 <jkingkong> sorry
08:13:13 <Olathe> jkingkong: instance Ord (Foo a) where (<=) _ _ = True
08:13:27 <jkingkong> data Zoo a = [Foo a] or something
08:13:39 <jkingkong> and I want to instance Eq with Zoo
08:13:50 <mauke> jkingkong: instance Eq (Zoo a) where
08:14:30 <Jafet> wvd, list comprehensions are pretty much the way to get cartesian products, though, without pulling the Monad minigun
08:14:34 <jkingkong> it complains Could not deduce (Ord (Foo a)) from the context (Eq (Zoo a)) arising from a use of '=='
08:14:52 <jkingkong> why would Order matter if it's just looking at equality?
08:14:55 <mauke> jkingkong: where am I using == ?
08:15:19 <jkingkong> after the "where"...?
08:15:30 <mauke> there's nothing there
08:15:47 <jkingkong> oh i thought it was implicit
08:15:48 <EvanR-work> q
08:15:56 <jkingkong> what does that do exactly
08:16:09 <jkingkong> that worked
08:16:21 <jkingkong> lol what does it all mean!??
08:16:54 <mauke> that actually calling (==) on Zoo will crash at runtime
08:17:18 <mauke> but the instance is there for type checking
08:17:32 <jkingkong> what exactly are the mechanics here
08:17:39 <jkingkong> just so I understand (if you would be so kind)
08:17:44 <jkingkong> thanks btw
08:17:55 <jkingkong> the solution feels a little too magical
08:19:21 <mauke> instance Eq (Zoo a) where (==) = undefined  -- this
08:19:57 <jkingkong> hmm I've never really used the undefined keyword before
08:20:10 <jkingkong> how does the compiler interpret this loosely?
08:20:39 <Zao> undefined is the spelling one uses for bottom (_|_)
08:20:54 <mauke> it's not a keyword
08:21:03 <jkingkong> I have seen that yes
08:21:04 <mauke> @src undefined
08:21:04 <lambdabot> undefined =  error "Prelude.undefined"
08:21:25 <mauke> > error "blargh im ded"
08:21:26 <lambdabot>   *Exception: blargh im ded
08:21:44 <jkingkong> so it won't know how to equate objects of type Zoo?
08:21:54 <nealar> How can I catch "*** Exception: <<DB.HSQL.Error.SqlError>>" ?
08:23:26 <nealar> it is supposed to be thrown by "throw (SqlError "" (fromIntegral errno) errMsg)"
08:24:00 <nealar> but catch (error . (show :: (SqlError->String))) does not work
08:24:17 <nealar> the exception simply shoots through it
08:24:36 <nealar> it there an "unsafe catch everything"?
08:25:34 <Starfire> Make sure you evaluate whatever is causing the exception before you catch.
08:25:52 <Cale> nealar: catch works better when applied to IO actions which throw errors. You can use Control.Exception.evaluate to try to force exceptions thrown from pure code to be evaluated inside a catch, but it's tricky
08:26:26 <Cale> nealar: Also make sure that you're using Control.Exception's catch
08:26:42 <Cale> The one in the Prelude is sort of only there for legacy reasons.
08:26:59 <Cale> (and doesn't catch much)
08:27:12 <nealar> Cale: this error results from "connect" to DB with type IO connection
08:28:02 <nealar> and GHCi ensures te use of right catch by asking "what catch do you want to use: Prelude.catch or Control.Exception.catch?"
08:28:30 <nealar> IO Connection
08:28:39 * nealar misspelled
08:29:32 <Cale> nealar: You should be able to catch it then...
08:29:56 <Cale> nealar: Just make sure the function you give to catch to handle the error is of the appropriate type, and it'll catch it.
08:30:32 <Cale> (or you can use SomeException as the type, which will result in any exception being caught)
08:30:36 <nealar> maybe this is thrown not by DB.connect but by Network.connect? I have no other theories what might it be
08:31:40 <nealar> Cale: if I catch SomeException, the next task will be to decipher it - i.e. to guess the right type :) Just as what I'm trying to do now
08:33:48 <wvd> So last week I've been reading up on Haskell and became further and further (lists, higher order functions, lambdas, go on..) - now I was wondering, I'm going to do a  'hobby' project to test it in practice. I have two ideas: 1] a simple game emulator, 2] a code profiling app using graphs -- which is one would be preffered?
08:34:09 * nealar wishes Exception class to have classname:: e->String method
08:34:27 <Jafet> @hoogle typeOf
08:34:27 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
08:34:28 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
08:34:28 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
08:34:37 <kmc> can't you use Typeable for that?
08:35:09 <Jafet> TypeableN? Something tells me I don't want to know.
08:35:48 <aavogt> Jafet: would you prefer if the names were like  Monoid vs. Alternative?
08:35:52 <kmc> for typing type constructors
08:36:10 <kmc> anyway in this case plain old typeOf should suffice
08:36:14 <Jafet> aavogt, maybe, but I would have to know to decide
08:36:26 <nealar> @hoogle TypeRep
08:36:27 <lambdabot> Data.Typeable data TypeRep
08:36:27 <lambdabot> Data.Typeable typeRepArgs :: TypeRep -> [TypeRep]
08:36:27 <lambdabot> Data.Typeable typeRepKey :: TypeRep -> IO Int
08:36:27 <aavogt> > typeOf1 (Maybe 5)
08:36:28 <lambdabot>   Not in scope: data constructor `Maybe'
08:36:32 <aavogt> > typeOf1 (Just 5)
08:36:33 <lambdabot>   Maybe
08:37:03 <geheimdienst> @src Maybe
08:37:04 <lambdabot> data Maybe a = Nothing | Just a
08:37:08 <nealar> > show $ typeOf $ Just 7
08:37:09 <aavogt> I'm not sure how the situation is with overlapping instances and those typeOfDefault
08:37:09 <lambdabot>   "Maybe Integer"
08:37:45 <aavogt> but in my limited experience there aren't any problems
08:38:01 <geheimdienst> @let data Foo = Bar
08:38:01 <lambdabot>  Invalid declaration
08:39:16 <geheimdienst> > data Foo = Bar
08:39:17 <lambdabot>   <no location info>: parse error on input `data'
08:40:48 <nealar> it doesn't allow me to mix catch anf typeOf without giving explicit type :(((
08:41:01 <nealar> :t handle (error . typeOf)
08:41:02 <lambdabot>     Couldn't match expected type `[Char]'
08:41:03 <lambdabot>            against inferred type `TypeRep'
08:41:03 <lambdabot>       Expected type: e -> [Char]
08:41:17 <nealar> :t handle (error . show . typeOf)
08:41:18 <lambdabot> forall b e ex. (Typeable e, ArrowError ex (->)) => ((e, ex) -> b) -> e -> b
08:41:37 <nealar> lambdabot's GHC is smarter
08:42:03 <aavogt> what is the point of handling an error like that?
08:42:09 <aavogt> * any exception
08:42:10 <nealar> :t \x-> catch x (error . show . typeOf)
08:42:11 <lambdabot> forall a. IO a -> IO a
08:42:34 <nealar> aavogt: to find what throws it and how to handle it in real life
08:42:37 <aavogt> you may be looking at the wrong version of Control.Exception
08:43:07 <int-e> @type handle
08:43:08 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
08:43:18 <nealar> then HSQL may be using wrong version of Control.Exception
08:43:24 <int-e> @type Control.Exception.handle
08:43:25 <lambdabot> forall e a. (GHC.Exception.Exception e) => (e -> IO a) -> IO a -> IO a
08:43:27 <nealar> int-e: flip catch
08:43:50 <int-e> odd preference
08:44:20 <aavogt> @type Control.Exception.handle (\(SomeException e) -> error (show (typeOf e)))
08:44:22 <lambdabot> Not in scope: data constructor `SomeException'
08:44:29 <aavogt> @type Control.Exception.handle (\(Control.Exception.SomeException e) -> error (show (typeOf e)))
08:44:30 <lambdabot> forall a. IO a -> IO a
08:44:40 <int-e> @type catch
08:44:40 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
08:44:46 <int-e> @type Control.Exception.catch
08:44:47 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
08:44:50 <aavogt> nealar: try that
08:45:14 <aavogt> if you're using the exception module from base-4
08:45:27 <int-e> okay. I forgot about Prelude's version of catch. Lambdabot not importing Control.Exception at all is sensible.
08:46:28 <nealar> int-e: handle uses _the_right_catch_ , there is no Prelude.handle ;)
08:47:04 <Polarina> With Network.Socket, can I initialize and bind a socket in one thread, and then use it in another (forkOS compiled with -threaded)?
08:47:09 <wvd> I've implemented my maximum' function like, foldl1 (\acc x -> if acc > x then acc else x) - however, the tutorial (LYAH) uses foldr1, is there any reason for this?
08:47:53 <Polarina> wvd, why not implement it as foldl1 max ?
08:48:16 <wvd> Polarina: Could also, but is there any reason to use foldr1 instead of foldl1?
08:48:19 <Jafet> (Is foldl1 like foldl, or foldl'?)
08:48:22 <int-e> wvd: no particular reason. if you add strictness (foldl1') the left fold will be better.
08:48:51 <Polarina> > foldl1 [a,b,c,d]
08:48:53 <lambdabot>   Couldn't match expected type `a -> a -> a'
08:48:53 <lambdabot>         against inferred type `[...
08:49:01 <Polarina> > foldl1 [a,b,c,d] :: Expr
08:49:02 <nealar> *** Exception: Dynamic
08:49:03 <lambdabot>   Couldn't match expected type `a -> a -> a'
08:49:03 <lambdabot>         against inferred type `[...
08:49:18 * nealar scratches head
08:49:24 <Polarina> :S
08:49:30 <nealar> @karma+ aavogt
08:49:30 <lambdabot> aavogt's karma raised to 6.
08:49:39 <nealar> At least it gave a result
08:49:44 <Jafet> > foldl1 (*) [a,b,c,d]
08:49:45 <lambdabot>   a * b * c * d
08:49:46 <int-e> wvd: the point is that the maximum function is associative - max (max a b) c = max a (max b c), so foldl1 and foldr1 will produce the same result.
08:49:51 <exDM69> @src fix
08:49:51 <lambdabot> fix f = let x = f x in x
08:49:59 <int-e> > foldl1 f [a,b,c]
08:50:00 <lambdabot>   f (f a b) c
08:50:33 <kmc> Polarina, seems likely.  does the OS's sockets API care about threads at all?
08:50:52 <Polarina> kmc, I don't know -- I am making a program intended to run on windows.
08:51:26 <Polarina> And I have no experience with windows programming.
08:51:53 <kmc> yeah, me either :)
08:52:00 <aavogt> > foldr (&&) True [True,False,undefined]
08:52:01 <lambdabot>   False
08:52:06 <aavogt> > foldl (&&) True [True,False,undefined]
08:52:07 <lambdabot>   False
08:52:07 <pikhq> Polarina: Go back! Go back while you still can!
08:52:09 <exDM69> I still can't understand what makes fix work
08:52:14 <pikhq> There be dragons there!
08:52:14 <Polarina> pikhq, xD
08:52:23 <aavogt> > foldr (&&) True ([True,False] ++ undefined)
08:52:24 <lambdabot>   False
08:52:32 <aavogt> > foldl (&&) True ([True,False] ++ undefined)
08:52:32 <Silvah> pikhq: whatcha talkin' about?
08:52:33 <lambdabot>   *Exception: Prelude.undefined
08:52:36 <kmc> what makes "fix" work is that "let" is recursive
08:52:39 <kmc> @src fix
08:52:39 <lambdabot> fix f = let x = f x in x
08:52:42 <pikhq> Silvah: Windows programming.
08:52:54 <Silvah> Windows programming is neat.
08:53:00 <kmc> it's no more surprising than any other recursive "let", except that that's all there is
08:53:04 <Silvah> ...at least compared to you-know-what.
08:53:06 <exDM69> kmc: does it work by term rewriting in the compilation
08:53:15 <pikhq> exDM69: Well, you see. fix f is just x, where x is f x. And so x is f f x. And thus f f f x. And so on.
08:53:20 <kmc> exDM69, i don't quite follow but the answer is probably 'no'
08:53:23 <kmc> > let x = 1 : x in x
08:53:24 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:53:31 <kmc> ^^^^ there's an example, not using "fix", of recursive "let"
08:53:37 <kmc> > fix (1:)
08:53:37 <aavogt> pikhq: it might be helpful to add some parentheses there
08:53:38 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:53:42 <Silvah> > repeat 1
08:53:43 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:53:52 <pikhq> aavogt: Erm. Yes, yes it would.
08:54:15 <aavogt> perhaps even more correct that way :)
08:54:25 <wvd> So $ is (a -> b) -> a -> b, what is this? It takes a function and a as argument and returns b?
08:54:29 <kmc> @src ($)
08:54:30 <lambdabot> f $ x = f x
08:54:34 <pastorn> @let aoeu x = if x == 0 then 0 else x + aoeu (x-1)
08:54:35 <lambdabot>  Defined.
08:54:37 <kmc> wvd, it's just function application
08:54:40 <pastorn> > fix aoeu
08:54:41 <nealar> there is no way to get concrete type out of Dynamic other than guessing it, right?
08:54:44 <lambdabot>   mueval-core: Time limit exceeded
08:54:50 <Jafet> > concat $ iterate (++[1]) []
08:54:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:54:57 <kmc> wvd, it's useful to get nicer syntax, or for higher order stuff, such as using it as a section
08:54:58 <pikhq> wvd, it's just id.
08:55:03 <aavogt> nealar: no, dynamic stores the typeRep
08:55:14 <nealar> @hoogle typeRep
08:55:14 <lambdabot> Data.Typeable data TypeRep
08:55:14 <lambdabot> Data.Typeable typeRepArgs :: TypeRep -> [TypeRep]
08:55:14 <lambdabot> Data.Typeable typeRepKey :: TypeRep -> IO Int
08:55:18 <exDM69> kmc: I've implemented letrec in a programming language using term rewriting, and I recall that the haskell compiler does something similar
08:55:22 <kmc> :t dynTypeRep
08:55:23 <lambdabot> Dynamic -> TypeRep
08:55:29 <kmc> well there's no "the Haskell compiler"
08:55:35 <wvd> So.
08:55:39 <aavogt> there is the ghc though
08:55:42 <kmc> and most things a compiler does could be described as "term rewriting"
08:55:47 <kmc> i don't know what you mean more specifically
08:55:49 <pikhq> exDM69: There are many valid ways of implementing it.
08:55:51 <geheimdienst> wvd, the point of $ is that you can get rid of a few parentheses if you like: f (g 5) is the same as f $ g 5
08:55:54 <wvd> When I have something like, max a (max b c) I could write max a $ max b c?
08:56:00 <Silvah> Yup.
08:56:02 <pikhq> wvd: Yes.
08:56:03 <geheimdienst> wvd, exactly
08:56:06 <exDM69> kmc: can't remember which compiler was in question
08:56:23 <kmc> > map ($3) [pred, succ]
08:56:23 <wvd> Are these recommend using instead of parenthesis?
08:56:24 <lambdabot>   [2,4]
08:56:48 <pikhq> wvd: Often.
08:57:13 <wvd> kmc, wait, how that works? it's like succ $ 3 = succ (3)?
08:57:28 <dv-> But $ is kind of ugly
08:57:29 <applicative> wvd, geheimdeinst, $ is also good for making a section:
08:57:32 <applicative> > map ($ 4) [(+1),(+2]
08:57:33 <lambdabot>   <no location info>: parse error on input `]'
08:57:39 <applicative> > map ($ 4) [(+1),(+2)]
08:57:39 <lambdabot>   [5,6]
08:57:59 <wvd> How does that exactly work? It evaluates to (+1) $ 4? Which is (+1) (4)?
08:58:05 <tromp> also useful in return  $ a+b
08:58:09 <geheimdienst> applicative, yes that's pretty cool, someone showed me the other day :)
08:58:13 <dv-> @src ($)
08:58:14 <exDM69> pikhq: yeah, I studied letrec in depth a while ago
08:58:14 <lambdabot> f $ x = f x
08:58:26 <applicative> wvd, exactly
08:58:38 <tromp> best use is f . g . h $ x
08:58:44 <exDM69> pikhq: and I felt appaled when I found out that the classic way of doing it in lisp is with set!
08:59:05 <Jafet> News flash, lisp is impure.
08:59:10 <wvd> geheimdienst: But why I need $ here? (+1) 4 evaluates fine?
08:59:29 <nealar> @src ($)
08:59:30 <lambdabot> f $ x = f x
08:59:32 <kmc> operationally Haskell code compiled with GHC is mutating all the time
08:59:36 <nealar> just this
08:59:47 <kmc> when you evaluate a thunk it mutates to store the completed value
09:00:19 <geheimdienst> wvd: applicative wanted to show that you can run multiple functions on the same argument with the "map ($ ...)" trick
09:00:29 <geheimdienst> > map ($3) [pred, succ]
09:00:30 <lambdabot>   [2,4]
09:00:43 <wvd> geheimdienst: yes, but pred 3 works fine, why it needs to be pred $ 3?
09:00:53 <wvd> (in the map function)
09:01:15 <applicative> wvd, after map, you need a function, so map 3 [pred, succ] wouldnt work,
09:01:20 <geheimdienst> well there's no other way to write it in that case
09:01:26 <geheimdienst> > map 3 [pred, succ]
09:01:27 <lambdabot>   Ambiguous type variable `a' in the constraint:
09:01:27 <lambdabot>    `GHC.Enum.Enum a'
09:01:27 <lambdabot>      ar...
09:01:27 <aavogt> > sequence [pred, succ] 3 -- like this
09:01:28 <lambdabot>   [2,4]
09:01:53 <geheimdienst> aavogt: well that's a little confusing now :-)
09:02:03 <applicative> @type sequence
09:02:04 <aavogt> no it's not :)
09:02:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:02:05 <wvd> But how $ 3 is a function?
09:02:39 <aavogt> wvd: it's some syntactic sugar:  ($ x) == (\y -> y x)
09:02:42 <geheimdienst> $ 3 is a function that takes one more argument -- which is a function
09:02:43 <applicative> wvd, it is the 'higher order function' of applying-a-function-to-3
09:03:15 <geheimdienst> maybe you've seen things like (3 +) or (++ "abc"). that's similar to ($ 3)
09:03:28 <aavogt> err, put a $ between the y and x, if the operator actually does something
09:03:43 <geheimdienst> difference is, (++ "abc") would take a string, while ($ 3) takes a function
09:03:45 <aavogt> but have you seen (-3)?
09:03:56 <wvd> S
09:03:56 <aavogt> > (-3) 0
09:03:57 <lambdabot>   -3
09:03:58 <wvd> So*
09:04:22 <wvd> ($n) takes a function, and will be passed n as argument?
09:04:31 <aavogt> > map (-3) [0,1,2]
09:04:32 <lambdabot>   [-3,-3,-3]
09:04:48 <nealar> @hoogle Dynamic
09:04:48 <lambdabot> module Data.Dynamic
09:04:48 <lambdabot> Data.Dynamic data Dynamic
09:04:48 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
09:05:06 <applicative> aavogt, how does that work, is it reading (-3) as const
09:05:07 * geheimdienst slaps aavogt over the head with a soft, large monad
09:06:06 <aavogt> applicative: because \bot has an   instance Num a => Num (k -> a)
09:06:18 <Jafet> > 1 2
09:06:19 <lambdabot>   Ambiguous type variable `t' in the constraint:
09:06:20 <lambdabot>    `GHC.Num.Num t' arising f...
09:06:23 <applicative> aavogt, i see.
09:06:33 <applicative> > (1) 3
09:06:33 <lambdabot>   Ambiguous type variable `t' in the constraint:
09:06:34 <lambdabot>    `GHC.Num.Num t' arising f...
09:06:35 <aavogt> so    fromInteger :: Num a => Integer -> k -> a
09:06:46 <applicative> only aavogt knows how to use it
09:06:49 <aavogt> so there is a magic const there
09:07:03 <djahandarie> What is the point of that?
09:07:12 <wvd> So $n = \y -> y n, so basically it's a lambda, which first argument is a function which gets executed by what you defined using $, so ($3) succ, is succ 3?
09:07:13 <geheimdienst> wvd, yes you're right. ($) takes 2 arguments, a function and some other thing. you you can fix the latter argument to be 3 by saying ($ 3). what remains to be specified is the first argument (the function)
09:07:19 <wvd> ok
09:07:24 <wvd> thanks
09:07:32 <aavogt> wvd: the parentheses are part of the syntax for a section
09:07:48 <applicative> wvd, that's right. It's a little silly but useful sometimes.
09:08:15 <aavogt> > ((*) - (+)) 4 2:: Int
09:08:16 <lambdabot>   2
09:08:28 <aavogt> djahandarie: you can write things like that
09:09:04 <Jafet> That seems quite... pointless
09:09:05 <djahandarie> What just happened?
09:09:11 <aavogt> @unpl ((*) - (+)) 4 2
09:09:11 <lambdabot> ((*) - (+)) 4 2
09:09:12 <nealar> Just Access denied for user 'ikz_admin'@'alarum.fryazino.net' (using password: YES)
09:09:15 <aavogt> :(
09:09:16 <nealar> cool
09:09:19 <geheimdienst> woah. how can you subtract a function from a function?
09:09:26 <nealar> aavogt.thank you!
09:09:28 <tromp> :t ((*) - (+))
09:09:29 <lambdabot> forall a. (Num a) => a -> a -> a
09:09:30 <aavogt> no problem
09:09:34 <applicative> @type ((*) - (+))
09:09:34 <lambdabot> forall a. (Num a) => a -> a -> a
09:09:36 <zygoloid> @type (-)
09:09:37 <lambdabot> forall a. (Num a) => a -> a -> a
09:09:38 <applicative> ha
09:09:48 <zygoloid> geheimdienst: ^^ you just need a suitable Num instance :)
09:10:00 <tromp> who put (*) into Num?
09:10:14 <int-e> Cale, presumably
09:10:27 <geheimdienst> guys, you're giving me the willies
09:10:28 <applicative> > fromIntegral (*)
09:10:29 <lambdabot>   No instance for (GHC.Real.Integral (a -> a -> a))
09:10:29 <lambdabot>    arising from a use of ...
09:10:36 <int-e> instance Num a => Num (b -> a) ... evaluated point-wise
09:10:43 <geheimdienst> > (*) == (*)
09:10:43 <nealar> SqlError gets wrapped in Dynamic on its way somehow, so GHCi reports it as "error" not as (show SqlError)
09:10:44 <lambdabot>   *Exception: (==): No overloading for function
09:10:50 <aavogt> cale was part of the haskell committee, int-e?
09:11:01 <tromp> > (succ - pred) 42
09:11:02 <Cale> no
09:11:03 <lambdabot>   2
09:11:06 <geheimdienst> @type Num
09:11:06 <int-e> Cale runs this instance of lambdabot, IIRC.
09:11:07 <lambdabot> Not in scope: data constructor `Num'
09:11:11 <zygoloid> aavogt: no, cale chooses what language lambdabot provides :)
09:11:17 <applicative> lambdabot follows more advanced ideas
09:11:26 <aavogt> if anything, \bot should have a Num class that's split up
09:11:28 <Cale> Lambdabot just has a bunch of stuff imported :)
09:11:30 <Jafet> I bet Cale would want to be!
09:11:42 <Cale> Jafet: It might be nice :)
09:12:20 <aavogt> I dunno how useful that would be because you can't define any instances from here
09:12:39 <applicative> > pred . [1,2,3]
09:12:40 <lambdabot>   [0,1,2]
09:13:00 <geheimdienst> > pred >>= [1,2,3]
09:13:01 <lambdabot>   Couldn't match expected type `a -> a -> b'
09:13:02 <lambdabot>         against inferred type `[...
09:13:09 <geheimdienst> >  [1,2,3] >>= pred
09:13:10 <lambdabot>   No instances for (GHC.Num.Num [b], GHC.Enum.Enum [b])
09:13:10 <lambdabot>    arising from a use...
09:13:22 <geheimdienst> my monad-fu is weak
09:13:25 <wvd> Why can't I do something like: "succ . max" I need to make a curried function which is (a -> a)? Like succ . max 5
09:13:30 <applicative> > [1,2,3] >>= return . pred
09:13:31 <lambdabot>   [0,1,2]
09:13:39 <wvd> Oh, nevermind.
09:13:42 <geheimdienst> > fmap pred [1,2,3]
09:13:43 <lambdabot>   [0,1,2]
09:13:44 <aavogt> @type (succ Prelude..) Prelude.. max
09:13:45 <lambdabot> forall a. (Enum a, Ord a) => a -> a -> a
09:13:45 <zygoloid> > pred <$> [1,2,3]
09:13:46 <lambdabot>   [0,1,2]
09:13:58 <aavogt> wvd: it needs more dots
09:14:02 <wvd> let a x = succ . max x  worked fine.
09:14:08 <wvd> But I should be able to remove the x though
09:14:09 <wvd> Oh?
09:14:09 <maltem> A too special Prelude for lambdabot would defeat its purpose (among several) of teaching beginners, though
09:14:32 <aavogt> maltem: like that's it's purpose :)
09:14:35 <int-e> > ((succ .) . max) 2 3
09:14:36 <lambdabot>   4
09:14:49 <maltem> aavogt, well among several :p
09:15:31 <scree> > (fmap.fmap) succ max 9 10
09:15:32 <lambdabot>   11
09:15:36 <applicative> > succ . (max 5) $ [2,5,6]
09:15:36 <lambdabot>   No instances for (GHC.Enum.Enum [t], GHC.Num.Num [t])
09:15:36 <lambdabot>    arising from a use...
09:15:40 <int-e> > ((.) (.) (.) succ max) 2 3
09:15:41 <lambdabot>   4
09:15:49 <djahandarie> lol
09:15:54 <geheimdienst> yeah that clears things up
09:16:00 <int-e> absolutely
09:16:07 <wvd> "let b = ((succ .) . max)" won't work.
09:16:10 <applicative> > map (succ . (max 5) ) [2,5,6]
09:16:11 <lambdabot>   [6,6,7]
09:16:29 <geheimdienst> @let b = succ . max
09:16:30 <lambdabot>  Defined.
09:16:35 <aavogt> @let succMax = (succ .) . max
09:16:36 <lambdabot>  Defined.
09:16:40 <geheimdienst> > b [42, 47]
09:16:40 <aavogt> > succMax 1 2
09:16:41 <scree> > (.) (.) (.) (.) (.) succ max 5 [2,5,6]
09:16:41 <lambdabot>   Ambiguous occurrence `b'
09:16:41 <lambdabot>  It could refer to either `L.b', defined at <local...
09:16:41 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:16:41 <lambdabot>    arising from a use of `...
09:16:42 <lambdabot>   3
09:16:44 <wvd> > b 2 5
09:16:45 <lambdabot>   Ambiguous occurrence `b'
09:16:46 <lambdabot>  It could refer to either `L.b', defined at <local...
09:16:50 <wvd> > L.b 2 5
09:16:52 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
09:16:52 <lambdabot>    arising from a use of `e_125' a...
09:16:55 <wvd> See
09:17:17 <aavogt> that's because b was wrong and different from your definition
09:17:27 <geheimdienst> > (succ . max) [1,2,3]
09:17:28 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
09:17:28 <lambdabot>    arising from a use ...
09:17:36 <applicative> wvd, b 2 is the 'successor' of the function max 2, which makes no sense
09:17:47 <geheimdienst> wai it no worky?
09:17:51 <jmcarthur> 666 users?!
09:17:57 <jmcarthur> somebody leave!
09:17:58 <applicative> wvd, it still doesn't make sense when you apply it to 5
09:17:59 <dcoutts> @arr!
09:17:59 <lambdabot> Yo ho ho, and a bottle of rum!
09:18:41 <applicative> > succMax 2 5
09:18:41 <lambdabot>   6
09:18:52 <wvd> applicative: ah right, thanks
09:18:52 <dcoutts> MrFenix: you were asking about cabal overwriting data files
09:19:04 <geheimdienst> > (succ . maximum) [1,2,3]
09:19:05 <lambdabot>   4
09:19:11 <geheimdienst> ah nao it worky!
09:19:31 <aavogt> @type hBuild
09:19:32 <lambdabot> Not in scope: `hBuild'
09:19:43 <aavogt> Cale: can has HList?
09:20:14 <int-e> fun. fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap  equals  fmap fmap fmap fmap fmap fmap
09:21:11 <aavogt> the imports would be roughly http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25768#a25768
09:21:19 <aavogt> though I'm not sure about the label situation
09:21:27 <scree> int-e: how is this possible???
09:21:32 <applicative> wvd, aavogts succMax = (succ.). max  takes a number n, makes the max n function, then composes that function with succ
09:21:50 <applicative> > succMax 5 6
09:21:51 <lambdabot>   7
09:22:04 <wvd> > let x2 = succMax 5
09:22:05 <lambdabot>   not an expression: `let x2 = succMax 5'
09:22:20 <scree> > asTypeOf (fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap) (fmap fmap fmap fmap fmap fmap)
09:22:21 <lambdabot>   Overlapping instances for GHC.Show.Show
09:22:21 <lambdabot>                              ((a ->...
09:22:33 <scree> @type asTypeOf (fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap) (fmap fmap fmap fmap fmap fmap)
09:22:34 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) a1. (Functor f1, Functor f) => (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
09:22:44 <applicative> > let x2 = succMax 5 in x2 4
09:22:45 <lambdabot>   6
09:22:45 <geheimdienst> wvd, try @let
09:23:34 <wvd> Ah, this makes snese.
09:23:36 <wvd> sense*
09:23:41 * scree is deeply suspicious
09:23:46 <applicative> wvd, @let makes it store a def.  in "> let ... " one needs and " ...in ....."
09:24:01 <pastorn> > 1 0
09:24:02 <lambdabot>   Ambiguous type variable `t' in the constraint:
09:24:02 <lambdabot>    `GHC.Num.Num t' arising f...
09:24:08 <wvd> Btw, is it possible to write Haskell programs without using Monads?
09:24:08 <aavogt> hmm, though hFoldr would be rather useless since you can't do any local bindings
09:24:25 <pastorn> wvd: yes
09:24:46 <wvd> I mean, are they really neccesary in a Haskell program?
09:24:50 <pastorn> wvd: it might be a bit difficult doing IO, but other than that
09:25:03 <applicative> > 1 . 2 $ 3  -- this is twisted
09:25:04 <lambdabot>   1
09:25:06 <aavogt> I think you are sort of stuck using IO for main
09:25:07 <pastorn> wvd: not neccessary, but they help a lot
09:25:09 <geheimdienst> well, ultimately everything is in the IO monad ...
09:25:24 <pastorn> @type interact -- aavogt
09:25:25 <lambdabot> (String -> String) -> IO ()
09:25:27 <wvd> Yeah
09:25:28 <geheimdienst> there's always a point where you're saying main = do ...
09:25:31 <wvd> IO will be an exception
09:25:35 <applicative> wvd, if your program is:   putChar 'a' you don't need a monad.
09:25:42 <aavogt> pastorn: well you are still producing some IO action
09:25:47 <mux> well, putChar is still an IO action
09:25:48 <wvd> But after I've fully read LYAH I think I'll write some dummy haskell program.
09:26:00 <aavogt> which is an instance of Monad whether you use those methods yourself or not :)
09:26:08 <aavogt> @src interact -- pastorn
09:26:08 <lambdabot> Source not found. You untyped fool!
09:26:14 <pastorn> wvd: aavogt well, if main = interact f, then you're not using any monads ;)
09:26:28 <geheimdienst> @type interact
09:26:29 <lambdabot> (String -> String) -> IO ()
09:26:30 <wvd> LYAH has a section about the IO monad so it won't hurt.
09:26:33 <aavogt> pastorn: look at the definition of interact though
09:26:50 <scree> @src interact
09:26:50 <lambdabot> interact f = do s <- getContents; putStr (f s)
09:26:51 <applicative> wvd, pastorn is right, you can get a long way with text / file operations just compiling executables with the interact function.
09:27:14 <aavogt> of course, it doesn't have to be implemented like that
09:27:18 <wvd> I'm going to write a simple AST evaluator (such as (+ 3 (* 5 5)) would be 28.
09:27:37 <pastorn> wvd: do eeeeeet
09:27:38 <applicative> applicative, you can pipe through them.  All you need to do is write f::String -> String and main = interact f
09:27:49 <int-e> scree: most of those fmaps are really just (.).
09:28:15 <scree> int-e: so which ones can be dispensed with?
09:28:21 <applicative> wvd, what i just said to 'applicative,' was meant for you, alas.
09:28:50 <wvd> applicative, ah ok.
09:29:01 <wvd> anyway, still have to read like 4 chapters on LYAH, so i'll be busy for some time
09:29:22 <applicative> aavogt, I take it that interact was in the earliest 'premonadic' haskells, so it wouldn't have been thus implemented.
09:29:47 <aavogt> but we aren't using those languages
09:30:06 <applicative> indeed not
09:30:35 <mux> mmm, was't "premonadic haskell" unable to do any kind of I/O at all?
09:30:45 <mux> it sounds doubtful that it had interact
09:30:52 <aavogt> IO is necessary
09:30:56 <pastorn> mux: no, interact was used
09:31:09 <pastorn> but i'm guessing it was a special case-hackery
09:31:14 <mux> aavogt: yes, but haskell didn't have it, and you had to have a C wrapper to do the side-effetcs
09:31:16 <applicative> mux, no it used laziness.
09:31:31 <pikhq> mux: No, pre-monads, Haskell did moderately weird stuff.
09:31:50 <applicative> mux, basically an interactive program was from [Inputs] -> [Responses]
09:31:54 <pastorn> IO done through continuations :)
09:31:58 * geheimdienst thinks a language without side-effects is silly
09:32:00 <pikhq> What was it, main :: [Input] -> [Output]?
09:32:03 <mux> applicative: that's precisely what I've been describing, just now.
09:32:08 <mux> so it couldn't have interact
09:33:16 <aavogt> uh, that is interact
09:33:34 <mux> aavogt: no it's not; interact does some I/O, and such a main function does not
09:34:22 <aavogt> when a program does absolutely no IO, you might as well not run it
09:34:46 <mux> aavogt: this is going in cirlces, as I said, people used C wrappers around the main function to do all the I/O
09:35:01 <yaxu> http://vimeo.com/12081541 # haskell + emacs + acid house
09:35:46 <pikhq> mux: interact does not perform some I/O.
09:35:53 <pikhq> It is merely a value describing an IO action.
09:35:55 <aavogt> I'm not sure what you mean here. A value of type (IO a) uses a C wrapper to do I/O as much as   main :: Input -> Output
09:36:22 <mux> pikhq: that is irrelevant
09:36:24 <pikhq> You can, in fact, kinda-sorta think of (IO a) as being (Input -> Output a)
09:36:40 <jesusabdullah> Whoa
09:36:52 <jesusabdullah> yaxu: That code describes the jams, ya?
09:37:03 <yaxu> jesusabdullah: yes
09:37:10 <jesusabdullah> Neato
09:37:25 <mux> aavogt: I mean that when you use an IO action such as interact, it does the I/O itself (see the source that was pasted), whereas before, all the I/O was done in the C wrapper around the pure haskell code, this is very different
09:37:28 <pikhq> mux: It performs IO just as much as a function from Input to Output does.
09:37:38 <jesusabdullah> yaxu: How'd you do that?
09:37:44 <applicative> yaxu, i don't quite get it, do you recompile after changing the text?
09:37:44 * jesusabdullah likes
09:37:48 <pikhq> mux: Uh, all the IO is *still* done in a C wrapper around the pure Haskell code.
09:38:14 <pikhq> That's most of the GHC runtime right there!
09:38:17 <mux> pikhq: obviously no... a function from Input to Output is pure and does no side-effetcs, an IO action does some kind effects
09:38:18 <yaxu> applicative: yes when it flashes red is when I'm sending that code to ghci
09:38:28 <mux> pikhq: I'm sorry, but you're not making any sense again...
09:38:33 <pikhq> mux: No, an IO action describes some kind of effects.
09:38:40 <applicative> yaxu, but it doesn't crash the music already going on,.
09:38:41 <mux> when it's run, it does side effects.
09:38:43 <mux> same thing.
09:39:07 <yaxu> applicative: no it's just updating a mutable variable which is read by a separate scheduling thread
09:39:14 <mux> ie that is the haskell code that calls, for instance, read() or write(); not a C wrapper around it (that was written by hand)
09:39:25 <yaxu> applicative: it's called live coding
09:39:30 <applicative> yaxu, i see, that can be retained.
09:39:35 <pikhq> *cough* That's not how pre-monad Haskell IO worked.
09:40:00 <mux> pikhq: *cough* we're describing/talking about how IO was done when haskell had none...
09:40:01 <applicative> yaxu, yes, i've seen it before, but hadn't thought through even this elementary part...hah
09:40:33 <pikhq> mux: That's not "pre-monad Haskell", that's "rough draft" Haskell...
09:40:42 <mux> as far as I remmeber, this is Haskell 1.0
09:40:43 <pikhq> Haskell had IO before monads.
09:41:04 <mux> besides, whatever you want to call it, it was still working this way
09:41:35 <mux> so, I'm curious to know how IO was implemented in haskell before monads, before I've never heard that such a thing even existed
09:41:51 <byorgey> yaxu: awesome =)  are you going to release any of the code?
09:41:55 <int-e> scree: with x = fmap, we have x a b c = a (b c) (i.e. if applied to at least three arguments, fmap = (.)) and it follows that  x x x x x x x x x x x x = x (x x) x x x x x x x x = x x (x x) x x x x x x = x (x x x) x x x x x = x x x (x x) x x x = x (x (x x)) x x x = x (x x) (x x) x = x x (x x x). (note that we have x x (x x x) x x x x = x x (x x x) = x x x x x x x).
09:41:56 * pikhq shall find a link
09:42:04 <mux> please do!
09:42:12 <applicative> mux, there is a little discussion toward the beginning of 'Tackling the Awkward Squad" by Peyton Jones
09:42:15 <jesusabdullah> yaxu: I agree with byorgey.
09:42:38 <mux> applicative: I've read this paper, and I don't remember it describing any kind of I/O mechanism in haskell before monads
09:42:51 <pikhq> mux: http://research.microsoft.com/~simonpj/papers/history-of-haskell/history.pdf I think it's in there.
09:43:01 <jesusabdullah> IN A WORLD where MONADS were MERELY A DREAM
09:43:15 <jesusabdullah> only ONE MAN could READ THE OUTPUT
09:43:17 * pastorn sees pablo fransisco in his head
09:43:20 <geheimdienst> luckily, one day they said "hey, why not simply use a monoid in the category of endofunctors". everyone loved it and started writing a monad tutorial rightaway ...
09:43:22 <yaxu> byorgey: yes, next week
09:43:36 <mux> pikhq: please be more specific, I'm not going to scan the whole document :-(
09:43:38 <byorgey> yaxu: fantastic, I look forward to it with glee =)
09:43:41 <mux> I still think you're on drugs or something.
09:43:54 <mux> there are not so many ways to implement I/O in an otherwise purely functional language
09:44:01 <mux> I know of monads and uniqueness typing (a la Clean)
09:44:12 <sm> yaxu: nice!
09:44:41 <pikhq> mux: Section 7.1, "Streams and continuations".
09:44:49 <applicative> mux, pages 4 and 5, he ends mentioning
09:44:51 <applicative> mux, "Hudak and Sundaresh give a useful survey of approaches to purely-functional in- put/output [15], which describes the pre-monadic state of play."
09:44:54 <jesusabdullah> I think pik's on the same drugs all the rest of you hard-kore haskellers are, just a lot more of them
09:45:11 <pikhq> mux: Lazily, the main function was passed responses to requests that it returned.
09:45:14 * jesusabdullah still needs to snag a copy of RWS
09:45:43 <gwern> jesusabdullah: Is a man not entitled to a reliable language?
09:45:48 <pikhq> This is *kinda* like treating your program as a function from stdin to stdout, except with more varied semantics.
09:45:49 <mux> pikhq: yes, so this entirely confirms what I've been saying...
09:45:53 <gwern> no! says the lisper; dynamicism is power.
09:46:00 <pikhq> mux: ... No, it doesn't.
09:46:08 <gwern> no! says the mler; impurity is more natural
09:46:08 <jesusabdullah> hahaha
09:46:19 <pikhq> mux: It says that it worked much as it does now, except with a less clean abstraction.
09:46:20 <gwern> no! says the MSM programmer; all is impure
09:46:22 <mux> pikhq: that is how "I/O" was handled, but haskell still wasn't doing any I/O itself; some C wrapper was, it is wildly different
09:46:30 <gwern> I rejected those answers. I chose... Haskell. a language where the pure need not fear the impure.
09:46:36 <pikhq> mux: *Haskell is still doing that*.
09:46:42 <mux> pikhq: no it's not
09:46:47 <gwern> Where the function is not bound by petty type systems
09:46:54 * applicative hands immense foam mallets to mux and pikhq
09:47:01 <jesusabdullah> gwern++
09:47:10 <pikhq> mux: There are 0 side effects caused by the evaluation of an IO action.
09:47:10 <gwern> Where the large would be manipulated by the small
09:47:23 <gwern> And with the sweat of your brain, Haskell can become your language as well!
09:47:28 <pikhq> mux: Just as there are 0 side effects caused by the evaluation of a function from Input to Output.
09:47:30 <geheimdienst> pikhq, but not at runtime ...?
09:47:36 <mux> pikhq: so, I must have been dreaming last time I wrote stuff in a file with Haskell code :-)
09:47:45 <pikhq> mux: There are, however, side effects caused by the execution of an IO action.
09:48:02 <mux> I've adressed this petty distinction of yours earlier, it's still irrelevant
09:48:21 <jesusabdullah> Not that I'm an expert, but it sounds like a legit distinction
09:48:22 <geheimdienst> pikhq, you mean roughly evaluating IO actions happens at compile-time, and executing them at run-time, right?
09:48:24 <pikhq> mux: Much like there are side effects caused by getting requests out of a function, executing them, and then passing in the responses.
09:48:28 * applicative hands even more immense foam mallets to mux and pikhq
09:48:40 <jesusabdullah> YES
09:48:51 <jesusabdullah> Ooh! Can we make pinata mallets?
09:48:54 <BONUS> i think it's a legit destinction. otherwise evaluating putStrLn "foo" `seq` () would print stuff
09:48:56 <jesusabdullah> Then there will be CANDY
09:48:59 <pikhq> geheimdienst: Kinda.
09:49:27 <mux> pikhq: calling putStrLn in some haskell functions ends up doing a side-effect, and it is the function itself that does it, not some wrapper hidden behind it.
09:49:28 <applicative> > length (map putChar "hahah")
09:49:29 <lambdabot>   5
09:49:46 <jesusabdullah> Why do you guys care? Just ooc?
09:49:49 <BONUS> applicative: that's just evaluating the spine though
09:49:51 <mux> this is in no way the same
09:49:58 <BONUS> > length (map undefined "12345")
09:49:58 <lambdabot>   5
09:50:05 <pikhq> mux: No, you're not calling putStrLn in functions.
09:50:22 <pikhq> Well. You are, but not getting side effects out of it.
09:50:34 <pikhq> > (\_ -> putStrLn "foo") ()
09:50:35 <pikhq> 0 side effects!
09:50:35 <lambdabot>   <IO ()>
09:50:45 <pikhq> Hmm.
09:50:47 <applicative> that looks like a side effect
09:50:50 <pikhq> @src IO
09:50:50 <lambdabot> Source not found. I feel much better now.
09:50:52 <mux> pikhq: congratulations on being full of shit two days in a row and boring me to death. I'm now done with this discussion (again).
09:50:53 <geheimdienst> In 1996 Haskell gained monads, enabling serious I/O, ensuring decades of debate on IRC, and boosting the foam mallet industry.
09:50:59 <tag> So what exactly is <> (and on a similar note, what's <$> ?)
09:51:13 <pikhq> Coulda sworn that lambdabot had the import of GHC's IO.
09:51:14 <gwern> @hoogle (<>)
09:51:14 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
09:51:15 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
09:51:27 <gwern> as usual, the type sigs are informative
09:51:29 <geheimdienst> @src putStrLn
09:51:29 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
09:51:32 <mux> @src IO Monad
09:51:32 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:51:33 <applicative> mux, it's okay, isn't it, I was learning from the discussion, thinking about it.
09:51:34 <geheimdienst> @src putStr
09:51:35 <lambdabot> putStr s  = hPutStr stdout s
09:51:40 <geheimdienst> @src hPutStr
09:51:40 <lambdabot> Source not found. Take a stress pill and think things over.
09:51:42 <mux> applicative: I guess it is :-)
09:51:47 <geheimdienst> ah-ha!
09:51:54 <nostrand> ><
09:51:59 <pikhq> mux: Basically, though: IO is currently treated as something *roughly* like (RealWorld -> (RealWorld, a))
09:52:07 <mux> pikhq: I know how it is treated
09:52:08 <tag> They will become informative, I'm still a bit confused by most of the haskell punctuation
09:52:13 * nostrand is SDL + Haskell ^^
09:52:28 <mux> pikhq: you are completely out of touch with the reality, and what's worse, I fear that you're confusing newbies in here, but whatever.
09:52:30 <applicative> pikhq, mux is clearly not an idiot.  I
09:52:37 <applicative> am an idiot.. haha
09:52:51 <mux> it's a good thing people have been researching a way to model side-effects in a purely funcitonal language, now thanks to pikhq, we all know they were wrong.
09:53:22 <pikhq> mux: Are you familiar with Lazy K's IO?
09:53:25 <jesusabdullah> I don't think newbies really know enough to have an intelligent discussion on this subject
09:53:28 <jesusabdullah> I would know
09:53:32 <jesusabdullah> I am ubernoob
09:53:32 <geheimdienst> pikhq, that looks like the State monad
09:53:39 <applicative> mux, pikhq is clearly not an idiot, I'm an idiot
09:53:51 <pikhq> geheimdienst: There's strictness annotations in there somewhere.
09:53:54 <pikhq> I don't remember the details.
09:54:05 <soupdragon> stop calling yourself idiots.......
09:54:11 <pikhq> There's also a nice sprinkling of magic.
09:54:17 <applicative> soupdragon, ok
09:54:20 <mux> pikhq: listen; a side-effect is something you can observe after calling some function that isn't contained in the result type. if I call writeFile or whatever in Haskell, I can observe it afterwards. So, by defintion, my function did some side-effects.
09:54:33 <geheimdienst> soupdragon, yourself or each other? is each other still fine?
09:54:39 <mux> now, if I have a main function returning a Response, I can not observe any change afterwards
09:54:48 <mux> because the C wrapper still has to do the I/O itself
09:54:50 <EvanR-work> writeFile does not cause a side effect
09:54:55 <pikhq> mux: main = do writeFile; ... -- You say this is a function that had side effects?
09:54:55 <mux> so my main function wasn't doing any I/O at ALL.
09:54:56 <EvanR-work> when 'called'
09:54:56 <BONUS> mux: you don't really *call* things in haskell. you evaluate expressions or you perform side-effects
09:54:58 <mux> pikhq: understand now?
09:55:09 * applicative hands *even more* immense foam mallets to mux and pikhq to clobber each other with, without side-effects
09:55:11 <pikhq> It is neither a function nor does evaluating it cause side effects.
09:55:33 <mux> at this point I'm not sure how to explain things to you
09:56:06 <jesusabdullah> applicative: I was hoping for the side effect of candy spraying everywhere. I'm disappointed.
09:56:18 <pikhq> mux: I think you're just not getting how stream-based IO worked. Look into Lazy K; it's *similar*, but significantly more *obvious* in its treatment of IO.
09:56:20 <applicative> jesusabdullah, Im working on it
09:56:25 <BONUS> putStrLn "foo" isn't a function, it's an I/O action. and there's a difference between performing an I/O action and evaluating it.
09:56:39 <mux> BONUS: the semantic difference here is entirely irrelevant.
09:56:46 <EvanR-work> no it isnt
09:56:50 <BONUS> how so?
09:56:59 <mux> because whatever you call it, the explanation remains the same
09:57:02 <pikhq> (Lazy K is a purely functional esoteric programming language, that has stream-based IO.)
09:57:05 <applicative> mux, i don't see that.  you are skipping over the crucial role of "main = ...", no?
09:57:09 <mux> isn't that the definition of irrelevance?
09:57:10 <EvanR-work> you can manipulate groups of IO actions independently of executing them
09:57:18 <BONUS> like i said, if it were irrelevant, evaluating putStrLn "foo" `seq` () would do side-effects
09:57:22 <jesusabdullah> pikhq is kind of an expert on esoteric programming languages, I've noticed.
09:57:23 <mux> applicative: really, I'm not :-)
09:57:24 <Silvah> Hi all...
09:57:29 <jesusabdullah> pikhq: Did you ever try Piet?
09:57:36 <pikhq> jesusabdullah: It's a hobby of mine.
09:57:40 <pikhq> jesusabdullah: No, I've not tried Piet.
09:57:41 <jesusabdullah> sup Silvah
09:57:53 <jesusabdullah> pikhq: I've been meaning to, but it's been hard to wrap my head around
09:57:57 <EvanR-work> hopefully what BONUS said doesn't get washed away in this insanity
09:58:08 <gwern> Lazy K sounds like a street name for a drug
09:58:09 <mux> applicative: when your main :: [Request] -> [Response] returns, no I/O has been done yet; in modern Haskell with main :: IO (), when main returns, the I/O has been performed
09:58:35 <mux> EvanR-work: what BONUS said was entirely true, but also entirely irrelevant to the present discussion
09:58:48 <BONUS> the only time when evaluation causes side-effects is in interleaved I/O
09:58:48 <pikhq> mux: You seem to be *horribly* confused about how that [Request] -> [Response] thing works.
09:59:01 <mux> pikhq: yes, sure, whatever
09:59:07 <jesusabdullah> whoa, ddg's first result for Lazy K was an implementation on github
09:59:09 <jesusabdullah> WIN
09:59:13 <jesusabdullah> <3 ddg
09:59:14 <applicative> pikhq, why say mux is confused, etc. just keep elucidating your take on it.
09:59:18 <soupdragon> ddg?
09:59:25 <soupdragon> what is it
09:59:28 <jesusabdullah> duckduckgo.com
09:59:36 <jesusabdullah> Nifty search engine
09:59:37 <mux> applicative: that's when people do when they have no further arguments
09:59:39 <pikhq> The runtime passes it a cons cell containing two thunks, and it results in a cons cell containing two thunks.
09:59:39 <Jafet> mux, you are using time-based conjunctions. That is patently wrong
09:59:40 <mux> what
10:00:05 <jesusabdullah> You guys ever listen to Chemical Bros?
10:00:13 <mux> yeah, right, so main :: [Request] -> [Response] is the same as main :: IO (); one has to wonder why monads were even brought into haskell then.
10:00:14 <pikhq> (strictly speaking, it passes a thunk that results in a cons cell. Anyways.)
10:00:15 <jesusabdullah> [music] -> [response]
10:00:25 <soupdragon> oh it's aggregating multiple search engines?
10:00:28 <zygoloid> mux: what do you mean by "when your main :: [Request] -> [Response] returns"?
10:00:30 <jesusabdullah> soupdragon:
10:00:32 <jesusabdullah> er
10:00:44 <mux> Jafet: for the case of main returning, it's completely true - for other functions it's not given that the result may not be evaluated yet
10:00:46 <zygoloid> you mean, when the resulting list has been evaluated to HNF or to RNF?
10:01:00 <pikhq> mux: Also, it's [Response] -> [Request].
10:01:14 <EvanR-work> since when does 'main' ever return
10:01:17 <mux> pikhq: thanks for once again pointing out something entirely irrelevant
10:01:23 <jesusabdullah> soupdragon: I don't think so! It's just another player, so to speak, but it has a few cool features. One of them is "zero-click info." It also seems to be particularly good for searching for software-related stuff
10:01:32 <mux> I'm so sorry for inverting the order of parameters
10:01:56 <pikhq> The runtime evaluates the head thunk of the Request, which may or may not require evaluating the head thunk of Response. It then executes the action described by the Request. The result of this will be the value of the next Response thunk.
10:02:03 <EvanR-work> main may or may not finish evaluating
10:02:04 <aristid> pikhq: what is this? 1992?
10:02:10 <pikhq> This repeats until you get a Request to exit, or [].
10:02:11 <geheimdienst> soupdragon: i think it's a search engine of its own, but it does some cleverness like making snippets from wikipedia extra-long. all the guys on hacker news seem to be using it now ...
10:02:18 <glguy> The [Response] -> [Request] approach was very clumsy and bug-prone
10:02:20 <pikhq> aristid: We *are* discussing pre-monad IO in Haskell.
10:02:31 <jesusabdullah> mux: I would think that, even if these things are only indirectly related to your argument, that making a lot of mistakes would still erode at your, umm, umm...shit.
10:02:35 <jesusabdullah> Lost the word.
10:02:39 <jesusabdullah> mux: CREDIBILITY!
10:02:47 <jesusabdullah> mux: It would erode at your credibility.
10:02:55 <mux> I don't care much about my credibility :-)
10:02:56 <EvanR-work> shit works
10:03:12 <pikhq> The reason why monads are the preferred abstraction is that this stream-based IO method is a *massive* pain.
10:03:13 <jesusabdullah> mux: It kinda matters if you're trying to win a logical argument, dontcha think? 's all I'm sayin'
10:03:19 * zygoloid really doesn't understand what mux and pikhq are arguing about; the IO monad can be implemented in terms of a [Response] -> [Request] model
10:03:22 <soupdragon> not really no
10:03:24 <Jafet> Kindly discommence flagellation upon equine demise.
10:03:31 <soupdragon> you should use reasonable arguments rather than authority
10:03:33 <pikhq> zygoloid: I've said as much.
10:04:02 <soupdragon> e.g. generally you find out someone has a PhD just after you find out they don't know the answer to something
10:04:02 <mux> you've also said many more wrong things
10:04:08 <jesusabdullah> soupdragon: Was that directed at me?
10:04:12 <soupdragon> no
10:04:15 <jesusabdullah> Okay
10:04:26 <applicative> EvanR-work, the dispute is about 'pre-monadic IO' vs monadic
10:04:31 <pikhq> zygoloid: mux is claiming you had to have a "manual C wrapper" for pre-monad Haskell, whereas with monads, you get "functions having side effects".
10:04:33 <mux> I remember when #haskell was a peaceful place
10:04:39 <jesusabdullah> because I was gonna say, I definitely don't think authority implies credibility in and of itself
10:04:59 <geheimdienst> mux, monads seem to bring quite a bit of peace to the haskellers
10:05:12 <Silvah> mux: and the idyllic world shattered, as usual.
10:05:51 <zygoloid> pikhq: well, in both cases it depends how you implement it. but that sounds like a reasonable way of describing the difference between obvious implementations of the two approaches
10:06:17 <EvanR-work> applicative: right, now whats the dispute?
10:06:32 <pikhq> zygoloid: As in "you must *manually write C code* that calls your purely functional Haskell stuff", as opposed to letting the runtime do the work.
10:06:47 <soupdragon> before monads there was still IO
10:06:50 <pikhq> (at least, as far as I was getting it; please, let me know if I misrepresented something)
10:07:00 <mux> I don't care anymore really
10:07:02 <geheimdienst> soupdragon! don't get them started again!
10:07:05 <applicative> EvanR-work, I think that's still the main issue, but there is an underlying dispute about contemporary IO.   The obscurity of the matter is leading to dogmatism.
10:07:09 <soupdragon> @applicative
10:07:09 <lambdabot> Unknown command, try @list
10:07:16 <mux> I'm sufficiently comforted by the fact that at least one other person told you my way of describing this was reasonable
10:07:24 <soupdragon> mux what did you descibe?
10:07:49 <mux> soupdragon: we were discussing the differences between the treatment of I/O in haskell before and after monads
10:08:03 <soupdragon> it's on dons blog I'll find it for you guys
10:08:04 * jesusabdullah goes BACK IN TIME and issues a FATWAH decreeing that you must manually write C code that calls purely functional Haskell.
10:08:06 <djahandarie> If an error is being thrown to a thread, is it possible to catch it in that thread?
10:08:10 * jesusabdullah dusts off his hands
10:08:20 <pikhq> jesusabdullah: Bweheheh.
10:08:35 <jesusabdullah> \o/
10:08:49 <EvanR-work> then haskell would be purely function for real real ;)
10:08:49 <soupdragon> http://donsbot.wordpress.com/2009/01/31/reviving-the-gofer-standard-prelude-circa-1994/
10:08:52 <applicative> pikhq, Peyton  Jones says explicitly that there was a  C wrapper for main:: String -> String and a more complex one for main:: [Req]->{Resp]
10:08:52 <EvanR-work> functional
10:09:11 <soupdragon> There is one approach to pre-monadic IO
10:09:20 <Silvah> Haskell was an esoteric language before monads, wasn't it?
10:09:23 <pikhq> applicative: There exists, in effect, such a wrapper in modern Haskell.
10:09:24 <zygoloid> applicative: pikhq's complaint was against the suggestion that end-users had to write their own such wrapper
10:09:36 <pikhq> It's just significantly more complex.
10:09:48 <pikhq> And less of a pain to deal with.
10:10:03 <mux> zygoloid: I don't think that was the crux of the debate
10:10:11 <soupdragon> so what's the problem
10:10:11 <soupdragon> ?
10:10:17 <applicative> pikhq, yes, the runtime, but it doesn't operate on a concrete type in quite that way.
10:10:20 <zygoloid> mux: i don't think the debate had a meaningful crux
10:10:21 <soupdragon> everyone read that link
10:10:32 <mux> possibly not
10:10:45 <geheimdienst> Silvah, yeah, it's amazing how mainstream you can make something if you just add a few monoidal endofunctors
10:10:53 <pikhq> mux: ... So, your entire point was that the runtime had to be implemented in a somewhat different way to deal with the *slightly* different semantics?
10:11:00 <soupdragon> lol
10:11:13 <pikhq> Wrapped in moderately confusing verbiage? Wow. This feels somewhat silly now.
10:11:16 <djahandarie> Seems it is impossible to catch an error thrown by throwTo outside of where it is thrown
10:11:16 <mux> pikhq: I told you already I'm not interested in this anymore, please drop it, for everyone's sake.
10:11:25 <pikhq> ...
10:11:36 <pikhq> (oh, and ad hominems! Can't forget those!)
10:11:47 <applicative> mux, pikhq, it does seem reasonable to drop it,
10:11:51 <geheimdienst> http://xkcd.com/386/
10:11:55 <jesusabdullah> ad homonyms?
10:12:02 <applicative> and wait for a learner's syntax errors!
10:12:07 <jesusabdullah> er, add homonyms?
10:12:13 <pikhq> applicative: There's nothing to discuss.
10:12:18 <EvanR-work> jesusabdullah: lol
10:12:32 <pikhq> Well, unless we just want to flame. In which case, I'll need to find my asbestos underpants.
10:12:37 <applicative> pikhq, there are always new type violations!!
10:12:44 <dolio> If [Response] -> [Request] is more purely functional than IO, then that's just a proof that being purely functional sucks.
10:12:49 <applicative> > head 3
10:12:50 <lambdabot>   No instance for (GHC.Num.Num [a])
10:12:50 <lambdabot>    arising from a use of `e_13' at <inter...
10:13:14 <applicative> > reverse 3
10:13:15 <lambdabot>   No instance for (GHC.Num.Num [a])
10:13:15 <lambdabot>    arising from a use of `e_13' at <inter...
10:13:26 <applicative> hi edwardk_
10:13:32 <edwardk_> heya applicative
10:13:59 <tromp> :t reverse []
10:14:00 <Polarina> Does anyone have any instructions on how to compile into an windows executable with ghc (and some libraries from hackage)?
10:14:01 <lambdabot> forall a. [a]
10:14:24 <EvanR-work> [Request] -> [Response] looks like part of larger message passing object oriented system, those never seemed to have a problem with IO :)
10:14:58 <applicative> Polarina, isnt is just   ghc --make -O2 Foo.hs -o foo.exe  ?
10:15:06 <Silvah> Pok
10:15:06 <soupdragon> edwardk did you see huttons F5 paper?
10:15:16 <soupdragon> edwardk I was like "HEY !!! I know this!!!"
10:15:28 <Silvah> er
10:15:29 <Silvah> Whatever.
10:15:39 <Silvah> applicative is faster than me.
10:15:47 <edwardk> soupdragon: yeah, factorizing folds?
10:15:49 <soupdragon> edwardk because it was your Kan extension/CPS optimizing thing
10:15:54 <soupdragon> yeah
10:15:57 <Polarina> applicative, I still need to install some libraries from hackage (I am using wine)...
10:16:04 <jesusabdullah> Has anyone made some nifty windows software with haskell yet?
10:16:10 <edwardk> soupdragon: yeah the codensity example made me smile =)
10:16:20 <Silvah> cabal install?
10:16:34 <applicative> edwardk, i predicted you would like the codensity example
10:16:36 <Polarina> Silvah, how do I install cabal?
10:16:45 <Silvah> ...seems like I'm the only Windows user here.
10:17:07 <applicative> Polarina, i totally don't understand wine, but can you install the Haskell Platform?
10:17:18 <jesusabdullah> Polarina: cabal install cabalinstall ;)
10:17:19 <Silvah> Download cabal-install from its site. Yup, very hard.
10:17:30 <applicative> cabal install cabal-install
10:17:37 <jesusabdullah> d-oh!
10:17:53 <jesusabdullah> ohhhhh
10:17:57 <edwardk> applicative: i pointed out to voightlaender tha connection between his cps hack and the codensity monad right after he published the asymptotic improvement of free monads paper, so some of this is old hat, but it is nice to see if nicely tied up with a formal worker-wrapper transformation bow put on top.
10:18:17 <applicative> Polarina, if you have installed the Platform, you have the cabal executable (not to be confused with the Cabal lib it uses)
10:18:29 <edwardk> Silvah: nah, i run windows... i just use ghc inside of a linux vm ;)
10:18:49 <Polarina> Ok, thanks. :)
10:19:00 <jesusabdullah> I install haskell on a windows box once
10:19:06 <applicative> Polarina, that's the answer, set up a linux vm inside wine.....
10:19:21 <edwardk> i actually do have ghc installed in windows as well, i just never really use it
10:19:27 <jesusabdullah> Couldn't get all the deps for whatever I wanted to run installed in my short timeframe, though
10:19:57 <Polarina> Configuring parsec-2.1.0.1...    spawnv failed: errno 2: No such file or directory
10:20:12 <Polarina> I get that error when running  wine cabal.exe install parsec
10:20:16 <EvanR-work> ghci in a 'dos prompt' is pretty funny ;)
10:20:31 <edwardk> applicative: ahaha
10:20:40 <Silvah> Polarina: try under real Windows.
10:20:41 * geheimdienst uses arch linux full-time for the smug superiority, but sometimes, when no-one is looking, boots into windows to play civilization for an evening
10:20:52 <shadwick> hello
10:20:53 <Polarina> Silvah, I don't have a real Windows. :(
10:21:04 <Silvah> No, wine does not count, cuz it is buggy.
10:21:10 <Polarina> :(
10:21:19 <glguy> How do you know that someone uses Arch Linux?
10:21:24 <glguy> He tells you without being asked!
10:21:25 <edwardk> Polarina: sounds like cabal is looking for one of the standard paths from windows for something like its global config dir, or user install dir, etc.
10:21:26 <EvanR-work> msys works in wine, so should ghc
10:21:33 <Silvah> Oh, this makes things complicated...
10:21:38 <edwardk> Polarina: and choking because it can't find it on your platform
10:21:49 <applicative> Polarina, I'm worried there's not going to be too much wisdom about such indirect use of cabal install.   There must be someone who knows what happens with `wine cabal.exe install parsec`
10:21:59 <Twey> glguy: And hangs out in #haskell ;)
10:22:08 <edwardk> glguy: Because haskell works and not much else? =)
10:22:19 <geheimdienst> glguy lol :-P
10:22:34 <applicative> I wonder if dcoutts is familiar with a setup like Polarina's
10:22:39 <edwardk> j/k i actually don't know the current state of arch's packages in general
10:22:40 <EvanR-work> i keep arch a secret because its embarrassing
10:22:40 <soupdragon> I try to use arch but it doesn't install :(
10:23:05 <glguy> — Sent from my MacBook Pro
10:23:12 * geheimdienst any moment now will start into a big lecture about his awesome homegrown shell scripts he uses for wifi connectivity
10:23:30 <applicative> soupdragon it's very easy to install as long as you dont want silly things like an internet connection, usb support, etc.
10:23:41 <EvanR-work> applicative: wifi
10:23:42 * edwardk has this awesome script for wifi connectivity.. called windows ;)
10:23:44 <soupdragon> I have a mac so I can't install any Linux
10:23:47 <soupdragon> That is why problem
10:23:58 <edwardk> my linux VMs have it easy ;)
10:24:06 <soupdragon> yeah I have to use a VM but it is slow
10:24:10 <jesusabdullah> soupdragon: wait, shouldn't you be able to throw linux on it pretty easy? :S
10:24:21 <soupdragon> jesusabdullah: I wish it was easy :/
10:24:25 <soupdragon> I tried for weeks though
10:24:31 <EvanR-work> arch is for x86 only
10:24:34 * applicative is secretly pleased he can't set up wifi on his arch laptop.   the usb problem is graver.
10:24:42 <jesusabdullah> oh geez :(
10:25:03 <geheimdienst> applicative, you're pleased you can't?
10:25:04 * jesusabdullah keeps using fedora
10:25:17 <geheimdienst> jesusabdullah, fedora is an old hat
10:25:19 <p_l> applicative: what chipset and what issues?
10:25:23 <glguy> jesusabdullah: Did you upgrade to 13?
10:25:25 <edwardk> geheimdienst: *groan*
10:25:28 <soupdragon> lol
10:25:37 <soupdragon> I can boot mac os off a USB
10:25:37 <jesusabdullah> geheimdienst: Ah, but old hats fit well don't they? :D
10:25:46 <soupdragon> but I couldn't find a single linux distro which boots off the USB
10:25:53 <applicative> p_I , i haven't thought about it for a while.
10:26:01 <Polarina> USB works just fine on Arch.
10:26:03 <soupdragon> some of them boot of CD though, but once you install them it doesn't boot off the HD >:[
10:26:14 <soupdragon> not for me, it does not work when I try it
10:26:20 <jesusabdullah> glguy: Not yet. I downloaded the F13 beta like 2 weeks ago and never got around to installing it on my desktop
10:26:20 <byorgey> -blah please
10:26:32 <applicative> what byorgey said
10:26:33 * edwardk stopped using red hat around the time they spun up fedora
10:26:40 <jesusabdullah> (desktop runs a dying install of untuntuo, and the whole "let's fuck up gnome" thing kinda pissed me off)
10:26:50 <edwardk> yeah, sorry =)
10:26:53 <jesusabdullah> (that and I've found fedora works better for me)
10:27:06 <guest11> Argh.
10:27:17 <lispy> Why is unfoldr a right unfold?
10:27:21 <applicative> guest11, hi
10:27:25 <guest11> Linux weenies?
10:27:28 <lispy> I'm not visualizing this
10:27:28 <byorgey> @type unfoldr
10:27:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:27:47 <edwardk> lispy: it tells you how to generate each constructor in turn.
10:27:49 <lispy> :t foldr
10:27:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:27:55 <byorgey> lispy: I guess because it generates things starting at the beginning of the list, as opposed to the end.
10:27:58 <guest11> Why there is no unfoldl?
10:28:08 <jesusabdullah> There isn't?
10:28:14 <jesusabdullah> (weird)
10:28:17 <lispy> guest11: I think unfoldl would only work for finite things
10:28:17 <edwardk> lispy: a left unfold would generate in the other direction from the base case and not give a result until it completed with the parens in the wrong order lke foldl
10:28:28 <edwardk> lispy: exactly
10:28:29 <byorgey> unfoldl would be pretty inefficient.  better to just use unfoldr to generate the list backwards and then reverse it when you're done.
10:28:35 <guest11> Oh, I've quitted IRC finally.
10:28:44 <edwardk> guest11: reverse . unfoldr ;)
10:29:14 <lispy> byorgey: but the beginning of the list is at the left, correct?
10:29:17 <djahandarie> Ugh, killThread does not seem to be killing my thread
10:29:24 <edwardk> lispy: yes
10:29:29 <byorgey> lispy: yes, but the 'left/right' has to do with the associativity
10:29:45 <edwardk> so to use the output of an unfoldl you need to know when it stopped, so you need to run the whole thing through to completion
10:29:55 <byorgey> lispy: in some sense the first thing foldr does is process the leftmost element of a list, as well
10:30:09 <lispy> oh, first : (second : (third :  ( ... ))))  ?
10:30:14 <edwardk> lispy: yeah
10:30:18 <byorgey> it's called foldr because it applies the combining function associated to the right, not because it starts on the right.
10:30:33 <lispy> I think I'm visualizing it now :)
10:30:34 <applicative> > let f b = Just (chr b, succ b) in take 20 $ unfoldr f 1
10:30:35 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4"
10:30:43 <byorgey> > foldr f a [x,y,z]
10:30:44 <lambdabot>   f x (f y (f z a))
10:30:55 <applicative> > let f b = Just (chr b, succ b) in take 20 $ unfoldr f 32
10:30:55 <lambdabot>   " !\"#$%&'()*+,-./0123"
10:31:16 <geheimdienst> lambdabot, no swearing plz
10:31:26 <guest11> lol
10:31:31 <applicative> > let f b = Just (chr b, succ b) in take 12 $ unfoldr f 32
10:31:31 <lambdabot>   " !\"#$%&'()*+"
10:31:50 <guest11> She does not listen to you.
10:31:55 <byorgey> lambdabot is channeling Q*bert
10:32:14 <applicative> > foldr f a [b,c,d,e,f,g,h,i,j]
10:32:15 <lambdabot>   Ambiguous occurrence `b'
10:32:15 <lambdabot>  It could refer to either `L.b', defined at <local...
10:32:15 <geheimdienst> lambdabot is a she? woah
10:32:24 <applicative> > foldr f a [c,d,e,f,g,h,i,j]
10:32:24 <lispy> > take 3 $ unfoldr (\x -> (Just (xs!!x), succ x) 0 [x,y,z]
10:32:24 <lambdabot>   f c (f d (f e (f f (f g (f h (f i (f j a)))))))
10:32:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:32:28 <guest11> Yup.
10:32:29 <djahandarie> Is there some more violent way to kill a thread than killThread?
10:32:38 <wvd> Could anyone give a simple example of Data.Function.on?
10:32:46 <danharaj> murderThread?
10:32:49 <gwern> djahandarie: you could exit the main thread
10:32:52 <edwardk> byorgey: haha
10:32:56 <guest11> Operating system's API, perhaps.
10:32:57 <applicative> @type Data.Function.on
10:32:57 <djahandarie> gwern, except that
10:32:57 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:32:58 <Zao> wvd: Normally used by compare?
10:33:00 <gwern> that'd cause the OS itself to get involved
10:33:06 <Zao> compare `on` wtf
10:33:07 <edwardk> wvd: compare `on` fst
10:33:08 <Zao> Or something.
10:33:11 <gwern> djahandarie: whine whine whine
10:33:15 <guest11> wtf?
10:33:18 <djahandarie> gwern, I'm actually hacking up Mueval right now
10:33:21 * Zao hands gwern some cheese.
10:33:26 <lispy> > take 3 $ unfoldr (\x -> (Just (xs!!x), succ x)) 0 [x,y,z]
10:33:27 <lambdabot>   Not in scope: `xs'
10:33:28 <guest11> @let wtf = id
10:33:29 <lambdabot>  Defined.
10:33:32 <lispy> hehe, oops
10:33:33 <edwardk> wvd: would compare a pairs by their first element
10:33:48 <guest11> :t compare `on` wtf
10:33:49 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
10:33:49 <lispy> > take 3 $ unfoldr (\x -> (Just ([x,y,z]!!x), succ x)) 0
10:33:50 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:33:50 <lambdabot>         against inferred type ...
10:33:59 <gwern> djahandarie: hah. well if you find a way to kill a non-allocating tightly looped (green) thread which doesn't involve the process level, good luck!
10:34:12 <edwardk> > on compare length [1,2,3] [0,0]
10:34:13 <lambdabot>   GT
10:34:17 <applicative> @type  compare `on` fst
10:34:18 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
10:34:28 <applicative> @type  compare `on` length
10:34:29 <lambdabot> forall a. [a] -> [a] -> Ordering
10:34:37 <guest11> > on compare wtf 1 2
10:34:38 <lambdabot>   LT
10:34:47 <djahandarie> gwern, seems like you have been through this process
10:34:50 <applicative> @type wtf
10:34:51 <lambdabot> forall a. a -> a
10:34:57 <djahandarie> gwern, how does lambdabot do it without the whole bot going down?
10:34:58 <gwern> djahandarie: well yeah, since I wrote mueval
10:35:11 <gwern> djahandarie: well, first mueval is a separate process
10:35:21 <gwern> djahandarie: second, mueval is *2* processes.
10:35:27 <edwardk> @type (+) `on` length -- and its ilk can be useful if you need to add up common properties
10:35:28 <lambdabot> forall a. [a] -> [a] -> Int
10:35:42 <geheimdienst> > sortBy (compare `on` length) ["lolcats", "foo", "x"]
10:35:43 <lambdabot>   ["x","foo","lolcats"]
10:35:53 <glguy> Can I global tell cabal-install to create all build files in ~/.cabal/build rather than adding directories to my individual source trees?
10:35:55 <djahandarie> gwern... I... see...
10:35:57 <Starfire> :t (&&&)
10:35:58 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:36:02 * glguy is poking around ~/.cabal/config
10:36:09 <gwern> djahandarie: the first process, the watchdog process, doesn't touch the expression; it passes it on ot the second process, which tries to eval it; the first process has a timer and kills the second if the second doesn't kill itself/exit
10:36:25 <edwardk> @let sortOn f = sortBy (compare `on` f)
10:36:27 <lambdabot>  Defined.
10:36:34 <djahandarie> gwern, yeah, I see the watchdog code
10:36:35 <applicative> wvd, I hope some of this is helping.  they seem to be talking about compare not on
10:36:42 <djahandarie> I'm I suppose to forkIO a forkedProcess?
10:36:47 <djahandarie> Am*
10:36:49 <lispy> take 3 $ unfoldr (\i -> Just (([x,y,z]!!i), succ i)) 0  -- geez, I had a lot of typos :)
10:36:56 <lispy> > take 3 $ unfoldr (\i -> Just (([x,y,z]!!i), succ i)) 0
10:36:57 <lambdabot>   [x,y,z]
10:37:01 <gwern> djahandarie: you just can't do it as a single process. because any threads 'are' the process, and if any threads goes into a 100% CU loop, then the whole process is looped, even if you had a thread with a timeout
10:37:04 <wvd> applicative, I gotit now I think, thanks.
10:37:09 <guest11> unfoldr yourself.
10:37:15 <applicative> wvd, cool
10:37:31 <gwern> djahandarie: this is because of the GHC RTS; the RTS only switches threads and can run timeouts on every malloc, but if there are no mallocs, the RTS never ever runs
10:37:39 <geheimdienst> > sortBy (comparing length) ["lolcats", "foo", "x"]
10:37:40 <lambdabot>   ["x","foo","lolcats"]
10:37:47 <geheimdienst> > sortBy (compare `on` length) ["lolcats", "foo", "x"]
10:37:48 <lambdabot>   ["x","foo","lolcats"]
10:37:48 <djahandarie> Hm
10:37:48 <gwern> djahandarie: so, if you try to evaluate 'let x = x in x'...
10:38:07 <gwern> (at least, I think that's one of the non-allocating epxressions. there are a few in the test suite)
10:38:07 <djahandarie> gwern, my trouble is that I don't want the results to go to stdout
10:38:22 <djahandarie> gwern, so I was making it pass the result back via the MVar
10:38:32 <djahandarie> Except now I have the killing issues
10:38:38 <gwern> djahandarie: yeah, I don't see any safe way to do that
10:38:56 <gwern> djahandarie: like I said, you *have* to have process level boundaries for security, and MVars don't work across process boundaries
10:39:00 <gwern> that I know of, anyway
10:39:34 <djahandarie> So then how is lambdabot working with stdout? Does it do that hDuplicateTo thing?
10:40:11 <djahandarie> (I was going to look at lambdabot code but the repo was down)
10:40:26 <gwern> c.h.o is dead *again*? oy
10:40:33 <gwern> djahandarie: well you could just 'cabal unpack lambdabot'
10:40:37 <gwern> not like it changes very often
10:40:44 <djahandarie> It's back up now though
10:41:10 <gwern> djahandarie: but I think Eval.hs is just reading stdout
10:41:17 <djahandarie> Ah
10:41:29 <gwern> Eval.hs:            (out,err,_) <- popen binary args Nothing
10:42:25 <guest11> So simple...
10:42:32 <djahandarie> ...popen?
10:42:37 <nus> pipes
10:42:44 <gwern> djahandarie: some wrapper over System.Process I think
10:42:47 <gwern> should be in lambdabot-utils
10:42:50 <djahandarie> I know, but I didn't know Haskell provided it
10:42:51 <djahandarie> Alright
10:42:59 <djahandarie> This all seems so damn dirty though
10:43:19 <gwern> it is
10:43:48 <gwern> but until ghc hq fixes the tight loop problem, you need processes, and what besides stdin/out is a standard IPC method?
10:44:19 <djahandarie> Nothing, I guess. :(
10:46:57 <gwern> djahandarie: incidentally, chrisdone has a fork of mueval where you feed in expression on stdin, not the stdargs, and get back results
10:47:48 <rajeshsr> @hoogle a -> [a] -> Integer
10:47:48 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
10:47:49 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:47:49 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:48:11 <rajeshsr> @hoogle a -> [a] -> Int
10:48:11 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
10:48:11 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
10:48:11 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
10:48:37 <rajeshsr> @src intersperse
10:48:37 <lambdabot> intersperse _   []     = []
10:48:37 <lambdabot> intersperse _   [x]    = [x]
10:48:37 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
10:48:53 <soupdragon> > 27*72
10:48:54 <lambdabot>   1944
10:49:04 <soupdragon> > 1944*4
10:49:04 <lambdabot>   7776
10:50:13 <MilosDj> .
10:50:37 <soupdragon> :t palindrome
10:50:38 <lambdabot> forall a. (Show a) => a -> Bool
10:50:49 <soupdragon> > find (palindrome . (*27)) [1..
10:50:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:50:52 <soupdragon> > find (palindrome . (*27)) [1..]
10:50:52 <lambdabot>   Just 37
10:51:35 <gwern> @unlet
10:51:36 <lambdabot>  Defined.
10:51:38 <gwern> bwa ha ha ha
10:51:50 <soupdragon> > find (palindrome . (*13574)) [1..]
10:51:51 <lambdabot>   Just 1588
10:52:03 <shadwick> why don't people just do that in ghci?
10:52:08 <shadwick> instead of IRC
10:52:28 <gwern> shadwick: kibbitzers'
10:52:29 <rajeshsr> @src sort
10:52:29 <lambdabot> sort = sortBy compare
10:52:38 <soupdragon> > 13574*1588
10:52:39 <lambdabot>   21555512
10:53:25 <rajeshsr> well, how does sorting pairs work? Does it derive Ord?
10:53:39 <rajeshsr> how about arbitrary tuples?
10:53:39 <c_wraith> @instances Ord
10:53:40 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:54:03 <rajeshsr> c_wraith, thats cool!
10:54:04 <zygoloid> rajeshsr: lexicographically
10:54:26 <rajeshsr> how do you make it for arbitatry tuples? seems it has only till length 5..
10:54:27 <c_wraith> rajeshsr, it's obviously not a complete list.  But it's a nice hint.
10:54:56 <soupdragon> > find (palindrome . product . (\i->[1..i])) [1..]
10:54:57 <lambdabot>   Just 1
10:54:57 <rajeshsr> zygoloid, hmm! thanks
10:54:58 <Gracenotes> it only goes up to 11-tuples
10:55:00 <soupdragon> > find (palindrome . product . (\i->[1..i])) [2..]
10:55:01 <lambdabot>   Just 2
10:55:06 <soupdragon> > find (palindrome . product . (\i->[1..i])) [3..]
10:55:07 <lambdabot>   Just 3
10:55:08 <soupdragon> oh god dammit
10:55:11 <soupdragon> > find (palindrome . product . (\i->[1..i])) [10..]
10:55:15 <lambdabot>   mueval-core: Time limit exceeded
10:55:17 <Gracenotes> but you can derive Ord automatically for any length data type, so, shouldn't a huge problem..
10:55:25 <soupdragon> there may not even exist one of those
10:55:42 <rajeshsr> Gracenotes, yeah. was wondering how you do it for arbitrary length..
10:56:08 <Gracenotes> and data types shouldn't be that huge, for performance reasons
10:56:25 <rajeshsr> @hoogle count
10:56:25 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
10:56:25 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
10:56:25 <lambdabot> Data.ByteString.Lazy count :: Word8 -> ByteString -> Int64
10:57:14 <byorgey> preflex: seen sfultong
10:57:15 <preflex>  sfultong was last seen on #haskell 16 hours, 17 minutes and 17 seconds ago, saying: byorgey: ok
10:57:16 <rajeshsr> is there any builtin function to count the number of "e" in a list L?
10:57:24 <Gracenotes> :t filter
10:57:25 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:57:26 <Zao> length . filter?
10:57:46 <byorgey> rajeshsr: no, but I often define  count p = length . filter p
10:57:47 <rajeshsr> Zao, ha, ok!
10:57:58 <Zao> byorgey: length . filter $ p ?
10:58:03 <Zao> Oh, nvm.
10:58:05 <byorgey> no
10:58:06 <Zao> Can't read tonight.
10:58:12 <Zao> Silly you, naming your predicate p :D
10:58:26 <byorgey> what do you name your predicates? =)
10:58:26 <Zao> Pointless person-type person.
10:58:27 <zygoloid> > take 3 $ filter palindrome (scanl1 (*) [1..])
10:58:29 <lambdabot>   [1,2,6]
10:58:35 <jkingkong> are there any sorted data structures? i.e. sorted sequence, sorted array, etc? I don't seem to see any on hackage
10:58:36 <Zao> byorgey: f
10:58:44 <rajeshsr> byorgey, hmm, thanks!
10:58:48 <zygoloid> jkingkong: Data.Set is a sorted sequence
10:58:56 <Zao> byorgey: All functions should be named f. If need be, f''.
10:58:59 <jkingkong> zygoloid: thanks for that
10:59:01 <byorgey> Zao: hehehe
10:59:18 <Zao> xxs'''
10:59:29 <Zao> You know you need variable naming when you end up with such things in a function.
10:59:43 <Silvah> So all functions are equal?
11:00:35 <nus> λετ φ = f ιν f
11:00:43 <jmcarthur> only in the "liberty" sense
11:00:45 <byorgey> Silvah: if you only name functions f, you will only ever have one in scope, so you might as well assume they are all equal ;)
11:02:28 <zygoloid> > let f f = f in f f f f f 'f'
11:02:30 <lambdabot>   'f'
11:03:00 <geheimdienst> i smell a new section in the "evolution of a haskeller" coming up
11:03:27 <rajeshsr> > let f y = map (\x -> (x, (length . filter (== x) $ y)) y
11:03:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:03:36 <rajeshsr> what is wrong with that?
11:04:16 <geheimdienst> you got 4 opening parens and only 3 closing
11:05:44 <byorgey> > let f y = map (\x -> (x, (length . filter (== x) $ y))) y in f [1,2,3,2,2,3,1]
11:05:45 <lambdabot>   [(1,2),(2,3),(3,2),(2,3),(2,3),(3,2),(1,2)]
11:06:38 <rajeshsr> yeah, go that!
11:06:40 <rajeshsr> thanks
11:07:01 <rajeshsr> somehow i unnecessarily put a parenthesis for snd
11:09:35 * hackagebot sifflet 0.1.6 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-0.1.6 (GregoryWeber)
11:10:11 <rajeshsr> any other simpler way to make a histogram?
11:10:29 <rajeshsr> > let f y = map (\x -> (x, (length . filter (== x) $ y)) y in f [1,1,2,1,2,1]
11:10:30 <lambdabot>   <no location info>: parse error on input `in'
11:10:50 <rajeshsr> > let f y = map (\x -> (x, length . filter (== x) $ y)) y in f [1,2,1,1,2,1,1]
11:10:51 <lambdabot>   [(1,5),(2,2),(1,5),(1,5),(2,2),(1,5),(1,5)]
11:11:57 <rajeshsr> > let f y = nub . sort . map (\x -> (x, length . filter (== x) $ y)) $ y in f [1,2,1,1,2,1,1]
11:11:58 <lambdabot>   [(1,5),(2,2)]
11:13:12 <aristid> :t nub
11:13:13 <lambdabot> forall a. (Eq a) => [a] -> [a]
11:13:18 <aristid> @src nub
11:13:19 <lambdabot> nub = nubBy (==)
11:13:24 <aristid> @src nubBy
11:13:25 <lambdabot> nubBy eq []             =  []
11:13:25 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:14:06 <aristid> > nub [1,2,3,1,2,1,4]
11:14:07 <lambdabot>   [1,2,3,4]
11:14:24 <aristid> wow that function must be expensive
11:14:36 <mauke> > nub [0 ..]
11:14:36 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:21:00 <forrest> what's the best way to generate a list like ["outfile.part001","outfile.part002", ... ] ?
11:21:16 <nostrand> forrest: Haskell ;)
11:22:01 <applicative> > map ("outfile.part00"++) [1..9]
11:22:02 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:22:02 <lambdabot>    arising from the literal ...
11:22:15 <copumpkin> you'll probably want printf to prefix numbers with 0s
11:22:22 <applicative> hahah
11:22:28 <copumpkin> > printf "%03d" 5 :: String
11:22:29 <lambdabot>   "005"
11:22:31 <applicative> > map ("outfile.part00"++) ['1'..'9']
11:22:31 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:22:32 <lambdabot>         against inferred ty...
11:22:41 <applicative> man i'm a type disaster today.
11:23:00 <forrest> applicative: interesting, but I want a list to go up to "outfile.part999"
11:23:02 <copumpkin> > map (("outfile.part" ++) . printf "%03d") [1..]
11:23:03 <lambdabot>   ["outfile.part001","outfile.part002","outfile.part003","outfile.part004","o...
11:23:17 <applicative> > map ("outfile.part00"++).show $ [1..9]
11:23:18 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:23:18 <lambdabot>         against inferred ty...
11:23:20 <mauke> > map (printf "bla %03d") [1 ..]
11:23:21 <lambdabot>   Ambiguous type variable `b' in the constraints:
11:23:21 <lambdabot>    `Text.Printf.PrintfType ...
11:23:27 <mauke> > map (printf "bla %03d") [1 ..] :: [String]
11:23:27 <lambdabot>   ["bla 001","bla 002","bla 003","bla 004","bla 005","bla 006","bla 007","bla...
11:23:31 <copumpkin> yeah, now I feel dumb
11:23:38 <Starfire> :t printf
11:23:39 <forrest> ah, that's exactly it
11:23:39 <lambdabot> forall r. (PrintfType r) => String -> r
11:23:50 <forrest> so printf is pretty much like C then?
11:23:55 <copumpkin> not really
11:24:00 <copumpkin> it's like printf and sprintf rolled into one
11:24:04 <kaol> > map (reverse.(:"00trap.eliftou")) ['1'..'9']
11:24:05 <lambdabot>   ["uotfile.part001","uotfile.part002","uotfile.part003","uotfile.part004","u...
11:24:07 <applicative> but printf is gross
11:24:08 <copumpkin> not sure why, cause it's annoying and doesn't buy you much
11:24:11 <forrest> but the format string syntax is the same
11:24:17 <copumpkin> yeah
11:24:24 <portnov> @djinn [(a, b)] -> ([a], [b])
11:24:24 <lambdabot> Error: Undefined type []
11:24:31 <mauke> printf is awesome
11:24:39 <soupdragon> i'm not that keen on it
11:24:41 <Starfire> > printf "%d" "not a number"
11:24:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:24:43 <lambdabot>    `GHC.Show.Show a'
11:24:43 <lambdabot>      a...
11:24:44 <copumpkin> I still don't like that it goes into IO too
11:24:59 <pastorn> copumpkin: huh?
11:25:13 <copumpkin> printf can print directly if you put it in an IO context
11:25:15 <forrest> well how to make my list without printf then?
11:25:24 <pastorn> yes, obviously :D
11:25:41 <rajeshsr> @hoogle printf
11:25:41 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
11:25:41 <lambdabot> module Text.Printf
11:25:41 <lambdabot> Text.Printf class PrintfArg a
11:27:16 <Starfire> @src printf
11:27:17 <lambdabot> Source not found. Do you think like you type?
11:27:58 <mux> > map (\i -> let end = show i in concat ["outfile.part", replicate (3 - length end) '0', end, ".txt"]) [1..999]
11:27:59 <lambdabot>   ["outfile.part001.txt","outfile.part002.txt","outfile.part003.txt","outfile...
11:28:07 * mux doesn't like printf as well
11:28:17 <mux> at least in its current incarnation
11:28:28 <forrest> ok i have this idea of using [1000 ... 1999] and converting to string, then taking the tail
11:28:35 <mauke> forrest: ew
11:28:40 <mauke> just use printf
11:28:47 <forrest> ah, mux similar to what i was thinking
11:29:00 <mux> forrest: but the printf version is a lot more simpler and readable
11:29:06 <Zao> zipWith (printf "%d %d")   -- :D
11:29:11 <mux> so if the fact that it's not type-safe doesn't itch you, just use that
11:29:20 <forrest> i realize it's a bad idea but i hope someone will show me how to do it anyway, i've been trying here in ghci and can't quite get it
11:29:29 <mauke> $(printf "template-haskell%03d")
11:30:12 <forrest> yeah, i'll use printf, i'm coming from C
11:31:43 <rajeshsr> :t printf
11:31:44 <lambdabot> forall r. (PrintfType r) => String -> r
11:31:59 <rajeshsr> printf "%d%d" (1,2)
11:32:00 <Starfire> Is there a document somewhere that details how printf is implemented in Haskell?
11:32:03 <rajeshsr> > printf "%d%d" (1,2)
11:32:04 <lambdabot>   No instance for (Text.Printf.PrintfArg (t, t1))
11:32:04 <lambdabot>    arising from a use of `e...
11:32:10 <pastorn> Starfire: the source?
11:32:32 <pastorn> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/Text-Printf.html
11:32:33 <rajeshsr> > printf "%d%d" 1
11:32:34 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:32:34 <lambdabot>    `Text.Printf.PrintfType ...
11:32:37 <rajeshsr> > printf "%d" 1
11:32:38 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:32:38 <lambdabot>    `Text.Printf.PrintfType ...
11:32:48 <rajeshsr> how do you use it?
11:32:54 <mux> Starfire: I've seen blog posts about it but I don't have the link anymore - it involves type-class trickery
11:33:09 <pastorn> > printf "%d" 1 :: String
11:33:10 <mauke> > printf "%d" 1 :: String
11:33:10 <lambdabot>   "1"
11:33:11 <lambdabot>   "1"
11:33:14 <pastorn> haha
11:33:15 <mauke> > ""++ printf "%d" 1
11:33:16 <lambdabot>   "1"
11:33:20 <pastorn> mauke: <3 <3 <3
11:33:45 <mux> pastorn: how is the source going to help a haskell newcomer understand it? we used to help people in here instead of displaying such an attitude...
11:33:56 <pastorn> haha...
11:34:13 <pastorn> a haskell newcomer probably shouldn't mess with printf :)
11:34:25 <mux> Starfire: maybe look up "varadic functions haskell", I think the title was something along those lines
11:34:37 <mauke> @where oleg
11:34:37 <lambdabot> http://okmij.org/ftp/
11:35:17 <rajeshsr> > printf "%s" 1  :: String
11:35:17 <lambdabot>   "*Exception: Printf.printf: bad argument
11:35:23 <rajeshsr> > printf "%d" 1  :: String
11:35:24 <lambdabot>   "1"
11:35:31 <rajeshsr> > printf "%d %d" 1  :: String
11:35:31 <mux> mauke: is the template haskell version of printf that is type-safe and also allows to pass formats as strings as usual available in hackage?
11:35:31 <lambdabot>   "1 *Exception: Printf.printf: argument list ended prematurely
11:35:33 <mauke> see http://okmij.org/ftp/Haskell/polyvariadic.html
11:35:38 <rajeshsr> > printf "%d %d" (1,2)  :: String
11:35:39 <lambdabot>   No instance for (Text.Printf.PrintfArg (t, t1))
11:35:39 <lambdabot>    arising from a use of `T...
11:35:46 <rajeshsr> > printf "%d %d" 1 2  :: String
11:35:47 <lambdabot>   "1 2"
11:35:47 <mauke> mux: well, I know mine is
11:35:58 <mauke> @hackage printf-mauke
11:35:59 <lambdabot> http://hackage.haskell.org/package/printf-mauke
11:36:02 <rajeshsr> strange! so you can write variadic functions in haskell?
11:36:15 <mauke> rajeshsr:  http://okmij.org/ftp/Haskell/polyvariadic.html
11:36:27 <mux> forrest: so, you could also use that printf implementation
11:36:33 <Gracenotes> it would be a nice convenience if n-tuples were treated as n consecutive arguments
11:36:49 <Gracenotes> since the only purpose of polyvariadic printf is convenience
11:37:01 <Gracenotes> and also formatting things
11:37:06 <mauke> Gracenotes: when does that ever come up?
11:37:14 <rajeshsr> mauke, thanks!
11:37:15 <edwardk> Gracenotes: unless you use a TH variadic printf
11:37:32 <forrest> mux: i'm liking your solution now better
11:37:45 <mux> forrest: here, have my glasses then :D
11:38:11 <mux> I really only wrote it to show it was of course possible to write this without printf :-)
11:38:15 <Gracenotes> mauke: well. 3-4 times for me.. mostly having to shoehorn something at the end of a long line of computation that results in a tuple
11:38:28 <Gracenotes> so I end up using uncurry
11:38:32 <edwardk> Gracenotes: it is kind of nice when you want to check the compile time correctness of gettext-style formatting strings.
11:38:36 <Gracenotes> or pattern matching, if all else fails
11:39:30 <Gracenotes> edwardk: yeah, like gcc does. does the formatting string survive past compile time, though?
11:40:10 <edwardk> Gracenotes: in my case, yes. i load and check all the po files to make sure the format strings are compatible, but then i let others get loaded at runtime
11:42:03 <edwardk> Gracenotes: if i could work out a sufficiently smart 'config.dyre'/xmonad-like automatic rebuild process that was portable i might just check them upon building the modules in question, but i haven't gone there yet
11:43:49 <Gracenotes> mauke: though.. since the nature of printf is that it probably will end up getting used with code in do blocks or with lots of where/let clauses, making it work pointfree isn't a huge concern most of the time
11:45:26 <tag> Is there a better "Haskell for C programmers" tutorial than the one on the haskell.org website?
11:46:59 <applicative> > map (("outfile.part"++).reverse . take 3 . (++ repeat '0') . reverse . show ) [98..102]
11:46:59 <lambdabot>   ["outfile.part098","outfile.part099","outfile.part100","outfile.part101","o...
11:47:00 <c_wraith> tag, have you read lyah?  It's a good intro
11:47:00 <pastorn> tag: if you already know C you can probably read RWH without any major difficulty
11:47:43 <tag> RWH?
11:47:54 <p_l> tag: real world haskell
11:48:08 <applicative> forrest, ^^^ That's kind of lame, I didn't see mux's unprintfy solution;
11:48:27 <wvd> Is it normal that "data" doesn't work in ghci?
11:48:28 <mauke> @where rwh
11:48:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:48:31 <mauke> wvd: yes
11:48:41 <wvd> mauke, ok, thanks.
11:49:38 <forrest> applicative: his was     map (\i -> let end = show i in concat ["outfile.part", replicate (3 - length end) '0', end, ".txt"])  [1..999]
11:49:44 <edwardk> wvd: the stuff you can type in at the ghci prompt is more or less what you can do inside of a 'do' in haskell, which doesn't include making data or type definitions. =/
11:50:12 <wvd> edwardk: mmh, do? I think I didn't read about that yet.
11:50:15 <edwardk> wvd: this is the source of the need to use 'let ..' to bind variables, etc. and some of the other quirks of the syntax you use at the ghci prompt
11:50:31 <edwardk> wvd: mostly just providing you a reference point for when you get there ;)
11:50:51 <wvd> edwardk: oh, thanks. I think I saw LYAH mentioned it.
11:50:54 <applicative> forrest, I meant, I saw it after I spammed with mine.  mux's avoids the obnoxious reverse. f . reverse trick
11:51:16 <edwardk> do comes up when you start playing with monads (and hence whenever you really need IO, since IO is a monad)
11:51:45 <wvd> edwardk: I'm thinking of just reading up about the IO monad, and forget about monad, going to write some simple program then first.
11:51:46 <applicative> edwardk, IO is other things besides a monad
11:51:52 <edwardk> we usually hold off on explaining those for a while, because until you get your head around the way haskell works, they can really throw your thinking off
11:52:14 <wvd> k
11:52:18 <edwardk> applicative: sure, hence my attempt to surround that with weasel words ;)
11:52:39 <mauke> wvd: sounds like a good plan
11:52:41 * edwardk remembers to add more next time =)
11:53:40 <rajeshsr> :t ()
11:53:41 <lambdabot> ()
11:53:45 <rajeshsr> > ()
11:53:46 <lambdabot>   ()
11:54:05 <rajeshsr> flip ($) ()
11:54:07 <rajeshsr> > flip ($) ()
11:54:08 <lambdabot>   Overlapping instances for GHC.Show.Show ((() -> b) -> b)
11:54:08 <lambdabot>    arising from a ...
11:54:29 <rajeshsr> > flip ($) $ ()
11:54:30 <lambdabot>   Overlapping instances for GHC.Show.Show ((() -> b) -> b)
11:54:30 <lambdabot>    arising from a ...
11:54:41 <wvd> So.. data Foo = Baz Int Int | Bar Int Int - "Foo" is the type, what are Baz and Bar?
11:54:44 <applicative> > flip ($) () (const 3)
11:54:45 <lambdabot>   3
11:54:51 <wvd> They're just a simple function taking 2 parameters?
11:55:29 <applicative> wvd, inter alia, they are such functions,
11:55:39 <mauke> wvd: that's one half of it
11:55:53 <mauke> you can also use them in patterns to extract values from a Foo
11:55:59 <applicative> wvd, but if Foo a = Baz a a | Bar a a
11:56:13 <mauke> oh, and they're called "data constructors"
11:56:26 <wvd> But, in function type declarations I can't use Baz or Bar? I have to use "Foo"?
11:56:42 <applicative> wvd, then people say "Foo" is a 'type constructor' and "Baz" and "Bar" are as mauke says, data constructors
11:56:57 <wvd> Ah.
11:57:04 <wvd> But what if I have: "data Foo = Int Int Int"
11:57:08 <applicative> wvd, yes, the type is what's mentioned in the signature, not data...
11:57:08 <wvd> I have no data constructor?
11:57:17 <mauke> wvd: no, the first Int is your data constructor
11:57:18 <tag> :t *
11:57:18 <applicative> yeah, it makes no sense
11:57:18 <lambdabot> parse error on input `*'
11:57:31 <edwardk> wvd: they are called 'data constructors' they act like functions that you an pattern match on
11:57:32 <applicative> data Foo = Foo Int Int Int
11:57:36 <mauke> Foo ~ (Int, Int)
11:57:46 <edwardk> wvd: then the data constructor is named Int
11:58:14 <wvd> Let's say I want to create a type which represent an packet. It has three fields: opcode, length, data (String for now) - would I just do "data Packet = Int Int String"?
11:58:20 <wvd> represents*
11:58:28 <wvd> Or is there a more convenient way.
11:58:30 <edwardk> wvd: data Packet = Packet Int Int String
11:58:47 <wvd> Ah
11:58:48 <edwardk> wvd: or type Packet = (Int, Int, String) -- which is probably a bad idea since you can't make instances for it
11:58:54 <mauke> possibly use an enum for the opcode
11:59:05 <applicative> wvd, you can reuse the type constructor for one of its data constructors.
11:59:15 <mauke> no, you can reuse the name
11:59:21 <applicative> right
11:59:25 <mauke> since values and types live in different namespaces
11:59:58 <applicative> or, since names of values and names of types are in different name spaces?
12:00:05 <edwardk> types constructors and typeclasses fall in one logical name space and data constructors in another, so the name reuse doesn't conflict.
12:02:56 <applicative> wvd, edwardk's "data Packet = Packet Int Int String" is a standard way to do what you want; in older texts they might have written
12:04:44 <jlouis> also, it screams to the use of ByteString over String :)
12:04:51 <applicative>  "data Packet = MkPacket Int Int String" to distinguish they type constructor from the data constructor.
12:05:05 <wvd> jlouis: I know, was just a quick example.
12:05:09 <wvd> applicative, why would I do that?
12:05:29 <applicative> wvd, you mean write "data Packet = MkPacket Int Int String"
12:05:33 <mauke> data Packet = Packet{ opcode :: Int, length :: Int, data :: String }
12:06:10 <wvd> Also, just a question, because I'm wondering. When I want my type to be comperable I need to be a member of the Eq typeclass - but is it possible to implement own behaviour of the == operator? Other question, how does Eq compare your own types? How does it know what to compare?
12:06:49 <mauke> it doesn't
12:06:53 <nus> @src (==)
12:06:53 <lambdabot> x == y = not (x /= y)
12:07:00 <edwardk> sure, you can define Eq's methods separately, but stylistically it should satisfy a == b <=> compare a b == EQ
12:07:08 <mauke> wvd: by default your new type will not support ==
12:07:17 <wvd> mauke: what if I do deriving (Eq)
12:07:21 <applicative> @type compare
12:07:22 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
12:07:31 <mauke> wvd: then the compiler will generate the obvious Eq instance for you
12:07:51 <edwardk> wvd: then it takes it from the contents of the newtype and just defines the obvious equality
12:08:09 <wvd> mauke: ok, but let's say I have my Packet type, and == should be True when the opcode is the same, can I define this behaviour somewhere?
12:08:15 <mauke> yes
12:08:18 <mauke> by writing an Eq instance
12:08:22 <wvd> Ok
12:08:31 <edwardk> wvd: instance Eq Packet where Packet a _ _ == Packet b _ _ = a == b
12:08:33 <applicative>  "data Packet = Packet Int Int String deriving Eq"  will require all fields the same
12:08:46 <edwardk> wvd: however, i would not recommend defining equality in such a way as a general rule.
12:09:06 <edwardk> equality is usually best provided 'structurally' even if you need to define other combinators to access the field you want
12:09:14 <mauke> or (with my record type): instance Eq Packet where (==) = (==) `on` opcode
12:09:28 <edwardk> that way someone can check packets for structural equality with (==) or use (==) `on` opcode when they want to compare opcodes
12:09:44 <wvd> true
12:10:18 <edwardk> in general it is useful to be able to rely on reasoning like a == b    implying f a == f b
12:10:37 <edwardk> wvd: which you lose if you use a non-structural equality like the one you proposed
12:10:42 <soupdragon> im gonna write a polynomial in haskell
12:10:54 * edwardk hands soupdragon a [Double] ;)
12:11:26 <edwardk> for sparse polynomials, I should also hand you an IntMap Double ;)
12:11:33 <soupdragon> hm
12:11:36 <soupdragon> hmmmmmm
12:11:59 <soupdragon> I wonder if that is all I need
12:12:15 <edwardk> soupdragon: wrapping them in newtypes never hurts, but that should probably get you by ;)
12:12:39 <soupdragon> newtype Polynomial = MkPolynomial { unPolynomial :: IntMap Rational }
12:12:40 <soupdragon> ?
12:12:55 <wvd> Where a typeclasses uses for? Can I see this an java interface? e.g. we define a typeclass when certain types share the same behaviour on certain operations?
12:12:56 <edwardk> yeah
12:13:23 <mauke> wvd: yes, but there are a few differences
12:13:24 <copumpkin> wvd: you can if d(i/o)bblego isn't around, but they're much more flexible than interfaces
12:13:48 <mauke> you can invent a new typeclass and make an existing type an instance of it
12:13:59 <mauke> java classes have to specify their interfaces in the declaration
12:14:02 <edwardk> wvd: typeclasses give you a slightly less 'ad hoc' ad hoc polymorphism. the java interface is a good analogy, but there are differences because you'll note you define the data in one part and the instances separately. in java you ball it all up in one thing
12:14:25 <mauke> the other difference is in how you use them
12:14:31 <wvd> meh, I think I'm going to close this guide and start writing code, seems more efficient
12:14:35 <mauke> java interfaces autogenerate existentials for you
12:14:53 <mauke> e.g. there's no way to write Eq in java
12:15:10 <edwardk> wvd: c++ uses the notion of a vtable to implement inheritance, etc. if you're familiar with the idea, the vtable is stored in each object. a typeclass is a 'naked vtable' without the attached object, which is built up using type information. -- but that is probably not a nice intuition if you don't do a lot of c++ or com interop ;)
12:15:14 <mauke> hmm, I might be wrong there; I'm not taking generics into account
12:15:37 <wvd> edwardk: meh, I never really looked deep into C++, just Java/Python
12:16:19 <mreh> Java is like a rockpool
12:16:23 <Polarina> Does anyone have a nice function to parse an IP-addres:port combination? :)
12:16:30 <mauke> interface Eq { public boolean eq(Eq); }  // is this valid java syntax?
12:16:45 <systemfault> The only wrong thing is that there 1 vtable per class, not per object
12:16:51 <soupdragon> http://pastie.org/980592
12:16:55 <soupdragon> that's me exausted already
12:17:00 <soupdragon> I can't wirte any more
12:17:22 <wvd> mauke: mmh, public boolean eq(Eq e); is I think.
12:17:43 <copumpkin> you can't force it to be the same type
12:17:53 <mauke> wvd: the point is that this is different from the Haskell typeclass
12:18:12 <ArkRost> Hi! Does Template haskell provide tools for redefining build-in functions and keywords?
12:18:15 <mauke> 'Eq' really means 'an unknown class implementing Eq' there
12:18:35 <mauke> whereas in (==) :: (Eq a) => a -> a -> Bool, the a's have to be the same
12:18:53 <mauke> ArkRost: what's a built-in function?
12:18:56 <copumpkin> ArkRost: there are no built-in functions that are always visible (except for one value, iirc)
12:19:12 <nus> ArkRost, why would you want redefine keywords, though?
12:19:16 <copumpkin> actually, even that isn't always visible
12:19:25 <copumpkin> :t realWorld#
12:19:26 <lambdabot> Not in scope: `realWorld#'
12:20:22 <edwardk> systemfault: depends on your inheritance model, simple subclasses tend to  share the vtable and just add to the end of it when you subclass, but i admit the analogy leaks ;)
12:20:50 <copumpkin> @quote analogy
12:20:50 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
12:20:56 <copumpkin> @quote analogies
12:20:56 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
12:20:59 <edwardk> ArkRost: short answer: no ;)
12:21:02 <copumpkin> @quote dmwit analogies
12:21:03 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
12:21:19 * edwardk spends a lot of time in that category
12:21:27 <systemfault> edwardk: I never made any analogy, I just made a comment :(
12:21:33 <wvd> putStrLn returns an IO action with the type of ()?
12:21:43 <nus> bad explanations have arrows all messed up
12:21:46 <mauke> wvd: yes
12:21:56 <edwardk> systemfault: i was referencing my analogy in a somewhat self deprecating manner
12:22:50 <applicative> wvd, the 'IO action' returns () to speak that way, as getLine returns some String
12:23:03 <newsham> hrmmm.. dr klein spoke at galois last week?
12:23:09 <nus> ArkRost, metaprogramming is done in Template Haskell, if you're in search of macros
12:23:14 <wvd> Oh wait.
12:23:18 <EvanR-work> () is the coolest value/type
12:23:24 <newsham> does galois have videos of talks yet?
12:23:28 <aristid> EvanR-work: no it's not
12:23:31 <wvd> Why wouldn't it return Nothing?
12:23:39 <mauke> wvd: Nothing is not a type
12:23:47 <EvanR-work> aristid: yes it is! yes it is!
12:23:52 <newsham> evanr: i prefer uninhabited types
12:23:59 <aristid> EvanR-work: no, forall a. a is cooler
12:24:11 <wvd> mauke, oh right
12:24:13 <EvanR-work> @src ()
12:24:13 <lambdabot> data () = ()
12:24:15 <applicative> wvd, you can define functions IO (Maybe String)
12:24:23 <EvanR-work> @src Void
12:24:24 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:24:34 <mauke> newtype Void = Look Void
12:24:40 <applicative> wvd, such 'actions' would return Nothing, or Just "hahahah"
12:24:47 <aristid> EvanR-work: but seriously, the coolest type is obviously: 1
12:24:55 <wvd> mmh, getLine is enough for my program I was planning to make.
12:24:56 <EvanR-work> 1 is a type?
12:25:02 <aristid> hell yeah
12:25:08 <mauke> > undefined :: 1
12:25:09 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
12:25:09 <lambdabot>    arising from a use of ...
12:25:17 <wvd> putStrLn - is there a equilivant of which doesn't put a newline at the end?
12:25:18 <newsham> by "1" do you mean "()"?
12:25:23 <danharaj> :k 1
12:25:24 <lambdabot> *
12:25:28 <aristid> :t undefined :: 1
12:25:29 <lambdabot> Unit
12:25:33 <mauke> wvd: yeah, putStr
12:25:36 <aristid> newsham: no, it's Unit, which is different.
12:25:48 <mauke> wvd: you may be interested in http://mauke.ath.cx/stuff/haskell/how-to-io.html
12:25:58 <danharaj> Is () the bottom type then?
12:25:59 <newsham> () + () = () ()
12:26:11 <aristid> Prelude> :t undefined :: 1
12:26:11 <aristid> undefined :: 1 :: GHC.Generics.Unit
12:26:15 <edwardk> hah Look Void
12:26:15 <newsham> danharaj: no, () is the type that has a single inhabitant
12:26:16 <applicative> obviously a phantom type like --  data Phantom ; phantom :: Phantom ; phanton = error "there are no Phantoms"    -- is cooler
12:26:18 <copumpkin> :k 1 :+: 1
12:26:19 <lambdabot> *
12:26:27 <EvanR-work> wvd: make sure you understand the semantics of each IO action, they can fail and cause errors under some conditions
12:26:36 <copumpkin> :k (1 :+: 1) :*: (1 :+: 1 :+: 1)
12:26:36 <EvanR-work> you wouldnt want your program to crash
12:26:37 <lambdabot> *
12:26:37 <wvd> EvanR-work: such as?
12:26:37 <soupdragon> **
12:26:49 <EvanR-work> wvd: well, getLine fails if there are no more lines
12:26:58 <mauke> that's not important for now
12:27:04 <EvanR-work> among millions of other situations
12:27:08 <wvd> ah well.
12:27:09 <dolio> :t Unit :: 1
12:27:10 <lambdabot> Unit
12:27:17 <wvd> I didn't read up on error handling yet.
12:27:22 <newsham> ?djinn 1 :+: 1
12:27:22 <lambdabot> Cannot parse command
12:27:28 <mauke> applicative: that's 1) not a phantom type 2) not valid H98
12:27:37 <applicative> yeah, its a mess
12:27:39 <copumpkin> @djinn Either () ()
12:27:39 <lambdabot> f = Left ()
12:27:46 <copumpkin> yay, djinn is left-handed
12:28:09 <newsham> ?djinn (Either () (), Either (Either () ()) ())
12:28:10 <lambdabot> f = (Left (), Left (Left ()))
12:28:37 <soupdragon> ?djinn Maybe ()
12:28:37 <lambdabot> f = Nothing
12:28:45 <copumpkin> a left-handed nihilist
12:28:47 <applicative> what do i mean, an EmptyDataDeclaration
12:28:51 <aristid> :t Left ()
12:28:52 <lambdabot> forall b. Either () b
12:28:54 <copumpkin> EmptyDataDecls ?
12:29:11 <aristid> :t [Left (), Left (), Right ()]
12:29:12 <lambdabot> [Either () ()]
12:29:14 <applicative> yes, what do we call such a type, an empty type?
12:29:17 <aristid> > [Left (), Left (), Right ()]
12:29:18 <lambdabot>   [Left (),Left (),Right ()]
12:29:20 <newsham> preflex: seen anything new today
12:29:20 <preflex>  Sorry, I haven't seen anything
12:29:28 <copumpkin> applicative: an almost-empty type ;)
12:29:33 <mauke> ?!
12:29:34 <lambdabot> Maybe you meant: . ? @ v
12:29:47 <copumpkin> omg buffer overflow!
12:29:52 <aristid> > cycle [Left (), Left (), Right (), Left(), Right(), Right(), Left(), Right()]
12:29:53 <lambdabot>   [Left (),Left (),Right (),Left (),Right (),Right (),Left (),Right (),Left (...
12:30:04 <copumpkin> preflex: seen anything new today
12:30:05 <preflex>  Sorry, I haven't seen anything
12:30:09 <edwardk> preflex: xseen mmorrow
12:30:10 <preflex>  mmorrow was last seen on freenode/#ghc 129 days, 16 hours, 32 minutes and 25 seconds ago, saying: * mmorrow is rtfm'ing
12:30:11 <mauke> newsham: preflex is too stupid to decode UTF-8 there
12:30:25 <newsham> preflex: seen anything¯new¯today
12:30:26 <preflex>  Sorry, I haven't seen anything¯new¯today
12:31:03 <jkingkong> the default behavior of zipWith when the lenghts are mismatched is to truncate the longer list, is there an alternative version that lengthens the shorter list with zeroes?
12:31:17 <jkingkong> \lenghts/lengths
12:31:39 <newsham> preflex: seen P⋁¬P
12:31:41 <preflex>  Sorry, I haven't seen P⋁¬P
12:31:46 <applicative> okay, data Empty ; empty :: Empty; empty = error "nothing is really empty"
12:31:50 <newsham> preflex does unicode just fine
12:31:53 <newsham> (wether or not it knows it)
12:32:04 <rajeshsr> @hoogle fix
12:32:04 <lambdabot> Data.Function fix :: (a -> a) -> a
12:32:04 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
12:32:04 <lambdabot> module Control.Monad.Fix
12:32:04 <edwardk> jkingkong: sadly no, since there isn't a class that just contains an empty value for each type, you can make one, but its also not clear that that is the best way, since you might want to just provide two other functions for what to do with the longer tail, etc.
12:32:14 <mreh> preflex is unaware of the excluded middle
12:32:18 <edwardk> jkingkong: it gets reinvented over and over though
12:32:24 <aristid> which is the original module for fix?
12:32:29 <mauke> newsham: unless you use a multibyte character where one of the bytes happens to be latin-1 whitespace
12:32:30 <aristid> Control.Monad.Fix?
12:32:34 <jkingkong> edwardk: thanks yea I was just curious since it seems like it would be convenient
12:32:39 <newsham> mauke: ah, gotcha
12:32:45 <newsham> wait, that cant happen.
12:32:54 <newsham> utf8 multi-byte characters have upper bit set
12:33:08 <mauke> newsham: what about byte 160?
12:33:09 <rajeshsr> > let hg x = fix( \st -> replicate (pred x) 0 ++ [1] ++ (map (sum . take x) . tails $ st)) in take 10 $ hg 3
12:33:10 <lambdabot>   [0,0,1,1,2,4,7,13,24,44]
12:33:17 <newsham> mauke: byte 160 has upper bit set :)
12:33:23 <newsham> > 160 .&. 0x80
12:33:23 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:33:24 <lambdabot>    `Data.Bits.Bits a'
12:33:24 <lambdabot>      a...
12:33:34 <newsham> > 160 .&. 0x80 :: Word8
12:33:35 <lambdabot>   128
12:33:45 <rajeshsr> > let hg x = fix(\st -> replicate (pred x) 0 ++ [1] ++ (map (sum . take x) . tails $ st)) in take 10 . hg $ 3
12:33:45 <mauke> newsham: yes, so it can occur in a utf-8 multibyte char
12:33:46 <lambdabot>   [0,0,1,1,2,4,7,13,24,44]
12:34:03 <newsham> oh its a latin-1 whitespace is what you're saying
12:34:04 <newsham> gotcha
12:34:36 <mauke> <newsham> preflex: seen anything new today  <preflex>  Sorry, I haven't seen anythingÂ
12:34:38 <edwardk> heh i was just going to mention nbsp as such as space
12:34:40 <mauke> ^ hence this
12:34:51 <newsham> that was using 160
12:35:37 <edwardk> not just the upper bit set, but is less than c0 so is a valid tail byte
12:35:40 <rajeshsr> so finally got that with fix!
12:35:47 <rajeshsr> ^
12:36:03 <jkingkong> Is there a sorted data structure kind of like Data.Set (that was suggested earlier) that allows duplicates?
12:36:08 <newsham> edk: not sure i see the relevance :)  but yah.
12:36:12 <edwardk> @pl \x -> fix(\st -> replicate (pred x) 0 ++ [1] ++ (map (sum . take x) . tails $ st))
12:36:13 <lambdabot> fix . ap ((.) . (++) . flip replicate 0 . pred) (((1 :) .) . (. tails) . map . (sum .) . take)
12:36:22 <newsham> jking: a multiset?
12:36:31 <edwardk> > take 10 . fix . ap ((.) . (++) . flip replicate 0 . pred) (((1 :) .) . (. tails) . map . (sum .) . take) $ 3
12:36:33 <lambdabot>   [0,0,1,1,2,4,7,13,24,44]
12:36:38 <jkingkong> newsham: i'll take a look thanks
12:36:49 <rajeshsr> edwardk, haha! that looks a lot intuitive! ;)
12:37:02 <newsham> http://hackage.haskell.org/packages/archive/multiset/0.1/doc/html/Data-MultiSet.html
12:37:03 <wvd> What's the best way to check if a char is a ( or )? I could use generalCategory - but is there a better way?
12:37:18 <edwardk> rajeshsr: feel free to replace random .'s with `fmap`'s to win friends and impress your peers
12:37:40 <edwardk> @type (`elem` "()")
12:37:41 <lambdabot> Char -> Bool
12:37:49 <dcoutts> jkingkong: or use a Map key [value]
12:37:50 <wvd> Oh.
12:37:54 <Polarina> Is there something like hGetContents, but strict?
12:37:54 <wvd> edwardk, smart :P
12:37:54 <jkingkong> newsham: thanks I'm looking now. Any reason why you pointed me to the 0.1 version over the 0.2 version?
12:38:05 <newsham> nope, just first thing that google gave me
12:38:10 <rajeshsr> edwardk, haha! :) I bet i won't understand what i do after that.
12:38:19 <jkingkong> dcoutts: I was considering it but having the data sorted is a big plus
12:38:33 <edwardk> rajeshsr: isn't that the point of obfuscation?
12:38:38 <jkingkong> newsham: ah ok thanks. wasn't sure if there were stability problems or something
12:38:40 <rajeshsr> @pl let hg x = let st = replicate (pred x) 0 ++ [1] ++ (map (sum . take x) . tails $ st) in st in take 10 $ hg 3
12:38:40 <lambdabot> take 10 (fix ((replicate (pred 3) 0 ++) . (1 :) . map (sum . take 3) . tails))
12:38:54 <dcoutts> jkingkong: how are they sorted if they have the same key?
12:39:21 <jkingkong> dcoutts: well, at the moment, I'm not representing the data as key, value pairs
12:39:31 <rajeshsr> take 10 (fix ((replicate (pred 3) 0 ++) . (1 :) . map (sum . take 3) . tails)) $ 3
12:39:34 <rajeshsr> > take 10 (fix ((replicate (pred 3) 0 ++) . (1 :) . map (sum . take 3) . tails)) $ 3
12:39:34 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
12:39:57 <aristid> > take 3 []
12:39:58 <lambdabot>   []
12:40:05 <newsham> ?type take 5
12:40:06 <lambdabot> forall a. [a] -> [a]
12:40:08 <aristid> > sum []
12:40:09 <lambdabot>   0
12:40:16 <aristid> ah so that works.
12:41:14 <dcoutts> jkingkong: my point is either you can order the items which go in a single bag or you cannot, if you can then you can use a Map of Maps, if you can't you use a Map of lists.
12:43:05 <jkingkong> dcoutts yes you can order them
12:43:34 <jkingkong> dcoutts very interesting, so here's the idea: I have these bags like (x,y) (a,y) (foo,z)
12:43:40 <jkingkong> the first two are "equal"
12:43:53 <jkingkong> it'd be nice to traverse the structure and do things to these "equal" elements
12:44:14 <jkingkong> I'm just not sure what the optimal way of doing this is
12:44:15 <dcoutts> jkingkong: you mean, that's 3 buckets, with two items in each bucket?
12:44:19 <jkingkong> yes
12:44:35 <jkingkong> and the equality only checks one item in the bucket (the latter one)
12:44:47 <jkingkong> at least, that's how I've implemented it thus far
12:44:48 <dcoutts> jkingkong: ok, so you can use a Map key (Map key' value)
12:45:14 <dcoutts> where key and key' are probably taken as some field or identifier or the value
12:45:23 <dcoutts> the first key gives you the bucket
12:45:28 <dcoutts> the second orders within the bucket
12:45:38 <jkingkong> mm i see
12:45:48 <dcoutts> you do two-stage lookups for individual items, or single lookup to get all items in a bucket
12:45:59 <jkingkong> so lets
12:46:02 <jkingkong> take this example
12:46:17 <jkingkong> and say the ordering in the first and second bin of the bucket is alphabetical
12:46:23 <wvd> I want to remove all ()'s out of my list, not . `elem` "()" is not valid syntax, and not . elem "()" gives a [[Char]] -> Bool instead of Char -> Bool - any ideas?
12:46:31 <jkingkong> what would the keys and key's be
12:46:39 <jkingkong> read: "key-primes"
12:46:51 <Zao> wvd: So you want to remove all substrings that are "()"?
12:46:59 <Zao> I would regex the crap out of it.
12:47:03 <applicative> @type elem
12:47:04 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:47:08 <dcoutts> jkingkong: so what determines which bucket each item lives in?
12:47:20 <wvd> Zao: I want to remove ( and ). So basically I check if a character is an element of "()"
12:47:26 <Zao> Ah.
12:47:29 <Zao> filter.
12:47:33 <wvd> applicative, so I have to pass the single character first.
12:47:40 <wvd> applicative, but not . `elem` "()" doesn't work.
12:47:41 <jkingkong> dcoutts: the "degree" of the second item
12:47:49 <mauke> wvd: `notElem`
12:48:08 <dcoutts> jkingkong: wait, are there always exactly two items in each bucket?
12:48:20 <mauke> not . (`elem` "()")
12:48:27 <wvd> Oh right.
12:48:30 <ClaudiusMaximus> :t ( not . (`elem` "()") , not . `elem` "()" )
12:48:31 <edwardk> wvd  you also probably want to parenthesize the (`notElem` "()") if you're going to use it like that
12:48:31 <lambdabot> parse error on input ``'
12:48:34 <edwardk> @type notElem
12:48:35 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:48:37 <edwardk> @type elem
12:48:38 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:48:50 <jkingkong> dcoutts: yes although I plan on needing a third one eventually
12:48:56 <jkingkong> dcoutts: nothing's ever easy...
12:49:05 <Zao> @type not . flip elem "()"
12:49:06 <lambdabot> Char -> Bool
12:49:11 <dcoutts> jkingkong: your example of (x,y) (a,y) (foo,z), are those three items, and the first two of them live in the same bucket because their second component is equal?
12:49:23 <jkingkong> yes
12:49:28 <applicative> wvd, you need to bracket like mauke says, else the "." cant get hold of " `elem` "()" "
12:49:35 <Zao> Sections tend to need gratuitous parenthesis.
12:49:44 <jkingkong> I was thinking the foldOccur :: (a -> Occur  -> b -> b) -> b -> MultiSet  a -> b function in the multiset module has promise
12:49:49 <dcoutts> jkingkong: ok, so then the type of the first key is the type of the second component, and the type of the second key is the type of the first component.
12:49:49 <jkingkong> except, I have no idea what it does
12:50:13 <jkingkong> dcoutts: hmm yes i think I follow you
12:50:28 <rajeshsr> There is a Mac port of ghc, right?
12:50:52 <jkingkong> dcoutts: I'll have to ponder about this for some time haha
12:51:05 <jkingkong> dcoutts: but thanks a lot for the idea, it sounds really neat
12:51:15 <applicative> rajeshsr, there is an installer of the Haskell Platform, and also a macports version
12:51:15 <jkingkong> dcoutts : have you done something like that before?
12:51:28 <jlouis> Anyone know how fast MVars are compared to TMVars?
12:51:34 <dcoutts> jkingkong: it's quite a general idea, you'll see people sometimes refer to it as generalised tries
12:51:42 <jlouis> Are they a "bit" faster or blazingly faster?
12:51:46 <jkingkong> dcoutts: i see
12:51:50 <dcoutts> jkingkong: the idea is making the structure of the map follow the structure of the key
12:52:01 <applicative> rajeshsr, I think that other things being equal the installer is to be preferred.
12:52:02 <dcoutts> jkingkong: so if you key is a pair, you get a map of maps
12:52:45 <dcoutts> jlouis: Simon Marlow gave a talk recently which had some numbers, take a look at the ghc blog
12:53:14 <telephone> Haskell OpenGL question: What is the difference between Vertex3 and Vector3?
12:53:18 <jkingkong> dcoutts: yes this makes sense. The only thing I need to ponder about now is whether adding a third key would make this thing unneccesarily difficult
12:53:19 <jlouis> dcoutts: oh, interesting
12:53:23 <jlouis> dcoutts: thanks
12:53:31 <applicative> @where platform -- rajeshsr, see below
12:53:31 <lambdabot> http://hackage.haskell.org/platform/
12:53:36 <rajeshsr> applicative, hmm, ok! thanks.
12:53:40 <dcoutts> jlouis: hmm, I don't immediately see it on the blog, I'm sure it was a recent talk though
12:53:43 <Zao> telephone: One is a three-component value, the other is a Vertex specification?
12:53:47 <jkingkong> dcoutts: also, I'm worried about performance (i.e. memory footprint)
12:53:59 <Twey> telephone: One represents a vertex and another represents a vector.
12:54:06 <dcoutts> jkingkong: maps are not much more memory intensive than lists
12:55:08 <telephone> Twey: yes, but is there some known reason for this choice?
12:55:17 <ibt> is there a way to have cabal build haddock documentation that links to the source? i'm not seeing any .cabal/config options for doing that
12:55:39 <dcoutts> jkingkong: if you don't need to modify the mapping once it's constructed then one can sometimes do more space efficient things with immutable arrays. It's not usually worth it for most applications.
12:55:44 <Twey> telephone: What choice?
12:55:57 <Twey> The choice to differentiate between vectors and vertices?
12:56:07 <Twey> They're quite different concepts.
12:56:10 <dcoutts> ibt: no, the option is not exposed as we've not worked out a sensible design for it. There's a ticket for it if you've got any suggestions.
12:56:21 <jkingkong> dcoutts thanks again for all your help
12:56:26 <dcoutts> np
12:57:05 <telephone> Twey: yes. In theory you could distinguis, but in programming this only caused confusion for me.
12:58:08 <somebody__> d
12:58:42 <Twey> telephone: Then you're doing it wrong
12:58:43 <Polarina> What do I do here? GHC broke. http://codepad.org/CmsWa9uB
12:58:46 <telephone> Twey: by the way, this is not so important.  I just wondered if there where some differences other than two different types.
12:58:54 <Twey> A point is not a vector.  A vector describes a transformation or translation of some kind.
12:58:54 <wvd> helloworld.hs:12:4: parse error on input `|' <= Hows that possible? It's basically a guard.
12:59:06 <Twey> A vector describes a point in space.
12:59:10 <wvd> Oh wait, bracket mismatch
12:59:11 <Twey> Er
12:59:13 <Twey> A vertex**
12:59:21 <Twey> You shouldn't really be able to get them confused
13:02:40 <jlouis> dcoutts: I found one of Marlows papers and it might be worth a try to change from STM to MVars
13:03:01 <jlouis> dcoutts: I shouldn't really run into any trouble in this app anyway
13:03:16 <telephone> Twey: That might be a physicist view of the problem.
13:03:25 <dcoutts> jlouis: MVars should be faster, how much you would have to find out by testing.
13:03:33 <Twey> telephone: You're new to strong typing, aren't you?  ☺
13:03:41 <dcoutts> jlouis: of course they might also be more tricky if you were making good use of STM
13:03:58 <Twey> They're different types precisely *so* that you don't get them confused and pass a vertex by mistake where you intended a vector (or vice versa).
13:04:19 <dcoutts> jlouis: I sometimes hear people say that they prototype with STM and then work out a more tricky but higher performance scheme using MVars
13:04:22 <Twey> (also, so that you can tell immediately which was intended by looking at the type of a function)
13:04:22 <mauke> wvd: paste your code somewhere
13:04:36 <telephone> Twey: No. But I did not see the meaning of creating two types.
13:04:37 <wvd> mauke, fixed it already. but it's bedtime now.
13:04:42 <mauke> ok
13:05:19 <Twey> telephone: The same meaning as in creating any type
13:05:27 <Twey> You can represent everything as tuples if you want to.
13:05:45 <Twey> type Maybe a = (Bool, a)
13:05:57 <mauke> type Maybe a = Either () a
13:06:12 <Twey> Well, everything non-recursive, anyway.
13:06:41 <dolio> Everything is a bit string.
13:06:44 <dolio> Let's just use that.
13:06:44 <mauke> type List a = Fix (Maybe . (,) a)
13:07:08 <Twey> Heheh.
13:07:09 <soupdragon> Mu x. 1 + a * x
13:09:38 <jlouis> dcoutts: I think I have killed most of the good use of STM
13:13:15 <forrest> ok i tried to write a couple of functions to get the list i was after earlier http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25771
13:13:43 <forrest> since i made the number of appended digits variable, i couldn't get the printf version to work
13:14:29 <forrest> my ghci errors are at the bottom there commented out
13:15:47 <forrest> of course i'm probably doing something totally boneheaded, i'm still very much a newbie at haskell
13:16:59 <nostrand> is it overkill to use arrows just for syntactic convience and readability?
13:17:25 <Twey> No
13:17:26 <lowasser> No
13:17:29 <mauke> forrest: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25771#a25772
13:17:32 <Twey> We do it all the time ☺
13:17:34 <lowasser> that's what things like monads are for!
13:17:42 <lowasser> monads, arrows, all that jazz
13:18:23 <nostrand> oki ^^
13:19:01 <Twey> Hehe
13:20:37 <forrest> mauke: that works, but why?
13:20:47 <soupdragon> someone write polynomial algorithm for me :(
13:21:02 <copumpkin> soupdragon: what polynomial algorithm?
13:21:06 <soupdragon> no one alive in haskell-math
13:21:15 <mauke> forrest: because the type of the number list was ambiguous
13:21:17 <soupdragon> http://pastie.org/980592
13:21:26 <soupdragon> I need a Num instance
13:21:41 <soupdragon> well just + and *
13:21:42 <mauke> it couldn't decide if it was [Int], [Integer], [Double], [Rational] or something completely different
13:21:48 <copumpkin> you can use IntMap.unionWith for addition
13:21:54 <Polarina> How do I evaluate something strictly? DeepSeq doesn't seem to do the trick.
13:21:55 <mauke> and the printf magic requires concrete types
13:22:01 <soupdragon> (+) = IntMap.unionWith (+)  ?
13:22:01 <forrest> ah, so my format string would also work?
13:22:05 <copumpkin> soupdragon: yeah
13:22:06 * forrest checks
13:22:15 <copumpkin> soupdragon: negate is map negate :)
13:22:17 <soupdragon> * is hard though
13:22:42 <zachk> soupdragon: i coded something similar up using Num a-> Poly [a]
13:22:53 <copumpkin> it's a little trickier, but you could always convert it to a list temporarily and figure it out
13:23:00 <copumpkin> then try to avoid converting to list first
13:23:01 <soupdragon> zachk
13:23:06 <soupdragon> want to port it to this??
13:23:17 <soupdragon> I will implment GCD and long division if ou do
13:23:42 <forrest> ah, yes
13:23:52 <zachk> i dont know gcd and long division for polynomials, also my code cant represent ak^-n terms
13:24:01 <soupdragon> I'll do gcd and long division
13:24:25 * wli only wrote Grobner stuff
13:24:36 <soupdragon> "only"
13:25:07 <BMeph> Polarina: Do you feel comfortable about being more specific than "something"? Many things have different ways of being made strict. :)
13:25:19 <soupdragon> univariate polyynomial
13:26:03 <Polarina> BMeph, type Destinations = [(HostAddress, PortNumber)]
13:27:26 <copumpkin> soupdragon: what are you going to do with the polynomials?
13:27:28 <copumpkin> you should normalize them!
13:27:36 <copumpkin> and allow more than one variable
13:27:39 <soupdragon> what does it mean tto normalize ?
13:27:43 <copumpkin> horner
13:27:46 <soupdragon> I need univariate
13:28:00 <soupdragon> I already have multivariate
13:28:19 <Polarina> BMeph, any ideas?
13:28:23 <copumpkin> hmm, can't you just use your multivariate code with a single var? :P
13:28:53 <aavogt> @src (!$)
13:28:54 <lambdabot> Source not found.
13:28:56 <aavogt> @src !$
13:28:57 <lambdabot> Source not found. It can only be attributed to human error.
13:28:59 <aavogt> @src $!
13:29:00 <lambdabot> f $! x = x `seq` f x
13:29:02 <Choko> soupdragon: I've implemented univariate polynomials representing the coefficients as (Ring a) => [(Integer,a)]
13:29:09 <aavogt> Polarina: do you see how $! works?
13:29:23 <Polarina> aavogt, yes, and it's not working, doesn't evaluate the thing.
13:29:35 <soupdragon> Choko cool
13:29:51 <aavogt> presumably you can force more by writing      f $!! x = rnf x `seq` f x
13:29:52 <soupdragon> Choko come to #haskell-math
13:30:22 <Polarina> PortNumber doesn't have a NFData instance.
13:30:34 <aavogt> write one
13:30:42 <Polarina> I don't know how.
13:30:49 <aavogt> they are mechanical
13:31:04 <aavogt> @hackage derive -- perhaps this can do it for you
13:31:05 <lambdabot> http://hackage.haskell.org/package/derive -- perhaps this can do it for you
13:31:11 <cozachk> soupdragon, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25773#a25773
13:31:34 <aavogt> Polarina: there is a   makeNFData
13:31:47 <Polarina> o.O
13:32:03 <soupdragon> nice
13:32:16 <Polarina> What is that?
13:32:31 <Polarina> I am looking at the documentationt, and I do not understand a bit of it.
13:34:09 <c_wraith> :t let f :: a -> b ; f = undefined in f
13:34:10 <lambdabot> forall a b. a -> b
13:35:05 <aavogt> Polarina: there are a couple ways to use derive
13:35:34 <edwardk> preflex: xseen Gracenotes
13:35:34 <preflex>  Gracenotes was last seen on freenode/#haskell 1 hour, 51 minutes and 46 seconds ago, saying: mauke: though.. since the nature of printf is that it probably will end up getting used with code in do blocks or with lots of where/let clauses, making it work pointfree isn't a huge concern most of the time
13:36:18 * Gracenotes is around
13:37:05 <aavogt> one is as a standalone program that generates some code, and the other is as template haskell run by ghc
13:38:17 <jkingkong> question: I kind of understand existential quantification in the context of function declarations, but what about when instancing a typeclass?
13:38:33 <jkingkong> eg, instance Num (Foo bar) where ...
13:38:49 <jkingkong> how do I make this work "forall" phantom types bar?
13:38:56 <mauke> jkingkong: like that
13:38:57 <aavogt> what is existential there?
13:39:12 <BMeph> Polarina: Might I know, what are you doing that shows your list isn't being evaluated?
13:39:13 <jkingkong> Foo bar = Zoo
13:39:16 <jkingkong> or something
13:39:40 <mauke> jkingkong: what does that have to do with existentials?
13:39:42 <aavogt> BMeph: evaluate first... ask questions later
13:39:52 <jkingkong> OK this will take some time to explain
13:39:55 <jkingkong> please bear with me
13:40:14 <jkingkong> So a Num operation I want to implement depends on the Ordering of the arguments
13:40:30 <jkingkong> The way the objects are ordered depends on bar
13:40:45 <jkingkong> which could be one of several data types without a constructor
13:40:53 <jkingkong> (using fglasgow-exts)
13:41:09 <jkingkong> so, when I do instance Num (Foo bar) where...
13:41:35 <aavogt> I would write     instance Num (Foo Ordering1) where ...
13:41:40 <jkingkong> it complains "Could not deduce (Ord (... bar)) from the context ..."
13:41:57 <jkingkong> ok so even if the implementation is the same
13:41:58 <aavogt> why do you need to compare barS?
13:42:04 <jkingkong> I need to do it separately for each one?
13:42:13 <jkingkong> I want to use the unionWith function
13:42:14 <mauke> instance (Ord bar) => Num (Foo bar) ?
13:42:18 <jkingkong> from Data.Map
13:42:26 <jkingkong> which depends on the ordering
13:42:58 <jkingkong> mauke: I get the same error
13:43:24 <aavogt> so did you derive Ord for Foo?
13:43:30 <jkingkong> yes
13:43:36 <jkingkong> for some types of bar
13:43:46 <jkingkong> i.e. there is Foo A, Foo B, Foo C
13:43:49 <jkingkong> all ordered differently
13:44:34 <MilosDj> Hi All :)
13:44:39 <MilosDj> I have started learning haskell couple days ago and I was wondering about some recommendations about GUI
13:44:40 <aavogt> then that's your problem
13:44:48 <jkingkong> to be specific Foo bar = Foo (Map (Zoo bar) Q)
13:45:05 <jkingkong> so Zoo A, Zoo B, and Zoo C have orderings
13:45:18 <jkingkong> as do Foo A, Foo B, and Foo C
13:45:20 <aavogt> jkingkong: you're claiming there is an instance Ord a => Ord (Foo a)
13:45:25 <aavogt> but there isn't one
13:45:38 <jkingkong> I also have instance Ord (Foo a)
13:45:46 <jkingkong> Foo A sorry
13:45:54 <jkingkong> I have instances for both Foo and Zoo
13:46:03 <aavogt> A and a are quite different things
13:46:18 <jkingkong> the idea is to use the phantom type so that when Foo is ordered with A, then Zoo is ordered with A
13:46:21 <aavogt> I'm not sure if overlapping instances are part of -fglasgow-exts
13:46:25 <jkingkong> and so on
13:46:50 <jkingkong> well, it is I think... at least, when I was reading about it
13:46:59 <aavogt> you could write      instance (Ord (Foo bar)) => Num (Foo bar)
13:47:16 * BMeph is confused because that isn't the meaning of "phantom type" that he's familiar with... :|
13:47:48 <jkingkong> aavogt: gosh that's it
13:47:53 <aavogt> BMeph: which one are you familiar with?
13:47:56 <aavogt> jkingkong: which one?
13:48:03 <jkingkong> wait no
13:48:14 <aavogt> that you need to add an overlapping instance, or that you should change the instance head?
13:48:34 <jkingkong> "Constraint is no smaller than the instance head in the constraint: Ord (Foo bar) (Use -XUndecidableInstances to permit this)
13:48:37 <jkingkong> yea
13:48:49 <jkingkong> never seen this before
13:48:56 <BMeph> aavogt: More types mentioned on the lLHS than on the RHS
13:48:59 <aavogt> it tells you how to solve them
13:49:12 <jkingkong> BMeph: this is precisely what I'm doing
13:49:29 <jkingkong> BMeph: but you might need to scroll up a bit :P
13:49:57 <danharaj> Don't use undecidable instances.
13:50:09 <jkingkong> well, I get the same error message as before when I do
13:50:16 <jkingkong> so yea that won't help :P
13:50:43 <jkingkong> Note that when I specify bar as in instance Num (Foo A) where... it works
13:51:11 <jkingkong> will I just need to copy the code for each bar? instance Num (Foo A) where ... instance Num (Foo B) where... etc.
13:51:29 <aavogt> that shouldn't be necessary
13:51:33 <jkingkong> This seems to belie the point of it yea
13:51:57 <jkingkong> hmm any ideas? You've been very helpful btw
13:52:34 <aavogt> [16:45:18]    jkingkong | I also have instance Ord (Foo a)
13:52:38 <aavogt> did you add that one?
13:52:55 <jkingkong> mm
13:53:07 <jkingkong> with an undefined implementation?
13:53:11 <c_wraith> :t f :: StateT m a -> m a ; f = undefined in f
13:53:12 <lambdabot> parse error on input `;'
13:53:18 <aavogt> why should it be undefined?
13:53:21 <c_wraith> :t let f :: StateT m a -> m a ; f = undefined in f
13:53:22 <lambdabot>     `StateT m a' is not applied to enough type arguments
13:53:22 <lambdabot>     Expected kind `??', but `StateT m a' has kind `* -> *'
13:53:22 <lambdabot>     In the type `StateT m a -> m a'
13:53:31 <c_wraith> :t let f :: StateT s m a -> m a ; f = undefined in f
13:53:32 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> m a
13:53:35 <aavogt> supposedly the parameter to Foo doesn't represent any values
13:54:09 <jkingkong> well, I have no idea how to order objects of type Foo without a specification
13:54:22 <jkingkong> I'm using the phantom type to link the ordering between Foo and Zoo
13:54:35 <aavogt> oh now I realize what BMeph meant by you using some odd definition of phantom type
13:55:24 <aavogt> though what is Zoo?
13:55:36 <jkingkong> this is described in a paper by Oleg
13:55:47 <jkingkong> as his solution to the "configurations problem"
13:55:50 <aavogt> then it should work :)
13:55:58 <jkingkong> haha yea I'm just stupid
13:56:11 <jkingkong> Zoo are the keys in the map
13:56:18 <aavogt> @hackage reflect
13:56:19 <lambdabot> http://hackage.haskell.org/package/reflect
13:56:33 <jkingkong> reminder: Foo bar = Foo (Map (Zoo bar) Int)
13:56:43 <aavogt> http://hackage.haskell.org/package/reflection
13:56:53 <jkingkong> the idea is to propagte the knowledge about bar throughout the implementation
13:56:58 <gwern> I was impressed by Oleg's typeclass solution to the configurations problem
13:57:06 <gwern> I'll never use it, but I'm still impressed
13:57:07 <jkingkong> yes I was impressed too
13:57:14 <danharaj> what is the configurations problem
13:57:22 <gwern> danharaj: global variables
13:57:28 <gwern> which store configuration
13:57:37 <jkingkong> and maintain static typing and such
13:57:39 <gwern> you could just pass them around. everywhere. but that's annoying
13:58:05 <aavogt> implicit parameters
13:58:17 <jkingkong> anyways, it looks like I'll have to read the paper again and figure out what it is I'm not understanding
13:58:19 <aavogt> except maybe a bit more sane
13:58:24 <tromp> like modulus in a program doing arithmetic mod M
13:58:37 <jkingkong> yes that was the example he used
13:58:53 <danharaj> sounds like something dependent typing could do trivially
13:59:18 <jkingkong> then you lose the benefit of static typing
13:59:34 <jkingkong> if there's anything I've learned, all these features make some things easier, and other things harder
13:59:41 <danharaj> restrict your dependent typing to terms that are reducible to values at compile time.
14:00:17 <jkingkong> gah I need to go fellows
14:00:28 <jkingkong> thanks for all the input
14:00:44 <mreh> bleep
14:02:21 <MilosDj> Hi All :)
14:02:23 <MilosDj> I have started learning haskell couple days ago and I was wondering about some recommendations about GUI
14:02:44 <MilosDj> what's easiest/best for starting gui haskell?
14:02:55 <danharaj> Do you have any exprience with gui libraries in other languages?
14:03:46 * edwardk looks up at the mention of the reflection package
14:03:59 <MilosDj> win32
14:04:06 <MilosDj> in c++
14:04:24 <thoughtpolice> edwardk: since jkingkong left, i'll say that reflection is awesome, and much easier to use with the tagging interface from 0.3
14:04:25 <danharaj> have you ever used WX or GTX in C++
14:04:33 <MilosDj> no
14:04:44 <MilosDj> just raw win32 api
14:04:49 <danharaj> ew :p
14:04:51 <thoughtpolice> edwardk: because i do like oleg's typeclass solution to the configurations problem
14:04:52 <Twey> Ow
14:05:08 <danharaj> MilosDj: There are ports of those libraries to Haskell, they are called wkhaskell and gtk2hs
14:05:28 <Twey> Bindings, not ports
14:05:31 <MilosDj> and you recommend...
14:05:34 <danharaj> Twey: pff
14:05:45 <Twey> You can use the Win32 API from within Haskell.  If you're insane.
14:05:58 <danharaj> MilosDj: I have not managed to get gtk2hs to build, personally, I managed to get wx to work, but I haven't used it much.
14:05:59 <aavogt> Twey: but are all the bindings done?
14:06:19 <Twey> I think both are complete
14:06:32 <danharaj> MilosDj: the advantage of using these is that if you get stuck you can look at the C++ libraries and examples and convert that into Haskell.
14:07:18 <danharaj> For building wxHaskell on windows, look at this blog post
14:07:22 <danharaj> http://wewantarock.wordpress.com/
14:07:40 <aavogt> there would be no binaries for wx?
14:07:53 <MilosDj> omg, why?
14:08:05 <MilosDj> so I need to compile source?
14:08:28 <aavogt> gtk2hs has had windows installers in the past...
14:08:30 <edwardk> thoughtpolice: thanks =)
14:09:24 <edwardk> i've thought about doing a 0.4 which replaces the use of Tagged with a typeclass so you can more directly implement data types with a single phantom type parameter
14:09:47 <edwardk> but I haven't worked out all the details
14:09:48 <danharaj> MilosDj: Using Cabal is not only easy, it is a neccessity for getting the most out of Haskell
14:10:17 <danharaj> MilosDj: Especially on Windows, unfortunately our platform is neglected by the neckbeards :p
14:10:17 <dcoutts> aavogt: they still work, there are installers for ghc-6.10.1 and 6.10.4
14:10:22 <nus> MilosDj, http://code.haskell.org/gtk2hs/INSTALL
14:10:29 <MilosDj> I'll try, I am in haskell waters only for 4 days
14:11:20 <MilosDj> I tried some code, looks nice, currently watching msdn C9 videos
14:11:37 <danharaj> MilosDj: Are you sure you are ready to try and do GUI programming? It is an advanced subject in any language.
14:11:53 <danharaj> Then again if you managed to stomach raw win32 api in C++ you must be tough as nails.
14:12:04 <MilosDj> but I wanted to try some gui examples
14:12:15 <jmcarthur> are jhc and lhc supercompilers or merely whole program optimizers? i've been under the impression that they are the former, but i'm wondering if i'm wrong
14:12:17 <MilosDj> raw win32 api is great if you want to learn it
14:12:23 <eevar> given rank :: a -> Ord, how do I pick the highest ranked value from a list?
14:12:39 <Zao> maximumBy?
14:12:44 <mauke> eevar: what's Ord?
14:12:48 <aavogt> Ord isn't a type...
14:12:48 <eevar> sounds good, thanks
14:13:04 <eevar> Ordering
14:13:27 <mauke> huh
14:13:46 <aavogt> so how do you tell which one is higher:   rank x == rank y == GT
14:14:10 <c_wraith> > LT < GT
14:14:11 <lambdabot>   True
14:14:21 <aristid> @pl map (\x -> "Group" ++ [x]) ['A'.. 'H']
14:14:22 <lambdabot> map (("Group" ++) . return) ['A'..'H']
14:14:34 <aristid> @src [] return
14:14:34 <lambdabot> return x    = [x]
14:14:47 <aristid> :t []
14:14:48 <lambdabot> forall a. [a]
14:14:52 <aristid> > [] 1
14:14:53 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
14:15:27 <aavogt> > (:[]) 1
14:15:28 <lambdabot>   [1]
14:17:47 <nus> (:ЕЭ)
14:41:55 <Lemmih> jmcarthur: They aim to be but aren't yet.
14:49:25 <interferon> just as a thought experiment, i'd like to use types to distinguish between closed and open sockets/files, so that a user can't inadvertently close a handle and then use it, and i'd like the failure to happen at compile time
14:49:29 <interferon> anyone have any ideas?
14:50:06 <interferon> i thought of a ConnectedSocket | DisconnectedSocket adt, but the user could simply hang onto the original ConnectedSocket object and use that even after close returned a DisconnectedSocket
14:50:20 <copumpkin> http://hackage.haskell.org/package/regions
14:50:49 <Masky> is there an easy way to make an tuple orderable if only its first element is a orderable?
14:51:19 <interferon> copumpkin: wow, thanks
14:51:27 <monochrom> you have to make your own tuple type
14:51:40 <copumpkin> interferon: it links to http://hackage.haskell.org/package/safer-file-handles too, which is closer to what you want :)
14:51:51 <applicative> @src Ord
14:51:51 <lambdabot> class  (Eq a) => Ord a  where
14:51:51 <lambdabot>     compare      :: a -> a -> Ordering
14:51:51 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
14:51:51 <lambdabot>     max, min         :: a -> a -> a
14:52:20 <interferon> copumpkin: awesome
14:52:30 <interferon> copumpkin: of course it's from oleg :)
14:54:11 <Twey> Of course the standard with* pattern rather than explicit closing solves this problem, too.
14:54:19 <applicative> Masky the obvious way is as monocrom said introduce a type isomorphic to a tuple type  data MyTuple a b c = MyTuple a b c
14:54:46 <ddarius> Twey: Not necessarily.
14:55:01 <applicative> Masky, if I understand, you will also have to make the Eq instance only care about the first element, which is a little wierd.
14:55:05 <Twey> Unless you use IORefs or something to take it out of the closure.
14:55:30 <mauke> withFoo return
14:55:49 <Twey> mauke: Depending on the type of withFoo
14:56:06 <mauke> withFoo throwIO
14:56:34 <Twey> Yeah, IO breaks it as usual.  ☺
15:02:37 <Masky> applicative, can i just do instance Ord (Int,MyType)?
15:03:25 <ivanm> Masky: you would probably need OverlappingInstances for that
15:03:34 <Masky> :/
15:04:13 <applicative> Masky that seems bad, look at this, it's a bit mechanical http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25774#a25774
15:06:33 <kmc> you should define a new type for this
15:06:41 <applicative> Masky, if the first element is Int, you can put that in and omit the qualifications Eq (Ord a) => etc
15:06:45 <kmc> not inject new behaviors into the tuple type everyone already uses for lots of things
15:07:27 <applicative> kmc, is the lame module I put up ^^^ Ill advised, I thought I was following advice like yours
15:08:10 <ivanm> kmc: yeah
15:08:41 <kmc> i meant to Masky
15:19:57 <aavogt> kmc: that overlapping instance won't affect other users of tuples unless they are also (Int, MyType)
15:23:25 <danderson> dcoutts: ping?
15:51:09 <soupdragon> @oies 6,98,57
15:51:09 <lambdabot>  Least positive k such that k * 10^n + prime(n) is prime.
15:51:10 <lambdabot>  [1,6,19,5,6,17,6,6,10,2,15,17,3,9,7,48,32,12,39,9,17,18,27,1,50,36,18,3,11,4...
15:57:49 <syntaxglitch> It's a well-known principle that the success of a programming language is determined primarily by the facial hair of its creator(s)
15:58:02 <syntaxglitch> Both Simons are clean-shaven, which I guess is part of avoiding success?
16:07:07 <mjrosenb> syntaxglitch: presumably it is the facial hair content at the time of creation?
16:07:42 <syntaxglitch> mjrosenb, don't think so--seems to track changes over time to some extent, though possibly with a time delay
16:08:41 <syntaxglitch> I'm also not sure how it works with multiple creators when the beardness varies
16:09:36 <monochrom> therefore it is a bunk theory
16:09:39 <syntaxglitch> nevertheless, it seems plausible to me that any success Haskell currently has is being driven purely by the power of Wadler's beard
16:09:42 <mjrosenb> because i'm pretty sure that if k+r were to shave people would not suddenly stop using C
16:10:24 <wli> mjrosenb: Wadler's beard is surely enough, then.
16:11:12 <syntaxglitch> mjrosenb, assuming some sort of cumulative inertia, C should be virtually immortal
16:12:11 <mjrosenb> i wonder if you have to factor the beariness of its hardcore users
16:12:15 <mjrosenb> *beardiness
16:12:21 <syntaxglitch> hmm, good question
16:12:29 <syntaxglitch> I don't think that's ever been investigated
16:13:43 <deech> Does anyone here have experience writing FCGI apps in Haskell?
16:13:50 <zachk> fast cgi?
16:14:00 <deech> yup
16:14:25 <copumpkin> why would you aim specifically for fastcgi?
16:14:40 <deech> Specifically, can you maintain server side state in a FCGI script?
16:15:08 <Ke> syntaxglitch: C is virtually immortal for a quite a while into the future
16:15:21 <deech> copumpkin: because I get a persistent connection
16:15:29 * wli doubts there are many languages trying to compete with C.
16:15:31 <copumpkin> deech: ?
16:15:39 <copumpkin> deech: I mean, why choose that over a pure haskell server or whatever?
16:15:51 <copumpkin> deech: possibly with an apache in front of it for ssl or whatever
16:16:02 <Ke> well there are quite a few C variants that compete with C
16:16:18 <deech> because I am trying to account for the case where I can't start a server on the machine.
16:16:34 <deech> Like if I have a GoDaddy account.
16:16:48 <mjrosenb> wli: there are very few languages trying to compete with haskell
16:17:00 <mjrosenb> wli: that must be the cause of haskell's sustained popularity
16:18:07 * pikhq doubts there are many languages that can compete with C for the uses it's meant for
16:18:27 <syntaxglitch> pikhq, creating buffer overflows?
16:18:29 <deech> wli: Haskell is one of those languages that everyone wants to say they know but very few put in the time.
16:19:10 <pikhq> Being low-level enough to allow for direct memory access, being high-level enough to not make you have to think about things like basic control structures.
16:19:44 <syntaxglitch> deech, it's not even that much time... I've spent maybe six months tinkering with Haskell to reach some modest level of competence, enough to get stuff done in it at any rate
16:19:49 <deech> pikhq: Forth? Or so I've heard.
16:20:08 <pikhq> deech: Oh, Forth definitely manages it.
16:20:13 <pikhq> With style.
16:20:13 <wli> Forth is not on any sort of par with C for abstraction.
16:20:24 <toki78> hi
16:20:26 <toki78> guys
16:20:31 <pikhq> wli: True, C *is* more abstracted.
16:20:48 <deech> syntaxglitch: everytime I feel somewhat comfortable, something kicks my ass. Most recently HXT.
16:20:54 <toki78> it is off topic, but is anyone interesetd in a SAT solver by hand ?
16:21:32 <toki78> i turned it into a game
16:22:17 <syntaxglitch> deech, a sufficiently complicated library/framework/etc. can do that in any language, no matter how well you know it, though
16:22:22 <soupdragon> toki78 yeah that sounds cool
16:22:36 <toki78> http://tokis-edv-service.de/index.php/beispiele/solving-sat-by-hand
16:22:47 <toki78> soupdragon, please give a comment
16:23:02 <toki78> if you dont wanna register, use guest guest
16:23:06 <syntaxglitch> just the Haskell language, e.g., ignoring stuff outside the standard libraries, really isn't a big deal to pick up :\
16:23:44 <soupdragon> toki it's just a huge list of numbers??
16:23:45 <deech> syntaxglitch: I've dealt with complex API's in Java, that was cake compared to learning arrows to make sense of HXT.
16:24:00 <interferon> is there a between operator that indicates whether one number is between two others
16:24:28 <syntaxglitch> deech, ahhh, as in Control.Arrow? Yeah, those are kind of a trip at first
16:24:37 <soupdragon> it's too hard for me
16:24:54 <toki78> soupdragon, the numebrs are lists, and the lists are maxterms
16:25:24 <toki78> soupdragon, you have to find a sequence with minimal number of intermadiary minterms
16:25:32 <wli> I have a number of very major weak points despite something over 12 years of Haskell programming.
16:25:47 <EvanR> > let a !$% b = (\x -> x>a && x<b) in 4 !$% 8 3
16:25:48 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> GHC.Bool.Bool)
16:25:48 <lambdabot>    arising fro...
16:26:09 <EvanR> > let a !$% b = (\x -> x>a && x<b) in (4 !$% 8) 3
16:26:10 <lambdabot>   False
16:26:32 <deech> interferon: you can make one :). (><) a b c = (c > a) && (c < b)
16:26:46 * syntaxglitch does still find TH horribly opaque and baffling, he must admit
16:27:21 <deech> wli: That is not comforting.
16:27:54 <toki78> soupdragon, sort the maxterms by count, and multiply in the maxterms with the mostly occurring variable first
16:27:59 <wli> Well, in my case I've had day jobs programming C and nightlife taking up a fair chunk of those years.
16:28:23 <toki78> soupdragon, thats the first attempt
16:29:05 <soupdragon> this is definitely not fun
16:29:10 <toki78> lol
16:29:17 <yuriks> anyway I can pass an IO value to a normal function?
16:29:26 <toki78> yes
16:29:31 <allbery_b> no.  you lift a normal function into IO instead
16:29:43 <yuriks> that works
16:29:51 <yuriks> how do I do that?
16:29:56 <allbery_b> (well, there are ways but they're usually foot-shooting in various sometimes obscure ways)
16:30:03 <yuriks> actually
16:30:20 <yuriks> hmm, isn't x <- myIOFunc supposed to remove the value form the IO?
16:30:41 <c_wraith> No.  It's syntactic sugar for putting whatever you do with x into IO
16:30:46 <toki78> and then you can use x in a normal function without lifting
16:30:49 <mjrosenb> yuriks: efb
16:30:56 <allbery_b> fmap myPureFunction myIOValue, or liftM myPureFunction myIOValue, or myIOValue ==> return . myPureFunction
16:31:15 <mjrosenb> allbery_b: what is ==> from?
16:31:24 <allbery_b> damn, typoed that again
16:31:28 <allbery_b> >>= not ==>
16:31:34 <mjrosenb> aah.
16:31:36 * allbery_b has broken fingermacro
16:31:46 <mjrosenb> yeah, that one makes more sense
16:32:09 <allbery_b> and the <- syntax translates into the >>= form
16:33:00 <mreh> reading the yampa source is like grinding broken glass into your scrotum
16:33:57 <yuriks> oh, nvm me
16:34:02 <yuriks> my problem was elsewhere XD
16:34:10 <toki78> can anyone tell me if there is a better channel for theortical computer science stuff ?
16:34:22 <mreh> toki78, I don't know
16:34:24 <mreh> #logic?
16:34:32 <toki78> good idea
16:34:54 <mreh> they might deem you unworthy of their time and kick you
16:35:03 <yuriks> heh
16:35:20 <mjrosenb> will ##logic is only one very limited subset of theoretical CS
16:35:23 <toki78> most probably
16:35:34 <mjrosenb> namely, formal logic
16:35:35 <mreh> it's the foundation of CS
16:35:43 <toki78> too few people there
16:35:49 <gwern> @quote scrotum
16:35:49 <lambdabot> No quotes match.
16:35:51 <toki78> CS ?
16:35:54 * gwern didn't think so
16:35:59 <mreh> computar science
16:36:29 <toki78> they dont answer me at all
16:36:42 <mreh> toki78, be patient, fewer people will be reading it
16:37:00 <mreh> gwern: I have to remember what cpSFAXA stands for :)
16:37:11 <gwern> what does it stand for?
16:37:29 <toki78> can i open my own channel ?
16:37:33 <toki78> #theory ?
16:37:40 <mreh> gwern: isn't it obvious?
16:37:48 <mreh> toki78, yup
16:37:50 <mreh> just join it
16:37:56 <gwern> continuation passing Style FAXA?
16:38:00 <gwern> mreh: no
16:40:43 <shapr> Silly question...I want to make a tree of categories. An item can refer to a location in that tree.
16:41:05 <shapr> But I'd like to be able to add more to the tree later, and not have to change the items themselves.
16:41:24 <shapr> Sounds to me like I need to give each category an ID, so that changes to the tree will not change existing items.
16:41:31 <shapr> Is there a better way?
16:41:45 <gwern> tree of categories?
16:42:09 <shapr> gwern: Yeah, I'm making a hardware barter website. I stole the categories tree from newegg.com.
16:42:27 <shapr> gwern: What do you suggest?
16:42:27 <gwern> sounds like each category has an ID - the category
16:42:42 <shapr> Yeah, I thought so, just wasn't sure if there was a better way.
16:43:05 <shapr> Thanks!
16:43:12 * gwern shrugs
16:43:51 <mreh> sounds like you need a category theory
16:46:36 <shapr> mreh: ouch
16:46:54 <mreh> I think I heard a cough in the audience
16:47:06 <gwern> no, that was a groan. of pity.
16:48:21 <toki78> i made a little discovery with neural nets
16:48:53 <QtPlatypus> toki78: What was your discovery?
16:49:13 <toki78> please read the text here : http://tokis-edv-service.de/index.php/beispiele/feed-forward-neuronale-netze
16:49:22 <gwern> 'why are you randomly wiring your neural nets?' 'I wish them to have no preconceptions' Sussman shut his eyes. 'I too wish to have no preconceptions'
16:49:58 <toki78> *g*
16:52:15 <mreh> is the number of hidden neurons correlated to the number of terms in the function?
16:52:35 <mreh> for example a perceptron is linear
16:53:09 <_swift_> gwern: haha, your mention of that anecdote made me look up the original, and i have to say, i was enlightened!
16:53:27 <toki78> the number of neurons correlates to the number of periods in the sine function
16:54:33 <mreh> toki78, what about multiple layers?
16:55:05 <toki78> at the moment i cannot generalize that method, not even to dimension > 1
16:55:40 <toki78> :(
16:58:27 <toki78> mreh , can you give a comment about that discovery ?
16:58:44 <mreh> toki78, multiple layers?
16:58:54 <toki78> not possible yet
17:09:05 * hackagebot attoparsec-iteratee 0.1.1 - An adapter to convert attoparsec Parsers into blazing-fast Iteratees  http://hackage.haskell.org/package/attoparsec-iteratee-0.1.1 (GregoryCollins)
17:27:24 <djahandarie> Hayoo has been throwing an internal server error for awhile now :(
17:39:58 <mjrosenb> djahandarie: haven't noticed
17:40:06 <mjrosenb> djahandarie: i've always used hoogle
18:00:39 <jkingkong> does anybody have a small program that makes use of the Reflection module?
18:00:52 <jkingkong> I'm fairly certain it's what I need but I can't make heads or tails of it
18:01:02 <soupdragon> @hackage Reflection
18:01:02 <lambdabot> http://hackage.haskell.org/package/Reflection
18:01:15 <jkingkong> yes that one
18:01:18 <soupdragon> that is a 404
18:01:24 <soupdragon> I am just wondering what this module is
18:01:31 <jkingkong> http://hackage.haskell.org/packages/archive/reflection/0.3.0/doc/html/Data-Reflection.html
18:01:35 <soupdragon> tu
18:01:35 <soupdragon> ty
18:01:38 <jkingkong> np
18:01:45 <soupdragon> have you read the paper on this?
18:01:55 <jkingkong> Yes
18:01:58 <jkingkong> err...tried to
18:02:09 <soupdragon> I remember reading this and being very unimpressed
18:02:11 <jkingkong> the Implicit Configurations one that everybody raves about (for good reason I'm sure)
18:02:16 <jkingkong> oh yea?
18:02:22 <soupdragon> yeah I didn't really see the big deal
18:02:23 <jkingkong> do you know what the actualy solution should be?
18:02:34 <soupdragon> oh I mean it's fine
18:02:37 <soupdragon> I don't have anything against it
18:03:07 <jkingkong> I mean, I need a global variable defined at runtime, and I don't want to pass it around everywhere
18:03:22 <soupdragon> imo you should just pass it around everywhere, or use C
18:03:56 <jkingkong> even if there are many global variables? and if one of those variables changes how I want objects to be ordered?
18:04:02 <jkingkong> this is the real problem actually
18:04:19 <jkingkong> I want to instance the Ord typeclass differently depending on a parameter passed at runtime
18:04:49 <pikhq> jkingkong: Why do you want to do that?
18:05:00 <pikhq> (rather, what do you intend to do by doing that)
18:05:05 <jkingkong> I'm using Haskell to write a math package
18:05:23 <jkingkong> depending on how things are defined, one object might be bigger or smaller than the other
18:05:44 <jkingkong> have a type dependence that is mutable at runtime seems like the elegant way of doing this
18:06:00 <jkingkong> rather than writing ad hoc "compare" functions for every possible input
18:06:40 <pikhq> :t sortBy
18:06:41 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
18:06:43 <pikhq> :t comparing
18:06:44 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
18:06:55 <jkingkong> yes this is true
18:07:04 <jkingkong> but say I want to put it in a map
18:07:12 <jkingkong> which requries the object to instance Ord
18:07:21 <jkingkong> how will the map know how to order them?
18:07:31 <pikhq> Also, "object"? What is this "object" of which you speak?
18:07:34 <jkingkong> and there are other structures/functions that need this too
18:07:42 <jkingkong> meh a foo
18:07:49 <jkingkong> just some abstract data type
18:07:58 <monochrom> an object has morphisms to itself and other objects
18:08:06 <monochrom> <duck>
18:08:14 <jkingkong> monochrom: lol
18:08:30 <jkingkong> monochrom that is true
18:08:40 <pikhq> jkingkong: It really truly *does* seem like what you have is a *typeclass*, not a type you're dealing with...
18:08:46 <jkingkong> but for this application, writing out/determining those isomorphisms is really difficult
18:09:03 <jkingkong> pikhq: yes it's possible I'm doing this completely the wrong way
18:09:15 <jkingkong> Oleg's paper uses a typeclass at least
18:09:25 <pikhq> This is why I'm asking what you're intending to do. So as to be least unhelpful. ;)
18:09:42 <jkingkong> haha why thank you
18:10:23 <jmcarthur> could you perhaps give a made-up-syntax version of what you want along with what it means?
18:10:44 <jmcarthur> assuming made-up-syntax is even necessary, of course
18:10:46 <jkingkong> so say newtype Foo bar = Foo (Zoo bar)
18:11:06 <jkingkong> and newtype Zoo bar = Zoo Something Known
18:11:27 <jkingkong> bar is the variable that will encapsulate how objects of type "Foo" and "Zoo" are ordered
18:11:33 <jmcarthur> so bar is a phantom type in Zoo?
18:11:36 <jkingkong> yes
18:11:40 <jkingkong> it gets trickier
18:11:46 <jmcarthur> listening
18:12:05 <jkingkong> now say I don't want Foo bar = Foo (Zoo bar) but I want Foo bar = Foo (Map (Zoo bar) Something)
18:12:28 <jkingkong> functions in the Map module require Zoo bar to instance ord
18:12:32 <jkingkong> Ord sorry
18:12:40 <jmcarthur> instance Ord (Zoo Int) ...; instance Ord (Zoo Bool) ...; etc.
18:12:48 <jkingkong> yes exactly
18:13:02 <jmcarthur> or even just:  instance Ord bar => Ord (Zoo bar), if Zoo would work that way
18:13:04 <jkingkong> now suppose I want Foo bar to instance the Num class
18:13:15 <jmcarthur> man this is involved :P
18:13:16 <jkingkong> yes I can instance Zoo that way properly
18:13:22 <jkingkong> haha :P isn't it always
18:13:32 <jmcarthur> okay, listening again
18:13:41 <jmcarthur> and this time i will wait until you tell me to speak ;)
18:13:57 <jkingkong> instance Num (Foo bar) where ... Foo a + Foo b = some function that depends on order
18:14:07 <jkingkong> Now here, the compiler complains
18:14:19 <jkingkong> because it doesn't know what instance of Zoo bar it needs
18:14:33 <jmcarthur> bar is not enough information?
18:14:40 <jkingkong> no it's not
18:14:47 <jkingkong> and this is what I don't understand
18:15:01 <jkingkong> I was hoping the compiler would be smart and know that it's fine
18:15:12 <jmcarthur> are you using FlexibleInstances or the instance Ord bar => Ord (Zoo bar) version?
18:15:19 <jkingkong> but I think it's worried the user will try something like Foo Bad where Bar is not instanced
18:15:23 <jkingkong> \Bar/Bad
18:15:35 <jkingkong> Ord bar => Ord (Zoo bar)
18:15:47 <jmcarthur> instance Ord bar => Num (Foo bar)
18:15:53 <jmcarthur> tried that?
18:16:05 <jkingkong> Yes this is what it looks like right now
18:16:11 <jkingkong> now
18:16:20 <jkingkong> it tells me "Constraint is no smaller than the instance head"
18:16:36 <jmcarthur> uh
18:16:40 <jkingkong> and "Use -XUndecidableInstances to permit this"
18:16:49 <jkingkong> also
18:16:53 <jkingkong> if it helps the diagnosis
18:17:02 <jkingkong> if I do instance Num (Foo A) where ...
18:17:10 <jkingkong> and I've instanced Foo A
18:17:11 <jkingkong> it works
18:17:26 <jmcarthur> if you enable UndecidableInstances does it work?
18:17:33 <jmcarthur> or does it hang?
18:17:36 <jkingkong> No
18:17:53 <nus> this is what you get when you code Turing machines at the type level
18:18:12 <jmcarthur> honestly i'm not seeing why it would be saying that
18:18:20 <nus> why are you modelling the operations as typeclasses anyway?
18:18:23 <jmcarthur> let me look back over what you said an make a test program out of it
18:18:30 <jkingkong> It tells me Could not deduce (Show (Foo bar)) from the context (Ord (Zoo bar))
18:18:41 <jmcarthur> ah!
18:18:51 <jmcarthur> that means it "works"
18:18:58 <jkingkong> ?
18:19:04 <jmcarthur> you will need a Show instance though
18:19:17 <jkingkong> well I have one
18:19:18 <jmcarthur> for Foo
18:19:21 <jmcarthur> oh?
18:19:21 <jkingkong> just not for a general bar
18:19:24 <jmcarthur> what does it look like?
18:19:26 <jkingkong> for specific bar
18:19:26 <jmcarthur> oh
18:19:30 <jmcarthur> that's the problem then
18:19:33 <jkingkong> instance Show (Foo A) where
18:19:37 <jkingkong> yea exactly
18:19:51 <jmcarthur> you're going to have to do it for each bar if you do the show instances that way
18:19:52 <jkingkong> part of me feels like it should just "work" but I can understand why it wouldn't
18:20:04 <jkingkong> sigh yea I was about to resign to that
18:20:08 <jkingkong> it really isn't that terrible
18:20:15 <jkingkong> I just want it to look nice and pretty :)
18:20:22 <jmcarthur> so you can't say  instance Show bar => Show (Foo bar)?
18:20:30 <jkingkong> hmm I'll try this
18:20:35 <jmcarthur> that would fix it
18:22:05 <jkingkong> hmmm
18:22:12 <jkingkong> Overlapping instances for Show
18:22:35 <jmcarthur> you must not have gotten rid of your other instance(s)
18:22:36 <jkingkong> Foo bar is more general than Foo A
18:22:43 <jkingkong> yea I didn't
18:22:44 <jmcarthur> you will have to replace them with the new one entirely
18:22:53 <jkingkong> OK let's try that
18:23:36 <jkingkong> worked!
18:23:39 <jmcarthur> yay!
18:23:46 <jkingkong> man what a random fix
18:23:53 <jkingkong> so I was doing the other part right after all
18:23:59 <jmcarthur> doesn't seem that random to me :)
18:24:02 <jkingkong> I just assumed it was wrong cause it was the tricky part
18:24:08 <jkingkong> haha no not at all you have my gratitude
18:24:23 <jkingkong> Now, I'll have to figure out how to make things "Show" properly
18:24:29 <jkingkong> but that'll be another day :)
18:24:40 <jmcarthur> you can't derive it?
18:25:37 <jkingkong> what do you mean?
18:25:45 <jmcarthur> newtype Zoo bar = <stuff> deriving Show; newtype Foo bar = Foo (Zoo bar) deriving Show
18:26:00 <jkingkong> oh yes i suppose I could
18:26:17 <jkingkong> what does -XUndecidableInstances do exactly
18:26:19 <jmcarthur> and in fact if bar is phantom you probably don't even have to have that Show constraint on bar
18:26:23 <jmcarthur> nor the Ord constraint
18:26:30 <jmcarthur> i suggested those without needing to i think
18:26:43 <jkingkong> the code breaks when I remove the Ord constraint
18:26:48 <jmcarthur> UndecidableInstances means the compiler might not terminate
18:26:58 <jmcarthur> if you do something very wrong
18:27:03 <jkingkong> I see
18:27:15 <jkingkong> so it's not completely safe but you don't think it's dangerous either
18:27:39 <jmcarthur> some people do. i haven't seen a case where it allows you to successfully compile code that should not compile
18:27:51 <jkingkong> ah good to know
18:28:10 <jkingkong> somebody earlier here was telling me that I would cause armaggedon if I used that flag
18:28:14 <jkingkong> (slightly exaggerated)
18:28:21 <jmcarthur> well, you could!
18:28:26 <jmcarthur> if armaggedon == nontermination
18:28:29 <jkingkong> haha
18:28:35 <soupdragon> :t palindrome
18:28:35 <lambdabot> forall a. (Show a) => a -> Bool
18:28:41 <jmcarthur> > palindrome
18:28:42 <jkingkong> is that a type synonym? :D
18:28:42 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
18:28:43 <lambdabot>    arising fro...
18:28:50 <jmcarthur> > palindrome "foo"
18:28:51 <lambdabot>   False
18:28:56 <jmcarthur> > palindrome 5
18:28:57 <lambdabot>   True
18:29:04 <jmcarthur> interesting signature for that
18:29:14 <jkingkong> existential quantification
18:29:19 <jmcarthur> hmm?
18:29:24 <jkingkong> the forall a.
18:29:25 <jmcarthur> are you talking about palindrome
18:29:30 <jkingkong> why is that necessary here
18:29:31 <jmcarthur> in this case it's nothing special
18:29:33 <jmcarthur> it's not
18:29:41 <jkingkong> yea didn't think so
18:29:49 <jmcarthur> :t palindrome :: Show a => a -> Bool
18:29:50 <lambdabot> forall a. (Show a) => a -> Bool
18:29:55 <jmcarthur> lambdabot just puts it there
18:30:08 <jkingkong> lambdabot has extensions enabled I see
18:30:12 <jkingkong> very convenient
18:30:12 <jmcarthur> a few
18:30:28 <jkingkong> if you couldn't tell already I'm fairly new to haskell and this channel
18:30:43 <jmcarthur> we all learn from each other :)
18:30:49 <jkingkong> one of the best places in IRC imho
18:30:51 <jkingkong> :D
18:30:55 <jmcarthur> very much agreed
18:31:00 <jmcarthur> we're even nice to trolls
18:31:04 <jkingkong> hopefully I'll be able to offer something at some point
18:31:06 <jkingkong> I'd believe it
18:31:20 <jmcarthur> just watch Cale talk a troll to death some time ;)
18:31:30 <jkingkong> somebody came asking if GHC had a Mac version
18:31:36 <jkingkong> I couldn't believe he got a courteous answer
18:31:45 <jkingkong> This room is filled with good samaritans
18:32:30 <jmcarthur> of course this room has good samaritans. it's says so right in TFM
18:32:34 <jmcarthur> ;)
18:33:04 <jkingkong> TFM?
18:33:11 <jmcarthur> jkingkong: as in "RTFM"
18:33:30 <jkingkong> ohhh that's easier to understand
18:33:49 <jkingkong> are most of you guys developers?
18:33:57 * copumpkin is a bum
18:34:01 <jkingkong> Microsoft employees? hobbyists? what exactly
18:34:02 <jmcarthur> professionally?
18:34:07 <jkingkong> sure
18:34:07 <jmcarthur> ah generally
18:34:11 <jmcarthur> yes and yes :)
18:34:14 <jmcarthur> well
18:34:19 <jmcarthur> i don't work for microsoft
18:34:24 <jkingkong> developer and hobbyist
18:34:33 <jmcarthur> but i code professionally and as a hobby
18:34:36 <jkingkong> copumpkin: lol
18:34:36 <RyanT5000> jkingkong: i run a haskell-based game studio :)
18:34:40 <jmcarthur> most of us probably do
18:34:40 <djahandarie> A lot of students in here also
18:34:46 <jmcarthur> ah yes, students
18:34:47 <jkingkong> RyanT5000: wow
18:34:51 <jkingkong> I'm a student
18:34:59 <jmcarthur> s/most/many/
18:35:03 <jkingkong> grad students I imagine
18:35:04 <copumpkin> did you come from japan on a boat?
18:35:10 <jkingkong> haha no
18:35:18 <jkingkong> American born
18:35:26 <copumpkin> damn
18:35:28 <djahandarie> copumpkin, haven't you heard that Japan has internet now
18:35:39 <jkingkong> apparently, they have planes too
18:35:45 <jmcarthur> japan has better internet than we do :(
18:35:59 <jkingkong> almost everywhere does these days :(
18:36:01 <djahandarie> jmcarthur, except you are capped at a 200KB/s link to anywhere else in the world
18:36:06 <djahandarie> I'm in Japan right now
18:36:08 <jmcarthur> djahandarie: really?
18:36:10 <jmcarthur> dang
18:36:11 <djahandarie> Yeah
18:36:15 <jmcarthur> i didn't know that
18:36:19 <RyanT5000> huh, that seems to call for a massive P2P caching solution...
18:36:35 <jkingkong> I big DC++ network for the whole country
18:36:39 <jkingkong> \I/A
18:36:44 <RyanT5000> cool
18:36:46 <djahandarie> There is perfect dark and stuff
18:36:50 <dolio> djahandarie: That's better than being capped at 200KB/s to anywhere other than your house.
18:37:00 <djahandarie> dolio, yes, indeed. :P
18:37:54 <jkingkong> my dad works in japan
18:38:14 <jkingkong> he's never mentioned that about the internet
18:38:27 <copumpkin> I didn't notice anything particularly painful when I was stealing wifi in 2006
18:38:28 <jkingkong> probably never needs to do any heavy duty dling
18:38:44 <djahandarie> It's blazing fast in the country
18:38:49 <djahandarie> Damn impressive
18:38:55 <djahandarie> But anywhere else it's painful
18:39:06 <djahandarie> I'm sure you can get a good link somehow but this is how it is most places
18:39:09 <jkingkong> so if you want an English copy of Ubuntu or something
18:39:15 <djahandarie> There are mirrors in Japan
18:39:16 <jkingkong> you'd have trouble ?
18:39:25 <jkingkong> i'm sure i guess
18:39:26 <copumpkin> mac software updates?
18:39:29 <jkingkong> for something that high profile
18:39:35 <Adamant> networking is hard, let's go drinking.
18:39:41 <djahandarie> haha
18:39:43 <copumpkin> roger that
18:39:48 <jmcarthur> djahandarie: "I'm in Japan right now" .. so you're visiting or you live there?
18:39:54 <djahandarie> jmcarthur, just visiting
18:40:03 <djahandarie> Been here for 2 weeks almost
18:40:06 <djahandarie> Leaving on Sunday
18:40:14 <jmcarthur> i'd like to visit japan some day
18:40:36 * djahandarie will brb
18:41:12 <jkingkong> Japan's a decent place
18:41:17 <jkingkong> the food portions are small though
18:44:48 <jmcarthur> smaller food portions would be good for me
18:49:50 <copumpkin> does anyone know if TMR issues 2-5 were ever published in pdf format?
18:49:55 <copumpkin> I can only find wiki pages
18:51:43 <monochrom> probably not.
18:52:11 <gwern> I don't think I ever saw them in PDF format, no
18:52:18 <copumpkin> damn
18:52:36 <gwern> don't feel bad; mediawiki can made PDFs of pages
18:53:38 <copumpkin> ugh :P
18:53:40 <copumpkin> not nearly as pretty
18:54:22 <gwern> however, I vaguely remember having to go through and clean up the markup
18:54:29 <gwern> so I don't think they were originally written in mediawiki
18:54:32 <soupdragon> yeah you should make them into PDFs
18:54:35 <gwern> you may be able to find the original tex
18:54:36 <soupdragon> that would be really useful
18:54:45 <soupdragon> I'm sure they will thank you on the site too
18:54:55 <copumpkin> I was just looking to see whether there's enough info
18:54:56 <soupdragon> I've read the old ones but it was a hassle to fish them out
18:55:23 <copumpkin> I don't mind writing tex but maybe the articles started out as tex but were never compiled?
18:56:14 <copumpkin> Impure Thoughts 1 - Thtatic Compilathionth (without a lisp) -(not licensed for this wiki; see the copy on the TMR wiki)
18:56:23 * gwern starts to feel depressed and like an old man. 'once, many years ago, I was working on the original TMR articles on the hawiki'...
18:56:24 <copumpkin> lost forever?
18:56:27 <copumpkin> Philippa: ? :)
18:57:17 <copumpkin> aw, damn
18:57:18 <copumpkin> [attachment:Reflection.pdf PDF version of this article]
18:57:23 <copumpkin> lost in the wiki changeover?
18:57:36 <gwern> entirely possible. quick, to the internet archive!
18:57:48 <copumpkin> I doubt it keeps pdfs does it?
18:58:50 <jkingkong> what is TMR?
18:58:53 <copumpkin> the monad reader
18:58:58 <jkingkong> ah ty
18:58:59 <gwern> too much radium
18:59:01 <copumpkin> byorgey: do you know anything about those ancient issues?
18:59:03 <jkingkong> lol
18:59:06 <gwern> what killed marie curie, you know
18:59:14 <jkingkong> not Radon?
18:59:15 <gwern> copumpkin: the IA keeps PDFs
18:59:20 <copumpkin> oh
18:59:25 <gwern> jkingkong: if radon were that deadly, we'd all be goners
18:59:26 <monochrom> what didn't kill marie made her stronger
18:59:33 <gwern> monochrom: and then killed her
18:59:57 <jkingkong> and it was radium
18:59:59 <jkingkong> and polonium
19:00:09 <jkingkong> according to wiki so I sit at my macbook corrected
19:00:16 <gwern> a rat, a rat
19:00:20 <gwern> dead for a ducat, dead
19:02:38 <copumpkin> okay, no pdfs
19:02:50 <copumpkin> but tmrwiki does have the good stuff
19:02:57 <copumpkin> so I could go through and TeXify them
19:03:33 <gwern> sounds like a lot of work
19:03:36 * copumpkin adds it to his todo list
19:03:40 <copumpkin> it'll probably never come off it
19:03:41 <gwern> maybe you should ask around to see if the repos are still around
19:03:49 <copumpkin> yeah, I'll wait to hear from byorgey and/or shapr
19:03:59 <copumpkin> since it seems like shapr was running it back in the good ol' wikidays
19:04:00 <gwern> I only have the repo for #13, but I know more exist
19:04:21 <gwern> and, after all, with darcs you only need one copy
19:05:38 <gwern> one of the advantages of DVCS. I wonder how the subversion guys back up repos
19:05:56 <jkingkong> gwern: isn't that what radon pumps are for?
19:05:57 <copumpkin> keep them on a big-ass server with redundant storage and off-site backsups!
19:06:03 <copumpkin> backups, even
19:06:11 <gwern> ass-big servers cost a lot
19:06:25 <gwern> jkingkong: no, those are for firing klingon missiles
19:06:34 <jkingkong> but yes, admittedly radon is not nearly as radioactive as radium so not sure what I was thinking
19:06:37 <copumpkin> http://sneezy.cs.nott.ac.uk/darcs/TMR/
19:06:38 <jkingkong> ah, that's very important
19:06:42 <copumpkin> here are 6-14's repos
19:08:08 <jkingkong> CVS vs subversion vs Git vs Mercurial vs others
19:08:09 <jkingkong> go
19:08:15 <gwern> oh good, more repos for my collection
19:08:32 <gwern> ah, turns out I already had 11,14, and 15
19:08:42 * soupdragon smirks.. I guess that's why they call it distributed version control
19:10:00 * gwern has roughly 970 repos. it's pretty sweet
19:10:12 <tensorpudding> CVS and SVN bad, Git Mercurial and Darcs good.
19:10:36 <gwern> it's neat to be able to grep over most of the haskell corpus
19:11:29 <_swift_> i've been meaning to try darcs but i keep hearing its slow for large repos and i often have pretty large files in my repos
19:11:51 <soupdragon> yeah it's really bloody slow
19:11:56 <tensorpudding> Darcs used to have some terrible speed bugs, but they've been mitigated somewhat.
19:11:57 <gwern> if you're keeping large binaries in your repo, most dvcses are pretty bad
19:12:00 <tensorpudding> Mostly with merging.
19:12:03 <gwern> soupdragon: traitor!
19:12:17 <soupdragon> I can't hide the truth anymore
19:12:22 <mjrosenb> darcs still has some speed bugs when working on a huge repository
19:12:33 <_swift_> mercurial handles them well, despite the fact that i'd heard that it didn't (probably the complaints were about older versions?)
19:12:52 <tensorpudding> I've never heard complaints about git being slow.
19:13:28 <_swift_> git seems pretty good but i often <sigh> have to work with windows people, and the experience on windows doesn't seem to be very good
19:13:29 <gwern> it's slow for me. takes forever to figure out how the heck to do anything :)
19:14:02 <tensorpudding> git has imprinted on me, I now am always confused by vcs's that don't work like git.
19:14:39 <gwern> (you mean you've imprinted on git)
19:14:49 <tensorpudding> yeah, i suppose
19:14:58 <tensorpudding> i guess i meant a literal imprinting
19:15:25 <aavogt> like a fowl
19:17:25 <Zao> _swift_: SmartGit is quite lovely if you're on Windows.
19:17:37 <Zao> _swift_: Free for non-commercial usage.
19:18:03 <_swift_> Zao: is it better than tortoisegit? because tortoisegit is beyond frustrating for me
19:19:05 <Zao> Never touched TGit.
19:19:27 <Zao> This is not a shell extension, but a standalone application.
19:19:27 <_swift_> Zao: well, i'll give it a try. surely it can't be worse
19:19:46 <Zao> Like the Git GUI of the msysgit distro, but more awesome.
19:20:16 <_swift_> Zao: nice!
19:21:28 <_swift_> Zao: ah wait, i can't use it. i keep forgetting that i'm doing commercial work right now =)
19:21:53 <gwern> who will know
19:22:07 <_swift_> i'd rather not expose my employer to liability
19:23:29 <jkingkong> I'm a github user
19:24:37 <sfultong> I'm having trouble pulling from patch-tag all of a suddent
19:28:47 <djahandarie> Is there some version of sequenc_e which instead of running the IO actions in order, it forks them all?
19:29:11 <monochrom> perhaps mapM_ forkIO them?
19:29:34 <monochrom> sorry, sequence_ . map forkIO them
19:29:59 <monochrom> @type mapM_
19:29:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
19:30:01 <djahandarie> That's what I tried but it ended up sending my process into some crazy CPU-munching loop
19:30:23 <monochrom> @type mapM_ forkIO
19:30:24 <lambdabot> Not in scope: `forkIO'
19:30:49 <monochrom> @type mapM_ (undefined :: IO a -> IO Int)
19:30:50 <lambdabot> forall a. [IO a] -> IO ()
19:31:43 <monochrom> Then the problem is in each action.
19:31:51 <djahandarie> Hm
19:34:25 <Zao> _swift_: Doh. I'd probably use the msysgit command line tools then.
19:34:29 <Zao> Not _too_ horrible :D
19:35:02 <djahandarie> monochrom, yeah you are right, it seems to be the way I wrote forkIO for a ReaderT Blah IO
19:35:13 <_swift_> Zao: yeah, i'm thinking i may switch to them. i definitely prefer the commandline on every other platform, but the windows commandline is so strange that i usually try to avoid it
19:35:15 <gwern> djahandarie: if all your threads are munching cpu, that seems more like a problem with what the threads are doing :)
19:35:16 <RyanT5000> so, is there a good chatroom for math stuff?  i'm trying to come up with an efficient way of doing numerical integration on a GPU
19:35:34 <RyanT5000> i understand the "on a GPU" part of my problem, just not the numerical integration part :P
19:35:43 <gwern> I thought with gpus that if you could do it at all you were doing it fast
19:35:45 <RyanT5000> (i *slightly* understand that part)
19:35:56 <RyanT5000> gwern: yeah, i'm still on the "doing it at all" part
19:36:08 <monochrom> #haskell-blah doubles as chatroom for math when other chatrooms fail
19:36:24 <RyanT5000> i'll try that
19:36:36 <monochrom> Just yesterday they proved the twin prime conjecture there.
19:37:22 <syntaxglitch> _swift_, install cygwin and a better terminal application
19:37:30 <syntaxglitch> having a usable command line is nice
19:37:37 <Zao> _swift_: SmartGit is Java-based by the way, so it runs on Linux and other hippie platforms :)
19:38:02 <Zao> Quite handy when trying to get a visual feel for how the heck your repository hangs together :)
19:38:19 <_swift_> syntaxglitch: yeah, that would probably be worthwhile
19:38:24 <_swift_> Zao: cool, good to know
19:38:33 <gwern> monochrom: I think you need to use more famous open questions - I had to look up twin primes
19:40:29 <monochrom> It's ok. You people make me look up American TV show references all the time.
19:40:51 <Draconx> it's hard to get more well-known than twin primes, I think.
19:41:15 <mjrosenb> goldbach? 3n+1?
19:41:16 <Draconx> maybe more people know about Goldbach's conjecture?
19:41:25 <monochrom> You need to use more famous shows than The Simpsons.
19:41:34 <ddarius> Collatz's Conjecture is stupid.
19:42:01 <mjrosenb> right, 3n+1 is called Collatz's conjecture
19:42:13 <soupdragon> why is it stupid!??
19:42:18 <soupdragon> I thought it was great
19:42:18 <mjrosenb> ddarius: it is no worse than goldbach's conjecture
19:42:22 <soupdragon> I heard about a new one
19:42:29 <syntaxglitch> How about the Church-Turing thesis? If memory serves me, that's not actually "proven" except by lack of counterexamples...
19:42:39 <soupdragon> > iterate (\x -> x + (read . reverse . show) x) 7
19:42:40 <lambdabot>   [7,14,55,110,121,242,484,968,1837,9218,17347,91718,173437,907808,1716517,88...
19:42:48 <copumpkin> syntaxglitch: it's going to be damned hard to prove :P
19:42:51 <Draconx> syntaxglitch, Church-Turing thesis is not something that you can prove, because it's a statement about the real world.
19:42:52 <copumpkin> ;)
19:42:53 <soupdragon> this always finds a palindrome
19:42:57 <soupdragon> ^ open conjecture
19:43:08 <soupdragon> is it harder than collatz?
19:43:21 <copumpkin> what is the "harder" relation?
19:43:25 <ddarius> There is no significance to Collatz's Conjecture.  The only significance in proving it would be in the method used to prove it.  It's not otherwise an interesting mathematical questoin.
19:43:59 <soupdragon> what is there significance to
19:44:40 <copumpkin> riemann?
19:44:52 <copumpkin> seems pretty significant
19:45:19 <djahandarie> Is there some way to make a thread wait indefinitely without MVar?
19:45:32 <ddarius> The Riemann hypothesis is pretty significant.
19:45:33 <monochrom> read from /dev/null
19:45:34 <copumpkin> djahandarie: an infinite loop? :P
19:45:43 <soupdragon> I don't understand reimann yet
19:45:49 <jkingkong> In Data.Map, there is a mapKeysWith and map function that let you modify the keys and maps of all the Map elements with a predefined function
19:45:49 <monochrom> err, reading from /dev/null is wrong
19:45:53 <Draconx> monochrom, that would return immediately.
19:45:54 <soupdragon> anyway can understand collatz
19:46:01 <jkingkong> there doesn't seem to be one that lets you modify both key and value at the same time
19:46:04 <jkingkong> or am I wrong?
19:46:09 <monochrom> loop over threadDelay
19:46:13 <soupdragon> and that palindrome thing
19:46:18 <glguy> forever (threadDelay maxBound)?
19:46:18 <djahandarie> Hm okay
19:46:25 <Mathnerd314> @hoogle wait
19:46:26 <lambdabot> Control.Concurrent.QSem waitQSem :: QSem -> IO ()
19:46:26 <lambdabot> Control.Concurrent.QSemN waitQSemN :: QSemN -> Int -> IO ()
19:46:26 <lambdabot> System.IO hWaitForInput :: Handle -> Int -> IO Bool
19:46:33 <copumpkin> mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
19:46:37 <copumpkin> jkingkong:
19:46:44 <jkingkong> copumpkin: yes?
19:46:54 <jkingkong> so mapWithKey leaves the key intact
19:47:01 <jkingkong> I want to change the key as well
19:47:24 <gwern> monochrom: more famnous than the simpsons? what could that be?
19:47:25 <copumpkin> there's mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
19:47:27 <copumpkin> oh i see
19:47:29 <copumpkin> you said that :)
19:47:32 <jkingkong> :)
19:47:39 <jkingkong> yes at least now we're on the same page
19:47:55 <copumpkin> hm, I could've sworn there was one
19:47:57 <copumpkin> but I guess not
19:48:08 <jkingkong> this should definitely go in a future version
19:48:16 <jkingkong> I suppose I'll have to write it myself?
19:48:21 <djahandarie> @hoogle threadDelay
19:48:22 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
19:48:27 <soupdragon> hehe
19:48:27 <jkingkong> sigh, and Data.Map was so *complete* too
19:48:33 <djahandarie> @hoogle forever
19:48:34 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
19:48:37 <copumpkin> submit a proposal to libraries@ :)
19:48:57 <jkingkong> hehe maybe I'll write it and show it to them
19:49:06 * gwern prays for jkingkong's soul
19:49:17 <jkingkong> yes i'll need that
19:49:30 <jkingkong> how do I submit a proposal anyways?
19:49:36 <jkingkong> never tried/needed to before
19:50:36 <gwern> you email an essay to libraries@, lard it with all the statistics and arguments you can muster, and then sit back for the reaming
19:50:49 <gwern> if you enjoy it and come back for me, you may eventually succeed
19:50:56 <gwern> a bug report is also in order
19:50:58 <copumpkin> then a thousand people will chime in with minor variations on your idea
19:51:05 <copumpkin> and nobody will be able to agree on what minor variation is the right onw
19:51:12 <copumpkin> and it'll stagnate
19:51:20 <glguy> libraries@ serves an important role of stopping changes from being introduced to the libraries
19:51:28 <monochrom> hahahaha
19:51:38 * jkingkong shudders
19:51:44 <glguy> without it we might not have stability
19:51:47 <monochrom> @remember glguy libraries@ serves an important role of stopping changes from being introduced to the libraries
19:51:47 <lambdabot> Nice!
19:51:55 * gwern was actually about to @remember that
19:51:58 <copumpkin> me too :P
19:52:00 <glguy> or any number of useless little utility functions that don’t all need to be in the libraries
19:52:07 <gwern> and without stability, where would we be?
19:52:10 <gwern> in anarchy!
19:52:22 <jkingkong> awww cmon my function would be useful!
19:52:24 <syntaxglitch> gwern: we'd have a lot more bikesheds of the wrong colors
19:52:28 <gwern> jkingkong: you aren't a filthy anarchist are you
19:52:30 <monochrom> without stability, we would exceed python in popularity
19:52:38 <jkingkong> maybe just a little
19:52:48 <gwern> then maybe you need only a little killing
19:52:52 <monochrom> and instability
19:53:20 * jkingkong gets on with his rebel function
19:53:46 <gwern> your lack of stability disappoints me
19:54:32 <djahandarie> Hm, if I have a bunch of mapM_ over the same same list, would it be possible to somehow combine these? I don't think the map f . map g == map (f . g) property holds here
19:55:02 <djahandarie> Due to the sequence_ disregarding things along the way
19:55:03 <gwern> djahandarie: wait, how can you mapM_ multiple times?
19:55:05 <jkingkong> not unless f and g are homomorphisms
19:55:07 <gwern> :t mapM_
19:55:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
19:55:13 <djahandarie> I mean
19:55:17 <gwern> djahandarie: there's nothing left after the first mapM_
19:55:38 <djahandarie> Yeah they aren't composed actually I don't know what I was thinking
19:56:01 <djahandarie> They are just run seperatetly
19:56:28 <glguy> you can't automatically fuse the two mapM_s since that would change the order of the side-effects
19:56:43 <djahandarie> _ <- mapM_ (something) xs; _ <- mapM_ (somethingElse) xs; _ <- mapM_ (etc) xs
19:56:47 <gwern> I suppose you could do something like map (\x -> f x >> g x >> h x >> return()) list, but not sure what's the point
19:56:53 <glguy> also, no sense pulling in a Monad constraint when all you wanted was an Applicative constraint
19:57:03 <glguy> :t Data.Foldable.traverse_
19:57:04 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
19:57:31 <copumpkin> no sense forcing you onto a list either, as that shows :)
19:58:39 <gwern> what does applicative do anyway?
19:59:16 <djahandarie> I suppose I could just do just map a (\f -> mapM_ f xs) over my list of functions
19:59:26 <djahandarie> It just feels wrong doing all this mapM_ though
19:59:50 <syntaxglitch> :t (<*>)
19:59:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:59:52 <ddarius> djahandarie: If the order of the side-effects doesn't matter to you, then you can fuse them.
19:59:59 <syntaxglitch> :t pure
20:00:00 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
20:00:12 <syntaxglitch> gwern: It does those
20:00:31 <djahandarie> pure is the Applicative verison of return?
20:00:35 <glguy> yes
20:00:47 <glguy> and <*> is ap
20:00:52 <monochrom> applicative does almost nothing
20:00:54 <djahandarie> Cool
20:00:55 <syntaxglitch> all monads should be applicatives as well, in which case return and pure should be identical
20:01:55 <ddarius> class (Applicative m) => Monad m where (>>=) :: m a -> (a -> m b) -> m b
20:02:25 <djahandarie> Is that actually how it is?
20:02:33 <monochrom> no
20:02:44 <djahandarie> Is there something I can import that will make it that?
20:02:47 <monochrom> It will be in Haskell 3100
20:02:50 <glguy> You only need Monad if you want to construct new computation structure based on previous results
20:03:02 <djahandarie> Which I don't
20:03:22 <syntaxglitch> the critical details are: fmap :: (a -> b) -> (f a -> f b), <*> :: f (a -> b) -> (f a -> f b), flip (>>=) :: (a -> f b) -> (f a -> f b)
20:03:26 <djahandarie> :t Data.Foldable.traverse
20:03:28 <lambdabot> Not in scope: `Data.Foldable.traverse'
20:03:38 <glguy> :t Data.Traversable.traverse
20:03:39 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:04:31 <djahandarie> Doesn't that seem to use the previous results?
20:05:12 <syntaxglitch> contrariwise, if you try to use an Applicative as if it was a Monad, you'll end up with a huge stack of nested functors, e.g. (f a -> f (f b))
20:05:36 <djahandarie> Ah
20:05:49 <glguy> djahandarie: no, the struture of the computation is defined by the argument to that function
20:05:59 <glguy> in your case by the list
20:06:17 <syntaxglitch> the ability to compress nested functors into a single layer is also sufficient to form a monad, given an applicative
20:06:19 <syntaxglitch> :t join
20:06:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:06:36 <djahandarie> Right I see now
20:08:05 <djahandarie> So how do I make some monad that isn't Applicative become Applicative? Since it isn't already defined that way
20:09:04 <monochrom> instance Applicative IMonad where (<*>) = ap
20:09:21 <monochrom> pure = return
20:09:48 <monochrom> THE END
20:10:12 <syntaxglitch> but don't try and make all monads into applicatives in one fell swoop, that leads to the Pit of Despair
20:10:27 <djahandarie> Haha, why's that?
20:10:31 <monochrom> why despar?
20:11:14 <syntaxglitch> well, by Despair I mean OverlappingInstances, but it's almost the same thing
20:12:03 <monochrom> ok don't worry, we're lazy programmers, we don't write undemanded code.
20:12:32 <monochrom> in fact we don't write some demanded code either. XD
20:12:39 <gwern> what's the Sloth of Despond then?
20:13:17 <dolio> What about Hythloth?
20:13:30 <monochrom> we spend all our time reading undemanded category theory papers XD
20:13:47 <djahandarie> I seem to be getting Illegal instance declaration for `Applicative (ReaderT Blah IO)'... is that not okay?
20:14:02 <djahandarie> The kinds match up :(
20:14:23 <dolio> That will require FlexibleInstances, at least.
20:14:53 <djahandarie> Maybe I should just stick with mapM_ heh
20:15:09 <monochrom> I see why despair now. :)
20:15:14 <dolio> FlexibleInstances isn't a very controversial extension.
20:16:30 <syntaxglitch> monochrom, so you produce a thunk representing some code, but don't actually do the work until someone looks to see what the code is, eh?
20:16:34 * syntaxglitch doesn't think that would fly at the day job
20:16:45 <djahandarie> Now I'm being told to add NoMonomorphismRestriction as well
20:17:29 * syntaxglitch adds {-# LANGUAGE NoEpimorphismRestriction #-} to his code
20:17:47 <djahandarie> Nevermind, that was just because of a syntax error
20:17:50 <gwern> @wn despond
20:17:53 <lambdabot> *** "despond" wn "WordNet (r) 2.0"
20:17:53 <lambdabot> despond
20:17:53 <lambdabot>      v : lose confidence or hope; become dejected; "The supporters of
20:17:53 <lambdabot>          the Presidential candidate desponded when they learned
20:17:53 <lambdabot>          the early results of the election"
20:18:13 <gwern> you don't see much 'despond' or 'despondency' these days. wonder why
20:20:04 <monochrom> The programmer is the thunk.
20:20:17 <monochrom> (And the TV is the message.)
20:20:57 <djahandarie> Couldn't foldable be used in a ton of places where list is normally used?
20:21:09 <syntaxglitch> couldn'
20:21:12 <syntaxglitch> ergh
20:21:25 <syntaxglitch> couldn't X be used in a ton of places where Y is normally used? quite often
20:21:30 <djahandarie> lol
20:21:59 <gwern> djahandarie: well, you have to have a specific structure at some point
20:22:09 <syntaxglitch> contrary to popular belief, the modern Haskell language and the entire contents of Hackage did not spring forth fully formed from the forehead of SPJ
20:22:14 <gwern> could many libraries be more general? of course
20:22:28 <syntaxglitch> not all design decisions were made with full foresight
20:22:37 <djahandarie> Where is some place where you would explicitly want a list rather than something foldable?
20:23:21 <djahandarie> Oh, anywhere you'd want to add on to the list I suppose
20:23:21 <monochrom> I agree with syntaxglitch. Where is some place where you would explicitly want Haskell rather than just some nice language?
20:23:42 <djahandarie> This conversation is getting far too meta for me
20:24:12 <syntaxglitch> djahandarie, no reason other than efficiency, I imagine; a fold can stand in for any list operation you like
20:24:41 <matt_m> If you have foldable, you can fold cons and get back the list
20:24:59 * gwern abases myself before the great haskell gods. forgive me for making insufficient use of availabe abstractions! I am not worthy! I am a worm!
20:25:04 * gwern wriggles abjectly
20:25:14 <djahandarie> lol
20:26:24 <monochrom> if you are a worm, you are probably Foldable too
20:26:50 * gwern folds self. limply, very limply. it's not very abject to forcefully and firmly fold oneself
20:26:52 * syntaxglitch gives gwern 20 "fmap"s to perform as pennance
20:27:03 <gwern> syntaxglitch: oh, that's no penance...
20:27:08 <gwern> if you know what I mean
20:27:31 <Rotaerk> you're really whipping out the adjectives aren't you..
20:27:43 * nus means what you know
20:28:30 <djahandarie> >> is still legal to use with Applicatives, correct?
20:28:39 <syntaxglitch> :t (>>)
20:28:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
20:28:48 <gwern> Rotaerk: adjectives aren't the only thing I whip out
20:28:49 <syntaxglitch> :t (*>)
20:28:49 <djahandarie> Hm
20:28:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
20:28:52 <djahandarie> Ah
20:28:55 <Rotaerk> >_>
20:28:59 <gwern> ?vixen isn't that right?
20:29:00 <lambdabot> correct
20:29:04 <Rotaerk> heh
20:29:10 <syntaxglitch> :t (<*)
20:29:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
20:29:29 <c_olin> I'm trying to compile/run a basic OpenGL program in Haskell, but the executable causes a segmentation fault when executed.  Any ideas?
20:29:40 <djahandarie> Is there any downside to making this stuff so general?
20:29:51 <copumpkin> a tiny bit of overhead, possibly
20:29:57 <copumpkin> unless you get whole-program compilation
20:29:58 <syntaxglitch> djahandarie, it might lead to compulsive fmap'ing
20:30:38 <copumpkin> djahandarie: you need to pass around method dictionaries and they aren't constant jump locations, so it makes life harder for the cpu
20:30:55 <gwern> but the code is shorter!
20:30:58 <gwern> that's the important thing
20:31:14 <copumpkin> yeah, and the cost is minimal, anyway
20:31:31 <c_olin> Here is my code... http://pastebin.com/P2EzzWM1
20:31:52 <djahandarie> Okay now to run this through hlint and watch it burn
20:32:12 <syntaxglitch> eventually you may start writing your code using zygohistomorphic prepromorphisms
20:32:35 <djahandarie> I do know some category theory too so I don't think that'll be too far away
20:32:39 <gwern> we joke about that, but what are those anyway?
20:32:41 <djahandarie> lol *sigh*
20:32:47 <copumpkin> it's more about masturbation than category theory
20:33:00 <djahandarie> -_
20:33:12 <Trinithis> no way!
20:33:18 <jkingkong> wooot finally finished what I wanted to get finished today
20:33:25 <syntaxglitch> gwern, a generalized recursion scheme built from various pieces in category-extras
20:33:43 <jkingkong> masturbation what?
20:33:43 <copumpkin> gwern: take the bits and look them up in this table: http://comonad.com/reader/2009/recursion-schemes/
20:33:48 <djahandarie> As if it wasn't scary enough by itself
20:34:09 <jkingkong> oh i looked up and saw zygohistomorphic preproporphisms
20:34:27 * jkingkong has an orgasm
20:34:32 <gwern> copumpkin: that sounds like work. isn't there a burrito analogy you could use instead?
20:34:49 <byorgey> copumpkin: yeah, I don't know anything about those old versions of TMR, sorry
20:34:59 <c_olin> Nobody knows what might be causing my program to seg fault?  Google doesn't yield anything helpful :\
20:35:21 <copumpkin> byorgey: ah okay. I'll ask shapr when he reappears :) I've started converting issue 2 just to see how much work it is and it isn't too bad, but it's not the most exciting thing to be doing
20:35:36 <byorgey> copumpkin: yeah, but I think you will get mad props from the community.
20:35:59 <copumpkin> mad props sound good
20:36:07 <copumpkin> maybe I'll do it on my plane ride home
20:36:44 <copumpkin> I mostly just want it so I can read them on my ipad offline, with pretty typography
20:37:06 <pastorn> copumpkin: iPad > kindle?
20:37:14 <RyanT5000> oh yeah, where is shapr?
20:37:16 <Trinithis> @whatis ipad
20:37:17 <lambdabot> I know nothing about ipad.
20:37:20 <copumpkin> pastorn: I wouldn't say that
20:37:26 <syntaxglitch> gwern: it's for when you need to eat and regurgitate a burrito at the same time, as well as change it into a taco halfway through, or something, I don't even know
20:37:30 <copumpkin> pastorn: I wouldn't compare them directly. They're trying to do different things
20:37:37 <gwern> a good try
20:37:53 <copumpkin> you also get access to all stages of your digestion as you digest it
20:37:57 <gwern> RyanT5000: wasn't he working on some sort of category system ripped from newegg?
20:38:11 <jkingkong> Is there a way of making a Map automagically prune elements with specific values?
20:38:16 <RyanT5000> gwern: i'm not sure
20:38:23 <RyanT5000> i've been meaning to get in touch with him, though
20:38:29 <jkingkong> i.e. all elements with values = 0 are never in the map
20:38:38 <jkingkong> (using Data.Map say)
20:38:40 <copumpkin> jkingkong: nope, but you can make a simple wrapper to do that
20:38:55 <jkingkong> really?
20:39:06 <jkingkong> there are a lot of functions that involve changing the elements
20:39:12 <jkingkong> I can't imagine the wrapper for that being easy
20:39:21 <copumpkin> it'd be boring and mechanical
20:39:22 <jkingkong> but I'm also a haskell noob
20:39:26 <Trinithis> easy but perhaps tedious
20:39:30 <jkingkong> oh ok
20:39:38 <copumpkin> it's probably easier for you to just check when you're doing stuff to it
20:39:39 <jkingkong> so the way I'm thinking is the only way :(
20:39:59 <jkingkong> gosh now I have two things I want to add to this module
20:40:01 <Trinithis> you could also use
20:40:07 <jkingkong> I'm listening
20:40:10 <Trinithis> Map Key (Maybe Value)
20:40:15 <Trinithis> and check for Nothing values
20:40:29 <jkingkong> This would amount to the same in the end right?
20:40:33 <Trinithis> yes
20:40:43 <jkingkong> sigh well I'd better get to work then
20:40:44 <Trinithis> unless you have a lot of data mapping to Nothing
20:40:50 <Trinithis> and consume lots of space
20:40:55 <Trinithis> but thats prolly not an issue
20:41:03 <jkingkong> well, the operations I'm doing could produce "Nothing" fairly frequently
20:41:13 <jkingkong> and I don't want my maps with hundreds of keys pointing to Nothing
20:41:21 <Trinithis> then wrap it
20:41:21 <jkingkong> so it'd be a nice thing to automate
20:41:33 <copumpkin> you should always wrap it, to be safe
20:41:40 * copumpkin buys a box of newtypes
20:41:47 <djahandarie> Is there a way to make hlint complain about more stuff?
20:42:00 <jkingkong> Yes I am using newtype
20:42:01 <danharaj> replace it with a woman
20:42:05 <copumpkin> djahandarie: --dowhatImean,idiomatically ?
20:42:06 <jkingkong> I had it wrapped for a different reason
20:42:08 <BMeph> hBitch? ;
20:42:10 <gwern> djahandarie: add more rules to it
20:42:10 <jkingkong> guess I can just lop this on
20:43:12 <marcuy> how can I extract a Char from a custom data and add it to [Char] for example: data TT = Sim Char | Another
20:43:31 <Trinithis> time to reinstall os
20:43:57 <Trinithis> (of course using haskell! jk)
20:45:34 <Cale> marcuy:  foo :: TT -> [Char]; foo (Sim x) = [x]; foo Another = []
20:45:45 <Cale> marcuy: like that?
20:47:33 <marcuy> Cale, perfect thanks
20:48:14 <danharaj> marcuy: pattern matching is a critical concept
20:49:25 <marcuy> danharaj, this is why I'm learning it
20:58:30 <jkingkong> goodnight #haskell
20:59:17 <matt_m> goodnight kimjongil
21:00:42 <wli> matt_m: There was a Kim Jong Il online?
21:03:40 <dmead> we are human
21:03:42 <dmead> after all.
21:03:54 <copumpkin> speak for yourself.
21:04:14 <pikhq> Human? I'm a monster!
21:04:34 <dmead> we are human, with tasty patch boxes
21:04:36 <dmead> http://www.youtube.com/watch?v=u-NGo9EGwcI&feature=related
21:05:04 <typemore> is ghc written all in haskell
21:05:25 <copumpkin> almost
21:06:24 <glguy> typemore: what copumpkin means is that is almost all haskell code
21:06:50 <copumpkin> only the runtime and a script aren't
21:07:20 <typemore> err, the runtime is still written in C?
21:07:26 <copumpkin> and cmm
21:07:44 <copumpkin> (which is ghc's flavor of c--)
21:07:49 <matt_m> wli: For some reason, that's the name I see when I read 'jkingkong'
21:08:33 <typemore> why can't haskell be self hoasting?
21:08:56 <ezyang> typemore: It partially is.
21:09:00 <ezyang> Or, at least, GHC is.
21:09:05 <RyanT5000> typemore: i think there would at least need to be a non-GCed haskell flavor for that to work
21:09:14 <wli> It is self-hosting. Runtimes always use foreign code unless you're talking about asm.
21:09:50 <copumpkin> typemore: all the actual compiler stuff is already in haskell
21:10:06 <wli> e.g. C uses foreign (asm) code to issue system call traps.
21:10:08 <copumpkin> or do you complain about c not being self-hosting because memcpy is written in assembly? :)
21:10:51 <typemore> is the following correct: ghc produces a _binary_ which is the union of (1) haskell code converted to binary <-- by a compiler written in haskell and (2) some runtime <-- written in C ?
21:11:04 <copumpkin> yes
21:11:13 <typemore> victory
21:11:15 <copumpkin> all the actual compilation is pure haskell
21:11:53 <copumpkin> in the runtime is details about closures and GC, mostly
21:12:21 <c_olin> Anyone interested in helping me get a basic OpenGL program running compiled in GHC?
21:12:26 <typemore> hmm, is ocaml written in purely ocaml, or does it also take a ghc like manner?
21:12:33 <copumpkin> it'd be interesting to see if someone could get rid of GC in haskell
21:12:48 <Cale> c_olin: I can try to help, what seems to be the problem?
21:12:49 <wli> copumkin: Region analysis?
21:12:52 <ezyang> copumpkin: Didn't House partially try to do that?
21:13:09 <c_olin> Cale:  My code compiles fine, but it seg faults when I run it
21:13:12 <copumpkin> wli: yeah, it worked for that ML, but we have more knobs and whistles
21:13:12 <c_olin> Here is my code... http://pastebin.com/P2EzzWM1
21:13:20 <c_olin> I'm running ubuntu
21:13:23 <copumpkin> ezyang: probably
21:13:32 <copumpkin> but not for general-purpose stuff I don't think
21:13:42 <wli> copumpkin: Probably easier to do from the ground up than to retrofit. :(
21:13:47 <copumpkin> yeah :/
21:14:00 <copumpkin> maybe
21:15:06 <Cale> c_olin: Okay, one moment while I install the libraries so I can try to run your code myself.
21:15:19 <c_olin> Cale, Okay thanks
21:18:15 <RyanT5000> if someone got rid of GC in haskell
21:18:25 <RyanT5000> and my company is still in business in a year
21:18:30 <RyanT5000> it will be worth money
21:18:32 <RyanT5000> just sayin' :)
21:18:46 <RyanT5000> we would definitely be interested in funding that kind of project
21:18:51 <typemore> removing GC from haskell is easy
21:18:56 <Cale> RyanT5000: If someone got rid of garbage collection, your programs would run out of memory very quickly ;)
21:18:56 <typemore> it's called C & C++
21:19:15 <RyanT5000> hahaha thank both of you for your snarky solutions :P
21:19:17 <jmcarthur> RyanT5000: you mean something other than mark-and-sweep, i assume
21:19:19 <pikhq> RyanT5000: Haskell has no need for a garbage collector. Sadly, we run on machines with finite memory, making garbage collection a *very* valuable feature in Haskell implementations. :)
21:19:24 <pastorn> RyanT5000: there's a function 'gc' or something similar...
21:19:53 <p_l> RyanT5000: Most people don't have a problem with GC, btw
21:19:56 <pastorn> hooked to GHCs inner workings in some way (i presume)
21:20:10 <RyanT5000> p_l: i know; that's why i suspect my company may need to fund it :)
21:20:15 <RyanT5000> i don't mind GC most of the time
21:20:24 <Cale> c_olin: Okay, that doesn't segfault for me.
21:20:31 <RyanT5000> i just need the ability to avoid GC sometimes
21:20:32 <RyanT5000> and control it
21:20:34 <c_olin> hmmm
21:20:36 <pastorn> i know writing to files can screw you over some times (not having written everything by the time the handle is going to close etc.)
21:20:41 <RyanT5000> specifically, i'd love to write my main graphics loop in Haskell
21:20:44 <p_l> RyanT5000: you're talking then about *tuning* GC and possibly a Real-Time GC
21:20:45 <pastorn> does 'appendFile' have this problem?
21:20:53 <c_olin> Any idea on how to figure out what is wrong?  Google gives me nothing.
21:20:59 <Cale> c_olin: I'm on Ubuntu, using the generic linux binary for GHC 6.12.2, and the latest packages from Hackage for OpenGL and GLUT
21:21:01 <RyanT5000> p_l: yes; no-gc is not the only solution to the problem we have
21:21:02 <Null-A> is there a foldl1 which accepts empty lists?
21:21:18 <RyanT5000> which is that GC would cause us to drop frames whenever a major GC occurs
21:21:18 <Cale> c_olin: How are you compiling the program? Just  ghc --make gltest  ?
21:21:25 <phildarnowsky> evening all, I have what I bet is a simple question for someone who knows what they're doing (i.e. not me)
21:21:29 <pastorn> RyanT5000: modify GHC; setGC :: Bool -> IO ()
21:21:33 <p_l> RyanT5000: ITA software afaik avoids GC most of the time, though they use a more imperative programming model afaik
21:21:36 <pastorn> XD
21:21:36 <Cale> phildarnowsky: go for it :)
21:21:37 <copumpkin> Null-A: it's called foldl
21:21:39 <dmead> phildarnowsky, don't ask to ask
21:21:39 <c_olin> Cale, ghc -package GLUT --make Main.hs
21:21:40 <dmead> just ask
21:21:48 <Null-A> copumpkin: oh ok
21:21:56 <babusri> In my program, I changed Data.Vector.Mutable to Data.Vector.Unboxed.Mutable and was surprised to find that the time taken jumped from 1.8 seconds to 3.9 seconds. Any idea how this can happen. I checked this a few times. I will file a ticket on trac.
21:21:57 <RyanT5000> well, our solution was just to write the graphics loop in C++ :)
21:22:02 <copumpkin> Null-A: the extra argument to foldl is what foldl1 should do when it gets an empty list :)
21:22:02 <phildarnowsky> I've installed a package with cabal, but can't seem to get ghci to load the modules in that package
21:22:05 <Cale> c_olin: ah, the --make will figure out which -package's you need.
21:22:08 <RyanT5000> and run it on a thread with no haskell
21:22:10 <phildarnowsky> is there something "obvious" that I'm missing?
21:22:13 <Null-A> copumpkin: oh lol
21:22:14 <RyanT5000> which works great :)
21:22:16 <RyanT5000> it's just annoying
21:22:20 <Null-A> copumpkin: thx
21:22:25 <dmead> phildarnowsky, have you installed globally or as yourself
21:22:26 <dmead> ?.
21:22:26 <lambdabot> Not enough arguments to @.
21:22:53 <c_olin> Cale, Okay.. compiles and still seg faults :\
21:22:57 <phildarnowsky> dmead: I _think_ I installed globally...at least, I did "sudo cabal install whatever"
21:23:00 <Cale> phildarnowsky: As a sanity check, you might want to run  ghc-pkg list <packagename>  and check to see that it's really installed.
21:23:15 <copumpkin> c_olin: load it into gdb and see if it segfaults anywhere recognizable
21:23:21 <dmead> phildarnowsky, also run ghc-pkg check
21:23:31 <pastorn> c_olin: you need to do initialWindowSize $= Size 200 200
21:23:36 <pastorn> or similar
21:23:44 <Cale> phildarnowsky: Even though it shouldn't be your problem here, I recommend against installing packages globally, since it's nice if you accidentally mess things up to not have to reinstall ghc.
21:23:48 <dmead> phildarnowsky, i  made the mistake of installing globally.. but you really only need to install as your user unless you need to maintain a system for a bunch of people
21:24:03 <dmead> ghc-pkg list
21:24:07 <dmead> ghc-pkg unregister
21:24:22 <phildarnowsky> cale: I'm seeing it installed, and ghc-pkg doesn't complain
21:24:25 <pastorn> c_olin: also, you might want to have a clearColor
21:24:30 <pastorn>    clearColor $= Color4 0 0 0 0
21:25:06 <pastorn> so, who here knows about file handles?
21:25:10 <phildarnowsky> trying install again locally just to see what happens
21:25:15 <c_olin> pastorn, Still seg faults
21:25:51 <pastorn> c_olin: oh right
21:25:53 <c_olin> gdb gives me: "0x0024fef6 in XF86DRIQueryExtension () from /usr/lib/fglrx/libGL.so.1"
21:26:10 <pastorn> displayCallback $= do { clear [ColorBuffer]; flush }
21:26:12 <copumpkin> do other gtk-based apps work fine?
21:26:24 <phildarnowsky> think maybe I see the problem
21:26:40 <pastorn> c_olin: or 'swapBuffers'... don't know exactly which that does what
21:26:58 <Cale> pastorn: Well, that's made the program behave more sanely for me, but it runs okay regardless :)
21:27:52 <c_olin> meh
21:27:56 <pastorn> c_olin, Cale: if you do openGL stuff and you don't have any actual computations to do it'll probably behave weirdly (LOTS of DMA being done, so it can freeze the system a bit)
21:27:57 <nus> fglrx might be the culprit.
21:28:09 <pastorn> at least i think it's the DMA that messes things up
21:28:26 <copumpkin> this seems external to gtk2hs I'd think
21:28:27 <Cale> c_olin: Other GL stuff works fine on your system, I take it?
21:28:40 <jmcarthur> RyanT5000: i think what we're really after is incremental garbage collection. gc that is spread out evenly across all the frames of the game
21:28:43 <Cale> (like glxgears)
21:28:45 <pastorn> if you want to experience this, set idleCallback $= Just (return ())
21:28:49 <c_olin> Cale, Come to think of it... I haven't really tried anything opengl since I updated ubuntu
21:29:00 <c_olin> Cale, haha
21:29:04 <copumpkin> oh I mean GL
21:29:08 <c_olin> glxgears seg faults
21:29:08 <copumpkin> silly me
21:29:13 <c_olin> lol
21:29:26 <pastorn> c_olin: you go girl!
21:29:32 <pastorn> copumpkin: you know!
21:29:35 <pastorn> answer me!
21:29:39 <copumpkin> ?
21:29:43 <c_olin> Well thanks for the help :)
21:29:43 <copumpkin> no I don't!
21:29:53 <pastorn> how do i make sure my stuff is written to my file before the handle closes and messes things up?
21:30:04 <copumpkin> pastorn: you don't use lazy IO :)
21:30:06 <pastorn> i want to use appendFile; is that safe?
21:30:20 <jmcarthur> how would the handle closing mess things up?
21:30:24 <pastorn> i was cautioned to use deepseq to be sure
21:30:29 <Cale> pastorn: Output is never lazy I/O
21:30:33 <copumpkin> the handle won't close magically when you don't want it to
21:30:34 <BMeph> i accidentally  the whole appendFile
21:30:50 <pastorn> but what's the problem with readFile/writeFile then?
21:30:59 <pastorn> i've heard that you can mess things up with those
21:31:00 <phildarnowsky> dmead Cale: just to be sure my approach is right, if I install a cabal package that exposes Data.Foo, I should be able to load it in GHCi with :module +Data.Foo, just like it's a core module that comes with GHC?
21:31:03 <jmcarthur> pastorn: readFile is lazy IO
21:31:04 <copumpkin> pastorn: readFile and writeFile to the same file handle
21:31:11 <copumpkin> you don't know when readFile actually reads
21:31:21 <Cale> pastorn: readFile gives you a magic string, which when you look at it, causes the file to be read *then*
21:31:23 * glguy accidentally the whole file descriptor
21:31:23 <pastorn> see, i know there was something :)
21:31:25 <jmcarthur> pastorn: writeFile should be safe, afaik
21:31:26 <dmead> phildarnowsky, yea
21:31:33 <jmcarthur> readFile is... dumb :)
21:31:34 <pastorn> *knew
21:31:38 <jmcarthur> but handy for one-shot things
21:31:44 <Cale> pastorn: If you write the file in the mean-time, you'll get weird and inconsistent results.
21:31:49 <pastorn> and appendFile would also be safe?
21:31:57 <jmcarthur> i would never use readFile in something even remotely complex though
21:31:58 <copumpkin> yeah
21:32:03 <Cale> In conjunction with readFile?
21:32:04 <copumpkin> appendFile should just seek to the end and then write
21:32:05 <dmead> phildarnowsky, ghci should be reading stuff in ~/.ghc and ~/.cabal
21:32:15 <Cale> You shouldn't write to a file that you're reading with lazy I/O
21:32:25 <pastorn> is there no version of readFile that's safe?
21:32:32 <copumpkin> oh you're reading too?
21:32:37 <Cale> There's the one from the strict bytestring library
21:32:40 <pastorn> copumpkin: yes, at startup
21:32:45 <copumpkin> there's strict IO on hackage
21:32:49 <copumpkin> if you really want strict string IO
21:32:49 <Cale> In fact, in general though, it's a good policy not to write to a file you're reading from.
21:33:02 <pastorn> Cale: it's a log file :/
21:33:10 <pastorn> and i need to load it before starting up the program
21:33:13 <Cale> Why are you reading the log file?
21:33:16 <copumpkin> logfiles tend to be write only?
21:33:23 <pastorn> Cale: because i create state from it
21:33:24 <jmcarthur> pastorn: there's (a) manual reading, (b) strict bytestring's readFile, or (c) one of a couple libraries on hackage that attempt to give you safer lazy-style IO
21:33:26 <Cale> mmm
21:33:31 <phildarnowsky> dmead: I'm seeing it under ~/.cabal/lib all right
21:33:43 <Cale> So, instead, maybe write to a different file, and when you're done with that, move that new file over top the old one.
21:33:55 <dmead> phildarnowsky, you need to take out stuff you install globally first
21:34:00 <copumpkin> do you mean log as in journal, like a filesystem has?
21:34:06 <Cale> Er, except in your case you won't be finished with writing.
21:34:09 <Cale> hmm
21:34:10 <Cale> :)
21:34:18 <copumpkin> appending shouldn't be as bad as arbitrary writing, anyway
21:34:30 <pastorn> i could copy the log to temp file at startup, then just use readfile on that
21:34:32 <copumpkin> as long as you don't try to read more than was already there
21:34:37 <pastorn> and only append to the actual file
21:34:42 <Cale> That's true. You could also just make sure that you read the whole thing right off.
21:34:58 <pastorn> Cale: nah, just using strings... don't wanna mess around
21:35:12 <copumpkin> and the worst that will happen if you try reading into the newly appended stuff is that your read might terminate the string when there was new data there
21:35:17 <copumpkin> (I'm guessing)
21:35:42 <Cale> pastorn: Well, it's easy enough to do  fmap BS.unpack . BS.readFile $ "foo"
21:35:44 <pastorn> copumpkin: no, i'll put the cp in the beginning of my program
21:36:02 <Cale> pastorn: That'll save you the trouble of strange behaviour from the lazy I/O
21:36:03 <copumpkin> pastorn: then just readFile, rnf/deepseq the string, and then start your writing :)
21:36:08 <copumpkin> or stop using String IO which sucks :P
21:36:16 <copumpkin> especially since it treats chars as bytes, which is icky
21:36:28 <pastorn> copumpkin: it does?
21:36:32 <jmcarthur> String does?
21:36:32 <Cale> copumpkin: It doesn't anymore.
21:36:38 <copumpkin> ah, as of 6.12 it doesn't
21:36:42 <pastorn> i thought they were magic UTF Chars
21:36:42 <copumpkin> but still :P
21:36:42 <jmcarthur> aha
21:37:07 <jmcarthur> bedtime
21:37:20 <Cale> String IO uses the default for your locale, which is usually UTF-8
21:37:48 <Cale> It was always supposed to be that way, but took a while to get there :)
21:38:15 <phildarnowsky> dmead Cale: If I'm reading this right, I only have it installed locally.  There's no incantation I'm supposed to do after cabal-install, before loading in GHCi?
21:38:30 <Cale> phildarnowsky: No, it should just work.
21:38:38 <Cale> phildarnowsky: Which package?
21:38:43 <phildarnowsky> hmpfr
21:39:37 <GammaLambda> How can I convert a `Maybe String` to a String?
21:39:56 <Cale> GammaLambda:  case foo of Nothing -> "oops!"; Just x -> x
21:40:01 <phildarnowsky> dmead: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmpfr
21:40:17 <GammaLambda> Cale: not sure I follow
21:40:39 <copumpkin> GammaLambda: you need to decide waht to do if you have Nothing
21:40:41 <pastorn> @hoogle unpack
21:40:41 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
21:40:41 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
21:40:41 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
21:40:45 <pikhq> GammaLambda: fromJust :: Maybe a -> a -- Note: undefined on Nothing.
21:40:52 <Cale> GammaLambda: You pattern match on it, and handle the case when the Maybe value is Nothing, and the case when it's Just x for some String x, separately.
21:41:03 <Cale> :t fromMaybe
21:41:05 <lambdabot> forall a. a -> Maybe a -> a
21:41:08 <Cale> You could also use that
21:41:11 <Cale> :t maybe
21:41:12 <GammaLambda> Cale: ok, that leads me in the direction I need
21:41:12 <copumpkin> fromJust is evil and should be removed :P
21:41:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:41:15 <dmead> phildarnowsky, i had to fix this problem last weekend.. one of the big steps was to make sure i didn't have stuff installed globally
21:41:15 <Cale> Or that
21:41:21 <copumpkin> except for when you're positive it's going to be a Just
21:41:23 <dmead> but tbh i forget exactly what i did to fix it
21:41:25 <pikhq> copumpkin: No more evil than head.
21:41:25 <pikhq> :P
21:41:29 <pastorn> strictReadFile = fmap B.unpack . B.readFile
21:41:32 <Cale> head is also evil
21:41:33 <copumpkin> pikhq: that should also be removed :P
21:41:36 <pastorn> Cale, copumpkin ^^ that will do?
21:41:38 <dmead> phildarnowsky, maybe you have a dependency missing
21:41:45 <Cale> pastorn: yes
21:41:48 <copumpkin> pastorn: if you really insist on using String :P
21:41:56 <Cale> pastorn: At least, if you don't care about text encoding
21:41:59 <pastorn> copumpkin: i already use strings EVERYWHERE
21:42:00 <phildarnowsky> dmead: this is what I get from ghc-pkg list hmpfr:
21:42:06 <phildarnowsky> /usr/local/lib/ghc-6.12.0.20091121/package.conf.d
21:42:06 <phildarnowsky> /home/phil/.ghc/i386-linux-6.12.0.20091121/package.conf.d
21:42:06 <phildarnowsky>    hmpfr-0.3.1
21:42:22 <pastorn> Cale: say wat?
21:42:23 <dmead> yea you have it installed globally and in your local directoy
21:42:35 <dmead> you have to remove it twice then reinstall locally
21:42:41 * pastorn will have some swedish characters here and there...
21:42:43 <Cale> dmead: wait, what?
21:42:52 <Cale> dmead: I see only one listing there :)
21:42:54 <phildarnowsky> dmead: Oh, I thought that if I had it installed globally it'd appear under the /usr/local/lib... line
21:43:00 <Cale> phildarnowsky: It would
21:43:21 <Cale> phildarnowsky: You just have it installed locally, should be fine
21:43:27 <dmead> ah soz
21:43:33 <dmead> yea
21:43:40 <Cale> phildarnowsky: So if you open ghci, and do  :m + Data.Number.MPFR
21:43:41 <dmead> i'm thinking you have a dep missing
21:43:45 <Cale> what happens?
21:44:09 <phildarnowsky> cale: can't find it:
21:44:10 <phildarnowsky> <no location info>:
21:44:10 <phildarnowsky>     Could not find module `Data.Number.MPFR':
21:44:10 <phildarnowsky>       it is not a module in the current program, or in any known package.
21:44:42 <Cale> Okay then, let's try to force it...
21:44:50 <Cale> ghci -package hmpfr
21:44:54 <Cale> and then try the same thing
21:45:06 <Cale> Shouldn't really be necessary to do that...
21:45:30 <phildarnowsky> cale: I think I see something off, let me put it in a pastie
21:46:03 <pastorn> phildarnowsky: installing GHC from its binary blob?
21:46:14 <phildarnowsky> cale: http://pastie.org/981297
21:46:40 <phildarnowsky> pastorn: I don't remember for sure, but I think I built GHC on this machine from source
21:47:12 <pastorn> phildarnowsky: i remember having some trouble when installing the binary dist on ubuntu
21:47:22 <Cale> phildarnowsky: That's what it says on my machine, and I don't have the hmpfr package installed at all.
21:47:30 * hackagebot haskell-cnc 0.1 - Library for parallel programming in the Intel Concurrent Collections paradigm.  http://hackage.haskell.org/package/haskell-cnc-0.1 (RyanNewton)
21:47:30 <pastorn> i had to install ghc from Apt before i could install it from the binary package
21:47:41 <pastorn> i think i had the same problem
21:47:49 <pastorn> if that's the BigNum library stuff...
21:47:53 <phildarnowsky> pastorn: that's the one
21:48:14 <pastorn> phildarnowsky: try getting it through your distro first, THEN do the manual installing
21:48:18 <phildarnowsky> pastorn: I seem to remember installing from source since I needed some up-to-the-minute feature that wasn't in the Ubuntu distro
21:48:23 <pastorn> that worked for me on ubuntu 10.04
21:48:24 <ezyang> Why is there no mconcatMap! :o)
21:48:45 <pastorn> phildarnowsky: it's only 100 or so MB...
21:48:47 <phildarnowsky> pastorn: I'll give that a try, sounds likely since I've brought this machine up to 10.04 already
21:48:58 <pastorn> phildarnowsky: wait wat?
21:49:06 <tensorpudding> mconcatMap...that would be map . mconcat?
21:49:08 <pastorn> you did the upgrade stuff?
21:49:21 <phildarnowsky> pastorn: right, but IIRC I installed GHC from source
21:49:29 * pastorn never does that
21:49:36 * pastorn doesn't like exploding computers
21:49:41 * phildarnowsky has to do stuff like that more often than he likes
21:49:46 <ezyang> other way round
21:49:58 <tensorpudding> Bootstrapping isn't very fun.
21:49:59 <pastorn> phildarnowsky: as long as you remount ~ it's usually no trouble
21:50:37 <pastorn> phildarnowsky: when there's a new distro i always reformat / and mount /home/ properly, then i do one giant apt-get install command, wait for a bit, and then everything works again
21:51:30 <phildarnowsky> pastorn: that's not a bad idea, except I have everything under one monolithic partition
21:51:39 <pastorn> phildarnowsky: you should stop that
21:51:56 <phildarnowsky> pastorn: why?
21:52:14 <pastorn> it's simpler if you ever need to do recoveries etc.
21:52:31 <pastorn> and you can't get away with effortless re-installations like i can ;)
21:52:41 <pastorn> (uprgading always seems to break stuff for me)
21:53:06 <phildarnowsky> pastorn: I've never needed to do a recovery, and usually don't install stuff (especially big stuff like GHC) from source
21:53:11 <phildarnowsky> pastorn: of course, the one time I do...
21:53:37 <Cale> phildarnowsky: I tend to go with the generic linux binary rather than installing from source. Compiling GHC when you're not hacking on it is a tremendous waste of time :)
21:53:38 <phildarnowsky> pastorn: and I never liked trying to figure out beforehand how big /home should be, so I decided to skip the issue
21:53:38 <pastorn> at least the upgrade broke some versions ago... now i don't dare to try again
21:53:54 <RyanT5000> jmcarthur: re incremental garbage collection: yes, that's more or less what we want, but we also want it to be *predictable*
21:54:18 <pikhq> RyanT5000: So, you want real-time GC.
21:54:22 <phildarnowsky> I see that I actually do have distro GHC installed as well as my hand-carved GHC, so let me flush the latter and mess with it, and I'll see if that helps
21:54:31 <pastorn> phildarnowsky: just give 15 GB to /, 2~4 GB to swap and the rest to home
21:54:35 <pastorn> easy as pie :D
21:55:01 <Cale> RyanT5000: Have you seen Atom?
21:55:20 <Cale> http://hackage.haskell.org/package/atom
21:55:34 <RyanT5000> pikhq: that sounds good, but i don't know what that means precisely enough to say for sure
21:55:43 <RyanT5000> Cale: nope, but it sounds awesome
21:56:16 <pastorn> writeC  :: Name  -> Config  -> StateHierarchy  -> [Rule] -> Schedule  -> [Name] -> [Name] -> [(Name, Type)] -> IO  RuleCoverage
21:56:19 <pastorn> haha
21:57:17 <copumpkin> pastorn: what's that??
21:57:59 <RyanT5000> btw does anyone have lispy's contact info?
21:58:11 <RyanT5000> (outside of IRC)
21:58:17 <copumpkin> hmm
21:58:33 <copumpkin> I know his name, but that's it
21:58:38 <RyanT5000> hm
21:58:47 <phildarnowsky> cale: I also used to spend days at a time configuring and recompiling my Linux kernel.  But I got over that.
21:59:00 <pastorn> copumpkin: Language.Atom.Code.writeC
21:59:20 <RyanT5000> he said he might be interested in one of the projects i'm looking for people for
21:59:30 <RyanT5000> though i might as well ask if anyone else in here is interested, as well:
22:00:07 <RyanT5000> i'm looking for someone to help work on ghc-iphone, and to create ghc-android
22:00:20 <RyanT5000> there would be money associated with this job
22:00:32 <RyanT5000> (despite the fact that it's mostly open-source work)
22:00:36 <danharaj> but the fascists at apple would never allow ghc-iphone
22:00:52 <RyanT5000> danharaj: we'll see :)
22:01:03 <RyanT5000> anyway, it exists: my company made it
22:01:07 <copumpkin> danharaj: if nothing else, we (the jailbreak community) will embrace him
22:01:27 * copumpkin gives RyanT5000 a hug, to prove his point
22:01:27 <RyanT5000> my company will be releasing our game for iPhone and Android and several other platforms
22:01:30 <RyanT5000> haha :)
22:01:43 <RyanT5000> if Apple wants to reject our app, they had plenty of excuses available to them before 3.3.1
22:01:57 <dmead> good luck with the language issues
22:02:01 <danharaj> oh wait
22:02:13 <RyanT5000> we always have a weapon of last resort: rewriting stuff in C++
22:02:18 <danharaj> http://projects.haskell.org/ghc-iphone/
22:02:19 <danharaj> this you?
22:02:22 <RyanT5000> yup :)
22:02:35 <Cale> copumpkin: What was his real name again? I probably have his email address
22:02:37 <RyanT5000> Steve Blackheath works for me; i hired him to make that project
22:02:44 <copumpkin> Cale: jason dagit
22:02:49 <Cale> Right...
22:02:52 <danharaj> I am better convinced that they would allow it if it compiles to C with their apis (fascists)
22:03:03 <RyanT5000> danharaj: it does compile to C
22:03:08 <danharaj> yes. I noticed.
22:03:15 <RyanT5000> we basically hand a pile of C, C++, and Objective-C to Xcode
22:03:22 <Cale> dagitj at gmail
22:03:23 <copumpkin> with llvm in there, we could generate ARM directly too
22:03:51 <RyanT5000> if you read Steve Jobs' email describing why he put in 3.3.1, it's clear that nothing we're doing is in violation of his intent
22:03:52 <danharaj> copumpkin: Apple definitely would reject that.
22:04:02 <copumpkin> danharaj: I don't really think so, honestly
22:04:18 <copumpkin> yes, it's in violation, but they don't care enough to put some heavy firepower to detect violations
22:04:28 <copumpkin> as long as you don't advertise that you're violating it, I don't think they care
22:04:37 <copumpkin> (and you aren't making an ugly, un-iphoney pp)
22:04:43 <RyanT5000> danharaj: me and the other co-founder of iPwn Studios both went to law school; we've looked over the contract very carefully :)
22:04:51 <copumpkin> Cale, the ultimate address book and teacher!
22:04:57 <danharaj> Steve Jobs' is a legal vampire.
22:04:58 * copumpkin tries to adapt the Saikano abbreviation to him
22:05:07 <copumpkin> Saikare?
22:05:07 <Cale> hehe
22:05:19 <copumpkin> I guess heiki never made it into the abbreviation
22:05:26 <RyanT5000> well, frankly, i can see where Apple's coming from on blocking Flash
22:05:33 <copumpkin> oh, I agree
22:05:37 <danharaj> well Flash sucks
22:05:38 <RyanT5000> flash is not known for its amazing performance or stability
22:05:41 <danharaj> This is a scientific fact.
22:05:50 <copumpkin> but it seems easier for them to just say "we don't want un-iphoney, shitty apps"
22:05:52 <copumpkin> :P
22:05:56 <RyanT5000> btw, Unity developers haven't had any issues with 3.3.1
22:05:58 <Cale> Well, lispy is the one hosting lambdabot, so I've communicated with him by email a bit in the past.
22:06:00 <copumpkin> "oh, and no flash either"
22:06:09 <Null-A> Man, amazingly I just wrote a hundred lines of haskell with almost not type inference errors
22:06:15 <Null-A> it felt amazing
22:06:22 <copumpkin> :)
22:06:28 <Null-A> I didn't think this day would come
22:06:30 <RyanT5000> copumpkin: i suspect that if they banned flash specifically, they'd be hit with a big fat lawsuit immediately
22:06:40 <Cale> But not only that, I have all the mailinglists going to my gmail account, where I mostly fail to read everything, but it's nicely searchable.
22:06:41 <copumpkin> RyanT5000: possibly
22:06:52 <copumpkin> yeah, same here
22:06:59 <copumpkin> gmail labels are awesome for mailing lists
22:07:03 <copumpkin> if you tell it to skip the inbox
22:07:22 <Cale> yep, that's what I'm doing :)
22:07:36 <RyanT5000> copumpkin: especially since you can put a thread back in the inbox and new stuff will appear there :)
22:07:50 <RyanT5000> (you may be aware of a certain thread of mine that is currently at the top of my inbox :P)
22:08:12 <copumpkin> yeah :)
22:09:22 <RyanT5000> speaking of which, i think it's time for me to flog that again:
22:09:29 <RyanT5000> anyone looking for a job writing games in haskell, talk to me
22:09:53 <RyanT5000> we're looking for people with haskell experience - game dev experience in particular isn't required
22:10:22 <Null-A> Selling stock options right?
22:10:33 <RyanT5000> Null-A: no; combination of cash and profit-share
22:10:37 <Cale> Does it require me to have apple stuff? :)
22:10:40 <Null-A> heh =)
22:10:50 <Null-A> no, but I require this
22:11:02 <RyanT5000> Cale: not necessarily; nearly all of our code runs on Linux
22:11:13 <Cale> Oh, cool :)
22:11:20 <RyanT5000> i'm also thinking of putting up an Xcode build server
22:11:28 <RyanT5000> so that our devs don't need to use apple stuff even for deployment
22:11:35 <RyanT5000> (iTunes would still be required)
22:11:42 <copumpkin> it runs in wine though
22:11:58 <RyanT5000> copumpkin: yeah, but it's still kind of "apple stuff" :P
22:12:07 <copumpkin> I also had an itunes-less implementation of the app-installing protocol lying around somewhere
22:12:11 <RyanT5000> huh, that's cool
22:12:13 <copumpkin> from OS 2.0, not sure if it's changed
22:12:17 <RyanT5000> it may well have
22:12:21 <RyanT5000> they were having a big spat with Palm
22:12:44 <copumpkin> yeah :/
22:12:51 <copumpkin> one of these days I'll reverse it again and see if it changed
22:12:53 <RyanT5000> anyway, we don't have much money, but we don't have none either :)
22:13:04 <copumpkin> dtrace is a godsend for that :P
22:13:18 <copumpkin> :)
22:13:21 <RyanT5000> we certainly can't offer a 150k salary like Tsuru does
22:13:21 <BMeph> I noticed someone bring this up on #functionaljava - has http://www.megacz.com/thoughts/on.laziness.html been discussed here already?
22:13:41 <copumpkin> RyanT5000: damn, off to tokyo then
22:13:47 <RyanT5000> haha
22:14:08 <RyanT5000> well, i don't mind having them as competitors in the hiring marketplace
22:14:09 <glguy> Is it well known that the GHC in macports doesn't work?
22:14:18 * glguy tries to find the ticket on the macports website about this
22:14:26 <RyanT5000> frankly, at this point, i think things that help Haskell help me
22:14:45 <RyanT5000> glguy: i'm not sure; we don't use that anyway
22:14:55 <ezyang> BMeph: I think that hit reddit a little back?
22:14:55 <RyanT5000> (we're stuck on GHC 6.10.4, for one)
22:15:01 <copumpkin> yeah, I've always just used the package
22:15:38 <copumpkin> it would be interesting to add laziness/strictness annotations in types. I think it would require some form of implicit boolean operations on types though
22:16:34 <copumpkin> I guess it'd be pretty hard in the general case
22:16:54 <copumpkin> since you could just force the 3rd element (and the first three constructors) of a list, for example
22:17:04 <glguy> RyanT5000: I’m just trying to figure out the best way to compile GTK2 applications on OS X. I don’t really care what version it is specifically or how I have to install it. Ideas?
22:17:29 <RyanT5000> glguy: gtk2hs is now installable by cabal, as of 0.11, afaik
22:17:33 <RyanT5000> does that help at all?
22:17:42 <RyanT5000> i've only done gtk2hs builds on linux, though :-/
22:17:45 <copumpkin> glguy: http://gtk-osx.org/ ?
22:17:52 <BMeph> ezyang: Thanks, I go put on some rubber clothes and explore the sewer, heh-heh.
22:17:52 <copumpkin> I haven't tried it though
22:17:55 <copumpkin> but it looks pretty :)
22:18:24 <BMeph> ezyang: I noticed that the guy hits Haskell rather hard, but never mentioned Clean...
22:18:57 <copumpkin> how does clean deal with the example I gave?
22:19:22 <glguy> RyanT5000: I have to find a pairing of GTK2 and GHC that use the same libiconv
22:19:48 <glguy> libiconv incompatibilities on OS X seem to be well known but I haven’t found anything definitive about what my options are.
22:19:58 <RyanT5000> glguy: ah, yeah, i haven't seen anything about that, sorry
22:20:40 <copumpkin> lol, this is a pretty deep package: http://hackage.haskell.org/packages/archive/dtrace/0.1/doc/html/src/System-DTrace.html#trace
22:20:47 <copumpkin> (that's the only thing in the whole package)
22:21:44 <Null-A> hmh
22:21:50 <Null-A> haskell has a preprocessor?
22:22:06 <copumpkin> it has template haskell and can use the regular c preprocessor too
22:22:11 <kmc> Null-A, no, but there's a GHC extension to use the C preprocessor, and a way to specify other programs as well
22:22:11 <copumpkin> and SHE ;)
22:23:46 <Null-A> I'm pretty sure my company would save millions of dollars if we switched to haskell
22:23:53 <Null-A> yet I don't think anyone would be interested
22:24:09 <Null-A> (the company I work for)
22:24:33 <RyanT5000> Null-A: that's what i'm hoping to do :) (save millions of dollars)
22:24:43 <Null-A> I tried to name a function today... mapFunctorToCollection
22:24:49 <Null-A> and during code review I was asked to change it
22:24:54 <Null-A> it was literally a map function lol
22:25:08 * p_l plans on milking, maybe not millions, but at leasts thousands of dollars by writing in CL/Haskell ;P
22:25:35 <Null-A> had to rename it to fDispatchCollection
22:26:11 <swift-prime> what's the 'f' for? to clarify that it's a function?
22:26:24 <Null-A> functor
22:26:27 <Null-A> yes
22:26:36 <c_wraith> sounds like C++-speak
22:26:42 <Null-A> yes, we're using C++
22:27:06 <Null-A> It's a shame, every week I see employees kind of frustrated on what to do
22:27:15 <Null-A> the code is a little crazy
22:27:21 <Null-A> and the best of us get a little done each week
22:27:22 <RyanT5000> i tried to use closures in C# on mono
22:27:34 <RyanT5000> in some work-for-hire i was doing back in the day
22:27:45 <swift-prime> C++ is like some sort of bizarre make-work program instituted to keep programmers perpetually employed
22:27:53 <RyanT5000> turns out, on that version of mono at least, sometimes things in a closure just get replaced with null
22:28:11 <RyanT5000> only if the closure's got some generic type arguments
22:28:14 <pastorn> RyanT5000: the best closure :D
22:28:28 <RyanT5000> pastorn: yeah, that was a 12-hour debug session
22:28:32 <kmc> RyanT5000, i saw your post about jobs at iPwn
22:28:34 <pikhq> swift-prime: No, that's computers in general.
22:28:35 <pikhq> :P
22:28:37 <RyanT5000> kmc: cool :)
22:28:37 <kmc> do you have a couple minutes to PM about it?
22:28:45 <RyanT5000> kmc: absolutely: it's my job :)
22:28:49 <swift-prime> pikhq: haha true :)
22:28:50 <kmc> cool :)
22:29:01 <RyanT5000> (and it's one of those 24/7 jobs in my case :P)
22:29:28 <Null-A> RyanT5000: if you're starting a company, why choose games?
22:29:39 <c_wraith> RyanT5000, oh, you're working on bloodknight?  I'm kind of amused I made my last release of the one lib I have on hackage to support use cases for you guys. :)
22:30:08 <RyanT5000> c_wraith: awesome, thanks :)
22:30:19 <c_wraith> Good luck with your efforts. :)
22:30:25 <RyanT5000> Null-A: for a number of reasons; it seemed like something we could start with little  money, for one
22:30:29 <RyanT5000> we really wanted to stay privately-owned
22:30:35 <RyanT5000> and away from venture-capitalists :P
22:31:00 <Null-A> they're not so bad :-P
22:35:13 <RyanT5000> haha
22:35:19 <RyanT5000> i took a course in venture capital at law school
22:35:27 <RyanT5000> it was from the VC perspective
22:35:40 <RyanT5000> and, i tell you what, if they have anyone who's taken that course or something like it
22:35:43 <Null-A> lol, that must have opened your eyes
22:35:48 <RyanT5000> i do not want to sit across from them at the bargaining table :P
22:35:59 <RyanT5000> they have so much power, all that's needed is a bit of cleverness to abuse it
22:36:23 <RyanT5000> not to mention, we like doing things that seem slightly crazy
22:36:26 <RyanT5000> like using Haskell to write a video game :)
22:36:29 <Null-A> Well, you are suppose to offset their power
22:36:33 <Null-A> by bringing value to the table
22:36:53 <RyanT5000> sure, but how much value can i *prove to them* that i'm bringing?
22:36:55 <RyanT5000> that's the hard part
22:37:05 <RyanT5000> the only way to *really* prove it is to already have a product
22:37:08 <RyanT5000> in which case, who needs VC?
22:37:17 <RyanT5000> and it's a spectrum between "idea" and "successful product"
22:37:21 <Null-A> for funding, unless its a video game
22:37:32 <RyanT5000> well i mean
22:37:39 <RyanT5000> once your product is successful, you don't need VC funding
22:37:48 <RyanT5000> or, at least, you need a very different kind
22:37:53 <RyanT5000> (growth investments, etc.)
22:37:55 <Null-A> right but not everyone can bootstrap a company from their personal finances
22:38:05 <RyanT5000> well, my gamble is that i can :)
22:38:09 <RyanT5000> and it seems to be working so far
22:38:10 <pastorn> @pl (\mb -> mb >>= \b -> whenM b f)
22:38:10 <lambdabot> (flip whenM f =<<)
22:38:14 <pastorn> ugh...
22:38:22 <pastorn> @hoogle whenM
22:38:22 <lambdabot> No results found
22:38:38 <pastorn> @type whenM
22:38:39 <lambdabot> Not in scope: `whenM'
22:38:45 <pastorn> oh, right :D
22:38:51 <Null-A> Sometimes VC funding is the difference between waiting 1 month for an influx of customers, and 12 months
22:38:52 <pastorn> @pl (\mb -> mb >>= \b -> when b f)
22:38:52 <lambdabot> (flip when f =<<)
22:41:20 <RyanT5000> Null-A: yeah, which means that if you give them 50% of your equity, you're paying a lot for that money
22:41:32 <Null-A> *nods*
22:41:56 <RyanT5000> i know "time-value of money" like the back of my hand (after running this business for 15 months with just my own money)
22:41:59 <RyanT5000> but some prices are just too high :)
22:42:13 <RyanT5000> not to mention, i think having a bunch of old guys on the board would be detrimental to the company's long-term success
22:42:18 <Null-A> do you have a demo yet?
22:42:35 <RyanT5000> no offense to "old people", but they're not known for their expertise at web and phone technologies :)
22:42:45 <RyanT5000> (and i don't trust VC firms to find the few old people who are)
22:42:58 <danharaj> Would Coq or Agda (or something else) be more accessible to get used to dependent type programming?
22:43:00 <Null-A> have you done any previous start-ups?
22:43:12 <BMeph> Ah, I <3 Reddit: 'Babbage: a programming language "named after the first systems designer to go over budget and behind schedule."'
22:43:22 <RyanT5000> Null-A: no, not yet; we're waiting for it to look really awesome before we put anything out there :)
22:43:27 <kmc> danharaj, Agda is more designed for programming, Coq moreso for proofs
22:43:31 <kmc> but Coq is more mature generally
22:43:33 <RyanT5000> we've had to spend a lot of time on the engine so far (which is completely custom, since it's haskell)
22:43:35 <kmc> Agda will be more familiar from Haskell
22:43:40 <Null-A> *nods*
22:43:47 <pastorn> haha
22:43:48 <danharaj> kmc: thanks
22:43:57 <RyanT5000> Null-A: well, during law school i sold electronics online
22:44:00 <pastorn> kmc: did you just use "agda" and "programming" in the same sentence?
22:44:04 <kmc> danharaj, i would read www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf and also http://www.cis.upenn.edu/~bcpierce/sf/
22:44:07 <kmc> pastorn, hell yeah
22:44:16 <RyanT5000> Null-A: but the liquidity hit of keeping an inventory was way too much
22:44:18 <pastorn> kmc: aww you di'int
22:44:25 <danharaj> I am reading the tutorial.pdf as we speak.
22:44:27 <RyanT5000> Null-A: so i liquidated that business before starting this one
22:44:38 <Null-A> cool
22:44:44 <Null-A> so you're recently out of school
22:45:00 * copumpkin beckons danharaj in the direction of #agda
22:45:28 <danharaj> pff
22:45:41 <danharaj> I bet the folks at #agda have neckbeards on their neckbeards compared to you guys :p
22:45:58 <kmc> yeah
22:46:01 * copumpkin has no neckbeard at all!
22:46:04 <kmc> we're the pragmatic, real-world programmers
22:46:12 <pastorn> danharaj: ulf doesn't have any beard
22:46:15 <RyanT5000> Null-A: yes; the other cofounder and i both graduated from law school in May '09
22:46:16 <pastorn> i do, though :D
22:46:16 <kmc> we eschew theory for the quick hack
22:46:27 <kmc> that's why Agda uses Haskell as its FFI language ;P
22:46:29 <RyanT5000> we started this company a bit before that to get the infrastructure (ghc-iphone, etc.) up and running
22:46:49 <Null-A> RyanT5000: nice =)
22:46:51 <copumpkin> kmc: my pet language will too :P
22:47:11 <Null-A> RyanT5000: I think if you were in the valley, you'd find more talent
22:47:23 <RyanT5000> Null-A: well, we don't constrain ourselves geographically anyhow
22:47:39 <RyanT5000> we're in Boston, but our two main programmers are in New Zealand and the Czech Republic
22:47:49 <RyanT5000> which basically means i don't ever get to sleep, due to timezone differences :P
22:47:55 * pikhq prides himself on a neckbeard
22:47:59 <copumpkin> sleep is overrated anyway
22:48:06 <Null-A> lol
22:48:11 <danharaj> I have a friend who does iphone development who works in New York, but collaborates with an artist in Croatia.
22:48:13 <RyanT5000> our art team is mostly local, though
22:48:17 <danharaj> The internet is a wonderful thing?
22:48:19 <RyanT5000> it helps us micromanage :P
22:48:29 <RyanT5000> (envision the scene from Like a Boss)
22:48:57 <Null-A> RyanT5000: ryan trinkle?
22:49:02 <RyanT5000> Null-A: yup
22:49:08 <pastorn> RyanT5000: shit, not that :D
22:49:12 <Null-A> cool, looking over your team, its impressive
22:49:14 <RyanT5000> i should probably start going by that name soon
22:49:16 * BMeph hums to an Offspring theme: "You've got to keep it over-rated..."
22:49:20 <RyanT5000> Null-A: it's also out of date :)
22:49:26 <RyanT5000> we've almost doubled in size since then
22:49:37 <Null-A> RyanT5000: reminds me of "Mr Twinkle" from The Pursuit of Happyness
22:49:52 <RyanT5000> it's a pretty huge project; we're doing everything from scratch: music, art, etc.
22:49:56 <RyanT5000> Null-A: haha
22:51:09 <Null-A> RyanT5000: Polytechnic is in france right?
22:51:19 <RyanT5000> RPI is in Albany, NY, USA
22:51:26 <Null-A> oh ok
22:51:30 <RyanT5000> i'd probably be in #ocaml right now if i went to school in france :P
22:51:36 <danharaj> hon hon hon
22:51:36 <RyanT5000> (not to stereotype or anything...)
22:51:39 <RyanT5000> :P
22:52:03 <copumpkin> hein
22:52:05 <danharaj> (it's ok I took 5 years of wine, cheese, cigarretes and 'my philosophy')
22:52:29 <Null-A> hah
22:52:32 <RyanT5000> nice :)
22:53:12 <Null-A> I use to do game dev when I was 15ish for a few years
22:53:25 <RyanT5000> Null-A: cool; what sorts of games did you work on/
22:53:26 <RyanT5000> ?
22:54:02 <Null-A> RyanT5000:  I wrote a lot of technology demos, I guess they weren't really games. Physics engine, Quake map renderer
22:54:08 <RyanT5000> cool
22:54:14 <RyanT5000> sounds like a great way to learn stuff
22:54:20 <Null-A> Yah it was a lot of fun
22:54:30 <RyanT5000> maybe you should revisit it... working for me ;)
22:54:30 <Null-A> oddly enough I don't actually like playing games lol
22:54:36 <Null-A> just making tehm
22:54:40 <RyanT5000> yeah, i stopped playing games a while ago
22:54:42 <phildarnowsky> RyanT5000: what part of Boston are you in?
22:54:49 <RyanT5000> phildarnowsky: Dorchester
22:55:15 <danharaj> Wait Pierce wrote a category theory book?
22:55:19 <danharaj> Is it grood?
22:57:03 <copumpkin> I haven't heard great things about it
22:57:18 <copumpkin> I doubt it's bad though
22:57:51 * hackagebot haskell-cnc 0.1.1 - Library for parallel programming in the Intel Concurrent Collections paradigm.  http://hackage.haskell.org/package/haskell-cnc-0.1.1 (RyanNewton)
22:59:56 <pastorn> RyanT5000: i'm too scared to run my cleaned up code :/
23:00:07 <RyanT5000> pastorn: lol
23:00:23 <RyanT5000> i'm sure it'll be fine :)
23:02:37 <pastorn> haha... my log of state modifying messages (user added shortcuts etc.) is "PRIVMSG  :PRIVMSG  :"
23:03:01 <pastorn> i'd say something's amiss...
23:03:11 <pastorn> but that's just me...
23:03:14 <RyanT5000> lol
23:04:04 <pastorn> should be ":pastorn!~alexander@aoeu.csbnet.se PRIVMSG #bottest :.add lol lulz \n\r .time add motuwefr 9-16 th 830-1800 sasu - : Pizza place \n\r"
23:04:23 <pastorn> whoops... user info on the second there as well...
23:04:28 * pastorn goes hunting
23:08:09 <djahandarie> Who here drinks coffee?
23:08:59 * BMeph raises his mug
23:09:14 <RyanT5000> djahandarie: almost exclusively :)
23:09:43 * pikhq raises mug
23:09:49 <Cale> I have a big cappuccino with 2 cups of espresso in it every morning.
23:09:59 <pikhq> djahandarie: It is one of the holy beverages.
23:10:14 <pikhq> Alongside tea, Mountain Dew, Dr. Pepper, and root beer.
23:10:17 <djahandarie> Because I just had some after a 2-3 year streak of not having any, and I was able to focus on what I was doing very well.
23:10:43 <RyanT5000> djahandarie: in my experience, coffee does not improve focus; only alertness
23:11:06 <RyanT5000> and "my experience" includes some fairly long periods of low- to no-sleep
23:11:40 <pikhq> In my experience, coffee can at most make it less likely that you'll collapse if you're actually sleep-deprived.
23:11:43 <RyanT5000> if you want help with focus, you need other things; some of the stuff in Red Bull is useful
23:12:02 <pikhq> This is not to say, however, that coffee is pointless. Far from it: coffee is delicious.
23:12:22 <RyanT5000> L-Tyrosine is also useful, though i haven't encountered it in any form that isn't ridiculously disgusting :P
23:12:29 <pikhq> It also makes it a bit easier to get started i' the morn'.
23:12:58 * pikhq is not one for getting up anti-meridian.
23:13:29 <phildarnowsky> FINALLY.  My configuration was all kinds of screwed but I got the library I wanted working.  Thanks all for the help!
23:13:38 <phildarnowsky> Now if I could just remember what I wanted to do in the first place.
23:14:00 <pastorn> djahandarie: my mom made me use caffeine pills
23:14:14 <pastorn> *much* cheaper than coffee
23:14:50 <tab> red bull in the morning is a good way to start the morning too :)
23:15:34 <pikhq> pastorn: But that has 0 flavor.
23:15:39 <djahandarie> I'm usually against using any chemicals enough to affect how I act.
23:16:11 <phildarnowsky> djahandarie: Caffeine is a surprisingly powerful drug.  Most Americans don't realize this because they have a massive tolerance for it.
23:16:37 <pastorn> pikhq: do i look like someone who cares?
23:16:38 <BMeph> Is there some well-known process for how strict/eager programmers add lazy annotations to values?
23:16:52 <pikhq> phildarnowsky: It's also hard to take it in dangerous quantities.
23:17:05 <pastorn> pikhq: actually it tastes like shit unless you swallow it quickly
23:17:14 <pikhq> (not to say that you can't; it's just tricky.)
23:17:18 <pikhq> pastorn: I disagree.
23:17:33 <phildarnowsky> pikhq: well, define "dangerous." chronic sleep deprivation is dangerous, and also very common.
23:17:38 <phildarnowsky> (says the man up at 2:15 in the morning)
23:17:47 <pastorn> if you place a caffeine pill on your tounge and leave it there for > 1 minute you won't like it
23:17:49 <pastorn> i guarantee
23:18:00 <pikhq> pastorn: Oh, caffeine pill.
23:18:07 <pikhq> pastorn: Yes, that *will* taste like shit.
23:18:15 <pikhq> Caffeine is pure bitter.
23:18:26 <hotaru2k3> if you take pure sugar and put it on your tongue for a minute it won't taste very good either
23:19:20 <pikhq> phildarnowsky: The drug itself does not generally have dangerous effects.
23:19:34 <pastorn> hotaru2k3: i must visit my kitchen now
23:19:42 <pikhq> That said, obviously if you use it to keep slogging through day after day while sleep deprived, you're screwing yourself.
23:19:43 <pastorn> this sounds very intriguing
23:19:58 <p_l> phildarnowsky: sleep deprivation gives the best hallucination ever, though
23:20:17 <phildarnowsky> p_I: oh, I know. :)
23:20:29 <p_l> :3
23:20:32 <RyanT5000> pikhq: the deadly dose (LD50) of caffeine is estimated to be 150-200mg/kg
23:20:58 * p_l recalls the rather weird case where it took him few minutes before he managed to convince himself as to reality he was in.
23:20:59 <RyanT5000> while that is quite a lot, i wouldn't say that qualifies as not having dangerous effects
23:21:01 <pikhq> RyanT5000: Yeah, that's pretty damned hard to pull off without trying.
23:21:08 <pikhq> Which was my point.
23:21:08 <RyanT5000> pikhq: agreed
23:21:22 <p_l> something like 50 espressos in one go?
23:21:33 <RyanT5000> i got very sick once when i took about 20 Penguin Mints in a short span :P
23:21:38 <mwotton> p_l: ever tried polyphasic sleep?
23:21:45 <mwotton> you get some wicked crazy dreams
23:21:55 <pikhq> RyanT5000: Yes, that's about where medical treatment becomes a decent idea.
23:22:01 <RyanT5000> (which is, according to Penguin, about 7 cups of coffee)
23:22:08 <pikhq> Oh, wait.
23:22:09 <RyanT5000> haha yeah
23:22:13 <RyanT5000> i mostly got very tired
23:22:14 <pikhq> Double that.
23:22:16 <RyanT5000> and sick to my stomach
23:22:41 <pikhq> That's about the point where you stop wanting to take any more caffeine.
23:22:50 <mwotton> RyanT5000: I did it for a month and a half. it's pretty awesome once you get past the hump
23:23:01 <pikhq> Not you're-going-to-get-arrythmia bit.
23:23:16 <p_l> mwotton: didn't have a schedule to fit
23:23:30 <p_l> mwotton: though my sleep disorder gets similar sometimes
23:23:31 <mwotton> but taking naps at parties and trying to work out what to do at 4am is weird.
23:23:50 <RyanT5000> haha
23:23:54 <RyanT5000> yeah, i'd like to try that kind of schedule
23:24:02 <p_l> try 36/12 schedule ... it was ... weird
23:24:31 <p_l> (36h up... 12h sleep... shit happens)
23:24:56 <RyanT5000> i did 26-hour days for a week; that was easy and useful
23:25:00 <RyanT5000> i slept 8 hours out of 26
23:25:25 <RyanT5000> it has a period of 7 days, which is helpful, because that means it can sync (with some difficulty) to a weekly schedule
23:25:38 <pikhq> mwotton: 4am? I've done that on a fairly normal 8-hour sleep cycle!
23:25:43 <RyanT5000> (i'd recommend it for students if they can get their classes to line up)
23:25:48 <pikhq> (Okay, I *might* just have a sleeping disorder)
23:26:16 <p_l> I *do* have a sleeping disorder
23:26:20 <RyanT5000> "disorder" is in the eye of the beholder :)
23:26:26 <p_l> I just don't have money to pay for full diagnosis :D
23:26:40 <p_l> not sure if NHS even covers me at all
23:27:01 <pikhq> RyanT5000: I'd say "having severe difficulty getting up before noon" may count.
23:27:27 <RyanT5000> could be - unless you value the ability to stay up very late more highly than you value the inability to get up early
23:27:28 <pikhq> (and having severe difficulty going to bed early enough to make getting up before noon feasible)
23:28:12 <phildarnowsky> I've read that your "chronotype" (i.e. the hours that you naturally feel inclined to sleep) is largely genetic, so if you're a night person, you're pretty well screwed unless you can find a job that'll accommodate that.
23:28:16 <phildarnowsky> Like programming. :)
23:28:30 <pikhq> phildarnowsky: :)
23:31:34 <p_l> phildarnowsky: well, the chronotype is true, but can be moved. And in absence of easily-accessible light, our sleeping pattern is much more different
23:32:03 <p_l> that is, without electric lights, you'd wake up few times during the night, but go to bed earlier
23:32:33 <phildarnowsky> p_I: true.  and there's a separate disorder, delayed sleep phase syndrome, which is actually more like what I described--inability to shift your hours.  that's the case where you're really screwed unless you can find nightwork.
23:33:49 <machine3> what is nightwork?
23:33:50 <pikhq> p_l: Hmm. People actually go to bed just because the light's out?
23:34:19 <hotaru2k3> and then there are people like me... most of the time i cannot fall asleep unless the sun is shining on my face
23:34:39 <pikhq> My experience includes laying in bed staring at the ceiling for hours.
23:34:41 <machine3> or you go to sleep in the morning when the sun rises
23:34:52 <phildarnowsky> machine3: work that you can do at night. or at least starting at a reasonable hour, like 1 PM.
23:35:08 <machine3> all work is nightwork/daywork lol
23:35:29 <phildarnowsky> machine3: try farming at night, see how you do. :)
23:36:03 <machine3> well actually i do germinate the seeds at night and use artifical lights to sprout
23:36:20 <pastorn> @djinn Maybe [a] -> [a]
23:36:20 <lambdabot> Error: Undefined type []
23:36:36 <pastorn> @djinn Maybe [Int] -> [Int]
23:36:36 <lambdabot> Error: Undefined type []
23:36:38 <phildarnowsky> pikhq: I think he's talking about pre-industrial cultures.  like in medieval times, people would go to bed at sunset, but then they would wake up around 2 or 3 and talk or pray or have sex or whatnot, then doze a little until dawn
23:36:39 <pastorn> cool
23:36:50 <p_l> pikhq: because you are used to artificial light
23:36:52 <phildarnowsky> machine3: foiled! uhhhhh, being a solar panel?
23:37:04 <p_l> phildarnowsky: actually it's related to electric lightning
23:37:12 <phildarnowsky> p_I: that's what I meant
23:37:27 <phildarnowsky> "pre-industrial" meaning "pre-artificial-light"
23:37:30 <p_l> because before that, even with gas lamps, we didn't have it viable enough
23:37:45 <pikhq> p_l: That's why I spend at least an hour in bed before I can actually sleep?
23:37:50 <phildarnowsky> having never seen a working gas lamp, I will take your word.
23:38:03 <kmc> in some climates it's highly advantageous to sleep during the day
23:38:09 <p_l> kmc: Spain? :D
23:38:11 <machine3> i dont know why i am in this channel. i dont know the language, but i am interested in
23:38:27 <RyanT5000> machine3: you should learn it :)
23:38:27 <p_l> Spain, aka the country where everything stops around noon
23:38:28 <machine3> maybe i will stay with php
23:38:28 <djahandarie> Is there a nice guide out there relating to setting up a cabal file for your code?
23:38:29 <RyanT5000> @where lyah
23:38:29 <lambdabot> http://www.learnyouahaskell.com/
23:39:07 <c_wraith> djahandarie, with an recent-enough version of cabal, you can just use the cabal init command
23:39:18 <phildarnowsky> awright, I'm going to bed, speaking of which.  my girlfriend has been asleep for 4 hours.  she's the normal one.  good night, all.
23:39:29 <machine3> are there any cool open source cms projects written on haskel?
23:39:33 <RyanT5000> goodnight
23:39:44 <djahandarie> c_wraith, apparently mine is not recent-enough. :-(
23:39:50 <machine3> hey ryan
23:39:51 <c_wraith> then upgrade!
23:39:53 <RyanT5000> machine3: i'm not sure, but you could begin by taking a look at HAppStack
23:40:01 <machine3> ok
23:40:15 <RyanT5000> it's a lower-level thing than a CMS
23:40:19 <djahandarie> machine3, it'd be best to get a little familiar with the syntax before diving into anything major like that, I'd suggest.
23:40:24 <p_l> machine3: web apps seem not to be oft-written in Haskell (unlike CL, where there's a lot of traffic regarding webapp dev.)
23:40:47 <RyanT5000> machine3: yes, what djahandarie said
23:40:52 <djahandarie> c_wraith, I don't think the Debian repos have an up-to-date-enough version.
23:41:16 <c_wraith> oh.  yeah.  They don't keep up-to-date with anything, so I just install ghc and cabal by hand.
23:41:23 <djahandarie> Heh.
23:41:47 <djahandarie> I'm always afraid to step outside my package manager because I often forget to take some critical step and things end up being duplicated/overwritten.
23:42:18 <djahandarie> It'd be nice if someone maintained an up-to-date apt repository of Haskell stuff.
23:42:35 <RyanT5000> djahandarie: have you tried using checkinstall?
23:42:48 <RyanT5000> (not sure if that's relevant to your problem)
23:43:06 <djahandarie> I haven't, it looks related.
23:45:06 * hackagebot haskell-cnc 0.1.2 - Library for parallel programming in the Intel Concurrent Collections paradigm.  http://hackage.haskell.org/package/haskell-cnc-0.1.2 (RyanNewton)
23:53:36 <chittoor> hola!
