00:00:13 <Damien> well thats what i was trying to get at
00:00:22 <Damien> like what language and what game engine
00:00:27 <pikhq> Damien: What you need is not "deep" but "broad".
00:00:31 <Damien> guess i gotta pay someone to show me
00:00:54 <Pseudonym> Damien, you might be better off buying a book, if you want to spend money.
00:00:57 <jimbo1> Damien: What you should do is find a simple "Learn C++ in 3 weeks" book or something
00:01:04 <jimbo1> Learn the basics of good programming
00:01:19 <jimbo1> Not necessarily C++, but many people being with that
00:01:27 <DigitalKiwi> jimbo1: nobody, not even Damien, deserves a learn X in Y weeks book!
00:01:31 <jimbo1> haha
00:01:34 <Damien> guess im gonna be a new haskler
00:01:37 <Damien> yay me
00:01:42 <Damien> think i can do it
00:01:46 <Damien> give me like 4 days
00:01:53 <pikhq> DigitalKiwi: Not even Learn Haskell in 5200 weeks?
00:02:02 <mreh> is this some kind of clever joke?
00:02:06 <Damien> mm hmm
00:02:19 <jimbo1> Well the point is to familiarize yourself with good programming skills and then see if you can incorporate new fields of interest into what you can already do
00:02:22 <jimbo1> baby steps
00:02:26 <DigitalKiwi> pikhq: i can't afford that much paper/bandwidth!
00:02:35 <blackdog> jimbo1: and you're suggesting C++ :)
00:03:00 <pikhq> DigitalKiwi: Sure you can. Most of the book is "Now, open Emacs and code some more." :P
00:03:03 <jimbo1> No, not suggesting.  It will make learning Haskell MUCH more difficult.  Just saying that many beginners start there.
00:03:17 <jimbo1> I started with C.  Not that I'm a "good" programmer.
00:03:21 <Damien> haskell wouldnt be a good start then?
00:03:28 <Damien> i learn quick for real
00:03:32 <DigitalKiwi> "this page intentionallly left blank \ p.s. Go code something!"
00:03:57 <Damien> should i try?
00:04:02 <SColes> of course
00:04:09 <DigitalKiwi> those IBM manuals
00:04:10 <Damien> what the link
00:04:16 <jimbo1> Haskell is very cool and interesting.  However, the major difference between C/C++ and Haskell is that Haskell is not imperative.  It is functional.  Do you know what that means?
00:04:18 <DigitalKiwi> does anyone know why they were left blank?
00:04:24 <jimbo1> It's a DIFFERENT way of thinking.
00:04:33 <jimbo1> Not easier or harder or better or worse.  Just different.
00:04:40 <Grey_Fox> it's totally better :p
00:04:43 <jimbo1> Haha
00:04:52 <DigitalKiwi> twss
00:04:56 <Pseudonym> Learning Haskell makes your C++ better.
00:05:09 <jimbo1> That is definitely true Pseudo
00:05:09 <pikhq> And makes template metaprogramming possible.
00:05:09 <ski> (jimbo1 : jfyi, someone claimed yesterday here "Haskell is imperative" :)
00:05:10 <Grey_Fox> You know, unless you have to deal with large amount of state.
00:05:13 <DigitalKiwi> what if i want my C++ to die!?
00:05:20 <jimbo1> ski: LOL
00:05:22 <Damien> is there a download
00:05:32 <pikhq> Damien: Several downloads exist.
00:05:56 <Damien> ..
00:06:00 <pikhq> Some of them are even relevant.
00:06:09 <Damien> under what
00:06:11 <DigitalKiwi> @where download
00:06:11 <lambdabot> I know nothing about download.
00:06:12 <Damien> where r they
00:06:16 <DigitalKiwi> bah
00:06:20 <blackdog> http://hackage.haskell.org/platform/
00:06:49 <Damien> .org :D
00:07:18 <Damien> thx
00:08:08 <blackdog> kfish: i like your server parties piece:)
00:12:38 <Damien> linux is crazy
00:14:41 <Damien> damn im getting an error
00:14:55 <Damien> http://davidsiegel.org/haskell-platform-in-karmic-koala/
00:15:10 <Damien> got to the ./configure
00:16:21 <Damien> saying ghc isnt found
00:16:59 <glguy> Damien: sounds like you'll want to ask #ubuntu for help installing packages.
00:17:09 <glguy> They'll know the specific commands and tools to use
00:18:12 <ski> cdsmithus : (oh, you attributed me like `@ski: ' .. i wouldn't have seen that if i didn't look at the scrollback) yes, but i'm suspecting you can't safely replace `g -> g x' with `x' .. only the other way around
00:18:28 <Damien> i got em
00:19:13 <Damien> yepp its goin
00:19:30 <Damien> i typed it instead of copying
00:23:35 <deteego> does anyone know if there are ways to go around cyclic modules?
00:23:49 <mornfall> Ideally, don't create cycles in modules. :)
00:23:58 <mornfall> It's bad design.
00:25:05 <siracusa> Where is if' defined?
00:25:07 <mornfall> There's something with SOURCE pragma if you really have to. http://www.haskell.org/ghc/docs/6.10-latest/html/users_guide/separate-compilation.html#mutual-recursion
00:26:10 <deteego> ewww, having to create hs.boot files
00:26:20 <deteego> seems kinda ugly
00:27:34 <jimbo1> Ugh, ^ vs ^^ vs **
00:27:49 <jimbo1> Why does this give me an error: 2 ^ (amt/12)
00:27:53 <jimbo1> amt is an Int
00:27:58 <jimbo1> sorry Integer
00:28:02 <ski> `amt/12' is an error, then
00:28:12 <ski> `div' is integral (truncating) division
00:28:39 <ski> > let amt :: Int; amt = 14 in amt / 12
00:28:40 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
00:28:40 <lambdabot>    arising from a use o...
00:28:44 <ski> > let amt :: Int; amt = 14 in amt `div` 12
00:28:44 <lambdabot>   1
00:28:52 <ski> > let amt :: Int; amt = 14 in fromIntegral amt / 12
00:28:53 <lambdabot>   1.1666666666666667
00:28:56 <jimbo1> No that's not what I want
00:29:04 <jimbo1> I want the /
00:29:10 <jimbo1> I need the floating point
00:29:18 <mornfall> deteego: It's good that it's ugly.
00:29:25 <ski> then convert the `Int' to a floating point, by `fromIntegral'
00:29:26 <mornfall> At least people think twice.
00:29:31 <jimbo1> oh, so I need to use fromIntegral on the Integer
00:29:39 <ski> jimbo1 : also, you'll probably want `**', instead of `^', in this case
00:29:39 <jimbo1> Yes, you said it before I could
00:29:41 <deteego> mornfall: more annoying then ugly
00:29:46 <deteego> mornfall: have to maintain 2 files
00:29:51 <jimbo1> Right, ski, I was just thinking that
00:30:03 <mornfall> deteego: Well, you didn't say why you need an import loop.
00:30:04 <ski> since `**' is floating exponentiation
00:30:14 <mornfall> deteego: And I claim that in 98% of cases it's a design bug.
00:30:25 <wli> There's also (^^)
00:30:38 <jimbo1> ski: it still gives me trouble
00:30:46 <jimbo1> (fromIntegral amt)/12
00:30:49 <ski> `(^)' is for natural exponents, and `(^^)' is for integral exponents
00:30:51 <ski> wli :)
00:30:58 <jimbo1> No instance for (Fractional Integer)       arising from a use of `/' at
00:31:14 <jimbo1> did I still do it wrong? :|
00:31:51 <ski> jimbo1 : you still are using an `Integer' somewhere in your expression
00:32:11 <ski> what is your current expression ?
00:32:15 <jimbo1> This is the entire expression: alpha = (fromIntegral amt)/(fromIntegral 12)
00:32:24 <jimbo1> amt is type Integer
00:32:35 <jimbo1> I just got rid of the ^ to simplify
00:32:38 <jimbo1> but STILL have the erro
00:32:44 <ski> you shouldn't need the `fromIntegral' on `12', since it is polymorphic over all types `a' in `Num'
00:32:59 <jimbo1> right, well I only put it to see if it would get rid of the error
00:33:01 <ski> the error must be elsewhere .. maybe where you use `alpha'
00:33:18 <deteego> mornfall: actually it was a design issue
00:33:27 <ski> try adding `alpha :: Double' before that line, and see what error you get
00:33:36 <jimbo1> good idea
00:33:58 <ski> (that often helps in narrowing down the error to the correct places)
00:34:00 <jimbo1> Got it!  The multiplication on the next line was expecting an Integer not a Double
00:34:08 <jimbo1> ski: you are a lifesaver
00:34:20 <ski> ok, now you can remove the type signature on `alpha' again, if you prefer
00:35:07 <dmwit> :t \f cs -> [c | c <- cs, f c cs] -- anybody have a good name for this?
00:35:08 <lambdabot> forall t. (t -> [t] -> Bool) -> [t] -> [t]
00:36:09 <noteed> dmwit: satList ?
00:36:41 <dmwit> ?pl \f cs -> filter (flip f cs) cs
00:36:41 <lambdabot> join . (filter .) . flip
00:37:31 <dmwit> huh, ?pl is pretty darn clevern
00:38:07 <noteed> dmwit: maybe you can remove the flip (and require f to have the arg flipped)
00:38:34 <dmwit> ?pl \f cs -> filter (f cs) cs
00:38:34 <lambdabot> (filter =<<)
00:38:36 <kfish> blackdog, cheers :)
00:38:42 <dmwit> Well.
00:38:55 <dmwit> That is a pretty clean implementation.
00:40:37 <dmwit> I'm going to hate myself next week, aren't I?
00:40:50 <ski> > (filter =<< (==) . length) [1,2,1,4,2,4,8,2]
00:40:50 <lambdabot>   [8]
00:40:51 <deteego> hmm wait
00:40:53 <deteego> no it isn't
00:40:54 <ski> lucid
00:40:55 <deteego> great
00:41:18 <noteed> dmwit: sure
00:41:41 <dmwit> ah, well, might as well go whole hog on the hate, then
00:41:50 <dmwit> ?pl \cs c -> any (c `isRotationOf`) cs
00:41:50 <lambdabot> flip (any . isRotationOf)
00:41:57 <dmwit> Screw you, future dmwit!
00:42:33 <Grey_Fox> what's ?pl
00:43:09 <SColes> Grey_Fox, point free style
00:43:22 <dmwit>  ?pl eliminates variables
00:43:22 <Grey_Fox> ok
00:43:25 <dmwit> ?pl \x -> f x
00:43:26 <lambdabot> f
00:43:40 <dmwit> ?pl \x y -> f x (g y)
00:43:40 <lambdabot> (. g) . f
00:43:46 <Grey_Fox> a mnemonic for "PointLess"?
00:43:54 <dmwit> ?pl \f g x -> f (g x)
00:43:54 <lambdabot> (.)
00:43:59 <dmwit> Grey_Fox: Yes, exactly.
00:44:00 <Twey> dmwit: My general rule is that if I can't generate it (and expand it) without @pl, I probably shouldn't use it :þ
00:44:26 <noteed> Twey: the future dmwit knows that
00:44:26 <dmwit> Twey: The (>>= filter) version is growing on me, though.
00:45:40 <Twey> dmwit: Sure, it's lovely, but make sure you work through how @pl got there first, or you will hate yourself next week :þ
00:51:24 <rajeshsr> can anyone help me with this code?
00:51:26 <rajeshsr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25435#a25435
00:51:40 <Quaffe> ?pl \x y -> f y x
00:51:41 <lambdabot> flip f
00:51:42 <rajeshsr> i get: sudo.hs:6:22: parse error on input `where'
00:52:22 <dmwit> rajeshsr: Your second guard doesn't have an = in it.
00:52:34 <dmwit> rajeshsr: Perhaps you meant "otherwise = if ... then ... else ..."
00:52:51 <rajeshsr> dmwit, ha, ok!!
00:52:56 <rajeshsr> thanks
00:53:02 <dmwit> rajeshsr: or "if ... then ... else ... = (undefined, undefined)"
00:53:38 <dmwit> Looks like tryVal/t/mx aren't indented the same amount, either. =)
00:53:41 <Makoryu> rajeshsr: I'd rewrite that if/then/else as two guards
00:54:03 <dmwit> oy, yes
00:54:04 <dmwit> I must be tired.
00:54:10 <rajeshsr> dmwit, how can i make the variable "mx" as accessible by all functions?
00:54:27 <rajeshsr> Makoryu, hmm, thanks for the tip.
00:54:53 <dmwit> rajeshsr: By all functions? Simple, just promote it to the top level.
00:55:46 <Makoryu> @pl \(x, y) -> x == False -- rajeshsr
00:55:46 <lambdabot> (False ==) . fst
00:55:55 <Makoryu> :t not . fst
00:55:56 <lambdabot> forall b. (Bool, b) -> Bool
00:56:22 <rajeshsr> Makoryu, ha, thats what i was thinking. I want to rewrite in a more elegant way. thank you.
00:57:22 <rajeshsr> what does @pl do actually?
00:57:52 <Makoryu> It rewrites functions to remove their explicit parameters
00:58:13 <Makoryu> The "pl" is for "pointless" because often as not, it is :p
00:59:05 <rajeshsr> Makoryu, haha! :) thanks
00:59:19 <Quaffe> I'm having trouble using the hSetEncoding on a socket handle - it works for fine for stdout.  Should hSetEncoding work on a handle from a socket?
00:59:20 <Makoryu> @pl \f x y -> (x, y f, Just (y x))
00:59:20 <lambdabot> (`ap` ((Just .) . flip id)) . (ap .) . flip ((.) . (,,)) . flip id
00:59:38 <Twey> rajeshsr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25435#a25436
01:00:38 <rajeshsr> Twey, wow! thanks! That is more elegant.
01:01:49 <rajeshsr> > map (+1) [1..10]
01:01:50 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
01:01:52 <Twey> rajeshsr: You're welcome.
01:02:01 <rajeshsr> > map (-1) [1..10]
01:02:02 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
01:02:02 <lambdabot>    arising from a use of `e_11110' a...
01:02:10 <Twey> > map (subtract 1) [1 .. 10]
01:02:12 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
01:02:12 <dmwit> :t runState
01:02:13 <rajeshsr> How do we apply sectioning for -
01:02:13 <lambdabot> forall s a. State s a -> s -> (a, s)
01:02:30 <rajeshsr> > map (1-) [1..10]
01:02:31 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
01:02:37 <rajeshsr> Twey, thanks!
01:02:44 <Twey> Try to space operators, especially ones involving dots — confusion with modules can result if you don't
01:03:04 <Makoryu> > Just.fst
01:03:06 <lambdabot>   Not in scope: `Just.fst'
01:03:07 <rajeshsr> Twey, you mean?
01:03:11 <Twey> Like that
01:03:13 <Makoryu> :t Just . fst
01:03:14 <lambdabot> forall a b. (a, b) -> Maybe a
01:04:47 <Twey> Likewise, ‘L..’ is the (.) operator from the module L
01:04:50 <Twey> :t L..
01:04:51 <lambdabot> parse error on input `L..'
01:04:53 <Twey> :t (L..)
01:04:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:05:16 <rajeshsr> Twey, ha, ok! So module names are given with no intervening "." ?
01:05:17 <rajeshsr> sorry, no intervening space..
01:05:30 <Twey> So if you have a datatype data A = L | K | M deriving Enum, and you try to use [L..M], bad things will result
01:05:33 <Twey> Yes
01:06:14 <jimbo1> oy
01:07:42 <Grey_Fox> Twey: should you write [L .. M] ?
01:07:53 <jimbo1> What is wrong with this line
01:08:00 <jimbo1> nvm
01:08:10 <Twey> Grey_Fox: Yes
01:09:00 <rajeshsr> Twey, interesting. So without spaces it is interpreted as belonging to a module?
01:09:41 <Twey> Yes
01:22:01 <rajeshsr> @pl \mp (x, y, z) -> insert (x, y) z mp
01:22:01 <lambdabot> (line 1, column 10):
01:22:01 <lambdabot> unexpected ","
01:22:01 <lambdabot> expecting letter or digit, operator or ")"
01:22:01 <lambdabot> ambiguous use of a non associative operator
01:24:29 <rajeshsr> @pl \mp (x, y, z) -> insert (x, y) z mp
01:24:30 <lambdabot> (line 1, column 10):
01:24:30 <lambdabot> unexpected ","
01:24:30 <lambdabot> expecting letter or digit, operator or ")"
01:24:30 <lambdabot> ambiguous use of a non associative operator
01:25:40 <rajeshsr> @pl (\mp (x, y, z) -> insert (x, y) z mp)
01:25:41 <lambdabot> (line 1, column 11):
01:25:41 <lambdabot> unexpected ","
01:25:41 <lambdabot> expecting letter or digit, operator or ")"
01:25:41 <lambdabot> ambiguous use of a non associative operator
01:26:01 <rajeshsr> what is wrong?
01:28:59 <rajeshsr> @src insert
01:28:59 <lambdabot> insert e ls = insertBy (compare) e ls
01:29:09 <rajeshsr> @hoogle insert
01:29:09 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
01:29:09 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
01:29:09 <lambdabot> Data.IntSet insert :: Int -> IntSet -> IntSet
01:49:23 <triyo> I installed ghc + cabal-install via apt-get on my ubuntu work pc and was faced with a very strange error: Could not find module `Control.Monad.Error'
01:49:50 <triyo> It doesnt make any sense does it since Control.Monad.Error should be part of the core install
01:52:08 <dolio> triyo: Are you sure mtl is installed?
01:52:19 <dolio> Or something equivalent.
01:52:27 <dolio> try ghc-pkg list mtl
01:53:08 <ivanm> blackdog: ta
01:53:59 <rajeshsr> @hoogle foldM
01:54:00 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
01:54:00 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
01:54:00 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
01:54:22 <triyo> dolio: response: I installed ghc + cabal-install via apt-get on my ubuntu work pc and was faced with a very strange error: Could not find module `Control.Monad.Error'
01:54:25 <triyo> oops
01:54:29 <triyo> sorry
01:54:36 <triyo> dolio: /var/lib/ghc-6.12.1/package.conf.d
01:55:23 <ivanm> well, you need either mtl or transformers for that module
01:55:24 <ivanm> probably mtl
01:55:48 <dolio> Looks like it's not there. Try installing libghc6-mtl-dev.
01:55:53 <dolio> I think that's probably the right one.
01:58:40 <rajeshsr> Can anyone help me track the compilation error in this code?
01:58:41 <rajeshsr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25443#a25443
01:59:02 <rajeshsr> it says: No instance for (Enum [Int])
01:59:02 <rajeshsr>       arising from the arithmetic sequence `0 .. 8' at sudo.hs:27:48-55
01:59:40 <triyo> dolio: thanks tha worked. Now it needs missing parsec... is there perhaps a way to install all the "batteries included" stuff in one go?
02:00:10 <dolio> I don't know. I haven't used ubuntu's packages in a long time.
02:00:20 <rajeshsr> anyone?
02:01:04 * hackagebot webserver 0.4.1 - HTTP server library  http://hackage.haskell.org/package/webserver-0.4.1 (KazuYamamoto)
02:01:19 <triyo> dolio: no worries, thanks for showing me the way to get the missing package(s) installed
02:01:33 <noteed> rajeshr: try adding explicit type signatures to pinpoint the problem
02:01:49 <jimbo1> I have something that will only accept a Maybe Int
02:01:52 <jimbo1> but I know what it is
02:01:59 <jimbo1> How can I just convert it to a Maybe
02:02:05 <jimbo1> so that this function will accept it?
02:02:32 <rajeshsr> > succ 10^11
02:02:33 <lambdabot>   285311670611
02:02:50 <rajeshsr> why is it behaving like that?!
02:02:56 <otto_s_> > 11^11
02:02:57 <lambdabot>   285311670611
02:03:05 * hackagebot mighttpd 0.4.2 - Simple Web Server in Haskell  http://hackage.haskell.org/package/mighttpd-0.4.2 (KazuYamamoto)
02:03:12 <rajeshsr> succ 10^100
02:03:22 <rajeshsr> > succ 10^100
02:03:23 <lambdabot>   137806123398222701841183371720896367762643312000384664331464775521549852095...
02:03:33 <rajeshsr> what is that?! is it a bug?
02:03:47 <rajeshsr> > succ 99
02:03:48 <lambdabot>   100
02:03:51 <rajeshsr> > succ 990
02:03:52 <noteed> rajeshr: function application has precedence before operators
02:03:52 <lambdabot>   991
02:03:54 <siracusa> > succ (10^10)
02:03:55 <lambdabot>   10000000001
02:04:25 <rajeshsr> noteed, ha, ok!
02:04:34 <dmwit> > 11^100
02:04:35 <lambdabot>   137806123398222701841183371720896367762643312000384664331464775521549852095...
02:04:49 <rajeshsr> > succ (10^100)
02:04:50 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
02:05:22 <ski> jimbo1 : `Just'
02:05:35 <jimbo1> i think I "Just" came across that
02:05:40 <ski> @type Just
02:05:41 <lambdabot> forall a. a -> Maybe a
02:05:43 <jimbo1> So I can say
02:05:55 <jimbo1> (Just x)
02:06:16 <ski> yes
02:06:51 <eevar2> > pred (10^100)
02:06:52 <lambdabot>   999999999999999999999999999999999999999999999999999999999999999999999999999...
02:07:28 <Grey_Fox> I say, that's off by one!
02:07:37 <Grey_Fox> oh, no it's not
02:08:06 <Grey_Fox> > 10^100
02:08:07 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
02:09:36 <rajeshsr> can anyone look at my pastebin code?
02:10:02 <rajeshsr> i don't really get why it says:  No instance for (Num [Int])
02:10:02 <rajeshsr>       arising from the literal `0' at sudo.hs:27:50
02:10:15 <dmwit> link?
02:10:25 <rajeshsr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25443#a25443
02:12:02 <dmwit> rajeshsr: Where do you pass in 'x'? ;-)
02:12:24 <dmwit> ignore me
02:13:08 * hackagebot ghc-mod 0.4.0 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.4.0 (KazuYamamoto)
02:13:48 <dmwit> You've got lots of extraneous (, ), and $s.
02:13:57 <dmwit> They're not causing your problem, but you should know it. =)
02:14:33 <rajeshsr> dmwit, oh! where you mean?
02:14:39 <dmwit> You'll help yourself a lot if you start giving a few things explicit types.
02:15:02 <dmwit> In particular, printAns seems like a good candidate; the type-checker can give much better error messages if it's got a few type assertions from the programmer.
02:15:17 <dmwit> forM_ [0..8] $ printRow === forM_ [0..8] printRow
02:15:32 <dmwit> foldM (process) (Data.Map.empty) $ [0..8] === foldM process Data.Map.empty [0..8]
02:15:58 <rajeshsr> dmwit, ha, ok!
02:16:05 <dmwit> I'd also suggest merging printRow and lis, e.g.
02:16:17 <dmwit> printRow x = print [ans ! (x, y) | y <- [0..8]]
02:19:14 <dmwit> rajeshsr: Comment out "main", then fire up ghci and type ":t foldM process". You might get a surprise. =)
02:22:37 <rajeshsr> dmwit, it worked! adding type signatures gave more sensible errors!!
02:22:46 <rajeshsr> the culprit was x <- i
02:22:51 <rajeshsr> x <- repeat i
02:22:56 <rajeshsr> should be there actually!!
02:23:47 <rajeshsr> dmwit, uh i meant it totally wrong! I need zip3!! :)
02:23:54 <rajeshsr> let me make the change..
02:24:06 * dmwit bets on replicate rather than zip3
02:24:37 <dmwit> I'm off to bed. Good luck!
02:27:14 <Grey_Fox> ?pl \x -> \y -> mod y x
02:27:14 <lambdabot> flip mod
02:32:39 <Grey_Fox> ?pl \x -> even x && odd x
02:32:39 <lambdabot> liftM2 (&&) even odd
02:33:14 <Botje> even x && odd x better written as const True
02:33:26 <Botje> wait, const False :P
02:46:44 <ski> (Botje : possibly s/const/flip seq/ ..)
02:51:05 <Grey_Fox>  perms x y = concatMap(\a-> zip (take (length y) (repeat a)) y) x
02:51:15 <Grey_Fox> there's a potentially useful function right?
02:51:37 <Grey_Fox> or is that defined elsewhere?
02:52:01 <Grey_Fox> does haskell provide a function that gives the cartesian product of two lists?
02:53:23 <ski> Grey_Fox : yes, it is called `liftM2 (,)'
02:53:30 <Grey_Fox> ah
02:53:36 <ski> > liftM2 (,) [0,1,2] [300,400]
02:53:36 <lambdabot>   [(0,300),(0,400),(1,300),(1,400),(2,300),(2,400)]
02:53:52 <Grey_Fox> hrmm, not defined in my implementation
02:54:01 <ski>   import Control.Monad
02:54:17 <ski> (or `:m + Control.Monad
02:54:21 <ski> ', in ghci)
02:58:45 <zygoloid> Grey_Fox: fyi, the take/length is unnecessary in your formulation. zip stops when either list runs out of elements.
02:59:06 <zygoloid> > let perms x y = concatMap (\a -> zip (repeat a) y) x in perms [1,2,3] [4,5]
02:59:07 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
02:59:28 <zygoloid> (plus it's lazier this way!)
03:00:21 <ivanm> preflex: seen bos
03:00:21 <preflex>  bos was last seen on #haskell 4 days, 5 hours, 32 minutes and 50 seconds ago, saying: And LLVM.
03:01:18 <zygoloid> Grey_Fox: also, zip (repeat a) b = map ((,) a) b
03:08:54 <Grey_Fox> cheers
03:09:01 <Grey_Fox> I'm still a bit of a haskell newbie
03:09:39 <zygoloid> another way of writing the same thing: perms xs ys = [(x,y) | x <- xs, y <- ys]
03:10:43 <zygoloid> you can use 'sequence' as a generalization of this for a list of lists:
03:10:51 <zygoloid> > sequence [[1,2],[3,4,5],[6,7]]
03:10:52 <lambdabot>   [[1,3,6],[1,3,7],[1,4,6],[1,4,7],[1,5,6],[1,5,7],[2,3,6],[2,3,7],[2,4,6],[2...
03:12:03 <Grey_Fox> it's a bit like unix isn't it? When you get to the point of writing a function, it's already there, or at least implementable with an elegant interface that you haven't heard of.
03:13:24 <Saizan> @quote true.haskell
03:13:24 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
03:16:20 <Grey_Fox> how long does that take?
03:16:27 <Grey_Fox> to know what you;re doing?
03:28:08 <ivanm> with a Set, I want to specify when doing an insertion or a union that if two values have the same constructor (I have a function that tests this) then to only use the second one; is this possible?
03:28:39 <Taejo> :t insertWith
03:28:40 <lambdabot> Not in scope: `insertWith'
03:28:41 <ivanm> or would my best bet be to use a newtype with Eq defined as being this same-constructor-equality function?
03:28:55 <ivanm> Data.Set doesn't seem to have such a function
03:29:34 <Taejo> ivanm: so you want, say, (Left 3) to overwrite (Left 7)?
03:29:41 <ivanm> yes
03:29:46 <benmachine> ivanm: it wouldn't be Eq, it'd be Ord, I think
03:29:49 <ivanm> this is for a specific datatype though
03:30:03 <ivanm> benmachine: well, whatever
03:30:08 <Taejo> you need a newtype with a new Eq instance, and a compatible Ord, yes
03:30:20 <ivanm> *sigh* looks like I'm doing that then...
03:31:03 <benmachine> anything else would make it quite easy to break Set invariants
03:31:09 <benmachine> but then I guess that's already quite easy
03:35:57 <ivanm> @type \ f g -> f `on` g
03:35:57 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:36:07 <mreh_> :t on
03:36:08 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:36:17 <ivanm> > succ `on` fst (1,'a') (b, 'c')
03:36:17 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> c
03:36:22 <ivanm> > succ `on` fst (1,'a') (2, 'c')
03:36:23 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> c
03:36:36 <ivanm> > (succ `on` fst) (1,'a') (2, 'c')
03:36:36 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> c
03:36:44 <ivanm> duh
03:36:49 <ivanm> > (*) `on` fst (1,'a') (2, 'c')
03:36:49 <lambdabot>   Ambiguous type variable `t' in the constraint:
03:36:50 <lambdabot>    `GHC.Num.Num t' arising f...
03:36:55 <ivanm> > ((*) `on` fst) (1,'a') (2, 'c')
03:36:55 <lambdabot>   2
03:36:58 <mreh_> whoever though of arrow notation is great
03:37:51 <ivanm> @tell Baughn haskell-indent doesn't seem to like guards when defining class instances
03:37:51 <lambdabot> Consider it noted.
03:37:52 <mreh_> > on (*) fst (1, 'a') (2, 'b')
03:37:53 <lambdabot>   2
03:38:05 <Baughn> @clear
03:38:05 <lambdabot> Messages cleared.
03:38:13 <mreh_> > (*) `on` fst $ (1, 'a') (2, 'b')
03:38:13 <ivanm> oh, you're here ;-)
03:38:14 <lambdabot>   Precedence parsing error
03:38:14 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
03:38:18 <Baughn> ivanm: I'm always here.
03:38:21 <Baughn> Except when I'm not.
03:38:24 <ivanm> heh
03:38:31 <ivanm> wow, strange that...
03:38:58 <mreh_> on is screaming out for generalisation... lists?
03:39:12 <mreh_> compose with fold?
03:39:43 <ivanm> why does it need generalisation?
03:40:03 <ivanm> @type \ f -> groupBy ((==) `on` f) . sortBy (compare `on` f)
03:40:04 <lambdabot> forall b a. (Ord b) => (a -> b) -> [a] -> [[a]]
03:40:25 <mreh_> compare `on` f is my favourite idiom
03:43:50 <zygoloid> mreh_: comparing?
03:44:04 <mreh_> :t comparing
03:44:05 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
03:44:11 <zygoloid> @type (compare `on`)
03:44:12 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
03:44:25 <mreh_> didn't know that one
03:44:32 <zygoloid> @type \f -> groupBy ((==) `on` f) . sortBy (comparing f)
03:44:33 <lambdabot> forall b a. (Ord b) => (a -> b) -> [a] -> [[a]]
03:46:58 <zygoloid> @let sortOn = sortBy . comparing; groupOn f = ((==) `on` f)
03:46:59 <lambdabot>  Defined.
03:47:34 <dolio> betaEq = alphaEq `on` normalize
03:49:15 <benmachine> :t map fst . sortBy (comparing snd) . map . (id &&&)
03:49:16 <lambdabot>     Couldn't match expected type `[(a, b)]'
03:49:16 <lambdabot>            against inferred type `[a1] -> [b1]'
03:49:16 <lambdabot>     In the first argument of `(.)', namely `map'
03:49:19 <benmachine> aw
03:49:22 <baaba> :t sortOn >>> groupOn
03:49:22 <lambdabot> forall a a1. (Ord a1, Eq a) => (a -> a1) -> [[a]] -> [[[a]]]
03:49:36 <benmachine> :t map fst . sortBy (comparing snd) . (map .) . (id &&&)
03:49:37 <lambdabot>     Couldn't match expected type `(a, b)'
03:49:37 <lambdabot>            against inferred type `[a1] -> [b1]'
03:49:37 <lambdabot>     In the first argument of `(.)', namely `map'
03:49:40 <benmachine> fff
03:49:48 <benmachine> :t \f -> map fst . sortBy (comparing snd) . map (id &&& f)
03:49:49 <lambdabot> forall b a. (Ord b) => (a -> b) -> [a] -> [a]
03:49:57 <benmachine> @pl \f -> map fst . sortBy (comparing snd) . map (id &&& f)
03:49:58 <lambdabot> ((map fst . sortBy (comparing snd)) .) . map . (id &&&)
03:50:16 <zygoloid> @type flip groupOn <=< flip sortOn
03:50:17 <lambdabot> forall a b. (Ord b) => [a] -> (a -> b) -> [[a]]
03:50:50 <zygoloid> @type flip (flip groupOn <=< flip sortOn)
03:50:52 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [[a]]
04:06:53 <benmachine> preflex: if anyone asks after me, I'm doing revision and should be back in ~2 weeks
04:07:56 <DigitalKiwi> preflex: seen benmachine
04:07:57 <preflex>  benmachine was last seen on #haskell 1 minute and 3 seconds ago, saying: preflex: if anyone asks after me, I'm doing revision and should be back in ~2 weeks
04:08:14 <chrisdone> so i've been thinking about monad transformers all week, and i'm beginning to think they are really not very useful or desirable
04:08:30 <soupdragon> I found them useful a couple of times though
04:09:10 <soupdragon> I mean it's basically a quick way to implement a new monad?
04:09:21 <Saizan> yeah
04:09:21 <Zao> soupdragon: They're ways to nest monads.
04:09:37 <soupdragon> that sounds complicated Zao
04:10:37 <Zao> soupdragon: Say you want State, but you also want IO.
04:10:39 <quicksilver> it's not a very interesting kind of nesting
04:10:42 <Zao> StateT IO ().
04:10:46 <quicksilver> Zao: soupdragon knows how they work.
04:10:52 <Zao> quicksilver: Oh well, I just woke up.
04:11:00 <Zao> Reading up is bothersome, as then I have to lift my head :D
04:11:05 <soupdragon> quicksilver: That is a little bit generous to say :P
04:11:09 <quicksilver> They're useful recipes for stitching together standard pieces.
04:11:15 <fasta> chrisdone, they clearly have a use.
04:11:18 <Zao> On IRC, assume everyone are simpletons. Things become much easier then :D
04:11:43 <quicksilver> the typeclasses are good for abstraction
04:12:10 <quicksilver> MonadState m s, MonadIO m => m a  is a better type signature than StateT s IO a
04:12:20 <Saizan> quicksilver: weren't typeclasses only for overloading?;P
04:12:29 <chrisdone> you have a data type a which is an instance of the class Monad, and this is the parent monad, and another one which runs inside it, and then you have a class with one method `lift' for running parent actions within the child monad's actions
04:12:37 <Zao> quicksilver: Ah yes. I was outlining the "traditional" transformers.
04:12:44 <quicksilver> Saizan: yes, and this is overloading.
04:12:50 <chrisdone> the trouble is the number of times of use, speed and flexibility limitations of `lift'
04:14:32 <chrisdone> typeclasses are awesome because: you have a few methods to implement, and *then* from that you get a whole host of functions which were implemented in terms of them (the Monad class is the perfect example)
04:14:53 <chrisdone> but monad transformers seems like a different direction
04:15:11 <chrisdone> i'd rather implement one measily method than write lift everywhere
04:15:27 <chrisdone> (and juggle problems with embedding)
04:16:21 <Saizan> if you end up writing lift everywhere you're arguably doing it wrong
04:18:19 <quicksilver> chrisdone: I never, ever, use lift.
04:18:34 <Saizan> monads (and transformers) are best used to build up a tiny EDSL tailored to what you want to write, which works as the API the rest of the code uses
04:18:34 <quicksilver> if you use lift you're definitely using the state transformers in the way I consider wrong, at least :)
04:19:07 <quicksilver> either use the methods in MonadState (et al.) or even better write a set of more specific primitives of your own
04:19:08 <chrisdone> i'm not personally using the state transformers but w/e i'm irrelevant
04:21:02 <dolio> It is true that the MonadTrans class isn't that great.
04:21:41 <chrisdone> quicksilver: yeah the MonadState et al way is a lot better
04:21:56 <dolio> Although it lets you write a lot of the other stuff as 'return = lift . return ; put = lift . put ; get = lift get ...'
04:22:54 <chrisdone> what's the speed hit for transformers?
04:23:26 <chrisdone> i saw something ages ago about there being a speed penalty
04:23:28 * chrisdone googles
04:23:57 <quicksilver> chrisdone: they aren't very fast, it's true
04:24:05 <quicksilver> although to quantify the 'speed hit' you'd have to know what to compare it to :)
04:24:28 <quicksilver> it's arguably a GHC compilation flaw rather than a real design flaw
04:24:54 <quicksilver> I've not worked on code where the overhead of my monad stack was the dominating problem.
04:24:58 <chrisdone> i suppose but it's a flaw at the end of the day
04:25:03 <chrisdone> i see
04:25:36 <quicksilver> if you change them to CPS form it speeds up by about 30%, anecdotally
04:25:45 <quicksilver> which, again anecdotally, is a common pattern with CPS
04:25:55 <chrisdone> sure
04:25:59 <quicksilver> a CPS transform has a similar effect to unboxing the tuples
04:30:28 <chrisdone> http://hackage.haskell.org/packages/archive/cgi/3001.1.5.2/doc/html/src/Network-CGI-Monad.html#MonadCGI
04:30:30 <chrisdone> i like this class
04:31:29 <chrisdone> doing a pure implementation of CGI is appealing to me
04:36:07 <chrisdone> what's a good doc to start on type families/type functions/associated types/etc/etc
04:36:29 <chrisdone> i'm not sure what the proper name is as i've seen several
04:36:50 <quicksilver> I'm not convinced there are any really good places :)
04:36:59 <quicksilver> there is somethign on the GHC wiki iirc
04:37:11 <quicksilver> http://www.haskell.org/haskellwiki/GHC/Indexed_types
04:37:22 <quicksilver> ^^ is a good place to start although I'm not sure it's entirely up to date
04:37:47 <chrisdone> indexed types, another name! haha. thanks
04:38:07 <quicksilver> chrisdone: (re MonadCGI) - yes, I did a B*Tree implementation as an abstract class so I could write a pure implementation against a ByteString state monad as well as an IO one against a file
04:38:17 <quicksilver> chrisdone: it's nice to have a pure version for testing etc.
04:39:02 <kolektiv> hi all, i have a very basic and i'm sure dumb question
04:39:20 <kolektiv> i'm working through the jonathan tang scheme interpreter in haskell article
04:39:32 <chrisdone> quicksilver: right! running CGI functions inside GHCi I imagine is very nice. do you think it's meaningful to apply QuickCheck to CGI code?
04:39:43 <quicksilver> if you have a way to run it purely, then sure
04:40:22 <kolektiv> does anyone know why this code: http://gist.github.com/397207 runs out of sequence?
04:40:44 <kolektiv> by which i mean, nothing happens until you type a name, then both putStrLns are executed
04:40:54 <chrisdone> output buffering?
04:41:43 <Feuerbach> kolektiv: works fine here
04:41:54 <Feuerbach> (under Linux)
04:42:03 <nus> kolektiv, what platform is this?
04:42:08 <kolektiv> Feuerbach: prompts for your name and then says hello once you've answered?
04:42:15 <kolektiv> nus: ghc on windows
04:42:19 <Feuerbach> kolektiv: exactly
04:42:29 <nus> kolektiv, ghc version?
04:42:51 <kolektiv> 6.12.1
04:43:03 <fasta> chrisdone, type families are still pretty fragile, AFAIK.
04:43:16 <kolektiv> running the exe in a zsh shell under cygwin...
04:43:23 <nus> oh my
04:43:35 <kolektiv> i wonder if it's en env thing - odd readline or something...
04:44:17 <kolektiv> i think i'd better try it on a different platform!
04:44:20 <chrisdone> kolektiv: maybe try: hSetBuffering NoBuffering --?
04:44:25 <chrisdone> woops
04:44:33 <chrisdone> kolektiv: hSetBuffering stdout NoBuffering
04:44:38 <MarcWeber> Any ideas what pandoc is missing here? http://dpaste.com/193177/
04:44:55 <kolektiv> chrisdone: i'll try when i've worked out what that means :)
04:44:56 <MarcWeber> "Setup: Package pandoc-1.5.1.1 can't be built on this system." is not very descriptive
04:44:56 <chrisdone> good grief
04:45:31 * kolektiv is still very much a haskell newbie (well, haven't touched for years)
04:45:41 <chrisdone> kolektiv: I don't really know about this topic but I recall there being strange buffering where reading in input flushes the output buffer, or maybe I'm imagining it
04:46:00 <kolektiv> chrisdone: that would certainly fit the symptoms
04:46:02 <chrisdone> [on some shells]
04:46:21 <kolektiv> yes, i imagine zsh+cygwin+win7 hasn't had much testing either!
04:46:36 <nus> cygwin 1.7 had some
04:46:48 <chrisdone> you deal with this kind of mess in c all the time. it's easy to forget that io and buffering is complicated
04:47:02 <kolektiv> chrisdone: true, good points
04:47:39 <kolektiv> aha. works perfectly in a simple windows cmd window
04:47:45 <kolektiv> shell/environment it is!
04:47:52 <chrisdone> i wonder why it does that
04:47:53 <kolektiv> that's... annoying
04:48:12 <kolektiv> as i'm in zsh a lot, and if i can't trust it when coding...
04:48:28 <mux> :t foldr (<|>) empty
04:48:29 <lambdabot>     Ambiguous occurrence `empty'
04:48:30 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
04:48:30 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
04:48:53 <mux> @hoogle Alternative f => [f a] -> f a
04:48:54 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
04:48:54 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
04:48:54 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
04:50:12 <mux> > asum [Nothing, Nothing, Just 1]
04:50:14 <lambdabot>   Not in scope: `asum'
04:50:21 <mux> > Data.Foldable.asum [Nothing, Nothing, Just 1]
04:50:22 <lambdabot>   Just 1
04:50:26 <mux> great
04:52:21 <chrisdone> you could define (<|>) within Monad, could you do it within Applicative?
04:52:24 <chrisdone> @src Applicative
04:52:25 <lambdabot> class Functor f => Applicative f where
04:52:25 <lambdabot>     pure  :: a -> f a
04:52:25 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
04:52:33 <chrisdone> nope
04:56:26 <quicksilver> chrisdone: how could you define <|> within monad?
04:59:49 <chrisdone> hmm
05:00:20 <chrisdone> (<|>) = mplus?
05:00:33 <chrisdone> nah that's cheating, hm
05:01:21 <chrisdone> no, you can't
05:01:38 <dino-> > "foo" `mplus` "bar"
05:01:39 <lambdabot>   "foobar"
05:02:39 <writer> > mzero `mplus` "bar"
05:02:41 <lambdabot>   "bar"
05:02:48 <writer> > "foo" `mplus` mzero
05:02:49 <lambdabot>   "foo"
05:03:16 <soupdragon> >> (>>)
05:03:19 <soupdragon> > (>>)
05:03:20 <lambdabot>   No instances for (Test.SmallCheck.Serial (m a),
05:03:20 <lambdabot>                    GHC.Show...
05:03:22 <soupdragon> > (>)
05:03:23 <lambdabot>   {()->{()->False}}
05:03:31 <chrisdone> <|> would need "bar" <|> undefined = "bar", iirc
05:03:48 <chrisdone> > "bar" <|> undefined
05:03:49 <lambdabot>   "bar*Exception: Prelude.undefined
05:03:58 <chrisdone> oh what
05:04:06 <chrisdone> <|> for lists is appending?
05:04:09 <soupdragon> yeah
05:04:15 <chrisdone> fair enough
05:04:20 <soupdragon> sorry dave
05:06:34 <chrisdone> @src List Applicative
05:06:34 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:06:38 <chrisdone> @src [a] Applicative
05:06:38 <lambdabot> Source not found. stty: unknown mode: doofus
05:06:44 <chrisdone> @src [] Applicative
05:06:44 <lambdabot> Source not found. My pet ferret can type better than you!
05:06:51 <chrisdone> @src Applicative []
05:06:52 <lambdabot> Source not found. My mind is going. I can feel it.
05:06:54 <chrisdone> oh well
05:07:12 <quicksilver> the applicative instance for [] is the natural restriction of the Monad one
05:07:17 <quicksilver> i.e. <*> == ap
05:07:40 <quicksilver> > [(+1),(*2)] <*> [3,4,5]
05:07:41 <lambdabot>   [4,5,6,6,8,10]
05:07:51 <soupdragon> > (sqrt((5+sqrt(5))/2)-(1+sqrt(5))/2)*exp(2*pi/5)
05:07:51 <lambdabot>   0.9981360445985088
05:08:09 <dino-> There was the talk of redesigning these things into somehting like MonadPlus and MonadOr http://haskell.org/haskellwiki/MonadPlus_reform_proposal
05:08:21 <soupdragon> > 1+1/(1+exp(-2*pi)+1/(1+exp(-4*pi)+1/(1+exp(-6*pi)+1)))
05:08:22 <lambdabot>   1.599329029505272
05:08:47 <soupdragon> > 1+1/(1+exp(-2*pi)+1/(1+exp(-4*pi)+1/(1+exp(-6*pi))))
05:08:48 <lambdabot>   1.6658381099182922
05:10:34 <chrisdone> class Monad m => MonadZero m where
05:10:34 <chrisdone>    mzero :: m a
05:10:41 <chrisdone> how do you instantiate a value for the 'a'?
05:10:51 <chrisdone> can someone write an example instance of this class please
05:11:09 <quicksilver> instance MonadZero [] where mzero = []
05:11:21 <chrisdone> hmm ok
05:11:22 <quicksilver> instance MonadZero Maybe where mzero = Nothing
05:12:24 <quicksilver> since it's parametric polymorphic in a, it can't really have a value of a in there.
05:12:35 <quicksilver> it must be some kind of monadic action which doesn't 'actually contain' a value.
05:12:38 <chrisdone> yeah
05:12:55 <chrisdone> what about an instance for ((->) r)?
05:14:04 <chrisdone> non-possiamo?
05:14:25 <quicksilver> correct. (->) r isn't a member of MonadZero
05:14:40 <chrisdone> i see
05:15:01 <illissius> is there any kind of mapM-ish thing which abstracts not just the monad, but also the list/container? (like, similarly to how there's a Foldable, maybe there's a Mappable? (...is that Functor?))
05:15:08 <quicksilver> illissius: Traversable
05:15:14 <dolio> @type Data.Traversable.mapM
05:15:15 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:15:38 <illissius> ah. thank you
05:16:14 <chrisdone> that's cool
05:19:18 <zygoloid> am i right in recalling that every Traversable Monad can be made into a monad transformer?
05:20:08 <dolio> The Traversable sequence is rather like a distributive law.
05:20:16 <zygoloid> yeah
05:20:47 <zygoloid> @type Data.Traversable.sequence . return
05:20:48 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m, Monad t) => m a -> m (t a)
05:20:49 <zygoloid> @type lift
05:20:50 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
05:21:03 <zygoloid> looks plausible
05:24:07 <quicksilver> zygoloid: I'd be curious how. A monad transformer has a different kind (obviously)
05:24:42 <quicksilver> data MkTraversableTrans t m = ???? -- where t is traversable and m is the base monad
05:25:29 <dolio> TravTrans t m a = MkTrans (m (t a))
05:25:45 <dolio> Or something.
05:25:47 * quicksilver nods
05:25:57 <quicksilver> like ListT, except apparently ListT doesn't work :)
05:26:44 <dolio> I don't know if that will actually work out, though. Can you get by with only t (m a) -> m (t a)?
05:26:53 <dolio> Or do you need to go in both directions?
05:28:31 <dolio> I guess it works out.
05:28:45 <quicksilver> :t Data.Traversable.sequence
05:28:46 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
05:28:50 <dolio> m (t (m (t a))) -> m (m (t (t a)) -> m (t (t a)) -> m (t a)
05:28:56 <dolio> Or something along those lines.
05:29:36 <dolio> The question is whether that's a monad.
05:29:41 <quicksilver> :t Data.Traversable.sequence . fmap return
05:29:42 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t a -> m (t a)
05:29:52 <quicksilver> :t Data.Traversable.sequence . fmap return . return
05:29:53 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m, Monad t) => a -> m (t a)
05:30:06 <quicksilver> that's the right type for return.
05:30:49 <quicksilver> return is sequence . fmap return . return and join is fmap join . join . fmap sequence
05:30:55 <quicksilver> (for some values of fmap)
05:30:57 <quicksilver> interesting.
05:31:07 <quicksilver> just that last fmap is really (fmap.fmap) I think.
05:31:21 <quicksilver> dolio: well, ListT doesn't work, so I guess this doesn't always work?
05:31:36 <dolio> Yeah.
05:32:24 <dolio> Distributive laws are probably supposed to obey algebraic laws that sequence might not.
05:32:36 <quicksilver> and if it doesn't even work for ListT then maybe it doesn't work for any interesting case at all :)
05:32:45 <quicksilver> it probably gives the right answer for MaybeT
05:32:57 <quicksilver> since there is essentially only one way to write MaybeT, it's determined by the types.
05:33:37 <quicksilver> ah, and it probably works for fixed length lists (vectors/tuples) using the "zipWith" join.
05:34:05 <quicksilver> ehm. Using the 'zipWith' ap, i.e. the "diag" join.
05:38:47 <soupdragon> I was thinking of writing a program in haskell that grows crystals but I can't figure out how to do it
05:39:38 <silver> grows crystals in real life?
05:39:52 <silver> that would be fun project
05:39:53 <soupdragon> simulated
05:39:56 <silver> oh :(
05:40:03 <noteed> soupdragon: 2d or 3d ?
05:40:05 <soupdragon> 3D
05:40:41 <soupdragon> I saw this thing a long time ago, you get square paper and color boxes in if they're next to 1 or 2 other boxes
05:41:25 <soupdragon> but how do you work out what rules grow a crystal and what lattice do you use etc..
05:42:47 <silver> http://en.wikipedia.org/wiki/Crystal_growth !!
05:43:42 <anakreon> I was reading the definition of a fixpoint function from http://harold.hotelling.net/gcdfix.lhs
05:43:45 <soupdragon> silver, http://en.wikipedia.org/wiki/Crystal_structure
05:43:54 <soupdragon> see Unit Cell -- I'm thinking of something like that
05:43:56 <silver> now we need to find or make a model to not require NASA supercomputers to simulate this
05:44:00 <anakreon> It is defined as:
05:44:00 <anakreon>  
05:44:00 <anakreon>  
05:44:05 <anakreon> > fix :: (a -> a) -> a
05:44:08 <anakreon> > fix f = f $ fix f
05:44:09 <lambdabot>   mueval-core: Time limit exceeded
05:44:09 <lambdabot>   <no location info>: parse error on input `='
05:44:11 <anakreon>  
05:44:14 <anakreon>  
05:44:21 <soupdragon> anakreon, and what is the question?
05:44:27 <chrisdone> a funny thing about working here is there are no native english speakers and they get annoyed with you for not understanding their thickly accented engrish. it's like, you have those people who give poor explanations and then get mad at you for not undertanding, and then add a thick barely comprehensible accent
05:44:41 <anakreon> The question is how does the function  know when to stop?
05:44:49 <anakreon> Where is the check that f x = x?
05:45:06 <Botje> it doesn't
05:45:29 <ivanm> chrisdone: where is "here"?
05:45:33 <silver> chrisdone, any specific nicks?
05:45:36 <soupdragon> anakreon: it uses lazy evaluation so it only computes what it needs to
05:45:38 <ivanm> anakreon: you have to make f smart enough to stop
05:45:55 <anakreon> This is my definition.
05:45:57 <anakreon> fixpoint f x
05:45:57 <anakreon>   | f x == x  = x
05:45:57 <anakreon>   | otherwise = fixpoint f (f x)
05:45:59 <anakreon>  
05:46:13 <soupdragon> anakreon, that definition wont work
05:46:18 <silver> chrisdone, oh sorry, nevermind that question
05:46:26 <anakreon> Why not?
05:46:33 <soupdragon> anakreon, well it does work in some very particular circumstances but not in general
05:46:40 <ivanm> anakreon: you might want to use a where in there to avoid recomputing f x
05:46:52 <dolio> That's a different fixed point operator.
05:46:54 <ivanm> note that that is different from fix, if only because of the type signature
05:46:56 <noteed> soupdragon: google gave this, maybe you'll find something (maybe in the references) students.cs.tamu.edu/ebl4767/research/thesis.pdf
05:47:22 <ivanm> @type let fixpoint f x = let x' = f x in if x == x' then x else fixpoint f x' in fixpoint
05:47:22 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
05:47:26 <ivanm> @type fix
05:47:27 <lambdabot> forall a. (a -> a) -> a
05:47:34 <chrisdone> woops i meant to say that in #haskell-blah
05:47:34 <ivanm> anakreon: ^^ spot the difference?
05:47:45 <ivanm> fix doesn't take an initial value!
05:48:01 <dolio> It already knows the initial value. :)
05:48:13 <ivanm> dolio: does it?
05:48:14 <nus> anakreon, the point is 'f' should know better how and when it should stop (i.e. what's '==')
05:48:22 <dolio> ivanm: It's always _|_
05:48:32 <ivanm> ahhh, right
05:48:43 <ivanm> except f _|_ is usually _|_
05:48:51 <ivanm> so it doesn't need to recurse, it's found the fixed point already! :p
05:48:59 <dolio> if f _|_  = _|_, then fix f = _|_.
05:49:18 <nus> > fix undefined
05:49:19 <lambdabot>   *Exception: Prelude.undefined
05:50:12 <ivanm> nus: no, that's using undefined as the function...
05:50:14 <ivanm> > fix succ
05:50:15 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
05:50:25 <ivanm> :o
05:50:34 <ivanm> > fix (succ :: Int -> Int)
05:50:38 <lambdabot>   mueval-core: Time limit exceeded
05:51:28 <soupdragon> http://upload.wikimedia.org/wikipedia/commons/1/13/Carbon_lattice_diamond.png
05:52:24 <dolio> Anyhow, if f is monotone, and ... then the least fixed point of f is the limit of the sequence _|_, f _|_, f (f _|_) ...
05:52:38 <dolio> Which is what fix f = f (fix f) happens to do.
05:53:25 <dolio> And all functions in Haskell are monotone, unless you're doing evil stuff with spoon/unamb/etc.
05:53:38 <soupdragon> http://newton.ex.ac.uk/research/qsystems/people/goss/symmetry/Solids.html
05:53:44 <soupdragon> what's spoon?
05:53:48 <Jafet> soupdragon, those are some hard balls
05:54:18 <dolio> It's that wrapper copumpkin wrote to turn certain pure exceptions into a Maybe.
05:54:33 <soupdragon> ah unsafePerformIO . catch or something?
05:54:35 <anakreon> From http://en.wikipedia.org/wiki/Fixed_point_%28mathematics%29, it defines the topogical fixed point property as the value x for which f x = x. I still do not understand how fix works and why fixpoint does not. I would appriciate some pointers for further study of fixpoint and it's implementation in haskell.
05:54:54 <soupdragon> anakreon: you need to understand lazy evaluation
05:55:18 <soupdragon> anakreon: for example consider   x = True && (True && (False && x))
05:55:20 <anakreon> A value is calculated only if required
05:55:24 <soupdragon> > let x = True && (True && (False && x)) in x
05:55:25 <lambdabot>   False
05:55:31 <soupdragon> why does it not cause an infinite loop?
05:55:38 <soupdragon> @src (&&)
05:55:38 <lambdabot> True  && x = x
05:55:38 <lambdabot> False && _ = False
05:56:06 <soupdragon> > let x = True : (True : (False : x)) in all x
05:56:07 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
05:56:07 <lambdabot>         against inferred ...
05:56:12 <soupdragon> > let x = True : (True : (False : x)) in and x
05:56:12 <lambdabot>   False
05:56:37 <dolio> http://en.wikipedia.org/wiki/Kleene_fixpoint_theorem
05:56:39 <anakreon> Yes, I understand your example. I also understand that fix will recursivly calculate f (f (f ...f(x)))
05:56:45 <soupdragon> no
05:57:47 <soupdragon> it is f . f . f . f . f . ... forever, there is no x at the end
05:57:58 <Botje> > let ones = 1 : ones in ones
05:57:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:58:31 <soupdragon> > fix ((1:).(map (+1)))
05:58:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:58:36 <rajeshsr> @src repeat
05:58:37 <lambdabot> repeat x = xs where xs = x : xs
05:59:01 <soupdragon> > take 6 $ ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . undefined
05:59:02 <lambdabot>   *Exception: Prelude.undefined
05:59:06 <soupdragon> doh
05:59:59 <dolio> What it computes is f (f (f ... (f (fix f)))).
06:00:03 <Jafet> > fix error
06:00:04 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
06:00:04 <dolio> Unfolding as many times as necessary.
06:00:23 <dolio> Until f doesn't care what fix f is anymore.
06:00:27 <soupdragon> > take 5 $ (((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1))) . ((1:).(map (+1)))) undefined
06:00:28 <lambdabot>   [1,2,3,4,5]
06:00:43 <anakreon> dolio. Thanks I got it now
06:01:57 <dolio> Actually, in Haskell, I suppose it's more accurate to say that it unfolds until the context doesn't care what happens when you unfold it more, since it can be an infinite list.
06:02:14 <dolio> Or infinite other things.
06:03:07 <Jafet> Classic context anthropomorphism analogy
06:03:33 <Jafet> If you want to get down to it, everything is driven by main
06:08:37 <chrisdone> and if main doesn't work there's always violence
06:08:57 <Jafet> It's best when it involves the mains.
06:20:26 <rajeshsr> is there any source level debugger for ghci?
06:21:16 <dino-> rajeshsr: yes! http://haskell.cs.yale.edu/ghc/docs/6.12.2/html/users_guide/ghci-debugger.html
06:25:06 <Choko> Is there a nice tool to visualize the profiling output from ghc ?
06:26:54 <ivanm> Choko: there's prof2dot
06:26:57 <ivanm> that's probably about it
06:28:13 <Choko> ivanm: I will try it, thanks
06:36:00 <rajeshsr> finally wrote a complete sudoku code with pure backtracking: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25445#a25445
06:36:20 <rajeshsr> any comment on coding style? and where things can be improved?
06:36:39 <soupdragon> use   type ... = ....
06:36:51 <soupdragon> there is no point writing:   solve::Map (Int, Int) Int -> (Int, Int) -> (Bool, Map (Int, Int) Int)
06:36:53 <nus> uhh, your screen is too wide?
06:37:09 <soupdragon> it should be  solve :: Sudoku -> Coordinate -> ... stuff like that, something you can read
06:37:29 <soupdragon> also the code is too long, it actually falls off the edge of the webpage
06:37:41 <rajeshsr> soupdragon, hmm, thats a good idea! I used typedef liberally, yet to get used in haskell!
06:37:49 <rajeshsr> soupdragon, yep, what can be done?
06:38:06 <soupdragon> I'm not sure, but there is usually something
06:38:51 <rajeshsr> BTW, for getting input i really seemed to have struggled a lot! Anyway to make it simpler?
06:41:43 <Makoryu> rajeshsr: Refactor!
06:41:51 <rajeshsr> the important lesson learnt with this is that always give type signature of the function. Haskell then will give you more user-friendly error message to debug!
06:42:18 <rajeshsr> Makoryu, you mean? make the variable names expressive?
06:42:40 <Makoryu> rajeshsr: No, I mean, break out common subexpressions
06:42:56 <Makoryu> Let's start with "foo v = not . elem v $ bar"
06:43:05 <Makoryu> You can make that a function
06:43:21 <cdsmithus> rajeshr, or, at least, add type signatures if you don't understand the errors
06:43:45 <rajeshsr> hmm, f = not . elem v
06:43:46 <rajeshsr> ?
06:43:59 <Makoryu> Let's say: nlm xs v = not . elem v $ xs
06:44:17 <Makoryu> And then you can just write: colCheck = nlm [sudoku ... ]
06:44:28 <rajeshsr> Makoryu, hmm, ok!
06:44:48 <Makoryu> This isn't necessarily the most readable way, and certainly not the best name
06:44:58 <rajeshsr> what is the usual way? is factoring done after writing a working code?
06:45:10 <Makoryu> Generally :p
06:45:22 <rajeshsr> ha, ok! :)
06:45:32 <rajeshsr> also, can you look at the way I get input.
06:45:38 <rajeshsr> i know i made it hard.
06:45:44 <rajeshsr> How to make it simpler and elegant?
06:46:14 <rajeshsr> head $ (dropWhile (not . fst)  [solve (insert (x, y) val sudoku) t | val <- [1..9], isok val]) ++ [(False, sudoku)]
06:46:21 <rajeshsr> how to make that line smaller?!
06:47:52 <rajeshsr> also wondering how to get away with using the constant 8? is there anyway to put it as a manifest constant, global to whole file?
06:48:04 <Botje> rajeshsr: move the dropwhile inside the list comprehension
06:48:30 <rajeshsr> Botje, how?
06:49:22 <Botje> head $ [ (True, solution) | val <- [1..9], isok val, (True, solution) <- solve (insert (x,y) val sudoku) t] ++ [(False, sudoku)]
06:49:48 <Botje> okay, so maybe that's not simpler :(
06:50:17 <cdsmithus> Botje, it's also not equivalent.  The original just dropped False from the front of the list.
06:50:49 <cdsmithus> Oh wait, there's a head
06:50:54 <cdsmithus> So yeah, it is equivalent
06:51:32 <Makoryu> rajeshsr: You can split the expression across two lines, as long as the second (and subsequent) lines are indented more than the first
06:51:44 <rajeshsr> Botje, ha, ok! anyway i guess dropWhile is more expressive here..
06:52:27 <rajeshsr> Makoryu, hmm, ok.
06:52:53 <rajeshsr> any way to have manifest constants in haskell?
06:53:02 <Makoryu> (You could also rewrite the entire thing as filter, map, etc.)
06:53:03 <cdsmithus> So, on further thought, it seems like filter is closer to what you conceptually wanted (still guaranteed to be equivalent, since you're taking the head)
06:53:41 <cdsmithus> head $ (filter fst [solve (insert (x, y) val sudoku) t | val <- [1..9], isok val]) ++ [(False, sudoku)]
06:53:59 <Makoryu> rajeshsr: Like __DATE__ and such?
06:54:01 <rajeshsr> cdsmithus, right. But dropWhile makes it clear that i break after the first True, although because of head, other methods like filter etc. are equivalent to this..
06:54:14 <rajeshsr> Makoryu, #define FOO 42
06:54:19 <rajeshsr> like that..
06:54:27 <rajeshsr> const int FOO = 56;
06:54:44 <Makoryu> rajeshsr: That's not really necessary in Haskell.
06:55:02 <rajeshsr> Makoryu, well, i have used 8 in many places..
06:55:04 <Makoryu> I mean, you just define a top-level value and it's automatically immutable
06:55:06 <cdsmithus> rajeshsr: I like filter because it gives more meaning to the intermediate results.  It's understood that you'll only be doing as much work as necessary
06:55:33 <nus> rajeshsr, you have the size encoded, generalize?
06:55:40 <rajeshsr> well, am not talking about constness, am talking about using a value again and again like in my code..
06:56:45 <rajeshsr> cdsmithus, hmm, may be i find it dropWhile more natural because of my heavy imperative background where we enjoy breaking the moment we get the result! :)
06:56:53 <rajeshsr> nus, you mean?
06:57:03 <nelfin> rajeshsr: foo :: Int
06:57:07 <nelfin> rajeshsr: foo = 42
06:57:14 <rajeshsr> nelfin, ha!!
06:57:21 <applicative> @type notElem
06:57:22 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:57:43 <cdsmithus> rajeshr: Yes, I think I understand that... but this is a (minor) example of *exactly* where using a lazy language frees you to do things in a more composable way.  I guess I just wanted to point that out.
06:57:59 <rajeshsr> cdsmithus, yep, i got that!
06:58:27 <rajeshsr> in fact i wouldn't have understood about filter being equivalent with it, without you pointing out that! Thanks
06:58:35 <cdsmithus> In particular, I initially assumed that because you were using dropWhile, there was some importance attached to only discarding the False pairs from the beginning.
06:58:55 <cdsmithus> Until I noticed the "head" at the beginning, anyway
06:59:35 <rajeshsr> @pl (\mp (x, y, z) -> insert (x, y) z mp)
06:59:35 <lambdabot> (line 1, column 11):
06:59:35 <lambdabot> unexpected ","
06:59:35 <lambdabot> expecting letter or digit, operator or ")"
06:59:35 <lambdabot> ambiguous use of a non associative operator
06:59:48 <rajeshsr> why that breaks? I want to get away with lambda!
07:00:12 <Cale> rajeshsr: The triple, I think.
07:00:21 <cdsmithus> Not sure... it should be valid Haskell.
07:00:25 <Cale> rajeshsr: There are not many built-in functions for working with triples
07:00:33 <Makoryu> rajeshsr: @pl won't pattern match on certain things
07:00:33 <Cale> and so @pl doesn't know about them
07:00:36 <rajeshsr> Cale, hmm, ok
07:00:41 <Cale> (it doesn't parse all of Haskell)
07:00:46 <cdsmithus> Oh!
07:00:47 <the_guru> humm...
07:00:54 <the_guru> wow no one is dead here
07:01:40 <rajeshsr> Any comment on making the I/O part more easy and elegant? I seemed to have complicated things in I/O part, right?
07:02:01 <rajeshsr> those zip3, foldM, return foldl etc..
07:02:13 <Saizan> if someone wants to convert it to use haskell-src-exts and report a more explicit error when some construct is not supported it'd probably be appreciated :)
07:02:26 <rajeshsr> really makes it look unnatural! In fact it is, i struggled more to get I/O than get sudoku working!
07:02:42 <Cale> I really should sleep. I might take a look at it when I get up though.
07:03:07 <rajeshsr> Cale, hmm, ok, thanks!
07:03:29 <Makoryu> the_guru: Generally, the dead don't use IRC....
07:03:41 <the_guru> then?
07:03:46 <the_guru> who uses?
07:04:41 <Saizan> rajeshsr: it seems like there's too much interleaving with the collection of the strings from stdin and their processing
07:05:02 <rajeshsr> Saizan, can you elaborate?
07:06:12 <Saizan> rajeshsr: i'd write a pure function "parse :: [String] -> Map (Int,Int) Int" which expects a list of length 9
07:06:49 <Saizan> rajeshsr: so then you can write ques <- parse <$> replicateM 9 getLine
07:06:53 <rajeshsr> Saizan, ha, ok. i think i got you..
07:07:51 <rajeshsr> those foldM and all is really heavy usage, i guess. right?
07:09:31 <Saizan> well, it's not heavy per se, but how you're using it leads to mixing I/O and pure computations too much
07:09:46 <Saizan> s/computations/code/
07:11:16 <Saizan> parse :: [String] -> Map (Int,Int) Int is almost surely going to be much simpler than what you've now between process and the foldM, since you're not also worrying about getting the data from the user
07:12:05 <rajeshsr> Saizan, hmm, ok!
07:12:27 <the_guru> what u can own rajesh
07:13:34 <Saizan> (good old separation of concerns)
07:25:37 * edwardk_ just realized i could hack up my little compiler to darcs annotate on an error to tell me the last patch that contributed the line with the error. i wonder if it'd be useful enough to justify the source control coupling
07:26:17 <edwardk_> file:line:column:patch ?
07:32:31 * hackagebot records 0.0.0.1 - A flexible record system  http://hackage.haskell.org/package/records-0.0.0.1 (WolfgangJeltsch)
07:33:12 <nus> edwardk_, seen this? http://cakoose.com/darcs/darcs-reannotate/darcs-reannotate
07:34:02 <edwardk_> nus: no i hadn't. =) neat
07:34:21 <Jafet> > let(%)=mod;(/)=div;s g=case findIndex(=='0')g of Nothing->[g];Just f->concat$map(\m->if or.concat$map(\i->[g!!(f-f%27+f%9/3*3+i/3*9+i%3)==m,g!!(f%9+i*9)==m,g!!(f-f%9+i)==m])[0..8]then[]else s$take f g++[m]++drop(f+1)g)['1'..'9'] in s "000023801702010000000000360006084753000106000283790600074000000000050207509340000"
07:34:22 <edwardk_> is there an example of its output?
07:34:23 <lambdabot>   ["6954238717326184958415793629162847534571369282837956141748625393689512475...
07:35:02 <nus> edwardk_, ever used cvs?
07:35:29 <edwardk_> nus: yeah, but i never used the annotate feature i'll admit ;)
07:35:46 <nus> edwardk_, http://wiki.darcs.net/RelatedSoftware/DarcsReannotate
07:35:51 <edwardk_> my goal with cvs was to use it as little as possible to get my job done ;)
07:36:17 <edwardk_> ah perfect
07:36:17 <nus> there was a time with not much choice
07:36:53 <nus> caveat emptor, it breaks, as Python, sometimes
07:37:18 <edwardk_> well, i'm more interested in what i could get the compiler to do to be aware of source control enough to give more informed diagnostics
07:37:29 * Baughn is getting /rather tired/ of the module import cycle limitation
07:37:29 <soupdragon> > 1+1/(2+2/(3+3/(4+4/(5+5/(6+6/(7+7/8))))))
07:37:30 <lambdabot>   1.3922115222165907
07:37:50 <soupdragon> > 1+2/(2+3/(3+4/(4+5/(5+6/(6+7/(7+8/9))))))
07:37:51 <edwardk_> i.e. this failed to compile and here is at least the patch that contributed the line that isn't compiling. (even if of course that patch didn't cause the error)
07:37:51 <lambdabot>   1.7182816576664037
07:38:30 <al22> May I ask a question about attoparsec? I'm trying to convert a parsec parser to attoparsec but can't even get the basics right ...
07:38:41 <edwardk_> al22: whats the issue?
07:38:43 <al22> For example, parse ((P.takeWhile $ notInClass "\n\r") `sepBy` P8.endOfLine) $ B.pack "1\n2\n3"
07:39:11 <al22> always returns 'Partial _ '
07:39:40 <al22> instead of ["1", "2", "3"] as I would expect.
07:40:00 <al22> B = Bytestring module, P = Attoparsec
07:40:02 <edwardk_> don't you have to feed it the  last empty bytestring somehow? trying to remember the attoparsec combinators (maybe parse does that for you)
07:40:32 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25448 <-- Import cycles aside, anyone have a cleverer suggestion for how to handle the lookupLease ad-hoc polymorphism there than using a class?
07:40:54 <edwardk_> so 'feed it B.empty'
07:41:11 <edwardk_> it is partial because parse returns a resumable result.
07:41:24 <edwardk_> after all that parser could always continue to munch more
07:41:58 <al22> Thanks, edwardk_, but parse ((P.takeWhile $ notInClass "\n\r") `sepBy` P8.endOfLine) $ B.empty still returns Partial _
07:43:02 <edwardk_> what happens when you feed (parse (P.takeWhile (notInClass "\n\r") `sepBy` P8.endOfLine) (B.pack "1\n2\n3")) B.empty ?
07:43:12 <al22> Essentially, what I'm trying to achieve is to split a large CSV-like file into lines but the last line might not be \n-terminated.
07:43:21 <edwardk_> feed was a function =)
07:44:14 <al22> Wow, looks good!
07:44:49 <tibbe> how is let desugared in do notation again?
07:45:18 <edwardk_> @undo do foo; let x = y; bar
07:45:18 <lambdabot>  Parse error at end of input
07:45:34 <edwardk_> @undo do foo; let { x = y}; bar
07:45:34 <lambdabot> foo >> let { x = y} in bar
07:45:53 <al22> @edwardk_ Thanks! I would not have been able to come up with that myself!
07:45:54 <lambdabot> Unknown command, try @list
07:46:00 <nus> edwardk_, seems like you'd want to get somwhere into the 'darcs trackdown' implementation
07:46:08 <edwardk_> al22: np, i mucked around in attoparsecs guts for a while =)
07:46:38 <edwardk_> nus: possibly, though, having the compiler revert to previous versions might be a bit much
07:47:21 <tibbe> edwardk_: thanks
07:48:19 <edwardk_> it might be kind of neat to use the fancy rope types i have to patch and unpatch the file in memory though, so i can correlate locations across patches while searching for what first broke the code though
07:48:31 <edwardk_> but that is overkill even by my standards ;)
07:49:42 <tibbe> @source ($!)
07:49:42 <lambdabot> ($!) not available
07:49:46 <tibbe> @src ($!)
07:49:46 <lambdabot> f $! x = x `seq` f x
07:50:32 <nus> well, if change was yours, you already know where exactly the error is... if not... depends on how often you test the merges, I guess
07:51:31 <nus> monotony of merge/compile, so to say
07:51:46 <zachk> ok if i have data Poly a = Poly [a] how do i force a to be of Num a ?
07:51:54 <edwardk_> *nods* i think i might just grab the last patch to affect the line on which the error occurred as a starting point.
07:52:10 <edwardk_> zachk: you shouldn't. just enforce it in each instance or method
07:52:28 <edwardk_> zachk: instance Num a => Num (Poly a) where ...
07:52:44 <zachk> oh first and no () ok
07:53:03 <edwardk_> instance Monoid a => SemiGroup (Poly a) where ...
07:53:20 <illissius> is it possible somehow to have a type constructor as a paremeter to a function, and use then use it within the function to pattern match with? (to begin with you'd need a way to designate it as a type constructor and not just any function...)
07:53:28 <edwardk_> instance (Show a, Ord a) => SomethingStrange (Poly a) where .. ;)
07:53:37 <edwardk_> zachk: you can use ()'s around it, but they aren't required
07:53:56 <zachk> instance Show a => Show (Poly a) where   would i put Num a there?
07:54:44 <edwardk_> zachk: why does it have to be a Num to show?
07:54:46 <edwardk_> =)
07:55:14 <illissius> i think you want the a to be a Num, not the (Poly a) to be a Num, right?
07:55:24 <zachk> mmmm perhaps a type signature somewhere would help
07:56:06 <illissius> you could use GADT syntax: data Poly a where (Num a) => [a] -> Poly a
07:56:07 <edwardk_> zachk: my point is this. you _could_ say instance Num a => Show (Poly a)
07:56:28 <edwardk_> illissius: its a bad idea, it adds no value, and that constraint just adds overhead and obligation and provides no benefit
07:56:57 <edwardk_> zachk: but showing a polynomial doesn't intrinsically depend on the argument being a Num, so why construct the dictionary to pass it to the method?
07:57:54 <zachk> im adding in plus signs where there arent any
07:58:11 <zachk> showNum n = if n < 0 then ('+':(show n)) else show n
07:58:15 <edwardk_> illissius: there is also the useless syntax data Num a => Poly a = Poly [a], but it _never helps) =)
07:59:29 * zachk will brb and is very confused...
07:59:32 <Saizan> data Poly a where Num a => [a] -> Poly a can make some type signatures shorter :)
08:00:18 <jlouis> yay, now the allocation cost-centre is moving around in combinatorrent. This means we have killed most of the nastiness
08:00:38 <applicative> Saizan, but surely the point at issue, whatever it is, doesn't require GADT syntax to be made clear
08:00:42 <illissius> edwardk_: oh right. i was having trouble remembering the exact details of the situation with ADTs, GADTs, and constraints
08:00:52 <jlouis> The Control process for peers is now the winner. He will be fun to optimize
08:01:24 <Saizan> applicative: that GADT syntax is associated with a particular semantic that you don't get with haskell98 notation for ADTs
08:01:45 <Saizan> applicative: i agree that it's probably not what zachk wants though
08:01:49 <applicative> yes, I was just thinking of zachk's problem,
08:01:55 <edwardk_> zachk: instance Show a => Show (Poly a) where showsPrec d (Poly []) = showString "0"; showsPrec d (Poly [x]) = showsPrec d x; showsPrec d (Poly x:xs) = showParen (d > 10) $ shows x . showString " + " . showsPrec 5 xs
08:02:11 <edwardk_> zachk: note that show for Poly never needed to use the fact that a was a Num, just that it was a Show, which is implied by Num
08:02:11 <applicative> i thought it might confuse the issue, which admittedly I couldn't yet grasp
08:02:35 <edwardk_> er the showsPrec d (Poly x:xs) should be showsPrec d (Poly (x:xs))
08:03:01 <edwardk_> er
08:03:12 <edwardk_> and the call to shows x should have been to showsPrec 5 x
08:03:38 <rajeshsr> Saizan, made what you said: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25449#a25449 Indeed it looks simpler now!
08:03:40 <rajeshsr> thanks
08:04:27 <triyo> I am using record syntax for defining my data type. I know that the data is immutable. Question is how do I get a new instance of data for this record that has one of the value fields changed to some other value. What is the right approach to do this in Haskell. (Sorry for n00bie question pls)
08:05:39 <Botje> triyo: foo { field = newValue }
08:05:51 <Botje> triyo: and everyone hates record syntax, don't worry
08:06:13 <edwardk_> nus: hrmm "Foo.ks:10:8:error:ekmett: ... isnt too shabby actually with a key of what each patch name means printed separately in a patches section of the compiler output
08:06:33 <triyo> oh the moustache syntax, lovely. :)
08:08:41 <rajeshsr> @pl (\x (y, z) -> f x y z)
08:08:41 <lambdabot> (`ap` snd) . (. fst) . f
08:09:07 <Botje> huh
08:09:10 <rajeshsr> which is better? the lambda expression or the point free form?! :)
08:09:12 <Saizan> ?index range
08:09:12 <edwardk_> zachk: did the example make sense?
08:09:13 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
08:09:16 <Botje> lambda, by far.
08:09:18 <edwardk_> rajeshsr: its situational.
08:09:25 <Saizan> rajeshsr: i suspect "parse = M.fromList . zip (range ((0,0),(8,8))) . concat . map (map read . words)" using Data.Ix.range
08:09:37 <edwardk_> rajeshsr: i prefer point-free when its only one argument being plumbed through or its just a beta-reduction to go back and forth
08:09:48 <Botje> @unpl \x -> uncurry (f x)
08:09:48 <lambdabot> \ x -> uncurry (f x)
08:10:05 <Saizan> @pl \x -> uncurry (f x)
08:10:06 <lambdabot> uncurry . f
08:10:30 <Botje> rajeshsr: you can use \x -> uncurry (f x)
08:10:35 <Botje> or even uncurry . f
08:10:40 <Botje> which should be equivalent
08:10:44 <illissius> so re: my earlier question, i assume it's not possible to do "foo :: SOME_SYNTAX (A -> B) -> B -> A; foo construct b = bar b where bar :: B -> A; bar (construct a) = a", where SOME_SYNTAX says that the (A->B) is a type constructor for B and not just any old function?
08:11:31 <illissius> s/type constructor/constructor/
08:11:34 <rajeshsr> :t range
08:11:35 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
08:11:46 <edwardk_> rajeshsr: in the case of that pl, it makes use of non-trivial properties like ap in the anonymous reader monad, etc. and greatly increases the level of sophistication required of the reader, while providing no benefit
08:12:15 <Saizan> illissius: right, there's nothing at the type level to distinguish data constructors from regular functions
08:12:25 <rajeshsr> edwardk_, hmm, yeah!
08:12:34 <rajeshsr> Saizan, that looks cooler! thanks
08:12:41 <illissius> ok, thanks
08:12:50 <edwardk_> rajeshsr: but Botje's version is pretty sexy and i'd probably drop that in ;)
08:13:47 * edwardk_ waves hello to lowasser
08:13:53 <rajeshsr> edwardk_, i don't get how he uses uncurry for my lambda form. I thought about uncurry, but no idea of how..
08:13:59 * lowasser waves back
08:14:01 <nus> edwardk_, hmm, as a first step (and given meaningful patch names)... Ideally, one would like to end up with the file in an editor's buffer.
08:14:44 <edwardk> @type (uncurry .)
08:14:45 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f (a -> b -> c) -> f ((a, b) -> c)
08:15:00 <edwardk> gah stupid caleskel
08:15:11 <edwardk> @type (uncurry Prelude..)
08:15:13 <lambdabot> forall a b c a1. (a1 -> a -> b -> c) -> a1 -> (a, b) -> c
08:15:14 <Saizan> illissius: you could make an ADT just for the constructors (maybe a GADT to specify the type of the fields?) or you could piggyback on Data.Data which defines Constr and the boilerplate to extract it from a value
08:15:41 <edwardk> where that first argument is 'f'
08:16:39 <zachk> yay i got it ! instance (Num a,Ord a) => Show (Poly a) where
08:16:48 <zachk> i thought Num's were Ord
08:16:52 <edwardk> zachk: overkill ;)
08:16:58 <edwardk> zachk: Show doesn't need all that stuff
08:17:38 <zachk> if i comment it out ghci tells me to add it in
08:17:39 <edwardk> zachk: you may want (Num a, Ord a) on a bunch of methods, but why construct those dictionaries to pass to show which won't use them?
08:17:48 <edwardk> did you see my show above?
08:18:12 <edwardk> what is the type signature on your showNum?
08:18:16 <edwardk> and why does it exist?
08:19:00 <lowasser1> backity
08:19:26 <edwardk> Num a is (rather asininely) a subtype of Show a, so you probably had something like showNum :: Num a => a -> String, which you used in your show, infecting the types required of that, etc.
08:19:59 <edwardk> stuff like that is why you want to just require the smallest set of constraints possible
08:20:04 <edwardk> for each individual operation
08:20:13 <zachk> ok it may be overkill but it seems to be working
08:20:27 <edwardk> zachk:  can you hpaste what you have?
08:21:30 <zachk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25450#a25450
08:22:26 <soupdragon> zachk cool
08:22:32 <zachk> ty
08:22:38 <soupdragon> want to see mine
08:22:55 <zachk> well i showed you mine so sure ill take a peek at yours ;-D
08:23:13 <soupdragon> http://github.com/odge/al-jabr/blob/master/haskell-bits/Polynomials.hs
08:23:14 <illissius> Saizan: woah. at any rate in my specific case I can just hardcode the constructors, I was merely wondering
08:24:12 <illissius> also it is amusing how i repeatedly typo hardcode as hardcore before correcting it, including this sentence
08:24:55 <zachk> nice soup... i was thinking of something like that but i dont really get the type system and overloading very good, instances class and newtype confuse me
08:25:34 <soupdragon> zachk, the thing is -- these are multivariable polynomials, and all the algorithms are much simpler (or only exist) in the single variable case
08:26:26 <scree> hmm.  are there libraries containing versions of zip that give give you something the length of the longest list (with some defaults)?
08:26:54 <scree> I mean, it's not hard to write, but I always end up writing it afresh
08:26:59 <illissius> zachk: as far as i know 'newtype' is the same as 'data' only with less runtime overhead and restrictions on its use, though i'm not entirely clear either
08:27:02 <zachk> what got me interested in doing this...is ive found for some mod (poly n) x == 0
08:28:06 <zachk> soupdragon: so your polynomials are Nums?
08:28:39 <edwardk> zachk: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25450#a25451 is a start towards something more idiomatic
08:28:46 <soupdragon> zachk, well I don't use stuff like Num, I tried a few different ways to structure it but none were really viable
08:28:59 <soupdragon> what's that about mod (poly n) x == 0?
08:29:17 <nus> newtype is usefull to get rid of all existing instances for the new type and keep constructors
08:29:24 <nus> *useful
08:29:33 <zachk> edwardk: nice
08:30:09 <edwardk> but i'll say this the Eq and Ord instances you have are strange.
08:30:48 <chrisdone> sometimes i wish types curried but i think this means i'm doin it rong
08:32:26 <edwardk> zachk: and of course you need some kind of eval n = foldr (\d acc -> d * n + acc) 0 or something to use them
08:32:44 <Apocalisp> @hoogle ([a] -> b) -> [a] -> [b]
08:32:44 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
08:32:44 <lambdabot> Control.Parallel.Strategies parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
08:32:44 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t e -> q) -> d -> q
08:32:54 <chrisdone> (->) has kind * -> * -> *, ((->) r) has kind *->*, but (((->) r) ((->) k)) has kind sod all
08:32:59 <chrisdone> does lambdabot have a @kind command?
08:33:08 <Apocalisp> @kind []
08:33:09 <lambdabot> * -> *
08:33:13 <Apocalisp> yes!
08:33:15 <chrisdone> @kind ((->) r)
08:33:16 <lambdabot> Not in scope: type variable `r'
08:33:22 <chrisdone> umm
08:33:34 <zachk> edwardk: yea i sort of forgot about the eval for now
08:33:34 <chrisdone> @kind ((->) In)
08:33:35 <lambdabot> Not in scope: type constructor or class `In'
08:33:37 <chrisdone> @kind ((->) Int)
08:33:37 <lambdabot> ? -> *
08:33:48 <Apocalisp> @kind forall a. ((->) a)
08:33:49 <lambdabot>     `(->) a' is not applied to enough type arguments
08:33:49 <lambdabot>     Expected kind `*', but `(->) a' has kind `? -> *'
08:33:53 <chrisdone> why is there both '?' and '*'?
08:34:20 <Apocalisp> ([a] -> b) -> [a] -> [b] -- feels like a comonad
08:34:21 <chrisdone> Apocalisp: could that one curry?
08:34:31 <chrisdone> well, partially apply i mea
08:34:57 <chrisdone> forall a. ((->) a) is * -> *
08:35:00 <Apocalisp> I don't know what @kind expects
08:35:06 <chrisdone> but you get "not applied to enough args"
08:36:18 <chrisdone> i guess you'd need a type-level representation of type application, like function application has a value-level representation
08:36:33 <chrisdone> orsomth
08:37:09 <scree> @type (. tails) . fmap
08:37:10 <lambdabot> forall a b. ([a] -> b) -> [a] -> [b]
08:37:24 <scree> hmm
08:37:26 <chrisdone> @kind ((->) Int) Int
08:37:27 <lambdabot> *
08:37:42 <chrisdone> @kind (((->) Int) ((->) Int)) Int Int
08:37:43 <lambdabot>     `(->) Int' is not applied to enough type arguments
08:37:43 <lambdabot>     Expected kind `?', but `(->) Int' has kind `? -> *'
08:38:49 <chrisdone> hum
08:40:30 <nus> @kind (->)
08:40:31 <lambdabot> ?? -> ? -> *
08:40:35 <zygoloid> chrisdone: (->) has kind ?? -> ? -> *. both ?? and ? are bigger than * (otherwise you wouldn't be able to write functions which take unlifted types)
08:42:37 <nus> @kind (>>>)
08:42:38 <lambdabot> Not in scope: type variable `>>>'
08:42:45 <nus> err
08:42:46 <dpratt71> is there a convenient way to load all .hs files in a directory into GHCi?
08:42:47 <zygoloid> chrisdone: there's some details here: http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
08:42:50 <nus> @type (>>>)
08:42:51 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
08:43:08 <chrisdone> zygoloid: hey thanks
08:44:10 <quicksilver> dpratt71: GHCi does it automatically if one file imports the others
08:44:12 <soupdragon> http://bootes.math.uqam.ca/cgi-bin/ipcgi/lookup.pl?Submit=GO+&number=1.5450849718747&lookup_type=simple
08:44:16 <soupdragon> I found a bug in plouffe
08:44:19 <quicksilver> dpratt71: which is how it normally works for me at least.
08:44:23 <soupdragon> > 1/8-1/8*5**(1/2)
08:44:24 <lambdabot>   -0.15450849718747373
08:44:28 <soupdragon> ^ it's negative but it says it's positive
08:44:37 <soupdragon> maybe that's not even a bug :/
08:44:39 <dpratt71> quicksilver: hmm; doesn't seem to be working in this instance
08:45:17 <quicksilver> what makes you say it isn't working?
08:46:30 <dpratt71> quicksilver: error "could not find module 'XYX'" when XYZ.hs is right there in the same directory
08:46:57 <dpratt71> if I add XYX.hs to the :l command, I get an error about another missing module
08:46:58 <quicksilver> ghci has to be in that directory too
08:47:13 <quicksilver> either launch it in that directory
08:47:15 <quicksilver> or :cd to it
08:47:28 <dpratt71> quicksilver: ah, ok; thanks
08:47:33 <tibbe> Does "return $! x : xs" make sense in a strict state monad? : is already in a constructor and it has no strict fields so forcing it doesn't for x or xs.
08:47:53 <quicksilver> tibbe: that indicates that someone doesn't understand $!, IMO :)
08:48:25 <tibbe> quicksilver: I find it tricky myself when dealing with (state) monads
08:48:53 <tibbe> quicksilver: it's somewhat tricky to reason about when things get forced in presence of all these state tokens
08:49:32 <quicksilver> certainly you can't understand strictness in a state monad without understanding how >>= was written
08:49:43 <quicksilver> either by looking at the source or hoping it was documented by the author :)
08:50:15 <quicksilver> but that is not related to the nonsensicality of f $! (a : b)
08:50:30 <quicksilver> f $! (a : b) === f (a : b) for all f,a,b
08:50:47 <dpratt71> I'm tempted to modify ghci.conf such that things like "-XNoMonomorphismRestriction" are enabled by default; is this a sensible thing to do?
08:50:56 <cdsmithus> dpratt71: I did that
08:51:07 <cdsmithus> Well, I did it in a .ghci
08:51:43 <quicksilver> dpratt71: lots of people think the monomorphism restriction is *especially* inappropriate in ghci
08:51:47 <quicksilver> (so, go ahead!)
08:51:56 <cdsmithus> In particular, though, I think that while the monomorphism restriction is vaguely justifiable in a compiled context... yeah, what quicksilver said
08:52:19 <dpratt71> very good, thanks
08:52:48 <dpratt71> (anything else I should enable while I'm in there?)
08:54:28 <quicksilver> personally I normally enable other options in files; when I'm working on ghci I've almost always got a file loaded
08:54:32 <cdsmithus> Here's a question.  I just aesthetically prefer it when GHCi writes types as "forall a. a -> a" instead of just "a -> a".  I know -fglasgow-exts has that effect... but with it being not recommended, how else do I get that behavior?
08:54:54 <tibbe> quicksilver: right, it makes sense of the constructor has strict fields though
08:55:52 <quicksilver> tibbe: yes.
08:55:58 <tibbe> @src IO
08:55:58 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:56:03 <tibbe> @src ST
08:56:03 <lambdabot> newtype ST s a = ST (STRep s a)
08:56:06 <tibbe> @src STRep
08:56:06 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
08:56:21 <tibbe> quicksilver: or does it?
08:56:32 <cdsmithus> It does?  If you force the constructor with pattern matching, and it has strict fields, how does the strictness on the pattern match matter?
08:56:37 <quicksilver> tibbe: now you're confusing me.
08:56:42 <quicksilver> tibbe: ST is not a state monad.
08:56:45 <tibbe> quicksilver: the $1 pushes the evaluation outside the lambda that receives the state token
08:56:59 <Saizan> cdsmithus: ExplicitForAll
08:57:24 <tibbe> quicksilver: :) sorry. The question is. Does $! ever make sense on application of a function to a constructor in a strict state monad like ST or IO?
08:57:44 <cdsmithus> Saizan: Unfortunately, that doesn't do it.  That just makes it accept that format for types, but it doesn't use the format.
08:57:54 <quicksilver> IO/ST are strict in their effects
08:57:59 <quicksilver> they aren't strict in any other way
08:58:15 <quicksilver> return undefined >> return 42 is still fine (for example)
08:58:22 <tibbe> right
08:58:30 <tibbe> let me post the code in question
08:58:33 <quicksilver> (lazy ST isn't even strict in its effect, and that's a bit weird)
08:58:42 <tibbe> do arr  <- A.unsafeFreeze p
08:58:43 <tibbe>    let !b = Buffer p (o+u) 0 l
08:58:43 <tibbe>        !t = Text arr o u
08:58:43 <tibbe>    buf' <- inlineInterleaveST (k b)
08:58:43 <tibbe>    return $! t : buf'
08:58:50 <tibbe> does all these ! and $! make sense here?
08:59:00 <quicksilver> return $1 a : b is nonsense in every case
08:59:05 <quicksilver> return $! a : b is nonsense in every case, rather
08:59:11 <tibbe> Text and Buffer are data constructors with only strict fields.
08:59:39 <quicksilver> the !b and !t are probably doing work, then
08:59:48 <quicksilver> they're forcing p, o+u, l, and arr
08:59:48 <tibbe> yes
08:59:55 <tibbe> the core looks different so I assume they are :)
09:01:20 <JoeyA> What does the @ sign mean in Haskell?
09:01:38 <nlogax> bind the value on the right to the name on the left. afaik :)
09:01:40 <tibbe> JoeyA: Gives name to a pattern match.
09:01:49 <exDM69> JoeyA: in the patterns such as: func list@(x:xs) = x : func xs
09:01:50 <cdsmithus> JoeyA: In pattern matching, it allows you to bind a name to the whole expression, and also pattern match it against something
09:02:06 <tibbe> foo a@(SomeConstructor field) = ... field ... a ...
09:02:09 <Saizan> > let xxs@(x:xs) = [1,2,3] in (xxs,x,xs)
09:02:10 <lambdabot>   ([1,2,3],1,[2,3])
09:02:19 <mornfall> It's also a legal operator character (when not alone)...
09:03:23 <JoeyA> I think I found a case where it would have been useful:
09:03:24 <JoeyA> sieve p (c:composites)
09:03:46 <JoeyA> Instead, I could say sieve p composites@(c:cs)
09:04:05 <JoeyA> Do people sometimes use @ notation merely for the sake of documentation?
09:04:11 <Saizan> that gives a different meaning to the composites indentifier
09:04:18 <JoeyA> Understood
09:04:45 <JoeyA> Instead, composites means all of the composites, not the tail end.
09:04:46 <Makoryu> JoeyA: Usually they use it when they don't want to have to reconstruct a value that they pattern matched against
09:05:01 <tibbe> JoeyA: It's useful if the constructor has several fields and you want to avoid mentioning them all to reconstruct the same value
09:05:08 <JoeyA> ah
09:05:31 <tibbe> JoeyA: foo a@(MkFoo b c d e f g h) = if b == 0 then a else ...
09:05:34 <tibbe> instead of
09:05:47 <tibbe> JoeyA: foo a@(MkFoo b c d e f g h) = if b == 0 then MkFoo b c d e f g h else ...
09:06:21 <tibbe> (also, it might save an allocation unless the compiler can see that the constructed MkFoo is the same as the one passed in)
09:14:57 <quicksilver> tibbe: I think it will always save allocation, and the compiler never does that optimisation you suggest.
09:15:01 <quicksilver> (I'm not sure though)
09:15:17 <aristid> > 4 Prelude.* 2
09:15:18 <lambdabot>   8
09:15:22 <aristid> :D
09:15:49 <aristid> i somehow expected qualified operators to behave like functions instead
09:16:43 <zygoloid> aristid: see -XNewQualifiedOperators: http://haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html
09:18:07 <tibbe> quicksilver: it could though, right? there's no risk of introducing space leaks
09:18:13 <Saizan> `Prelude.(-)` <- since using a qualified operator wasn't horrible enough..
09:19:51 <aristid> oh, the hierarchical namespace isn't part of the standard?
09:20:22 <Makoryu> Nope
09:20:43 <quicksilver> tibbe: seems pretty non-controversial to me.
09:21:01 <Saizan> it's part of haskell2010 iirc
09:26:00 <aristid> Saizan: it is
09:28:35 * hackagebot data-accessor-template 0.2.1.4 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-template-0.2.1.4 (HenningThielemann)
09:29:35 <soupdragon> > let z k = exp(k*sqrt(-1)*2*pi/11); w=exp(sqrt(-1)*2*pi/5::Complex CReal)in (z 0+w*z 1+w^2*z 2+w^2*z 3+w^3*z 4+w^4*z 3)^5
09:29:39 <lambdabot>   mueval-core: Time limit exceeded
09:29:45 <soupdragon> can someone please run that for me ? if they have CReal and ghci open
09:29:54 <gwern> @hoogle CReal
09:29:55 <lambdabot> No results found
09:30:05 <soupdragon> oh no!! it's wrong
09:30:11 <soupdragon> > let z k = exp(k*sqrt(-1)*2*pi/11); w=exp(sqrt(-1)*2*pi/5::Complex CReal)in (z 0+w*z 1+w^2*z 2+w^2*z 3+w^3*z 4+w^4*z 5)^5
09:30:13 <gwern> soupdragon: I've noticed that CReal is really slow
09:30:14 <lambdabot>   mueval-core: Time limit exceeded
09:30:26 <soupdragon> I need something more efficent than CReal
09:30:33 <gwern> you might say, that for mueval, those expressions are... CReal killers
09:30:45 <Makoryu> （　≖‿≖）
09:30:49 * hpc groans
09:31:15 <soupdragon> oh man I got the expression totally wrong
09:31:20 <Makoryu> :t exp
09:31:21 <lambdabot> forall a. (Floating a) => a -> a
09:31:54 <Makoryu> > exp (0 :+ pi) :: Complex Rational
09:31:55 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Real.Rational)
09:31:56 <lambdabot>    arising from a u...
09:32:11 <Makoryu> Oh, damn
09:32:12 <Makoryu> Right
09:32:17 * Makoryu facepalms
09:33:02 <soupdragon> > let z k = exp(k*sqrt(-1)*2*pi/11); w=exp(sqrt(-1)*2*pi/5::Complex Double);p = sum.map z in (p[2,9]+w*p[4,7]+w*w*p[8,3]+w*w*w*p[5,6]+w*w*w*w*p[10,1])^5
09:33:03 <lambdabot>   (-398.4796734531111) :+ (-47.591489204503745)
09:33:09 <soupdragon> ^ this is totally no tthe answer I expected :/
09:33:25 <soupdragon> it shouldn't even have a complex part
09:34:08 <soupdragon> very confusing
09:34:51 <aristid> > log (1 :: CReal)
09:34:52 <lambdabot>   0.0
09:40:43 <jmcarthur> > let z k = exp(k*sqrt(-1)*2*pi/11); w=exp(sqrt(-1)*2*pi/5::Complex Double);p = sum.map z in (p[2,9]+w*p[4,7]+w*w*p[8,3]+w*w*w*p[5,6]+w*w*w*w*p[10,1])^5 :: Complex CReal
09:40:44 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
09:40:44 <lambdabot>         against infe...
09:41:59 <jmcarthur> > let z k = exp(k*sqrt(-1)*2*pi/11); w=exp(sqrt(-1)*2*pi/5::Complex CReal);p = sum.map z in (p[2,9]+w*p[4,7]+w*w*p[8,3]+w*w*w*p[5,6]+w*w*w*w*p[10,1])^5 :: Complex CReal
09:42:02 <lambdabot>   mueval-core: Time limit exceeded
09:42:13 <jmcarthur> what should i have expected?
09:42:36 <jmcarthur> oh that was above already
09:42:38 <zygoloid> jmcarthur: well, on my machine it's been going for over a minute already. :D
09:42:47 <jmcarthur> ew
09:44:23 <zygoloid> hmm, that's different from the 16:29 expression :(
09:44:37 <soupdragon> yeah ummmmm
09:44:38 <soupdragon> I made a mistake
09:44:40 <soupdragon> :(
09:44:46 <glguy> :)
09:44:47 <soupdragon> and right now I am still working on correcting it
09:44:54 <mauke> > reverse ":("
09:44:55 <lambdabot>   "(:"
09:46:18 <fryguybob> sort (map reverse happys) == sort sads?
09:47:49 <fryguybob> > sort (map reverse [":D",":)","=)","=D"]) == sort ["D:","):",")=","D="]
09:47:50 <lambdabot>   True
09:47:57 <fryguybob> D:
09:48:45 <zygoloid> soupdragon: p[4,7] == 0
09:48:58 <soupdragon> no way
09:49:02 <soupdragon> that's impossible
09:49:14 <soupdragon> > let z k = exp(k*sqrt(-1)*2*pi/11); w=exp(sqrt(-1)*2*pi/5::Complex CReal);p = sum.map z in p[4,7]
09:49:15 <lambdabot>   NaN
09:49:15 <zygoloid> as is p[10,1]
09:49:27 <aristid> NaN as in joy.
09:49:32 <soupdragon> > let z k = exp(k*sqrt(-1)*2*pi/11::Complex CReal);p = sum.map z in p[4,7]
09:49:36 <lambdabot>   (-1.3097214678905701281138501449325871063676) :+ 0.0
09:49:46 <soupdragon> > let z k = exp(k*sqrt(-1)*2*pi/11::Complex CReal);p = sum.map z in p[10]*p[1]
09:49:50 <lambdabot>   mueval-core: Time limit exceeded
09:50:43 <aristid> why does this seemingly simple code exceed time limits so fast?
09:50:55 <zygoloid> you want p[10]*p[1] not p[10,1]?
09:51:02 <soupdragon> p[10]*p[1] = -1
09:51:20 <soupdragon> or maybe just +1
09:51:23 <soupdragon> I don't know anymore
09:52:10 <zygoloid> > ((-2.6135925147083554289380779960240380239363) :+ 0.9606505128988543887158696438374830277124) ^ 5
09:52:12 <lambdabot>   31.675752607803872 :+ 164.38333243261243
09:52:17 <zygoloid> ^^ there's your answer :P
09:52:27 <soupdragon> dammit
09:52:44 <Makoryu> soupdragon: Are you intentionally golfing your code, or do you just like writing function application without spaces?
09:52:44 <zygoloid> wow, the Complex Double form was out by a /lot/
09:53:18 <soupdragon> Makoryu neither
09:54:06 <trofi> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25444#a25444 <- internal server error :[
09:54:22 <Makoryu> > let p = "Mongeese in space" in p !! 8
09:54:23 <lambdabot>   ' '
09:54:27 <Makoryu> > let p = "Mongeese in space" in p[8]
09:54:28 <lambdabot>   Couldn't match expected type `[t1] -> t'
09:54:28 <lambdabot>         against inferred type `[GH...
09:55:12 <zygoloid> > let p = ("Mongeese in space"!!).head in p[8]
09:55:13 <lambdabot>   ' '
09:59:50 <rajeshsr> > > iterate (+1) 1
09:59:51 <lambdabot>   <no location info>: parse error on input `>'
10:00:19 <rajeshsr>  > iterate (+1) 1
10:00:21 <rajeshsr> > iterate (+1) 1
10:00:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:00:29 <aristid> @src iterate
10:00:29 <lambdabot> iterate f x =  x : iterate f (f x)
10:01:49 * hackagebot hums 0.2.6 - Haskell UPnP Media Server  http://hackage.haskell.org/package/hums-0.2.6 (BardurArantsson)
10:06:41 <stulli> Where can i find a parser for Haskell source code?
10:07:08 <gwern> stulli: haskell-src-exts?
10:07:33 <rajeshsr> :t genericTake
10:07:33 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
10:07:34 <zygoloid> stulli: what do you want to do with it? sometimes you might be better off with template haskell
10:08:02 <rajeshsr> :t findIndex
10:08:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
10:08:36 <rajeshsr> forall a i. (Integral b) => (a -> Bool) -> [a] -> Maybe b
10:08:44 <rajeshsr> @hoogle forall a i. (Integral b) => (a -> Bool) -> [a] -> Maybe b
10:08:44 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
10:08:44 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
10:08:44 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
10:08:56 <stulli> gwern: thanks, that looks good
10:10:14 <stulli> zygoloid: I want to learn parsing haskell source code :) Maybe i will do some fun metrics with it
10:10:36 <zygoloid> sounds like a fun project :)
10:10:40 <gwern> stulli: hlint is probably a good example user
10:11:01 <pastorn> how should i write a Monad alias using list and state?
10:11:11 <pastorn> ListT (State s) a+
10:11:14 <pastorn> ?
10:11:16 <pastorn> or
10:11:22 <pastorn> StateT s [a]?
10:12:14 <stulli> I think it would be useful for the Scion project where i'd like to participate a bit in summer
10:12:30 <gabl> http://de.threadless.com/product/1646/Life_is_like_a_box_of_terrible_analogies
10:13:02 <pastorn> so this is basically what i have:
10:13:52 <pastorn> [ calcCost x y | x <- xs, y <- ys ] -- but for each y i'm only interested in the minimum cost for all x's
10:14:07 <pastorn> (calcCost is a State computation)
10:14:24 <zygoloid> pastorn: when the list monad backtracks, do you want it to keep the state or revert it?
10:14:50 <pastorn> zygoloid: each x is a new state
10:15:21 <pastorn> maybe that should be 'runState (calcCost y) x'
10:15:57 <pastorn> @type execState
10:15:58 <lambdabot> forall s a. State s a -> s -> s
10:16:07 <pastorn> no, eval is what i meant
10:17:07 <zygoloid> pastorn: it sounds like you want a monad like: state -> [(state, a)].
10:17:27 <zygoloid> @unmtl StateT s [] a
10:17:28 <lambdabot> s -> [(a, s)]
10:17:47 * Accidus grumbles about "Our construction [..] extends routinely to a functor...".
10:17:56 <Accidus> I don't see the extension!
10:18:05 <glguy> use the routine?
10:18:13 <rajeshsr> :t flip
10:18:14 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:18:20 <rajeshsr> @src flip
10:18:21 <lambdabot> flip f x y = f y x
10:18:21 <pastorn> zygoloid: ok, so what i'm doing is that i have entered all my phonebills into a [BillEntry] and then written a [Contract] which is the cost profiles for the different subscriptions that the carrier gives
10:18:29 <Makoryu> @unmtl ReaderT m IO
10:18:29 <lambdabot> err: `ReaderT m IO' is not applied to enough arguments, giving `/\A. m -> IO A'
10:18:44 <pastorn> zygoloid: now what i want to do is to calculate the best subscription for each of my bills
10:18:51 <Makoryu> @unmtl ReaderT m IO a
10:18:52 <lambdabot> m -> IO a
10:19:15 <pastorn> it has to be a Stateful computation since some contract specifies free minutes
10:19:41 <pastorn> (so i might subtract first the land line calls from the free minutes, then the calls to other carriers etc.)
10:19:49 <edwardk> pastorn: something like: fmap (\y -> minimum (map (calcCost y) xs)) ys
10:20:20 <pastorn> edwardk: yes, but would that preserve state?
10:20:51 <pastorn> lets call contracts (the state variables) c:cs and bills b:bs (to lessen the confusion for poor me)
10:20:53 <edwardk> that will run calcCost for each x y pair, returning a list of each of the minimum x's for each y.
10:32:26 <osaunders> How might I resolve this link error when connecting to Sqlite3 DB: <http://codepad.org/EXGGgRih>?
10:33:08 <c_wraith> is that on ghc 6.10.x?
10:33:24 <osaunders> 6.10.4
10:33:31 <c_wraith> osx 10.6?
10:33:38 <osaunders> 10.5
10:33:44 <c_wraith> hmm...  Not sure about 10.5
10:33:49 <osaunders> 10.5.8
10:33:52 <c_wraith> 10.6 has lots of typical linker problems
10:34:23 <osaunders> I get the impression database access isn't a very mature area for Haskell.
10:34:46 <cdsmithus> osaunders: HDBC works fine, I've never had issues with it
10:34:54 <rajeshsr> this is offtopic but i think someone here can help me.
10:35:07 <osaunders> cdsmithus: That is HDBC, is it not?
10:35:11 <rajeshsr> can anyone give a proof as to why x[i] = x[2*i] for some i > \mu and a multiple of \lambda in Floyd's cycle detection algorithm: http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare ?
10:35:24 <c_wraith> So most of my suggestions for osx 10.6 go out the window...  (if you installed the lib, did you install universal binaries?  Do you have ghc configured to use all the correct -m32 or whatever it is flags?)
10:35:34 <cdsmithus> osaunders: Yes, but the problem seems to be more one of build tools on your platform, not the library
10:35:41 <rajeshsr> \mu = start index of cycle, \lambda = loop length
10:37:00 <osaunders> c_wraith: I didn't install any sqlite library that I'm aware.
10:37:34 <osaunders> Just a sqlite3 macport.
10:37:54 <Saizan> osaunders: http://hackage.haskell.org/trac/ghc/ticket/2578 -- might be helpful?
10:37:59 <Makoryu> osaunders: Isn't there already an sqlite3 installation on OS X?
10:38:00 <c_wraith> osaunders: That's the library.  But I don't know if the +universal variant matters on osx 10.5
10:38:57 <osaunders> Oh, I didn't realize the build is actually working those are just warnings.
10:39:11 <c_wraith> heh. apparently no one does
10:39:46 <osaunders> c_wraith: sudo port info sqlite3 says I'm using the universal variant.
10:40:04 <osaunders> Well anyway, I guess it doesn't matter too much now. :-)
10:40:10 <c_wraith> yeah, I think the linker problems I've dealt with only exist on 10.6
10:41:11 <osaunders> Looks like they fixed this problem so I guess I should upgrade to GHC 6.12
10:41:24 <osaunders> Makoryu: Maybe but it's probably old.
10:42:24 <soupdragon> > product [1..5]
10:42:25 <lambdabot>   120
10:44:55 <fizruk> hi all! i have tree-like structure with many different kind of nodes. each node type is an instance of Pretty class, having method (pretty :: a -> Text.PrettyPrint.HughesPJ.Doc).
10:45:31 <fizruk> i want to wrap result of pretty for some nodes in, say, html tags
10:46:21 <fizruk> am i right that the only way is to rewrite those pretty instances for my special case?
11:04:27 <osaunders> @hoogle (Read r) => String -> Maybe r
11:04:28 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
11:04:28 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
11:04:28 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
11:04:43 <BMeph> fizruk: 1) Is your tree-like structure a type? 2) Is your tree-like structure an instance of Pretty? 3) Do you want to do anything different with the other nodes in your structure?
11:06:15 <BMeph> fixruk: 4) Are all of the special wrapped-result nodes members of one type?
11:09:29 <pastorn> wtf i this?
11:09:35 <pastorn> > mfix Just
11:09:39 <lambdabot>   mueval-core: Time limit exceeded
11:09:48 <hellyeah> Hi
11:09:49 <pastorn> it prints Just... but i don't get it
11:09:59 <Makoryu> :t mfix Just
11:10:01 <lambdabot> forall a. Maybe a
11:10:02 <c_wraith> @src MonadFix
11:10:02 <pastorn> hellyeah: hello
11:10:02 <lambdabot> class (Monad m) => MonadFix m where
11:10:02 <lambdabot>     mfix :: (a -> m a) -> m a
11:10:03 <Saizan> pastorn: do you understand fix?
11:10:12 <pastorn> Saizan: not really :(
11:10:20 <c_wraith> :t mfix . return
11:10:21 <lambdabot> forall a (m :: * -> *). (MonadFix m) => m a -> m a
11:10:23 <hellyeah> I am reading right now realworldhaskell and I am confused because the authoer keeps using "$" since severa chapters withouteven mentioning what $ is
11:10:31 <hellyeah> the authoer doesnt even say that he will explain it later
11:10:32 <Saizan> then you have little hope of understanding mfix!
11:10:49 <Saizan> http://www.vex.net/~trebla/haskell/fix.xhtml
11:10:51 <c_wraith> @src ($)
11:10:51 <lambdabot> f $ x = f x
11:10:51 <Makoryu> hellyeah: Yeah I hate that
11:11:00 <hellyeah> yeah
11:11:05 <pastorn> hellyeah: in ghci:
11:11:07 <pastorn> :t ($)
11:11:08 <lambdabot> forall a b. (a -> b) -> a -> b
11:11:11 <hellyeah> lambdabot, and what is it for?
11:11:12 <c_wraith> rwh a much better *second* haskell book
11:11:16 <Makoryu> hellyeah: So, function application (f x) is a higher precedence than any operator
11:11:29 <Makoryu> hellyeah: Whereas ($) is defined as the lowest precedence of any operator
11:11:36 <fizruk> BMeph: 1) yes, it's actually AST 2) yes, and each node is also an instance of Pretty 3) i want to translate AST to html, highlighting interesting elements 4) is there any difference whether they are or not?
11:11:46 <edwardk> Makoryu: (except @ and ~)
11:11:55 <edwardk> and {}
11:11:58 <edwardk> ;)
11:12:18 <c_wraith> edwardk: @ and ~ aren't operators.  {} is though, I suppose.
11:12:24 <Makoryu> hellyeah: So if you want to apply a function to a complicated expression, or you're getting a function from a complicated expression and you want to apply it to something, you sick $ in between to save yourself some parens
11:12:36 <Saizan> not really an operator, though something in expressions at least :)
11:13:06 <edwardk> just pointing them out as the oddities that trip folks up ;)
11:13:49 <hellyeah> oh
11:13:53 <hellyeah> ty Makoryu
11:14:05 <hellyeah> so I oculd actually omit $ by puttign some parantheses?
11:14:21 <c_wraith> yeah.  It gets ugly fast.
11:14:41 <Makoryu> > unwords . sort `on` length . words $ "Lorem ipsum et cetera"
11:14:42 <lambdabot>   Precedence parsing error
11:14:42 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
11:14:45 <Makoryu> Whoops
11:14:50 <Makoryu> > unwords . (sort `on` length) . words $ "Lorem ipsum et cetera"
11:14:51 <lambdabot>   Couldn't match expected type `[a] -> c' against inferred type `[a]'
11:15:09 <hellyeah> hm okay
11:15:20 <hellyeah> but I dont get how to put parantheses if I oit the $ here:
11:15:21 <hellyeah> main = putStrLn "Name??" >> getLine >>= (\inp -> putStrLn $ "hi "++inp++"!!!")
11:15:39 <c_wraith> Makoryu: you want sortBy I think
11:15:43 <c_wraith> :t sortBy
11:15:44 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
11:15:52 <Makoryu> c_wraith: Yeah, I just kicked myself for making that mistake :p
11:16:22 <fizruk> BMeph: the problem is that pretty for, say, statement is defined with use of pretty for expression. so if i want to highlight (wrap this html tag) expression -- i need to write some function that implements pretty for statement but using another function to get pretty expression
11:16:45 <Makoryu> hellyeah: Everything after the $ and before the )
11:16:48 <hellyeah> if UI put some parantherses asounr putStrLn  "hi "++inp++"!!!" , it doesnt work
11:16:53 <hellyeah> oh
11:16:54 <hellyeah> ok
11:16:55 <hellyeah> sry
11:17:11 <hellyeah> aah ty =)
11:17:13 <hellyeah> now got it
11:17:15 <hellyeah> :)
11:17:22 <Zao> hellyeah: You're welcome.
11:17:24 <Makoryu> hellyeah: "foo $ bar ++ baz" == "foo (bar ++ baz)"
11:17:29 <hellyeah> ty
11:17:39 <Makoryu> hellyeah: You can substitute pretty much any operator for (++) there
11:18:22 <fizruk> BMeph: hm... i can define separate module with Pretty' class and redirect pretty' to pretty by default and then write pretty' for nodes, i am interested in
11:21:20 <BMeph> fizruk: I'd recommend that, especially since that's "really" what you're doing - you're changing some of the functionality of Pretty, but not all of it.
11:21:38 <pastorn> @pl (\r -> fromIntegral (calls be) * openingFee r)
11:21:38 <lambdabot> (fromIntegral (calls be) *) . openingFee
11:22:12 <gwern> > newtype CharAznable a = Red a
11:22:13 <lambdabot>   <no location info>: parse error on input `newtype'
11:22:26 <gwern> makes it go faster
11:26:22 <Baughn> @hoogle m a -> (a -> m ()) -> m a
11:26:23 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:26:23 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:26:23 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:26:41 * gwern is always surprised at the lack of gundam jokes here, especially with a key language feature like 'newtype'
11:26:51 <fizruk> BMeph: it seems to me that i should write some generalization of Pretty class so that i could modify pretty output...
11:26:54 <winxordie> gwern: I was waiting for that.
11:27:01 <Baughn> gwern: Please don't seed this joke
11:27:07 <gwern> Baughn: why ever not?
11:27:18 <gwern> the ghcommu - it tells me - Baughn is my enemy!
11:27:18 <Makoryu> And now, in anticipation of your insight into the future...
11:27:26 <Baughn> gwern: It is not your destiny.
11:27:37 <gwern> how could you ever understand?
11:27:40 * Baughn would rage against destiny, anyway
11:28:03 <gwern> you're just weak and afraid of my humorous power!
11:29:58 <rajeshsr> i saw a code that has f = fmap . fmap . fmap
11:30:07 <gwern> @quote fmap.*fmap
11:30:07 <lambdabot> No quotes match. My brain just exploded
11:30:13 <gwern> oh good grief
11:30:17 <Makoryu> :t fmap `fmap` fmap `fmap` fmap
11:30:18 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
11:30:23 <rajeshsr> why would anyone have something like that, and that too operating with just lists and pairs!
11:30:35 <gwern> rajeshsr: multiple layers of abstraction?
11:30:41 <pikhq> :t fmap . fmap . fmap
11:30:42 <Baughn> :t (fmap . fmap) `fmap`
11:30:42 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
11:30:43 <lambdabot> parse error (possibly incorrect indentation)
11:30:44 <pikhq> Mmm, generalism.
11:30:50 <Baughn> :t fmap (fmap . fmap)
11:30:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f2 (a -> b) -> f2 (f (f1 a) -> f (f1 b))
11:30:53 <jmcarthur> i use such idioms a lot
11:30:55 <pastorn> rajeshsr: i.e. [Map k (Maybe v)]
11:31:09 <c_wraith> :t (.) (.) (.)
11:31:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:31:20 <jmcarthur> caleskell needs to die
11:31:22 <pikhq> :t fmap fmap fmap fmap fmap fmap
11:31:23 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
11:31:25 <pastorn> :t ((.) . (.))
11:31:26 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:31:30 <pikhq> Aaaw.
11:31:35 <rajeshsr> pastorn, Map is a monad?
11:31:39 <pastorn> @let tits = ((.) . (.))
11:31:40 <lambdabot>  Defined.
11:31:44 <pastorn> rajeshsr: no, but i Functor
11:31:45 <jmcarthur> rajeshsr: it's a Functor
11:31:57 <jmcarthur> if its semantics were slightly different it could have been a monad
11:32:08 <rajeshsr> ha, fmap works with functor! Anyway i do not know the distinction yet!
11:32:24 <rajeshsr> so what does fmap do on a map?
11:32:32 <rajeshsr> does fmap do anything on pairs?
11:32:40 <c_wraith> @instances Functor
11:32:40 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:32:41 <jmcarthur> rajeshsr: (a -> b) -> (Map k a -> Map k b)
11:32:45 <jmcarthur> yes
11:32:56 <jmcarthur> rajeshsr: (a -> b) -> (c, a) -> (c, b)
11:33:28 <rajeshsr> jmcarthur, applies to snd?
11:33:31 <heatsink> Is there a particular convention that the first element of the pair is the invariant one?
11:33:36 <jmcarthur> right
11:33:39 <gwern> > fmap (+1) (2,2)
11:33:40 <lambdabot>   (2,3)
11:33:44 <Makoryu> @unpl second (+1)
11:33:44 <lambdabot> second (\ a -> a + 1)
11:33:50 <pastorn> rajeshsr: so for [ Map k (Maybe v) ], fmap . fmap . fmap is perfectly reasonable (i would have renamed the first one to 'map' though) for doing transformations on all v:s
11:33:51 <gwern> hm. I was not expecting that
11:34:10 <gwern> I thought fmap on (a,b) would = (f a, f b)
11:34:11 <jmcarthur> rajeshsr: it's *almost* the same as Control.Arrow.second, but there is a subtle difference
11:34:23 <gwern> why does it only modify the second?
11:34:25 <heatsink> gwern: That wouldn't type though
11:34:44 <soupdragon> gwern, the functor is  (,) a :: * -> *
11:34:45 <Makoryu> gwern: Because the semantics of Functor are not that flexible....
11:34:46 <heatsink> gwern: I'm guessing it's supposed to be analogous to the State monad
11:34:47 <djahandarie> > fmap (+1) (2,2,2)
11:34:48 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t t1))
11:34:48 <lambdabot>    arising from a use of `e_...
11:34:50 <rajeshsr> pastorn, hmm! ok.
11:34:52 <gwern> @quote BASIC
11:34:52 <jmcarthur> gwern: Functor works on things of kind * -> *, so (,) a :: * -> * is the functor
11:34:52 <lambdabot> arw says: ...and a basic law of haskell is, 50% of all documentation has to be monad tutorials :)
11:34:52 <soupdragon> rather than  (,) :: * -> * -> *
11:35:15 <rajeshsr> the code am referring to is Reid's solution for problem C at GCJ. very elegant use of haskell!
11:35:18 <heatsink> @quote applicative
11:35:19 <lambdabot> applicative says: if you are only beginning to learn Haskell, don't let them talk to you about monads. ask them about fmap
11:35:42 <Makoryu> gwern: We do still have arrows for nicer, more flexible pair semantics
11:35:43 <Makoryu> ¯\O_o/¯
11:36:10 <jmcarthur> arrows aren't very nice. they have some conveniences, is all
11:36:14 <rajeshsr> what does @quote do?
11:36:26 <heatsink> It remembers.
11:36:34 <heatsink> @quote
11:36:34 <lambdabot> buttbot2 says: "I butt you so you can butt the best butt whenever you butt your butt hole."
11:36:36 <jmcarthur> it gives quotations that people told lambdabot to remember at some earlier time
11:36:43 <Makoryu> rajeshsr: It looks up a memorable quote from somebody in the channel.
11:36:52 <djahandarie> @quote djahandarie
11:36:52 <lambdabot> djahandarie says: I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
11:36:54 <gwern> @quote Dijkstra
11:36:54 <c_wraith> who told lambabot to remember *that*?
11:36:54 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
11:36:55 <lambdabot> regeneration."
11:36:58 <int-e> for example, you could type @remember rajeshsr what does @quote do?
11:36:58 <rajeshsr> cool!!
11:37:06 <int-e> and @quote would then know about that quote
11:37:09 <gwern> no, not cool. it is a terrible responsibility
11:37:37 <rajeshsr> haha!
11:37:46 <djahandarie> I wonder if 50% of quotes in the Haskell channel also have to be about monads...
11:37:57 <gwern> @quote
11:37:57 <int-e> @quote quotes
11:37:57 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
11:37:58 <lambdabot> kamatsu says: it should be possible to automate HWN: take every ANN topic from haskell-cafe, some of the top-voted haskell reddit submissions, and all remembered quotes from #haskell in the last
11:37:58 <lambdabot> week
11:38:02 <gwern> @quote
11:38:03 <lambdabot> neuraxon77 says: With a concatenative language the only construct is the monoid, and structuring a language with this in mind makes all types optional
11:38:14 <rajeshsr> So, how does a functor differs from a monad? I have known fmap only in relation with monads
11:38:17 <gwern> well, monoids don't really count as a mention of monads
11:38:29 * hackagebot happs-tutorial 0.9.5 - A Happstack Tutorial that is its own web 2.0-type demo.  http://hackage.haskell.org/package/happs-tutorial-0.9.5 (ThomasHartman)
11:38:31 <dpratt71> as someone who has used VB6 almost every day for the last 12+ years, I find that quote...amusing
11:38:46 <jmcarthur> rajeshsr: monads can do everything functors can and more
11:39:24 <Makoryu> rajeshsr: http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
11:39:24 <heatsink> Why isn't Functor a superclass of Monad?
11:39:39 <Makoryu> heatsink: Because certain parts of the Prelude were poorly planned.
11:39:45 <rajeshsr> jmcarthur, hmm, ok!
11:39:46 <heatsink> ah.
11:40:02 <djahandarie> I'm creating a new complexity theory class... BMM... Bounded Error Monad Mentions
11:40:10 <djahandarie> #haskell falls in it
11:40:22 <Makoryu> heatsink: Look on the bright side. At least it was better planned than, say, Java  ┐(　´〰`)┌
11:40:38 <djahandarie> And it is entirely disjoint from all other classes
11:40:42 <olsner> #haskell fails in a bounded error monad?
11:41:35 <rajeshsr> Makoryu, i second that moands aren't as important as i thought! I was stuck up trying to make complete sense of them. From last week, i have made significant progress in haskell, by simply coding! I think my understanding of monads will get good soon!
11:41:37 <gwern> Makoryu: is that an emoticon with a mustache?
11:41:48 <heatsink> Makoryu: But how can Java be badly planned when it has such an abundance of classes? *cough*
11:42:06 <djahandarie> (=゜ω゜)人(゜ω゜=)
11:42:11 <Makoryu> rajeshsr: I like hearing that :p
11:42:16 <Makoryu> gwern: ....It could be.
11:43:01 <rajeshsr> Makoryu, well, i won't say i understand moands well now! :)
11:43:12 <fizruk> BMeph: writing separate module doesn't solve the problem ) copypaste needed ))
11:44:28 <gwern>  lambda: the ultimate condiment
11:46:37 <osaunders> > (M.fromList a b, M.fromList b a) [(1,2), (3,4)]
11:46:38 <lambdabot>   Couldn't match expected type `[(k, a)]'
11:46:38 <lambdabot>         against inferred type `Simp...
11:46:39 <olsner> lambda <-> condiment, how?
11:46:50 <hellidunno> OO
11:47:17 <heatsink> Not much OO here, maybe try #java
11:47:47 <hellidunno> nah I just got disconnected form freenode
11:48:05 <hellidunno> * You have been killed by NickServ (command used by xyz!~xyz@78.185.142.75))
11:48:05 <osaunders> Why does this work :-(  > mapsFromList a b = (M.fromList a b, M.fromList b a)
11:48:09 <osaunders> *doesn't
11:48:30 <olsner> fromList takes exactly one list to turn into a map
11:49:00 <byorgey> osaunders: maybe you want something like  (M.fromList (zip a b), M.fromList (zip b a))
11:49:10 <heatsink> hellidunno: By NickServ?  I think that should only happen if someone else has the password for your name.
11:49:23 <hellidunno> hmm
11:49:25 <hellidunno> weird
11:49:27 <osaunders> Dammit.
11:49:32 <osaunders> Such a silly blunder.
11:49:33 <hellidunno> nvm
11:49:35 <osaunders> Thanks guys.
11:49:48 <hellidunno> oh the other nick was regged okay nvm
11:50:21 <byorgey> osaunders: no worries.  but this is what types are for =)
11:53:03 <osaunders> byorgey: For catching silly blunders? Yes, they do a very good job of that, which is good because I make plenty.
11:53:15 <osaunders> I'm a blunder factory.
11:54:45 <gwern> > let (><>) = ((flip ($)) (foldr ((:) . succ) [] "hs&r\US`\USehrg") $ (.) const const) in "what is this" ><> "i don't know"
11:54:46 <lambdabot>   "it's a fish"
11:54:56 <BMeph> osaunders: Naugh, you're just a Blunder Visitor... ;)
11:55:03 <gwern> @remember chmod666 > let (><>) = ((flip ($)) (foldr ((:) . succ) [] "hs&r\US`\USehrg") $ (.) const const) in "what is this" ><> "i don't know"
11:55:04 <lambdabot> I will remember.
11:55:08 <gwern> @quote fish
11:55:08 <lambdabot> No quotes match. stty: unknown mode: doofus
11:55:17 <dpratt71> BMeph: :)
11:55:22 <gwern> @quote useh
11:55:23 <lambdabot> chmod666 says: > let (><>) = ((flip ($)) (foldr ((:) . succ) [] "hs&r\US`\USehrg") $ (.) const const) in "what is this" ><> "i don't know"
11:55:28 <gwern> @flish
11:57:25 <byorgey> hehe
11:57:42 <byorgey> osaunders: so's everyone.
11:59:34 <hellidunno> grr, sry but what wasthe name of the function that inserted a certai nelement inbetween everyelement of a list
11:59:35 <hellidunno> like
11:59:48 <byorgey> intersperse
11:59:53 <hellidunno> functionname 0 [1,2,3] ----> [1,0,2,0,3]
11:59:54 <hellidunno> ah ty
11:59:56 <hellidunno> :)
11:59:57 <osaunders> Is there a way to set an include path in GHC?
11:59:58 <hellidunno> :)
12:00:11 <hellidunno> not native speaker here, so a bit hard to remember that word xD
12:00:22 <osaunders> BBL
12:00:33 <byorgey> hellidunno: you can also use hoogle to search for functions by type
12:00:39 <byorgey> @hoogle a -> [a] -> [a]
12:00:40 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
12:00:40 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
12:00:40 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
12:00:56 <hellidunno> cool
12:01:00 <hellidunno> haven't known that lol :D
12:01:17 <byorgey> there is a web interface at haskell.org/hoogle
12:01:24 <byorgey> it even links right to the documentation
12:01:41 <hellidunno> veery good
12:10:22 <rajeshsr> :t fmap . fmap . fmap fst [(Maybe, [a])]
12:10:22 <lambdabot> Not in scope: data constructor `Maybe'
12:10:46 <heatsink> The data constructors are Just and Nothing
12:10:51 <edlinde> was wondering if haskell is good to use for ANY kind of project?
12:10:58 <rajeshsr> :t fmap . fmap . fmap fst [(Maybe b, [a])]
12:10:59 <edlinde> I know nothing about haskell :)
12:10:59 <lambdabot> Not in scope: data constructor `Maybe'
12:11:07 <edlinde> http://codepad.org/FxRcp2YQ
12:11:09 <rajeshsr> :t fmap . fmap . fmap fst [(Just b, [a])]
12:11:09 <lambdabot>     Couldn't match expected type `a -> b'
12:11:10 <lambdabot>            against inferred type `Maybe Expr'
12:11:10 <lambdabot>     In the expression: Just b
12:11:35 <edlinde> some guys implemented some cryptography work using common lisp
12:11:46 <edlinde> was wondering if the same can easily be done in Haskell?
12:11:47 <jlouis> Saizan: success :P http://jlouis.github.com/combinatorrent/
12:11:49 <rajeshsr> :t fmap fst [(Just 1, [1..10])]
12:11:49 <lambdabot> forall t. (Num t) => [Maybe t]
12:11:53 <rajeshsr> > fmap fst [(Just 1, [1..10])]
12:11:54 <lambdabot>   [Just 1]
12:12:27 <rajeshsr> >fmap . fmap fst [(Just 1, [1..10])]
12:12:31 <rajeshsr> > fmap . fmap fst [(Just 1, [1..10])]
12:12:31 <lambdabot>   Couldn't match expected type `a -> b'
12:12:32 <lambdabot>         against inferred type `Data.M...
12:12:33 <edlinde> any ideas?
12:12:51 <jlouis> edlinde: there is a guy who implemented a crypto protocol shape analyzer for Haskell and then made it parallel in an hour
12:13:04 <roconnor> @faq can Haskell be used to implement cryptography as easily as in Lisp?
12:13:04 <lambdabot> The answer is: Yes! Haskell can do that.
12:13:08 <sizzler> Hi anyone whether the project http://code.google.com/p/hoc/source/list is still under development ?
12:13:12 <edlinde> jlouis: shape analyzer?
12:13:14 <sizzler> ~knows
12:13:46 <edlinde> jlouis: are there libraries to use to say compute a MD5 hash etc... or have hash lookup tables in haskell?
12:14:06 <edlinde> jlouis: or is this very easily implemented in Haskell by yourself?
12:14:15 <jlouis> edlinde: http://hackage.haskell.org/package/cpsa
12:14:31 <jlouis> edlinde: In my app, I call OpenSSL for my SHA1 needs
12:14:58 <edlinde> so its like a system call?
12:15:10 <jlouis> edlinde: more or less, it is bindings to the C library
12:15:23 <edlinde> I intend to learn a functional language this summer... and haskell is the top on my list :)
12:15:37 <edlinde> jlouis: yeah I am more a C and C++ person
12:16:25 <edlinde> jlouis: just that we did an assignment and our group wrote the stuff in C ... another group wrote it in Java writing 50 million lines of code :) while the lisp guys did the same in much less code and they achieve decent speeds too
12:16:32 <edlinde> not as slow as the java stuff
12:16:39 <Baughn> jlouis: You need SHA1, specifically? SHA2 won't work?
12:16:45 <rajeshsr> :t fmap . fmap
12:16:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:16:51 <jlouis> Baughn: SHA1. BitTorrent uses SHA1
12:16:55 <HugoDaniel> hello
12:17:09 <edlinde> so is haskell hard to learn?
12:17:17 <Baughn> edlinde: All things have a cost.
12:17:22 <edlinde> for a complete newbie with a C/C++ background
12:17:28 <jlouis> edlinde: I'd argue C++ is harder in some sense
12:17:38 <edlinde> yeah I can see what you mean
12:17:42 <Baughn> edlinde: For haskell, being a newbie at C/C++ is a /good/ thing
12:17:46 <roconnor> C++ is freaking impossible
12:17:55 <PeakerWork> edlinde: It will take time, and some effort.. Not sure if it will be "hard".. If it is fun, is it still considered hard?
12:17:58 <edlinde> but I mean is the transition really from this OO paradigm to functional
12:18:00 <jlouis> roconnor: indeed :)
12:18:03 <rajeshsr> edlinde, yep! :) But don't make the mistake of learning it all and then coding! just take up some interesting problem you want to solve and force yourself to solve it with haskell!
12:18:05 <edlinde> thinking functionally :)
12:18:19 <Baughn> roconnor: What is rewriting C++ programs for which you only have /some/ of the source code and have to know how you can alter classes without breaking the ABI, then?
12:18:27 <jlouis> the key to Haskell is very simple. Do.not.fucking.give.up.
12:18:36 <edlinde> jlouis: :)
12:18:47 <rajeshsr> fmap . fmap (+1) [Just 1, Just 2]
12:18:47 <Baughn> edlinde: And find a thesis you can write using it, forcing yourself to keep going. ;)
12:18:51 <rajeshsr> > fmap . fmap (+1) [Just 1, Just 2]
12:18:52 <lambdabot>   Couldn't match expected type `a -> b'
12:18:52 <lambdabot>         against inferred type `Data.M...
12:18:55 <edlinde> after summer I do a course in FP.. we get taught SML though
12:19:00 <PeakerWork> > (fmap . fmap) (+1) [Just 1, Just 2]
12:19:01 <lambdabot>   [Just 2,Just 3]
12:19:02 <rajeshsr> > fmap . fmap (+1) $ [Just 1, Just 2]
12:19:03 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
12:19:09 <jlouis> edlinde: SML is a fine way into the game
12:19:11 <edlinde> but I want to learn haskell instead of ML
12:19:19 <jlouis> edlinde: I programmed SML for about 8 years
12:19:26 <rajeshsr> PeakerWork, can you explain what is wrong with mine?
12:19:31 <Baughn> jlouis: As I was going to say, though. Careful: I've had crashes and memory corruption when using openssl from haskell.
12:19:31 <edlinde> can I transfer any of the haskell skills to ML?
12:19:36 <PeakerWork> rajeshsr: prefix has precedence over everything else, so yours is:  fmap . (fmap (+1)) ...
12:19:41 <jlouis> edlinde: You will learn that the ideas from SML carries over
12:19:44 <PeakerWork> @type fmap . fmap (+1)
12:19:44 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Num a1) => (a -> a1) -> f a -> f a1
12:19:52 <Baughn> jlouis: It's why I wrote the SHA2 and AES libraries. But it doesn't support SHA1, so.. sorry...
12:19:59 <PeakerWork> rajeshsr: note that's not quite:
12:20:03 <PeakerWork> @type (fmap . fmap) (+1)
12:20:04 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1, Num a) => f (f1 a) -> f (f1 a)
12:20:07 <jlouis> Baughn: hopenssl has not crashed for me yet
12:20:08 <edlinde> jlouis: so you would recommend me to learn SML first and then Haskell?
12:20:14 <jmelesky> i'm still a big fan of SML, but it's very clear that haskell has a bigger community and fuller suite of libraries available
12:20:22 <jlouis> edlinde: if you can get credit for doing SML...
12:20:22 <Baughn> jlouis: It was some kind of race condition, I think.
12:20:25 <edlinde> SML zealots at uni love it and say its much cleaner etc etc
12:20:32 <jlouis> edlinde: where is here?
12:20:34 <PeakerWork> jmelesky: How can you give up laziness? :)
12:20:43 <rajeshsr> PeakerWork, BTW, what it means to apply "." for a function taking two parameters. I guess that is where i have got stuck!
12:20:44 <edlinde> sweden
12:20:57 <jmelesky> PeakerWork: i make up for it by being able to predict my memory usage. :)
12:21:02 <PeakerWork> rajeshsr: All functions are of 1 argument :)
12:21:03 <Saizan> jlouis: you got it down to the CPU use of etorrent?
12:21:06 <rajeshsr> @t (+) . (-)
12:21:06 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:21:08 <edlinde> also very much into Erlang
12:21:21 <jlouis> edlinde: curious! SML is cleaner in that it has a formal operational semantics formalized in Twelf of all things
12:21:23 <edlinde> jlouis: so how would you recommend getting started?
12:21:25 <rajeshsr> :t (+) . (-)
12:21:25 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
12:21:27 <PeakerWork> rajeshsr: (a -> b -> c) == (a -> (b -> c))       so if you unify  (a -> b)   with (c -> d -> e)        you get   a = c,  b = (d -> e)
12:21:50 <edlinde> jlouis: I was thinking of "Learn yourself a haskell" and working through that
12:21:52 <jlouis> edlinde: SML is fine. So is Haskell. I have no recommendation of one over the other
12:21:55 <PeakerWork> rajeshsr: if you take (-)'s result, it is a (Num t => t -> t), so if you try to give that as an arg to (+), that's why you get a (Num (a -> a)) arg to (+) there
12:21:56 <jlouis> Saizan: yeah !
12:22:02 <Baughn> edlinde: IMHO, Haskell is the most advanced functional programming language /that is also useful for writing large, useful systems/. But I have to hide now.
12:22:07 <Saizan> jlouis: cool
12:22:22 <jmelesky> edlinde: SML is a great language, and it's smaller and will fit in your head easier than haskell. but haskell is actually growing, where sml is, well, not so much.
12:22:25 <Baughn> edlinde: If you like math, using haskell to solve the Euler problems can be interesting
12:22:31 <edlinde> Baughn: so I have heard.. but then some others reckon Erlang works much better with larger projects
12:22:32 <jlouis> edlinde: I'd probably say learn SML first. When you have learned haskell, you will not like SML :P
12:22:41 <PeakerWork> jmelesky: How does one cope without: Purity, Type Classes, Laziness?
12:22:51 <edlinde> jlouis: thats even better :)
12:23:03 <PeakerWork> I learned Haskell, and now I can't learn OCaml
12:23:04 <edlinde> jlouis: it means I will then be able to kick ass in SML
12:23:04 <edlinde> hahahha
12:23:21 <jlouis> you can only kick ass in SML by using the MLton compiler
12:23:25 <edlinde> well I hope
12:23:46 <Baughn> edlinde: I don't know if that's true or not. It might be. Certainly, if the project is large enough to cover multiple machines that's a good chance..
12:23:46 <sizzler> once again anyone know the status of haskell-objective c binding
12:23:53 <edlinde> its a very basic introductory course they say.. just to get your head around how to think in a functional manner
12:23:55 <jmelesky> PeakerWork: you can be just as pure in sml as in haskell, but you aren't *required* to be, nor do you have to jump through monadic hoops to get around it
12:24:03 <Baughn> edlinde: Erlang is without a doubt less advanced than haskell in a language-theory sense, though. ;)
12:24:10 <edlinde> to me it seems very much like "describing" the problem mathematically and you are done!
12:24:13 <jlouis> edlinde: Erlang has dynamic typing...
12:24:18 <edlinde> I like maths... so its all good :)
12:24:27 <jlouis> it is a different beast, with a different power
12:24:43 <Baughn> edlinde: And yes, dynamic typing. You lose a *lot* of power if you don't have a strong static type system.
12:24:46 <rajeshsr> (+) . (-) $ 9 8
12:24:49 <rajeshsr> > (+) . (-) $ 9 8
12:24:49 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:24:50 <lambdabot>    `GHC.Num.Num t' arising f...
12:24:55 <edlinde> hmm k
12:24:57 <PeakerWork> jmelesky: The other side of the same coin is not having any guarantees.. I don't see the Haskell facilities as hoops -- they actually shorten code :)
12:24:59 <rajeshsr> :t -
12:24:59 <lambdabot> parse error (possibly incorrect indentation)
12:25:03 <rajeshsr> :t (-)
12:25:04 <lambdabot> forall a. (Num a) => a -> a -> a
12:25:04 <jmelesky> PeakerWork: and sml has a great packaging system. and laziness is easy to implement if you wish to use it
12:25:19 <edlinde> but am I right in saying that FP boils down to being able to just formulate the problem in an expression almost
12:25:20 <jlouis> SMLs module system is awfully cool
12:25:20 <rajeshsr> > (+) . (-) $ 9 8 :: Int
12:25:20 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:25:21 <lambdabot>         against inferred type ...
12:25:32 <Baughn> PeakerWork: It might be an oddity, but my current project is ~95% monadic. >_<
12:25:33 <PeakerWork> jmelesky: Well, laziness is important as a default.. otherwise if you want to write modular programs, e.g:  take k . sort -- you have to reimplement sort yourself
12:25:37 <edlinde> I have just browsed through some functional codes here and there and it seems to me like that
12:25:38 <rajeshsr> guess i should give up!! :)
12:25:47 <PeakerWork> Baughn: why/how would it make code longer?
12:26:01 <Baughn> PeakerWork: Oh, it doesn't. I'm very much enjoying the presence of non-IO monads.
12:26:06 <PeakerWork> rajeshsr: What is the result type of the (-) function?
12:26:11 <Baughn> PeakerWork: Not very much /pure/ code around, though. :P
12:26:11 <jmelesky> PeakerWork: it makes equivalent haskell code shorter, but not equivalent sml code...
12:26:25 <PeakerWork> jmelesky: what advantage do you get out of impurity in evaluation?
12:27:35 <PeakerWork> jmelesky: It reduces the learning curve, I'd guess.. But once you know how to use Functor, Applicative, Monad, the distinction helps a whole lot (giving guarantees to the reader, and to the compiler)
12:27:37 <jlouis> Saizan: yes, it is pretty cool we are getting down around Erlangs speeds, but it did take some hacks :)
12:28:00 <PeakerWork> jmelesky: Making things like DPH possible
12:28:02 <jlouis> Saizan: I can also get past it, but the hack is evil :)
12:28:07 <jmelesky> PeakerWork: flexibility. implementing a VM doesn't require implementing a monad, just mutating a variable that represents the VM environment. and since it's eager, not lazy, you don't run into cascading confusion with those mutations
12:28:21 <rajeshsr> PeakerWork, Num
12:28:23 <PeakerWork> jmelesky: The State monad is by default eager
12:28:30 <jlouis> Saizan: essentially manual memory management of buffers :)
12:28:38 <PeakerWork> rajeshsr: (-) :: Num t => t -> (t -> t)
12:28:54 <PeakerWork> rajeshsr: so the result of (-) after being applied with 1 argument is  Num t => (t -> t)
12:28:58 <jmelesky> PeakerWork: i'm not suggesting that sml is superior to haskell, just that i still enjoy programming in it
12:29:13 <rajeshsr> PeakerWork, ha, yeah!
12:29:34 <jmelesky> would i become a better haskell programmer if i barred myself from using sml? probably. but why bar myself from programming in a language i like?
12:29:56 <PeakerWork> jmelesky: Not asking you to :)  I just think impurity and no laziness by default is a disadvantage
12:30:09 <PeakerWork> rajeshsr: So when you use f . (-)      f is being applied to the direct result of (-), which is still a function
12:30:18 <rajeshsr> so (+) . (-) never works?
12:30:32 <PeakerWork> rajeshsr: unless you declare functions to be valid Nums (so pretty much yes, never works)
12:30:47 <PeakerWork> @where SEC
12:30:47 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
12:30:53 <jmelesky> PeakerWork: i think losing either purity or laziness would be a mess -- they really need eachother. but without both, you just end up with a good language that's a little easier to reason about on some things, a little harder on others
12:30:58 <PeakerWork> rajeshsr: read this ^^ for how to use (.) with (+) or (-)
12:31:02 <rajeshsr> PeakerWork, hmm now the dots are brightening! Let me connect them to make sense! :)
12:31:18 <PeakerWork> jmelesky: I think impurity should make everything just harder to reason about..
12:31:36 <tromp> > (+) . succ $ 2 4
12:31:37 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:31:37 <lambdabot>    `GHC.Num.Num t' arising f...
12:31:55 <tromp> > ((+) . succ $ 2 ) 4
12:31:56 <lambdabot>   7
12:32:00 <Saizan> jlouis: you should make GHC HQ's feel guilty for this :)
12:32:20 <jlouis> Saizan: it is only a blog post away :P
12:32:54 <jmelesky> PeakerWork: probably more true in situations where you're using third-party libraries. but there aren't many of those. and the module system, properly used, makes it unlikely that code outside what you're working on is going to mess with your impure data
12:32:58 <jmcarthur> functions can be valid nums
12:33:24 <jmelesky> PeakerWork: and strict evaluation does make reasoning about performance and memory use easier
12:33:29 <jmcarthur> aside from Eq and Show, that is
12:33:35 <jmcarthur> but that's because Num sucks
12:43:58 <FliPPeh_> >  let the = (1*); meaning = (+); of' = 21; life = 21 in the (meaning of' life)
12:43:59 <lambdabot>   42
12:44:02 <rajeshsr> > (fmap . fmap . fmap) fst [Just 4, [(11, [1..10])]]
12:44:03 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (f (a, b))'
12:44:03 <lambdabot>         against ...
12:44:04 <FliPPeh_> Haskell is such a beautiful language.
12:44:12 <rajeshsr> > (fmap . fmap . fmap) fst [4, [(11, [1..10])]]
12:44:12 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `[t]'
12:44:40 <rajeshsr> > (fmap . fmap . fmap) fst [(4, [(11, [1..10])])]
12:44:41 <lambdabot>   [(4,[11])]
12:48:30 <rajeshsr> > fmap . fmap . fmap fst $ [(4, [(11, [1..10])])]
12:48:31 <lambdabot>   Couldn't match expected type `a -> (a1, b)'
12:48:31 <lambdabot>         against inferred type `...
12:48:36 <edwardk> jmelesky: my biggest problems with sml are the syntactic overhead that is imposed by strictness and impurity and the lack of polymorphic recursion
12:48:47 <jlouis> even more aggressive cutting tells the story: http://jlouis.github.com/combinatorrent/ optimization matter
12:49:16 <rajeshsr> @src (.)
12:49:17 <lambdabot> (f . g) x = f (g x)
12:49:17 <lambdabot> NB: In lambdabot,  (.) = fmap
12:49:37 <jlouis> When Productivity goes up, CPU/Network goes down :)
12:50:35 <rajeshsr> @unpl fmap . fmap
12:50:35 <lambdabot> (\ c -> fmap (fmap c))
12:50:45 <rajeshsr> @unpl fmap . fmap . fmap
12:50:45 <lambdabot> (\ c -> fmap (fmap (fmap c)))
12:51:27 <Baughn> edlinde: I just (okay, took me two weeks) wrote a four-thousand-line haskell program.
12:51:37 <Baughn> edlinde: I didn't /try/ it until now.
12:51:42 <Baughn> edlinde: /It worked the first time/.
12:51:49 <Baughn> edlinde: And that's why haskell is good. :)
12:51:50 <jlouis> classical Haskell
12:51:53 <bo0ts__> Hi, is there a straight forward way to find the frequency of each unique element in a list?
12:52:05 <Baughn> bo0ts__: Yes.
12:52:07 <bo0ts__> I can only think of something that involves a lot of state.
12:52:14 <jlouis> I just ripped out the low level communication in my program. Worked the first time.
12:52:23 <edwardk> Baughn: =)
12:52:33 <rajeshsr> bo0ts__, use Set
12:52:38 <roconnor> @hoogle a -> [a] -> Int
12:52:39 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
12:52:39 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
12:52:39 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
12:52:42 <byorgey> bo0ts__: yes, using something like  map (id &&& length) . group . sort
12:52:59 <byorgey> > map (id &&& length) . group . sort $ "abcbbcadacbc"
12:53:00 <lambdabot>   [("aaa",3),("bbbb",4),("cccc",4),("d",1)]
12:53:07 <roconnor> byorgey: requires Ord
12:53:15 <byorgey> true
12:53:19 <Baughn> > map (head &&& length) . group . sort $ "abcagdghajkdsd"
12:53:20 <rajeshsr> :t (&&&)
12:53:20 <lambdabot>   [('a',3),('b',1),('c',1),('d',3),('g',2),('h',1),('j',1),('k',1),('s',1)]
12:53:21 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:53:23 <byorgey> and sorry, I mean (head &&& length) not id
12:53:39 <edlinde> Baughn: 4000 lines? What you building?
12:53:40 <edlinde> :)
12:53:43 <Baughn> > map (head &&& length) . group . sort $ "A perfectly normal english sentence"
12:53:45 <lambdabot>   [(' ',4),('A',1),('a',1),('c',2),('e',6),('f',1),('g',1),('h',1),('i',1),('...
12:54:05 <Baughn> ..lookat that e. Oh yes.
12:54:12 <Baughn> edlinde: Distributed filesystem.
12:54:29 <Baughn> edlinde: Hum, got another two thousand in the messaging system..
12:54:32 <bo0ts__> Shouldn't that have a higher complexity than a linear walkthrough and storing elements in a lookup table?
12:54:32 <edlinde> Baughn: ah neat
12:54:55 <edlinde> Baughn: whats this for? A project or a thesis? or just open source stuff you working on?
12:55:00 <Baughn> bo0ts__: Well yes, but you can't do that with all of unicode
12:55:03 <Baughn> edlinde: Thesis
12:55:16 <edlinde> Baughn: PhD thesis?
12:55:22 <Baughn> Just MSc.
12:55:29 <bo0ts__> Baughn: It isn't necessarily for [Char].
12:55:32 <edlinde> hmm cool
12:55:33 <Baughn> thesis :: Maybe Thesis?
12:55:46 <edlinde> its a lot of code to write for a MS thesis I suppose
12:55:57 <Baughn> ..I hope the judges agree.
12:56:06 <Baughn> It /was/ a lot of code, and I've run into a couple GHC bugs too.
12:56:08 <jlouis> bo0ts__: I tend to start with stuff like that line byorgey posted. And then I'll come back and optimize further if needed later on
12:56:54 <bo0ts__> jlouis: Of course you are right. I was just playing mindgames to come up with a solution that has the same complexity as my imperative approach.
12:56:57 <jmelesky> edwardk: i'm not sure what you mean by the syntactic overhead from strictness
12:56:59 <rajeshsr> @unpl (fmap . fmap) (+) [Just 1, Just 2]
12:56:59 <lambdabot> fmap (fmap (+)) [Just 1, Just 2]
12:57:27 <jlouis> bo0ts__: the imperative approach being to create an array and then count?
12:57:31 <jmelesky> edwardk: or do you just mean the syntax required to have (this; that; theother) ?
12:58:09 <bo0ts__> jlouis: Iterating over the array and updating a map of some kind while doing it.
12:58:21 <rajeshsr> ha, thank to @unpl it makes it so clear now!
12:58:24 <edlinde> Baughn: what does a distributed file system come under? I mean what area is this?
12:58:25 <jlouis> bo0ts__: Data.Map can do that
12:58:45 <Baughn> edlinde: Distributed Systems, I'd guess?
12:59:27 <jlouis> bo0ts__: foldl', M.adjust or M.alter shoudl do it in a one-liner
12:59:36 <jlouis> or close to
13:00:15 <bo0ts__> jlouis: Yes, that seems possible. Thank you.
13:01:41 <edwardk> jmelesky: the need to explicitly order your lets in smaller scopes rather than dump things in a where clause with wider scope because the compiler can spot the lack of use of a variable and elide it, and the need for a distinction between fun and val because you need to know when effects happen
13:02:02 <edwardk> jmelesky: the ability to arbitrarily beta-reduce in a lazy setting also helps in the syntax of generated EDSLs
13:02:31 <BMeph> jlouis: insertWith succ, maybe? ;)
13:02:33 <edwardk> jmelesky: all of those contribute to greater syntactic overhead in a strict language
13:02:52 <rajeshsr> > fmap . fmap . fmap fst $ [(4, [(11, [1..10])])]
13:02:53 <lambdabot>   Couldn't match expected type `a -> (a1, b)'
13:02:53 <lambdabot>         against inferred type `...
13:03:06 <edwardk> jmelesky: the distinction between let and let rec which is brought about about caring about the order of side effects and the issues with cycles that result
13:03:12 <rajeshsr> > (fmap . fmap . fmap) fst  [(4, [(11, [1..10])])]
13:03:13 <lambdabot>   [(4,[11])]
13:03:13 * BMeph thinks "insertWith succ" sounds like something Ron Jeremy would program... ;p
13:03:17 <rajeshsr> @unpl (fmap . fmap . fmap) fst  [(4, [(11, [1..10])])]
13:03:18 <lambdabot> fmap (fmap (fmap fst)) [(4, [(11, [1 .. 10])])]
13:04:20 <rajeshsr> @unpl fmap . fmap . fmap fst $ [(4, [(11, [1..10])])]
13:04:20 <lambdabot> (fmap (fmap (fmap fst ([(4, [(11, [1 .. 10])])]))))
13:05:52 <jlouis> BMeph: even neater!
13:06:08 <rajeshsr> @unpl fmap . fmap . fmap $ fst  [(4, [(11, [1..10])])]
13:06:09 <lambdabot> (fmap (fmap (fmap (fst [(4, [(11, [1 .. 10])])]))))
13:13:09 <rajeshsr> :t second
13:13:10 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
13:13:22 <rajeshsr> @hoogle first
13:13:22 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
13:13:22 <lambdabot> Data.Monoid newtype First a
13:13:22 <lambdabot> Data.Monoid First :: Maybe a -> First a
13:13:36 <rajeshsr> first (1,1)
13:13:40 <rajeshsr> > first (1,1)
13:13:40 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
13:13:41 <lambdabot>    arising from a use of `Control...
13:13:56 <edwardk> > first (+1) (1,3)
13:13:57 <lambdabot>   (2,3)
13:14:20 <djahandarie> Heh
13:14:23 <systemfault> >fst (1,2)
13:14:29 <systemfault> > fst (1,2)
13:14:30 <lambdabot>   1
13:15:29 <soupdragon> Cale?
13:16:31 <rajeshsr> edwardk, so what does first do?
13:16:47 <edwardk> read 'a' in the type signature as (->)
13:16:59 <edwardk> it applies a function to the first element of a tuple
13:17:13 <edwardk> second does the same to the second element
13:17:15 <tromp> i used haskell to count number of chess positions. anyone wanna check the details?
13:17:18 <rajeshsr> :t first
13:17:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:17:38 <edwardk> tromp: that may take a while to run ;)
13:17:39 <rajeshsr> i don't get what it means by (a b c -> ...)
13:17:47 <edwardk> @type first
13:17:47 <tromp> takes a few minutes
13:17:48 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:17:50 <rajeshsr> how can (a b c) be like that
13:17:54 <tromp> well, it's only an upper bound:)
13:18:09 <byorgey> rajeshsr: 'a' is a type variable that takes two type parameters
13:18:09 <edwardk> that is the same as (b -> c) -> (b,d) -> (c,d)    when a == (->)
13:18:17 <byorgey> rajeshsr: for example, Either takes two type parameters
13:18:21 <byorgey> rajeshsr: so does (->)
13:18:22 <rajeshsr> byorgey, ha!!
13:18:27 <edwardk> the type is more general because there are other 'Arrows' than (->)
13:19:07 <edwardk> though i prefer to generalize 'first' into one that is parametric in the bifunctor, rather than the arrow
13:19:27 <byorgey> edwardk: ah, yes, that seems much more useful =)
13:19:51 <BMeph> rajeshsr: If it helps you, Where \-bot puts 'a', you can imagine a (~>). Some like how it's suggestive, but not identical to, a function arrow. :)
13:20:16 <rajeshsr> well, i do not know about arrows!
13:20:22 <Saizan> first f = bimap f id ?
13:20:24 <edwardk> class Bifunctor f where bimap :: (a -> b) -> (c -> d) -> f a c -> f b d; first :: (a -> b) -> f a c -> f b c; second :: (a -> b) -> f c a -> f c b; first id = bimap f id; second = bimap id; bimap f g = second g . first f
13:20:31 <edwardk> saizan yeah
13:20:34 <rajeshsr> it is given in this blog: http://conal.net/blog/posts/semantic-editor-combinators/
13:20:42 <rajeshsr> so tried to understand about first..
13:20:49 <rajeshsr> any link on that?
13:20:52 <BMeph> rajeshsr: So, first :: forall ((~>) :: * -> * -> *) b c d. (Arrow (~>)) => (b ~> c) -> ((b, d) ~> (c, d))
13:21:20 <edwardk> rajeshsr: for most purposes you can ignore the arrow part and just pretend that Arrow a => a b c -- is a way to say (b -> c) that also permits some other, mostly irrelevant stuff to also work
13:21:49 * BMeph cheers for edwardk and his Mystical, Magical Bifunctor Mantras!
13:21:50 <edwardk> there are a bunch of combinators in Control.arrow that would otherwise be useful, but are only defined there
13:22:18 <edwardk> er in my def above i meant first f = bimap f id
13:23:01 <edwardk> though sadly i usually have to break up bifunctor into 3 classes, so i can support bifunctors which have one arg or the other contravariant
13:23:31 <edwardk> that way you can apply 'second' to (->)
13:24:01 <BMeph> :t Right . undefined :: ((a -> b) -> Either a b)
13:24:03 <lambdabot> forall a b. (a -> b) -> Either a b
13:25:03 <rajeshsr> so functions are abstract types that takes one parameter and returns one? is that the essence of arrows?!
13:25:23 <rajeshsr> :t (->)
13:25:24 <lambdabot> parse error on input `->'
13:25:31 <byorgey> :k (->)
13:25:32 <lambdabot> ?? -> ? -> *
13:25:36 <edwardk> rajeshsr: arrows are basically a generalized construction that can be generated from functions, but may contain other things
13:25:37 <byorgey> ah, ignore that =)
13:25:54 <edwardk> @src Arrow
13:25:54 <lambdabot> class Arrow a where
13:25:55 <lambdabot>     arr, pure   :: (b -> c) -> a b c
13:25:55 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
13:25:55 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
13:25:55 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
13:25:56 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
13:25:58 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
13:25:59 <BMeph> Uh, "first f = bimap f id", or if you prefer, "first = flip bimap id"? :)
13:26:18 <edwardk> BMeph: flip is usually the sign that i shouldn't bother being pointfree ;)
13:26:25 <rajeshsr> edwardk, when we say a function is an arrow, do we mean that they are abstract types as i said?
13:26:35 <edwardk> there is an intsance of Arrow (->)
13:26:44 <BMeph> edwardk: I did write "if". :)
13:27:09 <edwardk> BMeph: i scribbled the correction to my offhand ramblings a few lines below though =)
13:28:36 <rajeshsr> > first (+1) (1,2)
13:28:37 <lambdabot>   (2,2)
13:29:23 <rajeshsr> any other sophisticated use of first ?
13:29:30 <rajeshsr> first (+1) [1..10]
13:29:32 <rajeshsr> > first (+1) [1..10]
13:29:33 <lambdabot>   Couldn't match expected type `[t]' against inferred type `(b, d)'
13:29:42 <rajeshsr> @t first (+1)
13:29:42 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:29:44 <BMeph> edwardk: Yeah, I finally caught it when I re-read the mass of text before I responded - you porbably did it as I typed, and I just didn't look up in time to edit myself. :)
13:29:53 <rajeshsr> @type first (+1)
13:29:54 <lambdabot> forall b d. (Num b) => (b, d) -> (b, d)
13:30:43 <rajeshsr> @type first (show)
13:30:43 <lambdabot> forall b d. (Show b) => (b, d) -> (String, d)
13:30:49 <kaol> first is plumbing for arrow notation.
13:32:23 <tromp> > first post!
13:32:23 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:34:01 <rajeshsr> > first show ("first", "post")
13:34:01 <lambdabot>   ("\"first\"","post")
13:34:09 <rajeshsr> ;)
13:36:45 <scotty> How do I get all values associated with a particular key in a Data.Map?
13:37:55 <rajeshsr> scotty, isn't there only one value?
13:38:25 <rajeshsr> or use Map k [v] if you want multiple values..
13:39:11 <dpratt71> I've read scattered musings about the issues of modelling IO in Haskell, and I've come up with a question...
13:40:08 <dpratt71> ...is it impossible or unsavory to model lines of a text file, bytes of a binary file, or lines entered at the console as a list?
13:40:36 <roconnor> dpratt71: I'm not sure what you mean
13:41:01 <edwardk> dpratt71: you mean dynamically as it streams in?
13:41:13 <edwardk> dpratt71: with demand on the list requesting more of the input?
13:41:16 <roconnor> @type interact
13:41:17 <lambdabot> (String -> String) -> IO ()
13:41:19 <dpratt71> edwardk: yeah, I thin that's what I mean
13:41:25 <dpratt71> *think
13:41:41 <edwardk> interact takes input a line at a time, feeds it to your function and prints out the result.
13:41:54 <roconnor> edwardk: really, a line at a time?
13:42:00 <dpratt71> (depending on how dumb that idea is, it may not be what I mean)
13:42:14 <edwardk> @type hGetContents
13:42:16 <lambdabot> Not in scope: `hGetContents'
13:42:27 <roconnor> @type getContents
13:42:28 <lambdabot> IO String
13:42:53 <dpratt71> edwardk: interesting; I was kinda hoping there was some way of getting away from that IO action thing...
13:43:01 <edwardk> getContents returns all of the user input as a lazy list
13:43:18 <roconnor> dpratt71: interact does let you get away from IO action thing
13:43:39 <roconnor> main = interact myProgram  where myProgram :: String -> String
13:43:49 <edwardk> dpratt71: ultimately you need some IO operation to kickstart feeding you the data, but note that getContents returns the list, but the side-effects are deferred until the portion of the list in question is accessed
13:44:07 <dpratt71> I see
13:44:41 <edwardk> dpratt71: you might find the 'history of haskell' paper that SPJ and a bunch of folks put together. the original IO interface was basically built using lazy lists of requests and responses, but it was too easy to screw up
13:44:46 <byorgey> dpratt71: note, however, that this sort of "lazy I/O" can come back to bite you in strange ways that I don't really understand
13:45:02 <edwardk> http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm
13:45:04 <byorgey> but others have written about the pitfalls at length, I'm sure if you search for "lazy IO" you'll find some
13:45:10 <dpratt71> interesting
13:45:30 <rajeshsr> is (->) an operator?
13:45:36 <edwardk> the problem in general with getContents and its ilk is that of course you may want to know when you're done reading the file... what happens when another io action deletes it?, etc.
13:45:37 <byorgey> rajeshsr: it is a type operator
13:45:43 <rajeshsr> what sort of operator is it?
13:45:45 <rajeshsr> oh!
13:45:55 <rajeshsr> what type operators exists in haskell?
13:46:11 <dpratt71> edwardk: makes sense
13:46:19 * hackagebot hamlet 0.2.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.2.2 (MichaelSnoyman)
13:46:20 <edwardk> , : -> (,,) (,,,) (,,,,) ...
13:46:23 <byorgey> rajeshsr: "operator" just means something made from operator (non-alphanumeric) characters and infix
13:46:34 <dpratt71> dpratt71: ok, how about a functional/transactional file system, then :)
13:46:38 <byorgey> : is not a type operator
13:46:49 <edwardk> byorgey: true, sloppy of me
13:46:49 <rajeshsr> byorgey, ok, type functions may be more appropriate?! :)
13:47:26 <dpratt71> hmm; a bad sign that I've started talking to myself?
13:47:27 <edwardk> rajeshsr: well, a type function is a different beast, 'operator' just means that it is given infix
13:47:44 <edwardk> dpratt71: it is perfectly normal, or so i've been repeatedly assured.
13:47:47 <tensorpudding> I'm trying to make instances of a certain typeclass as instances of my typeclass, but I'm getting a kind mismatch.
13:47:48 <rajeshsr> edwardk, hmm, anything can be made in fix in haskell
13:47:55 <dpratt71> edwardk: :)
13:47:56 <rajeshsr> so all is operator! :)
13:47:59 <edwardk> rajeshsr: yes, yes, it can ;)
13:47:59 <rajeshsr> i mean all functions
13:48:10 <byorgey> rajeshsr: yes, you can do this with types too
13:48:16 <byorgey> like Int `Either` Bool
13:48:20 <edwardk> which is why you can think about the fact that 'a' can be set to (->) in the definition for first, and get a reasonable type
13:48:25 <edwardk> @type first
13:48:26 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:48:46 <edwardk> first :: (->) b c -> (->) (b,d) (c,d)
13:48:53 <scotty> rajeshsr: Shouldn't I be able to do this: (Map.insertWith (:) key x m)
13:49:07 <rajeshsr> edwardk, is it called a type constructor?
13:49:15 <scotty> rajeshsr: That is, when I'm building the map.
13:49:16 <edwardk> scotty: you need to insert the initial value as a singleton list
13:49:24 <tensorpudding> i.e. I want the constructors to have kind * -> * but for some stupid reason it expects *, which makes no sense because it works fine for when I define it for some other constructor of kind * -> *
13:49:31 <mreh> who knows haskell fruit?
13:49:37 <scotty> So, I should use ++, and [x]?
13:49:41 <edwardk> so perhaps sprinkle a return in there and use ++
13:49:42 <edwardk> yeah
13:49:45 <scotty> Thanks
13:50:33 <byorgey> tensorpudding: maybe you need some kind annotations?
13:50:43 <tensorpudding> How and where would I specify them?
13:50:54 <byorgey> tensorpudding: in certain situations without kind annotations things will default to kind * if it can't infer a specific kind
13:50:55 <tensorpudding> In the instance declaration, or in the class definition?
13:50:57 <edwardk> tensorpudding: data Foo (f :: * -> *) = ...
13:51:08 <byorgey> tensorpudding: in the class definition
13:51:22 <byorgey> or data declaration, like in edwardk's example
13:51:27 <byorgey> depends on what the problem is
13:51:39 <tensorpudding> Do I need -XKindSignatures for that?
13:51:40 <edwardk> class Bar (f :: * -> *)
13:51:43 <edwardk> yeah
13:51:43 <byorgey> yes
13:51:46 <tensorpudding> Okay
13:51:47 <edwardk> or something that implies it
13:52:04 * soupdragon needs math people to help me :[
13:52:16 <edwardk> soupdragon: whats the issue?
13:52:30 <byorgey> if only there were math people in this channel ;)
13:52:31 <soupdragon> to solve a quintic which has the group cyclic C_5
13:52:42 <soupdragon> > let z k = exp(k*sqrt(-1)*2*pi/11::Complex Double); t1 = z 5+z 6 ; t2 = z 10+z 1 ; t3 = z 2+z 9 ; t4 = z 7+z 4; t5 = z 8+z 3 in (t1-t5)*(t5-t4)*(t4-t3)*(t3-t2)*(t2-t1)
13:52:43 <lambdabot>   (-10.999999999999972) :+ 3.4794455633822547e-15
13:52:47 <soupdragon> ^ I think this is -11
13:52:57 <soupdragon> so presumably (t1-t5)*(t5-t4)*(t4-t3)*(t3-t2)*(t2-t1) is a resolvent
13:53:22 <tensorpudding> Okay that worked.
13:53:39 <soupdragon> the equation is z^5+z^4-4z^3-3z^2+3z+1=0 btw
13:54:01 <edwardk> i think the most *'s i've ever had to give in a kind with a practical use case was 36. ;)
13:54:04 <tensorpudding> I'm not seeing exactly why it is needed though.
13:54:10 <roconnor> soupdragon: don't we have software to solve this?
13:54:13 <byorgey> woah
13:54:14 <soupdragon> but yeah I don't know how to solve it.... I looked up all these papers like "On Solution of Soluble Equations of Higher Degree" and it's all abstract nonsense
13:54:16 <edwardk> but perhaps my definition of practical diverges from the norm
13:54:22 <byorgey> edwardk: define "practical" =)
13:54:24 <rajeshsr> insertWith could have been made more general as with foldl. (v -> a -> v) as the function
13:54:27 <byorgey> yes, exactly ;)
13:54:36 <rajeshsr> any rationale for not having done it?
13:54:40 <edwardk> byorgey: useful to me in the moment? =)
13:54:53 <byorgey> :t insertWith
13:54:54 <lambdabot> Not in scope: `insertWith'
13:54:57 <soupdragon> yikes!!
13:54:59 <byorgey> :t M.insertWith
13:55:00 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
13:55:30 <edwardk> rajeshsr: then you need to define a second value to insert for the actual insert
13:55:54 <soupdragon> so does anyone know some book or something which would explain how to solv this
13:56:01 <byorgey> rajeshsr: insertWith is not a fold, it produces a new map rather than a summary value
13:56:15 <byorgey> rajeshsr: so the value produced by the inserting function must still be the same type as it was before
13:56:29 <edwardk> rajeshsr: you also don't have to use the second argument
13:56:41 <rajeshsr> byorgey, i mean insertWith uses an agregation function
13:56:49 <rajeshsr> why not that be as general as fold
13:57:04 <edwardk> rajeshsr: insertWith (\as _ -> x:as) k (return x)
13:57:25 <byorgey> rajeshsr: I understand your question, I was trying to explain why I don't think it could be made as general as fold
13:57:31 <byorgey> try to implement it and you will see =)
13:57:47 <roconnor> soupdragon: if your galois group is C5, does that mean your roots are in Q adjoint a fifth root of unity?
13:58:14 * roconnor left his book at work :(
13:59:26 <soupdragon> sorry I was afk im back now
13:59:48 <roconnor> hmm I guess not
13:59:54 * roconnor rethinks
13:59:59 <soupdragon> roconnor: I'm not sure about that but it sounds sort of like what happens with solving the general cubic
14:00:20 <rajeshsr> edwardk, i don't get the point of your example. you mean for the present insertWith?
14:00:21 <edwardk> rajeshsr: even (a -> a) -> k -> a -> M.Map k a -> M.Map k a -- is sufficient if you think about it, they are just giving you more context, you don't have to use it
14:00:49 <roconnor> soupdragon: I'm useless without my textbook ;(
14:01:06 <edwardk> rajeshsr: you can;t just give (a -> v -> a) -> k -> v -> Map k a -> Map k a -- because where do you get the 'a' from the 'v' for the initial insert?
14:01:17 <edwardk> rajeshsr: so you'd need an extra argument there
14:01:36 <edwardk> but it is redundant to even give the function v, since it could take it from the current environment
14:01:46 <rajeshsr> edwardk, yep! waht to do with initial value is absolutely needed
14:01:53 * roconnor doesn't remember what abelian groups have to do with radicals
14:02:01 <soupdragon> abelian groups are solvable
14:02:02 <rajeshsr> edwardk, do you think that is the case always?
14:02:11 <soupdragon> or.. unsolvable
14:02:15 <edwardk> rajeshsr: so really all you need is (a -> a) -> k -> a -> M.Map k a -> M.Map k a
14:02:16 <roconnor> solvable
14:02:27 <roconnor> but group solvability has something to do with radical solvability
14:02:31 <edwardk> but it is nice to be able to for the common case, just apply a binary function to combine the two inputs
14:02:31 <soupdragon> yeah so if the group is abelian you can solve the thing in radicals
14:02:34 <rajeshsr> edwardk, ha, yeah, the "v" that is being applied is always present!
14:02:53 <edwardk> so the type of insertWith gives you back your 'a'
14:02:58 <edwardk> as a courtesy
14:03:04 <edwardk> you can still choose to ignore it though
14:03:14 <edwardk> like i did above
14:03:17 <edwardk> thats all
14:03:19 <edwardk> anyways gotta run
14:03:23 <aavogt> but then it's harder to know which one is your own
14:03:25 <ezyang> bye
14:03:35 <Makoryu> > foldr f z [1..10]
14:03:36 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
14:03:45 <soupdragon> according to Galois my quintic is solvable using fifth roots of unity
14:03:49 <soupdragon> err fifth roots
14:03:58 <cdsmithus> roconnor: My memory is fuzzy from Galois theory... but if the Galois group is solvable, then the equation is solvable by radicals, right?
14:04:12 <roconnor> cdsmithus: yes
14:04:28 <rajeshsr> soupdragon, why did that equation came in the first place?! ;)
14:04:57 <cdsmithus> And a group being solvable just means that you can build a chain of subgroups where the factor of each by the next one down is abelian?
14:05:11 <roconnor> yes
14:05:37 <roconnor> so you can build a chain of subfields which adjoin radicals
14:05:54 <roconnor> but why adjoining a radical iff the galois group is abiliean?
14:06:15 * cdsmithus looks for an algebra book. :)
14:06:32 <soupdragon> I am not sure that abelian is synonymous with solvable..
14:06:54 <roconnor> I think ablean is the base case for solvable
14:06:57 <roconnor> a chain of length 1
14:09:05 <soupdragon> but the theory says 'this can be solved'
14:09:11 <roconnor> yes
14:09:14 <soupdragon> my question is, by whom?
14:09:22 <rajeshsr> BTW, adjust seems to come close to what we discussed now...
14:09:26 <roconnor> by cdsmithus
14:09:31 <soupdragon> hehe
14:09:43 <soupdragon> 13th roots of unity are so much easier to find than 11th
14:09:45 <cdsmithus> Wait.. solvable by me?  That's a much stronger condition
14:10:41 <scotty> I'm all confused by Int vs Integer.  So, Integer is like an idealized Int?  Can I not do comparisons on Integers, such as "<"?
14:10:52 <Zao> scotty: Int is a small fixed-width integer.
14:10:58 <Zao> scotty: Integer is a bigint.
14:11:11 <burp> very big int ;)
14:11:12 <byorgey> scotty: sure you can compare Integers.
14:11:13 <scotty> Zao: I'm trying to do a less-than comparison and it's complaining.
14:11:14 <Zao> (where by "small" it's around 30-60 bits"
14:11:17 <soupdragon> when solving the cubic, we (let the roots be t1,t2,t3) know that the sum and product of (t1 + w*t2 + w^2*t3)^3 & (t1 + w^2*t2 + w*t3)^3 are rational.. and we use that to solve the equationh
14:11:17 <Saizan> > (1::Integer) < 2
14:11:18 <lambdabot>   True
14:11:29 <soupdragon> but I couldn't find anything 'similar' to this for the quintic
14:11:35 <Zao> > (maxBound :: Int) -- on this platform
14:11:36 <lambdabot>   9223372036854775807
14:11:38 <burp> @instances Integer
14:11:39 <lambdabot> Couldn't find class `Integer'. Try @instances-importing
14:11:47 <byorgey> scotty: with what complaint is it complaining?
14:12:03 <Zao> > (1 :: Integer) == (1 :: Int)
14:12:04 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
14:12:04 <lambdabot>         agains...
14:12:07 <Peaker> "Int" should be hidden behind some module that makes it clear it's an implementation detail performance hack
14:12:10 <soupdragon> (known sum and product give a quadratic.. knock the 3 off to get the cube root)
14:12:16 <wagle>   @hoogle (a -> b -> c) -> (a, b) -> c
14:12:19 <Zao> Peaker: So should you.
14:12:24 <wagle> @hoogle (a -> b -> c) -> (a, b) -> c
14:12:25 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
14:12:25 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
14:12:25 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
14:12:30 <Peaker> Zao, :-P
14:12:32 <wagle> d'uh
14:12:38 <scotty> One sec, it must be part of something bigger.  I'll put the code on pastebin.
14:12:39 <Peaker> Zao, I take it you like your integer arithmetic to wrap around
14:12:41 <wagle> knew it looked familier
14:12:54 <Zao> Peaker: Indeed.
14:13:11 <Zao> Peaker: I do prefer the sized types for that though.
14:13:16 <Zao> Less unpredictable.
14:13:41 <scotty> http://pastebin.com/ji9tRJs4
14:13:56 <scotty> I'm trying to find the longest list in my map.
14:14:09 <byorgey> scotty: ah, length returns an Int
14:14:17 <scotty> Ah
14:14:19 <byorgey> for hysterical raisins
14:14:23 <byorgey> use genericLength instead
14:14:27 <soupdragon> I tried every permutation of (t1+w^i tj+..)^5 but none of them are real
14:14:28 <byorgey> or fromIntegral . length
14:14:30 <rajeshsr> k, bye everyone!
14:14:31 <scotty> XD
14:14:33 <scotty> Thanks
14:14:37 <Peaker> Zao, "Int" wraparounds are virtually always bugs, and it sucks in a language that's otherwise relatively statically safe
14:14:43 <rajeshsr> thanks for all the help today!
14:14:48 <rajeshsr> good night!
14:14:49 <byorgey> bye rajeshsr
14:17:06 <scotty> genericLength is in Data.List, right?
14:17:13 <monochrom> @djinn a -> ((a -> r) -> r)
14:17:13 <lambdabot> f a b = b a
14:17:41 <Makoryu> :t \a b -> b a
14:17:42 <lambdabot> forall t t1. t -> (t -> t1) -> t1
14:17:54 <monochrom> the converse is 2nd-rank: (forall r. (a->r)->r) -> a, so I can't ask djinn to do it
14:18:30 <monochrom> Today I understood the Wadler Theorems for Free paper!
14:18:45 <Peaker> monochrom, is that related to what you just wrote?
14:19:48 <monochrom> Tangentially related. Wadler applied free theorems to the example of proving isomorphism between a and (forall r. (a->r)->r)
14:20:01 <monochrom> (as 1 of about 10 examples)
14:21:19 <wagle> @hoogle [a] -> [b] -> [(a,b)]
14:21:20 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
14:21:20 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
14:21:20 <lambdabot> Data.Graph.Inductive.Example genLNodes :: Enum a => a -> Int -> [LNode a]
14:22:52 <wagle> what if i want foo [1,2] [3,4] == [(1,3), (1,4), (2,3), (2,4)] ?  is there a name for that?
14:23:09 <mreh> :t transpose
14:23:10 <lambdabot> forall a. [[a]] -> [[a]]
14:23:23 <mreh> oh
14:23:32 <Saizan> wagle: liftM2 (,)
14:23:35 <mreh> looks like something for the list monad
14:23:46 <Saizan> > liftM2 (,) [1,2] [3,4]
14:23:47 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
14:23:52 <wagle> yeah, ez for list monad
14:24:00 <wagle> Saizan: cool
14:24:17 <mreh> @do liftM2 (,)
14:24:17 <lambdabot> liftM2 (,)
14:24:23 <mreh> :D
14:24:29 <mreh> @src liftM2
14:24:29 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:24:34 <Peaker> monochrom, Feeding that cont "id" to get the "a"?
14:25:08 <Peaker> alternatively, liftM2 = liftA2 f x y = pure f <*> x <*> y
14:25:14 <Peaker> (or f <$> x <*> y)
14:25:17 <monochrom> Yes.
14:25:41 * mreh has never used applicative
14:25:50 <mreh> it seems overly complex
14:26:03 <HugoDaniel> hi
14:26:19 <mreh> yo
14:26:20 <Peaker> mreh, It's very simple :)
14:26:23 <wagle> @hoogle liftM2
14:26:23 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:26:27 <mreh> Peaker: good
14:26:31 <Peaker> mreh, Do you use Functor?
14:26:43 <mreh> Peaker: I use fmap regularly
14:26:52 <mreh> I was just fmapping some Maybes
14:26:59 <Peaker> mreh, If you just want Functor with the ability to also apply a function to multiple wrapped inputs, rather than just one, you use <*>
14:27:04 * Makoryu scratches some vinyl
14:27:09 * Makoryu puts on sunglasses
14:27:11 <mreh> like a list of Maybes?
14:27:20 <mreh> lets kick it
14:27:23 <Peaker> mreh, yeah, or maybe just a couple of Maybes
14:27:29 <Peaker> mreh, Lets say you want to sum 2 Maybes
14:27:34 <Peaker> mreh, With "fmap", you can't combine Maybes
14:27:35 <conal> mreh: in other words, Applicative removes the asymmetry of Functor, while simplifying Monad
14:28:02 <mreh> asymmetry in a sense of what?
14:28:10 <mreh> :t fmap
14:28:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:28:40 <Peaker> mreh, If you try to use a binary function like (+) on a couple of Maybe's contents, you can try to:   fmap (+) (Just 5)   but then you get:  Just (5+)  (now your partially applied function is wrapped in a Maybe)
14:28:44 <conal> mreh: that the combining operation applies to one unwrapped and one wrapped arg.
14:29:27 <Peaker> mreh, So "fmap" won't accept your (Just (5+)) as a proper function.  But <*> which is just like fmap except it will (The function is also wrapped in a Maybe)
14:29:27 <mreh> conal, gotcha
14:29:56 <mreh> this an "Applicative Functor"?
14:30:02 <Peaker> Yeah
14:30:02 <mreh> this is*
14:30:05 <Peaker> @src Applicative
14:30:05 <lambdabot> class Functor f => Applicative f where
14:30:06 <lambdabot>     pure  :: a -> f a
14:30:06 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
14:30:30 <systemfault> > (+) <$> pure 3 <*> Just 5
14:30:31 <lambdabot>   Just 8
14:30:44 <Peaker> So:  (<$>) = fmap ;   pure (+) <*> Just 5 <*> Just 9      "pure (+)" wraps our binary function in a Maybe. Then we can use <*> on it to feed it one extra arg in a maybe, each time
14:31:18 <Peaker> f <$> x = fmap f x = pure f <*> x
14:31:36 <mreh> how does that parse?
14:31:48 <mreh> the pure (+) <*> Just 5 <*> Just 9
14:32:11 <Peaker> mreh, prefix has highest precedence, so:  ((pure (+)) <*> (Just 5)) <*> (Just 9)
14:32:12 <mreh> there's only one way it can if it typechecks I suppose
14:32:16 <mreh> yes
14:32:45 <soupdragon> man solving equations is really HARD
14:32:46 <Peaker> mreh, it turns out lots of "monadic" things are also Applicative things.. and Applicative is a simpler class than Monad, less powerful/structure, so more types can be instances
14:33:11 <Peaker> mreh, For example, "sequence" is Applicative, and thus all of the monadic operations defined in terms of "sequence".  (>>) is also an Applicative operation
14:33:15 <mreh> Category theory is so general, it's only useful to programmers they say
14:33:30 <mreh> you lost me there, let me try and understand that
14:34:19 <mreh> :t flip (>>=)
14:34:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
14:34:32 <mreh> hmm
14:34:37 <mreh> :t flip (>>)
14:34:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> m a -> m b
14:34:39 <Peaker> mreh, (>>=) is Monad, not Applicative.. Only (>>) is Applicative
14:34:50 <mreh> okay
14:35:01 <soupdragon> for symmetric operators we have  (<<) = flip (>>)  for example
14:35:06 <soupdragon> and (=<<) = flip (>>=)
14:35:22 <soupdragon> and for commutative ops they are symmetrical like (+) (*) etc
14:35:41 <Peaker> @type \x y -> const <$> x <*> y
14:35:42 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f a
14:35:51 <Peaker> @type \x y -> flip const <$> x <*> y
14:35:52 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a1 -> f a -> f a
14:36:34 <Peaker> mreh, Notice that unlike Functor which never touches the "f" when converting "f a -> f b",  Applicative takes two "f"s and returns just one "f", so it must do some sort of combining between the two f's
14:36:43 <ivanm> bos: you around?
14:36:50 <Peaker> mreh, in the case of the IO Applicative, for example, the combining is just sequencing effects
14:36:58 <mreh> uhuh
14:37:04 <bos> ivanm: not really
14:37:10 <mreh> is the default defined in terms of >>= then?
14:37:20 <ivanm> bos: just wanted to know if you got my patch for criterion
14:37:27 <Peaker> mreh, The monadic (>>) is defined in terms of (>>=), but Applicative (>>) is just (*>)
14:37:29 <Peaker> @type (*>)
14:37:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
14:37:36 <bos> ivanm: i did, thanks
14:37:41 <Peaker> (defined in terms of fmap, const and <*>)
14:37:54 <ivanm> np
14:38:02 <mreh> exciting stuff
14:38:06 <mreh> I need time to digest
14:38:50 <hpc> @src (*>)
14:38:50 <lambdabot> (*>) = liftA2 (const id)
14:40:43 <Makoryu> @src (<*)
14:40:43 <lambdabot> (<*) = liftA2 const
14:40:47 <soupdragon> well I have found an example of solving a quintic..
14:41:05 <Peaker> @type (const id)
14:41:06 <lambdabot> forall a b. b -> a -> a
14:41:27 <Peaker> (const id) is a funny way to write (flip const) :)
14:41:30 <Peaker> @type flip const
14:41:31 <lambdabot> forall b a. a -> b -> b
14:41:47 <Makoryu> Peaker: I think it optimizes better, strangely enough
14:42:13 <Peaker> Makoryu, Simple rewrite rule could take care of such things :)
14:42:34 <Makoryu> Yeah, it's arguably a bug in GHC's whatchamacallitizer
14:43:04 * Makoryu forgets the name of the optimization stage actually responsible for the problems with flip
14:46:28 <brooksbp> What's the name of the code generator written in Haskell that generates code snippets that you can use to do testing?
14:49:12 <kmc> brooksbp, can you be more specific?
14:49:32 <kmc> QuickCheck generates test cases automatically.  it doesn't really generate "code"
14:49:33 <brooksbp> ah found it, QuickCheck.
14:49:37 <kmc> it can generate functions though
14:50:10 <kmc> the benefit of functional programming is that it's much simpler to generate functions than to generate code
14:50:47 <brooksbp> can quickcheck generate test examples for the lambda calculus?
14:50:56 <kmc> test lambda expressions?
14:50:56 <mreh> :t FRP.Yamp.switch
14:50:57 <lambdabot> Couldn't find qualified module.
14:51:01 <mreh> :t FRP.Yampa.switch
14:51:02 <lambdabot> Couldn't find qualified module.
14:51:12 <kmc> brooksbp, quickcheck can generate values for any type which is an instance of the class "Arbitrary"
14:51:23 <kmc> if you have a type representing lambda expressions, you can make such an instance
14:51:41 <brooksbp> ah
14:52:05 <kmc> brooksbp, RWH has a good chapter about QuickCheck
14:53:00 <mreh> switch :: SF a (b, Event c) -> (c -> SF a b) -> SF a b -- I wonder if I can nest those nicely
14:54:02 <mreh> is that the same as const? (\ _ ->)
14:54:29 <mreh> @pl (\ _ -> f)
14:54:30 <lambdabot> const f
14:55:32 <Peaker> mreh: btw: Did you figure out what Monad adds Applicative?
14:56:04 <mreh> Peaker: I'm not sure what you mean
14:56:25 <copumpkin> preflex: seen preflex
14:56:50 <mreh> preflex: seen godel
14:57:03 <gwern> @botsnack
14:57:03 <lambdabot> :)
14:57:05 <kmc> hi copumpkin
14:57:09 <copumpkin> hi kmc :)
14:57:17 <jmcarthur> "what Monad adds Applicative"?
14:57:17 <Peaker> mreh, Well, Functor i the simplest. Applicative adds pure and <*> to that.  Monad adds something to Applicative
14:57:25 <Peaker> oops, missing "to"
14:57:38 <Peaker> I wrote that blindly, as my computer was running "ld", thrashing as hell, and responding with 30 sec. delays :)
14:57:44 <kmc> typeclassopedia is a good reference
14:57:46 <mreh> *>
14:57:54 <jmcarthur> Peaker: you are looking for a minimal addition or just something not expressible with applicative?
14:57:55 <kmc> Applicative adds two things, that "should" be in different classes
14:58:07 <Peaker> mreh, *> is an Applicative operation. Monads adds new power, not expressible with Applicative alone
14:58:17 <kmc> class (Functor f) => Pointed f where { pure :: a -> f a }
14:58:29 <mreh> hmm
14:58:29 <jmcarthur> oh are you just guiding mreh?
14:58:31 <Peaker> kmc, Yeah, almost giving merit to the "One type-class per method" suggestion :)
14:58:45 <Peaker> (MonadZero, MonadPlus... Zero, Plus instead of Monoid)
14:58:54 <Peaker> jmcarthur, I hope so
14:59:00 <jmcarthur> okay
14:59:04 <mreh> heh
14:59:07 <mreh> :\
14:59:11 <jmcarthur> i was thinking this should have been old school to you. i was confused ;)
14:59:18 <mdmkolbe> Is there a good multimap library for haskell?  (I've searched hackage and the standard libraries and didn't see one, but maybe I missed it.)  I could write one as a Map of a Set, but if one already exists, then it'd save me time/effort.
14:59:33 <mreh>  /o\
14:59:50 <kmc> mdmkolbe, that's what i've done
15:00:04 <kmc> Map has some good "combining" insert, union, etc
15:00:06 <kmc> though iirc it's missing a few
15:00:08 <mreh> pure does lifting
15:00:14 <mreh> monad has bind
15:00:21 <mreh> also
15:00:28 <kmc> :t M.unionWith S.union
15:00:29 <lambdabot> forall a k. (Ord a, Ord k) => M.Map k (S.Set a) -> M.Map k (S.Set a) -> M.Map k (S.Set a)
15:00:33 <gwern> http://hackage.haskell.org/packages/archive/criterion/0.5.0.0/doc/html/Criterion-MultiMap.html ?
15:01:14 <Peaker> mdmkolbe, I once wrote: http://github.com/Peaker/MapManyToOne
15:01:25 <jmcarthur> this explains what you can do with the various effects classes pretty well, IMO http://just-bottom.blogspot.com/2010/04/programming-with-effects-story-so-far.html
15:02:19 <Peaker> jmcarthur, Not sure calling it "effects" is leading or misleading
15:02:24 <mreh> Peaker: I give up, but it has something to do with bind, give me  a clue
15:02:38 <mreh> :t (>>=)
15:02:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:02:42 <mreh> :t <*>
15:02:42 <lambdabot> parse error on input `<*>'
15:02:48 <mreh> :t (<*>)
15:02:48 <kmc> "join" is also sufficient to get you to Moand from Applicative
15:02:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:02:49 <Peaker> jmcarthur, why does he say Applicative does "parallel" composition?
15:03:47 <kmc> mreh, try writing this with Applicative:  do { v <- getChar; if v == 'x' then print 3 else return () }
15:04:17 <mreh> :t join . (<*>)
15:04:18 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
15:04:18 <lambdabot>     Probable cause: `<*>' is applied to too few arguments
15:04:18 <lambdabot>     In the second argument of `(.)', namely `(<*>)'
15:04:21 <jmcarthur> Peaker: i assume because applicative itself doesn't require any particular ordering of effects
15:04:26 <edwardk> hrmm does anyone know if there is already a 'soft heap' implementation in haskell?
15:04:31 <roconnor> kmc: can't be done
15:04:37 <kmc> roconnor, right
15:04:39 <mreh> soft heap sounds dirty
15:04:40 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25453 <-- Anyone got any clever ideas to let me avoid needing wrap1 through 5?
15:04:40 <ddarius> edwardk: Define "soft heap"
15:04:43 <Peaker> jmcarthur, But it does allow ordering of effects
15:04:44 <jmcarthur> i guess that's not strictly different from Monad though
15:04:48 <jmcarthur> yes it allows it
15:05:04 <Peaker> jmcarthur, Monad does imply ordering, without some deep trickery :)
15:05:06 <jmcarthur> i think that wording may be a bit handwavy, is all
15:05:14 <Peaker> (covariance and positive positions in the type)
15:05:33 <jmcarthur> Peaker: but applicative doesn't imply it
15:05:55 <edwardk> heap with key corruption rate based on the number elements you've inserted so far, used to make optimal minimum spanning tree implementations and do median selection in linear time, etc.
15:05:59 <Peaker> jmcarthur, If we had UnorderedPair, we could guarantee no ordering
15:06:19 <mreh> @undo do { v <- getChar; if v == 'x' then print 3 else return () }
15:06:20 <lambdabot> getChar >>= \ v -> if v == 'x' then print 3 else return ()
15:06:21 <edwardk> er rather with a bounded corruption rate based on the number of elements you've inserted so far and an specified epsilon
15:06:21 <Peaker> or just replace (<*>) with something on a Set
15:06:32 <jmcarthur> alas we only have regular structures
15:06:43 <Peaker> Actually that's silly, we could just have a law about order of effects not mattering
15:06:48 <jmcarthur> but i don't think that's the point
15:07:17 <jmcarthur> he didn't say the order of effects don't matter. he just said that applicative doesn't impose such a restriction
15:07:24 <edwardk> ddarius: http://www.siam.org/proceedings/soda/2009/SODA09_053_kaplanh.pdf
15:07:27 <jmcarthur> that's my reading, anwyay
15:07:29 <jmcarthur> *anyway
15:07:32 <ddarius> Peaker: There are still two different definitions of (<*>)
15:07:40 <Peaker> mdmkolbe, did you look at it?
15:07:48 <Peaker> ddarius, ?
15:08:29 <ddarius> Peaker: Depending on whether the execution is left-to-right or right-to-left.
15:08:50 <Peaker> ddarius, oh
15:08:54 <ddarius> :t (<**>)
15:08:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
15:09:17 <mdmkolbe> Peaker: yeah, I just need the "backward/one-to-many" part though.  I might use it as a starting point.
15:09:22 <jmcarthur> "The next step on the ladder of expressiveness is ArrowChoice, which allows us to branch according to the input of the box, but the branches still have a static structure. This restriction is lifted by the Monad (or the equivalent ArrowApply) interface, which grants us the ability to manipulate arrows as first class entities during runtime, i.e. within the interpretation phase."
15:09:25 <Peaker> @type liftA2 (flip ($))
15:09:27 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f (a -> b) -> f b
15:09:49 <jmcarthur> that's something that is interesting about monads and why haskell does IO better than most imperative languages :)
15:10:06 <jmcarthur> " When we program in mainstream imperative languages, we rarely have the opportunity to venture beyond the limits of ArrowChoice."
15:10:11 <Peaker> jmcarthur, I thought there was established equivalence between (Category+Applicative) and Arrow (iirc)
15:10:26 <jmcarthur> Peaker: didn't he say that
15:10:27 <jmcarthur> ?
15:10:37 <Peaker> jmcarthur, I only skimmed it :)
15:10:48 <jmcarthur> Peaker: "Arrow is strictly the intersection of Applicative and Category."
15:11:01 <Peaker> jmcarthur, In mainstream imperative languages, you can use previous input to parameterize the next actions
15:11:08 <Peaker> Not sure what he means by that limitation
15:11:22 <Peaker> jmcarthur, Why keep Arrow then?
15:11:27 <Peaker> (Seems redundant)
15:11:28 <jmcarthur> Peaker: why indeed
15:11:30 <jmcarthur> it is
15:11:40 <ddarius> Peaker: Category was abstracted from Arrow.
15:11:58 <edwardk> jmcarthur: too bad one can't enforce that in the type for arrow it'd be nice to always be able to use either sugar without wrapping, etc.
15:12:04 <Peaker> Though I'd speculate conal's DeepArrow is useful
15:12:06 <gwern> huh. top measures time in minutes right?
15:12:08 <jmcarthur> i've been exploring other avenues for alt-stdlib
15:12:10 <Peaker> (and not stemming from any of those)
15:12:15 * gwern has one darcs pull which has run for 3847 units
15:12:19 <jmcarthur> edwardk: yeah!
15:12:27 <gwern> I guess that's the merge bug in action
15:12:36 <gwern> dang people who haven't upgraded to darcs-2 format
15:13:08 <jmcarthur> edwardk: i experimented with whitespace overloading partly to toy with treating things like Kleisli arrows as normal functions. it was, as expected, pretty messy
15:13:15 <ivanm> gwern: blame the windows users, apparently they're the ones mainly still using darcs-1
15:13:16 <edwardk> Peaker: class (Category k, Applicative (forall a. k a)) => Arrow k  -- sadly isn't definable
15:13:32 <Peaker> edwardk, because of the quantifier?
15:13:41 <gwern> ivanm: windows and mac users seem to be reasponsible for everything bad!
15:13:54 <ivanm> yup
15:13:55 * gwern has heard hitler, stalin, and mao all used windows or macs
15:14:02 <jmcarthur> bifunctors generalized to work on categories other than just Hask largely alleviates the need for Arrow
15:14:11 <ivanm> next up is ubuntu users (LTS releases with people still using GHC 6.8)
15:14:19 <edwardk> jmcarthur: i actually had a small interpreter i was trying to use the wadler et al style arrow calculus as the basis for the implementation of application
15:14:21 <copumpkin> omg edwardk abandoned his channel!
15:14:32 <edwardk> copumpkin: nah, just signed in ;)
15:14:37 <copumpkin> :)
15:14:39 <jmcarthur> edwardk: i *still* haven't checked that out. been meaning to
15:14:48 <edwardk> jmcarthur: don't bother
15:14:52 <jmcarthur> oh?
15:15:00 <edwardk> jmcarthur: the method used in the paper is flawed
15:15:05 <jmcarthur> oh :(
15:15:12 <jmcarthur> now i think i recall you saying something like that before
15:15:18 <scotty> Is there a function already in Prelude that permutes tuples, or, more specifically, compares tuples for equality regardless of the order of the elements?
15:15:27 <ivanm> gwern: lol
15:15:30 <copumpkin> scotty: nope
15:15:33 <copumpkin> it can't be written
15:15:37 <edwardk> jmcarthur: they out-clevered themselves with their proof of equivalence
15:15:40 <scotty> Wha-?
15:15:43 <ivanm> @remember gwern [I have] heard hitler, stalin, and mao all used windows or macs
15:15:43 <lambdabot> It is forever etched in my memory.
15:15:44 <jmcarthur> copumpkin: can't be written?
15:15:53 <scotty> Er, okay.
15:16:07 <jmcarthur> copumpkin: why not?
15:16:09 <copumpkin> jmcarthur: what would the type be? equality comparison of tuples regardless of order?
15:16:13 <scotty> What, about lists of n elements?
15:16:26 <scotty> So, [1,2,3] == [3,2,1]
15:16:34 <edwardk> sadly, it is published, and was disproved more or less at the conference, so no strong rebuttal will probably ever be published, so it'll sit there and mislead folks, which I think is worse than not having existed in the first place
15:16:41 <jmcarthur> copumpkin: presumably it was intended to look like  (===) :: (a, a) -> (a, a) -> Bool
15:16:51 <copumpkin> jmcarthur: oh, I was thinking about heterogeneous tuples
15:17:02 <copumpkin> (of arbitrary length, possibly)
15:17:37 <jmcarthur> > Set.fromList [1,2,3] == Set.fromList [3,2,1]
15:17:38 <lambdabot>   Not in scope: `Set.fromList'Not in scope: `Set.fromList'
15:17:48 <jmcarthur> > Data.Set.fromList [1,2,3] == Data.Set.fromList [3,2,1]
15:17:48 <lambdabot>   Not in scope: `Data.Set.fromList'Not in scope: `Data.Set.fromList'
15:17:50 <gwern> copumpkin: a little template-haskell will fix that!
15:17:54 <jmcarthur> err
15:18:00 <jmcarthur> :t Data.Set.fromList
15:18:01 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
15:18:02 <gwern> > S.fromList [1,2,3] == S.fromList [3,2,1]
15:18:03 <lambdabot>   True
15:18:06 <jmcarthur> bah
15:18:12 <jmcarthur> scotty: ^^
15:18:16 <scotty> Nice
15:18:22 <BMeph> scotty: Did you mean comparing tuples, all with the same component types, or tuples with different ones?
15:18:27 <gwern> jmcarthur: the qualified names are listed in mueval's Context.hs if you care
15:18:33 <jmcarthur> gwern: thanks
15:18:41 <BMeph> > S.fromList [1,2,3] == S.fromList [3,2,1, 3]
15:18:42 <lambdabot>   True
15:19:38 <gwern> BMeph: were you expecting that to be false?
15:19:49 <copumpkin> he was showing how it didn't match the spec exactly
15:20:51 <BMeph> gwern: No.... Okay, "lists of n elements" -> avoids duplicates. NM. :)
15:20:56 <walrus_> hi guys, any idea of how can you can create a type in Haskell representing a polymorphic tree of functions?
15:21:06 <jmcarthur> > sort [1,2,3] == sort [3,2,1, 3]
15:21:07 <lambdabot>   False
15:21:09 <jmcarthur> > sort [1,2,3] == sort [3,2,1]
15:21:10 <lambdabot>   True
15:21:15 <copumpkin> walrus_: polymorphic how?
15:21:36 <scotty> I'm just trying to define == on my Triangle data type, which is Triangle Integer Integer Integer
15:21:44 <BMeph> walrus_: Geez, you didn't even ask if you could ask a question, you just went out and DID IT! (Good job, BTW. ;)
15:21:49 <jmcarthur> scotty: it's easier than that ;)
15:22:00 <jmcarthur> scotty: data Triangle = Triangle Integer Integer Integer deriving Eq
15:22:03 <jmcarthur> :)
15:22:09 <scotty> Wha-?
15:22:19 <scotty> So, that will be agnostic about the order of the integers?
15:22:24 <copumpkin> nope
15:22:26 <jmcarthur> scotty: oh nevermind, sorry
15:22:32 <scotty> That's what I want.
15:22:32 <walrus_> copumpkin: I created a genetic algorithm programa with a type like Tree a = Bin (String, (a -> a -> a)) (Tree a) (Tree a), but I'm trying to generalize to tree that can have in a Bin node, function like a -> b -> c
15:22:32 <jmcarthur> i completely forgot your spec
15:22:41 <jmcarthur> yeah you need to write your own. my bad
15:22:45 <scotty> Okay
15:23:07 <ivanm> compare `on` sort ?
15:23:13 <scotty> Also, I don't want fromList.
15:23:17 <scotty> It will remove duplicates.
15:23:17 <gwern> scotty: 'instance Eq Triangle where (==) (Triangle a b c) (Tiangle x y z) =  a==x && b==y && c==z' is mechanical and straightforward enough that ghc can write it for you
15:23:21 <Peaker> walrus_, Why not compose your Tree from a generic tree:   data Tree a = Bin a (Tree a) (Tree a) | Tip    and then just use:  Tree (String, (a -> a -> a)) ?
15:23:21 <scotty> I think sort is what I want.
15:23:22 <walrus_> copumpkin: using just a specifica type in the Tree, I can convert a tree to a function in a very easy way: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25454#a25454
15:23:26 <jmcarthur> scotty: yeah you want sort
15:23:27 <ivanm> > (compare `on` sort) [1,3,2,3] [3,2,1]
15:23:28 <lambdabot>   GT
15:23:35 <ivanm> oh, right
15:23:39 <BMeph> "instance Triange Eq where Triangle x y z == Triangle a b c = sort [x,y,z] == [a,b,c]", perhaps? :)
15:23:39 <scotty> gwern: I need to be agnostic about order.
15:23:44 <jmcarthur> (==) `on` sort
15:23:48 <ivanm> > (compare `on` (map head . group . sort)) [1,3,2,3] [3,2,1]
15:23:49 <lambdabot>   EQ
15:23:58 <ivanm> jmcarthur: (==), compare, same diff
15:24:02 <scotty> I like BMeph's.
15:24:05 <gwern> scotty: so toss in 2 more disjunctions
15:24:11 <BMeph> \o/
15:24:17 <scotty> gwern: I think that's ugly.
15:24:22 <alex404> Does the first of the double of ints (i,i) that you give to createCArray offset the CArray by that much, or is it just arbitrary indexing?
15:24:23 * ddarius would probably write out the equalities.
15:24:28 <jmcarthur> BMeph's is wrong ;)
15:24:31 <scotty> Oh
15:24:34 * gwern thinks BMeph's is cheating
15:24:40 <antont> i'm trying to build a hs project using cabal, and get this error: File name does not match module name: Saw: `Main' Expected: `Fenfire' .. the project is at http://antti-juhani.kaijanaho.fi/darcs/fenfire-hs/
15:24:50 <jmcarthur> needs to say sort [x,y,z] == sort [a,b,c]
15:24:50 <gwern> ddarius: yeah, but 'that's ugly'
15:24:51 <scotty> Well, can't you do sort [x,y,z] == sort [a,b,c] ?
15:24:55 <jmcarthur> right
15:25:06 <ddarius> gwern: Yes, it's the ugliest solution, except for all the others.
15:25:11 <scotty> That's what I interpreted it as.  I sort of just glossed over it, but I thought that's what he was trying to do.
15:25:12 <gwern> jmcarthur: I just assumed that was a typo
15:25:14 <walrus_> Peaker: I created a generic tree, but I want to have different functions types in it
15:25:18 <antont> tried to google about that and got some hints in http://trac.haskell.org/haddock/ticket/73 but that seemed to be a bit different thing
15:25:26 <ivanm> scotty: that's what ((==) `on` sort) does
15:25:43 <walrus_> I tried GADTs but didn't found a way to convert a Tree to a function
15:26:00 <jmcarthur> instance Eq Triangle where (==) = (==) `on` (sort.toList) where toList (Triangle a b c) = [a,b,c]
15:26:11 <walrus_> (if a only could pattern matching types :P)
15:26:12 <jmcarthur> toList might be useful elsewhere, so that one might be nice
15:26:19 <jmelesky> edwardk: sorry, tuned out for a while and didn't get your responses till now. you still up for chatting about sml?
15:26:43 <gwern> hell, if we want to bring in datastructures let's just use set
15:26:55 <gwern> 'S.fromList [a,b,c] == S.fromList [x,y,z]'
15:27:04 <jmcarthur> gwern: we already discussed that one
15:27:06 <BMeph> scotty, jmcarthur  Yes, that's what I meant, but it wasn't what I wrote. Good call, jmcarthur! :)
15:27:15 <jmcarthur> set removes duplicates
15:27:51 <ddarius> jmcarthur: So?  It will still do the right thing for this.
15:27:55 <gwern> jmcarthur: so? if one triangle is 2 1 1, and the other is 1 1 2, both sets are 1 2
15:28:23 <gwern> and 1 2 won't give the wrong answer with some 1 2 3 triangle
15:28:32 <jmcarthur> meh, okay
15:28:55 <edwardk> jmelesky: sure. i was afk for quite a while in there as well, but we should probably move the off topic chatter somewhere else, like #kata or #haskell-blah
15:29:17 <scotty> Ah
15:29:54 <scotty> I went away for a sec, but I just finsihed reading.  So, should I just add two more disjunctions? XD  Maybe using sort is overkill.
15:30:10 <scotty> I don't have much style yet when it comes to Haskell.  I'm still learning.
15:30:39 <Peaker> walrus_, Different function types in each node?
15:30:43 <gwern> I think I'd just use sort. the disjunctions are probably a bit opaque
15:30:57 <walrus_> Peaker: exactly
15:31:01 <aristid> why does Num require Show and Eq?
15:31:07 <kmc> scotty, we can give style advice if you like
15:31:07 <copumpkin> aristid: nobody knows
15:31:17 <BMeph> scotty: I'd go with gwern's suggestion, and use Set comparison. ;)
15:31:23 <gwern> if you were to switch from Integers to Num in general, I guess I'd wonder abotu switching to disjunctions
15:31:27 <walrus_> with GADTs I can make data Tree  where
15:31:31 <kmc> aristid, they got too drunk at a Haskell 98 committee after-party
15:31:42 <walrus_> Un :: (a -> b) -> Tree -> Tree | V :: Tree
15:31:50 <aristid> copumpkin: wow, it took you only 6 seconds, including network latency. :D
15:31:51 <BMeph> aristid: Becaute The Committee was bored and cranky from low blood sugar! ;)
15:31:52 <copumpkin> aristid: the Eq is because of "pattern matching" on numbers, probably
15:31:53 <gwern> I mena, sort requires 'Ord' doesn't it? the disjunctions just require Eq
15:31:58 <Peaker> aristid, Eq for emulating "pattern matching", and Show... I am not sure
15:32:11 <gwern> :t Data.List.sort
15:32:12 <lambdabot> forall a. (Ord a) => [a] -> [a]
15:32:25 <alex404> Does anyone know how to use createCArray?
15:32:34 <aristid> maybe so the standard can say that 4 is a Num?
15:32:42 <gwern> scotty: yeah, so that's when you'd want the disjunctions - when you don't have Ord, but only Eq for your parameters
15:32:42 <Peaker> walrus_, Why not just have a tree of a sumtype?
15:32:44 <aristid> a generic Num
15:32:54 <alex404> I don't understand why it takes a function on a ptr as opposed to just a pointer as an argument
15:33:09 <walrus_> but if try to create a function: convertToFunction (Un uf u) = uf.(f u) ; convertToFunction V = id, I get "Inferred type is less polymorphic than expected ;   Quantified type variable `a' is mentioned in the environment:     f :: Tree -> a1 -> a (bound at main.hs:19:0)"
15:34:01 <BMeph> aristid: A momentary lapse of premature optimisation. :)
15:34:10 <walrus_> Peaker: because I don't know what is a tree of a sumtype? ;)
15:34:19 <aristid> is there a sort that takes a sort comparison function?
15:34:24 <Peaker> walrus_, A sum type is something like Either
15:34:38 <Peaker> walrus_, data MySumType = A (a -> b) | B (a -> a -> a) | C ...
15:34:43 <Peaker> walrus_, Tree MySumType
15:34:54 <gwern> aristid: sortBy?
15:35:01 <aristid> :t sortBy
15:35:02 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
15:35:11 <aristid> gwern: thanks :D
15:35:22 <Makoryu> @hoogle sortOn
15:35:22 <lambdabot> No results found
15:35:38 <copumpkin> I think data-ordlist has it
15:35:41 <Makoryu> @let sortOn f = sortBy (comparing `on` f)
15:35:42 <lambdabot>  <local>:3:0:
15:35:42 <lambdabot>      Multiple declarations of `L.sortOn'
15:35:42 <lambdabot>      Declared at: <loc...
15:35:50 <Makoryu> Whoops
15:35:51 <copumpkin> that's not the most efficient way to do it
15:35:58 <aristid> @let sortOn f = sortBy (compare `on` f)
15:35:59 <lambdabot>  <local>:3:0:
15:35:59 <lambdabot>      Multiple declarations of `L.sortOn'
15:35:59 <lambdabot>      Declared at: <loc...
15:36:00 <Makoryu> copumpkin: I suppose not
15:36:04 <aristid> oO
15:36:07 <Makoryu> Wait, why did I write comparing
15:36:08 <aristid> :t sortOn
15:36:09 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
15:36:10 <Makoryu> @unlet
15:36:11 <lambdabot>  Defined.
15:36:15 <copumpkin> http://hackage.haskell.org/packages/archive/data-ordlist/0.4.3/doc/html/Data-List-Ordered.html#v%3AsortOn
15:36:29 <Makoryu> :t unwords . sortOn length . words
15:36:30 <lambdabot> String -> String
15:36:47 <walrus_> Peaker: I don't see how this would help me, or how I would convert a tree to a function
15:37:06 <aristid> > (unwords . sortOn length . words) "hello Makoryu, i want to try this"
15:37:07 <lambdabot>   "i to try want this hello Makoryu,"
15:37:41 <Makoryu> @src sortOn
15:37:41 <lambdabot> Source not found.
15:37:47 <aristid> @src sortBy
15:37:47 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
15:38:01 <aristid> @src insertBy
15:38:01 <lambdabot> insertBy _   x [] = [x]
15:38:02 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
15:38:02 <lambdabot>                                  GT -> y : insertBy cmp x ys'
15:38:02 <lambdabot>                                  _  -> x : ys
15:38:08 <Makoryu> @src sort
15:38:09 <lambdabot> sort = sortBy compare
15:38:25 <aristid> haha that's a funny implementation
15:38:32 <Makoryu> It's not very efficient :|
15:38:57 <Makoryu> I'd be surprised if that's actually the implementation GHC uses
15:39:11 <aristid> i'm 100% confident it's not.
15:39:25 <copumpkin> yeah, lol
15:39:29 <copumpkin> not sure where that came from
15:39:52 <aristid> it's to illustrate what the function does
15:40:31 <Peaker> walrus_, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25454#a25455
15:43:06 <ddarius> copumpkin: The report.
15:43:44 <copumpkin> ddarius: wow, I should probably read it someday
15:43:55 <walrus_> Peaker: this doesn't works
15:44:47 <Peaker> oops
15:45:40 <Peaker> walrus_, fixed: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25454#a25456
15:46:34 <Peaker> walrus_, The idea is to generalize on the notion of a Tree that has bin/un nodes, parametrize it for stuff in all nodes, stuff in just bin nodes, stuff in just un nodes
15:47:38 <walrus_> Peaker: but is possible to create a Tree like: Un (Int -> Double) (Un (String -> Int) V) with this kind of Tree?
15:49:25 <walrus_> Peaker: and I don't know how to create a simple Tree with your type, like a: Un id V
15:49:33 <Peaker> walrus_, You can do Tree bin (Either (Int -> Double) (String -> Int)) a
15:49:53 <Peaker> walrus_, I just extracted the specific into type variables from your type
15:50:09 <Peaker> walrus_, otherwise it's almost the same
15:51:37 <walrus_> Peaker: the problem is that I'm trying a general solution. This solution with Either is not general, in my problem I will need a lot of different types (Int -> String), (Int -> Int), (Int -> Double), (Double -> Int), etc.
15:53:10 <jmcarthur> @let withWords = (unwords .) . (. words)
15:53:10 <lambdabot>  Defined.
15:53:19 <walrus_> Peaker: and would need to generate different random trees with these functions. With a GADTs I could create this kind of Tree, but can't see a way to convert the Tree to a function
15:53:23 <Peaker> walrus_, what is the common thing of all these functions? How can you use the functions if you have no idea what types they can be?
15:54:03 <walrus_> Peaker: the common thing is the number of arguments
15:54:12 <jmcarthur> > withWords . sortOn length $ "hello Makoryu, i want to try this"
15:54:13 <lambdabot>   Couldn't match expected type `[GHC.Base.String]
15:54:13 <lambdabot>                            ...
15:54:18 <jmcarthur> oops
15:54:26 <jmcarthur> > withWords (sortOn length) "hello Makoryu, i want to try this"
15:54:27 <lambdabot>   "i to try want this hello Makoryu,"
15:54:27 <Peaker> walrus_, that's not enough to be able to actually use those functions
15:55:12 <Peaker> jmcarthur, that should be inWords, probably.. withWords is (words .) . (. unwords)
15:55:20 <jmcarthur> you're right
15:56:13 <Makoryu> :t with
15:56:15 <lambdabot> Not in scope: `with'
15:56:22 <jmcarthur> @let inWords = (unwords .) . (. words)
15:56:23 <lambdabot>  Defined.
15:56:50 <jmcarthur> > sortOn length `inWords` "hello Makoryu, i want to try this"
15:56:51 <lambdabot>   Not in scope: `sortOn'
15:56:58 <jmcarthur> o_O
15:57:04 <walrus_> Peaker: if a make a GADT, data Tree where Un :: (a->b) -> Tree -> Tree | V :: Tree, I could create a tree like Un head (Un tail V), I can create this 'valid' Tree, but can convert it to head.tail, understand?
15:57:06 <Makoryu> The hell?
15:57:11 <Axman6> sortBy
15:57:17 <Axman6> :t sortBy
15:57:17 <hiptobecubic> jmcarthur, ?   so that .... does what now? Or rather i see what it does, but how?
15:57:18 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
15:57:23 <Makoryu> Axman6: No, sortOn is what we want here
15:57:28 <Makoryu> :t sortOn
15:57:29 <lambdabot> Not in scope: `sortOn'
15:57:30 <Axman6> doesn't exist
15:57:32 <Peaker> walrus_, you mean "a" and "b" are Tree params?
15:57:36 <Peaker> walrus_, or existentials?
15:57:43 <jmcarthur> hiptobecubic: inWords?
15:57:51 <walrus_> Peaker: existentials
15:57:52 <Makoryu> @let sortOn c = sortBy (on compare c)
15:57:53 <lambdabot>  Defined.
15:57:55 <jmcarthur> hiptobecubic: inWords f = unwords . f . words
15:57:56 <Makoryu> :t sortOn
15:57:57 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [a]
15:57:59 <jmcarthur> another definition
15:58:04 <jmcarthur> > sortOn length `inWords` "hello Makoryu, i want to try this"
15:58:05 <lambdabot>   "i to try want this hello Makoryu,"
15:58:06 <Peaker> walrus_, if they're existentials, what can you do with them?
15:58:31 <kmc> :t inWords
15:58:32 <lambdabot> ([String] -> [String]) -> String -> String
15:59:25 <Makoryu> > filter ((> 5) . length) `inWords` "I'm sorry, Axman. I'm afraid I can't do that."
15:59:26 <lambdabot>   "sorry, Axman. afraid"
15:59:41 * Axman6 is not!
16:00:02 <walrus_> Peaker: well, In my specific case, I can't make a function: Tree -> a -> b; and have no idea if this is possible
16:01:33 <walrus_> Peaker: the GADT was just a desesperate solution, but doesn't appears to help
16:02:26 <Peaker> walrus_, what is this for?
16:03:12 <soupdragon> whatabout Tree a b -> (a -> b)
16:03:41 <copumpkin> omg instance Arrow Tree ;)
16:03:50 * copumpkin (jumps in without knowing wtf the topic is0
16:03:51 <walrus_> Peaker: is for a genetic programming model that I'm using in a research
16:04:01 <aristid> type Memo a = forall r. (a -> r) -> (a -> r)
16:04:02 <copumpkin> maybe instance Category Tree
16:04:08 <aristid> is this an existential type?
16:04:17 <aristid> (from http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.0/doc/html/src/Data-MemoCombinators.html )
16:04:50 <walrus_> Peaker: I need to create random programs, represented by these trees, mutate and cross it, etc. I already made the program to functions of just one type
16:05:04 <ddarius> aristid: No.
16:05:19 <ddarius> aristid: At least depending on your intent.
16:05:22 <Peaker> walrus_, Sounds like a uniform type is the way to go here...
16:05:50 <aristid> ddarius: what is it, then?
16:06:14 <ddarius> aristid: It's a universal type.
16:06:48 <walrus_> Peaker: uniform type?
16:06:55 <Peaker> walrus_, "just one type"
16:07:09 <aristid> ddarius: don't know that term yet
16:07:11 <Peaker> walrus_, Though maybe you can have something like:  data Tree o where Un :: (a -> o) -> Tree a -> Tree o ; Two :: (a -> b -> o) -> Tree a -> Tree b -> Tree o
16:07:31 <ddarius> aristid: forall == universal quantification,  exists = existential quantification.
16:08:37 <ddarius> aristid: GHC doesn't allow you to write "exists" anywhere and its syntax for local existential types uses forall due to a equivalence between certain expressions using forall and exists.
16:08:54 <walrus_> Peaker: well, but in my specific problem just one type is not enough, I will need function like the scalar product of two vectors, and binary functions of two vector returning another vector
16:08:58 <ddarius> (and due to a desire not to create extra reserved identifiers)
16:09:35 <aristid> ddarius: the problem is i don't understand a word of this
16:09:55 <ddarius> aristid: Then you look up the words.
16:10:05 <Peaker> walrus_, how do you intend to modify the tree structure and still keep all the types correct?
16:10:05 <ddarius> @google universal quantification
16:10:07 <lambdabot> http://en.wikipedia.org/wiki/Universal_quantification
16:10:08 <lambdabot> Title: Universal quantification - Wikipedia, the free encyclopedia
16:10:21 <Peaker> walrus_, Don't you need some form of invariant to help the modifications?
16:12:18 <aristid> ddarius: i know what universal quantification is in other contexts
16:12:59 <Kaidelong> does haskell's bottom always fall through the entire computation or is there a way to catch bottom?
16:13:21 <ddarius> Kaidelong: Bottom is equivalent to non-termination.
16:13:21 <Peaker> Kaidelong, It falls through the entire pure computation. In IO you can be lucky enough to catch some bototms
16:13:32 <walrus_> Peaker: I tried a way with type classes, something like: class RandomElement a ; pickRandom :: a  ; instance  RandomElement (Int -> Int) where pickRandom = getRandom [abs, `mod` 7]
16:14:02 <Peaker> walrus_, but how do you intend to change the structure of the tree but still retain the type correctness of functions connected to each other?
16:14:03 <Kaidelong> ddarius: okay, so as a design pattern I will use the option data type from the start and check for bad input beforehand?
16:14:16 <Kaidelong> and use liftM to compose on it
16:14:42 <walrus_> Peaker: but again, I could not create the convertion function of a tree to a function
16:14:59 <ddarius> Kaidelong: Ideally, you design in such a way that such checks are only needed at the outermost parts of your program, i.e. the user interface parts, and you don't have to constantly check anything.
16:15:03 <Peaker> walrus_, I'd worry even more about mutating the tree -- with the above GADT I think converting to a function would work
16:15:43 <Kaidelong> ddarius: I have a situation (gaps in input data and refusal of answering when extrapolating) where the behavior is desirable
16:16:08 <walrus_> Peaker: didn't worked. Give the error "Inferred type is less polymorphic than expected"
16:16:19 <copumpkin> it escaped!
16:16:21 <ddarius> Kaidelong: Then using the Maybe monad may be appropriate.
16:16:24 <copumpkin> catch it, quick
16:16:44 <Kaidelong> ddarius: Maybe monad is what I meant, I'm still calling them option types. my bad
16:17:27 <copumpkin> why not the Maybe functor?
16:17:30 <copumpkin> :P
16:18:13 <ddarius> copumpkin: Because the whole structure of the monad is what is appropriate for the problem.
16:18:36 <copumpkin> aha
16:18:43 <copumpkin> I didn't see the rest of the description
16:19:08 <ddarius> Kaidelong: You may also want to look at Applicative.
16:21:12 <walrus_> Peaker: the sad thing is that with uniform type I already replicated the results of an article ("Statistical mechanics of Program Systems" -  JP Neirotti, N. Caticha), that was made using Lisp, and the Haskell solution is faster.
16:22:28 <walrus_> Peaker: but thanks, I will keep thinking in a way to make this with Haskell.
16:22:55 <Peaker> walrus_, How does the lisp solution mutate stuff while keeping the function connections senseful?
16:24:29 <Kaidelong> ddarius: applicative monads are a less syntax heavy way to lift functions, no? learnyouahaskell does cover it, so I'll go look there, but that's how I remember them
16:24:38 <Kaidelong> oh wait, no, there was something else to it
16:25:06 <aristid> ddarius: hmm i think i understand it better now. universal type is a type with an unlocalised implicit or explicit forall, right? like the type of the function id
16:25:09 <aristid> :t id
16:25:10 <lambdabot> forall a. a -> a
16:25:40 <aristid> so i could write type IdType = forall a. a -> a and id :: IdType
16:26:39 <ddarius> aristid: With extensions, you can write that, yes.
16:28:06 <aristid> ddarius: do i need the same extension (-XRankNTypes?) to compile this module? http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.0/doc/html/src/Data-MemoCombinators.html
16:28:40 <ddarius> aristid: Yes.
16:29:51 <Peaker> Kaidelong, "Applicative Functors", not "applicative monads"
16:31:26 <Kaidelong> Peaker: so I see, I'll check out other resources
16:46:59 <blackdog> anyone got a current lambdabot install? i can't build because show needs quickcheck < 2 and tagsoup needs quickcheck 2.1.*
16:53:54 <Zao> blackdog: Maybe use an older tagsoup?
16:55:57 <blackdog> Zao: cheers, i'll try that... but shouldn't cabal's selection algorithm work that out?
17:00:53 <Zao> blackdog: It's up to the cabal file to specify that you want a constraint on a package.
17:01:56 <Zao> blackdog: It has no idea what dependencies different versions of a package has. It just trusts that the cabal file author has specified constraints that give versions that are non-conflicting.
17:03:22 <blackdog> Zao: sure, but it's getting those constraints from the cabal file
17:03:44 <blackdog> it's not failing to compile, it's failing to start because it can't find a solution to the constraints of the cabal file
17:04:20 <Zao> blackdog: I'm talking about constraints once-removed.
17:04:53 <Zao> If you have libomg < 2.4, it'll grab the latest libomg that satisfies that constraint and pray.
17:05:25 <Zao> It won't go somehow grabbing successively older versions just in case they happen to have different secondary constraints.
17:05:49 <Zao> What is "failing to compile" and what is "failing to start"?
17:06:22 <blackdog> Zao: oh, i meant "failing to start compiling" - i get "blah was excluded because foo bar esque"
17:06:28 <blackdog> sorry, not being clear
17:06:39 <Rosebud_> hi, ill like to use the contains function from list, but i dont know which module should i import? any help plz ? :O
17:07:24 <Zao> blackdog: My suggested solution is to dig around hackage to find a version of tagsoup that has suitable constraints and then amending your lambdabot cabal file with suitable constraints.
17:07:31 <Zao> And then submit a patch to the author.
17:07:48 <Zao> Or while experimenting, provide additional constraints to the cabal-install command line.
17:08:44 <blackdog> oh, i see what you mean. ok, cool.
17:09:48 <Saizan> blackdog: the current dependency solver is quite simple so it doesn't even aim to be a complete one, some hints are necessary at times
17:10:51 <blackdog> Saizan: is there a plan to make it more comprehensive? I know dev time is precious
17:12:20 <blackdog> Zao: how would you track down how tagsoup is being called in? it doesn't appear to be in the cabal file directly
17:13:14 <Saizan> blackdog: there are some known incremental improvements one could make, and there's the option of rewriting it using a SAT solver
17:14:26 <Saizan> blackdog: cabal install --dry-run -v helps with that
17:15:30 <Saizan> blackdog: i'd use --contraint="tagsoup == 0.6" since that's the latest that doesn't depend on QC 2
17:16:04 <blackdog> beautiful. thank you.
17:21:20 <blackdog> wheee, ghc segfault...
17:21:32 <copumpkin> sounds fun
17:22:17 <blackdog> think i must have had objects available from a previous compiler.
17:23:02 <dpratt71> I'm about to "sudo make install" the Haskell Platform and I must admit, I'm a little nervous
17:24:13 <dpratt71> what are the chances one or more Haskell-related packages I've already installed will cause problems for me? 0%?
17:25:38 <Saizan> it already built?
17:25:42 <byorgey> dpratt71: what did you already have installed?
17:27:02 <dpratt71> byorgey: cabal-install, ghc6, ghc6-prof, libghc6-mtl-dev, libghc6-mtl-prof
17:27:57 <Saizan> mh, does the platform install its own mtl?
17:28:08 <dpratt71> Saizan: if that last question was to me, yes
17:29:13 <Saizan> it could cause problems to the package one, if the version is the same
17:29:52 <Saizan> and you'll end up with to cabal executables i guess, but that's mostly a problem of deciding which one you want
17:30:13 <danharaj> When parsing a complicated grammar, should I use parsec to lex and then parse separately, or should I just use Parsec.Token?
17:30:14 <dpratt71> Saizan: I think I already have the latter situation
17:30:40 <dpratt71> should I uninstall the packages?
17:30:58 <byorgey> dpratt71: uninstalling the packages is probably a good idea
17:31:09 <dpratt71> byorgey: ok
17:31:12 <Saizan> well, you've to keep ghc, no?
17:31:36 <byorgey> dpratt71: you also don't want things getting screwed up next time you do a system upgrade and it tries to upgrade those packages and screws up your platform install
17:31:43 <byorgey> oh, uh, yes =)
17:32:01 <byorgey> uninstall everything except ghc6 and ghc6-prof
17:32:11 <dpratt71> byorgey: ok
17:32:18 <dpratt71> byorgey: thanks
17:35:41 <Philonous> bah, too much on-topic discussion going on in -blah -.-
17:37:02 <Peaker> Philonous, Lisp/Pascal? :)
17:37:11 <Philonous> type systems
17:37:21 <mdmkolbe> If you have a program that is running under a state monad with a particular state wired in, what is the idomatic name for that state type.  (e.g. data MyState = MyState Int [Char])
17:37:53 <dpratt71> a bit confused concerning cabal-install...subsequent to building the haskell platform, I have one at "/usr/local/bin/cabal"
17:37:57 <byorgey> mdmkolbe: I don't understand the question
17:38:27 <dpratt71> when I "cabal install cabal-install" it puts that one in "~/.cabal/bin"
17:38:42 <byorgey> dpratt71: yes, by default cabal installs things locally
17:38:56 <byorgey> you can "cabal install --global cabal-install" to get it to upgrade the one in /usr/local
17:39:10 <Zao> dpratt71: I tend to solve that by either changing the cabal conf to put stuff in ~/bin, or add .cabal/bin to PATH.
17:39:23 <dpratt71> byorgey: ok, thanks;
17:39:28 <Zao> Or make an global update, of course.
17:39:34 <Saizan> --root-cmd=sudo
17:39:42 <dpratt71> Zao: I see; that makes things clearer thanks
17:40:11 <mdmkolbe> byorgey: I'm writing an application.  It is running under a state monad.  I need to give a name to the datatype for the state that the monad is running with.  What is a good generic name for a datatype that is "the state type for this program"?
17:40:55 <dpratt71> is .bashrc the best place to modify the path?
17:40:57 <Makoryu> mdmkolbe: Gooberwhackister
17:41:14 <Zao> dpratt71: Sounds like something that would only take if you're in a shell.
17:44:16 <dpratt71> what's a good forum/resource for Linux questions of the sort that I just asked?
17:45:48 <byorgey> mdmkolbe: oh, I see.  I usually call it "FooState" where Foo is an appropriate domain-specific noun.
17:46:16 <byorgey> mdmkolbe: but I don't necessarily feel strongly that this is the most aesthetic choice.
17:50:05 <DigitalKiwi> dpratt71: what linux distro do you use?
17:51:04 <dpratt71> Ubuntu 10.4; as is probably evident, I'm a Linux-newb
17:51:42 <DigitalKiwi> oh, then the irc channel is out
17:51:47 <DigitalKiwi> maybe ##linux
17:52:12 <Veinor> why would the irc channel be out?
17:52:31 <DigitalKiwi> because #ubuntu is the worst irc channel i have ever been to for getting help
17:52:36 <Veinor> ah :P
17:52:47 <Cale> dpratt71: I modify my path in ~/.profile
17:53:02 <Veinor> go in there and say 'ubuntu sucks because you can't do X'
17:53:15 <dpratt71> Cale: ok, thanks
17:53:56 <dpratt71> DigitalKiwi: thanks, in ##linux atm, actually
17:54:27 <DigitalKiwi> i once asked in #ubuntu and #debian "if ubuntu is debian then why is there ubuntu?" and managed to not get banned
17:54:31 <DigitalKiwi> i was surprised
17:54:38 <Philonous> Veinor: X works as well on ubuntu as on any other system
17:54:57 <DigitalKiwi> ctrl+alt+backspace
17:54:59 <DigitalKiwi> oh wait
17:55:00 <mdmkolbe> dpratt71: on ubuntu I think they call it ~/.bash_profile instead of ~/.profile.  Use which ever of the two already exists.
17:55:01 <theorbtwo> DigitalKiwi: Hm.  If you asked in both, I'm quite surprised.
17:55:23 <ezyang> \me politely suggests #haskell-blah
17:55:40 <bremner> their actually talking about Haskell there :)
17:55:42 <ezyang> although they're off talking about math there :-)
17:55:46 * copumpkin rudely suggests rudely suggesting #haskell-blah
17:55:55 * pastorn suggests ezyang should learn the difference between / and \
17:56:01 <pastorn> :p
17:56:08 <bremner> copumpkin: get your lazy ass to #h-b
17:56:08 <ezyang> ^_^
17:56:27 <DigitalKiwi> http://xkcd.com/727/
17:56:30 <DigitalKiwi> comic related
17:57:06 <pastorn> haha
17:57:07 <pastorn> nice
18:01:23 <pastorn> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
18:01:23 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:01:31 <pastorn> </trolling>
18:02:48 * hackagebot ghc-mod 0.4.1 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.4.1 (KazuYamamoto)
18:02:52 <kmc> comic related, terrible
18:03:03 <kmc> http://goatkcd.com/727/sfw
18:03:14 <kmc> (not totally sfw)
18:03:37 <ezyang> that is so not sfw.
18:03:59 <danharaj> These are much better than xkcd
18:04:05 <kmc> it's much more sfw than what you get if you remove the last path component
18:04:06 <pastorn> kmc: that's pretty awesome
18:04:14 <tensorpudding> Goatkcd is not better than xkcd.
18:04:24 <danharaj> Science disagrees.
18:04:28 <kmc> it frequently has a working punchline when the original doesn't
18:04:29 <kmc> as in this case
18:04:43 <kmc> this isn't just a non-sequitor, it's actually a coherent story about a guy who goes on the news to goatse everyone
18:04:57 <tensorpudding> Why do people complain about xkcd?
18:05:16 <kmc> the punchline of the original strip is "normal people are stupid".  there's nothing clever about how this idea is presented
18:05:21 <kmc> anyway
18:05:25 <kmc> let's argue about xkcd in #h-b
18:05:30 <kmc> it'd beat the current argument there
18:07:12 <JoeyA> Is it possible to multiply inherit monads?  (note that I still don't fully understand them)
18:07:24 <Peaker> JoeyA, There's no inheritance
18:07:32 <kmc> JoeyA, you might want a stack of "monad transformers"
18:07:49 <JoeyA> For instance, there might be a chain of operations on the ST monad, but you may want to inject prints
18:07:50 <Cale> But monad transformers just turn monads into different monads
18:08:02 <Cale> JoeyA: Can't do that
18:08:03 <Peaker> JoeyA, If you want ST+IO, you can just use IO (which has ST in it)
18:08:09 <kmc> for example, (State s) represents computations which carry a state "s".  (StateT s m) takes the monad m and *adds* this capability to it
18:08:17 <kmc> that is, it takes a monad and gives you another monad with more capabilities
18:08:28 <kmc> however both IO and ST have to live at the bottom of a stack, due to how they're implemented
18:08:33 <kmc> and IO can do everything ST can
18:08:44 <kmc> and there's this safe function
18:08:46 <kmc> :t stToIO
18:08:47 <lambdabot> Not in scope: `stToIO'
18:08:51 <kmc> stToIO :: ST RealWorld a -> IO a
18:09:06 <Peaker> RealWorld?
18:09:09 <kmc> so in that case, i'd just use IO
18:09:11 <Philonous> kmc: Well, but you may want to run a ST action from inside pure code
18:09:18 <copumpkin> Peaker: damn right
18:09:22 <kmc> Philonous, but you certainly can't if it also has prints injected
18:09:26 <kmc> unless you do so unsafely
18:09:35 <Philonous> kmc: point taken
18:09:49 <kmc> Peaker, is a tag of sorts distinguishing the stToIO'd ST action from a runST'd ST action
18:09:56 <kmc> which must have type (forall s. ST s a)
18:09:58 <JoeyA> Does a State monad simply hang on to a variable of an arbitrary type?  For instance, could you create a State Int, then, inside of a do construct, iterate over it like in a for loop?
18:10:04 <kmc> JoeyA, yes
18:10:14 <kmc> JoeyA, it's just sugar for passing that value explicitly from function to function
18:10:20 <kmc> it doesn't create "real" mutable memory
18:10:24 <kmc> which IO and ST both do
18:10:28 <JoeyA> What's the difference between State and ST?
18:10:32 <kmc> ^^^
18:10:39 <kmc> different API too
18:10:43 <JoeyA> Also, why can't everything go into one god monad?
18:10:58 <kmc> JoeyA, much of it could
18:11:03 <Cale> JoeyA: For something to be a monad, it just has to implement a particular API
18:11:07 <JoeyA> Is that like asking: Why can't all methods go into one C++ class?
18:11:07 <kmc> that'd be bad, you'd lose the ability to know what parts of your code use which effects
18:11:11 <kmc> yeah a little bit
18:11:19 <blackdog> JoeyA: half the point is to constrain what pieces of your code can do
18:11:19 <Cale> JoeyA: It's a bit like asking "Why can't we just lump all libraries into one big library?"
18:11:26 <kmc> it's like asking why can't every C++ function be a single function that takes an int saying what it should do
18:11:34 <blackdog> Cale: it's worse than that, even - that'd just be a problem for navigation
18:11:40 <Cale> blackdog: indeed
18:11:42 <blackdog> there's a real semantic distinction
18:11:58 <JoeyA> kmc> Sounds almost like libcurl :P
18:11:59 <blackdog> JoeyA: in conclusion, we all hate you and don't do that :P
18:12:08 <JoeyA> lol
18:12:10 <kmc> yeah JoeyA ;)
18:12:14 <Cale> JoeyA: Perhaps I'll go over the implementation of the State monad. There's no magic there, but a bit of clever functional programming.
18:12:34 <kmc> JoeyA, also, some things can't be combined.  IO is a good example; most monads have some kind of "run" function (runST, runState, etc) which you apply and evaluate to get the result of an action
18:12:36 <Cale> JoeyA: You know about data declarations?
18:12:37 <kmc> but IO can't have that
18:13:03 <JoeyA> Cale> Yes.
18:13:08 * BMeph prefers "identify" to "contraint" or "disallow"...
18:13:10 <tensorpudding> The God Monad can only be created for brief moments at the extreme type fusion energies produced by the newly constructed Glasgow Haskell Collider.
18:13:13 <kmc> so if you combined IO with every other monad, you'd lose runST and all those useful things
18:13:18 <JoeyA> int **something_from_c[5];
18:13:19 <Cale> JoeyA: Okay, so  data State s a = S (s -> (s,a))
18:13:23 <kmc> @remember tensorpudding The God Monad can only be created for brief moments at the extreme type fusion energies produced by the newly constructed Glasgow Haskell Collider.
18:13:24 <lambdabot> It is stored.
18:13:29 <kmc> tensorpudding, beautiful
18:13:31 <JoeyA> or data :: Tree ... whatever
18:13:42 <Philonous> JoeyA: By carefully restriction what a certain piece of code can do and encoding that in the type system the compiler can give pretty strong guarantees about what can and can not happen. That is a great boon for debugging and for agressive code transformation/optimization
18:13:45 <kmc> tensorpudding, so that's what SPJ was talking about with the whole "fusion is critical for DPH" thing
18:13:56 <pikhq> *cough*unsafePerformIO*cough*
18:13:58 <Cale> JoeyA: I don't mean the type declarations which say what type a value has.
18:14:07 <Cale> JoeyA: I mean data declarations which define new datatypes.
18:14:12 <JoeyA> gotcha
18:14:31 <JoeyA> I think I understand.  In the sense I understand a language I can listen to but not speak :-)
18:15:06 <JoeyA> But for now, assume I do understand
18:15:07 <Cale> So this   data State s a = S (s -> (s,a))   says that for any types 's' and 'a', we have a type  State s a  which is going to be our representation of computations which manipulate a "state" of type s, before producing a "result" of type a
18:15:23 <JoeyA> ah
18:15:40 <Cale> and the way we're going to represent such a computation is simply as a function, from the initial state of type s, to a pair consisting of a final state of type s, and a result of type a
18:16:06 <Cale> and in order to turn such a function into a (State s a) value proper, we'll apply the data constructor S
18:16:25 <Cale> S :: (s -> (s,a)) -> (State s a)
18:17:14 <Cale> (our goal will be to eliminate the need to mention this data constructor S, by constructing a bunch of functions and combinators for building things up)
18:17:43 <Cale> But before that, we also want a way to run such a computation on an initial state of type s, and get a final state/result pair
18:17:51 <Cale> runState (S f) s = f s
18:18:42 <Cale> runState :: State s a -> s -> (s,a)
18:19:06 <Cale> Its implementation is so simple because of our carefully chosen representation ;)
18:19:15 <Cale> JoeyA: follow that so far?
18:19:23 <copumpkin> is there a good mnemonic for remembering the distinction between the various state running functions?
18:19:32 <copumpkin> it kind of bothers me how similarly named they are
18:19:49 <copumpkin> :t (execState, evalState, runState)
18:19:50 <lambdabot> forall s a s1 a1 s2 a2. (State s a -> s -> s, State s1 a1 -> s1 -> a1, State s2 a2 -> s2 -> (a2, s2))
18:19:50 <Cale> copumpkin: eval means get the result, exec means get the final state, run means get everything
18:20:09 <Cale> I don't know why they're named that way
18:20:21 <copumpkin> yeah, I was looking for some aid to actually remembering which is which
18:20:28 <byorgey> 'run' is the most general, corresponding to the 'run' of several other monads
18:20:38 <byorgey> 'exec' has an imperative flavor so it's concerned with the state
18:20:56 <byorgey> 'eval' gets the *val*ue of the computation
18:21:12 <copumpkin> :) that sounds decent
18:21:20 <BMeph> 'eval' has a data-ish "flavor" so it's concerned with the result! ;)
18:21:21 <Cale> JoeyA: Let me know when you've caught up :)
18:21:26 <JoeyA> Cale> Makes sense, I suppose
18:21:30 <Cale> JoeyA: okay :)
18:21:32 <JoeyA> I should try writing a loop that messes with the state
18:21:58 <Cale> JoeyA: So let's implement some basic primitives that we'll eventually combine together to make more complicated State computation
18:21:59 <Cale> s
18:22:01 <JoeyA> Is the a (result?) actually necessary, or is it just helpful?
18:22:19 <Cale> It's important to what it is that we're doing...
18:22:24 * BMeph imagines little robotic functions floating around, saying (in a robotic voice): "E-val-u-ate!"
18:22:38 <Cale> I mean, you could just work with functions of type  s -> s  but you would no longer have a monad
18:22:45 <JoeyA> Here's a simple task I'd like to try:  Use setBit on an integer to set a bunch of bits to 1.
18:23:05 <JoeyA> In purely functional code, doing this slows down later on, possibly because it keeps copying the Integer
18:23:13 <Cale> ?
18:23:15 <JoeyA> Will State be any better?  Or will ST be needed?
18:23:23 <kmc> State is just sugar
18:23:24 <Cale> It's hard to say.
18:23:26 <kmc> for passing the Integer around
18:23:31 <Cale> But State shouldn't be any better.
18:23:33 <kmc> it's probably already equivalent to what you wrote
18:23:37 <JoeyA> okay
18:23:43 <Cale> (or worse)
18:23:46 <kmc> the fact that it's just sugar means we can implement it in a few lines, which Cale is about to show you :)
18:23:50 <JoeyA> I should try it anyway for practice.
18:24:01 <kmc> ST is implemented with scary compiler guts, which is how it gives you *true* mutable memory cells
18:24:04 <JoeyA> If I wanted to move it to the ST monad, would I essentially s/State/ST/g ?
18:24:13 <kmc> JoeyA, no, they have different API as well
18:24:17 <kmc> in State you have a single value you manipulate
18:24:21 <kmc> in ST you allocate "STRef" cells
18:24:26 <kmc> or other things like STArrays etc
18:24:32 <kmc> and read and write them with ST monad actions
18:25:05 <JoeyA> @hoogle runState
18:25:06 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
18:25:06 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
18:25:06 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
18:25:17 <Cale> JoeyA: Besides, when you setBit, it's not copying the integer. It's constructing a new integer which is the result of OR-ing the integer in question with the new bit.
18:25:34 <kmc> but that's mostly a copy
18:25:35 * BMeph makes punks check themselves by using an STFUArray!
18:25:48 <kulin> harsh
18:25:50 <Cale> It's a different integer
18:26:58 <JoeyA> So if I want to manipulate state, then return it, would I say State Integer Integer ?
18:27:05 <kmc> yes
18:27:13 <Cale> It's not clear that it was obtained by copying and then modifying, or if it was obtained from whole cloth. There's no way you could ever tell.
18:27:15 <kmc> @unmtl State Integer Integer
18:27:15 <lambdabot> Integer -> (Integer, Integer)
18:27:18 <JoeyA> Or could I set the result to a nothing type?
18:27:22 <kmc> @unmtl State s a
18:27:22 <lambdabot> s -> (a, s)
18:27:37 <kmc> JoeyA, see how a state-transforming action is just a function that takes an old state, and returns a result and a new state
18:27:39 <kulin> is it usual to both manipulate a state and return it?
18:27:50 <Cale> JoeyA: You could do that as well, but if you always ignore the result of the computation, then the State monad is the wrong thing for what you're doing.
18:27:51 <kmc> kulin, the "get" primitive does so
18:28:04 <Cale> Let's look at get and put now
18:28:36 <JoeyA> Module not found:  import Control.Monad.State  (
18:28:39 <JoeyA> :( *
18:28:44 <kulin> i will need to look at ST myself, i usually just write stateless code (because I'm amazing)
18:28:53 <BMeph> kulin: If you manipulated a state but didn't return it, how would you know? ;)
18:28:54 <Cale> JoeyA: Ignore that, we're implementing our own State monad
18:28:54 <kulin> i actually just use STM as if it were state
18:28:56 <danharaj> Does State need to be a monad? Can its full semantics be captured by something simpler like applicative functors?
18:29:12 <Cale> danharaj: Nothing *needs* to be a monad...
18:29:25 <danharaj> Cale: You know what I mean :) Some things are more appropriately applicative.
18:29:50 <copumpkin> I don't really know what you mean
18:29:58 <kmc> danharaj, using the Applicative interface with State provides fewer capabilities than using the Monad interface
18:30:03 <Cale> danharaj: But I suppose if you only had the applicative interface and didn't have access to the data constructor you wouldn't be able to write all the computations you can with the Monad interface.
18:30:05 <danharaj> kmc: Thanks :p
18:30:07 <copumpkin> there exists a monad for the state type constructor
18:30:14 * BMeph has no flippin' clue what danharaj means...
18:30:35 <kmc> sometimes there is a nice story about the difference.  like for Parsec, Applicative is context-free, and Monad is context-sensitive
18:30:40 <Cale> JoeyA: anyway...
18:30:48 <JoeyA> now here:  S :: (s -> (s,a)) -> (State s a)
18:30:53 <JoeyA> S is capital.  Why isn't that a syntax error?
18:31:01 <JoeyA> Because it's a constructor?
18:31:02 <Cale> Because S is a data constructor
18:31:18 <JoeyA> How is it invoked?
18:31:35 <Cale> S (\s -> (s+1,s)) -- for example
18:31:44 <JoeyA> just like a regular function?
18:31:47 <Cale> yep
18:31:55 <Makoryu> :t Just -- JoeyA
18:31:56 <lambdabot> forall a. a -> Maybe a
18:31:57 <JoeyA> Why does it have to be capital?  Convention, or is it semantically different?
18:32:06 <Cale> JoeyA: We can pattern match against it
18:32:11 <copumpkin> that's what Haskell enforces
18:32:19 <Cale> runState (S f) s = f s
18:32:23 <kmc> JoeyA, if you don't how data types work, it's a bit premature to learn about monads
18:32:23 <Cale> ^^ here we did that
18:32:26 <JoeyA> ah
18:32:30 <BMeph> JoeyA: Both! Isn't Haskell fun? :)
18:32:43 <JoeyA> I know a little bit
18:32:46 <kmc> it's an enforced convention, and it's semantically different
18:32:53 <kmc> in that a constructor never "does" anything
18:32:59 <kmc> it just stores its arguments and can be pattern-matched later
18:33:00 <JoeyA> The problem is, you really can't get away with not learning monads, practically speaking
18:33:07 <JoeyA> Without monads, no mutable arrays
18:33:10 <Cale> JoeyA: Not really...
18:33:14 <Cale> JoeyA: You can just learn IO
18:33:16 <JoeyA> Meaning some algos can't be implemented quickly
18:33:27 <kmc> JoeyA, if you don't how data types work, it's a bit premature to use mutable arrays
18:33:34 <kulin> mutable arrays?
18:33:36 <JoeyA> You can manipulate mutable arrays in IO?
18:33:39 <Makoryu> JoeyA: http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
18:33:41 <Cale> yes
18:33:47 <Cale> IOArrays
18:33:49 <blackdog> JoeyA: for some array algorithms, you can implement them with lazy references to themselves
18:33:55 <kmc> JoeyA, IO can do everything ST can
18:34:07 <BMeph> kmc: That last sentence no verb again...
18:34:11 <kulin> what is the point of ST? in what was is passing a value around in ST different than just passing the value?
18:34:13 <JoeyA> What about STU?
18:34:14 <blackdog> it's only if you're going to use and update the same field multiple times that you run into trouble
18:34:16 <kmc> BMeph, yes, because i it from my client history
18:34:27 <Cale> There's IOUArrays correspondingly
18:34:28 <JoeyA> I guess it doesn't exist in that form
18:34:40 <JoeyA> Consider:  a <- newArray (2,n) True :: ST s (STUArray s Int Bool)
18:34:42 <Cale> STUArrays are the same thing for ST
18:35:00 <kmc> JoeyA, anyway, you're right that monads are important.  as a concept, they have a lot of prerequisites.  using IO only or ST only and not worrying about the "Monad" abstraction has somewhat fewer prerequisites
18:35:02 <BMeph> kmc: Ah, your client history likes to  things... ;)
18:35:07 <danharaj> kmc: Parsing context sensitive grammars has worse computational complexity than parsing context free. If I use parsec's applicative interface, do I get the better complexity guarantee?
18:35:09 <Cale> a <- newArray (2,n) True :: IO (IOUArray Int Bool)
18:35:15 <kmc> danharaj, i don't know
18:35:17 <kmc> good question
18:36:19 <JoeyA> So I suppose I should try to implement S :: (s -> (s,a)) -> (State s a) as an exercise
18:36:35 <copumpkin> I don't think so with parsec
18:36:36 <Cale> JoeyA: Well, that data declaration I gave defines S
18:36:38 <copumpkin> but with other libraries
18:36:56 <Cale> JoeyA: That type signature isn't meant to be code (and ghc will just complain about it if you give it)
18:37:14 <JoeyA> oh
18:37:18 <danharaj> copumpkin: What are some other parser combinator libraries? I know of attoparsec in addition.
18:37:20 <Cale> S is part of the definition of the State type constructor
18:37:56 <JoeyA> looks like it's equivalent to data State s a = S (s -> (s,a))
18:37:57 <JoeyA> Is it?
18:38:05 <Cale> That's what I wrote
18:38:10 <Cale> Isn't it?
18:39:01 <JoeyA> so S :: (s -> (s,a)) -> (State s a) is just hypothetical?
18:39:12 <Cale> Well, that's the actual type of S
18:39:28 <Cale> If you go into ghci and write :t S that will be the type it gives for the function S
18:39:58 <Cale> I suppose if we didn't mind using the new GADT syntax for types, we could write:
18:40:00 <JoeyA> Control.Monad.State doesn't exist
18:40:03 <Cale> data State s a where
18:40:09 <Cale>   S :: (s -> (s,a)) -> State s a
18:40:19 <JoeyA> :t State
18:40:20 <lambdabot> forall s a. (s -> (a, s)) -> State s a
18:40:30 <Cale> Yeah, the mtl is a little different
18:40:38 <Cale> (but not significantly)
18:41:47 <JoeyA> So after having this:  data State s a = S (s -> (s,a))
18:41:55 <JoeyA> would I need to implement bind and return?
18:41:59 <Cale> yes
18:42:05 <Cale> and we'll get to that :)
18:42:12 <JoeyA> and there's no need to actually write S :: (s -> (s,a)) -> (State s a)
18:42:14 <Cale> If you'd like we could do it first
18:42:16 <Cale> right
18:42:19 <JoeyA> (if the data State... is there?)
18:42:25 <Cale> yeah
18:42:38 <Cale> because the type of the S data constructor is specified there
18:43:11 <Cale> A data declaration has to the left of the = sign, the name of a new datatype being defined, along with a (possibly empty) list of type parameters
18:43:27 <Cale> and then to the right of the = sign, it has a |-separated list of data constructors
18:43:38 <Cale> each of which is followed by a list of the types of its parameters
18:43:45 <Cale> For example...
18:44:23 <Cale> data Employee = Boss String Integer | Peon String
18:44:59 <Cale> This will define one type (Employee), and two data constructors, Boss :: String -> Integer -> Employee, and  Peon :: String -> Employee
18:45:03 <kulin> i think it should be: data Employee = Boss String | Peon Integer String
18:45:18 <Cale> Depends on what the Integer means :)
18:45:33 <JoeyA> Would this be correct?  return :: (State m) => (s,a) -> m (s,a)
18:45:38 <kulin> it means you are no more than a number in the eyes of the corporate world
18:45:39 <Cale> no
18:45:40 <JoeyA> Or am I accidentally overriding the default return?
18:45:48 <Cale> :t return
18:45:49 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:45:56 <Cale> Here, our monad m = State s
18:46:01 * hackagebot epub-metadata 1.0.2 - Library and utility for parsing and manipulating  ePub metadata  http://hackage.haskell.org/package/epub-metadata-1.0.2 (DinoMorelli)
18:46:03 <Cale> So return :: a -> State s a
18:46:25 <Cale> :t (>>=)
18:46:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:46:32 <Cale> and this specialises to
18:46:46 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
18:46:52 <aavogt> almost like   lift for StateT
18:47:02 <Cale> whaaa?
18:47:16 <aavogt> Cale: JoeyA's original signature
18:47:19 <JoeyA> Is there one for State s a -> (s,a) ?
18:47:21 <Cale> oh, hmm
18:47:37 <Cale> JoeyA: We had runState :: State s a -> s -> (s,a)
18:47:43 <JoeyA> ah
18:47:58 <Cale> JoeyA: Of course, we'll need to pass in an initial state to be able to compute the final state and result
18:48:12 <JoeyA> right
18:48:27 <Cale> okay
18:49:01 <Cale> If you'd like, you can try implementing return.
18:49:07 <JoeyA> Will do
18:50:41 <JoeyA> Okay, now in data State s a = S (s -> (s,a))
18:50:47 <Cale> mhm?
18:50:49 <JoeyA> The only data being held here is a function, right?
18:50:53 <Cale> yeah
18:51:25 <JoeyA> and when we build up more actions, it chains these functions together?
18:51:28 <Cale> So, we're being real functional programmers here, and treating functions as data more than in many circumstances, which will probably be the main thing that makes this tricky
18:51:31 <Cale> yeah
18:52:02 <kmc> yes
18:52:26 <JoeyA> So return a needs to return a function that returns a, I suppose.  Where does the initial state come from?
18:52:36 <JoeyA> wow, weird sentence
18:52:40 <Cale> return :: a -> State s a
18:52:47 <Cale> So, if we start out...
18:52:50 <Cale> return v = ...
18:53:03 <Cale> v :: a here, and we're trying to write a value of type State s a
18:53:04 <BMeph> Data tells functions where to go. Functions tell data what to do.
18:53:21 <Cale> We don't have many ways to make a value of type State s a yet
18:53:26 <Cale> There's just the S data constructor
18:53:32 <Cale> so we might as well use it...
18:53:37 <Cale> return v = S (...)
18:53:48 <Cale> and S takes a parameter of type s -> (s,a)
18:53:52 <Cale> so, a function
18:53:57 <Cale> and it might as well be a lambda
18:54:06 <Cale> return v = S (\s -> ...)
18:54:21 <Cale> So now s :: s
18:54:29 <Cale> and we need to write something of type (s,a)
18:54:43 <JoeyA> return a = S (\s -> (s,a))
18:54:45 <JoeyA> Right?
18:55:02 <Cale> right
18:55:42 <Cale> So this is the computation which "does nothing" to the initial state, passing it through to the final state
18:55:44 <JoeyA> I ought to try doing this stuff in JavaScript later on :)
18:55:54 <Cale> and whose result is a (or v)
18:56:05 <lispy|web> foo :: forall a. a -> Int, means, given any 'a', it can produce an Int.  bar :: (forall a. a) -> Int, means?
18:56:33 <Cale> lispy|web: Given a polymorphic value which could have any type at all, it produces an Int
18:56:44 <Cale> lispy|web: So for example, not a String
18:56:59 <Cale> The only valid parameter would be undefined itself
18:57:06 <Cale> (and I suppose calls to error)
18:57:14 <JoeyA> runState (State s a) = ... -- correct?
18:57:25 <lispy|web> Cale: but, with type classes, it seems to behave differently?
18:57:28 <Cale> JoeyA: State s a is at the type level
18:57:40 <Cale> lispy|web: does it?
18:57:42 <lispy|web> Cale: baz :: (forall m. Monad m => m a) -> Int
18:57:54 <lispy|web> Cale: inside there, I could treat m as a specific monad
18:58:09 <Cale> lispy|web: That means, given something which could be a computation in any monad, produce an Int
18:58:34 <lispy|web> Oh, my example needs to be a function to be meaningful actually
18:58:49 <JoeyA> runState s (S f) = f s
18:58:57 <lispy|web> Cale: fwiw, I'm trying to understand the 'purify' function here: http://okmij.org/ftp/Computation/lem.html
18:59:06 <Cale> JoeyA: yeah, though the parameters are usually in the other order
18:59:15 <Cale> JoeyA: But that doesn't matter :)
18:59:17 <lispy|web> Cale: I mostly get why purify works, the inner return has type, a -> Identity a
18:59:24 <JoeyA> Now I have to figure out how to implement the Haskell logo :-)
18:59:50 <lispy|web> Cale: what I don't get is what happens when you move the forall out a level
18:59:57 <JoeyA> Cale> Oops, I see
19:00:20 <lispy|web> Cale: when you do that, it stops allowing m = Identity
19:00:27 <Cale> lispy|web: Basically, the forall inside the parameter means that the parameter *must* be polymorphic in that type
19:00:49 <Cale> JoeyA: So, this is more tricky, want me to take it step by step?
19:01:02 <JoeyA> Let me think first, please :-)
19:01:18 <Cale> It's actually possible to mess this up in an interesting way so that you get a monad where the state flows backwards in time
19:01:31 <JoeyA> lol
19:01:54 <JoeyA> .dab eb dluow tahT
19:02:08 <Cale> (our 'get' computation to be defined later will end up getting the result of the *following* 'put')
19:03:01 <JoeyA> Well, here's where I'm lacking:  I've never used the >>= operator before; I just use do blocks.
19:03:21 <JoeyA> So are all the lines of a do block simply >>=ed together?
19:03:58 <Cale> do v <- x; <stmts>   means   x >>= \v -> do <stmts>
19:04:26 <Cale> But follow the type more than anything
19:04:41 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
19:04:52 <JoeyA> So >>= just means add a job to the chain, right?
19:04:59 <Cale> sort of, yes
19:05:14 <Cale> Decide what to do next based on the result of the first part
19:06:07 <danharaj> Yeah, >>= pretty much means decide what comes next based on the previous 'action'
19:06:11 <Cale> brb, just need to put some dishes away
19:07:13 <kulin> Cale = putDishesAway >>= continueExplanation
19:07:13 <ezyang> Cale does dishes. Hero among humans.
19:07:21 <edwardk> preflex: xseen jbapple
19:07:29 <edwardk> hrmm no preflex
19:11:45 <edwardk> @tell jbapple http://erikdemaine.org/theses/dharmon.pdf has some neat results with regards to splitting, trees, and theoretical time bounds.
19:11:46 <lambdabot> Consider it noted.
19:11:49 <edwardk> nice timing
19:12:01 <Philippa> kulin: putDishesAway >> continueExplanation, I suspect :-p
19:12:27 <kulin> i expect his explanation to contain a small bit about how putting away the dishes went
19:12:50 <Cale> okay
19:12:59 <JoeyA> okay, I think I get the role of >>=
19:13:26 <JoeyA> It essentially means execute the monadic function on the left-hand side, and make its monad-free result available to the right-hand side as a function argument.
19:13:34 <Cale> yeah
19:13:40 <Cale> and then run the result of that function
19:13:55 <kmc> to be precise though, the thing on the left is not a function
19:13:59 <kmc> it's an action
19:14:05 <kmc> the thing on the right is a function returning an action
19:14:10 <Cale> That is, when x >>= f is run, you run x (whatever that means) getting some result v, and then run f v, returning its result.
19:14:16 <kmc> functions have arguments and have a (->) in their types
19:14:44 <lispy|web> Cale: what I get stuck on is why forall a b m. Monad m => ((a -> m b) -> m b) -> ((a -> b) -> b), is so different than forall a b. (forall m. Monad m => ((a -> m b) -> m b)) -> ((a -> b) -> b).  Different in terms of the polymorphism of m.
19:14:51 <Cale> Right, x is not a function (though in our specific case, there will be a function hidden away inside it)
19:15:24 <Cale> lispy|web: The first works for any monad m, the second requires a parameter which would work for any monad m
19:15:59 <Cale> (and might, as part of its definition, use that function with different monads)
19:17:13 <lispy|web> Cale: ah.  Okay.  So, I guess  foo :: a -> Int, would be foo :: forall a. (a -> Int), ?
19:18:12 <Cale> lispy|web: right
19:18:30 <Cale> lispy|web: Things are implicitly forall'd at the top of the signature if you leave the foralls out
19:18:49 <lispy|web> Cale: right.  I was more interested in the scoping of that forall.
19:19:09 <lispy|web> Cale: In particular, it's not, foo :: (forall a. a) -> (forall. Int)
19:19:29 <Cale> right
19:19:53 <Cale> It's more obvious with a function type that has interesting definitions.
19:20:04 <Cale> (maybe)
19:20:10 <Cale> Actually, obvious enough here...
19:20:19 <Cale> (forall a. a) -> Int, you could only pass undefined to
19:20:31 <Cale> a -> Int will take a String, or whatever you give it
19:20:55 <Cale> JoeyA: let me know whenever you'd like to continue
19:21:01 <JoeyA> okay
19:22:24 <lispy|web> Cale: in both cases, the function has ignore the first parameter, which is kind of interesting
19:23:08 <Cale> Well, I could write
19:23:22 <Cale> @let foo :: (forall a. a) -> Int; foo x = x + 1
19:23:22 <lambdabot>   TypeOperators is not enabled
19:23:29 <Cale> errr...
19:23:42 <Cale> I'm guessing rank-N types is off too
19:23:52 <kmc> moar extensions
19:23:53 <Cale> But you get the idea :)
19:24:15 <lispy|web> Cale: Hmm
19:24:42 <Cale> lispy|web: Note, it would be a stupid function, but it would meet the type signature
19:24:57 <Cale> lispy|web: Since that parameter is completely polymorphic, I can use it as an Int
19:25:10 <lispy|web> Cale: oh, I can define it but not use it without it diverging?
19:25:27 <Cale> yeah
19:25:46 <Cale> If it were more constrained it might be more interesting
19:25:53 <Cale> (forall a. Num a => a) -> Int
19:26:01 <Cale> might do any number of interesting things
19:27:48 <lispy|web> Cale: right, so (forall a. Num a => a) -> Int, seems to allow you to pick a specific instance of Num inside the body of the function
19:28:35 <Cale> right
19:28:39 <Cale> possibly more than one :)
19:29:17 <Cale> foo x = round (x / 2 :: Double) + x
19:30:15 <lispy|web> Cale: and it's this property that Oleg used in his purify example.  He used the identity monad to extract a value from the monad
19:30:49 <Cale> yeah
19:30:53 <Cale> brb
19:32:33 <juw> ?ADCC SEND "ff???f?.?.?.?.?.?.?.?.?.?.?.?..?" 0 0 0
19:32:34 <lambdabot> Unknown command, try @list
19:32:47 <lispy|web> Cale: and, I'm wondering if type classes do something to the intuitionistic logic
19:33:16 <Cale> Well, I suspect that they mostly act as additional parameters
19:34:17 <lispy|web> Cale: yeah, the m F that he uses to represent false, is more like m F {a}
19:34:29 <lispy|web> where the {a} is some inferred and hidden type
19:35:06 <Nereid> Totally not related to haskell, but does anyone know of a relatively simple proof of the equivalence of the two definitions of p-adic numbers?
19:35:32 <Nereid> (That is, the completion of Q wrt the p-adic norm, and the field of fractions of the inverse limit of Z/(p^n))
19:36:41 <lispy|web> Nereid: I bet people in #math know :)
19:36:45 <Nereid> heh
19:36:52 <Cale> hmm
19:37:06 <lispy|web> I don't think I've studied the p-adic stuff, but I more or less get your question
19:37:18 <JoeyA> Cale:  (>>=) (S f) g = S (\s -> (\(s2, a) -> runState (g a) s2) (f s))
19:38:31 <Cale> JoeyA: that looks good, though I would have written it like this:
19:39:02 <Cale> x >>= f = S (\s -> let (s',v) = runState x s in runState (f v) s')
19:40:40 <JoeyA> I'm trying to test this with the following stub function:
19:40:44 <JoeyA> ones :: Int -> Integer
19:40:44 <JoeyA> ones n = runState $ do
19:40:44 <JoeyA> 	ret <- return 0
19:40:44 <JoeyA> 	return ret
19:41:01 <JoeyA> However, I get "Ambiguous occurrence `return'"
19:41:32 <Cale> ah, we should make our definitions of return and >>= into an instance of the Monad class if you want to use do-notation
19:41:34 <JoeyA> Why can't it tell which return to use based on the context?  (I called the primary do block with runState)
19:41:40 <Cale> instance Monad (State a) where
19:41:48 <Cale>   ... put definitions of return and >>= inside here
19:42:00 <Cale> er, State s rather :)
19:42:10 <Cale> (not that it matters which letter we use)
19:42:20 <siracusa> Where is if' defined?
19:42:34 <Cale> siracusa: nowhere.  if' b t e = if b then t else e
19:44:01 <Cale> JoeyA: do-notation puts things in terms of the Prelude Monad class
19:44:26 <Cale> JoeyA: and return could either refer to the Prelude's return or the local definition if you don't say which
19:44:32 <siracusa> Cale: Why does lambdabot know it?
19:44:33 <JoeyA> http://codepad.org/2n4OlzZE
19:44:44 <Cale> siracusa: you mean the @pl plugin?
19:44:51 <siracusa> Yep
19:44:56 <Cale> siracusa: The @pl plugin doesn't even have a real Haskell parser
19:45:01 <JoeyA> I'm getting errors like:   Not in scope: type constructor or class `State'
19:45:08 <Cale> siracusa: It just uses its own Haskellish lambda calculus
19:45:30 <JoeyA> http://uncyclopedia.wikia.com/wiki/Compiler
19:45:32 <lispy|web> JoeyA: 	data State s a = S (s -> (s,a)), has to be at the top level
19:45:54 <lispy|web> JoeyA: the way it is now, the compiler thinks that data is local to the type class instance
19:46:04 <lispy|web> JoeyA: but, that's not allowed in haskell :)
19:46:19 <JoeyA> Misplaced type signature: runState :: State s a -> s -> (s, a)
19:46:21 * Cale always wonders what is so "inverse" about the "inverse limit". It's just a normal limit.
19:46:27 <JoeyA> I don't understand why that would belong on the outside.
19:46:50 <Cale> On the outside of what?
19:46:59 <Cale> That belongs at the top level of your module
19:47:11 <JoeyA> of the instance Monad (State s a) where block.
19:47:19 <Cale> The only things which go inside the instance declaration for Monad (State s) are the definitions of the monad operations
19:47:22 <Cale> which are return and >>=
19:47:40 <Cale> and it's not Monad (State s a), it's Monad (State s)
19:47:55 <Cale> State s is the monad we're defining, and State s a is the type of a specific computation in that monad.
19:50:09 <JoeyA> http://codepad.org/qQV2YLSL
19:50:16 <JoeyA> Do I need to import Control.Monad or something?
19:50:16 <Cale> Oh, I see, they just index the inverse limit incorrectly, and it makes it look like the order is flipped around.
19:50:19 <Cale> That's screwy
19:50:33 <Cale> JoeyA: I'll have a look
19:50:58 <Cale> oh, like the error says, you're not allowed to put type signatures inside an instance declaration for some stupid reason
19:51:20 <Cale> (so just leave them out, only put the definitions in)
19:51:54 <lispy|web> Cale: yeah, that's an extension I've thought about writing :)
19:53:03 <aavogt> the stupid reason that you aren't allowed duplicate type signatures?
19:55:49 <JoeyA> In the do block, how do I alter the State itself?
19:56:14 <Cale> aavogt: Despite the redundancy, it can be useful to people reading the code sometimes to have specialised type signatures in the instance.
19:56:34 <Cale> JoeyA: Good question. We haven't written those operations yet :)
19:57:21 <Cale> JoeyA: First of all, we need an operation  get  whose result will be the current state, and which won't change the state.
19:58:08 <Cale> and then we need a function  put  which will take a new state value s', and whatever the initial state was, it will ignore it and replace it with the given s'
19:58:21 <Cale> (and return the () as its result)
19:58:44 <Cale> You might like to think a bit about what their type signatures and implementations will be
19:59:23 <aavogt> Cale: you can just as easily write       method = let method_ :: x y z; method_ ...  in method_
20:00:08 <Cale> aavogt: You *could*, but it's ugly
20:01:01 <Philippa> aavogt: or method = ( ... ) :: x y z, for that matter
20:01:06 <Cale> In fact, I think you should also be able to write type signatures for arbitrary expressions and have the compiler check that they're valid and use them for inference.
20:01:19 <Philippa> er, can't you?
20:01:25 <Cale> No, it complains.
20:01:37 <aavogt> Philippa: parens should be unnecessary there
20:01:46 <Philippa> what're the limitations?
20:01:47 <Cale> Oh, I mean, at the top level
20:01:55 <Cale> Not just inside some other declaration
20:02:14 <aavogt>   method = \a b c -> ... :: x y z     vs    method a b c = ...
20:02:18 <Philippa> those aren't expressions, are they??
20:02:46 <aavogt> equations are nicer sometimes
20:02:48 <Cale> I mean, currently if you give a type declaration for any expression more complicated than a single identifier, it will complain
20:02:59 <Cale> at the top level
20:03:08 <Philippa> oh, right. Those aren't expressions, but ISWYM
20:03:14 <Cale> I'd like to be able to give type declarations for expression
20:03:16 <Cale> s*
20:03:38 <Cale> foo bar baz :: Quux
20:03:42 <Cale> and have that checked
20:03:52 <aavogt> if that's an expression, that works
20:04:03 <Cale> yes, but not as a declaration
20:04:27 <Cale> (while I see no particularly good reason that it ought not to work)
20:04:27 <Philippa> *reparses*
20:04:28 <aavogt> I see now.
20:04:47 <Cale> That is, a top level declaration of the type of a particular expression
20:05:04 <aavogt> you want to define a bunch of things at the bottom of your file:    __ = __ `const` (x y z :: ABC), with more equations or whatever
20:05:24 <aavogt> but some preprocessing done to make it a bit prettier
20:05:48 <Cale> yes, perhaps that would work as a preprocessor (though it would be nicer if the compiler didn't make that apparent)
20:06:06 <aavogt> TH
20:07:48 <JoeyA> Cale: get :: State s s; get = S (\s -> (s,s))
20:08:08 <Cale> JoeyA: right :)
20:09:09 <aavogt> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25460#a25460
20:10:00 <aavogt> and then a bit of CPP can hide the `typeAssert' function
20:10:22 <Cale> cute
20:11:31 <JoeyA> Cale:  set :: s -> State s (); set s' = S (\s -> (s', ()))
20:11:41 <Cale> JoeyA: right again :)
20:11:54 <JoeyA> I kind of got lucky there with the boring type part.
20:12:02 <JoeyA> ghc has a bug.  I was supposed to get 10 error messages.
20:12:25 <JoeyA> For pulling a stunt like that
20:12:27 <Cale> JoeyA: So with get, set (or put), return and (>>=), we can now forget about the S data constructor altogether and build computations up from those if we want
20:19:15 <aavogt> you can use the ghc-api from template haskell?
20:21:22 <Cale> JoeyA: So you can see in the end that there's no magic in the State s monad, and it's just a way of wrapping up an existing functional idiom of writing functions which have additional parameters and results in order to simulate a kind of "stateful" computation.
20:21:40 <JoeyA> Yes
20:21:41 <JoeyA> :t State
20:21:42 <lambdabot> forall s a. (s -> (a, s)) -> State s a
20:22:15 <Cale> JoeyA: But don't be misled that monads have something to do with state in general. I suppose some of them do, but many also don't.
20:22:23 <Cale> The list monad is a good example
20:22:31 <Cale> There, we have:
20:22:35 <Cale> return :: a -> [a]
20:22:37 <Cale> and
20:22:45 <Cale> (>>=) :: [a] -> (a -> [b]) -> [b]
20:23:27 <JoeyA> Cale: Yay, it works :-)  http://codepad.org/2m2Dvfnp
20:23:48 <Cale> yep :)
20:34:15 <JoeyA> Cale:  Now here's one thing I still don't understand.  Consider this:  http://codepad.org/PaqlwFs8
20:35:06 <JoeyA> Here, the state we're dealing with is treated like a variable inside the do construct:  a <- newArray (2,n) True :: ST s (STUArray s Int Bool)
20:35:49 <Cale> JoeyA: Yeah, ST has an altogether different implementation, and it is slightly magical
20:37:17 <c_wraith> ST is closely related to IO (the abstraction).  They were created and added to haskell at the same time.
20:37:20 <Cale> The ST monad lets you create new STArrays and STRefs and maintain references to them
20:37:28 <Cale> Hmm, really?
20:37:40 <Cale> I thought IO was somewhat older than ST
20:37:43 <JoeyA> a <- newArray (2,n) True :: ST s (STUArray s Int Bool)
20:37:43 <JoeyA> b <- newArray (2, fromIntegral n) True :: ST s (STUArray s Integer Bool)
20:37:52 <Cale> IO is defined in the standard while ST is not.
20:37:57 <JoeyA> ^ That works.
20:38:17 <c_wraith> Well, the paper outlining ST talks about how IO is just a special case of ST in GHC.
20:38:26 <Cale> Well, that's true
20:38:31 <c_wraith> IO may have been developed first, but they share implementation
20:38:32 <Cale> the implementation is unified in GHC
20:38:40 <Cale> though the implementation of IO in GHC is an awful hack ;)
20:38:48 <ddarius> @google lazy functional state threads
20:38:55 <c_wraith> yes, that's the name of the paper
20:39:01 <Cale> Well, I shouldn't badmouth it too much, it does seem to result in pretty fast code
20:39:03 <lambdabot> Plugin `search' failed with: thread killed
20:39:05 <c_wraith> except \bot seems to be dead
20:39:06 <JoeyA> Now, where is/are the monad(s) in the code above?
20:39:19 <JoeyA> Are two state chains created, one for a, and one for b ?
20:39:20 <Cale> (while the suggestion I have would probably not be as efficient)
20:39:30 <Cale> The monad is ST s
20:39:40 <ddarius> @google lazy functional state threads
20:39:53 <Cale> and no, ST s computations just describe a bunch of operations on a heap of memory
20:39:55 <lambdabot> Plugin `search' failed with: thread killed
20:40:29 <Cale> There's actually another way that we could have designed the State s monad which might have been easier to generalise to ST
20:41:20 <Cale> We could have instead made the operations: return, (>>=), get and put, into data constructors
20:41:31 <Cale> and put all the logic for running things into the runState function
20:41:40 <edwardk> hrmm: http://cg.scs.carleton.ca/~morin/teaching/5408/refs/minmax.pdf is kind of interesting. never seen that kind of heap before
20:41:41 <Cale> So we'd have a GADT like this:
20:41:46 <Cale> data State s a where
20:41:53 <Cale>   ReturnS :: a -> State s a
20:42:04 <Cale>   BindS :: State s a -> (a -> State s b) -> State s b
20:42:09 <Cale>   Get :: State s s
20:42:19 <Cale>   Put :: s -> State s ()
20:42:58 <kmc> ST isn't defined in the standard, and the type of runST is not a Haskell 98 type
20:43:02 <Cale> An action built up from these is nothing but a raw description of what might be done to some state of type s
20:43:14 <Cale> We would then write runState in terms of these like this:
20:43:17 <kmc> runST is probably the first argument to make for adding rank-2 types
20:43:29 <Cale> runState :: State s a -> s -> (s,a)
20:43:44 <Cale> runState (ReturnS v) s = (s,v)
20:43:51 <ddarius> edwardk: What's with this heap kick?
20:44:15 <Cale> runState (BindS x f) s = let (s',v) = runState x s in runState (f v) s'
20:44:24 <Cale> runState Get s = (s,s)
20:44:33 <Cale> runState (Put s') s = (s',())
20:45:00 <edwardk> ddarius: they seem to be the best users of the various redundant binary repreentations, and algorithmic tricks that i've been using to try to find a 'splittable fingertree' with jim apple.
20:45:12 <Cale> So, this runState turns our abstract description of what to do, built up as a bunch of data constructors, into an actual function
20:45:41 <Cale> and in exchange for making runState more complicated, we now get trivial definitions of the operations
20:45:45 <edwardk> ddarius: i want a structure that has both fast O(1)ish cons/snoc/view(l|r) and a split operation that can rip it in half with O(1)ish bounds, but i'm willing to pay a little more for append.
20:45:47 <Cale> return = ReturnS
20:45:52 <Cale> (>>=) = BindS
20:45:54 <Cale> get = Get
20:45:57 <Cale> put = Put
20:46:00 <Cale> done ;)
20:46:25 <edwardk> ddarius: it is a surprisingly difficult problem. If i was willing to settle for O(log n) split i could go with fingertrees
20:46:25 <Cale> From this perspective, it's easier to imagine how ST might be built.
20:46:35 <Cale> (and IO for that matter)
20:46:48 <edwardk> ddarius: but the general structure has some applications to work stealing
20:47:11 <Cale> JoeyA: Roughly following? I know I didn't really properly introduce the GADT syntax, but I'm hoping it's at least a bit self-explanatory
20:47:43 <JoeyA> Cale: I think so.
20:48:07 <Cale> okay, so let's not worry about arrays for the time being and just focus on ST with STRefs (arrays are similar)
20:48:08 <JoeyA> So in a line like this:  runState (Put s') s = (s',())
20:48:12 <Cale> oh, okay
20:48:21 <JoeyA> Is Put really a function in the expression tree?  Is Haskell really that cool?
20:48:30 <ddarius> You can represent mutable arrays as immutable arrays of STRefs.
20:48:38 <Cale> Put is a function, but it just serves to build a piece of data
20:48:39 <JoeyA> As in, being able to pattern match against expressions just about anywhere in the evaluation tree.
20:48:52 <Cale> and our runState is pattern matching on that abstract description of something to be done
20:49:05 <Cale> Well, that's what's magical about data constructors
20:49:10 <Cale> you can pattern match against them
20:49:21 <JoeyA> I can't do this:  let f (x*y) = x
20:49:24 <Cale> right
20:49:30 <JoeyA> Is there a pattern-match-like thing I could do instead?
20:49:32 <Cale> But only because * is not a data constructor
20:49:37 <JoeyA> oh
20:49:57 <Cale> If you had some datatype with a data constructor :*: then you could write  f (x :*: y) = x
20:50:14 <Cale> (: is the only "uppercase" symbol character)
20:51:55 <Cale> So if we were to fully evaluate (even under lambdas -- which normally doesn't happen), a do-block like  do x <- get; put (x+1); return x
20:52:46 <Cale> We would see  BindS Get (\x -> BindS (Put (x+1)) (\k -> ReturnS x))
20:53:29 <Cale> So this is sort of a higher-order abstract syntax for our state computations
20:53:56 <BMeph> edwardk: Sorry, I just caught up with the convo. So, Do Okasaki's deques not do it for you? :)
20:53:59 <Cale> and our runState is picking that abstract syntax apart and actually carrying out the described operations
20:54:18 <edwardk> BMeph: they can't split into balanced pieces in O(1)
20:55:21 <edwardk> BMeph: the general application domain is to try to replace 'conc' lists or 'blocked-ranges' with something that has a balance factor to it and has fast access to either ends so that you can quickly run the serial algorithm once you pass it out to each processor
20:55:31 <JoeyA> Interesting.  Well, thanks for all the help, Cale
20:55:40 <Cale> JoeyA: so anyway
20:55:46 <Cale> data ST s a where
20:55:56 <Cale>   ReturnST :: a -> ST s a
20:56:10 <Cale>   BindST :: ST s a -> (a -> ST s b) -> ST s b
20:56:31 <Cale>   newSTRef :: a -> ST s (STRef s a)
20:56:33 <Cale> er
20:56:35 <Cale>   NewSTRef :: a -> ST s (STRef s a)
20:56:52 <Cale>   ReadSTRef :: STRef s a -> ST s a
20:57:03 <Cale>   WriteSTRef :: STRef s a -> a -> ST s a
20:57:06 <Cale> oops
20:57:08 <Cale>   WriteSTRef :: STRef s a -> a -> ST s ()
20:57:25 <Cale> So now you have a representation of the abstract syntax of ST operations
20:58:08 <Cale> and you can imagine that a lower-level machine will actually carry them out for us, allocating memory on the heap for each NewSTRef, and reading and writing the appropriate points in memory for reads and writes.
20:58:24 <JoeyA> I guess STRefs are objects living inside the ST monad?
20:58:27 <JoeyA> E.g. individual arrays
20:58:39 <Cale> Well, STRefs are like mutable variables
20:58:56 <Cale> I could have added the array operations, but they're more complicated
20:59:15 <Cale> (and if I was doing a full implementation, I would)
20:59:39 <Cale> Of course, an STArray *might* be implemented as just a normal array of STRefs, but that's not so efficient
21:00:31 <JoeyA> What's the difference between an STArray and an STUArray
21:00:32 <JoeyA> ?
21:01:04 <Cale> Ah, for that you'll probably want to understand a little about how Haskell implements polymorphism
21:01:05 <BMeph> JoeyA: "U" stands for "unboxed". :)
21:01:08 <JoeyA> I guess unboxed is more efficient, but carries some caveats?
21:01:08 <Cale> Yeah
21:01:16 <Cale> Well, and laziness
21:02:13 <Cale> Normally, Haskell values are *not* just plain values in memory -- if they were, we would have 1) a difficult time representing unevaluated or partially-evaluated values
21:02:36 <Cale> and 2) we would need to compile infinitely many copies of every polymorphic function, for every possible type at which it could be used
21:03:14 <Cale> You might have noticed that things like  map :: (a -> b) -> [a] -> [b]  don't care at all what type of values are in the list, and work regardless of what size those values would be in memory
21:03:32 <Cale> and yet there is really only one piece of code for map :)
21:03:50 <ddarius> We could JIT code at run-time.
21:03:54 <aavogt> the compiler is free to generate specialized versions of polymorphic functions
21:04:32 <Cale> So what's going on is that we represent values as pointers to code. Code that will compute the real value (if it's not yet evaluated) and return it to the caller during a pattern match.
21:05:08 <Cale> (and which, before it does so, will rewrite that pointer to point at a shorter piece of code which just returns the already-computed value of the expression)
21:05:17 <Cale> This pointer indirection is usually known as a box
21:05:45 <Cale> It ensures that values have a uniform representation in memory, no matter what they are, and is tied into the implementation of laziness.
21:06:12 <Cale> Normal STArrays are arrays of mutable cells, each of which holds a boxed value
21:06:37 <Cale> So you can put unevaluated expressions into the cells of your STArray, and only evaluate them later when you get the values back out again
21:06:37 <JoeyA> Here, why can't I just say runST ?  http://codepad.org/c0ob00A3   Why does it have to be runSTUArray ?
21:07:04 <Cale> Oh, because your type signature says UArray Int Bool
21:07:37 <Cale> runSTUArray does some additional work to freeze the mutable STUArray into an immutable UArray
21:07:38 <JoeyA> :t runST
21:07:39 <lambdabot> forall a. (forall s. ST s a) -> a
21:08:03 <JoeyA> Oh
21:08:24 <Cale> If you want to return the array itself, it has to do that, because by design, the STUArray will not be accessible from any ST computation other than the one in which it was created.
21:08:45 <Cale> and runST's type ensures that you can't return mutable cells from your computation.
21:08:54 <Cale> (either arrays or STRefs)
21:09:09 <Cale> That's what the sneaky 's' type parameter is all about
21:20:57 <Cale> JoeyA: Oh, yeah, so what I was going to say is that STUArray, IOUArray, and UArray have a special representation for each element type, which packs the actual values of the elements into a single contiguous chunk of memory (rather than a bunch of pointers to them)
21:20:59 <Nereid> well I proved that they're isomorphic. (now to show that the topologies are the same...)
21:22:04 <Cale> Nereid: cool. While I'm not all that familiar with p-adics, that seems like the sensible way to go.
21:23:41 <wli> Gouvea has a fun book on that front.
21:24:16 <JoeyA> @src forM_
21:24:17 <lambdabot> forM_ = flip mapM_
21:24:22 <JoeyA> @src mapM_
21:24:22 <lambdabot> mapM_ f as = sequence_ (map f as)
21:24:30 <JoeyA> @src sequence_
21:24:30 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
21:27:11 <JoeyA> Is my `for` function correct here?  http://codepad.org/gAKaz54K
21:27:38 <JoeyA> It works in this context, but I'm not entirely sure it's right
21:28:04 <JoeyA> Namely, I wrote it from the perspective of doing something rather than planning to do something.
21:28:40 <c_wraith> @src Num
21:28:40 <lambdabot> class  (Eq a, Show a) => Num a  where
21:28:40 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:28:40 <lambdabot>     negate, abs, signum     :: a -> a
21:28:40 <lambdabot>     fromInteger             :: Integer -> a
21:28:49 <c_wraith> huh.  So num doesn't imply Ord.  Interesting.
21:28:56 <tensorpudding> That for function looks all right, I suppose
21:29:00 <JoeyA> c_wraith> Yeah, I noticed.
21:29:01 <tensorpudding> But you don't need Num there
21:29:06 <JoeyA> (earlier today)
21:29:19 <tensorpudding> You could get by with Ord
21:29:35 <tensorpudding> Or you could spring for Enum
21:29:39 <c_wraith> Seems redundant.
21:29:41 <Cale> JoeyA: it seems okay, except your end condition, you might want to make into a function. You could also write it as  for start end step = forM (takeWhile (<= end) . iterate step $ start)
21:29:47 <Cale> Or forM_
21:30:01 <tensorpudding> Yeah, forM_ pretty much makes a replacment for this simpler
21:30:03 <c_wraith> You could get by with just forM_ and a list of numbers to operate on
21:30:06 <JoeyA> I didn't do that because my for was slightly faster.
21:30:21 <Cale> Oh, that's surprising
21:30:29 <Cale> Are you compiling with optimisations?
21:30:33 <JoeyA> http://stackoverflow.com/questions/2815002/performance-of-looping-over-an-unboxed-array-in-haskell/2815935
21:30:35 <tensorpudding> You could use forM_ and a list comprehension, if you want a fancy step function
21:30:37 <JoeyA> Yes, -O2
21:30:59 <Cale> I wouldn't expect it to make all that big of a difference.
21:31:07 <tensorpudding> That way your stop condition could be (a -> Bool)
21:31:13 <Cale> There is technically a bit more allocation, I suppose.
21:33:09 <Cale> That might just indicate a failure of fusion though. hmm...
21:33:26 <JoeyA> "Cale> JoeyA: it seems okay, except your end condition, you might want to make into a function"  You mean to make it more generic, right?
21:33:31 <Cale> Yeah
21:33:37 <JoeyA> It would probably be just as fast anyway :-)
21:33:42 <Cale> Well, given that your step is a function
21:33:49 <applicative> JoeyA, it seems awfully fast, i changed it to do primes to 100000,  real	0m0.025s
21:34:04 <JoeyA> It is
21:34:23 <JoeyA> (Not my algorithm; based on a posting on the Haskell wiki)
21:34:35 <JoeyA> (which is based on something a Greek guy came up with ;-) )
21:34:44 <applicative> I see, its a little hard to penetrate
21:35:54 <JoeyA> But in my stackoverflow question, the performance is significantly worse for some reason if I use the embedded recursion rather than the outer for loop.
21:38:12 <Cale> hmm, it seems to be spending most of its time doing I/O in any case
21:40:45 <tensorpudding> Maybe try profiling?
21:41:42 <Cale> I can see the bit of performance degradation when switching to the nice abstract forM_ ...
21:41:48 <Cale> I wonder why that's happening...
21:42:30 <danharaj> Is there a monad for continuation passing style or something? I would like to get acquainted with the idea.
21:42:43 <kmc> yes
21:42:45 <kmc> Control.Monad.Cont
21:42:46 <tensorpudding> @hoogle Cont
21:42:47 <lambdabot> module Control.Monad.Cont
21:42:47 <lambdabot> Control.Monad.Cont newtype Cont r a
21:42:47 <lambdabot> Control.Monad.Cont Cont :: ((a -> r) -> r) -> Cont r a
21:42:51 <kmc> is basically sugar for a CPS transform
21:42:56 <tensorpudding> @hoogle ContT
21:42:56 <lambdabot> Control.Monad.Cont newtype ContT r m a
21:42:56 <lambdabot> Control.Monad.Cont ContT :: ((a -> m r) -> m r) -> ContT r m a
21:42:56 <lambdabot> Control.Monad.Cont mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a
21:43:02 <danharaj> CPS transform?
21:43:08 <kmc> continuation passing style transform
21:43:09 <kmc> you don't need monads to do explicit CPS
21:43:18 <danharaj> ah, hm.
21:43:28 <kmc> just turn a value of type T into a function of type  forall r.  (T -> r) -> r
21:43:38 <danharaj> ooh, I see.
21:43:43 <kmc> and apply that extra argument to whatever you were going to return
21:43:54 <kmc> Cont just uses return and (>>=) to do this in a systematic way
21:43:59 <kmc> and then provides the continuation to you via
21:44:00 <kmc> :t callCC
21:44:01 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
21:44:08 <danharaj> mm
21:44:10 <danharaj> Now, I hear that CPS transforms make haskell code faster? Is this true in general and if so, why?
21:44:18 <kmc> i have not heard that
21:44:25 <kmc> do you mean at the source level, or as something the compiler does?
21:44:32 <danharaj> at the source level
21:44:50 <danharaj> http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
21:44:55 <danharaj> That is what I'm getting it from.
21:45:15 <Cale> danharaj: Sometimes replacing what would be allocated data structures with functions can help the compiler do a better job of optimising the code.
21:45:52 <danharaj> Cale: So in a sense, making your code more functional makes it easier for the compiler to optimize.
21:46:00 <Cale> sometimes, yes
21:46:45 <danharaj> Now, what is call/cc?
21:47:05 <kmc> "call with current continuation"
21:47:18 <kmc> Cale, would you say that's a form of fusion?
21:47:36 <copumpkin> it's a way of "breaking out"
21:47:38 <Cale> kmc: Well, it's a form of doing what fusion should do, but by hand :)
21:47:41 <danharaj> kmc: Right... so what does that mean? What does arguments does it take, and what is the 'current continuation'?
21:47:42 <kmc> danharaj, you might want to learn this in the context of Scheme
21:47:49 <kmc> which has *actual* first-class continuations
21:47:52 <copumpkin> danderson: think of returning early from an imperative "function"
21:47:55 <danharaj> I'd rather not learn how to read parentheses.
21:47:58 <danharaj> :p
21:48:03 <kmc> danharaj, you should learn Scheme
21:48:06 <kmc> if you care at all about CS
21:48:26 <danharaj> kmc: I am a math person, I like CS from a mathy pov.
21:48:26 <Cale> danharaj: If you were to have a do-block, and you focused on any given action in it, the remainder of the do-block (as you should know), can be thought of as a function from the result of this computation to the remainder of the computation to be done
21:48:32 <kmc> in Haskell you write f x y z.  in Scheme you write (f x y z).  is that so bad?
21:48:52 <kmc> danharaj, let's ignore the monadic part for now and pretend continuations are ordinary functions
21:49:04 <kmc> (call/cc f) is equivalent to (f k), where k is a value called the "current continuation"
21:49:10 <danharaj> yes
21:49:11 <Cale> danharaj: So that function is the "current continuation". What callCC does is to essentially take a function, and pass it as an argument, that current continuation.
21:49:16 <kmc> which means that k looks like a function
21:49:27 <Cale> :t callCC
21:49:28 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
21:49:32 <kmc> but that if you call (k x), that call will never return; instead, the call (f k) = (call/cc f) returns with x
21:49:40 <kmc> no matter how many levels deep you were
21:49:51 <kmc> and (this is the really trippy part) even if f already returned, but you stashed k somewhere
21:49:57 <kmc> you can make it return again, by calling k
21:50:07 <danharaj> huh ok wat
21:50:09 <kmc> and whatever happened after the return happens again, with the new value you passed to k
21:50:14 <danharaj> Let me draw a diagram
21:50:18 <kmc> danharaj, there are writeups about this online, they may make more sense
21:50:22 <danharaj> pff
21:50:23 <kmc> you will have to learn Scheme for best effect
21:50:24 <danharaj> it's 1 am
21:50:26 <kmc> it's really not hard
21:50:28 <danharaj> I don't need no sense.
21:50:38 <JoeyA> In pattern matching, what does ! mean?
21:50:45 <Cale> So, the parameter to callCC is a function which, given a function (a -> m b) (the current continuation), gives us a computation of type m a to be performed
21:50:45 <JoeyA> such as in go !a !m !n !c
21:50:45 <copumpkin> an implicit seq
21:50:58 <copumpkin> JoeyA: think of ! as a whip cracking
21:51:00 <kmc> JoeyA, it will force evaluation of that expression (to weak head normal form) before continuing the match
21:51:04 <copumpkin> to show you how strict it is
21:51:05 <Cale> and callCC does the obvious, and passes that function the continuation which it has been bound to :)
21:51:24 <JoeyA> Isn't it already strict?
21:51:31 <kmc> how so?
21:51:32 <edwardk> hrmm a novel form of binary space partitioning tree i've never used before: http://pnylab.com/pny/papers/vptree/vptree/
21:51:42 <JoeyA> In order to pattern match
21:51:51 <Cale> JoeyA: If you pattern match against a data constructor, it'll evaluate the parameter just enough to match
21:51:58 <kmc> JoeyA, matching against a variable doesn't cause any evaluation
21:52:01 <kmc> because it always suceeds
21:52:03 <Cale> JoeyA: If your pattern is just a variable, it doesn't evaluate normally
21:52:04 <kmc> > case undefined of x -> ()
21:52:05 <lambdabot>   ()
21:52:08 <kmc> > case undefined of !x -> ()
21:52:09 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
21:52:12 <kmc> grr
21:52:13 <copumpkin> muahaha
21:52:14 <JoeyA> okay
21:52:30 <kmc> JoeyA, in some intermediate compiler languages (but not in Haskell), "case" always forces to whnf
21:52:36 <kmc> but in Haskell it only forces as much as the patterns require
21:52:48 <kmc> which for variables and wildcards is "none"
21:52:55 <danharaj> CPS seems very natural to me.
21:52:58 <kmc> a bang is useless on a constructor pattern
21:53:03 <kmc> i.e. !(Just _) is the same as (Just _)
21:53:11 <kmc> but (Just !x) is different from (Just x)
21:53:15 <Cale> danharaj: There was a nice video lecture on it that I'm trying to find
21:53:58 <Cale> actually it was a whole course on denotational and operational semantics of programming languages using a good bit of Haskell, along with some Prolog
21:54:01 <JoeyA> I guess that's because seq (and by extension !) does not recursively evaluate like deepSeq does?
21:54:52 <danharaj> Is there a compiler that implicitly does CPS transformation as an optimization?
21:54:55 <Cale> JoeyA: right
21:55:14 <Cale> danharaj: That happens for a lot of strict languages...
21:55:50 <BMeph> Chicken!
21:55:52 <danharaj> Cale: :p I am getting into this business of what's under the hood of languages.
21:55:55 <kmc> danharaj, it's not only an optimization, it makes things simpler
21:56:05 <kmc> danharaj, for example if you do a full CPS transform, you don't need a runtime call stack at all
21:56:11 <Cale> The Reduceron implementation of Haskell converts all data structures into lambdas
21:56:20 <Cale> (and case expressions into function application)
21:56:24 <ski> (CPS transformation is not an optimization in itself .. it may aid in doing other optimizations, though)
21:56:47 <kmc> Cale, does it use church encoding, or something more elaborate?
21:57:11 <Cale> Scott encoding perhaps?
21:57:21 <Cale> I forget
21:57:23 <ski> (kmc : well, you're effectively doing a stack on the heap in that case. but yes, no separate stack mechanism)
21:57:29 <danharaj> :t callCC
21:57:30 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
21:57:46 <danharaj> Why does that signature look awfully familiar.
21:58:16 <kmc> yeah
21:58:57 <kmc> the type of call/cc is the same as Pierce's Law in logic
21:59:04 <kmc> which is equivalent to excluded middle
21:59:15 <danharaj> That seems shady.
21:59:25 <kmc> i.e. classical logic, vs. constructive logic
21:59:31 <kmc> shady how?
21:59:56 <ski> danharaj : you possibly may recognize "Peirce's law", `((P -> Q) -> P) -> P)', from propostional logic
22:00:09 <danharaj> tmc:Because now we're in classical logic country and I was comy in intuitionist land
22:00:13 <danharaj> kmc*
22:00:21 <danharaj> comfy*
22:00:58 <kmc> so in fact you can write a term with excluded middle type, (Either a (a -> Void))
22:01:01 <kmc> using call/cc
22:01:04 <ski> (which is an example of a formula that is provable in classical propositional logic, but not in intuitonistic propositional logic (also, it only uses the implication connective, which could be seen as interesting))
22:01:06 <kmc> and it's a very cheeky sort of proof
22:01:45 <Pseudonym> ski: Well, you only need implication.
22:01:52 <Pseudonym> If you have True and False, anyway.
22:02:04 <ski> those are connectives as well :)
22:02:08 <Pseudonym> Sure.
22:02:10 <Cale> @djinn (((a -> b) -> a) -> a) -> (Either a (a -> Void))
22:02:10 <lambdabot> -- f cannot be realized.
22:02:31 <ski> Cale : you probably need `Rank2Types', there
22:02:31 <Cale> hmm
22:02:32 <Cale> oh
22:02:35 <Cale> right, yes
22:02:47 <danharaj> Hmm, I'm trying to phrase this question properly, taking a strongly normalizing typed lambda calculus and giving it call/cc, is it now turing complete?
22:02:54 <ski> (for stating a general premise)
22:02:58 <Cale> Which djinn conveniently has no notion of ;)
22:03:10 <kmc> danharaj, don't think so
22:03:12 <kmc> not sure
22:03:13 <Pseudonym> @djinn (((a -> b) -> a) -> a) -> ((a -> a) -> a)
22:03:13 <lambdabot> -- f cannot be realized.
22:03:18 <Cale> hmm, I would think "probably"
22:03:40 <Cale> call/cc is a pretty powerful control structure :)
22:03:44 <Pseudonym> Actually, that probably needs to be more polymorphic.
22:04:05 <ski> @djinn ((((Either a (Not a)) -> Void) -> (Either a (Not a))) -> (Either a (Not a))) -> (Either a (Not a))
22:04:05 <lambdabot> f a =
22:04:05 <lambdabot>     case a (\ b -> Right (\ c -> b (Left c))) of
22:04:05 <lambdabot>     Left d -> Left d
22:04:05 <lambdabot>     Right e -> Right e
22:04:17 <danharaj> Then again, call/cc is a sound operator, whereas say general recursion is not.
22:04:21 <ski> ^ or you could monomorphize
22:04:32 <Cale> hmm...
22:04:35 <Cale> that's a good point
22:04:37 <danharaj> It's just interesting to me that it corresponds to a classical proposition.
22:04:46 <kmc> the proof is quite cheeky
22:04:46 <Pseudonym> I've never heard anyone say "monomorphize" before.  I like it.
22:04:55 <Cale> okay, I believe that you can't do it then :)
22:05:07 <ski> can't do what ?
22:05:16 <Cale> Write fix in terms of call/cc
22:05:57 <danharaj> kmc: At some point I think you said something about existential and polymorphic types are related by cps transform. Can you elaborate on that?
22:05:58 <AnAdorableNick> Does GHC by default dynamically link with *any* external libraries?
22:06:34 <Cale> AnAdorableNick: gmp is the only really notable thing
22:06:37 <kmc> danharaj, yes.  (exists a. T a) is like (forall r. (T a -> r) -> r)
22:06:51 <AnAdorableNick> Cale: If it does, is it possible to force GHC to statically link *everything*?
22:06:52 <kmc> because the value contains (T a) for some specific unknown a
22:06:56 <AnAdorableNick> Cale: gmp?
22:07:00 <Pseudonym> And of course libc, libm etc.
22:07:03 <kmc> and so it's equivalent to accept a function which accepts (T a) for all a
22:07:12 <Cale> GNU Multi-Precision Math library
22:07:14 <kmc> and then give it the particular one you have
22:07:27 <ski> kmc : `forall r. (forall a. T a -> r) -> r'
22:07:32 <ski> danharaj : ^
22:07:34 <danharaj> So, "I have a T a for some type a" is the same thing as "I can give you a T a for any continuation"
22:07:35 <kmc> hmm yes
22:07:37 <kmc> what ski said
22:07:43 <Pseudonym> Some clever person has implemented Integer in terms of the Word types.
22:07:48 <kmc> this is like the logical theorems relating exists and forall
22:07:51 <ski> (danharaj : and if you instantiate `r' to `Void', there, you get `Not (forall a. Not (T a))')
22:07:52 <AnAdorableNick> Cale: Is it possible to orce GHC to link statically with *everything*?
22:08:05 <Pseudonym> Some far less clever person (i.e. me) has half-implemented Float and Double in terms of Integer.
22:08:05 <Cale> If there's a way, I don't know it.
22:08:24 <ski> danharaj : yes
22:09:32 * ski idly wonders why one would implement `Float' or `Double' in terms of `Integer'
22:09:35 <danharaj> I have to wonder if there are other ideas that can be expressed as types corresponding to modal operators.
22:09:43 <Pseudonym> ski: For bootstrapping new compilers.
22:10:09 <Pseudonym> Same reason why you might implement Integer in terms of Word types.
22:10:15 <ski> danharaj : staged computation can be expressed in terms of a modal operator, istr
22:10:27 <danharaj> which one is istr?
22:10:39 <ski> "istr" means "i seem to recall"
22:10:44 <BMeph> "I Seem To Recall" ;)
22:10:52 <danharaj> oh :p I thought- yeah it's late
22:11:03 <danharaj> Since there are a few hundred modal logics out there
22:11:10 <danharaj> it's hard to know if some have quirky names.
22:11:54 <BMeph> Pseudonym: But there's another, better reason for implementing Integer in terms of Word types - getting us a Natural type! >:)
22:11:55 <ski> danharaj : there's also the "of course" and "why not" operations in linear logic, which can be thought of as modal operators
22:12:15 <Cale> http://www.uni-koblenz.de/~laemmel/paradigms0910/ -- AHA!
22:12:37 <Cale> Took me forever to remember that it was Ralf Laemmel's course, and then Google finally gave it to me :)
22:12:48 <kmc> ski, really?
22:12:51 <kmc> how do they work
22:12:59 <danharaj> Maybe something is in necessity and possibility. Like "I can construct a" and "I might be able to construct a"
22:13:04 <danharaj> relating to nondeterminism.
22:13:05 <Cale> danharaj: There's a lecture there on Continuation Style which you might be interested in
22:13:11 <danharaj> cale:Thanks!
22:13:48 <ski> kmc : writing "of course" as `!' (and "why not" as `?'), a proof of `! A' is a proof of `A' that can be reused as many times as you like
22:14:19 <danharaj> Now just a point of clarification, call/cc f doesn't actually evaluate f right? It just binds it to the current continuation and you can come back and evaluate it later?
22:14:26 <ski> (`? A' is the "russian reversal" of this; the continuation will "reuse you as many times as it likes to")
22:14:26 <JoeyA> Why does this work:  f = runST (return 0)
22:14:30 <kmc> danharaj, with lazy eval, yes
22:14:31 <JoeyA> But this doesn't:  f = runST g where g = (return 0)
22:14:45 <Cale> danharaj: Well, it ought to be the next thing to evaluate in any case...
22:14:47 <kmc> JoeyA, because g is getting an overly restricted monomorphic type by default, i think
22:15:08 <ski> JoeyA : what if you add a type signature `g :: Num a => ST s a' ?
22:15:08 <kmc> danharaj, under lazy evaluation, (call/cc f) is like (f k) and that will sit as an unevaluated thunk
22:15:10 <Cale> Yeah, the problem is the monomorphism restriction
22:15:13 <kmc> with strict eval it'll go immediately
22:15:34 <Cale> JoeyA: If you turn the bloody thing off with {-# LANGUAGE NoMonomorphismRestriction #-}, your problem should go away
22:15:46 <Cale> (I really wish that had a shorthand name)
22:16:02 <Cale> {-# LANGUAGE NoMR #-} would be so much nicer
22:16:02 <ski> kmc : does Lazy Scheme really implement `call/cc' ?
22:16:14 <JoeyA> Thanks
22:16:30 <JoeyA> I was going to put a type signature in, I just couldn't figure out what it needed to be.
22:17:08 <ski> (JoeyA : you can remove the `Num a => ' bit and replace `a' with `Int' or `Integer' or `Double' or what-strikes-your-fancy, if you like)
22:17:25 <Cale> JoeyA: I once spent a full hour trying to work out why my ST program was not typechecking, and it turned out that it was because I had flippantly written  forM = flip mapM  (this was in the days before forM was in the library), and not given it an explicit type signature
22:17:47 <Pseudonym> (a ~ Int) =>
22:18:01 <danharaj> Can you transform code so it has no call/cc's in it anymore?
22:18:22 <Cale> So the monomorphism restriction applied and was causing it to have type  [a] -> (a -> ST () b) -> ST () b  for some stupid reason.
22:18:28 <Pseudonym> The thing about Double and Float is that they introduce a bunch of complication that if you're writing a new compiler you really don't want to deal with.
22:18:40 <Cale> and then the computation I used it in couldn't be runST'ed
22:18:52 <danharaj> We should represent reals as convergent sequences :p
22:18:53 <Cale> er
22:19:02 <danharaj> Put that laziness to use.
22:19:02 <Cale> [a] -> (a -> ST () b) -> ST () [b] of course
22:19:26 <Pseudonym> Isn't there still some allocation issue with GHC and Float?
22:19:32 <ski> danharaj : that's what the CPS transform does
22:19:41 <Cale> danharaj: Just convergent turns out not to be so useful. You usually need a particular bound on the speed of convergence.
22:19:48 <ski> (or rather, s/the/a/ .. there's several of them)
22:19:54 <danharaj> Cale: Right, modulus 2^-n, say
22:20:17 <Cale> danharaj: Interestingly, all computable functions are continuous :)
22:20:26 <ski> (Pseudonym : i see)
22:20:34 <Pseudonym> CReal implements reals as convergent sequences of linear fractional transformations.
22:20:36 <Pseudonym> IIRC
22:20:47 <Cale> Open sets are those sets for which membership is semidecidable.
22:20:52 <danharaj> Cale: You'll need to define what you mean, I can think of plenty of functions that are discontinuous and computable. Step function :p
22:21:01 <Cale> The step function isn't computable
22:21:12 <Cale> It won
22:21:19 <Cale> It won't terminate at 0
22:21:32 <danharaj> Oh I see, you don't let equality be computable.
22:21:47 <ski> equality of real numbers isn't decidable, no
22:21:47 <kmc> Cale, you're proposing some strange topology on the set of functions?
22:21:58 <Cale> Because you could have a sequence of points converging to 0 really quickly, but it doesn't matter, you can never tell that the limit is certainly 0
22:22:08 <BMeph> "All functions are continnuous!" ;)
22:22:13 <ski> kmc : just a topology on (computable) reals, i think
22:22:18 <kmc> oh
22:22:18 <Cale> kmc: It turns out to be the usual topology on R
22:22:25 <kmc> hmm really?
22:22:34 <Cale> (Well, on the computable subset of R)
22:22:37 <kmc> oh hmm
22:22:40 <kmc> i sort of see why
22:23:02 <danharaj> Well I would hope that the rationals with epsilon neighborhoods still form a basis for it
22:24:11 <danharaj> Ok, am getting very drowsy now. I'll be sleeping on this stuff. Thanks for the insight everyone. Happy Hasking :p
22:24:17 <ski> (Cale : btw, what about that Ralf Laemmel course link, before ?)
22:24:39 <Cale> ski: I was looking for it for danharaj to watch the lecture on continuation style semantics
22:24:49 <ski> ok
22:25:35 * ski wonders whether there is a word like "whether" and "whence" meaning roughly "what about"
22:26:46 <kmc> whizzle
22:26:52 <Cale> Sometimes 'whither' is used like that?
22:28:43 <Cale>   2. a. gen.  or fig. with various shades of meaning: To what result, condition, action, subject, cause, etc.? {dag}to  what extent, how far?
22:29:30 <Cale> Though that's somewhat archaic
22:29:43 <Cale> (and/or flowery)
22:36:31 <ski> Cale : ok, that could possibly do, then
22:36:40 <ski> (the archaicness doesn't bother me :)
22:37:25 <BMeph> ski: Verily, and forsooth? ;
22:38:15 * ski apologizes for causing such a kerfuffle
22:39:00 <JoeyA> What's wrong with the explicit typing on line 25?  http://codepad.org/5dIRa5w7
22:39:04 <SColes> you said kerfuffle...
22:39:10 <JoeyA> or maybe 23
22:40:09 <JoeyA> I figure the function f takes an Int and yields an action which returns ()
22:41:40 <ski> the problem is that `f :: Int -> ST s ()' is here interpreted as `f :: forall s. Int -> ST s ()', which is wrong
22:42:19 <JoeyA> Why isn't that the case on this line?  a <- newArray (2,n) True :: ST s (STUArray s Int Bool)
22:42:20 <ski> this is because `f' uses `a', an `STUArray s Int Bool' (note that this mentions `s' !)
22:42:50 <ski> (well, variables in type ascriptions behave somewhat funny)
22:43:21 <ski> anyway
22:43:36 <ski> either you need to remove the type signature on `f'
22:43:56 <ski> or you need to make `s' in scope in the outer `do_block' definition
22:44:17 <ski> so that the inner `f :: Int -> ST s ()' is then interpreted as referring to the same `s' as the outer one
22:44:44 <JoeyA> how do I do that?
22:45:01 <ski> you can do this either by writing `do_block :: forall s. ST s (UArray Int Bool)' (the `forall s. ' is important, here)
22:45:36 <ski> or by replacing `a <- newArray (2,n) True :: ST s (STUArray s Int Bool)' by `a :: STUArray s Int Bool <- newArray (2,n) True'
22:46:14 <ski> you'll also need to add `{-# LANGUAGE ScopedTypeVariables #-}' at the top of your module, to enable this extension to Haskell 98
22:50:29 <ski> hrm
22:51:13 <JoeyA> Works on codepad, doesn't in ghc
22:51:26 <ski> > let f (x :: a) = let g :: a -> a; g = (x +) in g . g in f 2 3
22:51:27 <lambdabot>   A pattern type signature cannot bind scoped type variables `a'
22:51:27 <lambdabot>    unless th...
22:52:24 <ski> > let f :: Num a => a -> a -> a; f (x :: a) = let g :: a -> a; g = (x +) in g . g in f 2 3
22:52:25 <lambdabot>   7
22:52:33 * ski never noticed this before
22:52:50 <JoeyA> Can't I do something like this?  f :: Int -> *
22:53:15 <JoeyA> as in, only coerce the arguments I want to coerce
22:56:08 <ski> JoeyA : ok, sorry, i goofed a little
22:56:36 <Cale> JoeyA: Philippa also has proposed such a feature, but it doesn't exist as of yet.
22:57:35 <ski> you should say `do_block :: forall s. ST s (STUArray s Int Bool)', (instead of having `UArray Int Bool'), in there
22:57:35 <ski> (for some reason i thought you were using `runST', and didn't look closely at that part of your code)
22:57:56 <ski> @type Data.Array.ST.runSTUArray
22:57:57 <lambdabot> forall i e. (Ix i) => (forall s. ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
22:58:51 <ski> (it would probably be somewhat more consistent to use `_' instead of `*' there .. or maybe using `..' would be better ?)
22:59:52 <ski> JoeyA : anyway, fixing that, i get your code to load
23:02:03 * ski wonders what's the rationale for not allowing pattern signatures to bind type variables unless you have "rigid type context" (which i interpret here as you having specified a polymorphic type signature)
23:03:43 <JoeyA> If I ever design a programming language, I plan to make orthogonality a high priority.  That is, given a syntax, just about anything expressible in that syntax would be allowed.  Strict typing is simply not compatible with this notion.
23:04:10 <kmc> uh, why is that a good property?
23:04:16 <kmc> and that's not what is usually meant by "orthogonality"
23:05:09 <JoeyA> kmc: Makes a better power/complexity ratio.
23:05:09 <kmc> i have a small patch to GHC which achieves this goal.  if your program has a type error, instead of refusing to compile, it will ignore your source code and produce a binary which writes out ASCII goatse
23:05:57 <kmc> right
23:06:25 <kmc> you have lots of power and no idea if you're using it how you meant
23:07:02 <flux> actually it'd be interesting to see a version that instead of refusing to compile would replace the offenting expresion with undefined
23:07:18 <JoeyA> But the syntax and semantics are simpler, so there's less to think about and understand.
23:07:20 <flux> and offending expressions as well..
23:07:24 <kmc> yeah
23:07:34 <Jafet> I suspect JoeyA has never used perl.
23:07:36 <kmc> dynamically typed languages are simple to think about and understand
23:07:46 <blackdog> flux: you don't know which bit's wrong, though
23:07:47 <kmc> that's great for tiny programs
23:07:51 <blackdog> just that there's a conflict
23:07:53 <ski> flux : and *warn* about it every time ..
23:07:56 <Jafet> But perhaps he would like Jot.
23:07:59 <flux> ski, obviously
23:08:11 <kmc> but the combinatorial explosion of code paths means that no matter how simple a language is, any moderately big program will be too big to understand all at once
23:08:16 <flux> blackdog, well, it could also use an error primitive which would indicate the location
23:08:18 <rajeshsr> what is the best way to have a 2 dimensional mutable array?
23:08:22 <abens> JoeyA: abstraction
23:08:28 <Jafet> flux, make undefined a monad!
23:08:35 <kmc> though i think perl is not the ideal JoeyA is looking for
23:08:39 <kmc> because it has very many semantic rules
23:08:47 <kmc> in order to second-guess the programmer's intent
23:08:59 <blackdog> kmc: like regexes in haskell? :)
23:09:00 <ski> rajeshsr : maybe `STArray s (Int,Int) Foo' ?
23:09:14 <kmc> yes exactly blackdog
23:09:19 <kmc> don't get me started about that library ;P
23:09:46 <blackdog> hey, maybe you _did_ mean to run that regex in the ST monad. Why not?
23:10:59 <Jafet> Haskell should have recursive regexes like perl...! oh wait, that's parsec
23:11:14 <rajeshsr> ski, hmm, my requirement is to improve my sudoku with heuristics. I will store a bitarray(an Int) of values in that 2 dimensional array to keep track of possible values in the square which will change in the course of program.
23:11:19 <rajeshsr> is it that what i want?
23:11:44 <rajeshsr> Jafet, do you like Perl?
23:12:13 <Jafet> It's incredibly useful as a tool for refuting other people
23:13:50 <rajeshsr> refuting for what? That Perl supports almost all they need?
23:13:55 <kmc> it's funny when people try to dismiss static types as "restrictive"
23:14:02 <kmc> of course they are, that's the bloody point
23:14:06 <ski> rajeshsr : sounds like it would work
23:14:08 <blackdog> kmc: it does make reflective code hard
23:14:13 <kmc> they restrict you from writing some incorrect programs
23:14:38 <Jafet> Haskell probably has the least restrictive static type system, actually--
23:14:43 <c_wraith> they also make it hard to write some correct but really confusing programs!
23:15:02 <ski> (often the complaints are more about "overly restrictive", though)
23:15:11 <kmc> if you want the computer to follow every bad suggestion you give, static typing is not for you
23:15:17 * c_wraith considers some ruby code he's written that takes arguments of like 10 different types interchangeably, in the most confusing manner possible
23:15:30 <blackdog> kmc: be fair: you can't write the y combinator. that's reasonably major, surely?
23:15:32 <rajeshsr> kmc, a lot of incorrect programs in fact! No one really knows if a particular data passed to a function is of right type. For example, a function taking up a list in python, is easily given a single value, assuming that it is singleton, and it will break only when we run!
23:15:36 <kmc> i think we all went through a stage of wanting to be the omnipotent god of the machine but really, it's not a good way to get work done
23:15:44 <ski> (sometimes couples with "i want lists and tuples to be the same thing, so what if i use list with three elements of wildly different types ?")
23:15:47 <Jafet> blackdog, that is easily fixed!
23:15:48 <kmc> blackdog, yes, it also restricts you from writing some correct programs
23:15:52 <kmc> not disagreeing there
23:16:02 <kmc> just pointing out that restriction is the whole point
23:16:10 * blackdog groans at Jafet's horrible puns
23:16:17 <kmc> hehe
23:16:18 <kmc> i get it now
23:16:40 <c_wraith> wow, I totally missed the pun, despite knowing to what Jafet was alluding.  >_>
23:16:42 * c_wraith is blind
23:16:45 <c_wraith> or drunk
23:16:46 <Jafet> @quote jafet python way
23:16:46 <lambdabot> No quotes match. Where did you learn to type?
23:16:48 <rajeshsr> Jafet, isn't C more liberal as a statically typed language?
23:17:57 <rajeshsr> what it means by boxed an unboxed arrays?
23:18:02 <Jafet> rajeshsr, does that make Haskell Democrat?
23:18:04 <ski> (C is "weakly typed")
23:18:09 <Jafet> Er, Republican
23:18:13 <kmc> or "not safely typed"
23:18:19 <kmc> or "not strongly typed"
23:18:21 <blackdog> weakly static, yes?
23:18:23 <c_wraith> C's types are just instructions to the compiler for how to treat values.  They don't enforce much of anything.
23:18:27 <kmc> whereas Python is strongly typed, but not statically typed
23:18:43 <kmc> yes, C uses types primarily to specify representation, not semantics and correctness
23:18:44 <mornfall> And C++ is strongly and statically typed. And Java is not. Sucks. :)
23:18:46 <rajeshsr> kmc, "not strongly typed " describes it better than weakly typed.
23:18:51 <kmc> this has corrupted many a programmer's thinking about types
23:19:11 <kmc> as does the fact that C, C++, Java use manifest typing -- so statically-typed languages must be verbose and clunky
23:19:16 <blackdog> mornfall: you think? you can still fool the compiler, it's hard to say C++ is really static
23:19:18 <rajeshsr> well, what makes a language weakly typed?
23:19:34 <mornfall> blackdog: Oh, you have unsafeCoerce# in Haskell, too.
23:19:36 <kmc> rajeshsr, the type system is not sufficient to prevent you from writing totally unsafe programs with crazy nondeterministic behavior
23:19:39 <rajeshsr> i guess all languages are not strongly typed, than call it a weakly typed..
23:19:47 <blackdog> mornfall: true, but you don't use it much outside FFI
23:19:51 <JoeyA> I'm gonna lay down my strict aliasing rules... down by the riverside (ba-bum-bump) down by the riverside... (ba-bum-bump) down by the riverside...
23:20:04 <kmc> in C a tiny mistake can cause you to essentially branch to a randomly-chosen address
23:20:13 <mornfall> blackdog: Well, you don't use C-style casting much in C++ either (well, not at all if you know better).
23:20:14 <kmc> in Haskell or Java you really have to go out of your way to get a program which does this
23:20:19 <c_wraith> rajeshsr: it has to do with data representation in GHC.  boxed types contain either a pointer to the computer value, or to the thunk to compute the value.  unboxed types contain the value itself.  this means that the value must be calculated fully before being stored in an unboxed array.
23:20:19 <rajeshsr> kmc, hmm, then why not python? when C is?! :)
23:20:23 <kmc> what?
23:20:48 <c_wraith> *computed* value
23:20:55 <kmc> in Java or Python most mistakes about types will result in a runtime exception
23:21:05 <kmc> in C most mistakes about types will result in undefined, often crazy behavior
23:21:20 <rajeshsr> hmm, the definition is too fuzzy!
23:21:28 <kmc> the ones that get past the type checker, which are significant
23:21:43 <mornfall> kmc: Well, runtime exception is only slightly better than crazy behaviour.
23:21:47 <kmc> especially because C programs make liberal use of unsafe casts
23:21:56 <kmc> mornfall, i think it's a lot better, but static checking is a lot better still
23:22:06 <rajeshsr> double to int implicit conversion possible in C, while not in Java or python..
23:22:06 <Jafet> kmc, in C most mistakes about types will compile and work until you have to port the program to a different architecture
23:22:19 <rajeshsr> is that what you mean?
23:22:22 <kmc> rajeshsr, no
23:22:28 <kmc> implicit conversions are a whole different axis
23:22:33 <mornfall> (of evil)
23:22:45 <kmc> you can have them in a strongly or weakly typed language, statically or dynamically typed language
23:22:47 <abens> kmc: But the size of the set of incorrect solutions that type-check becomes enormous as problems become more involved. Take numerical algorithms: solutions will all type-check trivially. Your algorithm tells you whether it is a good solution, not the type system. That means there's an infinite number of ways you can mess up the algorithm. And therefore, the type system isn't very useful in that case, *for the purpuse of avoiding
23:22:48 <abens> mistakes*.
23:22:50 <Jafet> Let's all rage against the machine.
23:22:59 <kmc> yeah abens
23:23:11 <kmc> a Haskell-like type system is much more useful for symbolic code than numeric code
23:23:12 <rajeshsr> c_wraith, interesting! thanks.
23:23:25 <Jafet> abens, that depends on what a "type system" is. Proof theory languages let you express any semantics using types
23:23:26 <abens> It might still be nice for notation though.
23:23:27 <JoeyA> Jafet: That's kind of what I've been doing the last 2 hours.
23:23:44 <JoeyA> (raging against the machine)
23:23:48 <rajeshsr> kmc, can you give a specific instance to prove C is not strongly typed while python and Java are?
23:24:02 <Jafet> JoeyA, nah fuck it, turn it off.
23:24:04 <kmc> rajeshsr, sure.  in C you can cast between pointers to two different structs with different layout
23:24:13 <rajeshsr> kmc, yep
23:24:14 <kmc> and then if you look at a field of that struct, you get garbage data
23:24:23 <kmc> and if you call a function pointer in that struct, you get unknown program behavior
23:24:34 <kmc> if you return a pointer to a local variable, you get garbage data
23:24:48 <kmc> if you keep a pointer to heap after calling free(), you get garbage data
23:24:57 <c_wraith> should I buy okasaki's book?  It has haskell examples, where his thesis didn't, right?
23:24:59 <rajeshsr> hmm! :)
23:25:05 <arw> you are mixing types and memory management.
23:25:06 <kmc> this is a whole class of issues unknown to Python, Java, and Haskell, outside of each language's C interface layer
23:25:09 <JoeyA> Of course, you can also do this:  float a = ..., b = ...; int percent = a * 100 / b; /* How horrible!!! */
23:25:26 <dolio> c_wraith: The actual meat of the book uses ML with laziness annotations.
23:25:26 <kmc> arw, true
23:25:39 <dolio> But there are Haskell translations in an appendix.
23:25:40 <c_wraith> dolio: so actually the same as his thesis, then?
23:25:57 <kmc> arw, though you can say that this is part of what a reference type in Java means, that's not part of what a pointer type in C means
23:26:18 <c_wraith> Does he address how Haskell doesn't have quite the same laziness semantics he was positing in his thesis?
23:26:20 <kmc> each reference in Java is either "null" or a well-formed object
23:26:21 <dolio> I haven't read his thesis.
23:26:43 <c_wraith> oh.  it basically posited automatic memoization
23:27:01 <arw> kmc: in java there is still a null, which also gives you some unitialized object. you just get an exception before you do anything nasty with it.
23:27:06 <kmc> right
23:27:17 <kmc> which is fundamentally different from doing the wrong thing and not knowing it
23:27:28 <dolio> Well, most Haskell implementations memoize shared values, even though it isn't mandated.
23:27:36 <kmc> for an essentially infinite universe of possible wrong things
23:27:36 <rajeshsr> kmc, if a language allows a not so sensible conversions then it can be regarded as a "not strongly typed". I guess this definition makes some clarity.
23:27:44 <dolio> I think that's all he requires in his book.
23:27:46 <kmc> rajeshsr, conversion is a different beast from cast
23:27:55 <kmc> cast means "believe me that these are already the same type"
23:28:08 <c_wraith> dolio: hmm.  I thought he wanted greater memoization, but I didn't look carefully at his argument for using it.  Perhaps that is sufficient
23:28:09 <rajeshsr> kmc, ok, casting!
23:28:10 <kmc> conversion means "make a value of this new type, which is in some sense like the value of the other type"
23:28:16 <kmc> C uses the same syntax for both, confusingly
23:28:37 <kmc> the two definitions sort of coincide for pointer types
23:28:39 <rajeshsr> kmc, ha, thats a nice distinction!
23:28:43 <blackdog> kmc: that's right, integer promotion etc
23:28:44 <rajeshsr> yep!
23:28:53 <mornfall> kmc: Actually, I call the former a coercion and the latter a cast. Dunno why though. :)
23:29:07 <kmc> but for example, pretending an 8-byte integer is an 8-byte double is very different from computing a new double with 0 fractional part
23:29:07 <blackdog> there was a realliy weird example i saw the other day... something about char c = 127, and c++ used later
23:29:13 <c_wraith> dolio: certainly, that does fit with the laziness annotation semantics he added to his ml examples, so maybe I just misinterpreted it
23:29:17 <kmc> blackdog, signedness of char?
23:30:00 <blackdog> kmc: i think it got promoted to an int in one context, and not in another, so you get overflow in one
23:30:05 <kmc> ok
23:30:17 <arw> signed overflow is undefined behaviour in c.
23:30:29 <arw> so its even worse...
23:30:33 <kmc> mornfall, yeah, the terminology is not perfectly consistent.  i like "coercion" as well.  haskell usage uses "cast" to mean the "assume they're the same" one
23:30:36 <kmc> :t cast
23:30:38 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
23:30:39 <blackdog> as much as it annoys me to have to lard my programs with fromIntegral, it's better than having to hunt down that kind of horrible bug
23:30:41 <kmc> but also uses "coerce"
23:30:46 <kmc> for the unchecked version
23:31:00 <c_wraith> :t unsafeCoerce
23:31:01 <lambdabot> Not in scope: `unsafeCoerce'
23:31:06 <c_wraith> :t Unsafe.Coerce.unsafeCoerce
23:31:07 <lambdabot> forall a b. a -> b
23:31:21 <c_wraith> such a great type signature :)
23:31:24 <kmc> nothing is true, everything is permitted
23:31:54 <kmc> anything implies everything
23:32:05 <dolio> c_wraith: I'd find it odd if he wanted more than what Haskell provides. Perhaps he was just noting that you can't merely simulate $(foo) as \() -> foo, because that may recompute foo arbitrarily many times?
23:32:35 <dolio> Or, more than what a typical Haskell implementation provides, that is.
23:32:42 <c_wraith> dolio: I think I just misread his statement about not re-evaluating the same expression
23:33:53 <Jafet> Idea: implicit conversions for haskell
23:34:44 <dolio> What I mentioned would be a species of that. In fact, that's part of why you can't adequately simulate lazy evaluation in a pure, strict language.
23:34:47 <blackdog> kmc: I _am_ interested in staged computation in haskell, though. it's one of those things that's basically trivial in Lisp, and always seems painful in haskell
23:35:20 <dolio> Because \() -> foo only simulates call-by-name unless you can do tricks with mutable references.
23:35:41 <c_wraith> that's true
23:39:03 <ski> (blackdog : you've taken a look at MetaML / MetaOCaml, yes ?)
23:42:33 <rajeshsr> any link about how to use STArray. I don't seem to be following it from the doc..
23:42:45 <rajeshsr> @hoogle STArray
23:42:45 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
23:42:45 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
23:42:45 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
23:43:04 <dolio> What part are you having trouble with?
23:43:14 <kmc> rajeshsr, you use it thru http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/array/Data-Array-MArray.html
23:45:28 <sohum> @oeis 0.25,0.25,0.1875
23:45:28 <lambdabot>  Sequence not found.
23:45:46 <luite> integer sequences?
23:45:57 <sohum> is it only integer sequences?
23:46:04 <dolio> That's what the i is for.
23:46:10 <sohum> ....duh, right
23:47:02 <Jafet> It would probably get too uncountable for them to deal with R
23:47:20 <sohum> I'm only asking for Q :P
23:48:17 <dolio> @oeis 1 1 1
23:48:18 <lambdabot>  Pascal's triangle read by rows: C(n,k) = binomial(n,k) = n!/(k!*(n-k)!), 0<=...
23:48:18 <lambdabot>  [1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,1,5,10,10,5,1,1,6,15,20,15,6,1,1,7,21,35,35,2...
23:48:26 <dolio> @oeis 1 1 1 1 1 1
23:48:27 <lambdabot>  The simplest sequence of positive numbers: the all 1's sequence.
23:48:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:48:48 <sohum> (0,1,2,3...)·(1/2,1/4,1/8,1/16), basically
23:48:58 <c_wraith> why is that simpler than all zeroes?
23:49:05 <dolio> Zero isn't positive.
23:49:05 <c_wraith> oh, *positive*
23:49:14 * c_wraith reminds the crowd of the alcohol
23:49:23 <Jafet> Sleeping early helps with the hangover.
23:49:44 <c_wraith> I don't have hangovers
23:49:49 <c_wraith> I have alcohol poisoning!
23:50:09 <c_wraith> (I'm short of that tonight, and quite off-topic, so I'll be ceasing conversation on the topic)
23:51:33 <dolio> If you're not getting hangovers, your drinks obviously don't contain enough lime juice.
23:51:46 <dolio> And gin.
23:52:33 <abens> Jafet, mind if I reheat the prove-this!-ye-types topic?
