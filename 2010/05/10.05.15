00:00:39 <copumpkin> shhh
00:01:14 <copumpkin> Be vewy vewy quiet! I'm hunting wabbits
00:06:20 <glguy>     Warning: A do-notation statement discarded a result of type GHC.Prim.Any.
00:06:25 <glguy> <_<
00:06:46 <copumpkin> wow, I've never seen that before
00:07:02 <copumpkin> oh, I misread it
00:07:16 <dmwit> Yep, that's a new warning in .12.
00:07:18 <copumpkin> what do you have that's returning Any?
00:07:22 <glguy> forever
00:07:25 <tensorpudding> The *.12 warnings are numerous.
00:07:27 <copumpkin> ah
00:07:41 <tensorpudding> But that's what -Wall is for, right?
00:07:54 <glguy> -Wall is different than -Wridiculous
00:08:35 <pkrumins> -Wmidgets
00:08:37 <tensorpudding> Maybe warnings regarded discarded values from do-blocks that nonetheless typecheck should be something returned by HLint instead of -Wall.
00:08:46 <glguy> Any should fall into the same category as ()
00:08:50 <tensorpudding> Maybe.
00:08:58 <copumpkin> Any is magic though
00:09:02 <copumpkin> it could be anything!
00:09:14 <tensorpudding> Personally I think that having too many warnings is better than too few.
00:09:23 <copumpkin> what if you get desensitized?
00:09:32 <glguy> I think that it is bad because it encourages people to disregard them or turn them off altogether
00:09:37 <glguy> and out goes the baby
00:09:51 * copumpkin likes bathwater
00:10:12 <tensorpudding> -Wall already does lots of obnoxious things, like giving you warnings every time it defaults a type.
00:15:46 * glguy switches to forever m >>= putMVar done
00:16:21 * glguy hopes that the deadlock detection doesn't get smarter
00:20:44 <dmwit> glguy: You could also use do { _ <- forever m }, the preferred way to mark that you aren't using the result.
00:20:59 * glguy refuses to mark that he isn't using a result he doesn't have
00:21:02 <dmwit> forever m >>= putMVar done -- <- this would freak me out if I saw it
00:21:13 <dmwit> You could also write forever_. ;-)
00:21:31 <copumpkin> why does forever have the type it has?
00:21:46 <copumpkin> it would be easier if it were returning m ()
00:21:46 <dmwit> So it can go in branches of a case statement.
00:21:52 <copumpkin> hm
00:22:04 <Ytinasni> same reason error returns an 'a'
00:22:10 <copumpkin> fair enough
00:22:35 <copumpkin> we just like most general types
00:22:38 <dmwit> I can't say I've ever seen it used that way, but...
00:22:39 <dmwit> yeah =)
00:22:48 <glguy> :t forkIO
00:22:49 <lambdabot> Not in scope: `forkIO'
00:23:01 <glguy> ?hoogle forkIO
00:23:02 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
00:23:07 * glguy glares at the ()
00:23:22 <copumpkin> :)
00:23:38 <copumpkin> not always general enough, I guess
00:23:49 <glguy> someone got cruft in my peanut butter!
00:24:00 <copumpkin> I like crunchy peanut butter
00:24:14 <glguy> in the future there will be robots
00:24:21 <Axman6> making forkIO :: IO a -> IO ThreadId would break exactly no code right?
00:24:55 <copumpkin> well, it might help resolve some type variables in some cases, I guess
00:25:17 <glguy> it could break some code that used to depend on type-inference setting the return type to () to help with type-class selection or something...
00:25:32 <glguy> in a contrived case, at least
00:26:18 * dmwit is willing to bet that making forkIO have the more general type would break exactly no existing code
00:26:37 * copumpkin quickly submits a contrived package to hackage
00:26:45 <copumpkin> @hackage make-dmwit-lose-his-bet
00:26:46 <lambdabot> http://hackage.haskell.org/package/make-dmwit-lose-his-bet
00:26:49 <glguy> copumpkin: too late, lots of people have done that already
00:26:54 * dmwit carefully notes the word "existing" in his bet
00:27:09 <copumpkin> dmwit: it already existed, I swear!
00:27:13 <dmwit> ;-)
00:27:35 <glguy> ahh, a philosophical question about what it means for code to exists
00:28:02 <monochrom> I want to see how you break it.
00:31:40 <copumpkin> :t Control.Concurrent.forkIO
00:31:41 <lambdabot> IO () -> IO GHC.Conc.ThreadId
00:32:12 <copumpkin> :t \x -> Control.Concurrent.forkIO (x >> return ())
00:32:13 <lambdabot> forall a. IO a -> IO GHC.Conc.ThreadId
00:32:14 <glguy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25508#a25508
00:33:35 <dolio> glguy: You should talk to the people who want ever 'm' that appears in "do ... ; m ; ..." to have a type like 'm ()'.
00:34:03 <glguy> let those people make their own language
00:34:29 <dmwit> It was inspired by F#, believe it or not.
00:34:29 <copumpkin> h()skell?
00:34:37 <dolio> They're trying. It's called the next version of Haskell. :)
00:34:39 <glguy> they can call it "hassle"
00:34:54 <dmwit> Look, you're the one who turned on -Wall.
00:35:05 <dmwit> You don't like it, you pick a different -W setting.
00:35:09 <glguy> yeah, the rest of it is useful
00:35:55 <Jafet> Another brick in the wall
00:36:38 <copumpkin> glguy: so are you making a tftp server in haskell?
00:36:55 <glguy> at this point it is "made"
00:37:35 <copumpkin> aha
00:37:47 <Jafet> It's not "made" until -Wall approves!
00:38:03 <glguy> I fixed the -Wall warning with that >>= putMVar done
00:38:25 <dolio> Was someone here writing a program to show lazy reduction of lambda terms?
00:39:01 <glguy> monochrom: did you see how to break it?
00:39:07 <Jafet> "Was"? benmachine stopped?
00:39:10 <monochrom> Yes
00:39:19 <dolio> Is, was, whatever.
00:40:49 <copumpkin> past and present are one, for dolio
00:41:00 <dolio> Call me Dr. Manhattan.
00:41:13 <glguy> OK, Dr. Manhattan.
00:42:07 <copumpkin> dolio's feeling blue
00:42:14 <copumpkin> Dr. Manhattan, I mean
00:42:16 <dmwit> abadee abadie
00:52:35 * glguy makes a note to campaign against the attack on do notation in the next version of Haskell on Monday
00:53:04 <glguy> goodnight!
00:53:43 <monochrom> yeah, down with (down with (do notation))
00:54:15 <monochrom> (DoNotation -> Bad) -> Bad
00:55:38 <Raynes> Do notation considered harmful? What's next? A black US president?
00:55:48 <monochrom> @djinn ((donotation -> bad) -> bad) -> donotation
00:55:48 <lambdabot> -- f cannot be realized.
00:59:59 <monochrom> @unmtl Cont Bad DoNotation
00:59:59 <lambdabot> (DoNotation -> Bad) -> Bad
01:05:04 <newbie008> copumpkin: ok
01:05:15 <copumpkin> newbie008: so yeah, you never see Maybe in isolation at the value level
01:05:34 <copumpkin> it's always Maybe Int or Maybe Bool or Maybe String or Maybe applied to some other concrete type
01:05:51 <newbie008> yes i've seen that
01:05:57 <newbie008> but lemme open the subject with this
01:05:57 <newbie008> copumpkin: so if "(call/cc (lambda (k) (k 42)))" is the simplest usage of callcc that i can find, what would be the simplest usage of monads?
01:06:07 <copumpkin> I wouldn't start from there
01:06:15 <copumpkin> functors are simpler to grasp and are on the path to monads
01:06:37 <copumpkin> (by the way, Cont a is a monad too :P)
01:06:49 <copumpkin> (continuations)
01:07:06 <Fanael> Yet another person who wants to understand monads?
01:07:11 <copumpkin> :P
01:07:23 <copumpkin> newbie008: do you have a feeling for functors?
01:07:30 <Taejo> newbie008: the simplest usage of monads is all stuff you do already... Monads are an abstraction -- noticing that there are similarities between those things
01:07:46 <newbie008> Fanael: i just understood call/cc so i'm feeling like another challenge
01:08:07 <copumpkin> :t callCC
01:08:08 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
01:08:16 * copumpkin whistles
01:08:24 <newbie008> copumpkin: lemme think
01:08:40 <newbie008> copumpkin: no i dont know functors but i can go do some reading
01:09:05 <dmwit> > return 4 :: Maybe Int -- the simplest usage of a monad
01:09:06 <lambdabot>   Just 4
01:09:12 <dmwit> > return 4 :: [Int]
01:09:13 <copumpkin> well, all monads are functors, so it'll be helpful
01:09:13 <lambdabot>   [4]
01:09:24 <dmwit> > return 4 :: IO Int
01:09:25 <lambdabot>   <IO Int>
01:09:28 <copumpkin> newbie008: a functor is also a type constructor, like Maybe or [] (list)
01:10:09 <copumpkin> and it must behave nicely, so you provide a function to prove it does
01:10:27 <copumpkin> > fmap (+1) [1,2,3]
01:10:28 <lambdabot>   [2,3,4]
01:10:33 <copumpkin> > fmap (+1) (Just 1)
01:10:35 <lambdabot>   Just 2
01:10:44 <copumpkin> newbie008: see the similarity?
01:11:08 <newbie008> *reading*
01:12:12 <copumpkin> man, I'm sleepy. But I must finish watching this crappy movie
01:12:40 <Fanael> > (+) <$> Just 1 <*> Just 2
01:12:41 <lambdabot>   Just 3
01:12:42 <newbie008> copumpkin: so a monad is a specific kind of functors?
01:12:53 <copumpkin> newbie008: yes, it's a functor with some additional properties
01:13:10 <newbie008> and functors are things that you can apply a higher-order function to?
01:13:21 <copumpkin> functors are things that you can "map" over
01:13:33 <copumpkin> in some sense, anyway
01:13:39 <copumpkin> another language might call them Mappable
01:13:42 <newbie008> ok i'm with you
01:14:01 <newbie008> so lists are functors too?
01:14:05 <copumpkin> yep
01:14:13 <copumpkin> there are several others, too
01:14:21 <newbie008> so if i asked you
01:14:24 <dmwit> In addition to fmap, monads get return and join:
01:14:25 <dmwit> :t return
01:14:26 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
01:14:28 <dmwit> :t join
01:14:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:14:44 <copumpkin> return :: a -> [a], for lists
01:14:52 <copumpkin> join :: [[a]] -> [a]
01:14:57 <newbie008> but if i asked you "what is it about the list that makes it a functor?", the only thing you could say would be "the fact that you can apply map to it?"
01:15:10 <copumpkin> newbie008: it must satisfy the functor laws! :)
01:15:16 <newbie008> which are?
01:15:19 <copumpkin> newbie008: which is effectively our way of encoding the category theory into haskell
01:15:24 <copumpkin> fmap id = id
01:15:26 <dmwit> newbie008: fmap id = id
01:15:31 <copumpkin> fmap f . fmap g = fmap (f. g)
01:15:38 <newbie008> oh
01:15:40 <dmwit> copumpkin is too fast =)
01:15:46 <copumpkin> that's what she said :(
01:15:48 <copumpkin> oh wait
01:15:51 <newbie008> but those are just really saying "fmap has to work"
01:16:01 <dmwit> newbie008: yep
01:16:04 <copumpkin> newbie008: yep, they're pretty trivial, but are remarkably useful
01:16:34 <copumpkin> maybe surprisingly, one of them is actually redundant in haskell
01:16:36 <newbie008> is fmap simply "functor map" ? I knew map but i never knew fmap
01:16:42 <copumpkin> yeah
01:16:46 <newbie008> ok then
01:16:47 <copumpkin> fmap is just map for lists
01:17:02 <newbie008> do you mean that the other way around?
01:17:12 <newbie008> i've always used map with lists
01:17:19 <newbie008> never used fmap with lists
01:17:20 <Taejo> yes, map is fmap for lists
01:17:26 <dmwit> ?src Functor []
01:17:26 <lambdabot> Source not found. You untyped fool!
01:17:27 <newbie008> oh okay :)
01:17:28 <Taejo> but you can use fmap on lists
01:17:30 <copumpkin> I guess it depends how you think about that sentence :P
01:17:30 <dmwit> ?src [] Functor
01:17:31 <lambdabot> Source not found. Wrong!  You cheating scum!
01:17:33 <dmwit> oh, right
01:17:35 <dmwit> ?src [] fmap
01:17:36 <lambdabot> fmap = map
01:17:39 <dmwit> newbie008: =)
01:17:44 <newbie008> no way!!
01:17:49 <newbie008> hahaha
01:17:54 <copumpkin> that's actually what it is in the standard library
01:17:55 <newbie008> okay then, i now know fmap
01:17:59 <copumpkin> instance Functor [] where fmap = map
01:18:05 <dmwit> ?src Maybe fmap
01:18:06 <lambdabot> fmap _ Nothing       = Nothing
01:18:06 <lambdabot> fmap f (Just a)      = Just (f a)
01:18:11 <newbie008> okay so now i know what a functor is
01:18:16 <copumpkin> yep
01:18:22 <Fanael> ?src [] (<*>)
01:18:23 <lambdabot> (<*>) = ap
01:18:23 <newbie008> carry on please :)
01:18:27 <copumpkin> so a monad adds two additional methods to that
01:18:29 <Fanael> ap?
01:18:44 <copumpkin> meh
01:18:50 <dmwit> ap mf mx = do { f <- mf; x <- mx; return (f x) }
01:18:52 <copumpkin> we appear to be skipping applicative and <*>, but we'll live
01:19:25 <dmwit> :t ap
01:19:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:19:33 <copumpkin> newbie008: the first one is a -> m a, which is basically "sticking something into it"
01:19:43 <copumpkin> newbie008: Maybe and [] both obviously support that
01:19:52 <copumpkin> [] even supports it in more than one way
01:19:55 <Fanael> I know what ap is, I'm just surprised that it is <*> for lists...
01:20:03 <dmwit> Fanael: <*> is ap
01:20:08 <copumpkin> ap and <*> should always be the same
01:21:00 <Fanael> It's not true when something is an applicative functor but not a monad ;)
01:21:08 <copumpkin> newbie008: that a -> m a function is called return!
01:21:14 <copumpkin> Fanael: you know what I mean :P
01:21:31 <newbie008> copumpkin: by "sticking something into it" you mean boxing it?
01:21:43 <dmwit> Often, but not always.
01:22:02 <copumpkin> it's easy to think of it in terms of containers, but it's not the only things that can be functors
01:22:18 <newbie008> if the rule is a -> m a doesnt that mean that I will pass a parameter and you will apply m to it?
01:22:19 <copumpkin> return is technically from something called a pointed functor
01:22:41 <dmwit> For example, for continuations, return is simply the trivial continuation... which doesn't really correspond to "boxing" in the usual sense.
01:22:50 <dmwit> newbie008: Oh, no!
01:22:53 <dmwit> newbie008: Not at all.
01:23:01 <copumpkin> m is a type constructor there
01:23:05 <dmwit> newbie008: 'm' is a type function, not a value function; you can't apply it to a value of type 'a'.
01:23:06 <copumpkin> like Maybe or []
01:23:16 <copumpkin> Int -> [Int]
01:23:21 <copumpkin> or Bool -> Maybe Bool
01:23:21 <newbie008> oh so a -> m a can be seen as typecasting?
01:23:27 <copumpkin> not even casting
01:23:43 <newbie008> oh i got it then, not casting, youre simply ... "boxing it"
01:23:45 <newbie008> i get it
01:23:47 <newbie008> :)
01:23:58 <copumpkin> it takes an "unmonadic" (sometimes called pure) value and sticks it in the monad, whatever that means for that particular monad
01:24:01 <newbie008> i'll be careful with the boxing concept but it makes things simpler to see
01:24:17 <copumpkin> so for list,
01:24:19 <kmc> if functors are containers, then pointed functors are containers with a "one element" case you can build from the element itself
01:24:21 <newbie008> okay, so that's the first thing monads have that functors dont
01:24:22 <dmwit> Yes, boxes can be a fine intuition to start with. =)
01:24:23 <copumpkin> > return 5 :: [Int]
01:24:24 <lambdabot>   [5]
01:24:29 <kmc> not all functors are usefully thought of as containers, but so it goes
01:24:36 <copumpkin> > return False :: Maybe Bool
01:24:37 <lambdabot>   Just False
01:24:57 <copumpkin> newbie008: the other one is the deeper/more powerful one
01:25:04 <copumpkin> :t join
01:25:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:25:06 <dmwit> > return 3 (error "surprise!")
01:25:07 <lambdabot>   3
01:25:13 <copumpkin> lol
01:25:21 <newbie008> now before you get to join
01:25:32 <newbie008> that a -> m a, is that a property that monads have, or a rule, or what?
01:25:41 <dmwit> a -> m a is a type.
01:25:48 <dmwit> It's the type of the function "return".
01:25:49 <copumpkin> yeah, we call something that has that (and satisfies some obvious laws) a monad
01:25:53 <newbie008> is that one of the laws that a things has to have to be a monad? like the laws we saw before for functors?
01:25:57 <copumpkin> yep
01:26:00 <dmwit> Actually, to be pedantic, return has the type Monad m => a -> m a.
01:26:29 <newbie008> okay, so you added the "return" law to functors
01:26:41 <copumpkin> yeah, or a method called return that satisfies some laws, anyway
01:26:46 <dmwit> No... we can't state the laws until we've got join.
01:26:48 <newbie008> which has nothing to do with the "return" we were mentioning when you were helping me out with callcc :)
01:27:03 <newbie008> okay lets go to join then
01:27:11 <copumpkin> yeah, it's a bit confusing for people coming from other languages
01:27:33 <copumpkin> join is for flattening monads!
01:27:39 <newbie008> so unboxing?
01:27:43 <dolio> You can state that return must be a natural transformation, at least.
01:27:43 <copumpkin> nope
01:27:52 <Taejo> ironically, "return" was named that way in an appeal to imperative programming
01:28:00 <dolio> return . f = fmap f . return
01:28:12 <copumpkin> newbie008: monadness itself doesn't ever let you unbox values
01:28:20 <copumpkin> newbie008: individual monads might allow you to, but in general you can't
01:28:35 <copumpkin> newbie008: you can, however, "unbox" a value within the monad (if they're neested) :P
01:28:38 * copumpkin fails
01:28:48 <newbie008> what would be a more appropriate name for "return" if they werent trying to appeal to imperative programming like Taejo said?
01:29:00 <copumpkin> point is what some people call it
01:29:05 <Fanael> Are there any monad which doesn't allow to get 'unboxed' value?
01:29:07 <dmwit> unit, singleton, point, pure
01:29:22 <dmwit> Fanael: IO
01:29:23 <copumpkin> Fanael: IO ;)
01:29:25 <dmwit> ST
01:29:27 <Taejo> Applicative uses "pure", it's called "unit" in category theory
01:29:33 <dmwit> Eh, ST isn't a good example, I guess.
01:29:41 <newbie008> can we call return and join "box" and "unbox" for the sake of simplification?   =)
01:29:42 <copumpkin> :t runST
01:29:43 <lambdabot> forall a. (forall s. ST s a) -> a
01:29:50 <copumpkin> newbie008: nah, they aren't opposites
01:29:51 <dmwit> STM, maybe, depending on what you mean by "unboxed".
01:30:07 <copumpkin> newbie008: we can call return box if you insist, but join is not unbox
01:30:20 <Entroacceptor> can I get ghc to cross-compile?
01:30:37 <newbie008> what would be a better name for join then?
01:30:49 <copumpkin> newbie008: join is a pretty decent name
01:31:06 <newbie008> and how would you use it? I understood the example someone gave before for "return" : Bool -> Maybe Bool
01:31:11 <copumpkin> it beats mu
01:31:17 <newbie008> so for join would an example be...
01:31:19 <copumpkin> newbie008: well, you tell me
01:31:20 <Taejo> > join (Just (Just 3))
01:31:22 <lambdabot>   Just 3
01:31:26 <copumpkin> [[Int]] -> [Int]
01:31:29 <copumpkin> how would you write that?
01:31:29 <Taejo> > join (Just (Nothing))
01:31:30 <lambdabot>   Nothing
01:31:33 <newbie008> Maybe Maybe Bool -> Maybe Bool
01:31:34 <newbie008> ?
01:31:42 <dmwit> Maybe (Maybe Bool) -> Maybe Bool
01:31:53 <newbie008> oh ok
01:32:06 <Taejo> join on Maybe turns Just (Just x) into Just x, everything else into Nothing
01:32:15 <roconnor> @tell kar-1 see theorem 3.2.2 and corollary 3.2.5
01:32:16 <lambdabot> Consider it noted.
01:32:22 <copumpkin> > join [[1,2,3],[4,5,6],[2,3,4]]
01:32:23 <lambdabot>   [1,2,3,4,5,6,2,3,4]
01:33:01 <newbie008> how do you send statements to lambdabot?
01:33:09 <copumpkin> just stick "> " in front
01:33:22 <newbie008> > join [[1,2],[4,5]]
01:33:23 <lambdabot>   [1,2,4,5]
01:33:33 <roconnor> @tell kar-1 oh and the axiom of choice has no arithmetic consequences (in fact it has no Sigma^1_2 consequces) so issues about the axiom of choice are irrelevent
01:33:34 <lambdabot> Consider it noted.
01:33:35 <newbie008> > return [] 2
01:33:36 <lambdabot>   []
01:33:42 <copumpkin> that's a confusing one
01:33:45 <copumpkin> I'd avoid it for now :P
01:33:51 <copumpkin> > return 2 :: [Int]
01:33:53 <lambdabot>   [2]
01:33:55 <newbie008> but you see what i was trying to do right?
01:34:01 <newbie008> oh i see
01:34:03 <copumpkin> yeah
01:34:27 <Entroacceptor> > return [2]
01:34:27 <lambdabot>   No instance for (GHC.Show.Show (m [t]))
01:34:28 <lambdabot>    arising from a use of `M32114272...
01:34:33 <newbie008> :t return
01:34:34 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
01:34:36 <dmwit> ?src (->) return
01:34:36 <lambdabot> return = const
01:34:48 <dmwit> ^^ this explains the weird "return [] 2" thing above
01:34:57 <dmwit> > const [] 2
01:34:58 <lambdabot>   []
01:35:07 <newbie008> hmmm
01:35:13 <copumpkin> and type inference is what forced it to figure that out
01:35:17 <newbie008> return [Int] 2
01:35:21 <dmwit> Don't worry about it, though; that's a monad we can skip to begin with.
01:35:26 <newbie008> > return [Int] 2
01:35:27 <lambdabot>   Not in scope: data constructor `Int'
01:35:27 <copumpkin> you're breaking the type/value barrier!!
01:35:30 <copumpkin> call in the type police
01:35:31 <newbie008> okay
01:35:34 <newbie008> hahaha sorry :P
01:35:41 <dmwit> > return [33, 56, 8] 2
01:35:42 <lambdabot>   [33,56,8]
01:35:46 * copumpkin deports newbie008 to #agda
01:35:46 <newbie008> okay so i understand return and join
01:35:48 <newbie008> what now?
01:35:53 <copumpkin> newbie008: that's it :P
01:36:04 <Taejo> return, fmap and join together make a monad
01:36:06 <copumpkin> newbie008: there are a few laws that say the functions should make sense
01:36:26 <newbie008> that can't be all, i need an epiphany :D
01:36:48 <copumpkin> well, understanding how it's actually a useful abstraction is the next step
01:36:49 <dmwit> Sorry, no epiphany. We keep telling people this stuff is dead simple, and we mean it. =)
01:36:51 <newbie008> i mean, how can just that be so useful?
01:37:07 <dmwit> ah!
01:37:15 <dmwit> It's useful because it's useful. =)
01:37:15 <newbie008> aha that's the million dollar question right?
01:37:26 <Taejo> it's so useful *because* it's so simple: if it were so complex, there wouldn't be so many monads
01:37:28 <copumpkin> newbie008: people just found a recurring pattern and gave it a name :)
01:37:32 <dmwit> Lots of programming patterns can be simplified in a very similar way.
01:37:44 <Taejo> @src sequence
01:37:44 <lambdabot> sequence []     = return []
01:37:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:37:45 <lambdabot> --OR
01:37:45 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
01:37:46 <dmwit> And it turns out that monads are the common thread between them.
01:37:47 <copumpkin> newbie008: admittedly, the join form isn't the most common one
01:37:58 <copumpkin> and the other form is a little less intuitive and a little more practical
01:38:16 <dmwit> Yep, the other form is to have just two functions, return and (=<<)
01:38:20 <dmwit> :t (=<<)
01:38:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
01:38:23 <newbie008> > sequence [1,2,3]
01:38:24 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
01:38:24 <lambdabot>    arising from a use of `M30496003...
01:38:32 <copumpkin> hah
01:38:39 <newbie008> ?
01:38:40 <Taejo> :t sequence
01:38:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:38:46 <copumpkin> > sequence [[1,2],[3,4]]
01:38:47 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
01:38:48 <dmwit> (=<<) push normal functions a little deeper into the monad.
01:39:00 <newbie008> WHOA
01:39:03 <Taejo> > sequence [Just 5, Just 7, Just 1]
01:39:04 <newbie008> that's useful my friend
01:39:04 <lambdabot>   Just [5,7,1]
01:39:08 <Taejo> > sequence [Just 5, Just 7, Nothing]
01:39:08 <lambdabot>   Nothing
01:39:15 <Fanael> Wasn't it (>>=)?
01:39:19 <newbie008> :D
01:39:20 <newbie008> hold on hahaha let me absorb this :
01:39:25 <dmwit> (=<<) has always seemed more natural to me.
01:39:32 <roconnor> @tell soupdragon you cannot encode any mathematical problem into the halting or non-halting of a machine, only Pi_1/Sigma_1 problems.
01:39:33 <lambdabot> Consider it noted.
01:39:38 <dmwit> (a -> m b) -> (m a -> m b) -- there's something pleasing about the symmetry of this type
01:39:43 <copumpkin> newbie008: what's important to note is that the sequence/(>>=)/(=<<)/(>=>) view of things is equivalent to the super simple one we gave you beofre
01:39:48 <copumpkin> they're just different ways of looking at the same thing
01:39:53 <copumpkin> and one can be derived from the other
01:40:16 <copumpkin> yeah, =<< is nicer
01:40:31 <newbie008> what were you guys saying above about "the other form"? the other form of what? monads?
01:40:47 <copumpkin> it's just another way of looking at the same set of rules
01:40:52 <dmwit> newbie008: There's several equivalent ways to define a monad.
01:40:53 <copumpkin> it's the (=<<) thing that dmwit just did
01:41:12 <dmwit> newbie008: One is return/fmap/join; one is return/=<<; there are still others, as well.
01:41:39 <Taejo> newbie008: basically, (return, fmap, join) are equivalent to (return, (=<<)) -- you can use the former three to write (=<<) and the latter two to right fmap and join
01:41:58 <copumpkin> :t (<=<)
01:41:59 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
01:42:03 <copumpkin> that's the cleanest :)
01:42:10 <newbie008> so is =<< in place of return or join?
01:42:11 <copumpkin> and is also derivable from the above ones
01:42:19 <copumpkin> newbie008: it replaces join and fmap
01:42:29 <copumpkin> it's kind of both of them folded into one
01:42:39 <dmwit> Yes, I like (<=<) a lot, too.
01:42:41 <dmwit> So many choices!
01:43:12 <dmwit> g <=< return = g
01:43:14 <copumpkin> all hail the hypnofish
01:43:19 <dmwit> return <=< g = g
01:43:22 <newbie008> oh i just got the =<< part, they can be defined in terms of the others
01:43:27 <copumpkin> yep
01:43:36 <dmwit> (f <=< g) <=< h = f <=< (g <=< h)
01:43:41 <copumpkin> so the official Haskell Monad class has return and (>>=) in it
01:43:43 <newbie008> much like OR, AND, NAND, XOR, etc, you can pick 3 and define the others, or something like that
01:43:51 <Taejo> yes
01:44:26 <copumpkin> newbie008: the official Haskell Monad class also has an evil method in it that doesn't belong in there, so just plug your nose and ignore it
01:44:45 <copumpkin> the designers were on crack
01:44:55 <Fanael> f***?
01:45:01 <copumpkin> yesh
01:45:10 <Taejo> if only we could agree what kind of crack, we would fix it :)
01:45:23 <newbie008> what is the evil method?
01:45:32 <mxc> yeah, why is fail in there anyway?
01:45:46 <newbie008> i thought the only thing evil in haskell was the performUnsafeIO thingy or whatever it's called ;)
01:45:47 <copumpkin> mxc: the name says it all
01:45:49 <mxc> everything else seems so clean, elegant and pure, then they stuck that in there for no good reason
01:45:51 <mxc> heh
01:46:08 <dmwit> Well, we know why it's there.
01:46:11 <dmwit> But that doesn't excuse it.
01:46:13 <copumpkin> newbie008: there's evil in various places
01:46:19 <copumpkin> that's a different kind of evil though
01:46:23 <mxc> they go ahead and pollute it with f***, but adding functor and applicative instances to monad, no that would be overkill
01:46:31 <copumpkin> newbie008: this evil is an inelegant evil
01:46:33 <dmwit> It's there so that failed pattern matches in do notation have something to call.
01:46:40 <Taejo> fail is bad design, whereas unsafePerformIO is actually unsafe
01:46:58 <mxc> dmwit - but they essentially just call error "pattern match" anyway right?
01:47:04 <dmwit> I think we can all agree that do-blocks with pattern matches that could fail should really be MonadZero's instead of Monads.
01:47:09 <dmwit> mxc: No, not error. fail
01:47:14 <copumpkin> :t fail
01:47:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
01:47:28 <mxc> dmwit - right, but in most monads, fail just calls error... right?
01:47:33 <dmwit> > do { Just x <- [Nothing]; return x }
01:47:34 <lambdabot>   []
01:47:39 <dmwit> mxc: ^^ for example
01:47:42 <copumpkin> > fix fail
01:47:44 <lambdabot>   ""
01:47:47 <Taejo> mxc: in monads that aren't MonadZeros, yes
01:48:01 <Taejo> in a MonadZero, fail should equal mzero
01:48:17 <dmwit> MonadPlus, sorry
01:48:28 <mxc> so basically the reason is that monad designers  can override the fail behavior
01:48:33 <dolio> That depends what you mean by 'equal'.
01:48:51 <Taejo> am I being stupid again?
01:49:11 <dolio> Either carries a message, for instance.
01:49:19 <Taejo> oh, right
01:49:38 <newbie008> ok, how can monads help me understand why this works? --->   main = mapM putStr ["a","b"]
01:49:55 <Taejo> well mapM is a monad function
01:50:11 <copumpkin> I'd start by figuring out sequence
01:50:11 <Taejo> @src mapM
01:50:11 <lambdabot> mapM f as = sequence (map f as)
01:50:23 <dmwit> mapM_ f (x:xs) = f x >> mapM_ f xs; mapM_ f [] = return ()
01:50:30 <newbie008> so it transforms that into putStr "a" ; putStr "b"   ??
01:51:04 <Taejo> yes
01:51:07 <dmwit> Actually... it transforms it into
01:51:14 <copumpkin> loosely
01:51:17 <dmwit> do { x <- putStr "a"; y <- putStr "b"; return [x, y] }
01:52:05 <newbie008> dmwit: ok, so i need to ask something
01:52:23 <newbie008> > sequence [1,[2,3]]
01:52:24 <lambdabot>   No instance for (GHC.Num.Num [a])
01:52:24 <lambdabot>    arising from a use of `e_1123' at <int...
01:52:28 <newbie008> oh sorry
01:52:37 <newbie008> > sequence [[1],[1,2]]
01:52:38 <lambdabot>   [[1,1],[1,2]]
01:53:03 <copumpkin> trying to understand the list monad might not be the best starting place
01:53:07 <dmwit> > do { x <- [1]; y <- [1, 2]; return [x, y] }
01:53:08 <lambdabot>   [[1,1],[1,2]]
01:53:09 <copumpkin> play with Maybe first, maybe
01:53:10 <newbie008> dmwit: can you show me how that works in terms of how you just showed me this? --->  do { x <- putStr "a"; y <- putStr "b"; return [x, y] }
01:53:10 <dmwit> =)
01:53:19 <dmwit> newbie008: same way =)
01:53:27 <newbie008> so it'd be :
01:53:29 <dmwit> newbie008: Although I will admit that the list monad can be a little surprising at first.
01:53:42 <copumpkin> newbie008: have you come across nondeterminism?
01:53:53 <copumpkin> in the sense of something doing more than one thing "at once"?
01:54:12 <newbie008> do { x <- [1][1]; y <- [1][2]; return [x,y] } ????
01:54:31 <newbie008> copumpkin: no i have never read about that
01:54:42 <newbie008> copumpkin: i've only read about nondeterminism in philosophy :)
01:54:43 <dmwit> newbie008: Almost. See my expansion above.
01:54:58 <copumpkin> newbie008: well the list monad approximates doing multiple things at once :)
01:55:16 <newbie008> dmwit: i saw it, i was trying to do mine based on that
01:55:29 <newbie008> oh i didnt see it
01:55:30 <newbie008> hold on
01:55:33 <dmwit> =)
01:55:59 <newbie008> that cant be right...
01:56:19 <newbie008> then at what part did  [1], [1,2] get transformed into [1,1], [1,2] ??
01:56:39 <dmwit> Let's work through it together.
01:56:44 <newbie008> ok :)
01:56:48 <Taejo> newbie008: it might help not to duplicate values in your example
01:56:52 <dmwit> First things first: we have to implement (>>=)
01:56:58 <newbie008> right lets use 1,2,3 :)
01:57:02 <Taejo> > sequence [[3], [1,2]]
01:57:02 <dmwit> :t (>>=)
01:57:03 <lambdabot>   [[3,1],[3,2]]
01:57:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:57:20 <dmwit> or, less polymorphically:
01:57:31 <dmwit> :t (>>=) :: [a] -> (a -> [b]) -> [b]
01:57:32 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
01:57:46 <dmwit> newbie008: Think you can write a function with that type?
01:58:09 <dmwit> There's a few cheesy ones, and one good one.
01:58:12 <newbie008> with >>='s type?
01:58:19 <dmwit> yes
01:59:11 <newbie008> so it's a function that takes two parameters: a list and a function that takes a and returns a list of b's; and then it returns a list of b's?
01:59:21 <newbie008> :t map
01:59:22 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:59:29 <newbie008> the opposite of map then
01:59:35 <newbie008> oh almost
01:59:56 <newbie008> i'm thinking
02:00:05 <dmwit> Take your time.
02:00:43 <copumpkin> I think it may be time for me to sleep
02:02:38 <newbie008> i'm still thinking, don't tell me
02:02:55 * copumpkin disappears! g'night
02:02:58 <copumpkin> and good luck :P
02:03:07 <newbie008> copumpkin: thank you for the help
02:03:13 <copumpkin> np :)
02:03:14 <newbie008> copumpkin: nighty night
02:04:35 <newbie008> dmwit: i think i got it
02:04:49 <dmwit> Okay, let's see it.
02:05:04 <newbie008> i dont know if i can write it but let me tell you the functionality first
02:05:12 <newbie008> is that ok?
02:05:15 <dmwit> sure!
02:05:24 <newbie008> ok,
02:05:43 <newbie008> with that type i could write a function that takes two parameters,
02:05:46 <newbie008> and the example iwll be
02:05:51 <newbie008> these parameters:
02:06:31 <newbie008> ["string1", "string2"] and then a function that takes individual items off a list and returns a list of the atoms in it
02:06:37 <newbie008> and then it'll return that list
02:06:48 <newbie008> so basically i could make a function that would flatten a list of strings
02:06:51 <newbie008> that's what i think
02:07:04 <newbie008> it would return just one strin
02:07:05 <newbie008> g
02:07:10 <dmwit> hm
02:07:12 <newbie008> :t join
02:07:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:07:24 <newbie008> lemme try some more
02:07:29 <dmwit> I think you'd better do *something* with every part of the input.
02:07:45 <newbie008> well the (a -> [b]) throws me off
02:07:56 <newbie008> because i dont know how to turn just one thing (a) into a list of other things
02:07:59 <dmwit> Well, you don't have to write a function with that type.
02:08:13 <dmwit> You're given a function with that type, and have to make one with the type [a] -> [b].
02:08:14 <newbie008> other than to think of turning a string into a list of chars but that's again a string
02:08:49 <dmwit> It might help if we motivate this a bit.
02:08:57 <newbie008> i'm having trouble thinking of a function that has such a type (a -> [b]) that is not the "flatten" function
02:09:07 <dmwit> So, I'm going to steal straight from "You Could Have Invented Monads".
02:09:11 <dmwit> Here's the setup.
02:09:19 <dmwit> You're writing a square-root function.
02:09:28 <dmwit> Now, square roots are kind of funny.
02:09:44 <newbie008> ok
02:09:48 <dmwit> For positive numbers, there are two square roots, and for zero, there's only one, and for negative numbers, there aren't any.
02:10:02 <dmwit> But you'd like to write a function that handles all of these correctly.
02:10:07 <dmwit> So, what's its type?
02:10:21 <dmwit> Well, there's a couple good answers, but one possibility is
02:10:31 <dmwit> root :: Double -> [Double]
02:10:42 <dmwit> Do you think you could write that function?
02:11:02 <newbie008> *thinking*
02:11:14 <dmwit> (You're allowed to use this one for free:
02:11:15 <dmwit> :t sqrt
02:11:16 <lambdabot> forall a. (Floating a) => a -> a
02:11:22 <dmwit> > sqrt 37
02:11:23 <lambdabot>   6.082762530298219
02:11:29 <Fanael> There aren't any square roots for negative numbers?
02:11:39 <newbie008> not counting complex numbers
02:11:42 <dmwit> Let's stay with real numbers for now.
02:11:50 <dmwit> Doubles, in particular. =)
02:11:52 <newbie008> now why do you say there are two square roots for positive numbers?
02:12:02 <Fanael> sqrt 4 = 2 or -2
02:12:09 <newbie008> oh i see
02:12:11 <newbie008> oh ok
02:12:16 <newbie008> yeah i can write that function probably
02:12:17 <newbie008> hold on
02:17:31 <newbie008> i'm having trouble printing a double; i can print an integer fine
02:18:01 <newbie008> > putStr (sqrt 16)
02:18:02 <lambdabot>   No instance for (GHC.Float.Floating GHC.Base.String)
02:18:02 <lambdabot>    arising from a use ...
02:18:11 <dmwit> ack, why bother printing?
02:18:25 <dmwit> > sqrt 16
02:18:26 <lambdabot>   4.0
02:18:36 <newbie008> just to help
02:18:46 <dmwit> Well, use print instead of putStr.
02:19:04 <dmwit> But with ghci it really shouldn't be necessary.
02:19:20 <newbie008> ok but i'm compiling and all :)
02:19:24 <newbie008> i'll be done in a sec
02:19:27 <dmwit> Why?
02:19:42 <dmwit> For playing around, compilation is such overkill... =P
02:21:53 <newbie008> i'm not comfortable with REPLs
02:22:18 <newbie008> okay i'm having trouble returning a list... hardcoded example: root x = [2][3]  how do i do that?
02:22:30 <Fanael> root x = [2, 3]
02:22:35 <newbie008> oh ok
02:22:35 <dmwit> The syntax for lists with several elements is [a, b, c, d]
02:22:39 <dmwit> not [a][b] =)
02:23:42 <newbie008> dmwit: v
02:23:44 <newbie008> dmwit: root x = if x > 0 then [sqrt x, -(sqrt x)] else [sqrt x]
02:23:47 <newbie008> finally  :D
02:24:13 <opqdonut> > sqrt (-2)
02:24:15 <lambdabot>   NaN
02:24:20 <newbie008> main = mapM print (root 0.0)  --> 0
02:24:29 <newbie008> main = mapM print (root 16.0)  --> 4.0 and -4.0
02:24:33 <opqdonut> > sqrt (-2 :+ 0)
02:24:34 <lambdabot>   Precedence parsing error
02:24:35 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
02:24:40 <dmwit> newbie008: Hm, that doesn't look quite right for negative numbers. =P
02:24:41 <opqdonut> > sqrt ((-2) :+ 0)
02:24:42 <lambdabot>   0.0 :+ 1.4142135623730951
02:24:42 <opqdonut> anyway
02:24:58 <dmwit> newbie008: But fine, it's good enough for the next bit to make sense.
02:25:10 <dmwit> opqdonut: hush, we're in the middle of something
02:25:17 <opqdonut> yeah, sorry
02:25:29 <dmwit> newbie008: Okay. So.
02:25:42 <dmwit> newbie008: Now, it turns out as the pointy-haired boss that I didn't want the square root after all.
02:25:46 <dmwit> I wanted the fourth root.
02:25:56 <dmwit> As a clever programmer, you wish you could just write
02:26:04 <dmwit> fourth_root x = root (root x)
02:26:12 <dmwit> ...but the types don't quite line up, you see?
02:26:32 <dmwit> Because (root x) returns a list, but the second call to root is expecting just a plain old number.
02:26:36 <roconnor> @type root
02:26:37 <lambdabot> Not in scope: `root'
02:26:46 <dmwit> root :: Double -> [Double]
02:26:55 <roconnor> fourth_root = root >=> root ?
02:26:59 <dmwit> yes
02:27:05 <dmwit> newbie008 is learning monads =)
02:27:07 <newbie008> hmm lemme ponder that
02:27:08 <roconnor> oh
02:27:41 <dmwit> newbie008: So, here's what you as a programmer think would be a neat idea:
02:28:01 <dmwit> what if you could write a function that takes something with root's type, and turned it into a function that worked on lists?
02:28:04 <dmwit> e.g.
02:28:17 <dmwit> (=<<) :: (a -> [b]) -> ([a] -> [b])
02:28:41 <newbie008> right...
02:28:55 <newbie008> yeah because i can't do root (root x), gotcha
02:28:59 <dmwit> Before you dive off on that, can you see how to write fourth_root using that function?
02:29:08 <dmwit> (and root?)
02:29:17 <newbie008> lemme try
02:30:06 <dmwit> For now, it's okay if you get repeated fourth roots.
02:33:10 <newbie008> dmwit: fourth_root = (=<<) root
02:33:11 <newbie008> dmwit: main = mapM print (fourth_root [10.0, 15.0])
02:33:18 <newbie008> and yes i got repeated fourth roots
02:33:34 <dmwit> um
02:33:51 <newbie008> oh thats not right
02:33:56 <dmwit> The fact that fourth_root only calls root once makes me suspicious. =)
02:33:58 <newbie008> thats not taking any fourth root
02:34:02 <newbie008> hold on lol
02:38:37 <krainboltgreene> #join #haskell-bleh
02:38:40 <krainboltgreene> Bah.
02:41:39 <jesusabdullah> wat
02:45:23 <nus> newbie008, you might find /msg 'ing lambdabot with one-liners convenient
02:45:56 <newbie008> nus: thanks but i'm using notepad++ with ghc on the backend :)
02:46:05 <newbie008> not used to repls
02:46:34 <dmwit> No time like the present to get used to them. =)
02:48:37 <nus> newbie008, you're manually doing (>>=) 'tween your editor and ghc, while a ghci is a ready made one.
02:50:10 <nus> (I bet it's keyboard shortcuts dependence)
02:51:31 <krainboltgreene> http://www.planeterlang.org/en/planet/article/How_to_Think_Like_a_Pioneer/
02:51:47 <krainboltgreene> Woops, wrong window.
02:51:52 * krainboltgreene really hating xchat.
02:59:20 <newbie008> dmwit: ok here's the thing
02:59:41 <newbie008> dmwit: i can't do it in haskell because i'm not proficient in it, i keep getting silly errors that wont let me proceed
02:59:56 <newbie008> dmwit: but i can make it in Lua even though Lua doesnt have =<<
03:00:01 <newbie008> dmwit: but i made my own =<<
03:00:26 <nus> what does a Lua (=<<) look like?
03:00:43 <newbie008> i'm pasting it now
03:03:04 <newbie008> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25509#a25509
03:03:18 <newbie008> so i can understand the principle behind it
03:03:23 <newbie008> i just can't do it in haskell
03:03:28 <newbie008> dmwit: would you take a look at it?
03:03:49 <dmwit> sorry, yes
03:03:52 <newbie008> my equalLessLess is a function of type [a] -> (a -> [b]) -> [b]
03:03:54 <dmwit> I was doing something else, one second.
03:03:57 <newbie008> what you had told me to do before
03:03:58 <newbie008> ok
03:04:54 <dmwit> Yes, this looks great!
03:05:07 <newbie008> but see, i can probably try to implement the real =<< later
03:05:09 <dmwit> I don't know Lua, so I don't know for sure, but that looks fine.
03:05:17 <Fanael> Hmmm, equalLessLess is actually (>>=) rather than (=<<).
03:05:20 <newbie008> it's possible i think because Lua does have first class functions
03:05:24 <dmwit> Fanael: That's okay.
03:05:29 <newbie008> Fanael: hahah really??
03:05:44 <dmwit> Okay!
03:05:48 <newbie008> but it doesnt return a function though
03:05:52 <dmwit> So now you know what (>>=) does.
03:05:54 <newbie008> it just does the job itself
03:05:58 <newbie008> yes i understand it
03:06:10 <Fanael> Yes. And it's okay, since (=<<) is simply "flip (>>=)".
03:06:15 <dmwit> :t join . fmap
03:06:16 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
03:06:17 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
03:06:17 <lambdabot>     In the second argument of `(.)', namely `fmap'
03:06:25 <dmwit> :t \f x -> join (fmap f x)
03:06:27 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a -> m a1) -> m a -> m a1
03:06:31 <dmwit> In particular...
03:06:46 <dmwit> :t \f x -> concat (map f x) -- where concat is join for [], and map is fmap for []
03:06:47 <lambdabot> forall a a1. (a -> [a1]) -> [a] -> [a1]
03:06:58 <newbie008> :t flip
03:06:59 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
03:07:02 <newbie008> > :t flip
03:07:03 <lambdabot>   <no location info>: parse error on input `:'
03:07:08 <newbie008> > :t flip
03:07:09 <lambdabot>   <no location info>: parse error on input `:'
03:07:18 <dmwit> No "> " before ":t".
03:07:44 <Fanael> newbie008: flip :: (a -> b -> c) -> b -> a -> c
03:07:45 <newbie008> :t flip
03:07:46 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
03:07:55 <dmwit> :t Prelude.flip
03:07:57 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
03:08:33 <newbie008> lemme try one thing before we continue
03:08:40 <dmwit> newbie008: So, are you ready to figure out how sequence [[3], [1, 2]] gets to where it's going?
03:08:44 <dmwit> oh, okay
03:08:48 <newbie008> almost, hold on
03:10:27 <newbie008> dmwit:  okay lets go, i'll try to implement the proper =<< in Lua later as an exercise
03:10:40 <dmwit> Oh, it's easy.
03:10:45 <dmwit> Just switch the order of the arguments a and ab.
03:11:02 <dmwit> anyway.
03:11:06 <dmwit> Let's start here:
03:11:18 <dmwit> do { x <- [3]; y <- [1, 2]; return [x, y] }
03:11:27 <dmwit> This is just syntax sugar for
03:11:43 <dmwit> [3] >>= \x -> [1, 2] >>= \y -> return [x, y]
03:12:22 <newbie008> hmm that's deep
03:12:33 <newbie008> i'll have to draw some stuff to understand that
03:12:39 <dmwit> oh?
03:12:43 <dmwit> oh no, hold on
03:12:46 <dmwit> Let me back up.
03:12:47 <newbie008> oh ok
03:12:57 <dmwit> There's nothing deep here; this is a totally mechanical translation.
03:13:06 <dmwit> You know about lambdas/anonymous functions, right?
03:13:13 <newbie008> yes :)
03:13:16 <dmwit> okay
03:13:25 <newbie008> i know the \x notation
03:13:47 <dmwit> Then, the above two lines are just two different ways of writing the same thing. If you write the "do" version, then GHC will convert it to the (>>=) version behind your back.
03:14:00 <dmwit> It's a totally mechanical and mostly boring transformation; that's not the important part.
03:14:11 <dmwit> We're just trying to get it into a form we can start evaluating.
03:14:15 <newbie008> okay what's the important part?
03:14:19 <newbie008> ok
03:14:27 <dmwit> Now, remember that (>>=) is
03:14:31 <newbie008> oh i thought i'd have to draw the evaluation, that's what i meant
03:14:36 <dmwit> \f x -> join (fmap f x)
03:14:36 <dmwit> or
03:14:41 <dmwit> \f x -> concat (map f x)
03:14:42 <dmwit> or
03:14:45 <dmwit> concatMap
03:14:54 <newbie008> ok
03:15:06 <dmwit> so, rewriting the above:
03:15:17 <dmwit> [3] >>= \x -> [1, 2] >>= \y -> return [x, y]
03:15:21 <dmwit> in concatMap form, that's:
03:15:30 <Fanael> dmwit: (>>=) is flip concatMap, not concatMap
03:15:39 <dmwit> concatMap (\x -> concatMap (\y -> return [x, y]) [1, 2]) [3]
03:15:46 <dmwit> Fanael: You're right again, of course.
03:16:03 <dmwit> newbie008: Can you see how we got from the (>>=) version to the concatMap version?
03:16:20 <newbie008> *loooking at them*
03:17:16 <newbie008> should there be two concatMap's since there were two >>= before?
03:17:35 <dmwit> yep
03:17:40 <dmwit> And there are two, right? =)
03:17:51 <newbie008> oh i see now
03:18:09 <newbie008> OH
03:18:10 <newbie008> hahahah
03:18:12 <newbie008> i can see it now
03:18:17 <dmwit> great
03:18:27 <dmwit> Alright, one more thing to translate.
03:18:33 <dmwit> Do you remember the definition of "return" for lists?
03:20:25 <newbie008> yes, i think. it returns what you pass to it as a list
03:20:36 <dmwit> right
03:20:43 <dmwit> so let's simplify that in the middle
03:20:58 <dmwit> concatMap (\x -> concatMap (\y -> [[x, y]]) [1, 2]) [3]
03:21:13 <newbie008> okay, straightforward
03:21:30 <dmwit> concatMap f [x, y, z] = concat [f x, f y, f z] -- do you believe this?
03:21:52 <newbie008> yes that's very easy to understand
03:21:59 <newbie008> i got it already
03:22:09 <dmwit> Okay, so using that equation, ...
03:22:12 <newbie008> the y is a lambda that builds the lists within the list that it'll return
03:22:33 <dmwit> [(\x -> concatMap (\y -> [[x, y]]) [1, 2]) 3]
03:22:43 <dmwit> hmm, yup!
03:23:01 <dmwit> [concatMap (\y -> [[3, y]]) [1, 2]]
03:23:18 <dmwit> whoops, lost a concat =P
03:23:29 <dmwit> concat [concatMap (\y -> [[3, y]]) [1, 2]]
03:23:35 <dmwit> Using the same equation as before...
03:23:56 <dmwit> concat [concat [(\y -> [[3, y]]) 1, (\y -> [[3, y]]) 2]]
03:24:20 <newbie008> wow that's awesome
03:24:23 <newbie008> i'm following ya
03:24:40 <dmwit> concat [concat [[[3, 1]], [[3, 2]]]]
03:24:53 <newbie008> then concat [ [[[3,1]], [[3,2]] ]
03:24:56 <newbie008> yeah that
03:25:11 <dmwit> concat [concat [[3, 1], [3, 2]]]
03:25:52 <dmwit> whoops
03:25:53 <dmwit> I mean
03:26:02 <dmwit> concat [[[3, 1], [3, 2]]]
03:26:10 <dmwit> which is, finally,
03:26:14 <dmwit> [[3, 1], [3, 2]]
03:26:20 <dmwit> phew!
03:26:28 <newbie008> i got it sir
03:26:32 <newbie008> my question for you now is
03:27:01 <Fanael> ?src ((->) r) (>>=)
03:27:02 <lambdabot> Source not found. Maybe if you used more than just two fingers...
03:27:10 <dmwit> ?src (->) (>>=)
03:27:10 <lambdabot> f >>= k = \ r -> k (f r) r
03:28:03 <newbie008> is there a tool that i can feed it "sequence [[3], [1,2]]" and get all the steps until the end of the evaluation where it becomes [[3,1],[3,2]] ?
03:28:23 <dmwit> huh
03:28:31 <dmwit> Well, yes, actually!
03:28:36 <dmwit> ghci just recently got a debugger.
03:28:54 <newbie008> so if i just downloaded the very latest ghci i should have it?
03:28:59 <dmwit> yes
03:29:19 <newbie008> is there a certain command or switch i haveto type to enable that?
03:29:36 <dmwit> nope
03:29:40 <dmwit> But you should read the documentation on it.
03:29:46 <Saizan> :trace , no?
03:30:03 <dmwit> :break first
03:30:06 <dmwit> then :trace
03:30:30 <newbie008> ahh that's nice
03:30:34 <newbie008> i'll make sure to get it
03:30:46 <newbie008> i'm saving this conversation because i want to study what we just did
03:31:45 <Saizan> @src sequence
03:31:46 <lambdabot> sequence []     = return []
03:31:46 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:31:46 <lambdabot> --OR
03:31:46 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
03:31:47 <newbie008> now just to finish up
03:31:58 <newbie008> dmwit: since the whole point of this was about monads
03:32:14 <dmwit> Actually, the debugger doesn't seem all that useful here.
03:32:14 <newbie008> dmwit: the =<< was the monad that helped us achieve all this?
03:32:41 <dmwit> dmwit: The list type constructor [] is the monad; return and (=<<) are the functions that witness the fact that it is a monad.
03:33:06 <newbie008> dmwit: quit talking to yourself!  :P
03:33:15 <dmwit> heh, whoops
03:33:22 <dmwit> Well, it is 0630 here.
03:33:29 <dmwit> I think I can be excused for being a little bit loopy.
03:33:39 <nus> :t (,)
03:33:40 <lambdabot> forall a b. a -> b -> (a, b)
03:33:45 <newbie008> 5:33 here but that's my time to be up 'cause i work overnights
03:33:46 <nus> :t (->) (>>=)
03:33:47 <lambdabot> parse error on input `->'
03:33:51 <nus> errh
03:34:01 <nus> @src (->) (>>=)
03:34:01 <lambdabot> f >>= k = \ r -> k (f r) r
03:34:15 <newbie008> dmwit: so the list type is a monad
03:34:21 <dmwit> :t \f k r -> k (f r) r
03:34:22 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t -> t2) -> t -> t2
03:34:25 <newbie008> dmwit: and that fact allows me to use its properties
03:34:29 <newbie008> dmwit: as a monad
03:34:32 <dmwit> newbie008: yup!
03:34:36 <newbie008> dmwit: to save some typing
03:34:43 <dmwit> Yes, exactly.
03:35:13 <dmwit> If by "typing" you mean "keyboarding" rather than "checking the type of a value". ;-)
03:35:48 <newbie008> dmwit: or in other words, on the example about the root(root(x)) that couldn't be done, one could say that monads allow you to accomplish basically that even though the types are different
03:36:10 <newbie008> dmwit: monads allow the programmer to tell the program something along the lines of "you know what i mean, make it work"
03:36:11 <dmwit> Yes!
03:36:52 <newbie008> "of course i know root() can't take the result of another "root" function call but you know what i mean"
03:37:17 <dmwit> Various monads let you combine types that are "almost alike" in different ways. That is one fine way of thinking of monads.
03:37:34 <dmwit> There are several other fine ways, too.
03:37:40 <newbie008> that is really cool
03:37:42 <dmwit> Likely as many fine ways as there are fine people. =)
03:37:44 <Botje> heh. time for a "monads are DWIM" tutorial
03:37:55 <nus> dmwit, what I was getting at is something like :t [,]
03:38:13 <dmwit> :t \x y -> [x, y] -- ?
03:38:15 <lambdabot> forall t. t -> t -> [t]
03:38:31 <newbie008> so what other example eays can monads be thought of besides "combining things that are almost alike and simply have the compiler understand what i mean" ?
03:38:58 <silver> buritos?
03:39:28 <dmwit> I like to think of monads as building trees of expressions. Some people like thinking of them as boxes containing a value, or as computations that eventually return a value, or as spacesuits and toxic waste.
03:40:22 <dmwit> Still others are so steeped in category theory that they can sensibly think of them as a monoidal endofunctor...
03:40:30 <newbie008> i can understand the "trees of expressions" way of thinking, because having just done the Lua version of =<< (or almost) I can see how monads do those things for us
03:40:37 <newbie008> is that how you mean it?
03:41:01 <dmwit> I'm not sure. What you said is sufficiently vague that I can't tell whether we're thinking the same thing.
03:41:44 <dmwit> But the way I think of it, each (>>=) is a branch in the expression tree.
03:42:14 <dmwit> At the leaves are atomic actions -- [3] or [1, 2] in the case of the list monad, or putChar 'c' in the IO monad, or put in the State monad, etc.
03:43:11 <dmwit> Then later, there's an interpreter that crawls the tree and does... well... something.
03:43:18 <dmwit> What that something is depends on which monad is involved. =)
03:43:44 <newbie008> oh then that's not what i'm thinking \ i'm not thinking of the computation of monads as trees \ i was simply thinking that monads do the "adaptation" coding for us -> instead of my having to adapt root() to be able to take another root()'s returned value, i can just use a monad to do that for me
03:44:02 <dmwit> I'm going to go to bed, but a good exercise for you is to think about the Maybe type.
03:44:14 <dmwit> You can think of "Nothing" as a null pointer, and "Just" as a non-null pointer.
03:44:41 <dmwit> With that intuition, try writing a few functions that could reasonably return null, and then chain them together.
03:44:45 <Botje> but what about Just Nothing! *ducks*
03:44:56 <dmwit> Botje: A non-null pointer to null. easy!
03:45:02 <Botje> :)
03:45:37 <dmwit> When you get tired of writing lots of case statements, see if you can come up with a nicer way to chain them... and see if it looks familiar. =)
03:46:00 <dmwit> ?go you could have invented monads and maybe you already have
03:46:01 <lambdabot> Maybe you meant: google googleit do
03:46:05 <dmwit> ?google you could have invented monads and maybe you already have
03:46:06 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
03:46:06 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
03:46:20 <dmwit> ^^ my favorite explanation of monads; you might like it, too
03:46:27 <dmwit> see ya!
03:46:29 <Saizan> newbie008: seeing monads as a way to glue together functions that don't immediately compose is a pretty good mental model
03:47:25 <Saizan> each monad will be able to glue only some kind of functions, that's why you need many
03:47:59 <newbie008> dmwit: hey
03:48:03 <Botje> bye dmwit!
03:48:10 <newbie008> dmwit: dont go just yet, lemme show you just one thing i just finished
03:48:17 <dmwit> k =)
03:48:38 * hackagebot xmobar 0.10 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.10 (AndreaRossato)
03:48:40 <newbie008> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25510#a25510
03:48:43 <nus> :t \x y -> x:y
03:48:44 <lambdabot> forall a. a -> [a] -> [a]
03:49:18 <Botje> nus: that's usually just written (:)
03:49:31 <nus> yeah, but
03:49:35 <newbie008> dmwit: i'll do what you said, thanks a lot for the help!
03:49:37 <nus> @src (->) (>>=)
03:49:38 <lambdabot> f >>= k = \ r -> k (f r) r
03:49:43 <nus> Botje, ^^
03:50:02 <nus> and (:) being one
03:50:06 <newbie008> Saizan: that's how i see monads now
03:50:21 <newbie008> Saizan: a way of mixing functions that dont mix but should :)
03:50:40 <newbie008> dmwit: did you see the code?
03:50:51 <dmwit> Yep, looks nice.
03:50:59 <newbie008> dmwit: and it works fine too :)
03:51:12 <newbie008> dmwit: i'll study this, i just got the haskell school of expression book
03:51:20 <newbie008> dmwit: you've helped me a lot, i appreciate it
03:51:24 <newbie008> dmwit: now go to bed!
03:51:56 <newbie008> Saizan: you know what i'm just thinking is cool?
03:52:00 <newbie008> Saizan: and correct me if i'm wrong
03:52:20 <newbie008> Saizan: i can implement monads in any language that supports first-class functions
03:52:25 <newbie008> Saizan: isn't that true?
03:52:56 <Saizan> newbie008: yeah, though they might not be as nice to use
03:53:21 <nus> newbie008, first-class functions are usually implemented as closures, some ooish-languages call them functors
03:53:35 <Saizan> typeclasses help because they pick the right implementation for (>>=) and return just by looking at the types
03:53:41 <newbie008> Saizan: but did you see my Lua code i just wrote? it works just the same as the =<< operator , although my version is not an operator but a function
03:54:40 <newbie008> nus, Lua supports both first-class functions and closures but one is not implemented because of the other
03:54:56 <newbie008> nus, i think
03:55:06 <nus> newbie008, monads allow you nested value capture and nested side-effects
03:55:43 <Saizan> newbie008: i'm not sure what that lua code is doing, but it's supposed to only implement the list monad, right?
03:55:51 <newbie008> nus: can you exemplify that "nested value capture" bit?
03:56:02 <newbie008> Saizan: right
03:56:10 <newbie008> Saizan: and it implements =<< so that it works on lists
03:56:36 <newbie008> Saizan: Lua's code should be straightforward to read
03:56:45 <newbie008> Saizan: i mean, i just started learning Lua 3 days ago
03:57:15 <newbie008> Saizan: having only read half of chapter 13 of the Programming in Lua online book Lol
03:57:27 <Saizan> i don't get "for _,v in pairs(listA) do table.insert(result, functionAtoB(v)) end"
03:57:32 <nus> newbie008, what's a closure for you?
03:57:47 <Saizan> nus: aren't closures just an implementation detail?
03:58:18 <Saizan> i mean, why are they relevant here?
03:58:20 <nus> Saizan, people coming from a strict FL think first in them
03:58:50 <newbie008> Saizan: in Lua the only data structure there is are tables. there are no arrays etc. so for _,v in pairs(listA) is basically traversing the table. that table is much like a dictionary so if i say _,v that means k,v (as in key,value) but also means i'm not interested in the key, so i'm not naming it
03:59:32 <newbie008> Saizan: do table.insert(result, functionAtoB(v) --> means put every funtionAtoB(v) return value into my "result" list
03:59:41 <newbie008> nus: a closure to me is
03:59:59 <newbie008> nus: when i'm nested twice and can access the values from the outer scope, for instance
04:00:07 <newbie008> nus: but in a persistent way
04:00:22 <Saizan> newbie008: then it looks like it's not an implementation of =<<
04:00:32 <newbie008> Saizan: how so?
04:01:12 <Saizan> newbie008: the second argument is the list you should iterate over
04:02:11 <newbie008> Saizan: you mean to say equalLessLess should take two arguments, the function and the list?
04:02:14 <Saizan> what you implemented there is more like \aTob value -> aTob =<< aTob value -- which doesn't even have the right type :)
04:02:21 <newbie008> Saizan: in that case then this is the correct code:
04:02:23 <newbie008> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25509#a25509
04:03:20 <Saizan> newbie008: that's defining >>=, i.e. with the arguments flipped, but yeah
04:03:48 <newbie008> Saizan: so if i just flip the arguments, it will be exactly =<< ?
04:04:22 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25510#a25511 <- this would also be correct, i think, and curried
04:04:50 <Saizan> no, wait
04:04:54 <Saizan> you lack a concat part
04:05:41 <newbie008> Saizan: wow that's exactly what i had before i came up with my version
04:05:50 <Saizan> newbie008: is there something like table.append?
04:06:06 <newbie008> Saizan: but with your version, instead of calling res = fourth_root_proper(16) you have to do res = fourth_root_proper(root(16))
04:06:33 <newbie008> Saizan: it's the same as table.insert, puts it in the end
04:07:07 <Saizan> newbie008: you need something that given two tables produces a new table with the elements of both
04:07:14 <newbie008> table.concat
04:07:26 <Saizan> then use that instead of .insert
04:07:33 <Saizan> and you'd have something like =<< :)
04:07:39 <newbie008> Saizan: oh i got it!
04:08:12 <newbie008> so i should modify this version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25510#a25511  to use concat?
04:08:26 <Saizan> yep
04:09:14 <newbie008> Saizan: ok lemme try
04:09:15 <nus> uhh, Lua tables are one-way linked lists?
04:12:09 <newbie008> nus: i'm not really sure, i just started coding in it, but to me they look like dictionaries
04:12:28 <newbie008> nus: i'm sure they're not linked lists though
04:12:33 <nus> newbie008, which dictionaries, Python?
04:12:35 <newbie008> nus: because given one element you can't go to the next
04:12:45 <newbie008> nus: dictionaries like a hash table
04:13:04 <newbie008> nus: not familiar with the python implementation of dictionaries
04:13:17 <nus> oh, hash maps
04:13:21 <newbie008> nus: dictionaries as in { key1 = value1, key2 = value2, etc}
04:13:38 <nus> newbie008, that could be implemented in a million ways
04:13:54 <newbie008> nus: agreed
04:14:00 <newbie008> nus: what's your specific question then ?
04:14:09 <newbie008> nus: do you want to know if something is doable or not?
04:14:50 <nus> there's no 'end' in a hash map
04:17:06 <nus> oh, http://www.lua.org/manual/5.1/manual.html#2.5.7
04:17:10 <nus> heh
04:17:36 <nus> they're monads (-:
04:19:02 <newbie008> nus: how do you figure?
04:19:30 <nus> newbie008, look at the table constructor syntax ^^^
04:20:30 <Saizan> nus: so?
04:21:19 <Saizan> there doesn't seem to be anything that could work like concatMap or "<-" there.
04:24:07 <nus> Saizan, read about metatables, also
04:26:51 <newbie008> Saizan: take a look at my new =<< -------->    http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25510#a25513
04:27:03 <newbie008> Saizan: turns out table.concat is not what we wanted
04:27:19 <newbie008> Saizan: i have put more comments now
04:28:06 <Saizan> newbie008: that looks right
04:28:24 <newbie008> Saizan: awesome!!
04:28:33 <newbie008> Saizan: so is that =<< or >>=  ??
04:29:23 <Saizan> =<<, because it takes the function first
04:29:51 <StarFire> Hmm, c2hs seems to be somewhat broken, at least on Windows.
04:30:04 <aristid> @pl f x y = if x then Just y else Nothing
04:30:04 <lambdabot> f = flip flip Nothing . (. Just) . if'
04:30:06 <newbie008> StarFire: thank you
04:30:14 <Saizan> StarFire: wrt spaces in paths?
04:30:15 <newbie008> Saizan: thank you for the help :)
04:30:32 <StarFire> Saizan: I'm getting a "The character '#' does not fit here."
04:30:42 <newbie008> ?src Maybe
04:30:42 <lambdabot> data Maybe a = Nothing | Just a
04:30:53 <newbie008> ?src Nothing
04:30:53 <lambdabot> Source not found. Are you on drugs?
04:31:03 <newbie008> ?src Just
04:31:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:31:10 <newbie008> :t Nothing
04:31:10 <StarFire> The same chs file worked earlier (previous Haskell Platform), and as far as I can tell, there are no spaces in the paths.
04:31:11 <lambdabot> forall a. Maybe a
04:31:15 <Saizan> the line above is what defines Nothing and Just
04:31:19 <sepp2k> @src Maybe
04:31:19 <lambdabot> data Maybe a = Nothing | Just a
04:31:29 <newbie008> Saizan: oh ok
04:31:34 <aristid> :t flip flip
04:31:35 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
04:31:43 <newbie008> Saizan: so Nothing is defined on the linethat defines Maybe ?
04:32:01 <sepp2k> newbie008: Yes.
04:32:02 <Fanael> :t Prelude.flip Prelude.flip
04:32:03 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
04:32:10 <Saizan> newbie008: yeah, a data declarations defines a type and its data constructors
04:32:45 <newbie008> Saizan: sepp2k: so what does Nothing | Just a is really doing? I'd like to try and implement Maybe in Lua
04:33:11 <newbie008> is | simply the binary OR ? can't be...
04:34:39 <sepp2k> newbie008: It means "A value of type Maybe a is either the constant Nothing or Just x where x is a value of type a".
04:35:42 <sepp2k> So it defines the constant (nullary constructor) Nothing of type Maybe a (for all a) and the unary constructor Just, which creates a value of type Maybe a when given an argument of type a.
04:35:48 <newbie008> sepp2k: right, but what does "either" in your explanation mean? how does it get evaluated? how does it decide whether it'll be Nothing or Just x ?
04:36:03 <aristid> is there a nicer way to write if x then Just y else Nothing?
04:36:20 <aristid> unfortunately @pl only found an ugly way
04:36:38 <aristid> @djinn Bool -> a -> Maybe a
04:36:39 <lambdabot> f a b =
04:36:39 <lambdabot>     case a of
04:36:39 <lambdabot>     False -> Nothing
04:36:39 <lambdabot>     True -> Just b
04:36:47 <roconnor> aristid: probably, can you give more context
04:36:48 <sepp2k> newbie008: Huh? A type definition is not executable code. Nothing gets evaluated there.
04:37:08 <roconnor> aristid: some use of guard will work
04:37:17 <sepp2k> newbie008: When you create a value of type Maybe it knows whether it's Just or Nothing, because it knows whether you wrote Just or Nothing.
04:37:20 <roconnor> aristid: : guard x >> return y
04:37:28 <nus> newbie008, Lua table constructor syntax already allows you 'local result = {}'. If you're into comparative linguistics think about how that's related to monads.
04:37:30 <aristid> @src guard
04:37:30 <lambdabot> guard True  =  return ()
04:37:31 <lambdabot> guard False =  mzero
04:37:47 <newbie008> sepp2k: hmm...
04:37:49 <aristid> roconnor: using Maybe as a MonadPlus?
04:37:53 <roconnor> yes
04:38:07 <newbie008> nus: do you mean that in relation to what i did in my code?
04:38:08 <aristid> roconnor: looks interesting
04:38:25 <roconnor> but you probably really want to do guard x >> some code
04:38:34 <roconnor> and probably want it in a do block
04:38:39 <sepp2k> newbie008: In other words: There are two ways to create values of type Maybe a. One is to use the constant Nothing, the other is to use Just with an argument of type a.
04:38:39 <nus> newbie008, how to rewrite your code more Lua-idiomatish
04:38:52 <newbie008> nus: ok, i'd like to see that
04:39:00 <newbie008> nus: would you care to add to that paste?
04:39:00 <aristid> roconnor: i'm pondering how to implement Data.List.lookup in a beautiful way
04:39:10 <newbie008> nus: add a revision
04:39:14 <roconnor> @src lookup
04:39:15 <lambdabot> lookup _key []          =  Nothing
04:39:15 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
04:39:15 <lambdabot>                         | otherwise = lookup key xys
04:39:33 <aristid> that's explicit recursion! the devil!
04:40:01 <roconnor> @type foldM
04:40:02 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:40:32 <aristid> roconnor: that's roughly how i was thinking, though i was thinking scanl not foldM
04:40:54 <aristid> oh, scanl is stupid
04:41:12 <aristid> i guess i confused scanl and foldr?
04:41:27 <aristid> @src foldr
04:41:27 <lambdabot> foldr f z []     = z
04:41:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:41:31 <aristid> @src foldl
04:41:31 <lambdabot> foldl f z []     = z
04:41:31 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:42:14 <aristid> @src foldM
04:42:15 <lambdabot> foldM _ a []     = return a
04:42:15 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
04:42:19 <roconnor> @type \c l -> map ((x,y) -> guard (x=c) >> return y) l
04:42:20 <lambdabot> parse error on input `='
04:42:24 <roconnor> @type \c l -> map ((x,y) -> guard (x==c) >> return y) l
04:42:25 <lambdabot>     Pattern syntax in expression context:
04:42:25 <lambdabot>         (x, y) -> guard (x == c) >> return y
04:42:31 <roconnor> @type \c l -> map (\(x,y) -> guard (x==c) >> return y) l
04:42:32 <lambdabot> forall t t1 (m :: * -> *). (Eq t, MonadPlus m) => t -> [(t, t1)] -> [m t1]
04:42:43 <newbie008> nus: did you do it?
04:42:45 <roconnor> @type \c l -> mapM (\(x,y) -> guard (x==c) >> return y) l
04:42:46 <lambdabot> forall t t1 (m :: * -> *). (Eq t, MonadPlus m) => t -> [(t, t1)] -> m [t1]
04:42:52 <nus> newbie008, I believe that'd take out all the fun of finding parallels yourself.
04:43:04 <roconnor> er nope
04:43:10 <roconnor> bad
04:43:15 <newbie008> nus: do just one example so that i see what you mean better
04:43:32 <roconnor> @type foldM
04:43:33 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:44:00 <roconnor> nope
04:44:03 <roconnor> foldM is no good either
04:44:34 <ski> (good for what ?)
04:44:49 <roconnor> @type \c l -> map (\(x,y) -> guard (x==c) >> return y) l
04:44:50 <lambdabot> forall t t1 (m :: * -> *). (Eq t, MonadPlus m) => t -> [(t, t1)] -> [m t1]
04:44:52 <roconnor> @type first
04:44:54 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
04:44:57 <roconnor> @type First
04:44:58 <lambdabot> forall a. Maybe a -> First a
04:45:09 <roconnor> @src First
04:45:10 <lambdabot> Source not found. It can only be attributed to human error.
04:45:18 <roconnor> @type runFirst
04:45:19 <lambdabot> Not in scope: `runFirst'
04:45:21 <roconnor> @type unFirst
04:45:22 <lambdabot> Not in scope: `unFirst'
04:45:25 <ski> @type getFirst
04:45:26 <lambdabot> forall a. First a -> Maybe a
04:45:43 <ski>   newtype First a = First {getFirst :: Maybe a}  -- i think
04:45:56 <roconnor> @type \c l -> getFirst . msum . map (\(x,y) -> guard (x==c) >> return y) $ l
04:45:57 <lambdabot>     No instance for (MonadPlus First)
04:45:58 <lambdabot>       arising from a use of `msum' at <interactive>:1:19-22
04:45:58 <lambdabot>     Possible fix: add an instance declaration for (MonadPlus First)
04:46:10 <aristid> roconnor: First was Monoid iirc
04:46:10 <roconnor> @type \c l -> getFirst . msum . map (\(x,y) -> First (guard (x==c) >> return y)) $ l
04:46:11 <lambdabot>     No instance for (MonadPlus First)
04:46:12 <lambdabot>       arising from a use of `msum' at <interactive>:1:19-22
04:46:12 <lambdabot>     Possible fix: add an instance declaration for (MonadPlus First)
04:46:24 <roconnor> @type msum
04:46:25 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
04:46:31 <roconnor> @type \c l -> getFirst . mconcat . map (\(x,y) -> First (guard (x==c) >> return y)) $ l
04:46:32 <lambdabot> forall a t. (Eq t) => t -> [(t, a)] -> Maybe a
04:46:40 <ski> probably `First' should be in `Monad' and `MonadPlus', as well
04:46:41 <roconnor> @type \c l -> getFirst . mconcat . map (\(x,y) -> guard (x==c) >> return y) $ l
04:46:43 <lambdabot>     No instance for (MonadPlus First)
04:46:43 <lambdabot>       arising from a use of `guard' at <interactive>:1:44-55
04:46:43 <lambdabot>     Possible fix: add an instance declaration for (MonadPlus First)
04:46:51 <ski> s/should be/ought to be/
04:46:55 <roconnor> @type \c l -> getFirst . mconcat . map (\(x,y) -> First (guard (x==c) >> return y)) $ l  -- my solution
04:46:57 <lambdabot> forall a t. (Eq t) => t -> [(t, a)] -> Maybe a
04:47:41 <roconnor> @pl (\(x,y) -> First (guard (x==c) >> return y)
04:47:41 <lambdabot> (line 1, column 44):
04:47:42 <lambdabot> unexpected end of input
04:47:42 <lambdabot> expecting variable, "(", operator or ")"
04:47:45 <roconnor> @pl (\(x,y) -> First (guard (x==c) >> return y))
04:47:45 <lambdabot> uncurry ((First .) . (. return) . (>>) . guard . (c ==))
04:48:06 <roconnor> almost readable
04:48:46 <aristid> :t mapM
04:48:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:49:14 <roconnor> wait does msum work here?
04:49:26 <roconnor> > msum [Nothing, Just 3, Nothing]
04:49:27 <lambdabot>   Just 3
04:49:33 <roconnor> duh
04:49:48 <roconnor> @type \c l -> msum . map (\(x,y) -> guard (x==c) >> return y) $ l  -- my solution
04:49:49 <lambdabot> forall (m :: * -> *) a t. (MonadPlus m, Eq t) => t -> [(t, a)] -> m a
04:50:26 <aristid> roconnor: i got another solution, wait a second
04:50:43 <roconnor> @type \c -> msum . map (\(x,y) -> guard (x==c) >> return y)  -- my solution
04:50:44 <lambdabot> forall (m :: * -> *) a t. (MonadPlus m, Eq t) => t -> [(t, a)] -> m a
04:53:30 <aristid> roconnor: let myLookup k = msum . (map (\(k', v) -> guard (k == k') >> return v))
04:53:51 <roconnor> aristid: I like it
04:54:00 <aristid> thanks!
04:54:13 <aristid> can we improve it further? :D
04:54:28 <ski> `flip' it ?
04:54:40 <roconnor> @type lookUp
04:54:41 <lambdabot> Not in scope: `lookUp'
04:54:44 <roconnor> @type lookup
04:54:45 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
04:55:26 <aristid> roconnor: mine even works with lists
04:55:46 <aristid> myLookup "a" [("a",1), ("a",2)] :: [Int] => [1,2]
04:55:48 <ski> `(MonadPlus m,Eq k) => [(k,v)] -> (k -> m v)' sounds more reasonable, to me
04:56:14 <roconnor> @type (=<<)
04:56:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
04:58:20 <aristid> @pl f x y = x >> return y
04:58:21 <lambdabot> f = (. return) . (>>)
04:59:27 <ski> @type \kvs k0 -> do (k,v) <- foldr (mplus . return) mzero kvs; guard (k0 == k); return v
04:59:28 <lambdabot> forall (m :: * -> *) b a. (MonadPlus m, Eq a) => [(a, b)] -> a -> m b
04:59:55 <ski> @type foldr (mplus . return) mzero  -- maybe this already exists ?
04:59:56 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
05:00:16 <ski> @hoogle [a] -> m a
05:00:16 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
05:00:17 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
05:00:17 <lambdabot> Data.Sequence fromList :: [a] -> Seq a
05:02:57 <ski> .. maybe a good name for it would be `Control.Monad.listToMonadPlus' ?
05:03:01 * hackagebot ldif 0.0.7 - The LDAP Data Interchange Format (LDIF) parser  http://hackage.haskell.org/package/ldif-0.0.7 (RadoslavDorcik)
05:03:34 <aristid> ski: i think it should be MonadPlus'd only after the guard thing?
05:03:57 <ski> `foldr (mplus . return) mzero' doesn't use `guard'
05:04:22 <ski> (but both `mzero' and `mplus' force it into `MonadPlus')
05:05:16 <portnov> is here an analog of stat (2) in haskell? better if it would be crossplatform...
05:05:34 <portnov> really, i need only to get `last modified' date of file.
05:06:53 <ski> @type \kvs k0 -> do (k,v) | k0 == k1 <- foldr (mplus . return) mzero kvs; return v  -- it might be nice to have this syntax working ?
05:06:54 <lambdabot> parse error on input `|'
05:06:57 <Olathe> > (msum . map return $ [1..5]) :: Maybe Integer
05:06:58 <lambdabot>   Just 1
05:07:31 <ski> (yes, that works as well .. i just preferred to fuse it)
05:07:53 <aristid> ski: huh, [] is already MonadPlus so i guess listToMonadPlus is rather pointless
05:08:38 <ski> aristid : it wouldn't be pointless. what if we want `forall a. [a] -> Foo a', where `Foo' is in `MonadPlus' (but is neither `[]' nor `Maybe') ?
05:09:03 * hackagebot xmobar 0.11 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.11 (AndreaRossato)
05:09:05 <aristid> ski: hm
05:09:24 <ski> (but `listToMonadPlus' when that `Foo' is `[]' is of course just `id', yes)
05:11:08 <aristid> ok, i've made another variant of myLookup and a small test: http://codepad.org/hqoxvRDj
05:11:19 <aristid> should myLookup be total?
05:11:24 <Olathe> > let f [] = mzero; f (x:xs) = mplus (return x) (f xs) in f [1..5] :: Maybe Integer
05:11:25 <lambdabot>   Just 1
05:12:13 <b0fh_ua> Hi! is there some standard function for :: ( a -> k2 ) -> Map k a -> Map k2 a ? I need to create new keys based on the value of map item
05:12:17 <MrFenix> hi, is there a way to define $datadir in a .cabal file?
05:13:05 <ski> aristid : i'd say yes
05:13:13 <aristid> roconnor, ski: it was fun, maybe we can continue this later
05:13:19 <mauke> b0fh_ua: probably not, because that creates a completely new map structure
05:13:29 <MrFenix> b0fh_ua: http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Map.html#v%3AmapKeys
05:14:30 <b0fh_ua> MrFenix: I have to use value - not just key
05:14:32 <ski> @type Data.Map.mapKeys  -- b0fh_ua
05:14:33 <lambdabot> forall k1 k2 a. (Ord k2) => (k1 -> k2) -> M.Map k1 a -> M.Map k2 a
05:14:43 <b0fh_ua> mapKeysWith wouldn
05:14:46 <ski> (i presume that's what you meant)
05:14:46 <b0fh_ua> t work either
05:15:19 <b0fh_ua> ski: the function takes a key and produces another one. I need to take value and produce key.
05:15:24 <ski> (hm, or now on closer look i see you didn't mean that ..)
05:15:37 <ski> hm
05:15:38 <b0fh_ua> MrFenix: so just use elements and insert into new map
05:15:46 <b0fh_ua> may be foldl )
05:16:02 <mauke> :t \f -> M.fold (\x z -> M.insert (f x) z) M.empty
05:16:03 <lambdabot>     Occurs check: cannot construct the infinite type:
05:16:03 <lambdabot>       b = M.Map k b -> M.Map k b
05:16:03 <lambdabot>     Probable cause: `M.insert' is applied to too few arguments
05:16:04 * ski would just extract the elements and create a new map, then
05:16:11 <mauke> :t \f -> M.fold (\x z -> M.insert (f x) x z) M.empty
05:16:12 <lambdabot> forall a k k1. (Ord k) => (a -> k) -> M.Map k1 a -> M.Map k a
05:19:07 <mauke> :t \f -> M.fromList . map ((,) =<< f) . M.elems
05:19:08 <lambdabot> forall k a k1. (Ord k) => (a -> k) -> M.Map k1 a -> M.Map k a
05:19:33 <olsner> aah, syb is awesome... looks like I finally grokked how the magic works
05:21:10 <ski> @type ((,) =<<)
05:21:11 <lambdabot> forall a b. (b -> a) -> b -> (a, b)
05:21:18 <ski> @type graph
05:21:19 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
05:21:23 <olsner> just replaced 40-something lines of boilerplate pattern matching with a syb one-liner
05:21:49 <b0fh_ua> mauke: yup, like this one
05:22:07 <mauke> which one?
05:22:58 <wli> I may have to learn syb.
05:24:12 <tryks> bonjour / hello
05:24:49 <b0fh_ua> mauke: fold (\val nMap -> M.insert ( read ( itemid val ) ) val nMap) M.empty evtMap
05:25:08 <b0fh_ua> seems to work
05:25:51 <mauke> why not M.fromList . map ((,) =<< (read . itemid)) . M.elems $ evtMap?
05:25:52 <ski> are you sure that `read' will not fail on you ?
05:26:09 <olsner> wli: iiuc, the basic thing is just a typeclass that allows generic code to iterate all type constructors of a type, along with a bunch of combinators that allow combining specifics into generics
05:26:53 <b0fh_ua> ski: well, for now there are integers only )
05:27:03 <ski> > read "abc" :: Integer
05:27:04 <lambdabot>   *Exception: Prelude.read: no parse
05:27:55 <b0fh_ua> mauke: well, I'm not quite familiar with such constructions for now
05:28:15 <mauke> which ones?
05:28:26 <mauke> M.fromList/M.elems should be clear
05:28:35 <b0fh_ua> mauke: map one
05:28:37 <b0fh_ua> with (,)
05:28:47 <mauke> (,) x y = (x, y)
05:29:16 <mauke> f =<< g = \x -> f (g x) x
05:29:32 <mauke> (,) =<< f = \x -> (f x, x)
05:30:08 <b0fh_ua> mauke: wow, nice
05:30:47 <mauke> http://mauke.ath.cx/tmp/flow.png
05:32:02 <mauke> > liftM2 h f g x :: Expr
05:32:03 <lambdabot>   Ambiguous type variable `a1' in the constraints:
05:32:03 <lambdabot>    `SimpleReflect.FromExpr...
05:32:06 <mauke> :-(
05:32:31 <mauke> > liftM2 (h :: Expr -> Expr -> Expr) f g x
05:32:32 <lambdabot>   h (f x) (g x)
05:34:08 <b0fh_ua> mauke: probably you could either give some advices of how to simplify that scary and ugly code at: http://github.com/jdevelop/hslj/blob/master/LiveJournal/Post/ListEvent.hs
05:34:19 <b0fh_ua> especially parseResponse function
05:34:44 <mauke> nice, printf
05:35:24 <MrFenix> :t (\ f m -> fromList $ Prelude.map (\x -> (f $ fst x, snd x)) $ toList m)
05:35:25 <lambdabot> Not in scope: `toList'
05:35:39 <MrFenix> :t (\ f m -> Data.Map.fromList $ Prelude.map (\x -> (f $ fst x, snd x)) $ Data.Map.toList m)
05:35:40 <lambdabot> forall b k a. (Ord b) => (k -> b) -> M.Map k a -> M.Map b a
05:37:38 <mauke> github--
05:40:43 <MrFenix> :t (\ f m -> fromList $ Prelude.map (uncurry $ (,) . f) $ toList m)
05:40:44 <lambdabot> Not in scope: `toList'
05:40:57 <MrFenix> :t (\ f m -> Data.Map.fromList $ Prelude.map (uncurry $ (,) . f) $ Data.Map.toList m)
05:40:58 <lambdabot> forall a b a1. (Ord a1) => (a -> a1) -> M.Map a b -> M.Map a1 b
05:41:41 <mauke> b0fh_ua: all I can think of is updateListEvent "security" value evt = case strToSec value of Nothing -> evt; Just s -> evt{ security = s }
05:41:49 <mauke> because fromJust and == Nothing are ugly
05:42:29 <olsner> that ListEvent show instance could be written pointsfree style as liftM10 (printf "...")
05:42:46 <dv-> Is there a GTK/whatever widget for a web-browser engine like webkit or gecko in Haskell?
05:43:30 <MrFenix> dv-: http://github.com/baldo/haskell-webkit
05:43:47 <mauke> b0fh_ua: allowmask'' = fromMaybe 0 allowmask'
05:43:52 <b0fh_ua> olsner: that's out of my expertise for now :(
05:44:10 <dv-> MrFenix: Awesome!
05:44:26 <hamishmack> dv-: ManateeLazyCat added webkit support to gtk2hs
05:44:52 <b0fh_ua> still trying to learn haskell, there're a lot of things remain behind wall of shadows
05:45:18 <dv-> hamishmack: ah? I looked at the docs but couldn't find anything
05:46:39 <hamishmack> It is in darcs version of gtk2hs
05:47:02 <dv-> I will get it, thanks
05:47:06 <hamishmack> might be the same as that version on github
05:47:21 <ski>   updateListEvent "security" = maybe id (\s evt -> evt {security = s}) . strToSec  -- mauke,b0fh_ua ?
05:47:54 <mauke> ski: wrong number of parameters
05:48:36 <ski> are there more equations ?
05:49:07 <mauke> oh, only about 10
05:49:16 * ski notes b0fh_ua gave a link above .. follows
05:50:45 <ski> i would start by making modify wrappers for the fields (possibly using fclabels or data-accessor or something like that)
05:51:24 <olsner> updateListEvent could be Map String (String -> ListEvent -> ListEvent)
05:51:32 <olsner> i.e. map from string to update-function
05:52:07 <ski> is there any reason to prefer that, here ?
05:52:32 <ski> (hm, dynamic modifiability of the list, i suppose)
05:52:39 <ski> (s/list/map/)
05:53:20 <olsner> gets rid of having to duplicate the 'updateListEvent "key" = ' part I guess
05:54:06 * ski doesn't count that as serious duplication
05:55:10 <mauke> updateListEvent s = case s of
05:56:17 <olsner> hmm, a case expression would probably be about the same syntax overhead as the definition of the map (or less) while getting rid of the map lookup :)
05:57:29 <ski> (.. and getting rid of the dynamic checking)
05:59:32 <olsner> if the key is not in the map you'd just not modify the event, just like the fallback case would (and the last equation of the function currently does)
06:00:07 <ski> yes, but using a map enables checking whether the key is in it
06:00:36 <ski> (i'm not sure whether this feature would be desirable/needed in b0fh_ua's case, though. just an observation)
06:01:17 <b0fh_ua> ski: well, even with map there will be still a need to provide some sort of function to update record
06:01:35 <ski> sure
06:01:46 <ski>   modify :: FRef a b -> (b -> b) -> (a -> a)
06:01:49 <ski>   anum,... :: FRef ListEvent String
06:01:58 <b0fh_ua> ouch, FFI
06:02:02 <b0fh_ua> nom not now )
06:02:20 <ski>   updateListEvent "anum" = modify anum . const
06:02:24 <ski>   ...
06:03:26 <ski>   updateListEvent "security" = maybe id (modify security . const) . strToSec
06:05:42 <ski> (here `security :: FRef ListEvent Security', where `strToSec :: String -> Maybe Security)
06:06:11 <ski> b0fh_ua : ^ does that approach look unintelligble to you ?
06:06:48 <b0fh_ua> ski: I simply don't understand it now
06:06:52 <ski> (btw, `modify foo . const' could probably be replaced with `set foo' or `flip (set foo)')
06:06:59 <ski> ok
06:07:11 <Fanael> @djinn (((a -> b -> c) -> b -> a -> c) -> d) -> d
06:07:11 <lambdabot> f a = a (\ b c d -> b d c)
06:07:49 <ski> @type ($ Prelude.flip)  -- Fanael
06:07:50 <lambdabot> forall b a b1 c. (((a -> b1 -> c) -> b1 -> a -> c) -> b) -> b
06:08:59 <ski> @. pl djinn (((a -> b -> c) -> b -> a -> c) -> d) -> d
06:08:59 <lambdabot> f = ($ flip)
06:09:42 <b0fh_ua> ski: data-accessor package
06:09:46 <Fanael> @. pl djinn b -> (a -> b -> c) -> a -> c
06:09:46 <lambdabot> f = flip flip
06:09:59 <ski> b0fh_ua : yes, or one of the more-or-less-similar ones
06:10:24 * hackagebot hogre 0.0.3 - Haskell binding to a subset of OGRE  http://hackage.haskell.org/package/hogre-0.0.3 (AnttiSalonen)
06:11:24 * hackagebot hogre-examples 0.0.3 - Examples for using Hogre.  http://hackage.haskell.org/package/hogre-examples-0.0.3 (AnttiSalonen)
06:11:26 <b0fh_ua> ski: so will it be correct if I would say that with help of the Accessor I could set properties by the names?
06:12:04 <ski> more or less, yes
06:12:35 <ski> the names `anum',`security',... would be names of the fields, and you can then use set,get,modify operations on them
06:13:04 <b0fh_ua> ski: but that is no "true" record from now?
06:13:17 <ski> (you still have to do the initial boilerplate of defining `anum',&c. to be accessors, though .. unless GHC has recently gained support for doing this itself)
06:13:27 <ski> what do you mean ?
06:13:54 <b0fh_ua> well, the functions like "security evt" will still exist?
06:14:21 <ski> you can still use the same "record" type for `ListEvent' (though probably renaming the actual primitive fields from `anum' to `getAnum',&c. for clarity)
06:14:52 <ski> instead of `security evt' you will say `get security evt' (or something similar .. i don't recall the actual data-accessor syntax)
06:15:13 <b0fh_ua> okay
06:16:51 <ski> looking at it, it appears you can say either `getVal security evt' or `evt ^. security' (whichever you like)
06:16:55 <Twey> There's TH in Data.Accessor to generate the boilerplate
06:17:04 <ski> ah, ok
06:17:55 <jystic> how do I make lambdabot change a function to point free?
06:18:03 <Twey> There's also get  it just has the arguments the other way around
06:18:05 <Fanael> @pl
06:18:05 <Twey> jystic: @pl
06:18:05 <ski> @pl f x = x
06:18:05 <lambdabot> f = id
06:18:05 <lambdabot> (line 1, column 1):
06:18:05 <lambdabot> unexpected end of input
06:18:05 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
06:18:09 <jystic> thanks
06:18:18 <Twey> What?
06:18:20 <Twey> Oh
06:18:22 <jystic> @pl buildings x = map (map read . words) (lines x)
06:18:22 <Twey> Fanael's 
06:18:22 <lambdabot> buildings = map (map read . words) . lines
06:18:35 <jystic> ahh :)
06:19:03 <ski> Twey : oh, ok. apparently `Basic.get' is a synonym for `getVal'
06:19:25 <Fanael> @pl (\x y -> (+) `id` x `id` y)
06:19:25 <lambdabot> (+)
06:19:35 <Twey> ski: Oh, I lie  the TH is in a separate package, data-accessor-template
06:21:41 <Twey> Urgh, Henning'd
06:22:01 <Twey> type Accessor r a = T r a
06:22:08 <Twey> At least it's wrapped
06:22:31 <ski> b0fh_ua : for completeness, my `FRef' above is `Accessor' (as well as `T'); `modify security' becomes `(security ^:)'; while `modify security . const' becomes `setVal security', alternatively `(security ^=)')
06:23:24 <mauke> your use of ` saddens me
06:23:33 * ski bows
06:23:57 <Twey> Apparently this usage came to be because in some old UNIX fonts, ' looks like a  and ` looks like a 
06:26:20 <Cale> Well, and it was presumably carried forward by the force of TeX :)
06:27:18 <mauke> and m4
06:35:02 <Baughn> > (print *> return) 42
06:35:03 <lambdabot>   No instance for (GHC.Show.Show (m a))
06:35:03 <lambdabot>    arising from a use of `M7569091908...
06:35:13 <Baughn> ..hey, that used to work.
06:35:16 <Baughn> :t (print *> return) 42
06:35:16 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m a
06:35:56 <mauke>  > (print *> return) 42 :: Maybe Integer
06:36:01 <mauke> > (print *> return) 42 :: Maybe Integer
06:36:02 <lambdabot>   Just 42
06:36:36 <mauke> > liftA2 (*>) print return 42
06:36:37 <lambdabot>   <IO Integer>
06:36:46 <Baughn> Anyway..
06:37:00 <Baughn> I guess "foo *> return" is /not/ equivalent to "\a -> foo a >> return a", after all
06:37:29 <mauke> no, just look at the types
06:37:36 <Baughn> :t (*>)
06:37:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
06:37:44 <mauke> (*>) :: (e -> a) -> (e -> b) -> (e -> b)
06:38:07 <mauke> @djinn (e -> a) -> (e -> b) -> (e -> b)
06:38:07 <lambdabot> f _ a b = a b
06:38:29 <mauke> @pl \a -> foo a >> return a
06:38:29 <lambdabot> liftM2 (>>) foo return
06:39:03 <Baughn> Yes, okay.. but what's the point of *> then, since I get neither the side-effect nor the value?
06:39:14 <Baughn> @src (*>)
06:39:14 <lambdabot> (*>) = liftA2 (const id)
06:39:15 <mauke> you get the side effect
06:39:36 <Baughn> Not in IO, I don't
06:39:38 <mauke> it's just that the "side effect" of (e ->) is passing additional arguments
06:39:42 <mauke> you're not in IO
06:39:51 * Baughn blinks
06:39:54 <Baughn> ..you're right.
06:41:15 <JasonFelice> So, if I were to create Haskell bindings for SANE and WIA to acquire still images, should that go under Graphics.Acquire or System.Scanner or what?
06:41:31 <Baughn> JasonFelice: System.Scanner, I say
06:41:43 <Baughn> Most IO functions go there
06:41:59 <Baughn> (That is, those that don't go in Network)
06:42:09 <Baughn> ..or... hmm
06:42:26 <Baughn> @dice 1d2
06:42:26 <lambdabot> 1d2 => 2
06:42:31 <Baughn> JasonFelice: Oh. Graphics.Acquire.
06:43:19 <JasonFelice> heh.  That was kind of my thought process, although 'repeat' was applied.
06:44:21 <JasonFelice> As long as nobody has a convincing argument, Graphics.Acquire
06:44:39 <dv-> Anyone know what's wrong here: http://pastebin.com/0B6f3pDE trying to build gtk2hs
06:48:13 <hamishmack> dv-: With ghc-6.12.1 it is probably best to get gtk2hs from darcs
06:48:21 <hamishmack> then...
06:48:46 <hamishmack> cd tools; cabal install; sh bootrastrap.sh
06:48:55 <hamishmack> sorry...
06:49:18 <hamishmack> cd tools; cabal install; cd ..; sh bootrastrap.sh
06:49:23 <dv-> :o Thanks. Should be in the readme :p
06:49:57 <Jafet1> ... it is?
06:50:06 <hamishmack> dv-: this is only temporary until the cabal packages go into hackage
06:51:27 <hamishmack> then you will just be able to cabal install webkit
06:56:13 <orlandu63> if cabal is called by root does it install the library somewhere in /usr/share/lib?
06:57:01 <StarFire> Hmm, it would appear that the latest language-c doesn't work on files with CRLF line endings.
07:01:33 <dino-> orlandu63: I believe it has more to do with the configuration step before build. I want to say default is --user if you don't muck with cabal config.
07:01:49 <dino-> Or pass args explicitly
07:02:12 <dino-> orlandu63: Did you install something and can't find it now?
07:02:25 <Saizan> yes, the default is user installation, so if you run cabal as root without passing --global you get a root-local installation
07:03:18 <Saizan> (IOW it follows $HOME)
07:05:43 <orlandu63> dino-: no, i am just curious
07:07:19 <dino-> On my system, I configured ~/.cabal/config with:  user-install: False  documentation: True  root-cmd: sudo
07:07:43 <illissius> if anyone's used the llvm bindings -- alloca and arrayAlloca allocate in increments of what? 1 byte? 4 bytes? or can it infer the type you want?
07:07:44 <dino-> So everything by default get installed globally unless I switch it with --user. And API docs get created and installed if possible.
07:07:58 <mauke> illissius: what are the types?
07:08:09 <orlandu63> interesting, i might use that
07:08:14 <illissius> mauke: alloca :: forall a r s. IsSized a s => CodeGenFunction r (Value (Ptr a))
07:08:26 <mauke> oh wow
07:11:24 <Saizan> i guess it takes the size from IsSized's methods?
07:11:34 <Cale> illissius: It'll allocate according to what type you're using.
07:11:43 <Cale> (probably)
07:12:08 <Cale> at least, if it's anything like the function of the same name from the FFI
07:13:35 <Cale> An instance of IsSized t n  appears to be a way to specify that the memory representation of values of type t require n bits.
07:14:15 <illissius> i think so too, but i haven't tried to think through how exactly it does it :)
07:15:01 <illissius> probably if i tried writing something using it without do-notation it would be become clear
07:19:43 <Cale> Oh, it *appears*, though I'm not sure, that LLVM has some way from the type to determine the amount of allocation to use anyway, so the IsSized thing is purely for the additional level of verification that can be done on the Haskell side of things.
07:21:21 <Cale> The code for alloca uses  typeRef :: (IsType a) => a -> TypeRef
07:21:38 <Cale> where it appears that TypeRef is a reference to an LLVM type.
07:23:39 <Cale> alloca :: forall a r s . (IsSized a s) => CodeGenFunction r (Value (Ptr a))
07:23:39 <Cale> alloca =
07:23:39 <Cale>     liftM Value $
07:23:39 <Cale>     withCurrentBuilder $ \ bldPtr ->
07:23:39 <Cale>       U.withEmptyCString $ FFI.buildAlloca bldPtr (typeRef (undefined :: a))
07:24:48 <Cale> IsSized doesn't have any methods of its own, but it's a subclass of IsType
07:32:13 <illissius> Cale: heh, thanks for digging :)
07:32:59 <illissius> ...you can do 'undefined :: a', and have it be the type of the a from (Ptr a)?
07:33:25 <Cale> illissius: The ScopedTypeVariables extension must be on
07:34:02 <Cale> illissius: Type variables which are explicitly quantified in the type signature of a function refer to the types they're bound to in the body then.
07:34:15 <Cale> (or s/function/value/)
07:36:11 <illissius> ah yes, and it does appear to be enabled there
07:36:36 <leino> hi all.. I'm trying to follow the instructions of http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-Set.html
07:36:44 <illissius> is ScopedTypeVariables considered 'hygienic' or more like a hack?
07:37:16 <leino> when I try (in ghci) "import Data.Set (Set)" I get "parse error on input 'import' "
07:37:23 <Cale> It's one of those things which probably should have been part of the standard.
07:38:02 <Cale> leino: ghci still doesn't yet support the full syntax of import declarations
07:38:29 <leino> is there a better interactive environment?
07:38:32 <Cale> leino: You're meant to put that import line at the top of a file, rather than giving it to ghci
07:38:43 <leino> ok
07:38:45 <Cale> :m + Data.Set will work though
07:39:01 <Cale> Or just plain  import Data.Set
07:39:12 <leino> and how do you do qualified imports (if that is a standard term) in ghci?
07:39:23 <mauke> can't
07:39:24 <Cale> By putting them in a file and loading it.
07:39:29 <leino> I get a similar error
07:39:36 <leino> ok I see
07:39:37 <leino> thanks
07:39:39 <Cale> Declarations are meant to go into files. Really all that ghci wants are expressions :)
07:40:05 <Cale> Typically, you load a file into ghci, and hit :r whenever you make changes.
07:40:13 <Cale> (which reloads it)
07:40:37 <Cale> That way you never lose definitions by accident, and it's reasonably convenient to work with.
07:40:47 <Tefaj> Is it intentional that ghc does not recompile, even with different command line?
07:41:18 <mreh> does the IO monad live in "GHC.IOBase"?
07:41:25 <Cale> Tefaj: mmm... there are cases where I really wish it would. I've been mildly annoyed by that feature at times as well.
07:41:40 <Cale> Tefaj: It only uses the file timestamps to tell if it should recompile.
07:41:48 <Tefaj> I suspect it is, because it obnoxiously says "No compilation is needed"...
07:42:03 <Tefaj> The manual says that it uses checksums now
07:42:32 <Tefaj> It should also checksum the command line and compiler output, in my opinion (like ccache)
07:42:33 <Cale> Ah, okay, but that's no better for your case :)
07:42:40 <Cale> right
07:42:58 <Cale> You might put a feature request into the trac (or see if it's already there)
07:43:04 <Tefaj> Okay
07:43:38 <Cale> mreh: "live"? You mean the basic definition in GHC?
07:44:07 <Cale> mreh: Apparently the type itself is in GHC.Types in 6.12.2
07:44:21 <Cale> mreh: and the Monad and Functor instances are in GHC.Base
07:45:21 <Cale> ":info IO" in ghci will tell you
07:46:39 <Taejo> does compiled IO code really pass around tuples of RealWorld tokens, or does the compiler know that (# Realworld, foo #) is actually just foo
07:46:39 <Taejo> ?
07:47:18 <Cale> It gets optimised away
07:47:37 <Cale> The RealWorld type has no actual values, and just exists to help dependency analysis along
07:47:46 <mreh> Cale the constructor I need specifically
07:48:04 <Cale> Well, to help use dependency analysis to order the execution of the IO actions.
07:48:53 <mreh> (even with cunning newtype deriving: cannot eta-reduce the representation type enough)
07:49:03 <Cale> mreh: sorry, what?
07:49:12 <mreh> GHC just gave me this error
07:49:13 <Cale> mreh: Why do you need the data constructor for IO?
07:49:38 <mreh> Cale: deriving a new instance for an MArray
07:50:04 <Cale> Can I see your newtype declaration?
07:50:21 <mreh> I didn't define it, but i'll get it
07:50:25 <mreh> it's the openGL types
07:50:36 <mreh> http://hackage.haskell.org/packages/archive/OpenGLRaw/1.1.0.1/doc/html/src/Graphics-Rendering-OpenGL-Raw-Core31-TypesInternal.html#GLint
07:51:20 <Cale> Lovely, CPP macros.
07:52:45 <Tefaj> http://hackage.haskell.org/trac/ghc/ticket/437 "Opened 5 years ago"
07:52:47 <Tefaj> Sigh
07:53:51 <Cale> Tefaj: Let's add ourselves to the CC list. The developers use those lists to decide what people care about.
07:54:09 <DigitalKiwi> 5 year old bug, nice
07:54:15 <Tefaj> Aha. Well, no one probably cares about what I care about
07:54:39 <Cale> (mostly just the length of the list)
07:54:57 <Cale> mreh: so, er...
07:55:19 <Cale> mreh: What is the compiler choking on there?
07:56:12 <mreh> Cale: trying to derive this: deriving instance MArray IOUArray GLint IO
07:56:20 <Cale> INTEGRAL_TYPE expands to some lifting instances of Num, Integral, Read, Show, Typeable, and some others
07:56:39 <mreh> I suppose I might convert between the two and back again
07:56:54 <Cale> So, using the new separate deriving extension?
07:57:09 <mreh> {-# OPTIONS_GHC -XStandaloneDeriving -XGeneralizedNewtypeDeriving #-}
07:57:48 <Cale> MArray and IArray are really odd classes in that most of their methods are not exported from the modules in which they're defined.
07:58:00 <Cale> and I wonder if that might be causing the problem
07:58:13 <Cale> (maybe not)
07:58:47 <Cale> oh, wait
07:59:00 <Cale> Is there even an instance MArray IOUArray CInt IO ?
07:59:11 <Cale> No, there isn't.
07:59:40 <Cale> Maybe you want a StorableArray instead
08:00:01 <mreh> Cale: I was trying to dodge anything hard :)
08:00:09 <mreh> Is that unboxed?
08:00:15 <Cale> yeah
08:00:28 <Cale> CInt is (theoretically at least) different from Int
08:00:45 <Cale> and GLint is a newtype of CInt
08:01:32 <Cale> You can use StorableArray via the MArray interface just the same as you'd use an IOUArray, you can ignore the functions in Data.Array.Storable
08:01:38 <jesusabdullah> What's a CInt?
08:01:59 <Tefaj> A C int
08:02:00 <Cale> An int value as the C compiler represents it.
08:02:05 <jesusabdullah> oh
08:02:14 <jesusabdullah> huh!
08:03:58 <jesusabdullah> Question: Is Real World Haskell good?
08:04:16 <arw> generally, yes i like it.
08:04:20 <TheSandman> hello
08:04:22 <jesusabdullah> hmm
08:04:28 <Cale> mreh: StorableArray just uses the FFI stuff to read and write values in memory according to instances of Storable (which defines things like alignment and how exactly to peek and poke values into memory)
08:04:28 <Choko> it's a nice book
08:04:29 <TheSandman> i need some help with a bit of code
08:04:46 <arw> jesusabdullah: but it depends on your prior knowledge and what you want to do with haskell.
08:04:47 <jesusabdullah> You're a little late Sandman, I should've gone to sleep like 6, 7 hours ago ;)
08:04:48 <Cale> mreh: It's probably not *quite* as efficient as IOUArray, but I'll bet it's not bad.
08:05:01 <Cale> TheSandman: Just ask :)
08:05:15 <mreh> Cale: it's a C Array on the actual heap isn't it?
08:05:22 <Cale> mreh: effectively, yeah
08:05:24 <TheSandman> http://stikked.com/view/33ab249e
08:05:29 <arw> jesusabdullah: you should know at least the basics before reading it, and its very light on the theoretical stuff.
08:05:32 <jesusabdullah> arw: probably numerical analysis in an engineering context
08:05:34 <Cale> mreh: It's in a format which will be comprehensible from the C side of things
08:05:35 <TheSandman> ERROR file:Sudoku.hs:76 - Instance of Num [Square] required for definition of buildRow
08:05:39 <TheSandman> this is what i get
08:05:51 <jesusabdullah> I poked through the first half or so of LYAH
08:05:56 <TheSandman> the square function returns a Square object
08:06:02 <jesusabdullah> Not that I'm saying that this is enough
08:06:05 <mreh> @hpaste
08:06:05 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:06:06 <Cale> TheSandman: You just forgot some parens around your (c+1)
08:06:12 <TheSandman> oh
08:06:19 <mreh> oh you did paste already :)
08:06:21 <jesusabdullah> but I can definitely tell that LYAH has a ways to go
08:06:22 <Cale> TheSandman: It meant that you were adding 1 to the result of buildRow ds r c
08:06:42 <TheSandman> thanks guys :D
08:06:49 <Cale> (which is apparently a list of squares, rather than a number)
08:06:49 <jesusabdullah> It was all me
08:06:56 * jesusabdullah bows
08:07:07 <jesusabdullah> But yeah
08:07:19 <TheSandman> back to the drawing board
08:07:21 <TheSandman> cheers
08:07:41 <Cale> jesusabdullah: edwardk and I will be writing a book soon too :)
08:07:59 <jesusabdullah> I have a hard time diving into something unless I have a particular project to work on, and as an enginerd, figuring out kinematics and dynamics is probably what I wanna do
08:08:02 <Cale> (but that's not even really started yet :)
08:08:14 <jesusabdullah> What I need is, "Haskell for scipy users"
08:08:28 <Cale> ah, hmm...
08:08:33 <jesusabdullah> XD
08:08:35 <Cale> Do you know about hmatrix at least?
08:08:38 <jesusabdullah> I kid, partly
08:08:44 <jesusabdullah> Yeah, I'm aware of hmatrix
08:08:58 <jesusabdullah> I hear its docs are pretty good!
08:09:05 <leino> anyone know if the elements of a set as defined in Data.Set can be compared with Eq?
08:09:47 <mreh> leino I should think it's a constraint on the type of a Set
08:09:54 <Cale> leino: They must be, yes.
08:10:31 <Cale> leino: But it doesn't relieve you of the responsibility for demanding an instance of Ord (which is a subclass of Eq), when working with Sets.
08:11:01 <Cale> It's just that all the nontrivial operations on sets require an instance of Ord.
08:11:19 <leino> ok, then why do I get the errors http://pastebin.com/357YnExv when I try to load http://pastebin.com/V50SDSzn
08:11:31 * Cale looks
08:11:35 <jesusabdullah> Thanks for BS-ing with my dudes
08:11:37 <jesusabdullah> :)
08:12:01 <Cale> leino: Just add the constraint it's asking for :)
08:12:19 <Cale> actually, better yet:
08:12:28 <Cale> isAssociative :: (Ord s) => Set s -> (s -> s -> s) -> Bool
08:12:54 <leino> what is one of those thingies called?
08:13:02 <leino> it seems I need to read up on them
08:13:03 <Cale> A class context
08:13:15 <leino> because that made no sense to me :)
08:13:16 <Cale> It restricts the types over which the type variables range
08:13:33 <mreh> before the => is the context
08:13:37 <Cale> The representation of a set is internally a kind of balanced binary tree
08:13:37 <leino> Ord stands for what? ordered?
08:13:40 <Cale> Yeah
08:13:43 <Philonous> Cale: What will your book be about?
08:13:43 <jesusabdullah> Someday I'll be able to read those things
08:13:47 <jesusabdullah> what're they called?
08:13:48 <mreh> @src Ord
08:13:49 <lambdabot> class  (Eq a) => Ord a  where
08:13:49 <lambdabot>     compare      :: a -> a -> Ordering
08:13:49 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
08:13:49 <lambdabot>     max, min         :: a -> a -> a
08:13:56 <Cale> (Ord s) means that the type s must be one which supports the ordering operations like (<) and such
08:14:01 <mreh> jesusabdullah, prototype/type signature
08:14:05 <leino> and Eq ?
08:14:12 <mreh> Equal
08:14:15 <jesusabdullah> In math class I only really saw real^n-->real^m
08:14:27 <mreh> jesusabdullah, it's the same kind of thing
08:14:29 <Cale> leino: Equality
08:14:32 <Cale> @src Eq
08:14:32 <lambdabot> class  Eq a  where
08:14:32 <lambdabot>     (==), (/=)   :: a -> a -> Bool
08:14:48 <jesusabdullah> mreh: Right, but I get lost real easy :S
08:14:59 <jesusabdullah> practice, I guess
08:15:05 <mreh> these are type classes, they have "methods", which are functions that operate on those classes
08:15:12 <leino> so an Ord is also an Eq?
08:15:24 <mreh> by implication of the definition, yeah
08:15:42 <mreh> @src Ordering
08:15:42 <lambdabot> data Ordering = LT | EQ | GT
08:15:49 <mreh> otherwise you couldn't do this
08:16:00 <mreh> :t compare
08:16:01 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
08:16:03 <jesusabdullah> Ord means "orderable?"
08:16:09 <leino> but I only need the elements of my sets to be Eq's
08:16:11 <mreh> yeah
08:16:14 <jesusabdullah> cool
08:16:21 <Cale> leino: well...
08:16:36 <mreh> choose a type that implements Eq, or implement it yourself
08:16:44 <Cale> leino: Actually, with the new Set API, you might be okay with Eq alone.
08:17:07 <Cale> Traditionally all the operations on Sets required Ord, but I see that they've relaxed a lot of the constraints.
08:17:43 <Cale> Hmm, have things actually changed, or am I just not remembering clearly? :)
08:17:54 <Cale> anyway, Set.toList doesn't require Ord
08:18:01 <Cale> (which is understandable)
08:18:11 <Cale> or elems
08:18:15 <Cale> which is just another name for that
08:18:32 <leino> oh wait a minute, I think I understand now.. when I write "Set a" it means set of elements with type a?
08:18:37 <Cale> yeah
08:18:53 <mreh> lowercase is a type variable in haskell
08:19:05 <mreh> concrete types have a capital
08:19:22 <jesusabdullah> >_<
08:19:31 <mreh> jesusabdullah, okay?
08:19:37 <jesusabdullah> I just looked up my first python project
08:19:47 <jesusabdullah> I thought it might be a good candidate for trying to do in haskell instead
08:19:50 <jesusabdullah> and
08:19:51 <jesusabdullah> well
08:19:53 <Cale> Yeah, so the type:  Set s -> (s -> s -> s) -> Bool  means that for *any* type s, it takes a Set of values of type s, and (a function which takes two values of type s and produces another)... and produces a Bool
08:19:54 <jesusabdullah> it makes me wanna vomit
08:20:02 <mreh> jesusabdullah, what was it?
08:20:12 <jesusabdullah> http://github.com/jesusabdullah/super-four-bar-explorer/blob/master/sfbe.py
08:20:22 <Cale> leino: But your implementation of isAssociative there wouldn't work for any types where equality isn't defined
08:20:26 <jesusabdullah> An implementation of a non-linear curve fit
08:20:29 <jystic> @pl f x /= f (x-1)
08:20:30 <lambdabot> f x /= f (x - 1)
08:20:39 <jesusabdullah> part of the problem is that the original equations are horrendous
08:20:43 <Cale> leino: So you need the extra constraint that says values of type s can be compared to see if they're equal.
08:20:54 <Cale> (since you're using ==)
08:21:06 * mreh prays for the day someone comes with a general purpose type project he might help with
08:21:10 <jystic> @pl id x /= id (x-1)
08:21:10 <lambdabot> x /= x - 1
08:21:13 <Cale> Also,  foldr1 (&&)  is better written as  and
08:21:13 <leino> I see
08:21:27 <Cale> and = foldr (&&) True
08:21:43 <leino> ok so and works on lists?
08:21:48 <Cale> yeah
08:21:49 <mreh> :t and
08:21:50 <lambdabot> [Bool] -> Bool
08:21:51 <leino> sweet
08:21:54 <jesusabdullah> also, should've used full variable names, and I'd love to come up with something more general, where you could describe a linkage instead of having to hard-code the equations for a four-bar :S
08:21:58 <Cale> it also has the advantage of not falling down when applied to an empty list
08:21:58 <jesusabdullah> sorry to spam
08:22:01 <jesusabdullah> :S
08:22:22 <Saizan> "Set s" now reads as "kind * at the universe level s" to me
08:22:29 <mreh> @src foldr1
08:22:29 <lambdabot> foldr1 _ [x]    = x
08:22:29 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
08:22:29 <lambdabot> foldr1 _ []     = undefined
08:22:33 <Cale> Saizan: hehe
08:22:35 <mreh> :D~
08:22:45 <jesusabdullah> Oh, question: Suppose you had a function with, say, a dozen parameters. How do you make that manageable?
08:22:49 <mreh> I didn't even know that
08:22:54 <Cale> jesusabdullah: Define some datatypes
08:23:19 <Cale> jesusabdullah: Or break the function into smaller pieces, each of which does something simpler
08:23:19 <jesusabdullah> Cale: Go on?
08:23:22 <jesusabdullah> hmm
08:23:25 <pastorn> is lambdabot capable of doing DCC?
08:23:37 <Cale> Well, datatypes can bundle multiple things into one piece of data
08:23:41 <jesusabdullah> I don't think these ones work very well with being decomposed
08:23:44 <Cale> so you don't have to pass so many parameters
08:23:56 <Cale> (just one parameter which has all the data you need)
08:24:02 <jesusabdullah> in python I would've used a dictionary
08:24:09 <jesusabdullah> if I were to do it again
08:24:11 <jesusabdullah> same idea?
08:24:15 <Cale> Dictionaries could be replaced by Data.Map values
08:24:39 * jesusabdullah googles
08:24:41 <Cale> At least, if all the values have the same type.
08:24:47 <Saizan> or record types
08:24:59 <jesusabdullah> Or, a few Data.Maps
08:25:00 <Cale> http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-Map.html
08:25:03 <plumenator> Where can I find the code for the 1500 line Haskell server mentioned in SPJ's awkward squad paper?
08:25:05 <Cale> right
08:25:09 <jesusabdullah> Most of them would be reals
08:25:14 <Cale> plumenator: hmm...
08:25:16 <jesusabdullah> (Double) ?
08:25:19 <Cale> plumenator: Does it have a name?
08:25:35 <Saizan> it's on hackage, but i always forget the name
08:25:40 <plumenator> I'm not sure, I just began reading the paper, thought it would be a good idea to have the source
08:26:08 <Cale> Is it HSP?
08:26:28 <jesusabdullah> Are import Data.Map (Map) and import qualified Data.Map as Map equivalent?
08:26:30 <plumenator> Could be, lemme check
08:26:52 <Cale> I don't know. HSP would have evolved a lot since that paper was written.
08:27:07 <Tefaj> No. The former imports the type Data.Map.Map and the latter imports the Map module.
08:27:08 <plumenator> No, I think it was written by Simon Marlow..
08:27:20 <Saizan> plumenator: http://hackage.haskell.org/package/mohws
08:27:21 <jesusabdullah> Tefaj: Thanks!
08:27:22 <plumenator> HSP's page mentions Erik Meijer
08:27:32 <Tefaj> Typically you use both.
08:27:47 <plumenator> jesusabdullah: wow, cool, thanks!
08:28:22 <jesusabdullah> plumenator: w8 wat?
08:28:35 <plumenator> oops
08:28:37 <jesusabdullah> haha
08:28:42 <plumenator> I meeant that for Sai
08:28:47 <plumenator> Saizan*
08:28:52 <jesusabdullah> NO TAKESIES BACKSIES
08:28:52 * Saizan is not sure how much it changed since the paper
08:29:01 * jesusabdullah puts on a second pair of sunglasses
08:29:32 <jesusabdullah> Oh, I get it now
08:29:36 <plumenator> Saizan: It still can have the same basic architecture, right?
08:29:44 <jesusabdullah> sluuuurp
08:30:18 <Saizan> plumenator: i guess, i'd check the 0.1 version if you're reading the paper
08:30:36 <plumenator> Okay
08:30:45 <plumenator> I installed it with cabal...
08:30:52 <plumenator> Wonder where the source might be...
08:31:02 <Saizan> especially since 0.2+ seem to be maintained by HenningThielemann which has a peculiar naming convention.
08:31:09 <plumenator> Okay
08:31:11 <Cale> jesusabdullah: The trouble with Data.Map is that it defines a lot of things having names which are also names of Prelude functions.
08:31:23 <Saizan> plumenator: use "cabal unpack mohws-0.1" to get the source
08:31:31 <jesusabdullah> Cale: That's what the hackage page was saying
08:31:34 <jesusabdullah> *nods*
08:31:49 <Cale> jesusabdullah: So it's necessary to import it qualified to avoid overlaps. You can also import specific things from it separately, so as to avoid writing the qualified names everywhere
08:31:51 <plumenator> Saizan: thanks
08:32:13 <Cale> (Haskell programmers traditionally don't like seeing qualified names if they can avoid them :)
08:32:24 <Fanael> Uhm... I give up. Cabal-install tries to build directory-1.0.1.1 (and fails with "Missing dependency on a foreign library") even though I have exactly the same version of this library installed. Is this normal?
08:32:25 <jesusabdullah> I kinda feel bad because I'm kinda converting this in my mind to python imports
08:32:48 <Cale> Fanael: that's odd...
08:33:20 <Saizan> Fanael: if it does that it means that it either think your directory installation is broken, or that it's built against a version of a dependency that conflicts with something else
08:33:21 <Cale> Fanael: You already have directory-1.0.1.1 installed, and it's trying to install it again?
08:33:21 <jesusabdullah> Fanael: Is the foreign library where it expects it to be? idk what I'm talking about really, but, umm, just throwing it out there
08:33:49 <Fanael> Cale: exactly.
08:33:54 <Saizan> Fanael: does "ghc-pkg check" report anything?
08:34:11 <jesusabdullah> Fanael: Why install it again? :S
08:34:26 <Cale> I think another case where it might do that is if you're installing something globally, but only have a locally installed version of the package. I wouldn't expect that to be the problem for directory though.
08:34:41 <Cale> jesusabdullah: It's usually an indicator that something is broken.
08:35:11 <jesusabdullah> Yeah, I suppose :)
08:35:53 <Cale> We've had a fair amount of this lately. I wonder why... I haven't run into it yet myself, but I don't have a ton of packages installed yet on 6.12.2
08:36:03 <mreh> Cale: hum, I can't derive this type for GLint with a StorableArray, even when there is a definition for an isomorphic type
08:36:12 <Cale> mreh: You shouldn't have to
08:36:23 <jesusabdullah> For some reason, I've ALWAYS had a rocky time getting a decent haskell environment going
08:36:28 <jesusabdullah> at least, with the unbuntos
08:36:31 <Saizan> Fanael: also you can pass --dry-run -v to see why it wants to reinstall directory when you're installing the original package
08:36:33 <Cale> mreh: There should be an instance of Storable for GLint
08:36:44 <Cale> mreh: and so you should already be able to make a StorableArray of them
08:36:50 <jesusabdullah> but I think they half-ass their haskell packages >:|
08:36:52 <mreh> Cale: oh
08:37:15 * Baughn thinks he's found a race condition in happstack-state
08:37:16 <jesusabdullah> Fedora wasn't too bad at all, except that I was running cabal w/ su
08:37:22 <Cale> jesusabdullah: I've stopped using Ubuntu's packages for any Haskell-related stuff.
08:37:23 <jesusabdullah> :o
08:37:35 <jesusabdullah> Cale: Yeah, I don't blame you XD
08:37:43 <Cale> jesusabdullah: What I do is just install the generic linux binary of GHC, then cabal-install, and then I'm set.
08:37:57 <jesusabdullah> As an aside, xmonad seems a lot smoother on fedora too
08:37:59 <Cale> (just use cabal-install to get everything else)
08:38:06 <mreh> shame there's no unboxing for C types
08:38:09 <jesusabdullah> though I last tried xmonad like 1,2 years before now
08:38:17 <Cale> mreh: It's not boxed.
08:38:20 <jesusabdullah> can't use a netbook without tiling
08:38:43 <Cale> mreh: The Storable instance for CInt/GLint specifies how to directly write values of those types into memory.
08:38:49 <Cale> (and read them back)
08:38:56 <jesusabdullah> Cale: I think I got stuck trying to install cabal-install, if you can believe that.
08:39:05 <jesusabdullah> Cale: But that was some time ago!
08:39:06 <mreh> so the OpenGL types are purposely the C types
08:39:19 <Cale> yeah
08:39:31 <mreh> not just to be annoying
08:39:34 <Cale> Because somewhat obviously, there's FFI going on
08:39:38 <mreh> :D
08:40:09 <mreh> not obvious necessarily
08:40:16 <Cale> I suppose. :)
08:40:25 <mreh> they could be wrapped quite neat;y
08:40:28 <Cale> I would really like to see Haskell reimplementations of some things.
08:40:30 <mreh> don't suppose how it would be slower
08:40:56 <Cale> It would be really nice to have a GUI library which didn't fall down when you used it in a multithreaded way.
08:40:59 <mreh> graphics pipeline is certainly something you'd want to see done in a low level systems programming language
08:41:14 <Cale> C programmers suck at threads, apparently.
08:41:16 <mreh> in the Perlis sense
08:41:29 <mreh> openGL crappy for threads?
08:41:54 <Cale> iirc, OpenGL makes use of lots of (OS) thread local state
08:42:03 <Cale> and you need to use bound threads to make it work
08:42:11 <pastorn> Cale: the StateVar things?
08:42:33 * mreh no know haskell threads yet
08:42:34 <Cale> StateVar is just a high-level abstraction for all sorts of mutable state
08:42:58 <mreh> or concurrency, I doubt they're the same thing
08:43:02 <Cale> (a (StateVar t) internally consists of an IO t for reading the state and a t -> IO () for writing it)
08:43:16 <plumenator> Found a version even nearer to the original HWS here: http://www.thenewsh.com/~hws/
08:43:21 <Cale> mreh: Well, they're closely related
08:43:37 <Cale> mreh: forkIO makes a new thread, and that's how you get concurrency
08:43:59 <StarFire> Hmm. If a C interface defines a call-by-value struct parameter, how do I call it from Haskell?
08:44:02 <pastorn> "a modern GHC (6.4.1)"
08:44:12 <pastorn> plumenator: made be a bit dated...
08:44:30 <plumenator> pastorn: That's wht I want. :D
08:44:40 <mreh> StarFire: I think FFI are all done in the IO monad
08:45:25 <StarFire> I know. I was just curious how to write the "foreign import" for such a function.
08:45:30 <Cale> StarFire: There are a couple options. One is to make a corresponding Haskell type, and write an instance of Storable which tells how to read and write it from memory in the way that the C struct would be. Another is to write a C-side wrapper.
08:45:53 <StarFire> I guess the latter would be easier.
08:45:56 <roconnor> ha, there is a comic strip (indirectly) about me http://ro-che.info/ccc/03.html
08:46:21 <Cale> Yeah, but if you're writing a complete binding anyway, you' purposes
08:46:23 <Cale> oops
08:46:25 <Cale> edit fail :)
08:46:32 <jesusabdullah> tssch
08:46:42 <jesusabdullah> I have to admit, I never did anything quite like that
08:46:43 <Cale> Yeah, but if you're writing a complete binding anyway, you'll likely have a type for those purposes.
08:46:53 <jesusabdullah> though one time I tried to distill vinegar to make a bigger baking soda explosion
08:46:59 <jesusabdullah> and stank up the whole kitchen
08:47:05 <jesusabdullah> Mom was, needless to say, pissed
08:47:26 <jesusabdullah> BUT, based on my subjective evaluation I was successful!
08:47:54 <StarFire> I guess this would be a fine opportunity to learn how Storable works.
08:48:19 <roconnor> Cale: sorry about getting frusterated last night.  It was good for me though, it helped clarify a few things.
08:48:32 <Cale> roconnor: No problem :)
08:49:08 <Cale> StarFire: There are also tools which can help write the instances for you, but it's not so hard to do by hand either.
08:50:02 <b0fh_ua> Hello! Can somebody please suggest an example of how to use Data.Accessor for setting value in record?
08:50:03 <roconnor> I think I more clearly know what natural numbers we are modeling now: the ones from the meta-language, IE the subset of langauge terms of the from O or Succ {nat}.
08:50:06 <StarFire> I'm using c2hs for the actual binding, but it doesn't seem to support call-by-value structs.
08:50:29 <Gracenotes> there are so many Turing machine jokes about the halting problem
08:50:56 <Gracenotes> well, out of the very small pool of Turing machine jokes there were to begin with. where are the jokes about enumerating the computable numbers, eh?
08:51:07 <Cale> roconnor: Yeah (at least about the first part)
08:51:24 <mreh> how many jokes about the halting problem are there?
08:51:24 <roconnor> Cale: which one is the first part?
08:51:49 <Cale> That soundness is a relationship between your meta-system and the system you're studying with it.
08:52:00 <Tefaj> Is it possible to know whether there will ever be an end to these halting problem jokes>
08:52:07 <roconnor> Cale: I think that might be the right way to look at it
08:52:14 <mreh> Tefaj: I like that one better
08:52:25 <roconnor> Cale: or at least it is good enough to convince you :D
08:52:29 <Cale> :)
08:53:14 <roconnor> Cale: but we do get a definition of what it means for an arithmetic statement to be true, and hence what it means for a formal system to be sound.
08:53:25 <roconnor> Cale: even if truth is relative to the meta-system
08:54:10 <roconnor> Cale: We can still discount PA+~Con(PA) as an unsound system, even if the meta-system is using a non-standard definition of natural numbers.
08:58:10 <Fanael> Hmmm, funny.
08:59:20 <gwern> agh. wasn't this discussion from last night?
08:59:33 <roconnor> gwern: yes
08:59:46 <roconnor> gwern: resonable people can't agree to disagree.
08:59:47 <Fanael> ghc-pkg check tells me that almost all packages are broken ^^
09:00:02 <gwern> roconnor: aumann's agreement theorem says that, yes
09:00:23 <gwern> but I thought agreement could be reached in less than log rounds :(
09:00:44 <jystic> @pl show2 (x,y) = show x ++ " " ++ show y
09:00:44 <lambdabot> show2 = uncurry ((. ((' ' :) . show)) . (++) . show)
09:01:26 <Saizan> Fanael: heh, maybe it can be solved, can you paste its output and the one of "ghc-pkg list" on a pastebin?
09:01:27 <roconnor> gwern: really?
09:01:37 <roconnor> I must be doinging this ineffecently
09:01:50 <gwern> roconnor: that or someone involved is not a bayesian agent
09:02:09 <roconnor> gwern: do you have to be bayesian to be reasonable?
09:02:33 <gwern> roconnor: mm. robin hanson has a paper showing 'bayesian wannabes' have to agree too, but I forget how that weakens the definition
09:02:43 <jutaro> jbhokuhbou
09:03:00 <roconnor> :)
09:04:13 <gwern> roconnor: 'A year ago I proved a complexity-theoretic analogue of Aumanns theorem: that not only will two Bayesians agree in the limit of common knowledge, but theyll also (probably, approximately) agree after a really short conversation.'
09:04:17 <gwern> roconnor: http://scottaaronson.com/blog/?p=13
09:04:21 <Athas> Has anyone wrapped X11 UTF-8 input in Haskell yet?
09:04:49 <roconnor> I suck at conversing
09:05:12 <roconnor> I suspect I was iterating rather than dividing and conquring
09:05:20 * hackagebot Hermes 0.0.2 - Message-based middleware layer  http://hackage.haskell.org/package/Hermes-0.0.2 (SveinOveAas)
09:05:22 * hackagebot control-monad-exception-monadsfd 0.9 - Monads-fd instances for the EMT exceptions monad transformer  http://hackage.haskell.org/package/control-monad-exception-monadsfd-0.9 (PepeIborra)
09:05:23 <gwern> roconnor: more likely you suck at being rational. don't feel bad, we all do
09:05:25 * hackagebot control-monad-exception-monadstf 0.9 - Monads-tf instances for the EMT exceptions monad transformer  http://hackage.haskell.org/package/control-monad-exception-monadstf-0.9 (PepeIborra)
09:05:28 <gwern> that's why we can't agree
09:05:40 <roconnor> nooo
09:05:51 <Entroacceptor> gwern: that's a mindist view
09:05:59 <gwern> Entroacceptor: I disagree
09:06:14 <Entroacceptor> that's because you're a dummy ;)
09:06:15 <roconnor> :O
09:06:16 * gwern doesn't even know what a mindist view means, except maybe in a buddhist context
09:06:21 * hackagebot control-monad-exception 0.9.0 - Explicitly typed, checked exceptions with stack traces  http://hackage.haskell.org/package/control-monad-exception-0.9.0 (PepeIborra)
09:06:34 <Entroacceptor> gwern: I don't know that either, just made up that word
09:07:03 <Entroacceptor> but there are things which are not possible to fully rationalize
09:07:16 <gwern> (in a buddhist context, I'd suspect it had something to do with the 2 mahayana schools - madhyamika and yogacara (mind-only))
09:09:01 <gwern> '65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.'
09:09:17 <roconnor> :O
09:09:26 <Fanael> Argh. I've removed Haskell Platform, cleaned the system and installed it again, now everything works...
09:09:29 <monochrom> false dichotomy.
09:09:48 <roconnor> I thought numbers were simply a kind of symbols
09:10:10 <monochrom> yeah, begs the question of what are numbers, *really*???
09:10:24 <gwern> 'We cannot spend the day in explanation' --emerson
09:10:51 <ski> (.. why not ?)
09:10:52 <dv-> Has anyone used gtk2hs's webkit bindings?
09:10:57 <Olathe> Numbers are the things you get when you are in line at the barber.
09:11:29 <roconnor> monochrom: inductively defined symbols :D
09:12:01 <gwern> ski: 'The great end of life is not knowledge, but action.'
09:20:09 <wayne> what advantages does haskell hold over lisp?
09:20:20 <wayne> *do
09:20:26 <wayne> *does.
09:20:29 <wayne> wait. grammar confusion.
09:20:32 <roconnor> wayne: a type system
09:21:33 <Entroacceptor> less parens
09:21:36 <kassens> how can i specify the class of an argument in a type definition? a should be of class Num in type Env a = [(String, FAEValue a)]
09:22:03 <kassens> (i hope i got the terms right)
09:23:14 <alexanderk> hello
09:23:47 <sepp2k> wayne: A powerful static type system and a "freer" syntax (infix operators!).
09:24:07 <sepp2k> Also laziness and purity.
09:24:17 <Fanael> Everything.
09:24:24 <alexanderk> i search for a beat detection algorithm
09:24:26 <Cale> and it's often overlooked, but pattern matching is pretty handy
09:24:31 <alexanderk> anybody have an idea?
09:24:53 <sepp2k> Cale: Good point. Can't believe that wasn't on my list.
09:24:57 <roconnor> Cale: good point
09:25:06 <alexanderk> yes
09:25:11 <alexanderk> good point
09:25:55 <soupdragon> pattern matching is a library for lisp
09:25:56 <lambdabot> soupdragon: You have 1 new message. '/msg lambdabot @messages' to read it.
09:25:59 <soupdragon> @messages
09:25:59 <lambdabot> roconnor said 7h 46m 27s ago: you cannot encode any mathematical problem into the halting or non-halting of a machine, only Pi_1/Sigma_1 problems.
09:26:25 <alexanderk> anybody knows library for beat detection?
09:26:29 <soupdragon> roconnor: but if proof checking is decidable, then you can just enumerate all proofs?
09:26:49 <roconnor> soupdragon: a statement being provable or not is Sigma_1/Pi_1
09:27:00 <roconnor> but true does not imply provable.
09:27:06 <alexanderk> hello
09:27:51 <jbapple> hi alexanderk
09:28:20 <Cale> alexanderk: hmm, I can't tell you much that wouldn't be obvious... You'd probably want to do something like start by discretising time into small chunks and use an FFT to transform each chunk of time into the frequency domain, and then take the song, and construct for each possible period T, the sum of the frequency responses at times x + k T, for each x from 0 up to T-1, and each integer k.
09:29:05 <aavogt> kassens: let the  Num constraint just show up wherever you use Env
09:29:18 <kassens> thanks aavogt
09:29:20 <Cale> and look for periods for which the frequency responses are more heavily concentrated in x
09:29:34 <aavogt> so you have functions like   f :: Num a => Int -> Env a -> Int
09:30:23 <soupdragon> roconnor, oh right, I get it now
09:32:53 <JasonFelice> alexanderk: There is a project BpmDJ I think that does something less sophisticated than what Cale suggests, but it seems to work.  It can determine frequency (BPM) but it doesn't actually identify beats.
09:33:33 <dv-> {#enum LoadStatus {underscoreToCase}#} <- what's this? :|
09:34:16 <aavogt> dv-: is some preprocessor run over the code? Like hsc2hs or c2hs or something like that?
09:35:24 <dv-> Yeah
09:36:14 <aavogt> dv-: then the notation is something specific to that preprocessor
09:39:15 <dv-> Ah it turns C's SOME_STATE into SomeState
09:40:47 <ville> When I am writing an application with an imperative language like C++ or Java, I usually start with a short description of the program domain and then I can find my initial candidates for classes, variables and functions. Verb => function, Adjective => variable and Subject => class. Not perfect but usually I find it gets me a good starting point. Is there similar process for Haskell and what maps to which Haskell construct?
09:41:29 <Tefaj> Haskell lets you program imperatively.
09:42:04 <ville> Jafet, hey your underwear are backwards!
09:42:13 <Tefaj> What underwear?
09:42:45 <soupdragon> ville, no
09:42:48 <soupdragon> not for me at least
09:43:00 <Tefaj> There are a few standard ways to think about state -- state (transformer) monads, CSP, etc.
09:43:32 <ville> Is there a website that would discuss this sort of thing rather than Haskell syntax?
09:43:36 <gwern> when writing a new program, I start with my input - often 'String' thanks to 'interact' and then progressively transform it until i have the results I want, and then I work on transforming it back into a String
09:44:06 <gwern> ville: Real World Haskell, I think, builds a number of programs. but this sort of waffly philosophy stuff is hard to talk about in any language
09:44:49 <Tefaj> SICP's second and third chapters relate to Haskell quite well (even better than it does to Scheme, I think)
09:44:49 <Saizan> ville: a central point is deciding what you have to use as internal model for your program and define some datatypes for that
09:45:15 <jutaro> p+
09:45:15 <NemesisD> hey all. i'm trying to install xmonad. when i do cabal install xmonad-contrib-0.9.2 i get :package haskell98-1.0.1.1 is broken due to missing package random-1.0.0.2-cf650c34bae72c01e165a0d26c11236b. It does this when installing X11-xft-0.3
09:45:34 <NemesisD> i've tried cabal installing random and doing it the old fashioned way. it installs but this keeps happening
09:45:50 <Saizan> NemesisD: can you paste "ghc-pkg list" somewhere?
09:46:26 <ville> Tefaj: alright I'll see that at least.
09:47:11 <ville> gwern: Reading through real world haskell right now.
09:48:03 <tommd> Don't read through it, work through it!
09:48:04 <NemesisD> Saizan: http://sprunge.us/BbcL
09:48:20 <NemesisD> haskell98 is the broken one
09:48:38 <ville> tommd: I will in the second pass.
09:48:52 <gwern> lies. you won't make a second pass
09:49:05 <NemesisD> oh wait, theres several broken packages apparently
09:49:10 <ville> gwern: Heh. Bet?
09:49:11 <gwern> look at webcomic artists - how many ever survive going back to redo all their old comics?
09:49:19 <gwern> no; betting would change the situation
09:49:33 <mdmkolbe> In scrap your pointerplate, if "mkQ Nothing Just" is "cast" then what is "mkT . const"?
09:49:50 <Saizan> NemesisD: the problem is that you've the same version of the same package installed in both the global and user dbs
09:49:51 <Tefaj> Kraftwerk re-produces all its albums.
09:50:12 <Saizan> NemesisD: that's bad because it confuses both ghc-pkg and cabal, so you've to unregister the one in the userdb
09:50:19 <gwern> (my statement was about going back without any financial incentives; my statement with financial incentives would be different and more optimistic)
09:50:22 <Saizan> NemesisD: both for haskell98 and random
09:50:22 <aavogt> mdmkolbe: id?
09:51:10 <NemesisD> Saizan: i bet its because i have some packages installed from apt for that
09:51:27 <mdmkolbe> aavogt: no, "id" would leave the value the same but where "mkQ Nothing Just" gets the value, "mkT . const" sets the value
09:51:44 <NemesisD> theyre virtual packages or whatever you call it so i can't seem to remove them
09:51:54 <mdmkolbe> @type mkT . const
09:51:56 <lambdabot> forall b a. (Typeable a, Typeable b) => b -> a -> a
09:52:07 <Saizan> NemesisD: the ones in the userdb are installed via cabal, surely
09:52:12 <aavogt> value(s)
09:52:21 <Saizan> NemesisD: you just need ghc-pkg unregister --user to remove them
09:52:42 <Saizan> NemesisD: this might break some packages in the userdb, but you'd just rebuild those
09:53:01 <NemesisD> Saizan: would i specify haskell98 and random to that command or just as you posted it?
09:53:38 <Saizan> NemesisD: "ghc-pkg unregister --user haskell98" and "ghc-pkg unregister --user random"
09:53:55 <aavogt> > (mkT . const) 5 (Just 0)
09:53:56 <lambdabot>   Just 0
09:54:14 <Cale> http://www.youtube.com/watch?v=uVaNmuTilQM&feature=channel <-- haha, perfect
09:54:29 <aavogt> > (mkT . const) (5::Int) (Just (0::Int))
09:54:31 <lambdabot>   Just 0
09:54:49 <aavogt> > (mkT . const) (5::Int) (0::Int)
09:54:50 <lambdabot>   5
09:54:57 <NemesisD> Saizan: ok cool, now try to cabal install xmonad-contrib-0.9.2 ?
09:55:05 <olsner> > everywhere (mkT (const 5)) (Just 0)
09:55:06 <lambdabot>   Just 5
09:55:19 * soupdragon doesn't get it ;)
09:55:21 <aavogt> hmm, I suppose I was confusing mkT with mapT or whatever it's called
09:55:25 <aavogt> @type gmapT
09:55:26 <lambdabot> forall a. (Data a) => (forall b. (Data b) => b -> b) -> a -> a
09:55:33 <Saizan> NemesisD: yup
09:55:37 <aavogt> > gmapT (mkT . const) (5::Int) (Just (0::Int))
09:55:38 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int -> t'
09:55:39 <lambdabot>         ...
09:55:52 <aavogt> > (mkT . const) (5::Int) `gmapT` Just (0::Int)
09:55:53 <lambdabot>   Just 5
09:56:00 <alexanderk> hey
09:57:36 <NemesisD> Saizan: wow. out of curiosity. does cabal/ghc compile on multiple cores or something?
09:57:36 <aavogt> mdmkolbe: so mkT . const is just a generalization of const
09:58:06 <Saizan> NemesisD: you mean if it can compile multiple modules in parallel?
09:58:07 <NemesisD> it compiles really fast on quad core
09:58:10 <NemesisD> Saizan: yeah
09:58:21 <aavogt> which gives you the original value if your substitution can't be cast to the result type
09:58:32 <mdmkolbe> aavogt: yes
09:59:08 <jbapple> Is the Journal of Functional Programming web site working for anyone else?
09:59:46 <Saizan> NemesisD: no, you'd need to hook it in some other build system
10:00:00 <jbapple> clicking on the title from http://journals.cambridge.org/action/browseJournalsAlphabetically doesn't get me anywhere
10:00:46 <jbapple> That is, the link http://journals.cambridge.org/action/displayJournal?jid=JFP does not seem to have any JFP-specific content
10:00:56 <Cale> I wonder how hard it would be to stick some instances of par into the GHC source code and get an improvement on multiple cores :)
10:02:02 <jbapple> make -j?
10:02:21 <aavogt> most of the slowness is linking anyways...
10:03:34 <Saizan> Cale: there are some things that aren't really threadsafe apparently
10:05:15 <Cale> hmmm
10:06:00 <roconnor> stupid hpaste locked database
10:08:41 <orlandu63> is there a way for cabal to compile packages with -O. furthermore, is -O generally safe?
10:11:29 <b0fh_ua> Can somebody please advice some way of decoding url-encoded data into String (UTF8)?
10:12:01 <Saizan> orlandu63: -O is the default
10:12:33 <ddarius> @hoogle urlDecode
10:12:34 <lambdabot> Network.CGI urlDecode :: String -> String
10:12:34 <lambdabot> Network.CGI.Protocol urlDecode :: String -> String
10:12:34 <lambdabot> Network.HTTP.Base urlDecode :: String -> String
10:12:37 <Saizan> orlandu63: you can pass -O0 or -O2 as flags to cabal install iirc
10:13:28 <orlandu63> thanks
10:15:32 <gwern> there's also the unescape functions in Network.URI
10:19:30 * LowRider Brand New!!Notebooks and LCD TVs.Discounts up to 30%.Our Special Limited Time Offers Up To May, 22. The newest electronics only http://www.elplace.com
10:19:51 <Tefaj> Oh great, they're invading IRC.
10:19:56 <b0fh_ua> awesome
10:19:58 <Tefaj> I feel unsafe.
10:21:38 <tensorpudding> el place sounds like bad spanish
10:21:52 <tensorpudding> should be la place
10:29:33 <bremner> la playa
10:29:50 <tensorpudding> mm
10:59:22 <Baughn> @hoogle fsstat
10:59:22 <lambdabot> No results found
11:10:56 <Norfenstein> is there some way to make System.Cmd work with unicode (in GHC 6.12)? or another way to do system calls involving unicode?
11:23:29 <gwern> Norfenstein: I think it'
11:23:39 <gwern> s supposed to just work, although it's all very new nad likely buggy
11:24:58 <leejr> I am new to haskell,  but I am impressed with it.
11:25:21 <gwern> that will pass, and be replaced by disgust for other languages
11:25:26 <leejr> it is very close to c++ with templates.
11:25:41 <Norfenstein> *Main> system $ "ls .html"
11:25:41 <Norfenstein> ls: cannot access ~ZD.html: No such file or directory
11:25:57 <gwern> we would say it the other way, but yes, templates do give c++ some half-assed FP abilities
11:26:05 <Norfenstein> looks like System only works with ASCII strings
11:26:07 <tensorpudding> Thinking of Haskell as being like C++ and its templates is probably a bad idea.
11:26:08 <mauke> oh hey, system is broken
11:26:24 <mauke> can I think of it as the template part of C++?
11:26:28 <leejr> c++ with templates was the only perfect language in the sense that all information known before compilation could be encoded.
11:26:49 <mauke> lolwut
11:27:01 <gwern> if there is nothing to do at runtime, then in what sense is the compiler not an interpreter?
11:27:10 <mauke> leejr: have you heard of this language from the 60s?
11:27:25 <mauke> it was called losp
11:27:32 <gwern> mauke: never heard of it
11:27:33 <Norfenstein> so there's currently no way to make system calls with unicode strings?
11:27:35 <leejr> no
11:27:43 <mauke> Norfenstein: well, you could encode them manually
11:27:51 <gwern> yeah, how we did things before 6.12
11:28:01 <leejr> i do have an observation
11:28:08 <Norfenstein> the above "just worked" for me before 6.12
11:28:10 <gwern> leejr: you may find the futamura projections interesting: http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html
11:28:26 <leejr> why are classes necessary,  why not just have each function be a class unto itself.
11:28:27 <mauke> is that like futurama + futa?
11:28:35 <gwern> @quote everyone
11:28:35 <lambdabot> lament: says: I think I speak for everyone in this channel when I say haskell is absolutely horrible and nobody would ever want to use it
11:28:45 <tensorpudding> Futaruma is nearly an anagram of Futurama.
11:28:46 <gwern> @quote good.news
11:28:46 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
11:28:49 <gwern> godammit
11:28:57 <tensorpudding> Wait, it is an anagram of Futurama.
11:29:09 <gwern> @quote gwern good.news
11:29:09 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
11:29:12 <monochrom>  @quote is not very usable
11:29:25 <Norfenstein> how do you manually encode a string so System will work correctly?
11:30:07 <gwern> Norfenstein: I usually used encodeString from utf8-string
11:30:09 <gwern> I think
11:30:22 * gwern is a Bear of very Little Brain and Unicode confuses him
11:30:39 <leejr> Every function calls other functions.  Therefore why not have the "class" of the function be the set of functions it calls?
11:31:00 <leejr> In short everything is a function.
11:31:17 <mauke> huh?
11:31:20 <leejr> 9 is a function that always returns 9
11:31:21 <tensorpudding> You'd have to change the class of a function by changing its internals, then
11:31:22 <gwern> of course. how do you think the lambda calculus represents numbers
11:31:35 <mauke> leejr: no, all functions have exactly one argument
11:31:36 <gwern> code is data, data is code
11:31:47 <leejr> every function calls a set of functions, right?
11:31:57 <mauke> yes/no/maybe
11:32:02 <leejr> therefore it defines a set of functions.
11:32:04 <mauke> no
11:32:31 <leejr> tok. lets use, it has a set of functions associated with it
11:32:38 <monochrom> this is not a productive discussion
11:32:48 <tensorpudding> What meaning would a class have in that situation?
11:32:48 <sepp2k> gwern: I can call the church-numeral 4 with an argument. Thus it is a function. I can't call the haskell Integer 4 with an argument. Thus it is not.
11:32:59 <leejr> a class has a set of functions associated with it.
11:33:01 <tensorpudding> I can't think of anything useful you could say about two functions in the same class.
11:33:09 <leejr> so a function and a class are similar
11:33:11 <mauke> a class is like a relation between types
11:33:14 <gwern> sepp2k: the church numeral is a combinator, isn't it? so wouldn't calling it with a function be a type error?
11:33:43 <gwern> er. I said that badly.
11:33:48 <leejr> so why not have each function also define a class?
11:33:50 <gwern> closed-expression? dunno
11:34:18 <mauke> leejr: I don't understand what that means or how it would be useful
11:34:20 <monochrom> yes a church numeral is a combinator, i.e., no free variables, closed.
11:34:42 <tensorpudding> These classes surely wouldn't be attendant to any object-oriented notion of a class.
11:35:04 <monochrom> if you also use the untyped lambda calculus, there is no type error.
11:35:05 <sepp2k> gwern: Unless I'm missing something, the church-numeral is a function that takes another function (f) as an argument and returns f.f.f.f - I don't see where that would cause a type error.
11:35:09 <leejr> right.  it would be purely functional
11:35:24 <tensorpudding> But it doesn't *mean anything*
11:35:28 <mauke> leejr: wait, so are these haskell classes or not?
11:36:10 <leejr> hmm.
11:36:41 <leejr> instead of defining a class and giving it properties,  let the properties define the class.
11:37:10 <mreh> how can I list all the types of names exported by a module?
11:37:29 <monochrom> :browse module
11:38:08 <leejr> all functions that call the same set of functions belong in an equivalence class.
11:39:01 <mauke> leejr: how do I do that for a class with no methods?
11:39:25 <mreh> the output is only too long ain't it
11:39:45 <tensorpudding> You can divide the set of functions into an equivalence class that way, but what does it accomplish?
11:40:01 <monochrom> There is a co- joke in this misguided line of thought. OO champions hiding implementation, even irrelevance of implementation. Now this person wants unconditional exposure of implementation, in fact grouping things based on only implementation. This is co-OO.
11:40:33 <Baughn> @index on
11:40:33 <lambdabot> bzzt
11:41:04 <mauke> @index off
11:41:04 <lambdabot> bzzt
11:41:06 <mreh> what would that look like?
11:41:13 <leejr> the traditional notion of  a class is basically that of a processor: a state and methods,  it is still data-centric
11:41:32 <Baughn> off :: (a -> a -> c) -> (a -> b) -> b -> b -> c
11:41:50 <mreh> someone was telling me about the days of databases before relational databases
11:42:12 <mreh> all things tend to declarative languages it seems
11:42:18 <gwern> 'off' seems pretty weird. provide one way to transform 2 arguments, then how to combine the 2
11:42:24 <monochrom> mreh: The output is no longer than what you asked for, all exported names and all their types.
11:42:30 <pastorn> @type on
11:42:31 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:42:37 <leejr> i'm sorry I
11:42:43 <leejr> I'm unclear.
11:42:56 <pastorn> @type sortBy (compare `on` snd)
11:42:57 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
11:43:00 <mreh> monochrom: what I really need is to find the source code quickly
11:43:07 <pastorn> gwern: ^^^
11:43:25 <Baughn> gwern: Yes, off seems a little.. off.
11:43:37 <monochrom> Go to hackage to find source code.
11:43:48 <pastorn> @djinn (a -> a -> c) -> (a -> b) -> b -> b -> c
11:43:48 <lambdabot> -- f cannot be realized.
11:43:53 <pastorn> cool
11:44:09 <mreh> monochrom: I have it, it imports with no explicit imports,
11:44:26 <mreh> so who knows
11:45:13 <monochrom> For each name, :info tells you which module really defines it.
11:45:23 <mreh> sweeeet
11:45:36 * soupdragon watches susskin
11:45:46 <monochrom> Example. :info Control.Monad.State.Lazy.mapM refers you to Control.Monad
11:46:23 <monochrom> :info Prelude.maybe refers you to Data.Maybe
11:47:40 <gwern> Baughn: wait, is that sig even right? what would you do with the function (a -> a -> c) if you just turned both a as into bs
11:47:56 <Baughn> gwern: It's deliberately broken
11:48:18 <gwern> Baughn: and even if fixed to :: (b -> b -> c) -> (a -> b) -> a -> a -> c, why mention the (b -> b -> c)? why not let the caller apply that?
11:48:22 <Baughn> gwern: Although, it might be useful if you use reverse :: (a -> b) -> b -> a first.
11:49:00 <gwern> it's not like 'f (off x y z)' is much different from 'off f x y z'
11:49:02 <soupdragon> shouldn't that be  (a -> b) -> not b -> not a?
11:50:00 <Baughn> gwern: It was a joke. You're insisting on analyzing it. ;_;
11:50:01 <copumpkin> @djinn  (a -> b) -> Not b -> Not a
11:50:02 <lambdabot> f a b c = b (a c)
11:50:33 <gwern> bah
11:50:41 <gwern> forget you guys. I'm too cool for school
11:50:49 <gwern> stop getting all up in my ear-holes
11:50:56 <Olathe> @pl \ a b c -> b (a c)
11:50:57 <lambdabot> flip (.)
11:51:01 * copumpkin pulls out of gwern's earhole
11:51:46 <leejr> In group theory, a group element is both object and operator.  group elements represent transformations. multiplication is really transformation composition, which is why groups are associative.  this allows chains of operations to be well defined, and therefore modular.
11:52:12 <leejr> associativity is the key to modularity.
11:53:11 <monochrom> you don't want group. you want monoid. you are not ready for reversible computing yet.
11:54:00 <copumpkin> semigroup!
11:54:15 <leejr> please enlighten me,  I didn't read about this stuff,  I came up with it myself
11:54:22 <mauke> MAGMA
11:54:26 <leejr> so I'm not into the jargon
11:54:55 <monochrom> most people in #haskell flunked math and still know about monoid. and monad too.
11:54:57 <copumpkin> alternative magma!!!
11:55:06 <monochrom> and yeah, magma.
11:55:55 * glguy thinks that this is the translation that OS X's tftp client does for "NetASCII" but is having trouble finding any kind of authoritative specification http://fpaste.org/gwJa/ 
11:56:06 <copumpkin> leejr: a group is a monoid with an invertible operation
11:56:21 <copumpkin> leejr: a monoid is a semigroup with an identity element
11:56:35 <copumpkin> a semigroup is a magma with an associative operation
11:56:42 <leejr> I was just using the term 'group' to get the concept across.
11:56:45 <copumpkin> alternative is a weaker associativity
11:57:29 <leejr> the main point was the associativity of operations,
11:57:43 <copumpkin> yep
11:58:30 <nainaide> In Monad Transformer,  s <- t m a , the s type is m a  or  a ?
11:59:28 <leejr> a vector is a state,  but a vector can be described by a transformation,  so get rid of the vector and only have transformations (aka. funtcions)
11:59:54 <leejr> a function only takes functions as arguments.
12:00:05 <monochrom> flawed question. "s <- t m a" is not a type because of "<-", and not a do-statement because you say "a" is a type.
12:00:43 <leejr> it is a true all the way down to primitive functions like 'True()' , 'False()' , 1(), "hello"() ...etc
12:01:04 <copumpkin> leejr: where is this?
12:01:08 <copumpkin> @where ops
12:01:09 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
12:01:15 --- mode: ChanServ set +o mauke
12:01:15 --- mode: mauke set +b |littlebear|!*@*
12:01:16 <copumpkin> can someone temporarily ban |littlebear| ?
12:01:17 <leejr> in my head.
12:01:17 <soupdragon> o_o
12:01:37 <copumpkin> leejr: why would you have nullary functions?
12:01:41 <leejr> i came up with it last night
12:02:19 <leejr> for example,  in shell programming these is the 'True' functioon that always returns true.
12:02:26 <nainaide> monochrom,  I am wrong, infact  a is a value.  then, what 's the ans
12:02:31 <copumpkin> what's the true that's being returned?
12:02:32 <monochrom> copumpkin: Suppose I want to invent a story that everything is a binary operator. Then I will surely coerce 0 into a binary operator too.
12:02:48 <copumpkin> monochrom: and they all lived happily ever after?
12:02:59 <monochrom> nainaide: you need to say more about t, m, a.
12:03:15 --- mode: mauke set -o mauke
12:03:31 * copumpkin loves mauke's iron fist
12:03:35 <leejr> true is an arguemtn to 'if then'
12:03:43 <copumpkin> leejr: but it's not a function itself? :P
12:03:49 <leejr> it is a function passed to 'if then'
12:04:10 <sepp2k> leejr: Actually there is the true *application* that always returns 0.
12:04:12 <copumpkin> it seems like you're talking about lambda calculus and church encoding
12:04:18 <monochrom> But perhaps just the type of t will help tremendously.
12:04:37 <copumpkin> except you don't know you're talking about it
12:04:43 <leejr> church encodign?  should I look it up. in wikiped
12:04:48 <mauke> I don't think that's what he's talking about
12:04:56 <copumpkin> leejr: yep! it's very elegant!
12:05:16 <mauke> leejr: church encoding is about building everything out of functions
12:05:23 * monochrom invents bi-lambda calculus. everything is a function of two arguments.
12:05:30 <copumpkin> ooh!
12:05:33 <nainaide> getValidPassword = do s <- lift getLine,  lift getLine type is MaybeT IO String,  is s String?
12:05:40 <leejr> so I came up with church encoding on my own.
12:05:55 <mauke> leejr: I doubt it, you were talking about 2 being a function that always returns 2
12:05:58 <leejr> must be a good idea then ;-)
12:06:14 <mauke> lambda calculus has no "2", only functions
12:06:26 <sepp2k> leejr: Church numerals aren't nullary functions though. And they don't returns themselves.
12:06:26 <leejr> how is that not builiding everything out of functions
12:06:33 <copumpkin> 2 is a function that applies a function twice
12:06:33 <mauke> leejr: because it returns 2
12:06:44 <copumpkin> leejr: so 2 is a function that returns itself?
12:06:47 <copumpkin> quine-like? :P
12:06:58 <Cale> (\succ zero -> succ (succ zero))
12:07:22 <mauke> leejr: you have no numbers, no lists, no data structures, no if-then-else, no loops
12:07:26 <mauke> leejr: only functions
12:07:39 <copumpkin> it's very deep! ;)
12:07:40 <Cale> (\cons nil -> cons you (cons can (cons also (cons do (cons lists nil)))))
12:07:40 <mauke> now write a program
12:07:44 * monochrom 's bi-lambda calculus is this. everything takes two arguments, the first is a type, the second is a value...
12:07:49 <copumpkin> ooh
12:08:23 <tensorpudding> It's like the lambda calculus, with types strapped to the trunk
12:08:51 <glguy> If functional programming emphasizes functions as values does typical programming emphasize types as values?
12:08:53 <leejr> In a sense the whole thing would  bootstrap itself
12:09:13 <leejr> it would be self deffining, which is what information is.
12:09:18 <copumpkin> hmm
12:09:40 <leejr> somehtin is true bescause that's how we interpret it'
12:09:59 <leejr> or is defined by it's operation on 1 and 0
12:10:03 <leejr> OR
12:10:18 <mauke> you lost me
12:10:29 <Taejo> I suppose http://ro-che.info/ccc/09.html has already been mentioned here :)
12:10:44 <copumpkin> lost me too
12:11:04 <leejr> here is an analogy.
12:11:24 <mauke> life is like an analogy
12:11:33 <sepp2k> Does anybody else find it interesting that "purely object oriented" means "everything is an object", but "purely functional" doesn't mean "everything is a function"?
12:11:35 <copumpkin> did you forget an R?
12:11:48 <copumpkin> sorry, that's inappropriate for #haskell
12:12:09 <leejr> for example, money has no value yet it is the basis of all wconomies,  it used to be backed by gold,  but now the whole thing floats without gold backing.
12:12:18 <mauke> hah, took me a while to find the right, um, insertion point
12:12:29 <leejr> money is functionality, gold is a value
12:13:00 <leejr> it seems like you need the gold,  but you don't
12:13:10 <sepp2k> copumpkin: I laughed. Maybe I should be ashamed of that, but I'm not.
12:13:29 * copumpkin slaps sepp2k for having a dirty mind
12:13:50 <leejr> it seems like you need data structures but maybe you don't
12:14:01 <copumpkin> still lost :)
12:14:08 <sepp2k> You shouldn't slap people that have dirty minds. They might like it.
12:14:09 <copumpkin> I need more CS
12:14:12 <leejr> sorry.
12:14:26 <uorygl> sepp2k: in the case of Unlambda, "purely functional" *does* mean that everything is a function.
12:14:51 <Cale> Unlambda isn't pure though
12:14:56 <leejr> I was just trying to think of the perfect language.  haskell inspired me.
12:14:57 <copumpkin> unlambda is pretty close to LC, minus the lambda
12:14:58 <sepp2k> It's not what people usually mean when they use the term though.
12:15:09 <uorygl> Yeah, that's the irony of Unlambda.  :)
12:15:21 <uorygl> Lazy K, which is similar to Unlambda, doesn't have that irony.
12:15:27 <Cale> yeah
12:15:33 <Cale> I was about to suggest it :)
12:15:45 <leejr> I do think the group concept is a good one to reflect upon.
12:16:21 <uorygl> Anyway, I'm having difficulty figuring out where the R should go.
12:17:00 <copumpkin> leejr: anyway, I'm not sure functions all the way down is a good thing to strive for, for a practical language, but you should definitely check out church encoding if you're interested in seeing how someone else approached the problem
12:17:21 <mauke> uorygl: between o and g
12:17:31 <copumpkin> we can pretend haskell values are morphisms in hask by treating them as functions from a singleton
12:17:42 <uorygl> Aha.
12:18:05 <leejr> symplectic operational chains.  ha,ha  make it sound smart
12:18:16 <leejr> thank you copumkin for your time.
12:18:32 <copumpkin> http://en.wikipedia.org/wiki/Church_encoding
12:18:48 <copumpkin> I don't see that term, nor do I know what it means :P
12:18:54 <leejr> I hate having an idea and nobody to bounce it off of.
12:20:51 <leejr> it's from geometry and topology.  all this crap boils down to it and group theory.  but seeing that is like looking at  a laptop and seeing all the way into the cpu circuitry
12:21:02 <leejr> I just made that term up.
12:24:09 <leejr> OK. I read Church encoding.  Church encodieng is simply a means of programning recursion to a certain depth
12:24:31 <mauke> hah
12:24:32 <leejr> it is like a fractal that stops at a certain granularity.
12:24:59 <sepp2k> leejr: It's a means to represent numbers in a language that doesn't have any.
12:25:27 <mauke> s/numbers/anything/
12:25:30 <copumpkin> leejr: that's for numbers
12:25:32 <tensorpudding> It's not really a fractal if you eventually get to "We're sorry, we don't have self-similarity at this zoom level"
12:25:32 <leejr> it could be used that way if the function was 'successor' and the argument
12:25:38 <leejr> were numbers
12:25:47 <sepp2k> mauke: Yes, I was thinking Church numerals
12:25:54 <copumpkin> leejr: but there's also a representation of true/false and arbitrary datastructures like lists
12:26:33 <leejr> it is similar to modern C++ template programming.
12:27:22 <mauke> yes, because C++ templates are basically a functional language
12:27:35 <leejr> the think I like about haskell is that it does what I was trying to do with C++ but with a lot less clutter
12:27:46 <Rotaerk> mauke, one that runs at compile time
12:28:02 <leejr> mozaltov!
12:29:57 <leejr> So I guess yes,  my concept of a number was like church numerals.  the base 'vector' is 0  and the transformation is 'succ' repeated n times.
12:30:34 <leejr> a smart compiler would 'optmize' it by simple putting down 9 or whatever number it was.
12:31:08 <sepp2k> leejr: Unless I misunderstood you, your numbers were supposed to be nullary functions (which don't exist in the lambda calculus). Church numerals take arguments.
12:33:48 <opqdonut> in some sense with laziness everything is a nullary function
12:34:02 <leejr> I don't know what a lambda calculus is.
12:34:19 <opqdonut> but of course in a pure functional language, a tends to be pretty much isomorphic to () -> a
12:34:23 <soupdragon> leejr, get rid of types.. now imagin programming just with  \x -> ...   and nothing else
12:34:56 <leejr> every argument would be a function.
12:35:28 <leejr> you could have arguments,  but they are functions all the way down the line
12:35:50 <copumpkin> how would you get anything done? :)
12:35:50 <leejr> until a primitive function like '9' is hit
12:36:04 <copumpkin> why would it be a function? just cause you call it that?
12:36:25 <sepp2k> leejr: There are no primitive functions. All functions take exactly one argument (which is a function) and return another function.
12:36:28 <leejr> data structures are really just a go-between.  they don't _do_ anything.
12:36:50 <leejr> the point of a program is to _do_ somethibng.
12:37:13 <leejr> anythow, thats the line of thought.
12:37:16 <monochrom> I agree. The point of a program is to do something, namely produce more data.
12:37:55 <monochrom> Program correctness looks at what data is produced.
12:38:00 <leejr> monochrom,  but that data is eventually used to do somehting.,  so the storage is just a go-between
12:38:32 <monochrom> No. The data is eventually left alone a data for my marvel.
12:38:44 <monochrom> s/left alone a/left alone as/
12:39:44 <leejr> I've never seen a bit on a hard drive.
12:40:10 <leejr> I heard you could once sprinkle iron filings on the disk and read off the bits.
12:40:14 <monochrom> I have pixels on my screen. They have colours. Pixel colours are data for me to watch. They end there as far as computing is concerned. No further processing on pixel colours.
12:40:45 <monochrom> Yeah who cares about hard disk. Tell me I am right or I am wrong about screen pixel colours. I see them all the time.
12:40:46 <leejr> a pixel is a command.  a function.
12:41:01 <leejr> it is output
12:41:02 <monochrom> No. A pixel's colour is data.
12:41:13 <Baughn> monochrom: There's further processing in your brain?
12:41:20 <copumpkin> leejr: okay, if you're going to keep throwing around the word function so much, let's hear a definition :P
12:41:20 <monochrom> This LCD cell thingy is clearly not a function.
12:41:29 <glguy> The pixel is the computer
12:41:45 <monochrom> Baughn: Not by the computer program.
12:42:15 <monochrom> Output is data.
12:43:00 <leejr> function:  an element of an associative n-ary algebra  ?
12:43:21 <copumpkin> hmm
12:43:28 <glguy> The point of the program isn't to compute something, it is to prove that the type of the program is inhabited!
12:43:46 * copumpkin sends glguy to agda with no dinner
12:43:49 <monochrom> or die trying
12:44:12 <leejr> the LCD lights up.
12:45:08 <leejr> I'm not saying that data encoding isn't necessary,  but there is a reason why programming languages are moving further and further towards the functional paradigm
12:46:09 <monochrom> Yes, because the functional paradigm offers better and better ways to make more data.
12:46:16 <leejr> languages are focussing more on the ends (functionality) than the means(data)
12:46:41 <erikc> in my world, the ends is the data and the means is the code
12:47:26 <leejr> erikc,  thank you for your honesty
12:48:03 <erikc> no problemo
12:48:13 <copumpkin> or ends are types?
12:48:37 <ddarius> Ends are indexed colimits indexed by the Hom bifunctor
12:48:48 <copumpkin> how about coends?
12:49:01 <Cale> http://en.wikipedia.org/wiki/End_%28category_theory%29
12:49:08 <leejr> maybe I'll write a small 'sample' program and post it later.  just to try the concept out.
12:49:23 <Cale> Now we just need a categorical definition of means
12:49:26 <ddarius> er ends are indexed limits
12:49:30 <ddarius> coends are indexed colimits
12:49:31 <leejr> i don't know what a coend is.
12:49:42 <Cale> (probably inspired somehow by probability theory)
12:50:04 <leejr> In short , the motto of this language would be, "It is what it does"
12:50:37 <leejr> very quantum mechanical epistomology
12:50:40 <copumpkin> whee, mumps on haskell-cafe
12:50:43 <ddarius> Indexed (co)limits are also known as weighted (co)limits.
12:51:09 <monochrom> perhaps just use coend for means. colimit is sum. mean is sum too. is that right?
12:51:24 <erikc> at this point, i'll hopelessly ask if anyone has ghc working on aix
12:51:26 <leejr> if I post the sample could copumkin and others who are curious get it somehow?
12:51:30 <ddarius> monochrom: A colimit is a quotient of a sum, so even better.
12:51:40 <monochrom> ok perfect!
12:51:43 <Cale> Yeah, that seems reasonable :)
12:51:48 <leejr> should I tag it?
12:51:51 <leejr> somehow
12:51:56 <gwern> erikc: I don't think I've ever heard of ghc on aix. it's a project to get ghc on sparc even
12:51:57 <monochrom> the indexed limit justifies the indexed colimit?!
12:51:58 <copumpkin> the coends justify the ends?
12:52:04 <copumpkin> ;)
12:52:09 <copumpkin> the coends cojustify the ends, maybe
12:52:17 <leejr> Im glad I got you all thinking .
12:52:44 <leejr> Don't just accept the status quo,  think it through for yourself.
12:52:51 <gwern> the means justify the ends up to isomorphism?
12:52:54 <erikc> gwern: i've found binary builds, but they just segfault immediately, maybe i'll finally learn how to bootstrap ghc
12:53:18 <monochrom> Don't just accept the status quo. Defend it eloquently from heresy!
12:53:27 <gwern> for the emperor!
12:53:34 <copumpkin> leejr: we're #haskell, we already make the status quo shudder
12:53:48 <leejr> ;-)
12:54:05 <Null-A> Does anyone know where I can find a compiler written for a language like C (or a subset) written in haskell that focuses on short lines of code?
12:54:28 <copumpkin> hmm, nope, but we do have a c parser if you want :P
12:54:36 <copumpkin> you just have to write the rest ;)
12:54:43 <Null-A> the rest?
12:54:47 <leejr> Haskell is great.  It takes C++ to the next level. For me, unless there is static typing it is crap.
12:54:48 <Null-A> what does it output?
12:54:54 <gwern> an AST
12:55:01 <gwern> what else would a parser output srsly
12:55:10 <Null-A> ah ok, so I just searcher "c parser" ?
12:55:25 <Saizan> @hackage language-c
12:55:26 <lambdabot> http://hackage.haskell.org/package/language-c
12:55:37 <leejr> If you know something apriori, there should be a way to encode it beforehand, rather than test for it at runtime.
12:55:38 <Null-A> thanks
12:55:39 <copumpkin> invoke the power of Saizan
12:55:54 <copumpkin> leejr: next up, dependent types
12:56:44 <leejr> OK,  I will finish learning Haskell.  I never had to learn a language before,  they were all pretty much the same.
12:56:46 <leejr> bb
12:58:11 <ddarius> @hoogle either
12:58:12 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
12:58:12 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
12:58:12 <lambdabot> module Data.Either
12:58:17 <Philonous> Is there an implementation of OOHaskell on hackage?
12:58:46 <gwern> Philonous: I don't know, is there?
12:59:20 <copumpkin> pff who needs oo
12:59:35 <Philonous> I'd like to see how it's implemented ;)
13:00:21 <Philonous> gwern: I've searched the list, but no joy. Maybe it is named somehow differently, that's why I ask
13:01:50 <gwern> it might be in libolewg
13:02:09 <gwern> not that I can see why anyone would bother resurrecting oohaskell
13:02:22 <Saizan> wait, is OOHaskell the oleg one?
13:02:28 <Philonous> Yeah
13:02:35 <gwern> Saizan: who else?
13:03:09 <Saizan> Philonous: there's a zip here http://homepages.cwi.nl/~ralf/OOHaskell/code.html
13:03:45 <gwern>  loleg: o hai there i put some oo in ur haskell?
13:03:52 <Philonous> Saizan: Splendid, thanks a lot!
13:04:00 <Saizan> gwern: there's also an O'Haskell which is an haskell dialect rather than something implemented within
13:05:46 <Saizan> http://www.cs.chalmers.se/~nordland/ohaskell/
13:07:01 <zachk> is there a way to get lambdabot to randomly spit out numbers from 1..6?
13:07:11 <copumpkin> @dice
13:07:11 <lambdabot> unexpected end of input: expecting number
13:07:19 <copumpkin> there was some command for it
13:07:24 <Philonous> @dice 6
13:07:24 <arw> @dice 6
13:07:24 <lambdabot> 6 => 6
13:07:25 <gwern> @dice 1d6
13:07:25 <lambdabot> 6 => 6
13:07:25 <lambdabot> 1d6 => 5
13:07:36 <soupdragon> @dice 6468716871
13:07:36 <lambdabot> 6468716871 => 6468716871
13:07:45 <copumpkin> @dice 2d5
13:07:46 <lambdabot> 2d5 => 6
13:07:51 <gwern> @dice 6468716871d6468716872
13:07:52 <lambdabot> 6468716871d6468716872 => 20922082093377583219
13:08:29 <opqdonut> @dice 65536d2
13:08:29 <lambdabot> 65536d2 => 98208
13:08:33 <opqdonut> @dice 65536d2
13:08:33 <lambdabot> 65536d2 => 98346
13:08:35 <opqdonut> @dice 65536d2
13:08:36 <lambdabot> 65536d2 => 98290
13:08:42 <opqdonut> pretty tight, huh?-)
13:08:51 <soupdragon> @dice 99999999999999d99999999999999
13:08:52 <lambdabot> 99999999999999d99999999999999 => 5000000251800415910818766848
13:09:05 <copumpkin> yeah, not too bad
13:09:15 <copumpkin> at least it isn't computing a trillion random numbers and adding them up
13:09:19 <sepp2k> @dice 1024d0
13:09:19 <lambdabot> 1024d0 => -26965397022934738615939577861835371004269...
13:09:27 <soupdragon> lol
13:09:39 * hackagebot clientsession 0.3.0 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.3.0 (MichaelSnoyman)
13:10:31 * LowRider Discounts!! Our Special Limited Time Offers Up To May,22!!! Notebooks,Plasma and LCD TV's.Buy your electronic needs at our unique prices. Laptop Sony VAIO VGN-FW590FFD-575,57$!!!Apple MacBook Air MC234LL/A-695,27$!!! http://www.elplace.com/
13:10:47 <copumpkin> lol
13:11:11 <deech> Hi all, I am having issues installing gtk2hs from darcs. Has anyone here successfully done that?
13:12:03 <Saizan> deech: someone today has suggested: "cd tools; cabal install; cd ..; sh bootstrap.sh"
13:12:11 <stralep> Could I write here ~4 lines of code? I'm newbie, and help would be appreciated :)
13:12:24 <Makoryu> stralep: Use a pastebin
13:12:26 <Makoryu> @where hpaste
13:12:27 <lambdabot> http://hpaste.org/
13:13:14 <Saizan> some other pastebin.
13:13:16 <deech> Saizan: That seems to be doing something :). The documentation on the site for building from darcs is wrong.
13:14:18 <gwern> deech: so is INSTALL
13:14:26 <stralep> Here http://pastebin.com/xvfXfcdV
13:15:22 <stralep> I wanted to implement De Certesian product of two sets
13:15:26 <tensorpudding> hpaste is nearly always down, obnoxious.
13:15:36 <soupdragon> De ?
13:15:51 <mauke> rene descartes
13:16:05 <soupdragon> de scartesian?
13:16:06 <copumpkin> descartesian?
13:16:09 <tensorpudding> it's Cartesian.
13:16:19 <stralep> sorry
13:16:49 <rtq> Needing some help on ghc-pkg
13:16:49 <mauke> :t S.map
13:16:49 <lambdabot> forall a b. (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
13:16:56 <Makoryu> @pl \s t -> map (\y -> map (\z -> (y, z)) t) s
13:16:57 <lambdabot> flip (map . flip (map . (,)))
13:16:57 <deech> Ok, thanks to Saizan I got a little further, but now I get an error saying that I have to install glib >=0.10.5 && <0.11. Is this referring to libglib?
13:17:03 <tensorpudding> You could probably write it as some sort of fold or map over Data.Set.Set's
13:17:04 <copumpkin> :t S.mapMonotonic
13:17:05 <rtq> I posted the problem here - http://stackoverflow.com/questions/2841473/how-do-i-get-the-haskell-platforms-ghc-pkg-to-work-on-mac-osx
13:17:05 <lambdabot> forall a b. (a -> b) -> S.Set a -> S.Set b
13:17:25 <mauke> :t \s t -> S.map (\y -> S.map (\z -> (y,z)) t) s
13:17:26 <lambdabot> forall a a1. (Ord a1, Ord a) => S.Set a -> S.Set a1 -> S.Set (S.Set (a, a1))
13:17:33 <rtq> Probably need to remove everything and start again
13:17:40 <Makoryu> stralep: When you just write "map" instead of "Set.map" you're using Prelude.map
13:17:48 <Makoryu> stralep: Is that what you intended?
13:17:56 <Makoryu> (Prelude.map only works on lists)
13:18:09 <stralep> Probably...
13:18:14 <Saizan> rtq: no
13:18:14 <tensorpudding> You can make a Cartesian product on lists pretty simply using the List monad
13:18:20 <tensorpudding> i.e. a list comprehension
13:18:28 <Saizan> rtq: you just need to use cabal-install-0.8.2 from hackage.
13:18:47 <zachk> > let as `cp`  bs = {do a<-as;b<-bs;return (a,b); } in [1..3] `cp`['a'..'c']
13:18:48 <lambdabot>   <no location info>: parse error on input `{'
13:18:48 <tensorpudding> It'd be neat if they had a set comprehension
13:18:54 <rtq> Saizan: tried that
13:19:06 <Makoryu> zachk: Swap "do" with "{"
13:19:14 <Saizan> rtq: cabal --version says you're using 0.6.2
13:19:16 <zachk> > let as `cp`  bs = do {a<-as;b<-bs;return (a,b); } in [1..3] `cp`['a'..'c']
13:19:17 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
13:19:32 <Saizan> rtq: so maybe you've both installed and one is masking the other in the searchpath?
13:19:43 <tensorpudding> > [(a,b) | a <- [0..10], b <- [0..5]]
13:19:44 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(2...
13:20:23 <stralep> Jus one question more :) Couls I use mapMonotonic instead of map?
13:20:31 <stralep> * Just
13:20:33 <rtq> Saizan: Could not install cabal-install-0.8.2 - can show you the error - wait a minute
13:20:34 <copumpkin> > liftA2 (,) [1..3] ['a'..'c']
13:20:35 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
13:20:43 <copumpkin> stralep: if your function is monotonic, you could :)
13:21:57 <stralep> In case of dec. pruduct? Is Pair a b monotone compared to a and b?
13:22:03 <rtq> Saizon: Setup: At least the following dependencies are missing:
13:22:03 <rtq> Cabal ==1.9.*
13:22:05 <deech> NM, I found it, it's actually part of gtk2hs.
13:22:13 <mdmkolbe> Is there a standard function that given a function of type (a -> Just a) and a value of type (a) iteratively applies the function to the value (i.e. f $ fromJust $ f $ fromJust $ ... $ f a) until the function returns Nothing and then returns the result just before "f" returned Nothing.
13:22:14 <mdmkolbe> (I can provide my own implementation if that will make things clearer; I'm wondering if there is a standard function or idiom for this.)
13:22:37 <Saizan> rtq: that's from the darcs version.
13:22:45 <byorgey> stralep: I don't understand the question.
13:22:46 <soupdragon> @src fixM
13:22:46 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:22:47 <Saizan> rtq: the tarball on hackage won't give you that error
13:22:49 <copumpkin> :t dropUntil
13:22:50 <lambdabot> Not in scope: `dropUntil'
13:22:55 <copumpkin> soupdragon: mfix?
13:23:02 <rtq> Saizon: thx - will try
13:23:06 <copumpkin> gotta love consistent naming
13:23:08 <soupdragon> :t mfix
13:23:10 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
13:23:20 <Saizan> rtq: http://hackage.haskell.org/packages/archive/cabal-install/0.8.2/cabal-install-0.8.2.tar.gz
13:23:22 <aavogt> @type until isNothing
13:23:23 <lambdabot> forall a. (Maybe a -> Maybe a) -> Maybe a -> Maybe a
13:23:54 <mdmkolbe> > until isNothing (\x -> Nothing) (Just 5)
13:23:55 <lambdabot>   Nothing
13:24:00 <aavogt> > until isNothing (\(Just x) -> guard (x `mod` 5 == 0) >> Just x) 1
13:24:01 <stralep> byorgey: if a1<a2 and b1<b2, is (a1,b1)<(a2,b2)?
13:24:01 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
13:24:01 <lambdabot>    arising from a use of...
13:24:13 <Saizan> rtq: and after you install it, make sure "$HOME/.cabal/bin" is in front of your $PATH
13:24:17 <mdmkolbe> I want the value before it isNothing
13:24:20 <copumpkin> stralep: comparing pairs is lexicographic
13:24:25 <byorgey> stralep: yes.
13:24:32 <aavogt> > until isNothing (\(Just x) -> guard (x `mod` 5 == 0) >> Just x) (Just 1)
13:24:33 <lambdabot>   Nothing
13:24:46 <copumpkin> until isNothing === const Nothing
13:24:49 <copumpkin> unless it diverges
13:24:56 <aavogt> yes
13:25:02 <byorgey> stralep: but that is irrelevant, you can't implement cartesian product with two maps.
13:25:15 <byorgey> stralep: because map preserves set cardinality.
13:25:29 <rtq> Saizon: about to install - shoul I run bootstrap?
13:25:50 <Saizan> rtq: yeah, it'll fetch the packages that you might miss
13:26:07 <stralep> byorgey: is there something like fmap for sets?
13:26:32 <aavogt> > map fromJust $ takeWhile isJust $ iterate (\(Just x) -> Nothing) (Just 5)
13:26:33 <lambdabot>   [5]
13:26:54 <byorgey> stralep: yes, there is Set.map and Set.mapMonotonic
13:26:58 <soupdragon> :t listToMaybe
13:26:59 <lambdabot> forall a. [a] -> Maybe a
13:27:08 <soupdragon> what about [Maybe a] -> [a
13:27:12 <soupdragon> @hggole [Maybe a] -> [a]
13:27:12 <lambdabot> Unknown command, try @list
13:27:16 <soupdragon> @hoogole [Maybe a] -> [a]
13:27:17 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
13:27:17 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
13:27:17 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:27:28 <rtq> Saizon: that worked - no errors - need to verify now
13:27:29 <stralep> byorgey: sorry... flatMap?
13:27:34 <soupdragon> :t (last . maybeToList .) . fmap
13:27:35 <lambdabot>     The operator `.' [infixr 9] of a section
13:27:36 <lambdabot>         must have lower precedence than that of the operand,
13:27:36 <lambdabot>           namely `.' [infixr 9]
13:27:41 <soupdragon> :t ((last . maybeToList) .) . fmap
13:27:42 <lambdabot> forall a a1. (a1 -> a) -> Maybe a1 -> a
13:27:55 <byorgey> stralep: oh, you mean something that will turn a Set (Set (a,b)) into Set (a,b)?
13:28:08 <stralep> byorgey: yes
13:28:20 <Saizan> ?type Set.unions
13:28:22 <lambdabot> Couldn't find qualified module.
13:28:28 <Saizan> ?type Data.Set.unions
13:28:28 <byorgey> stralep: you can do  unions . toList
13:28:29 <lambdabot> forall a. (Ord a) => [S.Set a] -> S.Set a
13:28:56 <mdmkolbe> soupdragon: that won't iterate the function.  maybeToList (Just x) = [x]
13:28:57 <soupdragon> :t ((last . maybeToList) .) . iterate
13:28:58 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `[a1]'
13:28:58 <lambdabot>       Expected type: (a1 -> a1) -> a1 -> Maybe a
13:28:58 <lambdabot>       Inferred type: (a1 -> a1) -> a1 -> [a1]
13:30:27 <aristid> :t last
13:30:28 <lambdabot> forall a. [a] -> a
13:30:50 <aristid> @src maybeToList
13:30:50 <lambdabot> maybeToList  Nothing   = []
13:30:51 <lambdabot> maybeToList  (Just x)  = [x]
13:30:56 <aristid> @src last
13:30:57 <lambdabot> last [x]    = x
13:30:57 <lambdabot> last (_:xs) = last xs
13:30:57 <lambdabot> last []     = undefined
13:31:16 <aristid> soupdragon: last could just as well be replaced by head?
13:31:23 <copumpkin> I think all pure values should be wrapped in Identity
13:31:57 <stralep> byorgey: you mean foldr union (toList set)?
13:33:12 <soupdragon> oh!!
13:33:17 <aavogt> > let ?f = const Nothing; ?x = Just 5 in foldr (\_ (b,x) -> if b then (b,x) else case ?f x of Nothing -> (True,x); Just x -> (False,x)) (False, ?x) (repeat ())
13:33:18 <lambdabot>   *Exception: stack overflow
13:33:19 <soupdragon> :t unfoldr
13:33:20 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:33:26 <soupdragon> :t (last .) . unfoldr
13:33:27 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> a
13:33:35 <byorgey> stralep: Data.Set provides the 'unions' function which is the same as foldr union empty
13:34:19 <stralep> byorgey: yes :) sorry
13:34:59 <copumpkin> we should try to confuse people with a stack underflow error
13:37:12 <mdmkolbe> aavogt: maybe try using takeWhile isJust
13:37:33 <aavogt> for the stack overflow?
13:37:45 <SliMM> Hello guys
13:37:52 <aavogt> > foldr (flip const) 1 (repeat 0)
13:37:56 <lambdabot>   mueval-core: Time limit exceeded
13:38:57 <mdmkolbe> aavogt: ahh, sorry I was thinking that the result of unfoldr is infinite
13:39:21 <SliMM> Can I make a list instance of a certain class?
13:40:09 <stralep> Well... Thank you byorgey, copumpkin and Makoryu :)
13:40:17 <ologNation> Does anyone know of something like sage for haskell?
13:40:30 <Saizan> SliMM: instance SomeClass [a] where ... ?
13:40:30 <mdmkolbe> SliMM: yes.  That is what the "instance" form is for.
13:41:04 <SliMM> Even for the Show class?
13:41:10 <mdmkolbe> SliMM: yes
13:41:49 <mdmkolbe> SliMM: but if you prefer you can use "deriving (Show)" after your "data" declaration to have the compiler write it for you.
13:42:08 <SliMM> I actually want to do the exact opposite
13:42:21 <SliMM> but I get a syntax error And I can't figure out why
13:42:24 <SliMM> Syntax error in instance head (variable expected)
13:42:27 <aavogt> it's a bit odd for the Show class, in that there's a showList method which is used instead of a separate instance Show a => Show [a], because that one apparently overlaps
13:43:23 <mdmkolbe> SliMM: can you paste to  haskell.pastebin.com an example giving you the syntax error
13:45:09 <SliMM> mdmkolbe: http://stikked.com/view/c40e59e8
13:45:41 <Saizan> aavogt: there's an instance Show a => Show [a] instance, any [Foo] instance would overlap with it
13:46:39 <ologNation> Is there anything for symbolic computation in haskell?
13:47:03 <Saizan> > map f [1..3]
13:47:04 <lambdabot>   Ambiguous type variable `b' in the constraints:
13:47:04 <lambdabot>    `SimpleReflect.FromExpr ...
13:47:07 <aavogt> oh right, so the showList method is there so that the String instance can be fancy without having any overlapping instances
13:47:09 <Saizan> > map f [1..3] :: [Expr]
13:47:10 <lambdabot>   [f 1,f 2,f 3]
13:47:18 <Saizan> aavogt: yeah
13:47:55 <Saizan> SliMM: the solution there is to give a definition to the showList method in the Show Digit instance
13:48:21 <aavogt> well you're allowed overlapping instances even if the standard library does ugly stuff to avoid them
13:48:26 <SliMM> Saizan: Ah, ok, mightI ask why?
13:48:26 <ologNation> Does anyone know a channel where people know about sage?
13:48:53 <Saizan> SliMM: otherwise you've to turn on two language extensions: FlexibleInstances (which i think ghc suggested to you) and OverlappingInstances (which is somewhat controversial)
13:49:43 <Saizan> SliMM: well, in haskell98 you can't have a concrete type as the argument of a type contructor in the head of an instance, it's a somewhat arbitrary condition and in fact you can use FlexibleInstances to lift it
13:50:17 <sepp2k> SliMM: Because instance Show a => Show [a] where show xs = showList xs  (assuming the question was "Why is that the solution?")
13:50:21 <mdmkolbe> SliMM: there is a Show instance for [a] which is conflicting with your declaration of for [Digit].  But that instance for [a] is implemented by calling showList on Digit.  So if you declare a Show instance on Digit that defines showList, then the [a] instance will call your function
13:50:38 <Saizan> SliMM: though there's already an instance for Show a => Show [a], so your instance for Show [Digit] would overlap with it, and this si bad for coherence in the presence of separate compilation
13:51:13 <SliMM> Saizan, mdmkolbe: What about [[Digit]]?
13:51:18 <Saizan> SliMM: you can use OverlappingInstances and if you do ghc will pick the most specific instance that fits, but that's discouraged
13:51:40 <Saizan> SliMM: you'd have the same problems.
13:52:01 <rtq> Saizan: Thanks for your help - all is good now
13:52:11 <mdmkolbe> SliMM: if you want a show instance for that which isn't just the instance for [a] with a=[Digit], then you'll have to go with the OverlappingInstances route
13:52:26 <Saizan> anyhow, the method showList is in the Show class for this exact reason (so that a String can be shown as "foo" rather than ['f','o','o'])
13:52:46 <Saizan> rtq: cheers :)
13:53:26 <SliMM> Only that I cannot redefine showList for [Digit], right?
13:53:45 <Saizan> no
13:54:00 <mdmkolbe> Saizan: no = right? or no = wrong?
13:54:06 <SliMM> Saizan: sorry, didn't notice the previous reply
13:54:09 <Saizan> you can't :)
13:54:23 <Saizan> you'd have to edit the [a] instance
13:54:46 <Saizan> SliMM: anyhow, if you need some particular pretty printing maybe Show is not the class for you
13:55:02 <Saizan> it's supposed to produce valid haskell code, afterall
13:55:11 <Saizan> (when possible)
13:56:43 <copumpkin> @instances Show
13:56:44 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
13:56:55 <SliMM> Ok, I guess I'll create a different function instead of an instance of Show
13:57:05 <copumpkin> what's the Show instance for ST s a? :P
13:57:08 <SliMM> since it is only pretty printing
13:57:11 <copumpkin> will it runST it/
13:57:30 <Saizan> > show (undefined :: ST s a)
13:57:31 <lambdabot>   "<<ST action>>"
13:57:36 <copumpkin> hot
13:57:44 <copumpkin> :P
13:58:43 <mdmkolbe> > show (undefined :: ST s Int)
13:58:44 <lambdabot>   "<<ST action>>"
14:01:35 <aavogt> @type newStRef
14:01:36 <lambdabot> Not in scope: `newStRef'
14:01:39 <aavogt> @type newSTRef
14:01:40 <lambdabot> forall a s. a -> ST s (STRef s a)
14:05:29 * Baughn bewares the 23M hello,world
14:05:53 <zachk> is it jvm?
14:05:59 <Baughn> No. Haskell.
14:06:06 <zachk> how do i make one
14:06:13 <Baughn> Link with hermes.
14:06:50 <aavogt> is it stripped?
14:07:33 <zachk> whats hermes
14:07:54 <copumpkin> just link to ghc :P
14:11:17 <zachk> copumpkin: how do i do that my hw is only at 897k atm
14:11:39 <copumpkin> http://www.haskell.org/haskellwiki/GHC/As_a_library
14:11:56 <Null-A> haskell looks scary when you start, but the language is actually not too bad in the end
14:12:17 <Null-A> I've only spent a day learning, getting the hang of it
14:12:27 <copumpkin> Null-A: hah!
14:12:40 <copumpkin> famous last words
14:12:43 <Null-A> lol
14:12:47 <copumpkin> prepare for plenty of head explosions to come
14:13:03 <Null-A> I realize, that the language features can be combined in rather complicated ways
14:13:16 <Null-A> but I mean the haskell98 language features themselves in principle
14:13:17 <Saizan> there's been a shortage of head explosions on thos channel
14:13:48 <ddarius> Null-A: Haskell is not much more than a sugared typed lambda calculus.
14:14:20 <Null-A> *nods*
14:14:25 <copumpkin> Null-A: yeah, it really isn't that complicated, fundamentally :)
14:15:06 <zachk> thanks copumpkin mine on windows vista (my helloworld) is now 26 megs almost 27 im so happy i can use my 750gig hd for something now
14:15:14 <copumpkin> sweet!
14:15:15 <illissius> learning haskell is a process of continual head explosion
14:16:13 <Null-A> illissius: examples of head explosions?
14:16:46 <Null-A> It would be nice to understand the compilation process, but I don't think I'll invest the time for that
14:17:06 <Null-A> also I know there's lots of language extensions
14:17:27 <illissius> Null-A: arrows. comonads. *morphisms.
14:21:00 <gwern> @quote head
14:21:01 <lambdabot> Bulat says: Haskell was developed with goal to hide implementation details from egg-headed scientists and this obviously should have some drawbacks
14:23:02 <SliMM> How can I run (easily) putStr (or other IO function) on each of the elements of a list?
14:23:14 <mauke> mapM_
14:23:19 <SliMM> ty
14:25:50 <gwern> @hoogle mapM_
14:25:51 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
14:25:51 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
14:25:51 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
14:26:13 <Baughn> zachk: http://brage.info/~svein/hermes/html/Network-Hermes.html <-- This.
14:26:42 <copumpkin> withHermes :: IO a -> IO a
14:26:42 <copumpkin> All use of hermes must be wrapped with this (on windows)
14:26:43 <copumpkin> eugh
14:26:47 <copumpkin> I still hate that on windows
14:26:57 <Baughn> Mm. It's really just a wrapper for the network thing.
14:27:11 <copumpkin> yeah, but you need to start up winsock
14:27:14 <copumpkin> that's why they have that
14:27:20 <Baughn> I know.
14:27:31 <chrisdone> we *all* know
14:27:32 <Baughn> To make it more amusing, I'm pretty certain hermes wouldn't /work/ on windows.
14:27:38 <copumpkin> it's gross :P
14:32:59 <mdmkolbe> @hoogle (a -> m b) -> (b -> c) -> a -> m c
14:33:00 <lambdabot> Language.Haskell.TH.Quote dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (b -> Maybe (Q q)) -> a -> Q q
14:35:14 <copumpkin> :t \f g x -> fmap g (f x)
14:35:16 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (t -> f a) -> (a -> b) -> t -> f b
14:35:31 <aavogt> @pl \f g x -> fmap g (f x)
14:35:31 <lambdabot> flip ((.) . fmap)
14:36:09 <aavogt> @type flip ((.) . (.)) :: (Functor f) => (t -> f a) -> (a -> b) -> t -> f b
14:36:11 <lambdabot> forall t (f :: * -> *) a b. (Functor f) => (t -> f a) -> (a -> b) -> t -> f b
14:47:11 <Philonous> Does anyone actually use HList ?
14:48:33 <mdmkolbe> @hoogle (a -> Maybe b) -> b -> b
14:48:34 <lambdabot> Data.IntMap update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
14:48:34 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:48:34 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:48:56 <mdmkolbe> @hoogle (a -> m b) -> b -> b
14:48:56 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:48:56 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:48:56 <lambdabot> Control.Exception handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a
14:49:03 <copumpkin> Philonous: if it were updated to use type families, I might
14:49:27 <Philonous> copumpkin: What's wrong with fundeps?
14:49:40 <copumpkin> it's a roundabout way to do functions
14:49:42 <mdmkolbe> @hoogle (Maybe b) -> b -> b
14:49:43 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
14:49:43 <lambdabot> Prelude asTypeOf :: a -> a -> a
14:49:43 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
14:50:14 <Philonous> copumpkin: Ok. Well, I think that's not possible, unfortunately, because it relies on some compiler quirks that don'T work with type families
14:50:37 <copumpkin> the only stuff that GHC doesn't support on type families is superclass equality, as far as I know
14:51:56 <Saizan> copumpkin: overlapping instances
14:52:11 <copumpkin> ah, hmm
14:52:15 <copumpkin> does hlist use that?
14:52:20 <Philonous> copumpkin: It does
14:52:26 <copumpkin> boo :)
14:53:18 <ddarius> copumpkin: I don't think it requires overlapping instances for the core ideas, just for some "sugar"
14:53:44 <aavogt> how do you manage recursion over HCons and HNil without overlap?
14:53:48 <tensorpudding> I prefer syntactic sugar to syntactic HFCS.
14:53:56 <Saizan> i'm not sure how you can write HLookup without
14:54:00 <mdmkolbe> @hoogle Maybe a -> (a -> b) -> Maybe b
14:54:01 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
14:54:01 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
14:54:01 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
14:54:25 <Saizan> aavogt: HCons and HNil don't overlap by definition :)
14:54:25 <ddarius> I may be thinking of incoherent instances.
14:56:31 <aavogt> Saizan: I suppose I was thinking about the lookup then
14:57:24 <aavogt> Philonous: recent versions of haskelldb use HList
14:58:32 <aavogt> which is an improvement over the earlier extensible records that were in the library
14:58:46 <mreh> :t liftM
14:58:47 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:59:22 <Saizan> http://github.com/nonowarn/has/blob/master/src/Data/Has/Engine.hs <- has uses OverlappingI. but no fundeps there
15:00:09 <Saizan> the fundep is in Knows
15:00:46 <Saizan> anyhow, the problem with hlist is that you don't get as much inference as you'd like
15:00:58 <Saizan> as i like, at least
15:01:11 <aavogt> Saizan: you can write your own   Apply class with more fundeps
15:01:15 --- mode: ChanServ set +o mauke
15:01:15 --- mode: mauke set -b |littlebear|!*@*
15:01:46 <Kaedenn> So I have a do block with a putStr followed by a x <- getLine, yet I don't see the string on the console when I'm asked for x
15:02:12 <Saizan> aavogt: oh, i'd never use Apply, that's horrible.
15:02:26 <aavogt> Saizan: how do you mean?
15:03:15 --- mode: mauke set -o mauke
15:03:25 <Saizan> aavogt: Apply is used to map/fold some polymorphic function over an HList, right?
15:03:33 <aavogt> yes
15:03:48 <Kaedenn> How can I make the output of putStr appear /before/ the following x<-getLine after it?
15:04:12 <Saizan> aavogt: i'd look for some alternative, gadts help
15:04:12 <aavogt> so with the current Apply class, you don't get inference on the construction of the list you fold or map
15:04:36 <dantay> Could anyone tell me how you'd split a string at a give number of characters? I'm new to haskell
15:04:38 <ddarius> Kaedenn: It's buffering.
15:04:43 <dantay> given*
15:04:49 <aavogt> @type splitAt
15:04:50 <djahandarie> dantay, splitAt
15:04:50 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:05:01 <dantay> awesome, thanks a lot
15:05:12 <Kaedenn> ddarius: Yes, I can see that, yet I'd like the buffer to be flushed when I do a getLine
15:05:44 <copumpkin> set no buffering or line bufferin
15:06:00 <copumpkin> hSetBuffering stdout NoBuffering or something
15:06:07 <ddarius> copumpkin: Line buffering is what he likely has.  He's using putStr not putStrLn.
15:06:15 <copumpkin> oh, duh
15:06:20 <gwern> > 365 / 5
15:06:21 <lambdabot>   73.0
15:06:23 <Saizan> or just hFlush
15:06:26 <copumpkin> you could flush it manually
15:06:33 <Kaedenn> Yeah, hFlush would work. THanks.
15:07:20 <aavogt> Saizan: I gotta go now, but I'd be interested to see how GADTs apply to that inference problem later
15:08:18 <Saizan> aavogt: i'm not sure if they'd help with getting more inference, they'd help in requiring less routing through typeclasses
15:08:51 <Fanael_> O.o, it's 0:06?
15:08:52 <aavogt> technically there's an  Apply (a -> b) a b    instance, but it's useless
15:14:00 <Saizan> it's quite amusing how Oleg considers GADTs a fancy type system extension
15:21:56 <nominolo> @hoogle [Either a b] -> ([a], [b])
15:21:56 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
15:24:32 <copumpkin> I love this: http://www.reddit.com/r/programming/comments/b20oq/a_monad_nontutorial_or_why_you_shouldnt_ask_what/c0klc2r
15:28:03 <djahandarie> That article itself it pretty good
15:29:16 <mdmkolbe> @pl \f -> \x -> lift (f x)
15:29:16 <lambdabot> (lift .)
15:29:29 <dantay> how would you turn a [Char] into a [[Char]]?
15:29:37 <mdmkolbe> @type \f -> \x -> lift (f x)
15:29:38 <lambdabot> forall t (m :: * -> *) a (t1 :: (* -> *) -> * -> *). (MonadTrans t1, Monad m) => (t -> m a) -> t -> t1 m a
15:29:53 <mdmkolbe> @hoogle (t -> m a) -> t -> t1 m a
15:29:53 <lambdabot> Data.Map update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
15:29:54 <lambdabot> Control.OldException tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)
15:29:54 <lambdabot> Control.Exception tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
15:29:55 <BMeph> dantay: Depends on what you're trying to achieve.
15:30:01 <copumpkin> dantay: return, repeat?
15:30:11 <copumpkin> > :t return "moo"
15:30:12 <lambdabot>   <no location info>: parse error on input `:'
15:30:15 <copumpkin> :t return "moo"
15:30:16 <mdmkolbe> dantay: inits, tails
15:30:16 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
15:30:25 <djahandarie> lol
15:30:26 <dantay> I'm trying to split a list 81 characters into a list of lists of 8 characters
15:30:27 <BMeph> dantay: chunk, fmap return, et al.
15:30:28 <dantay> 9*
15:30:35 <copumpkin> lol
15:30:58 <Peaker> Data.List.Split probably has chunkify
15:31:11 <BMeph> ...and so, the SuDoku chickens come home to roost... ;)
15:31:17 <copumpkin> chunkificatify
15:31:58 <BMeph> copumpkin: Hmm, it that when you chop up the household pet into foodstuff?
15:34:13 <gwern> 'The other problem when you are learning monad is that you want to use them. You open your editor and say "I'll make a program and I'm gonna create my own monads and I'll show it in the Haskell Caf and I'll become a member of the Secret Category Cabal and I'm gonna spend my evenings talking about Kleili arrows and functors and maybe Paul Hudak will friend me in facebook". Curiously, you have never say "Mmm, today I feel like I'm gonna make a program ...
15:34:19 <gwern> ... that uses hashtables". You don't try to impose data structures to your imperative programming, so why are you trying to force monads in your haskell programs? Don't go after monads, let the monads find you.'
15:34:32 <gwern> @quote Neo
15:34:32 <lambdabot> gwern says: Unfortunately Neo, no one can be *told* what the Monad is.
15:42:18 <gwern> @wn mure
15:42:20 <lambdabot> No match for "mure".
15:42:43 <gwern> ah, the root of 'immure'. that makes sense
15:42:49 <gwern> never seen it without 'im' though
15:43:23 <copumpkin> mural
15:45:35 <gwern> http://en.wiktionary.org/wiki/mure#English unfortunately gives no examples as an adjective
15:45:41 <gwern> can't really see how to use it
15:46:15 <bella_calda_18> those who exchange pictures? I want ... Here you can download my photos then let me know http://www.wikiupload.com/p4trNG1i
15:47:04 <copumpkin> bella_calda_18: vattene :P
15:47:22 <copumpkin> @where ops
15:47:22 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
15:47:34 <gwern> copumpkin: that's just lambdabot ops
15:47:50 <mauke> I don't think so
15:47:51 <copumpkin> gwern: hm?
15:47:57 <copumpkin> someone made a list with @where+
15:48:06 <bella_calda_18> chi fa a scambio foto? ho voglia... qui potete scaricare le mie foto poi fatemi sapere   http://www.wikiupload.com/p4trNG1i
15:48:07 <copumpkin> it's not a lambdabot admin list
15:48:09 <bella_calda_18> ho vogliaaa
15:48:17 <gwern> hm. I don't think that's a good idea in any case. just ask nickserv
15:48:22 <gwern> and get the real list
15:48:27 <mauke> why?
15:48:30 <copumpkin> gwern: the point is to highlight the ops
15:48:34 <copumpkin> not to get me a list
15:48:37 <copumpkin> I know who they are :P
15:50:10 <idnar> copumpkin: heh, that post is brilliant
15:50:29 <Saizan> which post?
15:50:30 <idnar> I mean, have you ever /tried/ to explain functions to someone? :)
15:50:35 <idnar> http://www.reddit.com/r/programming/comments/b20oq/a_monad_nontutorial_or_why_you_shouldnt_ask_what/c0klc2r
15:51:02 <gwern> idnar: most people who have gone through middle-school math know what functions are
15:51:27 <gwern> you just need to convince them functions can do more than just add/subtract/multiply/divide reals
15:52:23 <idnar> gwern: it's pretty hard to get from school-math functions to what most programming languages call a function
15:52:31 <gwern> idnar: it is?
15:52:39 <gwern> I didn't think it was for haskell
15:52:47 <idnar> gwern: well, I said most programming languages ;)
15:53:03 <gwern> what other language would we be trying to educate people in functions in?
15:53:36 <idnar> I don't really know what it would have been like if I learned Haskell as my first language
15:53:46 <idnar> but I suspect even then, it may have been easier to forget everything I knew about math functions initially
15:54:22 <idnar> it's the mismatch between knowing what something "is", and knowing what to do with it and how to do it
15:57:40 <Saizan> don't teach functions, teach intutionistic logic.
15:59:12 <BMeph> Sometimes I wonder if Haskell programmers are missing out in not being able to jump so quickly between in-language programming concepts, and lower-level implementation details of how it gets done. Then I think, "What if figuring out low-level details is all those other programmers know how to do?" ;)
16:00:12 <erikc> it isnt all they know how to do, but a lot of time is burnt dealing with the low level issues
16:00:34 <ddarius> BMeph: What makes you think Haskell programmers aren't able to do that?
16:04:48 <gjl> ddarius, probably because a lot of them respond to such an obvious troll
16:07:28 <aristid> @src guard
16:07:28 <lambdabot> guard True  =  return ()
16:07:29 <lambdabot> guard False =  mzero
16:10:27 <Null-A> where do I paste?
16:10:29 <Null-A> hpaste is down
16:10:53 <kmc> codepad.org
16:11:36 <BMeph> ddarius: Kind of as a corollary to erick's correction, it's not that Haskell programmers can't do it, so much as that it's a much smaller parcentage of what they _HAVE_ to do, to get their programs to work properly.
16:12:31 <kmc> i mean nobody is only a "Haskell programmer"
16:12:35 <kmc> good programmers need to know C, no matter what
16:13:01 <Null-A> is there a way to reduce line count here? http://codepad.org/Hof8W5eB
16:13:50 <Null-A> P is a module, forgot to include it
16:13:54 <wli> kmc: Arguable. Systems programming has been done without high-level [sic] languages and with other high-level languages besides C (e.g. PL/I in Multics).
16:14:19 <mdmkolbe> what is the correct noun for the (Data a) part of the signature "Foo :: (Data a) => a -> Foo a"?  "class quallifier"?
16:14:20 <kmc> wli, sure.  C is ubiquitous in today's world
16:14:26 <wli> kmc: Modern alternative systems programming has been done in Ada also.
16:14:28 <kmc> C may very well outlive the human race
16:15:02 <Philonous> mdmkolbe: class constraint
16:15:22 <kmc> mdmkolbe, the whole thing is called a "context"
16:15:25 <Ke> I still can't figure out how C is high level
16:15:25 <kmc> it's a list of constraints
16:15:59 <pikhq> Ke: It is, *compared to assembly*.
16:16:01 <mdmkolbe> Philonous, kmc: thx.  I knew the words, but was totally blanking on them
16:16:09 <Ke> assembly is not a language
16:16:10 <pikhq> There *exist* abstractions in C.
16:16:20 <wli> Ke: Strictly speaking, the term "high-level" in this context essentially refers only to the idea that it abstracts out hard machine register assignments and similar such things.
16:16:23 <kmc> Null-A, this pattern with Parsec.Token has annoyed me many times.  i finally figured out a way to make it go away using NamedFieldPuns or RecordWildCards
16:16:24 <pikhq> And as such, can be considered high level to some extent.
16:16:28 <kmc> can't remember the details
16:16:36 <kmc> but something like
16:16:37 <erikc> C abstracts calling convention, instruction selection, instruction scheduling and register allocation
16:16:44 <Null-A> kmc: no sample code you can digg up?
16:16:49 <kmc> Null-A, no
16:16:51 <Null-A> k
16:16:58 <pikhq> Of course, there's a continuum between "high level" and "low level", and not just a simple pair of adjectives.
16:17:07 <kmc> a multidimensional continuum
16:17:22 <pikhq> kmc: Quite true.
16:17:25 <kmc> C++ has very powerful weird abstractions, and also makes no attempt to hide very low level aspects of memory
16:17:41 <pikhq> Very weird thing, this.
16:18:01 <kmc> Null-A, try something like:  P.TokenParser { .. } = P.makeTokenParser haskellStyle
16:18:16 <kmc> with the RecordWildCards extension on, that's a legal top-level binding
16:18:18 <kmc> weird as it looks
16:18:33 <ddarius> kmc: Nice trick.
16:18:46 <ddarius> Somewhat evil (in general) but nice there.
16:18:47 <Peaker> Hiding whether something is in the instance, global, function local, is such a bad idea
16:19:04 <Peaker> And the "m_" conventions for member names in C++ are the absurd result... "this->" should have been explicit
16:19:12 <Ke> also typical human readable assembler languages have abstractions like named memory addressess
16:19:23 * kmc should have known better than to say the C-word
16:19:48 <Ke> =o)
16:20:41 <kmc> Peaker, sometimes it is... if a class template inherits from another class template, you need this-> to access the superclass's members.  otherwise it will bind to something unrelated from the global namespace first
16:20:55 * ddarius doesn't understand by which criteria assembly or even machine code fails to be a programming language.
16:21:27 <kmc> despite templates being nearly as dumb as macros, they actually managed to make the name resolution more complicated than macros would be
16:21:33 <wli> It's plausible to abstract much the same things as C without as many linguistic defects but by the time you get there you're stuck trying to compete with an already-heavily-entrenched competitor and never get out of the gate. Ada, for instance, still has little penetration outside US defense and maybe not even that much there.
16:21:35 <ddarius> Gilad Bracha has some arguments for a specific order of resolution.
16:22:01 <kmc> C's defects are pretty minor i think
16:22:24 <ddarius> wli: My impression is that Ada is used less and less, but then I suspect C is used less and less (within the DoD).
16:22:32 <Peaker> I see namespaces and name resolution as a syntactic artifact of encoding graphs in ASTs (which are then encoded as text)
16:22:57 <Ke> ddarius: assembly is a vague set of programming languaes
16:23:18 <Peaker> kmc, pretty major: Bad stdlib ("gets"), bad syntax (virtually all programmers confused by it),  value of arrays is a ptr to first element (also very confusing to most, no first-class array values), ...
16:23:44 <kmc> hmm, the C stdlib does suck esp. for string handling
16:23:52 <Null-A> kmc: still trying to figure it out, I get a nasty error message when I call one of my functions using parse functions
16:24:04 <wli> Peaker: Crap/missing module system is rather major.
16:24:05 <kmc> there are much better string libs that don't compromise C principles
16:24:09 <ddarius> Ke: Okay.  So you simply meant that assembly doesn't denote a single, particular programming language.
16:24:26 <Peaker> wli, Crap?
16:24:38 <kmc> i think the lack of a module system is not nearly as big a problem for C as for C++, precisely because people don't see C as a high level apps language
16:24:46 <copumpkin> I love crap
16:25:12 <Peaker> kmc, Lack of module system also makes scalability to large projects tough (build system becomes more and more sluggish, e.g: duplicating debug information everywhere)
16:25:43 <kmc> i think it's a feature of C that a C compiler just reads code and shits out object files, and the linker just glues them together
16:25:51 <kmc> and i think the same property is a bug in C++
16:26:31 <Ke> I think there are optimizations for that
16:26:33 <wli> kmc: Um, huge projects are done in C, e.g. the Linux kernel. Header file garbage in Linux is horrendous.
16:26:43 <Ke> esp. with link time optimizer
16:31:01 <wli> It's not just the build system getting more sluggish (though it does), it's that modularity becomes impossible to carry out. Inline code happens in header files, certain header files get depended on too heavily for almost anything to do without (sched.h in Linux) even though they shouldn't be depended on that way, abstract data types become impossible without runtime overheads because you can't restrict the scope properly, etc.
16:31:55 <Peaker> wli, I don't think there's a problem with modularity
16:33:51 <scoles> Has anyone here used the mongodb driver for haskell?  I'm having trouble having it update and insert quickly (uses little/no cpu nor does much IO).
16:34:55 <kmc> Null-A, can you pastebin what you have now?
16:35:09 <Null-A> kmc: sure thanks, i'm pretty new to haskell
16:35:43 <kmc> Null-A, for the syntax i gave you to be valid, you need to turn on the RecordWildCards extension to GHC
16:35:47 <kmc> did you do that?
16:36:05 <Null-A> yep
16:36:08 <Null-A> http://codepad.org/FRdS68Wo
16:36:26 <Null-A> I get an error when I call run p_object "input"
16:36:46 <Null-A> *Main> :t whiteSpace
16:36:47 <Null-A> whiteSpace :: CharParser GHC.Prim.Any ()
16:36:54 <copumpkin> oh no
16:36:56 <Null-A> whereas before it was CharParser st ()
16:36:58 <wli> Peaker: Which out of the things I outlined isn't a problem with modularity?
16:36:59 <copumpkin> you don't want Any
16:37:23 <Peaker> wli, I don't see why inline functions hurt modularity
16:37:32 <Peaker> wli, You mean binary modularity?
16:38:01 <Peaker> wli, Abstract types can be implemented without runtime penalty by using macros/inline functions and hiding them in an _internals.h header
16:38:03 <wli> Peaker: Because the code gets dumped into headers, separating the inline code from the rest of the module with which it's associated.
16:38:23 <Peaker> wli, Well, just consider foo.c, foo.h, foo_internals.h  to be a single unit
16:38:37 <wli> Peaker: Then that creates the problem that you can't restrict the scope of whatever data type it manipulates if it's an ADT wrapper.
16:39:02 <Peaker> wli, You can restrict by convention -- if it's typedef'd and not in the header file, don't use it
16:39:28 <wli> Peaker: Or that it can't restrict the scope of internal state the things manipulate etc.
16:39:33 <kmc> Null-A, oh, i think this is a very nasty consequence of the monomorphism restriction
16:39:35 <Peaker> wli, If you don't use other_module_internals.h declarations, you're ok..
16:39:38 <kmc> the *dreaded* monomorphism restriction
16:39:52 <Peaker> I'd prefer the MR to yield an error than to yield an "Any" type
16:39:56 <kmc> yes
16:40:01 <kmc> i'd prefer the MR to crawl into a hole and die
16:40:10 <kmc> Null-A, turn on NoMonomorphismRestriction extension for this module
16:40:13 <kmc> that's really the easiest way
16:40:24 <kmc> otherwise you will have to give type sigs for all the stuff you bind with the wildcard
16:41:09 <kmc> lotta people writing JSON parsers
16:41:14 <wli> Peaker: Okay, the module system fails to allow you to restrict the scope of internal state and/or abstract data types' internals and the module system doesn't have a deficiency? What would it take for you to call the module system deficient? Bugs where it randomly renames things?
16:41:17 <kmc> is this something to do with RWH or is it just a common idea
16:41:28 <Null-A> kmc: so -XNoMonomorphismRestriction ? to ghci
16:41:40 * Null-A googles
16:41:41 <Peaker> wli, The module system is very deficient, I agree to that -- but modularity is still achievable
16:41:56 <kmc> Null-A, at the top of your file:
16:41:58 <Cale> Null-A: Better to just put  {-# LANGUAGE NoMonomorphismRestriction #-} at the top of the module
16:42:02 <kmc> yeah, what Cale said
16:42:11 <Null-A> k
16:42:12 <kmc> you can do {-# LANGUAGE NoMonomorphismRestriction, RecordWildCards #-}
16:42:12 <Peaker> wli, The deficiency is that to get modularity, you need to follow some conventions -- but it doesn't make modularity impossible
16:42:46 <Null-A> I'm getting the same error kmc Cale
16:47:14 <Peaker> wli, btw, I think one of the main problems it that people don't follow those conventions - and indeed give up modularity when using C.. which is a source for a lot of my agony when cooperating on projects with C programmers
16:47:31 <Saizan> pattern bindings are monomorphic even with the MR off, i think
16:48:43 <wli> Peaker: Well, the big problem with those conventions is that it takes human eyeballs to enforce them and they get circumvented in any sufficiently large project.
16:50:03 <wli> Peaker: So while I agree with your idea about linguistic defects at the "programming in the small" level I really strongly insist that the truly make-or-break "this is killing us now" problems are the programming-in-the-large issues wrt. modularity.
16:50:11 <Peaker> wli, Not when you have code reviews and good people on it (I've had projects like that)
16:51:00 <Peaker> wli, If you have: A) Educated C developers, B) Educated/enforced code reviewers  (B is enough as it can lead to A) modularity is one of the easier things to review/achieve
16:51:15 <EvanR> imperative:functional <-> sequential logic:combinational logic
16:51:19 <wli> Peaker: Again, from my Linux experience, not enough reviewer manpower to get anywhere close, way too much code going in and out, etc., and even when it's there it's highly fallible and routinely missses problems.
16:51:40 <Peaker> wli, Linux is not an example of a good reviewed project :)
16:51:54 <Peaker> wli, My experience with that was only in "Cathedral" projects
16:52:16 <glguy> THE SO_RCVTIMEOUT socket option takes a "struct timeval" ... but Network.Socket.setSocketOption only operates on CInt parameters... is the network library broken? Is there a trick to using this?
16:52:24 <Peaker> My opinion of most Linux code I've read is that it's pretty horrible
16:52:32 <Peaker> (Though that is true of almost all C code everywhere)
16:52:38 <wli> Peaker: Linux has massive code volume and a huge breakdown by maintainer etc. where the different maintainers have different standards, review effectiveness, etc.
16:55:54 <wli> When I do userspace I just take the runtime hit for data abstraction in part because there's no stack depth limitation to worry about either. Linux has to worry about stack depth and cares about dumb aspects of performance like call overhead because of the sorts of patterns of usage etc. and general performance criticality and so on. C's (lack of a) module system essentially can't have the compiler enforce any data abstraction or privacy or a
16:57:59 <wli> If you can get the compiler to do the data privacy and abstract data structure privacy enforcement you get something that takes up time/effort/etc. for serious review (and a source of bugs when that review fails) done totally by the compiler.
17:04:12 <digitteknohippie> okies, time to get back into haskell after doing nothing more in my noob learnings for over a year....
17:05:19 <wli> Peaker: I guess it's tough to impress people with the need for it when they're not on projects of such scales etc. where modularity is an outright perpetual crisis.
17:13:44 <Cale> digitteknohippie: Of course, let us know if you have any questions about it :)
17:14:26 <digitteknohippie> yep,  so long as i dont get distracted by other chats too much, a question is formulating....
17:14:28 <digitteknohippie> ^_^
17:16:32 <ccasin> how far to bang patterns force evaluation?  The user guide says just to whnf, but I see differences in profiling adding them to things that are explicitly constructed pairs
17:16:35 <ccasin> *do
17:17:11 <digitteknohippie> the basic jist of what i'm upto at the moment tho, is i've been through the little walkthrough for making a chat bot, got it sitting nicely in my chat, it can repeat what's said with "!id blahblahblah" but i want to move it on to replying specific messages when given other commands...   so am trying to look into how to do that just now...
17:17:31 <dmwit> ccasin: can you be a bit more specific?
17:18:48 <ccasin> dmwit: I mean to ask, is writing (let !foo = (a,b) in e) different than writing (let foo = (a,b) in e)?
17:18:50 <dmwit> ccasin: Remember that (a, b) is actually (,) {- this is a constructor, and counts for whnf -} a b...
17:19:09 <dmwit> let's see
17:19:15 <ccasin> dmwit: yes, that's why I'm confused because I see differences in profiling in the two situations above
17:19:25 <dmwit> Yes, those are different.
17:19:46 <dmwit> The former will evaluate (a, b) to whnf before evaluating e no matter what; the latter will not evaluate (a, b) unless e depends on foo.
17:19:56 <ccasin> but isn't (a,b) already in whnf?
17:20:11 <dmwit> err
17:20:12 <dmwit> quite
17:20:35 * wli has yet to get off the ground with the mini-ML with a module system independent study project.
17:21:53 * dmwit is looking for the appropriate -ddump option
17:22:46 <wli> (e.g. omit pattern matching and all such other conveniences)
17:22:55 <dmwit> ccasin: let !foo = (3, 4) in 7 and let foo = (3, 4) in 7 compile to the same core here
17:23:11 <ccasin> dmwit: of course, my example is in the middle of a big project
17:23:16 <ccasin> but I haven't looked at the core
17:23:33 <ccasin> will do, now - just glad to know I'm not crazy
17:23:36 <ccasin> thanks
17:24:13 <kmc> let !p = e is somewhat of a special case, compared to other uses of ! in patterns
17:24:21 <kmc> that is, that ! is not part of the pattern p, but is part of the syntax of "let"
17:24:30 * wli had the idea at some point of trying to specify exactly what he planned to implement and hasn't gotten off the ground with that, never mind actual code.
17:24:35 <ccasin> wli: sounds like fun - are you doing inference, or demanding annotations.
17:24:39 <kmc> if it were part of p, it would mean "when you evaluate p to whnf, evaluate p to whnf first"
17:24:41 <kmc> which is useless
17:25:04 <dmwit> ccasin: However, if I try let foo = (3, 4) in foo, the bang pattern does compile differently.
17:25:21 <wli> ccasin: I figured I could start off demanding annotations maybe if I get around do it to do inference later. The important part of it was to do something with a module system.
17:26:32 <ccasin> kmc, dmwit: hmm... it's starting to make more sense, thanks
17:26:38 <kmc> what let !p = e in b means is roughly let p = e in p `seq` b
17:26:50 <kmc> that is "when you evaluate the let body to whnf, evaluate p first"
17:27:06 <ccasin> I have very little experience thinking about how bang patterns change thing, mostly I'm blindly stumbling about trying to see why something unexpected takes a long time
17:27:20 <ccasin> kmc: yeah, makes sense, I wasn't thinking about it quite right
17:27:49 <Saizan> kmc: that doesn't explain the observations though
17:27:59 <ccasin> wli: fair enough!  ML modules are pretty tricky, and sometimes play with unification in unexpected ways
17:28:42 <wli> ccasin: For the moment I'm at a loss as to how to even get started, and am not doing too well at even defining the project.
17:29:08 <dmwit> No, I was wrong. I read diff incorrectly.
17:29:21 <dmwit> let foo = (3, 4) in foo compiles to the same thing as with the bang pattern, up to alpha equivalence
17:29:32 <Null-A> kmc: did you get my msg about your fix not working?
17:29:41 <Cale> I rather dislike the new translation of bang patterns in pattern bindings
17:30:05 <kmc> Null-A, no.  it's still getting Any?
17:30:08 <Cale> They have the power to turn let into case, which I find disturbing
17:30:12 <Null-A> kmc: correct :(
17:30:57 <Cale> Even if it would mean that things like  (let !x = ... in ...) would mean the same as without the bang pattern, I think they should have stuck with the original simple translation.
17:31:10 <ccasin> wli: well, is your goal to mimic the modules of a particular programming language, or just to try to add any nice module system to miniml?
17:31:11 <Null-A> kmc: oh wierd, i just tried it again (and my code has changed a lot since, and it works)
17:31:41 <Saizan> Null-A: are you using the bound values now?
17:31:46 <wli> ccasin: To get practice doing some kind of interpretation with a module system.
17:31:55 <Null-A> Saizan: not sure what that means?
17:32:08 <wli> ccasin: O'Caml -style modules are probably the intended model for modules here.
17:32:16 <Null-A> kmc: actually the nomorphism isn't needed either now
17:32:38 <ccasin> Cale: I'm unfamiliar with the change, can you describe it?
17:33:25 <ccasin> wli: the thing about ML and o'caml style modules is that, while they can be specified quite beautifully, they aren't really first-class citizens of the language
17:33:30 <wli> ccasin: "mini-ML" doesn't refer to a specific language but to the idea of a super-stripped down ML-like language, as small as possible to make interpretation easy while being Turing-complete.
17:33:30 <Cale> ccasin: When bang patterns first showed up, they had the rather trivial desugaring where they would turn into some extra seq's on the right hand side of the equation.
17:33:49 <wli> ccasin: Yeah, first-class modules aren't really on the agenda.
17:33:59 <kmc> wli, usually it means not just Turing-complete but capturing some "essential" properties of functional programming
17:34:08 <kmc> whatever the author considers those to be
17:34:16 <Cale> ccasin: But the thing about pattern bindings is that they are always lazy (irrefutable):  (x,y) = ...  behaves just as if it were  ~(x,y) = ...
17:34:26 <kmc> usually abstraction, application, constructors, and pattern-matching
17:34:29 <kmc> probably "let" too
17:34:30 <wli> kmc: Yeah, higher-order functions etc. are intended to be there.
17:34:44 <wli> kmc: Algebraic types, too.
17:35:10 <wli> kmc: Pattern matching I think can be ditched in favor of forcing people to write out case statements.
17:35:13 <Cale> and so !(x,y) = ... would have also worked as ~!(x,y) = ... which is obviously the same as ~(x,y) = ..., since forcing the evaluation once it's already going to happen does nothing.
17:35:13 <ccasin> Cale: I see, and to move those patterns to the right you have to add case
17:35:20 <ccasin> I think?
17:35:56 <Cale> To make  let !(x,y) = u in v  immediately force the evaluation of u, it gets translated into  case u of (x,y) -> v
17:36:36 <ccasin> Cale: right, I guess I'm still as to how the bang patterns got away with out this in the first place
17:36:46 <ccasin> sorry, *still confused as to
17:36:50 <wli> bbiab dinner
17:37:15 <Cale> Well, without that, putting a bang pattern at the top level of a pattern binding does nothing, but I think that's fine.
17:37:25 <ccasin> I see
17:37:29 <Cale> I think that would be the most consistent behaviour
17:38:00 <ccasin> I sort of disagree - ! is supposed to mean some sort of strictness, and irrefutable patterns are very non-strict
17:38:05 <Cale> Well, consistent with the operational idea that  let  doesn't induce any evaluation
17:38:07 <ccasin> but, I can see there is room for debate :)
17:38:11 <Cale> only case does that
17:38:20 <Cale> (that's what case is about)
17:38:29 <ccasin> fair enough
17:38:31 <dmwit> ccasin: You may want to use plain old `seq` or Control.Parallel.Strategies rather than bang patterns.
17:38:43 <dmwit> *may* =)
17:38:52 <ccasin> alas, I am being called away - but thanks for your help thinking about bang patterns, all
17:38:52 <Null-A> Checkout my JSON parser! (It's not completely standards compliant) http://codepad.org/Ynmv4R7j I can't believe how few lines of code this was
17:39:45 <Cale> My operational picture of things is that let expressions control the heap, and case expressions control the stack.
17:39:54 <Null-A> I took the ApplicativeParsec thing from realworldhaskell, i'm not sure if this is still necessary these days...
17:40:40 <kmc> Null-A, looks great :)
17:40:43 <Cale> Null-A: pretty cool :)
17:41:04 <Null-A> thanks for your help =)
17:41:34 <kmc> Null-A, btw i think ApplicativeParsec is not necessary with parsec3
17:41:48 <kmc> i don't remember if the latest Haskell Platform has parsec 2 or 3
17:42:00 <kmc> its name is also shortened (thankfully!) to Text.Parsec
17:42:07 <Null-A> Oh nice
17:42:16 <Null-A> so that must mean I don't have parsec 3 then
17:42:30 <kmc> i think the old name is also kept for compatibility?
17:42:40 <kmc> Null-A, it's possible that your "Any" problem went away because some other code you wrote constrained the type of something
17:42:51 <Null-A> *nods*
17:43:18 <kmc> this is a slightly unfortunate property of type inference; type errors can go away because of non-local changes
17:43:25 <kmc> (or show up again)
17:43:44 <kmc> the guideline is to put a signature on every top-level binding, which prevents this pretty well
17:44:06 * Saizan mutters something about principal types
17:44:23 <Cale> I wonder if the Any thing showed up because of extended defaulting in GHCi somehow?
17:44:45 <Cale> I suppose that can't be the explanation if all the definitions were in the file...
17:45:01 <Saizan> it's just what GHC picks when there's a monomorphic variable that doesn't get unified to anything
17:45:35 <Cale> Isn't that supposed to be a type error though?
17:45:50 <ddarius> Yes, Parsec 3 includes an Applicative instance.
17:46:23 <Saizan> Cale: it's a type error only if it has a typeclass costraint and there's no defaulting rule associated
17:46:48 <BMeph> If you sub liftA2 for liftM2 in the entry defn, can you drop the Monad dependency?
17:46:55 <gwern> ah, a good mention of LYAH: http://www.smashingmagazine.com/2010/05/15/why-a-tale-of-a-post-modern-genius/
17:46:59 <gwern> who wrote lyah anyway?
17:47:01 <kmc> :t foldr (<|>) empty
17:47:02 <lambdabot>     Ambiguous occurrence `empty'
17:47:02 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
17:47:02 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
17:47:06 <kmc> :t foldr (<|>) Control.Applicative.empty
17:47:07 <lambdabot> forall (f :: * -> *) a. (Alternative f) => [f a] -> f a
17:47:10 <kmc> does that have a name?
17:47:18 <Cale> gwern: bonus
17:47:32 <gwern> @tell bonus lyah: http://www.smashingmagazine.com/2010/05/15/why-a-tale-of-a-post-modern-genius/
17:47:32 <lambdabot> Consider it noted.
17:47:37 <gwern> @flish
17:48:54 <Null-A> It's been a long time since I've forgotten to eat meals while programming, only a good sign for haskell =)
17:49:10 <kmc> haha
17:50:43 <Null-A> parsec 3 isn't in haskell 2010 afaik
17:52:18 <BMeph> kmc: "aconcat", perhaps...
17:52:53 * Saizan wonders if the new type inference machinery could support partial type signatures
17:54:27 <kmc> uhc has those iirc
17:54:31 <kmc> would be nice
17:54:49 <kmc> @hoogle (Alternative f) => [f a] -> f a
17:54:49 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
17:54:49 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
17:54:49 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
17:55:01 <kmc> ah tricky, putting it in Foldable
17:55:02 <kmc> :t asum
17:55:02 <lambdabot> Not in scope: `asum'
17:55:37 * Null-A upgrades to parsec3 and applicative stuff is there
17:55:51 <gwern> did haskell98 specify parsec-2 when I wasn't looking?
17:56:14 <kmc> Null-A, it's not, but Haskell 2010 is a different thing from Haskell Platform 2010.1.0.0
17:56:25 <Null-A> oh right
17:56:27 <Null-A> I meant the later
17:56:52 <kmc> Null-A, anyway, you could write p_value as asum [JString <$> stringLiteral, JNumber <$> natural, ... ]
17:56:59 <kmc> Null-A, whether that's better than what you have is debatable
17:57:10 <Null-A> "as a sum" *
17:57:15 <kmc> slightly lighter syntax
17:57:27 <kmc> Null-A, using the function "asum" from Data.Foldable
17:57:32 <Null-A> oh
17:57:37 <Null-A> cool thanks
17:57:45 <kmc> :t msum
17:57:46 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
17:57:54 <Null-A> :t asum
17:57:55 <kmc> is in Control.Monad and will also work here, but is less general
17:57:56 <lambdabot> Not in scope: `asum'
17:59:17 <danharaj> So I'm rewriting my parser for my minilanguage. Instead of trying to type check while parsing, I just parsed into a syntax tree with no type information. I'm not entirely sure how to type check and add type information to the data now.
17:59:29 <kmc> danharaj, your typed syntax is a GADT?
18:00:59 <danharaj> kmc: Yeah, and my untyped tree doesn't, but the language is simple enough that I can figure out the type of a tree expression/whether it is well typed or not. I'm just not sure how to translate it into an expression (GADT value)
18:01:58 <danharaj> (I can't wait for my copy of Pierce to arrive so I can start working implementing those :)
18:02:06 <Saizan> data Term ty where ...; data Exists f where Exists :: f a -> Exists f; typecheck :: AST -> Exists Term
18:03:07 <kmc> Saizan, pros/cons of using a generic existential like that, versus making one explicitly?
18:03:09 <danharaj> Saizan: The problem is that if you try to make typecheck recursive, how can the nodes higher in the true know what the type of its children are if they're wrapped in an existential?
18:03:21 <danharaj> tree*
18:03:27 <Saizan> well, add a Maybe, unless all the ASTs are welltyped
18:04:07 <Saizan> kmc: i didn't have to invent a specific name
18:04:09 <kmc> danharaj, this may be useful: http://augustss.blogspot.com/2009/06/more-llvm-recently-someone-asked-me-on.html
18:04:33 <kmc> an excellent read
18:04:43 <Saizan> danharaj: i wouldn't recurse with typecheck directly
18:04:47 <kmc> in particular the section "The TExp module" deals with this problem
18:04:56 <kmc> and i don't remember how so i'm reading it again ;)
18:06:32 <danharaj> The way I'm thinking about it is that I want to work with type values at run-time, but I'm not sure that is how things are done in Haskell.
18:06:39 <copumpkin> omg
18:07:04 <ddarius> copumpkin: ?
18:07:19 <copumpkin> I forgot what I was omging about
18:07:38 <kmc> danharaj, this one has object-language types represented both by Haskell values and by Haskell types
18:08:28 <danharaj> kmc: Alright, I'm reading it right now. We'll see if I can manage it. Got 3 hours of sleep last night and I've been out all day.
18:08:30 <copumpkin> oh, I was asking yesterday
18:08:56 <Saizan> (it's nice how what should be an argument can be part of the result if you just admit failure..)
18:09:18 <copumpkin> does anyone know of a good resource discussing CPS from the point of view of curry-howard and (for example) how existentials are related to cont. monochrom gave me one article by sigfpe yesterday but it didn't cover the kinds of things I was hoping
18:09:36 <copumpkin> there's a missing question mark somewhere in there
18:09:56 <Null-A> what do you guys think is the best editor for haskell?
18:10:01 <copumpkin> ed
18:10:03 <copumpkin> it's all I use
18:10:07 <Null-A> seriously?
18:10:09 <copumpkin> no
18:10:18 <Null-A> :-P
18:10:19 <copumpkin> I just use textmate
18:10:29 <Null-A> ah, *nods* i'm on mac, but I never really got hooked
18:10:55 <Null-A> i don't mind emacs or vim, because they both support the vim editing commands ^_^
18:12:36 <ddarius> copumpkin: Lectures on the Curry-Howard Isomorphism has a section on classical logic.
18:13:07 <copumpkin> http://folli.loria.fr/cds/1999/library/pdf/curry-howard.pdf ?
18:13:16 <copumpkin> looks good
18:13:23 <copumpkin> thankee!
18:14:30 <ddarius> copumpkin: It's mentioned there, but you probably also want to explicitly look at Parigot's lambda-mu calculus.
18:14:49 <danharaj> Lectures on the Curry-Howard Isomorphism is a great book
18:17:38 <wli> Okay, back. Where was this wrt. mini-ML?
18:18:25 <copumpkin> ddarius: anything like a simple list of correspondences between logical constructs and CPS-like stuff?
18:20:56 -ChanServ(ChanServ@services.)- Saizan set flags +votsriRfA on pumpkingod.
18:21:17 --- mode: ChanServ set +o copumpkin
18:21:25 --- mode: ChanServ set -o copumpkin
18:21:31 <ddarius> copumpkin: See the embeddings discussed in that chapter.
18:21:39 <wli> I'm at a total loss as to how to write a spec for this.
18:21:44 <danharaj> page 140, section 6.4
18:21:45 <danharaj> just checked :)
18:22:06 <danharaj> Right after a discussion of the lambda-mu calculus.
18:22:43 <mail> too much high level stuff here
18:22:52 <copumpkin> mail: like what?
18:23:10 <wli> Grammars and judgments should crop up at some point.
18:24:04 <danharaj> kmc, Saizan: Thanks for your help and resources. I think I have an idea of what I'm going to do now.
18:25:25 <copumpkin> hmm, my college isn't letting me grab that lambda-mu calculus paper
18:25:28 <copumpkin> I think it's too old
18:25:42 <danharaj> I can try for you.
18:25:53 <Veinor> I got it.
18:26:08 <danharaj> oh god springer fucking fascists
18:26:29 <copumpkin> damn, Veinor's school is better than mine :P
18:26:36 <danharaj> mine too :|
18:26:42 <copumpkin> damn you and your bigger endowment ;)
18:26:44 <Veinor> http://www.amateurtopologist.com/curry-howard.pdf
18:26:48 <danharaj> Almost never is it that I can grab a springer paper.
18:26:57 <copumpkin> Veinor: oh, I meant the lambda-mu calculus
18:26:57 <Veinor> copumpkin: :P
18:26:59 <Veinor> oh
18:27:09 <copumpkin> http://www.springerlink.com/content/5x552812m8150709/
18:27:25 <Veinor> gimme a sec
18:27:26 <copumpkin> I think my college only bought up ti 1994
18:28:26 <danharaj> Mine only has it back to 97 :|
18:28:39 * BMeph imagines a "Ron Jeremy Research University...it's well-endowed!"
18:28:48 <copumpkin> lol
18:29:06 <Veinor> k, got it
18:29:12 <Veinor> http://www.amateurtopologist.com/fulltext.pdf
18:29:30 <copumpkin> okay, now I can damn you and your bigger endowment
18:29:47 <danharaj> Heh.
18:29:51 <copumpkin> (thanks!)
18:29:58 <JasonFelice> So, say you are writing a wrapper for SANE, and you have foreign functions which take a while.  We don't expect these to play well with GHC threads, now, do we?  What to do?
18:30:13 <Veinor> no problem :P
18:30:33 <copumpkin> danharaj: page 140, section 6.4?
18:31:10 <copumpkin> JasonFelice: just use forkOS to make bound threads, if your FFI library has expectations about specific threads
18:31:49 <Veinor> forkOS: an OS based on forks!
18:32:10 <JasonFelice> forkOS = BSD ?
18:32:23 <Veinor> :P
18:32:24 <copumpkin> forkBombOS
18:32:56 <kmc> JasonFelice, forkOS is roughly the same as forkIO, but it guarantees that successive FFI calls from the forked Haskell thread will be made by the same OS thread
18:33:29 <kmc> (there is a common misconception that forkOS will cause your haskell code itself to run in its own OS thread, largely due to the poorly chosen name)
18:33:45 <kmc> (but the only guaranteed difference between forkIO and forkOS is with respect to FFI calls)
18:33:57 <aavogt> forkFFIOS?
18:33:58 <JasonFelice> I thought that forkIO did the not-real-thread stuff for Haskell code, and therefore my foreign functions would block.
18:34:03 <copumpkin> not that the distinction really matters
18:34:27 <kmc> JasonFelice, if by "not real" you mean "not OS threads" then yes, but it will prevent a blocking FFI call from blocking the whole Haskell system
18:34:39 <kmc> this is important because for example all IO is implemented by FFI calls
18:35:18 <JasonFelice> OK, now my brain hurts.  Of course, this is par for the Haskell course, but... how does it do _that_?
18:35:25 --- mode: ChanServ set +o copumpkin
18:35:36 <ddarius> copumpkin revels in his new power
18:35:41 <kmc> JasonFelice, by having some OS threads sitting around chilling out, which are only responsible for making FFI calls on behalf of a Haskell-executing thread
18:35:43 <copumpkin> just trying to figure something out
18:35:57 --- mode: ChanServ set -o copumpkin
18:36:09 * copumpkin is done, sorry!
18:36:30 <kmc> JasonFelice, remember that your Haskell-level threads are already moving between OS threads frequently.  it's plausible for them to move to special OS threads for FFI calls
18:36:39 <JasonFelice> kmc: ah, we call that "thread pool pattern" at work.  Apparently previous maintainers of my C++ code at work thought "lots of threads = fast, so lets make large pools of idle ones."
18:36:47 <kmc> yeah
18:37:05 <pikhq> Ouch. That *hurts*.
18:37:13 <kmc> ob. snark: GHC Haskell has libraries or language features for a lot of things that are "design patterns" in other languages
18:37:21 <Saizan> JasonFelice: basically, if you compile your program with -threaded and these C functions don't use thread-local state everything works fine
18:39:36 <aavogt> Saizan: what was that about using GADTs to avoid one instance of Apply for every polymorphic function you want to apply to a HList?
18:41:38 <Saizan> aavogt: well, basically that if your HList is a recursive GADT indexed by the types, you can naturally recurse over it, you might need other gadts to witness typeclass contexts though
18:41:44 <copumpkin> "I know many languages and in my professional opinion ruby is for faggots."
18:41:48 <copumpkin> choice quotes from proggit
18:41:53 <kmc> ahahaha
18:42:14 <kmc> is that as a professional programmer or as a professional faggot?
18:42:40 <copumpkin> can I ask that?
18:42:48 <kmc> you probably should
18:43:12 <kmc> god hates ruby
18:43:34 <danharaj> If the universe were coded in ruby it would restart every twenty seconds.
18:43:41 <Veinor> no, you're thinking of pHP
18:43:48 <copumpkin> ruby isn't that terrible
18:43:56 <copumpkin> but it's not that great either
18:44:27 <pkrumins> God wrote the Universe in Perl anyway.
18:44:43 <digitteknohippie> its all starting to come back to me...  poking around in hackage.haskell.org, searching with hoogle,   ....
18:44:48 <danharaj> pkrumins I think you stepped in some failkcd on the way in.
18:44:57 <edwardk> @hpaste
18:44:57 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:45:03 <pkrumins> danharaj: not at all.
18:45:09 <kmc> if the universe were coded in Haskell, it would have the property that outcomes of physical events are not determined until they are observed
18:45:10 <kmc> :O
18:45:11 <copumpkin> omg it's edwardk
18:45:29 <Saizan> aavogt: http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=16763 <- related http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16763
18:45:31 <danharaj> kmc: Quantum is a monad.
18:45:36 <danharaj> (or something :p)
18:45:37 <kmc> it's an arrow on hackage
18:45:44 <copumpkin> If a tree falls in a forest and no one is around to force it, does it make a sound?
18:45:54 <copumpkin> quantum-arrow I think
18:45:59 <copumpkin> luqui made it
18:46:00 <kmc> well, there's quantum-arrow, and also QIO, the Quantum IO Monad
18:46:05 <edwardk> hrmm can someone take a look at http://paste.lisp.org/display/99289 and help me figure out what i'm doing wrong with inverseNewton? the example i gave there doesn't seem to work
18:46:12 <kmc> because the regular IO monad doesn't confuse enough people
18:46:19 <copumpkin> oh shit, edwardk needs help, the world will end now
18:46:34 <danharaj> Schroedinger's burrito
18:46:54 <edwardk> possibilities are that i'm a moron and screwed up the jacobian for sqrt, etc.
18:46:59 <edwardk> my calculus is fading fast ;)
18:47:20 <JasonFelice> http://axgle.github.com/images/haskell.jpg
18:47:43 <JasonFelice> (I had to find it after the proggit quote)
18:47:55 <kmc> sigh
18:48:00 <kmc> fuck that picture
18:48:14 <danharaj> hey it's all true
18:48:19 <edwardk> take 10 $ inverseNewton sqrt 1 (sqrt 10) -- should converge to 10 like is does with Numeric.FAD
18:48:25 <danharaj> You can't do haskell without getting balls-deep in theory.
18:48:35 <copumpkin> balls-deep, eh
18:48:56 <edwardk> but i get [1.0,5.324555320336759,14.427179341843509,-3.9252037373700723,NaN,NaN,NaN,NaN,NaN,NaN] so i obviously have a problem with the derivative in question
18:48:57 * BMeph prefers the pic that includes Lisp in the mix...
18:49:09 <JasonFelice> BMeph: I know... I couldn't find it.
18:49:25 <edwardk> OTOH, the zeroNewton examples do work
18:49:37 <copumpkin> edwardk: that looks like a neat module
18:49:55 <edwardk> copumpkin: it will be once it fully works ;)
18:50:01 <gwern> > 20000000000 * 0.03
18:50:02 <lambdabot>   6.0e8
18:50:08 <digitteknohippie> okies, question time... i want to get my bot to be able to do as lamdabot does, returning specific messages, when prompted, and so i can set up more.   like entering "!foobillows" would have the bot return "foobillows is a word digitteknohippie made up for this example".  i was thinking it would be a case of adding to the eval section, like !quit and !id, but am less sure now...
18:50:12 <edwardk> it should make the neural network guys happy, since reverse mode AD is 'the ultimate backpropagator'
18:50:13 <digitteknohippie>  can anyone help me outta this muddle?
18:50:33 <kmc> danharaj, i don't think that's true
18:50:55 <edwardk> once i'm sure the basics are working in can go through and add support for directional derivatives, etc.
18:51:08 <Saizan> digitteknohippie: that would surely work,
18:51:43 <digitteknohippie> do i need to send it through a privmsg too, like in http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot ?
18:52:34 <Saizan> yeah, that's how you send something to a channel
18:52:37 <kmc> privmsg is used by IRC for all "normal" messages
18:52:39 <kmc> including to a channel
18:52:41 <kmc> yes it's confusing
18:52:45 <edwardk> found it. it is indeed my derivative for sqrt
18:52:56 <JasonFelice> Anyway, so what I got is that... since SANE probably doesn't have thread local state, I don't need to worry about long running functions.
18:52:58 <copumpkin> edwardk: ooh, so it all works?
18:53:07 <edwardk> Numeric.FAD.diff2 sqrt 2 and Numeric.RAD.diff2 sqrt 2 disagree
18:53:28 <edwardk> copumpkin: yeah, i just have a few niggling mistakes in my recollection of calc 3 ;)
18:54:23 <kmc> JasonFelice, not effectively
18:54:42 <edwardk> ahh i forgot a sqrt =)
18:54:46 <kmc> JasonFelice, a FFI call could be long-running whether or not it has thread local state
18:54:54 <copumpkin> edwardk: now you need to prove it correct
18:54:56 <kmc> but you don't need to worry about that in any case, as long as you're using a -threaded build
18:55:06 <edwardk> sqrt = liftA1 sqrt (recip . (2*) . sqrt)
18:55:21 <copumpkin> liftA1 :o
18:55:25 <kmc> (i am pretty sure but not 100% sure on that)
18:55:31 <edwardk> now i get [1.0,5.324555320336759,9.269354807297656,9.986142908728961,9.999995196196624,9.999999999999424,10.0,10.0,10.0,10.0]
18:55:31 <JasonFelice> right.  And if I'm not, oh well.  I'm trying to figure out what is "good practice" for cabal packages and long running ffi calls.
18:55:33 <Veinor> now I want steak!
18:55:39 <copumpkin> Veinor: how come?
18:55:44 <Veinor> liftA1
18:55:47 <copumpkin> oh
18:55:48 <copumpkin> lol
18:55:54 <copumpkin> I've never had A1
18:56:01 <Veinor> me neither, I just wanted to make that joke
18:56:04 <copumpkin> :)
18:56:06 <edwardk> liftA1 was taken from pearlmutter and siskind. i don't like the name ;)
18:56:17 <Veinor> also, bleh, stupid fighting between programmers. now my motivation to work on this project is gone
18:56:24 <copumpkin> Veinor: what project?
18:56:29 <Veinor> Remember the Milk bindings.
18:56:29 <digitteknohippie> oh!  so perhaps something like eval h | "!foobillows"  =  privmsg h ~~~~~~~  er, no... i've not quite got this at all yet.  XP
18:56:59 <Veinor> RTM revoked the API key for the Todo iPhone app cause the Todo guys were using it for the iPad version as well
18:57:05 <Veinor> so now I don't have RTM syncing :(
18:57:51 <copumpkin> edwardk: if you were to drop the Num, what kind of real algebraic structures would be needed for this?
18:58:21 <edwardk> copumpkin: same stuff as i need in the forward ad implementation i have
18:58:35 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-Module-AutomaticDifferentiation.html
18:58:50 <copumpkin> oh, I never played with that stuff
18:58:53 <edwardk> sufficiently abstract? =)
18:58:55 <copumpkin> I'll check it out
18:59:09 <copumpkin> RightSemiNearRing r
18:59:10 <copumpkin> lol, yep
18:59:32 <Veinor> Zygohistomorphic prepromorphisms!
18:59:39 <copumpkin> but I dunno, you might want to parametrize your typeclasses over the operations too
18:59:43 <copumpkin> :P
18:59:46 <edwardk> so one should be able to construct a similar tape that let you implement d:: (Bimoduler m,Ringoidm) => (foralls.Ds r m ->Ds r m) -> (r, m) using reverse mode AD
18:59:54 <edwardk> copumpkin: thats what newtypes are for ;)
18:59:57 <Veinor> oh god what the hell
19:00:00 * Veinor 's head explodes
19:00:01 <copumpkin> eww newtypes
19:00:12 <eugenn> Ringoid wtf xD
19:00:17 * copumpkin reluctantly pulls out his mop and starts cleaning up after Veinor 
19:00:27 <Veinor> :P
19:00:43 <edwardk> http://paste.lisp.org/display/99289#1 has the fixed reverse mode ad code
19:00:58 <nominolo> preflex: @users
19:01:07 <edwardk> eugenn: i was taking derivatives of some very very weak structures, since i was using this in parsers, etc. which are only rightseminearrings
19:01:19 <Olathe> What's a good data structure for a Turing machine tape ?
19:01:27 <copumpkin> Olathe: a zipper! ;)
19:01:30 <preflex> sorry, wasn't paying attention
19:01:31 <edwardk> Olathe: data Zipper a = Zipper [a] [a]
19:01:37 <copumpkin> preflex: talk to me
19:01:43 <JasonFelice> So... is there a philosophical reason why bitmap-0.0.1 doesn't have a getPixel?  Any reason I shouldn't be using it as a result type for my scanner package?
19:01:44 <Olathe> Ahh, OK, thanks :)
19:02:03 <gwern> my problem with goproblems.com is that it's not very friendly to users. I'm just going through problems and it's giving me 4 or 6 dan problems. like come on guys
19:02:48 <edwardk> gwern: i just started playing go a little while ago. i must admit it has been amusing after a lifetime of chess
19:02:54 <copumpkin> I just started too!
19:03:08 <gwern> edwardk: now grow a beard and learing unicycling, and then you'll be a true haskeller
19:03:24 <copumpkin> gwern: do you have all those?
19:03:37 <edwardk> hey i already live near cambridge, MA area, what more do you want ;) the beard and unicycle are like standard issue out here ;)
19:03:38 * gwern has a beard but regards unicycling as silly
19:03:51 <copumpkin> lol
19:03:54 <gwern> I may re-earn my geek cred with juggling though
19:04:04 <copumpkin> gwern: how long is your hair?
19:04:11 <edwardk> shapr got my wife up on the unicycle, but i never got a chance to try it before he left the area
19:04:22 <gwern> copumpkin: somewhere between kempt and unkempt
19:04:33 <digitteknohippie> in "eval h x | "!id " `isPrefixOf` x = privmsg h (drop 4 x)" what does the "(drop 4 x)" mean?  x relates to the input info? and the drop 4....?
19:04:46 <pikhq> gwern: That's a description of level of maintainance, not length.
19:04:56 <copumpkin> digitteknohippie: it means you don't want the "!id " in front
19:04:59 <gwern> pikhq: no more than half an inch then >.< sheesh
19:05:00 <edwardk> i picked up some contact juggling when shapr was in the area, but that is about the extent of my hippie pursuits ;)
19:05:09 <digitteknohippie> oh right.  :)
19:05:13 <pikhq> One can have kempt 5 foot long hair, and unkempt 1 inch long hair. :P
19:05:26 <pikhq> (though the latter would take actual work to manage.)
19:05:28 <gwern> even gandalf or dumbledore can't do a kempt 5ft beard
19:05:36 <aavogt> digitteknohippie: that would be nicer as:    eval h (stripPrefix "!id " -> Just x) = privmsg h x
19:05:48 <pikhq> gwern: A wizard's beard cannot be kempt!
19:06:07 <pikhq> That is the source of true magic!
19:06:12 <gwern> pikhq: who are you to say so? meddle not in their hygiene
19:06:20 <copumpkin> edwardk: you should pick a ridiculously general package name for this, just to piss people off
19:06:25 <copumpkin> @hackage algebra
19:06:26 <lambdabot> http://hackage.haskell.org/package/algebra
19:06:27 <copumpkin> for example
19:06:43 <edwardk> copumpkin: it'll probably be 'rad' to go with pearlmutter and siskind's 'fad'
19:06:52 <copumpkin> that's like totally rad
19:07:12 <kmc> what's the best way to make a joinable thread?
19:07:27 <aavogt> digitteknohippie: or if you don't want -XViewPatterns:   eval h x | Just x <- stripPrefix "!id " x = privmsg h x
19:07:31 <copumpkin> kmc: a MVar?
19:07:34 <edwardk> if i wanted to be more individualistic i'd go and bundle up a reverse mode and a forward mode ad into one package, figure out a reverse mode tower, etc. but it doesn't seem to be worth the effort at the moment ;)
19:07:41 <kmc> is there a nice wrapper
19:07:48 <copumpkin> kmc: don't think so
19:07:51 <kmc> :/
19:08:02 <kmc> it shouldn't be necessary to expose the MVar to the person doing the spawning
19:08:02 <copumpkin> make a nice abstract joinable-thread package :)
19:08:20 <copumpkin> I agree
19:08:28 <aavogt> "expose your MVar!"??
19:08:37 <copumpkin> you should find a nice way to abuse Monad's join ;)
19:08:41 <kmc> i really like this style of concurrent programming with actions that close over thread communication constructs
19:08:43 <kmc> haha
19:08:58 <kmc> it basically works out of the box
19:09:03 <kmc> because i have spawn :: IO () -> IO (IO ())
19:09:12 <digitteknohippie> thnx for all that aavogt, but what i'm really after is getting it to return a specific message relating to a specific input.     like entering "!foobillows" would have the bot return "foobillows is a word digitteknohippie made up for this example".     rusty noob, so its taking a little while to get this.
19:09:13 <copumpkin> that's comonad!
19:09:23 <kmc> yeah
19:09:30 <kmc> what else do i need to make an IO comonad?
19:09:42 <copumpkin> unsafePerformIO ;)
19:09:49 <danharaj> kmc: Bimonad
19:09:51 <edwardk> kmc: io as a comonad doesn't work
19:09:58 <kmc> actually it should be:   IO a -> IO (IO a)
19:10:02 <kmc> which yes is co-join or whatever
19:10:08 <edwardk> kmc: duplicate
19:10:08 <aavogt> it works if you like incorrectness
19:10:21 <copumpkin> :t unsafePerformIO
19:10:22 <lambdabot> Not in scope: `unsafePerformIO'
19:10:29 <copumpkin> @hoogle unsafePerformIO
19:10:30 <lambdabot> Foreign unsafePerformIO :: IO a -> a
19:10:30 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
19:10:32 <copumpkin> copoint!
19:10:35 <edwardk> aavogt: it works fine as long as you have linearity in your type system
19:10:39 <danharaj> Is it coUnsafePerformIO or unsafeCoperformIO?
19:10:39 <copumpkin> or extract
19:10:52 <copumpkin> nah, it's already the opposite of return!
19:11:07 <aavogt> edwardk: which is missing
19:11:10 <edwardk> extract = unsafePerformIO makes me twitch ;)
19:11:12 <kmc> ah http://hackage.haskell.org/package/threads is like what i wanted but better
19:11:32 <copumpkin> and unsafePerformIO even satisfies the Copointed laws!
19:11:34 <copumpkin> sweet!
19:11:34 <aavogt> digitteknohippie: so you should keep an  IORef (Map String String) ?
19:11:51 <gwern> copointed laws?
19:12:05 <edwardk> aavogt: a lot of stuff, look up the 'OI' comonad and what was done there. it didn't think about the fact that every functor in Hask is strong, etc. its really just a misapplication of an idea.
19:12:22 <aavogt> I've read that one
19:12:40 <kmc> oi!
19:12:47 * copumpkin submits a proposal to libraries to add instance Copointed IO to the prelude
19:12:57 * digitteknohippie reads n rubs chin
19:13:12 <aavogt> hmm, I forgot to put a deadline for a libraries proposal
19:13:24 <gwern> what is copointed IO and why would one want it?
19:13:41 <copumpkin> gwern: Pointed gives you a -> f a, and Copointed gives you f a -> a
19:13:48 <copumpkin> Pointed f and Copointed f, that is
19:13:56 <copumpkin> basically pure
19:14:02 <copumpkin> and impure ;)
19:14:08 <dolio> You should wait for your proposal to add Copointed to the prelude to go through.
19:14:19 <aavogt> it will address all these complaints about getting this about getting things out of IO
19:14:30 <gwern> copumpkin: but don't lots of monads/f not have copoints?
19:14:46 <copumpkin> gwern: yeah, it'd be a typeclass that some functors belong to and others don't
19:15:23 <aavogt> copumpkin: is it sensible to keep copointed separate from comonad?
19:15:24 <copumpkin> like, IO is copointed, and Maybe isn't ;)
19:15:24 <gwern> are there very many that belong?
19:15:34 <gwern> copumpkin: and lists, aren't copointed
19:15:40 <copumpkin> yep!
19:15:42 <copumpkin> ST s is
19:15:50 <dolio> All comonads are copointed.
19:15:53 <aavogt> Writer is
19:15:54 <copumpkin> (I'm just kidding, by the way)
19:16:01 <gwern> and how is IO copointed?
19:16:17 <copumpkin> IO a -> a is the right shape
19:16:37 <dolio> ST s is not copointed.
19:16:45 <aavogt> dolio: yes, so are there any instances that have    w a -> a, but not   w a -> w (w a)
19:16:53 * Saizan eats pop corns as gwern gets walked through this
19:17:00 <copumpkin> dolio: it should be
19:17:09 <copumpkin> if the haskell gods were nicer
19:17:10 <gwern> copumpkin: but unsafePerformIO doesn't really count does it...
19:17:13 <dolio> aavogt: Are there any instances that have a -> m a but not m (m a) -> m a?
19:17:18 <copumpkin> gwern: yeah, I was being stupid for a change :)
19:17:24 <aavogt> dolio: yes
19:17:31 <edwardk> copumpkin: i'd argue that you are mistaken. you can throw in IO ;)
19:17:38 <dolio> copumpkin: It'd only be copointed for unsafePerformST.
19:17:39 <ddarius> There is a library on hackage somewhere which includes a function for joining multiple threads.
19:17:44 <edwardk> copumpkin: an IO a doesn't necessarily contain a value of type a
19:17:52 <digitteknohippie> okies, haskell.org has brought me cunningly to Control.Concurrent.MVar  ...   and i need a break.   bbs
19:18:01 <copumpkin> edwardk: that's impure stuff, I just plug my ears and go "lalalala"
19:18:15 <edwardk> copumpkin: but unsafePerformIO is pure? =)
19:18:20 <danharaj> IO is a perverse monad.
19:18:20 <copumpkin> yeah!
19:18:28 <digitteknohippie> lol
19:18:43 <aavogt> @type copumpkin
19:18:44 <lambdabot> Not in scope: `copumpkin'
19:18:47 <gwern> @quote Mordor
19:18:47 <dolio> edwardk: If it weren't pure, the type would be IO a -> IO a.
19:18:47 <lambdabot> Badger says: one does not simply >>= into mordor
19:19:05 <danharaj> Wouldn't that be out of mordor?
19:19:42 <danharaj> One does not simply unsafeWalkIntoMordor.
19:19:51 <dolio> aavogt: I suspect the answer is the same for cojoin, although I don't have a battery of copointed functors to back that up.
19:19:54 <gwern> @quote unsafe.*Mordor
19:19:54 <lambdabot> c_wraith says: oh.  well, then.  some actually *do* simply unsafePerformIO into Mordor.
19:19:57 <geheimdienst> couldn't we view mordor as a monad which needs a value injected
19:20:40 <geheimdienst> one does not simply return rings into mordor
19:20:53 <geheimdienst> hm ...
19:22:10 <allbery_b> how about semigroups?
19:22:12 <Olathe> What's a good way to parse a string with, say, matching parentheses (and other stuff) ? I need to somehow keep track of where I am in the string as I iterate, but also as I recurse and return from a recursive call.
19:22:37 <dolio> With a pushdown automaton.
19:22:51 <Olathe> Ahh, OK.
19:23:01 <Olathe> Thanks :)
19:23:09 <mauke> you could use a counter
19:23:26 <dolio> Since you only need one symbol on the stack, you could probably get by with just an integer.
19:23:32 <dolio> As mauke says.
19:23:58 * copumpkin makes a dirty joke about dyck
19:24:01 <mauke> or return the remaining string from your parser so you know where to continue
19:24:02 <gwern> could probably get by with just a Nat too
19:24:17 <gwern> unless you expect many malformed strings like ())) :)
19:24:34 <dolio> Yeah, but we don't have those readily available.
19:24:41 <copumpkin> well, even with nat
19:24:43 <edwardk> hrmm, i'm trying to figure out the nicest way to extend the reverse mode AD code so i can mix up the types inside of my derivatives.
19:24:47 <copumpkin> if you ever want to go negative, you've got a problem
19:24:56 <Null-A> How do I modify the Parsec Monad to include some of my own data?
19:25:08 <gwern> dolio: pfft. what's Nat but a line of code or two?
19:25:33 <danharaj> Null-A : Do you mean give the parser user defined state?
19:25:35 <dolio> gwern: Actually, I guess you only need to import Data.Word.
19:25:40 <Null-A> danharaj: yah
19:25:52 <dolio> It's unlikely that his string will have enough parentheses in a row to overflow one.
19:25:53 <kmc> Null-A, include where?
19:25:55 <gwern> dolio: Nat's easier and probably shorter
19:25:58 <aavogt> > -1 :: Word
19:25:59 <lambdabot>   18446744073709551615
19:26:02 <copumpkin> mmm
19:26:13 <gwern> > maxBound :: Word
19:26:14 <lambdabot>   18446744073709551615
19:26:18 <Null-A> danharaj: I'm looking at an example that calls ReaderT UserType IO, if I place IO with the Parsec one, this should work?
19:26:27 <dolio> How is it easier?
19:26:31 <edwardk> data Tape a t = C a | V a Int | forall b c. (Num b, Num c) => B a (a -> (b, c)) (t b) (t c) | forall b. Num b => U a (a -> b) (t b) -- could be made to work but i'd have to pay for it with a lot of unsafeCoerce machinery and i'm paying to store those Num dictionaries
19:26:39 <danharaj> I don't know Null-A, I haven't used the user state capability of parsec.
19:26:54 <edwardk> plus i'd have to reimplement Data.Reify
19:26:54 <aavogt> it's the same as using some normal state monad
19:26:55 <gwern> dolio: well, just constructors, as opposed to strange data and operators
19:26:58 <Null-A> kmc: so the data  gets passed around automatically in all my parsing funcs
19:27:10 <gwern> dolio: also Nat is closer to the semantics etc
19:27:13 <kmc> Null-A, some static data? or mutable state?
19:27:26 <Null-A> mutable
19:27:42 <dolio> > let fact :: Word -> Word ; fact 0 = 1 ; fact (n+1) = (n+1) * fact n in fact 9
19:27:43 <lambdabot>   mueval-core: GhcException "panic! (the 'impossible' happened)\n  (GHC versi...
19:27:46 <Null-A> It changes inside the parsing funcs kmc
19:27:52 <dolio> Wow.
19:28:15 <Null-A> kmc: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot there's an example here where they 'wrap over' the IO monad
19:28:25 <Null-A> kmc: do you think I could do it the same way?
19:28:25 <gwern> dolio: see?
19:28:32 <dolio> :)
19:28:32 <kmc> yes, using StateT
19:28:48 <kmc> Null-A, there they only use ReaderT
19:28:56 <Null-A> oh ok
19:29:03 <Null-A> i'll give this a shot
19:29:05 <kmc> Null-A, also in parsec3, ParsecT itself is a monad transformer so you could stack state underneath
19:29:34 <aavogt> parsec has user state
19:29:35 <kmc> @unmtl StateT s (CharParser ()) a
19:29:35 <lambdabot> s -> CharParser () (a, s)
19:29:41 <aavogt> there is no need to use StateT
19:29:44 <kmc> yeah
19:30:12 <kmc> :t Text.ParserCombinators.Parsec.getState
19:30:12 <copumpkin> what's the CT interpretation of monad transformers btw?
19:30:12 <lambdabot> forall s u (m :: * -> *). (Monad m) => Text.Parsec.Prim.ParsecT s u m u
19:30:18 <kmc> :t Text.ParserCombinators.Parsec.setState
19:30:18 <lambdabot> forall u s (m :: * -> *). (Monad m) => u -> Text.Parsec.Prim.ParsecT s u m ()
19:30:37 <glguy> Parsec's user state is different than stacking user statck above or under parsect
19:30:52 <glguy> it threads through and backtracks differently than either
19:31:15 <edwardk> copumpkin: they are somewhat adhoc, usually built off of the existence of a distributive law
19:31:22 <copumpkin> ah
19:31:44 <copumpkin> I was thinking about the ListT thing and why it's evil
19:31:50 <dolio> Except that's not true for several.
19:32:01 <edwardk> mark p jones gave a nice library of ways to build monads off of monads, a pointed functor and a distributive law of one of a few flavors which covers most of the transformers
19:32:05 <dolio> StateT is not a distributive law.
19:32:14 <edwardk> dolio: hence why i said usually =)
19:32:23 <dolio> It only permutes half way.
19:32:27 <edwardk> yep
19:32:34 <aavogt> though applicatives compose in general, it doesn't look like people do that often because then you need different <*>
19:32:55 <edwardk> state is given rise to by an adjunction (well, all monads are) it just sandwiches the adjunction around some other monad
19:33:32 <kmc> let's all use type-level monad zippers
19:33:42 <edwardk> kmc: sure, you first
19:33:54 <copumpkin> monad zippers give rise to comonads!
19:34:10 <kmc> do they really
19:35:35 <copumpkin> ezyang: did you ever succeed in your proof?
19:35:49 <dolio> edwardk: I guess ReaderT isn't, either. It just sticks an (r ->) on. The positive stuff gets distributed, but not the negative stuff.
19:36:39 <Saterus> hayoo is down?
19:37:03 <Null-A> kmc: when I add setState to my monad, I get type inference error, do you think using Parsec.Token is forcing a state type of () ?
19:37:14 <Null-A> kmc: to my parsing funcs*
19:38:16 <kmc> Null-A, that'd be sad
19:38:21 <edwardk> dolio the mark p jones stuff took one of 3 kinds of laws: m (n a) -> n (m a), m (n a) -> m a or n (m a) -> m a
19:38:22 <copumpkin> what channels does xahlee hang out in?
19:38:25 <Null-A> lol
19:38:36 <edwardk> dolio: i guess only the first of those could be considered 'distributive' =)
19:41:05 <gwern> copumpkin: I don't think xahlee hangs out anywhere for long
19:41:28 <copumpkin> gwern: I dunno, he looks fairly unidle on freenode right now, but it won't let me see what channels he's in :(
19:41:42 <gwern> think I've seen him in #scheme and #emacs though
19:42:32 <mauke> preflex: xseen xahlee
19:42:32 <preflex>  xahlee was last seen on freenode/##javascript 27 days, 9 hours, 42 minutes and 6 seconds ago, saying: ic
19:42:40 <dolio> He's been pretty quiet on comp.lang.functional lately.
19:43:09 <dolio> c.l.f has been mostly spam for a while now.
19:43:45 <gwern> 'and with strange eons, even IE may die'
19:44:37 <gwern> dolio: maybe he's finally trolled too much; or maybe he was a supernatural puppet of Naggum and his psychospiritual reservoirs have been drained
19:44:49 <gwern> alternately, some meddlesome kids may've destroyed his horcruxes
19:44:58 <copumpkin> lol
19:45:31 <gwern> hormacros?
19:49:07 <Olathe> Is there any nicer way to do this: http://codepad.org/TrZTkwpG ?
19:49:33 <copumpkin> aw brainfuck
19:49:41 <Olathe> Yes :)
19:50:06 <gwern> just reuse our existing bf package
19:50:10 <Saterus> hayoo is down?
19:50:12 <kmc> Olathe, build a (Data.Map.Map Char TuringCommand)
19:50:36 <Olathe> How would I handle the While [TuringCommand] stuff ?
19:50:57 <kmc> specially, perhaps
19:51:15 <kmc> it would save you the boilerplate for 6 cases
19:51:48 <kmc> i was wondering this though, what's the best way to write a parser for matching parentheses
19:51:58 <aavogt> Map gives up some static checking
19:52:00 <kmc> without using a library like Parsec
19:52:09 <copumpkin> kmc: just a nat
19:52:18 <copumpkin> a foldr, probably
19:52:22 <twanvl> kmc: use a stack or if there is only one type, an integer
19:52:26 <kmc> i ended up with something slightly weird that was continuation-based
19:52:31 <aavogt> better to define:   op :: Char -> Maybe TurningCommand
19:52:34 <Cale> Or just use a list of pairs and lookup.
19:52:38 <kmc> let's say: what's the best way to parse s-expressions
19:52:44 <Cale> (the Data.Map might help, but that's a pretty short list)
19:52:47 <kmc> without using Parsec or similar
19:52:53 <copumpkin> kmc: like the full rivest spec of s-expressions? :P
19:52:58 <copumpkin> or just common ones
19:53:18 <kmc> every s-expr is either a word or a parenthesized whitespace-separated list of s-exprs
19:53:27 <kmc> where a word is some lexically obvious thing like alphanumeric characters mushed together
19:53:46 <kmc> anyway if people feel like golfing this i'd be very interested to see the best one
19:54:12 <copumpkin> what's the output? just whether it's well-formed or not as a Bool?
19:54:15 <copumpkin> cause that's easy
19:54:19 <kmc> copumpkin, AST
19:54:24 <copumpkin> ugh! :P
19:56:01 <matt_m> kmc:  There's not really a good way to do that in Haskell, because it's statically typed
19:56:18 <copumpkin> not sure I'd say that
19:56:20 <matt_m> kmc:  There, that ought to do it
19:56:37 <kmc> ?
19:57:00 <copumpkin> data SEXPR = Word String | List [SEXPR]
19:57:19 <kmc> yeah
19:57:22 <kmc> that's the goal
19:58:27 <aavogt>  type SEZPR = Dynamic
20:00:58 <mail> > print lol
20:00:59 <lambdabot>   Not in scope: `lol'
20:01:04 <mail> > print "lol"
20:01:05 <lambdabot>   <IO ()>
20:01:16 <mail> > "lol"
20:01:18 <lambdabot>   "lol"
20:04:16 <twanvl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25516     this is a start, it can probably be done shorter
20:04:33 <twanvl> parsing s-expressions that is
20:05:41 <kmc> mapSnd applies a function to the first element of a tuple?
20:05:56 <twanvl> of course
20:06:01 <kmc> what are the args of go?
20:06:08 <kmc> what's w?
20:06:24 <twanvl> the first argument is "should we start a new word"
20:06:36 <twanvl> it should be True in the first call
20:06:40 <copumpkin> why not just flip the tuple and use fmap?
20:06:44 <tensorpudding> Isn't mapSnd basically fmap using the Functor definition of (,)?
20:06:58 <tensorpudding> Or wait, it's applying it to the first argument..
20:07:04 <copumpkin> it's an odd name :P
20:07:08 <twanvl> :)
20:08:01 <dmwit> More people should import Control.Arrow
20:08:19 <kmc> i wonder if this flag could be expressed better by mutual recursion between two functions
20:08:26 <ddarius> kmc: It can
20:08:37 <kmc> it looks like they share a lot of cases though
20:09:04 <dmwit> > lex "(sexpr lol)"
20:09:05 <lambdabot>   [("(","sexpr lol)")]
20:09:18 <dmwit> > lex ""
20:09:19 <lambdabot>   [("","")]
20:09:22 <dmwit> argh
20:09:31 <dmwit> :t unfoldr
20:09:32 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:09:32 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25517#a25517 this is what i had, not sure why it's continuation-based, it seemed like a good idea at the time?
20:09:36 <kmc> i think using lex is cheating too
20:09:54 <dmwit> > takeWhile (not . null) $ unfoldr (listToMaybe . lex) "(sexpr lol)"
20:09:55 <lambdabot>   ["(","sexpr","lol",")"]
20:10:00 <aavogt> it's in the prelude
20:10:13 <Veinor> heheh, sexpr
20:10:39 <dmwit> > takeWhile (not . null) $ unfoldr (listToMaybe . lex) "(sexpr lol 'but 'quotes 'do 'funny 'things)"
20:10:41 <lambdabot>   ["(","sexpr","lol"]
20:10:44 <copumpkin> @hoogle lex
20:10:45 <lambdabot> Prelude lex :: ReadS String
20:10:45 <lambdabot> Text.Read lex :: ReadS String
20:10:45 <lambdabot> Text.Read.Lex lex :: ReadP Lexeme
20:11:06 <copumpkin> wow, I've been doing haskell for a year and a half and have never heard of that
20:11:28 <dmwit> It's definitely the most monolithic function in the Prelude.
20:11:33 <dmwit> You don't see a lot of call for it.
20:11:37 <aavogt> some day you will know the whole prelude
20:11:41 <copumpkin> seems kind of silly
20:11:47 <copumpkin> is it in h98?
20:11:50 <dmwit> yep
20:11:53 <dmwit> and I agree
20:12:07 <aavogt> it's silly like head and tail
20:15:59 <kmc> i think i decided that continuation passing was cleaner than lots of let-binding of tuples
20:22:23 <gwern> speak of the devil. xahlee just joined #wikipedia
20:22:40 <copumpkin> ooh
20:22:48 <gwern> you don't trust me? :(
20:22:52 <tensorpudding> Who's xahlee?
20:22:53 <copumpkin> I wanted to see him
20:23:16 <gwern> tensorpudding: google will tell you more than you wanted to know
20:23:25 <copumpkin> @quote xahlee
20:23:25 <lambdabot> xahlee says: i do wonder, if any reputable computer scientist would blub out such idiotic things as this thread's lispers have been.
20:23:40 <gwern> copumpkin: well, if you have something to say say it, or I'll look silly
20:23:44 <Olathe> @pl \a -> showChar ',' . a
20:23:44 <lambdabot> (showChar (',') .)
20:23:50 <copumpkin> oh, you shouldn't have told him
20:23:56 <copumpkin> I just wanted to see how crazy he sounded
20:24:10 <copumpkin> now I feel awkward
20:24:30 <tensorpudding> Ooh, I read his Elisp stuff briefly.
20:25:34 <twanvl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25516#a25519  that is likely as short as it will get
20:26:10 <copumpkin> cute
20:26:40 <copumpkin> twanvl: you can shorten it by leaving out the type :P
20:26:50 <gwern> looks better at least
20:26:56 <ddarius> copumpkin: Say you are a big fan.
20:27:03 * geheimdienst realizes Control.Arrow is some kind of mini-parsec :-o It's got many, one, ...
20:27:16 <copumpkin> nope
20:27:24 <copumpkin> he defined many and one in that module
20:27:37 <geheimdienst> no wait
20:27:38 <copumpkin> Alternative does though
20:27:40 <geheimdienst> silly
20:27:48 <copumpkin> :t many
20:27:49 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
20:30:58 * geheimdienst should have more caffeine before "realizing" stuff
20:31:17 <geheimdienst> anyhoo, i was trying to understand this function: http://hackage.haskell.org/packages/archive/X11/1.4.5/doc/html/src/Graphics-X11-Xlib-Extras.html#setClientMessageEvent
20:31:47 <geheimdienst> the C struct that it works with (i think) is: http://tronche.com/gui/x/xlib/events/client-communication/client-message.html
20:32:18 <geheimdienst> so, why is the last 2 args of the haskell function an Atom and a Time? this doesn't make any sense imho
20:33:14 <aavogt> geheimdienst: it makes perfect sense
20:33:38 <aavogt> int format, data, are combined into a single entry 'Time'
20:34:26 <aavogt> well, that source code makes no sense because it's been processed by hsc2hs
20:34:32 <geheimdienst> wait, i thought the CInt was corresponding to int format
20:34:33 <aavogt> geheimdienst: look at the original code
20:34:58 <dons> geheimdienst: yeah, it is a mini-parsec. that was its origins -- parser combinators.
20:35:59 <dons> let's see...
20:40:42 <dons> the first pre-arrows arrows where fudgets (carlsson and hallgren) and parser combinators (swiestra and duponcheel)
20:40:56 * dons works with magnus carlsson, and didn't know he co-invented arrows...
20:44:21 <geheimdienst> i guess what i'm saying is: the C struct has room for 20 bytes and you can look at them as 20 bytes, 10 words, or 5 longs. but even factoring in the latent weirditude of all things haskell, i don't see any sense in treating the 20 bytes as an Atom followed by a Time
20:49:52 <Axman6> "poke        datap   (fromIntegral l_0_) -- does this work?" heh
20:50:03 <sjanssen> geheimdienst: you're right, it doesn't make much sense
20:50:03 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
20:50:31 <sjanssen> geheimdienst: Graphics.X11.Xlib.Extras is basically just a bunch of hacks that were necessary for xmonad
20:50:42 <Axman6> heh
20:50:49 <sjanssen> many of the bindings don't have their full range of functionality
20:51:28 <Cale> I love the  "-- does this work?" :)
20:53:02 <geheimdienst> ok thanks guys
20:53:42 * ddarius has comments exactly like that in his source upon occassion.
20:53:44 * geheimdienst is so happy that for once, it's not his feeble haskell-fu, but rather stuff actually not making sense
20:54:14 <sjanssen> the whole union of char/short/long thing is a bit annoying to model in Haskell
20:55:03 <kmc_> kmc, you bastard
20:55:09 <kmc_> ping out and die
20:55:15 <Cale> It shouldn't be *too* bad since there's a format flag there though.
20:55:17 <geheimdienst> couldn't we say: data Foo = This | That | TheOtherThing ... ?
20:55:34 <Cale> You could just use a normal Haskell union type, and convert back and forth
20:55:57 * digitteknohippie got there.   "   eval h "!foobillows" = privmsg h "foobillows is made up"    "    WOOHOO!
20:57:07 <dons> Cale: i think 'does this work' was me expressing some skepticism
20:57:47 <geheimdienst> well, you were right being skeptical
20:57:53 * BMeph would haved laughed out loud, were dons to have put in this comment: -- is this dangerous?
20:59:24 * geheimdienst thinks someone should compile the "Top 10 Comments You Don't Want to See in the Library's Source"
20:59:43 <aavogt> no comments
21:01:26 * edwardk boggles sometimes at how long the hackage upload process can take
21:01:40 <dons> shouldn't be too bad these days
21:01:44 <dons> all the timeouts went away
21:01:49 <dons> if you're getting  those, i'm surprised .
21:02:03 <edwardk> its just been stuck at 'Uploading ...' for a couple of minutes.
21:02:06 <edwardk> ah there it went
21:02:09 <dons> mmm.
21:02:22 <edwardk> in this era of instant satisfaction i just find it odd
21:03:01 * hackagebot rad 0.1 - Reverse Automatic Differentiation.  http://hackage.haskell.org/package/rad-0.1 (EdwardKmett)
21:03:05 <dons> it recomputes a bunch of catalogues, not sure why we make you wait for that
21:03:09 <dons> but hackage 1.0 is unloved code
21:03:15 <Cale> It's annoying that most (all?) browsers, while they have lovely displays for downloads, typically don't report anything at all about the progress of uploads.
21:03:22 <edwardk> *nods*
21:03:30 <copumpkin> that's totally rad
21:03:36 <edwardk> copumpkin: =)
21:03:40 <copumpkin> oh wait, I already said that earlier
21:03:42 <edwardk> at least its not a fad
21:03:46 <copumpkin> :)
21:03:54 <copumpkin> what do you use reify for?
21:04:07 <geheimdienst> well while uploading just display a link to a random youtube cat video. optimization problem solved.
21:05:08 <edwardk> i record the 'tape' as i go through the computation. i need data-reify to avoid treating a directed graph of jacobians as a tree and thereby seeing combinatorial explosion
21:05:23 <copumpkin> ah
21:05:51 <edwardk> so i use reify to take my 'tape' and generate a graph, topsort the graph, and back-propagate
21:06:21 <copumpkin> yeah
21:06:29 <edwardk> otherwise code like let x1 = x0*x0; x2 = x1*x1; ... x28 =x27*x27 in x28 -- would cost a lot more =0
21:07:07 <edwardk> it is surprising how much code is common to both reverse AD and forward AD
21:07:47 <edwardk> i also cleaned up things and added support for taking the gradient over functions that just use traversable inputs rather than lists, this lets you use arrays, seqs, lists, etc.
21:12:01 <ddarius> edwardk: Why is it surprising?
21:12:48 <edwardk> ddarius: maybe just to me. first time i went about this the code felt significantly different
21:16:58 * ddarius just read "The Hunting of the Snark" a few hours ago.
21:17:04 * hackagebot wai-extra 0.1.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.1.1 (MichaelSnoyman)
21:17:14 <tensorpudding> ddarius: Was it any good?
21:18:51 <ddarius> tensorpudding: It's not as good as Jabberwocky.
21:20:01 <Null-A> Is there a type like Either except for 3 options?
21:20:37 <ddarius> Either a (Either b c)
21:20:58 * geheimdienst considers jabberwocky as good a monad tutorial as any
21:21:07 <Null-A> ddarius: something a little nicer
21:21:22 <Cale> Null-A: Typically, you'd make your own, more descriptive type
21:21:23 <ddarius> Jabberwocky is quite a bit better (even as a monad tutorial) than most monad tutorials.
21:21:28 <Null-A> *nods*
21:22:24 <geheimdienst> null-a, the implementation of Either is just the 3 lines at the top of file://localhost/usr/share/doc/ghc/html/libraries/base-4.2.0.0/Data-Either.html
21:22:29 * ddarius now reads "Hunting for Snarks in Quantum Mechanics" the paper whose abstract inspired me to (re?)read "The Hunting of the Snark."
21:22:55 <geheimdienst> it's little effort to write something like it for 3 options
21:23:06 <Null-A> geheimdienst: lol yah, I now realize this
21:25:24 <tensorpudding> Despite the popularity of Jabberwocky, I remain unimpressed.
21:26:41 <ddarius> "Some readers might like to see string theory on the list, but it doesnt pass the Pauli snark test for a plausible scientific conjecture: Why it isnt even wrong!"
21:27:28 <scriptdevil> Is it possible for someone to add the time complexity of the functions in the the docs?
21:27:40 <scriptdevil> (Just a suggestion)
21:28:08 <Cale> Which functions?
21:28:12 <Cale> All of them?
21:28:13 <aavogt> it is done in containers
21:28:25 <Cale> In many libraries, they're documented.
21:28:28 <scriptdevil> Cale: No. Data.List
21:28:39 <aavogt> @docs Data.List
21:28:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
21:28:43 <Cale> That shouldn't be too hard in general
21:29:08 <aavogt> so it should say, ex.   last :: [a] -> a; O(n)
21:29:11 <Cale> One little problem is that there are at least two time complexities you might be interested in for each function.
21:29:23 <scriptdevil> aavogt: Something of that..
21:29:33 <scriptdevil> Cale: Average case should suffice.
21:29:53 <scriptdevil> Cale: Worst case for some functions that have really awry worst cases
21:29:54 <Cale> (Time to evaluate to WHNF, time to evaluate the resulting list fully)
21:30:23 <Cale> and things are a little weird for higher order functions
21:30:50 <Cale> foldr is O(1) in one sense
21:31:07 <Cale> @src foldr
21:31:07 <lambdabot> foldr f z []     = z
21:31:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:31:26 <Cale> Even though it's recursive, it immediately passes control to f which gets to decide whether to continue or not
21:31:55 <Cale> Though I suppose you might consider the "worst case" to be when f uses its second parameter.
21:32:28 <Cale> But yeah, it would be nice to have this stuff documented more fully.
21:32:58 <copumpkin> oh one thing I've been meaning to ask for months that I keep forgetting
21:33:13 <copumpkin> what is the difference between non-strict and lazy... people seem to point out that haskell is the former a lot
21:33:23 <aavogt> sharing
21:33:24 <Cale> non-strict refers to the semantics
21:33:39 <Cale> The denotational semantics
21:33:52 <aavogt> copumpkin: kindergarten would teach laziness if it was non-strict
21:33:59 <Cale> That is, roughly, what is the termination behaviour of the programs
21:34:15 <dmwit> lazy means non-strict *and* maximally shared evaluation
21:34:18 <Cale> Lazy evaluation is a specific evaluation order which implements non-strict semantics
21:34:31 <Cale> s/order/mechanism/
21:34:46 <aavogt> for all practical purposes, haskell is lazy, no?
21:34:47 <Cale> Lazy evaluation is outermost-first evaluation, plus sharing
21:35:02 <Cale> aavogt: GHC uses a mixture of lazy and strict
21:35:31 <Cale> The evaluation order is unspecified by the language -- the only requirement is that you get the same result as you would get under lazy evaluation.
21:36:07 <Cale> So as long as GHC can prove to itself that it won't cause the program to fail to terminate, it can use strict evaluation in some places to save memory perhaps.
21:36:25 <c_wraith> :t liftA2 (<$)
21:36:26 <lambdabot> forall a (f :: * -> *) b (f1 :: * -> *). (Functor f, Applicative f1) => f1 a -> f1 (f b) -> f1 (f a)
21:36:27 <Cale> (and it does analysis for this purpose)
21:36:55 <c_wraith> I used that expression last night.  I don't know how I feel about itt.
21:37:05 <Cale> But lazy evaluation is a good first estimate for judging performance
21:39:52 <Cale> But the transformations that the optimiser and rewrite rules do are in many cases pretty drastic, and can even affect the asymptotic complexity of your program in some cases, so really all you can do is profile.
21:40:30 <c_wraith> Using quickcheck 2, I wanted to create a Gen (Maybe Int) where the Int portion came from choose (1, 5).  The best I could come up with was liftA2 (<$) (choose (1, 5)) (arbitrary :: Gen (Maybe ()))
21:40:48 <c_wraith> But I was half-asleep, and feel like there should be a cleaner way to do that.
21:43:42 <Cale> frequency [(1, return Nothing), (5, fmap Just (choose (1,5))]
21:44:08 <dmwit> :t guard
21:44:09 <c_wraith> That's a bit shorter, but I'm not sure it's really cleaner. :)
21:44:09 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:44:23 <scoles> I'm using the mongodb package and trying to insert about 60k keys.  I must be doing something wrong because it takes a _very_ long time to do so.  What's the best/simplest way for me to have these insertions and updates happen concurrently?
21:44:38 <dmwit> fmap (\x -> guard (x < 6) >> return x) (choose (1, 6))
21:44:58 <dmwit> I prefer to call that middle function "ensure".
21:45:05 <dmwit> ensure p x = guard (p x) >> return x
21:45:24 <dmwit> fmap (ensure (<6)) (choose (1, 6)) -- reads pretty nicely
21:45:39 <c_wraith> dmwit: I'm not sure that does the same thing
21:46:01 <Cale> oh?
21:46:09 <c_wraith> that looks like it will result in a LOT more Nothings
21:46:15 * dmwit admits that he knows nothing about Gen/Arbitrary/QuickCheck in general
21:46:16 <Cale> Really?
21:46:16 <c_wraith> unless I'm mis-reading something
21:46:27 <c_wraith> oh.  wait.
21:46:29 <Cale> c_wraith: The 6's turn into Nothings
21:46:31 <c_wraith> I see what you're doing.
21:46:55 <dmwit> I wonder if it's worth trying to get "ensure" added to the standard libraries.
21:46:56 <c_wraith> That's just about the same, actually.  quickcheck's arbitrary instance for nothing is somewhere about that same proportion
21:46:58 <dmwit> I use it an awful lot.
21:47:13 <Cale> http://www.marriedtothesea.com/051610/stack-up-lions.gif
21:47:17 <aavogt> it will be an awful lot of effort
21:47:27 <aavogt> dmwit: monad-comprehensions instead?
21:47:33 <dmwit> O_o
21:47:47 <dmwit> Implementing monad comprehensions in GHC is going to be less work than getting ensure into the libraries?
21:47:47 <aavogt>  [ x | p x ]
21:47:53 <dmwit> Just how bad *is* that process?
21:48:12 <aavogt> @quote twitter
21:48:12 <lambdabot> No quotes match. Take a stress pill and think things over.
21:48:16 <aavogt> @quote witter
21:48:17 <lambdabot> No quotes match. There are some things that I just don't know.
21:48:26 <ddarius> Implementing monad comprehensions is probably not too hard.
21:48:41 <ddarius> You could also look at earlier GHC's to see how they did it.
21:48:48 <Cale> They used MonadZero
21:48:55 <Cale> Which doesn't exist anymore
21:49:00 <dmwit> MonadPlus is still around.
21:49:06 <Cale> true
21:49:32 <aavogt> at least in haskell-src-exts and template-haskell, do and list comprehensions are treated very similarily
21:49:50 * wli looked at trying to reintroduce monad comprehensions but didn't get far enough in understanding what was going on to figure out anything.
21:50:07 <aavogt> going on in ghc?
21:50:48 * aavogt supposes you can use a quasi-quote
21:51:07 <glguy> I wasn't sure how to weave it into the code for parallel list comprehensions
21:51:19 <aavogt>  [$c| x | p x |]
21:52:24 <aavogt> there's no generalized zip
21:52:47 <kmc> scoles, did you get an answer?
21:53:52 <kmc> scoles, i know nothing about mongodb but i know how to do concurrency in haskell if that helps
21:53:55 <aavogt> probably nobody here has used the mongodb bindings, and you didn't provide enough information as to what methods you are using to insert those keys
21:53:59 <ddarius> Just poo on parallel list comprehensions.
21:54:28 <kmc> scoles, it is pretty easy to fork a thread for each insert, and this will be pretty efficient on the Haskell side, but perhaps mongodb won't like a bunch of concurrent requests
21:55:32 <scoles> kmc, yeah I was trying to figure out how to do that
21:56:15 <aavogt>  mapM_ (forkIO . yourIOFunctionThatInsertsValue) listOfValues
21:56:20 <kmc> :t forkIO
21:56:21 <lambdabot> Not in scope: `forkIO'
21:56:28 <kmc> :t Control.Concurrent.forkIO
21:56:29 <lambdabot> IO () -> IO GHC.Conc.ThreadId
21:57:06 <kmc> scoles, http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
21:57:31 <kmc> the basic summary is: use forkIO to spawn an IO action as a lightweight Haskell thread
21:57:39 <kmc> use Chan and MVar to communicate between them
21:57:40 <glguy> mapM_ is old-world. traverse_ is the future :)
21:57:44 <kmc> all threads die when the "main" thread dies
21:58:25 <Burning_Aces> a
21:58:44 <aavogt> glguy: unfortunately, those imports get a bit unpleasant
21:58:46 <ddarius> :t traverse_
21:58:47 <lambdabot> Not in scope: `traverse_'
21:59:10 <aavogt> @type Data.Foldable.traverse_
21:59:11 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
21:59:32 <glguy> aavogt: Ive come to accept that my Haskell files are going to need 25 lines of imports to get anything done :)
21:59:59 <aavogt> import Data.*
22:00:00 <scoles> i'm using a zipWithM_ on a partially applied function (line 25 here http://codepad.org/G6OJMYaI) so I don't think the functions that start the insertion get their own threads.  At least it doesn't seem that way.
22:00:03 --- mode: ChanServ set +o mauke
22:00:04 --- kick: Burning_Aces was kicked by mauke (Burning_Aces)
22:00:04 --- mode: mauke set +b *!*@cpe-75-186-150-165.woh.res.rr.com
22:00:12 <copumpkin> eugh
22:00:14 --- mode: ChanServ set +o glguy
22:00:53 <kmc> ?
22:00:59 <kmc> heh
22:01:12 <copumpkin> people need to update their wireless routers
22:01:28 <kmc> scoles, (forkIO `seq`) makes no sense
22:01:33 <dmwit> Oh, wow.
22:01:37 <aavogt> sure it can
22:01:37 <dmwit> That is an oooold hack.
22:01:46 <kmc> forkIO is a global function, it's pretty much already evaluated no matter what
22:01:57 <aavogt> kmc: what if forkIO isn't evaluated to whnf?
22:02:00 <kmc> ;P
22:02:04 --- mode: mauke set -o mauke
22:02:05 <kmc> scoles, i'm not sure what you're trying to do with that
22:02:15 <BMeph> :t (traverse_ .)
22:02:16 <lambdabot> Not in scope: `traverse_'
22:02:29 <BMeph> :t (Data.Foldable.traverse_ .)
22:02:30 <lambdabot> forall a (f :: * -> *) b (t :: * -> *) (f1 :: * -> *). (Data.Foldable.Foldable t, Applicative f, Functor f1) => f1 (a -> f b) -> f1 (t a -> f ())
22:02:30 <aavogt> perhaps confused by the need to use variations on seq when using par
22:02:37 --- mode: glguy set +C
22:02:39 <kmc> yes
22:02:45 <kmc> well, parallelism and concurrency are very different
22:02:49 <scoles> confused to say the least ;)
22:02:51 <kmc> and evaluation and execution are very different
22:03:02 <kmc> scoles, forkIO is a function that takes an IO action and returns another IO action
22:03:25 <kmc> you want to apply it to an argument, which is the body of the thread you want to launch
22:03:44 <kmc> if m is an IO action, then (forkIO m) is an IO action that launches "m" in its own thread and returns immediately
22:03:46 <aavogt> you sort of need to define your terms if you start giving different meanings to things people think are synonyms
22:04:05 <aavogt> otherwise your quest is rather ineffective
22:04:07 <kmc> yeah
22:04:19 <kmc> i am happy to explain either distinction if asked
22:04:23 <kmc> i won't assume that people don't understand them
22:05:17 <scoles> ok, so is there anyway for forkIO to work with that zipWithM?  It seems that I can't apply it to the partially applied function I'm zipping with.
22:05:18 <aavogt> well the people that understand what you mean by A /= B aren't the ones that need convincing
22:05:43 <kmc> scoles, maybe you want:  zipWithM (\x y -> forkIO (insert' col x y))
22:06:01 --- mode: glguy set -o glguy
22:06:01 <kmc> which lambda term is equivalent to (forkIO .) . insert' col,  i think
22:06:04 <kmc> but that might be less clear
22:06:10 <scoles> ah, ok
22:06:23 <copumpkin> preflex: seen mauke
22:06:23 <preflex>  mauke was last seen on #haskell 2 hours, 23 minutes and 51 seconds ago, saying: preflex: xseen xahlee
22:06:27 <kmc> scoles, it will then print "done" immediately and quit
22:06:40 <kmc> because forkIO doesn't wait for the thread to finish (which would defeat the purpose)
22:06:49 <kmc> and the program quits when main ends regardless of other threads
22:06:59 <aavogt> the clarity of the latter option is proportional to how much time you spend in #haskell
22:07:06 <kmc> yes
22:07:42 <aavogt> well forkIO could register with the main thread and hold it up before exiting
22:08:14 <aavogt> it's really an arbitrary choice I think
22:08:27 <geheimdienst> the Control.Concurrent documentation has example code for making the main thread wait
22:08:43 <aavogt> why isn't it a function?
22:08:46 <ddarius> forkIO should be as lightweight as possible where it doesn't keep valuable functionality from being implemented.
22:08:49 <kmc> aavogt, which?
22:09:02 <aavogt> kmc: that forkIO doesn't make the main thread wait
22:09:27 <kmc> sorry, what would the function be
22:09:43 <kmc> http://hackage.haskell.org/package/threads will do thread joining for you
22:09:49 <aavogt> it would have the same signature
22:09:52 <BMeph> unsafePerformPutThumbUpBum :: IO ()
22:10:25 <kmc> aavogt, if i were convincing people the distinction exists, i'd take a different approach
22:10:44 <kmc> advocacy being different from education
22:11:00 <aavogt> you're doing the same thing again
22:11:08 <kmc> which thing?
22:11:26 <aavogt> A /= B
22:11:30 <aavogt> ...??
22:11:33 <kmc> ?
22:12:26 <kmc> i mean that someone here is already interested in learning the Haskell way of thinking, and so if i say "evaluation is different from execution" they will either know what i mean or ask
22:12:48 <kmc> it's different if i'm on proggit trying to convince people to think this way
22:17:45 * geheimdienst occasionally hangs out here, sometimes asks something, but often enough has no clue what's being discussed. there's generally a little too many bimonoidal predemented zygolodromes flying around.
22:18:19 <copumpkin> :)
22:18:26 <pikhq> geheimdienst: But all is monad!
22:18:27 <copumpkin> you can always ask us to explain in simpler language
22:18:43 <aavogt> copumpkin: and you can always refuse!
22:18:44 * Cale finds it kind of funny which of his comments receive the most upvotes on reddit.
22:18:46 <copumpkin> they're often fairly simple things, but people make up words to simplify communication between those who know them
22:18:47 <geheimdienst> "... why, that's just a monoid in the category of endofunctors ..."
22:18:56 <Cale> "HALP! THEY STEALS MAH ELECTROMS!" -- 34 points
22:18:58 <copumpkin> @quote lax
22:18:58 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
22:18:59 <scoles> thanks so much kmc :) now it works like a beauty
22:19:16 <dmwit> Behind every great functor is a plain old function that respects composition and identity.
22:19:39 <copumpkin> Cale: yeah, the thoughtful ones get way fewer upvotes, sadly
22:19:41 <ddarius> Cale: Consider it a very explicit example of what the internet optimizes for.
22:19:56 <ddarius> dmwit: Two functions.
22:20:00 * dmwit nods
22:20:23 * wli remembers the sign in the z29/X-19 lab in 1994: "WWW == World Wide Waste (of bandwidth)"
22:20:28 <geheimdienst> well the internet optimizes for short, snappy, sensational things ...
22:20:56 <geheimdienst> but still, what kind of article could cause the comment "halp they steals mah electroms"?
22:20:58 <kmc> scoles, it solved your performance problem?
22:21:11 <copumpkin> http://imgur.com/p83HI.jpg
22:21:18 <Cale> geheimdienst: A picture of a cat with packing peanuts
22:21:26 * copumpkin stalks Cale
22:21:33 <kmc> it's funny because it's a cat speaking in cute broken english
22:21:50 <kmc> quick, the internet must know about this
22:22:01 <copumpkin> I like monorail cat myself
22:23:04 <dmwit> Every once in a while I visit typeracer.com and play a few rounds.
22:23:11 <scoles> kmc, yup :)
22:23:29 <dmwit> Then I feel bad because typing on #haskell all day makes me a very speedy typist and I beat everybody.
22:23:31 <kmc> scoles, cool.  that was easier than i expected :)
22:23:38 <kmc> threads in GHC Haskell are pretty simple
22:25:26 <ddarius> dmwit: Talk less.
22:25:52 <copumpkin> there were talkativity stats for #haskell up somewhere for a while
22:26:00 <copumpkin> I remember being terrified that I'd made my way to the top of them
22:26:11 * dmwit probably doesn't even register
22:26:14 <copumpkin> and yes, talkativity is a word
22:28:03 <kmc> i'm probably near the top
22:28:08 <kmc> because i am unemployed and have nothing better to do
22:28:27 <copumpkin> kmc: what else do you do with your time? surely you aren't on here all the time
22:28:29 <aavogt> you could find a job?
22:29:01 <aavogt> @quote student
22:29:02 <lambdabot> PaulGraham says: "There are few sources of energy so powerful as a procrastinating grad student."
22:29:16 <aavogt> @quote dead.*end
22:29:17 <lambdabot> MarkPilgrim says: "In the long run, the utility of all non-Free software approaches zero. All non-Free software is a dead end."
22:29:38 <aavogt> @quote phd.*student
22:29:39 <lambdabot> dons says: phd students have life easy
22:30:15 <glguy> http://www.cse.unsw.edu.au/~dons/irc/haskell.html
22:30:25 <glguy> as of November
22:30:39 <dmwit> ack, I do register
22:30:42 <copumpkin> is that total?
22:30:44 <copumpkin> I guess
22:31:15 <copumpkin> there were monthly ones too I think
22:31:36 <pikhq> kmc: You could... Learn a language?
22:31:54 <copumpkin> I haven't heard much from SamB recently
22:31:56 <copumpkin> preflex: SamB
22:32:01 <copumpkin> preflex: seen SamB
22:32:02 <preflex>  SamB was last seen on #css 121 days, 1 hour, 30 minutes and 13 seconds ago, saying: Stoner19:got it, thanks
22:33:09 <copumpkin> ski has quite a potty mouth. 0.0% words were foul language.
22:33:16 <copumpkin> ski: shame on you
22:33:39 <aavogt> because there's no swearing here?
22:35:34 <soupdragon> that (no swearing) is a new rule afaict
22:36:03 <soupdragon> would love it if someone just deleted all swear words so there was no 'bad words' left.. then there wouldn't be an issue
22:36:22 <copumpkin> http://www.cse.unsw.edu.au/~dons/irc/haskell-03.html
22:36:22 <copumpkin> wow
22:36:58 <soupdragon> yesterday???
22:37:02 <soupdragon> that is confusing
22:37:20 <copumpkin> ?
22:37:28 <soupdragon> on that page you linked
22:37:44 <aavogt> where is yesterday?
22:37:46 <geheimdienst> well the page was generated july 2006 or something
22:38:25 <copumpkin> Smerdyakov used to hang out in here :o
22:38:35 <Cale> He was eventually banned
22:38:56 <copumpkin> and Cale eventually capitalized his nick
22:39:02 <copumpkin> such great history to be learned
22:39:22 <Cale> Actually, I don't know why it has my nick in lowercase.
22:39:27 <Cale> hmm
22:39:36 <copumpkin> "Is palomer stupid or just asking too many questions? 24.3% lines contained a question! "
22:39:49 <Cale> @palomer
22:39:49 <lambdabot> Brump!
22:39:55 <copumpkin> The loudest one was xerox, who yelled 8.9% of the time!
22:39:58 <tensorpudding> Who is palomer?
22:40:05 <copumpkin> Darius wrote the longest lines, averaging 73.3 letters per line.
22:40:10 <kulin> im sure, im at over 50% questions
22:40:21 <Cale> Just a guy who used to hang around here more.
22:40:33 <copumpkin> yet he gets his own lambdabot command
22:40:40 <Cale> @palomer
22:40:40 <lambdabot> Hrmph
22:40:41 <Cale> @palomer
22:40:41 <lambdabot> Hrmph
22:40:42 <Cale> @palomer
22:40:42 <lambdabot> (_|_)
22:40:42 <soupdragon> @palomer
22:40:43 <BMeph> Heh-heh, "lambdabot's faithful follower, dons" as if lambadabot had just one follower. Then again, maybe the rest are classed as fanboys...? ;)
22:40:43 <lambdabot> Learning vim is pointless
22:40:43 <Cale> @palomer
22:40:43 <lambdabot> They're telling you lies!
22:40:45 <Cale> @palomer
22:40:45 <lambdabot> Blargh!
22:40:52 <soupdragon> I remember thiis nick but not the person..
22:41:11 <Cale> I was hoping for the comments about text editors there...
22:41:15 <tensorpudding> Damn, shapr talks a lot.
22:41:16 <copumpkin> wow, RyanT5000 was in here in 06
22:41:40 <aavogt> half of you weren't born in '06
22:41:44 <copumpkin> lol
22:42:26 <Cale> I'm three AND A HALF!
22:42:36 <copumpkin> Riastradh stopped hanging out in here in 05
22:43:23 * BMeph is pretty sure none of us were born in '06. Although, augustss could've been born in 1906, maybe... ;)
22:43:33 <tensorpudding> I think I first visited here in 2007.
22:44:29 <copumpkin> xerox is the all-time loudmouth
22:44:38 * ivanm first came here around 2006/2007
22:44:46 <tensorpudding> Hmm, guess not, I can't find a freenode log for #haskell
22:44:53 <ivanm> wait, could have even been end of 2005
22:45:05 <glguy> ivanm: "Logs: http://tunes.org/~nef/logs/haskell/"
22:45:14 <copumpkin> I'd like a tarball of those
22:45:18 <copumpkin> they're a pain to download individually
22:45:30 * glguy used to have a local set of them for easy fgrepping
22:45:33 <Cale> My earliest log file is from 2004, but I started coming here maybe a couple years before?
22:45:55 <copumpkin> I grabbed them all with a script once
22:46:07 <tensorpudding> I've got records with Cale in them from my time on #math that date back to 2007 though
22:46:11 <copumpkin> but it's annoying because it's hard to convince regular tools like wget to fetch files with "no textension"
22:46:15 <copumpkin> -t
22:46:24 <ivanm> eh, I lost my original logs (might have them backed up somewhere though)
22:46:32 <ivanm> I'm considering trying to get logrotate to work on my logs...
22:48:46 <copumpkin> 13:03:43 <Lemmih> Darius: I'm very new to Haskell so I'm sure that much/most of the code could be better :)
22:48:50 <Cale> I started using IRC in 1995-96, but mostly Undernet back then.
22:49:00 <tensorpudding> My logs for when I ran irssi are all gone.
22:49:22 <copumpkin> <palomer> is lazy evaluation _really_ useful?
22:50:03 <tensorpudding> i've got some random logs that must have been from Gaim/Pidgin
22:50:58 <soupdragon> The thing I really hate about these "what's the point of"/"is ___ useful?" questions are when you KNOW that they are really really important.. but you can't think of any examples
22:51:46 <shapr> tensorpudding: What did I say?
22:51:46 <copumpkin> soupdragon: people then proceeded to give him a few examples, which he seemed to ignore, but then Riastradh shut him up
22:52:09 <tensorpudding> I would have no idea.
22:52:26 <tensorpudding> Referring to the #haskell logs from 2006, where you had more lines of chat than the next several people put together
22:52:26 <soupdragon> how?
22:52:42 <shapr> tensorpudding: Anyway, I don't talk much anymore... but you should see the historical yearly totals.
22:53:01 <tensorpudding> http://www.cse.unsw.edu.au/~dons/irc/haskell-03.html
22:53:08 <tensorpudding> as was linked earlier
22:53:28 <copumpkin> hm?
22:53:35 <copumpkin> oh
22:53:53 <Null-A> Do you think haskell is simple enough for mainstream programmers?
22:53:55 <soupdragon> no
22:54:13 <soupdragon> "mainstream programmers" probably refers to something vauge enough that they can't do anything
22:54:25 <soupdragon> best thing to do is learn it yourself and be reflective about the process
22:54:43 <tensorpudding> Haskell is simple enough that people who have any interest can learn it.
22:54:49 * soupdragon keeps hearing people say "no true scotsman" and thinks this is probably the same thing
22:54:53 <Null-A> I'm doing fine, it's just i'm pretty smart, I can see my colleagues complaining about the complexity :-P
22:55:01 <soupdragon> yeah I know the feeling
22:55:04 <tensorpudding> No true programmer hates Java.
22:55:10 <soupdragon> I think it's more a personal thing, than people around you being dumb
22:55:11 <copumpkin> lol
22:55:27 <kmc> soupdragon, for a long time the answer to "is purity really useful" was "parallelism", but we had nothing to actually show for it
22:55:28 <kmc> now we do
22:55:32 <kmc> and it makes me very happy
22:55:41 <Null-A> :)
22:55:43 <copumpkin> that's why I wear a purity ring
22:55:49 <aavogt> does this mainstream programmer want to learn something new?
22:55:50 <soupdragon> kmc, now we do ?
22:55:54 <kmc> yes soupdragon
22:55:59 <soupdragon> which is?
22:56:08 <tensorpudding> Mainstream programmers usually are interested with writing code.
22:56:10 <kmc> in that GHC has a good threaded runtime and supports pure parallelism via par, Strategies, etc.
22:56:17 <kmc> and you get a real world speedup with very little effort
22:56:17 <digitteknohippie> !haskell
22:56:18 <lunacat> haskell is the loveliest programming language ever.  much thanks goes to those who came up with it, and the community of pleasnt people who continue to use, support and develope it.  meow.
22:56:20 <kmc> and it's easier than threads
22:56:21 <copumpkin> and dph! and STM! zomg
22:56:25 <digitteknohippie> ;)   thnx again everyone.
22:56:33 <tensorpudding> I think a lot of programmers will just use whatever has the best odds of landing them employment, though.
22:56:36 <copumpkin> :)
22:56:41 <kulin> haskell is great, but its no vbscript
22:56:45 <soupdragon> so true
22:56:46 <kmc> yeah, those also depend on purity copumpkin
22:56:49 <kmc> but forkIO etc. don't
22:56:50 <aavogt> strategies were leaky before parallel-2...
22:56:51 <copumpkin> tensorpudding: with that tsuru capital ad on haskell-cafe, that sounds like haskell :P
22:56:55 <jesusabdullah> Can't go wrong with vb6!
22:56:57 <jesusabdullah> :v
22:57:11 <kmc> anyone have opinions about tsuru capital?
22:57:20 <tensorpudding> Well, it's not like management chooses languages for their difficulty in supporting.
22:57:22 <copumpkin> kmc: beyond, "man, I really should apply"?
22:57:32 <kmc> yeah
22:57:42 <copumpkin> not much, there seems to be almost no info on them anywhere
22:57:57 * soupdragon is wondering what to study
22:57:57 <kmc> Null-A, i think anyone smart enough to write good code, in general, can learn Haskell
22:58:06 <copumpkin> the guy who posted the ad participated in a real time haskell thread on -cafe a while ago
22:58:09 <kmc> however i think a lot of working programmers are not smart enough to write good code in general
22:58:26 <aavogt> what is good code?
22:58:26 <copumpkin> that's all I know about it :P
22:58:34 <kmc> Null-A, also, i'd avoid reading too much into the intelligence / knowledge distribution of current Haskellers
22:58:37 <copumpkin> aavogt: Shit Code -> Void
22:58:38 <kmc> that says more about who bothers to learn Haskell
22:58:43 <kmc> and less about what's necessary for learning Haskell
22:58:49 <aavogt> copumpkin: is Shit a Monad?
22:58:52 <tensorpudding> A lot of programmers aren't willing to write good code, or to relearn the bad practices they picked up.
22:58:58 <copumpkin> aavogt: doesn't really matter, but possibly
22:59:01 <tensorpudding> Or at least, that is what I read on a blog.
22:59:02 <Null-A> kmc: *nods*
22:59:02 <kmc> it's also why employers should want to hire Haskell programmers even if they don't care about Haskell and never plan to use it
22:59:05 <copumpkin> kmc: you have any opinions?
22:59:11 <kmc> about tsuru copumpkin?
22:59:14 <copumpkin> yep
22:59:19 <kmc> no
22:59:22 <copumpkin> oh, and tsuru means crane in japanese
22:59:22 <kmc> i know nothing about them
22:59:24 <kmc> pretty small right?
22:59:33 <copumpkin> the bird kind of crane
22:59:37 <kulin> im not sure about the foundations for all these assumptions
22:59:37 <kmc> i worked at a 100 person finance company that grew to 200 people.  it got a lot less fun in that time
22:59:51 <copumpkin> ah
23:00:04 <copumpkin> kmc: would you move to japan?
23:00:08 <kmc> dunno
23:00:24 <copumpkin> I'm actually pretty tempted by it, but I've studied a fair amount of japanese
23:00:30 <copumpkin> and have already spent a few months there
23:00:59 <Cale> 22:04:48 <shapr> hi cale
23:00:59 <Cale> 22:05:13 <shapr> Learning Haskell?
23:01:07 <copumpkin> aw
23:01:09 <Cale> 03.05.14 :)
23:01:17 <kmc> :)
23:01:35 <Cale> 23:23:58 <cale> If I wanted to write a programmable editor that used Haskell as the extension language, what do people think would be the easiest way to do that?
23:01:35 <Cale> 23:24:21 <Pseudonym> cale: You don't by any chance have a simpler question, do you? :-)
23:02:10 <soupdragon> hehe
23:02:15 <kulin> did you ever make your editor?
23:02:16 <ivanm> Cale: so, as your intro to haskell you wanted to write yi? :p
23:02:19 <kulin> or did you give up on your dreams?
23:02:21 <copumpkin> yi!
23:02:25 <aavogt> isn't yi a bit stalled?
23:02:40 <Cale> My prodding various people might have inspired yi somewhat.
23:02:41 <ivanm> aavogt: seems that way to me
23:02:50 <ivanm> but with leksah using yi, it might improve
23:02:54 <geheimdienst> so, was your 7-year haskell anniversary like 2 days ago?
23:03:02 <Cale> I remember prodding dons to look into finding a way to dynamically load Haskell code :)
23:03:06 <ivanm> copumpkin: hmmmm, what's the factorial of yi? :p
23:03:12 <copumpkin> 1
23:03:20 <ivanm> so, yi \in {0,1} ?
23:03:33 <Cale> geheimdienst: Seems like!
23:04:00 <Cale> Though I'd been using and learning the language for a while before that.
23:04:08 <aavogt> things look to have been different back then
23:04:13 <aavogt> FFI was fresh
23:04:19 <geheimdienst> well then happy birthday!
23:04:20 <aavogt> H98 wasn't that stale?
23:04:28 * geheimdienst shakes cale's hand
23:04:53 <copumpkin> can anyone find the first appearance of pumpkin?
23:05:35 <Cale> Not in the 01, 02, 03 logs.
23:05:40 <copumpkin> lol
23:05:47 <aavogt> early '09?
23:05:54 <dmwit> pumpkinintoilet
23:06:05 <copumpkin> late 08 should be it, but I'm not sure when
23:06:14 <copumpkin> I was just asking questions on someone else's behalf at the beginning
23:06:45 <ddarius> copumpkin: That person tricked you.
23:06:51 <copumpkin> lol
23:06:55 <copumpkin> really?
23:07:03 <dmwit> My first record is Oct 31, 2009.
23:07:20 <dmwit> hmm... these are not my full logs
23:07:29 * dmwit goes rooting around for the older ones
23:07:30 <copumpkin> I had written a script to fetch all the logs
23:07:33 <copumpkin> I wonder where it went
23:07:34 <Cale> Oct 07 19:18:10 <pumpkin_>      is there a way of making an empty "do-nothing, return-nothing" IO?
23:07:38 <aavogt> THIS is my FULL log
23:07:39 <scoles> So I'm trying to now have the main thread wait for all the other threads with the second method listed here http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Concurrent.html#11 but I can't find what package the later function used here is in (hoogle shows nothing, hayoo is down).  Anyone know?
23:07:44 <copumpkin> aha, that sounds about right
23:08:10 <kmc> which one scoles
23:08:13 <Cale> Not sure what year that was, I'd have to flip through the logs and count backward
23:08:24 <kmc> btw you might just want to use http://hackage.haskell.org/package/threads
23:08:26 <copumpkin> Cale: 08
23:08:44 <dmwit> ooo, Unicode type variables
23:08:47 <dmwit> fancy
23:08:53 <scoles> kmc, thanks :D i'll try that package out
23:08:54 <Null-A> The type systems keeps tripping me up, and the compiler messages aren't much help. Are you guys able to write type safe code on your first try after a while?
23:09:05 <Cale> Null-A: yep
23:09:06 <copumpkin> Cale: thanks for looking!
23:09:17 <Null-A> that's good
23:09:39 <kmc> Null-A, depends.  for something very complicated i have no chance of writing it error-free, in any language.  difference being that Haskell makes most of my errors into type errors
23:09:48 <kmc> so i can catch them earlier and more exhaustively
23:09:48 <Cale> Null-A: But remember that type errors (with associated line numbers) are a whole lot nicer than bugs at runtime :)
23:10:05 <Null-A> *nods*
23:10:25 <kulin> scoles, i think that example is just a really verbose way of saying, if you want the main loop to wait for other threads, use an MVar to communicate between the threads so you will know when the result is complete
23:10:52 <geheimdienst> it's difficult to get anything to run, but when it does, there's good chances it will work
23:11:11 <geheimdienst> unlike very dynamic languages, where basically everything will run ... for a while ...
23:11:16 <Cale> (or at least do something useful, if not what you wanted ;)
23:11:32 <copumpkin> yeah, nothing beats objective-c's silent null messaging behavior
23:11:38 <kmc> scoles, here's the super simple not exception safe version http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25520#a25520
23:11:39 <copumpkin> sending a message to null gives you another null
23:22:07 <shapr> Cale: I'm glad you stayed on #haskell!
23:22:58 <Cale> Yeah :)
23:23:01 <scoles> thanks kmc and kulin
23:23:14 <kmc> no problem scoles
23:25:13 <dobie_gillis> has anyone installed lambdabot with cabal recently? i'm getting some dependency conflicts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25521#a25521
23:25:42 <tessier> Hello all! I am trying to compile the haskell code on: http://jng.imagine27.com/articles/2009-07-23-094212_generating_pi_in_haskell.html and it seems to compile successfully but when I run it I get the error: machine_pi: Prelude.head: empty list
23:25:49 <Nereid> dobie_gillis: I managed to a month or two ago. it looks familiar but I forget how I resolved it
23:25:52 <Nereid> sorry
23:26:12 <tessier> er...is the above sentence incomplete for anyone else or is my terminal messed up and not displaying properly?
23:26:28 <dobie_gillis> Nereid: that's okay.. glad to know it's not just my system :)
23:26:29 <tessier> Ah, highlight with mouse makes it show up.
23:26:31 <aavogt> dobie_gillis: add --constraint='tagsoup < 0.9'?
23:26:34 <kmc> tessier, it wants a command-line argument
23:26:37 <tessier> For some reason xchat is having issues with xmonad it seems.
23:26:43 <tessier> kmc: Doh. Of course. Thanks!
23:26:44 <kmc> tessier, the code is slightly poorly written too
23:26:46 <aavogt> or maybe less than 0.8, I forget
23:27:02 <tessier> kmc: Well, I doubt he really put that much effort into a simple blog posting
23:27:03 <aavogt> it needs more highlighting
23:27:05 <cads>  hey when we import a library we make the exported functions and type constructors of a library available in our code. Do we say that we've imported a library into the current scope? (I'm tempted to say 'we've imported a library into the current namespace", which is bad!)
23:27:05 <kmc> yeah
23:27:16 <kmc> tessier, but for the low effort solution you'd go (oneArg:_) <- getArgs
23:27:22 <kmc> "head" is a big code smell
23:27:54 <aavogt> cads:   module Foo (module Bar, module Foo) where
23:27:58 <copumpkin> irrefutable patterns are pretty close :P
23:28:00 <dmwit> cads: hm, importing just defines some names
23:28:33 <aavogt> so that when you import Foo, you get Bar!
23:29:19 <cads> in this case there's a module which imports 12 other modules part of a library so that everything can be used
23:29:33 <dobie_gillis> aavogt: <0.8 worked, thanks
23:29:37 <dmwit> cads: I'm not sure any qualification is necessary. We just say "we've imported a module", with no extra fluff on the end.
23:30:13 <cads> I'm just making a little tutorial and I want to say "this line imports the hasmat module into the available definitions" or so
23:30:36 <cads> brb, must make tuna salad
23:30:46 <copumpkin> cads: euphemism?
23:30:56 <aavogt> module from library xyz
23:30:59 <dmwit> How about just "this line imports the hasmat module"?
23:31:20 <aavogt> copumpkin: moar euphemism please
23:31:40 <geheimdienst> that explanation wouldn't say more than "import Hasmat"
23:31:42 <dmwit> Or even just leaving that out, maybe. If you want to say something, explain what it does rather than just reusing the word "import".
23:31:43 * copumpkin makes salmon and anchovy salad, if you know what I mean
23:31:54 <geheimdienst> exactly ;)
23:32:16 <aavogt> use -XPackageQualifiedImports or whatever it's called
23:32:30 <dmwit> e.g. "This line defines a bunch of names like isHazardous, uranium, and helium, which are defined in the hasmat library."
23:33:06 <dmwit> Even that sentence can be improved a lot. =)
23:33:22 <geheimdienst> "After importing Hasmat, our code can use everything Hasmat exports: uranium, isHazardous, etc."
23:33:54 <geheimdienst> also, how is helium hazardous ... it just makes your voice squeaky
23:34:05 <aavogt> it displaces O2
23:34:09 <jesusabdullah> Exactly
23:34:13 <dmwit> Obviously isHazardous helium = False.
23:34:39 <pikhq> geheimdienst: Not-oxygen tends to hurt your living. :)
23:34:46 <jesusabdullah> isHazardous helium = True
23:34:55 <jesusabdullah> but isPoisonous helium = False
23:35:04 <geheimdienst> on 2nd thought, it makes the careless baby's balloon float away, inducing baby to cry like mad for 80 mins
23:35:06 <Jafet> Is aavogt making a subtle joke about the lack of optimization capability of alternative haskell implementations?
23:35:08 <geheimdienst> that's a hazard
23:35:24 <aavogt> Jafet: if you want :)
23:35:25 <pikhq> Jafet: If he is, that's an amazingly subtle joke.
23:35:31 <jesusabdullah> Your MOM's an alternate haskell implementation?
23:35:47 <soupdragon> lol
23:35:50 <Jafet> Surely not, she is quite strict.
23:35:51 * jesusabdullah needs to catch up on his sleep. He's not making sense anymore.
23:36:30 <jesusabdullah> hah
23:36:37 <jesusabdullah> gnight yalls
23:37:09 <aavogt>  {- | generate lolcats -} module Hasmat where {}
23:37:19 <dobie_gillis> now i'm getting this error building lambdabot (i'm using ghc 6.10.4): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25522#a25522
23:37:20 <kmc> hehe
23:37:47 <kmc> dobie_gillis, what command are you using to build?
23:37:54 <kmc> you can expose the unix pkg with "ghc-pkg expose unix"
23:38:16 <kmc> not sure if that's sensible
23:38:17 <aavogt> oh no, cabal compiles using -hide-all-packages
23:38:20 <Cale> Where did you get your lambdabot?
23:38:27 <dobie_gillis> kmc: i'm using cabal install, how can i pass that along to cabal?
23:38:35 <kmc> not sure
23:38:53 <aavogt> so even if you exposed everything, ghc wouldn't see that
23:38:59 <cads> copumpkin: it's a euphamism for mixing mayonaise into tuna and diced pickles and onions, if you know what I mean
23:39:00 <geheimdienst> isn't a package "hidden" when the cabal file says foo < 0.2 and there's only foo 0.3 available ...?
23:39:03 <Cale> You can edit the build dependencies in the .cabal file
23:39:07 <copumpkin> cads: ooh!
23:42:37 <cads> "this makes all the modules of the hasmat library available, including ..." sounds good
23:42:51 <aavogt> if you know what I mean?
23:43:11 <cads> damn, that was delicious
23:43:39 <geheimdienst> on #haskell, we are so eloquent that, behind even a plain tuna salad, we suspect cunning double-entanner... entedre... end... we suspect extra meaning
23:44:14 <Null-A> I'm building up an intermediate representation using an algebraic data type, the input is AST; I'm exploring the AST depth first search and wish to reference parts of the I-Representation just recently generated as I'm generated it. This feels really awkward in haskell, I have to keep temporarily constructing faulty I-Reps with partially complete data and pass it through all the constructing functions. Is there an easier way to do this
23:44:26 <kmc> Null-A, probably
23:44:30 <kmc> Null-A, maybe you can hpaste some code
23:44:32 <aavogt> @wn entendre
23:44:33 <lambdabot> No match for "entendre".
23:44:40 <aavogt> @wn "double entendre"
23:44:40 <lambdabot> *** "double entendre" wn "WordNet (r) 2.0"
23:44:40 <lambdabot> double entendre
23:44:40 <lambdabot>      n : an ambiguity with one interpretation that is indelicate
23:44:43 <kmc> Null-A, or maybe you should just have more arguments in your helper function
23:44:55 <soupdragon> "This feels really awkward in haskell" --  you know a way to do it that isn't awkward? You can implement that method in haskell and program in that style
23:46:27 <dmwit> Or maybe you want to learn about comonads!
23:46:42 <Null-A> kmc: http://codepad.org/GPt4HwGY
23:47:08 <Null-A> issue is in IRep file, I haven't done any temporary constructing right now
23:47:10 <geheimdienst> ... first, imagine a simple coburrito.
23:48:18 <aavogt> what's mkAttr?
23:48:27 <Null-A> kmc: Normally I would pass a pointer to the data structure around, and I can query it while its being built
23:49:02 <cads> I was eat burritor the other day and I'd put way too much hotsauce on it, and as I was scalding my mouth I thought "this is exactly like a monad"
23:49:09 <kmc> Null-A, well, most values in Haskell are implicitly by reference, but you don't build a value by mutating it in-place
23:49:28 <kmc> Null-A, so which part of this is awkward?
23:49:38 <cads> 4 hours later on the loo I though "ooh yeah, monad coming through"
23:49:39 <ddarius> Hot sauces does not scald unless it is at a high temperature.
23:49:52 <Null-A> kmc: I didn't add the awkward part yet, going to take some time
23:50:14 <Null-A> kmc: so basically I'll have to pass the accumulator to the mk function
23:50:16 <cads> ddarius: I'm sure skoeville units can be converted to fahrenheit _somehow_
23:51:00 <Null-A> kmc: so if I'm accumulating Types inside a Namespace, I'd construct a new Namespace with the current accumulated list of Types, so that its available for query
23:51:20 <geheimdienst> that is one thing *so* strange about english, there's only one word for hi-temperature-hot and for spicy-hot
23:52:09 <Null-A> kmc: this is inside the foldr calls btw
23:52:40 <soupdragon> geheimdienst: it's probably because we never discovered spicey food until it was too late
23:52:42 <ddarius> geheimdienst: There are many words for each.  "Hot" is just the most common for each.
23:53:05 <Cale> What I think is stranger is that while we have a distinction between 'fewer' and 'less' for discrete and continuous things, there isn't a corresponding distinction for 'more'
23:53:06 <geheimdienst> when you say "she's so hot", i guess that refers to the temperature ("... smoking hot"), but the other meaning would also be reasonable
23:53:37 <cads> Cale: I suppose that would be "many-er"
23:53:54 <dobie_gillis> okay building lambdabot from the tarball now, after 'ghc-pkg expose unix' and 'runhaskell Setup build' I get the same hidden package error
23:54:11 <dmwit> spicy food activates the same nerves as high temperature
23:54:29 <dmwit> So it's not totally insane. I agree that it's inconvenient.
23:54:50 <Cale> Also, why does "the red big balloon" sound strange compared with "the big red balloon"? :)
23:54:56 <geheimdienst> cale, the linguists are saying that's baloney ... http://itre.cis.upenn.edu/~myl/languagelog/archives/003775.html
23:55:07 <cads> ddarius: so for example something that has 4 trillion skoville units tastes exactly like quark-gluon plasma
23:56:10 <Cale> geheimdienst: There definitely is a distinction in meaning between 'less' and 'fewer', regardless of whether it's okay to use 'less' with discrete objects in some cases.
23:56:22 <ddarius> cads: Using that analogy would probably make the Skoville units much more colorful.
23:56:34 <copumpkin> less people use fewer than should do so ;)
23:56:34 <Cale> It's not okay to say, for example, "fewer water"
23:57:10 <ddarius> Cale: A lot of languages have a not-grammatically-enforced preferred word order though with varying degrees of strength and there are many that do not.
23:58:19 <cads> dmwit: I think having imprecise language lets you be more expressive - I can fancy that I've burnt my mouth (and soon after my ass) after eating some ungodly hot food
23:58:39 <geheimdienst> yes, the water thing surely is right ... i meant the thing about saying "6 items or less", which prescriptivists don't like because they randomly decided countable things need "fewer"
23:58:42 <Cale> ddarius: Yeah, it's just strange that some permutations of adjectives are preferred over others.
23:59:34 <dmwit> My girlfriend, who speaks English as a second language, says adjective order is one of the most difficult things to get right.
23:59:43 <dmwit> http://www-users.cs.york.ac.uk/susan/cyc/a/adj.htm has the (supposed) rules
