00:00:24 <geheimdienst> i guess that's a matter of being used to it. it's not just adjectives either. "comparing oranges to apples" sounds weird, although the meaning should be the same as the proper proverb
00:00:42 <dmwit> Ah, well, idioms are idioms.
00:00:52 <dmwit> Those happen in every language.
00:01:29 <kulin> is there a smart way to chose the order of parameters? I notice for example Data.Map has the map at the end of the parameter list "insert key value m"
00:01:35 <kulin> is there some rule of thumb i should have when deciding?
00:01:50 <dmwit> Put them in the order in which they are most likely to be partially applied.
00:01:52 <aavogt> choose an order that makes partial application more useful
00:01:54 <c_wraith> kulin: think about currying.
00:01:59 <Cale> kulin: Parameters should go in increasing order of expected rate of change.
00:02:07 <copumpkin> ooh
00:02:10 <ddarius> kulin: Use what's sensible, then after that consideration, the fastest varying parameters go last.
00:02:22 <kulin> alright, thanks
00:02:29 <dmwit> dang, seems everybody's in agreement
00:02:40 <copumpkin> I'd like some sort of way of making that less necessary
00:02:41 <aavogt> it's rather annoying when a library puts the varying parameters first
00:02:50 <Cale> copumpkin: You already have it
00:02:57 <Cale> copumpkin: That's what lambda is for
00:02:58 <copumpkin> f _ 5 . g
00:02:59 <aavogt> because that's the parameter order for OO methods
00:03:02 <copumpkin> yeah, but this is shorter
00:03:05 <copumpkin> :P
00:03:16 <copumpkin> and the \ for lambda bothers the heck out of me for irrational reasons
00:03:17 <Cale> The underscore proposal has weird issues though
00:03:32 <BMeph> "Apples to oranges" is about meter (that is, why is sounds weird the other way).
00:03:37 <aavogt> it doesn't steal syntax
00:03:39 <Cale> (the one you're suggesting has been suggested a number of times before and discussed at length on the mailing lists)
00:03:43 <BMeph> why *it
00:03:45 <copumpkin> Cale: yeah, I know
00:04:03 <ddarius> I hate all those "implicit" lambda proposals.
00:04:09 <copumpkin> how come?
00:04:19 <copumpkin> if we could make the lambda syntax prettier I wouldn't feel the need for them :P
00:04:27 <dmwit> BMeph: sounds like "suusu" to me in both (using 's' for "stressed syllable" and 'u' for "unstressed syllable")
00:04:27 <aavogt> we already have implicit lambdas with partial application
00:04:30 <Cale> ddarius: There's one in particular which I do want, which is the "case of" thing.
00:04:36 <ddarius> copumpkin: Lambda syntax is already very light.
00:04:40 <soupdragon> everyone in every language seems to have something against typing lambda
00:04:40 <copumpkin> aavogt: only in a prescribed order though
00:04:41 <soupdragon> weird!
00:04:45 <aavogt> right
00:04:58 <ddarius> Cale: That's different.  That's not rife with ambiguities.
00:05:01 <aavogt> copumpkin: just use flip already
00:05:04 <Cale> sure, right :)
00:05:18 <copumpkin> aavogt: we should have a few thousand permutation HOFs
00:05:22 <ddarius> copumpkin: Admittedly, it is perhaps shameful that C# has a lighter lambda syntax.
00:05:25 <aavogt> let a = b in case of fire -> exit
00:05:26 <copumpkin> to permute the arguments in any order we want
00:05:34 <dmwit> copumpkin: http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/
00:05:43 <dmwit> copumpkin: order-independent arguments =)
00:05:49 <copumpkin> dmwit: hah yeah, saw that
00:05:51 <ddarius> aavogt: let in case of fire -> exit
00:05:53 <dmwit> (though admittedly with some additional labels)
00:05:53 <cads> so I've got a matrix library which is fashioned to be similar to matlab and even had an 'eye' function which you call to construct a matrix. I'd like to rename it, as well as do some other refactoring to the code, and I'm wondering if there's any tool that would make this faster and less error prone than search and replace
00:06:01 <alexbobp> Haskell is throwing a stack overflow from a tail-recursive method I wrote... isn't this supposed to be optimized out?
00:06:05 <aavogt> > let in 1
00:06:06 <lambdabot>   1
00:06:15 <copumpkin> cads: hare existed at one point I think
00:06:17 <Cale> alexbobp: stack overflow doesn't mean what you think it might :)
00:06:18 <copumpkin> not sure if it still works
00:06:28 <aavogt> hmm, I didn't realize that `let {} in' was allowed
00:06:32 <alexbobp> Cale: ah. can it happen just from bigints getting too large?
00:06:37 <cads> bitrot be damned :P
00:06:38 <Cale> alexbobp: no
00:06:39 <copumpkin> alexbobp: don't be so strict in your thinking
00:06:40 <dmwit> > do
00:06:41 <lambdabot>   <no location info>: Empty 'do' construct
00:06:50 <dmwit> Apparently do {} isn't allowed. =)
00:06:51 <Cale> alexbobp: The stack consists of pattern matches which are waiting for their scrutinees to be sufficiently evaluated to match
00:07:04 <aavogt> dmwit: because that would be an implicit return ()?
00:07:09 <ddarius> aavogt: I'm surprised that empty cases (as in case x of {}) aren't allowed, though I guess that goes hand in hand with the also surprising omission of empty data types.
00:07:26 <copumpkin> yeah, dolio was asking for those on reddit a couple of weeks ago iirc
00:07:29 <dmwit> aavogt: It's hard to say what it should return. That's probably why it's not allowed.
00:07:39 <aavogt> dmwit: so   return undefined?
00:07:40 <dmwit> aavogt: (i.e. why is () so special?)
00:07:44 <Cale> alexbobp: So probably what happened is you built up a giant expression like ((... ((0 + 1) + 2) ...) + 999999) + 1000000
00:07:50 <cads> alexbobp: basically your tailrecursive function might be passing along a thunk as one of the parameters
00:08:01 <alexbobp> oh, I see
00:08:02 <Cale> alexbobp: and then the outermost + needs to match its left parameters
00:08:04 <Cale> parameter*
00:08:08 <alexbobp> is it possible to make that not happen?
00:08:08 <aavogt> because it's as good as the mempty of some other monoid?
00:08:13 <copumpkin> alexbobp: certainly!
00:08:30 <copumpkin> alexbobp: make your code stricter, or lazier
00:08:33 <Cale> alexbobp: Yeah, by using seq or bang patterns or a stricter version of whatever higher order function you're using
00:08:52 <cads> if you're using foldl you can use foldl', for example
00:08:52 <Cale> Or else ensure that you don't demand the whole thing at once in some other way
00:08:57 <alexbobp> Cale: if I pastebin code can you take a look?  it's 6 lines
00:09:00 <Cale> sure
00:09:02 <alexbobp> I'm passing tuples
00:09:35 <alexbobp> http://alexbobp.pastebin.com/yxAcLxaE
00:09:36 * cads stilll wonders how seq does its magic
00:09:44 <copumpkin> it's built in
00:09:52 <soupdragon> I think of seq as a typeclass
00:10:00 <Cale> cads: seq x y, when evaluated, ensures that x is evaluated before the result of evaluating y is made available
00:10:06 <soupdragon> (which is completely wrong.. but it's the only way I can get to sleep at night)
00:10:30 <Cale> seq could be implemented for most types using case
00:10:45 <Cale> x `seq` y = case x of Nothing -> y; Just _ -> y
00:10:52 <Cale> (for Maybe, for instance)
00:10:57 <ddarius> There used to be a type class for seq which saved parametricity.
00:11:24 <Cale> For functions it's built-in magic though.
00:11:34 * BMeph imagines comparing gravy to oranges...
00:11:49 <Cale> (since there's no way to use case to ensure that an expression is evaluated down to being a lambda)
00:12:20 <Cale> alexbobp: Oh, sorry, totally missed that line and was waiting for the paste :)
00:12:27 <alexbobp> Cale: ah, np
00:12:32 <alexbobp> Cale: I'm in no hurry, this is just practice code.
00:12:50 <alexbobp> Cale: I'm hanging out with a cs friend and we had an urge to test the theory and haskell seemed like the best tool for the job
00:12:52 <Cale> alexbobp: okay, so fibc will already evaluate its first parameter on each recursion
00:12:58 <alexbobp> the theory that the limit of the ratios of two fibonacci numbers is phi
00:13:09 <Cale> But what's happening is like this:
00:13:13 <copumpkin> adjacent :P
00:13:20 <copumpkin> or successive
00:13:25 <soupdragon> alexbobp, how do youproev that
00:13:25 <Cale> fibc 3 (1,1) -> fibc (3-1) (1,1+1)
00:13:34 <Cale> -> fibc 2 (1,1+1)
00:13:50 <Cale> -> fibc (2-1) (1+1,1+(1+1))
00:13:57 <Cale> -> fibc 1 (1+1,1+(1+1))
00:14:14 <Cale> Well, I'm not representing the sharing accurately here, but you see what's happening
00:14:36 <Cale> So you're going to build up these arithmetic expressions which'll only evaluate after fibc is done
00:14:47 <Cale> (at which point they'll be huge and blow the stack)
00:15:18 <Cale> So, we can just ensure that a and b are evaluated:
00:15:33 <Cale> fibc n x = a `seq` b `seq` fibc (n-1) (b, a+b)
00:15:51 <Cale> also note, you could just pattern match there, rather than using 'where'
00:15:56 <Cale> fibc n (a,b) = a `seq` b `seq` fibc (n-1) (b, a+b)
00:16:19 <Cale> It'd also be enough just to force one of the two.
00:16:21 <soupdragon> > map numerator $ iterate (\x->1+1/x::Rational) 1
00:16:22 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
00:16:23 <geheimdienst> and, instead of seq, can you put bangs into the destructuring bit?
00:16:31 <Cale> fibc n (a,b) = b `seq` fibc (n-1) (b, a+b) -- this should do
00:16:34 <Cale> yeah
00:16:43 <Cale> fibc n (a,!b) = fibc (n-1) (b, a+b) -- this should also do
00:16:47 <geheimdienst> fibc n (!a, !b) ?
00:16:51 <Cale> or that
00:16:52 <ddarius> geheimdienst: That requires a recent extension.
00:16:53 <geheimdienst> oic
00:17:12 <ddarius> geheimdienst: However, I expect this extension will get adopted in the not-too-distant future.
00:17:12 <Cale> But for that, you'll want  {-# LANGUAGE BangPatterns #-}
00:17:16 <geheimdienst> ddarius, because i'm inside a tuple? or bangs in general?
00:17:22 <copumpkin> soupdragon: that's neat
00:17:33 <ddarius> geheimdienst: Bang patterns.  Bangs in data types are standard Haskell 98.
00:17:34 <copumpkin> you probably don't even need the cast on it
00:17:45 <copumpkin> > map numerator $ iterate (\x->1 + 1 / x) 1
00:17:46 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
00:18:01 <Cale> alexbobp: anyway, does that make sense?
00:18:04 <copumpkin> > map numerator $ iterate (succ . recip) 1
00:18:05 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
00:18:09 <soupdragon> I found that when I was playing with continued fractions the other day
00:18:24 <Jafet> \phi = [1;1,1...]
00:18:28 <ddarius> Indeed.
00:18:32 <aavogt> > scanl1 (+) [1..]
00:18:33 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
00:18:42 <soupdragon> those are triangular numbers
00:18:55 <alexbobp> soupdragon: well we never really proved it, we just found that the decimal approximations we get look really close to phi...
00:19:01 <alexbobp> Cale: sorry, I spaced out, reading...
00:19:17 <Cale> alexbobp: You're right, the limit really is phi
00:19:53 <soupdragon> alexbobp: if you define it by x = 1 + 1/x and multiply both sides by x you get a quadratic, but that's still a bit off concluding, for a start.. a quadratic has two solutions but the continued fraction only has one value -- so what's going on here?
00:20:03 <cads> > (\x->1+1/x) 8
00:20:03 <lambdabot>   1.125
00:20:10 <soupdragon> (we can take a-priori that all continued fractions converge)
00:20:17 <cads> oh, numerator
00:20:22 <ddarius> soupdragon: phi^2 = 1 + phi
00:21:13 <soupdragon> I guess you could say _thou must be a quadratic irrational_ and solve   (A + Bsqrt(C))/D = 1+1/((A + Bsqrt(C))/D)
00:21:25 <ddarius> The two solutions are phi and 1/phi.
00:21:34 <alexbobp> Cale: Well I can now compute the one millionth fibonacci number linearly XD
00:21:36 <alexbobp> Cale: thanks!
00:21:40 <soupdragon> since that fixes sqrt to a specific value (using single valued functions)
00:21:45 <copumpkin> > map denominator $ iterate (succ . recip) 1
00:21:46 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
00:21:50 * BMeph thought the solutions were phi and -1/phi...
00:21:53 * geheimdienst sleepy. geheimdienst bed now. geheimdienst enough haskell. kthxbye, guys!
00:22:16 <alexbobp> Cale: seq is really cool.  I'll definitely remember that.
00:22:19 <ddarius> There is some ambiguity of which of those two solutions is meant when someone says "the golden ratio."
00:22:34 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in zipWith (/) (tail fibs) fibs
00:22:34 <lambdabot>   [Infinity,1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619...
00:22:34 <soupdragon> wow that method I just thuoght up is _Awful_
00:22:52 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in drop 10 $ zipWith (/) (tail fibs) fibs
00:22:53 <lambdabot>   [1.6181818181818182,1.6179775280898876,1.6180555555555556,1.618025751072961...
00:22:59 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in drop 30 $ zipWith (/) (tail fibs) fibs
00:23:00 <lambdabot>   [1.6180339887505408,1.6180339887496482,1.618033988749989,1.618033988749859,...
00:23:28 <Jafet> @quote undoubtedly
00:23:29 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
00:23:40 <Cale> > iterate (\x -> x - (x^2 - x - 1)/(2*x - 1)) 1
00:23:41 <lambdabot>   [1.0,2.0,1.6666666666666667,1.619047619047619,1.618034447821682,1.618033988...
00:23:48 <Cale> > drop 30 $ iterate (\x -> x - (x^2 - x - 1)/(2*x - 1)) 1
00:23:48 <lambdabot>   [1.618033988749895,1.618033988749895,1.618033988749895,1.618033988749895,1....
00:24:05 <alexbobp> what is "drop"?
00:24:18 <Cale> throws away the n first elements of the list
00:24:34 <Cale> (so we can see the later ones)
00:24:35 <soupdragon> I wish I could think of examples of "reverse induction"
00:24:45 <soupdragon> how does one come up with reverse induction problems, to set?
00:24:51 <soupdragon> like if you were a teacher for example
00:25:02 <Cale> reverse induction?
00:25:20 <soupdragon> Cale, well the only example I really know is one from The Book (inspired by Erdos)
00:25:39 <soupdragon> it's when you use an induction scheme that has a recursive case which goes 'backwards'
00:25:49 <soupdragon> likeum
00:25:51 <soupdragon> say the collatz thing
00:26:08 <soupdragon> if we proved that always terminates, you could use that as a reverse induction ordering
00:26:53 <soupdragon> P(1), (n even)P(n/2)=>P(n), (n odd)P(3n+1)=>P(n)
00:27:07 <soupdragon> that odd one is what makes it reverse induction
00:27:22 <dobie_gillis> has code.haskell.org been down long
00:27:24 <Cale> Okay
00:27:41 <soupdragon> I was trying to come up with examples but I really can't think of a way to construct problems for this
00:27:52 <soupdragon> at least with basic math you can just write a program to generate thousands of problems :P
00:28:12 <Cale> But those will all really be the same problem, and you shouldn't ever do that to someone ;)
00:29:48 <soupdragon> presumably I should be looking at strange recursive programs and turn them into arithmetic problems -- somehow
00:29:51 <Cale> Though your Collatz example doesn't quite fit that, induction actually works on an arbitrary well-ordered set.
00:30:08 <soupdragon> but all the recursive programs I know of are generally very simple schemes like folds
00:30:27 <dmwit> "How to Think Like a Computer Scientist, 1 new from $834.14" ... seems a bit overpriced
00:30:44 <soupdragon> Cale - yeah its just a name for a slightly unusual class of well orderings
00:31:30 <copumpkin> dmwit: it's an exclusive profession
00:32:39 <Cale> soupdragon: I suppose you could take normal induction problems and turn them into that, but that's kind of boring.
00:33:06 <Cale> (especially when something holds for all n, it doesn't make sense to prove it only up to some fixed number)
00:33:11 <soupdragon> Cale -- yeah it's got to be the most irritating thing to be using crazy indications schemes if they just make things harder
00:33:39 <soupdragon> but cases where this sort of scheme actually /helps/ are rare
00:33:41 <Cale> You need something which has a natural bound on it already
00:33:47 <Cale> yah
00:33:48 <Cale> yeah*
00:34:19 <Cale> I can imagine using it to prove things about binomial coefficients, if you wanted to work from the large end of the row for some reason.
00:34:32 <mreh> well I have frag compiling now, but the damn thing segfaults now
00:34:34 <aavogt> thinking?
00:34:46 <ddarius> Cale: "large end of the row" ?
00:34:59 <BMeph> I like the pattern Collatz makes in trinary. It seems almost self-solvable that way...
00:35:02 <Cale> ddarius: (n;k) where k is closer to n :)
00:35:16 <Cale> (I phrased that awkwardly, sorry :)
00:36:28 <mreh> dons: I have a patch for a compiling frag, the thing segfaults when you try to launch though
00:36:40 <dolio> Generate all Fibonacci numbers less than n.
00:36:41 <soupdragon> hehe
00:36:49 <soupdragon> I searched for the trinary thing and found this:
00:36:50 <Jafet> mreh, hah
00:36:54 <soupdragon> "This is much more obscure than normal induction, and itвЂ™s difficult to come up with any examples of things it can prove. IвЂ™m still working on that ;) "
00:37:01 <soupdragon> someone else who has the same problem as me
00:37:17 <mreh> you plug one hole and another one appears
00:40:05 * BMeph remembers to "explain" "large end of the row" as "far side of the triangle" - it's much clearer that way...
00:40:14 <dolio> Or, for a strictly increasing f : N -> N, generate a list of all f(m) < n.
00:40:45 <dolio> (In general.)
00:40:59 <soupdragon> so f = id
00:41:04 <dolio> That's one.
00:41:17 <soupdragon> that's the slowest function allowable I guess
00:41:28 <dolio> Yes.
00:42:36 <soupdragon> the easy way to code this is filter (< n) . map f $ [1..n-1], but I guess you want to justify the termination of the iterative algorithm
00:42:57 <soupdragon> (which takes longer to write out, but both are pretty easy)
00:43:16 <dolio> Yes, well, that first algorithm potentially does a lot more work than necessary.
00:43:53 <soupdragon> dolio, yeah i was just thinking, if we used some kind of 'monotonicFilter' and lazy evaluation, maybe that algorithm works just as well
00:44:05 <dolio> I guess you can use takeWhile and get away without much cruft if you're lazy.
00:44:35 <soupdragon> http://www.haskell.org/haskellwiki/Confluent_term_rewriting_system what the heck :|
00:46:13 <ivanm> soupdragon: so term rewriting is commutative? >_>
00:54:55 <dolio> ivanm: Yes, if you imagine that reductions are arrows in a category (which you may well be able to do).
00:55:41 <ivanm> dolio: well, I _was_ just thinking of terms as being some Source -> Source transformation function and they'd been all joined together with (.) ...
01:38:27 <soupdragon> fib (m+n) = fib m * fib n + fib (m-1) * fib (n-1)
01:38:37 <soupdragon> ^ could be the basis for a faster fib algorithm?
01:44:31 <dmwit> ?check testBit (-1)
01:44:32 <lambdabot>   Add a type signature
01:44:44 <xerox> copumpkin: I do not yell!!!
01:44:57 <dmwit> :t testBit
01:44:58 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
01:45:04 <dmwit> ?check testBit (-1 :: Integer)
01:45:05 <lambdabot>   "Falsifiable, after 2 tests:\n-3\n"
01:45:12 <dmwit> hah
01:45:19 <dmwit> > testBit (-1) (-1)
01:45:20 <lambdabot>   Ambiguous type variable `a' in the constraint:
01:45:20 <lambdabot>    `Data.Bits.Bits a'
01:45:20 <lambdabot>      a...
01:45:25 <dmwit> > testBit (-1 :: Integer) (-1)
01:45:26 <lambdabot>   False
01:45:52 <dmwit> ?check \n -> n >= 0 ==> testBit (-1 :: Integer) n
01:45:54 <lambdabot>   No instance for (Test.QuickCheck.Testable
01:45:54 <lambdabot>                     (Test.QuickCh...
01:46:20 <dmwit> ?check \n -> (n >= 0) ==> testBit (-1 :: Integer) n
01:46:21 <lambdabot>   No instance for (Test.QuickCheck.Testable
01:46:21 <lambdabot>                     (Test.QuickCh...
01:46:25 <dmwit> :t (==>)
01:46:26 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
01:47:06 <dmwit> :t \n -> (n >= 0) ==> (n > 1)
01:47:07 <lambdabot> forall a. (Num a, Ord a) => a -> Property
01:47:17 <dmwit> :t \n -> (n >= 0) ==> testBit (-1 :: Integer) n
01:47:18 <lambdabot> Int -> Property
01:47:51 <dmwit> ?instances-importing Test.QuickCheck Testable
01:47:52 <lambdabot> (), Bool, Gen prop, Prop
01:59:42 <Peaker> what's the point of () being testable?
02:00:00 <Peaker> @check ()
02:00:01 <lambdabot>   "Arguments exhausted after 0 tests."
02:00:13 <Peaker> @check Int -> ()
02:00:14 <lambdabot>   Parse error at "->" (column 5)
02:00:15 <dmwit> for exceptions, maybe?
02:00:23 <Peaker> @check (Int -> ())
02:00:23 <lambdabot>   Parse error at "->" (column 6)
02:00:27 <Peaker> oops :)
02:00:41 <Peaker> @check (\(x :: Int) -> ())
02:00:42 <dmwit> ?check \n -> ()
02:00:42 <lambdabot>   Parse error in pattern at "->" (column 14)
02:00:42 <lambdabot>   "Arguments exhausted after 0 tests."
02:01:22 <dmwit> ?check (\n -> ()) :: Int -> ()
02:01:23 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> ()'
02:01:43 <Peaker> @check (\(x :: Int) -> ()) -- parsed OK
02:01:43 <lambdabot>   Parse error in pattern at "->" (column 14)
02:01:46 <Peaker> or not
02:01:55 <dmwit> ?check ((\n -> ()) :: Int -> ())
02:01:56 <lambdabot>   "Arguments exhausted after 0 tests."
02:01:59 <dmwit> aha!
02:02:05 <Peaker> weird that it needs more ()
02:02:15 <dmwit>  ?check is doing something naughty with its code -- it's sticking it in the middle of an expression
02:02:43 <aavogt> @check \x -> x == x
02:02:44 <lambdabot>   "OK, passed 500 tests."
02:02:51 <aavogt> @check \x -> x == ()
02:02:52 <lambdabot>   "OK, passed 500 tests."
02:02:53 <kmc> you must construct additional pylons
02:09:12 <kmc> Peaker, the point is to confuse beginners
02:09:18 <kmc> @check \xs -> xs == reverse xs
02:09:19 <lambdabot>   "OK, passed 500 tests."
02:10:12 <aavogt> I suppose it writes    quickCheck $ ...
02:10:21 <aavogt> when it should be   quickCheck ( ... )
02:10:24 <kmc> ?
02:10:37 <aavogt> ?check \x -> x :: Bool
02:10:38 <lambdabot>   "Falsifiable, after 1 tests:\nFalse\n"
02:10:43 <aavogt> ?check \x -> x :: ()
02:10:44 <lambdabot>   "Arguments exhausted after 0 tests."
02:10:54 <kmc> ah
02:11:12 <aavogt> no, I'm doubting myself now
02:11:24 <Peaker> kmc, you're using () == () -- that uses the Testable Bool instance, not the Testable () instance
02:11:28 <aavogt> please do explain how you were convinced :)
02:16:45 <kmc> :t either throwIO return
02:16:46 <lambdabot> Not in scope: `throwIO'
02:17:01 <soupdragon> > (1+sqrt(2))^2
02:17:02 <lambdabot>   5.82842712474619
02:17:05 <kmc> :t either Control.Exception.throwIO return
02:17:06 <lambdabot> forall a a1. (GHC.Exception.Exception a) => Either a a1 -> IO a1
02:17:55 <kmc> > 3 + 2*sqrt 2
02:17:56 <lambdabot>   5.82842712474619
02:18:30 <soupdragon> > 1/(1+sqrt(2))
02:18:31 <lambdabot>   0.4142135623730951
02:18:57 <dmwit> > 5 + 2/(1 + sqrt 2)
02:18:58 <lambdabot>   5.82842712474619
02:20:02 <dmwit> > (7 + 5 * sqrt 2) / (1 + sqrt 2)
02:20:03 <lambdabot>   5.828427124746191
02:20:29 <dmwit> is there an anti-golf competition?
02:20:33 <dmwit> maximal de-optimization?
02:21:30 * hackagebot wumpus-core 0.16.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.16.0 (StephenTetley)
02:22:15 <tensorpudding> There are fewer limits on de-optimization
02:23:30 * hackagebot rad 0.1.1 - Reverse Automatic Differentiation.  http://hackage.haskell.org/package/rad-0.1.1 (EdwardKmett)
02:23:57 <soupdragon> woah that's rad
02:23:59 <edwardk> had a bug in exp =/
02:24:00 <soupdragon> ;d
02:24:10 <dolio> Next up: tubular.
02:24:13 <edwardk> =)
02:24:24 <soupdragon> tubular would be a good name for cyclindical algebraic decomposition :P
02:24:32 <edwardk> soupdragon: hehehe
02:25:10 <edwardk> I need to build a quickcheck suite for it that checks that it gives the same answers as Numeric.FAD
02:25:35 <soupdragon> wow seriously I have no idea what is going on in this code
02:25:40 <soupdragon> this is gonna take me all day to figure out :D
02:25:43 <edwardk> soupdragon: ?
02:25:50 <soupdragon> looking at RAD.hs
02:25:54 <edwardk> ah
02:26:16 <soupdragon> Constant, Variable, Binary, Unary?
02:26:16 <edwardk> basically it builds up a graph mapping the outputs backwards to the inputs of the function
02:26:19 <edwardk> yeah
02:26:20 <soupdragon> is that what Tape has in it
02:26:22 <soupdragon> okay
02:27:18 <edwardk> Binary takes the result of the function, the two off-axis elements of the transpose of the jacobian, and the two dependencies in the graph
02:28:41 <edwardk> then when you go to calculate diff, or some other function that happens to use the tape it starts from the result, converts the tree to a graph, sets the sensitivity to 1, and propagates it backwards through the graph. the wikipedia article on automatic differentiation might help as a guide
02:28:41 <skanev> is there a TextMate bundle that supports SCSS?
02:28:57 <edwardk> perhaps I should expand the constructor names now that the code is written ;)
02:29:07 <soupdragon> oh well I don't know about that, I figured it out
02:29:19 <kmc> edwardk, congrats on getting the name "rad"
02:29:25 <copumpkin> omg
02:29:35 <copumpkin> so many east-coasters up at this ungodly hour
02:29:45 <kmc> i'm a west-coaster at this point in time
02:29:51 <copumpkin> oh really!
02:29:53 <copumpkin> weird
02:30:04 <edwardk> copumpkin: a cat meowing outside my bedroom door wouldn't let me sleep ;)
02:30:05 <copumpkin> well, me and edwardk at least
02:30:09 <kmc> back at caltech as a creepy alum
02:30:18 <copumpkin> edwardk: is it a lolcat?
02:30:23 <copumpkin> @quote lolcategory
02:30:23 <lambdabot> tensorpudding says: lolcategory demands moarphisms
02:30:34 <edwardk> *groan*
02:30:36 <copumpkin> edwardk: cause you should've given him some moarphisms in that case
02:30:43 <edwardk> lolcat is a proper subcategory of cat
02:30:50 <copumpkin> kmc: sweet, I'm a permanent creepy alum
02:30:53 <Jafet> You could huff him for med-x
02:31:23 <copumpkin> epic moarphisms?
02:33:15 <Jafet> let desu = return
02:33:29 <edwardk> mostly i just tossed him in the back room so my wife could continue to get some sleep and came over here to code for a while ;)
02:34:01 <copumpkin> edwardk: oh, it's your cat?
02:34:07 <Raynes> By code, obviously you mean talk on IRC.
02:34:20 <copumpkin> figures that edwardk would have cats
02:34:33 <Raynes> I has an lolcat.
02:34:56 <kmc> wait med-x comes from cats?
02:35:19 <copumpkin> he probably mistook a cat theory book for a book about pets and accidentally became a mathematician when he read it
02:35:51 <aavogt> haha
02:36:32 <edwardk> copumpkin: yeah two of them
02:37:10 <xerox> cat and cat^op
02:37:33 <copumpkin> are they isomorphic?
02:38:48 <soupdragon> what does C being isomohrpism to C^op give you?
02:39:10 <edwardk> copumpkin: i've been afraid to find out. if i try to turn my cat inside out, i think they might arrest me
02:40:53 <DigitalKiwi> Jafet: DESU DESU DESU
02:41:42 <Taejo> are systems of linear equations over {0,1} NP-complete? I don't mean Z/2Z -- the variables can only be in 0 or 1, but the addition is ordinary Z-addition, and the "right hand side" can contain any integers
02:42:47 <edwardk> Taejo: what keeps you from just performing gaussian elimination?
02:42:51 <kmc> so it's just a linear equation over Z, where variables range over {0,1}?
02:43:00 <Taejo> kmc: yes
02:43:07 <Jafet> newtype DESU a = DESU { desu :: String -> a }
02:43:10 <kmc> well you can find all the solutions without that restriction
02:43:16 <kmc> using gaussian elimination or whatever
02:43:22 <kmc> and see if any of them conform to the restriction
02:43:26 <soupdragon> are the variables integers?
02:43:28 <soupdragon> ooh
02:43:33 <soupdragon> you said that sorry
02:43:38 <Jafet> It's even easier over Z/2Z.
02:43:43 <copumpkin> newtype DESU a = DESU (DESU a -> a)
02:43:48 <Taejo> I know it's easier over Z/2Z
02:44:12 <tensorpudding> Not many interesting equations over Z/2Z
02:44:36 <copumpkin> omg another east coaster is still awake
02:44:40 <Taejo> tensorpudding: there was a google code jam question where you had to solve linear systems over Z/2Z
02:44:40 <copumpkin> tensorpudding: you're east coast, right?
02:44:42 <soupdragon> so is it like  3x+7y=3;1x+5y=9 ?
02:44:48 <soupdragon> whre x and y are just 0 or 1
02:44:51 <Taejo> or maybe GCJ Africa
02:44:52 <tensorpudding> yeah
02:45:39 <Taejo> kmc: that's what I thought, but it seems to me that you can reduce the minesweeper consistency problem to this one, which would make it NP-Hard
02:46:01 <Taejo> (it all started with me thinking up minesweeper variants)
02:46:11 <soupdragon> so it's actually like  x+y=4;z+y=2?
02:46:15 <soupdragon> there are no integers on the left
02:46:31 <Taejo> soupdragon: ah, yes
02:46:47 <soupdragon> btw I'm annoyed I didn't realize that
02:46:59 <soupdragon> because I actually did solve minesweeper problems in this exact way
02:47:11 <soupdragon> just used CHR though for solving the equations
02:47:24 <Taejo> CHR?
02:47:31 <soupdragon> well it just does constraint solving
02:47:36 <soupdragon> swi prolog library
02:48:17 <Taejo> so solving these equations is NP-complete?
02:49:20 * DigitalKiwi wonders if m0nkfish is a warrior m0nkfish
02:49:36 <soupdragon> I'm not sure
02:50:00 <soupdragon> Taejo, if you allowed subtraction on the left I think you can always turn these equations into a minesweeper problem
02:50:06 <soupdragon> but without that i don't see a way to do it
02:51:24 <Taejo> why are you turning these equations into minesweepers -- to prove NP-hardness or to actually solve minesweepers, you need to go the other way
02:51:53 <Jafet> Describe this reduction
02:51:57 <jmg> hi
02:52:28 <jmg> i've just wondering why there are no functor instances for Data.Vector.*
02:53:02 <copumpkin> jmcarthur: functor doesn't fit
02:53:09 <copumpkin> rfunctor maybe
02:53:20 <jmg> what's rfunctor?
02:53:22 <Taejo> Jafet: each unknown square in the minesweeper grid becomes a variable over {0,1} where 0 represents a safe square and 1 a mine. The known squares give you equations about their neighbours: if x, y and z neighbour a 1, you get x + y + z = 1
02:53:32 <copumpkin> restricted functor
02:53:37 <copumpkin> vector has a typeclass of elements
02:53:45 <copumpkin> you can't fmap arbitrarily
02:53:45 <jmg> ah, ok
02:53:54 <Jafet> Taejo, that merely tells you whether you can unambiguously proceed with one ply lookahead.
02:53:58 <copumpkin> and I think the boxed vector does have a functor instance
02:54:07 <jmg> thanks, should have been obvious
02:54:08 <copumpkin> doesn't it?
02:54:24 <soupdragon> say the biggest integer on the RHS was 27
02:54:39 <soupdragon> can you sya this problem is equivalent to solving the system over Z/28Z?
02:54:43 <jmg> no it doesn't
02:54:56 <copumpkin> @hackage vector
02:54:56 <lambdabot> http://hackage.haskell.org/package/vector
02:55:18 <copumpkin> weird
02:55:37 <Taejo> Jafet: oh, of course!
02:55:38 <jmg> yeah, perhaps to keep the implementations interchangable
02:55:44 <copumpkin> yeah
02:56:12 <jmg> so, i'll write my own fmap for my cases
02:56:23 <Taejo> So minesweeper is *essentially* interactive (assuming P /= NP). That's a nice result anyway
02:57:16 <Jafet> I'm currently reading on sliding block puzzles. Those are PSPACE-complete.
02:58:46 <Taejo> I want to write a minesweeper where you never have to guess (the minesweeper on hackage claims this property, but actually in that you often have to guess -- you just never guess wrong)
02:59:12 <Jafet> That seems to follow the behaviour of the Microsoft version.
02:59:24 <Jafet> What do you mean by "guess"?
02:59:31 <tensorpudding> Simon Tatham's puzzle collection has a minesweeper like that.
02:59:40 <Taejo> Jafet: where there are multiple solutions
02:59:43 <Jafet> If you want to reduce all lookahead to one, that wouldn't make it very interesting
02:59:44 <katia> люди ктонибудь помогите как можно взломать мир пользователя очень надо!
03:00:01 <Taejo> Jafet: indeed! I want hard minesweepers, but not impossible ones
03:00:21 <Jafet> вЂЅвё
03:00:40 * hackagebot AES 0.2.7 - Fast AES encryption/decryption for bytestrings  http://hackage.haskell.org/package/AES-0.2.7 (SveinOveAas)
03:00:53 <Taejo> but I hate it when you finish an expert puzzle except for four square and there are two solutions, and you don't know which the program has chosen
03:00:55 <tensorpudding> As in, it guarantees that the puzzle is solvable without making any guesses.
03:01:08 <Jafet> Taejo, I don't know then. It's possible that the complexity of making such puzzles is similar or exceeding that of solving them (which has proven true in other NP games)
03:01:19 <Taejo> indeed
03:01:26 <copumpkin> katia: we don't understand your encoding :P
03:01:40 * hackagebot SHA2 0.2.2 - Fast, incremental SHA hashing for bytestrings  http://hackage.haskell.org/package/SHA2-0.2.2 (SveinOveAas)
03:01:52 <copumpkin> kazakhstan?
03:01:53 <Taejo> Jafet: you can probably reduce Unique-SAT to it
03:02:04 <tensorpudding> http://www.chiark.greenend.org.uk/~sgtatham/puzzles/ is the link.
03:02:23 <Taejo> tensorpudding: thanks
03:02:40 * hackagebot Hermes 0.0.3 - Message-based middleware layer  http://hackage.haskell.org/package/Hermes-0.0.3 (SveinOveAas)
03:03:03 <Jafet> Hmm, some classic games there
03:03:17 <tensorpudding> He invented virtually nothing about the games.
03:04:31 <kmc> :t flip ((join .) . fmap)
03:04:32 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
03:04:33 <Jafet> One of the wackiest puzzle makers is that new age maze guy
03:05:21 <Taejo> what I originally wanted to do was design small puzzles that required deep reasoning, and could be solved with pencil and paper, but since the interactivity is essential, I definitely have to give up the latter
03:05:45 <katia> People ктонибудь help as it is possible to crack the world of the user very much it is necessary!
03:06:25 <Jafet> "Pencil and paper" reminds me of http://www.morpionsolitaire.com/
03:08:02 <Taejo> tensorpudding: it seems to generate fairly shallow puzzles
03:08:21 <tensorpudding> What does, mines?
03:08:33 <katia> People ктонибудь help as it is possible to crack the world of the user very much it is necessary!
03:08:39 <tensorpudding> It generates the same kind that minesweeper does.
03:08:43 <Taejo> Jafet: OTOH, just because it's NP-complete doesn't mean it can't be done (for small sizes)
03:08:52 <Jafet> Sure. See Sudoku.
03:09:23 <Taejo> tensorpudding: perhaps the elimination of ambiguity also accidentally eliminates some complexity
03:09:25 <Jafet> Is katia a crack user or what
03:10:13 <Jafet> That depends on how you sample puzzles. If you just generate random puzzles and discard ambiguous ones, then the remaining ones are guaranteed still hard. That probably isn't practical, though.
03:14:58 <tensorpudding> only overzealous algorithms would eliminate cases where the problem was hard but not impossible, instead of just the ones where it was impossible
03:15:19 <tensorpudding> it's possible that the algorithm mines uses to ensure solvability is overzealous
03:17:37 <kmc> so is there a name for the GADT whose constructors have the types of return, fmap, and join?  or return and bind?
03:17:42 <kmc> or the Monad instance of such?
03:17:47 <kmc> it's not really a monad because it's not associative
03:18:33 <kmc> something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25523#a25523
03:18:54 <kmc> i think the Monad instance is somewhat sane as long as T is abstract and only runT is provided
03:18:57 <kmc> anyway, is this good for anything?
03:20:07 <triyo> Hi all. I have a code snippet here: http://codepad.org/RFFxhaT5 . I am still in early stages learning haskell and this code even to me doesn't look quite right.
03:20:23 <triyo> Firstly, I am not sure about the function argument list.
03:21:29 <triyo> I read in the argument list form the commnd line using getArgs, should this function perhaps receive the [String] argument list?
03:21:44 <triyo> Next, all those null check ver
03:21:45 <triyo> 
03:22:05 <triyo> look very non-idiomatic
03:23:04 <Saizan> kmc: that made me think of Program here: http://apfelmus.nfshost.com/articles/operational-monad.html
03:23:46 <triyo> So real purpose of the function is to build  a predicate function based on a given String argument list
03:24:08 <Twey> override [] ys = ys; override (x : xs) (_ : ys) = x : override xs ys
03:25:40 <Olathe> override xs [] = xs
03:25:51 <Twey> Yeah
03:26:23 <Twey> getArgs >>= run . flip override [list, of, default, args]
03:26:30 <kmc> triyo, case (isRecur, null fileExt) of (False, True) -> ...; (True, True) -> ...; ...
03:27:08 <kmc> triyo, or pull it out to the top level
03:27:32 <kmc> buildPred False "" = ...; buildPred True "" = ...; buildPred False fileExt = ...; buildPred True fileExt = ...
03:28:12 <kmc> i recommend that actually
03:28:15 <triyo> Oh I see patter matching on func arguments
03:28:30 <Twey> :t join $ fmap (++) . drop . length
03:28:32 <lambdabot> forall a. [a] -> [a] -> [a]
03:29:20 <mreh> newtype deriving seems like magic to me
03:29:40 <kmc> mreh, evil magic: http://hackage.haskell.org/trac/ghc/ticket/1496
03:31:03 <kmc> but the basic idea is simple
03:31:22 <kmc> since the newtype is equivalent to the underlying type
03:31:31 <kmc> you should be able to reuse the underlying type's instances
03:36:56 <Olathe> triyo: http://codepad.org/ohQfa48H
03:38:04 <mreh> kmc: how do I instruct ghc to derive a newtype from another?
03:38:24 <mreh> syntactically
03:38:39 <kmc> err, what do you mean
03:38:50 <kmc> i thought by "newtype deriving" you meant the GeneralizedNewtypeDeriving extension
03:38:58 <mreh> kmc yes
03:39:00 <kmc> which has basically the same syntax as other typeclass "deriving"
03:39:11 <kmc> that doesn't derive a newtype from another newtype
03:39:21 <kmc> it derives a class instance for a newtype based on a class instance for the underlying type
03:39:39 <xxxxllll> Who uses DarkComet-RAT 2.0 RC5?
03:39:46 <kmc> newtype Foo = Foo Int deriving (Eq, Num, Bounded)
03:40:05 <mreh> kmc: oh, I didn't understand how it did it
03:40:56 <mreh> I want to derive a RandomArrow
03:40:57 <kmc> confused
03:41:07 <mreh> from StateArrow
03:41:08 <kmc> you mean how the implementation in GHC works?
03:41:34 <aavogt> that's the only one, isn't it?
03:41:43 <mreh> aavogt: yep
03:41:53 <kmc> @hoogle StateArrow
03:41:54 <lambdabot> No results found
03:42:15 <aavogt> @hoogle ArrowState
03:42:16 <lambdabot> No results found
03:43:08 <roconnor> @src (>>=) ContT
03:43:09 <lambdabot> Source not found. Wrong!  You cheating scum!
03:43:16 <roconnor> @src ContT (>>=)
03:43:17 <lambdabot> m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
03:43:37 <mreh> newtype RandomArrow a b = RA (StateArrow RandomGen a b) -- might do it non?
03:46:56 <roconnor> I wonder if GHC's pointer tagging will speed up my original DNAmonad code
03:47:29 <roconnor> edwardk: you around?
03:47:57 <edwardk> roconnor: yeah
03:48:00 <edwardk> roconnor: whats up?
03:48:20 <mreh> DNAmonad??
03:48:22 <roconnor> Do you understand what Derek Elkin's is saying in this [Haskell-cafe] Speed of Error handling with Continuations vs.  Eithers thread
03:48:26 <edwardk> hacking up a test suite to compare the outputs of Numeric.FAD to Numeric.RAD
03:49:01 <edwardk> roconnor: haven't looked yet. i noticed in the original question that the poster didn't say what optimization level he was testing
03:49:12 <edwardk> which makes a huge difference with CPS'd code
03:49:47 <roconnor> ``
03:49:49 <roconnor> I've copy/pasted the code below, any suggestions on optimization, or if this is simply a bad idea would be much appreciated.
03:49:50 <roconnor> Strangely, compiling with -O2 seems to have no effect on the speed:
03:50:03 <roconnor> from the original message
03:51:22 <roconnor> ah
03:51:34 <roconnor> Derek is saying that type CEEither a b = forall c. (a -> c) -> (b -> c) -> c  is slow
03:51:46 <roconnor> and instead forall r . ContT r (Either e) a is fast
03:51:54 <edwardk> roconnor: yeah
03:52:14 <roconnor> I'm surprised by that
03:52:34 <roconnor> I vaguely see why that might be the case
03:53:03 <edwardk> ContT r (Either e) is a codensity monad, so it has free fmap, return, bind that don't have to look at the altnerate cases.
03:53:07 <edwardk> er alternate
03:53:29 <roconnor> because ContT r (Either e) a  has make the value hold a "bubble to the top" or has turned Either insideout
03:53:34 <roconnor> to use terrible analgoies
03:54:16 * Saizan is getting highly weird results from that particular benchmark
03:54:31 <roconnor> @src ContT (>>=)
03:54:31 <lambdabot> m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
03:54:48 <Saizan> Criterion is giving me 7 *u*s for Either and 13 *m*s for the codensity version
03:55:11 <roconnor> :O
03:55:13 <Fanael> O.o
03:55:55 <Saizan> with -O2 on x86_64
03:55:56 <roconnor> bindErrCPS m f =  ErrCPS $ \err good -> runErrCPS m err $ \x -> runErrCPS (f x) err good
03:56:12 <roconnor> edwardk: what I don't get is that bindErrCPS and the bind for ContT look so similar
03:56:23 <roconnor> edwardk: why is th bindErrCPS slow?
03:57:13 <NIXDAEMON-COOL> how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
03:58:30 <roconnor> striping off the no-op constructors and projections we have m >>= k  = \c -> m (\a -> k a c)  vs
03:58:50 <maurer_> NIXDAEMON-COOL: You are the best.
03:58:51 <roconnor> m >>= f = \err good -> m err (\x -> f x err good)
03:59:02 <kmc> @remember NIXDAEMON-COOL how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
03:59:02 <lambdabot> I will never forget.
03:59:17 <NIXDAEMON-COOL> ??
03:59:28 <kmc> @nixon
03:59:28 <lambdabot> The presidency has many problems, but boredom is the least of them.
03:59:33 <kmc> @protontorpedo
03:59:33 <lambdabot> ok so say I ftp files from some 50 remote servers now, and then read them inot mysql, then ftp back to an ohter 50 servers some info they read into thier informix db
03:59:39 <roconnor> @vixen
03:59:39 <lambdabot> Ok
03:59:45 <kmc> @. vixen nixon
03:59:46 <lambdabot> i think you know the answer to that one, silly
03:59:50 <kmc> @. vixen nixon
03:59:50 <lambdabot> i think i can...
03:59:52 <edwardk> roconnor: i know ContT gets handled nicely by the internal compiler optimization passes, it might just be that the rules need a little bit of love to handle things like ErrCPS a bit nicer
04:00:03 <NIXDAEMON-COOL> I needs make have web application employment boss in morning before
04:00:31 <maurer_> NIXDAEMON-COOL: Joke's getting old real fast.
04:00:35 <zygoloid> is someone playing with markov chains?
04:00:37 <NIXDAEMON-COOL> ??
04:01:03 <NIXDAEMON-COOL> unhelps you are large
04:01:20 <soupdragon> that was pretty funny
04:01:21 <Fanael> Ahem.
04:01:48 <Fanael> What did he want, after all?
04:02:18 <Twey> To patch KDE2 under FreeBSD, perhaps
04:02:40 <silver> nah, this stuff should be asked at #anime
04:03:46 <dolio> @protontorpedo
04:03:46 <lambdabot> so haskell is new and improved c?
04:03:49 <hoknamahn> hi guys. I want to make a type which is rather a synonym for some type family (let's say for Int, Double, String). So I could create a homogeneous list of Int, Double, String but not Float or Integer. What is a better way of doing it?
04:04:11 <kmc> hoknamahn, data MyThing = MyInt Int | MyDouble Double | MyString Strng
04:04:19 <hoknamahn> homogeneous
04:04:32 <kmc> hoknamahn, but probably you can come up with names that relate to your probelm domain
04:04:35 <Saizan> roconnor: maybe it's the double use of err that causes trouble
04:05:00 <aavogt> @hackage HList -- maybe
04:05:01 <lambdabot> http://hackage.haskell.org/package/HList -- maybe
04:05:39 <hoknamahn> kmc, I understand that [MyThing] is still homogeneous list but in fact it allows me to have different types mixed inside of one array. You know what I mean
04:05:40 <aavogt> hoknamahn: what do you plan to do with the elements of the list?
04:05:49 <zygoloid> hoknamahn: IsIntDoubleOrString t => [t]
04:06:19 <aavogt> zygoloid: that makes the list one of Int, Double, String, but no combinations of them
04:06:27 <kmc> hoknamahn, data MyThing f = MyInt (f Int) | MyDouble (f Double) | MyString (f String)
04:06:29 <zygoloid> aavogt: that's what hoknamahn wants iiuc
04:06:29 <hoknamahn> so basic idea that I can have lists of Strings or Ints Or Doubles
04:06:30 <kmc> then e.g.
04:06:43 <kmc> MyInt [2,3,4] :: MyThing []
04:06:54 <kmc> MyDouble (Just 1.2) :: MyThing Maybe
04:06:58 <maurer_> data Lister = ListerInt [Int] | ListerDouble [Double]...
04:07:14 <zygoloid> kmc: that's not really composable :(
04:07:45 <hoknamahn> can we use type families for that?
04:07:55 <kmc> hoknamahn, not sure how
04:07:59 <zygoloid> hoknamahn: it sounds like you want a typeclass.
04:08:09 <hoknamahn> yep i know i can use type classes
04:08:20 <hoknamahn> i thought maybe there is a way to go without it
04:08:30 <kmc> hoknamahn, maybe if you give us more context about why you want to do this
04:09:24 <plumenator> Has anybody been able to install hashell recently?
04:09:36 <hoknamahn> well. for instance we have a point cloud. each point has the same set of attributes. only a certain types allowed to be written into attribute lists
04:09:40 <zygoloid> does anyone know of a library on hackage wrapping the ptrace syscall?
04:10:13 <kmc> so a point can have either string attributes or double attributes but not a mixture of the two?
04:10:37 <kmc> zygoloid, google provdes nothing
04:10:45 <aavogt> so the quesion is:   Either [Double] [String]     or  [Either Double String]
04:11:36 <aavogt> the latter is a bit more tricky to get if you want instead of Double, String, to have some arbitrary member of a typeclass
04:12:07 <hoknamahn> i think i have to try type class
04:12:08 <Olathe> triyo: http://codepad.org/ohQfa48H
04:12:15 <hoknamahn> what type families for then?
04:12:40 <zygoloid> type families are for implementing open type functions
04:13:04 <kmc> type families give you functions from types to types which are defined by pattern-matching the types
04:13:10 <triyo> Olathe: thx, I went the case of route. http://codepad.org/2py1ROTL
04:13:38 <kmc> data families give you things like "adaptive containers" that look like polymorphism but where the representation depends on the type argument
04:14:15 <mreh> @src Kleisli
04:14:15 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:14:19 <kmc> hoknamahn, if you look in the papers, ghc manual, etc. you will find examples
04:14:31 <kmc> it's not clear to me why this would relate to type families
04:14:56 <hoknamahn> okay that was my missunderstanding
04:15:08 <triyo> I have a single function that needs to be called on two distinct pattern matches. Is there a way to do an "or" of some sort on function argument matching?
04:15:29 <aavogt> triyo: not nicely
04:16:02 <Twey> triyo: Pattern guards
04:16:15 <Twey> Wait
04:16:18 <ivanm> preflex: seen Igloo
04:16:18 <preflex>  Igloo was last seen on #ghc 10 seconds ago, saying: i.e. I suspect that any Gentoo user using a recent GHC has a recent enough gcc that they need the most recent extra-gcc-opts contents
04:16:30 <Twey> Do pattern guards allow for вЂorвЂ™?  I know they have вЂandвЂ™
04:16:37 <aavogt> you could write something like:      let (a,b,c) = case x of patt1 -> (x,y,z); patt2 -> (x,y,z) in  ... expression that uses a,b,c
04:16:47 <mreh> how can I wrap computation in a Kleisli? Is the constructor visible?
04:16:56 <kmc> triyo, make a helper function
04:17:05 <mreh> he's back
04:17:10 <NIXDAEMON-COOL> i undo make bad of code go collide fix how to ??
04:17:12 <triyo> cool thx guys
04:17:26 <Fanael> Nani?!?
04:18:01 <Fanael> I have no clue what are you talking about.
04:18:13 <Saizan> NIXDAEMON-COOL: this cannel is about the Haskell programming language, it's not appropriate for discussing anything else
04:18:16 <kmc> NIXDAEMON-COOL, why did you come to #haskell?
04:18:44 <aavogt> @type \x -> case case x of Left (a,(_,b)) -> (a,b); Right (_,(a,b)) -> (a,b) of (a,b) -> a+b
04:18:45 <lambdabot> forall t t1 t2. (Num t) => Either (t, (t1, t)) (t2, (t, t)) -> t
04:18:49 <kmc> this channel is for talking about Haskell, category theory, logic, other math, and how much C++ sucks
04:18:51 <NIXDAEMON-COOL> a program make haskell for boss collide how to fix ??
04:18:53 <Fanael> Saizan: *channel
04:19:08 <kmc> NIXDAEMON-COOL, are you a bot?
04:19:10 <aavogt> triyo: ^^
04:19:19 <Fanael> I still don'tt understand him.
04:19:22 <Fanael> don't*
04:19:55 <aavogt> so in other news, or-patterns are quite ugly to emulate in haskell
04:19:55 <triyo> aavogt: thx
04:20:00 <NIXDAEMON-COOL> ?? i dont english make understand i do not. how to what means bot ??
04:20:01 <lambdabot>  i dont english make understand i do not. how to what means bot
04:20:08 <Fanael> kmc: but C++ doesn't suck :P
04:20:11 <mreh> lol
04:20:15 <Fanael> :D
04:20:18 <kmc> Fanael, let's have an extended discussion about it
04:20:34 <mreh> NIXDAEMON-COOL: what languages do you speak other than english?
04:20:44 <Fanael> Japanese, perhaps.
04:20:45 <kmc> NIXDAEMON-COOL, we have no idea what question you are asking or why you are asking it here
04:20:52 <mreh> could we find him a room that speaks him language
04:20:52 <kmc> does it relate to the programming language named Haskell?
04:21:02 <mreh> s/him/his
04:21:07 <kmc> try lojban
04:21:08 <NIXDAEMON-COOL> english is ungood, haskell program i write collide
04:21:14 <kmc> it's the logical language
04:21:33 <tensorpudding> @remember lambdabot i dont english make understand i do not. how to what means bot
04:21:33 <lambdabot> It is forever etched in my memory.
04:21:35 <mreh> I asked what language you do speak
04:21:38 <Fanael> Ah! "ungood"! Newspeak!
04:22:08 <NIXDAEMON-COOL> haskell
04:22:11 <kmc> NIXDAEMON-COOL, can we see your code?
04:22:15 <maurer_> NIXDAEMON-COOL: What languages do you speak? Maybe someone who speaks your language can help you in PM?
04:22:21 <Peaker> Fanael, I hate inheritance... People learn C++ and then they use it. It's terrible.  And then they "emulate" C++ inheritance in C, which is even worse
04:22:25 <kmc> can you put it on hpaste.org perhaps?
04:22:40 <Ferdirand> "I don't english make, understand I do not" that kind of made sense
04:22:47 <mreh> if he doesn't start making sense soon... I'll carry on with my work
04:22:47 <Peaker> Fanael, C++ templates are a large step in the right direction, but done so horrible..
04:22:48 <triyo> If I have a longer line like so "loadFindArgs badArgs = error $ "Invalid argument list: " ++ (intercalate ", " badArgs) ++ "\n\n" ++ usage" where should I place the break line in haskell, best practice if any?
04:23:16 <NIXDAEMON-COOL> code is boss no can upload epect for boss company
04:23:17 <aavogt> drop the parens
04:23:33 <triyo> and should it go right under error function or slightly indented, any guidelines on the wiki for this?
04:23:49 <kmc> NIXDAEMON-COOL, then what information can you give us to figure out what your problem is and why it's occurring?
04:23:52 <maurer_> NIXDAEMON-COOL: With no code and no problem, how can we help you?
04:24:11 <aavogt> maurer_: but the collisions... can't you see?
04:24:26 <kmc> i'm guessing that means "crash"?
04:24:32 <maurer_> aavogt: There's a reasonable chance that this guy actually needs help and just has bad english.
04:24:47 <triyo> aavogt: I droped the parens, thx. Now where would you break line so line doesn't go over much then 80char
04:25:06 <NIXDAEMON-COOL> boss make allow upload make put  small amount in website put up
04:25:08 <NIXDAEMON-COOL> i do
04:25:17 <mreh> :D
04:25:17 * hackagebot constructive-algebra 0.0.0 - A library for constructive algebra.  http://hackage.haskell.org/package/constructive-algebra-0.0.0 (AndersMortberg)
04:25:27 <aavogt> triyo: be ugly and drop the spaces between the ++, and then it fits?
04:25:41 <mreh> executive decision are made fast in that company
04:26:00 <aavogt> but to be more serious, it doesn't really matter where you stick the newline in there
04:26:05 <Liskni_si> so do I have to switch to non-english whenever I want to get a lot of attention?
04:26:21 <aavogt> Liskni_si: broken english seems more effective
04:27:00 <Fanael> Peaker: yeah, C++ templates are a large step in the right direction, if the "right direction" means back.
04:27:27 <Saizan> @remember Fanael yeah, C++ templates are a large step in the right direction, if the "right direction" means back.
04:27:27 <lambdabot> I will never forget.
04:27:30 <kynky> i thought templates were good
04:27:31 <Peaker> Fanael, towards parametric types (even though templates have horrible syntax and a horrible implementation)
04:27:39 <Liskni_si> aavogt: cool, will try next time need help I some.
04:27:49 <Peaker> pretty sad that Java/C# copied most of the horrible syntax
04:28:05 <Peaker> language designers are so terrified of changing any syntax people know
04:28:05 <kmc> i like how we're moving "towards" something that was worked out 40 years ago
04:28:05 <sepp2k> But none of the interesting features.
04:28:15 <Peaker> kmc, You mean by HM?
04:28:29 <kmc> well, inference is a separate thing
04:28:32 <kynky> i thought BASIC had horrible syntax
04:28:39 <kmc> just polymorphism
04:28:39 <Fanael> Hmm, is there anything in C++ what doesn't have horrible syntax and a horrible implementation?
04:28:44 <Peaker> kmc, where were there static parametric types, including higher-kinded ones?
04:28:45 <triyo> aavogt: " it doesn't really matter where you stick the newline in there" .. Ok, now should the new line begin right under the error function or a bit indented to depict that its the previous line is continuing?
04:28:53 <kmc> Peaker, ML?
04:28:59 <Fanael> Except the C part of C++, of course.
04:29:01 <NIXDAEMON-COOL> upload code to that collide I did to give how to ??
04:29:04 <kmc> System F is parametric
04:29:25 <mreh> anyone understand that one?
04:29:39 <hoknamahn> :))
04:29:53 <scree> NIXDAEMON-COOL: are you dutch by any chance?
04:30:02 <aavogt> a bit indented, triyo
04:30:03 <Twey> American address.
04:30:07 <NIXDAEMON-COOL> i make new hpastess.org for you in website do you get or i send ??
04:30:21 <kmc> this is it? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25524
04:30:23 <NIXDAEMON-COOL> american friend i have give shell irssi ubuntu plan
04:30:34 <NIXDAEMON-COOL> kmc find
04:31:26 <kmc> NIXDAEMON-COOL, this is a fine Haskell expression
04:31:33 <mreh> I was expecting something more difficult
04:31:48 <soupdragon> wow
04:31:51 <soupdragon> 'constructive algebra'
04:31:52 <Saizan> i guess the problem is that it uses too much memory (maybe Heap overflow?)
04:31:54 <NIXDAEMON-COOL> collide crash make do it not
04:32:02 <soupdragon> that's a BIG title for code that does NOTHING
04:32:04 <maurer_> NIXDAEMON-COOL: We see the code, what is it doing that you don't expect?
04:32:11 <Fanael> C++ templates rocks. While other C++ features generally interact poorly with each other, templates set the record by interacting poorly with themselves.
04:32:22 <NIXDAEMON-COOL> maurer_ kmc find
04:32:31 <Twey> Fanael: Heheheh
04:32:45 <Saizan> NIXDAEMON-COOL: are you compiling with -O2 ?
04:32:51 <scree> that code has a massive space leak
04:32:59 <scree> is that likely to be the problem?
04:33:01 <illissius> i don't get this C++-sucks-but-C-is-cool thing. sure, it ain't exactly simple and elegant, but it's still a hell of a lot nicer to program in than C.
04:33:08 <illissius> (but maybe that's because I've only ever used it with Qt)
04:33:15 <kmc> illissius, C++ pretends to be something C never pretended to be
04:33:25 <Saizan> scree: i guess so, that's what "crash" should be referring to
04:33:30 <kmc> C is a fine systems language.  C++ is also a decent systems language
04:33:33 <Twey> illissius: C is intended to be minimalistic and low-level, which it managesвЂ¦ to a certain extent
04:33:34 <Peaker> illissius, I don't find it very nice... So many unnecessary pitfalls
04:33:38 <NIXDAEMON-COOL> boss make compile somebody other do tell me collide Saizan
04:33:39 <kmc> but people also use it for applications programming
04:33:53 <maurer_> scree: Yes, it almost certainly is. I don't want to try to explain fold' through a language barrier though.
04:33:55 <mreh> the games industry is run on C++
04:34:14 <mreh> and anime artists tears
04:34:20 <scree> I guess we just post a working version and see what happens?
04:34:29 <Saizan> NIXDAEMON-COOL: try like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25524#a25525
04:34:41 <mreh> just like the engineering world is run on MATLAB
04:34:49 <mreh> has the world gone completely mad?!
04:35:29 <NIXDAEMON-COOL> i make send Saizan boss tell other email twitter thank you
04:35:49 <aavogt> maurer_: the issue is that the holding on to the common subexpression causes a space leak
04:36:00 <maurer_> Saizan: Does that actually do anything different?
04:36:12 <aavogt> Saizan: that's a nice solution :)
04:36:21 <Saizan> maurer_: removes sharing
04:36:35 <maurer_> Saizan: How does it do that? (I believe you, simply don't know how)
04:36:41 <illissius> at any rate, Qt/C++ is, imo, nicer than C# or Java
04:36:48 <illissius> otoh, boost is scary.
04:36:55 <Fanael> What?
04:37:16 <Fanael> C
04:37:23 <Fanael> ^H
04:37:54 <scree> Saizan: might the compiler not specialize it out?
04:37:56 <aavogt> maurer_: the value   Num a => [a]  is like a function
04:37:59 <Fanael> C++ nicer than anything else (well, maybe except Malbolge)? It's not possible.
04:38:04 <hoknamahn> hey guys, so this can be a good solution for my problem i.e. type restricted only to a certain subset of types http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25526#a25526
04:38:06 <hoknamahn> ?
04:38:38 <aavogt> scree: wouldn't inlining be more likely? ... this is all quite difficult to predict
04:39:00 <maurer_> aavogt: Oh. I always just assumed the compiler picked a type at compile time
04:39:15 <scree> I was about to suggest manual inlining as a solution :)
04:39:36 <Peaker> maurer_, it could, in theory, until you introduce rank-n or existential types...
04:39:56 <Peaker> or parametric recursion, I think
04:39:59 <aavogt> ghc doesn't though
04:40:11 <kmc> hoknamahn, why is each list of attribs restricted to one type?
04:40:19 <kmc> in that case you might want a GADT instead
04:40:24 <NIXDAEMON-COOL> boss like make work of you Saizan thank you inside today
04:40:43 <kmc> data Attr a where { AInt :: Int -> Attr Int; ADouble :: Double -> Attr Double }
04:40:44 <Peaker> Why didn't Haskell 2010 just accept all of the non-crazy syntactic extensions (e.g: Type Operators)?
04:40:50 <aavogt> hoknamahn: for empty classes (and instances) you can leave off the where
04:40:56 <scree> was that thanks or an employment offer?
04:41:04 <illissius> actually, that's probably not a direct comparison -- I think what's really the case is that the the Qt libraries are much nicer than the C# or Java ones, but looking at just the language sans libraries C# and Java are better
04:41:07 <hoknamahn> kmc, I'll check GADT
04:41:18 <hoknamahn> aavogt, good to know thanks
04:41:18 <Peaker> Why did Haskell not have type operators in the first place?
04:41:38 <kmc> why did haskell not have hierarchical modules in the first place?
04:41:46 <aavogt> it's easier to start simple
04:41:57 <aavogt> especially when the differences are just syntax
04:42:23 <Peaker> Hierarchial modules were maybe unknown to the designers.. Though they knew operators, and types, so why not type operators? :)
04:42:38 <Peaker> anyway, why not accept it and any other trivial syntax extension in 2011? :)
04:43:03 <kmc> still adds more things to learn
04:43:09 <kmc> restricts future uses of syntax
04:43:13 <aavogt> how does membership in the standard affect how you get to use it?
04:43:33 <kmc> Haskell's syntax is reasonably simple and clean, and i'd rather not bless a bunch of extensions when there might be a simpler framework
04:43:47 <aavogt> oh no, it's already quite redundant
04:43:55 <kmc> they might have resolved the numerical operator problem with syntactic trickery and then we wouldn't have typeclasses ;)
04:43:59 <aavogt> there are way too many ways to say the same thing
04:44:29 <aavogt> as in, why do we have  where, pattern guards, ~ @ in patterns...
04:45:09 <scree> isn't ~ necessary?
04:45:10 <aavogt> if-then-else should go too
04:45:20 <aavogt> scree: not at all
04:45:37 <kmc> yes, if-then-else should go
04:45:49 <aristid> why?
04:46:09 <aavogt> because case is just as expressive and short
04:46:33 <aavogt> hmm, though I'd keep pattern guards in that case...
04:46:36 <kmc> it's special case syntax for something trivial that could be an ordinary function
04:46:48 <kmc> also, showing beginners that it is an ordinary function would be a good early demonstration of lazy eval
04:47:01 <kmc> if anything it should be replaced with general Agda-style mixfix
04:47:02 <Peaker> kmc, I agree with your points, but most of the syntax world for types is mirrored in values, and vice versa.. And the lack of type operators shines out
04:47:18 <kmc> then we can name the replacement for if/then/else as if_then_else_
04:47:34 <aavogt> kmc: it isn't clear how to deal with nested mixfix stuff
04:47:37 <Peaker> Without type operators, the TypeCompose library is much more confusing
04:48:01 <Peaker> kmc, how do you partially apply if_then_else_ ?
04:48:15 <scree> so, to write: f b ~(x,y) = if' b (x+y) 0
04:48:20 <Peaker> Also, what is the type of "if" in a DT language?
04:48:32 <kmc> Peaker, prefix
04:48:38 <aristid> :t if'
04:48:39 <lambdabot> Not in scope: `if''
04:48:48 <aristid> @hoogle if'
04:48:48 <lambdabot> No results found
04:48:51 <aristid> oO
04:48:53 <Peaker> "Bool -> a -> a -> a" wouldn't be good enough for a DT language
04:49:02 <aristid> Peaker: what's DT?
04:49:02 <scree> we need: f False _ = 0; f True (a,b) = a+b
04:49:07 <Peaker> aristid, Dependent types
04:49:16 <aristid> Peaker: is haskell such a language?
04:49:19 <Peaker> aristid, nope
04:49:23 <kmc> (T : Set) -> (v : Bool) -> T v -> T v -> T v
04:49:25 <kmc> i think
04:49:32 <Peaker> kmc, oh, cool
04:49:36 <aavogt> > let f b vs = let (a,b) = vs in if b then a+b else 0 in f False undefined
04:49:37 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
04:49:37 <lambdabot>    arising from a use of `GHC.N...
04:49:42 <aristid> Peaker: wait, is "dependent" the same as in c++ templates there? :D
04:49:43 <Peaker> kmc, (T : Bool -> Set) though
04:49:51 <kmc> err yeah
04:49:56 <hoknamahn> are we limited to GHC if we using GADTs?
04:50:00 <kmc> it's hard to say
04:50:12 <kmc> i mean, in theory the type of the "else" branch could depend on the value of the "then" branch
04:50:15 <kmc> but is that at all reasonable?
04:50:22 <aavogt> > let f b vs = let (x,y) = vs in if b then x+y else 0 in f False undefined
04:50:23 <lambdabot>   0
04:50:28 <aavogt> > let f b vs = let (x,y) = vs in if b then x+y else 0 in f True undefined
04:50:29 <lambdabot>   *Exception: Prelude.undefined
04:50:34 <aavogt> scree: ^^
04:50:38 <Peaker> aristid, No, dependent types means that values, and not just their types, are allowed to be used as type parameters. Even a value of a function argument can be used to parametrize the result type
04:50:51 <scree> aavogt: aha
04:51:15 <scree> aavogt: so it's just a syntactical replacement?
04:51:15 <aristid> Peaker: ah, i think that
04:51:20 <Peaker> kmc, I don't know -- are types that depend on values allowed to depend on any value, or just according to data-flow?  e.g: (a : A) => (b : B)   is "A" allows to depend on "b" ?
04:51:20 <aavogt> scree: yes
04:51:21 <aristid> is not really necessary
04:51:25 <scree> aavogt: never realized
04:51:29 <kmc> Peaker, no
04:51:39 <Peaker> aristid, It's not necessary -- until you want to prove very interesting properties of your program with types
04:51:41 <kmc> aristid, for example with dependent types you can write types like "lists of at most 5 elements"
04:51:48 <kmc> the type "lists of at most 5 elements" depends on the value "5"
04:51:56 <Saizan> maurer_: it does pick the type at compile time
04:51:56 <aavogt> scree: pattern matches are strict most places, but lazy in lets
04:52:03 <aristid> kmc: well you can also do this right now, although the syntax is terrible
04:52:04 <Peaker> kmc, this particular example can be encoded in Haskell to
04:52:10 <aavogt> > (\(a,b) -> 0) undefined
04:52:11 <lambdabot>   *Exception: Prelude.undefined
04:52:18 <kmc> only by inventing new numbers at type level
04:52:28 <maurer_> Saizan: Then why does it do something different than specifying the type non-polymorphically?
04:52:28 <kmc> aristid, another way to look at it is that types are first-class values.  you can have functions that take types and return types, yet you still have static checking
04:52:30 <scree> aavogt: right, I would have understood each individually, just never made the connection
04:52:33 <Peaker> kmc, Sure, but DT let you do things that you can't do at all in Haskell
04:52:45 <scree> aavogt: probably because I've never used ~ in anger
04:52:55 <kmc> Peaker, what's a good example there?
04:53:07 <Saizan> maurer_: because with my code the type is picked at the call site rather than at the definition
04:53:15 <maurer_> Saizan: OK
04:53:17 <aristid> kmc: having type-level numbers be different from value-level numbers seems like a reasonable restriction?
04:53:20 <kmc> Haskell has enough hacks that usually you *can* do something even if it would be much nicer in DT
04:53:21 <Peaker> Maybe a "sort" that is proven to: A) Terminate B) Return a sorted list C) Of the same length  D) Can it be proven to be a permutation?
04:53:38 <kmc> Peaker, that's pretty involved, but yes
04:53:39 <Peaker> aristid, It is a serious impediment to code re-use, but that's not the main disadvantage of Haskell over DT's
04:53:42 <aristid> kmc: i'd want a more convenient syntax for type-level numbers tho
04:53:54 <kmc> aristid, a systematic way to reflect data to type level would be nice
04:54:01 <kmc> such as She's data-kinds
04:54:15 <Peaker> aristid, It's nice to have a program where any arbitrary property you have in mind can be proven true by the types
04:54:39 <aristid> Peaker: i have the suspicion that a true DT would be terribly hard to implement efficiently.
04:54:49 <kmc> aristid, how much do you know about it?
04:54:50 <Peaker> aristid, DT actually makes more efficiency possible
04:55:04 <aristid> kmc: not much, just a few heuristics.
04:55:06 <kmc> aristid, www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
04:55:09 <Peaker> aristid, e.g: The type of zip takes 2 equal-length lists, so it doesn't have any runtime checks for premature list end
04:55:21 <kmc> aristid, DT programs often have a lot of compile-time computation, as it will essentially check your proofs
04:55:52 <kmc> aristid, http://www.cis.upenn.edu/~bcpierce/sf/ is a good introduction to another dependently typed language (Coq) and the proof system built around it
04:56:02 <DigitalKiwi> haskell uses recursion a lot, but supposedly all recursive algorithms can be changed to iterative? so i'm wondering if that is still always possible in haskell or if there are some limitations that make those algorithms not work >.>
04:56:26 <kmc> aristid, and http://people.cs.uu.nl/andres/LambdaPi/index.html is an implementation for a toy dependently-typed language in Haskell
04:56:29 <aristid> kmc: my reasoning was basically "there's probably a reason why haskell doesn't allow full-fledged DT" :)
04:56:46 <kmc> aristid, there are reasons; efficiency is not a big one i think
04:57:09 <dolio> There are dependently typed assembly languages where you can prove that you don't access out-of-bounds memory without doing any runtime checks in your loop.
04:58:02 <aristid> kmc: i agree that DT is a beautiful thing to have. compile-time programming in general should be done more.
04:58:35 <aavogt> DigitalKiwi: foldr isn't tail-recursive
04:59:15 <aavogt> so the optimization you bring up cannot be applied to it
04:59:23 <Saizan> DigitalKiwi: laziness makes non-iterative recursion useful and interesting
04:59:27 <kmc> DigitalKiwi, what do you mean by "iterative"?
04:59:41 <Saizan> well, it's useful anyway..
04:59:42 <sepp2k> DigitalKiwi: It is not clear to me what an iterative algorithm in haskell would look like. And yes, every recursion can be turned into a while-loop with a stack (in languages that have while-loops), but I see no reason that should be preferable.
04:59:50 <aristid> i guess iterative recursion = tail recursion?
04:59:51 <Saizan> more useful :)
05:00:02 <sepp2k> (And every loop can also be turned into recursion)
05:00:25 <aristid> sepp2k: in imperative languages, an explicit stack is often preferred because its size can be controlled
05:00:59 <DigitalKiwi> kmc: what they said, while loops are one way of doing it
05:01:19 <sepp2k> DigitalKiwi: Except haskell doesn't have while-loops
05:01:24 <DigitalKiwi> yeah
05:01:29 <sepp2k> aristid: Ok, good point.
05:01:30 <kmc> you can write one easily
05:01:33 <DigitalKiwi> which would make it a lot harder ;D
05:01:33 <kmc> but you'd use recursion to do so ;)
05:01:45 <DigitalKiwi> heh
05:01:46 <kmc> i think the question about tail recursion as a special case of recursion
05:01:48 <kmc> is more interesting
05:02:19 <kmc> and this is quite different for lazy vs. strict eval
05:02:25 <DigitalKiwi> and usually a good reason not to use recursion is when your stack is limited and your recursion is very 'deep'
05:02:26 <kmc> (lazy vs. eager?)
05:02:46 <kmc> DigitalKiwi, but you have to store that data somehow.  making the stack explicit doesn't make it less deep
05:03:00 <DigitalKiwi> but therein lies the kicker
05:03:03 <kmc> maybe you are cleverer than the compiler in what needs to be stored
05:03:32 <DigitalKiwi> sometimes you have to or end up using a stack, but the stack is only limited by memory space, because you use linked list :)
05:03:46 <DigitalKiwi> instead of the provided stack
05:03:53 <Jafet> > let a _ n = succ n; a m 0 = a (pred m) 1; a m n = a (pred m) (a m (pred n)); in a 4 1
05:03:54 <Saizan> DigitalKiwi: you don't need explicit loops to do that
05:03:54 <lambdabot>   2
05:04:02 <kmc> DigitalKiwi, you can do this in Haskell too
05:04:03 <aristid> DigitalKiwi: you mean like when the C stack is only 4096 bytes or so?
05:04:06 <kmc> and it's pretty much done for you
05:04:42 <DigitalKiwi> aristid: dunno
05:04:43 <kmc> the "actual" stack in GHC is only as deep as the deepest chain of pattern matching scrutinees iirc
05:04:55 <Jafet> > let a _ n = succ n; a m 0 = a (pred m) 1; a m n = a (pred m) (a m (pred n)); in [a m n | m <- [1..3], n <- [1..3]]
05:04:56 <lambdabot>   [2,3,4,2,3,4,2,3,4]
05:04:59 <kmc> in GHC-produced code*
05:05:15 <Jafet> I can't believe I implemented a buggy ackermann's function
05:06:50 <ClaudiusMaximus> > let a _ n = succ n in [a m n | m <- [1..3], n <- [1..3]]
05:06:51 <lambdabot>   [2,3,4,2,3,4,2,3,4]
05:08:28 <Jafet> > a m n = a (pred m) (a m (pred n)); let a 0 n = succ n; a m 0 = a (pred m) 1; in [a m n | m <- [1..3], n <- [1..3]]
05:08:29 <lambdabot>   <no location info>: parse error on input `='
05:08:35 <Jafet> > let a m n = a (pred m) (a m (pred n)); a 0 n = succ n; a m 0 = a (pred m) 1; in [a m n | m <- [1..3], n <- [1..3]]
05:08:39 <lambdabot>   mueval-core: Time limit exceeded
05:08:50 <Jafet> > let a 0 n = succ n; a m 0 = a (pred m) 1; a m n = a (pred m) (a m (pred n)); in [a m n | m <- [1..3], n <- [1..3]]
05:08:52 <lambdabot>   [3,4,5,5,7,9,13,29,61]
05:09:02 <DigitalKiwi> http://xkcd.com/207/ Jafet
05:11:43 * hackagebot rad 0.1.2 - Reverse Automatic Differentiation.  http://hackage.haskell.org/package/rad-0.1.2 (EdwardKmett)
05:12:06 <edwardk> (bug in (**))
05:14:45 <aristid> :t par
05:14:47 <lambdabot> forall a b. a -> b -> b
05:15:09 <aristid> @src par
05:15:10 <lambdabot> Source not found. My pet ferret can type better than you!
05:15:10 <Jafet> :t seq
05:15:11 <lambdabot> forall a t. a -> t -> t
05:15:13 <Saizan> edwardk: i see you have inside information about base-5 :)
05:15:30 <edwardk> ?
05:16:11 <aristid> @hoogle par
05:16:12 <lambdabot> Control.Parallel par :: a -> b -> b
05:16:12 <lambdabot> Text.Html paragraph :: Html -> Html
05:16:12 <lambdabot> Text.XHtml.Frameset paragraph :: Html -> Html
05:16:26 <aristid> too bad @hoogle doesn't link to things
05:16:28 <Saizan> edwardk: "base >= 4 && < 6" <- that implies you know it'll work with base-5
05:16:38 <edwardk> ah
05:16:52 <edwardk> hackage wants a cap on base, so i gave it one ;)
05:17:05 <Baughn> @. pl undo do f <- fa; v <- va; return (f v)
05:17:05 <lambdabot> (va >>=) . (return .) =<< fa
05:17:41 <Peaker> Saizan, does cabal allow you to do that?
05:17:49 <opqdonut> Baughn: liftM ($)
05:17:55 <Saizan> Peaker: to lie? unfortunately yes
05:18:04 <opqdonut> :t \f v -> do f <- fa; v <- va; return (f v)
05:18:05 <lambdabot> Not in scope: `fa'
05:18:05 <lambdabot> Not in scope: `va'
05:18:08 <opqdonut> gah
05:18:14 <opqdonut> :t \fa va -> do f <- fa; v <- va; return (f v)
05:18:15 <lambdabot> forall (m :: * -> *) b t. (Monad m) => m (t -> b) -> m t -> m b
05:18:20 <opqdonut> :t liftM ($)
05:18:20 <edwardk> Saizan: that said, i require very very little from base, so its probably a reasonable guess ;)
05:18:21 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> b)
05:18:29 <Peaker> Saizan, cabal really needs to get rid of version dependencies, and use import/export signatures instead
05:18:32 <opqdonut> :t liftM2 ($)
05:18:33 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
05:18:38 <opqdonut> Baughn: ^ see there
05:18:51 <Baughn> Mm.
05:19:06 <opqdonut> also,
05:19:09 <Peaker> Saizan, When you "cabal sdist" it could convert all unqualified open imports and lacking export lists to fully-specified lists that are uploaded alongside your package so it can generate import/export signatures
05:19:12 <opqdonut> :t (<*>)
05:19:13 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:19:19 <opqdonut> :t ap
05:19:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:19:25 <opqdonut> known by a couple of other names :)
05:19:29 <Baughn> opqdonut: I was trying to instance Alternative for Parsec/GenParser.. why doesn't it have one of those, anyway?
05:19:31 <Saizan> Peaker: i think we need both, the author might want to restrict the compatible versions for semantic reasons that can't be checked automatically
05:19:49 <Baughn> opqdonut: ..and yes, of course, now that you mention it. <*> = ap. ^^;
05:19:55 <opqdonut> :)
05:20:28 <Peaker> Saizan, I think if the semantics of a function or type change, then they should be renamed, for a simpler/nicer resolution
05:20:39 <Baughn> Parsec doesn't instance State either..
05:20:44 <Baughn> Geez.
05:21:45 <Peaker> Saizan, if there's a large new library, its name can be appended a version number.. I think it's reasonable to have Parsec3 as a module name
05:21:45 * soupdragon wonders if there is anyone in #haskell who doesn't use the word 'is'
05:22:59 <edwardk> soupdragon: currently or over their lifetime?
05:23:11 <Saizan> Peaker: preprocessors and TH macros with system-dependent results also get in the way of collecting the exposed interface
05:23:56 <Peaker> Saizan, Yeah, maybe they should be forced to build signature files manually for the various configurations, and split those into different packages
05:27:02 <aavogt> @hoogle is
05:27:02 <lambdabot> System.FilePath.Posix isAbsolute :: FilePath -> Bool
05:27:02 <lambdabot> System.FilePath.Windows isAbsolute :: FilePath -> Bool
05:27:02 <lambdabot> Network.URI isAbsoluteURI :: String -> Bool
05:27:21 <aavogt> soupdragon: I think that word happens to be quite uncommon :)
05:29:44 <Saizan> Peaker: if some tool tackling the simple cases that calculates version constraints were written (assuming it can cover a large enough set of packages) and proved itself useful in practice, it could gain the mindshare to require some annotations in the more complicated ones
05:30:08 <Saizan> Peaker: versions constraints would just be a way to summarize the information
05:30:42 <Peaker> Saizan, interesting.. start as an add-on, you mean?
05:30:53 <Saizan> Peaker: yeah
05:31:07 <Peaker> though, to make it really useful, retro-active version specification would need to be supported
05:31:22 <Peaker> Maybe the tool could rewrite .cabal files at first
05:31:33 <Peaker> but it would make "cabal install" not "just work"
05:32:40 <Saizan> you'd probably need a mirror of hackage were you've revisions of the packages with patched .cabal files, or we could get those in hackage directly if it's convincing enough :)
05:33:08 <Peaker> Saizan, aren't .cabal's supposed to be immutable on hackage?
05:33:13 <Peaker> (New .cabal = new version)
05:35:10 <Saizan> Peaker: yeah, you'd need a way to say "i'll make this new version and it should shadow this other one because it's a fix"
05:35:19 <Saizan> in the mirror you could just remove the old one.
05:35:49 <Peaker> Mirroring hackage is not free :)
05:37:55 <Saizan> another option is to crack cabal-install open and add another solver that uses the additional information, we'd have to improve the dependency solver anyway
05:38:36 <Saizan> so many options :)
05:39:48 <Saizan> (even simple build reports could be a valuable source of information)
05:41:31 <Olathe> Are there any array types that store integers modulo an integer with the minimal space necessary ?
05:42:48 <Axman6> o.O
05:42:55 <Jafet> A packed bit array?
05:43:10 <Saizan> only if the other integer is 2, 32 or 64
05:43:12 <Axman6> so logBase 2 m bits per element?
05:43:32 <Jafet> You can also store them completely packed a la FRACTRAN, but that sounds even sillier than this silly
05:43:35 <Olathe> Axman6: Yeah, or logBase 8 m bytes or whatever
05:44:04 <ivanm> Axman6!
05:44:12 <Axman6> ivanm?
05:44:20 <ivanm> it's you!
05:45:29 <Axman6> i think it is, yes
05:45:43 <ivanm> *phew*
05:45:56 <ivanm> there was something I wanted to ask you earlier when you weren't online... but now I forget :s
05:46:29 <Axman6> you showed me that MS thingo that's in manning clark this week, that wasn't it was it?
05:46:51 <medfly> what's a convenient way to tell if something from Floating is a whole number
05:46:58 <ivanm> Axman6: nah, something else
05:47:06 <ivanm> and the only interesting thing about that is free food >_>
05:47:10 <Olathe> medfly: properFraction or something
05:47:24 <medfly> thanks
05:47:46 <Olathe> > let wholeNumber = (==0) . snd . properFraction in map wholeNumber [pi, 3]
05:47:48 <lambdabot>   [False,True]
05:48:05 <medfly> do I need to test it's less than a really small number or just test it's equal to 0?
05:48:15 <medfly> :/
05:48:29 <thefailbot> how do you split a string into a list of strings?
05:48:35 <Olathe> medfly: Hmm, good question.
05:48:39 <medfly> :t splitAt
05:48:39 <lambdabot> forall a. Int -> [a] -> ([a], [a])
05:48:45 <Axman6> thefailbot: a thousand different ways
05:48:54 <Olathe> > words "zomg hi how are you"
05:48:55 <lambdabot>   ["zomg","hi","how","are","you"]
05:49:05 <pastorn>  @hoogle [a] -> [[a]]
05:49:12 <Axman6> > lines "this is line 1\nand line 2"
05:49:12 <pastorn> @hoogle [a] -> [[a]]
05:49:13 <lambdabot> Data.List inits :: [a] -> [[a]]
05:49:13 <lambdabot> Data.List permutations :: [a] -> [[a]]
05:49:13 <lambdabot> Data.List subsequences :: [a] -> [[a]]
05:49:13 <lambdabot>   ["this is line 1","and line 2"]
05:49:18 <Olathe> medfly: Maybe...
05:49:30 <Axman6> > subsequences "hello"
05:49:31 <lambdabot>   ["","h","e","he","l","hl","el","hel","l","hl","el","hel","ll","hll","ell","...
05:49:41 <aavogt> @hoogle subsequences
05:49:42 <lambdabot> Data.List subsequences :: [a] -> [[a]]
05:49:43 <medfly> k, thx
05:49:48 <aavogt> is that one new?
05:49:53 <medfly> > properFraction -1.4
05:49:54 <lambdabot>   No instance for (GHC.Real.Fractional (a -> (b, a)))
05:49:54 <lambdabot>    arising from a use o...
05:50:47 <Olathe> > let wholeNumber x = let (_, r) = properFraction x in r == 0 or x/r > 1e7 in map wholeNumber [pi, 3.000000000001]
05:50:48 <lambdabot>   Precedence parsing error
05:50:48 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
05:50:54 <Olathe> > let wholeNumber x = let (_, r) = properFraction x in r == 0 || x/r > 1e7 in map wholeNumber [pi, 3.000000000001]
05:50:55 <lambdabot>   [False,True]
05:52:17 <edwardk> woot, test suite more or less validates my RAD implementation against pealmutter and siskind's FAD implementation. we only disagree on a few minor things (0**0) and (recip 0) and because i generate the jacobian in a different order i get different precision on a couple of test cases
05:54:08 <roconnor> what is RAD and FAD?
05:54:26 <edwardk> reverse mode automatic differentiation vs forward mode
05:55:21 <edwardk> forward ad calculates the derivatives as you go. reverse ad works backwards from the answer, which turns out to be better for getting things like gradients, etc.
05:55:44 <mauke> .
05:56:11 <soupdragon> > sqrt(sqrt(2))
05:56:12 <lambdabot>   1.189207115002721
05:56:15 <soupdragon> oh this sucms
05:56:15 <edwardk> http://hackage.haskell.org/package/rad vs http://hackage.haskell.org/package/fad
05:56:29 <soupdragon> I cant take square roots of the form  (A+B*sqrt(C))/D
05:56:35 <soupdragon> they don' tend up in that form again
05:57:02 <roconnor> soupdragon: huh?
05:57:21 <soupdragon> this form of number; (A+B*sqrt(C))/D, is a field
05:57:27 <soupdragon> but I can't take square roots of it
05:57:40 <soupdragon> beacuse e.g. sqrt(sqrt(2)) is not expressible in the form  (A+B*sqrt(C))/D
05:57:53 <soupdragon> h A,B,C,D integers
05:57:53 <soupdragon> o
05:57:56 <roconnor> this is not surprising
05:58:06 <soupdragon> yeah but it ruins my idea
05:58:22 <roconnor> are you trying to trisect angles? :D
05:58:34 --- mode: ChanServ set +o mauke
05:58:34 --- mode: mauke set -bbbb rplqr!*@* ylhrwbhl!*@* orgullocachanill!*@* *!*@cpe-75-186-150-165.woh.res.rr.com
05:58:35 <soupdragon> hehe
05:58:48 <Axman6> mauke?
05:59:15 <roconnor> mauke is letting the spammer's in!  he is one of them! traitor!!
05:59:19 <roconnor> :D
05:59:40 <mauke> Axman6?
06:00:11 <Axman6> oh, those were unbans. i was wondering why you were banning so many people :)
06:00:14 <soupdragon> i guess I have a way to generate some vauegly interesting unsolvable diophantines now
06:00:21 <soupdragon> since you can't square roots like that
06:00:34 --- mode: mauke set -o mauke
06:00:37 <soupdragon> I get 3 variable 2 equation systems whic no solution
06:01:18 <roconnor> x^2 + 1 = 0 has no solutions
06:01:33 <soupdragon> i
06:01:39 <roconnor> that isn't an integer
06:01:44 <soupdragon> you're not an integer
06:01:46 <soupdragon> ;D
06:01:57 <Fanael> Get real.
06:02:00 <roconnor> diophantine equations is about integer solutions, right?
06:02:10 <soupdragon> if you have equations  D1=0, D2=0  you can AND them  D1^2 + D2^2 = 0
06:02:20 <soupdragon> and you can OR them D1 * D2 = 0
06:02:38 <soupdragon> hm what about xor
06:02:40 <alar> is there a possibility to import library and negate instances defined in it?
06:03:19 <roconnor> soupdragon: can you xor recursively enumarable sets?
06:03:25 <mauke> alar: no
06:04:06 <alar> mauke: so i have to make my own clone of the library, with changed instances?
06:04:09 <Fanael> Why not?
06:04:10 <soupdragon> can 2(a^2+b)=c^2 have any integer solutions?
06:04:12 <roconnor> alar: instances are the fungus of haskell
06:04:31 <roconnor> soupdragon: a = 0 b = 2 c = 2
06:04:40 <alar> roconnor: how tasty?
06:05:15 <Olathe> Why is Array not a typeclass ?
06:05:30 <xerox> ?docs Data.Array
06:05:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
06:06:45 <xerox> dunno
06:07:04 <soupdragon> roconnor,
06:07:06 <ivanm> isn't it?
06:07:11 <soupdragon> > sqrt(3+2*sqrt(2))
06:07:12 <lambdabot>   2.414213562373095
06:07:15 <Olathe> Ahh, IArray is a class
06:07:16 <soupdragon> > 1 + sqrt(2)
06:07:17 <lambdabot>   2.414213562373095
06:07:37 <ivanm> Olathe: see Data.Array.IArray
06:07:38 <ivanm> yeah
06:07:49 <ivanm> Olathe: Array is a really basic type, IArray expands it slightly
06:08:13 <Olathe> Ahh, OK. Thanks :)
06:08:53 <mux> bah, the default vim syntax file for haskell gets confused with multi-line string literals
06:13:09 <Baughn> @hoogle Handle -> IO Fd
06:13:09 <lambdabot> Network.BufferType buf_hGetContents :: BufferOp a -> Handle -> IO a
06:13:09 <lambdabot> Network.BufferType buf_hGetLine :: BufferOp a -> Handle -> IO a
06:13:09 <lambdabot> Network.BufferType buf_hGet :: BufferOp a -> Handle -> Int -> IO a
06:13:15 <Baughn> @hoogle Handle -> Fd
06:13:15 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:13:15 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:13:15 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
06:14:15 <aavogt> @hoogle Fd -> Handle
06:14:16 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:14:16 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
06:14:16 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:14:29 <ivanm> what would be better: "Set.unions . reverse", "foldr Set.union Set.empty" or "foldl' (flip Set.union) empty" ?
06:14:42 <ivanm> I'm wanting right-biased sets
06:15:16 <ivanm> *right-biased set unions
06:16:01 <Fanael> Uhm.
06:16:13 <Fanael> I don't know what I did.
06:16:26 <Fanael> Are there any GHC switch called "-O3"?
06:16:59 <ivanm> Fanael: no
06:17:08 <ivanm> (if there is, then it just defaults to -O2)
06:17:43 <Axman6> i have a feeling that -O3 has been somewhat left behind, and optimises less than -O2, though i'm not sure where i got this idea from
06:18:04 <ivanm> oh, wait there is
06:18:17 <ivanm> usually -O2 is better, as -O2 is sometimes too agressive and might be worse than -O2
06:18:31 <ivanm> but most parallel alg stuff like vector seem to use -O3 *shrug*
06:19:25 <Fanael> Wow.
06:19:33 <aavogt> ivanm: which of those -O2 should be -O1?
06:19:47 <ivanm> oh, the second should be -O3
06:19:54 <mauke> ivanm: since when is there a -O3?
06:20:02 <Axman6> always
06:20:05 <mauke> because it's not in 6.8 or 6.10
06:20:12 <Axman6> aye you sure?
06:20:14 <mauke> yes
06:20:18 <Axman6> i'm 95% sure it was there
06:20:24 <ivanm> humph.... maybe I mis-remembered
06:20:26 <aavogt> it's not documented...
06:20:30 <mauke> in 6.6 or 6.8 -O3 was worse than -O1
06:20:34 <mauke> it was never meant to work
06:20:43 <Axman6> -On    Set optimisation level n
06:20:49 <mauke> yes
06:20:56 <mauke> where n в€€ {0,1,2}
06:21:04 <ivanm> I thought vector and repa used -O3 ... >_>
06:21:19 <mauke> ivanm: not -optc -O3?
06:21:20 <ivanm> are there any other parallel libraries from dph that I might have seen that in?
06:21:23 <Fanael> Haskell (well, I dunno it could be called Haskell anymore, since it written using raw GHC primops) compiled using GHC beats similar C++ code compiled using Intels' compiler. Very impressive.
06:21:38 <Fanael> it's*
06:21:44 <Fanael> Intel's*
06:22:06 <aavogt> are both codes heavily optimized?
06:22:15 <Fanael> Yep.
06:22:22 <aavogt> or has lots of effort gone only into making the haskell faster?
06:22:24 <thefailbot>  
06:22:29 <Axman6> interesting. care to share?
06:22:55 <ivanm> anyone managed to get hmatrix 0.9.3.0 to build?
06:23:02 <ivanm> with vector support, that is
06:23:05 <Axman6> i have in the past
06:23:11 <Axman6> not with vector
06:23:12 <ivanm> mauke: yeah, that's probably what I saw :s
06:23:20 * hackagebot SimpleAES 0.4.2 - Fast AES encryption/decryption for bytestrings  http://hackage.haskell.org/package/SimpleAES-0.4.2 (DavidHimmelstrup)
06:23:40 <ivanm> hmmm, even with vector support disabled it fails :s
06:24:41 <Axman6> do you have the right libraries installed?
06:24:51 <ivanm> I have some broken packages but I didn't think any of them were deps of hmatrix
06:25:31 <ivanm> Axman6: well, apparently it only needs storable-complex (that doesn't come with GHC)
06:25:41 <ivanm> and it looks like some .hi file not being found causing the error >_>
06:25:59 <Saizan> maybe you deleted it.
06:26:17 <Axman6> sure it doesn't need something like LAPACK or that gnu math lib thing?
06:26:25 <ivanm> Axman6: oh, yeah, they're installed
06:26:38 * ivanm is trying to upgrade from 0.8.3.0
06:27:53 <Peaker> I dislike saying optimizations are "aggressive".. maybe "more extreme towards runtime efficiency at the expense of memory efficiency" or such
06:28:12 <mreh> ghc is telling me I have a package hidden, but it isn't
06:28:33 <Twey> Peaker: I like вЂzealousвЂ™ ;)
06:28:41 <ivanm> or "so eager to try and be helpful that it trips over the rug and when trying to stop its fall it brings down the buffet containing the very expensive hand-made and painted bone china dinnerware set"
06:28:51 <ivanm> mreh: could be because it's broken
06:28:59 <mreh> ivanm, hmm
06:29:02 <Twey> Peaker: Aggressiveness is to do with behaviour-changing, I believeвЂ¦
06:29:07 <ivanm> mreh: does "ghc-pkg list" have it in any brackets?
06:29:26 <mreh> ivanm: no, this is what I was referring to, it's weird
06:29:32 <Fanael> Axman6: Haskell code: http://wklej.org/hash/edbbdcd04a0/ C++ code: http://wklej.org/hash/0862cf56d52/ and brainfuck used to benchmark: http://wklej.org/hash/a8dd9b00295/
06:30:33 <ivanm> mreh: with the same user?
06:30:38 <ivanm> "ghc-pkg check" doesn't bitch?
06:31:31 <Axman6> Fanael: isn't State# RealWorld == IO ish?
06:31:52 <Olathe> Fanael: Wow
06:33:04 <mreh> ivanm: yeah
06:33:35 <mreh> ivanm: not about what I'm using
06:34:13 <Axman6> Fanael: also, wow, that's gross :)
06:34:50 <Olathe> Fanael: Did you make that ?
06:35:06 <ivanm> mreh: what _does_ it bitch about? any deps of what you're using?
06:35:18 <mreh> ivanm: no, midi, that's all
06:35:41 <Fanael> Yep, I did that ;)
06:36:32 <Axman6> does the C++ do the same work? ie, optimisation etc?
06:37:06 <Fanael> Yes, C++ does the same work.
06:37:07 <Axman6> also.. __fastcall, what's that do? (apart from, i assume, make the call faster. i'd like to know how and why)
06:37:15 <ivanm> Axman6: reminder email r.e. aushack sent
06:37:28 <Axman6> ah, good
06:37:33 <ivanm> well, I would if my mail client stopped bitching...
06:37:41 <Axman6> heh
06:37:44 <Fanael> __fastcall tells compiler to put arguments into registers instead of pushing them onto stack.
06:39:09 <ivanm> here's my hmatrix error: setup: Error: Could not find module: Data.Packed with any suffix: ["hi"] in the search path: ["dist/build"]
06:39:32 <Axman6> Fanael: ah, i see, how nice
06:39:48 <Peaker> On x86/64 the default calling convention does that
06:40:12 <Peaker> at least the first 6 args go into registers
06:40:13 <Twey> Does that mean i386 or x86_64?
06:40:22 <Peaker> x86_64
06:40:24 <Twey> What if they are too big to fit?
06:40:35 <Fanael> Then they're pushed onto stack.
06:40:40 <Twey> Ah, fair enough.
06:40:50 <Peaker> I think only structures would be C values too big to fit in a register, and I am not sure what the calling convention(ABI) says about them
06:40:59 <Twey> Or arrays
06:41:07 <Peaker> C doesn't have values of array type
06:41:21 <Twey> Oh, they're just pointers, right
06:41:26 <Peaker> When you take the value of an array in C, you get a pointer to its first element
06:41:53 <Peaker> Well, arrays exist in C, as types of real objects allocated somewhere..
06:42:04 <Peaker> but when you take their value...
06:43:28 <Olathe> Fanael: I think loopOptimize x@(Loop [Add (-1#), Move n1, Add k, Move n2]) changing it to [..., Set 0#] is bad because if the current contents of the cell is n, it'll only execute the loop once rather than n times.
06:43:35 <Peaker> Maybe the most clarifying example of this confusing behavior is:  int x[2][3]; (Array of 2 arrays of 3 ints).   The type of "x" is int[2][3].  The type of the *value* of "x" is int (*)[3]   (ptr to first element, ptr to array of 3 ints)
06:44:07 <Peaker> note:  int (*)[3]  means ptr-to-array-of-3-int,  and not:  int *[3]  which means:  array-of-3-ptr-to-int
06:44:16 <Peaker> C syntax is so horrible :)
06:44:33 <Axman6> yup
06:44:37 <Fanael> Olathe: it replaces that loop with FarAdd followed by Set, there's no loop anymore.
06:44:49 <Axman6> though, rewaeding whenever you make something work in it :D
06:45:17 <Peaker> Axman6, I like it when I manage to create generic/encapsulated/modular code in C.. as it is indeed more of a challenge
06:45:29 <Axman6> aye
06:45:39 <Olathe> Fanael: Oh, I know, but if you have +++++++[that loop], the loop should go seven times. But the optimization will replace the loop and it will only happen one time, instead of seven.
06:46:37 <Olathe> Maybe I'm wrong. Let me test it with Hello, World, which uses that.
06:46:53 <ivanm> Axman6: OK, _now_ I think its sent
06:47:06 <Axman6> am i on the list?
06:47:11 <ivanm> yes
06:47:18 <Axman6> ok, checking now
06:47:23 <Axman6> yes, it sent
06:49:14 <ivanm> Axman6: worked out my problem with hmatrix: I wasn't telling it to actually build just skip straight to installing :s
06:49:28 <Axman6> :\
06:51:22 <soupdragon> > 10^10
06:51:23 <lambdabot>   10000000000
06:52:27 <Peaker> > 10^10^10
06:52:32 <lambdabot>  Terminated
06:53:00 <Twey> > 1e10 ^ 10
06:53:01 <lambdabot>   1.0e100
06:53:06 <Twey> > 1e10 ^ 100
06:53:06 <soupdragon> :t even
06:53:07 <lambdabot> forall a. (Integral a) => a -> Bool
06:53:07 <lambdabot>   Infinity
06:53:10 <Twey> Heh
06:53:45 <Jafet> > 1e10^100 :: CReal
06:53:47 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
06:53:50 <sdschulze> [horribly OT] Do you know of any #ocaml channel anywhere?
06:54:03 <mreh> arse poo and tiddle
06:54:17 <soupdragon> > let pow x 0 = 1 ; pow x 1 = x ; pow x y = if even y then (((x^(y`div`2))`mod`(10^10))^2)`mod`(10^10) else (x*x^(y-1))`mod`(10^10) in foldr (\x y -> (pow x x + y)`mod`(10^10)) 0 [1..1000]
06:54:18 <mreh> ghc-pkg has borked
06:54:18 <lambdabot>   9110846700
06:55:52 <ivanm> @google ocaml IRC
06:55:53 <lambdabot> http://alan.petitepomme.net/cwn/2004.05.25.html
06:55:53 <lambdabot> Title: Caml Weekly News
06:55:54 <ivanm> sdschulze: ^^
06:56:11 <ivanm> sdschulze: looks like they're on netsplit.de or something
06:56:25 <soupdragon> Did ya try /join #ocaml ?
06:57:01 <ivanm> soupdragon: lol, I assumed he'd already tried that ;-)
06:57:12 <Twey> Haha
06:57:28 <sdschulze> Wtf... /who #ocaml always showed me nothing.
06:57:36 <sdschulze> Maybe I should stop using ERC.
06:57:37 <Fanael> Olathe: [->>+++<<] adds value of current cell times 3 to the second cell to the left and sets the current cell to 0. FarAdd 2 3 followed by Set 0 does exactly the same thing. There's nothing wrong in this optimization.
06:57:38 <Twey> That's for people.
06:57:41 <ivanm> sdschulze: "/topic #ocaml" works here
06:57:47 <Twey> Try /list #ocaml
06:58:09 <mauke> try /join #ocaml
06:58:10 <Twey> I don't think Freenode lets you /who channels.
06:58:16 <sdschulze> anyway... thanks, sorry and bye
06:58:20 <Baughn> [svein@eris b]$ ls ../foo
06:58:20 <Baughn> ls: cannot access ../foo: Is a directory
06:58:21 <Twey> At least not ones you're not in.
06:58:23 <sdschulze> Twey: It works for #haskell.
06:58:29 <Twey> sdschulze: But Haskell is better anyway.  ;)
06:59:01 * Baughn just got pwned by HFuse. Wondrous...
06:59:11 <ivanm> Baughn: lol
06:59:39 * ivanm makes a wild guess that "/who #haskell" works because sdschulze was _in_ #haskell
06:59:52 <ivanm> or not; it seems to work on channels I'm not in
06:59:57 <ivanm> must be some flag thing
07:00:11 * ivanm -> sleep
07:00:16 <Twey> Which channels?
07:00:27 <ivanm> Twey: /who #gentoo seems to work
07:00:28 <Olathe> Fanael: That's true, except for the set to zero. It only sets to one less than it is now.
07:01:20 <Fanael> Nope, because the loop, well, loops while the current cell /= 0.
07:01:27 <Twey> Hm.
07:01:34 <Olathe> Fanael: Sure, but then it adds more than once.
07:02:10 <Olathe> Fanael: For instance, if current cell is seven, it'll set it to zero, but it'll do the add seven times.
07:02:30 <soupdragon> > liftA2 (\x y -> (x*y)`mod`10) [1,2,3,4,5,6,7,8,9] [2,3,4,5,6]
07:02:31 <Fanael> Yeah, it'll add three to the second cell to the left seven times.
07:02:32 <lambdabot>   [2,3,4,5,6,4,6,8,0,2,6,9,2,5,8,8,2,6,0,4,0,5,0,5,0,2,8,4,0,6,4,1,8,5,2,6,4,...
07:02:36 <soupdragon> dammit
07:02:58 <Olathe> Fanael: But I think the optimizer will only do it once instead of seven times.
07:03:26 <Fanael> It won't, there's call to timesWord# in addAt ;)
07:04:00 <Olathe> Ah, OK :)
07:04:41 <Olathe> Thanks for explaining
07:06:15 <Fanael> You're welcome :)
07:08:00 <soupdragon> what's a cool geometry thing I could wiret in heaskll?
07:10:14 <Jafet> 3D rendering? Nope, someone's already on it. GL bindings? There are already several. Physics engine? Nope, already on hackage.
07:10:37 <Jafet> I'm trying to be encouraging, believe me!
07:13:17 <litoh> hello
07:13:19 <litoh> quick question
07:13:21 <litoh> i'm using SDL.pollEvent which gives me one IO Event after another and i want to collect them in a list until the current event is SDL.NoEvent
07:13:30 <litoh> how do i do that?
07:13:52 <litoh> i read http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html already, but i can't find the correct function
07:15:34 <Choko> is there a way to make specialised instances for some types when theres defined a more general instance ?
07:16:22 <Baughn> Choko: The OverlappingInstances extension.
07:16:28 <Choko> thanks
07:17:58 <Olathe> I have data ModArray i e = W8 i i (UArray i Word8) and I'm having a lot of trouble making it an instance of IArray. instance IArray ModArray fails, instance IArray ModArray Integer fails, and instance IArray (ModArray Integer) fails.
07:18:20 <Choko> but it still fails does the instances have to be defined in the same module ?
07:20:48 <Saizan> Choko: OverlappingInstances has to be used where the instances are defined, not where they're used
07:21:09 <Olathe> What does Illegal instance declaration for `IArray ModArray Integer' (Only one type can be given in an instance head.) mean ?
07:21:38 <Saizan> Olathe: that you need FlexibleInstances i think
07:22:13 <Saizan> @src IArray
07:22:13 <lambdabot> Source not found. Wrong!  You cheating scum!
07:22:20 <Saizan> @hoogle IArray
07:22:21 <lambdabot> module Data.Array.IArray
07:22:21 <lambdabot> Data.Array.IArray class IArray a e
07:22:22 <Choko> Saizan: i added the extension to both modules but i guess it's because i define an instance in module A then in module B i import module A and make a overlapping instance :)
07:22:51 <Olathe> Ahh, OK. Thanks
07:22:57 <Saizan> Choko: it's ok to define them in separate modules, and you need the extension only in one of those
07:23:06 <Olathe> It's weird that arrays are nonstandard :)
07:23:06 <Saizan> Choko: can you paste the code and the error?
07:24:18 <Choko> First i read up on overlapping instances
07:25:13 <Choko> but here the error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25527#a25527
07:26:20 <Fanael> > 29620 / 27900
07:26:21 <lambdabot>   1.0616487455197132
07:26:38 * hackagebot rad 0.1.3 - Reverse Automatic Differentiation.  http://hackage.haskell.org/package/rad-0.1.3 (EdwardKmett)
07:26:49 <Saizan> Choko: ok, the problem is that those instances are not just overlapping, they have an identical instance head
07:27:59 <ville> When writing a .cabal file for a project, are the keys in key: value case-sensitive? The examples I've found have had some written Uppercase: while others in the same fire are lowercase:
07:28:01 <Saizan> Choko: the contexts are ignored when deciding which instance to pick
07:28:15 <Saizan> ville: they aren't
07:28:21 <ville> err file
07:28:30 <ville> Ok
07:28:44 <Choko> Saizan: thanks :)
07:29:53 <Choko> but Saizan any ide of what I can do ?
07:30:08 <Choko> I want to make at specialization for characteristic 3
07:30:55 <Saizan> Choko: the standard way is to use a newtype
07:40:34 <leino> could someone please enlighten me as to why I get errors when I try to compile this: http://pastebin.com/sEagMNAF  using ghc
07:41:19 <leino> the errors I get are: http://pastebin.com/hF5Xudpt
07:42:00 <litb> hello folks
07:42:12 <rajeshsr> leino, main should be a IO monad
07:43:09 <leino> rajeshsr: ok... and how do I make it that?
07:43:26 <rajeshsr> main = do {puStrLn $ show (solution 500)}
07:43:44 <rajeshsr> main = do {print (solution 500)}
07:43:52 <leino> so in other words, a main must 'do' something?
07:44:11 <Olathe> @hoogle second
07:44:11 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
07:44:11 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
07:44:11 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
07:44:12 <Fanael> main = print $ solution 500
07:56:09 <Peaker> leino, "main" must have-type IO a.. values of this type "do" things (when executed)
07:57:19 <sepp2k> Note that there's no need for the do keywords in this case. main = print (solution 500)  will work just fine.
07:58:01 <sepp2k> The important bit is that print returns IO ()
07:59:27 <b0fh_ua> Hello! I have some problems with decoding a UTF8 string from url-encoded string.
07:59:31 <b0fh_ua> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25528#a25528
07:59:41 <b0fh_ua> can somebody please explain what am I doing in wrong way?
08:02:16 <alar> b0fh: have you tried to "strip" your source to test just the encoding?
08:02:49 <chrisdone> decodeIt = maybe "" SU.decode
08:05:31 <b0fh_ua> alar: the problem is that if I encode the string and then decode it - it works great
08:05:58 <b0fh_ua> chrisdone: thanks
08:06:35 * alar haven't use cyrillic URIs yet, knows nothing
08:07:10 <b0fh_ua> alar: well, it doesn't look like cyrillic as well :(
08:07:33 <b0fh_ua> I am getting the output exactly as it is procuded in last section, and it's not cyrillic
08:08:28 <alar> bofh: if there are only latin chars - what does UTF8 have to do with it?
08:08:53 <b0fh_ua> alar: it is supposed to be UTF8, and not only latin1
08:11:55 <mreh> :t (<<<) . arr
08:11:56 <lambdabot> forall (cat :: * -> * -> *) b c a. (Arrow cat) => (b -> c) -> cat a b -> cat a c
08:12:03 <mreh> :t fmap
08:12:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:14:11 <Saizan> preflex: seen byorgey
08:14:11 <kolmodin> ?seen kolmodin
08:14:12 <lambdabot> Unknown command, try @list
08:14:12 <preflex>  byorgey was last seen on #haskell 18 hours, 40 minutes and 36 seconds ago, saying: stralep: Data.Set provides the 'unions' function which is the same as foldr union empty
08:14:21 <kolmodin> what's the command called now?
08:14:29 <mauke> kolmodin: don't make me kick you
08:14:30 <Saizan> kolmodin: use preflex
08:15:04 <kolmodin> I got the feeling it was a stupid question
08:15:27 <mauke> unless you have Saizan on ignore
08:15:36 <kolmodin> :)
08:15:39 <kolmodin> ok
08:16:11 <kolmodin> preflex: seen gour
08:16:12 <preflex>  gour was last seen on #haskell 6 days, 1 hour, 10 minutes and 15 seconds ago, saying: night ivanm
08:22:57 * hackagebot rad 0.1.4 - Reverse Automatic Differentiation.  http://hackage.haskell.org/package/rad-0.1.4 (EdwardKmett)
08:26:52 * mux wonders what's up with tagsoup 0.9; ghci/ghc cannot find Text.HTML.TagSoup even though ghc-pkg describe show it as part of the exposed modules
08:28:58 * hackagebot HFuse 0.2.2 - HFuse is a binding for the Linux FUSE library.  http://hackage.haskell.org/package/HFuse-0.2.2 (TaruKarttunen)
08:36:12 <mux> sigh, cabal install insists on insists on installing random-1.0.0.2 in the user database while the very same version is in the global database, thus breaking things.
08:37:48 <mux> forced to do cabal unpack/build/install instead, this is too bad.
08:37:50 <Null-A> how do i declare construct nodes in a circular graph using haskell data constructors?
08:38:06 <aristid> is it dangerous to have this at the beginning of a module? {-# LANGUAGE TypeSynonymInstances, MultiParamTypeClasses, FlexibleInstances #-}
08:38:22 <aavogt> aristid: those are pretty safe extensions
08:39:09 <mux> omg cabal-install is being very stupid today
08:39:15 <Saizan> mux: what command are you running that ends up doing that?
08:39:28 <mux> "cabal install tagsoup"
08:39:42 <mux> but this ends up the same when I do unpack/build/install actually
08:39:58 <Saizan> can you run "cabal install tagsoup --dry-run -v" and paste the output somewhere?
08:40:13 <mux> cabal must see I'm a normal user, and that I want to install in the user db alright, but it mistakeningly seems to strip the global db at the same time
08:40:31 <mux> so it ends up willing to reinstall base packages
08:40:52 <Saizan> there's no occasion where it'll "strip" the global db
08:41:18 <Saizan> some global packages might appear broken or unsuitable though, --dry-run -v will give something to work on
08:42:59 <mux> doesn't say much about why it choses to reinstall random-1.0.0.2 in that case
08:43:07 <mux> selecting random-1.0.0.2 (installed or hackage) and discarding random-1.0.0.0
08:43:07 <mux> and 1.0.0.1
08:43:19 <mux> (funnily, there is /only/ random-1.0.0.2 installed)
08:43:21 <mux> and later :
08:43:26 <mux> In order, the following would be installed:
08:43:27 <mux> random-1.0.0.2 (reinstall) changes: time-1.1.4 -> 1.2.0.2
08:43:40 <Saizan> ok, so that's the point
08:43:47 <mux> so it's not saying why it wants to reinstall random
08:43:54 <Saizan> that's why
08:44:05 <mux> ...?
08:44:10 <Saizan> it's trying to reinstall random because it decided to use another version of time
08:44:27 <mux> that makes no sense at all
08:44:49 <Saizan> time is apparently a dependency of random
08:44:54 <mux> yes
08:45:09 <mux> I can see that, but it still makes no sense
08:45:30 <Saizan> cabal-install seeks a solution where you use only one version of every package (except base)
08:45:37 <Saizan> to prevent type errors later.
08:45:50 <mux> I'm telling cabal to install some package; all the dependencies for it are met, there is no need to try to reinstall a package just because one of its deps has been updated
08:45:54 <Saizan> (the type errors don't necessarily occur, but they might)
08:46:04 <Saizan> it's not just because of that.
08:46:18 <Saizan> it's because it picked time-1.2.0.2 for some other reason
08:46:31 <mux> well yeah one could say that
08:47:01 <mux> but it still doesn't give any reason why it would want to select time-1.2.0.2 either
08:47:03 <Saizan> if it happens to just be because it was the latest then you can just add a --constraint="time==1.1.4" and it'll work
08:47:16 <mux> yes but a bug needs to be fixed
08:47:27 <Saizan> does it work with that constraint?
08:47:56 <mux> Saizan: yes
08:48:16 <JasonFelice> How do I get a Ptr Word8 into a ByteString in GHC?  It seems that only Hugs has fromForeignPtr...
08:48:26 <Saizan> ok, then this is indeed a shortcoming of the dependency solver
08:48:52 <Saizan> it's known to be far from complete, since it never backtracks
08:48:53 <mux> thanks btw, I now have a working tagsoup-0.9 module
08:49:34 <aristid> can you explain what i'm doing wrong here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25529#a25530
08:49:44 <Saizan> np
08:49:54 <aristid> why doesn't it find out that k = Int and v = Int?
08:51:04 <soupdragon> aristid: it just doesn't you need to add a fundep for that
08:51:17 <soupdragon> aristid: althuogh I would probably suggest to do ths in a different way than use fundeg
08:51:32 <Saizan> aristid: because you could easily make a new instance where a is still a list of pairs but k and v are other things
08:52:12 <aristid> how can i solve this?
08:52:35 <Saizan> you'd never be able to use the "empty" method with that class definition
08:52:48 <aristid> insert doesn't work either
08:53:06 <Saizan> insert would work if you add enough type annotations
08:53:12 <mreh> how does <*> work for arrows?
08:53:47 <Saizan> aristid: the solution is to use fundeps or associated types
08:53:57 <mreh> Kleisli has no Functor and Applicative instances, strangely, so we could start there
08:54:10 <mreh> @instances Functor
08:54:11 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:54:27 <mreh> @instances-importing Control.Arrows Functor
08:54:28 <lambdabot> IO, Maybe, []
08:54:50 <Saizan> mreh: you can make an "instance Arrow (~>) => Applicative ((~>) a) where"
08:55:11 <Saizan> well, you could if it didn't overlap with a lot of things :)
08:56:04 <Axman6> @instances-importing Control.Arrow Functor
08:56:05 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:56:09 <Saizan> "instance Applicative f => Applicative (Kleisli f a)" should work
08:56:12 <mreh> is ~> an infix type constructor?
08:56:28 <Saizan> an infix type variable
08:56:32 <mreh> variable
08:57:36 <Makoryu> mreh: Yep. When you see "a b c" in a type signature (in Arrow functions, for example) you can rewrite it as "b ~> c"
08:57:53 <Makoryu> (I mean, so long as you replace all other instances of "a" with "(~>)")
08:58:12 <Makoryu> :t (***)
08:58:13 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:58:25 <mreh> I know arrows already :)
08:58:45 <aristid> Saizan: thanks, fundeps help!
08:59:04 <aristid> Saizan: but soupdragon said i should avoid fundeps?
08:59:11 <soupdragon> no I didn't
08:59:15 <soupdragon> I said /I/ avoid fundeps
08:59:21 <mreh> Saizan: I can define Applicative without the body?
08:59:32 <aristid> soupdragon: why?
08:59:35 <soupdragon> well okay I didn't say that either but I meant it
08:59:39 <soupdragon> I ujst don't like them
08:59:46 <mreh> or a deriving
08:59:47 <soupdragon> they seem bad to me
08:59:47 <aristid> soupdragon: is there another solution?
08:59:51 <soupdragon> yes
08:59:58 <aristid> i'm curious!
09:01:02 <mreh> this is so hard :(
09:01:53 <mreh> @remember Barbie Math is hard, teehee
09:01:53 <lambdabot> Nice!
09:04:14 <mreh> It makes me smile when people get mad over trivial things
09:04:30 <soupdragon> uh why
09:04:51 <mreh> some business commission in the UK hit the roof when bottle of vitamin water were "encouraging people to takes days off"
09:05:42 <mreh> maybe it's because they're projecting all their anger onto one small thing, and it seems a little overkill
09:06:16 <mreh> mathematics professors outraged at talking barbie dolls for example
09:06:33 <mreh> it points to a deeper fear maybe
09:06:40 <Peaker> I get mad at software a lot
09:07:14 <aavogt> mreh: they will be replaced by talking barbie dolls soon enough :)
09:07:31 <mreh> terrifying
09:07:53 <Saizan> mreh: no, i was just stubbing the declaration, you'd need to fill in the methods' implementation
09:08:24 <mreh> Saizan :) I needed that part in the first place
09:08:37 <Philonous> Peaker: I like xkill. It is deeply satisfying to blast disobedient software to oblivion. I hate it when my software talks bag to me like in windows ("Are you sure? Do you really want to quit?" ...)
09:08:45 <Philonous> back*
09:08:46 <mreh> I'll have a crack at it
09:08:55 <mreh> maybe I can use runKleisli to get the computation out
09:09:03 <rajeshsr> how do you convert, a character '1' to Int 1
09:09:05 <rajeshsr> ?
09:09:21 <mreh> @hoogle Char -> Int
09:09:21 <lambdabot> Data.Char digitToInt :: Char -> Int
09:09:21 <lambdabot> Data.Char ord :: Char -> Int
09:09:21 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
09:09:31 <mreh> > digitToInt '1'
09:09:33 <lambdabot>   1
09:09:37 <aavogt> > fromEnum '1'
09:09:38 <lambdabot>   49
09:09:47 <mreh> > fromEnum '2'
09:09:48 <lambdabot>   50
09:10:09 <mreh> > subtract 48 . fromEnum
09:10:09 <rajeshsr> mreh, thanks! Should learn to search like that!!
09:10:10 <lambdabot>   {()->-48}
09:10:11 <mreh> kinda
09:10:19 <aavogt> heh
09:10:20 <Saizan> mreh: you get something of type "a -> f b" out of runKliesli, i can give you the code if you want :)
09:10:55 <mreh> @list
09:10:55 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:10:57 <aavogt> > subtract (fromEnum '0') . fromEnum . (`asTypeOf`'a')
09:10:59 <lambdabot>   {'a'->49;'b'->50;'c'->51;'d'->52}
09:10:59 <Peaker> Philonous, heh, yeah
09:11:12 <mreh> how do I get particular implementations of a method with lambdabot?
09:11:21 <Peaker> Philonous, I hate it when the 3 major OS's are thrashed to utter unresponsiveness whenever a single process malfunctions and allocates too much or such
09:11:34 <aavogt> @src Monad (>>=)
09:11:34 <lambdabot> Source not found. Do you think like you type?
09:11:34 <Peaker> Philonous, For decades they are not fixing this problem
09:11:40 <aavogt> @src Monad (=<<)
09:11:40 <lambdabot> Source not found.
09:11:41 <Peaker> aavogt, which monad?
09:11:45 <mreh> heh
09:11:47 <aavogt> @src Monad []
09:11:48 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:11:52 <mreh> lol
09:11:54 <Peaker> @ src [] (>>=)
09:11:54 <Axman6> @src Either (>>=)
09:11:54 <aavogt> @src [] (=<<)
09:11:54 <lambdabot> Left  l >>= _ = Left l
09:11:54 <lambdabot> Right r >>= k = k r
09:11:55 <lambdabot> Source not found.
09:12:02 <aavogt> oh, finally
09:12:15 <aavogt> Peaker: all of them
09:12:16 <Peaker> @src [] (>>=)
09:12:16 <lambdabot> xs >>= f     = concatMap f xs
09:12:19 <mreh> @src (>>>) (Kleisli m)
09:12:19 <lambdabot> Source not found. Wrong!  You cheating scum!
09:12:31 <Peaker> aavogt, It's an open set, potentially infinite :)
09:12:58 <aavogt> mreh: ask where they are defined with :info, then track down the source of your library
09:13:01 <temoto> take n $ repeat a  -- how is this called?
09:13:09 <rajeshsr> @type concat
09:13:09 <aavogt> replicate
09:13:10 <lambdabot> forall a. [[a]] -> [a]
09:13:10 <Peaker> @src replicate
09:13:10 <lambdabot> replicate n x = take n (repeat x)
09:13:31 <temoto> Thanks.
09:13:38 <aavogt> I don't think ghc can handle an infinite number of instances
09:13:49 <rajeshsr> > concat $ map show [1,2,3]
09:13:50 <lambdabot>   "123"
09:14:07 <aavogt> there tend to be performance issues before you get to a couple million instances
09:14:10 <Peaker> > concat . map show $ [1,2,3]
09:14:11 <lambdabot>   "123"
09:14:27 <Peaker> aavogt, ghc only has to see a subset at a time
09:14:37 <Peaker> aavogt, ":info" in ghci tells you what instances it sees now
09:14:49 <aavogt> http://greayer.wordpress.com/2010/01/28/record-selector-punning-with-type-level-strings-2/
09:15:21 <aavogt> Peaker: and you only get a finite number of invocations of ghc
09:15:44 <aavogt> therefore we are practically limited to a finite number of instances
09:16:00 <Peaker> aavogt, unbounded number though
09:16:37 <aavogt> just because I can't tell you the bound doesn't mean it doesn't exist :)
09:19:04 <centrinia> The bound might be the remaining lifespan of the universe times the maximum number of devices that can run ghc divided by the minimum time it takes to invoke ghc.
09:23:22 <mdmkolbe> Is there a way to get GHCi to nicely wrap the results of "show"  (e.g. with indentation etc.)
09:24:14 <dino-> What exactly does the Char Read instance do? I can't get source from the GHC lib docs.
09:25:17 <centrinia> > read 'a'
09:25:18 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:25:18 <lambdabot>         against inferred ty...
09:25:25 <centrinia> > read "a" :: Char
09:25:26 <lambdabot>   *Exception: Prelude.read: no parse
09:25:50 <Botje> > show 'a'
09:25:51 <lambdabot>   "'a'"
09:25:52 <Axman6> > read "'c'" :: Char
09:25:53 <lambdabot>   'c'
09:25:58 <centrinia> Oh.
09:26:09 <dino-> > read '1' :: Int
09:26:10 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:26:10 <lambdabot>         against inferred ty...
09:27:05 <Fanael> > read "1" :: Int
09:27:06 <lambdabot>   1
09:28:02 <Fanael> @src Char read
09:28:02 <lambdabot> Source not found. You type like i drive.
09:28:15 <Saizan> mdmkolbe: not really, you could parse the result and pretty print it with haskell-src-exts though :)
09:30:09 <mdmkolbe> Hmm, is there maybe a "deriving(PrettyPrint)"?
09:30:17 <rajeshsr> > range 1 10
09:30:18 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
09:30:28 <rajeshsr> @type range
09:30:29 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
09:30:37 <rajeshsr> > range (1, 10)
09:30:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:32:03 <Axman6> Fanael: still around?
09:32:59 <Fanael> Is anything bad in this?
09:35:42 <Axman6> you were the one who wrote that fast brainfuck interpreter aren't you?
09:36:13 <Fanael> Yep.
09:36:48 <Axman6> well, i'm having fun playing with it. running a bf interpreter written in bf running itself running a hello world program
09:37:25 <Fanael> And it works?
09:37:26 * hackagebot constructive-algebra 0.1 - A library of constructive algebra.  http://hackage.haskell.org/package/constructive-algebra-0.1 (AndersMortberg)
09:37:32 <Axman6> waiting to see
09:37:59 <aavogt> mdmkolbe: there are some libraries which take the output of show and insert line breaks and indentation to make things a bit more readable
09:38:04 <aavogt> @hackage IPPrint
09:38:04 <lambdabot> http://hackage.haskell.org/package/IPPrint
09:38:07 <Axman6> seems to just die, ie, stops computing anything. uses heaps of CPU for a while, then just dies down
09:38:14 <aavogt> http://hackage.haskell.org/package/ipprint
09:38:46 <Axman6> could be that its the parsing and optimising that's causing all of the CPU usage
09:41:29 <Fanael> Hmm, odd.
09:44:55 <Fanael> Does your code work under other interpreters?
09:45:50 <Axman6> yes
09:46:03 <Axman6> well, it works in yours
09:46:48 <Axman6> what's the simplest bf program i could use to test if it was actually working ok?
09:47:10 <Fanael> Hello world perhaps?
09:47:41 <mauke> he said simple
09:48:11 <Fanael> Isn't hello world simple?
09:48:28 <mauke> not in brainfuck
09:48:39 <Axman6> it's just ++++++[>++++++++++++<-]>.>++++++++++[>++++++++++<-]>+.+++++++..+++.>++++[>+++++++++++<-]>.<+++[>----<-]>.<<<<<+++[>+++++<-]>.>>.+++.------.--------.>>+.
09:48:40 <mdmkolbe> aavogt: cool, that looks like just what I want (though I'll have to tweak the parameters)
09:48:40 <tensorpudding> maybe a no-op program
09:48:42 <Axman6> apparently
09:48:54 <Axman6> i need to print something
09:48:59 <soupdragon> +[+.]
09:49:08 <soupdragon> > map chr [1..]
09:49:08 <Axman6> good plan
09:49:09 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\E...
09:49:25 <mauke> @bf +.
09:49:26 <lambdabot>  Done.
09:49:30 <deech> Hi all, I recently installed ghc 6.12 and Haskell Platform and I am having trouble installing FileManip: I get the following error: Registering directory-1.0.1.0...
09:49:30 <deech> <command line>: cannot satisfy -package Cabal-1.8.0.2:
09:49:30 <deech>     Cabal-1.8.0.2-bc92fe595a99db06fca8c2eb712108b4 is unusable due to missing or recursive dependencies:
09:49:30 <deech>       directory-1.0.1.0-6fc781e8b4c1e6453beef99caa1eb840 process-1.0.1.2-796f8df86c244641e2bb164491ae2490
09:49:33 <mauke> @bf +[+.]
09:49:33 <lambdabot>    !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghij...
09:49:38 <deech> crap, sorry about that.
09:50:37 <danharaj> for some a, is Either a a monad?
09:50:55 <Axman6> for all a
09:52:15 <Peaker> danharaj, Either a a   isn't a Monad, because it is a type and not a type constructor.  (Either e) is a monad, if you're willing to ignore the stupid "fail" method or put a restriction on "e" that it can be made from a String
09:52:42 <danharaj> Right, should have put a comma after the first a.
09:52:52 <Axman6> danharaj: did you mean is (Either a) a monad, or is (Either a a)..
09:52:56 <Axman6> the former
09:53:02 <danharaj> (Either a)
09:53:05 <ddarius> type W a = Either a a is a comonad.
09:53:06 <Axman6> @src Either >>=
09:53:07 <lambdabot> Source not found. My mind is going. I can feel it.
09:53:10 <Axman6> @src Either (>>=)
09:53:10 <lambdabot> Left  l >>= _ = Left l
09:53:11 <lambdabot> Right r >>= k = k r
09:53:12 <Peaker> danharaj, oh, heh, yeah.. But unfortunately, the Monad class fails by having "fail" in it
09:53:18 <mauke> @bf ++++.>+++++++++++[>+++++++++<-]>--..<.>.
09:53:18 <lambdabot>   aaa
09:53:32 <Peaker> @bf ++++.>++++
09:53:33 <lambdabot>  Done.
09:54:02 <mauke> > length "aaa"
09:54:03 <lambdabot>   <no location info>:
09:54:03 <lambdabot>      lexical error in string/character literal at chara...
09:55:36 <Peaker> @type (first, fst)
09:55:37 <lambdabot> forall (a :: * -> * -> *) b c d a1 b1. (Arrow a) => (a b c -> a (b, d) (c, d), (a1, b1) -> a1)
09:55:44 <Peaker> @type (first . second, snd . fst)
09:55:44 <lambdabot> forall (a :: * -> * -> *) d b c d1 a1 b1 b2. (Arrow a) => (a b c -> a ((d1, b), d) ((d1, c), d), ((a1, b1), b2) -> b1)
09:55:59 <mauke> :t first fst
09:56:00 <lambdabot> forall c b d. ((c, b), d) -> (c, d)
09:56:08 <dmwit> Is that 'a' blinking?
09:56:15 <dmwit> =/
09:56:15 <mauke> yes
09:57:13 <ddarius> instance Functor W where fmap f = either (Left . f) (Right . f); instance Comonad W where extract = either id id; duplicate (Left a) = Left (Left a); duplicate (Right a) = Right (Right a)
09:58:22 <ddarius> duplicate = either (Left . Left) (Right . Right)
09:59:13 <walrus_> (ok, maybe a too general question) if I create a data type, is always possible to create a random object of that type?
09:59:40 <jon_of_arc> No, consider types with no constructor.
10:00:43 <HARRISON> webchat breaks the links in topic
10:00:46 <HARRISON> just fyi
10:01:21 <walrus_> jon_of_arc: ok, but if I have constructors?
10:04:23 <ville> How do I find out my version of `base', trying to satisfy cabal check so it doesn't complain about upper bound missing
10:04:44 <Fanael> cabal info base
10:05:52 <jon_of_arc> walrus_: to be clear: when you say "random", do you mean construct a value of that type whose constructor is selected at random from the available constructors and whose constructor arguments are similarly selected at random (in the same manner) from their range?
10:06:10 <jon_of_arc> Huh. Formatting fail, apparently; not sure what happened there
10:07:22 <walrus_> jon_of_arc: yes, and select randomly the arguments that you be passed to the constructors
10:07:37 <Null-A> How do I data construct nodes in circular graph ?
10:08:41 <Null-A> it the only way to declare self referential data structures is via indirection?
10:09:00 <mauke> > let xs = 1 : xs  in  xs
10:09:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:09:11 <jon_of_arc> Null-A: you can tie knots, or use a different approach to defining the structure
10:09:43 <jon_of_arc> walrus_: I would need to spend time I don't have thinking about it to come to a clear opinion (let alone proof), but my hunch is that functions will cause problems.
10:09:56 <walrus_> jon_of_arc: my problem is that with my type http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25532 the arguments to the constructors depends of the first randomly selected argument.
10:10:37 <Null-A> mauke: the nodes aren't linking to the next ones though, you just have an infinite list of nodes
10:10:59 <Null-A> unfortunately my links are far more complex than a linear sequence
10:14:20 <jon_of_arc> Null-A: if your structure is complex this probably isn't what you want, but http://www.haskell.org/haskellwiki/Tying_the_knot gives an explanation of the approach
10:14:34 <Null-A> jon_of_arc: thanks
10:18:52 <jon_of_arc> walrus_: sorry, it looks like it'll take more time than I have to wrap my head around the issue.
10:19:32 <walrus_> jon_of_arc: ok, thanks!
10:20:10 <danharaj> What value does (read foo) return if foo cannot be read into the desired type?
10:20:18 <mauke> undefined
10:20:34 <mauke> @src undefined
10:20:35 <lambdabot> undefined =  error "Prelude.undefined"
10:20:52 <danharaj> Is there a reason why they did not use Maybe?
10:21:17 <mauke> if you want reads, you know where to get it
10:21:24 <danharaj> true.
10:21:33 <jon_of_arc> I'd imagine it's for the same reason map works on lists
10:21:39 <jon_of_arc> Rather, is specific to lists
10:22:38 <danharaj> jon_of_arc: And that is? Accident of history?
10:25:02 <jon_of_arc> danharaj: I was assuming new-user-friendliness (by giving list-related error messages instead of functor-related error messages for map, and by being partial rather than introducing a Maybe for read), but that could also be the case. Now that I think about it, I can't remember where I read the explanation of the map choice, and it may have been a post-hoc justification or simply incorrect speculation.
10:29:25 * sepp2k can buy the user-friendliness argument for map, but not for read.
10:30:49 <danharaj> jon_of_arc: I suppose beginner friendliness could be possible, but since when has haskell ben beginner friendly? :p
10:33:24 <Fanael> Hello, it's me again! *evil laughter*
10:37:41 <blueonyx> > 0.2+0.2+0.2
10:37:41 <lambdabot>   0.6000000000000001
10:37:56 <soupdragon> > 0.99999999999999999999999
10:37:56 <lambdabot>   1.0
10:38:39 <blueonyx> > 0.2*3
10:38:40 <lambdabot>   0.6000000000000001
10:38:46 <blueonyx> > 0.2*3.0
10:38:47 <lambdabot>   0.6000000000000001
10:39:22 <silver> :t 0.2
10:39:23 <lambdabot> forall t. (Fractional t) => t
10:40:15 <rajeshsr> is there any haskell settings file for vim? am unable to access this: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
10:40:21 <Fanael> > foldl' (+) 0 [1, 1.1..2]
10:40:21 <lambdabot>   16.500000000000004
10:40:44 <aavogt> > [1, 1 .. ]
10:40:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:41:14 <Fanael> :t foldr
10:41:15 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:42:04 <Fanael> @pl (\_ x -> x + 1)
10:42:04 <lambdabot> const (1 +)
10:42:14 <aavogt> > let s = [1, 1.1 .. 10 ] in foldr (+) 0 s == foldl (+) 0 s
10:42:15 <lambdabot>   True
10:42:58 <Fanael> @pl (\x _ -> x + 1)
10:42:58 <lambdabot> const . (1 +)
10:43:27 <Fanael> > foldl' (const . (+ 1)) 0 [1..1000]
10:43:28 <lambdabot>   1000
10:43:57 <aavogt> length already?
10:44:35 <Fanael> I can't use length.
10:45:13 <mauke> > sum . map (const 1) $ [1..1000]
10:45:14 <lambdabot>   1000
10:45:15 <aavogt> sounds artificial
10:45:59 <aristid> does this code look reasonable? any obvious improvements? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25533#a25533
10:46:10 <Fanael> I'm doing some exercises - one of them is to write length using a fold.
10:46:17 <laughedelic> rajeshsr, look at this also http://www.vim.org/scripts/script.php?script_id=2356
10:47:50 <aristid> @let foldrLength = foldr (const (+1)) 0
10:47:51 <lambdabot>  Defined.
10:47:58 <aristid> > foldrLength [1 .. 4]
10:48:00 <lambdabot>   4
10:48:39 <aavogt> is there a difference between   class C a b c | a -> b, a -> c   and   class C a b c | a -> b c
10:48:50 <aavogt> hmm, I suppose the former is more restrictive
10:49:03 <Fanael> > foldr (const (1+)) 0 [1..1000000]
10:49:04 <aristid> aavogt: the latter is legal?
10:49:04 <lambdabot>   *Exception: stack overflow
10:49:18 <aavogt> yes
10:49:35 <Fanael> > foldl' (const . (1+)) 0 [1..1000000]
10:49:36 <lambdabot>   1000000
10:49:50 <soupdragon> > last [1..10000000]
10:49:51 <lambdabot>   10000000
10:50:01 <blueonyx> :t maybe
10:50:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:50:20 <blueonyx> aka unmaybe
10:50:48 <aavogt> hmm, it looks like they are the same
10:51:17 <aavogt> so foldr should be called list?
10:51:17 <Fanael> > foldl1' (flip const) [1..10]
10:51:18 <lambdabot>   10
10:51:38 <aavogt> but such naming isn't ambiguous for `maybe'
10:51:39 <edwardk> aavogt: they mean the same thing
10:52:02 <edwardk> aavogt: (re the fundep question)
10:52:12 <aavogt> edwardk: it's a bit odd because the latter sort of implies that  b :: * -> *
10:52:17 <aavogt> but it doesn't actually
10:52:18 <aristid> aavogt: cool, so i'll use that
10:53:47 <Fanael> > 3# +# 8# -- ^^
10:53:48 <lambdabot>   Not in scope: `+#'
10:54:35 <aavogt> @vixen how about some unboxing?
10:54:36 <lambdabot> how? it depends...
10:56:00 <aristid> :t 3#
10:56:01 <lambdabot> GHC.Prim.Int#
10:56:17 <copumpkin> Fanael: it wouldn't be able to Show it anyway. You'd need to wrap it in I#
10:56:25 <copumpkin> :t GHC.Prim.+#
10:56:27 <lambdabot> parse error on input `GHC.Prim.+#'
10:56:35 <copumpkin> > GHC.Prim.+#
10:56:36 <lambdabot>   <no location info>: parse error on input `GHC.Prim.+#'
10:56:47 <copumpkin> > i# (3# GHC.Prim.+# 5#)
10:56:48 <lambdabot>   Not in scope: `i#'Not in scope: `GHC.Prim.+#'
10:56:55 <copumpkin> guess not
10:57:08 <aristid> > 3#
10:57:09 <lambdabot>   Couldn't match kind `#' against `*'
10:57:18 <aristid> :k 3
10:57:19 <lambdabot> Only unit numeric type pattern is valid
10:57:27 <aristid> oO
10:57:59 <copumpkin> 1 is a valid type
10:58:03 <copumpkin> strangely enough
10:58:41 <aristid> copumpkin: why?
10:58:44 <aristid> :k 1
10:58:45 <lambdabot> *
10:58:58 <copumpkin> because someone thought it looked nicer than writing Unit, I guess
10:58:59 <Fanael> > flip id `id` 2 `id` (*4) -- nice way to frighten small programmers
10:59:00 <lambdabot>   8
10:59:05 <aristid> :k Unit
10:59:07 <lambdabot> *
10:59:13 <aristid> :t ()
10:59:14 <lambdabot> ()
10:59:15 <copumpkin> > Unit :: 1
10:59:16 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
10:59:17 <lambdabot>    arising from a use of ...
10:59:22 <aristid> > () :: 1
10:59:24 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
10:59:24 <lambdabot>         against inferred t...
10:59:30 <copumpkin> so they built it into the compiler :P
10:59:45 <aristid> copumpkin: sounds like a very stupid thing to do.
11:00:36 <Fanael> :t flip id
11:00:37 <lambdabot> forall a b. a -> (a -> b) -> b
11:00:45 <Fanael> How come?
11:00:59 <aristid> :t flip
11:01:00 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:01:07 <aristid> :t Prelude.flip
11:01:08 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:01:46 <aristid> :t flip ($)
11:01:47 <lambdabot> forall a b. a -> (a -> b) -> b
11:03:16 <Peaker> any pretty alternative to ($ x) . ($ y) . ($ z)   ?
11:03:25 <Peaker> @type \x y z -> ($x) . ($y) . ($z)
11:03:26 <lambdabot> forall a b a1 a2. a -> a1 -> a2 -> (a2 -> a1 -> a -> b) -> b
11:03:35 <Peaker> @pl \x y z -> ($x) . ($y) . ($z)
11:03:36 <lambdabot> (. flip (flip . flip id)) . (.) . flip flip
11:03:39 <aristid> @unpl f x y z = ($ x) . ($ y) . ($ z)
11:03:40 <lambdabot> f x y z f = f z y x
11:03:57 <aristid> Peaker: i think the pointful version is rather easy to read :P
11:04:10 <ddarius> Hmm, poor choice of variable names, though perfectly legal.
11:04:44 <ddarius> > let notRecursive notRecursive = notRecursive in notRecursive 3
11:04:46 <lambdabot>   3
11:05:08 <copumpkin> @quote id
11:05:08 <lambdabot> qwe1234 says: laziness is TEH SUCK, by the way. there's a reason we got rid of it after writing the first fortran compiler.
11:05:15 <copumpkin> @quote id
11:05:16 <lambdabot> bos says: it looks like an interesting book, although i find the idea that software engineers might be ready for category theory this side of the 22nd century charmingly naive
11:05:19 <copumpkin> meh
11:05:23 <Peaker> aristid, then I'd need an extra \ for the point
11:05:33 <Peaker> aristid, I don't like \x -> ...  I prefer to compose functions :)
11:06:09 <aristid> Peaker: i like readability, but i'm also bad at reading mildly complex point-free code
11:06:23 <aristid> dot sections scare me especially much :D
11:06:35 <Makoryu> :t (.).(.)
11:06:36 <Peaker> aristid, I don't use dot sections, I use SECs instead
11:06:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:06:43 <Fanael> @pl (f x >>= \y -> g >> return y)
11:06:43 <lambdabot> (g >>) . return =<< f x
11:07:01 <Makoryu> @unpl (.) (.) (.)
11:07:02 <lambdabot> (\ c e f i -> c (e f i))
11:07:16 <Makoryu> @unpl fmap fmap fmap
11:07:16 <lambdabot> fmap fmap fmap
11:07:21 <Makoryu>  в”ђ(гЂЂВґгЂ°`)в”Њ
11:07:29 <aristid> Peaker: secs?
11:07:30 <Peaker> @unpl (.) . (.) . (.)
11:07:30 <lambdabot> (\ l b c f i -> l (b c f i))
11:07:33 <Peaker> @where SEC
11:07:34 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
11:07:45 <Peaker> aristid, extremely important technique in FP
11:08:36 <Fanael> @unpl ((g >>) . return =<< (f x))
11:08:36 <lambdabot> (\ d -> g >> (((f x) >>= return) d))
11:09:24 <aristid> Peaker: i always have the feeling that there's so much to learn when learning haskell
11:09:26 <conal> btw, i prefer "fmap . fmap" to "fmap fmap fmap", as the former captures which fmap is general and which is necessarily (.)
11:09:31 <Makoryu> @unpl second . (.) . first . map
11:09:32 <lambdabot> (\ f -> second (\ b c -> first (map f) (b c)))
11:09:46 <ddarius> aristid: Would you rather the alternative?
11:10:21 <Fanael> @pl fmap `fmap` fmap
11:10:21 <lambdabot> fmap `fmap` fmap
11:10:23 <aristid> ddarius: rather not learn? no, i want to learn, it's just the feeling of being overwhelmed
11:10:27 <conal> ddarius: :)
11:11:01 <Makoryu> aristid: I think the entirety of Haskell's hype these days is due to the fact that there *is* so much to learn
11:11:24 <Makoryu> Not that you *need* to learn even a small amount of it in order to use Haskell, though
11:11:28 <ddarius> Most of it is not necessary to learn though to be a competent Haskell programmer.
11:11:53 <Makoryu> Yeah. Learn enough to get in on the ground floor, and then ride the waves of brain expansion as they carry you to satori.
11:11:58 <Makoryu> пј€гЂЂВ°вЂївЂїВ°пј‰
11:12:02 <glguy> Are you guys talking about something specific that started before I joined or all agreeing on generalizations?
11:12:33 <copumpkin> SEC I think
11:13:13 <Makoryu> glguy: The conversation progressed from "point-free style is hard/scary" to SEC to "there's a lot to learn in Haskell"
11:13:47 <glguy> ah
11:14:11 <aristid> Makoryu: that's true but represented in an unfair way :P
11:14:16 <conal> there's a lot one *can* learn, but not so much one *must* learn.  (for instance SECs)
11:14:21 <soupdragon> what is SEC?
11:14:23 <glguy> (and what is SEC)?
11:14:25 <soupdragon> urgh I know hwat it is
11:14:30 <Makoryu> aristid: I chose brevity over accuracy... Sorry >_>
11:14:36 <aristid> soupdragon: http://conal.net/blog/posts/semantic-editor-combinators/
11:14:55 <Makoryu> aristid: So my explanation ran faster, and produced incorrect results ;)
11:15:22 <aristid> Makoryu: i like point-free style as long as i understand it, and i'm trying to understand it better with time
11:15:46 <aristid> but sometimes points are good
11:15:49 <glguy> point-free style is certainly useful on IRC where you get about one line at a time to talk to lambdabot
11:16:09 <aristid> glguy: there's always let ... in:)
11:17:08 <conal> haskell (and functional programming in general) allow one to express big thoughts, but doesn't require one to.  (on big thoughts, see john backus's turing award paper "can programming be liberated ...".)
11:17:55 <soupdragon> I wish I had something to write in haskell! I have been trying to come up with ideas for weeks now!
11:18:25 <ddarius> soupdragon: What do you write in other programming languages?
11:18:31 <soupdragon> nothing
11:18:37 <ddarius> soupdragon: What do you find interesting about Haskell?
11:18:45 <soupdragon> not much :|
11:18:54 <soupdragon> I learned the basics already there is not much to explore afaict
11:19:16 <conal> soupdragon: maybe take up something other than programming
11:19:33 <conal> hacky sack looks awfully fun.
11:20:26 <glguy> You could set up a protection racket
11:20:34 <aristid> is there a nice function for (flip .)?
11:20:41 <aristid> or operator
11:20:45 <ddarius> :t (flip .)
11:20:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f1 (f (a -> b)) -> f1 (a -> f b)
11:20:58 <aristid> :t flip Prelude..
11:20:58 <ddarius> Freakin' Christ
11:20:59 <lambdabot> parse error (possibly incorrect indentation)
11:21:05 <aristid> :t flip (Prelude..)
11:21:06 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
11:21:17 <aristid> @djinn forall b c a. (a -> b) -> (b -> c) -> a -> c
11:21:17 <glguy> >>>
11:21:17 <lambdabot> f a b c = b (a c)
11:21:27 <ddarius> :t (flip Prelude..)
11:21:28 <lambdabot> forall (f :: * -> *) a b a1. (Functor f) => (a1 -> f (a -> b)) -> a1 -> a -> f b
11:21:34 <ddarius> :t (Prelude.flip Prelude..)
11:21:35 <lambdabot> forall a b c a1. (a1 -> a -> b -> c) -> a1 -> b -> a -> c
11:21:36 <copumpkin> lol
11:21:42 <aristid> @src (>>>)
11:21:43 <lambdabot> Source not found. I am sorry.
11:21:53 <glguy> :t (>>>) :: (a -> b) -> (b -> c) -> a -> c
11:21:54 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
11:22:00 <aristid> uh i actually meant flip (.)
11:22:03 <aristid> not (flip .)
11:22:23 <copumpkin> the >>>
11:22:34 <copumpkin> then*
11:23:09 <aristid> Peaker: ($ z) >>> ($ y) >>> ($ x)?
11:23:31 <aristid> @unpl f x y z = ($ z) >>> ($ y) >>> ($ x)
11:23:32 <lambdabot> f x y z = ((\ a -> a z) >>> \ b -> b y) >>> \ c -> c x
11:23:52 <aristid> @unpl f x y z = let (>>>) = flip (.) in ($ z) >>> ($ y) >>> ($ x)
11:23:52 <lambdabot> f x y z = let { (b >>> c) f = c (b f)} in (((\ g -> g z) >>> \ h -> h y) >>> \ i -> i x)
11:24:03 <aristid> @unpl f x y z = let (>>>) = flip (.) in (($ z) >>> ($ y) >>> ($ x))
11:24:03 <lambdabot> f x y z = let { (b >>> c) f = c (b f)} in (((\ g -> g z) >>> \ h -> h y) >>> \ i -> i x)
11:25:39 <aristid> @hoogle >>>
11:25:40 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
11:25:40 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
11:25:40 <edwardk> preflex: xseen alp
11:25:40 <preflex>  alp was last seen on freenode/#haskell-blah 47 days, 17 hours, 53 minutes and 34 seconds ago, saying: yeah!
11:26:04 <edwardk> preflex: xseen alpmestan
11:26:04 <preflex>  Sorry, I haven't seen alpmestan
11:26:08 <copumpkin> alpounet
11:26:11 <edwardk> thanks =)
11:26:16 <edwardk> preflex: xseen alpounet
11:26:16 <preflex>  alpounet was last seen on freenode/#haskell 5 days, 18 hours, 50 minutes and 31 seconds ago, saying: #Г¦lgorithms ? maybe
11:26:28 <copumpkin> :)
11:26:40 <copumpkin> you giving him something rad for his neural networks? :o
11:26:43 <edwardk> trying to figure out what a cotangent tower looks like
11:27:00 <edwardk> copumpkin: yeah. 'lambda the ultimate back propagator' and all that
11:28:15 <ddarius> A tower of tangent covectors?  V -o V -o V -o R ?
11:30:10 <edwardk> ddarius: thats the general idea, though i'm not sure i grok your notation. the idea being to be able to do the same kind of trick that has been done with forward AD to generate a tower of derivatives, but apply it to reverse ad
11:30:37 <illissius> is dependent types roughly what C++ would have if you could use runtime values in templates and weren't restricted to ints?
11:30:38 <ddarius> edwardk: I'm using -o for the set of linear transformations.
11:30:54 <soupdragon> illissius: not really a good way to think about it
11:31:10 <soupdragon> illissius: better to start with typed lambda calculus rather than C++
11:31:10 <ddarius> Or rather the linear space of linear transformations.
11:31:48 <illissius> but that's hard work! (:
11:32:00 <edwardk> part of it is i just need to read the other literature in this space. ;) i finally grokked pearlmutter and siskind's 'ultimate backpropagator' paper and got this far
11:32:36 <CVirus> What is the equivalent to the interactive :type function if I'm writing a script ?
11:33:15 <aavogt> CVirus: your editor can perhaps load up ghci and ask it :type?
11:33:31 <c_wraith> types are elided at compile-time.
11:33:33 <edwardk> but i'd like a simple model that lets me compute the hessian, etc. using the same framework i'm able to use to find the jacobian
11:33:39 <copumpkin> illissius: dependent types is what haskell would have if the types could cross the ::
11:33:43 <ddarius> Well, if a tower of cotangents is a covector of covectors of covectors ... then V -o V -o V -o R is VвЉ—VвЉ—V-oR, so the infinite case would seem to be Stream V -o R or something like that.
11:34:07 <edwardk> that sounds about right
11:34:38 <edwardk> that fits with my intuition that i should basically be able to replace the 'replay' of my tape with a replay of the tape in the forward mode AD tower
11:35:45 <CVirus> aavogt: I'm writing a script that has 2 functions ... the second function is supposed to return the type of the first function
11:36:27 <edwardk> what i have now is data RAD s a = RAD (Tape a (RAD s a)); data Tape a t = C a | V a Int | U a a t | B a a a t t  -- for constants, input variables, the result of a unary function with its single off axis jacobian entry and the reference to the input variable, or a binary function with the two off axis entries in the jacobian and inputs
11:36:41 <edwardk> i conjecture i should be able to replace that with
11:37:00 <edwardk> data Tape a t = C a | V a Int | U a [a] t | B a [a] [a] t t
11:37:17 <edwardk> but i'm probably being naive =)
11:37:29 <copumpkin> Baaatt!!
11:37:56 <edwardk> and s/data RAD/newtype RAD/
11:39:34 <edwardk> so i suppose as a first step i should work out how to use my RAD solver to find a hessian for a given function, and go from there
11:39:59 <Jedai> CVirus: like typeOf or do you mean that the first function has type "a -> b" and the second "c -> (a -> b)" of something else ?
11:40:33 <edwardk> though i suppose in theory i could just use RAD s (RAD t a))
11:41:28 <ddarius> Yeah, it's the Jacobian of the Jacobian?
11:41:46 <edwardk> sounds about right, and the math seems to check =)
11:42:29 * sizur wants to share his happiness about zsh discovery with the best # he knows.
11:42:54 <Makoryu> sizur: Oh?
11:43:22 <Jedai> sizur: what's the features that really change your life compared to bash ?
11:43:45 <sizur> bash to zsh is like unary counting to multivariable calculus
11:44:06 * wli is all about zsh
11:45:08 <sizur> i trieds zsh today and switched right away.  so far tab completing and globs blow bash away
11:45:09 <shapr> Are there any Haskell web libs that can automagically template up a combobox or ajax pulldown from a Data.Tree?
11:45:20 <copumpkin> I used zsh like bash and it was no different!
11:45:22 <copumpkin> ;)
11:46:10 <cytzol> When people ask me what's good about zsh I can't think of anything, because it's made me take things like globbing and tab completion for everything and overall prettiness for granted
11:46:19 <sizur> more intuitive for loop in shell i also a win, although minor
11:46:48 <shapr> So, no one does web page templating with Haskell? :-/
11:46:51 <cytzol> Then I tried to write a shell and found out how irksome the whole system can be :)
11:47:15 <ddarius> Jacobian of the gradient though I guess you could view the gradient as a Jacobian.  Let's just say the differential of the differential.
11:47:39 * ddarius has never written a web page with Haskell.
11:48:05 <Jedai> shapr: I don't know much about this world but recently you had haml which seems interesting (compile-time checked templates)
11:48:22 <shapr> Hm, good point! I'll check out haml.
11:48:45 <Ke> how would I debug a cabalized program
11:48:59 <gwern> Ke: how would you debug any haskell program?
11:49:27 <Ke> check individual functions in ghci
11:49:46 <shapr> Ke: Write QuickCheck properties?
11:49:49 <gwern> go thou and do likewise
11:50:57 <shapr> Has anyone used the hamlet hackage?
11:51:29 * ddarius wishes making marks over characters was readily doable.
11:51:40 <Ke> there is no way to just get some breakpoints from binary
11:51:42 <Ke> ?
11:52:53 <Ke> well moderately ill-defined, but still
11:53:36 <shapr> Debug.Trace?
11:53:37 <shapr> @quote trace
11:53:37 <lambdabot> Babelfish says: And there you travel: a beam tracer! Naturally, there are many things that ought to be amend.
11:53:39 <shapr> hmm
11:53:41 <shapr> @quote debug
11:53:41 <lambdabot> lennart says: I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
11:53:41 <lambdabot> useful for functional code
11:53:45 * shapr shrugs
11:53:49 <shapr> @quote oasis
11:53:50 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
11:53:51 <shapr> aha
11:54:04 <CVirus> Jedai: what is typeOf .. I'm new to haskell
11:54:47 <Jedai> CVirus: Then don't worry about it (it's one of the tools that can be used to do some reflection in Haskell)
11:54:50 <Ke> well if you wan't to locate a problem fast, what would you suggest
11:54:55 <sm> shapr: there's formlets.. I think that's about the closest to what you want (and it's not very close)
11:55:06 <Ke> if you don't know the source at all
11:55:20 * hackagebot happstack-util 0.5.0.2 - Web framework  http://hackage.haskell.org/package/happstack-util-0.5.0.2 (JeremyShaw)
11:55:20 <Ke> =oP
11:55:33 <sm> or maybe that's way overkill; worth a look anyhow
11:55:50 <ddarius> shapr: Sounds like you have a project.
11:56:08 * sm will be user #1
11:56:48 <shapr> ddarius: Yeah, it's cute..
11:57:20 <shapr> ddarius: It's very simple, it's part craigslist, part freecycle, part ebay...
11:58:29 <shapr> ddarius: The idea being that you post a list of hardware/software that you own and don't use. Then if somene else wants or needs that, they can request it.
11:58:47 <shapr> and you can either look at their list of hardware and barter for it, or they can just pick it up
11:58:53 <sm> a specialised freecycle ?
11:58:56 <shapr> Yup
11:59:02 <sm> oh, you said that
11:59:10 <shapr> Sadly, geekswap.com is taken
11:59:20 * hackagebot happstack-data 0.5.0.2 - Happstack data manipulation libraries  http://hackage.haskell.org/package/happstack-data-0.5.0.2 (JeremyShaw)
11:59:22 * hackagebot happstack-ixset 0.5.0.2 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/happstack-ixset-0.5.0.2 (JeremyShaw)
11:59:27 <Ke> shapr: by description Debug.Trace seems to be fprintf(stderr..., but I bet it is not that useless
11:59:35 * ddarius rented a movie a week ago but keeps getting distracted by books and research papers.
11:59:41 <shapr> Whether or not the website is ever used, it would be fun just to build it in Haskell to learn the state of the art.
11:59:52 <Ke> shapr: ie. wth is the String parameter
12:00:05 <copumpkin> ddarius: what movie?
12:00:21 <copumpkin> geekspin
12:00:46 <shapr> copumpkin: haha
12:00:58 <shapr> copumpkin: Also taken
12:01:02 <copumpkin> damn
12:01:02 <ddarius> copumpkin: "How I Got Lost"
12:01:21 * hackagebot happstack-state 0.5.0.2 - Event-based distributed state.  http://hackage.haskell.org/package/happstack-state-0.5.0.2 (JeremyShaw)
12:01:23 * hackagebot happstack-server 0.5.0.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-0.5.0.2 (JeremyShaw)
12:01:25 * hackagebot happstack 0.5.0.2 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-0.5.0.2 (JeremyShaw)
12:02:15 <Ke> shapr: nvm. found a tutorial
12:02:48 <makmanalp> does anyone know where the convention of calling the head x and the tail xs comes from?
12:02:59 <makmanalp> etymologically?
12:03:27 <mauke> you might be overthinking this
12:03:50 <copumpkin> from the list monster, I think: http://learnyouahaskell.com/listmonster.png
12:04:07 <mauke> that doesn't even contain x
12:04:12 <makmanalp> mauke: i'm just curious
12:04:18 <copumpkin> oh
12:04:21 <copumpkin> I thought you meant head and tail
12:04:22 <makmanalp> copumpkin: what mauke said :P
12:04:32 <copumpkin> :(
12:04:37 <makmanalp> head and tail are already in lispish languages btw
12:04:45 <makmanalp> or un the unices
12:04:45 <copumpkin> yeah, I know
12:04:48 <ddarius> makmanalp: item:items
12:04:52 <mauke> car/cdr
12:04:56 <companion_cube> makmanalp: just from the fact that the most basic varname is "x", and "xs" stands for "many x"
12:05:26 <makmanalp> companion_cube: oh, that makes a lot of sense, x is a pluralizer and it stresses the fact that the list is homogenous in type
12:05:47 <companion_cube> you mean, 's' is a pluralizer
12:06:01 <makmanalp> er, sorry, yes
12:06:09 <soupdragon> pluralizer is a word?
12:06:18 <makmanalp> soupdragon: well, it should be!
12:06:21 <mauke> it's a song by britney spears, I think
12:06:22 <companion_cube> but imho it's just "i've got one x and then many other x's"
12:06:35 <soupdragon> didn't know britney spears was into linguistics
12:06:48 <companion_cube> soupdragon: there are not only native english speakers here
12:07:01 <soupdragon> companion_cube: what do you mean by that?
12:07:19 <companion_cube> just that some people here do not speak english perfectly (me, for example)
12:07:24 <soupdragon> so?
12:07:34 <companion_cube> Nothing
12:07:46 <soupdragon> I'm not criticizing you, If you took it that way
12:07:59 <soupdragon> I might be a native speaker but there are still words I don't know
12:08:44 <companion_cube> uh, ok, i thought you were using irony :)
12:08:52 <companion_cube> jsut never mind then :)
12:10:40 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25535#a25535 -- does this seem sensible?
12:10:50 <scotty> I'm doing this: adjustAll :: Ord k => (a -> a) -> [k] -> Map k a -> Map k a
12:10:50 <scotty> adjustAll f [] mp = mp
12:10:52 <mreh> it's my proposal for a ArrowRandom
12:10:55 <scotty> Whoops
12:11:05 <scotty> http://pastebin.com/WyYjNcQ4
12:11:12 <scotty> Isn't there a better way?
12:11:28 <mreh> scott: fmap?
12:11:47 <mreh> @instances Functor
12:11:48 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:11:58 <mreh> hmm, I'm sure Map is
12:12:16 <mreh> @instances-importing Data.Map Functor
12:12:17 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Map k, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:12:23 <mreh> yeah
12:12:34 <mreh> that's what you need
12:12:58 <scotty> I'm not familiar with this.  Know any good guides online I could read?
12:13:05 <copumpkin> mreh is an objectivist
12:13:07 <mreh> @where functor
12:13:07 <lambdabot> I know nothing about functor.
12:13:13 <copumpkin> so much rand in that module
12:13:22 <mreh> lol wut
12:13:23 <scotty> lol
12:13:30 <scotty> He shares my sentiments.
12:13:33 <mreh> very hamusing
12:14:56 <scotty> Maybe this?: http://en.wikibooks.org/wiki/Haskell/Applicative_Functors#Functors
12:15:12 <JNB> Hello folks, im having trouble with some Haskell IDEs (HEAT and WinHugs). Its a simple enough problem, im just unfamiliar with them... id preferably like to use HEAT... i can enter single statements and have them evaluated, but i am stuck when trying to  define a function then use one...
12:15:21 <mreh> runRand for a RandArrow, which is basically the Kleisli Arrow of MonadRandom, only seems useful with the signature (RandomGen g => g -> (RandArrow g b c) -> b -> c
12:15:59 <JNB> In HEAT i can enter the function defginition, click compile... and well it compiles, but theres no apparent out put, and i cant invoke any of the functions
12:16:12 <ddarius> mreh: Are there any examples of that class that aren't Kleisli arrows?
12:16:24 <zcrar70> I just wrote my first haskell program: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25534
12:16:37 <mreh> ddarius: which class ArrowRandom?
12:16:38 <zcrar70> I was wondering whether anyone would mind having a look?
12:17:00 <MrFenix> hi.. can anyone help me? why does show shredder UTF-8 to \SomeNumber?
12:17:09 <zcrar70> I'm worried that I didn't do a great job of separating the pure from the unpure
12:17:35 <mreh> zcrar70: looks good to me
12:18:09 <MrFenix> > show "Ein Umlaut: Гј"
12:18:10 <lambdabot>   "\"Ein Umlaut: \\252\""
12:18:14 <ddarius> mreh: Yes.
12:18:29 <mreh> when you're working with the file system you have no choice but to write impure code
12:18:41 <mreh> ddarius: no, this is the first instance of its kind
12:18:46 <mreh> that I know of
12:18:58 <zcrar70> mreh: yes, thanks - I was just worried that the two were getting too intertwined.
12:19:07 <mreh> there's only one instance of MonadRandom too for example
12:19:25 <ddarius> mreh: If you can't think up an example that isn't a Kleisli arrow, then why bother using Arrows at all?  Just use a monad.
12:19:42 <zcrar70> mreh: thanks for taking a look, at least now I know I'm not completely off
12:19:53 <ddarius> zcrar70: Your code looks like a Java programmer wrote it.
12:19:56 <mreh> ddarius: ArrowRandom isn't a monad, it's an Arrow
12:20:11 <mreh> RandA is a Monad
12:20:12 <zcrar70> ddarius: well, that's what I was worried about :-)
12:20:21 <zcrar70> ddarius: any particular suggestions?
12:20:29 <mreh> s/ArrowRandom/RandomArrow
12:20:47 <ddarius> mreh: It's an Arrow that is equivalent to a monad.
12:21:34 <mreh> ddarius: it's an ArrowTransformer
12:23:03 <mreh> I don't know, Cale suggested I write RandA as a nice addition, blame him :)
12:23:36 <ddarius> zcrar70: Use let less, name less intermediates.  Don't put local type annotations unless they are necessary.  Perhaps use more data structures.
12:23:39 <diego__> i made this function to convert from decimal to binary, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25537 the problem is that it doesn't return correct with r 0, doing the less changes possible, how to solve it
12:24:03 <zcrar70> ddarius: many thanks
12:25:54 <MrFenix> diego__: r 0 = 0:[]
12:26:15 <ddarius> mreh: If RandomArrow is an instance of ArrowApply, then it is a monad.
12:26:17 <MrFenix> diego:  or just  r 0 = [0]
12:26:46 <mreh> ddarius: do you think the code is useless?
12:27:36 <MrFenix> > show "MotГ¶rhead"
12:27:37 <lambdabot>   "\"Mot\\246rhead\""
12:27:38 <diego__> but that appends a final zero
12:27:49 <MrFenix> grr. I hate utf
12:27:50 <diego__> for example, r 2 gives [0, 1, 0]
12:27:50 <ddarius> mreh: The class might not be useless if you can think of an instance of it that is not equivalent to a monad, but if I know that something is a monad, it's usually much more convenient to use it as a monad and if I really want to use it as an arrow, that's what Kleisli is for.
12:28:05 <diego__> initial zero
12:28:43 <mreh> it's nice to be saved the boilerplate sometimes
12:29:55 <aristid> > show "вЂЌMotГ¶rhead"
12:29:56 <lambdabot>   <no location info>:
12:29:57 <lambdabot>      lexical error in string/character literal at chara...
12:30:04 <aristid> heh.
12:31:30 <glguy> zcrar70: (length (filter (\n -> n == True) changedSubfolders)) > 0  ---->  or changedSubfolders
12:31:32 <ddarius> aristid: That's due to lambdabot.
12:31:34 <glguy> :t or
12:31:35 <lambdabot> [Bool] -> Bool
12:32:03 <glguy> :t not . null
12:32:04 <lambdabot> forall a. [a] -> Bool
12:32:59 <aristid> ddarius: it doesn't support unicode?
12:33:40 <glguy> zcrar70: when you find yourself doing ((> 0) . length . (filter (\i -> isSuffixOf i (map toLower input)))) jpegExtensions), check out this function
12:33:42 <glguy> :t any
12:33:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:34:22 <glguy> any (`isSuffixOf` map toLower input) jpegExtensions
12:34:28 <ddarius> aristid: The @run feature doesn't handle Unicode properly on input.  Try typing that code into GHCi.
12:35:18 <MrFenix> diego__: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25537#a25538
12:36:11 <zcrar70> glguy: thanks very much - the any function does indeed look like exactly what I want :-)
12:36:13 <diego__> ahh, :) thank you!, that will do it
12:36:28 <MrFenix> GHCi, version 6.12.1: http://www.haskell.org/ghc/  :? for help
12:36:28 <MrFenix> Prelude> show "MotГ¶rhead"
12:36:29 <MrFenix> "\"Mot\\246rhead\""
12:37:41 <Jedai> MrFenix: Yes, that's normal
12:37:46 <aristid> ddarius: well maybe the zero-width joiner is illegal haskell anyways?
12:38:01 <ddarius> "AB\&C"
12:38:04 <ddarius> > "AB\&C"
12:38:05 <lambdabot>   "ABC"
12:38:51 <MrFenix> this drives me nuts... I'm developing a web application and everything works; except that unicode shredders my json databases with gibberish
12:39:25 <zcrar70> glguy: I just understood your first suggestion now too - thanks very much! That looks a lot more elegant.
12:39:26 <glguy> Prelude> Codec.Binary.UTF8.String.encodeString "MotГ¶rhead"
12:39:27 <glguy> "Mot\195\182rhead"
12:40:13 <edwardk> ddarius: hrmm looks like http://www.sophia.inria.fr/tropics/slides/EdfCea05.pdf recommends against my knee-jerk guess at how to calculate higher order derivatives in reverse mode (slide 51 and the few thereafter)
12:40:15 <idnar> the JSON library should take care of that though, surely?
12:41:14 <glguy> I'd be somewhat surprised if the JSON library did a UTF8 pass
12:42:01 <MrFenix> the json library (Text.JSON.Generic) does not care about it at all.. it takes haskell data and converts to strings
12:42:43 <MrFenix> Text.JSON.Generic> encodeJSON "MotГ¶rhead"
12:42:43 <MrFenix> "\"Mot\246rhead\""
12:43:31 <ddarius> edwardk: So you have to look up that piggy back thing?
12:43:47 <MrFenix> Prelude Text.JSON.Generic> putStrLn $ encodeJSON "MotГ¶rhead"
12:43:47 <MrFenix> "MotГ¶rhead"
12:43:50 <MrFenix> -_-
12:44:37 <glguy> 6.12's putStrLn knows about utf8
12:44:52 <edwardk> ddarius: i'm looking at slides 54 .. 58 of the deck i just linked to above, trying to figure out what is being said in sufficient detail to know if it makes sense given my implementation
12:44:54 <Jedai> MrFenix: And that's not correct behaviour ? JSON don't understand \246 ?
12:45:25 <Jedai> s/don't/doesn't/
12:45:44 <glguy> \246 is the unicode codepoint
12:46:05 <c_wraith> Jedai: correct behavior is to use \u escapes for anything outside of ascii
12:46:06 <glguy> you have to convert it to utf8 before you put it on the wire, but GHC's Handles now do that
12:46:25 <glguy> Oh, JSON doesn't do UTF-8?
12:46:54 <c_wraith> it's not supposed to.
12:47:06 <glguy> I didn't realize it was ASCII only
12:49:05 <glguy> json.org/fatfree.html says it uses UTF-8
12:49:50 <glguy> but I don't know that that is necessarily "authoritative"
12:50:16 <MrFenix> That's how my database looks like after writes
12:50:16 <MrFenix> [{"matnr":42313,"name":"Lemmy","vorname":"MotГѓВ¶rhead","mail":"Lemmy.MotГѓВ¶rhead@tu-dortmund.de"}]
12:50:38 <duairc> Hey, I'm pretty new to Haskell (at least in terms of actually writing stuff with it), and I have a datatype with a lot of fields and it seems like a good idea to use records for this but I'm a little apprehensive about using them, I'm not sure why
12:50:52 <Jedai> MrFenix: That looks more like a problem with the display
12:50:58 <edwardk> gah, data.graph doesn't have a bfs in it. =/
12:51:23 <Jedai> MrFenix: like it isn't aware your file is in unicode
12:51:34 <duairc> I guess it feels like if I use records for this datatype, then I should use them for my other ones too, or at least it's arbitrary what ones I use them for and what ones I don't and I'm not really sure what to do
12:51:35 <Jedai> in utf8 rather
12:51:36 <glguy> MrFenix: looks like the data was correctly UTF8 encoded on its way into your database but that you aren't decoding the utf8 when you print it back
12:51:39 <c_wraith> hmm.  http://www.ietf.org/rfc/rfc4627.txt is authoritative.  it looks like unicode as utf8 is fine
12:52:52 <edwardk> ugh, and it appears that data.graph internally uses lists with ++ a lot rather than difference lists
12:53:59 <timcowlishaw> Hey all, would any of you be able to spare a sec to help a beginner with a bug? The line 'let (matched:rest) = suf' is throwing an Irrefutable pattern failed error in this code, and I'm struggling to understand why: http://gist.github.com/403112
12:54:51 <Jedai> timcowlishaw: it means that suf is an empty list in a case where you need matched or rest in your code
12:55:04 <timcowlishaw> aaah thanks @Jedai
12:55:45 <Jedai> timcowlishaw: you should probably do a case suf of [] -> ... ; matched:rest -> ...
12:55:56 <MrFenix> I have tried to copy the json file to my computer and displayed it in a text editor capable of unicode and different other encodings ... allways the same
12:56:18 <timcowlishaw> aah yep, that makes sense
12:56:27 <MrFenix> I've even tried to use System.IO.UTF8.writeFile instead of Prelude - same result
12:56:30 <Jedai> MrFenix: capable of unicode doesn't mean "interpreting files as utf8 by default"
12:56:32 <c_wraith> MrFenix: "unicode" is not an encoding.
12:56:45 <timcowlishaw> however, how come ghci doesn't complain at this, in that case  'let head:tail = []'?
12:57:05 <MrFenix> I've used KWrite and checked UTF-8 as encoding while opening
12:57:14 <glguy> timcowlishaw: because you didn't try and use head or tail
12:57:20 <Jedai> timcowlishaw: probably because you don't need head or tail later on
12:57:52 <timcowlishaw> aah sorry - that's not quite what i meant, my bad - i didn't mean the head and tail funcitons, was just using htem as variable names :-)
12:57:52 <Jedai> timcowlishaw: given that haskell is lazy, it won't even try this pattern matching if it don't need to
12:58:01 <glguy> > let x : xs = [] in ()
12:58:02 <lambdabot>   ()
12:58:07 <glguy> > let x : xs = [] in x
12:58:08 <lambdabot>   *Exception: <interactive>:1:137-147: Irrefutable pattern failed for pattern...
12:58:14 <Ke> code.haskell.org down again
12:58:14 <Jedai> timcowlishaw: that's what I and glguy means to
12:58:23 <Jedai> too
12:58:27 <aavogt> > case [] of x:xs -> ()
12:58:28 <lambdabot>   *Exception: <interactive>:1:133-153: Non-exhaustive patterns in case
12:58:32 <timcowlishaw> aha!
12:58:34 <timcowlishaw> yes
12:58:37 <MrFenix> my environment is set to de_DE@utf-8  and everything else including special characters works
12:58:39 <timcowlishaw> of course
12:58:47 <aavogt> patterns are strict except in let
12:58:49 <timcowlishaw> thank you both very much, that's crystal clear now
12:58:57 <Jedai> aavogt: and with ~
12:59:04 <Jedai> aavogt: and where
12:59:07 <aavogt> that just complicates things
12:59:12 * aavogt doesn't use those :)
12:59:40 <duairc> Sorry to try to get attention again, but did anybody see my messages above about records?
13:00:03 <MrFenix> duairc: whats wrong about records?
13:00:16 <Jedai> aavogt: I would rather say that patterns are strict in function parameters (except if explicitly made lazy with ~) and case...of... but lazy in let... and where...
13:00:44 <aavogt> strict in lambda
13:01:12 <Jedai> duairc: Records make sense when you have a lot of fields with different semantics
13:01:18 <Cale> The patterns which start with ~ are not the only irrefutable ones :)
13:01:28 <aavogt> newtypes?
13:01:34 <Cale> There's also simple variables
13:01:44 <Cale> x is an irrefutable pattern
13:01:51 <aavogt> underscores
13:01:59 <Cale> and yeah, underscores :)
13:02:28 <Jedai> duairc: mainly they make sense when they're useful (NB: records in Haskell are not as awesome as they could be, there are some package to improve their usefulness in deeply nested modification cases (like fclabels))
13:02:44 <duairc> Jedai: Well, I have about 10 fields, that all do different sorts of things, so I think records make sense for that
13:02:54 <Jedai> duairc: Probably :)
13:03:04 <aavogt> Jedai: the official term is apparently labeled fields now
13:03:21 <duairc> It's just now that I'm using records in this module, I'm wondering if I should use them for a similar datatype that has only 4 fields, and I'm just not really sure where to make the distinction
13:03:22 <aavogt> since records sort of imply features that are absent
13:04:22 <duairc> I guess it's not hugely important, it's just the syntax looks so different that it feels like I'm implying that the 10-field datatype is somehow completely different to the rest of the datatypes and it feels wrong to do that
13:04:32 <Jedai> aavogt: That makes sense
13:04:48 <aristid> @pl f x (x', y) = x == x'
13:04:49 <lambdabot> f = (`ap` snd) . (. fst) . (const .) . (==)
13:04:55 <aristid> oO
13:05:07 <jesusabdullah> converts to pointless?
13:05:15 <Jedai> duairc: Not really, "records" (or labeled fields to be PC) in Haskell are just sugar around normal algebraic datatypes
13:05:18 <aristid> yes, but also sometimes generates weird code
13:05:26 <jesusabdullah> BUT HASKLE THERE ARE DOTS NAOW
13:05:34 <jesusabdullah> Fun :D
13:05:46 <aristid> jesusabdullah: but no points
13:05:47 <danharaj> Haskell needs real records :|
13:05:57 <aristid> danharaj: just use HList :P
13:06:02 <Jedai> duairc: it's mainly an issue of convenience
13:06:03 <jesusabdullah> aristid: touche :D
13:06:16 <duairc> Jedai: I know it's just sugar, but just when I'm defining the datatype, it LOOKS different. And now I have sugar for updating fields for some datatypes, but not for others
13:06:35 <danharaj> Wouldn't heterogeneous lists need template haskell?
13:06:37 <duairc> Yeah, I understand it's just convenience, but it just feels that I'm losing some... symmetry or something. It's not a big deal really
13:06:44 <jesusabdullah> duairc: Could you just not use the sugar?
13:06:45 <Jedai> aristid: There's "has" for a more lightweight approach now, though I don't know how convenient it really is (never tried it)
13:07:01 <jesusabdullah> I'm still waiting for someone to invent syntactic stevia
13:07:18 <aristid> Jedai: has?
13:07:18 <duairc> I dunno, I'll live :)
13:07:21 <aristid> @has
13:07:22 <lambdabot> Maybe you meant: ask faq map what
13:07:45 <c_wraith> @hackage has
13:07:45 <lambdabot> http://hackage.haskell.org/package/has
13:08:04 <Jedai> aristid: it's the name of the package
13:08:19 <duairc> Also, how does the module system interact with the records? If you want to export the getter functions, do you have to list them all or can you somehow say "export all the getters for this datatype"? What about the updating syntax? Does that ever get exported?
13:08:31 * aavogt doesn't understand what has has over HList
13:08:31 <aristid> Jedai: what a wonderful package name :P
13:08:40 <aristid> aavogt: being simpler?
13:09:05 <Jedai> aavogt: I think the question is more in what it don't have over HList
13:09:07 <aavogt> user code is more or less the same
13:09:55 <aristid> i guess there's no reason not to use HList then
13:10:26 <Jedai> ok, my sentence is confusing (or just plain wrong), I meant to say that it is less powerful/generalist so it might be simpler but as I said I never used it so...
13:14:47 <aavogt> aristid: HList is a bit more general in that it's labels don't have types associated with them
13:15:41 <aavogt> so you can have a record    R { weight :: Double }, and R2 { weight :: Int }  using HList, but not `has'
13:16:23 <danharaj> <=< ????
13:16:32 <chrisdone> :t (<=<)
13:16:33 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:16:41 <mreh> let me get this right, importing a module will import all the instance methods into the name space?
13:16:42 <Cale> danharaj: Kleisli composition
13:16:48 <danharaj> Cale: What to the what now
13:16:54 <copumpkin> kleisli mposition
13:17:14 <mreh> Kleisli Arrows!
13:17:17 <mreh> \o/
13:17:22 <danharaj> :t (>=>)
13:17:23 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:17:26 <chrisdone> :t readFile >=> putStrLn
13:17:27 <lambdabot> FilePath -> IO ()
13:17:47 <Cale> danharaj: How much category theory do you know?
13:17:48 <edwardk> duairc: you can export all of the getters for a data type just by saying module Foo (DataType(..)) where
13:17:54 <edwardk> duairc: that also exports the constructors
13:17:58 <Cale> (I could explain that name more if you do :)
13:18:18 <danharaj> Cale: I don't know what a kleisli category is. Can you define >=> in terms of >>=?
13:18:27 <copumpkin> yeah
13:18:33 <Cale> (f >=> g) x = f x >>= g
13:18:34 <Twey> @src (>=>)
13:18:35 <lambdabot> Source not found. There are some things that I just don't know.
13:18:41 <danharaj> ah ok
13:18:41 <Twey> Huh.
13:18:44 <edwardk> @source (>=>)
13:18:44 <lambdabot> (>=>) not available
13:18:57 <Twey> What's the difference?
13:19:02 <Cale> (f <=< g) x = f =<< g x
13:19:15 <chrisdone> flip
13:19:53 <Twey> (f >=> g) x = (g <=< f) x = f x >>= g
13:20:30 <danharaj> would you be able to drop the point? (f <=< g) = (f =<<) . g
13:21:09 <Twey> Yep
13:21:28 <Twey> (>>= g) . f, equivalently
13:21:57 <chrisdone> can you help me define an idea for a monad?
13:21:57 <chrisdone> a >> return y >>= b  =  case a >> yield x >>= b of
13:21:57 <chrisdone>                           (x,cont) -> cont y
13:22:37 <aristid> @src partition
13:22:38 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
13:22:38 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
13:22:38 <lambdabot>                               | otherwise = (ts, x:fs)
13:22:41 <chrisdone> i want a monad in which i have `yield' which can return a value and the rest of the computation, and then resume the computation with a new value
13:23:19 <chrisdone> similar to callCC $ \yield -> a >> yield x >>= b, except that only returns a value, not the rest of the computation (i.e. (>>=b))
13:25:02 <glguy> ChoiceT
13:25:10 <chrisdone> e.g. i'm running a monad computation, and right in the middle something's missing, so it returns a value early with some status saying GetSuchAndSuchInfo, and a function to resume once i have that info
13:25:20 <chrisdone> ChoiceT, huh? /me googles
13:25:34 <glguy> oh, if you want to resume back with that value then you want delimited continuations
13:26:02 <glguy> chrisdone: you might read about Oleg's ZipperFS, it uses continuations like this to simulate system calls
13:26:23 <chrisdone> ahh thanks!!
13:34:37 <Peaker> *huge* changes to my UI framework, once it compiled - it worked :)
13:34:43 <aristid> @src foldl
13:34:43 <lambdabot> foldl f z []     = z
13:34:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:35:01 <aristid> @src foldr
13:35:01 <lambdabot> foldr f z []     = z
13:35:01 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:35:16 <chrisdone> Peaker: what's all that funky ~~> stuff from conal? i remember it from ages ago but don't remember what it's called. got a link?
13:36:08 <Peaker> chrisdone, I dont remember, but the idea is that like you have: first, second, and ***:  f *** g = first f . second g    similarly you have: result (.), argument (flip (.)), and (~>).  f ~> g = argument f . result g
13:36:56 <Peaker> chrisdone, with infixr 2 (~>) you can chain them:   f ~> g ~> h ~> id ~> i    applies f,g,h,id,i  on the respective values in the type (f -> g -> h -> a -> i)
13:37:12 <Makoryu> > foldr f z x
13:37:13 <lambdabot>   Couldn't match expected type `[a]'
13:37:13 <lambdabot>         against inferred type `SimpleRef...
13:37:16 <Makoryu> Dang
13:37:29 <Makoryu> Oh right
13:37:33 <Makoryu> > foldr f z [1..5]
13:37:34 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
13:38:23 <HugoDaniel> hi
13:38:36 <Makoryu> > foldr ((+) . const 1) 0 "SPACE PIZZA" :: Expr
13:38:38 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + 0))))))))))
13:38:46 <chrisdone> Peaker: ohhh. i remember. fancy
13:39:06 <chrisdone> Peaker: kind of like reverse of chaining <*>
13:39:33 <chrisdone> or not actually
13:39:35 <chrisdone> let me try it
13:41:36 <MrFenix> fixed my UTF problem
13:41:36 <chrisdone> ohhh
13:41:44 <chrisdone> it's like a function wrapper
13:42:30 <MrFenix> it was Network.CGI - I switched to Web.Encodings to decode post requests and now it works.
13:43:06 <mreh> are fundeps in multiparameter type classes a GHC extension?
13:43:23 <mreh> oh, found it
13:48:57 <Jedai> > ((+1) ~> (*2) ~> id) (+) 5 1
13:48:57 <lambdabot>   Not in scope: `~>'Not in scope: `~>'
13:50:18 <Jedai> > let result = (.); arg = flip (.); f ~> g = argument f . result g; infixr 2 (~>) in ((+1) ~> (*2) ~> id) (+) 5 1
13:50:19 <lambdabot>   <no location info>: parse error on input `('
13:50:29 <Jedai> > let result = (.); arg = flip (.); f ~> g = argument f . result g in ((+1) ~> (*2) ~> id) (+) 5 1
13:50:30 <lambdabot>   Not in scope: `argument'
13:50:36 <Jedai> > let result = (.); arg = flip (.); f ~> g = arg f . result g in ((+1) ~> (*2) ~> id) (+) 5 1
13:50:37 <lambdabot>   No instance for (GHC.Num.Num (a -> a1))
13:50:37 <lambdabot>    arising from a use of `e_11251' ...
13:50:45 <Jedai> > let result = (.); arg = flip (.); f ~> g = arg f . result g in ((+1) ~> ((*2) ~> id)) (+) 5 1
13:50:47 <lambdabot>   8
13:51:46 <Jedai> Very cute... and allows to quite nicely compose multi-argument functions
13:53:43 <aristid> which is the canonic multi map data structure?
13:55:22 <chrisdone> :t id ~> id
13:55:23 <lambdabot> Not in scope: `~>'
13:55:27 <ClaudiusMaximus> aristid: i've used (Map k [v]) before
13:55:47 <chrisdone> @let (~>) = let result = (.); arg = flip (.); f ~> g = arg f . result g in (~>)
13:55:48 <lambdabot>  Defined.
13:55:50 <chrisdone> :t id ~> id
13:55:51 <lambdabot> forall a a1. (a -> a1) -> a -> a1
13:56:04 <chrisdone> :t id ~> (id ~> id)
13:56:05 <lambdabot> forall a a1 a11. (a -> a1 -> a11) -> a -> a1 -> a11
13:56:28 <chrisdone> now that is brilliant
13:56:51 <chrisdone> :t (id ~> id) . (id ~> id)
13:56:52 <lambdabot> forall a a1. (a -> a1) -> a -> a1
13:57:22 <chrisdone> hehe, what is that idempotency?
13:57:26 <chrisdone> no
13:58:00 <aristid> ClaudiusMaximus: hmm
13:58:01 <chrisdone> f(f) = f, what do you call that
13:58:18 <chrisdone> identity on itself?
13:58:21 <Draconx> chrisdone, a fixed point?
13:58:44 <dmwit> :t id :: (a -> a1 -> a11) -> a -> a1 -> a11 -- why bother with all the fancy notation?
13:58:46 <lambdabot> forall a a1 a11. (a -> a1 -> a11) -> a -> a1 -> a11
13:59:05 <chrisdone> dmwit: i'm just looking at how ~> works
13:59:15 <ClaudiusMaximus> f . f = f   ==  f is a projection (iirc)
14:00:02 <dmwit> f . f = f is idempotency
14:00:03 * copumpkin ponders removing #haskell-in-depth from his autojoin list
14:00:13 <dmwit> f . f = f is not the same as f(f) = f
14:00:22 <chrisdone> dmwit: yeah
14:04:01 <chrisdone> > ((*2) ~> ((+10) ~> ((*3) ~> id))) (\a b c -> a + b * c :: Int) 1 2 3
14:04:02 <lambdabot>   110
14:04:13 <HugoDaniel> hey chris
14:04:14 <HugoDaniel> :D
14:04:20 <chrisdone> hey hey
14:04:33 * chrisdone high fives hugo
14:04:43 <jutaro> Hey hugo, hey chris
14:04:45 <copumpkin> :t liftA2 (.)
14:04:46 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
14:04:48 <HugoDaniel> hey jutaro
14:05:03 <copumpkin> :t liftA2 (Prelude..)
14:05:04 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
14:05:36 <HugoDaniel> what is ~> ?
14:06:10 <chrisdone> result = (.)
14:06:10 <chrisdone> arg = flip (.)
14:06:10 <chrisdone> f ~> g = arg f . result g
14:06:14 <Cale> http://www.toothpastefordinner.com/051610/strongadoodle.gif  -- lol
14:06:27 <HugoDaniel> i wanted to talk to you about tryhaskell :)
14:06:49 <chrisdone> dmwit: i think that's pretty cool (above)
14:06:51 <chrisdone> HugoDaniel: oh yeah?
14:06:57 <HugoDaniel> yeahh :)
14:07:11 <HugoDaniel> you are sending the js console commands through JSON to the server, right ?
14:07:35 <chrisdone> yep
14:07:44 <chrisdone> you saw the blog post right?
14:07:51 <HugoDaniel> no
14:07:53 <HugoDaniel> what blog post ?
14:08:00 <HugoDaniel> i looked at the js console code
14:08:09 <chrisdone> http://chrisdone.com/posts/2010-04-05-haskell-json-service-tryhaskell.html
14:08:15 <HugoDaniel> ohh, very nice
14:08:27 <HugoDaniel> hmm
14:08:47 <HugoDaniel> so anyways, the server is just mueval runing inside a cgi interpreter and json unwrapper, right ?
14:08:52 <chrisdone> so writing your own try haskell you just need a html page
14:09:02 <chrisdone> yeah
14:09:39 <HugoDaniel> hmm
14:10:01 <HugoDaniel> i wanted to have mueval runing inside my monad... im not sure if thats possible
14:11:14 <Gracenotes> is it a MonadIO? :o
14:12:41 <HugoDaniel> yes Gracenotes
14:12:49 <aristid> chrisdone: cool, an interactive tutorial on tryhaskell.org
14:13:19 <HugoDaniel> tryhaskell is teh future :D
14:13:35 <aristid> yeah the layout should be a bit wider tho
14:13:41 <aavogt> interesting, top level TH splices work even with  -XNoTemplateHaskell
14:14:50 <Gracenotes> darn, where are all the programming audio books? still waiting for a market to magically crop up one day...
14:15:01 <HugoDaniel> :D
14:15:21 <HugoDaniel> "real world haskell audio book"
14:15:58 <Gracenotes> with reasonably high-level descriptions of the code, might be the main issue in many of them
14:18:37 <ClaudiusMaximus> Gracenotes: i have this, it's huge http://aspress.co.uk/ds/ and pure-data centric, but there's a wikibook with translations of the examples into supercollider3
14:18:55 <hydo> I need a memory refresh - I read a post or wiki entry about using expressions in pattern matching a few days ago and I can't remember what it was called and can't seem to narrow it down with google.  If I remember right, it was an extension (well, it required a LANGUAGE pragma) that let you includ expressions on the left side of '='.  Does anyone know what I'm talking about?
14:19:58 <aavogt> view patterns
14:20:09 <hydo> yes, that's it.  thank you!
14:20:19 <aavogt> or -XPatternGuards sort of allow the same thing
14:26:58 <temoto> Having hard time to write literal 0 of type Float...
14:27:15 <Cale> :t 0
14:27:16 <lambdabot> forall t. (Num t) => t
14:27:20 <Cale> :t (0 :: Float)
14:27:20 <lambdabot> Float
14:27:25 <aavogt> :t 0.0
14:27:26 <lambdabot> forall t. (Fractional t) => t
14:27:55 <soupdragon> temoto, just write 0?? why does i thave to be float
14:28:20 <Makoryu> temoto: What are you doing, exactly?
14:28:29 <temoto> Oh thanks, the problem was actually that i misplaced x and n in replicate.
14:29:12 <mreh> does anyone know in detail how split works in RandomGen?
14:29:12 <temoto> it was 'replicate 0 n_visible' and i was trying stuff like '0.', '0.0', '(0::Float)' :)
14:29:31 <mreh> it doesn't specify which is the new and which is the old RandomGen
14:30:07 <zygoloid> what's the right way to wait(2) in a GHC-compiled program?
14:30:24 <zygoloid> there's waitForProcess in System.Process but the ProcessHandle isn't exported and i have a pid
14:30:41 <zygoloid> *ProcessHandle constructor
14:34:44 <whald> mreh: i think there is one "old" gen and two "new" ones when split is used, not?
14:35:11 <dons> mreh: there's a paper cited at the bottom of the docs
14:35:23 <dons> basically, it duplicates the seeds and permutes one
14:38:44 <hydo> oh my god... view patterns.. my code is nice to look at again.  Well, I guess it's all in the beholder, but still... *I* like looking at it.
14:40:41 <Silvah> zygoloid: there should be a function which makes a handle from a pid, though I'm not sure whether it really exists...
14:41:29 <Silvah> Does portability matter?
14:42:34 <aavogt> there are no tutorial-style documents for how to use hlist as the library it currently is?
14:42:44 <zygoloid> Silvah: not really, as long as it works on linux.
14:43:02 <zygoloid> looks like System.Process's waitForProcess is really just a wrapper around waitpid anyway
14:43:26 <zygoloid> i was worried that the RTS might be doing Something Clever, but i'm happy to FFI my way to wait.
14:45:32 <buntfalke> Since GHC can compile to C code, why is it so difficult to built object files with can interface to the linux kernel, or run on bare metal?
14:46:12 <copumpkin> it's not c code like any you've ever seen before
14:46:19 <mreh> dons: so if I used to the wrong one each time I could generate with the same seed each time
14:47:10 <buntfalke> companion_cube: Well - I guess it's not exactly readable - but who cares - why wont "gcc -fno-hosted ghc_output.c" do the trick?
14:47:19 <buntfalke> hmmm
14:47:24 <Makoryu> buntfalke: The runtime (like GHC in general) makes certain awkward assumptions about the underlying system
14:47:26 <zygoloid> buntfalke: you still need a significant runtime system
14:47:37 <Makoryu> Assumptions which don't necessarily hold in a kernel, or on bare metal
14:48:06 <Silvah> It's so difficult because the RTS is big and it depends on zillion other things, such as GMP or system's API, for instanbe.
14:48:12 <Silvah> instance*
14:48:17 <mreh> I'm reading the haskell98 report now, seems to shed some light on it
14:48:32 <copumpkin> GMP has been pulled out of the RTS
14:48:38 <copumpkin> it's just a library now
14:48:46 <copumpkin> albeit one that has a privileged position in ghc
14:49:13 <aavogt> right, it still is closely involved so that GC on Integers isn't so bad
14:49:13 <buntfalke> hmmm
14:49:17 <copumpkin> there's a pure haskell replacement for it called integer-simple
14:49:31 <copumpkin> aavogt: not really
14:49:45 <Silvah> It's not "yet another library" for people using GHC <= 6.10.
14:50:02 <temoto> djinns Char -> Int :) please
14:50:07 <copumpkin> Silvah: sure, but we can't update old versions of ghc, or they'd become new versions ;)
14:50:15 <aristid> @djinn Char -> Int
14:50:15 <Makoryu> buntfalke: Basically, a lot of the code in GHC (and in the runtime system) is incredibly hairy and gross, and hard to work with
14:50:15 <buntfalke> Well: I would like to built "runs on bare metal"-object files in a functional language compareable to haskell - suggestions?
14:50:15 <lambdabot> Error: Undefined type Char
14:50:17 <Reisen> Quick question, (my math is very bad, I'm just looking for confirmation)
14:50:30 <copumpkin> buntfalke: you could look at jhc
14:50:38 <copumpkin> buntfalke: or atom, which is a dsl in haskell
14:50:49 <Reisen> [[-1 0][0 1]]  will this flip accross the y or x axis?
14:51:04 <Makoryu> buntfalke: Are you planning to write a kernel? :p
14:51:08 <temoto> aristid, it doesn't really work, because it doesn't know the types, but i found hoogle is great at it. That's Data.Char.ord.
14:51:16 <buntfalke> Makoryu: Just for fun, yes.
14:51:43 <Reisen> Not for homework, I'm just not sure confused, as the way I've learnt to do matrix multiplications makes this seem really wrong: http://upload.wikimedia.org/math/c/e/5/ce5f7c28da8e89087f7e6256cfbcc243.png
14:51:55 <buntfalke> copumpkin: "dsl in haskell" <-- define "dsl" please
14:51:57 <zygoloid> is there a C2HS-style library available using Language.C + TH? :)
14:51:59 <aristid> temoto: i just wanted to try it out
14:52:12 <Makoryu> buntfalke: Domain-specific language
14:52:31 <copumpkin> buntfalke: check it out at http://tomahawkins.org/
14:53:41 <buntfalke> I already stumpled upon BitC, and started reading their papers. A pity not to have one of the more widespread func. langs available for that
14:54:45 <Makoryu> buntfalke: There have been several projects to convert GHC and its runtime to a state usable for low-level programming. Some of them actually got as far as writing a basic OS.
14:54:50 <buntfalke> copumpkin: having a look, thanks
14:55:05 <Makoryu> @where house
14:55:05 <lambdabot> http://programatica.cs.pdx.edu/House/
14:55:06 <buntfalke> Makoryu: and they're all dead by now.
14:55:11 <Makoryu> buntfalke: Well, yes.
14:55:43 <temoto> Speed problems?
14:55:51 <dons> there's a talk on this kind of thing next week, http://www.galois.com/blog/2010/05/12/tech-talk-developing-good-habits-for-bare-metal-programming/
14:55:57 <gio123> can one tell me wizard to install online all packages
14:55:59 <gio123> ?
14:56:05 <gio123> latex packages
14:56:21 <ddarius> Reisen: Then you need to relearn matrix multiplication.
14:56:25 <jmcarthur> dons: will there be any recordings of slides of that talk made public later?
14:56:30 <buntfalke> How come "a lot of the code in GHC (and in the runtime system) is incredibly hairy and gross, and hard to work with" anyway? It's not like it's as old as GCC, would compile for a similar amount of architectures and doesnt have lots of the more nasty features?
14:56:33 <jmcarthur> that you know of, at least
14:56:44 <dons> and an experience report, "Writing systems software in a functional language: an experience report"
14:56:49 <dons> jmcarthur: yeah, we got a new video setup
14:56:53 <jmcarthur> sweet!
14:56:55 <dons> this should be our first official video
14:57:00 <copumpkin> nice!
14:57:02 <buntfalke> I mean. In my mental image of the avg. GCC programmer does more hackish things more frequently than the avg GHC programmer/
14:57:03 <dons> though we have a few previous talks recorded as well, that might go up
14:57:04 <jmcarthur> looking forward to it
14:57:19 <dons> we've been recording on and off for about 6 months while testing different equipment
14:57:28 <ddarius> Reisen: Or perhaps you are confused about what a "reflection about the x-axis means."
14:57:34 <Twey> buntfalke: Programming C *is* вЂdoing a hackish thingвЂ™
14:57:39 <dons> buntfalke: its hairy/complex by haskell standards
14:57:42 <dons> buntfalke: but you
14:57:44 <buntfalke> well,that's the point Twey :-)
14:57:48 <dons> 're not going to e.g. introduce segfaults
14:58:02 <Reisen> ddarius, you're right, just realised I'm an idiot
14:58:03 <Twey> Well, in some of it you mightвЂ¦
14:58:20 <Makoryu> buntfalke: As I understand it, much of the design predates the horrendously powerful optimization phases that GHC implements. So, a lot of shortcuts (deep unsafePerformIO magic) were taken in earlier versions, and a lot of those are still around.
14:58:21 <dons> using C for a compiler -- which is all symbol matching and manipulation - is doing it wrong
14:58:33 <dons> yep. a few of those are still around
14:58:37 <dons> mostly they've been refactored out
14:58:50 <dons> ghc basically tracks idioms from 20 years of slowing improving ghc performance
14:59:03 <Philippa> Makoryu: that's not the RTS itself
14:59:07 <Twey> Why type-level naturals instead of just generic DTs?
14:59:20 <Makoryu> Philippa: Nope... I was getting to that :p
14:59:28 <Makoryu> Of course, others said it better.
14:59:42 <Makoryu> <Twey> buntfalke: Programming C *is* вЂdoing a hackish thingвЂ™
15:00:30 <HugoDaniel> :D
15:00:44 <buntfalke> [23:58:09] <dons> yep. a few of those are still around <-- "those" as in "shortcuts (deep unsafePerformIO magic)"?
15:00:49 <Twey> Yes
15:00:51 * buntfalke tries to keep track
15:00:56 <Silvah> So what programming Haskell is, then?
15:00:56 <buntfalke> thanks
15:01:02 <HugoDaniel> i enjoy C, and the way it binds with haskell, the perfect duo
15:01:15 <Twey> Silvah: Programming, with the occasional hack thrown in
15:01:25 <dons> poetry :-)
15:01:56 <HugoDaniel> dons: ahah :)
15:01:58 <Twey> Heh
15:02:42 <buntfalke> Silvah: Haskell is machine-readable Maths, and Maths - is "[00:01:00] <dons> poetry :-)", since as erdoes said "there is no place for ugly maths" :-)
15:04:13 <Twey> I think a lot of maths is ugly.
15:04:26 <Twey> Generally not final formulae, but the proofs can be horrendous.
15:04:53 <Makoryu> Yes, logic is ugly, awful, atrocious, repulsive, etc.
15:05:01 <buntfalke> hrhr
15:05:08 <Makoryu> Especially the interface for routing MIDI components.
15:05:25 <Twey> Haha.
15:05:26 <ddarius> Twey: Usually mathematicians aren't happy with ugly proofs.
15:05:41 <buntfalke> dons: where will i find the video recording of the talk you mentioned? and where's that exp. report?
15:06:04 <buntfalke> Plus: Do you know how Habit compares to BitC?
15:06:13 <BMeph> I'd like to see Type-level naturals, if only because I'd like to see Naturals -> Somewhere<- at base-level... :\
15:06:18 <Twey> BitC is dead, Habit isn't?
15:06:38 <buntfalke> I see :-)
15:06:45 <Twey> ddarius: Hmm, fair point.  Maybe I'm just doing it wrong.  :Гѕ
15:06:59 <Twey> buntfalke: BitC was never really designed to be functional
15:07:08 <Twey> I don't know how well Habit does on that score
15:07:17 <ddarius> Twey: Well, via CH, (some) proofs correspond to programs and there are ugly and pretty programs.
15:07:18 <Twey> Definitely looks worth following, though.
15:07:47 <Twey> ddarius: *nod* But some programs are just intrinsically ugly (they do complex things that have no obvious simplifying abstraction)
15:08:33 <Silvah> Everything is pretty, you just fail to see this.
15:08:46 <buntfalke> the point of that quote is "there exists ugly maths, but as with a form of art, it should be improved on until there's no more of it left"
15:10:51 <Twey> I agree, but I'm not entirely convinced that there aren't some conceptual limitations that simply defy prettifying.
15:11:01 <temoto> How to convert ByteString to list of Bool (its bits) ?
15:11:01 <Silvah> Well, I said everything?
15:11:23 <ddarius> Twey: Most of those programs are dealing with ad-hoc things (e.g. human standards etc.)  Most of the beauty of mathematic proofs is finding that simplifying abstraction.
15:11:29 <Silvah> C++ is by no means pretty.
15:11:40 <Twey> ddarius: That's true.
15:12:12 <copumpkin> if everything is pretty, what's the point of the term?
15:12:21 <zachk> ok , if I have a list of functions how do i pattern match [] ?
15:12:50 <Silvah> Who knows.
15:12:56 <Philippa> zachk: same as ever?
15:13:05 <BMeph> temoto: ByteString -> [Word8] {- i.e. bytes -} -> [Bool] {- i.e., bits -}
15:13:25 <zachk> ive tried it before and functions are not an instance of Eq so it fails
15:13:43 <Twey> Pattern-matching does not require Eq
15:13:44 <temoto> zachk, pattern-matching doesn't require Eq.
15:13:44 <BMeph> temoto: At least, that's how I'd do it; others may have more..."constructive" forms of advise... ;)
15:13:50 <Twey> Pattern-matching is magic.
15:13:55 <BMeph> *adviCe
15:14:15 <temoto> zachk, you were doing x == y matching. Do just [] matching.
15:14:18 <Silvah> It's not the only pointless term...
15:14:38 <zachk> i tried [] matching before and i remember it not working
15:14:42 <zachk> i guess ill try it again
15:15:02 <temoto> BMeph, okay Word8 is a hint. What functions do you use for these 2 steps?
15:15:07 <Silvah> Well, every term seems more or less pointless to me...
15:15:08 <copumpkin> Silvah: how about we abolish terms with no discriminative power?
15:15:20 <Twey> Sounds reasonableвЂ¦ unpack is the first step
15:15:28 <BMeph> @hoogle Bytestring -> [Word8}
15:15:28 <lambdabot> Parse error:
15:15:28 <lambdabot>   --count=20 "Bytestring -> [Word8}"
15:15:28 <lambdabot>                                  ^
15:15:31 <BMeph> @hoogle Bytestring -> [Word8]
15:15:32 <lambdabot> Did you mean: ByteString -> [Word8] /count=20
15:15:32 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
15:15:32 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:15:44 <BMeph> @hoogle ByteString -> [Word8]
15:15:44 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
15:15:44 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
15:15:44 <lambdabot> Data.ByteString head :: ByteString -> Word8
15:16:10 <BMeph> @hoogle Word8 -> [Bool]
15:16:11 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
15:16:11 <lambdabot> Data.ByteString elem :: Word8 -> ByteString -> Bool
15:16:11 <lambdabot> Data.ByteString notElem :: Word8 -> ByteString -> Bool
15:17:26 <Twey> concatMap (reverse . map (toEnum . flip mod 2) . takeWhile (/= 0) . iterate (`div` 2)) . unpack
15:17:51 <Twey> Should work with an appropriate signature
15:17:58 <temoto> > let f [] = "this is [] pattern" in f []
15:18:00 <lambdabot>   "this is [] pattern"
15:18:03 <temoto> zachk, ^
15:18:09 <osaunders> I'm not sure if this on-topic: I'm looking for people interested working on a startup with me.
15:18:35 <BMeph> temoto: It sounds horridly inefficient, but I'd likely use something from Data.Bits for the Word8 -> [Bool] part. Check around, and try stuff out. It's not a crime to do thing "un-Haskelly" - especially if it works! :)
15:19:14 <temoto> Twey, omg so long expr... thanks.
15:19:17 <Silvah> copumpkin: but it's so much work and it won't buy us anything...
15:19:22 <Twey> Feel free to break it up
15:19:59 <temoto> BMeph, do you do something like twey suggested?
15:20:10 <copumpkin> it'd be amusing because if we threw out all words with no discriminative power, (ignoring other things the word discriminative can be applied to) we could throw out the word discriminative too
15:20:33 <zachk> what do you mean by discrimnative?
15:20:49 <copumpkin> contribute information
15:21:03 <BMeph> temoto: "concatMap (flip (map testBit) [0..7]) . unpack" should work as well, if more awkward-looking... :)
15:21:12 <Twey> digits base = reverse . map (toEnum . flip mod base) . takeWhile (/= 0) . iterate (`div` base); ones = toEnum . digits 2; bytestringToBools = concatMap ones . unpack
15:21:13 * zachk is loss as copumpkin 's grand idea 
15:21:15 <Silvah> And then we'll forget what we wanted to throw out exactly. Funny.
15:21:23 <Cale> What's an example of a nondiscriminative word?
15:21:27 <Twey> Ah!  BMeph's is nicer.
15:21:31 <gio123> copumpkin: where is pumpkin?
15:21:55 <Silvah> Cale: pretty
15:22:07 <zachk> Cale: perhaps interjections , thinking of cuss words
15:22:08 <copumpkin> Silvah said that everything was pretty a few minutes ago
15:22:18 <copumpkin> so I asked why have the word at all
15:22:31 <Cale> But not everything is pretty to everyone.
15:22:40 <copumpkin> gio123: I murdered him and have a few of his limbs in a bag
15:22:44 <copumpkin> I really should get rid of them
15:22:57 <temoto> copumpkin, i believe same holds for any two groups of anything if those two groups describe whole set.
15:23:05 <zachk> copumpkin: have they started to decay yet? you might want to eat them if they haven't already
15:23:12 <copumpkin> zachk: good idea
15:23:13 <jbapple> What is the difference between List and Data.List?
15:23:22 <copumpkin> jbapple: one is h98 the other is ghc
15:23:27 <Makoryu> jbapple: List is the old (Haskell '98) name
15:23:33 <Twey> List is preвЂ“hierarchical-modules
15:23:39 <jbapple> I mean, I can see at least one difference
15:23:50 <Twey> It should be H98-compatible, I think
15:24:01 <jbapple> Data.List includes some functions not in List
15:24:13 <copumpkin> :t permutations
15:24:14 <lambdabot> forall a. [a] -> [[a]]
15:24:21 <jbapple> :t foldl'
15:24:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:24:23 <copumpkin> > permutations [1..3]
15:24:24 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
15:24:48 <Silvah> Cale: everything is relative...
15:24:48 <zachk> > (length.permutations) [1..5]
15:24:50 <lambdabot>   120
15:25:34 <temoto> BMeph, thanks a lot.
15:27:12 <BMeph> temoto: Oh, before you thank me, let me write it in a way that works... ;)
15:27:38 <Silvah> Does it have to work, really?
15:27:40 <BMeph> temoto: "concatMap (flip map [0..7] . testBit) . unpack" should work. :)
15:27:48 <matt_m> Does anyone know of a model of computation that defines a computation to be a tree of behavior:  a computation could diverge, or return a previous formal parameter, or return another computation, or apply a previous formal parameter to another computation
15:28:03 <matt_m> Anyone seen something like that or have a name for it?
15:28:28 <matt_m> e.g. the identity function takes a formal parameter and returns it
15:28:52 <BMeph> Silvah: Yes, it *has* to work. :ю
15:29:32 <temoto> BMeph, unpack suggests that i don't need to convert String to ByteString in first place, right?
15:29:56 <Silvah> You have to.
15:29:57 <zachk> matt_m what do you mean by previous formal parameter?
15:30:13 <Silvah> unpack returns a list of bytes.
15:31:00 <matt_m> zachk:  K x y = x is a function that returns a function that returns its first formal parameter
15:31:08 <Silvah> A String is a list of characters. Characters aren't bytes.
15:31:10 <BMeph> temoto: Well, Strings aren't ByteStrings (although ByteStrings are Strings -  "it's complicated")... ;)
15:31:48 <Silvah> ByteStrings aren't Strings, they're strings.
15:31:59 <zachk> matt_m: by previous do you mean previously passed into the function? cause then you are gonna need state
15:32:15 <Silvah> Strings are of course strings, too.
15:32:20 <temoto> BMeph, i know difference between those two. I asked for ByteString -> [Bool] in first place because it seemed reasonable for me that String must be encoded in some character encoding before working with bits.
15:32:40 <zachk> > :t SuperString
15:32:42 <lambdabot>   <no location info>: parse error on input `:'
15:32:57 <BMeph> zachk: "UR DOIN IT RONG"... ;)
15:33:05 <temoto> :t 1
15:33:07 <lambdabot> forall t. (Num t) => t
15:33:09 <zachk> BMeph: show me how to do it right || left
15:33:19 <zachk> :t SuperString
15:33:20 <lambdabot> Not in scope: data constructor `SuperString'
15:33:27 <matt_m> zachk:  What I'm looking for is sort of an alternative to lambda calculus.  It includes more computations than LC though
15:33:45 <Silvah> Wrong? Maybe he wanted to get a error message?
15:34:05 <zachk> matt_m: i believe what you want could be modelled in lambda calculus as well
15:34:17 <matt_m> zachk:  Yes it could
15:35:05 <zachk> matt_m: you might be looking for Scheme , or some strange variant of it
15:35:22 <matt_m> zachk:   LC can't produce arbitrary trees of infinite length, though.  So, for example, you can't make a lambda abstraction that produces the digits of an arbitrary real, whereas in the formalism I have in mind you could
15:35:55 <matt_m> zachk:  I think any scheme variant will be closer to LC than this
15:37:15 <zachk> matt_m: ok so we have F n = last parameter F was called with
15:37:32 <zachk> is that what you mean by previous formal parameters?
15:37:52 <matt_m> zachk:  No, I mean closed over parameters
15:38:28 * zachk is lost 
15:39:21 * Silvah is going to the bed...
15:39:24 <matt_m> zachk:  Sorry, I'm probably not explaining it well
15:40:01 <Silvah> Good night.
15:40:03 <BMeph> matt_m: Sounds like textbook primitive recursion. I could be missing the point, though.
15:40:06 <temoto> BMeph, something needs to be fixed, because i get 'not Bits instance for Char'...
15:40:36 <matt_m> zachk:  With Lambda Calculus, you have a finite string that defines your function. \x ...    I'm interested in studying functions by their traces (sort of, not to be confused with concurrency semantics) rather than via substitution
15:40:52 <temoto> BMeph, http://codepad.org/3Fl9vqxL
15:41:03 <zachk> matt_m: whats the trace of a function?
15:41:41 <temoto> BMeph, Layer is [Neuron] which is Maybe Bool
15:41:51 <matt_m> zachk:  It's what that function does from "the outside" point of view.  It could either diverge, or give you back one of your previous parameters, or give you back a new computation, or ask to evaluate a previous parameter against a new computation
15:42:38 <zachk> matt_m: this sounds like closures and/or continuations, or maybe even coinduction, but i dont really know that much about the latter two
15:43:25 <matt_m> zachk:  It's related to those things, but none of them are the name I'm looking for
15:43:53 <zachk> matt_m: then mix them all together and make a system
15:44:04 <matt_m> BMeph:  Primitive recursion is a subset of recursive functions.  I'm talking about a superset
15:44:46 <matt_m> zachk:   My goal in asking is to discover an existing body of work, not to overcome some technical block
15:45:13 <Saizan> matt_m: maybe just a (possibly infinite) tree of all the possible reductions?
15:45:23 <Saizan> ah.
15:46:03 <matt_m> Saizan:  It includes "traces" of things that aren't reductions of any lambda term.
15:46:32 <matt_m> Saizan:  For example, you could imagine a computation that successively enumerates the digits of any real number
15:46:46 <matt_m> even non-computable ones
15:46:48 <gwern> how about omega
15:46:50 <zachk> matt_m: you cant do that, there are noncomputable reals
15:47:10 <zachk> ....
15:47:21 <matt_m> zachk:  What I'm interested in is a mathematical object.  Maybe using the term "computation" isn't advisable :)
15:47:47 <Saizan> well, there's plenty of super-turing computational models, no?:)
15:48:12 <zachk> matt_m: id say ask in #math but they will just poo poo you off :(
15:48:15 * Saizan doesn't know anything of relevance though
15:48:18 <matt_m> Saizan:  Ya, I'm wondering if this one has a name
15:48:45 <matt_m> Ya I think CS people are better to ask about this than general math people
15:48:53 <zachk> matt_m: have you coded up an example of what you are trying to achieve?
15:49:17 <gwern> matt_m: how could he? it's uncomputable? :)
15:49:25 <matt_m> :)
15:49:32 <temoto> BMeph, wow, changing import from ByteString.Char8 to ByteString solved it. Your bits function work now, thanks.
15:49:52 <matt_m> thanks all
15:52:04 <BMeph> temoto: Looks like you're using the D.B.Char8 byteString. If that's what you need, then it's fine...ah, you got it - NM, then. :)
15:53:03 <patch-tag> hdbc problem, connecting to mysql via hdbc.odbc, select statement. sporadically I get *** Exception: SqlError {seState = "[]", seNativeError = -2, seErrorMsg = "sqlFetch: []"}
15:53:07 <patch-tag> anybody seen this?
15:53:12 <patch-tag> maybe 1 in 10 queries
15:53:58 <patch-tag> (same query every time, just repeating)
15:54:30 <Kaidelong> just to make sure I'm understanding the material here...
15:54:46 <Kaidelong> this would be a potential implementation of a parallel map:
15:55:04 <Kaidelong> pmap _ [] = []
15:56:11 <aavogt> that's it?
15:56:16 <Kaidelong> pmap f (x:xs) = h `par` t `pseq` h:t where h = f x
15:56:27 <Kaidelong>          t = pmap f xs
15:56:48 <aavogt> such a thing is already defined in the parallel library
15:57:11 <Kaidelong> aavogt: the point is that I'm understanding how `par` is used
15:57:23 <Kaidelong> err, par
15:57:34 <Kaidelong> but it seems like the convention is to infix it
15:57:48 <BMeph> aavogt:  ([XX:54] <Kaidelong> just to make sure I'm understanding the material here...) --> I think this is supposed to be a re-hash... :)
15:57:56 <Makoryu> @src parMap
15:57:57 <lambdabot> Source not found. That's something I cannot allow to happen.
15:58:14 <temoto> i wouldn't use pseq at all (and i could be terribly wrong)
15:58:22 <copumpkin> it's important
15:58:25 <aavogt> what would you do instead?
15:58:29 <aavogt> pattern match?
15:59:47 <Kaidelong> so I take it I get it then?
16:00:04 * BMeph would take it that way.
16:00:10 <Kaidelong> yay, thanks
16:01:03 <Makoryu> Yeah, the real definition (which is a bit more complicated than what Kaidelong wrote) just uses seq
16:01:10 <Makoryu> http://www.haskell.org/ghc/docs/6.8.3/html/libraries/parallel/src/Control-Parallel-Strategies.html#parMap
16:01:13 <Makoryu> http://www.haskell.org/ghc/docs/6.8.3/html/libraries/parallel/src/Control-Parallel-Strategies.html#using
16:01:16 <Makoryu> http://www.haskell.org/ghc/docs/6.8.3/html/libraries/parallel/src/Control-Parallel-Strategies.html#parList
16:01:29 <Kaidelong> Makoryu: I'm not covering parallel strategies yet
16:01:35 <Kaidelong> that's NEXT on my list of things to talk about
16:01:52 <Makoryu> Kaidelong: All right :p
16:01:56 <Kaidelong> but now that I'm comfortable that the first part of my entry is accurate
16:02:03 <Kaidelong> I'll get to work on the strategies section
16:03:54 <temoto> pmap f (x:xs) = (h `par` h):t ?
16:04:12 <Kaidelong> temoto: wouldn't that make t lazy, defying the point?
16:04:57 <temoto> Kaidelong, i'm not sure why parallel map have to be non-lazy.
16:05:35 <Kaidelong> temoto: because if you evaluate by need you'll be evaluating it one element at a time anyway?
16:06:05 <buntfalke> BTW, how come Haskell-Code isn't parallelized automatically where there are no dependencies?
16:06:45 <Makoryu> buntfalke: 'Cause doing that for an entire program is a hard problem
16:07:12 <Kaidelong> buntfalke: IIRC the short answer is that implicit parallelism does not play well with lazy evaluation in the general case
16:07:28 <aavogt> parallelizing is easy... but doing it such that the pieces are big enough that you actually get a speedup is a tricky part
16:07:28 <buntfalke> Why? It's functional - no side effects. Can't we just draw a graph, and check for which parts of it aren't connected?
16:07:33 <dons> buntfalke: there's too much parallelism for today's hardware
16:07:34 <aavogt> Kaidelong: no, it plays nicely
16:07:48 <dons> buntfalke: you might have say, 8 hardware threads.
16:07:55 <dons> but millions of nodes in the haskell program
16:08:02 <dons> == paralleliism overload
16:08:34 <dons> buntfalke: i have a 3 hour course on this stuff, btw, http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
16:08:56 <buntfalke> dons, aavogt: So we define: "(magic constant)*Hardware_Threads = nr_of_individual_operations" to be the threshold for implicitly parallelizing or not
16:08:58 <dons> fully implicit parallelism was tried though, back in the late 80s/mid-90s.
16:09:02 * BMeph thought parallelism DID play well with lazy evaluation...especially where side-effects are identified and manageable
16:09:11 <dons> buntfalke: right, and that's *really hard*. statically estimating granularity
16:09:17 <dons> there's some good papers on it.
16:09:22 <aavogt> buntfalke: so how do you know how long each operation will take?
16:09:40 <dons> you have to estimate the cost of evaluating each thing at compile time -- symbolically. that's HARD.
16:09:43 <temoto> Kaidelong, if i understand what 'par' does, then (h `par` h) : t  will evaluate h in parallel with t, because t doesn't depend on h.
16:09:55 * Kaidelong thought the problem was that knowing whether or not a value would actually be needed was undecidable?
16:09:56 <buntfalke> dons: I see...it intuitively feels quite simple though. "Just find some working constant, multiply, and go ahead" :-)
16:10:03 <dons> that's the trick.
16:10:04 <Kaidelong> until it is needed
16:10:11 <dons> if we had different hardware it'd be easier
16:10:16 <Kaidelong> although I suppose haskell is different from a turing machine
16:10:18 <dons> you could get away with being less accurate
16:10:30 <BMeph> buntfalke: What if your "constant" isn't constant, hmm? ;)
16:10:33 <Makoryu> buntfalke: There are a couple libraries now where you basically tell the compiler "figure out how to parallelize this piece of data" and it does it
16:10:35 <buntfalke> aavogt: you simply assign /some/ reasonable "cost" to every operation. add = 1, multiply = 3, divide = 9 or so
16:10:35 <dons> turing machines don't have much to do with it.
16:10:48 <dons> for some subsets of haskell, its much easier to automatically parallelize.
16:10:54 <dons> arrays, for example, have a reasonable static cost model
16:11:00 <dons> so we have auto-magic parallel arrays as a result
16:11:10 <dons> ghc's even smart enough to do nested parallel data automatically
16:11:20 <dons> just not arbitrary haskell
16:11:23 <aavogt> buntfalke: but how many of those happen?
16:11:31 <arw> buntfalke: finding the "real" cost for each operation would require a solution to the halteproblem.
16:11:32 <Kaidelong> dons: so the approach is to do things in parallel whenever it's though to be worth it's cost, even if the value calculated in parallel is never actually used?
16:11:37 <Makoryu> But the language isn't built on that, and they're still experimental
16:11:48 <kmc> yes http://tumblr.justtesting.org/post/578801625/simon-peyton-jones-on-data-parallel-haskell is a fantastic talk about data parallel haskell
16:11:52 <Makoryu> On the other hand, Haskell was designed as a playground for pretty much exactly that kind of experiment
16:11:52 <dons> Kaidelong: that's the general idea with sparks -- speculative evaluation
16:11:58 <arw> buntfalke: you can calculate the cost of simple primitives, but not of more complex algorithms.
16:12:02 <aavogt> arw: well the code you run hopefully terminates :)
16:12:03 <Kaidelong> cool, that makes sense
16:12:12 <Makoryu> Oh god how long have I been lagging
16:12:12 <kmc> a spark is much cheaper than a Haskell thread, which is much cheaper than an OS thread
16:12:15 <kmc> none of them is free though
16:12:29 <BMeph> Sounds like we need a JIT/RTS-tweaking Haskell compiler... ;)
16:12:42 <temoto> What, spark is different from haskell thread?
16:12:47 <dons> yep.
16:12:52 <buntfalke> arw: Well - you do not actually need the /real/ cost - that might even depend on the input data. My thought was that some rough virtual cost model would allow for an estimation which is exact enough to do some fair guesses on wether we better parallelize or not
16:12:54 <arw> aavogt: "it terminates" is just the easiest part of calculating the time it will need.
16:12:57 <buntfalke> arw: and Hi btw :-)
16:12:58 <Kaidelong> I imagine though that in some contexts though, making parallelism implicit might change the behavior of a lazy program?
16:13:05 <temoto> Why do we need two kinds of threads?
16:13:10 <kmc> temoto, a spark isn't a thread
16:13:13 <aavogt> but if the fastest way to see how long it will take to evaluate something is to go and evaluate it.. you have not gained anything
16:13:23 <Kaidelong> and you need to avoid that?
16:13:35 <dons> see the graph on page 19 of tihs talk, http://donsbot.wordpress.com/2009/10/17/multicore-haskell-now-acm-reflections-projections-2009/
16:13:41 <Kaidelong> IE if there is a thunk that will not normally be evaluated that doesn't terminate
16:13:43 <dons> shows the spark/thread/os-thread/cpu model
16:13:44 <kmc> temoto, it's a pointer to a thunk which might be worth evaluating in parallel.  it goes on a queue and Haskell threads pick it up if they're not busy doing other stuff
16:13:58 <arw> buntfalke: that might be possible, yes. you could run the code single-threaded, do some statistics inside the vm and then parallelize.
16:14:17 <dons> haskell threads push sparks at each other, os threads steal haskell threads from each other
16:14:30 <dons> and the kernel migrates os threads around the available cores
16:14:40 <dons> and that's how we do a haskell.
16:14:49 <temoto> kmc, oh i see now, thanks. But that sounds as cheap as a general thunk.
16:15:08 <dons> sparks are thunks in queues attached to each core.
16:15:18 <aavogt> temoto: it's cheap if they don't get run
16:15:18 <dons> of extra work in case there are idle cycles
16:15:19 <kmc> temoto, the thunk already exists either way.  to "spark" a thunk you have to copy a pointer to it onto a lockless queue, which takes a little time
16:15:41 <temoto> queue overhead, i see
16:16:50 <buntfalke> arw: As in, profile, evaluate, recompile?
16:17:18 <dons> there's a paper on that.
16:17:22 <arw> buntfalke: as in profile, evaluate, distribute to different threads.
16:17:29 <dons> it should be tried again, given the changes in costs.
16:17:47 <arw> buntfalke: there should be no recompilation involved, the functions you execute don't know they are beeing parallelized.
16:17:56 <dons> Tim Harris, Satnam Singh: Feedback directed implicit parallelism
16:18:20 <arw> interesting. i'll attach that to my read-queue :)
16:18:24 <jon_of_arc> Kaidelong: it seems to me like speculative evaluation of a nonterminating thunk on a separate core can't make you not terminate, it can just make you burn cycles on that core. I might be wrong about that, though; not an area I've had time to dig into.
16:19:09 <Kaidelong> jon_of_arc: I could see how haskell might set it up so that the spark dies out when it can prove it's not needed
16:19:19 <buntfalke> arw: So you think of letting the RTS decide about implicitly parallelizing on the fly, then
16:19:25 <Kaidelong> it does seem like not evaluating it at all might be better though
16:19:26 <dons> Kaidelong: that's called 'fizzling'
16:19:33 <dons> ghc kills sparks that are recomputed elsewhere.
16:19:39 <dons> or whose values go out of scope.
16:19:57 <arw> buntfalke: yes, since there is a RTS and it should know best about the current state of the program i guess that would be logical.
16:20:01 <dons> jon_of_arc: re. non-termination, that's right.
16:20:11 <dons> `par` is not observable, other than your laptop gets hot
16:20:11 <arw> buntfalke: but you could of course also use profiling data from earlier runs.
16:20:36 <buntfalke> arw: True. I first thought of doing that offline, more like traditional profiling.
16:20:44 <buntfalke> Hmmm
16:20:49 <aavogt> jon_of_arc: at least for that speculative evaluation paper on ghc (which was apparently too complicated to justify the slight benefits), speculative evaluation is stopped when the value turns out to be too expensive
16:20:51 <arw> buntfalke: but short of actually running the program i can't imagine how one would be able to collect useful data about its behaviour
16:21:21 <apolon> hi all
16:21:55 <kmc> hi Apocalisp
16:21:56 <kmc> err
16:21:58 <kmc> hi apolon
16:22:32 <apolon> any hints as to the best GUI library for haskell?
16:22:41 <apolon> i've been learning gtk2hs a bit
16:22:42 <gwern> opengl
16:22:53 <gwern> no issues installing it, and you know it's high performance
16:23:16 <apolon> does it have all of the ui widgets etc?
16:23:25 <Makoryu> apolon: Use gtk2hs, and convince all your end users to switch to Linux
16:23:29 <gwern> widgets? man if you want widgets prepare to sell your soul
16:23:33 <temoto> Although opengl is missing 'UI' part.
16:23:46 <arw> but it is "real 3D"!
16:23:53 <jon_of_arc> It has that, or at least one direction
16:24:05 <kynky> wx
16:24:09 <buntfalke> arw: Well - some heuristics might be usefull to do /some/ of this at compile time: "Wow, Graph A has we've got n functions, m operations, o times recursive functions, all independent from Graph B - let's hope thats worth being parallelized"
16:24:38 <apolon> at this point i need an easy way to make UIs rather than high-performance graphics
16:24:40 <buntfalke> arw: Sure, you won't know what's actually used of it, but the assumption would be that few programmers write 1k lines when they're not needed.
16:24:49 <apolon> like plot graphs etc
16:25:08 <kynky> gtk2hs has cairo
16:25:19 <buntfalke> and it has gtk *caugh* :-P
16:25:33 <gwern> apolon: there are a number of graph plotting libs on hackage I think
16:25:49 <arw> buntfalke: maybe. the interesting part would be to find out how good this approach would work with real programs.
16:25:59 <apolon> well -- i've been working through the gtk2hs tutorial, and the cairo chapter is giving me linking errors!!
16:26:11 <arw> buntfalke: e.g. take some preexisting code and see if it gets some speedup.
16:26:17 <apolon> when i run main from ghci it gives segmentation fault after 3-5 sec
16:26:18 <kmc> apolon, are you building with ghc --make ?
16:26:23 <dons> apolon: Chart is a great gtk-based graphing library
16:26:37 <dons> http://hackage.haskell.org/package/Chart
16:26:42 <kynky> does gtk2hs work well in ghci ?
16:26:47 <dons> yeah
16:26:51 <buntfalke> arw: agreed :-)
16:26:51 <Makoryu> apolon: Are you on Linux? I dunno if gtk2hs and company are properly tested on other operating systems
16:27:05 <dons> screenshots: http://dockerz.net/twd/HaskellCharts/Example6
16:27:17 <dons> Makoryu: they're tested, but harder to install.
16:27:21 <apolon> LOL!  Thanks!! :-[
16:27:27 <dons> primarily mac is a pain, as MacPorts isn't very stable (?)
16:27:29 <apolon> i forgot --make :P
16:27:46 <apolon> i'm a super noob :(
16:27:55 <arw> buntfalke: finding the right level at which to parallelize some code is not easy, even if all parts are independent. there is still io-load, memory and cache consumption to consider which will kill your performance even if your estimates on raw cpu-time are right.
16:27:58 <apolon> but now it looks nice :)
16:28:06 <Makoryu> dons: There is no good package manager for OS X.
16:28:15 <aavogt> so --make will be the default for 6.14?
16:28:17 <apolon> dons thx i'll check it out
16:28:33 <arw> buntfalke: but for the general, non-hpc case it might work.
16:28:37 <Makoryu> dons: And there is certainly no reliable way to install GTK.
16:28:59 <Ke> how is it going with the dynamic linking
16:29:09 <Makoryu> (Setting it up by hand sure doesn't count)
16:29:16 <dons> Makoryu: you could imagine a nice installer for gtk2hs , like we have for ghc: http://hackage.haskell.org/platform/mac.html
16:29:22 <Ke> will it make it into the 6.14
16:29:30 <dons> Ke: its in 6.12
16:29:34 <apolon> what does --make actually do?
16:29:44 <dons> resolves dependencies
16:29:47 <buntfalke> arw: Uh, I was thinking in the range of <= 16 CPUs, or "current avg server/workstation/desktop/notebook systems" - not large clusters
16:29:53 <apolon> shouldn't that be automatic?
16:30:00 <dons> --make makes it automatic.
16:30:02 <carter> does anyone know why the macports version of the haskell platform isn't current?
16:30:12 <dons> otherwise it is a one-module-at-a-time compiler
16:30:13 <Ke> dons: but there were some problems that made it non default behaviour
16:30:13 <dons> like gcc
16:30:13 <Makoryu> Or at least, there's no reliable way to set it up properly for use with gtk2hs
16:30:13 <Makoryu> dons: So, just stick with recommending that people switch to Linux.
16:30:23 <dons> Makoryu: :(
16:30:27 <Makoryu> In lieu of an OpenGL-based Haskell toolkit, that's the least painful solution
16:30:35 <dons> Ke: http://mostlycode.wordpress.com/2010/01/26/ghc-6-12-1-dynamic-executables-fun/
16:30:35 <Makoryu> (Augh, great, more lag)
16:31:06 <apolon> wait, is it really true that gtk2hs does NOT work on anything except linux?
16:31:25 <dons> Ke: http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/using-shared-libs.html
16:31:31 <dons> apolon: no, that's not true
16:31:41 <apolon> what about wxwidget
16:31:41 <dons> it is a cross-platform graphics toolkit.
16:31:47 <dons> that's also cross-platform.
16:31:59 <Makoryu> carter: You can always rely on the macports version of anything to be way behind
16:32:04 <apolon> so what's the problem then
16:32:31 <gwern> apolon: it's not a binary thing, but a continuum between Just Works and ohmigodIamgoingtogohangmyself
16:32:42 <Makoryu> apolon: In theory, GTK is cross-platform
16:32:53 <Makoryu> apolon: In theory, things work as well in practice as they do in theory ;)
16:33:16 <dons> its entirely cross platform. it is just harder to build on some systems than others.
16:33:29 <arw> buntfalke: well, on everything larger the problem still becomes harder because there are more "punishments" for moving calculation around. you will get network delay and capacity problems, network topology will matter, scheduling in the network will get harder, etc.
16:33:38 <dons> wxWidgets is also harder to build on some platforms than others.
16:33:47 <jon_of_arc> Makoryu: I've found that theory actually works better in practice than it does in theory. ;)
16:33:50 <dons> it'd be really cool to have one click installers for gtk2hs like we have for hte platform though
16:34:00 <Makoryu> jon_of_arc: In practice, this may be true.
16:34:03 <apolon> so i take it that in practice building a gtk2hs program on windows would is hard?
16:34:15 <Makoryu> jon_of_arc: Actually, I've got a theory about it....
16:34:42 <dons> apolon: harder than some things, easier than others
16:34:58 <apolon> ok one more question
16:35:18 <buntfalke> arw: which is why I was thinking of the "general, non-hpc case" with a few, local threads only :-)
16:35:18 <apolon> is there a library for displaying trees or dags?
16:35:51 <ddarius> @hackage diagrams
16:35:52 <lambdabot> http://hackage.haskell.org/package/diagrams
16:35:55 <ddarius> @hackage blods
16:35:55 <lambdabot> http://hackage.haskell.org/package/blods
16:35:57 <ddarius> @hackage blobs
16:35:57 <lambdabot> http://hackage.haskell.org/package/blobs
16:35:58 <apolon> or -- possibly cyclic graphs too??
16:36:11 <arw> buntfalke: i agree. first get the easy stuff to work.
16:36:15 <pato> hi, can anyone help me. I have to put a haskell homework tomorrow, and I've a problem
16:36:29 <arw> buntfalke: it will be hard enough on a simple dualcore
16:36:50 <apolon> The requested resource was not found: no such package 'blobs'
16:37:06 <gwern>  @hackage is just dumb string concatnation
16:37:11 <gwern> it doesn't actually check or anything
16:37:35 <buntfalke> arw: I'll start way earlier with "Go finish Schneider's Haskell lecture" :-)
16:37:52 <pato> I have to make multiple definitions in a where clause. like: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25542
16:37:55 <jon_of_arc> I was wondering about what the "blods" package name could meanвЂ¦
16:37:56 <pato> how can I do that?
16:38:15 <buntfalke> Then, and after having read some relevant papers, I can still (re)consider and try - or dismiss it :-)
16:39:00 <gwern> pato: newline and indent
16:39:06 <Makoryu> pato: Personally I think Ancient Greek is a much better language for naming types and variables ;)
16:39:08 <gwern> where foo = bar\n\tbaz = quux
16:39:13 <jon_of_arc> pato: pretty much just like it sounds. Make a where clause, put multiple definitions in it.
16:40:17 <pato> thanks!
16:40:43 <BMeph> apolon: Sup dawg, I kerd u liek DAWGS so... ;)
16:41:02 <gwern> @quote gwern.*like
16:41:02 <lambdabot> No quotes match. I feel much better now.
16:41:10 <gwern> @quote gwern.*good
16:41:11 <lambdabot> No quotes match. There are some things that I just don't know.
16:41:14 <gwern> @quote gwern.*Good
16:41:14 <lambdabot> No quotes match. I feel much better now.
16:41:18 <gwern> what on earth
16:41:21 <gwern> @quote gwern
16:41:22 <lambdabot> gwern says: #haskell: because none of us are as offtopic as all of us
16:41:28 <olsner> I'm not sure the nick part is included in the regexp match
16:41:29 <gwern> ok, at least it's not completely broken
16:41:32 <patch-tag> so, this is totally bizarre. in hdbc over mysql, I had this query with a large number cols in an IN grouping. With > 982 items, I get that internal sql error. When joined with unlines. When joined with unwords, it passes. With less items in the in grouping, unlines is okay. wtf?
16:41:37 <gwern> olsner: I could swear I did that just yesterday though
16:41:46 <patch-tag> i'll email john goerzen
16:42:00 <apolon> @quote lambdabot.*quote*
16:42:00 <lambdabot> command says: lambdabot will say 'it is forever etched into my memory' and then forget the quote by tomorrow.
16:42:12 <gwern> @quote gwern
16:42:13 <lambdabot> gwern says: [regarding the naming of Monoids] we will call them CuteFluffableThings, since you can put more fluff into them, but no one would remove fluff from a cute thing
16:42:42 <gwern> @quote gwern
16:42:42 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
16:42:57 <gwern> that one should've matched '@quote gwern.*good', I think.
16:43:18 <apolon> is there a combinator you could eval to @quote something?
16:43:22 <Berengal> futurama projection :)
16:43:40 <gwern> Berengal: you are not the first to note the anagram
16:43:58 <temoto> gwern, probably, quote doesn't start with '%username% says:', it's a prefix appended at output time.
16:44:09 <Berengal> Oh, it's an anagram too? I've always though I was just being dyslexic
16:44:27 <gwern> > sort "futurama" == sort "futamura"
16:44:28 <lambdabot>   True
16:44:49 <olsner> > null ("futurama" \\ "futamura")
16:44:50 <lambdabot>   True
16:45:15 <ddarius> > null ("f" \\ "futamura")
16:45:16 <lambdabot>   True
16:45:25 <gwern> zing
16:45:52 <olsner> > null ("fffffffuturama" \\ "futamura")
16:45:53 <lambdabot>   False
16:46:14 <gwern> olsner: yes, we got the point the first time
16:46:43 <tromp> > 212*7394384359052019860110129861127614655263725+1448*6499245207374987910384446769196893420982287+1952*5710094948882734570085737442865185909590743
16:46:44 <lambdabot>   22124621884617108585387385940828998876019391612
16:47:15 <apolon> >y i
16:47:16 <zachk> tromp: whats that number related too or is it just a random string of numbers :0
16:47:22 <apolon> > y i
16:47:23 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
16:47:23 <lambdabot>         against infe...
16:47:32 <tromp> counting number of chess positions
16:47:35 <apolon> > y (if b then not b else b)
16:47:36 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:47:37 <lambdabot>         against inferred type ...
16:47:45 <Berengal> @type y
16:47:45 <lambdabot> Expr
16:47:58 <tromp> well, an upperbound
16:48:27 <ddarius> \b -> if b then not b else b = const False
16:48:45 <apolon> y (\b -> if b then not b else b)
16:48:57 <apolon> > y (\b -> if b then not b else b)
16:48:58 <lambdabot>   Couldn't match expected type `(GHC.Bool.Bool -> GHC.Bool.Bool)
16:48:58 <lambdabot>             ...
16:50:02 <apolon> hm
16:50:22 <apolon> > i i
16:50:23 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
16:50:23 <lambdabot>         against infe...
16:50:58 <BMeph> tromp: Ah. For a bit, I thought it might be the decimal representation of an LC program you used to count those chess positions... ;)
16:51:54 <tromp> there's no point in doing that since the bound itself is gonna be more concise than the program computing it:)
16:52:01 <temoto> Is there any convenient just_or_fail ?
16:52:12 <tromp> and i cant wait around forever on the result
16:52:23 <temoto> as in, extract x from Just x or fail monad on Nothing?
16:52:51 <tromp> i only use binary LC to show how concisely things can be defined
16:53:27 <BMeph> tromp: So you see my point exactly! ;)
16:54:23 <ddarius> temoto: Not really, at least for a general monad.
16:54:42 <temoto> ddarius, i'm in IO
16:54:44 <ddarius> temoto: Oh wait, I'm somewhat wrong.
16:54:50 <BMeph> temoto: 'maybe', maybe.. ;)
16:55:11 <pikhq> temoto: (Just x) <- foo -- ?
16:55:16 <ddarius> temoto: do Just x <- return <maybevalue>; ...
16:55:29 <pikhq> @undo do (Just x) <- return Just 1
16:55:29 <lambdabot>  Parse error at end of input
16:55:31 <pikhq> Erm.
16:55:33 <pikhq> @undo do (Just x) <- return (Just 1)
16:55:33 <lambdabot>  Parse error at end of input
16:55:35 <BMeph> "return . fromJust" could do it, too...badly, but still.... :\
16:55:42 <pikhq> @undo do (Just x) <- return (Just 1);foo
16:55:42 <lambdabot> return (Just 1) >>= \ a -> case a of { (Just x) -> foo; _ -> fail ""}
16:55:52 <ddarius> BMeph: That doesn't use fail/throw an IOError.
16:56:07 <ddarius> pikhq: You don't need the first set of parentheses.
16:56:08 <temoto> BMeph, maybe (fail "you rong") const value ?
16:56:36 <pikhq> temoto: Pattern matchs in do notation call fail when they fail. :)
16:56:44 <BMeph> temoto: s/const/return/ perhaps. :)
17:03:37 <temoto> uhm.. how to write a sigmoid exp ** (-E/T)  function ?
17:06:24 <ddarius> exp (-E/T)
17:06:31 <temoto> okay, ** works as expected: float power, now i need 'e ** x'
17:06:57 <temoto> oh exp is exp :) great
17:07:06 <temoto> ddarius, thank you
17:09:26 <temoto> http://www.stanford.edu/~pmcmahon/fpl09_dbn.pdf WOW hardware RBM
17:17:16 <cads> hey, can I use haskell to visit a sit that generates its HTML on the fly and copy out the generated html tree?
17:17:24 <dh__> good evening. Is it possible to define a list of function , then compose them together ?
17:17:31 <copumpkin> dh__: sure
17:17:35 <cads> what's that thing that makes lambdabot say "yes, haskell can do that!"
17:17:35 <copumpkin> :t foldr (.) id
17:17:37 <lambdabot> forall b. [b -> b] -> b -> b
17:17:46 <ddarius> @faq
17:17:46 <lambdabot> The answer is: Yes! Haskell can do that.
17:17:48 <dh__> thanks.
17:17:54 <copumpkin> :t appEndo . foldMap Endo
17:17:55 <lambdabot> Not in scope: `foldMap'
17:18:00 <copumpkin> :t appEndo . Data.Foldable.foldMap Endo
17:18:01 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
17:18:32 <ddarius> cads: You could also just use wget.
17:18:53 <cads> I need to manipulate the site as well though
17:19:52 <cads> facebook is basically a template with javascript functions that fetch the info from your profile, expands the list of entries when you click "view older posts", etc.
17:20:01 <dh__> wait , cads: I want functions of [a->b, b->c, c->d ] to be composed.
17:20:08 <dh__> not [b->b ]
17:20:22 <copumpkin> dh__: you can't
17:20:34 <copumpkin> lists are homogeneous
17:20:56 <dh__> is there something heterogeneous? container of functions?
17:21:02 <tensorpudding> tuples
17:21:14 <dh__> but it's variable length.
17:21:15 <copumpkin> dh__: you'd need something special
17:21:45 <dh__> last time somebody refer me a paper to read ..
17:22:03 <cads> a structure that can hold an arbitrary chain of functions, as long as each function's codomain is the same as the next's domain
17:22:04 <temoto> probably, about rank-n polymorphism
17:22:20 <dh__> yes, cads, that's what  I want.
17:22:47 <ddarius> dh__: Do you need to count these chains or something, why can't you just compose them in the first place?
17:22:48 <copumpkin> data Flist a b = forall c. Flist (a -> c) (Flist c b)
17:23:21 <dh__> I build a tree of functions, and want to do many thing on this tree.
17:23:32 <ddarius> copumpkin: You need an Id case.
17:23:39 <Cale> dh__: hmm...  data FList a b where FNil :: FList a a; FCons :: (a -> b) -> FList b c -> FList a c
17:23:41 <copumpkin> oh yeah :)
17:23:44 <dh__> Func = AtomFuncs | Compose [ Func ]  | Product [ Func]
17:23:48 <copumpkin> unless you have an infinite stream of functions :P
17:24:29 <copumpkin> which of course you couldn't do much with
17:24:48 <Cale> dh__: But why is it important to keep the functions separate?
17:24:56 <ddarius> copumpkin: You could do about as much as you could do with Cale's FList type.
17:25:01 <Cale> dh__: Why not just compose them immediately and be done with it?
17:25:17 <dh__> I want to define a trace function for the tree.
17:25:25 <copumpkin> dh__: keep in mind that if you don't know the types of the intermediate functions (and you won't), you won't be able to do much with them
17:26:12 <dh__> I see , there is no run time information. thanks, copumpkin.
17:26:15 <copumpkin> except just compose them with the ones adjacent to them
17:26:40 <Cale> Yeah, types are a compile-time phenomenon, and are erased by compilation.
17:27:04 <dh__> I guess I'll go back to python ..
17:27:13 <edwardk> heresy ;)
17:27:16 <Cale> dh__: What are you trying to accomplish?
17:27:52 <dh__> a function that could trace ( print each step of intermedia result ) of compostion of functions.
17:28:01 <Cale> Okay
17:28:11 <Cale> So, that's a useful piece of information
17:28:23 <Cale> We need to know that the intermediate types are showable, in that case
17:28:23 <dh__> fs = Compose [ inc , str , (*2 ) ]
17:28:37 <dh__> trace fs (1 ) -->  (2, '2' , ??)
17:28:48 <copumpkin> so you'd change my type to have a Show constraint, and you probably want a terminator too
17:28:49 <Cale> dh__: hmm...  data FList a b where FNil :: FList a a; FCons :: (Show b) => (a -> b) -> FList b c -> FList a c
17:28:50 <copumpkin> as ddarius pointed out
17:29:00 <copumpkin> or just use Cale's thing :P
17:29:29 <Cale> So, now we require that the intermediate type is showable.
17:29:52 <dh__> is  FList in standard lib ? I can't hoogle it.
17:29:56 <Cale> It's not.
17:30:02 <Veinor> FList is the type that you're making
17:30:02 <Cale> It's something I'm defining for you
17:30:11 <ballard4553> #haskell hi
17:30:14 * copumpkin likes flisting
17:30:23 <ballard4553> #haskell hi
17:30:25 <temoto> http://en.wikipedia.org/wiki/Sigmoid_function there it is, sigmoid function, the logistic one. How to modify it, so its domain is 0..1 instead of -inf..inf ?
17:30:25 <copumpkin> this doesn't look promising
17:30:33 <Cale> A list of functions which are composable and where every intermediate type is showable is something which is way too special-purpose for the standard library
17:30:33 --- mode: ChanServ set +o copumpkin
17:30:50 <Cale> So...
17:31:05 <copumpkin> ballard4553: why are there so many of you?
17:31:32 <gwern> copumpkin: they're androids man they churn them out in the hundreds
17:31:35 <Cale> trace :: (Show a, Show b) => FList a b -> a -> ([String], b)
17:31:50 <Veinor> looks about right, Cale
17:31:53 <ballard4554> #haskell hi
17:31:55 <ballard4554> #haskell hi
17:31:59 <Cale> trace FNil x = ([show x], x)
17:32:10 <soupdragon> hi ballard
17:32:12 <gwern> copumpkin: he's seen things you can't even imagine. fire off the tanhauser gate...
17:32:13 <tensorpudding> existentials!
17:32:16 <soupdragon> :(
17:32:31 <tensorpudding> Except GADT notation hides them somewhat
17:32:42 <ddarius> soupdragon: Real Name: PircBot 1.5.0 Java IRC Bot
17:33:03 <Cale> trace (FCons f fs) x = let (ss, y) = trace fs (f x) in (show x : ss, y)
17:33:06 --- mode: ChanServ set -o copumpkin
17:33:22 <ballard455> #haskell hi
17:33:26 <ballard455> #haskell hi
17:33:30 <soupdragon> hey
17:33:36 <soupdragon> ballard455
17:33:40 <copumpkin> ballard455: quit it
17:33:42 --- mode: ChanServ set +o Cale
17:33:48 <Berengal> ballard455: you should consider testing your bot in your own private channel
17:33:50 <soupdragon> OMG HE USED MULTIPLE LINES !!!!
17:33:56 <b6> how should i round some floating point number to, e.g., the nearest ten thousandth?
17:34:11 <dh__> thanks cale. It's still hard for me.
17:34:12 <copumpkin> soupdragon: he joined the channel multiple times with bots each of which says nothing at all, multiple times
17:34:29 <gwern> we should test whether ballard is human or not. let's ask him soem questions about animals
17:34:31 <Cale> dh__: It's sort of a strange thing to do. I'm using the GADTs extension here.
17:35:01 <dh__> Cale: May I ask what degree you got ?
17:35:01 <temoto> b6, when no special routines are there, i use this trick: int (x * 1000)
17:35:17 <Cale> dh__: I have a BMath in pure mathematics.
17:35:18 <temoto> b6, ... / 1000 of course
17:35:27 <dh__> that's why.
17:35:29 <Berengal> "This sentance is false" is false
17:35:29 <b6> temoto: hmm, i guess it's ok. thanks.
17:35:32 <copumpkin> if it were pure mathematics, he'd be in #ocaml
17:35:35 <Veinor> well, / 1000 will give you an int
17:35:37 <Berengal> That should take care of any bots
17:35:39 <copumpkin> I mean, impure
17:35:43 <mreh> newtype RandomGen g => RandomArrow a b c = RAT (StateArrow g a b c) -- what's wrong with this?
17:35:48 <mreh> type dependency?
17:35:49 <Cale> dh__: Nah, the reason I'm good at Haskell has little to do with that :)
17:36:02 <Cale> dh__: and more to do with the fact that I started around 2001 or 2002 or so.
17:36:15 <mreh> ghc tells me 'g' is not in scoep
17:36:20 * ddarius started in early 2002.
17:36:24 <copumpkin> mreh: it probably isn't
17:36:26 <dh__> my point is : the learning curve for haskell is ,,, too high .
17:36:33 <copumpkin> dh__: no it isn't
17:36:39 <soupdragon> just take it slow
17:36:40 <soupdragon> there's no rush
17:36:41 <copumpkin> steep, maybe :)
17:36:43 <Cale> It took me about two months before I felt like I could do anything with Haskell, and about a year to really feel comfortable with it.
17:36:54 <dh__> even I believe I'm smart , but haskell still too difficulty for me.
17:36:55 <mreh> same here
17:36:58 <Berengal> Same as Cale for me
17:37:05 <aavogt> I don't believe I'm smart
17:37:09 <mreh> copumpkin: but it says g is not in scope the first time
17:37:09 <copumpkin> dh__: you're probably just used to other languages
17:37:15 <dh__> steep, yes. English is not my first language.
17:37:16 <Cale> Treat it like you're learning your first programming language.
17:37:24 <Axman6> dh__: haskell really isn't that hard, it's just maths with patern matching
17:37:30 <pikhq> dh__: It's steep, but there really is nothing that could be done to make it easier without making it... Feel like Haskell.
17:37:31 <Cale> It probably took about as long to learn that.
17:37:32 <Berengal> In comparison, it took me a week before I felt like I could do anything in Java, and I still don't feel comfortable with it
17:38:05 <temoto> Could anyone help to shift sigmoidal 1 / 1 + exp (-x) function 6 units to right?
17:38:19 <dh__> When I'm learning haskell, I'm always directed to a paper, like GADT, Monad, etc and I can't understand them.
17:38:46 <dh__> I even tried to learn Category theory myself, and I did success to understand them now.
17:38:47 <copumpkin> dh__: maybe you're trying to run before you can walk
17:38:51 <Axman6> dh__: well read a tutorial first, learn the language before moving onto more difficult topics
17:38:52 <Cale> dh__: Oh, you don't have to read the paper on GADTs
17:38:55 <Berengal> dh__: Just go program stuff instead, and read beginner tutorials. Don't worry about the advanced stuff
17:39:21 <dh__> thanks guys.
17:39:23 <Cale> dh__: If you're just interested in programming, it's not required to learn any category theory.
17:39:24 * BMeph is reminded of a saying: Friends help you move; Real friends help you move sigmoids. 8D
17:39:34 <gwern> what
17:39:43 <dh__> I fact , I'm interested in category theory , and algebra of programming.
17:40:00 <Cale> dh__: Okay then :)
17:40:02 <soupdragon> me too
17:40:05 <temoto> dh__, don't lie to yourself :)
17:40:09 <soupdragon> I found it very difficult to study these things dhuogh
17:40:10 <dh__> just found Richard Bird's book is so hard to follow.
17:40:30 <dh__> yes, I'm really interested in category .
17:40:46 <soupdragon> I just know the basic definitions for category theory
17:40:57 <soupdragon> even that took months
17:41:05 <ddarius> temoto: translate f dx = \x -> f (x - dx)
17:41:08 <Cale> temoto: Did you figure it out? Just compose on the right with a translation.
17:41:08 <Berengal> I know that a category is a typed monoid, and that's good enough for me for now
17:41:15 <soupdragon> and I am not even sure what it's for
17:41:19 <edwardk> dh_: Bird had a very peculiar style to him. Have you tried something like real world haskell?
17:41:22 <Pseudonym> The good thing about category theory, though, is that it has a steep learning curve at the start, but it gets more shallow.
17:41:23 <lambdabot> Pseudonym: You have 1 new message. '/msg lambdabot @messages' to read it.
17:41:24 <Berengal> I am contemplating getting a degree in mathematics instead of computer science though
17:41:41 <dh__> real world haskell ? a book ?
17:41:43 <edwardk> Berengal: its handy to have
17:41:49 <Cale> Berengal: A typed monoid, or a preorder with semantics :)
17:41:54 <winxordie> Berengal - some propaganda: Do it! Best thing I ever did. :P
17:41:59 <dh__> I like pointfree style of programming, product, coproduct stuff.
17:42:01 <ddarius> Berengal: The "typed monoid" perspective tends to be less useful than the "poset with multiple ways to be <=" perspective.
17:42:08 <edwardk> dh__: http://book.realworldhaskell.org/
17:42:11 <Pseudonym> soupdragon, if it's any consolation, I've been at it for five years, and I still don't have a good intuition about what an adjunction is.
17:42:14 <Cale> s/poset/preorder/
17:42:26 <dh__> thanks edwardk.
17:42:33 <Pseudonym> I know plenty of examples, but I don't have a good intuition.
17:42:33 <Cale> People like posets a lot, but it's funny that preorders don't receive more attention
17:42:35 <soupdragon> I have read about adjunction that stuff seems wild
17:42:44 <edwardk> cale: agreed
17:42:54 <Berengal> edwardk: I know. Math is fun! Unfortunately, CS is also fun, so right now I've got no degree at all
17:42:54 <ddarius> Pseudonym: Forget intuition, just Hom(FA,B) ~ Hom(A,UB), all you need to know
17:43:03 <edwardk> Berengal: get both
17:43:04 <copumpkin> Pseudonym: I thought that the galois connection view was what "made it click" for me
17:43:06 <cads> temoto, sin^-1(x) has a domain of [-1,1] and looks _kinda_ like the sigmoid
17:43:09 <soupdragon> There is this programming language (CPL) which lets you define lambda as an adjunction
17:43:13 <Pseudonym> Yes, that helped, I have to admit.
17:43:22 <Pseudonym> ddarius: But compare that to, say monads.
17:43:30 <soupdragon> everything in that language is defined by adjunctions
17:43:30 <Pseudonym> I can "see" monads when programming.
17:43:31 <Berengal> edwardk: Well, yes, but which one first, and do I get my masters right after, or do I take two bachelors?
17:43:33 <edwardk> Berengal: i'd say it worked for me, but the consequences are mostly that i just wound up with twice as many student loans in half the time. ;)
17:43:50 <Pseudonym> The overloaded semicolon view, the generalised sequence view, the term substitution view...
17:43:58 <soupdragon> but aren't programming monds just a tiny fragment of the full picture of monads?
17:43:59 <ddarius> Pseudonym: There are plenty of adjunctions in programming that are very direct.  Monads in programming tend to be special cases.
17:44:02 <Cale> Pseudonym: Did you see my series of articles about adjunctions?
17:44:06 <Pseudonym> I have enough disparate examples that I can "see" them.
17:44:07 <edwardk> soupdragon: yes
17:44:17 <Berengal> edwardk: Heh. I've already got a job as an Enterprise Java (tm) monkey, so I've got the money, but no degree
17:44:34 <Cale> Pseudonym: I'm... not sure that they'll really help, since I actually agree with you that it would be good to have yet more intuition about adjunctions.
17:44:35 <ddarius> Berengal: What do you need the degree for then?
17:44:45 <Berengal> ddarius: Fun and adventure
17:44:45 <copumpkin> is it celsius?
17:44:50 <Cale> But I describe a bunch of ways to look at them anyway.
17:44:56 <aavogt> it's absolute
17:45:00 <edwardk> ddarius: kinda handy when the economy turns and enterprise java monkeys are out of fashion
17:45:14 <ddarius> Berengal: If I could just give you a (valid) degree, would that provide "fun and adventure"?
17:45:16 <Berengal> ddarius: Also, my employer didn't really like me sneaking in the back door and showing initiative the way I did when I got the job, so they're going "yeah, you should probably do that"
17:45:27 <Cale> http://analogical-engine.com/wordpress/?page_id=232 -- they're linked from here :)
17:45:28 <ddarius> Berengal: Okay, -that- is a good reason.
17:45:33 <soupdragon> speaking of galois connections - I was like 'hm I wonder if there are any more (than galois theory)' ... and it turns out _EVERYTHING_ is a galois connection
17:45:34 <temoto> ddarius, Cale thanks, translation helped.
17:45:37 <Berengal> ddarius: No. It's not the degree that's important, it's being able to get one
17:45:52 <ddarius> Berengal: However, it sounds like what you want is the knowledge/learning experience, not the piece of paper.
17:45:53 <copumpkin> oh I like Cale's index
17:46:04 <edwardk> soupdragon: which is a kind of adjunction ;)
17:46:09 <Berengal> ddarius: For me anyway. My employer thinks otherwise, but they're really not that important in this equation
17:46:19 <Cale> It's been too long since either one of us has written an article on that blog.
17:46:35 <soupdragon> What I really want with category theory, is to learn a little bit of the basics.. then have a category theory based introduction to category theory
17:46:37 <ddarius> soupdragon: Consider the embedding of integers into the reals, and then consider floor and ceiling.
17:46:42 <soupdragon> i.e. they can use basic category theory to define everything
17:46:47 <temoto> cads, sin^-1(x) ?
17:46:47 <soupdragon> but maybe I have to do that myself
17:46:50 <Berengal> ddarius: Indeed. The only problem with that is that I'm a very good autodidact whom is easily bored at school. That's the reason I dropped out in the first place.
17:46:54 <soupdragon> (in which case I probably get it wrong)
17:47:11 <soupdragon> ddarius: yes stuff like that! it's amazing
17:47:17 <soupdragon> they are like everywhere
17:47:50 * ddarius should formulate Kan extensions in pre-order categories.
17:47:52 <temoto> cads, i can't understand what that symbolic means. sin of what?
17:47:54 <codolio> Adjunctions are even more everywhere.
17:48:08 <Pseudonym> I think the world needs a good book on category theory that lies between "Conceptual Mathematics" and "Categories for the Tenured Mathematics Professor".
17:48:13 <temoto> cads, sin(x) ** -1 ?
17:48:18 <cads> hmm, arcsin doesn't look at all like the sigmoid
17:48:20 <soupdragon> I think it would be really cool to have a category theory book defined in terms of category theory
17:48:22 <copumpkin> codolio: more everywhere than what?
17:48:27 <Pseudonym> My working title is "Abstract Nonsense: Categories for the Armchair Mathematician".
17:48:30 <codolio> Than Galois connections.
17:48:33 <cads> temoto: I was thinking about the inverse sine function
17:48:40 <winxordie> Pseudonym: I look forward to the "$X for the Tenured Mathematics Professor" Series.
17:48:45 <soupdragon> because when I first learned about category theory I felt a bit sick like I was looking down from a high building with vertigo
17:49:04 <copumpkin> codolio: ah yes
17:49:04 <soupdragon> because I could see that everything being defined could be made into one
17:49:08 <edwardk> winxordie: i love the title. Haskell for the Tenured Mathematics Professor is a surefire win ;)
17:49:08 <copumpkin> Has anyone really been far as decided to use even go want to do look more like?
17:49:11 <soupdragon> and it was like an infinite recursion
17:49:38 <gwern> copumpkin: felicia day goes lolwut
17:49:39 <winxordie> edwardk: That'd catch on like wildfire across math departments all around. We can get marketing!
17:49:42 <Pseudonym> You know what I mean, though.  Either they introduce natural transformations on page 2, or they introduce them at the end of the book.
17:49:45 <ddarius> edwardk: Once you get tenure, why would you learn anything?
17:49:50 <temoto> i found this excellent web tool to experiment with function graphs http://rechneronline.de/function-graphs/
17:49:54 <edwardk> though I must admit you'd have better sales targeting the untenured mathematics professor, as hunting tenureship is like snipe hunting these days ;)
17:49:59 <ddarius> Pseudonym: Natural transformations should be introduced on page two.
17:50:00 <Pseudonym> There are no books that I'm aware of that introduce them in chapter 3.
17:50:11 <Pseudonym> Not in the book that I envisage.
17:50:17 <gwern> ddarius: reminds me of the joke comparing a tenured professor to a rooted sea filter - they both no longer have any need for a nervous system and so digest them
17:50:20 <ddarius> Pseudonym: There are several that have chapter 1 categories, chapter 2 functors, chapter 3 natural transformations.
17:50:21 <winxordie> Yeah, tenure hunting's gonna be interesting >_<
17:50:30 <Pseudonym> Maybe.
17:50:31 <winxordie> might as well call it treasure hunting >_<
17:50:44 <Cale> There should be books about categories for many other sorts of people. What about "Baby's First Categories", "Categories for Suicidal Teens", and "Practical Categories for the Botanical Enthusiast"?
17:51:01 <copumpkin> Pseudonym: awodey introduces them in the middle
17:51:11 <Pseudonym> Actually, now that I look in Asperti and Longo, it's chapter 1 categories, chapter 2 constructions, chapter 3 functors and nat trans.
17:51:20 <Berengal> "Categories for Dummies"
17:51:25 <winxordie> Categories for Suicidal Teens would get a good number of the beginning comp. sci. students I feel.
17:51:25 <soupdragon> Cale haha yeah
17:51:34 <soupdragon> I have read category theory for babies
17:51:38 <soupdragon> that 'Conceptual Mathematics' book
17:51:42 * Pseudonym tries to imagine category theory and angst poetry
17:51:50 <soupdragon> and I look at various category theory for people with computers
17:51:58 <Pseudonym> Actually, you'd need to put vampires in it these days.
17:51:58 <soupdragon> and there is category theory of set theory
17:52:09 <soupdragon> but what i would like to read next is category theory for category theorists
17:52:10 <copumpkin> someone should write category theory for wannabe haskellers
17:52:20 <copumpkin> or is there already one?
17:52:27 <cads> category theory for ninjas
17:52:30 <winxordie> Pseudonym: "Ode to the Bloo-sucking, Sparkly Monoid?"
17:52:34 <winxordie> *blood
17:52:41 <copumpkin> what happened to that's his name anyway?
17:52:46 <copumpkin> the ninja dude
17:52:52 <copumpkin> *what's
17:52:52 <Pseudonym> Ask a Ninja?
17:52:54 <cads> soup dragon - CT for babies?
17:53:01 <copumpkin> pokokokokokoko
17:53:01 <tensorpudding> Natural transformations on page two sounds like a stretch.
17:53:05 <ddarius> copumpkin: He finally left, no doubt to return under a different nick in a few months.
17:53:07 <copumpkin> HaskellLove
17:53:12 <Berengal> Somehow I feel "Categories for Practicing Nonconformists" will flop...
17:53:18 <tensorpudding> What do you cover on page one?
17:53:25 <Pseudonym> And if you've got Categories for Ninjas, you need Categories for Pirates too.
17:53:25 <ddarius> tensorpudding: Categories and functors.
17:53:26 <copumpkin> tensorpudding: categories!
17:53:42 <Pseudonym> Universal arrrrrows!
17:53:52 <tensorpudding> You can define categories pretty quick.
17:54:05 <tensorpudding> After you define functor, you can give examples.
17:54:07 <ddarius> tensorpudding: You can define all of those pretty quick and they are relatively straightforward.
17:54:24 <tensorpudding> Functors are easy enough.
17:54:26 <ddarius> And they get you to the real meat, universal properties.
17:54:27 <temoto> cads, it looks like 1 / (1 + exp ( (-x + 0.5) / 0.1 )) does the right thing. :)
17:54:32 <Pseudonym> The trouble is that monads are like burritos.
17:54:34 <tensorpudding> Natural transformations are harder
17:54:52 <Pseudonym> Natural transformations are easy to grok, in that they're just functor homomorphisms.
17:54:58 <temoto> boy i even recalled that math fun in school
17:55:02 <Pseudonym> I got that in about ten seconds.
17:55:06 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25543#a25543 -- finally it's finished
17:55:08 <Pseudonym> However, it took me a while to get this:
17:55:11 <Pseudonym> @free F a -> G a
17:55:11 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
17:55:12 <mreh> he says hopefully
17:55:15 <Pseudonym> Dammit.
17:55:28 <ddarius> Pseudonym: D^C^2 ~ D^2^C, so you could just introduce the arrow category and functors.
17:55:30 <codolio> @free t :: F a -> G a
17:55:30 <soupdragon> cads what?
17:55:30 <lambdabot> $map_G f . t = t . $map_F f
17:55:31 <Pseudonym> @ft (Functor f, Functor g) => f a -> g a
17:55:32 <lambdabot> Done.
17:55:34 <Pseudonym> That's it.
17:55:41 <tensorpudding> But natural transformations means that you're not having a lot of dialogue on page one, anyway.
17:55:51 <copumpkin> that's so pretty
17:55:52 <aavogt> @fft
17:55:53 <lambdabot> Done.
17:56:08 <soupdragon> I still don't get what free has to do with naturality
17:56:19 <Pseudonym> The natural transformation property IS the free theorem.
17:56:29 <Pseudonym> That's what really made it click.
17:56:52 <tensorpudding> There's a lot of boilerplate books put in front to make sure the reader knows what's going on
17:56:55 <Pseudonym> What's so "natural" about a natural transformation?  It's the "forall a".
17:57:00 <ddarius> Indeed, if you are familiar with polymorphic functions, the concept of natural transformation should be rather natural.  However, it can be a bit misleading if you aren't careful.
17:57:08 <Pseudonym> Yeah, that's true.
17:57:14 <ddarius> A good way to avoid that problem is to work out the details of the free monoid adjunction.
17:57:19 <tensorpudding> What is the bias of the reader of this book?
17:57:19 <mreh> dons: is a patch that makes frag compile any use to you?
17:57:36 <ddarius> Defining the counit requires paying a bit more attention to what you actually have.
17:57:48 <cads> <soupdragon> I have read category theory for babies <- which book is that?
17:57:56 <Pseudonym> Sure.  But as far as intuition goes, I don't think you can beat that.
17:58:01 <soupdragon> I already said: Conceptual Mathematics
17:58:05 <Pseudonym> At least for a Haskell programmer
17:58:22 <copumpkin> unnatural transformations
17:58:23 <ddarius> Pseudonym: I agree, I think it is the most natural analog to consider.
17:58:31 <copumpkin> unnaturalCoerce
17:58:42 <tensorpudding> (do we need more category theory books)
17:58:53 <Pseudonym> tensorpudding: Yes.  Next question?
17:58:53 <ddarius> tensorpudding: Yes.
17:59:05 <soupdragon> so whose writing a category theory book?
17:59:10 <tensorpudding> But what's the niche?
17:59:11 <soupdragon> it would be cool if you did it like RWH
17:59:11 <Pseudonym> None fit the "sweet spot" of the typical person on #haskell.
17:59:19 <soupdragon> like umm
17:59:23 <soupdragon> on a webpage that i can read ;P
17:59:25 <tensorpudding> Okay, so the niche is functional programmer
17:59:29 <Cale> Categorical JSON parsers
17:59:30 <Pseudonym> Yeah.
17:59:36 <soupdragon> btw graham hutton did a really good set of intro notes
17:59:40 <copumpkin> categorical fibonacci golfing
17:59:48 <soupdragon> if you are still at the totally ignorant level which I am at
17:59:52 <soupdragon> I need to look at every intro
17:59:58 <copumpkin> soupdragon: you should write it!
17:59:59 <soupdragon> because I just forget it ajj..
18:00:00 <Pseudonym> People who want to use category theory in anger in their programs.
18:00:02 <ddarius> soupdragon: Except that he stops right when it gets interesting.
18:00:08 <copumpkin> soupdragon: no better way to learn something than to teach it to others
18:00:12 <soupdragon> well I did write my own category theory  notes in a wiki but that was just for me to remember
18:00:14 <tensorpudding> Categories for the Working Lambdasmith.
18:00:23 <Pseudonym> tensorpudding: Think of it this way.  Category theory is the Design Patterns of mathematics.
18:00:45 * soupdragon suffers an allergic reaction
18:00:51 <Pseudonym> So there should be a book aimed at the same level.
18:01:01 <ddarius> I think the Barr and Wells lecture notes are the closest to meeting that demographic.
18:01:09 <copumpkin> yep!
18:01:18 <copumpkin> they be good
18:01:18 <tensorpudding> Which demographic?
18:01:41 <soupdragon> one other thing is, it would be really nice to have lots and lots of problems
18:01:44 <ddarius> tensorpudding: A functional programmer without a very extensive mathematical background.
18:01:54 <Pseudonym> And it'd also be nice if they were problems that you could solve in Haskell.
18:01:57 <soupdragon> like things to categorize.. and things which have excellent  simple solutions when expressed in category theory
18:02:13 <soupdragon> missing out on these is very hard for a beginner like me, because I cannot really come up with it myself
18:02:42 <tensorpudding> I don't think I'm thinking of the same Barr and Wells
18:02:49 <cads> just study, oh, algebraic geometry
18:02:51 <soupdragon> one of the very good 'case studies' is unification algorithm as coequalzer
18:02:57 <ddarius> tensorpudding: The lecture notes, not the book.
18:03:01 <tensorpudding> Oh.
18:03:08 <tensorpudding> So not Toposes Triples & Theories.
18:03:28 <ddarius> tensorpudding: There's a different book as well, but definitely not that.  Though the first chapter does have some excellent exercises.
18:04:03 <cads> soupdragon: woah, lawvere.. this looks cool
18:04:23 <Pseudonym> cads: That's "Conceptual Mathematics"?
18:04:26 <cads> yeah
18:04:44 <Pseudonym> Yeah, it's an excellent book, but it doesn't cover as much ground as we need.
18:04:46 <ddarius> I particularly like their (Coequalizer can be big) exercise.  There are two functors from the terminal category (one object, no non-identity arrows) to the category that looks like 0 -> 1.  Describe the coequalizer of those two functors.
18:04:50 <codolio> Conceptual Mathematics is for, like, early high school students.
18:05:10 <dolio> I can only assume.
18:05:22 <cads> it seems like most cat theory for programmers type introductions are like "here's a cartesian closed category, it interprets a lambda calculus, have a ball!"
18:05:32 <ddarius> Computational Category Theory by Rod Burstall is another good one for programmers, but it takes a decidedly different perspective.
18:05:38 <Pseudonym> Yeah, Asperti and Longo do that.
18:05:58 <Pseudonym> I think there's a book that could be written which uses category theory as the formul
18:06:06 <Pseudonym> as a formulation for organising software.
18:06:07 <dolio> People who don't understand what a function is yet, and such.
18:06:15 <Pseudonym> i.e. Haskell programs
18:06:17 <soupdragon> The other question is, Once I 'know' category theory... what will I be able to do with it?
18:06:20 <ddarius> Pseudonym: I believe there may be related to Goguen's work.
18:06:32 <soupdragon> It's not clear where I am going, if I study this stuff
18:06:33 <Pseudonym> Barr and Wells did talk about module signatures, IIRC.
18:06:42 <ddarius> Pseudonym: I don't think so.
18:06:52 <soupdragon> I thik that is another reason why it can take a very long time
18:06:59 <Pseudonym> IS-A is-a monomorphism.
18:07:04 <cads> as a programmer better to learn that category theory is Java certification, no?
18:07:24 <ddarius> soupdragon: It's most handy for compactly understanding other mathematics and for organizing concepts.  It can be used in more direct means a la Computational Category Theory.
18:07:33 <Pseudonym> You'll be more likely to be using category theory in 20 years' time than Java certification.
18:08:18 <cads> Pseudonym: I was being facetious :)
18:08:46 <cads> I think mathematicians have a secret disdain for programmers
18:09:14 <mdmkolbe> Parsec is some variant of LL which doesn't do left recursion, right?  Are there any parser combinator libraries out there that do left recursion?
18:09:16 <ddarius> Pseudonym: http://cseweb.ucsd.edu/~goguen/projs/swarch.html perhaps
18:09:29 <cads> if you ask a mathematician about category theory for programming they'll scoff and say the category theory used for programming is just a small shadow of the real CT
18:09:46 <Pseudonym> Thanks, I'll take a look ddarius.
18:09:51 <ddarius> mdmkolbe: It's a recursive descent parser (modulo being embedded into Haskell) and so has the problems that all recursive descent parsers have.
18:10:15 <ddarius> cads: Some parts of it are deep, but it is not broad.
18:10:19 <Pseudonym> cads: Of course it is.  And the monoids and total orders that you see in the Prelude are also a shadow of real algebra.
18:10:23 <Pseudonym> That's not the point.
18:10:31 <theorbtwo> Naturally, the CT that can be implemented in finite memory is not the true CT.
18:11:43 <mdmkolbe> ddarius: but some recursive desent parsers *can* to left recursion (though they are a bit obscure)
18:11:55 <dolio> That's funny, because a while back, some of the professional category theorists at the n-category cafe were going on about how they don't have a very good understanding of coalgebras, because as mathematicians, they never use them.
18:12:15 <soupdragon> they should get some non-well-founded sets
18:12:21 <ddarius> mdmkolbe: The parser combinators that use a breadth-first approach should work.
18:12:22 <soupdragon> why dont we have that in set theory
18:12:26 <dolio> Whereas they're more common in programming.
18:12:39 <Cale> cads: It's partly intentional that the CT used for programming is a small shadow of full category theory, and partly because we still need to look into how a lot of things might be useful to programming.
18:12:45 <ddarius> dolio: Yeah, though mathematicians use them more often than they think in disguised forms.
18:12:55 <dolio> Yes.
18:15:19 <soupdragon> this is inspired me I am going to study category theiory aain
18:15:21 <soupdragon> again
18:15:38 <tensorpudding> They teach category theory to computer programmers to lure them into pure mathematics.
18:16:02 <edwardk> tensorpudding: they teach it to physicists for the same reason
18:16:06 <tensorpudding> Heh.
18:16:06 <soupdragon> I think it would be cool to use mathematics to make programming easier, but a lot of poeple seem to think mathematics only makes thing harder
18:16:07 <edwardk> its mathematical crack
18:16:43 <mdmkolbe> edwardk: for computer science I understand, but where does CT find application in physics?
18:16:44 <tensorpudding> Edward Witten is a mathematics turncoat, string theory is the collective enslavement of physicists into furthering abstract mathematics.
18:17:20 <copumpkin> mdmkolbe: ask baez!
18:17:25 <dolio> mdmkolbe: One of the guys at the n-category cafe does category theory specifically for physics.
18:17:27 <copumpkin> cousin of a great folk singer
18:17:28 <edwardk> http://math.ucr.edu/home/baez/ look up the n-category cafe ;)
18:17:29 <tensorpudding>  Try reading the N-Category Cafe, and the stuff that John Baez writes about
18:17:57 <edwardk> as 10 people reply with the n-category cafe ;)
18:18:07 <tensorpudding> Heh.
18:18:08 <copumpkin> :)
18:18:52 <edwardk> typical physicist stuff, the simple version doesn't fit our constraints so lets add more dimensions until i can't prove that the system i'm working with can't fit inside my model
18:19:04 <cads> mdmkolbe: there is a good paper about how category theory find application wherever there is a notion of "process"
18:19:27 <Veinor> edwardk: haha
18:19:38 <edwardk> cads: a closed cartesian category is a pretty gosh darn good place to run the lambda calculus ;)
18:20:16 <tensorpudding> monoids everywhere just want to be free
18:20:28 <edwardk> but free monoids are boring
18:20:29 <cads> mdmkolbe: It's called Categories for the practicing physicist: http://arxiv.org/abs/0905.3010
18:20:47 <Pseudonym> I liked the Rosetta Stone paper, too.
18:20:51 <tensorpudding> free groups are boring too
18:21:02 <copumpkin> free abelian groups!
18:21:17 <ddarius> mdmkolbe: Category theory came out of algebraic topology.  Topology has a lot of application to physics.
18:21:17 <Pseudonym> http://arxiv.org/abs/0903.0340
18:21:23 <cads> mdmkolbe: and remember categories were invented to study groovy things in algebraic topology, and all that crazy manifold stuff is very useful in physics
18:21:30 <cads> ddarius: jinx :P
18:21:31 <edwardk> hrmm i need to back port my reverse ad code into my monoids library
18:21:47 <tensorpudding> free abelian groups?
18:21:52 <copumpkin> :P
18:22:00 <copumpkin> http://en.wikipedia.org/wiki/Free_abelian_group
18:22:21 <ddarius> edwardk: Programmers are -extremely- fond of free monoids.
18:22:24 <edwardk> I always thought that "The Abelian Group" would make an awesome name for an investments holding company
18:22:26 <ddarius> As well as free pointed magmas.
18:22:47 <copumpkin> edwardk: you should found it!
18:22:51 <tensorpudding> Oh, they're not actually free groups.
18:23:10 <tensorpudding> The only free groups that are abelian are isomorphic to the trivial group or Z
18:23:14 <cads> the only group of people more fond of molten hot magmas are the Super-Villians
18:23:16 <ddarius> tensorpudding: Of course free abelian groups are not free groups.
18:23:27 <edwardk> copumpkin: i think i own sylowgroup.com actually ;)
18:23:47 <copumpkin> :o
18:23:52 <Pseudonym> tensorpudding: Hang on, so why is ZxZ under pairwise addition not a free abelian group?
18:24:27 <tensorpudding> Okay, so there's a difference between an "abelian free group" and a "free abelian group"
18:24:33 <Pseudonym> Ah.
18:24:38 <Pseudonym> Yes, that makes sense.
18:24:47 <Pseudonym> abelian (free group) vs free (abelian group)
18:24:52 <tensorpudding> because apparently there is a concept of being "free abelian"
18:24:54 <tensorpudding> Which I didn't know.
18:25:04 <Pseudonym> Or (free abelian) group
18:25:14 <edwardk> copumpkin: er nope it appears i let that one lapse ;)
18:25:51 <ddarius> There's a concept of "free" and it can be applied to the category of groups and the category of abelian groups.
18:25:53 <Pseudonym> The Free Abelian group was a PAC set up to release Abel from prison?
18:29:20 <winxordie> *groan*
18:29:29 * ddarius should really eat some real food today.
18:30:16 <tensorpudding> Hmm, free modules
18:30:22 <tensorpudding> of course
18:30:51 <ddarius> I like all the relations between abelian group, group, ring, module, and algebra theory.
18:31:06 <ddarius> As well as group/monoid actions.
18:31:32 <tensorpudding> They're quite incestuous.
18:32:06 <tensorpudding> algebras are like...generalized rings
18:32:58 <dolio> An abelian group is a monoid object in the category of groups, right? Or am I thinking of commutative monoids?
18:33:47 <dolio> I guess I'm thinking of monoids.
18:33:49 <tensorpudding> the endomorphisms on a group form a monoid
18:33:51 <winxordie> algebra's more like obsessive compulsive disorder with magmas.
18:33:56 <ddarius> dolio: I believe a group object in a group (or a category of group enriched groups) is an abelian group (category of abelian groups).
18:34:32 <ddarius> tensorpudding: Endomorphism on any set form a monoid.  Perhaps you meant to say "ring" or some such?
18:35:09 <ddarius> dolio: http://en.wikipedia.org/wiki/Eckmann%E2%80%93Hilton_argument  This is what you are thinking of, no?
18:35:47 <dolio> ddarius: I've never bothered working through the actual argument. Just random trivia I've picked up.
18:36:33 <napping> So, is there foundational semantics work that considers memory models? I've been looking at Ynot, but it doesn't speak of concurrency
18:36:54 <ddarius> dolio: Well wikipedia says a group object in monoids (or groups) is an abelian group.  I would work it out just for the heck of it.
18:37:22 <tensorpudding> what's a group object?
18:37:49 <dolio> It's the categorical definition of a group.
18:37:54 <dolio> Like a monoid object.
18:37:59 <tensorpudding> is that a monoid with all the arrows isomorphisms?
18:38:23 <ddarius> tensorpudding: No.  You're thinking of a groupoid which is a category with all arrows isomorphisms.
18:38:52 <ddarius> tensorpudding: If you take the standard definition of groups, and rewrite it using categorical notation, and then generalize to any category rather than Set, you get a group object.
18:38:53 <dolio> Object G with morphisms e : 1 -> G, n : G -> G, m : G x G -> G that satisfies various identities.
18:39:56 <tensorpudding> Where did I get my mistaken view of what monoids in categories are...
18:40:42 <dolio> You're thinking of monoids/groups as a category.
18:40:48 <ddarius> A groupoid on one object is (like any category on one object) a monoid and also a group.
18:40:50 <dolio> Not foo-objects in a category.
18:41:15 <tensorpudding> Groupoids are weaker than groups though
18:41:49 <temoto> http://codepad.org/tKTfHhsY please help to fight the monad :)
18:41:55 <ddarius> tensorpudding: Groupoids are like typed groups.
18:42:02 <tensorpudding> i.e. all groups should be groupoids but not all groupoids are groups
18:42:09 <tensorpudding> unless the definition here is in conflict
18:42:10 <ddarius> tensorpudding: Note though, that the term "groupoids" refers to three distinct concepts.
18:42:52 <dolio> monoid : category :: group : groupoid
18:43:14 <temoto> basically, i have a function which returns IO a and i need to use a in map.
18:43:21 <tensorpudding> Well that is a poor choice, having multiple different conflicting definitions of what a groupoid.
18:43:39 <ddarius> tensorpudding: Groupoid a la a category with only isomorphisms is not the same as the abstract algebra groupoid which is just a magma.
18:43:51 <cads> what's a good reference for finding out trivial like what category is dual to Set?
18:44:04 <tensorpudding> I regret having heard of groupoids.
18:44:15 <ddarius> cads: The category that is dual to Set is the category of complete atomic Boolean algebras.
18:44:20 <tensorpudding> I'd gotten used to calling them magmas, which is an unambiguous name.
18:44:29 <ddarius> cads: But I'm not aware of any reference of random CT facts.
18:44:46 <ddarius> tensorpudding: I don't think "groupoids" is used too often for "magma."
18:45:10 <tensorpudding> It's what I learned.
18:45:38 <ddarius> I don't think people talk about magmas (under any name) all that much.
18:45:53 <tensorpudding> We didn't use them.
18:46:12 <tensorpudding> But we did talk about semigroups, monoids and groupoids.
18:47:55 <Cale> groupoid is the old term for magma. The sense of "category with only invertible arrows" has largely supplanted it.
18:48:03 <winxordie> ddarius: maybe it's where I am, but my algebra profs talk about magmas all the time.
18:48:26 <Cale> (since that's more obviously group-like, and more important anyway)
18:49:12 <dolio> Perhaps they've been strong-armed by the number theorists, and so talk about the (Nat,+) magma.
18:49:31 <ddarius> dolio: ?
18:49:53 <dolio> We were talking a day or two ago about how number theorists like to say 0 isn't a natural number.
18:50:17 <ddarius> dolio: Then it would still be a semigroup.
18:50:17 <gwern> they do?
18:50:39 <ddarius> Torsors are really nice, underused things.
18:50:42 <dolio> Oh, magma doesn't even require associativity?
18:50:45 <dolio> Geeze.
18:51:03 <ddarius> dolio: The free magma is the set of non-empty binary trees.
18:51:09 <cads> dolio: I saw N defined in a book as {1, 2, 3, ...} and it was pretty wierd, at first I thought it was a bad typo
18:51:19 <winxordie> all you need is closure from my memory.
18:57:06 <heropass> 0 is only about 1200 years old
18:57:12 <heropass> the other numbers are much older
18:57:30 <heropass> so 0 isn't as natural as the counting numbers, apparently
18:57:57 <danharaj> It depends on what you mean by counting.
18:58:04 <temoto> http://codepad.org/tKTfHhsY please help to fight the monad :)
18:58:35 <gwern> temoto: mapM comes to mind
18:58:43 <gwern> or liftM
18:59:16 <gwern> temoto: where the IO coming from anyway?
18:59:25 <gwern> I don't see anything obviously io
18:59:40 <temoto> gwern, calcHiddenNeuron :: Machine -> Int -> IO Neuron
18:59:55 <temoto> that's what i need to map with
19:00:31 <gwern> and is data Layer = Layer [IO Neuron]?
19:01:17 <temoto> no, it's pure Layer [Neuron]
19:01:24 <temoto> of course
19:02:17 <gwern> temoto: if you try to map a foo -> IO Neuron on a [foo], what's the sig of the result?
19:02:59 <gwern> :type map
19:03:14 <gwern> @botsnack
19:03:14 <lambdabot> :)
19:03:18 <gwern> @type map
19:03:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:03:19 <temoto> gwern, [IO Neuron] obviously
19:03:28 <ville> Is there some sort of namespace mechanism in Haskell or is using prefixing for identifiers the custom?
19:03:44 <Axman6> :t sequence
19:03:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:04:01 <copumpkin> ville: modules
19:04:09 <Axman6> sounds like you wan fmap Layer . sequence
19:04:10 <gwern> temoto: so you're making a [IO Neuron] with your mapped function, and passing it to something that expects [Neuron]?
19:04:10 <temoto> ville, modules provide namespaces, prefixing is commonly used too.
19:04:25 <temoto> gwern, yes, exactly.
19:04:37 <ville> just that I've checked few libraries so far and seems like prefixing is rampant.
19:04:45 <temoto> gwern, that's what i want in the end.
19:05:46 <gwern> temoto: but in the end, you still need to do IO. so perhaps you ultimately want IO (Layer [Neuron]), which you can <- to a name
19:06:01 <temoto> Axman6, ... . sequence $ map ... ?
19:06:15 <Axman6> actually, mapM
19:06:18 <Axman6> :t mapM
19:06:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:06:32 <Axman6> which is sequence . map f btw
19:06:37 <Axman6> @src sequence
19:06:38 <lambdabot> sequence []     = return []
19:06:38 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:06:38 <lambdabot> --OR
19:06:38 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
19:06:44 <gwern> gee thanks a lot Axman6
19:06:51 <gwern> just give him the answer why don't you
19:07:17 <Axman6> why not? all i saw was him struggeling to formulate the question
19:08:39 <temoto> i was trying permutations of <- in do and pure '=' in where with very little understanding of why
19:09:40 <temoto> maybe it's because it's morning already, or maybe i never understood it for good
19:11:10 <temoto> So the final thing that worked is   new_hidden <- fmap Layer . mapM (calcHiddenNeuron machine) [0..len]
19:11:35 <gwern> yeah but now you don't know why that works
19:11:52 <temoto> Yes, i don't really get what fmap is supposed to do there.
19:12:12 <pikhq> ville: import qualified Foo -- You want something like this?
19:12:18 * gwern had started explaining that when Axman6 butted in
19:12:35 <pikhq> (after a qualified import, you access things from the module using Foo.bar)
19:12:39 <temoto> oh common
19:13:03 <pikhq> import qualified Foo as Bar -- IIRC, this works if you want a shorter prefix
19:13:06 <Axman6> > fmap Just [1,2,3]
19:13:07 <lambdabot>   [Just 1,Just 2,Just 3]
19:13:33 <ville> pikhq: I was more wandering about the common naming conventions used.
19:13:51 <temoto> fmap f . g   is   (fmap f) . g  or   fmap (f . g) ?
19:13:52 <gwern> > fmap (\x -> Just x) (return "foo")
19:13:53 <lambdabot>   No instance for (GHC.Show.Show
19:13:53 <lambdabot>                     (f (Data.Maybe.Maybe [GH...
19:13:58 <gwern> bleh
19:14:05 <gwern> > fmap (+1) (Just 5)
19:14:06 <lambdabot>   Just 6
19:14:24 <pikhq> ville: Well. Each module has its own namespace...
19:14:33 <temoto> i suppose it's former then
19:15:03 <temoto> but that doesn't make a lot of sense
19:15:36 <temoto> see what totally gets me out of understanding is that fmap is very close to (.)
19:15:53 <temoto> so it's   fmap Layer `fmap` mapM f xs
19:16:01 <gwern> temoto: it's a . which can peek in a monad's wrapper? does that help/
19:16:51 <temoto> Now when you try to read that in prefix form, two fmaps go side by side.
19:17:03 <osaka>  /connect -ssl irc.us.synirc.net 7001 -n nnytle
19:17:25 <pikhq> temoto: It's not that "fmap is very close to (.)", it's that (.) is fmap on the functions.
19:17:28 <pikhq> :P
19:17:47 <temoto> fmap (fmap Layer) (mapM f xs) this doesn't make sense to me
19:18:54 <aavogt> the first fmap is to get inside the monad that mapM has sequenced
19:19:07 <aavogt> the second can be just map
19:19:11 <aavogt> to affect the list
19:20:17 <temoto> hm wait, actually, the working code is a bit different, it has no dot
19:20:22 <danharaj> is (Foo = forall a. (Bar a) => Foo a) an instance of Bar automatically?
19:20:30 <aavogt> no
19:20:35 <aavogt> you can write one tohugh
19:20:37 <aavogt> though*
19:20:38 <temoto> fmap Layer $ mapM f xs
19:21:08 <aavogt> then Layer takes a list of whatever f's result is
19:21:14 <temoto> this makes a bit more sense
19:21:24 <aavogt> you know that you can ask ghci what those types all are
19:21:33 <aavogt> it makes the same sense to me
19:21:36 <danharaj> aavogt: can you use deriving?
19:21:52 <temoto> aavogt, yes   `data Layer = Layer [Neuron]`
19:21:53 <aavogt> I don't think so
19:22:27 <danharaj> aavogt: Hrm, seems like something the compiler could automatically do.
19:22:37 <aavogt> temoto: so few types are fixed such that that definition is appropriate in either case
19:22:55 <temoto> i can replace fmap with liftM
19:22:56 <aavogt> danharaj: yeah, the instance is quite mechanical
19:23:02 <aavogt> not in general
19:23:06 <aavogt> temoto: ^^
19:23:06 <temoto> liftM Layer $ mapM f xs
19:23:18 <temoto> it works right now in particular code
19:23:27 <temoto> this notation makes even more sense
19:23:28 <aavogt> because your Functor is also a Monad
19:23:38 * BMeph wonders why in God's name would anyone _want_ to replace fmap with liftM...
19:23:55 <aavogt> BMeph: less type constraints
19:24:05 <temoto> BMeph, i'm starting to understand that thing
19:24:16 <aavogt> it's a bit nicer to deal with   (Monad a, ... ) where ... doesn't include  Functor a
19:24:27 <aavogt> if you decide to write out the signatures
19:24:28 <BMeph> Yeah - I still wonder, though. :)
19:24:53 <aavogt> it's happened to me
19:28:04 <temoto> So the thing is that we lift Layer into monad to accept [IO Neuron], lift map into monad to iterate pure list with Int -> IO Neuron...
19:28:23 <temoto> looks like the only thing that wasn't already in monad is [0..len] pure list
19:28:47 <temoto> maybe lifting or something it, would allow to reduce the expression?
19:29:08 <gwern> personally I'm suspicious you need to involve IO at all
19:29:18 <gwern> what is it there for? random numbers? pass around a seed instead
19:29:18 <temoto> gwern, it's for random.
19:29:43 <temoto> That's an option too.
19:30:01 <gwern> I'd do that. the less in IO the better
19:30:12 <Cale> @let takeUntil p [] = []; takeUntil p (x:xs) | p x = [x] | otherwise = x : takeUntil p xs
19:30:13 <lambdabot>  Defined.
19:30:23 <Cale> > let mystery = takeUntil (==1) . map length . filter (all (=='a')) . iterate (\(x:y:xs) -> xs ++ case x of 'a' -> "bc"; 'b' -> "a"; 'c' -> "aaa") in mystery $ replicate 9 'a'
19:30:24 <lambdabot>   [9,14,7,11,17,26,13,20,10,5,8,4,2,1]
19:31:41 <temoto> wow
19:31:42 <jbapple> I have a hazy memory of "deriving (Arbitrary)". Am I imagining things?
19:31:52 <jbapple> Do I need some flag?
19:32:09 <Cale> jbapple: For newtypes, that would be possible using NewtypeDeriving
19:32:24 <jbapple> Not for datatypes, though?
19:32:27 <Cale> Right
19:32:35 <jbapple> I must have misremembered
19:32:49 <gwern> or are thinking of a tool like drift
19:33:03 <gwern> pretty sure there was something recently about deriving arbitrary for you
19:34:35 <Cale> @let mystery = takeUntil (==1) . map length . filter (all (=='a')) . iterate (\(x:y:xs) -> xs ++ case x of 'a' -> "bc"; 'b' -> "a"; 'c' -> "aaa")
19:34:36 <lambdabot>  Defined.
19:34:57 <Cale> > mystery (replicate 57 'a')
19:34:58 <lambdabot>   [57,86,43,65,98,49,74,37,56,28,14,7,11,17,26,13,20,10,5,8,4,2,1]
19:34:59 <Axman6> :t takeWhile
19:35:01 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:35:20 <Axman6> ah, different thing
19:35:23 <temoto> And so the night has passed. :/ gotta have at least some sleep before work
19:36:20 <temoto> Thanks everyone, a lot. It can create empty machine and calculate hidden layer properly; which is a fairly good outcome.
19:44:29 <Cale> The Prelude (Or maybe it was just the List library?) used to have takeUntil and dropUntil in it, which would include the element where the condition changed like that. I wonder why they were removed.
19:45:11 <copumpkin> those seem more useful
19:45:17 <Olathe> Is there some evil hackery I can do to somehow make an IArray type that takes an extra parameter when creating it via the array function (I want to store integers modulo a programmer-chosen number) ?
19:45:29 <DigitalKiwi> Cale: you has a hat
19:45:37 <copumpkin> Olathe: you'd need type-level numbers
19:45:48 <Cale> ah, that's because of the weird bots earlier
19:45:50 <Olathe> Ahh. any tutorials on those ?
19:45:51 --- mode: Cale set -o Cale
19:45:58 <Olathe> Or are they possible ?
19:46:11 <copumpkin> Olathe: they are, but they're not very easy to work with in general
19:46:35 <Olathe> Is it some weird Church numeral thing ?
19:46:36 <Cale> Olathe: Basically, the suggestion is that you store elements in the array of a type where arithmetic is modulo the given number alread.
19:46:37 <Cale> y*
19:47:11 <Cale> You can do that without type-level arithmetic, just by storing the modulus along with the numbers
19:47:21 <Olathe> Ahh, OK.
19:47:36 <Cale> But it makes things a bit weird when you go to combine two modular numbers like that
19:47:54 <Olathe> Yeah, I'd want type safety to prevent that.
19:47:58 <Olathe> If it's possible.
19:48:15 <Cale> It's possible, but often more awkward than you'd want it to be
19:48:33 <danharaj> So I am defining a typeclass Translatable, whose members are types of GADT expressions I can get from typechecking an AST. Operators in the AST are translated to types :: (SomeExpr -> SomeExpr -> a) where SomeExpr is an existential wrapper for the GADT type. So I recursively call this function as I go down the tree, but at these operator branches, I need to translate to the hidden type of the existentials for the argument sub-trees. Can 
19:48:35 <Olathe> Is it possible to hide the awkwardness when using the array type ?
19:48:43 <danharaj> (oh god wall of unintelligible gibberish)
19:48:51 <Olathe> Or the numeric modulo type
19:48:52 <copumpkin> mmm
19:48:57 <Cale> http://www.reddit.com/r/sml -- lol
19:49:22 <DigitalKiwi> danharaj: the worst part is it cut off ;p
19:49:22 <copumpkin> hot
19:49:32 <danharaj> DigitalKiwi: Where izzat? :p
19:49:36 <DigitalKiwi> sub-trees. Can
19:49:45 <danharaj> "Can I do this?"
19:49:56 <DigitalKiwi> so close to making the cutoff!
19:50:12 <DigitalKiwi> you should use smaller words
19:50:28 <danharaj> if Expr is the GADT type, then SomeExpr = forall a. (Translatable a) => SomeExpr (Expr a)
19:50:38 <danharaj> I need to get to the 'a' parameter in my translate function.
19:51:00 <danharaj> I think I should be able to do this because I don't care which 'a' it is, I just want to call the translate function associated ot it.
19:51:25 <Cale> The existential wrapper throws away information about which 'a' it is, and only keeps a dictionary for the methods of Translatable
19:51:42 <Cale> Well... since it's a GADT, you can recover a bit more than that perhaps
19:51:56 <Cale> (which constructor was used may tell you some more about the type)
19:53:34 <danharaj> Cale: Well, I am defining the translate function associated with a. I get to a branch in the AST denoting operator application. I get the operator associated to the token in the AST w/ type (SomeExpr -> SomeExpr -> a) . Now I need to translate the leaves to types corresponding to the hidden ones in the operator signature.
19:53:45 <gwern> '# SML has a truly interactive interpreter in which functions can be both defined and used. In Haskell, functions must be defined in a separate file and compiled before being used in the interactive shell.'
19:53:50 <gwern> FFFFFFUUUUCCCCCKKKKKK
19:53:56 <gwern> <insert picture>
19:54:07 <danharaj> BTW translate :: Term -> Either Err (Expr a)
19:54:19 <danharaj> I hope what I'm trying to do is clear.
19:54:25 <BMeph> Cale: (looking at the "mystery" definition:) "Where does he get those wonderful toys?" :)
19:56:08 <danharaj> Actually my type has a mistake in it. the operator should have type (SomeExpr -> SomeExpr -> Expr a)
19:56:48 <gwern> someone who has ghci handy - can you do multiple lets to define a function?
19:56:54 <gwern> eg do let fac 0 = 1; fac n = n * fac (n-1)
19:56:58 <gwern>  as 2 newlines
19:57:08 <gwern> minus semicolon syntax
19:58:13 <BMeph> Cale: That reddit  section is AWESOME! I don't think I saw a single "SMiL" thread - it was all "SML" stuff - LOL!
19:58:34 <dolio> > let f :: Word -> Word ; f 0 = 1 ; f (n+1) = (n+1) * f n in f 9
19:58:34 <lambdabot>   mueval-core: GhcException "panic! (the 'impossible' happened)\n  (GHC versi...
19:59:03 <DigitalKiwi> impressive
19:59:15 <DigitalKiwi> @faq can haskell make the impossible happen?
19:59:15 <lambdabot> The answer is: Yes! Haskell can do that.
19:59:16 <dolio> > let f :: Word -> Word ; f 0 = 1 ; f n = n *  f (n-1) in f 9
19:59:16 <lambdabot>   mueval-core: GhcException "panic! (the 'impossible' happened)\n  (GHC versi...
19:59:56 <gwern> I worry sometimes about that
20:00:06 <dolio> > let f 0 = 1 ; f n = n * f (n-1) in f 9 :: Word
20:00:06 <lambdabot>   362880
20:00:09 <gwern> but no one has exploited ghc panics. yet.
20:00:21 * hackagebot cil 0.0.1 - An interface to CIL and ACSL through Frama-C.  http://hackage.haskell.org/package/cil-0.0.1 (TomHawkins)
20:00:25 <dolio> > let f 0 = 1 ; f n = n * f (n-1) in f (9 :: Word)
20:00:26 <lambdabot>   362880
20:01:10 <Cale> Why does GHC panic over that?
20:01:25 <gwern> Cale: I have no idea
20:01:57 <Cale> anyway, I can't imagine panics being easy to exploit, unless something interesting happens right before them.
20:02:39 <gwern> I've read enough Phrack to think that that is a good last words
20:03:33 <Cale> Not all panics are made equal anyway.
20:04:21 <gwern> hm. turns out ghc will accept multiple let bindings but it looks like they shadow ech other, and don't add up
20:04:29 <gwern> oh well
20:04:37 <dolio> I don't get a panic in 6.12.1, so I guess they fixed that one.
20:04:43 <dolio> Unless mueval is doing something fancy.
20:05:02 <Axman6> dolio: that isn;t one of my bugs is it? i swear i remember reporting that a year or so ago
20:05:21 <gwern> dolio: I dunno what lambdabot's mueval was compiled with. probably 6.10
20:05:22 <dolio> Axman6: I found it by accident yesterday.
20:05:40 <dolio> Yeah, if you message lambdabot, it will dump the whole error and it says 6.10.4.
20:07:06 <dolio> > let f :: Word -> Word ; f n = if n == 0 then 1 else n * f (n-1) in f 9
20:07:06 <lambdabot>   362880
20:07:17 <dolio> The pattern match against 0 is apparently the problem.
20:07:43 <dolio> > let f :: Word -> Word ; f 0 = 0 ; f n = n in f 9
20:07:44 <lambdabot>   9
20:07:47 <dolio> > let f :: Word -> Word ; f 0 = 0 ; f n = n in f 0
20:07:47 <lambdabot>   0
20:07:51 <dolio> Or not...
20:08:23 <dolio> > let f :: Word -> Word ; f 0 = 0 ; f n = 1 + f (n - 1) in f 0
20:08:24 <lambdabot>   mueval-core: GhcException "panic! (the 'impossible' happened)\n  (GHC versi...
20:08:52 <gwern> looks like overflow
20:09:05 <gwern> 0-1
20:09:14 <gwern> or I guess this would be underflow?
20:09:20 <gwern> > (0::Word)-1
20:09:21 <lambdabot>   18446744073709551615
20:09:28 <gwern> > 1+((0::Word)-1)
20:09:29 <lambdabot>   0
20:09:37 <gwern> hrm...
20:09:56 <gwern> > 1+((0::Word)-1) :: Word
20:09:56 <lambdabot>   0
20:10:01 <gwern> > 1+((0)-1) :: Word
20:10:02 <lambdabot>   0
20:10:06 * gwern dunno
20:13:13 <jberryman> is lambdabot using the MS Ecel backend?
20:13:23 <jberryman> *excel
20:13:38 <jesusabdullah> ?
20:13:42 * jesusabdullah wants to know
20:14:27 <dolio> http://hackage.haskell.org/trac/ghc/ticket/2881
20:14:31 <dolio> There's the bug.
20:14:47 <dolio> Reported by Axman6.
20:15:09 <Axman6> :)
20:17:24 <danharaj> what is :::
20:17:37 <Cale> danharaj: In what context? It could be a type or data constructor
20:17:52 <danharaj> data ATExp = forall a . TExp a ::: TTyp a
20:18:42 <Cale> Okay, it's just a data constructor.  data ATExp where (:::) :: TExp a -> TTyp a -> ATExp
20:18:53 <danharaj> ah
20:18:56 <tensorpudding> Not to be confused with (::)
20:19:22 <danharaj> It's infix, too right?
20:19:24 <Cale> The GADT syntax is so much clearer in many cases
20:19:26 <Cale> yeah
20:20:06 <Cale> yeah, it looks like a sort of analogue of :: given the names of your types there
20:20:20 <Cale> (takes an expression and a type and produces something)
20:20:23 <dolio> Huh, I hadn't seen an existential datatype with an infix constructor before.
20:20:35 <dolio> That's even more confusing than usual.
20:20:36 <danharaj> I'm reading a blog post by some guy doing something similar to me.
20:20:49 <danharaj> I'm trying to understand how to turn an untyped AST into a typed one
20:21:20 <tensorpudding> Do GADTs have any downsides?
20:22:01 <danharaj> Tutorials for them are not really clear.
20:23:00 <copumpkin> tensorpudding: more verbose types, but that's about it I think
20:23:07 <c_wraith> tensorpudding: more complexity?  they're just a generalization.
20:23:10 <copumpkin> I'd be fine with scrapping the standard data declaration style
20:24:40 <tensorpudding> That was my angle, was that they could be used as a replacement.
20:25:06 <tensorpudding> I think the GADT syntax is clearer and more symmetric, if more verbose.
20:25:40 <danharaj> Yeah, I think I understood data declarations better when I figured out GADT's
20:26:05 <Cale> They're somewhat trickier to implement though, and afaik "deriving" still doesn't work with them yet.
20:26:35 <copumpkin> yeah, it doesn't
20:26:38 <Cale> (but that could be fixed at least for types which are equivalent to normal algebraic types)
20:26:49 <copumpkin> well, I think it does if you don't use GADT-ey features
20:27:35 <ddarius> We could go the C++ route..
20:28:06 <tensorpudding> What's the C++ route?
20:28:45 <ddarius> Just spew out the code syntactically and see if it type checks.
20:29:59 <jberryman> I'm really ignorant about character encoding issues, but is there a way to read a file as a list of Ints?
20:30:10 <jberryman> I'm trying to implement something like < http://quadium.net/funge/spec98.html#Format > third paragraph
20:32:14 <Olathe> jberryman: Yeah, you can use a lazy bytestring and join them into Ints.
20:32:24 <Olathe> jberryman: Also, Data.Binary might do that automatically.
20:33:23 <Cale> jberryman: It looks like that definition is just describing what is needed to treat characters encoded in any way according to their ordinal in some enumeration.
20:33:55 <Cale> jberryman: So you could just use map (map fromEnum) . lines
20:34:11 <pastorn> @type fromEnum
20:34:12 <lambdabot> forall a. (Enum a) => a -> Int
20:35:19 <Cale> Of course, you're probably going to want to turn that list of lists into either an Array of some sort or a Data.Map
20:36:01 <tensorpudding> hooray sequences
20:36:29 <jberryman> Cale: thanks. I really need to get educated on text encoding, but I ran into a problem getting a module developed on GHC 6.8 to work on 6.12, on a particular file which mixed ASCII and non-ASCII characters
20:36:38 <jberryman> posted it to haskell-cafe yesterday
20:36:40 <jberryman> let me find it
20:37:13 <jberryman> http://www.haskell.org/pipermail/haskell-cafe/2010-May/077756.html
20:41:16 <Cale> jberryman: hmm
20:41:51 <Cale> jberryman: I got the program mentioned from its darcs repository and it seems to work for me under 6.12.2
20:43:03 <Cale> (just using   darcs get http://coder.bsimmons.name/code/Befunge )
20:43:29 <Cale> I had to change Befunge.hs to export 'main', which for some reason it wasn't doing.
20:43:45 <Cale> But I just ran it on a game-of-life implementation, and it worked.
20:44:16 <jberryman> Did you try it on tests/mycology/mycology.b98 ?
20:44:54 <Cale> ah, okay
20:44:55 <Cale> I see
20:45:21 <jberryman> Cale: according to the replies I got on haskell-cafe there is an issue with the non-ascii characters in that file
20:47:13 <jberryman> Cale: or rather that's my misunderstanding of what's going on
20:47:21 <Cale> *** Exception: mycology.b98: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
20:52:51 <Cale> In the whole file, there is a single Гє
20:53:10 <Cale> Well, at least, something which shows up as a Гє in vim
20:53:42 <Cale> and the problem happens right there
20:54:03 <Cale> I suppose we could try reading the file without UTF-8 decoding.
20:54:51 <BMeph> I think I'm finally getting Old and Crotchety, but for some reason, I find myself unimpressed with phrases such as "Being a total newbie, I wanted to start with something simple - so I'm simulating a distributed database..."
20:55:30 <jberryman> Cale: sorry, how would I go about that?
20:55:56 <ddarius> BMeph: ?
20:56:37 <Cale> iconv -f latin1 -t utf-8 mycology.b98 -o mycology.utf.b98
20:56:39 <Cale> aha!
20:56:43 <Cale> this fixed it
20:57:17 <Cale> So it really was the fact that it was encoded as latin-1 rather than utf-8 which caused the problem
20:59:51 <Cale> Okay, so currently it's using readFile to read the input.
20:59:59 <Cale> (wasBig,arr) <- liftM (buildGrid bigOk)$ readFile$ srcFile os
21:00:34 <edwardk> BMeph: i waited until at least my 4th haskell project before i set my sights on distributed database stuff =)
21:00:38 <arcatan> oh that's an awful cliche
21:01:19 <jberryman> Cale: yeah, and when I try to read in the whole file by calling 'length', it creates the error
21:01:21 <Cale> So we'll have to open a handle explicitly instead so we can hSetEncoding hdl latin1
21:03:05 <Cale>        hdl <- openFile (srcFile os) ReadMode
21:03:05 <Cale>        hSetEncoding hdl latin1
21:03:05 <Cale>        (wasBig,arr) <- liftM (buildGrid bigOk) . hGetContents $ hdl
21:03:25 <Cale> This fixes the problem for that mycology file.
21:03:39 <Cale> (as would converting the mycology file to UTF-8)
21:04:01 <Cale> Of course, it'll kill support for utf-8 encoded files.
21:05:35 <jberryman> Cale: thanks for elaborating. is there any way I can be as liberal as possible in dealing with different file encodings? or... convert files to UTF-8 programmatically?
21:06:11 <jberryman> Cale: or should I just try to catch these errors and display a message to the user?
21:06:56 <Cale> Unfortunately, text files don't traditionally contain much if any information about which encoding is used, and it's ambiguous. Treating the files as latin-1, I *think* will mean that you'll never get an error of that sort, as any binary file is valid latin-1. (?)
21:07:16 <Cale> But it will mean that programs written using UTF-8 won't work as expected.
21:07:30 <BMeph> ddarius: Not an actual example, just what it sounds like from my perspective.
21:07:31 <Cale> I suppose you could take a text encoding name as a parameter or flag to the program
21:08:04 <Cale> The default behaviour of readFile is to use the encoding for the current locale, which is set in an environment variable
21:08:19 <Cale> But these days, that usually means UTF-8
21:08:45 <Cale> mkTextEncoding :: String  -> IO  TextEncoding
21:09:05 <danharaj> what is the pattern guards extension?
21:09:29 <ddarius> BMeph: What what sounds like?
21:09:48 <Cale> is a system-dependent way to get particular encodings (on linux, it uses the list of encodings supported by iconv)
21:09:49 <jberryman> Cale: thanks, that was a huge help
21:11:03 <dolio> > let f l | Just x <- lookup 5 l = x | otherwise = "Yow!" in f [(0,"hello"), (5, "whoa!")]
21:11:04 <lambdabot>   "whoa!"
21:11:10 <dolio> > let f l | Just x <- lookup 5 l = x | otherwise = "Yow!" in f [(0,"hello"), (4, "whoa!")]
21:11:10 <lambdabot>   "Yow!"
21:11:29 <jberryman> 'night all
21:11:32 <DrSyzygy> You can do that?
21:11:47 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#pattern-guards
21:11:47 <DrSyzygy> Unexpected. You get to throw exceptions to avoid Bad Stuff in guards?
21:12:14 <Cale> No exceptions :)
21:12:20 <DrSyzygy> > let f l | x <- head l = x | otherwise = "Foo" in f []
21:12:22 <lambdabot>   "*Exception: Prelude.head: empty list
21:12:28 <Cale> Just pattern matching against the result of a function inside a guard
21:12:39 <DrSyzygy> Ahhhhh.
21:12:54 <DrSyzygy> The first one works before we get the wrong data type?
21:13:56 <Cale> Data type?
21:14:03 <DrSyzygy> Constructor...
21:14:08 <DrSyzygy> I'm tired. Language gets wonky.
21:14:11 <Cale> ah
21:14:34 <DrSyzygy> That thingie, there, y'know.
21:14:36 <Cale> Yeah, it just checks to see if Just x matches the result of lookup 5 l, and if so, the guard succeeds
21:14:37 <DrSyzygy> ;-)
21:14:45 <Cale> and x is bound to the result of the lookup in the body
21:15:00 <Cale> and then the second guard catches all the other cases
21:15:14 <Cale> (well, the one other case, where lookup 5 l is Nothing)
21:16:01 <Cale> This isn't a particularly brilliant example of the use of pattern guards, but if you have more than one lookup, and a number of cases to fall through, the code you'd otherwise have to write can get pretty clunky.
21:18:08 <danharaj> aha
21:18:20 <danharaj> You can use pattern guards to do pattern matching on existential types.
21:20:43 <Cale> You can also just use case expressions to do it
21:21:26 <danharaj> I could.
21:21:58 <danharaj> I just need to get acclimated to using existentials. They seem integral to compilers in Haskell.
21:23:29 <ddarius> danharaj: Most compilers don't bother trying to reflect an untyped AST into a typed one, partially because that is limited by the power of the host language's type system.
21:25:35 <dolio> Same problem with dependent type theories. They tend to unsafeCoerce all over the place when extracting to something like Haskell.
21:25:44 <dolio> Although perhaps they do it more than strictly necessary.
21:27:20 <danharaj> ddarius: I think I see it. While thinking about it on the train, I had the thought that in the long term, the more complicated the extensions I make to the type system, the less I'll be able to reflect it in Haskell, and I'll eventually have to work with it manually at the data level.
21:29:11 <danharaj> But I don't intend on this project ever having more than a limited form of polymorphism and ADT's, so I'm just doing it for the learning experience.
21:29:24 <Cale> http://www.viceland.com/blogs/uk-games/2010/05/10/the-totalitarian-buddhist-who-beat-sim-city/
21:29:57 <pastorn> Cale: go vice!
21:31:01 <dolio> How do you beat sim city?
21:31:08 <copumpkin> fill the map with arcologies!
21:31:11 <copumpkin> or was that 2000
21:31:26 <Cale> I think that was 2000
21:32:10 <copumpkin> "When 349 of the most advanced model, the "Launch Arco" (pictured), are built, an "exodus sequence" starts in which all Launch Arcos blast into space."
21:32:31 <cocon> is there anyway (infix rule or similar) to make "x ~~ f y" parse as
21:32:31 <cocon> 	"(x ~~ f) y"?
21:32:46 <dolio> -- is the start of a line comment.
21:32:58 <BMeph> ddarius: I feel as if I'm more often seeing projects which I'd call ambitious, being taken on by newcomers to Haskell. Now, while I'm all for having an adventurous spirit in exploring new intellectual territory, it seems to be more hazardous than warrented to want to write a web server in a language, when you don't have a strong grasp of how to do output.
21:33:06 <Cale> cocon: nope
21:33:22 <Cale> cocon: Function application always binds tighter than any infix operator
21:33:52 <Cale> dolio: Your comment reveals something about the font that you're using :)
21:34:04 <dolio> Ah yes.
21:34:25 <dolio> Ubuntu has changed the font hinting to make ~ look exactly like -.
21:34:49 <copumpkin> good for them
21:35:41 <edwardk> cocon: fraid not
21:35:46 <dolio> Actually, looking at them side-by-side, ~ is slightly greyer.
21:36:50 <copumpkin> edwardk: does anyone call you eddie?
21:37:11 <Cale> dolio: Oh, and about beating Sim City, this guy had a city with a population of over 6 million, using all available space in an efficient way (e.g. not even room for any roads), and it reached a steady state and lasted for 50,000 game years.
21:37:12 <edwardk> copumpkin: not really
21:37:33 <edwardk> copumpkin: my wife did when we first met, but thats about it
21:37:37 <copumpkin> ah
21:37:42 <Cale> (well, that was how long he ran it for)
21:38:00 <Cale> It was all meticulously planned :)
21:38:07 <edwardk> a couple of coworkers crack 'eddie haskell' jokes every once in a while ;)
21:38:37 * BMeph figures that's better than cracking "Edward Cullen" jokes...
21:38:59 <copumpkin> edwardk: does your skin sparkle in the sun?
21:39:31 <edwardk> copumpkin: as a geek i go out of my way to avoid sun, so the world may never know.
21:40:02 <BMeph> Oh, great - pale and named Edward...you're setting yourself up, man... ;)
21:40:36 <copumpkin> next up, caesarean section with his teeth
21:40:46 <edwardk> even better there are pictures of me running around in renaissance garb and i know how to fence
21:41:04 <edwardk> copumpkin: i believe it was the baby that et its way out
21:41:12 <copumpkin> was it? I dunno, I haven't read it
21:41:17 <copumpkin> I've just heard stories
21:46:19 <Kaidelong> BMeth; it could partially be that new programmers in haskell have already done formidable projects with imperative language
21:46:33 <Kaidelong> so simpler projects will not act as a real draw
21:47:23 <Kaidelong> I don't think many people take it up as their first language
21:48:02 <danharaj> It might also be that easy projects don't require some of the bigger guns in Haskell, and those are often the ones you want to tackle.
21:48:26 <danharaj> (Don't mix metaphors like I just did :|)
21:49:33 <c_wraith> Ok...  Should I fully generalize this library I'm working on?  I feel like it may be overgeneralizing.
21:50:30 <scotty> What do you all do when you want to use popular names for your own operators such as '-'?  Do you hide the specific Prelude functions?
21:51:15 <edwardk> c_wraith: maybe i'm biased but there is no such thing as overgeneralizing ;)
21:51:17 <copumpkin> import qualified Prelude
21:51:29 <copumpkin> and or -XNoImplicitPrelude if you really want to go crazy
21:51:50 <ddarius> edwardk: How often do you use category-extras?
21:51:57 <c_wraith> edwardk: I'm just thinking about ease of use vs generality that less than 1% of cases will want.
21:51:59 <scotty> copumpkin: Isn't it annoying having to type "Prelude." before everything?
21:52:19 <danharaj> c_wraith: Can't you just make bindings for the simple case from the more general one?
21:52:20 <copumpkin> scotty: you can import qualified Prelude, import Prelude (foo, bar, faz)
21:52:22 <edwardk> ddarius: touche ;)
21:52:40 <danharaj> c_wraith: Like how Parsec has Parser and GenParser
21:52:47 <scotty> copumpkin: Ah, yeah, sounds good.
21:52:54 <edwardk> c_wraith: design for what you actually have a use for, extend as needed
21:53:32 <c_wraith> edwardk: I did that already.  published on hackage.  I got a request to extend it for someone else's use case...  I'm wondering whether I should go with just the minimum he needs, or go all-out for him.
21:54:58 <c_wraith> I can see the elegance in the design if I take it to the extreme...  But I've already covered the minimum for his use case.
21:55:07 <scotty> copumpkin: I think I will end up having like 20 different functions in "import Prelude (...)"
21:55:16 <scotty> copumpkin: I don't know if this is good.
21:55:20 <copumpkin> scotty: it's not bad
21:55:48 <copumpkin> import Prelude hiding (foo, bar, baz)
21:56:02 <danharaj> c_wraith: Is the current implementation an easy special case of the full generalization?
21:56:23 <copumpkin> import Prelude using (x; y; z) hiding (a; b) renaming (foo to bar)
21:56:29 <c_wraith> danharaj: yes.  It's just a significant re-write to change it.
21:57:05 <danharaj> c_wraith: Would the re-write break backwards compatibility if someone used the current library and the fully generalized one?
21:57:19 <edwardk> renaming?
21:57:25 <copumpkin> :P
21:57:32 <copumpkin> agda does it, why can't we?
21:57:46 <copumpkin> we need fancier modules
21:58:04 <systemfault> What's the hype about agda?
21:58:10 <c_wraith> I've already broken backward compatibility in a small way.  Generalizing it wouldn't break it any further, if I was smart about adding helper functions.
21:58:24 <copumpkin> systemfault: it's fun
21:58:31 <systemfault> Ah, haskell isn't?
21:58:48 <copumpkin> it's fun in a different way
21:58:49 <danharaj> c_wraith: I think you should pave the way for future generalization and release it in its current state, and then work on the full generalization at your pleasure.
21:59:47 <edwardk> systemfault: its like what would happen if simon peyton jones and company had a party and invited conor mcbride and he convinced them all to chuck all this pesky type inference crap, and just rely on the end user to prove everything. dependent types, an ever shifting metatheory, and more language features than you can shake a stick at
21:59:54 <c_wraith> danharaj: that's a pretty good approach, I think.
22:00:01 <c_wraith> thanks for the advice. :)
22:00:11 <copumpkin> that's a pretty good summary
22:00:32 <systemfault> edwardk: Ah... AGDA is to Haskell what C++ is to C?
22:00:36 <systemfault> :/
22:00:37 <copumpkin> no
22:00:49 <danharaj> Agda has a different philosophy from Haskell.
22:00:54 <copumpkin> although it is a bit "messy" in some ways
22:01:09 <pastorn> types of types and all that :)
22:01:18 <copumpkin> haskell has types of types
22:01:21 <dolio> Is that like JAVA?
22:01:29 <copumpkin> lol
22:01:33 <kosmikus> :)
22:01:35 <systemfault> So, when I'll get better with haskell, I should definitely take a look at Agda?
22:01:37 <pastorn> copumpkin: hmm... i don't know how to properly describe Set
22:01:47 <edwardk> systemfault: agda is ... different, its like eiffel to c. it brings in a whole bunch of weird ideas, but is internally strangely minimalistic and more consistent in some ways, but also draws a little bit from the crackpot fringe ;)
22:02:00 <systemfault> edwardk: Ahhh ok :)
22:02:13 <pastorn> systemfault: when you want to prove stuff about your code, then you should look at agda
22:02:15 <copumpkin> pastorn: Set is the type of types, and Set 1 (or Set1) is the type of types of types, and so on
22:02:32 * pastorn dies a little inside
22:02:36 <copumpkin> why?
22:02:40 <edwardk> take coq, rip out all the ocamlish nonsense and replace it with haskellish sensibilities
22:02:53 <dolio> It's also the type of datatypes defined to be in Set1.
22:03:12 <systemfault> edwardk: Ahh ok :)
22:03:15 <copumpkin> I wonder what the highest level anyone's every used in agda
22:03:25 <copumpkin> ever*
22:03:33 <dolio> Set \omega, obviously.
22:03:56 <edwardk> sorry for explaining analogies with analogies. agda is nice when you don't need or want proof tactics, but in some ways that hair shirt seems to be doing the agda folks a world of good
22:04:28 <dolio> Tactics are imperative proving.
22:04:37 <systemfault> edwardk: It's good :)
22:04:38 <BMeph> Agda is to Haskell what Factor is to Forth! ;)
22:04:38 <edwardk> they've gotten pretty good at expressing things in very precise detail or at modeling tactics through tricky universes
22:04:51 <copumpkin> the semiring solver is pretty neat
22:05:16 <copumpkin> but coq has one too
22:05:45 <edwardk> true, but it serves as a model of the kind of construct that can be built using just the tools agda provides
22:06:02 <edwardk> i admit i didn't expect it when i first saw it
22:06:09 <copumpkin> I was surprised at how flexible it is
22:07:10 <BMeph> copumpkin: A semi-coq ring? ;ю
22:07:14 <copumpkin> oh god
22:07:18 <systemfault> :/
22:07:32 <edwardk> thats what happens when you've had one too many of them ripped out.
22:08:00 <systemfault> Well.. Why Coq and not Chicken? :/
22:08:03 * systemfault hides.
22:08:05 * edwardk just realized he was using his #haskell-blah voice ;)
22:09:02 <arcatan> welcome to #-bloh, where your complaints are addressed with majestetic.. oh scrap that
22:10:13 <edwardk> my biggest issue with agda is that the library design goes out of its way to just make up random ungooglable symbols on you ;)
22:10:32 <copumpkin> yeah, I've wondered how long NAD spends perusing unicode tables
22:10:41 <edwardk> it can't be healthy ;)
22:10:44 <copumpkin> there are some fairly ridiculous ones
22:11:39 <c_wraith> does any library use the snowman operator?
22:11:43 <edwardk> its like he watched that talk by guy steele that complained about apl from the perspective that user extensions didn't feel like part of the language design, and went overboard, deciding to make everything feel like it belonged in APL ;)
22:11:56 <c_wraith> вѓ 5
22:12:10 <Pseudonym> Everything DOES belong in APL.
22:12:23 <Pseudonym> Mind you, extensions in APL usually mean adding more bucky keys.
22:12:31 <edwardk> c_wraith: if not, the moment i do something for measuring temperatures, its in ;)
22:13:09 <edwardk> APL was awesome.. as long as you were the language implementor ;)
22:13:34 <Pseudonym> iverson++
22:13:54 * edwardk slinks off given that copumpkin and saizan can probably give him untold grief about the same being said for kata ;)
22:14:08 <copumpkin> gotta love walls of agda: http://snapplr.com/y4wc
22:14:18 <copumpkin> nah, kata is awesome! ;)
22:14:40 <c_wraith> @karma iversion
22:14:40 <lambdabot> iversion has a karma of 0
22:14:47 <c_wraith> err, I suck at sports
22:14:51 <c_wraith> @karma iverson
22:14:51 <lambdabot> iverson has a karma of 1
22:15:44 <edwardk> i love agda if only because it taught me that throwing unicode everywhere isn't the solution to your problems, it just ensures that you have one more.
22:16:34 <copumpkin> hah, just wait until I write my own language
22:16:40 <copumpkin> it doesn't even use text!
22:17:06 <edwardk> copumpkin's language uses coexponentials, but not exponentials just because he wants to be able to subtract types
22:17:07 <copumpkin> your programs will be 4d animated models
22:17:23 <copumpkin> ooh, sure, I'll throw those in too
22:17:26 <Pseudonym> copumpkin, you're telling me you haven't written your own language?
22:17:29 * copumpkin hasn't come across coexponentials
22:17:35 <copumpkin> Pseudonym: nope, but I have great plans for it
22:17:42 <ddarius> I like the fact that Agda is forgoing tactics.
22:17:53 <copumpkin> I think it's a coming of age ritual in this community
22:18:30 <Pseudonym> Well, you write a compiler for a toy language first.
22:18:31 <edwardk> ddarius: i agree, it builds character
22:18:42 <copumpkin> Pseudonym: nah, I don't need a compiler
22:19:04 <edwardk> copumpkin: oh crap i'm rubbing off on you ;)
22:19:07 <copumpkin> :P
22:19:11 <copumpkin> you're my role model!
22:20:16 * ddarius is not sure when he first implemented a programming language or in what language it was implemented in.
22:20:17 <Pseudonym> I think I still have the source code of my first compiler sitting around somewhere.
22:20:44 <ddarius> I did make a 6502 emulator in x86 assembly a really long time ago if one wants to count that...
22:20:46 <Pseudonym> I did learn an important lesson with it: Triples are a REALLY stupid intermediate format.
22:21:15 <copumpkin> :o
22:21:50 <edwardk> my first real programming language design experience came from writing little extensions to the c64 basic token set, i then veered off into assembly and didn't look back for a long time
22:21:55 <Pseudonym> Oh, I did that.
22:22:03 <Pseudonym> Extending C64 basic was fun.
22:22:12 <Pseudonym> You essentially subclassed the tokeniser.
22:22:30 <Pseudonym> Only it wasn't written for that.
22:22:37 <edwardk> yeah i lied and told a kid in 3rd grade that i'd written a disassembler and then had to make good on the claim over the weekend
22:23:00 <copumpkin> :o
22:24:11 <edwardk> i came in monday with one that only half worked but he didn't know any better than i did. ;) i fixed it up and then started exploring the basic rom... i just thought that that was the way people coded. cramming everything they could into such a tiny little space with no real regard for control flow
22:24:42 <Pseudonym> Writing the ROM for an 8-bit micro is like that.
22:24:49 <edwardk> moved on to the kernel rom, and the rom in the 1541 before playing around writing turbo loaders
22:26:58 <edwardk> Pseudonym: yeah. it proved to be a valuable skill when i discovered demo sceners at least ;)
22:27:51 <Pseudonym> :-)
22:28:10 * Pseudonym had a brief flirtation with the demo sceners in the early 90s
22:28:18 <Pseudonym> Trouble is, I didn't live in Scandinavia.
22:28:50 * edwardk tried not to flirt with sceners, they tended to have bad hygiene given that they didn't get away from their computers much the few nights before the compo... ;)
22:28:57 <copumpkin> :o
22:30:40 <edwardk> speaking of getting away from computers, i should get some sleep. ;)
22:51:59 <somnium> can anyone recommend any resources on the implementation of Data.Vector?
22:53:16 <Lemmih> somnium: You might read the stream fusion paper.
22:55:02 <somnium> Lemmih: is the underlying datastructure a trie?
22:56:36 <Lemmih> somnium: No, vectors are arrays.
22:59:52 <somnium> Lemmih: ah, hmm. (this stream fusion paper is very interesting) So they do COW for updates?
23:03:53 <Lemmih> somnium: No, I don't think so. Updates aren't recommended.
23:04:29 <nniro> can someone tell me how to import a global variable in FFI? Treating it like a function seg faults my application...
23:07:52 <Polarina> nniro, foreign import "file.h &global_var" varia :: Word32
23:08:08 <nniro> I tried : foreign import ccall "gpm.h gpm_fd" gpm_fd :: IO CInt
23:08:28 <Polarina> nniro, foreign import ccall "gpm.h &gpm_fd" gpm_fd :: IO CInt
23:08:28 <nniro> ah no ccall heh
23:08:40 <Polarina> nniro, or no ccall, you need that &.
23:09:05 <Lemmih> nniro: ccall can be implicit.
23:09:05 <nniro> that's pretty far fetched heh
23:09:22 <Polarina> nniro, far fetched? The '&' indicates it's a variable.
23:09:31 <nniro> even if & is to get the adress of a variable in C ;P
23:10:03 <rl> somnium: see also http://www.cse.unsw.edu.au/~rl/publications/recycling.html
23:10:29 <Polarina> nniro, yes.
23:10:53 <nniro> Polarina: it doesn't seem to work
23:11:17 <nniro> Polarina: ghc complains... let me do it in X so I can paste it here
23:11:56 <c_wraith> nniro, please paste to a pastebin :)
23:12:07 <nniro> Unacceptable type in foreign declaration: CInt
23:12:15 <scotty> Can anyone familiar with HOpenGL tell me what happened to "matrixExcursion"?  Did it get renamed or something?  I'm trying to build some demos where it's used.
23:13:00 <nniro> Polarina:  When checking declaration:
23:13:01 <nniro>         foreign import ccall unsafe "static gpm.h &gpm_fd" gpm_fd :: CInt
23:13:47 <Polarina> nniro, who told you to put that "static" there?
23:14:17 <Polarina> Also, unsafe doesn't make sense in this context.
23:14:20 <nniro> Polarina: that's the test right after I tried it in the IO monad, and the code itself doesn't have that "static" there
23:14:23 <scotty> Ah, it's call "preservingMatrix".
23:15:14 <nniro> Polarina: safe or unsafe it always raises that error
23:15:52 <Polarina> nniro, no, don't be implicit, don't say anything. And what's the error?
23:17:14 <nniro> Polarina: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25546#a25546
23:18:37 <nniro> Polarina: gpmGetFd :: IO Int; gpmGetFd = liftM fromIntegral gpm_fd; foreign import ccall "gpm.h &gpm_fd" gpm_fd :: IO CInt
23:18:42 <Polarina> nniro, try  foreign import "gpm.h &gpm_fd" gpm_fd :: IO CInt
23:20:06 <nniro> Polarina: it gives a parse error on `"'
23:20:11 <Polarina> o.O
23:21:08 <nniro> Polarina: if I remove the '&' symbol it (and adds the ccall back) it compiles perfectly
23:23:09 <Polarina> nniro, but what if you do  foreign import ccall "&gpm_fd" gpm_fd :: IO CInt ?
23:23:10 <nniro> Polarina: would it be because the code itself is in a hsc file?
23:23:29 <Polarina> I don't know.
23:24:13 <nniro> heh
23:24:17 <sosman> So many tutorials to choose from
23:24:23 <DigitalKiwi> you stumped Polarina!
23:24:31 <Polarina> DigitalKiwi, I figured.
23:24:37 <DigitalKiwi> this is unheard of
23:24:50 <DigitalKiwi> sosman: i know right?
23:24:55 <DigitalKiwi> so hard to pick :(
23:24:57 <Polarina> nniro, looking at old messages in the mailing list, it seems that the variable has to be a pointer, as in Ptr CInt.
23:25:01 <sosman> like standards
23:25:12 <DigitalKiwi> I once did a paper for sociology on "Too many choices limit freedom"
23:25:48 <nniro> Polarina: so you're telling me it's impossible to import standard global variables?
23:25:50 <sosman> And I don't know if its a problem with google or haskell but searching for: haskell => doesn't really help me much
23:26:05 <Polarina> nniro, yes, unless it's a pointer.
23:26:18 <DigitalKiwi> got a 97, but i'm not sure if he actually read them, i think most people got 97s on all of them as long as they were the right length >.>
23:26:18 <Polarina> nniro, in your case, you will most likely have to create a wrapper.
23:26:42 <ski> copumpkin : .. hm, i wasn't even aware we had a "no swearing" rule
23:26:48 <copumpkin> ?
23:26:59 <c_wraith> wow, ski, that's like 24 hours of lag :)
23:27:00 <copumpkin> oh!
23:27:02 <sosman> We are so f****d
23:27:02 <copumpkin> lol
23:27:04 <DigitalKiwi> lisp
23:27:16 <ski> c_wraith : .. yes ?
23:27:17 <copumpkin> soeren: funded?
23:27:18 <DigitalKiwi> fortran
23:27:19 <DigitalKiwi> C
23:27:38 <DigitalKiwi> those are swear words right?? ;p
23:27:40 <c_wraith> DigitalKiwi: you missed the biggest swear-word of them all...  cobol. :)
23:27:45 <DigitalKiwi> haha
23:27:49 <nniro> Polarina: alright, thanks for your help
23:27:52 <sosman> python is ok though?
23:28:26 <ski> (copumpkin : .. though maybe that's why i was singled out as "ski has quite a potty mouth. 0.0% words were foul language." :)
23:28:41 <copumpkin> it might have been 0.0005%
23:28:45 <copumpkin> and just truncated
23:28:50 <copumpkin> to be one decimal
23:28:56 <Polarina> nniro, you're welcome.
23:29:05 <DigitalKiwi> how do you get that stat?
23:29:55 <ski> (copumpkin : then i think it is more probable it was one of the ones DigitalKiwi named than the more common ones, which i can't recall when i last used)
23:29:57 <sosman> How do I read "run :: Show a => Parser a -> String -> IO ()" (example from the parsec docs) please?
23:30:45 <sosman> eg run is a type of ...
23:31:13 <copumpkin> a function that takes a parser that returns a value of type that is an instance of Show (i.e., can be transformed to a String representation), a String, and returns an IO action that returns nothing of interest
23:31:20 <ski> sosman : `run' takes a parser that will return values of some type `a' (which must be in `Show'), and a string, and returns an `IO'-action (that will presumably try to parse the string using the parser, and either print out some kind of parse error message, or write out the result value `a')
23:31:27 <copumpkin> presumably, it parses the string and prints the result of the parser
23:31:40 <sosman> wait while i parse that.
23:32:40 <ski> > run Sosman.englishParser ircMessage
23:32:40 <lambdabot>   Not in scope: `run'Not in scope: `Sosman.englishParser'Not in scope: `ircMe...
23:32:41 <kmc> sosman, "given that 'a' is some Show-able type, 'run' takes a 'Parser a', and a String, and returns an IO action that has no meaningful result but presumably does something useful"
23:33:05 <kmc> (type class context) => arg1 -> arg2 -> ... -> argN -> result
23:33:25 <tensorpudding> @src gcd
23:33:25 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
23:33:25 <lambdabot> gcd x y = gcd' (abs x) (abs y)
23:33:25 <lambdabot>    where gcd' a 0  =  a
23:33:25 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
23:33:57 <sosman> thanks all - I like kmc's best
23:34:02 * ski wants to remove the extra `gcd 0 0' case ..
23:34:36 * Silvah wonders why
23:34:42 <sosman> heh
23:34:52 <copumpkin> it's annoying
23:34:54 <Cale_> because the gcd of 0 and 0 is 0
23:34:58 <nniro> Polarina: for your information I was able to fix it, I used : foreign import ccall "&" gpm_fd :: Ptr CInt       and then had to use peek gpm_fd to access the value
23:35:00 <ski> what Cale_ said
23:35:03 <copumpkin> I'm not even sure how they decided that
23:35:09 <copumpkin> someone had to go out of their way to be wrong there
23:35:11 <Polarina> nniro, cool. :)
23:35:46 <ski> (.. also, it'd be nice if `mod n 0' was `n')
23:37:34 <Silvah> Why it'd be nice?
23:38:18 <ski> because `|Z / 0*|Z' is isomorphic to `|Z'
23:39:00 <ddarius> Is |Z supposed to be "blackboard Z"?
23:39:05 <ski> (yes)
23:39:15 <ski> iow, `a' being congruent to `b', modulo `0', is the same as `a = b'
23:40:50 <roconnor_> a = b mod 0 iff 0 divides a - b
23:41:03 <roconnor_> 0 divides a - b iff a = b
23:41:08 <roconnor_> makes sense I guess
23:41:46 <roconnor_> ski:  so n div 0 = 0 ?
23:41:50 <ski> no
23:41:52 <ddarius> a|b if exist n such that an=b ...
23:42:06 <roconnor_> ski: why not?
23:42:13 <kmc> sosman, though remember that "multiple arguments" in Haskell are just syntactic sugar
23:42:18 <kmc> every function really only has one argument
23:43:22 <roconnor_> ski:  (n `div` 0)*n + (n `mod` 0) = n ?
23:43:25 <ski> roconnor_ :  n `div` d = q  <=>  n = q * d
23:43:35 <roconnor_> ski: that isn't true
23:43:37 <sosman> kmc: as in a tuple
23:43:40 <sosman> ?
23:43:40 <roconnor_> 3 `div` 2
23:43:44 <roconnor_> > 3 `div` 2
23:43:45 <lambdabot>   1
23:43:59 <ski> sorry, that's supposed to be exact division
23:44:12 <roconnor_> ah sorry
23:44:17 <roconnor_> ski:  so n `div` 0 = 0 ?
23:44:26 <Polarina> No
23:44:32 <Polarina> n `div` 0 = infinity
23:44:43 <roconnor_> Polarina: given n `mod` 0 = n
23:44:44 <kmc> sosman, no
23:44:58 <copumpkin> infinity isn't a number!
23:45:02 <kmc> sosman, the type (A -> B -> C) parenthesizes as (A -> (B -> C))
23:45:03 <copumpkin> unless it is
23:45:05 <JoeyA> > 3 `div` 0
23:45:06 <lambdabot>   *Exception: divide by zero
23:45:09 <copumpkin> it's a nimber
23:45:17 <kmc> sosman, that is, when you apply one argument, you get a function back, which takes the second argument
23:45:18 <JoeyA> > 3 / 0 -- floating point division
23:45:19 <lambdabot>   Infinity
23:45:22 <kmc> sosman, this is called "currying"
23:45:24 <kmc> makes sense?
23:45:30 <copumpkin> yeah, floating point math fails
23:45:36 <ddarius> That's called partial application.
23:45:42 <roconnor_> ski: I demenad answers!
23:45:45 <ddarius> Currying is what curry does.
23:46:00 <roconnor_> carry out your n `mod` 0 argument to it's logical conclusion!
23:46:03 <copumpkin> currying is related to exponentials!
23:46:08 <kmc> ddarius, i thought "currying" refers to a convention for how to represent multiple arguments
23:46:12 <sosman> kmc: makes sense yes, just like when music teacher explained all those black blobs on music.
23:46:18 <kmc> another convention would be to use tuples
23:46:20 <ski> roconnor_ : hm, actually, i'm confusing this with exact division. i now agree that   n `div` 0 = 0
23:46:21 <kmc> (A, B) -> C
23:46:29 <Kaidelong> http://donsbot.wordpress.com/2009/10/17/multicore-haskell-now-acm-reflections-projections-2009/ <-- on slide 34, are those parens really necessary?
23:46:29 <kmc> that's the less common convention in Haskell, because the curried syntax is nicer
23:46:29 <ddarius> kmc: As I said, currying is what curry does.
23:46:34 <roconnor_> horry!
23:46:40 <kmc> the functions "curry" and "uncurry" go back and forth
23:46:41 <kmc> :t curry
23:46:42 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
23:46:42 <kmc> :t uncurry
23:46:43 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
23:46:47 <roconnor_> I got ski to say n `div` 0 = 0
23:47:13 <pikhq> There's also the fact that we Haskellians love to eat curry.
23:47:13 <pikhq> :P
23:47:14 <ski> (roconnor_ : or, hm ..)
23:47:22 <ddarius> copumpkin: Currying is one half of the adjunction characterizing exponentials.
23:47:26 <copumpkin> yep
23:47:26 <roconnor_> ski: oh wait
23:47:28 <roconnor_> I screwed up
23:47:29 <sosman> I'm from oz, prefer meat pies.
23:47:30 <roconnor_> sorry
23:47:33 <ddarius> pikhq: Curry is good.
23:47:46 <roconnor_> ski:  (n `div` 0)*0 + (n `mod` 0) = n
23:47:47 <ddarius> I prefer Indian curries the most.
23:47:49 <ski> roconnor_ : actually, it shouldn't have been "(n `div` 0)*n + (n `mod` 0) = n", i think
23:47:50 <roconnor_> not (*n)
23:47:57 <copumpkin> thai curries can be pretty decent
23:47:59 <sosman> Anyway - takes a bit for the brain to wire itself to new concepts.
23:48:00 <roconnor_> I'm retarded
23:48:02 <pikhq> ddarius: Mmm... Well, they *did* invent it.
23:48:10 <ski> more like  (n `div` q)*q + (n `mod` q) = n
23:48:19 <roconnor_> ya
23:48:20 <roconnor_> my bad
23:48:28 <roconnor_> okay
23:48:41 <roconnor_> now we just need (_|_)*0 = 0
23:48:43 <copumpkin> pikhq: really?
23:48:44 <ski> which means that if  q = 0  , then  n `div` q  could be anything, to make that hold
23:48:47 * Kaidelong thinks `mod` 0 would be undefined
23:48:53 <copumpkin> I thought it was a practice for preserving food that was all over the place
23:49:05 <copumpkin> some people salt it, some people put it in vinegared rice, others curry it
23:49:09 <ski> in which case i think it should be "undefined", if we want a unique (not arbitrarily chosen) solution
23:49:10 <roconnor_> Kaidelong: a = b mod 0 iff 0 divides a - b  iff a = b
23:49:18 <pikhq> copumpkin: No, it just spread all over the place.
23:49:24 <copumpkin> hmm
23:49:31 <sosman> pikhq: references?
23:49:36 <pikhq> sosman: Not handy!
23:49:43 <Kaidelong> roconnor: I was reading that as literal code, not a congruency, I suppose
23:49:52 <copumpkin> pikhq: likely excuse!
23:50:19 <Kaidelong> still why not say "b mod b" to the same effect?
23:51:02 <ski> (roconnor_ : would you happen to know different terms for these two different senses of "undefined" : (a) there is no value satisfying the "defining" property; (b) there are too many values satisfying the "defining" property ?)
23:51:21 <roconnor_> b) is bottom
23:51:26 <roconnor_> a) is top
23:51:34 <Silvah> This discussion is amusing...
23:51:44 <copumpkin> roconnor_: which are you? ;)
23:51:47 <ski> Kaidelong : hm ?
23:52:15 <Kaidelong> if you try to do `mod` 0 in haskell you get a perfectly expected divide by zero exception
23:52:28 <ski> i dispute the "expected"
23:52:36 * hackagebot lrucache 1.0 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-1.0 (CarlHowells)
23:52:40 <sosman> curry(ПЂ)
23:52:42 <roconnor_> Kaidelong: no, read it as congruency
23:52:51 <ski> (since there doesn't need to be a division that is to be performed)
23:52:59 <Kaidelong> roconnor_: yes, but the ``s ski wrote threw me off
23:52:59 <ddarius> :t (const, curry fst)
23:53:00 <lambdabot> forall a b a1 b1. (a -> b -> a, a1 -> b1 -> a1)
23:53:01 <roconnor_> Kaidelong: a ==[0] b iff 0 divides a - b iff a = b
23:53:15 <copumpkin> why isn't there a curry snd built-in?
23:53:16 <Kaidelong> thought he was presenting code
23:53:30 <copumpkin> :t curry snd
23:53:31 <lambdabot> forall a b. a -> b -> b
23:53:36 <ddarius> copumpkin: Because flip const or const id isn't too much to write?
23:53:37 <copumpkin> seq!
23:53:41 <copumpkin> muahaha
23:53:44 <roconnor_> ski: I'd rather get gcd fixed first, but we can do both at the same time
23:53:48 <ski> (Kaidelong : for a small while, i thought i was writing about Haskell code, but i was confusing exact and truncating division)
23:54:26 <Kaidelong> ski: if you think of the modulus as the remainder and you allow it negative values, it doesn't make sense at 0
23:54:48 <Kaidelong> if you think of it in the sense of a clock face, it does make sense to do a `mod` 0
23:55:03 <Silvah> It doesn't make any sense for other values too.
23:55:09 <roconnor_> > 5 `mod (=101)
23:55:10 <lambdabot>   <no location info>: parse error on input `('
23:55:16 <ski> roconnor_ : yes, the `gcd' one is possibly more irritating (which is why i said "it'd be nice if" about the `mod' one), but one reminded me of the other
23:55:16 <Kaidelong> hmm
23:55:20 <roconnor_> > 5 `mod` 101
23:55:21 <lambdabot>   5
23:55:22 <Kaidelong> > -5 `mod` 3
23:55:23 <lambdabot>   -2
23:55:28 <roconnor_> > 5 `mod` (-101)
23:55:29 <lambdabot>   -96
23:55:35 <Kaidelong> so mod in haskell means "remainder"
23:55:47 <roconnor_> > 5 `mod` (-(101^4))
23:55:48 <lambdabot>   -104060396
23:55:50 <Cale> > 5 `rem` (-101)
23:55:51 <lambdabot>   5
23:55:54 <ski> Kaidelong : i'm not following what you say about negative values. can you rephrase ?
23:56:05 <Cale> There's div and mod, and there's quot and rem
23:56:19 <ski> > (-5) `mod` 3  -- btw
23:56:20 <lambdabot>   1
23:56:23 <roconnor_> Cale: ski is suggesting n `mod` 0 should be n
23:56:25 <Kaidelong> ooh
23:56:26 <Kaidelong> oops
23:56:26 <Cale> Corresponding to two possible conventions for division
23:56:31 <Kaidelong> operator precedence go
23:56:37 <Kaidelong> sorry about that
23:56:55 <Kaidelong> well then I don't see why `mod` 0 should throw an exception either
23:57:23 <Cale> roconnor_: Yeah, that sort of makes sense.
23:57:28 <roconnor_> I guess there is no choice but for n`mod`0 to be n
23:57:30 <Kaidelong> > (-5) `mod` 0
23:57:31 <lambdabot>   *Exception: divide by zero
23:57:38 <roconnor_> since Z is the initial ring
23:57:41 <Kaidelong> > (-5) `rem` 0
23:57:42 <lambdabot>   *Exception: divide by zero
23:57:58 <roconnor_> we don't even have a choice of representitives
23:58:07 <Kaidelong> roconnor_: yes, n `mod` 0 should equal to n
23:58:10 <Cale> Yeah, it seems totally sensible
23:58:25 <roconnor_> someone should just sneak into Haskell Libs and fix gcd and mod
23:58:46 <ddarius> And everything else that is brokne.
23:58:46 <Kaidelong> I'm kind of happy haskell's mod is the one I actually need to work with
23:58:48 <Cale> @src lcm
23:58:48 <lambdabot> lcm _ 0     =  0
23:58:48 <lambdabot> lcm 0 _     =  0
23:58:48 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
23:59:00 <Kaidelong> I remember .NET's mod was really the remainder, which was not what I wanted
23:59:04 <Cale> Kaidelong: yeah
23:59:25 <Cale> Kaidelong: rem is apparently marginally easier to implement in hardware for some reason
23:59:39 <Cale> But it's less useful
