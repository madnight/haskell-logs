00:00:16 <roconnor> @src replicate
00:00:17 <lambdabot> replicate n x = take n (repeat x)
00:00:25 <IceKiller> > [1,2,3] `zip` repeat 1
00:00:26 <lambdabot>   [(1,1),(2,1),(3,1)]
00:00:28 <IceKiller> hmm
00:00:30 <rtq> Glguy, I am scrapping web pages with tag soup and I need to go from one page to another
00:00:46 <glguy> Then your function isn’t pure
00:00:48 * BMeph would prefer it were called "runOfIntoADeepDarkForestAndUnsafePerformIO"... ;
00:00:57 <djahandarie> Is it possible to use forkIO on a readerT around an IO?
00:01:07 * BMeph meant "runOffIntoADeepDarkForestAndUnsafePerformIO"... ;
00:01:26 <glguy> djahandarie: you’ll need to read the environment and then run the thing to fork with that environment
00:01:50 <glguy> fork m = do x <- ask ; inBase (forkIO (runReaderT x m))
00:01:51 <Jafet> You'll ruin the pristine deep dark forest that way, bmeph
00:02:04 <rtq> I have an impure that calls a pure and I want to call an impure from that
00:02:10 <djahandarie> Oh, that's nifty, glguy
00:02:26 <Twey> bauerbill-style: blindlyPerformImpureActionsInPureCodeDespiteTheInherentRisk
00:02:26 <rtq> Could make everything impure
00:02:59 <glguy> rtq: You need to make things a little less pure rather than lie about them being pure :)
00:03:09 <glguy> unsafePerformLolWut?
00:03:11 <pastorn> Twey: wouldn't 'thisWillBlowShitUp' be more proper?
00:03:17 <Twey> Heheh
00:03:29 <rtq> :) glguy
00:03:49 <Twey> bauerbill has an option --blindly-trust-everything-when-building-packages-despite-the-inherent-danger
00:03:51 <glguy> rtq: the IO type constructor is not your enemy!
00:03:52 <Jafet> That only describes a function that safely and reliably blows shit up.
00:03:52 <Twey> It makes me laugh
00:04:03 <Twey> :t inBase
00:04:04 <lambdabot> Not in scope: `inBase'
00:04:09 <Twey> What is inBase?
00:04:10 <glguy> Twey: MonadLib
00:04:10 * BMeph is tired of these...naugh, been done to death, let's let sleeping snakes lie. ;)
00:04:12 <Twey> Oh
00:04:20 <Twey> Hehe
00:04:31 <glguy> The library you use when you don’t want to write your own stack
00:04:51 <djahandarie> glguy, wait, what is inBase in that function?
00:05:18 <glguy> djahandarie: inBase lifts the IO ThreadId to ReaderT env IO ThreadId
00:05:32 <k23z__> when I do ghc --make program.hs   does ghc include some small version of itself inside the .exe ?
00:05:42 <djahandarie> glguy, where does it come from? I don't have it
00:05:46 <djahandarie> @hoogle inBase
00:05:46 <lambdabot> No results found
00:05:52 <glguy> MonadLib, the same place you got ReaderT from
00:05:52 <k23z__> are there things I can do in ghci and not in ghc --make  ?
00:06:06 <k23z__> I mean can interpreted code in Haskell do things that compiled code can't ?
00:06:29 <djahandarie> Oh, I see it
00:06:44 <k23z__> I mean can interpreted code in Haskell do things that Haskell compiled code can't ?
00:07:39 <pastorn> k23z__: no, there's no magical boundries that are laid upon the interpreter (afaik)
00:08:19 <k23z__> pastorn, does the binary of some program.hs compiled with ghc --make program.hs   include some small interpreter ?
00:08:29 <glguy> k23z__: no, it just includes the run-time system
00:08:29 <pastorn> no
00:08:55 <pastorn> glguy: the RTS is GC + what else?
00:08:56 <Jafet> If you call the loader an interpreter
00:09:08 <Jafet> Threads
00:09:45 <k23z__> glguy, and what kind of "magical" things that normal runtimes don't do does the GHC runtime do ? does it inspect/determine the flow of the program and see what kind of initializations need to be made or things like that ?
00:10:12 <djahandarie> glguy, would liftIO = inBase ?
00:10:28 * glguy refuses to support mtl!
00:10:34 <Jafet> ghc compiles to gcc C or operating system machine code, k23z
00:11:05 * glguy isn’t comfortable enough with the RTS to teach anyone about what it is /:-)
00:11:45 <copumpkin> it compiles to "c"
00:11:54 <copumpkin> which is horrendous and being phased out
00:12:10 <Jafet> Isn't it already phased out
00:12:27 <Jafet> Or perhaps already being phased out
00:12:31 <pastorn> k23z__: in the future it'll only be using its LLVM super powers
00:13:46 <Jafet> Which ironically, allows it to target virtual machine
00:16:00 <k23z__> pastorn, glguy , copumpkin , Jafet  thanks :)
00:19:15 <Kaidelong> what's the FIFO data structure haskellers generally use?
00:19:29 <pastorn> Kaidelong: a stack?
00:19:36 <Kaidelong> stacks are FILO
00:19:39 <pastorn> oh
00:19:41 <Kaidelong> I need FIFO
00:19:46 <pastorn> you want a doubly linked list?
00:19:48 <pastorn> sort of?
00:19:50 <Kaidelong> yeah
00:19:54 <Kaidelong> that would do it
00:19:55 <glguy> Kaidelong: you can do it in amortized constant time with two stacks
00:19:55 * Jafet pads the cluebat
00:20:10 <pastorn> newtype DLL a = DLL ([a], [a])
00:20:22 <pastorn> Kaidelong: that usually works...
00:20:40 <pastorn> put new stuff in the right pile, take stuff from the left
00:20:51 <Jafet> If you want it this hard way, Okasaki has properly implemented this sort of queue
00:21:01 <olsner> I might use a lazily generated list instead, if possible
00:21:19 <BMeph> Do it in O(1) time - use three stacks! ;)
00:21:31 <Jafet> Less seriously, http://hackage.haskell.org/packages/archive/procrastinating-structure/1.0.1/doc/html/Data-PVar-Queue.html
00:21:40 <pastorn> Kaidelong: if you use a DList you have O(1) for adding to either end (i think)
00:22:03 <Kaidelong> pastorn: yes, I did not know the name of the doubly linked list though
00:22:07 <Kaidelong> it is DList then?
00:22:15 <BMeph> Jafet: That's an interesting-looking package...I'll have to check it out some time... ;)
00:22:24 <pastorn> Kaidelong: DList is a fast version of lists
00:22:27 <pastorn> @where DList
00:22:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
00:23:00 <k23z__> how is lazy evaluation implemented into Haskell ?
00:23:17 <pastorn> k23z__: geee... ask something simpler, will you?
00:23:22 * Jafet swings the cluebat at k23z making a satisfying "thunk" sound
00:23:35 <pastorn> k23z__: for each value you have something called a "thunk"
00:23:46 <opqdonut> k23z__: every value can be a thunk (think a function pointer). when somebody tries to access the value, the thunk gets evaluated, and the value replaced
00:23:46 <k23z__> I mean, does GHC generate additional code around the parts of the program where lazy evaluation is used so that it can make it possible ?
00:24:06 <opqdonut> it's used everywhere
00:24:24 <opqdonut> later compile steps can detect places where stuff is actually strict (non-lazy) and optimize that
00:24:46 <Jafet> It's not a C function pointer, but it's similar to gcc C closures.
00:24:55 <opqdonut> i'm glossing here :)
00:25:06 <pastorn> i was thinking...
00:25:14 <IceKiller> does anybody know how top coul dbe more efficient?
00:25:23 <pastorn> i don't want to liftIO my functions... is there a way to import + reexport functions
00:25:28 <opqdonut> k23z__: see http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/ for a book on the subject
00:25:42 <pastorn> changing type signatures from IO a ==> (MonadIO mio) => mio a
00:26:03 <pastorn> is this something for template haskell?
00:26:36 <pastorn> (i don't feel like manually writing 400 lines of f = liftIO System.IO.f
00:28:35 <dv-> You could liftIO $ do ...
00:28:55 <pastorn> dv-: yeah' i've started doing that a bit, but still
00:29:13 <pastorn> i want to treat my IO functions as first class citizens in my monad
00:30:34 <k23z__> opqdonut, I've downloaded that book, I'd like to flip to a specific page describing how it's actually done, I'm reading 193 now because in the TOC I saw the "lazy" word first used there
00:30:55 <Kaidelong> glguy: right, I learned that a long time ago and forgot it
00:31:08 <Kaidelong> so, so long as you don't need JUST the head
00:31:13 <Kaidelong> using reverse is fine
00:31:18 <Kaidelong> the complexity added is constant
00:31:33 <Kaidelong> thanks
00:34:15 <Jafet> Only if the queue isn't persistent.
00:34:20 <pastorn> Kaidelong: i see a monad in the making...
00:34:32 <k23z__> has anyone here ever felt the need to write Haskell code(or code in general) on two columns  becuase both columns were so similar ?
00:34:33 <Kaidelong> I've installed dlist anyway
00:34:37 <Kaidelong> I'll take a look at it
00:34:52 <Kaidelong> it'll still be faster than reversing a singly linked list, if only by a constant factor
00:34:55 <Twey> k23z__: No… you're doing it wrong.  Generalise more.
00:35:04 <pastorn> FIFO e a = FIFO ([e],[e]) -> (a,[e],[e]))
00:35:51 <pastorn> k23z__: ehm.... what are you talking about?
00:40:16 <k23z__> pastorn, when you write cod
00:40:18 <k23z__> code
00:40:26 <pastorn> yes?
00:40:29 <k23z__> did you ever feel the need to write it on two columns
00:40:35 <pastorn> nevar
00:40:45 <k23z__> well I do, I have weird feelings
00:40:55 <pastorn> for your sister?
00:41:01 <glguy> :-/
00:41:09 <pastorn> k23z__: not cool
00:42:00 <Kaidelong> Well I tend to write my code with = aligned, if that counts
00:42:17 <pastorn> k23z__: what's the columns for? if i have two files open at the same time i have the 2nd one to read from (to know how to properly use what i'm calling)
00:42:19 <k23z__> pastorn,   my sister is programming C# and some VBA  , I do have some weird feelings about that ..
00:42:20 <Kaidelong> or | or -> or whatever
00:42:30 <pastorn> hahhahahaa
00:42:40 <k23z__> pastorn, please don't make fun of her
00:42:50 <pastorn> k23z__: it's very hard not to
00:42:52 <Kaidelong> What's wrong with C# and VBA?
00:43:02 <k23z__> Kaidelong, yeah that's what I was saying
00:43:04 <pastorn> she must be very "special"
00:43:22 <k23z__> she's an average programmer
00:43:25 <k23z__> like me
00:43:34 <k23z__> and many other programmers out there
00:43:39 <Kaidelong> it is unusual for women to program and work with computers but that's a good reason to be supportive of it and not call out that it is unusual
00:43:52 <pastorn> Kaidelong: here... i have some naughty stuff i want to show you:
00:43:53 <pastorn> http://codepad.org/gvx3NTp0
00:43:56 <Kaidelong> if they're self concious about being programmers
00:44:02 <Kaidelong> then they're more likely to do something else
00:44:24 <k23z__> Kaidelong, I know women who know Haskell much better than me and I must contradict you on that, and I've met some very smart women until now, so that myth has been abolished in my mind
00:44:43 <Kaidelong> k23z__: it's a cultural thing. Nothing to do with physical prowess
00:45:03 <Kaidelong> my sister took a programming class and felt excluded because of her gender
00:45:15 <pastorn> :(
00:45:17 * glguy guesses that pastorn was just making fun of VBA
00:45:24 * pastorn was
00:45:43 <glguy> people interested in jumping into a gender-issues in programming can join #haskell-blah
00:45:49 <harblcat> I'm trying to use binary trees to brute-force the '24-game' math puzzle... Not sure how to turn a tuple into all possible binary trees using the given numbers.
00:46:05 <glguy> pastorn can avoid saying things like "for your sister?"
00:46:25 <k23z__> harblcat, enumerate all possible valid paranthesis expressions of length L
00:46:30 <freiksenet1> hello! how are events/messages usually implemented in haskell? Message are side effects, is there a functional way to do this kind of things?
00:46:34 <pastorn> harblcat: have you properly set up jack bauer?
00:46:44 * pastorn is extremely boring today
00:46:56 <harblcat> pastorn: he is ineffective...
00:47:09 <Kaidelong> freiksenet1: there are a lot of ways to do it and you'll have to pick something out
00:47:10 <glguy> freiksenet1: The Chan is often used for sending and receiving events
00:47:23 <glguy> (across threads)
00:47:47 <freiksenet1> hmm
00:47:57 <harblcat> k23z__: well, I'd do that, except I'm working with the actual trees, and I don't want to have to wrap some evaluation stuff in there too.
00:47:59 <freiksenet1> I just though that I probably don't really need non-functional events here
00:48:01 <freiksenet1> thanks
00:48:20 <Kaidelong> freiksenet: what are you trying to do?
00:48:26 <harblcat> looking for a way to go from tuple-of-four-numbers to list-of-possible-trees.
00:48:44 <freiksenet1> something like a game event loop, where some things can push events too
00:48:56 <Kaidelong> harblcat: sounds like something you can do with a list comprehension
00:48:57 <freiksenet1> but I figured as events are not really asynchronous I don't really need messages
00:49:11 <Kaidelong> freiksenet1: you don't. You could parameterize your state
00:49:15 <freiksenet1> yeah
00:49:48 <harblcat> well, I can already use Data.List.permutations for the permuting, and nub that to not waste time. I'm more perplexed on how to get the structures of the trees.
00:50:27 <Kaidelong> doThings :: InsideWorld -> OutsideWorld -> InsideWorld
00:50:29 <harblcat> I could have (a+b)+c+d and a+b+(c+d)... which are the same, but it's an example.
00:50:29 <Kaidelong> something like that
00:53:10 <ivanm> has there been a changelog for the RC for 6.12.3?
00:53:35 <k23z__> harblcat, www.1stworks.com/ref/RuskeyCombGen.pdf     page 74
00:53:54 <ClaudiusMaximus> sounds like http://www.haskell.org/haskellwiki/Haskell_Quiz/Countdown
00:55:37 <Kaidelong> harblcat: what comes to my mind is to make a union type of [a] and a, and then have a function that either returns the only tree it can generate with 0 more places to put another thing, or returns a list of trees that can still be generated
00:55:42 <k23z__> harblcat, HTH
00:55:43 <Kaidelong> then flatten it into a list
00:56:11 <Kaidelong> a recursive approach
00:56:57 <Kaidelong> since you're unifying the concept of things with list of things, the trees that can still be generated can themselves be lists of trees
00:57:30 <k23z__> harblcat, what you wrote depends on the associativity of the operators involved in your expression http://en.wikipedia.org/wiki/Associativity
00:58:37 <k23z__> in the case that you mentioned all possible ways to choose parenthesis are equivalent since it doesn't change anything due to associativity of +
00:59:03 <harblcat> k23z__: the operations I'm going to use are simple +, -, *, and /
00:59:09 <k23z__> if you had an operation that was not associative with its neighbours then things would've surely changed
00:59:19 <harblcat> right
00:59:34 <Kaidelong> - is left associative, not commutative
00:59:43 <Kaidelong> same with /
00:59:46 <k23z__> harblcat, you want to count the distinct ways to parse an expression ?
01:00:22 <Kaidelong> k23z__: that'd just be finding a catalan number wouldn't it?
01:00:35 <harblcat> no, actually I want to find all possible ways to make four numbers come out to 24.
01:00:58 <glguy> project euler?
01:01:21 <harblcat> ?
01:01:36 <Kaidelong> harblcat: there are infinite possible ways
01:01:44 <k23z__> Kaidelong, the catalan number is all valid ways to write N parenthesis so that it's a balanced sequence (meaning what everyone knows it means from basic arithtmetic)
01:01:50 <glguy> ؟
01:02:12 <Kaidelong> 24 + 1 - 2 + 1
01:02:18 <Kaidelong> 24 + 2 - 4 + 2
01:02:26 <Kaidelong> 24 + 4 - 8 + 4
01:02:29 <Kaidelong> etc...
01:02:34 <harblcat> infinite?
01:02:40 <pastorn> harblcat: yes
01:02:48 <harblcat> I don't think so..
01:02:48 <pastorn> using bignums
01:02:58 <harblcat> only numbers 1-9.
01:03:04 <Kaidelong> then there are not
01:03:07 <pastorn> 24 + n +n - (2*n)
01:03:10 <k23z__> harblcat, you most likely have a finite number of symbols you can use and your expression must be finite and probably bounded to something, otherwise the problem makes little sense. this is a counting problem ...
01:03:10 <pastorn> oh, all right
01:04:43 <harblcat> I merely want to figure out if it is possible to make 24 with all possible combinations of the numbers 1 through 9.
01:05:23 <Kaidelong> harblcat: iterate through the permutations and try every arrangement?
01:05:36 <pastorn> harblcat: using +, *, -, /?
01:05:38 <Kaidelong> terminate if one does not ever yield 24?
01:05:44 <harblcat> pastorn: yes
01:05:54 <pastorn> so division is possible?
01:06:08 <harblcat> yes, so there will be fractional results.
01:06:37 <pastorn> harblcat: do it in the type system :D
01:07:00 <pastorn> (then you can't typecheck if you do bad divisions)
01:07:05 <k23z__> harblcat, you can even evaluate partially along the way, for example if you see you have (7*(...))   it's pretty clear that's not going to amount to 24 ..
01:07:39 <Kaidelong> 7*((8*3)/7)
01:07:41 <k23z__> harblcat, if you find a way to recursively enumerate all expressions and cut some of the recursion branches along the way with slick, clever-like choices then you're done pronto
01:07:52 <k23z__> Kaidelong, err, you're right :)
01:07:59 <harblcat> k23z__: right... right now I'm having architecture problems.
01:08:12 <harblcat> 'where do I start?' etc..
01:08:40 <pastorn> harblcat: i'd make an expression type, but that's just me
01:08:56 <harblcat> already got one. Nodes and Values.
01:09:02 <pastorn> data Exp = N Int | Add Exp Exp ...
01:09:07 <k23z__> harblcat, how about operators ?
01:09:13 <harblcat> Ops, too, Plus, Minus, Multiply, Divide.
01:09:16 <pastorn> harblcat: something like that &&&
01:09:17 <pastorn> ^^^
01:09:36 <k23z__> harblcat, first just generate all expressions of a given length, then you'll smart that out with various optimizations
01:09:37 <harblcat> so it would be Node (Value 5) (Plus) (Value 10) or something.
01:10:32 <c_wraith> Is there a way to specify compiler options with Hint?  I need to hide some packages.
01:10:45 <c_wraith> Or am I stuck falling back to the ghc api?
01:11:04 <pastorn> harblcat: it'd probably be easier if you just have the one type :)
01:11:16 <pastorn> instead of separating Ops and Values
01:11:20 <c_wraith> oh, hmm.  there's unsafeSetGHCOption
01:11:23 <harblcat> hmm, maybe..
01:11:28 <harblcat> I'll give it a go
01:11:30 <pastorn> harblcat: also, you can have infix operators in haskell
01:12:03 <pastorn> data Exp = N Int | :+ Exp Exp | :* Exp Exp
01:12:13 <pastorn> but when you use them you'll write (e0 :+ e1)
01:12:25 <k23z__> harblcat, what problem is this anyway ? Project Euler ?
01:12:30 <harblcat> oh? that sounds cool.
01:12:36 <roconnor> when I build something with Setup.hs, how do I use it without installing it?
01:12:37 <mornfall> harblcat: Well, clearly if any divisor of 24 is in the allowed set, it's possible with just addition.
01:12:40 <harblcat> k23z__: no, no project euler, just curiousity
01:12:47 <mornfall> harblcat: (Or 1...)
01:13:19 <mornfall> harblcat: So the interesting sets are just those composed of 5, 7 and 9.
01:13:40 <mornfall> harblcat: Ah, I missed the bit about 4 numbers.
01:13:43 <mornfall> harblcat: Or no?
01:13:48 <harblcat> mornfall: I was puzzled with the set 1, 3, 4, and 6
01:14:07 <harblcat> sets of four numbers, with the added stipulation that they must be unique.
01:14:23 <ivanm> preflex: seen mmorrow
01:14:23 <preflex>  mmorrow was last seen on #ghc 127 days, 5 hours, 16 minutes and 38 seconds ago, saying: * mmorrow is rtfm'ing
01:14:34 <ivanm> he really is taking a long time to read that manual... >_>
01:14:36 <mornfall> harblcat: So just permute the operations in between those 4 numbers and see if anything gets you 24?
01:14:51 <harblcat> ...is what I'm working on doing :)
01:14:52 <mornfall> That's very finite and quite simple even.
01:15:08 * harblcat is fairly fresh at haskell still
01:16:38 <roconnor> > replicateM 3 ["times" "plus"]
01:16:39 <lambdabot>   Couldn't match expected type `t -> a'
01:16:39 <lambdabot>         against inferred type `[GHC.T...
01:17:00 <roconnor> > replicateM 3 ["times", "plus"]
01:17:01 <lambdabot>   [["times","times","times"],["times","times","plus"],["times","plus","times"...
01:17:13 <glguy> Anyone know how to update PATH on OS X so that applications launched from the GUI see the change and not just applications started from bash? It would need to be user specific as I’d like to add ~/.cabal/bin
01:17:36 <harblcat> replicateM?
01:17:40 <harblcat> wat
01:19:43 <harblcat> understanding how that works is making my brain hurt...
01:20:40 <harblcat> is it through some feature of the List monad?
01:20:48 <harblcat> > replicateM 3 $ Just 4
01:20:49 <lambdabot>   Just [4,4,4]
01:20:59 <harblcat> ...is what I would expect.
01:23:04 <pastorn> > replicateM 3 [1,2,3]
01:23:05 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
01:23:20 <pastorn> > replicateM 3 [1,2]
01:23:21 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
01:23:40 <pastorn> harblcat: replicateM 4 [0..9]
01:23:40 <harblcat> right, I get that it does that, but I don't particularly understand why...
01:23:53 <pastorn> @src replicateM
01:23:53 <lambdabot> replicateM n x = sequence (replicate n x)
01:24:12 <pastorn> @src sequence
01:24:12 <lambdabot> sequence []     = return []
01:24:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:24:12 <lambdabot> --OR
01:24:12 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
01:24:23 <pastorn> lolwut?
01:24:44 <harblcat> woo..
01:25:01 <harblcat> I can see hanging around here can melt brains.
01:25:04 <pastorn> harblcat: write out the first definition with line breaks etc.
01:25:11 <harblcat> I sorta-kinda get it, though.
01:25:16 <pastorn> then it's probably easier to see
01:25:49 * hackagebot gtk2hs-buildtools 0.9 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.9 (AxelSimon)
01:25:51 * hackagebot glib 0.11.0 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.11.0 (AxelSimon)
01:25:51 <Twey> The second is clearer pe'i
01:25:53 * hackagebot gio 0.11.0 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.11.0 (AxelSimon)
01:26:24 <Cale> harblcat: "running" a list in the list monad means selecting an element from it in all possible ways, and sequence runs each of the actions in a list, producing a list of the results.
01:26:47 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
01:26:48 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
01:26:49 * hackagebot cairo 0.11.0 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.11.0 (AxelSimon)
01:26:51 * hackagebot pango 0.11.0 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.11.0 (AxelSimon)
01:27:02 <harblcat> hmm..
01:27:03 <Cale> So sequence picks an element from each of the lists in all possible ways
01:27:13 <harblcat> I see
01:27:53 * hackagebot gtk 0.11.0 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.11.0 (AxelSimon)
01:27:55 * hackagebot gconf 0.11.0 - Binding to the GNOME configuration database system.  http://hackage.haskell.org/package/gconf-0.11.0 (AxelSimon)
01:27:57 * hackagebot glade 0.11.0 - Binding to the glade library.  http://hackage.haskell.org/package/glade-0.11.0 (AxelSimon)
01:27:59 * hackagebot gnomevfs 0.11.0 - Binding to the GNOME Virtual File System library.  http://hackage.haskell.org/package/gnomevfs-0.11.0 (AxelSimon)
01:28:02 * hackagebot gstreamer 0.11.0 - Binding to the GStreamer open source multimedia framework.  http://hackage.haskell.org/package/gstreamer-0.11.0 (AxelSimon)
01:28:23 <Twey> Ooh.
01:28:31 <Twey> Is this leading up to a Cabalised Gtk2Hs?
01:28:45 <pastorn> seems like it :)
01:28:47 <Cale> It looks like it is a cabalised gtk2hs
01:29:04 * hackagebot gtkglext 0.11.0 - Binding to the GTK+ OpenGL Extension  http://hackage.haskell.org/package/gtkglext-0.11.0 (AxelSimon)
01:29:06 * hackagebot gtksourceview2 0.11.0 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.11.0 (AxelSimon)
01:29:08 * hackagebot soegtk 0.11.0 - GUI functions as used in the book "The Haskell School of Expression".  http://hackage.haskell.org/package/soegtk-0.11.0 (AxelSimon)
01:29:10 * hackagebot svgcairo 0.11.0 - Binding to the GTK+ OpenGL Extension  http://hackage.haskell.org/package/svgcairo-0.11.0 (AxelSimon)
01:29:12 * hackagebot vte 0.11.0 - Binding to the VTE library.  http://hackage.haskell.org/package/vte-0.11.0 (AxelSimon)
01:29:12 <Twey> I think these are direct bindings
01:29:17 <Cale> http://hackage.haskell.org/package/gtk
01:29:17 <mux> oh yay, cabalized gtk2hs
01:29:23 <Twey> Apart from soegtk
01:29:32 <Twey> Ooh.
01:29:40 <Twey> Alrighty then.
01:29:42 <Twey> Awesome.
01:30:13 <copumpkin> holy crap
01:30:14 * hackagebot webkit 0.11.0 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.11.0 (AxelSimon)
01:30:22 <copumpkin> that's a lot of stuff uploaded at once
01:30:23 * mux hearts axel simon
01:30:32 <Twey> Wonder how long he's been sitting on that lot
01:30:44 <copumpkin> WebKit under GTK :o
01:30:47 <Twey> \o/
01:30:55 <Twey> Argh, I'm late -runs-
01:31:00 <mux> copumpkin: yes, this is awesome too :-P
01:31:14 <pastorn> isn't webkit that google thingy for making java into HTML + CSS + JS?
01:31:22 <copumpkin> so wait, is gtk2hs cabalized now?
01:31:26 <mux> we're talking about webkit-gtk2 here, obviously
01:31:32 <mux> not bare webkit
01:31:47 <copumpkin> very nice!
01:31:55 <mux> pastorn: webkit is originally an apple thing btw, even though google is one of the main contributor now
01:32:04 <copumpkin> http://www.haskell.org/gtk2hs/
01:32:19 <Ke> mux: originally kde thing
01:32:25 <copumpkin> excellent!
01:32:32 <Ke> webkit is a khtml derivative
01:32:40 <mux> well, it's a khtml fork
01:32:45 <mux> but that's loooong ago now.
01:33:06 <mux> there is much more to attribute to apple in there than to kde
01:33:45 <mornfall> mux: That's bullshit.
01:34:11 <mux> mornfall: that's a nice argument you're sharing there.
01:34:34 <mornfall> mux: What was yours? It's so because I say so?
01:34:41 <mux> whatever
01:38:22 <carbonix> hello
01:38:34 <Cale> hello
01:39:08 <carbonix> I'm having a small haskell issue:). and was wondering that anyone might answer this simple question.. why do I get an error on these 2 line of code? http://pastebin.com/fnLK7hA4
01:39:22 <Cale> Sure, I'll have a look
01:40:30 <Cale> Well, the indentation is a bit weird, but otherwise, that code typechecks
01:40:36 <Cale> What error are you getting
01:40:38 <Cale> ?
01:41:07 <carbonix> unresolved overloading
01:41:18 <carbonix> *** Type       : (RealFrac a, Integral a) => [[a]]
01:41:38 <carbonix> if instead of maxval I use front/2, for example
01:41:47 <carbonix> I get the desired result.. but everything with decimals
01:41:54 <mux> carbonix: looks like you are trying to use a number as both an integral and a fractional
01:42:17 <carbonix> mux: I don't understand from where does this come from
01:42:19 <Cale> Oh, right, that code typechecks, but with a pretty useless type :)
01:42:27 <carbonix> for example, I tried part [[11]]
01:42:44 <Cale> Because you have front/2 there, it means that the type of front must be a Fractional type
01:42:53 <Cale> (Rational, Float, Double, etc.)
01:42:56 <mux> fromIntegral front/2 I guess?
01:43:12 <Cale> and because maxval is the result of floor, it must have Integral type
01:43:19 <mux> unless you really wanted integral division, in which case use `div`
01:44:08 <Cale> and so k has some Integral type, and so front - k must have an Integral type as well
01:44:17 <Cale> But there aren't any types which are both Integral and Fractional
01:44:18 <carbonix> ok, I understand the problem:)
01:44:34 <carbonix> indeed I wanted an integral division
01:44:54 <carbonix> thanks for the explanations
01:45:07 <mux> those type errors are always a bit surprising/confusing when you come from a world where implicit numerical coercion is the norm
01:45:14 <Cale> Sure, let us know if you have any more problems :)
01:46:09 <carbonix> true, that was my main problem, I didn't get the fact that I actually can't do the conversions from one type to another
01:46:33 <mux> you'll get used to it in no time ;-)
01:47:42 <ivanm> Axman6: ping
01:51:01 <quicksilver> mux: although, actually, C/C++ implicit numerical conversion doesn't work the way many programmers seem to expect.
01:51:12 <quicksilver> mux: so that world is not so rosy either.
01:51:27 <quicksilver> mux: float x = 3/4; printf("x = %f\n",x);
01:51:30 <mux> I never meant to say that world is rosy; on the contrary, I find it's unsafe and dirty
01:51:45 <quicksilver> my point is that not only is it unsafe, it's not even DWIM.
01:51:52 <mux> what I said is that it's confusing to have such type errors in haskell when you're used to implicit coercions, nothing more
01:52:03 <quicksilver> in fact, haskell does manage to DWIM for that kind of case ;)
01:52:13 <quicksilver> (perl and python both DWIM there, too)
01:52:32 <quicksilver> mux: hey, I'm not disagreeing with you :) I'm just continuing the remarks.
01:52:41 <mux> okay :)
01:52:53 <quicksilver> I think many moderately inexperienced C programmers expect 0.75 from the above code.
01:53:13 <mux> anyone else tried to install the cabalized gtk2hs? somehow gio fails to install because it cannot open "shal.list" - which seems weird, it should try to open "marshal.list" instead
01:53:17 <ivanm> preflex: seen Axman6
01:53:17 <preflex>  Axman6 was last seen on #ghc 7 hours, 53 minutes and 48 seconds ago, saying: g'day rl
01:53:27 <mux> grep(1) didn't help me understand this, I can't see where this comes from
01:53:42 <ManateeLazyCat> We have ready to release gtk2hs-0.11, but we want generate some packages documentation (glib, gio, pango, cairo, gtk) in *one* place, so how to do this with "cabal haddock" ? Thanks!
01:54:14 <Starfire> I read somewhere that C's weird implicit conversion stuff is partly because C didn't initially support floating point numbers.
01:54:17 <arcatan> what does that code give then? 0?
01:55:33 <ManateeLazyCat> We want combine all gtk2hs core packages documentation (glib, gio, pango, cairo, gtk) in *one* index.html.
01:57:43 * ManateeLazyCat Sorry, emacs again, i missing answer?
01:57:46 * ManateeLazyCat emacs crash again.
01:58:33 * eevar2 suggests irssi/xchat in a separate terminal
01:59:00 * ManateeLazyCat I use erc.
01:59:30 * ManateeLazyCat Hate Emacs....
02:00:44 <Jafet> Start separate emacs for erc!
02:00:46 <Peaker> quicksilver, Python only DWIM there in Python>=3
02:01:42 <ManateeLazyCat> Jafet: No, i won't use Emacs anymore.
02:02:05 <Jafet> gtkmacs? Wait, there's no such port.
02:03:08 <ManateeLazyCat> Jafet: I'm not that mean, i have use gtk2hs develop Emacs replace, so i won't use Emacs when my program release.
02:03:56 <ManateeLazyCat> Do you anyone know "Combining haddock documentation from multiple	packages" ?
02:08:24 <Gracenotes> do you anyone know :o
02:08:35 <Gracenotes> well, it's done for all the GHC base libraries
02:09:00 <Gracenotes> see - http://www.haskell.org/ghc/docs/6.12.2/html/libraries/index.html
02:10:31 <Gracenotes> how it's done, I can't help you.. as a superindex, it just ends up referencing the individual package docs
02:10:54 <Peaker> does "foldr (.) id" have a name?
02:11:08 * ski usually calls it `compose'
02:11:42 <Peaker> Adding to my Data.Function.Utils
02:11:46 <ManateeLazyCat> Gracenotes: We have some individual packages (glib, gio, pano, cairo, gtk) in gtk2hs repository, we want haddock generate documentation in *one* place, and build a index page for those packages.
02:11:46 <ivanm> as good a name as any I suppose
02:12:40 <siracusa> ManateeLazyCat: See http://www.haskell.org/haddock/haddock-html-0.8/invoking.html, I don't know exactly how, but it must be a combination of --use-index, --gen-index and -read-interface.
02:13:00 <ManateeLazyCat> siracusa: Thanks, i read it.
02:13:51 <Gracenotes> delicious haddock...
02:14:29 * ManateeLazyCat We can release gtk2hs-0.11 today after fix documentation problem
02:14:31 <Gracenotes> Peaker: does (last . sequence) work? :)
02:14:52 <Gracenotes> two names.. -.-
02:15:27 <Gracenotes> sequence would just be analogous to scanr, wouldn't it... ah, I'm too easily entertained this early in the morning
02:15:56 <ivanm> greetings m3ga
02:16:46 <Peaker> @type last . sequence
02:16:47 <lambdabot> forall a. [[a]] -> [a]
02:16:49 <m3ga> ivan!
02:16:53 <Peaker> @type foldr (.) id
02:16:55 <lambdabot> forall b. [b -> b] -> b -> b
02:17:06 <ibt> i have a large number of nested ifs where the conditions are from IO. is there a common solution to making this look neater?
02:17:24 <Gracenotes> hm
02:18:13 <Gracenotes> oh, I see, wrong placement of (.)s...
02:18:16 <Gracenotes> @type (last .) . sequence
02:18:17 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => [f a] -> f a
02:19:48 <Peaker> @type [(last .) . sequence, foldr (.) id]
02:19:49 <ski> @type let (.) = (Prelude..) in (last .) . sequence
02:19:49 <lambdabot> forall b. [[b -> b] -> b -> b]
02:19:50 <lambdabot> forall a a1. [a1 -> a] -> a1 -> a
02:20:17 <ski> .. and the type of that tells us that it is different from `foldr (.) id'
02:20:34 <Peaker> Gracenotes, foldr (.) id is beginning to appear more appealing eh? :)
02:20:59 <Peaker> yeah, indeed
02:21:16 <Gracenotes> different? seems more general to me...
02:21:19 <Peaker> it would just apply the last function
02:21:44 <Gracenotes> oooh.
02:21:45 <Peaker> Gracenotes, it is more general because it doesn't have to do that pesky thing of actually feeding results to the next function :)
02:21:47 <Gracenotes> right you are.
02:21:53 <ski> > ((last .) . sequence) [(*2),(3^)] 4
02:21:54 <lambdabot>   81
02:21:56 <Gracenotes> pesky reader monad
02:22:06 <Gracenotes> the types have defeated me
02:22:34 <Peaker> I'll stop using the [] unification trick -- it is misleading
02:22:34 <Peaker> (The more general type you might get may suggest a mistake as it does here)
02:23:02 <siracusa> ManateeLazyCat: I have successfully built these packages on Windows with GHC 6.10.4 and Gtk+ 2.18: glib, gio, cairo, pango, gtk, gtksourceview2, glade, gtkglext. The last one was a bit tricky, but the rest very easy. The cabal packages are really great! :-)
02:23:30 <Gracenotes> I'm not sure if it's possible to get arrow-like behavior from the reader-function-monad
02:23:30 <ski> (it is useful if you actually want a glb, instead of a lub)
02:24:52 <ManateeLazyCat> siracusa: Glad to hear that, you need thanks Axel. :)
02:24:53 <Gracenotes> :t foldr local id
02:24:55 <lambdabot> forall a. [a -> a] -> a -> a
02:26:07 <ski> @type execState . sequence_ . map modify  -- not `Reader'
02:26:08 <lambdabot> forall s. [s -> s] -> s -> s
02:26:20 <ManateeLazyCat> siracusa: I try to generate all gtk2hs-core packages documentation in one place now.... Then gtk2hs user can find gtk2hs APIs easily.
02:27:06 <ManateeLazyCat> siracusa: Please let me know if you know how to do that. :) I'm reading haddock manual....
02:28:21 <siracusa> ManateeLazyCat: No, I never tried that, sorry.
02:29:08 <ManateeLazyCat> siracusa: I want documentation is more easier to users, it's not big program if i failed... :)
02:29:52 <ManateeLazyCat> s/big program/big problem
02:30:20 <ski> > foldr (.) id [\x -> concat ["(",x,")"],reverse] "abcd"
02:30:21 <ski> > foldr local id [\x -> concat ["(",x,")"],reverse] "abcd"
02:30:21 <lambdabot>   "(dcba)"
02:30:22 <lambdabot>   ")dcba("
02:42:15 <greap> Hi. I'm getting the warning [cabal: Couldn't read cabal file "./hellage/0.1/hellage.cabal"] when I try to use cabal.
02:42:50 <greap> It's referenced in the cabal index, but there's no package directory, so I'm not sure why it's trying to read it.
02:43:05 <greap> Even for a 'cabal list' call.
02:44:09 <greap> I've had a look around and there's a japanese guy that has tweeted about it happening to him, but that's all I could find: http://twitter.com/ranha/status/13954962378
02:48:52 <ivanm> greap: what are you actually doing?
02:49:06 <ivanm> can you paste up a log of what commands you use and the error messages?
02:49:08 <ivanm> @hpaste
02:49:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:49:42 <ivanm> greap: oh, wait, have you configured to use some alternate hackage mirror or something?
02:50:46 <quicksilver> Cale: hmm, we should change hpaste :-(
02:50:53 <quicksilver> Cale: change @hpaste, that is.
02:52:23 * hackagebot wai-extra 0.1.2.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.1.2.1 (MichaelSnoyman)
02:53:10 <ivanm> quicksilver: do you have any idea what's happened to mmorrow?
02:53:32 <ivanm> we were just discussing that before in -blah; I tried googling him but there hasn't been any mention of him since 24 December 2009 :s
02:53:43 <ivanm> was his christmas present the disconnection from the net or something? >_>
02:54:15 <greap> ivanm: I actually just upgraded cabal-install and the messages no longer happen.
02:54:19 <dcoutts> greap: I think there's not a lot you can do except to upgrade
02:54:30 <ivanm> dcoutts: heh, he beat you to it ;-)
02:54:40 <greap> Still it was quite odd.
02:54:47 <dcoutts> greap: it's due to a package file that contains new syntax that older cabal versions do not grok
02:54:57 <ivanm> dcoutts: oh? what syntax was that?
02:54:59 <greap> ah, makes sense
02:55:04 <dcoutts> it slipped past our filters
02:55:32 <dcoutts> ivan: Build-Depends: base (>= 4.2)
02:55:33 <ivanm> nothing there seems obviously different/wrong ...
02:55:43 <dcoutts> erm I mean ivanm
02:56:02 <ivanm> ooohhh.... is that valid? :o
02:56:20 <dcoutts> ivan: 1.8 allows ()'s and multiple && || clauses
02:56:29 <dcoutts> but this one only says it needs 1.4
02:56:30 <ivanm> hmmm....
02:56:40 <ivanm> dcoutts: so it's a bug in the cabal file?
02:56:53 <dcoutts> the cabal/hackage check catches the multiple clauses bit, but misses the extra ()'s
02:56:59 <dcoutts> ivanm: yes
02:57:18 <ivanm> oh, it's _hackage's_ fault rather than cabal-installs?
02:57:43 <dcoutts> yes, both that the package .cabal file is wrong, and that we did not catch it
02:58:33 <ivanm> I take it newer c-i is a bit laxer specifically because of this?
02:59:01 <dcoutts> newer c-i uses newer Cabal library, which allows the full syntax
02:59:30 <dcoutts> hmm, unfortunately we cannot easily catch this mistake, because the parser throws away ()'s
02:59:46 <dcoutts> so we cannot distinguish old and new syntax from the AST
02:59:53 <ivanm> so the parser is too good? :p
02:59:59 <dcoutts> which is the level where we do the checks
03:01:02 <ManateeLazyCat> gtk2hs-0.11 release!
03:01:22 <dcoutts> http://hackage.haskell.org/package/gtk-0.11.0
03:01:24 <dcoutts> ooooh
03:01:32 <mux> dcoutts: hey, does this ring any bell?
03:01:33 <mux> Configuring gio-0.11.0...
03:01:33 <mux> setup: gtk2hsHookGenerator: shal.list: openFile: does not exist (No such file
03:01:33 <mux> or directory)
03:01:45 <mux> I believe it should try to open marshal.list, and not shal.list
03:01:54 <dcoutts> mux: no, sorry
03:01:55 <quicksilver> the case of the missing mar
03:02:10 <mux> okay, I'll have to dig deeper tonight
03:02:19 <ManateeLazyCat> mux: YOu need install tools first.
03:02:31 <ManateeLazyCat> mux: cd ./tools && cabal install
03:03:01 <ManateeLazyCat> mux: Then switch to gtk2hs directory and do "sh ./bootstrap.sh"
03:03:04 <mux> ManateeLazyCat: this is from a "cabal install gtk" command
03:03:10 <mux> not from source/darcs
03:03:56 <ManateeLazyCat> mux: Okay, i test it.
03:04:02 <ManateeLazyCat> mux: I just know from Axel.
03:11:34 <Cale> @paste
03:11:35 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:11:37 <Cale> hmm
03:11:39 <Cale> okay
03:12:15 <aristid> is that moonpatio.com site better than hpaste.org?
03:12:33 <quicksilver> it used to be the same
03:12:38 <quicksilver> but unfortunately mmorrow is AWOL
03:12:54 <quicksilver> and moonpatio is broken in his extended absence.
03:13:05 <aristid> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25675 <- terrible, terrible URI :(
03:13:07 <ivanm> aristid: it points to moonpatio because at one stage mmorrow upgraded the hpaste server code and got it running on his site before hpaste.org was updated
03:13:26 <quicksilver> well, hpaste.org *was* moonpatio, then.
03:13:26 <copumpkin> @hpaste
03:13:26 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:13:33 <copumpkin> @where paste
03:13:34 <lambdabot> http://hpaste.org/new
03:13:46 <ivanm> quicksilver: well, there was an hpaste.org, but it was down for some reason IIRC
03:13:48 <quicksilver> but it took awhile to update the DNS, which is why @hpaste got changed to mention moonpatio by name.
03:13:56 <quicksilver> ivanm: until we re-pointed the DNS, yes.
03:14:07 <ManateeLazyCat> mux: I have test it, install successful.
03:14:10 <ivanm> ahhh
03:14:51 <aristid> ah, hpaste.org is owned by bos (who's not idling here atm)
03:15:31 <quicksilver> yes, hpaste.org has now been pointed back to another server again
03:15:49 <ManateeLazyCat> mux: I know, you install old Gtk2hsBuildTools
03:16:06 <ManateeLazyCat> mux: It's a bug of old version of gtk2hs-buildtools
03:16:27 <ManateeLazyCat> mux: You need update it with "cabal install gtk2hs-buildtools"
03:16:48 <luite> is it on hackage now?
03:17:11 <ManateeLazyCat> mux: I doubt you install old gtk2hs-buildtools from gtk2hs darcs.
03:17:24 <ManateeLazyCat> mux: And forgot update it.
03:17:46 <ManateeLazyCat> "cabal install gtk" works very well.
03:18:27 <Kaidelong> is "Win32" one of those cabal packages I should not upgrade?
03:18:40 <ivanm> yes
03:18:51 <ivanm> Kaidelong: the only package that comes with GHC that is safe to upgrade is Cabal
03:21:53 <Kaidelong> I see an update to wx-haskell has come down the pipe
03:22:00 <aristid> @pl replicateM n x = sequence (take n $ repeat x)
03:22:01 <lambdabot> replicateM = (sequence .) . (. repeat) . take
03:22:12 <Kaidelong> now to see if paddleball and hello world will run on my machine without segfaulting
03:23:30 <ManateeLazyCat> Kaidelong: segfault? GUI ?
03:23:37 <Kaidelong> yep
03:23:39 <Kaidelong> wxHaskell
03:23:47 <ManateeLazyCat> Kaidelong: Do you use ghc-6.12.2?
03:23:48 <Kaidelong> on my XP machine, 32 bit, it works
03:24:16 <Kaidelong> no, 6.12.1 apparently
03:24:22 <Kaidelong> is that a problem?
03:24:33 <quicksilver> ManateeLazyCat: doesn't that mean that the gtk2hs on hackage should depend on the new version of gtk2hs-buildtools?
03:24:46 <Kaidelong> gtk2hs is on hackage?
03:24:55 <ManateeLazyCat> quicksilver: You need install gtk2hs-buildtools first.
03:25:00 <ManateeLazyCat> quicksilver: Then "cabal install gtk"
03:25:02 <ManateeLazyCat> Kaidelong: Yes!
03:25:06 <Kaidelong> !!!
03:25:09 <Kaidelong> yay
03:25:24 <ManateeLazyCat> Kaidelong: We know ghc-6.12.2 have a runtime bug that make gtk2hs callback got segfault.
03:25:38 <ski> (quicksilver : "AWOL" ?)
03:25:48 <ivanm> ski: as in you don't know what that means?
03:25:53 <ivanm> or you think it doesn't apply here?
03:25:54 <ManateeLazyCat> Kaidelong: But i don't know the detail of wx
03:25:58 <ski> that'd be correct
03:25:58 <Kaidelong> ManateeLazyCat: wasn't you guys giving me the problem, I was using wxHaskell. Mysteriously segfaults on my 64-bit win 7 machine
03:26:10 <ivanm> ski: Away WithOut Leave
03:26:13 <Kaidelong> works fine on my 32 bit XP machine
03:26:18 <ivanm> usually used by the military
03:26:20 <ManateeLazyCat> Kaidelong: http://hackage.haskell.org/trac/ghc/ticket/4038
03:26:28 <ski> ivanm : i see, ty
03:26:41 <ivanm> actually, wikipedia says it should be absent, not away
03:26:47 <quicksilver> ski: in fact, I fear the worst, but I hope for the best.
03:26:48 <ivanm> http://en.wikipedia.org/wiki/AWOL
03:26:54 <ski> @where+ lisppaste <http://paste.lisp.org/new/haskell.hr>,<http://paste.lisp.org/new>
03:26:54 <lambdabot> Nice!
03:26:58 <ManateeLazyCat> Kaidelong: http://hackage.haskell.org/trac/ghc/ticket/4038 is ghc-6.12.2 problem with gtk2hs, maybe will help us wx.
03:27:29 <Kaidelong> manateelazycat: I do not use ghc-6.12.2
03:27:33 <ManateeLazyCat> quicksilver: Because we don't use any library from gtk2hs-buildtools, so you need install gtk2hs-buildtools before you install any glib-depend package.
03:28:05 <ManateeLazyCat> Kaidelong: I know, i just provide that link, maybe have same problem in Windows-64bit/ghc-6.12.1
03:28:15 <Kaidelong> hmm
03:28:28 <Kaidelong> well let me update my wxhaskell distribution first to see if they fixed it
03:28:35 <ivanm> ManateeLazyCat: so that means just doing a "cabal install gtk" will fail then?
03:28:58 <ivanm> dcoutts: is cabal-install smart enough to match up the build-tools for the gtk cabal file to the gtk2hs-buildtools package as a dep?
03:28:58 <ManateeLazyCat> ivanm: "cabal install gtk2hs-buildtools && cabal install gtk"
03:29:05 <Kaidelong> also I'll most likely just be using gtk2hs now since I have experience with gtk that I don't with wx
03:29:09 <dcoutts> ivanm: not yet
03:29:13 <ivanm> ManateeLazyCat: right, I meant that people are going to just try doing "cabal install gtk"
03:29:16 <ivanm> dcoutts: *nod*
03:29:25 <quicksilver> dcoutts: isn't this what dependencies are for?
03:29:25 <ivanm> ManateeLazyCat: so you might want to get some documentation up quick-smart
03:29:33 <dcoutts> quicksilver: of course
03:29:34 <quicksilver> why not just have gtk depend on gtk2hs-buildtools?
03:29:34 <ivanm> quicksilver: except deps are for libraries
03:29:35 <ManateeLazyCat> ivanm: I have suggest Axel that add gtk2hs-buildtools in glib.cabal, but Axel don't like it.
03:29:48 <ivanm> and gtk2hs-buildtools doesn't provide a library
03:29:52 <dcoutts> he doesn't like it because it's wrong
03:29:55 <ivanm> yup
03:30:01 <quicksilver> oh.
03:30:08 <quicksilver> Why are deps for libraries?
03:30:10 <ManateeLazyCat> http://hackage.haskell.org/package/gtk2hs-buildtools
03:30:28 <ivanm> quicksilver: build-tools is for, well, build-tools
03:30:30 <dcoutts> quicksilver: you mean why are library dependencies for libraries
03:30:30 <quicksilver> (or, if you prefer, "Why are deps not for tools, too?")
03:30:54 <ivanm> but it assumes that they match up to the package name for that build tool AFAIK
03:31:13 <ivanm> quicksilver: because that's how it was specified, and Cabal is kept backwards-compatible
03:31:20 <dcoutts> no
03:31:23 <ivanm> oh...
03:31:25 <ivanm> ignore me then :p
03:31:29 * ivanm -> TV
03:31:48 <quicksilver> why does the system distinguish between libraries and build-tools?
03:32:01 <quicksilver> it's just a technical difference, isn't it? the end result is the same?
03:32:11 <dcoutts> quicksilver: because they are different things
03:32:13 <quicksilver> or is this really a distinction between runtime deps and buildtime deps?
03:32:14 <dcoutts> one is a program
03:32:25 <dcoutts> one is a ghc/haskell lib
03:32:25 <ivanm> quicksilver: don't forget, cabal deals with hiding unused libraries, etc.
03:32:33 <quicksilver> I do know the difference between a program and a library ;)
03:32:34 <dcoutts> C libs are different kinds of dependencies again
03:32:36 <ivanm> (so if you specify mtl it won't worry about the module clash with transformers)
03:32:42 <quicksilver> I'm just asking why cabal cares about the difference.
03:32:45 <dcoutts> quicksilver: they're all kinds of dependencies
03:33:03 <dcoutts> quicksilver: because the need was most pressing for libs and that's the problem we solved first
03:33:06 <Kaidelong> do I build gtk2hs and gtk2hs-buildtools under MSYS or the windows shell?
03:33:18 <ManateeLazyCat> Hi all, i have reinstall all gtk2hs packages from hackage, works well. For install Windows, please read http://code.haskell.org/gtk2hs/INSTALL
03:33:23 <dcoutts> quicksilver: of course the dep resolver should be extended to handle the other kinds of dependencies
03:33:34 <quicksilver> OK, but what I don't understand is why that solution couldn't have covered tools too. I'm asking "what is it about tools which requires different handling from libs?"
03:33:35 <ManateeLazyCat> Kaidelong: gtk2hs can install on Windows,
03:33:46 <ManateeLazyCat> Kaidelong: Read http://code.haskell.org/gtk2hs/INSTALL
03:33:50 <ivanm> can an op maybe put a warning message in the topic for when people try to just do "cabal install gtk" and wonder why it doesn't work?
03:34:14 <quicksilver> E.g. debian distinguishs build-deps from run deps, but it doesn't distinguish libraries from executables.
03:34:34 <dcoutts> quicksilver: it's that build-tools does not specify a Haskell package, it specifies a program
03:34:39 <dcoutts> quicksilver: e.g. perl
03:34:42 <ivanm> quicksilver: well, yes, Cabal is a build library, not an install library
03:35:02 <dcoutts> quicksilver: so it's not completely trivial
03:35:06 <quicksilver> dcoutts: OK, things like perl which are outside the system, I can see that's a different issue.
03:35:19 <quicksilver> dcoutts: but gtk2hs-buildtools is inside the system. It is itself a cabal-installable entity.
03:35:25 <dcoutts> quicksilver: furthermore, packages containing executables are not registered
03:35:31 <quicksilver> Ah!
03:35:36 <dcoutts> quicksilver: so it's not a simple extension of the libraries thing
03:35:43 <quicksilver> that sounds like the technical difference I was missing.
03:35:48 <Kaidelong> ManateeLazyCat, do I want GTK 2.20 or 2.16?
03:36:10 <ManateeLazyCat> Kaidelong: No, gtk2hs will decide which APIs will install.
03:36:12 <quicksilver> why not make gtk2hs-buildtools into a library package, which happens to bundle a useful executable?
03:36:42 <Kaidelong> manateelazycat: this is from the installation guide :) it says to put a binary distribution of GTK in my path
03:36:46 <ManateeLazyCat> Kaidelong: I think GTK-2.8 is okay, but you can't use APIs in new GTK+ version
03:37:14 <Kaidelong> the two all-in-one packages are for 2.16 and 2.20... so I have to hunt for an older one?
03:37:16 <ManateeLazyCat> Kaidelong: I don't know the detail of Windows, Axel works on it.
03:37:30 <dcoutts> quicksilver: some packages do that, it's an ugly hack
03:37:48 <ManateeLazyCat> Kaidelong: I test gtk2hs on Linux.
03:38:09 <ManateeLazyCat> Kaidelong: I recommend you use new GTK version.
03:38:21 <siracusa> Kaidelong: I tried it with Gtk 2.18, all works fine. With 2.20 I can't insdtall the gtkglext package for OpenGL support.
03:38:35 <dcoutts> quicksilver: the right thing to do is to extend the dep resolver to handle other deps, like C libs, build-tools etc
03:38:53 <quicksilver> dcoutts: You have better perspective than me. From where I'm standing it seems better to use a 'hack' which makes cabal install gtk work, than wait for the cabal developers to extend the dep resolver, which will not happen to any particular timescale.
03:38:56 <ManateeLazyCat> siracusa: Error message?
03:39:16 <quicksilver> of course from where I'm standing I'm probably not seeing the disadvantages of the hack.
03:39:31 <Kaidelong> siracusa: this on windows?
03:39:41 <Kaidelong> 2.16.6 is my other option
03:39:57 <Kaidelong> I'm downloading both since both were suggested
03:40:03 <ManateeLazyCat> Kaidelong: I think old version will okay if 2.18 can work.
03:40:17 <siracusa> ManateeLazyCat: It fails installing the c package, so this might not necessarily be a gtk2hs problem!
03:40:31 <ManateeLazyCat> siracusa: I see.
03:41:33 <ManateeLazyCat> siracusa: Can you install `webkit` package on Windows?
03:42:35 <siracusa> ManateeLazyCat: I haven't tried yet, I can try later today if you want
03:43:39 <ManateeLazyCat> siracusa: I think all gtk-dependent package should be work if you have install C library in right place.
03:44:04 <dcoutts> quicksilver: it's hard to keep any sensible registry of programs, like for libraries
03:44:23 <quicksilver> yes, that's why the hack to make a program into a library has value.
03:44:40 <dcoutts> quicksilver: a library really cannot be used without being registered, so distributions are forced to register them
03:44:54 <dcoutts> quicksilver: they are not similarly forced to register executables
03:45:16 <dcoutts> so cabal-install having its own register of progs it installed is not a complete solution
03:45:43 <dcoutts> refusing to use progs unless they're registered is also less than ideal
03:46:09 <ManateeLazyCat> quicksilver: I think better solution is "cabal install gtk2hs-buildtools && cabal install gtk" and wait Cabal Team fix this problem.
03:46:18 <dcoutts> quicksilver: currently we detect programs by finding them on the $PATH, and for some we know how to extract their version which allows for versioned deps
03:47:10 <Darthreborn> hi all, i want to generate an AST from an html file, is there a good html haskell parser?
03:47:59 <dcoutts> quicksilver: in principle we could make the dep resolver work in the same way, we look at all the progs that could be needed by a set of packages and we simply try to detect them.
03:48:23 <dcoutts> quicksilver: if they're not already installed then we can see if any packages from hackage provide them.
03:48:34 <luite> ManateeLazyCat: do you know where to get the webkit binaries for windows?
03:49:05 <ManateeLazyCat> luite: Sorry, i'm linux guy, don't know the detail of Windows.
03:49:12 <ManateeLazyCat> luite: Google it?
03:49:26 <dcoutts> quicksilver: that's basically what we'll have to do for C deps too, look at what ones might be needed and try to detect them on the system. The difference is that we cannot easily automagically provide them if they're not installed.
03:49:31 <Kaidelong> wxWindows still segfaults magnificiently
03:49:42 <Kaidelong> what was your suggestion again manatee?
03:49:46 <Kaidelong> err
03:49:49 <Kaidelong> wxHaskell I mean
03:49:53 <Kaidelong> wxWindows works fine
03:50:04 <Kaidelong> Widgets
03:50:07 <Kaidelong> wxWidgets
03:50:08 <ManateeLazyCat> luite: http://trac.webkit.org/wiki/BuildingOnWindows ?
03:50:17 <luite> ManateeLazyCat: already did, but it doesn't seem to be the official binaries, and I can't find binaries for webkitgtk+
03:50:36 <mux> ManateeLazyCat: thanks, installing gtk2hs-buildtools solved the problem - why is it now listed in the dependencies though?
03:50:44 <mux> s/now/not/
03:50:48 <ManateeLazyCat> Kaidelong: Do you have gdb on Windows.
03:51:04 <Kaidelong> the gnu debugger?
03:51:04 <ManateeLazyCat> mux: Ask dcoutts
03:51:06 <Kaidelong> I don't think so
03:51:15 <Kaidelong> the C++ examples work
03:51:24 <Kaidelong> so the problem is with wxHaskell, not wxWidgets
03:51:31 <ManateeLazyCat> Kaidelong: If you have any debugger, you can run your program in debug and try to get backtrace.
03:51:38 <luite> ManateeLazyCat: the gtk package installed fine though, it's great to see that the days of manually compiling gtk2hs are finally over :)
03:51:49 <ManateeLazyCat> Kaidelong: Then you can send those backtrace information to wxWindows Team.
03:52:00 <ManateeLazyCat> luite: Yes,
03:52:13 <siracusa> luite: I didn't find them either, so I think you have to build yourself.
03:52:18 <ManateeLazyCat> luite: It's a big improve!
03:52:31 <dcoutts> mux: they are listed in the build-tools dependency field, but cabal-install doesn't handle that yet
03:52:38 <mux> ohoh
03:52:45 <mux> that explains a lot.
03:53:02 <luite> siracusa: oh ok, I won't bother then, I don't really need webkit anyway :)
03:54:17 <djahandarie> Hm, I'm getting some functional dependecies error when using ReaderT
03:54:19 <ManateeLazyCat> luite: I think after gtk2hs-0.11, will have more people to use gtk2hs
03:54:22 <djahandarie> I have no idea what its trying to tell me
03:55:15 * ManateeLazyCat IMO, gtk2hs is an artwork for haskell community .....
03:56:11 <ManateeLazyCat> luite: Sorry, i can't help you.
03:56:21 <ManateeLazyCat> luite: I just test gtk2hs on Linux.
03:56:31 <djahandarie> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25690#a25690 is relevant code and the error
03:56:43 <mux> well, other than the thing with gtk2hs-buildtools, and the fact that the installer somehow fails if the mkdir /usr/local/lib/gtk-2.0/include directory doesn't exist (same for glib), it works.
03:56:53 <mux> s/mkdir//
03:56:54 <luite> ManateeLazyCat: no problem. I just wanted to test if it worked, don't need webkit yet :)
03:57:20 <siracusa> ManateeLazyCat: Is a separate Win installer planned for gtk2hs, for convenience?
03:57:23 <djahandarie> Why is that error even cropping up?
03:57:49 <luite> siracusa: more convenient than cabal-install?
03:57:51 <ManateeLazyCat> luite: I have write simple browser demo in webkit package, i haven't test it with Windows, but on Linux, damn fast, and write by Haskell !
03:58:07 <ManateeLazyCat> siracusa: No, Windows Installer is not need.
03:58:26 <ManateeLazyCat> siracusa: We plan to merge gtk2hs to Haskell-Platform. :)
03:58:51 <siracusa> luite, ManateeLazyCat: Yeah, I mean also including the C packages
03:58:59 <ivanm> ManateeLazyCat: I doubt that would happen
03:59:07 <ManateeLazyCat> ivanm: ?
03:59:10 <ivanm> because of the C libs
03:59:19 <ManateeLazyCat> ivanm: Difficult?
03:59:24 <mux> yay, working gtk2hs from cabal with ghc 6.12.3rc1
03:59:26 <mux> this is a good day.
03:59:27 <ivanm> well, OSX users hate it
03:59:34 <ManateeLazyCat> ivanm: :)
03:59:35 <ivanm> mux: is there a Changelog for the rc?
03:59:55 <mux> ivanm: I haven't been able to find one, but I rushed on it anyways since I knew it fixed a bug I was experiencing
04:00:12 <ivanm> I'm waiting for the HP to start having a secondary list of "recommended" libs which aren't part of the platform proper, but indicate good libraries for a particular purpose
04:00:24 <ManateeLazyCat> I think gtk2hs-0.11.0 is stable enough, we have fix many bugs from gtk2hs-0.10.1
04:00:39 <ManateeLazyCat> mux: Linux?
04:00:46 <mux> nope
04:00:52 <mux> but that's totally irrelevant, I should sya
04:01:13 * ManateeLazyCat Looks have so many gtk2hs/Windows users. :)
04:01:15 <mux> if you're referencing that problem with non-existing directories
04:01:25 <mux> not windows, not mac os x either
04:01:29 <mux> guess again :-)
04:01:36 <ManateeLazyCat> mux: FreeBSD?
04:01:38 <mux> bingo
04:01:56 <Kaidelong> glib and cairo silently failed during the configure step
04:02:07 <ManateeLazyCat> mux: Glad to it can works on FreeBSD, even we haven't test gtk2hs on it.
04:02:22 <mux> ManateeLazyCat: it works only when I do some manual directory creation first
04:02:27 <ManateeLazyCat> Kaidelong: Paste error.
04:02:34 <mux> other than that, from the point of view of gtk2hs, it should pretty much be the same as on Linux
04:02:41 <mux> I'm not very surprised that it nearly works :)
04:03:13 <ManateeLazyCat> mux: If it's big problem, please send detail information to gtk2hs-devel list, we will adjust gtk2hs for FreeBSD. :)
04:03:25 <mux> you're missing my point
04:03:36 <mux> I /will/ report it in order to get this fixed, but the problem is not FreeBSD-specific
04:03:44 <Kaidelong> http://pastebin.com/7gaMR2gA
04:03:51 <Kaidelong> that was on MSYS
04:03:52 <mux> the fact that it's triggered on FreeBSD just shows there's a bug somewhere
04:03:58 <Kaidelong> it seems to work with the windows command emulator
04:04:07 <Kaidelong> the documentation said that msys would work too
04:04:12 <mux> whether it's Linux or FreeBSD or something else, there should be no reason for the setup to fail because the /usr/local/lib/gtk-2.0/include directory doesn't exist
04:04:16 <Kaidelong> so that may need fixed
04:04:26 <mux> this is "just wrong"
04:04:39 <Kaidelong> err
04:04:43 <Kaidelong> command console
04:04:44 <ManateeLazyCat> Kaidelong: Can you do "cabal install gtk -v"
04:04:54 <dcoutts> mux: got any details on that?
04:05:02 <ManateeLazyCat> Kaidelong: Your paste is less useful.
04:05:07 <mux> dcoutts: just a second
04:05:08 <Zao> I hope that you're using whatever pkg-config GTK has over some kind of hardcoded paths.
04:05:18 <dcoutts> Zao: yes, it does
04:05:28 <siracusa> Kaidelong: Is your MSYS path set properly to find the build tools?
04:05:33 <Kaidelong> ManateeLazyCat: I did say it was silent. Everything before that went smoothly. I need to wait for cabal to finish
04:05:33 <dcoutts> Zao: use pkg-config I mean, cabal support it directly
04:05:43 <mux> dcoutts: mmm unfortunately I don't have the logs of the failed build anymore; let me remove those empty directories I created and run it agian
04:05:50 <Kaidelong> siracusa: I have to set my MSYS path differently from my windows path?
04:06:11 <ManateeLazyCat> mux: Looks your problem is pkg-config.
04:06:25 <mux> it certainly seems like it's related to pkg-config
04:06:53 <ManateeLazyCat> mux: If pkg-config can return right result to gtk2hs on FreeBSD, everything should be fine.
04:07:02 <mux> before you ask, yes, pkg-config --cflags gtk+-2.0 lists this directory
04:07:09 <mux> that doesn't mean the directory should exist
04:07:12 <Kaidelong> manateelazycat: I suspect it was because I forgot to restart the MSYS shell
04:07:17 <mux> ManateeLazyCat: pkg-config returns the right result
04:07:20 <Kaidelong> it works now
04:07:21 <mux> it has ALWAYS worked this way
04:07:26 <ManateeLazyCat> Kaidelong: :)
04:07:37 <mux> gcc doesn't enforce directory existence with the -I flag, things would be very annoying otherwise
04:07:51 <dcoutts> mux: indeed, and as far as I am aware, nor does cabal
04:07:58 <mux> let me show you that error
04:08:09 <dcoutts> mux: so it should be just a bug, not a design error
04:09:26 <mux> running cabal install --reinstall gtk now
04:09:45 <mux> here:
04:09:46 <mux> Registering gtk-0.11.0...
04:09:46 <mux> setup: gtk-0.11.0: include-dirs: /usr/local/lib/gtk-2.0/include doesn't exist
04:09:47 <mux> or isn't a directory (use --force to override)
04:10:00 <mux> so it does look like cabal enforces the directory existence..
04:10:03 <dcoutts> ah, it's ghc-pkg that checks that
04:10:07 <mux> ah
04:10:23 <mux> that'll be more annoying to fix
04:10:24 * hackagebot hlibev 0.2.3 - FFI interface to libev  http://hackage.haskell.org/package/hlibev-0.2.3 (AycanIrican)
04:10:35 <dcoutts> mux: so perhaps cabal needs to filter out non-existent include dirs
04:10:45 <mux> or ghc-pkg needs to stop complaining about those
04:10:57 <mux> it sounds dangerous to me
04:11:04 <dcoutts> mux: we can check with JaffaCake which he thinks is more sensible
04:11:10 <mux> it's common practice to have extra include dirs tht sometimes don't exist
04:11:13 * mux nods
04:11:27 <dcoutts> mux: for C bits yes, for the Haskell bits we can be pretty strict.
04:11:27 <mux> i'll have to go back to real work, I'll be back later
04:11:39 <mux> but hwen haskell bits include C bits...
04:11:44 <mux> one has to wonder :)
04:12:34 <djahandarie> > sum [1..]
04:12:39 <lambdabot>   mueval-core: Time limit exceeded
04:12:44 <djahandarie> Hm
04:13:16 <djahandarie> Is that really a time limit being exceeded? Becuase on my computer it started swapping way before the timelimit was hit
04:13:34 <Kaidelong> is there a sample app ala paddle I can run to check if gtk2hs works?
04:13:35 <djahandarie> Should be a memory limit of sorts
04:13:51 <quicksilver> djahandarie: does your computer have a time limit?
04:13:55 <ManateeLazyCat> Kaidelong: gtk/demo
04:14:03 <djahandarie> quicksilver, no, my mueval does though
04:14:07 <quicksilver> djahandarie: how long?
04:14:17 <Kaidelong> manateelazycat: with the gtk distribution?
04:14:23 <Kaidelong> that's not really what I want to test
04:14:53 <quicksilver> actually, a compiled sum [1..] shouldn't use a significant amount of memory.
04:15:19 <ManateeLazyCat> Kaidelong: demo directory is forgot add in distribution package.
04:15:21 <djahandarie> quicksilver, the default of 5
04:15:26 <ManateeLazyCat> Kaidelong: Sorry.
04:15:30 <djahandarie> quicksilver, and this is being run interpreted
04:15:53 * ManateeLazyCat pasted "World.hs" at http://paste2.org/get/850230
04:15:56 <ManateeLazyCat> Kaidelong: Above
04:16:07 <quicksilver> djahandarie: I think lambdabot has the limit at only 1 second.
04:16:10 * ManateeLazyCat pasted "Makefile for World.hs " at http://paste2.org/get/850232
04:16:15 <ManateeLazyCat> Kaidelong: Above is makefile.
04:16:16 <quicksilver> but I'm still pretty surprised you're using much memroy.
04:16:30 <djahandarie> quicksilver, bout 4 GiB sucked up real fast
04:16:36 <quicksilver> odd.
04:17:10 <Kaidelong> ManateeLazyCat: I take it gtk does not work with GHCi?
04:17:14 <mux> I can understand that if it's using Integer and not Int
04:17:35 <ManateeLazyCat> Kaidelong: gtk2hs can works with ghci
04:17:56 <Kaidelong> when I try to start ghci -package gtk it complains about recursive dependencies
04:18:11 <djahandarie> quicksilver, still got killed even with a timelimit of 1
04:18:28 <djahandarie> I'll try compiling it
04:18:50 <ManateeLazyCat> Kaidelong: Weird....
04:19:34 <dcoutts> that is weird indeed
04:19:48 <djahandarie> quicksilver, even compiled it sucks up memory and fails to stop
04:20:18 <ManateeLazyCat> Kaidelong: Can you try Makefile at http://paste2.org/get/850232 ?
04:21:00 <Kaidelong> manateelazycat: I don't know how the haskell build system works
04:21:11 <Kaidelong> I've been using leksah to do that for me
04:21:22 <djahandarie> Oh, there is apparently "rLimits", I'll try that
04:21:39 <ManateeLazyCat> Kaidelong: Can you use ghci in shell?
04:21:50 <Kaidelong> ManateeLazyCat: that's what I was trying, yeah
04:22:01 <ManateeLazyCat> Kaidelong: Switch World.hs directory, and do "ghc --make World.hs -o world"
04:22:16 <ManateeLazyCat> Kaidelong: No, is ghc
04:22:22 <ManateeLazyCat> Kaidelong: Sorry, typo.
04:23:19 * ManateeLazyCat Oh god, lost forgot add demo directory in gtk2hs packages. :-(
04:25:22 <ManateeLazyCat> code.haskell.org shutdown again?
04:25:40 <Ke> "again"
04:26:02 <ManateeLazyCat> Won't be because gtk2hs, too many people download it?
04:26:04 <ManateeLazyCat> :)
04:26:40 <Ke> doubtful
04:27:20 <ManateeLazyCat> Sorry all. We forgot include the demos in the distribution, i guess too late now.
04:27:21 <Kaidelong> wow the error message for trying to start ghc --interactive -package gtk is a bit strange
04:27:34 <ManateeLazyCat> Kaidelong: ghc work?
04:28:21 <ManateeLazyCat> We will put a link on the Wiki.
04:28:53 <ManateeLazyCat> Kaidelong: I need dinner now, back soon. Please leave message to me if you have any problem, i will try to help you. :)
04:29:23 <Kaidelong> manateelazycat: it looks like I'm running out of time to mess around wiht haskell, but I'll take a look later this week
04:44:10 <djahandarie> gwern, is there some way I can check if timeLimit is actually being payed attention to in mueval?
04:48:17 <soupdragon> can you program a random number generator in a quantum computer?
04:48:59 <djahandarie> I can't see why not
04:49:07 <silver> I can'
04:49:09 <silver> t
04:49:11 <ManateeLazyCat> soupdragon: Do you have quantum computer. :)
04:49:17 <soupdragon> hehe no I don't have one
04:49:27 <djahandarie> In fact you could probably exploit quantum-random properties
04:51:12 * ManateeLazyCat Quantum computer is safer, you will know receive data is not safe when someone touch it.....
04:51:31 <soupdragon> ManateeLazyCat - I heard of that - so cool!
04:51:33 <Botje> worse, it will get arbitrarily corrupted
04:51:41 <Botje> makes a DoS rather easy :)
04:51:54 <ManateeLazyCat> :)
04:51:55 <soupdragon> you can't clone a quantum state
04:52:14 <soupdragon> something like  |0>|x> --> |x>|x>  is not unitary (but I don't know what is unitary yet..)
04:52:36 <ManateeLazyCat> soupdragon: Maybe *cat* will jump from it. :)
04:52:46 <djahandarie> Or the ket
04:55:29 <djahandarie> soupdragon, the main reason you can't clone quantum state is because it works out that <o|v> = <o|v>^2, which would require o to be equal to or orthogonal to v
04:55:46 <djahandarie> Which it isn't
05:19:31 <janbanan> http://pastebin.com/gFWfH6n0
05:19:39 <janbanan> C is nullable but is A?
05:20:48 <soupdragon> do you have a definition of nullable
05:22:47 <janbanan> If A -> e is a production og G, then A is nullable
05:23:04 <siracusa> janbanan: If C is then A is as well
05:23:11 <soupdragon> weird... definiton
05:23:27 <soupdragon> I'd just flip a coin
05:25:35 <janbanan> siracusa yeah it must be like that, thanks!
05:26:01 <BONUS> yeah A is nullable, because it is able to produce the end symbol by itself
05:26:01 <lambdabot> BONUS: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:26:04 <BONUS> yikes!
05:26:20 <soupdragon> janbanan, so your definition is wrong
05:27:02 <janbanan> soupdragon yes, I saw that it was only the base case for the proof now :P
05:27:56 <BONUS> i think that a symbol A is nullable if there exists a production A -> eta or if there exists a production A -> sentence where all the symbols in sentence are nullable
05:28:01 <BONUS> or something
05:28:23 <soupdragon> and that's defined by co-recursion?
05:28:39 <BONUS> i think that's just a normal recursive definition
05:32:33 <soupdragon> with the rule "A -> C | A" how can yuo conclude A is nullable by induction -- it only seems to be a valid conclusion by coinduction
05:33:25 <soupdragon> or do you only have to look at one of the alternatives?
05:34:12 <ivanm> what do you mean by "nullable by induction"?
05:34:40 <BONUS> soupdragon: isn't A -> C | A actually two rules? A -> C and A -> A?
05:35:13 <janbanan> Yes it is
05:35:39 <BONUS> so if you have something like A -> BCD | EFG, either B, C and D have to be nullable or E, F and G
05:35:56 <BONUS> looks like plain induction to me, idk
05:36:04 <soupdragon> ok
05:39:15 <Axman6> ivanm: you were after me?
05:41:45 <Kaidelong> does anyone know good resources for learning about abstract state machines, other than the primer?
05:42:31 <Palmik> Kaidelong, why other than primer? :)
05:42:37 <jpcooper> hello
05:42:41 <ivanm> Axman6: yeah: you and Sarah booked at the high cross park lodge, right?
05:42:47 <jpcooper> is there a function which can split a string by commas?
05:42:49 <Axman6> yeah
05:43:01 <ivanm> well, they're currently $80/night... with "discounted" wifi :s
05:43:08 <Axman6> :\
05:43:10 <ivanm> (though wotif still says free wifi)
05:43:15 <ivanm> I sent them an email to query this
05:43:30 <Kaidelong> Palmik: I need citations, mostly. But also, I like seeing things from different perspectives
05:46:30 <Axman6> ivanm: well, if wotif said free wifi when we booked, afaik, they have to give it to us
05:49:05 <quicksilver> jpcooper: not in the base library no. CHeck out the 'split' package on hackage
05:49:14 <jpcooper> thanks
05:58:52 <Starfire> If I have a function definition with some constant expression in a where clause, will the thunk for the constant expression be shared between all invocations of the function?
05:59:00 <sioraiocht> @src words
05:59:00 <lambdabot> words s = case dropWhile isSpace s of
05:59:00 <lambdabot>     "" -> []
05:59:00 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
06:00:48 <Starfire> For instance, if I have fib n = fibs !! n where fibs = 0 : 1 : zipWith (+) fibs (tail fibs), will fibs be shared between all calls of fib?
06:01:21 <soupdragon> no
06:01:27 <soupdragon> use ; instead of where for that
06:01:50 <Starfire> So I have to define fibs as a non-exported top-level constant to get sharing?
06:01:55 <soupdragon> yes
06:02:08 <Starfire> OK, good to have that cleared up.
06:03:04 <Starfire> Is there some reason (space leaks? strictness?) why GHC won't share thunks otherwise?
06:11:49 <zark4711> I have a problem installing haskelldb-hdbc-mysql via cabal. The c library libiconv is used somewhere and the linker can't find some symbols. for example "_iconv_close". i found in the haskell mailing list archives a note that there exist two versions of the libiconv on mac. one preinstalled and one came with macports. one of the versions does export these symbols the other doesn't. and based on which library was used when compiling ghc the a
06:12:15 <dcoutts> zark4711: right
06:12:40 <zark4711> has anyone an idea what i can do to use the other library for this package? i don't have an overall understanding and don't know if this is possible
06:12:45 <Saizan> Starfire: i'm not sure if GHC guarantees that fibs won't be shared, though it doesn't guarantee that it will either
06:13:13 <Saizan> Starfire: and yeah, it can cause space leaks in the general case
06:14:15 <zark4711> i tried the easy way out by using haskelldb-hsql-mysql hdbc-odbc and hsql-odbc. but in each case i get different problems. so i thought i should stick with the first one
06:19:01 <dcoutts> zark4711: I'd go for hdbc-* rather than the others
06:23:15 <zark4711> dcoutts: yes, hsql is out of date. just noticed that i dont have a working libiodbc on my system which probalby caused some problems with haskelldb-hdbc-odbc...ok wich now leads me to the same libiconv problem with  odbc :(
06:24:16 <dcoutts> zark4711: I'm not sure what the workarounds are, you'll need to find an OSX user
06:26:09 <quicksilver> Starfire: you don't need it to be a top-level constant to be shared.
06:26:49 <quicksilver> fibs = let fibsl = 1 : zipWith (+) fibsl (tail fibsl) in \n -> fibsl !! n should share fine.
06:27:42 <Starfire> quicksilver: Do I need to define it with a lambda (ie. not with an equation) to get sharing?
06:27:46 <quicksilver> (erm, plus 0: )
06:28:04 <quicksilver> that is an equation.
06:28:16 <quicksilver> I'm not sure how to carefully answer your question.
06:28:43 <quicksilver> GHC doesn't always lift constants through intervening lambdas - even though it can - because that might be space leak.
06:29:03 <quicksilver> I'm not sure if there are any circumstances in which it will, I htink there might be some.
06:29:28 <quicksilver> it's certainly nothing to do with equations vs lambda
06:29:40 <quicksilver> equations and lambda/case are equivalent
06:29:44 <Starfire> OK.
06:29:53 <quicksilver> it's about whether the constant is inside a lambda or not
06:30:11 <quicksilver> (whether that is a literal visible lambda or one implied by an equation with parameters)
06:30:24 <Starfire> So it's always equivalent to write 'f x = ...' instead of 'f = \x -> ...' ?
06:30:41 <quicksilver> yes.
06:30:49 <quicksilver> apart from the DMR.
06:31:00 <Starfire> Equivalent in the sense that they get optimized identically.
06:31:09 <quicksilver> equivalent in the sense that they produce the same code
06:31:14 <quicksilver> ...apart from the DMR.
06:31:24 <Starfire> DMR = monomorphism restriction?
06:31:26 * quicksilver nods
06:31:34 <Starfire> Yeah.
06:31:38 <quicksilver> the transformation which would share even in the case you initially suggested is called 'full laziness'
06:31:44 <Axman6> damn monomorphism restriction?
06:31:50 <quicksilver> you'll find it discussed if you google it
06:31:54 <quicksilver> but it can lead to space leaks.
06:32:06 <quicksilver> (as can laziness in general...)
06:32:10 <quicksilver> Axman6: Dreaded
06:32:20 <Axman6> close enouch :)
06:32:22 <Axman6> gh*
06:32:29 * Axman6 needs to sleep
06:32:57 <Polarina> Could someone explain to me how    zip <*> tail    is equivalent to    \xs -> zip xs (tail xs)    ?
06:33:09 <quicksilver> email message suggests that GHC used to do full laziness in 1999
06:33:12 <quicksilver> (GHC 3)
06:33:14 <Axman6> well, <*> == ap
06:33:18 <quicksilver> either that or SPJ is wrong.
06:33:30 <quicksilver> Polarina: the secret lies in the Applicative instance being used
06:33:40 <quicksilver> (or Monad instance if you choose to think of it that way)
06:33:43 <Axman6> and ap for functions looks like: ap f g x = f x (g x), i think
06:33:51 <Axman6> @src (->) ap
06:33:52 <lambdabot> Source not found. :(
06:33:54 <quicksilver> right.
06:33:54 <Axman6> :(
06:33:56 <Axman6> @src ap
06:33:57 <lambdabot> ap = liftM2 id
06:34:06 <quicksilver> ap f g = \x -> f x (g x)
06:34:14 * Axman6 levels up!
06:34:21 <quicksilver> Axman7 now?
06:34:36 <Polarina> ap looks like the >=> operator.
06:34:37 <Axman6> i'd need to kill another Axman to increment
06:34:39 <philo> how is the llvm backend comming ?
06:34:51 <philo> any blog recent blog post yet ?
06:35:14 <quicksilver> Polarina: ap :: m (a -> b) -> m a -> m b
06:35:17 <djahandarie> Axman6, doppelgangeR?
06:35:29 <Polarina> @src (>=>)
06:35:30 <lambdabot> Source not found. Just try something else.
06:35:35 <quicksilver> Polarina: >=> :: (a -> m b) -> (b -> m c) -> (a -> m c)
06:35:42 <quicksilver> Polarina: the 'm' is in a different place
06:35:44 <Polarina> Odditites. :(
06:35:47 <quicksilver> with ap the "whole function" is inside m
06:35:59 <quicksilver> m (a -> b) is different from a -> m b
06:36:44 <Polarina> Thanks everyone. :)
06:41:23 <Polarina> Could someone explain to me the difference between a Monad and an Applicative?
06:41:41 <Axman6> @src Applicative
06:41:42 <lambdabot> class Functor f => Applicative f where
06:41:42 <lambdabot>     pure  :: a -> f a
06:41:42 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
06:42:19 <Axman6> i think it's that Applicatives don't have to be able to implement join (which being able to define >>= means you can do)
06:42:22 <redocdam> this has an interesting effect in ghci: take 4 $ reverse [1,2..]
06:42:47 <redocdam> I think it might be the most useful haskell program I have seen
06:43:11 <djahandarie> philo, there was this one on the llvm project blog... http://blog.llvm.org/2010/05/glasgow-haskell-compiler-and-llvm.html
06:43:28 <Polarina> redocdam, are you expecting any particular output?
06:43:46 <philo> redocdam:  nothing strange on my side
06:43:59 <philo> djahandarie: i read that one
06:44:06 <quicksilver> Polarina: Applicative effects can't utilise the result of earlier effects
06:44:15 <Axman6> redocdam: well, it's provably something that doesn't terminate, so what result are you expecting?
06:44:19 <quicksilver> Polarina: (which is what bind, aka >>=, lets you do)
06:44:20 <philo> djahandarie:  do you know if they plan to update the llvm bindng ?
06:44:51 <Axman6> philo: the llvm backend and the binding aren't related
06:45:00 <djahandarie> ^^
06:45:05 <redocdam> maybe it should be improved
06:45:09 <redocdam> with more line noise
06:45:28 <Axman6> is this a reallty bad attempt at trolling?
06:45:34 <redocdam> yes
06:45:45 <Polarina> quicksilver, thanks.
06:45:46 <Axman6> because, you're failing pretty badly as a troll
06:45:58 <Polarina> And why would one use an Applicative instead of a Monad?
06:46:01 <cheztape> how appropriate is haskell for writing network servers?
06:46:08 <Axman6> you're not being particularly annoying, just appearing ignorant
06:46:20 <Axman6> cheztape: extremely
06:46:22 <djahandarie> cheztape, it sometimes farts when you aren't paying attention
06:46:33 <djahandarie> Otherwise its appropriate
06:46:35 <shepheb> Polarina: sometimes the interface is nicer, see the Applicative style for Parsec
06:46:36 <quicksilver> Polarina: well, you might have a type which is an instance of Applicative but not Monad.
06:46:36 <Axman6> look at the results the Snap framework's webserver is getting
06:46:44 <redocdam> Axman6: sorry, but I was also having a gnu-snack while I typed it in
06:46:53 <cheztape> thank you Axman6
06:47:08 <Polarina> quicksilver, how so?
06:47:35 <cheztape> I'm trying to choose between Erlang and Haskell for a project at work and I can't really decide
06:47:44 <quicksilver> Polarina: I don't know how to answer that.
06:47:48 <janbanan> If (A,B) is a unit pair and B->C, are (A,C) a unit pair also?
06:47:51 <quicksilver> Polarina: not every type is an instance of every type class :)
06:47:52 <philo> Axman6: http://socghop.appspot.com/gsoc/student_project/show/google/gsoc2010/haskell/t127230760615
06:47:57 <Axman6> cheztape: like most languages though, being appropriate for a task and being easy to implement that task are two different things. learning haskell would be be advised before trying to write a server in it
06:47:59 <Polarina> cheztape, to be honest, Haskell is perfectly up to all tasks.
06:48:13 <quicksilver> Polarina: Applicative is less restrictive than Monad, so it has more instances.
06:48:19 <Axman6> cheztape: http://snapframework.com/benchmarks
06:48:31 <philo> do you think that learning Ocaml would be a plus for an haskell progrmmer ?
06:48:36 <Axman6> quicksilver: or, should have more instances
06:48:48 <Polarina> Axman6, hehe. :P
06:50:11 <cheztape> thanks much, I'm reading "Learn you some haskell for great good", I heard it's good for starting, isn't it?
06:50:18 <Axman6> yep
06:50:20 <redocdam> philo: no that is the devil
06:50:45 <redocdam> what you should do is learn category theory
06:51:04 <redocdam> which will also greatly enrich your day-to-day life
06:51:16 <cozachk> or you could just learn the IO monad and learn other monads one at a time
06:51:17 --- mode: ChanServ set +o quicksilver
06:51:21 --- mode: quicksilver set +b *!*redocdam@unaffiliated/redocdam
06:51:21 --- kick: redocdam was kicked by quicksilver (I'm bored.)
06:51:41 <cheztape> Axman6, these benchmarks look impressive
06:51:59 <Axman6> heh, i was just thinking that if i had ops, i wouldn't even give them the pleasure of a kickban, he wasn't worth it
06:52:15 <Axman6> but, i like to play with my food when i have ops, its a known problem
06:52:30 <philo> Axman6:  read my link ?
06:52:35 <Axman6> yeah
06:52:48 <Axman6> though that's not where the current work is happening at the moment
06:54:37 <Axman6> well, as far as i know anyway
06:56:03 --- mode: quicksilver set -o quicksilver
06:57:34 <Polarina> quicksilver, oh, I forgot; thanks for your help. :)
06:58:50 <Axman6> urgh. i forgot how much pain installing a new ghc is:
06:58:51 <Axman6> package bytestring-0.9.1.5 is broken due to missing package
06:58:52 <Axman6> base-4.2.0.0-95c41f6bf22ec723b98f35a571e408fc
06:58:52 <Axman6> package zlib-0.5.2.0 is broken due to missing package
06:58:52 <Axman6> base-4.2.0.0-95c41f6bf22ec723b98f35a571e408fc
06:58:55 <Axman6> >__<
06:59:06 <Axman6> and i can't remember the fix
06:59:26 <Polarina> Axman6, overwrite?
06:59:30 <Polarina> That's what I did.
06:59:34 <Axman6> ?
06:59:43 <Polarina> Axman6, overwrite the new ghc binary over the old one.
06:59:47 <Axman6> i did
06:59:59 <Axman6> well, i uninstalled the old one, and installed a new one.
07:00:07 <Axman6> hmm, maybe i didn't uninstall it
07:00:18 <Polarina> Hehe.
07:02:07 * Saizan thinks there's something wrong on os x
07:02:32 <Saizan> wrt ghc installer, i mean
07:06:25 <Axman6> dcoutts: i don't suppose you could help me with a post 6.10-6.12 upgrade cabal problem could you? I can't install anything, because it says base-4.2.0.0-95c41f6bf22ec723b98f35a571e408fc is missing :(
07:06:52 <Saizan> Axman6: what does ghc-pkg --version say?
07:07:01 <Polarina> Axman6, have you tried installing base-4.2.0.0-95c41f6bf22ec723b98f35a571e408fc?
07:07:09 <dcoutts> Axman6: interesting
07:07:10 <Axman6> Saizan: GHC package manager version 6.12.1
07:07:33 <Axman6> Polarina: well no, base is highly dependant on the version of ghc you have installed, and is instanned with ghc (i believe)
07:07:51 <dcoutts> Axman6: so do you have any version of base 4.2 installed ?
07:08:14 <Axman6> dcoutts: if it helps, this is on OS X, going from a macports installed, 64bit 6.10.4, to a 32 bit 6.12.1
07:08:17 <Axman6> i'll check
07:08:33 <Axman6> ghc-pkg list base
07:08:34 <Axman6> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
07:08:34 <Axman6> /usr/local/lib/ghc-6.12.1/package.conf.d base-3.0.3.2 base-4.2.0.0
07:09:11 <Axman6> note to irssi: if you're going to warn me about pasting more than 5 lines of output, at least make it 5 lines when you send it -_-
07:09:21 <Blkt> how do I import a module in Haskell? I don't mean the import keyword itself, but how I find the source file of the module to be imported
07:09:54 <Axman6> Blkt: i'm not sure i understand the question
07:10:11 <Saizan> Axman6: ghc-pkg describe base | grep "id:" -- will tell us if it's the same base
07:10:26 <Axman6> id: base-3.0.3.2-52acef427378232ec569bca0486ee48f
07:10:26 <Axman6> id: base-4.2.0.0-95c41f6bf22ec723b98f35a571e408fc
07:11:15 <Blkt> I have a source file wich has "import Foo" at the beginning; that Foo module is in another file, namely foo.lhs, but when I load it via :load in ghci it doesent see it
07:11:15 <Saizan> ok, so it's "just" broken for some reason, "ghc-pkg check" tells anything interesting?
07:11:45 <Axman6> what should i be looking for?
07:11:49 <Blkt> Saizan: ghc-pkg check tells nothing at all
07:12:05 <Saizan> Blkt: i was speaking to Axman6
07:12:08 <Axman6> Blkt: it should probably be called Foo.lhs
07:12:58 <Blkt> Axman6: wait a sec
07:13:10 <quicksilver> yes, the file needs to be called Foo.lhs, and ghci needs to be able to find it.
07:13:22 <quicksilver> simplest way is for ghci's working directory to be the directory the file is in.
07:13:23 <Blkt> Axman6: this: http://www.cs.nott.ac.uk/~gmh/calculator.lhs makes use of this: http://www.cs.nott.ac.uk/~gmh/Parsing.lhs
07:13:36 <Saizan> Axman6: well, you can just paste it, it should tell you which packages are directly broken and which just transitively
07:14:45 <quicksilver> Blkt: launch ghci from the directory with boths files in; or :cd to it.
07:14:47 <Axman6> Saizan: http://pastie.textmate.org/private/epvtaw4jb6hbkimfkdbvvw
07:15:05 <Blkt> quicksilver: thanks
07:16:50 <Saizan> Axman6: do you have perhaps binary-0.5.0.2 installed both in the global and user db?
07:17:00 <Axman6> possible
07:17:23 <Darthreborn> i'm trying to install curl through cabal, and i'm getting an error curl libraries not found :(
07:17:24 * Saizan is not sure how this would cause a problem with base though
07:17:40 <Saizan> Darthreborn: you've to install the C curl lib via your package manager
07:17:57 <Darthreborn> Saizan: oh thanks ill try it
07:18:09 <Axman6> apparently i have ghc-binary and binary installed (both with the same version, one global, one user)
07:18:23 <Saizan> those shouldn't clash
07:18:36 <dcoutts> they're different names, so it's ok
07:19:04 <Saizan> btw, how come you just switched from 6.10 to 6.12 and you've all those packages installed? is it picking the 6.10 package db?
07:19:08 <dcoutts> Darthreborn: could the cabal error message have been more helpful, to let you know that it's system packages you need to install?
07:19:09 * Axman6 wouldn't mind knowing how nuke everything, and start with a clean ghc install
07:19:49 <dcoutts> Darthreborn: as I recall, it does mention something about system packages, perhaps you can suggest how the error message could be changed to be clearer?
07:20:05 <Axman6> Saizan: it's possible it's using the last version og 6.12.1 i had installed (i switched back to 6.10.4 to test the 64 bit version for mac. too many segfaults for my liking)
07:20:05 <Blkt> quicksilver: thank you, it works now, but how do I tell ghc where to find source files? is there some kind of classpath?
07:20:33 <Axman6> Blkt: ah, you've been infected by java, your questions make more sense now ;)
07:20:50 <Blkt> Axman6: not my fault, College stuff...
07:21:01 <Blkt> Axman6: but as you can see, I'm trying to redeem myself
07:21:02 <Saizan> Axman6: you just have to nuke the user db directory i think, it's the second one "ghc-pkg list" will list
07:21:25 <Axman6> Saizan: how do i do that?
07:21:35 <Saizan> Axman6: rm ?
07:21:44 <Axman6> all or ~/.cabal?
07:21:58 <Saizan> it shouldn't be ~/.cabal
07:22:04 <Axman6> oh right, .ghc
07:22:11 <Axman6> i forgot all about that
07:22:33 <Axman6> seems to be working
07:22:55 <quicksilver> Blkt: for development, you just keep them in the current directory.
07:23:10 <quicksilver> Blkt: once you're happy with a library you "install" it, which registers it in the ghc package database
07:23:15 <Saizan> meh, i was going to ask for a backup for debugging purpouses :)
07:23:16 <quicksilver> Blkt: ..and then ghc can find it automatically.
07:23:39 <Axman6> Saizan: good thing i don't like deleting things, i just moved it :)
07:23:39 <Blkt> quicksilver: much smarter...thanks
07:23:43 <Axman6> what would you like to see?
07:23:48 <quicksilver> Blkt: so, the ghc package database is "like" the classpath, but it's managed automatically.
07:24:41 <Saizan> Axman6: well, it'd be the whole package.conf.d directory in question
07:24:57 <Darthreborn> Well i just installed every package containing curl and lib in its name and now it has installed sucessfully ^^
07:25:28 <Axman6> Saizan: hmm, for version i386-darwin-6.12.1 or x86_64-darwin-6.10.4 ?
07:26:02 <Saizan> Axman6: the former
07:26:40 <Axman6> how would you like to receive it?
07:27:16 <triyo> In emacs, I try to load a source file that depends on another .hs file. Prelude running in my Emacs can't find that .hs file that is in the same dir.
07:27:56 <triyo> I tried launching emacs from the dir that holds both source files. no luck
07:28:39 <Saizan> triyo: ":! ls" from within ghci lists them?
07:29:06 <Saizan> at the Prelude> prompt, i mean
07:29:27 <triyo> Saizan: -> "bin  config  lib  logs	packages  share" so no, that not the right dir
07:29:37 <triyo> that looks like .caba I guess
07:29:43 <triyo> .cabal
07:30:01 <Saizan> ah, you've an old emacs haskell-mode i suspect
07:30:10 <ksf> is there a way to specify default types for a class constraint?
07:30:15 <ksf> just like Num, just with my own...
07:30:21 <triyo> hmm, its the one that came with Ubuntu 10.04
07:30:24 <nus> triyo, M-x cd <dir>
07:31:09 <Saizan> triyo: version? however the workaround is to create a file foo.cabal in the directory containing the files
07:31:22 <ksf> how does the prelude do it?
07:31:38 <ksf> or are Num etc. really inbuilt magic?
07:31:52 <Saizan> ksf: there's the default keyword
07:32:05 <Saizan> not sure if it's in the standard or if it's an extension
07:32:25 <triyo> nus: ran "cd command" didn't fix the problem
07:32:51 <nus> triyo, what Saizan said
07:32:55 <triyo> Saizan:  emacs 23.1.1
07:32:56 <ksf> http://www.haskell.org/haskellwiki/Keywords#default
07:33:00 <ksf> now that's cryptic.
07:33:29 <triyo> cool, I'll create the .cabal file, I need it anyway
07:33:30 <Saizan> triyo: i meant the haskell-mode version
07:33:37 <RichardBarrell> triyo: eight megs and constantly swapping! :)
07:33:53 <ksf> ha!
07:34:00 <ksf> it only works with the Num class
07:34:03 <ksf> now that's a wart.
07:34:09 * RichardBarrell is using erc-mode right now, so ignore him. ;)
07:35:04 <dcoutts> Darthreborn: right, but my question is how could we have made things better so that you would have known what to do without having to come and ask in #haskell. It's not that asking is bad, but if it's obvious what to do then that's better.
07:35:18 <quicksilver> triyo: I think it's the ghci directory you need to change, not the emacs one
07:35:21 <quicksilver> :cd in the ghci buffer
07:35:35 <quicksilver> (changing the emacs directory might work if you do it before ghci ever gets loaded)
07:35:50 <quicksilver> newer versions of haskell-mode try to get this right automatically for some cases IIRC
07:35:52 <nus> triyo, M-x haskell-version
07:35:57 <triyo> quicksilver: ohh you might be right. let me try
07:36:00 <dcoutts> Darthreborn: or perhaps the lesson is that our error messages are perfect but that nobody reads them! :-) what do you think it is?
07:36:30 <Darthreborn> dcoutts: oh i see, the problem is that curl is not the thing i was installing, i was installing hxt, a xml parser, and curl was a dependency error on install. I have no idea of what curl does however :D
07:37:22 <dcoutts> Darthreborn: so perhaps explaining that it was a dependency of the thing you wanted that failed would help?
07:37:32 <dcoutts> Darthreborn: what do you think would have helped?
07:37:47 <dcoutts> Darthreborn: certainly we do not expect you to know what curl is
07:39:03 <Darthreborn> dcoutts: i see, it would obviously help if it just installed the missing dependencies by itself
07:40:02 <jmcarthur> unfortunately it can't do that :(
07:40:10 <jmcarthur> not system dependencies anyway
07:40:14 <dcoutts> Darthreborn: or since we usually cannot install system libs (since it does not run as root), worked out which system libs you should install
07:40:36 <jmcarthur> hmm... something platform-aware?
07:42:18 <Darthreborn> dcoutts: something in the error that pointed the libraries missing would indeed be fine, it didn't even specified it was system libraries missing :(
07:45:02 <dcoutts> Darthreborn: oh because it says C libraries, rather than saying system packages?
07:46:01 <Darthreborn> dcoutts: hum as i recall it didn't said even C libraries, i thought it was some haskell libraries missing
07:47:26 <dcoutts> Darthreborn: hmm, it's a pity we cannot easily reproduce it now that you do have the system package installed.
07:47:56 <fryguybob> How would I make QuickCheck give me a double in a specific range?
07:49:45 <Darthreborn> dcoutts: the error i had was this "configure: error: curl libraries not found, so curl package cannot be built
07:49:47 <Darthreborn> See `config.log' for more details."
07:50:00 <gwern> fryguybob: add a conditional that discards anything too large/small?
07:50:28 <dcoutts> Darthreborn: ohhh, ok, yeah that's bad. That package is doing it's own check. If it just did nothing then cabal would do the check and produce a much better error message.
07:51:02 <jmcarthur> sweet! gtk2hs on hackage as well as some webkit bindings!
07:51:15 <fryguybob> gwern: Ok, seems a little indirect.
07:51:36 <gwern> fryguybob: well, you could do a newtype and define your own Arbitrary instance, but that's harder...
07:52:25 <fryguybob> gwern: I don't mind doing, that.  What would I do in the definition of arbitrary for that?
07:52:39 <gwern> dunno. suppose it depends on double's instance of Arbitrary
07:52:40 <quicksilver> you don't need a newtype.
07:52:47 <quicksilver> you can create a Gen Double
07:52:59 <quicksilver> which is like a reified Arbitrary instance
07:52:59 <fryguybob> gwern: I afraid if my range is small if I use suchThat it wouldn't be very efficient.
07:53:04 <quicksilver> and specifically use that Gen
07:53:10 <quicksilver> with some combinator - I think it might be 'forall'
07:53:13 <gwern> quicksilver: how would that look like?
07:53:18 <quicksilver> @hoogle forall
07:53:18 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
07:53:19 <lambdabot> Language.Haskell.TH ForallC :: [Name] -> Cxt -> Con -> Con
07:53:19 <lambdabot> Language.Haskell.TH.Syntax ForallC :: [Name] -> Cxt -> Con -> Con
07:53:26 <quicksilver> that's the one.
07:53:51 <quicksilver> forAll (myDoubleInRange 1.5 2.5) (\d -> d + d = 2 * d)
07:54:04 <quicksilver> where myDoubleInRange :: Gen Double is your Gen.
07:54:19 <quicksilver> and the property I'm testing is Double addition.
07:54:38 <fryguybob> quicksilver: What would myDoubleInRange look like?
07:55:14 <gwern> myDoubleInRange x y z = z > x && z < y, I'd guess
07:55:54 <quicksilver> fryguybob: Gen a is like an arbitrary instance.
07:56:11 <quicksilver> Indeed, in the definition of the class "class Arbitrary a where arbitrary :: Gen a"
07:56:26 <quicksilver> so writing a Gen Double is exactly the same thing as writing an arbitrary instance for Double
07:57:18 <quicksilver> you can, for example, use the 'choose' combinator to effectively use randomR
07:57:21 <quicksilver> but this is all in the docs.
07:57:44 <quicksilver> choose :: Random a => (a, a) -> Gen a
07:58:46 <fryguybob> > sample $ choose (1.0,2.0)
07:58:48 <lambdabot>   Not in scope: `sample'Not in scope: `choose'
08:00:07 <gwern> mueval doesn't import quickcheck
08:01:20 <fryguybob> quicksilver: Thanks, some how I missed choose in the docs.
08:01:25 <quicksilver> :)
08:01:31 <quicksilver> you're most welcome.
08:10:20 <Polarina> http://blog.malde.org/index.php/2010/05/22/snagged/ -- why is iconv even involved with GHC there? :S
08:11:42 <quicksilver> Polarina: selecting the correct output encoding for the current locale.
08:11:54 <quicksilver> well, just selecting it. Actually encoding the unicode chars into it.
08:12:00 <quicksilver> s/just/not just/
08:16:27 <Polarina> quicksilver, what if I always want my output to be in UTF-8?
08:17:57 <quicksilver> Polarina: then select that encoding.
08:18:24 <Polarina> quicksilver, select?
08:18:27 <quicksilver> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/GHC-IO-Handle.html#v%3AhSetEncoding
08:18:44 <Polarina> Will that remove the iconv dependency?
08:18:50 <quicksilver> no of course not.
08:19:01 <Polarina> :(
08:19:06 <quicksilver> your code can choose whatever encodings it wishes.
08:19:12 <quicksilver> what's wrong with an iconv dep?
08:19:17 <quicksilver> it's a standard part of the toolchain.
08:19:40 <Polarina> quicksilver, see the article I linked.
08:19:47 <Polarina> quicksilver, it explains my concerns.
08:21:07 * quicksilver shrugs
08:21:13 <quicksilver> it gives me no concerns.
08:21:24 <quicksilver> If iconv breaks static linking, go complain to the iconv developers.
08:21:36 <Polarina> :(
08:21:41 <quicksilver> it appears they provide a very simple provision to override the compiled in path
08:21:45 <quicksilver> so it appears to be a non-problem
08:21:51 <quicksilver> except that you need to know the trick.
08:22:24 <quicksilver> in general, the linux ecosystem is quite anti static-linking, but that's not really GHC's fault, nor a priority problem for GHC to try to solve, IMO.
08:28:41 <Ke> quicksilver: depends on what your priorities are
08:30:54 <Ke> in order haskell to properly pass QA you might also want to separate writable and executable sections
08:48:39 <kstt> Hi, I have an algebraic type (data Foo = Bar | Baz), I'd like to write a function that can take a constructor as a parameter. What would the signature be please ?
08:48:54 <EvanR-work> Bar :: Foo
08:49:13 <fasta> kstt, there is nothing irregular about that.
08:50:10 <EvanR-work> are Bar and Baz considered CAFs?
08:50:30 <kstt> CAF ?
08:50:39 <soupdragon> kstt, just write the function then ask GHC what the type is
08:51:11 <kstt> nice idea :)
08:51:17 <quicksilver> kstt: constructors are not first class in haskell.
08:51:39 <quicksilver> although if your constructors indeed have no arguments - like in the example you put in parentheses - then you have a very close approximation.
08:51:56 <soupdragon> constructors are just functions ?
08:52:01 <mux> my favourite way to understand stuff when I don't get types: having a top-level "wtf = undefined" function and then get its type via GHCi
08:52:07 <quicksilver> if it's really data Foo = Bar Int | Baz String then you are in more trouble.
08:52:20 <quicksilver> soupdragon: depends what direction you approach the 'just' from
08:52:31 <kstt> quicksilver actually they do have « argument », they are mainly containers
08:52:33 <EvanR-work> soupdragon: thats why i asked above if they were cafs, since they dont take arguments they cant be functions
08:52:35 <quicksilver> soupdragon: constructors give rise to functions.
08:52:43 <quicksilver> soupdragon: but constructors are more than that.
08:52:47 <quicksilver> you can pattern match on a constructor.
08:53:02 <quicksilver> case x of Bar _ -> .....; -- pattern match on Bar
08:53:29 <EvanR-work> (:) is a function but [] isnt
08:53:31 <quicksilver> case x of y _ -> ....; -- where y is a 'variable' standing for Bar DOESN'T WORK ;)
08:54:01 <quicksilver> if you pass 'Bar' as a parameter to a function
08:54:17 <quicksilver> then all you get is that part of the constructor which is, indeed, a function
08:54:23 <quicksilver> you don't get the part that you can match against.
08:55:36 <EvanR-work> Bar Int | Baz String, you can make a function like :: (Foo -> a) -> ?
08:55:37 <EvanR-work>  ;)
08:55:45 <quicksilver> in that sense, constructors aren't first class in haskell - you can't pass them to a function as a parameter and then use 'what you get' to pattern match.
08:55:52 <quicksilver> EvanR-work: yes, of course you can. That's just the funciton part.
08:55:56 <EvanR-work> (Foo -> a) -> a
08:55:57 <quicksilver> EvanR-work: you can't use that to pattern match.
08:56:00 <quicksilver> that's the point I'm making.
08:56:01 <EvanR-work> yes
08:56:13 <EvanR-work> in the above the function cant do anything im thinking
08:56:16 <soupdragon> why would you pass constructors around
08:56:54 <quicksilver> why would you pass anything around?
08:57:02 <quicksilver> why do we ever ask for first-class this or abstractions over that?
08:57:09 <quicksilver> because it lets us factor our code
08:57:14 <quicksilver> pull out common patterns
08:57:18 <quicksilver> reuse them
08:58:47 <EvanR-work> (a -> Foo) -> Foo
08:59:14 <EvanR-work> is a const
08:59:46 <quicksilver> a workable compromise is to split the type into an enum-like part and the value part.
09:00:01 <quicksilver> and have an Eq instance for the enum-like part which serves the role of constructor.
09:00:31 <EvanR-work> data A = A T V
09:00:48 <EvanR-work> but then your value may not match with the type
09:01:07 <EvanR-work> unless you enforce it with abstract interface
09:01:55 <EvanR-work> sounds brittle
09:02:53 <kstt> ok I managed to get my function to work
09:03:01 <kstt> thank you all
09:03:25 <kstt> (that was a parametric parser combinator)
09:04:34 <dmwit> !!!
09:04:36 <dmwit> ?hackage gtk
09:04:37 <lambdabot> http://hackage.haskell.org/package/gtk
09:04:41 <dmwit> YESSSSSSS
09:06:43 <byorgey> =D
09:07:26 <byorgey> oh, nice, cairo is now split out into a separate library, too!
09:07:48 <dcoutts> should help criterion etc
09:07:59 * byorgey does a jib of happiness
09:08:04 <byorgey> a jig even
09:08:07 <EvanR-work> lol
09:08:13 <quicksilver> EvanR-work: you can enforce it with a GADT if you want
09:08:14 <EvanR-work> i like the cut of your jib
09:08:14 <byorgey> I'm so happy I made up a new dance
09:08:28 <quicksilver> EvanR-work: sometimes there is a certain regularity.
09:08:37 <quicksilver> anyway I had something else to do, I stopped partway through my explanation
09:09:00 <EvanR-work> does a gib
09:09:02 <quicksilver> I was going to go onto say.. or for a better solution, you pass around constructor/destructor pairs, like (b -> Foo, Foo -> Maybe b)
09:09:17 <quicksilver> and then you really do have most of the power of a first-class constructor.
09:09:27 <quicksilver> This is a bit like lenses but not exactly.
09:09:43 <EvanR-work> and now i know what lenses are
09:09:49 <EvanR-work> amazing
09:09:49 <Silvah> > ((-3) * (-3) > (-2) * (-2), (-3) > (-2))
09:09:50 <lambdabot>   (True,False)
09:10:02 <quicksilver> EvanR-work: no, lenses are (Foo -> b, Foo -> b -> Foo)
09:10:07 <quicksilver> EvanR-work: getter and setter
09:10:09 <Botje> @pl \x y z -> x * y
09:10:10 <lambdabot> (const .) . (*)
09:10:11 <quicksilver> not constructor and destructor.
09:10:13 <Botje> O_o
09:10:14 <quicksilver> but they are related.
09:10:15 <Botje> evil
09:10:21 <EvanR-work> oh
09:10:40 <Silvah> @pl \x y -> (x*x > y*y, x > y)
09:10:40 <lambdabot> ap (ap . ((,) .) . (. join (*)) . (>) . join (*)) (>)
09:10:50 <Silvah> > ap (ap . ((,) .) . (. join (*)) . (>) . join (*)) (>) (-3) (-2)
09:10:51 <lambdabot>   (True,False)
09:10:54 <Silvah> lol
09:11:04 <EvanR-work> i suddenly was thinking that a telescoping set of setters could be combined to update a nested record
09:11:24 <EvanR-work> guess thats not lenses
09:11:30 <Silvah> @pl \x y -> (x*x > y*y) == (x > y)
09:11:30 <lambdabot> ap (ap . ((==) .) . (. join (*)) . (>) . join (*)) (>)
09:11:45 <quicksilver> EvanR-work: yes, that's exactly what lenses are
09:11:50 <EvanR-work> oh
09:12:11 <EvanR-work> but the combining isnt a matter of just doing .
09:12:31 <dmwit> Not quite, no.
09:12:35 <EvanR-work> well it should be
09:12:35 <quicksilver> there is a natural way to combine (Foo -> Bar, Foo -> Bar -> Foo) with (Bar -> Baz, Bar -> Baz -> Bar) to get (Foo -> Baz, Foo -> Baz -> Foo)
09:12:44 <dmwit> But they form a category, so you can use the category composition. =)
09:12:47 <quicksilver> EvanR-work: (.) alone is enough on the getter side
09:13:13 <quicksilver> the setter side is also (.) if you rearrange the parameters.
09:13:27 <EvanR-work> ah thats what im talkin about
09:13:41 <EvanR-work> category shmategory
09:13:42 <quicksilver> @djinn (a -> b -> b) -> (b -> c -> c) -> (a -> c -> c)
09:13:44 <lambdabot> f _ _ _ a = a
09:13:55 * quicksilver slaps lambdabot 
09:13:58 <quicksilver> no, not that one ;)
09:14:18 <quicksilver> ah, what I asked for is impossible.
09:14:23 <quicksilver> you need the inner getter
09:14:34 <quicksilver> to make the outer settery you use the inner getter *and* the inner setter.
09:15:21 <triyo> n00b question. Is there a way to represent a Generic Number type in Haskell? A filed could be an Integer or Double for instance.
09:15:55 <soupdragon> triyo, Num
09:16:09 <soupdragon> e.g.  data X n = ... | N n | ...
09:16:17 <soupdragon> Num n =>  ... -> X n -> ...
09:16:51 <soupdragon> another way to do it is   data N = I Integer | D Double   which is like dynamic typing
09:17:54 <EvanR-work> triyo: CReal
09:18:05 <EvanR-work> > 5 :: CReal
09:18:05 <lambdabot>   5.0
09:18:14 <EvanR-work> > 23471928374918237491823498127394 :: CReal
09:18:15 <lambdabot>   23471928374918237491823498127394.0
09:18:18 <EvanR-work> > pi :: CReal
09:18:19 <lambdabot>   3.1415926535897932384626433832795028841972
09:18:25 <triyo> soupdragon: that makes sense. thx
09:18:27 <EvanR-work> :)
09:18:39 <triyo> EvanR-work: wow a CReal data type, sweet
09:19:13 <triyo> @type CReal
09:19:13 <yaxu> hi all, how do you prounce "<*>" ?
09:19:14 <lambdabot> Not in scope: data constructor `CReal'
09:19:38 <quicksilver> triyo: CReal *is* a type, so it doesn't have a type.
09:19:39 <triyo> EvanR-work: any idea what module its in?
09:19:40 <dmwit> :t (<*>)
09:19:41 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:19:42 <quicksilver> numbers
09:19:44 <quicksilver> package on hackage
09:19:53 <idnar> yaxu: "ap", I suppose
09:19:57 <dmwit> yaxu: "ap"
09:20:02 <quicksilver> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
09:20:15 <EvanR-work> is <*> 'fmap' ?
09:20:16 <jmcarthur> i love how all i have to do is try to run `darcs put' in a repository that has binaries in it to completely crash my linux box
09:20:21 <dmwit> EvanR-work: No, ap.
09:20:30 <EvanR-work> :t fmap
09:20:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:20:33 <EvanR-work> :t ap
09:20:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:20:49 <EvanR-work> interesting
09:20:55 <yaxu> EvanR-work:  <$> is `fmap`
09:21:25 <EvanR-work> so is ap supposed to be used for monads or functors or both?
09:21:25 <yaxu> thanks all
09:21:40 <EvanR-work> or applicative
09:21:42 <quicksilver> functors in general don't have ap
09:21:44 * EvanR-work goes insane
09:21:47 <jmcarthur> ap is for monads, <*> is for applicatives
09:21:51 <jmcarthur> they mean the same thing though
09:21:52 <ski> EvanR-work : monads (but every monad is an applicative functor, and is also a plain functor)
09:22:21 <EvanR-work> @src Applicative
09:22:21 <lambdabot> class Functor f => Applicative f where
09:22:22 <lambdabot>     pure  :: a -> f a
09:22:22 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
09:22:36 <ski> (also, note that not every `Monad' in haskell is actually required to be an `Applicative' or a `Functor', due to hysterical raisins)
09:22:43 <EvanR-work> lol
09:26:26 <vitka> :t unsafeCoerce . unsafePerformIO
09:26:27 <lambdabot> Not in scope: `unsafeCoerce'
09:26:35 <vitka> :P
09:27:12 <EvanR-work> :t unsafePerformIO
09:27:12 <lambdabot> forall a. IO a -> a
09:27:34 <EvanR-work> > unsafePerformIO (putChar 'a')
09:27:36 <lambdabot>   *Exception: Prelude.undefined
09:27:50 <quicksilver> that's interesting.
09:28:06 <triyo> CReal seems cool. Does it make sense that it would be a lot slower than Integer when computing a product of say 10000 ... when I compute for Integer, it flys, with CReal it seems a lot slower
09:28:15 <quicksilver> triyo: yes, it's much much much slower
09:28:30 <EvanR-work> triyo: maybe you want Ratio
09:28:33 <EvanR-work> of two Integers
09:28:40 <EvanR-work> > 22 % 7
09:28:41 <lambdabot>   22 % 7
09:28:44 <quicksilver> although its speed is adaptive depending how much information you ask for
09:28:58 <quicksilver> > 1.098723407913458723094587203948752938745290387452983475 :: Rational
09:28:59 <lambdabot>   43948936316538348923783488157950117549811615498119339 % 4000000000000000000...
09:29:11 <EvanR-work> lol?
09:29:32 <EvanR-work> whats with the 4
09:29:46 <Cale> EvanR-work: It's in lowest terms
09:29:46 <quicksilver> it reduces to lowest terms
09:29:55 <quicksilver> my numerator had a factor of 25
09:30:04 <quicksilver> (all numbers ending in 75 do...)
09:30:28 <Cale> > 0.75 :: Rational
09:30:29 <lambdabot>   3 % 4
09:30:37 <EvanR-work> > pi :: Rational
09:30:39 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
09:30:39 <lambdabot>    arising from a us...
09:30:57 <quicksilver> Rational also exhibits variable speed, of course - there is a tendency for arithemtic operations to increase the size of the denominator
09:31:14 <EvanR-work> :t (%)
09:31:15 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
09:31:26 <EvanR-work> Rational is not Ratio?
09:31:28 <quicksilver> and, asymptotically, primitive operations on Rational are mostly O(log denom) in complexity
09:31:33 <quicksilver> EvanR-work: Rational is Ratio Integer
09:31:51 <quicksilver> however, Ratio is pretty broken on types which are subject to overflow
09:32:00 <b0fh_ua> Hello! Can somebody please take a look at: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25695#a25695 and let me know what do I do in wrong way?
09:32:01 <quicksilver> because when the denominator overflows you just get rubbish.
09:32:20 <EvanR-work> are you calling Z_n rubbish ;)
09:32:57 <xcr_> hi, what is _|_ ?
09:33:06 <quicksilver> EvanR-work: as the basis for the Ratio a type, yes.
09:33:14 <aavogt> @google bottom logic
09:33:16 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.77.988&rep=rep1&type=pdf
09:33:16 <lambdabot> Title: Bottom-Up Learning of Markov Logic Network Structure
09:33:41 <aavogt> xcr_: it's some invalid condition like an infinite loop or call to error
09:34:14 <EvanR-work>  > head []
09:34:18 <EvanR-work>   _|_
09:34:36 <EvanR-work>  > length [1..]
09:34:38 <EvanR-work>   _|_
09:34:58 <EvanR-work> :D
09:35:05 <xcr_> thanks
09:36:00 <xcr_> ( I was trying to decode seq )
09:36:34 <xcr_> kinda makes sense now
09:36:44 <EvanR-work> > seq (head []) 5
09:36:45 <lambdabot>   *Exception: Prelude.head: empty list
09:36:59 <EvanR-work> > snd (head [], 5)
09:37:00 <lambdabot>   5
09:37:36 <aavogt> @type curry snd
09:37:37 <lambdabot> forall a b. a -> b -> b
09:38:06 <aavogt> @type const
09:38:07 <lambdabot> forall a b. a -> b -> a
09:38:34 <aavogt> so fst and snd should really be curried functions :)
09:39:38 <EvanR-work> omg tuples are useless
09:40:04 <quicksilver> well, tuples are useful for multiple return values
09:40:14 <quicksilver> unless you want to refactor all such code into CPS style
09:40:35 <EvanR-work> we should program everything in untyped lambda calculus
09:40:51 <quicksilver> #lisp is over that way? ;)
09:40:57 <EvanR-work> lol
09:41:00 <ksf> @pl (\cnt -> kk cnt >>= (\kc -> return $ takeI n kc))
09:41:00 <lambdabot> (takeI n `fmap`) . kk
09:41:48 <ksf> so what, CPS is trivial.
09:41:54 <ksf> by itself, without oleg, that is.
09:42:03 <triyo> I'm trying to get ghc to infer Rational for read function, no luck
09:42:21 <triyo> Prelude.read: no parse
09:42:22 <quicksilver> yes, but we don't write code via trivial transforms; we write code in the way which helps us think best
09:42:25 <EvanR-work> triyo: do you have a top level type definitions
09:42:31 <triyo> yes I do
09:42:36 <triyo> -> Rational
09:42:37 <quicksilver> triyo: using what syntax?
09:42:53 <quicksilver> > read "2%3" :: Rational
09:42:54 <lambdabot>   2 % 3
09:42:58 <quicksilver> > read "2.3" :: Rational
09:42:59 <lambdabot>   *Exception: Prelude.read: no parse
09:43:11 <triyo> hm, I see
09:43:13 <quicksilver> i.e. Rational uses the % as its Read-syntax, not the decimal.
09:43:28 <triyo> I'm passing in an Integer in my case
09:43:37 <triyo> at the moment, but I might get a Double
09:43:43 <EvanR-work> read takes a String
09:43:46 <ksf> > read "2" :: Rational
09:43:47 <lambdabot>   *Exception: Prelude.read: no parse
09:44:00 <triyo> ksf: thats the I get
09:44:02 <ksf> ...it really, really wants to have that %.
09:44:10 <triyo> hehe exactlly
09:44:12 <ksf> it's rational's type constructor.
09:44:23 <aavogt> so if we had postfix function application, does that make CPS look almost normal?
09:44:28 <Silvah> :T (%)
09:44:30 <EvanR-work> triyo: if you are just converting a Integer to Rational, use fromIntegral
09:44:31 <ksf> > read "2%1" :: Rational
09:44:31 <Silvah> :t (%)
09:44:32 <lambdabot>   2 % 1
09:44:32 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
09:44:48 <triyo> Oh I see
09:44:54 <aavogt> though the arguments are in the wrong order sort of
09:46:09 <quicksilver> ksf: funnily enough, it's not
09:46:13 <quicksilver> ksf: % isn't a constructor
09:46:22 <quicksilver> personally I think that Read instance is a little surprising.
09:46:31 <quicksilver> (but it's consistent with the Show instance which is one of the rules)
09:47:01 <aristid> @src (%)
09:47:02 <lambdabot> x % y = reduce (x * signum y) (abs y)
09:47:22 <quicksilver> I have a lurking feeling that Num types should read anything of the form "12345" and Fractional types should read anything of the form "1234.5678"
09:47:26 * ksf just made his code typecheck without undefined and now is afraid to run it.
09:47:26 <aristid> @src reduce
09:47:26 <lambdabot> reduce _ 0 = undefined
09:47:26 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
09:47:26 <lambdabot>     where d = gcd x y
09:47:39 <quicksilver> since those types will be accepted by such literals in code
09:47:48 <quicksilver> and Read/Show is supposed to be about haskell code syntax.
09:47:51 <quicksilver> But it isn't very important.
09:48:00 <aristid> > 4 :% 8
09:48:01 <lambdabot>   Not in scope: data constructor `:%'
09:48:10 <aristid> uh, where is :%?
09:48:15 <quicksilver> :% is hidden to stop you constructing improper fractions
09:48:22 <ksf> "fromList" is a similarily nasty case.
09:48:23 <quicksilver> which is just as well because that's exactly what you just tried to do!
09:48:32 <aristid> quicksilver: yes! :)
09:48:51 <quicksilver> the numeric functions over Rational assume reduced form.
09:48:57 <quicksilver> it makes them slightly faster to assume that.
09:49:12 <ksf> at the expense of reducing all the time.
09:49:15 <quicksilver> well at least it makes Eq faster
09:49:19 <quicksilver> I'm not sure what else it makes faster :)
09:49:53 <dmwit> > showHex 768 ""
09:49:54 <lambdabot>   "300"
09:49:55 <Cale> Show
09:50:10 <ksf> I don't think code that uses rational coincides with code that needs to be fast often, though.
09:50:18 <aavogt> > read "4%8"::Rational
09:50:19 <lambdabot>   1 % 2
09:50:36 <soupdragon> > sort [1,2,3]
09:50:37 <lambdabot>   [1,2,3]
09:50:47 <ksf> > toRational (read "1.2" :: CReal)
09:50:48 <Cale> Fast rational linear algebra is apparently something that can get quite arcane
09:50:48 <lambdabot>   *Exception: CReal.toRational
09:50:50 <soupdragon> x(x:ys)
09:50:59 <ksf> > toRational (read "1.0" :: CReal)
09:51:00 <lambdabot>   *Exception: CReal.toRational
09:51:03 <ksf> > toRational (read "1" :: CReal)
09:51:03 <soupdragon> :t (-) . head
09:51:04 <lambdabot> forall a. (Num a) => [a] -> a -> a
09:51:04 <lambdabot>   *Exception: CReal.toRational
09:51:08 <ksf> huh
09:51:34 <aavogt> perhaps it's better for it to die rather than give an approximation here
09:51:47 <aavogt> though that doesn't explain the Eq and Ord instances
09:51:50 <ksf> approximate 1%1?
09:52:11 <aavogt> ksf: I mean so that it doesn't surprise you when  toRational (pi :: CReal) doesn't terminate
09:52:22 <soupdragon> @pl \l -> head l : map ((-) . head $ l) (tail l)
09:52:22 <lambdabot> liftM2 (:) head (ap (map . (-) . head) tail)
09:52:33 <soupdragon> > iterate (liftM2 (:) head (ap (map . (-) . head) tail)) [6,8]
09:52:34 <lambdabot>   [[6,8],[6,-2],[6,8],[6,-2],[6,8],[6,-2],[6,8],[6,-2],[6,8],[6,-2],[6,8],[6,...
09:52:39 <soupdragon> > iterate (liftM2 (:) head (ap (map . (-) . head) tail) . sort) [6,8]
09:52:40 <lambdabot>   [[6,8],[6,-2],[-2,-8],[-8,-6],[-8,-2],[-8,-6],[-8,-2],[-8,-6],[-8,-2],[-8,-...
09:52:57 <ksf> > toRational (read "1.0" :: CReal) :: Ratio CReal
09:52:58 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
09:52:58 <lambdabot>         against infe...
09:53:00 <Cale> ksf: There's no way that it can ever be totally certain that the CReal it has corresponds to 1%1
09:53:06 <soupdragon> > iterate (liftM2 (:) head (ap (map . flip . (-) . head) tail) . sort) [6,8]
09:53:07 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
09:53:39 <ksf> I don't know a bit about creal's implementation
09:53:46 <soupdragon> > iterate (liftM2 (:) head (ap (map . flip . flip (-) . head) tail) . sort) [6,8]
09:53:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
09:53:49 <ksf> I assumed it was something like series of ratios or such
09:53:53 <soupdragon> > iterate (liftM2 (:) head (ap (map . flip (-) . head) tail) . sort) [6,8]
09:53:54 <lambdabot>   [[6,8],[6,2],[2,4],[2,2],[2,0],[0,2],[0,2],[0,2],[0,2],[0,2],[0,2],[0,2],[0...
09:54:00 <soupdragon> > iterate (liftM2 (:) head (ap (map . flip (-) . head) tail) . sort) [6,8,2]
09:54:02 <lambdabot>   [[6,8,2],[2,4,6],[2,2,4],[2,0,2],[0,2,2],[0,2,2],[0,2,2],[0,2,2],[0,2,2],[0...
09:54:22 <aavogt> ksf: well independent of it's representation, toRational isn't defined for lots of creals
09:56:17 <triyo> This is what worked for me. Depending on the expectation that is. I expect an Integer in one scenario, so my code for it looks like so: toRational (read $ B.unpack txt :: Integer)
09:56:46 <soupdragon> > iterate (liftM2 (:) head (ap (map . flip (-) . head) tail) . sort) [5*3*84,5*3*847,5*3*124]
09:56:47 <lambdabot>   [[1260,12705,1860],[1260,600,11445],[600,660,10845],[600,60,10245],[60,540,...
09:56:56 <triyo> I firstly needed to unpack some ByteString and then read it in as the expected Integer, then I called toRational
09:57:51 <ski> aavogt : yes
09:58:44 <aavogt> ski: but neither is Eq
09:58:48 <aavogt> and we have that
09:58:59 <ski> (.. and that was re CPS :)
09:59:08 <aavogt> :(
09:59:18 <ski> <aavogt> so if we had postfix function application, does that make CPS look almost normal?
09:59:30 <ski> <aavogt> though the arguments are in the wrong order sort of
09:59:41 * aavogt remembers that
10:00:40 <ski> maybe something like .. `(k Head) (repeat x) = k x; (k Tail) (repeat x) = k (repeat x)'
10:01:01 <ski> (where `Head :: a -> Stream a; Tail :: Stream a -> Stream a')
10:02:16 <ski> (apropos, the CPS transformation is not a local transformation .. so in that sense, it is not a trivial one)
10:12:55 <ksf> some people claim that the way to understand iteratees is to write one's own.
10:13:08 <c_wraith> and then upload it to hackage
10:13:23 <ksf> that's misleading. writing your own iteratees is bound to confuse you more than reading oleg's code ever could on its own.
10:14:35 <ksf> ...and the code being more pointless than I'm comfortable with doesn't help things.
10:18:55 <EvanR-work> haha
10:24:45 <Eludias> (newby question) I've got a list of files/directory names, how do find out which of them are directories? 'filter System.Directory.doesDirectoryExist fnames' obviously doesn't work with IO Bool..
10:26:47 <dv-> filterM
10:26:54 <Zao> @type filterM
10:26:56 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
10:27:19 <Eludias> thanks.
10:33:39 <b0fh_ua> Hello! Can somebody please take a look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25696#a25696, and let me know what do I do in wrong way?
10:33:49 <b0fh_ua> I'm not sure how to resolve that type conflicts
10:36:27 <lpsmith> Is there a Haskell function  :: IO Int that returns a cryptographically secure random number in a platform independent way?
10:36:35 <lpsmith> I suppose I could just read from /dev/urandom
10:37:30 <Botje> lpsmith: there's randomIO
10:37:39 <Botje> it's not very secure though, i imagine
10:37:43 <Polarina> lpsmith, or implement a cryptographically secure pseudo-random number generator (and even make it pure).
10:40:22 <lpsmith> for my intended application,  IO is the most convenient way :)  I'd also prefer a generator that re-seeds itself from a source that's closer to truly random,  as urandom does
10:40:54 <zygoloid> lpsmith: unsafeCoerce (Just 42) :: Int ;-)
10:41:45 <lpsmith> chosen by a fair die roll, guaranteed to be random, right?  :)
10:42:15 <soupdragon> @roll 1d42
10:42:15 <lambdabot> Consider it noted.
10:42:23 * zygoloid went for something more horrible than the standard xkcd reference
10:42:46 <zygoloid> @die 1d42
10:42:46 <lambdabot> 1d42 => 42
10:42:48 <ski> @die 1d0
10:42:48 <lambdabot> 1d0 => 1
10:43:17 <c_wraith> lpsmith: if you're on a system that has /dev/urandom, you can use unsafeInterleaveIO to convert it into a "pure" list of Int
10:43:52 <soupdragon> @roll 10d6
10:43:52 <c_wraith> err, "pure" *lazy* list of Int
10:43:52 <lambdabot> Consider it noted.
10:44:11 <c_wraith> heh.  roll = tell
10:44:30 <xerox> @dice 1d1
10:44:30 <lambdabot> 1d1 => 1
10:44:38 <xerox> fixed game
10:44:42 <danharaj> @dice 1d20
10:44:42 <lambdabot> 1d20 => 6
10:45:40 <soupdragon> @dize 1016161613d123123
10:45:41 <lambdabot> 1016161613d123123 => 62558887075461
10:46:04 <Ferdirand> what does "platform independent" means in this case ?
10:46:07 <soupdragon> @dice 11111111d11
10:46:08 <lambdabot> 11111111d11 => 66663632
10:46:12 <soupdragon> @dice 11111111d1111111111111111111111
10:46:13 <lambdabot> 11111111d111111111111111111... => 6173721540544574128197017916
10:46:20 <zygoloid> @lice 100d0
10:46:20 <lambdabot> 100d0 => 50
10:46:21 <zygoloid> @lice 100d1
10:46:22 <lambdabot> 100d1 => 100
10:46:27 <soupdragon> @lice 100d100
10:46:27 <lambdabot> 100d100 => 5532
10:46:38 <soupdragon> @dec 5d3
10:46:38 <lambdabot> Maybe you meant: dice dict do docs ghc let rc src
10:46:42 <soupdragon> @decf 5d3
10:46:42 <lambdabot> Maybe you meant: dice dict docs
10:46:47 <soupdragon> @dece 5d3
10:46:47 <lambdabot> 5d3 => 12
10:46:48 <soupdragon> @dece 5d3
10:46:49 <lambdabot> 5d3 => 8
10:46:50 <zygoloid> huh, d0 seems to be treated as d2
10:46:55 <soupdragon> how do you do bionmonial cofefficents
10:47:10 <soupdragon> @idce 3d5
10:47:11 <lambdabot> Maybe you meant: dice id
10:47:11 <lpsmith> Ferdirand, something that works under most unices and microsoft windows server
10:47:13 <soupdragon> @idce 5d5
10:47:13 <lambdabot> Maybe you meant: dice id
10:47:16 <soupdragon> @dice 5d5
10:47:16 <lambdabot> 5d5 => 17
10:47:17 <soupdragon> @dice 5d5
10:47:17 <lambdabot> 5d5 => 16
10:47:18 <soupdragon> @dice 5d5
10:47:18 <lambdabot> 5d5 => 13
10:47:20 <dmwit> ?dice 5d5+32
10:47:20 <lambdabot> 5d5+32 => 50
10:47:27 <lpsmith> But I'm not too worried, I think I'll just read from urandom
10:47:52 <ski> zygoloid : not quite. `1d2' gives either `1' or `2', while `1d0' apparently gives either `0' or `1'
10:48:01 <zygoloid> ski: yeah :-/
10:48:07 <zygoloid> @dice 1d0 + 0d1
10:48:08 <lambdabot> 1d0 + 0d1 => 0
10:48:25 <zygoloid> @ghc
10:48:25 <lambdabot> ghc says: Illegal polymorphic type signature in pattern
10:48:45 <siracusa> What does `@dice xdy' mean?
10:48:46 <ski> @dice replicateM 3 1d6
10:48:46 <lambdabot> unexpected "r": expecting number
10:48:50 <zygoloid> @ghc NEVER
10:48:51 <lambdabot> ghc says: NEVER use commas within those string literals, cpp will ruin your day
10:49:12 <ski> siracusa : roll a die with `y' faces `x' times, adding the results
10:49:55 <zygoloid> siracusa: lambdabot sends a message over amazon's mechanical turk and someone somewhere rolls x dice with y faces, and adds up the results
10:50:29 <siracusa> zygoloid: Wow, this person must be very quick :-P
10:50:55 <ski> oh, this must be the new "grid computing", processing power for hire, i've heard about !
10:51:44 <nus> mechanical turks in clouds
10:51:55 <nus> @quote unf
10:51:56 <lambdabot> Botje says: fuzzy feelings aren't always aerodynamic, unfortunately.
10:51:58 <nus> @quote unf
10:51:59 <lambdabot> mjard says: "parsers are like the unfun part of everything"
10:52:02 <nus> @quote unf
10:52:02 <lambdabot> ddarius says: Unfortunately, the logic programming community has this unhealthy death grip on Prolog.
10:52:06 <nus> @quote fun
10:52:07 <lambdabot> kmc says: the usual structure for a Haskell program is a crunchy IO shell with a  gooey chocolate pure function center
10:52:10 <nus> @quote fun
10:52:10 <lambdabot> anonymous says: Primitive recursion is the goto of functional programming.
10:53:22 <zygoloid> @ghc fun
10:53:22 <lambdabot> ghc says: The instance types do not agree with the functional dependencies of the class
10:56:09 <zygoloid> @ghc strange way
10:56:10 <lambdabot> ghc says: deadlock: main thread blocked in a strange way
10:57:37 <lpsmith> ddarius, so what do you think the logic programming community and/or the Prolog community should be doing?
10:58:48 <Eludias> filter on [IO a] is called filterM. How would one do partitionM?
10:59:35 <soupdragon> "Prolog community" heh
11:00:16 <markus_____> it was a qouote, darius is not here
11:00:30 <lpsmith> markus_____, I know :)
11:00:37 <lpsmith> But ddarius is often around
11:00:40 <edwardk> soupdragon: it'll continue to exist as long as folks like frank pfenning has graduate students ;)
11:00:47 <edwardk> er have
11:01:02 <elliottcable> ack
11:01:08 <dpratt71> how might I resolve this cabal error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25697#a25697
11:01:10 <edwardk> lpsmith: the tongue in cheek answer is "learn haskell" ;)
11:01:11 <markus_____> heh
11:01:26 <edwardk> they can then write their programs at the type level
11:01:29 <edwardk> like oleg
11:01:31 <copumpkin> untyped!
11:01:48 <dcoutts> dpratt71: use a different version of the unix package, e.g. the one you've got installed already.
11:01:55 <edwardk> copumpkin: they're prolog/logic programmers, they are used to living without types ;)
11:02:01 <copumpkin> failogic
11:02:06 <lpsmith> Prolog is a language I should know better than I do
11:02:10 <copumpkin> we need moar universez
11:02:26 * edwardk hands copumpkin Set1 and Set2, so he can have a couple more on hand.
11:02:27 <copumpkin> liek lots and lots
11:02:34 <copumpkin> edwardk: MOAR!!
11:02:44 <lpsmith> hahaha
11:02:55 <dpratt71> dcoutts: what if a package I'm trying to install has a dependency on this version of the unix package?
11:03:12 * copumpkin DEMANDZ LEVELZ
11:03:16 * edwardk hands copumpkin, S n, Z, and a function Nat -> universe.
11:03:16 <dcoutts> dpratt71: if it really really needs that version of the unix package then you need to upgrade ghc.
11:03:30 <dcoutts> dpratt71: but it probably does not need that recent a version of the unix package.
11:03:39 <copumpkin> Set_omega!
11:03:56 <dpratt71> dcoutts: ok, thanks
11:04:14 <edwardk> if you want more than a countable infinity of universes, we'll need to talk about other indexing sets.
11:04:29 <edwardk> but then universe containment gets funky
11:04:58 <dcoutts> dpratt71: you can make cabal try picking an older version: cabal install foo --constraint='unix == 2.3.*'  for example
11:05:13 <edwardk> copumpkin: i note that your iminent fall from the ivory tower of academia seems to have already caused your speech patterns to regress ;)
11:05:18 <dcoutts> dpratt71: you can check what version you've already got installed using cabal info unix
11:05:32 <copumpkin> edwardk: WUT U MEAN
11:06:14 <dpratt71> dcoutts: ok, thanks; I'm assuming that there's no particular harm in updating the platform, so I'm proceeding in that direction
11:07:07 <mreh_> man it's like #math in here, but without the hostility to outsiders
11:07:15 <copumpkin> mreh_: STFU
11:07:19 <FauxFaux> Screw you, mre.. bah. :p
11:07:38 <copumpkin> :P
11:07:52 <soupdragon> not enough sexism and egotism for #math
11:07:54 * copumpkin stops acting dumb
11:08:04 <copumpkin> I'll just be my normal dumb self
11:08:21 <mreh_> that's hardly true
11:08:27 <mreh_> you're abnormally dumb
11:08:42 <copumpkin> well, for me abnormality is normal
11:09:02 <ski> @src partition
11:09:02 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
11:09:02 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
11:09:02 <lambdabot>                               | otherwise = (ts, x:fs)
11:09:18 <ski> @type let partitionM :: Monad m => (a -> m Bool) -> ([a] -> m ([a],[a])); partitionM p xs = foldrM (select p) (return ([],[])) xs where select p x ~(ts,fs) = liftM (\b -> let (ts',fs') | b = (x:ts,fs) | otherwise = (ts, x:fs) in (ts',fs')) (p x) in partitionM
11:09:19 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m ([a], [a])
11:09:25 <ski> maybe something like that ?
11:09:25 <lpsmith> mreh_, it's like a lot of channels in here without the hostility to outsiders
11:09:33 <copumpkin> > partitionM even [1..5]
11:09:34 <lambdabot>   Not in scope: `partitionM'
11:09:47 <copumpkin> @let partitionM :: Monad m => (a -> m Bool) -> ([a] -> m ([a],[a])); partitionM p xs = foldrM (select p) (return ([],[])) xs where select p x ~(ts,fs) = liftM (\b -> let (ts',fs') | b = (x:ts,fs) | otherwise = (ts, x:fs) in (ts',fs')) (p x)
11:09:48 <lambdabot>  Defined.
11:09:49 <copumpkin> > partitionM even [1..5]
11:09:54 <lambdabot>   Couldn't match expected type `m GHC.Bool.Bool'
11:09:56 <lambdabot>         against inferred typ...
11:10:08 <lpsmith> seriously,  sometimes it's easier to ask an off-topic question in #haskell than to try to find any satisfaction certain other channels
11:10:09 <copumpkin> > partitionM (return . even) [1..5]
11:10:10 <lambdabot>   No instance for (GHC.Show.Show (m ([a], [a])))
11:10:10 <lambdabot>    arising from a use of `M8...
11:10:26 <lpsmith> Or #haskell-blah,  often works too
11:10:37 <copumpkin> > partitionM (sequence [even, odd]) [1..5]
11:10:38 <lambdabot>   [([2,4],[1,3,5]),([1,2,4],[3,5]),([4],[1,2,3,5]),([1,4],[2,3,5]),([2,3,4],[...
11:11:16 <soupdragon> @quote
11:11:17 <lambdabot> hakko says: most programmers have a lot of religious issues about their work, yes.
11:11:21 <soupdragon> @quote
11:11:22 <lambdabot> SleepDeprivation says: <Speck> Oh my god. Crickets in the basement. <Speck> Hundreds of them.
11:11:26 <soupdragon> @quote
11:11:26 <lambdabot> quanticle says: "@quote quanticle"
11:11:56 <ski> Eludias : btw, forgot to alert you to ^
11:12:57 <markus3> lambdabot remembers all the right stuff
11:13:44 <soupdragon> @quote
11:13:44 <lambdabot> mental says: "real programming" as in web 2.0 applications?
11:14:56 <ski> > partitionM (sequence [even, odd]) [0,1]
11:14:57 <lambdabot>   [([0],[1]),([],[0,1]),([0,1],[]),([1],[0])]
11:21:05 <nus> @quote lambdabot
11:21:05 <lambdabot> lambdabot says:  lambdabot hasn't said anything memorable
11:21:20 <nus> lambdabot, why do you remember it then?
11:21:24 <soupdragon> @quote]
11:21:24 <lambdabot> geezusfreeek says: i was half hoping lambdabot would lie and make something up :)
11:21:26 <soupdragon> @quote
11:21:26 <lambdabot> kmc says: "<killing-joke> ah, yes, but my 'happy' she is broken"  <--- how not to talk to your gynecologist
11:21:34 <soupdragon> @quote
11:21:34 <lambdabot> SAHChandler says: :|
11:21:37 <soupdragon> @quote
11:21:37 <lambdabot> HarriKiiskinen says: banging my head against Haskell, but liking the feeling of hurting brains
11:23:16 <gwern> @forget lambdabot lambdabot hasn't said anything memorable
11:23:16 <lambdabot> Done.
11:23:52 <soupdragon> @quote lambdabot
11:23:52 <lambdabot> lambdabot says:  lambdabot hasn't said anything memorable
11:23:57 <soupdragon> @quote
11:23:57 <lambdabot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
11:24:04 <soupdragon> @quote
11:24:05 <lambdabot> absentia says: hask me anyting and I'll kell you no lies
11:24:32 <gwern> @forget lambdabot lambdabot hasn't said anything memorable
11:24:32 <lambdabot> No match.
11:24:38 <gwern> @forget lambdabot  lambdabot hasn't said anything memorable
11:24:39 <lambdabot> No match.
11:24:42 <gwern> ?
11:24:45 <soupdragon> @quote lambdabot
11:24:45 <lambdabot> lambdabot says: * lambdabot secretly deletes lunabot's source code
11:25:16 <Gracenotes> so that's what happened... poor lunabot
11:26:05 <gwern> @forget lambdabot \ lambdabot hasn't said anything memorable
11:26:05 <lambdabot> No match.
11:26:14 <gwern> didn't think so.
11:26:39 <nus> @quote .*lambdabot.*
11:26:40 <lambdabot> erg0t says: ayer soñe k el lambdabot tenia interprete de OCaml
11:27:10 <nus> @quote .*lambdabot$
11:27:11 <lambdabot> lambdabot says: lambdabot
11:27:24 <Squarism> if a string starts with a certain sign X... can say "the string contains leading X's" ?
11:27:56 <ski> i think so
11:28:18 <nus> not sure about ('s) part
11:28:41 <gwern> @forget lambdabot lambdabot
11:28:41 <lambdabot> Done.
11:29:00 <ski> surely if a string starts with (at least) one X, then it starts with at least zero X's ?
11:31:43 <nus> ski, if that generalization holds true, then the string starts with zero of all other symbols as well
11:32:44 <ski> sure
11:33:12 <nus> then, zero is a just another symbol wich all strings inherently start with
11:33:18 <nus> *which*
11:33:27 <ArkRost> Hi! I have some questions about haskell and AST. Can I change haskell's AST like in Lisp?  Is there a preprocessor in haskell? Where I can take a look on the examples if it's possible?
11:33:50 <soupdragon> ArkRost you can't do lisp style macros but the need to is much rarer
11:34:32 <soupdragon> ArkRost, for example I coul define (-->) = (,), then cond ((True,x):_) = x ; cond (_:xs) = cond xs
11:34:44 <soupdragon> now I can write  cond [ p1 --> r1, p2 --> r2 ]
11:34:51 <soupdragon> and thats just a normal function, rather than a macro
11:35:59 <sepp2k> ArkRost: GHC allows you to specify rewrite rules, but those are incredibly evil and are not supposed to change semantics (although they're very well able to)
11:36:17 <ski>   ?- replicate(_,0,Zeros),replicate(_,1,Ones),append(Zeros,_,[2,3,4]),append(Ones,_,[2,3,4]).
11:36:22 <ski>   Yes
11:36:30 <mamalujo> ArkRost: apparently lazy evaluation and purity make many things that would be marcos normal functions. Still macros are sometimes nevertheless needed. Template Haskell is the official way for such situations. alternatively I think haskell-src-exts can be used, no idea on details
11:36:40 <soupdragon> :/
11:36:43 <tibbe> dcoutts: could we turn the Cabal repo into a hashed repo? it would make it faster to fetch
11:36:44 <ski> nus : no, "zero" is a count, not a symbol
11:37:00 <mamalujo> ArkRost: neither seems to be as practical as in lisp, I gather
11:37:12 <dcoutts> tibbe: we need to upgrade darcs on the hackage box really, that'd make the conversions much simpler
11:37:21 <BMeph> That reminds me of Appel's "Critique of Standard ML", specifically: "Lack of macros: This is clearly an advantage, not a disadvantage." ;)
11:37:24 <tibbe> dcoutts: I see
11:37:25 <ski> (and if you replicate a symbol zero times, you get an empty list, which is not a symbol, either)
11:37:45 <tibbe> dcoutts: Thomas sent me two patches :) I'm going to review them as soon as I've fetched the Cabal repo
11:37:56 * tibbe likes his patches early and frequent
11:37:57 <dcoutts> great
11:38:14 <gwern> > 115 + 5*ln(1437+1)
11:38:15 <lambdabot>   Not in scope: `ln'
11:38:48 <tibbe> dcoutts: who's responsible for the hackage box?
11:38:58 <dcoutts> tibbe: galois
11:39:00 <gwern> > log 10
11:39:00 <lambdabot>   2.302585092994046
11:39:05 <gwern> log e
11:39:07 <gwern> > log e
11:39:08 <lambdabot>   log e
11:39:17 <tibbe> dons: could we upgrade the hackage box to the latest version of darcs pretty please?
11:39:22 <gwern> > 115 + 5*log(1437+1)
11:39:22 <lambdabot>   151.35504269140495
11:39:54 <ski> @let log10 :: Floating f => f -> f; log10 f = log f / log 10
11:39:55 <lambdabot>  Defined.
11:40:02 <soupdragon> > e
11:40:03 <ksf> this is like a puzzle depicting a completely blue sky.
11:40:03 <lambdabot>   e
11:40:15 <ski> > log (exp 1)
11:40:16 <lambdabot>   1.0
11:40:19 <ski> > log10 (exp 1)
11:40:20 <lambdabot>   0.43429448190325176
11:40:29 <ksf> you're in a twisty little maze of types all looking the same but still not fitting.
11:40:30 <otto_s> > logBase 10 1
11:40:31 <ski> > (recip . log10 . exp) 1
11:40:32 <lambdabot>   0.0
11:40:32 <lambdabot>   2.302585092994046
11:40:42 <otto_s> > logBase 10 (exp 1)
11:40:43 <lambdabot>   0.43429448190325176
11:40:53 <ski> otto_s : ah, forgot about that one :)
11:41:01 <gwern> @src log
11:41:01 <lambdabot> Source not found. You untyped fool!
11:41:12 <otto_s> ski: :)
11:41:13 <gwern> pfft. I'll just assume 'log' is the natural log
11:42:18 <ski> > log `graph` exp 1  -- it is ..
11:42:19 <lambdabot>   (2.718281828459045,1.0)
11:42:34 <ksf> :t graph
11:42:35 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
11:45:05 <triyo> I'd like to get a 'denominator' from a Rational number. I see there is a "denominator" function in GHC.Real module, but I think it might be hidden.
11:46:24 <triyo> any ideas?
11:47:46 <ToRA> > case (5%4) of 5 :% 4 -> True
11:47:47 <lambdabot>   Not in scope: data constructor `:%'
11:47:53 <ToRA> that smells
11:48:02 <ToRA> ghci claims the constructor is imported
11:48:07 <Eelis> @type numerator
11:48:08 <lambdabot> forall a. (Integral a) => Ratio a -> a
11:48:41 <triyo> apparently % is not a constructor.
11:48:50 <bigboat> Hi, novice here, why does "doubleMe x = x + x" return "parse error on input `='" in ghci ?
11:48:50 <ToRA> no, % is a smart constructor
11:48:57 <ToRA> :% is the constructor for Real's
11:48:59 <ToRA> also in GHC.Real
11:49:09 <ToRA> but denominator is also in GHC.Real
11:49:09 <triyo> you need a let bigboat
11:49:16 <ToRA> and it is exported, so just use that
11:49:31 <triyo> let doubleMe x = x + x .... that is in ghci
11:49:52 <triyo> ToRA: I see, thanks
11:49:52 <Eduardo_> hello
11:49:59 <Eduardo_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25702#a25702
11:50:02 <ToRA> hmm, of course, that is GHC specific
11:50:07 <bigboat> ah, thank you very much
11:50:21 <Eduardo_> why this doesn't work?
11:50:34 <wli> @type numerator &&& denominator
11:50:35 <lambdabot> forall c. (Integral c) => Ratio c -> (c, c)
11:52:47 <Eduardo_> anyone?
11:54:03 <triyo> Eduardo_:  having a quick look. one sec.
11:54:11 <ksf> Eduardo_, because you're obfuscating code?
11:54:53 <ToRA> what's in IO on line 5?
11:55:04 <ksf> filter (`notElem` [".",".."]) dirContents
11:55:25 <Eduardo_> didn't know  that was a `notElem`
11:55:29 <Eduardo_> I'll try that
11:55:35 <ksf> @src notElem
11:55:36 <lambdabot> notElem x =  all (/= x)
11:55:41 <ksf> @src elem
11:55:42 <lambdabot> elem x    =  any (== x)
11:56:35 <Eduardo_> ksf: dirContents is of type IO [FilePath]
11:56:48 <ksf> it shouldn't.
11:57:08 <ksf> you execute getDirectoryContents on line 4, after all.
11:57:28 <Eduardo_> yes
11:57:37 <Eduardo_> ops
11:57:39 <Eduardo_> I mean
11:57:47 <ksf> so dirContents should be [FilePath], which is [String]
11:58:11 <ksf> ... do let files = filter ...
11:58:21 <ksf> the code I wrote isn't monadic
11:58:26 <ksf> it just doesnt' need to be.
11:58:38 <Eduardo_> Couldn't match expected type `[FilePath]' against inferred type `IO FilePath'
11:58:58 <Eduardo_> that happens on
11:59:00 <Eduardo_> (flip filter) dirContents (`notElem` [ "." , ".." ])
11:59:10 * ski annotated "newbie on IO" with "some rewriting" at <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25702#a25703>
11:59:13 <ski> Eduardo_ : ^
11:59:57 * edwardk finally gives in and uses template haskell because he can't get ghc to just "DWIM".
12:00:02 <wvd> Why is [3,2,1] > [0,0,2] = True? Shouldn't it become false because of the last element.
12:00:05 <Eduardo_> many thanks, ski
12:00:15 <Eduardo_> :)
12:00:21 <edwardk> wvd: it compares lexicographically
12:00:25 <edwardk> wvd: first element, then second, etc.
12:00:29 <edwardk> 3 > 0
12:00:35 <ksf> ski you're too fast
12:00:35 <wvd> Yes.
12:00:36 <IceKiller> does haskell accept if else if else ? (witht he second if being condition to the first if?)
12:00:53 <wvd> edwardk: But the last comparison is False, but because 2 were already True, it's True?
12:00:59 <ksf> you have to have thens there, somewhere.
12:01:11 <edwardk> wvd: no once 3 > 0 it stops
12:01:26 <wvd> edwardk: Oh..
12:01:34 <edwardk> wvd: "dcb" > "aac"
12:01:37 <ksf> > if False then False else if True then True else False
12:01:39 <lambdabot>   True
12:01:45 <edwardk> wvd: pretend you're sorting words
12:01:45 <ksf> > if False then False else if False then True else False
12:01:46 <lambdabot>   False
12:01:46 <ski> ksf : eheheh .. i was actually starting to think i was too slow (given how some people in here already had started attacking it, by the time i returned)
12:01:55 <wvd> edwardk: And if the first comparison is equal, it goes to the second?
12:01:59 <edwardk> wvd: yeah
12:02:08 <wvd> edwardk, ok, thanks.
12:02:21 <edwardk> wvd: and it takes the shorter list as the smaller, just like "ab" < "abc"
12:02:25 <Eduardo_> ski: and in case I want to do it without `let' ?
12:02:35 <Eduardo_> (asking just for learning purpose)
12:03:18 <ski> Eduardo_ : well, since the expression defining `files' isn't an action to be run, you typically wouldn't ..
12:03:33 <wvd> Also -- variables in Haskell are immutable, so they can't be changed once given a value. I've been trying this in ghci with 'let' but it lets me assign the same name two times, is this just because of let?
12:03:38 <ksf>       print . filter (`notElem` [ "." , ".." ]) =<< getDirectoryContents =<< getCurrentDirectory
12:03:42 <ski> Eduardo_ : if you really want, you could say `files <- return (...)' instead of `let files = ...', though
12:04:04 <edwardk> wvd: it has to do with the fact that in ghci it is like you're in the 'do' sugar in haskell. you aren't redefining the variable, you are 'shadowing' it.
12:04:09 <ski> (Eduardo_ : there is at least one rare case where this can be useful ..)
12:04:26 <wvd> edwardk: oh, haven't read about do yet, following LYAH, but thanks
12:04:31 <Eduardo_> > print . filter (`notElem` [ "." , ".." ]) =<< System.Directory.getDirectoryContents =<< System.Directory.getCurrentDirectory
12:04:32 <lambdabot>   Not in scope: `System.Directory.getDirectoryContents'Not in scope: `System....
12:04:37 <triyo> binding Gets the value out of the Monad wrapper, is that the right way to say it? :)
12:04:39 <Eduardo_> fail :p
12:04:44 <Eduardo_> gonna compile that
12:04:51 <ski> wvd : it is likst
12:04:59 <Eduardo_> thanks, ksf and ski
12:05:07 <edwardk> if you wrote "let x = 10"  then "let f y = x + y" then "let x = 11", the binding for f still would refer to the 'old' x.
12:05:08 <ski> > let x = 2 in let y = x*x in let x = y^3 in (x,y)
12:05:09 <lambdabot>   (64,4)
12:05:26 <ksf> Eduardo_, do-notation is just syntactic sugar for >>= and lambdas
12:05:42 <ksf> the translation is straight-forward and teaches a fair amount of stuff about monads
12:05:57 <ski> @type print . filter (`notElem` [ "." , ".." ]) =<< System.Directory.getDirectoryContents =<< System.Directory.getCurrentDirectory
12:05:58 <lambdabot> IO ()
12:06:07 <ksf> if you can wrangle them, you're not going to be confused by monads for some time.
12:06:21 <Eduardo_> yeah, I'm getting to them
12:07:31 <ksf> notice how =<< is like a unix pipe written backwards?
12:07:44 <Eduardo_> yea
12:08:06 <ksf> kinda like pwd | xargs ls | sed or whatever
12:08:09 <Eduardo_> you passed the result of getCurrentDirectory to getDirectoryContents
12:08:30 <illissius> is there any difference between foreign export dynamic and foreign import wrapper? is one old / the other new?
12:08:37 <ksf> :t print . filter (`notElem` [ "." , ".." ])
12:08:39 <lambdabot> [[Char]] -> IO ()
12:08:54 <ksf> :t filter (`notElem` [ "." , ".." ])
12:08:55 <lambdabot> [[Char]] -> [[Char]]
12:09:23 <ksf> I think function composition is the scariest part, there.
12:10:04 <ksf> you don't even have to write lambdas in haskell to define new functions, that is.
12:10:13 <Eduardo_> yea
12:10:36 <Eduardo_> Haskell is amazing
12:10:54 <ksf> :t \dirs -> print . filter (`notElem` [ "." , ".." ]) $ dirs
12:10:55 <lambdabot> [[Char]] -> IO ()
12:11:03 <ksf> :t \dirs -> print (filter (`notElem` [ "." , ".." ]) dirs)
12:11:05 <lambdabot> [[Char]] -> IO ()
12:25:13 <wvd> What's a "singleton" list?
12:25:17 <soupdragon> [x]
12:25:22 <wvd> Oh
12:25:23 <wvd> Thanks
12:25:57 <ski> > let (:[]) x = "x" in x
12:25:58 <lambdabot>   <no location info>: Parse error in pattern
12:27:22 <soupdragon> > let "x" = (:[]) 'x' in "x"
12:27:23 <lambdabot>   "x"
12:27:37 <soupdragon> > let "x" = (:[]) x in "x"
12:27:38 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:27:39 <lambdabot>         against inferred type...
12:27:39 <ski> hehe
12:32:24 <wvd> God
12:32:30 <wvd> I have to love Haskell already
12:32:33 <wvd> And I'm not at types yet
12:33:48 <EvanR-work> wvd: well that explains that ;)
12:33:53 <EvanR-work> just joking
12:33:56 <wvd> heh :P
12:34:12 <wvd> And ofcourse the most famous thingie
12:34:13 <wvd> Monads
12:34:37 <EvilMachine> hello. :) i think you are the right people for my question: i want to create something like this:
12:34:58 <c_wraith> it's sad that monads are part of many haskell descriptions.  They're not really very important for using haskell.
12:35:08 <soupdragon> they are fundamentally important
12:35:12 <EvilMachine> 1. to be able to define a program as a set of constraints.
12:35:30 <EvilMachine> 2. the contstraints are defined trough subconstraints.
12:35:38 <wvd> It just sucks that LYAH doesn't have monads yet - since I really like the writing style used.
12:35:44 <EvilMachine> 3. the base constraints are defined as tests in normal haskell
12:35:47 <EvanR-work> wvd: now you did it. another monad debate
12:36:00 <wvd> EvanR, oh. I'm sorry.
12:36:26 <EvanR-work> lets argue about Functor instead
12:36:32 <EvilMachine> result: the evaluator has nothing else to do, than limit the number of tests done, using the constrairts, and return the result set that is left.
12:36:39 <EvilMachine> is there something like this?
12:36:42 <Saizan> EvilMachine: sounds like you want to make an EDSL for constraint programming :)
12:37:04 <EvilMachine> Saizan: EDSL? what's that? I assume not an Edsel? ;)
12:37:12 <EvanR-work> embedded digital subscriber line
12:37:17 <EvilMachine> lol
12:37:23 <Saizan> EvilMachine: monadiccp is one, there are also some CHR implementations
12:37:29 <sepp2k> If I write 42 :: Double or 42 :: Float, does it really call fromRational or is that optimized away?
12:37:32 <Saizan> Embedded Domain Specific Language
12:37:33 <EvilMachine> evil damned satan's lair?
12:37:46 <EvilMachine> ah ok
12:37:52 <EvilMachine> Saizan: yes, one cas say that
12:38:05 <EvilMachine> cas=can
12:38:09 <c_wraith> sepp2k, the calculation is done at compile-time.
12:38:10 <ski> EvilMachine : .. hm, are you talking about constraints as in CLP ?
12:38:34 <EvilMachine> Saizan: i love how this (to me) crazy ideas are just another normal thing for you haskell guys. you don't even blink!
12:38:38 <EvilMachine> :D
12:39:03 <wvd> sepp2k, hey, thanks for the answer on SO :p
12:39:04 <EvilMachine> please... I am lost in acronyms. :/
12:39:06 * illissius occasionally blinks
12:39:09 <RavuAlHemio> Hi. I'd like to parallelize the computation of a list comprehension where the list looks like, in simple terms, [f(x) | x <- [0..100]]. Eventually, I'd like to take the sum of the elements of this list. Is such parallelization possible?
12:39:24 <sepp2k> c_wraith: Ah good, thanks. Is that specified by the standard or just what ghc does?
12:39:25 * ski . o O ( "Ensilation Dinotherian Strigilator Locale" )
12:39:33 <sepp2k> wvd: np
12:39:38 <EvilMachine> what is CHR? swiss rupies? what is CLP? club of lowrider programmers?
12:39:52 <EvanR-work> lol
12:39:56 <RavuAlHemio> wtf is wtf?
12:40:01 <EvanR-work> this is getting ridiculous
12:40:21 <soupdragon> @wtf
12:40:22 <lambdabot> Maybe you meant: bf ft wn
12:41:21 <ski> EvilMachine : "Constraint Handling Rules" and "Constraint Logic Programming"
12:42:05 <EvilMachine> so... wikipedia tells me that CHR = constraint handling rules. and CLP = constraint logic programming.
12:42:09 <EvilMachine> lol
12:42:11 <EvilMachine> ok
12:42:19 <Iago> RavuAlHemio, using Control.Parallel?
12:42:25 <EvilMachine> what i don't understand is, how you expected me to know this...
12:42:34 <ski> @where CHR
12:42:34 <lambdabot> I know nothing about chr.
12:42:54 <RavuAlHemio> Iago: For example.
12:42:56 <ski> @where+ CHR Constraint Handling Rules at <http://www.cs.kuleuven.be/~dtai/projects/CHR/>
12:42:57 <lambdabot> It is stored.
12:43:27 <Saizan> EvilMachine: well, EDSL is quite commonly used here, however it's perfectly fine to ask :)
12:43:43 <ski> EvilMachine : well, it sounded like you maybe already were familiar with C(L)P, and only wanted a way to it in Haskell ..
12:43:55 <wvd> Is "3 + 5" evaluated at compile time?
12:44:02 <ski> possibly
12:44:03 <EvilMachine> but hey, guys: thank you anyway. :) as I said: it's quite impressive how normal this stuff is to you.
12:44:06 <wvd> Since
12:44:07 <wvd> :t 3 + 5
12:44:09 <lambdabot> forall t. (Num t) => t
12:44:12 <wvd> :t 8
12:44:13 <lambdabot> forall t. (Num t) => t
12:44:19 <wvd> Mmh, ghci says something different.
12:44:30 <Iago> RavuAlHemio, well, parMap rnf f [1..100]
12:44:41 <EvilMachine> ski: nah. i just re-invented the concept, without knowing it actually already existed.
12:44:46 <jmcarthur> i assume nothing is normal
12:44:52 <RavuAlHemio> Iago: Thanks. :)
12:44:58 <EvilMachine> ski: damnit! i could have made millions! *millions*! ;))
12:45:01 <sepp2k> wvd: Only if you store it in a variable first.
12:45:07 <Iago> RavuAlHemio, though maybe you want a bigger chunk (parMap uses chunk=1) if f is not very computational expensive
12:45:17 <sepp2k> wvd: :t 3+5 says the same thing in ghci as in lambdabot
12:45:27 <sepp2k> @define x = 3+5
12:45:28 <wvd> sepp2k, nevermind, I misread.
12:45:47 <sepp2k> @let x = 3+5
12:45:48 <Iago> RavuAlHemio, in that case use parListChunk
12:45:49 <lambdabot>  Defined.
12:45:52 <sepp2k> :t x
12:45:53 <lambdabot>     Ambiguous occurrence `x'
12:45:53 <lambdabot>     It could refer to either `L.x', defined at <local>:1:0
12:45:53 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/L.hs:74:0-32
12:46:05 <ski> > Language.Haskell.TH.normalG Nothing
12:46:05 <lambdabot>   Not in scope: `Language.Haskell.TH.normalG'
12:46:08 <ski> @type L.x
12:46:09 <lambdabot> forall t. (Num t) => t
12:46:23 <sepp2k> No monomorphism restriction in lambdabot?
12:46:35 <RavuAlHemio> :quit
12:46:36 <ski> \o/
12:46:49 <monochrom> A person who says "hi I want to create: 1. ... constraint ... 2. ... constraint ... 3. ... constraint ...", does not guess that in "CXX", "CYY", "CZZ" etc, "C" stands for constraints. How do you expect people to believe this?
12:46:51 <Iago> RavuAlHemio, I don't know what is the current status of DPH but I think that it will be a best choice for what do you want
12:47:13 <RavuAlHemio> Iago: Yeah... "./darcs-all --dph get" doesn't work anymore, though.
12:47:30 <soupdragon> lol monochrom
12:47:41 <soupdragon> hey I am bored what should I do?
12:47:51 <monochrom> add more constraints
12:48:03 <EvilMachine> Saizan: so to rephrase in local terminology: my idea was to make an EDSL for constraint programming in haskell, that allows you to define music trough constraints, so that after compilation and execution, it renders music according to your wishes. sounds cool, no? :D
12:48:36 <Saizan> EvilMachine: it does :)
12:48:43 <jmcarthur> to me as well
12:48:55 <EvilMachine> monochrom: i am neither english, nor is the letter C ever exclusively locked to the word "constraint" in my head. ^^
12:48:56 <Saizan> EvilMachine: i'm not sure which kinds of constraints you'd use though
12:48:57 <ski> (EvilMachine : btw, you're aware of Haskore, yes ?)
12:49:11 <monochrom> I am not english either.
12:49:12 <gwern> > length [1..20]
12:49:13 <lambdabot>   20
12:49:24 <EvilMachine> Saizan: I've got a pretty good idea about that, as that's what i started out with.
12:49:25 <ski> EvilMachine : well, the only other possible choice is "Continuation" ..
12:50:44 <EvilMachine> Saizan: rhythmic properties, groove properties, tonal range and musical scale, volume patterns, etc
12:51:59 <maltem> EvilMachine, somwhere on the the web there's a guy who generated music by specifiying the general form of the music piece, and giving real music as stochastic input. May be interesting to you. There was a piece to sound like Bach, another like Chopin etc., and they really did :)
12:52:19 <EvilMachine> ski: yes. but waaay too limited for my ideas. i want to throw out all the traditional things from normal music, and use the generic rules that are the reason for those traditional things, so that i am not limited in freedom.
12:52:50 <ski> ok (just checking)
12:52:55 <soupdragon> hey what's a fun short ahskell projec tI coul ddo?
12:53:02 <EvilMachine> ski: lol. Cascade, Combinator, Connector, Calculation, etc, etc, etc. :)
12:53:22 <maltem> soupdragon,  spellchecker? :p
12:53:39 <EvilMachine> maltem: guess what gave me the idea to try this in the first place? :D
12:53:48 * ski tries to recall an initialism of something starting with `Combinator' ..
12:54:07 <maltem> EvilMachine, heh. Do you have the link ready? I forgot to bookmark it
12:55:00 <EvilMachine> ski: considering it can be one that you don't know... well, how about Combinator Lambda Patterns? Combinator Linked Polylists? I could name stuff all day. ;)
12:55:39 <EvilMachine> maltem: sorry. long time ago. i just opened an old half-done project, and wanted to get into doing the other half.
12:56:06 <EvilMachine> maltem: and this idea was my high-level part of it.
12:56:37 <EvilMachine> maltem: well, actually i didn't imagine that it already existed and was quite well-known. :/
12:56:48 <Iago> RavuAlHemio, uhmm well, use control-parallel so... seems that the wiki page is out of date.
12:56:56 <RavuAlHemio> Okay.
12:57:29 <ski> EvilMachine : what is `Combinator Lambda Patterns' ? .. something like `b (>>= k) Left = Left' instead of `Left e >>= k = Left e' ?
12:57:48 <EvilMachine> ski: noo idea. just made it up on the spot. :D
12:58:28 <EvilMachine> ski: just wait. tomorrow people will wonder why newbies don't know what it means. ;)
12:59:01 * ski idly wonders who wondered that today ..
12:59:20 <EvilMachine> guys, you seriously rule! you all! :D
12:59:59 <maltem> Rather you'll get blogposts about how nasty the Haskell people are because the expect you to know and understand Combinator Lambda Patterns
13:00:06 <EvilMachine> i just wonder where you got all that knowledge from? i mean you don't learn that in CS where I come from.
13:00:34 <EvilMachine> maltem: not from me.
13:01:13 <EvilMachine> maltem: i got enough hate for PHP and a certain browser for the next decade. (yep, was forced to "program" in it, if you can call it that)
13:02:00 * ksf wants -XAssumeShowInstance. Now.
13:02:12 <ski> what would it do ?
13:02:48 <mux> if that is supposed to mean "automatically derive Show for every type", please, no
13:02:52 <ksf> assume that all contexts include Show instances where necessary for unification
13:03:06 <ksf> it's a debug thingie.
13:03:08 <mux> ah
13:03:25 <sanders> Anyone know if anyone is working on Haskell bindings for Googles V8
13:03:56 <Saizan> ksf: you also need to conjure up the corresponding dictionaries though, or would you accept a binary dump of the internal representation?:)
13:03:56 <lispy> sanders: that would be pretty cool
13:04:14 <EvilMachine> mux: i thought maybe I write a very evil library that allows casting from every type known in haskell to every other type via evil PHP-like assumptions and interpretations. muhahahahaaa!
13:04:23 <lispy> sanders: I don't know of a project like that and I can't commit any time :(
13:04:36 * mux cowers in fear
13:04:51 <lispy> sanders: What sorts of uses do you have in mind?  I see that now that gtk2hs is fully on hackage we have webkit bindings in Haskell
13:05:18 <lispy> sanders: V8 + webkit = browser glued together with Haskell?
13:05:24 * EvilMachine offer mux a tasty curry.
13:05:28 <sanders> lispy: Javascript is sometimes a good general script language for a large application
13:05:29 <mux> well that's not really webkit, but webkit-gtk, not quite the same
13:05:35 <ksf> Saizan, it could even error out
13:05:36 <sanders> like for example a database
13:05:52 <ksf> I just don't want to scatter Show contexts all over my source merely to print a value
13:06:23 <EvilMachine> sanders: i agree. you can do nice functional programming in JS, if you know how.
13:06:32 <mux> I understand how irritating it can be to have to walk all your type hierarchy adding Show derivations
13:06:58 <EvilMachine> ksf: put them in a different file or even directory?
13:07:09 <Saizan> ksf: if it always errors out that's not very useful, if you mean that it should do a dynamic check and lookup a Show instance among all those imported in your program, then you'd have to change a lot to implement that
13:07:12 <ksf> contexts, not instances.
13:07:21 <EvilMachine> ksf: or even make a generator for them?
13:07:45 <EvilMachine> ah ok
13:08:09 <ksf> ...and I still can't figure out why my monad breaks after the first bind.
13:08:31 <EvilMachine> ha, i have another one: CLP = context lookup program *evilgrin*
13:08:35 <ksf> there's a nothing here where there should be a just
13:08:41 <EvilMachine> ok, i'm off. sorry for OT
13:08:55 <EvilMachine> @all: thanks again!
13:08:55 <lambdabot> Unknown command, try @list
13:09:00 <EvilMachine> \@all: thanks again!
13:10:53 <monochrom> (just drop the @)
13:11:21 <monochrom> (I'm really glad lambdabot uses @ so we can tell people to not use twitter convention)
13:12:12 <ksf> ha! got it.
13:12:22 <sepp2k> To be fair, twitter didn't invent that convention. People used @ before twitter.
13:12:34 <gwern> they did?
13:12:43 <glguy> There is no need to be fair when discussing Twitter
13:12:44 <ksf> wait this test proves that it should work.
13:12:46 <gwern> I don't remember ever see it...
13:13:03 <pikhq> sepp2k: To be cruel, only idiots used said convention.
13:13:04 <pikhq> :)
13:13:35 * gwern ponders. if I've shown something to be consistently wrong or right, is that better than being inconsistently wrong?
13:13:41 <gwern> I feel lost in my own phrasings
13:14:21 <monochrom> If you are consistently wrong, you can just add a not-gate to correct yourself.
13:14:57 <monochrom> Similarly, in those logic puzzles, a person who consistently lies is not a problem.
13:14:57 <gwern> only if we were dealing with booleans
13:15:09 <gwern> a not gate doesn't help much with real-valued answers :)
13:15:31 <gwern> 'oh, it's 'not' .333...; that's very helpful, it leaves an infinity of possible answers'
13:15:58 <monochrom> This is to punish you for using all of the real numbers.
13:16:37 * BMeph would like to point out in fairness, that everyone who uses email is not an idiot. Not completely...
13:17:10 <gwern> but if we use a limited set of probabilities, which isn't equivalent to the 0-1 range, we open ourselves up to errors. oh well
13:17:49 <monochrom> better than consistently wrong almost everywhere
13:18:49 <dpratt71> trying to install a package (unix) via cabal; an error occurs that references config.log, but cabal seems to delete it after the install fails; does that make sense?
13:19:10 <dcoutts> dpratt71: right
13:19:16 * ski idly wonders whether it is possible to check whether functions in `(Nat -> Bool) -> Bool' are "almost everywhere constantly `False'"
13:19:34 <dcoutts> dpratt71: if you're not working with a locally unpacked package then cabal builds in a temp dir
13:19:48 <dcoutts> dpratt71: if you're trying to diagnose build problems then cabal unpack first
13:21:03 <dpratt71> dcoutts: ever helpful you are with this stuff, thanks
13:23:16 <lispy> sanders: you should do your scripting in the type system if you want a dynamically typed scripting language ;)
13:23:29 <ksf> now I'd like to hack all memptys in my source to include file and line number in their show output.
13:23:48 <lispy> ksf: CPP?
13:24:24 <sanders> lispy: well we would like to expose an interface for non haskell developers
13:24:34 <lispy> #define mempty (trace "mempty at __LINE__:__FILE__" mempty)
13:24:43 <lispy> sanders: I was teasing :)
13:25:09 <lispy> ?hoogle trace
13:25:09 <lambdabot> Debug.Trace trace :: String -> a -> a
13:25:10 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
13:25:10 <lambdabot> module Debug.Trace
13:25:15 <Eduardo_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25702#a25706
13:25:38 <ksf> error: detected recursion whilst expanding macro "mempty"
13:25:41 <Eduardo_> moved that "filter `notElem` ..." to a function
13:25:52 <Eduardo_> and now it won't work
13:26:01 * ski . o O ( `{-# RULES mempty = trace "mempty at __LINE__:__FILE__" mempty #-}' )
13:26:03 <Eduardo_> ._.
13:26:21 <lispy> ksf: hmm...my syntax may have been off, but I think CPP can do tihs
13:26:47 <ksf> erm
13:27:17 <ksf> well yes it doesn't replace things before its definition, so I can do memtpy' = mempty and then use that definition
13:27:28 <sepp2k> Eduardo_: The expressions in a do-block need to have type IO
13:27:38 <ksf> problem being, ghc's cpp doesn't know about __LINE__ and __FILE__
13:27:46 <sepp2k> print $ filter ... does have type IO, filter .... does not.
13:28:07 <sepp2k> Ehrm, they need to have type m a for some monad m and type a.
13:28:15 <ski> Eduardo_ : `main = print =<< getVisible', and wrap the final comman in `getVisible' in `return'
13:28:20 <lispy> ksf: darcs.net/src/impossible.h
13:28:23 <sepp2k> Of course it doesn't have to be IO, but the type of main does need to be IO
13:28:26 <Eduardo_> ok
13:28:31 <lispy> ksf: that does exactly what I had in mind, and already works :)
13:28:33 <Eduardo_> let me see
13:28:57 <lispy> ksf: IIRC, it uses the same CPP as gcc
13:29:29 <Eduardo_> ski and sepp2k : thanks
13:29:37 <sepp2k> Eduardo_: What you probably want to do is use return in getVisible and then vis <- getVisible; print vis  in main
13:29:55 <sepp2k> Or print <$> getVisible  or something to that effect.
13:30:03 <Eduardo_> but I did not understood why I need that
13:30:26 <sepp2k> Do you know how do-notation is expanded?
13:30:49 <Eduardo_> >>=
13:31:07 <dpratt71> perhaps this comment will make my lack of Haskell experience evident, but I often question whether "do notation" is worth it
13:31:14 <ksf> oh it's the quotes.
13:31:28 <sepp2k> Eduardo_:  Right. The type of >>= is m a -> (a -> m b) -> m b
13:31:30 <mux> dpratt71: actually, people have been debating this, it ain't a stupid question
13:31:35 <ksf> now that's evil.
13:31:47 <sepp2k> So the rhs of >>= needs to have type  a -> m b
13:31:50 * ski . o O ( `imp_funny_name' ? )
13:32:08 <dpratt71> probably too late to go back now, in any case
13:32:25 <sepp2k> Eduardo_: This means that a statement in do needs to have type m b.
13:32:45 <sepp2k> In this case m=IO, so each statement in the do-block needs type IO something.
13:32:53 <lispy> ski: to avoid shadowing any reasonable names
13:33:09 <sepp2k> The result of filter is not IO something, so you need return, which "wraps" the value in IO
13:33:20 <ski> lispy : but, why not `($ (__LINE__,....))' ?
13:33:45 <Eduardo_> got it sepp2k
13:33:46 <lispy> ski: good question, the author probably didn't think of that.
13:33:47 <Eduardo_> thanks :)
13:34:52 <ski> @pl runCont . return
13:34:52 <lambdabot> runCont . return
13:34:54 <mux> dpratt71: it turns out that in many cases, the Applicative syntax can be a lot more nicer than the do-notation
13:34:55 <ski> .. bah
13:35:18 <glguy> dcoutts: you about?
13:35:19 <mux> dpratt71: or at least, a lot more functional
13:35:25 <dcoutts> glguy: hia
13:38:32 <dpratt71> mux: when you say 'Applicative syntax', I assume you are referring to using the combinators from the Applicative type class?
13:38:44 <mux> yeah
13:39:00 <dpratt71> how does that compare to what is rendered by @undo?
13:39:16 <danharaj> is <*> left associative or right?
13:39:34 <roconnor> danharaj: it associates the same way whitespace does
13:39:54 <mux> dpratt71: I cannot say in general, it depends on the particular cases
13:40:27 <aristid> danharaj: infixl 4 <*>
13:40:37 <danharaj> aristid: thanks
13:41:30 <c0sine> would this be the spot the ask about gtk2hs?
13:41:46 <c0sine> i see there is some trouble getting it to work with ghc 6.12.1
13:42:15 <c0sine> er, 6.12.2
13:42:34 <danharaj> In some recent version, I forgot which, I think someone accidentally the FFI.
13:42:45 <danharaj> Some obscure part that gtk2hs uses.
13:42:52 <mux> hah
13:42:54 <c0sine> interesting
13:42:59 <thoughtpolice> that was a while ago
13:43:08 <mux> this is fixed in 6.12.3rc1
13:43:21 <c0sine> oh I need to upgrade then
13:43:24 <c0sine> thanks for the info!
13:43:25 <thoughtpolice> oh so there is a bug with 6.12.2?
13:43:30 <thoughtpolice> missed my radar
13:43:31 <mux> http://hackage.haskell.org/trac/ghc/ticket/4038
13:43:33 <dpratt71> supposing one has executed "cabal unpack xyz", how might one tell cabal to 'install' the package from that directory?
13:43:40 <mux> see the above ticket
13:43:41 <dcoutts> dpratt71: cabal install
13:44:48 <dpratt71> dcoutts: cabal install xyz? i.e. will it source it from where it unpacked it? or are you saying "cabal install" from the directory?
13:45:17 <danharaj> :t pure (.)
13:45:17 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 ((a -> b) -> f a -> f b)
13:45:30 <applicative> dpratt71, just cabal install don't name the program
13:45:37 <c0sine> wait is that...
13:45:38 <dcoutts> dpratt71: "cabal install" is for the package in the current directory
13:45:46 <dpratt71> ok, thanks
13:45:48 <c0sine> :t False
13:45:49 <lambdabot> Bool
13:45:51 <c0sine> whoa
13:45:54 <c0sine> nice
13:47:36 <danharaj> :t (.)
13:47:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:47:46 <danharaj> oh, (.) is part of the functor definition?
13:48:24 <danharaj> waitaminute
13:48:27 <danharaj> :t fmap
13:48:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:49:00 <dolio> @type flip
13:49:01 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:49:46 <danharaj> hey waitaminute what is * -> *? The kind of type constructors?
13:49:55 <ksf> yep
13:50:01 <ksf> or rather their kind
13:50:10 <ksf> which is what you said
13:50:36 <danharaj> so to be really verbose (a :: *) in that definition up there
13:50:45 <danharaj> I didn't know that ghc could handle higher kinds.
13:51:00 <ksf> it doesn't do sorts, and kinds are untyped
13:51:20 <ksf> ...with the excetpion of functionally-valued ones and the distinction between built-in primitives and user types.
13:51:37 <danharaj> There ought to be a tutorial on type theory in the context of Haskell
13:51:49 <ksf> there's spj's papers
13:51:51 <danharaj> in particular GHC's extensions.
13:52:04 <danharaj> are they accessible and elementary?
13:52:21 <ksf> some of them with a significant number of greek symbols, some with a sane number of them.
13:53:04 <ksf> that is, there should be opaque sections in about every paper, and most of them are actually really readable.
13:56:12 <elliottcable> ahhahahh no way. no way no way no way. http://bit.ly/bLKcfx
13:57:11 <danharaj> heh
13:57:17 <ksf> oh. copy+paste programming.
13:57:20 <monochrom> It is https://review.source.android.com/#patch,sidebyside,14699,1,libc/memset.c
13:57:31 <ksf> that wouldn't have happened with a compiler with reliable inlining.
13:58:06 <jlouis> Warning, unused variable v!
13:58:11 <monochrom> bit.ly uses AOLServer?!
13:58:19 <thoughtpolice> ksf: why not?
13:58:32 <jlouis> I wonder why the C-compiler is not screaming its ass all over that one
13:58:43 <xerox> elliottcable: hehe
13:58:48 <monochrom> someone turned off screaming
13:59:00 * ksf guestimates that memset is a copy of wait is there a c function to set memory to 0?
13:59:02 <danharaj> all warnings should be default on compilers :|
13:59:16 <danharaj> you should have to specify a flag to shoot yourself in the foot
13:59:20 <monochrom> --no-ansi -Wnone -f-just-obey
13:59:26 <pikhq> ksf: memset. :)
13:59:34 <danharaj> --what-are-you-my-mother
13:59:37 <elliottcable> --fuck-C-I-write--*my*-language!
13:59:44 <elliottcable> --oops
13:59:48 <aledge> danharaj, hahaha
14:00:14 <monochrom> people do specify flags, you know
14:00:17 <arw> nah, thats mostly not a bug, memset is always used with v=0 anyways *ducks&hides*
14:00:19 <danharaj> if you use that flag you would get a compilation error
14:00:30 <danharaj> "No, I am your father."
14:00:35 <monochrom> hahahahah
14:00:36 <elliottcable> oh shit
14:00:38 <elliottcable> gcc is my father
14:00:40 * elliottcable gasps
14:00:44 <danharaj> and then it cuts off your  hand
14:00:53 <c0sine> am i insane for learning haskell as my first language?
14:01:02 <c0sine> i've been going over types again and again
14:01:08 <monochrom> not insane
14:01:08 <c0sine> cause it seems like that is the key to it all
14:01:08 <danharaj> no.
14:01:15 <danharaj> it is.
14:01:18 <mauke> fun is the key
14:01:25 <c0sine> i want to use haskell for bioinformatics work at some point
14:01:35 <altmattr> coding is the key
14:01:37 <danharaj> You'll have to learn how to be a good programmer immediately.
14:01:45 <c0sine> yeah that's what it feels like
14:01:51 <c0sine> it forces you to sort of debug up front
14:01:54 <altmattr> I have bee caught up trying to understand things before I use them
14:01:58 <danharaj> Instead of learning 'how to program' in a looser language and then relearning how to do it properly.
14:02:02 <altmattr> best just to jump in
14:02:07 <monochrom> anyway, because of the ridiculous convenience of make, it doesn't matter that the flags are 1TB long, people just store them in the make file once.
14:02:08 <jlouis> I learned something interesting about combinatorrent today btw. At the lowest level, we allocate 1.23 times as much data as we download
14:02:30 <monochrom> (oh this is why programmers want 1PB disks)
14:02:36 <danharaj> I hate make.
14:02:36 <jlouis> Most of those 23% is createAndTrim being trimmed
14:02:44 <danharaj> My favorite part of ghc is --make
14:02:58 <monochrom> same story with cabal, actually
14:03:18 <mauke> c0sine: are types hard?
14:03:27 <c0sine> no it's the vocabulary mostly
14:03:30 <c0sine> if that makes sense
14:03:31 <jlouis> it totally changes the optimization efforts
14:03:43 <mauke> c0sine: can you give me an example?
14:03:47 <monochrom> The only way you can encourage programmers to not use unsafe flags is to scratch all "build environments" and suppress anyone who wants to create one.
14:04:22 <c0sine> not really bud
14:04:42 <c0sine> i'm not really literate enough to be here to be honest
14:05:03 <ksf> oh there's enough americans here so don't worry about literacy.
14:05:08 <danharaj> heh
14:05:34 <mauke> the other day we had someone in #perl who wanted to "illiterate over an array"
14:05:46 <danharaj> ill iterate
14:06:04 <glguy> mauke: Was he successful?
14:06:23 <mauke> hard to tell
14:06:35 <c0sine> better get back to plugging away at it
14:06:38 <c0sine> take it easy
14:07:27 <danharaj> IMO tutorials don't focus enough on the type system.
14:07:29 <mauke> Yukkuri shiteitte ne‼
14:07:34 <danharaj> I should write one
14:07:44 <danharaj> Also get your giant robot language out of here >:|
14:08:13 <danharaj> (<3)
14:24:34 <ezyang> What indentation conventions do you use when you have a do with a where clause?
14:25:06 * glguy typically indents two spaces in from the name on a newline
14:25:41 <EvanR-work> uhg do ... where
14:25:57 <ezyang> EvanR-work: Am I doing it rong? ;-)
14:26:07 <EvanR-work> it hurts me each time i want to do it
14:26:11 <c_wraith> I go out of my way to use lets when a do block is involved
14:26:30 <EvanR-work> my reaction is to always use let\n  .....\n  in do\n
14:26:38 <EvanR-work> then that looks horrible and i refactor
14:27:45 <EvanR-work> = mydoblock where
14:27:48 <EvanR-work>   mydoblock =
14:27:51 <EvanR-work>   mywherestuff =
14:29:58 <BMeph> Why don't we use relative ordering for operator precedence, and make a tree (or a list, if a tree is too complicated for an efficient implementation) of ops, instead of the small  selection of ints for it?
14:30:24 <jmcarthur> BMeph: we could at least use rationals ;)
14:30:25 <ezyang> BMeph: Editing that tree seems nontrivial.
14:31:17 <danharaj> I think it is sketchy to allow global declarations of precedence for library defined operators anyway.
14:31:26 <danharaj> But it's just so convenient.
14:31:42 <ezyang> I hold that infix operators were a good idea.
14:32:09 <danharaj> ezyang, sure, but maybe by default they should have no associativity or precedence, and you have to define that locally in your module that uses them.
14:33:36 <ezyang> Maybe.
14:33:50 <ezyang> I might suggest that, except for extremely well known operators, changing the fixity should be outlawed
14:34:10 <ezyang> Because it's nonlocal info that seriously changes the meaning of a program.
14:35:30 <BMeph> jmcarthur: To me, using Rationals seems to be a kludge for using a list. Rationals' only appeal that I see is a cheap way to insert ops into the rankings. Clearly a step in the right direction, but why not just do what we "really" want, and just make it a list?
14:36:00 <jmcarthur> i'm not really making an argument for or against
14:38:41 <BMeph> That's another thing - we shouild be able to specify associativity, commutativity, idempotence, et al., somehow. Most likely, in the type system, although it seems like a special case if it goes there...
14:40:21 <danharaj> You would need some sort of dependent typing/proving to safely declare those.
14:42:09 <ski> BMeph : i've wanted to play with arbitrary partial orders for precedences for a while ..
14:42:41 <ski> (using rationals would only be slightly better than using BASIC, btw)
14:42:55 <aavogt> rock-paper-scissors
14:42:58 <jmcarthur> BMeph: i've been using type classes to express such properties
14:43:03 <danderson> aavogt: you forgot lizard-spock
14:44:02 <aavogt> though a partial order means you can't compare everything... not that you get cycles like that, right?
14:44:35 <aavogt> a > b > c > a looks like it breaks quite a few expectations
14:44:57 <ski> BMeph : re the latter, i've been thinking AST up-to associative operations would be easiest to start with
14:45:13 <niteria> i have a noobish question, what is a proper identation before where?
14:45:15 <copumpkin> aavogt: you still need transitivity
14:45:20 <copumpkin> aavogt: that wouldn't be a partial order
14:45:25 <aavogt> says who?
14:45:33 <ski> says mathematicians
14:45:35 <copumpkin> he was talking about arbitrary partial orders
14:45:38 <niteria> tabs? spaces? how many?
14:45:41 <copumpkin> they have a formal definition :P
14:45:59 <aavogt> is there a name for the structure formed by rock paper and scissors?
14:46:07 <ski> partial orders require reflexivity, anti-symmetry, and transitivity
14:46:26 <tromp> a 3 cycle
14:46:44 <ski> (or swap reflexivity and anti-symmetry out for irreflexivity and asymmetry, if you're doing strict partial orders)
14:46:46 <aavogt> a generalization of the unicycle
14:47:28 <ski> (aavogt : i've wanted to read about such "cyclic orders", but i haven't found any relevant info)
14:48:17 <danharaj> ski: It's basically graph theory.
14:48:36 <ski> .. btw, another wild generalization on the precedence front is to allow an infix operator to have difference precedences at its left and right side
14:48:38 <copumpkin> tromp: a tricycle?
14:48:56 <xerox> aavogt: a commutative but non-associative binary operation
14:49:04 <ski> danharaj : what would be a suitable weakening of transitivity, then ?
14:49:23 <ski> xerox : a mobile ?
14:49:23 <copumpkin> just turn it off
14:49:27 <copumpkin> talk about a relation :P
14:49:34 <xerox> ski: like.. a phone?
14:49:38 <copumpkin> {(a, b), (b, c), (c, a)}
14:49:40 <copumpkin> there
14:49:43 <ski> copumpkin : well, that's boring :)
14:50:05 <niteria> runghc didnt like 4 spaces before where
14:50:06 <xerox> it's fun!
14:50:09 * copumpkin is such a powerful mathematician that he just represented rock-paper-scissors
14:51:02 <ski> xerox : <http://en.wikipedia.org/wiki/Mobile_(sculpture)>
14:51:37 <xerox> ski: that is a good name :D
14:53:34 <ddarius> lpsmith: I think the logic programming community should be moving toward and developing logic languages with more logical content such as lambdaProlog.
14:53:50 <copumpkin> we need illogical languages
14:53:59 <danharaj> Python?
14:54:00 <soupdragon> ddarius what about CHR
14:54:16 <soupdragon> isn't it basically the pinnacle of logic programming
14:54:27 <RichardBarrell> copumpkin: Prolog seems perfectly illogical to me.
14:54:45 <ddarius> soupdragon: Constraint logic programming is an orthogonal dimension that the logic community has been pretty good about developing.
14:55:10 <RichardBarrell> copumpkin: plenty of things that damn well ought to work damn well don't because they turn out to take longer than the age of the universe to computer. :)
14:55:19 <copumpkin> RichardBarrell: terrible!
14:55:35 <ski> (hrm, a few links re mobiles : <http://en.wikipedia.org/wiki/Example_of_a_commutative_non-associative_magma>, <http://unspecified.wordpress.com/2008/12/28/commutative-but-not-associative/>, <http://www.cs.chalmers.se/Cs/Grundutb/Kurser/e4fun/FPLectures/Lecture02A.hs>)
14:56:11 <Eduardo_> > let f = (flip filter) "Hello" in f (/= 'o')
14:56:13 <lambdabot>   "Hell"
14:56:45 <Eduardo_> let f = (flip filter) =<< getDirectoryContents ...
14:56:48 * ski has visited Hell ..
14:56:56 <Eduardo_> lol
14:57:05 <Eduardo_> I can't use monads with currying?
14:57:06 * cozachk wishes right now that haskell had a nice full numeric tower like scheme :-( 
14:57:25 <ski> Eduardo_ : you want `liftM'; check the types !
14:57:38 <Eduardo_> ski: thanks
14:57:44 <aristid> :t liftM
14:57:45 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:57:47 <ddarius> Haskell's numeric system is inspired in part by Scheme's and Common Lisp's.
14:58:04 <soupdragon> (which is probably why it sucks so hard ^^)
14:58:20 <cozachk> how do I make Complex RealFloat an instance of Ord
14:58:30 <ski> Eduardo_ : possibly you want `.' as well, though ..
14:58:45 <xerox> cozachk: nooo
14:58:47 <ski> cozachk : .. er, you shouldn't ?!
14:59:39 <Eduardo_> ski: how I can do that with `.'
14:59:51 <Eduardo_> õ.o
14:59:55 <ski> (Eduardo_ : .. which might amount to using `<=<', instead .. i'm not sure)
15:00:10 <xerox> i > 0 would mean i^2 > 0^2 that is -1 > 0, but also i/i > 0/i that is 1 > 0  :-(
15:00:33 <cozachk> i really dont want too, but i have this Ord requirement that creeps into my polynomial multiplication because of using sortBy and groupBy on tuples of (Num a)=>(Integer,a)
15:00:45 <ski> Eduardo_ : what is the (intended) type of `flip filter', in your particular case ?
15:01:09 <xerox> cozachk: why don't you just say type Polynomial a = [a]
15:01:39 <ski> xerox : well, what if the coefficients are complices ..
15:02:04 <Philonous> cozachk: instance (Ord a) => Ord (Complex a) where compare (xr :+ xi) (yr :+ yi) = <...>
15:02:04 <cozachk> yes thats my problem , im trying to computer eigenvalues
15:02:22 <xerox> Philonous: there is no sensible >...<
15:02:35 <cozachk> magnitude is sensible
15:02:48 <djp> whoh ! holy haskell mania!
15:02:51 <xerox> as you wish
15:02:54 <Philonous> xerox: So what? Since when do classes/instances have to make sense?
15:03:08 <Eduardo_> ski: just because by this way I can pass a shorter name (the list) and then on other line the lambda
15:03:14 <copumpkin> Philonous: const GT
15:03:16 <djp> quick question; is there an easy haskell way to convert atom xml feeds to html ?
15:03:22 <xerox> Philonous: are you serious
15:04:35 <ski> Eduardo_ : you could start with the more direct version (if you have one working) , and rewrite that step-by-step
15:06:35 <Eduardo_> ski: I got one working
15:06:39 <Eduardo_> but the only way is to
15:06:47 <Philonous> To prevent cozachk from writing this instance when he really wishes to do so would be morally presumptous. I only provided the syntax. And I hope I will never have to work with his code :>
15:06:54 <Eduardo_> use the `<-'
15:07:23 <Eduardo_> and then `(flip map) var'
15:07:36 <scree> xerox: I'm sure this has come up before: any well-ordering will do
15:07:41 <Eduardo_> I would like to do it without having to use `<-'
15:07:58 <xerox> scree: not wise computationally
15:08:57 <scree> xerox: since when do instances have to be computable?
15:08:58 <ski> (hm, can one create a weak counter-example to every set having a well-ordering ?)
15:09:23 <ski> (scree : since when you actually try to run the code on a computer ..)
15:09:25 <xerox> ski: R
15:09:58 <scree> ski: every computable set is computationally well-orderable
15:10:12 <ski> yes, i suspect if it's possible, the reals would probably work .. but i'm not sure whether it is possible
15:10:38 <ski> scree : where "computable set" means exactly what ?
15:11:06 <scree> ski: good question
15:11:08 <xerox> ski: sorry I see what you mean now, not sure, I'll think about it though
15:11:12 <ski> effectively a detachable subset of naturals ?
15:11:55 <scree> I guess so, yes
15:12:03 * ski doesn't see how to computationally derive a well-ordering for a given set `A' (which we know nothing more about)
15:12:40 <scree> you want a program that takes some bits and returns either nothing or some bits that represent an element of the set, right?
15:12:41 <ski> (just like i don't see how to prove intuitionistically `A \/ Not A' for a given proposition `A' (which we know nothing more about))
15:13:08 <ski> (.. and in fact, in this latter case, one can construct counter-models)
15:13:16 <cozachk> Philonous, now it compiles but i get a runtime exception :-D now that is progress
15:13:19 <scree> scree: so we're dealing with computable partial functions N -> N
15:13:51 <scree> scree: a total function N -> N, which takes the first defined value, then the second &c., is also computable
15:14:20 <ski> scree : i was suspecting you were talking about decidable or semi-decidable predicates over naturals .. but i would rather be thinking of arbitrary sets
15:15:08 <ski> scree : i don't see that (btw, you're talking to yourself ..)
15:15:15 <scree> ski: how would you even talk about computing orderings on infinite data
15:15:16 <xerox> ski: actually, R is perfect
15:15:19 <dolio> dolio: What's going on, dolio?
15:15:48 <cozachk>  /msg zachk hey its me , yourself ya know> ?
15:15:49 <xerox> ski: or if you want {1,2,3} with < = {(1,2),(2,3)}
15:15:50 <ski> scree : exactly. i don't see how one can do that
15:16:18 <ski> xerox : i'm not following what you're going for
15:16:22 <xerox> the counterexample
15:16:50 <ski> how is that a weak(/Brouwerian) counter-example ?
15:17:17 <xerox> not sure what weak means here
15:19:30 <xerox> good night
15:24:52 <kuribas> How can I install documentation using cabal?
15:25:01 <mux> how do you guys like my algorithm to enumerate non-empty partitions into k subsets? I don't like it much. http://paste.lisp.org/display/100482
15:25:46 <dcoutts> kuribas: see cabal install --help
15:25:59 <mux> I feel like there should be at least a more elegant and/or simpler definition for dist
15:26:25 <kuribas> dcoutts: thanks.
15:27:32 <cozachk> mux: should the return value of kparts be [[a]] not [[[a]]]
15:27:38 <cozachk> shouldnt*
15:27:45 <mux> cozachk: nope, the type is correct
15:28:03 <mux> you want a list of partitions, and each partition splits the input space into k lists
15:28:11 <cozachk> oh ok
15:28:37 <mux> (yes, I know, this screams "project euler")
15:29:18 <ski> @tell see <http://www.illc.uva.nl/~seop/entries/brouwer/weakcounterex.html>, specifically replacing `alpha' with the characteristic function of any given (decidable) predicate over naturals. we have no reason to expect to being able to decide whether `alpha' is constantly zero for arbitrary decidable predicates. this is weak/Brouwerian counter-examples
15:29:19 <lambdabot> Consider it noted.
15:29:46 <ski> erm
15:29:51 <ski> @tell xerox see <http://www.illc.uva.nl/~seop/entries/brouwer/weakcounterex.html>, specifically replacing `alpha' with the characteristic function of any given (decidable) predicate over naturals. we have no reason to expect to being able to decide whether `alpha' is constantly zero for arbitrary decidable predicates. this is weak/Brouwerian counter-examples
15:29:52 <lambdabot> Consider it noted.
15:30:08 <roconnor> > let kparts k xs = zipWith (\a b -> a:kparts (k-1) b) (inits xs) (tails xs) in kparts 2 [1..4]
15:30:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:30:47 <mux> if you actually achieve defining this function in a one-liner with lambdabot, I hang myself right here right now
15:31:02 <mux> that is, I don't think (hope?) you can.
15:32:07 <Botje> define a function that is basically kparts 2, then use it as many times as you need to create kparts
15:32:10 <mux> (I actually hope you can, but there would be much less incentive to try it if I said that :D)
15:32:54 <soupdragon> what's a fun haskell challenge I could try out
15:32:55 <soupdragon> ?
15:33:02 <mux> Botje: not sure what you mean here, but you should know that most naive approaches I took resulted in incorrect functions, that is, functions that would generate the same solutions many times
15:33:07 <roconnor> soupdragon: ICFP 2006 contest
15:33:42 <Botje> hmm, fair enough
15:34:16 <mux> Botje: this algorithm translates rather precisely the recurrence relation of stirling numbers of the second kind (which count the ways to do such partitions)
15:35:18 <mux> ie, S(n,k) = k*S(n-1,k) + S(n-1,k-1)
15:36:03 <soupdragon> s n k = k*s (n-1) k + s (n-1) (k-1) -- for the haskell impaired
15:36:21 <mux> hah, sorry about that :-P
15:37:33 <see> hej
15:37:34 <lambdabot> see: You have 1 new message. '/msg lambdabot @messages' to read it.
15:37:41 <sm> cool.. I just made cabal-install totally happier by blowing away ~/.ghc and re-cabal installing something dependy
15:37:43 <roconnor> > let kparts 1 xs = [[xs]]; kparts k xs = concat . init . tail $ zipWith (\a b -> a:kparts (k-1) b) (inits xs) (tails xs) in kparts 2 [1..4]
15:37:44 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:37:52 <roconnor> > let kparts 1 xs = [[xs]]; kparts k xs = concat . init . tail $ zipWith (\a b -> map (a:) $ kparts (k-1) b) (inits xs) (tails xs) in kparts 2 [1..4]
15:37:54 <lambdabot>   [[[1],[2,3,4]],[[1,2],[3,4]],[[1,2,3],[4]]]
15:38:02 <roconnor> > let kparts 1 xs = [[xs]]; kparts k xs = concat . init . tail $ zipWith (\a b -> map (a:) $ kparts (k-1) b) (inits xs) (tails xs) in kparts 3 [1..4]
15:38:03 <lambdabot>   [[[1],[2],[3,4]],[[1],[2,3],[4]],[[1,2],[3],[4]]]
15:38:09 <roconnor> > let kparts 1 xs = [[xs]]; kparts k xs = concat . init . tail $ zipWith (\a b -> map (a:) $ kparts (k-1) b) (inits xs) (tails xs) in kparts 4 [1..4]
15:38:10 <lambdabot>   [[[1],[2],[3],[4]]]
15:38:13 <roconnor> > let kparts 1 xs = [[xs]]; kparts k xs = concat . init . tail $ zipWith (\a b -> map (a:) $ kparts (k-1) b) (inits xs) (tails xs) in kparts 5 [1..4]
15:38:14 <lambdabot>   []
15:38:38 <mux> roconoor: that's wrong :-)
15:38:45 <mux> err, roconnor
15:39:10 <roconnor> mux: perhaps I don't understand the specification
15:39:16 <mux> your solution for kparts 2 [1,2,3,4] misses lots of solutions
15:39:19 <mux> it should return this:
15:39:22 <mux> [[[1,2,3],[4]],[[2,3],[1,4]],[[1,3],[2,4]],[[3],[1,2,4]],[[1,2],[3,4]],[[2],[1,3,4]],[[1],[2,3,4]]]
15:39:35 <roconnor> mux: that isn't order presevering
15:39:39 <mux> I don't care
15:39:51 <roconnor> mux: you want me to consider the lists as representing sets?
15:39:54 <mux> the order could probably be tweaked :-)
15:40:14 <copumpkin> you can do what roconnor did, after generating permutations
15:40:21 <mux> roconnor: I want all the ways to partition a set of elements (here represented as a list), into k non-empty disjoint subsets
15:40:23 <copumpkin> you'd get a different order
15:40:38 <roconnor> > let kparts 1 xs = [[xs]]; kparts k xs = concat . init . tail $ zipWith (\a b -> map (a:) $ kparts (k-1) b) (inits xs) (tails xs) in kparts 5 =<< permuations [1..4]
15:40:39 <lambdabot>   Not in scope: `permuations'
15:40:43 <roconnor> > let kparts 1 xs = [[xs]]; kparts k xs = concat . init . tail $ zipWith (\a b -> map (a:) $ kparts (k-1) b) (inits xs) (tails xs) in kparts 5 =<< permuation [1..4]
15:40:44 <lambdabot>   Not in scope: `permuation'
15:40:45 <copumpkin> actually that would make too many
15:40:47 <mux> I dare you!
15:40:53 <mux> I double dare you :D
15:41:05 <copumpkin> > permutations [1..4]
15:41:06 <lambdabot>   [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4...
15:41:18 <copumpkin> > let kparts 1 xs = [[xs]]; kparts k xs = concat . init . tail $ zipWith (\a b -> map (a:) $ kparts (k-1) b) (inits xs) (tails xs) in kparts 5 =<< permutations [1..4]
15:41:20 <lambdabot>   []
15:41:23 <copumpkin> lol
15:41:25 <mux> yes, using permutations would result in *way* too many solutions, no matter how you look at it
15:41:30 <copumpkin> > let kparts 1 xs = [[xs]]; kparts k xs = concat . init . tail $ zipWith (\a b -> map (a:) $ kparts (k-1) b) (inits xs) (tails xs) in kparts 2 =<< permutations [1..4]
15:41:31 <lambdabot>   [[[1],[2,3,4]],[[1,2],[3,4]],[[1,2,3],[4]],[[2],[1,3,4]],[[2,1],[3,4]],[[2,...
15:41:47 <kuribas> :m +Text.XML.HXT.Arrow
15:41:56 <kuribas> sorry...
15:41:57 <roconnor> I need my good ol' choose function.
15:42:13 <mux> oh, I have a choose function; I don't think it's useful here
15:43:06 <mux> this is when Oleg enters the channel, and subsequently rewrites my function using 4 lexemes and 17 characters, in the type system.
15:44:53 <ski> > (filter (not . uncurry (||) . (null *** null)) . partitionM (const [False,True])) [0,1,2]  -- hrm, twice as many solutions as wanted ..
15:44:54 <lambdabot>   [([0],[1,2]),([1],[0,2]),([0,1],[2]),([2],[0,1]),([0,2],[1]),([1,2],[0])]
15:45:03 <copumpkin> bell numbers, apparently
15:45:38 <mux> stirling numbers are related to bell numbers
15:45:59 <mux> B(n,k) = sum for 1 to n of S(n,k)
15:46:42 <ski> (.. does `n' lie between `1' and `n' ?)
15:46:53 <mux> sorry, that was terribly inaccurate
15:46:55 <soupdragon> @let wp _ i | i < 0 = False ; wp "" 0 = True ; wp ('(':s) i = wp s (i-1) ; wp ('(':s) i = wp s (i+1)
15:46:56 <lambdabot>  <local>:4:0:
15:46:56 <lambdabot>      Warning: Pattern match(es) are overlapped
15:46:56 <lambdabot>               In...
15:47:01 <soupdragon> damn you!!!
15:47:07 <soupdragon> > let wp _ i | i < 0 = False ; wp "" 0 = True ; wp ('(':s) i = wp s (i-1) ; wp ('(':s) i = wp s (i+1) in wp "((()))"
15:47:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
15:47:08 <lambdabot>    arising fro...
15:47:39 <mux> B(n) = sum for k ranging from 0 to n of S(n,k)
15:47:39 <mux> here.
15:47:48 <mux> what I said previously made absolutely no sense
15:47:49 <ski> well, lambdabot *has* a point, above ..
15:48:10 <soupdragon> @let wp _ i | i < 0 = False ; wp "" 0 = True ; wp (')':s) i = wp s (i-1) ; wp ('(':s) i = wp s (i+1)
15:48:11 <lambdabot>  Defined.
15:48:12 <soupdragon> :D
15:48:16 <soupdragon> > wp "((()))"
15:48:17 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
15:48:17 <lambdabot>    arising fro...
15:48:22 <soupdragon> damm it
15:48:38 * ski was thinking mux meant `b n = sum [s n k | n <- [1 .. n]]'
15:48:38 <RichardBarrell> I love that overlapping instances for Show error.
15:48:40 <soupdragon> > wp "((()))" 0
15:48:41 <lambdabot>   True
15:48:43 <soupdragon> > wp ")))(((" 0
15:48:44 <lambdabot>   False
15:48:47 <mux> I sould use haskell syntax: bell n = sum (map (\k -> stirling n k) [0..n])
15:48:50 <soupdragon> :t replicateM
15:48:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:48:52 <RichardBarrell> It used to be that \bot would give you the "No instance for Show..."
15:48:53 <mux> ski: heh, pretty much, yes.
15:49:13 <soupdragon> > length . filter (flip wp 0) $ replicateM 3 "()"
15:49:14 <lambdabot>   *Exception: <local>:4:0-94: Non-exhaustive patterns in function wp
15:49:27 <RichardBarrell> Since then, at least two different libraries have added Show instances for functions, and poor old \bot hasn't known which to pick ever since. ^_^
15:49:31 <soupdragon> > replicateM 3 "()"
15:49:32 <lambdabot>   ["(((","(()","()(","())",")((",")()","))(",")))"]
15:49:41 <mux> ski: but you really want the S(n,0) case since S(0,0) = 1 (others are 0)
15:49:45 <soupdragon> doh
15:49:51 <soupdragon> @undef
15:49:59 <ski> (mux : er, actually, i meant i was thinking you meant `b n k = sum [s n k | n <- [1 .. n]]' (but what you meant was actually `b n = sum [s n k | k <- [0 .. n]]'))
15:50:09 * mux nods
15:50:13 <soupdragon> @let wp _ i | i < 0 = False ; wp "" 0 = True ; wp "" _ = False ; wp (')':s) i = wp s (i-1) ; wp ('(':s) i = wp s (i+1)
15:50:15 <lambdabot>  Defined.
15:50:17 <soupdragon> > length . filter (flip wp 0) $ replicateM 3 "()"
15:50:18 <lambdabot>   0
15:51:01 <roconnor> > let choose 0 xs = [([],[])]; choose n [] = []; choose n (x:xs) = (map (x:) *** id) (choose (n-1) xs) ++ (id *** map (x:)) (choose n xs) in choose 3 [1..4]
15:51:02 <lambdabot>   Couldn't match expected type `([[t]], b')'
15:51:03 <lambdabot>         against inferred type `[...
15:51:15 <soupdragon> > wp "" 0
15:51:16 <lambdabot>   True
15:51:18 <soupdragon> > wp "()" 0
15:51:19 <lambdabot>   True
15:51:25 <soupdragon> > length . filter (flip wp 0) $ replicateM 2 "()"
15:51:26 <lambdabot>   1
15:51:27 <soupdragon> > length . filter (flip wp 0) $ replicateM 4 "()"
15:51:28 <lambdabot>   2
15:51:30 <soupdragon> > length . filter (flip wp 0) $ replicateM 8 "()"
15:51:31 <lambdabot>   14
15:51:31 <roconnor> > let choose 0 xs = [([],[])]; choose n [] = []; choose n (x:xs) = map ((x:) *** id) (choose (n-1) xs) ++ map (id *** (x:)) (choose n xs) in choose 3 [1..4]
15:51:33 <lambdabot>   [([1,2,3],[]),([1,2,4],[3]),([1,3,4],[2]),([2,3,4],[1])]
15:51:33 <soupdragon> > length . filter (flip wp 0) $ replicateM 16 "()"
15:51:35 <lambdabot>   1430
15:51:42 <soupdragon> @oies 14,1430
15:51:43 <lambdabot>  Sequence not found.
15:51:47 <soupdragon> > length . filter (flip wp 0) $ replicateM 6 "()"
15:51:48 <lambdabot>   5
15:51:49 <soupdragon> > length . filter (flip wp 0) $ replicateM 10 "()"
15:51:50 <lambdabot>   42
15:52:02 <soupdragon> @oies 1,2,5,14,42
15:52:03 <lambdabot>  Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called...
15:52:03 <lambdabot>  [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,3...
15:52:12 <soupdragon> oh that's not it
15:52:16 <copumpkin> @ask edwardk can your AD automatically differentiate datastructures? :P
15:52:16 <lambdabot> Consider it noted.
15:52:44 <roconnor> mux: this is hard :D
15:53:17 <mux> roconnor: this single phrase of yours makes me happier than I've been all day
15:55:38 <roconnor> how do you do list exponentiation again?
15:56:22 <copumpkin> flip replicateM ? :P
15:56:37 <copumpkin> what do you mean by list exponentiation?
15:56:56 <roconnor> copumpkin: [1,2,3]^[4,5,6] is some reasonable list with 27 elements
15:57:08 <copumpkin> hmm
15:57:32 <copumpkin> oh, like the set of functions with the lists as domain and codomain?
15:57:33 <roconnor> ++ is plus
15:57:56 <roconnor> and lifM (,) is times
15:59:28 <copumpkin> > mapM (\x -> map (\y -> (x, y)) [4,5,6]) [1,2,3]
15:59:29 <lambdabot>   [[(1,4),(2,4),(3,4)],[(1,4),(2,4),(3,5)],[(1,4),(2,4),(3,6)],[(1,4),(2,5),(...
15:59:30 <mux> powerset?
15:59:35 <Axman6> is there a reason gtk2hs's cabal package doesn't depend on gtk2hs-buildtools if it need it to build?
15:59:37 <mux> filterM (const [True,False])
15:59:44 <copumpkin> > length $ mapM (\x -> map (\y -> (x, y)) [4,5,6]) [1,2,3]
15:59:45 <lambdabot>   27
15:59:50 <copumpkin> roconnor: that?
16:00:06 <copumpkin> oh I guess not
16:00:19 <soupdragon> @pl mapM (\x -> map (\y -> (x, y))
16:00:20 <lambdabot> (line 1, column 31):
16:00:20 <lambdabot> unexpected end of input
16:00:20 <lambdabot> expecting variable, "(", operator or ")"
16:00:20 <copumpkin> oh yes
16:00:23 <copumpkin> that's it
16:00:23 <soupdragon> @pl mapM (\x -> map (\y -> (x, y)))
16:00:24 <lambdabot> mapM (map . (,))
16:00:28 <roconnor> copumpkin: looks okaish
16:00:56 <Axman6> oh man, i pl'd that in my head. something's wrong!
16:01:09 <roconnor> > mapM (\x -> map (\y -> (x, y)) [1..2]) "abcd"
16:01:10 <lambdabot>   [[('a',1),('b',1),('c',1),('d',1)],[('a',1),('b',1),('c',1),('d',2)],[('a',...
16:01:34 <copumpkin> soupdragon: that's missing something :)
16:01:50 <choffstein> Hey all.  I have a quick question: I am trying to turn a string into a ByteString.  I do it via Codec.Binary.UTF8.String encode, which gives me [Word8], which I then 'pack'.  My issue is that I am getting a Lazy ByteString instead of a strict one.  I was wondering if there was a way I could force the strict version
16:01:51 <copumpkin> @pl \a b -> mapM (\x -> map (\y -> (x, y)) a) b
16:01:51 <lambdabot> mapM . flip (map . (,))
16:01:59 <copumpkin> aha! told you ;)
16:02:03 <copumpkin> @pl \a b -> mapM (\x -> map (\y -> (x, y)) b) a
16:02:04 <lambdabot> flip (mapM . flip (map . (,)))
16:02:12 <dcoutts> Axman6: it does but cabal-install does not yet track build-tools
16:02:22 <Axman6> ah, i see
16:02:40 <Axman6> well, compiling CParser seems to take a hell of a long time...
16:03:22 <choffstein> ah, that was a stupid question of mine ... I was reading my compiler error completely backwards.
16:03:25 <soupdragon> is there a list of haskell tutorials that need written?
16:03:45 <Axman6> how odd, stopped the build, and started it again, and it went without a hitch
16:03:51 <roconnor> @index comparing
16:03:51 <lambdabot> bzzt
16:04:01 <Axman6> Data.Ord
16:04:26 <ski> > mapM ((`map` [0,1]) . (,)) [2,3]
16:04:27 <lambdabot>   [[(2,0),(3,0)],[(2,0),(3,1)],[(2,1),(3,0)],[(2,1),(3,1)]]
16:04:30 <ski> > mapM ((`map` "ab") . (. return) . (:)) "cde"
16:04:31 <lambdabot>   [["ca","da","ea"],["ca","da","eb"],["ca","db","ea"],["ca","db","eb"],["cb",...
16:04:34 <ski> > length (mapM ((`map` "ab") . (. return) . (:)) "cde")
16:04:35 <lambdabot>   8
16:04:54 <ski> roconnor : .. oh, you already got it :)
16:05:20 <Axman6> gogo cabal install gtk!
16:05:59 <roconnor> @index on
16:06:00 <lambdabot> bzzt
16:06:08 <copumpkin> Data.Function
16:06:08 <RichardBarrell> Axman6: gtk installs from cabal? When did that happen?
16:06:18 <RichardBarrell> Axman6: and who do we have to thank for it?
16:06:24 <Axman6> a day or so ago
16:06:35 <dcoutts> RichardBarrell: Axel Simon has been working on it for some time
16:06:36 <Axman6> the gtk2hs guys i guess ;
16:06:42 <RichardBarrell> Nifty!
16:07:47 <Figs> How do you save a closure?
16:07:52 <copumpkin> you don't
16:07:54 <ski> @type uncurry (fmap . (,))
16:07:55 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
16:08:08 * copumpkin flexes his muscles at ski
16:08:18 <ddarius> ski: A clear illustration of one definition of "strength"
16:08:33 <ddarius> Namely, that fmap is representable by a morphism.
16:08:54 <roconnor> let kpart k xs = filter ((4==).length) . map ( map (map snd) . groupBy ((==) `on` fst) . sort) $ mapM (\x -> map (\y -> (y,x)) [1..4]) xs in kpart 2 [1..4]
16:08:58 <roconnor> > let kpart k xs = filter ((4==).length) . map ( map (map snd) . groupBy ((==) `on` fst) . sort) $ mapM (\x -> map (\y -> (y,x)) [1..4]) xs in kpart 2 [1..4]
16:08:59 <lambdabot>   [[[1],[2],[3],[4]],[[1],[2],[4],[3]],[[1],[3],[2],[4]],[[1],[4],[2],[3]],[[...
16:09:00 <ski> ddarius : yes. (as evidenced by copumpkin)
16:09:04 <copumpkin> @typo uncurry (liftM2 (,))
16:09:05 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
16:09:05 <roconnor> damn it
16:09:16 <roconnor> mux: I give up
16:09:20 <roconnor> good night :)
16:09:21 <mux> yay, I win!
16:09:25 <copumpkin> lol
16:09:26 <mux> have a good night sir :-)
16:09:28 <mike-burns> Figs: What are you trying to accomplish?
16:09:47 <choffstein> has anyone here successfully played around with haskell and google's protocol buffers?
16:09:58 <ddarius> @hackage hproto
16:09:59 <lambdabot> http://hackage.haskell.org/package/hproto
16:10:19 <Figs> Satisfying my curiousity mostly. It's been niggling away in the back of my mind for a while since I realized what a pain it is to deal with in Python.
16:10:19 <ddarius> @hackage hprotoc
16:10:20 <lambdabot> http://hackage.haskell.org/package/hprotoc
16:10:21 <choffstein> hprotoc
16:10:41 <ormaaj> Is (\x y -> blah) exactly shorthand for (\x -> \y -> blah) or are they logically different and just happen to be equivalent somehow. (this doesn't work in like... python)
16:10:48 <Axman6> Figs: i don't believe you can in haskell
16:10:59 <Axman6> ormaaj: they're the same
16:11:33 <choffstein> ddarius: I am just having a hard time working with the automatically generated files that are being created.  Mainly because I am new to Haskell.
16:12:31 <alex404> exit
16:13:28 <Cale> Figs: Well, if you really had access to closures, it's not a problem to work out some way of serialising them. However, first-class functions in Haskell, while they might be implemented by closures of some sort internally in some implementations, aren't visibly closures.
16:13:55 <soupdragon> hllo cale
16:14:16 <Cale> (you can't separate the code from the environment binding the free variables)
16:14:47 <ormaaj> oh wait yes it does... it just needs a comma. (lambda x, y: x - y)(3, 4)
16:15:56 <Figs> Cale: Could you elaborate on that a bit please?
16:16:16 <zygoloid> ormaaj: i have a suspicion that given:  (\0 0 -> 0) 0 (error "Hello")  and  (\0 -> \0 -> 0) 0 (error "Hello")  the former can produce the "Hello" exception but the latter can't
16:16:36 <soupdragon> ;(
16:16:39 <ddarius> Figs: For any types A and B, A -> B is an abstract data type that provides only one operation.
16:16:54 <ski> @type (uncurry . (Data.Traversable.traverse .) . flip . curry) strength
16:16:55 <lambdabot> forall a (f :: * -> *) (t :: * -> *) b. (Data.Traversable.Traversable t, Applicative f) => (f b, t a) -> f (t (a, b))
16:17:13 <Cale> Figs: A closure is a pair consisting of a chunk of explicit code which may contain free variables, and an environment, which is essentially a dictionary of mappings from free variables that occur in the code to values.
16:17:51 <ski> ormaaj : they're the same, in most cases
16:18:09 <ormaaj> zygoloid: Kind of hard to tell. The auto-currying thing makes the types appear the same
16:18:11 <Cale> If you had such a thing, it wouldn't be too hard to come up with a way of serialising it.
16:18:59 <EvanR> you can represent it as a supercombinator and some of the arguments
16:18:59 <Cale> But any closures in the implementations of Haskell are hidden away behind an abstraction barrier where you can't even tell that they're closures. All you have access to are (first-class) functions.
16:19:49 <Cale> (Also, nothing in the Haskell spec requires that functions be implemented using closures.)
16:20:23 <EvanR> there are no free variables in the program as a whole
16:20:49 <EvanR> so closures seem kind of inappropriate
16:20:49 <choffstein> Can someone take a look at http://pastie.org/977191?  I am very stuck as to why I am getting the compiler errors I am
16:20:53 * ski . o O ( `newtype a -> b = forall x. Closure $# (# x , (# x , a #) #-> b #)' )
16:21:10 <choffstein> I would be much obliged
16:21:48 <Cale> choffstein: It looks like you're using lazy and strict bytestrings without converting between the two.
16:22:10 <ddarius> ski: The existential would also be a problem for serializing unless we shoved a suitable function for serializing inside the closure as well.
16:22:35 <ski> yes
16:22:56 <ski> (.. though OCaml has (limited) support for marshalling closures)
16:23:12 <choffstein> Cale: So BS.pack is probably being lazy then>
16:23:24 <ddarius> ski: Well the implementation can ignore the existential.
16:23:38 <mauke> choffstein: what
16:23:45 <Cale> choffstein: BS is Data.ByteString, which is the strict variant of ByteStrings
16:23:50 <ski> only if enough information is kept at run-time
16:24:05 <choffstein> Cale: Right, that is what I thought.  Hence why I am having trouble understanding the compiler error
16:24:09 <Cale> choffstein: It's confusing because there's Data.ByteString.Lazy, which defines a different type which is also called ByteString
16:24:39 <ddarius> ski: I'm not sure it can fail to at one level.
16:24:46 <choffstein> Cale: It seems to me that it is expecting Data.ByteString.Lazy.Internal.ByteString in my Just constructor
16:25:01 <Cale> yes
16:25:09 <choffstein> Cale: But looking at the definition of Request, I don't get that at all
16:25:25 <Figs> Cale: Suppose I have something like this ( http://pastebin.com/j6VQpms2 )
16:25:30 <ski> ddarius : i mean, iiuc, the OCaml RTS does it by keeping tags, and having a known layout of closures
16:26:06 <Figs> Where I get either a or b back from some function in another part of my program. How would I store the result between runs of my program?
16:26:07 <Cale> choffstein: Well, you have P'.ByteString there... I'm not sure which variant of ByteString it is that Text.ProtocolBuffers.Header exports, but I'm betting that it's the lazy kind.
16:26:17 <ddarius> ski: The information needed for garbage collection plus the information needed for execution seems like all that would be needed for a, highly unportable, implementation.
16:26:33 <choffstein> Cale: Ahhhh.  Okay.  I'll get my head around this eventually, damnit!
16:26:49 <choffstein> Cale: Is there a way to go from the Lazy to the Strict ByteString?
16:27:03 <ski> ddarius : even in the presence of CTGC or region management ?
16:27:04 <c_wraith> :t toChunks
16:27:05 <Cale> choffstein: It'd be so much simpler if the types were actually named differently ;)  Yeah, there's toChunks and fromChunks
16:27:05 <lambdabot> Not in scope: `toChunks'
16:27:23 <zygoloid> @type BSL.toChunks
16:27:25 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
16:27:25 <c_wraith> toChunks creates a lazy list of strict bytestrings.
16:27:30 <zygoloid> @type BSL.fromChunks
16:27:31 <lambdabot> [BSC.ByteString] -> BSLC.ByteString
16:27:35 <c_wraith> which you can that concatenate
16:27:39 <ddarius> ski: Well you could say "Even in the presence of the trivial garbage collector."
16:27:41 <c_wraith> err, *then
16:27:46 <mike-burns> Figs: You mean like in a database?
16:28:18 <Figs> Sure either to a database, or to a file.
16:28:22 <ski> ddarius : are you talking about just doing a full memory dump ?
16:28:38 <Cale> Figs: Since (\n -> xyz + n) is just a function and not a closure, you have no choice but to define some sort of datatype to represent it abstractly.
16:28:48 <ddarius> ski: I wasn't though that's another solution.
16:29:19 <gio123_> Cale: hi
16:29:21 <mike-burns> Figs: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database - these are the DB libraries for Haskell. I've used HDBC without many complaints.
16:29:32 <Cale> Figs: Though since it's only an Int -> Int function, I suppose you could theoretically encode it as a giant explicit list of pairs.
16:29:39 <gio123_> Cale: english?
16:30:03 <EvanR> mike-burns: autoclosing a prepared statement when you attempt to read the last result is annoying
16:30:12 <Olathe> gio123_: Yes, Cale is speaking English.
16:30:15 <mike-burns> Eh?
16:30:16 <c_wraith> HDBC's postgres connector using blocking libpq calls.  That's suboptimal.  One of my co-workers is working on making a fix to that available.
16:30:38 <EvanR> mike-burns: hdbc auto closes prepared statements, making them unreusable
16:30:41 <gio123_> Olathe: are u sure?
16:30:41 <mike-burns> Oh.
16:30:47 <EvanR> which is the point of prepared statements
16:30:48 <Cale> Olathe: He wants help with English.
16:30:49 <mauke> gio123_: 'u' is not a word
16:30:56 <Olathe> Cale: Oh.
16:31:13 * Axman6 agrees with mauke
16:31:18 <gio123_> mauke: it is a ltter, so it is not alow to us eltter here?
16:31:23 <mike-burns> EvanR: Yeah, I wasn't thrilled with HDBC, just saying that it gets the job done.
16:31:38 <Axman6> gio123_: not when using it as a replacement for a word
16:31:43 <mauke> gio123_: 'ltter', 'alow', and 'eltter' are not words
16:32:12 <gio123_> mauke: they are words... if you know defination of words
16:32:21 <mauke> 'defination' is not a word
16:32:31 <mike-burns> You guys are being kinda rough on some dude who simply wanted Cale to explain further.
16:32:42 <mauke> and has been doing so for years
16:32:44 <Axman6> well, they're not english words
16:32:45 <EvanR> and probably cant spell english worth a damn ;)
16:32:47 <Cale> mike-burns: huh?
16:32:49 <mauke> usually unrelated to haskell
16:32:57 <mike-burns> Oh, I didn't know the history.
16:32:58 <gio123_> Cale: english :)?
16:33:00 <Figs> Cale: Why isn't a's x a closure when you run the program? Do you mean that to the type system, it's just a function, so I can't preserve it?
16:33:03 <Cale> mike-burns: gio123_ wants something else
16:33:13 <choffstein> Cale: I am sorry, but I am really slow on the uptake.  I am looking at Data.ByteString.Lazy fromChunks here, and I don't understand how it will take me to the strict version...
16:33:29 <mauke> choffstein: you want toChunks
16:33:34 <Cale> Figs: It's just a function. You shouldn't call it a closure because it's impossible to separate it into code + an environment.
16:33:42 <Saizan> choffstein: S.concat . L.toChunks
16:33:47 <Cale> gio123_: Yeah, hang on
16:33:56 <choffstein> Oh, wow, that seems round-about
16:34:02 <choffstein> okay, thanks.  I'll take a look into it
16:34:37 <Cale> choffstein: fromChunks takes a (lazy) list of strict chunks and turns them into a lazy bytestring
16:35:02 <mauke> choffstein: why do you need to convert anyway?
16:35:02 <Cale> choffstein: toChunks takes a lazy bytestring, and turns it into a lazy list of strict chunks
16:35:24 <choffstein> mauke: the protobuf translation seems to have chosen to use lazy bytestrings
16:35:30 <choffstein> Cale: Okay, that makes sense.
16:35:37 <mauke> choffstein: so why are you using strict bytestring?
16:35:48 <choffstein> mauke: because ZeroMQ requires the strict bytestring
16:36:25 <choffstein> Or, at least I think it does.  I get very confused by it all.
16:39:01 <Figs> Cale: But you can seperate it into an environment and a code pair. I could do so manually if I wanted. If there's no way to automatically do that given an arbitrary function type, then fine.
16:39:36 <Cale> Figs: Yeah, basically, by representing code explicitly using a tree.
16:40:06 <Cale> Figs: Haskell doesn't provide a way to pry apart arbitrary functions into closures, is what I'm saying :)
16:40:22 <Figs> Ok.
16:40:42 <Cale> Figs: (It would break referential transparency, though it might be a nice thing to have in the IO monad.)
16:40:59 <copumpkin> unfortunately that information isn't preserved currently
16:41:40 <soupdragon> information cannot be created or destroyed
16:42:23 <Cale> soupdragon: Can be converted into heat though.
16:44:16 <Figs> Alright thanks. See you all later.
16:44:57 <Mortomes> Cale: Equivalent to destroying
16:46:02 <Cale> It's fun to think that the reason that processors get so hot is that they're converting discarded information into heat.
16:46:18 <soupdragon> Cale - it's not just fun
16:46:28 <soupdragon> that is the basis of low energy reversible computers
16:46:40 <Cale> right.
16:46:49 <soupdragon> the way you said it sounded like it wasn't true..
16:47:01 <EvanR> reversible sounds like the ultimate time memory tradeoff
16:47:28 <EvanR> infinite memory, and time is irrelevant, because you already computed it
16:48:06 <soupdragon> I heard that the fundamental laws of physics are time reversible
16:48:27 <soupdragon> stuff like 'forwards in time' just comes from large collections of things operating statistically
16:48:41 <QtPlatypus> soupdragon: Thats an open question.
16:48:54 <EvanR> i think this is where cs people are disconnected from reality
16:50:26 <arw> soupdragon: newtonian mechanics is reversible and is made irreversible by statistics, in large quantities of particles you get chaotic behaviour and stuff.
16:50:28 <QtPlatypus> EvanR: Well all mathmatics is disconnected from reality.  CS and felds of math are abstractions that give us useful models.
16:50:30 <Cale> soupdragon: Yeah, that's currently possible.
16:50:48 <arw> soupdragon: later theories are almost all irreversible in some aspect.
16:51:24 <EvanR> qm is reversible unless you add the statistical hypothesis
16:51:44 * hackagebot hfiar 2.0.2 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-2.0.2 (FernandoBenavides)
16:51:49 <EvanR> making it apply to real life
16:51:53 <ddarius> arw: The current standard model of physics and general relativity obey CPT symmetry.
16:52:26 <arw> ddarius: yes, CPT, but not only T.
16:53:59 * soupdragon doesn't erally beleive in the universe or anything but it's fun to pretend
16:54:57 <ddarius> "The evidence for existence seems inconclusive."
16:58:23 <Cale> Well, you can't tell the difference between an electron travelling forwards in time, and a positron going in reverse
16:58:57 <Raynes> That's annoying. I spent 30 minutes last night grabbing the gtk2hs darcs repo and cabal installing everything individually, and today, bang! It's on hackage.
16:59:19 <Cale> Raynes: hehe
16:59:30 <blackdog> "It was hard for me, it should be hard for everyone else!"
16:59:48 <Raynes> blackdog: That's right. ;)
16:59:48 <blackdog> cabal install yi -fgtk still doesn't work off the bat, sadly
16:59:58 <Figs> Hey Cale -- why would having a Read and Show for Int -> Int violate referential transparency?
17:00:24 <Cale> Figs: It wouldn't, per se. Just the efficient one which prints a representation of the code would.
17:00:29 <monochrom> w00t gtk2hs comes in a cabal package!
17:00:48 <Cale> Figs: Because you could tell the difference between two functions which computed the same results.
17:01:04 <Cale> Even though they're supposed to be the same function.
17:01:05 <monochrom> but oh God it's full of tiny packages!
17:01:45 <dolio> You can show (forall a. a -> a), though.
17:01:51 <danharaj> Cale: That seems like a very strict for of referential transparency.
17:01:54 <danharaj> form*
17:02:07 <Cale> danharaj: It's just the usual sort.
17:02:53 <danharaj> Cale: What is that definition.
17:03:23 <Cale> If you have any two functions f and g for which f x = g x for all x, then you should be able to replace f by g in any program without changing its meaning.
17:04:30 <danharaj> That is stronger than "if forall x , f x = g x, then forall y , you can replace f y with g y without changing its meaning.
17:04:32 <danharaj> "
17:04:48 <danharaj> and I don't know why your version should be used over mine.
17:05:01 <Cale> Oh?
17:05:07 <Cale> How is it stronger?
17:05:17 <jbapple> dolio: Not in the presence of seq, though, right?
17:05:40 <ski> @where+ PurelyFunctional "What is a Purely Functional Language?" at <http://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps> by Amr Sabry, 1998
17:05:40 <lambdabot> Nice!
17:05:44 <ddarius> Referential transparency doesn't talk about equivalent functions but a variable and what it is bound te.
17:05:48 <dolio> jbapple: Yeah, probably not. seq ruins everything.
17:06:01 <Cale> danharaj: If that's the case, we can always just introduce a lambda.
17:06:05 <danharaj> Cale: let me think :p
17:06:38 <ddarius> let x = M in N <=> N[x/M]
17:06:40 <jbapple> Not everything: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.3.4936&rep=rep1&type=pdf
17:06:49 <dolio> jbapple: It might not be a problem for that type, but certainly for (forall a b. a -> b -> a) you can't accurately detect const vs. seq.
17:07:01 <Cale> We can eta expand f to (\y -> f y) and then replace f with g to get (\y -> g y), and then eta reduce to get g
17:07:05 <danharaj> Cale: I just don't think equality on functions should be defined as pointwise equality and I'm trying to formalize that.
17:07:10 <danharaj> Cale: yeah
17:07:15 <Cale> Of course it should :)
17:07:50 <jbapple> and http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf
17:07:59 <danharaj> Cale: That equality is not effective.
17:08:04 <soupdragon> there are lots of different notions of equality
17:08:08 <Cale> At least, in an ideal world where we don't have to worry about the performance of our programs and only their termination behaviour, pointwise equality is exactly what we want.
17:08:28 <soupdragon> if you are trying to decide which equality is 'the right one' you're probably wrong
17:08:42 <danharaj> soupdragon: 'the right one' is the one that is most useful for your context.
17:08:43 <soupdragon> you really to have a use case to choose an equality
17:08:50 <dolio> jbapple: Yeah, well, the second one just ignores anything that seq could do wrong. :)
17:08:50 <soupdragon> yes and you have to have a context
17:09:02 <jbapple> dolio: fair enough :-)
17:09:09 <danharaj> soupdragon: the context is referential transparency :p
17:09:19 <soupdragon> Cales definition is correct
17:09:29 <danharaj> It is not a decidable equality. So I don't think it should be.
17:09:48 <Cale> danharaj: Note that pointwise equality also takes into account nontermination behaviour.
17:09:48 <ddarius> danharaj: It doesn't need to be decidable to be a specification.
17:10:52 <Philonous> Does someone know how I can produce a "CommandParser" for shellac? The documentation is rather sparse and mentions it only once in the return type of a function that the user is to provide.
17:11:41 <danharaj> ddarius: Sure, but why Cale's specification instead of mine (literal equality as lambda terms)?
17:12:20 <ddarius> danharaj: Personally I think you are both wrong as I stated above.
17:12:31 <danharaj> heh
17:12:58 <danharaj> ddarius: I don't exactly understand your position could you elaborate?
17:14:44 <danharaj> Cale: If I concede that, how does 'read' violate referential transparency?
17:14:52 <dolio> Referential transparency says that the result of a function applied to a particular value is the same regardless of where or how many times that function is called, or whatnot.
17:14:55 <ddarius> danharaj: Referential transparency says that you can replace a reference with what it refers to without changing the meaning of the program.  The word "function" was not involved at all, though my equivalence was slightly off, let x = M in N <=> let x = M in N[M/x]
17:15:14 <dolio> Cale's statement is about extensional equality of functions.
17:15:36 <danharaj> ok, yeah, that sounds correct.
17:15:39 <danharaj> (both)
17:20:19 <wli> I guess that's one way to handle recursive definitions.
17:29:37 <soupdragon> looks like the #haskell-math project petered out and died
17:31:05 <wli> There was a particular project behind it?
17:38:47 <jmcarthur> soupdragon: it actually just hadn't gotten started. most participants are just finishing up some schooling right now i think
17:40:21 <ManateeLazyCat> Do you use maybeT ?
17:41:02 * hackagebot hfiar 2.0.3 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-2.0.3 (FernandoBenavides)
17:42:37 <siracusa> ManateeLazyCat: Have you tried gtkglext on your system?
17:44:04 <ManateeLazyCat> siracusa: ?
17:44:10 <ManateeLazyCat> siracusa: Any problem?
17:45:27 <siracusa> ManateeLazyCat: Yes, but I'm not sure if it's gtk2hs related. If I start the DrawingCube demo the GL canvas paints over the button and the label.
17:45:58 <ManateeLazyCat> siracusa: Wait a sec, i check.
17:46:27 <siracusa> ManateeLazyCat: So the button is black, only if I resize the window the button is visible for a short time and then gets painted over.
17:53:25 <ManateeLazyCat> siracusa: I have test demo again, works fine.
17:54:33 <siracusa> Hhm, so either it's Windows specific or something's wrong with the DLLs.
17:54:59 <ManateeLazyCat> siracusa: http://farm5.static.flickr.com/4030/4640089815_3a03c7e710_o.png
17:55:16 <ManateeLazyCat> siracusa: Yes, i doubt something wrong on Windows.
17:57:56 <copumpkin> @djinn ((t -> b) -> u -> b) -> ((t1 -> t) -> b) -> (t1 -> u) -> b
17:57:57 <lambdabot> -- f cannot be realized.
18:08:21 <copumpkin> can anyone figure out that type that yitz wrote on -cafe?
18:08:22 <copumpkin> keep :: ((t -> b) -> u -> b) -> ((t1 -> t) -> b) -> (t1 -> u) -> b
18:08:27 <copumpkin> it looks impossible to me
18:08:39 <copumpkin> even using recursion
18:09:08 <pastorn> @djinn ((t -> b) -> u -> b) -> ((t1 -> t) -> b) -> (t1 -> u) -> b
18:09:08 <lambdabot> -- f cannot be realized.
18:09:13 <pastorn> copumpkin: there you go
18:09:26 <copumpkin> @djinn (a -> a) -> a
18:09:26 <lambdabot> -- f cannot be realized.
18:09:27 <copumpkin> :t fix
18:09:28 <lambdabot> forall a. (a -> a) -> a
18:09:35 <copumpkin> that's what I meant by "even using recursion"
18:09:38 <pastorn> bah, details
18:10:19 <pastorn> > fix (/100000) 1
18:10:20 <lambdabot>   *Exception: stack overflow
18:10:22 <pastorn> :(
18:11:03 <copumpkin> > fix (/100000)
18:11:07 <lambdabot>   mueval-core: Time limit exceeded
18:11:10 <aavogt> @type fix (/100000)
18:11:11 <lambdabot> forall a. (Fractional a) => a
18:11:16 <jmcarthur> it looks copied out of ghci though, judging from the t1
18:11:20 <copumpkin> how did that typecheck?
18:11:32 <pastorn> copumpkin: haha, that was cool
18:11:33 <copumpkin> @typo fix (/100000) 1
18:11:34 <lambdabot> forall t t1. (Fractional (t -> t1), Num t) => t1
18:11:34 <aavogt> looks like there's some odd Num instance there
18:11:35 <pastorn> do it again :)
18:11:37 <copumpkin> oh
18:11:59 <copumpkin> > 5 6
18:12:00 <lambdabot>   Ambiguous type variable `t' in the constraint:
18:12:00 <lambdabot>    `GHC.Num.Num t' arising f...
18:12:13 <jmcarthur> > 5 ()
18:12:14 <lambdabot>   5
18:12:16 <aavogt> > fix 1
18:12:17 <lambdabot>   1
18:12:20 <copumpkin> wtf
18:12:21 <pastorn> wtf?
18:12:23 <jmcarthur> > (5 + 5) ()
18:12:25 <lambdabot>   10
18:12:42 <pastorn> > let x = () in 5 + x
18:12:43 <lambdabot>   No instance for (GHC.Num.Num ())
18:12:43 <lambdabot>    arising from the literal `5' at <intera...
18:12:47 <jmcarthur> > (\a -> a+5) + (\a -> a*2) $ 3
18:12:48 <lambdabot>   14
18:12:53 <pastorn> jmcarthur: you evil magician
18:13:00 <copumpkin> oh
18:13:00 <jmcarthur> looks like a standard lifted num instance to me
18:13:02 <pastorn> > let x = () in 5 x
18:13:02 <lambdabot>   5
18:13:07 <copumpkin> :t normal
18:13:08 <lambdabot> Not in scope: `normal'
18:13:11 <copumpkin> hmm
18:13:15 <Cale> > (sin^2 + cos^2) 5
18:13:15 <lambdabot>   0.9999999999999999
18:13:17 <jmcarthur> (+) = liftA2 (+)
18:13:22 <copumpkin> oh, vector-space is loaded
18:13:24 <copumpkin> I guess?
18:13:29 <jmcarthur> :t (^+^)
18:13:30 <lambdabot> forall v. (AdditiveGroup v) => v -> v -> v
18:13:33 <jmcarthur> looks like
18:13:40 <copumpkin> so the NumInstances
18:14:05 <jmcarthur> > 5 *^ (3, 3)
18:14:06 <lambdabot>   No instance for (GHC.Num.Num (Data.VectorSpace.Scalar t1))
18:14:06 <lambdabot>    arising from ...
18:14:14 <jmcarthur> > 5 *^ (3, 3) :: (Double, Double)
18:14:15 <lambdabot>   (15.0,15.0)
18:14:35 <jmcarthur> yay more ways to confuse newbies!
18:14:47 <copumpkin> time to compose numbers with fmap
18:14:51 <copumpkin> > 5 . [1..5]
18:14:53 <lambdabot>   [5,5,5,5,5]
18:14:53 <jmcarthur> lol
18:14:55 <copumpkin> :P
18:15:00 <copumpkin> mindfuck galore!
18:15:05 <pastorn> what is this?
18:15:13 <copumpkin> > 5 . 6
18:15:14 <lambdabot>   No instance for (GHC.Show.Show (f b))
18:15:14 <lambdabot>    arising from a use of `M3936156076...
18:15:15 * pikhq giggles
18:15:17 <copumpkin> > 5 . 6 $ 7
18:15:18 <lambdabot>   5
18:15:19 <jmcarthur> pastorn: a Num instance for functions
18:15:26 <copumpkin> > 5.6 $ 7
18:15:27 <lambdabot>   5.6
18:15:28 <Philonous> Are the num instances for functions hard-coded into lambdabot?
18:15:29 <pastorn> kill me now
18:15:31 <jmcarthur> i love it, but i can confuse people if they aren't prepared for it
18:15:36 <Philonous> (singular)
18:16:38 <pikhq> I'm giggling.
18:16:49 <jmcarthur> > ((+)^2) 2 3
18:16:51 <lambdabot>   25
18:17:40 <jmcarthur> > product - sum $ [1..5]
18:17:41 <lambdabot>   105
18:17:41 <pastorn> jmcarthur: stop it
18:17:47 <jmcarthur> what? :)
18:18:12 <soupdragon> stop treating functions like they're numbers!!
18:18:14 <soupdragon> it's not tru
18:18:22 <copumpkin> it's fals?
18:18:35 <pastorn> soupdragon: for church numerals it is...
18:18:46 <copumpkin> so much religion in here
18:18:50 <copumpkin> keep it on-topic
18:18:59 <pastorn> hehe
18:19:05 <pastorn> copumpkin: oh you're bad
18:19:22 <Pseudonym> It's cotrue.
18:19:25 <copumpkin> omg it's lady gaga on glee right now
18:19:32 <copumpkin> (totally on-topic)
18:19:33 <pastorn> copumpkin: you should join me on mass
18:19:39 <pastorn> copumpkin: in the Church of Alonzo
18:20:14 <jmcarthur> > let length = sum . (1 .) in length "hello there"
18:20:15 <lambdabot>   11
18:20:36 <soupdragon> lol
18:20:49 <soupdragon> > foldr ((+) . 1) 0 "test"
18:20:50 <lambdabot>   4
18:21:12 <Philonous> @type (.)
18:21:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:21:38 <jmcarthur> soupdragon: that's a good one!
18:21:50 * BlackM belongs to the Reformed (Mogensen) branch of Scott!
18:21:55 <Cale> soupdragon: That's an awesome definition of length :)
18:22:19 <jmcarthur> mine is clearly inferior because it is shorter
18:22:33 <copumpkin> I like yours too
18:22:41 <aavogt> branch cuts
18:22:42 <jmcarthur> no, mine is inferior
18:22:52 <copumpkin> jmcarthur: don't feel bad cause yours is shorter
18:22:55 <aavogt> @src sum
18:22:55 <lambdabot> sum = foldl (+) 0
18:22:58 <copumpkin> it works just as well
18:22:59 * jmcarthur searches for yet more obscure ways to write length
18:23:25 <BlackM> copumpkin: Fine! "That's what SHE said!" ;
18:25:31 <jmcarthur> > foldr ((+) . 1 1 1 1 1 1 1 1 1 1 1) 0 "test"
18:25:32 <lambdabot>   4
18:25:35 <jmcarthur> :)
18:25:45 <pastorn> wtf?
18:25:51 <soupdragon> foldr ((+) . 1 2 3 4 5 6 7 8 9) 0
18:25:52 <jmcarthur> > foldr ((+) . 1 2 3 4 5 6 7 8 9 10 11 12 13) 0 "test"
18:25:54 <lambdabot>   4
18:26:02 <pastorn> > foldr ((+) . 10 1 1 1 1 1 1 1 1 1 1) 0 "test"
18:26:03 <lambdabot>   40
18:26:13 <jmcarthur> no that ruins the effect
18:26:19 <jmcarthur> it looks like counting!
18:27:17 <choffstein> hey everyone.  I was in here earlier trying to figure out a way to go from Lazy ByteStrings to strict ones, and was steered towards concat . toChunks.  I am now trying to go from Strict ByteStrings to Lazy ones.  If `msg` is a strict bytestring, would msg2 = fromChunks [msg] by Lazy?  I am really struggling with this one
18:27:36 <jmcarthur> dang, the Sum type now conflicts
18:27:42 <jmcarthur> vector-space has its own
18:27:44 <aavogt> it's one single chunk
18:27:50 <jmcarthur> > Sum 1
18:27:52 <lambdabot>   Ambiguous occurrence `Sum'
18:27:52 <lambdabot>  It could refer to either `Data.Monoid.Sum', imp...
18:27:54 <jmcarthur> :(
18:28:12 <aavogt> > Some
18:28:13 <lambdabot>   Not in scope: data constructor `Some'
18:28:13 <pastorn> @seen JonnoFTW
18:28:13 <lambdabot> Unknown command, try @list
18:28:16 <pastorn> :(
18:28:18 <pastorn> halp?
18:28:26 <copumpkin> preflex: seen JonnoFTW
18:28:26 <preflex>  Sorry, I haven't seen JonnoFTW
18:28:34 <copumpkin> preflex: seen Jonno_FTW
18:28:34 <preflex>  Jonno_FTW was last seen on #haskell 1 day, 18 hours, 6 minutes and 11 seconds ago, saying: I don't get it, how do I use this module?
18:28:46 <pastorn> copumpkin: cool, thanks :)
18:30:21 <jmcarthur> > foldr ((+) . fix 1) 0 "test"
18:30:22 <lambdabot>   4
18:31:35 <soupdragon> LOL
18:31:44 <siracusa> > 10 20 30
18:31:45 <lambdabot>   Ambiguous type variable `t' in the constraint:
18:31:46 <lambdabot>    `GHC.Num.Num t'
18:31:46 <lambdabot>      aris...
18:31:47 <pastorn> srsly?
18:31:51 <siracusa> > 10 20 30 :: Int
18:31:52 <lambdabot>   10
18:32:00 <pastorn> copumpkin: could you plz kick jmcarthur? i'm getting a headache
18:32:08 <copumpkin> he can kick himself
18:32:13 <pastorn> awww
18:32:25 <pastorn> jmcarthur: plz?
18:32:35 <jmcarthur> pastorn: but i was going to make it worse first
18:32:40 <jmcarthur> building action and all that, you know
18:32:46 <copumpkin> > fix (fix 1)
18:32:47 <lambdabot>   1
18:32:54 <pastorn> ((+) . fix 1) is pretty terrible
18:32:54 <copumpkin> > fix fix 1
18:32:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:33:11 <aavogt> @type Mu
18:33:11 <pastorn> > (fix fix) 1
18:33:12 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:33:13 <lambdabot> Not in scope: data constructor `Mu'
18:33:14 <soupdragon> > (fix . fix) 1 :: Integer
18:33:15 <lambdabot>   1
18:33:31 <soupdragon> :t In
18:33:32 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
18:33:36 <soupdragon> :t out
18:33:37 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
18:33:42 <copumpkin> > fix . fix . fix $ 1
18:33:43 <lambdabot>   1
18:33:58 <soupdragon> :t fix (In . fix . out)
18:33:59 <lambdabot>     Occurs check: cannot construct the infinite type:
18:33:59 <lambdabot>       f = (->) (f (Mu f))
18:33:59 <lambdabot>       Expected type: Mu f
18:34:09 <aavogt> @type fix . In
18:34:10 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `Mu f'
18:34:11 <lambdabot>     Probable cause: `In' is applied to too many arguments
18:34:11 <lambdabot>     In the second argument of `(.)', namely `In'
18:34:27 <aavogt> @type (fix .) . In
18:34:28 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
18:34:29 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
18:34:29 <lambdabot>       Expected type: f1 (Mu f1) -> f (a -> a)
18:34:33 <copumpkin> lol
18:34:48 <copumpkin> it takes special skill to get a kind error from a flawed value expression
18:37:41 <Raynes> Cale: Amusingly, if I had thought to look in bootstrap.sh, I could have cabal installed everything automagically. I never claimed to be smart though.
18:38:04 <aavogt> @type fix (In . ?f)
18:38:06 <lambdabot> forall (f :: * -> *). (?f::Mu f -> f (Mu f)) => Mu f
18:38:36 <soupdragon> I started to write a tutorial on implementing scheme in haskell but I got fed up with it pretty quickly
18:38:46 <jmcarthur> > ((foldr (+) . fix) 0 . ((.).fix) 1) "test" . fix $ 5
18:38:47 <lambdabot>   4
18:39:24 <pastorn> > fix (++) "lol"
18:39:25 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:39:31 <pastorn> @type fix
18:39:32 <lambdabot> forall a. (a -> a) -> a
18:39:43 <aavogt> > fix (.) 1 2
18:39:44 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
18:39:47 <pastorn> oh, right
18:40:00 <jmcarthur> > ((foldr (+) . fix) (0 "^_^") . ((.).fix) (1 "o_O")) "test" . fix $ 5 ":D"
18:40:01 <pastorn> > fix (++ "NOM) "OM"
18:40:01 <lambdabot>   4
18:40:01 <lambdabot>   <no location info>:
18:40:02 <lambdabot>      lexical error in string/character literal at end o...
18:40:17 <pastorn> > fix (++ "NOM") "OM"
18:40:18 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
18:40:18 <lambdabot>         against inferr...
18:40:27 <aavogt> > fix (.) 1
18:40:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
18:40:30 <pastorn> @type (++ "NOM")
18:40:31 <lambdabot> [Char] -> [Char]
18:40:38 <pastorn> @type "OM"
18:40:39 <lambdabot> [Char]
18:40:41 <copumpkin> > fix (fix .) 1
18:40:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:40:42 <pastorn> @type fix
18:40:43 <lambdabot> forall a. (a -> a) -> a
18:40:45 <copumpkin> :P
18:40:49 <pastorn> oh, right
18:40:51 <jmcarthur> @pl \xs -> ((foldr (+) . fix) (0 "^_^") . ((.).fix) (1 "o_O")) xs . fix $ 5 ":D"
18:40:51 <lambdabot> ($ 5 ":D") . (. fix) . foldr (+) (fix (0 "^_^")) . (fix (1 "o_O") .)
18:40:56 <pastorn> gawd
18:41:06 <pastorn> copumpkin: how do i get super magic op powers
18:41:06 <jmcarthur> @let awesomeLength = ($ 5 ":D") . (. fix) . foldr (+) (fix (0 "^_^")) . (fix (1 "o_O") .)
18:41:07 <lambdabot>  Defined.
18:41:13 <pastorn> i seriously need them
18:41:15 <copumpkin> pastorn: beats me
18:41:28 <pastorn> but you have them!
18:41:56 <pastorn> > awesomeLength "jmcarthur sucks ballz"
18:41:57 <lambdabot>   21
18:42:10 --- mode: ChanServ set +o jmcarthur
18:42:16 <jmcarthur> you were saying? ;)
18:42:20 <pastorn> haha
18:42:21 --- mode: ChanServ set -o jmcarthur
18:42:23 <pastorn> :D
18:42:28 <aavogt> > 1 awesomeLength "LoL"
18:42:29 <lambdabot>   1
18:42:41 <pastorn> > fix ("OM N" ++)
18:42:42 <lambdabot>   "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM...
18:42:47 <SubStack> awesome
18:43:06 <pastorn> @src repeat
18:43:06 <lambdabot> repeat x = xs where xs = x : xs
18:43:08 <aavogt> it respects word boundaries too
18:43:40 <pastorn> let rpt x = fix (x :)
18:43:46 <pastorn> > let rpt x = fix (x :)
18:43:46 <lambdabot>   not an expression: `let rpt x = fix (x :)'
18:43:58 <jmcarthur> use @let
18:44:06 <pastorn> @let rpt x = fix (x :)
18:44:06 <lambdabot>  Defined.
18:44:22 <pastorn> > rpt "Lo"
18:44:23 <lambdabot>   ["Lo","Lo","Lo","Lo","Lo","Lo","Lo","Lo","Lo","Lo","Lo","Lo","Lo","Lo","Lo"...
18:44:35 <pastorn> > concat $ rpt "Lo"
18:44:36 <lambdabot>   "LoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLo...
18:44:50 <copumpkin> okay how about we all quit fucking around :P
18:45:02 <aavogt> @let cycl x = fix (x++)
18:45:02 <jmcarthur> @undefine
18:45:03 <lambdabot>  Defined.
18:45:06 <jmcarthur> lol
18:45:12 <aavogt> > cycl "Lo"
18:45:13 <lambdabot>   Not in scope: `cycl'
18:45:17 * BMeph_ resolves to start dicking around instead...
18:45:41 <Hunner> > "Tro" ++ (concat $ rpt "lo")
18:45:42 <lambdabot>   Not in scope: `rpt'
18:45:44 <pastorn> copumpkin: http://farm4.static.flickr.com/3101/2851814771_38b1ff5e57.jpg
18:45:56 <aavogt> hmm, though y is a vowel
18:46:11 <jmcarthur> :t ($ 5 ":D") . (. fix) . foldr (+) (fix (0 "^_^")) . (fix (1 "o_O") .)
18:46:12 <lambdabot> forall b a. (Num b) => [a] -> b
18:46:16 <_Ray_> Hey. Without getting /too/ deep into category theory (but maybe wetting the feet a bit), where's a good explanation about what monads are, and how they relate to the purely-functional side of Haskell?
18:46:26 <copumpkin> okay thank god we have a real question
18:46:27 <jmcarthur> i'm actually surprised that doesn't somehow run into a type ambiguity or something
18:46:43 <copumpkin> _Ray_: how much haskell experience do you have? :P
18:46:49 <aavogt> because the strings aren't overloaded
18:46:52 <pastorn> copumpkin, _Ray_: take that to #haskell-in-depth
18:46:53 * copumpkin is opposed to premature monadicity
18:47:00 <pastorn> this place is for serious beezwax
18:47:02 <aavogt> so it's fine to apply const to them
18:47:11 <_Ray_> About 4 months, in an algorithms course. I won't see category theory for about 10 more months, though.
18:47:24 <jmcarthur> pastorn: i'd say any topic, advanced or not, is better than ($ 5 ":D") . (. fix) . foldr (+) (fix (0 "^_^")) . (fix (1 "o_O") .)
18:47:39 <pastorn> jmcarthur: i wouldn't
18:47:40 <soupdragon> monads ala haskell have nothing to do with category theory
18:47:45 <aavogt> all topics which are better than themselves
18:47:46 <copumpkin> soupdragon: sure they do
18:47:50 <jmcarthur> pastorn: so you want more ($ 5 ":D") . (. fix) . foldr (+) (fix (0 "^_^")) . (fix (1 "o_O") .) then?
18:47:59 <pastorn> why not?
18:48:05 <pastorn> i'm getting used to this :)
18:48:08 <jmcarthur> heh
18:48:49 <aavogt> > 1 `2` 3 :: Int
18:48:50 <lambdabot>   <no location info>: parse error on input `2'
18:48:55 <jmcarthur> aw
18:49:05 <pastorn> chucks
18:49:06 <copumpkin> _Ray_: do you understand functors?
18:49:28 <pastorn> @let two = 2
18:49:29 <lambdabot>  Defined.
18:49:35 <_Ray_> copumpkin, I've seen the terminology in C++ as "Objects who implement operator()", meaning objects that can act as functions.
18:49:36 <sinelaw> hey
18:49:37 <pastorn> > 1 `two` 3
18:49:37 <lambdabot>   2
18:49:44 <copumpkin> _Ray_: it's completely different from that
18:49:53 <danharaj> I hate that terminology.
18:50:09 <copumpkin> _Ray_: haskell functors might be called Mappable in another language (as interfaces or protocols)
18:50:27 <aavogt> @msg lambdabot @let sixty = 60
18:50:28 <lambdabot> Not enough privileges
18:50:33 <aavogt> :(
18:50:56 <aavogt> > let twenty = 20; three = 3 in twenty-three
18:50:57 <lambdabot>   17
18:51:30 <jmcarthur> not confusing at all
18:51:41 <_Ray_> So "fmap :: (a -> b) -> f a -> f b" means that fmap gets a function from a to b, a "functor of a", and returns a "functor of b"?
18:52:05 <pastorn> _Ray_: exactly :)
18:52:14 <pastorn> fmap (+3) (Just 0)
18:52:17 <pastorn> > fmap (+3) (Just 0)
18:52:17 <lambdabot>   Just 3
18:52:44 <SubStack> > fmap (+1) Nothing
18:52:44 <lambdabot>   Nothing
18:52:50 <BMeph_> _Ray_: Or, fmap gets a function from a to b, and returns a function from "functor of a" to "functor of b". :)
18:53:06 <ddarius> Don't say "functor of a"
18:53:07 <_Ray_> Yeah, because of currying.
18:53:18 <_Ray_> And what might a "functor of b" be, in English? (I know "of a" means it's parametrized to type a, similar to "a bag of fruit" or "a list of ingredients")
18:53:40 <BMeph_> ddarius: "functor on a"? ;) "functor `on` a"? ;
18:54:01 <copumpkin> [] is a functor
18:54:09 <copumpkin> [Int] is the functor applied
18:54:22 <jmcarthur> > [(x, y) | x <- [0..9], y <- [0..9], x - y == read (show x ++ show y)]
18:54:23 <lambdabot>   [(0,0)]
18:54:37 <aavogt> appalled to Int
18:55:03 <_Ray_> Oh, so applying a functor to a type is parametrizing the functor?
18:55:25 <copumpkin> the functor is a type constructor that takes a concrete type and returns a (concrete) type
18:55:30 <BMeph_> > [(x, y) | x <- [0..9], y <- [0..9], y - x == read (show x ++ show y)]
18:55:30 <jmcarthur> applying a functor to a type creates a type
18:55:31 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9)]
18:55:44 <ddarius> copumpkin: plus a ...
18:55:44 <copumpkin> it's a function from types to types, you might say, but it must satisfy some additional properties
18:56:36 <pastorn> @src guard
18:56:36 <lambdabot> guard True  =  return ()
18:56:36 <_Ray_> Such as?
18:56:36 <lambdabot> guard False =  mzero
18:56:38 <copumpkin> plus a method fmap that proves that you can take any morphism in the source (pure) category and lift it into the functor (that satisfies some properties)
18:56:43 <copumpkin> _Ray_: like [] or Maybe
18:56:48 <copumpkin> > fmap (+1) (Just 5)
18:56:49 <lambdabot>   Just 6
18:56:51 <copumpkin> > fmap (+1) [1..5]
18:56:52 <lambdabot>   [2,3,4,5,6]
18:57:29 <aavogt> @quote bind
18:57:30 <lambdabot> DavidLeimbach says: Don't play with your monads... eventually you'll go bind.
18:57:33 <jmcarthur> fmap f . fmap g  ==  fmap (f . g)
18:57:44 <jmcarthur> fmap id  ==  id
18:57:54 <copumpkin> the latter one is redundant in haskell
18:57:56 <jmcarthur> one can actually be inferred from the other
18:58:05 <_Ray_> What would "Lift it into the functor" mean?
18:58:06 <jmcarthur> heh, yeah, what he said :)
18:58:20 <aavogt> copumpkin: is it really redundant if you care to consider strictness?
18:58:47 <aavogt> in the presence of undefined values of course
18:58:55 <pastorn> _Ray_: probably 'return' or 'fmap f'
18:59:06 <jmcarthur> aavogt: like   fmap id _|_  ==  _|_   ?
18:59:30 <aavogt> or that fmap id must be as strict as  id
18:59:33 <aavogt> jmcarthur: yes
19:00:40 <_Ray_> Ah, this lifting I assume: http://en.wikipedia.org/wiki/Lift_(mathematics)
19:01:11 <jmcarthur> _Ray_: lifting a function to a functor looks like this:    Functor f => (a -> b) -> (f a -> f b)
19:01:26 <jmcarthur> _Ray_: that's actually just fmap, but i added parens where i think it helps to visualize what's going on
19:01:34 <copumpkin> _Ray_: you can think of map :: (a -> b) -> ([a] -> [b]) as a function that takes a function on pure values and gives you a function on lists
19:01:57 <soupdragon> I think that the arrows aer different
19:02:06 <copumpkin> soupdragon: ?
19:02:08 <soupdragon> like  (a --> b) -> (Fa -> Fb)
19:02:10 <soupdragon> oops
19:02:12 <soupdragon> like  (a --> b) -> (Fa --> Fb)
19:02:20 <jmcarthur> fmap actually takes a function as input and creates a "lifted" version of that function as its output
19:02:21 <soupdragon> if you are talking 'category theory'
19:02:43 <jmcarthur> soupdragon: i think even that is not *quite* fully general in the categorical sense
19:02:51 <soupdragon> what is the fully general one then?
19:02:56 <jmcarthur> but that's just hearsay. i don't know the fully general one
19:03:01 <soupdragon> k
19:03:02 <jmcarthur> i've heard it's not expressible in haskell
19:03:59 <jmcarthur> but i have seen it generalized further to this at least:  (a --> b) -> (Fa ---> Fb)   ... i don't know if that has any actual bearing on category theory though
19:04:52 <jmcarthur> soupdragon: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Categorical.html
19:05:20 * _Ray_ will digest lifting for a few minutes, then come back, thanks :)
19:06:25 * copumpkin is trying to understand swedish train timetables
19:06:39 <pastorn> copumpkin: wut?
19:06:40 <pastorn> need help?
19:06:50 <copumpkin> ooh, perfect
19:06:54 <copumpkin> pastorn: can I PM? :)
19:06:58 <pastorn> NEVAR
19:07:02 <pastorn> of course, silly
19:07:29 <pastorn> what's the matter with people who refuses to take PMs?
19:07:39 <copumpkin> pastorn: omg
19:08:21 <pikhq> ... There exist such people?
19:08:42 <soupdragon> in channels where you get lots of homework peple
19:08:51 <soupdragon> like PM you randomly and demand that you do homework for them
19:09:03 <pikhq> Oh, idjits.
19:09:06 * copumpkin PMs soupdragon for homework help
19:09:18 <gwern> PMs is a serious problem for women
19:09:22 * pikhq PMs pikhq for homework help
19:09:29 <gwern> let's not treat it lightly
19:09:49 <pikhq> pikhq: so, couldyou, like, help me with my Japanese? These kanjis are SO HARD?
19:09:51 <pikhq> pikhq: WTF man?
19:10:45 * applicative warns pikhq that this *might* be a homework question, and should thus not be answered.
19:10:50 <gwern> pikhq: you should switch to korean. hangul is a breeze in comparison
19:11:08 <copumpkin> aw
19:11:10 <pikhq> gwern: I already know the entire Jouyou list man. Not that hard. :)
19:11:48 <gwern> yeah but with hangul once you memorize the 50 or so, then you're done. with japanese 'oh our kanji is in another castle'
19:12:08 <gwern> 'and we don't even know how many thousands more there are'
19:12:32 <pikhq> Pffft. They're almost all composed of a few pieces.
19:12:44 <pikhq> Big deal.
19:13:00 <gwern> that's like saying all images are simple because they're composed of a few pixels
19:13:12 <pikhq> No worse than English spelling.
19:14:01 <pikhq> There's ~100 radicals used in kanji, and they're composed in some fairly simple ways.
19:14:01 <gwern> no, it's worse; at least with an alphabet you get *some* benefit like easy computerization
19:14:36 <gwern> * >100 radicals; fixed your post for you
19:15:03 <pikhq> 馬鹿ね。
19:15:53 <Gracenotes> I've always thought kanji pieces are like various greek/latin/etc. roots. Except for the fact that you basically need to know every single one to write kanji, whereas you can learn English vocab without knowing the roots. And also the fact that radicals correspond badly with semantic meaning. And the variety pronunciations for each one. yeah.
19:16:03 <wli> That must make optical character recognition a lot easier.
19:16:26 <pikhq> Gracenotes: No, individual *kanji* are like the various Greek/Latin/etc. roots.
19:16:41 <gwern> man. OCR is hard enough in english. I wonder how rubbish OCR is for japanese?
19:16:44 <pikhq> Except that more words are composed using them. :)
19:16:59 <Gracenotes> pikhq: doesn't mean the analogy doesn't apply to components within kanji
19:17:21 <pikhq> Gracenotes: Less well.
19:18:24 <Gracenotes> most components and radicals of kanji have a history of their own in the Chinese language. whereas combining them into words, that's a bit more haphazard for the Japanese, considering they had a language before a writing system
19:18:41 <pikhq> It could apply better if Simplified Chinese had worked by fixing the semantics a bit better, rather than just using a heavy dosage of grass script forms.
19:19:14 <pikhq> Or shinjitai, for that matter...
19:19:49 <Gracenotes> perhaps we can turn to our resident expert copumpkin
19:19:57 * gwern unwinds from this heavy discussion by reading about anime. 'Anyway, School Days caused me such disappointment and depression that I'll never be the same. After finishing it, the part of me that knew how to fall in love died! Now I can only understand true love when its in works of fiction.'
19:19:58 <copumpkin> NOES
19:20:31 <gwern> what makes copumpkin our expert? why, he doesn't even seem to be coming from .ja
19:20:41 <copumpkin> wut
19:20:49 <Gracenotes> that's right. disqualified!
19:20:55 <gwern> or am I wrong mr comcast.net
19:21:07 <copumpkin> gwern: U R WRONG
19:21:14 <copumpkin> I R EXPURT
19:21:15 <gwern> yes that's right - I KNOW /WHO
19:21:31 <pikhq> I think I'm a bit more of an expert. I watch anime with neither subs nor dubs!
19:21:32 <pikhq> :P
19:21:40 <Gracenotes> oh, I managed to recommend Higurashi to someone. yes, a single person. I have a poor conversion rate for being a fan of things.
19:21:48 <copumpkin> I can get most of the anime with no subs
19:22:04 <aavogt> or understanding!
19:22:14 <copumpkin> lol
19:22:23 <copumpkin> I mean, I understand most of it
19:22:31 <gwern> Gracenotes: a fellow at RIT gave me a copy of season 1; after watching it, I can never watch slice-of-life rural anime agani
19:22:36 <pikhq> aavogt: No, I follow it just fine.
19:22:42 <gwern> the same way, at least
19:22:56 <marcot> Hi.  I'm trying to build gtk2hs 0.10.1 in Debian sid, and I'm getting an error.  It's strange because the package used to build.
19:22:56 <_Ray_> Small question. Reading about lifting. It says that if I have f :: X -> Y, and there exists g :: Z -> Y, then lifting f onto Z means h :: X -> Z, such that g . h = f. But which g is this? I mean, "lifting f onto Z" doesn't mention a particular g, and it can't possibly hold that f = g . h forall g.
19:22:59 <Gracenotes> oh, you watched season 2, right?
19:23:04 <marcot> https://buildd.debian.org/fetch.cgi?&pkg=gtk2hs&ver=0.10.1-4%2Bb1&arch=amd64&stamp=1266729261&file=log
19:23:13 <gwern> Gracenotes: watched them all eventually
19:23:30 <marcot> Now I'm getting:
19:23:37 <marcot> glib-0.10.1 is unusable due to missing or recursive dependencies:
19:23:43 <marcot> base-4.2.0.0
19:23:44 <gwern> Gracenotes: I keep meaning to play the spiritual successor to higurashi, the island-mansion games, but you know how it is
19:23:52 * gwern really should play my touhou games first
19:24:34 <Philonous> What's with the obsession with japanese culture?
19:24:52 <copumpkin> beats me
19:25:03 <gwern> Philonous: they own all our bases. american geek pop culture is intellectually bankrupt
19:25:20 <gwern> what was hot in the 90s? Xena? Hercules? Buffy? give me a fucking break
19:25:38 <jmcarthur> i thought djinn knew Functor. does it not? can i add it somehow?
19:25:53 <aavogt> @help djinn-add
19:25:54 <lambdabot> djinn-add <expr>.
19:25:54 <lambdabot> Define a new function type or type synonym
19:25:59 <gwern> in comparison, somethign like Evangelion or Cowboy Bebop - oh man I feel ill just comparing them
19:26:15 <jmcarthur> hmm
19:27:17 <jmcarthur> i have no idea how djinn-add is meant to be used there :\
19:27:22 <gwern> (if we could collectively agree to erase anything shown on the SF channel and pretend it was all contemporaneous anime, the world would be a better place)
19:27:42 <aavogt> @wn contemporaneous
19:27:43 <copumpkin> @djinn-add type NotNot a = (a -> Void) -> Void
19:27:44 <lambdabot> *** "contemporaneous" wn "WordNet (r) 2.0"
19:27:44 <lambdabot> contemporaneous
19:27:44 <lambdabot>      adj 1: occurring in the same period of time; "a rise in interest
19:27:44 <lambdabot>             rates is often contemporaneous with an increase in
19:27:44 <lambdabot>             inflation"; "the composer Salieri was contemporary
19:27:46 <lambdabot>             with Mozart" [syn: {contemporary}]
19:27:48 <lambdabot>      2: of the same period [syn: {coetaneous}, {coeval}]
19:28:02 <pastorn> wat?!
19:28:05 <copumpkin> @djinn NotNot (Not a) -> Not a
19:28:05 <pikhq> gwern: Anything? Even Doctor Who?
19:28:05 <Philonous> gwern: Uh, well. I guess I get your point. But somehow I thought "intellectual geek pop culture" was somehow oxymoronic at first blush
19:28:10 <lambdabot> f a b = void (a (\ c -> c b))
19:28:13 <gwern> aavogt: really aavogt? really? did that need defining?
19:28:26 <Gracenotes> not sure you can do typeclasses with djinn
19:28:32 <gwern> pikhq: I've never seen any doctor who, so I reserve judgement
19:28:40 <Gracenotes> at least, not in the most general sense
19:28:45 <aavogt> I was wondering if those extra sylables were used elsewhere
19:28:50 <gwern> with djinn, the safe assumption is that you can't do it :)
19:28:55 <jmcarthur> thanks
19:28:57 <pikhq> gwern: Only "geek pop culture" in the US, though. In the UK, it's just plain pop culture.
19:28:57 <pastorn> @src fix
19:28:57 <lambdabot> fix f = let x = f x in x
19:29:03 <pikhq> (read: most popular show in Britain)
19:29:08 <pastorn> @djinn-add fix f = let x = f x in x
19:29:08 <lambdabot> Cannot parse command
19:29:09 <Gracenotes> particularly with polymorphic data structures, and *especially* with recursive polymorphic data structures
19:29:17 <pastorn> @djinn-add fix = \f -> let x = f x in x
19:29:17 <lambdabot> Cannot parse command
19:30:18 <gwern> pikhq: from the vague memetic reflections of dr. who, I'd probably rank it as tolerable and well below top-notch SF anime like Serial Experiments Lain
19:31:18 <gwern> pikhq: but one series isn't enough to refute a thesis like '90s japanesese geek pop culture pwns '90s american geek pop culture
19:31:19 <pikhq> gwern: It's really got more of a usually-light-hearted fantasy feel to it, really.
19:31:29 <pikhq> Oh, '90s pop culture?
19:31:46 <pikhq> That was one decade Doctor Who *didn't* air during!
19:32:03 <pikhq> (the previous such decade being the '50s...)
19:32:15 <Philonous> gwern: I take it you don't like Lynch's work?
19:32:28 <gwern> Philonous: lynch - he of the Dune movie?
19:32:31 <gwern> he is DEAD TO ME
19:32:43 <Philonous> gwern: He of the Twin peaks series
19:33:12 <gwern> ('but aside from the murder, he was a lovely neighbor')
19:33:55 <gwern> Philonous: anyhoo, you don't think twin peaks was a failure akin to Lost?
19:34:52 <Philonous> gwern: I haven't seen lost.
19:36:06 <gwern> (ah. well, both seem to be 'enigma' shows which failed to satisfyingly resolve the engima. that makes them a failure. like a detective novel where the author presents a culprit but lacks the competence to write the culprit as actually guilty)
19:37:19 <gwern> I read recently that agatha christie would begin writing her novels, but her notebooks show that she wouldn't settle on a villain until way into the novel. now that's skillful
19:39:54 <Philonous> gwern: I don't think that the engima should be resolved at all. What should be resolved is the rest, what commonly is called "reality"
19:41:06 <gwern> well, that's one approach - examine not the mystery but the repercusions and lives affected; but that too requires forethought. agatha christie may be able to write a satisfying mystery on the fly; but the writers of lost or twin peak are no agatha christies
19:46:27 <gwern> huh. David Brin agrees with me about Lost
19:46:34 <gwern> 'But I don’t expect that from a saga like LOST, where the writers, though brilliant, were also clearly passing around a bong at every story session, shouting at each other “Hey, wait! What if they then turn around and see THIS!!!”'
19:46:55 <Philonous> I tend to agree. Btw. that's a good approach to science fiction in general, not to concentrate on the science, but on it's ramifications.
19:47:42 <pikhq> Philonous: I'd argue that the whole point of science fiction is the *effect* of things, not just "oooh neat tech".
19:48:22 <pikhq> Which leaves me being rather disappointed in Star Trek, for instance, a lot of the time.
19:48:50 <gwern> pikhq: well, I wouldn't really call a novel like _Dune_ or _A Fire Upon the Deep_ the 'effect of things' style of SF, but they're still damn good
19:49:04 <Philonous> pikhq: That's what I meant. If sci fi writer have to say anything interesting at all, then it would be about the impact even of sometimes subtle technological differences
19:49:19 <pikhq> gwern: Mmm, true.
19:49:30 <Philonous> gwern: I wouldn't call them sci fi, rather space opera
19:49:45 <pikhq> Though I'm not entirely sure those are even sci-fi, but rather a space fantasy or some such.
19:49:57 <gwern> so we might want to say that most good SF falls into either 'alternate universe building' or 'effect of things'
19:53:43 <Philonous> Maybe I'm spoiled by Stanisłav Lem's Works
19:53:45 <applicative> marcot, do you have cabal install?  It looks like you have ghc 6.12.something.
19:54:07 <applicative> damn, just missed him.
19:57:48 <c_wraith> Hmm.  How does one implement Typeable without deriving it?
19:58:20 <pastorn> @hoogle Typeable
19:58:20 <lambdabot> module Data.Typeable
19:58:20 <lambdabot> Data.Typeable class Typeable a
19:58:20 <lambdabot> Data.Typeable class Typeable1 t
19:59:12 <applicative> class Typeable a where typeOf :: a -> TypeRep
19:59:19 <pastorn> what is this? instance [overlap ok] Typeable Int
19:59:22 <pastorn> overlap?
19:59:45 <c_wraith> It means that module was compiled with OverlappingInstances
19:59:58 <pastorn> oh, ok
20:01:03 <applicative> it means that the programmer has met a proof obligation....
20:01:41 <c_wraith> I guess I need to work with the various functions to build up a TypeRep from internal ones
20:01:57 <Cale> c_wraith: Yes, I suppose you could...
20:02:04 <Cale> c_wraith: Why do you want to do that?
20:02:35 <c_wraith> I can't derive it for this type, since it has kind (* -> *) -> * -> *
20:03:21 <danharaj> Isn't that just applying the first argument to the second?
20:03:37 <c_wraith> kinds are not types
20:03:37 <danharaj> (I don't see how else you could define that signature)
20:03:53 <c_wraith> kinds don't work like types
20:04:00 <copumpkin> that's a monad transformer, probably
20:04:02 <Cale> Well, they do, sort of
20:04:09 <c_wraith> it is a monad transformer, yes
20:04:30 <aavogt> so make a typeable instance for the applied type
20:04:38 <Cale> It's analogous to a function (Int -> Int) -> Int -> Int
20:04:44 <aavogt> :k Typeable2
20:04:45 <lambdabot> Class `Typeable2' used as a type
20:05:00 <aavogt> @hoogle Typeable2
20:05:00 <lambdabot> Data.Typeable class Typeable2 t
20:06:20 <aavogt> c_wraith: standalone deriving maybe?
20:06:46 <Cale> You might be able to mimic Typeable2, but with a different kind
20:07:35 <aavogt> or   instance Typeable1 m => Typeable1 (t m :: * -> *) ...
20:07:38 <pastorn> @hoogle Typeable2
20:07:38 <lambdabot> Data.Typeable class Typeable2 t
20:07:50 <aavogt> class Typeable2 t where typeOf2 :: t a b -> TypeRep
20:08:03 <pastorn> oh, ok
20:08:08 <c_wraith> aavogt, if I do that, don't I need to contruct a TypeRep?
20:08:09 <pastorn> parameterised types :)
20:08:32 <c_wraith> which is what I was asking how to do in the first place
20:08:32 <aavogt> deriving instance Typeable1 m => Typeable1 (t m :: * -> *) -- does this work?
20:08:43 <c_wraith> I'll give it a shot
20:10:00 <aavogt> @hoogle TypeRep
20:10:01 <lambdabot> Data.Typeable data TypeRep
20:10:01 <lambdabot> Data.Typeable typeRepArgs :: TypeRep -> [TypeRep]
20:10:01 <lambdabot> Data.Typeable typeRepKey :: TypeRep -> IO Int
20:10:39 <aavogt> @hoogle mkTyConApp
20:10:40 <lambdabot> Data.Typeable mkTyConApp :: TyCon -> [TypeRep] -> TypeRep
20:12:05 <c_wraith> Yeah, all it's telling me is that it can't derive typeable for a type constructor with an argument that's not of kind *
20:13:41 <aavogt> well anyhow, you can construct those typereps with mkTyConApp and mkTyCon, and recursive calls to typeOf
20:15:20 <c_wraith> Looks like that's the answer
20:18:29 <c_wraith> Oh.  I see why it can't derive Typeable.  This isn't straightforward at all.
20:19:32 <pastorn> c_wraith: maybe it has to do with the paramerised stuff?
20:19:52 <pastorn> deriving shouldn't fail, right?
20:19:58 <pastorn> so Data a b = D a b
20:20:15 <pastorn> and derive Typeabel for that would cause a kind error, wouldn't it?
20:20:35 <c_wraith> there's no higher kind in the arguments to, umm..  I'll pretend you named that D
20:21:08 <pastorn> data D a b = D a b
20:21:10 <pastorn> there
20:21:24 <c_wraith> that just has kind * -> * -> *
20:21:33 <Cale> data D a b = D (a b)
20:21:34 <Cale> there :)
20:21:38 <c_wraith> there you go. :)
20:22:12 <aavogt> you may restrict the kind in a data decl?
20:22:25 <pastorn> Cale: hmm... but don't you have to make a difference between 'container' types and actual types?
20:22:58 <copumpkin> aavogt: sur
20:23:07 <copumpkin> aavogt: you might need KindSignatures
20:24:57 * edwardk waves hello,
20:24:58 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
20:25:09 <Cale> pastorn: Well, the type variable 'a' there will have to refer to a type constructor
20:25:15 <c_wraith> @kind RWST
20:25:17 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
20:25:25 <danharaj> what is a RWST
20:25:29 <c_wraith> That's the real problem.  This is a newtype around *that*
20:25:30 <edwardk> cale: damn you and your mention of manufactoria ;)
20:25:31 <copumpkin> the world's most mysterious type
20:25:35 <Cale> edwardk: :)
20:25:41 <aavogt> reader writer state tran
20:25:41 <copumpkin> danharaj: nobody knows!
20:25:42 <edwardk> Cale: just finished metatron
20:25:58 <aavogt> for your monads
20:26:17 <Cale> edwardk: Which one was that again?
20:26:23 <edwardk> add A + B
20:26:37 <danharaj> still confused :p
20:26:45 <edwardk> comes after check if A > B
20:26:54 <copumpkin> danharaj: there are better ways of dealing with confusion than parting the channel
20:26:58 * danharaj jiggles
20:27:03 <danharaj> hit a button :p
20:27:30 <aavogt> @unmtl RWST r w s IO a
20:27:31 <lambdabot> r -> s -> IO (a, s, w)
20:27:41 <dolio> "Jiggles"?
20:28:09 <aavogt> @unmtl RWST r w s RWST
20:28:09 <lambdabot> err: `RWST r w s RWST' is not applied to enough arguments.
20:28:11 <dolio> Like Jell-O?
20:28:33 <edwardk> cale: i kept expecting them to ask you to implement a 4-color 7 state turing machine ;)
20:28:35 <danharaj> metaphorically
20:28:38 <copumpkin> @unmtl RWST r w s (RWST a b c (ST s))
20:28:38 <lambdabot> err: `RWST r w s (RWST a b c (ST s))' is not applied to enough arguments, giving `/\A. r -> s -> a -> c -> ST s (A, s, w, c, b)'
20:28:57 <aavogt> those are some good error messages
20:29:03 <copumpkin> indeed
20:29:06 <copumpkin> big lambdas are cute
20:29:12 <copumpkin> who needs polymorphism
20:29:25 <dolio> That is polymorphism.
20:29:29 <aavogt> @unmtl RWST a l s (RWST x y z IO) a
20:29:30 <lambdabot> a -> s -> x -> z -> IO (a, s, l, z, y)
20:29:36 <copumpkin> *who needs implicit polymorphism
20:29:37 <copumpkin> better?
20:30:04 <danharaj> Just wondering, how many type annotations do you guys put in your code?
20:30:05 <aavogt> oh, that's rather confusing since I reused `a'
20:30:14 <copumpkin> danharaj: 17 each file
20:30:15 <aavogt> danharaj: I have more annotations than code
20:30:15 <danharaj> I tend to put in most of the toplevel ones
20:30:36 <danharaj> I only omit them when it's obvious to me what the type is, and that is rarely the case :p
20:30:45 <aavogt> which is puzzling because annotations count as code
20:31:01 <dolio> I annotate all top-level stuff.
20:31:16 <c_wraith> I wonder if I can get this to work by using ScopedTypeVariables and undefined.
20:31:44 <edwardk> copumpkin: in response to your AD question: afraid not. ;) though you could make a numeric instance that defined operations on ADTs with a show instance that showed the result you want and differentiation that ;)
20:31:45 <aavogt> scopedtypevariables doesn't really let you do any more than usual
20:31:54 <aavogt> it's just significantly prettier
20:32:01 <danharaj> Do you guys thing complete type inference is a neccesity for a functional language?
20:32:08 <copumpkin>  danharaj nope
20:32:11 <edwardk> danharaj: no, but it helps
20:32:12 <copumpkin> although it's nice
20:32:26 <aavogt> haskell has no complete type inference
20:32:28 <Cale> danharaj: Haskell doesn't have complete type inference.
20:32:43 <danharaj> It doesn't?
20:32:49 <danharaj> (Haskell 98)
20:32:51 <Cale> Typeclasses ruin it
20:32:52 <c_wraith> aavogt: it lets me say typeOf (undefined :: a) without having to figure out how to get an a.
20:32:52 <Cale> yeah
20:32:58 <dolio> You must annotate polymorphic recursive functions.
20:33:17 <gwern> (well, with extensions I'm sure there's stuff without type inference)
20:33:25 <gwern> dolio: how do you mean?
20:33:41 <dolio> > let f x 0 = show x ; f x (n+1) = f (x,x) n in f 5 3
20:33:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
20:33:42 <Cale> I think it's essential to have good-enough type inference.
20:33:58 <dolio> > let f :: Show a => a -> Int -> String ; f x 0 = show x ; f x (n+1) = f (x,x) n in f 5 3
20:33:59 <lambdabot>   "(((5,5),(5,5)),((5,5),(5,5)))"
20:34:03 <aavogt> c_wraith: well you can get an `a' somehow if your class/instance fixes enough type variables to be chosen anyhow
20:34:12 <danharaj> Cale: I think so too, I just don't know what "good enough" is.
20:34:18 <aavogt> though perhaps functional dependencies break that property
20:34:22 <copumpkin> Cale: that's well defined
20:35:04 <Cale> What "good-enough" means depends on what type system features you have, but I think that HM is a good baseline
20:36:12 <Cale> That is, if you write programs which only have HM types, I think it's reasonable to expect their types to be inferred.
20:37:02 <jbapple> I think even without typeclasses you can get incomplete type inference in Haskell 98 by using non-regular data types
20:37:05 <Cale> and then beyond that, probably you want it so that explicit signatures are for the most part only required for things which have "fancy" types.
20:37:11 <ezyang> Does the sum of two types form a bifunctor?
20:37:24 <dolio> Yes. The Show example is just easier.
20:37:27 <Cale> ezyang: yes
20:37:33 <ezyang> kk
20:37:35 <copumpkin> ezyang: same with product
20:37:35 <jbapple> dolio: fair enough
20:37:39 <dolio> And doable in lambdabot. I'm not sure if there are any nested types defined in it.
20:37:43 <danharaj> Well, not all type?
20:38:01 <danharaj> nevermind. I was thinking o fsomething else.
20:38:26 <Cale> (and not the things which use the things with fancy types)
20:38:44 <dolio> Any nested type pretty naturally leads to needing polymorphic recursion, though.
20:39:30 <dolio> For the catamorphism, for instance.
20:39:33 <Cale> I still don't really understand what's difficult about polymorphic recursion. I'll have to look into that sometime.
20:39:53 <systemfault> Will I be able to use the cool haskell jargon one day?
20:40:06 <ezyang> Yes!
20:40:19 <systemfault> I don't remember having used the word catamorphism ever :(
20:40:32 <danharaj> fold, abstracted.
20:40:35 <dolio> Cale: At the very least, it'd probably require delaying the occurs check until you can decide whether you can generalize a variable.
20:40:47 <copumpkin> its dual is the dogomorphism
20:40:53 <BMeph_> Are there any useful functions that are idempotent, but not associative or commutative (or either)?
20:41:01 <dolio> And delaying other unification, too.
20:41:16 <dolio> If you make a recursive call with (), you can't set the relevant type to ().
20:41:18 <ezyang> BMeph_: Lots of math isn't assoc/commut?
20:41:20 <dolio> Otherwise you get:
20:41:29 <dolio> @type let f x = f () in f
20:41:30 <lambdabot> forall t. () -> t
20:41:41 <copumpkin> BMeph: idempotent things tend to be unary
20:41:50 <danharaj> BMeph: functions with respect to what operation? composition? Composition is associative.
20:41:56 <applicative> BMEph_ dont we naturally say idempotent where f f x = f s
20:42:06 <applicative> like copumkin said
20:42:06 <copumpkin> oh I see what you mean
20:42:17 <ezyang> I must be miunderstanding what idempotent means
20:42:28 <ezyang> o i c
20:42:29 <copumpkin> you can see it in two ways
20:42:44 <copumpkin> the composition is idempotent
20:42:51 <Cale> dolio: hmm, okay
20:42:53 <aavogt> so    x + y = x + (y + y) = (x + y) + y?
20:43:31 <aavogt> or do you have a formulation of idempotent for binary ops that doesn't make it look associative?
20:43:56 <danharaj> I think idempotents always satisfy that equation regardless of the associativity of the general structure??
20:44:22 <ezyang> Is there a function in stdlib that is as such: mysteryFunc f g h = g . h . f
20:44:33 <ezyang> @pl \f g h = g . h . f
20:44:34 <lambdabot> (line 1, column 8):
20:44:34 <lambdabot> unexpected "="
20:44:34 <lambdabot> expecting pattern or "->"
20:44:41 <ezyang> @pl \f g h -> g . h . f
20:44:42 <lambdabot> flip ((.) . (.)) . flip (.)
20:44:43 <aavogt> @type (.) . (.)
20:44:44 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:44:50 <dolio> Looks like bimap for (->)
20:45:00 <pastorn> @type tits
20:45:00 <lambdabot> Not in scope: `tits'
20:45:11 <pastorn> @let tits = ((.) . (.))
20:45:12 <lambdabot>  Defined.
20:45:14 <ezyang> But it's contravariant in one?
20:45:32 <dolio> Yes. (->) :: Hask^op x Hask -> Hask.
20:46:21 <dolio> Your version may have f and g backwards. It's hard for me to tell just by looking.
20:46:56 <ezyang> (f -> g) h = g . h . f (g <- f) h = g . h . f
20:47:04 <ezyang> erm, there should be a break between f and (g
20:48:52 <dolio> @type \f g h -> g Prelude.. h Prelude.. f
20:48:53 <lambdabot> forall c b c1 a. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
20:49:13 <dolio> I guess that looks right.
20:49:50 <dolio> b goes to a (opposite) and c1 goes to c (same).
20:50:55 <dolio> Anyhow, I'm not even sure if category-extras will have that.
20:51:08 <ddarius> It should.
20:52:17 * BMeph_ is reminded of "bracket"...
20:52:46 <edwardk> dolio: have what?
20:52:57 <tommd> lpsmith: You were asking about a secure RNG earlier?
20:53:07 <ddarius> edwardk: Do you have category-extras on highlight or just category?
20:53:10 <dolio> map for a C^op x C -> D functor.
20:53:21 <lpsmith> tommd, aye
20:53:27 <lpsmith> I'm using urandom
20:53:27 <edwardk> ddarius: nah, just happened to look over =)
20:53:48 <tommd> lpsmith: Use "/dev/random" to seed and periodically add additional input to a DRBG
20:53:58 <dolio> Ah, you do.
20:53:59 <tommd> It just so happens I've implemented NIST SP 800-90
20:54:04 <lpsmith> sweet
20:54:05 <tommd> Cryptographically secure DRBG
20:54:14 <edwardk> dolio: sounds a bit like the ExpFunctor code. lemme check if its in category-extras or just mentioned on the blog
20:54:27 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Exponential.html
20:54:28 <gwern> @quote as.one.does
20:54:28 <lambdabot> ndm says: I was browsing through the Yhc standard libraries, as one does on the weekend, and was drawn to Yhc's sort function.
20:54:29 <edwardk> ?
20:54:30 <lpsmith> well, for what I need,  /dev/urandom is plenty fast enough
20:54:39 <tommd> lpsmith: Use at your own risk for now (though the KATs are passing) and know the interface might change... or more likely a second, higher level interface will be built.
20:54:40 <dolio> Well, you could do it that way, too.
20:54:48 <dolio> I was thinking bimap for (->).
20:54:53 <edwardk> ah
20:55:08 <tommd> lpsmith: Good, because this is _much_ slower than urandom, but if you are fine with urandom then I suppose there is no reason for you to switch.
20:55:37 <edwardk> i have a bifunctor with selectable categories, which can get you there, ExpFunctor, forces C = Hask, (No CExpFunctor, sorry) ;)
20:55:49 <dolio> :)
20:55:49 <tommd> Just figured I'd let you know its out there if you had a specific need for really high quality RNGs
20:55:54 <lpsmith> but looking over hackage, that does seem to be a potential weakness
20:56:06 <tommd> Well this should certainly fill the void.
20:56:41 <lpsmith> It'd be nice to at least have an abstraction layer over urandom and CryptGenRandom
20:56:58 <tommd> lpsmith: Add it to the discussion about the new Crypto package.
20:57:07 <edwardk> so perhaps just Bifunctor from http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor.html ?
20:57:45 <dolio> Yes, that looks like it will work.
20:57:54 <copumpkin> @typo let almostBimap a b c x = a (c (b x)) in almostBimap
20:57:55 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t3) -> (t3 -> t) -> t2 -> t1
20:58:10 <ddarius> copumpkin: Ugh.
20:58:15 <edwardk> blech
20:58:17 <dolio> Well, it probably won't be pleasant. It won't just be bimap.
20:58:20 <danharaj> does A + (A , X) have an initial algebra? Is it the type of all non-empty finite lists?
20:58:33 <copumpkin> wow, I got two different people to be disgusted
20:58:38 <ddarius> danharaj: You mean \X.A+(A,X) ?
20:58:39 <dolio> Because you'll need to wrap one thing in a flip newtype.
20:58:39 * copumpkin rubs his hands in evil glee
20:59:01 <copumpkin> mapContraMap?
20:59:03 <danharaj> ddarius: Yes, I am sloppy
20:59:23 <ddarius> danharaj: Every polynomial type in Haskell has an initial algebra.
21:00:00 <danharaj> gotcha
21:00:02 <ddarius> Arguably Mu F is the initial algebra for F in Haskell for any functor F.
21:00:13 <dolio> edwardk: Come to think of it, expfunctor isn't right, because there's no way for it to have the most general type for \f g h -> g . h . f
21:00:19 <danharaj> :t Mu
21:00:20 <lambdabot> Not in scope: data constructor `Mu'
21:00:25 <danharaj> @kind Mu
21:00:25 <lambdabot> (* -> *) -> *
21:00:27 <ddarius> danharaj: And yes, that would be equivalent to a type of non-empty lists.
21:00:30 <lpsmith> tommd, link?
21:00:32 <dolio> The only way to get that for an expfunctor is F a = (a -> a)
21:00:35 <ezyang> I wonder if category-extras has a bifunctor
21:00:42 <copumpkin> ezyang: it sure does!
21:00:51 <ezyang> Where?
21:00:52 <edwardk> dolio: fair enough
21:00:58 <c_wraith> is there a trifunctor, too?
21:01:00 <edwardk> ezyang: control.functor
21:01:13 <ezyang> aha!
21:01:14 <edwardk> ezyang: under PFunctor and QFunctor
21:01:24 <danharaj> ddarius: I am curious, \X.1+(A,X), the final coalgebra of that functor. How is the anamorphism defined?
21:01:26 <copumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor.html#t%3ABifunctor
21:01:35 <edwardk> which are the halves of it needed to support 'first' and 'second' respectively
21:01:48 <edwardk> (for use when the other type is unresolvable)
21:02:06 <copumpkin> edwardk: P and Q stand for letters of the alphabet?
21:02:11 <copumpkin> :P
21:02:13 <edwardk> yeah =)
21:02:24 <ezyang> Nasty little impl :^)
21:02:26 <copumpkin> Pee and Queue
21:02:32 <ddarius> copumpkin: P and Q are often used for the projections of a comma category.
21:02:36 <copumpkin> Queueueueue
21:03:01 <edwardk> ezyang: i welcome a cleaner implementation that types in all of the scenarios this one does ;)
21:03:05 <copumpkin> @get-shapr
21:03:05 <lambdabot> shapr!!
21:03:13 <ezyang> edwardk: I doubt one exists :-)
21:04:09 <tommd> lpsmith: http://www.haskell.org//pipermail/libraries/2010-May/013688.html
21:04:10 <ddarius> unfold phi = In . fmap (unfold phi) . phi
21:04:35 <JoeyA> @src product
21:04:35 <lambdabot> product = foldl (*) 1
21:05:06 <c_wraith> > product []
21:05:07 <lambdabot>   1
21:05:17 <JoeyA> Does GHC's product function tend to use a divide and conquer technique?
21:05:27 <copumpkin> JoeyA: no
21:05:59 <ddarius> danharaj: For that particular functor, the unfold is basically unfoldr.
21:06:01 <copumpkin> I'm assuming split it into chunks because (*) is associative?
21:06:05 <copumpkin> is what you mean
21:06:13 <danharaj> :t unfoldr
21:06:13 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
21:06:14 <ddarius> (*) isn't associative.
21:06:23 <copumpkin> tends to be
21:06:54 <copumpkin> nobody ever talks about alternative operations :(
21:07:00 * copumpkin strokes alternative to make it feel loved
21:07:19 <ezyang> The bifunctor type looks kind of funny
21:08:03 <ezyang> If I want to express that I have a bifunctor for functions f : a -> b, g : -> d, such that bimap f g : Bifunctor a c -> Bifunctor b d, how would I properly express that with category-extras?
21:08:15 <ezyang> (notation is very loose here but hopefully meaningful)
21:08:17 <danharaj> ddarius: right yeah >_< ok. For the initial algebra, we have constructors nil and cons. For the final coalgebra do we have total head and tail?
21:09:03 <dolio> No.
21:09:24 <ddarius> danharaj: You can think of it that way if you like.
21:09:58 <dolio> You have observe :: Colist a -> Maybe (a, Colist a)
21:10:32 <danharaj> dolio: right, Colist a -> 1 + (a, Colist a)
21:10:41 <dolio> Yes.
21:10:58 <dolio> Streams have total head and tail.
21:11:14 <dolio> But the functor in question is SX = A * X.
21:11:33 <ddarius> dolio: I viewed "total head and tail" as head :: Colist a -> Maybe a; tail :: Colist a -> Maybe (Colist a)
21:11:44 <dolio> Oh.
21:11:46 <danharaj> dolio: what ddarius said :p
21:14:28 * hackagebot cabal2arch 0.7.2 - Create Arch Linux packages from Cabal packages  http://hackage.haskell.org/package/cabal2arch-0.7.2 (DonaldStewart)
21:14:39 <danharaj> It seems to me that Mu \X.A+(A,X) and Mu \X.(A,X) have the same elements?
21:14:44 <danharaj> or amidoinitrong
21:14:58 <ddarius> danharaj: No, one can terminate the other can't.
21:15:24 <ddarius> And technically the latter is empty in typical cases where Mu /= Nu.
21:15:28 <danharaj> ddarius: the first one is finite, the second one is necessarily finite
21:15:39 <danharaj> oh, uh
21:15:50 <danharaj> (what's a Nu)
21:16:14 <ddarius> The greatest fixpoint operator versus Mu the least fixpoint operator.  In Haskell they are the same.
21:16:24 <danharaj> oh
21:16:43 <danharaj> Because Haskell does not distinguish data from codata, right?
21:17:30 <ddarius> You can say that, though that's kind of like saying Mu == Nu in Haskell because Mu == Nu in Haskell.
21:19:34 <ezyang> Oh, it's just Bifunctor t Hask Hask Hask eh
21:20:36 <danharaj> ddarius: well, uh... Ok. For the List functor List X = 1 + A*X , we have Mu List fitting inside of Nu List in an natural injection. Is this true for all polynomial functors?
21:21:04 <copumpkin> mu list sitting inside of nu list?
21:21:26 <edwardk> ezyang: yeah instance Bifunctor SwedishChef Bork Bork Bork
21:21:39 <ddarius> danharaj: It depends on what you mean.  What category do you want these injections in?
21:22:02 <danharaj> ddarius: I'm not sure. I am most comfortable in Set I guess, so perhaps we should work in Set.
21:22:52 <ezyang> Hahaha
21:23:14 <ezyang> edwardk: So, what precisely is the technical need for the three Hasks? I understand what they represent, but don't understand what would happen if I tried to get rid of them.
21:23:55 <dolio> They represent the two source and one target category.
21:23:59 <edwardk> danharaj: one way to do it would be to play with them as newtype Mu f = Mu (forall b. (f a -> a) -> a); data Nu f = forall b. Nu a (a -> f a) -- then swap out the category Hask by changing -> for another category
21:24:18 <dolio> Bifunctor t Hask Hask Hask isn't right, presumably. One has to be Hask^op.
21:24:32 <dolio> If we're talking about the g . h . f from earlier.
21:24:43 <ezyang> dolio: Nope, totally different now
21:24:46 <dolio> Oh.
21:24:51 <ezyang> Just a plain ole bifunctor
21:24:52 <edwardk> danharaj: in Hask you can define a natural isomorphism from Mu <-> Nu. but if you swap out -> for another category, you can find categories where you can't
21:25:02 <dolio> Well, in that case, that's the answer.
21:25:16 <dolio> Bifunctors are C x D -> E in general.
21:25:35 <edwardk> ezyang: what dolio said. he beat me to it ;)
21:25:42 <ezyang> Yeah, but there isn't going to be a reasonable instance of Bifunctor that doesn't use Hask Hask Hask, is there?
21:25:49 <edwardk> ezyang: you can define a simpler bifunctor, in which case you only need one category
21:25:55 <dolio> (->) is one.
21:25:56 <edwardk> ezyang: sure there is
21:26:02 <ezyang> Ok, so you were just being general.
21:26:04 <edwardk> Bifunctor (Dual Hask) Hask Hask
21:26:06 <danharaj> :| I'm going to bed. /headdesk
21:26:07 <edwardk> (->)
21:26:10 <edwardk> =)
21:26:11 <ezyang> ohhh, right
21:26:19 <ezyang> ^_^
21:27:05 <edwardk> danharaj: if you want a simple example of where Mu /= Nu try using the category data Iso a b = Iso (a -> b) (b -> a)
21:27:13 <pastorn> :k (->)
21:27:14 <lambdabot> ?? -> ? -> *
21:27:21 <pastorn> right...
21:27:35 <copumpkin> pastorn: domain, codomain, and it makes you a pretty type
21:27:35 <edwardk> pastorn: the funny ?'s are just so it can support unboxed types
21:27:49 <dolio> Well, Mu /= Nu in Set, even.
21:27:53 <pastorn> edwardk: oh, ok
21:27:58 <pastorn> what's all this Mu business?
21:28:06 <copumpkin> pastorn: type-level fixed points
21:28:18 <edwardk> dolio: sure, just was easier to allow him to beat his head against something straight in haskell ;)
21:28:20 <copumpkin> for data and codata
21:29:31 <ddarius> danharaj: For any category, you can construct a unique arrow from the initial algebra of some functor to the final coalgebra of that functor assuming both exist.
21:32:14 <danharaj> thanks for entertaining my questions.
21:33:15 <dolio> It actually follows pretty readily from the universal properties.
21:33:51 <danharaj> dolio: yeah, but I asked if it were an injection always
21:34:06 <ddarius> Lambek's lemma gives you the necessary coalgebra given an initial algebra so that you can apply the final coalgebra universal property and vice versa.
21:36:39 <ezyang> Another question: does category-extras have a constant functor?
21:37:36 <ezyang> It seems kind of not useful, but maybe I'm missing something
21:38:36 <ddarius> The constant functor is handy, though it is much more handy when not restricted to Hask.
21:39:14 <edwardk> ezyang: it has a Const bifunctor: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Combinators-Const.html and there is the Const functor from Control.Applicative that i don't duplicate
21:39:42 <ezyang> oh, it's in control applicative? handy.
21:53:30 <ezyang> One more question :o). Is there a nice type corresponding to Bifunctor t Hask Hask Hask, Functor f, Functor g => b (f a) (g a)?
21:53:40 <ezyang> s/b/t/
21:59:12 <edwardk> "Biff"
21:59:26 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Combinators-Biff.html
21:59:56 <edwardk> the bifunctor functor functor functor ;)
22:01:43 <ezyang> Excellent.
22:01:55 <ezyang> Where does the name Biff come from, by the way?
22:02:45 * hackagebot graphmod 1.2 - Present the module dependencies of a program as a "dot" graph.  http://hackage.haskell.org/package/graphmod-1.2 (IavorDiatchki)
22:09:48 * hackagebot tagsoup 0.10 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.10 (NeilMitchell)
22:11:47 <edwardk> ezyang: mostly from the fact that "BifunctorFunctorFunctorBifunctor" was way too long ;)
22:14:11 <edwardk> There are Biff p f g a b ~ p (f a) (g b) and Lift p f g a ~ p (f a) (g a), Const2 t a b ~ t, Join p a ~ p a a, Of f p a b ~ f (p a b), and Flip p a b ~ p b a, where possible they are named after their term level equivalents
22:15:28 <ezyang> *nod*
22:16:33 <edwardk> (and a bunch of type aliases, On, PAp, PCofree, PFree, etc. i don't know if Clowns and Jokers are still in there
22:16:37 <ezyang> fwiw, Fokkinga et al. define Biff p f g a a as (let † be bifunctor) A_(f†g). Way short :^)
22:17:06 <edwardk> that would be Lift in category-extras parlance iirc
22:17:35 <ezyang> Oh, I see.
22:18:11 <edwardk> and yeah Fokkinga can be a little tricky to read
22:19:58 <ezyang> "This is the subject of tomorrow's blog post :-)"
22:20:08 <edwardk> ah
22:20:34 <edwardk> i'm just trying to finish up my ad library so i can move on to other things ;)
22:21:21 <ezyang> Completionist instinct is good.
22:36:36 <ezyang> I'm rereading dolio's comments \f g h -> g . h . f is a bimap for (->). I'm kind of wondering if it's not a dimap for (->)
22:36:54 <dolio> What's dimap?
22:37:11 <copumpkin> bimap on dual of the first one I think
22:37:17 <ezyang> ==
22:37:41 <copumpkin> it should be contravariant in one of them
22:37:49 <dolio> Oh, then yes.
22:38:11 <ezyang> And the other question is if it's actually reader (->), or coreader
22:38:35 <k23z__> when I try to cabal install SDL I get
22:38:35 <k23z__> setup.exe: sh: runGenProcess: does not exist (No such file or directory)
22:38:37 <k23z__> what is that ?
22:38:40 <copumpkin> Coreader is boring
22:38:43 <copumpkin> as hell
22:38:51 <copumpkin> iirc
22:39:07 <copumpkin> isn't it just (,)?
22:39:25 <dolio> (,) r
22:39:32 <ezyang> Oh, ha. That is pretty boring
22:40:31 <ezyang> But to use dimap, I need some bifunctor, and I don't know which one I want.
22:42:21 <k23z__> c/,,\
22:44:45 <copumpkin> we need a dependent n-functor
22:45:31 <copumpkin> for certain values of "need"
22:46:40 <ezyang> Really?
22:47:01 <copumpkin> what, you don't?
22:47:10 <copumpkin> I certainly need it
22:47:21 <ezyang> I don't really grok.
22:48:59 <copumpkin> just saying stupid stuff that only barely makes any sense
22:50:57 <ezyang> Ok.
22:51:09 * ezyang gives up trying to shoehorn this function into category extras and will just write it out explicitly 
22:51:26 <edwardk> ezyang: heh what is the function?
22:51:58 <ezyang> \f g h -> g . h . f
22:52:04 <edwardk> ah
22:52:14 <edwardk> ok, next question, why? =)
22:52:39 <ezyang> Because Fokkinga defines an operator that does specifically that, and that implied to me some deep significance..
22:52:57 <edwardk> in his ph.d dissertation?
22:53:19 <ezyang> No, in the Banana Lenses paper
22:53:20 <dolio> It's an intro to category theory.
22:53:23 <edwardk> ah
22:53:29 <dolio> Oh.
22:53:31 <ezyang> dolio: Nope, not that one :^)
22:55:02 <k23z__>  When I try to "cabal install SDL" I get ->    setup.exe: sh: runGenProcess: does not exist (No such file or directory)
22:55:35 <ezyang> k23z__: Can you install any cabal packages, or is just SDL failing?
22:55:48 <k23z__> ezyang, I installed some and they worked
22:56:04 <ezyang> Ok. Are you following the WIN32 instructions for SDL?
22:56:12 <ezyang> It's an FFI, so you probably need to setup the compiler toolchain
22:56:18 <ezyang> http://mirror.seize.it/hsSDL/hssdl/WIN32
22:56:23 <k23z__> ezyang, link with WIN32 instructions for SDL please ?
22:57:13 <ezyang> just did
22:58:39 <BMeph_> So, the excerpt from his dissertation. :)
22:59:04 <k23z__> ezyang, "3. Modify SDL.cabal file from hsSDL distribution"
22:59:11 <k23z__> ezyang, where is SDL.cabal ?
22:59:20 <k23z__> BMeph_, dissertation ? whos ?
22:59:55 <BMeph_> k23z__: Earlier convo, get your problem settled first. :)
22:59:56 <ezyang> run "cabal unpack SDL"
23:00:41 <ezyang> BMeph_: Haha.
23:03:24 <triyo> Is this a right statement to make: "In principle, Haskell programming language doesn't have to worry about Null pointer exceptions as all values are constant and cannot be variable. So there can never be a pointer reference to null, hence no Null Pointer runtime exceptions can occur."
23:03:43 <copumpkin> well, not quite
23:03:58 <triyo> It's just some comment I'm making and what to confirm my own understanding first of course. :)
23:04:21 <copumpkin> types are sets of values, and in java or similar languages all (non-primitive) types have an additional element
23:04:22 <triyo> copumpkin: hmm how so? Could you elaborate.
23:04:23 <copumpkin> which is null
23:04:29 <ibid> triyo: it's literally true, but ...
23:04:42 <ezyang> triyo: constant and variableness doesn't have much to do with it
23:04:55 <copumpkin> in haskell, our types are more real and don't include implicit nulls
23:04:55 <ezyang> I can get null pointer exceptions while programming with immutable classes in Java
23:05:23 <ibid> (ah yes, ezyang is correct. not even literally true)
23:05:56 <ibid> triyo: the reason null pointer exceptions happen is because the programmer forgot to hande a case
23:06:19 <ibid> triyo: while haskell does not have null pointers, it is quite possible to get runtime errors because of a forgotten case
23:06:35 <ibid> triyo: for example, one might forget to handle Nothing
23:06:57 <triyo> ibid: I see what you mean, hence the use of Maybe monad
23:07:06 <triyo> right?
23:07:19 <dancor> ibid: are there cases of that where the compiler will not issue warnings?
23:08:26 <copumpkin> I wouldn't call it Maybe monad
23:08:31 <copumpkin> it's the maybe type, that happens to be a monad :)
23:08:37 <ibid> dancor: yes.
23:08:46 <copumpkin> I wouldn't call it "the Maybe monad" unless you're using its monadiness
23:08:52 <ibid> triyo: not all code is monadic
23:09:14 <dancor> ibid: what's an example
23:09:15 <mornfall> copumpkin: I think he was exactly pointing out that he'd use the monadicness to avoid missed Nothing cases.
23:09:18 <ibid> triyo: and not everywhere is the maybe monad's semantics what you want to do
23:09:47 <ibid> dancor: the compiler does not warn if you use head on a possibly empty list
23:09:59 <triyo> copumpkin: thanks for your correction. Maybe is rather an instance of a monad
23:10:02 <ibid> dancor: the compiler warnings only happen if you are doing explicit pattern matching
23:11:06 <copumpkin> triyo: mostly pedantry :)
23:11:12 <copumpkin> (on my part)
23:11:59 <triyo> ibid: whats the common practice for handling issue like reading head of list that doesn't exist? Is it Maybe? case for [] and return Nothing.
23:12:17 <k23z__> ezyang, ok what do I do about this ? http://i.imgur.com/TeZih.png
23:12:28 <ibid> triyo: the common practice is DON'T DO THAT - just like accessing a null pointer in Java
23:12:45 <triyo> Languages like scheme or clojure return "nothing" instead of an error when calling head on empty list..
23:12:48 <Gracenotes> :t listToMaybe
23:12:49 <lambdabot> forall a. [a] -> Maybe a
23:12:53 <ezyang> Update cabal.
23:13:02 <ibid> triyo: they are not statically typed
23:13:11 <k23z__> ezyang, how ?
23:13:15 <Gracenotes> listToMaybe just *happens* to be specified to return the head, though.. as opposed to (say) the last elem
23:13:24 <triyo> ibid: small detail, that explains the problem :)
23:13:38 <k23z__> triyo, I'll never use clojure or scheme hopefuly
23:13:55 <copumpkin> k23z__: you should try at least one of them
23:13:56 <copumpkin> they can be fun
23:14:01 <copumpkin> I still prefer haskell
23:15:09 <k23z__> I know that book SICP, everybody says it's a good book, but I don't want to read it, exactly because it would mean for me to learn a new language(Scheme) which I wouldn't be able to use anywhere(or so I think ? am I wrong ?)
23:15:31 <ibid> triyo: you *could* have head return a Maybe, but that just shunts the problem around
23:15:43 <k23z__> copumpkin, why do you think Scheme is fun ? is it also useful to read SICP in any way ?
23:15:53 <copumpkin> k23z__: it's nice because you can learn a lot about how a language is constructed, without dealing with too many icky bits
23:15:58 <copumpkin> k23z__: yeah, I think it is
23:16:10 <triyo> ibid: yup, I have some code that uses maybe in this way
23:16:18 <k23z__> copumpkin, so that book emphasizes compiler construction ?
23:16:21 <Pseudonym> Many so-called computer science courses tend to spend a lot of time on "let's study the syntax of Java".
23:16:22 <pastorn> k23z__: and you do have use of knowing scheme
23:16:32 <ibid> k23z__: learn as many languages as you can.  that will develop your programming skill in any language
23:16:37 <Pseudonym> Scheme has the advantage that there's almost no syntax to worry about.
23:16:38 <k23z__> pastorn, example please ?
23:16:43 <copumpkin> learn as many different languages as you can, anyway
23:16:47 <triyo> k23z__: you could learn Scheme the lang in about 20min
23:16:48 <Pseudonym> At least one a year.
23:16:51 <pastorn> k23z__: if you work your way through SICP you will learn lots of neat stuff that isn't exactly language specific
23:16:54 <copumpkin> I wouldn't bother spending much time on ruby/python if you already know python/ruby
23:17:00 <triyo> it has only about 25 special forms, if that
23:17:13 <pastorn> AND you'll be able to code in clojure and 48 other lisp-like languages
23:17:44 <pastorn> triyo: plz teach me quasiquotes in 10 minutes then :)
23:17:49 <k23z__> ezyang, I just upgraded as you told me, I get the same error http://i.imgur.com/TeZih.png
23:17:59 <copumpkin> k23z__: if nothing else it'll look good on your resume :) but there's a lot of other benefits
23:18:00 <pastorn> cause i've triend and i've understod bupkus
23:18:04 <triyo> I find programming in Haskell does require some upfront thought (this is a good thing right?) compare to a dynamic lang like scheme where you can jump to your emacs editor and start coding...
23:18:18 <k23z__> copumpkin, usually interviewers don't believe you know so many languages
23:18:27 <pastorn> *tried
23:18:27 <copumpkin> k23z__: if they don't, you can prove it
23:18:33 <Pseudonym> triyo: That time you don't spend thinking upfront you pay for in debugging after the fact.
23:18:33 <k23z__> copumpkin, they ask something like "oh, and I see you know so many languages, with a smirk on their face"
23:18:37 <triyo> pastorn: minus the  macros. :)
23:18:40 <k23z__> copumpkin, they actually make fun of this
23:18:46 <Pseudonym> Swings and roundabouts.
23:18:58 <triyo> pastorn: minus the hygiene  macros.
23:18:59 <k23z__> copumpkin, you don't have time in an interview to prove stuff like that to them
23:19:04 <copumpkin> k23z__: I'd try to include ones relevant to the job and pick a sampling of fundamentally different ones, at least
23:19:11 <copumpkin> listing every little thing you've played with is silly
23:19:19 <Pseudonym> k23z__, it depends on the job.  I have 40+ languages mentioned on my CV, and they very much believed it.
23:19:24 <k23z__> copumpkin, I know it's silly, that's what I was saying ..
23:19:25 <fwoop> the "having to think upfront" is just a matter of (lack of) familiarity with the programming style
23:19:37 <pikhq_> Not very hard to know a lot of languages. Most of your learning is going to be per-paradigm.
23:19:43 <Pseudonym> Yeah.
23:20:04 <Pseudonym> Or per-standard-library.
23:21:17 <k23z__> Pseudonym, you must also have a masters degree and probably a phd or a lot of working experience. I don't have working experience, except unofficial work experience because some jackasses didn't bother to do the legal formalities ..
23:22:51 <k23z__> pikhq_, like    imperative, object-oriented , logic , functional                 distributed/parallel/concurrent , event-based  no ?
23:22:52 <copumpkin> k23z__: nah you don't
23:23:11 <pikhq_> k23z__: Yuh.
23:24:03 <tomberek> hello
23:24:09 <pikhq_> Though I'd break them differently: procedural, object-oriented, unstructured, logic, declarative, metaprogramming, etc.
23:24:27 <wli> What's unstructured and logic?
23:24:32 <copumpkin> assembly maybe?
23:24:35 <copumpkin> and prolog?
23:24:52 <djahandarie> Where does Haskell go in that list?
23:25:01 <copumpkin> putting assembly in might show you're good at low-level stuff, assuming you're actually pretty competent in it
23:25:16 <ezyang> k23z__: If no one has answered your question yet, cabal update; cabal upgrade cabal-install
23:25:40 <k23z__> copumpkin, knowing assembly well means knowing the architecture you're working on very well. that ties you down to one machine. writing efficient assembly code means knowing that machine very well
23:25:48 <copumpkin> k23z__: yep
23:25:50 <ezyang> Translation for FPwBLEBW done! Though I'm sure I've messed up some of the transcriptions.
23:26:07 <k23z__> copumpkin, I wrote some nasm, but it was suboptimal to the same code written that the g++ compiler generated
23:26:17 <djahandarie> Scary that I knew what that acronym was for
23:26:25 <k23z__> copumpkin, of course it was lizible because I wrote it and I knew what was in there, but the compiler outsmarted me in every possible way
23:26:49 <copumpkin> people weren't meant to write efficient assembly for superscalar machines, anyway
23:26:58 <k23z__> ezyang, I did that cabal update; cabal upgrade cabal-install
23:27:14 <k23z__> ezyang, getting the same error ..
23:27:14 <ezyang> ok...
23:27:17 <ezyang> Hm.
23:27:26 <jeeez> is there a 'not equal to' operator? probably there is, how do i use it? :\
23:27:32 <ezyang> I'm stumped, and also pretty sleepy
23:27:34 <copumpkin> (/=)
23:27:34 <ezyang> jeeez: /=
23:27:46 <copumpkin> > 5 /= 5
23:27:47 <lambdabot>   False
23:27:48 <copumpkin> > 5 /= 6
23:27:48 <lambdabot>   True
23:27:58 <jeeez> thanks!
23:29:14 <dancor> > let (!=) = (/=) in 5 != 4
23:29:14 <lambdabot>   True
23:29:16 * wli would probably break it down into imperative, dataflow, logic, functional, string processing, I forget what else.
23:29:32 <pikhq_> copumpkin: I doubt there's more than a couple dozen people capable of doing efficient assembly for superscalar machines.
23:29:55 <copumpkin> pikhq_: computers are just so much better at keeping the pipeline in mind when ordering instructions
23:30:09 <copumpkin> if I kept massive comments keeping track of its state at all times
23:30:11 <pikhq_> Like I said. :)
23:30:20 <copumpkin> yeah, it's a waste of brainpower :)
23:31:03 <eldragon> Pentium-M was very good w/ highest IPC
