00:00:02 <copumpkin> c_wraith: here, now you can bitch at gcollins ;) http://github.com/snapframework/snap-website/blame/master/src/Main.hs
00:00:03 <ksf> unlink, yes
00:00:21 <unlink> OK, thanks.
00:00:25 <ksf> there's ways to get around it and load stuff run-time, though.
00:00:35 <lispy|web> unlink: Well, at run-time the code has to be available either static linked or dynamic linked
00:00:35 <unlink> OK.
00:00:51 <unlink> But that's like dlopen() semantics, right?
00:00:57 <ksf> c_wraith, yes, I know, OOP is evil, OOP is bad, but I bleeding _want_ it, so my inquiry is justified.
00:01:08 <lispy|web> unlink: that's what I had in mind for dynamic linked
00:01:16 <c_wraith> ksf: sorry, I meant "oops".  bad typing, not anything related to you
00:01:22 <unlink> ok
00:01:56 <unlink> And Haskell modules can't do anything "on import", since there is no such concept of the timing of "on import", correct?
00:02:15 <c_wraith> correct.  It's not like python where the file is executed when it's imported.
00:02:34 <ksf> unlink, they can, with TH
00:02:41 <ksf> that is, they can generate themselves.
00:02:59 <c_wraith> ksf: that's still at compile-time, rather than runtime, which is how I interpreted the question
00:03:22 <ksf> yep.
00:03:31 <unlink> Yeah. OK. I thought so.
00:03:36 <c_wraith> ksf: python modules execute when they're loaded, at runtime, so you can have things like caches built at module load time.
00:03:55 <unlink> The Python version of import is absolutely horrid, as illustrated by the famous xkcd comic.
00:04:04 <ksf> in haskell, you can use unsafePerformIO newIORef for such things.
00:04:16 <c_wraith> ksf: true, but frightening. :)
00:04:28 <ivanm> I have no idea what you're talking about, but I agree with c_wraith
00:04:28 <ksf> which won't give you the ref at "load time", but it's going to be there when you need it.
00:05:23 <unlink> You could, in principle, turn off gravity by merely importing a module O:-)
00:06:28 <ksf> haskell has the property that if you import a module, you get one of two behaviours: a) your program doesn't compile any more, b) it runs with unchanged semantics
00:07:12 <c_wraith> hmm.  that's a good way to express it.  I like that description
00:07:26 <ksf> ...at least without -XIncoherentInstances
00:07:41 <c_wraith> I like to pretend that option doesn't exist. >_>
00:08:08 <EvanR> this is my revised timer, now with IORefs instead of StateT http://codepad.org/IECkuOgp
00:08:50 <ksf> maybe a whole class of ghc features should require -XLetMeShootMyFoot
00:09:48 <byorgey> GHC seems to hang when I try to compile a certain file.  I do have UndecidableInstances on but I don't think that's causing it.  Any ideas what I can do to figure out what ghc is doing?
00:10:17 <ksf> divide+conquer?
00:10:59 <ksf> first thing, move everything that requires undecidable instances out into a separate module
00:11:33 <ksf> (and cc http://hackage.haskell.org/trac/ghc/ticket/3547 )
00:12:26 <byorgey> ok, it's definitely not the UndecidableInstances
00:12:52 <byorgey> I commented out those instances and removed the pragma, and it doesn't give me any errors (like it does with the instances but no pragma), just hangs
00:13:37 <ksf> you can tell ghc to dump info about passes
00:13:49 <byorgey> hmm, good idea
00:13:55 <copumpkin> those are simplifier passes
00:14:01 <copumpkin> do you have circular rewrite rules ?:)
00:14:13 <copumpkin> it doesn't go to any effort to prevent that
00:14:38 <c_wraith> EvanR: looks cleaner without the StateT.  I'd consider adding a couple lets to give descriptive names to some of the more opaque blocks, but that's just something I've learned from being forced to read my code again later. :)
00:15:53 <blackdog> is json-b the standard json handler with bytestrings?
00:15:54 <EvanR> c_wraith: its pretty ugly. im rewriting the loop as a explicitly recursive action
00:16:04 <EvanR> to see how it looks
00:16:06 <copumpkin> explicit recursion! you need fix!
00:16:13 <copumpkin> explicit recursion is the devil1!
00:16:16 <byorgey> I don't have any rewrite rules
00:16:23 <EvanR> well see wont we
00:16:43 <c_wraith> I think forever is a fine combinator for what you're doing...
00:16:46 <byorgey> looks like it is hanging at the 'Renamer/typechecker' phase
00:16:50 <byorgey> and eating more and more memory
00:16:52 <c_wraith> Or did you mean a different loop?
00:17:00 <EvanR> no
00:17:20 <copumpkin> byorgey: is it small or independent enough to paste?
00:19:10 * ksf is wondering whether some syb stuff could do the magic
00:20:33 <byorgey> copumpkin: unfortunately, very much not =(
00:20:59 <copumpkin> aw
00:22:38 <c_wraith> EvanR: It occurs to me that there's a good chance you could get rid of the IORef by making the recusion explicit.  I suppose that's part of what you're doing?
00:22:54 <byorgey> ah, wait, it looks like it is UndecidableInstances after all
00:23:13 <byorgey> I wasn't doing a clean in between each compile which I think was doing weird things so that it didn't seem like it was before
00:23:30 <copumpkin> ah
00:23:40 <copumpkin> when in doubt, it's undecidable instances
00:24:10 <EvanR> c_wraith: well yes
00:24:13 <EvanR> http://codepad.org/h0RRjfW5
00:24:25 <byorgey> is there a way to get GHC to print out stuff about its instance searching?
00:24:34 <byorgey> I don't understand why this particular instance is looping
00:25:19 <EvanR> ah quantum_int need be gone
00:25:51 <EvanR> http://codepad.org/GuZE7F1F
00:27:07 <c_wraith> I'd be tempted to define timeWork inside of mkTimer, so it could get quantum from its environment instead of passing it through every time, but that's not a big deal.
00:27:26 <EvanR> yeah
00:27:35 <EvanR> and out
00:27:43 <c_wraith> oh, right
00:27:49 <EvanR> in which case i could use fix ;)
00:27:54 <c_wraith> haha :)
00:28:02 <byorgey> hah! fixed it
00:28:12 <byorgey> I still don't know why it was looping.
00:28:21 <byorgey> but at least I know why my code was wrong.
00:28:24 <ddarius> byorgey: What did you change?
00:28:43 <byorgey> I fixed a type error; I needed to insert an extra 'map'
00:28:59 <EvanR> @hoogle fix
00:29:00 <lambdabot> Data.Function fix :: (a -> a) -> a
00:29:00 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
00:29:00 <lambdabot> module Control.Monad.Fix
00:29:01 <byorgey> but apparently it was trying very very hard to make the wrong code typecheck
00:29:32 <c_wraith> byorgey: is this something an explicit type signature somewhere would have caught?
00:31:18 <copumpkin> byorgey: mind if I ask what you're using undecidable instances for?
00:31:24 <byorgey> c_wraith: well... I'm sure there is an explicit type signature somewhere that could have caught this.  But I doubt it would have been reasonable to put it.
00:31:33 <byorgey> I have top-level type signatures for everything.
00:31:36 <c_wraith> byorgey: yeah, I forgot that qualifier.
00:32:36 <byorgey> copumpkin: not at all. I'm making heavy use of the vector-space library, and it has various type functions like Scalar and Basis that denote the associated scalar or basis type of a vector space
00:32:46 <copumpkin> yeah, I've played with it
00:33:14 <byorgey> copumpkin: so you end up with instances like   (some constraint on (Scalar v)) => some instance for v
00:33:21 <copumpkin> ah yeah
00:33:49 <byorgey> they are all perfectly fine and terminating since the Scalar/Basis types are always "simpler"
00:34:03 <byorgey> but it's impossible to see that syntactically
00:35:19 <byorgey> ok, I'd really better go to bed now =)
00:35:40 <ivanm> byorgey: hac phi going well?
00:36:41 <EvanR> somehow that compiled
00:36:54 <c_wraith> man.  more silliness in this Main file.  Clearly, they didn't put much effort into making sure their site-specific code was clean.
00:37:23 <EvanR> for anyone still listening to my insanity, http://codepad.org/IzEyzfrH
00:37:56 <c_wraith> ack.  anyone suggesting fix wasn't serious!!!!  ;)
00:38:16 <EvanR> just wondering, did i do it right?
00:38:44 <c_wraith> I don't have a clue.  does it compile and work? :)
00:38:54 <byorgey> ivanm: yeah, it's fantastic =)
00:38:55 <EvanR> ill see
00:39:06 <byorgey> so much fun to hack on stuff with lots of other smart people
00:39:17 <byorgey> all in one room
00:39:18 <byorgey> with food
00:39:28 <EvanR> c_wraith: yeah
00:39:31 <c_wraith> sadly, I can't stick around.  Have to head back home.  Maybe I'll catch you in 30 minutes or so, if you're still playing with this, EvanR
00:39:41 <EvanR> heh, i gotta go to bed
00:39:47 <EvanR> 238am here
00:40:49 <EvanR> IORefs, eat your heart out ;)
00:40:53 * EvanR goes to sleep
00:43:39 <ivanm> preflex: seen Axman6
00:43:39 <preflex>  Axman6 was last seen on #haskell 3 hours, 52 minutes and 2 seconds ago, saying: dons: you still around?
01:00:19 <roconnor> > iterate f x
01:00:20 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
01:00:31 <roconnor> > inits $ iterate f x
01:00:32 <lambdabot>   [[],[x],[x,f x],[x,f x,f (f x)],[x,f x,f (f x),f (f (f x))],[x,f x,f (f x),...
01:01:07 <c_wraith> > fix $ scanl f x
01:01:08 <lambdabot>   [x,f x x,f (f x x) (f x x),f (f (f x x) (f x x)) (f (f x x) (f x x)),f (f (...
01:02:06 <ddarius> > fix $ scanl (const f) x
01:02:07 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
01:02:13 <c_wraith> heh.  yeah, that.
01:02:31 <copumpkin> hey, what if you wanted a double iterate?
01:03:18 <c_wraith> :T x
01:03:21 <c_wraith> whoops
01:03:23 <c_wraith> :t x
01:03:24 <lambdabot> Expr
01:03:43 <ddarius> If I make an appropriate nested data type and plug its constructors in for f and x, will it work?
01:03:53 <c_wraith> How does the Expr stuff work, such that unbound names are treated as Expr, instead of... compile errors?
01:04:02 <dmwit> c_wraith: f and x are bound
01:04:05 <djahandarie> c_wraith, it's only a-z
01:04:12 <djahandarie> :t f
01:04:12 <c_wraith> ah!  that explains it.
01:04:13 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
01:04:18 <djahandarie> :t z
01:04:20 <lambdabot> Expr
01:04:32 <c_wraith> remarkably effective dirty hack.  I approve. :)
01:04:44 <copumpkin> ddarius: I think so... or was your question rhetorical?
01:04:45 <ddarius> The whole thing is a dirty hack.
01:04:45 <dmwit> What's dirty about defining some variables?
01:04:57 <copumpkin> people think it's magic
01:05:07 <copumpkin> and expect non a-z to work too :P
01:05:14 <copumpkin> and the f,g,h being functions is also kind of dirty
01:05:33 <c_wraith> :t i
01:05:34 <lambdabot> Expr
01:05:40 <ddarius> :t scanl
01:05:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
01:05:50 <roconnor> > map reverse (inits (iterate f x))
01:05:51 <lambdabot>   [[],[x],[f x,x],[f (f x),f x,x],[f (f (f x)),f (f x),f x,x],[f (f (f (f x))...
01:05:54 <dmwit> I agree, the people that think it's magic are dirty. The hack, however, is clean and bright.
01:06:03 <roconnor> I'm trying to think of a nice way to do map reverse (inits (iterate f x))
01:06:14 <ddarius> :t \f x -> fix (scanl f x)
01:06:15 <lambdabot> forall a. (a -> a -> a) -> a -> [a]
01:06:39 <c_wraith> throw in a const, and you have iterate
01:06:46 * hackagebot haskell-updater 1.1.0.0 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.1.0.0 (IvanMiljenovic)
01:06:53 <copumpkin> but then you lose the fun
01:07:28 <dmwit> :t \f x -> iterate (\xs -> case xs of [] -> [x]; (x:_) -> f x : xs) []
01:07:29 <lambdabot> forall a. (a -> a) -> a -> [[a]]
01:07:41 <dmwit> > iterate (\xs -> case xs of [] -> [x]; (x:_) -> f x : xs) []
01:07:42 <lambdabot>   [[],[x],[f x,x],[f (f x),f x,x],[f (f (f x)),f (f x),f x,x],[f (f (f (f x))...
01:07:47 <dmwit> roconnor: ?
01:08:08 <roconnor> dmwit: needs more combinators :)
01:08:17 <dmwit> sure, how about
01:08:33 <dmwit> uh, never mind
01:08:46 <dmwit> > iterate (\xs -> map f xs ++ [x]) []
01:08:47 <lambdabot>   [[],[x],[f x,x],[f (f x),f x,x],[f (f (f x)),f (f x),f x,x],[f (f (f (f x))...
01:08:55 <dmwit> Bad asymptotics on that one, though. =)
01:09:04 <roconnor> ya
01:09:09 <roconnor> I want more sharing
01:09:21 <roconnor> seems like a nice structure for sharing
01:09:24 <dmwit> Well, the iterate one I gave has very nice sharing.
01:09:44 <djahandarie> ...both used iterate? :P
01:09:49 <dmwit> yeah yeah
01:09:52 <dmwit> s/iterate/first/
01:10:24 <roconnor> > iterate (foldr (\x l -> f x : (x : l)) [x]) []
01:10:26 <lambdabot>   [[],[x],[f x,x,x],[f (f x),f x,f x,x,f x,x,x],[f (f (f x)),f (f x),f (f x),...
01:10:39 <dmwit> Not quite...
01:10:40 <roconnor> @pl iterate (foldr (\x l -> f x : (x : l)) [x]) []
01:10:40 <lambdabot> iterate (foldr (ap ((.) . (:) . f) (:)) [x]) []
01:10:56 <roconnor> @pl iterate (foldr (\x l -> f x : (x : l)) [x]) []
01:10:56 <lambdabot> iterate (foldr (ap ((.) . (:) . f) (:)) [x]) []
01:11:00 <roconnor> > iterate (foldr (\x l -> f x : (l)) [x]) []
01:11:01 <lambdabot>   [[],[x],[f x,x],[f (f x),f x,x],[f (f (f x)),f (f x),f x,x],[f (f (f (f x))...
01:11:10 <roconnor> @pl iterate (foldr (\x l -> f x : (l)) [x]) []
01:11:11 <lambdabot> iterate (foldr ((:) . f) [x]) []
01:11:31 <roconnor> > iterate (foldr ((:) . f) [x]) []
01:11:32 <lambdabot>   [[],[x],[f x,x],[f (f x),f x,x],[f (f (f x)),f (f x),f x,x],[f (f (f (f x))...
01:11:39 <roconnor> that foldr is soo close to a map
01:11:50 <dmwit> But that one does not have good sharing.
01:11:52 <copumpkin> that's basically what dmwit had
01:11:54 <roconnor> oh right
01:11:55 <roconnor> crap
01:11:58 <copumpkin> isn't dmwit's just a fold?
01:12:04 <dmwit> dmwit's is not just a fold
01:12:10 <dmwit> dmwit's is not recursive in the argument to iterate
01:12:37 <ddarius> Why are you talking in the third person?
01:12:45 <dmwit> to be cute
01:12:51 <copumpkin> :)
01:12:52 <c_wraith> I feel like scanr is almost right here.  But that can't be true, because scanr is never the right answer.
01:13:08 <roconnor> c_wraith: well, I am trying to get rid of a reverse
01:13:51 <roconnor> >  fix (scanr f x)
01:13:55 <lambdabot>   mueval-core: Time limit exceeded
01:13:56 <dmwit> :t \xs -> [] : map (map f) xs
01:13:57 <lambdabot> forall a a1. (Show a1, SimpleReflect.FromExpr a) => [[a1]] -> [[a]]
01:14:52 <c_wraith> roconnor: scanr is not very lazy, as it needs to scan the entire list before producing the first element of output.
01:14:57 <dmwit> > fix (\xs -> [] : map ((x:) . map f) xs)
01:14:58 <lispy|web> oh wow: http://okmij.org/ftp/Computation/Computation.html#sendmail-Turing
01:14:58 <lambdabot>   [[],[x],[x,f x],[x,f x,f (f x)],[x,f x,f (f x),f (f (f x))],[x,f x,f (f x),...
01:15:09 <lispy|web> sendmail configs are turing complete
01:16:45 <dmwit> > [] : iterate (\xs@(x:_) -> f x : xs) [x]
01:16:46 <lambdabot>   [[],[x],[f x,x],[f (f x),f x,x],[f (f (f x)),f (f x),f x,x],[f (f (f (f x))...
01:16:59 <dmwit> roconnor: Is that a little better? no case there...
01:17:09 <dmwit> or even
01:17:23 <dmwit> > [] : iterate (\xs -> f (head x) : xs) [x]
01:17:24 <lambdabot>   Couldn't match expected type `[a]'
01:17:24 <lambdabot>         against inferred type `SimpleRef...
01:17:39 <copumpkin> head xs
01:17:41 <dmwit> > [] : iterate (\xs -> f (head xs) : xs) [x]
01:17:42 <lambdabot>   [[],[x],[f x,x],[f (f x),f x,x],[f (f (f x)),f (f x),f x,x],[f (f (f (f x))...
01:17:57 <dmwit> ?pl \xs -> f (head xs) : xs
01:17:57 <lambdabot> (:) =<< f . head
01:18:01 <copumpkin> lol
01:18:12 <dmwit> =)
01:18:15 <djahandarie> I'm f.head up with this!
01:18:19 <copumpkin> there, now it's true haskell
01:18:44 <copumpkin> @pl \x -> [] : iterate (\xs -> f (head xs) : xs) [x]
01:18:44 <lambdabot> ([] :) . iterate ((:) =<< f . head) . return
01:18:51 <copumpkin> @pl \x -> [] : iterate (\xs -> f (head xs) : xs) (pure x)
01:18:51 <lambdabot> ([] :) . iterate ((:) =<< f . head) . pure
01:19:27 <copumpkin> I dread to make it take the f argument though
01:19:29 <copumpkin> it's so pretty
01:19:53 <c_wraith> I find myself disturbed by ([] :)
01:19:58 <copumpkin> @pl \f -> ([] :) . iterate ((:) =<< f . head) . pure
01:19:59 <lambdabot> (([] :) .) . (. pure) . iterate . ((:) =<<) . (. head)
01:20:02 <copumpkin> oh nice
01:20:08 <copumpkin> even prettier ;)
01:20:11 <c_wraith> that seems like an operation with no semantic value
01:20:43 <dmwit> Hey, I didn't write the spec.
01:22:44 <djahandarie> Does that actually work?
01:23:08 <copumpkin> > ((([] :) .) . (. pure) . iterate . ((:) =<<) . (. head)) f x
01:23:09 <lambdabot>   [[],[x],[f x,x],[f (f x),f x,x],[f (f (f x)),f (f x),f x,x],[f (f (f (f x))...
01:23:12 <copumpkin> yay dmwit
01:24:02 <dmwit> blech
01:24:15 <dmwit> I take it back, I want out of the Religion of the Lost Point.
01:25:23 <copumpkin> too late now
01:25:31 <copumpkin> you've sold your points to the devil
01:25:45 <dmwit> ?localtime
01:25:49 <lambdabot> Local time for dmwit is Sun May 23 04:25:22 2010
01:25:56 <dmwit> I think, maybe, it's time for bed.
01:25:59 <dmwit> buh-bye
01:26:04 <copumpkin> night
01:26:12 <djahandarie> ?localtime
01:26:15 <lambdabot> Local time for djahandarie is Sun May 23 04:48:20 2010
01:26:33 <djahandarie> No it isn't. :[
01:26:37 <c_wraith> uh.  what?  is your IRC client a liar?
01:26:55 <djahandarie> I'm on the other side of the globe from my irc client :P
01:27:28 <c_wraith> the time it's reporting doesn't even make any sense.  the minutes being :48 is very odd
01:27:43 <djahandarie> That's because the clock isn't in sync on the server
01:27:54 <c_wraith> wow, that's pretty far off. :)
01:28:15 <djahandarie> Actually, it's because they created a new timezone specifically for me
01:28:23 <c_wraith> neat.  can I have one?
01:29:06 <djahandarie> You need to sign a contract with the devil. Ask dmwit about that he seems to be experienced
01:29:08 <c_wraith> have linux distros started installing ntpd pointing at pool.ntp.org by default yet?
01:29:49 <c_wraith> that seems like such a low-controversy thing to do...
01:30:36 <copumpkin> I WANT THE FREEDOM TO KEEP MY OWN TIME DAMNIT
01:30:46 <copumpkin> DON'T NEED NO CENTRAL AUTHORITY TELLING ME WHAT TIME IT IS
01:30:57 <c_wraith> then uninstall it. :P
01:31:20 <copumpkin> I DON'T WANT TO HAVE TO OPT OUT OF A NANNY SYSTEM THAT CODDLES ME LIKE I'M STUPID
01:31:25 <dv-> I run openntpd on two machines but they're always 2 minutes apart
01:31:27 <copumpkin> WHY DO YOU HATE FREEDOM?
01:31:30 <djahandarie> c_wraith, you clearly haven't done anything related to linux, where even low-controversy things are controvertial
01:32:00 <c_wraith> freedom ate my mother one sad day at the beach. :(
01:32:40 <c_wraith> no, wait, I'm thinking of the slithergadee
01:39:51 <roconnor> dmwit: I think I'm happy with ([] :) . iterate ((:) =<< f . head) . return
01:43:02 <copumpkin> please don't be!
01:43:51 <c_wraith> I had a friend in college who kept his clock like 40 minutes fast in his dorm room, facing the hall, and often had his door open.
01:44:10 <c_wraith> He said it was hilarious any time someone walked by, glanced in, then panicked and started running
01:44:37 <c_wraith> djahandarie's server clearly is doing the same thing
01:45:19 * lispy|web once made a software clock in the format of "HH:SS" and referred to it as the the "hour secs" clock -- sadly, no one ever found this joke amusing
01:46:22 <glguy> lispy|web, i am disappoint
01:46:35 <jyper> haskell arrays are basically efficient maps right (where keys are limited to Ix)? Also If this is the case is it reasonable to use a 2d (Int,Int) key array instead of lists of lists to represent a simple 2d grid game?
01:46:36 <lispy|web> glguy!
01:47:09 <lispy|web> glguy: send help, I've been reading Oleg's website all day and my brain hurts :(
01:47:31 <c_wraith> jyper: if you're not using an MArray, updates will be expensive.
01:48:01 <c_wraith> jyper: though updates to a list of lists are even more expensive.
01:53:53 * c_wraith just finally internalized how DiffArray works.  That'd be really neat, if it wasn't inexplicably slow.
01:56:45 <c_wraith> I guess they must have an extra level of indirection internally, so that it can silently switch representations from actual array to diff.  That probably explains a good chunk of the speed.
01:56:48 <roconnor> let s = s = map (reverse . (1:) . zipWith ((sum.) . zipWith (*)) s) ([]:iterate (\l -> 1:zipWith (+) (head l) (tail (head l))++[0]) : l) [[1]]) in take 25 $ map sum s
01:56:52 <roconnor> > let s = s = map (reverse . (1:) . zipWith ((sum.) . zipWith (*)) s) ([]:iterate (\l -> 1:zipWith (+) (head l) (tail (head l))++[0]) : l) [[1]]) in take 25 $ map sum s
01:56:53 <lambdabot>   <no location info>: parse error on input `='
01:56:59 <roconnor> > let s = map (reverse . (1:) . zipWith ((sum.) . zipWith (*)) s) ([]:iterate (\l -> 1:zipWith (+) (head l) (tail (head l))++[0]) : l) [[1]]) in take 25 $ map sum s
01:57:00 <lambdabot>   <no location info>: parse error on input `)'
01:57:00 * int-e would probably start with Data.Map.Map (Int, Int) a
02:03:45 <Libster>   DCC SEND "urgayurgayugr" 0 0 0
02:06:07 <copumpkin> ugh
02:08:35 <djahandarie> Does anyone know the big-O for checking equality of two Bytestrings?
02:08:56 <c_wraith> O(n), for whatever n is shorter. :)
02:09:12 <djahandarie> Where n is the string length?
02:09:13 <c_wraith> it doesn't do anything special, it's just a byte-by-byte comparison
02:09:18 <c_wraith> yeah
02:09:40 <copumpkin> djahandarie: what else could it do?
02:09:51 <c_wraith> there might be an optimization to check lengths, at least for strict bytestrings, as those are fixed, known lengths
02:10:45 <c_wraith> I guess whether that's an optimization or not depends on whether or not the strings you're comparing are actually equal.
02:11:12 <c_wraith> or rather, how often they're equal.
02:30:02 <danderson> how come unsafe FFI calls block the entire haskell process, rather than just the calling thread?
02:31:42 <danderson> sorry, I should be specific. I'm asking about GHC's FFI implementation in particular.
02:32:41 <Cale> are you compiling with -threaded?
02:33:04 <danderson> yes.
02:33:34 <danderson> The FAQ states that only safe calls can happen concurrently with -threaded, but unsafe calls will freeze all haskell threads for the duration of the FFI call
02:33:51 <danderson> which seems to fly in the face of the whole point of having unsafe calls for added efficiency in the first place
02:34:28 <copumpkin> unsafe just means they can call back into haskell
02:34:47 <danderson> http://www.haskell.org/haskellwiki/GHC:FAQ#When_do_other_Haskell_threads_get_blocked_by_an_FFI_call.3F
02:34:52 <danderson> what about that FAQ entry?
02:35:27 <danderson> I know what safe/unsafe mean in the Haskell FFI addendum, but preventing concurrency seems to be a side-effect of GHC's implementation
02:35:31 <danderson> and I'm wondering why
02:38:33 <BorisL> is it possible to rename function during import with some GHC extension? For example, import Prelude (zipWith as zw)
02:41:01 <hydo> that's...... MADNESS
02:41:09 <hydo> (i don't know, sorry)
02:41:12 <copumpkin> BorisL: no
02:41:19 <copumpkin> I'd like to :)
02:41:22 <copumpkin> agda supports that
02:56:15 * hackagebot darcs 2.4.4 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.4.4 (EricKow)
03:06:01 <zygoloid> danderson: you've got it backwards. safe/unsafe refers to the function, not to how it's used
03:06:39 <zygoloid> (ghc makes safe calls to unsafe functions and unsafe calls to safe functions)
03:06:47 <copumpkin> I hate that
03:06:57 <zygoloid> yeah, it trips me up every time :(
03:07:30 <copumpkin> @localtime
03:07:31 <lambdabot> Local time for copumpkin is 2010-05-23 06:07:07 -0400
03:07:35 <copumpkin> bedtime!
03:08:57 <danderson> zygoloid: oooh.
03:09:03 <danderson> That is amazingly confusing.
03:09:09 <danderson> but makes sense. Thanks.
03:13:17 <ClaudiusMaximus> hm i installed ghc-6.12.2 generic binary, followed by cabal-install tarball ./bootstrap.hs - then edited my config to enable library profiling; is it normal that i need to reinstall things like mtl because they missed profiling versions?
03:14:12 <copumpkin> yeah
03:25:15 <osfameron> gah.  to mock a mockingbird is HARD
03:25:52 <osfameron> every time I come back to the first puzzle in the mockingbird section itself, I can't remember how to derive it, or even how to go about deriving it
03:26:16 <osfameron> which is a bit learning-curve fail I think
03:26:21 <osfameron> (some of the later puzzles are easier)
03:31:00 * ivanm hasn't even bothered killing the mockingbird yet
03:32:29 <Botje> using the type system?
04:08:15 <Phyx-> lol? GHC just crashed with "evacuate: strange closure type 301"
04:09:37 <endojelly> hi #haskell
04:09:41 <danderson> do as it says, evacuate and let the bomb squad handle it
04:09:42 <endojelly> I want to learn more about space leaks
04:09:44 <endojelly> any pointers?
04:11:22 <Phyx-> endojelly: have you tried http://www.haskell.org/haskellwiki/Performance/Space
04:11:41 <Phyx-> danderson: I put a call in, but it's sunday so, they're probably out sipping margaritas
04:11:55 <endojelly> Phyx-, no, very good, thanks
04:12:40 <endojelly> Phyx-, because it leads to http://www.haskell.org/haskellwiki/Performance/Strictness 8)
04:13:49 <Phyx-> endojelly: well, it does have to do with strictness, have you already read that one then?
04:17:09 <endojelly> Phyx-, read it now
04:18:35 <dv-> Haskell. You come for the lazyness. You stay for the strictness.
04:56:06 <lyndon> Just trying to load the hello world snap template into ghci, and hitting this error: Couldn't match expected type `Data.ByteString.Internal.ByteString' against inferred type `[Char]'
04:56:16 <lyndon> Anyone played with this yet?
05:05:33 <Polarina> lyndon, we can't help you without any further information, sorry.
05:07:26 <ivanm> sounds like the StringLike extension is needed or something
05:15:09 <Axman6> lyndon: the problem is that you need -XOverloadedStrings i think (it may be called something else, so check the ghc man page)
05:16:41 <Axman6> lyndon: just compiling the program as the tutorial should work (though there are some other errors in the tutorial)
05:16:49 <Axman6> lyndon: there is also #snapframework
05:25:44 <lyndon> Axman6: Polarina: Thanks!
05:26:05 <Axman6> most of the Snap devs are in #snapframework i believe
05:27:04 <lyndon> Axman6: Your overloadedstring suggestion worked like a charm.
05:27:54 <Axman6> if you're interested, what that does is allows you to write "hello" and have it intrepreted as a ByteString
05:28:54 <lyndon> I figured. It seems odd that there needs to be an extension for that for some reason though.
05:29:27 <lyndon> I guess I've been using languages with only one string class for too long.
05:41:05 <roconnor> What is the recommended package for heaps?
05:41:33 <jlouis> roconnor: depends on what you want to do to them I guess
05:41:50 <roconnor> jlouis: take out the maximum
05:41:53 <jlouis> roconnor: I use Data.PSQueue from PSQueue here because I need a priq you can search
05:41:56 <roconnor> and update random elements
05:42:15 <jlouis> PSQueue can update random elements because you can search it
05:42:45 <jlouis> Ralf Hinzes paper on how they work is a fun read as well. It is "somewhat like a tennis tournament storing losers"
05:43:09 <jlouis> where extraction replays the tournament
05:43:46 <jlouis> it seems to serve me reasonably well for what I do
05:44:04 <Axman6> hooray, finally fixed my freenode IPv6 problem, and i'm using SSL too :)
05:44:05 <roconnor> jlouis: this looks good
05:44:35 <jlouis> roconnor: they work reasonably well for me in combinatorrent
05:46:02 * roconnor looks up how it works
05:50:25 <jlouis> roconnor: that idea of the tournament is in Knuth, TAoCP Vol 2 as well by the way, so the idea is old
05:50:30 <jlouis> Vol 3!
05:50:31 <jlouis> not 2
05:52:36 * Saizan suddenly connected TAoCP and Kill Bill
06:04:27 * Phyx- wonders whether one could make a jokes book with just the errors that GHC generates
06:06:33 <Polarina> A database query syntax error has occurred. This may indicate a bug in the software. The last attempted database query was: (SQL query hidden) from within function "MediaWikiBagOStuff:_doquery". MySQL returned error "1062: Duplicate entry 'haskellwiki:messages:Sitenotice' for key 1 (localhost)".
06:06:40 <Polarina> This is getting quite annoying. :(
06:07:19 <ulfdoz> Doesn't look like haskell, but b0rken php-code.
06:08:01 <Polarina> It's the haskell's wiki.
06:09:00 <ulfdoz> I would guess, that it is a modified mediwiki.
06:09:13 <ulfdoz> mediawiki, even.
06:09:25 <Polarina> Probably, I don't know.
06:10:10 <ulfdoz> http://www.haskell.org/info.php <- at least this doesn't decline it.
06:10:20 <soupdragon> > iterate (+17) 0
06:10:22 <lambdabot>   [0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,272,289,306,323,3...
06:12:36 <Kaidelong> could I do something where an algebraic data type has a field that takes any instance of a superclass?
06:12:46 <Kaidelong> IE one of the alternatives is any Num
06:14:08 <soupdragon> yeah
06:14:15 <soupdragon> data X a = I a
06:14:21 <soupdragon> then you use it like  Num a => X a
06:14:26 <soupdragon> that will have any sort of Num in it
06:15:21 <Phyx-> Kaidelong: you can create a normal datatype and use smart constructors like soupdragon mentioned. or you can use an existential type
06:16:10 <Kaidelong> soupdragon: but then wouldn't a data X b be different from a data X a?
06:16:14 <Kaidelong> that is what I'm trying to avoid
06:17:42 <Phyx-> Kaidelong: I don't get what you want, if you want to allow "any value which is part of the type class Num" then they can be different by requirement
06:19:05 <Kaidelong> What I want is the ability to use a union type to put a bunch of things onto a list that do not have the same type. Some of them will be "ordered" data which will be depresented by numbers, but not always doubles
06:19:41 <Kaidelong> I could make two alternative cases but the point here would be to have one "ordered" alternative
06:20:01 <Phyx-> Kaidelong: right, the approach above would work, if you just keep the type of the ADT polymorphic always. but you can take a look at existentials, look at example 2.1 http://www.haskell.org/haskellwiki/Existential_type
06:20:29 <Kaidelong> that looks like what I want phyx
06:20:35 <Kaidelong> thanks
06:20:45 <Phyx-> np
06:20:53 <Kaidelong> oh wait
06:21:02 <Kaidelong> could a list be of type [X a] list
06:21:09 <Kaidelong> as opposed to a type [X Y] list?
06:21:20 <Kaidelong> or is that not allowed?
06:22:00 <Kaidelong> hmm, I think it could be as a parameter, couldn't it?
06:22:02 <Peaker> Kaidelong, You can have:   type Something a = [X a]
06:22:06 <Kaidelong> so it could be
06:22:38 <Phyx-> sure, it's allowed, the type of list is polymorphic. so a can be any value, including X b
06:22:55 <Peaker> Kaidelong, why not?
06:23:00 <soupdragon> > 1/17 :: CReal
06:23:01 <lambdabot>   0.0588235294117647058823529411764705882353
06:23:15 <Kaidelong> so then if I cons an instance of the type with a different Num parameter there is no type error?
06:23:39 <soupdragon> Kaidelong, what's this for??
06:23:41 <Peaker> Kaidelong, you mean a value of the type?
06:23:51 <Peaker> Kaidelong, Types have values.. Classes have instances
06:24:27 <Peaker> Kaidelong, If you have: type Something a = [X a]  then all elements in the list   Something Int   have type   X Int.  Not differing types for differing list elements
06:24:37 <Phyx-> Kaidelong: if any insertion forced it to infer a monomorphic type, like Int, then the rest of the lists would have to be Int aswell from that point on
06:25:10 <Phyx-> - from that point on
06:25:17 <Kaidelong> That's what I was guessing... problematic
06:25:46 <Kaidelong> Let me look over existential types and see if they can help with this table design
06:25:56 <Kaidelong> otherwise I'll just do things the hard way and make a big union type
06:26:45 <Kaidelong> (basically, the idea here is that columns all have the same type, and operations only work on whole columns)
06:27:16 <Peaker> Kaidelong, Why not keep each column in a list then?
06:27:17 <Kaidelong> (but Ordered values can be of any Num type, and a row contains columns... and there lies the problem)
06:27:42 <Peaker> Or represent a row as a tuple?
06:28:18 <Kaidelong> Peaker: because I don't want to work with 400-tuples
06:28:32 <Peaker> Kaidelong, Maybe HList would suit you
06:28:41 <Peaker> Kaidelong, if not a transposed representation (lists of columns)
06:29:00 <soupdragon> Kaidelong what's it for??
06:29:08 <Kaidelong> soupdragon: mining medical data
06:29:10 <soupdragon> Why would you ever do this
06:29:17 <soupdragon> no
06:29:22 <soupdragon> the num thing
06:29:58 <Polarina> What do people recommend to thoroughly test some pure haskell code? :)
06:29:58 <Kaidelong> soupdragon: extensibility if I decide to make some rule that generates a different kind of number from what I was using before, so that I don't have to go add another alternative to the union type
06:30:27 <Peaker> Polarina, Usually QuickCheck
06:30:50 <Polarina> Peaker, why does QuickCheck happen to be your choice?
06:31:13 <Peaker> Polarina, I barely write production Haskell code, only toys for my amusement atm, so I don't do much testing :)
06:31:30 <Peaker> Polarina, But it's fun to be able to do something like:
06:31:46 <Peaker> @check (\xs -> reverse (reverse xs) == (xs::[Int]))
06:31:47 <lambdabot>   "OK, passed 500 tests."
06:31:52 <Peaker> @check (\xs -> reverse xs == (xs::[Int]))
06:31:53 <lambdabot>   "Falsifiable, after 1 tests:\n[-3,0,3]\n"
06:31:57 <Phyx-> I keep forgetting wha the difference between smallcheck and quickcheck is
06:32:30 <ivanm> @instances Enum
06:32:31 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
06:32:45 <ivanm> do tuples have Enum instances?
06:33:11 <Phyx-> [(0,1)..(10,10)]
06:33:15 <Phyx-> >[(0,1)..(10,10)]
06:33:22 <Phyx-> > [(0,1)..(10,10)]
06:33:23 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
06:33:23 <lambdabot>    arising from a use of `e_1011010...
06:33:31 <ivanm> doesn't look like it...
06:33:57 <Phyx-> you could always just write one :)
06:34:03 <Polarina> Can QuickCheck, for example, automatically check my Functor instances and see if they follow the laws?
06:34:08 <ivanm> Phyx-: yeah
06:34:16 <ivanm> I don't want one, its for an email on -cafe ;-)
06:34:24 <Phyx-> for instance that one i just tried
06:34:26 <Phyx-> is just
06:34:27 <Phyx-> liftM2 (,) [0..10] [1..10]
06:34:51 <Kaidelong> I suppose what I'm trying to do would be one of the areas where an object oriented approach might be helpful, if you want to extend later, just subclass
06:35:28 <Kaidelong> subclassing is invisible to your earlier code
06:35:30 <Silvah> @instances Applicative
06:35:31 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
06:36:09 <Peaker> Kaidelong, Subclass to get a type product, or subclass to get a sub-type?
06:36:32 <Kaidelong> Peaker: the latter, in particular one with different behavior from the superclass
06:37:10 <Kaidelong> OOly you could override the superclass' methods
06:37:28 <Peaker> Kaidelong, That's not really supported in OO, IMO..  OO's "subclasses" are really just a weird mix of interface instances and type products
06:38:10 <Peaker> I don't see why people think sub-classes are sub-types, they're virtually never used that way, and when they are, a type-class instance or a record of functions could do the same
06:38:25 <Phyx-> ivanm: something like let enum2Tuple (x1,y1) (x2,y2) = liftM2 (,) [x1..x2] [y1..y2]
06:38:39 <ivanm> Phyx-: as I said, I didn't want it!
06:38:42 <Kaidelong> well then a type product, or operhaps neither of what you mentioned Peaker
06:38:46 <Phyx-> ivanm: awww :P
06:38:48 * hackagebot hlibev 0.2.2 - FFI interface to libev  http://hackage.haskell.org/package/hlibev-0.2.2 (AycanIrican)
06:38:54 <ivanm> it was for an email on -cafe trying to derive Enum for a type alias on a tuple...
06:39:01 <Silvah> > [()..()]
06:39:02 <lambdabot>   [()]
06:39:09 <ivanm> Silvah: () isn't a tuple
06:39:27 <Peaker> it is a tuple of 0 things :)
06:39:51 <hpc> :t ()
06:39:52 <lambdabot> ()
06:39:57 <Phyx-> no, it's the unit type, afaik, it's conceptually not a tuple
06:40:57 <ivanm> Phyx-: yup
06:41:10 <Peaker> What makes it "conceptually not a tuple""?
06:41:17 * Kaidelong thinks he will hard-code in the types and make an option for Double and Int
06:41:20 <Peaker> A tuple of 0 elements, to my understanding, is the unit type
06:41:22 <ivanm> Peaker: because it behaves differently from a tuple?
06:41:33 <ivanm> Peaker: do you state that ('a') is a one-tuple?
06:41:48 <Peaker> ivanm, All types are 1-tuples of those types, conceptually
06:42:43 <Kaidelong> :t 5
06:42:44 <lambdabot> forall t. (Num t) => t
06:42:48 <ivanm> Peaker: the report treats () differently from tuples: http://www.haskell.org/onlinereport/basic.html
06:42:54 <ivanm> it doesn't say its a sub-type of tuple...
06:42:57 <Phyx-> Peaker: because a unit type is a type that can only hold one value. so it can't hold any information. while tuples can hold information
06:43:13 <Phyx-> and GHC also implements unit as a special type
06:43:16 <Phyx-> and not a 0-tuple
06:43:16 <Kaidelong> does haskell have an unsigned byte type I can use, by the way?
06:43:35 <hpc> :t (())
06:43:36 <ivanm> actually, the report says specifically that the size of a tuple is >= 2: http://www.haskell.org/onlinereport/exps.html#tuples
06:43:36 <lambdabot> ()
06:43:42 <Silvah> Word8
06:43:47 <ivanm> yeah
06:43:53 <Peaker> Phyx-, Tuples of N elements are products of N types.  A product of 0 types is the unit type and can hold no information
06:44:02 <Kaidelong> > 257 :: Word8
06:44:02 <lambdabot>   1
06:44:10 <Peaker> ivanm, Technically, that's true.. I said conceptually, 0-tuples are the same as the unit type
06:44:11 <Kaidelong> yay
06:44:18 <ivanm> Peaker: conceptually, maybe
06:44:22 <hpc> > -127 :: Word8
06:44:24 <lambdabot>   129
06:44:28 <Silvah> 257 :: Int8
06:44:33 <Silvah> > 257 :: Int8
06:44:34 <lambdabot>   1
06:44:43 <Silvah> > -127 :: Int8
06:44:44 <lambdabot>   -127
06:44:52 <ivanm> > 128 :: Int8
06:44:53 <lambdabot>   -128
06:45:11 <Silvah> > negate (-128) :: Int8
06:45:12 <lambdabot>   -128
06:45:14 * ivanm -> unconciousness + hallucinations
06:46:00 <Kaidelong> hmm
06:46:09 <Kaidelong> I will try haskell then
06:46:23 <Kaidelong> the heterogenous list type I will definitely take a look at
06:46:36 <ivanm> Kaidelong: noooooo!!!!
06:46:41 <ivanm> you do _not_ want to use that!
06:46:49 <Kaidelong> one of the issues I have is that I'd like to work with a an immutable two dimensional array, so I will prefer a union type for this
06:47:11 <ivanm> what's a union type?
06:47:18 <ivanm> and why do you need a special type for this?
06:47:24 <hpc> you can do 2D lists just fine...
06:47:26 <Silvah> Something evil.
06:47:28 <Kaidelong> data Y = A | B | C
06:47:30 <ivanm> just use an IArray...
06:47:34 <ivanm> Kaidelong: oh, a sum type
06:47:39 <Kaidelong> ivanm: I was going to do that
06:47:45 <hpc> > [[1, 2, 3], [4, 5], [6, 7, 8, 9]]
06:47:46 <lambdabot>   [[1,2,3],[4,5],[6,7,8,9]]
06:47:56 <Kaidelong> IArray I'm comfortable with
06:48:34 <ivanm> (usage of a sum type prevents you from using UArray)
06:48:39 <ivanm> maybe even vector would work
06:49:14 <ivanm> anyway, it's time to hit the sack
06:49:16 <ivanm> g'night all
06:49:20 <Kaidelong> ivanm: a list of vectors would make some of my planned operations inefficient
06:49:22 <Kaidelong> goodnight
06:49:24 <Axman6> night ivanm
06:49:31 <Silvah> night ivanm
06:49:34 <Phyx-> > (const minBound &&& const maxBound) undefined :: (Word8, Word8)
06:49:35 <lambdabot>   (0,255)
06:49:39 <Axman6> Kaidelong: what are you trying to do?
06:49:43 <Silvah> @localtime ivanm
06:49:43 <ivanm> Axman6: since you're here: when you saw someone using the kindle the other day, do you recall what version that was?
06:49:45 <lambdabot> Local time for ivanm is Sun May 23 23:49:21
06:49:49 <Phyx-> @pl  (const minBound &&& const maxBound) undefined
06:49:49 <lambdabot> (const minBound &&& const maxBound) undefined
06:49:51 <ivanm> Kaidelong: can't you have 2D vectors?
06:50:00 <Axman6> ivanm: not a clue
06:50:02 <Kaidelong> ivanm: you can?
06:50:11 <ivanm> Phyx-: no params, ergo no difference for @pl
06:50:24 <Phyx-> @unpl  (const minBound &&& const maxBound) undefined
06:50:24 <lambdabot> ((\ _ -> minBound) &&& \ _ -> maxBound) undefined
06:50:36 <Kaidelong> Axman6: I'm trying to write a program which will clean out gaps from a data set to prepare it for a support vector machine
06:50:43 <ivanm> Kaidelong: hmmm, maybe not
06:50:50 <ivanm> unless you have a vector of vectors...
06:51:14 <Kaidelong> ivanm: that would be nice, but type issues...
06:51:18 <Phyx-> ivanm: lol, yeah, In my head I had that it would break it apart and then try and make it pointfree :P
06:51:26 <ivanm> search for "dimensional" here: http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
06:51:28 <Axman6> Kaidelong: i'm not sure what you mean by that
06:51:39 <ivanm> Phyx-: seeing as how it already is...
06:51:54 <Phyx-> ivanm: hahaha, you know, I actually missed that :P
06:52:18 <Phyx-> ivanm: I blame it on my cold...
06:52:23 <Kaidelong> Axman6: a lot of data mining algorithms can't handle gaps in data. The point of what I'm planning is to use declarative statistics to figure out the best rows and columns to drop, as well as figuring out which are related to each other and may be used to infer one another
06:52:40 <Phyx-> > eTIME
06:52:41 <lambdabot>   Not in scope: `eTIME'
06:52:48 <Kaidelong> err
06:52:51 <Kaidelong> not declarative
06:53:02 <Kaidelong> descriptive statistics
06:53:31 <Kaidelong> IE, if a column does not clearly distinguish the two labelled groups, it's pretty useless
06:55:19 <Phyx-> > fmap join
06:55:20 <lambdabot>   Overlapping instances for GHC.Show.Show (f (m (m a)) -> f (m a))
06:55:20 <lambdabot>    arising...
06:55:27 <Phyx-> lol
06:55:37 <Kaidelong> :t join
06:55:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:55:45 <Kaidelong> ah
06:55:49 <Kaidelong> so it's <-
06:56:11 <cozachk> :t fmap
06:56:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:57:30 <Phyx-> > map concat
06:57:30 <lambdabot>   Overlapping instances for GHC.Show.Show ([[[a]]] -> [[a]])
06:57:31 <lambdabot>    arising from ...
06:57:38 <Phyx-> hmm, forgot about that a
06:58:12 <Phyx-> > map concat :: [[[Int]]] -> [[Int]]
06:58:12 <lambdabot>   Overlapping instances for GHC.Show.Show
06:58:13 <lambdabot>                              ([[[GH...
06:58:17 <Phyx-> meh,
06:58:29 <Kaidelong> > fmap (.)
06:58:30 <lambdabot>   Overlapping instances for GHC.Show.Show
06:58:30 <lambdabot>                              (f (a ...
06:58:37 <Phyx-> > id
06:58:37 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:58:38 <lambdabot>    arising from a use of `...
06:58:45 <Phyx-> > map
06:58:45 <hpc> > show id
06:58:45 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> [a] -> [b])
06:58:46 <lambdabot>    arising...
06:58:46 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:58:46 <lambdabot>    arising from a use of `...
06:58:50 <Phyx-> who broke it?
06:58:55 <Kaidelong> > fix show
06:58:55 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
06:59:35 <Phyx-> wasn't it able to print out functions before?
06:59:40 <danderson> crap, darcs just screwed me.
06:59:54 <Kaidelong> Phyx-: I believe so
07:00:10 * danderson just sent a patch with a half-complete description by accident :(
07:00:12 <Kaidelong> > show show
07:00:12 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Base.String)
07:00:13 <lambdabot>    arising f...
07:00:13 <hpc> :t fix
07:00:14 <lambdabot> forall a. (a -> a) -> a
07:00:25 <Kaidelong> so fix show works but show show doesn't
07:00:33 <Kaidelong> seems broken
07:00:37 <hpc> > fix id
07:00:41 <lambdabot>   mueval-core: Time limit exceeded
07:01:02 <Kaidelong> oh wait right
07:01:03 <Kaidelong> lazy
07:01:10 <Phyx-> oh, wow, ghci just locked up and ctrl+C doesn't bail out
07:01:18 <Kaidelong> each show starts with the " character
07:01:29 <Botje> > show show :: String
07:01:30 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Base.String)
07:01:30 <lambdabot>    arising f...
07:01:37 <arw> Phyx-: Ctrl-\
07:01:40 <Phyx-> heeeelp
07:01:40 <Phyx-> lol
07:01:41 <Kaidelong> :t show show
07:01:42 <lambdabot>     Overlapping instances for Show (a -> String)
07:01:43 <lambdabot>       arising from a use of `show' at <interactive>:1:0-8
07:01:43 <lambdabot>     Matching instances:
07:01:48 <Kaidelong> :t fix show
07:01:48 <lambdabot> String
07:01:49 <Botje> > show (show :: () -> String) :: String
07:01:51 <lambdabot>   Overlapping instances for GHC.Show.Show (() -> GHC.Base.String)
07:01:51 <lambdabot>    arising ...
07:01:58 <Phyx-> arw: now, it just won't do anything, except eat memory
07:01:58 <hpc> :t show
07:01:59 <lambdabot> forall a. (Show a) => a -> String
07:02:21 <Kaidelong> > sqrt
07:02:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:02:22 <lambdabot>    arising from a use of `...
07:02:24 <hpc> oh, fix show works because it resolves the 'a' in show's type
07:02:24 <Phyx-> <interactive>: out of memory
07:02:26 <Phyx-> finally
07:02:32 <arw> Phyx-: if you really want to be rid of it, pkill -KILL ghci
07:03:03 <hpc> fix requires a -> a, and show matches that when it is String -> String
07:03:15 <Phyx-> arw: i'm on windows, for some reason using fix on a non terminating computation always locks it up and freezes the whole system untill it dies
07:03:22 <hpc> > show (show :: String -> String)
07:03:23 <lambdabot>   Overlapping instances for GHC.Show.Show
07:03:23 <lambdabot>                              (GHC.B...
07:03:45 <Silvah> > fix ("hello"++)
07:03:46 <lambdabot>   "hellohellohellohellohellohellohellohellohellohellohellohellohellohellohell...
07:04:04 <hpc> > fix fmap
07:04:05 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
07:04:13 <Phyx-> hpc: no, it works because fix show is fully applied
07:04:16 <Silvah> > fix (\x -> cycle (1:x))
07:04:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:04:18 <arw> Phyx-: ah, windows would explain why Ctrl-\ doesn't work :)
07:04:30 <hpc> :t cycle
07:04:31 <lambdabot> forall a. [a] -> [a]
07:04:59 <Phyx-> arw: usuaully Ctrl+C works, but I noticed a few haskell programs blocking it. I presume a bug in whatever ghci uses for console interaction
07:07:00 <arw> Phyx-: maybe. i'm also no quite sure which part of the console/shell/application stuff is responsible for recognizing C-c and delivering and executing the signal.
07:08:15 <arw> Phyx-: C-A-del and killing it in the task manager should always help on windows, nothing that doesn't completely grab the keyboard blocks C-A-del
07:08:37 <Phyx-> arw: yes, but I basically couldn't do anything untill it dead
07:08:42 <Phyx-> it was eating up memory so fast
07:08:51 <Phyx-> slowed down everything :P
07:09:15 <arw> yes, quite understanable, it just eats memory.
07:09:35 <hpc> @src fix
07:09:36 <lambdabot> fix f = let x = f x in x
07:09:47 <arw> as soon as your system starts swapping stuff out its mostlyy too late for interactive killing of the offender
07:09:48 <Phyx-> i foolishly tried
07:09:50 <Phyx-> fix (\f -> f . (+1)) 10
07:09:51 <Phyx-> lol
07:10:17 <hpc> haha
07:10:33 <abens> isn't there a way to specify max heap size for ghci?
07:10:34 <arw> hm. is there a fixN where fix terminates after n iterations or something?
07:10:52 <Silvah> > fix (\f -> f . (+1)) 10
07:10:58 <lambdabot>  Terminated
07:11:05 <Saizan> abens: yeah, you can start it with +RTS -M..
07:12:31 <Phyx-> abens: just bake it into the function you pass
07:12:32 <Phyx-> > fix (\f n-> if n == 10 then id else f (n+1) . (+1)) 0 10
07:12:38 <lambdabot>   mueval-core: Time limit exceeded
07:12:42 <Phyx-> odd
07:12:58 <Phyx-> > fix (\f n-> if n == 10 then id else f (n+1) . (+1)) 0 10
07:13:01 <lambdabot>   mueval-core: Time limit exceeded
07:13:06 <Phyx-> that works fine locally
07:14:47 <arw> lambdabot has some strict limits on how long a computation might take so that its harder to keep the bot busy with endless loops.
07:15:13 <Saizan> > fix (\f n-> if n == 10 then id else f (n+1) . (+1)) 0 10
07:15:15 <lambdabot>   20
07:15:48 <hpc> > fix ("blah" >>)
07:15:52 <lambdabot>   mueval-core: Time limit exceeded
07:16:01 <Phyx-> arw: sure, but that's not a long running code
07:16:28 <Axman6> :t fix ("blah" >>)
07:16:33 <lambdabot> forall b. [b]
07:16:36 <arw> Phyx-: not if the box the bot runs on currently also has something else to do.
07:16:54 <hpc> :t ("" >>)
07:16:55 <lambdabot> forall b. [b] -> [b]
07:16:55 <Phyx-> lol, it's moonlighting
07:17:04 <Phyx-> it's probably running java code too
07:17:11 <cdsmithus> Huh>  How is that forall b?
07:17:18 <hpc> > fix (True >)
07:17:22 <lambdabot>   mueval-core: Time limit exceeded
07:17:38 <Axman6> > "hello" >> [1,2,3]
07:17:40 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
07:17:47 <Axman6> > "hello" >> "world"
07:17:48 <arw> cdsmithus: empty string is an empty list, and () has no fixed type of its members...
07:17:49 <lambdabot>   "worldworldworldworldworld"
07:17:49 <cdsmithus> Oh
07:18:09 <Phyx-> cdsmithus: because all polymorphic functions are implicitly qualified, it's just a rank-1 function in the case above
07:18:12 <Phyx-> :t id
07:18:13 <lambdabot> forall a. a -> a
07:18:16 <Phyx-> see
07:18:26 <hpc> :t ([] >>)
07:18:28 <lambdabot> forall b. [b] -> [b]
07:18:37 <Saizan> ?type ""
07:18:38 <lambdabot> [Char]
07:18:42 <Saizan> ?type (>>)
07:18:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:18:43 <cdsmithus> Phyx- Yeah, I was just confusing myself about the meaning of that section
07:19:00 <Saizan> a = Char, but b can be whatever
07:19:09 <Phyx-> just how many commands for type does that bot have
07:19:13 <cdsmithus> I just woke up, that's my excude. :)
07:19:16 <cdsmithus> My excuse, too
07:19:30 <hpc> :t, @type, ?type are the ones i know of
07:19:43 <hpc> @ty putStrLn
07:19:44 <lambdabot> String -> IO ()
07:21:06 <Phyx-> > fix (unsafePerformIO . return) :: Int
07:21:07 <lambdabot>   Not in scope: `unsafePerformIO'
07:21:09 <Phyx-> lol
07:21:25 <Phyx-> not that I expected it to
07:21:54 <cdsmithus> @let unsafePerformIO = undefined :: IO a -> a
07:21:56 <lambdabot>  Defined.
07:22:16 <Silvah> > > fix (unsafePerformIO . return) :: Int
07:22:18 <lambdabot>   <no location info>: parse error on input `>'
07:22:21 <Silvah> > fix (unsafePerformIO . return) :: Int
07:22:22 <lambdabot>   *Exception: Prelude.undefined
07:22:25 <Silvah> :D
07:23:00 <soupdragon> :t unsafePerformIO
07:23:01 <lambdabot> forall a. IO a -> a
07:23:30 <Phyx-> yes, but that would just crash
07:23:31 <Phyx-> lol
07:23:38 <hpc> as well it should :P
07:23:48 <Phyx-> @quote
07:23:48 <lambdabot> ozone says: when will bytestring be O(1) for all operations?
07:23:58 <Phyx-> @quote unsafePerformIO
07:23:59 <lambdabot> sorear says: unsafePerformIO is dangerous only because it shows you the world as it really is, and your mind won't be able to take it.
07:24:09 <Phyx-> lol
07:24:22 <Silvah> @quote C++
07:24:22 <lambdabot> ddarius says: Oh no! My code is more than two lines!  There must be a better way!
07:24:43 <Phyx-> think it stripped out the "++"
07:24:48 <Phyx-> and just searched for c
07:24:51 <hpc> @quote jav
07:24:52 <lambdabot> mrd says: the best preprocessor for java is rm
07:24:57 <Botje> heh
07:24:57 <Phyx-> haahahah
07:25:16 <Silvah> lol
07:25:51 <hpc> @quote perl
07:25:52 <lambdabot> lament says: and facing a choice between perl and mircscript, i'd gladly shoot myself
07:26:05 <Phyx-> is today a holiday or something?
07:26:09 <soupdragon> yes
07:26:10 <Phyx-> it's quiet here today
07:26:12 <soupdragon> day of rest
07:26:13 <Phyx-> it is?
07:26:20 <soupdragon> 7th day
07:26:22 <Peaker> @quote python
07:26:22 <lambdabot> python says: is a mediocre language invented by a mediocre person
07:26:30 <hpc> @quote ruby
07:26:30 <lambdabot> chrisdone says: benchmarks only exist to make fun of ruby
07:26:38 <abens> haha
07:26:38 <soupdragon> @quote
07:26:39 <lambdabot> Loriel says: I will forever feel funny talking about C++ because I cannot say 'functor' to mean 'object with operator()' anymore without feeling ridiculous. Thanks, Haskell!
07:26:46 <soupdragon> @quote
07:26:46 <lambdabot> hexpuem says: [on learning haskell] the best way is to shove a SD card up your nose with learn yourself a haskell good on it
07:26:51 <soupdragon> @quote
07:26:52 <lambdabot> kealyow says: can you make a macro that builds the expression accoridng to those MODULAR LOVE UNITS??
07:27:05 <cdsmithus> Oh yeah, I'd forgotten that bastardized meaning of "functor"
07:27:08 <Peaker> Heh, that quote from Loriel actually is true.. In c++ discussions I almost shiver
07:27:32 <hpc> what's a c++ functor?
07:27:42 <abens> anything you can call
07:27:46 <cdsmithus> hpc, any object that overrides the "()" operator so it can be called like a function
07:27:57 <hpc> o.O
07:27:59 <cdsmithus> Err, I meant overloads
07:28:28 <Taejo> I, for one, welcome our operator-overloading overlords
07:28:42 <soupdragon> @quote
07:28:42 <lambdabot> BlairPHoughton says: "In My Egotistical Opinion, most people's C programs should be indented six feet downward and covered with dirt." -- Blair P. Houghton
07:28:52 <hpc> @quote intercal
07:28:53 <ulfdoz> hier
07:28:53 <lambdabot> faxathisia says:  > (fun $ intercalate (map chr [0x0d, 0x0a])$ map (concat.map (\(e,r) -> replicate e ' ' ++ replicate r '@'))[[(0,3)],[(3,2)],[(3,3)],[(2,2),(1,2)],[(0,2),(3,2)]]) :: Expr
07:28:57 <ulfdoz> ewin, sry
07:29:02 <hpc> @quote apl
07:29:02 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
07:29:09 <hpc> :(
07:29:24 <Phyx-> @quote Phyx
07:29:24 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
07:29:27 <Phyx-> @quote Phyx-
07:29:27 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
07:29:35 <Phyx-> guess i'm not funny
07:29:37 <hpc> @quote lisp
07:29:38 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
07:29:38 <soupdragon> @quote
07:29:38 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
07:29:40 <soupdragon> @quote
07:29:40 <lambdabot> conal says: iow: don't just *say* things precisely (syntax & types), *mean* things precisely (semantics).
07:30:00 <arw> @quote pascal
07:30:00 <lambdabot> monochrom: says:  Turbo Pascal is the best thing since GHC.
07:30:12 <hpc> brilliant!
07:30:21 <Phyx-> was he on something that day?
07:31:05 <hpc> @quote vb.net
07:31:06 <lambdabot> No quotes match. There are some things that I just don't know.
07:31:18 <hpc> @quote ruby on rails
07:31:19 <lambdabot> No quotes for this person. You type like i drive.
07:32:41 <hpc> @quote rail
07:32:41 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
07:33:06 <Silvah> @quote template
07:33:07 <lambdabot> fnord123 says: Haskell mainly helps with my C++ template coding when I'm doing money oriented programming
07:34:06 <Peaker> Maybe the @quote stuff can go in #haskell-blah ?
07:34:19 <Phyx-> or maybe you can just pm the bot
07:41:25 <dpratt71> Phyx-: would you, perchance, be working on a Haskell editor (or something more ambitious) in VS 2010?
07:43:56 <soupdragon> :t divMod
07:43:57 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
07:44:03 <soupdragon> > divMod 10 17
07:44:04 <lambdabot>   (0,10)
07:44:47 <soupdragon> > let l n = case divMod n 17 of (q,r) -> q : l (10*r) in l 10
07:44:48 <lambdabot>   [0,5,8,8,2,3,5,2,9,4,1,1,7,6,4,7,0,5,8,8,2,3,5,2,9,4,1,1,7,6,4,7,0,5,8,8,2,...
07:44:55 <soupdragon> > 1/17 :: CReal
07:44:56 <lambdabot>   0.0588235294117647058823529411764705882353
07:47:07 <soupdragon> so taht's long division really
07:47:22 <Phyx-> dpratt71: yes
07:47:33 <dpratt71> Phyx-: cool
07:47:44 <soupdragon> @let longDivide a b = let l n = case divMod n b of (q,r) -> q : l (10*r) in l a
07:47:44 <dpratt71> Phyx-: how's it coming?'
07:47:45 <lambdabot>  Defined.
07:47:49 <soupdragon> > longDivide 22 7
07:47:51 <lambdabot>   [3,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,...
07:47:53 <soupdragon> ^ pi
07:48:46 <Phyx-> dpratt71: pretty good, god typechecking to work this week, now i'm working on filling the EDI with the info and i'll move on to cabal support next
07:50:28 <Phyx-> IDE*
07:50:36 <Phyx-> got*
07:50:39 <Phyx-> heh, lots of typos
07:53:12 <dpratt71> Phyx-: very nice; looking forward to taking it for a spin when you get there :)
07:54:03 <b0fh_ua> Hi. Is there any convenient way to update value of a field of a nested record of another record?
07:55:00 <Phyx-> dpratt71: for the first one i just want to match the features of the old one, and move on from there. i should have a stable version around july. I currently only have time to work on it in the weekends
07:55:14 <hpc> x {a = (a x) {b = y}}
07:55:21 <hpc> like that?
08:11:44 <soupdragon> h = fold f <=> h . in = f . F h  wut
08:12:37 <soupdragon> @free foldr
08:12:39 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
08:12:58 <soupdragon> @free maybe
08:12:59 <lambdabot> f . h = k . g => f . maybe x h = maybe (f x) k . $map_Maybe g
08:13:11 <mxc> b0fh_ua: not without one of the non-standard record libraries like fclabels
08:20:51 <soupdragon> "To illustrate our new worker/wrapper technique, we now move from the abstract world of
08:20:51 <soupdragon> category theory to the concrete world of Haskell"
08:20:53 <soupdragon> HAH!
08:23:20 <olsner> soupdragon: well, haskell is executable (evaluable?)
08:25:12 <byorgey> so are appropriate categories
08:25:25 <dark> @free is http://www.haskell.org/haskellwiki/Pointfree ?
08:25:26 <lambdabot> Extra stuff at end of line
08:25:49 <byorgey> @free (a -> b) -> f a -> f b
08:25:49 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
08:25:56 <byorgey> no, it generates free theorems
08:26:02 <Silvah> dark: it's not. @pl is pointless.
08:26:22 <dark> @pl foldr a
08:26:22 <lambdabot> foldr a
08:26:30 <soupdragon> @free (+)
08:26:30 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
08:26:39 <byorgey> @free a -> a
08:26:40 <lambdabot> Extra stuff at end of line
08:26:42 <soupdragon> lol
08:26:46 <byorgey> @free id :: a -> a
08:26:46 <lambdabot> f . id = id . f
08:27:00 <byorgey> @free map :: (a -> b) -> f a -> f b
08:27:00 <lambdabot> Extra stuff at end of line
08:27:06 <byorgey> bah
08:27:50 <dark> @pl \x y z -> f (g x y) z
08:27:50 <lambdabot> (f .) . g
08:28:17 <Silvah> @pl \x y -> f (g x y)
08:28:17 <lambdabot> (f .) . g
08:28:29 <Silvah> @pl \x y z -> f (g x y z)
08:28:30 <lambdabot> ((f .) .) . g
08:28:36 <dark> the point is actually part of haskell syntax?
08:28:41 <Makoryu> @pl \f g h -> f . g . h
08:28:41 <lambdabot> (. (.)) . (.) . (.)
08:28:54 <Phyx-> dark: it's a function
08:28:54 <Silvah> It's not.
08:28:56 <Makoryu> dark: It's an ordinary function
08:29:00 <Silvah> dot it's just a function.
08:29:00 <Phyx-> @src (.)
08:29:00 <lambdabot> (f . g) x = f (g x)
08:29:00 <lambdabot> NB: In lambdabot,  (.) = fmap
08:29:02 <Silvah> @src (.)
08:29:03 <lambdabot> (f . g) x = f (g x)
08:29:03 <lambdabot> NB: In lambdabot,  (.) = fmap
08:29:16 <Makoryu> dark: In Haskell, a function can have an infix name so that you can use it as an operator
08:29:38 <dark> @pl (.) a
08:29:39 <lambdabot> (a .)
08:30:03 <dark> it's the y combinator?
08:30:10 <Makoryu> > let ($$$) = replicate in 3 *** "Haskell is great"
08:30:11 <lambdabot>   Couldn't match expected type `a b' c''
08:30:11 <lambdabot>         against inferred type `[GHC....
08:30:14 <dark> fixed-point
08:30:26 <Makoryu> The hell?
08:30:30 <Makoryu> Oh my bad
08:30:34 <Makoryu> > let ($$$) = replicate in 3 $$$ "Haskell is great"
08:30:35 <lambdabot>   ["Haskell is great","Haskell is great","Haskell is great"]
08:30:41 <Makoryu> I changed one but not the other >_>
08:30:46 <cdsmithus> dark: No fixpoint combinators have some up that I have seen, no.
08:31:01 <Makoryu> dark: The fixed-point combinator is fix
08:31:02 <dark> @pl (.) a b
08:31:02 <lambdabot> a . b
08:31:04 <Makoryu> :t fix
08:31:05 <lambdabot> forall a. (a -> a) -> a
08:31:07 <Makoryu> :t (.)
08:31:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:31:10 <cdsmithus> dark: The dot is function composition, if that's what you're asking
08:31:16 <dark> @src fix
08:31:16 <lambdabot> fix f = let x = f x in x
08:31:19 <dark> ah
08:32:20 <cdsmithus> It is ironic that "point-free" notation adds so many decimal points (for function composition) to the code.
08:33:04 <dark> i suppose point-free has something to do with the fixed-point combinator
08:33:19 <dolio> No.
08:33:23 <cdsmithus> dark: Not really, no... though fixpoints can be useful for defining point-free functions
08:33:52 <dolio> Named variables are points.
08:34:02 <dark> ah
08:34:08 <cdsmithus> dark: "Point" in point-free means named formal parameters... iu.e., in (\x -> x + 1), x is a point
08:34:14 <dark> i see a "fixed point" as a point of a function where f(x) = x
08:34:25 <soupdragon> that's right
08:34:41 <dark> all functions can be rewritten for having no named parameters?
08:34:51 <soupdragon> dark, sort of...
08:34:52 <Makoryu> dark: Not all
08:35:20 <Makoryu> dark: Some functions (in Haskell, at least) need to perform explicit pattern matching
08:35:30 <soupdragon> all functions that don't do case analysis or weird type hacks or...... maybe ti would be easier to define a class of functison that you can do it with
08:35:34 <dolio> It depends what primitives you have.
08:35:42 <Makoryu> If we had first-class pattern matching, maybe we could get away with it 
08:35:49 <dark> hm
08:36:04 <cdsmithus> Yes, there does exist some recursively enuerable set of primitives so that all functions can be point-free. :)
08:36:07 <dark> nice unicode emoticon
08:36:59 <dark> Makoryu, what is "first-class pattern matching"? having functions that receives its pattern matching as a parameter, composing two patterns etc?
08:37:02 <cdsmithus> (That was sort of a joke... but a bad one)
08:37:05 <soupdragon> wow you can do folds on GADTs...
08:37:08 <soupdragon> I didn't know that
08:37:35 <dark> cdsmithus, (I of course almost got any meaning, let alone a joke)
08:37:45 <Makoryu> dark: Pretty much
08:38:08 <soupdragon> "the time complexity is reduced from quadratic to linear.
08:38:08 <soupdragon> For example, in a simple experiment using the Glasgow Haskell Compiler the time for
08:38:08 <soupdragon> n = 10000 was reduced from around 90 seconds to 0.2 seconds."
08:38:09 <soupdragon> win
08:38:18 <soupdragon> Codensity monad ^
08:38:19 <dark> Makoryu, and what happens with the type system?
08:40:29 <dark> Makoryu, would one need to describe a partial match in the type system? also, could someone build a match in runtime? how would the compiler know a certain match would never fail?
08:40:39 <gcollins> c_wraith: yeah that 'error "foo" >> exitFailure' code sucks
08:41:27 <Makoryu> dark: It's conceivable that you could implement first-class patterns of some kind as a Haskell extension without actually changing the type system
08:41:38 <dark> i think that letting the matching happen in run time may make it hard to prove correctness
08:42:05 <Makoryu> dark: Sure. It depends on what features you have exactly, though
08:42:13 <dark> Makoryu, but, if the type system isn't expressive enough for describing the "kinds" of match (in special, the match that never fails), one would never know if a particular match is safe
08:42:18 <hpc> a pattern can have a type
08:42:30 <hpc> (Just f) :: Maybe a
08:42:34 <Cale> soupdragon: :) What example was that?
08:42:50 <soupdragon> something to do with finding a leaf of a tree
08:43:33 <soupdragon> http://www.cs.nott.ac.uk/~gmh/f5.pdf -- nicely ties together some of the strange tricks about optimization
08:43:34 <Makoryu> dark: Haskell doesn't allow type-level functions at all right now, so that's moot :p
08:43:48 <jmcarthur> well, it sort of does
08:44:28 <jmcarthur> type families are reasonable way to hack in certain kinds of type-level functions
08:45:03 <dark> type-level function: maps a type to a type?
08:45:09 <jmcarthur> yeah
08:46:06 <dark> it maybe requires types to be treated as values
08:46:09 <jmcarthur> type family Foo a; type instance Foo Int = Bool; type instance Foo Char = Maybe String
08:46:32 <Makoryu> dark: There are a number of languages that will nonchalantly do exactly that
08:46:44 <dark> coq, maybe?
08:47:41 <Makoryu> I dunno actually
08:48:00 <soupdragon> imagine if you could write a funcction on Haskell
08:48:04 <soupdragon> f :: Bool -> *
08:48:07 <soupdragon> f True = Integer
08:48:12 <soupdragon> f False = Bool
08:48:23 <soupdragon> then you could do like  x :: f a -> f (not a)
08:49:07 <dark> not a? it isn't a type..
08:49:14 <soupdragon> ya it's a Bool
08:49:16 <soupdragon> :t nt
08:49:17 <lambdabot> Not in scope: `nt'
08:49:19 <soupdragon> :t not
08:49:20 <lambdabot> Bool -> Bool
08:49:27 <dark> not is a function, but not a type
08:50:01 <dark> ah
08:50:06 <dark> hm
08:50:08 <dark> o.o
08:50:10 <Cale> dark: f is a function from values to types
08:50:16 <hpc> f takes a Bool and returns a type
08:50:32 <hpc> so f a -> f (not a) is Integer -> Bool when a is true
08:50:34 <soupdragon> Warning: This is made up haskell code
08:50:39 <hpc> and Bool -> Integer when a is false
08:50:45 <hpc> yeah, hypothetically
08:50:58 <bremner> s
08:50:59 <arw> hm. /me wishes for "vector 17" which creates a 17-dim vector type :)
08:51:03 <bremner> errr, sorry
08:51:26 <arw> certainly sounds very useful.
08:51:42 <soupdragon> yes!
08:52:04 <soupdragon> but it also makes type inference and stuff harder (which is probably a good thing.. getting hte computer to do more work)
08:52:05 <jmcarthur> arw: vector-static :)
08:52:13 <jmcarthur> arw: but it's incomplete and abandoned
08:52:13 <Cale> You'd probably want to insist that f's name start with an uppercase letter, but that's just syntax :)
08:53:28 <dark> soupdragon, but it wouldn't compile in most cases
08:53:57 <dark> if a isn't known in runtime, the compile would have to know the "type of things that may either be Integer or Bool", a sort of dynamic typing
08:54:41 <dolio> If you do case analysis on a, you know in each branch what the value of a is.
08:54:55 <soupdragon> dark - yeah the implicit quantification sort of breaks down here
08:55:05 <arw> dark: but thats not that much of a difference from Something Bool | OtherThing Integer
08:55:09 <dark> but what if get this value that can be either integer or bool, and sum with 1?
08:55:17 <dmead> hey channel
08:55:18 <dark> it is valid only if a is true
08:55:31 <soupdragon> you're gith
08:55:32 <soupdragon> right*
08:55:33 <dmead> where is the setting for ghci that tells it to read user installed cabal packages?
08:55:40 <soupdragon> This sort of stuff breaks type inference
08:55:53 <dmead> I can't get ghc to load packages that cabal is happy to configure and install
08:55:57 <dark> arw, no, it is.. you don't have syntactic means of "breaking" the value into its possibilities without such explicit approach
08:56:08 <soupdragon> compiler would ask you to add annotations sometimes, stuff like that
08:56:19 <arw> dark: right, the compiler cant statically check what it will only know at runtime.
08:56:49 <arw> dark: sorry, i forgot about the "only at runtime" problem :)
08:56:52 <dolio> Classes could be extended to do the case analysis.
08:56:59 <soupdragon> Cale I can prove that all math is broken in one word: Banach Tarski
08:57:15 <dark> arw, there is a maybe similar problem, of having explicit mutable cells vs. everything being mutable, and the propagation of constness (bitC is trying to do the 'everything is mutable', instead of doing like ocaml that has reference cells; and it has hard problems)
08:57:23 <dolio> class C (a :: Bool) where f :: f a -> f (not a)
08:57:35 <dolio> Oops, that first f should be something else.
08:57:50 <dark> propagation of constness and polymorphism
08:57:57 <Silvah> soupragon: those are two words.
08:57:57 <Cale> soupdragon: Hm?
08:58:02 <soupdragon> it was a joke
08:58:09 <Cale> soupdragon: Banach-Tarski is perfectly reasonable
08:58:13 <soupdragon> ;[
08:58:18 * soupdragon goes back to the drawing board
08:58:19 * Cale fails to see it as a paradox ;)
08:58:46 <Cale> It's only weird until you notice that the 'pieces' that it cuts the ball into are nonmeasurable sets.
08:58:47 <dark> it's *not* :(
08:59:01 * soupdragon thought it was really funny :P
08:59:22 <Cale> It would be funny if you were serious :)
08:59:22 <dark> it's just a weird property of set theory
09:00:12 <Cale> dark: Or of the properties we insist volume should have.
09:00:14 <cdsmithus> Okay, I admit it.  I just don't understand the initial algebra description of folds.
09:00:40 <mxc>  no, soupdragon is right
09:00:45 <soupdragon> cdsmithus: I think I got a tiny bit closer to understanding it ...
09:01:02 <Cale> cdsmithus: There's less to it in the end than you might think...
09:01:33 <mxc> if i have a unit sphere - thats what I have...  i cant just take it apart and have 2 unit spheres
09:01:35 <cdsmithus> What I don't understand is, it asks for a particular object A, and a morphism from F A -> A.  Why?  What does that mean?  What are A, and what is that morphism, for common folds like lists?
09:02:09 <soupdragon> cdsmithus: I think A is arbitrary
09:02:11 <Cale> cdsmithus: A is what we usually think of as an "F algebra" and the morphism sort of specifies the particular way in which it is one.
09:02:21 <dolio> (A, a : F A -> A) is the definition of an algebra.
09:02:21 <soupdragon> cdsmithus: So it means that it doesn't depend on any particular form of A
09:02:29 <Cale> Let's take a specific example
09:02:51 <Cale> data N a = Z | S a -- essentially Maybe
09:02:52 <cdsmithus> Wait a second... A has to be something specific.  It's a particular object... if A were a different object, then (A,f) might not be initial, right?
09:02:58 <Cale> This N is a functor
09:03:01 <cdsmithus> Okay
09:03:07 <Cale> and so we can discuss algebras of that functor
09:03:37 <Cale> an algebra is just a type A, which has a defined function  N A -> A
09:03:44 <opqdonut> (for example a monoid over the set X is given by X and (+) : X^2 -> X)
09:03:50 <cdsmithus> (The "wait a second" was to soupdragon, not you, Cale... I gotcha so far)
09:04:13 <dolio> For lists (with element type X), A is a type, and a : (1 + X*A -> A), which can be factored into z : A and f : X -> A -> A.
09:04:14 <Cale> cdsmithus: You're right about if A was a different object it might not be initial
09:04:15 <opqdonut> (err, actually not a monoid, but a magma or something)
09:04:15 <soupdragon> cdsmithus: are you reading a particular document?
09:04:24 <dolio> Which should look familiar.
09:04:37 <opqdonut> (anyway, my point is that F is kind of the "signature" of whatever functions are in the algebra)
09:04:38 <cdsmithus> Okay... so, intuitively, what does an algebra of N mean?  Why do we care about them?
09:04:38 <soupdragon> if it's the one I just linked, I would recommend you to a certain something else first
09:04:42 <soupdragon> cdsmithus %
09:05:06 <arw> mxc: measurability of sets is similarly non-intuitive as countability. the 'hilbert hotel' paradoxon is great for explaining that kind of difference between intuition and mathematics.
09:05:09 <Cale> cdsmithus: Well, what does it mean to have a function Maybe A -> A?
09:05:25 <Cale> Let's call that function f
09:05:41 <Cale> We have some special element (f Nothing) of A
09:06:00 <Cale> and we have, for each x in A, some (f (Just x)) of A
09:06:13 <mxc> FYI, the 'c' in mxc is my last name...
09:06:15 <mxc> cantor
09:06:17 <cdsmithus> Right, okay, so I got that.
09:06:31 <Cale> Or if we go with my original description, f :: N A -> A
09:06:51 <Cale> and we have f Z :: A, and for each x :: A we have f (S x) :: A
09:06:51 <soupdragon> cdsmithus: ???
09:07:03 <cdsmithus> Yes, so f is some choice of (f Z) together with some function (A -> A).  Got that much.
09:07:12 <Cale> So this sort of sets up A with a "zero" and a "successor" for each element
09:07:14 <mxc> and, i had a great uncle george...  he had 2 'e's in his name and wasn't a mathematician
09:07:36 <Cale> Now, what's a morphism between N-algebras?
09:07:49 <mxc> but a professor that I TAed for in college assumed that based on my name I had someone osmoted all of georg cantor's results at birth
09:07:51 <soupdragon> :/
09:07:54 <soupdragon> why are you ignoring me
09:07:55 <mxc> *somehow
09:08:19 <cdsmithus> Sorry, soupdragon, I don't follow IRC too well.
09:08:48 <cdsmithus> Soupdragon: Yes, I was motivated to figure this stuff out by reading the first part of the paper on Reddit now, but I've tried before as well
09:08:50 <Cale> If A and B are two such N-algebras (that is, they have zeroes and successors in the way I just described), then an N-algebra morphism phi: A -> B
09:08:59 <soupdragon> "paper on Reddit"?
09:09:51 <Cale> is a function A -> B which has the property that phi . f = g . fmap phi
09:10:00 <mxc> arw: i wonder if there was ever a hotel hilbert on futurama
09:10:08 <mxc> seems like their cup of tea
09:10:16 <cdsmithus> Cale: Okay, gotcha... and fmap phi is...
09:10:18 <Cale> These are both mappings N A -> B
09:10:23 <soupdragon> :/
09:10:28 <soupdragon> urgh
09:10:30 <Cale> fmap phi :: N A -> N B
09:10:40 <dark> Cale, I am not convinced our physical universe must obey the space the way mathematicians imagine
09:10:43 <cdsmithus> Right... it's just z maps to Z, and S x maps to S (phi x)?
09:10:52 <dark> I am not convinced it is continuous at all
09:10:53 <Cale> dark: Nor should you
09:11:02 <Cale> cdsmithus: right
09:11:36 <Phyx-> hmm does anyone know if http://www.amazon.co.uk/Category-Computer-Scientists-Foundations-computing/dp/0262660717/ref=pd_bxgy_b_img_c is a good book?
09:11:39 <dark> so "volume" is maybe something we should refrain from applying to mathematical constructs (or at least differentiate between "volumes in reality" and "volumes in this mathematical theory"..)
09:11:45 <Cale> cdsmithus: and so this just says that it's a function A -> B which preserves the zero and successors
09:11:49 <dark> so there's not wrong with anything ^^
09:12:02 <soupdragon> cdsmithus "paper on Reddit"?
09:12:12 <cdsmithus> soupdragon: There's a paper about folds on Reddit.
09:12:16 <soupdragon> Yes okay
09:12:18 <soupdragon> And what it is?
09:12:31 <cdsmithus> soupdragon: I don't know, and I'm trying to think about this stuff right now
09:12:35 <soupdragon> okay
09:12:38 <soupdragon> thanks a lot
09:13:29 <cdsmithus> Sorry, soupdragon, I'm not trying to be rude.  I'll go look it up.
09:13:51 <Cale> cdsmithus: That is, for Z we have phi (f Z) = g (fmap phi Z) = g Z
09:14:00 <cdsmithus> soupdragon: http://www.cs.nott.ac.uk/~gmh/f5.pdf was the paper that motivated me to try to figure this out again
09:14:05 <soupdragon> Right okay
09:14:13 <soupdragon> I just linked that a moment ago
09:14:28 <Cale> cdsmithus: and for S x, we have phi (f (S x)) = g (fmap phi (S x)) = g (S (phi x))
09:15:10 <Cale> and remember that f (S x) was our sort of "successor" operation on elements of A
09:15:33 <cdsmithus> Right
09:15:36 <arw> dark: the science which deals in "this mathematical construct applies (not) to that part of reality" is called physics, and yes, physicists think about that stuff a lot :)
09:15:37 <Cale> and correspondingly g (S y) is the "successor" on elements y of B
09:16:02 <Cale> So an N-algebra morphism is something which preserves the zeroes and successors
09:16:15 <Cale> So now we want to find an initial object
09:16:27 <Cale> in the category of N-algebras and their morphisms
09:16:38 <cdsmithus> Cale: Yes, I do see that, though I'm not terribly comfortable with it... i.e., it takes me a bit to work through the notation and understand that things are working out
09:16:49 <Cale> Yeah
09:18:12 <Cale> So, our initial object will be something nice where we'll have a unique N-algebra homomorphism from it to any other N-algebra
09:19:00 <cdsmithus> Cale: So I do see that the natural numbers, together with the morphism f(Z) = 0, f(S x) = x + 1, is an inital algebra.
09:19:10 <Cale> yeah
09:19:39 <Cale> and now suppose we have any other N-algebra, say B, with g :: N B -> B
09:20:16 <Cale> We want a map  phi :: Nat -> B  which ought to preserve the zero and successors, and be the unique way of doing that
09:20:38 <cdsmithus> Right, so that's easy.
09:20:51 <Cale> Right, just for fun though, let's use the laws :)
09:21:01 <Cale> phi . f = g . fmap phi
09:21:23 <Cale> So, phi (f Z) = g (fmap phi Z) = g Z
09:21:37 <Cale> of course, f Z = 0, as you said
09:21:42 <Cale> So phi 0 = g Z
09:21:58 <Cale> and...
09:22:16 <Cale> phi (f (S x)) = g (fmap phi (S x))
09:22:30 <Cale> = g (S (phi x))
09:22:42 <Cale> and so:
09:23:00 <Cale> phi (x + 1) = g (S (phi x))
09:23:16 <cdsmithus> Yep, got it.  And phi (x + 1) = g (fmap phi (S x)) = g (S (phi x))... as you typed at the same time I was typing it
09:23:17 <Cale> this gives us a recursive formula for phi :)
09:25:09 <Cale> So any N-algebra morphism Nat -> B will satisfy these equations, and I suppose it's a bit of a technicality that there's only one solution to those equations. (Given a finite natural number n, there's only one possibility for phi n)
09:25:41 <Null-A> Either is an instance of monad (right?), and when I call `return Y`, it lifts Y into Either using Right data construct (?), hence wouldn't the type signature of return be `Monad m => b -> m a?
09:26:00 <Null-A> instead its a -> m a
09:26:15 <Cale> I don't see where you're getting the b from
09:26:18 <dolio> return's signature is always Monad m => a -> m a
09:26:37 <Cale> Null-A: For each type e, Either e is a monad.
09:26:40 <Null-A> Cale: because the type of Y is different than what the monad is wrapping
09:26:58 * Null-A thinking
09:27:04 <Cale> Null-A: return x = Right x,  return :: a -> Either e a
09:27:12 <Peaker> Null-A, "Either" isn't an instance of monad. "Either l" is.  So the type of return here is still:  Monad m => a -> m a    because it is specifically:   a -> Either l a
09:27:20 <dolio> b -> Either a isn't well-kinded.
09:27:37 <Null-A> I see =)
09:27:45 <Cale> cdsmithus: So that should give you a bit of a feel for what's going on
09:27:47 <cdsmithus> Here's where I'm lost... So a fold for Maybe is just the function maybe z f x = case x of Nothing -> z ; Just t -> f t.  How are we getting closer to that?  Where are the natural numbers there?  Why did it do us any good to identify A as the naturals, and define this morphism from F A -> A?
09:28:08 <Cale> cdsmithus: Oh
09:28:12 <Null-A> thanks guys
09:28:19 <Cale> cdsmithus: Right, you're interested in folds :)
09:28:51 * hackagebot linkcore 0.4 - Combines multiple GHC Core modules into a single module  http://hackage.haskell.org/package/linkcore-0.4 (TimChevalier)
09:29:36 <dolio> Maybe isn't the inductive fixed point of itself.
09:29:51 <dolio> Nat is of Maybe.
09:30:40 <dolio> If you want a functor whose fixed point is "Maybe a", it's 'Const (Maybe a)'.
09:30:41 <cdsmithus> dolio: If you mean that Maybe Nat is isomorphic to Nat... yes, I see that.
09:31:40 <cdsmithus> or was that a different conversation?
09:31:47 <dolio> Then you have Const (Maybe a) algebras (R, a : Const (Maybe a) R -> R = Maybe a -> R = (a -> R) -> R -> R)
09:32:29 <dolio> I guess that probably got confusing with the two 'a's. My fresh variable chooser is off today.
09:33:10 <Cale> cdsmithus: Well, this initial algebra example we're doing is leading towards fold for naturals
09:33:17 <Cale> cdsmithus: Not the fold for Maybe
09:33:32 <cdsmithus> Ah
09:33:38 <dolio> If you want a really high-level picture, it's this: F specifies some language of operators. F-algebras are like semantic sets that are closed under the operations of F, and the initial F algebra is a set of F terms.
09:34:18 <dolio> And the catamorphism takes program term in the initial F-algebra to its semantic value in whatever set you've specified.
09:34:32 <cdsmithus> Cale: Okay, so I'll forget about folding Maybe, and we can fold naturals. :)
09:35:22 <cdsmithus> dolio: Saving that comment to read it later.  It makes general sense.
09:35:55 <dolio> For naturals, your operations are Z and S, nullary and unary respectively.
09:36:06 <cdsmithus> Cale: I just assumed that since your example was a Maybe type, that we were heading toward a fold for Maybe.  By mistake
09:36:10 <cdsmithus> ^My
09:36:53 <Cale> cdsmithus: So, all there is to folding naturals we've actually already described :)
09:37:25 <Cale> cdsmithus: Pick any type B and any function N B -> B, and you get a unique map Nat -> B
09:37:47 <cdsmithus> Cale: Got it.  So in a sense, you pick some type, figure out what its initial algebra is, and then the object (in category Hask) from that initial algebra is the type over which you can define a fold... right?
09:38:16 <Cale> The unique arrows from the initial algebra to every other algebra give you the fold
09:38:31 <cdsmithus> If so, that makes sense to me now.  I was just looking for a connection to folds on the original type, which is obviously not there.
09:39:14 <dolio> cdsmithus: Oh, and in that high-level description, the algebraic law you get from it being a homomorphism (a . fmap cata = cata . in) tells you how it computes.
09:39:44 <dolio> By directionalizing the equivalence.
09:41:12 <cdsmithus> Okay, going to poke at this some more.  Thanks for the help!  I was looking up the wrong tree
09:41:24 <dolio> If you deduce that 'cata Z = z', then you use that as a compute rule 'cata Z => z'.
09:41:51 <cdsmithus> dolio: What does that notation mean?  cata Z = z?
09:42:34 <dolio> Well, I'm over-simplifying. It'd be more like 'cata z s Z = z' in a Haskell program.
09:43:04 <dolio> z and s specifying the algebra in question.
09:43:10 <cdsmithus> dolio: Ah, okay.  Got it
09:44:18 <dolio> Anyhow, it's like how '(\x -> e) e' = e[x := e']' is an algebraic law for lambda terms, but operationally you rewrite things on the left to things on the right.
09:45:34 <dolio> Or eta '(\x -> f x) = f if x is not free in f', which people have used as either a reduction rule or an expansion rule.
09:46:37 * SamB_XP looks for the hollow bracket key on his keyboard
09:46:42 <Cale> foldNat :: (Maybe a -> a) -> (Nat -> a); foldNat f = g where { g Zero = f Nothing; g (Succ n) = f (Just (g n)) }
09:47:04 <Saizan> dolio: what's the functor that gives you those laws?
09:47:33 * SamB_XP wonders if there's a win32 native port of SCIM
09:48:19 <SamB_XP> (that is, non-cygwin)
09:49:02 <dolio> Saizan: I haven't seen a treatment of lambda terms as initial algebras (or terminal coalgebras), so I don't know. That isn't the point, though.
09:49:35 <Saizan> dolio: yeah, i've properly put the statement in context now, sorry :)
09:49:52 <Saizan> (it'd be nice though)
09:53:03 <dolio> "An initial algebra approach to term rewriting systems with variable binders" sounds promising.
09:53:46 <dolio> Looks like it's pay-only, though.
09:54:12 * SamB_XP wonders if anyone has made any progress towards proving stream fusion correct
09:55:21 <dolio> Man, even the guy's web site just links to Springer.
09:55:22 <c_wraith> SamB_XP:  depends on what part of it.  the map f . map g === map (f . g) part comes from the functor laws.
09:55:52 <opqdonut> and defining things with build is kinda self-evidently correct :)
09:56:12 <Saizan> google finds me a .ps with a slightly different name by the same author: http://www.cs.gunma-u.ac.jp/~hamana/Papers/btrs.ps
09:56:51 <drhodes> sunday morning fun in circular dependency land ~ cabal: dependencies conflict: ghc-6.12.1 requires directory ==1.0.1.1 however directory-1.0.1.1 was excluded because ghc-6.12.1 requires directory ==1.0.1.0  :)
09:57:18 <opqdonut> oh, build was an older thing
09:58:02 <MrBlueSky> Quick question, are binary trees functors?
09:58:09 <Saizan> drhodes: let me find you the faq for that :)
09:58:22 <c_wraith> MrBlueSky: they can be.
09:58:34 <Saizan> drhodes: http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
09:58:47 <c_wraith> MrBlueSky: There's a functor instance for Data.Map.Map k
09:59:06 <drhodes> Thanks Saizan, spent an embarassing amount of time yesterday trying to fix it.
09:59:14 <MrBlueSky> ohok
09:59:25 <Cale> MrBlueSky: If you have a type like   data Bin a = Tip | Branch a (Bin a) (Bin a)
09:59:39 <Cale> MrBlueSky: Then Bin is an easy Functor instance
09:59:43 <Cale> fmap Tip = Tip
09:59:46 <Cale> tsk
09:59:48 <Cale> fmap f Tip = Tip
10:00:04 <Cale> fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)
10:00:19 <MrBlueSky> gotacha, thanks Cale!
10:00:25 <MrBlueSky> and c_wraith!
10:11:07 <Polarina> Is there some good pure XML library? :)
10:12:37 <dons> 'xml' is a good one
10:12:37 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
10:14:09 <c_wraith> hmm.  I wonder why snap doesn't appear to provide a name for "finishWith =<< getResponse".  That seems like the most commonly-desired way to run finishWith
10:18:03 --- mode: ChanServ set +o mauke
10:18:03 --- kick: mauke was kicked by mauke (mauke)
10:18:16 * Twey scratches his head.
10:18:25 <Kaidelong> > fmap fmap fmap
10:18:26 <lambdabot>   Overlapping instances for GHC.Show.Show
10:18:26 <lambdabot>                              ((a ->...
10:18:43 <hpc> :t fmap fmap fmap
10:18:44 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:18:49 <soupdragon> :t (?f . fmap fmap fmap . ?g)
10:18:50 <lambdabot> forall b (f :: * -> *) a b1 (f1 :: * -> *) (f2 :: * -> *). (?f::(f (f1 a) -> f (f1 b1)) -> b, Functor f, Functor f1, ?g::f2 (a -> b1), Functor f2) => f2 b
10:19:07 <soupdragon> > ((*2) . fmap fmap fmap . (+)) 3 5
10:19:09 <lambdabot>   No instance for (GHC.Num.Num (f (f1 a)))
10:19:09 <lambdabot>    arising from a use of `e_1235' ...
10:20:36 <mauke> excellent
10:25:50 <Kaidelong> what's the difference between Functor and FunctorM?
10:27:10 <opqdonut> FunctorM?
10:27:13 <Kaidelong> oh I think I see
10:27:36 <Kaidelong> or maybe not
10:27:41 <Kaidelong> :t fmapM
10:27:42 <lambdabot> Not in scope: `fmapM'
10:27:44 <opqdonut> ah
10:27:52 <opqdonut> NOTE: This module is DEPRECATED. The classes in Data.Foldable and Data.Traversable provide a more general interface.
10:28:09 <mauke> Funkturm
10:28:20 <Kaidelong> oh, well I guess I better not use this guy's stuff then
10:28:30 <opqdonut> basically, fmapM sequences the fmaps in some (hopefully natural) order
10:28:36 <opqdonut> so you can apply something with side-effects
10:28:46 <opqdonut> in a list, the side-effects probably flow from left to right
10:42:19 <Athas> How can I convert a CString to [Word8]?
10:42:27 <Athas> I could do it manually, by first converting to String, but...
10:44:17 <Cale> Athas: You could go by way of Data.ByteString
10:44:52 <Cale> Data.ByteString.Unsafe.unsafePackCString :: CString -> IO ByteString
10:45:19 <Cale> and there are variations on that
10:46:12 <c_wraith> does the unsafe in that name indicate that it just wraps the CString in place?
10:46:18 <Athas> Actually, what I really want to do is use utf8-string to convert [Word8] to a String.  If anyone knows of a simpler way, I'd be very interested.
10:46:30 <Cale> Oh, hey, there's a safe one
10:46:34 <Cale> packCString :: CString  -> IO  ByteString
10:46:43 <hpc> why does converting from CString to ByteString require IO?
10:46:43 <Cale> I missed that at first
10:46:46 <c_wraith> Whereas that one copies?
10:46:49 <Cale> yeah
10:46:52 <c_wraith> hpc: because it mucks with pointers
10:46:58 <hpc> ah :\
10:46:59 <Cale> (that's what the difference is)
10:47:24 <Silvah> Everything in bytestring mucks with pointers.
10:47:36 <Cale> Also, unsafePackCString won't associate any finaliser with the ByteString, so you're still responsible for the memory
10:47:56 <c_wraith> some of the pointer-mucking can be unsafePerformIO'd.  Some can't.
10:47:57 <Cale> (despite that memory being part of the ByteString value ;)
10:48:03 <Silvah> Though internally inlinePerformIO takes care of getting rid of this pesky IO.
10:48:43 <Cale> hpc: It's not typically a big deal for it to be in IO
10:48:52 <Cale> hpc: You don't usually work with CStrings in any other context
10:49:17 <hpc> ah
10:49:21 <pikhq> hpc: ByteStrings are internally done using IO. They are unsafePerformIO'd because they are *externally* pure.
10:49:44 <pikhq> Even though inside, you're literally messing around with pointers and blocks of memory.
10:49:48 <Kaidelong> I think I've found an (ugly) solution to the problem I have been thinking of
10:49:51 <pikhq> (much like C)
10:50:14 <Silvah> Actually, bytestring does not use unsafePerformIO, at least not under GHC, where it's using something even uglier.
10:50:30 <c_wraith> ooh, that's fun :)
10:50:41 <Kaidelong> make my own, very general data type, which can be used to describe an "orderable value" which is essentially going to be a byte array
10:50:47 <pikhq> Silvah: Oh? Oh dear.
10:51:03 <Kaidelong> and then have functions that work on that accept functions from the calling code describing how to work on it
10:51:24 <Athas> It turns out that utf8-string has a function for just what I need.  Yay me.
10:51:39 <Kaidelong> so basically you end up with a data structure consisting of data and functions to work on it... I just re-invented OOP
10:51:41 <Athas> (Of course, the real problem is that the Xlib wrapper is really stupid about UTF-8.)
10:51:55 <c_wraith> Kaidelong: I was about to say that. :)
10:52:20 <Silvah> inlinePerformIO (IO x) = case x realWorld# of (# _, v #) -> v -- that's what bytestring uses.
10:52:20 <Kaidelong> makes me think I should do this project in F#
10:52:33 <dark> someone here was talking about algorithmic music and saying it's crap, http://www.youtube.com/watch?v=d2JvOwS26Zg
10:52:45 <dark> better quality http://code.haskell.org/synthesizer/hal2/supercollider-haskore/Air.mp3
10:52:49 <c_wraith> Oh.  It actually mucks with the internal representation of IO?  fun!
10:53:00 <dark> and sources http://darcs.haskell.org/haskore-supercollider/src/Haskore/Interface/SuperCollider/Example/Air.hs , i liked it o.o
10:53:19 <Silvah> Yeah.
10:53:22 <Kaidelong> dark: air wasn't really algorithmic was it? somewhere inbetween composed and generated
10:53:31 <Kaidelong> although
10:53:31 <dark> hm
10:53:38 <Kaidelong> I suppose you could say that for any algorithmic music
10:53:42 <Kaidelong> so it's kind of a moot point
10:53:56 <dark> really? ok..
10:54:04 <dark> hmm
10:54:18 <dark> one thing is trying to 'tune' an algorithm for making music
10:54:33 <dark> other thing is to run an algorithm that makes on its own, and then searching for good music
10:54:39 <dark> but well
10:55:01 <dark> it's a continuum
10:55:03 <Kaidelong> I think what they did more for Air was compose little sections
10:55:13 <Kaidelong> and then use algorithmic transforms on them to vary them
10:55:36 <danderson> hmm
10:55:42 <Kaidelong> so it was more intelligent design than a search over some space for something that sounded good (ala fractal music)
10:55:45 <dark> see the source (I can't understand much of it)
10:55:47 <Kaidelong> of course, I might be wrong
10:55:56 <danderson> is there a way to detach finalizers from a ForeignPtr?
10:56:23 <danderson> I'm looking for a way to manage foreign pointers, but at some points ownership is transferred from haskell to another piece of foreign code
10:56:34 <danderson> at which point I need to stop managing the lifetime of the pointer from Haskell
10:56:54 <danderson> but Foreign.ForeignPtr doesn't let you detach/disable finalizers
10:57:47 * Kaidelong ponders what to do, could re-invent OOP in haskell, which is ugly, limit himself to certain data types for ordered values in haskell, which is also ugly, or use F#, which is ugly in some other ways
10:58:07 <dark> why not ocaml?
10:58:13 <Kaidelong> dark: even uglier
10:58:20 <dark> uglier than f#?
10:58:21 <Silvah> W
10:58:27 <Kaidelong> dark: for what I'm doing
10:58:29 <dark> argue with more details
10:58:30 <Silvah> hy not malbolge?
10:58:32 <dark> hm
10:59:01 <Kaidelong> dark: the ability to use it with C# is helpful
10:59:05 <Kaidelong> easily, I mean
10:59:12 <dark> Kaidelong, are you using haskell on .net?
10:59:16 <Kaidelong> I'll have access to stuff like Pex and Winforms
10:59:24 <Kaidelong> dark: no, that project was abandoned IIRC
10:59:39 <dark> ah, you don't have something working
10:59:48 <dark> i prefer gtk to winforms
10:59:53 <Kaidelong> dark: this is a new project, hence why I'm still planning
11:00:13 <dark> Kaidelong, why oop/ordered values?[
11:00:19 <Twey> Kaidelong: You can use the DotNET library to call .NET code from Haskell.
11:00:30 <Kaidelong> dark: extensibility by people who will want to call my code at a later date
11:00:37 <Twey> Kaidelong: What is the problem you're trying to solve that you think requires OOP?
11:01:00 <Twey> (OOP has been implemented quite comprehensively in Haskell already  there's no need to re-invent the wheel)
11:01:01 <Kaidelong> Twey: I want my code to be able to use ordered values without being aware of their implementation
11:01:13 <Twey> Kaidelong: So like a typeclass?  :
11:01:15 <Kaidelong> haskell tries to prevent this by default, it seems
11:01:33 <Twey> I'm confused by this assertion.
11:01:34 <Twey> :t sort
11:01:36 <lambdabot> forall a. (Ord a) => [a] -> [a]
11:01:39 <Athas> How is this not the Ord typeclass?
11:01:43 <Kaidelong> Twey: the problem with a typeclass is that T a is not the same as T b
11:01:43 <cozachk> instance (Ord a)=> yourType a
11:01:51 <Twey> This is an example of a function that uses ordered values without knowing their implementation.
11:01:54 <Kaidelong> Athas: for my purposes, it isn't, different terminology
11:02:19 <dark> Kaidelong, and why should it be?
11:02:24 <Kaidelong> Twey: I need a collection that does not care whether it has a T a in it or a T b and can have both in it if it needs to
11:02:28 <cozachk> Kaidelong, do you want to be able to compare T a to
11:02:31 <cozachk> t b ]
11:02:34 <Athas> Kaidelong: Use existential quantifiers.
11:02:35 <Twey> Kaidelong: You want existential types
11:02:36 <dark> Kaidelong, do you want a collection of T's with different types?
11:02:49 <Athas> They will make you go all cross-eyed, but they are very useful.
11:02:54 <dark> so this is existential types
11:03:28 <cozachk> Kaidelong, how many different types do you need to compare?
11:03:33 <Kaidelong> I'll take another look at that then, I did not really understand it the first time
11:03:42 <jystic> Is there a way to do conditional compilation in .hs files so that I can use a different implementation of a function for Windows?
11:03:50 <sinelaw> haskell controlled robot http://www.youtube.com/watch?v=2ZblWWxeLsY&feature=player_embedded
11:03:56 <Kaidelong> cozachk: strictly speaking, you will only ever compare a T b to a T b, but it might have to live inside a collection with another T a
11:04:02 <Twey> Kaidelong: The example in http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types is the sort of thing you're talking about.
11:04:40 <Kaidelong> cozachk: I'd also like for people calling my code to be able to invent their own notions rather than using ones I picked like "Int" or "Double"
11:05:15 <Kaidelong> some people have have complicated vectors on n-dimensional space
11:05:19 <EvanR> whats a way to do this without defining h, let h x y f = (g f) x y in h x y f
11:05:23 <Kaidelong> that still have some natural ordering
11:05:44 <EvanR> you can do (g f) x y, but if f is a large expression i want to put it last
11:05:57 <EvanR> i.e. h x y f
11:06:25 <EvanR> x >$> y >$> f
11:06:33 <EvanR> erm, g f
11:06:42 <EvanR> bah
11:06:46 <hpc> :t (>$>)
11:06:47 <lambdabot> Not in scope: `>$>'
11:07:08 <EvanR> let x >$> f = f x
11:07:39 <hpc> or in pointfree, >$> = flip $
11:08:03 <EvanR> yeah
11:08:23 <EvanR> y >$> x >$> g f
11:08:24 <Twey> (>$>) = flip ($)
11:08:40 <hpc> i like it
11:09:33 <Twey> F# calls this (|>)
11:09:43 <cozachk> Kaidelong, are your a and b actually numbers? then use Num a
11:09:53 <EvanR> haskell needs a default def for it
11:09:58 <Kaidelong> cozachk: not quite
11:10:28 <Kaidelong> they define something akin to (-)
11:10:38 <cozachk> negate?
11:10:40 <Kaidelong> but nothing like (*) or (/) or (+)
11:10:43 <Kaidelong> no, difference
11:10:54 <abens> make it $>
11:11:02 <Kaidelong> so they're not Num but not Ord either
11:11:31 <Kaidelong> and it can be uncountable so not enum either
11:12:03 <cozachk> Kaidelong, enlighten me on how you can define something uncountable in a computer language
11:12:12 <Twey> > 1 / 0
11:12:13 <lambdabot>   Infinity
11:12:16 <Kaidelong> cozachk: you can't, strictly
11:12:16 <Twey> ;)
11:12:22 <Kaidelong> but floating point simulates that
11:12:22 <EvanR> i dont think its working very well with two arguments, there must be an associativity or precedence problem
11:12:53 <cozachk> Twey, but infinities can be countable :-/
11:13:13 <Twey> Not in finite time :
11:13:28 <sinelaw> preflex, seen chrisdone
11:13:29 <preflex>  chrisdone was last seen on #haskell-blah 1 day, 20 hours, 49 minutes and 16 seconds ago, saying: http://www.businessinsider.com/well-these-new-zuckerberg-ims-wont-help-facebooks-privacy-problems-2010-5
11:13:52 <sinelaw> preflex remembers quotes from haskell-blah? hmmm
11:14:16 <cozachk> Twey, you can count them in finite time if time is continous and your counting process can accelerate
11:14:54 <mauke> sinelaw: it remembers quotes from anywhere
11:15:08 <mauke> preflex: seen PoppaVic
11:15:08 <preflex>  PoppaVic was last seen on ##C 46 seconds ago, saying: * PoppaVic mutters inaudible imprecations..
11:15:10 <Kaidelong> cozachk: it's a bit comlicated to explain why I need this floating point notion of difference, but simply put, I need to evaluate things based on the difference in variance between two labels
11:15:43 <Kaidelong> either way it means I need a type class slightly different from Num, Enum, and Ord
11:15:53 <Kaidelong> which is annoying, really
11:16:23 <Kaidelong> Num would fill the purpose but is more specific than I need
11:16:49 <Kaidelong> Ord and Enum are too general
11:17:36 <Kaidelong> also unrelated, but last I knew, astronomers at least think time is not continuous
11:17:41 <cozachk> Kaidelong, do you have a 0 element ?
11:18:07 <EvanR> wild claims
11:18:20 <Kaidelong> cozachk: hmmm, have not thought of that. I'm inclined to say no, there is no special point anywhere like a 0
11:18:21 <cozachk> femtoseconds
11:18:54 <cozachk> kaidelong: you have T something and (-) T s - T s == 0
11:18:57 <Kaidelong> EvanR: something to do with the laws of physics being unknown when you go inside some very tiny interval of time
11:19:06 <Kaidelong> it has been a while
11:19:16 <EvanR> i have a deep loathing of pop physics
11:19:32 * hackagebot hpage 0.11.0 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.11.0 (FernandoBenavides)
11:19:38 <cozachk> we just cant measure time after a certain size of the interval
11:19:56 <Kaidelong> well I suppose that doesn't dictate that it is discrete
11:20:12 <EvanR> that probably true, due to quantum effects and limitations of possible hardware
11:20:36 <EvanR> but thats a long way from having a discrete domain
11:20:45 <Kaidelong> if you can't measure it I suppose you can't know whether it is really discrete or not
11:21:03 <Kaidelong> oh
11:21:08 <Kaidelong> planck time
11:21:15 <EvanR> yeah thats all over wikipedia
11:21:25 <EvanR> which is probably the worst source for physics facts that exists
11:21:30 <Kaidelong> Okay, I just took some astronomy years ago
11:21:45 <Kaidelong> guy from UW teaching it
11:22:30 <EvanR> also i have a feeling that certain physics professionals have become so bored with their work that they dont care if they say things that have no formal backing
11:22:32 <Kaidelong> remembered something about how unless something really big happens with a theory of everything, that you couldn't measure things that are transient within a certain unit of time
11:22:42 <EvanR> and you get the contents of the bookstore science section
11:23:01 <danharaj> :t []
11:23:02 <lambdabot> forall a. [a]
11:24:00 <EvanR> Kaidelong: that follows from basic relativity, theres this thing called the classical electron radius. the time it takes light to traverse this distance seems like a straightforward limit to the resolution of a real clock
11:24:05 <Kaidelong> I suppose for computation it is effectively not continuous since you have to observe the result
11:24:25 <Kaidelong> the computation machinery itself will have to observe it
11:24:51 <Kaidelong> so if you can't see stuff happening within planck time you can't do more than one computation within it
11:25:21 <danharaj> Whose to say your discrete unit of time coincides between reference frames?
11:25:25 <danharaj> who's
11:25:26 <danharaj> (
11:25:26 <danharaj> *
11:25:29 * danharaj >_<
11:25:40 <EvanR> exactly
11:25:44 <Kaidelong> hmm
11:26:04 <Kaidelong> but that won't let you calculate an infinite number of operations in finite time through accelerating speed, would it?
11:26:21 <Kaidelong> unless you're able to freeze time around you or something
11:26:30 <EvanR> the time it takes to traverse a length contracted classical electron radius is even less, so the rest 'length' would be the best case
11:26:34 <danharaj> Kaidelong: You would need an infinite amount of energy to compute an infinite amount of operations anyway.
11:27:13 <EvanR> i dont know how we got from measuring time intervals to doing computations
11:27:21 <mux> I'd like to understand what's up with cabal install which started thinking it was a good idea to reinstall the base packages into my user db, breaking lots of things in the process
11:27:23 <EvanR> one is not a limit of the other
11:27:24 <Kaidelong> EvanR: that was the original subject
11:27:29 <EvanR> oh
11:27:52 <EvanR> so yeah normal computations arent limited by plank time, theres parallel computation and other things
11:28:10 <Kaidelong> someone said that if you can accelerate your computation speed, and time is continuous, you can calculate an infinitely complex task in finite time
11:28:28 <EvanR> also sounds dubious
11:29:06 <Kaidelong> EvanR: asymptotic limit of computations against time
11:29:14 <koala_man> reasoning seems fair, but the assumptions do not
11:29:21 <Kaidelong> yes
11:29:24 <Kaidelong> that was my thinking
11:29:25 <c_wraith> the time used needs to fall off logarithmically vs number of computations, as well as the energy used
11:30:02 <Kaidelong> err
11:30:04 <c_wraith> the math for describing it is sound.  But it's not based on a model of physics I'm familiar with. :)
11:30:06 <Kaidelong> not limit, rather the lack of one
11:30:08 <danharaj> can a type constructor return a polymorphic type?
11:30:50 <EvanR> :t Reader Int
11:30:51 <lambdabot> Not in scope: data constructor `Int'
11:31:08 <Kaidelong> c_wraith: the one time I read a book on metaphysics I pretty much was unable to follow once they got to infinite velocities
11:31:16 <whh> I have a newbie question about deriving Show -- if I have a data type where one of the constructors includes a function (e.g. Int -> Int) do I have to write the entire Show by hand, or is there a trick to override just that one case, (e.g. my type is like: data Expr = ... | Fun String (Expr -> Expr) -- I only want to show the string in this case)
11:31:19 <EvanR> metaphysics
11:31:20 <Kaidelong> philosophy in general has not appealed to me
11:31:35 <Kaidelong> very term heavy and hard to grasp
11:31:59 <Null-A> unfalsfiable theories aren't worth your time
11:32:00 <sinelaw> i just saw a nice theorem by Chaitin that you can't prove that a theorem has a higher complexity than your axioms
11:32:09 <sinelaw> (there's a bound)
11:32:24 <EvanR> since theres no way to differentiate 'serious' metaphysics with this guy http://www.tenthdimension.com/, the whole thing is basically offensive
11:33:46 <Kaidelong> EvanR: I wouldn't call any of it serious, it's mental masturbation
11:33:48 * c_wraith abandons metaphysics to watch south park
11:33:50 <abens> falsifiablility has never been the driving force behind scientific progress though (not endorsing nonsense of course)
11:34:16 <sbpaul_> O_O
11:34:23 <cozachk> how is computer science even a science?
11:34:25 <EvanR> i guess if you think string theory is progress
11:34:29 <sbpaul_> oh the "driving" force
11:34:35 <danharaj> Mathematics is menta masturbation too.
11:34:42 <abens> I think of it as an application of math.
11:34:54 <sbpaul_> computer science is application of knowledge about electronics
11:35:01 <sbpaul_> far better qualified as "technology" than 'science"
11:35:03 <soupdragon> computer science is applied masturbation
11:35:03 <sinelaw> wtf
11:35:04 <Kaidelong> danharaj: that's true, and philosophers apparently are able to make money in some situations few and far between
11:35:10 <mux> computer science has nothing to do with electronics, nor computers
11:35:11 <sinelaw> what's going on here
11:35:18 <EvanR> computer science has as much to do with computers as astronomy is about telescopes ;)
11:35:21 <sinelaw> is this ##visualbasic now?
11:35:21 <cozachk> computer science existed before computational electronics
11:35:23 <sbpaul_> i would have to disagree...
11:35:35 <mux> sbpaul_: see EvanR's quote, from Knuth, IIRC.
11:35:44 <EvanR> ' '
11:35:47 <sbpaul_> yes, there were computers before electronics
11:35:51 <sbpaul_> but now our computers are electronic
11:35:58 <EvanR> there were algorithms before computers
11:35:58 <mux> both computers and electronics are irrelevant
11:36:01 <sbpaul_> and most of our concerns are about how they handle processing
11:36:13 <mux> CS is about computation in the abstract sense, it doesn't care about the hardware
11:36:33 <Kaidelong> mux: that would make it a sort of mathematics, really
11:36:38 <sbpaul_> to the degree computation in the abstract sense is dependent on the hardware
11:36:42 <mux> Kaidelong: that's precisely what it is
11:36:43 <abens> string theory is a theoretical research program, nothing more. it lets people get a degree and continue the tradition.
11:36:44 <EvanR> a graph reduction scheme seems pretty far from any real hardware, i cant think of any straightfoward hardware for it
11:36:44 <sbpaul_> CS is about electronics
11:36:55 <mux> sbpaul_: no
11:37:04 <sbpaul_> that was a two part message
11:37:17 <mux> that was a one part answer :-)
11:37:24 <sbpaul_> fine
11:37:50 <Kaidelong> so what you're saying is that because we need to know how to use telescopes to do astronomy
11:37:56 <Kaidelong> astronomy is, in part, about telescopes?
11:38:07 <sbpaul_> the telescope is a tool in astronomy
11:38:16 <sbpaul_> no what you're saying is like saying that
11:38:23 <EvanR> you dont need a computer to carry out the computations, its just a tool
11:38:30 <mux> computer science should just be named something else
11:38:31 <sbpaul_> since telescopes use glasses to transmit light
11:38:34 <sbpaul_> it's irrelevant
11:38:39 <sinelaw> dijsktra didn't even use a computer most of his career
11:38:43 <sbpaul_> to understand optics
11:38:46 <EvanR> the planets are still out there if you dont see them
11:38:48 <sbpaul_> as a part of telescope science
11:38:49 <sinelaw> he didn't have one at home even
11:38:54 <sbpaul_> EvanR: prove it ;)
11:39:02 <EvanR> i saw mars the other day
11:39:06 <sbpaul_> liar
11:39:07 <EvanR> bright enough to see without one
11:39:16 <Kaidelong> you still have a lens in your eye
11:39:19 <EvanR> i also computed some numbers using the division algorithm
11:39:21 <EvanR> in my head
11:39:22 <sbpaul_> anyway, my point is, science just means "knowing"
11:39:26 <sinelaw> computer science is not like astronomy, it's a branch of mathematics - not an empirical science
11:39:29 <sbpaul_> so "computer science" = "knowing computers"
11:39:32 <sinelaw> cs doesn't need computers at all
11:39:38 <sbpaul_> and if you know computers, you know they use electronics!
11:39:40 <sbpaul_> end of story
11:39:42 * hackagebot RMP 0.0.2 - Binding to code that controls a Segway RMP  http://hackage.haskell.org/package/RMP-0.0.2 (NoamLewis)
11:39:44 * hackagebot allocated-processor 0.0.2 - Functional combinators for monadic actions that require allocation and de-allocation  http://hackage.haskell.org/package/allocated-processor-0.0.2 (NoamLewis)
11:39:46 * hackagebot cv-combinators 0.1.2.3 - Functional Combinators for Computer Vision  http://hackage.haskell.org/package/cv-combinators-0.1.2.3 (NoamLewis)
11:39:48 * hackagebot HOpenCV 0.1.2.2 - A binding for the OpenCV computer vision library  http://hackage.haskell.org/package/HOpenCV-0.1.2.2 (NoamLewis)
11:39:53 <sinelaw> hehe :)
11:39:53 <EvanR> telescopes also use electronics
11:39:54 <sbpaul_> go run ghc on a cucumber
11:39:58 <EvanR> so CS is now astronomy?
11:40:05 <sbpaul_> omg
11:40:16 <Kaidelong> EvanR: it's a popular analogy
11:40:20 <EvanR> lol
11:40:24 <sbpaul_> no
11:40:25 <Kaidelong> I heard it too
11:40:31 <sbpaul_> but now astronomy uses tools from computer science
11:40:42 <EvanR> computer engineering maybe
11:40:44 <mux> CS basically never considers hardware, except when dealing with efficiency, where it only assumes there's some harware on which doing something twice is going to be slower than doing it one. that's a pretty broad assumption :-P
11:40:54 <mux> s/one/once/
11:41:22 <Kaidelong> mux: I have to take some classes on intel architecture to get my degree, well, already taken them, but still, it's ot like we just ignored it
11:41:30 <sinelaw> since this is such a productive discussion, i would like to propose those interested to watch my haskell-controlled robot: http://www.youtube.com/watch?v=2ZblWWxeLsY&feature=player_embedded
11:41:37 <mux> Kaidelong: that's just not CS...
11:41:42 <mux> see what sinelaw said
11:41:42 <EvanR> thats a funny assumption because when i do addition i memoize so i dont have to compute it again, so the assumption fails for me ;)
11:41:43 <sinelaw> enjoy
11:41:47 <mux> CS is just a branch of mathematics
11:41:55 <sbpaul_> by that reasoning
11:41:59 <sbpaul_> all science is just a branch of mathematics
11:42:06 <sbpaul_> the problem is that science deals with reality
11:42:11 <sbpaul_> and math deals with absolute truths
11:42:17 <sbpaul_> mathematical truths
11:42:27 <EvanR> sbpaul_: yeah computer science is neither science or computer
11:42:32 <mux> no, biology, engineering, and countless other sciences cannot be said to be branches of mathematics
11:42:41 <sbpaul_> by that same reasoning
11:42:42 <sbpaul_> it could
11:42:49 <sinelaw> mux engineering too actually :)
11:42:55 <sinelaw> at least parts of it
11:43:03 <dons> interesting post on reddit haskell: http://gergo.erdi.hu/blog/2010-05-23-efficient_type-level_division_for_haskell/
11:43:11 <Kaidelong> I like your robot
11:43:15 <Kaidelong> err, whoever posted that
11:43:19 <mux> sbpaul_: that's just wrong; biology for instance deals with very tangible things all the time, CS doesn't, end of line
11:43:20 <sbpaul_> "oh, all populations grow at some rate, the implementations are just part of it"
11:43:21 <sinelaw> Kaidelong, me
11:43:32 <sbpaul_> yeah and CS doesn't...pssh
11:43:47 <sbpaul_> stack overflows are tangible, deleting your harddrive is tangible
11:43:52 <sinelaw> sbpaul_, that's not CS
11:43:58 <sbpaul_> what is it then?
11:44:02 <mux> sbpaul_: and none of those things are related to CS in any way..
11:44:05 <sbpaul_> computer omniscience?
11:44:06 <Kaidelong> sinelaw: I don't know if I'd be that strict about it
11:44:10 <mux> computer technologies
11:44:11 <dons> what's your favorite "secret" hackage package? http://stackoverflow.com/questions/2891160/which-is-your-favorite-hidden-gem-package-on-hackage
11:44:19 <Cale> Computer science is unfortunately named
11:44:24 <mux> Cale: yep
11:44:26 <danharaj> Informatique
11:44:30 <Cale> It's not about computers, and it's not a science.
11:44:40 <Kaidelong> It's about knowing things
11:44:45 <danharaj> The word science has drifted.
11:44:51 <sbpaul_> i think anything grounded in empirical phenomena is a science
11:44:53 <Kaidelong> wetenskap
11:44:54 <sinelaw> sbok, a lot of stuff in CS is about abstract machines and the computability limits of any theoretical "computer", for example. that's just mathematics
11:44:54 <sbpaul_> call me old fashioned
11:44:59 <Mkman> hey
11:45:00 <mux> yeah, the french word for CS, "informatique", is much better
11:45:10 <andrewsw> it's about determining what sorts of things are computable
11:45:10 <Kaidelong> "rekenaarwetenskap" is a fine word for me
11:45:16 <kar-1> CS combines mathematics with thinking about resource usage
11:45:16 <Kaidelong> translates directly to computer science
11:45:17 <mux> err, cheers :D
11:45:20 <Cale> sbpaul_: It's not really grounded in empirical phenomena.
11:45:20 <sbpaul_> any science can produce abstract equations
11:45:27 <sbpaul_> oh, but it is
11:45:32 <sinelaw> i've had enough.
11:45:37 <sbpaul_> computers are real
11:45:44 <sbpaul_> the equations have to be useful in that context
11:45:50 <Kaidelong> Cale: computers still have to run your algorithm and you still have to know how to build them
11:46:00 <Cale> There's a good deal of computer science which discusses objects which have no physical model.
11:46:01 <mux> omg, they won't give up
11:46:09 * mux goes to do more productive things &
11:46:11 <cozachk> computers used to be people with adding machines
11:46:16 <sbpaul_> yes that would be "purely theoretical science"
11:46:32 <sbpaul_> potentially with real world applications
11:46:44 <sinelaw> mux check out my video, more fun
11:46:47 <sbpaul_> w/e
11:46:55 <Cale> If something doesn't fundamentally rely on the scientific method, then it's not really a science.
11:47:07 <sbpaul_> yes
11:47:22 <Cale> And I'd argue that computer science is sufficiently abstracted that it really doesn't rely on the scientific method at all.
11:47:39 <Kaidelong> Cale: other people like to call it engineering, too... it seems like people really don't like to agree on this
11:47:47 <sbpaul_> i think we're talking about a split
11:47:50 <Cale> Computer engineering is something else :)
11:47:51 * sinelaw has a library fine
11:47:51 <sbpaul_> that the semantics don't allow for
11:48:03 <EvanR> computer engineering isnt computer science
11:48:14 <ttt--> Which parts are too abstracted for the scientific method?
11:48:16 <hpc> computer engineering isn't even software engineering
11:48:17 <Kaidelong> some places think that computer science isn't anything at all
11:48:31 <Kaidelong> and use some other term instead
11:48:33 <roconnor> does cabal come with ghc?
11:48:42 <Kaidelong> roconnor: no
11:48:43 <sbpaul_> when did google buy picasa
11:48:46 <EvanR> at my uni computer science was mainly information technology ;)
11:48:46 <Kaidelong> get the haskell platform
11:48:47 <cozachk> roconnor, cabal comes with the haskell platform
11:49:01 <Cale> ttt--: They're sufficiently abstracted that we have nicer ways to define truth than going back to inductive empirical reasoning and the scientific method.
11:49:07 <Cale> In computer science, you can prove things.
11:49:08 <roconnor> I thought ghc came with something
11:49:14 <Cale> It's essentially a branch of mathematics.
11:49:28 <Kaidelong> I think personally I lean that way too
11:49:45 <sbpaul_> there is the part of "computer science" that deals with abstract mathematical phenomena and the part that deals with empirical phenomena
11:49:48 <sbpaul_> what do you call the latter
11:50:05 <sinelaw> Cale, btw i just read chaitin's theorem about the limit on proving that a theorem has complexity beyond the complexity of the axioms used in the proof
11:50:18 <tmske> Hi, I am following a haskell tutorial (complete newbie here) and was wondering how I should this: I have list of list and I want to find the list with maximum length
11:50:21 <sinelaw> mathematical phenomena?
11:50:24 <Cale> Do you mean the stuff about engineering physical systems which are approximations to the machines that computer science typically deals with?
11:50:35 <sbpaul_> yes
11:50:44 <Kaidelong> tmske: maximum . map length
11:50:46 <Cale> Perhaps computer engineering?
11:50:58 <sbpaul_> engineering is the implementation
11:51:00 <Kaidelong> :t maximum . map length
11:51:01 <lambdabot> forall a. [[a]] -> Int
11:51:03 <sbpaul_> at least as i learned it
11:51:06 <Kaidelong> oh eep
11:51:08 <Kaidelong> not what you want
11:51:27 <Kaidelong> :t maximumBy (compare `on` length)
11:51:28 <lambdabot> forall a. [[a]] -> [a]
11:51:29 <Cale> maximumBy (comparing length)
11:51:31 <Kaidelong> that is what you want
11:51:44 <Kaidelong> or that
11:51:47 <Cale> Or:  map snd . maximum . map (\
11:51:49 <Cale> oops
11:51:55 <Cale> Or:  map snd . maximum . map (\xs -> (length xs, xs))
11:52:13 <andrewsw> :t comparing
11:52:13 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
11:52:27 <Cale> That'll pair each list with its length, compute the maximum of the list of pairs, and then grab the list from the result
11:52:32 <Cale> er, oops
11:52:38 <Kaidelong> :t (compare `on`)
11:52:39 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
11:52:45 <Cale> Should be snd . maximum . map (\xs -> (length xs, xs))
11:52:53 <Cale> :t snd . maximum . map (\xs -> (length xs, xs))
11:52:54 <lambdabot> forall a. (Ord a) => [[a]] -> [a]
11:53:03 <Kaidelong> anyway Cale's version is the cleanest
11:53:19 <Kaidelong> maximumBy (comparing length)
11:53:24 <tmske> ok, I'll try it, what was wrong with maximum map length?
11:53:44 <Cale> tmske: You want the list with maximum length, and not just the maximum length, no?
11:53:45 <Kaidelong> > maximum . map length $ [[1],[1,1]]
11:53:46 <lambdabot>   2
11:53:56 <andrewsw> :t maximum . map length
11:53:56 <Kaidelong> > maximumBy (comparing length) $ [[1],[1,1]]
11:53:57 <lambdabot> forall a. [[a]] -> Int
11:53:57 <lambdabot>   [1,1]
11:54:24 <tmske> ah, so, I see the difference :)
11:54:32 <tmske> thanks for the quick help
11:54:36 <Cale> > map (\xs -> (length xs, xs)) . words $ "here are a bunch of words"
11:54:38 <lambdabot>   [(4,"here"),(3,"are"),(1,"a"),(5,"bunch"),(2,"of"),(5,"words")]
11:54:44 <Cale> > maximum . map (\xs -> (length xs, xs)) . words $ "here are a bunch of words"
11:54:45 <lambdabot>   (5,"words")
11:54:48 <donri> Why isn't there a cabal-installable package for haskell-platform?
11:54:50 <Cale> > snd . maximum . map (\xs -> (length xs, xs)) . words $ "here are a bunch of words"
11:54:50 <lambdabot>   "words"
11:55:00 <ddarius> > snd . maximumBy (comparing fst) . map ((,) =<< length) $ words "asoh aosnhu snaou oard owhu r"
11:55:01 <lambdabot>   "aosnhu"
11:55:15 <Cale> ^^ this is a really effective way to do it, since it avoids recomputing the lengths of the lists
11:55:57 <sinelaw> i wish there was a program to tell me which subexpressions are recomputed
11:55:58 <Cale> If you write  maximumBy (comparing length), it will compute the length of each list on each comparison
11:56:34 <Kaidelong> Cale: that seems amazingly bad. Shouldn't it use a strict fold and compute each length only once?
11:56:41 <Cale> Kaidelong: huh?
11:56:43 <roconnor> sinelaw: ghc almost never does CSE
11:56:50 <sbpaul_> hmm
11:56:52 <sinelaw> roconnor i know
11:56:57 <sbpaul_> http://www.msarnoff.org/sdb/
11:56:58 <sinelaw> but i don't know why
11:57:11 <Cale> Kaidelong: It has no choice, the comparison function you're giving to maximumBy just computes the lengths of each of the two lists it's given and compares them
11:57:15 <sbpaul_> are you guys excited
11:57:15 <Saizan> donri: see "Build from cabal" http://hackage.haskell.org/platform/linux.html
11:57:15 <roconnor> sinelaw: they worry about introducing space leaks
11:57:18 <sbpaul_> about the direction of the world
11:57:19 <ddarius> sinelaw: It's not always an optimization and it trades space for time which may or may not be what you want.
11:57:31 <Kaidelong> Cale: okay, so it's because maximumBy is fed comparing
11:57:35 <sbpaul_> open source is taking over
11:57:48 <Cale> comparing length xs ys = compare (length xs) (length ys)
11:57:53 <sinelaw> ddarius i wish they had a mode where you can turn on a warning for CSE's
11:58:03 <Saizan> sinelaw: do you have a reference to that chaitin theorem you mentioned above?
11:58:10 <sinelaw> so that with a smart editor you can hand-pick (via annotations) which ones you DO want eliminated
11:58:20 <sinelaw> Saizan sure sec
11:59:20 <Cale> Kaidelong: comparing isn't smart enough to build a memo table of lists that it has seen before, and even if it was, it would essentially have to do as much work as length did just to check that it indeed had that list
11:59:40 <sinelaw> Saizan http://www.cs.auckland.ac.nz/~chaitin/ibm.pdf, found on this page: http://www.cs.auckland.ac.nz/~chaitin/complete.html
11:59:56 <Saizan> sinelaw: thanks
12:00:03 <Kaidelong> Cale: ideally, graph reducation would be able to handle this case, right?
12:00:07 <sinelaw> the theorem is mentioned towards the end of the paper (it's not the main focus of the paper) and also somewhere in the middle (search for "later")
12:00:14 <sinelaw> Saizan ^^^
12:00:17 <Cale> Graph reduction is what I'm talking about here.
12:00:25 <Cale> GHC does graph reduction
12:00:38 <Kaidelong> wasn't that about memoizing the values of expressions and not re-computing them?
12:00:44 <tmske> Cale, Kaidelong: thanks a lot, I'll need a lot of learning :)
12:00:44 <Cale> Graph reduction doesn't mean "magically memoise everything"
12:00:47 <Kaidelong> if you can prove that you may need them again?
12:00:53 <Cale> Kaidelong: no
12:00:56 <Kaidelong> ok
12:01:15 <Cale> Kaidelong: It says that if a parameter to a function is duplicated in the function's body, share the result of evaluating that parameter between the copies.
12:01:42 <Cale> That's it. If you write  length xs ++ length xs, it will still compute the length twice.
12:01:52 <Cale> er
12:01:56 <Cale> That was supposed to be +
12:01:59 <Kaidelong> Cale: couldn't it then do that if maximumBy is done with a lazy fold? Generate a big expression with a bunch of duplications in the body?
12:02:08 <Kaidelong> although that'd have problems too
12:02:40 <Cale> No, because you're passing maximumBy an arbitrary comparison function
12:03:01 <Cale> Well...
12:03:07 <Kaidelong> so what happens? is the function abstracted away from the optomizer?
12:03:11 <wli> I don't think "magically memoize everything" is out there by any means.
12:03:30 <Cale> You might be able to avoid a few more length computations if we wrote comparing a little differently
12:03:43 <dons> haha. jdh downvoting every haskell submission. http://www.reddit.com/user/jdh30/disliked/
12:03:56 <Cale> comparing p x = let v = p x in \y -> compare v (p y)
12:03:56 <donri> Saizan: I saw that, I'm asking for a package. Why doesn't "cabal install haskell-platform" work?
12:04:32 <ddarius> donri: The Haskell platform includes things not on Hackage (and that will never be on Hackage)
12:04:42 <dons> ddarius: no, not quite.
12:04:53 <dons> its the binaries that the haskell-platform requires. cabal-install can't check for those yet
12:05:09 <sbpaul_> dons
12:05:10 <dons> we have a ticket that describes what cabal must do in order for haskell-platform to be cabal installable
12:05:11 <sbpaul_> are you from australia
12:05:21 <dons> yes
12:05:25 <Kaidelong> jdh seems like a troll, looking over his articles
12:05:30 <sbpaul_> that explains it then
12:05:34 <sbpaul_> http://sourceforge.net/projects/supertux-3d/
12:05:34 <dons> sbpaul_: ?
12:05:59 <Cale> That would mean that as soon as comparing gets the length function and the first list, it'd be able to compute the length once and for all for that first list, and return a function which compares with the resulting number
12:06:02 <sbpaul_> hehe...tux puts on a fireman hat when he gets the flame flower
12:06:15 <roconnor> are you sure cabal doesn't come with ghc?
12:06:34 <dons> ddarius: http://trac.haskell.org/haskell-platform/ticket/15
12:06:48 <ddarius> roconnor: The Cabal library necessarily does.
12:06:48 <dons> sbpaul_: what do you mean "are you from australia"
12:07:11 <Cale> Kaidelong: jdh is worse than your average troll when you consider his motivations.
12:07:32 <sbpaul_> well it's a pretty simple question
12:07:38 <donri> Also, I created https://bugs.launchpad.net/ubuntu/+bug/584682 so any Ubuntu user should go and set "affects me" and subscribe. ([needs-packaging] haskell-platform)
12:07:45 <Kaidelong>  Cale: what are his motivations?
12:07:46 <dons> sbpaul_: why did you ask?
12:08:00 <sbpaul_> where would the fun be in telling you that
12:08:34 <dons> you go in my bad book, in that case.
12:08:36 <Cale> Kaidelong: to sell these books and promote his consulting business http://www.ffconsultancy.com/
12:08:51 <Cale> Kaidelong: (for OCaml and F#)
12:08:54 <dons> don't like, Cale :)
12:08:57 <dons> don't link.
12:08:59 <sbpaul_> http://goblinhack.sourceforge.net/
12:09:00 <Kaidelong> Cale: I ran accross those books a while ago.
12:09:08 <Kaidelong> Never bought any though
12:09:10 <Cale> dons: hehe
12:09:11 <dons> sbpaul_: why are you spamming the channel with sourceforge links?
12:09:23 <sbpaul_> the links are sweet
12:09:30 <dons> they're off topic in #haskell
12:09:33 <roconnor> ddarius: oh right
12:09:45 <roconnor> damn it, I keep forgetting cabal isn't an application
12:09:47 <sbpaul_> you're just saying that because you're mad i won't tell you how i know you're australian
12:10:00 <dons> no, they're off topic.
12:10:01 <copumpkin> o.O
12:10:08 <danderson> I smell troll.
12:10:22 <sbpaul_> how many more times do i have to be called a troll before i die
12:10:24 --- mode: ChanServ set +o dons
12:10:27 <Cale> sbpaul_: http://www.zincland.com/powder/index.php?pagename=release -- as long as we're posting offtopic links to roguelikes
12:10:28 --- mode: dons set +b *!*sbpaul@*.twcny.res.rr.com
12:10:28 --- kick: sbpaul_ was kicked by dons (one.)
12:10:35 --- mode: ChanServ set -o dons
12:10:40 <danderson> dons++
12:16:55 <donri> BONUS: So, how soon does "coming soon" mean in LYAH? :)
12:17:34 <Raynes> donri: Sometime over the next 10 years.
12:17:44 <donri> Great!
12:18:09 <copumpkin> ooh, pointing out stackoverflow on haskell-cafe is good
12:18:23 <copumpkin> maybe it'll reduce the RJ rate
12:18:30 <dons> RJ?
12:19:03 <copumpkin> there's a guy called R J who's sent at least a dozen emails asking about bird problems
12:19:27 <uaca-uaca> I'm trying to write a function that gets files recursively
12:19:30 <copumpkin> people have suggested he try beginners
12:19:43 <uaca-uaca> this is what I've come up with: http://gist.github.com/411176
12:19:45 <Kaidelong> hmm, saw a question on whether or not "pure functional" algorithms may be asymptotically worse than an algorithm with destructive updates, first thing that I wondered was whether or not you can justify destructive updates as being enough to not call something pure functional, seems that would depend on the context
12:20:09 <uaca-uaca> can you please give some advice about the style?
12:20:10 <dons> oh.
12:20:42 <Cale> Kaidelong: Arbitrary destructive updates mean that it won't be pure.
12:20:47 <uaca-uaca> especially the (return.join :: [[a]] -> IO [a]) bit; can I replace that with something better?
12:21:08 <Kaidelong> Cale: but if the destructive updates cannot be used to communicate information through side effects?
12:21:21 <Kaidelong> except atomically while the function is running
12:21:28 <Cale> Kaidelong: Basically, the key property is referential transparency.
12:22:16 <Cale> Any function in the pure language should only consist of a means of associating to each set of parameters, some fixed, deterministic result.
12:22:24 <Kaidelong> Cale: in the end though, you only need to restrict, and not eliminate mutable state, right?
12:22:47 <dolio> There was a paper published some time ago about an algorithm that a strict, purely functional language performed asymptotically worse at.
12:22:54 <Cale> Kaidelong: Well, in the sense that lazy evaluation by graph reduction "restricts" mutable state
12:23:08 <dolio> However, a later paper showed that a lazy, purely functional language didn't have such a performance hit.
12:23:33 <Cale> Kaidelong: (there's implicit mutation of expressions into their resulting values)
12:23:47 <ddarius> Kaidelong: Practically speaking yes.  But results about asymptotics of "pure functional" algorithms are about completely purely functional implementations.
12:23:47 <Kaidelong> dolio: I haven't actually found an example of a strict, purely functional language
12:23:49 <Cale> But most people wouldn't ordinarily think of that as mutation at all
12:23:58 <Kaidelong> except some "stricter" versions of haskell
12:24:06 <Kaidelong> but I don't think those are really strict
12:24:21 <dolio> Kaidelong: I'm not aware of many, either. However, you can postulate one for the sake of argument.
12:24:43 <sepp2k> You can have destructive updates without sacrificing referential transparency though. Like "x = [1,2,3]; y = changeSecondElementTo 4 x" Now if the compiler know that x will never be used after the call to changeSecondElementTo, it can compile this to a destructive update while still keeping referential transparency, right?
12:25:09 <Cale> sepp2k: Well, yes.
12:25:22 <Kaidelong> sepp2k: that is what I was thinking yes, since the referential transparency is maintained, isn't that still functional?
12:25:36 <Kaidelong> can't you be both pure functional and also a little bit imperative?
12:25:36 <ddarius> Kaidelong: That code is expressed functionally.
12:25:38 <Cale> It's still pure
12:25:40 <Kaidelong> do you have to choose?
12:26:02 <Cale> Kaidelong: The question is about particular restricted languages where you *are* choosing.
12:26:10 <dolio> Yes, that's my query about the situation. If you have uniqueness types that allow the compiler to optimize things into destructive updates, can you match any destructive algorithm?
12:26:17 <dolio> And does that count as mutability?
12:26:23 <ddarius> dolio: I'm pretty sure you cannot.
12:26:24 <copumpkin> I haven't seen much from jdh on the trolling front on reddit recently
12:26:39 <Cale> dolio: Once you get an answer to your question, how about lazy evaluation alone?
12:27:06 <jbapple> copumpkin: He posted something about Haskell's hash tables not being fixed yet in a year old thread on GC, but it is no longer visible
12:27:17 <dolio> Cale: That's also a good question. I'm kind of skeptical that it's enough.
12:27:22 <jbapple> copumpkin: It may have been deleted by a moderator
12:27:34 <jbapple> copumpkin: That moderator may have been dons
12:27:37 <copumpkin> jbapple: maybe nobody cares about hashtables and it got downvoted?
12:27:41 <Cale> dolio: At least, it was enough to defeat Pippenger's argument.
12:27:57 <jbapple> copumpkin: No, it's not downvoted, it's gone
12:28:02 <copumpkin> ah
12:28:04 <copumpkin> I found it
12:28:18 <copumpkin> it's a year old, that's why
12:28:31 <jbapple> copumpkin: That's why what?
12:28:40 <copumpkin> it's why it's not visible
12:29:04 <jbapple> copumpkin: no. The post I'm talking about is from 23 hours ago
12:29:16 <jbapple> copumpkin: It is visible on http://www.reddit.com/user/jdh30
12:29:28 <copumpkin> yeah, that's what I'm talking about too
12:29:32 <dolio> Cale: For instance, is there any lazy data structure than can be used to perfectly shuffle a multiset of n items in O(n) time? I'm only aware of O(n log n) solutions.
12:29:39 <copumpkin> he probably just commented on it and realized nobody would ever see it since the thread was so old
12:29:46 <jbapple> He said: Nice to see the Haskell community laughed and moved on without actually fixing anything, again. Hash table performance with GHC 6.12 is still dire and the bug in the GC they did fix has made program using mutable arrays 2 slower.
12:30:07 <jbapple> copumpkin: So he deleted it himself? I suppose that's possible
12:30:17 <jbapple> But he said in the post that it was a year later
12:30:25 <jbapple> so it's not like it came as a surprise
12:30:35 <copumpkin> jbapple: a moderator would have to go out of his way to notice someone posting on an old thread and delete his comment
12:30:52 <jbapple> copumpkin: Or someone could RSS follow jdh30
12:31:02 <copumpkin> jbapple: so you think it's maliciousness?
12:31:15 <copumpkin> seems pretty unlikely to me
12:31:31 * Kaidelong wrote an O(n) functional shuffling algorithm a while ago, but not in haskell
12:31:33 <jbapple> copumpkin: Did you see the older famous mysteriously deleted jdh30 post on programming.reddit? I will find you a link
12:31:47 <jbapple> copumpkin: If it's not mod deleted, it's a false-flag operation
12:31:49 <ddarius> dolio: Well, I think technically you can cast any imperative algorithm into a uniqueness types using program that is able to update in-place.  Though I don't think you can do it without seriously damaging the structure of the original algorithm.
12:31:49 <Kaidelong> oh wait
12:31:52 <Kaidelong> it wasn't functional
12:31:57 <Kaidelong> I used a mutable array nm
12:32:03 <copumpkin> jbapple: he deletes a lot of his stuff... I had an entire conversation once and he deleted it afterwards
12:32:12 <copumpkin> jbapple: this was pre-dons being a moderator, for what it's worth
12:32:19 <ddarius> dolio: You can always compile the algorithm to assembly and interpret that assembly with a big array for memory.
12:32:28 <dolio> ddarius: Yes, it probably wouldn't end up appreciably different than, say, ST.
12:33:10 <copumpkin> jbapple: anyway, don't look too hard, I don't care that much :P
12:33:12 <Kaidelong> wasn't pure either
12:33:19 * copumpkin is pure
12:33:32 <Kaidelong> but then again, you sort of expect that from shuffling
12:33:43 <Kaidelong> calling it with the same input might lead to different output
12:34:10 <dolio> Kaidelong: Well, you can have pure interfaces for pseudorandom number generators.
12:34:21 <dolio> rand :: Gen -> (Int, Gen) and whatnot.
12:34:21 <jbapple> dolio: Finger trees might be able to do it. They can be suprisingly asymptotically fast because of the fast access near the ends
12:34:25 <Kaidelong> dolio: which is what haskell does, but I wasn't using it then
12:34:33 <ddarius> dolio: ST allows arbitrary sharing and effects visible from independent parts of the ST computation.  The key to imperative algorithms is aliasing.  Uniqueness types don't allow aliasing, but you could encode it in the manner I described.
12:35:09 <jbapple> dolio: For instance, splitting a fingertree down to individual elements is O(n), even though the first split can be \Omega(lg n)
12:35:32 <dolio> Ah, hmm.
12:36:07 <jbapple> copumpkin: http://www.reddit.com/r/programming/comments/bnnoh/fast_automatically_parallel_arrays_for_haskell/c0not4b
12:38:11 <jbapple> here is a kernel of an idea for an O(n) PF shuffle: for each swap, just cons a new element on a list with the element shuffled and its new index. Now radix sort the list by index.
12:39:08 <Kaidelong> jbapple: so a variation of the O(n log n) version with a linear sort?
12:39:34 <Kaidelong> the knuth shuffle would still be a bit more efficient, but not asymptotically
12:39:40 <Kaidelong> was it called the knuth shuffle?
12:39:42 <Kaidelong> I have forgotten
12:39:56 <jbapple> Kaidelong: I suppose. If my only constraint were O(n lg n), I would do the swapping immediately, rather than queueing it up for a later sort
12:41:25 <c_wraith> hmm.  Snap does appear to support sendfile.  that's neat.
12:42:35 <jbapple> I also saw that post about asymptotic differences b/w purely functional and imperative algorithms. My first thought was minimum spanning tree
12:43:11 <Cale> jbapple: How do you ensure that you don't reuse indices?
12:43:33 <jbapple> I this all of the MST algorithms since the invention of the Fibonacci tree use decreaseKey, which is naturally imperative
12:43:38 <jbapple> Cale: good question
12:44:05 <c_wraith> didn't okasaki address PQ structures?
12:44:36 <Cale> I'm pretty sure that anything which does this in O(n) is going to use laziness in some very subtle way
12:45:06 <jbapple> c_wraith: yes
12:45:41 <jbapple> c_wraith: In the FingerTree paper, Hinze & Paterson implement decreaseKey as find + delete + insert, which is \Omega(lg n)
12:46:07 <jbapple> But fibonacci heaps (and pairing heaps, and soft heaps) have o(lg n) decreaseKey
12:47:48 <Cale> Oh funny, there's actually no way to perfectly shuffle a list using a bounded number of coin flips.
12:48:06 <jbapple> Cale: What about the strikeout method using fingertrees? I haven't done the recurrence relation yet, but it might be O(n)
12:48:37 <c_wraith> Cale: bounded by what?
12:49:08 <Cale> c_wraith: You can't bound the number of coin flips you'll need by any function of the input size.
12:49:35 <Cale> c_wraith: It follows from the fact that n! doesn't divide any power of 2 for n >= 3.
12:50:10 <c_wraith> Hmm.  The obvious O(n) mutable array solution is only probabilistically O(n).
12:50:29 <jbapple> Cale: nope, fingertrees don't fix it automatically
12:51:01 <Cale> But we can ignore that, and assume we have a source of uniform random numbers for each range
12:51:26 <Null-A> are IORef's faster than State monads?
12:51:37 <Silvah> It depends.
12:51:49 <Cale> Null-A: profile
12:51:52 <Silvah> They can be slower.
12:51:59 <Null-A> it would seem like IORef's are just a more limited version of State monads
12:52:01 <Silvah> They can be faster too.
12:52:04 <Null-A> why use them ?
12:52:15 <Cale> Null-A: IORefs are real mutable references
12:52:17 <glguy_> IORefs can communicate across threads
12:52:28 <Null-A> oh ok
12:52:37 <Cale> They can communicate across threads, and you can have an arbitrary number of them
12:52:47 <Cale> at arbitrary types
12:52:48 <Silvah> IORefs are mutable variables in IO monad, State monad is just a trick and does not update anything in place.
12:53:17 <Null-A> *nods* it would seem faster then
12:53:27 <Null-A> at least for large data structures
12:53:37 <Cale> The State monad is just a wrapper around the common functional idiom of writing functions which take an extra parameter and produce an extra component of their result to maintain some "state"
12:53:56 <Null-A> *nods*
12:54:05 <Cale> The optimiser can work more aggressively on pure computations than it can on ones with mutation in them.
12:54:24 <Cale> So, no guarantees about what's better.
12:54:27 <Null-A> i see
12:55:46 <Silvah> Are there any libriaries with *strict* list or I have to roll my own?
12:55:54 <Cale> But mostly the choice between those two doesn't come up so much. You use IORefs for really quite different purposes than you'd use the State monad for.
12:56:43 <Cale> Silvah: I don't know of anything too fancy. You're probably not much worse off rolling your own.
12:56:56 <Cale> Silvah: What do you need strict lists for?
12:57:33 <Cale> Normal lazy lists are sufficiently convenient that people usually just write strict algorithms on them when appropriate.
12:57:57 <Silvah> I dunno yet, actually. I just wonder whether there are such things.
12:57:58 <Null-A> i don't know why people align blocks with the equals in a function defition. That means every block looks aligned differently
12:58:31 <Cale> Null-A: The important thing is that the lines inside the block line up, not how much it's indented by
12:58:45 <Cale> I usually indent things like:
12:58:46 <Null-A> right, I always just ident by 4
12:58:48 <Null-A> indent*
12:59:06 <Cale> foo = do bar
12:59:09 <Cale>          baz
12:59:11 <Cale>          quux
12:59:25 <Null-A> is that 4 space alignment or = alignment?
12:59:53 <Cale> I align the following lines of the do-block up with the column on which the first statement inside it started.
13:00:19 <Cale> I don't count the number of spaces
13:00:22 <Null-A> yah personally I don't like that
13:00:26 <Cale> It's just whatever it takes to get it to line up
13:00:28 <Null-A> if you rename the function, you have to update it all
13:00:47 <dons> Silvah: the adaptive package
13:00:52 <Cale> If there are lots of parameters, or the parameters might change, I'll put a newline before 'do'
13:00:53 <dons> has self-optimizing strict lists
13:00:58 <Cale> foo x y z =
13:01:02 <dons> but if you want element-wise strictness, spine laziness, that's a good choice
13:01:03 <Cale>   do bar x
13:01:07 <dons> if you want spine strictness, use a vector
13:01:07 <Cale>      baz
13:01:13 <Cale>      quux y z
13:01:16 <hpc> i usually put the newline after the do
13:01:24 <Null-A> same
13:01:26 <hpc> foo = do
13:01:29 <hpc>     bar
13:01:30 <hpc>     baz
13:01:33 <hpc>     qux
13:02:04 <Cale> I don't like the way that looks somehow -- starting an expression on one column and continuing it on an earlier column looks weird to me
13:02:14 <Silvah> dons: thank you :)
13:03:03 <Cale> (even though the syntax technically allows it)
13:03:59 <mauke> Cale: how do you format case expressions?
13:04:01 <Cale> I adhere to the rule that siblings in the structure will line up vertically, and start in a column which is deeper than their parents.
13:04:33 <Cale> mauke: Yeah, I always think that I ought to switch to using:
13:04:35 <Cale> case foo
13:04:40 <Cale>   of Nothing -> ...
13:04:46 <Cale>      Just x -> ...
13:04:47 <mauke> ugly
13:04:47 <hpc> Cale: i like it because it reads like C-likes or python, and for complex uses it keeps the margin from spiralling out of control
13:05:08 <mauke> the first statement is not special
13:05:19 <mauke> why should I put words before it?
13:05:21 <Cale> mauke: And I'm not treating it specially
13:05:31 <mauke> you are, by marking it with 'do' or 'of'
13:05:35 <Cale> It starts in the same column as all the others
13:05:43 <mauke> that's not how text editors work
13:05:49 <Cale> The 'do' or 'of' is its parent
13:06:15 <Cale> Yeah, but I'm not *really* editing text. It's a fluke that I'm using a text editor at all.
13:06:23 <Cale> I'm editing a tree :)
13:07:13 <Cale> and I want what I see to be indicative of the structure of that tree
13:07:34 <hpc> now you have me imagining what a tree-based editor would look like
13:07:48 <Botje> green >:)
13:07:54 <mauke> my tree parser works differently
13:09:41 <Null-A> every hour I use haskell, I seem to increasingly like it
13:09:54 <Null-A> the super-beginner period was hell though
13:10:31 <hiptobecubic> Null-A, yes.
13:11:06 <EvanR> hell... of a good time!!!?!1
13:12:02 <Null-A> when I couldn't write `main = do quicksort([1,9,5])` my face turned red
13:12:10 <hiptobecubic> EvanR, no.
13:12:36 <hiptobecubic> Null-A, what resources did you use to learn with?
13:12:40 <Null-A> you read about liftIO and you're like wtf
13:13:00 <Null-A> hiptobecubic: uh I've been all over the place, i'm kind of stubborn, and can't force myself to read books front to back
13:13:15 <Null-A> so first I just skimmed the first few chapters of real world haskell as fast as possible so I understood the syntax
13:13:21 <Null-A> then I said "i'm going to write a compiler"
13:13:43 <hiptobecubic> Pretty ambitious first project
13:13:47 <Null-A> then i said f*** this sucks. decided to abandon it. came back a week later
13:13:54 <Null-A> played with parsec, and said "wow"
13:14:00 <Null-A> so on and so on
13:14:20 <Null-A> hiptobecubic: the only thing that would really interest me
13:14:32 <copumpkin> a compiler for what?
13:14:34 <hpc> i still need to learn parsec
13:14:37 <Null-A> hiptobecubic: i abandoned my original compiler project when I found out cyclic graphs were hard to make
13:14:48 <Null-A> right now i'm plowing my way through writing a scheme interpreter in 24 horus
13:14:50 <Null-A> hours*
13:14:55 <Null-A> almost done
13:14:58 <hpc> that one is fun
13:15:05 <Null-A> yah my favorite book so far
13:15:07 <Null-A> very rewarding
13:15:13 <Null-A> 48 hours*
13:15:15 <Cale> Null-A: It can be a bit like learning your first programming language, only since it's not, more humbling still.
13:15:26 <Null-A> *nods*
13:15:36 <triyo> love this quote from Typeclassopedia "The more monad tutorials there are, the harder people think monads must be, and the more new monad tutorials are written by people who think they finally getmonads"
13:15:44 <Null-A> copumpkin: distributed systems language compiler (even more ambitious)
13:15:51 <copumpkin> wow :P
13:17:19 <kuribas> I liked the explanation from Realworld Haskell.
13:17:54 <Null-A> yah I've skimmed over many parts of RWH
13:18:02 <Null-A> for parsec I found the documentation better
13:18:54 <kuribas> Null-A: I have read it completely, and I already knew a lot what was written.
13:18:59 <roconnor> @type zipWith4
13:19:00 <lambdabot> forall a b c d e. (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
13:19:04 <kuribas> But I was happy for the new parts :)
13:19:26 <Null-A> =) certainly monumental aid, and thank you to the authors
13:19:44 <Null-A> i can't imagine what the scene was here back in 98
13:19:52 <Null-A> probably would've gave up
13:20:25 <EvanR> haskell failed to avoid success
13:20:34 <Null-A> shux
13:21:03 <Null-A> trust me, your popularity could me much worse
13:21:06 <Cale> Well, I don't know about that far back, but even in 2001 or so when I started, there were fewer tutorials and resources, and the community was a lot smaller, but still just as friendly.
13:21:13 <ddarius> copumpkin: How many people are in #agda?
13:21:18 <Null-A> yah its very friendly
13:21:22 <Cale> We used to have a wiki that people actually used as a wiki :/
13:21:24 <copumpkin> ddarius: 28
13:21:24 <Null-A> I always thought it would be more snobbish
13:21:38 <Cale> The change over to mediawiki sort of killed that to a large extent
13:21:51 <ddarius> Yeah, I preferred the old wiki.
13:22:40 <Cale> I think mediawiki makes people think of Wikipedia, and discourages conversational tone.
13:23:07 <copumpkin> why did we switch?
13:26:33 <Null-A> i'm following 'scheme in 48hours', they use a lists and 'lookup' and IORef to manage a mutable hash table, is there another package for this? I had to write sophisticated table[key] = X mutation functions, seems pretty boiler plate
13:28:07 <Null-A> looks like I can shove a Data.Map inside an IORef
13:28:34 <ddarius> You can put anything into an IORef.
13:28:42 <Null-A> *nods*
13:29:55 * bremner wonders if 3rd CS students knowing no functional programming could do 'scheme in 48hours'
13:30:03 <whh> Hey Null-A - I've been following schemein 48 hrs too (last night and this morning)
13:30:03 <timmaxw2> my program is making GHCi segfault
13:30:07 <timmaxw2> any advice?
13:30:14 <Null-A> whh: cool, its pretty fun
13:30:21 <Null-A> i started yesterday too
13:30:24 <Kaidelong> bremmer: scheme was my 2nd functional language
13:30:34 <pikhq> bremner: Depends on the CS student in question.
13:30:44 <Kaidelong> first one was SML/NJ, looked cool at first, but I hated it after a while
13:30:46 <whh> I'm not following it exactly - making my own language up as I go
13:30:59 <bremner> pikhq: well, say 80% of students
13:31:01 <pikhq> Some such CS students could do Scheme in 48 hours without having much more than a spec of Scheme.
13:31:03 <Kaidelong> Scheme turned out to have the same problems, but a nicer syntax for beginners
13:31:16 <mjonsson> Kaidelong: what turned you off SML?
13:31:16 <Kaidelong> at least I loved the syntax
13:31:16 <pikhq> Others couldn't even *use* Scheme without tons of handholding.
13:31:26 <Kaidelong> mjonsson: the special cases, mostly
13:31:34 <triyo> bremner: 'scheme in 48hours', easy. Writing an interpreter in Haskell in 48 hours? Highly unlikely :)
13:31:44 <whh> I think whether you can deal with scheme or not depends on whether you have an editor that balances parens and auto-indents
13:31:47 <Kaidelong> I am now vaguely aware that a lot of that has to do with allowing short-circuiting in a strict language
13:31:53 <bremner> sure.  I'm thinking about  a course for programming languages
13:32:43 <Kaidelong> haskell would probably have been a better choice for first exposure than SML/NJ for me, despite the learning curve. I was also somewhat offended by an inconsistency in scheme where functions because "procedures" and you couldn't get the cdr of them
13:33:01 <Kaidelong> became*
13:33:04 <whh> I just wanted to ask if anyone could help me answer a question with deriving Show
13:33:29 <Kaidelong> I get turned off by exceptions and inconsistencies
13:33:42 <whh> I have something like data Expr = ... | Fun String (Expr -> Expr)... but this causes me to not be allowed to do deriving Show
13:33:45 <pikhq> whh: Don't ask to ask to ask; just ask.
13:33:57 <timmaxw2> whh: there's no way to show (Expr -> Expr), so you can't derive Show for that
13:34:02 <whh> because I "just asked" earlier :-)
13:34:19 <pikhq> whh: Yes. You can only derive Show if all the things in your type are instances of Show.
13:34:31 <timmaxw2> whh: the compiler will build the derived Show instance out of the Show instances for the types of the fields, but there is no show instance for (->), so it doesn't work
13:34:42 <whh> the compiler mumbled something about Stand-alone deriving declarations
13:35:01 <timmaxw2> what does your deriving declaration look like?
13:35:05 <whh> I tried it, but couldn' t get it to work
13:35:13 <timmaxw2> and what exactly is the error message?
13:35:22 <whh> let me try to get it back...
13:36:33 <whh> No instance for (Show (Expr -> IOThrowsError Expr))
13:36:43 <whh> ... or use a standalone 'deriving instance' declaration instead,
13:37:19 <timmaxw2> i don't know why it's talking about standalone deriving declarations, but the main issue is that it can't show the function
13:38:27 <timmaxw2> if you import Text.Show.Functions, then you can get a dummy instance of Show for functions, which might be useful for debugging
13:38:28 <whh> yeah... what I really want to do is just show a string, but it seems that I have to write the Show inst by hand just to override this one thing
13:39:07 <whh> I tried this...{-# language StandaloneDeriving, FlexibleInstances, FlexibleContexts, UndecidableInstances #-}
13:39:07 <whh> data E = I Integer
13:39:08 <whh>        | F (E -> E)
13:39:08 <whh> --         deriving (Show)
13:39:08 <whh> deriving instance Show (E -> E) => Show E
13:39:21 <whh> but that fails
13:39:48 <timmaxw2> whh: the issue here is that there is no way to show a function. What do you want to be printed in place of the function object? What is the textual representation of your function?
13:40:23 <whh> yeah, my real fun ctr is Fun String (Expr -> ...) and I just want to show the string
13:40:28 <timmaxw2> whh: if you don't care what the function is and just want to see the rest of the structure, then you can import Text.Show.Function, and then it will show "<function>" in place of the function
13:40:34 <timmaxw2> whh: so that solution will work for you
13:40:45 <whh> great - thanks
13:41:40 <whh> btw, I'm surprised that with the little test function I gave above that it compiles, but fails at runtime
13:41:51 <whh> F (\i->i)
13:41:57 <whh> No instance for (Show (E -> E))
13:42:32 <whh> but then again, UndecidableInstances sounds suspicious
13:44:13 <kuribas> I was going to use Text.XHtml for my cgi script, but it seems that it is only useful for _writing_ html, not for processing it (like parsing html and validating it).  Is that right?
13:44:41 <timmaxw2> can anybody help me? I'm running GHCi 6.10.4. My program causes GHCi to segfault (null pointer access) when I run it interactively. I'm not doing anything weird with IO, foreign functions, or extensions, just pure Haskell. has anybody seen this problem before? do you know what might be causing it? any suggestions, other than filing a bug report?
13:44:47 <Null-A> do I have to cleanup after calling newIORef?
13:44:53 <copumpkin> Null-A: no
13:44:56 <Null-A> thx
13:45:13 <walrus_> whh: if you need to now what are the functions, you can try a solution like this: http://pastebin.com/W5r2WNRL
13:45:42 <mauke> timmaxw2: how big is your program?
13:46:02 <timmaxw2> a bit under 2000 lines of code
13:46:12 <timmaxw2> or did you want memory usage?
13:46:18 <whh> walrus_: yeah... but I was trying to use deriving Show to avoid rewriting 99% of the show funs
13:46:19 <mauke> no, code size
13:46:30 <Kaidelong> does haskell employ early or late binding for its methods?
13:46:36 <mauke> timmaxw2: I haven't seen this before; can you reduce it to a smaller testcase?
13:46:48 <roconnor> so I build something with ./Setup.hs build
13:46:56 <roconnor> now how do I include it when working in ghci?
13:47:06 <roconnor> I don't want to install it
13:47:07 <timmaxw2> mauke: i will try...
13:47:21 <Kaidelong> guessing early binding, otherwise it'd need some kind of type information at run time
13:47:34 <timmaxw2> mauke: but i don't know where to start, so i doubt i will be able to. i'll file a bug report (with smaller test case if possible) later.
13:50:05 <Kaidelong> if I'm reading GITH right, there is a kind of late binding where methods are implicitly passed to functions?
13:50:42 <ddarius> The terminology of early/late binding doesn't apply to Haskell classes.
13:51:30 <Kaidelong> huh
13:52:03 <Kaidelong> so how does a function know which methods to use?
13:52:05 <bremner> Kaidelong: what do you mean by methods?
13:52:30 <Kaidelong> bremner: functions that work on class instances and can be overloaded for different instances of the same class
13:53:22 <Kaidelong> does the compiler generate a bunch of more specific versions of a function from a polymorphic one?
13:53:31 <Kaidelong> wouldn't that be a kind of early binding?
13:54:11 <siracusa> timmaxw2: If you compile with GHC the problem doesn't occur?
13:57:33 <timmaxw2> siracusa: i will try that
13:58:15 <timmaxw2> siracusa: it works if i compile with ghc --make
13:58:21 <copumpkin> factor your folds! omg: http://www.cs.nott.ac.uk/~gmh/f5.pdf
13:58:23 <timmaxw2> siracusa: but fails in GHCi
13:59:14 <timmaxw2> siracusa: but, if I run in GHCI with the compiled .O files present (so it loads the compiled modules instead of interpreting them), then it does segfault
14:04:28 <vmixey> "As you may be aware, iteratee-based I/O is trendy right now"
14:04:33 <vmixey> ummm no I wasn't aware of that
14:04:51 <copumpkin> it is, though
14:05:16 <dons> vmixey: its trendy
14:05:45 <dons> Required by haskell-attoparsec-iteratee haskell-iteratee-parsec haskell-snap-core haskell-snap-server haskell-usb
14:05:52 <dons> and more
14:07:39 * hackagebot hackport 0.2.6 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.6 (LennartKolmodin)
14:21:58 <kuribas> Is there a good library to parse and generate html tags?
14:23:36 <k23z__> kuribas, I saw some on hackage
14:24:28 <kuribas> hm, let's see...
14:24:28 <k23z__> kuribas, http://www.haskell.org/haskellwiki/Applications_and_libraries/Web_programming#HTML
14:24:57 <k23z__> kuribas, the tagsoup would seem pretty good http://community.haskell.org/~ndm/tagsoup/
14:26:26 <kuribas> Thanks, looks interesting.
14:29:17 <timmaxw2> > 3.0 - 5.0
14:29:18 <lambdabot>   -2.0
14:29:43 <timmaxw2> this is ridiculous: if i type "3.0 - 5.0" into ghci, i get "Prelude> 3.0 - 5.0
14:29:43 <timmaxw2> -Segmentation fault"
14:30:03 <timmaxw2> WTF
14:30:16 <arw> timmaxw2: broken ghci binary or broken computer
14:30:21 <roconnor> @type unfoldr
14:30:23 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:30:24 <arw> timmaxw2: overheating or memory problems?
14:30:40 <timmaxw2> arw: no other symptoms
14:31:05 <arw> timmaxw2: then try to reinstall ghc/ghci, perhaps into another directory or something.
14:32:05 <timmaxw2> arw: shit, it takes hours to build GHC
14:32:18 <arw> oh, you compiled it yourself?
14:32:44 <timmaxw2> arw: no, i installed the MacPorts version
14:32:44 <arw> maybe you used a wrong architecture or something?
14:32:51 <arw> hm.
14:33:27 <timmaxw2> problem occurs whenever i ask it to show a negative Float or Double, and it only occurs in interactive mode... gahh
14:33:30 <arw> sometimes segfaults come from choosing the wrong processor type, like when you compile for a processor with sse and run on a processor without.
14:34:09 <timmaxw2> arw: i guess i'll go look for a MacPorts mailing list. also, it seems funny that it would only occur in interactive mode.
14:34:31 <timmaxw2> arw: maybe GHC optimizations remove the construct that causes the problem
14:34:38 <arw> timmaxw2: if the box works fine otherwise. but considering the very limited symptoms i would really suspect a broken ghci binary.
14:35:01 <timmaxw2> arw: thanks for your suggestions, i'll see if i can find an answer
14:35:19 <arw> timmaxw2: good luck :)
14:37:38 <timmaxw2> is anyone else on the channel running GHC on a Mac with MacPorts?
14:38:02 <vmixey> no but I would advise against macports because it sucks
14:38:20 <timmaxw2> vmixey: is fink better?
14:38:30 <vmixey> not to my knowledge
14:39:07 <arw> timmaxw2: http://hackage.haskell.org/platform/mac.html
14:39:23 <arw> timmaxw2: you could try the installer, just to see if it makes a difference
14:40:48 <timmaxw2> arw: thanks, i'm trying that now
14:41:38 <glguy> timmaxw2: at this point GHC+macport is broken
14:42:11 <timmaxw2> shit... wonder if it's possible to install linux on mac hardware...
14:42:27 <glguy> timmaxw2: you just install using the haskell.org/ghc provided installer
14:42:33 <glguy> which goes into /usr/bin
14:42:43 <glguy> and you'll have a working 6.12.2 install
14:42:45 <vmixey> timmaxw2, I spent forever trying and failed.. right now I'm using ubuntu on a VM though, which works pretty well
14:42:58 <vmixey> timmaxw2, really damn frustrating with all the install failures :/
14:43:11 <vmixey> 9.10 worked though.. just not the new 10.04 thing
14:43:12 <timmaxw2> glguy: hopefully that will work. i seem to recall having problems with the haskell platform on mac before,but maybe it will work this time.
14:44:37 <glguy> timmaxw2: it works fine as long as you don't try to link against libraries you installed with macports
14:46:23 <roconnor> jlouis: Data.PSQueue.findMin is taking it's sweet time
14:46:35 <roconnor> ah there it goes
14:48:01 <roconnor> damn
14:48:04 <roconnor> 33 seconds :(
14:48:11 <roconnor> stupid O(1)
14:48:36 <glguy> is it constantly slow?
14:48:49 <opqdonut> constantly non-halting
14:49:49 <roconnor> glguy: perhaps not
14:49:57 <roconnor> perhaps it takes 33 to build the priority queue
14:50:24 <glguy> If something is O(1) is it necessarily (1)?
14:50:33 <opqdonut> what sign was that?
14:50:36 <hpc> omega
14:50:43 <glguy> theta
14:50:51 <hpc> ah
14:50:53 <opqdonut> of course not, it might be o(1)
14:51:07 <roconnor> isn't every algorithm (1)
14:51:23 <opqdonut> sure, if you count turing machine steps
14:51:31 <opqdonut> or some other discrete quantity
14:53:00 <roconnor> ah
14:53:11 <roconnor> 5 seconds instead of 33 seconds if I use fromAscList
14:53:30 <opqdonut> unsafePleaseBuildItFasterICanPayYou
14:54:04 <glguy> how can every algorithm be considered (1)?
14:54:25 <glguy> Or did you mean Omega?
14:55:59 <Igloo> If you run it on a finite machine, it's either O(1) or doesn't terminate
14:56:48 <vmixey> once again math is completely useless and wrong
14:57:09 <opqdonut> I just did a course on deterministic distributed algorithms
14:57:18 <ddarius> vmixey: Be a finitist.
14:57:22 <opqdonut> we derived lots of concrete upper bounds for the number of communication rounds used
14:57:28 <Cale> Well, asymptotic analysis is pretty silly in a finite setting.
14:57:37 <opqdonut> it was pretty illuminating
14:58:49 <roconnor> :( this is still too slow
14:59:30 <Null-A> Am I stupid for trying this:   http://codepad.org/uxHTc9TR#comment-LWEeCnBm  Why can't this work
15:00:52 <ddarius> Null-A: It doesn't know what type you want to use for e.
15:00:59 <glguy> Null-A: use:  Left (SomeExceptione e)
15:01:12 <Null-A> I can't match on all types which conform to a class?
15:01:22 <Null-A> i want to call the show function after all
15:01:48 <glguy> Null-A: no, literally match on:  Left (SomeException e)
15:01:54 <Null-A> i follow
15:02:04 <glguy> I'm not using "SomeException" as a placeholder
15:02:22 <Saizan> SomeException is supposed to be at the top of the hierarchy of exceptions, anyway
15:02:27 <Null-A> I'm just talking about the logically correct concept of matching on a class
15:02:43 <Cale> Null-A: The problem isn't directly with your print function
15:03:24 <Cale> Null-A: It's with the fact that the preceding 'try' doesn't know what type of exceptions it's looking for
15:03:28 <timmaxw2> vmixey, glguy: problem fixed. thanks for all your help.
15:03:58 <Null-A> Cale: ah i see
15:04:01 <glguy> Null-A: the problem is that "try" works on all instances of Exception
15:04:04 <Cale> Null-A: If you specialise the type of print a bit, you can force it to look for any type of exception at all (that's what SomeException does)
15:04:23 <glguy> and your print function works on all Show instances, and it doesn't know what specific instance to pick
15:05:14 <Null-A> specific instance(s) right?
15:05:42 <Null-A> glguy:
15:05:54 <Cale> Null-A: The problem is similar to what happens when you write   show . read
15:06:24 <Null-A> *nods*
15:06:39 <Null-A> I think I follow
15:06:52 <Null-A> i'll spend more time going over type classes in depth later
15:06:52 <Cale> read is polymorphic in its result type, and show is polymorphic in its parameter, so you end up with an ambiguity concerning which parser to use
15:07:19 <Cale> (one that can't be resolved later because that type doesn't appear in the overall type of the expression)
15:07:35 <roconnor> I have a simily in my haskell code
15:07:42 <roconnor> solve b = unlines . (show (length solution') :) . map (\(a,b) -> show a++" "++show b) $ solution'
15:07:45 <jlouis> roconnor: oh, it might be laziness, might it not?
15:07:57 <Null-A> I see, hence SomeException
15:07:59 <Cale> Same thing is happening here: evalAndPrint's type doesn't contain a type variable for the type of exceptions to use.
15:08:07 <roconnor> jlouis: I think fromList is just stupidly slow
15:08:18 <roconnor> jlouis: fromAscList is faster
15:08:23 <Cale> and so whatever type it is, we'd better choose it here somehow
15:08:37 <jlouis> roconnor: fromList probably just adds elements one at a time
15:08:43 <roconnor> sure
15:08:47 <roconnor> it should be n log n
15:09:00 <ddarius> The real question is is fromAscList . sort faster than fromList.
15:09:09 <roconnor> I guess log n = 6
15:09:19 <roconnor> ddarius: :O
15:09:27 <jlouis> I rarely store more than 10k elements in my psqueue
15:09:34 <roconnor> ddarius: how fast is sort on a sorted list?
15:09:41 <roconnor> jlouis: I have
15:09:45 <roconnor> > 512^2
15:09:46 <lambdabot>   262144
15:09:49 <roconnor> that many
15:09:57 <jlouis> that is a bit more
15:09:57 <ddarius> roconnor: It should be O(n) for a decent sort.
15:10:15 <roconnor> ddarius: then, I'd expect it to be faster in my case
15:12:08 * roconnor tries PSQ.fromDistinctAscList
15:13:11 <roconnor> not really any faster
15:13:13 <dolio> Do you actually need a priority search queue?
15:13:18 <dolio> Or just a priority queue?
15:13:50 <roconnor> dolio: I need to get the minimum element, and then update random values
15:14:34 <Null-A> Cale: So basically, polymorphic functions (e.g. any function with a variadic type) are universally qualified across all types (which conform to the type classes specified). But when you're calling polymorphic functions they're variadic  types need to be constrained to a particular instance determined at the call site.
15:14:47 <Null-A> Cale: trying to capture the lingo
15:14:59 <Null-A> their*
15:15:33 <ddarius> "variadic type" is not in Haskell vocabulary
15:15:35 <Null-A> I guess the correct term is 'type variable'
15:15:39 <Null-A> ?
15:15:48 <ddarius> Also, "universally quantified" not "qualified"
15:15:55 <Null-A> thanks
15:16:02 <opqdonut> hmm, universally qualified
15:25:04 <augur> does anyone know of any solutions to the problem of unifying sets?
15:25:22 <clanehin> is wondering if there are any impls of composable transactions other than the STM impl that ships with GHC.
15:36:37 <clanehin> Was also asking at 3 this morning (yeah).  I can't see that Control.Arrow.Transformer.Static exports any way to wrap or unwrap a StaticArrow based on an applicative functor that is not itself a monad or arrow.
15:41:08 * hackagebot meldable-heap 2.0.3 - Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues  http://hackage.haskell.org/package/meldable-heap-2.0.3 (JimApple)
15:44:52 <Cale> http://www.voidref.com/pub/images/early_programming.jpeg
15:49:48 <roconnor> jlouis: I swiched from adjustWithKey to updateWithKey and now I'm running out of memory when running?
15:49:54 <roconnor> should I expect this?
15:50:11 <roconnor> jlouis: I was trying to make my priority queue smaller by actually deleting elements from it
15:50:55 <jlouis> roconnor: I only use minView on mine and updateWithKey. I can't remember if I enforced strictness on it
15:51:12 <roconnor> oh
15:51:17 <roconnor> strictness...
15:51:41 <jlouis> I might have, it is threaded through IO
15:52:12 * hackagebot snap-core 0.2.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.1 (GregoryCollins)
15:52:14 * hackagebot snap-server 0.2.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.1 (GregoryCollins)
15:52:24 <jlouis> Also, I cut off after a bounded number of minViews if possible because I was afraid it took up all the CPU time
15:52:36 <c_wraith> moar updates?  Guess they're working hard on it. :)
15:54:00 <vmixey> > iterate (+17) 0
15:54:02 <lambdabot>   [0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,272,289,306,323,3...
15:56:13 * hackagebot heist 0.1.2 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.1.2 (GregoryCollins)
15:56:55 <jlouis> mm, they are hard at work
15:57:28 <jmcarthur> i'd definitely like to give snap a try
15:57:40 <c_wraith> I'm working with it for a stupidly simple example right now.
15:57:50 <Saizan> clanehin: the StaticArrow thing looks like a bug
15:58:07 <c_wraith> I wonder if the major version bump means they broke one of the 3 functions I'm using. ;)
15:58:35 <jmcarthur> i was talking to somebody yesterday who has apparently been using it while it was still on the down low. he gives it a good review
15:59:06 <c_wraith> It looking pretty clean so far.
15:59:24 <jmcarthur> it doesn't feel too low level? that seems to be my initial impression from the documentation
15:59:36 <sm> I have if flag(web) and if flag(webhappstack) sections in my .cabal, meant as alternatives. Latest cabal  check complains because they both pull in the same module. I tried using else, no luck. Any ideas ?
15:59:40 <c_wraith> It is low level, which is the part I'm working with at the moment...
16:00:22 <c_wraith> But *most* of what I want to do with a haskell web server is low-level stuff.
16:00:50 <jmcarthur> i'm more interested in getting this FRP/DCTP library working first. i'm tired of not having a good implementation
16:01:04 <Saizan> DCTP?
16:01:12 <jlouis> I wonder how hard it would be to reuse snap inside combinatorrent :)
16:01:32 <jmcarthur> Saizan: denotative continuous-time programming. it's a bit more accurate for describing my goals than functional reactive programming, i think
16:01:57 <c_wraith> I've got to say, I don't like the .cabal file that snap init creates.  But that's a really minor complaint.
16:02:00 <jmcarthur> Saizan: plus it has conal's thumbs up, and i'd like to spread better ideas of what it's all about by using more accurate terminology :)
16:02:13 <DerisionSnort> @pl \x y -> x:y:[]
16:02:13 <lambdabot> (. return) . (:)
16:02:18 <jmcarthur> c_wraith: yeah, i am very particular about such unimportant things :\
16:02:47 <Saizan> jmcarthur: i'm always in favor of more accurate terminology if it has clear definitions :)
16:03:15 * hackagebot atom 1.0.4 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.4 (TomHawkins)
16:04:40 <DerisionSnort> @pl \xs ys -> concat $ zipWith (\x y -> x:y:[]) xs ys
16:04:40 <lambdabot> (join .) . zipWith ((. return) . (:))
16:04:43 <DerisionSnort> lol
16:04:57 <gcollins> c_wraith: what would you like to see instead?
16:05:09 <gcollins> we kind of just dashed it out.
16:06:00 <c_wraith> gcollins: I'd rather not have the overloaded strings extension in it, and the build-depends has about 3 things that aren't necessary in it.
16:06:13 <jmcarthur> Saizan: well, "denotative" here is meant the way Landin uses it in The Next 700 Programming Languages, and i think "continuous-time" is a bit more obvious
16:06:18 * gcollins agrees
16:06:34 <nus> @unpl (join .) . zipWith ((. return) . (:))
16:06:34 <lambdabot> (\ e m -> (zipWith (\ j p -> ((:)) j (return p)) e m) >>= \ f -> f)
16:06:37 <gcollins> but doug wrote that and for the most part that means it's off my radar :)
16:07:01 <DerisionSnort> ((join .) . zipWith ((. return) . (:))) "bnn" (repeat 'a')
16:07:05 <DerisionSnort> > ((join .) . zipWith ((. return) . (:))) "bnn" (repeat 'a')
16:07:06 <lambdabot>   "banana"
16:07:08 <gcollins> overloadedstrings should be a language pragma inside the generated Main.hs -- i think someone already complained about that
16:07:15 <c_wraith> gcollins: also, you wrote some silly code in your website example:  error "blah" >> exitFailure
16:07:18 <c_wraith> ;)
16:07:25 <gcollins> yeah
16:07:34 <gcollins> that should be fixed also :)
16:07:54 <c_wraith> it still works how it's supposed to!  Just in a silly way.  :)
16:07:59 <gcollins> yeah
16:08:02 <gcollins> most definitely.
16:08:42 <gcollins> btw minor version bump was a slight api change in snap-core --- probably shouldn't affect end user code actually but i bumped the version to make sure
16:09:24 <gcollins> c_wraith: if you have questions/comments/etc you can join us in the #snapframework channel, we are more likely to see it in there
16:09:35 <gcollins> #haskell has a lot of traffic :)
16:09:36 <jmcarthur> anyway, i'm working on a DCTP library that uses stream fusion for doubleplus fast code :)
16:09:55 <c_wraith> gcollins: As I have any real feedback, I'll let you know in there.
16:10:00 <gcollins> cool
16:10:01 <c_wraith> err, *if* I have any...
16:10:04 <gcollins> :)
16:10:15 <Saizan> doubleplus?:)
16:10:23 <c_wraith> it's newspeak
16:10:32 <jmcarthur> Saizan: 1984
16:11:38 <roconnor> heh
16:12:03 <roconnor> only in haskell does reducing the size of my structures make me run out of memory
16:12:20 <Saizan> ah, missed that
16:12:47 <jmcarthur> writing the stream algorithms has been interesting. few of the existing stream functions are directly applicable to this since i'm really simulating a "continuous list"  (R -> a  semantics instead of  Nat -> a)
16:13:10 <gcollins> jmcarthur: what's "DCTP"?
16:13:18 <gcollins> discrete cosine transform?
16:13:30 <jmcarthur> gcollins: denotative continuous-time programming. it's a bit more accurate for describing my goals than functional reactive programming, i think
16:13:55 <gcollins> man -- i wish someone would come up with a workable FRP model
16:14:08 <jmcarthur> gcollins: i'm hoping mine is workable :)
16:14:19 <gcollins> in that case best of luck to you
16:14:45 <jmcarthur> it's an eventless model. only has behaviors and a kind of generalized integration
16:15:01 <gcollins> i did a little bit of yampa stuff back in grad school -- antony courtney was at yale at the same time i was and i poked around in there a little bit
16:15:28 <jmcarthur> my model is actually not very far from yampa, except i'm not going to be rigging an event model into it
16:15:30 <gcollins> for coursework i think? i don't remember
16:15:39 <jmcarthur> and i'm doing classical frp rather than arrowized
16:15:44 <gcollins> can you get away with not having events?
16:15:55 <jmcarthur> i think i can with my generalized integration idea
16:16:33 <jmcarthur> like, you should be able to accumulate impulses and treat them like events if you want (and it will probably happen in practice)
16:17:00 <roconnor> @type \b a -> guard b >> Just a
16:17:01 <lambdabot> forall b. Bool -> b -> Maybe b
16:17:04 <gcollins> "switching" behaviour?
16:17:09 <jmcarthur> but it won't really suffer from the sampling issue that yampa has (except for events deriving from truly continuous functions of time)
16:17:30 <jmcarthur> gcollins: yeah, switching should be naturally derivable from the primitives
16:17:36 <gcollins> coool.
16:17:42 <jmcarthur> but switching is not itself a primitive this time
16:18:15 <gcollins> it's been ages since i looked at that stuff -- the main issue w/ yampa is that you might have to hold on to an indeterminate amount of the input, right?
16:19:07 <jmcarthur> i've not used yampa for anything big. the main complaint i hear about is that you occasionally will hit some sort of laziness issue, which i imagine is what you are describing.
16:19:55 <jmcarthur> i also take issue with sampling rate being exposed in the semantics for events (the "no infinitely discontinuous events" restriction)
16:20:29 <jmcarthur> my implementation will technically leak sampling rate too, but the semantics should be better defined and i think a bit more elegantly
16:21:07 <jmcarthur> "continuous events" should be fine in my model, for example, although you may still observe differences in the output with two different sampling rates
16:21:21 <clanehin> Saizan: yeah, I think so too.
16:21:27 <jmcarthur> but that's just reality screwing up the theory ;)
16:21:32 <gcollins> :)
16:22:07 <ezyang> Pooh, why isn't haskell-src-exts a drop-in replacement for haskell-src
16:26:43 <Saizan> jmcarthur: that makes it sound like accuracy is bad for theories :)
16:27:07 <jmcarthur> Saizan: my point is that sampling rate is purely an implementation flaw this time rather than a semantic flaw
16:28:50 <jmcarthur> in yampa the semantics is actually defined such that you can't create an infinite number of events in any range of time. my eventless model avoids that ugliness
16:32:40 <Saizan> do you lose any valuable predictive power over how the programs actually run?
16:33:46 <jmcarthur> i think it was a concession to the inability to make a general enough integration algorithm in the implementation. in this case, i've made a general integration algorithm. it's not accurate enough to catch all possible "events," but it's accurate enough to get most of the ones i can think of that people will care about. it's essentially a generalization of numeric integration. since i have an
16:33:49 <jmcarthur> algorithm that basically works i'm defining the semantics for "an ideal world"
16:36:22 <jmcarthur> Saizan: well, i have made a concession in the implementation to encode impulses into the behavior that are guaranteed not to be overlooked by the integrator, so if you need that kind of predictive power that's available. however, things like collision detection of bullets are probably not going to work naively
16:36:49 <jmcarthur> i'm not doing any sort of interval arithmetic to hone in on derivate impulses like that
16:46:33 * hackagebot hledger-lib 0.10 - Core types and utilities for working with hledger (or c++ ledger) data.  http://hackage.haskell.org/package/hledger-lib-0.10 (SimonMichael)
16:46:35 * hackagebot hledger 0.10 - A command-line (or curses or web-based) double-entry accounting tool.  http://hackage.haskell.org/package/hledger-0.10 (SimonMichael)
16:53:16 <_wsh> hey all, anyone feel like helping out with a really stupid installation error question?
16:54:27 <sshc> Nope
16:54:37 <_wsh> sshc:  okay :P
16:55:55 <dantheman> Hey all, I'm having a bit of trouble understanding what the point of  the 'coarbitrary' function of Quickcheck's Arbitrary type class is for. Can anyone enlighten me?
16:56:39 <c_wraith> dantheman: it's...  complicated.  It has to do with creating Arbitrary instances for functions.  If you use Quickcheck 2, it's been moved somewhere entirely different.
16:58:25 <dantheman> Right. Well all I want to do is create a simple test property. However to do so I have to make an instance for Arbitrary of one of the parameters (it's just a simple data MyData = DataA | DataB)
16:58:54 <dantheman> But when I compile it keeps complaining I haven't implemented the coarbitrary function.
16:59:19 <dantheman> my arbitrary function is just of the form : arbitrary = elements [DataA, DataB]
16:59:24 <c_wraith> If I remember how it works, you should be able to get away with implementing it as undefined
17:07:17 <danderson> in Template Haskell, is there a way to print a Q value as a string of Haskell (for debugging/verification) ?
17:07:41 <danderson> the output of Show for what I'm defining is essentially unparseable :)
17:08:23 <ezyang> "hackage-collision: Ambiguous infix expression". Oh poo.
17:09:41 <ezyang> I wonder what kind of exception is being thrown and how to catch it.
17:10:16 <iaefai> How can I convert an integer to a string, show adds " " to it, which I do not want.
17:10:28 <danderson> aha, found the pretty printer for TH.
17:10:34 <danderson> and good grief, that is quite horrific.
17:13:14 <sepp2k1> iaefai: show doesn't add "s to numbers (at least not for the Num instances in the standard library). It does add "s if you show strings.
17:14:05 <iaefai> > (show 9)::[Char]
17:14:06 <lambdabot>   "9"
17:14:18 <sepp2k1> length "9"
17:14:22 <sepp2k1> > length "9"
17:14:24 <lambdabot>   1
17:14:59 <sepp2k1> > "\"" `elem` "9"
17:15:00 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:15:00 <lambdabot>         against inferred ty...
17:15:14 <iaefai> > length ((show 9)::[Char])
17:15:15 <lambdabot>   1
17:15:19 <iaefai> ok, my mistake
17:15:31 <sepp2k1> > '"' `elem` "9"
17:15:32 <lambdabot>   False
17:17:02 <sepp2k1> Note that when ghci (or lambdabot) displays the result of an expression, it calls show on it. So if you type in show 9, ghci basically does  putStrLn (show (show 9))
17:17:15 <iaefai> :t (++)
17:17:16 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:17:34 <iaefai> > (show 9) ++ "10"
17:17:35 <lambdabot>   "910"
17:17:50 <iaefai> > show 9 ++ "10"
17:17:50 <lambdabot>   "910"
17:27:01 <QtPlatypus> What varent of haskell does lambdabot speek?  Is there a alternative predlude I can load
17:27:05 <QtPlatypus> :t (.)
17:27:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:27:29 <ManateeLazyCat> How to spawn an external process that ignore parent-process's kill signal, i mean child process will live even parent process has killed. I use "runCommand (command ++ " &") >> return ()", but can't work.
17:28:29 <ManateeLazyCat> Thanks!
17:29:03 <copumpkin> QtPlatypus: caleskell! ;)
17:29:19 <copumpkin> QtPlatypus: you can grab the lambdabot source and see what modules are loaded by default
17:29:32 <alpounet> it's in the L.hs file iirc
17:30:05 * hackagebot hpage 0.11.1 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.11.1 (FernandoBenavides)
17:31:37 <QtPlatypus> :t (+)
17:31:38 <lambdabot> forall a. (Num a) => a -> a -> a
17:32:07 <djahandarie> :t f
17:32:07 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
17:36:35 <alpounet> > iter f x :: [Expr]
17:36:36 <lambdabot>   Not in scope: `iter'
17:36:43 <alpounet> > iterate f x :: [Expr]
17:36:44 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
17:37:14 <kmc> @hoogle runCommand
17:37:15 <alpounet> hey lowasser did you get the llvm backend to work ?
17:37:15 <lambdabot> No results found
17:37:25 <lowasser> alpounet: yes indeed!
17:37:33 <alpounet> what was the problem ?
17:37:36 <dantheman> How do you go about getting quickcheck to do more than the standard 100 tests?
17:37:47 <kmc> ManateeLazyCat, perhaps you can use "nohup" (on UNIX)
17:37:48 <lowasser> I don't honestly know, but I did a clean install, and it worked out
17:38:06 <dantheman> i.e. is there some way you can just call quickcheck prop NUMTESTS
17:38:13 <kmc> :t Test.QuickCheck.check
17:38:14 <lambdabot> Not in scope: `Test.QuickCheck.check'
17:38:17 <ManateeLazyCat> kmc: Can you tell me why option "&" can't work ?
17:38:23 <lowasser> anyway, with LLVM, my implementation is running 20-30% faster than the C++ implementation written by the inventors of the algorithm
17:38:28 <lowasser> I'm pretty pleased
17:38:29 <kmc> dantheman, check :: Testable a => Config -> a -> IO ()
17:38:32 <kmc> ManateeLazyCat, not precisely
17:38:35 <dantheman> cheers kmc
17:39:00 <alpounet> lowasser, wow nice
17:39:05 <alpounet> what is your code doing precisely ?
17:39:22 <alpounet> (i'm trying to spot the areas where the backend does a good job)
17:39:43 <lowasser> http://hackage.haskell.org/packages/archive/rangemin/2.2.1/doc/html/Data-RangeMin.html
17:39:48 <kmc> quickCheckN n = check (defaultConfig { configMaxTest = n })
17:40:11 <ManateeLazyCat> kmc: I have finish a GTK+ QuickSilver program (that search input and do it for you) http://farm4.static.flickr.com/3415/4619030666_2e5df0bcf8_o.png, one of feature is search application and startup it.
17:40:19 <alpounet> lowasser, and compared to the NCG ?
17:40:28 <ManateeLazyCat> kmc: But i want new application still running even i kill my program.
17:40:29 <lowasser> the NCG is tied with the C++ implementation
17:41:06 <alpounet> ok
17:41:57 <lowasser> it's very array-heavy, and I had to roll my own stream fusion to get the kind of performance I wanted
17:42:32 <alpounet> Data.Vector's wasn't enough ?
17:43:30 <lowasser> the vector package's fusion has a distinct tendency to have several duplicated variables with the same information
17:43:42 <lowasser> I'm talking about it some with Roman
17:44:11 <dpratt71> ]\
17:44:11 <dpratt71> '
17:44:26 <alpounet> ok
17:44:27 <lowasser> but the kinds of operations I need for this particular application let me get a little more specialized than Data.Vector
17:44:53 <lowasser> e.g. I don't need any Skips in my streams, but I need to efficiently support snoc
17:45:22 <alpounet> yeah ok i see
17:48:37 <ManateeLazyCat> kmc: nohup works perfect, thanks!
17:49:25 <hpc> nohup is basically an alias for command > nohup.out
17:50:51 <dibblego> what is a right-associative operator that most people would be familiar with?
17:50:53 <ManateeLazyCat> hpc: Have any program similar nohup ?
17:51:08 <sepp2k1> hpc: It is? I'd think it was called nohup because it prevents the app being killed by the HUP signal. > certainly doesn't do that.
17:52:07 <hpc> oh, it also pulls input from /dev/null
17:52:16 <Cale> @tell dibblego exponentiation is right-associative
17:52:16 <lambdabot> Consider it noted.
17:53:25 <ManateeLazyCat> sepp2k1: nohup is right command to prevent child-process kill when parent-process exit?
17:53:58 <hpc> oh, if this isn't running from a terminal, nohup is the right command
17:55:07 <ManateeLazyCat> hpc: http://farm4.static.flickr.com/3415/4619030666_2e5df0bcf8_o.png my GTK+/Haskell program similar Mac QuickSilver.
17:55:17 <ManateeLazyCat> hpc: One of feature is "startup application".
17:55:26 <hpc> i see
17:55:32 <ManateeLazyCat> hpc: So i want new startup application won't kill by my program.
17:55:37 <vmixey> coool!!
17:55:58 <ManateeLazyCat> hpc: So nohup is right command for my need ?
17:56:02 <hpc> probably
17:56:12 <ManateeLazyCat> hpc: I have test runCommand with option "&", but can't work.
17:56:34 <hpc> does haskell have a fork command?
17:56:52 <c_wraith> at least two
17:57:01 <c_wraith> depends on why you want to fork
17:57:02 <ManateeLazyCat> hpc: ?
17:57:14 <ManateeLazyCat> hpc: Why need fork?
17:58:14 <hpc> never mind, i am being stupid
17:58:23 <hpc> i did find this though: http://therning.org/magnus/archives/727
17:59:32 <ManateeLazyCat> I need redirect nohup output to /tmp, i don't want nohup.out flood my directories. :)
17:59:50 <dibblego> sorry, did I miss anything? "what is a right-associative operator that most people would be familiar with?"
17:59:51 <lambdabot> dibblego: You have 1 new message. '/msg lambdabot @messages' to read it.
18:00:04 <dibblego> thanks Cale
18:00:37 <dolio> > 2 ^ 2 ^ 2
18:00:38 <lambdabot>   16
18:00:44 <dolio> > 2 ^ 2 ^ 2 ^ 2
18:00:45 <lambdabot>   65536
18:01:00 <ManateeLazyCat> hpc: You mean forkProcess?
18:01:02 <dibblego> > (2 ^ 2) ^ 2
18:01:03 <lambdabot>   16
18:01:22 <dibblego> > ((2 ^ 3) ^ 2) == (2 ^ 3 ^ 2)
18:01:23 <lambdabot>   False
18:01:36 <hpc> not sure
18:01:48 <hpc> i seem to have all those calls mixed up
18:01:53 <danharaj> "right-associative" is not a characteristic of an operation, but a convention held by its users to omit parentheses.
18:02:40 <dolio> It's a property of an operator in Haskell.
18:02:49 * ManateeLazyCat If you want spawn GTK+ child-process, don't use forkProcess, it's not safe function do that, use runProcess or runCommand instead.
18:03:32 * ManateeLazyCat I have write detail description in gtk2hs
18:09:18 * hackagebot fpipe 0.0.1 - F#-style composition and application  http://hackage.haskell.org/package/fpipe-0.0.1 (BenSchulz)
18:10:51 * ManateeLazyCat pasted "run extenal command and won't kill when parent process exit." at http://paste2.org/get/847494
18:11:06 <ManateeLazyCat> Above functions works well.
18:11:10 <ManateeLazyCat> Thanks all for help! :)
18:11:57 <SquOnk> Greetings.
18:12:23 <SquOnk> Can anyone offer a hint on how to run batch QuickCheck2 tests. There's no Test.QuickCheck.Batch anymore, is it?
18:13:20 <ManateeLazyCat> My QuickSilver better GNOME-launcher, support regular-expression search ..... :)
18:29:08 <Null-A> and I'm done my scheme interpreter! =)
18:29:16 <vmixey> cool
18:29:23 <vmixey> time?
18:29:31 <Null-A> About 10 hours
18:29:41 <vmixey> hey that's pretty good
18:29:49 <Null-A> I was also learning haskell too
18:30:08 <vmixey> what are you going to do now?
18:30:11 <copumpkin> did you learn you a haskell?
18:30:25 <Pseudonym> Scheme interpreters take less than 48 hours, typically, so you've done pretty well.
18:30:32 <Null-A> It can execute this http://codepad.org/eZ3bgfqF vmixey
18:30:35 <Null-A> cognominal: yar
18:30:45 <Null-A> copumpkin: yar*
18:30:57 <vmixey> lonely parens ;_;
18:31:29 <Null-A> ?
18:32:57 <plfabian60> hey
18:33:13 <copumpkin> plfabian60: ohai2u
18:33:16 <copumpkin> how r u?
18:34:44 <plfabian60> good
18:35:29 <copumpkin> a/s/l?
18:35:53 * pastorn looses respect for copumpkin
18:36:37 <copumpkin> you set your respect loose?
18:37:07 <pastorn> copumpkin: but it's cool, Respect is Additive, so you can't go below zero
18:37:13 <ddarius> Option Strict Off
18:38:54 <plfabian60> 23/m/ny
18:39:10 <vmixey> hi
18:39:19 <vmixey> Null-A what are you going ot hack next?
18:39:43 <Null-A> vmixey: hmh
18:40:12 <Null-A> vmixey: I might take a whack at the distributed systems compiler again
18:40:36 * vmixey does not even know what that is :)
18:41:05 <Null-A> well it's not a refined term, it's just writing a compiler for a computer language which is meant for building distributed systems
18:41:52 <Null-A> hmh, or maybe i should try building a distributed system in haskell
18:42:21 <vmixey> the problem I always had with concurrency is that I only have one computer..
18:42:32 <Null-A> multi process with sockets?
18:42:35 <vmixey> so it's all theoretical really.. and why bother even programming it in that case
18:43:04 <Null-A> well.. I also wanted to run simulations of different kinds of failures
18:43:11 <Null-A> and perf analysis
18:43:15 <SamB_XP> what if you need to mix IO and computation in a fairly-optimal way?
18:43:22 <vmixey> ah that sounds pretty cool
18:43:46 <Null-A> SamB_XP: if I cared about performance I wouldn't be using haskell
18:43:52 <Null-A> at least for distributed systems
18:44:05 <SamB_XP> you'd rather use erlang, then?
18:44:09 <Null-A> most would use C++ or something, but my hobby project becomes monumental
18:44:27 <Null-A> well I'm curious what I can do with haskell as an exercise, I know what erlang is capable of
18:44:47 <Null-A> I also wanted to focus no shared state models rather than messaging
18:44:50 <Null-A> on*
18:45:04 <SamB_XP> ugh, state
18:45:07 <ddarius> Null-A: Distributed shared state?
18:45:09 <Null-A> yes
18:45:11 <SamB_XP> alsways making things a pain
18:45:23 * copumpkin wrote a network Chan once
18:45:28 <copumpkin> but then got bored
18:45:39 <copumpkin> it was going to work with vacuum for ultimate leetness
18:45:45 <ddarius> Null-A: Sounds like a disaster, but you wouldn't be the first.
18:45:57 <Null-A> ddarius: so you're a fan of messaging?
18:48:00 <Null-A> ddarius:  unfortunately one way or another, you rely on state if you want to recover from failure
18:48:04 <ddarius> Null-A: For a distributed scenario, yes.  Trying to hide the underlying reality in those cases seems only to lead to complicated and fragile code to cover where the abstraction fails.  The shared state abstraction is becoming more and more untenable even on a single computre.
18:48:29 * hackagebot snap-core 0.2.2 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.2 (GregoryCollins)
18:48:30 <ddarius> Null-A: There's a difference between "state" and "shared state"
18:48:54 <Null-A> right
18:48:58 * Null-A thinking
18:51:22 <Null-A> ddarius: So, let's focus on particular use cases:  Let's say you have a computer node that dies, if you were operating on shared state, another computer node could continue where the last node left off
18:54:22 <ddarius> Null-A: Shared state neither necessarily provides that nor does message passing preclude that.
18:54:41 <Null-A> ddarius: well okay
18:54:50 <Null-A> you're obviously on top of your game here
18:54:56 <Null-A> hm
18:55:06 <Null-A> what uni/college did/do you go to?
18:55:45 <ddarius> Null-A: I don't have a degree.
18:55:55 <Null-A> just high school?=
18:57:42 <ddarius> I technically have an Associate's degree, but I've never been a full-time student of any college.
18:57:49 <Null-A> k
18:58:39 <Null-A> mhm
18:58:46 <Null-A> I guess I kind of agree
18:59:16 <copumpkin> agree?
18:59:26 <Null-A> "For a distributed scenario, yes.  Trying to hide the underlying reality in those cases seems only to lead to complicated and fragile code to cover where the abstraction fails.  The shared state abstraction is becoming more and more untenable even on a single computre."
18:59:36 <Null-A> shared state vs messaging
19:07:01 <Saizan> you mean that things like CORBA don't work well?
19:07:41 <Null-A> ddarius: While I agree that shared state seems to hide more realities than messaging, this doesn't necessarily lead to fragile code, so long as you don't make unjustified assumptions about the realities of messaging that control the shared state
19:07:57 <Null-A> ddarius: And there are certainly advantages of having a higher level of abstraction
19:08:58 <monochrom> you can make either shared variables or messages "higher level"
19:10:31 <Null-A> right, in some ways higher level messaging apis just converge on shared state..
19:10:39 <Null-A> obviously there's a lot of ways you could take it
19:11:43 <Saizan> i think the idea is that there are cases where your model already resembles message passing, so using shared state would be an encoding
19:11:52 <ddarius> The assumptions inherent in the shared state model are unjustified.
19:12:10 <ddarius> on a distributed system
19:12:28 <ezyang> Question for Cabal devs: does it make sense for me to ask for, say, all BuildPaths from a GenericPackageDescription?
19:12:30 <Null-A> Well I think there's many different models here.. ddarius
19:12:37 <Null-A> ddarius: can you give an example
19:12:51 <monochrom> Notice a premise of OOP is "message passing is higher level than shared variables".
19:13:28 <danharaj> monochrom: I think it is more that OOP encourages encapsulation, and message passing is more in that vein than shared variables.
19:13:41 <danharaj> monochrom: Not necessarily about 'higher level'
19:14:09 <ddarius> Null-A: Constant and small latency for accessing references, any guarantees about being able to retrieve or assign references, freshness of references.  Also many of the issues with shared state concurrency come along with a vengeance.
19:14:49 <Null-A> ddarius: well I wouldn't make those mistakes
19:14:54 <monochrom> Fine, message passing is more encapsulated than shared variables.
19:15:16 <Null-A> ddarius: shared state would be locally cached, so accessing references would be instanteneous
19:15:33 <ddarius> Null-A: And now you have to worry about inconsistency of the caches and cache misses.
19:15:35 <Null-A> ddarius: the guarantees about 'freshness' of state is nil
19:16:09 <ddarius> Caching is a large part of what makes computers complicated/fragile to program for performance as they try to maintain a shared-state picture for something that is increasingly distributed.
19:16:10 <Null-A> ddarius: I would guarantee that the local cache is equivalent to snapshot of the central database
19:16:18 <Null-A> ddarius: but definitely not real-time
19:16:41 <monochrom> In the 1990's, "how to fake shared variables over a message passing system" was a popular MSc thesis topic. Think about what that means.
19:16:46 <Null-A> ddarius: single writers
19:19:38 <ddarius> I think that a shared state abstraction should be an optional "library" over a primarily message passing base.
19:19:46 <Null-A> that's sensible
19:19:51 <Null-A> yah you're right
19:19:52 <Null-A> uhg
19:19:58 <Null-A> i'm been brainwashed a little
19:20:02 <Null-A> i've*
19:20:50 <Pseudonym> Haskellers don't use message passing nearly enough.
19:21:15 <Null-A> is it easy to program erlang style in haskell?
19:21:32 <Pseudonym> Arguably easier, because of strong typing.
19:21:43 <Null-A> many processes, easy failure, messaging/inboxes
19:21:56 <ddarius> Null-A: You can mimic the basic message passing style easily enough (in a non-distributed scenario) but the rest, such as the failure handling, is not there currently.
19:22:05 <Pseudonym> There's no common Haskell library for tuplespace.
19:22:10 <ddarius> It should be readily doable as a library, but no one has written the library.
19:22:16 <Pseudonym> But if you just want multi-input multi-output message queues...
19:22:49 <Pseudonym> Lambdabot uses this for the IRC protocol implementation, incidentally.
19:22:56 <danharaj> What is the best way to implement data structures whose 'constructors' need to enforce invariants?
19:23:06 <Pseudonym> There are three main threads which communicate via message-passing.
19:23:19 <Pseudonym> danharaj: Smart constructors.
19:23:27 <monochrom> hide constructors
19:23:29 <Pseudonym> Hide the real constructors, only expose the function version.
19:23:50 <danharaj> ah, alright.
19:23:56 <mauke> newspeak
19:24:03 <ddarius> mauke: What about it?
19:24:13 <mauke> encode the invariant in the data structure, making it impossible to talk about invalid objects
19:24:32 <Pseudonym> Depends on the invariant.
19:24:48 <Pseudonym> An obvious example of something that's hard to do that way is sorted lists.
19:25:25 <Pseudonym> Similarly, with balanced binary search trees, the balance condition is straightforward to enforce, but the search key ordering isn't.
19:25:32 <Pseudonym> Usually.
19:26:33 <pikhq> Null-A: Haskell lacks the Erlang runtime which makes distributedness and failure handling much less clean.
19:26:48 <Null-A> pikhq: *right* I was thinking about that too
19:27:24 <Pseudonym> The Erlang run time makes laziness harder, though.
19:27:37 <Null-A> Someone should really polish haskell in this area
19:27:38 <pikhq> Yeah.
19:27:43 <Null-A> it'd be a real shame if Erlang became the standard
19:27:54 <Pseudonym> Not really.
19:28:03 <Pseudonym> It's not either-or.
19:28:03 <monochrom> You can always design the data structure to lack invalid objects. Using countability, write a bijection between the integers and you data. Store the integer.
19:28:06 <mike-burns> Right tool for the right job.
19:28:18 <Pseudonym> It'd be a shame if F# became the standard.
19:28:24 <Null-A> mike-burns: unfortunately when you get hired by a company, it doesn't work like that
19:28:30 <Null-A> Pseudonym: lol
19:28:32 <ddarius> pikhq: Much of the failure handling can be reasonably handled at a library level.
19:28:35 <mike-burns> Null-A: I was just about to type that, acutally.
19:28:43 <dolio> But... Microsoft! And concurrent garbage collection!
19:28:59 <dolio> And Haskell sucks!
19:29:01 * ddarius doesn't really see Erlang and Haskell as competing.
19:29:13 <drk-sd> (neither do I)
19:29:48 <Null-A> can erlang even interop with other languages via protocol?
19:30:00 <mike-burns> At my current job we had to choose between Ruby and cron.
19:30:08 <mike-burns> Just to give an example of things that don't compete, competing.
19:30:11 <Pseudonym> It handles TCP/IP, if that's what you mean.
19:30:37 <Null-A> Pseudonym: if the protocol allows for passing functions over tcp/ip that poses a problem
19:31:00 <Null-A> mike-burns: ouch
19:31:02 <dolio> mike-burns: What was the Ruby angle? Write your own cron in Ruby?
19:31:21 <Pseudonym> Erlang has been used to implement ATM switches.  So I think it's safe to say that it interfaces to non-Erlang.
19:31:29 <mike-burns> dolio: Well, use an existing cron-like scheduler with a Ruby API.
19:31:40 <monochrom> Fun, choosing between F# and penguin!
19:33:29 <ddarius> Pseudonym: Ericsson also uses C++ and presumably their Erlang and C++ code talks to each other upon occassion.  If Erlang can talk to C++, it can talk to anything.
19:34:10 <monochrom> (C++ can talk to C++. It can't talk to anything else. Except Erlang. :) )
19:34:18 <Null-A> lol
19:34:23 <mauke> C++ can't talk to C++
19:34:29 * ddarius agrees with mauke.
19:34:31 <copumpkin> there's a package on hackage for acting as an erlang node iirc
19:34:40 <Saizan> http://hackage.haskell.org/package/eprocess
19:35:07 <copumpkin> http://hackage.haskell.org/package/erlang
19:35:19 <Saizan> two then!
19:36:21 <copumpkin> :)
19:36:32 <dancor> can the packages talk to each other
19:36:41 <Null-A> Maybe strong typing systems are destined to fail, I mean look at python's success. Perhaps people like shooting themselves in the foot. Avoid the immediate pain of compiler errors, for the repeatibly unforeseen long term pain continuous debugging and maintainability costs.
19:37:09 <copumpkin> people are stupid, but who cares?
19:37:19 <monochrom> costs? it's revenue.
19:37:20 <mike-burns> Java is quite popular and has stronger typing than Python.
19:37:21 <Null-A> we'll have to start our own companies then
19:38:21 <dancor> i think laziness and immaturity/small-userbase are much bigger non-starters for haskell
19:38:33 <copumpkin> laziness?
19:38:35 <dancor> that too-strong typingg
19:38:37 <dancor> non-strictness
19:38:39 <Pseudonym> mike-burns: Most Java programmers will readily admit, if pressed, that they use Java despite the language, not because of it.
19:38:41 <copumpkin> non-strictness?
19:38:52 <Pseudonym> The value proposition of Java is not the language, but the platform/libraries/frameworks/tools.
19:38:54 <mike-burns> Pseudonym: And yet they use it.
19:38:54 <dancor> non-strict semantics
19:38:54 <monochrom> The last thing a paid programmer wants is a program that writes itself.
19:39:03 <mike-burns> Pseudonym: Yeah, exactly.
19:39:06 <copumpkin> dancor: sorry, I mean why do you think that's a problem?
19:39:26 <dancor> copumpkin: oh, it's a complication that can become a liability
19:39:42 <dancor> in debugging complexity, for example
19:39:56 <mike-burns> It really has to do with whether the language provides some "killer app" that makes the programmer's life more productive.
19:40:28 * ezyang goes stabbity stab at his hs file 
19:40:30 <dancor> performance analysis as well
19:43:51 <djwonk> i'm looking for alternative ideas on how to setup various strategies in a simulation. a strategy determines how an agent is going to behave. different strategies can be initialized in different ways.
19:44:35 <djwonk> my mind tends to gravitate towards OO... in which case I would have subclasses with different initializer parameters
19:44:49 <monochrom> without further detail, a strategy is a function. (with further detail, I don't want to get into it!)
19:44:55 <ezyang> I want hGetContents to properly handle UTF-8 files; how can I set the locale inside of Haskell?
19:45:19 <djwonk> monochrom: right. :)
19:45:41 <Saizan> ezyang: i'd hSetEncoding on Handle
19:46:01 <djwonk> monochrom: it is the type signature that has got me stuck. i don't know how to loosely specify the type signature of what a strategy function should look like (since I want to leave the kinds of initializations open ended)
19:46:37 <dancor> it could be WorldState -> Action..
19:46:47 <Saizan> you'd probably leave the initialization part out
19:47:11 <mike-burns> djwonk: I could very well be wrong, but it sounds like you're writing the abstraction before writing the code, and it might be easier to find the patterns if you go the other way around.
19:47:28 <djwonk> i've written a first pass already
19:47:33 <djwonk> it is super ugly
19:47:40 <mike-burns> Ah OK.
19:47:41 <dancor> djwonk: can you give more detail
19:48:20 <djwonk> to simplify: an agent gets one random number at a time
19:48:30 <djwonk> and has to decide to keep or get trying
19:48:54 <djwonk> it wants to find a reasonably high number, trading that off against the number of steps to look
19:49:04 <dancor> "get trying"?
19:49:17 <djwonk> sorry, "get trying" -> "keep trying"
19:49:17 <mike-burns> keep trying
19:49:28 <dancor> ok
19:49:32 <djwonk> not a hard problem
19:49:43 <ezyang> Saizan: Is there a way to do that with readFile?
19:49:48 <djwonk> just hard for me to code elegantly in haskell
19:49:55 <dancor> maybe it's Int -> [Int] -> Bool
19:50:07 <dancor> f curNum seenNums = decision
19:50:28 <djwonk> dancor: i want to implement multiple strategies, with multiple knobs to tweak
19:50:39 <dancor> right
19:50:44 <dancor> multiple f's
19:51:41 <Null-A> Is there a way to get mutable maps using IORefs without having to write all the boilerplate of calling newIORef, writeIORef, readIORef ?
19:51:43 <dancor> you might want to let the strategies keep their own state instead of explicitly providing seenNums
19:51:44 <djwonk> so here is what I have now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25671#a25671
19:52:12 <dancor> which might mean something like Int -> a -> (Bool, a)
19:52:17 <djwonk> it works. lots is missing. i hard coded some random #'s
19:53:20 <djwonk> right, i agree, multiple strategy functions
19:54:28 <ddarius> Null-A: Just abstract as usual.
19:54:48 <Null-A> ddarius: I was hoping it'd be a common pattern
19:54:49 <djwonk> part of what I want to learn is how to organize haskell programs in ways that make sense even though i don't get to use objects
19:55:19 <dancor> i would probably use more functions and fewer datatypes for this
19:55:21 <dancor> but idk
19:56:21 <ddarius> Null-A: There's modifyIORef but you'll probably still want an abstraction over that.
19:56:50 <ezyang> Does withFile give guarantees of strictness?
19:57:01 <djwonk> dancor: thanks for taking a look. i'm going to take a stab at another way, but I have to admit I think I'm missing some conceptual knowledge. maybe i just need a good example
19:57:45 <dh___> Good evening . I have a question about  Sharon Curtis' & Gavin Lowe "A graphical calculus" . with this Graphical calcus , I can't prove relation R meet R = R .
19:57:54 <dh___> any help ?
19:58:29 <ezyang> This *.hs parsing problem is kind of a mess; basically, I can't figure out how to read in a file as a String w/o making a guess whether or not it's latin1 or utf-8
19:59:06 <monochrom> latin1 should be banned
19:59:32 <ezyang> It's true!
19:59:36 <ezyang> But it's here to stay...
19:59:42 <ezyang> I should file a Hackage bug.
19:59:44 <ddarius> dh___: Ask on #math or some other channel
20:03:15 <monochrom> how would you define R meet R in haskell?
20:03:18 <jesusabdullah> R meet R = R; QED?
20:03:27 <jesusabdullah> What's R meet R mean anyways?
20:04:02 <copumpkin> meet is an operation on a lattice
20:04:14 <copumpkin> I'm assuming that's it
20:04:23 <monochrom> there are many lattices
20:04:31 <Adamant> monochrom: every time I deal with the various insanities Unicode has perpetuated, I feel the same way about it.
20:04:38 <copumpkin> I thought x meet x = x was one of the axioms
20:04:51 <copumpkin> I guess he's trying to prove it for a specific instance?
20:05:05 <dh___> meet is defined as  x = R meet S  <=>  x <= R and x <= S , according to Ricahrd Bird and Orge
20:05:20 <monochrom> axiom of lattices, sure. first you need to establish that the relation space is a lattice. zeroth you have to choose a partial order.
20:06:22 <monochrom> Unicode has not perpetuated any insanity.
20:06:37 <Jonno_FTW> hello
20:07:11 <monochrom> Patriotic insanity that shortsightedly think "let's just design a charset that only works for one national language" does.
20:07:35 <Jonno_FTW> how come I get 'not in scope' errors when they are defined in other imported module?
20:07:50 <pikhq_> Adamant: Unicode is not insane. It is the only sane character set.
20:08:01 <orbisvicis> i have some questions about recursion, are the comments i put @ http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25672 correct? I also can't figure out the last example
20:11:30 <Adamant> monochrom: at the time both ASCII and Latin-1 were written, most of the rest of the world couldn't afford anything to run a charset on.
20:11:31 <mauke> orbisvicis: the last one is a type error
20:11:48 <Saizan> ezyang: there are packages on hackage with sources in latin1?
20:12:27 <ezyang> Saizan: Sort of.
20:12:35 <ezyang> From spot checking, it's just in the source code comments
20:12:54 <Saizan> ah, ok
20:13:07 <pikhq> Adamant: Which justifies the continued existence of non-Unicode charsets how?
20:13:17 <orbisvicis> mauke: yes, why is the second argument not a monad
20:13:25 <monochrom> Jonno_FTW: perhaps because http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/interactive-evaluation.html#ghci-scope
20:13:28 <djwonk> mike-burns: i pasted my code, if you have any suggestions i would be very glad.
20:13:46 <Jonno_FTW> how can I have 2 modules, and the second module relies on functions from the first? The problem I get is it tries to compile the first module, but this fails because things are out of scope which I have defined in the second module
20:13:51 <mauke> orbisvicis: because values aren't monads. a monad is a type with two operations
20:14:00 <Adamant> pikhq: they don't need to justify their existence any more than Unicode does.
20:14:08 <mauke> orbisvicis: and the second argument is not a monadic value because someone misspelled 'mpower'
20:14:44 <ezyang> Oh joy, some code is emitting Control.Exceptions...
20:14:49 <orbisvicis> mauke: heh, and thanks for the semantic clarification
20:14:59 * ezyang is still unhappy with the preponderance of exception possibilities 
20:15:16 <Adamant> pikhq: also Unicode is more or less one long and continual vulnerability when it comes to doing anything involving strings and security.
20:15:24 <pikhq> Adamant: Yes they do. They support one or a few national languages. This is to say, they are ROYAL PAINS IN THE ASS for anyone who ever, ever wants to deal with multiple languages.
20:15:25 <Saizan> Jonno_FTW: you should import the second module from the first too
20:15:45 <pikhq> Unicode, on the other hand, handles pretty much every currently-spoken language.
20:15:48 <ezyang> If I want to squelch a control.exception, how can I do it? `catch` const ... doesn't work because e is insufficiently constrained.
20:15:50 <Saizan> Jonno_FTW: but then you get mutually recursive modules, which aren't properly supported.
20:16:07 <Saizan> ezyang: contrain with SomeException
20:16:09 <mauke> ezyang: define a custom catchAll with a restricted type
20:16:20 <pikhq> Also, one long and continual vulnerability? How are they *any* more so than any other string type?
20:16:23 <Adamant> pikhq: in a way that people bitch is linguistically inappropriate
20:16:26 <Jonno_FTW> but I don't want the second module in the first
20:16:42 <Adamant> see the CJK controversy
20:16:47 <pikhq> Adamant: Better than literally *everything else in existence*.
20:16:51 <ezyang> Oh, I see!
20:16:52 <Saizan> Jonno_FTW: but you do if you're using functions from the second in the first..
20:16:56 <Jonno_FTW> I want the second module as a generic module
20:17:00 <ezyang> IT looks like this is frowned upon tho
20:17:03 <Jonno_FTW> i guess
20:17:35 <pikhq> Unicode at least makes it *possible* to deal with multiple languages. Going back to national standards for encoding is an awful *regression*.
20:17:49 <Adamant> pikhq: have you looked at the history of Unicode-related security bugs?
20:18:11 <pikhq> "Look at us, we fail horribly at writing parsers"?
20:18:18 <ezyang> Adamant: IIRC, they're all due to Foo <-> Unicode conversions
20:18:43 <Adamant> ezyang: and Unicode would be ignored by a lot of folks if it couldn't do that
20:18:59 <ezyang> Ok, some say I'm getting some mystery Control.Exception, and I want to find out where it's coming from. How can I tease out this info?
20:19:08 <ezyang> Adamant: Sure.
20:19:29 <ezyang> Anyway, i18n is inevitably painful, since we're not very i18n people
20:20:30 <monochrom> perhaps Adamant means URLs like "hskell.org". that "" is U+0430 not U+0061
20:20:44 <pikhq> Adamant: Having multiple character sets = special cases. Special cases are the bane of everyone everywhere. Granted, Unicode isn't free of them. (Freaking Han unification) But honestly, I do not want to have to keep dealing with the differences between ASCII, Latin-1, MS CP-2524, Shift-JIS, JIS, and EUC-JP.
20:21:04 <mauke> http://www.sektioneins.com/de/advisories/advisory-032008-php-multibyte-shell-command-escaping-bypass-vulnerability/index.html  -- awesome non-unicode bug
20:21:10 <pastorn> pikhq: is that korean?
20:21:43 <pikhq> pastorn: No, Japanese just has 3 freaking character encodings in common use, and 4 defined.
20:21:52 <pastorn> 4
20:21:54 <pastorn> ?
20:22:02 <ezyang> srsly!   = error "ambiguous infix expression"
20:22:05 <pastorn> hiragana, katakana and kanji and .....?
20:22:09 <pikhq> JIS, Shift-JIS, EUC-JP, and UTF-8.
20:22:14 <ezyang> pastorn: Nope ;-)
20:22:20 <pastorn> oh, ok
20:22:22 <pastorn> :)
20:22:29 <ezyang> Shift-JIS is such a bitch. http://htmlpurifier.org/security/2008/shift-jis
20:22:44 <pastorn> pikhq: just use UTF and say sod off to everyone else :)
20:22:47 <pikhq> Shift-JIS is defined in terms of JIS to allow for backwards compatibility with a katakana encoding set that DOS used.
20:22:52 <Jonno_FTW> upon following your advice, I get this: Module imports form a cycle for modules:
20:22:55 <Jonno_FTW>   Morebot (morebot.hs)
20:22:58 <Jonno_FTW>     imports: Botbase
20:23:00 <Jonno_FTW>   Botbase (./Botbase.hs)
20:23:03 <Jonno_FTW>     imports: Morebot
20:23:15 <pastorn> Jonno_FTW: there's a way around that
20:23:20 <Jonno_FTW> go on
20:23:31 <pikhq> JIS is the national standard. EUC-JP is the UNIX standard (and thus, used by a large number of websites). And UTF-8 is, well, Unicode.
20:23:33 <Jonno_FTW> using your bot template?
20:23:38 <Saizan> yeah, i told you mutually recursive modules are not nice to work with :)
20:23:42 <pikhq> Oh, yeah, and Shift-JIS is the Microsoft standard.
20:23:59 <pastorn> Jonno_FTW: no, but if you *have* to have cyclic imports, you can define a 'base' file or something
20:24:09 <pastorn> it's in the language spec, iirc
20:24:15 <mauke> it's not
20:24:31 <pastorn> well, the page looked spec-y
20:24:38 <Jonno_FTW> is there a better workaround then?
20:24:39 <Saizan> Jonno_FTW: this is how GHC supports them: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/separate-compilation.html#mutual-recursion
20:24:52 <pastorn> Jonno_FTW: ^^^
20:24:57 <pastorn> Jonno_FTW: make Types.hs
20:25:07 <pastorn> and put all your stuff in there :)
20:25:29 <ezyang> agggh who is emitting this error :-(((
20:25:31 <Saizan> or decouple your modules more, if they deserve to
20:25:38 <pastorn> Jonno_FTW: or do you have functions calling each other from different modules?
20:26:09 <pastorn> ezyang: seems like an awesome error :)
20:26:24 <Saizan> ezyang: i'd bet the parser.
20:26:41 <ezyang> Saizan: I've grepped haskell-src-exts for the error string and haven't found it
20:26:50 <ezyang> oh, duh, caps
20:27:08 <ezyang> here we go!
20:27:18 <iaefai> Is there an easy way to find out where cabal is located, if you don't have it in the path, but ghc is in the path?
20:27:26 <Jonno_FTW> this seems like a bit of a nasty workaround
20:27:32 <Jonno_FTW> is there a best way?
20:27:40 <pastorn> iaefai: $ which cabal
20:27:46 <pikhq> Adamant: In short: not-Unicode is hell.
20:27:55 <Saizan> pastorn: "don't have it in the path"
20:27:59 <Adamant> pikhq: I would disagree
20:28:04 <Saizan> iaefai: tried ~/.cabal/bin ?
20:28:04 <pastorn> iaefai: usually in ~/.cabal/bin/
20:28:13 <pikhq> Adamant: How many character encodings do you regularly deal with?
20:28:19 <pikhq> I regularly see 6.
20:28:25 <pikhq> For 2 languages.
20:28:45 <iaefai> Saizan: THat is where I have it, but I need to find it in any computer where it lives. So I need a reliable method.
20:28:46 <Adamant> pikhq: like most other technical standards, Unicode is great for some folks and completely fucks/annoys others
20:28:53 <iaefai> I don't expect anything wierd, just possible
20:28:58 <ezyang> How do catch fail in the IO monad?
20:29:09 <pastorn> pikhq: isn't there any library for this?
20:29:11 <Adamant> pikhq: ASCII, Latin-1, and UTF-8
20:29:23 <pikhq> Adamant: You're off by one.
20:29:30 <Adamant> on average, when I'm not playing at speaking other languages
20:29:30 <ezyang> It seems like Prelude.catch should do it, but I'm missing the error
20:29:31 <pastorn> data Japanese = UTF8 String | JIS String | SJIS String ...
20:29:32 <pikhq> There's also the Microsoft Latin-1 variant.
20:29:39 <pastorn> *JString
20:29:53 <Adamant> pikhq: true, but I don't run on Windows :)
20:29:53 <pikhq> pastorn: Shift-JIS cannot be reliably detected.
20:30:01 <Saizan> ezyang: Control.Exception.catch will surely do
20:30:04 <pikhq> Adamant: Yes, but surely you browse the web?
20:30:16 <pikhq> And thus have to deal with things mislabeled as Latin-1 from time to time?
20:30:26 <pastorn> pikhq: why not just use UTF and ignore the others?
20:30:28 <Adamant> pikhq: probably
20:30:35 <pikhq> pastorn: Because of websites.
20:30:41 <pastorn> that's what my lazy ass would've done :)
20:30:46 <Adamant> pastorn: why not just use English and ignore everything else :)
20:30:51 * ezyang is so confused 
20:30:53 <Adamant> same problems come up.
20:30:56 <pastorn> ezyang: haha
20:31:07 <pastorn> as someone said, it might be a parser error
20:31:07 <pikhq> Adamant: Every time you see random noise in a website, that's an error caused by encoding failure.
20:31:11 <ezyang> Saizan: Ok, so let's take stock here. Control.Exception.catch catches the exception, Prelude.catch does not.
20:31:23 <ezyang> I find the error string in the parser module, which is using Monad.fail
20:31:30 <ezyang> this does not compute
20:31:42 <pikhq> You see it a bit less than many other people, speaking only English. But it is a massive pain for, oh, pretty much everyone else.
20:31:51 <pastorn> ezyang: what parser library are you using?
20:32:10 <pikhq> About a third of my libc is code specifically for dealing with this mess.
20:32:10 <monochrom> why not just use haskell and ignore everything else :)
20:32:24 <pastorn> haha
20:32:36 <Adamant> pikhq: I don't speak only English, but I also don't depend on other languages.
20:32:43 <Saizan> ?src IO fail
20:32:43 <lambdabot> fail s  = failIO s
20:32:50 <Saizan> ?src failIO
20:32:50 <lambdabot> failIO s = ioError (userError s)
20:32:52 <pikhq> Unless we can replace Unicode with a better character set, we should just let everything but Unicode die a swift death.
20:33:20 <pastorn> pikhq: does unicode leave something out?
20:33:44 <Adamant> I could replace that with a lot of technical stuff I would like I see die for various reasons
20:33:57 <pikhq> pastorn: It is a bit overly complex in some areas, and did unification of a large number of CJK glyph variants.
20:34:03 <Adamant> but usually they are still being used for a reason.
20:34:08 <Adamant> not reasons I like
20:34:10 <Adamant> but reasons
20:34:37 <pikhq> Adamant: How many of those things do you continue to *advocate* the continued existence of?
20:34:55 * BMeph wonders how many hexa-flexagons are going to be at MG's interment...
20:34:55 <Adamant> I think more or less your statements about "special casing" and what technical standards do to folks can sum this up.
20:34:59 <pastorn> ezyang: use ghci + breakpoints to see what happened?
20:35:13 <Saizan> ezyang: well, Prelude.catch catches an exception thrown by fail here, maybe there's some rethrowing somewhere
20:35:30 <Adamant> pikhq: I advocate the use of stuff that I wouldn't use that is perfectly appropriate for others all the time
20:35:53 <Adamant> pikhq: because other people don't have the same set of trade-offs to make
20:36:31 <pastorn> ezyang: pm 4 u
20:36:38 * pikhq banishes Adamant to the hell that is having to deal with 3 *radically* different character sets for a *single freaking language*
20:37:08 <ezyang> pastorn: haskell-src-exts
20:37:09 <djwonk> dancor: I'm thinking about using an association list to initialize a strategy
20:37:26 <djwonk> it means that the compiler won't be able to do as much checking, though
20:37:30 <Adamant> pikhq: let's just decide on 64 bit characters and use that. it should be enough for anybody. (famous last words)
20:38:50 <Adamant> then the folks doing embedded stuff will be at our throats. :)
20:39:21 <pikhq> Adamant: Oh, they're already at our throats for using anything but ASCII, regardless of the language in use.
20:40:24 <pikhq> Arguably, they're at our throats just for demanding text output.
20:55:32 <pastorn> Jonno_FTW: did you get it working?
21:07:06 <cdsmithus> Silly question, perhaps.  If I want to non-lazily read an entire file into a String, is there an easy way to do that?
21:07:25 <ezyang> System.IO.Strict
21:07:25 <kmc> it's not as easy as it should be
21:07:37 <ezyang> "erm, yes it is" :o)
21:07:37 <copumpkin> you could rnf whatever lazy IO function you wanted
21:07:46 <copumpkin> aha, hadn't even come across that module!
21:07:53 <kmc> within the std lib
21:07:54 <cdsmithus> Thanks, ezyang!
21:08:04 <copumpkin> oh, it's not a standard lib
21:08:15 <cdsmithus> I'm okay with non-standard, so long as it works!
21:08:24 <copumpkin> if you want to do it without external dependencies, just rnf/deepseq the output
21:08:44 <ezyang> not standard lib unfortunately
21:09:15 <mauke> :t (>>= liftM2 (>>) (evaluate . length) return) . readFile
21:09:15 <lambdabot> Not in scope: `evaluate'
21:09:30 <ezyang> I think withHandle might also give you some guarantees about closing file handles
21:11:16 <cdsmithus> Okay, System.IO.Strict did it.  Thanks!  I'll remember that package
21:23:18 <Olathe> I've made some list functions and I want to time them (both to WHNF and NF). How do I do that ?
21:23:55 <yashton> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/profiling.html
21:26:27 <copumpkin> doing whnf on a list probably isn't too interesting
21:26:48 <copumpkin> you could force the spine without forcing the elements though, in addition to forcing all of it
21:31:57 <orbisvicis> is it possible to create a pure timer (seconds etc)
21:38:18 <Axman6> orbisvicis: time isn't a pure thing, so i don
21:38:21 <Axman6> don't believe so
21:38:28 <Axman6> every time you inspect time, it changes
21:38:32 <ezyang> IO in Haskell is kind of obnoxious
21:38:37 <Olathe> I want to do WHNF since I'm doing stuff like tailTake (equivalent to \n -> reverse . take n . reverse) and so on where getting to WHNF can take a while.
21:49:06 <ezyang> Haskell98 got IO pretty wrong... "opaque types"? Come on guys...
21:49:17 <copumpkin> what do you mean?
21:49:47 <ezyang> So, I want to catch only IO errors that correspond to "invalid arguments"
21:50:19 <Pseudonym> Ah, so the real problem here is that exceptions weren't worked out in 1998,.
21:50:22 <ezyang> If the IOError type was transparent, I could go an look it up. But there's no funtion
21:50:30 <ezyang> Pseudonym: I guess that to :-)
21:50:45 <ezyang> Oh, I see, InvalidArgument is GHC only
21:50:47 <ezyang> :-/
21:50:54 <Pseudonym> That's a fair complaint, but the situation would be even worse if IOError was transparent.
21:50:56 <ezyang> What's the good practice thing to do now?
21:53:09 <ezyang> I guess import GHC.IO.Exception is an option.
21:53:51 <Pseudonym> I don't know what's considered good practice, but that'll work.
21:54:13 <ezyang> you meen findModuleName?
21:54:26 <ezyang> No idea :o).
21:54:53 <ezyang> ModuleName -> IO (Maybe FilePath) I think
21:55:05 <ddarius> There are standard exception libraries.  If you are dealing with existing exceptions, you should use the relevant library which won't be in the GHC namespace.  If you are making your own, I recommend using an explicit exception monad rather than the IOErrors are asynchronous exceptions.
21:55:29 <ezyang> ddarius: It's an existing exception, and it's GHC only.
21:56:03 <ezyang> I mean, I could be lazy and catch all Io exceptions...
21:56:09 <ezyang> Actually, that might not be too wrong
22:04:29 <pastorn> ezyang: i h4xx ur syntax
22:04:56 <ezyang> hackahackahacka (< . . .
22:05:27 <c_wraith> Now I wonder if there's a pac-man glyph in unicode
22:05:44 <pastorn> hehe
22:07:27 <c_wraith> I couldn't find one in my quick search.
22:08:46 <pastorn> ezyang: don't kill me
22:17:55 <pastorn> ezyang: u has pm
22:17:59 <pastorn> *haz
22:21:35 <pastorn> how nasty is this? http://codepad.org/XzcT8ThX
22:21:40 <pastorn> (the let + ; stuff)
22:35:19 <ddarius> pastorn: Why don't you take those commented sections and make them into local functions?
22:36:12 <pastorn> which commented sections?
22:36:25 <pastorn> ddarius: also: this is ezyangs code
22:36:47 <pastorn> i just refactored and put the "let {" in for getting the variable indentation to look better
22:36:49 <ddarius> {- figure out where the .cabal file is -} and the other big one
22:40:36 <pastorn> ddarius: hmm... you mean something like this? http://codepad.org/1VYUIqYY
22:43:07 <ddarius> pastorn: No.  I mean stick the local functions into a where clause, parameterize as necessary, and then rewrite the body in the four or five lines it will then be.
22:43:27 <pastorn> ezyang: ^^^^^
22:45:00 <ddarius> I.e. apply an "Extract to local function" refactoring twice (or so)
22:45:35 <ezyang> ddarius: duly noted.
22:46:20 <ezyang> more hacking in the morning!
23:03:42 <JoeyA> Just wondering, what kind of applications would Haskell _not_ be good for?
23:03:54 <Fallen_Demon> Things that need randomness
23:04:25 <ddarius> JoeyA: Currently, anything that needs hard real-time guarantees.  It's also not very good for things that need specific memory layouts.
23:04:53 <pikhq> JoeyA: Things where bizarre low level tricks with pointers are justified, things where hard real-time guarantees are needed, and when you would prefer assembly.
23:04:56 <ddarius> JoeyA: However, in both those cases you could use Haskell as a language to generate code that is suitable for those domains.
23:05:47 <pikhq> Basically, if C or assembly are going to be your only realistic choices.
23:06:36 <ddarius> pastorn: I'd probably write something more like this: http://codepad.org/vTwCE1ms
23:06:53 <Fallen_Demon> pikhq, I refuse to believe you couldn't use Ada wherever you could use C
23:07:24 <pikhq> Fallen_Demon: Write the following in Ada: goto *foo;
23:07:41 <pastorn> ezyang: ^^^^
23:07:41 <pikhq> (where void*foo)
23:07:54 <pastorn> ddarius: heh, nice of you to refactor :)
23:08:28 <Fallen_Demon> pikhq, goto can die in a hole :P
23:08:51 <ddarius> Fallen_Demon: Unless you are making a threaded code interpreter.
23:08:53 <pikhq> Fallen_Demon: What, that's *computed* goto.
23:09:27 <pikhq> Y'know, the unarguably legitimate use of goto (for certain not-absolutely-bonkers uses).
23:10:58 <JoeyA> If JavaScript had goto (and it could jump out of scope), then it would support first-class continuations.
23:12:41 <JoeyA> function call_cc(f) {var ret = f(function k(v){ret = v; goto lbl;}); lbl: return ret;} // Something like this
23:12:59 <RandPaul> I have a question
23:13:04 <pastorn> shoot1
23:13:06 <pastorn> !
23:13:09 <RandPaul> is Haskell a linux distro?
23:13:13 <Fallen_Demon> -_-
23:13:17 <pastorn> heh
23:13:19 <pastorn> no
23:13:24 <pastorn> it's a programming language
23:13:25 <Fallen_Demon> Must...not....troll
23:13:35 <RandPaul> so it is a linux programming language?
23:13:48 <Fallen_Demon> It can be compiled on any platform
23:13:56 <pastorn> RandPaul: it's not specific to any platform
23:14:03 <JoeyA> no, you need a C for linux distros
23:14:16 <JoeyA> (jk)
23:14:19 <Fallen_Demon> Doesn't matter whether it's Windows, *NIX or Mac
23:15:40 <pastorn> RandPaul: how did you end up in here?
23:15:52 <RandPaul> just kind of wandered
23:15:59 <RandPaul> I have the business idea of making MexiSoft
23:16:01 <copumpkin> haiti=mierda?
23:16:01 <JoeyA> hehe
23:16:04 <RandPaul> just a cheap rebranding of
23:16:06 <RandPaul> Ubuntu
23:16:08 --- mode: ChanServ set +o copumpkin
23:16:10 <RandPaul> but not mention to customers
23:16:12 <RandPaul> that it is linux
23:16:17 <copumpkin> RandPaul: do you have a relevant question?
23:16:18 <RandPaul> say it is its own antivirus
23:16:30 <RandPaul> and have it preconfigured with
23:16:31 <copumpkin> I'd try ##linux
23:16:32 <RandPaul> amsn
23:16:37 <JoeyA> RandPaul: Take it as a warning that copumpkin raised his/her operator status.
23:16:57 <RandPaul> ok
23:16:59 <pikhq> I should note that this person is using the name of a someone infamous American politician.
23:16:59 <kmc> it's funny because RandPaul is from mexico
23:17:02 <JoeyA> It's like someone lifting their giant boot
23:17:05 <pikhq> s/someone/somewhat/
23:17:11 <RandPaul> I love Rand Paul
23:17:12 <copumpkin> lol
23:17:16 <RandPaul> i wish we had one here
23:17:22 <copumpkin> RandPaul: anyway, you're welcome to talk about stuff in #haskell-blah
23:17:33 <RandPaul> ok
23:17:35 <copumpkin> but in here we like to talk about programming haskell and obscure mathematics :)
23:18:41 --- mode: ChanServ set -o copumpkin
23:19:24 <pastorn> copumpkin: op isn't fun anymore?
23:19:47 <copumpkin> no need to keep :P
23:20:13 <copumpkin> (it)
23:20:20 <pastorn> > it
23:20:21 <lambdabot>   Not in scope: `it'
23:20:24 <pastorn> boooo
23:20:35 <pastorn> @slap lambdabot
23:20:35 * lambdabot smashes a lamp on lambdabot's head
23:20:45 <pastorn> @botsnack
23:20:45 <lambdabot> :)
23:20:56 <JoeyA> Let n,k be an abelian monoidic subgroup of the cartesian product of the catamorphism of polymorphic categories.  For all n applied to k, is it a homomorphism?
23:21:03 <JoeyA> That's what a lot of the stuff I read here looks like to me :P
23:21:20 * Pseudonym actually tried to work out if the question was meaningful or not
23:21:29 <copumpkin> I stopped at monoidic
23:21:58 <pastorn> JoeyA: those questions should actually go to #haskell-in-depth
23:22:41 <pastorn> what's this? "Factorising folds for faster functions"
23:22:46 <pastorn> anyone read it? is it good?
23:23:12 <pastorn> (it's high on reddit right now)
23:24:06 <BMeph> pastorn: I liked it. :)
23:26:04 <BMeph> I've called it "Worker/wrapper gone Wild", myself - still alliterative, and slightly more suggestive of the subject matter. :)
23:26:21 <BMeph> Meant *I'd've
23:26:28 <JoeyA> Does/will/could Haskell implement algebraic solving capabilities?  e.g. let x^2 + 2*x + 1 = 0 in ...
23:27:00 <JoeyA> Now, if I understand correctly, that problem in general is undecidable, correct?
23:27:07 <pastorn> JoeyA: you could encode that yourself...
23:27:12 <kmc> JoeyA, over integers, yes
23:27:20 <kmc> JoeyA, over an algebraically complete field like the complex numbers, it's easy
23:27:41 <pastorn> data Exp = EF Float | EMul Exp Exp | ETo Exp Exp | EAdd Exp Exp | EVar String
23:27:41 <kmc> it's doubtful it'd ever be a core feature of Haskell
23:27:44 <pastorn> etc....
23:27:52 <kmc> however you can make embedded languages to do it
23:28:56 <JoeyA> Well, the idea of using arbitrary patterns could be an incredibly powerful way to specify programs, I suppose
23:28:56 --- mode: ChanServ set +o copumpkin
23:29:02 <pastorn> JoeyA: if you can encode your expression in the Exp type above (with som extra stuff) you can probably make a solver
23:29:04 --- kick: RandPaul was kicked by copumpkin (we don't want your kind in here)
23:29:09 --- mode: ChanServ set -o copumpkin
23:29:25 <pastorn> copumpkin: wut? what did he do?
23:29:34 <copumpkin> he's being a racist asshole in #haskell-blah
23:29:53 <JoeyA> though support code would be needed (perhaps in the form of libraries) to solve varying cases
23:30:00 <copumpkin> and has no interest in haskell, of course
23:30:10 <pastorn> of course
23:30:16 * pastorn nods agreeingly
23:31:04 <JoeyA> Here's a less math-y example:  length xs = 5 -- xs is now a list of length 5 (we don't know the elements yet)
23:31:25 <Pseudonym> @seen xerox
23:31:25 <lambdabot> Unknown command, try @list
23:31:28 <pastorn> JoeyA: there are infinitely many solutions to that
23:31:56 <JoeyA> not if you trim it down with more definitions :-)
23:31:56 <pastorn> (unless you fix xs to be a list of certain kinds of elements)
23:32:13 <copumpkin> xerox: awake? :)
23:32:20 <JoeyA> (xs !! (n+1)) - (xs !! n) = 1
23:32:20 <copumpkin> @get-shapr
23:32:20 <lambdabot> shapr!!
23:32:24 <JoeyA> head xs = 0
23:32:28 <JoeyA> now we know what xs is
23:32:31 <Pseudonym> Also Philippa and SyntaxPolice.
23:32:31 <pastorn> JoeyA: you should use that Exp type i wrote and try to solve something :)
23:32:44 <Pseudonym> Really should have more #haskell-blah ops.
23:34:20 <JoeyA> But a cool concept arising out of arbitrary pattern matching is that you can invoke functionality of libraries without even mentioning them.
23:34:30 <JoeyA> In other words, you have this super-terse explanation of what you want
23:35:04 <JoeyA> And some module contains algorithms that can be used to solve the constraints.
23:35:48 <JoeyA> And the application does not explicitly mention the algorithms at all (except for importing the right modules)
23:35:56 <JoeyA> Is there a name for that concept?
23:37:19 <pastorn> SAT solving?
23:38:53 <JoeyA> What I'm talking about is (unless I'm mistaken) harder in general, but the hardness is nixed by having enough algorithms to span the problems people encounter.
23:39:16 <JoeyA> If a piece is missing, the coder will need to learn how to write it.
23:39:45 <pastorn> JoeyA: i'm completely lost...
23:39:48 <JoeyA> Then that piece, if proven correct, could be merged into the larger set of algorithms (I'll call it the Borg)
23:41:22 <roconnor> is ghc's heap profiler easy to use?
23:42:01 <JoeyA> Suppose we said, in an application:  x*x*x = 27
23:42:11 <roconnor> will it help debug my strange memory problem where shrinking my priority queue makes it run out of memory?
23:42:14 <JoeyA> The compiler, without help, wouldn't immediately know what to do with it.
23:42:25 * JoeyA is talking about something different, sorry
23:42:31 <pastorn> JoeyA: i don't think the compiler is going to do this
23:42:34 <pastorn> at least not ghc
23:42:42 <pastorn> JoeyA: you shoud look into using mathematica
23:42:47 <pastorn> which is pretty awesome
23:43:01 * roconnor wonders if prolog would know what to do with that :)
23:43:12 <pastorn> also there's wolframalpha, which is basically mathematica + loads of statistical data
23:44:14 <JoeyA> So if an application said x*x*x = 27, we might have a formula that says (x*x*x = y) = (x = cuberoot y) or something.
23:45:28 <pastorn> JoeyA: what exactly are you driving at here? or are you just trolling?
23:46:01 <JoeyA> I'm driving at an idea, and I wonder if it has a name.
23:46:11 <pastorn> equation solving?
23:46:18 <pastorn> look into prolog
23:46:23 <pastorn> and mathematica
23:46:31 <pastorn> in mathematica you can do AWESOME stuff
23:47:25 <pastorn> i don't remember the exact syntax, but it's something like this: Integrate[x^3 + sqrt(x^2/(e^x)), x, 1, 10 ]
23:47:46 <pastorn> that will integrate over that equation, in regards to variable x, from 1 to 10
23:48:09 <JoeyA> Well, part of what I'm getting at is a hypothetical development strategy where a collection of algorithms can be written, proved correct, and exist not by name, but by spanning problem spaces.
23:48:41 <pastorn> it sounds like you want prolog...
23:48:44 <JoeyA> meaning you don't even have to know about the libraries, you just give a problem and hope a solution already exists
23:48:56 <JoeyA> if not, the compiler will identify it, and you solve it.
23:49:08 <JoeyA> Can prolog do that?
23:49:13 <pastorn> what if it's unsolvable
23:49:15 <pastorn> ?
23:49:25 <pastorn> (x / 0) == 3
23:50:00 <pastorn> JoeyA: let's go to #haskell-blah
23:50:06 <JoeyA> an algorithm or such can indicate unsolvable cases.
23:51:06 <Twey> Have fun writing that algorithm ;)
23:51:24 <kmc> "I like to compare iteratees to the video game character Kirby, who changes his state depending on what he consumes. Iteratees are kind of like that." -- snap framework API tutorial
23:51:33 <Twey> Hehe
23:51:39 <kmc> that's nonsense
23:51:42 <kmc> obviously iteratees are burritos
23:51:45 <Twey> Oh good, the site is back
23:52:56 <pastorn> haha
23:53:03 <pastorn> kmc: obviously
23:56:47 <Pseudonym> Iteratees are like burritos.
23:56:48 <Twey> Ooh Twey likey Snap
23:57:52 <eevar> the snap benchmarks are bogus, tho. I'd like to see it compared to Compojure or Node.js, not the slowest kids on the block
