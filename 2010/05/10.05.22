00:03:12 <glguy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25636#a25636
00:04:28 <glguy> ripped that out of some other code i have, but that's the idea of not needing to know you support IPv6
00:04:28 <juhp_> code.h.o seems to be down?
00:04:43 <copumpkin> just for a change :)
00:04:57 <juhp_> copumpkin: hehe
00:04:58 * glguy was able to ssh into code.h.o
00:05:09 <juhp_> well http :)
00:05:13 <copumpkin> yeah, it's the httpd that stops responding I think
00:05:17 <copumpkin> people can always ssh into it
00:05:22 <juhp_> ok
00:06:15 <juhp_> suppose it is one way to access the public repos ;)
00:06:39 <glguy> There is almost nothing running on that computer
00:06:44 <glguy> certainly nothing that listens on :80
00:09:06 <juhp_> glguy: you mean it is a different host?
00:10:36 <glguy> I just mean that the webserver isn't running at this point in time
00:10:44 <juhp_> ah nod
00:11:13 <glguy> from the looks of /var/log/apache2/access_log, it usually has one :)
00:15:37 <juhp_> wonder if there is someone around who can restart it
00:19:04 <juhp_> yay rsync saves the day again ;o)
00:21:15 <gcollins> glguy: thanks, will save your snippet and keep it in mind
00:23:21 <glguy> gcollins: instead of peeking inside the SockAddr constructors you can use "getNameInfo"
00:23:54 <gcollins> good, because apparently some platforms don't support ipv6 at all and you have to use an #ifdef or template haskell to pattern match
00:24:21 <yashton> i'm trying to install the hackage module 'time' but I keep getting this error: <command line>: cannot satisfy -package Cabal-1.8.0.2:
00:24:21 <yashton>     Cabal-1.8.0.2-a7cb9536dae40bb8d1ebb7fda099f46a is unusable due to missing or recursive dependencies:
00:24:21 <yashton>       process-1.0.1.2-d10eb9528cbd95f3032e472adaaecc29
00:24:21 <yashton>     (use -v for more information)
00:24:23 <glguy> and if you bind on the IPv6 wildcard  ::   you'll support ipv4 and ipv6 on all systems except the ones that went out of their way to disable it
00:24:30 <yashton> i do indeed have process installed
00:24:47 <yashton> cabal list "process" shows it as installed
00:24:53 <yashton> what do i need to do?
00:24:55 <glguy> For example, Linux has the sysctl net.ipv6.bindv6only
00:24:58 <glguy> which is 0 by default
00:25:18 <glguy> otherwise IPv4 connections to that socket will show up as   ::ffff:A.B.C.D
00:25:25 <koala_man> nice
00:25:49 <glguy> and you can do IPv4 and 6 from a single socket
00:26:12 <koala_man> is that linux specific or some kind of standard practice?
00:26:22 <glguy> the sysctl is linux specific
00:26:25 <glguy> it is standard practice
00:26:27 <glguy> OS X does it too
00:26:52 * glguy is connected to an IPv6 Freenode server atm
00:26:55 <gcollins> :)
00:27:05 <gcollins> i know who to ask if i try to implement this and run into problems
00:29:28 <Saizan> yashton: can you paste your "ghc-pkg list" to a pastebin?
00:29:40 <yashton> where's pastebin at?
00:29:47 <Saizan> pastebin.com
00:29:54 <yashton> alright, gimme a sec
00:31:04 * glguy raged a little bit just this afternoon when he found the bit of code in openssh that explicitly disables this feature of IPv6 sockets
00:31:15 <copumpkin> ew
00:31:28 <yashton> http://pastebin.com/1Kgy8vvY
00:32:09 <yashton> i'm running ubuntu 10.04 with a repository install of ghc 6.12
00:32:43 <glguy> Fortunately the network library doesn't even bother exposing that possibility
00:33:08 <Saizan> yashton: you've the same version of process installed both in the user and the global db, that's bad since it confuses both ghc-pkg and cabal, you should run "ghc-pkg unregister --user process" to get rid of the user one
00:33:12 <gcollins> good night guys -- i'm off to bed
00:33:51 <yashton> Saizan: i'll try that, thanks
00:33:51 <copumpkin> g'night!
00:34:22 <Saizan> iirc there's a Cabal FAQ with more details
00:35:22 <yashton> Saizan: I'm getting an error message
00:35:25 <yashton> ghc-pkg: unregistering process would break the following packages: hslogger-1.0.10 (use --force to override)
00:35:43 <yashton> adding --force gives the same error
00:36:13 <glguy> You’ll have to unregister all of the things that depend on this package you shouldn’t have installed :(
00:36:30 <Saizan> how come --force doesn't override?
00:36:49 <yashton> ah, i added --force after 'process' instead of before
00:37:01 <yashton> but i think i will have to remove the packages
00:37:08 <glguy> Well, even if you don't “have” to; it is still a good idea.
00:37:13 <yashton> if i wanted to install them globally instead of locally what do i do instead?
00:37:30 <Saizan> installing them globally doesn't sound like a good idea.
00:37:40 <yashton> i just typed 'cabal install foo'
00:39:01 <Saizan> user packages can use global ones as deps
00:39:33 <yashton> so why would it even bother adding them for user if they exist globally?
00:39:42 <Saizan> you should investigate why cabal ends up reinstalling process when you'll reinstall the packages that will break, you can use --dry-run -v to get more info
00:40:15 <Saizan> it probably decided it wanted process built against a different version of its deps
00:42:45 <Saizan> i.e. filepath and directory
00:43:14 <yashton> i'm removing the ones I installed now
00:43:36 <yashton> then i'll start over and see what happens
00:45:11 <yashton> is there a difference between ghc-syb and syb?
00:45:53 <Saizan> yes
00:46:01 <yashton> alright
00:47:12 <fhobia> i tried to use getClockTime and noticed that its considered "oldtime" ...the "oldtime" docs says to use the new time library, but it doesn't say what the new time library is
00:47:29 <fhobia> is it just "time"? because that depends on "old-locale" ...not sure...if that is the right one?
00:47:44 <Saizan> that's the new one
00:47:50 <fhobia> all right, cool
00:49:08 * glguy lols… old-locale
00:49:31 <fhobia> we're going to have old-time and older-time soon...
00:49:33 <fhobia> lol
00:49:53 <glguy> maybe they’ll just move old-locale to older-locale
00:49:57 <glguy> and not change anything else
00:50:02 <yashton> maybe an 'old-timer' too ;-)
00:50:44 <yashton> "when I was your age we had to write our monads by hand, up hill, both ways in the snow"
00:51:04 <Axman6> ah man, install snap was a good idea, i can see all these other awesome libraries being installed at the same time
00:52:34 <alexsuraci> dang, snap's docs are really nicely done. (whole site, actually.)
00:53:13 <yashton> the package I'm trying to install says "There is no available version of ghc that satisfies >=6.10 && <6.12", which is probably due to me running 6.12
00:53:22 <yashton> can i just have it ignore this?
00:57:49 <fhobia> new time needs new examples
01:03:37 <Axman6> gcollins: are you still around? (and responsible for snap?)
01:04:02 <copumpkin> he went to sleep
01:04:14 <Axman6> :(
01:05:44 <bitstream0101> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25637 -- is it reasonable?
01:05:51 <bitstream0101> Trying to only expose the handle and not have the caller worry about closing it.
01:07:34 <ivanm> bitstream0101: looks about right
01:07:42 <ivanm> on a quick skim anyway
01:07:47 <bitstream0101> ivanm: cool, thanks
01:08:00 <Axman6> would hClose throw an exception if the handle is already closed?
01:08:00 <ivanm> it's the right kind of approach anyway
01:08:18 <ivanm> Axman6: from memory, no
01:14:00 <ivanm> is anyone else starting to get irritated by RJ's continual "how do I do this proof?" queries on -cafe?
01:14:34 <pastorn> ivanm: maybe haskelllove under a new pseudonym?
01:14:46 <copumpkin> no, but yes
01:14:56 <yashton> everybody loves a good spammer
01:15:02 <copumpkin> as in, not haskelllove, but yes I'm getting irritated
01:15:18 * pastorn doesn't read cafe
01:15:24 <pastorn> this channel + reddit is plenty
01:15:53 <copumpkin> there are occasionally good discussions on it
01:15:54 <ivanm> pastorn: heh
01:16:17 <dark> what you folks think about osker?
01:16:29 <ivanm> pastorn: this RJ character has gotten a hold of Bird's book and is trying to teach himself FP + Haskell with it, but keeps asking how to do certain proofs, etc.
01:16:34 <ivanm> dark: what's osker?
01:16:45 <ivanm> I know of oscar the grouch... that what you mean? :p
01:16:51 <pastorn> which book?
01:17:09 <dark> an operating system written in haskell
01:17:31 <dark> derived from house (another haskell os) and based on architecture of L4 (a microkernel)
01:17:38 <ivanm> oh
01:17:41 <Axman6> huh, one of the examples given for Snap doesn't seem to work :(
01:17:46 <dark> http://en.wikipedia.org/wiki/L4_microkernel_family#Current_research_and_development
01:17:47 <pastorn> dark: CAN HAZ linky?
01:17:56 <dark> just a paper
01:18:01 <copumpkin> Axman6: there's a #snapframework btw :)
01:18:07 <Axman6> dark: i quite like NICTA's seL4 kernel
01:18:14 <dark> reading it, it's aimed at mathematical verification
01:18:17 <pastorn> oh, so they have implemented it but aren't sharing the code yet?
01:18:27 <ivanm> Axman6: someone in #gentoo-au works on seL4 IIRC
01:18:36 <dark> hmm.. not sure, i meant, i just found a paper
01:18:39 <ivanm> if you want to ask them something about it, I can probably dig up their nick
01:18:39 <dark> would like to see more
01:19:08 <ivanm> pastorn: the book is "Introduction to Functional PRogramming Using Haskell"
01:19:11 <Axman6> ivanm: cool
01:19:15 <ivanm> http://www.comlab.ox.ac.uk/publications/publication2642-abstract.html
01:19:29 <yashton> http://web2.comlab.ox.ac.uk/oucl/publications/books/functional/
01:19:50 <dark> http://programatica.cs.pdx.edu/House/
01:19:56 <ivanm> Flathead is his nick
01:19:56 <pastorn> ivanm: is that the mathy book?
01:20:07 <ivanm> pastorn: I think so (been a while since I read it)
01:20:22 <dark> they wrote some device drivers (keyboard, mouse, display, and a network card), and a network stack
01:20:38 * ivanm is tempted by O'Reilly's ebook deal
01:20:57 <ivanm> I've been thinking of getting an ereader, and this way I could get RWH on it...
01:21:02 <yashton> in my classes i'm always frustrated with my classmates' lack of math skills
01:21:02 <dark> "we were able to implement the graphics primitives in Haskell, with decent performance, and our Haskell implementation for parsing, decompressing and rending GIF images was fast enough to let us use House to present our slides at ICFP 2005."
01:21:11 <ivanm> wait, but it's the 22nd here now... >_>
01:21:30 <dark> yashton, why don't you teach them then?
01:22:03 <dark> pastorn, so, at least house has some code online (per link above)
01:22:17 <pastorn> yeah :)
01:23:30 <yashton> dark: the problem is they don't usually *want* to understand it. they don't care about math. it's all about bashing through the course.
01:23:38 <dark> on osnews a commenter says: "The argument about monolithic kernels is flawed because with a secure language (in particular: no arbitrary pointers like in C) you can pretty much eliminate the overhead of micro-kernels. Even if that is not enough we could have something like a hybrid kernel (drivers as modules loaded into kernel). That would be basically as fast as a "real" monolithic kernel, but without most of the inflexibility and complexity. "
01:23:44 <dark> yashton, ah, i know this
01:23:54 <dark> yashton, don't you have any nerd friend?
01:23:56 <ivanm> Axman6: with snap, have you heard of any of those 4 behind it before?
01:24:08 <yashton> dark: they don't particularly have much passion for programming either
01:24:17 <dark> yashton, yeah, same thing here
01:24:55 * glguy gives some examples of multiple results from getAddrInfo http://fpaste.org/RdsO/
01:24:57 <Axman6> ivanm: i haven't heard of any of those 4 :)
01:25:28 <yashton> dark: i just finished my first year at my new school after transferring. i'm afraid i haven't found many people who share my passion for the code.
01:25:49 <ivanm> Axman6: yeah; my big worry about snap from what little I've seen of it is that if none of us have heard of them and they're not active in the community, how do we know they'll hang around and keep maintaining and developing snap?
01:26:08 <Axman6> i think they have interest in using it
01:26:32 <dark> yashton, you probably should find acquaintances with graduate students then
01:26:33 <ivanm> yeah
01:26:40 <Axman6> i don't get the feeling it was developed because the community needed a decent web framework, but because they did (i could very well be wrong)
01:26:51 <dark> yashton, i mean, most people on university want just go out there and make some money
01:26:57 <Twey> ivanm: Kind of a bad time to be buying e-readers, with tablets just starting to take off…
01:26:58 <glguy> Axman6: you want the people developing it to need it
01:27:06 <Axman6> aye
01:27:12 <ivanm> Twey: Australia... we're a few years behind :s
01:27:13 <dark> the ones interested on the actual knowledge will go to masters
01:27:20 <yashton> dark: i'm thinking about it. i'd like to get into some research. none of the professors are doing anything that immediately catches my eye
01:27:21 <ivanm> Twey: also, ereaders have the advantage in battery power and readability
01:27:23 <Twey> ivanm: Heh, fair enough
01:27:33 <Twey> ivanm: Not if the hype on the Adam is to be believed
01:27:35 <ivanm> since from all I've read, ereaders are easier on the eyes
01:27:40 <ivanm> Twey: on the what?
01:27:42 * Axman6 saw a kindel for the first time yesterday, and wants it
01:27:51 <Axman6> le? meh
01:27:53 <ivanm> also, I'm amazed that we got the Kobo before the USA! :o
01:28:00 <ivanm> Axman6: where?
01:28:04 <dark> yashton, i have professors working with isabelle, a sml theorem prover, it's a lot nice
01:28:06 <Twey> ivanm: http://www.notionink.in/adamoverview.php
01:28:09 <Axman6> ivanm: the bus
01:28:10 <ivanm> Axman6: though from what I've read, the international version is crippled
01:28:31 <Axman6> hanlin make some nice ones, that are cheaper and more powerful
01:28:43 <ivanm> Axman6: right; I'm looking at the Bebook neo though
01:28:47 <Twey> It's an ultra-low–power tablet with a screen that can switch to monochrome reflective mode, like an e-book reader
01:28:57 <Twey> Has about 160 hours of battery life
01:28:57 <ivanm> the co-op bookshop sells them for $500: 6" + wacom tablet + wifi
01:29:01 <Twey> Sadly not released yet :-\
01:29:08 <ivanm> Twey: heh, there's always that
01:29:29 <ivanm> Twey: I'm wanting to get one before I go to Aushack in July so I have something to read papers on, etc. on the bus ;-)
01:29:40 <yashton> dark: that looks interesting.
01:29:42 <Twey> Ah, fair enough
01:29:43 <Axman6> Twey: damn, i want
01:29:50 <Twey> Axman6: Yeah ☹
01:30:13 <Twey> There've been some awesome demos, but they're playing silly buggers with the release date
01:30:14 <Axman6> any price yet?
01:30:20 <Axman6> bah
01:30:27 <Twey> USD$300–500, looks like
01:30:33 <ivanm> Axman6: borders has the kobo for $200
01:30:39 <ivanm> but apparently its old tech
01:30:55 <ivanm> and I don't want to buy something overseas for warranty reasons
01:31:02 <Twey> They've only said it will be cheaper than the equivalent iPad, but nothing fixed yet
01:32:18 <ivanm> Twey: so, it'll be overpriced here ;-)
01:32:29 <Twey> Haha, maybe :þ
01:32:57 <Ke> 6" is way too small for a pdf erader
01:33:00 <Ke> reader
01:33:08 <ivanm> Ke: yeah, that's going to be the main sticking point probably
01:33:23 <Ke> monochrome reflective would be awesome though
01:33:26 <ivanm> I want it to read PDFs; if it can't deal with them properly then I don't think I'll get one
01:33:46 <ivanm> doing re-flowing would be nice, but it wouldn't help for multi-column pdfs :s
01:34:09 <ivanm> apparenlty its almost readable if you hold the ereader in landscape mode...
01:35:40 <ivanm> Twey: http://forums.whirlpool.net.au/forum-replies.cfm?t=1424569&p=3#r43
01:36:34 <ivanm> Ke: thing is, to have an ereader be big enough to read pdfs comfortably, it's probably going to be too big to be convenient and too expensive :s
01:36:59 <Twey> Haha
01:37:02 <Twey> Aussie tax
01:37:07 <ivanm> yeah
01:37:10 <Ke> yup
01:37:18 <Twey> Can't you import?  Are the fees prohibitive?
01:37:19 <ivanm> every few years someone complains that windows, office, etc. are overpriced here
01:37:34 <Twey> Windows, Office, &c. are overpriced everywhere
01:37:38 <Ke> well as long as it's of a4 size, would be good enough for me
01:37:46 <ivanm> Twey: overpriced vs USA, UK, etc. prices
01:37:49 <ivanm> Twey: usually its not "legal" (you need a USA shipping address, etc. but there are companies that can do it for you)
01:38:00 <Twey> My mother paid £400 for a copy of MS Office
01:38:04 <ivanm> a fair number of people do this, but then you have warranty issues
01:38:10 <Twey> Mm
01:38:15 <yashton> *obligatory jab at proprietary software, praise for Linux and open source*
01:38:37 <ivanm> later in that thread someone bitched that they bought an ebook cheaper from the USA, but becuase they had to ship it back after it broke for the warranty most of the savings were lost :s
01:38:44 <ivanm> yashton: heh
01:38:47 <Twey> Heheh.
01:38:48 <Ke> I thought you can't get a computer without office
01:38:56 <Ke> or at least pc
01:39:10 <yashton> Office is always extra
01:39:24 <Twey> Sometimes they ship with Works or something
01:39:31 <Twey> But full MS Office usually costs extra
01:39:41 <Twey> Especially the Pro versions
01:39:45 <yashton> Microsoft wants their chunk of change from you :-)
01:39:46 <ivanm> well, some laptop resellers were talking crap here earlier this year about how new copyright laws meant they weren't allowed to sell laptops + computers without an OS
01:39:56 <ivanm> because, you know, if you don't _buy_ windows you're just going to pirate it...
01:40:01 <glguy> More like MS ”Doesn't work”. Amirite??
01:40:10 <ivanm> the relevant government minister said that that was bullshit
01:40:11 <Twey> Heh
01:40:23 <yashton> even ones that come preinstalled with linux variants haven't done very well
01:40:30 <yashton> Dell was selling machines with Ubuntu on them
01:40:36 <dark> http://singularity.codeplex.com/SourceControl/changeset/view/45126#579288 .. a singularity build file, seems to be powershell. it's mostly similar to sh, but with annoying differences. why microsoft has to make everything look almost-identical-but-incompatible? =(
01:40:39 <Ke> well anyways bundling windows is cheper for all parties involved, I hear
01:40:40 <yashton> the problem was that the machiens were substandard
01:40:45 <ivanm> yashton: not here, and IIRC they had a price premium
01:40:45 <Ke> cheaper
01:41:10 * copumpkin mumbles something about haskell
01:41:12 <Twey> PowerShell's quite different to sh
01:41:22 <ivanm> Ke: heh, I got Dell to give me an extra $100 off my laptop a few years back because I kept going on about how I didn't want windows (which I'd already downgraded to Basic to save $100), etc.
01:41:33 <ivanm> copumpkin: I WANT AN EREADER TO READ RWH!!!
01:41:36 <ivanm> close enough?
01:41:37 <ivanm> :p
01:41:40 <dark> Twey, so, if you know it, can you confirm it's powershell?
01:41:43 <copumpkin> ivanm: fine, fine
01:41:48 <ivanm> *phew*
01:41:52 <copumpkin> powershell == monad??
01:41:55 <copumpkin> zomg
01:42:31 <yashton> I bought a powerbook when I first went to college, it was required by my department. Since then I've always built my own machines from scratch and just run Linux
01:42:45 <yashton> much cheaper.
01:43:01 <ivanm> copumpkin: yeah, powershell is the official name for what microsoft used to call their monad shell
01:43:21 <ivanm> yashton: except laptops; it's usually not a good idea to try to build a laptop yourself...
01:43:36 * ivanm doesn't actually build machines himself, but shops around between computer stores to see who'll give him the best deal
01:43:43 <dark> also, http://lwn.net/Articles/352432/ do you like this people?
01:43:50 <ivanm> mainly because I'm worried about incompatible hardware, putting it together wrong, etc.
01:44:12 <dark> people are bashing garbage collector in kernel space, but all high-level research OSes does this..
01:44:24 <dark> it might be the future
01:44:26 <Twey> dark: I don't really know it
01:44:27 <yashton> ivanm: my theory is that these days, you don't really need a super high powered laptop. build your self a powerful desktop, and use a smartphone or a netbook for portable computing.
01:45:06 <ivanm> yashton: well, at the time I had a laptop to use _as_ a desktop
01:45:15 <ivanm> but yeah, my next machine will be a proper desktop
01:45:54 <yashton> the other thing is that if you dump some serious cash into a machine, it will last a lot longer.
01:46:23 <ivanm> right
01:46:59 <dark> i prefer to buy the cheapest. dual core machines are now incredible cheap, but 2 or 3 years ago it was very expensive
01:47:15 <dark> i don't think it's worth to pay a lot for something just to get it 2 or 3 years earlier
01:47:17 <yashton> there's a sweet spot in the middle of the price range where you aren't getting cheap knockoff hardware, and not buying bleeding edge overpriced stuff
01:47:30 <ivanm> right
01:47:40 <ivanm> because any higher than that and you have diminishing returns
01:47:42 <dark> but i would like to pay for quality, low-end stuff often is crappy
01:48:24 <dark> i mean, the low end should be identical to the previous high-end, but they are mean, :(
01:48:24 <ivanm> yup
01:48:38 <c_wraith> huh.  Snap was released.  Now I have even more work to do this weekend.
01:48:59 <ivanm> heh
01:49:25 <c_wraith> Now I've gotta go evaluate Snap as a framework.  *sigh*.  :)
01:52:04 <pastorn> c_wraith: what do you mean by that?
01:52:12 <pastorn> "as a framework"
01:53:31 <c_wraith> I mean from the standpoint of someone intending to use it to write applications.  I care most about how well the framework API fits with my needs.  I don't care as much about performance, from a benchmarking perspective.
01:54:03 <c_wraith> I also don't care about bugginess or stability, at the moment.
01:54:23 <fhobia> how do you explicitly fill in a generic type for a function like you can for values? like 1.0::GLfloat
01:54:34 <fhobia> ParseTime a <-- i want to tell it what a i want
01:54:37 <c_wraith> :t id :: Int -> Int
01:54:38 <lambdabot> Int -> Int
01:55:15 <fhobia> i'm calling parseTime but the compiler can't figure it out so it complains
01:55:24 <fhobia> figure out the type that is
01:55:28 <c_wraith> :t parseTime
01:55:29 <lambdabot> Not in scope: `parseTime'
01:55:36 <c_wraith> @hoogle parseTime
01:55:39 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
01:55:39 <lambdabot> Data.Time.Format class ParseTime t
01:55:55 <fhobia> yeah, trying to tell it what t to use
01:56:13 <c_wraith> ah.  you'd write something like:     parseTime :: TimeLocale -> String -> String -> Maybe XXX
01:56:57 <fhobia> hmm
01:57:08 <c_wraith> given that it's so verbose, you're probably better off specifying the type somewhere else
02:02:42 <Saizan> or just annotate the result
02:02:57 <Saizan> (parseTime foo bar baz :: Maybe Something)
02:03:29 <Saizan> and, btw, a function is a value :)
02:06:03 <fhobia> ...oooh got it
02:06:34 <fhobia> damn, this language is nuts
02:07:13 <pastorn> haha
02:07:35 <pastorn> fhobia: yes it is :D
02:07:40 <fhobia> i did parseTime defaultTimeLocale "%d-%b-%y" :: String -> Maybe UTCTime
02:07:50 <fhobia> cause its i guess one of othes partially applied functions
02:07:50 <fhobia> XD
02:08:02 <pastorn> > filterM (const [True,False]) "abc"
02:08:02 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
02:08:03 <c_wraith> fhobia: I prefer to think of it as leaving out most of the sillyness of other languages.  Though it has its own silly points.  ;)
02:08:32 <fhobia> 8)
02:09:12 <c_wraith> And yes, that's precisely a partially applied function.  I think you're getting a good idea what you're doing. :)
02:09:27 <fhobia> :)
02:32:23 * BMeph likes (old) Io's treating all functions as Cont actions
02:36:04 <RayNbow> hmm, snapframework.com is a bit broken in IE8? :p
02:36:25 <Xilon> Seems to be broken in a few browsers
02:37:16 <c_wraith> err.  how is a server broken in some browsers? <_<
02:38:02 <RayNbow> de index page hosted on snapframework.com is broken :p
02:38:09 <c_wraith> Oh.
02:38:10 <RayNbow> not the server itself ;)
02:38:16 <c_wraith> oh oh oh.
02:38:19 * c_wraith fails at reading
02:38:20 <c_wraith> :)
02:38:29 <RayNbow> seems to work in Chrome though
02:38:43 <c_wraith> yeah, web browsers suck.  a lot.
02:38:44 <poweradapter> c_wraith, propably returning headers with errors or something
02:38:45 <poweradapter> oh
02:39:47 <c_wraith> huh.  Heist is interesting.  I wonder how much I'll have to play with it to figure out how to make common patterns work.
02:40:47 <Xilon> Haddock is a bit weird in Chrome
02:41:01 <wvd> Can Learn you a Haskell be considered as a good book for people who come from OO languages, with no knowledge of functional languages/concepts?
02:41:25 <c_wraith> wvd: I think lyah is a very solid intro to the language for anyone with any programming experience.
02:41:26 <Kaidelong> wvd: It's a reasonable tutorial, really, for anyone who can get GHCi running
02:41:26 <Nola> its a good book regardless of where they came
02:41:35 <Xilon> I found it pretty good, though Real World Haskell was more to my liking
02:41:56 <Kaidelong> it's a better first look than RWH but otherwise I agree
02:41:58 <Nola> and since when does haskell not do OO?
02:41:59 <c_wraith> RWH is more of a second book.  LYAH is more of a "I'm confused by everything" intro
02:42:10 <Kaidelong> Nola: depends what you mean by OO
02:42:28 <Nola> OO like Java. Haskell does the same thing.
02:42:32 <Kaidelong> however you could implement OO in haskell, same is true for C though
02:42:38 <Xilon> Nola: Not really
02:42:45 <Nola> example?
02:42:46 <wvd> So, reading the 6 or so chapters from LYAH and then stepping over to RWH won't hurt?
02:43:00 <Xilon> Nola: Java is mutable for one...
02:43:01 <Kaidelong> Nola: no downcasting, for example
02:43:08 <Kaidelong> no reflection
02:43:25 <Kaidelong> no overloading
02:43:36 <Kaidelong> (although you get something similar with type classes)
02:43:45 <wvd> Also, writing a simple project along learning won't hurt, right?
02:43:47 <Nola> you can get something similar 50 different ways
02:43:57 <Nola> haskell does OO
02:44:03 <Xilon> Haskell is OOP the same way Go is
02:44:07 <Kaidelong> Nola: I think downcasting is pretty much the antithesis of haskell's type system
02:44:35 <xarch> hi
02:44:53 <companion_cube> \o
02:44:54 <Nola> downcasting ...    you don't need to do that
02:45:29 <Nola> people don't really downcast in C++ these days
02:45:33 <Nola> that was an old thing in the 90's
02:45:45 <Nola> I write C++ full time, I don't downcast. ever
02:46:03 <Kaidelong> Nola: Nethertheless, I would not venture to say that haskell meets people's conventional definition of OO
02:46:17 <Xilon> It's definitely not Smalltalk like
02:46:21 <Kaidelong> It's type system as it is has a lot of limitations, Don Syme went over this in a recent talk
02:46:25 <Xilon> Although you could probably get it to be
02:46:26 <Kaidelong> but there are advantages too
02:46:46 <Kaidelong> Xilon: there is an O'Haskell extension for haskell, isn't there?
02:47:01 <Xilon> Kaidelong: I did see that recently, yes
02:47:36 <Xilon> Though I'm not sure whether it's Java-style (method calling) OOP or Smalltalk (message passing) style OOP
02:50:52 <mxc> quick cabal-install question, if i have a package - package.tar.gz, whats the command to directly install it?  cabal install -u package.tar.gz or something instead of manually untarring it and running the config, build, install commands?
02:51:16 <Nola> is this not OO?
02:51:57 <Nola> class Animal a where speak :: a -> IO (); age :: a -> Int
02:52:08 <Nola> instance Animal RubberDuck where speak _ = putStrLn "quack!"; age (Rubberduck a) = a
02:52:23 <Xilon> That is polymorphism, yes
02:53:03 <Kaidelong> Nola: no not really. That's an abstract data structure with a class definition, but it doesn't have its own internal state or methods attached to it in particular
02:53:29 <Xilon> It depends on the definition of OO
02:53:49 <Nola> Kaidelong: in C++, a class doesn't have any internal state either
02:53:54 <Nola> unless you declare a static
02:54:07 <Nola> the state is only in instances of that class
02:54:26 <Kaidelong> Nola: Of course the class itself doesn't. But the objects, once instantiated, have their own internal state
02:54:31 <Nola> which, relative to haskell, the instance vs. the data syntactical in difference but not fundamentally
02:54:32 <Kaidelong> haskell does not really allow for that
02:54:44 <Kaidelong> rather
02:54:57 <Kaidelong> you have many different data values, of a particular regular form
02:55:01 <Kaidelong> but they are immutable
02:55:31 <Xilon> http://golang.org/doc/go_faq.html#Object_Oriented_Programming somewhat relevant. Go's interfaces are similar to Haskell's type classes
02:55:52 <Kaidelong> also, haskell's notion of static typing is much stricter than the notion you get with what people usually mean by Object Oriented
02:56:15 <Nola> more strict in what way
02:56:45 <Twey> There's essentially no down-casting
02:57:11 <Kaidelong> Nola: also, types are eliminated at compile time (related to the above)
02:57:33 <Nola> data State = S myStateStuff
02:57:35 <Twey> Like unsafePerformIO, there's a bit behind the scenes, but if you ever see it or use it, either you're implementing a programming language that has it or you're doing something wrong
02:57:36 <Kaidelong> in C++ and other languages people like to call OO (including Smalltalk) type information is retained at run-time and can be changed
02:58:46 <Xilon> C++ and Java have full support for meta-programming at runtime?
02:58:54 <Kaidelong> Nola: it's not neccessarily a bad thing not to be OO. Haskell was aiming to be divorced from those conventions from the beginning
02:58:57 <Kaidelong> Xilon: yes
02:58:58 <Nola> you cant change type stuff at runtime
02:59:08 <Kaidelong> Nola: downcasting involves doing that
02:59:14 <Xilon> Did not know that
02:59:20 <Nola> you can only check if an object matches a type
02:59:51 <Nola> it's read only.
02:59:58 <Kaidelong> Nola: you can look inside an object and do nasty things to its type in languages like C# and Java
03:00:04 <Kaidelong> people just generally don't
03:00:24 <Nola> in C++, the "type" is just an integer
03:00:31 <Kaidelong> In C that is true
03:00:32 <Nola> next to the vtable
03:00:51 <Kaidelong> C++ has a more complicated notion of how things work when it comes to objects
03:00:51 <Nola> you can check if it matches some ID
03:01:21 <Zao> The "type" is something you very rarely care about except when using RTTI with dynamic_cast, regular honest virtual member functions and typeid().
03:01:33 <Nola> who even uses that stuff?
03:01:35 <Nola> newbs only
03:01:36 <Zao> I do.
03:01:54 <Nola> dynamic_cast is like stuff you find in an introduction to C++ book
03:02:03 <Zao> Most features of C++ have their places, and explicitly ignoring or shunning them is a bit stupid if you want to write idiomatic code.
03:02:31 <Nola> when is rtti and dynamic cast useful.
03:02:46 <Zao> Trying to do the C-ish kind of OO in Haskell has some serious impedance mismatches.
03:03:08 <Zao> Nola: Factories, situations where regular unary dynamic dispatch is not enough.
03:03:10 <Xilon> C-ish OO?
03:03:20 <Zao> Xilon: The kind you use in C, C++, Java, C#, etc.
03:03:23 <Zao> Interface-based.
03:03:24 <pastorn> Zao: gObjects?
03:03:30 <Nola> typeid and dynamic cast has no usefulness or functionality for factories whatsoever
03:03:33 <Xilon> Ah, thought you meant OO in C specifically
03:03:43 <Zao> Nola: So you claim.
03:04:01 <Kaidelong> Wasn't haskell by design trying to get something with similar power subclassing in OO while avoiding the flaws?
03:04:09 <Nola> Zao: Example?
03:04:20 <Nola> They do nothing for a factory but make the factory more limited
03:04:28 <Nola> It's 100% negative effect
03:04:40 <Nola> you can use .clone() polymorphically on something if you want a clone of it
03:04:55 <Nola> you do not need to switch over some hard-coded RTTI list
03:04:58 <Nola> thats llamahstuff
03:05:14 <Zao> I never claimed that you should use a "hardcoded RTTI list", whatever that is.
03:05:26 <Zao> In any way, this is -blah material and you're a troll.
03:05:38 <Nola> a std::map of type_info* wrappers
03:05:59 <Nola> mapping to function pointers for create functions
03:06:35 <Nola> Great, now you can pass a type_info wrapper into the map and get a pointer to the function
03:06:37 <Nola> That does nothing for you
03:06:42 <Zao> Not to mention that the juicy bits of Boost break horribly if you enable the infernally retarded "omg-no-rtti" switches of compilers.
03:06:48 <Nola> You can just as easily use a regular integral ID
03:06:55 <Nola> without bloating the vtable of every object
03:06:57 <Zao> Especially when dealing with multi-module applications.
03:07:04 <Zao> (where by module I mean DLL/so/dylib)
03:07:39 <Nola> the rtti doesnt actually do anything
03:07:40 <Zao> Anyway, Haskell rules, death to the infidels, give pie.
03:08:04 <Nola> except something you can do with a regular integer, without it affecting every single object
03:08:12 <Nola> it has no effect / use
03:08:16 <Nola> not possible
03:08:21 * Kaidelong really would like to see a type system based on logical deduction of whether or not something is an instance of a class
03:09:13 <Kaidelong> like for example being able to tell that map will work for anything that contains an unrestricted type variable
03:09:16 <Xilon> Kaidelong: Like duck typing?
03:09:23 <Kaidelong> Xilon: yeah, but static
03:10:05 <roconnor> deriving Functor
03:10:55 <Kaidelong> roconnor: I'm talking about this all being implicit and based on logic programming approaches, IE instead of writing a class you write a bunch of rules
03:11:03 <Xilon> Kaidelong: Not sure if it's exactly like you want but Go kind of has this (static duck typing)
03:11:27 <roconnor> rules?
03:11:49 <roconnor> remember some types are instances of classes in more than one way.
03:11:56 <Xilon> But it's more about an object having specific functions being considered as implementing an interface
03:12:10 <Nola> rtti only has one single thing it does, which is give a unique ID for a type across translation units and ensure the id is unique
03:12:14 <Kaidelong> roconnor: I was thinking of it just being limited to type constructors
03:12:30 <Kaidelong> what the rules look at, I mean
03:12:34 <Kaidelong> or existing classes
03:12:55 <Zao> Nola: Implementation detail.
03:12:55 <Kaidelong> like, if you were already able to prove something was an instance of foo, you can require that before something can be an instance of bar
03:12:58 <Zao> Nola: As are vtables.
03:13:01 <Zao> Nola: And you.
03:13:18 <Nola> the unique ID part is not a implementation detail
03:13:21 <Nola> That's the user part of it
03:13:24 <roconnor> Kaidelong: I don't think I understand your proposal.
03:13:25 <Nola> What the user gets out of it
03:14:10 <Nola> if you dont use rtti, then instead you can make an Enum of  animal_dingbat, animal_bear
03:14:16 <Nola> Same thing.
03:14:16 <roconnor> a class instance is more than a proof, it depends on which functions the class is instantiated with.
03:14:21 <Nola> The rtti gives a unique id instead
03:14:25 <Kaidelong> roconnor: I'm aware of that
03:14:37 <Kaidelong> roconnor: I'm talking about an entirely different type system here
03:14:37 <Nola> At the price of touching the vtable of every object
03:15:08 <Nola> Since you may want to use the ID's for creation, but never for downcasting
03:15:12 <Kaidelong> probably something that will turn out to be intractable
03:15:16 <Nola> touching the vtable is only useful if you want to downcast
03:16:24 <Kaidelong> It would be neat though to see a language where things are implicitly given types based on deducative reasoning
03:16:35 <Kaidelong> -a
03:16:51 <Kaidelong> define something with a constructor and behaviors
03:17:05 <roconnor> Kaidelong: doesn't haskell already do this?
03:17:10 <Kaidelong> if you use it as the argument to some function, the compiler tries to prove it is a valid argument
03:17:33 <Kaidelong> roconnor: I don't think so? You still explicitly have to make things instances of classes?
03:18:17 <roconnor> Kaidelong: so when I do fmap a, you want the comiler to do what?
03:18:24 <Kaidelong> roconnor: structural typing might be somewhat related to the idea? OCaml does that. A bit simpler than what I had in mind though
03:18:43 <Kaidelong> look at the type constructor for the data type I'm working with
03:19:07 <Kaidelong> prove that it'll work with the output of a function a->b
03:19:09 <roconnor> Kaidelong: okay, It says List.
03:19:21 <Kaidelong> give it a hint that it can extract the value somehow
03:19:36 <Kaidelong> I didn't say it would be easy
03:19:49 <roconnor> what does "it'll work with the otuput of a function a -> b?
03:19:52 <roconnor> mean
03:19:58 * Kaidelong has no idea
03:20:18 * Kaidelong is not seriously proposing anything
03:21:44 <Nola> Kaidelong what kind of programs do you make
03:22:27 <Kaidelong> Nola: mostly stuff around my school work right now, which is data mining and pruning trees and tables
03:22:34 <Kaidelong> right now working on something designed to convert surveymonkey XLS dumps into something more useful
03:22:48 <Kaidelong> then try to trim the optimum rows and columns to keep the most data possible
03:23:02 <Kaidelong> without losing too much information about a particular target class
03:23:46 <Kaidelong> Nola: last term I was doing a lot of crypto stuff
03:25:38 <Kaidelong> also I program on my own time and will do anything I find remotely interesting, writing an AI that plays hunt the wumpus recently
03:25:48 <Kaidelong> from that berkeley textbook
03:26:08 <Kaidelong> (most of this I'm doing in F# but haskell and C# too)
03:31:24 <Xilon> Kaidelong: How is F#?
03:31:29 <Nola> i want to see artistic rather than scientific stuff in haskell, and not data processing, but APPS
03:31:52 <Nola> like a amazing haskell music program with a gui, or a new way of painting
03:32:02 <Kaidelong> Xilon: I like it, it's versatile and concise and very familiar to me coming from Java
03:32:16 <Kaidelong> Xilon: Don Syme is a smart guy and it shows
03:32:49 <Kaidelong> Xilon: tool support is terrible, but better than Haskell's. I tend to use it in combination with C#, calling F# code from C# for applications where better tool support helps
03:32:52 <wvd> Is there some GUI library in Haskell which uses a process per widget and not a centralized event loop like most GUI libaries do?
03:33:03 <Kaidelong> IE GUIs, unit testing, static analysis
03:33:52 <Kaidelong> the Visual Studio environment is great, and the .NET project system is nice, although I'm not sure if I like it better than Cabal
03:34:26 <wvd> I have one problem with C#/F#
03:34:31 <wvd> It's not fully crossplatform
03:34:44 <Botje> doesn't it run on mono?
03:34:48 <Kaidelong> wvd: It's pretty cross platform in practice though
03:35:01 <Kaidelong> mono isn't that good but it does a lot of apps well
03:35:03 <wvd> Botje, it does, but Mono is behind and lacks some features..
03:35:10 <Kaidelong> when I wrote distributed stuff though it didn't run on mono
03:35:17 <wvd> Kaidelong, e.g. no1 can guarantee that my Windows apps work on Mono.
03:35:27 <wvd> Such as WinForms, ..
03:35:37 <Kaidelong> wvd: winforms works amazingly well on mono
03:35:39 <Botje> Gtk# works nicely, though
03:36:02 <wvd> Kaidelong: Serious? Last time I asked in the C# channel they said Mono didn't support them yet.
03:37:08 <Kaidelong> wvd: mono doesn't, and will never, "support" it, since it's not part of .NET
03:37:16 <Kaidelong> but in practice they've implemented a lot of it
03:37:23 <Kaidelong> so a lot of winforms things will run on mono
03:38:25 <dark> mono isn't about strict .net compliance, but running real world apps, imo
03:38:56 <dark> if it means having to write microsoft non-standard extensions, then it will do it (ps: on their own platforms, they can't stop doing that o.o)
03:40:48 <Nola> zomg Mono
03:41:15 <Nola> .NET for linux and macos, just what I always wanted!!
03:41:29 <Nola> lolol
03:41:33 <Twey> Sarcasm detected.  Sarcasm detected.
03:41:45 <Twey> Please vacate the area in an orderly fashion.
03:42:23 <Kaidelong> Nola: .NET is quite nice, but so is java
03:42:27 <Twey> .NET actually isn't that bad.  If it did everything it was advertised as doing, it would be a nice boon.  The underlying tech's quite a bit different to Java's.
03:42:38 <Nola> Kaidelong: not if you're me
03:42:48 <Nola> they aren't fast enough for my apps
03:42:51 <wvd> Anyway, after reading quick up on Haskell it seems that it's really interesting. But, is it really worth it to write programs in Haskell, and how about perfomance vs languages like C, Java, Python
03:43:04 <Kaidelong> Twey: Java has really caught up and far surpassed recently, mostly in part because their underlying tech was kept simpler
03:43:24 <Kaidelong> .NET makes it easier to implement other paradigms on it, though, from what I heard
03:43:30 <Twey> Oh really?
03:43:31 <Twey> Yeah
03:43:47 <Twey> wvd: Yes
03:43:59 <Twey> Slightly slower, faster, faster, respectively
03:44:13 <Kaidelong> Java has gotten a lot faster
03:44:14 <Twey> (in general — it depends a lot on how you code, and it can be faster than C in a few cases)
03:44:27 <wvd> Well, let me ask this question: When I shouldn't use Haskell?
03:44:30 <Nola> Kaidelong: wouldnt work for my stuff
03:44:30 <Twey> (of course for things like concurrent programming it's going to be a lot faster)
03:44:37 <wvd> e.g. should I write heavy server applications in Haskell?
03:44:41 <Twey> wvd: Sure
03:44:46 <Kaidelong> wvd: shell scripting simple things I suppose? I like perl better for that
03:44:52 <Kaidelong> GUI development maybe
03:45:01 <Twey> For shell scripting we have HSH
03:45:13 <Twey> GUIs are nothing special at the moment, sadly, but we have decent bindings to GTK and other toolkits
03:45:30 <mreh> hasn;t anyone seen wxFruit
03:45:33 <Twey> The main reason not to use it is interoperability with existing code in other languages, I think
03:45:40 <Twey> mreh: Still nothing special…
03:45:40 <wvd> I heard there was a binding that used every widget used it's own eventloop and such, sounds interesting. But
03:45:47 <mreh> Twey: :0
03:46:00 <wvd> What about things such as graphics/3D drawing/UI's?
03:46:05 <Twey> Fruit is not exactly production-ready :þ
03:46:27 <mreh> Twey: meh, Yampa is far more production ready than the authors wish to let on
03:47:02 <Twey> wvd: We've got the standard bindings to OpenGL and stuff, but the Haskell community is also working on some interesting functional variations on the standard imperative theme, like Yampa and FieldTrip, which, AFAIK, are actually pretty mature now
03:47:14 <gio123> k
03:47:41 <Twey> Oh, and on the interop front, C++ is nasty, but C is easy, and we have libraries to work with COM, .NET, and Erlang
03:47:42 <mreh> I'm working on integrating randomness into Yampa right now </boast>
03:48:30 <wvd> Found it: http://www.cs.chalmers.se/Cs/Research/Functional/Fudgets/
03:48:42 <wvd> Does the community use Fudgets?
03:48:48 <Nola> the reason java or .net arent compatible with stuff I do is
03:48:50 <Kaidelong> Twey: didn't Yampa have some pretty severe theoretical problems?
03:48:50 <Twey> wvd: Also see Conal Elliot's Eros
03:49:01 <Twey> Kaidelong: I don't know: ask mreh :þ
03:49:13 <Kaidelong> for games anyway
03:49:15 <Twey> wvd: But these are experimental concepts.  We don't really use them for production code yet.
03:49:20 <wvd> Twey: "eros"?
03:49:27 <mreh> Kaidelong: see Haskelloids :)
03:49:47 <Nola> can you imagine writing a program like Cubase in java?
03:49:54 <mreh> Kaidelong: theoretically Yampa is a fudge, but pragmatically it works very well
03:50:04 <wvd> Nola: Wasn't Cubase written in C?
03:50:04 <Twey> wvd: http://lmgtfy.com/?q=haskell+eros
03:50:17 <Nola> wvd, C++
03:50:18 <mreh> the classical FRP models have problems with performance right now
03:50:49 <wvd> Oh well, I'll first start reading parts of LYAH, but so far I seem to like Haskell :P
03:50:51 <dv_> whats the difference between FRP and regular functional programming?
03:50:54 <mreh> I wish I could get Frag to work again...
03:51:08 <mreh> dv_ FRP = functional reactive programming
03:51:15 <wvd> Nola, I could Cubase written in Java - but it's really douable.
03:51:22 <dv_> yes, but the reactive part seems inherent in functional programming
03:51:32 <Kaidelong> wvd: look at Haskore
03:51:39 <Kaidelong> Not for recording
03:51:51 <Kaidelong> but if you want to do composition
03:52:05 <Kaidelong> also I prefer sonar to cubase myself =p
03:52:06 <mreh> dv_ you need a library of combinators too
03:52:14 <wvd> Kaidelong, FL Studio here ;P
03:52:15 <dv_> define combinators
03:52:25 <Kaidelong> FL Studio is based on Cubase
03:52:37 <dv-> Now there's a dv_ too. Word
03:52:39 <mreh> things you build larger programs with from smaller ones
03:52:45 <dv_> :)
03:52:49 <Nola> <wvd> Nola, I could Cubase written in Java - but it's really douable.
03:52:51 <dv_> there is this library called Adam, written by adobe
03:52:51 <Nola> no, no
03:53:02 <Nola> How is that remotely doable?
03:53:07 <wvd> What do you mean?
03:53:15 <Twey> /nick dv`
03:53:16 <Nola> it doesnt really make sense, it wouldnt work
03:53:22 <wvd> Nola, why not?
03:53:29 <dv_> it behaves similar to a spreadsheet, in that changing one value automatically triggers changes in all other values that depend on the previously modified on
03:53:30 <dv_> e
03:53:44 <Nola> because the mixing happens at 0.5milliseconds latency
03:53:52 <dv_> is FRP something similar?
03:53:54 <Nola> Java can't even collect the garbage without stopping everything
03:54:01 <wvd> Nola, true, but would Haskell be suited for it then :)?
03:54:03 <Nola> there's so many problems, it would be impossible
03:54:18 <mreh> dv_ there's no mutable state per-se
03:54:29 <dv_> neither is there one in adam
03:54:31 <Nola> wvd: Haskell can't do it either
03:54:36 <Nola> haskell also stops the world
03:54:46 <dv_> the outputs become inputs in the next call
03:54:59 <dv_> similar to the state monad
03:55:30 <mreh> it's very similar, but in Yampa, for example, state is implicit
03:56:30 <dv_> adam was conceived for describing controller logic (controller as in MVC) in a more reusable and compact declarative manner
03:56:34 <mah01> I have 100k files. Totaling about 3GB. While I read those files one by one in Haskell, after about 10k of files, ghci takes all my memory. I understand, that the lazy evaluation causes the problem. But I also tried to use samples http://users.aber.ac.uk/afc/stricthaskell.html#semiclosed -- same sh*t.
03:57:04 <dv_> but the odd thing is, it does make sense to use it as a sort-of inverted MVC, which FRP can be seen as too IIRC
03:57:08 <mah01> and I also tried using System.IO.Strict
03:57:34 <mreh> dv_ well with AFRP (Yampa is an example of this) FPR programs are first order values, so you can recombine and reuse them to your hearts content
03:57:43 <mreh> Arrowised FRP
03:58:24 <dv_> what I mean with inversion is that essentially, MVC is all about automatic synchronization due to its star-shaped topology, the model being in the center
03:59:04 <Kaidelong> Nola: couldn't you use some concurrent recording process with a system call that doesn't involve any garbage collection?
03:59:20 <Kaidelong> but which can talk back to the haskell or java program?
03:59:23 <Kaidelong> when it finishes
03:59:27 <Kaidelong> or get controlled
03:59:38 <dv_> whereas in FRP the synchronization is done implicitely by the reaction
03:59:43 <dv_> hmm, cant spell it better
03:59:57 <mreh> dv_ yes, you are only working with signals in FRP
04:00:18 <mreh> this turns out not to be such a big problem in the end
04:00:44 <dv_> yes, and the reason why MVC is used in imperative programs is that changing a value does -not- automatically propagate a change to its dependent values
04:00:47 <mreh> at least by my standards
04:01:09 <mah01> anyone regarding memory leak during file read?
04:01:27 <dv_> well, mvc is often implemented using signals/delegates
04:01:31 <Botje> mah01: can you show your code?
04:01:39 <mah01> 1 sec
04:01:58 <dv_> but frp seems to be a cleaner alternative to mvc
04:02:26 <squidsoup> hi there, would anyone happen to know why the haskell-platform mac ports package appears to be defunct?
04:02:46 <mreh> dv_ read this paper "Genuinely Functional GUIs"
04:03:02 <mah01> Botje, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25643#a25643
04:03:13 <Xilon> squidsoup: Probably because of this http://hackage.haskell.org/platform/
04:03:33 <Xilon> Unfortunately it doesn't work on Leopard and older
04:03:43 <squidsoup> http://hackage.haskell.org/platform/mac.html recommends using the haskell-platform port
04:03:53 <Botje> mah01: acc is only evaluated at the end
04:04:01 <Botje> (you should also print it instead of returning it)
04:04:12 <mah01> got it
04:04:20 <mah01> thanx, I will try
04:04:22 <squidsoup> it just doesn't appear to exist - I can downlaod the dmg however
04:04:26 <Botje> mah01: so you should insert a strictness annotation somewhere
04:04:26 <Xilon> squidsoup: It provides it as an alternative, but I'd say it's recommending the DMG
04:04:42 <Botje> mah01: easiest is probably to do test fns $! acc + ...
04:05:04 <squidsoup> no worries, I just tend to install everything from ports as a convenience.. wonder why it's acting up
04:05:11 <Botje> that will evaluate the length (and close the file afterwards) before going to the next file, i think
04:07:00 <wvd> Anyone experience with Leksah?
04:07:58 <Kaidelong> I do, but I wasn't too fond of it, ended up using vim
04:08:14 <Kaidelong> nonetheless I may be able to help
04:08:35 <squidsoup> Kaidelong: any vim plugins you find particularly helpful for haskell development?
04:08:50 <Xilon> You mean Yi plugins! *cough*
04:09:32 <Kaidelong> squidsoup: I just used the official vimball for the syntax highlightly, been using it mostly as a text editor and doing stuff the hard way. Perhaps there are people who have done better with vim who you can ask?
04:09:43 <Kaidelong> err, official is probbly a bad word
04:09:48 <Kaidelong> the one from the wiki
04:10:02 <squidsoup> right
04:11:31 <wvd> When I start Leksah on Windows it keeps saying "sh.exe doesn't work anymore" -- anyone else had this too?
04:17:50 <ivanm> wvd: probably wanting either cygwin or msys
04:18:08 <wvd> ivanm: I've installed "grep"
04:18:18 <wvd> But..
04:18:20 <ivanm> have you installed "sh"?
04:19:03 <wvd> Yeah
04:19:22 <wvd> "sh" from cmd works fine
04:19:47 <ivanm> *shrug*
04:19:51 <ivanm> what's that from? cygwin?
04:19:57 <ivanm> preflex: seen hamishmack
04:19:57 <preflex>  hamishmack was last seen on #haskell 6 days, 21 hours, 28 minutes and 32 seconds ago, saying: then you will just be able to cabal install webkit
04:20:02 <ivanm> hmmm....
04:20:34 <wvd> ivanm: It's in my System32 folder, .. probably some single sh program.
04:20:37 <wvd> Should I install cygwin?
04:20:52 <ivanm> how did you install sh?
04:21:20 <wvd> I think it was a single install, from some site.
04:21:21 <Zao> msys, preferably.
04:21:30 <wvd> It might be from "msysgit"
04:21:36 <Zao> The simple way tends to be to install "msysgit netinstall".
04:21:43 <Zao> You get a git build as a side effect :D
04:21:44 <SKK> hello
04:22:06 <SKK> anyone alive?
04:22:17 <Botje> hallo
04:22:18 <ivanm> no, we're all dead
04:22:19 <Zao> Just us cockroaches.
04:22:21 <roconnor> @type ap const const
04:22:22 <lambdabot> forall b. b -> b
04:22:27 <SKK> :"(
04:22:28 <Zao> We and Hugs survived.
04:22:30 <ivanm> roconnor: :o
04:22:36 <ivanm> > (ap const const) 2
04:22:37 <lambdabot>   2
04:22:46 <ivanm> @src ap
04:22:46 <lambdabot> ap = liftM2 id
04:22:50 <ivanm> oh, right
04:23:00 <SKK> Does haskell support pattern matching on records?
04:23:10 <ivanm> SKK:
04:23:13 <ivanm> grrr
04:23:14 <ivanm> SKK: yes!
04:23:29 <ivanm> foo Bar{ baz = [] } = ...
04:23:53 <ivanm> this works even if there are other record fields in Bar
04:24:28 <Zao> (and you can name the whole variable with @ too)
04:24:38 <SKK> hm, that's what I'm not able to do
04:24:44 <SKK> let's see
04:24:51 <Zao> foo b@(Bar { baz = [] }) or somesuch.
04:25:04 <SKK> @data Node = forall a. Node {ch::[Node], val::a, step::[Node]->a}
04:25:04 <lambdabot> Unknown command, try @list
04:25:14 <SKK> uh..
04:25:20 <ivanm> Zao: well, the b@ shouldn't be needed...
04:25:39 <ivanm> SKK: you're not creating yet another graph type are you?
04:25:48 <Zao> ivanm: That is if you want to name it, as I said.
04:25:56 <ivanm> oh, right, missed that
04:25:56 <SKK> actually i have tick [n@{ch=c,val=v,step=s}] = v+1
04:26:10 <SKK> and it says that there's a parse error on input '{'
04:26:13 <Zao> You're missing a ctor.
04:26:39 <ivanm> SKK: you need the constructor
04:26:39 <Zao> At the least at least.
04:26:53 <SKK> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25644#a25644
04:27:05 <ivanm> so tick [n@Node{ch=c, val=v, steps=s}]
04:27:20 <ivanm> there's probably better ways to do that though
04:27:49 <SKK> oh, duh.  thanks ivanm!
04:28:04 <SKK> but now it says "Illegal use of punning for field 'tick'
04:28:07 <SKK> wth does that mean?
04:28:19 <SKK> by the way, this is a graph yes
04:28:28 <SKK> why is that bad?
04:28:31 <ivanm> any particular reason you don't use a pre-existing graph library?
04:28:43 <SKK> yep... i wanna try something new
04:28:46 <ivanm> as for that error, I'm randomly going to guess the fact that you're doing the ch=c, etc.
04:28:53 <ivanm> SKK: huh?
04:29:01 <mux> stirling numbers of the second kind allow me to count the number of ways to distribute elements of a set in k non-empty disjoint subsets; is there an algorithm that would allow me to enumerate those?
04:29:09 <SKK> basically, i want to compile the graph into a network of functions which reference each other
04:29:20 <ivanm> mux: sounds a bit like a block design...
04:29:22 <SKK> so that i can execute it simultaneously
04:29:28 <mauke> last line: ...,tick}
04:29:34 <ivanm> SKK: that doesn't make any sense
04:29:48 <bremner> mux: just use the basic recursive formula
04:30:06 <mux> mmm, what recursive formula?
04:30:19 <SKK> sure it does!
04:30:47 <SKK> but noone knows what -XNamedFieldPuns is supposed to be?
04:30:52 <bremner> mux: isn't it given in the online encyclopedia of integer sequences?
04:31:21 <mux> bremner: I have a formula that allows me to count, as I said, but I don't see how to use it to enumerate
04:31:39 <mux> ivanm: I'm looking into block design as we speak, not sure yet if this is what I need
04:31:45 <ivanm> SKK: that lets you use the record names as variables without explicitly pattern matching on them
04:32:06 <ivanm> note that you then _have_ to use those field names when constructing new values, etc. IIRC
04:32:40 <ivanm> mux: to be specific, a balanced incomplete block design
04:32:56 <SKK> i see
04:32:57 <SKK> thx
04:33:19 <ivanm> mux: I think you then want one of those variables to be 1
04:33:23 <bremner> mux: see http://paste.debian.net/74351/  ; rgs stands for "restricted growth string"
04:33:42 <ivanm> since it says how many copies of each value you want, and you're wanting the sets to be disjoint
04:35:22 <mah01> Botje, thanks. Trick with "$!" worked!
04:35:57 <squidsoup> cabal is putting libraries and binaries in ~/.cabal/ .. should this be bothering me?
04:36:24 <mauke> no
04:36:31 <mauke> unless you want to change it
04:36:31 <Botje> mah01: f $! x === x `seq` f x
04:36:38 <Botje> or, "evaluate x before you go on to f x"
04:37:00 <ivanm> squidsoup: it can be wherever you want if you specify where in ~/.cabal/config
04:37:13 <ivanm> oh, and that's cabal-install doing that, not cabal :p
04:37:19 <mux> ivanm: mmm, but "k" isn't fixed in my case, I don't need a specific number of elements in the subsets
04:37:22 <ivanm> note that cabal-install defaults to user-installs rather than system installs
04:37:25 <squidsoup> thanks ivanm, it seems like an unusual default behaviour
04:37:26 <ivanm> mux: *nod*
04:37:30 <ivanm> squidsoup: why?
04:37:49 <squidsoup> typically unix apps just tend to store configuration files and scripts in ~/.foo
04:38:16 <ivanm> squidsoup: well, it _could_ go in ~/.ghc/ if you want
04:38:22 <mauke> cpan also stores downloaded archives and build directories in ~/.cpan
04:38:27 <ivanm> but technically cabal-install could work with other compilers as well
04:38:40 <ivanm> and yeah, ~/.cabal is also where the downloaded files are
04:39:22 <dhan> Hi. How can I get rid of the "command prompt" window of Haskell GUI applications for Windows? Is this determined by compile options?
04:39:54 <ivanm> dhan: that's probably how they're run... *shrug*
04:40:01 <ivanm> which apps in particular are you talking about?
04:40:21 <dhan> err... my own simple code that uses Graphics.UI.SDL
04:42:06 <ivanm> if you use a shortcut or something you can probably avoid it
04:42:57 <SKK> Does anyone know anything about HList?  Is it cool?  Is it worth learning?
04:43:03 <dhan> that's one workaround...
04:45:43 <dhan> on C, the app should tell the OS what kind of app it is, so that the OS can decide whether to create a console for it or not. choosing the entry point WinMain instead of main usually did the trick, iirc
04:46:19 <dhan> though i don't have the faintest idea how i can do the same with Haskell
04:47:59 <ivanm> SKK: you shouldn't touch it
04:48:05 <ivanm> it is full of unimaginable evil
04:48:32 <ivanm> dhan: seeing as how I 1) don't develop GUIs, 2) don't use C and 3) don't use Windows, I can't really help you with that :p
04:48:35 <mauke> http://haskell.org/gtk2hs/archives/2005/06/23/hiding-the-console-on-windows/
04:48:46 <ivanm> mauke to the rescue!
04:49:16 <dhan> thank you very much mauke, i'll give it a try right away
04:50:31 <SKK> wow, that bad huh
04:50:45 <SKK> is it fun?
04:51:21 <ivanm> why would it be fun?
04:51:31 <ivanm> it's a horrible kludge to do something that you shouldn't do in haskell
04:51:48 <SKK> sounds like fun :)
04:52:13 <SKK> but does it really do some dynamic type casting or is it a smart way to go around it?
04:52:30 <mauke> huh? it's just nested tuples
04:52:41 <mauke> (42, ("Hello", ('x', ())))
04:53:12 <SKK> what's the big deal then?
04:53:52 <mauke> sugar and typeclasses
04:54:41 <ivanm> mauke: is it?
04:54:48 <ivanm> I thought it did a forall... >_>
04:55:25 <zygoloid> i thought the big deal was that you could make lists of labelled fields for use as extensible records?
04:55:58 <dhan> mauke, it worked like a charm. thank you a lot
04:58:32 <Silvah> :t (42, ("Hello", ('x', ())))
04:58:33 <lambdabot> forall t. (Num t) => (t, ([Char], (Char, ())))
05:23:38 <dark> why can't haskell embed the Num meaning in the t part? like (Num t,  ([Char], (Char, ())))
05:23:48 <dark> instead of forall t. (Num t) => (t, ([Char], (Char, ())))
05:24:05 <dark> i.e. why can't it make the quantification implicit?
05:24:17 <mauke> do you mean (forall t. Num t => t, ...) or (exists t. Num t => t, ...)?
05:25:28 <dark> ah.. there is also an "exists" on types..?
05:25:34 <mauke> no
05:25:42 <dark> so there is no ambiguity
05:25:48 <mauke> what
05:25:52 <dark> i mean, this could be a syntax sugar
05:25:53 <mauke> ghc doesn't support 'exists'
05:26:09 <mauke> but you still need to decide which meaning you want
05:26:40 <dark> why? is there such a thing like existential quantification on haskell types?
05:27:19 <mauke> yes
05:28:05 <dark> ah, ok..
05:28:10 <dark> o.O
05:28:18 <dark> (i will hopefully grasp it someday)
05:28:46 <mauke> well, what did you want your code to do?
05:30:55 <dark> nothing, just a random question upon seeing this, <lambdabot> forall t. (Num t) => (t, ([Char], (Char, ())))
05:31:15 <dark> it seems to me that proper pretty printing (with a lot of syntax sugar and aliasing) is critical to functional programming
05:31:19 <Cale> dark: There's no ambiguity in that case
05:31:31 <dark> no i mean, this forall seems a quite invasive
05:31:35 <Cale> oh
05:31:43 <dark> does this scale when someone haves a lot of things to quantify?
05:31:59 <Cale> Yeah, the explicit forall scales to more bizarre situations better.
05:32:01 <dark> haves? ahn..
05:32:18 <Cale> For example, if you want a function which requires its parameter to be a polymorphic function
05:32:23 <dark> have, i think..
05:32:26 <mauke> has
05:32:35 <dark> has, but, i asked with does
05:32:40 <Cale> foo :: (forall a. [a] -> Int) -> (Int, Int)
05:32:46 <dark> hm
05:32:50 <Cale> foo f = (f [1,2,3], f "hello")
05:33:03 <Cale> Then you can apply foo to 'length' for example
05:33:17 <dark> but why don't haskell use ml-style alpha, beta..? i mean, 'a 'b
05:33:29 <Cale> Meh, that's just a stylistic thing
05:33:35 <mauke> 'does' applies to 'scale', 'someone ... has' is a new thing
05:33:38 <dark> indeed
05:33:46 <Cale> We use names starting with a lowercase letter for type variables
05:33:47 <mauke> dark: a b is shorter than 'a 'b
05:33:48 <dark> mauke, ah
05:33:49 <mauke> so why bother?
05:33:56 <Cale> and names starting with an uppercase letter for type constructors
05:34:07 <Cale> and this applies at the value level too:
05:34:07 <dark> mauke, not sure actually
05:34:20 <mauke> (+) :: (Num a) => a -> a -> a
05:34:28 <dark> no, no forall there, why?
05:34:30 <Cale> names starting with a lowercase letter are ordinary variables and names of defined things
05:34:40 <mauke> dark: top-level foralls are optional
05:34:42 <Cale> names starting with an uppercase letter are data constructors
05:34:47 <mauke> also, 'forall' is not Haskell 98
05:34:52 <dark> ahh...
05:34:57 <mauke> :t (+)
05:34:57 <lambdabot> forall a. (Num a) => a -> a -> a
05:35:01 <mauke> lambdabot always prints them
05:35:06 <dark> hmm, haskell 98 has no forall/exists?
05:35:10 <Cale> right
05:35:10 <mauke> right
05:35:22 <dark> so forall was introduced in order to have this other weird quantifier?
05:35:25 <Cale> Haskell 98 always implicitly sticks all the foralls at the top level of each type signature
05:35:33 <dark> seems ok
05:35:39 <dark> that's what ml seems to do too
05:35:49 <Cale> :t runST
05:35:49 <lambdabot> forall a. (forall s. ST s a) -> a
05:36:33 <Kaidelong> what's the difference between Data.Array and Data.Vector?
05:36:36 <Cale> This clever type for runST is essentially all that is needed to ensure that STRefs (mutable references for the ST monad) are only used inside the call to runST in which they were created.
05:36:45 <dark> i understand this better as 'a 's ST -> 'a, but as a matter of fact, people in ml would like to switch to ST 's 'a -> 'a (not sure why it is better)
05:36:50 <Cale> Kaidelong: Data.Vector is newer and has less fancy indexing.
05:36:59 <Cale> Kaidelong: but more aggressive fusion
05:37:04 <dark> 'a 's no hmm it would be.. ('a, 's) ST -> 'a
05:37:08 <Kaidelong> cale: so vectors have to be flat, but are more efficient?
05:37:42 <Kaidelong> err, not flat
05:37:48 <Kaidelong> one-dimensional is what I meant
05:37:55 <Cale> yeah
05:38:11 <Cale> Well, potentially more efficient, anyway
05:38:41 <djahandarie> Are there any cases where it performs worse?
05:39:17 <Cale> I don't know of any, but I'm not speaking on any basis of experience. It's supposed to be better.
05:39:37 <Cale> I've never used Data.Vector myself, except to show some people how to do things using it.
05:40:09 <Kaidelong> hmm, how good is haskell at discovering when things can be done in place?
05:40:33 <Kaidelong> like optomizing unfolds feeding into folds
05:40:53 <Kaidelong> where the intermediate values never need to be shown to the outside world and can be overwritten immediately
05:40:53 <Cale> Kaidelong: Well, 'in-place', no, it doesn't do that.
05:41:12 <Cale> But various libraries have rewrite rules to fuse operations together
05:41:45 <Kaidelong> so how would I set something up to use stack allocated or register allocated mutable data?
05:42:08 <Cale> The garbage collector is generally extremely good at picking up lots of short-lived data.
05:42:28 <Cale> I don't know, use the FFI and a C program?
05:42:29 <Kaidelong> it'd still be better for the garbage collector to fire less often, though
05:42:38 <Cale> Or a fragment of assembly?
05:42:43 <Kaidelong> haskell has no stack allocated mutable variables?
05:42:53 <Silvah> No.
05:42:54 <Cale> What does 'stack allocated' mean?
05:42:57 <Cale> ;)
05:43:19 <Cale> The evaluator doesn't work like an evaluator for a strict language at all.
05:43:51 <Kaidelong> Cale: there is no facility to make a chunk of code make in place mutations if you can show that it's pure?
05:44:00 <Kaidelong> so long as it finishes
05:44:19 <Saizan> fusion already means that the garbage collector doesn't have to work, where it applies
05:44:24 <Cale> Generally, GHC won't perform such a transformation.
05:44:43 <pao> Hi all! I'm using an association list as a map like structure... is that correct to use lenght xs `seq` xs to force the update? (I'm using filter to update the values)
05:45:06 <Cale> Kaidelong: You not only need purity, you need linearity to be able to do something like that.
05:45:44 <Kaidelong> Cale: yes, haskell provides IO and ST though, where ordering does matter
05:46:03 <dark> Cale, what do you mean by linearity?
05:46:09 <Kaidelong> Cale: It strikes me as a good idea to be able to "escape" to a lower level of abstraction if the programmer needs it
05:46:19 <Cale> dark: I mean that the variable in question is only used in one place.
05:46:25 <Kaidelong> oh
05:46:35 <Kaidelong> Cale: that'd be the idea won't it?
05:46:50 <Kaidelong> it'll stick to that small chunk of code that changes it and will never be seen outside
05:47:02 <Kaidelong> to the pure part of the program nothing can happen in place
05:47:21 <Kaidelong> but in that black box there is an in-place update
05:48:11 <dark> Cale, if someones does SSA, this will always be true, right?
05:49:23 <Cale> dark: SSA means that each variable is *assigned* once
05:49:29 <Cale> not that it's *used* once :)
05:49:59 <Cale> SSA places no restrictions on how many times the value of any given variable is used.
05:50:20 <dark> hm o.o but after the "last" use, one can write in place
05:50:25 <Cale> Well, yes.
05:50:27 <roconnor> mmm, linear types
05:50:40 <dark> is linear types related to this?o.o
05:50:42 <Cale> So, I suppose linearity is a stronger condition than you *really* need
05:50:53 <roconnor> linear types would allow you to ensure one use
05:50:54 <dark> i heard about them, but i think i didn't paid attention
05:51:01 <dark> hmm
05:51:02 <roconnor> and exactly one use
05:51:39 <Kaidelong> Cale: wouldn't linearity stop the "in place" thing and defeat the purpose?
05:51:44 <Saizan> uniqueness is the property we want, i think
05:52:26 <Cale> Kaidelong: The idea is that after the value is consumed, you can be certain that you're done with it, and that memory is available for re-use.
05:53:05 <Kaidelong> Cale: but won't the garbage collector still fire and halt the program? or does the function free the memory immediately after it the data is out of scope?
05:54:03 <Kaidelong> like the using directive in C#
05:54:22 <Cale> Kaidelong: Well, you could relieve the garbage collector of responsibility for managing the memory for a variable of that sort.
05:55:02 <Kaidelong> Cale: has there been any attempt to make some kind of declarative specification of an imperative algorithm using something like arrows to represent a state machine?
05:55:31 <Kaidelong> just curious
05:55:34 <Cale> hmm
05:55:58 <Cale> Here's what I do whenever I come across an imperative algorithm which uses local mutable variables to compute a pure result:
05:56:01 <Kaidelong> that could be one way to address the complaints of imperative programmers on space efficiency
05:56:30 <Cale> Take each step in the imperative program and turn it into a function, and each local mutable variable, and turn it into a function parameter
05:57:04 <Cale> and then examine the control flow of the imperative algorithm, and just have the functions call each other in a mutually recursive way to represent that control flow
05:57:16 <Kaidelong> cale: won't GHC by default keep composing the function calls on the stack? but that's a state machine
05:57:59 <Kaidelong> I don't think you'll actually get in-place updates like that though, will you?
05:58:04 <Cale> The stack will never grow very much usually, because each function is going to immediately call another, often without pattern matching on any large expression.
05:58:17 * cdsmithus decides to slap anyone that uses the word "goodness" in documentation.
05:58:18 <Cale> You won't get in-place updates, but it doesn't matter.
05:58:32 <Cale> cdsmithus: ?
05:58:50 <Cale> cdsmithus: What about 'badness'? ;)
05:58:55 <cdsmithus> I'm just noticing that it means "This is trendy, and it likely has advantages here, but I am not going to bother telling you what they are"
05:59:03 <Kaidelong> Yuri Gurevich's criticism of functional languages was pointing out that functional programmers can't tell him how to write an algorithm that does an in-place update
05:59:21 <Cale> cdsmithus: Oh, I was thinking of its use as a technical term in various special cases
05:59:22 <Kaidelong> And he said that if he told his colleagues the general response (it doesn't matter) they'd be unconvinced
05:59:54 <Silvah> My criticism of imperative languages was pointing out that imperative programmers can't tell me how to write an algorithm that doesn't an in-place update.
06:00:00 <Cale> Kaidelong: Well, okay, there are cases where perhaps it matters, and you can use ST for those. But they are few and far between.
06:00:07 <Kaidelong> Silvah: it's about efficiency
06:00:35 <Kaidelong> doing in place updates are efficient at a fundamental level, particularly if you can avoid IO when doing it
06:00:45 <lyndon> Hi, I keep getting the message "cabal: Couldn't read cabal file "./hellage" when I run cabal list.
06:00:50 <lyndon> How do I fix this?
06:01:09 <cdsmithus> Kaidelong: Or, if not ST, then something like zipper or the equivalent for other data structures.
06:01:10 <Cale> Kaidelong: The problem with updating memory in-place is that the conditions under which it's okay to do so are difficult to decide on in a truly automatic way.
06:01:15 <Kaidelong> Cale: ST can do it? I thought ST could give the appearance but GHC would not actually do anything in place
06:01:25 <dark> are linear types a way for doing algorithms known to perform poor with FP, but that are okay if you have some mutability?
06:01:29 <Cale> Kaidelong: No, ST really gives you pure access to memory.
06:01:34 <Kaidelong> huh
06:01:37 <Kaidelong> ok then
06:01:46 <Cale> Kaidelong: It's essentially just a restricted IO monad.
06:01:51 <Silvah> It's State what gives the appearance but does not actually do anything in place.
06:02:01 <Silvah> ST is really in place.
06:02:06 <dolio> dark: Not necessarily.
06:02:13 <dark> i suppose haskell might 'win' mainstream by pushing those things (or at least influence a lot the 'next big thing')
06:02:32 <Cale> Mutation is dead anyway
06:02:34 <dark> dolio, but if the optimization can be performed, a sufficiently smart compiler will do this, right?
06:02:47 <Kaidelong> I agree that I mostly do not care about these things
06:02:48 <Cale> Mutation makes sense as a way of doing things when you have one processor.
06:02:59 <dark> hmm.. o.o
06:02:59 <dolio> dark: In general, they give you very strict guarantees about when it's okay to deallocate memory.
06:03:01 <Kaidelong> But there are monk-like types who want to extract every bit of performance possible
06:03:13 <Cale> But it's an extremely questionable practice on multiprocessors.
06:03:21 <Kaidelong> so it's nice to have some mechanism to lower the level of abstraction for a moment
06:03:34 <Silvah> Hehe, Kaidelong, are you talking about me? ;)
06:03:46 <Cale> Kaidelong: Those people shouldn't use Haskell to write programs directly. They should use Haskell to write special-purpose compilers.
06:03:59 <dark> Cale, i was reading a bit on bitC. it claimed that it could perform a lot of real timemultimedia processing that pure FP just couldn't
06:04:02 <dolio> dark: That can be used for mutable update (if you have a function that accepts a linear Foo and returns a linear Foo), but they're more general than that.
06:04:04 <Kaidelong> Cale: in situations where you have to work sequentially anyway (IE a non-commutative fold) you may as well update things immediately to wasting memory?
06:04:17 <Kaidelong> avoid
06:04:23 <dark> dolio, hm, o.o
06:04:55 <dark> dolio, it's ok to deallocate when you evaluate it, right?
06:05:08 <Kaidelong> Cale: I don't really buy that, it's nice to be able to say "lower my level of abstraction" a bit in a high level language, I do remember using inline IL a few times
06:05:29 <dolio> dark: If you have an algorithm that uses only values with linear types, it doesn't need to be garbage collected. Everything can be deallocated immediately when it's consumed.
06:05:48 <dark> Kaidelong, if you have various processors and want to do something in-place with a shared memory, you need locks
06:05:54 <dolio> That's the idea, anyway.
06:06:05 <Kaidelong> dark: but if you can't do it in parallel anyway, that doesn't matter
06:06:07 <dark> Kaidelong, and then you have the problem of cache coherency too
06:06:12 <dark> hm
06:06:16 <cdsmithus> dark: Basically, linear types guarantee that once a value is used, no one else is holding onto it.  That means you don't need to keep it around for any reason, so you can in-place update, or allocate it in temporary storage that will be discarded later, or whatever.
06:06:24 <dark> dolio, uh. @.@
06:06:54 <dark> i was seeing this haskell os, House, and its spinoff I forgot the name
06:06:57 <dark> osk..something
06:07:02 <Cale> Kaidelong: Basically, you're trading maintainability and your own sanity for a constant factor improvement in performance.
06:07:05 <dark> it might profit from linear types
06:07:07 <Kaidelong> dark: House
06:07:18 <Kaidelong> Cale: sure, but some people will want that tradeoff
06:07:23 <dark> osker
06:07:27 <Cale> Kaidelong: It's a tradeoff which is far less often appropriate than many would tell you :)
06:07:32 <dolio> dark: You can use weaker guarantees for mutable update, though, like Clean's uniqueness types.
06:07:32 <cdsmithus> Cale: Sometimes that's a reasonable trade-off.  Sanity is overrated.
06:07:46 <Kaidelong> Cale: if you tell them "use C" then they make a very, very big tradeoff for everything
06:07:58 <Kaidelong> if you say "make this part imperative" then it's a smaller tradeoff
06:08:09 <Cale> Well, sure, that's what ST is for.
06:08:18 <dolio> Uniqueness types track when you duplicate a reference to something. If you haven't yet duplicated a reference, it's safe to mutably update.
06:08:40 <Nola> show me the programs you guys wrote
06:08:41 <Silvah> I've never seen sane programmer, so this tradeoff is completely artificial.
06:08:44 <Nola> screenshots pls
06:08:57 <bremner> Nola: sign my NDA
06:08:59 <dolio> But uniqueness types don't force the use of resources, so you have to run a garbage collector (because resources may never be 'consumed' as they are with linear types).
06:09:11 <Nola> bremner: I'm not being comical
06:09:32 <bremner> Nola: you are not be intensionally comical, perhaps
06:09:47 <Nola> Anyways, that's my reply to the last conversation
06:10:04 <Nola> haskell programmers inherently don't create programs
06:10:09 <stroan> hah
06:10:22 <Nola> you laugh cause you sense the truth in my statement
06:10:59 <Cale> Nola: http://hackage.haskell.org/packages/archive/pkg-list.html
06:11:45 <Nola> looking under music (my interest)
06:11:45 <cdsmithus> bremner: What would it mean to be extensionally comical, but not intensionally comical?
06:11:59 <Nola> library, library, library, abstract thing, library, back-end, library, interface
06:12:07 <Nola> lolgasm
06:12:20 <Nola> this is exactly what im talking about
06:12:47 <mapreduce> Nola: Perhaps go to Google Images and search for Haskell Program
06:12:58 <bremner> actually, I don't write long programs in Haskell, so at least in my case the barb lands. But the short programs I write in haskell, I care about correctness a lot.
06:13:02 <Cale> Nola: Some of those libraries are intended to be used directly to create music
06:13:27 <Cale> Nola: In particular, Haskore is a tool which lets you represent music directly as code, and manipulate it with programs.
06:14:18 <dark> Cale, wow, googling
06:14:44 <dark> i would like to do something with algorithmic music ._.
06:14:50 <dark> maybe with cellular automata ._.
06:14:51 <Nola> Cale, that's not that cool. People do that on every language
06:14:54 <Nola> LISPmusic
06:14:56 <Nola> Pythonmusic
06:14:57 <Nola> JMusic
06:15:04 <Nola> it's a long list of them
06:15:06 <mauke> Nola: so?
06:15:06 <dark> .-.
06:15:13 <Nola> mauke: Real program
06:15:21 <mauke> Nola: what
06:15:41 <dark> Nola, it's cool, sicp has a fractal as an exercise, i found it cool and inspiring
06:16:00 <Nola> It's cool for wanking
06:16:06 <dark> could be something music related why not
06:16:14 <Nola> algorithmic guys
06:16:22 <Cale> Nola: How is that not a collection of real programs?
06:16:31 <dark> looking at dictionary for wanking
06:16:36 <mauke> haha
06:16:37 <Cale> A library is a bunch of programs
06:16:49 <Cale> Which you can use to do various things :)
06:17:00 <Nola> Cale, I'll show a real program
06:17:07 <mauke> Nola: why?
06:17:17 <Cale> Nola: You mean a program with a friendly GUI?
06:17:29 <dark> i'm playing with some real programs, they are fun
06:17:45 <dark> (looking at autoconf is mostly like looking at a matrix screen)
06:17:53 <dark> (i think i've said that already here)
06:18:15 <Cale> Nola: If you're a programmer, one would expect you to appreciate the fact that a library is just as good as a separately executable binary in many cases.
06:18:16 <Nola> http://img185.imageshack.us/img185/6497/nolaquence.png
06:18:51 <bremner> \o/ gui
06:18:53 <Cale> It's a program whose user interface consists of code.
06:18:57 <mauke> what's that, a disassembler?
06:19:02 <mapreduce> Wow, it's like OctaMED SoundStudio for the Amiga.
06:19:19 <dark> the real programs i'm playing with are glibc, gcc, binutils..
06:19:23 <dark> mauke, looks music related
06:19:33 <dark> octave, ..
06:19:47 <dark> play notes, and the general subject here
06:21:42 <nlogax> a real program is a program with messy gui? how about http://leksah.org/screenshots.html then? :) (no offense to leksah devs)
06:21:48 <Cale> Look at what your program is displaying. It's a bunch of code for describing music. The biggest difference between what your program has, and a library for describing music, is a real programming language that can be used to eliminate repetitive tasks :)
06:22:24 <Cale> (It may not be missing that anyway, but I think you get what I'm trying to say)
06:22:37 <mapreduce> He might have dal segno al coda
06:22:37 <Kaidelong> Nola: http://img413.imageshack.us/img413/2494/fornola.jpg
06:23:03 <Nola> Cale: I know you think that's true and I can understand why you think it's true
06:23:04 <dark> Cale, so true. biologists that works with dna processing often have to do repetitive tasks in a gui programs.. (when they can afford, they hire slaves for doing this in perl)
06:23:07 <Nola> It's not.
06:23:20 <Nola> music is rhythmic
06:23:21 <dark> at least it is what i see here
06:23:32 <Nola> Text does not work for multiple voices
06:23:33 <Cale> Nola: Rhythm is algorithmic
06:23:45 <Nola> cause the lines are single lines
06:23:51 <nlogax> algorhythms?
06:24:20 <Kaidelong> nola: had to run over and everything to get that up =p
06:24:21 <Cale> Nola: There are at least two ways to compose any two pieces of music: sequentially, and in parallel
06:24:43 <dark> Nola, maybe you don't know the right programming language for describing rhythms and melodies in a straightforward way? note that programming languages aren't restricted to text space
06:25:21 * mauke opens paint to code some piet
06:25:25 <Cale> Traditional music notation is essentially a very limited 0th order programming language for describing music.
06:26:11 <dark> i guess there are ways for describing general properties of a musical piece
06:26:16 <Cale> (with a handful of idiomatic control structures)
06:26:17 <Nola> Rhythm doesn't work in text except for separate polyphonic parts
06:26:28 <dark> (i am thinking about those things even since i was introduced to a guy named fourier)
06:26:55 <Nola> doing counterpoint
06:27:46 <Kaidelong> oops
06:28:05 <Kaidelong> I guess that's still scientific and numerical stuff, the other thing I was about to post was about reduction potentials
06:28:27 <dark> Nola, there are attempts on programming with, hmm.. images.. or, whatever, there are room for improvement to the state of art
06:28:29 <Cale> Nola: You might be interested in the stuff that Alex McLean has been doing
06:28:34 * Kaidelong realizes he hasn't really written much code that isn't scientific or numerical
06:29:07 <Kaidelong> sorry
06:29:45 <Nola> Cale
06:30:07 <Nola> It's not possible to express this in a meaningful way and I don't want to sound overly anger or judgemental
06:30:24 <Nola> the text algorthmic guys don't make real music
06:30:48 <Nola> with chords and beautiful harmonies
06:31:14 <Nola> That's not to say it's impossible, but so far No person has done that
06:31:27 <ivanm> what are we talking about here? data representations for music?
06:31:30 <mauke> except for JSB Sebastian Bach
06:31:38 <dark> Nola, but what about new kinds of music? that doesn't exist yet. (with cellular automata, for example)
06:31:41 * ivanm points out lilypond if it hasn't been introduced into this discussion already
06:31:50 <ivanm> or are you talking about _generating_ music?
06:31:52 <Kaidelong> dark: I tried that!
06:31:54 <Kaidelong> by hand
06:31:57 <Nola> dark: oh god
06:32:02 <Nola> go on Max/MSP
06:32:03 <Kaidelong> it didn't sound too good
06:32:10 <Nola> there's 1000 of those cellular automata guys
06:32:11 <dark> Nola, what?
06:32:12 <Kaidelong> too repetitive
06:32:19 <dark> hm hah
06:32:21 <Nola> They all make pussy music
06:32:27 <Nola> Its the wankiest stuff
06:32:28 <dark> @.2
06:32:28 <lambdabot> Not enough arguments to @.
06:32:28 <Cale> Nola: I don't see any particular reason why.
06:32:30 <Nola> Not real music
06:32:51 <Nola> Cale: Cause the interface is a kind of instrument
06:32:55 <ClaudiusMaximus> i used a continuous cellular automata reaction diffusion thing for wave terrain synthesis, made some fun noises
06:33:08 <dark> Nola, but, what if someone could make it work?
06:33:16 <stroan> ClaudiusMaximus: that sounds fun. write it up anywhere?
06:33:18 <Cale> It's not hard to express chord structure algorithmically.
06:33:21 <dark> ClaudiusMaximus, interesting
06:33:22 <Nola> dark, I tried to make it work
06:33:32 <dark> Nola, hm
06:33:53 <ClaudiusMaximus> stroan: http://claudiusmaximus.goto10.org/cm/2010-05-21_rdex_live_at_opennight.html
06:34:14 <dark> Nola, http://whatismusic.info/ , do you know this book?
06:34:22 <stroan> ClaudiusMaximus: cheers
06:34:30 <ClaudiusMaximus> no technical write-up really (just output and source code..), though i probably should at some point
06:34:43 <Cale> Basically, however you think about the music that you're writing, you should be able to come up with a decent way of encoding it using combinators.
06:35:17 <dark> Cale, it would maybe harder than to express using traditional means
06:35:33 <Cale> dark: Surely not by more than a small constant factor.
06:35:36 <dark> the key would be to make a medium of expression that is in any sense better
06:35:58 <Cale> Unless by 'traditional means' you mean playing an instrument directly :)
06:36:00 <dark> Cale, no, i mean, a system that is worse in all possible ways isn't worth a try
06:36:24 <dark> hm, no, traditional means = what is being used right now by the one we are considering
06:36:24 <Cale> dark: Right, but real music has structure.
06:36:29 <Nola> "Octave translation invariance is the result of splitting the representation of pitch into a precise value modulo octaves and an imprecise absolute value. This split enables the more efficient representation and processing of pitch values, particularly when one pitch value must be "subtracted" from another to calculate interval size.
06:36:33 <Nola> from that web page, dark
06:36:37 <Nola> that's not what music is about to me.
06:36:53 <dark> Nola, he says that music is about stimulating the brain the right way
06:37:10 <dark> Nola, that is, music is an anthropomorphic concept by itself
06:37:27 <Nola> Cale:  re:   be able to come up with a decent way of encoding it using combinators.
06:37:31 <dark> in other words: good music is music that feels good
06:37:52 <dark> and then he build a theory based on the latest discoveries on the brain sound processing
06:37:53 <Nola> it's not just about the ability to encode
06:37:59 <dark> not mainstream, but worth a reading
06:38:08 <Nola> it's the live mutation of the data and the way that you control the editing
06:38:14 <Cale> Nola: Well, it's about getting the idea in your head into a machine
06:38:46 <Nola> selecting a range and shifting it underneath, nudging it, slicing it and rotating it behind somee parts, swapping the edges around, dragging, stamping, stamping, stamping, transposing the inner voices
06:38:50 <Nola> That's the process which makes it come out
06:38:54 <ClaudiusMaximus> i think i wrote my best music with trackers - but still i have the same process - write a bit, listen back, imagine what should come next, write it, repeat...
06:38:56 <Nola> The "encoding" is lacking the process
06:39:12 <dark> Nola, in this paragraph, he tried to push a corollary of his thesis: that our perception of musical notes are based on the way our brain process audio input, and nothing more
06:39:17 <Cale> Nola: So encode those operations as functions :)
06:39:21 <Nola> I could of course, write music using that process mentioned then later encode it into your combinators
06:39:34 <{newbie}_> ok so I installed sme packages with cabal but I can't find an uninstall command on cabal's help
06:39:38 <Nola> Cale: No,
06:39:43 <Nola> you dont encode them as functions
06:39:56 <Nola> They are organic
06:40:01 <Saizan> {newbie}_: that's because there isn't one
06:40:20 <Nola> It's like saying "paint a portrait of a beautiful lady, and encode the brush strokes as functions"
06:40:24 <dark> organic: yeah, good music is pretty much an ergonomic matter
06:40:34 <dark> not necessarily a mathematical beauty
06:41:07 <Saizan> Nola: no, that would be appropriate if you were playing a instrument with functions
06:41:08 <dark> you *can* encode mathematically, but it is meant to please human beings, and in doing that it is adapted to fit our strangeness
06:41:19 <Nola> the transformational functional stuff is higher level
06:41:23 <Nola> I *do that*
06:41:30 <Nola> but it's not the inner-nitty-gritty brushwork
06:41:42 <Nola> It's the forms of the patterns, being changed in key
06:41:52 <Nola> Aliased and instanced, mutated for a specific reason
06:41:55 <dark> the obvious way of doing music with a computer is having a program that evaluates what is good music. then, you do some genetic algorithms on it
06:42:06 <dark> that's the main point of that page Nola
06:42:22 <Cale> dark: I think you're talking about something that's different from what Nola is looking for though
06:42:26 <dark> that if someone find out this algorithm (maybe trying to describe the brain on a computer?), he will make wonderful music
06:42:35 <dark> Cale, dunno what Nola is looking :)
06:42:48 <soupdragon> brain on a computer would be cool
06:42:59 <Cale> dark: Nola is talking about ways to compose music, not to have a computer compose music. :)
06:43:03 <{newbie}_> Saizan: so how do I delete packages? Old school rm?
06:43:04 <soupdragon> probabl need faster/bigger hardware first though
06:43:05 <dark> soupdragon, it's already done in some cases
06:43:08 <soupdragon> no way
06:43:16 <Zao> From the looks of it, everything but Haskell :D
06:43:27 <dark> simulations doesn't need to map the reality 1:1
06:43:37 <Kaidelong> dark: they practically do
06:43:44 <Saizan> {newbie}_: first you "ghc-pkg unregister" them, then rm yeah
06:43:46 <dark> there's the neutrinos after all
06:43:46 <Kaidelong> dark: IBM's recent claims were debunked
06:43:59 <dark> they need to capture some high-level structures
06:44:38 <Kaidelong> dark: it turns out the little details about brain chemistry were more important than the guys who made claims of simulating brains claimed
06:44:42 <Cale> Nola: The way I've seen people do this stuff is they tend to have some source code which describes the piece of music that they are working on, and they have a process which sits in the background playing whatever version of that music was last committed to.
06:44:47 <dark> Cale, Hmmm.. well, I was addressing a separate concern :P Nola was dismissing the site, I was trying to defend it
06:45:03 <dark> Kaidelong, yeah
06:45:06 <Cale> Nola: and they make changes to the program, interactively committing changes to the program which describes the music
06:45:07 <Nola> Cale: LiveCoding
06:45:10 <dark> Kaidelong, that's why it's going to be imprecise
06:45:11 <Cale> Nola: right
06:45:35 <dark> Nola, what's the program you were using?:
06:45:45 <Nola> for livecoding?
06:45:50 <geheimdienst> iirc, ibm did some work in that area, one runaway idiot told the media "omg we simulated a cat brain!", which got a lot of coverage. then his ibm colleagues told him to shut up with the sensational crap because it's damaging their credibility
06:46:00 <Cale> Nola: Though, that implies a bit of a process which is perhaps more transformative than the one we want.
06:46:05 <geheimdienst> something like that
06:46:32 <soupdragon> geheimdienst: yeah that story was almost as bad as all the newspapers suddenly turning religous about this synthetic biology stuff
06:46:48 <Nola> the livecoding is a kind of brain filter. It does cause stuff to come out differently. It will make you write something you wouldn't think of with an organic process.
06:46:50 <Cale> Nola: One could instead imagine having a bit more control over the background process which plays the music, instead telling it to play a particular interval in time from the described piece as you work on it.
06:46:58 <Nola> That aspect is alright
06:47:24 <Nola> but the main Working Aspect is that you think of music and it appears
06:47:44 <Nola> the instrumental interface I mentioned before, is best for that
06:48:25 <Cale> Well, the program you were using more or less presented the music as a bunch of text anyway.
06:48:31 <Nola> that's my app
06:48:58 <dark> Nola, in that screenshot
06:49:00 <Nola> yes
06:49:09 <Nola> Joint project, me and my partner wrote it. 120Kloc
06:49:17 <Cale> So, I don't see what the difference is between that text, and the kind of program text I'm talking about, except that what I'm talking about gives you a bit more ability to extend the language you're working with.
06:49:25 <Nola> c++
06:49:41 <Silvah> What?
06:49:57 <dark> Nola, has a webpage?
06:50:08 <dark> soupdragon, there is news about synthetic cells.. pretty religious issue
06:50:08 <Zao> Can has research paper?
06:50:21 <dark> Zao, ^^
06:50:25 <Cale> I've seen people work with tracker-style music programs, and they have various tricks that they apply by hand to the sequences of notes, which would ideally be encoded as program structure, as they're things which have to be re-adjusted if they want to change something later.
06:50:35 <soupdragon> dark, it sounds scientific to me
06:51:01 <geheimdienst> zao, there's a thread on reddit today with an "ask me anything" of one of the guys behind the synthetic cell thing
06:51:14 <dark> well, the news were more religious than scientific
06:51:22 <dark> at least ok the two blogs i read :P
06:51:24 <soupdragon> dark, yes that's what I'm upset about
06:51:31 <dark> or maybe two newspaper
06:51:39 <dark> hardly know the difference those days
06:51:40 <soupdragon> geheimdienst: link?
06:51:54 <Nola> Cale: what kind of trick did you have in mind?
06:52:05 <geheimdienst> http://www.reddit.com/r/IAmA/comments/c6kd6/i_am_one_of_the_creators_of_the_first_synthetic/
06:52:16 <soupdragon> thanks
06:52:16 <geheimdienst> link to research paper inside
06:52:18 <Zao> Oh right, that bacteria thingie.
06:52:29 <Nola> Echoing a track
06:52:30 <Cale> Nola: Things like having one voice follow another, translated in time
06:52:33 <Cale> yeah
06:52:37 <dark> brave new world
06:53:01 <Nola> Cale: That's POST
06:53:06 <Nola> it's higher level
06:53:26 <Nola> the harmonical editing of the sequences themselves requires finer grained work
06:54:47 <Cale> Nola: Sure, but there's not necessarily a good reason you should force yourself to do it only at the end. When you do it, you might find that you've introduced some harmonic effects that change the way that you perceive the original line, and you might want to go back and tweak things.
06:55:14 <Nola> The program does that.
06:55:21 <Nola> You can insert an alias of something and apply transforms to it
06:55:25 <soupdragon> Megzla?
06:55:45 <Cale> Sure, for a finite number of various transformations
06:55:45 <soupdragon> is that you! :)
06:55:51 <dark> geheimdienst, loved it, thanks
06:56:10 <Nola> but Cale, I couldn't write the parts I'm applying that transform on, in text
06:56:16 <geheimdienst> dark, you're welcome
06:56:25 <soupdragon> Nola?
06:56:29 <Cale> Nola: Isn't that essentially what you're already doing?
06:56:58 <Cale> Nola: I mean, your interface consists of a bunch of text, for the most part, with a new graphical sliders to represent fractional numbers.
06:57:03 <Cale> few*
06:57:42 <Nola> The reason is because you can edit time in a spatial way
06:57:54 <Nola> Writing code for it, Time does not align
06:58:16 <Nola> If you write two algorithmic lines, and they are on separate text lines
06:58:18 <Cale> You could force it to, in a variety of ways.
06:58:20 <Nola> And they have various functions within them
06:58:28 <Nola> Yet you are thinking harmonically
06:58:29 <dark> 'Finally, my education in microbiology pays off! I can laugh at a joke on reddit!'
06:58:45 <Nola> The text will not align the voices of the chords
06:59:10 <Cale> Nola: I can imagine a lot of ways you could manage to put everything to do with a single point in time on one line.
06:59:15 <Cale> (in code)
06:59:28 <Cale> and if all else fails, there's always quasiquotation :)
06:59:32 <Nola> heh
06:59:43 <Nola> You can put a point in time on a line
06:59:54 <Nola> But it's still in 1 dimension
06:59:57 <Cale> I mean, all the voices on one line.
07:00:03 <Nola> Yeah
07:00:09 <Cale> one line per point in time
07:00:12 <Nola> However.
07:00:14 <Cale> Just like your tracker :)
07:00:18 <Nola> You now create another point in time
07:00:19 <Nola> With all voices
07:00:32 <Nola> Yet the positions in the text of the previous voice  does not align with the next point in time's voices
07:00:38 <Nola> so you cannot see the melodic line inside of those voices
07:00:40 <Cale> You could force it to line up
07:00:45 <Nola> It requires quasiquotation
07:00:48 <Cale> Use spaces :)
07:00:54 <Nola> At which point a text editor becomes insufficient
07:01:00 <Nola> Which is what my damn thing does ...
07:01:29 <Nola> When I have tried to do this in text, you spend half the time trying to align spaces
07:01:38 <Nola> Its immensely frustrating and difficult
07:01:41 <soupdragon> Nola ping?
07:02:09 <Cale> Well, that can be helped by a number of things, but sure. I get your point. :)
07:02:40 <Nola> yes soupdragon hi
07:02:44 <Cale> I'm not necessarily trying to argue that there's no point in writing GUIs for various things, only that there are alternatives which work.
07:02:46 <soupdragon> I asked you q
07:02:48 <Nola> which is what I meant originally about  algorithmic being usable for counterpoint
07:03:25 <Nola> the stuff people make algorithmically or in livecoding has parts which aren't specifically coherent with eachother
07:03:35 <Nola> cause of the effort required
07:03:40 <Nola> so instead it becomes explorative / inventive
07:03:52 <Nola> Just doing something Else instead of making it coherent
07:04:18 <soupdragon> "I think it's frustrating that every news article I've read has the basic format of "X happened, but scientist Y considers it not that important, and group Z finds this highly unethical and dangerous.""
07:06:30 <Cale> Nola: How about this way -- you could have a language in which separates the selection of modes/scales at each point in time throughout a piece from the choice of notes from those modes by each voice.
07:06:46 <Cale> (which is what traditional music notation does)
07:07:26 <Cale> s/in//
07:07:53 <Cale> That would certainly make it easier to be coherent.
07:12:16 * hackagebot getflag 1.0 - Command-line parser.  http://hackage.haskell.org/package/getflag-1.0 (TroelsHenriksen)
07:12:22 <soupdragon> wtf
07:12:27 <soupdragon> there's already a command line parser
07:12:37 <soupdragon> oh this one is plan-9 style
07:13:22 <Cale> I was unaware that plan-9 used a different style of commandline flags.
07:13:58 <Nola> Cale: that is "restictive" harmony. You set the context for a mode up, and then use relative degrees. Say that the language allows   C ^V 7 ^V b9 I { 1 2 3 2 3 1 }
07:14:20 <Nola> a flat 9'th V chord of the V 7 chord of the key of C
07:14:38 <Nola> and the first, second, third, second, etc  degrees of that context
07:14:49 <Cale> yeah
07:16:20 <Nola> the reason it's restrictive is cause there's so often other notes which you need to go outside of the context momentarily. they are expressive ideas, impression ideas, ideas you don't even fully understand, or things you just liked the sound of, but which for the most part still fits into the context
07:16:23 <Cale> Nola: and of course, there could be a way to describe accidentals relative to whatever mode you happen to be in.
07:16:35 <Nola> so to express it it requires more symbols to make the 1 2 3 4 apply to the context
07:16:42 <Nola> and then it becomes chromatic
07:17:13 <Cale> Chromatic in the end, but described relative to a harmonic context
07:17:28 <Nola> well, Cale, i made a system for this, the program has a hierarhically nested harmonic language
07:17:34 <Nola> i will take a pic
07:17:38 <Cale> Neat :)
07:18:02 <Cale> Nola: What do you think of the notion that it would make working with music as text easier to manage? :)
07:22:14 <Nola> http://bit.ly/baHFm0
07:22:32 <Nola> the harmonic structure is on the left. The underlines on the notes show how they fit the harmonic structure
07:22:45 <Nola> Yellow is a mode-match. Green is a direct diatonic in-chord or active tone match
07:22:48 <Nola> red is chromatic/outside
07:23:37 <Cale> cool
07:23:46 <Nola> about doing it in text
07:24:18 <Nola> it still would not help you see  2 dimensions
07:24:26 <Nola> where voices align, and time aligns
07:25:52 <Cale> Well, of course, you would still need/want to split the piece into sections and bars, and to listen to parts of it in realtime or near-realtime as you updated it.
07:26:27 <Nola> ever looked at MML?
07:26:29 <Luke_> I'm having a problem with cabal where it says "failed to parse output of 'ghc-pkg dump'" for every action I take. Anyone know what the deal is?
07:26:58 <Cale> I haven't
07:27:20 <soupdragon> Mega ML?
07:27:46 <Nola> this one
07:27:46 <Nola> http://www.nullsleep.com/treasure/mck_guide/
07:28:08 <Cale> Luke_: Maybe that you have a different version of ghc than cabal thinks you do?
07:28:21 <Luke_> possibly
07:28:32 <Nola> it's a language for music which  some guys actually have made real music in
07:28:39 <soupdragon> Nola nullsleep is great!
07:28:48 <soupdragon> Nola do you make chip music now
07:28:49 <Saizan> Luke_: cabal --version ?
07:28:49 <soupdragon> ?
07:29:04 <Nola> soupdragon: sometimes
07:29:08 <soupdragon> Cooool
07:29:09 <Luke_> ghc version 6.12.1, cabal-install version 0.6.2
07:29:12 <Nola> the guys who made MML tracks amaze me though
07:29:16 <soupdragon> Nola if you put anyone online link me please
07:29:17 <Luke_> i used platform to get all this
07:29:18 <Nola> They have an ability to do this, which I don't
07:29:23 <soupdragon> yeah I really love nullsleep
07:29:35 <soupdragon> well they probably worked really hard too
07:29:49 <Saizan> Luke_: are you sure the cabal executable you're using is the one that came with the platform?
07:29:55 <Saizan> Luke_: it looks too old
07:30:02 <Luke_> cabal is trying to update it self
07:30:06 <soupdragon> nola are you megzla though??
07:30:09 <Luke_> but yeah - it came with it
07:30:19 <byorgey> Luke_: that's why, you need cabal-install 0.8 at least with ghc 6.12
07:30:27 <Nola> soupdragon: who exactly is megzla ?
07:30:32 <byorgey> 0.6.2 doesn't know how to parse the output of ghc-pkg dump, which changed in 6.12
07:30:34 <Luke_> i wonder how it got so out of date
07:30:41 <Cale> Nola: another IRC user
07:30:42 <soupdragon> Nola someone who came in here before.. another C++ fan and composer
07:30:48 <soupdragon> Nola, I guess htat's not you?? too bad
07:31:04 <Nola> well, I am Megzlna
07:31:07 <soupdragon> He was doing some amazing stuff
07:31:15 <Luke_> it looks like my ghc came from ubuntu but my cabal came from platform. I updated ubuntu which broke all this
07:31:29 <soupdragon> soupdragon you probably dont remembr talking to me I was vixey at the time
07:31:37 <soupdragon> you linked your CD it was great
07:31:37 <Luke_> what's recommended in this situation? should I try to get everything on platform or use apt for management of them packages?
07:31:53 <soupdragon> Nola* oops
07:31:53 <Nola> I do remember you vixey
07:31:55 <soupdragon> kk
07:31:59 <soupdragon> do you have a site??
07:32:03 <Cale> Luke_: I don't use Ubuntu's version of anything Haskell-related
07:32:18 <soupdragon> Nola that's cool you're at haskell I tohught you gave up :p
07:32:36 <Nola> i was mad at record syntax
07:32:36 <Saizan> Luke_: i'd  download the latest cabal-install tarball and use the bootstrap.sh script to install it, at this point
07:32:55 <soupdragon> Well I never use records
07:33:05 <Luke_> i used this to install platform: http://davidsiegel.org/haskell-platform-in-karmic-koala/
07:33:10 <Luke_> it told me to use apt for ghc etc
07:33:24 <Luke_> is there a way I can use platform to bootstrap myself off apt?
07:33:56 <Saizan> yeah, you can install ghc using the generic binary taraball on GHC's site
07:34:05 <Saizan> and then install the platform
07:34:18 <Luke_> will GHC be managed by cabal then?
07:34:28 <Saizan> no
07:34:34 <Luke_> is there a way to make that happen?
07:34:56 <Cale> GHC is never managed by cabal.
07:35:02 <Saizan> cabal isn't really a package manager anyway, e.g. there's no uninstall
07:35:34 <Luke_> it makes sense to perhaps leave ghc managed by apt and then try to manage everything else with cabal then
07:35:36 <Saizan> it only keeps track of the libraries installed because those get registered with ghc-pkg
07:36:00 <Cale> Luke_: What I tend to do is to install the generic linux binary of GHC (under /usr/local), and then grab the cabal install tarball from hackage and run the bootstrap.sh script from it
07:36:12 <Cale> Luke_: and then I use cabal to install Haskell packages as user
07:36:48 <stroan> Cale: does the bootstap.sh script grab network/parsec etc?
07:36:58 <Cale> stroan: yeah
07:37:06 <stroan> that would have saved me a LOT of time the other day :D
07:37:19 <Nola> Cale, http://bit.ly/9sS4HW
07:37:22 <Luke_> i think my plan is this: use ubuntu for ghc, use platform for all the default packages and then cabal to manage keeping them all up to date
07:37:27 <Nola> you can see some vague attempts at aligning stuff there
07:38:04 <Nola> (mml)
07:38:07 <Cale> Yeah
07:38:35 <Cale> Of course, if you work with a small enough chunk of music at a time, and you're able to listen interactively, I suspect it obviates most of the need to align things visually.
07:38:46 <Luke_> thanks guys
07:39:12 <Nola> Cale:  .... hah
07:39:29 <Nola> seems reasonable
07:39:56 <Nola> But you insert an event somewhere, and move a few things, and it has drastic implications for the other stuff which follows
07:40:19 <Nola> Now in order to make something below go back to where it should be, you have to insert a dotted triplet halved plus a quarter and an 8th
07:40:34 <Cale> Well, you need to make sure that things are set up such that stuff which is in one bar doesn't get pushed into the next bar just because you added something before it
07:40:49 <Nola> my last MML attempt involved an hour of trying to get chord degrees to match up after i made a few changes
07:41:01 <Nola> i had to insert a lot of symbols
07:41:04 <Cale> Oh, in MML, yeah, that's possible :)
07:41:27 <Cale> I guess I'm still sort of thinking of the space of all possible languages for describing music :)
07:41:40 * araujo bought RWH today
07:41:55 <mxc> araujo++
07:41:56 <Cale> You would want the language to represent time in some nicely direct way, so things couldn't get too messed up like that.
07:42:12 <araujo> mxc, :)
07:42:16 <Nola> that also seems reasonable
07:42:23 <Nola> but it breaks again
07:42:28 <mxc> the first, and probably only book with my name in print
07:42:42 <mxc> along with the 1000 or so other people who commented on the beta version
07:42:51 <Nola> You are working in Bar chunks, but now you want to take the part and shift it so it overlaps onto the bar edge of the next bar -- moving everything
07:42:55 <araujo> hehehe, yeah, I see plenty of people there
07:42:57 <Nola> but shifting every other one back
07:43:09 <Nola> Once they cross over edges, all the time becomes complex again
07:43:14 <Cale> Then you would apply a shifting transformation to the whole bar, perhaps.
07:44:04 <Cale> So, the bar is still expressed as if it started at a given time, but it's really relative to that.
07:45:03 <Cale> Or perhaps bar isn't the right word, and we should be talking about phrases and when they begin.
07:46:29 <Cale> So you have a bunch of phrases that you write, and then separately encode where in time those phrases go.
07:47:09 <araujo> mxc, Last book I read about haskell was like 5~6 years ago
07:47:23 <araujo> so I am bit excited to have a new one to read now =)
07:47:27 <Cale> (and sure, you still have the responsibility of making sure they line up and sound good together, but that's as much about actually listening to what's going on as anything.
07:47:32 <path[l]> these days they're very different. They have pictures and shit
07:47:36 <path[l]> Im j/k
07:49:10 * araujo still needs to send dons this copy so he can post it back to him with his signature though 
07:49:28 <Nola> the phrases are too static cause of the way a text editor works
07:49:35 <Nola> for instance
07:50:51 <Nola> I am trying to fix this part, I got into a modulation context and I have got to get home to the original key. I went a bit down the rabbit hole. I'm trying to figure it out
07:51:01 <Nola> the problem was that I let the bass switch with the inner voices in functionality
07:51:17 <Nola> I have to twist it back around
07:52:23 <Nola> So I take the inner voices from something, invert them with the bass, keep flipping chords around. Change the function of that melody part with what the inner voices are doing. I am pulling notes out of the bass into the melody
07:52:25 <Nola> all fast
07:52:31 <Nola> swapping, edit keys, specialized stuff
07:52:55 <Nola> in the text editor, those individual phrases you mentioned have a time context of their own
07:53:23 <Nola> If you pull degrees out of them and move them, swapping with other parts, they break and have to be re-formed
07:53:39 <Nola> sometimes it's pedal to the metal
07:53:45 <Nola> change change change change change change
07:54:26 <Cale> hmm
07:56:24 <Nola> example
07:56:31 <mreh> is this not a little off topic?
07:56:48 <Cale> mreh: Well, it started out somewhat on topic ;)
07:57:02 <mreh> I understand
07:57:35 <Cale> mreh: We're discussing possible problems with writing music directly as program code.
07:57:47 <mreh> interesting
07:57:55 <Cale> mreh: and I'm trying to understand why Nola thinks it's too difficult to work with
07:58:09 <soupdragon> Cale have you heard any of his work
07:58:12 <Cale> (and I have to admit that I've not done a lot of it myself)
07:58:26 <Cale> soupdragon: No, only seen screenshots of his programs
07:58:40 <mreh> Nola: can I see pages of what you are doing?
07:59:54 <Nola> simplest thing
08:00:02 <Nola> [ C . . . E . . . G . . . E . . . ]  ->  [ C . . F E . . A G . . C E . . E ]
08:00:20 <Nola> that kind of edit operation can be done in 1 mouse motion
08:00:31 <Nola> and 1 click
08:01:18 <Nola> If I go down to exact amount of keyboard keys required, it will be ~40. Remove from original locations, fix times, try to insert, move
08:01:26 <Nola> so take 8 hours of work
08:01:36 <mreh> :\
08:01:53 <Cale> Nola: Couldn't the mouse motion and click be encoded in some other way?
08:02:33 <Cale> (as text, for example)
08:02:41 <Nola> in 8 hours , you can do 1000 ops, or 1000 * N ops
08:02:44 <Nola> it makes all the difference
08:02:49 <Nola> Cale: that'd be a new text editor
08:03:12 <Cale> Nola: Well, I mean represent that transformation you just applied as part of the music.
08:03:23 <Cale> Give it a name
08:03:37 <Nola> those transforms may be the process of creating a melody which is purely inspirational
08:03:38 <mreh> is that a pentatonic?
08:03:46 <Nola> it may be impressionistic
08:03:56 <Nola> We dont need undo history of every change that was ever made
08:04:01 <Nola> In view
08:04:40 <Cale> Then make an editor key which evaluates an expression in the interpreter and puts the result back into the code :)
08:04:41 <Nola> The data you're looking at should have some degree of comprehensibility cause it doesnt overload you with wall of text
08:05:10 <Nola> that makes sense Cale
08:05:33 <Cale> I'm just suggesting possible ways to make this sort of thing sensible to do.
08:07:42 * Cale wonders if Wolfgang Jeltsch uses IRC.
08:08:28 <siracusa> Cale: I think he does, but not quite frequently
08:09:02 <Cale> Do you know what nick he uses?
08:09:19 <siracusa> Yes, jeltsch
08:09:28 <Cale> preflex: seen jeltsch
08:09:28 <preflex>  jeltsch was last seen on #haskell 55 days, 18 hours, 9 minutes and 51 seconds ago, saying: How can I get/reset my Hackage password?
08:09:32 <Cale> I see :)
08:11:11 <Cale> I'm interested in his records package, but it seems there are some differences between the code and the examples, and I'm not sure I want to dive into understanding the type hackery to understand what's going wrong :)
08:13:17 <Nola> the whole transformational thing can still be done on a time grid with 2d scopes and getting the benefits of the code and the editor at the same time
08:14:28 <Nola> http://bit.ly/9MbkPG
08:14:54 <Nola> http://bit.ly/bQ4REy
08:15:59 <Nola> the main concern being to write shortest possible names for functions so they dont take a lot of horizontal space
08:16:23 <Nola> and 2d scopes have a lot of weird rules
08:17:08 <Admin_> hi
08:17:11 <Admin_> lol
08:17:16 <Admin_> strange nick
08:17:24 <slawo> ok
08:17:37 <Silvah> lol
08:18:17 <slawo> so quiet
08:18:48 <Silvah> Wait a while, it's pretty unusual here...
08:21:55 <siracusa> Cale: Did you read a very recent paper to his record system? I think he wanted to publish his paper to the PPDP'10 last week.
08:22:10 <slawo> What compiler do you prefer? I'm new in Haskell, so...
08:22:14 <Cale> siracusa: I haven't read any paper about it, just saw the package on Hackage.
08:22:38 <Silvah> GHC
08:22:38 <siracusa> Ah ok
08:22:40 <Cale> I wonder how useful it would be to have an extension which would make anything starting with a single quote that was not a character constant into the sole value of a type with the same name, satisfying a bunch of instances of basic classes (Eq, Ord, Read, Show, etc.)
08:23:08 <Cale> It seems like a lot of these record-systems-as-libraries would benefit a good deal from that.
08:23:20 <Silvah> Actually, I didn't hear of anyone using something other than GHC.
08:23:29 <Cale> Oh, don't forget Bounded and Enum ;)
08:25:01 <edwardk> Cale: doesn't that muck with the usage of the same construct inside of template haskell?
08:25:06 <Cale> Well, maybe you'd still want them all to belong to some class like Jeltsch's 'Name'
08:25:15 <Cale> edwardk: Well, yeah...
08:25:32 <Cale> Stupid syntax ;)
08:25:47 <Cale> Always so hard to choose a good syntax which isn't already taken by something
08:26:10 <edwardk> clearly it should be `Something ;)
08:26:26 <Cale> Oh, that'd work.
08:27:11 <Cale> edwardk: Any news wrt the book?
08:27:40 <edwardk> cale: i'll set up a meeting when i get back from hac phi and see wats going on
08:27:44 <Cale> okay :)
08:28:12 <SamB_XP> Cale: so these types would come from a global namespace, I guess?
08:28:37 <Cale> SamB_XP: Yeah, I hadn't thought much about the namespace issues.
08:28:45 <SamB_XP> no module prefixes
08:28:47 <Cale> SamB_XP: But that would do.
08:29:01 <Guest38216> hmm - my platform and ghc packages are conflicting in ubuntu because of /var/lib/ghc-6.12.1/package.conf.d/package.cache :/
08:29:02 <SamB_XP> no packages
08:31:32 <Cale> SamB_XP: Yeah, the idea is that while they're all technically separate types, they're all in some sense one kind which would ideally be part of the Prelude or something.
08:31:49 <Cale> SamB_XP: Mostly for use as type-level labels.
08:34:27 <Cale> I would advocate something similar for use as record labels if we were adopting some specific system for row polymorphism, but it looks like the type-level programming stuff is beginning to get strong enough to express a lot of that not-so-inconveniently in a library.
08:34:43 <soupdragon> what about She?
08:36:56 <Cale> Well, She's pretty experimental. Hopefully we'll eventually have some built-in support for dependent types.
08:37:36 <soupdragon> I guess we will get numbers first
08:37:38 <Cale> But for now, the type functions stuff is making type level programming a lot more convenient.
08:37:51 <Cale> (even on its own)
08:38:08 <soupdragon> I haven't really found type functions that useful
08:38:38 <soupdragon> I was trying to do pattern match coverage with them but it was a huge mess
08:39:04 <Cale> Well, I can read the code for this records package without too much of a headache, which is pretty cool.
08:39:17 <soupdragon> it would be nice if we could just use normal functions at the type level
08:39:37 <Cale> It doesn't end up looking like something that takes a full Oleg of type hackery to do anymore.
08:39:49 <soupdragon> well by normal functions I don't really mean normal functions
08:39:55 <soupdragon> something like   f :: Integer -> *
08:40:14 <soupdragon> but right now we have to use "Integer" or program it backwards into a GADT
08:40:25 <Cale> Sure
08:40:42 <soupdragon> (which is a lot of fun...)
08:41:02 <Cale> Another option is just to, for now, put some support for Integer in by hand at the type level, which is obviously the wrong thing, but a whole lot easier.
08:41:11 <soupdragon> One thing worries me though, if haskell gets dependent types.. people might start "proving" things in haskell
08:41:23 <Cale> What would be wrong with that?
08:41:31 <soupdragon> by "proving" I mean not actually proving
08:41:48 <Cale> okay, what *do* you mean? :)
08:41:55 <soupdragon> Since there will (I imagine) not be a rigorus way to interpret such proofs
08:42:10 <Cale> We already prove things in Haskell
08:42:44 <Cale> Functional programmers are just applied logicians who spend most of their time writing proofs in an inconsistent intuitionistic logic with a rich semantics.
08:43:05 <Luke> Cale: i like that =) "rich semantics"
08:44:06 <mike-burns> Well that explains the lack of real-world Haskell apps!
08:44:29 <Cale> mike-burns: Even the real-world Haskell apps can be thought of that way!
08:44:55 * mike-burns looks to download some real-world Haskell proofs.
08:45:12 <mike-burns> Hopefully I can find a proof for rendering Web pages.
08:45:26 <Cale> You might try that new Snap thing
08:45:39 <Luke> mike-burns: whats up man - you at hac-phi?
08:45:43 <Cale> http://snapframework.com/
08:45:45 <mike-burns> Luke: Nah I wish.
08:45:46 <soupdragon> Cale - as I see it there's never going to be a time when  forall a. a  isn't inhabited, in haskell. So if we get full spectrum dependent types - we can't trust someone who says they've proved something unless we read the entire proof
08:46:04 <Luke> me neither =/
08:46:18 <Cale> soupdragon: Sure.
08:46:20 <Luke> mike-burns: let me know what you think of snap
08:46:24 <soupdragon> That's what worries me
08:46:38 <mapreduce> Don't you need to read the entire proof anyway?
08:46:48 <soupdragon> because there will be people who think they have correctness, resources or security guarantees enforced on their code
08:46:49 <Cale> soupdragon: It just means we can't *completely* trust any proof written in Haskell without reading it.
08:46:57 <soupdragon> but maybe there is just a blatant bug but they didn't realize it
08:47:00 <mike-burns> Luke: From what I've seen of it, it's still not complete enough for me to want to use it instead of Rails.
08:47:30 <Cale> soupdragon: There will be *some* correctness guarantee provided by constructing such proofs. It just won't be as strong as the usual one.
08:47:49 <Luke> mike-burns: yeah but you could help make it awesome with your experience =)
08:48:03 <mike-burns> Luke: This is true, and I do want to!
08:48:13 <soupdragon> maybe the compiler needs some checks for totality and a lack of misuse of unsafe functions
08:48:20 <soupdragon> but if we go too far this way it's not right to call it haskell
08:48:27 <mike-burns> Luke: But at this point I wish there were one Haskell Web framework instead of Yesod, Happstack, Snap, and the smaller ones.
08:48:27 <soupdragon> and nobody that knows haskell wil be able to use i teither
08:48:47 <soupdragon> I am not sure what the best thing to do is, it seems like a bit of an impasse
08:48:59 <Luke> mike-burns: yeah but maybe resurrecting happstack wasn't the way to go
08:49:16 <Nola> what is the problem
08:49:22 <Cale> gcollins: btw, the second "slide" on the Snap framework main page is messed up for me in firefox.
08:49:22 <Saizan> having a strong-normalizing subset doesn't sound like too much of a problem
08:49:28 <Luke> why have another web framework? well none is a clear winner yet
08:49:39 <soupdragon> Saizan, well that is the current situation with type families isnt it?
08:49:53 <mike-burns> Luke: Right it makes sense to make another, but at the same time it'd make sense to throw weight behind one.
08:50:08 <Luke> definitely
08:50:14 <Nola> or rather what is the problem in the least amount of words it can be expressed which isnt proprietary to haskell
08:50:16 <mike-burns> Luke: I feel like the diffrences between these Web frameworks is more of Not Invented Here than features.
08:50:35 <Luke> yeah i know what you mean
08:51:19 <Nola> conflicting names?
08:51:28 <Cale> Nola: which problem?
08:51:46 <Saizan> soupdragon: yeah, but they can surely be extended
08:52:11 <Cale> mike-burns: I don't see any harm in people working on more than one if that's what they feel comfortable doing, anyway :)
08:52:15 <soupdragon> I think haskell would be better to go the CHR way
08:52:34 <mike-burns> Cale: Oh I totally agree and that's why I feel bad every time I complain about such a thing.
08:52:36 <soupdragon> We should do constraint/logic programming in types, and functional programming in values
08:52:51 <Saizan> if they really promote algebraic datatypes to kind this summer then we can have induction :)
08:52:52 <soupdragon> I feel that is much more natural and leads to less worrisome issues
08:52:54 <mike-burns> Cale: 'Cause, like, they're either going to make a new framework, or do nothing, and I'd rather a new framework.
08:53:27 <soupdragon> natural for haskell -- of course there are other routes to take like the path Agda is going
08:53:28 <Cale> mike-burns: I would like to see some more variation between them as well though.
08:53:37 <soupdragon> but I see no reason for Haskell to become (Haskell+Agda)/2
08:54:15 <soupdragon> On the other hand, a lot of people have an aversion to logic programming
08:54:48 <wvd> Are there any things why Haskell won't be suited to write a simple compiler/interpreter in Haskell?
08:54:52 <SamB_XP> what!?!?
08:54:52 <Saizan> yeah, type families were pushed because they felt more functional than the alternative
08:54:54 <SamB_XP> why?
08:55:01 <Cale> mike-burns: There isn't enough of an attempt to abstract over what really happens communication-wise over the network.
08:55:18 <SamB_XP> wvd: that's one of my favorite things to write ;-)
08:55:27 <Saizan> though the alternative was a very crippled logic language with a weird syntax :)
08:55:45 <Cale> mike-burns: Continuation-based frameworks make a decent shot at fixing some of the issues there, but the newer frameworks don't appear to be going that way for some reason.
08:56:03 <wvd> SamB_XP: Do you have a concrete example? Would be very nice.
08:56:07 <SamB_XP> Saizan: which is, afaik, still used rather a lot?
08:56:22 <mike-burns> Cale: I'm actually pretty opposed to continuation-based frameworks. (And I worked on PLT Scheme's for a while!)
08:56:41 <Cale> mike-burns: Oh? Why is that?
08:56:46 <Saizan> SamB_XP: heh, yeah, s/was/is/
08:56:55 <mike-burns> Cale: The issue I have with them is scalability: HTTP scales extremely well because it's stateless, but the continuation-based ones are based on maintaining state.
08:57:20 <Cale> mike-burns: They're about managing the state you're inevitably going to have to manage anyway
08:57:31 <mike-burns> Cale: Plus stateless frameworks are trivial to test. Few things were easier to test than Perl CGI scripts: send some data to stdin, get some data on stdout, and verify it's right.
08:57:35 <Cale> mike-burns: Despite the stateless nature of the communication protocol
08:57:53 <mike-burns> Cale: I see your point.
08:58:01 <SamB_XP> Cale: well, I think it's nicest when you can have as little as possible
08:58:02 <Cale> There are a lot of potential bugs involved in maintaining state across those stateless communications.
08:58:13 <Saizan> soupdragon: won't logic programming for types turn Haskell in (Haskell+Coq)/2 though?
08:58:23 <soupdragon> no
08:58:25 <Saizan> soupdragon: i'm referring to Ltac
08:58:26 <Cale> and it would be nice to have a library which just took care of it for you
08:58:49 <mike-burns> Cale: Maybe the recent rash of stateless Web frameworks is compete with the existing ones (Rails, Django, etc.) so we can attract people familiar with those.
08:58:55 <SamB_XP> and continuation-passing doesn't seem like a good fit for e.g. wikis
08:59:32 <_root> hello friendz
08:59:33 <jlouis> continuation passing on the web needs some reclamation system as well, if somebody never use the continuation
08:59:35 <mike-burns> SamB_XP: That's a great point; continuation-based Web apps are typically wizards, which are bad UI and also not found often on the Web.
09:00:10 <jlouis> and we are entering a client server cycle again now, with web sockets
09:00:31 <Cale> _root: It's usually considered a bit needlessly dangerous to IRC as your root user.
09:00:46 <soupdragon> lol
09:00:57 <soupdragon> _root left the chat room. (Client Quit) <--- someone must have hacked him
09:02:33 <SamB_XP> or he realized his mistake from his nick
09:03:39 <Luke> some ubuntu package maintainer just convinced me to learn how to make debs and become an ubuntu haskell package maintainer =)
09:03:54 <mike-burns> Oh good luck!
09:03:56 <Saizan> it's contagious
09:04:10 <Luke> we'll see how that goes
09:04:24 <Luke> correct me if I'm wrong but people can just contribute to hackage whenever they want right?
09:04:33 <Saizan> yep
09:04:46 <Luke> what keeps broken code out?
09:04:51 <Luke> haskell just breaks less? =)
09:04:53 <mike-burns> Dignity.
09:05:02 <Saizan> people yelling at the maintainers
09:05:09 <Saizan> if anyone cares :)
09:05:15 <Luke> Saizan: liek you said before, cabal isn't a package maintainer so apt would be nice to have
09:05:33 <Saizan> maintainer of each package i mean
09:05:41 <Luke> yeah understood
09:06:00 * hackagebot rangemin 2.2.1 - Linear range-min algorithms.  http://hackage.haskell.org/package/rangemin-2.2.1 (LouisWasserman)
09:06:01 <Luke> ok wow that took me like 3 hours to get ready to install snap =D
09:06:06 <Luke> i really just want to make a webapp
09:06:07 <Luke> haha
09:06:44 <mike-burns> Ha oh you're becoming an Ubuntu Haskell package maintainer because the existing packages don't work?
09:06:51 <Saizan> Cale: which record package were you talking about?
09:07:20 <Luke> mike-burns: yeah... or are old/incomplete
09:07:36 <Luke> mike-burns: i think just packaging platform would be a good step
09:07:46 <mike-burns> Luke: I agree, 100%.
09:07:53 <Saizan> Luke: i think they have that sorted out on debian
09:08:01 <Luke> yeah i think i heard that too
09:08:04 <Luke> probably can just be ported
09:08:08 <mike-burns> I'm on Debian and can confirm that I have no complaints.
09:08:31 <Luke> i literally work 10-12 hour days at work though =/
09:08:35 <Luke> this will be tough =D
09:08:45 <mike-burns> See if you can do it at work, somehow.
09:08:53 <Luke> that's what i'm trying to do
09:09:07 <Luke> we use C++ but i'm trying to get us on deps/apt for that
09:09:18 <Luke> then I can do the haskell stuff on the weekends after i pass the series 7
09:09:32 <mike-burns> I'm trying to write an open source Haskell library for one of our products at work, so I can maintain it at the job.
09:09:43 <Luke> awesome
09:10:36 <Cale> Saizan: 'records'
09:11:28 <Cale> Saizan: It seems to work now if I make sure to give my records explicit types and use a polymorphic (Id a) instead of just Id as the examples suggest.
09:11:48 <Cale> I'm not sure what keeps it from working without explicit type signatures
09:12:53 <Cale> It doesn't seem to be able to guess the "style" parameter from context, and I think that's what kills it.
09:13:28 <Silvah> :t Left
09:13:29 <lambdabot> forall a b. a -> Either a b
09:14:51 <Saizan> Cale: ah, yeah, i can see that
09:15:16 <Cale> person :: (X :& Surname ::: String :& Age ::: Int :& Room ::: String) (Id a)
09:15:17 <Cale> person = X :& Surname := "Jeltsch" :& Age := 33 :& Room := "HG/2.39"
09:15:17 <Cale> extract f r = let (r', n := x) | const True [n,f] = separate r in x
09:15:17 <Cale> surname = extract Surname
09:15:40 <Cale> That at least works though.
09:15:46 <EvanR> :t (:=)
09:15:47 <lambdabot> forall a b. a -> b -> Assoc a b
09:15:50 <Saizan> with no annotation for person you get a type error?
09:15:53 <Cale> Different :=
09:16:00 <Cale> Saizan: yeah
09:16:11 <Cale> Saizan: at least, when I try 'surname person'
09:16:16 <Saizan> anyhow, it's the same problem with all these encoding, you don't get enough type inference :)
09:16:18 <rokoteko> forall means for all types?
09:16:32 <Cale> rokoteko: yeah
09:16:46 <rokoteko> ah excellent, something Ive missing this far. :)
09:16:49 <Cale> rokoteko: (or in some cases as appropriate, all type constructors)
09:17:31 <hellidunno> Hey there
09:17:47 <hellidunno> I am reading right now RWH and I have aproblem at a certain code listing inthe book
09:17:59 <hellidunno> http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html
09:18:12 <rokoteko> Cale: so forall a b c implies forall a, forall b, forall c ?
09:18:17 <hellidunno> under the subheadline "The identity parser"  there is the second code lsiting
09:18:28 <hellidunno> I haven o idea what "case runParse parser (ParseState initState 0) of
09:18:28 <hellidunno> " does
09:18:42 <Silvah> This chapter is terrible.
09:18:46 <hellidunno> yeah =/
09:18:59 <hellidunno>  runParse parser (ParseState initState 0)  <----I dont get it
09:19:27 <Cale> rokoteko: yeah
09:19:49 <Cale> hellidunno: I'll take a look
09:19:52 <hellidunno> ty
09:19:54 <Saizan> can you be more specific? i.e. you don't get why it's doing that or what it's doing at all?
09:20:15 <hellidunno> parser is of Type Parse a that wraps a function runParse
09:20:31 <hellidunno> why the hell do they return a runParse function to runParse
09:20:32 <rokoteko> Cale: is forall (a b) c valid? as in for all types of a and b, but necessarily not for c?
09:20:45 <hellidunno> I am confused
09:20:46 <hellidunno> :/
09:20:54 <Cale> rokoteko: uh... that's not valid syntax
09:21:11 <Saizan> hellidunno: runParser is the accessor that extract the wrapped function out of a "Parser a" value
09:21:41 <rokoteko> Cale: ahh. now Im starting to see why it's called forall instead of "for" :)
09:21:49 <rokoteko> Cale: thanks!
09:21:53 <Cale> hellidunno: runParse p s will run the parser p with the initial state s
09:22:06 <Saizan> hellidunno: i.e. you could define Parser like this: newtype Parse a = Parse (ParseState -> Either String (a, ParseState)); runParser (Parse f) = f
09:22:53 <Cale> rokoteko: With extensions to the type system turned on (you need at least one of them in order for the explicit foralls to be accepted), you can place the foralls in different parts of the type to require various kinds of polymorphism
09:23:17 <hellidunno> awww
09:23:18 <hellidunno> okay
09:23:23 <Cale> rokoteko: For example  (forall a. ...) -> ... would indicate a function which requires its parameter to be something polymorphic
09:23:44 <hellidunno> I thought that PArse a jsut wraps a runParse function, but this is only the accessor
09:23:45 <hellidunno> okay
09:23:46 <hellidunno> ty
09:23:54 <Cale> rokoteko: (because maybe it needs to use that parameter with different types)
09:24:44 <rokoteko> Cale: ok. :) just fyi, Im still on the beginning of my path of learning haskell. currently trying to understand types and type constructors, functors etc. pardon my silly questions :)
09:24:55 <Cale> rokoteko: Quite all right :)
09:25:27 <Silvah> Your questions are not silly...
09:25:42 <pastorn> it should say "forany" and not "forall"
09:25:49 <Cale> rokoteko: Normally if you leave the forall out, what happens is that it implicitly places one at the top-level of each type signature.
09:26:10 <Cale> (that captures all the type variables used in the signature)
09:26:48 <danharaj> Why can you write instances for monomorphic types but not polymorphic types?
09:27:27 <Cale> danharaj: Well... I suppose the reason is that there needs to be some concrete way to select which instance to use.
09:27:52 <hiptobecubic> I did it!
09:27:59 <Silvah> I guess there is an extensions which allos that.
09:28:00 <Cale> danharaj: and this is done by matching the type constructor against the available instances
09:28:14 <Silvah> allows*
09:28:24 <Cale> You can write instances for polymorphic types though.
09:28:37 <danharaj> Cale: You can?
09:28:43 <Cale> instance Ord a => Ord [a] where ...
09:28:45 * hiptobecubic coughs
09:28:51 <Cale> Like that.
09:28:57 <danharaj> Ah, that's not what I meant.
09:29:23 <Cale> Did you mean something like defining an instance for types like (forall a. ...)
09:29:24 <Silvah> What did you mean?
09:29:36 <danharaj> Cale:yes
09:30:03 <Cale> danharaj: If you want to do that, I suggest just making a wrapper type.
09:30:27 <Cale> Higher rank and impredicative polymorphism is unusual anyway.
09:30:33 <Saizan> "instance Foo (Bar a) where" is already quite like that, no? it'd get different when you nest the forall inside some other type constructor
09:30:44 <danharaj> Cale: I guess. It seems annoying to have to wrap everything, but I suppose it's for the best w.r.t. compiler implementation.
09:31:04 <Cale> danharaj: What specific instance are you trying to write?
09:31:15 <danharaj> Cale: Actually forgot, it came up last week :)
09:31:43 <Cale> danharaj: Another problem is that polytypes are weird things which tend to specialise later.
09:31:53 <fiasco_> Hi! I need some help with a parser I'm writing (http://pastebin.com/AZck9hZj). a program is composed of a composite which is '[ Exprs or Deps ] Expr' seperated by ';'
09:31:55 <dolio> Parametric higher-order abstract syntax is a use case.
09:32:10 <dolio> instance Show (forall v. Term v) where ...
09:32:20 <Cale> danharaj: It's potentially confusing to have the polytype instance apply, and then have the type specialise to something else where another, different instance would normally apply
09:32:25 <fiasco_> but no matter what I tried I cant make it to accept "[....]; expr;" just "[.....]; expr"
09:32:33 <Cale> danharaj: You want instance selection to be coherent
09:33:06 <Cale> danharaj: It's possible to switch on IncoherentInstances and write instances like that, but you can get really confusing things to happen :)
09:33:19 <dolio> There are actually a lot of instances there that apply.
09:33:25 <danharaj> I think what I was trying to do was wrap functions in an existential type.
09:33:28 <dolio> instance Eq (forall v. Term v) where ...
09:33:29 <Silvah> Haha, I was right!
09:33:29 <danharaj> And I wanted to wrap polymorphic functions.
09:33:50 <danharaj> But I had type class constraints on the arguments of the functions, but the polymorphic types didn't satisfy the constraints.
09:33:53 <fiasco_> my mistake is probably in zCompositeExpr which start at line 806
09:34:47 <danharaj> Like, let's say you have this signature: (SomeFooFun :: forall a. (Foo a) => SomeFooFun (a -> Bar)) and then you have a function Baz :: forall a. (Foo a) => (a -> Bar), you can't do (SomeFooFun Baz)
09:35:30 <dolio> Of course, PHOAS runs into other problems anyway unless you newtype it, because ImpredicativeTypes is disappearing.
09:35:57 <Cale> dolio: At least, possibly
09:36:10 <Cale> danharaj: Is SomeFooFun meant to be a constructor?
09:36:12 <dolio> Well, hopefully it'll be back eventually.
09:36:38 <Cale> danharaj: with no parameters?
09:37:22 <danharaj> It's supposed to take a function (a -> Bar)
09:37:32 <danharaj> oh
09:37:35 <danharaj> er that :: should be an =
09:37:46 <Cale> ah, okay
09:37:51 <danharaj> and there should be a data :p
09:40:12 <Cale> danharaj: Well, you have an ambiguous type
09:42:19 <danharaj> Cale: What is the ambiguity?
09:43:41 <Cale> SFF :: forall a. (Foo a) => (a -> Bar) -> SFF
09:44:28 <Cale> If you pick any particular 'a', as long as there's an instance of Foo for that type, then SFF will take a parameter of type (a -> Bar) and produce an SFF
09:44:40 <Cale> But here, Baz :: (Foo a) => a -> Bar
09:45:07 <Cale> says that for any type a we pick, Baz can be treated as a function a -> Bar
09:45:31 <Cale> So if you just write  SFF Baz,  the 'a' never gets pinned down
09:46:12 <danharaj> Cale: Ah, I see. But I know how to write a Foo instance for (forall. a (Foo a) => a) or however it is expressed.
09:46:16 <danharaj> But it won't let me =[
09:46:54 <fiasco_> anyone?
09:46:55 <Cale> But you'd still need  Baz :: (forall a. (Foo a) => a) -> Bar
09:47:09 <Cale> fiasco_: I'll have a look
09:47:38 <fiasco_> thanks.
09:48:15 <danharaj> Cale: There is a difference between those two typings of Baz?
09:49:14 <Cale> danharaj: Yeah, this Baz takes a parameter which is required to be polymorphic
09:49:34 <Cale> The other Baz takes a monomorphically typed parameter, but any monomorphic type
09:50:08 <danharaj> Cale: for this Baz, it can't be used on monomorphic types anymore?
09:50:24 <Cale> right
09:50:29 <danharaj> ah, I see.
09:51:35 <danharaj> I guess my intention was for SFF to inherit the polymorphic behavior of the first Baz.
09:52:35 <Cale> I guess your problem is that as a matter of policy, the type checker never instantiates type variables to polymorphic types
09:53:01 <Cale> Well, in part...
09:53:16 <Cale> This is kind of weird :)
09:54:02 <Cale> class Foo a
09:54:03 <Cale> data SFF where
09:54:03 <Cale>   SFF :: (forall a. (Foo a) => a -> Bar) -> SFF
09:54:03 <Cale> data Bar where
09:54:03 <Cale>   Baz :: (Foo a) => a -> Bar
09:54:07 <Cale> this works
09:54:22 <Cale> (it'll typecheck SFF Baz)
09:54:45 <danharaj> Cale: will it still typecheck monomorphic functions?
09:55:15 <Cale> It means that SFF requires a polymorphic parameter
09:55:34 <Cale> (only something with the same type as Baz will do)
09:55:52 <danharaj> ah
09:55:55 <danharaj> That's weird.
09:56:15 <danharaj> I guess I could give SFF two constructors, one for mono functions and one for poly functions?
09:56:25 <Cale> I suppose you coudl
09:56:27 <Cale> could*
09:56:40 <danharaj> Cale: and just to be sure, if I unwrap Baz from SFF Baz, I can instantiate it to work no mono types?
09:56:41 <Cale> I'm not really sure what it is that you're doing :)
09:56:41 <danharaj> on*
09:56:45 <Cale> yeah
09:56:48 <danharaj> Cale: WIZZARDRY
09:56:54 <danharaj> Ok, that's cool and weird.
09:57:24 <monochrom> = wizzard laundry
09:58:12 <geheimdienst> monochrom, are you sure about that? laundry is wet, not dry. wizzarwet?
09:58:58 <monochrom> all laundry dries eventually.
09:59:38 <monochrom> unless you are one of those "it's the process not the result that matters" lunatics
10:01:13 * geheimdienst observes how all laundry dries eventually, but not all expressions are evaluated eventually
10:01:50 <monochrom> expression is another story
10:01:56 <Saizan> what if you live in a very humid place?
10:02:11 <jmcarthur> geheimdienst: not all laundry dries. what if it's at the bottom of the ocean (assuming the ocean doesn't dry, of course)?
10:02:18 <soupdragon> what is the half life of wetness?
10:02:47 <monochrom> no laundry at the bottom of the ocean.
10:03:00 <geheimdienst> saizan, you'd have a dryer, and would dry laundry on demand. this is much like haskell, which evaluates exactly what's needed. good point, man.
10:04:14 <monochrom> note also that you make wet exactly what's needed, and that which exactly you will dry. the point still stands.
10:04:43 * geheimdienst is now applying his puny understanding of physics to the question if anything would dry in space. probably not very much.
10:05:27 <aavogt> if it's warm
10:05:35 <hiptobecubic> @src flatten
10:05:36 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:05:40 <hiptobecubic> :(
10:05:48 <Cale> @src concat
10:05:48 <lambdabot> concat = foldr (++) []
10:05:48 <aavogt> @src concat
10:05:48 <lambdabot> concat = foldr (++) []
10:05:54 <hiptobecubic> oh i see, thanks
10:06:10 <hiptobecubic> @src foldr
10:06:10 <lambdabot> foldr f z []     = z
10:06:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:06:44 <mux> > foldr f a [x,y,z]
10:06:45 <lambdabot>   f x (f y (f z a))
10:06:58 <pikhq> geheimdienst: If it's warm, then the water will still eventually evaporate.
10:07:22 <Cale> hiptobecubic: foldr abstracts over what's common to the following definitions:
10:07:24 <pikhq> Phase changes care not for your puny "vaccum"
10:07:25 <Cale> sum [] = 0
10:07:30 <Cale> sum (x:xs) = x + sum xs
10:07:35 <Cale> product [] = 1
10:07:40 <Cale> product (x:xs) = x * product xs
10:07:45 <Cale> concat [] = []
10:07:52 <Cale> concat (x:xs) = x ++ concat xs
10:07:55 <mux> length [] = 0
10:08:01 <mux> length (x:xs) = 1 + length xs
10:08:09 <Cale> and so on :)
10:08:17 <Cale> There are a lot of things which fit that pattern
10:08:18 <hiptobecubic> Cale, yeah i was trying to write this bizarre intersperse in chapter three of real world haskell... it doesn't act like normal intersperse.. it's   a -> [[a]] -> [a]
10:08:29 <mux> I felt compelled to add an example where the value of 'x' wasn't used in the function passed to foldr ;-)
10:08:33 <Cale> So we just cut out the parts that change and turn them into parameters
10:08:50 <Cale> and that's what foldr gives you
10:09:02 <Cale> :t intersperse
10:09:03 <lambdabot> forall a. a -> [a] -> [a]
10:09:10 <Cale> ah, right
10:09:18 <hiptobecubic> Cale, yes, but they are asking for a->[[a]]->[a]
10:09:22 <Cale> :t (concat .) . intersperse
10:09:23 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:09:28 <Cale> mm...
10:09:34 <mux> :t (concat .) . intercalate
10:09:36 <lambdabot> forall a. [[a]] -> [[[a]]] -> [a]
10:09:39 <mux> woops.
10:09:41 <hiptobecubic> Cale, lol. Right well. We can't all be wizards.
10:09:54 <geheimdienst> yeah, but i think drying will take much much longer than on earth. if something continually removes water vapor (wind or convection), i.e. lowers the local humidity, that is a great speedup to drying ... right?
10:10:19 <soupdragon> what the heck is a->[[a]]->[a]
10:10:37 <soupdragon> are you putting one thing between the sequences?
10:10:47 <mux> :t \x -> intersparse x . concat
10:10:48 <lambdabot> Not in scope: `intersparse'
10:10:52 <mux> :t \x -> intersperse x . concat
10:10:53 <hiptobecubic> soupdragon,  foo ',' ["bar"] = "b,a,r"
10:10:54 <lambdabot> forall a. a -> [[a]] -> [a]
10:11:00 <Cale> :t (concat .) . intersperse . (:[])
10:11:01 <lambdabot> forall a. a -> [[a]] -> [a]
10:11:02 <soupdragon> :t ? foo ',' ["bar"]
10:11:03 <lambdabot> parse error on input `?'
10:11:05 <soupdragon> :t ?foo ',' ["bar"]
10:11:07 <lambdabot> forall t. (?foo::Char -> [[Char]] -> t) => t
10:11:07 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/31353b866b161ff7
10:11:11 <Cale> need an extra robot monkey
10:11:19 * hackagebot jmacro 0.3.1 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.3.1 (GershomBazerman)
10:11:26 <wli> geheimdienst: I guess it depends on vapor pressure or something.
10:11:35 <soupdragon> :t intersperse
10:11:37 <lambdabot> forall a. a -> [a] -> [a]
10:11:43 <soupdragon> :t intercalate . return
10:11:44 <lambdabot> forall a. a -> [[a]] -> [a]
10:11:49 <hiptobecubic> geheimdienst, wli correct
10:12:04 <hiptobecubic> @src return
10:12:04 <lambdabot> Source not found. Maybe if you used more than just two fingers...
10:12:04 <wli> geheimdienst: Like how much resistance there is to increasing saturation of the air.
10:12:07 <Cale> > let f = (concat .) . intersperse . (:[]) in f ' ' ["hello", "there", "world"]
10:12:08 <lambdabot>   "hello there world"
10:12:20 <Axman6> unwords!
10:12:25 <soupdragon> monochrom you devil!
10:12:41 <soupdragon> thta's a nice post
10:12:47 <Axman6> why must you masquerade yourself?
10:13:51 <monochrom> soupdragon: In fact I wrote it as a sarcasm to: http://groups.google.com/group/comp.lang.functional/msg/da802356a04535c6
10:14:08 <soupdragon> yeah I noticed that
10:14:31 <monochrom> (every FP conversation ends with monads...)
10:15:28 <hiptobecubic> @src .
10:15:28 <lambdabot> (f . g) x = f (g x)
10:15:28 <lambdabot> NB: In lambdabot,  (.) = fmap
10:16:01 <Axman6> monochrom: s/FP/haskell, not all FP languages use monads (or at least call them that)
10:16:01 <soupdragon> @src (.)
10:16:01 <lambdabot> (f . g) x = f (g x)
10:16:02 <lambdabot> NB: In lambdabot,  (.) = fmap
10:16:05 <soupdragon> that's funny!
10:16:10 <soupdragon> I didn't expect both of them to work
10:16:14 <soupdragon> lambdabot++
10:16:22 * hackagebot RepLib 0.2.2 - Generic programming library with representation types  http://hackage.haskell.org/package/RepLib-0.2.2 (ChrisCasinghino)
10:16:23 <soupdragon> that's almost.. intelligence
10:16:54 <hiptobecubic> Cale, what's going on with your version?
10:17:02 * fiasco_ is frustrated!
10:17:04 <hiptobecubic> Cale, (concat .) . ?
10:17:07 <monochrom> @vixen I laud you!
10:17:07 <lambdabot> You complete me
10:17:11 <monochrom> hehe
10:18:19 <Cale> hiptobecubic: (concat .) is the function which applies concat to the result of another function
10:18:44 <Cale> hiptobecubic: Let's look at what this chain of functions does when I apply it to a parameter x
10:18:47 <hiptobecubic> isn't that was concat . would do as well?
10:18:56 <Cale> (concat .) . intersperse . (:[]) $ x
10:19:11 <Cale> -> (concat .) . intersperse $ [x]
10:19:21 <Cale> -> (concat .) $ intersperse [x]
10:19:34 <Cale> -> concat . intersperse [x]
10:20:20 <hiptobecubic> > let f = concat . intersperse . (:[]) in f ' ' ["hello", "there", "world"]
10:20:21 <lambdabot>   Couldn't match expected type `[[a]]'
10:20:21 <lambdabot>         against inferred type `[a1] ->...
10:20:24 <hiptobecubic> i see
10:20:36 <hiptobecubic> > let f = concat . intersperse $ (:[]) in f ' ' ["hello", "there", "world"]
10:20:36 <lambdabot>   Couldn't match expected type `[[a]]'
10:20:37 <lambdabot>         against inferred type `[a1] ->...
10:20:44 <hiptobecubic> crazy
10:21:01 <hiptobecubic> > let f = (concat .) . intersperse $ (:[]) in f ' ' ["hello", "there", "world"]
10:21:02 <lambdabot>   The section `: []' takes one argument,
10:21:02 <lambdabot>  but its type `[a]' has none
10:21:06 <soupdragon> :t (concat .)
10:21:07 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
10:21:08 <hiptobecubic> > let f = (concat .) . intersperse . (:[]) in f ' ' ["hello", "there", "world"]
10:21:09 <lambdabot>   "hello there world"
10:21:20 <soupdragon> > (contact .) [[[]]]
10:21:21 <lambdabot>   Not in scope: `contact'
10:21:59 <soupdragon> @pl \a b -> a ++ x : b
10:21:59 <lambdabot> (. (x :)) . (++)
10:22:18 <soupdragon> > foldr ((. (' ' :)) . (++)) [] ["hello", "there", "world"]
10:22:33 <hiptobecubic> ...
10:22:38 <lambdabot>   "hello there world "
10:22:40 <geheimdienst> > let f x ys = concat $ intersperse [x] ys in f ' ' ["hello","there","world"]
10:22:41 <lambdabot>   "hello there world"
10:22:47 <Cale> hiptobecubic: You can think of (f .) as a way to push the application of f down a parameter
10:22:56 <zygoloid> > unwords ["hello","there","world"]
10:22:57 <lambdabot>   "hello there world"
10:23:45 <lyndon> @src get
10:23:45 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:24:00 <Cale> > ((f .) . g) x y :: Expr
10:24:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:24:01 <lambdabot>    `SimpleReflect.FromExpr ...
10:24:25 <Cale> anyway, it's equal to  f (g x y)
10:25:54 <mauke> > (((f :: Expr -> Expr) .) . g) x y :: Expr
10:25:55 <lambdabot>   f (g x y)
10:25:56 <Blkt> where can I find a GHC-to-Haskell98 table so that I can find out where the classes and type declarations are?
10:27:54 <geheimdienst> cale, so (f .) . g x y == f (g x y), and that's obviously different from (f . g) x y, right?
10:27:59 <monochrom> Does http://haskell.org/onlinereport/ help?
10:28:15 <heath> hrm, i must be forgetting something obvious
10:28:28 <mauke> :t (f .) . g x y
10:28:28 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f, SimpleReflect.FromExpr (f1 (f a)), Functor f1) => f1 (f b)
10:28:36 <Cale> geheimdienst: right, the latter is equal to f (g x) y
10:29:47 <mauke> > ((f .) . (g x y :: Expr)) a b :: Expr
10:29:47 <lambdabot>   Couldn't match expected type `t -> t1 -> a'
10:29:47 <lambdabot>         against inferred type `...
10:30:12 <Blkt> monochrom: yes, a little bit
10:30:29 <geheimdienst> blkt, not sure what you mean, but many common classes are documented in http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Prelude.html
10:30:51 <monochrom> yeah, combine the two
10:30:52 <geheimdienst> other than that, does hoogle help you? http://www.haskell.org/hoogle/
10:32:14 <dancor> @src any
10:32:15 <lambdabot> any p =  or . map p
10:32:31 <dancor> @src or
10:32:31 <lambdabot> or    =  foldr (||) False
10:32:33 <hiptobecubic> Cale, can you rewrite 2 * 3 + 2 in RPN using composition?
10:33:07 <hiptobecubic> is it RPN? You knwo what i mean.. like + 2 3  instead of 2 + 3
10:33:08 <soupdragon> 2 3 * 2 + ???
10:33:08 <hiptobecubic> prefix
10:33:12 <mauke> preflex: calc 2 3 * 2 +
10:33:12 <preflex>  8
10:33:21 <soupdragon> (+ (* 2 3) 2)
10:33:23 <Axman6> hiptobecubic: RPN is postfix
10:33:25 <Cale> I guess it would be closer to just polish notation
10:33:26 <monochrom> > any (> 0) (1 : undefined)
10:33:27 <lambdabot>   True
10:33:30 <mauke> preflex: calc + * 2 3 2
10:33:30 <preflex>  8
10:33:34 <hiptobecubic> Axman6, yes, sorry
10:33:36 <soupdragon> haha
10:33:41 <monochrom> :type one
10:33:45 <soupdragon> preflex: calc + 2 3 2 *
10:33:45 <preflex>  8
10:33:46 <monochrom> @type one
10:33:47 <soupdragon> wtf
10:33:47 <lambdabot> Not in scope: `one'
10:34:10 <hiptobecubic> :t one
10:34:10 <lambdabot> Not in scope: `one'
10:34:14 <hiptobecubic> :)
10:34:42 <Cale> > (((+).) . (*)) 2 3 2
10:34:43 <lambdabot>   8
10:34:49 <monochrom> reverse hungarian notation: iTwo iThree fiiPlus
10:34:51 <hiptobecubic> Cale, yes that's what i wanted, thanks
10:35:42 <beutdeuce> why is the type [()] -> () for max' = \l -> foldr1 max l ?
10:36:01 <mauke> :t \l -> foldr1 max l
10:36:01 <lambdabot> forall a. (Ord a) => [a] -> a
10:36:14 <mauke> :t foldr1 max
10:36:14 <monochrom> Someone should write a category theory tutorial "category theory in hungarian notation"
10:36:14 <lambdabot> forall a. (Ord a) => [a] -> a
10:36:24 <beutdeuce> thats weird, because in ghc, its giving me something different
10:36:41 <mauke> monomorphism restriction?
10:37:26 <jmcarthur> deriving Functor is awesome
10:37:55 <jmcarthur> for the record
10:38:14 <orbisvicis> can data types be defined in where clauses ?
10:38:20 <monochrom> No.
10:38:29 <monochrom> (I wish we could.)
10:38:42 <geheimdienst> jmcarthur, that would make a good t-shirt
10:38:46 <monochrom> (I wish whole modules in where clauses, too.)
10:38:58 <Axman6> DSM's?
10:39:11 <Axman6> or... FSM's...
10:39:17 <orbisvicis> hm, thanks
10:39:27 <hiptobecubic> :t (+ .)
10:39:27 <lambdabot> parse error on input `.'
10:39:35 <hiptobecubic> :t ((+) .)
10:39:36 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
10:40:24 <jmcarthur> geheimdienst:  heh
10:40:52 <beutdeuce> how would one go about writing concurrent programs in haskell?
10:41:10 <monochrom> by using Control.Concurrent
10:42:54 <hiptobecubic> My head still is not around the mechanics of (.).  I understand ($) i think.
10:43:33 <Silvah> :t (.)
10:43:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:43:54 <Silvah> Goddamit. I want ol' good Prelude function!
10:43:55 <geheimdienst> same thing for me, i find $ very easy to understand, while . always needs effort
10:44:25 <soupdragon> geheimdienst, other way around for me
10:44:40 <Axman6> Silvah: you're not alone. shout at Cale, he refuses to listen to me, and others
10:46:43 <geheimdienst> soupdragon, i always think in terms of where i would put parentheses, then you skip the ) and put a $ where the ( would go
10:46:58 <Cale> hiptobecubic: Actually, this lambdabot-specific definition of (.) can be helpful in understanding how things like (f .) . g work
10:47:46 <Cale> hiptobecubic: You might find it easier to think of it as fmap f . g  (and then remember that the functor instance we're using is the one for functions)
10:47:52 <soupdragon> The nice thing about . is you don't have to care about paranthesis
10:48:00 <soupdragon> (f . g) . h = f . g . h = f . (g . h)
10:48:17 <Silvah> :t ($!)
10:48:19 <lambdabot> forall a b. (a -> b) -> a -> b
10:49:07 <Cale> hiptobecubic: In some sense, you can think of a function a -> b as being like an indexed container, with one value of type b for each value of type a
10:49:21 <hiptobecubic> Cale, ok sure
10:49:26 <Silvah> @src ($!)
10:49:27 <lambdabot> f $! x = x `seq` f x
10:49:37 <Cale> hiptobecubic: and what composition does is to apply a function to all the elements contained in another
10:50:19 <hiptobecubic> .... so that f1 a... gives you the result of f2 a?
10:50:35 <geheimdienst> i got an idea: think in terms of shell pipes. ls | grep in bash is analogous to grep . ls in haskell ... right?
10:51:31 <hiptobecubic> hiptobecubic, ... no... it gives the result of f2 (f1 a) ?
10:51:41 <Silvah> ya
10:51:47 <Cale> hiptobecubic: So (f . g) x -- the value of the resulting function at the 'index' or 'position' x, is equal to f (g x) -- f applied to the value of the function g at index x
10:52:14 <Silvah> Or rather grep =<< ls ;)
10:52:15 <soupdragon> geheimdienst: yes
10:52:17 <Cale> This is just the definition of composition, but maybe a bit of an interesting way to think of it
10:52:28 <Cale> So it's related in that way to what map does on lists
10:52:30 <geheimdienst> yeah, x is piped into g, and g's output is piped into f
10:52:44 <Cale> > map f [1,2,3] :: [Expr]
10:52:45 <lambdabot>   [f 1,f 2,f 3]
10:53:03 <geheimdienst> silvah, yeah, let's bring some monads into this, just to simplify it
10:53:22 <hiptobecubic> (f . g) x y    what is happening here then?  f of g of x and y?  f of (g of x) and y?
10:53:40 <Cale> map f xs applies the function f to each of the elements of the list-container xs, (f . g) applies the function f to each of the elements of the function-container g :)
10:53:54 <Cale> Yeah
10:53:59 <Cale> ((f . g) x) y
10:54:01 <Silvah> Did I mention that I loathe when someone writes my nickname as it'd be a variable rather than a type or constructor?
10:54:22 <hiptobecubic> silvah, no i don't believe you did
10:55:10 <Silvah> So I did it right now.
10:55:42 <geheimdienst> sILVAH, i assume you're uncomfortable being a constant, too? ;-)
10:55:47 <hiptobecubic> Cale, wait... (f . g) x y   ->   ((f . g) x) y?   Meaning f of (g of x) and y?
10:55:53 <Cale> yeah
10:56:11 <Cale> Whenever you write f x y z, it really means ((f x) y) z
10:56:12 <hiptobecubic> Cale, that's why this was so hard for me... i feel like that reaches out of the parens
10:56:27 <Silvah> geheimdienst: your assumption is correct...
10:56:51 <Blkt> geheimdienst: the first link you gave was the most helpful, thanks
10:57:14 <Cale> that is, function application associates to the left
10:57:19 <hiptobecubic> Cale, i'm so used to functions be called as f(x(y(z))) that my brain automatically reads them right to left i think
10:57:25 <soupdragon>  don't think of  f x y  as f(x,y)
10:57:46 <hiptobecubic> soupdragon, no i know. it's (f x) y
10:57:48 <Cale> You can think of it that way, but it might make things harder here
10:58:15 <soupdragon> also there is a difference between  f . g x  and  (f . g) x
10:58:28 <hiptobecubic> where (f x) is a function that takes a y and f's it in the x
10:58:36 <hiptobecubic> if you will
10:58:49 <Cale> heh
10:58:54 * soupdragon is not sure what f-ing something in the x means...
10:59:14 <hiptobecubic> i suppose it's really more like y is getting f'ed _with_ an x
11:02:30 <hiptobecubic> f . g x    is f . (g x) yes?
11:02:36 <Cale> yeah
11:02:49 <Cale> function application binds more tightly than any infix operator
11:02:50 <hiptobecubic> unless you $
11:02:54 <hiptobecubic> right ok
11:03:30 <Silvah> @src ($)
11:03:31 <lambdabot> f $ x = f x
11:03:33 <hiptobecubic> I'm not sure why I feel the need to understand this :D  I graduated with a bio degree
11:03:56 <soupdragon> cool
11:04:04 <soupdragon> biology is really interesting
11:04:15 <hiptobecubic> It's just so different from the imperative languages
11:04:54 <hiptobecubic> Not that CompSci at UMiami is too crazy anyway. I'm not sure they have compulsory functional programming anyway
11:04:58 <geheimdienst> f . g x is f (g x), and f $ g x is also f (g x), which explains why there is a little overlap between . and $ (right?)
11:05:12 <Cale> yeah
11:05:20 <hiptobecubic> geheimdienst, sure. But i hadn't thought about it
11:05:21 <soupdragon> geheimdienst: that is not  correct
11:05:26 <Cale> er
11:05:32 <Cale> geheimdienst: Right, no :)
11:05:36 <soupdragon> (f . g . h $ x) = (f $ g $ h $ x)
11:05:41 <soupdragon> BUT....
11:05:50 <Cale> f . g $ x, f $ g x are the same
11:06:03 <Cale> f . g x is not the same as that
11:06:05 <Silvah> Oh, my friend's question is da best... "what's wrong with f :: Int -> Int -> Bool?" What would be your answer to this?
11:06:07 <soupdragon> (f . g) . h = f . g . h = f . (g . h) <-- remember I said this earlier
11:06:13 <soupdragon> This sort of nice  law does not hold for $
11:06:23 <mauke> Silvah: "nothing"
11:06:27 <soupdragon> so e.g. (f $ g) $ x is not f $ (g $ x)
11:06:30 <hiptobecubic> Silvah, i agree. nothing
11:06:31 <Cale> (it doesn't even usually typecheck for $)
11:06:37 <soupdragon> now the question is... which one is  f $ g $ x  ?
11:06:53 <soupdragon> And that's one of the reasons why I like . more
11:07:06 <Cale> Silvah: Uh, nothing necessarily?
11:07:23 <Cale> Silvah: It depends on what one wants f to be :)
11:07:29 <hiptobecubic> > let f x y = if x `cmp y == GT then true else false in f 1 2
11:07:30 <lambdabot>   <no location info>: parse error on input `y'
11:07:39 <hiptobecubic> well you know, my syntax is weak :)
11:07:54 <geheimdienst> it's just the backtick
11:08:00 <hiptobecubic> > let f x y = if x `cmp` y == GT then True else False in f 1 2
11:08:00 <lambdabot>   Not in scope: `cmp'
11:08:06 <hiptobecubic> > let f x y = if x `compare` y == GT then True else False in f 1 2
11:08:07 <lambdabot>   False
11:08:16 <Silvah> Mine was: "That's correct. Try asking real question now." I just wondered whether there could be actually something wrong with that ;)
11:08:32 <mauke> hiptobecubic: useless use of 'if'
11:08:36 <Cale> Silvah: Maybe he's trying to type it into ghci?
11:08:57 <Axman6> hiptobecubic: for all x, if x then True else False === x
11:09:16 <hiptobecubic> === ?
11:09:21 <Cale> Silvah: Or maybe the definition of f is missing
11:09:33 <Cale> (you can't just give a type signature with no definition)
11:09:55 <hiptobecubic> mauke, is it?
11:10:07 <mauke> yes
11:10:14 <hiptobecubic> mauke, why's that?
11:10:23 <mauke> <Axman6> hiptobecubic: for all x, if x then True else False === x
11:10:33 <Silvah> Cale: You can! ...if it's a foreign import ;)
11:10:42 <soupdragon> === is just a verbose way of saying =
11:10:48 <Axman6> hiptobecubic: i was using === to mean 'is exactly the same as'
11:11:23 <Axman6> @check \x -> x == if x then True else False
11:11:24 <lambdabot>   "OK, passed 500 tests."
11:11:24 <geheimdienst> whenever you write "then true else false", you might as well skip that. in haskell and anywhere else.
11:12:09 <mauke> geheimdienst: not true
11:12:14 <Silvah> But yeah, there was nothing wrong with type signature per se.
11:12:17 <mapreduce> @check \x -> (x == True == True) == x
11:12:18 <lambdabot>   Precedence parsing error
11:12:18 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
11:13:08 <Silvah> @src maybe
11:13:09 <lambdabot> maybe n _ Nothing  = n
11:13:09 <lambdabot> maybe _ f (Just x) = f x
11:13:44 <geheimdienst> mauke, how do you mean?
11:14:29 <mauke> geheimdienst: consider javascript
11:15:35 <hellidunno> What'S the use of the id function?
11:15:55 <mauke> what's the use of the number 0?
11:16:08 <hellidunno> 0 is obvious
11:16:10 <hellidunno> id not
11:16:19 <mauke> hah
11:16:25 <Silvah> hellidunno: ($) *is* id.
11:16:29 <hellidunno> id returns what it gets as an argument
11:16:32 <hellidunno> oh
11:16:33 <hellidunno> lol
11:16:35 <soupdragon> you can use it to state an equation succinctly
11:16:37 <sepp2k> hellidunno: If you fold with (.) id is your neutral element.
11:16:39 <soupdragon> for example   f = id
11:16:42 <Silvah> As does ($).
11:16:47 <soupdragon> this says that whatever you put into f comes back out
11:16:52 <geheimdienst> mauke woah, never thought of that. now that you mention it, yeah sure, the whole !! story ... you could convert to a boolean by saying then true else false
11:16:55 <hellidunno> ok ty :)
11:17:13 <Silvah> :t ($)
11:17:14 <lambdabot> forall a b. (a -> b) -> a -> b
11:17:41 <Silvah> (a -> b) -> (a -> b), same as id.
11:17:55 <hpc> just a specialized form
11:18:15 <Silvah> It's what I meant ;)
11:18:16 <sepp2k> hellidunno: Also if you define a function that composes a function with itself n-times, then selfCompose 0 = id  is your base-case.
11:18:22 <hpc> > (2*) `id` 2
11:18:23 <lambdabot>   4
11:19:36 <hellidunno> interesting, nice
11:19:47 <Silvah> > zipWith3 id [(*), (+)] [42, 69] [11, 666]
11:19:48 <lambdabot>   [462,735]
11:22:29 <zygoloid> > let z = ZipList in getZipList $ z[(*), (+)] <*> z[42, 69] <*> z[11,666]
11:22:30 <lambdabot>   [462,735]
11:22:33 <hiptobecubic> :t (concat .)
11:22:33 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
11:23:19 <Silvah> You've ruined my example :(
11:23:19 <geheimdienst> > zip3 [(*), (+)] [42, 69] [11, 666]
11:23:20 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
11:23:21 <lambdabot>    arising from a use...
11:24:36 <hiptobecubic> so that takes a function and returns a function which takes a list of lists and applies the first function before applying the second function?
11:24:44 <zygoloid> > let z = zipWith ($) in [(*), (+)] `z` [42, 69] `z` [11, 666]
11:24:45 <lambdabot>   [462,735]
11:24:56 <zygoloid> Silvah: ^^ happier with that one? :)
11:26:06 <Silvah> id is shorter than ($) ;)
11:28:02 <zygoloid> ($) is clearer than id for function application though :)
11:28:25 <copumpkin> > id (+1) 5
11:28:26 <lambdabot>   6
11:29:28 <hiptobecubic> > (+1) 5
11:29:29 <lambdabot>   6
11:29:40 <mauke> const id
11:30:18 <Phyx-> Hi, I was wondering of there's some way to ask ghc to show which specific instance of a class it's picking when executing an expression?
11:30:28 <zygoloid> flip const?
11:30:45 <hiptobecubic> @src const
11:30:46 <lambdabot> const x _ = x
11:31:10 <hiptobecubic> what the hell is the point of const
11:31:39 <dolio> It's shorter than \x _ -> x
11:31:40 <soupdragon> hiptobecubic, it's just there because it holds mystical significance
11:31:43 <hiptobecubic> throw an argument away?
11:31:54 <zygoloid> > let crop = zipWith const in crop ['A'..] [1..10]
11:31:55 <lambdabot>   "ABCDEFGHIJ"
11:32:20 <hiptobecubic> take 10 ['A'..]
11:32:33 <zygoloid> not so useful if you don't know the length of the list.
11:32:41 <geheimdienst> hiptobecubic, yeah, i think it just throws the argument away. const 5 is the same as \_ -> 5
11:32:43 <zygoloid> the zipWith method is lazier
11:33:12 <zygoloid> crop xs ys = genericTake (genericLength ys :: Natural) xs, if you prefer
11:33:22 <hiptobecubic> zygoloid, what do you mean? the lists are both infinite
11:33:32 <hiptobecubic> zygoloid, oh i see
11:33:33 <hiptobecubic> sure
11:34:04 <hiptobecubic> > take (fromIntegral $ length [1..10]) ['A'..]
11:34:05 <lambdabot>   "ABCDEFGHIJ"
11:34:18 <triyo> Ok I know what DSL means but what is this EDSL I hear about in the Haskell space mean?
11:34:19 <zygoloid> > take (fromIntegral $ length [1..]) ['A'..]
11:34:23 <lambdabot>   mueval-core: Time limit exceeded
11:34:44 <geheimdienst> embedded dsl?
11:34:52 <hiptobecubic> >  let crop = zipWith const in crop ['A'..] [1..]
11:34:52 <zygoloid> > let crop = zipWith const in crop ['A'..] [1..]
11:34:52 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\12...
11:34:53 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\12...
11:36:08 <triyo> geheimdienst: oh, that makes sense I guess. I tried googling define:EDSL and got zilch
11:41:26 <nominolo> triyo: alternatively also spelled DESL
11:41:45 <zygoloid> or DSEL?
11:42:38 <geheimdienst> Embedded Damn Straightforward Language
11:43:24 <geheimdienst> Embedded Difficult Screwy Language
11:47:00 <triyo> Embedded Digital Subscriber Line
11:47:39 <zygoloid> Every Day Seems Lovelier
11:49:29 <opqdonut> ethical decisions seem lopsided
11:56:11 <mreh> domain specific embedded language
11:56:15 <mreh> right?
11:58:26 <marcot> Good afternoon.  I'm trying to use criterion, but it's giving me this message: ERROR: output type PNG 800 600 not supported on this platform
11:58:53 <SonOfLilit> Hello
11:59:06 <triyo> mreh: right, confirmed
11:59:15 <marcot> Hum, it's seems that this is because Chart is not installed.
12:01:12 <flippo> I'm finding this explanation of monads confusing: http://www.theosociety.org/pasadena/sd/sd1-3-15.htm
12:04:46 <geheimdienst> For the Greek Monas signifies “Unity” in its primary sense. Those unable to seize the difference between the monad — the Universal Unit — and the Monads or the manifested Unity, as also between the ever-hidden and the revealed Logos or the Word, ought never to meddle in philosophy, let alone the Esoteric Sciences.
12:05:51 <Null-A> i'm using haskellmode-vim, how do I run a haskell program besides "!runhaskell main.hs <args>"
12:06:20 <Null-A> ":GHCi main" doesn't let me pass args
12:06:52 <EvanR> im writing some c code, and i feel uncomfortable knowing that the types im writing dont actually guarantee any safety :S
12:07:09 <SonOf> Rant: I was an hour and 10 minutes late for this round of google code jam, and if I had five more minutes I'dve had time to fix the bug in q2 and would've ascended to the next level
12:07:25 <EvanR> i got a warning that i assigned an incompatible pointer type
12:07:36 <EvanR> but it compiled anyway
12:08:14 <mauke> -Werror
12:08:25 <EvanR> ah
12:08:28 <EvanR> good call
12:08:46 <mauke> preflex: ? cflags
12:08:47 <preflex>  gcc -std=c89 -pedantic -Wall -W -Wno-missing-field-initializers -Wundef -Wendif-labels -Wshadow -Wbad-function-cast -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -O2
12:09:15 <hellidunno> strict rules
12:10:52 <EvanR> there should be a tutorial 'C for haskell programmers'
12:11:03 <EvanR> how to maximize your type safety
12:11:28 <mauke> use casts sparingly
12:11:51 <mauke> abstract types are your friend
12:12:43 <geheimdienst> don't use duff's device
12:12:50 <opqdonut> :D
12:13:05 <mauke> duff's device doesn't affect type safety
12:13:22 <c_wraith> Doesn't it not really help with modern compilers and architectures, anyway?
12:13:48 <geheimdienst> mauke, oh i see, of course, then go ahead and use it a lot ...
12:13:50 <geheimdienst> ;)
12:14:00 <flippo> Have fun with setjmp and longjmp
12:14:17 <jmcarthur> avoid state. oh wait, you can't
12:14:42 <geheimdienst> c_wraith, whatever the modern compilers, it's hostile to modern programmers. end of discussion :-)
12:14:43 <c_wraith> I used setjmp and longjmp.  Once.  When writing a python wrapper for a C lib where I need to handle python exceptions in callbacks. <_<
12:14:43 <dv-> no cpufreq module on amd64?
12:14:49 <dv-> oh oops
12:19:51 <jdsc_> hello everyone
12:20:40 <jdsc_> the snap framework looks really cool, anyone knows if it handles https or will someday ?
12:22:31 <sclv_> someday
12:22:48 <c_wraith> for the moment, using a reverse proxy that handles ssl is fine.
12:26:26 <jdsc_> thanks c_wraith!
12:27:57 <mdmkolbe> What are appropriate citations to use for GHC, Generic Haskell and Epigram?
12:29:43 <nominolo> mdmkolbe: you mean for referencing GHC in a paper?
12:30:37 <mdmkolbe> Yes
12:32:57 <Olathe> @hoogle diffUTCTime
12:32:57 <lambdabot> Data.Time.Clock diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
12:34:55 <nominolo> mdmkolbe: for GHC I've seen it as "The GHC Team.  The Glasgow Haskell Compiler.  http://haskell.org/ghc"
12:35:16 <nominolo> mdmkolbe: some authors also just use a footnote with the link
12:36:27 <Adamant> EvanR: you could also take a look at CERT's rules for C coding.
12:36:50 <Adamant> a fair amount of the nasty bugs you can generate in C are also security bugs.
12:37:22 <pikhq> Buffer overflows and memory leaks are like 99% of the bugs in C that stick around.
12:38:35 <Adamant> and integer overflows, and blah blah blah
12:39:30 <pikhq> Bit less common for integer overflows to actually be *bugs* though.
12:39:41 <pikhq> (not that it doesn't happen)
12:39:59 <nominolo> pikhq: oh, integer overflow cause *great* bugs
12:40:16 <ClaudiusMaximus> it happened to me - worked fine on 32bit, on 64bit it malloc'd ~4GB and crashed hard
12:40:18 <nominolo> e.g., if it's passed to malloc
12:40:21 <pikhq> nominolo: Yes, when they happen they happen spectacularly.
12:41:00 <Adamant> yes. and moving from 16 to 32 bits, or 32 to 64 bits, is also a rich source of bugs.
12:41:57 <Null-A> I'm calling Parsec.Token.LanguageDef and get an error: http://codepad.org/vKAbJ27l#comment-EkTIMYGA
12:42:46 <EvanR> Adamant: overflow. im not sure how to even sanely handle that
12:42:59 <EvanR> ints are everywhere
12:43:14 <Adamant> EvanR: the CERT guide will give you hints.
12:44:13 <Adamant> EvanR: I've got to knock off IRCing and work on code, otherwise I would try to help, even though I'm just a conspiracy theory wacko. (assuming you are the same EvanR from #physics)
12:44:18 <BMeph> Greetings, Haskelliers!
12:44:20 <Adamant> :P
12:44:32 <EvanR> yes
12:44:38 <EvanR> im reading it
12:46:06 <Null-A> solved, nvm
12:50:54 <chewbranca> wow... if you're testing out the snap framework, don't use 'snap' as your example project name...
12:51:11 <danderson> hehe, reminds me of my first time with rails
12:51:33 <chewbranca> hahaha yeah, probably a noob mistake on my part, still very new to haskell
12:51:37 <danderson> tried to write a fortune cookie application, but the pluralizer was incorrectly doing cookie -> cookies -> cooky
12:51:40 <danderson> and so everything exploded
12:52:23 <danderson> then after that, turns out rail has no namespacing, so somehow my "Cookie" class (fortune cookie data type) was used in lieu of Webrick's Cookie class (HTTP cookie handling)
12:52:27 <danderson> with hilarious consequences
12:52:50 <chewbranca> I test out a lot of random frameworks and apps, so I usually use a directory name that is very similar to the app name so I can remember it later, unfortunately, using an app called snap overwrites the existing snap binary I had in ~/.cabal/snap lol
12:53:37 <chewbranca> hahahah yeah, you have to use nested namespacing in rails, ie Danderson::Cookie, pretty annoying when plugins don't do that and you have plugins overlapping on each other
12:54:53 <danderson> anyone happen to have examples of programs that use the LLVM bindings?
12:55:14 <danderson> having a little bit of trouble wrapping my head around the expected sequencing to construct bits of IR
12:55:31 <chewbranca> ok wow, so I overwrote snap now I can't figure out how to reinstall it properly
12:55:42 <danderson> cabal install --reinstall snap ?
12:55:43 <chewbranca> I don't see an uninstall option for cabal programs
12:55:58 <chewbranca> danderson, I did that, but it doesn't make another binary
12:56:14 <chewbranca> when I run snap after that I get: .cabal/bin/snap: No such file or directory
12:56:35 <danderson> could it be another package that's providing the binary?
12:56:41 <jdsc_> chewbranca: delete the binary and reinstall the package by hand, maybe ?
12:57:44 <chewbranca> jdsc_, I did delete the original snap binary in ~/.cabal/bin/snap because it was the snap web application I compiled
12:57:55 <chewbranca> jdsc_, is there a different binary I should delete?
13:00:24 <jdsc_> chewbranca: i don't think there's another binary, that's weird
13:00:59 <chewbranca> jdsc_, I just went through my ~/.cabal/ folder and deleted everything I could find with snap
13:01:08 <chewbranca> its still recognized as being installed though
13:01:12 <chewbranca> its stored somewhere else
13:01:20 <chewbranca> even tried uninstalling cabal-install and reinstalling
13:02:41 <danderson> "Generating and compiling a zillion numerical type aliases, this might take a while" << from the build of type-level, hehe.
13:03:06 <SonOfLilit> chewbranca: ghc-pkg unregister snap
13:03:17 <SonOfLilit> will tell it to forget it is installed
13:03:18 <jdsc_> chewbranca: maybe you installed as root and it's in /usr/local/bin
13:03:31 <SonOfLilit> it will not delete anything, though
13:03:44 <SonOfLilit> but that probably doesn't matter as you'll override it all
13:04:03 <SonOfLilit> jdsc_'s suggestion can be verified with 'where snap'
13:04:12 <EvanR> Adamant: this looks pretty grim to me. i knew it was bad but not this bad
13:04:12 <chewbranca> I installed cabal-install as root, but cabal upgrade set everything to my ~/.cabal directory
13:04:13 <SonOfLilit> but sounds wrong to me
13:04:44 <chewbranca> SonOfLilit, I tried unregistering and it returns: ghc-pkg: cannot find package snap
13:04:53 <jdsc_> i think the command is 'whereis' (not 'where')
13:04:55 <lyndon> @src (>>)
13:04:55 <lambdabot> m >> k      = m >>= \_ -> k
13:04:58 <chewbranca> yeah whereis and which snap return nothing
13:05:08 <jdsc_> try unregistering packages snap-core and snap-server
13:05:29 <chewbranca> good call
13:05:32 <chewbranca> found it that times
13:06:03 <Adamant> EvanR: there was a Neal Stephenson article on a contractor-grade power tool he used, which more or less laughed at anything resembling safety but could chew through problems there weren't a lot of other good solutions to you
13:06:16 <Adamant> *to use
13:06:55 <pikhq> Adamant: Small part of "In The Beginning, There Was The Command Line", IIRC.
13:07:00 <Adamant> EvanR: that's more or less what C is - the problem is that it was sold to people like something that should be front and center at the local tool store.
13:07:18 <Adamant> for "civilian" tool users
13:07:47 <mapreduce> http://www.cryptonomicon.com/beginning.html
13:07:52 <EvanR> im not sure if im going to voluntarily use C after this project is over
13:07:54 <Adamant> partly through sheer lack of knowledge of the consequences.
13:08:08 <chewbranca> ok great, that worked, got the snap-* packages unregistered, reinstalled snap, and now its all working
13:08:29 <Adamant> EvanR: it's fine, as long as you know why you are using it, know what the hell you are doing, and there isn't something better/safer that would work.
13:08:52 <EvanR> game programming ;)
13:08:59 <chewbranca> thanks for the help jdsc_ SonOfLilit and danderson!! I appreciate it, sorry for my haskell noobness, I just got into haskell this week
13:09:06 <Adamant> granted, it can still put a hole through your foot :P
13:09:21 <Adamant> EvanR: I'll assume that's a jibe at C++ and agree :P
13:09:23 <chewbranca> I switched my window manager to xmonad end of last week and that caught my interest in haskell
13:09:23 <mreh> EvanR: Look at hackage for haskell games
13:09:48 <chewbranca> reading through the learn you a haskell tutorial right now, any recommendations on good resources after that?
13:09:49 <EvanR> yes im liking haskell for games
13:10:06 <SonOfLilit> chewbranca: You're welcome
13:10:07 <nominolo> preflex: seen byorgey
13:10:07 <preflex>  byorgey was last seen on #haskell 5 hours, 39 minutes and 35 seconds ago, saying: 0.6.2 doesn't know how to parse the output of ghc-pkg dump, which changed in 6.12
13:10:12 <SonOfLilit> I'm very new to Haskell myself
13:10:13 <jdsc_> chewbranca: you're welcome :)
13:10:19 <mreh> EvanR: is it something you're primarily interested in?
13:10:29 <Adamant> there's not a huge amount of existing data on Haskell for gaming, but for homebrew projects there's more than enough data to justify it
13:10:31 <SonOfLilit> I began with the 48 hour scheme tutorial because I knew it would have my full interest
13:10:43 <sgf> When trying to compile a fairly big project with profiling on GHC, I'm getting "unknown symbol `_CCCS'". All I can see on trac is a closed, can't reproduce ticket for something similar. Anyone seen anything similar and/or any ideas on cutting down the code to a reproduceable test case for filing bugs on?
13:11:03 <EvanR> mreh: ive been doing research and experiments, but it has to wait until my game in c is done
13:11:06 <mreh> sgf: have you cleaned the directory first?
13:11:13 <mreh> rm *.hi *.o
13:11:25 <hpc> wouldn't ghc --clean work too?
13:11:27 <mreh> EvanR: see you in a few months then
13:11:32 <EvanR> yeah right
13:11:38 <mreh> hpc: cabal clean
13:11:41 <hpc> ah
13:11:46 <mreh> is there a ghc --clean?
13:12:11 <hpc> not according to the man, apparently
13:12:25 <EvanR> oh, i havent even been working on it for a year yet. initial commit jun 25 2009
13:12:39 <mreh> EvanR: what does it do?
13:12:52 <EvanR> mainly IO
13:12:58 <EvanR> not much of a game
13:12:59 <SonOfLilit> then I continued with lots of practice (google code jam problems, mainly), the "Real World Haskell" book (I like it very much, but not alone... too slow for me), blogs (Neighbourhood of Infinity goes over my head most of the time, but when I get someting it spikes my feeling of awesome and it really helps me get into the correct haskell mindset) and journal publications (about FRP)
13:13:06 <mreh> what game is it? :)
13:13:26 <EvanR> http://repo.or.cz/w/cantaveria.git
13:13:27 <nus> sgf, any foreign code involved?
13:13:44 <sgf> mreh: Well, I'm building several executables from the same source, and it claims I need to build the non-profiled version as well as the profiled to do some dynamic linking stuff...
13:14:07 <sgf> I could try cleaning and only building that exe, though, I suppose.
13:14:14 <byorgey> hey nominolo
13:14:45 <mreh> sgf: what does what say?
13:14:45 <sgf> nus: Not in the source file the error's coming from. I think all FFI's now done in packages separate from what I'm compiling.
13:14:53 <SonOfLilit> chewbranca: has this been helpful?
13:15:03 <SonOfLilit> oh, I must add, hanging out here in IRC helped a lot
13:15:45 <sgf> If I make clean and then compile with profiling without doing a non-profiling build, GHC gives an error message saying that it needs the non-profiling build too...
13:16:10 <sgf> I can go dig out that error message, but it'll involve rebuilding again!
13:16:27 <mreh> sgf does ghc complain that it needs profiling libraries for a certain package?
13:16:33 <mreh> oh
13:16:35 <sgf> No.
13:16:36 <mreh> non-profiling
13:16:49 <mreh> is this a C-lib?
13:16:53 <nus> sgf, it's a savvy custom to keep logs for big builds, use 'tee'.
13:17:39 <mreh> package databases like ubuntu keep profiling and vanilla libraries separately for haskell atleast
13:19:15 <sgf> nus: /That/ error message was several hours ago, which I've since fixed.
13:19:16 <mreh> EvanR: if you ditch it now and learn FRP you'll probably finish in less than half the time :D
13:20:01 <EvanR> yeah but half of what
13:20:01 <chewbranca> SonOfLilit, oh cool, I've heard some good things about real world haskell, I might have to pick that up
13:20:11 <EvanR> by the time im done in half the time, haskell may be the new C
13:20:22 <mreh> I doubt that
13:20:28 <EvanR> ive spent the entire 00s quitting and restarting stuff
13:20:37 <mreh> it may be the new applications programming language
13:20:53 <chewbranca> SonOfLilit, is this the blog you're talking about? http://blog.sigfpe.com/
13:20:58 <chewbranca> looks interesting
13:21:03 <endojelly> i know you're not impartial, but I would be interested in what arguments there are for making a functional language *not* lazy by default
13:21:22 <mreh> endojelly, ease of use is one big one
13:21:36 <endojelly> besides simple things as overhead for the thunks
13:21:50 <endojelly> mreh, you mean strict languages are considered easier to use?
13:21:54 <EvanR> i found strict javascript more difficult after learning haskell
13:22:27 <EvanR> you gotta wrap everything in nullary anonymous functions
13:22:29 <endojelly> mreh, I don't know if, assuming that I know both concepts well enough, I would find a strict language easier to use than a lazy one.
13:22:47 <jdsc_> endojelly: no space leaks
13:23:18 <mreh> I was trying to find a reference, but I it's easier to work out what order things are going to be evaluated
13:23:32 <mreh> s/I/I *think*/
13:23:38 <endojelly> jdsc_, is that when you can't actually be sure if a value might be needed?
13:24:01 <endojelly> jdsc_, where as in a strict language, simply every expression is evaluated, eliminating it on occurence?
13:24:15 <sgf> mreh: Message was "Common.hs:1:0: Dynamic linking required, but this is a non-standard build (eg. prof). You need to build the program twice: once the normal way, and then in the desired way using -osuf to set the object file suffix."
13:24:32 <endojelly> mreh, ok, but in a pure language that doesn't really matter, right? you need things similar to monadic IO, though
13:24:51 <mreh> endojelly: semantically they are identical
13:24:53 <mreh> yes
13:25:15 <sgf> So, I've done that. Anyway, that's not the problem I'm having now, I'm just trying to clarify what was going on...
13:25:17 <mreh> lazy vs strict is an operational thing
13:25:57 <endojelly> mreh, so my question I guess is: what is the advantage, for the programmer, to know in what order something gets evaluated. performance-related?
13:26:23 <ezyang> Hey guys, when you have a function A -> B, which is not really doing anything interesting except extracting B from A, what do you name the function?
13:26:45 <endojelly> ezyang, possibly just the same name that the thing you are actually extracting has
13:26:47 <mapreduce> endojelly: Predictability of performance, possibly.
13:26:50 <ezyang> endojelly: It makes it a lot eaiser to reason about the expected runtime of a program.
13:27:04 <ezyang> endojelly: Hm.
13:27:06 <endojelly> ezyang, i.e. if you're extracting a common prefix, call it commenPrefix.
13:27:27 <ezyang> I mean, I guess that might be problematic if I have C -> B.
13:27:43 <soupdragon> ezyang it's a projection
13:28:06 <ezyang> soupdragon: Sure.
13:28:09 <endojelly> ezyang, not with typeclasses, or use <thing>From<Otherthing> ;)
13:28:15 <Null-A> wtf.. I think my haskell environment is broken http://codepad.org/cgdAZ3V7
13:28:33 <ezyang> I'm just getting a feel for what you'd probably choose.
13:28:39 <endojelly> mapreduce, ezyang, ok that's a good one, pretty clear, too.
13:28:43 <ezyang> I've personally used sourceDest, sourceToDest
13:28:47 <endojelly> anything else?
13:29:01 <c_wraith> Null-A: it looks like you have an error message pasted in your source file....
13:29:03 <mreh> endojelly, I thought up another reason, effective pure memoization!
13:29:10 <Null-A> c_wraith: har har..
13:29:17 <mreh> and of course infinite data structures
13:29:19 <Null-A> c_wraith: that's the error message
13:29:22 <endojelly> mreh, in strict languages or lazy ones?
13:29:26 <mreh> endojelly, lazy
13:29:29 <c_wraith> Null-A: oh, the error message on the bottom is from the site?  that's annoying
13:29:30 <ezyang> aha, that's because Codepad is running it
13:29:35 <Null-A> c_wraith: yep
13:29:50 <endojelly> mreh, ok, but I'm spefically asking for advantages to languages which are *strict* by default 8)
13:29:54 <ivan> codepad confuses at least 80% of the time
13:30:24 <c_wraith> that is pretty bad.  Anyway, from the error message, I'd guess there's an instance for [Char], but not for Char
13:30:27 <mreh> endojelly: strictness is a restriction if you catch my drift
13:30:43 <mreh> they're the same semantically, so why not allow the program to evaluate things as they are required?
13:30:52 <c_wraith> I don't see how a single character can be a stream
13:30:55 <ezyang> soupdragon: Though, were you actually suggesting I use "projection" in the name?
13:31:25 <endojelly> mreh, yes, but that's the thing. I'm interested in what arguments might be against making laziness the default. they don't even have to be consensus
13:31:26 <mreh> endojelly, I think the big advantages have been supplied
13:32:00 <ezyang> endojelly: Laziness has overhead, because you have to store closures
13:32:04 <mreh> endojelly, it's also harder to implement
13:32:11 <soupdragon> ezyang no
13:32:13 <ksf> anyone iteratee-experienced here to bounce an idea?
13:32:27 <soupdragon> I thought you were asking for a name for that class of functions since you used generic names A, B
13:32:43 <endojelly> mreh, ezyang, best I paste what I wrote initially
13:32:44 <c_wraith> man, everyone's all iteratee this and enumerator that these days.  :)
13:32:46 <ezyang> soupdragon: Ah, I see.
13:32:58 <endojelly> 22:20 < endojelly> i know you're not impartial, but I would be interested in what arguments  there are for making a functional language *not* lazy by default
13:33:02 <endojelly> 22:21 < endojelly> besides simple things as overhead for the thunks
13:33:09 <sgf> mreh: mreh: Rebuilt from clean, exact error message is 'ghc.exe: ../Build\obj\PAD.prof.o: unknown symbol `_CCCS''
13:33:12 <ksf> heh, I was all iteratees even before they were on hackage
13:33:20 <ezyang> oh you want more reasons
13:33:35 <ezyang> Laziness can move when work is done around in unexpected ways
13:33:43 <ezyang> dons had a good talk about that
13:33:47 <endojelly> I sometimes hear "maybe it isn't such a good idea to make everything lazy by default" and I'm asking myself, why. I don't know enough about it to come up with more reasons than the overhead for thunks and runtime-related issues
13:34:02 <endojelly> so I want to know if there's more, maybe things that aren't so obvious
13:34:10 <c_wraith> I think lazy by default is good, but people need to be aware there are problems with it.
13:34:23 <ksf> the idea is to move the message that is carried inside Cont in IterGV into IterateeG, which'd then be a sum type of either runIter or a state transition function.
13:34:42 <endojelly> (actually the runtime prediction argument was a good one, because although it's pretty obvious, I forgot it)
13:34:53 <mreh> endojelly: arguments would probably all be it's hard for people to learn, but that's never stopped us :)
13:34:54 <ksf> or, well, messages in general. IterateeG would be parametrised over it and the enumerator has to support what you send it...
13:35:18 <ezyang> "Work might also be migrated away from where you want it done "
13:35:32 <c_wraith> I'll tell you about my run-in with default laziness while coding up a data structure.  It turned out that because some updates were being made lazily, each iteration of the structure kept all the previous generations, until all the thunks in it were forced.  That resulted in huge unexpected space leaks.
13:35:52 <c_wraith> Once you are aware of the issues, it's really easy to see how to work around them.
13:35:52 <mreh> and runtime prediction is all about optimisation, but that's not an issue when you have a good profiler
13:35:59 <endojelly> mreh, it's a good argument, but yes, the harder learning curve pays off 8)
13:36:04 <SonOfLilit> endojelly: Whenever I invoke the debugger and try to step through my code, it does all sorts of srange jumps that make me go "wtf where am I?"
13:36:16 <ksf> I got the idea because I want the iteratee to be able to tell the enumerator "it'd be great if you read in chunks of length n now instead of the default", and threading that through the monad instance seems awful.
13:36:34 <endojelly> SonOfLilit, hah, debuggers, good one
13:36:35 <ksf> ...better pass some state around in the base enumerator.
13:37:21 <danharaj> I think the argument for default laziness loses weight in a language that distinguishes data and codata.
13:37:22 <c_wraith> I'm still trying to figure out why Snap uses an enumerator pattern for output.  Is it just so that you can change your mind about what output you're producing at later points, without having to keep everything in memory before then?
13:37:24 <EvanR> well, if there are parts of the program you want to be strict, isnt that the point where youd say, alright, im making this part strict?
13:37:25 <SonOfLilit> endojelly: I'd love to have a debugger that actually gives you a complete trace as an expandable call graph, though
13:37:41 <endojelly> SonOfLilit, to be fair, I often think haskell programs don't need debugging as often. though that's a feature of the type system, not the language's lazyness.
13:38:06 <danharaj> In an ideal program, laziness/strictness should not impact the semantics, only the performance.
13:38:06 <mike-burns> Or perhaps it's a feature of how carefully people construct the programs.
13:38:08 <ksf> c_wraith, I think yes.
13:38:11 <EvanR> endojelly: also because of the immutable data
13:38:18 <SonOfLilit> endojelly: There's always that weird case when you do
13:38:27 <ksf> consider writing out a 1gig file, then the string foo, then another 1gig file and then the string bar.
13:38:32 <ksf> you don't want to have that in memory.
13:38:34 <endojelly> SonOfLilit, for uncaught exceptions, I already like the work that has been done to implicitly pass a call stack to failable functions for debugging purposes
13:38:38 <SonOfLilit> and with the haskell knowledge I have,I still need it a lot
13:38:53 <ksf> (although snap's iteratees don't support sendfile, they do that manually)
13:38:58 <endojelly> EvanR, oh, yes, thanks, type system and purity
13:39:20 <EvanR> i dont think purity == immutable data
13:39:21 <SonOfLilit> endojelly: how about when I simply am doing something wrong and want to watch my program run to see if I can spot the mistake?
13:39:22 <c_wraith> ksf: I think the main realization was noting that its pattern wouldn't force the input to writeBS before actually doing the output.
13:39:41 <endojelly> EvanR, doesn't purity mean "no side effects", and doesn't mutable data imply side effects?
13:39:55 <SonOfLilit> like something that happened to me during code jam today
13:40:19 <endojelly> SonOfLilit, nono, I agree, debugging in haskell is hard because of that
13:40:19 <EvanR> endojelly: but it doesnt imply the other way
13:40:25 <ksf> I also don't think snap does writev, tcp_cork or anything like that...
13:40:32 <SonOfLilit> I had a piece of code tha I knew was wrong, I couldn't figure out how. So I traced it a bit, saw how it reached its result, understood what modification had to be made
13:40:53 <SonOfLilit> endojelly: it could be much easier it there were better tools
13:40:55 <endojelly> EvanR, but you can't have side effects in a pure language, thus you can't have mutable data in a pure language?
13:41:01 <SonOfLilit> but still, it's an argument against
13:41:08 <endojelly> yeah
13:41:15 <EvanR> endojelly: but you can have immutable data in an impure language
13:41:57 <EvanR> so called 'effectively immutable', in practice
13:41:59 <endojelly> EvanR, yeah, but I wasn't trying to say that you *need* a pure language for immutable data
13:42:29 <danharaj> Why is citeseer always down?
13:43:06 <endojelly> EvanR, just that haskell's purity implies immutable data, so they're more often less buggy :P
13:43:31 <mike-burns> If the program isn't buggy you're simply not trying hard enough.
13:43:32 <EvanR> i think the bugs come from mutable data
13:43:57 <SonOfLilit> many do
13:43:59 <endojelly> EvanR, I agree
13:44:05 <SonOfLilit> some bugs simply come from the programmer
13:44:10 <c_wraith> woo.  I'm installing snap twice.  silly me, testing on both ghc 6.10 and 6.12
13:44:22 <EvanR> endojelly: you can have a pure function that uses mutable local variables to carry out its computation
13:44:32 <SonOfLilit> I write wrong code sometimes. Because I don't consider an edge case, or simply because I have a wrong assumption
13:44:38 <danharaj> Referential transparency does not imply immutable data.
13:44:54 <danharaj> It implies you can't observe impure operations.
13:44:54 <endojelly> EvanR, yes, but then is it pure "all the way through"?
13:45:11 <SonOfLilit> endojelly: What EvanR describes is even useful
13:45:18 <endojelly> EvanR, a really pure language would consist of nothing but pure functions, wouldn't it?
13:45:25 <endojelly> some of them constant.
13:45:26 <c_wraith> EvanR: You've just described ST
13:45:38 <EvanR> yeah i know haskell can do this
13:46:10 <EvanR> and such a function is probably harder to write correctly
13:46:48 <ezyang> I feel like reading some Haskell code. What is some beautiful Haskell code I should read?
13:46:54 <c_wraith> They're not so bad.  ST makes the mutation operations highly visible.  It's when they're disguised that it's hard to identify them
13:47:04 <endojelly> so as soon as you write a pure function that uses mutable local variables, your language might still have referential transparency, but it's not pure anymore.
13:47:57 <EvanR> whether haskell is 'pure' depends on your perspective i guess
13:48:48 <SonOfLilit> ezyang: They say xmonad is interesting
13:48:53 <SonOfLilit> I haven't tried
13:49:30 <endojelly> EvanR, problem is, I don't really know what the accepted definition of pure is
13:49:48 <EvanR> all functions are pure, the result only depends on the inputs
13:50:08 <c_wraith> I've seen people say, in this channel, that pure means "execution occurs only via graph reduction"
13:50:19 <nus> sgf, _CCCS should be in libHSrts_p.a
13:50:45 <hpc> EvanR: that's the definition of pure...
13:50:47 <endojelly> c_wraith, and that is not true for strict languages I guess?
13:51:10 <EvanR> hpc: there you go
13:51:12 <c_wraith> endojelly: I don't really know if I agree with that definition.  But I've seen it used.
13:51:23 <ezyang> Ok, I can look at xmonad
13:51:39 <Null-A> these type inference errors are making my brain hurt: "Inferred type is less polymorphic than expected"
13:51:52 <c_wraith> that one's always fun.
13:51:59 <ezyang> Null-A: Pastie!
13:52:05 <c_wraith> you specialized your code too much!
13:52:07 <endojelly> c_wraith, can you tell me more why a strict language isn't executing by graph reduction?
13:52:07 <ezyang> But it means what it says
13:52:17 <BMeph> c_wraith, endojelly: That ccan't possibly be true - think: what does ML give you that LML (or Haskell) does not?
13:52:23 <BMeph> *can't
13:52:27 <Null-A> ezyang: I found a decent solution, just add type inference elsewhere, and ghc figure it out
13:53:25 <nus> endojelly, how c_wraith's 'pure' became your 'strict'?
13:53:54 <SonOfLilit> nus: by double negation
13:53:55 <endojelly> nus, did it?
13:54:20 <endojelly> nus, he said pure would be execution by graph reduction, I ask why strict isn't
13:54:20 <nus> <c_wraith> I've seen people say, in this channel, that pure means "execution occurs only via graph reduction"
13:54:35 <EvanR> we should probably stop talking about the pure tangent and get back to the lazy/strict
13:54:40 <c_wraith> actually, strict vs. non-strict is orthogonal to being only graph reduction.  They just change the order of graph reduction.
13:54:42 <endojelly> nus, oh wait I'm stupid 8)
13:54:49 <endojelly> impure!
13:54:52 <endojelly> I meant impure!
13:54:55 <sgf> nus: Tell that to GHC. :p I have a suspicion I could have done something stupid with a package, so I'm poking about a little more...
13:55:26 <endojelly> c_wraith, nus, yes, sorry, I confused the words because of the discussion about lazy/strict before
13:55:54 <nus> sgf, somehow it doesn't get linked in, it seems.
13:56:11 <endojelly> but now I also see where the idea of pure ^= execution by graph reduction comes from
13:56:35 * nus doesn't
13:56:42 <endojelly> the graph itself would be mutated in an impure language, wouldn't it?
13:56:46 <mah01> I want to have multiple regex matches for a string. So matching greedy matching "<p>.*</p>" for "aaa <p>bbb</p> ccc <p>ddd</p> eee" would give me two matches. What library is suitable for that?
13:57:37 <c_wraith> Does GHC 6.12.2 clean up some of the spurious warnings that were in 6.12.1?
13:57:59 <soupdragon> mah01, not regex for this :[
13:58:08 <BMeph> endojelly: It could be, and non-locally. THAT's the point to why purity is so useful.
13:58:20 <mah01> soupdragon, sorry, didn't get your point
13:58:31 <soupdragon> my point is: Don't use regex
13:58:40 <mah01> why?
13:58:48 <endojelly> EvanR, it was an interesting tangent, but yes
13:58:54 <soupdragon> because HTML tags are nested but regex cannot parse nesting
13:59:13 <Veinor> mah01: matchRegexAll returns the string after the match
13:59:13 <BMeph> mah01: If it's a greedy match, then you have one match. :)
13:59:17 <sgf> nus: I was hoping it might have been an old installed package with the same module-name confusing it, but I've just nuked the entry in packages.conf, and still not working.
13:59:42 <Veinor> er
14:00:00 <sgf> There's a thread from several years ago about nasty interaction between TH and profiling... I suppose it could be something along those lines, since the file uses TH.
14:01:01 <mah01> soupdragon, well, actually I showed simple example. HTML I have is not valid. So you can encounter "<b>..<p>..</b>..</p>". I just want to parse specific types of tags, so I guess regex is alright for that.
14:01:12 <Veinor> > matchRegexAll (mkRegex "q") "aqbqc"
14:01:12 <lambdabot>   Not in scope: `matchRegexAll'Not in scope: `mkRegex'
14:01:16 <mah01> BMeph, yeah, you are right, not greed ;)
14:02:06 <soupdragon> lol
14:02:09 <soupdragon> *facepalm*
14:02:15 <Silvah> ?
14:02:32 <ksf> endojelly, the graph _does_ get mutated.
14:02:34 <ksf> cf. thunking.
14:02:57 <ksf> so, to summarize, laziness makes haskell impure...
14:03:03 <mike-burns> mah01: If you're parsing invalid or malformed HTML you probably want the tagsoup package.
14:03:40 <jmcarthur> why is Hac φ called Hac φ? what does the φ mean?
14:03:48 <c_wraith> is it in philidelphia?
14:03:53 <mike-burns> It is.
14:03:54 <c_wraith> that would just make it a bad pun
14:04:02 <jmcarthur> lol
14:04:13 <mike-burns> Not even a pun, really.
14:04:22 <jmcarthur> φladelphia
14:04:32 <jmcarthur> φladelφa
14:04:35 <mike-burns> Heh.
14:04:41 <Silvah> lol
14:05:54 <mah01> Veinor, I guess you were talking about "Text.Regex", right? I tried:   matchRegexAll (mkRegex "<P>[^/]*</P>") "aaa <P>bbb</P> ccc <P>ddd</P> eee <P>fff</P> ggg"     which returned me    "Just ("aaa ","<P>bbb</P>"," ccc <P>ddd</P> eee <P>fff</P> ggg",[])". But that is only one match!
14:07:44 <Veinor> Prelude Text.Regex> let allMatches r str = case matchRegexAll r str of Nothing -> []; Just (_, match, after, _) -> match : allMatches r after
14:07:56 <mah01> mike-burns, thanks for the tip about tagsoup. Some of my html files are about 15-20MB weight. And there can be really a lot of html tags. So after stripping all XML tags and reducing white-space characters, contents can take only several percent of original file size.
14:08:02 <Veinor> Prelude Text.Regex> allMatches (mkRegex "q.") "aqbqcq"
14:08:03 <Veinor> ["qb","qc"]
14:08:07 <Veinor> there you go
14:08:18 <mah01> mike-burns, would tagsoup work fine with that?
14:09:02 <mah01> Veinor, thanks!
14:09:24 <mike-burns> mah01: I've honestly never tried tagsoup, in Haskell, with that. I've tried it in Python (BeautifulSoup, I think) on files that size without complaint.
14:09:37 <Veinor> no problem; keep in mind that Text.Regex.Posix doesn't let you do .*? minimal matching
14:10:00 <Veinor> so <p>.*</p> will always match from the first <p> to the last </p>
14:10:12 <c_wraith> jmcarthur:  related - http://math.ucr.edu/~jdp/Relativity/COW.JPG
14:10:41 <mah01> Veinor, yes, I used "<p>.*</p>" just for example
14:11:28 <Veinor> ah, okay
14:11:38 <roconnor> note to self: use arrays instead of lists for memoization
14:12:12 <endojelly> roconnor, or, more generally, efficient maps 8)
14:12:26 <jmcarthur> Silvah: i think it's possible if you are in control of what libraries you use
14:12:47 <roconnor> edon: perhaps map too would have been fine
14:12:55 <roconnor> edon: my lists are only of length 500
14:13:02 <Veinor> actually, you could probably clean that up a bit
14:13:04 <roconnor> I didn't think accessing it would be so bad
14:13:16 <EvanR> shouldnt the process of memoization be automated, since functions are pure
14:13:23 <jlouis> c_wraith: re warnings, I don't think so
14:13:27 <Veinor> oh wait, no
14:13:34 <EvanR> and because you cant do it the scheme way because you cant have internal state
14:13:37 <jmcarthur> EvanR: what about insane space leaks that the compile could never predict?
14:13:38 <mike-burns> Or shouldn't there be a memoization library?
14:13:42 <jmcarthur> *compiler
14:13:46 <c_wraith> EvanR: No.  It's impossible for the compiler to tell if it would help
14:13:46 <EvanR> jmcarthur: configurable
14:13:47 <Veinor> there are memoization libraries
14:13:48 <jmcarthur> mike-burns: there are a few
14:13:53 <Silvah> jmcarthur: ???
14:13:54 <mreh> memo-combinators
14:13:59 <Veinor> also memotrie
14:14:17 <jlouis> c_wraith: all my spurious warnings are one in GHC-HEAD now however
14:14:18 <jmcarthur> Silvah: what? i can't really expand on it
14:14:40 <c_wraith> jlouis.  HEAD is the current 6.13?
14:14:57 <jlouis> c_wraith: yes, from 2010-05-21 here
14:15:02 <jmcarthur> EvanR: it's in libraries anyway, so it's not a big deal
14:15:15 <Silvah> You wrote something about libriaries, control and other whatnots...
14:15:19 <EvanR> seems like you have to change the interface to the function
14:15:39 <jmcarthur> Silvah: yes?
14:15:40 <EvanR> rather than transparently changing the basic function to one that somehow memoizes
14:15:47 <roconnor> mreh: does it use arrays?
14:15:49 <jmcarthur> EvanR: no you don't
14:15:59 <Silvah> Though I dunno why the heck you mentioned me.
14:16:01 <jmcarthur> EvanR: check out memo-combinators or memotrie
14:16:15 <jmcarthur> Silvah: in response to "Am I the only person who thinks it is simply impossible to make readable code in that language?"
14:16:23 <mreh> roconnor: sorry I don't know
14:16:35 <Veinor> if the function's recursive you have to make sure that the function only ever calls the memoized function
14:16:43 <Silvah> Ah.
14:16:50 <Veinor> also, it's data-memocombinators
14:17:01 <jmcarthur> aha
14:17:14 <Silvah> Well, I wrote that on #haskell-blah, so please answer on #haskell-blah too.
14:17:33 <jmcarthur> Veinor: that's true that you have to call the memoized version but... that makes sense :)
14:17:53 <leino> hi all.. trying to "cabal install greencard" but I get the following errors: http://pastebin.com/N6UDhsYh
14:17:56 <leino> any ideas?
14:17:57 <jmcarthur> Silvah: oh sorry, i didn't realize it was #haskell-blah... i guess i should unmerge these buffers
14:18:15 <Veinor> yeah, that's tripped me up a few times
14:18:23 <Veinor> 'why isn't this working?! ... oh'
14:22:14 <JoeyA> Does GHC have a compiler switch or something to enable multi-core computation?
14:22:54 <Silvah> It does.
14:23:06 <Veinor> JoeyA: -threaded I think
14:23:07 <c_wraith> JoeyA: yes.  But your code needs to be set up to take advantage of mulitiple cores, too
14:23:15 <Silvah> Try asking the proper question now.
14:23:23 <Veinor> Silvah: that's not nice.
14:23:28 <JoeyA> thanks
14:23:48 <Silvah> I know...
14:23:59 <Veinor> and then you have to make sure to tell it how many cores when you run it, like ./foo +RTS -N2 -RTS
14:24:08 <Veinor> which says 'use two cores'
14:25:00 <Silvah> I'm not a nice person even though I'm trying my best.
14:26:04 <Phyx-> You probably forgot to take your pills today :)
14:26:52 <Veinor> I think that's right, I haven't done any multi-core computation
14:26:55 <EvanR> the -N2 only works for concurrent code right
14:27:29 <JoeyA> Why does runghc -O2 foo.hs run much slower than ghc --make -O2 foo.hs && ./foo ?
14:27:41 <JoeyA> The former runs at interpreted speed
14:27:43 <Silvah> AFAIR there was something about that in RWH.
14:28:19 <Phyx-> JoeyA: did you just ask and answer your own question?
14:28:33 <Silvah> (I'm talking about multicore computation)
14:28:43 <Silvah> lol
14:28:49 <JoeyA> Well, -O2 means optimize.  I figure runghc would know to compile first before running.  Otherwise, the -O2 would be useless.
14:28:54 <Silvah> Apparently he did ^^
14:29:09 <EvanR> runghc interprets it i think
14:29:31 <Veinor> JoeyA: what happens if you do it without -O2 ?
14:29:41 <Phyx-> JoeyA: optimized interpreted code vs optimized compiled code. the delta is still interpreted vs compiled
14:35:23 <mah01> Veinor, getting back to the question about regular expressions using Text.Regex. Any ideas how I can have minimal matching? For example I want to match "<p>..</p>" in the html.
14:35:40 <Veinor> I don't think POSIX regexes support that
14:35:51 <mah01> damn =)
14:36:05 <Veinor> PCREs do, though
14:36:31 <mah01> so.. is there a point to use pcre-light library instead?
14:36:37 <zygoloid> <p>([^<]|<[^/]|</[^p]|</p[^>])*</p> ?
14:36:52 <Veinor> pcre-light gives you the full force of perl-compatible regex expressions
14:37:05 <EvanR> regex considered harmful
14:37:14 <Veinor> er, you might want to use regex-pcre
14:37:29 <mah01> em.. is that better?
14:38:34 <Veinor> I think it lets you use the same interface as text.regex
14:38:41 <mah01> alright
14:38:49 <hpc> PCRE doesn't do s/// patterns though
14:38:54 <hpc> unless i am mistaken
14:39:06 * hackagebot web-routes-quasi 0.3.0 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.3.0 (MichaelSnoyman)
14:39:55 <Veinor> regex-pcre lets you import Text.Regex.PCRE to use the same interface as Text.Regex.POSIX but with the PCRE backend
14:40:26 <mah01> Veinor, regarding minimal match. zygoloid offered "<p>([^<]|<[^/]|</[^p]|</p[^>])*</p>" works fine
14:40:48 <Veinor> yeah, but that's ugly
14:40:50 <Veinor> :P
14:41:02 <JoeyA> So in a threaded Haskell program, do I need to make multitasking explicit?
14:41:16 <EvanR> forkIO, MVar, Chan
14:41:20 <EvanR> theres also this STM thing
14:41:21 <mah01> well, yes..
14:41:30 <JoeyA> I tried running an embarrassingly parallel program without any markers, and it only used one thread :(
14:41:31 <zygoloid> depends what you mean by 'explicit'
14:41:46 <JoeyA> I was hoping it'd know to split lazy computations across threads
14:41:47 <EvanR> you want parallel computation
14:41:53 <EvanR> thats something else
14:41:59 <zygoloid> you need to annotate what you want to parallelize at least
14:42:12 <ddarius> JoeyA: There's a difference between concurrency (two things observably happening at the same time) and parallelism (spreading one task over multiple cores/CPUs/computers).
14:43:11 <ccasin> jmcarthur: the phi stands for philadelphia!
14:47:41 <Peaker> JoeyA, There's no implicit parallelism going on (yet).. Good news is, though, that it is much easier to introduce parallelism in Haskell than almost anywhere else
14:47:41 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
14:47:44 <Veinor> ... why does ghc-pkg list say I have base 3 and base 4? O_o
14:47:55 <jmcarthur> ccasin: thanks
14:48:26 <EvanR> :t par
14:48:27 <lambdabot> forall a b. a -> b -> b
14:48:33 <JoeyA> Okay, I found Control.Parallel and got par working to create a "pmap" (parallel map) function.
14:48:37 <sclv_> :t flip const
14:48:38 <lambdabot> forall b a. a -> b -> b
14:48:52 <sclv_> mine is more efficient :-)
14:48:59 <EvanR> :t seq
14:49:00 <lambdabot> forall a t. a -> t -> t
14:49:01 <zygoloid> @type parMap
14:49:02 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
14:49:28 <zygoloid> JoeyA: ^^ one of those? :)
14:50:50 <EvanR> how does par give you the result of the 'ignored' computation
14:51:09 <zygoloid> you're expected to hold on to it yourself
14:51:11 <hpc> EvanR: you just use it later
14:51:21 <BMeph> :t const id
14:51:22 <lambdabot> forall a b. b -> a -> a
14:51:28 <EvanR> ah, like seq
14:51:38 <Peaker> EvanR, It doesn't, it only hints that some hardware should start computing the "a" to make it available if it is used later
14:51:51 * JoeyA wonders why Haskell doesn't parallelize automatically (without having to indicate how)
14:52:11 <zygoloid> JoeyA: sometimes it can make your program slower. it's very hard to automate.
14:52:13 <Peaker> JoeyA, Because it turns out that if you get the granularity of parallelism wrong (too fine or too coarse) it only harms performance
14:52:17 <EvanR> JoeyA: because you havent written a paper on it and implemented an efficient way to do that yet ;)
14:52:24 <JoeyA> lol
14:53:08 <Peaker> JoeyA, "sparking" a computation to a new thread has an overhead cost. For very small computations, doing this is counter-productive.  There's no easy automatable way to know "how big" a computation will be before-hand, statically
14:53:46 <Peaker> I wish there was "profile-based-par" that was automatic (GHC using a profile result to determine which computations are likely to be big or not)
14:54:40 <danderson> so, trying to compile http://code.haskell.org/llvm/examples/Fibonacci.hs , and I'm getting a massive vomit of linker errors. I have no idea where to begin to fix them, and one actually looks quite strange (can't find 'main'). http://code.bulix.org/9e091h-75115?raw
14:54:53 <ddarius> Peaker: People have definitely talked about that before and there may be some work on it too.
14:55:23 <Phyx-> Peaker: that has it's short comings too I can imagine, for instance if your test inputs don't cover the more computationally expensive paths
14:55:23 <danderson> does it make sense to anyone why the runtime .a would fail to find the main in the module (right at the end), or why pretty much all symbols in the .o appear undefined at link time?
14:55:29 <dons> JoeyA: there's too much parallelism implicitly than today's hardware can handle. so we have to reduce the granularity by estimating the size of computations statically. that's really really hard
14:55:35 <Peaker> Phyx-, Sure
14:57:11 <Phyx-> @hoogle hscParse
14:57:11 <lambdabot> No results found
14:57:19 <Phyx-> time to grep!
14:57:23 <Peaker> danderson, you have defined "module Fibonacci" -- "main" is ignored everywhere except in the "Main" module
14:57:27 <Peaker> Phyx-, Hayoo!
14:57:59 <danderson> Peaker: ah, sneaky. These are the examples from the LLVM bindings, hence my confusion.
14:58:01 <Phyx-> Peaker: nah, don't think these files are indexed
14:58:22 <jlouis> There, combinatorrent and etorrent now performs roughly the same on some test torrents CPU wise
14:58:22 <danderson> okay, that gets rid of the main linker error, leaving only the crapload of LLVM failures
14:58:38 <Peaker> jlouis, cool
14:59:00 <jlouis> Peaker: we are not done yet :)
14:59:17 <jlouis> Although it helps tremendously to hand the RTS -A3M here
15:00:18 <Phyx-> hmm. how does GHC know if a lhs file is using bird or latex style? does it check during lexing whether a > or \begin was found at the start or  aline?
15:00:28 <danderson> Peaker: any idea how to demangle the symbol names? Doesn't look like gcc-c++-style mangling
15:00:40 <Saizan> zdec ?
15:01:11 <danderson> zdec?
15:01:16 <danderson> google knows nothing about this
15:02:11 <Saizan> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames
15:04:44 <danderson> thanks
15:07:31 <Null-A> Which package declares an instance of Read for Integers?
15:07:37 <danderson> wow, I'm very confused now. Building the examples with the provided Makefile produces no LLVM linker errors
15:07:54 <danderson> despite having no references on where to find the libs
15:07:57 <zygoloid> Null-A: base :)
15:08:14 <danderson> which makes sense, in a way... Since the bindings would be statically linking with the LLVM libs
15:08:17 <Null-A> zygoloid: so I don't need to import anything?
15:08:39 <zygoloid> Null-A: just the Prelude, so no.
15:09:51 <Null-A> zygoloid: oh I figured out my mistake =)
15:11:25 <sinelaw> does anyone know of a paper combining info theory with functional programming ?
15:11:35 <ddarius> To what end?
15:11:54 <sinelaw> any end
15:12:28 <sinelaw> well in my case, i just need to summarize a paper about something with info theory and any other field, and i thought that direction could be interesting
15:12:32 <ddarius> sinelaw: Chaitin's work re Omega and similar things sorta does this.
15:12:56 <danderson> silly question, but does ghc use `ld` on linux as the linker?
15:13:12 <danderson> That is, if I pass -optl -w to ghc, is it `ld` that is getting that flag?
15:14:27 <Saizan> yes, when you compile
15:14:44 <danderson> right. Thanks.
15:14:51 <sinelaw> @type null
15:14:52 <lambdabot> forall a. [a] -> Bool
15:15:00 <sinelaw> @src null
15:15:00 <lambdabot> null []     = True
15:15:01 <lambdabot> null (_:_)  = False
15:15:07 <danderson> okay, so apparently passing --make is enough to make ghc smart and link against the right libraries automagically
15:15:20 <danderson> fun.
15:15:45 <Saizan> ah, yeah, you should always use --make, unless you've an external build system doing all the chasing
15:16:14 <Saizan> the "right libraries" are listed in the package information registered with ghc-pkg
15:17:12 <danderson> right, that makes sense now. The fact that it didn't previously is probably a sign that I should be getting sleep
15:17:21 <sinelaw> ddarius ooh thanks!
15:17:22 <danderson> not messing with compilers
15:17:32 <orbisvicis> can I create a class identical in every way to another except having extra constructors?
15:17:50 <Saizan> classes don't have constructors
15:17:54 <orbisvicis> *type
15:18:22 <Saizan> not so transparently as you might hope
15:19:16 <Saizan> "data NewType = Old OldType | ... extra constructors here .." is a way to do that
15:24:05 <jlouis> heh, it *really* helps giving combinatorrent a larger nursery
15:27:30 <orbisvicis> Saizan: by not so transparently, do you mean the type of "Constructor_in_oldtype::NewType" remains OldType ?
15:27:54 <roconnor> is there an extended euclidian algorithm somewhere?
15:28:30 <ddarius> roconnor: I'm pretty sure there are ones in those sundry "algebra" libraries.
15:28:42 <Saizan> orbisvicis: yeah, you've to wrap it with the "Old" constructor of NewType
15:29:44 <ddarius> roconnor: For example, http://hackage.haskell.org/packages/archive/constructive-algebra/0.1.2/doc/html/Algebra-Structures-EuclideanDomain.html#v%3AextendedEuclidAlg
15:30:02 <xerox> roconnor, there's monochrom's http://www.vex.net/~trebla/haskell/calculator/Calculator.html
15:33:56 <lyndon> Hi, I'm trying to load my snap site in ghci, and I'm getting an error with Control.Monad.Trans: "it was found in multiple packages: monads-fd-0.1.0.1 mtl-1.1.0.2". I don't have a problem building with cabal since it specifies the monads-fd package, but is there a way to get it working in ghci?
15:36:06 <lyndon> I think I've found a solution: {-# LANGUAGE PackageImports #-} :)
15:37:45 <jbapple> I don't understand GHCi's printing of this GADT:
15:37:50 <jbapple> data Equal a b where
15:37:50 <jbapple>     Equal :: Equal a a
15:37:59 <jbapple> (That's how it is in my text file)
15:38:15 <jbapple> > :i Equal
15:38:15 <jbapple> data Equal a b where
15:38:15 <jbapple>   Equal :: forall a. (a1 ~ a) => Equal a a
15:38:16 <lambdabot>   <no location info>: parse error on input `:'
15:38:23 <jbapple> That's how ghci sees it
15:38:31 <jbapple> What is a1?
15:38:50 <xerox> a ghost type!
15:39:13 * jbapple hides under the covers
15:39:14 <SonOfLilit> in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25654#a25654 am I correct to think that solve is effectively memoized?
15:39:43 <jbapple> I would understand if the constraint were "(b ~ a)"
15:39:51 <jbapple> or the parameters were named a and a1
15:40:09 <jbapple> Or this definition actually used phantom types
15:40:27 <jbapple> But it's not and they aren't and it doesn't
15:40:49 <jbapple> (This is GHC 6.12.2, btw)
15:41:05 <Saizan> what does :t Equal says?
15:41:33 <jbapple> Equal :: Equal a a
15:41:48 <cdsmithus> Okay, the documentation for  Data.ByteString.hGet says "If there is any data to read, then hGet  will not block, instead it will return whatever data is available without blocking."  is it lying?
15:42:27 <Saizan> looks like "just" a bug in the prettyprinter for declarations then?
15:43:46 <jbapple> Saizan: I wouldn't want to speculate. Maybe the bug is in :t printing, where a equality constraint is not printed
15:44:08 <jbapple> Saizan: Or the bug is in my brain, and there's a good reason for it that I don't get
15:44:26 <cdsmithus> i.e., try typing 'B.hGet stdin 5' in GHCi.  That documentation seems to imply it should wait for one character and then do an early return.  Instead it waits for all 5
15:44:39 <SonOfLilit> say
15:45:08 <SonOfLilit> if I want to use modulo arythmetic in haskell, is there a num derivative that does this behind the scenes for me?
15:46:29 <Saizan> jbapple: well, how GHC sees gadts internally is indeed "normal adts + equality contexts" but in that view the right type would be  "Equal :: forall a b. (a ~ b) => Equal a b", that's my understanding at least
15:46:39 <SonOfLilit> i.e. something like (Num IntMod a)?
15:46:47 <cdsmithus> SonOfLilit, since the arithmetic operators need an extra argument... seems unlikely.  Unless you reify the mod base as a type.  Then you could do it; it would just be ugly.
15:46:58 <SonOfLilit> that's what I meant
15:47:02 <SonOfLilit> why ugly?
15:47:08 <Saizan> not so ugly
15:47:42 <SonOfLilit> is there something like this that I can get from hackage / already in the distribution?
15:50:33 * Saizan doesn't know
15:51:06 <jbapple> http://hackage.haskell.org/trac/ghc/ticket/4087
15:51:55 <SonOfLilit> hmmm, can that even be done? passing a value as a type constructor param?
15:52:20 <roconnor> I find that I'm getting used to (f .). g
15:53:00 <SonOfLilit> roconnor: what does that do?
15:53:34 <roconnor> @type \f g -> (f .) . g
15:53:35 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
15:53:39 <roconnor> gah
15:53:43 <roconnor> Cale!!!!
15:53:53 <roconnor> @type \f g -> (f Prelude..) Prelude.. g
15:53:55 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
15:54:10 <roconnor> SonOfLilit: it takes f and composes it with a binary function g
15:54:19 <Saizan> the more general type is actually nicer to read :)
15:54:34 <roconnor> you can and more brackets
15:54:44 <roconnor> @type \f g -> ((f Prelude..) Prelude..) Prelude.. g
15:54:46 <lambdabot> forall b c a a1 a2. (b -> c) -> (a2 -> a1 -> a -> b) -> a2 -> a1 -> a -> c
15:54:56 <roconnor> will compose f with a trinary function g
15:55:43 <SonOfLilit> can you write a general version?
15:56:52 <soupdragon> @pl \f -> (f .) . g
15:56:53 <lambdabot> (. g) . (.)
15:56:55 <soupdragon> @pl \g -> (f .) . g
15:56:55 <lambdabot> ((f .) .)
15:56:58 <soupdragon> @pl \f g -> (f .) . g
15:56:59 <lambdabot> (.) . (.)
15:57:19 <hpc> :t (.) (.)
15:57:19 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
15:57:24 <soupdragon> :t let it = (.) . (.) in ?f . it . it . it . ?g
15:57:25 <lambdabot> forall b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) a b1 (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4, Functor f5, ?f::(f (
15:57:26 <lambdabot> f1 (f2 (f3 (f4 (f5 a))))) -> f (f1 (f2 (f3 (f4 (f5 b1)))))) -> b, ?g::f6 (a -> b1), Functor f6) => f6 b
15:57:46 <roconnor> SonOfLilit: not without crazy typeclass stuff and haskell extensions
15:57:50 <soupdragon> :t let it = (Prelude..) . (Prelude..) in ?f . it . it . it . ?g
15:57:51 <lambdabot> forall b a a1 a2 a3 b1 c a4 a5 (f :: * -> *). (?f::((a -> a1 -> a2 -> a3 -> a4 -> a5 -> b1) -> a -> a1 -> a2 -> a3 -> a4 -> a5 -> c) -> b, ?g::f (b1 -> c), Functor f) => f b
15:58:02 <SonOfLilit> composeK 4 f g :: Int -> (b -> c) -> (ak -> ... -> a1 -> a) -> a -> c
15:58:14 <SonOfLilit> bummer
15:58:28 <temoto> http://codepad.org/QCGNRP2G Could anyone please help to rewrite this function to pass new random seed to calcNeuron on each iteration of 'map'? I was thinking about zipWith and somehow creating an infinite list of random seeds throw recursion of (_, next_seed) = next start_seed   but can't comeup with a proper one.
15:58:33 <soupdragon> where '4' is S (S (S (S Z))) in some very cleverly built GADT
15:59:28 <SonOfLilit> btw, reasking my question from before:
15:59:37 <SonOfLilit> in http://hackage.haskell.org/trac/ghc/ticket/4087, can I count on memoization?
16:00:23 <SonOfLilit> and the other q: is there/can I write a number type for arythmetic modulo n?
16:01:03 <BMeph> SonOfLilit: That composeK type makes no sense, but I think I can figure out what you mean... :)
16:06:34 * hackagebot snap-server 0.1.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.1.2 (GregoryCollins)
16:09:34 <SonOfLilit> no help with the modulo arythmetic?
16:10:32 <hpc> you'll have to roll your own, it seems
16:12:34 <writer> > head $ Data.Map.toList $ (foldl (\y x -> Data.Map.insert x (x * x) y) Data.Map.empty [20..2000])
16:12:35 <lambdabot>   Not in scope: `Data.Map.toList'Not in scope: `Data.Map.insert'Not in scope:...
16:12:49 <writer> > head $ M.toList $ (foldl (\y x -> M.insert x (x * x) y) M.empty [20..2000])
16:12:50 <lambdabot>   (20,400)
16:12:56 <writer> > head $ M.toList $ (foldl (\y x -> M.insert x (x * x) y) M.empty [20..20000])
16:12:58 <lambdabot>   (20,400)
16:13:01 <writer> > head $ M.toList $ (foldl (\y x -> M.insert x (x * x) y) M.empty [20..200000])
16:13:02 <lambdabot>   *Exception: stack overflow
16:14:21 <roconnor> > let s = map (\n -> 1:zipWith ((sum .). zipWith (*)) s (reverse (take n (iterate (\l -> 1:zipWith (+) l (tail l++[0])) [1])))) [0..] in take 25 $ map sum s
16:14:23 <lambdabot>   [1,2,3,5,8,13,22,39,71,131,243,452,843,1578,2967,5604,10627,20215,38538,735...
16:14:35 <roconnor> oh crap
16:14:39 <roconnor> that isn't right
16:14:52 <beutdeuce> technically, both the left and the right fold are equally fast when it comes to reversing a list, right?
16:15:43 <zachk> beutdeuce: i may be naive but how do you use foldr to reverse a list?
16:16:07 <beutdeuce> foldr (\x acc -> acc ++ [x]) []
16:16:22 <soupdragon> zachk, you can use the equation  foldr (flip f) z l = foldl f z (reverse l)  to derive it
16:18:31 <BMeph> beutdeuce: That foldr use is O(n^2).
16:19:22 <beutdeuce> is (:) constant?
16:20:20 <beutdeuce> oh, i see, nvm, got confused a bit
16:24:23 <soupdragon> > iterate (+142857) 0
16:24:24 <lambdabot>   [0,142857,285714,428571,571428,714285,857142,999999,1142856,1285713,1428570...
16:26:35 <Mathnerd314> question: what Haskell idioms could one use instead of loops?
16:26:48 <hpc> tail recursion
16:26:51 <soupdragon> iterate
16:27:06 <beutdeuce> folds
16:27:42 * hackagebot hstest 0.0.0 - Tests properties in specified modules via QuickCheck; uses GHC api for speed  http://hackage.haskell.org/package/hstest-0.0.0 (DaveHinton)
16:27:54 <SonOfLilit> I want to memoize a function (Int->Int->Integer). How do I?
16:29:08 <roconnor> SonOfLilit: make a a list of lists
16:29:14 <roconnor> acutally make an array of arrays
16:29:18 <roconnor> but start with a list of lists
16:29:45 <Saizan> or use data-memo-combinators (i think that's the name..) on hackage
16:29:52 <SonOfLilit> oh, gotta add, it's recursive
16:30:41 <SonOfLilit> roconnor: I can't find how to make a list of lists without breaking on recursion
16:31:21 <roconnor> SonOfLilit: this is how I do it
16:31:42 <roconnor> you start with f x y = ... (f e1 e2) ...
16:31:53 <beutdeuce> ,[]:[]:[]:[]
16:32:17 <roconnor> I then define f0 x y = (memoF!!x)!!y
16:32:59 <copumpkin> > []:[]
16:33:00 <lambdabot>   [[]]
16:33:03 <roconnor> and then I define memoF = map (\x -> map (\y -> f x y) [0..]) [0..]
16:33:12 <roconnor> and then, once I see that is all working
16:33:17 <soupdragon> > 3 3
16:33:18 <lambdabot>   Ambiguous type variable `t' in the constraint:
16:33:19 <lambdabot>    `GHC.Num.Num t' arising f...
16:33:22 <roconnor> I replace (f e1 e2) with (f0 e1 e2)
16:33:48 <roconnor> then I replace my lists with arrays by adding listOfArray (0,upperbound) to memoF
16:33:53 <roconnor> er
16:33:55 <roconnor> arrayOfList
16:34:22 <SonOfLilit> roconnor: that's what I did
16:34:45 <SonOfLilit> but it errors on the stage where I replaced the recursive call
16:35:12 <roconnor> SonOfLilit: perhaps you forget the step where you check that it all works
16:35:21 <roconnor> before replace (f e1 e2) with (f0 e1 e2)
16:35:22 <SonOfLilit> it works great
16:35:31 <beutdeuce> > 1+1
16:35:31 <roconnor> make sure f0 and f have the same time
16:35:32 <lambdabot>   2
16:35:32 <SonOfLilit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25654#a25654
16:35:34 <roconnor> type
16:35:42 <SonOfLilit> this is just before
16:35:54 <beutdeuce> > take 10 [2^n|n<-[1..]
16:35:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:36:03 <SonOfLilit> no wait
16:36:10 <SonOfLilit> that was much before
16:36:13 <beutdeuce> > take 10 [2^n|n<-[1..]]
16:36:14 <soupdragon> > take 10 [2^n|n<-[1..]]
16:36:14 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
16:36:15 <SonOfLilit> let me update
16:36:15 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
16:36:35 <soupdragon> > iterate (join (+)) 1
16:36:36 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
16:36:36 <beutdeuce> do list comprehensions use right fold?
16:36:55 <soupdragon> beutdeuce, I think they use the list monad (concatMap) actualy
16:37:04 <soupdragon> of course that function can be defined as a fold...
16:37:12 <beutdeuce> ah, ooo, how does that iterate join work?
16:37:23 <soupdragon> join (+) = \x -> x + x
16:37:30 <soupdragon> so it just doubles each time
16:37:42 <beutdeuce> creative :)
16:37:46 <roconnor> > let s = map (\n -> 1:zipWith ((sum .). zipWith (*)) (map reverse s) (reverse (take n (iterate (\l -> 1:zipWith (+) l (tail l++[0])) [1])))) [0..] in take 25 $ map sum s
16:37:47 <lambdabot>   [1,2,3,5,8,14,24,43,77,140,256,472,874,1628,3045,5719,10780,20388,38674,735...
16:37:57 <SonOfLilit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25654#a25655
16:39:37 <SonOfLilit> roconnor: your solution?
16:40:04 <SonOfLilit> or did you actually take mine apart and back again in these few minutes?
16:40:40 <roconnor> SonOfLilit: Well, now that the contest is over, it is my solution
16:40:53 <roconnor> I wanted to see if I could do it with lists instead of arrays
16:41:21 <beutdeuce> > let evens' n = take n $ iterate (\x -> 2^x) 1 in evens' 5
16:41:22 <lambdabot>   [1,2,4,16,65536]
16:41:47 <beutdeuce> nvm the name, was trying something out
16:42:01 <roconnor> SonOfLilit: I don't like all the calls to reverse
16:42:45 <roconnor> .
16:42:46 * hackagebot snap-server 0.1.3 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.1.3 (GregoryCollins)
16:43:49 <SonOfLilit> roconnor: I cannot seem to follow your code
16:45:42 <soupdragon> wait a sec
16:46:00 <roconnor> > let s = map (\l -> 1:zipWith ((sum .). zipWith (*)) (map reverse s) (reverse l)) (inits (iterate (\l -> 1:zipWith (+) l (tail l++[0])) [1])) in take 25 $ map sum s
16:46:02 <lambdabot>   [1,2,3,5,8,14,24,43,77,140,256,472,874,1628,3045,5719,10780,20388,38674,735...
16:46:05 <soupdragon> damn!
16:46:09 <soupdragon> I almost had a cool idea :))
16:46:16 <soupdragon> but it didn't work out. you can't memoize in the way I was hoping
16:46:46 <SonOfLilit> well
16:46:50 <beutdeuce> is it possible to write (take) using a fold?
16:46:58 <SonOfLilit> right now I can't memoize any way :/
16:47:17 <soupdragon> beutdeuce, sort of......
16:47:36 <soupdragon> beutdeuce, it would be a fold on the number - and you would have to make up some new functions for eating lsits
16:47:36 <fiasco_> anyone free to try and help finding a bug in a parser I'm writing?
16:47:59 <roconnor> SonOfLilit: I tried to give you some directions
16:48:27 <SonOfLilit> I followed them exactly, they led to a strange error that evades my debugging
16:48:38 <roconnor> SonOfLilit: get rid of your useless takewhile
16:50:04 <roconnor> write an operator  i `memo` j = (withfree!!i)!!j
16:50:19 <roconnor> then check to see that i `memo` j == i !!! j
16:53:40 <SonOfLilit> mmm, I also thought the takeWhile was useless... but without it, my code hangs, turns out
16:53:52 <fiasco_> anyone?
16:54:34 <temoto> fiasco_, you'd have better luck if you post the question without asking to ask.
16:55:49 <danderson> asking meta-questions will only get you meta-answers, it's better to save the round-trip
16:56:44 <fiasco_> well, I wrote a parser (http://pastebin.com/25pgqN5Q) and I'm having hard time finding a bug and need some help.
16:57:14 <soupdragon> fiasco_: this is a really long script
16:57:15 <roconnor> SonOfLilit: then you are doing something wrong
16:57:25 <soupdragon> fiasco_: I can't look at this and just see where the error is
16:57:41 <fiasco_> in my little toy lang. a program is a composite and a composite is a list of expressions and definition ended with an expression
16:57:58 <soupdragon> my advice would be to delete all your code and start again
16:58:03 <fiasco_> the problem is with the semicolons.
16:58:34 <fiasco_> while it parse fine "[DE]; expr" it fails on "[DE]; expr;"
16:58:48 <fiasco_> i.e. im having a problem with the last ";"
16:59:44 <fiasco_> soupdragon: working on it for hours ;-(
17:00:15 <SonOfLilit> roconnor: yes, I probably am
17:00:59 <soupdragon> fiasco_, the reason I suggest it is because during a rewrite you'll get bored of repeating yourself.. and develop techniques that eliminate redundancy in the code - and also verify that each small peice is correct as you build up due to being more worried about the final thing
17:02:03 <SonOfLilit> roconnor: the sum would sum an infinite list without that takeWhile
17:02:34 <roconnor> ah
17:02:35 * fiasco_ is frustrated!
17:02:35 <roconnor> ok
17:02:41 <SonOfLilit> so the only wrong thing I did was calling it "memoized" when it also post-processed
17:02:49 <SonOfLilit> and I can guess the bug
17:03:06 <fiasco_> soupdragon: the sad thing is it works perfect. the only problem is the last ";" of the code
17:05:41 <ivt> hi, I've learnt Python as my first programming language, and I want to move on to something else.. I was thinking C++ or Java, but do you think I could learn haskell first?
17:05:50 <soupdragon> :|
17:07:46 <ivt> oops
17:07:56 <SonOfLilit> ivt: Haskell was the hardest language for me to learn
17:07:57 <hypercube31> ivt: if you think you want to learn haskell learn more about the lambda's in python first
17:08:13 <SonOfLilit> but probably the most fun and the most teaching
17:08:20 <hypercube31> SonOfLilit, its easy if you get what lambda calc is about, as is scheme, if you dont then ur screwed
17:08:21 <ivt> well, I think I'm fairly proficient in python
17:08:53 <ivt> is it generally a fast language?
17:09:00 <hypercube31> ivt: lambda calculus.. learn it beyond just what has to do with python, cause python is still an imperative language... haskell is functional.. different paradigm
17:09:28 <hypercube31> ivt: learn what you want, implementations change over time with speed.. thats not a good reason to learn a language
17:09:47 <hypercube31> ivt, whats more important is whats called domain specific.. what you're thinking of using it for.. ie: the right tool for the job
17:10:39 <ivt> hm , what would you say haskell's main domain of application would be?
17:10:48 <copumpkin> "general computation"
17:10:58 <hypercube31> ivt: read the wiki page on it. ypi
17:11:02 <hypercube31> er
17:11:10 <copumpkin> "the work you'd give a linear-bounded automaton"
17:11:20 <hypercube31> ivt: its way better when it comes to math based applications
17:11:35 <hypercube31> ivt: when you understand what functional programming is, then you'll realize where its better suited
17:11:47 <ivt> alright, thanks
17:12:14 <hypercube31> if nothing else to broaden your perspective past just plain imperative langs
17:12:19 <roconnor> @type unfoldr
17:12:20 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:12:52 <ivt> well, I wanted to do a functional language for that reason
17:14:05 <hypercube31> ivt: the way i went about it, i learned what the church-turing thesis was about, then learned what lambda calculus was good for and why.. and then went into trying to understand what generally functional programming was about, once you do that you'll know what language you'll want to play with
17:14:23 <hypercube31> ivt: otherwise you're going to have a hell of a time trying to do anything useful and grasp much
17:14:57 <copumpkin> that's one way of approaching it
17:15:01 <copumpkin> I don't think it's a common one though
17:15:06 <zakwilson> Speed isn't a good reason not to learn a language, but Haskell is generally pretty fast. I'd say GHC is generally comperable to Java, and sometimes it's actually faster than C.
17:15:14 <copumpkin> there are several lambda calculi
17:15:37 <soupdragon> yes but there is only one lambda calculus
17:15:46 <uorygl> The untyped lambda calculus is the biggest lambda calculus, isn't it?
17:17:13 <copumpkin> it's the original one :)
17:18:11 <copumpkin> lots of mathematicians dying these days
17:18:34 <Saizan> SonOfLilit: sorted it out? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25654#a25656 <- this works anyhow, the duplication is to handle (!!!!) being called with negative arguments
17:18:46 <hypercube31> "After the original system was shown to be logically inconsistent (the KleeneRosser paradox), Church isolated and published in 1936[3]  just the portion relevant to computation, what is now called the untyped lambda calculus."
17:20:10 <SonOfLilit> Saizan: thank you, I already did as much
17:21:09 <SonOfLilit> now I'm trying to optimize by adding the modulus operation somewhere in the middle
17:21:15 <SonOfLilit> but the results come out wrong
17:21:59 <wli> ivt: LYAH and YAHT are probably the ways to go.
17:35:52 <SonOfLilit> good night
17:36:03 <SonOfLilit> thank you all for your help and the pleasant discussions :)
17:38:01 * hackagebot meldable-heap 2.0.1 - Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues  http://hackage.haskell.org/package/meldable-heap-2.0.1 (JimApple)
17:58:06 * hackagebot extcore 0.8 - Libraries for processing GHC Core  http://hackage.haskell.org/package/extcore-0.8 (TimChevalier)
17:58:45 <mamalujo> do fixity declarations work with type operators?
18:03:08 <tommd> mamalujo: I don't think so.
18:05:38 <copumpkin> I thought they did
18:11:00 <JoeyA> Is there a shorter way to do groupBy (\a b -> length a == length b) xs ?
18:11:14 <copumpkin> (==) `on` length
18:11:26 <JoeyA> @hoogle on
18:11:26 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:11:26 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
18:11:26 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
18:11:39 <ddarius> Probably better to do a Schwartzian transform for that.
18:11:47 <copumpkin> yeah
18:11:53 <copumpkin> maybe not actually?
18:12:13 <copumpkin> @src groupBy
18:12:13 <lambdabot> groupBy _  []       =  []
18:12:13 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
18:12:13 <lambdabot>     where (ys,zs) = span (eq x) xs
18:12:28 <copumpkin> it should be fine?
18:13:18 <copumpkin> oh, it might duplicate calls on the boundaries
18:13:20 <ddarius> copumpkin: That will calculate length x for each element in span.
18:13:53 <JoeyA> `on` was what I was looking for, thanks
18:14:05 <JoeyA> groupBy ((==) `on` length) [[1],[2],[3,4],[5,6]] -- I like how it reads like prose now :-)
18:14:25 <soupdragon> JoeyA, yeah that's a good sign
18:15:55 <byorgey> preflex: seen conal
18:15:56 <preflex>  conal was last seen on #haskell 1 day, 7 hours, 39 minutes and 28 seconds ago, saying: aristid: as in Pan & Vertigo
18:17:23 <jbapple> preflec: seen preflex
18:17:29 <jbapple> preflex: seen preflex
18:17:29 <preflex>  what
18:18:00 <soupdragon> preflex: impersonate mauke
18:18:25 <mauke> did you mean: be
18:19:13 * hackagebot meldable-heap 2.0.2 - Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues  http://hackage.haskell.org/package/meldable-heap-2.0.2 (JimApple)
18:20:22 <EvanR> i dont get this pattern. in the doc, runState is a constructor and evalState is a regular function
18:20:27 <EvanR> confusing
18:20:44 <hpc> runState can't be a constructor with a lowercase 'r'
18:20:46 <mauke> @src State
18:20:46 <lambdabot> Source not found. My brain just exploded
18:20:53 <mauke> preflex: be mauke
18:20:54 <preflex>  eval: BEGIN{$^H {q}=sub:{my$ my=$ _[1];$ my!~ /\$/?$ my:sub: {my% my=@ _;(my$ my=$ my)=~s '\$(\w+)'$ my{$ 1}'eg;$ my}};$ ^H |=0x28000}  'my name is $name and im $age years old'->(age => 'ten pounds of flax', name => 'nanonyme')
18:20:55 <EvanR> ok its a record accessor
18:21:32 <soupdragon> mauke is a perl script :(
18:21:41 <mauke> preflex: be mauke
18:21:41 <preflex>  I've solved the halting problem WITH A SHOTGUN
18:22:11 <JoeyA> I've used this pattern more than once:  delta :: (Num a) => [a] -> [a]; delta [x] = []; delta (x:y:zs) = y-x : delta (y:zs)  .  Instead of matching [] and (x:xs), I match [x] and (x:y:zs) so I can work on 2 adjacent values.
18:22:25 <JoeyA> Is there a fold-ish function for that?
18:22:41 <JoeyA> I know I can do a cumulative sum with scanl (+) 0 xs, now I want to go the other way around :-)
18:23:00 <mauke> > ap zip tail "abcd"
18:23:01 <lambdabot>   [('a','b'),('b','c'),('c','d')]
18:23:01 <dolio> zipWith (-) (tail l) l
18:23:25 <mauke> @quote zip`a
18:23:25 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
18:23:55 <JoeyA> ap is a monadic function.  Does it use the list monad for that?
18:24:03 <mauke> no
18:24:16 <byorgey> JoeyA: no, ap works in any monad.
18:24:19 <byorgey> @type ap
18:24:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:24:21 <copumpkin> (a->) in that case
18:24:29 <dolio> @type zipWith subtract `ap` tail
18:24:30 <lambdabot> forall a. (Num a) => [a] -> [a]
18:24:34 <mauke> > ap f g x
18:24:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:24:35 <lambdabot>    `GHC.Show.Show a'
18:24:35 <lambdabot>      a...
18:24:37 <dolio> @type zipWith subtract `ap` tail $ [1..10]
18:24:37 <lambdabot> forall a. (Num a, Enum a) => [a]
18:24:38 <mauke> aww
18:24:43 <dolio> > zipWith subtract `ap` tail $ [1..10]
18:24:44 <lambdabot>   [1,1,1,1,1,1,1,1,1]
18:25:03 <copumpkin> <*> is one character shorter
18:26:21 <mauke> > ap (+) f x
18:26:22 <lambdabot>   x + f x
18:26:40 <JoeyA> Are <*> and ap the same, except <*> requires a more specific type?
18:26:52 <mauke> s/more/less/
18:27:04 <copumpkin> all monads are applicatives, but not vice versa
18:27:09 <JoeyA> Ah
18:27:26 <JoeyA> > (zip<*>tail) "abcd"
18:27:27 <lambdabot>   [('a','b'),('b','c'),('c','d')]
18:28:10 <copumpkin> > uncurry (liftA2 (,))
18:28:11 <lambdabot>   Overlapping instances for GHC.Show.Show ((f a, f b) -> f (a, b))
18:28:11 <lambdabot>    arising...
18:28:12 <JoeyA> > zipWith (-) <$> tail $ [1,2,3,4]
18:28:14 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
18:28:14 <lambdabot>    arising from a use ...
18:28:31 <JoeyA> > (zip<*>tail) "abcd"
18:28:32 <lambdabot>   [('a','b'),('b','c'),('c','d')]
18:28:53 <JoeyA> zipWith subtract <$> tail $ [1,2,3,4]
18:28:58 <JoeyA> > zipWith subtract <$> tail $ [1,2,3,4]
18:28:59 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
18:28:59 <lambdabot>    arising from a use ...
18:29:06 <JoeyA> > zipWith (-) `ap` tail $ [1,2,3,4]
18:29:07 <lambdabot>   [-1,-1,-1]
18:29:37 <JoeyA> (I know, subtract is a flipped version of (-))
18:30:03 <mauke> > zipWith (-) <*> tail $ [1,2,3,4]
18:30:03 <lambdabot>   [-1,-1,-1]
18:30:13 <JoeyA> Yup.  I habitually threw in a <$>
18:30:43 <JoeyA> now I'd like to understand how the heck that works.
18:30:53 <mauke> @src ap
18:30:54 <lambdabot> ap = liftM2 id
18:31:05 <JoeyA> @src <*>
18:31:06 <lambdabot> Source not found. Are you on drugs?
18:31:11 <mauke> JoeyA: do you understand zip?
18:31:12 <JoeyA> @src (<*>)
18:31:12 <lambdabot> Source not found. It can only be attributed to human error.
18:31:15 <JoeyA> Yes
18:31:19 <mauke> http://mauke.ath.cx/tmp/flow.png
18:31:33 <JoeyA> Did you just draw that up?
18:31:39 <mauke> no
18:32:09 <mauke> > zipWith (-) <*> tail $ [1,2,3,4] :: [Expr]
18:32:10 <lambdabot>   [1 - 2,2 - 3,3 - 4]
18:32:30 <mauke> > ap (zipWith (-)) tail [1,2,3,4] :: [Expr]
18:32:31 <lambdabot>   [1 - 2,2 - 3,3 - 4]
18:32:45 <JoeyA> You're telling me Haskell can do algebra?!
18:32:46 <ddarius> mauke just relabelled diagrams from APL!
18:32:51 <mauke> > (zipWith (-)) [1,2,3,4] (tail [1,2,3,4]) :: [Expr]
18:32:52 <lambdabot>   [1 - 2,2 - 3,3 - 4]
18:33:09 <mauke> > zipWith (-) [1,2,3,4] [2,3,4] :: [Expr]
18:33:09 <lambdabot>   [1 - 2,2 - 3,3 - 4]
18:33:34 <JoeyA> solve (== 0) (x**2 - 2*x + 1 :: Expr)
18:33:46 <mauke> > (x**2 - 2*x + 1 :: Expr
18:33:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:33:52 <mauke> > x**2 - 2*x + 1 :: Expr
18:33:52 <lambdabot>   x**2 - 2 * x + 1
18:34:06 <mauke> > x^2 - 2*x + 1 :: Expr
18:34:07 <lambdabot>   x * x - 2 * x + 1
18:34:33 <ddarius> @google "Chapter 3" "Defining functions" trains of verbs
18:34:33 <lambdabot> No Result Found.
18:34:34 <JoeyA> Is Expr in a module?
18:34:57 <ddarius> http://www.jsoftware.com/help/learning/03.htm
18:35:00 <mauke> anyway, we want \xs -> zip xs (tail xs), which is an instance of the general \x -> f x (g x)
18:35:03 <mauke> which is ap
18:35:28 <mauke> except I called it c x (g x) in the diagram
18:35:32 <JoeyA> hmm
18:35:51 <mauke> yes, Expr is in a module
18:36:12 <ddarius> (zip tail) in J (if we consider zip a dyad and tail a monad.
18:36:19 <ddarius> )
18:36:28 <mauke> http://hackage.haskell.org/packages/archive/simple-reflect/0.2/doc/html/Debug-SimpleReflect.html
18:37:47 <JoeyA> (\xs -> zip xs (tail xs)) [1,2,3,4]
18:37:56 <JoeyA> > (\xs -> zip xs (tail xs)) [1,2,3,4]
18:37:58 <lambdabot>   [(1,2),(2,3),(3,4)]
18:38:00 <JoeyA> > zip <*> tail $ [1,2,3,4]
18:38:01 <lambdabot>   [(1,2),(2,3),(3,4)]
18:42:09 <ddarius> (,. }.) in J except that it errors if the lists aren't the same length.
18:43:18 <EvanR> how learned to stop worrying and love StateT
18:43:35 <EvanR>   i^
18:45:57 <JoeyA> > zipWith subtract <*> tail $ [1,4,9]
18:45:58 <lambdabot>   [3,5]
18:46:09 <JoeyA> > zipWith subtract <*> tail $ [] -- should be an error
18:46:10 <lambdabot>   []
18:46:33 <FunctorSalad> ziplists are often the topic in code fragments recently, here
18:46:34 <mauke> > zipWith subtract =<< tail $ []
18:46:34 <lambdabot>   *Exception: Prelude.tail: empty list
18:46:37 <mauke> happy?
18:46:53 <JoeyA> heh
18:47:26 <mauke> > zipWith subtract =<< tail $ [1,4,9]
18:47:27 <lambdabot>   [-3,-5]
18:47:29 <FunctorSalad> not making any conclusions in particular...
18:48:18 <JoeyA> ah, I guess laziness is kicking in here
18:48:21 <JoeyA> >  (\xs -> zip xs (tail xs)) []
18:48:22 <lambdabot>   []
18:48:30 <JoeyA> No need to look at tail xs because xs is empty.
18:48:43 <JoeyA> @src (=<<)
18:48:43 <lambdabot> f =<< x = x >>= f
18:48:43 <mauke> yes, and because zip checks its first argument first
18:49:14 <ddarius> J amuses me so.
18:49:20 * hackagebot snap-server 0.1.4 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.1.4 (GregoryCollins)
18:49:23 <mauke> see that flow diagram? (=<<) is like ap but puts the function in the other argument slot
18:49:28 <FunctorSalad> @let zipAp f x = filter (\(_,i) (_,j) -> i == j) ((zip f [0..]) =<< (zip x [0..]))
18:49:28 <lambdabot>  <local>:20:20:
18:49:29 <lambdabot>      The lambda expression `\ (_, i) (_, j) -> i == j'
18:49:29 <lambdabot>      h...
18:50:03 <JoeyA> > zipWith (-) =<< tail $ [1,4,9]
18:50:05 <lambdabot>   [3,5]
18:50:08 <JoeyA> > zipWith (-) =<< tail $ []
18:50:09 <lambdabot>   *Exception: Prelude.tail: empty list
18:50:28 <mauke> zip (tail xs) xs
18:51:00 <JoeyA> > zip =<< tail $ [1,2,3]
18:51:01 <lambdabot>   [(2,1),(3,2)]
18:51:08 <JoeyA> > zip =<< tail $ []
18:51:09 <lambdabot>   *Exception: Prelude.tail: empty list
18:51:25 <JoeyA> > (\xs -> zip (tail xs) xs) $ [1,2,3]
18:51:26 <lambdabot>   [(2,1),(3,2)]
18:51:31 <JoeyA> > (\xs -> zip (tail xs) xs) $ []
18:51:32 <lambdabot>   *Exception: Prelude.tail: empty list
18:52:12 <EvanR> :t join
18:52:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:52:54 <EvanR> forkIO . flip execStateT (x,0) . forever $ do...
18:53:09 <EvanR> brrrr wrong. execStateT returns not IO ()
18:53:14 <EvanR> how do i 'ignore it'
18:54:55 <EvanR> lets try insertting a return () =<<
18:55:29 <EvanR> actually a <<
18:55:29 <mauke> did you mean: >> return ()
18:55:49 <EvanR> if you do that, the .s dont work
18:56:30 <EvanR> << not in scope
18:56:38 <mauke> (>> return ()) .
18:58:11 <EvanR> nice
18:58:14 <JoeyA> I still don't quite understand how zipWith (-) =<< tail $ [1,4,9] works.  Why isn't the return value wrapped in a monad or something?
18:58:27 <JoeyA> It seems like just about anything can be a monad.
18:58:47 <Axman6> (a ->) is a monad
18:59:08 <EvanR> it can only be a monad if it can wrap around any type, like a burrito
18:59:35 <JoeyA> What do you mean by (a ->) ?
18:59:47 <JoeyA> As in, a function with at least 1 argument?
18:59:50 <Axman6> functions
19:00:01 <pikhq> JoeyA: That's a partially-applied type.
19:00:35 <Axman6> > ((+) >>= (*)) 3
19:00:36 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
19:00:39 <Axman6> bleh
19:00:43 <Axman6> > ((2+) >>= (*)) 3
19:00:45 <lambdabot>   15
19:01:00 <Axman6> > ((2+) >>= (*) >>= (+)) 3
19:01:01 <lambdabot>   18
19:01:04 <JoeyA> Hmm.  In that case, I suppose <$> can be used to operate on the inner part of just about any function
19:01:08 * JoeyA tries it
19:01:31 <mauke> heh, "inner part"
19:02:02 <mauke> > (show <$> sqrt) 2
19:02:03 <lambdabot>   "1.4142135623730951"
19:02:40 <JoeyA> So <$> just means . when the RHS is a function?
19:02:53 <Axman6> yes
19:02:59 <JoeyA> okay
19:03:47 <JoeyA> now lists can also be a monad
19:03:49 <JoeyA> > do {a <- [1,2,3]; b <- [4,5,6]; return (a,b);}
19:03:50 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
19:04:01 <JoeyA> Now I get to guess what <$> means to a list :-)
19:04:03 <EvanR> hrm i seem to have where in the wrong place
19:04:16 <EvanR> is this valid (x -> f x where f = ...)
19:04:19 <mauke> :t (<$>)
19:04:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:04:24 <JoeyA> I guess show just turns into map
19:04:28 <EvanR> erm, with the \
19:04:33 <JoeyA> > show <$> [1,2,3]
19:04:34 <lambdabot>   ["1","2","3"]
19:04:38 <JoeyA> > map show [1,2,3]
19:04:39 <lambdabot>   ["1","2","3"]
19:04:51 <Axman6> > (\x ->  f x where f a = show a) 3
19:04:52 <lambdabot>   <no location info>: parse error on input `where'
19:04:59 <mauke> JoeyA: most functions are map
19:05:09 <JoeyA> "where" can only go on = expressions, if I'm not mistaken
19:05:18 <mauke> map, fmap, <$>, liftM, liftA
19:05:27 <JoeyA> > (\x -> let f a = show a in f x) 3
19:05:28 <lambdabot>   "3"
19:05:40 <mauke> oh, and (.), fmap, <$>, liftM, liftA
19:06:51 <JoeyA> > show . [1,2,3]
19:06:53 <lambdabot>   ["1","2","3"]
19:07:02 <JoeyA> what module does that?
19:07:14 <soupdragon> Functor
19:07:15 <JoeyA> Prelude Control.Applicative Control.Monad> show . [1,2,3] -- doesn't work
19:07:20 <Axman6> Cale's broken lambdabot does that
19:07:26 <soupdragon> (.) = fmap
19:07:36 <mauke> s/broken/awesome/
19:07:48 <mauke> s/Cale's/my/
19:07:50 <soupdragon> mauke++
19:07:54 <JoeyA> Functor?
19:08:04 <JoeyA> I tried Control.Functor
19:08:18 <Axman6> Functor is in the Prelude i believe
19:08:21 <mauke> JoeyA: lambdabot's (.) is fmap, not (Prelude..)
19:08:23 <Axman6> @index Functor
19:08:23 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:09:55 <JoeyA> So in regular Haskell, is <$> a generalization of (.) ?
19:09:58 <JoeyA> err, .
19:10:16 <mauke> @src <$>
19:10:16 <lambdabot> f <$> a = fmap f a
19:10:22 <mauke> @src Functor
19:10:22 <lambdabot> class  Functor f  where
19:10:22 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
19:10:31 <mauke> @src (->) fmap
19:10:31 <lambdabot> fmap = (.)
19:18:49 <airbrush> hehe I like that nick
19:19:06 <JoeyA> Which one?
19:21:24 <JoeyA> Is there a nested composition function?  I can do this:
19:21:27 <JoeyA> > let compose n f = foldl' (.) id $ replicate n f
19:21:28 <lambdabot>   not an expression: `let compose n f = foldl' (.) id $ replicate n f'
19:21:38 <JoeyA> > let compose n f = foldl' (.) id $ replicate n f in compose 4 (*2) $ 1
19:21:39 <copumpkin> :t iterate
19:21:39 <lambdabot>   16
19:21:40 <lambdabot> forall a. (a -> a) -> a -> [a]
19:21:54 <JoeyA> oh yeah
19:21:54 <mauke> > iterate (* 2) 1 !! 4
19:21:55 <lambdabot>   16
19:41:44 <c_wraith> > tail . fix $ (1:) . scanl (+) 1
19:41:46 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
19:42:02 <c_wraith> oh, oops
19:42:08 <c_wraith> > tail . fix $ scanl (+) 1
19:42:09 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
19:44:53 <BMeph> > head . take 4 . iterate (* 2)$1
19:44:54 <lambdabot>   1
19:45:05 <BMeph> > head . drop  4 . iterate (* 2)$1
19:45:06 <lambdabot>   16
19:49:28 <EvanR> what on earth does this error mean
19:49:30 <EvanR> http://codepad.org/spyMAT5r
19:50:28 <c_wraith> it means you haven't used fromIntegral enough.
19:50:31 <pastorn> EvanR: is that (init,0) that's messing with you?
19:50:35 <c_wraith> Word32 and Int are different types
19:50:41 <EvanR> i have a fromEnum there
19:50:52 <pastorn> EvanR: write (init, 0 :: Word32) or something
19:50:53 <EvanR> it should be Word32 everywhere else
19:52:02 <Cale> I don't think I understand why you're using StateT there
19:52:03 <EvanR> it gives me an error that 0 is expected to be Int
19:52:38 <EvanR> Cale: would you suggest a IORef
19:52:53 <c_wraith> I really don't think you want an MVar there.
19:52:58 <Cale> Given that you're already in IO, and you'r defining something which is local to an IO action...
19:53:07 <c_wraith> Maybe a SampleVar
19:53:20 <Cale> It wouldn't hurt at all to use an IORef instead of StateT
19:53:28 <EvanR> i do want an MVar
19:53:35 <EvanR> that simplifies the interface to the timer
19:53:56 <c_wraith> Oh, it's number of game steps
19:54:04 <c_wraith> I see.  Yeah, use an IORef internally
19:54:28 <c_wraith> IORefs are not evil...  When you're already in IO.
19:54:35 <lloy0076> Simple question but I can't seem to stumble across the answer: 'cabal install snap-server' works but it puts it in my local .cabal/bin directory. In my .cabal/config I have a site wide install directory with prefixes all setup but I can't figure out how to get cabal to use the sitewide versus the local installation directlory...
19:54:43 <EvanR> modifyIORef is too long :(
19:55:05 <EvanR> but i guess the StateT kick start line is also long
19:56:01 <Cale> lloy0076: Maybe you want --global ? I never install things globally with cabal myself.
19:56:10 <lloy0076> Ok, I shall try that.
19:56:23 <c_wraith> I mean, this feels like you just want something that increments a value, puts it into an MVar, and continues doing that forever.
19:56:30 <Cale> lloy0076: It helps to install everything as user because it means that if you mess things up, you don't need to reinstall GHC
19:57:51 <EvanR> im interested in the semantics of this timer, but at the moment id like to understand this error message
19:58:13 <EvanR> it keep thinking my state is (Word32, Int)
19:58:33 <lloy0076> @Cale: Thanks for that; it just dawned on me that cabal install --help would have answered me too so I shall make sure to try a --help next time before asking what are probably newbie-ish questions.
19:58:33 <lambdabot> Unknown command, try @list
19:58:46 <lloy0076> Cale: Thanks for that; it just dawned on me that cabal install --help would have answered me too so I shall make sure to try a --help next time before asking what are probably newbie-ish questions.
19:58:47 <SamB_XP> EvanR: needz moar fI
19:58:55 <EvanR> fI?
19:58:58 <EvanR> a
19:59:04 <SamB_XP> that's what I call fromIntegral
19:59:10 <SamB_XP> when I have to use it a lot
19:59:22 <c_wraith> EvanR: what do you think the state is?
19:59:28 <EvanR> ive seen fromEnum used when you want a Int
19:59:36 <EvanR> c_wraith: (Word32, Word32)
19:59:46 <Cale> :t fromEnum
19:59:46 <lambdabot> forall a. (Enum a) => a -> Int
20:00:09 <Cale> Though, fromEnum isn't a great way to convert Word32 to Int
20:00:17 <Cale> I think I'd go with fromIntegral
20:00:18 <EvanR> i was told it is
20:00:39 <EvanR> its all over the ffi bindings i was working on
20:00:46 <SamB_XP> fromIntegral can do it all, reliably
20:00:46 <EvanR> to convert from CInt to Int
20:00:55 <Cale> fromIntegral
20:01:20 <EvanR> so then youd say dont use toInteger, instead use fromIntegral?
20:01:37 <Cale> Well, toInteger is part of fromIntegral
20:01:47 <SamB_XP> fromIntegral can generally figure it out ;-)
20:02:01 <Cale> Yeah, I tend not to think about it and just use fromIntegral anyway
20:02:06 <EvanR> fromIntegral did not solve the error
20:02:21 <SamB_XP> must've used it in the wron place ;-)
20:02:28 <SamB_XP> add more typesigs, maybe
20:02:28 <EvanR> i dont see where it thinks its a Int
20:02:41 <EvanR> Word32 works with all those operations
20:03:25 <EvanR> stupid type inferrence gimickery
20:03:45 <c_wraith> I'd follow SamB_XP's advice, and add some type signatures around, to see where ghc disagrees with you
20:03:53 <EvanR> ok
20:03:55 <syntaxglitch> EvanR, type inference is optional y'know
20:03:57 <BMeph> EvanR: I have looked at that post, and I can tell you what's up with it...
20:03:59 <Cale> What is the type of getTicks?
20:04:08 <EvanR> IO Word32
20:04:22 <BMeph> Cale: (Better yet: what's the type of quantum... ;)
20:04:26 <EvanR> Int
20:04:27 <EvanR> ah
20:04:30 <BMeph> EvanR: Thank you. :)
20:04:40 <EvanR> now im confused
20:04:41 <Cale> BMeph: That much is in the type signature :)
20:04:56 <EvanR> so it thinks counter is an Int
20:04:59 <EvanR> got it
20:05:24 <EvanR> ill switch to IORefs
20:05:38 <BMeph> EvanR: No, don't do it!
20:05:42 <EvanR> ?
20:05:56 <Cale> BMeph: Don't argue with me ;)
20:06:00 <Cale> hehe
20:06:11 <BMeph> EvanR: If you do, I may not get to tell you that "UR DOIN IT RONG!!11!11!ichi1!" ;
20:06:18 <Cale> hehe
20:06:50 <EvanR> i need the IO for getTicks and putMVar, im not sure that warrants also using it for IO mutable variables just because i can
20:07:17 <Cale> EvanR: StateT over IO is almost always a mess
20:07:22 <EvanR> on the other hand it would probably reduce total characters of code
20:26:11 <danharaj> Is there a way to force it so that GHC rejects type signatures with implicit foralls? I think foralls make the types easier to read, and I want to enforce that habit for myself.
20:27:45 <Cale> I don't think there is...
20:28:12 <Cale> I haven't actually looked in the documentation for one though.
20:30:04 <unkanon> how do other functional languages do without monads? what do they use to replace monads, to help achieve better compositionality?
20:30:33 <Cale> Monad is just a particular interface on top of which a lot of common functions can be written.
20:30:47 <Cale> You can totally do without abstracting over those functions.
20:30:54 <danharaj> Monads are not special in Haskell, they are just types with certain operations.
20:31:10 <Cale> But I suspect what you really want to know is what other functional languages do without *the IO monad* in particular.
20:31:19 <unkanon> Cale: right, common functions, which means sharing code which means better compositionality
20:31:24 <Cale> (Note that it's really non-essentiall that the IO monad is a monad)
20:31:29 <Cale> non-essential*
20:31:31 <unkanon> Cale: no no I don't particualrly care about the IO monad
20:31:44 <unkanon> I mean how do they achieve compositionality without monads?
20:32:00 <Cale> By... a lot of techniques.
20:32:17 <danharaj> unkanon: Any language with a type system similar in power to Haskell's can define monads. Are you asking for other idioms that do some of the things monads can do?
20:32:44 <FunctorSalad> monads are more-or-less-special notationally...
20:32:57 <Cale> Monads are just one type of combinator library that we've picked out as being worth having a name, and while it's convenient that you get all the stuff in Control.Monad for free in exchange for defining a monad instance, it's not really essential.
20:33:01 <unkanon> danharaj: no, I'm asking how other functional languages that don't have type constructors and whatnot achieve compositionality
20:33:01 <FunctorSalad> unless you -XNoImplicitPrelude ...
20:33:18 <Cale> Oh, don't have type constructors?
20:33:18 <danharaj> unkanon: Any specific language you have in mind?
20:33:32 <FunctorSalad> but it's not easy to find something that'd fit the do notation and can't be made a monad
20:33:35 <Cale> Most functional languages have type constructors. At least, all the ML family.
20:33:46 <unkanon> ocaml (i don't really know if it doesn't have type constructors though) or maybe Clean
20:34:06 <Cale> O'Caml and Clean have type constructors
20:34:07 <syntaxglitch> Most functional languages that don't have type constructors don't really have types at all
20:34:13 <FunctorSalad> you don't count parameterized types?
20:34:27 <Cale> and you can work with monads in O'Caml and Clean
20:34:32 <FunctorSalad> (do the tycons have to be standalone at least in some contexts?)
20:34:40 <FunctorSalad> class arguments in hs...
20:34:43 <danharaj> unkanon: You can use monads in Clean. But I don't know if it's idiomatic. They don't use it for IO. They use uniqueness types for IO.
20:34:47 <Cale> Though the lack of typeclasses makes it a bit less fun
20:35:00 <unkanon> let me try to rephrase my question
20:35:02 <Cale> Clean has a limited form of typeclasses
20:35:09 <unkanon> :)
20:35:32 * syntaxglitch notes that F# is based on OCaml to some extent, and uses monads somewhat explicitly
20:35:38 <FunctorSalad> most languages have [] at least ;)
20:35:44 <FunctorSalad> most static ones
20:35:47 <danharaj> You can even define monads in C++ with a lot of template magic :p
20:35:51 <unkanon> what would be another substitute for monads, that would also give us the advantage of compositionality (like building on top of preexisting code like getting the stuff in Control.Monad for free like Cale mentioned)
20:36:13 <Cale> unkanon: Name any other programming abstraction
20:36:22 <unkanon> OO
20:36:26 <Cale> Sure.
20:36:34 <unkanon> oh
20:36:37 <syntaxglitch> unkanon, if you're thinking mostly in terms of functional languages, lisp macros are substitute for language feature X, for all values of X
20:36:44 <unkanon> so you're saying i have to think of monads as a paradigm?
20:36:51 <Cale> unkanon: Monads are even less disruptive than OO
20:37:00 <unkanon> Cale: right, i agree perfectly
20:37:03 <Cale> unkanon: Monad is essentially just an API
20:37:07 <unkanon> syntaxglitch: wow that's pretty powerful
20:37:22 <SamB_XP> syntaxglitch: even HM typing?
20:37:24 <FunctorSalad> hmm I'd credit more basic things for haskell's compositionality
20:37:41 <FunctorSalad> starting with first-class functions...
20:37:55 <danharaj> unkanon: Monads are not the paradigm. The paradigm is defining things correctly. A monad is a monad because it has the structure of one, not because you try to make it a monad.
20:37:58 <unkanon> FunctorSalad: right, but first-class functions is much easier to find in a language than to find type constructors
20:38:01 <Cale> Yeah, I don't really see the use of the monad abstraction as being really about compositionality.
20:38:02 <FunctorSalad> ... purity combined with types making information flow more visible... ans so on
20:38:10 <FunctorSalad> *and
20:38:15 <Cale> It saves a bit of work, and gives us a common interface to a bunch of libraries
20:38:27 <Cale> But it doesn't help those libraries work together any more than they already would.
20:38:42 <unkanon> Cale: yes i'm trying to refer to that "common interface"characteristic of monads
20:38:54 <unkanon> the fact that if you define bind and return you get a lot of stuff for free
20:38:57 <FunctorSalad> unkanon: it's still not clear to us (I think) which type constructors ML doesn't have
20:39:05 <SamB_XP> Cale: it does if some of them are libraries of things to do with whatever monad
20:39:12 <Cale> SamB_XP: That's true.
20:39:13 <FunctorSalad> (it has parameterized lists and so on at least, to my knowledge)
20:39:15 <syntaxglitch> SamB_XP, probably, if nothing else via something amounting to embedding a typed DSL or whatever absurd contraption people can come up with
20:39:25 <Cale> unkanon: Of course, it's possible to invent other common interfaces, and people do it all the time :)
20:39:29 <danharaj> Applicative also has that 'common interface'. So do arrows.  So do...
20:39:45 <SamB_XP> Functors?
20:39:46 <Cale> unkanon: and various languages have different ways to abstract over common interfaces: in OO, you use subtyping
20:39:55 <unkanon> FunctorSalad: i didn't mean to say ML doesn't have type constructors, i was just guessing :)
20:39:55 <danharaj> Common structure -> Common interface
20:40:29 <FunctorSalad> unkanon: the common interface thing could be emulated by just passing a dictionary explicitly, if we didn't have typeclasses for typeconstructors
20:40:29 <syntaxglitch> Most OO languages' notions of subtyping seem kinda broken if you ask me, but eh
20:40:29 <unkanon> then let's put it another way
20:40:31 <FunctorSalad> (as Monad is)
20:40:33 <Cale> unkanon: and of course, higher order functions can themselves be seen as a way to get that kind of abstraction over a common interface.
20:40:50 <Cale> (take the methods of that interface as parameters)
20:40:58 <unkanon> let's say i take away monads from haskell. how much more code would you have to type now? or would that not be the major disadvantage of losign monads?
20:41:09 <FunctorSalad> in the end they just save you the dict passing, save you finding out the name of the dict, and enable optimizations I guess (since the dict is the same every time for a given type)
20:41:17 <unkanon> FunctorSalad: a dictionary of functions?
20:41:28 <Cale> unkanon: We'd need to have separate definitions of things like forM and sequence, and such, for each monad that we used.
20:41:33 <syntaxglitch> unkanon, you can't really "take away" monads without taking away the language features used to express them, which are pretty fundamental
20:41:42 <Cale> unkanon: and we'd lose do-notation and would have to use separately named functions for each monad
20:41:46 <FunctorSalad> unkanon: yes. data MonadD m = MonadD { bind :: (a -> m b) -> m a -> m b, ... }
20:41:53 <Cale> unkanon: But people used to write code that way
20:41:59 <syntaxglitch> do notation is trivial, but losing type classes would kinda suck
20:42:08 <FunctorSalad> unkanon: ah. I admit we need type constructors as parameters of types here
20:42:19 <FunctorSalad> don't know if ML has that
20:42:52 <Cale> You'll see really old Haskell code from before typeclasses that explicitly recognises monads without being able to abstract over them
20:43:08 <unkanon> well i know haskell needs do to do things in order
20:43:14 <unkanon> but let's also consider haskell is not lazy anymore
20:43:15 <syntaxglitch> Cale, I think F# does exactly that today, for what it's worth
20:43:18 <SamB_XP> or before constructor classes, at any rate ...
20:43:19 <Cale> In fact, I don't know if it's still there, but there were even a few of those in GHC :)
20:43:31 <FunctorSalad> syntaxglitch: but mostly for convenience reasons (intEqual, stringEqual, pairEqual intEqual stringEqual, ...), no?
20:43:35 <unkanon> so take laziness _and_ monads away from haskell. how bad is it now? unusable?
20:43:39 <SamB_XP> I've seen code in Yhc so old it uses almost-monads
20:43:46 <FunctorSalad> of course there's not a sharp line between 'convenience' and 'fundamental' ;)
20:44:11 <Cale> unkanon: Haskell actually isn't specifically lazy, it's just non-strict, meaning that the compiler can evaluate things in whatever order it wants as long as the result and termination behaviour is the same as with lazy evaluation.
20:44:33 <Cale> unkanon: Laziness is important.
20:44:34 <unkanon> FunctorSalad: that's awesome, Lua basically works with dictionaries (it calls them metatables), that's how it jumps from closures to objects
20:44:42 <Cale> unkanon: Or at least, non-strictness is :)
20:44:52 <syntaxglitch> FunctorSalad, pretty much everything besides "data", "case" and lambdas are "conveniences"
20:45:06 <unkanon> Cale: but i'm just trying to elinate the need for do notation for argument's sake
20:45:07 <Cale> Nonstrictness is way more important to compositionality than recognising various libraries as monads.
20:45:10 <SamB_XP> syntaxglitch: is that so?
20:45:15 <SamB_XP> what about expressive power ?
20:45:23 <Cale> do-notation is totally unnecessary
20:45:30 <danharaj> do-notation is for suckers.
20:45:33 <danharaj> >_>;;;
20:45:35 <FunctorSalad> I tried an explicit dictionary in C# once so I can have arbitrary dependence of method signatures on the implementing type ;)
20:45:39 <Cale> (it's purely syntax sugar)
20:45:51 <SamB_XP> do notation certainly doesn't affect the expressive power of Haskell
20:45:55 <danharaj> (read my line again with Cale's line in mind and see the pun)
20:45:59 <FunctorSalad> instead of "a -> Konstant" ;)
20:46:06 <Cale> hehe
20:46:20 * SamB_XP groans about all-day suckers ...
20:46:37 <FunctorSalad> all-day?
20:46:59 <Cale> unkanon: Yeah, instead of using typeclasses, you can always just bundle all the functions you need into a datastructure and pass those around.
20:47:11 <FunctorSalad> ah. nonstrictness-related
20:47:11 <SamB_XP> Cale: assuming you have dependant types!
20:47:14 <FunctorSalad> ?
20:47:16 <Cale> SamB_XP: ?
20:47:25 <unkanon> Cale: so could you say that if haskell didn't have monads, that wouldn't affect its compositionality too much? (the reason I ask is because that channel 9 guy's video explaining monads, he kept saying it's all about compositionality)
20:47:30 <SamB_XP> typeclass dictionaries are dependantly-typed
20:47:33 <Cale> SamB_XP: I'm just talking about writing the code that typeclasses desugar into directly
20:47:41 <FunctorSalad> syntaxglitch: lets get rid of data through church encoding while we're at it ;)
20:47:44 <Cale> SamB_XP: I don't see how that is.
20:48:01 <SamB_XP> well, maybe I'm slightly overstating facts
20:48:02 <danharaj> unkanon: It's all about extracting the common thread between so many different kinds of computation. There are so many things that are monads that it is a very useful abstraction.
20:48:14 <SamB_XP> but they definitely have a big lambda!
20:48:18 <syntaxglitch> FunctorSalad, I think losing pattern matching/constructor laziness would be more fundamental, but I'm not sure
20:48:18 <FunctorSalad> syntaxglitch: lambda is fundamental in that you really don't want to implement safe beta-reduction on the text level yourself, I guess
20:48:40 <Cale> unkanon: Oh, I found that video really obnoxious, if you're talking about the one I'm thinking of.
20:49:31 <Cale> Though I sort of forget exactly what it was that bothered me.
20:49:41 <unkanon> danharaj: but isn't there something else that so many things are too? I mean, besides monads, aren't many things also xyz, where xyz is something else that we could use as a basis for threading everything together (besides monads)?
20:49:57 <unkanon> Cale: oh that would be my next wquestion :(
20:50:11 <Cale> unkanon: Sure, there's applicative functors, arrows, comonads, etc. etc.
20:50:28 <Cale> unkanon: Lots of general "shapes" that libraries might happen to fit into
20:50:32 <unkanon> Cale: ok, that's what i was asking for i guess
20:50:35 <danharaj> Monads are just the ones beginners see the most because they handle IO.
20:50:39 <unkanon> Cale: now let me ask something about that list
20:51:09 <unkanon> Cale: which one of those is the simpler to understand, as in, the one that would have more chances at being popular and "catching on"?
20:51:18 <syntaxglitch> Cale, what, no love for monoids? :(
20:51:24 <SamB_XP> unkanon: functors
20:51:27 <SamB_XP> definitely functors
20:51:36 <Cale> unkanon: hmm...
20:51:37 <Axman6> dons: you still around?
20:51:43 <danharaj> Functors are very easy to understand.
20:51:49 <SamB_XP> (the ordinary kind, not just applicative ones!)
20:51:52 <unkanon> Cale: you don't agree with SamB_XP ?
20:51:52 <danharaj> But they don't have that much structure.
20:52:03 <Cale> unkanon: I usually don't think of them in terms of "catching on" or not.
20:52:10 * syntaxglitch coughs and points out that, given modern C#, monads have arguably "caught on"
20:52:15 <unkanon> Cale: well lets just go with ease of understanding then
20:52:29 <FunctorSalad> syntaxglitch: what happened?
20:52:36 <unkanon> syntaxglitch: LINQ?
20:52:42 <FunctorSalad> (in the newest version? haven't seen it)
20:52:51 <FunctorSalad> 3.5 wasn't quite 'monads'
20:52:54 <mauke> class Default a where def :: a
20:53:00 <Cale> Functors (of which monads, comonads, applicatives, and various other things are subclasses) are demonstrably simpler.
20:53:04 <syntaxglitch> Yeah, LINQ. Pity that the type system is too broken to actually express monads as an interface
20:53:25 <Cale> unkanon: A functor in this context is just a type constructor f together with a function fmap :: (a -> b) -> (f a -> f b)
20:53:25 <unkanon> syntaxglitch: LINQ doesn't count as monads catching on because it's nothing but good-old SQL
20:53:27 <FunctorSalad> what's monad-like about linq?
20:53:37 <FunctorSalad> the quotation of code?
20:53:43 <unkanon> Cale: oh but you still need the type constructor then..
20:54:11 <Cale> Oh, and fmap has to satisfy a couple laws
20:54:14 <Cale> fmap id = id
20:54:22 <Cale> fmap (f . g) = fmap f . fmap g
20:54:29 <unkanon> Cale: right i remember that
20:54:30 <Cale> and that's it
20:54:33 <unkanon> Cale: i guess the problem is
20:54:35 <Cale> So functors include any sort of homogeneous container type where you could apply a function to all the elements
20:54:37 <syntaxglitch> FunctorSalad, creating a single-item collection is return, SelectMany is >>=
20:54:41 <unkanon> Cale: yes it is indeed simple to understand
20:54:54 <FunctorSalad> syntaxglitch: so, the list monad?
20:54:55 <unkanon> Cale: but it's tough implementing that on a language that doesnt offer type constructors :(
20:55:00 <Cale> as well as lots of types of "computations" to which you could apply a pure function to the result
20:55:13 <syntaxglitch> FunctorSalad, if you abuse the interface it uses, any monad you like
20:55:13 <Cale> unkanon: Well, you can ignore the type construtor part, and focus on fmap
20:55:27 <syntaxglitch> You just have to put with non-parametric return
20:55:33 <FunctorSalad> syntaxglitch: the IEnumerable seems like a step towards haskell too... with "yield return" syntax making lazyness relatively easy
20:55:50 <syntaxglitch> But yes, IEnumerable is basically a lazy list, and using LINQ on it is the list monad
20:55:55 <Cale> unkanon: Which language doesn't offer type constructors though?
20:55:56 * BMeph votes for CPS to "catch on"...
20:56:05 <mauke> Cale: Perl!
20:56:14 <unkanon> Cale: Lua, C...
20:56:18 <Cale> I mean, which language that you actually want to use ;)
20:56:22 <mauke> Cale: Perl!
20:56:23 <syntaxglitch> I seem to recall one of the MSDN bloggers demonstrating how to use various monads with the LINQ syntax, including Cont.
20:56:25 <unkanon> Cale: Lua, C...
20:56:26 <unkanon> :)
20:56:27 <Cale> hehe
20:56:32 <Cale> C is hopeless
20:56:33 <unkanon> no, but really
20:56:41 <mauke> but if you really want to, $collection->map(sub { ...}) is of course possible in Perl
20:56:50 <Cale> Don't even bother trying to implement these abstractions in C, you'll just hurt yourself, your code, or both
20:56:58 <unkanon> it's just a pity that such useful concepts as monads and functors require "type constructors"to be used in a language
20:57:13 <danharaj> unkanon: type constructors are the first abstraction.
20:57:15 <Cale> I'm not going to say it's impossible, it's just that C sucks and will do everything to prevent you from succeeding.
20:57:30 <danharaj> heh, that was a pithy statement.
20:57:33 <danharaj> I am awesome.
20:57:36 <FunctorSalad> :o
20:57:51 <syntaxglitch> FunctorSalad, keep in mind that the language design guys at MS have been heavily influenced by Haskell; LINQ's monadic structure is not a coincidence at all
20:57:59 <unkanon> danharaj: whaddya mean by that?
20:58:02 <Cale> Lua on the other hand, well... I forget, does Lua have *proper* first-class functions?
20:58:14 <Cale> It's untyped, right?
20:58:20 <unkanon> Cale: yes, very proper :)
20:58:24 <unkanon> Cale: yes.
20:58:26 <Cale> okay
20:58:48 <danharaj> unkanon: Taking a type, and making a new type out of it. That's what a type constructor is. This happens all the time, it's so fundamental. Languages like C don't even support *this* abstraction in code, even though they use it often.
20:58:54 <Cale> So you could at least think in terms of functors a bit and define fmap for various sorts of structures you're using.
20:58:57 <unkanon> Cale: but i just see no way of emulating type constructors on a language that doesnt offer them
20:58:59 <danharaj> unkanon: C++ does, though. In a way.
20:59:10 <Cale> Monads are painful though because of return
20:59:12 * FunctorSalad wonders why haskell isn't more windows-centric with MS effectively sponsoring it
20:59:15 <FunctorSalad> ( @ syntaxglitch )
20:59:30 <Cale> return :: (Monad m) => a -> m a
20:59:36 <mauke> unkanon: why do you need type constructors to use functors in an untyped language?
20:59:39 <Cale> return is polymorphic in the type of its result
20:59:48 <FunctorSalad> at least indirectly by employing researchers working on haskell
20:59:51 <syntaxglitch> Oh, and since I'm defending ugly languages tonight, both C# and Java have a limited sort of type constructors via "generics" a.k.a. parametric polymorphism
20:59:51 <Cale> In a way that is independent of its parameters
20:59:53 <unkanon> mauke: i don't know... so i don't?
21:00:00 <Cale> A lot of OO languages struggle with that
21:00:22 <unkanon> mauke: i mean, Lua has no types _at all_, so therés no way to make something change type even
21:00:22 <Cale> unkanon: See, in Haskell, we can do things like:
21:00:27 <mauke> Cale: don't make me write return in C++ :-)
21:00:28 <Cale> > read "5" :: Integer
21:00:28 <lambdabot>   5
21:00:31 <Cale> > read "5" :: Double
21:00:32 <lambdabot>   5.0
21:00:35 <FunctorSalad> syntaxglitch: sure
21:00:39 <Cale> > read "[1,2,3]" :: [Integer]
21:00:40 <lambdabot>   [1,2,3]
21:00:45 <syntaxglitch> If memory serves me Java's generics actually built off of some work that Wadler did, frighteningly enough
21:00:50 <Cale> What 'read' does is dependent on the type of its result.
21:00:56 <danharaj> mauke: I think FC++ already did that :p
21:01:02 <Cale> Not on the type of its parameter, like it would need to be in an OO setting.
21:01:23 <Cale> unkanon: and we make use of this in the monad interface normally
21:01:33 <FunctorSalad> do we?
21:01:36 * BMeph wonders why so many high-visibility Haskell projects have a "unix" dependency
21:01:37 <Cale> Yep
21:01:44 <FunctorSalad> m,a and b are fixed by the args
21:01:44 <unkanon> hmm
21:01:46 <Cale> return makes use of that sort of polymorphism
21:01:49 <danharaj> BMeph: because neckbeards are the only ones patient enough to learn Haskell :p
21:01:51 <FunctorSalad> ok
21:01:53 <FunctorSalad> thought bind
21:02:01 <Cale> Yeah, bind is surprisingly not the problem :)
21:02:12 <danharaj> Cale: You can parametrize functions on their return type in C++ IIRc
21:02:12 <FunctorSalad> ("b" is only fixed by a nested return value, admittedly)
21:02:20 <mauke> danharaj: not normally
21:02:28 <ddarius> syntaxglitch: What is "limited" about C#'s parametric types?
21:02:35 <syntaxglitch> yeah, return is why monads can't be expressed properly in C#, despite LINQ's crazy magic
21:02:37 <FunctorSalad> the kind?
21:02:39 <SamB_XP> you need that <> nonsense
21:02:42 <FunctorSalad> if it even is
21:02:43 <danharaj> mauke: Really? I never tried to do that waybackwhen. It ought to be added as an extension.
21:02:43 <syntaxglitch> SelectMany is a perfectly fine >>=
21:02:56 <mauke> danharaj: C++ lacks proper type contexts
21:03:24 <mauke> int f(); double f();  // invalid, these functions can't be distinguished by their parameter lists alone
21:03:42 <Cale> mauke: Except that you can't write polymorphic functions just by using f
21:03:44 <unkanon> Cale: the only way i can think of making something be a "type" in Lua would be to turn a variable into a list where the first item is the variable and the second item is a dictionary of functions that work on the "type" that we are turning that function into. does that make sense?
21:03:46 <syntaxglitch> ddarius, can't parameterize with type constructors is the main thing, though I may be confusing "what C# can do" with "what's actually tolerable thanks to type inference"
21:03:49 <danharaj> mauke: template<typename T> T f() { ... } should work, no?
21:04:05 <Cale> mauke: Oh, that was your point, sorry :)
21:04:06 <mauke> danharaj: yes, but then you have to explicitly mention the T you want
21:04:07 <SamB_XP> yeah, those two functions typically get the same symbol name at the object level
21:04:20 <mauke> f<unsigned long>();
21:04:27 <danharaj> mauke: This is not a terrible burden compared to the stuff you put up with in C++.
21:04:28 <SamB_XP> (er, that is, .o or .obj or what-have-you)
21:04:30 <Cale> unkanon: Instead, you could just pass the typeclass dictionary separately from the data
21:04:50 <Cale> unkanon: It becomes unwieldy because all your functions end up with an additional parameter
21:04:54 <Cale> unkanon: But it works
21:05:40 <Cale> So, you have a dictionary containing return and bind for each monad, and your generic return and bind functions take such a dictionary as a parameter and simply extract it
21:05:43 <mauke> danharaj: you can fake return-type-based overloading in C++ by using dummy classes, overloaded conversion operators, and templates
21:05:57 <Cale> and then you just make sure to explicitly thread the monad dictionary along
21:06:08 <danharaj> mauke: I'm convinced you can fake anything with template metaprogramming
21:06:20 <Cale> It's awkward though. Typeclasses make this so much more usable in real code.
21:06:21 <syntaxglitch> C++ templates are Turing-complete, if memory serves me
21:06:21 <FunctorSalad> Cale: somehow I took it for granted with `return'... hmm
21:06:29 <mauke> danharaj: not arbitrary function calls, sadly
21:06:48 <mauke> I think this is called the "perfect forwarding" problem
21:07:03 <unkanon> Cale: (i'll be right back, hold on)
21:07:09 <syntaxglitch> Though I'm not sure how expressive template metaprograms can be in terms of producing "output"
21:07:24 <danharaj> :t []
21:07:25 <lambdabot> forall a. [a]
21:07:29 <FunctorSalad> (but the equation-solving haskell effectively does implies that return types are taken into account, yes)
21:07:46 <FunctorSalad> (type equations)
21:08:33 * SamB_XP wrote a typechecker once!
21:08:47 <unkanon> Cale: yeah i can see that working but also being awkward to use
21:09:07 <FunctorSalad> SamB_XP: I admit I never did or read in detail how it operates :(
21:09:09 <SamB_XP> (of course, it was for a language that was utterly lacking in polymorphism... but I wrote the whole thing myself, except some of the lexer and maybe some of the parser ...)
21:09:10 <ddarius> SamB_XP: You can write a type checker in a few lines of Prolog.
21:09:19 <unkanon> Cale: i mean, ultimately what we're asking for is really the abstraction that typeclasses / type constructors provide
21:09:32 <unkanon> SamB_XP: burn  ;)
21:09:34 <FunctorSalad> I assumed you walk the tree and gather all the constraining equations that turn up...
21:09:35 <Cale> unkanon: and you can write things like (in an imaginary untyped language with pattern matching)  sequence m [] = return m []; sequence m (x:xs) = bind m x (\v -> bind m (sequence xs) (\vs -> return m (v:vs)))
21:09:38 <unkanon> SamB_XP: (only joking, lol)
21:09:48 <syntaxglitch> SamB_XP, I'm writing a type-checker right now... sort of
21:10:06 <SamB_XP> hey, it was for that game
21:10:07 <mauke> http://mauke.ath.cx/stuff/c++/awesome/null.hh - a pointless exercise in polymorphism and return-type-based overloading
21:10:08 <FunctorSalad> (and do unification of the sides)
21:10:11 <SamB_XP> "cult of the bound variable"
21:10:15 <Cale> unkanon: Passing around those m's everywhere is horrid, but it's the only way to properly get the polymorphism we're after.
21:10:17 <SamB_XP> you should try it, it's a fun game!
21:10:40 <lhames> syntaxglitch: There are some hilarious examples of C++ programs designed to produce output as compiler errors. (Erwin Unruh's primes finder is a great example)
21:10:55 <ddarius> FunctorSalad: You can do it that way and that is more or less the idea behind the HM(X) framework.
21:11:40 <syntaxglitch> lhames, well yeah, but that's not what I meant. For C++ template programs, useful "output" means working C++ code
21:12:37 <FunctorSalad> ddarius: what's the X parameter?
21:12:38 <SamB_XP> anyway, the parser + typechecker was for a language called RML, the interpreter for which ran too slowly on my system with my VM
21:13:02 <lhames> syntaxglitch: What do you mean? I just found the first 10 primes without the bother of producing working code. ;)
21:13:11 <syntaxglitch> lhames, I wrote a fractal renderer in GNU make once using "echo" for output, so I'm also familiar with egregious misuse of turing-equivalence :P
21:13:30 <lhames> I just offered it as an extreme example of computing with templates.
21:13:34 <ddarius> FunctorSalad: The underlying constraint domain.
21:13:36 <lhames> Yep. :)
21:13:38 <SamB_XP> this was, in fact, mostly because I had insufficient RAM and/or used a poor choice of allocator for my VM
21:14:18 <SamB_XP> oh, have you looked at xmltex ?
21:14:28 <unkanon> Cale: and by passing those around, we'd get kinda the same advantages that monads give us?
21:14:41 <danharaj> The embedding of the untyped lambda calculus into templates is not at all that bad.
21:14:49 <Cale> unkanon: Exactly
21:14:50 <danharaj> Relative to what you should expect from C++.
21:15:00 <danharaj> So really it's like gargling battery acid. Through your eyes.
21:15:06 <syntaxglitch> lhames, I know, my point is just that doing arbitrary computations given turing-completeness is usually not too difficult; producing output useful for a particular purpose can be challenging.
21:15:11 <Cale> unkanon: Apart from the fact that it would be awkward, you could do everything we currently do with monads like that.
21:15:16 <FunctorSalad> "Database error" http://www.haskell.org/haskellwiki/Xmonad/General_xmonad.hs_config_tips
21:15:33 <FunctorSalad> oh well this is not the hawiki bugtracker sorry
21:15:38 <FunctorSalad> ;)
21:15:48 <lhames> syntaxglitch: Agreed.
21:16:01 <Cale> unkanon: You could even implement monad transformers as functions on those dictionaries that you're passing around.
21:16:02 <FunctorSalad> it looks so similar!
21:16:28 <syntaxglitch> for instance, you can write arbitrary computations in GHC's typechecker using either fundeps or type families; but the latter are less expressive in terms of doing useful things with Haskell types
21:17:41 <syntaxglitch> even though it's actually simpler to demonstrate turing equivalence using type families
21:18:26 <danharaj> what's a type family?
21:18:48 <syntaxglitch> danharaj, a relatively new-ish GHC extension
21:19:00 <danharaj> syntaxglitch: That technically answered my question, yes ;)
21:19:06 <unkanon> Cale: well i have to study that more then
21:19:07 <FunctorSalad> danharaj: like classes but the result is a type too, not a dictionary
21:19:10 <SamB_XP> huh. apparantly if something goes wrong in an xmltex run, you might need to use an XML processing instruction to get out of it !
21:19:16 <unkanon> Cale: hold on i'll be right back with you :)
21:19:18 <FunctorSalad> hey, better than a car analogy
21:19:23 <unkanon> Cale: (i'm at work now lol)
21:19:29 <danharaj> FunctorSalad: So it's like a union of the types?
21:19:41 <danharaj> and I suppose you could define full on intersection types with them too?
21:19:43 <syntaxglitch> danharaj, type-level functions with some restrictions
21:19:58 <FunctorSalad> danharaj: it's a type synonym with parameters, but not uniformly as with "type Foo a = ..."
21:20:14 <FunctorSalad> danharaj: instead you have instance decls as with classes
21:20:24 <danharaj> ah
21:20:25 <FunctorSalad> "type instance Foo Int = String" etc
21:20:49 <Cale> Type functions, essentially
21:20:50 <FunctorSalad> and there's "data instance" for fresh ADTs instead of synonyms
21:21:45 <syntaxglitch> Unfortunately to my knowledge you can't write TypeEq with type families which kinda ruins a lot of metaprogramming fun :(
21:22:09 <FunctorSalad> *don't* expect the typechecker to deduce that if "m a = n b" then "m=n and a=b" with type fams, btw ;)
21:22:18 <FunctorSalad> it's a trap notationally
21:22:57 <FunctorSalad> but for type fams it's wrong of course, they needn't be injective
21:24:01 <nus> "Keep Your Types Concrete, Haskellers"
21:24:19 <FunctorSalad> yes it confused me a bit first
21:24:25 <abens> I'm reading http://www.haskell.org/haskellwiki/GHC/Type_families at the moment. So far it seems one benefit is that type signatures of multiparameter classes tend to be sort of confusing. Type families are more obvious. Reminds me of typedefs in C++ templates to move around type information.
21:25:03 <syntaxglitch> When you have MPTCs with a one-way fundep, the class is essentially a type function; type families make that more explicit
21:25:25 * SamB_XP lobs a Void at nus 
21:25:26 <unkanon> Cale: so you say using dictionaries / function tables and passing those around, we'd have nothing less than what monads can provide?
21:25:29 <FunctorSalad> like if you have "Basis v" as in the vector-space package... a function of type like "Basis v -> Foo" will be pretty awkward to use, since nothing fixes the v
21:26:01 <FunctorSalad> (v is the vectorspace type here, Basis v the type of basis vectors of your chosen basis)
21:26:17 <ddarius> unkanon: That is how type classes in general are usually encoded in Haskell implementations.
21:26:24 <FunctorSalad> (and `Basis' a type synonym function/family)
21:26:29 <unkanon> ddarius: under the hood?
21:26:42 <unkanon> ddarius: so it's as simple as that under the hood?
21:26:53 <ddarius> unkanon: Yes.  Note though, that such a translation requires higher-rank types if you want to maintain types.
21:27:31 <unkanon> ddarius: what are higher-rank types in a nutshell?
21:28:36 <ddarius> unkanon: Types like (forall a. a -> M a) -> Int
21:29:05 <FunctorSalad> actually I'm not sure whether that function can be called at all ;) with type annotations
21:29:43 <FunctorSalad> (you have an associated synonym family and a non-method function where only the synonym occurs)
21:30:11 <dolio> I think it likely cannot.
21:30:31 <unkanon> hmm i see
21:30:41 <danharaj> I am using Either as an Error monad, I have a list of possible actions, is there a prebuilt function that tries each one until one succeeds?
21:30:49 <c_wraith> @djinn Bool -> Bool
21:30:49 <lambdabot> f a = a
21:31:20 <ddarius> danharaj: msum
21:31:21 <SamB_XP> @. pl djinn a -> a
21:31:21 <lambdabot> f = id
21:31:28 <danharaj> ddarius: thanks
21:32:56 <FunctorSalad> syntaxglitch: somehow I find such fundep-based functions easier to understand
21:32:57 <danharaj> it is not at all obvious to me from its description in the docs that it does that.
21:33:07 <danharaj> ddarius: can you explain in a bit more detail?
21:33:17 <FunctorSalad> syntaxglitch: you get extra clutter though, namely variables
21:33:35 <c_wraith> I don't think msum does what you want.
21:33:44 <c_wraith> I think msum does the opposite of what you want.
21:34:06 <c_wraith> @instances MonadPlus
21:34:07 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
21:34:13 <c_wraith> Maybe it does...
21:34:14 <copumpkin> > msum [Left "ugh", Left "wtf man?", Right 5, Left "u crazy"]
21:34:15 <lambdabot>   Right 5
21:34:24 <FunctorSalad> > Left "fail" `mplus` Left "fial"
21:34:25 <lambdabot>   Left "fial"
21:34:30 <FunctorSalad> > Left "fail" `mplus` Right "meow"
21:34:31 <c_wraith> > msum [Left "ugh", Left "wtf man?", Right 5, Left "u crazy", Right 11]
21:34:31 <lambdabot>   Right "meow"
21:34:32 <lambdabot>   Right 5
21:34:35 <FunctorSalad> think it's fine
21:34:41 <syntaxglitch> FunctorSalad, I dunno, I've written a lot of fundep metaprograms, it can get pretty horrendous
21:35:03 <FunctorSalad> syntaxglitch: indeed
21:35:22 <danharaj> I am going to have to keep in mind MonadPlus in the  future
21:36:07 <FunctorSalad> syntaxglitch: using GADTs and thus value-level witnesses instead gives you back full control... at the cost of passing those witnesses around
21:36:24 <nus> @src Either mplus
21:36:24 <lambdabot> Left _ `mplus` n = n
21:36:25 <lambdabot> m      `mplus` _ = m
21:36:44 <SamB_XP> FunctorSalad: so you can delete anything, then?
21:37:11 <FunctorSalad> SamB_XP: I don't understand
21:37:21 <SamB_XP> it's a lame NT permissions joke ;-P
21:37:27 <FunctorSalad> delete the witnesses at runtime? one would *hope* ghc does that ;)
21:37:38 <FunctorSalad> ok
21:38:50 <nus> -XKillWitnesses
21:40:23 <FunctorSalad> (I mean a one-parameter gadt can play the role of a set of types, just like a typeclass can)
21:40:44 <FunctorSalad> (but it's closed-world, so you can do more with it...)
21:41:37 <FunctorSalad> probably a useless curiosity though, just too annoying to pass all those witnesses (values of the gadt type, which correspond to instances)
21:42:17 <syntaxglitch> FunctorSalad, I'm mostly just having fun seeing what I can do at compile time, really
21:42:45 <FunctorSalad> syntaxglitch: this produces compile-time proofs as well except you can cheat with _|_ ;)
21:43:20 <syntaxglitch> _|_ ruins everything :(
21:43:32 <SamB_XP> but they work well for proving you haven't made a mistake other than that sort of mistake
21:44:00 <FunctorSalad> SamB_XP: you can do it accidentally too, it corresponds to circular logic
21:44:25 <FunctorSalad> like calling your inductive proof with the same argument as the current one...
21:45:32 <syntaxglitch> If the only bug a program can contain is an infinite loop, that's doing pretty well all things considered
21:46:35 <FunctorSalad> (essentially one is just emulating a real dep-typed language there)
21:48:26 <SamB_XP> yeah, it sure beats a buffer overflow!
21:48:27 <syntaxglitch> speaking of which, I installed agda the other day... should try to figure out what the crap to do with that sometime
21:49:08 <syntaxglitch> I don't suppose there's a "Learn You an Agda" website out there
21:52:59 <FunctorSalad> a year or so ago documentation was pretty sparse, unfortunately
21:53:02 <juhp_> syntaxglitch: there is a tutorial (that I have not read...)
21:53:19 <FunctorSalad> (up-to-date one, that is)
21:53:47 <SamB_XP> there are a lot of libraries that you could try reading ..
21:54:03 <SamB_XP> the lovely thing about standard libraries is that there are so many to choose from!
21:54:25 <syntaxglitch> heh
21:54:43 <syntaxglitch> well, might as well charge recklessly ahead and figure out what I'm doing afterwards
21:54:51 <syntaxglitch> what's the worst that could happen?
21:55:04 <danharaj> prove arithmetic is inconsistent
21:55:08 <SamB_XP> you could wind up with a PhD
21:55:23 <FunctorSalad> <newbie> how do I ... <regular> rtfm <other regular> ahem, we have no manual <regular> ok, rtfsl then
21:55:25 <FunctorSalad> ....
21:55:33 <SamB_XP> danharaj: doesn't that happen at least every few decades anyways?
21:55:34 <FunctorSalad> ;)
21:55:53 <danharaj> rtfsl?
21:55:59 <FunctorSalad> standard library
21:56:05 <SamB_XP> danharaj: they always manage to salvage things pretty well, it seems
21:56:17 <danharaj> SamB_XP: What.
21:56:27 <SamB_XP> proving arithmatic inconsistant!
21:56:33 <danharaj> hasn't happened.
21:57:01 <SamB_XP> well, okay, not arithmatic, because that's not actually a formal system ...
21:57:12 <danharaj> I think you mean incomplete.
21:57:15 <syntaxglitch> proving arithmetic inconsistent is easy given an appropriate axiomatization
21:57:35 <FunctorSalad> "<syntaxglitch> what's the worst that could happen?" <-- semi-waste a LOT of time
21:57:56 <FunctorSalad> not entirely joking... I had an obsessive phase with formal proving
21:58:09 <syntaxglitch> in fact, you can prove anything you want given the right set of axioms, they're useful that way
21:58:55 <syntaxglitch> FunctorSalad, sounds like fun to me!
21:59:26 <lispy|web> hi
21:59:27 <absentia> oh bleem!
21:59:37 <FunctorSalad> syntaxglitch: it has this "collecting stuff and improving your character / your town etc" appeal of games ;)
21:59:52 <lispy|web> FunctorSalad: community service?
22:00:06 <FunctorSalad> lispy|web: rpg characters ;)
22:00:13 <SamB_XP> lispy|web: are you gonna join the club?
22:00:15 <FunctorSalad> and computer games
22:00:27 <lispy|web> SamB_XP: what club?
22:00:35 <FunctorSalad> "your base/town/empire" in strategy games
22:00:53 <lispy|web> FunctorSalad: oh, I thought you were saying that community service had characteristics similar to character building found in rpgs
22:00:57 <SamB_XP> Liskni_si: the bring back ... er, what was that nice web-based IRC thingy? club
22:01:17 <lispy|web> SamB_XP: oh, I'm using webchat.freenode.net
22:01:30 <FunctorSalad> lispy|web: I was comparing building a library of formal proofs with either rpgs or (laid-back) strategy games
22:01:32 <SamB_XP> Liskni_si: he's talking about formal logic
22:01:33 <lispy|web> SamB_XP: I'm too lazy to setup irssi
22:01:50 <lispy|web> SamB_XP: fix your tab completion ;)
22:02:26 <FunctorSalad> epic typo
22:02:30 <SamB_XP> I'm too busy coughing to notice I mesed up the completion
22:02:33 <lispy|web> I've been reading a lot this weekend...stuff on Oleg's website.  Delimited Continuations, Zippers, Iteratees.  I'm seeing some common themes.
22:03:08 <FunctorSalad> isn't that to be... expected? ;)
22:03:16 <FunctorSalad> if it's all from the same person
22:03:28 <lispy|web> And the idea of modeling multi-agent protocols with delimited continuations is certainly interesting
22:03:30 <SamB_XP> FunctorSalad: more to it than that
22:03:37 <FunctorSalad> and not in the trivial sense "the common property is that he's the author"
22:04:18 <syntaxglitch> I think like 90% of Oleg's stuff is about continuations in some form
22:04:25 <lispy|web> Well, it seems that iteratees use continuations, but what is interesting is that he defined his generic zipper by using differentiation of the traversal instead of the data structure.
22:04:35 <syntaxglitch> and the other 10% I'm probably just not clever enough to notice the implied continuation
22:04:43 <SamB_XP> lispy|web: oooooh
22:04:51 <lispy|web> So, zippers may not _need_ to use delimited continuations but he found a nice way to fit them in
22:04:51 <SamB_XP> that's neeeeet
22:05:05 <FunctorSalad> syntaxglitch: the overlapping instances absuse/magic also is pretty original
22:05:20 <FunctorSalad> syntaxglitch: he does type equality that way for example (since you mentioned it)
22:05:53 <lispy|web> I'm still not sure I understand what makes a continuation dilimited
22:06:32 <dolio> You set delimiters, and capture continuations up to those delimiters.
22:06:32 <lispy|web> In the case of iteratees, I think he just sort of threw the mathematics of delimited continuations out to help limit their scope and make them more understandable
22:06:38 <dolio> Rather than arbitrarily far into the future.
22:06:39 <SamB_XP> I think it's closely related to my sanity
22:07:41 <lispy|web> dolio: That tells me what a delimiter is for, but I don't understand how they are implemented or how they do their job
22:08:06 <lispy|web> dolio: I think I have more reading to do
22:09:00 <EvanR> what is a convention for naming a local IORef
22:09:16 <dolio> I'm not sure what knowing how they're implemented has to do with understanding the concept.
22:09:26 <EvanR> x <- readIORef xRef?
22:09:33 <copumpkin> don't name it!
22:09:40 <EvanR> :S
22:09:40 <copumpkin> =<< ftw ;)
22:09:54 * copumpkin steals EvanR's points
22:09:56 <EvanR> i have to use it in more than one place
22:10:11 <lispy|web> dolio: I guess that's part of what I don't get.  They feel magical still.  If I had to implement them I'm sure they'd be less so.
22:10:19 <EvanR> i could use a Reader!
22:10:21 <EvanR> :\
22:10:26 <lispy|web> :t join
22:10:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:10:37 <dolio> Undelimited continuations let you capture "the rest of the program" as a first-class value.
22:10:50 <dolio> Delimited continuations let you capture smaller scopes.
22:12:01 <SamB_XP> like "the rest of part of the program in the sandbox I told you about earlier"?
22:12:12 <dolio> Sure.
22:12:17 <dolio> Or "the rest of the loop."
22:13:10 <dolio> Or "the rest of this traversal that walks around a data structure arbitrarily, based on a function that tells me where to walk next."
22:13:14 <dolio> Which is how you get zippers.
22:13:54 <FunctorSalad> dolio: but I don't get how Cont is "the rest of the program"
22:14:22 * lispy|web either
22:14:28 <SamB_XP> well, it isn't
22:14:29 <FunctorSalad> I can "execute" it any time too if I have an "a -> r" handy
22:14:36 <FunctorSalad> for Cont r a
22:14:39 <dolio> In the case of Cont, it's already delimited in a way.
22:14:45 <SamB_XP> yeah
22:14:47 <FunctorSalad> ok, that clears it up some
22:14:54 <lispy|web> delimited in what way?
22:15:04 <dolio> While inside a Cont computation, you can capture "the rest of the computation, up to the runCont."
22:15:45 <FunctorSalad> I guess one limit is that you can't runCont if 'r' is universal in you local context
22:16:18 <dolio> Things would be different if you had native continuations you could access anywhere.
22:16:20 <lispy|web> universal?
22:16:28 <dolio> Like Scheme.
22:16:37 <FunctorSalad> forall r. .... Cont r Foo ...
22:16:42 <FunctorSalad> (@ lispy|web )
22:17:04 <FunctorSalad> depending on what ... is at least
22:17:07 <dolio> Alternately, you could look at Scheme as always running in a Cont monad, and the runCont is surrounding the program as a whole.
22:17:26 <lispy|web> ContT IO ?
22:17:30 <lispy|web> ah, scheme
22:17:37 <lispy|web> You're one big monad to me
22:17:49 <BMeph> Hmm, maybe I should ask Oleg if he's done anything with (old) Io? >;)
22:18:03 <EvanR> SchemeT
22:18:20 <SamB_XP> BMeph: a language named for a moon, or?
22:19:07 <c_wraith> Hmm.  I really don't like the idiom of "type Foo m = FooT m Bar", but I can't exactly express why.
22:19:20 <FunctorSalad> :o
22:19:22 <lispy|web> c_wraith: newtype is better :)
22:19:29 <FunctorSalad> never seen it
22:19:36 <BMeph> SamB_irs1i: That's my guess. Get this - there is one control structure: "actions", AKA continuations. :)
22:19:39 <FunctorSalad> because the monad gets lost? ;)
22:19:49 <SamB_XP> I thought you were supposed to use Id in there, not Bar!
22:19:56 <FunctorSalad> hmm or it doesn't
22:20:12 <c_wraith> Because it loses the generality of the monad, it feels like.
22:20:15 <FunctorSalad> you can still bind :: (m -> Foo m) -> (Foo m -> Foo m)
22:20:28 <c_wraith> It's not true, of course.
22:21:16 <c_wraith> I think I just hate using type synonyms to hide the most variable part of a constructed type.
22:22:04 <lispy|web> i feel like type synonyms are almost always wrong
22:22:48 <c_wraith> especially when it's a monad structure, you can use a FooT m Int while computing the FooT m Bar, but it doesn't show that variability clearly in the type signature.
22:22:57 <EvanR> copumpkin: you know i wouldnt have to name them if i were using StateT ;)
22:23:51 <c_wraith> But I also agree that type synonyms rarely ever anything.
22:24:31 <c_wraith> err.  what?  I just confused myself.  rarely every a good idea, is what I meant.
22:24:55 <lispy|web> I almost the whole monad
22:25:10 <c_wraith> I need to give up on typing, and get to nutriating.  err, eating.
22:28:18 <lispy|web> oh wow, this code shows how to implement unsafeCoerce :: a -> b, using unsafePerformIO and IORefs
22:28:36 <lispy|web> This code is supposed to be teaching me about prompts in delimited continuations :)
22:30:03 <copumpkin> it's a neat trick
22:30:20 <lispy|web> globalRef :: IORef a; globalRef = unsafePerformIO $ newIORef undefined; coerce :: a -> b; coerce e = unsafePerformIO (do writeIORef globalRef e; readIORef globalRef)
22:30:29 <copumpkin> yep
22:31:08 <copumpkin> not only do you have unsafeCoerce, but it's doubly unsafe because it's not threadsafe
22:31:26 <lispy|web> So prompts in this implementation are just unique integers
22:31:54 <dolio> Yes.
22:32:08 <dolio> Not all formulations of delimited continuations even contain multiple prompts, though.
22:33:11 <dolio> For instance, you can implement shift and reset in the ordinary Cont monad.
22:34:47 <jbapple> Here is a fun trick:
22:35:09 <lispy|web> dolio: so, is a prompt a way to place a 'mark' within the control flow?
22:35:16 <jbapple> Write a data type with one phantom type: data M a = M
22:35:35 <jbapple> Then write an empty Show instance declaration: instance Show a => Show (M a)
22:35:36 <SamB_XP> I think it's called a "delimiter"
22:35:37 <SamB_XP> ?
22:35:43 <jbapple> load it in GHCi
22:35:56 <jbapple> then type the constructor at the prompt and hit enter
22:36:03 <copumpkin> you get () ?
22:36:08 <jbapple> poof -- there goes all your memory
22:36:12 <copumpkin> oh really?
22:36:15 <copumpkin> hmm
22:36:23 <jbapple> fast, too
22:36:25 <dolio> lispy|web: Prompts let you use names when you delimit, and capture up to a name.
22:36:52 <lispy|web> dolio: so it's like labeling the scopes?
22:37:01 <dolio> Without multiple prompts 'reset (... reset (... shift k))' would only capture up to the inner reset.
22:37:22 <copumpkin> jbapple: fun!
22:37:27 <lispy|web> jbapple: for me it just said I don't have a show instance
22:37:31 <dolio> But if you have multiple prompts, you can do 'reset p1 (... reset p2 (... shift p1 k))' and capture up to the outer reset.
22:37:35 <copumpkin> it worked fine for me
22:37:49 <jbapple> lispy|web: what GHC version?
22:37:51 <copumpkin> and by worked I meant it gobbled plenty of memory
22:37:55 <copumpkin> I'm on 6.12.1
22:37:57 <lispy|web> jbapple: 6.12.1
22:38:04 <jbapple> I'm on 6.12.2
22:38:19 <copumpkin> lispy|web: you sure you did it right?
22:38:24 <copumpkin> not sure why it would complain about no instance
22:38:31 <copumpkin> oh I guess no Show a?
22:39:00 <lispy|web>     No instance for (Show (M a))       arising from a use of `print' at <interactive>:1:0
22:39:04 <jbapple> lispy|web: I named the module ShowMemory, which is also the name of the file. Did you not name the module or put it in a file named Main.hs
22:39:16 <jbapple> did you start ghci with any flags?
22:39:17 <lispy|web> I called it M.hs
22:39:24 <jbapple> very interesting
22:39:27 <lispy|web> it contains only that data definition
22:39:31 <lispy|web> no module declaration
22:39:36 <jbapple> and the show instance, right?
22:39:43 <lispy|web> Yes, I use flags, I'll try removing my .ghci
22:39:46 <lispy|web> I added that
22:39:53 <lispy|web> Still not using tons of mem
22:40:13 <jbapple> Mine wats a gig of RAM in less than a second
22:40:16 <jbapple> *eats
22:40:29 <copumpkin> mine was up to 150MB in a couple of seconds before I ctrl+z'd it
22:40:29 <jbapple> let me see if I have a .ghci
22:40:35 <copumpkin> I have no ghci and didn't name the module
22:40:41 <copumpkin> no .ghci
22:40:57 <jbapple> Yeah, I don't have one either
22:41:04 * FunctorSalad thought jbapple was saying that action should cause severe amnesia
22:41:11 <FunctorSalad> <jbapple> poof -- there goes all your memory
22:41:21 <SamB_XP> lol
22:41:23 <jbapple> ghc -W -Wall doesn't warn about anything either
22:41:32 <jbapple> Then how would I remember the bug at all
22:41:42 <jbapple> (a) John G raped and murdered my wife
22:41:46 <jbapple> (b) Then who was phone?
22:42:11 <mauke> what does ghc -W do?
22:42:14 <SamB_XP> can you here me now ?
22:42:19 <absentia> wtf?
22:42:29 <SamB_XP> er. hear?
22:42:39 <EvanR> here here
22:42:44 <lispy|web> I unset my env vars, removed ~/.ghci, started it as \ghci M.hs
22:42:52 <FunctorSalad> jbapple: hmm didn't consider how you'd remember it
22:43:05 <lispy|web> I'm on a mac
22:43:06 * SamB_XP very carefully launches the creampie at EvanR 
22:43:08 <FunctorSalad> maybe you're just reporting the misfortune of you colleague though
22:43:12 <jbapple> man ghc: -W "enable normal warnings"
22:43:13 <lispy|web> 10.5.something (Leopard)
22:43:31 <jbapple> linux for me
22:43:31 <SamB_XP> FunctorSalad: or worse, tried it on a victim!
22:43:41 <FunctorSalad> :o
22:43:50 <lispy|web> jbapple: oh, well maybe Steve Jobs makes mine work better?
22:43:52 <jbapple> That's a pretty bad bug
22:43:58 <jbapple> almost as bad as nasal demons
22:43:59 <FunctorSalad> a ghci would be pretty awkward to force someone to use though
22:44:00 <copumpkin> I'm on a mac, also 10.5
22:44:08 <EvanR> steve jobs is the new bill gates
22:44:24 <dolio> Who's the new Steve Balmer?
22:44:25 <jbapple> Never trust anyone with a common noun as a last name
22:44:28 <jbapple> myself included
22:44:29 <lispy|web> copumpkin: maybe Steve blessed  your build too?
22:44:33 <EvanR> dolio: linus
22:44:41 <copumpkin> blessed by making it gobble memory?
22:44:48 <FunctorSalad> EvanR: lol
22:44:49 <lispy|web> oh right
22:44:52 <SamB_XP> dolio: I don't think Apple needs one of those ?
22:45:05 <lispy|web> copumpkin: I was thinking yours was fine too
22:45:11 <lispy|web> hmm
22:45:23 <lispy|web> is ghci build with profiling?
22:45:29 <SamB_XP> registerization? bitness?
22:45:29 * lispy|web doubts it
22:45:40 <SamB_XP> ghci can't run with profiling
22:45:49 <dolio> SamB_XP: How can you make money without someone to freak out and throw chairs at people?
22:45:56 <jbapple> I think mine is built with profiling
22:45:57 <EvanR> http://glitchnyc.com/images/LinuxBusinessWeek.gif
22:45:59 <SamB_XP> not only does it refuse to attempt to work, it crashes badly if you override said refusal
22:46:16 <jbapple> I haven't tried to make an executable yet
22:46:28 <EvanR> ^ monkey suit
22:47:08 <jbapple> GHC calls it an error with "main = show M"
22:47:14 <jbapple> ambiguous type variable
22:47:24 <lispy|web> jbapple: print M?
22:47:28 <jbapple> sorry, yes
22:47:42 <lispy|web> that makes sense
22:47:56 <lispy|web> it would have to be main = print (M :: M ()) or such
22:47:57 <FunctorSalad> it doesn't know the result of a value-level function like show doesn't depend on type
22:48:11 <FunctorSalad> if you had a typeable constraint it even could
22:48:28 <danharaj> Anyone know of any research on processor designs based on graph reduction instead of von neumann machines?
22:48:49 <lispy|web> danharaj: not personally, but I've heard it discussed here.
22:49:00 <mauke> is that like the reduceron?
22:49:07 <lispy|web> danharaj: LtU might have articles about it?
22:49:07 <SamB_XP> well, perhaps more of a toy, but yeah, the reduceron
22:49:22 <danharaj> Reduceron sounds like a decepticon.
22:49:55 <lispy|web> dolio: so how are shift/reset implemented?  My sample implementation here from Oleg doesn't contain those names
22:50:08 <jbapple> lispy|web, copumpkin: do you have GHC trac accounts? Will you add your results to a ticket for me?
22:50:22 <lispy|web> dolio: but I do have things like letSubCont, pushPrompt and some other stuff
22:50:25 <copumpkin> I do, but I'll need to remember my password :)
22:50:26 <SamB_XP> jbapple: you can't solve the captcha ?
22:50:55 <SamB_XP> or you want it done now, not when whoever does that stuff checks their mail ?
22:51:01 <lispy|web> I have 2 accounts there.  One causes infinite loops in the redirects and the other works.  If I guess the wrong account first then I'm screwed :)  But I can try
22:51:03 <jbapple> no, I'm writing a ticket just fine. I would just like other people to add their info as well
22:51:19 <jbapple> Since the results have differed amongst us
22:51:20 <SamB_XP> ah, ah!
22:51:26 <SamB_XP> got it
22:51:39 <jbapple> ok, brb with ticket #
22:51:41 <dolio> lispy|web: In what context? For Cont(T), reset uses runCont, and shift works a lot like callCC, except it doesn't call the continuation if you just return from the function.
22:51:46 <lispy|web> jbapple: my results are exactly normal.  So not much to say other than my platform, which appears to be the same as copumpkin's
22:52:38 <jbapple> lispy|web: by "normal", you mean "complains about ambiguity", right?
22:52:50 <c_wraith> um, wtf.   "cabal: dependencies conflict: ghc-6.10.4 requires bytestring ==0.9.1.4 however bytestring-0.9.1.4 was excluded because bytestring-0.9.1.5 was selected instead; bytestring-0.9.1.4 was excluded because of the top level dependency bytestring ==0.9.1.5"
22:52:57 <c_wraith> is ghc a package?
22:53:15 <jbapple> http://hackage.haskell.org/trac/ghc/ticket/4089
22:53:29 <lispy|web> jbapple: in ghci it doesn't complain and if I have deriving (Show) it prints M and uses only about 30megs of memory total
22:53:51 <jbapple> wait, you used "deriving (Show)"?
22:53:56 <SamB_XP> c_wraith: containing the GHC library, yes
22:54:12 <SamB_XP> the one that lets you use the compiler in your programs
22:54:12 <c_wraith> huh.  there is a hidden package named ghc.  I can't tell it to use a different version of bytestring, can I?
22:54:21 <lispy|web> jbapple: If I use that it prints M, otherwise it gives me an error saying no instance (also only uses 30 megs)
22:54:34 <dolio> lispy|web: If you're talking about the formulation that Oleg tends to use, it's more complicated. You keep track of a program stack, pushPrompt sticks a marker onto the stack, and letSubCont walks up the stack until it finds the right prompt.
22:54:44 <c_wraith> does that mean I need to recompile all of this using bytestring 0.9.1.4?
22:54:47 <jbapple> ok. So, that is different than my result, so I think that makes it interesting
22:54:50 <dolio> And then shift and reset are defined in terms of those primitives.
22:54:54 <lispy|web> dolio: gotcha.  Yeah, I was just starting to figure that out
22:55:01 <lispy|web> dolio: I did find his shiftP
22:55:14 <lispy|web> dolio: and it does things like letSubCont ... pushSubCont ...
22:55:17 <jbapple> Furthermore, it is different than copumpkin's result, which makes it doubly interesting, since y'all are on the sameish platform
22:55:20 <lispy|web> dolio: creating a stack, just like you said
22:56:16 <copumpkin> I get a stack space overflow when I compile it
22:56:22 <lispy|web> jbapple: I don't know my password anymore I guess
22:56:23 <copumpkin> (with main = print (M :: M ())
22:56:33 <lispy|web> sounds like the type checker is divering then
22:56:35 <jbapple> copumpkin: very interesting
22:56:36 <lispy|web> diverging*
22:57:00 <copumpkin> oh, not the compilation
22:57:07 <copumpkin> I meant the resulting executable
22:57:16 <lispy|web> ah
22:57:17 <jbapple> copumpkin: I get no stack overflow . . . .oh
22:57:54 <lispy|web> Mine continues to behave correctly
22:57:56 <jbapple> how does "-main-is" work?
22:58:19 <jbapple> I still get linker errors with "ghc --make -main-is ShowMemory ShowMemory.hs"
22:58:23 <lispy|web> data M a = M deriving Show
22:58:25 <lispy|web> right?
22:59:08 <copumpkin> no
22:59:15 <copumpkin> instance Show a => Show (M a)
22:59:24 <copumpkin> with no implementation of the show method
22:59:53 <lispy|web> ah
22:59:57 <lispy|web> Now I get the bad behavior
23:00:04 <BMeph> Is there another interpreter/evaluator tutorial other than the Scheme one?
23:00:15 <copumpkin> oh
23:00:23 <lispy|web> BMeph: the one about monad transformers is kind of one
23:00:24 <copumpkin> it's simpler than that
23:00:55 <lispy|web> BMeph: http://www.grabmueller.de/martin/www/pub/Transformers.en.html
23:01:01 <jbapple> I needed "-fforce-recomp" to get "-main-is" to work
23:01:07 <jbapple> copumpkin: I also get a stack overflow
23:01:40 <copumpkin> it's like providing no method for Eq I think
23:01:50 <copumpkin> you can make it even simpler
23:01:53 <copumpkin> just by doing data M = M
23:01:56 <copumpkin> instance Show M
23:02:02 <copumpkin> still behaves just as badly
23:02:15 <copumpkin> show has a default implementation that must diverge
23:02:20 <lispy|web> yeah
23:02:43 <copumpkin> @hoogle shows
23:02:43 <lambdabot> Prelude shows :: Show a => a -> ShowS
23:02:43 <lambdabot> Text.Show shows :: Show a => a -> ShowS
23:02:43 <lambdabot> Prelude type ShowS = String -> String
23:02:52 <copumpkin>     show x          = shows x ""
23:02:57 <copumpkin> which is also why you get no warning
23:03:09 <c_wraith> ok, reinstalling tons of things with a dependency on bytestring 0.9.1.4 worked.  But I wish there was a better solution
23:03:15 <copumpkin> shows           =  showsPrec zeroInt
23:03:17 <BMeph> lispy|web: Thanks, I'll check it out. I'm thinking of re-doing the Amalthea implementation in Haskell, and figured I might just try doing it from scratch instead of learning OCaml, too. O may  do that anyway, but at least it's a choice. :)
23:03:24 <copumpkin>     showsPrec _ x s = show x ++ s
23:03:28 <copumpkin> yeah, it's that simple
23:03:53 <lispy|web> BMeph: well, that tutorial I linked is really just how to step by step add monad transformers but the example they work with is a trivial interpreter
23:03:54 <copumpkin> it's like defining instance Eq M with no implementation of (==) or (/=)
23:04:01 <copumpkin> they just mutually recurse
23:04:48 <lispy|web> BMeph: but, knowing how to construct custom monads from transformers is quite a useful thing to know for interpreter builders
23:04:51 <jbapple> copumpkin: Maybe it's not a "bug" then after all
23:04:53 <dolio> lispy|web: ccshan's paper Shift to Control might be a better place to look for how to implement various operators directly and simply.
23:04:57 <copumpkin> yeah, it isn't
23:04:58 <jbapple> But it really sucks
23:05:04 <EvanR> does the standard lib have command line args accessors?
23:05:10 <jbapple> I had to kill ghc, which kills all of my running instances
23:05:19 <jbapple> or wait for the system to kill it
23:05:24 <lispy|web> EvanR: GetOpt?
23:05:32 <EvanR> :t GetOpt
23:05:33 <lambdabot> Not in scope: data constructor `GetOpt'
23:05:36 <EvanR> :t getOpt
23:05:37 <lambdabot> Not in scope: `getOpt'
23:06:07 <EvanR> how about something like int argc, char* argv[]
23:06:09 <lispy|web> EvanR: http://hackage.haskell.org/packages/archive/base/4.0.0.0/doc/html/System-Console-GetOpt.html
23:06:11 <lispy|web> EvanR: it's in base
23:06:21 <lispy|web> EvanR: oh, getArgs?
23:06:24 <copumpkin> jbapple: if nothing else, it should highlight the need for a good way to annotate what methods need to be provided for typeclasses in a compiler-checked manner
23:06:24 <EvanR> ah
23:06:27 <lispy|web> :t getArgs
23:06:28 <EvanR> :t getArgs
23:06:28 <lambdabot> Not in scope: `getArgs'
23:06:29 <lambdabot> Not in scope: `getArgs'
23:06:38 <lispy|web> ?hoogle getArgs
23:06:38 <lambdabot> System.Environment getArgs :: IO [String]
23:06:58 <EvanR> hehe, i already guessed the name in my psuedo code ;)
23:07:03 <lispy|web> main = do [n] <- getArgs -- I've seen this used when the program is run as ./foo 10
23:07:28 <EvanR> thats nifty
23:07:56 <lispy|web> EvanR: well, it's neat but sloppy.
23:08:09 <lispy|web> ./foo pi -> pattern match failure
23:08:13 <EvanR> thats contradictory
23:08:32 <EvanR> ./foo pi should work
23:08:34 <lispy|web> oh yeah, sorry "neat" means "cool" or "novel" too :)
23:08:59 <EvanR> but converting pi to a number wont work
23:10:10 <lispy|web> EvanR: GetOpt is probably the best way.  tselliot once whipped up a quick example in GetOpt that had proper exception handling, but I don't have it handy and I don't know how to recreate it off the top of my head
23:10:37 <EvanR> a list of the args is fine
23:11:08 <EvanR> exitFailure for the win
23:11:43 * copumpkin @$!%!@^!@^@!$!%1
23:12:06 <copumpkin> that package by ndm for parsing options is quite nice
23:12:08 <copumpkin> despite being impure
23:12:15 <jbapple> So, when GHCi gets stuck in a loop, it stops responding to my "^C"
23:12:25 <copumpkin> jbapple: it's certain kinds of loop
23:12:33 <copumpkin> if they don't allocate, the runtime can't grab control again
23:12:37 <FunctorSalad> killall -9 ghci
23:12:40 <lispy|web> jbapple: did you hit ^C compulsively?
23:12:44 <copumpkin> ^Z works fine
23:12:48 <FunctorSalad> :)
23:12:48 <lispy|web> jbapple: I find that sometimes I just have to tell it 10 times
23:12:50 <copumpkin> I always bg it and then just kill it
23:13:05 <jbapple> Yeah, I had to background it then kill -9 it
23:13:13 <jbapple> kill didn't seem to do anything
23:13:16 <copumpkin> and by bg I mean suspend
23:13:19 <lispy|web> kill -9 -1, is fun too
23:13:20 <FunctorSalad> sigterm maybe works too, maybe it's just not responding to the key
23:13:21 <FunctorSalad> ?
23:13:30 <FunctorSalad> lispy|web: what does that do
23:13:38 <lispy|web> -1 as a pid means everything
23:13:43 <jbapple> oh dear
23:13:59 * lispy|web use to logout of his desktop sessions in Solaris that way
23:14:02 <EvanR> and alt F4 makes the map download faster
23:14:13 <FunctorSalad> 1 would have a similar effect wouldn't it
23:14:16 <lispy|web> CDE ftl
23:14:30 <lispy|web> FunctorSalad: well, except you'd have to be root to use that one
23:14:40 <lispy|web> FunctorSalad: when you do -1 as a normal use it's only your processes
23:14:44 <lispy|web> user*
23:14:47 <FunctorSalad> I see
23:15:37 <FunctorSalad> lispy|web: I think I can alt+sysreq+i as a user
23:15:38 <FunctorSalad> ;)
23:15:52 <FunctorSalad> *altgr
23:16:46 <jbapple> Thanks for the help with that "bug", everyone
23:16:52 <FunctorSalad> (don't try that now)
23:16:53 <lispy|web> jbapple: np
23:16:57 <FunctorSalad> without saving your data
23:16:58 <lispy|web> type classes are hard
23:17:00 <jbapple> It's not a bug, but at least I learned how to kill GHCi properly
23:17:25 <lispy|web> jbapple: well and you learned that it pays to give implementations of show and not rely on default
23:17:27 <jbapple> although, now I wonder why it didn't show up on lispy|web's machine
23:17:43 <lispy|web> jbapple: it did once I pulled my head out of my as^H^Hthe sand
23:17:45 <jbapple> Yeah, I was trying to do standalone deriving and I just forgot the extra keyword
23:17:49 <lispy|web> jbapple: I was doing the show instance incorrectly
23:17:51 <FunctorSalad> jbapple: once it starts trashing you're lucky to get bash and kill back into memory though ;)
23:17:55 <jbapple> ah, ok
23:18:11 <FunctorSalad> I disabled my swap now...
23:18:41 <FunctorSalad> nevermind, kill is builtin
23:19:05 <FunctorSalad> if the loop is a memory-filling one
23:20:16 <jbapple> won't ^z allow ghci's memory to be swapped out and bash's to be swapped in?
23:20:41 <jbapple> (I realize this is not a Haskell question)
23:21:00 <lispy|web> *gasp*
23:21:27 <lispy|web> So do zippers have good resource usage?
23:22:10 <BMeph> The best!
23:22:16 <lispy|web> I know if you use lazy IO and traverse the input twice the RTS will hold the whole input in memory until the second traversal ends.  I keep imagining zippers having similar resource funkiness
23:22:44 <lispy|web> And if that's the case, I want no part of them for what I have in mind
23:23:02 <copumpkin> zippers are just cursors
23:23:13 <ddarius> lispy|web: A zipper, by design, typically holds reference to the entire structure.
23:23:45 <lispy|web> ddarius: yeah, that's what I thoguht
23:24:00 <FunctorSalad> jbapple: maybe - I think I was in some other window already, which makes it harder
23:24:15 <lispy|web> ddarius: so they are really only appropriate if you can afford to hold them in memory all at once?
23:24:29 <FunctorSalad> it at least managed to make the login in terminal 1 stall
23:24:46 <copumpkin> lispy|web: well, it allows you to move back and forth along the data, so you can't exactly "stream" like you would a normal list
23:24:59 <copumpkin> since streaming usually suggests forgetting the stuff you've already seen
23:25:18 <copumpkin> being able to move back and look at it again makes it hard to forget :)
23:25:29 <c_wraith> never forget!
23:25:51 <jbapple> zippers should be called elephants
23:26:44 <lispy|web> Well, I could imagine a zipper where the ends are stored on disk and only the cursor is in memory
23:26:58 <lispy|web> So using next would necessarily be in IO
23:28:20 <copumpkin> you could make a bidirectional iteratee :)
23:28:22 <c_wraith> that's sounding a lot like iteratee.  But right now, everything sounds a lot like iteratee
23:29:20 <lispy|web> heh, I've gone is a circle then
23:30:13 <FunctorSalad> c_wraith: maybe a tree zipper is a better example then
23:30:20 <blackdog> can you hide a package directly within a file?
23:30:33 <lispy|web> blackdog: I don't think so
23:30:35 <blackdog> am playing around with snap, but the old mtl vs monad-fd thing is killing me
23:30:41 <FunctorSalad> you want to single out a subtree, and also be able to recover the whole tree...
23:30:49 <c_wraith> blackdog: it didn't give me any trouble...
23:30:54 <lispy|web> blackdog: You can hide a package when you invoke ghc/ghci though
23:30:56 <blackdog> fair enough. i guess i'll bug kazu to make ghc-mod respect cabal files
23:30:58 <EvanR> i think its possible to make a writer that never returns from an infinite loop, but you can still get a 'lazy' stream of output from it (just dont touch the return value). is there a way to make a reader that does something similar? you can continue to feed it stuff?
23:31:12 <blackdog> c_wraith: yeah, compiling is fine - i'm using ghc-mod to get feedback within emacs
23:31:18 <c_wraith> oh, I see
23:31:30 <c_wraith> Yeah, it should respect the cabal file, if one's present
23:32:00 <lispy|web> EvanR: what do you mean?
23:32:14 <lispy|web> EvanR: something that produces an infinite stream incrementally?
23:32:34 <lispy|web> "codata" as I've heard it called
23:32:41 <c_wraith> EvanR: if you put a [a] in a Reader, it will only be generated as demanded.
23:32:41 <EvanR> ehm, like a Random monad, but instead of a random number generator its a lazy list which is determined by future IO or something
23:32:42 <ddarius> Infinite streams tend to be produced incrementally by necessity...
23:32:43 <copumpkin> EvanR: a reader is just an implicit argument, really
23:32:51 <blackdog> c_wraith: suppose putting much work into getting it working w/out cabal is a bit quixotic
23:33:37 <EvanR> copumpkin: yes so a basic reader wont cut it
23:33:44 <copumpkin> EvanR: well it depends
23:33:51 <FunctorSalad> c_wraith: lists are a bit of a collapsing example because the "upwards" part looks just like the downwards
23:34:00 <copumpkin> a reader on a lazy list is going to be lazy, but the reader isn't buying you anything
23:34:19 <c_wraith> Reader never buys you anything by itself. >_>
23:34:25 <FunctorSalad> c_wraith: in general the "up" part (my term) is a list of one-holed constructors of the old type
23:34:31 <EvanR> reader is great
23:34:42 * ddarius doesn't know why FunctorSalad is having a one-sided conversation with c_wraith.
23:35:11 <FunctorSalad> ddarius: <c_wraith> that's sounding a lot like iteratee.  But right now, everything sounds a lot like iteratee
23:35:20 <FunctorSalad> which was in the context of list zippers
23:35:55 <lispy|web> ddarius: ah yeah, so I meant to contrast it with something that sits in an infinite loop before producing anything, even if it claims to produce an infinite stream someday
23:35:56 <FunctorSalad> so I specified a zipper which looks totally unlike iteratee
23:36:08 <ddarius> FunctorSalad: Yes, but you misinterpreted what he was responding to and at any rate he hasn't said anything to -you- at all even with you addressing him directly.
23:36:50 * lispy|web disappears to watch fullmetal alchemist.
23:36:57 <FunctorSalad> ddarius: *shrug* stay-in-irc-window inertia
23:37:01 <lispy|web> iteratees / zippers will have to wait, my brain is full
23:37:30 <FunctorSalad> combined with wanting to say something
23:37:42 <FunctorSalad> and remembering for myself what zippers are
23:45:57 <clanehin> OK, I'm confused.  Does Control.Arrow.Transformer.Static even export a way to wrap and unwrap a StaticArrow based on an applicative functor that is not itself a monad or arrow?
23:55:54 <c_wraith> uh.  just found this in the snap site source:  error "You must specify a port!" >> exitFailure
23:56:00 <c_wraith> That looks very bizarre to me.
23:56:05 <c_wraith> like...  broken
23:56:09 <ksf> is there a way to say that the default instance of a class should apply to any type that doesn't have an implicit instance?
23:56:17 <copumpkin> c_wraith: are you sure that's the Prelude.error?
23:56:22 <c_wraith> oh, no.  good point
23:56:46 <c_wraith> After double-checking, the only thing it's hiding from Prelude is catch.
23:57:10 <copumpkin> c_wraith: what file is this?
23:57:44 <c_wraith> it's in the snap-website repo (it's the source for their site, not part of Snap itself), in src/Main.hs
23:58:21 <ksf> actually, I want an open optional-product type.
23:58:41 <ksf> that is, the product of a and b would be (Maybe a, Maybe b)
23:59:17 <ksf> is there a name for that?
23:59:18 <copumpkin> c_wraith: looks like a bug
23:59:28 <c_wraith> :t liftM2 $ uncurry (,)
23:59:29 <lambdabot>     Couldn't match expected type `a2 -> r'
23:59:29 <lambdabot>            against inferred type `(a, b)'
23:59:29 <lambdabot>     In the second argument of `($)', namely `uncurry (,)'
23:59:38 <c_wraith> err, oop.
23:59:46 <unlink> Haskell's import is a purely compile-time operation, correct?
23:59:50 <c_wraith> :t uncurry $ liftM2 (,)
23:59:51 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
