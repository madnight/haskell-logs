00:00:55 <mwotton> Axman6: ambling down the main road, are they?
00:01:08 <mwotton> suppose that's what happens when you build a city in a paddock
00:03:42 <Axman6> what, get somewhere so easy to navigate that even cows can do it? :P
00:03:48 * Axman6 -> buying shit
00:03:58 <Axman6> s/shit/stuff, sorry kids
00:04:39 <dolio> You can get a good look at a t-bone by sticking your head up a butcher's ass, but wouldn't you rather just take his word for it?
00:13:55 <kyagrd> haskell.org is down :(
00:14:31 <kyagrd> Haskell hompage is on memorial weekend break
00:15:24 <dolio> It takes breaks much more often than holidays.
00:19:10 <dons> mmm
00:19:17 <dons> ooh my yes
00:20:12 <dons> hasn't happened in a long while
00:22:00 <EvanR> it took me all sunday, but i threw together a parse and execution environment for a imperative object oriented language in haskell
00:22:03 <EvanR> parser
00:22:14 <EvanR> and i didnt even know parsec
00:23:35 <dons> was it python?
00:23:50 <EvanR> no
00:23:56 <EvanR> hah
00:23:59 <mwotton> dons: I do wonder what bernie's up to there
00:24:07 <mwotton> presumably the hard bit would be the FFI integration
00:26:33 <kyagrd> language-python makes ghc-6.12 eat up gigabytes of memory and die
00:26:34 <EvanR> python is object oriented?
00:26:52 <kyagrd> I mean trying to compile language-python
00:31:59 <tomberek> dang, i think i'm writing monad transformations from scratch
00:42:11 <soupdragon> > sum (\x->8/(x*4-1)*(x*4+1)) [1..100]
00:42:12 <lambdabot>   The lambda expression `\ x -> 8
00:42:12 <lambdabot>                              GHC.Real./
00:42:13 <lambdabot>    ...
00:42:26 <soupdragon> > sum . map (\x->8/(x*4-1)*(x*4+1)) $ [1..100]
00:42:27 <lambdabot>   822.7741283672484
00:42:46 <soupdragon> > sum . map (\x->8/((x*4-1)*(x*4+1))) $ [1..100]
00:42:47 <lambdabot>   0.8534322528170432
00:43:00 <soupdragon> > map (\x->((x*4-1),(x*4+1))) $ [1..100]
00:43:01 <lambdabot>   [(3,5),(7,9),(11,13),(15,17),(19,21),(23,25),(27,29),(31,33),(35,37),(39,41...
00:43:43 <soupdragon> "π／８＝１／（３×５）＋１／（７×９）＋ …… "
00:43:48 <soupdragon> how do i  do that in haskell?
00:44:31 <dolio> > sum . map (8 / (((*4) - 1) * ((*4) + 1))) $ [1..100]
00:44:32 <lambdabot>   0.8534322528170432
00:45:20 <madhadron> Does anyone know how to bootstrap GHC if you really don't have access to a binary that will run on a given system?
00:45:42 <madhadron> (In this case, a rather old Linux on x64_64)
00:45:59 <tomberek> is there a way to compare the structure of two functors?
00:47:06 <danharaj_> tomberek: natural transformations?
00:47:23 <tomberek> danharaj, i don't know much about them?
00:47:42 <danharaj_> a natural transformation is basically a morphism between functors.
00:48:17 <tomberek> danharaj : i was looking at liftA2 as a way to combine to applicatives
00:48:51 <madhadron> tomberek, Unless I misunderstand what you're asking, liftA2 only applies to one functor at time
00:50:16 <tomberek> madhadron: yes, the same functor
00:51:07 <madhadron> tomberek, Okay, in that case I don't understand what you mean by comparing structure
00:51:38 <tomberek> madhadron: i want to take the same functor, and be able to combine them... so for lists: myfunc (+) [1,2] [4] -> [5]
00:52:07 <tomberek> where the same structure is kept and combined in a specified way, the rest of the structure is thrown away
00:52:48 <madhadron> In the case of lists, I would just do it with map and zip
00:52:54 <tomberek> correct
00:52:54 <madhadron> but I don't understand your general case
00:53:14 <madhadron> You would essentially have to write a further subtype of functor
00:53:19 <tomberek> but those are only for lists... i would like to do it for any Functor,, or Applicative
00:53:39 <dolio> > (+ 8/3) . sum . map (8 / (((*4) + 1) * ((*4) + 3))) $ [1..100000]
00:53:40 <lambdabot>   3.141587653639796
00:53:46 <tomberek> basically, a union between Functors that preserves structure
00:54:16 <dolio> > sum . map (8 / (((*4) + 1) * ((*4) + 3))) $ [0..100000]
00:54:17 <lambdabot>   3.1415876536398177
00:54:27 <madhadron> tomberek, I think you'll need to define a typeclass giving you some kind of operation with you can get at the pieces of a functor
00:54:49 <madhadron> For instance, you say that all functors you are interested in take the form of an ordered product of functors
00:55:06 <madhadron> and then provide the equivalent of head and tail functions on the class
00:55:37 <madhadron> But the point of the Functor class is that it provides you a minimal calculus of the type.  Anything further that you want, you must define as an extension to the calculus.
00:56:06 <tomberek> madhadron: maybe if i explain what i'm doing,, maybe you can think of an easier way, or it might already be done
00:56:19 <madhadron> Sure
00:56:31 <madhadron> Since I'm just sitting here scratching my head over how to statically compile ghc
00:56:32 <c_wraith> anyone have an example sitting around of a functor that isn't naturally an applicative functor?
00:56:58 * QtPlatypus looks at Text.HTML "A list of functions and there signature isn't documentation"
00:57:12 <tomberek> madhadron: I'm trying to make a Product typeclass. Simple instances are (a,b) and data Prod a b = Prod {item::a,label::b}
00:57:26 <c_wraith> I guess lists can naturally be applicative functors in two different ways, which means that which instance to choose isn't natural.
00:57:31 <madhadron> QtPlatypus, 1. Use Text.XHtml; 2. Yeah, it's kind of sad, and you end up reading the source code instead.
00:58:44 <QtPlatypus> madhadron: Thanks, and what can we do to change this aspect of Haskell culture?
00:59:11 <soupdragon> write documentation
00:59:13 <madhadron> QtPlatypus, I hate to say it, but start writing and submit patches.
00:59:13 <dolio> c_wraith: C s a = (s, s -> a)
00:59:18 <danharaj_> exemplary documentation
00:59:19 <tomberek> madhadron: next, I want to be able to work with Functors of Products.  so... [1,2,3] and [1,4,9] -> [(1,1),(2,4),(3,0)] (zipWIth for lists)
00:59:35 <madhadron> I wrote the introduction for the BlazeHtml library, and it was a lot of time and work to get something usable.
01:00:06 <QtPlatypus> madhadron: True, but its rather difficult to write good documentation when you don't understand the thing you documenting.
01:00:09 <eevar2> just plainly ignoring the undocumented libs might also be an idea
01:00:46 <madhadron> QtPlatypus, Yes, that's very true.  It took me quite a while to figure out Happstack, and after the fact I think the API is rather broken in many places.  Not sure I want to document it as is...
01:01:13 <madhadron> tomberek, So you want a ZippableFunctor?
01:01:20 <tomberek> madhadron: i have that working so far
01:01:31 <tomberek> madhadron : perhaps,, i'll look at that
01:01:35 <danharaj_> :t zip
01:01:36 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
01:01:48 <madhadron> No, it doesn't exist yet, it's just the obvious name.
01:01:52 <danharaj_> :t zipWith
01:01:53 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
01:02:08 <madhadron> QtPlatypus, I have also considered that it's rather painful for people to have to submit source patches to get documentation in.
01:02:20 <tomberek> madhadron : well, i have the deconstruction part workig
01:02:23 <madhadron> QtPlatypus, I believe this stops a lot of people from posting their insights when they figure something out.
01:02:24 <QtPlatypus> madhadron: How so?
01:02:52 <madhadron> QtPlatypus, Well, you figure something out, write it up, push it to a repository, ask the maintainer to pull it, and wait for him to post it to hackage.
01:03:03 <QtPlatypus> Ah
01:03:06 <dolio> c_wraith: Or just (,) r, for that matter.
01:03:14 <tomberek> madhadron: for example, I can take any Functor of Products, and extract a Functor of each element of the Product
01:03:31 <madhadron> QtPlatypus, Eventually you want it all nicely in Haddock (I think), but something like the ability to submit comments on elements on a Haddock page on Hackage might be invaluable
01:03:46 <dolio> c_wraith: It's applicative when r is a monoid, but it's a functor (and comonad) for arbitrary r.
01:03:46 <tomberek> madhadron : now I'm working on the construction part of it.. taking two Functors and making it into a Functor of Products
01:04:22 <QtPlatypus> madhadron: Sort of making it more wiki-like, at least in the low barrior to entry sence?
01:04:24 <madhadron> tomberek, Oh, I see the confusion!  When you say "functor," my poor brain thinks what you know as fmap
01:04:26 <danharaj_> tomberek: do you know what signature for your function you want?
01:04:44 <madhadron> QtPlatypus, Right.  It has to be cleaned up in the end, but maybe something like PostgreSQL's user comments on the manual
01:04:56 <tomberek> madhadron: did all that make sense?
01:05:36 <madhadron> tomberek, So you want to specialize functors to be zippable and unzippable.
01:05:51 <madhadron> tomberek, Or rather, to have a subobject classifier.
01:06:14 <tomberek> madhadron : i think so, yes
01:06:21 <c_wraith> dolio: Well...  Hmm.  I guess I'd consider const or flip const on t to be be reasonable implementations for making that applicative, but I can see why people would disagree with me.
01:06:26 <tomberek> madhadron : most of it works already
01:06:26 <c_wraith> err, on r
01:06:59 <tomberek> danharaj : at the moment, i'm looking for (Functor f) => f a -> f b -> f c   where b is going to be a product of a and b
01:07:36 <madhadron> tomberek, And c is?
01:08:50 <tomberek> madhadron : this is where my type and kind thinking gets lost... I want c to simply be the product of a and b.... I have a typeclass already for this.
01:09:11 <madhadron> tomberek, But seriously, try just writing down the types ZippableFunctor f where fzip :: f a -> f b -> f (a,b)
01:09:19 <dolio> c_wraith: That only works if you use undefined in pure, which is 1) rather haskell-centric, 2) lame.
01:09:38 <madhadron> and UnzippableFunctor where fhead :: f (a,b) -> f a and ftail :: f (a,b) -> f b
01:10:05 <madhadron> May not be the most elegant interface (essentially, it's pretending that pairs are cons cells in the type systems), but it should get you something alive enough to play with
01:10:47 <tomberek> madhadron: almost exactly what i would need, except instead of (a,b) i would have c with a constraint that (Item c ~ a,Label c ~ b) or something
01:10:57 <tomberek> madhadron : (i'm using ATs)
01:11:44 <madhadron> tomberek, Their names are Car and Cdr (:  But in that case your problem is getting the last details of the type signature write?
01:13:26 <tomberek> Car Cdr ?         i'm sure some of edwardk's zipping and unzipping functors might be what i need, but it's hard for me to wrap my head around more than few paragraphs of most of his posts
01:13:29 <cads> why's it called car and cdr?
01:14:15 <madhadron> tomberek, I'm not familiar with his posts.
01:14:23 <tomberek> http://comonad.com/reader/2008/zipping-and-unzipping-functors/
01:14:27 <dolio> cads: It has to do with register names on the old lisp machines (or something along those lines) as I recall.
01:14:28 <madhadron> Car and cdr - first and second of a cons pair in Lisp
01:14:40 <madhadron> dolio, Actually it predates the lisp machines.
01:14:47 <dolio> Ah.
01:14:48 <madhadron> Though I forget the exact hardware
01:15:00 <madhadron> But truly ancient
01:15:09 <cads> so the car register held the head of the list and cdr held the adress to the rest of it?
01:17:10 <madhadron> cads, Actually car was the pointer to the head, but yes.
01:17:31 <cads> ah, yes
01:17:38 <madhadron> tomberek, If you ignore his prose, which just uses lots of category theory names, the code is very clear
01:18:15 <freiksenet> I have an algebraic type with 5 different variants. They have to be ordered not only by the variant but by one other parameter that is shared among them all. for now i have huuuuge compare function, about 50 lines, that covers all possibilities. is there an easier way to do that?
01:18:26 <tomberek> madhadron: that was a general comment about him... hehe... but what i'm trying to do different is not force the use of (,)
01:18:58 <madhadron> tomberek, So you're defining a type family isomorphic to (,)
01:19:18 <tomberek> madhadron, a typeclass isomorphic to (,)
01:19:25 <soupdragon> freiksenet, let me see it?
01:19:40 <freiksenet> I am REALLY ashamed of that tbh
01:19:44 <freiksenet> https://gist.github.com/3929427142b734bc749f
01:20:29 <madhadron> tomberek, Sure.  So you have class PairLike f a b where car :: f a b -> a and cdr :: f a b -> b?
01:21:05 <tomberek> madhadron,, yeah, look http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25830#a25830
01:21:13 <soupdragon> looks fine to me
01:21:24 <madhadron> freiksenet, You can define a common accessor function for all the variants if they share a field of the same type
01:22:26 <freiksenet> https://gist.github.com/3929427142b734bc749f like that?
01:22:33 <madhadron> i.e., data Type = First { boris :: String, ... } | Second { boris :: String, ... }
01:22:48 <freiksenet> ah
01:23:03 <freiksenet> and then I can access any type with just boris?
01:23:08 <madhadron> Right
01:23:12 <tomberek> madhadron: once I had instance (Applicative f, Product m)=>Product (Wrap f m)   i was able to play with an Applicative of Products as a Product
01:23:18 <madhadron> So you define one function which compares constructors, a second which compares the result of boris
01:23:19 <freiksenet> ok, that would make it easier
01:23:25 <madhadron> and then it should collapse nicely
01:23:35 <freiksenet> thanks a lot
01:23:58 <freiksenet> can I pattern match records like (Foo _ _ _) or I always need to use {} notation?
01:24:09 <madhadron> freiksenet, Both work
01:24:12 <tomberek> freiksenet: you can pattern match
01:24:21 <freiksenet> thanks a lot again.
01:24:25 <madhadron> freiksenet, but for the constructor comparison, it's probably more concise to use {}
01:24:46 <freiksenet> madhadron: ok, thanks
01:24:47 <madhadron> tomberek, And your problem is that liftA2 is not behaving as you would expect?
01:25:47 <triyo> I'm trying to give the new 'berp' lib a try, but I get an error when attempting to perform an install. "cabal: cannot configure berp-0.0.1. It requires integer -any". Any ideas how to resolve this pls?
01:25:53 <tomberek> madhadron,, hm... I don't know what id does with differences in structure,, but that is what i was thinking of using.
01:26:00 <tomberek> id->it
01:26:14 <madhadron> tomberek, Depends entirely on your instance definitions
01:26:55 <madhadron> triyo, Is integer listed in the library dependencies in the cabal file?
01:27:10 <madhadron> tomberek, If you use zip as the instance of fzip, then it will just discard anything beyond the short of the two
01:27:59 <tomberek> madhadron, (Functor f,Product c,Item c ~ a,Label c ~ b) => (a->b->c)->f a -> f b -> f c   would be it
01:28:55 <triyo> madhadron: yup, its a build dependency "integer"
01:29:11 <madhadron> madhadron, liftA2 should fit, since it generalizes that type.
01:29:42 <madhadron> No, wait
01:29:47 <madhadron> Product doesn't imply Applicative
01:30:02 <madhadron> triyo, That should have been in your base ghc installation, I think.
01:30:06 <tomberek> madhadron : btw, props on you for being able to answer multiple questions at the same time.. thanks for the help, i'll try liftA2.... does what i'm doing make sense?
01:30:38 <madhadron> tomberek, It seems to make sense.  My real attention right now is on compiling GHC, but I see no warning bells
01:30:50 <madhadron> As for multiple questions, I've been on IRC for a *long* time.  You learn to conversation switch.
01:31:03 <ivanm> tomberek: before you ask, no, I haven't done anything more :p
01:31:10 <tomberek> madhadron : thanks
01:31:19 <tomberek> ivanm : hehe,, someone has to light the fires
01:31:21 <madhadron> Must be 13 years now.
01:31:38 <tomberek> ivanm : under people's asses that is
01:31:50 <madhadron> Or for insurance fraud
01:32:11 <tomberek> that too
01:32:38 <ivanm> tomberek: leave my poor donkey alone! :p
01:33:55 <dolio> c_wraith: Now that I think of it, const and flip const don't work, either, because they violate equational rules that the applicative methods would be expected to follow.
01:34:05 <tomberek> btw, donkey's must be REALLY good workers if it's worth raising a sterile animal
01:34:29 <ivanm> tomberek: you referring to mules? and yes, they are
01:34:29 <tomberek> no wait, that's mule
01:34:35 <dolio> pure f <*> x would not be the same as f <$> x with const.
01:34:38 <ivanm> also hardy, etc.
01:34:43 <ivanm> mule = donkey + horse IIRC
01:34:55 <freiksenet> madhadron: Once again - thanks a lot, this simplified everything SO much.
01:34:56 <dolio> And f <*> pure x would not be the same as ($x) <*> f with flip const.
01:35:08 <dolio> Er, ($x) <$> f.
01:35:20 <ddarius> ivanm: Specifically a male donkey and a female horse.
01:35:37 <madhadron> ivanm, Beat me to it.  The converse being a hinny.
01:35:46 <tomberek> hehe
01:35:47 <madhadron> freiksenet, You're welcome.
01:35:58 <ivanm> ddarius: yeah, that sounds more tractable
01:35:59 <ivanm> s/tractable/likely/
01:36:21 <dolio> You need the identity rule of the monoid action for those rules to hold with (,) r.
01:37:31 <triyo> hmm, now I get "cabal: dependencies conflict: ghc-6.12.1 requires containers ==0.3.0.0 however containers-0.3.0.0 was excluded because berp-0.0.1 requires containers ==0.2.*"
01:38:30 <ivanm> triyo: because bernie seems to be using ghc 6.10 still
01:38:38 * dolio goes back to bed.
01:39:04 <ivanm> and thus the deps for berp reflect that (you should be safe in editing the cabal file and letting it use containers < 0.4.0.0
01:39:31 <triyo> ivanm, I see, makes sense since I'm on 6.12.1
01:40:14 <ivanm> there were a few changes from containers 2 to containers 3, but I doubt they were large enough such that berp needs 0.2.0.0
01:41:54 <tomberek> madhadron: liftA2 does something a little different. It enforces that the product is inside the Functor/Applicative.  close though
01:42:50 <madhadron> tomberek, So now you get to decide whether you want to change your Product instance for list or write your own liftA2
01:43:24 <madhadron> Anyway, I need to dive into my own code now.
01:43:28 * madhadron dives down the rabbit hole.
01:43:34 <tomberek> madhadron: thanks!
01:46:17 <alip> is haskell.org down?
01:47:00 <ivanm> alip: http://downforeveryoneorjustme.com/haskell.org
01:53:32 <Twey> Why does Lato's Iteratee chapter in the new TMR have only a single chunk for the rest of the stream in the Done constructor of IterV?  Surely it should be the whole rest of the stream?
02:03:32 <glguy> Twey: Doesn't it return the remainder of the chunk that it was working on?
02:04:18 <glguy> The IterV is either a result and a remaining chunk or a continuation requiring yet another chunk. It doesn't have access to the whole stream
02:04:40 <Twey> glguy: Oh!  I see.  The enumerator takes care of the rest.
02:10:27 <mreh> happy bank holiday
02:10:35 <alexbobP> 'sup scotty
02:13:48 <sioraiocht> is there a way to force GHC to recompile all files using --make?
02:15:49 <ibid> is www.haskell.org down for just me or generally?
02:16:08 <Twey> sioraiocht: --force-recomp?
02:16:17 <Twey> ibid: http://downforeveryoneorjustme.com/haskell.org
02:16:21 <sioraiocht> Twey: thanks
02:16:27 <ivanm> Twey: bah, beat me to it
02:16:55 <ibid> Twey: ok, then would you mind pinging the admins, since you knew that :-)
02:18:50 <ibid> (never mind, i figured i have a local installation of the docs:)
02:28:02 <earthy> cool. now there's an error I had'nt seen before.
02:28:27 <earthy> 'Kind mis-match. The first argument of `m' should have kind `k', but `(# a, s #)' has kind `(#)''
02:28:41 <earthy> 'pity'
02:35:09 <mreh> earthy: which compiler are you using?
02:36:42 <soupdragon> > 0o7777777/0o123457
02:36:43 <lambdabot>   49.0
02:36:49 <earthy> ghc 6.12
02:36:49 <soupdragon> > 0o61
02:36:50 <lambdabot>   49
02:36:59 <mreh> earthy: I have never seen that before in my life
02:37:06 <mreh> I've seen plenty of kind errors
02:37:16 <earthy> mreh: I found it suitably interesting. :)
02:37:41 <mreh> (##) is a CPP thingy isn't it?
02:37:54 <earthy> but basically I've tried to wrap a monad around an unboxed tuple, which can't be done
02:38:03 <Jafet> It's a ghc thingy
02:38:13 <Jafet> I think
02:38:30 <earthy> (there's no reference to an unboxed tuple, so you can't use unboxed tuples where you can use ordinary types of data)
02:39:11 <Jafet> Demand strict monads today
02:39:14 <mreh> earthy: sorry to be a pain, but are you sure you need an unboxed tuple?
02:39:34 <mreh> yeah, can't you make it strict?
02:39:55 <earthy> mreh: I don't necessarily need it, si I just dropped it again
02:40:07 <earthy> this was ghc telling me nicely to reconsider :)
02:40:46 <Jafet> mreh, depends on whether you can write that monad in haskell, probably
02:41:08 <Jafet> And then, of course, it wouldn't work with its non-strict progenitor
02:53:50 <ski> mreh : `(#)' is the kind of unboxed tuples (`(# t0 , t1 , ... #)')
02:55:42 <mreh> what does (# unpack #) mean?
02:56:21 <tomberek> how can I do this  :: (Functor f) => f String -> String  ?
02:57:10 <mreh> tomberek: it depends on the functor
02:57:13 <ivanm> yeah
02:57:22 <mreh> @src functor
02:57:22 <lambdabot> Source not found. You speak an infinite deal of nothing
02:57:24 <tomberek> thought so
02:57:26 <mreh> @src Functor
02:57:26 <lambdabot> class  Functor f  where
02:57:26 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
02:57:28 <ivanm> tomberek: the only thing you can do on a generic functor is fmap
02:57:33 <mreh> it's impossible
02:57:45 <tomberek> yeah, it makes sense
02:58:12 <tomberek> what's the first thing in the Functor,Applicative,Monad,etc hierarchy that can do it?
02:58:20 <ivanm> tomberek: none of them can
02:58:34 <ivanm> tomberek: the closest you have is >>= in Monad
02:58:38 <ivanm> @src Applicative
02:58:38 <lambdabot> class Functor f => Applicative f where
02:58:39 <lambdabot>     pure  :: a -> f a
02:58:39 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
02:58:48 <BONUS> comonad can :]
02:58:56 <mreh> what's the other name of pure?
02:58:59 <mreh> <$>?
02:59:16 <tomberek> mreh: looked it up,, it's a Copointed Functor
02:59:16 <ivanm> return
02:59:32 <tomberek> @src Copointed
02:59:32 <lambdabot> Source not found. Maybe you made a typo?
02:59:48 <tomberek> extract :: f a -> a
02:59:53 <ski> mreh : unboxed uni-tuple containing `unpack' ?
03:00:12 <mreh> > (1)
03:00:13 <lambdabot>   1
03:00:44 <ski> @kind (# Int #)
03:00:45 <lambdabot> (#)
03:00:51 <ski> that's an unboxed uni-tuple
03:01:06 <mreh> oh, cool
03:01:13 <ski> > case (# (23 :: Int) #) of (# n #) -> n
03:01:14 <lambdabot>   23
03:01:20 <scree> tomberek: most applicatives/monads etc. are not also in the co-heirarchy
03:01:42 <ski> (you can only evaluate values of types of kind `*' at the top-level in lambdabot)
03:01:50 <ski> > (# (23 :: Int) #)
03:01:51 <lambdabot>   Illegal binding of unboxed tuple e_123 :: (# GHC.Types.Int #)
03:02:04 <ski> > let it = (# (23 :: Int) #) in ()
03:02:04 <lambdabot>   Illegal binding of unboxed tuple it :: (# GHC.Types.Int #)
03:02:09 <tomberek> scree: ya , i'm thinking i might be able to use copointed.... i've been working on understanding as much of the stuff in category-extras as i can
03:02:29 <scree> tomberek: what's the application?
03:03:14 <tomberek> scree: A Show instance for Showable things wrapped in a Functor
03:03:33 <tomberek> but wait,, in this case, it's wrapped in []
03:04:14 <tomberek> scree: I need something else   ,,, Foldable?
03:05:36 <scree> tomberek: sounds about right
03:05:53 <scree> tomberek: though your separator won't be type-specific
03:05:57 <tomberek> hm, Foldable doesn't live in edward's hierachy
03:06:07 <scree> tomberek: and you lose all other structural information
03:06:14 <ski> tomberek : `instance Copointed w => Show (exists a. Show a => w a)' ?
03:06:27 <ski> er, s/=> w a/*> w a/
03:07:34 <tomberek> ski: i would, but because I know i'll be using [] a lot.   [] is not copointed
03:07:59 <HugoDaniel> why is it that the more i know haskell, the more i feel i dont know :(
03:08:08 <ski> tomberek : but you're abstractly trying to make such an instance ?
03:08:53 <ski> HugoDaniel : as you learn more, since there's still much to learn, the visible boundary of things you see, but don't understand yet, expands
03:09:05 <tomberek> yes, it really seems that Foldable is the way to go, but I'm trying to understand what abstraction is correct   (I could have gotten a trivial version a while ago, i'm just learning)
03:09:08 <HugoDaniel> :(
03:09:36 <ski> (and i suppose that probably holds in any nontrivial field of knowledge)
03:10:29 <ski> tomberek : btw, i'm not sure i see how you could sensible define such an instance
03:11:01 <tomberek> ski, it would have to throw away structure info, that's why i think Foldable and Monoid can do it
03:11:07 <ski> tomberek : .. maybe what you're really after is to be able to show `[Showable]' sensibly ?
03:11:14 <ski> hm
03:11:21 <ski> that might work
03:11:27 <scree> tomberek: right, anything you write will be equivalent to:
03:11:53 <kmc> :t show . toList
03:11:54 <lambdabot> Not in scope: `toList'
03:12:00 <kmc> :t show . Data.Foldable.toList
03:12:01 <lambdabot> forall (t :: * -> *) a. (Show a, Data.Foldable.Foldable t) => t a -> String
03:12:15 <scree> instance (Foldable t) => Show (t Showable) where show = show . toList
03:12:38 <ski> @type flip (Data.Foldable.foldr shows)
03:12:39 <lambdabot> forall a (t :: * -> *). (Show a, Data.Foldable.Foldable t) => t a -> String -> String
03:12:52 <scree> damn, the lambdabot is faster than me *again*
03:13:01 <ski> hm, not quite that, but along that line
03:13:34 <ski> hm, one'd need a way to denote the `t' structure in the output
03:13:35 <tomberek> scree: working on it
03:14:00 <ski> (and i suppose one would prefer `fold' to `foldr', since that would preserve e.g. nesting in trees)
03:14:20 <ski> @hoogle Foldable t => [a] -> t a
03:14:20 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
03:14:21 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
03:14:21 <lambdabot> Data.Sequence fromList :: [a] -> Seq a
03:15:23 <ski> scree : the problem (imo) with that would be that showing it as a list won't produce valid haskell code which can be executed at type `t a'
03:15:36 <ski> (other than that, it should be fine)
03:15:55 <ski> (hm .. well, modulo nesting issue, actually)
03:16:01 <tomberek> scree: instance (Functor f, Foldable f, Show m) => Show (Wrap f m)
03:16:10 <tomberek> show = foldMap id . fmap show . unwrap
03:16:15 <ski> tomberek: @src Wrap
03:16:25 <scree> @src Wrap
03:16:25 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:16:26 <tomberek> newtype Wrap f m = Wrap {unwrap::f m}
03:17:24 <scree> @type foldMap
03:17:25 <lambdabot> Not in scope: `foldMap'
03:17:28 <tomberek> it works,,, thanks for the idea-bouncing
03:17:35 <ski> @type Data.Foldable.foldMap
03:17:35 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
03:17:57 <ski> tomberek : that would just concatenate the `show' result of each element .. not that good
03:18:19 <scree> also, what's wrong with foldMap show . unwrap?
03:18:39 <ski> tomberek : btw, `foldMap id = fold'
03:19:15 <tomberek> ski: yeah,,, duh.. foldMap show. unwrap is the same
03:19:17 <ski> scree : that'd be equivalent to (and simpler than) what tomberek said, yes
03:19:37 <scree> ski: I'm pretty sure there's no good way to encode the nesting in general
03:20:09 <scree> ski: without inventing some amusing new typeclass
03:20:24 <tomberek> ski, how can i modify that to insert, say a comma between elements?
03:20:35 <ski> scree : i think this really calls for `Show1'
03:20:38 <scree> tomberek: show . toList
03:21:10 <ski> (`Typable' : `Typable1' : `Typable2' : ... :: `Show' : `Show1' : `Show2' : ...)
03:21:28 <ski> tomberek : you need special code for each `f', that tells how to do that
03:21:34 <ski> like with a `Show1'
03:21:40 <scree> ski: why is that better than Show a => Show (t a)?
03:21:57 <tomberek> scree: where's that toList?
03:22:08 <tomberek> got it
03:22:51 <tomberek> scree,ski: ok, now the other question... what kind of abstract is Foldable?
03:23:07 <ski> (scree : .. thinking on that question)
03:23:36 <ski> one answer would be that `Show (t a)' there requires some extension (which ?)
03:23:49 <ski> but the question would then be how bad (or not) that is
03:24:04 * ski seems to recall there being some argument, and is trying to recall it
03:24:58 <scree> ski: I don't think it does
03:25:08 <ski> (you don't think it does what ?)
03:25:15 <scree> need an extension
03:25:23 <tomberek> scree: Show a => Show (t a) has overlaps
03:25:31 <ski> `Show (t a)' is not a valid Haskell 98 instance head
03:25:51 <ski> so, it definitely needs an extension
03:26:08 <tomberek> FlexibleInstances , maybe UndeciableInstances as well
03:26:48 <ski> hrm
03:26:52 <scree> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25831#a25831
03:26:58 <ski> maybe i'm confusing things in my head
03:27:00 <scree> compiles with me
03:27:16 <scree> also, data ... deriving (Show) has exactly that signature
03:27:37 <ski> scree : hm, actually, i think you're talking about doing that instance for a specific `t' .. while i for some reason where thinking about `t' being a type variable
03:27:41 * ski looks at the paste
03:27:54 <scree> ski: the paste is trivial
03:28:46 <scree> ski: oh, right
03:29:08 <scree> but even with Show1, there's no generic way of doing this is there?
03:31:06 <alip> i'm trying to build a haskell library using cabal but i get "Setup: No (or multiple) ghc rts package is registered!!" how should i proceed?
03:31:29 <tomberek> scree: generic way to do what?
03:31:40 <dcoutts> alip: check ghc-pkg list rts
03:31:49 <scree> ga
03:32:48 <scree> well, class Show1 t where show1 :: t a -> String
03:33:09 <scree> doesn't even have a way of showing the contents
03:33:49 <alip> dcoutts: http://paste.pocoo.org/raw/220296/ it looks ok
03:34:16 <scree> and instance (Context t, Show a) => Show (t a) has overlaps &c., and is also fairly rubbish for any generic choice of Context as it loses structure
03:34:35 <scree> all the rest is a misunderstanding (sorry ski)
03:35:40 <dcoutts> alip: is that the only ghc instance? could cabal be picking up the wrong ghc-pkg ?
03:35:46 <ski> scree : sorry, my connection locked up for a while
03:35:57 <tomberek> scree: but no idea what Foldable actually means?
03:36:07 <tomberek> it's almost copointed,, but with a stop
03:36:18 <ski> scree : `class Show1 f where showsPrec1 :: Show a => Int -> f a -> ShowS' is what i meant
03:36:46 * scree finally understands
03:36:46 <alip> dcoutts: ghc-pkg is a symlink to ghc-pkg-6.10.4 and it's the only ghc instance
03:38:10 <scree> but I'd still prefer: instance Show a => Show (Wrap t) a
03:38:17 <dcoutts> alip: did it just start doing this or has it done it from the moment you installed ghc?
03:38:29 <alip> dcoutts: the latter
03:38:31 <tomberek> scree : you mean (Wrap t a) ?
03:38:32 <scree> tomberek: Foldable just means a collection you can fold over
03:38:51 <tomberek> scree: sure, but I'm trying to figure out what that is in 'category-speak'
03:39:13 <tomberek> some comonoidal ring of hylofunctors,, or whatever
03:40:08 <freiksenet> is it possible to make standalone executables with GHC? like exe files that will run on windows without ghc installed
03:40:21 <tomberek> frieksenet: yes
03:40:39 <alip> dcoutts: i installed cabal using cabal-install's bootstrap.sh as a normal user fwiw
03:41:08 <Jafet> freiksenet, link the runtime statically
03:41:27 <dcoutts> alip: what does cabal --version report btw?
03:41:41 <ski> freiksenet : btw, note that usually, when you run "standalone" executables written in C, they dynamically link with a run-time library for C
03:42:08 <alip> dcoutts: cabal-install version 0.8.2, using version 1.8.0.2 of Cabal library
03:42:15 <HugoDaniel> the json package is amazing :)
03:42:19 <freiksenet> I am just wondering what is the best way to distribute stuff made with haskell on windows
03:42:26 <freiksenet> while linux people can easily use cabal
03:42:36 <freiksenet> it is probably too much to ask from windows people
03:43:38 <ski> scree : ah, now i think i recall one argument in favor of `Show1'
03:43:43 <Jafet> If your ghc runtime depends on a C runtime, it might get messy. Otherwise I don't see any problem
03:43:51 <jeltsch> freiksenet: You may distribute an *.exe file, but you should use Cabal/HackageDB in addition, so that your software is more easily found.
03:44:20 <tomberek> scree: isn't folding a 'Morphism' ?
03:44:32 <freiksenet> jeltsch: yeah, that's the plan.
03:44:34 <ski> scree : consider a higher-order type constructor of kind, say `(* -> *) -> *' (or `(* -> *) -> * -> *' if you prefer), one example of this is `Mu'
03:44:35 <freiksenet> thanks
03:44:51 <ski> scree : then how do you declare a `Show' instance for `Mu' ?
03:45:07 <ski> scree : with `Show1' you say `instance Show1 f => Show (Mu f) where ...'
03:45:23 <dcoutts> alip: ah hold on, it's failing when configuring a particular package, not doing it for every package
03:45:35 <dcoutts> alip: which package is it?
03:45:39 <ski> scree : without `Show1' you want to say `instance (forall a. Show a => Show (f a)) => Show (Mu f) where ...', but that's not supported
03:46:24 <ski> scree : instead you can try with `instance Show (f (Mu f)) => Show (Mu f) where ...', if you enable `FlexibleInstances' (i think) ..
03:47:14 <ski> scree : .. but that's possibly bad for two reasons :
03:47:22 <ski> scree : (a) it exposes an implementation detail of `Mu f' (that it has `f (Mu f)' internally), which you might not want to expose
03:48:29 <ktzqbp> Haskell.org has been down for hours now - anyone knows whats up?
03:49:19 <dcoutts> ktzqbp: the whole box appears down, while I can ping it I cannot ssh in
03:49:24 <tomberek> scree: ski: aha! Foldable is catamorphism!
03:49:35 <ski> scree : (b) i'm not sure whether that instance is guaranteed to terminate, since the contexts grow
03:50:01 <ski> tomberek : not exactly .. more like "convert-to-list, and then use list catamorhpism"
03:50:11 <ski> (probably not exactly that, but something similar to that)
03:50:41 <tomberek> hm.. dang, i though i was clever..... or is Foldable, just a basic thing, not a build up of other things?
03:51:25 <ski> tomberek : consider e.g. `data Tree a = Tip | Node a (Tree a) (Tree a)', the natural catamorphism on this is `foldTree :: o -> (a -> o -> o -> o) -> (Tree a -> o)', not `foldr :: (a -> o -> o) -> o -> (Tree a -> o)'
03:52:05 <ski> i would tentatively regard `Foldable' as an ad-hoc thing, that doesn't really have a that nice general description
03:52:18 <ktzqbp> dcoutts: so long as the head honchos are onto the problem :)
03:52:40 <ski> (i'm not even sure what laws it is supposed to satisfy, though maybe it's the ones you'd expect from "convert-to-list, then fold")
03:52:57 <tomberek> ski: how did you derive that?
03:53:05 <ski> derive what ?
03:53:15 <dcoutts> ktzqbp: I don't expect any resolution until morning US east cost time
03:53:18 <tomberek> ski: the natural catamorphism
03:54:30 <ski> tomberek : `Tip :: Tree a' and `Node :: a -> Tree a -> Tree a -> Tree a', so say `foldTree (tip :: o) (node :: a -> o -> o) :: Tree -> o', replacing `Tree a' with `o' in the types of the arguments corresponding to the constructors
03:55:10 <ski> tomberek : if you do this with `data List a = Nil | Cons a (List a)' you get `foldList (nil :: o) (cons :: a -> o -> o) :: List a -> o', except the order of `nil' and `cons' is flipped
03:56:46 <Cale> tomberek: The general idea is that the catamorphism replaces the constructors of a datatype with other functions/values throughout the structure.
03:56:54 <tomberek> Cale, ski, thanks!
03:57:02 <ski> (and the definition of `foldTree' is automatic : `foldTree tip node Tip = tip; foldTree tip node (Node a t0 t1) = node a (foldTree tip node t0) (foldTree tip node t1)', calling recursively on the recursive parts of the constructors)
03:57:49 <Jafet> Same way as how ghc derives it, I suppose
03:58:55 <ski> (if you use the type recursively inside some other type constructor in an argument of a data constructor, then you need to call `fmap' on that type constructor .. and the non-regular (/ nested) case is harder)
03:59:32 <scree> so, I guess Foldable is just any functor with an embedding in the List functor
04:00:06 <tomberek> Cale, ski: I'm still new to some of this,, i'm now looking at cata in Control.Morphism.Cata... Functor for structure, FixF for recursion, what's the 'Algebra'?
04:00:25 <tomberek> scree, that makes sense
04:01:04 <ski> tomberek : in the case of `Tree' above, you have `data TreeAlgebra a o = TipA | NodeA a o o', in the `List' case you have `data ListAlgebra a o = NilA | ConsA a o'
04:01:16 <ski> note now that
04:01:34 <alip> dcoutts: indeed, it's a simple library i'm writing here's its cabal file http://paste.pocoo.org/raw/220306/
04:01:55 <ski>   foldTree :: o -> (a -> o -> o -> o) -> (Tree a -> o)
04:01:58 <ski> corresponds to
04:02:00 <tomberek> so the algebra defines what sorts of structures are possible?
04:02:09 <ski>   foldTree :: (TreeAlgebra a o -> o) -> (Tree a -> o)
04:02:25 <dcoutts> alip: you're building using runghc Setup.hs I suppose, rather than using cabal.
04:02:34 <ski> the algebra defines the "shape" of the constructors
04:03:01 <tomberek> looks like shape ~ kind
04:03:06 <tomberek> is that close?
04:03:12 <ski> not really
04:03:24 <mindThomas> Hi
04:03:25 <alip> dcoutts: yeah but using cabal build gives the same error
04:03:54 <ski> tomberek : have you seen algebras in math, like monoids or groups ?
04:04:21 <dcoutts> alip: ghc-pkg check does not report any problems?
04:04:25 <tomberek> ski : i'm an engineer, we don't go that abstract, but I'm learning
04:04:32 <mindThomas> Any UK guys in here who would call their local O2 store for me and ask if they have any O2 Joggler's left?
04:04:36 <alip> dcoutts: nope
04:05:17 <dcoutts> alip: clearly this should not happen, we might find out slightly more if you install Cabal-1.8.0.4
04:05:43 <ski> tomberek : well, a monoid consists of a set/type `m', together with two operations `empty :: m' and `(++) :: m -> m -> m'
04:05:56 <tomberek> ski: i got monoids
04:06:06 <dcoutts> alip: it ignores that particular problem, though no-doubt if it still thinks the rts package is missing then that'll lead to other problems.
04:06:20 <tomberek> ski: binary operation and a 'zero'
04:06:22 <ski> tomberek : such that `forall m1. empty ++ m1 = m1', `forall m0. m0 ++ empty = m0' and `forall m0 m1 m2. (m0 ++ m1) ++ m2 = m0 ++ (m1 ++ m2)'
04:06:23 <dcoutts> but it might give us more of a cluse
04:06:25 <dcoutts> clue
04:06:59 <tomberek> ski:associative binary operation and a zero
04:07:11 <ski> tomberek : now, to make this a little bit more interesting, say that we add another operation `singleton :: Integer -> m'
04:07:59 <tomberek> ski : um, where did Integer come from ? or is that a Nat?
04:08:13 <ski> tomberek : so, now we have : monoids where elements can "be" `Integer's
04:08:23 <ski> i just added it, arbitrarily
04:08:33 <tomberek> ski: oh, i see
04:08:43 <ski> so, this is not monoid, it is monoids with an additional operation (no new laws)
04:08:48 <ski> this is just to make it more interesting
04:09:01 <ski> now, examples of monoids
04:09:37 <ski> there is a monoid where `m = Integer', `empty = 0' `(++) = (+)',`singleton = id'
04:10:02 <ski> s/monoid/monoid "over" `Integer's/
04:10:10 <ski> this could be called the `sum' monoid "over" `Integer's
04:10:13 <tomberek> ski: 0 and (+),,, 1 and (*)
04:10:47 <ski> yes, the latter (with `singleton = id') would be the `product' monoid "over" `Integer's
04:11:01 <tomberek> empty=12 (++)=(+) singleton = mod 12
04:11:11 <tomberek> that's the clock monoid?
04:11:15 <ski> there's also one where `m = String', `empty = ""', `(++) = (Data.List.++)', `singleton = show'
04:11:25 <ski> tomberek : sure :)
04:11:43 <tomberek> ski, k, i got monoids pretty well
04:12:01 <ski> actually, this last one isn't a monoid, because `show 0' is not `""' but `"0"' .. imagine it was `""' :)
04:12:42 <tomberek> roger
04:12:45 <ville> What is the general scheme for naming ones modules, seems like Haskell people don't go with the Project.Something.Else concept found used in some other language
04:13:01 <ski> tomberek : now, there's a special monoid ("over" `Integer's), called the *initial* monoid ("over" `Integer's, i'll omit this part for the rest)
04:13:15 <ski> this monoid can be presented as
04:13:21 <ski>   m = [Integer]
04:13:24 <ski>   empty = []
04:13:30 <ski>   (++) = (Data.List.++)
04:13:35 <ski>   singleton = (:[])
04:14:04 <tomberek> ah, a collection of integers
04:14:14 <Cale> ville: Heh, it seems like a lot of projects go with the "randomly prefix the general name of my thing with 'Data.' or 'Control.' and hope it's not already taken" method.
04:14:22 <ski> this is called the "initial" monoid, because there's a unique function from this monoid to any other monoid, that "respects" the monoid operations
04:14:24 <yitz> ville: they do, but put that inside the hierarchy somewhere where it makes at least some sense
04:14:42 <yitz> ville: which translates pretty much to what Cale said
04:15:12 <tomberek> m = Set Integer   empty = emptySet  (++) = (insert)   singleton = (insert empty)
04:15:15 <ville> Cale, yitz so the Project'sName... approach isn't a bad idea?
04:15:18 <Cale> "Data" and "Control" are both so general and interrelated to each other that they're essentially both "Misc"
04:15:27 <ski> generally a function from a monoid `(m0,empty0,append0,singleton0)' to `(m1,empty1,append1,singleton1)' is a function, say `f', that has type `m0 -> m1' and which satisfies
04:15:35 <Cale> ville: Yeah, that works fine too :)
04:15:40 <ski> tomberek : yes, that's another monoid .. not the initial one, though
04:15:51 <ski>   f empty0 = empty1
04:16:04 <ski>   f (append0 x y) = append1 (f x) (f y)
04:16:14 <ski>   f (singleton0 n) = singleton1 n
04:16:15 <yitz> ville: if there's somewhere in the existing hierarchy that makes sense to you, prefix that to ProjectName
04:16:16 <tomberek> ski, i though a set is more general..... ok.....
04:16:33 <ski> tomberek : in this case, the list monoid is the one that is the initial
04:16:44 <ville> yitz: so Something.Else.ProjectName...
04:16:56 <ski> anyway, how do we define the initial function from the list monoid to *any* other monoid ?
04:17:03 <ski> answer :
04:17:38 <yitz> ville: e.g. i recently uploaded something related to timezones. there is already popular timezone stuff in Data.Time.LocalTime, so I put mine under that.
04:17:39 <ski>   f : ([Integer],[],(++),(:[])) >---> (mX,emptyX,appendX,singletonX)
04:17:48 <ski>   f [] = emptyX
04:18:11 <ski>   f (ns0 ++ ns1) = appendX (f ns0) (f ns1)
04:18:17 <tomberek> ski: little confused then by 'initial'  , but i'm getting everything so far
04:18:19 <ville> Is there any particular reason why this naming scheme was adopted?
04:18:31 <ski>   f [n] = singletonX n
04:18:46 <ville> Other than it seemed to work at the time and seems to work now.
04:18:51 <ski> to make this actual haskell, we should avoid pattern-matching on `.. ++ ..', so we actually get here
04:18:56 <ski>   f [] = emptyX
04:19:05 <alip> dcoutts: can't upgrade Cabal :S http://paste.pocoo.org/raw/220313/
04:19:06 <yitz> ville: to reduce the chance of name clashes by unrelated things that happen to have the same name
04:19:10 <ski>   f (n:ns) = appendX (singletonX n) (f ns)
04:19:32 <ski> tomberek : ok ?
04:19:33 <yitz> ville: but it turned out that Data and Control as top-level names didn't contribute much to that goal...
04:19:35 <dcoutts> alip: use cabal install cabal cabal-install
04:19:40 <dcoutts> alip: rather than upgrade
04:20:09 <yitz> dcoutts: are there any plans for upgrade ever to be fixed?
04:20:09 <tomberek> ski : got it, still not sure why the list one is 'initial'.. not a set,, or rather a bag
04:20:13 <ville> Ok.
04:20:30 <ski> tomberek : now, the function that for any type `mX' takes `emptyX',`appendX',`singletonX' as arguments, and returns the above `f' function (that turns a `[Integer]' into an `mX') *is*
04:20:39 <yitz> dcoutts: if not for a while, why not just make it an alias for install --reinstall for the meantime?
04:20:43 <ski> the *monoid* fold / catamorphism
04:20:54 <dcoutts> yitz: yes in the short term by making it less visible, changing it to cabal install --upgrade-dependencies
04:21:06 <dcoutts> yitz: it does not mean the same thing as --reinstall
04:21:24 <yitz> dcoutts: i know. but that's what works when you need to do upgrade.
04:21:39 <ski> tomberek : note that for this to be well defined, the arguments `emptyX',`appendX' to the monoid catamorphism should actually form a monoid, i.e. `emptyX' should be left and right unit to `appendX', which should be associative
04:21:49 <dcoutts> yitz: I don't follow that
04:21:57 <ski> i.e.
04:22:01 <dcoutts> yitz: if you need a later version of foo, you just do cabal install foo
04:22:16 <tomberek> ski: you pulled a fast one there somewhere,,, a list has the concept of order, which a fold needs
04:22:34 <ski>   foldMonoid :: forall mX. mX -> (mX -> mX -> mX) -> (Integer -> mX) -> ([Integer] -> mX)
04:22:35 <yitz> dcoutts: that also upgrades the dependencies?
04:22:42 <tomberek> ski: did that get introduced with singleton :: Integer -> m?
04:22:46 <ski>   foldMonoid emptyX appendX singletonX = f
04:22:46 <dcoutts> yitz: no, but then neither does cabal install foo --reinstall
04:22:48 <ski>     where
04:22:53 <ski>     f [] = emptyX
04:22:56 <ski>     f (ns0 ++ ns1) = appendX (f ns0) (f ns1)
04:22:59 <ski>     f [n] = singletonX n
04:23:15 <tomberek> ski, ok
04:23:25 <ski> tomberek : the order comes from that `(++)' is associative, but not necessarily commutative
04:23:54 <ski> tomberek : note that in this conception of lists (as the initial monoid), there is no "cons", there is just "empty" and "append" (and "singleton")
04:24:04 <tomberek> ski, ah!! so it HAS to be a list
04:24:11 <ski> ("cons" might be an implementation detail of this)
04:24:13 <yitz> dcoutts: what exactly is the problem with upgrade? isn't that what one ought to do to get the latest version of a package - with automatic upgrade of whatever else needs to be, without breaking anything else?
04:24:16 <ski> tomberek : "it" being ?
04:24:23 <tomberek> the initial
04:24:39 <ski> yes, there is only one initial monoid
04:24:54 <ski> (it can be represented in many ways, but all will behave the same)
04:25:00 <dcoutts> yitz: the problem with upgrade is that you actually do not want to upgrade all dependencies, for some dependencies like the core ghc packages it is wiser to keep their original versions.
04:25:12 <ski> (generally, in any category, there is at most one initial object)
04:25:32 <dcoutts> yitz: the problem with it is it is too simplistic, it does what it says it's going to do, it just turns out that's not something you want.
04:25:33 <ski> (and we're talking here about the category of monoids ("over" `Integer's))
04:25:47 <alip> dcoutts: still get the same error: http://paste.pocoo.org/raw/220315/
04:25:48 <yitz> dcoutts: how hard is that to fix?
04:26:02 <tomberek> ski:  it's 'over' integers because of singleton :: Integer -> m
04:26:06 <ski> yes
04:26:06 <dcoutts> yitz: it means working out what we think the more useful behaviour should be
04:26:17 <ski> if we omitted that part, it would just be the category of monoids
04:26:27 <tomberek> it would be 'over' pairs if it was singleton :: (Int,Int) -> m      or something
04:26:59 <ski> (and there the initial object is `[()]' with `empty = []' and `append = (++)')
04:27:07 <ski> yes
04:27:32 <tomberek> ski,,,, understanding is creeping in
04:27:39 <ski> the `singleton' is just to make this more interesting .. `[()]' isn't really that interesting in itself
04:28:24 <ski> so, the point is that there is a (unique) way to go from the initial monoid to any monoid you wish, "respecting" the monoid operations
04:28:25 <Cale> ski: Wait, are you sure? It seems like there would be more than one arrow from that monoid to most others.
04:28:48 <ski> Cale : hrm, actually you're right
04:28:48 <dcoutts> alip: ah, it's doing the same check when running hsc2hs, for .hsc files which presumably you're using
04:29:02 <ski> the initial monoid is `[Void]', not `[()]', mea culpa
04:29:13 <ski> (and `[Void]' is even less interesting)
04:29:19 * hackagebot parsec-extra 0.1.0.0 - Some miscellaneous basic string parsers.  http://hackage.haskell.org/package/parsec-extra-0.1.0.0 (AriePeterson)
04:29:26 <Cale> Or just ()
04:29:33 <ski> yes, it's isomorphic :)
04:29:41 <dcoutts> alip: does cabal list --installed --simple report the rts package?
04:29:43 <yitz> dcoutts: first thought - 1. upgrade only those dependencies that are absolutely needed to upgrade this package, and do not break other installed packages (e.g. current version depends on old version of something, no known way to get around that by upgrading it). 2. lock base as a special case 3. when (1) or (2) cause a full upgrade to fail, try again with an intermediate version
04:30:15 <alip> dcoutts: yep
04:30:26 <dcoutts> yitz: we already lock base as a special case, we do 1 anyway for install
04:30:27 <ski> tomberek : anyway, that general way to go from the initial algebra (in our case the algebra kind being monoids), to any algebra *is* the catamorphism for that kind of algebra
04:30:57 <dcoutts> yitz: so I think, apart from 3, that's the behaviour of install
04:31:09 <Cale> The trivial monoid is actually a zero object. It's terminal as well as initial.
04:31:21 <ski> (and if you wonder, "initial object" is defined to be an object where there's a unique morphism from that object to any object in the category)
04:31:26 <dcoutts> yitz: upgrade also tries to install the latest version of all package dependencies, rather than trying to use installed versions of dependencies.
04:31:46 <ski> tomberek : are you still following ?
04:32:02 <tomberek> ski: yes,, what is precise definition of 'algebra' ?
04:32:10 <yitz> dcoutts: leading to breakage?
04:32:11 <ski> i'll come to that
04:32:22 <tomberek> ski : then yes, i follow
04:32:35 <ski> tomberek : now that you've seen monoids ("over" `Integer's), let's take another example of an algebra
04:32:42 <tomberek> Cale was coming up with less interesting monoids
04:33:16 <ski> instead of having a set/type `m' with operations `empty',`append',`singleton'
04:33:30 <dcoutts> yitz: things can break with upgrade for two reasons: successfully installing later versions of core packages leads to problems, sometimes newer versions of core packages fail to install on older ghc (their deps indicate they should but in practise they were not tested).
04:33:47 <ski> lets take algebras that consist of a type `m', with operations `empty :: m', `cons :: Integer -> m -> m'
04:34:08 <ski> and lets say that we now require these operations to satisfy no laws at all !
04:34:08 <Cale> This seems like kind of a weird explanation of algebras to me...
04:34:19 <ski> (this is sometimes called an "anarchic algebra")
04:34:43 <Cale> Though I guess you're avoiding using functors anywhere? :)
04:34:46 <ski> Cale : well, i'm building up to explaining catamorphisms of haskell types
04:34:56 <tomberek> ski, one sec
04:35:05 <dcoutts> alip: and it only lists a single instance of the rts?
04:35:07 <yitz> dcoutts: comparing to say, macports. port install and port upgrade are pretty much the same. except that install fails if that port is already installed, while upgrade fails if it's not already installed. upgrade has the additional option of uninstalling the older version (but not by default)
04:35:27 <alip> dcoutts: yep
04:35:41 <dcoutts> yitz: so the naming/behaviour is different, I'm sure that also adds to the confusion
04:35:43 <Cale> tomberek: Do you know what a functor is?
04:35:47 <yitz> dcoutts: and yeah, upgrade will also upgrade recursively by default.
04:36:04 <tomberek> ski : would an example be   m =  Integer   cons =  const
04:36:06 <dcoutts> yitz: ok, upgrading recursively is the same
04:36:21 <ski> Cale : i'm possibly introducing functors in this context, later, to explain the "shape of an algebra"
04:36:23 <Cale> (I probably shouldn't be jumping into the middle of this :)
04:36:28 <yitz> dcoutts: it's a little different though. the dependencies are usually only build dependencies.
04:36:33 <ski> tomberek : and `empty' being ?
04:36:44 <dcoutts> yitz: the more accurate name for what "cabal upgrade foo" does is "cabal install foo --also-upgrade-dependencies"
04:37:01 <tomberek> ski, forgot about empty
04:37:04 <ski> tomberek : but, yes, it doesn't matter what `empty' is, that is a "list"-algebra (let's call this kind of algebra that)
04:37:23 <dcoutts> alip: I'm almost out of ideas, how much time do you have to work on this?
04:37:32 <ski> (or, rather, for each possible value of `empty', that gives us a "list"-algebra)
04:37:40 <tomberek> ski: roger
04:37:53 <ski> now, we can define list-algebras like
04:37:58 <alip> dcoutts: don't have any time limits, just doing it for fun
04:38:12 <ski>   m = Integer; empty = 0; cons = (+)
04:38:18 <ski>   m = Integer; empty = 1; cons = (*)
04:38:29 <yitz> dcoutts: introspecting, i usually don't want to think through exactly what will happen to the dependencies, it should just work. i say "upgrade" when i want to upgrade something, and "install" when i want to install something. i want there to be easy-to-find options when i actually do need to think about the dependencies.
04:38:33 <dcoutts> alip: did you build this ghc yourself or is it a distro package?
04:38:40 <ski>   m = Integer; empty = 0; cons d n = d + 10 * n
04:38:49 <tomberek> ski , wait
04:38:50 <alip> dcoutts: i built it from FreeBSD ports
04:39:10 <dcoutts> yitz: I think the default should just be install, it handles upgrading the listed packages
04:39:11 <tomberek> ski, there are no laws, so you don't need empty = 1, it could =3
04:39:20 <ski> correct
04:39:38 <ski>   m = Integer; empty = 0; cons = (*)
04:39:44 <ski> is also valid (but a bit boring)
04:39:45 <dcoutts> yitz: as in installing newer versions of them, --reinstall is only needed to reinsall the exact same version as you've got already
04:40:17 <tomberek> ski: agreed
04:40:26 <yitz> dcoutts: make upgrade an alias to install. except at least give a warning when the effect is the other one (installing when you said upgrade or v.v.)
04:40:27 * hackagebot berp 0.0.2 - An implementation of Python 3.  http://hackage.haskell.org/package/berp-0.0.2 (BerniePope)
04:40:29 <ski> now, can you guess what the initial list-algebra is ?
04:41:10 <dcoutts> yitz: I'm planning to disable it entirely and tell people to use install instead
04:41:11 <tomberek> ski, one sec. let me think
04:41:27 <HugoDaniel> i really dislike haskell record syntax :/
04:41:28 * hackagebot language-python 0.3.1 - Parsing and pretty printing of Python code.  http://hackage.haskell.org/package/language-python-0.3.1 (BerniePope)
04:41:45 <ivanm> HugoDaniel: *shrug* as do many others
04:41:47 <dcoutts> yitz: and perhaps tell people if they really really want the old upgrade behaviour then they can use install --upgrade-dependencies, and hopefully most casual users will not do that
04:41:54 <ski> HugoDaniel : record update, or other things as well ?
04:42:03 <yitz> dcoutts: ok, better than the current situation. make sure that the --help clearly explains that install is also for upgrading though.
04:42:09 <dcoutts> yitz: I'm not sure what you mean when you say the effect is the other one
04:42:22 <HugoDaniel> record update yes, but mostly the unmaintainability they bring to my code
04:42:29 <ski> (tomberek : if you can't guess, no matter)
04:42:34 <tomberek> m = 1 empty = 0 cons = (+)   that naturals?
04:42:48 <ski> i think you mean `m = Natural'
04:42:54 <tomberek> yes
04:42:56 <tomberek> Naturals
04:43:02 <yitz> dcoutts: in most package managers, install will not upgrade an existing package. people expect to get an error saying "you've already got that". in that case, they may want to think again before upgrading it.
04:43:02 <ivanm> HugoDaniel: how do they become unmaintainable?
04:43:04 <ski> that is a list-algebra (since the types are correct .. there's no laws to check)
04:43:08 <tomberek> non-negative
04:43:11 <ski> but it's not the initial list-algebra
04:43:16 <dcoutts> yitz: cabal/ghc have (almost) always supported having multiple versions of a package installed, perhaps that's where people's install/upgrade confusion comes from
04:43:23 <tomberek> but that's not the initial?  dang...
04:43:29 <ski> the initial one is
04:43:32 <yitz> dcoutts: conversely, upgrade will not install something that's not already there, except as a dependency.
04:43:39 <ski>   m = [Integer]; empty = []; cons = (:)
04:43:40 <ski> :)
04:43:53 <dcoutts> yitz: where as cabal will happily install a new version, leaving the existing version also installed
04:43:55 <ski> note that this is lists of `Integer's *again*
04:44:03 <yitz> dcoutts: but one of them hidden
04:44:03 <ski> but this time we think of them differently
04:44:27 <dcoutts> yitz: no, both are available, but you get one in scope by default when you use ghci without any -package flags
04:44:36 <dcoutts> you can select either however
04:44:43 <ski> instead of thinking of them as being constructed by `[]',`(++)' and `singleton'  (where we don't really think about how this is represented in the machine)
04:45:01 <yitz> dcoutts: macport also does that. in fact, upgrade leaves the old version around by default (which i find weird, and always override).
04:45:02 <ski> we think of lists as *specifically* single-linked lists, from left-to-right
04:45:10 <HugoDaniel> if i have a function: myFunc (MyData field1 field2 field3) ... and latter decide to add another record to the MyData then that function breaks, and many other that are defined that way
04:45:15 <ski> tomberek : ok ?
04:45:19 <tomberek> ski, how can one know that it's the initial?
04:45:22 <HugoDaniel> also, namespace pollution is very ugly
04:45:30 <ski> tomberek : well, let's define the catamorphism
04:45:38 <HugoDaniel> it would be nice to be able to turn of the function accessor generation
04:45:40 <ivanm> HugoDaniel: well, one alternative is to do myFunc MyData{ fld1 = field1, ... }
04:45:42 <tomberek> ski: ok
04:45:45 <ivanm> or else use the RecordPuns extension
04:45:56 <HugoDaniel> ivanm: yes, thats what i usually end up doing... to avoid that problem
04:46:05 <luite> hmm, the dependencies for berp seem to have been fixed, but compiling Parser.hs gives me a ghc out of memory error
04:46:09 <ski>   foldIntegerList :: forall mX. mX -> (Integer -> mX -> mX) -> ([Integer] -> mX)
04:46:17 <ski>   foldIntegerList empty cons = f
04:46:19 <ski>     where
04:46:23 <ski>     f [] = empty
04:46:31 <ski>     f (n:ns) = cons n (f ns)
04:46:50 <luite> (Parser.hs of the language-python package)
04:46:52 <ski> you should now hopefully note that is the the same as
04:47:00 <ski>   foldIntegerList empty cons = foldr cons empty
04:47:06 <ski> so this is basically `foldr'
04:47:17 <yitz> ivanm, HugoDaniel views can also be helpful. you can hide the constructor and still match on it
04:47:24 <HugoDaniel> hmm
04:47:28 <HugoDaniel> where can i read about views ?
04:47:45 <ivanm> @where views
04:47:45 <lambdabot> I know nothing about views.
04:47:49 * HugoDaniel is googling
04:47:54 <ivanm> lambdabot obviously doesn't live near the beach...
04:48:06 <tomberek> ski, roger
04:48:11 <ivanm> HugoDaniel: it would probably help if haskell.org was up...
04:48:18 <HugoDaniel> yes :/
04:48:31 <yitz> http://downforeveryoneorjustme.com/haskell.org
04:48:43 <ski> @wiki ViewPatterns
04:48:44 <lambdabot> http://www.haskell.org/haskellwiki/ViewPatterns
04:48:54 <ski> or something like that (but `haskell.org' seems to be down ..)
04:49:13 <yitz> @wiki AnythingGoesWhenHaskellOrgIsDown
04:49:13 <lambdabot> http://www.haskell.org/haskellwiki/AnythingGoesWhenHaskellOrgIsDown
04:49:18 <ivanm> yitz: lol
04:49:32 <ivanm> @wiki Why_C_is_better_than_Haskell
04:49:32 <lambdabot> http://www.haskell.org/haskellwiki/Why_C_is_better_than_Haskell
04:50:00 <ski> tomberek : btw, to be strict, this is `Integer'-list-algebras .. we could change `Integer' into anything we like, though
04:50:02 <HugoDaniel> :D
04:50:06 <HugoDaniel> beautiful
04:50:51 <ski> tomberek : so, let's go back to monoids "over" `Integer's for a short while
04:51:22 <tomberek> ski, sure, change Integer to a and you can fold over any list
04:51:27 <ski> why did the initial monoid "over" `Integer's turn out to be *lists* (of `Integer's) ?
04:51:52 <ski> let's say we make a new kind of algebra, almost like monoid "over" `Integer's, but with one difference
04:52:23 <ski> an algebra of this kind consists of a type `m', and operations `empty :: m', `append :: m -> m -> m', and `singleton :: Integer -> m'
04:52:30 <ski> but this time, *no* laws !
04:53:03 <ski> now, one possible such algebra is
04:53:41 <ski>   m = Bool; empty = False; append _ _ = True; singleton _ = False
04:54:39 <tomberek> ski,,  append is boring, it can be and/or
04:54:57 <ski> now, it is impossible to make a morphism from the `[Integer]' whatever-algebra into this whatever-algebra .. this means that `[Integer]' (with `empty = []; append = (++); singleton = (:[])' is *not* the initial whatever-algebra)
04:55:10 <ski> s/morphism/function that respects the operations/
04:56:01 <ski> because `[]' is the same as `[] ++ []', but the catamorphism to the algebra would want to return `False' in the first case, but `True' in the second case
04:56:25 <ski> now, *this* is the initial whatever-algebra :
04:56:50 <ski>   m = IntegerTree; empty = Empty; append = Append; singleton = Singleton
04:56:51 <ski> where
04:56:57 <ski>   data IntegerTree = Empty
04:57:12 <ski>                    | Append IntegerTree IntegerTree
04:57:18 <ski>                    | Singleton Integer
04:58:14 <ski> now you can define a `foldIntegerTree' that will convert `Empty' into `False' and `Append Empty Empty' into `True', when passed the `empty = False; append _ _ = True; singleton _ = False' for the previous whatever-algebra
04:58:25 <ski> tomberek : are you still following ?
04:58:55 <tomberek> ski, it just records all the operations
04:59:00 <ski> exactly
04:59:04 <tomberek> ski: a 'logging' algebra
04:59:12 <ski> the reason why it didn't do that in the monoid case is that we had laws
04:59:33 <ski> the laws required (e.g.) that `(m0 ++ m1) ++ m2 = m0 ++ (m1 ++ m2)'
04:59:39 <tomberek> yeah, the laws make you lose information
05:00:05 <ski> so, we can't just use constructors, since `Append (Append m0 m1) m2' is not the same as `Append m0 (Append m1 m2)' -- they can be distinguished
05:00:09 <ski> right
05:01:01 <ski> but if we try with `[Integer]' and define `empty = []' and `singleton x = x : []' and `append' defined in the usual recursive case over the *`[]' and `(:)'* constructors, *then* it works out fine
05:02:12 <ski> so, in haskell, often we don't think of out types as having any particular laws (we can't even express the laws in the language, so they'd have to be written in comments, and the type made abstract, to avoid abuse)
05:02:46 <ski> so, most commonly, the haskell type will have one constructor for each operation
05:03:35 <tomberek> ski,,, a data constructor for these operations... hm..
05:03:41 <ski> s/out types/the data constructors of our types/
05:04:24 <ski> like with `IntegerTree' above .. one constructor for each of the operations `empty :: m', `append :: m -> m -> m', `singleton :: Integer -> m'
05:05:20 <ski> now, lets look at the `Integer'-list-algebras again
05:05:35 <ski> they had `empty :: m' and `cons :: Integer -> m -> m' as operations (no laws)
05:05:45 <ski> the initial such algebra is just
05:05:56 <ski>   m = [Integer]; empty = []; cons = (:)
05:06:24 <ski> (so, one constructor for each operation, since we have no laws that requires us to lose information)
05:06:38 <ski> *another* such algebra is
05:06:46 <ski>   m = Integer; empty = 0; cons d n = d + 10 * n
05:07:26 <ski> now, since the former is an initial object, we have a unique function from the former to the latter, respecting the operations
05:07:42 <ski>   f :: [Integer] -> Integer
05:07:49 <ski>   f [    ] = 0
05:08:09 <ski>   f (d:ns) = d + 10 * f ns
05:08:19 <ski> and this is the same as
05:08:22 <tomberek> ski sure
05:08:34 <ski>   f = foldList 0 (\d n -> d + 10 * n)
05:08:37 <ski> which is the same as
05:08:42 <ski>   f = foldr (\d n -> d + 10 * n) 0
05:08:46 <ski> so, when we say
05:08:59 <ski> > foldr (\d n -> d + 10 * n) 0 [1,4,2,8,5,7]
05:09:00 <lambdabot>   758241
05:10:47 <ski> we're *really* (implicitly) defining/using an `Integer'-list-algebra `m = Integer; empty = 0; cons d n = d + 10 * n', and using the initial morphism from the intial object to this algebra to translate the `[1,4,2,8,5,7]' (an element of the initial algebra) into this latter "backwards-decimal number" `Integer'-list-algebra
05:10:50 * hackagebot console-program 0.1.0.0 - Interprets the command line and a config file as commands and options  http://hackage.haskell.org/package/console-program-0.1.0.0 (AriePeterson)
05:11:38 <tomberek> ok, so a list of numbers to numbers written in some base
05:11:54 <tomberek> ski: the concept of a list of numbers -> concept of written numbers
05:12:25 <ski> yes, when we fold/catamorphate on the list (the element of the initial foo-algebra), we convert into another custom foo-algebra, given by the initial arguments to the fold/catamorphism
05:13:37 <ski> (the initial arguments here being `(\d n -> d + 10 * n)' and `0', corresponding to `m = Integer; empty = 0; cons d n = d + 10 * n' in our custom algebra that we want our result in)
05:13:43 <ski> now, if you look at
05:13:51 <ski> @type Data.Foldable.fold
05:13:51 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
05:14:14 <ski> this could be written as
05:14:31 <ski>   Data.Foldable.fold :: Foldable t => m -> (m -> m -> m) -> (t m -> m)
05:14:43 <ski> if we want to not use the `Monoid m' constraint
05:15:27 <ski> but since `Monoid' is an algebra that has laws, we *really* should make sure that the `m -> m -> m' operation we would pass to this `fold' is actually associative (and has the `m' argument as left and right unit)
05:16:08 <ski> since we actually have a nice `Monoid' class, we can avoid passing those (`empty' and `append') operations for the `m'-monoid we're mapping into
05:16:41 <ski> so we don't have to check each time we apply `fold' that the operations satisfy the laws (but instead we have to check that everytime we make an instance of `Monoid')
05:17:09 <tomberek> ski, roger
05:17:15 <ski> this comes at the price of making it harder to use more than one set of operations on a particular haskell type
05:18:09 <ski> (hence you have wrapper `Monoid's like `Sum m' and `Product m', e.g. when `m' is `Integer', as a work-around for this)
05:19:13 <ski> so .. are there any threads loose here ?
05:19:43 <ski> hm, right, you wondered about `foldTree :: (TreeAlgebra a o -> o) -> (Tree a -> o)' and such above, yes ?
05:20:29 <tomberek> ski, one sec
05:20:40 <tomberek> ski: you mentioned Sum m and Product m
05:20:52 <ski>   newtype Sum m = Sum m
05:21:02 <ski>   instance Num m => Monoid (Sum m)
05:21:04 <ski>     where
05:21:11 <ski>     mempty = Sum 0
05:21:24 <ski>     mappend (Sum m0) (Sum m1) = Sum (m0 + m1)
05:21:29 <ski> similarly for `Product'
05:21:48 <tomberek> ski, is that somewhere in Data.Monoid?
05:21:54 <ski> (but using '1' and `*' instead of `0' and `+')
05:22:15 <ski> @type Data.Monoid.Sum
05:22:16 <lambdabot> forall a. a -> Control.Monad.RWS.Sum a
05:22:33 * ski dunno why that insists on saying `Control.Monad.RWS' ..
05:22:43 <dcoutts> yitz: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25833
05:22:48 <ski> anyway, it's in `Data.Monoid'
05:22:51 <dcoutts> yitz: feedback apreciated
05:23:45 <yitz> dcoutts: haha! nice!
05:24:10 <ski> tomberek : so, `TreeAlgebra' ?
05:24:19 <tomberek> ski, so an instance is a declaration of an algebra?
05:24:58 <dcoutts> yitz: seem ok?
05:25:20 <ski> you can view an instance as a declaration of a *default* algebra (of the kind indicated by the corresponding `class' declaration, including both the methods, and the informal laws, if any)
05:25:34 * yitz now actually reads all of it... :)
05:25:44 <ski> a *default* algebra associated with a particular type, that is
05:26:17 <dcoutts> yitz: --help string for --upgrade-dependencies is: Pick the latest version for all dependencies, rather than trying to pick an installed version.
05:26:17 <ski> note that `Integer' both forms a monoid using `0',`(+)', and another monoid using `1',`(*)'
05:26:41 <ski> but since we can only have one instance of a class for each haskell type, we'd have to choose between those (and possibly others)
05:27:02 * hackagebot console-program 0.1.0.1 - Interprets the command line and a config file as commands and options  http://hackage.haskell.org/package/console-program-0.1.0.1 (AriePeterson)
05:27:19 <ski> so the best solution with this current system then is to not choose any particular monoid to associate with `Integer' itself
05:28:06 <tomberek> ski: ok, so the newtype allows us to defined multiple algebras for a type
05:28:09 <ski> instead we associate one with `Sum Integer' and another with `Product Integer', where these are new types that are really `Integer' inside, but since they're different types, we can associate different default monoids with them
05:28:15 <ski> but if we have an operation
05:28:19 <ski>   Data.Foldable.fold :: Foldable t => m -> (m -> m -> m) -> (t m -> m)
05:28:25 <tomberek> ok,
05:28:28 <yitz> dcoutts: you don't need the (slightly condescending) "if you know what your doing". the warning about --dry-run will scare off whoever needs scaring. it would be helpful instead to actually mention --constraint=, which from your example appears to make --upgrade-dependencies actually useful.
05:28:29 <ski> we don't really have to make an instance of `Monoid' at all
05:28:43 <tomberek> (this is helping me understand typeclasses)
05:28:52 <ski> we can just pass our operations of types `m' and `m -> m -> m' (after making sure the laws are satisfied)
05:29:17 <dcoutts> yitz: that business with constraints is because the dep resolver is not sufficiently smart, I hope it will become so in future
05:29:24 <dcoutts> it's not unique to upgrade
05:29:25 <ski> there is no *need* to make an instance declaration, other than the convenience of not having to explicitly mention which monoid you want to use
05:30:33 <yitz> dcoutts: ok. it's not so trivial to be "smart enough". debian aptitude has a pretty smart constraint solver, but it's interactive, and still sometimes goes off in totally the wrong direction.
05:30:42 <ski> tomberek : "the newtype allows us to defined multiple algebras for a type" <- we simulate this, by defining one default foo-algebra for one `newtype'-alias of our type, and another for another `newtype'-alias
05:31:48 <ski> tomberek : in some cases, where we have multiple useful foo-algebras, we think of one of them as the "main" one, so we associate that with the *actual* type with an `instance' declaration, and make the others into instances by making a `newtype' wrapper
05:31:49 <tomberek> ski,, ok... and what about when we see data?
05:32:18 <tomberek> so data is the "main" one, and newtypes of that data are alternates?
05:32:27 <ski> tomberek : e.g. `String' has normal order of concatenation in `Monoid', but `Dual String' has the reverse order of concatenation
05:32:41 <dcoutts> yitz: I'd prefer to keep a limit on an already long error message, the --constraint thing is pretty much orthogonal, and happens now anyway with upgrade
05:32:42 <ivanm> how is the haskell code here "unnatural" (except for their weird IO stuff)? http://blog.progopedia.com/2010/may/30/10-unnatural-ways-calculate-fibonacci-numbers/
05:32:43 <dcoutts> yitz: I've made the message less condescending :-)
05:32:55 <ski> tomberek : yes, (though in some cases the "main" one is also defined by a `newtype' .. it doesn't really matter)
05:33:07 <dcoutts> yitz: "If you want the old upgrade behaviour then use the install command with the ..."
05:33:15 <tomberek> ski, ok
05:33:27 <yitz> dcoutts: i didn't realize until now how important --constraint is or how to use it. mentioning it when the user appears to be getting in trouble with dependencies
05:33:39 <ski> > "ab" `mappend` "cd" `mappend` "efg"
05:33:40 <ski> > getDual (Dual "ab" `mappend` Dual "cd" `mappend` Dual "efg")
05:33:40 <lambdabot>   "abcdefg"
05:33:41 <lambdabot>   "efgcdab"
05:33:57 <yitz> dcoutts: yeah, and include the --dry-run thing.
05:34:13 <yitz> dcoutts: i didn't realize until now how important --constraint is or how to use it. mentioning it when the user appears to be getting in trouble with dependencies would be very helpful
05:34:13 <dcoutts> yitz: that's a good idea generally, for when dep planning fails
05:35:24 <tomberek> ski, got it,,, Dual simply switches the binary operation in reverse
05:35:55 <ski> (and, actually, since `Sum',`Product',`Dual' are *parameterized* wrappers (it doesn't really matter that the wrappers are `newtype's, though that's most efficient), you can use `Sum a' and `Product a' on *any* `a' (which is in `Num'), not just `m = Integer'; and `Dual m' on *any* `m' which is already in `Monoid', not just `m = String')
05:36:04 <yitz> dcoutts: "It is recommended that you do not upgrade core packages." What are those? Better to just say their names.
05:36:19 <ski> yes, so `Dual (Dual String)' is just a harder way to basically get the default `String' monoid
05:36:22 <yitz> or give some way to find out what they are
05:36:53 <ski> (Haskell doesn't know that we'd like `Dual (Dual m)' to be the same type as `m', so we have to live with that extra complication)
05:37:22 <dcoutts> yitz: the list is too long, it's the ones that come with ghc, though the advice probably extends to others that come with the platform, it's slightly fuzzy
05:37:42 <yitz> dcoutts: in --help, you'll remove upgrade as a command and copy that nice help text for --upgrad-dependencies, presumably
05:37:57 <dcoutts> yitz: yes
05:38:24 <ski> tomberek : ok, `foldTree :: (TreeAlgebra a o -> o) -> (Tree a -> o)' now, or have you had enough to chew on for today ? :)
05:38:32 <tomberek> ski: can't that be RULE'd?
05:38:54 <tomberek> ski, let's do it.. again, thanks for teaching
05:38:56 <ski> afaik, `RULES' only work on (value) expressions, not on type( expression)s
05:39:26 <yitz> dcoutts: is the list really that long? actually, i think i've upgraded a lot of the packages other than base that come with ghc. as long as it's a ghc that you're not building manually, what's the problem?
05:39:37 <sioraiocht> haskell.org being down makes me SAD
05:39:37 <tomberek> ski, wait  Dual (Dual String) doesn't cost us in run-time, only compile
05:40:08 <dcoutts> yitz: it does not always immediately cause a problem it just tends to get people into complex setups that ghc and cabal then do not handle well
05:40:20 <yitz> sioraiocht: they've been notified. it is becoming morning there now. hope it will come up again soon...
05:40:27 <dcoutts> yitz: if you're careful and know what you're doing it can be fine
05:40:28 <sioraiocht> indeed! =)
05:42:09 * Axman6 wonders who haskel.org is so crash prone
05:42:13 <Axman6> why*
05:42:27 <ski> tomberek : actually, it probably costs us at run-time, since unless the implementation manages to optimise `mappendA (Dual dx0) (Dual dx1) = mappendB dx1 dx0; mappendB (Dual x1) (Dual x0) = mappend x0 x1' into `mappendA (Dual (Dual x0)) (Dual (Dual x1)) = mappend x0 x1' (the `Dual's doesn't matter, what matters is that we swap two times, uselessly)
05:42:48 <dcoutts> Axman6: you're thinking of code.haskell.org, the main haskell.org is pretty reliable
05:43:13 <ski> tomberek : in this particular case it probably doesn't matter much, though, since both swaps are `O(1)' operations .. but consider `map'ping two swaps on a list, instead of doing nothing
05:43:18 <Axman6> i don't use code.haskell.org, so it being unreliable doesn't affect me :\
05:43:27 <yitz> dcoutts: still, saying "core" will just perplex people. how can we say something more precise?
05:44:19 <tomberek> ski, inlining would attempt to fix that?
05:44:35 <ski> tomberek : it could, yes
05:44:35 <dcoutts> yitz: we could say packages that come with ghc but I'm not sure it'd help, casual users do not know that either
05:44:50 <yitz> dcoutts: besides getting cabal confused, which is a separate issue and will become clear in a --dry-run, which packages actually affect ghc itself at runtime? let's see... base, integer-gmp. will extensible-exceptions confuse it at runtime?
05:45:03 <dcoutts> yitz: core packages does have a precise meaning for people more familiar with ghc, and perhaps those will be the only people using --upgrade-dependencies
05:45:07 <ski> (but sometimes you can't inline, since the dictionary isn't known until run-time (existential types, and, i think, polymorphic recursion))
05:45:23 <yitz> dcoutts: right, they should be getting hp. and anyway it's not clear that is the right criterion
05:45:35 <dcoutts> yitz: base cannot be upgraded anyway
05:45:49 <dcoutts> yitz: it will not be clear in a --dry-run
05:45:53 <tomberek> ski, ok, i'm just trying to say what i think is right, that way i know if i'm tracking
05:46:17 <dcoutts> cabal (may) successfully install new versions of core packages, but then you can end up with a complicated package db
05:46:33 <ski> tomberek : no problem :)
05:46:44 <dcoutts> yitz: some packages depending on old core package versions, others depending on the new ones
05:46:54 <yitz> dcoutts: perhaps people who install hp should have all of those packages locked by default, with some flag to upgrade them
05:46:57 <dcoutts> yitz: keeping it vague is perhaps a bonus :-)
05:46:57 <ski> anyway, `TreeAlgebra' and such things
05:47:26 <tomberek> ski, ready
05:47:41 <yitz> dcoutts: getting a vague message from a command you rely upon to keep your system running is rather upsetting
05:47:42 <dcoutts> yitz: sure, we could improve upgrade by locking some packages we think people should not upgrade, the question is what behaviour do we want precisely, and it'll take some time to implement it.
05:47:50 <ski> ok, so recall that, given a particular type `a', a `Tree a'-algebra consists of a type `tree_a' and two operations `tip :: tree_a' and `node :: a -> tree_a -> tree_a -> tree_a' .. and no laws with this
05:47:56 <dcoutts> yitz: it only really applies to --upgrade-depencencies
05:48:00 <ski> so, the initial such algebra is
05:48:03 <dcoutts> yitz: which we are not recommending
05:48:12 <dcoutts> yitz: perhaps just remove that bit entirely
05:48:27 <ski>   data Tree a = Tip
05:48:28 <ski>               | Node a (Tree a) (Tree a)
05:48:34 <ski> or, in GADT-syntax
05:48:34 <yitz> dcoutts: which bit - the option, or the message about it
05:48:52 <dcoutts> yitz: the last sentence about not upgrading core packages
05:49:00 <ski>   data Tree :: * -> *
05:49:02 <ski>     where
05:49:05 <ski>     Tip :: a -> Tree a
05:49:07 <ski>     Node :: a -> Tree a -> Tree a -> Tree a
05:49:26 <ski> where the operations on the type `Tree a' in this algebra is just the constructors
05:49:34 <tomberek> um,, Tip :: Tree a ?
05:49:39 <ski> (as usual with initial anarchic algebras)
05:49:55 <dcoutts> yitz: the point is, people typically do not install/upgrade things they do not know or care about, except when upgrade / --upgrade-dependencies would do it automatically.
05:49:56 <ski> tomberek : er, sorry, yes :)
05:50:09 <tomberek> ok
05:50:34 <yitz> dcoutts: how about just "use 'cabal install' to upgrade packages" people who know enough to want --upgrade will know it or find out about it
05:50:59 <dcoutts> yitz: it's a new flag, nobody knows about it
05:51:14 <yitz> dcoutts: perhaps, but you'd be surprised. confused people try things. if could cause damage it should be disabled by default.
05:51:32 <ski> so, the initial morphism that, given any other `Tree a'-algebra `tree_a' with operations `tip',`node', maps the initial algebra into this other algebra
05:51:41 <ski>   f :: Tree a -> tree_a
05:51:47 <ski>   f Tip = tip
05:52:02 <ski>   f (Node a t0 t1) = node a (f t0) (f t1)
05:52:12 <yitz> dcoutts: we need better documentation, besides the --help text
05:52:21 <dcoutts> yitz: could rephrase it as: "If you use --upgrade-dependencies, it is recommended that you do not upgrad core packages."
05:52:34 <tomberek> ski: sure, a structure preserving morphism
05:52:46 <ski> and the catamorphism/fold is just then the polymophic function (over `tree_a'), that given the `tip' and `node' operations on this other algebra `tree_a' returns the above `f' function
05:52:53 <yitz> dcoutts: yeah. that'll certainly scare away the faint of heart. :)
05:53:01 <dcoutts> yitz: ok, good
05:53:18 <ski>   foldTree :: forall tree_a. tree_a -> (a -> tree_a -> tree_a -> tree_a) -> (Tree a -> tree_a)
05:53:24 <ski>   foldTree tip node = f
05:53:24 <dcoutts> yitz: yes updating the user guide to talk about cabal-install rather than runghc Setup.hs would be a good thing, it's all time
05:53:25 <ski>     where
05:53:31 <ski>     ..as above..
05:53:41 <dcoutts> yitz: there's an open ticket for that if you know of any read volunteers :-)
05:53:43 <dcoutts> ready
05:54:25 <yitz> dcoutts: I would volunteer - but I'm too busy readying my CV for well-typed.
05:54:31 <ski> tomberek : in this case, since this actually works for any `a' at all (and e.g. not just when `a = Integer', or when we know that `Monoid a', i.e. `a' is a (/ has a default) monoid)
05:54:35 <dcoutts> yitz: heh :-)
05:55:09 <ski> tomberek : now, to make this more uniform with `foldList' and other folds on other types, we define
05:55:19 <tomberek> ski, so you don't do forall tree_a a. ?
05:55:40 <ski> yes, we'd do `forall a tree_a. ' in this case :)
05:56:08 <ski>   data TreeAlgebra a tree_a = TipA
05:56:08 <ski>                             | NodeA a tree_a tree_a
05:56:24 <ski> note how this is like `data Tree a = ...' above, but with the recursion removed
05:56:55 <ski> (this pattern is sometimes called `IndirectComposite', look it up on the wiki when it resurfaces)
05:57:02 <ski> now, the point is that we can replace
05:57:06 <ski>   foldTree :: forall tree_a. tree_a -> (a -> tree_a -> tree_a -> tree_a) -> (Tree a -> tree_a)
05:57:09 <ski> with
05:57:22 <ski>   foldTree :: forall tree_a. (TreeAlgebra a tree_a -> tree_a) -> (Tree a -> tree_a)
05:57:30 <tomberek> ski,,,, no, i meant an extra a
05:57:43 <tomberek> oh, i see
05:57:45 <tomberek> nvm
05:57:53 <tibbe> sioraiocht: how are the Text rope coming along?
05:58:18 <ski> so `TreeAlgebra a tree_a -> tree_a' is a handy way of collecting up the two `tree_a' and `a -> tree_a -> tree_a -> tree_a' arguments (the operations on the target algebra), in one argument
05:58:50 <ski> the idea is that if you have `tip :: tree_a' and `node :: a -> tree_a -> tree_a -> tree_a', you can define
05:59:00 <tomberek> ski, i see
05:59:16 <bastl> hey, is haskell.org down ATM ?
05:59:17 <ski>   deconstructTree :: TreeAlgebra a tree_a -> tree_a
05:59:39 <ski>   deconstructTree  TipA          = tip
06:00:00 <ski>   deconstructTree (NodeA a t0 t1) = node a t0 t1
06:00:12 <ski> so now you pass `deconstructTree' instead of `tip' and `node'
06:00:20 <ski> if we take the
06:00:23 <ski>   data List a = Nil
06:00:32 <ski>               | Cons a (List a)
06:00:36 <ski> type, we similarly get
06:00:48 <ski>   data ListAlgebra a list_a = NilA
06:00:52 <sioraiocht> tibbe: not bad, I have an idea to run by you actually
06:01:00 <ski>                             | ConsA a list_a
06:01:04 <ski> and then we can say
06:01:26 <ski>   foldList :: forall a list_a. (ListAlgebra a list_a -> list_a) -> (List a -> list_a)
06:01:29 <ski> instead of
06:01:37 <ski>   foldList :: forall a list_a. list_a -> (a -> list_a -> list_a) -> (List a -> list_a)
06:02:16 <ski> so, the general recipe here is : construct `FooAlgebra' from `Foo', by "removing/indirecting" the recursion
06:02:25 <ski> now, the last step here is this
06:02:41 <tomberek> ski : let me copy-paste that somewhere
06:03:10 <ski> since we now have `ListAlgebra' and `TreeAlgebra', we don't really need `List' or `Tree' anymore
06:03:23 <ski> we define a general "recursive-type-maker"
06:03:33 <earthy> hm. right. if a -hy heap profile shows me stg_ap_2_upd_info taking up half of my memory
06:03:38 <ski>   data Mu f = In {out :: f (Mu f)}
06:03:42 <earthy> then that's a space leak from laziness, right? :)
06:03:47 <ski> and now we can define `List' like
06:03:58 <ski>   type List a = Mu (ListAlgebra a)
06:04:00 <ski> and
06:04:12 <ski>   type Tree a = Mu (TreeAlgebra a)
06:04:15 <Schalken> How might I convert a Word8 to a String that is its 2digit hexadecimal representation?
06:04:29 <ski> if we had trees which only contains `Integer's, we'd do
06:04:42 <ski>   type IntegerTree = Mu IntegerTreeAlgebra
06:04:48 <kmc> :t showAtBase
06:04:49 <lambdabot> Not in scope: `showAtBase'
06:05:38 <dcoutts> yitz: improved message: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25833#a25834
06:05:45 <ski> the catch is that instead of saying `Cons 0 (Cons 1 (Cons 2 Nil))' we now have to say `In (Cons 0 (In (Cons 1 (In (Cons 2 (In Nil))))))' .. which is somewhat more tedious (but should be the same at run-time)
06:05:52 <jd10> what's the correct way of converting Float to Double?
06:06:14 <kmc> :t realToFrac
06:06:15 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
06:06:18 * ski awaits tomberek's swift return
06:06:22 <tomberek> ski, ok, i guess i now know Mu as well
06:06:26 <dcoutts> yitz: turns out it's hard to remove the upgrade command from --help, so instead I've moved it to the bottom of the list and changed the help text to "(command disabled, use install instead)"
06:06:37 <jd10> kmc: http://www.mail-archive.com/haskell-cafe@haskell.org/msg52636.html
06:07:04 <ski> tomberek : there's other advantages to using this `FooAlgebra' way of expressing our type
06:07:22 <ski> tomberek : say we want to have a `Tree a', but where each link is actually an `IORef' !
06:07:25 <ski> no problem !
06:07:56 <ski>   data MuIORef f = InIORef {outIORef :: IORef (f (MuIORef f))}
06:08:11 <ski>   type IORefTree a = MuIORef (TreeAlgebra a)
06:08:42 <ski> or, say that we want to annotate each level of the tree with `Loc' for tracking source locations
06:09:08 <ski>   data MuLoc f = InLoc {outLoc :: (Loc,f (MuLoc f))}
06:09:20 <ski>   type LocTree a = MuLoc (TreeAlgebra a)
06:09:58 <yitz> dcoutts: sounds fine. new minor bug for trac. :)
06:10:01 <ski> though, if we'd like to use both `IORef's and `Loc's at the same time, we'd really like to reuse the above, instead of defining new types all the time, so we can instead say
06:10:13 <tomberek> ski,, uh,, hand on
06:10:16 <tomberek> hang on
06:10:41 * ski hangs on
06:10:54 <ivanm> dcoutts: why is it hard to remove an option from the help? or are you using GetOpts and that would completely remove/disable the option?
06:11:36 <tomberek> ski... ok
06:11:42 <tomberek> ski, i think i've caught up
06:11:47 <ski>   data WrapIORef f o = WrapIORef {unWrapIORef :: IORef (f o)}
06:11:57 <dcoutts> ivanm: this is not GetOpts, it's the Cabal command line handling code, which lives in the Cabal lib. It does not support commands that are active but not listed in the --help. Would need that feature adding to the Cabal lib.
06:12:09 <ski>   data WrapLoc f o = WrapLoc {unWrapLoc :: (Loc,f o)}
06:12:13 <dcoutts> ivanm: it's the whole sub-command, not a flag
06:12:24 <ivanm> dcoutts: ahhh, removing it from cabal-install would require removing it from cabal itself?
06:12:25 <tomberek> ski: wait
06:12:29 <ski>   type IORefTree a = Mu (WrapIORef (TreeAlgebra a))
06:12:36 <yitz> jd10: nevertheless, that's the standard way to convert. it might get things wrong if you're worried about NaN, Infinity, etc.
06:12:43 <ski>   type LocTree a = Mu (WrapLoc (TreeAlgebra a))
06:12:53 <dcoutts> ivan: no, it'd require adding a new feature to the Cabal lib sub-command handling code.
06:12:53 <ski>   type LocIORefTree a = Mu (WrapLoc (WrapIORef (TreeAlgebra a)))
06:12:55 <tomberek> ski,,, it sounds like, working a the type level, you can combine algebras in easier ways
06:13:05 <ski>   type IORefLocTree a = Mu (WrapIORef (WrapLoc (TreeAlgebra a)))
06:13:13 <jd10> yitz: i'm getting quite weird results :(
06:13:34 <yitz> jd10: like?
06:14:13 <ski> tomberek : yes, now you can say `In (locA,Cons 0 (In (locB,Cons 1 (In (locC,Nil))))) :: LocList Integer', e.g.
06:14:25 <yitz> > realToFrac (10^100 :: Double) :: Float
06:14:26 <lambdabot>   Infinity
06:14:36 <yitz> > realToFrac (-10^100 :: Double) :: Float
06:14:37 <lambdabot>   -Infinity
06:14:42 <tomberek> ski, that sounds similar to what i've been trying to do
06:14:45 <jd10> yitz: like 113.33 -> 113.33000183105469
06:14:53 <yitz> > realToFrac (10^(-100) :: Double) :: Float
06:14:54 <lambdabot>   *Exception: Negative exponent
06:14:59 <bastl> can someon give me an example of an infix funxtion with three arguments. IIRC, one can put the operator between the fst and snd argument, but i dont know how to ... here is an example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25835
06:15:06 <yitz> > realToFrac (10e-100 :: Double) :: Float
06:15:07 <lambdabot>   0.0
06:15:15 <ski> tomberek : so, the actual expressions becomes somewhat more inconvenient to type in as large expressions .. but in payback you get to reuse code over `TreeAlgebra', instead of defining lots of incompatible variations of the same type
06:15:22 <baaba> jd10: obviously you can't store an infinite amount of numbers into a finite number of bits
06:15:29 <yitz> jd10: ah
06:15:34 <baaba> jd10: a floating point number can only contain a certain set of numbers
06:15:40 <baaba> 113.33 is not in that set
06:15:46 <baaba> but 113.33000183105469 is
06:15:49 <yitz> > realToFrac (113.33 :: Double) :: Float
06:15:50 <lambdabot>   113.33
06:15:53 <baaba> (well, that's probably rounded)
06:16:05 <yitz> > realToFrac (113.33 :: Float) :: Double
06:16:06 <lambdabot>   113.33000183105469
06:16:08 <ski> tomberek : so, `TreeAlgebra' here is sort of like a "kind" (not in the Haskell sense) of algebras
06:16:22 <tomberek> ski, how is this different than just parameterizing TreeAlgebra?
06:16:23 <jd10> okay, thanks!
06:16:39 <ski> tomberek : (those having operations `tip :: tree_a' and `node :: a -> tree_a -> tree_a -> tree_a', and no laws)
06:16:39 <jd10> so what's appropriate way of doing things?
06:16:45 <yitz> jd10: that looks ok i think.
06:16:54 <baaba> jd10: http://docs.sun.com/source/806-3568/ncg_goldberg.html
06:17:11 <jd10> geez
06:17:26 <tomberek> ski, and we can't express laws?
06:17:27 <baaba> yeah it's a bit long but i would consider it essential reading for programmers :P
06:17:31 <yitz> jd10: don't forget that they are both represented in binary. that's a pretty good approximation, why should it need to look nice in base 10?
06:17:53 <ski> tomberek : we'll, sure you can define `type LocTree a = (Loc,LocTreeCell a); data LocTreeCell a = Tip | Node a (LocTree a) (LocTree a)', but you have to do that manually for each variation
06:18:16 <ski> tomberek : we can't express laws (usually) in *Haskell*, we can still express them in comments
06:18:35 <baaba> jd10: it's worth reading even if you skip the proofs
06:18:40 <baaba> which take up a lot of space
06:18:48 <Schalken> kmc:  Could you show me how to make showIntAtBase to do Word8 -> (Char, Char)?
06:19:11 <jd10> yitz: yeah, you're right...
06:19:40 <ski> (tomberek : "usually", since in some cases, the fact that polymorphic functions in haskell are "parametrically polymorhic" (technical term), we get some laws automatically .. e.g. it is impossible to write an instance of `Functor' in which `fmap (g . f) = fmap g . fmap f' doesn't hold, iirc)
06:19:42 <Taejo> :t optional
06:20:23 <ski> @botsmack
06:21:24 <yitz> jd10: there are definitely problems with that conversion, but much of it is related to inherent problems with IEEE floating point itself. for everyday use, the naive realToFrac is usually good enough.
06:21:27 <lambdabot> :)
06:21:27 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
06:21:49 <tomberek> ski, it sounds good to be able to enforce laws
06:22:13 <ski> tomberek : another variant would be defining `type WrappedTree f a = f (TreeCell f a); data TreeCell f a = Tip | Node a (WrappedTree f a) (WrappedTree f a)' .. that's basically the same as using `Mu (f (TreeAlgebra a))'
06:23:03 <ski> (but having to declare yet another wrapper / cell(/worker) pair is somewhat tedious too, i think .. ymmv)
06:23:21 <ski> @type Text.Parsec.Combinator optional
06:23:22 <lambdabot>     Not in scope: data constructor `Text.Parsec.Combinator'
06:23:28 <ski> @type Text.Parsec.Combinator.optional
06:23:29 <lambdabot> forall t s u (m :: * -> *) a. (Text.Parsec.Prim.Stream s m t) => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m ()
06:23:34 <ski> @type Control.Applicative.optional
06:23:35 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
06:23:59 <ski> tomberek : so, recapping
06:24:01 <ski> we went from
06:24:03 <tomberek> ski, so Mu allows us to 'map/recurse' over a 'type-structure'
06:24:23 <ski>   foldTree :: forall a tree_a. tree_a -> (a -> tree_a -> tree_a -> tree_a) -> (Tree a -> tree_a)
06:24:26 <ski> to
06:24:49 <ski>   foldTree :: forall a tree_a. (TreeAlgebra a tree_a -> tree_a) -> (Tree a -> tree_a)
06:24:52 <ski> to
06:25:01 <ski>   foldTree :: forall a tree_a. (TreeAlgebra a tree_a -> tree_a) -> (Mu (TreeAlgebra a) -> tree_a)
06:25:04 <MadHatterDude> Anybody know how to stack two non-math symbols, on on top of the other in LaTeX?
06:25:09 <ski> and now we can generalize that final version to
06:25:32 <ski>   cata :: forall f. Functor f => (f o -> o) -> (Mu f -> o)
06:25:39 <ivanm> MadHatterDude: \frac{\text{foo}}{\text{bar}} ?
06:26:13 <temoto> So, MVar can be thought as a Chan with maximum length of 1?
06:26:16 <ski> tomberek : `Mu' allows us to take a type that expresses one "level" of a recursive type, and wraps that up for us into a recursive type that has the former type at each level
06:26:18 <MadHatterDude> ivanm: Yeah, but \text doesnt work with special symbols and \frac puts a line between them
06:26:21 <ski> @src Mu
06:26:21 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
06:26:24 <ski> compare with
06:26:29 <ski>   fix f = f (fix f)
06:26:29 <ivanm> MadHatterDude: \mathrm{...} then?
06:26:39 <ivanm> MadHatterDude: I thought \text just dropped it out of maths mode...
06:26:53 <ivanm> MadHatterDude: what special characters are you wanting to do?
06:27:15 <ivanm> MadHatterDude: and there are variants of \frac in amsmath that don't have the line (can't remember what they are though... \binom ?)
06:27:17 <MadHatterDude> wasysym's \Circle
06:27:30 <ivanm> on top of?
06:27:37 <ivanm> MadHatterDude: are you just wanting an umlaut?
06:27:40 <ski> tomberek : so, the point with `cata' above is that we just have to declar `TreeAlgebra a' as a `Functor' (mapping one `tree_a' type into another one), and *boom* we already have `foldTree = cata' :)
06:27:58 <MadHatterDude> ivanm: On top of \APLbox And that is non-math symbols
06:28:06 <ski> (and probably GHC can auto-derive `Functor' for us in the most common cases)
06:28:58 <tomberek> ski, ouch
06:29:06 <ski> why "ouch" ?
06:29:33 <ivanm> MadHatterDude: maybe using an in-line tabular? :/
06:29:57 <ivanm> but I'm guessing you want it inline within text which probably won't end up working
06:30:47 <MadHatterDude> ivanm: All right, I'll figgure it out...
06:30:57 <MadHatterDude> ivanm: thx
06:31:04 <ivanm> heh, didn't do much
06:31:17 <ivanm> MadHatterDude: ##latex ?
06:31:25 <tomberek> ski, with Mu, it got a lot harder to keep up
06:31:29 <ivanm> actually, it's just #latex
06:31:49 <ski> tomberek : just think of `Mu f' as `f (f (f (f (...))))'
06:32:05 <ski> (modulo the `In' constructors, that doesn't exist at run-time)
06:33:08 <ski> so, `TreeAlgebra a Foo' is *one* tree level, where we now have two `Foo's at the place where we'd expect the sub-trees
06:33:32 <tomberek> ski, yeah, i got the initial concept
06:33:35 <ski> and `TreeAlgebra a (TreeAlgebra a Foo)' is the same, except that we reach the `Foo's after *two* levels
06:33:39 <ski> ok
06:34:00 <ski> tomberek : ok, i guess this is basically it, if you don't have more questions
06:34:01 <_minoru> Hello everybody
06:34:19 <_minoru> I found that the space is still leaking: http://dumpz.org/19881/
06:34:24 <tomberek> ski,, is that a general rule, that a Algebra a (Algebra a b) is the same?
06:34:25 * ivanm waves idly in _minoru's general direction
06:34:33 <ski> (one could say something more about why `TreeAlgebra', &c. are functors, in terms of category theory .. but i think that can probably be skipped for now)
06:34:46 <ski> tomberek : the same as what ?
06:34:48 <ivanm> _minoru: what are you trying to do?
06:35:18 <ivanm> _minoru: and why are there parens in `` getInput("low") '' ?
06:35:43 <_minoru> ivanm, I'm trying to pass a state between different calls of handleRequest in my simple fastCGI application
06:35:52 <ivanm> @hoogle iterateM
06:35:52 <lambdabot> No results found
06:36:08 <ivanm> hmmm.... your iterate1 seems to be a monadic version of iterate...
06:36:19 <_minoru> yes, it is
06:36:36 <ski> tomberek : a `FooAlgebra (FooAlgebra Bletch)' is two levels of `Foo's, after which (if we don't hit something like `Nil' or `Tip' before), we reach `Bletch's where the sub-`Foo's would ordinarily be
06:36:43 <_minoru> but I couldn't find predefined anywhere in the standard packages
06:36:59 <ivanm> _minoru: have you done any profiling to try to work out where the leaks are occurring?
06:37:03 <_minoru> actually, I couldn't find it anywhere in all the web
06:37:03 <ski> tomberek : so a whole `Foo' corresponds to `FooAlgebra (FooAlgebra (FooAlgebra (...)))' .. i.e. `Mu FooAlgebra'
06:37:31 <ivanm> bah, hayoo is down
06:37:35 <ski> (a recursive type `Foo' is an (potentially) infinite tower of `FooAlgebra's .. all the way down)
06:37:38 <tomberek> ski, ok, i think
06:37:44 <_minoru> ivanm, yes, I did it yesterday: http://dumpz.org/19846/
06:37:53 <ivanm> and of course hoogle is since h.o is down :@
06:37:53 <tomberek> ski, with a turtle at the bottom
06:38:12 <ski> well, with anything you like at the bottom, since there is no bottom :9
06:38:19 <ski> s/:9/:)/
06:38:27 <ski> so, yes, with a turtle at the bottom !
06:38:34 <ivanm> @type randomR
06:38:34 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
06:39:46 <ivanm> _minoru: I would try testing it this way: in handleRequest, first hard-code a value for low
06:39:49 <ivanm> then for high
06:39:51 <ivanm> then for rnd
06:40:03 <ivanm> to try to track down where the leak is coming from
06:40:03 <ski> (there is no bottom in the type description .. since it is recursive .. in any particular value, though, you'll eventually reach `Tip' or `Nil' or something that doesn't use the `foo_a' argument anymore, so there it ends ... *unless* you're doing infinite datastructures, of course ! :)
06:40:16 <ivanm> I have the sneaking suspiciou that it's something to do with one of those 3
06:40:30 <tomberek> ski: honestly, at the last end there, i started losing you.
06:40:30 <earthy> oh wow. my haskell program just segfaulted... and I don't do any explicit Ptr handling...
06:40:37 <earthy> or FFI
06:40:45 <ski> tomberek : where ?
06:40:50 <earthy> (only through e.g. ByteString and Binary)
06:41:26 <earthy> okay. fluke. weird.
06:41:40 <ski> i just mean that `Mu (ListAlgebra a)' is `Nil | Cons a (Mu (ListAlgebra a))', which is `Nil | Cons a (Nil | Cons a (Mu (ListAlgebra a)))',&c.
06:41:45 <tomberek> ski: somewhere after bringing in TreeAlgebras, i held on for a bit, I was able to follow conceptually, but i couldn't reproduce it
06:42:08 <ski> the type itself expands as long as you like, but for finite data, eventually you'll hit `Nil'
06:42:22 <ski> tomberek : ok
06:42:38 <ski> tomberek : then that is possibly a sign that we should stop it here
06:42:46 <ski> (unless you have more questions)
06:43:24 <tomberek> ski, yes... thanks a lot, i'm going to go buy a category theory book to help me out
06:43:36 <ski> but look up `IndirectComposite' (iirc) at the wiki, later
06:43:40 <tomberek> ski, but some of the basics seem clearer now
06:43:48 <ski> nice
06:44:24 <ski> (also, there was some related page with `Decorate' in its name, but i forget the whole name)
06:44:28 <ski> anyway
06:44:32 * ski bows
06:45:17 <ski> (hm .. now where did i put my tea-cup ?)
06:47:14 * tomberek gives applause.
06:48:44 <_minoru> ivanm, I've just hardcoded lo, hi and rnd, but space leaks not stopped
06:48:57 <ivanm> _minoru: in that case, it might be your usage of cgi
06:49:04 <tomberek> ski: thanks,,good night/morning
06:49:05 <ivanm> either you're not using it properly, or there's a bug in the cgi library
06:49:15 <ivanm> try emailing the maintainer of that library and asking them
06:51:05 <yitz> _minoru: why are you building up CGI actions in a let instead of just running them in the do block?
06:51:21 <yitz> _minoru: could be that's part of your problem
06:51:32 <temoto> haskell.org seems down :(
06:51:39 <Axman6> it is
06:51:43 <ivanm> temoto: has been for a while
06:51:44 <_minoru> yitz, because I couldn't find another way to pass state between different calls of handleRequest
06:51:59 <leejongwook> http://www.haskell.org <-- Why can't I conntect to this page
06:52:10 <earthy> because it's down.
06:52:17 <leejongwook> x_x
06:52:29 <pozic> Is there any real reason why one should not use STM for all concurrency code other than the currently non-optimal implementation?
06:52:32 <temoto> leejongwook, you haven't study category theory much enough.
06:53:09 <pozic> Are there any programs that can be written more efficiently using a lower-level API?
06:53:13 <yitz> _minoru: i think usually in CGI you just run the handler once, and do whatever iteration you need inside of it
06:53:38 <pozic> (I have the impression that you could derive exact condition variables from STM code and have it work efficiently)
06:53:50 <ivanm> pozic: there is some overhead with STM
06:53:59 * Axman6 really likes MVars
06:54:03 <pozic> The current implementation only looks at whether any of the variables changed.
06:54:04 <yitz> _minoru: are you iterating because you want a lot of random numbers? then you should do that iteration in a pure function
06:54:11 * temoto really likes Chans
06:54:11 <ivanm> pozic: IIRC, dons has said that in galois they first write it with STM to get it working right, and then they translate to MVars, etc. to get performance if needed
06:54:13 <_minoru> yitz, and how to pass state between different fastcgi requests?...
06:54:14 <EvanR-work> MVars are the man
06:54:26 <EvanR-work> temoto: why?
06:54:29 <pozic> Can anyone be very specific?
06:54:34 <_minoru> MVars and STM has a strong flour of imperative haskell
06:54:46 <monadic_kid> pozic: you can impleent condition variables using MVars
06:54:56 <yitz> _minoru: each request represents an iteration of displaying a page in the user's browser and waiting for the user to click on something.
06:54:58 <pozic> monadic_kid: yes, I know that.
06:54:59 <EvanR-work> concurrency is necessarily imperative, i think
06:54:59 <_minoru> so, I really want to avoid them
06:55:07 <temoto> EvanR-work, they seem familiar to other concurrent code. Like messages in Erlang, Go.
06:55:18 <pozic> You want to synchronize a few pieces of code.
06:55:27 <pozic> That means there is some ordering you want.
06:55:29 <monadic_kid> _minoru: they represent away to do shared state concurrency
06:55:35 <yitz> _minoru: you pass state between those either using cookies, or by some persistence on the server (database, write to a file, etc.)
06:55:48 <pozic> If you call that imperative, well, do whatever you want.
06:56:04 <ivanm> _minoru: there's a quote (can't seem to find it) where Haskell is the world's finest imperative language
06:56:04 <yitz> _minoru: yes, avoid extra ones
06:56:07 <pozic> They are still actions that don't really do anything.
06:56:40 <pozic> So, is there anything fundamentally inefficient about STM?
06:56:54 * Axman6 finds writing imperative code in haskell to be quite pleasant
06:56:55 <ivanm> pozic: just the extra overhead IIRC
06:56:56 <yitz> @quote spj imperative
06:56:56 <lambdabot> No quotes match. My mind is going. I can feel it.
06:56:57 <pozic> By STM I mean the language, not the current implementation.
06:57:07 <EvanR-work> they have operational semantics so you are required to break out of your pure functional world view
06:57:08 <ivanm> pozic: Sun at one stage was working on hardware transactional memory...
06:57:10 <pozic> ivanm: which extra overhead?
06:57:18 <_minoru> ivanm, I think, that Eugenio Luggi sad that.
06:57:18 <Taejo> how would one write a Parsec expression parser with an operator like expr[expr]?
06:57:27 <ivanm> making sure variables haven't changed and logs for rollbacks
06:57:40 <pozic> ivanm: yes, but hardware doesn't scale to infinity.
06:58:07 <_minoru> is STM and MVars really a common practice in haskell to handle state?...
06:58:09 <Axman6> the super computer i get to see today gets pretty close
06:58:22 <Axman6> _minoru: they're common to handle concurrency
06:58:23 <EvanR-work> _minoru: handles concurrency
06:58:27 <ivanm> pozic: http://www.reddit.com/r/haskell/comments/c44b9/inability_to_control_side_effects_kills_stmnet/c0q1bte
06:58:49 <yitz> Taejo: e1 <- expr; e2 <- between (char '[
06:59:01 <yitz> ') (char ']') expr
06:59:04 <pozic> ivanm: shouldn't it be possible to derive critical sections from STM code and produce the lockbased code humans would have produced if they had infinite time on their hands?
06:59:19 <ivanm> pozic: *shrug* I just use this stuff, I don't do the compiler writing! :p
06:59:26 <Taejo> yitz: that's the easy part, the hard part is incorporating it into the expression parser
06:59:29 <_minoru> Axman6, EvanR-work , and which is a common practice to handle state without memory leaks in Haskell?
06:59:35 * yitz make a note to remind Steve Jobs to move the ' key farther away from Enter
06:59:52 <ivanm> _minoru: you have to be careful and maybe force some evaluation to avoid leaks
06:59:56 <ivanm> there are no easy solutions
07:00:01 <Heffalump> pozic: I guess so, if you have a whole program compiler
07:00:01 <yitz> Taejo: ?
07:00:07 * Axman6 wishes q wasn't so cose to tab, makes cmd-tab fairly dangerous
07:00:10 <EvanR-work> _minoru: theres State, IORef, MVar
07:00:16 <Heffalump> certainly won't be possible on a modular basis
07:00:31 <EvanR-work> _minoru: recursively passing stuff
07:00:53 <_minoru> EvanR-work, it doesn't seems to me that State monad can handle issues with memory leaks by itself
07:01:17 <pozic> Heffalump: right, so for libraries you would less efficiency, but fundamentally it seems the perfect abstraction.
07:01:34 <ski> @hackage procrastinating-structure
07:01:35 <lambdabot> http://hackage.haskell.org/package/procrastinating-structure
07:01:38 <Heffalump> dunno about perfect, but better than locks
07:01:51 <ski> _minoru : maybe that ^ might be useful to you ..
07:01:55 <pozic> Heffalump: dominating in formal terms.
07:02:39 <_minoru> ivanm, I understand, but I trying to found a persistent and native one
07:02:54 <_minoru> ski, can you tell me more about this?
07:03:45 <Heffalump> ski: why do you think that package is a good idea?
07:03:51 <Heffalump> it looks rather dubious to me :-)
07:03:53 <ski> just look at `Data.PVar.Queue' there, a pure queue is created impurely by some concurrent thread
07:04:11 <ski> Heffalump : i haven't claimed it is a good idea :)
07:04:20 <ski> just that it *might* be useful
07:04:28 <ski> it certainly is an interesting thought
07:05:00 <_minoru> ski, this is not a standard package.
07:05:01 <Heffalump> it's interesting, but looks rather impure
07:05:12 <Heffalump> if it blocked while waiting for the IO to populate it, that'd be much nicer
07:05:17 <ski> _minoru : *nod*
07:05:40 <ski> Heffalump : i only saw it recently, so i haven't looked it through
07:05:44 <_minoru> also, can tail recursion leak in haskell?
07:05:53 <_minoru> (i mean, GHC)
07:06:25 <ski> Heffalump : but, yes, blocking would be the preferable behaviour when the loose end is reached (i don't know what it does in that case)
07:06:51 <ski> (Heffalump : note that the `Maybe' is not for an open end, but for a *closed* end ..)
07:07:15 <kmc> _minoru, with lazy eval, tail recursion isn't necessarily as important
07:07:21 <ski> _minoru : it can leak in any language (with dynamic allocation), if you allocate more and more on the heap as you iterate
07:07:28 <kmc> _minoru, if you are producing a list lazily, and a consumer is consuming it lazily
07:07:50 <kmc> _minoru, then the pair of them becomes a sort of co-routine and can execute in constant space
07:08:10 <kmc> _minoru, so it often matters more whether a function is "productive" than whether it's tail-recursive
07:08:22 <_minoru> anywhere, where can the space leak?
07:08:27 <pozic> You can write functions often in both ways.
07:08:35 * ski would usually have the consumer consume strictly (maybe up-to the laziness of some outer consumer)
07:08:52 <pozic> It is easy to get the obviously tail-recursive version wrong, though.
07:09:41 <ski> _minoru : when you're keeping references to things you don't need around, an important case of that being thunks that haven't been appropriatedly forced, that refer to old things
07:11:10 <madhadron> Anyone know an elegant way of mapping an ADT constructor with a whole slew of named fields over a bunch of monadic actions to provide their values?
07:12:35 <byorgey> madhadron: I'm not sure I understand the question.
07:12:56 <madhadron> byorgey, Say I have data X = X { a, b, c, d, e, f, g, h, i, j :: String }
07:12:57 <ski> not really (other than using the record-less syntax, with `liftM[0..]' or `(<$>)'/`fmap`/`liftM` and `(<*>)'/`ap')
07:13:18 <madhadron> ski, Ok.
07:13:20 <byorgey> oh, wait, I get the question now
07:13:25 <monadic_kid> madhadron: hold on
07:13:33 <madhadron> I guess AP is probably the least violent
07:13:38 <monadic_kid> madhadron: I have to suggestions
07:13:40 <byorgey> yeah, doing  Constructor <$> action1 <*> action2 <*> action3 ...  is nice
07:13:48 <byorgey> but then you don't get to refer to the names of the fields
07:14:02 <pozic> madhadron: Template Haskell, if the list is _really_ long.
07:14:06 <madhadron> byorgey, Right.  Can always put them in comments, but nice to have the compiler do it.
07:14:21 <madhadron> pozic, There's *always* template Haskell.  It's like dwarf bread.
07:14:36 <ski> (with something like my reflective syntax idea, it would be something like `[> Constructor ([< action1) ([< action2) ...')
07:14:46 <FunctorSalad_> madhadron: gmapq?
07:15:01 <FunctorSalad_> if I understand the Q correctly... just woke up ._.
07:15:12 <madhadron> FunctorSalad, Does Data.Generics let me keep the labels?
07:15:18 <monadic_kid> madhadron: sounds like you want something like fclabels if I understood correctly or you can do write a bunch boiler-plate actions like getFoo :: MonadState MyState m => m FooType
07:15:45 <FunctorSalad_> madhadron: you need the labels as strings?
07:16:03 <madhadron> FunctorSalad, Naa, just want to have them nicely in the code for the compiler to check that I haven't screwed up
07:16:15 <madhadron> monadic_kid, fclabels looks almost exactly right
07:16:53 <pozic> madhadron: I will be the last person to say TH is a good system.
07:17:14 <monadic_kid> fclabels uses TH to generate labels
07:17:20 <pozic> TH is a research prototype that wasn't finished in any meaningful way.
07:17:29 <madhadron> monaidc_kid, Yes, but someone else already did the TH
07:17:38 <FunctorSalad_> madhadron: {-# LANGUAGE NamedFieldPuns #-} ... foo ... where X{a,b,c}=undefined
07:17:38 <FunctorSalad_> ?
07:17:39 <FunctorSalad_> ;)
07:18:01 <peterNovice> I apologize for this question, but is it common for haskell.org to be down? I am probably wrong, but I imagine that it is down at least once a month.
07:18:14 <FunctorSalad_> (if you want to check that certain named fields exist?)
07:18:18 <applicative> peterNovice, that sounds about right
07:18:18 <monadic_kid> peterNovice: it was fine yesterday
07:18:29 <FunctorSalad_> still confused whether you want something generic or not
07:18:36 <pozic> peterNovice: donate if you don't want that to happen, I suppose.
07:18:54 <madhadron> FunctorSalad, Don't need anything generic
07:19:09 <madhadron> I just have an ADT with a large number of fields, very simply thing
07:19:09 <peterNovice> applicative: I guess I could if that would help. To me it seems like it is down too often
07:19:11 <pozic> (I think it is kind of silly too that a website goes down as often as the haskell.org website)
07:19:12 <monadic_kid> madhadron: by the way you can compose labels to pick out nesting of fields
07:19:22 <madhadron> which all get initialized in one place
07:19:27 <madhadron> monadic_kid, That I did know.
07:19:49 <applicative> peterNovice, I think galois hosts it.  Presumably they are forever running wild experiments on the servers....
07:19:50 <madhadron> Alright, off to write slightly inelegant code
07:20:00 <FunctorSalad_> madhadron: ahh, you want the compiler to check that you haven't *missed* any field in constructing a new value?
07:20:05 <FunctorSalad_> isn't that some warning flag...?
07:20:20 <madhadron> FunctorSalad, Actually all the inelegant ways will do that.
07:20:31 <madhadron> And -Wall is plenty of warning flag for it
07:20:49 <madhadron> I just initialize it all, and I'll be putting in comments like -- http_base_port next to the appropriate lines
07:21:07 <madhadron> but was hoping for some way to make the monadic actions that produce the values be associated directly to the labels
07:21:18 <Cale> -Wall irritatingly warns about all sorts of things which don't matter
07:21:23 <madhadron> Like X { a <- getLine, b <- getLine }
07:21:31 <FunctorSalad_> madhadron: Ah. you can't use record syntax because of the monadicity
07:21:32 <FunctorSalad_> ?
07:21:39 <madhadron> FunctorSalad, Precisely
07:21:51 <FunctorSalad_> do { a <- blah; b <- blah; return X{..} }
07:21:58 <FunctorSalad_> {-# LANGUAGE RecordWildCards #-}
07:22:04 <FunctorSalad_> the .. is literal
07:22:06 <monadic_kid> madhadron: Well you could write a generic modify action which takes an action
07:22:09 <madhadron> FunctorSalad, Oh!  Perfect.
07:22:55 <FunctorSalad_> (that capital C is irritating... `wildcards' is a single word ;))
07:23:11 <deech> Hi all, is there a Haskell library that generates a random string of letters and numbers? I'm looking to create unique session ids.
07:23:25 <Zao> Aren't there UUID libraries?
07:23:33 <sioraiocht> I'd google it but haskell.org is down, is there a LANGUAGE pragma these days for using unboxed values and types (#)
07:24:03 <Cale> deech: You could do it with randomRs easily enough.
07:24:13 <monadic_kid> you could wite a version of modM or modify which takes an action like, say called modM_, then you can say modM_ field getLine
07:24:35 <deech> randomR's are in the base libraries?
07:25:05 <deech> And Hayoo's down again.
07:25:12 <madhadron> deech, Yes.
07:25:29 <madhadron> It's basically an instance that can take a generator and produce a value and a new generator
07:25:39 <applicative> peterNovice, hah, I was just going to check for recent complaints about haskell.org being down, but of course the haskell-cafe archive is hosted by haskell.org
07:25:54 <deech> madhadron: thanks!
07:26:09 <aristid> haskell.org is too centralised :/
07:26:28 <madhadron> deech, If you hold on a second, I can give you a function that produces alphanumeric strings as an example
07:27:41 <deech> madhadron: thanks
07:28:42 <madhadron> deech, http://paste-it.net/public/oaa9c9a/ <-- not particularly elegant.  in fact, ugly.
07:28:43 <madhadron> But works
07:28:48 <madhadron> Taken from production code
07:28:55 <FunctorSalad_> sioraiocht: MagicHash ?
07:29:00 <madhadron> All the relevant pieces are in System.Random
07:29:04 <sioraiocht> FunctorSalad_: cheers!
07:29:09 <FunctorSalad_> :)
07:29:30 <deech> madhadron: neat. Let me digest this.
07:29:43 <temoto> 'forever $' and tail recursion give same effect, so i wonder how should i reason to choose over those two.
07:29:56 <madhadron> temoto, What makes the code easier to read
07:30:18 <madhadron> temoto, Plus you can't pass values along through forever
07:30:44 <madhadron> temoto, If you really mean forever $ putStrLn "I'm stuck in an infinite loop!", then forever's the choice.
07:30:45 <FunctorSalad_> madhadron: q = ['A'..'z']?
07:30:45 <temoto> madhadron, of course i can read my own code easily (at least today) so it's hard to decide which is more readable :)
07:30:50 <FunctorSalad_> > ['A'..'z']
07:30:51 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
07:31:01 <madhadron> FunctorSalad, Note them character in the middle.
07:31:01 <Axman6> ^_`
07:31:12 <FunctorSalad_> oh no... ascii abuse failed
07:31:26 <madhadron> FunctorSalad, Though I certainly could have said ['A'..'Z'] ++ ['a'..'z'] blah blah
07:31:47 <madhadron> But as I said, that code ain't elegant
07:31:51 <FunctorSalad_> but... any character is legal for filenames except 'chr 0' I thought ;)
07:32:04 <madhadron> FunctorSalad, I've got to get in and out of SQL databases, Haskell, Perl, and R.
07:32:06 <gwern> > chr 0
07:32:07 <lambdabot>   '\NUL'
07:32:07 <Axman6> and / usually (or :)
07:32:11 <FunctorSalad_> :)
07:32:14 * gwern was about to say
07:32:23 <madhadron> FunctorSalad, I could get the escaping right in *all* of them...or just go ahead and shoot myself.
07:32:56 <madhadron> Oddly it's the R that would make me reach for the pistol, not the Perl.
07:33:05 <_minoru> I'll talk with lambdabot sometimes if I get lonely
07:33:06 <FunctorSalad_> madhadron: sure, I usually wouldn't bother with special chars in filenames either
07:33:20 <temoto> Also, i don't know how to stop 'forever' :)
07:33:25 <FunctorSalad_> (unsure about spaces in my ~/music folder...)
07:33:27 <Axman6> @vixen give _minoru some lovin'
07:33:27 <lambdabot> enough of this!
07:33:32 <Axman6> :o
07:33:34 <madhadron> temoto, exitImmediately or one of the threadKill commands
07:33:36 <gwern> spaces are legal
07:33:45 <gwern> no issue there except in manipulating them from the shell :)
07:33:50 <madhadron> FunctorSalad, That is what ID3 tags were created for (:
07:33:52 <FunctorSalad_> they do confuse bash unless you escape
07:33:55 <temoto> for recursive tail call, i write  if foo then loop else (well, something and no loop)
07:34:06 * Axman6 sleep
07:34:12 <temoto> @type exitImmediately
07:34:13 <lambdabot> Not in scope: `exitImmediately'
07:34:16 <madhadron> temoto, Right.  If you actually have a termination condition, then I would use something like whileM
07:34:34 <FunctorSalad_> madhadron: but sometimes you still have to resort to the filesystem ;)
07:34:36 <madhadron> temoto, Look in System.Posix.Exit
07:34:39 <temoto> This haskell.org down makes it harder to learn stuff :)
07:34:55 <dv-> Use error to exit
07:34:57 <madhadron> FunctorSalad, Remind me again why don't all run Plan 9?
07:35:06 <dv-> It's the proper Haskell way to quit
07:35:18 <opqdonut> :D
07:35:26 <madhadron> dv-, Depends what you're doing.  I've been in spots where that doesn't get me anywhere, like signal handlers.
07:35:35 <temoto> dv-, quit as in abort(3) ?
07:36:02 <dv-> @type error
07:36:03 <lambdabot> forall a. [Char] -> a
07:36:07 <FunctorSalad_> 'error' forces nonzero return status iirc
07:36:37 <FunctorSalad_> (in fact, one, apparently)
07:37:08 <FunctorSalad_> exitWith ExitSuccess would be the righter way to exit with 0
07:38:15 <temoto> I don't want the whole program to finish.
07:38:33 <temoto> It's about one loop, most commonly in thread.
07:39:18 <madhadron> temoto, There's a specific command to terminate the current thread
07:39:31 <madhadron> FunctorSalad_, Unless you're in the SIGTERM handler
07:39:46 <madhadron> FS_, In which case you must use exitImmediately or come back to the SIGTERM handler
07:40:23 <madhadron> temoto, Use myThread >>= killThread
07:40:26 <madhadron> In Control.Concurrent
07:40:43 <temoto> hm... signals could be used to emulate CTO... interesting :)
07:40:56 <FunctorSalad_> madhadron: thanks, didn't know that
07:41:10 <temoto> madhadron, thanks.
07:41:11 <madhadron> temoto, CTO?
07:41:19 <temoto> TCO
07:41:23 <madhadron> FS_, I learned it the hard way, at the bottom of a daemon.
07:41:23 <FunctorSalad_> temoto: the pure way would be Cont
07:41:30 <FunctorSalad_> :o
07:41:38 <madhadron> temoto, No, actually, because I'm sure it leaves a stack entry
07:41:41 <temoto> FunctorSalad_, yeah but i mean languages without that.
07:41:58 <temoto> FunctorSalad_, like Python.
07:42:06 <madhadron> temoto, In theory, when the new SIGTERM handler returns, the previous one should resume after some delay.
07:42:07 <FunctorSalad_> ah
07:42:31 <temoto> madhadron, is that true for all signals or just TERM?
07:42:43 <madhadron> temoto, All signals.  It's because you're doing a system call.
07:42:46 <FunctorSalad_> but why does exitWith invoke the sigterm handler?
07:42:56 <temoto> madhadron, how about ALRM?
07:43:05 <madhadron> FS, That's what exit() in C does
07:43:12 <madhadron> FS, Then there's exit_() to die *now*
07:43:13 <FunctorSalad_> oh
07:43:53 <madhadron> temoto, Same deal.  When the kernel sends a signal to a process, the current execution is suspended, and pulled off the processor, the new one for the signal handler set up, and started
07:44:17 <madhadron> temoto, and when the handler returns, the operating system guarantees that at some point afterwards, if the program is still alive, the original execution will be restored and continue
07:44:30 <FunctorSalad_> IIRC there's a list of things you're allowed to do in a signal handler in.. man 7 signals or so
07:44:53 <FunctorSalad_> (without invoking another signal handler, AIUI)
07:45:06 <madhadron> FS, Yeah.  The joys of nondeterministic programming.
07:45:11 <temoto> madhadron, but original execution could be just a for (;;) sleep(1);
07:45:29 <FunctorSalad_> *man 7 signal
07:45:35 <madhadron> temoto, And that's a problem how?
07:45:51 <madhadron> temoto, The scheduling might look schizophrenic.
07:46:02 <madhadron> But also, there are other methods than SIGALRM to implement sleep timers.
07:46:28 <madhadron> GHC actually abandoned SIGALRM a while back, as I discovered when trying to run it against an old version of glibc
07:47:20 <temoto> madhadron, so there will be virtually no 'execution to continue with'. I'm trying to pull it to the point where constant sigalrm-ing could be used as a poor-man continuation, maybe i'm stuck in this idea. :)
07:48:19 <madhadron> temoto, Ok, it depends if you put your own handler on SIGALRM or not.
07:48:39 <madhadron> But if it wakes up sleep, then at some point execution resumes, it sees sleep, and goes back to sleep.
07:48:57 <temoto> madhadron, of course i'd put a handler there. And it would call the continuation and then set another alarm.
07:49:34 <FunctorSalad_> madhadron: I thought this suspending is a feature rather than a problem though ;) so a program stuck in a loop can still be terminated with cleanup, or so
07:50:04 <FunctorSalad_> (or maybe you weren't saying otherwise)
07:50:07 <madhadron> temoto, Ah, I see.  If you have first class functions, you can pass them via shared memory to the signal handler, sleep, and let the OS pretend to be call/cc
07:50:31 <temoto> But maybe it's simpler to implement via global next_cc function pointer.
07:50:39 <madhadron> FS, You're exactly right.
07:50:40 <temoto> madhadron, yeah, exactly.
07:50:43 <madhadron> I hope I didn't say otherwise
07:51:04 <FunctorSalad_> madhadron: no, I just misunderstood "the joys of nondeterministic programming"
07:51:13 <madhadron> temoto, You have just used the Linux kernel as a subsystem of a Scheme runtime.
07:51:22 <fryguybob> byorgey: Hi byorgey, this isn't giving what I would expect: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25836#a25836
07:51:25 <FunctorSalad_> (it can be complicated but necessary after all)
07:51:35 <temoto> madhadron, well isn't it nice? :)
07:51:51 <madhadron> FS, Actually, it can be the source of some really fun stuff.  Have you read "A Method of Multiprogramming"?  Scholten's, I believe.
07:52:04 <madhadron> temoto, In the sense of getting an elephant to dance a polka
07:52:37 <madhadron> I think it might take less memory to write a Scheme
07:52:41 <dayz> is every FOL formula translatable to DL?
07:52:41 <FunctorSalad_> madhadron: I haven't
07:52:44 <dayz> description logic
07:52:57 <madhadron> FS, It's worth a gander.
07:53:43 <madhadron> dayz, I would imagine so, but I can't remember the details right now.
07:53:54 <madhadron> <-- notably not a information representation specialist
07:54:36 <dayz> madhadron, e.g., DL only supports binary (?) predicates?
07:54:48 <dayz> or is it unary
07:55:15 <madhadron> dayz, I think it just depends on your DL
07:55:31 <madhadron> I think my d(Type system extensions)/dt in a new module is about constant...
07:56:16 <madhadron> We just need a LANGUAGE pragma Agda
08:00:54 <aristid> in DT languages like agda, functions can take types as parameters, right? can they also return types?
08:01:05 <kmc> yes and yes
08:01:23 <aristid> can types also be parametrised by non-type values?
08:01:28 <kmc> yes
08:01:32 <aristid> WANT
08:01:47 <kmc> aristid, www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
08:02:19 <aristid> kmc: i guess i should take the bitter pill and read it :D
08:02:28 <madhadron> Greenspun's metalaw: All statically typed languages eventually contain an informal, bug-ridden implementation of half of a dependent type system
08:02:35 <aristid> why is adga marketed as a mere proof assistant?
08:02:44 <aristid> madhadron: hahahaha
08:02:50 <madhadron> aristid, Because that's what its designers are using it for?
08:03:07 <aristid> madhadron: but i can perfectly imagine using DT in day-to-day programming
08:03:14 <madhadron> Pretty much all the dependently typed languages today are proof assistants or computer algebra systems
08:03:34 <madhadron> aristid, Absolutely.  Give it a few years.
08:03:43 <madhadron> We're just getting monads accepted
08:04:05 <madhadron> Arrows and applicative functors next, and then, when the children are conditioned to abuse, we can bring out the dependent types.
08:04:43 <aristid> madhadron: well i've simulated such things in c++ (it was somewhat painful, of course)...
08:04:53 <kmc> aristid, it's not.  it's explicitly marketed as being more practical for real programming than other DT languages
08:05:03 <aristid> kmc: agda?
08:05:07 <kmc> yes
08:05:09 <kmc> in fact it doesn't really assist with proofs in the way Coq does
08:05:20 <madhadron> And it has a Haskell FFI, as I recall
08:05:33 <kmc> what do you mean "We're just getting monads accepted"?  we're just getting *first-class functions* accepted, and those are from 1936.
08:05:38 <aristid> "Agda is a proof assistant"
08:05:38 <monadic_kid> how about ATS, i don't like the syntax to be honest
08:05:46 <aristid> http://wiki.portal.chalmers.se/agda/pmwiki.php
08:06:00 <kmc> see the paragraph above it
08:06:11 <aristid> i only read bold text ;)
08:06:22 * madhadron crawls into a corner and cries at kmc's reminder.
08:08:08 <madhadron> But then, I taught my office mate the core of Lisp one time.  He looked at it, said, "Oh, sure, that's simple."
08:08:21 <madhadron> Then two days later he told me with a straight face, "I'm not smart enough for Lisp."
08:08:25 <kmc> haha
08:08:39 <aristid> madhadron: huh? why the change of mind?
08:08:44 <madhadron> This from someone who has to spend his days hunting down name collisions in JavaScript
08:08:48 <monadic_kid> ATS has a lot langauge features, dependant type system. Has macro system both AST and textual subtition, it has HM style parametric polymorphism and templates style with supoprt for specialization
08:09:10 <madhadron> aristid, I suspect it's because since he didn't have to worry about all the random stuff of making the language happy
08:09:12 <temoto> madhadron, routine is easier, that's a fact. :)
08:09:20 <madhadron> that he was left with just the hard problem he was actually solving
08:09:26 <madhadron> so the average work to be done was much more difficult
08:09:32 <aristid> madhadron: :D
08:09:52 <madhadron> temoto, Yeah, well, I'm the one he asks for help from when his JavaScript framework starts beating up his objects in the parallel runtime.
08:10:00 <aristid> madhadron: well in lisp (or most implementations of it) you have to fight the lack of static typing, of course
08:10:27 <madhadron> aristid, Or rather, lattices are not particularly useful for catching your errors.
08:10:36 <madhadron> Common Lisp is statically typed.  All values have type T
08:11:05 <Twey> forall ‘Common Lisp’.
08:11:32 <aristid> madhadron: yeah and in bash, all values have type string
08:11:48 <madhadron> aristid, Now, you can enforce static types on a function that will be caught at compile time
08:11:53 <madhadron> or rather, ones more specialized than T
08:12:21 <madhadron> it's just not ubiquitous.
08:12:58 <aristid> madhadron: it's like using Data.Dynamic? :P
08:13:42 <madhadron> aristid, ...yeah, pretty much.
08:13:49 <madhadron> Except that it looks like an object system.
08:14:25 <jpcooper> @pl hasPrefix pref = (== pref) . (take $ length pref)
08:14:25 <lambdabot> hasPrefix = liftM2 (.) (==) (take . length)
08:14:48 <fryguybob> byorgey: Here is a clearer example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25837#a25837
08:15:00 <aristid> :t liftM2
08:15:01 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:15:11 <madhadron> Though we ought to steal as much as possible from Common Lisp's error handling.
08:15:23 <madhadron> Haskell's is currently more than a little broken for day to day use.
08:15:38 <madhadron> (And I will throttle the next person who uses Maybe to represent the possibility of error)
08:16:03 <madhadron> (right after the next person who writes a function of type IO a -> * as opposed to MonadIO m => m a -> *
08:16:06 <aristid> madhadron: Maybe has the advantage of having a default monad instance
08:16:24 <aristid> compared to Either a at least
08:16:58 <jpcooper> what monad is that using?
08:17:14 <madhadron> aristid, Which means that Either's monad instance needs to be fixed to behave the expected way
08:17:19 <Saizan> madhadron: until you need to use catch :)
08:17:43 <madhadron> Saizan, Honestly, I don't think Either is strong enough to be the proper error type as it stands.
08:17:59 <madhadron> I want resumption, the call stack, line numbers, type safety in what can be thrown...
08:18:06 <Saizan> madhadron: i meant the part about MonadIO
08:18:09 <madhadron> All the stuff currently scattered among a number of different packages.
08:18:18 <deech> Hi all, I like points-free code, but sometimes for readability I want each function along the chain with a type signature. Is there a non-ugly way to do this?
08:18:40 <madhadron> Saizan, How so?  As it is, I have to write custom catch's for my stacked monad transformers.
08:18:44 <Saizan> madhadron: for checked exceptions there's control-monad-exception afaik
08:18:55 <madhadron> which are essentially unwrapping the monad, running catch, and rewrapping the monad
08:19:17 <madhadron> Saizan, Yes, there is.
08:19:18 <deech> s/I want each function/I want to annotate each function/
08:19:32 <Saizan> madhadron: right, you can't do that behaviour generically for any MonadIO
08:19:44 <Saizan> madhadron: not with the current MonadIO class
08:20:06 <madhadron> madhadron, That's true.  And it's a failure of the current class.
08:20:24 <madhadron> This is one of the things that's driven me up the wall lately when doing unix systems programming in Haskell.
08:21:00 <Taejo> @pl (\x -> s x *> x)
08:21:00 <lambdabot> (*>) =<< s
08:21:47 <FunctorSalad_> @remember <aristid> i only read bold text ;)
08:21:47 <lambdabot> I will never forget.
08:23:27 <byorgey> fryguybob: thanks for the report!  I'll look into it.
08:24:05 <FunctorSalad_> deech: how does pointfreeness make type annotations any uglier?
08:24:24 <FunctorSalad_> foo = h . (g :: Int -> Blah) . f
08:25:02 <aristid> @pl (\f x -> s (f x x))
08:25:02 <lambdabot> (s .) . join
08:25:12 <FunctorSalad_> foo = h . g . id_Int . f ; id_Int :: Int -> Int; id_Int = id
08:25:14 <FunctorSalad_> ;)
08:25:24 <aristid> @pl (\f x -> f (s x) x)
08:25:25 <lambdabot> join . (. s)
08:25:33 <Saizan> madhadron: i find the type signatures horrible for the use of long variables, though this is a class that allows that http://hackage.haskell.org/packages/archive/interleavableIO/0.0.1/doc/html/Control-Monad-Trans-InterleavableIO.html
08:25:36 <deech> FunctorSalad_: example: I want to create 4 random numbers between 0 and 15 with : take 4 $ repeat $ randomRIO (0::Int,15) >>= return
08:25:56 <madhadron> Saizan, <nods> I know there are a number of fairly good libraries out there.
08:26:03 <madhadron> The problem is that there are a bunch scattered everywhere
08:26:04 <FunctorSalad_> deech: but you'd need the annotation with or without points
08:26:14 <byorgey> fryguybob: ah, I see the problem.
08:26:16 <madhadron> This makes actually writing production code with error handling a mess
08:27:04 <deech> But if I want to add a type signature to the random part I get: take 4 $ repeat $ (randomRIO(0,15) :: IO Int) >>= return
08:27:11 <FunctorSalad_> (btw, foo >>= return = foo)
08:27:38 <deech> The parens kind of clutter up the function definition. Just wanted to know if there was a better way.
08:27:53 <deech> FunctorSalad_: That was a pared down example, I do some other things before returning.
08:28:00 <Saizan> madhadron: well, if no one that cares ever try to make a consistent solution.. :)
08:28:01 <madhadron> deech, Just pretend it's Lisp (:
08:28:12 <FunctorSalad_> deech: you can give the specialized version a name
08:28:15 <madhadron> Saizan, Yeah.  It's something on my list of things to do.
08:28:35 <madhadron> The problem is that everyone who cares is tends to have a todolist from here to the moon
08:29:05 <deech> FunctorSalad_: Yes, that's what I have been doing. But it seemed like a waste to factor that out just so I could add an annotation. It would be nice if (::) bound tighter.
08:29:47 <FunctorSalad_> hmm maybe there should be ::: yes :)
08:30:14 <madhadron> Ok, I'm heading home.  Ta ta, folk.
08:30:18 <FunctorSalad_> cya
08:30:19 <aristid> @pl \a b n -> a n . b
08:30:20 <lambdabot> flip . ((.) .)
08:30:45 <aristid> @pl \n -> take n . repeat
08:30:45 <deech> FunctorSalad_: Perhaps :). Or a proposal to fix (::), I can't see how it would hurt anyone.
08:30:46 <lambdabot> (. repeat) . take
08:31:01 <FunctorSalad_> deech: you could make a precedence 10 infix version of asTypeOf... but that could be considered ugly too ;)
08:31:05 <aristid> deech: i think you can simplify (. repeat) . take to replicate
08:31:23 <deech> aristid: thanks!
08:31:26 <FunctorSalad_> (because of the value irrelevance of typeOf)
08:31:40 <FunctorSalad_> *asTypeOf
08:32:20 <shapr> Yay, Language.Python builds in ghc 6.12!
08:32:24 <Saizan> (i don't find that problematic to put together some libs though, if they are orthogonal enough to not conflict)
08:32:52 <shapr> Does that mean that berp builds with ghc 6.12 as well?
08:33:22 <byorgey> fryguybob: fixed =)
08:33:39 <balor> Why does main require a return type of IO t?
08:33:56 <deech> FunctorSalad_: Readability says "So we meet again, Debugability. On guard!"
08:34:10 <Saizan> balor: what would you use instead?
08:34:46 <balor> Saizan: I've no idea.  I just have a function I want to run with no output.
08:35:05 <Saizan> balor: you can do that, IO () matches IO t
08:35:11 <FunctorSalad_> deech: hmm the named monomorphic randomRIO seems like it'd be Debugability's favourite ;)
08:35:27 <balor> Saizan: so IO(myfunc())?
08:35:36 <Saizan> balor: no
08:35:42 <FunctorSalad_> at least for type error msges...
08:35:44 * balor is a n00b
08:35:46 <Saizan> balor: IO is a type constructor
08:35:49 <yitz> deech: usually Readability and Debugability are on the same side. Speed and MemoryEfficiency however...
08:35:54 <Saizan> balor: what's the type of your function?
08:36:10 <balor> Graph -> [Char] -> [Int] -> Maybe [Int]
08:36:36 <FunctorSalad_> what are the valid values for "keymap" in Leksah?
08:36:58 <Saizan> balor: and what should your program do?
08:37:01 <deech> yitz: Yes, very true.
08:37:29 <balor> Saizan: The function returns a list of Ints, or Nothing
08:37:44 <deech> yitz: I usually ignore those bickering brothers until the code does what I intend.
08:37:49 <Saizan> balor: yeah, but how would it take the arguments from the outside?
08:37:50 <aristid> balor: the function is not a program
08:38:15 <balor> d'oh
08:38:20 <balor> I see it now
08:38:21 <Saizan> balor: if you just want to try it out with some haskell expressions as arguments i'd load it in ghci
08:38:24 <Taejo> binary sym fun = Infix (s sym *> pure fun) AssocLeft -- WARNING: Haskell contains pure fun
08:39:04 <Olathe> I thought fun was impure.
08:39:32 <Olathe> Since it changes state.
08:40:01 <dayz> if two logical theories have identical axioms, would it be correct to say that the two theories have the same "deductive power"?
08:40:35 <FunctorSalad_> why not "the same"? ;)
08:40:57 <FunctorSalad_> assuming the language is the same if the axioms are...
08:41:20 <FunctorSalad_> (ok, they may have differing unused language elements....)
08:42:26 <dayz> hmm
08:43:40 <FunctorSalad_> (by the way, AIUI 'theory' is a technical term referring to the set of theorems of a deductive system, so a theory wouldn't even have axioms...)
08:44:23 <dayz> FunctorSalad_, but if a theory doesn't have axioms, then how are the theorems deduced?
08:44:27 <FunctorSalad_> or at least there's a 'theory' operator that returns the set of theorems
08:45:20 <FunctorSalad_> dayz: http://en.wikipedia.org/wiki/Theory_%28mathematical_logic%29
08:45:23 <Cale> dayz: The theory is the set of all the theorems. Which ones were the axioms has been forgotten.
08:46:56 <gwern> so we can only compare theories if we are logically omniscient. troublesome.
08:47:06 <norm2782> I'm trying to install language-python-0.3.1 using cabal-install version 0.8.2 w/ version 1.8.0.4 of the Cabal library. however, at two thirds of the way ghc starts consuming every bit of my free mem and compilation never completes. does anyone have any idea how I could resolve this?
08:47:15 <norm2782> Keeps failing at [15 of 23] Compiling Language.Python.Version3.Parser.Parser ( dist/build/Language/Python/Version3/Parser/Parser.hs, dist/build/Language/Python/Version3/Parser/Parser.o )
08:47:54 <norm2782> s/failing/hanging
08:47:58 <gwern> norm2782: people were discussing that yesterday
08:48:06 <Cale> norm2782: I think someone else mentioned that GHC takes a rather extreme amount of memory to compile that module
08:48:08 <gwern> some ghc bug which may've gone away in HEAD
08:48:13 <dv-> @type pure >>> sequence -- :o
08:48:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
08:48:41 <norm2782> ah great, thanks guys. didn't see that yesterday. I'll try the latest ghc
08:48:48 <hstefan> hey. Is there someone able to answer me stuff about gtk2hs?
08:48:53 <FunctorSalad_> gwern: hmm depends on how the theory (which is of type 'Set') is presented to you
08:49:03 <dayz> Cale, why the axioms should be forgotten in a theory?
08:49:29 <gwern> norm2782: you should probably find the ghc bug report and see what is recommended there
08:49:29 <Cale> dayz: Well, you couldn't tell which statements were the axioms if all you have is a set of theorems.
08:49:30 <FunctorSalad_> if two theories are given in the form "thy(axiom1, .... axiomk)" it would be enough to prove that the axioms lists imply each other
08:49:43 <FunctorSalad_> (to prove that the theories are equal)
08:49:45 <fryguybob> byorgey: Excellent, works now.
08:49:47 <dcoutts> norm2782: it's a known issue (there's a ghc ticket about it), no easy solution, though using -O0 makes it less severe
08:49:50 <norm2782> gwern: good plan
08:50:02 <hstefan> can can I get some item from a listStore?
08:50:39 <hstefan> how can I*
08:50:44 <dayz> i see. thanks
08:51:00 <Cale> dayz: If I hand you a big bag of statements, it might be ambiguous which ones should be the axioms, and which ones are consequences of those -- there might be more than one minimal set of statements among them which could serve as axioms, and even then there are possible choices of axioms which are not minimal
08:51:05 <FunctorSalad_> (my point is that it's hard to have a 'literal' representation of an arbitrary infinite set ;))
08:52:06 <FunctorSalad_> (not quite arbitrary -- closed under deduction -- but doesn't matter)
08:52:16 <norm2782> this seems to be it: http://hackage.haskell.org/trac/ghc/ticket/3972
08:52:36 <norm2782> I'll have a go at it after dinner
08:52:48 <shapr> norm2782: How long did you l/
08:52:52 <hstefan> is haskell.org down?
08:53:06 <gwern> I think so. I was going to revert some spam I saw in the rss changes feed, but...
08:53:55 <hstefan> dammit, I need gtk2hs reference @_@
08:54:36 <norm2782> shapr: not sure what l/ is, but I let the process run for about half an hour.. it was consuming about 2.3 GB of free mem then and CPU activity was near zero
08:54:41 <shapr> norm2782: How long did you let the compile run before you gave up?
08:54:48 <Cale> hstefan: If you have "documentation: True" in your ~/.cabal/config and you installed Gtk2Hs from hackage, then it should be available in ~/.cabal/share/doc/
08:55:07 <Iago> hello, did someone read "I am not a number: I'm a free variable" ?
08:55:20 <hstefan> Cale: ty.
08:55:26 <shapr> norm2782: I'm in that same place right now, it's been running for 45 minutes, using 2.3gb, using only 2% cpu. Something is wrong here.
08:55:30 <pozic> Iago: do not ask to ask.
08:55:42 <norm2782> shapr: that sounds exactly like what I had this afternoon
08:56:11 <Iago> pozic, ok sorry
08:56:32 <hstefan> damm, there's no documentation :(
08:56:39 <shapr> Ah, virtual usage is 4.5gb. I think it's thrashing.
08:57:08 * shapr gives up and hits ^C
08:57:21 <Cale> hstefan: If you add that line to ~/.cabal/config and reinstall, it should build it for you :)
08:57:35 <norm2782> ugh.. haskell.org being down is a pain
08:57:40 <Iago> hello, did someone read "I am not a number: I'm a free variable" ? in that case, does someone know some code that make use of the kit described in the paper? (e.g. a lambda calculus and its type checker)
08:58:13 <hstefan> hstefan: thank you
09:00:46 <nominolo> Iago: I read the paper a while ago.  As for code, they say they used it in Epigram, no?
09:00:47 <haploid> can anyone verify that haskell.org is down ?
09:00:58 <Cale> yep
09:01:56 <Taejo> is left-recursion a problem in parsec?
09:02:43 <haploid> are there any known mirrors from which I can grab ghc 6.12.1 while the main site is down ?
09:02:47 <FunctorSalad_> Taejo: yes, it just produces an infinite loop if you can left-recurse without consuming anything :(
09:02:50 <haploid> or do I need to wait? :)
09:02:53 <Taejo> ok
09:03:09 <Taejo> FunctorSalad_: thanks, so it seemed, just wanted to check I wasn't missing anything
09:03:48 <norm2782> shapr: I'm fetching ghc head now, but it's taking forever.. if I get some results I'll let you know :)
09:04:48 <Iago> nominolo, I took a look on Epigram's code, but I was looking for something simpler...
09:06:17 <Iago> well, I was seeing http://www.e-pig.org/darcsweb?r=Pig09 but maybe I should download Epigram 1
09:06:27 <hstefan> are you able to enter www.haskell.org?
09:08:43 <Iago> nominolo, thanks anyway, I discovered that Ivor uses the same strategy
09:10:26 <FunctorSalad_> I can ping it with shockingly low mean deviation (wth does `ping' use that?) rtt min/avg/max/mdev = 100.412/100.859/101.450/0.416 ms
09:10:34 <FunctorSalad_> ( @ hstefan )
09:11:13 <akosch> i'm looking for something like "while", but can't find anything in control.monad...
09:11:24 <Iago> well, a similar one
09:11:43 <Olathe> @hoogle IO Bool -> IO ()
09:11:44 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
09:11:44 <lambdabot> Network.BSD setHostEntry :: Bool -> IO ()
09:11:44 <lambdabot> Network.BSD setNetworkEntry :: Bool -> IO ()
09:11:54 <Taejo> :t (\x y -> Deref $ x + y)
09:11:55 <lambdabot> Not in scope: data constructor `Deref'
09:12:01 <Taejo> @pl (\x y -> Deref $ x + y)
09:12:01 <lambdabot> (Deref .) . (+)
09:12:16 <haploid> Prelude is deprecated?  wow
09:12:25 <Taejo> haploid: what?
09:13:07 <haploid> just learning haskell from this book, getting warnings from ghc that the module Prelude is deprecated
09:13:20 <haploid> not a very old book either
09:13:33 <pozic> haploid: show us exactly what you are doing.
09:13:37 <Saizan> it's not Prelude that's deprecated
09:13:38 <FunctorSalad_> 38 packets -> 99.946/100.810/101.693/0.408 ms
09:13:40 <Saizan> it's base-3
09:13:50 <Taejo> that makes more sense
09:13:53 <Saizan> but don't worry too much about it
09:14:21 * hackagebot pisigma 0.2 - A dependently typed core language  http://hackage.haskell.org/package/pisigma-0.2 (AndresLoeh)
09:14:57 <FunctorSalad_> ah.... base version 3
09:15:49 <haploid> Saizan:  ok
09:16:24 <aristid> @unpl (x .)
09:16:25 <lambdabot> (\ a d -> x (a d))
09:16:53 <aristid> @unpl (. x)
09:16:53 <lambdabot> (\ a d -> a (x d))
09:17:10 <aristid> @unpl (. x) . y
09:17:10 <lambdabot> (\ d g -> y d (x g))
09:17:36 <Taejo> @ty foldl
09:17:37 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:22:48 <hstefan_> hey. I'm using a treeView in gtk2hs and it's model is a (String, [String]) listStore. The problem is: how can I get the [String] selected by the user?
09:23:13 <hstefan_> (I'm not sure if I explained my self correctly)
09:23:14 <haploid> is there an "ideal" distro to get haskell running on?
09:23:35 <dcoutts> hstefan_: you mean the type of each row in the model is  (String, [String]) ?
09:23:50 <hstefan_> dcoutts: exactly
09:24:49 <dcoutts> haploid: all of debian, gentoo, fedore and ubuntu are popular for Haskell, they all have some packages and one can also use cabal-install on them
09:25:08 <dcoutts> hstefan: so how do you want to represent the [String] bit?
09:26:06 <hstefan> I want to append it into another listStore and show it on another treeView
09:26:19 <haploid> dcoutts:  well ok, I'm using ubuntu and the vast majority of cabal packages don't build because unix-compat-0.1.2.1 doesn't build.
09:26:42 <Cale> haploid: The way I prefer to install GHC is pretty distribution-independent. Just grab the generic linux binary from the GHC website, install that, and then grab the cabal-install tarball from hackage and run the bootstrap.sh script from that.
09:27:14 <dcoutts> hstefan: oh ok so you don't want to display it in the same treeview, so you just want to do something with another treemodel/view when a row is selected
09:27:14 <haploid> Cale:  yeah, did that.  thanks.
09:27:29 <hstefan> yes.
09:27:57 <FunctorSalad_> Cale: seconded...
09:28:12 <dcoutts> haploid: I expect it's not too hard to get the unix-compat package building, it'll work on any linux distro if you've got the right C libs and headers installed
09:28:45 <dcoutts> hstefan: so look at the selection object, do something when it changes
09:28:45 <jlouis> hmm, snap on ghc 6.13 proves to be harder than I thought
09:29:28 <aristid> jlouis: huh?
09:29:35 <hstefan> the another treeView already 'exists' on screen, but it starts empty. When you select a row (a word) this treeView should show the synonymous on a [String].
09:29:37 <jlouis> knocking doors on different cabal package owners packages :)
09:29:52 <jlouis> aristid: snapframework.com
09:29:56 <jlouis> GHC HEAD
09:30:03 <hstefan> the problem is that I dont know how to get the element and the 'snd' of the tuple.
09:30:06 <FunctorSalad_> paranoid upper bounds again?
09:30:10 <FunctorSalad_> for dep versions
09:30:16 <haploid> dcoutts:  ok, well I'll keep working at it.  unix-compat build emits "ExitFailure 1" which is pretty uninformative.
09:30:24 <FunctorSalad_> *cough* these shouldn't be hard constraints
09:30:31 <dcoutts> haploid: there will be an error message earlier up in the log
09:30:35 <aristid> jlouis: i know about snap, but i wondered what was the problem :)
09:30:45 <jlouis> aristid: base-4 support
09:30:54 <FunctorSalad_> oh. hehe
09:31:12 <dcoutts> hstefan: right, so you need to go and modify the other view's model each time
09:31:13 <aristid> jlouis: because ghc 6.13 removes support for base-3?
09:31:18 <jlouis> aristid: yes
09:31:21 <FunctorSalad_> finally ;)
09:31:32 <FunctorSalad_> produces so many warnings ;)
09:31:44 <aristid> jlouis: well, then you only need to port all modules to base-4 :)
09:31:48 <jlouis> aristid: so I am mailing the owners of packages with patches at the moment to get it fixed now
09:31:50 <dcoutts> hstefan: you could make separate models and switch them, or make a new one each time, or mutate a single one.
09:31:56 <hstefan> dcoutts: I'm stucked in line 76.
09:32:05 <jlouis> rather than when ghc 6.14 hits
09:32:06 <hstefan> http://codepad.org/N0NHqf4K
09:32:09 <hstefan> heres the code
09:32:25 * hackagebot hsyscall 0.1 - FFI to syscalls  http://hackage.haskell.org/package/hsyscall-0.1 (AycanIrican)
09:32:40 <dcoutts> hstefan: have you worked out how to get data out of your existing model?
09:32:45 <haploid> dcoutts:  referring to the part following "command was:" ?  http://pastebin.com/qNV4Dn1u
09:33:33 <dcoutts> haploid: hmm, indeed, surprisingly uninformative
09:33:38 <hstefan> dcoutts: thats what I am looking for.
09:33:49 <dcoutts> hsc2hs usually tells us something about what went wrong
09:34:25 <dcoutts> hstefan: have you looked at the docs for the ListStore ?
09:34:40 <hstefan> dcoutts: I cant because haskell.org is offline :S
09:34:52 <dcoutts> hstefan: it's also on hackage
09:34:54 <dcoutts> @hackage gtk
09:34:55 <lambdabot> http://hackage.haskell.org/package/gtk
09:35:14 <dcoutts> haploid: you can cabal unpack, cd the-dir, cabal configure, cabal build -v
09:35:19 <dcoutts> haploid: might give us a bit more info
09:35:30 <haploid> dcoutts:  ok
09:35:49 <dcoutts> haploid: it's the hsc2hs preprocessor failing that is the symptom, the challenge is to work out why
09:36:09 <FunctorSalad_> it's in gtk2hs-buildtools
09:36:13 <FunctorSalad_> or something like that
09:36:18 <FunctorSalad_> which is on hackage :)
09:36:33 <aristid> jlouis: i told the people in #snapframework about the base-3 thing
09:36:36 <FunctorSalad_> the problem is just that preprocessor executables don't count as deps
09:36:53 <FunctorSalad_> @ hstefan
09:36:54 <jlouis> aristid: heh, I better join then
09:37:06 <FunctorSalad_> err sorry
09:37:13 <hstefan> uh?
09:37:18 <FunctorSalad_> wrong @ :)
09:37:48 <FunctorSalad_> the one who needed gtk2hs's hsc2hs, anyway
09:38:02 <dcoutts> FunctorSalad_: you're confused, gtk2hs has a fork of c2hs, not hsc2hs
09:38:13 <dcoutts> and this is about building unix-compat, not gtk2hs
09:38:49 <hstefan> dammit, I dont know what do 2_@
09:39:07 <FunctorSalad_> dcoutts: I plead misreading of the executable name "gtk2hsC2hs"... but correct on the second...
09:39:13 <aristid> will some of the error handling mechanisms be removed from a future version of ghc?
09:39:21 <haploid> dcoutts: building and instaling from the unpacked directory worked fine.  wtf?
09:39:46 <haploid> I guess I'll just unpack/build/install all the dependencies by hand
09:39:53 <dcoutts> haploid: does doing cabal install unix-compat --reinstall still fail? or was the whole thing transitory?
09:40:21 <dcoutts> haploid: if your box is temporarily low on memory, linking can sometimes fail (ld gets killed by the kernel)
09:40:55 <haploid> dcoutts, no it fails again
09:41:05 <dcoutts> hmm, weird
09:41:22 <dcoutts> haploid: this really shouldn't happen, you should not need to do the steps manually
09:41:30 <haploid> ah it's not just nix-compat - same issue with other dependencies
09:41:45 <dcoutts> haploid: any more info if you add -v ?
09:41:47 <haploid> and sure enough, I can build them manually just fine
09:42:11 <hstefan> dcoutts: sorry to bother you again... but could you give me some help here?
09:42:32 <dcoutts> haploid: oh, I don't suppose you've got /tmp mounted noexec ?
09:43:24 <dcoutts> hstefan: did you find http://hackage.haskell.org/packages/archive/gtk/0.11.0/doc/html/Graphics-UI-Gtk-ModelView-ListStore.html#v%3AlistStoreGetValue
09:43:50 <haploid> dcoutts:  yeah my host has /tmp and /var/tmp noexec by default
09:43:59 <dcoutts> haploid: ok, there's the issue
09:44:03 <haploid> I'll umount and try
09:44:08 <dcoutts> haploid: hsc2hs generates a C program and runs it
09:44:27 <dcoutts> haploid: and cabal install puts the whole build tree in /tmp/$random
09:44:36 <dcoutts> which is why it does not fail when you do it locally
09:44:40 <haploid> dcoutts:  umounting /tmp worked!
09:44:46 <haploid> awesome
09:44:53 <dcoutts> haploid: or changing $TMP would also work
09:45:11 <aristid> changing $TMP is probably better than umounting /tmp...
09:45:13 <dcoutts> haploid: I'll go file a ticket about getting a better error message for this case
09:45:30 <haploid> dcoutts++
09:45:38 <hstefan> dcoutts: ok... i've understood that part. But how can I get the 'id' of the element selected to use it  with listStoreGetValue
09:45:44 <Colours> hey is haskell.org down
09:45:51 <fxr> Colours: yes it is
09:45:52 <haploid> Colours yes
09:45:55 <Colours> : (
09:46:23 <hstefan> Colours: yes
09:46:53 <dcoutts> haploid: glad we figured it out :-)
09:47:08 <tao_> hi guys
09:47:08 <dcoutts> hstefan: it's just the index of the item you want
09:47:09 <tao_> sup
09:47:47 <hstefan> I know! But how can I get this index?!
09:47:54 <dcoutts> hstefan: ah, you're wondering about the TreeIter and the TreePath business
09:48:01 <haploid> dcoutta yup, thanks
09:48:47 <dcoutts> hstefan: a TreePath is a list of indexes, for a flat list tree model it'll always be length 1, it's only longer for trees
09:49:11 <dcoutts> hstefan: so you could do: [[i]] <- treeSelectionGetSelectedRows sel
09:49:48 <dcoutts> if you've got it in the mode were only a single selection is allowed
09:50:10 <hstefan> it is
09:50:10 <dcoutts> or you can use treeSelectionGetSelected and use the TreeModel to convert the TreeIter to a TreePath
09:50:51 <hstefan> the selection mode is set for single mode. "selected <- Model.treeSelectionGetSelectedRows treeview"
09:51:00 <hstefan> it must be [[selected]]?
09:51:12 <dcoutts> well that function gives you all the selected rows
09:51:25 <dcoutts> which in your case will be [] or [_]
09:51:41 <dcoutts> and the paths are all going to be of length 1, as you're using just a list, not a tree model
09:51:58 <dcoutts> hstefan: the Gtk tree stuff is a little over engineered, with these iters as well as paths
09:52:15 <dcoutts> and supporting trees as well as lists
09:52:24 <tao_> I have a question about haskell coding style. Please take a look at: http://gist.github.com/420009 . Am I doing it right? Note the "f(a)*f((a+b)/2)" and "integr a ((a+b)/2) f"
09:52:36 <hstefan> my brain is full of fuck.
09:52:59 <hstefan> meh, gtk2hs is a bit complicate
09:53:03 <hstefan> complicated*
09:54:17 <dv-> Nah
09:54:28 <kmc> tao_, f(a) is rare
09:54:31 <kmc> since those parens do nothing
09:54:35 <kmc> we'd typically write: f a
09:55:14 <Berengal_> haskell.org seems to be down :(
09:55:17 <tao_> so it would be (f a)*(f b)?
09:55:22 <tao_> Berengal_: same here
09:55:25 <kmc> sure
09:55:28 <kmc> or just f a * f b
09:55:29 <dmwit> f a * f b
09:55:35 <kmc> function application binds tighter than any infix operator
09:55:41 <kmc> still the parens are sometimes more readable
09:56:03 <tao_> oh
09:56:05 <tao_> nice
09:56:10 <tao_> thanks
09:56:12 <hstefan> dcoutts: listStoreAppend sinonList snd(listStoreGetValue list WAT HERE)
09:56:18 <Berengal_> I prefer (f a) * (f b), really...
09:56:27 <ddarius> I don't.
09:56:38 <hstefan> dcoutts: something like that?
09:56:51 <hstefan> I still stucked in get the index.
09:57:15 <dcoutts> hstefan: you need at least three lines: one to get the selected row, one to get the value at that row, and finally a loop to append the list of strings to the new model.
09:58:00 <hstefan> selected <- Model.treeSelectionGetSelectedRows treeview
09:58:01 <hstefan> checked
09:58:16 <hstefan> get the value is the problem.
09:58:35 <kmc> tao_, this is about how i'd write it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25839#a25839
09:58:50 <kmc> - type sigs on every top-level binding
09:59:10 <kmc> - (a+b)/2 factored out using "where"
09:59:27 <tao_> yeah, already done :)
09:59:28 <tao_> thanks
09:59:38 <kmc> also, i changed the arg order on "integr"
09:59:48 <tao_> "type sigs on every top-level binding"
09:59:49 <tao_> well
09:59:53 <tao_> i prefer not to
09:59:59 <tao_> if programm works ok
10:00:03 <kmc> because the partial application (integr f) seems more meaningful this way
10:00:25 <tao_> kmc: hmm
10:00:28 <kmc> type signatures are machine-checkable comments
10:00:41 <tao_> but there is no partial application of that function
10:00:42 <tao_> i mean
10:00:44 <fryguybob> byorgey: It seems the mailing list is still down... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25840#a25840
10:00:47 <tao_> you have to use a and b
10:00:58 <EvanR-work> tao_: i use javascript at work. man i wish i had type signatures on top level bindings
10:01:04 <dcoutts> hstefan: something like http://codepad.org/YvF7eM7n
10:01:11 <kmc> tao_, i can imagine a situation like map (integr f 0) [1,7,29]
10:01:12 <tao_> EvanR-work: heh
10:01:18 <fryguybob> byorgey: This is a refinement of the issue in: http://projects.haskell.org/pipermail/diagrams/2010-May/000000.html
10:01:21 <EvanR-work> i have no idea what anything takes or returns
10:01:23 <tao_> EvanR-work: i use perl, never complained
10:01:31 <kmc> much more easily than i can imagine map (integr 3 7) [f, g, h]
10:01:33 <kmc> though both are somewhat plausible
10:01:37 <tao_> kmc: oh, true
10:01:37 <byorgey> fryguybob: yeah, the mailing list is being worked on
10:01:42 <byorgey> fryguybob: I'll send out a message once it's up
10:01:56 <EvanR-work> tao_: you partially apply a lot more than you think in haskell. and then youll want to in other langs ;)
10:02:04 <tao_> indeed
10:02:08 <fryguybob> byorgey: ok
10:02:10 <hstefan> dcoutts: thank you again. Saved my ass.
10:02:12 <EvanR-work> and then not be able to
10:02:15 <EvanR-work> easily or at all
10:02:36 <haploid> hstefan: dcoutts has been saving asses by the assload
10:02:40 <byorgey> woah, a message to the list!?
10:02:58 <dcoutts> hstefan: it's mostly a matter of remaining calm, checking the docs, looking at the demos and chasing the chain of types.
10:02:58 <byorgey> fryguybob: hahahaha, I just realized that being the *administrator* of the list is NOT the same thing as being *subscribed*  =)
10:03:05 <FunctorSalad_> hehe
10:03:08 <EvanR-work> rofl
10:03:53 <EvanR-work> "remain fearless in the face of error messages"
10:05:05 <tao_> kmc: http://gist.github.com/420009 this is better?
10:05:30 <ddarius> tao_: Is this code supposed to be correct and is there any reason you don't want to write out "integrate" ?
10:05:37 * hackagebot hsyscall 0.2 - FFI to syscalls  http://hackage.haskell.org/package/hsyscall-0.2 (AycanIrican)
10:05:45 <hstefan> dcoutts: it still not working
10:05:48 <kmc> tao_, you can't have two "where" clauses like that; you can put two bindings under "where" though
10:06:02 <kmc> also i'd write abs (a-b) rather than abs(a-b)
10:06:17 <kmc> and f a * f c
10:06:26 <tao_> oh
10:06:28 <tao_> ff
10:06:29 <tao_> sorry
10:06:45 <tao_> ddarius: i am just practicing, sorry
10:06:48 <kmc> and the type signatures really are recommended ;)
10:07:10 <dcoutts> hstefan: people can only help you if you say what does not work, and show them what is going on, rather than making people guess :-)
10:07:31 <hstefan> SORRY.
10:07:40 <hstefan> sorry for the caps lock, again.
10:07:49 <dcoutts> :-) np
10:09:05 <hstefan> appgui.hs:79:48: Couldn't match expected type `String' against inferred type `Char In the second argument of `listStoreAppend', namely `str'
10:09:08 <hstefan>     In the expression: listStoreAppend sinonList str
10:09:10 <hstefan>     In the first argument of `sequence_', namely
10:09:13 <hstefan>         `[listStoreAppend sinonList str | str <- strings]'
10:09:36 <temoto> hstefan, and using paste service like codepad.org is nice too
10:09:43 <haploid> pastebin for > 2 lines
10:09:57 <hstefan> oh... I tought the limit was 4 lines.
10:10:02 <dcoutts> hstefan: check that your model really does have type (String, [String])
10:10:26 <haploid> well maybe it is hre, I dunno.  #java is generally  > 2 lines
10:10:31 <temoto> It's nice for any number of lines :)
10:10:43 <haploid> *here
10:10:44 <kmc> hstefan, it's also nice to not have it scroll off
10:11:05 <kmc> (that's 6 lines of text in my client btw)
10:11:05 <hstefan> sorry >_>
10:11:11 <kmc> no worries :)
10:11:28 <kmc> lambdabot will gladly spam the channel with 10+ lines sometimes
10:11:32 <kmc> and we haven't banned her yet
10:11:35 <hstefan> dcoutts: it does...
10:11:56 <temoto> hstefan, paste the whole appgui.hs
10:12:38 <hstefan> http://codepad.org/pOvVAR5n
10:13:02 <hstefan> (if you want the Trie module too just ask)
10:13:14 <byorgey> fryguybob: thanks for the nks for the example code
10:14:11 <byorgey> fryguybob: I'm taking a look at it now.
10:14:16 <tao_> oh wait
10:14:16 <tao_> wtf
10:14:23 <tao_> why i called my function 'integr'
10:14:30 <tao_> god i am so lame
10:14:43 <tao_> How do you call this algorythm? A search for roots?
10:14:46 <FunctorSalad_> because it's shorter than `integrate'?
10:15:02 <soupdragon> what algorithm?
10:15:02 <FunctorSalad_> short names are underrated ;)
10:15:28 <tao_> soupdragon: well, when you have f(x) = 0 and you search for x
10:15:32 <oab> Is there some place I can read about why c-- is basically dead?
10:15:34 <tao_> on the specific region
10:15:37 <tao_> s/on/in/
10:15:38 <soupdragon> how do you search?
10:15:45 <FunctorSalad_> not so sure the 'i' is more correct considering the word's Arabic (iirc) in origin
10:15:52 <tao_> soupdragon: well, i mean in general
10:16:01 <tao_> root searchign algorithm?
10:16:05 <soupdragon> there are a variety of algorithms for this
10:16:17 <FunctorSalad_> (so there is some freedom in transliteration, no?)
10:16:24 <tao_> yeah i know, but what's the name of the task itself?
10:16:35 <tao_> (i am asking this, because i am not a native speaker)
10:17:01 <kmc> oab, http://llvm.org/
10:17:03 <kmc> ;)
10:17:06 <byorgey> "solving", or "root-finding"
10:17:17 <tao_> root-finding looks nice, thanks
10:17:29 <FunctorSalad_> awesome ;) "from M.L. algorismus, a mangled transliteration of Arabic al-Khwarizmi "native of Khwarazm," surname of the mathematician whose works introduced sophisticated mathematics to the West (see algebra)."
10:18:22 <temoto> hstefan, whoa... well you could start with :t listStoreAppend in your ghci.
10:19:21 <tao_> btw, have you guys heard the news?
10:19:22 <hstefan> it does nothing...
10:19:28 <tao_> there will be c++ allowed in GCC
10:19:38 <tao_> well, not C compiler, but compiler collection
10:19:38 <hstefan> anyway... it's time t move for class.
10:19:46 <tao_> which is bad, imo
10:19:47 <Cale> tao_: That's news?
10:19:48 <hstefan> see you later
10:19:56 <tao_> Cale: ...yeah?
10:20:03 <temoto> hstefan, well you need to import the module with :m +Graphics.UI.Gtk
10:20:15 <Cale> tao_: Hasn't it included a C++ compiler for a long time?
10:20:22 <tao_> no
10:20:24 <tao_> i mean
10:20:41 <tao_> compiler developers are now allowed to use c++
10:20:46 <tao_> http://gcc.gnu.org/ml/gcc/2010-05/msg00705.html
10:20:47 <Cale> oh
10:21:02 <Cale> Well, they can use whatever they like :)
10:21:22 <pikhq> For 4.5 they spent time getting GCC to *build* with G++ while still being C. Go figure.
10:21:41 <tao_> Cale: umm, but GCC is the most popular and one of the best compilers for unix and unix-like systems
10:22:02 <Cale> tao_: Are you worried that it'll be more difficult to bootstrap?
10:22:08 <pikhq> Also, they don't allow any C++ in the C chunk of the compiler.
10:22:15 <tao_> i'm worried about more bugs
10:22:26 <pikhq> (so you can *still* bootstrap on a freaking PDP-11)
10:22:31 <tao_> i hope linus (a known c++ hater) will make his own compiler, or something
10:22:38 <BONUS> gcc is old hat, clang rules!!! *rides away on a motorcycle*
10:22:51 <tao_> lol
10:22:55 <haploid> on average, how long does it take a long-term imperative programmer to fundamentally grok the FP way of doing things ?
10:22:55 <kmc> g++ isn't a C++ compiler anyway
10:23:02 <kmc> nobody has ever written a C++ compiler
10:23:11 <dcoutts> haploid: probably a year or two
10:23:12 <tao_> because c++ is shit
10:23:14 <Silvah> Nobody?
10:23:15 <Cale> haploid: It took me about a year to feel comfortable.
10:23:16 <tao_> amirite, kmc ?
10:23:18 <kmc> haploid, don't use "imperative" as the opposite of "functional"
10:23:21 <BONUS> haploid: a year
10:23:25 <kmc> urrite tao_
10:23:39 <haploid> allright
10:23:43 <kmc> it will depend a lot
10:23:47 <pikhq> Silvah: g++ has one of the most complete C++ *parsers* out there.
10:23:50 <pikhq> It's not complete.
10:23:58 <pikhq> *Nobody can parse C++ fully*.
10:24:00 <tao_> pikhq: do you mean that the C compiler will still be developed in C?
10:24:04 <dcoutts> haploid: look on the plus side, it's much less than for C++  :-)
10:24:08 <pikhq> tao_: Yes.
10:24:11 <tao_> oh
10:24:11 <tao_> yeah
10:24:16 <tao_> that's good, of course
10:24:31 <tao_> dcoutts: lol
10:24:39 <Silvah> Guys from Comeau Computing wrote a C++ compiler.
10:24:55 <kmc> i'm not sure what an "imperative programmer" means anyway... a Python or JavaScript expert is going to have a very different perspective than a C++ or Java expert
10:24:59 <pikhq> Silvah: Not complete.
10:25:03 <Cale> Haha, does even Stroustrup fundamentally grok the C++ way of doing things? ;)
10:25:09 <Silvah> Why so?
10:25:21 <kmc> there are some languages traditionally labeled as "imperative" where core FP concepts are commonplace, though they may try to disown the terminology
10:25:22 <tao_> kmc: there are no C++ experts
10:25:37 <tao_> well, maybe stroustrup
10:25:49 <pikhq> Silvah: Well. Do they implement template export?
10:25:59 <haploid> kmc, yeah, more the latter.  at least I won't have a problem with strong static typing
10:26:03 <pikhq> (Nobody does.)
10:26:04 <Silvah> Aye.
10:26:16 <kmc> haploid, well, that's not part of the FP way of doing things
10:26:22 <pikhq> Okay, they may have the single most feature-complete C++ compiler.
10:26:24 <haploid> true
10:26:27 <tao_> haploid: so, what language were you using before you found out about haskell?
10:26:49 <kmc> haploid, and the C++ and Java type systems are pretty far from Haskell's
10:27:04 <kmc> in terms of features offered, effort vs. safety tradeoff, etc.
10:27:05 <tao_> c++ type system is a joke
10:27:10 <haploid> tao_:  I've done a lot of assembly, C, C++, and Java
10:27:18 <tao_> comparing to haskell's
10:27:21 <tao_> haploid: i see, cool
10:27:21 <haploid> primarily Java for the last few years
10:27:34 <Cale> haploid: You should basically treat Haskell as if it's your first programming language then. :)
10:27:43 <haploid> yeah probably
10:27:47 <Silvah> Assembly has better TS than C++, actually.
10:28:14 <kmc> a lot of people come to Haskell expecting it to be an introduction to FP concepts, but it's also an introduction to like 17 other things
10:29:03 <tao_> oops, sorry
10:29:05 <tao_> kmc: what's the introduction to FP concepts then?
10:29:19 <kmc> tao_, you could get it from Haskell, i'm just saying there are many other things to learn
10:29:41 <kmc> and there's a tendency to lump it all together as "the FP way of thinking" when most of it is foreign to other languages
10:29:50 <tao_> yeah, but where else i can get a good introduction to fp?
10:29:58 <kmc> the purest core of FP would be the lambda calculus, and the practical language closest to it would be Scheme
10:29:59 <tao_> I mean, I started with a haskell, because it's "pure"
10:30:04 <tao_> i prefer to learn that wa
10:30:04 <tao_> y
10:30:07 <tao_> for example
10:30:10 <tao_> when i was learning emacs
10:30:21 <oab> isn't fp so simple there is really no need to learn fp?
10:30:22 <tao_> i unbinded all arrows and pgup, pgdown, etc
10:30:33 <tao_> if you still understand me.. :)
10:30:38 <pikhq> oab: FP is so simple that it *must* be learned.
10:30:44 * hackagebot hlibev 0.2.4 - FFI interface to libev  http://hackage.haskell.org/package/hlibev-0.2.4 (AycanIrican)
10:31:08 <haploid> I actually ended up deciding to learn haskell because I like the idea of reducing side effects to make concurrency easier
10:31:09 <Cale> I sort of halfway disagree about that. When I think of FP languages, I think of the ML family, Miranda, Haskell, Clean, more than I think of lisps and Scheme. Maybe that's just me though.
10:31:17 <kmc> it's just you Cale ;)
10:31:18 <tao_> kmc: well, you can do lambda calculus in many languages
10:31:37 <kmc> certainly a lot of Common Lisp code is very un-functional
10:31:52 <Cale> Scheme is probably the best lisp in which to do functional programming
10:31:59 <fxr> right
10:32:02 <kmc> ultimately "FP" describes a style, not a language, and the most we can say about a language is the degree to which it encourages or discourages FP
10:32:03 <Cale> (or one of the better ones)
10:32:06 <oab> I find it strange to talk about learning FP rather than just learning programming.
10:32:28 <tao_> kmc: indeed
10:32:34 <kmc> oab, yeah.  it could mean "learning how to program without one specific arbitrary restriction"
10:32:39 <tao_> but iirc haskell strongly encourages that style?
10:32:45 <kmc> yes tao_
10:32:53 <kmc> or it could mean "learning how to program without mutable state"
10:33:04 <kmc> but many real-world programs still have lots of state, even in Haskell
10:33:10 <tao_> yeah, i know
10:33:21 <tao_> btw,
10:33:26 <kmc> for the latter i might prefer to say "denotational programming"
10:33:37 <tao_> where can i read about mutable states and other (un)mutable stuff?
10:33:42 <kmc> in Haskell?
10:33:51 <tao_> in general
10:33:54 <tao_> in programming
10:34:04 <oab> there is not much to it
10:34:27 <kmc> hrm
10:34:31 <tao_> i just dont know what the mutalbe thing is
10:34:31 <kmc> i don't know how to answer that question
10:34:45 <tao_> what does it mean?
10:34:48 <kmc> "mutable state" just means something that changes over time
10:35:01 <kmc> some would say "a value that changes over time", but i think that's a nonsensical idea
10:35:08 <tao_> oh
10:35:10 <tao_> that was easy
10:35:29 <c_wraith> typically, mutable describes data that can be updated in place.  immutable describes data that's updated by creating a copy with changes.
10:35:33 <kmc> in Haskell we make a point of distinguishing between values and states
10:36:07 <kmc> you can have a "box" which holds different values at time A and at time B
10:36:44 <oab> perhaps FP could be described as regular programming with "one time assignment" or "no reassignment"
10:37:15 <kmc> oab, but the other meaning of FP ("programming with first class functions") is useful and essential even with mutable state and effects
10:38:14 <freiksenet> what is wrong with haskell.org? it is down for the whole day today
10:38:31 <kmc> imperative and functional programming are largely complimentary
10:38:41 <kmc> and the best languages have good support for integrating the two
10:38:51 <burp> debian.org had problems today too :>
10:38:52 <haploid> allright well my haskell dev environment appears to work ok now, I'm going to go outside in the sun, get drunk and read more of this haskell book
10:39:03 <kmc> haha
10:39:04 <haploid> thanks guys
10:39:05 <Cale> freiksenet: I think it's a US holiday.
10:39:08 <kmc> what's your drink of choice haploid?
10:39:21 <c_wraith> Cale, it is.  That means the server's on holiday, too.
10:39:27 <freiksenet> Cale: mmm, never seen websites celebrate holidays
10:39:29 <BONUS> oh today's a US holiday? that explains a lot
10:39:36 <BONUS> which one
10:39:37 <haploid> kmc in this heat, ice cold hefeweizen
10:39:40 <Cale> freiksenet: I just mean that perhaps whoever is supposed to bring the server back up is not at work.
10:39:40 <gwern> it's memorial day
10:39:45 <gwern> the day we remember servers are mortal too
10:39:59 <oab> imho there should be a place clearly defining FP, lest it become just as loosly defined as OOP
10:40:17 <Cale> oab: It is somewhat loosely defined
10:40:17 <gwern> a slave is supposed to follow around, whispering, 'Remember Cale, servers art mortal!'
10:40:25 <c_wraith> memorial day.  also known as "the holiday where summer unofficially begins".  Unfortunately, no one told the weather that.
10:40:45 <kmc> it's been hot as balls in NYC for a while now
10:40:49 <Cale> oab: Basically, the consequences of programming with functions and algebraic types.
10:40:53 <freiksenet> Cale: I see
10:41:05 <tao_> oab: i second this
10:41:21 <tao_> you should write that on wiki, whenever the site is up
10:41:40 * gwern has some spam to revert whenever the wiki comes back up
10:41:50 <oab> Probably nobody will agree with whatever definition is made and there will be endless trolling
10:41:54 <Cale> heh
10:42:04 <jlouis> gwern: JDH went on an F# spree?
10:42:07 <oab> You see the same thing with OOP
10:42:12 <applicative> gwern what kind of spam does the wiki get
10:42:20 <gwern> applicative: insurance spam, mostly
10:42:55 <kmc> hehe jlouis
10:43:06 <jlouis> insurance?! Isn't that for imperative programs?
10:43:09 <applicative> gwern, i see, general mechanize wiki-spam; hadn't heard of it, but it stands to reason it exists...
10:43:20 <applicative> mechanized
10:43:35 <kmc> oab, that presumes that it *is* sharply defined now
10:43:36 <gwern> applicative: it's unfortunate. our spam-fighting techniques aren't as good as en
10:43:44 <dolio> @quote F#.*parallelism
10:43:44 <kmc> or that there's value in reclaiming the term for something sharply defined
10:43:44 <lambdabot> JonHarrop says: F# is way ahead of everything open source when it comes to parallelism.
10:44:18 <oab> Harrop?
10:44:22 <kmc> a well-known troll
10:44:25 <oab> is that the ocaml troll dude
10:44:31 <kmc> he used to be an ocaml troll
10:44:40 <kmc> now he decided ocaml sucks and F# is awesome
10:44:40 <FunctorSalad_> kmc: is he really known to be a troll?
10:44:52 <FunctorSalad_> in the stricter sense...
10:44:57 <kmc> which of course has nothing to do with the fact that his company is now selling F# services instead of OCaml services ;)
10:45:19 <newsham> kmc: perhaps you have causation backwards?
10:45:23 <FunctorSalad_> (not really believing what he says, or at least, not caring about the truth of what he says, only about it being provocative)
10:45:31 <oab> He went on and on about some hashtable implementation provided in Haskell in the past
10:45:36 <freiksenet> FunctorSalad_: he promotes his books
10:45:42 <dmwit> The company he works at, or the company he owns? If the latter, I shouldn't be surprised at all by a correlation between his beliefs and his services.
10:45:48 <kmc> FunctorSalad_, imo "troll" implies only being provocative, not that you don't have a legitimate interest
10:46:13 <applicative> gwern, i guess it took a while for people to figure out email spam.  wikipedia at least has hundred of eyes watching stuff.
10:46:13 <newsham> also implies living under a bridge
10:46:37 <gwern> applicative: we also have a large blacklist, bots, nofollow on external links, and so on
10:46:49 <gwern> none of which ha has
10:46:52 <freiksenet> he deliberately spams mailing groups (at least comp.lang.lisp and haskell-beginners) and attacks lisp/haskell.
10:47:05 <tao_> kmc: well, that's the "trollinh style"
10:47:08 <tao_> *ing
10:47:12 <kmc> hehe tao_
10:47:24 <tao_> trolls usually dont have arguments or interests
10:47:28 <gwern> they see me trolling... with my f#...
10:47:34 <oab> He should pick on C++ instead
10:47:37 <freiksenet> maybe he tries to get more search results that criticize haskell/lisp, so people would choose F#/OCaml.
10:47:45 <Heffalump> I think 'troll' is probably the simplest one-word description of him.
10:47:51 <Heffalump> though it is too simplistic
10:48:00 <jlouis> he is more complex than just a troll
10:48:17 <applicative> he is, it's hard to tell what drives it though
10:48:24 <newsham> troll + j omega?
10:48:25 <FunctorSalad_> some of what he writes does sound like legitimate criticism.. but only *some* ;)
10:48:36 <tao_> jesus was a troll too then
10:48:42 <jlouis> sometimes his argument is superflously valid until someone with experience tells him how to optimize a program in e.g., lisp or Haskell
10:48:45 <tao_> he was VERY provocative
10:49:03 <FunctorSalad_> (pointing out that the bad stuff is open-source does smell trollish though...)
10:49:05 <Heffalump> jlouis: s/superfluously/superficially/ ?
10:49:10 <kmc> yup
10:49:13 <jlouis> Heffalump: yeah
10:49:15 <jlouis> thanks
10:49:15 <newsham> tao: put the fear of god in the wine producers.
10:49:16 <kmc> jesus was a troll who got permabanned
10:49:22 <kmc> after 3 days he registered a new account
10:49:27 <tao_> tru
10:49:31 <Heffalump> kmc: lol
10:49:34 <newsham> almost wiped out the fish and bread business
10:49:51 <applicative> not sure what a troll is, but jdh is an interesting case.  if you correspond with him, he slowly calms down and things become reasonable.
10:49:53 <kmc> newsham, hmm, must've been them who really did him in
10:49:58 <kmc> crucifixion was an inside job
10:50:07 <FunctorSalad_> in german, anti-open-source trolls saved the dying word "frickeln" ("to tinker with")
10:50:08 <kmc> by the bread-industrial complex
10:50:19 <FunctorSalad_> or at least I only know the word through it ;)
10:50:22 <mux> kmc: http://www.funnyjunk.com/showcomment/4342348/ (obligatory motivational poster)
10:50:48 <newsham> "if the real jesus christ were to stand up today he'd be gunned down cold by the CIA" -the the
10:50:53 <newsham> (ok, way off topic now)
10:51:04 <kmc> haha mux
10:51:08 <oab> kmc: well he sent himself down to kill himself to save you from himself, pretty nicely done of jesus. You find me a troll that kills himself to save you from trolling
10:51:08 <Heffalump> applicative: if only that reasonableness actually lasted..
10:51:34 <kmc> oab, i know trolls who troll themselves to save me from trolling
10:51:36 <kmc> it's called 4chan
10:52:17 <oab> afaik 4chan has a haskell board now
10:52:44 <gwern> oab: it's had it for a while. /prog/ is so weird
10:52:53 <oab> of course after witnessing that place once I am not going to go back there
10:52:56 <applicative> Heffalump, yes I know.  I don't know what's up with him.  It can't be fame and notoriety quite.
10:53:34 <gwern> I did like their collective fic about a dystopian future in which sussman and abelson do battle, assisted by the Haskell nomads
10:53:44 <soupdragon> gwern lin?
10:53:44 <gwern> s
10:53:45 <soupdragon> link
10:53:47 <FunctorSalad_> oab: doesn't seem like it
10:53:55 <FunctorSalad_> at least not on the board index
10:54:17 <gwern> soupdragon: http://dis.4chan.org/read/prog/1202856797
10:54:25 <FunctorSalad_> (I like how one can filter for "adult boards only", lol)
10:54:33 <soupdragon> thank you
10:54:45 <gwern> 'Discipline was tight in the Haskell nomads. If a given expression did not behave deterministically he had to be wrapped up in the shroud of the monad and returned to the homelands after a ritualistic suicide - they couldn't afford to have monads in their tight-knit battle group. It jjust wasn't acceptable.'
10:55:08 <FunctorSalad_> :D
10:55:17 <c_wraith> someone's moving fast:  http://dis.4chan.org/read/prog/1275328394/1-40
10:55:25 <gwern> '
10:55:26 <gwern> "Well, well Sussman, I see you've maintained some of your skills from 6.001. You may have dodged that expression, but how long do you think you can hold out against my Python3000?"
10:55:30 <gwern> "THREE THOUSAND?!" the Sussman shouted in response, cackling. "You never understood, Hal; you couldn't defeat me with PythonOver9000."'
10:55:40 <kmc> this is just like YOSPOS but worse
10:56:02 <monochrom> http://dis.4chan.org/read/prog/<random number>
10:56:10 <oab> fantastic
10:56:23 <oab> truly a art
10:56:25 <soupdragon> "The Sussman stoked his wizard beard as he hummed the tune to SICP... today would be a well-balanced parenthesis." XD
10:56:45 <c_wraith> those numbers aren't random.  They're seconds from the epoch
10:57:13 <FunctorSalad_> any moderately long number starting with '12' is.
10:57:42 <monochrom> They're random seconds from the epoch.
10:57:48 <newsham> just an IO Nomad
10:58:18 <monoidal> are (*>) and (>>) the same for monads?
10:58:22 <monochrom> Customers arrive at random times to submit posts. This is a random Markov stochastic process.
10:58:37 <FunctorSalad_> monoidal: should be...
10:58:41 <c_wraith> monoidal, assuming the applicative and monad instances are consistent with each other
10:58:47 <gwern> sloppy coding. seconds are too coarse-grained - easy to get collisions
10:58:52 <FunctorSalad_> at least if (<*>) = ap
10:58:53 <kmc> sounds like a Poisson process
10:59:18 <monochrom> M/M/1
10:59:36 <wli> monochrom: Markovian queue?
10:59:41 <monochrom> Yeah!
10:59:43 <FunctorSalad_> gwern: I think on *4CHAN* they'd have noticed by now if the seconds had the task of uniquifying
11:00:01 <gwern> they've noticed and no doubt find it hilarious
11:00:30 <FunctorSalad_> do same-second threads seriously clobber the old one?
11:00:38 <gwern> no way to know but to try
11:03:50 <Baughn> Is there a common name for functions like maybe, (bool :: a -> a -> Bool -> a) or either?
11:04:07 <soupdragon> yes
11:04:11 <FunctorSalad_> catamorphism
11:04:15 <FunctorSalad_> ^^
11:04:21 <Baughn> Ah.
11:04:38 * Baughn is writing a ClassyPrelude package, and obviously needed bool. :P
11:04:44 <Saizan> depends on how you want to generalize to recursive types, really
11:05:02 <FunctorSalad_> yes, you can do one-level or infinite
11:05:11 <kmc> catamorphism implies something like a fold
11:05:11 <FunctorSalad_> catas are infinite
11:05:26 <Baughn> So would it be reasonable to say that bool is a catamorphism on Bool?
11:05:30 <tao_> http://blog.chromium.org/2010/05/desktop-notifications-now-available-to.html that's pretty interesting
11:05:33 <kmc> Baughn, yes, but a little silly imo
11:05:34 <ksf> oh I'm such an idiot
11:05:36 <Cale> Baughn: yes
11:05:46 <Cale> I don't think it's particularly silly.
11:05:48 <ksf> there I am, trying to fit into iteratees what's already covered by liftM
11:05:49 <mux> I think I've heard people just say folds. is that correct?
11:05:50 <Baughn> kmc: It's not how I was actually planning to document it, no
11:05:51 <monochrom> catas are not all infinite
11:06:24 <mauke> they totally are
11:06:25 <dolio> If you consider Bool to be the fixed point of FX = 1 + 1, it's completely precise. :)
11:06:30 <Cale> Catamorphisms (or folds) replace each of the data constructors throughout a value of an algebraic type with an arbitrary selection of other functions and values of appropriate types.
11:07:00 <FunctorSalad_> monochrom: no, I just meant that with recursive types they fold all the levels; a different generalization of `bool' and `either' would be to just eliminate the top constructor
11:07:02 <sinelaw> i like the idea of catamorphims. gives fold a non-adhocish appeal
11:07:30 <ologNation> It would be wonderful if someone had a way of multiplying polynomials in haskell.
11:07:44 <FunctorSalad_> @let caseList k1 k2 lst = case lst of { [] -> k1; (l0:l1) -> k2 l0 l1; }
11:07:45 <lambdabot>  Defined.
11:07:47 <FunctorSalad_> @ty caseList
11:07:48 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
11:07:59 <FunctorSalad_> this would be the "one-level" variant for lists
11:08:08 <monochrom> This is why you should not hit the enter key prematurely.
11:08:40 <ologNation> I checked HaskellForMaths.  There seem to be some tools there for Groebner Bases and multivariable polynomials.  It seems like way more complexity than I need, but maybe I could specialize.
11:08:59 <FunctorSalad_> monochrom: I did?
11:09:31 <monochrom> I think so. You could have joined two lines into one.
11:09:42 <soupdragon> ologNation ask in #haskell-math
11:09:53 <soupdragon> there was some code for that
11:11:13 <dolio> @type \k1 k2 lst -> case lst of { [] -> k1 ; (l0:l1) -> k2 l0 l1 }
11:11:14 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
11:11:32 <ologNation> soupdragon, Thanks!  Never heard of it.
11:11:38 * ologNation is joining hakell-math
11:15:39 <alip> what does =<< mean? i've been reading the real world haskell book but i think i've missed that :)
11:16:02 <dolio> f =<< m = m >>= f
11:16:16 <alip> ah :) just as i expected
11:16:20 <alip> dolio: thanks!
11:18:38 <tao_> http://lh6.ggpht.com/_pKjeJkDgORA/S_hKqHTpbHI/AAAAAAAAAR0/3QWd75GkUH0/s640/CIMG7631.JPG the sing says "new functional tee"
11:18:56 <monochrom> > reverse "f =<< m = m >>= f"
11:18:57 <lambdabot>   "f =>> m = m <<= f"
11:18:58 * hackagebot rangemin 2.2.2 - Linear range-min algorithms.  http://hackage.haskell.org/package/rangemin-2.2.2 (LouisWasserman)
11:19:04 <monochrom> oh oops :)
11:20:29 <tao_> is using eval function in haskell bad?
11:20:44 <Botje> monochrom: it didn't reverse the f!
11:21:23 <mauke> :t \f m -> liftM snd $ mfix (\(x, _) -> f x >>= \y -> m >>= \x -> return (x, y))
11:21:24 <lambdabot> forall (m :: * -> *) a a1. (MonadFix m) => (a1 -> m a) -> m a1 -> m a
11:21:41 <mauke> tao_: what eval function?
11:22:07 <monochrom> there is no eval. so using eval is not bad.
11:22:43 <c_wraith> speaking of eval, I should see if I can figure out what hint didn't like about the way I was using it.
11:24:18 <tao_> system.haskell.eval?
11:24:38 <c_wraith> I think I really need a variant of hint that's cabal-aware, and as such uses the same rules as cabal to determine what packages are available
11:27:48 <jlouis> improvementation! http://jlouis.github.com/combinatorrent/ :)
11:29:20 <Cale> jlouis: sparklines are so tiny that wouldn't it be better to embed them directly into the page?
11:29:59 * Baughn obstinately refuses to define map = fmap
11:30:17 <sinelaw> Baughn, why?
11:30:29 <Baughn> sinelaw: fmap is one more letter, and people have /expectations/ for map.
11:30:44 <Baughn> Anyway, having the concretely-typed specialization helps pick out type errors.
11:30:57 <Baughn> (And if the extra letter is an issue, use <$>)
11:31:16 <FunctorSalad_> I just meant infinity in the way that fix f x = sup_{n->infinity} f^n(x), btw
11:31:17 <sinelaw> not convinced
11:31:21 <Cale> Baughn: Why not lmap for list-specific map?
11:31:26 <sioraiocht> what is unsafe about unsafeInterleaveST?
11:31:28 <Cale> and map for the more general one?
11:31:29 <Baughn> I am, however, making ($) infixl.
11:31:33 <FunctorSalad_> where the thing may well become constant in some cases
11:31:44 <Baughn> Cale: Well, I'm used to.. hmm...
11:31:50 <Baughn> Cale: Okay, I'll try it.
11:31:53 <tao_> jlouis:
11:31:53 <tao_> http://jlouis.github.com/combinatorrent/img/CPUNet.png
11:32:02 <tao_> could you make pngs bigger please?
11:32:14 <monochrom> You're supposed to pay the abstraction tax by typing one more letter, not one fewer. :)
11:32:37 <Baughn> Cale: ..I can't do it. Everything in me refuses.
11:32:45 <tao_> also, followed
11:33:13 <FunctorSalad_> who uses `map' anyway? :(
11:33:26 <FunctorSalad_> it leads to breakage if you decide to import Map later
11:34:02 <monochrom> I use map.
11:34:04 <Baughn> FunctorSalad_: You're supposed to use fmap on Map
11:34:11 <Baughn> And I'm just not exporting map at all.
11:34:17 <Baughn> I'm happy with this compromise.
11:34:29 <FunctorSalad_> Baughn: I meant forward-compatibility... I use `fmap' for lists since I might want to import Map or Set later
11:34:39 <jlouis> Cale: change to a modern browser, like chrome
11:34:39 <Baughn> Point.
11:34:56 <jlouis> tao_: I probably should, yes
11:35:46 <Baughn> Hm. Wasn't there a typeclass equivalent for filter?
11:36:01 <FunctorSalad_> @ty mfilter
11:36:02 <lambdabot> Not in scope: `mfilter'
11:36:59 <MacMagnus> how do i get output from textbased unix-programs "into" Haskell?
11:37:19 <FunctorSalad_> @let milter p = foldr (\a bs -> if p a then a `mplus` bs else bs) mzero
11:37:20 <lambdabot>  Defined.
11:37:22 <FunctorSalad_> @ty milter
11:37:23 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (m a -> Bool) -> [m a] -> m a
11:37:34 <FunctorSalad_> hmm...
11:38:25 <c_wraith> I really don't think that's what you want as a general abstraction
11:38:37 <FunctorSalad_> no, not really
11:39:21 <c_wraith> filterM has the amazing distinction of being about the only *M function that really requires a monad constraint to work.  Most of the *M functions would be just fine with only applicative.
11:39:29 <FunctorSalad_> @let milter2 p = foldMap (\a -> if p a then return a else mempty)
11:39:30 <lambdabot>  <local>:3:12: Not in scope: `foldMap'
11:39:42 <FunctorSalad_> @let milter2 p = Data.Foldable.foldMap (\a -> if p a then return a else mempty)
11:39:43 <Baughn> Was there a symbolic name for (m)concat?
11:39:43 <lambdabot>  Defined.
11:39:51 <FunctorSalad_> @ty milter2
11:39:52 <lambdabot> forall a (t :: * -> *) (m :: * -> *). (Monad m, Monoid (m a), Data.Foldable.Foldable t) => (a -> Bool) -> t a -> m a
11:40:05 <norm2782> hmm.. so ghc HEAD does not cause my memory to be flooded anymore when compiling language-python :D .. now compilation takes forever with 100% CPU though. does anyone have any experience with how long the language-python compilation _should_ take?
11:40:18 <FunctorSalad_> @ty filterM
11:40:19 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:40:31 <c_wraith> there are rumors (<>) = mappend, at some point in the future.  I don't know about a symbolic name for (m)concat, though, is it's strictly a prefix function
11:40:42 <c_wraith> err, I should say it only takes one arg.
11:41:39 <jlouis> tao_: now with sligtly larger PNGs. It is a shame fireflux can't embed svg's directly in img tags (chrome can of course)
11:41:57 <FunctorSalad_> filterM doesn't abstract from [] at all though :p
11:42:16 <c_wraith> Nope.  neither does mconcat, which I was just thinking about.
11:42:31 <MacMagnus> i would like to get my (local) IP address in Haskell :) im reading "real world haskell", bu the approach are very different than for languages like Java...
11:42:53 <jlouis> tao_: I am happy CPU/Net broke 0.06 cpu seconds per transferred megabyte
11:43:08 <FunctorSalad_> @let milter3 p mx = do { x <- mx; guard (p x); return x }
11:43:09 <lambdabot>  Defined.
11:43:14 <FunctorSalad_> @ty milter3
11:43:15 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => (b -> Bool) -> m b -> m b
11:43:31 <FunctorSalad_> this? :|
11:43:55 <FunctorSalad_> > milter3 isLower "aaaAAAaa"
11:43:56 <illissius> norm2782: classic tradeoff -- cache for cpu time
11:43:56 <lambdabot>   "aaaaa"
11:44:02 <illissius> in this case, both are infinite
11:45:16 <norm2782> hah, so basically I can wait all I want and get nowhere?
11:45:39 <FunctorSalad_> > milter3 isLower (Node 'a' [Node 'A' [], Node 'a' []])
11:45:40 <lambdabot>   No instance for (Control.Monad.MonadPlus Data.Tree.Tree)
11:45:40 <lambdabot>    arising from a ...
11:46:02 <FunctorSalad_> don't we have leaf-data-trees?
11:46:09 <illissius> norm2782: I really have no idea, I just thought it was funny
11:46:15 <FunctorSalad_> these are MonadPluses...
11:46:38 <chrisdone> can you help me make a list of standard functions that work on concrete types?
11:46:39 <chrisdone> e.g. toUpper,toLower :: Char -> Char
11:46:47 <triyo> Is there a way to uninstall cabal package?
11:46:48 <norm2782> illissius: hehe, still, I think you're on to something ;)
11:47:03 <chrisdone> triyo: not automatically
11:47:25 <FunctorSalad_> grep -v '\b[A-Z]' typeDump
11:47:28 <FunctorSalad_> ;)
11:47:49 <illissius> hmm, is it possible to make a MonadPlus instance for (a -> m b) with (<=<) as mplus? (would it be useful for anything?)
11:48:09 <FunctorSalad_> grep -v '\b[a-z_]' typeDump -- sorry, this way I mean
11:48:17 <Saizan> triyo: you've to "ghc-pkg unregister" them and, if you want, rm the files manually
11:48:48 <triyo> I've installed HDBC.PostgreSQL however I installed different arch and ver of PostgreSQL server and now I get this error "can't load .so/.DLL for: pq (dlopen(libpq.dylib, 9): image not found)"
11:49:03 <ville> Can I only partially apply function's parameters in left-to-right order or are there some sort of placeholders?
11:49:04 <Saizan> illissius: the types won't match
11:49:07 <FunctorSalad_> shouldn't it be possible to determine the set of installed files even with existing data....
11:49:10 <ddarius> chrisdone: Use hoogle?  There aren't too many that work solely on completely concrete types.
11:49:13 <triyo> So I though perhaps reinstalling the driver may fix the problem, or am I wrong?
11:49:23 <FunctorSalad_> at least if you don't have a weird ~/.cabal/config
11:49:33 <ddarius> ville: Use lambdas if you need a different order.
11:49:39 <BONUS> illissius: you can do it with a -> m a though
11:49:42 <FunctorSalad_> the standard config only lets packages install files into predictable directories
11:50:04 <Baughn> "cabal: There is no installed version of base" <-- ..help
11:50:05 <chrisdone> ddarius: i'm looking on hayoo. hoogle's down. and yeah, it's surprising how few work on concrete types
11:50:22 <FunctorSalad_> how'd you use hayoo to do it?
11:50:33 <FunctorSalad_> (does it support negation?)
11:50:35 <chrisdone> i'm just putting in concrete types and hoping
11:50:35 <ddarius> illissius: That doesn't type and it wouldn't satisfy the laws.
11:50:43 <illissius> Saizan: ah; I tried it and failed, but thought that could just be my own incompetence
11:50:53 <FunctorSalad_> ah. I'd search for everything but type vars..
11:50:54 <Saizan> triyo: yeah, so just unregister the hdbc-sqlite (if that's the name) and install it
11:50:58 <FunctorSalad_> (if possible)
11:51:09 <illissius> BONUS: and would it be useful for anything? :D
11:51:22 <chrisdone> ahh, words/unwords! that's a good one
11:51:37 <FunctorSalad_> but that may yield monomorphic functions which don't exactly work on *standard* types
11:51:45 <ddarius> chrisdone: The easiest thing would be to just look through the standard libraries in the Report.
11:51:55 <dcoutts> Baughn: you wern't trying to install base were you?
11:52:12 <chrisdone> ddarius: good idea
11:52:13 <ddarius> chrisdone: Depending on your notion of "standard," most bytestring functions are monomorphic.
11:52:13 <BONUS> illissius: sure, it comes in handy
11:52:24 <chrisdone> it seems haskell.org is down
11:52:34 <sinelaw> yes it does
11:52:36 <chrisdone> ddarius: sure, my notion of "standard" is lax enough to include ByteString
11:52:36 <Baughn> dcoutts: Hm, no, I accidentally put build-depends in the wrong section.
11:52:49 <FunctorSalad_> chrisdone: maybe there's an easy way to get ghc to dump a type list?
11:52:58 <FunctorSalad_> (the ghc api, that is)
11:53:07 <FunctorSalad_> then you'd just have to write a Type->Bool predicate
11:53:37 <FunctorSalad_> at least I know ghci knows about everything even without importing ;)
11:54:05 <dcoutts> Baughn: oh, odd, from the code, it looks like you can only get that error from top level constraints specified on the command line, not deps in the .cabal file
11:54:38 <Baughn> dcoutts: I'd stuck "build-depends: base" in the global section instead of the library one, where it failed to work.
11:54:43 <Baughn> Would be nice if it'd tell me somehow.
11:55:02 <FunctorSalad_> (hmm, or maybe not...? I seem to remember my ghci knew all the qualified names by default, once)
11:55:39 <FunctorSalad_> or apparently it still does, they're just not autocompleted unless :module'd
11:56:25 <chrisdone> FunctorSalad_: hmm. i'll have a gander
11:57:02 <FunctorSalad_> chrisdone: I thought it has some global name-lookup thing :) one could just map (or mapKeys or whatever) over that
11:57:10 <FunctorSalad_> and ask for the type of each?
11:57:13 <dcoutts> Baughn: but that just gets ignored, at least I think it's ignored, I don't understand how you got that error message
11:57:32 <Baughn> dcoutts: It's the error message you get if you fail to build-depend on anything
11:57:47 <dcoutts> Baughn: oooh
11:58:14 <Baughn> Now instead I'm getting parse errors in my module export list, darn it. :/
11:58:20 <dcoutts> Baughn: right, because internally there's a constraint on base, and that cannot be satisfied if the thing doesn't depend on base. You're quite right.
11:58:52 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25842#a25842 <-- Since I apparently can't think right now, what's the problem with my syntax here?
11:59:01 <Baughn> (Also feel free to make suggestions on the contents)
11:59:41 <Baughn> Oh. It's that I'm looking at the wrong file when trying to solve it. That'd do it.
12:05:16 <chrisdone> Baughn: you were looking at the right file. the file was just being wrong to mess with you
12:05:42 <rntz> what's the option to ghc that turns on warnings for pattern matches that don't cover all possible patterns?
12:06:07 <c_wraith> I just use -Wall for that.
12:06:33 <chrisdone> rntz: -f-warn-incomplete-patterns
12:06:42 <chrisdone> or -fwarn-incomplete-patterns
12:06:56 <rntz> ah, thank you
12:07:00 <chrisdone> @google ghc warnings and sanity
12:07:14 * chrisdone prods lambdabot
12:07:15 <lambdabot> Plugin `search' failed with: thread killed
12:07:25 <chrisdone> :<
12:08:32 <chrisdone> The type of toUpper reads: Char -> Char
12:08:33 <chrisdone> It's pretty easy; a -> b means function from a to b. So
12:08:33 <chrisdone> toUpper :: Char -> Char
12:08:35 <chrisdone> means: for a given character (Char value) a, toUpper a has type Char.
12:08:35 <chrisdone> do you think my way of saying it here makes sense?
12:08:55 <chrisdone> i'm trying to avoid imperative language like "toUpper takes a value and does stuff with it and 'returns' something"
12:09:02 <Baughn> @src ($!)
12:09:02 <lambdabot> f $! x = x `seq` f x
12:09:57 <chrisdone>  @src seq
12:09:57 <chrisdone>  seq x y = const x $! y
12:11:01 <chrisdone> (actually that would be y $! const x, thinking about it...)
12:11:18 <Jedai> chrisdone: Sure, seems a good way to say it from a functional pov
12:11:25 <chrisdone> cool
12:17:31 <triyo> Hmm, how does HDBC toSql function work? It takes an 'any' type but "toSql 1" doesn't work. (Sorry for th noobie question :))
12:22:23 <Saizan> triyo: what's the error?
12:22:32 <chrisdone> triyo: I can explain it through questions. what is the type of toSql?
12:22:34 <Saizan> triyo: i suspect you might need a type annotation
12:22:43 <chrisdone> nevermind
12:23:08 <Baughn> triyo: "42" can be one of several types, toSql can take several types 42 could be, the program can't run unless it can pick /one/ type
12:23:16 * hackagebot ClassyPrelude 0.1 - Prelude replacement using classes instead of concrete types where reasonable  http://hackage.haskell.org/package/ClassyPrelude-0.1 (SveinOveAas)
12:23:41 * Baughn really wishes the haddock homepage hadn't been down right now
12:24:30 <triyo> Silly me, thanks guys. I add type annotation and it worked.
12:29:24 <chrisdone> haha, it's people like Svein Ove Aas ruining tutorial writer's lives
12:29:34 <Baughn> Whut?
12:29:49 <kmc> classy :)
12:29:53 <Baughn> chrisdone: That's me, if you didn't know. :P
12:29:55 <kmc> preflex, seen RyanT4000
12:29:55 <preflex>  Sorry, I haven't seen RyanT4000
12:30:03 <kmc> whoops, meant to PM that ;P
12:30:08 <chrisdone> Baughn: i didn't!
12:30:16 <kmc> also didn't even get the nick right ;P
12:30:20 * kmc sucks
12:30:20 <chrisdone> should've known with a norwegian name like that
12:30:44 <sinelaw> chrisdone heh but why is he ruining ....?
12:31:14 <chrisdone> just joking, what with me 15 minutes ago asking for help finding even a few concrete types from the prelude to use in a tutorial
12:31:47 <chrisdone> baughn comes along and says "i removed them all! fweuhaha!"
12:32:09 <Baughn> I did /not/.
12:32:13 <Baughn> You still have.. Int.
12:32:15 <chrisdone> the concrete types are gone. please try anothe rcastle
12:32:17 <sinelaw> Bool
12:32:22 <Baughn> Char.
12:32:30 <sinelaw> []
12:32:38 <sinelaw> well, no.
12:32:40 <chrisdone> i meant values with concrete types
12:32:43 <Baughn> I removed lists
12:32:45 <sinelaw> True
12:32:46 <jlouis> chrisdone: hehe
12:32:51 <sinelaw> @type True
12:32:52 <lambdabot> Bool
12:33:09 <sinelaw> lambdabot> FiniteGroup[2]
12:33:24 <BoToM> shell pls
12:33:41 <soupdragon> BoToM, do you know what haskell is
12:34:40 <chrisdone> BoToM: never private message me ever again
12:35:02 <BoToM> i need free shell
12:35:10 <sinelaw> run bash
12:35:21 <soupdragon> BoToM, haskell
12:36:12 <kmc> BoToM, i'm doing a survey, how did you find this chat room?
12:36:18 <Baughn> chrisdone: Besides, the lack of concrete types isn't even the biggest issue.
12:36:25 <Baughn> chrisdone: I also made $ and $! left-associative.
12:36:45 <danharaj_> Are you accidentally the entire prelude.
12:36:55 <Baughn> Not "accidentally", no
12:36:56 <sinelaw> parse error
12:37:26 <kmc> BoToM, do you PM everyone who talks to you?
12:37:35 <danharaj_> actually, sinelaw, that sentence parses, it just doesn't have the meaning you expected.
12:37:37 <danharaj_> :p
12:37:55 <kmc> shell pls
12:38:05 <chrisdone> oh god it's like the borg
12:38:11 <chrisdone> gui is futile
12:38:18 <sinelaw> hell pls
12:38:29 <sinelaw> MUHAUHAUHA</end>
12:38:37 <kmc> the end of the end?
12:38:39 <chrisdone> Baughn: not saying i don't approve
12:38:39 <kmc> @quote ubuntu.freebsd
12:38:39 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
12:38:49 <chrisdone> lol
12:38:57 <sinelaw> wha
12:39:01 <danharaj_> Wait, what is Baughn exactly doing?
12:39:02 <chrisdone> that's surely markov generated
12:39:11 <sinelaw> @quote psychobot
12:39:11 <lambdabot> psychobot says: let's eat grandma vs let's eat grandma aka interfacing with a guard
12:39:13 <kmc> chrisdone, i had a convo with the guy
12:39:18 <kmc> weird thing is, he actually had a Haskell question
12:39:20 <Baughn> danharaj_: http://hackage.haskell.org/package/ClassyPrelude-0.1 <-- Oh, I wrote this.
12:40:04 <kmc> @quote unhelps
12:40:04 <lambdabot> NIXDAEMON-COOL says: unhelps you are large
12:40:29 <stulli> Is there something like the Google Web Toolkit in Haskell?
12:40:46 <sinelaw> stulli i wish there was
12:40:50 <sinelaw> i'm forced to use GWT now
12:40:58 <sinelaw> kmc really what about
12:41:02 <sinelaw> and what does "shell pls" means
12:41:04 <sinelaw> *mean
12:41:05 <kmc> i don't remember
12:41:11 <kmc> it probably means "give me a shell account"
12:41:26 <sinelaw> borg have funny language
12:41:27 <stulli> sinelaw: Yeah, thats my situation aswell. Too bad.
12:41:44 <sinelaw> java is horrid
12:41:52 <soupdragon> I need a free shell i can't hack
12:41:57 <soupdragon> ;D
12:42:03 <sinelaw> pls
12:42:04 <kmc> there are web frameworks for Haskell... what do you need that GWT has that they don't have?
12:42:08 <kmc> generation of client-side code?
12:42:11 <fryguybob> byorgey: If you are still around I have a fix for the scaling part of the problem, ellipses and beziers still have an issue though.
12:42:16 <sinelaw> kmc, that's my case, yes
12:42:26 <kmc> i heard rumor of a long-ago project which compiled Haskell to JavaScript
12:42:31 <sinelaw> correct
12:42:38 <kmc> or possibly a JS interpreter for YHC's bytecode
12:42:39 <sinelaw> expeiremental, disbanded
12:42:54 <sinelaw> the real deal would be an llvm javascript backend
12:42:58 <stulli> kmc: yes, basically its a javascript desktop application
12:42:58 <Baughn> I remember that.. at the time I was but a newbie
12:43:09 <stulli> *it's
12:43:15 <byorgey> fryguybob: I think I figured out the problem with scaling too -- is your fix to delete the multiplication by k in Basics?
12:43:17 <sinelaw> OR using the AwesomePrelude to generate javascript
12:43:20 <Baughn> My, how time flies
12:43:40 <sinelaw> linearly
12:43:48 <Baughn> sinelaw: AwesomePrelude?
12:43:49 <BONUS> lol
12:43:53 <danharaj_> Baughn: you really took an axe to it didn't you? :p
12:43:58 <fryguybob> byorgey: I'll paste my version
12:44:14 <Baughn> danharaj_: It's what I do.
12:44:18 <sinelaw> Baughn yip
12:44:20 <chrisdone> hmmm
12:44:21 <byorgey> fryguybob: unfortunately the problem with the bounding function transformation is more insidious. I know why it is wrong but I am not yet sure how to fix it.
12:44:27 <chrisdone> what's a good way to say (a,b) -> a
12:44:32 <sinelaw> @goog AwesomePrelude
12:44:32 <lambdabot> Maybe you meant: google googleit
12:44:33 <kmc> fst
12:44:36 <sinelaw> @google AwesomePrelude
12:44:37 <lambdabot> http://github.com/tomlokhorst/AwesomePrelude
12:44:37 <lambdabot> Title: tomlokhorst's AwesomePrelude at master - GitHub
12:44:45 <chrisdone> i mean, what's a good way to say fst :: (a,b) -> a
12:44:46 <sinelaw> @google AwesomePrelude video
12:44:47 <fryguybob> byorgey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25845#a25845
12:44:48 <lambdabot> http://tom.lokhorst.eu/2010/02/awesomeprelude-presentation-video
12:44:48 <lambdabot> Title: AwesomePrelude presentation (video) | Tom Lokhorst's blog
12:44:54 <sinelaw> that's the one
12:45:02 <danharaj_> This is a +Code Axe+ all Haskell code is of the highest quality. It menaces with spikes of abstraction. Engraved on the object is images of programmers and libraries. The programmers are striking down the libraries.
12:45:12 <Baughn> Why is that not on hackage?
12:45:25 <chrisdone> for all types a and b, the fst function is defined (a,b) -> a
12:45:28 <sinelaw> Baughn je ne ces't pa
12:45:34 <chrisdone> wording doesn't sound right
12:45:37 <sinelaw> and perhaps it is
12:46:16 <Baughn> danharaj_: Something I've been tempted to do to DF on occasion. :P
12:46:17 <chrisdone> the haskell report can probably help me out on language for this one
12:46:19 <sinelaw> chrisdone, fst maps any pair (a,b) to a. No matter what type 'a' and 'b' are.
12:46:40 <danharaj_> Baughn: I think we all get that urge when we look at C++ code.
12:47:27 <Baughn> danharaj: I don't think Toady's old code counts as C++.
12:47:40 <fryguybob> byorgey: The bounding function on ellipses?
12:47:56 <danharaj> Baughn: Was it some sort of pseudo-C in C++?
12:48:04 <Baughn> danharaj: Naturally.
12:48:11 <byorgey> fryguybob: no, I mean the Transformable instance for Diagrams.
12:48:24 <byorgey> fryguybob: I don't think your code is correct.  Then again neither is mine.
12:48:28 <sinelaw> btw chrisdone
12:48:30 <danharaj> Baughn: "C++ is a better C" ... :p . So how long will it take before you convert Toady to the glory of Haskell?
12:48:32 <sinelaw> did you see that robot?
12:49:01 <fryguybob> byorgey: :D
12:49:05 <Baughn> danharaj: The moment someone points me at an embeddable Haskell compiler, I'll do that. ^^;
12:49:13 <Baughn> danharaj: For the moment we're leaning towards Chibi-scheme.
12:49:21 <chrisdone> sinelaw: what robot?
12:49:32 <chrisdone> sinelaw: Data isn't a robot, he's an android
12:49:40 <sinelaw> the one i programmed with haskell
12:49:48 <soupdragon> whats the differencen
12:49:50 <sinelaw> and the opencv bindings i made
12:49:57 <byorgey> fryguybob: I'm starting to think that to do this properly requires some sort of automatic differentiation
12:50:05 <chrisdone> ohh i didn't see the robot
12:50:17 <chrisdone> link me bitch!
12:50:26 <sinelaw> chrisdone http://www.youtube.com/watch?v=2ZblWWxeLsY&feature=player_embedded
12:50:39 <fryguybob> byorgey: For the general case or for the scaling case specifically?
12:50:41 <kmc> embeddable how?
12:50:55 <rntz> hm. is haskell.org down?
12:50:56 <sinelaw> dunno youtube schtick
12:51:00 <Baughn> rntz: Yes
12:51:03 <byorgey> fryguybob: for the general case.  If all you do is scale, it's easy.
12:51:29 <chrisdone> sinelaw: bugger me that's awesome
12:51:45 <byorgey> fryguybob: the problem is transformations which are not isometries.
12:51:46 <fryguybob> byorgey: Yeah I'll think about it some.
12:52:24 <sinelaw> chrisdone code is nice, too
12:52:33 <sinelaw> no IO (except at lower level lib code)
12:52:58 <Baughn> Whose blog is well-typed.com?
12:53:01 <fryguybob> byorgey: So it's the translation that is the issue?
12:53:07 <Baughn> ..oh.
12:53:41 <byorgey> fryguybob: no, translations are ok too, it's things like non-uniform scaling (e.g. scale by 5x along the x axis and 2x along the y axis) and shears
12:53:47 <byorgey> fryguybob: things that don't preserve angles
12:54:02 <fryguybob> byorgey: Ah, ok.
12:54:23 <byorgey> fryguybob: I suspect there is also independently a problem with the bounding code for Bezier curves, although I'm not sure yet
12:54:43 <Makoryu> Sup folks
12:55:14 <sinelaw> nothin'
12:55:19 <sinelaw> byorgey what lib are you working on
12:55:29 <byorgey> sinelaw: diagrams
12:55:36 <Makoryu> I've been convinced by novice programmers that all the names we use for stuff in Haskell are too hard to learn (for example, the distinctions between Monad, Functor, Arrow et al, as opposed to just naming them all DataStructure)
12:55:50 <sinelaw> i have some bezier curve code if you need it
12:55:59 <sinelaw> byorgey ^^^ but it seems that you don't
12:56:00 <Makoryu> So I propose that from now on we refer to the compiler as a baker, a program as a recipe, and a binary executable as cake
12:56:10 <danharaj> Makoryu: You mean burritos.
12:56:25 <Niccus> which one's the ez-bake oven?
12:56:25 <sinelaw> danharaj those are monads
12:56:26 <chrisdone> Makoryu: i think you're onto something
12:56:27 * hackagebot directory-tree 0.1.2 - A simple directory-like tree datatype, with useful IO functions  http://hackage.haskell.org/package/directory-tree-0.1.2 (BrandonSimmons)
12:56:35 <kmc> i tend to call IO-actions "recipes"
12:56:40 <byorgey> sinelaw: what sort of code?
12:56:46 <kmc> and have been known to shout "the recipe is not the cake!" at people
12:56:53 <byorgey> sinelaw: there are probably still useful bits and pieces we don't have
12:57:31 <sinelaw> byorgey, calculating the samples of an n-order bezier curve (parametric evaluation) and also implementation in opengl
12:57:40 <Makoryu> I've already begun implementing this proposal, and tonight I will cater (upload) it to FlourMill (Hackage)
12:58:08 <sinelaw> you mean cooking the proposal
12:58:31 <byorgey> sinelaw: nice, I might actually be able to use some of that, but probably not right at the moment
12:58:52 <sinelaw> the code is short (and maybe slow): http://github.com/sinelaw/graphui/blob/master/src/Math/Bezier.hs
12:58:59 <sinelaw> uses two other libs from the same directory
12:59:43 <fryguybob> byorgey: On the bezier thing my guess is that the results from the quad formula are not checked to see if they are in the [0,1] range.
13:00:07 <byorgey> fryguybob: aha, that could be it!
13:00:15 <byorgey> let me check
13:00:20 <byorgey> sinelaw: thanks!
13:00:29 <sinelaw> byorgey the opengl stuff is in luqui's hackage library graphics-drawingcombinators: http://hackage.haskell.org/package/graphics-drawingcombinators-1.4.1
13:00:29 <fryguybob> byorgey: I've had that one bite me before.
13:01:13 <byorgey> sinelaw: yeah, the opengl stuff will be useful in implementing an opengl backend for diagrams
13:01:59 <sinelaw> byorgey i recommand that lib (graphics-drawingcombinators) for all 2d opengl stuff. it's *functional*!
13:02:07 <Makoryu> byorgey: Can't you just use GTK? （　°‿‿°）
13:02:07 <sinelaw> recommend, even.
13:02:31 <sinelaw> (and also cross platform, i believe)
13:03:25 <byorgey> sinelaw: awesome!  Perhaps we can simply adapt it as a diagrams backend for 2D opengl.
13:03:37 <sinelaw> that should be great
13:03:53 <sinelaw> and not too hard. i've used it for my visual graph editor
13:04:05 <sinelaw> (not a diagram contender, sadly)
13:07:09 <winxordie> sinelaw: thanks for the drawingcombinators link; it looks pretty cool
13:07:15 <dever> hey all, saw something online a couple of weeks ago about colored hunit output? would anywone have a link?
13:07:42 <akosch> does anyone has this file? http://projects.haskell.org/haskellmode-vim/vimfiles/haskellmode-20090430.vba
13:07:44 <sinelaw> winxordie it is quite cool. thanks to luqui for writing it
13:07:55 <akosch> haskell.org seems down again...
13:08:00 <sinelaw> indeed.
13:08:19 <sinelaw> why does it go down so often?
13:08:31 <byorgey> fryguybob: brilliant, that was indeed the problem with the Bezier bounds =)
13:08:35 <byorgey> I just pushed a fix
13:08:42 <fryguybob> byorgey: Excellent.
13:09:04 <dever> ???
13:09:16 <byorgey> fryguybob: now everything works except the ellipses --- which is exactly because they are created by scaling a circle non-uniformly
13:10:56 <sinelaw> hey edwardk
13:11:05 <sinelaw> are you familiar with adaptive filtering?
13:11:26 <fryguybob> byorgey:  I've implemented ellipses as scalings of circles before and whenever I did anything with the ellipse I mapped it back to the circle for simpler math.
13:13:03 <pastorn> @hoogle reverse
13:13:03 <lambdabot> Prelude reverse :: [a] -> [a]
13:13:03 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
13:13:04 <lambdabot> Data.List reverse :: [a] -> [a]
13:13:22 <pastorn> hmm... but the web service seems to be down
13:13:23 <byorgey> fryguybob: sure, and I think that's actually what Scott did when implementing them.  But this problem unfortunately isn't ellipse-specific.
13:16:11 <pastorn> i'm running ubuntu; when i did a manual install of the GHC binary blob, where did the documentation land?
13:16:23 <pastorn> (ubuntu 10.04)
13:16:55 <dancor> is there a tempfile lib
13:16:57 <EvanR> haha binary blob
13:16:59 <hydo> So... unsafePerformIO.  Up until now, my beautiful (to me) code has not been sullied by its presence.  Now I find myself in need of pure, unique, and non-predictable identifiers and I'm thinking of using it to get UUID values from system-uuid.  How bad is unsafePerformIO?  Should I rethink my approach (again)?
13:17:21 * EvanR checks the latest openbsd comic and theme song
13:17:41 <fryguybob> byorgey: Beziers look right now.
13:18:03 <EvanR> hydo: save the state of your UUID generator to disk and load it back up when you restart the program
13:18:10 <EvanR> see Reader
13:18:18 <EvanR> or State
13:18:37 <danderson> hydo: do 2 calls to the system-uuid library call return 2 different values?
13:18:41 <pastorn> EvanR: that's what it's called!
13:18:49 <dancor> the openbsd freedom bridge crack is suspiciously lambda-like
13:18:54 <danderson> if so, using unsafePerformIO may break horribly
13:18:57 <Cale> hydo: Why is it not okay just to generate UUIDs in IO code?
13:18:58 <meanburrito920> is heskell.org down?
13:19:03 <meanburrito920> I can't seem to get a connection
13:19:06 <monoidal> yes
13:19:22 <dancor> it's always effing down
13:19:26 <Cale> hydo: Oh, you're using them as part of some algorithm?
13:19:31 <meanburrito920> any word on when it'll be back up?
13:19:37 <dancor> great community except where it counts
13:19:51 <ddarius> Community is all about a website.
13:20:03 <Cale> dancor: I wouldn't say *always* down.
13:20:05 <hydo> Cale: no, in a... not sure what to call it... typeclass conversion?
13:20:06 <Cale> When was the last time?
13:20:24 <gwern> Cale: this is pretty much a weekly thing
13:20:28 <gwern> apache being down
13:20:29 <hydo> I want the converted values to remain pure.
13:20:31 <Cale> gwern: what?
13:20:34 <hydo> as much as I can, anyway.
13:20:40 <Cale> gwern: I don't remember it being down last week
13:20:44 <ddarius> gwern: Not -all- of haskell.org
13:20:50 <gwern> ddarius: why I said apache...
13:21:10 <Cale> meanburrito920: Well, I think the hosting is in the US, and it's a holiday there, so you'll probably have to wait until tomorrow.
13:21:16 <gwern> not always a big deal - I don't need apache when I have ssh and can darcs send that way. but for people without accounts?
13:21:20 <b0fh_ua> guys, does newtype is just a "marker" for a type? For instance, "newtype Parse a = Parse { runParse :: a -> Either String a }", Parse $ \a -> Right a is just a "tag" for function \a -> Right a ?
13:21:24 <gwern> it's annoyed more than one xmonader...
13:21:34 <ddarius> gwern: I'm talking about, say, haskell.org/ghc
13:22:07 <Makoryu> b0fh_ua: I've never been terribly clear on the difference between newtype and data.
13:22:10 <Cale> b0fh_ua: Yeah, newtype's job is just to define a new type whose values can be implemented the same way as an existing type, but which will be treated as a different type by the type system
13:22:29 <fryguybob> byorgey: Seems like if we look at what inv t does to v_perp we should be able to get it to work.
13:22:43 <hydo> "it's a holiday there, so you'll have to wait until ..." Hopefully no one is paying for this kind of hosting.
13:22:52 <gwern> hydo: galois donates it...
13:23:01 <hydo> ah, ok... that makes sense then.
13:23:03 <Cale> The semantics of newtype are such that the data constructor for a newtype can be boiled away by compilation.
13:23:06 * fryguybob thinks harder...
13:23:54 <dever> must ahve imagined that package so :)
13:23:57 <ddarius> The haskell.org domain is spread over different servers hosted by different entities.
13:24:15 <sinelaw> they need to get better hosting
13:24:19 <gwern> ddarius: thought it was just yale and galois?
13:24:24 <sinelaw> for the same price
13:24:29 <byorgey> fryguybob: hmm, interesting idea...
13:24:30 <Cale> If we have  newtype N = N Integer, and data D = D Integer, then  (case undefined of N x -> 0) will evaluate to 0, but (case undefined of D x -> 0) will evaluate to undefined.
13:24:35 <fryguybob> byorgey: I guess that only really has meaning in 2d though...
13:24:47 <b0fh_ua> Cale: okay, that's clear. But "Parse a = Parse { runParse :: a -> Either String a }", runParse takes instance of Parse as argument, and returns function "a -> Either String a" as defined in the instance?
13:24:52 <byorgey> fryguybob: oh, yeah, hrm...
13:25:08 <meanburrito920> Does haskell allow you to redefine functions in the Prelude, eg. define + as something else?
13:25:13 <jbapple> http://www.haskell.org/ghc/docs/latest/html/libraries/ is timing out for me
13:25:23 <Baughn> meanburrito920: Yes
13:25:25 <ddarius> meanburrito920: You can shadow it locally, but you can't change it for anyone else.
13:25:39 <fryguybob> byorgey: Everytime I do something in 3d I find my self needing to generate some "arbitrary" but orthogonal vectors to a given one.
13:25:41 <monoidal> you can import Prelude hiding (+)
13:25:43 <Cale> b0fh_ua: Yeah, that's notation for the type of that field, runParse, and you automatically get an extractor function for extracting the runParse field from a value of type Parse a
13:25:49 <Makoryu> meanburrito920: import Prelude hiding ((+)); (+) = fmap
13:26:03 <byorgey> fryguybob: heh
13:26:59 <ddarius> fryguybob: You can often avoid such things by using an appropriate framework, but it is also not hard to write a function that will produce an orthonormal frame given a vector.
13:27:01 <meanburrito920> Makoryu: do you have to specifically hide it in order to change it?
13:27:09 <Baughn> > traverse (\a -> [a,42]) [1,2,3]
13:27:10 <lambdabot>   Not in scope: `traverse'
13:27:31 <Makoryu> meanburrito920: Only if you want to change it at the top level
13:27:47 <b0fh_ua> Cale: so "runParse parseInt" if "parseInt :: Parse Int; parseInt = Parse $ \a -> Right a" will still give me the type "Int -> Either String Int"
13:27:58 <b0fh_ua> Cale: I'm not sure why can
13:28:13 <Makoryu> meanburrito920: If you shadow it (in "let" or "where", or by using it as a variable name) then it doesn't matter if it's imported, hidden, or defined at all
13:28:15 <b0fh_ua> Cale: I'm not sure why can't i write "parseInt a = Right a"
13:28:26 <JasonFelice> @hoogle foldM
13:28:27 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:28:27 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
13:28:27 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
13:28:28 <fryguybob> ddarius: Right, that's what I end up doing.
13:28:37 <b0fh_ua> it will still give me "Int -> Either String Int"
13:28:45 <Cale> b0fh_ua: Because that would mean parseInt :: t -> Either a t
13:28:54 <Cale> b0fh_ua: Right, which is not the type you want
13:28:56 <Makoryu> > let foo (+) (*) = (4 + 3, 4 * 3) in foo div mod
13:28:57 <lambdabot>   (1,1)
13:29:01 <Cale> You want parseInt :: Parse Int, right?
13:29:10 <Cale> So you need to apply the newtype's data constructor
13:29:13 <ddarius> fryguybob: You may want to look at geometric algebra if you haven't already.
13:29:20 <b0fh_ua> Cale: umm, but that's the same as Int -> Either String Int ?
13:29:31 <Cale> b0fh_ua: Right, that's the point of a newtype
13:29:45 <Cale> b0fh_ua: It defines a *new* type, which just happens to be isomorphic to an existing one
13:29:49 <b0fh_ua> or that's the purpose of newtype - not allow mixing such functions?
13:29:52 <b0fh_ua> oh
13:29:59 <b0fh_ua> damn, now everything is clear
13:30:02 <Cale> But the typechecker will treat the type as separate, even if the implementation is the same
13:30:02 <b0fh_ua> thanks :)
13:30:08 <Cale> no problem :)
13:30:29 <Makoryu> b0fh_ua: If you use the "type" keyword (like typedef in C) then all the instances of the old type still apply to the new one
13:30:37 <b0fh_ua> Cale: so I can create functions with similar *effective* types, which will be considered as of different types by compiler?
13:30:51 <Cale> yeah
13:30:57 <b0fh_ua> nice
13:31:15 <b0fh_ua> now I seem to understand that crazy State monad :)
13:31:20 <Cale> b0fh_ua: and use the newtype constructor and pattern matching to convert between
13:34:41 <heatsink> Who is the "Church" mentioned in the topic?
13:34:55 <winxordie> Alonzo Church?
13:35:04 <Zao> The dude with the numerals.
13:35:05 <ibt> no idea what's going on with haskell.org?
13:35:07 <heatsink> According to WP he died in 1995, so pobably not
13:35:17 <winxordie> hmm.
13:35:23 <ddarius> Zao: Yes, or even better, the dude that invented the lambda calculus.
13:35:35 <sinelaw> same dude, no?
13:35:40 <sinelaw> ;)
13:35:48 <sinelaw> they forgot Mr. Curry
13:36:03 <ibt> so much for robustness
13:36:28 <Zao> I blame you all for endlessly grinding Church numerals.
13:36:42 <kmc> yeah, so much for robustness of Apache and MediaWiki
13:36:59 <kmc> if only they used a Haskell webapp framework they'd never be down
13:37:01 <kmc> like hpaste.org
13:37:08 <sinelaw> hpaste goes down often
13:37:12 <kmc> ;)
13:37:15 <mike-burns> That's the joke.
13:37:33 <gwern> my understanding is apache's at fault, not mediawiki
13:37:34 <sinelaw> ah
13:37:48 <mike-burns> What's the issue?
13:37:58 <sinelaw> we need a mirror
13:38:01 <gwern> memory use.
13:38:04 <sinelaw> that updates once a day or so
13:38:06 <gwern> never heard any reason for it
13:38:15 <mike-burns> Is someone working on it?
13:38:32 <Silvah> haskell.org is down?
13:38:46 <mike-burns> Yeah, been down for a while.
13:39:12 <sinelaw> ping is up
13:39:19 <mike-burns> Apache is down.
13:39:24 <jbapple> If haskell.org worked, I could look up how -main-is works
13:39:26 <sinelaw> yah looks like it
13:39:52 <jbapple> Can anyone summarize -main-is for me?
13:40:00 <sinelaw> -main-is?
13:40:02 <jbapple> I can't get past linker errors or "not a flag" errors
13:40:09 <heatsink> jbapple: Provide an alternate name for the "main" function
13:40:15 <sinelaw> ah, you mean the ghc option
13:40:42 <jbapple> heatsink: I have a module Foo. When I compile with -main-is Foo, I still get linker errors
13:40:44 <Silvah> Poor novices. Poor me.
13:41:00 <heatsink> I haven't used it before, but I think it's something like --main-is=Foo.defaultMainFunction
13:41:23 <jbapple> oh, I forgot, you have to delete some binary files or else it will silently fail
13:43:40 <mike-burns> How do I convert an Int to a ByteString?
13:44:00 <sinelaw> @hoogle Int -> ByteString
13:44:00 <lambdabot> Data.ByteString.Internal unsafeCreate :: Int -> (Ptr Word8 -> IO ()) -> ByteString
13:44:00 <lambdabot> Data.ByteString replicate :: Int -> Word8 -> ByteString
13:44:00 <lambdabot> Data.ByteString.Char8 replicate :: Int -> Char -> ByteString
13:44:04 <Silvah> show it and then pack the result.
13:44:16 <mrd> show'n'pack
13:44:19 <mike-burns> Silvah: Ah, cool.
13:44:32 <kmc> mike-burns, it's not clear what that would mean
13:44:35 <kmc> ASCII decimal representation?
13:44:39 <kmc> little-endian byte representation?
13:45:18 <mike-burns> kmc: I want 1::Int to "1"::ByteString
13:45:27 <kmc> "how do I convert A to B" is no more specific than "how do I write a function of type A -> B"
13:45:33 <kmc> yeah
13:45:43 <kmc> that'd be (pack . show) as mrd said
13:45:46 <kmc> or Silvah
13:45:46 <mike-burns> kmc: And yet two people helped me get to the right answer.
13:45:56 <Silvah> So, unsafeCoerce will "work" too.
13:46:06 <kmc> mike-burns, yeah, they guessed correctly
13:46:22 <pastorn> cabal install generates documentation, right?
13:46:33 <dcoutts> if you enable docs, yes
13:46:43 <mike-burns> Anyway, I've been running into this issue all day and can't figure it out without haskell.org: Couldn't match expected type `GHC.Word.Word8' against inferred type `Char'
13:46:49 <pastorn> dcoutts: ehm... i don't think i have :(
13:46:53 <kmc> mike-burns, they're different types
13:46:53 <pastorn> hoogle is down :(
13:47:01 <kmc> mike-burns, Word8 is an 8-bit unsigned integer
13:47:07 <kmc> mike-burns, Char is a Unicode code-point
13:47:19 <kmc> which in general can take much more than 8 bits to represent
13:47:33 <mike-burns> kmc: (pack (show 1)) gives me this. What am I doing wrong?
13:47:34 <Baughn> > maxBound :: Char
13:47:35 <lambdabot>   '\1114111'
13:47:38 <kmc> you can use the ByteString.Char8 module
13:47:40 <Silvah> map (fromIntegral . fromEnum) will work if you're using only ASCII.
13:47:56 <kmc> which uses Char instead of Word8 in a slightly unsafe way
13:48:04 <kmc> basically it will work as long as your characters are all in ASCII
13:48:22 <mike-burns> Well that's certainly a solution, but what is the intended solution for Data.ByteString?
13:48:23 <Baughn> mike-burns: If you're dealing with ascii or latin-1, you can use BYteString.Char8.  If you're actually dealing with unicode, you need the bytestring-utf8 package.
13:48:27 <kmc> which digits should be, unless someone rigged your Show Int instance to use I Ching hexagrams or whatever
13:48:42 <Baughn> mike-burns: utf8-string package.
13:48:42 <kmc> mike-burns, ByteString is not a module for manipulating text
13:48:46 <kmc> it's a module for manipulating bytes
13:49:23 <kmc> there are a few text-oriented packages
13:49:45 <mike-burns> If I'm using an API (in this case, Snap) that forces me to use ByteString, is the idea that I work with Strings in my code then pack it into a ByteString when I call any API functions?
13:50:13 <Baughn> mike-burns: What are you actually doing with the strings?
13:50:18 <kmc> text, utf8-string
13:50:51 <mike-burns> Baughn: something like: writeBS $ "This is post #" `append` (postId post)
13:50:53 <c_wraith> You can use bytestring directly, if you know what you're doing.
13:51:02 <kmc> mike-burns, that's not in general the idea behind using ByteString-API libraries
13:51:13 <kmc> it would kill much of the efficiency of ByteString
13:51:19 <kmc> however it might be simplest or best for whatever you're doing
13:51:28 <mike-burns> What am I supposed to do, in this situation?
13:51:30 <applicative> in Snap, they use {-#OverloadedStrings#-}
13:51:58 <mike-burns> Yeah, I've copied the {-#OverloadedStrings#-} into my modules too.
13:52:06 <applicative> mike-burns, I see
13:52:10 <kmc> if you're trying to use "show" on an Int
13:52:14 <kmc> then also packing it seems reasonable
13:52:36 <kmc> i'm sure someone could write a tiny bit more efficient Int-shower that uses ByteString directly
13:52:39 <kmc> but it hardly seems worth it
13:52:40 <applicative> that reads your "blah" ++ x  as appending bytestrings
13:52:40 <Baughn> mike-burns: In which case "This is post #" could be a bytestring, and you should use the bytestring append functions
13:53:00 <applicative> but I see, now you want to use show.  Is there a bs.show?
13:53:30 <kmc> bsShow = pack . map (fromIntegral . fromEnum) . show
13:53:42 <kmc> works as long as your Show instance uses only ASCII
13:53:52 <temoto> Does readChan removes data from both channels after dupChan ?
13:53:55 <mike-burns> There is a separate library for BS show, but I couldn't figure it out.
13:54:04 <kmc> maybe we can help you figure it out?
13:54:12 <applicative> does prelude Show only use ascii for standard things?
13:54:35 <kmc> > "☭"
13:54:36 <lambdabot>   "\9773"
13:54:59 <temoto> holy
13:55:05 <applicative> > show "?"
13:55:06 <lambdabot>   "\"?\""
13:55:10 <tedm> Anybody know what's happened to www.haskell.org? I haven't heard anything about downtime on the mailing lists...
13:55:29 <kmc> temoto, no
13:55:40 <mike-burns> Is there a Twitter or anything that can be used to keep us updated on haskell.org's status?
13:55:48 <temoto> kmc, no to chans or to holy?
13:55:53 <tedm> ...it seems to have been down since at least last night
13:55:54 <kmc> chans
13:55:57 <meanburrito920> would anyone mind explaining to me what the difference between 'type' and 'newtype' is?
13:56:05 <kmc> meanburrito920, sure
13:56:06 <temoto> kmc, thank you very much.
13:56:20 <kmc> meanburrito920, "newtype" is much more like "data" than it is like "type"
13:56:24 <applicative> mike-burns, I see your problem, I wonder how the handle things like this elsewhere in Snap.
13:56:27 <kmc> do you understand the difference between "data" and "type"?
13:56:48 <pastorn> @hoogle String -> Request
13:56:48 <lambdabot> Did you mean: String -> Request a /count=20
13:56:49 <lambdabot> Prelude error :: [Char] -> a
13:56:49 <lambdabot> Debug.Trace trace :: String -> a -> a
13:56:49 <meanburrito920> kmc: well, type just creates a synonym, right?
13:56:52 <kmc> correct
13:57:07 <meanburrito920> kmc: and data creates a new type with a constructor
13:57:10 <kmc> correct
13:57:11 <pastorn> what? lambdabot suggests?
13:57:16 <kmc> and newtype is like data in this respect
13:57:20 <mike-burns> Well I gotta run but thanks for the suggestions and advice everyone.
13:57:24 <kmc> you can think of newtype as a more restricted version of data
13:57:29 <meanburrito920> kmc: so newtype is like type, but with constructors?
13:57:43 <Silvah> Constructor, one.
13:57:49 <danharaj> newtype is data that guarantees that the type you specify is isomorphic to another type.
13:57:52 <kmc> i think that's a roundabout way to think about it
13:58:02 <kmc> because not having constructors is sort of the defining property of a synonym
13:58:12 <kmc> "newtype" is a variant of "data" which only works when you have one constructor with one field
13:58:18 <kmc> it is more efficient than "data"
13:58:29 <aavogt> it behaves differently
13:58:33 <kmc> and has slightly different semantics with respect to strictness and undefined values
13:58:43 <danharaj> It does? >_<
13:58:49 <Baughn> meanburrito920: If you have "newtype Foo a = Foo a" and "data Bar a = Bar a", then Foo undefined = undefined, while Bar undefined is a Bar that contains undefined..
13:58:49 <meanburrito920> so newtype only can have one constructor?
13:58:57 <kmc> correct meanburrito920
13:59:01 <Silvah> Aye.
13:59:01 <kmc> it's worth pointing out at this point
13:59:17 <kmc> and only one field
13:59:20 <kmc> it's worth pointing out at this point
13:59:20 <Baughn> A newtype exists only in the imagination of the compiler, but in memory is represented the same as the type it's wrapping
13:59:25 <kmc> that people sometimes want to do newtype T = T (A,B) to get around the one-field restriction
13:59:29 <heatsink> danharaj: a newtype is bottom iff the value inside is bottom.
13:59:32 <aavogt> kmc: the differences aren't slight... it's just that they don't change the behavior of many programs
13:59:34 <kmc> but this is no more efficient than data T = T A B
13:59:42 <soupdragon> yeah newtype is weird
13:59:45 <kmc> unless you need to go between T and (A,B) specifically
13:59:50 <soupdragon> I don't really get newtype
14:00:17 <heatsink> I think it's easiest to think of newtype as "same data representation, interepreted as a different type".
14:00:19 <soupdragon> I mean why bother having it at all?
14:00:27 <kmc> meanburrito920, the rationale behind all this is that, at compile time, you want a strong separation of types (which you don't get with "type"), but at runtime, you don't want to waste time and memory on extra wrapping
14:00:28 <Baughn> soupdragon: For generalized newtype deriving
14:00:29 <Zao> soupdragon: You can define new instances for them, can't you?
14:00:32 <soupdragon> it seems like a microotpimization
14:01:06 <kmc> it's not a valid optimization for the compiler to turn "data" into "newtype" unless it can prove strictness everywhere
14:01:11 <c_wraith> soupdragon, The most common use I run into for newtypes is wrapping strings for implementing a typeclass that you also want to implement for [a].
14:01:37 * Baughn would happily use overlapping instances for thatone
14:01:41 <kmc> perhaps today "newtype" would be defined as a hidden optimization on "data" which has one ctor with one strict field
14:01:54 <aavogt> soupdragon: newtypes + unsafecoerce
14:02:10 <danharaj> I hate how the non-strictness of Haskell makes semantics more complicated.
14:02:13 <danharaj> Fuck you Bottom.
14:02:20 <c_wraith> I *really* hate that String is [Char].  It ruins creating instances in a sane way.
14:02:37 <FunctorSalad_> danharaj: any turing-complete one will have bottom :p
14:02:39 <newsham> make your own String
14:02:42 <kmc> c_wraith, then get your users to use a different type
14:02:45 <FunctorSalad_> not just nonstrict ones
14:02:49 <monoidal> and overload strings
14:02:55 <kmc> do you hate that the name "String" is already taken?
14:02:58 <danharaj> FunctorSalad: Still should pretend it isn't there. Assume programs are correct.
14:03:00 <Silvah> I hate Haskell as a whole, but who cares?
14:03:06 <kmc> heh Silvah
14:03:22 <FunctorSalad_> hmm data Foo = Foo {-# UNPACK #-} Int
14:03:26 <FunctorSalad_> is not newtype? :(
14:03:34 <danharaj> FunctorSalad: We should need laziness annotations, not the other way around!
14:03:48 <newsham> danharaj: perhaps you're using the wrong language
14:03:55 <Silvah> Well, I hate Haskell less than other languages.
14:04:00 <JasonFelice> Anyone want to peer review some code for my project? Looking for n00bisms and things which could be more concies. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25848#a25848
14:04:03 <Saizan> yeah, it appears you'd like scala :)
14:04:09 <JasonFelice> er, concise.
14:04:17 <danharaj> I'm here for the community. :p
14:04:27 <danharaj> I have been slowly courting agda.
14:04:35 <aavogt> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25849#a25849
14:04:35 <newsham> there are languages where strict is the default
14:05:18 <kmc> aavogt, yes
14:05:18 <heatsink> newsham: Remarkable! How do they get anything done? :p
14:05:27 <newsham> heatsink: who knows
14:05:27 <danharaj> newsham: the advantages of Haskell outweigh the things I dislike about it.
14:05:36 <JasonFelice> Are there any generally accepted Haskell code layout rules?
14:05:36 <aavogt> strict data isn't the same as newtype
14:05:41 <kmc> FunctorSalad_, data Foo = Foo {-# UNPACK #-} !Int
14:05:42 <kmc> perhaps
14:06:03 <FunctorSalad_> unpack doesn't imply strict?
14:06:10 <kmc> not sure
14:06:16 <kmc> it would be odd for a pragma to alter semantics
14:06:16 <dons> it does, yep.
14:06:22 <dons> since it strips away the constructor
14:06:50 <dons> i'm not sure UNPACK works on non-strict fields though
14:06:50 <kmc> does it strip away the Foo ctor or the Int ctor?
14:06:56 <dons> Int
14:06:58 <FunctorSalad_> ah. the alternative would be that is just refuses to do anything
14:06:59 <dons> !Int -> Int#
14:06:59 <chrisdone> newbies of haskell! please try my Types chapter on http://tryhaskell.org/#22
14:07:02 <kmc> i.e. is that data Foo = Foo Int#
14:07:07 <dons> right
14:07:16 <applicative> JasonFelice, I appended the verdict of hlint to your paste.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25848#a25850
14:07:21 <FunctorSalad_> hmm
14:07:21 <pastorn> i have a list of URLs that i want to fetch
14:07:23 <kmc> but that's still not newtype
14:07:25 <Silvah> -funbox-strict-fields
14:07:33 <FunctorSalad_> funbox \o/
14:07:35 <kmc> because the Foo box is present at runtime
14:07:37 <EvanR> funbox
14:07:38 <kmc> and plays an important role
14:07:57 <sinelaw> fun-in-a-box
14:08:07 <sinelaw> (citing The Cat in the Hat)
14:08:10 <pastorn> can i use a compination of mapM and par to fetch all in sequence?
14:08:23 <kmc> fetch all what?
14:08:29 <FunctorSalad_> yes, all of them
14:08:36 <kmc> oh did not see above
14:08:44 <kmc> pastorn, "par" does parallel evaluation, not concurrent execution
14:08:55 <kmc> you can evaluate the IO actions to normal form in parallel, but this is of little to no use
14:08:57 <pastorn> pseq?
14:09:04 <kmc> pseq does sequential evaluation
14:09:11 <c_wraith> you need forkIO
14:09:13 <FunctorSalad_> but more seriously, "all in sequence"?
14:09:20 <Silvah> lol
14:09:23 <FunctorSalad_> that doesn't need anything special now
14:09:27 <pastorn> ok, so forkIO + MVars then...
14:09:37 <Silvah> I've read "fuckIO", o.O
14:09:38 <c_wraith> pastorn: assuming you mean "in parallel", yes
14:09:45 <pastorn> c_wraith: yes...
14:10:18 <kmc> pastorn, the "threads" package provides a way to spawn threads and later ask for the result
14:10:20 <pastorn> also: what library should i use for parsing HTML? i'm guessing all i want is just regex matching...
14:10:27 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25851#a25851 is my super simple version
14:10:27 <voker57> tagsoup
14:10:40 <FunctorSalad_> there appeared a cute little package wrapping that use of forkIO/MVars recently... 'async'
14:11:03 <aavogt> JasonFelice: also, you have some redundant  (return ()) in  storeScan, if savePngFile is what I think it is
14:11:06 <FunctorSalad_> Async a = IO a executed in another thread...
14:11:07 <FunctorSalad_> or so
14:11:16 <kmc> yeah
14:11:36 <pastorn> kmc: looks cool
14:11:43 <pastorn> but why line 10?   return (readMVar v)
14:11:48 <kmc> i love higher-order imperative functional programming
14:11:51 <pastorn> why not just readMVar v ?
14:11:57 <kmc> pastorn, because we don't want to read it now
14:12:01 <kmc> we return the action which would read it
14:12:11 <kmc> that's why the return type is IO (IO (Result a))
14:12:23 <kmc> (spawnTry x) spawns a thread which runs action "x", and returns an action
14:12:32 <kmc> when you execute that action, you block on the thread and get its result
14:12:33 <Silvah> Two-star programming, eh?
14:13:12 <kmc> in the simple case like this, there's no need to make a data type representing a thread
14:13:39 <chrisdone> life is awesome!
14:13:40 <kmc> i've seen and used this style elsewhere: hiding concurrency behind the scenes using closure
14:13:44 * chrisdone runs round high-fiving everyone
14:13:59 <Silvah> chrisdone: it's disputable.
14:14:09 <kmc> if you have a Chan, you might consider return (writeChan c) instead of return c
14:14:38 <jbapple> I'm getting an ambiguous module name because of overlapping packages in GHCi. How do I specify which package I want to be preferred?
14:14:45 <FunctorSalad_> "two-star"? ^^
14:14:47 * hackagebot list-extras 0.4.0 - Common not-so-common functions for lists  http://hackage.haskell.org/package/list-extras-0.4.0 (WrenThornton)
14:14:49 <jbapple> I tried -package X, but that didn't work
14:15:02 <kmc> jbapple, package-qualified imports in a file
14:15:02 <jbapple> and the ghc user guide is 404 at the moment
14:15:10 <FunctorSalad_> jbapple: ghc-pkg hide bla
14:15:11 <aavogt> jbapple: -hide-package Y?
14:15:12 <kmc> don't remember the LANGUAGE name :/
14:15:17 <chrisdone> jbapple: my solution has been to use :set -ignore-package
14:15:19 <Silvah> FunctorSalad_, do you know what three-star programming is?
14:15:22 <FunctorSalad_> kmc: PackageImports
14:15:29 <chrisdone> but yeah, package qualified imports is better
14:15:50 <FunctorSalad_> Silvah: no, but two-star sounded pretty bad ;)
14:15:51 <jbapple> kmc: I don't understand the grammar there
14:15:57 <jbapple> is the verb "imports"?
14:16:05 <temoto> kmc, your spawnTry is understandable, but still IO (IO (Result a)) looks scary :)
14:16:06 <kmc> jbapple, there is no verb
14:16:07 <jbapple> and package-qualified is the subject?
14:16:10 <kmc> it's a noun phrase
14:16:17 <aavogt>  import "mtl" Control.Monad.List
14:16:24 <jbapple> ah, ok
14:16:26 <kmc> temoto at first maybe
14:16:26 <aavogt> maybe it needs a version there
14:16:29 <pastorn> @hoogle httpget
14:16:29 <lambdabot> No results found
14:16:30 <jbapple> I'll try that
14:16:31 <kmc> temoto, "spawn" has the nicer type
14:16:39 <temoto> yeah
14:16:47 <kmc> and "try . spawn" should do roughly the same thing as "spawnTry"
14:16:47 <Silvah> @google three star programming
14:16:48 <lambdabot> http://www.c2.com/cgi/wiki?ThreeStarProgramming
14:16:49 <lambdabot> Title: Three Star Programming
14:16:51 <FunctorSalad_> actually I wouldn't have noticed the deferred-read subtlety without the type...
14:17:23 <kmc> FunctorSalad_, the typechecker would notice it for you ;)
14:17:31 <FunctorSalad_> sure
14:17:54 <danharaj> That wiki is like the tvtropes of programming
14:17:59 <kmc> btw i like how the threading definition of "join" and the monadic definition of "join" coincide here :)
14:18:37 <FunctorSalad_> Silvah: why is it not a compliment?
14:18:44 <FunctorSalad_> (three stars)
14:18:57 <Silvah> IO (IO a) just looks like two-star programming for me.
14:18:59 <kuitang> Why is there a syntax error on the | on line 5? http://haskell.pastebin.com/aSSwaauJ
14:19:25 <FunctorSalad_> Silvah: every boxed type has a star already kinda o_o
14:19:37 <FunctorSalad_> but referential transparency and all that.
14:19:43 <FunctorSalad_> s/[.]/.../
14:19:46 <heatsink> kuitang: the "where" ends the entire function.  You can't put another |guard after it.
14:20:00 <kmc> FunctorSalad_, because c2 users are afraid of any abstraction that doesn't have ten pages of AbstractFactoryManager boilerplate wrapping it, like oven mitts on a factory robot
14:20:03 <FunctorSalad_> [.] is awesome if you're already 17 levels of escaping or so deep
14:20:10 <FunctorSalad_> and don't want another \
14:20:13 <FunctorSalad_> ;)
14:20:27 <pastorn> gawd... i need a function that fetches HTML for me
14:20:28 <kuitang> heatsink: thanks
14:20:31 <FunctorSalad_> kmc: :)
14:20:34 <pastorn> :: String/URL -> IO STring
14:20:36 <kmc> Silvah, not sure what you're getting at
14:20:41 <kmc> it is double indirection, yes
14:20:41 <pastorn> which module is this in?
14:20:44 <Twey> Silvah: Nothing wrong with that pattern
14:20:44 <kmc> it's an action that returns another action
14:21:00 <aavogt> Silvah: if you have the warning for unused do-binds most errors with that pattern get caught (or warned)
14:21:01 <Silvah> Exactly!
14:21:05 <Twey> It's just taking advantage of Haskell's first-class imperativeness.  ☺
14:21:16 <Silvah> It's a double indirection!
14:21:17 <pastorn> i've started looking it HTTP.Browser etc. but it's all very weird...
14:21:22 <Twey> In fact, it's instrumental in the implementation of things like iteratees.
14:21:23 <kmc> yeah
14:21:23 <FunctorSalad_> pastorn: download-curl
14:21:23 <kmc> that's what the problem calls for
14:21:30 <pastorn> FunctorSalad_: thank you :D
14:21:32 <FunctorSalad_> or just `download', or `curl'
14:21:36 <FunctorSalad_> maybe they all exist
14:21:42 <Twey> It's useful for callbacks, too.
14:21:44 <JasonFelice> applicative: Wow, I guess I've changed a lot since my last hlint run.
14:21:59 <FunctorSalad_> one is supposed to simplify the other, but iirc they both have the trivial case o_o
14:22:23 <Silvah> Well, I'm AFAIR four-star programmer ;)
14:22:33 <aavogt> @type Mu IO
14:22:34 <lambdabot> Not in scope: data constructor `Mu'
14:22:35 <lambdabot> Not in scope: data constructor `IO'
14:22:38 <kmc> i used the type (Mu Chan) in a real program
14:22:42 <aavogt> :)
14:22:43 <kmc> does that make me an omega-star programmer?
14:23:01 <pastorn> FunctorSalad_: <3 <3 <3
14:23:24 <Twey> kmc: Haha, awesome.
14:23:30 <Twey> kmc: What did you use that for‽
14:23:36 <aavogt> kmc: where's the actual data in those chans?
14:23:36 <Saizan> i's say omega+1 at least
14:23:41 <FunctorSalad_> (indeed, all three exist ;))
14:23:51 <FunctorSalad_> apparently `download' is pure haskell?
14:23:52 <kmc> aavogt, there is none :)
14:23:57 <Silvah> kmc: you were using omega indirections in one place? If so, then yes ;)
14:24:12 <kmc> Silvah, i'm not sure what that'd mean
14:24:14 <FunctorSalad_> and `download-curl' wraps `curl', but `curl' still has the friendly `curlGet'
14:24:33 <aavogt> kmc: I'm interested in how that's useful too
14:24:39 <kmc> it was in an implementation of the pi calculus
14:24:54 <kmc> in which you have channels and you send other channels through them
14:24:57 <danharaj> sounds delicious
14:25:05 <kmc> like in Primer, where they put a time machine inside a time machine
14:26:13 <kmc> this is apparently good enough to get all computation
14:26:39 <Axman6> and be realy fucking confusing
14:26:53 <kmc> just like how in lambda calculus, you only have functions and they only take and return other functions
14:26:56 <FunctorSalad_> newtype MC = MC (Chan MC)?
14:26:57 <kmc> yeah
14:26:59 <Silvah> :>
14:27:27 <FunctorSalad_> does that hold any information?
14:27:43 <FunctorSalad_> hmm the lengths?
14:27:53 <kmc> the lengths aren't really observable
14:27:58 <kmc> they'd be nondeterministic
14:28:12 <kmc> it lets you build arbitrarily complicated webs of information flow
14:28:13 <applicative> JasonFelice, I wasn't sure I believed some of hlint's advice about inline type signatures; I'll have to study more
14:28:20 <pastorn> hehe
14:28:23 <pastorn> "Downloading download-0.3..."
14:28:29 <kmc> it's not useful to think of it as a data structure
14:28:30 <Twey> Hehe.
14:28:35 <kmc> it's more like a scheduler
14:29:41 <pastorn> dons: consider this a bug report ;)
14:29:43 <pastorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25854#a25854
14:30:18 <kmc> anyway in the pi calculus you basically get newChan, readChan, writeChan, return (), and forkIO
14:30:37 <aavogt> pastorn: cabal install download --constraint="tagsoup < 0.8" ?
14:30:48 <jlouis> kmc: yeah and then you have hte lambda calc with chans
14:30:52 <jlouis> its mighty fun
14:31:30 <Philonous> The order of top level definitions should be irrelevant, shouldn't it?
14:31:30 <kmc> oh you also get "forever"
14:31:41 <kmc> Philonous, yeah
14:32:01 <aavogt> Philonous: do you use template-haskell?
14:32:09 <Philonous> kmc: Because I just had to move a top level binding before another, otherwise ghci kept complaining
14:32:16 <deech> Hi all, I have a question regarding getting at values inside datatypes. If I have a datatype: data Something = A String | B String, and I want the String, can I write a function that matches on (_ s) and returns s?
14:32:18 <Philonous> aavogt: It's enabled, but unused, yes
14:32:29 <pastorn> aavogt: thakn you <3 <3 <3
14:32:31 <kmc> deech, no
14:32:34 <aavogt> perhaps it isn't really unused then
14:32:52 <kmc> deech, you can do data Something = A { getS :: String} | B { getS :: String}
14:32:59 <kmc> then getS :: Something -> String
14:33:05 <kmc> it's kinda ugly
14:33:06 <Philonous> aavogt: I just killed the LANGUAGE line and it compiles now
14:33:10 <Twey> kmc: Still using Western-1, I see
14:33:16 <FunctorSalad_> deech: or syb
14:33:23 <kmc> because if you *don't* declare that field name for some other constructor, it'll barf at runtime if it encounters that one
14:33:29 <kmc> Twey, do you know how to configure XChat otherwise?
14:33:39 <aavogt> Philonous: maybe that's worth a ghc bug, if you can narrow it down?
14:33:48 <Twey> kmc: http://xchat.org/encoding/
14:33:57 <kmc> :O
14:34:01 <FunctorSalad_> but you'd lose some static safety too...
14:34:08 <Twey> kmc: First result off Google
14:34:25 <kmc> Twey, so I should use utf8?
14:34:29 <Twey> Yeah
14:34:36 <kmc> Twey, sorry, i didn't google after i couldn't find it in the settings dialog
14:34:41 <deech> kmc: yeah, I was just trying to write idiomatic code. So I guess handling every data constructor is waht is expected.
14:34:58 <deech> FunctorSalad_: I'll just handle each case :)
14:35:10 <kmc> »»» Better?
14:35:12 <Philonous> aavogt: I will try
14:35:14 <Twey> kmc: Much.  ☺
14:35:16 <aavogt> Philonous: I can't imagine TH affecting type inference if you don't have any inline splices
14:35:20 <kmc> :D
14:35:36 <FunctorSalad_> unsafeCoerce . (\[x] -> x) . listify
14:35:39 <FunctorSalad_> should do it...
14:35:40 <FunctorSalad_> ;)
14:35:53 <FunctorSalad_> hmm unless listify is multilevel
14:35:58 <FunctorSalad_> @ty listify
14:35:59 <lambdabot> forall r a. (Data a, Typeable r) => (r -> Bool) -> a -> [r]
14:36:01 <aavogt> listify gets everything
14:36:05 <chrisdone> Twey: what up?
14:36:06 <FunctorSalad_> @ty gmapq
14:36:07 <lambdabot> Not in scope: `gmapq'
14:36:10 <FunctorSalad_> @ty gmapQ
14:36:11 <lambdabot> forall u a. (Data a) => (forall d. (Data d) => d -> u) -> a -> [u]
14:36:14 <aavogt> yeah, that one's better, FunctorSalad_
14:36:16 <Twey> chrisdone: Stuff
14:36:23 <chrisdone> Twey: you at uni.?
14:36:31 <Twey> chrisdone: Nah, college again
14:36:38 <EvanR> im trying to understand the fundamental reason why pattern matching and algebraic data types makes everything so amazing
14:36:39 <chrisdone> computer science?
14:36:43 <FunctorSalad_> gmapQ (\x -> unsafeCoerce x `asTypeOf` "")
14:36:47 <FunctorSalad_> ;)
14:37:02 <aavogt> FunctorSalad_: the unsafeCoerce should be unnecessary
14:37:02 <EvanR> and if theres something better or different and equal to 'power'
14:37:03 <soupdragon> EvanR, me too
14:37:08 <aavogt> in fact it might ruin things
14:37:14 <EvanR> equal in power
14:37:23 <kmc> EvanR, have you read about the pattern calculus?
14:37:27 <EvanR> no
14:37:29 <aavogt> since you can't infer what the type variable of the  (Data d) is
14:37:32 <chrisdone> imagine writing a lambda calculus interpeter without pattern matching, it would be impossible!!1
14:37:33 <FunctorSalad_> aavogt: you won't get a String otherwise
14:37:45 <kmc> hehe chrisdone
14:37:53 <gwern> I think what's cool about pattern-matching & ADTs is that they let you define more primitives
14:38:04 <chrisdone> Twey: studying Computer Séance?
14:38:07 <kmc> Sturgeon's Law says it is not only possible, it is inevitable
14:38:09 <FunctorSalad_> aavogt: my function is supposed to be a 'trust me, compiler' for deech's particular type
14:38:13 <gwern> you need a boolean for your dialethic logic? no problem, just define a new ADT besides Bool
14:38:14 <aavogt> > gmapQ (\x -> x :: String) ["I don't think so"]
14:38:14 <Twey> chrisdone: Among other things
14:38:15 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:38:15 <lambdabot>         against inferred ty...
14:38:24 <deech> Is it considered bad style to have a datatype that takes arguments that are only used by one of its data constructors?
14:38:26 <kmc> wait, not that one
14:38:29 <FunctorSalad_> of course it'll die horribly for anything with nonstring children
14:38:30 <kmc> greenspun's rule
14:38:45 <gwern> deech: like data Maybe a = Nothing | Just a?
14:39:03 <EvanR> @src []
14:39:04 <lambdabot> data [] a = [] | a : [a]
14:39:05 <Twey> deech: No, of course not
14:39:09 * gwern couldn't say
14:39:23 <FunctorSalad_> aavogt: your selector function must convert *arbitrary* Datas to u
14:39:35 <FunctorSalad_> no way to do it without cast/unsafeCoerce
14:39:39 <aavogt> > gmapQ (\x -> mkQ Nothing (Just . (`asTypeOf` ""))) ["abc"]
14:39:39 <lambdabot>   Overlapping instances for GHC.Show.Show
14:39:40 <lambdabot>                              (a -> ...
14:39:42 <deech> gwern: Yup, like that. Now that you've shown me Maybe, I feel better.
14:39:46 <deech> Twey: thanks!
14:39:56 <aavogt> :t gmapQ (\x -> mkQ Nothing (Just . (`asTypeOf` "")))
14:39:57 <lambdabot> forall a a1. (Data a1, Typeable a) => a1 -> [a -> Maybe [Char]]
14:40:04 <kmc> deech, if you have a type variable that's not used in *any* of the constructors, you might want to think about it harder
14:40:04 <aavogt> :t gmapQ (mkQ Nothing (Just . (`asTypeOf` "")))
14:40:05 <lambdabot> forall a. (Data a) => a -> [Maybe [Char]]
14:40:07 <kmc> but there are use cases for that too
14:40:12 <FunctorSalad_> mkQ does a cast or coerce :p
14:40:12 <Twey> chrisdone: Hehe, ‘séance’… about accurate: AQA, my exam board, teaches cargo-cult computing.
14:40:18 <aavogt> true
14:40:27 <aavogt> but there's a check in there for you :)
14:40:33 <chrisdone> hehe
14:40:54 <FunctorSalad_> but he wanted a single string as a result...
14:41:08 <FunctorSalad_> that won't be safe for arbitrary ADTs no matter how ;)
14:41:24 <FunctorSalad_> might as well coerce for the particular type
14:41:28 <aavogt> :t listToMaybe <=< gmapQ (\x -> mkQ Nothing (Just . (`asTypeOf` "")))
14:41:29 <lambdabot>     Couldn't match expected type `Maybe [c]'
14:41:29 <lambdabot>            against inferred type `[a -> Maybe [Char]]'
14:41:30 <lambdabot>     In the second argument of `(<=<)', namely
14:41:51 <aavogt> :t join . listToMaybe . gmapQ (\x -> mkQ Nothing (Just . (`asTypeOf` "")))
14:41:52 <lambdabot>     Couldn't match expected type `Maybe (Maybe [Char])'
14:41:53 <lambdabot>            against inferred type `a -> Maybe [Char]'
14:41:53 <lambdabot>     In the expression: mkQ Nothing (Just . (`asTypeOf` ""))
14:42:03 <aavogt> :t join . listToMaybe . gmapQ (mkQ Nothing (Just . (`asTypeOf` "")))
14:42:04 <lambdabot> forall a. (Data a) => a -> Maybe [Char]
14:42:15 <aavogt> :t listToMaybe <=< gmapQ (mkQ Nothing (Just . (`asTypeOf` "")))
14:42:16 <lambdabot>     Couldn't match expected type `Maybe [c]'
14:42:16 <lambdabot>            against inferred type `[Maybe [Char]]'
14:42:16 <lambdabot>     In the second argument of `(<=<)', namely
14:42:25 <aavogt> hmm
14:42:32 <aavogt> one of those is right
14:42:56 <aavogt> FunctorSalad_: I suppose so. Perhaps the better choice is to write the data differently
14:43:24 <kmc> SYB has some pretty serious machinery inside
14:43:25 <FunctorSalad_> by the way, you can just pass an existential AnyData to gmapQ as a "universal" selector
14:43:31 <FunctorSalad_> to avoid the mkQ stuff
14:43:32 <aavogt> so    data Tag = A | B;  type T = (Tag,String)
14:43:43 <kmc> as though all the scrapped boilerplate has been bolted together to make some kind of steam-powered death robot
14:43:46 <FunctorSalad_> then you have the cast at the point where you extract the String from the AnyData
14:43:59 <Twey> Hahaha
14:44:10 <kmc> :t AnyData
14:44:11 <lambdabot> Not in scope: data constructor `AnyData'
14:44:13 <FunctorSalad_> @remember <kmc> SYB has some pretty serious machinery inside <kmc> as though all the scrapped boilerplate has been bolted together to make some kind of steam-powered death robot
14:44:13 <lambdabot> It is forever etched in my memory.
14:44:15 <Twey> kmc: That's exactly the image I got when I first saw it!
14:44:20 <kmc> :D Twey
14:44:25 <aavogt> FunctorSalad_: what's the advantage of choosing the type you're looking for later?
14:44:26 <FunctorSalad_> indeed, along those lines
14:45:03 <FunctorSalad_> kmc: data AnyData where AnyData :: Data a => a -> AnyData -- is what I had in mind
14:45:23 <kmc> aha
14:45:24 <aavogt> I suppose it gets rid of that indirection with Maybe
14:45:27 <kmc> but it's not standard? :/
14:45:41 <aavogt> AnyClassName is pretty standard
14:45:49 <FunctorSalad_> aavogt: uh just to decrease the type variable mess or to store the results in a container for whatever reason
14:45:54 <FunctorSalad_> not much point really
14:46:08 <kmc> FunctorSalad_, so you could use this to indiscriminately flatten a datastructure?
14:46:19 <kmc> and get back a big list of mystery boxes?
14:46:20 <FunctorSalad_> yes
14:46:37 <aavogt> @type everything
14:46:38 <lambdabot> forall r a. (Data a) => (r -> r -> r) -> GenericQ r -> a -> r
14:46:43 <FunctorSalad_> that's what gmapQ does, just that the type variable is put back into its box ;)
14:46:43 <kmc> these: http://cache.g4tv.com/ImageDb3/174542_S/Mario-Box-question-mark.gif
14:46:48 <FunctorSalad_> (with the Any, that is)
14:46:56 <FunctorSalad_> it's the `forall d' in gmapQ...
14:47:59 <aavogt> @type everything (++) (\x k -> [k x :: forall a. Data a => (a -> r) -> r])
14:48:00 <lambdabot> Not in scope: type variable `r'
14:48:00 <lambdabot> Not in scope: type variable `r'
14:48:51 <FunctorSalad_> kmc: gmapQ will flatten one level, `everything' all of them
14:49:02 <aavogt> hmm, how to bring that `r' into scope...
14:49:37 <aavogt> @type everything (++) (\x k -> [k x :: (forall a. Data a => a -> r) -> r])
14:49:38 <lambdabot>     Cannot match a monotype with `a
14:49:38 <lambdabot>                                   -> (forall a1. (Data a1) => a1 -> r)
14:49:39 <lambdabot>                                   -> r'
14:49:42 <aavogt> :(
14:50:10 <FunctorSalad_> aavogt: with a pattern sig
14:50:27 <FunctorSalad_> it's the *only* way to bring the variable inside an existential into scope
14:50:49 <FunctorSalad_> or of a universal in a negative position, I suppose
14:51:00 <meanburrito920> is there a method that returns whether or x is a member of the list y?
14:51:12 <aavogt> elem
14:51:17 <danharaj> :t elem
14:51:18 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:51:45 <meanburrito920> ah, awesome. thanks
14:51:51 <FunctorSalad_> @type everything (++) (\(x::r) k -> [k x :: forall a. Data a => (a -> r) -> r])
14:51:52 <lambdabot>     Inferred type is less polymorphic than expected
14:51:52 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
14:51:52 <lambdabot>         k :: r -> (a -> r) -> r (bound at <interactive>:1:25)
14:52:38 <FunctorSalad_> @info GenericQ
14:52:38 <lambdabot> GenericQ
14:52:39 <aavogt> it's curious that the same function has different names for Data.Set and Data.Map
14:53:10 <aavogt> FunctorSalad_: the  x :: a
14:53:11 <FunctorSalad_> type GenericQ r = (Data a) => a -> r
14:53:12 <BMeph> @hoogle something
14:53:12 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
14:54:32 <FunctorSalad_> @type everything (++) (\(x::aaa) -> \(k :: forall r. (aaa -> r) -> r) -> k x)
14:54:32 <lambdabot>     Cannot match a monotype with `forall r. (aaa -> r) -> r'
14:54:33 <lambdabot>       Expected type: t
14:54:33 <lambdabot>       Inferred type: forall r. (aaa -> r) -> r
14:55:07 <FunctorSalad_> hmm is this impredicate types? thought they weren't dead yet
14:55:23 <FunctorSalad_> aavogt: the name shouldn't matter
14:56:00 <FunctorSalad_> but it seems to have accepted it now apart from wanting a monotype for the `r' in GenericQ
14:57:10 <FunctorSalad_> @type everything (++) (\(x::aaa) -> \(k :: forall r. (aaa -> r) -> r) -> k x    :: forall aaa. Data a => (forall r. (aaa -> r) -> r))
14:57:11 <lambdabot> Not in scope: type variable `a'
14:57:17 <FunctorSalad_> @type everything (++) (\(x::aaa) -> \(k :: forall r. (aaa -> r) -> r) -> k x    :: forall aaa. Data aaa => (forall r. (aaa -> r) -> r))
14:57:18 <lambdabot>     Cannot match a monotype with `forall r. (aaa -> r) -> r'
14:57:18 <lambdabot>       Expected type: t
14:57:18 <lambdabot>       Inferred type: forall r. (aaa -> r) -> r
14:57:46 <FunctorSalad_> aha! the type of k must be different
14:57:56 <FunctorSalad_> 'aaa' mustn't appear
14:58:36 <FunctorSalad_> @type everything (++) (\(x::aaa) -> \(k :: forall b r. Data b => (b -> r) -> r) -> k x    )
14:58:37 <lambdabot>     Cannot match a monotype with `forall b r.
14:58:37 <lambdabot>                                   (Data b) =>
14:58:37 <lambdabot>                                   (b -> r) -> r'
14:59:07 <FunctorSalad_> @type everything (++) (\(x::aaa) -> \(k :: forall b r. Data b => (b -> r) -> r) -> k x    :: GenericQ ((forall b r. Data b => (b -> r) -> r))
14:59:08 <lambdabot> parse error (possibly incorrect indentation)
14:59:30 <FunctorSalad_> @type everything (++) (\(x::aaa) -> \(k :: forall b r. Data b => (b -> r) -> r) -> k x    :: GenericQ (forall b r. Data b => (b -> r) -> r))
14:59:31 <lambdabot>     Cannot match a monotype with `forall b r.
14:59:31 <lambdabot>                                   (Data b) =>
14:59:31 <lambdabot>                                   (b -> r) -> r'
15:00:09 <FunctorSalad_> @type everything (++) (\(x::aaa) -> \k -> k x    :: GenericQ (forall r. Data b => (forall b. b -> r) -> r))
15:00:09 <lambdabot>     Cannot match a monotype with `aaa
15:00:10 <lambdabot>                                   -> a
15:00:10 <lambdabot>                                   -> forall r. (Data b) => (forall b1. b1 -> r) -> r'
15:00:24 <FunctorSalad_> @type everything (++) (\(x::aaa) -> \k -> k x    :: GenericQ (forall r. => (forall b. Data b => b -> r) -> r))
15:00:25 <lambdabot> parse error on input `=>'
15:00:30 <Silvah> :t Prelude.flip (\_ _ _ -> undefined)
15:00:31 <lambdabot> forall a b t a1. b -> a -> t -> a1
15:00:38 <FunctorSalad_> @type everything (++) (\(x::aaa) -> \k -> k x    :: GenericQ (forall r.  (forall b. Data b => b -> r) -> r))
15:00:39 <lambdabot>     Cannot match a monotype with `aaa
15:00:39 <lambdabot>                                   -> a
15:00:39 <lambdabot>                                   -> forall r. (forall b. (Data b) => b -> r) -> r'
15:00:58 <mreh> have we got a good high level (in a Perlis sense) graphics lib that uses openGL (or otherwise)
15:01:12 <FunctorSalad_> that one is finally correct I think, apart from the monotype restriction
15:01:31 <FunctorSalad_> or maybe one does need the annotation on k too :o
15:01:49 <Silvah> :t Prelude.flip ((\_ _ _ -> undefined) :: Int -> Float -> Double -> Word)
15:01:50 <lambdabot> Float -> Int -> Double -> Word
15:02:40 <FunctorSalad_> @type everything (++) (\(x::aaa) -> \(k :: forall b. Data b => b -> r)  -> k x    :: GenericQ (forall r.  (forall b. Data b => b -> r) -> r))
15:02:41 <lambdabot>     A pattern type signature cannot bind scoped type variables `r'
15:02:41 <lambdabot>       unless the pattern has a rigid type context
15:02:41 <lambdabot>     In the pattern: k :: forall b. (Data b) => b -> r
15:02:55 <lasse> Anybody know why haskell.org is down?
15:03:03 <FunctorSalad_> aavogt: ah I think I see what you mean now with getting the r into scope :o
15:03:09 <Silvah> Because Apache died.
15:03:56 <lasse> Silvah: Seems reasonable - any ETA on resurrecting it?
15:04:13 <FunctorSalad_> @type everything (++) (\(x::aaa) ->    (       \(k :: forall b. Data b => b -> r)  -> k x              ::  forall r. (forall b. Data b => b -> r) -> r       ) )
15:04:14 <lambdabot>     A pattern type signature cannot bind scoped type variables `r'
15:04:14 <lambdabot>       unless the pattern has a rigid type context
15:04:15 <lambdabot>     In the pattern: k :: forall b. (Data b) => b -> r
15:04:29 <FunctorSalad_> but it has one :P
15:04:50 <FunctorSalad_> or is the rightmost annotation not enough to make it rigid?
15:04:58 <aavogt> @type let f :: forall a r. Data a => a -> [(forall a. Data a => a -> r) -> r]; f = everything (++) (\x k -> k x) in f
15:04:59 <lambdabot>     Inferred type is less polymorphic than expected
15:04:59 <lambdabot>       Quantified type variable `a1' escapes
15:04:59 <lambdabot>     In the second argument of `everything', namely `(\ x k -> k x)'
15:06:01 <aavogt> @type let f :: forall a r. Data a => a -> [(forall a. Data a => a -> r) -> r]; f = everything (++) (\x k -> [k x]) in f
15:06:02 <lambdabot>     Inferred type is less polymorphic than expected
15:06:02 <lambdabot>       Quantified type variable `a1' escapes
15:06:03 <lambdabot>     In the second argument of `everything', namely `(\ x k -> [k x])'
15:06:16 <aavogt> @type \x k -> k x
15:06:17 <lambdabot> forall t t1. t -> (t -> t1) -> t1
15:07:05 <FunctorSalad_> @let f x = \(k :: forall r. (forall a. Data b => b -> r) -> r) -> k x
15:07:05 <lambdabot>   Parse error: DoubleArrow
15:07:37 <FunctorSalad_> @let f x (k :: forall r. (forall a. Data b => b -> r) -> r) = k x
15:07:38 <lambdabot>   Parse error: DoubleArrow
15:07:49 <FunctorSalad_>  @let doesn't have pattern sigs enabled?
15:07:53 <aavogt> I suppose not
15:07:55 <ski> s/forall a. /forall b./
15:08:05 <FunctorSalad_> @let f x (k :: forall r. (forall b. Data b => b -> r) -> r) = k x
15:08:05 <lambdabot>   Parse error: DoubleArrow
15:08:15 <FunctorSalad_> good point, but still ;)
15:08:22 <FunctorSalad_> @let f (x::Int) = x
15:08:22 <lambdabot>   ScopedTypeVariables is not enabled
15:08:53 <FunctorSalad_> @let f x = \k -> (k :: forall r. (forall b. Data b => b -> r) -> r) x
15:08:54 <lambdabot>   Parse error: DoubleArrow
15:09:09 <FunctorSalad_> I give up
15:09:13 <ski> @let idid :: (forall a. a -> a) -> (forall a. a -> a); idid id x = id x
15:09:13 <lambdabot>   TypeOperators is not enabled
15:09:41 <FunctorSalad_> anyway, I was trying to construct the second argument to everything separately, aavogt
15:09:49 <Silvah> @src flip
15:09:49 <lambdabot> flip f x y = f y x
15:09:52 <ski> (no `Rank2' or `RankN', either)
15:09:56 <FunctorSalad_> to `everything'
15:10:06 <ski> > let idid :: (forall a. a -> a) -> (forall a. a -> a); idid id x = id x in idid id ()
15:10:07 <lambdabot>   ()
15:10:36 <FunctorSalad_> aavogt: I thought it *should* be possible with ImpredicativeTypes at least
15:10:50 <Silvah> :t flip
15:10:51 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:11:09 <Silvah> Okay...
15:11:21 <FunctorSalad_> (what we need is a GenericQ (forall r. (forall b. Data b => r) -> r), as I see it)
15:12:28 <Silvah> > 8
15:12:29 <lambdabot>   8
15:12:42 <Silvah> At least this works as expected.
15:13:09 <FunctorSalad_> hehehe didn't know about the flip
15:13:29 <aavogt> Silvah: the flip we have here works wherever the real one works
15:14:16 <aavogt> because you may substitute (c ->)  for f
15:14:22 <Silvah> The same case as with the dot operator, eh?
15:14:33 <aavogt> sure
15:14:34 <FunctorSalad_> it might fail without an annot
15:14:55 <FunctorSalad_> instance selection, or this "monotype restriction" we just saw
15:14:59 <FunctorSalad_> for lack of a better word
15:15:08 <pastorn> Loading package download-0.3 ... linking ... <interactive>: /home/alexander/.cabal/lib/download-0.3/ghc-6.12.2/HSdownload-0.3.o: unknown symbol `stat64'
15:15:10 <pastorn> ghc: unable to load package `download-0.3'
15:15:12 <pastorn> *Main>
15:15:28 <pastorn> what is this? i've never gotten anything like this before :(
15:15:38 <kmc> :(
15:15:46 <Silvah> @src (->) fmap
15:15:46 <lambdabot> fmap = (.)
15:16:11 <ski> @src (.)
15:16:11 <lambdabot> (f . g) x = f (g x)
15:16:11 <lambdabot> NB: In lambdabot,  (.) = fmap
15:16:13 <pastorn> can it have something to do with me installing it like this? cabal install download --constraint="tagsoup < 0.8"
15:16:30 <aavogt> hmm, then flip should have a NB:
15:17:11 <aavogt> @type \a -> fmap ($ a)
15:17:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
15:17:18 <aavogt> @type flip
15:17:19 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:17:50 <FunctorSalad_> pastorn: hmm stat64?
15:17:59 <FunctorSalad_> isn't that a common system call...
15:18:02 <pastorn> FunctorSalad_: i have no clue...
15:18:02 <kmc> @pl flip $ \x -> fmap ($ x)
15:18:03 <lambdabot> flip (fmap . flip id)
15:18:09 <pastorn> FunctorSalad_: it's dons code
15:18:15 <pastorn> *blame* *blame*
15:18:31 <FunctorSalad_> but I'll defer to the linker experts
15:18:32 <kmc> now to tie the knot
15:18:37 <kmc> :t flip (fmap . flip id)
15:18:38 <lambdabot> forall b (f :: * -> *) a. (Functor f) => f (a -> b) -> a -> f b
15:19:25 <ski> @type let flip :: Functor f => f (a -> b) -> a -> f b; flip = flip (fmap . flip ($)) in flip
15:19:26 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:20:02 <ski> > let flip :: Functor f => f (a -> b) -> a -> f b; flip = flip (fmap . flip ($)) in flip (^) 2 5
15:20:03 <lambdabot>   *Exception: stack overflow
15:20:35 <ski> so, `Prelude.flip', or just `flip fab a = fmap ($ a) fab'
15:21:36 <ski> @tell Cale add `NB: In lambdabot,  flip fab a = fmap ($ a) fab' to `@src flip' ?
15:21:36 <lambdabot> Consider it noted.
15:22:04 <ski> @type \fab a -> ($ a) . fab
15:22:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
15:27:19 <BMeph> @get-Cale
15:27:20 <lambdabot> Unknown command, try @list
15:27:57 <JasonFelice> Anybody do TDD with a cabal-style project?  Should I put tests in the same source file or separate?  (I usually do the same in other languages, but that seems to clutter the imports and make dependencies harder to understand).
15:31:11 <mreh> @seen luqui
15:31:12 <lambdabot> Unknown command, try @list
15:31:18 <mreh> preflex: seen luqui
15:31:19 <preflex>  luqui was last seen on #haskell 55 days, 7 hours, 29 minutes and 40 seconds ago, saying: ah
15:31:41 <mreh> that's Luke Palmer right?
15:32:37 <Cale> Yes
15:32:38 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:32:50 <mreh> where is that boy?!
15:34:54 <Silvah> g'night all
15:35:14 <haploid> is there no way of evaluating two expressions in a function in haskell ?
15:35:29 <Silvah> no
15:35:36 <Silvah> It makes no sense.
15:36:07 <monoidal> you can make the function return a pair
15:36:09 <Silvah> First expression would be utterly useless.
15:36:20 <aristid> seq evaluates two expressions
15:36:55 <haploid> ahh, aristid thanks
15:37:18 <aristid> haploid: you probably don't want to use it.
15:37:26 <Silvah> I wonder he really understood that one.
15:38:03 <aristid> haploid: and don't expect me to explain it, cause it's bedtime for me :P
15:38:07 <Silvah> :t seq -- ahem
15:38:08 <lambdabot> forall a t. a -> t -> t
15:38:44 <Silvah> It evaluates the first expression to WHNF and return the second expression.
15:39:05 <Silvah> returns*
15:39:15 <haploid> yeah that's what I was looking for
15:39:19 <aavogt> it's an artificial data dependency
15:39:39 <aavogt> though not really since it doesn't require that the first argument is evaluated first
15:39:45 <mreh> are monoids tuples?
15:39:52 <mreh> 2 tuples
15:40:03 <monoidal> mathematically, a monoid is a tuple - a set and a binary operation
15:40:11 <mreh> what about the identity
15:40:16 <mreh> how much do I need
15:40:21 <mreh> three things?
15:40:22 <aavogt> > mempty :: (String,String)
15:40:23 <lambdabot>   ("","")
15:40:36 <monoidal> sometimes it is included in the definition. it is uniquely determined by the operation
15:40:48 <monoidal> in haskell, you have to specify mempty and mappend.
15:40:55 <kmc> in a dependently typed language you could include the proofs of identity and associativity
15:40:56 <mreh> @src Monoid
15:40:56 <lambdabot> class Monoid a where
15:40:57 <lambdabot>     mempty  :: a
15:40:57 <lambdabot>     mappend :: a -> a -> a
15:40:57 <lambdabot>     mconcat :: [a] -> a
15:41:24 <Silvah> @src Alternative
15:41:24 <lambdabot> class Applicative f => Alternative f where
15:41:24 <lambdabot>     empty :: f a
15:41:25 <lambdabot>     (<|>) :: f a -> f a -> f a
15:41:28 <mreh> @src mconcat
15:41:29 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:41:39 <aavogt> @type foldr mappend mempty
15:41:40 <lambdabot> forall a. (Monoid a) => [a] -> a
15:41:51 <mreh> I guessed as such
15:42:01 <mreh> good to know I'm a good guesser
15:42:02 <kmc> (T : Set, id : T, (+) : T -> T -> T, forall x. id + x = x, forall x. x + id = x, forall x y z. x + (y + z) = (x + y) + z)
15:42:11 <kmc> a 6-tuple :)
15:42:27 <haploid> hm, seq doesn't appear to actually be evaluating the first expression, just the second.  weird
15:42:45 <aavogt> haploid: how should it be observable to you?
15:42:54 <mreh> that's what seq does
15:43:02 <mreh> :t seq
15:43:03 <lambdabot> forall a t. a -> t -> t
15:43:11 <monoidal> haploid: are you attempting to do something like seq (print 3) (print 5)?
15:43:13 <haploid> aavogt: the first expression is a putStrLn
15:43:29 <soupdragon> haploid: lol
15:43:30 <monoidal> evaluating an expression is not the same as executing it.
15:43:33 <soupdragon> You should have listen earlier
15:43:43 <mreh> use a 'let' expression
15:43:53 <haploid> ok
15:44:01 <monoidal> haplod: what is the type of second argument?
15:44:04 <monoidal> *haploid
15:44:16 <kmc> evaluation is not execution
15:44:31 <kmc> the only way to get a printout on *evaluation* is to cheat and use unsafePerformIO, directly or indirectly
15:44:37 <kmc> the typical library for that is Debug.Trace
15:44:50 <aavogt> that's in base isn't it?
15:45:01 <kmc> yeah
15:45:02 <mreh> yes
15:45:36 <haploid> monoidal:  just recusively evaluating the same function with a param - 1
15:45:48 <haploid> kmc:  ok
15:46:01 <monoidal> haploid: if the function returns IO a
15:46:04 <monoidal> then just use >>
15:46:59 <aavogt> higher order function may be easier to reason about than doing the recursion yourself
15:47:31 <kmc> IO actions are totally inert values.  they are descriptions of how you could do something, but merely evaluating the description doesn't execute the thing described
15:48:16 <aavogt> > fix print `seq` ()
15:48:17 <lambdabot>   ()
15:48:21 <dcoutts> kmc: that's a nice concise explanation
15:48:48 <aavogt> > fix (print $!) `seq` ()
15:48:52 <lambdabot>   mueval-core: Time limit exceeded
15:48:56 <JasonFelice> @hoogle catch
15:48:57 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
15:48:57 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
15:48:57 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
15:49:02 <kmc> dcoutts, some of it's stolen from Cale ;)
15:49:11 <dcoutts> :-)
15:49:12 <kmc> he used the word "inert" iirc
15:50:05 <JasonFelice> I can't program Haskell with haskell.org timing out!  (I don't know the libraries well enough yet.)
15:50:48 <aavogt> your ghc didn't come with library documentation?
15:51:35 <kmc> JasonFelice, hackage.haskell.org is still up
15:51:42 <kmc> http://hackage.haskell.org/package/base has a lot of the standard library
15:52:00 <kmc> and other hackage packages
15:53:17 <JasonFelice> thanks.
15:53:45 <JasonFelice> aavogt: You know, these days I use Google for access to reference materials I have in books sitting on the shelf just to my left.
15:53:56 <JasonFelice> er, right.  That's funny.
15:54:15 <JasonFelice> (I was thinking "your left.")
15:55:36 <haploid> it's going to be an interesting learning experience.  this language does not map well to intuition at all
15:56:08 <chrisdone> i think that depends on whose intuition it is
15:56:16 <aavogt> where it came from
15:56:17 <haploid> sure
15:56:20 <chrisdone> for the guys who made it it makes perfect sense
15:56:26 <haploid> heh
15:56:36 <Hunner> intuition formed by procedural practices, no
15:56:57 <chrisdone> haploid: are you new to haskell?
15:57:09 <haploid> yes
15:57:20 <chrisdone> did you http://tryhaskell.org ? :D
15:57:34 <kmc> as you learn Haskell it shapes your intuition
15:57:43 <kmc> and things that seemed natural will start to seem clunky and awkward
15:57:56 <haploid> no but I bought real world haskell
15:57:58 <kmc> like how most languages use functions for three totally different roles
15:58:09 <kmc> RWH is free online
15:58:15 <kmc> but thank you for supporting your friendly local dons
15:58:24 <chrisdone> ch-ching!
15:58:37 <kmc> @quote were.called
15:58:37 <lambdabot> hiredman says: I used to think "dons" was a title, like people who were recognized as being really good at haskell were called dons
15:58:44 <jmcarthur> kmc: what are the three you are thinking of? i can think of pure computation and side effects, but i can't think of a third
15:58:49 <chrisdone> hahaha
15:59:00 <xerox> don haskello
15:59:01 <chrisdone> hiredman sounds like "made man"
15:59:11 <aavogt> jmcarthur: delayed execution?
15:59:27 <chrisdone> "Donnie's getting hired" (see: Goodfellas)
15:59:27 <jmcarthur> ah, instead of lazy evaluation
15:59:29 <applicative> JasonFelice, cabal install hoogle will give you the hoogle machinery for the main libraries.  you can do  hoogle "Control.Exception"   and things like that.
15:59:40 <aavogt> though I'm not sure it's so much clearer in haskell
15:59:45 <kmc> functions express a) argument dependence, b) first-class effects, c) deferred evaluation
15:59:49 <jmcarthur> i think it is
16:00:01 <jmcarthur> delayed evaluation at least. maybe not delayed "execution"
16:00:15 <kmc> delayed execution is part of what i mean by (b)
16:00:33 <kmc> (c) is the thing where a divergent term wrapped in a lambda doesn't diverge immediately
16:00:52 <kmc> (b) is the thing where an effect wrapped in a lambda doesn't execute immediately.  plus, it's a value you can pass around
16:00:58 <aavogt> so b, c are taken care of by lazy eval
16:00:59 <kmc> (a) is what functions do in math
16:01:04 <jmcarthur> c is not guaranteed by the spec, is it?
16:01:04 <kmc> (b) isn't
16:01:15 <chrisdone> it bugs me i can't write
16:01:15 <chrisdone> foo (Just x) = Just (x+1)
16:01:15 <chrisdone> foo          = const
16:01:15 <chrisdone> always gives me lip about different number of arguments. is this a semantic limitation or an implemenation limitation
16:01:19 <kmc> (b) has nothing to do with lazy eval in Haskell
16:01:24 <jmcarthur> the spec doesn't say we can't do evaluation under lambdas, afaik
16:01:29 <kmc> except for historical / design-justification reasons
16:01:36 <lowasser> Is there anything in particular you should do, besides email haskell-cafe, if you have an improvement to a Computer Language Benchmarks Game program?
16:01:37 <jmcarthur> it's just that that's hard to do, so we don't do it ;)
16:01:40 <kmc> jmcarthur, but it says that the semantics must be equivalent to if we didn't
16:01:45 <kmc> denotational
16:01:47 <ahunter> ok, I'm blanking and Hoogle seems down; is there a standard list function for generating combinations? return a list of all length-6 subsets of a list, say?
16:02:00 <lowasser> ahunter: not really
16:02:13 <kmc> ahunter, it's not hard to write, but it is a gap in the std lib afaik
16:02:34 <aavogt> chrisdone: it isn't too ugly to write the x... and the benefit is that you might catch a typo quicker
16:02:38 <lowasser> I mean, if you want one that's speedy, life also gets more interesting
16:02:42 <chrisdone> permutations [1..5]
16:02:46 <chrisdone> > permutations [1..5]
16:02:47 <lambdabot>   [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4...
16:02:47 <lowasser> although of course it's exponential anyway
16:03:03 <ahunter> Yeah, I know it's not too hard to write, it's just annoying it's noth there.
16:04:31 <jmcarthur> kmc: well, the evaluation under lambdas would have to be itself lazy, sure
16:04:40 <chrisdone> aavogt: i don't think it's necessary sometimes
16:05:22 <chrisdone> if i write an explicit formal parameter it's usually to indicate some special significance
16:05:28 <mreh> :t liftA2
16:05:29 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
16:05:42 <jmcarthur> kmc: "a divergent term wrapped in a lambda doesn't diverge immediately" ... sorry, i missed the word "immediately"
16:05:44 <chrisdone> i meant id, not const, btw
16:06:01 <jmcarthur> so you said it the way i was thinking it anyway
16:06:03 <mreh> :t <$>
16:06:04 <lambdabot> parse error on input `<$>'
16:06:09 <mreh> :t (<$>)
16:06:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:06:23 <chrisdone> (<$>) = fmap
16:06:24 <jmcarthur> rather, i misinterpreted the word... but i digress
16:06:33 <mreh> :t liftA
16:06:34 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
16:07:04 <dons> a bit on what is happening around hackage, http://donsbot.wordpress.com/2010/05/31/there-are-a-hell-of-a-lot-of-haskell-libraries-now-what-are-we-going-to-do-about-it/
16:07:32 <monoidal> @let allSubsets =  iterate (\k -> concatMap (\(x:y) -> map (x:) (k y)) . init . tails) (const [[]])
16:07:33 <lambdabot>  Defined.
16:07:50 <monoidal> > (allSubsets !! 3) [1,2,3,4]
16:07:51 <lambdabot>   [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
16:08:22 <monoidal> ahunter: ^ here is an obfuscated version
16:08:47 <kmc> dons, cool :)
16:09:25 <jmcarthur> dons: that's excellent
16:09:52 <haploid> oh, that works.  I can call multiple functions with do
16:09:54 <haploid> sweet
16:10:36 <kmc> you can execute multiple actions with "do"
16:10:48 <kmc> whether your actions come from calling functions or not is irrelevant
16:10:53 <monoidal> do x; y; z is same as do x; (do y; z)
16:12:14 <BMeph> That would make a good subject for (someone else's) blogging...the divide between evaluation and execution of IO+laxiness gives.
16:13:16 <kmc> i wish the hype about Haskell was more focused on "separating evaluation from execution in the runtime system" and less focused on "separating pure functions from effects in the type system"
16:13:36 <kmc> the latter builds a lot of false intuition
16:13:46 <FunctorSalad_> why not 'eval from exec in the type system'...?
16:14:09 <kmc> the type system doesn't have anything to say about execution
16:14:49 <kmc> brb
16:15:52 <BMeph> kmc: Especially since it's usually less accurately described as "eliminating side effects" than "identifying where side effects happen"... :\
16:16:07 <BMeph> ...drat!
16:16:50 <BMeph> I have to learn how to type fast, someday. Probably right after I start up those "Procrastinators' Anonymous" sessions... ;
16:17:15 <aavogt> BMeph: there are less side effects when you don't use destructive update to calculate say a sum
16:17:41 <aavogt> (of a list)
16:18:45 <danharaj> Do pullouts and pushbacks have computable interpretations in type theory?
16:18:52 <Hunner> BMeph: i learned touch typing and dvorak at the same time and doubled my speed at the same time as eliminating wrist pain
16:19:18 <soupdragon> danharaj yes
16:19:56 <danharaj> soupdragon: please to be elaborating
16:22:36 <gwern> @wn miserere
16:22:37 <lambdabot> No match for "miserere".
16:22:44 <gwern> @wn copremesis
16:22:44 <lambdabot> No match for "copremesis".
16:25:44 <gwern> tsk, wordnet, why nothing on fecal vomiting?
16:29:39 <Cale> http://www.marriedtothesea.com/053110/a-better-language.gif
16:30:04 <QtPlatypus> danharaj: What are pullouts and pushbacks?
16:30:58 <Cale> I think the equaliser/coequaliser part is a bit hard for most type systems
16:32:00 <Cale> QtPlatypus: Presumably he meant pullbacks and pushouts.
16:32:11 <danharaj> hah what did I really say that
16:32:28 <danharaj> pullout and pushback is what I do in sex, not category theory :\
16:32:49 <kmc> that's not effective
16:34:18 <monoidal> coequalizer can be simulated by instance Eq with some equivalence relation
16:34:31 <FunctorSalad_> what does that idiom "married to the sea" mean btw?
16:34:41 <FunctorSalad_> (==) is not in the typesystem
16:35:06 <FunctorSalad_> it occurs in lyrics too :o
16:35:29 <gwern> 'Today, there are 2121 libraries for Haskell, available as source on http://hackage.haskell.org (only a “cabal install” away), and often 100s of Haskell libraries in binary form on your favorite distro.'
16:35:29 <kmc> Cale, it's funny because Java is the COBOL of the 21st century, and this statement is made unironically about Java all the time
16:35:33 <gwern> 2121 -_-
16:35:58 <gwern> FunctorSalad_: I associate 'married to the sea' with sailors being unfaithful. 'I have a woman in every port because I'm married to the sea' etc
16:36:03 <danharaj> how many of them are maintained, have good documentation, and a userbase?
16:36:28 <kmc> danharaj, that problem is what the post is about
16:36:34 <gwern> danharaj: dunno. Gracenotes is working on that
16:36:49 <kmc> the answer is "we don't know yet but we care a lot"
16:37:03 <kmc> ...and the latter part is why Haskell actually has a shot in industry
16:37:19 <danharaj> :\
16:37:50 <kmc> compared to most FP languages with a highly academic origin
16:38:05 <FunctorSalad_> gwern: interesting, but doesn't seem plausible in the case I was thinking of... but sorry that's way OT now
16:38:29 <gwern> FunctorSalad_: if you do find out what it means, I'd be curious to know
16:38:37 <kmc> gwern, i thought it was just that a wife can't have the full attention of a sailor, not specifically that he'd be unfaithful
16:38:44 <kmc> but not sure
16:38:55 <kmc> webcomic names are usually non-sequitors
16:40:39 <kmc> i was amused when overcompensating used the word "overcompensating" as the punchline to a strip, and then declared that the strip was over
16:43:30 <haploid> google is really bad at locating explanations/solutions to ghc error messages.  is there a searchable forum or mailing list that is commonly used for this ?
16:43:40 <kmc> yeah, you're in it
16:44:11 <FunctorSalad_> well, searchable... but through google
16:44:19 <haploid> heh
16:44:27 <kmc> or grep, if you have a local copy
16:44:42 <kmc> but more importantly, it's a distributed search engine of much of what is known about Haskell
16:44:53 <FunctorSalad_> or Ctrl-F, if you never go offline and have infinite scrollback
16:44:55 <FunctorSalad_> ;)
16:44:55 <kmc> implemented by a bunch of primates with typewriters
16:45:38 <kmc> (monkeys with typewriters, even, if you're not into paraphyletic clades)
16:51:28 <tomberek> preflex: seen edwardk
16:51:28 <preflex>  edwardk was last seen on #haskell 1 day, 21 hours, 48 minutes and 40 seconds ago, saying: selckiku: hahaha
16:51:44 <soupdragon> preflex: seen selckiku
16:51:45 <preflex>  selckiku was last seen on #haskell 1 day, 21 hours, 40 minutes and 19 seconds ago, saying: lispy|web,  laziness i'm familiar with, but what do you mean by "purity"?  or just that it's elegant?
16:53:05 <haploid> "The equation(s) for `foo' have two arguments, but its type `([Char], Int) -> Int' has only one"  <--- does this mean anything to anyone /.
16:53:54 <pastorn> how does this happend? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25862
16:54:40 <kpreid> haploid: did you declare that type? perhaps it should be [Char] -> Int -> Int
16:55:07 <c_wraith> pastorn, the first one is looking at the global package cache, the second is looking at the user package cache
16:55:24 <pastorn> c_wraith: ugh... fix?
16:55:36 <c_wraith> either give Setup.hs the --user flag, or using cabal install to install it
16:57:43 <pastorn> c_wraith: thanks :D
16:57:50 <haploid> kpreid:  not sure what you mean by that.  I probably just don't understand type signatures
16:58:33 * hackagebot hbeanstalk 0.1 - Client for the beanstalkd workqueue service.  http://hackage.haskell.org/package/hbeanstalk-0.1 (GregHeartsfield)
16:58:54 <kpreid> haploid: the function f a b = ... has the type (type of a) -> (type of b) -> ..., not the type (type of a, type of b) -> ...
16:59:12 <haploid> oh
16:59:15 <kpreid> if you wanted the latter the function would be written f (a,b) = ...
16:59:45 <haploid> that syntax makoes no sense at all, but I'll try it, thanks
16:59:49 <haploid> *makes
16:59:59 <mreh> why does darcs insist on reverting things not in my cwd
17:00:43 <mreh> i.e. darcs whatsnew prints stuff completely unrelated to my project
17:01:01 <c_wraith> haploid, it makes perfect sense.  a -> b -> c is a curried function.  One that when you pass it an a, it returns a function from b to c.
17:01:31 <mreh> M ./dist/build/autogen/cabal_macros.h -4 +10
17:01:32 <mreh> M ./dist/setup-config -1 +1
17:02:09 <mreh> oh, that's all auto-generated stuff
17:02:33 <c_wraith> yeah, dist shouldn't be in source control
17:02:56 <mreh> how do I remove it?
17:03:08 <mreh> unrecord
17:03:15 <c_wraith> with darcs?  darcs remove
17:04:13 <edwardk> tomberek: whats up?
17:04:29 <danharaj> Are there any projects for making GHC errors more tractable?
17:04:30 <tomberek> hey, edwardk, just the man i wanted to see
17:05:00 <edwardk> does anyone know if someone has implemented a set of gll parser combinators in haskell?
17:05:16 <kmc> danharaj, not that i know of.  might be a good GSoC
17:05:17 <c_wraith> oh, that's not a typo for "all".
17:05:32 <kmc> there is "helium" which implements a Haskell-like language, and has good error messages as a primary goal
17:05:35 <haploid> c_wraith:  no, what I'd like is a function that takes a and b and returns c.  does haskell only support single-parameter functions ?  I will google curried functions, I aunfamiliar with the term
17:05:45 <edwardk> kmc: maybe not, thats an awfully invasive change for ghc, and ghc's bowels are not for the light of heart
17:05:52 <kmc> haploid, yes, Haskell only supports single-parameter functions
17:06:05 <kmc> haploid, you can do things that seamlessly look like multi parameter functions
17:06:10 <danharaj> kmc: GSoC?
17:06:13 <edwardk> the constrained handling rules approach is pretty invasive, as well
17:06:48 <kmc> haploid, when you say «f x y = 2*x + 7*y + 3», what you get is (say) «f :: Int -> Int -> Int»
17:07:04 <jbapple> the platform page claims that HP includes fingertrees: http://hackage.haskell.org/platform/contents.html
17:07:05 <kmc> haploid, which you can read as "f takes two Int arguments and returns an Int"
17:07:08 <kmc> but what's really going on
17:07:12 <jbapple> But I don't see them in any of the packages listed
17:07:16 <c_wraith> jbapple, Data.Sequence
17:07:20 <kmc> is that (Int -> Int -> Int) is shorthand for (Int -> (Int -> Int))
17:07:29 <kmc> and f is actually a function that takes one argument, and returns a function, which takes the second argument
17:07:31 <jbapple> Data.Sequence is based on fingertrees, but does not expose the entire interface
17:07:37 <jbapple> AFAICT
17:07:55 <kmc> and that's what we mean by "currying" -- it's a convention for how to encode multi-argument functions in languages without them
17:07:57 <c_wraith> Well, that's what the platform is referring to.
17:08:04 <kmc> and in Haskell this convention is strongly encouraged by the syntax
17:08:16 <haploid> oh wow, that's crazy.  am I incorrect in assuming that between curried functions, and recursion instead of loops, that the call stack often gets enormous in haskell programs ?
17:08:27 <dons> haploid: nope.
17:08:45 <kmc> haploid, because of lazy evaluation, the stack in GHC-compiled Haskell programs plays a much different role from in your typical C program
17:08:52 <dons> loops are a form of recursion
17:09:02 <kmc> haploid, in the (arguably simpler) world of non-lazy functional languages, you are often guaranteed that tail calls are optimized to take no stack space
17:09:14 <haploid> wow, ok
17:09:17 <kmc> that's why Scheme and ML users are comfortable implementing loops by recursion
17:09:24 <kmc> it's an optimization you sometimes get with C compilers, but it's not promised
17:09:32 <cabrey> Forgive me if this has been asked a million times, but is haskell.org down?
17:09:38 <kmc> cabrey, you are forgiven
17:09:39 <danharaj> cabrey: yes.
17:09:40 <kmc> and yes :)
17:09:43 <mreh> Java is not tail call optimised my friend said
17:09:47 <danharaj> Perhaps it should be put in the topic :p
17:09:48 <kmc> correct
17:09:57 <cabrey> danharaj: I did look there first
17:09:58 <kmc> in fact it's a pain to implement tail calls correctly on JVM
17:10:11 <kmc> so this also cripples non-Java languages
17:10:25 <kmc> all because Java neglected to add some basic decades-old features
17:10:30 <mreh> he found this out when he tried to write scheme in haskell and asploded the stack
17:10:37 <dons> cabrey: yep, and we're working on it
17:10:40 <danharaj> kmc: isn't it a bit of a pain to guarantee tail call optimization in Haskell as well? Also what sort of features have they omitted.
17:10:41 <dons> but it iis a public holiday in the US
17:10:48 <danharaj> haha :p
17:10:50 <kmc> danharaj, first-class functions, from 1936
17:11:13 <danharaj> kmc: Heh, yes I suppose you are correct. I can understand C/++ omitting them but when you are defining your own virtual machine...
17:11:17 <FunctorSalad_> write scheme in haskell on a jvm?
17:11:17 <kmc> danharaj, i don't know about the difficulty of guaranteeing TCO in Haskell.  i do know that tail calls are less important under lazy eval
17:11:37 <kmc> what matters in Haskell is less that you're making tail calls and more that you're producing match-able constructors
17:12:10 <kmc> «f x = x : (f (x-1))» is definitely not tail-recursive, but it can be called and consumed in constant space
17:12:25 <dons> haploid: http://stackoverflow.com/questions/2342864/efficient-recursion-in-functional-programming-vs-inefficient-recursion-in-differ/2343325#2343325
17:12:26 <kmc> lazy lists conceptually fuse producers and consumers into co-routines
17:12:49 <kmc> and a clever compiler / std library can realize this fusion into actual constant-space loops
17:13:23 <FunctorSalad_> but that isn't 'stream fusion' yet, is it?
17:13:37 <kmc> i defer to dons ;)
17:13:43 <danharaj> kmc: But I can see this being a problem. Would not the conditions under which fusion is done by say GHC be more arcane than tail recursion optimization?
17:14:15 <EvanR> writing a tail recursive function and whatever you have to do in haskell are both examples of things the programmer should not be concerned with
17:14:24 <danharaj> lemme check something
17:14:27 <soupdragon> yes
17:14:37 <EvanR> its like rearranging your switch statement so the most probably case is on top in C
17:14:39 <FunctorSalad_> I thought getting constant space on a chain of list-processing functions was just lazyness...
17:14:42 * hackagebot bytestring-nums 0.3.2 - Parse numeric literals from ByteStrings.  http://hackage.haskell.org/package/bytestring-nums-0.3.2 (JasonDusek)
17:14:53 <FunctorSalad_> (as long as they're harmless ones, of course)
17:14:58 <kmc> yeah
17:15:11 <kmc> i suppose the cleverness is necessary if you want constant space *and* no allocation
17:15:17 <djahandarie> Lazyness is pretty cool huh
17:15:19 <kmc> laziness alone should get you constant space
17:15:33 <djahandarie> Laziness* even
17:15:46 <kmc> danharaj, you're right that fusion being brittle is an issue.  i think this is considered a major open problem, at least SPJ mentioned it as such in a recent DPH talk
17:15:46 <danharaj> but in other cases can't laziness get you space explosion, like if the produced code builds up a massive thunk before evaluating it?
17:15:51 <kmc> yup
17:16:10 <kmc> one of the most difficult things about writing real apps in Haskell is in finding and fixing those sorts of problems
17:16:12 <haploid> what type is 'm b' ?  ghc is inferring the type 'm b' for some reason
17:16:14 <kmc> in my experience
17:16:30 <kmc> haploid, it means "any type which is any type constructor applied to any type"
17:16:30 <pikhq_> haploid: Context?
17:16:31 <kmc> not very useful
17:16:37 <danharaj> I understand the design decision about demanding non-strict semantics, but perhaps leaving evaluation strategy unspecified to allow the compiler more leeway would have led to code that is easier to reason about in terms of resource consumption.
17:16:39 <kmc> haploid, probably it says «(Monad m) => m b» ?
17:17:07 <kmc> i thought the Haskell Report specifies non-strict semantics only
17:17:10 <pikhq_> danharaj: Evaluation strategy is unspecified in Haskell.
17:17:16 <haploid> pikhq_: "Couldn't match expected type `Int' against inferred type `m b'"
17:17:22 <kmc> it is fairly silent on operational concerns
17:17:30 <kmc> haploid, can you upload your code and the full error msg to hpaste.org
17:17:33 <danharaj> perhaps I am conflating evaluation strategy and strictness/laziness incorrectly
17:18:22 <kmc> "strict" and "non-strict" describe semantics
17:18:27 <EvanR> strict/non strict, lazy/eager
17:18:34 <kmc> lazy evaluation is one strategy for implementing non-strict semantics
17:19:51 <jbapple> c_wraith: http://trac.haskell.org/haskell-platform/ticket/127
17:19:52 <danharaj> kmc: but specifying non-strict semantics does limit at least practically the evaluation strategies allowed (assuming the compiler does not prove a certain strategy is correct under circumstances), right? That's what I meant.
17:20:06 <kmc> danharaj, right
17:20:28 <kmc> danharaj, but for example, a Haskell compiler could fork two threads for every evaluation, one strict and one lazy
17:20:50 <kmc> the lazy thread might terminate when the strict one is infinite-looping
17:21:03 <kmc> but if they both terminate, they'll get the same result
17:21:08 <kmc> (the church-rosser theorem)
17:21:19 <kmc> and it might be a worthwhile optimization on a machine with lots of spare cores
17:21:25 <haploid> kmc:  figured it out, I should have been returning an IO() instead of an Int
17:21:29 <kmc> haploid, cool
17:21:42 <EvanR> doesnt the lazy one always finish at most as fast as the strict one
17:21:57 <kmc> you can let the strict one continue running
17:22:03 <kmc> to speculatively evaluate stuff you might need later
17:22:19 <kmc> GHC's support for pure parallelism is basically a way for the programmer to specify this behavior
17:22:20 <FunctorSalad_> danharaj: and there are strictness annotations...
17:22:32 <kmc> "par" is used to suggest "we might need this later, consider forking a thread to chew on it now"
17:22:34 <FunctorSalad_> -XBangPatterns makes them relatively cheap
17:23:01 <haploid> now I just need to read up and learn what the hell type IO() is :)
17:23:17 <EvanR> an IO action that when executed results in ()
17:23:38 <EvanR> @src ()
17:23:38 <lambdabot> data () = ()
17:23:43 <EvanR> :t ()
17:23:43 <FunctorSalad_> (where () is half a bit of information)
17:23:44 <lambdabot> ()
17:23:46 <FunctorSalad_> ;)
17:23:51 <pastorn> @src IO
17:23:51 <lambdabot> Source not found. That's something I cannot allow to happen.
17:23:54 <pastorn> :(
17:23:54 <EvanR> lol
17:24:00 <pastorn> i wantz it
17:24:01 <danharaj> FunctorSalad: But that now requires you to do work to improve the performance of your code; you have to add strictness annotations to control memory and processor consumption. Why not lazy annotations as well and let the compiler choose what to do without annotations?
17:24:10 <Axman6> would it be correct to say that () has zero entropy?
17:24:14 <kmc> haploid, a value of type «IO a» is a piece of imperative code which, if you executed it, would produce a value of type «a»
17:24:36 <danharaj> Axman6: () has no information.
17:24:42 <kmc> but evaluation is not execution, and so you can pass these values around like any other, without them executing until you say so
17:24:44 <EvanR> danharaj: if you are wanting to do strict stuff, yes, you are worrying about the performance
17:24:50 <FunctorSalad_> danharaj: it'd make the cases where lazyness has better performance require you to do work ;)
17:25:12 <kmc> haploid, and () is the uninteresting type which has only one value, also named ()
17:25:30 <FunctorSalad_> danharaj: (at least, eager by default... not sure how much what you said last is possible)
17:25:36 <haploid> cool
17:25:45 <kmc> haploid, so «IO ()» is a little like C's «void f()», but it's not actually a function, since it has no args
17:25:56 <FunctorSalad_> Axman6: I conflated the "semi" in computability theory with "half a bit", of course ;)
17:25:58 <dons> gee, i wonder if 'too many haskell libraries' will become a meme
17:26:00 <kmc> it just represents a thing you could do, now or later, which has no useful result
17:26:08 <EvanR> void f() isnt a function either ;)
17:26:08 <FunctorSalad_> () has zero or one bit, depending on whether you count _|_
17:26:10 <kmc> dons, don't let jdh know
17:26:15 <dons> heh
17:26:19 <FunctorSalad_> and it's the result type of semidecision procedures
17:26:32 <danharaj> FunctorSalad: This completely conjectural, but perhaps- say the compiler is allowed free reign over strictness, you could run a profiler on your code on test cases to generate data, and then you can compile again with this data and let the compiler choose where to choose what.
17:26:38 <djahandarie> dons, there is no such thing as bad publicity. ;-)
17:26:52 <EvanR> danharaj: compiler already does strictness analysis
17:26:52 <dons> this is a good problem to have
17:27:10 <EvanR> critical parts of code are made strict when it is an optimization
17:27:15 <kmc> i mean this would boil down to the ages-old cathedral / bazaar argument
17:27:35 <kmc> F# has the monolithic .NET libraries made by one company
17:27:55 <danharaj> EvanR: is strictness analysis allowed to introduce strict semantics? Or does it have to prove there is no difference?
17:28:04 <EvanR> danharaj: no difference
17:28:06 <EvanR> i think
17:28:08 <jmcarthur> right
17:28:32 <FunctorSalad_> (in other words, it does yield the not-quite-one-bit of information that can be observed by whether the computation ever terminates)
17:28:32 <jmcarthur> it has to prove that the value will be evaluated anyway
17:28:35 <dons> with much smaller monetary investment, but massive distribution, we can hopefully out-compete the cathedral teams
17:28:57 <dons> i think that's worked for us over e.g. inria/ocaml, but its tougher against java/ .NET :)  however, Perl shows it is possible!
17:29:06 <kmc> yeah
17:29:14 <kmc> it would be nice to have a good Haskell implementation targeting JVM or CLR
17:29:24 <dons> nice is one word.
17:29:25 <kmc> assimilate your opponents and then beat them ;)
17:29:42 <EvanR> embrace extend and extinguish
17:29:51 <EvanR> inverse
17:30:19 <danharaj> I think cathedral and bazaar is too coarse a distinction.
17:30:45 <pastorn> if i have a bunch of MVars and each of them triggers an IO () action once filled (printing to terminal), how do i make sure that no two printing occurs at the same time?
17:31:01 <kmc> pastorn, send your printing through another thread to serialize them
17:31:18 <dons> we have a few little cathedrals (e.g. galois, utrecht, some other universities) tossing code out over  the wall
17:31:26 <dons> that combine to form an alliance of city states
17:31:30 <pastorn> kmc: with a Chan?
17:31:41 <kmc> pastorn, my little snippet for that is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25864#a25864
17:31:44 <kmc> yeah
17:31:54 <FunctorSalad_> how is haskell particularly massively distributed?
17:32:02 <pastorn> kmc: seems clever :D
17:32:18 <kmc> eh how clever can you be in 3 lines of code
17:32:20 <dons> FunctorSalad_: anyone can upload to hackage. so we have 1-3 person teams all over the world.
17:32:20 <mwotton> dons: the real problem is having something like Emacs, where it's almost impossible to get stuff into the mainline and the packaging system sucks. at least we have cabal...
17:32:21 <pastorn> kmc: but i will be doing clever h4xx using 'haha'
17:32:27 <FunctorSalad_> pastorn: you could just have a single cathedral thread controlling the output
17:32:28 <hstefan> hey there. it's me again!
17:32:31 <FunctorSalad_> sorry could not resist
17:32:34 <kmc> cool pastorn
17:32:52 <EvanR> more like a PR thread
17:32:55 <gwern> city states don't have great track records
17:32:56 <pastorn> kmc: i want designated areas of the terminal for different stuff
17:33:04 <gwern> they tend to get defeated in detail
17:33:12 <pastorn> kmc: this will be crazy amounts of escape sequences :D
17:33:13 <kmc> pastorn, seems like one thread to manage each area might be nice
17:33:25 <pastorn> kmc: no, one thread to manage each
17:33:26 <kmc> oh, but it won't serialize their output for you
17:33:33 <kmc> hence the present problem
17:33:34 <kmc> i see
17:33:45 <FunctorSalad_> gwern: what does that mean in the de-metaphored picture?
17:33:53 <pastorn> kmc: downloading and parsing the problem will be one thread per URL request + parser
17:33:53 <FunctorSalad_> states getting defeated in detail
17:34:03 <pastorn> then sequence output in no particular order :)
17:34:16 <pastorn> (or rather in the order that parsing got done
17:34:32 <gwern> FunctorSalad_: well, if city-states equal a few people in individual universities, then logically their predators, centralized nation-states, must be mid to big corporations
17:34:43 <FunctorSalad_> pastorn: there's a package on hackage for ungarbling concurrent output, btw
17:34:58 <dons> gwern: makes sense
17:34:59 <pastorn> FunctorSalad_: BAH! nonsense! NIH!!
17:35:03 <gwern> FunctorSalad_: note that both apple and microsoft can be cast fairly in that role
17:35:13 <pastorn> FunctorSalad_: also: i need to learn this shit
17:35:31 <kmc> FunctorSalad_, which package?
17:35:34 <FunctorSalad_> gwern: I meant what it means for *actual* (city-)states to get "defeated in detail"
17:35:38 <FunctorSalad_> (sounded like a technical term)
17:35:56 <kmc> "concurrentoutput"
17:36:03 <FunctorSalad_> http://hackage.haskell.org/package/concurrentoutput
17:36:05 <FunctorSalad_> yes
17:36:18 <kmc> oh that's cute
17:36:52 <gwern> FunctorSalad_: oh. well, imagine barbarossa's germany going up against the city-states of italy - he may have the same number of troops, but because he's not an alliance but a king, he can concentrate them all on one spot and overwhelm a defender, while the allied city-states disperse their armies over alternate routes and to garrison their cities
17:37:15 <gwern> FunctorSalad_: it's a strategy term
17:37:20 <hstefan> So, I'm stucked in the same problem that I asked for help 5 hours ago. I'm using a treeView to display a list of (String, [String]) and I want to display the [String] of the selected row in another treeView but the problem is that I don't know how to get the element selected. ps: I'm using gtk2hs.
17:37:54 <gwern> FunctorSalad_: http://en.wikipedia.org/wiki/Defeat_in_detail
17:38:01 <FunctorSalad_> gwern: thx
17:38:06 <gwern> FunctorSalad_: defeat in detail also is how an attacker can hope to overcome the advantage of the defense
17:38:16 <gwern> @wn defeat in detail
17:38:18 <lambdabot> *** "defeat" wn "WordNet (r) 2.0"
17:38:18 <lambdabot> defeat
17:38:18 <lambdabot>      n 1: an unsuccessful ending [syn: {licking}] [ant: {victory}]
17:38:18 <lambdabot>      2: the feeling that accompanies an experience of being thwarted
17:38:18 <lambdabot>         in attaining your goals [syn: {frustration}]
17:38:20 <lambdabot> [42 @more lines]
17:38:23 <kmc> hstefan, what info does gtk give you?
17:38:24 <gwern> hm.
17:38:47 <hstefan> well...
17:38:58 <hstefan> I just don't know how to get the element...
17:39:06 <hstefan> but let me check something.
17:39:07 <FunctorSalad_> we discussed that in #haskell-blah actually ;) as found in rts games
17:39:35 <kmc> hstefan, so it's mostly a gtk question then?
17:39:38 <FunctorSalad_> and how it makes statically defending a large area against a full-scale attack  impossible
17:39:41 <kmc> gtk2hs docs are down :/
17:40:01 <hstefan> I guess...
17:41:42 <hstefan> someone here gave me some link in hackage
17:41:53 <hstefan> for gtk2hs doc
17:42:15 <kmc> oh yeah it's cabalized now
17:42:15 <hstefan> but I don't know the link anymore, I was at college.
17:42:17 <kmc> the future has come
17:42:21 <kmc> http://hackage.haskell.org/package/gtk perhaps
17:42:26 <Cale> http://cale.yi.org/gtk2hs/
17:42:34 <Cale> or that... :)
17:43:20 <kmc> hstefan, so treeViewGetSelection gets you a TreeSelection
17:43:46 <danharaj> gtk2hs builds with the latest ghc?
17:43:57 <hstefan> yep.
17:44:06 <Cale> and then presumably treeSectionGetSelected will get you a TreeIter
17:44:17 <hstefan> yes.
17:44:18 <Cale> listStoreIterToIndex  :: TreeIter  -> Int
17:44:22 <Cale> and then...
17:44:24 <hstefan> LOL?
17:44:26 <Cale> listStoreGetValue  :: ListStore  a -> Int  -> IO  a
17:44:27 <hstefan> JUST THIS?
17:44:34 <hstefan> omfg
17:44:43 <hstefan> so I need to get the TreeSelection...
17:44:50 <hstefan> then the iter
17:44:58 <hstefan> and later the index
17:44:59 <kmc> TreeView is pretty ornate...
17:45:03 <FunctorSalad_> kmc: worked on first attempt for me. amazing!
17:45:14 <Cale> I have no idea why there are so many layers of indirection here.
17:45:31 <FunctorSalad_> no more groaning "oh no, need to reinstall gtk2hs..." whenever you've updated ghc!
17:45:34 <FunctorSalad_> ;)
17:47:02 <dons> danharaj: yup
17:47:13 <kmc> part of it is that gtk supports custom models attached to their view
17:52:52 <Cale> This is definitely something where wx is considerably simpler. It would just be ... n <- get selection listBox; s <- get (item n) listBox ...
17:56:35 <hstefan> kmc: weird. I'm trying to use listStoreIterToIndex
17:56:42 <ezyang> :t (.)
17:56:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:56:58 <hstefan> but it says the name is not in scope :(
17:58:43 <FunctorSalad_> ^^^^^^ it makes sense if you think of [A] = sum_n [n] -> A
17:58:45 <FunctorSalad_> ;)
17:58:59 <FunctorSalad_> with [n] being the n-element type. bad choice of notation
17:59:00 <hstefan> module Main where
17:59:00 <hstefan> import Trie
17:59:00 <hstefan> import Graphics.UI.Gtk
17:59:00 <hstefan> import Graphics.UI.Gtk.ModelView as Model
17:59:00 <hstefan> import Data.Maybe
17:59:02 <hstefan> main :: IO()
17:59:04 <hstefan> main = do
17:59:07 <hstefan>     initGUI
17:59:09 <codnik> oy, can't access haskell.org/hopengl, what's up?
17:59:09 <hstefan>     mainWin <- windowNew
17:59:12 <hstefan>     windowSetTitle mainWin "Dicionario de Sinonimos"
17:59:12 <tomberek> byorgey: hello?
17:59:15 <hstefan>     windowSetDefaultSize mainWin 500 400
17:59:17 <hstefan>     mainWin `onDestroy` mainQuit
17:59:18 <codnik> and the main site, for that matter
17:59:19 <hstefan>     
17:59:22 <hstefan>     searchLabel <- labelNew (Just "Busca")
17:59:25 <hstefan>     searchEntry <- entryNew
17:59:27 <hstefan>     entrySetVisibility searchEntry True
17:59:30 <hstefan>     searchBox <- hBoxNew False 5
17:59:32 <hstefan>     searchButton <- buttonNewWithLabel "Buscar"
17:59:35 <hstefan>             
17:59:37 <hstefan>     boxPackStart searchBox searchLabel PackNatural 5
17:59:40 <hstefan>     boxPackStart searchBox searchEntry PackNatural 5
17:59:42 <hstefan>     boxPackStart searchBox searchButton PackNatural 5
17:59:45 <hstefan>     
17:59:47 <hstefan>     wordLabel <- labelNew (Just "Palavras")
17:59:50 <hstefan>     wordBox <- hBoxNew False 5
17:59:52 <hstefan>     boxPackStart wordBox wordLabel PackNatural 5
17:59:55 <hstefan>     list <- listStoreNew (trieList "" (triePrefix t1 ""))
17:59:57 <hstefan>     
18:00:00 <hstefan>     treeview <- Model.treeViewNewWithModel list
18:00:02 <hstefan>     
18:00:05 <hstefan>     searchText <- entryGetText searchEntry
18:00:07 <hstefan>     --searchListStore <- listStoreNew (trieList searchText (triePrefix t1 searchText))
18:00:10 <hstefan>     onClicked searchButton $ do
18:00:13 <hstefan>         searchText <- entryGetText searchEntry
18:00:16 <hstefan>         listStoreClear list
18:00:18 <hstefan>         mapM_ (listStoreAppend list) (trieList searchText (triePrefix t1 searchText))
18:00:21 <hstefan>     
18:00:24 <hstefan>     widgetSetSizeRequest treeview 100 180
18:00:26 <hstefan>     tViewWindow <- scrolledWindowNew Nothing Nothing
18:00:27 --- mode: ChanServ set +o Saizan
18:00:29 <hstefan>     containerAdd tViewWindow treeview
18:00:30 --- mode: Saizan set +b *!*hstefan@187.39.50.*
18:00:38 <yitz> hstefan: please use hpaste
18:00:56 <Saizan> i'll unban you in a little while :)
18:01:34 <kmc> oh jesus
18:01:37 <soupdragon> hey I was reading that program
18:01:42 <codnik> i'm trying to compile FunGen, which requires HOpenGL but there's no lib files for download through synaptic
18:01:43 <danharaj> accidentally the whole channel
18:01:44 <pastorn> i have a "download-curl" installed, but i can't import Network.Curl.Download
18:01:46 <soupdragon> now I'll never know what happens
18:01:49 --- mode: Saizan set -b *!*hstefan@187.39.50.*
18:01:49 <pastorn> it installed properly and everything
18:01:52 <hstefan>         selectedIter <- treeSelectionGetSelected  selection
18:01:54 <hstefan>         index <- listStoreIterToIndex selectedIter
18:01:55 <FunctorSalad_> lol
18:01:57 <hstefan>         (a, [b]) <- listStoreGetValue list index
18:01:57 <danharaj> ok god
18:01:59 --- mode: Saizan set +b *!*hstefan@187.39.50.*
18:02:01 <kmc> soupdragon, spoiler alert, main returns () at the end
18:02:03 <kmc> that could have been a fat-finger mistake
18:02:04 <Saizan> how long was it!?
18:02:06 <soupdragon> lloll
18:02:13 <danharaj> Accidentally the entire buffer
18:02:28 <codnik> and HOpenGL's site is down (which is hosted at haskell.org)
18:04:17 --- mode: Saizan set -b *!*hstefan@187.39.50.*
18:04:17 <pastorn> codnik: cabal install FunGEn
18:04:25 <pastorn> hstefan: you done?
18:04:27 <hstefan> guys, sorry the flooding.
18:04:32 <hstefan> it was not intentional.
18:04:42 <pastorn> hstefan: middle klicking is AWESOME
18:04:52 <hstefan> http://codepad.org/FBT0iHmV
18:05:01 --- mode: Saizan set -o hstefan
18:05:06 --- mode: Saizan set -o Saizan
18:05:14 <hstefan> whats wrong with 76?
18:05:25 <pastorn> codnik: oh... FunGEn won't build for me...
18:07:05 <hstefan> I'll install gtk again... maybe it's an older version
18:07:35 <hstefan> heh, I dunno how to use cabal.
18:08:11 <Saizan> it should be "cabal install gtk"
18:08:13 <ezyang> I'ts pretty easy
18:08:13 <codnik> pastorn: really? :( installing cabal, i wasn't using it
18:08:35 <pastorn> codnik: i'll get to the bottom of this...
18:09:02 <codnik> pastorn: does it complain about some dependency?
18:09:09 <pastorn> the OpenGL bindings chonged, they use changed from using Double to GLdouble
18:09:11 <codnik> pastorn: it seems to require HOpenGL
18:09:22 <pastorn> codnik: not HOpenGL
18:09:23 <pastorn> OpenGL
18:09:32 <codnik> fu..
18:09:33 <pastorn> the haskell part is implicit here ;)
18:09:34 <codnik> what now?
18:09:47 <pastorn> if you say "HOpenGL" i'm presuming you're talking about stuff from 2002
18:09:56 <codnik> i'm doomed
18:09:58 <pastorn> codnik: get cabal installed
18:10:30 <codnik> pastorn: doing that
18:10:37 <hstefan> well... apparently it didn't worked
18:10:38 <pastorn> then $ cabal update; cabal instal FunGEn # but it probably won't work since you'll need a lot of c dependencies to get it all working
18:10:50 <hstefan> i've installed gtk
18:10:52 <gwern> @wn league
18:10:53 <lambdabot> *** "league" wn "WordNet (r) 2.0"
18:10:53 <lambdabot> league
18:10:53 <lambdabot>      n 1: an association of sports teams that organizes matches for
18:10:53 <lambdabot>           its members [syn: {conference}]
18:10:53 <lambdabot>      2: an association of states or organizations or individuals for
18:10:55 <lambdabot> [4 @more lines]
18:11:01 <hstefan> but I still with the older version..
18:11:35 <codnik> pastorn: woot, it seems to have worked here
18:11:49 <codnik> pastorn: installing FunGen through cabal seemed to work
18:11:59 <pastorn> codnik: maffagga
18:12:07 <pastorn> i get fiddy errors
18:12:33 <codnik> pastorn: i get a few warnings
18:12:46 <codnik> pastorn: but ultimately it seems to work
18:13:09 <pastorn> cool
18:13:12 <pastorn> glhf
18:14:10 <pastorn> codnik: oh, i use ghc6.12
18:14:15 <pastorn> you don't :p
18:14:31 * pastorn is in the future, with all its marvelous broken dependencies
18:14:43 <codnik> pastorn: thankfully
18:14:54 <pastorn> but we have flying cars here
18:14:58 <codnik> still, i can't compile this file importing FunGen
18:15:02 <codnik> but i'm a noob
18:15:04 <codnik> so that figures
18:15:11 <hstefan> I'm trying to install gtk with cabal... but it requires lots of other packages... is there anyway to tell Cabal do download them? (like with Pacman or apt-get)
18:15:13 <pastorn> codnik: start using OpenGL directly instead
18:15:20 <pastorn> codnik: it's simple enough
18:15:42 <dcoutts> hstefan: cabal can only install other Cabal packages, it can't do C libs etc automatically
18:15:45 <codnik>     Failed to load interface for `FunGEn':
18:15:47 <codnik>       locations searched:
18:15:49 <codnik>         FunGEn.hi
18:15:51 <codnik>         FunGEn.hi-boot
18:15:56 <dcoutts> hstefan: that's an advantage of native distro packages
18:16:01 <pastorn> codnik: pm
18:16:13 <codnik> pastorn: what!? nooo. that would be the end of me
18:16:36 <pastorn> codnik: private message 4 u
18:16:46 <pastorn> what did you think i meant...?
18:16:51 * pastorn ponders
18:17:36 <codnik> pastorn: nah, i meant regarding using opengl instead
18:17:38 <meanburrito920> Wow, this is annoying. Along with haskell.org, hoogle and hayoo are both down... :(
18:17:52 <hstefan> damm... it will be a pain to install gtk2hs then.
18:18:09 <dcoutts> hstefan: are you on a linux box?
18:18:36 <dcoutts> if so it's easy, it's a bit more tricky on osx and windows
18:19:21 <hstefan> dcoutts: I can run one...
18:19:23 <pastorn> codnik: there are some really nice changes you'll be missing out on if you use that old version of OpenGL
18:19:41 <dcoutts> hstefan: on linux you just install the gtk devel package
18:20:05 <dcoutts> hstefan: on osx you use macports, on windows follow the detailed INSTALL instructions
18:20:24 <codnik> pastorn: but my goal is to just make a VERY simple game for my graduation paper
18:20:47 <codnik> pastorn: i was even going to use the pong example they have up on FunGen's site
18:20:48 <hstefan> dcoutts: where can I find the instructions?
18:20:57 <dcoutts> hstefan: for windows?
18:21:04 <jordandanford> I understand a fair of functional programming and programming in general, but I'm running into a bit of trouble with Haskell's type system
18:21:14 <dcoutts> hstefan: http://code.haskell.org/gtk2hs/INSTALL
18:21:42 <dcoutts> hstefan: normally you'd be able to find that link from the gtk2hs site, but of course at the moment haskell.org web server is down
18:21:49 <jordandanford> With this code (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25866#a25866), I get this error: "Couldn't match expected type `Expr' against inferred type `Prim'"
18:22:11 <hstefan> ffffff
18:22:19 <hstefan> I need to finish this for tomorrow @_@
18:22:27 <hstefan> please haskell.org, COME BACK!
18:22:39 <pastorn> codnik: pm... still...
18:22:46 <dcoutts> hstefan: all the bits you need are on other servers
18:23:26 <dcoutts> hstefan: if you're on a tight schedule and have access to linux, you might find that quicker
18:24:09 <jordandanford> the type Expr includes Prim's, so should I assume I can't have user types within other user types
18:24:10 <jordandanford> ?
18:24:22 <gwern> @wn percipience
18:24:23 <lambdabot> No match for "percipience".
18:24:36 <mauke> jordandanford: Expr does not include Prim
18:24:40 <mauke> jordandanford: Expr is basically a boolean
18:25:20 <jordandanford> mauke: So a function that takes an Expr can't take Prim?
18:25:24 <jordandanford> *a Prim
18:25:39 <mauke> no, there are only two values of type Expr
18:25:45 <djahandarie> @pl \x -> (f a x >> return ())
18:25:46 <lambdabot> (>> return ()) . f a
18:26:02 <aavogt> @hoogle fromMaybe
18:26:03 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
18:26:57 <jordandanford> mauke: Okay, I think I understand – what should I change it to?
18:27:04 <meanburrito920> aavogt: whoah, how are you querying hoogle? its on haskell.org!
18:27:24 <meanburrito920> ...or does lambdabot cache?
18:27:26 <aavogt> meanburrito920: or installed on the same server as \bot
18:27:30 <meanburrito920> ah
18:27:36 <aavogt> it is a standalone program you know
18:27:43 <meanburrito920> :O
18:27:47 <gwern> meanburrito920: you really should install hoogle. it's nice
18:28:04 <meanburrito920> indeed. but I'm guessing the download is on haskell.org...
18:28:15 <gwern> hackage
18:28:34 <aavogt> jordandanford: there are separate scopes for type names and constructor names
18:28:53 <djahandarie> Is there a function (>> return()) ?
18:28:54 * BMeph is not encouraged by: "gtk2hsTypeGen.exe: File format not recognized" ... :(
18:29:05 <djahandarie> @hoogle m a -> m ()
18:29:05 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
18:29:05 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
18:29:06 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
18:30:02 <meanburrito920> woo! hackage is up :) my day just got so much better
18:30:05 <jordandanford> aavogt: So how should I fix my code?
18:31:03 <aavogt> jordandanford: you can put all the constructors of Prim and Func in a single data
18:31:26 <jordandanford> aavogt: I figured, but is there any more modular way?
18:31:51 <hstefan> I'm loost.. damm! I can't install gtk2hs 2-2
18:32:27 <dcoutts> hstefan: keep calm man!
18:32:37 <dcoutts> what are you doing, which platform are you using?
18:33:28 <hstefan> I'm using windows 7 and trying to install gtk2hs
18:33:38 <hstefan> but I'm following the tutorial
18:33:40 <hstefan> for installation
18:33:48 <hstefan> and it keep giving me errors.
18:34:20 <dcoutts> hstefan: so if you're following the tutorial I suppose you're using the older gtk2hs release that has a windows installer right?
18:34:35 <hstefan> I was using that one
18:34:46 <dcoutts> hstefan: and presumably you're using the correct matching version of ghc
18:34:47 <meanburrito920> hm. so cabal is complaining it is not at the proper version, yet it "is not compatible with itself" so I can't upgrade it in place to the most recent version. does this mean I have to reinstall the entire haskell-platform?
18:34:52 <hstefan> but the older doensn't have something that I neded.
18:35:04 <dcoutts> hstefan: oh so you got it installed?
18:35:21 <hstefan> the older was by an setup...
18:35:27 <aavogt> jordandanford: you could have    data Expr = forall a. Eval a => Expr a;  class Eval a where eval :: a -> Int;  instance Eval Prim ; instance Eval Func
18:35:52 <aavogt> if you really need to keep Prim and Func as separate data types
18:35:57 <hstefan> but I need the newer, that can be found in cabal
18:36:03 <aavogt> I don't think that's better though
18:36:10 <hstefan> (for listStoreIterToIndex function)
18:36:20 <dcoutts> hstefan: oh you don't need that
18:36:45 <dcoutts> you can use the TreeModel to convert a TreeIter to a TreePath
18:36:55 <hstefan> how can I get the index or the item of a selectedRow?
18:36:56 <dcoutts> and the first element of the TreePath is the index
18:37:12 <dcoutts> we've been over this before
18:37:27 <hstefan> dcoutts: how can I do this then?
18:37:34 <dcoutts> you convert the iter to a path
18:37:41 <dcoutts> and the first element of the path is the index
18:37:42 <hstefan> yeah but how?
18:37:50 <hstefan> how do I convert to path
18:37:50 <dcoutts> using the functions that do those conversions
18:38:36 <aavogt> jordandanford: alternatively you could have an explicit union type of Expr:   type Expr = Either Prim Func, then explicitly wrap and unwrap Left and Right
18:38:40 <dcoutts> hstefan: treeModelGetPath  :: TreeModelClass  self => self -> TreeIter  -> IO  TreePath
18:38:54 <dcoutts> hstefan: like I said, you can use the TreeModel to convert a TreeIter to a TreePath
18:38:57 <aavogt> jordandanford: it all depends on the sort of modularity you're asking for
18:39:11 <dcoutts> hstefan: it just needs a little persistence in reading the docs
18:40:01 <siracusa> hstefan: I used this to get the row index: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25867
18:40:17 <aavogt> jordandanford: it might be nicer to write Func as just   data Func1 = Neg; data Func2 = Add | Sub | Mul | Div
18:40:35 <dcoutts> siracusa: right, that is the alternative method hstefan and I discussed earlier
18:41:12 <siracusa> dcoutts: Oh, I didn't read that
18:41:26 <dcoutts> siracusa: s'ok, that was hours ago
18:41:37 <meanburrito920> hm. so I updated cabal from the ubuntu repos and now I'm getting the error "could not read from ghc-pkg dump"
18:41:50 <dcoutts> hstefan: you had code using treeSelectionGetSelectedRows before, did you manage to get that to work?
18:42:09 <dcoutts> meanburrito920: ok so your cabal is too old compared to your ghc
18:42:38 <dcoutts> meanburrito920: make sure you're getting your ghc and cabal-install packages from the same ubuntu repo
18:43:03 <jordandanford> aavogt: It's just that this was much easier in Scala but I'm looking for a way to implement it for a native code compiler
18:45:16 <meanburrito920> dcoutts: oops, I'm stupid. I had cabal originally installed from source, so it was in ~/bin. I renamed that, so I thought I was good, but I forgot that I also put cabal in /usr/local/bin
18:45:26 <meanburrito920> now its working fine
18:45:30 <dcoutts> great
18:46:16 <jordandanford> aavogt: in terms of typing, I'm still thinking in a more object-oriented fashion, which doesn't translate well to Haskell
18:46:41 <gwern> we need more haskell koans
18:46:44 <gwern> to break the mind of objects!
18:47:26 <soupdragon> gwern is right!!
18:47:53 <danharaj> jordandanford: think in algorithms, not glue.
18:47:58 <gwern> 'if you have no value, I will take it from you; if you have a value, I will give it to you'
18:47:58 <kmc> i like OOP
18:48:04 <hstefan>  dcoutts: i still stucked.
18:48:04 <kmc> it is a nice tool for some jobs
18:48:19 <kmc> and it's much less painful in Haskell than in Java or C++
18:48:58 <danharaj> as far as I am experienced, there are two main types of OOP: glue to make imperative stateful programs sane to manage, and kludges to get around unexpressive type systems/lack of first class functions/etc.
18:49:17 <jordandanford> danharaj: I'm only 17, I have a lot to learn :)
18:49:18 <gwern> the professor was giving a lecture on lazy evaluation. 'Any questions?' he said.
18:49:20 <Rotaerk> OO doesn't have anything to do with imperative or mutability
18:49:32 <ezyang> gwern: +1!
18:49:33 <aavogt> kmc: so OO including -XExistentialQuantification?
18:49:35 <hstefan> damm
18:49:37 <kmc> this discussion will go nowhere because nobody actually agrees on what OOP is
18:49:39 <hstefan> I hate linux now.
18:49:41 <gwern> ezyang: not my story
18:49:42 <hstefan> oops
18:49:43 <hstefan> windows.
18:49:48 <kmc> aavogt, can be a useful feature for doing OOP, yes
18:50:02 <kmc> not absolutely essential; you can get away with closures often
18:50:04 <aavogt> it's rather unpleasant to use in haskell
18:50:07 <hstefan> I could finish all this pain with the listStoreIterToIndex function
18:50:09 <kmc> in place of existentials
18:50:13 <hstefan> but I cant use it.
18:50:25 <hstefan> because I cant install the newer version
18:50:26 <Rotaerk> an interface is basically just a record type where its members are all functions
18:50:35 <aavogt> kmc: so getting away with closures is using continuation-passing style?
18:50:35 <danharaj> Rotaerk: bull honkey. Gang of Three's book is all recipes for gluing imperative code together in manageable ways and managing state in a way that has better semantic guarantees.
18:50:40 <monochrom> You are talking with people who think even turing-completeness is non-essential. :)
18:50:54 <Rotaerk> danharaj, doesn't say anything about OO
18:51:07 <Rotaerk> perhaps their usage of OO
18:51:11 <RyanT5000> danharaj: (.) is glue :)
18:51:15 <Rotaerk> or OO as it applies to imperative
18:51:20 <danharaj> RyanT5000 (.) is algebra :D
18:51:21 <djahandarie> What package is that odd Num -> thing in?
18:51:29 <danharaj> Rotaerk: Give me an example of what you think OOP is
18:51:29 <kmc> aavogt, yeah that's roughly what i meant
18:51:38 <djahandarie> > ((*) + (-)) 4 5
18:51:38 <Cale> http://www.youtube.com/watch?v=MiRxLgyN_Lo -- offtopic musical interjection
18:51:38 <lambdabot>   19
18:51:44 <aavogt> kmc: both methods are rather indirect
18:51:45 <djahandarie> That thing ^^
18:51:56 <RyanT5000> danharaj: algebra glues things :)
18:51:59 <aavogt> and therefore awkward
18:52:17 <kmc> i don't think GHC's existentials are that bad.  but also, other compilers have more straightforward existentials
18:52:19 <danharaj> RyanT5000: It ain't glue if unsticking it is trivial :)
18:52:28 <hstefan> *head desking at the speed of light*
18:52:30 <monochrom> goo things
18:52:47 <RyanT5000> danharaj: what we need is glue that can deal with things as poorly-constructed as the stuff OOP can, but doesn't *itself* force poor construction
18:52:52 <Rotaerk> danharaj, OO is packaging multiple functions together which share a closure
18:52:59 <kmc> Rotaerk, exactly.  in particular an interface in Haskell needn't be a type class, a mistake often made by beginners
18:53:02 <Cale> djahandarie: vector-space
18:53:17 <monochrom> generic object orientation = goo :)
18:53:18 <Cale> djahandarie: In the <something>.NumInstances module
18:53:34 <ddarius> @google "goo programming language"
18:53:35 <lambdabot> http://en.wikipedia.org/wiki/Goo_(programming_language)
18:53:35 <lambdabot> Title: Goo (programming language) - Wikipedia, the free encyclopedia
18:53:38 <aavogt> you don't write normal code in CPS, ghc's -XExistentialQuantification needs lots of boilerplate wrapping and unwrapping
18:53:39 <djahandarie> Cale, cool, thanks
18:53:43 <monochrom> hehe
18:53:52 <dcoutts> hstefan: honestly, what is the point in telling us all this when you don't let anyone help you?
18:53:54 <Rotaerk> danharaj, an interface is just a description of the functions being packaged together, and a class is... basically a function that creates an instance of the interface with a particular set of functions implemented together under the same closure
18:54:00 <aavogt> kmc: maybe it's worse elsewhere, but that doesn't make it nice in haskell
18:54:11 <monochrom> I may write normal javascript in cps and trampolined
18:54:29 <Rotaerk> http://rotaerk.pastebin.com/9USpBirz  this is F# but demonstrates the correspondence..
18:54:49 <aavogt> aww, now we have to define normal
18:54:51 <hstefan> dcoutts: dude, I am aceppting any help.
18:55:10 <hstefan> the problem is that I'm a dumb and I don't understand some explanations.
18:55:15 <monochrom> normal means inner product is 0
18:55:22 <dcoutts> hstefan: but you don't let people help, you don't post your code, you don't say what is wrong. People are glad to help but you don't make it easy for them.
18:55:42 * BMeph loves Io for CPS programming...
18:55:48 <monochrom> oh w00t, someone who doesn't use the scientific method
18:56:00 <Rotaerk> so a function that takes an interface is kind of an extension of the idea of a high order function
18:56:12 <monochrom> paste or it didn't happen
18:56:18 <hstefan> sorry for that, the problem is that I'm nervous.
18:56:29 <danharaj> Rotaerk: fair enough
18:56:52 <dcoutts> hstefan: what you need to do is to past your code somewhere, say what is failing, say what you've tried, say what your understanding of it is, where you think it's wrong/missing/whatever
18:57:16 <ddarius> dcoutts: Don't forget to say what it is -supposed- to do.
18:57:17 <dolio> danharaj: OO means anything that is good design.
18:57:23 <kmc> haha
18:57:25 <Rotaerk> :P
18:58:22 <jason______> I wrote a partition function but when I try to add a method signature I get an error
18:58:28 <dcoutts> hstefan: and what ddarius said :-), and when something people have suggested does not work, don't just say "it didn't work" they need to know how and why, because they didn't just give that suggestion as a random guess, they probably know what they're doing
18:58:30 <jason______> Kind error: `a' is applied to too many type arguments
18:58:33 <jason______> partition :: (Ord a) => a [a] -> ([a], [a])
18:58:47 <danharaj> a [a]?
18:58:48 <jason______> Could someone please tell me what I am doing wrong?  Thanks.
18:58:51 <kmc> jason______, a [a] is not a valid type
18:58:52 <jason______> a and a list of a
18:59:03 <danharaj> a -> [a] -> ([a], [a])
18:59:05 <kmc> a -> [a] -> ...   -- is this what you want?
18:59:06 <hstefan> http://codepad.org/mM9Mvw3G
18:59:09 <hstefan> heres the code
18:59:12 <jason______> let me try it
18:59:13 <dcoutts> hstefan: great
18:59:40 <hstefan> what I'm trying to do is just get the element selected.
18:59:46 <hstefan> and when I do this
18:59:47 <jason______> hm that works
18:59:48 <FunctorSalad_> @kind a [a]
18:59:49 <lambdabot> Not in scope: type variable `a'
18:59:49 <lambdabot> Not in scope: type variable `a'
18:59:50 <jason______> thanks
18:59:58 <FunctorSalad_> @kind foralla . a [a]
18:59:59 <lambdabot> parse error on input `.'
19:00:00 <hstefan> I'll be able to show it on another treeView.
19:00:03 <FunctorSalad_> @kind forall a. a [a]
19:00:03 <dcoutts> hstefan: which line should I be looking at?
19:00:04 <lambdabot>     `a' is not applied to enough type arguments
19:00:04 <lambdabot>     Expected kind `*', but `a' has kind `k -> k1'
19:00:04 <lambdabot>     In the type `[a]'
19:00:19 <monochrom> > 76+17
19:00:20 <lambdabot>   93
19:00:20 <hstefan> 93
19:00:27 <FunctorSalad_> @kind forall a b. a (b a)
19:00:28 <lambdabot> *
19:00:56 <dcoutts> hstefan: ok, firstly, check the type of treeSelectionGetSelected
19:01:02 <FunctorSalad_> hehe...
19:01:13 <jason______> so for each argument your function accepts it returns another function?
19:01:34 <dcoutts> hstefan: and also treeModelGetPath, make sure you're passing the right arguments, and that the results are of the type you expect
19:01:53 <aavogt> FunctorSalad_: except lists aren't (* -> *) -> *
19:01:56 <dolio> This isn't some crazy language like Clean.
19:02:15 <FunctorSalad_> aavogt: one more no?
19:02:41 <hstefan> treeSelectionGetSelected :: TreeSelectionClass self => self -> IO (Maybe TreeIter)
19:02:47 <FunctorSalad_> kind(b) :: kind(a) -> k
19:02:55 <FunctorSalad_> kind(b) = kind(a) -> k
19:02:57 <aavogt> doesn't it work out with   a :: * -> * ?
19:03:02 <hstefan> it returns an TreeIter...
19:03:11 <dcoutts> hstefan: no, it returns a Maybe TreeIter
19:03:19 <dcoutts> hstefan: the difference is crucial
19:03:21 <aavogt> @kind forall a b. (a (b a),a,b)
19:03:22 <lambdabot>     `a' is not applied to enough type arguments
19:03:23 <lambdabot>     Expected kind `*', but `a' has kind `k -> *'
19:03:23 <lambdabot>     In the type `(a (b a), a, b)'
19:03:24 <FunctorSalad_> kind(a) = kind(b) -> *
19:03:27 <hstefan> aw.
19:03:49 <FunctorSalad_> or wait...
19:03:55 <dcoutts> hstefan: and the other one, you're just missing the model argument to treeModelGetPath
19:03:55 <FunctorSalad_> you're right :)
19:03:59 <aavogt> @kind forall a b t u. (a (b a),b (t :: * -> *),a (u :: *))
19:04:00 <lambdabot> *
19:04:10 <FunctorSalad_> since kind(a) = k -> * ...
19:04:29 <dcoutts> hstefan: so it returns Maybe because there might not be any item selected, so how do you want to handle that?
19:04:58 <hstefan> well...
19:05:10 <hstefan> ah.
19:05:24 <dcoutts> hstefan: btw, I think (but I'm not 100% sure) that onSelectionChanged will fire when an item is selected and also when an item is de-selected
19:05:44 <dcoutts> the point being, you probably can get situations where no item is selected
19:05:53 <FunctorSalad_> @forall a. a a
19:05:54 <lambdabot> Unknown command, try @list
19:05:57 <FunctorSalad_> @kind forall a. a a
19:05:58 <lambdabot>     `a' is not applied to enough type arguments
19:05:58 <lambdabot>     Expected kind `k', but `a' has kind `k -> k1'
19:05:59 <lambdabot>     In the type `a a'
19:06:09 <FunctorSalad_> ok, no infinite kinds
19:06:09 <hstefan> dcoutts: humm...
19:06:35 <dcoutts> hstefan: thinking is good, I'm in no rush :-)
19:07:07 <hstefan> I am thinking...
19:07:34 <hstefan> I'm trying to figure out about how can I manage that when it returns 'Nothing'
19:09:22 <systemfault> Is it possible that eventually, stream fusion is going to be applied to the whole standard library? (Might be a stupid question...)
19:09:55 <dcoutts> systemfault: turns out there's still some tricky issues to solve, but it's not implausible
19:10:36 <dcoutts> there are also possible improvements to fold/build fusion that might work better for lists than stream fusion
19:11:18 <hstefan> dcoutts: well... I just the execution of the 'do' block stop... or dont do anything when the treeIter is 'nothing'
19:11:30 <hstefan> I just want*
19:11:31 <systemfault> dcoutts: Thank you for the quick answer :)
19:11:49 <hstefan> now let me think about how can I check what was returned
19:12:47 <dcoutts> hstefan: have you used "case" expressions before?
19:13:18 <hstefan> yeah but it was some time ago...
19:13:41 <dcoutts> case blah of
19:13:44 <dcoutts>   Nothing -> ...
19:14:09 <hstefan> blah should be my treeIter, right?
19:15:05 <ksf> @pl m1 >>= \x -> m2 >> m3 x
19:15:05 <lambdabot> (m2 >>) . m3 =<< m1
19:15:19 <ksf> :t m1 >>= \x -> m2 >> m3 x
19:15:20 <lambdabot> Not in scope: `m1'
19:15:20 <lambdabot> Not in scope: `m2'
19:15:20 <lambdabot> Not in scope: `m3'
19:15:47 <ksf> :t readLine >>= \x -> print "foo" >> print x
19:15:48 <lambdabot> Not in scope: `readLine'
19:16:04 <ksf> :t System.IO.readLine >>= \x -> print "foo" >> print x
19:16:05 <lambdabot> Not in scope: `System.IO.readLine'
19:16:08 <ksf> :t System.IO.readLn >>= \x -> print "foo" >> print x
19:16:09 <lambdabot> IO ()
19:16:24 <ksf> now that didn't tell me anything.
19:16:49 <hstefan> yay, that part is done.
19:16:55 <dcoutts> hstefan: great
19:16:57 <ksf> @unpl (m2 >>) . m3 =<< m1
19:16:58 <lambdabot> (\ d -> m2 >> ((m1 >>= m3) d))
19:17:30 <ksf> commutative...
19:18:00 <hstefan> dcoutts: now I need to get the path
19:18:02 <hstefan> right?
19:18:09 <dcoutts> right
19:20:47 <hstefan> Just iter -> do
19:20:50 <hstefan>                          path <- treeModelGetPath iter
19:20:56 <hstefan> am I goint in the right way?
19:23:27 <dcoutts> hstefan: yes, looks right except for the missing model argument to treeModelGetPath
19:24:32 <haploid> hahha learnyouahaskell.com++
19:25:15 <hstefan> ok
19:25:19 <hstefan> now I got the path.
19:25:24 <hstefan> its a list
19:25:27 <hstefan> size one
19:25:31 <hstefan> right?
19:25:46 <hstefan> (considering that I'm using singleSelection mode)
19:26:20 <jason______> I wrote a function that inserts an argument between each element of a list
19:26:22 <jason______> intersperse :: a -> [[a]] -> [a]
19:26:26 <jason______> intersperse _ []     = []
19:26:26 <jason______> intersperse _ (x:[]) = x
19:26:27 <jason______> intersperse a (x:xs) = x ++ [a] ++ (intersperse a xs)
19:26:33 <jason______> it only works for characters
19:26:43 <ddarius> :t intersperse
19:26:43 <jason______> intersperse ',' ["a", "b", "c"]
19:26:43 <lambdabot> forall a. a -> [a] -> [a]
19:26:51 <ddarius> :t intercalate
19:26:52 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:26:54 <jason______> but intersperse 1 [1,2,3] does not work
19:27:17 <dcoutts> hstefan: yep
19:27:21 <jason______> ?
19:27:47 <jason______> why won't it accept numbers when it accepts strings/characters?
19:28:12 <dons> > intersperse 1 [1,2,3]
19:28:12 <lambdabot>   [1,1,2,1,3]
19:28:25 <hstefan> http://codepad.org/Lmz6KpqS
19:28:28 <hstefan> dcoutts
19:28:31 <hstefan> is that right?
19:28:33 <dons> it accepts any list of lists of any type 'a'.
19:28:34 <BMeph> jason______: Brace yourself, but...UR DOIN IT RONG!!!111!11!1!!1ichi!1!
19:28:47 <jason______> how so?
19:28:48 <dons> ?src intersperse
19:28:48 <lambdabot> intersperse _   []     = []
19:28:48 <lambdabot> intersperse _   [x]    = [x]
19:28:48 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
19:29:03 <dcoutts> hstefan: so far, yes
19:29:12 <BMeph> dons: His version, not the "real" one. :)
19:29:18 <dons> jason______: [1,2,3] isn't of type [[a]]
19:29:20 <dons> its of type [a]
19:29:28 <jason______> hm
19:29:32 <dons> your requring on lists of lists be provided. e.g. ["a"]
19:29:36 <dons> which is really [['a']]
19:29:37 <hstefan> dcoutts: now... I have a treePath
19:29:38 <jason______> oh i see
19:29:43 <jason______> thanks
19:29:48 <hstefan> and how can I get the index using it?
19:30:41 <dcoutts> hstefan: so as you said, it's a list of length 1
19:30:58 <hstefan> head path?
19:31:26 <dcoutts> right
19:33:01 <hstefan> mmm
19:33:19 <hstefan> tryed it... but got this error: http://codepad.org/6tI9kadC
19:33:54 <dcoutts> hstefan: you only need <- for impure things, for IO actions, head is pure
19:34:14 <dcoutts> hstefan: "<-" is not assignment like in C
19:34:22 <ksf> I have a thing like newtype Foo a = Foo (StateT FooS M a) deriving (a lot), is there any way in hell to derive (a lot) based on what M implements?
19:34:28 <hstefan> hmm..
19:34:40 <ksf> I don't think it's possible in current haskell, I mean in general.
19:35:33 <dons> beyond what generalized newtype deriving provides?
19:35:44 <ddarius> ksf: You mean something like derive (Foo if M implement Foo)?
19:35:44 <ksf> in fact, the character sequence "head" in any haskell source is usually either a bug or bad style.
19:35:46 <Saizan> ksf: something very hacky with TH and ghci (ghc-api)?
19:35:52 <ksf> ddarius, yes
19:35:56 <jmcarthur> for certain situations standalone deriving can get you close, but not really any interesting ones
19:36:01 <ksf> or maybe derive(everything but MonadIO)
19:36:11 <haploid> can one not define functions in ghci?  only .hs source files ?
19:36:21 <ksf> you can use let
19:36:22 <dons> haploid: let f x = x + 1
19:36:24 <jmcarthur> oh you mean without really specifying what you are deriving at all?
19:36:29 <haploid> ah ok
19:36:32 <dons> haploid: ghci is inside a 'do' block
19:36:34 <ksf> the ghci prompt is a do block
19:36:38 <dons> so imagine you already have: main = do ....
19:36:39 <haploid> ok
19:36:43 <dons> the .... is what you get to type in ghci
19:37:12 <ksf> jmcarthur, yes
19:37:41 <jmcarthur> i suppose it's possible in general
19:37:59 <jmcarthur> but it may depend on what StateT actually exposes
19:38:16 <hstefan> http://codepad.org/3fTlqHg4 wtf?!?!
19:38:16 <jmcarthur> maybe if you derive (a lot) in the definition of StateT then you could derive (a lot) in Foo as well
19:38:18 <ksf> well StateT includes MonadTrans
19:38:56 <ksf> maybe lifting lift to the type level in the general case?
19:39:08 <juhp> so erm ... how much memory does language-python need to build? :)
19:39:28 <jmcarthur> juhp: dunno. how much do you have?
19:39:49 <jmcarthur> i bet if you don't know if you have enough then you probably don't have enough
19:40:08 <ksf> also, newtype deriving understanding MonadIO m => StateT FooS m a would be great
19:40:19 <juhp> jmcarthur: only 4G ;)
19:40:27 <jmcarthur> that should be enough, i'd think
19:40:28 <hstefan> dcoutts: obi-wan, what's the problem now? http://codepad.org/3fTlqHg4
19:40:40 <juhp> jmcarthur: hm well seems not...
19:40:49 <jmcarthur> interesting
19:40:50 <hstefan> I really, REALLY, dont understand this error
19:41:19 <jmcarthur> is language-python that new python compiler?
19:41:25 <jmcarthur> or is it just a parser or something?
19:41:27 <juhp> I still have 2.5G of swap left ;)
19:41:36 <dcoutts> hstefan: it's saying that a TreeView does not implement the TreeModel interface
19:41:45 <juhp> jmcarthur: yeah it is a dep
19:41:48 <dcoutts> hstefan: which is because a TreeView is not a TreeModel
19:42:00 <dcoutts> hstefan: which means you just passed the wrong parameter ;-)
19:42:25 <dcoutts> pass it the one it wants, which is a .... ?
19:42:27 <jmcarthur> juhp: ah, so you are really just trying to build it, like with ghc? seems weird that 4G wouldn't be enough...
19:42:43 <juhp> jmcarthur: nod...
19:42:49 * jmcarthur tries it
19:43:18 <juhp> yeah i was just curious to give it a spin - no python fanboy ;o)
19:43:37 <juhp> good luck - I already shutdown X ...
19:43:55 <jmcarthur> what module does it hang up on?
19:43:59 <jmcarthur> or is it linker?
19:44:05 <juhp> the v3 parser
19:44:30 <dcoutts> hstefan: see the problem?
19:44:58 <hstefan> dcoutts: yep. Fixed.
19:45:04 <jmcarthur> juhp: well, i panicked at 75% of my memory while building Language.Python.Common.ParserUtils
19:45:05 <juhp> Language.Python.Version3.Parser.Parser
19:45:19 <juhp> :)
19:45:22 <jmcarthur> so i control-Ced it
19:45:29 <juhp> jmcarthur: how much do you have? :)
19:45:31 <jinjing> haskell.org down ...
19:45:42 <jmcarthur> i have 4G as well, but i don't really want to start swapping right now
19:45:59 <juhp> (:
19:46:13 <juhp> first machine i tried only had 2G...
19:46:15 <jmcarthur> well... i don't know what to say besides that i've verified the problem
19:46:27 <hstefan> I finally got the index, yay.
19:46:30 <jmcarthur> ghc is known to take a fair bit of memory, but i've never seen it do this much
19:46:33 <juhp> yeah - maybe I'll send Bernie a mail...
19:46:58 <jmcarthur> maybe ask in #ghc if there are any ways you can cut down on its memory usage?
19:47:12 <jmcarthur> might be able to if you sacrifice some optimizations or something, maybe
19:47:35 <juhp> yeah
19:47:38 <aavogt> cabal can be told to give ghc some RTS flags
19:47:43 <ksf> my crystal ball says that it's a bug.
19:47:45 <juhp> jinjing: that's bad :(
19:48:14 <dcoutts> ksf: it's certainly been reported, we'll see what the simons think
19:48:21 <juhp> maybe we should rename #hackage to #haskell-noc ? :)
19:48:31 <jinjing> juhp: indeed
19:48:35 <hstefan> dcoutts: it's almost there
19:48:39 <aavogt> I have this in a package that generates some code that ghc doesn't like:
19:48:40 <aavogt>     ghc-options:    -O2 +RTS -H3000M -M3500M -S -RTS
19:48:46 <dcoutts> juhp: actually we already use #ghc for that :-)
19:48:51 <juhp> hehe
19:48:54 <juhp> :)
19:49:01 <juhp> ok
19:49:25 <juhp> did it get slashdotted by berp? ;o)
19:49:34 <pastorn> booo
19:49:36 <dons> possibly
19:49:46 <pastorn> no GeneralizedNewtypeDeriving for Applicative :/
19:49:58 <pastorn> i have Functor and Monad though, so it shouldn't be hard ;)
19:49:59 <aavogt> collecting garbage more often by limiting the heap size is probably faster than swapping it out
19:50:06 <ksf> generalized works for everything
19:50:15 <aavogt> pastorn: what did you try?
19:50:19 <ksf> I think your monad just doesn't have an applicative instance
19:51:21 <dcoutts> aavogt: yes limiting is definitely faster than swapping, the GC heap does not work well with swap, it's constantly being traversed and pulled out of the swap
19:52:10 <jmcarthur> this is why GC would be best managed by the OS, IMO
19:52:18 <jmcarthur> it can coordinate with swapping
19:52:37 <jmcarthur> in ways i haven't thought about enough to prove effective
19:52:38 <sjanssen> or you could just not swap
19:52:39 <aavogt> dcoutts: so there's no sensible way for ghc to know what a sensible maximum is?
19:52:39 <haploid> people still use swap these days? :)
19:52:41 <hstefan> dcoutts: how do I copy my new list to the previous listStore?
19:52:42 <haploid> ram is so absurdly cheap
19:52:49 <jmcarthur> sjanssen: works great until you hit the OOM killer
19:53:06 <jmcarthur> haploid: because we keep thinking of ways to use all our ram anyway
19:53:15 <dcoutts> aavogt: that seems actually to be really hard given current OS interfaces for giving us info about memory
19:53:33 <jmcarthur> i use swap precisely to avoid the OOM killer (worst linux "feature" ever!)
19:53:35 <juhp> hm ok - whee now vm > 6000m
19:53:40 <dcoutts> hstefan: using clear and repeated append
19:54:01 <pastorn> can't derive Applicative: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25870
19:54:13 <juhp> bpope much have a lot of ram :)
19:54:34 <pastorn> (i did test with "Applicative (StateT S IO)" and not "GS"
19:55:01 <aavogt> dcoutts: so I suppose it might be recommended somewhere to set GHCRTS or whatever that env var is to limit heap size to a bit less than ram?
19:56:27 <dcoutts> aavogt: yeah, if you have a good estimate for your machine
19:56:46 <dcoutts> problem is of course it depends on what else is running, and it's dynamic
19:57:25 <dcoutts> aavogt: one simple thing the rts could do is to check if there is any ulimit in place
19:58:55 <fryguybob> http://hackage.haskell.org/trac/ghc/ticket/3972
19:59:03 <pastorn> here; a cleaner paste that actually loads and screams: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25871
19:59:06 <hstefan> dcoutts: http://codepad.org/QPBQ4v6L okay, it's fully interpreted but why this isn't working? Nothing is shown on screen :S
19:59:20 <pastorn> hstefan: setVisible?
19:59:28 * pastorn is damaged by swing
19:59:50 <systemfault> Eww Java... :/
19:59:54 <pastorn> hehe
20:00:23 <haploid> holy god, length walks the entire list ?
20:00:25 <dcoutts> hstefan: that code looks right to me
20:00:32 <pastorn> haploid: haha
20:00:33 <pastorn> yes :)
20:00:44 <pastorn> haploid: no weird java-like cheats here
20:00:45 <haploid> please tell me ghc optimizes this somehow
20:00:49 <pastorn> haploid: nope
20:00:53 <pastorn> it's a singly linked list
20:00:55 <haploid> wow
20:00:55 <c_wraith> how could it?  The data structure is too simple
20:00:58 <pastorn> it can be infinite
20:01:01 <c_wraith> @src []
20:01:02 <lambdabot> data [] a = [] | a : [a]
20:01:10 <c_wraith> See anywhere in there to cheat?
20:01:14 <mxc> haskell.org dead or just me?
20:01:15 <dcoutts> haploid: we don't do indexing, so it's pretty much ok
20:01:22 <pastorn> > length [1,2..] -- haploid
20:01:26 <lambdabot>   mueval-core: Time limit exceeded
20:01:38 <hstefan> dcoutts: it could look but it actually does nothing @_@
20:01:45 <haploid> heh ok
20:01:58 <dcoutts> hstefan: so is anything shown? or simply nothing happens when you select different items?
20:02:12 <ddarius> haploid: If you need to use length a lot then either you are doing it wrong or you should be using a different data structure.  Lists are the right tool for some jobs, but other data structures are the right tools for others.
20:02:14 <hstefan> nothing happens
20:02:52 <ksf> haploid, maybe you want Data.Sequence
20:03:40 <juhp> mxc: yes jinjing mentioned before
20:03:51 <ksf> which has O(1) length, head, tail (from the beginning and end) and log( min n m) append
20:04:02 <haploid> I was just thinking in terms of performance of string appending, etc.  I guess it's no different than null-terminated strings, but I've been spoiled by Java's StringBuilder, etc
20:04:29 <ksf> yep [] isn't meant for that
20:04:39 <c_wraith> haploid, you might need to think differently, but you can use laziness for append-only operations.
20:05:09 <dcoutts> hstefan: at this stage I often find it reassuring to add debugging print commands into the event handlers just to see if they are firing.
20:05:10 <c_wraith> (well, given stream fusion, anyway)
20:05:30 <ksf> there's even a newtype to invert the appending to prevent blowup on appends, but I forgot the name.
20:05:47 <mxc> juhp - thanks
20:05:55 <jmcarthur> %GC time      72.6%  (71.2% elapsed)
20:05:58 <ksf> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
20:05:59 <ksf> there.
20:06:02 <jmcarthur> and that's after running out of heap
20:07:15 <dcoutts> hstefan: in this case, try printing the sinonimos list that you're adding to the other store, make sure it's not actually empty.
20:07:40 <ksf> c_wraith, but even lazy bytestrings will blow up as soon as they're large enough
20:07:53 <ksf> ...at least afaik
20:07:59 <ksf> they're just a list of chunks, after all.
20:08:09 <applicative> pastorn, it's odd, everything's fine with the natural applicative instance from the monad one, pure = return; (<*>) = ap .
20:08:48 <pastorn> @src ap
20:08:48 <lambdabot> ap = liftM2 id
20:08:56 <pastorn> applicative: hmm...
20:09:06 <ksf> applicative, more often than not there's more than one possible applicative instance
20:09:15 <ksf> ...some of which obey the laws, some don't.
20:09:37 <hstefan> dcoutts: the list is not empty.
20:09:39 <applicative> ksf, i know, i'm thinking that's why they refuse the inference,
20:09:59 <jmcarthur> juhp: it works if you disable optimizations. i haven't tried with just -O1 instead of -O2 though.
20:10:04 <jmcarthur> juhp: -O0 would be insanely slow
20:10:29 <ksf> ...but generalisednewtypederiving should just wrap and unwrap stuff
20:10:30 <jmcarthur> that is, it builds with -O0
20:10:42 <ksf> it doesn't generate "real" code.
20:11:07 <juhp> jmcarthur: ok thanks
20:11:31 <hstefan> its some problem with mapM_
20:11:34 <tomberek> ksf, do you know a lot about Applicative?
20:11:36 <applicative> ksf, isnt this right, though: if a monad instance presupposed a prior applicative one, as applicative does functor, then the situation would be silly.
20:11:39 <hstefan> http://codepad.org/d4GTeMIH
20:11:47 <hstefan> but i dunno what is wrong oO
20:11:51 <hstefan> it appears to be valid
20:12:21 <c_wraith> ksf: if you're just writing the LBS out, and nothing else is holding on to it, chunks will discarded after being written, before the next chunk is generated.
20:12:30 <ksf> monads not requiring applicative is silly in general.
20:13:12 <ksf> c_wraith, I was referring to the append-case
20:13:23 <applicative> ksf, maybe this is a reason for thinking it's right.  the functor and monad instances are more likely derivable.  if we insist on 'deriving Applicative', it wouldn't know what to do
20:13:33 <ksf> where you walk the spine of the leading stuff way too often.
20:13:44 <dcoutts> hstefan: the trick for tracking down type errors is to add type annotations to say what type you think something is, eventually you can narrow down where you and the compiler disagree (but keep in mind, the compiler is always right!)
20:13:47 <rem7> is haskell.org down? I can't seem to be able to access it.
20:13:49 <c_wraith> ksf: that *is* the append case.  If you're appending in pure code (and have stream fusion), it will only be evaluated as necessary for output.
20:13:54 <djahandarie> rem7, yes
20:14:06 <dcoutts> hstefan: so you think that the list model has elements of type (String, [String])
20:14:12 <rem7> djahandarie: is there a mirror somewhere?
20:14:21 <ksf> well it knows what to do if the underlying thingie implements applicative: it just has to re-wrap things.
20:14:34 <djahandarie> That's a good question
20:14:51 <ksf> generalisedNewtypeDeriving can also derive user-defined classes, in general everything.
20:15:02 <djahandarie> I don't believe there is a mirror of haskell.org
20:15:05 <djahandarie> There should be, though.
20:15:07 <ksf> c_wraith, well that's nice
20:15:11 <hstefan> dcoutts: I do.
20:15:22 <rem7> djahandarie: hehe
20:16:30 <dcoutts> hstefan: if you use the ghc -XPatternSignatures extension, you can add type annotations like: (list :: ListStore (String, [String]) ) <- listStoreNew (trieList "" (triePrefix t1 ""))
20:16:38 <ksf> oh and there's DeriveFunctor, btw, which seems to work well unless it won't work.
20:16:55 <aavogt> ksf: that's the usual condition for deriving things :)
20:17:14 <rem7> im trying to get repa working but cabal is complaining about dph not being available... haskell.org is down,,, any suggestions?
20:17:30 <ksf> yes. no.
20:17:30 <hstefan> dcoutts: what it does?
20:17:51 <ksf> we were in the situation before and set up a torrent, but my ktorrent is defunct right now.
20:18:03 <dcoutts> hstefan: the extension lets you use the syntax:  do  (val :: type) <- action
20:18:26 <dcoutts> hstefan: i.e. to use type annotations on the results of actions in a 'do' block
20:18:26 <ksf> we should definitely decentralize the stuff
20:18:28 <pastorn> @pl (\x y -> fmap snd (run x y))
20:18:28 <lambdabot> (fmap snd .) . run
20:18:42 <ksf> or maybe beg google to give us huge, free appengine quotas.
20:18:43 <applicative> rem7, does ghc-pkg list show that you have the dph things
20:18:47 <hstefan> dcoutts: is there any way to get the type of a variable?
20:18:52 <hstefan> and print it on screen
20:19:02 <dcoutts> hstefan: no but you can assert it by using a type annotation
20:19:54 <rem7> applicative: dph things are surrounded with parenthesis... does that mean I have it?
20:20:02 <dons> [: :]
20:20:03 <dons> you mean?
20:20:10 <dons> oh, sorry.
20:20:14 <dons> they're hidden by default
20:20:14 <hstefan> I don't get it.
20:20:17 <applicative> rem7, I think that means they are hidden.
20:20:19 <dons> you have them, if you ask for  them
20:20:25 <gwern> rem7: ssh into c.h.o and get the repo that way?
20:20:51 <applicative> rem7, so you need to do " ghc-pkg expose dph-..."
20:21:07 <juhp> jmcarthur: hmm -O1 grabs 2-3G
20:21:24 <aavogt> http://downforeveryoneorjustme.com/http://code.haskell.org/
20:21:36 <djahandarie> I wonder what is in there that is so memory-intensive to compile
20:21:40 <rem7> applicative: yeah i just looked at it... im gonna try it out, thanks
20:21:50 <dons> aavogt: down for  everyone.
20:22:02 <gwern> djahandarie: doesn't the ghc bug finger some function not being shared?
20:22:03 <djahandarie> dons, no, code.haskell.org is up
20:22:04 <aavogt> c.h.o is up, but haskell.org isn't
20:22:21 <aavogt> hackage is up too
20:22:23 <jbapple> when haskell.org is down, who is/are the correct person/people to notify?
20:22:37 <hstefan> ITS DONEEEEEEEEEEEee
20:22:38 <hstefan> THIS
20:22:39 <hstefan> IS
20:22:42 <hstefan> SPAAARTAAA.
20:22:48 <hstefan> sorry for that.
20:22:50 <dcoutts> hstefan: so what was the final bug?
20:22:52 <applicative> rem7, I went through the same I remember, I have only dph-prim-par exposed at the moment, so maybe thats what all you need: ghc-pkg expose dph-prim-par
20:22:56 <hstefan> dcoutts: thank you lots!
20:22:58 <jbapple> That is, who has the authority to futz with the haskell.org server?
20:23:11 <hstefan> dcoutts: I just changed sinonimos to [sinonimos]
20:23:13 <hstefan> and it works.
20:23:20 <djahandarie> gwern, huh?
20:23:31 <dcoutts> hstefan: oh, that means it only has one item
20:23:36 <gwern> djahandarie: if http is down, go via another protocol
20:23:41 * hackagebot list-extras 0.4.0.1 - Common not-so-common functions for lists  http://hackage.haskell.org/package/list-extras-0.4.0.1 (WrenThornton)
20:23:46 <dcoutts> hstefan: which suggests the model really is using String and not [String]
20:23:57 <rem7> applicative: yeah, but I just realized that its an older version... I guess I need to update? i need 0.4 i have 0.3...
20:24:09 <dcoutts> jbapple: it's more a case of physical access we think, we cannot ssh in
20:24:26 <jbapple> dcoutts: who is "we"?
20:24:32 <jbapple> Also, who has physical access?
20:24:33 <hstefan> its strang.
20:24:35 <rem7> applicative: according to hackage > 6.13 is requiered
20:24:35 <hstefan> strange*
20:24:37 <applicative> rem7, what ghc are you using.  This will soon go over my head
20:24:49 <gwern> dcoutts: oh, we can't ssh in? I assumed c.h.o was still up for ssh
20:24:50 <dcoutts> jbapple: we as in people with accounts and sudo access on haskell.org
20:25:04 <dcoutts> gwern: oh code.h.o? that's ok at the moment afaik
20:25:05 <rem7> applicative: 6.10.4
20:25:06 <applicative> rem7, yes, I have that too, but  it installs with ghc 6.12
20:25:20 <dcoutts> it's haskell.org that is down, all the other *.haskell.org sites are fine
20:25:24 <ezyang> "i,i there should be a nagios instance that sends messages to IRC when things go down"
20:25:31 <tomberek> a |*| b = Wrap $ (|*|) <$> a <*> b    can this be expressed without requiring Applicative? isn't this a fmap?
20:25:35 <rem7> applicative: will it work with 6.10.4?
20:25:39 <jbapple> And dcoutts: the last few times this happened, what was the problem?
20:25:55 <dcoutts> jbapple: I don't recall, but the admins at the university sorted it out
20:26:04 <ksf> newtype EnumFdT m a = EnumFdM { unEnumFdM :: StateT EnumFdS m a } deriving (Monad, Functor, MonadIO)
20:26:08 <ksf> why does that compile?
20:26:19 <ksf> I'd expect it to throw up on MonadIO
20:26:20 <jbapple> dcoutts: which university hosts the server?
20:26:26 <dcoutts> jbapple: yale
20:26:38 <djahandarie> Heh, jmcarthur, juhp, http://hackage.haskell.org/trac/ghc/ticket/3972
20:26:48 <ksf> wait no it's an instance and the context requirement propagates
20:27:02 <jbapple> and haskell.org has been down for ~24 hours now?
20:27:07 <ksf> which possibly means that I should learn prolog to get into that crazy mindset, after all.
20:27:17 <applicative> does ghc 6.10 have "base-4.*"?
20:27:20 <jbapple> Perhaps it's time to pony up some cash to get it hosted by someone with skin in the game
20:27:24 <dcoutts> jbapple: firstly it was the weekend, then it's a US holiday on Monday
20:27:50 <jbapple> It just seems that free hosting from Yale is not working out for the community
20:27:53 <applicative> rem7, does ghc-pkg list show base-4.whatever?
20:28:16 <rem7> applicative: yeah, 3 and 4 show up
20:28:21 <dcoutts> jbapple: we don't have the organisation yet to accept the cash to pay for it ourselves
20:28:56 <ksf> ask google or amazon?
20:29:16 <jbapple> dcoutts: organization like "the organization of orchid lovers" or organization like "organizing your closet"?
20:29:25 <jbapple> Also, who hosts the other haskell servers?
20:29:29 <ksf> organisation like "incorporation"
20:29:30 <jbapple> Galois hosts one or two, right?
20:29:47 <rem7> applicative: after exposing dph-prim-par and seq it still asks for ==0.4.*
20:29:49 <dons> we host hackage
20:29:55 <ksf> maybe the ihg could do it
20:29:56 <dons> i'm sitting next to hackage right now actually
20:29:59 <dcoutts> jbapple: as in an organisation, but doing so requires that we organised ourselves :-)
20:30:00 <dons> its beeping cheerily
20:30:13 <dcoutts> jbapple: yep, galois and the other one is the community server
20:30:18 <djahandarie> dons, don't things tend to beep when they are broken? :P
20:30:23 <dons> not hackage
20:30:24 <pastorn> @hoogle (Eq a) => [a] -> [a] -> Bool
20:30:24 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
20:30:25 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
20:30:25 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
20:30:30 <jbapple> dcoutts: what do you mean "the other one"?
20:30:33 <dcoutts> jbapple: which is cheap commercial hosting and goes down all the time
20:30:36 <jbapple> Are there only two machines?
20:30:48 <dcoutts> jbapple: three in total
20:30:52 <dons> well, 4.
20:31:03 <dons> the VM (c.h.o), hackage/darcs (galois), sparky!!,  and yale
20:31:18 <dcoutts> ok yes, sparky, but it doesn't host any haskell.org services yet
20:31:25 <dons> and we're killing the VM in favor of sparky as we speak
20:31:27 <dons> or as yitz speaks
20:31:36 <dons> and then yale too, fingers crossed
20:31:37 <dcoutts> jbapple: the community server hosts code, community, trac, rt, projects
20:31:49 <djahandarie> Where is sparky at?
20:31:53 <dcoutts> chalmers
20:31:57 <ezyang> dons: Is there the infrastructure for mirroring, yet?
20:32:05 <dons> some, though only alpha stuff
20:32:12 <ezyang> If so, I could pretty easily convince the folks at MIT to mirror Haskell stuff.
20:32:13 <jmcarthur> so will we be able to use a lot of cores on sparky via ssh soon? :D
20:32:25 <dcoutts> ezyang: the problem is that half of it is dynamic
20:32:25 <applicative> rem7, I think you're out of luck, the dph business isn't a cabal-installable sort of thing.  I notice the repa page says it builds on 6.13, recomments 6.13... as what its really built for, etc
20:32:27 <dons> ezyang: i'll show you hackage tomorrow. you can be awed by all the haskell code on it.
20:32:31 <dons> :)
20:32:33 <dcoutts> jmcarthur: yep
20:32:34 <jmcarthur> i'm assuming i know what sparky is
20:32:36 <jmcarthur> awesome!
20:32:39 <ezyang> yay!
20:32:44 <jbapple> dons: What can I do to help migrate off the frequently-broken servers more quickly?
20:32:58 <rem7> applicative: cool thanks. I guess I'll have to rebuild...
20:32:59 <dons> get the yale haskellwiki mediawiki instance running somewhere else
20:33:03 <dons> so we can host it on sparky
20:33:03 <applicative> rem7, but 6.10 isnt mentioned.
20:33:16 <dcoutts> dons: we cannot host haskell.org on sparky
20:33:24 <dons> yale and c.h.o are the most vulenerable machines
20:33:25 <dcoutts> not without talking seriously to chalmers
20:33:26 <dons> hackage is fast and nice now
20:33:30 <dons> dcoutts: indeed
20:33:36 <dcoutts> they have not offered us that level of bandwidth
20:33:41 <jbapple> dons: What is special about the mediawiki instance on yale?
20:33:45 <dons> dcoutts: i guess we need a The Haskell Federation (ala apache) to pay for this
20:33:58 <dons> an umbrella over IHG and haskell.org
20:34:06 <dcoutts> dons: right, or under another org like the SFC
20:34:09 <dons> yeah
20:34:20 <dons> maybe we can make this happen over the summer. i'm keen.
20:34:25 <djahandarie> "Too many acronyms"
20:34:33 <dons> just need to submit certain .pdfs to certain graduate school offices.
20:34:35 <dcoutts> dons: I hope to have more time over the summer
20:34:38 <aavogt> @google thf
20:34:38 <lambdabot> http://en.wikipedia.org/wiki/Tetrahydrofuran
20:34:39 <lambdabot> Title: Tetrahydrofuran - Wikipedia, the free encyclopedia
20:34:48 <jbapple> dons: Or, where can I read more about the specific problems so that I can help more. Is there an email or bug report somewhere about how the mediawiki instance isn't installable elsewhere?
20:35:04 <dons> dcoutts: i'll be done in 4 weeks. might pop over to oxford to watch some cricket and hack :)
20:35:05 <dcoutts> dons: heh, in the old world I have to hand in two printed and bound copies
20:35:12 <dcoutts> dons: :-)
20:35:18 <ezyang> jbapple: Knowing MediaWiki, it's probably more of "someone finding an evening to do the migration"
20:35:32 <ezyang> MediaWiki is quite portable, even with custom skins and whatnot
20:35:33 * dons images post-doc life
20:35:35 <dons> imagines
20:35:35 <pastorn> is there some sort of cool filter function that works a bit like grep -A# -B#
20:35:40 <pastorn> to get hits after and before
20:37:26 <ksf> hmmm mapAccum?
20:37:44 <pastorn> ksf: yeah... that seems doable
20:38:48 <pastorn> ksf: hmm... but i also want filtering functions...
20:38:57 <ksf> going forth and implementing a complete haskell unix userland would be a great thing, btw.
20:39:05 <ksf> if only for all the convinience functions.
20:39:43 <ezyang> ksf: You mean, like cat and filter etc?
20:39:47 <soupdragon> > (71+1)*(71-1)
20:39:48 <lambdabot>   5040
20:39:51 <ezyang> I wonder how you'd get all the flags to play nicely
20:39:51 <pastorn> the worst part is i only need this for testing purposes
20:39:58 <ezyang> s/filter/sed/
20:40:03 <ksf> cat is easy
20:40:13 <ksf> find, grep...
20:40:18 <ezyang> Right-o
20:40:27 <juhp> hmm, now terminfo is giving me hassle
20:40:30 <ezyang> I think the first thing that'd happen if I tried to do that is I'd be like "must make type safe..."
20:41:08 <ksf> ezyang, here's a start: http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=10104
20:41:15 <pastorn> ksf: *lots* of string literals...
20:41:17 <pastorn> i reckon
20:41:46 <pastorn> but it would be cool if you could do
20:41:55 <pastorn> readFile fp >>= less
20:42:07 <pastorn> and have it trigger Vty or whatever
20:42:19 <ezyang>  ksf: Why is find using a map?
20:42:34 <ksf> it's almost as fast as gnu find, which is due to gnu find using trickery to avoid stats
20:42:46 <ksf> to filter out loops
20:42:53 <ezyang> aha
20:43:27 <pastorn> ksf: this seams reasonable? grep :: (Eq a) => Int -> Int -> [a] -> [a]
20:43:35 <pastorn> grep before after xs = ...
20:43:48 <pastorn> oh
20:43:54 <ksf> it will return an entry for every real inode which contains every name it found, which don't include recursive ones.
20:44:09 <pastorn> grep :: (Eq a) => Int -> Int -> [a] -> [[a]] -> [[a]]
20:44:21 <ksf> I guess it should take another function to control what's returned
20:44:23 <ezyang> grep -R or bust!
20:44:28 <ksf> ...and be an iteratee.
20:44:30 * pastorn was having unpure thoughts
20:44:46 <pastorn> ezyang: -R?
20:44:51 <pastorn> what does that do?
20:45:02 <ksf> descend into directories
20:45:14 <pastorn> booo
20:45:17 <pastorn> IO
20:45:18 <pastorn> naughtyness
20:45:28 * pastorn DO NOT WANT
20:45:31 <ksf> which is kinda like find . --exec grep ...
20:45:34 <ezyang> but it's damn useful. >:-)
20:45:58 <pastorn> ezyang: i was more thinking of pure *nix tools...
20:45:59 <ksf> or find . | xargs grep
20:46:41 <ksf> I guess the traditional shell versions of those tools could be implemented in terms of the haskell ones...
20:47:29 <ksf> I was just saying that doing unix utils is a great way to get a decent and useful set of haskell functions
20:48:15 <ezyang> agreed.
20:48:45 <ksf> oh and that find could be incremental. there's inotify.
20:51:33 <pastorn> where in the module heirarchy would all these functions go?
20:51:59 <pastorn> System.Tools ?
20:52:07 <pastorn> System.GNU ?
20:52:10 <ksf> HSH?
20:52:19 <pastorn> hsh?
20:52:36 <ksf> there's always been talk about a haskell shell, but so far there's not even bikeshedding.
20:53:48 <ksf> which I think is mostly due to the fact that people want a bash syntax _and_ not clash with haskell syntax _and_ have both at the same time.
20:54:43 <ksf> and then there's the big question of typed files
20:55:02 <pastorn> ksf: http://www.cse.chalmers.se/~dave/Courses/Topics/SavedProjects/2006-Haskal/
20:57:50 <djahandarie> Is hs-plugins nice?
20:58:57 <ksf> another idea I had is using all that cabal goodness to write a portage drop-in replacement
20:59:17 <ksf> ...which would include a bash shell written in haskell
20:59:32 <ksf> dunno what /sbin/runscript really is.
21:01:29 <mike-burns> sh is a nice DSL but it'd be sweet if I could use Haskell for shell functions.
21:02:18 <ksf> #!/usr/bin/runhaskell
21:02:37 <ksf> then it's a matter of re-creating the shell function interface and dropping it into main
21:03:02 <pastorn> ksf: i was thinking of a typeclass of some sort
21:03:11 <ksf> oh, and you'd have to export those shell variables.
21:03:14 <pastorn> so that each function would have the type
21:03:32 <pastorn> someNixCommand :: a -> Settings -> b
21:03:42 <ksf> and call the rest of the shell script as continuation to be able to export stuff from haskell
21:03:55 <pastorn> and the typeclass would provide defArgs :: Settings
21:04:03 <ksf> ...so I guess re-implementing sh would be a better idea.
21:05:36 <ksf> there's some type-level tricks than can be used to get functions that look like taking variable arguments
21:06:11 <ksf> but I think one would want to integrate with the type checker then, to provide completition
21:06:58 <ksf> ...sounds like a uhc-related master thesis.
21:07:26 <pastorn> ksf: i was just thinking that there should be, for each gnu function, there should be a constant defined with all the default parameters
21:08:19 <pastorn> so that most of the time it'd be 'grep xs xss (defArgs { before = 3, after = 4 })' etc.
21:09:17 <ksf> but you'd have things like "cat -" which is the default, and you'd have to remove the - out of [FileName] if you give an argument
21:09:54 <ksf> yep the bikeshedding doesn't work because there's tens of thousands of different bikesheds that can be painted.
21:09:56 <pastorn> ksf: perhaps each function would come in two versions
21:10:31 <pastorn> "cat" which would be equivalent to "cat -" and "catIO fp" which would be "cat fp"
21:11:02 <pastorn> perhaps this can be done with some typeclass hacks (like Printf does)
21:11:16 * ksf wonders whether one can have zero-arity functions when using typefam trickery to do varargs
21:11:55 <ksf> there are going to have to be parsing hacks, too. I don't want to write cat "file"
21:12:21 <pastorn> ksf: huh?
21:12:22 <ezyang> Bash quoting is pretty horrible... I'll take cat "file" just fine...
21:12:37 <ksf> actually, the shell maps quite well to haskell, there, as the called function analyses the arguments
21:13:03 <ksf> ...mostly. everything but shell quoting and thus argument separation.
21:13:13 <FunctorSalad_> ksf: instance FooType Int where ... ; instance FooType a => FooType (Char -> a) ?
21:13:28 <dolio> The point of type families is to do case analysis on a type, so 0-ary families don't make much sense.
21:13:31 <FunctorSalad_> for a vararg Char -> Char -> ... Int
21:13:48 <FunctorSalad_> oops. "fam" not "class"
21:14:00 <pastorn> what's happened to haskell.org and when will Phoenix make it rise?
21:14:01 <FunctorSalad_> sorry I haven't quite learned to read yet
21:14:23 <ksf> dolio, 0-arity functions, not families.
21:14:37 <ksf> like printf without any format does a newline or such
21:15:21 <FunctorSalad_> "maps quite well to haskell" in which way? did you have the mad idea of implementing basic haskell as bash commands too? ;)
21:15:35 <ksf> wrt. laziness
21:15:37 <dolio> Oh.
21:16:30 <dolio> ksf: I don't think you need type families for that.
21:16:35 <FunctorSalad_> how do you do varargs with just type families?
21:16:51 <ksf> but then, `` is expanded. but passing "1+2" won't spawn some magic thing and pass 3
21:16:53 <FunctorSalad_> (since you were only asking about the 0-ary case, I assume you know how to do the other)
21:17:02 <ksf> it's in the spj+oleg typefam paper
21:17:31 <ksf> I'm generally too tired to think about anything too complex right now, anyway.
21:17:54 <dolio> ksf: class PrintfFun a where printf :: a ; instance PrintfFun String where printf = "\n" ; ... ; instance FormattedPrintf a => PrintfFun (String -> a) where printf s = formattedPrintf s ; ...
21:18:00 <FunctorSalad_> well... nothing forces one to use `` ;)
21:18:10 <dolio> formattedPrintf being the current printf.
21:18:36 <ksf> oh, not just varargs, but variable typing based on a format type
21:18:56 <ksf> ...as we don't have dependent types there's no way to use strings, there
21:19:00 <ksf> except using TH
21:19:44 <pastorn> ksf: will you really be needing varArgs if you do like i suggested with defaultArgs ?
21:19:50 <ksf> `` can be jolly useful, for abut the same reasons as xargs
21:20:33 <jballanc> Can someone point me to a mirror for the latest stable GHC?
21:20:58 <ksf> pastorn, cat can take an infinite number of arguments
21:21:14 <pastorn> ksf: a list....
21:21:16 <ksf> ...at least on unices that support infinite argv[]
21:21:56 <FunctorSalad_> ksf: of course it can, but I meant in a hypothetical bash that makes more use of this call-by-name capability/lazyness
21:21:58 <ksf> yeah you're right. but I would hate the recordy syntax
21:22:02 <pastorn> catIO (defa { files = [ fp0, fp1, ..... ] } )
21:22:15 <aavogt> pastorn: the list doesn't allow args of differing type...
21:22:24 <aavogt> or that list doesn't
21:22:26 <FunctorSalad_> xargs is very nice, yes ;)
21:22:54 <pastorn> i don't know xargs, but doesn't xargs map well to 'map'/'mapM'?
21:23:03 <jballanc> ah, nevermind...I see that darcs.h.o is still up
21:23:11 <ksf> mapM, yes.
21:23:19 <FunctorSalad_> I was just going to say it... xargs -n1 is basically Prelude.map
21:23:20 <aavogt> pastorn: it maps to your format string having a fancier type
21:23:36 <ksf> you can emulate it with for `...` do
21:23:38 <aavogt> disregard that
21:23:46 <pastorn> hmm... maybe with applicative...
21:23:49 <aavogt> I got confused with xformat
21:24:26 <FunctorSalad_> ksf: but that's "subject to word splitting" I think ;)
21:24:37 <FunctorSalad_> as some manpages like to say it
21:24:59 <pastorn> cat <*> set files [fp0, fp1, ...] <*> set someOtherArg someOtherVal <*> pure defArgs
21:25:07 <FunctorSalad_> ok, plain xargs is vulnerable to newlines too
21:25:12 <FunctorSalad_> but xargs -0 ftw
21:25:22 <pastorn> ksf: ^^^
21:25:42 <pastorn> that would require som of those records libraries
21:25:45 <pastorn> copumpkin: hello
21:25:48 <copumpkin> allo
21:25:55 <copumpkin> I'm up early!
21:25:57 <ksf> FunctorSalad_, IFS!
21:26:10 <pastorn> copumpkin: we're discussing making GNU tools as haskell functions
21:26:14 <copumpkin> :o
21:26:16 <FunctorSalad_> oh
21:26:18 <ksf> you know you're using the wrong language for the job when you start messing with it.
21:26:27 <FunctorSalad_> pastorn: not other way around?
21:26:44 <FunctorSalad_> ksf: with shell-quote bash gets pretty good macro capabilities actually ;)
21:26:45 <pastorn> FunctorSalad_: i'm not sure about the order of anything here
21:26:50 <FunctorSalad_> (apropos messing)
21:27:07 <FunctorSalad_> at least if shell-quote is perfect and not just another hack... I don't know
21:28:01 <hstefan> hey there. How do I set a function that will be executed every time that user presses 'Enter'? (using gtk2hs)
21:28:22 <ksf> I only had to have a brief look at some latex packages to be convinced of macro languages' superiour capabilities (to produce messes)
21:28:33 <FunctorSalad_> :)
21:28:37 <djahandarie> http://holumbus.fh-wedel.de/hayoo/hayoo.html is giving a server error again... :(
21:28:53 <FunctorSalad_> I meant shell-quote helps to decrease the messes a bit...
21:29:23 <freiksenet> meh, this is the shame that haskell.org is still down :[
21:29:30 <freiksenet> a*
21:29:32 <ksf> bah the fh changed the hostnames to be boring
21:29:35 <FunctorSalad_> eval $(shell-quote -- BLAH1 BLAH2 ...) should be equivalent to BLAH1 BLAH2
21:29:41 <FunctorSalad_> or something...
21:30:01 <ksf> back in my days they were named after alcohol, alcohol percentage being directly correlated to machine speed.
21:30:42 <FunctorSalad_> that doesn't sound like it'd withstand moore's (generalized) law for long
21:30:52 <pastorn> hmm...
21:31:16 <pastorn> is it possible to make a vararg typeclass that takes functions as arguments
21:31:22 <pastorn> ?
21:31:33 <ksf> well the fastest machines were always used for the same stuff, so the student files were always served from smirnoff
21:31:33 <copumpkin> no
21:31:37 <pastorn> so that you could take arguments of type (ArgSet -> ArgSet)
21:31:48 <FunctorSalad_> assuming you don't start with some drink that has 1E-9 alcohol concentration or so
21:31:52 <pastorn> ok, maybe with a constructor then...
21:31:52 <copumpkin> pastorn: arguments to what?
21:32:08 <FunctorSalad_> ah, so machines would have to get renamed over time
21:32:44 <ksf> yep at the same rate as hardware got upgraded
21:32:53 <pastorn> copumpkin: i have an idea that if you are to embedd *nix tools in haskell that there should be a typeclass for all the arguments
21:33:05 <pastorn> and a defaultArgs constant for each function
21:33:05 <copumpkin> hmm
21:33:11 <ksf> smirnoff was also the cpu server for those sparc stations that were used as internet terminals
21:33:29 <aavogt> hmm, varargs without newtypes for function-valued arguments
21:33:59 <aavogt> could it work if you knew for sure that the next argument was a function of given arity?
21:34:04 <FunctorSalad_> pastorn: I've thought about it but maybe the slight sugar isn't worth the complication of typeclasses :|
21:34:26 <FunctorSalad_> is "ls :: [LsOption] -> IO [String]" really so bad?
21:34:41 <FunctorSalad_> monomorphic, zero type system headache
21:34:46 <pastorn> FunctorSalad_: yes, with haskell syntax it is
21:35:31 <pastorn> ok, how about this then
21:35:36 <FunctorSalad_> well if you make a bogus monad you can abuse do notation to leave out the commas
21:35:39 <FunctorSalad_> :)
21:35:52 * ksf would like to have a dd If "/foo" Of "/bar" If "/baz" which gives a type error on the second if
21:35:54 <pastorn> each function has a default config already givet no it
21:35:55 <copumpkin> you also lose type safety on options
21:36:09 <ksf> as I said, completition is related to type checking
21:36:10 <pastorn> cat = rawCat defaultCatArgs
21:36:29 <copumpkin> meow
21:36:39 <FunctorSalad_> ksf: that could be done in "my" way too, with a category or something
21:36:45 <FunctorSalad_> instead of TCs
21:36:55 <FunctorSalad_> hmm bad abbreviation
21:36:58 <FunctorSalad_> typeclasses
21:37:02 <FunctorSalad_> (not typecons)
21:37:05 <pastorn> maybe i'm "weird" for wanting these functions to be pure...
21:37:23 <FunctorSalad_> LsOption :: (* -> * -> *)
21:37:30 <FunctorSalad_> instance Category LsOption where ...
21:37:39 <FunctorSalad_> or well, DdOption
21:37:44 <pastorn> but maybe that's because i started this by wanting to write 'grep'
21:37:54 <FunctorSalad_> dd (If "foo" . Of "bar")
21:38:08 <pastorn> heh
21:38:16 <pastorn> who's gonna write 'awk'?
21:38:23 <pastorn> ksf: i assign you!
21:38:29 <aavogt> cat tartare
21:38:33 <ksf> there's no way to get around dropping into a monad as soon as you deal with some other thing that runs concurrently to you that you can't control, no matter how pure your OS is
21:38:51 <pastorn> ksf: true...
21:39:13 <pastorn> maybe they should all be their own module
21:39:33 <pastorn> Nix.Cat, Nix.Grep, Nix.Touch etc...
21:39:38 <FunctorSalad_> (now you'd have to carefully make DdOption a GADT such that (If "foo" . Of "bar" . If "foo") is incorrect)
21:39:47 <FunctorSalad_> is it possible?
21:39:55 <pastorn> but it would be cool if it could be unified...
21:40:48 <pastorn> http://en.wikipedia.org/wiki/Grep <-- bottom of page...
21:40:53 <pastorn> that's a *lot* of tools...
21:41:40 <ksf> touch foo == echo -n >> foo
21:41:59 <ksf> unix is the domain of there's many more less obvious ways to do it
21:43:00 * FunctorSalad respawned
21:43:15 * ksf cospawns
21:43:34 <FunctorSalad> in case someone replied about whether one could make statically-checked argument lists using GADTs...
21:43:48 <FunctorSalad> (of course one could, but with an easy-to-use result...)
21:43:57 <FunctorSalad> like ksf's dd example
21:45:08 <FunctorSalad> wouldn't completely avoid typeclasses I guess :(
21:46:47 <juhp> ah so language-python currently only builds out of the box with ghc-6.10.4 due to a ghc issue
21:47:18 <juhp> does lambdabot talk trac?
21:47:25 <FunctorSalad> hmm or... data DdOptions where { If :: String -> DdOption (a,IfUnset) (a,IfSet) ; Of :: String -> DdOption (OfUnset, b) (OfSet, b) }
21:47:37 <FunctorSalad> that looks like it could work :)
21:48:26 <FunctorSalad> Of "blah" . If "blub" would have type DdOption (OfUnset,IfUnset) (OfSet,IfSet), right?
21:48:45 <FunctorSalad> so you couldn't compose it with another If or Of
21:48:48 <copumpkin> is it just me or did traffic to haskell-cafe die down a lot
21:48:51 <FunctorSalad> (.) is Category/Arrow composition, btw
21:49:06 <FunctorSalad> and DdOption would need a free composition constructor too
21:49:20 <FunctorSalad> I like this... :)
21:56:36 <hstefan> how do I set an key to activate a button on gtk2hs?
22:07:05 <hstefan> anyone here?
22:07:12 <copumpkin> nope
22:07:38 <hstefan> lol
22:07:48 <hstefan> copumpkin: do you know about gtk2hs?
22:08:04 <copumpkin> nope
22:13:54 <FunctorSalad> oh no, ksf is gone already
22:14:28 <FunctorSalad> and I just proudly coded up the statically checked DD :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25872#a25872
22:14:40 <FunctorSalad> with no typeclasses :o
22:15:53 <aavogt> GADTs aren't sort of equivalent?
22:15:55 <FunctorSalad> (and arbitrary arg order)
22:16:11 <FunctorSalad> (and you could even do smarter stuff there)
22:16:14 <soupdragon> what does this code do?
22:16:29 <aavogt> it types dd
22:16:33 <FunctorSalad> soupdragon: smart varargs
22:16:46 <FunctorSalad> by making the argument list type a category
22:17:12 <FunctorSalad> "If0" means "if is unset", "If1" = "if is set"
22:18:42 <soupdragon> what lol
22:18:46 <soupdragon> I can't understand this
22:18:57 <FunctorSalad> aavogt: hmm GADTs and typeclasses?
22:19:41 <FunctorSalad> soupdragon: maybe "man dd" helps? ;)
22:20:00 <FunctorSalad> it's a command that (ignoring all the other parameters) is called like: "dd if=foo of=bla"
22:20:07 <FunctorSalad> or "dd of=bla if=foo"
22:20:08 <soupdragon> ohh
22:20:19 <FunctorSalad> with just a single of/if allowed
22:25:27 <copumpkin> aavogt: typeclasses can be represented by a dictionary of methods that's passed implicitly and looked up automatically
22:25:37 <copumpkin> i.e. a one-constructor datatype
22:27:23 <Schalken> Is it just me or is haskell.org down?
22:27:48 <copumpkin> down here
22:28:27 <Heffalump> it's been down for over a day :-(
22:28:50 <hydo> Does anyone have any recommendations on how to generate resonably non-predictable unique identifiers?  I've been using system-uuid up until now and just figured out that there's no support on the target os (freebsd).
22:29:19 <hydo> I never realized how much I could miss hoogle until it was gone. :(
22:29:31 <copumpkin> Heffalump: is that why -cafe seems dead too?
22:31:01 <hydo> hrm... maybe I'll go the concat-some-user-data-with-epoch-seconds-to-md5 method of identifier generation...
22:31:29 <BMeph> @hoogle something
22:31:30 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
22:31:50 <hydo> ! oh... nice.  It wasn't working earlier today.
22:32:08 <BMeph> copumpkins: Yes, h.o handles the mailing lists (mentioned earlier). :)
22:32:21 <FunctorSalad> hydo: sounds rather unpredictable to me, but I wouldn't know
22:32:53 <FunctorSalad> (well, maybe take fractional seconds too ;))
22:33:19 <hydo> FunctorSalad: it's not incredibly critical that it's super-amazing unpredictable... just needs to be enough to ensure that i'll never get two of the same thing.
22:33:20 <Heffalump> copumpkin: I guess so, don't know. I heard on here yesterday (Monday) that it was just Apache that was down, but I don't have any first-hand or authenticated information.
22:34:02 <FunctorSalad> (but then, the time-based part doesn't help very much against someone who can try many possibilities)
22:34:11 <hydo> system-uuid was the fire and forget method that I picked when I started the project.
22:34:33 <FunctorSalad> hydo: oh, mere uniqueness is easier than unpredictability
22:35:25 <FunctorSalad> e.g., someone malicious could just try all the plausible seconds if you used just seconds, even if seconds are reasonably unique for your purpose
22:35:37 <hydo> FunctorSalad: true... my logic said that uniqueness and unpredictability might = super uniqueness. heh
22:35:45 <hydo> not completely sound logic, but there you go.
22:36:04 <jbapple> Heffalump, copumpkin: above, somebody said that SSH is down, too
22:36:06 <hydo> high definition uniqueness!
22:36:28 <jbapple> so it needs someone at the physical location of the machine
22:36:32 <jbapple> Which is at Yale
22:36:36 <jbapple> which is in the US
22:36:45 <jbapple> which just had a Monday holiday :-(
22:41:20 <FunctorSalad> isn't the problem now that it's night, not that a holiday is just over? ;)
22:41:36 <FunctorSalad> </smartassery>
22:44:03 <faure> Hi all, I'm a python/php and javascript programmer, thinking of learning either haskell or lisp for fun. which do you guys think is better to learn first?
22:44:30 <dons> if you learn haskell, you'll already know lisp. the opposite isn't true
22:44:43 <alip> i have a .chs file and a corresponiding .hs-boot file for it but cabal doesn't copy the boot file into dist when building, manually copying it the build works fine. how can i make cabal copy it over?
22:44:56 <dons> dcoutts_: ^^
22:44:56 <faure> dons: I was hoping for an answer like that. thanks
22:45:00 <dons> good question alip
22:45:36 <dons> faure: go to hackage.haskell.org/platform , install haskell, and work through learnyouahaskell.com :)
22:45:41 <FunctorSalad> you could manually copy it in a userHook? I don't know any Cabal API really, but adding basic hooks is easy
22:46:02 <FunctorSalad> (filling the hooks, that is)
22:47:12 <FunctorSalad> (you simply use this in Setup.hs http://hackage.haskell.org/packages/archive/Cabal/1.8.0.4/doc/html/Distribution-Simple.html#v%3AdefaultMainWithHooks )
22:47:19 <aavogt> dons: I'm not sure our metaprogramming is really comparable
22:47:55 <aavogt> I think it's mostly because it's less necessary that template haskell has not developed so much
22:48:06 <FunctorSalad> err, or I guess that, even simpler, nothing is stopping you from doing a (system "cp Foo.hs-boot dist/...") before the call to defaultMain
22:50:16 <dons> its certainly not. if you really want to learn (especially runtime) metaprogramming as a technique, look at lisp.
22:50:36 <dons> TH is type compile time metaprogramming, so a bit different
22:50:38 <dons> typed.
22:51:21 <dons> TH is pretty well developed (nearly 10 years old!)
22:51:35 <dons> http://portal.acm.org/citation.cfm?id=636528
22:52:41 <faure> I don't really understand the advantages of lisp-style metaprogramming. I try to keep reading about it but I don't get it
22:52:59 <aavogt> my main complaints are that reify is a bit lacking and you can't get any Expr into pattern quasiquotes
22:53:30 <aavogt> also, there's not [p| |]
22:53:38 <FunctorSalad> and splicing names...
22:53:42 <FunctorSalad> (or is that possible?)
22:54:00 <aavogt> FunctorSalad: so implicitly take   Name -> Expr?
22:54:25 <FunctorSalad> aavogt: or Type, or Pattern ...
22:54:29 <FunctorSalad> or class names
22:54:38 <aavogt> I'm not sure Name knows whether it refers to a constructor or type or some other namespace
22:55:06 <aavogt> at least the results of mkName don't carry that along
22:55:09 <FunctorSalad> probably not, but it doesn't need to :)
22:55:34 <aavogt> hmm, can you actually be unambiguous there?
22:56:00 <FunctorSalad> I just had this case in mind: mkFoo = $(let name = ... in [d| $(name) x y = ... |])
22:56:24 <FunctorSalad> isn't it clear from context that a value identifier is needed?
22:57:18 <FunctorSalad> sorry, forget the '$'
22:57:29 <FunctorSalad> (the outer one :))
22:57:42 <FunctorSalad> that one should be at the point mkFoo is used
22:57:43 <aavogt> use syb to replace that name after the fact?
22:57:48 <FunctorSalad> hehe
22:57:51 <FunctorSalad> would work
22:58:32 <aavogt> though then you need to (==) `on` nameBase or something before replacing it
22:59:13 <dons> equating nameBase
22:59:20 <FunctorSalad> or match one level earlier, on the ValD...
22:59:28 <FunctorSalad> or FunD
22:59:56 <FunctorSalad> actually that's probably the toplevel of the result, so no syb needed really  ;)
23:00:09 <aavogt> @hoogle equating
23:00:09 <lambdabot> No results found
23:00:18 <FunctorSalad> > [d| needzName x y = x + y |]
23:00:19 <lambdabot>   <no location info>: parse error on input `='
23:00:19 <dons> oh, maybe equating didn't survive
23:00:26 <aavogt> dons: it used to exist?
23:00:28 <dons> ?hoogle comparing
23:00:28 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
23:00:35 <dons> by analogy
23:00:35 <FunctorSalad> now why doesn't that work? :(
23:00:40 <dons> maybe it was just a dream
23:00:49 <aavogt> FunctorSalad: because there's no TH here
23:01:02 <FunctorSalad> ah that was the other bot
23:01:07 <FunctorSalad> lunabot :(
23:01:16 <FunctorSalad> where are you :(
23:01:21 <aavogt> it _should_ be safe if you don't export runIO
23:02:14 <FunctorSalad> he so this was somehow valid vanilla haskell up to the `='? ;)
23:02:44 <aavogt> a list comprehension perhaps
23:02:46 <FunctorSalad> ... lexically, I guess
23:02:48 <FunctorSalad> yes
23:02:57 <aavogt> > [d| 1 == 1]
23:02:58 <lambdabot>   [d]
23:03:12 <FunctorSalad> lol
23:03:15 <FunctorSalad> Expr?
23:03:21 <aavogt> I guess
23:03:26 <FunctorSalad> @ty d
23:03:26 <lambdabot> Expr
23:07:50 <FunctorSalad> aavogt: I didn't get this about Expr (the TH one) and pattern quasiquotes, btw
23:08:41 <aavogt> FunctorSalad: you can emulate nice 'patterns' like  \[$f| x y z ... |] -> ...
23:09:07 <aavogt> if you're allowed functions in Pat you can do or-patterns, patterns on bits
23:09:28 <FunctorSalad> ok, but what's the problem?
23:09:53 <FunctorSalad> that you're just given a string in the qqoter?
23:09:57 <FunctorSalad> *quasiquoter
23:09:59 <aavogt> which looks nicer than a view pattern, because the variables you bind are right in there
23:10:20 <aavogt> and view patterns would be runtime checked without getting fancy with types...
23:10:27 <aavogt> (the same situation as printf)
23:10:45 <aavogt> FunctorSalad: it's that the output of the quasiquoter is  Pat
23:10:59 <aavogt> and Pat doesn't let you apply any functions
23:11:38 <FunctorSalad> but... you want just a pattern in that position, no?
23:11:54 <aavogt> how would you take apart the bits of an integer?
23:13:22 <FunctorSalad> well... only possible with view patterns as you say, if the integer is outside the brackets :)
23:13:47 <FunctorSalad> so you want a sort of compile-time evaluation, I see
23:13:59 <FunctorSalad> on the Exp level
23:14:03 <aavogt> oh no
23:14:15 <aavogt> the generated pattern calculates things at runtime
23:14:32 <aavogt> but the types there depend on what you write at compile time
23:14:35 <alip> FunctorSalad: thanks, i've added a prebuild hook to Setup.hs, now it works when I do "runhaskell Setup.hs build" but _not_ when i do "cabal build" why?
23:14:58 <FunctorSalad> alip: build-type:Custom in the .cabal maybe
23:15:27 <FunctorSalad> aavogt: why not the view pattern then?
23:16:30 <alip> FunctorSalad: \o/
23:16:37 <alip> thanks :)
23:16:47 <aavogt> FunctorSalad: for the same reason you might use a TH-based printf instead of one that uses typeclasses and a fancy typed format 'string'
23:17:18 <aavogt> first, the syntax will be less noisy, and more monomorphic types make for better errors
23:17:23 <FunctorSalad> but... that does dissect the string at compile-time... *confused* :(
23:17:29 <FunctorSalad> yes, I agree
23:17:55 <aavogt> FunctorSalad: so you dissect a string at compile time, but generate a function for runtime
23:18:14 <FunctorSalad> "printf" requires the string as a macroexpansion-time argument
23:18:29 <FunctorSalad> and that can be done with a pattern now, no?
23:18:49 <aavogt> so do pattern quasiquotes
23:18:53 <FunctorSalad> you just can't take the bits of a outside-any-Th-constructs integer
23:19:22 <aavogt> FunctorSalad: the problem is that the return type of the QQ for patterns (Pat) isn't rich enough
23:20:03 <aavogt> you couldn't write n+k patterns with them
23:20:10 <FunctorSalad> [$bits| x = 155 |] wouldn't work?
23:20:21 <FunctorSalad> if you parse the integer yourself
23:20:27 <aavogt> (for unnatural numbers)
23:20:55 <FunctorSalad> (as a pattern)
23:21:06 <aavogt> FunctorSalad: you can parse the 155 no problem
23:21:21 <aavogt> but parsing the integer that's being matched on is the problem
23:22:13 <FunctorSalad> which other integer?
23:22:28 <aavogt> the one whose bits you're looking at
23:22:32 <FunctorSalad> can you give an example how it would be used?
23:22:40 <FunctorSalad> if it existed ;)
23:23:23 <aavogt>  [$bits| 1x0y |]
23:23:57 <aavogt> matches on a number where the 4th bit is 1, the 2nd is 0, and binds x and y to the 3rd and 1st bits respectively
23:24:34 <FunctorSalad> ok, the integer being matched on isn't inside the quoted thing
23:24:43 <aavogt> that's the whole point :)
23:24:48 <FunctorSalad> hmm
23:29:26 <dons> i don't want to alarm anyone but ... http://i.imgur.com/TSr8a.png
23:29:57 <FunctorSalad> :)
23:30:10 <aavogt> 2121 looks too much like a date
23:30:33 <aavogt> "in 2121, that is how many libraries we will have!"
23:31:54 <dons> 2121!!!
23:33:15 <tomberek> correlating with pirates? where's the spaghetti monster?
23:34:26 <dons> STOP UPLOADING TO HACKAGE!
23:34:45 <Silvah> ?
23:35:05 <dons> Silvah: joke :) its causing pirates
23:35:28 <FunctorSalad> no no, the common cause is global warming
23:35:51 <dons> oh yes, http://www.worldwatch.org/brain/images/press/news/temp.gif
23:35:53 <dons> zoom in, pan left.
23:36:07 <dons> it all makes sense now
23:36:20 <dons> http://donsbot.files.wordpress.com/2010/05/hackage-june-2010.png
23:36:35 <dons> there's no other explanation
23:36:41 <c_wraith> global warming causes packages to be uploaded to hackage?
23:36:46 <FunctorSalad> haskell libraries react faster if the temperature is higher
23:37:14 <dons> the hydrogen bonds, you see.
23:37:37 <Silvah> What's 'global warming'? Do you mean that fictitious thing...?
23:39:53 <djahandarie> dons, just out of interest, do you have some statistic like "# of commits" or something we could overlay on that? I think that'd give an interesting insight to how many of those packages are actually being updated
23:40:27 <dons> oh, i have the uploads-per-day graph
23:40:43 <djahandarie> Yeah that sort of thing
23:40:50 <dons> http://www.galois.com/~dons/images/hackage-daily-graph.png
23:40:56 <dons> moving average of new releases per day
23:41:05 <dons> while the other one is cumulative new packages
23:41:24 <dons> but we'd need to see something like: what packages have been updated regularly over 3 years
23:41:32 <dons> or are updated "regular" or reached "stable"
23:41:33 <dons> tricky
23:41:54 <djahandarie> Hm yeah
23:44:04 <FunctorSalad> meh, does `yi' have impossible dependencies for you too? wants tranformers==0.1.*, which apparently isn't available anymore :/
23:44:42 <djahandarie> Yes
23:44:47 <FunctorSalad> or actually the problem is data-accessor-monads-fd-0.2.0.1. It requires
23:44:47 <FunctorSalad> transformers ==0.2.*.
23:44:55 <djahandarie> Try data-accessor-monads-fd==0.2 data-accessor==0.2.1.
23:45:06 <djahandarie> Try data-accessor-monads-fd==0.2 data-accessor==0.2.1.2
23:46:32 <djahandarie> yi requires transformers ==0.1.*, and data-accessor-monads-fd >= 0.2 & < 0.4. The issue is that data-accessor-monads-fd-0.2.0.1 requires transformers 0.2.*
23:46:46 <djahandarie> So if you have a late enough data-accessor-monads-fd it'll fail
23:46:54 <djahandarie> Same problem with data-accessor
23:47:00 <FunctorSalad> omg, it does something now
23:47:08 <FunctorSalad> (c i data-accessor-monads-fd==0.2 data-accessor==0.2.1.2 yi)
23:47:18 <djahandarie> :-)
23:47:33 <FunctorSalad> (abbreviation script)
