00:10:53 <RyanT5000> anyone want a job writing video games in Haskell?
00:13:21 <pastorn> yes
00:13:22 <pastorn> gief
00:13:35 <RyanT5000> my company's accepting applications right now :)
00:13:40 <pastorn> wut?
00:13:42 <pastorn> 4 realz?
00:13:44 <RyanT5000> yup
00:14:02 <pastorn> do i have to be on location?
00:14:41 <RyanT5000> nah; we're in Boston and you'd be welcome to come in if you happen to be :)
00:17:06 <copumpkin> RyanT5000: ooh
00:17:14 <RyanT5000> hey copumpkin :)
00:17:18 <RyanT5000> would you like to work for us?
00:17:23 <copumpkin> hey :)
00:17:26 <RyanT5000> it's been a while
00:17:30 <RyanT5000> we've made a ton of progress since then
00:17:38 <RyanT5000> we're getting very close to release indeed
00:17:46 <copumpkin> actually yeah, but I'm disappearing for a month or two to italy :/
00:17:48 <copumpkin> I quit grad school
00:18:11 <RyanT5000> ah, well that's bad timing
00:18:14 <copumpkin> yeah :/
00:18:18 <RyanT5000> hopefully we'll be basically done by then
00:18:22 <copumpkin> :)
00:18:25 <RyanT5000> however, you should talk to me when you get back
00:18:28 <RyanT5000> we'll see if we can arrange something
00:18:36 <copumpkin> yeah, will definitely do that! :)
00:19:08 <RyanT5000> cool :)
00:25:34 * hackagebot bein 0.1 - Bein is a provenance and workflow management system for bioinformatics.  http://hackage.haskell.org/package/bein-0.1 (FrederickRoss)
00:30:34 <wvd> A type class just defines certain behaviour for members of the typeclass?
00:30:42 <wvd> s/type class/typeclass/
00:31:40 <RyanT5000> typeclasses define a set of functions (or values) whose implementations depend on the type of their arguments or results
00:31:56 <RyanT5000> it's a lot like overloading in C++, but much more cleanly defined
00:32:19 <RyanT5000> it's also known as ad-hoc polymorphism: http://www.haskell.org/haskellwiki/Ad-hoc_polymorphism
00:32:20 <wvd> And could these be conflicting?
00:32:36 <RyanT5000> by default, Haskell doesn't allow you to define conflicting implementations
00:32:37 <wvd> e.g. Eq defines behaviour for == and /= but what if I made my own typeclass who defines behaviour for == and /= also?
00:32:54 <wvd> Ah, ok
00:32:58 <RyanT5000> if you make a new typeclass, then it'll be a symbol conflict
00:33:06 <markus3> yes
00:33:08 <RyanT5000> you'll have to specify module names
00:33:09 <RyanT5000> e.g.:
00:33:14 <RyanT5000> Prelude.== and MyModule.==
00:33:30 <wvd> But which will be standard?
00:33:33 <wvd> If I only would do "=="
00:33:52 <RyanT5000> if both are in scope, == alone will be illegal
00:33:56 <RyanT5000> because it's ambiguous
00:34:13 <wvd> ok
00:34:25 <wvd> Well, i'll see later. I'm just reading about typeclasses on LYAH
00:34:33 <RyanT5000> however, you can use the "instance" keyword to define new *implementations* of == and /=
00:34:36 <RyanT5000> which use the same typeclass
00:34:48 <RyanT5000> you can only have one instance per type
00:35:06 <RyanT5000> (there are some extensions that make it a bit more complicated than that)
00:35:16 <ManateeLazyCat> I have "(?>=) :: Monad m => Maybe a -> (a -> m ()) -> m () ", but sometimes, i need write "fooA >>= \ ?>= \maybeA -> fooB >>= \ ?>= \maybeB -> fooC >>= \ ?>= \maybeC -> ....  so have any tips that avoid write a *Just* do list ?
00:36:52 <RyanT5000> ManateeLazyCat: i haven't totally parsed what you're asking, but maybe some kind of monad transformer would be in order?
00:37:19 <ManateeLazyCat> RyanT5000: I have read MaybeT, but i don't like it.
00:37:31 <RyanT5000> ah; well that's about as much advice as i have, then :)
00:38:45 <ManateeLazyCat> RyanT5000: I have some code, just execute when match *Just foo*, sometimes, i have recursive *Just foo*, and any *Nothing* match will return ()
00:39:11 * ManateeLazyCat pasted "example code." at http://paste2.org/get/851822
00:39:16 <ManateeLazyCat> RyanT5000: Like above code.
00:39:26 <RyanT5000> have you thought about using a "do" statement?
00:39:41 <RyanT5000> you seem to have a "drifting right" problem there
00:40:02 <ManateeLazyCat> RyanT5000: If you do, i need write many template variable, that's unnecessary.
00:40:12 <RyanT5000> also, if you use MonadError or similar, you can deal with pattern match failures using `catch`
00:40:19 <RyanT5000> so you could just have something like
00:40:29 <RyanT5000> Just x <- blah
00:40:29 <RyanT5000> Just y <- blah'
00:40:39 <RyanT5000> with a big catch around the whole thing
00:40:45 <glguy> What was ?>=  ?
00:40:48 <RyanT5000> though i don't think i really understand what you're getting at
00:41:14 <ManateeLazyCat> RyanT5000: You mean, i use fromJust or similar, and don't care Nothing, then at outside use `catch` catch error?
00:41:33 <ManateeLazyCat> (?>=) :: Monad m => Maybe a -> (a -> m ()) -> m ()
00:41:33 <ManateeLazyCat> m ?>= f = maybe (return ()) f m
00:41:34 <RyanT5000> you can't use fromJust; it calls "error"
00:41:48 <RyanT5000> what you want is something softer than that
00:41:52 <RyanT5000> that won't kick you into IO
00:42:02 <RyanT5000> (though i see that you're already in IO, so maybe that's not such a big deal)
00:42:26 <glguy> ManateeLazyCat: make a single operator that does >>= and ?>=
00:42:33 <glguy> and then put all your \ lambdas on teh right side
00:42:37 <glguy> and you won't need to keep indenting
00:42:42 <glguy> or parenthesizing
00:42:43 <ManateeLazyCat> glguy: Use (?>=), i don't need write *Nothing* branch, just care *Just* branch.
00:43:18 <ManateeLazyCat> glguy: Good point. :)
00:43:41 * hackagebot bein 0.2 - Bein is a provenance and workflow management system for bioinformatics.  http://hackage.haskell.org/package/bein-0.2 (FrederickRoss)
00:43:55 <ManateeLazyCat> RyanT5000: I know you mean, but i don't like `catch` solution. :)
00:43:58 <glguy> ManateeLazyCat: also, your (?>=) is in the library as "for_"
00:44:22 <ManateeLazyCat> RyanT5000: If i write "Just x <- bal" code, then i need careful when copy code to otherplace.
00:44:37 <glguy> We often define an operator (>>=?) :: Monad m => m (Maybe a) -> (a -> m (Maybe b)) -> m (Maybe b)
00:45:09 <RyanT5000> ManateeLazyCat: yeah, that's true
00:45:55 * ManateeLazyCat I never use "Just x <- bla", i use " maybeError m str = fromMaybe (error $ "Just crash : " ++ str) m " instead.
00:47:03 <ManateeLazyCat> RyanT5000: Looks my code is best situation ... haven't magic ... :)
00:47:20 <RyanT5000> yeah; that might be :)
00:47:41 <RyanT5000> monads are brilliant, but they're still somewhat unwieldy
00:48:08 <RyanT5000> i'm sure the next decade will hold some pretty serious improvements on them
00:49:02 <ManateeLazyCat> RyanT5000: Sometimes, i avoid use too many moand if them can't give me a big improvements, too many moand wrap make code hard to read and understand....
00:49:09 <RyanT5000> yeah
00:49:39 * ManateeLazyCat State moand is exception, that make my code clearer. :)
00:49:45 <RyanT5000> yeah
00:50:03 <RyanT5000> in our game, we use lots of monads and arrows and such
00:50:14 <ManateeLazyCat> glguy: Wow, looks i do some duplicate work with (?>=) . :)
00:50:58 <glguy> ManateeLazyCat: also, (?>=) = for_
00:51:12 <glguy> and flip (?>=) = traverse_
00:51:27 <ManateeLazyCat> RyanT5000: I'm build some gtk2hs program, and have many IO moand, for clean logic, i always avoid use some advanced moand ...
00:51:40 <RyanT5000> yeah
00:51:45 <RyanT5000> it's hard
00:51:47 <ManateeLazyCat> glguy: Yeap, i found it, and for_ is more general, not just for Maybe moand.
00:51:54 <RyanT5000> and we've got massive performance concerns, as well
00:52:22 <ManateeLazyCat> glguy: Thanks for your help, i will use for_ instead my (?>=) :)
00:53:31 <glguy> You might also look and breaking that function up a bit
00:53:39 <glguy> as it stands it is a bit of wall
00:53:48 <dv-> Anyone else think hackage needs changelogs? :/
00:54:35 <dv-> even if it's just "bugfixes" and "huge api change that breaks everything you currently have"
00:54:52 <glguy> Well, you should know that much from teh version number change
00:54:54 <ManateeLazyCat> dv-: darcs ?
00:56:28 <dv-> ManateeLazyCat: that helps for the packages that have it
00:57:02 <ManateeLazyCat> Why do we still use these guys Haskell? Appears in other communities, we are like aliens. :)
00:57:30 <RyanT5000> Haskell is the future :)
00:57:41 <ManateeLazyCat> RyanT5000: Yes, that's my point.
00:57:52 <ManateeLazyCat> RyanT5000: Such as STM, i love it.
00:58:23 <RyanT5000> yeah
00:59:19 <glguy> ManateeLazyCat: You can also use this kind of style to avoid the text falling off the screen  http://fpaste.org/HGqR/
00:59:20 <ManateeLazyCat> RyanT5000: I still think Haskell is best language in my life, i believe it even it not popular like other OOP language ...
00:59:30 <RyanT5000> yeah
00:59:42 <RyanT5000> well, i think there are some things that OOP does better than Haskell, but they're few and far between
00:59:53 <ManateeLazyCat> glguy: Thanks, i read it.
00:59:56 <RyanT5000> obviously Haskell will be improved on, too
01:00:08 <RyanT5000> but Haskell is definitely the best thing around
01:00:22 <RyanT5000> i've staked my company's future (and all my money) on that bet :)
01:00:54 <ManateeLazyCat> RyanT5000: I send all my time for Haskell
01:01:42 <dv-> We need an extensible haskell web browser
01:01:42 <RyanT5000> cool
01:01:48 <RyanT5000> dv-: yes
01:01:57 <ManateeLazyCat> dv-: Have.
01:02:00 <ManateeLazyCat> dv-: Webkit.
01:02:03 <ManateeLazyCat> dv-: gtk2hs
01:02:11 <ManateeLazyCat> dv-: Infact, i have on it.
01:03:15 <dv-> Yeah I've looked at that
01:03:32 <ManateeLazyCat> dv-: I have write a simple webkit demo
01:03:41 <dv-> But I couldn't figure out how to implement adblock-like functionality. Is it even possible?
01:03:43 <ManateeLazyCat> dv-: Damn fast, and fully Haskell.
01:03:50 <ManateeLazyCat> dv-: Yes.
01:04:16 <RyanT5000> i once tried to write a javascript binding for haskell that harmonized both GCs
01:04:22 <RyanT5000> that was a complete failure :P
01:04:28 <RyanT5000> neither GC has the hooks that are necessary
01:04:41 <RyanT5000> (i was using spidermonkey)
01:04:49 <ManateeLazyCat> RyanT5000: In my webkit binding, i haven't binding JavaScript
01:05:13 <ManateeLazyCat> RyanT5000: I will try to do that when i have more spare time.....
01:05:33 <RyanT5000> yeah; well, i had a pretty complete spidermonkey binding, i just couldn't get it so that circular memory allocations that included both JS objects and Haskell values would get GCed properly
01:06:05 <ManateeLazyCat> RyanT5000: Your JS object is base on GObject of glib?
01:06:15 <RyanT5000> no
01:06:33 <RyanT5000> this didn't have any GUI-related stuff
01:06:37 <RyanT5000> it was a standalone spidermonkey
01:06:40 <RyanT5000> no browser involved
01:06:45 <ManateeLazyCat> RyanT5000: I see.
01:06:58 <RyanT5000> i just wanted the ability to script haskell in JS
01:09:36 <ManateeLazyCat> RyanT5000: I want a fully programable Haskell that can add plugin dynamic.....
01:09:48 <ManateeLazyCat> RyanT5000: Like lisp do ...
01:09:53 <RyanT5000> me too, but i think that's even harder
01:09:56 <RyanT5000> there's hsplugins...
01:10:03 <RyanT5000> but that's not exactly the same
01:10:54 * hackagebot bein 0.3 - Bein is a provenance and workflow management system for bioinformatics.  http://hackage.haskell.org/package/bein-0.3 (FrederickRoss)
01:11:16 <ManateeLazyCat> RyanT5000: I can't compile hsplugins in ghc-6.12, but if it's just recompile module and re-launch state in new binary entry, i have implement one.
01:11:24 <ManateeLazyCat> RyanT5000: But that's not i want.
01:11:47 <RyanT5000> yeah; i'm not entirely sure how it works
01:12:52 <ManateeLazyCat> RyanT5000: In my project, i developing a module that will recompile module when you running, and you don't need restart to update module.
01:13:04 <RyanT5000> that's cool
01:13:24 <RyanT5000> well, hsplugins compiles as a shared object, i think
01:13:34 <RyanT5000> so only the plugin would have to be unloaded and reloaded
01:13:42 * ManateeLazyCat pasted "Core.hs" at http://paste2.org/get/851848
01:13:45 <ManateeLazyCat> RyanT5000: Like above.
01:14:28 <ManateeLazyCat> RyanT5000: I save state in Binary before update, restore state from Binary after update modules.
01:14:34 <RyanT5000> yeah
01:14:45 <RyanT5000> is there any way to serialize closures yet?
01:14:58 <ManateeLazyCat> ?
01:14:59 <RyanT5000> that's one thing i'm really waiting for: the ability to serialize *any* state
01:15:01 <RyanT5000> even functions
01:15:08 <RyanT5000> obviously there would be complications to it
01:15:20 <ManateeLazyCat> RyanT5000: I use it restore GTK+ state.
01:15:23 <RyanT5000> but if you assume that the codebase doesn't change between save and load, it's definitely possible
01:15:37 <copumpkin> RyanT5000: nope
01:15:38 <RyanT5000> i mean serializing things that have (->) in their type
01:16:08 <copumpkin> yeah, nope
01:16:09 <copumpkin> :)
01:16:19 <ManateeLazyCat> RyanT5000: Infact, my Core.hs more like XMoand recompile one.
01:16:53 <ManateeLazyCat> RyanT5000: It's just save/restore state you provide, it can't save all state.
01:17:16 <RyanT5000> ah, right
01:17:30 <RyanT5000> yeah; i'd love to be able to save and restore Yampa circuit state :P
01:17:35 <RyanT5000> that's what i really want
01:17:48 <ManateeLazyCat> RyanT5000: Infact, it's impossible for GTK+ state, because gtk2hs just binding for GTK+, can't pick-up all state from C library.
01:17:56 <RyanT5000> yeah, that's true
01:18:05 <RyanT5000> i'd be happy enough with just pure-haskell values
01:18:06 <ManateeLazyCat> RyanT5000: I use it save/restore my gtk2hs program. :)
01:18:23 <ManateeLazyCat> RyanT5000: I use Binary pack/unpack state.
01:18:27 <RyanT5000> yeah
01:19:05 * ManateeLazyCat I hate Emacs this *sloooooooow suck program* ...
01:19:23 <copumpkin> I thought you liked emacs :)
01:19:45 <ManateeLazyCat> copumpkin: No, i hate it, slower than my finger.
01:20:03 <Veinor> would it even be possible to serialize a function without messing around with internals?
01:20:08 <copumpkin> Veinor: no
01:20:26 <ManateeLazyCat> copumpkin: Only reason i use Emacs now because i haven't develop all my favorites features to replace it.
01:21:05 <ManateeLazyCat> copumpkin: Emacs don't support multi-threaded, the biggest reason i don't like it.
01:21:24 <ManateeLazyCat> No, is elisp don't support multi-threaded.
01:21:31 <copumpkin> ah
01:21:34 <RyanT5000> Veinor: laziness would add even more annoying details to deal with; but the fact is that all the data is there *somewhere*  If you can GC it, you can serializeit
01:21:36 <copumpkin> elisp is gross
01:22:01 <Veinor> RyanT5000: yeah, but you can't do that right now without mucking about in the compiler internals
01:22:02 <ManateeLazyCat> copumpkin: Anyway, i don't like elisp completely....
01:22:03 <copumpkin> you could poke around the vacuum code a bit and look
01:22:31 <copumpkin> but I don't think it's possible without actually getting the GHC closure structures and implementing them in haskell
01:22:39 <copumpkin> which is already what vacuum does a bit, but you'd need to do more
01:22:44 <copumpkin> and you still can't serialize executable code
01:22:47 <pastorn> when will people learn that ED THE STANDARD EDITOR is the way to go?
01:22:48 <copumpkin> only environment/bindings
01:22:58 <copumpkin> pastorn: she made it btw!
01:23:06 <copumpkin> thanks again :)
01:23:10 <mxc> dear god
01:23:26 <tomberek> hey, i have an interesting problem with type classes... I created general instances that imply that one type class is a member of the other (and vice,versa), now i have overlapping instances arising from superclasses
01:23:27 <pastorn> copumpkin: oh, cool... do you have a death date yet?
01:23:39 <RyanT5000> copumpkin: yeah, but the heap doesn't contain executable code anyhow
01:23:40 <mxc> i just realized that that jan harrop troll made a blog specifically to passive aggresively attack haskell
01:23:44 <copumpkin> nope :P she was fine with it
01:23:58 <copumpkin> RyanT5000: yeah
01:24:03 <copumpkin> mxc: where?
01:24:09 <RyanT5000> you don't need to serialize anything out of .text if you don't mind horrid versioning
01:24:10 <mxc> haskell-news.blogspot.com
01:24:22 <copumpkin> lol
01:24:25 <RyanT5000> and if you use symbol names, versioning will only be *kind of* horrid
01:24:26 <mxc> its subtle, for him
01:24:28 <ManateeLazyCat> glguy: Ah, i have define "m ?>=> f = maybe (return Nothing) f m" in my Maybe module. :)
01:24:30 <ManateeLazyCat> (?>=>) :: Monad m => Maybe a -> (a -> m (Maybe b)) -> m (Maybe b)
01:24:42 <copumpkin> mxc: not very subtle
01:24:46 <copumpkin> "Posted by Flying Frog Consultancy Ltd"
01:24:52 <copumpkin> I'm sure dons would get a kick out of it
01:24:55 <copumpkin> mxc: how did you find it?
01:24:57 <ManateeLazyCat> glguy: And i need >>=?
01:25:06 <ManateeLazyCat> It's perfect for Maybe situation.
01:25:20 <mxc> yeah, but unless you know that FFConsultancy is a business which specializes in attacking haskell, its not entirely obvious from that site
01:25:41 <eevar2> someone needs to add that blog to reddit/planet haskell and any other aggregators ;)
01:25:48 <mxc> someone linked to a reasonable post there (which simply linked a tsuru capital paper) in stackoverlow
01:26:08 <copumpkin> mxc: I think it's mostly so harrop can claim he''s "fair and balance"
01:26:16 <copumpkin> "look at me! I have the occasional non-negative post about it"
01:27:03 <mxc> my thought is that that blog itself is quite insidious
01:27:22 <mxc> since its not obviously a haskell flog (flame + blog = flog?)
01:27:39 <mxc> he doesn't even put his own name on it
01:28:00 <eevar2> lol. check his profile @ blogger. he also runs lisp news, clojure news, scala news, +++
01:28:05 <copumpkin> oh, dons already knows about it
01:28:10 <copumpkin> he commented on it
01:28:10 <eevar2> blog names, that is
01:28:13 <mxc> he's a strange guy..  clearly feels insanely threatened by haskell but doesn't do the obivious move and learn it
01:28:41 <mxc> on the other hand, dons is like the haskell version of harrop, but in a much more informed, productive, helpful manner
01:28:47 <Veinor> '"I must say I'm disappointed"
01:28:52 <Veinor> That's the best out of context quote ever.
01:29:21 <copumpkin> maybe we should call up ff consultancy and ask him for help with haskell
01:29:26 <copumpkin> since he's an FP consultancy
01:29:34 <copumpkin> offer big money and refuse his attempts to convince us to change
01:29:39 <copumpkin> :P
01:30:43 <mxc> i like how in that post he refers to reddt as 'impartial' but the other 99.9% of the time when reddit is a lovefest for haskell its just a bunch of academic fanboys that never produce anything
01:31:32 <mxc> haha
01:32:23 <mxc> see if there's a unicode character that looks like 's' and register gs.com to make it look like he's getting attention from goldman
01:34:37 <dv-> loveolivia
01:34:48 * ManateeLazyCat I need off now, Emacs will kill me ..... 
01:35:02 <dv-> wow gdm fail
01:40:26 <roconnor> anyone know a nice proof that the seperable closure of a field is a subfield?
01:52:01 <mxc> maybe i've been using haskell for too long, but I was looking at clojure and I realized that i've completely forgotten how dynamic typing works
01:52:55 <mxc> unless function is basically a typeclass with some sort of implied instance for any combination of argumnet types
01:53:45 <RyanT5000> just think of it like every type is a constructor in a giant ADT
01:54:11 <RyanT5000> that's how i usually envision it anyhow
01:54:23 <RyanT5000> and then that ADT is the only type for everything
01:54:41 <RyanT5000> i suppose that gets blurry when you consider that there are an infinite number of types...
01:55:10 <RyanT5000> (though i haven't used clojure, so i'm not sure if that's the right way of thinking about their system)
01:56:36 <EnglishGent> hello :)
01:57:42 <EnglishGent> I'm curious - with the Map type - why are keys required to be an instance of Ord, as opposed to simply an instance of Eq? it seems a stronger requirement than is strictly necessary
01:57:51 <EnglishGent> is that just becuase of how it's implemented? :)
01:58:10 <markus3> i think because Map is implemented as binary search trees
01:58:23 <markus3> so the keys are ordered
01:58:27 * hackagebot bein 0.3.1 - Bein is a provenance and workflow management system for bioinformatics.  http://hackage.haskell.org/package/bein-0.3.1 (FrederickRoss)
01:59:00 <Jafet> The only way to implement an associative structure with Eq is an assoc-list (which isn't very popular for obvious reasons)
01:59:28 <markus3> like: left branch has all the keys lower than root, right has all that are bigger
01:59:45 <markus3> and this law is recursive
02:00:44 <markus3> so that's how the lookup has log n performance: it just has to move through the height of the tree
02:00:56 <Jafet> Data.List provides assoc-list operations
02:01:58 <EnglishGent> thanks markus3, Jafet :)
02:03:11 * EnglishGent was wanting a MP type class for representing maps/dictionaries so as to decouple the interface from the implementation :)
02:03:42 <Jafet> The problem being that they are highly interdependent
02:04:14 <Jafet> There should be a Hashable type class around, or you can make one, which lets you get around the Ord constraint
02:04:43 <Jafet> That also involves a few books' reading on hash table theory
02:12:46 * ManateeLazyCat pasted "Environment" at http://paste2.org/get/851895
02:12:46 <ManateeLazyCat> I have `Environment` (like above link) that contain a set of share state, and i have many function need read/update state from Environment, but i don't like transform `Environment` in it, so i need transform many state as function argument, have good solution that avoid so many function arguments?
02:14:17 <ManateeLazyCat> If you make all function like "Environment -> IO ()", you got bad layout with different module, otherwise i need write many function like this : "EnvStateA -> EnvStateB -> EnvStateC -> IO ()".
02:14:32 <ManateeLazyCat> And i'm not happy write so many function arguments.
02:16:34 <EnglishGent> can you recommend such a book Jafet? :)
02:16:38 <EnglishGent> hi ManateeLazyCat :)
02:16:44 <ManateeLazyCat> EnglishGent: Hi. :)
02:17:23 <Jafet> I can't, no
02:17:55 <Jafet> There are the usual suspects -- Knuth, Sedgewick, etc. Look in their tables of contents
02:18:44 <EnglishGent> ok - thanks anyway :)
02:19:06 <norm2782> Cormen et al. and Baase and Van Gelder discuss hashtables as well, but it's mostly introductory stuff
02:19:18 <ManateeLazyCat> The worset is i need change a *list* functions if i modified lowest function arguments.
02:19:30 <norm2782> oh Hashables.. heh, nevermind... read it wrong
02:19:35 * norm2782 grabs more coffee
02:20:11 <Jafet> Hashables for hashtables!
02:20:24 <Jafet> Hashes are great with black coffee
02:22:16 <ManateeLazyCat> EnglishGent: How you doing recently?
02:23:07 <mornfall> ManateeLazyCat: There's apparently no good way around it. The best you can do is to try to modularize the code enough so that you don't need too many environments around.
02:23:41 <mornfall> ManateeLazyCat: There are dynamically scoped variables in Haskell, but they are generally considered harmful.
02:24:23 <EnglishGent> I am good ManateeLazyCat  - changed jobs, hence my longish absence whilst the induced chaos was resolved
02:24:25 <mornfall> ManateeLazyCat: One more option, if you live in IO () most of the time, is to create a global IORef for the environment.
02:24:26 <EnglishGent> how about you? :)
02:24:45 <EnglishGent> thanks anyway norm2782  :)
02:24:51 * ManateeLazyCat pasted "keymap" at http://paste2.org/get/851918
02:24:52 <ManateeLazyCat> mornfall: Well, i'm develop some gtk2hs program, i have write code to handle user keymap. like above.
02:25:13 <ManateeLazyCat> mornfall: Then i can use "data Action" build polymorphism function.
02:25:33 <ManateeLazyCat> EnglishGent: Not bad, is too busy.
02:25:58 <ManateeLazyCat> EnglishGent: I'm busy on gtk2hs cabal, now gtk2hs-0.11 release, i'm busy on my project.
02:26:22 <ManateeLazyCat> mornfall: No, i don't like global IORef.
02:26:35 <mornfall> ManateeLazyCat: That was just some general remarks, as it is a fairly common problem with Haskell. I haven't seen a really good way around it yet.
02:26:53 <mornfall> ManateeLazyCat: I suspect the way to do it is to minimize the part of the code that is environment-dependant.
02:26:59 <ManateeLazyCat> mornfall: global variable is evil.
02:27:25 <ManateeLazyCat> mornfall: Any global variable will break my module design.
02:27:30 <int-e> ManateeLazyCat: can you reasonably make your states extensible? data Environment a = Env { ... extra :: a }
02:27:33 <ManateeLazyCat> mornfall: And make program hard to debug, because any code can access global variable.
02:27:52 <mornfall> ManateeLazyCat: Sure. It may or may not be an option depending on context.
02:27:53 <ManateeLazyCat> BTW, in gtk2hs, i just use TVar. :)
02:28:15 <mornfall> I need food. Bbl.
02:29:21 <ManateeLazyCat> mornfall: Yes, i have do that, i module my program, and lower library just keep pure function, but i need build Action.hs to mix those libraries, so i need Environment.
02:29:47 <ManateeLazyCat> mornfall: I have make Environment code minimize, but i want better than *long function argument*.
02:30:11 <ManateeLazyCat> int-e: Yes, i want
02:31:02 <int-e> Implicit arguments are a better option than global variables. They are not that evil either - they basically amount to a compiler managed Reader Applicative. /linear/ implicit arguments were evil (hard to predict, breaking equational reasoning).
02:32:21 <int-e> (http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html#implicit-parameters)
02:32:53 <dibblego> http://code.google.com/p/scalaz/source/browse/continuous/2010-02-15%2B64.581201s/src/scalaz/MA.scala#237 an example of implicit parameters in Scala
02:33:03 <ivanm> hey dibblego
02:33:19 <dibblego> hello
02:33:38 <ManateeLazyCat> int-e: The biggest problem is, higher-function pick-up some state from `Environment`, then transform subset to many little lower-functions, when i change lower-function's argument, i need change a *list functions* that from lower-function to higher-function.
02:34:15 <ManateeLazyCat> int-e: And this is painful.
02:35:38 <ManateeLazyCat> int-e: Unfortunately, ghc-6.12.2 can't works with current gtk2hs.
02:36:39 <int-e> the extension is old.
02:37:52 <ManateeLazyCat> int-e: I'm reading "Implicit parameters"
02:38:52 <ManateeLazyCat> int-e: ghc-6.12.1 support "-XImplicitParams"?
02:40:04 <ivanm> you mean where you give the variable name in the type signature?
02:40:13 <ivanm> I doubt they've done a regression to _remove_ that from 6.12.1 :p
02:40:41 <int-e> ManateeLazyCat: yes. and ghc 6.10.x too
02:40:43 <ManateeLazyCat> ivanm: I don't want "long function arguments"
02:40:55 <ivanm> oh, you mean like what scala has?
02:40:57 <ivanm> then no
02:41:04 <Starfire> ManateeLazyCat: 6.12.1 at least claims to support it, when called with --supported-languages.
02:41:09 <ivanm> I haven't heard of anything like that in Haskell-land
02:41:42 <int-e> ManateeLazyCat: and 6.8.x and IIRC 6.6 and 6.4 as well (although probably with different flags)
02:44:54 <quicksilver> int-e: IIRC implicit arguments also break equational reasoning
02:45:19 <quicksilver> int-e: because of the way their pseudo-dynamic scope interacts poorly with haskell's lexical scope.
02:45:29 <ManateeLazyCat> "least   :: (?cmp :: a -> a -> Bool) => [a] -> a" looks new to me.
02:46:12 <ivanm> ManateeLazyCat: right, that's what I was talking about
02:46:17 <int-e> quicksilver: well, you have the let ?foo = ... constructs to watch out for.
02:46:46 <quicksilver> int-e: yeah.
02:46:50 <quicksilver> I think they're ugly.
02:47:20 <quicksilver> I think there was a haskell-cafe posting that put me off them for good
02:47:21 <ivanm> what's the point of them? to shorten your function definition at the expense of your type signature?
02:47:30 <quicksilver> but I don't remember what it was.
02:47:40 <RyanT5000> ivanm: to shorten invocations, i think
02:47:41 <quicksilver> ivanm: the point is almost exactly what ManateeLazyCat asked for.
02:47:54 <int-e> I don't really like them - but I feel they can be useful.
02:47:55 <quicksilver> to improve modularity.
02:48:04 <ivanm> hang on, implicitparams extracts them from the environment? :o
02:48:10 <int-e> ivanm: you'd have to write most of that type signature anyway.
02:48:11 <ivanm> I thought it was just for the function definition :s
02:48:17 <ivanm> int-e: that too
02:48:31 <ivanm> but shouldn't you be writing type signatures for documentation purposes anyway? :p
02:48:40 * int-e generally tries to stuff things away in a Reader monad.
02:48:47 <int-e> ivanm: I would.
02:49:33 <ManateeL`> int-e: I always use runStateT and not runReaderT.
02:50:23 * ivanm should probably start using Reader more
02:50:32 <ManateeL`> ivanm: Why?
02:50:44 <ivanm> for precisely the reason int-e says
02:53:49 <int-e> But a nice thing about implicit parameters is that you get stacking and commuting of Reader(T)s for free, at the expense of a strange syntax for 'local'. The other advantage is that you are not being forced to use Applicative or Monad operations.
02:54:00 <ivanm> that reminds me: I'm soon going to need to use a State-like environment where I'm going to be having a State that I want to go through and update globally, and another State that is updated within sub-environment (i.e. within recursive calls)
02:54:06 <ivanm> what would be the best way of doing that?
02:54:19 <int-e> ... for 'local' and 'runReader(T)'.
02:56:14 <quicksilver> int-e: you're not *forced* to use applicative and Monad operations to use a reader monad though
02:56:15 <ManateeL`> ivanm: I use TVar in `Environment`,
02:56:16 <int-e> ivanm: by updates within sub-environments, do you mean something like 'local' does for reader? or is it a state that can be saved and restored?
02:56:30 <ivanm> int-e: yeah, like local
02:56:34 <quicksilver> int-e: you can always unpack the reader into an explicit lambda at any depth of the stack
02:56:38 <ManateeL`> int-e: Reader is better than State?
02:56:40 <ivanm> but it gets updated _within_ the environment, so local doesn't work :s
02:56:43 <quicksilver> int-e: and use normal applicative (small 'a') notation therein.
02:56:53 <int-e> quicksilver: yes, of course.
02:58:19 <ivanm> int-e: the use is here: I'm wanting to go through collecting nodeStmts from a DotStatements value after applying the "global" attributes to them; thing is, the DotSubGraph values have their own DotStatements values in them: http://hackage.haskell.org/packages/archive/graphviz/2999.9.0.0/doc/html/Data-GraphViz-Types.html#t%3ADotStatements
02:58:23 <int-e> ManateeL`: for immutable state - yes, I think so.
02:58:32 <ManateeL`> ivanm: Can you add IORef/MVar/TVar in Environment? Then change IOREf/MVar/TVar in runReaderT?
02:58:44 <ivanm> ManateeL`: no idea
02:58:48 <ivanm> and I'm not wanting to use IO for this
02:59:22 <ivanm> int-e: I was thinking of using RWS, but since local needs to be applied _before_ the recursive call IIUC... :s
02:59:47 <ManateeL`> int-e: I think Reader is handy for immutable state, for mutable state, i can't see reader's advantage.
03:00:04 <ivanm> ManateeL`: well, it's not meant to be used for mutable state
03:00:14 <ivanm> it's precisely designed to let you pass fixed values around implicitly
03:00:40 <ManateeL`> int-e: IMO, IORef/MVar/TVar can make ReaderT update mutable state too.
03:01:09 <int-e> ManateeL`: your environment looked immutable to me. if the state is mutable you'll want a StateT monad. A monad is appropriate, because ordering of state updates matters.
03:02:20 <int-e> ManateeL`: and you're right. but the variables (locations) themselves are immutable - it's their contents that changes.
03:02:35 <ManateeL`> int-e: Do you think http://paste2.org/get/851895 is immutable?
03:03:12 <mornfall> ManateeL`: As far as pure code is concerned, this is immutable yes.
03:03:18 <int-e> ManateeL`: I would assume so, although it's impossible to tell.
03:03:23 <markus3> a question: if i have any depth of lists in list is there an operator to use instead of multiple nested maps?
03:04:11 <ManateeL`> int-e: Ok, so "Implicit parameters" have any help to fix my *long function argument* problem?
03:04:24 <ManateeL`> int-e: Even i haven't understand "Implicit parameters" completely.
03:04:32 <mornfall> ManateeL`: If it changed during a pure computation, you'd need types of the kind Environment -> (Foo, Environment)... which is what StateT solves.
03:04:45 <mornfall> ManateeL`: If you have Environment -> Foo, ReaderT is the right one.
03:05:07 <mornfall> ManateeL`: Implicit parameters are dynamically scoped variables. You want to avoid them. (Anecdotally.)
03:05:08 <int-e> ManateeL`: the function type signatures will still mention all the environments that you use; but the extension would take care of the actual parameter passing for you.
03:05:10 <ManateeL`> mornfall: I see.
03:06:02 <mornfall> (Implicit parameters come with strings attached.)
03:06:33 <mornfall> But I agree they look very tempting at a first sight.
03:06:38 <int-e> They're a trade-off between convenience and ease of following the data flow of the program.
03:06:59 <ManateeL`> int-e: "Implicit parameters" is type safe?
03:07:05 <int-e> yes, they are.
03:07:12 <int-e> @type ?a
03:07:13 <lambdabot> forall t. (?a::t) => t
03:07:18 <mornfall> Type safe, yes. Composable or modular, not so much.
03:07:35 <int-e> you get strange contexts like that one.
03:07:51 * hackagebot bein 0.3.2 - Bein is a provenance and workflow management system for bioinformatics.  http://hackage.haskell.org/package/bein-0.3.2 (FrederickRoss)
03:08:04 <int-e> (and at runtime those will be actual function arguments)
03:08:24 <ManateeL`> int-e: "Implicit parameters" have any obvious disadvantage? Or break something?
03:08:31 <int-e> > let x = ?a in let ?a = 1 in x
03:08:31 <lambdabot>   1
03:09:13 <mornfall> ManateeL`: One obvious disadvantage is their global scope.
03:10:09 <RyanT5000> global scope is evil
03:10:10 <int-e> well, disadvantages include that they are not Haskell 98, and that it makes the code harder to follow. It adds a subtle precondition to refactorings - you can't move uses of functions across let ?foo = ...  bindings without checking whether that implicit parameter is used..
03:10:22 <int-e> they don't have global scope.
03:10:36 <ManateeL`> mornfall: Have exist hackage package use "Implicit parameters" ? I want study code deeply, just talk is too abstract.
03:11:22 <ivanm> so what's the scope for implicit params?
03:11:26 <RyanT5000> int-e: ?a means the same thing everywhere it appears; isn't that basically the same as global scope?
03:11:43 <mornfall> int-e: How can they not have global scope?
03:12:08 <RyanT5000> unless i'm mistaken, two implicit variables refer to the same thing if and only if their source code representation is the same
03:12:20 <mornfall> int-e: If two functions I call use ?a for different things -- with different types -- what happens?
03:12:26 <RyanT5000> whether that's called "global scope" or not, it suffers from one of the main problems of global scope
03:12:53 <int-e> > let x = ?a ++ []; y = ?a + 0 in (let ?a = [1] in x, let ?a = 1 in y)
03:12:54 <lambdabot>   ([1],1)
03:13:09 <int-e> mornfall: you get a type checking error.
03:13:21 <ManateeL`> RyanT5000: So "Implicit parameters" is some String scan? ?a always for same type?
03:14:13 <RyanT5000> ManateeL`: well i have no idea how it's implemented; i certainly hope Strings aren't too heavily involved :)
03:14:22 <RyanT5000> no, ?a isn't always the same type
03:14:35 <RyanT5000> well, i suppose it is
03:14:36 <RyanT5000> it's always
03:14:41 <RyanT5000> (?a::t) => t
03:14:42 <int-e> > let x = ?a ++ []; y = ?a + 0; z = [let ?a = ?b in y] ++ x in let ?a = [2]; ?b = 1 in z -- you can 'rename' them, too.
03:14:42 <lambdabot>   [1,2]
03:14:59 <ManateeL`> RyanT5000: I mean once it decide `?a` is which type, then it always same type.
03:15:10 <RyanT5000> ManateeL`: i don't think so
03:15:19 <int-e> in that sense the scope is really local.
03:15:54 <RyanT5000> int-e: i think we have different ideas of scope - though i don't doubt that mine may be wrong
03:16:39 <RyanT5000> to me, scope is about names, and not about definitions (i.e.: the values associated with names) or types
03:16:41 <paulvisschers> When making instances of a type family, can you do an equality test?
03:16:52 <int-e> RyanT5000: it may be as simple as talking about type class names (names of implicit parameters) vs. type class instances (their value).
03:17:05 <int-e> heh
03:17:13 <ManateeL`> paulvisschers: "deriving Eq" ?
03:17:19 <RyanT5000> int-e: yeah, well typeclass names are Module-scoped at least
03:18:01 <paulvisschers> ManateeL`: I meant that you could check that two type variables are the same type
03:18:03 <RyanT5000> int-e: but i think you can write two libraries that both use ?a, and, without them sharing any dependencies, those two ?a's will be aliased
03:18:10 <RyanT5000> which is incorrect, IMO
03:18:12 <mornfall> paulvisschers: (a ~ b) => ...
03:18:22 <mornfall> paulvisschers: In your context...
03:18:33 <mornfall> I guess you mean something like
03:18:33 <RyanT5000> in my book, all aliasing needs to derive from shared dependencies
03:19:06 <mornfall> instance (Foo a ~ Foo b) => Bar a b ...
03:19:07 <int-e> RyanT5000: but I still disagree they are global. a use of a function with an implicit parameter brings its name into scope. binding an implicit parameter does that as well.
03:19:08 <paulvisschers> mornfall: Ah great, that actually works
03:19:41 <int-e> RyanT5000: but two functions with the same implicit parameter but incompatible type for said parameter can coexist peacefully
03:19:56 <int-e> /same implicit parameter name/
03:20:33 <RyanT5000> int-e: yeah, that's true, they can coexist peacefully, but it requires total awareness by the user
03:20:35 <int-e> ManateeL`: and I think that's why hardly anybody uses them - they are confusing :)
03:20:54 <RyanT5000> there are still bad scenarios that can happen
03:21:02 <ManateeL`> int-e: I'm confusing now. :)
03:21:04 <int-e> RyanT5000: convenience with strings attached.
03:21:20 <RyanT5000> for example, suppose lib1-0.1 uses ?a and lib2-0.1 doesn't
03:21:38 <RyanT5000> now you write app-0.1 based on those libraries
03:21:49 <RyanT5000> now lib2-0.2 comes out and it uses ?a
03:21:52 <RyanT5000> that's a breaking change
03:21:56 <RyanT5000> your source should not build
03:21:58 <RyanT5000> but it does
03:22:08 <RyanT5000> (assuming they both require ?a to be the same type)
03:22:10 <ManateeL`> int-e: Example, i have function like this : "tabSelectLast :: (Client, WindowList, PageTable, Tabbar, TVar FocusNotifierList) -> IO ()", how to use "Implicit parameters" make it better?
03:22:18 <int-e> (we may disagree whether they add any convenience - I think we do. we can disagree a lot on whether the convenience is worth the confusion - I don't know, it depends on the actual use case.)
03:22:37 <RyanT5000> i definitely agree that they add convenience :)
03:22:48 <int-e> and while their scope is not global it is certainly good for the programmer's mental health to treat them that way.
03:22:59 <RyanT5000> in fact i might even consider using them
03:23:01 <paulvisschers> mornfall: Wait, that actually didn't work, I was reloading the wrong ghci window
03:23:08 <RyanT5000> i'm just saying they would be *better* if they didn't have these problems
03:23:31 <RyanT5000> and these problems could easily be alleviated if there were a declaration site for implicit parameters
03:23:33 <ManateeL`> paulvisschers: Please paste your code and error, that's will be help.
03:23:37 <RyanT5000> it could be as simple as
03:23:47 <RyanT5000> parameter ?a
03:23:51 <RyanT5000> at top level in any module
03:24:10 <mornfall> paulvisschers: :)
03:24:12 <paulvisschers> ManateeL`: Doing that now
03:24:15 <RyanT5000> (note: this also alleviates the need for the ? prefix)
03:24:17 <int-e> RyanT5000: ah but what about their type then?
03:24:25 <RyanT5000> the type is specified in exactly the same way
03:24:34 <RyanT5000> there's no need for the type to be given at the declaration site
03:24:35 <int-e> RyanT5000: oops. no, the ? prefix is important to me.
03:25:15 <mornfall> int-e: Well, I guess the issue is that implicit parameters prevent you from combining functions just due to a naming conflict of their parameters.
03:25:20 <RyanT5000> int-e: i didn't say it *had* to go away; it just isn't *as* necessary, since there's a declaration site clearly indicating that "a" is an implicit parameter wherever it appears
03:25:28 <mornfall> int-e: Which is certainly a modularity breach.
03:25:46 <paulvisschers> ManateeL`, mornfall: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25710#a25710
03:26:10 <int-e> mornfall: true.
03:26:11 * ManateeL` I always use Typeable-typeclass pack polymorphism type, then use Typeable.cast unpack type after pass type-system check. 
03:26:26 <mornfall> paulvisschers: Reminds me of HList.
03:27:05 <mornfall> int-e: I don't know if there's a good way around that limitation.
03:27:11 <mornfall> int-e: It just "feels" wrong.
03:27:26 <RyanT5000> int-e: anyway, all i'm saying is that having a declaration site (and thus typeclass-like scoping) would eliminate the library problem i described
03:27:35 <int-e> mornfall: which makes them a bad idea for public interfaces of libraries. For programs on the other hand, you tend to have more state (environments) and fewer people depending on your code ...
03:27:51 <ManateeL`> paulvisschers: "type instance"? Can write like this?
03:27:56 <RyanT5000> and i don't think it would hurt in any other way (except that you'd have to write a 2-token line for each one)
03:28:01 <mornfall> ManateeL`: Type family. Yes, that's legal.
03:28:29 <paulvisschers> ManateeL`: It's a type family, it's an extension to the language
03:28:33 <int-e> RyanT5000: because you the implicit parameter would become an exported entity and have a qualified name.
03:28:35 <mornfall> paulvisschers: You may need to make that an associated type though.
03:28:36 <ManateeL`> mornfall: What's different "type family" between "typeclass"
03:28:42 <ManateeL`> ?
03:28:45 <paulvisschers> ManateeL`: It's advanced stuff
03:28:53 <RyanT5000> a type family is an option function on types
03:28:59 <RyanT5000> it's quite different from a typeclass
03:29:06 <RyanT5000> *open function
03:29:08 <RyanT5000> not option function
03:29:16 <RyanT5000> (need more coffee :P)
03:29:28 * ManateeL` Have so much advanced stuff in Haskell.  :)
03:29:31 <mornfall> paulvisschers: Can you turn that into class Field l r where type Field l r :: *?
03:29:44 <mornfall> paulvisschers: Then you can use normal instance syntax (without type).
03:30:11 <paulvisschers> mornfall: I'll try
03:31:33 <mornfall> Hm, you need to name the class and the type differently from each other.
03:31:41 * ManateeL` First time read "type instance".....
03:32:13 <RyanT5000> int-e: maybe i'm crazy, but implicit parameters strike me as very similar to typeclasses with local instances
03:32:59 <mornfall> paulvisschers: Oh. That's not going to work.
03:33:01 <dcoutts> RyanT5000: mm, I guess there is a similarity
03:33:20 <int-e> RyanT5000: not crazy to me. of course the local instance is very limited - it's essentially one nullary function (?foo) of whatever type the implicit parameter has.
03:33:51 <mornfall> paulvisschers: I don't think you can have different instances depending on type parameter equality...
03:34:01 <dcoutts> RyanT5000: after all, implicit params are done using constraints in a similar way to class constraints
03:34:42 <quicksilver> an implicit parameter which is a dictionary
03:34:56 <quicksilver> is very much like a local typeclass instance
03:35:08 <int-e> RyanT5000: The implicit configuration stuff by Oleg et. al. approaches that view from the opposite direction.
03:35:20 <quicksilver> as in sortImplicit :: (?cmp :: a -> a -> Bool) :: [a] -> [a]
03:35:32 <quicksilver> ?cmp is very like a local Ord instance for a.
03:35:33 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
03:36:15 <ivanm> lol
03:36:21 <ManateeL`> quicksilver: ?cmp can be other type than Ord ?
03:36:26 <ivanm> I'm assuming ?cmp was matched to ?map ?
03:36:29 <ManateeL`> quicksilver: I mean for `sort`.
03:36:39 <quicksilver> ManateeL`: I don't understand your question.
03:36:46 <quicksilver> Ord is a class, not a type.
03:36:56 <quicksilver> but I was assuming my ?cmp is like (<)
03:37:13 <quicksilver> and since (<) is enough to define an Ord instance
03:37:18 <paulvisschers> mornfall: You're right, that won't work either
03:37:25 <ManateeL`> quicksilver: For sort list, a should be instance of Ord, and `?cmp` can be other typeclass?
03:37:46 <mornfall> paulvisschers: You would possibly need to wrap that up in another GADT
03:38:02 <quicksilver> ManateeL`: ?cmp is not a typeclass.
03:38:08 <mornfall> paulvisschers: Which would presumably suck and defeat the purpose of the exercise.
03:38:10 <ManateeL`> quicksilver: I'm confusion
03:38:21 <quicksilver> ManateeL`: ?cmp is an implicit paramter, and its type indicates it is just a function.
03:38:28 <quicksilver> a -> a -> Bool
03:38:32 <quicksilver> same type as (<)
03:38:50 <quicksilver> so, my sortImplicit (which doesn't really exist, I just made it up) is not using a's Ord isntance.
03:38:57 <quicksilver> Indeed it will work even if a doesn't have an Ord instance.
03:39:10 <quicksilver> it's using the implicit parameter instead
03:39:18 <paulvisschers> mornfall: I could also make an instance for each label I have, but that would also be extremely lame
03:39:31 <mornfall> paulvisschers: You could splice it. :D
03:40:40 <ManateeL`> quicksilver: So `?cmp` is point that it's a function that match "a -> a -> Bool", right?
03:40:58 <ManateeL`> quicksilver: And don't care which type is `a`?
03:41:22 <mornfall> paulvisschers: It would work if there was a /~ operator, but I don't know about one.
03:41:48 <quicksilver> ManateeL`: well, it's the same 'a' as the rest of the functin.
03:41:54 <quicksilver> ManateeL`: the a in [a] -> [a]
03:42:14 <mornfall> paulvisschers: type instances may never overlap
03:43:33 <paulvisschers> mornfall: Actually using explicit labels also sucks, because the recursive cases would need to be cartesian products of all the labels
03:44:24 <paulvisschers> mornfall: Is there a way to define closed type functions?
03:44:26 <mornfall> paulvisschers: Yes, which is why splicing is the only way to reasonably work around that problem. Not sure it's worth it though.
03:44:55 <mornfall> paulvisschers: I don't know of any.
03:45:35 <paulvisschers> mornfall: I also need a selection operator of course: (!) :: (Field l r ~ a) => r -> l -> a, so that probably won't work directly either
03:46:34 <mornfall> paulvisschers: Well, this has been implemented with functional dependencies before, so you probably want to just use the existing implementation. :) Type families are not completely implemented yet, and more involved things may be possible later.
03:47:20 <RyanT5000> Spam Time: My company is hiring people to work on our video game, which is written in Haskell.  Let me know if you're interested.
03:47:32 <ManateeL`> mornfall: "Type families are not completely implemented yet"? Even for ghc?
03:47:57 <ManateeL`> RyanT5000: If you paste it on haskell-cafe?
03:47:58 <mornfall> ManateeL`: Specifically for GHC.
03:48:11 <RyanT5000> ManateeL`: it's already there :)
03:48:20 <RyanT5000> but not everyone in this chatroom is on haskell-cafe
03:48:23 <ManateeL`> RyanT5000: What's your video game?
03:48:34 <RyanT5000> it's an action-roleplaying game called BloodKnight
03:49:13 <RyanT5000> it's going to be released on android, iphone (yeah, yeah, i know about the new license provision, and i don't think it's a problem), and other smartphones
03:49:18 * ManateeL` I'm used to be J2ME engineer to develop mobile game. :)
03:49:23 <RyanT5000> very cool :)
03:49:39 <ManateeL`> But i'm not interest it now, too easy for me. :)
03:49:55 <RyanT5000> i have an idea for a project that wouldn't be too easy :)
03:50:01 <RyanT5000> Haskell -> J2ME compiler
03:50:36 <ManateeL`> RyanT5000: I think J2ME is enough, why need haskell? Not pure? :)
03:50:47 <RyanT5000> well, our engine's written in haskell :)
03:50:54 <RyanT5000> we want it to work on everything
03:51:37 <RyanT5000> of course, we have C bits and such as well, so porting to java bytecode would be no minor undertaking, even with a perfect haskell->java compiler
03:51:39 <ManateeL`> RyanT5000: I have a J2ME emulator from gameloft that can adjust parameter when game is running, and don't need compile restart.
03:52:26 <ManateeL`> RyanT5000: Anyway, i think if you want developing mobile game, such for android, J2ME is best one.
03:53:00 <vitka> @pl \a -> f `first` (g a)
03:53:00 <lambdabot> (f `first`) . g
03:53:08 <ManateeL`> RyanT5000: Because many phone manufacturer is test for J2me.
03:53:09 <aristid> ManateeL`: i don't think android even supports J2ME
03:53:25 <RyanT5000> haskell development on android is not a big deal; they allow native apps
03:53:40 <RyanT5000> and they don't support j2me, just their own bastardized java thing
03:53:50 <RyanT5000> it's not conformant to any java standard
03:53:59 <RyanT5000> and it uses a different bytecode
03:54:02 <aristid> RyanT5000: you can put haskell apps for android in the market?
03:54:32 <ManateeL`> aristid: I don't know detail about android, but from my experience on mobile game, like symbian, and moto-linux, and window-mobile, many phone just support j2me
03:54:49 <RyanT5000> aristid: i believe so
03:55:00 <Jafet> Are you sure that automatic compilation to java gets around the android mandate?
03:55:13 <RyanT5000> Jafet: what android mandate?
03:55:14 <aristid> ManateeL`: android is a really different beast
03:55:29 <Jafet> Er sorry, iphone mandate
03:55:42 <ManateeL`> RyanT5000: So you develop mobile game haskell fully?
03:55:45 <RyanT5000> well, with Apple, you can never be sure of anything
03:55:50 <aristid> Jafet: it breaks the terms for iPhoneOS4
03:55:59 <ManateeL`> RyanT5000: Apple control everything...
03:56:01 <RyanT5000> they can reject us for pretty much any reason they see fit
03:56:11 <RyanT5000> i don't think we're necessarily in violation of that term anyway
03:56:28 <ManateeL`> RyanT5000: Or write by Haskell and transform to Java?
03:57:01 <RyanT5000> right now we have haskell code and (objective-)c(++)
03:57:12 <RyanT5000> as well as all kinds of scripts and programs that build our game
03:57:19 <ManateeL`> RyanT5000: objective-c for iphone?
03:57:29 <RyanT5000> yeah; it's necessary for certain Apple APIs
03:57:45 <ManateeL`> RyanT5000: Looks need longer test time.
03:57:51 <RyanT5000> ?
03:58:20 <ManateeL`> RyanT5000: You just develop game for android and iphone?
03:58:28 <RyanT5000> those are our first two targets
03:58:35 <RyanT5000> we plan to hit many more platforms as well
03:59:10 <ManateeL`> RyanT5000: I need test 15~20 phone after i develop game finish, when i was j2me engineer.
03:59:36 <RyanT5000> well, we plan to run a beta test with at least 100 people before release
03:59:51 <RyanT5000> probably more, although we want to keep it pretty quiet
04:00:00 <RyanT5000> so, there'll be a lot of testing
04:00:12 <RyanT5000> but there are only a few different iPhone and Android models out there right now
04:00:26 <quicksilver> "we want to keep it pretty quiet" he says in one of the largest 10 channels on freenode, publically logged ;)
04:00:37 <RyanT5000> haha i mean the beta itself
04:00:37 <quicksilver> secrecy fail?
04:00:40 <quicksilver> ;)
04:00:42 <RyanT5000> i don't mean the existence of the beta :P
04:00:50 <ManateeL`> RyanT5000: IMO, java is the most mature, haskell on mobile devices may have this or that problem and needs more time to debug.
04:01:01 <RyanT5000> we've had no problems so far
04:01:05 <RyanT5000> and we've been using it for a year now :)
04:01:26 <RyanT5000> the only thing is that we have to do frequent memory profiling audits
04:01:34 <ManateeL`> RyanT5000: Looks cool, have any screenshot?
04:01:35 <RyanT5000> because Haskell's tricky with memory, and phones don't have much :)
04:01:43 <RyanT5000> we'll be putting up screenshots soon
04:01:54 <RyanT5000> as soon as it's indisputably awesome :)
04:02:17 <ManateeL`> RyanT5000: When i was j2me programmer, i just have 800kb memory can use.
04:02:19 <Starfire> It has to be pretty stressful developing for a platform you don't know if you're even allowed to publish for.
04:02:44 <RyanT5000> Starfire: it is, although i wouldn't say that's the most stressful thing about starting this company :)
04:03:01 <RyanT5000> we knew going in that Apple was a harsh master
04:03:20 <ManateeL`> RyanT5000: And package must less than 250kb.
04:03:22 <Cale> Heh, maybe you can get Haskell explicitly added to the list of permitted programming languages ;)
04:03:35 <RyanT5000> Cale: i'll try petitioning Jobs myself :P
04:04:02 <quicksilver> well, the only approach I can imagine being sanctioned is official haskell support in XCode
04:04:07 <Starfire> But you're probably right in saying that Apple could ban you from the app store for many other reasons as well if they wish.
04:04:09 <ManateeL`> RyanT5000: I guess memory is big problem for Haskell mobile game.
04:04:12 <quicksilver> what they want is to make sure everyone uses XCode
04:04:23 <RyanT5000> quicksilver: well, we use XCode :)
04:04:24 <quicksilver> (one of the many things they want, rather)
04:04:26 <RyanT5000> we even go -via-c!
04:04:28 <mjrosenb> can you write a haskell interpreter in an acceptable language
04:04:28 <quicksilver> RyanT5000: you know what I meant :)
04:04:32 <ManateeL`> RyanT5000: If just for android and iphone, should be okay.
04:04:36 <mjrosenb> then yeah...
04:04:38 <RyanT5000> quicksilver: yup
04:04:38 <Starfire> mjrosenb: Interpreters are banned from the iPhone.
04:04:44 <mjrosenb> Starfire: oic...
04:05:01 <scree> once the game has a large enough circulation, you can hold apple to ransom
04:05:03 <RyanT5000> Starfire: what that actually *means* is another thing :P
04:05:05 <quicksilver> mjrosenb: on the other hand, every single application on the app store violates one or more of apple's guidelines.
04:05:07 <Starfire> Or rather, non-Apple-sanctioned interpreters, which AFAIK includes everything else but Webkit JavaScript.
04:05:12 <RyanT5000> quicksilver: exactly
04:05:17 <RyanT5000> if apple wants to screw us, they will
04:05:20 <mjrosenb> quicksilver: hells yeah.
04:05:22 <RyanT5000> the game is to make them not want to
04:05:24 <quicksilver> mjrosenb: so the guidelines are essentially a waste of electrons.
04:05:36 * mjrosenb has not considered purchasing an iphon yet
04:05:42 <quicksilver> good for /. and reddit flamewars, though :)
04:05:46 <int-e> scree: heh. "large enough" = Steve Jobs has it on his iPhone and enjoys the game? ;-)
04:05:48 <aristid> ManateeL`: i don't think targeting j2me makes a lot of sense, it's dying and the users aren't as active as smartphone users
04:06:06 <RyanT5000> int-e: haha; hopefully Jobs likes action-roleplaying games :)
04:06:18 <scree> int-e: would work.  Or so large they realize their market share will plummet unless they allow the app
04:06:20 <RyanT5000> there are only a couple good ones, so we could have a chance :
04:06:21 <RyanT5000> :)
04:06:46 <Starfire> I think Apple is just following the normal modus operandi for dictators: if your laws are such that everyone's a criminal, you can go after anyone if you want. :)
04:07:12 <RyanT5000> yep
04:07:15 <Starfire> There's probably a better phrased quote for that somewhere, but I can't find it.
04:07:22 <aristid> Starfire: the sad thing is they claim they do it for quality
04:07:23 <RyanT5000> Android is growing faster than iPhone now anyway
04:07:28 <aristid> but they exclude superior languages
04:07:45 <Starfire> aristid: Isn't that the standard Apple excuse for every irrational decision they make?
04:07:54 <aristid> i guess
04:08:07 <Starfire> "We wish to control the user experience so that..."
04:08:10 <danderson> apple doesn't really need excuses though
04:08:11 <aristid> also, why don't macbooks have UMTS support (when we're at ranting about apple) :D
04:08:17 <RyanT5000> of course; just like dictators make crazy laws to "protect the motherland" and "keep the peace" :)
04:08:30 <danderson> "if you're not happy, sod off" is the usual response, not justifications
04:08:31 <RyanT5000> but apple certainly has created a good device and platform
04:09:28 <RyanT5000> also, i'd just like to point out that a lot of people on reddit and this channel have a bias, of which i am frequently guilty as well
04:09:46 <Starfire> Haskell bias? :)
04:09:47 <RyanT5000> which is overvaluing code
04:10:05 <RyanT5000> frankly, rewriting 100% of the code in our project would be less than 20% of the total cost of the project
04:10:19 <RyanT5000> yes, the delay would suck, and yes, i would be really, really annoyed
04:10:47 <RyanT5000> but we've got a ton of storyline and game design and art and music and other things that went into this project
04:11:05 <RyanT5000> and those have nothing to do with the Apple license agreement
04:11:07 <Starfire> Of course, if you had to rewrite, you would know pretty much exactly what you're trying to write.
04:11:11 <RyanT5000> right
04:11:12 <RyanT5000> in fact
04:11:18 <RyanT5000> i would quickcheck all my C++
04:11:18 <Starfire> Which in my experience vastly speeds up coding.
04:11:29 <RyanT5000> indeed
04:12:05 <RyanT5000> so, whatever; i'll roll with apple's punches if i need to :)
04:12:17 <ManateeLazyCat> RyanT5000: http://farm5.static.flickr.com/4036/4641162603_b39bfd4cc2_o.jpg The one of my business mobile game.
04:12:38 <RyanT5000> i have a pile of backup plans for whatever they can throw at us, and if, at the end of the day, they don't want our products, we'll take them elsewhere
04:12:46 <ManateeLazyCat> RyanT5000: That's the design map. :)
04:12:48 <RyanT5000> ManateeLazyCat: looks cool :)
04:12:59 <RyanT5000> it reminds me of some cool games i played back in the day
04:15:32 <Starfire> Anyway, I wish you luck!
04:15:44 <RyanT5000> Starfire: thanks :)
04:16:18 <ManateeLazyCat> http://farm5.static.flickr.com/4037/4641775916_c2163f46d8_o.gif my favourites weapon -- laser.. :)
04:16:29 <RyanT5000> nice :)
04:16:58 <Starfire> Have you had any speed issues because of GC?
04:17:25 <RyanT5000> Starfire: yes; it amounts to about a 0.12 second pause, according to our measurements
04:17:57 <RyanT5000> and that happens about once every 90 seconds
04:18:02 <RyanT5000> so our rendering thread runs a tight C++ loop which executes the instructions coming from haskell
04:18:12 <Starfire> So good enough for non-realtime games, but not a good option for realtime games?
04:18:15 <RyanT5000> so that we don't drop frames even if Haskell gets stuck in a GC
04:18:23 <RyanT5000> we're quite realtime :)
04:18:26 <Starfire> Great!
04:18:41 <quicksilver> RyanT5000: does forcing the GC to occur more often reduce it below 0.12 seconds?
04:18:55 <RyanT5000> quicksilver: we weren't able to reliably reduce it to under a frame
04:18:59 * quicksilver nods
04:19:04 <RyanT5000> i don't remember all the details of our tests, but we did try that
04:19:07 <quicksilver> what are you targetting? 60fps?
04:19:11 <RyanT5000> 30fps
04:19:14 * quicksilver nods
04:19:18 <Starfire> Perhaps the new Immix GC will be helpful.
04:19:24 <ManateeLazyCat> quicksilver: 30 fps is enough
04:19:37 <quicksilver> a 2-core ARM would be helpful :)
04:19:40 <RyanT5000> Starfire: i haven't heard about that; we're stuck on GHC 6.10.4
04:19:57 <RyanT5000> we'll be upgrading after this release, but our ghc-iphone work will require some changes to get to HEAD
04:20:07 <RyanT5000> quicksilver: quite helpful indeed
04:20:15 <ManateeLazyCat> RyanT5000: Your game is 2-D or 2.5-D ?
04:20:17 <Jafet> Unreal 3 now runs at 300 fps, plan for the future
04:20:23 <quicksilver> RyanT5000: also, via-c doesn't really produce very good code :-(
04:20:24 <RyanT5000> ManateeLazyCat: 3D
04:20:25 <Starfire> RyanT5000: It's not implemented yet, but there's a GSoC project this summer to implement that in GHC.
04:20:27 <ManateeLazyCat> RyanT5000: Or your own 3-D engine?
04:20:35 <RyanT5000> quicksilver: that's alright; we profile all the time, and it's good enough for us :)
04:20:45 <ManateeLazyCat> RyanT5000: So you have use Haskell build your own 3-D engine?
04:20:59 <RyanT5000> yes, we built our own engine using Haskell and C++
04:21:06 <RyanT5000> it's built directly on OpenGL and OpenAL
04:21:07 <quicksilver> Jafet: just clip your engine to 30fps and rely on future graphics cards to do hardware interpolation between frames :)
04:21:34 <Jafet> Ironically, the new multi-GPU (SLI or CrossFire) setups themselves introduce frame stuttering
04:21:39 <ManateeLazyCat> quicksilver: Mobile game is more limit.
04:21:41 <Starfire> It would be cool if the new LLVM backend would allow targeting ARM without via-c.
04:21:56 <ManateeLazyCat> RyanT5000: Open-Source ?
04:22:00 <Jafet> (Do mobiles have graphics cards?)
04:22:10 <quicksilver> Jafet: well, graphics chipsets
04:22:11 <RyanT5000> ManateeLazyCat: our ghc-iphone project is open source (BSD)
04:22:21 <RyanT5000> the game is not, since we want to make money :P
04:22:32 <RyanT5000> Jafet: the iPhone has a pretty good GPU
04:22:37 <RyanT5000> it's a PowerVR MBX
04:22:39 <quicksilver> Starfire: I think an ARM native codegen was on the way with or without LLVM
04:22:39 <ManateeLazyCat> RyanT5000: Is your company develop ghc-iphone ?
04:22:43 <RyanT5000> ManateeLazyCat: yes
04:22:48 <Jafet> Interesting
04:22:52 <ManateeLazyCat> RyanT5000: Wow, that's cool.
04:22:55 <RyanT5000> there's been a bit of community development since then, but most of it is ours
04:23:04 <quicksilver> Starfire: the reason RyanT5000 uses via-c is probably not entirely because there isn't a ARM native codegen he can use
04:23:07 <ManateeLazyCat> RyanT5000: I have heard ghc-iphone, but don't know is your company. :)
04:23:15 <quicksilver> it's persumably also to fit into the apple code chain
04:23:28 <quicksilver> (?)
04:23:41 <ManateeLazyCat> RyanT5000: I need dinner now, nice to meet you. :)
04:24:08 <RyanT5000> ManateeLazyCat: nice to meet you too :) have a good day
04:24:15 <RyanT5000> quicksilver: yeah, although i don't think it would be too hard to integrate a native codegen
04:24:35 <RyanT5000> but we are heavily using Apple's toolchain
04:24:59 <RyanT5000> we've had to rewrite a few core algorithms in C, which we might not have had to do if we were using a native codegen
04:25:15 <RyanT5000> but, frankly, we quickcheck them, and it's really easy
04:25:29 <RyanT5000> it's not a significant proportion of our development time
04:26:00 <Jafet> How would native compiling obviate the need to integrate with Apple toolchain (by that you mean xcode and the like?)
04:26:15 <RyanT5000> well, it would *decrease* the apple toolchain use
04:26:21 <RyanT5000> i.e.: we wouldn't use their gcc as much
04:26:31 <RyanT5000> we'd still need to use their codesigning and linking and packaging tools
04:27:17 <RyanT5000> i have no particular distaste for Xcode, though; it gets the job done :)
04:29:01 <ManateeLazyCat> RyanT5000: Oh, i remember my Chinese friend is use ghc-iphone develop haskell program. Do you interested?
04:29:27 <ManateeLazyCat> RyanT5000: Maybe he can work for you.
04:29:28 <RyanT5000> yeah, i'd love to get in touch with anyone using it
04:29:38 <RyanT5000> whether or not he wants to work for me :)
04:29:39 <ManateeLazyCat> RyanT5000: Ok, i check my mail.
04:29:45 <RyanT5000> thanks
04:30:33 <ManateeLazyCat> RyanT5000: Your company site?
04:30:41 <RyanT5000> ipwnstudios.com
04:30:45 <RyanT5000> my email is ryan@ipwnstudios.com
04:31:04 <RyanT5000> you can feel free to give it to anyone (i just gave it to the whole internet in this chat log :P)
04:31:10 <RyanT5000> bring it on, spammers!
04:33:28 <Stuck-Student> hi, i am learning haskell and I am stuck on a particular problem to do with using folds and strings, can anyone help out?
04:33:40 <RyanT5000> Stuck-Student: most likely; ask away :)
04:33:46 <earthy> probably ;)
04:34:06 <danderson> Stuck-Student: probably; also, don't be afraid to directly ask your question, instead of opening up with a meta-question :)
04:34:23 <Stuck-Student> i have an assignment which asks me to define a function prefixes :: String -> [String] that returns a list of prefixes to the input string
04:34:29 <danderson> meta-questions can only be meta-answered, might as well go straight for the real question :)
04:34:46 <Stuck-Student> eg "Hello" would return ["h", "he", "hel", "hell"]
04:34:53 <earthy> @hoogle inits
04:34:53 <lambdabot> Data.ByteString inits :: ByteString -> [ByteString]
04:34:54 <lambdabot> Data.List inits :: [a] -> [[a]]
04:34:54 <lambdabot> Data.ByteString.Char8 inits :: ByteString -> [ByteString]
04:35:18 <Stuck-Student> i made one using recurision, but i think a version using folds would work too
04:35:25 <Stuck-Student> but i cant get it to go :(
04:35:28 <earthy> oh, sorry.
04:36:14 <earthy> well, write down the type you'd want and try to work from there
04:36:19 <Stuck-Student> apologies for the meta questions ;)
04:36:23 <Cale> Stuck-Student: Would it really leave out the 'o' like that?
04:36:33 <danderson> Stuck-Student: if it makes you feel any better, Data.List.inits (the stdlib implementation) doesn't use folds either. It uses explicit recursion.
04:37:10 <danderson> I'm actually not entirely sure that you can get away with using a fold on this problem, but my brain is half-asleep today, so don't trust me.
04:37:17 <earthy> prefixes :: [Char] -> [[Char]]  would then use   fold :: (a -> b -> b) -> b -> [a] -> b   specialized to the correct types
04:37:48 <Stuck-Student> actually I had been using scanl, not folds
04:37:59 <Stuck-Student> so it gives me a list
04:38:04 <earthy> i.e. fold :: (Char -> [[Char]] -> [[Char]]) -> [[Char]] -> [Char] -> [[Char]]
04:39:08 <earthy> now, the first argument to that fold would 'extend' the list of prefixes with an extra char
04:39:10 <Cale> There's an easy enough foldr way
04:39:26 <Cale> but it'll naturally include the whole string at the end
04:39:45 <Cale> > foldr (\x xs -> [x] : map (x:) xs) [] "abcd"
04:39:46 * danderson lets earthy do a walkthrough, clearly has less brain impairement than himself today
04:39:46 <lambdabot>   ["a","ab","abc","abcd"]
04:40:02 <Stuck-Student> ok, im not sure if its a problem if it does include the whole string at the end, the instructions are quite vague
04:40:29 <Cale> > foldr (\x xs -> map (x:) ([]:xs)) [] "abcd"
04:40:30 <lambdabot>   ["a","ab","abc","abcd"]
04:41:08 <Cale> > foldr (\x xs -> [] : map (x:) xs) [] "abcd" -- oh hey
04:41:09 <lambdabot>   ["","a","ab","abc"]
04:41:10 <danderson> Stuck-Student: worst case, the whole string will turn out to be the last in the list
04:41:28 <danderson> and it so happens that the `init' function returns all elements of a list but the last :)
04:41:47 <nominolo> @tell byorgey I was just wonderng whether you were planning a hackathon around ICFP, given that Baltimore is relatively close to Philly.
04:41:47 <lambdabot> Consider it noted.
04:41:50 <Stuck-Student> hmm thanks Cale that works a treat, but i dont really get what its doing...
04:42:11 <Cale> > foldr (\x xs -> [] : map (x:) xs) [[]] "abcd" -- another variation on behaviour
04:42:12 <lambdabot>   ["","a","ab","abc","abcd"]
04:42:20 <Cale> Stuck-Student: Okay
04:42:22 <nominolo> @tell byorgey It's not clear whether I'll be coming to the next ICFP, though, so that's all speculative
04:42:23 <lambdabot> Consider it noted.
04:42:49 <Cale> Stuck-Student: The "right" way to think about foldr f z is that it replaces each (:) in a list with the function f, and the [] at the end with z
04:42:57 <Stuck-Student> i appreciate your help so far too, i was about to tear my hair out on this one :)
04:43:18 <Cale> Stuck-Student: That is, you can imagine that it retroactively changes how the list has been built up in the first place.
04:44:12 <Stuck-Student> hmm ok, so i suppose it is similar to 'iterating' it in a sense, but applying a function while it goes
04:44:13 <Stuck-Student> ?
04:44:30 <Cale> Sort of, yeah, let me get you a diagram...
04:44:45 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
04:45:12 <Cale> Look at the picture for foldr in the top left corner there
04:45:57 <Cale> It shows what the generic foldr f z is going to do to the list [1,2,3,4,5], which is just another way of writing 1:(2:(3:(4:(5:[]))))
04:46:30 <Stuck-Student> yep ok, got that
04:47:37 <Cale> Okay, so there are two questions to think about: 1) What do we replace the empty list with? 2) If we had the list of prefixes for some list xs, how would we get the list of prefixes for x:xs?
04:48:01 <Cale> That is, what do we replace [] with, and what do we replace (:) with?
04:48:28 <Cale> So, prefixes [], based on your example, is probably just going to be []
04:48:37 <Cale> So, that tells us what z should be
04:49:04 <Stuck-Student> so 1) would be an empty list?
04:49:07 <Cale> yeah
04:49:18 <Stuck-Student> i think i had that at some point but deleted it :P
04:49:20 <Cale> That, or a list with just an empty list in it
04:49:33 <Cale> Those are the only two sensible options
04:49:48 <Stuck-Student> and 2) would that just be to find the prefixes of x?
04:49:50 <Cale> Depending on whether you want to count the empty prefix or not
04:50:06 <Stuck-Student> since we already know the prefixes of xs?
04:50:28 <Cale> Well, for 2), we want to account for the prefix that just has x, and then we want to add x into each of the prefixes for xs, yeah?
04:51:04 <Stuck-Student> yep makes perfect sense
04:51:06 <Cale> Like, if we have  prefixes "bcd" = ["b","bc","bcd"]
04:51:20 <Cale> and we want prefixes "abcd" = ["a","ab","abc","abcd"]
04:51:33 <aristid> @pl f x y = y
04:51:34 <lambdabot> f = const id
04:51:38 <Cale> okay
04:52:12 <Stuck-Student> ok, so join x onto the front of the first one
04:52:13 <Cale> So, the function which I wrote to do that is just (\x xs -> [x] : map (x:) xs)
04:52:33 <Cale> Where here, xs is the list of prefixes for the rest of the list.
04:53:01 <Cale> Might do better to have named it ps or something.
04:53:38 <Stuck-Student> maybe silly, but what does the (x:) represent in map /
04:53:39 <Stuck-Student> ?
04:53:48 <Cale> Oh, that's the function which adds x to the beginning of a list
04:53:54 <Cale> (x:) xs = (x:xs)
04:54:00 <Cale> It's an operator section
04:54:10 <Cale> You can do it with any infix operator
04:54:10 <Stuck-Student> oh right, of course
04:54:15 <Stuck-Student> i just finished reading about that
04:54:36 <Stuck-Student> how every function only takes one argument technically
04:54:40 <Cale> yeah
04:54:41 <Stuck-Student> right?
04:55:06 <Cale> Though, you can also write (:xs), which desugars to (\x -> x:xs)
04:55:37 <Cale> But in this case, the section is particularly easy, because (:) is secretly a function of one parameter anyway, so (x:) really just means (:) x
04:55:49 <mux> funny that you should talk about such a function
04:56:11 <marcot> Hi, I'm getting a build failure of gtk2hs 0.10.1 in ghc 6.12.1.  It's strange because with the exact same package it used to build with the same ghc version.
04:56:19 <marcot> https://buildd.debian.org/fetch.cgi?&pkg=gtk2hs&ver=0.10.1-4%2Bb1&arch=amd64&stamp=1266729261&file=log
04:56:20 <mux> Cale: I just had to code a generalization of that
04:56:24 <marcot> This is a correctly build.
04:56:31 <marcot> http://people.debian.org/~marcot/build.log
04:56:35 <marcot> And this is a failed build.
04:56:50 <marcot> What's the problem in the second one?  The source is exactly the same.
04:57:21 <mux> Cale: http://paste.lisp.org/display/100503
04:57:28 <Cale> marcot: At the very end there, it's saying that glib-0.10.1 is unusable due to missing base-4.2.0.0
04:57:35 <mux> Cale: I'm interested if you see a way to code this more elegantly
04:57:45 <Cale> marcot: Perhaps you could check which version of base comes with 6.12.1?
04:57:48 <Stuck-Student> Cale: ok thanks, i'll refactor what i have and see how that goes. im only on problem 1.2 of 3 so i might be back :)
04:58:05 <marcot> Cale: Yes, I noticed.  I think this may be caused by some changes in the -13 revision of ghc6, maybe in ghc-pkg.
04:58:11 <Cale> Stuck-Student: Yeah, feel free to ask questions and hang out here :)
04:58:30 <marcot> Cale: base-4.2.0.0 is here. =)
04:58:41 <mux> @let dist f (x:xs) = (f x : xs) : map (x:) (dist f xs); dist f []     = []
04:58:42 <lambdabot>  Defined.
04:58:44 <Cale> marcot: Okay, weird
04:58:51 <mux> > dist (1:) [2,3,4]
04:58:52 <lambdabot>   No instance for (GHC.Num.Num [t])
04:58:53 <lambdabot>    arising from a use of `e_11234' at <in...
04:59:04 <mux> err
04:59:15 <ManateeLazyCat> marcot: gtk2hs-0.10.1 failed with ghc-6.12.1 ?
04:59:20 <mux> > dist (1:) [[2],[3],[4]]
04:59:20 <aristid> Cale: a big PDF with your folds would be cool for hanging it on the wall :)
04:59:21 <lambdabot>   [[[1,2],[3],[4]],[[2],[1,3],[4]],[[2],[3],[1,4]]]
04:59:29 <Cale> aristid: :)
04:59:41 <ManateeLazyCat> marcot: Why you need gtk2hs-0.10.1 ? We have release gtk2hs-0.11.0
04:59:45 <Cale> aristid: Well, I have an SVG version of it
04:59:56 <aristid> Cale: with all of em?
05:00:12 <Cale> aristid: Yeah, should be linked there... let me know if anything is missing.
05:00:24 <aristid> ah yeah with all
05:00:25 <marcot> ManateeLazyCat: I'm the debian maintainer of gtk2hs.  There's a problem in the upgrade script of gtk2hs 0.10.1, which I only noticed now that 0.11 was released.
05:00:48 <marcot> ManateeLazyCat: So I have to create a new 0.10.1 revision to manage the upgrade more smootlhy.
05:01:11 <marcot> ManateeLazyCat: But as this build failure is being dificult to treat, I think I'll solve it using another strategy.
05:01:13 <Cale> mux: That's slightly awkward in that it's not naturally a foldr, because you make use of xs alone, and not just dist f xs
05:01:18 <ManateeLazyCat> marcot: I know.
05:01:35 <dcoutts> marcot: sorry, can't help, I can't see the build log, it's got a bad ssl cert and it does not seem to be available by plain http
05:01:40 <mux> Cale: yeah, I came to the conclusion this can't be a gold too
05:01:41 <ManateeLazyCat> marcot: Do you "--disable-split-objs"?
05:01:41 <mux> err, fold
05:01:47 <Cale> hmmm
05:02:15 <marcot> dcoutts: You mean the first one, right?  This one was the correct build, so it's not the most important.
05:02:30 <marcot> dcoutts: It's just to get a contrast with the build failure.
05:02:35 <marcot> ManateeLazyCat: Yes.
05:02:57 <ManateeLazyCat> autoreconf && ./configure --with-hcflags=-O0 --disable-split-objs && make && sudo make install
05:03:15 <ManateeLazyCat> marcot: above is my install command for gtk2hs-0.10.1
05:03:17 <dcoutts> marcot: oh looks like the build machine has a borked package database, it's missing base
05:03:32 <ManateeLazyCat> dcoutts: I see.
05:03:42 <ManateeLazyCat> marcot: "ghc-pkg check" first
05:03:43 <Cale> Good old lisppaste, reminds me of the days when we all used it more regularly here.
05:03:45 <dcoutts> marcot: see where it says: glib-0.10.1 is unusable due to missing or recursive dependencies: base-4.2.0.0
05:04:01 <marcot> dcoutts: ghc-pkg list in the build machine sais base-4.2.0.0 is available.
05:04:09 <marcot> dcoutts: No problem with ghc-pkg check too.
05:04:37 <ManateeLazyCat> marcot: Hmm, that's strange....
05:04:55 <quicksilver> but debian builders try to install packages temporarily, for this install
05:05:10 <dcoutts> marcot: then try the failing command directly
05:05:15 <quicksilver> one of those which is temporarily pulled in must be incompatible with any that are permanently installed on teh machine
05:05:24 <marcot> dcoutts: I've tried, and got the same output.
05:05:30 <dcoutts> marcot: note that it's using a local package db
05:05:42 <dcoutts> marcot: so you could run ghc-pkg list with that local db
05:07:54 <marcot> dcoutts: Yes, the local package.conf is broken.
05:08:29 <dcoutts> marcot: so we want to work out precisely how it's broken and why
05:08:47 <Cale> mux: Another thing this seems related to are selection functions like:  select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs], and separate [] = []; separate (x:xs) = ([],x,xs) : [(x:us,v,vs) | (us,v,vs) <- separate xs]
05:09:52 <marcot> dcoutts: I think it's getting too complicated.  I'll make the 0.11 package clean the trash left by the broken upgrade script in 0.10.1.  I think it's a safer approach than fixing the old build just to correct the upgrade script.
05:09:56 <Cale> mux: In fact, it's easy to write dist f xs = [us ++ f v : vs | (us,v,vs) <- separate xs]
05:10:01 <marcot> dcoutts: But thanks for your help.
05:10:05 <mux> Cale: nice
05:10:31 <Cale> These two functions I wish were in Data.List
05:10:49 <Cale> select is a natural first step to building permutations.
05:11:25 <Cale> Maybe there's something we're missing though. Probably there's a generic recursion scheme behind this.
05:11:26 <mux> yeahs, Data.List could have some more useful functions
05:11:34 <mux> but it's cool that there is subsequences and permutations now
05:11:46 <Cale> (It probably even has a name, if I could be bothered to look through the ones which do :)
05:12:04 <aristid> @src mapAccumL
05:12:04 <lambdabot> mapAccumL _ s []        =  (s, [])
05:12:05 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
05:12:05 <lambdabot>    where (s', y ) = f s x
05:12:05 <lambdabot>          (s'',ys) = mapAccumL f s' xs
05:12:12 <mux> yeah, probably something that is impossible to say and ends with morphism :)
05:12:55 <Cale> edwardk would know the name for it :)
05:13:49 <ManateeLazyCat> marcot: I think gtk2hs-0.11 is very different with gtk2hs-0.10.1, maybe you need build new script to build Debain package.
05:14:20 <marcot> ManateeLazyCat: Yes, I've done this already. =)
05:14:54 <phindmarsh> as an aside to my earlier questions (i was Stuck-Student but just switched to a destop IRC client) how do i pattern match a string with only one character in it in a function definition?
05:16:12 <phindmarsh> i tried [x] but i got type errors
05:16:14 <Cale> @let scheme f z [] = z; scheme f z (x:xs) = f x xs (scheme f z xs)
05:16:15 <lambdabot>  Defined.
05:16:29 <Cale> > let dist f = scheme (\x xs ps -> (f x : xs) : map (x:) ps) [] in dist (+10) [1,2,3,4]
05:16:30 <lambdabot>   [[11,2,3,4],[1,12,3,4],[1,2,13,4],[1,2,3,14]]
05:17:47 <Cale> > let select = scheme (\x xs ps -> (x,xs) : map (second (x:)) ps) [] in select [1,2,3,4]
05:17:48 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
05:18:22 <Cale> Oh, hey...
05:18:38 <Cale> @undefine
05:20:35 <Cale> @let scheme f z = foldr (uncurry f) z . (zip `ap` tails)
05:20:36 <lambdabot>  Defined.
05:20:43 <Cale> > let select = scheme (\x xs ps -> (x,xs) : map (second (x:)) ps) [] in select [1,2,3,4]
05:20:44 <lambdabot>   [(1,[1,2,3,4]),(2,[1,2,3,4]),(3,[1,2,3,4]),(4,[1,2,3,4])]
05:20:51 <Cale> ah, not what I wanted
05:21:06 <Cale> @undefine
05:21:09 <Cale> hmm
05:22:22 <lpeterse> can someone help me with a problem concerning syb?
05:23:14 <Cale> ah, need a drop 1
05:23:22 <Cale> @let scheme f z = foldr (uncurry f) z . (zip `ap` (drop 1 . tails))
05:23:23 <lambdabot>  Defined.
05:23:27 <Cale> > let select = scheme (\x xs ps -> (x,xs) : map (second (x:)) ps) [] in select [1,2,3,4]
05:23:28 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
05:23:48 <Cale> > let dist f = scheme (\x xs ps -> (f x : xs) : map (x:) ps) [] in dist (+10) [1,2,3,4]
05:23:49 <lambdabot>   [[11,2,3,4],[1,12,3,4],[1,2,13,4],[1,2,3,14]]
05:24:12 <Cale> So, that's not perfect, but it is a foldr with some additional stuff.
05:24:41 <Cale> lpeterse: Ask away, though I really don't know a whole lot about syb, it's possible someone knows enough :)
05:24:49 <lpeterse> it
05:25:04 <lpeterse> is basically about this piece of code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25712
05:26:11 <lpeterse> i spent the weekend understanding syb. as far as i understand one states special cases for types that are treated seperately
05:26:36 <Cale> hmm, interesting idea
05:26:37 <lpeterse> what i want is to define a special cases for a whole class of types
05:26:57 <Cale> btw, there's a missing type variable in your explicit type signature, I'm pretty sure
05:27:10 <Cale> er...
05:27:28 <Cale> Put is a monad isn't it?
05:27:36 <lpeterse> yes, it
05:27:49 <lpeterse> 's from data.binary
05:27:56 <Cale> yeah, so a -> Put is a kind error
05:28:01 <lpeterse> i'm rewriting data.binary in a generic way
05:28:10 <Cale> Yeah, that looks interesting.
05:29:08 <Cale> Does it complain because f is polymorphic?
05:29:32 <lpeterse> he say 'a' is ambigous
05:29:45 <Cale> hmm, yeah
05:30:05 <lpeterse> Ambiguous type variable `a' in the constraint: 'Data a'
05:30:21 <Cale> Is it important for serial to be in any way compatible with the existing instances of Put?
05:31:13 <Cale> But... this sort of thing ought to be doable...
05:32:10 <lpeterse> i'm not sure what you mean. i want to reuse the 'basic cases' like int and list but the serialisiation of anything elso should follow the general pattern
05:33:13 <quicksilver> that overlaps, lpeterse
05:33:14 <Cale> okay
05:33:17 <quicksilver> typeclasses don't work like that
05:33:22 <quicksilver> [] is also a Data instance
05:33:29 <Cale> But (,) should already be handled, in that case
05:33:53 <quicksilver> so it can't choose between a built in Put instance (built in to the binary library, I mean) and one that comes generically from a Data instance.
05:34:25 <lpeterse> quicksilver: any idea of how to do what i tried to do instead?
05:35:42 <Cale> Now that I look at how extQ works, I'm less confident it's possible to make it work for polytypes like that.
05:35:59 <Cale> (Only monotypes can be instances of Typeable)
05:37:28 <quicksilver> surely you can't expect serialisation of polytypes?
05:37:44 <quicksilver> you want uniform serialisation of each instance of a polytype
05:37:50 <Cale> quicksilver: Yeah
05:37:57 <quicksilver> which is a weaker/easier thing
05:38:14 <Cale> It's easier, but extQ won't help (I think)
05:39:19 <Cale> In any case, I think the sensible thing would be not to write a special case for (,) at all, and treat it like any other datatype
05:41:22 <lpeterse> this is of course a possibility. but Data.Binary has for example a special implementation for List which make much sense regarding size of the serialisation
05:42:03 <phindmarsh> whats the best way to find a substring without using a dedicated library function?
05:42:49 <Cale> phindmarsh: Well, start with writing it in terms of library functions, and reduce them to their definitions :)
05:43:07 <Cale> @src isInfixOf
05:43:08 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
05:43:10 <quicksilver> lpeterse: the thing that is scary about special cases is eventually you find a problem with one
05:43:14 <quicksilver> lpeterse: and then you want to fix it
05:43:15 <phindmarsh> i have written one using tail, but wondered if there was anything better
05:43:17 <Cale> You can replace any with find
05:43:27 <Cale> Or findIndex
05:43:27 <quicksilver> lpeterse: and then you discover that you really wish you had a versioning system :-(
05:43:44 <Cale> tails and isPrefixOf have easy definitions
05:43:57 <quicksilver> lpeterse: if Binary-x.y has a bugfix it may be unable to read file written by Binary-(x-1)
05:44:05 <scree> phindmarsh: do you mean, better than O(nm) complexity?
05:44:07 <quicksilver> lpeterse: do your plans include a versioning system? :)
05:44:37 <phindmarsh> i did one like this: http://pastebin.org/283190 (dont cringe too much :P)
05:44:52 <Cale> There's actually a really easy way to implement Knuth-Morris-Pratt substring search.
05:45:14 <RyanT5000> has anyone looked into doing serialization in the same way that vacuum works?
05:45:16 <Cale> Well, compared to the imperative versions of the algorithm :P
05:45:23 <lpeterse> the project is a linguistic framework. the binary format will be well documented and stable as soon as we are sure with it
05:45:30 <RyanT5000> am i the only person who wants a serialization system that works on all haskell values?
05:45:51 <Starfire> How would you serialize function values?
05:45:56 <Cale> phindmarsh: If you're going to go that way, use moar pattern matching :)
05:46:06 <phindmarsh> haha, ok
05:46:22 <Cale> phindmarsh: 'head' and 'tail' are a good way to accidentally write a function which crashes in some cases
05:46:24 <phindmarsh> im still in iterative programming land
05:46:31 <scree> phindmarsh: the (head a == head b) check seems redundant
05:46:34 <RyanT5000> Starfire: approximately: their info table pointer plus anything in their closures
05:46:46 <RyanT5000> i'm not talking about a referentially-transparent thing here
05:46:50 <Cale> Yeah, that's true as well
05:47:04 <Cale> also, the take is painful
05:47:05 <phindmarsh> scree: so you are correct, thanks for pointing that out
05:47:05 <RyanT5000> i'm talking about a dirty, nasty, IO-based way of getting my application's state written down
05:47:06 <quicksilver> RyanT5000: It's been done. Probably more than once.
05:47:13 <quicksilver> RyanT5000: each time it gets bitrotted.
05:47:14 <RyanT5000> quicksilver: is it usable?
05:47:17 <quicksilver> no.
05:47:19 <RyanT5000> that sucks
05:47:20 <phindmarsh> i had them seperated then i joined them without much thought
05:47:20 <Cale> phindmarsh: and (zipWith (==) needle haystack)
05:47:25 <RyanT5000> quicksilver: any particular reason?
05:47:28 <RyanT5000> heap formats change too quickly?
05:47:34 <Cale> well...
05:47:42 <Cale> actually, no, that doesn't work :P
05:47:52 <ManateeLazyCat> FRP, interested.....
05:47:53 <quicksilver> RyanT5000: phdware
05:48:01 <quicksilver> RyanT5000: http://www.macs.hw.ac.uk/~dsg/gdh/
05:48:01 <scree> any $ zipWith (==) needle haystack ?
05:48:15 <Cale> No, the problem is what happens when the haystack is too short
05:48:32 <quicksilver> RyanT5000: at least I *think* gdh contained a version of what you're saying.
05:48:34 <Cale> Too bad :P
05:48:36 <scree> ah, good point
05:48:41 <phindmarsh> could just make sure the needle is shorter than the haystack?
05:49:01 <Cale> phindmarsh: Yeah, but computing lengths of lists is admitting defeat
05:49:09 <phindmarsh> :P
05:49:13 <scree> phindmarsh: the point is that when you do a second pass like that, you're doing more work than you should
05:49:14 <Cale> phindmarsh: Better just to write an isPrefixOf
05:49:28 <Cale> phindmarsh: which does direct recursion
05:49:38 <Cale> @src isPrefixOf
05:49:38 <lambdabot> isPrefixOf [] _          = True
05:49:38 <lambdabot> isPrefixOf _  []         = False
05:49:38 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
05:49:52 <scree> phindmarsh: "proper" functions that don't have length will early-out if there's a match failure early on
05:50:01 <quicksilver> RyanT5000: happs does some funciton serialisation btu I think it's a different approach
05:50:05 <scree> phindmarsh: and take less than O(length of needle) time
05:50:24 <Jafet> There is always genericLength
05:50:42 <Cale> genericLength isn't really any better
05:50:45 <Cale> Well...
05:50:54 <Cale> You mean with lazy naturals?
05:51:06 <Cale> I think you still might end up doing more work than you need to.
05:51:07 <Jafet> (But only if you use lazy naturals, zip *and* takeWhile.)
05:51:12 <phindmarsh> ok cool, thanks for these pointers :)
05:51:15 <RyanT5000> quicksilver: i suspect GdH did have something like that
05:51:26 <RyanT5000> that "phdware" idea is very interesting
05:51:31 <RyanT5000> hmmm
05:51:35 <Jafet> It's also very silly, and is something you do for the sole purpose of being able to use genericLength.
05:51:39 <Cale> phindmarsh: Basically, you want to always use lists from left to right, and not do anything random-access-like with them.
05:51:45 <scree> > let isPrefixOf a b = a == zipWith const b a in isPrefixOf [1..10] [1..5]
05:51:46 <lambdabot>   False
05:51:50 <scree> > let isPrefixOf a b = a == zipWith const b a in isPrefixOf [1..10] [1..50]
05:51:50 <lambdabot>   True
05:51:57 <scree> > let isPrefixOf a b = a == zipWith const b a in isPrefixOf [2..10] [1..50]
05:51:57 <Cale> phindmarsh: Including computing the length, which involves running down the entire length of the list.
05:51:57 <lambdabot>   False
05:52:00 <RyanT5000> one of the main skills i'd like to develop in my company is the ability to grab cool things out of the PL academia and put them to good use in industry
05:52:05 <phindmarsh> ok cool
05:52:07 <Cale> phindmarsh: (and is thus quite expensive)
05:52:14 <RyanT5000> obviously anyone using Haskell is doing that to some extent, but i'd like to be very active about it'
05:52:16 <quicksilver> RyanT5000: furthermore, YHC had a version which sent the bytecode of the functions
05:52:23 <scree> phindmarsh: ^^^
05:52:29 <quicksilver> RyanT5000: which is fundamentally different to just sending the (name of) the info table
05:52:36 <RyanT5000> quicksilver: right
05:52:43 <RyanT5000> quicksilver: and more or less useful depending on one's needs
05:52:48 <Cale> phindmarsh: Obviously, there will always be some cases where it's impossible to avoid needing to know the length of a list, but usually we try to find more structural ways to do things.
05:52:54 <quicksilver> RyanT5000: so this problem has been solved at least three times in three completely different ways
05:53:00 <quicksilver> RyanT5000: and none of them are useful to you
05:53:02 <quicksilver> RyanT5000: sucks, doesn't it?
05:53:06 <RyanT5000> quicksilver: yes, lol
05:53:16 <RyanT5000> in about a year, i will pay good money for this feature :P
05:53:23 <Cale> scree: oh, that's cute
05:53:33 <RyanT5000> assuming that this game makes any money :P
05:53:38 <Jafet> Programming is one of those funny fields where the practice lags two decades or so behind the theory
05:53:54 <phindmarsh> Cale: yes, i understand the iteration ideas, i am lacking in the ability to exercise them at this point :)
05:54:04 <scree> Cale: thanks
05:54:09 <Ytinasni> Jafet: and by "funny fields" you mean "just like every other science"? :D
05:54:14 <RyanT5000> Jafet: yeah, but i think it could lag by less
05:54:15 <quicksilver> RyanT5000: sucks, doesn't it?
05:54:26 <quicksilver> RyanT5000: sorry, didn't mean to say that. There is also "Mobile Haskell"
05:54:30 <Jafet> If you factor in the fact that this field has only been around for about 80...
05:54:51 <quicksilver> RyanT5000: which, if I understand correctly, uses bytecode for local/dynamic functions but uses info-table pointers for library functions in fixed, compatible library versions.
05:55:05 <quicksilver> RyanT5000: http://www.macs.hw.ac.uk/~dubois/mhaskell/
05:55:08 <quicksilver> (yes, more phd-ware)
05:55:15 <RyanT5000> quicksilver: that sounds like a very sane approach; possibly not configurable enough, but a good default
05:55:27 <Cale> phindmarsh: If you don't want to be too fancy like scree's nice short version of it, the @src listing for isPrefixOf is probably instructive on how to go about that
05:55:32 <Cale> @src isPrefixOf
05:55:32 <lambdabot> isPrefixOf [] _          = True
05:55:32 <lambdabot> isPrefixOf _  []         = False
05:55:32 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
05:55:44 <RyanT5000> where do all these phds go once they graduate? lol
05:56:02 <Jafet> They breed and make more PhDs
05:56:06 <RyanT5000> hahaha
05:56:26 <Cale> It checks if either of the lists is empty, and gives an appropriate response in each case, and then if they're both nonempty, compares the first elements before proceeding to check the tails.
05:56:58 <Cale> Note that (&&) is defined in such a way that if its left parameter is False, it doesn't bother pattern matching the right one.
05:56:59 * ManateeLazyCat http://haskell.org/yale/publications.html have many books about FRP.
05:57:02 <Cale> @src (&&)
05:57:03 <lambdabot> True  && x = x
05:57:03 <lambdabot> False && _ = False
05:57:18 <quicksilver> Jafet: actually they breed, find they need money to support their offspring, get mortgages, and boring jobs.
05:57:25 <quicksilver> Jafet: and I speak from personal experience.
05:57:35 <Cale> So this isPrefixOf will stop immediately with False if the first element doesn't match, for example.
05:57:36 <soupdragon> on the news there was a report that said there was 60 to 70 percent chance of blah blah fixing the oil thing.. Why would thy not say 65% chance?
05:57:41 <Jafet> I'm talking about the non-biological kind of breeding
05:57:50 <bremner> soupdragon: error bars?
05:57:51 <soupdragon> Is there a difference between a 'range' of percentages and the medium
05:58:09 <quicksilver> implied error bars, yes
05:58:10 <Cale> (it won't get a chance to recurse, because (&&) won't use its second parameter)
05:58:11 <Jafet> It's similar to the von Neumann automaton process, actually.
05:58:25 <soupdragon> but percentage isn't a measurement
05:58:37 <quicksilver> soupdragon: ok, confidence interval then.
05:58:42 <lpeterse> quicksilver: ah, i could make a type distinction within the definition of the general case using typeable
05:58:53 <Jafet> Measuring chance in uncertainty bars -- typical news crap
05:59:01 <soupdragon> so it's a real thing?
05:59:10 <quicksilver> 65% has an implied confidence interval of +- 0.5% or +- 2.5% depending how you read it
05:59:16 <soupdragon> It has a stastical basis to say "between 60 and 70 percent"?
05:59:28 <quicksilver> where as 60-70% has an implied confidence interval of +- 10% (around the mean of 65)
05:59:32 <Cale> soupdragon: Suppose they'd said 30 to 100 percent chance
05:59:40 <Cale> soupdragon: Surely that's a different thing.
05:59:41 <quicksilver> heh, well it's not rigorous.
05:59:42 <RyanT5000> the most likely thing is that the news reporter thought it sounded better
05:59:44 <phindmarsh> scree: what does const do in your post earlier?
05:59:49 <RyanT5000> i give that a 80-90% chance
05:59:54 <soupdragon> Cale I don't know the difference because to me it's either going to happen or not
06:00:01 <byorgey> preflex: seen nominolo
06:00:01 <preflex>  nominolo was last seen on #haskell 1 hour, 17 minutes and 39 seconds ago, saying: @tell byorgey It's not clear whether I'll be coming to the next ICFP, though, so that's all speculative
06:00:01 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:00:12 <soupdragon> and a probability is just a guess
06:00:22 <Cale> soupdragon: Well, it might be just a guess.
06:00:24 <soupdragon> so what are they doing.. asking two people and reporting both answers?
06:00:31 <Jafet> soupdragon, then your brain is not yet contaminated by probability theory. Hope it stays that way but you'll never know
06:00:32 <soupdragon> I mean it just sounds ridiculous
06:00:40 <Cale> soupdragon: But they might actually have models which make concrete predictions about the probability.
06:00:49 <soupdragon> and I've seen my fair share of nonsense on the news so I was weary about it
06:01:22 <wli> It's nonsense. There are no models.
06:01:31 <Cale> soupdragon: There might be some probability distribution function of the likelihood of success, and they took an interval around the mean likelihood which covered 95% of the mass.
06:01:32 * ManateeLazyCat by all, night. 
06:01:42 <byorgey> @tell nominolo good question, I hadn't quite thought that far ahead yet.  Maybe we will try to organize an ICFP hackathon in conjunction with people at UMD.
06:01:42 <lambdabot> Consider it noted.
06:01:44 <Cale> soupdragon: It *probably* is just nonsense
06:02:09 <Cale> soupdragon: But there's at least a possibility that it's not.
06:03:14 <Jafet> There are also degrees of nonsensicality
06:04:22 <zygoloid> it could be the case that they have two plans, and the cheaper one has a 60% chance of success and the more expensive one has a 70% chance? :)
06:04:28 <RyanT5000> i think that if they understood the problem enough to accurately predict probabilities, they would probably know how to fix it :)
06:04:58 <RyanT5000> this isn't like quantum physics where you can say with certainty that something has an X% chance of having a particular effect
06:05:19 <RyanT5000> this is more like proving a conjecture; you don't even know if it's true until you've proved it
06:05:25 <zygoloid> it could be the case that they know of some reason why the probability of success is at least 60%, and they know of some reason why the probability of failure is at least 30%
06:05:25 <soupdragon> CAle oh okay so some sort of probaability that it's nonsense :P
06:05:41 <Cale> soupdragon: yeah
06:06:10 <scree> phindmarsh: const _ x = x
06:06:37 <scree> phindmarsh: so, zipWith const b a returns a list with values the same as "a", but only as long as "b"
06:07:10 <phindmarsh> scree: ah i see, thanks@
06:07:21 <scree> phindmarsh: it's a lazier version of take (length b) a
06:08:38 * soupdragon wonders if "60 to 70 percent chance of success" is just a odd way to say "probably"
06:09:23 <Jafet> It's more newsworthy.
06:09:25 <dv-> Probably
06:09:27 <zygoloid> "we asked three guys and two of them thought it'd work"
06:09:36 <soupdragon> haha
06:10:13 <geheimdienst> well it's more impressive than "probably"
06:10:33 <geheimdienst> same reason why wikipedia writes "a significant amount of" instead of "many"
06:10:37 <geheimdienst> ;-)
06:10:40 <aristid> > zipWith const [1,2,3,4,5] [1,2,39
06:10:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:10:43 <aristid> > zipWith const [1,2,3,4,5] [1,2,3]
06:10:44 <lambdabot>   [1,2,3]
06:10:50 <dv-> I always thought probably was more like 75-90%
06:10:54 <aristid> > zipWith const [1,2,3,4,5] [0,0,0]
06:10:55 <lambdabot>   [1,2,3]
06:11:03 <Jafet> That would be "always"
06:11:38 <dv-> Always is 100%
06:11:56 <soupdragon> almost always is 100%
06:11:58 <ddarius> RyanT5000: It doesn't make a whole lot of sense to say "inaccurately predict" probabilities modulo straight-up errors.
06:12:04 <Jafet> Hmm, take n xs = zipWith const xs [1..n]
06:12:22 <dv-> 35-65% is a maybe
06:12:25 <wli> I'm pretty sure it was pulled out of someone's arse and if they didn't do so themselves they're repeating someone else's having done so.
06:12:26 <soupdragon> if you have a continuous domain you can have 100% probability yet the event doesn't occur
06:12:27 <ddarius> Nor, in most cases, could a probability be "experimentally verified."
06:12:32 <soupdragon> same with 0% and it happens anyuwau
06:12:58 <soupdragon> basically all the sorts of reasons mathematically inclined folks find probability so obtuse
06:12:59 <RyanT5000> ddarius: well, if you accurately predict the probabilities and then run a million tests, you're more likely to be close than if you inaccurately predicted them
06:13:09 <RyanT5000> though i'm aware that it's not a very *precise* term i'm using
06:13:19 <RyanT5000> i don't think it's totally meaningless or nonsensical
06:13:31 <wli> soupdragon: Sets of measure 0 with continuous distributions.
06:15:45 <dv-> I thought we were talking about coin flips
06:15:47 <ddarius> RyanT5000: You can accurately calculate the probability of some event happening given your knowledge and have it not match the frequency which suggests a lack in your knowledge not an error in your calculations.  However, in most cases you can't run a predicted thing "a million times."
06:17:26 <Jafet> Or perhaps that your runs are flawed.
06:17:43 <RyanT5000> ddarius: yeah, that makes sense
06:18:09 <RyanT5000> i just don't think probability is very meaningful in the context of a one-off problem-solving exercise like the bp oil spill
06:18:20 <ddarius> RyanT5000: Sure it is.
06:18:29 <Jafet> It isn't meaningful to measure it.
06:18:43 <Jafet> But that holds for most everyday probabilities.
06:18:58 <ddarius> There's nothing to measure.
06:19:20 * geheimdienst would like to point out that you couldn't test it. no one is gonna make some more oil spills to test some theory
06:19:44 <Jafet> (Did you know that RANDU is so flawed, they simulated one million coin flips and it never landed on its edge?)
06:19:46 <zygoloid> consider a banach-tarski decomposition of the sphere. pick one of the pieces. what's the probability that an arbitrarily-chosen point on the sphere is on that piece? ;-)
06:19:53 <RyanT5000> well, for it to be meaningful, we need either a rigorous way of *producing* the estimate or a rigorous way of *testing* it, right?
06:19:55 * geheimdienst thinks something untestable it's pretty close to what pauli called "not even wrong"
06:20:01 <IceKiller> i know this is the wrong channel but has anyone here by any chance have any coding experience on the iphone? (objective c)
06:20:16 <Jafet> Wrong channel, right time...
06:20:38 <ivanm> Jafet: why right time?
06:20:41 <ddarius> RyanT5000: There is a rigourous way of calculating probabilities.  There isn't a rigorous way of "testing" them in most cases because what would that be measuring?
06:21:03 <ddarius> RyanT5000: You don't calculate 2+2=4 a million times to prove to yourself that it holds.
06:21:05 <RyanT5000> so what makes you think bp has a rigorous way of producing this probability?
06:21:10 <IceKiller> the accuracy of the test?
06:21:18 <Jafet> ivanm, because there is a dedicated phone dev here
06:21:29 <ivanm> ahhhhh
06:21:40 <ddarius> RyanT5000: I doubt they do.  The numbers probably are BS, but that doesn't mean some accurate probabilities couldn't be given or that probability is meaningless.
06:21:51 <IceKiller> we know from experience that coins can land on their sides, the question then becomes what % chance is there and how to include this as an actual chance in our equation
06:22:06 <ivanm> IceKiller: usually it gets ignored
06:22:07 <RyanT5000> sure; i have no doubt that an omnipotent being could produce a meaningful probability here :)
06:22:10 <geheimdienst> ddarius, yes, the way of calculating probabilities (or 2+2) sure is rigorous. the problem is: what's your input to the rigorous algorithm? if that's pulled out of peoples's asses, all the rigor in the process won't help you
06:22:11 <ivanm> as it's statistically unlikely
06:22:12 <RyanT5000> omniscient, i should say
06:22:21 <IceKiller> Jafet so your an iphone dev?
06:22:32 <RyanT5000> IceKiller: i am :)
06:22:34 <Jafet> Never. There lies pain.
06:22:47 <IceKiller> RyanT5000 mind if i pm you quick? ^^
06:22:52 <RyanT5000> well, my company is; i don't do terribly much coding myself
06:22:55 <RyanT5000> but go ahead :)
06:22:59 <ddarius> RyanT5000: Omniscience isn't necessary.  I could give a probability distribution for what I think the chance are of some approach working or not, it would just be very flat.
06:23:17 <ddarius> RyanT5000: If you were omniscient you wouldn't be giving probabilities.
06:23:59 <Jafet> It depends on the dimensions in which you are omniscient
06:24:03 <RyanT5000> yup
06:24:34 <Jafet> The concept of probability is also another mathematical abstraction that we pretend has relevance to real life
06:24:47 <RyanT5000> and it often does have relevance
06:24:48 * geheimdienst is omniscient in 2 of the most popular dimensions
06:25:39 <ddarius> Jafet: It doesn't have relevance to real life, it has relevance to us (and from there to reality if you like).  Probability theory is an extension of logic.
06:25:56 <Jafet> Extension in what sense, ddarius?
06:26:22 <ddarius> Jafet: In that the rules of probability theory reduce to exactly boolean logic in the certainly true/certainly false cases.
06:27:34 <aristid> RyanT5000: only one programmer according to http://ipwnstudios.com/bloodknight/node/20 ?
06:28:43 <ddarius> geheimdienst: There are ways of expressing "complete ignorance except for some facts" and in many cases the exact details don't have a huge effect on the distribution.  However, it certainly can be the case that you assume something that is false, and indeed in cases where probabilities can be related to frequencies such assumptions can be revealed.
06:29:39 <ddarius> geheimdienst: Perhaps more commonly people fail to include relevant information without realizing it, but in those cases you usually get broad distributions which suggests poor predictions.
06:33:24 <geheimdienst> i think i agree with you, ddarius
06:34:19 * geheimdienst thinks that, probabilitiy theory or no, a number is only as trustworthy as the guy who came up with it
06:34:31 <soupdragon> hehe
06:36:52 <rajeshsr> :t ap
06:36:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:40:00 <phindmarsh> Cale, scree and others, thanks for you assistance earlier, much appreciated.
06:47:29 <rajeshsr> Cale, Data.Array doesn't seem to make my solver any faster than 1s for really bad cases and just 0.1s for ordinary cases. I used Data.Map initially.
06:47:48 <ivanm> use Vector!
06:48:17 <rajeshsr> ivanm, hmm, lemme check out! thanks
06:48:39 * ivanm has no idea if its even relevant to applicable to what rajeshsr wants, but anyway...
06:48:54 <Cale> rajeshsr: Before that, try using UArray instead
06:49:02 <Cale> rajeshsr: It has the exact same interface as Array
06:49:14 <rajeshsr> Cale, oh, ok! thanks.
06:49:20 <Cale> rajeshsr: And so you can plug it in just by importing Data.Array.Unboxed and switching the types a bit
06:49:24 <rajeshsr> ivanm, was trying to write a sudoku solver..
06:49:40 <ivanm> rajeshsr: as opposed to all the other sudoku solvers on the wiki?
06:49:54 <EvanR-work> its like legos
06:50:02 <rajeshsr> ivanm, well, yeah. It is my own! :)
06:50:25 <rajeshsr> of course the fundamental idea is a Constraint Propagation. Using 2 heuristics to make it
06:50:40 * wli did a sudoku solver and was not enlightened.
06:51:00 <Jafet> Is DLX still neat in Haskell?
06:51:05 * ivanm turned a sudoku solver into a partial latin square generator...
06:51:20 <ivanm> since this was Bird's sudoku solver, I'm sure you can imagine how inefficient it was :s
06:51:38 <ivanm> however, I was teaching myself Haskell at the time I was hacking on that, so *shrug*
06:51:41 <rajeshsr> wli, well, the point of this exercise is to get familiar with Haskell, than solving sudoku which i have done a lot as a part of programming contests in languages like C/C++
06:52:31 <wli> Sounds like almost everyone has a much better idea of how sudoku solvers are supposed to work than I do.
06:53:23 <rajeshsr> wli, well, just take the 2nd case given in haskell wiki. If your sudoku solver solves it, then you have some good solver, or else it may be plain backtracking and may require more heuristics
06:54:09 <shapr> jmcarthur: tags, of course! Wow, I feel silly.
06:55:34 <Cale> ivanm: I would tend to imagine that it was surprisingly efficient despite not using anything low-level, if it was written by Bird.
06:56:16 <ivanm> Cale: it used [[Int]]
06:56:27 <ivanm> and was designed as a tutorial, not to be efficient ;-)
06:57:05 <rajeshsr> ivanm, if Latin square is given as a question, it should have unique solution, right?
06:57:17 <ivanm> rajeshsr: hmmm?
06:57:30 <ivanm> your question didn't come out too well ;-)
06:57:47 <rajeshsr> i mean a partial latin square given to solve, should have a unique solution, right?
06:57:56 <ivanm> sudoku puzzles are easier to solve than general latin squares: more constraints == less possibilities
06:58:00 <ivanm> rajeshsr: not at all
06:58:12 <ivanm> rajeshsr: the empty square is a partial latin square ;-)
06:58:23 <rajeshsr> ivanm, ha!!
06:58:31 <ivanm> you're thinking of uniquely completeable partial latin squares ;-)
06:58:57 * zygoloid has used the 'uniquely solvable' property to solve sudokus :)
06:59:40 <rajeshsr> yep! thats is the question bothering me in making a program for making sudoku questions too!
06:59:51 <shepheb> there are some published sudokus that aren't unique. usually you end up with four corners of a rectangle that are all either one number of another, and no way to determine which is which.
07:00:12 * Cale still wonders about whether there's a way to systematically construct asymptotically equivalent lazy pure-functional programs from strict imperative ones.
07:00:22 <zygoloid> shepheb: there are some published sudokus with no solution. both kinds are broken imo
07:00:38 <Cale> If anyone can come up with a way to do that, I would bet on Bird :)
07:00:46 <shepheb> zygoloid: broken by definition: logic puzzles supposedly with a unique, no-guessing-required solution
07:00:53 <rajeshsr> who is Bird?
07:01:00 <zygoloid> my local rag had a sudoku in the back with two 8s in a column a month or so ago!
07:01:08 <pastorn> rajeshsr: this is quite good if you want to get oriented in haskell: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/lab3.html
07:01:09 <Cale> rajeshsr: A functional programming researcher
07:01:17 <eikke> stupid question: what's the syntax for a long (multi-line) nested list? :s
07:01:25 <ivanm> zygoloid: :o
07:01:27 <Cale> http://en.wikipedia.org/wiki/Richard_Bird_%28computer_scientist%29
07:01:38 <quicksilver> eikke: no particular sytnax required
07:01:41 <ivanm> eikke: just split it up
07:01:45 <quicksilver> eikke: it's always OK to break lines inside haskell expressions
07:01:58 <ivanm> [[1,2] <newline> , [3,4]]
07:02:02 <quicksilver> just make sure you indent the subsequent line enough to clear any enclosing layout blocks
07:02:07 <eikke> ok
07:02:19 <quicksilver> definitely at least one space since your entire file is (almost certainly) a layout block
07:02:22 <pastorn> eikke: the only thing that's special is that you can do "hutahutehaot \<newline>\huteahu"
07:02:23 <rajeshsr> pastorn, thanks!
07:02:39 <Cale> rajeshsr: He's written a lot of stuff which involves taking naive functional programs and using equational reasoning alone, transforming them step-by-step into efficient functional programs.
07:02:45 <pastorn> i don't remember if that will give you a newline char or if that just concatenates them
07:02:58 <ivanm> pastorn: just concatenates
07:03:02 <ivanm> you need an explicit newline
07:03:13 <rajeshsr> Cale, wow! thats interesting. Something like compiler optimization for Functional Programming..
07:03:23 <ivanm> and you _don't_ want to do it after the newline (since it will try to interpret it as \\ n)
07:03:46 <Cale> rajeshsr: Well, yeah, this is often the sort of thing which involves a *bit* more creativity than one would expect from a compiler, but it's in that direction.
07:04:26 <rajeshsr> Cale, hmm, yeah!
07:04:39 <Cale> It's doing optimisations by hand, but in a thoroughly reasoned fashion.
07:05:39 <rajeshsr> hmm, By functional you mean Pure, right? Lazy doesn't get involved?
07:05:56 <ivanm> Cale: oh, did you see the thing on stackoverflow about people bitching that FP langs can't do quicksort well?
07:05:59 <rajeshsr> i mean the works or Bird..
07:06:16 <pastorn> ivanm: giv'em ST
07:06:39 <ivanm> pastorn: yeah, Paczesiowa pointed that out on the ensuing proggit discussion
07:07:00 <rajeshsr> ivanm, "well" means not asymptotically O(nlgn) or what?
07:07:06 <Cale> rajeshsr: It's known that there are problems for which the asymptotically optimal strict-functional program is asymptotically slower than the best imperative solution.
07:07:20 <Cale> rajeshsr: But this *isn't* known for lazy-functional programs.
07:07:21 <ivanm> rajeshsr: partially the whole "it's not in-place" stuff
07:07:43 <rajeshsr> Cale, yeah, you told me about that sometimes before..
07:08:08 <Cale> And in fact, it might be that every imperative program has its lazy functional asymptotic equivalent, but so far, the examples where we know of one are rather tricky and clever.
07:09:22 <rajeshsr> ivanm, that seems a good question. So how do you do it inplace? Does "inplace" make sense in FP world?
07:09:27 <Cale> The only systematic way I know of for constructing a pure lazy functional algorithm from an imperative one which does mutation of arbitrary-sized pieces of memory will introduce an additional log factor in reading and writing that memory.
07:09:43 <ivanm> rajeshsr: not with lists it doesn't
07:09:44 <Cale> I don't give a damn about in-place here ;)
07:09:51 <ivanm> and they were talking about list sorts
07:09:54 <Cale> Just that the time usage is the same
07:09:56 <ivanm> Cale: heh
07:10:15 <Cale> In-place doesn't really mean much.
07:10:21 <ivanm> don't forget, head . sort is a valid implementation of minimum for Haskell!
07:10:24 <Cale> (in a pure setting)
07:10:29 <ivanm> Cale: not for lists, no
07:10:36 <Jafet> At least you know you have a sympathetic brother in multitape Turing machines
07:10:39 <ivanm> for an ST wrapper around an array it would though, wouldn't it?
07:10:59 <rajeshsr> Cale, what mutation you mean? can you make it more clear?
07:11:51 <Cale> rajeshsr: Okay, so suppose we have an imperative program with an arbitrary-sized heap
07:12:07 <Cale> rajeshsr: that it can address and mutate in "O(1)"
07:12:35 <Cale> Even though that's physically unrealistic, we'll ignore the additional time costs as you increase the amount of available memory.
07:13:05 <Cale> We can write an equivalent functional program which simply uses a Data.Map to simulate that heap of memory
07:13:15 <Cale> But now accesses are O(log n)
07:13:42 <Cale> That is, on top of the log factor we're already ignoring.
07:14:32 <wli> I think most of the costs in terms of memory are in terms of the address space (usually much larger than memory) and circuit depth.
07:14:35 <Cale> This is usually acceptable, and we often just go ahead and ignore the additional log factor.
07:15:01 <Cale> But in some cases, we can do better.
07:15:31 <rajeshsr> Cale, hmm, i don't see how Map makes it Pure and Lazy. Still accessing global variables breaks referential transparency..
07:15:45 <Cale> For some programs which use mutation of a heap like that, and in more cases than strict-functional, we can write pure *lazy* functional equivalents.
07:15:54 <pastorn> rajeshsr: Map doesn't use globals
07:16:26 <Cale> rajeshsr: You just pass the immutable Map around, and construct a new modified Map whenever memory is written, and do lookups whenever memory is read.
07:16:47 <Cale> Think about using the  State (Map Address Value)  monad.
07:16:53 <Cale> (which is really pure)
07:17:04 * geheimdienst 's 2 cents are to first do the Simplest Thing that Could Possibly Work, then profile and get clever as needed. the whole big-o business is only relevant up to a point
07:17:10 <illissius> does ord/toEnum on a Char correspond to the unicode code point for it?
07:17:17 <matt_m> Cale:  What's the lazy functional language you have in mind for this?  It has constant seek arrays I guess?
07:17:18 <Cale> geheimdienst: Well, sure, but we have our theorist hats on.
07:17:19 <rajeshsr> ha, so you associate a Map with every function in it argument?
07:17:30 <matt_m> Cale: (Constant time look-up)
07:17:35 <Cale> matt_m: Sure.
07:17:39 <geheimdienst> cale, lol ;-)
07:17:54 <Cale> matt_m: But they're immutable ones.
07:18:11 <Jafet> What if you use DiffArray?
07:18:16 <Cale> matt_m: So the only fast "updates" you're going to get out of them is the monotone evaluation of expressions in them into values.
07:18:19 <Jafet> (Disclaimer: I know next to nothing about DiffArray)
07:18:27 <Cale> Jafet: That would be enough.
07:18:43 <Cale> DiffArray is cheating, obviously ;)
07:18:51 <byorgey> illissius: yes, I think so
07:18:58 <pastorn> Cale: obviously
07:19:16 <Jafet> Well, not if you demand access to old states.
07:19:23 <Cale> But you never will in this case.
07:19:36 <matt_m> Cale:  How do you detect collisions in an arbitrary list of integers in linear time with this functional language?
07:19:40 <Cale> Because your translation of the imperative program will always refer to the latest version of the heap
07:19:49 <Jafet> Then we're dealing with a restricted version of the problem here, it seems
07:20:14 <geheimdienst> since you're wearing hats, could you guys come up with kinduva big-o analysis that does not treat every memory access as costing the same? cause in reality, some memory is fast and others is orders of magnitude slower because of caching in the cpu and so on
07:20:19 <geheimdienst> that would be handy imho
07:20:23 <geheimdienst> kthxbye
07:20:38 <matt_m> Cale:  ie, you have N << M, and you're given a list of N integers less than M, and the problem is to find collisions in O(N)
07:20:47 <gwern> geheimdienst: orders of magnitude are just big constant factors
07:20:51 <gwern> what's the issue?
07:20:55 <pastorn> geheimdienst: thinking about caches when haskelling is usually not so great
07:21:02 <pastorn> unless you're using unboxed arrays
07:21:07 <Jafet> geheim, the whole point of models is to avoid thinking about things like that
07:21:25 <matt_m> Cale:  In an imperative language you use buckets.  How do you do that in a lazy functional language?
07:21:30 <Cale> matt_m: Well, if you're just interested in what sort of language it is, think of the pure segment of Haskell, with lazy Array
07:22:01 <illissius> byorgey: yes, seems so. I was just having trouble getting haskell's Char and Qt's QChar to give me the same number for the same character, but I think I've got it now
07:22:41 <wli> matt_m: Calculate array indices, use arrays.
07:23:06 <matt_m> wli: How do you get the elements into the array in O(N) time?
07:23:27 <mm_freak> randomNumber :: Integer
07:23:29 <Cale> matt_m: accumArray
07:25:11 <Cale> Though, I suppose you have the problem that after building the array with accumArray, you still have to walk through it. Not asymptotically a problem though
07:25:48 <Cale> That's a subtle point though...
07:25:57 <Jafet> @quote randomRIO
07:25:57 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
07:26:04 <Cale> I wonder if accumArray can be written in terms of array
07:26:23 <Cale> (while maintaining the O(n) complexity)
07:26:44 <matt_m> Cale:  You need to be able to fill in only the O(N) elements you're writing to, and leave the others uninitialized
07:27:01 <Cale> matt_m: Why is that?
07:27:12 <Cale> Oh, I see.
07:27:30 <Cale> You're worried about the time to allocate the array?
07:27:35 <matt_m> Cale:  Yes
07:27:50 <Cale> Uh, don't you have to pay for that in the imperative setting anyway?
07:28:23 <matt_m> Cale:  No
07:29:03 <pozic> matt_m: there are ways to get uninitialized memory in Haskell.
07:29:03 <Cale> Sure you do. Unless you have a way to allocate a mutable array of arbitrary size which has been zeroed out already in constant time.
07:29:24 <Cale> Leaving things uninitialised would be dangerous and ineffective.
07:29:27 <EvanR-work> the BSS segment
07:29:41 <matt_m> Cale: No, this is the classic example of where uninitialized memory is important for performance
07:29:47 <pozic> Cale: it can also help the theoretical complexity.
07:29:59 <Cale> matt_m: Perhaps I'm not thinking of the same algorithm you are.
07:30:02 <pozic> matt_m: anyway, you can do so.
07:30:09 <matt_m> Cale:  Basically if integer n occurs at index i in the input, you write index i to bucket n.  The second pass only checks the buckets in the second list
07:30:13 <matt_m> pozic:  ok
07:30:19 <Cale> matt_m: I don't see how you could possibly tell between an uninitialised cell and one that you'd already written.
07:30:26 <pozic> I don't know a way to do it in Java, though.
07:30:27 <matt_m> Cale:  You don't have to
07:30:30 <pozic> I don't think you can.
07:30:51 <matt_m> Cale:  The invariant is that at the end of the first pass, the index points back to the correct place in the first input list, or is garbage
07:30:52 <Cale> Oh, I see.
07:30:57 <matt_m> Cale: But that's enough to get the O(N) bound
07:31:20 <pozic> matt_m: what is the application of it?
07:31:33 <pozic> matt_m: I know one, but it is a rather obscure application.
07:31:46 <matt_m> pozic:  I don't know - I've never used it :)
07:31:47 <pozic> It would be nice to have "real-world" examples for these things.
07:32:02 <Starfire> Is there something wrong with this type declaration? (#) :: Int -> Int -> Int
07:32:06 <Cale> matt_m: Okay, that's more than I'd normally expect of an imperative program though.
07:32:16 <Starfire> ghci gives me a parse error when trying to load it.
07:33:18 <Cale> Starfire: hmm, nothing I can see.
07:33:19 <Starfire> If I remove the type declaration, it works.
07:33:37 <Cale> Starfire: What parse error?
07:33:47 <Starfire> Types.hs:42:2: parse error on input `#)'
07:33:58 <Cale> Starfire: hmm...
07:34:02 <Starfire> Uhh, actually just `)'
07:34:13 <Starfire> That's from an attempt with ( #) instead of (#)
07:34:25 <Cale> Maybe # is special with some of the extensions turned on...
07:34:48 <Cale> What happens if you write ( # )?
07:35:09 <Starfire> That seems to work, thanks!
07:35:45 <Cale> Starfire: I think it's an unfortunate collision with the syntax of unboxed tuples.
07:36:54 <Cale> matt_m: We could alternately require that the result of accumArray is indeterminate for any index in the array which doesn't occur in the list, but that's ugly :)
07:37:17 <Cale> matt_m: I don't really want to work in a language where it's possible to forget to initialise the elements of an array.
07:37:27 <Cale> (imperative or pure)
07:37:59 <gwern> don't you need the MagicHash extension to use # in source?
07:38:19 <Cale> UnboxedTuple
07:38:20 <Cale> s
07:38:44 * hackagebot Chart 0.13.1 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-0.13.1 (TimDocker)
07:39:02 <Cale> MagicHash is for names of non-infix functions that end in #
07:39:13 <Cale> Perhaps that could cause the problem as well
07:40:29 <kuribas> I am writing html combinators for HXT.  Can anyone give me some comments?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25718#a25718
07:43:27 <Cale> kuribas: I wonder if it wouldn't be simpler just to write a function which took, say, the datatype from Text.XHtml and translated it into an XmlTree
07:44:22 <Cale> hmm, maybe it's not easy to do that
07:44:48 <kuribas> Cale: you can always use xread, but it is more verbose.
07:44:59 <kuribas> And I think it is not so flexible...
07:45:31 <Jafet> Hm, xhtml is not html
07:46:26 <Cale> kuribas: Yeah, that's obviously not so nice if you have to parse it back from a string
07:46:49 <Cale> kuribas: I was thinking that the XHtml library would have some explicit tree type, but it seems that they've made it opaque.
07:47:33 <Cale> Oh, but good old  Text.Html  has an explicit tree.
07:48:04 <kuribas> But you would have to add a conversion function every time...
07:48:07 <Cale> yes
07:48:51 <Cale> I guess it depends on what you want to do
07:49:20 <kuribas> I wanted to read an xml file as a template, and fill in the gaps for my cgi script.
07:50:26 <kuribas> So I can replace a tag with a certain ID with the dynamically generated content.
07:51:37 <Cale> Okay
07:51:56 <Cale> So the HTML combinators are for constructing the bits which will be filled in, then?
07:52:01 <kuribas> yes
07:52:35 <Cale> So it wouldn't be *too* painful to do it the way I suggested, and it might save you a lot of work defining all the various HTML tags.
07:53:13 <Cale> But otherwise, that code looks fine to me :)
07:53:42 <Cale> On the other hand, I should mention that I'd usually skip the XML template altogether if possible.
07:54:04 <Cale> Just write a function which takes the missing chunks as parameters :P
07:55:11 <kuribas> Cale: What I like about an external html file, is that is easy to design a nice page.  If I hardcode it then it is harder to change bits, and see the result.
07:55:17 <jkingkong> Hey #haskell, I'm doing something really silly I'm sure but not sure what it is
07:55:22 <Cale> Even if you need to be able to load the template dynamically, I'd almost consider it worthwhile to use hint for that, if only to avoid having any more XML code than necessary.
07:55:32 <jkingkong> I want to declare a "Manifest" array in the Repa package
07:55:54 <Cale> kuribas: But perhaps you shouldn't listen to me on that point. I'm one of those people who despises XML. :)
07:56:02 <jkingkong> the type declaration of Manifest is sh -> Data.Array.Parallel.Array a -> Data.Array.Repa.Array sh a
07:56:30 <jkingkong> sorry should be sh-> Data.Array.Parallel.Unlifted.Array a -> Data.Array.Repa.Array sh a
07:56:54 <jkingkong> inside Data.Array.Parallel.Unlifted we have the type synonym Array a = [a]
07:56:55 <kuribas> Cale: me too actually, but in this case the xml file is just the webpage.
07:57:18 <jkingkong> so why doesn't something like Manifest (Z:3) [1,2,3] work?
07:57:24 <kuribas> Well, it's html, but close enough.
07:58:04 <jkingkong> I get "Couldn't match expected type `Data.Array.Parallel.Unlifted.Array a` against inferred type `[a1]`"
07:58:30 <Cale> What package is Data.Array.Parallel.Unlifted from? dph?
07:58:37 <jkingkong> yes
07:59:02 <jkingkong> it doesn't help to enfore the type with [1,2,3] :: Data.Array.Parallel.Unlifted.Array Int or something
07:59:09 <jkingkong> \enfore/enforce
08:00:20 <Kaidelong> Hmm, I don't want to use the default show instance for a type defined with data. Do I just define my own?
08:00:30 <Kaidelong> something like
08:00:40 <Kaidelong> show Blank  = ""
08:01:03 <Kaidelong> show Full t = s t where s = show :: String -> t
08:01:06 <jkingkong> instance Show ("insert type") where show ....
08:01:22 <JaffaCake> meeting in #ghc, if anyone's interested
08:01:25 <Cale> jkingkong: I don't understand how you could expect that code to work.
08:01:31 <Cale> jkingkong: [1,2,3] is obviously a list
08:01:43 <Cale> and I have no idea what's going on with (Z:3)
08:01:53 <Cale> You're treating 3 as a list?
08:02:20 <jkingkong> (Z:3) is the "shape" of the array
08:02:21 <Kaidelong> instance (Show t) => Show (Blankable t) where -- this would be my instance declaration?
08:02:41 <Cale> jkingkong: Syntactically, there's no way that could be right.
08:02:48 <jkingkong> cale: isn't the Array declaration in Data.Array.Parallel.Unlifted just a type synonym for a list?
08:02:50 <Cale> jkingkong: (:) is list cons
08:03:04 <jkingkong> Array a = [a]
08:03:06 <Cale> and it's impossible to overload it
08:03:10 <Cale> jkingkong: What???
08:03:17 <Cale> oh
08:03:18 <jkingkong> sorry type Array a = [a]
08:03:25 <Cale> Okay...
08:03:27 <byorgey> Kaidelong: you only need the (Show t) constraint if you actually call show on some values of type t
08:03:34 <jkingkong> is what's in Data.Array.Parallel.Unlifted
08:03:39 <byorgey> Kaidelong: but that looks good
08:03:49 <Kaidelong> byorgey: which I do. But that will work with standard haskel then? thanks
08:03:59 <Cale> jkingkong: Okay, I didn't realise that.
08:04:00 <jkingkong> kaidelong: yes
08:04:01 * geheimdienst points out that ??? is formally known as the wtf combinator
08:04:05 <jkingkong> cale: that's fine :)
08:04:09 <byorgey> Kaidelong: oh, I see.  yes, that will work.
08:04:25 <byorgey> Kaidelong: and by the way,  show (Full t) = show t  should work just fine.
08:04:37 <byorgey> I don't think you need all that  where s = show :: String -> t  business
08:04:42 <Cale> jkingkong: That just seems... wrong
08:04:42 <jkingkong> cale: I can follow the paper fine but when it comes to doing some simple examples I get completely bogged down. I wish the documentation had some better examples that aren't so grandiose
08:04:52 <Cale> jkingkong: It doesn't make sense that the Array representation would just be a list
08:05:15 <jkingkong> cale: yea I'm a complete beginner at this myself
08:06:02 * hackagebot LambdaCalculator 0.0.2 - A basic lambda calculator with beta reduction and a REPL  http://hackage.haskell.org/package/LambdaCalculator-0.0.2 (ThomasDuBuisson)
08:06:05 <jkingkong> http://hackage.haskell.org/packages/archive/repa/1.0.0.0/doc/html/Data-Array-Repa.html
08:06:09 <jkingkong> that's the source
08:06:32 <jkingkong> and I'm trying to make an instance of the algebraic data type "Array sh a" using the "Manifest" constructor
08:07:49 <RyanT5000> aristid: no, we have two programmers and I also program sometimes; the website is a bit out of date
08:08:21 <Cale> jkingkong: I wonder if you're actually meant to write values in that way.
08:09:08 <Cale> It's so confusing that they named the type constructor "Array" when there's already a type constructor named Array that they've imported and use in their signatures.
08:09:09 <jkingkong> cale: as opposed to what then?
08:09:17 <Cale> jkingkong: Maybe fromUArray?
08:09:20 <aristid> i would love to see evidence (numbers) how much money can be saved by using good programming languages
08:09:25 <jkingkong> cale: yea it's miserable, maybe that's it
08:09:34 <Cale> fromUArray sh uarr
08:09:34 <Cale> 	= sh   `S.deepSeq`
08:09:34 <Cale> 	  uarr `seq`
08:09:34 <Cale> 	  Manifest sh uarr
08:09:39 <RyanT5000> aristid: i've thought about that stuff a lot
08:09:41 <RyanT5000> it's difficult to measure
08:09:59 <Cale> hmmm
08:10:10 <applicative> jkingkong, I'm probably not following, but shouldn't you use UArrays  fromList
08:10:19 <jkingkong> oh yes I did just see that applicative
08:10:26 <RyanT5000> but i suspect that if you take a very holistic view of "language", to include the standard libraries, IDE, source management, build system, etc.
08:10:30 <Cale> Maybe it's important, even though the documentation for that module *says*  type Array a = [a], to really use the type defined in that module
08:10:34 <Kaidelong> "read is not a visible method of class Read"
08:10:47 <RyanT5000> there's at least a 10x improvement to be had without anything especially revolutionary
08:10:54 <Kaidelong> I take it this means
08:11:00 <Cale> I don't think it could really be lists. Maybe that's just some artifact of making Haddock work or something.
08:11:05 <Kaidelong> now that I've defined show, it should define read implicitly somehow
08:11:06 <aristid> RyanT5000: under which conditions?
08:11:09 <Kaidelong> how do I get that to happen?
08:11:31 <RyanT5000> aristid: well, this is just based on my personal observations of how i waste time when writing code
08:11:43 <quicksilver> Kaidelong: nope
08:11:46 <RyanT5000> for example, refactoring is horrible in most languages
08:11:47 <quicksilver> Kaidelong: it just means what it says.
08:11:55 <quicksilver> Kaidelong: 'read' is not a method.
08:12:02 <PeakerWork> I am trying to use an (ST s) computation in my internal representation of some abstract type... Is this possible without leaking the "s" type parameter outwards, in Haskell98?
08:12:06 <jkingkong> that did it
08:12:08 <Kaidelong> so then how do I make the read instance I need?
08:12:09 <Cale> sum_r _ segSize xs = P.error "FIXME GABI PLEASE PLEASE PLEASE"
08:12:12 <Cale> ^^ lol
08:12:13 <quicksilver> (the methods are readsPrec and readList)
08:12:13 <PeakerWork> The user of my abstract type isn't supposed to know about the use of ST
08:12:14 <jkingkong> thanks cale, applicative
08:12:17 <RyanT5000> the refactoring tools that exist are almost universally terrible
08:12:20 <Kaidelong> oh
08:12:23 <Kaidelong> I don't need to?
08:12:27 <jkingkong> i was thinking there was some magic used to turn the list into an array
08:12:29 <RyanT5000> so something that takes 3 seconds to think up
08:12:29 <aristid> RyanT5000: haskell has refactoring tools?
08:12:36 <quicksilver> Kaidelong: I would advise against writing your own Show or Read instance
08:12:37 <RyanT5000> no, i'm talking about all languages right now
08:12:45 <quicksilver> just use the default "deriving (Read,Show)"
08:12:51 <jkingkong> there's this "Elt" wrapping class for the elements of the array i guess
08:12:57 <RyanT5000> i'm not aware of any language that has refactoring tools that i'd call "good"
08:13:06 <RyanT5000> except i guess lisp if you count the whole language as a refactoring tool :P
08:13:06 * hackagebot hfiar 2.0.4 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-2.0.4 (FernandoBenavides)
08:13:14 <Kaidelong> quicksilver: that has a problem with writing "Blank" when I need it to write "" for the sake of the CSV format
08:13:20 <RyanT5000> anyway, most languages have a ton of room to grow in refactoring
08:13:24 <quicksilver> Kaidelong: then then isn't a Show instance IMO.
08:13:29 <quicksilver> Kaidelong: that's a csv export function.
08:13:30 <RyanT5000> and also, refactoring has a much larger hidden cost
08:13:39 <RyanT5000> which is that the upfront cost of refactoring causes you not to do it
08:13:44 <quicksilver> Kaidelong: Show instances produce valid haskell syntax, that's what they're fore.
08:13:44 <RyanT5000> which means you pay ongoing costs in lack of clarity
08:13:49 <quicksilver> CSV export/import is something else.
08:13:57 <Kaidelong> ok
08:14:00 <RyanT5000> which i'm certain add up to way more than the upfront cost would have been, in a lot of  case
08:14:21 <RyanT5000> and there's a lot of stuff like that in programming
08:14:26 <quicksilver> RyanT5000: well the refactoring stuff in eclipse is quite neat, as far as it goes
08:14:31 <quicksilver> RyanT5000: ... of course it only goes so far.
08:14:36 <RyanT5000> yeah
08:14:42 <RyanT5000> well we need refactoring tools that work on the AST
08:14:48 <quicksilver> RyanT5000: I presume VS is similar, but I'm allergic to VS.
08:15:01 <RyanT5000> VS is, IMO, microsoft's best product
08:15:01 <quicksilver> RyanT5000: there are plenty of projects which work that way.
08:15:05 <RyanT5000> (at least of the ones i've used)
08:15:07 <quicksilver> scion is the most promising atm I think.
08:15:42 <RyanT5000> well, i think most of them probably do a parse -> change ast -> prettyprint
08:15:44 <RyanT5000> which is not quite good enough
08:15:50 <RyanT5000> unless your AST includes comments and whitespace
08:16:05 <RyanT5000> and any other stuff like that
08:16:08 <quicksilver> RyanT5000: there is a roundtripping parser involved, yes
08:16:12 <quicksilver> RyanT5000: but it works
08:16:17 <RyanT5000> sure
08:16:19 <RyanT5000> it's just that
08:16:25 <RyanT5000> the refactoring tool has to be easily extensible
08:16:28 <quicksilver> haskell-src-exts contains a roundtrip parser which preserves whitespace.
08:16:31 <RyanT5000> in the same way that lisp macros are
08:16:41 <RyanT5000> yeah, haskell-src-exts
08:16:43 <RyanT5000> is very nice
08:16:50 <RyanT5000> i'm not trying to disparage everything, here
08:16:58 <quicksilver> scion uses haskell-src-exts' roundtrip, if I'm not mistaken.
08:16:59 <RyanT5000> in fact, what i meant by "nothing especially revolutionary" above
08:17:08 <quicksilver> "easily" extensible is a tough target
08:17:09 <RyanT5000> is that you probably can find all the features in *some* language
08:17:12 <quicksilver> the haskell AST isn't simple
08:17:20 <RyanT5000> the problem is that there's no language with *all* of them
08:17:25 <quicksilver> you can't write refactorings without understanding it
08:17:28 <RyanT5000> that's when you see the 10x improvement
08:17:33 <RyanT5000> sure
08:17:34 <Kaidelong> quicksilver: like this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25720#a25720
08:18:00 <kuribas> Where do I put a module (like Text.XML.HXT.Arrow.XHtml) when working on it?
08:18:05 <quicksilver> Kaidelong: that looks good to me.
08:18:17 <quicksilver> Kaidelong: does it do what you want? :)
08:18:25 <Kaidelong> quicksilver: I don't know yet
08:18:41 <applicative> kuribas, what do you mean, 'when working on it.'  Are you changing it, or importing it?
08:19:01 <quicksilver> Text/SML/HXT/Arrow/XHtml.hs
08:19:13 <kuribas> I am creating it :)  When I load a test file in ghci, I get:   Could not find module `Text.XML.HXT.Arrow.XHtml':
08:19:46 <kuribas> Doesn't ghci look in the current directory?
08:20:28 <kuribas> quicksilver: I tried that, but ghci complains.
08:22:07 <Kaide> quicksilver: if I try something like " importCSV "5" :: String -> Blankable Int " in the interpreter I get an error
08:22:08 <applicative> You have a subdirectory Text and so on.
08:22:08 <Kaide> oh
08:22:10 <Kaide> duh, nm
08:22:40 <kuribas> applicative: It works for ghc now, but not for ghci...
08:22:53 <kuribas> I like to work interactively in emacs.
08:23:32 <ManateeLazyCat> RyanT5000: Still there?
08:23:32 <applicative> the name of the module is "module Text.XML.HXT.Arrow.XHtml where..."
08:23:49 <RyanT5000> ManateeLazyCat: yep; it's 11:23 AM and i'm starting to think about going to sleep :P
08:23:50 <kuribas> applicative: yes
08:23:58 <applicative> kuribas:?  and it is in the sub sub sub sub sub dir Arrow
08:24:06 <Kaidelong> everything is working, thanks
08:24:09 <RyanT5000> (i don't sleep much these days)
08:24:12 <ManateeLazyCat> RyanT5000: How to use gtk2hs with multi-threaded?
08:24:29 <applicative> kuribas, could it be you have hxt installed, and theres some confusion?
08:24:30 <RyanT5000> ManateeLazyCat: hm?
08:24:32 <kuribas> applicative: yes.  But it is only ghci that complains...
08:25:03 * ManateeLazyCat pasted "gtk2hs concurrent library." at http://paste2.org/get/852289
08:25:04 <ManateeLazyCat> RyanT5000: Above
08:25:13 <kuribas> applicative: I doubt is, there is no module of that name in HXT.
08:25:19 <RyanT5000> ManateeLazyCat: cool
08:25:26 <applicative> thats what i'm thinking the problem is, though
08:25:27 <ManateeLazyCat> RyanT5000: http://paste2.org/get/852289 is my Concurrent library for multi-thread.
08:25:29 <RyanT5000> that's new in 0.11, right?
08:25:56 <applicative> kuribas maybe for the moment, ghc-pkg hide hxt  unless you need the rest of it
08:25:58 <PeakerWork> I am trying to implement an abstract type "Image" whose (hidden) representation uses an ST computation that does in-place modification on an array representing the image.   But this makes my abstract type "Image" have to be parameterized on "s", thereby leaking the use of ST.
08:25:58 <ManateeLazyCat> RyanT5000: Once you enable "-thread" flag, just use my library will build your own multi-thread gtk+ program.
08:26:13 <ManateeLazyCat> RyanT5000: No, it's tool library of my project.
08:26:16 <PeakerWork> Can use of the ST monad be abstracted away at all?  It seems the "s" type parameter must always leak out
08:26:17 <RyanT5000> ah, ok
08:26:41 <aristid> const = return?
08:26:51 <ManateeLazyCat> RyanT5000: "forkGuiIO_ :: IO a -> (a -> IO ()) -> IO ()" design is split "long-time non-gui action" and "gui action"
08:27:42 <RyanT5000> ManateeLazyCat: yeah, that looks useful
08:27:50 <kuribas> applicative: I think I know the problem, I started ghci in the wrong directory (in emacs).
08:27:55 <RyanT5000> alright well i have to go to sleep lest i fall over in my chair
08:28:00 <ManateeLazyCat> RyanT5000: "forkGuiIO_ nonGuiAction guiAction" will starting two threads, one thread for nonGui Action, another thread for guiAction (but wait nonGuiAction signal).
08:28:04 <applicative> kuribas, or if you need all of HXT plus your own  Text.XML.HXT.Arrow.XHtml  then cabal unpack hxt, add your addition to the appropriate subdir of Text/HXT  ... and meanwhile hide your other hxt
08:28:06 <applicative> haha
08:28:07 <RyanT5000> so it's Final Spam Time!
08:28:23 <ManateeLazyCat> RyanT5000: Bye, hope above library will help you. :)
08:28:32 <RyanT5000> My company is hiring people to work on our video game, which is written in Haskell!
08:28:52 <RyanT5000> Email me at ryan@ipwnstudios.com to apply.
08:29:05 <Cale> PeakerWork: The whole point is that the s parameter *can't* leak out.
08:29:17 <RyanT5000> goodnight everyone
08:29:30 <kuribas> applicative: It works now!  I had to kill the *ghci* buffer, since I opened it in another directory.
08:29:33 <Cale> PeakerWork: runST will refuse to typecheck if applied to any ST computation where it does.
08:29:37 <applicative> \me wants to tell RyanT5000 that he can do code cleanup, supply typesignatures, kind of Haskell janitorial work.
08:29:43 <ManateeLazyCat> Anyone people can use my library (http://paste2.org/get/852289) build your own multi-thread gtk+ program with gtk2hs-0.11
08:29:49 * applicative too
08:30:04 <ManateeLazyCat> And implementation is simple enough, i think most haskeller will understand it. :)
08:30:15 <ManateeLazyCat> So i don't explain it. :)
08:30:30 <applicative> kuribas, i see.
08:32:23 <PeakerWork> Cale: I don't mean it that way.. I have something like:  data Image a = Image { ... updateArray :: STArray s Coor a ->ST s () }
08:32:36 <PeakerWork> Cale: Now the "s" is undefined, unless I have it be a type argument to "Image"
08:32:47 <PeakerWork> Cale: But "Image" is trying to be an encapsulated/abstract type, that hides the fact it uses ST in there
08:32:49 <kuribas> applicative: But thanks anyway.
08:33:06 <PeakerWork> Cale: Users of the Image type really don't want to know about any such "s"
08:33:41 <PeakerWork> Cale: my alternative is just having the "render" of image be in IO (unnecessarily) just so that I don't need the "s" type parameter to "Imagea"
08:33:47 <Cale> PeakerWork: You could use an existential
08:33:57 <Cale> Er, no sorry
08:34:08 <Cale> Just make the field polymorphic
08:34:20 <PeakerWork> Cale: I'm trying to be as H98 as possible, but it does seem "ST" is very H98 unfriendly
08:34:32 <Cale> ST is impossible in H98
08:34:40 <Cale> You need higher rank quantification
08:34:44 <PeakerWork> Cale: what do you mean by make the field polymorphic?
08:34:51 <Cale> data Image a = Image { ... updateArray :: forall s. STArray s Coor a ->ST s () }
08:35:10 <ManateeLazyCat> I explain a example, like my Gtk+ QuickSliver program: http://farm4.static.flickr.com/3415/4619030666_2e5df0bcf8_o.png , have feature "Search all execute file in PATH", this search action need 3 seconds or longer, and longer than one gtk loop cycle.
08:35:27 <marcot> Now I'm having a problem building gtk-0.11.0.  glib, cairo, gio and pango built correctly, but in gtk-0.11.0 ./Setup build I get:
08:35:34 <marcot> Setup: ./Graphics/UI/Gtk/General/IconTheme.chs: invalid argument
08:35:35 <PeakerWork> Cale: I'll try that, thanks
08:35:40 <Cale> I think you can do that if you have higher rank types enabled.
08:36:19 <Aberro> Is haskell compiler for MS VS2008/2010 exist?
08:36:35 <ManateeLazyCat> So i write "forkGuiIO searchAction renderGui", when searchAction search all execute file in PATH, it will fill result in MVar, then another thread will takeMVar (singal trick) to render in gtk+ main thread.
08:36:45 <marcot> hum, it seems to be utf-8 problems.
08:37:16 <ManateeLazyCat> Then we implementation concurrent for non-gui action.
08:37:56 <applicative> Aberro, I don't think there's any special arrangement with VS.  Have you installed the Haskell Platform.
08:37:57 <ManateeLazyCat> Because gtk+ code is little enough, any gtk+ code will post to Gtk+ main thread, then all concurrent result can render in one loop cycle
08:38:12 <ManateeLazyCat> marcot: Paste all error.
08:38:20 <marcot> This is all error.
08:38:22 <ManateeLazyCat> IconTheme.chs is bring by me.
08:38:39 <marcot> Even with --verbose=3
08:38:55 <ManateeLazyCat> line number?
08:39:03 <applicative> marcot, I was going to say, thank God ManateeLazyCat is here...
08:39:03 <marcot> Nothing.
08:39:46 <Aberro> applicative: Yes, I install it. But MS VS is much better for writing applications, isn't so?
08:40:06 <marcot> applicative: Yes, it's good that he's here.
08:40:30 <ManateeLazyCat> marcot: My Emacs will crash when i login irc long time.... :-(
08:40:38 <Aberro> applicative: I find solution for MS VS 2003/2005, but it's uncompatible with 2008/2010.
08:40:46 <marcot> ManateeLazyCat: Do you use ERC?
08:40:48 <danewbie> jkingkong, still there?
08:40:51 <ManateeLazyCat> marcot: Yes.
08:40:59 <danewbie> i've read what you asked (a bit late)
08:41:30 <danewbie> first of all, the shape should be written as (Z :. 3), not (Z : 3) (notice the dot)
08:41:32 <ManateeLazyCat> marcot: Can you do "cabal install gtk -v" and paste all output to me, just one line looks less help. Thanks!
08:41:42 <applicative> Aberro, I just noticed that existed, and figured it prompted your question.  I wonder if people who fool around with both F# and the GHC have wisdom about what is simplest.
08:41:58 <marcot> ManateeLazyCat: I'm not using cabal install, I'm building it by hand.
08:42:33 <ManateeLazyCat> marcot: Which command do you use? runhaskell?
08:42:49 <marcot> ghc --make Setup; ./Setup configure; ./Setup build
08:43:07 <applicative> ManateeLazyCat, I was about to give marcot some advice last night, but then realized he's a package manager.
08:43:14 <marcot> This is an utf-8 issue.
08:43:55 <marcot> applicative: Your advice was not valid for package managers?
08:44:50 <gwern> marcot must be a very intelligent package manager
08:44:58 <applicative> marcot, I was imagining you were trying to install it for yourself
08:45:07 <applicative> gwern, sorry idiotic expression
08:45:32 <applicative> marcot, so i was going to point out what you clearly knew, that there was a new allegedly cabal installable version
08:46:00 <marcot> applicative: Ah, ok.  At that point I was trying to install it for myself, because not even this was working.
08:46:17 <marcot> applicative: After that I planned to see what was wrong in the package build scripts, and correct it.
08:46:28 <ManateeLazyCat> marcot: Your command is right, i will test it.
08:46:45 <ManateeLazyCat> marcot: Wait, do you mean failed with gtk2hs-0.11 or other version?
08:46:52 <marcot> ManateeLazyCat: I think I know what the issue is.  The utf-8 locale is not generated in this specific host.
08:46:57 <marcot> gtk-0.11
08:47:08 <applicative> marcot, I see.  Of course I have no wisdom to give you; only admiration and praise.
08:47:23 <marcot> I think this is related to the new way ghc handles utf-8.
08:48:05 <ManateeLazyCat> marcot: AFAIK, ghc-6.12.x use unicode as IO encoding.
08:48:21 <ManateeLazyCat> marcot: And 6.10.x not.
08:49:00 <aristid> Cale: i've made a slightly improved improved version of your folds SVG, do you want it?
08:49:32 <Cale> aristid: sure
08:49:49 <fryguybob> byorgey: I'm trying to build the new diagrams stuff, where do I get vector-space 0.7?
08:49:50 <marcot> ManateeLazyCat: Ok, issue solved.  I had to install the locales package in Debian to make it work.
08:49:52 <marcot> Thanks anyway.
08:50:11 <ManateeLazyCat> marcot: Oh, glad to you fix it. :)
08:50:15 <marcot> =)
08:50:22 <applicative> Is there an easy to follow discussion of the way ghc-6.12 changes the treatment of strings from ghc-6.10?
08:50:26 <marcot> The new gtk2hs will be available in debian soon.
08:50:42 <aristid> Cale: how can i give it to you?
08:50:47 <applicative> marcot, that's quite an achievement!
08:51:20 <ManateeLazyCat> marcot: After gtk2hs-0.11.0, we will add new APIs in short-cycle, don't need wait 6 month, so maybe increase your work.... :)
08:51:27 <Cale> aristid: dcc send?
08:51:29 <ManateeLazyCat> shorter-cycle
08:51:36 <Cale> aristid: Or put it on a webserver somewhere?
08:51:48 <aristid> Cale: k i put it on my webserver
08:51:51 <marcot> ManateeLazyCat: No, this one is being harder, but usually is very simple.  So a shorter-cycle is welcome.
08:52:29 <ManateeLazyCat> marcot: Thank you for your great work on Debain package! I use Ubuntu. :)
08:53:02 <marcot> =)
08:53:06 <aristid> Cale: http://breitkreuz.me/Folds.svg
08:55:26 <illissius> it would be nice if, if you had a class with default implementations for all the methods, and another class which is a subclass of it, that if you declared an instance of the subclass, it would automatically generate the instance for the superclass
08:55:34 <illissius> would there be anything super-wrong about doing that?
08:57:10 <ManateeLazyCat> illissius: Looks like OOP logic. :)
08:57:58 <illissius> yes indeed.
08:58:14 <ManateeLazyCat> illissius: So what's real you want? General method in typeclass, then have special methods for class instance?
08:58:28 <applicative> illisius, it's so immoral, i can't even imagine it.
08:59:01 <aristid> Cale: i hope you like it. the main thing i did was grouping and alignment
08:59:12 <illissius> ManateeLazyCat: as it happens, i'm tinkering with hand-made bindings for Qt (-:
08:59:21 <ManateeLazyCat> illissius: I use Typeable integrate with typeclass.
08:59:32 <zygoloid> illissius: yes, there's something very wrong with that. suppose module X defines an explicit orphan instance of C A, and module Y defines an instance of D A (where D is the subclass of C), and doesn't import X.
08:59:41 <Kaidelong> Illisius: you could probably implement it in haskell using a functor over a record of methods
08:59:46 <ManateeLazyCat> illissius: Already have Qt binding exist.
08:59:58 <illissius> ManateeLazyCat: yes, I know
09:00:05 <zygoloid> illissius: is it so hard to write 'instance C A'? :)
09:00:09 <Cale> aristid: The shadows got bumped a bit it seems
09:00:30 * ManateeLazyCat pasted "typeable with typeclass" at http://paste2.org/get/852338
09:00:31 <ManateeLazyCat> illissius: Like above
09:00:36 <aristid> Cale: i think i didn't change them, but maybe it happened by accident
09:00:49 <ManateeLazyCat> illissius: I use PageView class implement common methods.
09:01:21 <ManateeLazyCat> illissius: After Typeable pass type-system check, i use Typeable.cast to implement special methods for class instance.
09:01:34 <danewbie> Hi there
09:01:38 <illissius> zygoloid: nah, not really -- just wondering
09:01:42 <danewbie> Has anyone compiled some recent version of GHC?
09:01:45 <ManateeLazyCat> illissius: And i think this solution is much clearer than sub-class hierarchy something.
09:01:52 <illissius> ManateeLazyCat: looking
09:01:52 <danewbie> I tried to install the ghc-6.13.20100524 from source (not darcs)
09:01:53 <applicative> danewbie, hi.   yes.
09:02:00 <zygoloid> illissius: i could imagine it being tedious with a long or complex context
09:02:00 <danewbie> but it seems it doesn't install the profiling libraries
09:02:07 <ManateeLazyCat> danewbie: Real problem?
09:02:08 <danewbie> which seems to be http://hackage.haskell.org/trac/ghc/ticket/3374
09:02:22 <danewbie> yep, i was trying to install cabal
09:02:28 <Kaidelong> so I take it between type classes and interfaces, most of you prefer type classes?
09:02:29 <danewbie> but when i was trying to build it
09:02:31 <zygoloid> illissius: but usually any proposal to automatically generate an instance hits this same issue. it'd be easier if we could just outlaw orphan instances entirely...
09:02:54 <danewbie> i got some "Could not find module `Control.Monad':      Perhaps you haven't installed the profiling libraries for package `base'?"
09:03:02 * ManateeLazyCat pasted "speical methods for type instance" at http://paste2.org/get/852340
09:03:09 <danewbie> which seems to be that bug
09:03:09 <ManateeLazyCat> illissius: Above is speical methods.
09:03:37 <danewbie> although it is closed...
09:03:59 <Kaidelong> Gilad Bracha says that Felix Geller has written a master's thesis comparing the advantages and disadvantages of type classes and interfaces, never really saw the two as being terribly different
09:04:11 <danewbie> have you got that problem?
09:04:14 <Kaidelong> anyone have background on this?
09:04:21 <applicative> danewbie, the complaint was about an earlier version of ghc,wasnt it?  are you building ghc-6.13 for some special reason?
09:04:31 <danewbie> i need it for Repa
09:04:39 <applicative> danewbie, ah indeed.
09:04:56 <ManateeLazyCat> illissius: After you define a Type (such as SourceView) for PageView, then you can use "forall a . PageView a => a -> ... " pass haskell type-system check, then you use "(cast x :: Maybe SourceView)" unpack SourceView from PageView instance.
09:05:09 <gwern> Kaidelong: what kind of interfaces? java?
09:05:17 <Kaidelong> whoops
09:05:21 <Kaidelong> misread this
09:05:26 <ManateeLazyCat> illissius: Because Typeable.cast return (Maybe a), those unpack action is type safe.
09:05:32 <danewbie> but it seems really the same bug, because the libraries are build, just not installed
09:05:34 <Kaidelong> the thesis was on patterns as first class values
09:06:07 <danewbie> just wondering whether it was known, or maybe it was my fault...
09:06:07 <Kaidelong> gwern: I think so, the guy was a java developer
09:06:20 <ManateeLazyCat> illissius: My code perhaps not different yours, but i think logic is same.
09:06:33 <ManateeLazyCat> s/perhaps different/
09:07:31 <Kaidelong> Only real difference I can see is that type classes are parameterized and don't abstract away implementation types
09:07:42 <Kaidelong> I suppose that's very, very important though?
09:07:51 <ManateeLazyCat> illissius: Simple is: use "class Typeable a => Foo a where" define common methods for class, then use "forall a . Foo a" through type-system check, then use Typeable.cast unpack "Foo instance", that's all.
09:09:21 <ManateeLazyCat> illissius: if you want store "Foo instance", maybe you need some FooWrap to do that, like this: "data FooWrap = forall a . Foo a => FooWrap a".
09:10:50 <ManateeLazyCat> illissius: Those looks trick, but it's simple enough once you understand it.
09:10:56 <illissius> Kaidelong: ah ok, I was thinking by 'interface' you meant some kind of haskell construct I hadn't heard of :)
09:11:14 <illissius> ManateeLazyCat: yeah I don't have much/any experience with Typeable so I'm trying to think through this
09:12:51 * ManateeLazyCat pasted "My PageView instance" at http://paste2.org/get/852350
09:12:57 <ManateeLazyCat> illissius: Above is my PageView implementation
09:14:12 <ManateeLazyCat> illissius: Typeable is simple enough, just write "deriving Typeable" after your declaration.
09:14:34 <ManateeLazyCat> illissius: Infact, all type class can use "forall a . Foo a" pass type-system check.
09:14:56 <ManateeLazyCat> illissius: The point is, use Typeable, it can pack/unpack type class.
09:16:11 <ManateeLazyCat> illissius: Example, you have FooA and FooB is instance of class Foo, use Typeable, when you do "cast" action, type-system will make sure apply your FooA methods to FooA and not FooB.
09:16:18 <illissius> ManateeLazyCat: what do you do if you have a longer inheritance chain, like A > B > C > D?
09:16:33 <illissius> (or do you just avoid that :)
09:16:56 <ManateeLazyCat> illissius: Yes, i avoid use too long inheritance.
09:20:06 <illissius> ManateeLazyCat: yeah, maybe your way could work better for code you're writing from scratch, but Qt already *has* long inheritance chains, and I'm basically just mapping them one-to-one onto type classes, which seems to be a workable approach so far.
09:20:10 <ManateeLazyCat> illissius: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/Data-Typeable.html
09:20:24 <illissius> yeah I've been looking at that, thanks :)
09:20:35 <ManateeLazyCat> illissius: Oh, you mean Qt binding?
09:21:14 * zygoloid would like a GHC extension: class {-# DERIVE deriveFoo #-} Foo a where ..., with deriveFoo :: TypeQ -> Q [Dec]
09:21:19 <illissius> yeah, I'm experimenting with that (not a serious project, at least not yet -- just tinkering)
09:21:37 <zygoloid> (the idea being that 'deriving Foo' would then call that function to generate an instance)
09:21:58 <ManateeLazyCat> illissius: If you do something Qt binding, you need Foreign pointer cast operation.
09:22:07 <ManateeLazyCat> illissius: Like we do in gtk2hs.
09:22:21 <illissius> and I know there exist bindings already, but one of them is disgustingly convoluted (and afaict the source for the generator isn't open), and the other one is itself unfinished, so *shrug*
09:23:16 <ManateeLazyCat> illissius: Infact, some months ago, i try to use qthaskell instead gtk2hs (because Qt awesome framework).
09:23:24 <ManateeLazyCat> illissius: At last, i give up.
09:24:01 <ManateeLazyCat> illissius: qtHaskell is incomplete and not open enough.
09:24:02 <illissius> yeah, I looked at the api docs for it and it was barf-worthy
09:24:08 <ManateeLazyCat> illissius: So i still use gtk2hs.
09:24:45 <ManateeLazyCat> illissius: Wait, i paste some code from gtk2hs.
09:24:54 <ManateeLazyCat> illissius: Maybe will help you.
09:25:17 * ManateeLazyCat pasted "Types from gtk package." at http://paste2.org/get/852373
09:25:25 <illissius> ManateeLazyCat: I'm getting along just fine, so far, but thanks :)
09:25:27 <ManateeLazyCat> illissius: Above Types.chs is generate by gtk2hs-buildtools.
09:26:03 <ManateeLazyCat> illissius: You will seen instance A -> B -> C -> D.
09:26:09 <devinus> how do you guys deploy haskell applications ?
09:26:20 <ezyang> devinus: What kind?
09:26:21 <ManateeLazyCat> illissius: So maybe you need search gtk2hs-buildtools.
09:26:34 <devinus> ezyang: services
09:26:37 <ManateeLazyCat> illissius: I don't know how to do "C++ -> Haskell".
09:26:55 <ManateeLazyCat> illissius: gtk2hs is depend on c2hs (C -> Haskell).
09:27:13 <illissius> ManateeLazyCat: C++ -> C -> Haskell :)
09:28:01 <ManateeLazyCat> illissius: I'm afraid too many transform will make something harder....
09:28:26 <Cale> devinus: Well, nobody can tell that it's a Haskell program running your webserver.
09:28:33 <illissius> I plan to repurpose smokegen (which is kde's bindings generator thingie) for the C++ parsing bits, if I get that far.
09:29:09 <ManateeLazyCat> illissius: In GTK+ have GObject Introspection (http://live.gnome.org/GObjectIntrospection), Qt have similar thing?
09:29:14 <illissius> is {# #} syntax some kind of ghc extension? or what?
09:29:18 <Cale> devinus: So, for network applications at least, it's no more difficult than running the program?
09:29:31 <illissius> ManateeLazyCat: yeah, QMetaObject is very analogous to GObject afaik
09:29:35 <illissius> but i'm not at that point yet
09:29:40 <Cale> (I guess I'm a bit uncertain about what 'deploy' means)
09:29:47 <Kaidelong> illisius: looks like a pragma to me
09:30:05 <illissius> Kaidelong: wouldn't that be {-# #-}?
09:30:11 <Kaidelong> ah
09:30:11 <Kaidelong> right
09:31:05 <illissius> ManateeLazyCat: someone, Richard Dale I think, even made a GObject-QMetaObject bridge at one point
09:31:14 <ManateeLazyCat> illissius: I think some guys works on GSoC GObject Introspection to replace middle code of gtk2hs.
09:31:49 * BMeph always thinks of sending oout the military, when he hears/sees "deploy". This does not bode well for any future career in enterprise project management... ;)
09:31:55 <ManateeLazyCat> illissius: Well, GObject-QMetaObject bridge looks cool, but will get more limit if have more transform.
09:32:29 <illissius> deploy all units! chaaarge!
09:32:35 <ManateeLazyCat> illissius: Trust me, binding GUI toolkit like gtk+ or Qt is not funny enough. :)
09:32:49 <ManateeLazyCat> illissius: Sometimes, it's painful.
09:33:57 <ManateeLazyCat> illissius: Because most gtk+ or Qt guys write C/C++ code like OOP logic, and some trick can finish with simple Haskell code, you even need write some middle-code by hand .....
09:34:57 <ManateeLazyCat> s/can finish/can't finish
09:36:50 <ManateeLazyCat> illissius: I recommand you work base on qtHaskell or build some automatic tools to generate .chs code and documentation, otherwise works is duplicate and *huge*
09:37:48 <illissius> ManateeLazyCat: thanks for the help
09:39:08 <siracusa> ManateeLazyCat: Has the gtk2hs repo been spilt?
09:39:21 <ManateeLazyCat> siracusa: Yes.
09:39:38 <ManateeLazyCat> siracusa: All non-core packages has split out.
09:39:57 <ManateeLazyCat> siracusa: Like vte, webkit, gtksoureview2.... etc.
09:40:35 <ManateeLazyCat> siracusa: Of course, gtk2hs-buildtools and core packages (glib, gio, pango, cairo, gtk) still share one repository.
09:40:59 <ManateeLazyCat> siracusa: Because core packages need control under gtk2hs Team.
09:41:25 <ManateeLazyCat> siracusa: All non-core packages will take over by author or other maintain.
09:41:34 <siracusa> ManateeLazyCat: Ok, I got errors when updating, it tried to delete non-empty directories.
09:42:43 <ManateeLazyCat> siracusa: Paste it?
09:44:03 <ManateeLazyCat> siracusa: Maybe you need use "get" instead "pull" .  :)
09:44:56 <siracusa> ManateeLazyCat: Never mind, the problem is clear now. Some packages where removed from the repo, but I had still .o and .hi files in the directories.
09:45:12 <ManateeLazyCat> siracusa: :)
09:45:44 <ManateeLazyCat> siracusa: I always use two local repositories in my box, one for install, another for pull/push patches. :)
09:46:20 <siracusa> ManateeLazyCat: Unfortunately, I think drag and drop is now broken on Windows :-(
09:47:24 <ManateeLazyCat> siracusa: Sorry for that, can you report it to gtk2hs-devel list, Axel will fix it if it's a Windows bug.
09:49:35 <ManateeLazyCat> siracusa: gtk2hs-0.10.1 can work?
09:49:43 <gio123> k
09:50:33 * ManateeLazyCat I'm fully a keyboard guys .... :)
09:51:01 <siracusa> ManateeLazyCat: I haven't tested it with the old version, just installed gtk2hs-0.11 and my program doesn't work anymore.
09:51:33 <ManateeLazyCat> siracusa: Can you share you program is you want?
09:51:40 <ManateeLazyCat> siracusa: I can test it on Linux.
09:52:03 <ManateeLazyCat> siracusa: If Linux works, it's problem of Windows or some else...
09:52:37 <siracusa> ManateeLazyCat: It's far to complex. I'll write a minimal example.
09:52:39 <ManateeLazyCat> siracusa: Infact, gtk2hs-0.11 more like bug fix version, haven't change old APIs,
09:53:24 * ManateeLazyCat Why most gtk2hs users on Windows ?
09:53:42 <Kaidelong> ManateeLazyCat: statistics
09:54:06 <Kaidelong> most users of anything that is supported on windows will generally be using windows
09:54:14 <Kaidelong> because so many more people use windows
09:54:15 <ManateeLazyCat> Have any FRP master here? I'm reading FRP papers ....
09:54:35 * applicative wants to notify ManateeLazyCat that most of humanity uses windows
09:54:45 <ManateeLazyCat> Kaidelong: Maybe future people just use Android or iphone-OS.
09:54:59 <Kaidelong> ManateeLazyCat: maybe, but for now most of the world uses windows
09:55:21 <Kaidelong> programming haskell on my android phone would probably be hard, though
09:55:25 <Kaidelong> if you want my two cents
09:55:33 <Kaidelong> and I'll want to test myself on windows
09:55:38 <Kaidelong> my stuff even
09:56:18 * ManateeLazyCat I haven't use Windows many years.....
09:56:33 * ManateeLazyCat Feel Windows waste my time.
09:56:37 <Kaidelong> It has gotten better lately
09:56:49 * ManateeLazyCat I can use keyboard do everything in Linux.
09:56:50 <Kaidelong> but I do wish I didn't have to use it
09:56:53 <Dawgmatix> any pointers for editors for haskell ? especially something with an integrated debugger would be nice
09:57:15 <Kaidelong> I'm having better luck with leksah lately
09:57:28 <ManateeLazyCat> Dawgmatix: For release project is leksah.
09:57:43 <Kaidelong> I think most people use emacs
09:57:48 <Dawgmatix> okay
09:58:03 <Olathe> From what I've heard, leksah is completely backwards for Haskell.
09:58:13 <Dawgmatix> i am an experienced programmer who just bought a haskell book and wanted to find out what tools people use
09:58:30 <Kaidelong> Olathe: it seems to be built around cabal. Completely backwards how though?
09:58:41 <ManateeLazyCat> Dawgmatix: I recommand use Emacs.
09:58:46 <Olathe> > reverse "leksah"
09:58:47 <lambdabot>   "haskel"
09:58:50 <Kaidelong> I do not like that it has no VS like "send to interpreter" functionality
09:58:52 <siracusa> ManateeLazyCat: There're no problems with drag and drop in the minimal example, so I'll have to debug my program :-)
09:58:57 <Dawgmatix> thanks
09:59:01 <applicative> Dawgmatix, cool.   The more expert people use emacs or vim
09:59:04 <ManateeLazyCat> siracusa: Glad to heard that.
09:59:19 <applicative> Dawgmatics, thus a flame war can be started by such a question.
10:00:03 <ManateeLazyCat> siracusa: For old APIs, if it can works with gtk2hs-0.10.1, it's no problem with gtk2hs-0.11.0
10:00:31 <Dawgmatix> one last question - is it recommended to download the latest haskell from haskell.org or are distro specified packages well supported (i come from the lisp world where distros ship packages that are very out of date)
10:00:46 <Kaidelong> ManateeLazyCat: do you know if grapefruit works with the cabalized gtk?
10:00:50 <ManateeLazyCat> Dawgmatix: cabal update.
10:00:59 <Dawgmatix> okay
10:01:21 <ManateeLazyCat> Kaidelong: I heard grapefruit, but haven't try it.
10:01:59 <applicative> Dawgmatix, what distro are you using, its different with different ones
10:02:07 <Dawgmatix> thanks, now to dig into the haskell school of expression.
10:02:15 <Dawgmatix> i use ubuntu (lucid in particular)
10:03:10 <applicative> have you installed ghc yet?
10:03:14 <Kaidelong> ManateeLazyCat: apparently not
10:03:28 <Kaidelong> they set a requirement that gtk2hs version is <0.11
10:04:05 <siracusa> Kaidelong: I think Grapefruit is broken anyway at the moment, at least with GHC 6.12
10:04:58 <Kaidelong> siracusa: is grapefruit still being maintained at least? or did it get abandoned ala wxFruit
10:05:08 <Dawgmatix> yes i just installed ghc from synaptic since i noticed it has the same version (6.12.1) as the one on haskell.org
10:05:25 <ManateeLazyCat> Kaidelong: You switch to gtk2hs from wxWindows ?
10:05:32 <Kaidelong> ManateeLazyCat: gladly
10:05:46 <mux> @hoogle [Maybe a] -> [a]
10:05:47 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:05:47 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
10:05:47 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:06:12 <applicative> Dawgmatix, cool, I wasn't sure if the ghc 6 12 had m ade it there
10:06:13 <alexyk> how do I find out in general what a module provides and what functions do?  E.g., is there a way to inspect say Text.JSON from the commandline or ghci?  Like Clojure's (doc foo)
10:06:27 <ManateeLazyCat> Kaidelong: I'm too busy recently, after i finish my project, i will review all gtk+ 2.18 patches, and update gtk2hs to gtk+ 2.20.
10:06:35 <applicative> Dawgmatix, cool, is there a master package for 'haskell platform'?
10:06:44 <siracusa> Kaidelong: Well, I know that the author is not working on it actively at the moment. But there will be working and improved future releases.
10:07:04 <ManateeLazyCat> Kaidelong: Some widget in Gtk+ 2.20 are very useful, like GtkSpinner.
10:07:27 <Kaidelong> siracusa: seems like it should be more something under the care of a team. I take it haskell in general doesn't have the most manpower?
10:08:23 <alexyk> or generally how do folks look up modules docs?
10:08:31 <siracusa> Kaidelong: Not in general I think, but at least for some packages.
10:08:32 <ManateeLazyCat> siracusa: What's grapefruit? A front-end that give your advanced framework to control GUI program?
10:08:51 <siracusa> ManateeLazyCat: It's a FRP based GUI library
10:08:52 <Dawgmatix> applicative - i dont think theres something like haskell platform, though there is ghc6, hackage and a big bunch of haskell libraries. ive installed haskell and hackage command line tools and will install libraries using hackage in the future as i need them
10:08:54 <Kaidelong> ManateeLazyCat: an FRP framework for GUI programming
10:09:04 <Kaidelong> it's supposed to be independant of the back-end
10:09:11 <Kaidelong> but all that is supported right now is GTK
10:09:12 <ManateeLazyCat> I'm reading FRP paper since some many people recommand me read it.
10:09:27 <Dawgmatix> oops i mean cabal instead of hackage
10:09:56 <applicative> Dawgmatix, cool, I was thinking of the ` cabal install ` executable, most of all
10:10:04 <Dawgmatix> yes that exists
10:12:08 <applicative> Dawgmatix, that's good.  you can install packages from Hackage then.  Also, just `cabal unpack blah` to get the package and study it.  the SOE material is included in gtk2hs, or it was till the new version that just came out.
10:12:34 <ManateeLazyCat> applicative: "cabal install soegtk"
10:13:13 <applicative> Dawgmatix, ManateeLazyCat knows....
10:13:44 <alexyk> so, can you use haddock from command line or what?
10:13:52 <Dawgmatix> great, i appear to be all set :)
10:13:57 <fryguybob> @tell byorgey I'm trying to build the new diagrams stuff, where do I get vector-space 0.7?
10:13:57 <alexyk> or hoogle, or whatnot
10:13:57 <lambdabot> Consider it noted.
10:14:28 <devinus> Cale: i mean a deployment strategy other than git pull && make && ./run
10:14:30 <applicative> Dawgmatix, theres always help here, if you can break through the occasional type theory manias and so on.
10:15:05 <Dawgmatix> thanks :)
10:15:13 <Cale> devinus: cabal?
10:15:34 <applicative> Dawgmatix, one nice tool when beginning I found is hlint; you run it on your module and it tells you stuff like,  You dont need those parentheses
10:15:35 <devinus> Cale: are you familiar with erlang or java releases ?
10:15:55 <Dawgmatix> will look at that applicative
10:16:01 <alexyk> I guess nobody looks up docs here...  hmm
10:16:21 <alexyk> copumpkin: ping
10:16:34 <Cale> devinus: I haven't used either of those extensively enough to care about packaging my code.
10:16:43 <ManateeLazyCat> Dawgmatix: If you use hlint with Emacs, try use hlint.el
10:16:44 <Cale> devinus: But it sounds like you're looking for cabal
10:16:59 <Dawgmatix> okay manatee
10:17:08 <ManateeLazyCat> Dawgmatix: It will help you jump wrong code position in Emacs.
10:17:33 <zygoloid> wouldn't it be more useful if it helped you to jump to the right code position? :)
10:17:57 <ManateeLazyCat> Dawgmatix: If you just simple use Hasekll, leksah maybe be quick, if you want study Haskell, i recommend use Emacs or vi.
10:18:13 <Dawgmatix> i am already a emacs user, so i will probably go the emacs route
10:19:24 <ManateeLazyCat> zygoloid: Infact, hlint.el use Emacs's compile mode, hlint output "file:row:column:suggestion", then emacs jump position with those information.
10:19:49 <ManateeLazyCat> s/compile mode/compilation mode
10:20:26 <triyo> Hmm, I am trying to do a connection to mongoDB server using mongoDB haskell bindings from hackage in ghci. I get a Segmentation fault
10:20:57 <ManateeLazyCat> triyo: run in gdb, then type "bt" to get backtrace.
10:21:10 <ManateeLazyCat> triyo: Then will help about segmentation detail.
10:22:24 <triyo> ManateeLazyCat: hmmm I have abs no idea how to use gdb, I'm on a mac and I do have it installed.
10:22:34 <kuribas> Why should a . b $ c be better that a $ b $ c?
10:22:46 <Cale> kuribas: more apparent subexpressions
10:22:52 <Cale> a . b is meaningful on its own
10:22:57 <Cale> a $ b will be a type error
10:23:16 <Cale> It makes it easier to refactor code
10:23:20 <kuribas> I see.
10:23:28 <kuribas> I didn't think of it that way.
10:23:43 <ManateeLazyCat> triyo: "gdb ./YourProgram", then type "run", when your program crash, type "bt" in gdb.
10:23:50 <Cale> Also, a bunch of us want to change the associativity of $ in the future
10:24:05 <ManateeLazyCat> triyo: Then you will got backtrace about segmentation-fault.
10:24:05 <Cale> which will never happen if everyone writes code with repeated $'s like that
10:24:15 <triyo> ManateeLazyCat: oh I see, I was running this in a ghci session...will need to build a quick main
10:24:28 <kuribas> Cale: That would break a lot of code!
10:24:40 <Cale> kuribas: Well, less and less code now :)
10:24:48 <ManateeLazyCat> triyo: You need "ghc --make Foo.hs main" build main, then run "main" in gdb.
10:24:57 <Cale> kuribas: Most of the people who come here use the compositional style now, I think :)
10:25:29 <Cale> Repeated $'s used to be more popular than they are now
10:26:06 <triyo> ManateeLazyCat: thx, I'll do that, need to run now (need to bath my daughter, my wife is gonna have my balls in a wise.. :)) .. to much info, I know, laters.
10:26:22 * BMeph prefers an advice document of "how the new version breaks old code", and just going ahead to make a new version, than keeping old systems poorly reorganized
10:26:27 <ManateeLazyCat> Kaidelong: Maybe i don't use any FRP implementation wrap my program, but i want to read about it. FRP looks unnecessary for gtk2hs, just give your clearer logic i think.J
10:28:38 <Chaze> this is called a "trace" in a lecture I'm hearing: http://pastie.org/978387   does it look familiar to anything you know?
10:28:41 <Kaidelong> ManateeLazyCat: I think the intention is that FRP provides a declarative way to write your GUI code, which can then later on by translated to be used by an imperative library like gtk2hs
10:28:56 <Twey> Cale: Maybe we should introduce a GHC warning
10:29:10 <Kaidelong> so putting FRP stuff in the backend would be counter-productive, perhaps?
10:29:21 <Twey> Chaze: Sure
10:29:38 <Twey> Chaze: It's a manual expansion of an expression  the functional equivalent of a dry-run
10:29:53 <Chaze> Twey: yep, I figured that much. is there some way to compute them?
10:30:21 <Twey> Oh.  Hm.
10:30:25 <Cale> Chaze: It's also the sort of thing which is produced by older debugging tools for Haskell.
10:30:50 <Cale> I think Hat produced output like that
10:30:54 <Twey> What do newer ones do?
10:31:00 <zygoloid> Chaze: a #haskell regular has an online generator of such things. but i don't recall who! :(
10:31:00 <Chaze> Cale: thanks, i'll look into that
10:31:08 <Cale> http://www.haskell.org/hat/
10:31:10 <ManateeLazyCat> Kaidelong: If have gtk2hs-frp, i will try to play it, if grapefruit will support many back-end, i will stop use it. That's mean grapefruit must get *minimum* feature from different back-end.
10:31:28 <zygoloid> aha, mr BenMachine himself
10:32:22 <ManateeLazyCat> Kaidelong: I think most haskeller in this channel like play haskell with many advanced moand, but in my gtk2hs code, i try to avoid use too many moand wrap, except it can give me big improve like State moand.
10:32:23 <Cale> Right, benmachine wrote a nice tracer, which doesn't quite do lazy evaluation, but does a decent outermost-first trace.
10:32:53 <Cale> ManateeLazyCat: I actually think that monad transformers are overused.
10:33:00 <Kaidelong> ManateeLazyCat: I think the idea is that your C library interface goes pretty straight to the C, and that someone else can abstract over that if you need to?
10:33:04 <siracusa> ManateeLazyCat: No, you can use all features of a single backend in Grapefruit IIRC
10:33:09 <ManateeLazyCat> Cale: I just use runStateT . :)
10:33:11 <Cale> (StateT in particular)
10:33:45 <Cale> My personal heuristic is that nobody should be able to tell that you're using monad transformers from outside the module :)
10:33:45 <ManateeLazyCat> Cale: i use runStateT in function body to remove temporary variable. :)
10:33:47 <Cale> yeah
10:33:59 <hstefan> Hai. Is someone able to help me with gtk2hs?
10:34:04 <ManateeLazyCat> hstefan: Me.
10:34:22 <Cale> Well, I also tend to just pass parameters more often than I'll use StateT
10:34:28 <ManateeLazyCat> hstefan: Please report your OS and environment first.
10:34:33 <ManateeLazyCat> hstefan: Joking.... :)
10:34:43 <Cale> Unless it's the sort of parameter passing where I have to return intermediate states tupled with my results.
10:34:54 <hstefan> lol, I was just typing it haha
10:35:55 <ManateeLazyCat> Cale: Yes, runStateT is not happy with too many argument, such as runStateT (a, b, c, d) ....
10:36:21 <hstefan> anyway, let me ask you: I'm trying to write a custom model for showing a list on the treeView, but I dunno how to do it. Could you help me?
10:36:30 <c_wraith> ManateeLazyCat, the first argument to runStateT should be something of type StateT s m
10:36:36 <Cale> ManateeLazyCat: yeah, and especially if you're using it with IO, the result is often just as, if not uglier, than using IORefs
10:36:41 <c_wraith> err, StateT s m a
10:36:56 <Cale> StateT over list, however, is great :)
10:36:59 <ManateeLazyCat> c_wraith: I know, i use my own runStateT
10:37:03 <zygoloid> Chaze: http://tinyurl.com/36zwoc9
10:37:19 <Kaidelong> shouldn't you give it your own name then?
10:37:29 * ManateeLazyCat pasted "my state library" at http://paste2.org/get/852476
10:37:32 <ManateeLazyCat> c_wraith: Above
10:37:42 <c_wraith> ManateeLazyCat, ok, then. :)
10:38:06 <ManateeLazyCat> c_wraith: I use runStateT_ (arg1, arg2) -> do ....
10:38:17 <ManateeLazyCat> c_wraith: Or runStateT' :)
10:39:09 <ManateeLazyCat> harlekin: First thing, why you need custom model?
10:39:32 <ManateeLazyCat> hstefan: Maybe you use wrong understand with MVC of treeView.
10:39:51 <ManateeLazyCat> hstefan: Unfortunately, we forgot add demo program in gtk package.
10:40:48 <ManateeLazyCat> hstefan: Looks demo http://code.haskell.org/gtk2hs/gtk/demo/treeList/
10:41:00 <Chaze> zygoloid: thanks, this might be useful
10:41:04 <hstefan> ManateeLazyCat: thank you
10:41:58 <ManateeLazyCat> hstefan: If you know nothing about TreeView, you need read this manual : http://scentric.net/tutorial/
10:42:25 <hstefan> ManateeLazyCat: I know ALMOST nothing, so I'll read. haha
10:43:40 <ManateeLazyCat> hstefan: Read http://scentric.net/tutorial/ for understand MVC principle of TreeView, then integrate http://code.haskell.org/gtk2hs/gtk/demo/treeList/ with http://hackage.haskell.org/packages/archive/gtk/0.11.0/doc/html/Graphics-UI-Gtk-ModelView-TreeView.html
10:44:35 <ManateeLazyCat> hstefan: The point is not how to write work code, is understand MVC principle of TreeView/TreeModel/TreeViewColumn
10:44:47 <ManateeLazyCat> hstefan: Do you know MVC?
10:46:59 <ManateeLazyCat> hstefan: custom model is just need when you want write your own data-model to get more control , and most time, listStore is enough.
10:47:55 <Twey> How does the link :: ByteString -> ByteString -> Node, link "/login" "Login" work in the Description of http://hackage.haskell.org/packages/archive/heist/0.1.2/doc/html/Text-Templating-Heist.html?
10:48:03 <Twey> It looks like literal syntax for ByteStrings?
10:49:07 <siracusa> ManateeLazyCat: What are the plans for the demos, create a single demo package or put them in the appropriate packages?
10:49:21 * ManateeLazyCat pasted "runStateT code." at http://paste2.org/get/852487
10:49:33 <ManateeLazyCat> Cale: Above is my unlgy runStateT code.
10:49:45 <ManateeLazyCat> Cale: looks modifyM_
10:50:33 <ManateeLazyCat> siracusa: We have split all demo on it's own repository, just we forgot modified .cabal file, that "cabal sdist" lost demo demo directory when we release, sorry for that.
10:51:13 <ManateeLazyCat> siracusa: We will add demos when we fix some bugs on gtk2hs-0.11, then add demo in in gtk2hs-0.11.1
10:51:29 <siracusa> ManateeLazyCat: I see
10:51:35 <Dawgmatix> btw hlint is broken in cabal, how do i report this ?
10:52:22 <ManateeLazyCat> Dawgmatix: I doubt it.... I think hlint conflict with some package......
10:52:34 <ManateeLazyCat> Dawgmatix: Install hlint first, then install other packages.
10:52:45 <alexyk> how, in ghci, can you read the contents of a file into a variable?  let jsrc = ... readFile "1tweet"
10:53:07 <ManateeLazyCat> alexyk: No.
10:53:22 <ManateeLazyCat> alexyk: BTW, is "jsrc <- readFile file"
10:53:26 <alexyk> ManateeLazyCat: so only in an executable?
10:53:35 <ManateeLazyCat> alexyk: readFile return "IO String"
10:53:59 <ManateeLazyCat> alexyk: Yes.
10:54:19 <siracusa> alexyk: You can use what ManateeLazyCat wrote directly in GHCi
10:54:20 <alexyk> yeah.. ok
10:54:33 <alexyk> siracusa: aha!
10:54:58 <Raynes> <-
10:55:17 <alexyk> siracusa: since we run under an implicit do?
10:55:31 <alexyk> Raynes: I'll report you to rhickey!
10:55:33 <Dawgmatix> manatee, i see this error - "happy version >=1.17 is required but it could not be found."
10:55:39 <Raynes> alexyk: : I have no idea what he is getting at there. You can do exactly what you want with "jsrc <- readFile file"
10:55:50 <ManateeLazyCat> Cale: BTW, when i first study State moand, i'm confusion that try to use State moand from outside the module. :)
10:55:51 <alexyk> Raynes: yep, works
10:55:54 <EvanR-work> beware lazy io!
10:56:09 <alexyk> Raynes: still the comrades will discuss your recent neglect of Clojure
10:56:13 <ManateeLazyCat> Dawgmatix: Add "~/.cabal/bin/" in your PATH environment variable.
10:56:35 <ManateeLazyCat> Dawgmatix: happy install at ~/.cabal/bin, but hlint can't found it.
10:56:42 <Raynes> alexyk: Same to you. ;)
10:57:04 <ManateeLazyCat> Dawgmatix: Or do a soft-link in somewhere, like "sudo ln -s ~/.cabal/bin/happy /usr/local/bin"
10:57:06 <alexyk> Raynes: I need speedup :)
10:57:08 <Dawgmatix> ah i thought ln -s cabal to my ~/bin would do it
10:57:18 <Dawgmatix> didnt know about happy
10:57:22 <Raynes> alexyk: I've been wanting to freshen up my Haskell and write something in it, but I've been too busy with my Clojure projects. :<
10:57:26 <Dawgmatix> works now!
10:57:28 <ManateeLazyCat> Dawgmatix: add PATH is easiest way.
10:57:46 <ManateeLazyCat> Dawgmatix: Then all hackage binary will find by others.
10:57:47 <alexyk> Raynes: is there an equivalent of (doc foo) in this gobbledygooky soup we're in now? :)
10:58:42 <Raynes> alexyk: Just hoogle.
10:58:55 <alexyk> Raynes: I was vox clamantis in deserto for three hours and no command-line goodness emered
10:58:57 <Raynes> http://haskell.org/hoogle/
10:58:58 <Raynes> Oh how I wish Haskell had doc strings.
10:59:22 <alexyk> Raynes: yeah, so 1998
10:59:35 <Raynes> ;)
10:59:36 <c_wraith> Raynes, you mean that can be queried from ghci?
10:59:40 <alexyk> I mean, doc strings.  Man.
10:59:55 <alexyk> c_wraith: yep
11:00:14 <Raynes> c_wraith: Indeed. A way to look up documentation for a function in ghci.
11:00:18 <alexyk> how hard can it be, give eaf function an optional doc string queriable with doc foo
11:00:22 <alexyk> each
11:00:29 <alexyk> from ghci or command line
11:00:44 <Raynes> Lambdabot can hoogle
11:01:01 <alexyk> Raynes: some things are better done in private
11:01:10 <Raynes> Hehe.
11:01:30 <alexyk> of course, one can have a private session with the lanbdadot
11:02:14 <alexyk> kinda an alias for wget .. hoogle q=...
11:02:26 <aristid> alexyk: but then of course #haskell can't enjoy the @pl-trickery
11:02:43 <alexyk> aristid: @pl?
11:03:37 <Raynes> alexyk: It shows you magic. It shows you how to turn a lambda into a point-free composition of functions.
11:03:43 <Raynes> I think. IIRC.
11:03:54 <alexyk> ah
11:04:16 <aristid> alexyk: i love @pl and @unpl and @do and @undo and @.
11:04:35 <alexyk> oh, btw, I don't like . -- this dot.  I prefer F#'s |> to go left to right, is there one in Prelude or some stdlib module?
11:04:38 * ManateeLazyCat Eat FRP papers, maybe i will write some gtk2hs-frp library.... :)
11:04:38 <lispy1> aristid: yeah!
11:04:49 <aristid> @. pl undo f x y = do a <- x y; return a
11:04:49 <lambdabot> f = flip flip return . ((>>=) .)
11:05:05 <alexyk> oy
11:05:24 <Raynes> I love the dot.
11:05:33 <ManateeLazyCat> IMO, we don't need use CustomModel in TreeView anymore.
11:05:36 <Jafet> @. pl quote
11:05:37 <lambdabot> megeria says : i am so new to haskell that i still have the new car smell
11:05:40 * alexyk has a feeling he saw these people on #scala as well
11:06:22 <aristid> Jafet: now we only need the orbitz command.
11:06:22 <alexyk> Raynes: the dot is puny.  It's no little bouncy circle of math with a hole in t.
11:06:29 <alexyk> Raynes: . /= o
11:06:48 <ManateeLazyCat> I can use typeclass with Typeable through TreeModel type-check, then pick-up information with cast.
11:06:51 <Jafet> Say  if you mean 
11:07:12 <ManateeLazyCat> Around CustomModel completely, even have trick.
11:07:25 <Kaidelong> would be nice if we could get around to those haptic interfaces so that we're not stuck with the same keyboards
11:07:44 <alexyk> ok say I want to decode a tweet from JSON.  I get
11:07:46 <alexyk>  Ambiguous type variable `a' in the constraint:
11:07:46 <alexyk>       `JSON a' arising from a use of `decode'
11:07:54 <Jafet> You would need to be really fit to use most of those interfaces
11:08:02 <ManateeLazyCat> Like http://farm4.static.flickr.com/3415/4619030666_2e5df0bcf8_o.png , is i use some typeclass with listStore, don't use custmModel anymore.
11:08:05 <alexyk> should I define teh type to decode to, or can I just have a Map?
11:08:05 <EvanR-work> > let () = (.) in length  map (+1) $ [1,2,3]
11:08:06 <lambdabot>   3
11:08:49 <quicksilver> kuribas: FYI you don't have to kill ghci because it is in the wrong directory. There is a ":cd" command.
11:08:50 <alexyk> EvanR-work: is it a unicode raised dot?
11:09:00 <ManateeLazyCat> Kaidelong: If i write some gtk2hs blog, can you understand my English? :)
11:09:49 <EvanR-work> alexyk: yes
11:09:49 <hstefan> ManateeLazyCat: hey, how do I set the maximum size of a TreeView?
11:09:59 <Kaidelong> ManateeLazyCat: your English is perfectly understandable, and writing a blog will improve it
11:10:04 <alexyk> EvanR-work: the hole barely shows
11:10:11 <Raynes> It shows fine.
11:10:15 <Saizan> alexyk: you can use JValue if you want some generic representation of the JSON data
11:10:20 <kuribas> quicksilver: Ah, nice to now.
11:10:24 <EvanR-work> alexyk: the hole is one pixel big in my font
11:10:27 <ManateeLazyCat> hstefan: widgetSetSizeRequest treeView width height
11:10:37 <EvanR-work> but the entire thing is 3 pixels big
11:10:39 <hstefan> ManateeLazyCat: thank you again!
11:10:54 <hstefan> ManateeLazyCat: am I able to scroll down and see other items?
11:11:02 <alexyk> Saizan: I want to have a Map of Maps/Lists, can I enforce conversion of each JSObject to a Map and JSArray or whatever to a List?
11:11:40 <alexyk> EvanR-work: yeah, looks grey here on Mac.  Raynes can see through some tight holes apparently.
11:11:49 <ManateeLazyCat> Kaidelong: Sometimes, my English has some flaws.
11:11:54 <Saizan> alexyk: i don't think there's an instance for that, but you should check the haddock docs
11:11:58 <EvanR-work> data JS = JSObject (Map String JS) | JSArray [JS]
11:12:04 <ManateeLazyCat> hstefan: You need add treeView in scrolledWindow
11:12:22 <Saizan> alexyk: however JValue is already quite similar to that
11:12:36 <hstefan> ManateeLazyCat: hum... okay
11:12:46 <Kaidelong> ManateeLazyCat: I was not disputing it. Remember though that English has been a very international language for a long time and it's grown resistant to meaning being lost through mistakes.
11:13:22 <Kaidelong> You make mistakes but not so that you can't be understood
11:13:49 <ManateeLazyCat> Kaidelong: I'm a Chinese, i have bad spoken English, so i'm afraid i write wrong words even i understand it correctly.
11:14:25 <EvanR-work> its a chinaman!
11:14:26 <Kaidelong> ManateeLazyCat: write your blog. People will still understand you. You will learn from people correcting you.
11:14:44 <pikhq> ManateeLazyCat: The only way to improve, y'know, is to keep doing stuff in English. Watch TV in English, read books in English, write blogs in English, etc.
11:14:50 <alexyk> ok, decode jsrc :: Result JSValue does it.  Then I get stuff like, Ok (JSObject (JSONObject {fromJSObject = [("in_reply_to_status_id",JSNull) ... -- why fromJSObject=... ?
11:15:00 <pikhq> Oh, yeah, and actively studying things that you get wrong might help too.
11:15:42 <ManateeLazyCat> hstefan: widgetSetSizeRequest just send size "request* to gtk+ layout engine, so it's last size maybe not your setup value.
11:16:01 <Saizan> alexyk: that's just how record types get shown by default, fromJSObject is an accessor function for the unique field of JSONOBject
11:16:10 <zygoloid> alexyk: that looks like a derived Show instance for an ADT defined with record syntax
11:16:24 <zygoloid> (or rather, for a constructor defined with record syntax)
11:16:29 <alexyk> ah ok
11:16:35 <ManateeLazyCat> pikhq: Yes, i'm listen English songs, write English words with your guys, and watch English movie, read English papers....
11:17:00 <pikhq> ManateeLazyCat: Awesomeness.
11:17:05 <alexyk> so do folks use Text.JSON or some RJSon, reflective JSON, both in hackage?
11:18:03 <alexyk> More people know English than Haskell => English is simpler than Haskell.  English has no monads either.
11:18:16 <ManateeLazyCat> pikhq: Infact, i can read/understand English fully, but i can't write good English sometimes, because i haven't friend in RealWorld, so i can't speak it.
11:18:28 <Kaidelong> alexyk: I think I'll have to disagree on one of those points
11:18:48 <alexyk> Kaidelong: I won insist on any :)
11:18:51 <alexyk> won't
11:18:57 <EvanR-work> @src RealWorld
11:18:57 <lambdabot> Source not found. Sorry.
11:19:04 <quicksilver> kuribas: Ideally, haskell-mode would do it automatically (:Cd to the right place) when you C-c C-l
11:19:20 <quicksilver> kuribas: it does, if your project has a .cabal file, I believe.
11:19:38 <ManateeLazyCat> hstefan: If you add treeView/scrolledWindow in a GtkBox, you need use PackNatural instead PackGrow, because PackGrow will widget's size to max and ignore the value set in widgetSetSizeRequest.
11:19:56 <ManateeLazyCat> hstefan: This is little trick you need noticed.
11:20:25 <kuribas> quicksilver: oh, I see.  It doesn't have one yet.
11:21:48 <ManateeLazyCat> pikhq: I develop some English transform (around point) and English writer in Emacs.
11:22:11 <ManateeLazyCat> pikhq: If i can't understand some word, i move cursor to that word, i will know it's mean in Chinese.
11:22:27 <ManateeLazyCat> pikhq: I use English-writer flood irc channel.... :)
11:23:25 <ManateeLazyCat> pikhq: So i won't typo in most time, but i will got syntax error always.
11:24:10 * ManateeLazyCat I think my English will perfect if some English native-speaker can teach me how to speak English..... :)
11:24:49 <Kaide> ManateeLazyCat: tools like those are of questionable value for language learning. Best to use them to *confirm* ideas.
11:25:07 <zygoloid> ManateeLazyCat: you could set up a comments system like Real World Haskell had, on your blog, so people can correct your english :)
11:25:27 <ManateeLazyCat> Kaide: http://www.emacswiki.org/emacs-se/Sdcv#toc7
11:25:54 <ManateeLazyCat> zygoloid: Yes, i will, but i'm too busy on my project and gtk2hs now.
11:25:57 <Kaide> ManateeLazyCat: you need to be able to outsmart the tool you are using, for example once a machine translation I got for "the hyenas were stalking..." into german really meant "the hyena's were caring for..."
11:26:09 <Kaide> if I wasn't smarter than the tool I'd have ended up submitting that
11:26:18 <ManateeLazyCat> zygoloid: Maybe i will walk outside after i finish my project.
11:27:22 <ManateeLazyCat> Kaidelong: Because i'm hate Emacs now and i don't want waste time on elisp, so i don't want improve my tools.
11:27:43 <ManateeLazyCat> Kaidelong: I will develop smarter English tools in my project.
11:27:52 <Kaidelong> ManateeLazyCat: what I was saying was to rely mostly on your own language learning and not on tools
11:27:56 <ManateeLazyCat> Kaidelong: Including correct syntax error in real-time.
11:30:12 <gwern> zygoloid: the comments system is too heavy weight for copyediting; a wiki would be better
11:32:21 * ManateeLazyCat Currently, the best way to study English is at #haskell, sometimes i really can't understand some complicated words.
11:32:29 <hstefan> ManateeLazyCat: sorry to bother you again, but I have one last question: Is there anyway to set the spacing between the items shown in a treeView?
11:34:53 <jkingkong> hmmm, say I have a new "data" element, e.g. data foo = bar
11:35:04 <jkingkong> and I want to declare a newtype
11:35:20 <jkingkong> and say I want the newtype to be like (Int, [foo])
11:35:27 <jkingkong> this won't work because foo is not a type
11:35:34 <jkingkong> how does this work exactly
11:35:43 <soupdragon> jkingkong, data Foo = Bar you mean?
11:35:50 <jkingkong> yes
11:35:56 <mauke> Foo is a type
11:35:59 <soupdragon> newtype X = X (Int, [Foo])  does work
11:36:09 <jkingkong> huh
11:36:18 <jkingkong> let me try again maybe I'm misunderstanding the problem
11:37:11 <jkingkong> ok so say instead
11:37:31 <jkingkong> we have data Foo x y = ...(x, y)
11:37:38 <jkingkong> the data type has additional arguments
11:38:10 <jkingkong> so newtype X = X (Int, [Foo]) fails now with not enought type arguments
11:38:13 <jmcarthur> it would have to be something like this:  newtype X a b = X (Int, [Foo a b])
11:38:27 <jmcarthur> OR
11:38:38 <jmcarthur> newtype X = X (Int, [Foo String Double])
11:38:49 <jmcarthur> or some in-between
11:38:56 <jkingkong> It tells me that a and b in your example aren't in the scope
11:39:08 <jmcarthur> jkingkong: make sure the left hand side looks like mine
11:39:11 <jmcarthur> newtype X a b
11:39:45 <jkingkong> oh i see, it won't know they are type variables if you don't have that
11:39:55 <ManateeLazyCat> hstefan: Do you mean rows or columns?
11:40:16 <eevar> hmm... "cabal install gtk2hs-buildtools && cabal install gtk
11:40:17 <eevar> " -- shouldn't gtk2hs-buildtools be a dependency here?
11:40:34 <ManateeLazyCat> eevar: Because gtk2hs-buildtools is not library.
11:40:47 <ManateeLazyCat> eevar: gtk2hs-buildtools just execute tools.
11:40:58 <eevar> okies, thanks
11:41:00 <soupdragon> whats up frokes
11:41:13 <ManateeLazyCat> eevar: We have send request to Cabal team, i think this problem will fix in feature Cabal version
11:42:02 <hstefan> ManateeLazyCat: the space between rows.
11:42:06 <ManateeLazyCat> hstefan: If you want set spacing between columns, you can use treeViewColumnSetSpacing
11:42:38 <mux> is it proper/understandable to talk about the "disjoint k-subsets of a set" ?
11:42:49 <hstefan> ManateeLazyCat: it's not possible for rows?
11:42:57 <ManateeLazyCat> hstefan: Wait,
11:43:07 <Jafet> mux, what's a k-subset?
11:43:39 <soupdragon> *barf*
11:43:44 <mux> Jafet: this is probably incorrect naming; I mean to say all the ways to split a set into k disjoint subsets
11:44:03 <mux> Jafet: but I don't mean partitions, some elements of the set may be left untouched
11:44:04 <ManateeLazyCat> hstefan: Unfortunately, it's need "vertical-separator" style property that't haven't binding in gtk2hs-0.11
11:44:13 <nolsen01> Is there a webpage with a list of programs that are written in haskell?
11:44:19 <Jafet> "Untouched"?
11:44:19 <mux> ie, (1,2) is a "valid" disjoint subset pair for [1,2,3]
11:44:30 <mux> and 3 is discarded
11:44:37 <hstefan> ManateeLazyCat: ok then... :/
11:44:43 <BMeph> As in a subset with K elements?
11:44:49 <ManateeLazyCat> hstefan: It's possible, gtk2hs haven't binding any style property.
11:45:03 <mux> BMeph: no, k subsets
11:45:04 <ManateeLazyCat> hstefan: I will fix this in next version of gtk2hs.
11:45:13 <Jafet> That seems isomorphic to taking a k+1-partition.
11:45:30 <ManateeLazyCat> hstefan: But i have tips, if it's realy important to you, you can edit ~/.gtkrc-2.0
11:45:31 <Jafet> Give or take certain ordering constraints.
11:45:33 <BMeph> mux: I likly am remembering it wrongly, but I'd call that a k-way partition. :)
11:45:46 <hstefan> ManateeLazyCat: nah, it's not that important
11:46:14 <mux> Jafet: I should have said, k disjoint non-empty subsets
11:46:25 <hstefan> ManateeLazyCat: just for a cool layout. But thank you!
11:46:30 <Jafet> Non-empty partitions, then.
11:46:39 <mux> hmm
11:46:41 <Jafet> I sense you're trying to be difficult on purpose, so meh
11:46:59 <mux> I'm not, but I'm likely to have not understood this properly
11:47:19 <gwern> huh. Martin Gardner is dead
11:47:25 <gwern> I sort of thought he died a while ago
11:47:30 <ManateeLazyCat> hstefan: Default rows spacing is 2
11:48:15 <mux> Jafet: if I take the k+1 non-empty partitions, I miss all the solutions where the "extra group" of elements is itself empty, which it can
11:48:20 <hstefan> ManateeLazyCat: thank you, its useful for setting the treeView size correctly
11:48:50 <ManateeLazyCat> hstefan: What's you need? Calculate treeView size?
11:49:01 <mux> Jafet: I'm really not trying to be difficult on purpose, I want to find a proper way to name this function, which I may have implemented stupidly
11:49:25 <Jafet> mux, then add k+1 non-empty partitions with k non-empty partitions
11:49:27 <soupdragon> http://www.reddit.com/r/programming/comments/c89n9/a_short_introduction_to_coq/
11:49:29 <soupdragon> 50 replies??
11:49:32 <soupdragon> what the fuq?
11:49:41 <Jafet> Welcome to reddit
11:49:41 <mux> Jafet: the function is already written
11:49:43 <ManateeLazyCat> hstefan: If you want get cell size that include spacing between rows, use treeViewGetBackgroundArea
11:50:05 <ManateeLazyCat> hstefan: If you want get cell size *not* include spacing between rows, use treeViewGetCellArea
11:50:28 <hstefan> ManateeLazyCat: already did it. I was talking about the fixed height of the treeView. Just to know, are you a gtk2hs developer?
11:50:37 <ManateeLazyCat> hstefan: Yes.
11:50:49 <Jafet> mux, I couldn't name a black ghetto baby, so I can't comment on that.
11:51:04 <hstefan> ManateeLazyCat: thats nice! You're doing a great work there.
11:51:10 <ManateeLazyCat> hstefan: I know have many question about gtk2hs recently, so i login at here to answer questions.
11:51:22 <mux> Jafet: the problem I had with the approach you suggested, is that it is not obvious which of the k+1 group to remove after one took the k+1 non-empty partitions
11:51:42 <ManateeLazyCat> hstefan: Axel is the true hero, i'm just help him.
11:51:47 <mux> Jafet: so my implementation uses combinations and non-empty k-partitions algorithms
11:51:48 <soupdragon> @let units = iterate ((+1).(*10)) 1
11:51:49 <lambdabot>  Defined.
11:51:54 <soupdragon> > map (`mod`4) units
11:51:54 <lambdabot>   [1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
11:52:05 <soupdragon> > map (`mod`4) . map (^2) $ [1..]
11:52:06 <lambdabot>   [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,...
11:52:36 <ManateeLazyCat> hstefan: This need some trick to calculate TreeView height: TreeViewHeight = TreeViewHeaderHeight + Rows * RowHeight.
11:52:47 <ManateeLazyCat> hstefan: RowHeight is from treeViewGetBackgroundArea.
11:53:02 * ManateeLazyCat pasted "treeViewGetHeaderHeight" at http://paste2.org/get/852566
11:53:12 <ManateeLazyCat> Above function calculate header height.
11:53:18 <Kaidelong> :t do { cells <- (sepBy cell comma); newline; return cells }
11:53:20 <lambdabot> Not in scope: `sepBy'
11:53:20 <lambdabot> Not in scope: `cell'
11:53:20 <lambdabot> Not in scope: `newline'
11:53:37 <Kaidelong> great, parsec related monad, no type annotation
11:54:00 <aristid> > units
11:54:01 <lambdabot>   [1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,111111111...
11:54:13 <mauke> (?cell :: Parser a) => Parser [a]
11:54:18 <soupdragon> > map (^2) units
11:54:18 <lambdabot>   [1,121,12321,1234321,123454321,12345654321,1234567654321,123456787654321,12...
11:54:23 <Jafet> > map isPrime units
11:54:24 <lambdabot>   Not in scope: `isPrime'
11:54:29 <aristid> @let units' b = iterate ((+1).(*b)) 1
11:54:30 <lambdabot>  Defined.
11:54:36 <aristid> > units' 2
11:54:37 <lambdabot>   [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,26...
11:54:49 <Jafet> They're actually called repunits
11:55:00 * ManateeLazyCat pasted "TreeView library" at http://paste2.org/get/852568
11:55:03 <xerox> ?. oeis run units' 2
11:55:04 <lambdabot>  Sequence not found.
11:55:17 <aristid> > map (+1) (units' 2)
11:55:18 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
11:55:23 <ManateeLazyCat> hstefan: http://paste2.org/get/852568 is ModeView library of my project, enjoy!
11:55:27 <soupdragon> > units 3
11:55:27 <aristid> > map (+1) (units' 10)
11:55:27 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
11:55:28 <lambdabot>   [2,12,112,1112,11112,111112,1111112,11111112,111111112,1111111112,111111111...
11:55:30 <soupdragon> > units' 9
11:55:30 <mauke> spitrune
11:55:31 <lambdabot>   [1,10,91,820,7381,66430,597871,5380840,48427561,435848050,3922632451,353036...
11:55:32 <soupdragon> > units' 3
11:55:33 <lambdabot>   [1,4,13,40,121,364,1093,3280,9841,29524,88573,265720,797161,2391484,7174453...
11:55:38 <Jafet> @oeis 1 3 7 15 31 63
11:55:39 <lambdabot>  2^n - 1. (Sometimes called Mersenne numbers, although that name is usually r...
11:55:39 <lambdabot>  [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,2...
11:55:54 <soupdragon> @oies 1,7,17
11:55:54 <lambdabot>  Triangular array T read by rows: T(n,0)=T(n,n)=1 for n >= 0; for n >= 2 and ...
11:55:54 <lambdabot>  [1,1,1,1,3,1,1,4,4,1,1,6,11,5,1,1,7,17,16,6,1,1,9,30,44,22,7,1,1,10,39,74,66...
11:55:59 <gwern> repunits? that name stinks (is pungent) & sounds like a name worthy of punishment
11:56:02 <ManateeLazyCat> hstefan: If you interest TreeView, http://paste2.org/get/852568 will save your time.
11:56:02 <soupdragon> @oies 7,17
11:56:03 <lambdabot>  Largest prime dividing n (with a(1)=1).
11:56:03 <lambdabot>  [1,2,3,2,5,3,7,2,3,5,11,3,13,7,5,2,17,3,19,5,7,11,23,3,5,13,3,7,29,5,31,2,11...
11:56:10 <aristid> @oies 1,11,111,1111
11:56:11 <lambdabot>  Repunits: (10^n - 1)/9. Often denoted by R_n.
11:56:11 <lambdabot>  [0,1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,11111111...
11:56:14 <soupdragon> insufficent data for a meaningful answer :(
11:56:20 <Kaidelong> how do I turn off Leksah's annoying "always on top" behavior?
11:56:29 <ManateeLazyCat> Oh, god, can't we split lambdabot out from #haskell ?
11:56:32 <Jafet> @. oeis run init.tail.show $ units' 2
11:56:33 <lambdabot>  Sequence not found.
11:57:22 * ManateeLazyCat lambdabot is biggest spammer sometimes.
11:57:53 <Jafet> It's our collective spammer
11:58:05 <ManateeLazyCat> hstefan: Any question?
11:58:57 <gwern> ManateeLazyCat: we just need a social norm of taking things to privmsg
11:59:11 <Twey> The answer to my earlier question was {-# LANGUAGE OverloadedStrings #-}, FWIW.
11:59:46 <ManateeLazyCat> gwern: Can make lambdabot accept "/query" ?
11:59:54 <Jafet> It does
12:01:03 <ManateeLazyCat> hstefan: If have any problem, please send to gtk2hs list, we will help you. I need reading FRP now. :)
12:01:34 <mux> is GHC able to something like (sum xs, length xs) into a single foldr automatically?
12:01:34 <hstefan> ManateeLazyCat: humm. the last one is just about  the scrolling. I've created a "tViewWindow <- scrolledWindowNew Nothing Nothing" and added the treeView at it but I can't scroll the items on it.
12:01:42 <mux> to transform
12:02:08 <hstefan> ManateeLazyCat:  gtk2hs list? FRP?
12:02:19 <mauke> do we have a library for size annotated lists?
12:02:26 <ManateeLazyCat> hstefan: No, i just interested FRP.
12:02:50 <ManateeLazyCat> gtk2hs-users@lists.sourceforge.net>
12:03:13 <ManateeLazyCat> gtk2hs-devel@lists.sourceforge.net for gtk2hs developers.
12:03:33 <BMeph> mux: I don't think so. To transform things, GHC needs the transformed function to be outermost. :)
12:03:37 <ManateeLazyCat> Send general question to gtk2hs-users@lists.sourceforge.net is okay.
12:03:42 <hstefan> ManateeLazyCat: I was just asking what's that heh
12:03:46 <gwern> ManateeLazyCat: lambdabot accepts any priv messages, like '/msg lambdabot @quote'
12:04:07 <gwern> ManateeLazyCat: most IRC clients then create a private channel and you can then just do '@quote' like n #haskell
12:04:35 <mauke> data NList a = NList !Int [a]
12:04:40 <ManateeLazyCat> gwern: If we not help others, just test some code, we should /query lambdabot, right?
12:04:54 <mauke> fromList xs = NList (length xs) xs
12:04:55 <ManateeLazyCat> gwern: Sometimes, lambdabot flood all channel.
12:05:00 <gwern> dunno, how does /query differ from /msg?
12:05:02 <mauke> toList (NList n xs) = take n xs
12:05:16 <gwern> mauke: why not just use Seq which is doing much the same thing internally
12:05:32 <Jafet> gwern, /query is purely client side, opens a new window, frame or whatever
12:05:38 <mauke> well, Seq is more complicated
12:05:49 <gwern> mauke: also, why is toList not just 'toList (NList _ xs) = xs'? do you not trust the length?
12:06:06 <mauke> gwern: I want O(1) take/init
12:06:07 <gwern> Seq is also already written & debugged :)
12:06:32 <mauke> take m (NList n xs) = NList (min m n) xs
12:07:10 <ManateeLazyCat> hstefan: You should add "scrolledWindowSetPolicy tViewWndow PolicyNever PolicyAlways"
12:07:20 <applicative> ManateeLazyCat, the only trouble is that lambdabot is so much more interesting than human beings.
12:08:15 <gwern> mauke: take isn't very slow on seq
12:08:20 <gwern> 'O(log(min(i,n-i))). The first i elements of a sequence.'
12:08:40 <gwern> so log of how much you want
12:09:37 <mauke> cons x (NList n xs) = NList (succ n) (x : xs)
12:09:53 <hstefan> ManateeLazyCat: like this?
12:09:56 <hstefan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25727#a25727
12:10:02 <gwern> succ? do we actually have that?
12:10:05 <gwern> @Hoogle succ
12:10:06 <lambdabot> Maybe you meant: google hoogle
12:10:08 <gwern> @hoogle succ
12:10:08 <lambdabot> Prelude succ :: Enum a => a -> a
12:10:08 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap succFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
12:10:08 <lambdabot> System.Exit ExitSuccess :: ExitCode
12:10:31 * gwern writes n+1 and is happy with it
12:11:36 <mauke> uncons z f (Nlist n xs) | n <= 0 = z | otherwise = f (head xs) (tail xs)
12:12:18 <ManateeLazyCat> hstefan: NO
12:12:45 <ManateeLazyCat> Is "containerAdd treeBox tViewWindow" , not "containerAdd tViewWindow treeBox"
12:12:55 <nolsen01> I don't understand what a side effect is.
12:13:15 <Botje> nolsen01: writing files, launching missiles, calling your mother, ...
12:13:20 <Botje> something you can't undo easily.
12:13:28 <nolsen01> lol
12:13:30 <gwern> saying you were never wanted
12:13:49 <ManateeLazyCat> hstefan: And boxPackStart treeBox tViewWindow PackNatural 5
12:13:57 <hstefan> ManateeLazyCat: dammit >_>
12:14:15 <ManateeLazyCat> hstefan: I think you want Box -> ScrolledWindow -> TreeView, right?
12:14:28 <hstefan> yeah.
12:14:54 <nolsen01> I think I understand
12:15:46 <ManateeLazyCat> hstefan: "boxPackStart treeBox tViewWindow PackNatural 5" and "containerAdd tViewWindow treeView"
12:20:34 <hstefan> ManateeLazyCat: I got lost >_>
12:21:03 <ManateeLazyCat> hstefan: Do you developing GTK+ code before?
12:21:40 <hstefan> ManateeLazyCat: nope
12:23:09 <ManateeLazyCat> http://www.muitovar.com/gtk2hs/index.html
12:24:16 <ManateeLazyCat> hstefan: http://library.gnome.org/devel/gtk-tutorial/stable/ this is complete one.
12:24:59 <siracusa> hstefan: There's also a GUI design software called Glade, that writes XML files describing the GUI. You may find it easier to design your GUIs with that.
12:25:08 <hstefan> ManateeLazyCat: dude, I'm really thankfull but I just need the basics for a college homework...
12:25:11 <tag> Can someone explain to me what I seem to be failing to understand about haskell's syntax? http://codepad.org/caZck0tc
12:25:43 <mauke> tag: you can't just put an equation in the middle of a do block
12:25:49 <ManateeLazyCat> siracusa: I don't recommend newbie use Glade study gtk2hs, they're can't understand principle.
12:25:55 <opqdonut> tag: let nums = ...
12:25:58 <Twey> Equations only exist in the top-level, or in where or let clauses
12:26:02 <jmcarthur> tag: lose the type signature and say "let num =" instead of just "num ="
12:26:12 <mauke> no need to remove the type signature
12:26:18 <Twey> You don't have to lose the type signature.
12:26:21 <Twey> If you don't want to.
12:26:25 <jkingkong> when you declare something like a = f b c and it complains that there is "No instance for `insert type expected of b`" arising from use of `f`
12:26:28 <mauke> well, it's wrong
12:26:28 <jmcarthur> sure, but it's the easier explanation
12:26:31 <Twey> It does have to go inside the let, though.
12:26:32 <mauke> but in principle
12:26:33 <ManateeLazyCat> hstefan: Nevermind, study basic knowledge first, gtk2hs is easier to understand than other language binding.
12:26:35 <jkingkong> what exactly does that error message mean
12:26:41 <Twey> Yeah
12:26:58 <mauke> tag: print . show is also weird
12:27:05 <mauke> @src print
12:27:05 <lambdabot> print x = putStrLn (show x)
12:27:22 <tag> mauke: I hadn't attacked that one yet, I was working from the top down. :-)
12:27:38 <mauke> good choice
12:27:41 <aristid> @. pl src print
12:27:41 <lambdabot> (line 1, column 1):
12:27:41 <lambdabot> unexpected end of input
12:27:41 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:27:43 <tag> okay I now understand, what I'm actually trying to say is "let nums = map read args :: [Integer]"
12:27:45 <ManateeLazyCat> hstefan: I reommand you read http://www.muitovar.com/gtk2hs/index.html first.
12:27:53 <jkingkong> hmm when i do something like a = f (b::x) c it works, where x is an instance of the type of b
12:27:57 <tag> Which happens to also be more terse.
12:28:14 <aristid> @pl print x = putStrLn (show x)
12:28:14 <lambdabot> print = putStrLn . show
12:28:15 <mauke> tag: or let {nums :: [Integer]; nums = map read args}
12:28:16 <jkingkong> why can't it infer what it is based on b?
12:28:18 <hstefan> ManateeLazyCat: ok, thanks
12:28:33 <tag> understood
12:28:35 <mauke> tag: where the { ; } can be replaced by indentation/newlines, as usual
12:28:39 <tag> right
12:28:39 <ManateeLazyCat> hstefan: And read http://library.gnome.org/devel/gtk-tutorial/stable/ , try to use gtk2hs write those C code
12:29:07 <ManateeLazyCat> hstefan: http://code.haskell.org/gtk2hs/gtk/demo/ have many demo code can study.
12:30:43 <jmcarthur> tag: i forked it and made a concise version if you want to see it, but i won't link it if you'd rather work on it yourself
12:31:13 <jmcarthur> well, actually, just don't click it if you don't want to see it ;) http://codepad.org/eYu2Ny8V
12:33:03 <sepp2k1> Am I correct in thinking that without scoped type variables there are functions that can be written and compiled, but not explicitly given a type? And that with scoped type variables there are no such functions anymore? Also are there any functions that can only be compiled with scoped typed variables?
12:33:21 <sepp2k1> (sorry if I just sent this twice - I got disconnected in between)
12:35:50 <aristid> @src (->) return
12:35:50 <lambdabot> return = const
12:35:56 <aristid> @src (->) (>>=)
12:35:57 <lambdabot> f >>= k = \ r -> k (f r) r
12:36:33 <aristid> @pl x f k r = k (f r) r
12:36:33 <lambdabot> x = flip flip id . (ap .) . flip (.)
12:36:38 <tag> jmcarthur: what's the definition of =<< ?
12:36:56 <aristid> @src (=<<)
12:36:57 <lambdabot> f =<< x = x >>= f
12:37:03 <ManateeLazyCat> Bye all, 03:36 am in China, need to sleep....
12:37:18 <aristid> @. pl src (=<<)
12:37:19 <lambdabot> (line 1, column 1):
12:37:19 <lambdabot> unexpected end of input
12:37:19 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:37:21 <aristid> :(
12:37:39 <tag> :-)
12:39:38 <aristid> @pl f =<< x = x >>= f
12:39:39 <lambdabot> (line 1, column 9):
12:39:39 <lambdabot> unexpected "="
12:39:39 <lambdabot> expecting variable, "(", operator, "=<<", ">>>", "^>>", "^<<", ">>", ">>=" or end of input
12:39:49 <aristid> @pl z f x = x >>= f
12:39:50 <lambdabot> z = (=<<)
12:39:56 <aristid> heh.
12:42:03 <siracusa> Why does GHCi take so much CPU when being idle? It's sometimes very low and sometimes extremely high.
12:42:41 <tibbe> ttuegel: ping
12:42:53 <ttuegel> yes?
12:44:40 <Saizan> sepp2k1: 1) yes for locally defined functions, 2) i think so 3) depends, you can generally start using `asTypeOf` and similar to get the same effect of scoped type variables so if you allow such modifications then no
12:45:58 <sepp2k> Saizan: thanks
12:46:15 <jkingkong> question, suppose there is a module with function foo say that is in the prelude and bar that isn't in the prelude. Then, to use the first function, I need to import it as a qualified module. But then, I need to prepend bar with an X.bar each time. Is there a way around this?
12:46:25 <gwern> siracusa: it might be GC. idle-time GC can be very inefficient
12:46:37 <jkingkong> can I import it both as a qualified and unqualified module, basically
12:46:41 <gwern> fortunately you can disable it with +RTS -I0 -RTS I think
12:47:11 <gwern> jkingkong: I think you can; import qualified Quux (foo) as Q; import Quux (bar)
12:47:21 <gwern> 'Q.foo bar' etc
12:48:19 <siracusa> gwern: Great, down to zero! Thanks :-)
12:48:38 <gwern> the things one learns working on gitit
12:49:59 <jkingkong> gwern: ah that looks good
12:50:26 <gwern> jkingkong: personally, I think I would prefer to import the Prelude hiding the offending function
12:50:37 <gwern> (but the right thing is context dependent)
12:51:16 <tag> Okay, how do I construct a statement which says "a = a + b" and execute that for each element in an array as b (a not being in the array)?
12:51:34 <jkingkong> gwern: ok how do you hide the offending function, this seems like the better solution for me
12:51:42 <gwern> import Prelude hiding (foo)
12:51:44 <gwern> iirc
12:51:52 <xerox> tag: can you retry, in english=?
12:51:52 <jkingkong> gwern: ah, never saw that before, thanks
12:52:21 <gwern> jkingkong: import statements can be suprisignly complex and capable
12:52:29 <arw> > map (+ 4) [1, 2, 4, 5]
12:52:30 <lambdabot>   [5,6,8,9]
12:52:49 <arw> tag: if that is what you meant
12:53:44 <tag> Allow me to clarify (simplify).  If this were perl, I would write $total += $_ for @array;  If this were C, I'd write for (i = 0; i < length; i++) { total += array[i] }  And so forth.
12:54:03 <gwern> tag: oh, you want a fold over the list to sum all entries?
12:54:11 <arw> tag: ah. thats called a 'fold'
12:54:26 <gwern> @quote emission
12:54:26 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
12:54:39 <jmcarthur> > foldl (+) 0 [1..5]
12:54:40 <lambdabot>   15
12:54:45 <jmcarthur> > sum [1..5]
12:54:46 <lambdabot>   15
12:54:54 <gwern> @src sum
12:54:54 <lambdabot> sum = foldl (+) 0
12:55:14 <gwern> what typeclass are folds linked to? Foldable?
12:55:26 <arw> no. just lists
12:55:29 <arw> :t foldl
12:55:30 <tag> And foldr is the converse of foldl
12:55:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:55:32 <tag> ?
12:55:35 <c_wraith> gwern, for generalized folds, yes
12:55:42 <jmcarthur> tag: different associativity
12:55:50 <gwern> well, I'm sure any decent array would implement Foldable...
12:55:52 <jmcarthur> > foldl f z [a,b,c,d]
12:55:53 <lambdabot>   f (f (f (f z a) b) c) d
12:55:55 <jmcarthur> > foldr f z [a,b,c,d]
12:55:55 <lambdabot>   f a (f b (f c (f d z)))
12:56:02 <tag> Oh
12:56:11 <tag> Right
12:56:17 <scree> :t Data.Foldable.foldl
12:56:18 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> a) -> a -> t b -> a
12:56:34 <c_wraith> tag: in general, you want to use foldl when you're doing some operation with an accumulator, and you want to use foldr if you're processing a list into another lazy structure
12:57:00 <c_wraith> tag: and furthermore, you usually want foldl' instead of foldl, but the reasons for that are kind of subtle.
12:57:21 <lispy> another way to think of it: foldl is for finite things where the result is smaller, and foldr is for infinite things
12:57:30 <arw> does lambdabot do benchmarks?
12:57:32 <vitka> By the way, why foldl/foldl' is bad when result is lazy?
12:57:40 <lispy> arw: I don't think so.  What do you mean?
12:57:52 <vitka> I've heard that before, but I forgot the explanation.
12:58:00 <c_wraith> vitka: foldl will blow up the stack if compiled without optimizations, on large inputs.
12:58:04 <arw> lispy: something like :time foldl' (+) 0 [1..200000]
12:58:15 <vitka> Ah.
12:58:37 <arw> vitka: and foldl' ist strict, so it will force the evaluation even if its not necessary
12:58:45 <vitka> But foldl' won't. The explanation was something about strictness.
12:58:49 <arw> vitka: which kind of defeats the purpose of lazy
12:58:53 <vitka> Oh right.
12:58:58 * hackagebot async 1.0 - Asynchronous Computations  http://hackage.haskell.org/package/async-1.0 (PeterSimons)
12:59:17 <lispy> arw: No it doesn't, but it also wouldn't be that useful at the moment.  The CPU load of the machine it's on varies and the amount of CPU time that lambdabot gets is already so small you'd need a lot of quick things to get any meaningful benchmark info
12:59:20 <byorgey> preflex: seen fryguybob
12:59:20 <preflex>  fryguybob was last seen on #haskell 2 hours, 45 minutes and 23 seconds ago, saying: @tell byorgey I'm trying to build the new diagrams stuff, where do I get vector-space 0.7?
12:59:20 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
12:59:33 <fryguybob> Hey
13:00:09 <gwern> lispy: plus all the extra stuff mueval does screws up any timing - I mean, the 2 process invocations alone might overwhelm an order or two of difference
13:00:11 <byorgey> fryguybob: I had to patch vector-space a bit to get what I wanted to do to work, you can get the patched repo from  http://code.haskell.org/~byorgey/code/vector-space
13:00:30 <fryguybob> byorgey: Ok
13:00:42 <byorgey> fryguybob: hopefully the patch, or some variant of it, will eventually make its way into an official release of vector-space
13:00:49 <lispy> gwern: oh good point
13:01:28 <rajeshsr> is there a way to cycle a sequence with length 3..
13:01:31 <rajeshsr> that is:
13:01:31 <gwern> safe, fast, working - choose 2 for mueval :)
13:01:39 <rajeshsr> 1,2,3,4,5,6,7
13:01:58 <rajeshsr> (1,2,3),(2,3,4),(3,4,5)..
13:01:58 <lispy> gwern: safe and working are the important ones to me :)
13:02:11 <rajeshsr> is a cycling with length 3
13:02:20 <byorgey> rajeshsr: map (take 3) . tails  gets you most of the way there
13:02:26 <rajeshsr> something like Fibonacci, generalized
13:02:39 <byorgey> you may want to also throw away the shorter pieces that generates at the end
13:02:42 <soupdragon> hi byorgey
13:02:50 <byorgey> > map (take 3) . tails $ [1,2,3,4,5]
13:02:51 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
13:02:56 <byorgey> hi soupdragon
13:03:00 <gwern> rajeshsr: I suppose you could use the list monad to generate all permutations, then map (take 3), and then 'nub' it
13:03:03 <lispy> rajeshsr: well, I'd use a zip
13:03:14 <lispy> (I think anyway)
13:03:29 <rajeshsr> :t tails
13:03:30 <lambdabot> forall a. [a] -> [[a]]
13:03:36 <fryguybob> byorgey: I'm excited about diagrams, wish I could have been at Haq-\phi.  I'll let you know if the patched vector-space works for me.
13:03:39 <rajeshsr> tails [1..5]
13:03:42 <rajeshsr> > tails [1..5]
13:03:43 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
13:03:54 <byorgey> fryguybob: awesome.  I'm excited about it too. =)
13:04:01 <rajeshsr> wow!! thanks byorgey
13:04:01 <jmcarthur> what's new in diagrams?
13:04:10 <lispy> > (\x -> zip3 x (tail x) (tail (tail x)) [1..5]
13:04:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:04:23 <lispy> :t zip3
13:04:24 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
13:04:38 <lispy> Fixing my typo is an exercise for the reader
13:04:48 <gwern> @hoogle permutations
13:04:48 <lambdabot> Data.List permutations :: [a] -> [[a]]
13:04:53 <rajeshsr> lispy, thats a bit big! I guess byorgey solution is good for arbitrary "K" cycling i asked
13:05:08 <gwern> > nub $ map (take 3) $ permutations [1..4]
13:05:09 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[4,3,2],[3,4,2],[3,2,4],[4...
13:05:16 <gwern> > nub $ map (take 2) $ permutations [1..3]
13:05:17 <lambdabot>   [[1,2],[2,1],[3,2],[2,3],[3,1],[1,3]]
13:05:22 <gwern> looks good to me
13:05:28 <rajeshsr> gwern, we don't need all permutations...
13:05:45 <lispy> rajeshsr: yeah, and I don't think mine works the way I want
13:05:45 <gwern> but that isn't all permutations. note the take and nub
13:05:46 <byorgey> jmcarthur: the redesigned version is just getting off the ground, but so far the headlines are much simpler/more elegant semantics, modular rendering backends, polymorphic over the underlying vector space (R^2, R^3, R^4?, T -> R^3 ???), and named points/references
13:05:49 <tag> So I don't really understand what's going on there.  How does take 3 get to take 3?
13:06:00 <tag> :t take
13:06:01 <lambdabot> forall a. Int -> [a] -> [a]
13:06:06 <jmcarthur> awesome!
13:06:09 <gwern> tag: partial application
13:06:14 <lispy> ?src take
13:06:14 <lambdabot> take n _      | n <= 0 =  []
13:06:14 <lambdabot> take _ []              =  []
13:06:14 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:06:16 <gwern> > nub $ map (\x -> take 2 x) $ permutations [1..3]
13:06:16 <lambdabot>   [[1,2],[2,1],[3,2],[2,3],[3,1],[1,3]]
13:06:35 <rajeshsr> @src nub
13:06:35 <lambdabot> nub = nubBy (==)
13:06:45 <fryguybob> byorgey: I had just written a silly Postscript output for a plotting program that I'm working on when I came across diagrams and now would like to use that instead.
13:06:50 <gwern> rajeshsr: nub = unix's '
13:06:50 <rajeshsr> @src nubBy
13:06:50 <lambdabot> nubBy eq []             =  []
13:06:50 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:06:52 <gwern> uniq
13:06:53 <tag> > map (take 2) [1,2,3]
13:06:54 <lambdabot>   No instance for (GHC.Num.Num [a])
13:06:54 <lambdabot>    arising from a use of `e_12123' at <in...
13:06:58 <rajeshsr> gwern, oh, ok!
13:07:03 <gwern> tag: note permutations's type sig
13:07:13 <tag> :t permutations
13:07:13 <lambdabot> forall a. [a] -> [[a]]
13:07:22 <tag> I see, it's a list of lists.
13:07:29 <gwern> a list of possible permutations
13:07:44 <tag> I see, what's the significance of the grouping expression? ($)
13:07:45 <byorgey> so  map (take 3) applies (take 3) to each list
13:07:58 <gwern> tag: replaces parens
13:07:58 <tag> right
13:08:06 <gwern> > nub (map (\x -> take 2 x) $ permutations [1..3])
13:08:06 <lambdabot>   [[1,2],[2,1],[3,2],[2,3],[3,1],[1,3]]
13:08:11 <gwern> > nub (map (\x -> take 2 x) (permutations [1..3]))
13:08:11 <lambdabot>   [[1,2],[2,1],[3,2],[2,3],[3,1],[1,3]]
13:08:14 <tag> > take 2 [1,2,3,4]
13:08:15 <lambdabot>   [1,2]
13:08:17 <tag> gotcha
13:08:19 <tag> okay
13:08:30 <byorgey> fryguybob: well, you won't be able to use the new version yet, but contributions are welcome =)
13:08:41 <byorgey> fryguybob: you may also want to look at the older version already released on Hackage
13:08:43 <gwern> rajeshsr: do you have your solution yet?
13:09:00 <rajeshsr> gwern, yeah! using byorgey idea
13:09:03 <byorgey> fryguybob: it isn't perfect -- hence the redesign -- but it does actually work!
13:09:17 <tag> gwern: so $ is just another way to arbitrate precedence?
13:09:23 <gwern> rajeshsr: the 'tails' stuff? is that even correct?
13:09:31 <rajeshsr> byorgey, actually mine is an infinite list!
13:09:33 <gwern> tag: yep
13:09:37 <rajeshsr> think so..
13:09:39 <tag> Okay!
13:09:58 <tag> What's the significance of function composition in the tails example?
13:10:01 <gwern> tag: $, (), and . are common sticking points
13:10:04 <byorgey> rajeshsr: oh, then in that case you don't need to worry about shorter bits at the end, nice =)
13:10:06 <tag> .
13:10:08 <fryguybob> byorgey: Yeah, I'm moving pretty slow on my project right now so I figured the new version should be find :D.
13:10:15 <tag> what's the difference then between $, (), and . semantically?
13:10:17 <byorgey> fryguybob: ok =)
13:10:31 <fryguybob> byorgey: I'm converting my old version to haskell: http://unpretentiousness.blogspot.com/2010/02/latex-grapher.html
13:10:33 <xerox> tag: they all talk about the same thing, but they are different
13:10:33 <gwern> tag: I'm glad you asked! I'm sure someone else will be thrilled to tell you
13:10:45 <lispy> tag: $ and . are both normal functions
13:10:49 <xerox> tag: $ is not (), and . is composition, so none of those.
13:11:14 <lispy> tag: $ is actually just an infix identity function (id) with slightly restricted type
13:11:20 <lispy> :t ($)
13:11:20 <lambdabot> forall a b. (a -> b) -> a -> b
13:11:24 <byorgey> fryguybob: hey, those are some nice looking graphs =)
13:11:24 <uorygl> > let apx x a b c d = let (e,f) = (a+c,b+d) in (e,f) : if e/f > x then apx x a b e f else apx x e f c d in apx (sqrt 2) 1 1 2 1
13:11:26 <lambdabot>   [(3.0,2.0),(4.0,3.0),(7.0,5.0),(10.0,7.0),(17.0,12.0),(24.0,17.0),(41.0,29....
13:11:35 <pikhq> tag: () is a literal value of type () and a null type. :)
13:11:41 <lispy> that type, (a -> b) -> a -> b is the same as (a -> b) -> (a -> b)
13:11:46 <fryguybob> byorgey: Thanks!  My wife is a math professor, so there won't be pressure to get more done until next semester starts :D.
13:11:50 <byorgey> fryguybob: yes, I think diagrams should be a perfect backend for your project
13:12:22 <lispy> tag: so if id :: c -> c, then let c = a -> b, and bam you have ($)
13:12:25 <rajeshsr> @hoogle tails
13:12:25 <lambdabot> Data.ByteString tails :: ByteString -> [ByteString]
13:12:25 <lambdabot> Data.List tails :: [a] -> [[a]]
13:12:25 <lambdabot> Data.ByteString.Char8 tails :: ByteString -> [ByteString]
13:12:43 <byorgey> fryguybob: hehe, I see.  well, I also want to use it for a class I'm teaching in the fall so I'm motivated to get it up to speed by then too. =)
13:12:50 <gwern> rajeshsr: actually we can test this. what is your tails version?
13:12:58 * lispy hopes that makes sense
13:13:05 <uorygl> > let apx x a b c d = let (e,f) = (a+c,b+d) in (e,f) : if e/f > x then apx x a b e f else apx x e f c d in map (\(e,f) -> f*(sqrt 2 - e/f)) $ apx (sqrt 2) 1 1 2 1
13:13:06 <lambdabot>   [-0.1715728752538097,0.24264068711928566,7.106781186547617e-2,-0.1005050633...
13:13:08 <fryguybob> byorgey: Excellent.
13:13:20 <rajeshsr> gwern, 6.12.1
13:13:26 * gwern meant the code
13:15:30 <uorygl> Does GHCi come with CReal?
13:15:48 <gwern> uorygl: creal should come with ghci yes
13:15:54 <uorygl> Where is it?
13:16:01 <gwern> @hoogle CReal
13:16:01 <lambdabot> No results found
13:16:13 <gwern> hm?
13:16:26 <byorgey> fryguybob: if you like, you're welcome to subscribe to the diagrams mailing list, http://projects.haskell.org/cgi-bin/mailman/listinfo/diagrams
13:16:43 <gwern> @hoogle Data.Number.CReal
13:16:44 <lambdabot> No results found
13:17:15 <gwern> > (1.0 :: CReal)
13:17:16 <lambdabot>   1.0
13:17:17 <fryguybob> byorgey: Will do.
13:18:06 <rajeshsr> > let hg x = let st = (replicate (pred x) 0) ++ [1] ++ (map (sum . take x) . tails $ st) in st in take 10 $ hg 3
13:18:07 <lambdabot>   [0,0,1,1,2,4,7,13,24,44]
13:18:07 <tag> lispy: I more or less understand your explanation to the point of definition, but I can't really say I understand the implications.
13:18:16 <rajeshsr> my higher order fibonacci! :)
13:18:17 <gwern> uorygl: http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
13:18:21 <rajeshsr> so elegant with haskell!
13:18:22 <gwern> I guess it doesn't come with ghc
13:18:42 <gwern> rajeshsr: that's pretty weird
13:19:03 <rajeshsr> gwern, why?!
13:19:07 <lispy> tag: it's just that ($) is the identity function for functions.  So that makes it suitable as a place holder for function application.  You could just as easily use `id` instead.
13:19:17 <gwern> rajeshsr: most people would write fib differently
13:19:34 <rajeshsr> oh, well this is a generalized fibonacci
13:19:35 <gwern> rajeshsr: also some of those parens are unncessary I think
13:19:41 <lispy> tag: all other implications are a result of it being an operator (and hence infix, right associative in this case)
13:19:54 <gwern> rajeshsr: also, a double-let? reall?
13:20:04 <rajeshsr> thats for gchi!
13:20:13 <gwern> excuses
13:20:49 <rajeshsr> ha, well, the second let is for execution
13:20:57 <rajeshsr> first let makes the definition
13:21:28 <lispy> > fix $ \fib -> zipWith (+) fib (tail fib) -- another way to write fib :)
13:21:32 <lambdabot>   mueval-core: Time limit exceeded
13:21:42 <lispy> hehe, no base case
13:21:42 <dolio> Apparently it isn't. :)
13:21:58 <lispy> > fix $ \fib -> 0 : 1 : zipWith (+) fib (tail fib)
13:21:58 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:22:04 <lispy> Not let required!
13:22:22 <dolio> > fix $ (0:) . scanl (+) 1
13:22:23 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:22:29 <gwern> @quote zip.*tail
13:22:29 <lambdabot> edwardk says: zip. iterate . take .  intersect . find nub . lookup . tail . intercalate . transpose. reverse . unzip
13:22:36 <lispy> mmm...scanl, yes that is succinct
13:22:37 <gwern> @quote zip.*tail
13:22:37 <lambdabot> edwardk says: zip. iterate . take .  intersect . find nub . lookup . tail . intercalate . transpose. reverse . unzip
13:22:41 <gwern> what the
13:22:43 <gwern> @quote aztec
13:22:43 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
13:22:52 <lispy> :t zip. iterate . take .  intersect . find nub . lookup . tail . intercalate . transpose. reverse . unzip
13:22:52 <lambdabot>     Couldn't match expected type `[a]'
13:22:53 <lambdabot>            against inferred type `a1 -> [a1]'
13:22:53 <lambdabot>     In the first argument of `(.)', namely `iterate'
13:22:55 <lispy> :(
13:23:01 <Baughn> @type zip `ap` tail
13:23:02 <lambdabot> forall b. [b] -> [(b, b)]
13:23:08 <rajeshsr> what does fix do?
13:23:10 <aristid> @free foldl
13:23:11 <Baughn> > (zip `ap` tail) [1..10]
13:23:11 <lambdabot> (forall x. f . h x = k (f x) . g) => f . foldl h y = foldl k (f y) . $map g
13:23:12 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
13:23:25 <lispy> rajeshsr: fix is Y combinator, it's recursion
13:23:29 <Peaker> rajeshsr, fix f = f (fix f)
13:23:31 <lispy> ?src fix
13:23:31 <lambdabot> fix f = let x = f x in x
13:23:45 <rajeshsr> @hoogle fix
13:23:46 <lambdabot> Data.Function fix :: (a -> a) -> a
13:23:46 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
13:23:46 <lambdabot> module Control.Monad.Fix
13:23:54 <Baughn> rajeshsr: Feeds the snake on its own tail
13:24:04 <rajeshsr> ha, ok!
13:24:12 <lispy> :t \fix f -> f (fix f)
13:24:13 <lambdabot> forall t t1. ((t -> t1) -> t) -> (t -> t1) -> t1
13:24:17 <Baughn> > (fix (const 4), fix (1:))
13:24:18 <lambdabot>   (4,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:24:43 <aristid> > fix show
13:24:45 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
13:24:50 <gwern> > fix error
13:24:51 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
13:25:02 <Baughn> > fix fix
13:25:03 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
13:25:14 <Baughn> ..bad \bot.
13:25:35 <dolio> :t fix $ \fix f -> f (fix f)
13:25:36 <lambdabot> forall t. (t -> t) -> t
13:25:57 <lispy> :t \x -> x x
13:25:57 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:25:58 <lambdabot>     Probable cause: `x' is applied to too many arguments
13:25:58 <lambdabot>     In the expression: x x
13:25:58 <soupdragon> > fix $ \fix f -> f (fix f)
13:25:58 <lambdabot>   Overlapping instances for GHC.Show.Show ((t -> t) -> t)
13:25:59 <lambdabot>    arising from a u...
13:26:16 <rajeshsr>  fix $ (0:) . scanl (+) 1
13:26:19 <rajeshsr> how that works?
13:26:20 <lispy> \x -> x x, is the Y combinator in simply typed lambda calc, right?
13:26:39 <lispy> rajeshsr: are you familiar with scanl?
13:26:43 <lispy> that's where I'd start
13:26:43 <rajeshsr> of course
13:26:44 <soupdragon> lispy, U
13:26:52 <soupdragon> untyped
13:26:53 <interferon> on os x, where are cabal packages installed if they're not in ~/.cabal ?
13:26:58 <lispy> soupdragon: oh, right sorry
13:27:13 <lispy> interferon: I think ghc-pkg lists
13:27:20 <dv-> y f = f (y f)
13:27:25 <lispy> interferon: well, I should say, try ghc-pkg foo
13:27:31 <Saizan> ghc-pkg describe foo
13:27:37 <interferon> i think i have some corrupt packages and i want to wipe out every cabal package and reinstall the Haskell Platform
13:27:37 <lispy> interferon: heh, I'm not typing well today: ghc-pkg list foo :)
13:27:39 <BMeph> yCombinator : -> ret; ret ret.
13:27:43 <soupdragon> @pl \y f -> f (y f)
13:27:43 <lambdabot> ap id
13:27:47 <interferon> lispy: perfect, thanks
13:27:48 <lispy> interferon: ghc-pkg check?
13:28:08 <dolio> > scanl (+) z [a,b,c]
13:28:09 <lambdabot>   [z,z + a,z + a + b,z + a + b + c]
13:28:22 <Saizan> interferon: you only have to "wipe" ~/.ghc which is where the user package database is stored
13:28:48 <interferon> Saizan: i'll try that
13:28:51 <dv-> > a + b
13:28:52 <lambdabot>   a + b
13:29:00 <dv-> I didn't know it did that :o
13:29:02 <interferon> Saizan: i restored my old 32-bit mac onto my new 64-bit mac and things are flaky
13:29:08 <interferon> Saizan: so I want to remove it all
13:29:22 <lispy> > fix $ (z:) . scanl (+) 1
13:29:22 <lambdabot>   [z,1,1 + z,1 + z + 1,1 + z + 1 + (1 + z),1 + z + 1 + (1 + z) + (1 + z + 1),...
13:29:44 <lispy> > fix $ (0:) . scanl (+) 1 :: [Expr]
13:29:45 <lambdabot>   [0,1,1 + 0,1 + 0 + 1,1 + 0 + 1 + (1 + 0),1 + 0 + 1 + (1 + 0) + (1 + 0 + 1),...
13:30:16 <lispy> rajeshsr: does that help :)
13:30:33 <interferon> so is there a system-wide place where cabal packages are installed?
13:30:38 <interferon> they can't all be in ~/.ghc and ~/.cabal
13:30:59 <Saizan> there's the global package db, which is relative to your ghc
13:31:11 <lispy> interferon: Any location that ghc knows about should show with ghc-pkg list.
13:31:12 <Saizan> anyhow, "ghc-pkg list" will give you two directories
13:31:28 <interferon> oh right
13:31:35 <interferon> at the top of ghc-pkg list i see a system-wide directory
13:31:48 <Saizan> doesn't it contain the arch too?
13:31:53 <interferon> and what determines whether a package goes into ~/.ghc or ~/.cabal?
13:32:08 <lispy> interferon: your ~/.cabal/config settings if you're using cabal
13:32:16 <rajeshsr> lispy, hmm, quite vaguely. For I don't understand how does fix call the function when parameter is not given.
13:32:22 <rajeshsr> @src fix
13:32:23 <lambdabot> fix f = let x = f x in x
13:32:24 <Saizan> interferon: ~/.ghc doesn't store files, it store the index, ~/.cabal has the files
13:32:28 <lispy> interferon: if you use ./Setup the default in global but you can change it with --user
13:32:43 <rajeshsr> fix (+1)
13:32:45 <rajeshsr> > fix (+1)
13:32:49 <lambdabot>   mueval-core: Time limit exceeded
13:32:53 <xerox> (+1) is unfixable
13:32:56 <lispy> rajeshsr: understanding fix takes a while, but is very worth it.  You're at an exciting point :)
13:33:00 <xerox> i.e. broken
13:33:03 <Saizan> global ones will have nothing to do with ~/.ghc or ~/.cabal
13:33:24 <rajeshsr> lispy, ha, ok! that will be my next work then! :)
13:33:32 <lispy> interferon: the default install of cabal installs things --user
13:33:43 <byorgey> rajeshsr: fix f = f (fix f).  So fix makes up an argument to give to f, namely... fix f.
13:33:55 <Jafet> Not if it's a lazy nat
13:34:07 <byorgey> rajeshsr: but due to lazy evaluation this argument (fix f) is not evaluated unless f actually needs its argument.
13:34:09 <lispy> fix will always recurse, it has no termination
13:34:41 <pumpkin> > fix (const 5)
13:34:41 <rajeshsr> ha, cool! Lemme try to digest that.
13:34:42 <lambdabot>   5
13:34:45 <lispy> (equational reasoning helps a lot with understanding fix)
13:35:20 <lispy> fix (const 5) = const 5 (fix (const 5))
13:35:32 <lispy> ?src const
13:35:32 <lambdabot> const x _ = x
13:35:45 <pumpkin> it'll only recurse if forced to !
13:35:56 <pumpkin> don't make it do what it doesn't wanna do :P
13:35:58 <lispy> fix (const 5) = const 5 (fix (const 5)) = const 5 _ = 5
13:36:15 <fryguybob> byorgey: Everything built and the path example worked.  I had to bump up the Cairo version as I have 0.11.0.  Thanks!
13:36:47 <Jafet> Does lambdabot have lazy naturals?
13:36:57 <byorgey> fryguybob: ah, yes, Cairo 0.11.0 is hot off the presses.  if it worked fine for you I will bump the version constraint.
13:36:58 <Saizan> > 1 :: Nat
13:36:58 <lambdabot>   Not in scope: type constructor or class `Nat'
13:37:05 <lispy> Jafet: I don't think so, but that would be a cool mod
13:37:18 <Twey> Hey, flip const = const id
13:37:19 <Twey> Cool.
13:37:27 <lispy> If there is a package on Hackage that provides it, I think lambdabot could just import it
13:37:43 <fryguybob> byorgey: Hot off the presses and easy to build on windows :D.
13:37:54 <byorgey> fryguybob: nice =)
13:37:55 <gwern> lispy: sure, but then I either need to add it as a dep or resign myself to bug reports
13:38:12 <gwern> lispy: there may be a way to conditionally import modules if they exist, but I don't know how to do it
13:38:19 <rajeshsr> is there any blog or something about fix and writing fixable functions?
13:38:21 <pumpkin> Jafet: it used to
13:38:31 <lispy> gwern: Oh, I'd just say make it a dep
13:38:31 <pumpkin> Natural
13:39:00 <gwern> lispy: but there are a lot of things that could be a dep; why naturals?
13:39:18 <lispy> rajeshsr: Hmm...Not sure of a specific example, but google for the Y combinator or Haskell fix
13:39:37 <rajeshsr> lispy, ha, so this is Y combinator?!
13:39:46 <rajeshsr> Heard about anonymous recursion..
13:39:53 <GammaLambda> computers.
13:39:55 <lispy> rajeshsr: exactly
13:39:58 <GammaLambda> whoops
13:39:59 <rajeshsr> time to check out!
13:40:06 <rajeshsr> thanks
13:40:07 <lispy> rajeshsr: can you figure out what 'fix show' does?
13:40:17 <lispy> > fix show
13:40:18 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
13:40:26 <Saizan> it's not the Y combinator, but it has the same behaviour
13:40:46 <lispy> Saizan: hmm...what is the distinction?
13:41:11 <illissius`> this is probably blindingly obvious, but what's something which does (a -> m b) -> (b -> c) -> (a -> m c)?
13:41:13 <lispy> Saizan: it has the same type and implements the same transformation, right?
13:41:14 <rajeshsr> lispy, something staring with empty strings and trying to show them?
13:41:22 <rajeshsr> *starting..
13:41:40 <lispy> rajeshsr: yeah.  Man, it took me a lot of puzzling to figure out that one :)
13:41:43 <davidL> rajeshsr: http://www.vex.net/~trebla/haskell/fix.xhtml
13:41:50 <gwern> hm. 'we are anonymous. we are cursion'.
13:42:02 <lispy> illissius`: hoogle it!
13:42:10 <illissius`> I did! there's nothing built in
13:42:12 <rajeshsr> davidL, thanks
13:42:20 <lispy> ?hoogle (a -> m b) -> (b -> c) -> (a -> m c)
13:42:20 <lambdabot> Language.Haskell.TH.Quote dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (b -> Maybe (Q q)) -> a -> Q q
13:42:28 <rajeshsr> lispy, it is really getting interesting!
13:42:29 <lispy> illissius`: oh hmm...it does look familiar
13:42:43 <illissius`> I imagine you can get it fairly easily using the other monad functions
13:42:44 <mauke> :t \f g x -> fmap g (f x)
13:42:45 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (t -> f a) -> (a -> b) -> t -> f b
13:42:46 <illissius`> I'm just having trouble thinking
13:42:53 <mauke> @pl \f g x -> fmap g (f x)
13:42:54 <lambdabot> flip ((.) . fmap)
13:43:04 <lispy> :t (<*>)
13:43:04 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:43:23 <byorgey> Functor is enough, you don't even need Monad functions
13:43:29 <lispy> illissius`: it seems ilke something you'd use with applicative
13:43:55 <byorgey> mauke gave the solution above.
13:43:59 <illissius`> byorgey: well yeah. but most (all?) functor functions have equivalents defined for monads
13:44:03 <illissius`> mauke: thanks.
13:44:17 <byorgey> illissius`: there's only one functor method, namely fmap =)
13:44:26 <byorgey> and it has an equivalent, liftM.
13:44:31 <byorgey> for hysterical raisins.
13:44:52 <Saizan> lispy: Y combinator is the name of a particular lambda term, our fix is defined using recursion
13:44:54 <illissius`> oh. indeed
13:44:54 <byorgey> in an ideal world there would only be one.
13:45:12 <byorgey> but Haskell Monads do not have to be Functors, even though all monads are functors
13:46:10 <lispy> Haskell monads don't even have to be monads :(
13:46:42 <Jafet> They're full of fail
13:46:44 <triyo> I have a case where I connect to mongoDB using Haskell mongoDB bindings. All goes well when I run the simple connection test code from my compiled program. When I try to perform the same connection test from ghci, I am slapped by a nice segmentation fault.
13:47:07 <byorgey> lispy: heh, good point =)
13:47:47 <rajeshsr> k, guys! bye
13:47:48 <lispy> Jafet: hehe, that's clever considering that a lot of people object to the 'fail' function
13:47:50 <rajeshsr> late night here
13:47:56 <gwern> triyo: yeah, ghci has some issues with ffi
13:47:57 <rajeshsr> thanks for all those learning!
13:48:00 <byorgey> bye rajeshsr
13:48:05 <lispy> rajeshsr: bye
13:48:07 <rajeshsr> bye
13:48:14 <lispy> (come back soon!)
13:48:21 <Jafet> You probably need proof-level language to guarantee proper semantics
13:48:31 <lispy> Jafet: yeah, Agda can do it
13:48:31 <Jafet> There isn't any guarantee that some Ord instance is total, either
13:48:35 <gwern> triyo: you can run into the same issue if you were trying out a gtk2hs or wxhaskell program, for example
13:48:42 <triyo> gwern: any know workarounds? Would be nice to interactively query the db
13:48:46 <lispy> Jafet: and Isabelle too
13:48:49 <gwern> triyo: not really
13:48:50 <Jafet> Or that a Num instance is a ring...
13:48:53 <lispy> Jafet: I would assume Coq can as well
13:49:04 <Jafet> (And one isn't: Double)
13:49:58 <byorgey> any dependently-typed language can, more or less
13:50:27 <byorgey> well, any dependently-typed language with support for total programming
13:50:36 <byorgey> since otherwise you can 'prove' anything you like =)
13:51:22 * hackagebot threadscope 0.1.2 - A graphical thread profiler.  http://hackage.haskell.org/package/threadscope-0.1.2 (SimonMarlow)
13:51:54 <lispy> oh, a new threadscope.  Hopefully with updated deps now that gtk2hs has been refined?
13:51:59 <tibbe> @seen ttuegel
13:51:59 <lambdabot> Unknown command, try @list
13:52:06 <tibbe> preflex: seen ttuegel
13:52:06 <preflex>  ttuegel was last seen on #haskell 1 hour, 9 minutes and 14 seconds ago, saying: yes?
13:52:19 <triyo> gwern: it might be the ghc/i ver I'm on. I use 6.10.4, In mongoDB mini-tutorial, they take a tour through the mongoDB calls/queries all in ghci.
13:53:07 <triyo> on that thought it could be many other reasons
13:53:10 <Saizan> triyo: the problems of the GUI libs with ghci are due to their use of thread-local state, i doubt mongoDB is doing the same
13:53:53 <Saizan> triyo: does your program work fine if you compile with -threaded ?
13:54:25 <Peaker> illissius`, did you get your answer yet?
13:55:11 <Peaker> illissius`, First, your question can be decomposed into two:  (a -> m b) -> (b -> c) -> (a -> m c)   -- you're not touching the (a->) part.  So might as well just use (.) with something that can do:  m b -> (b -> c) -> m c...
13:55:24 <triyo> Saizan: yes they do. I have one at the running Snap HTTP server..
13:55:42 <Peaker> @hoogle m b -> (b -> c) -> m c
13:55:43 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:55:43 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
13:55:43 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
13:56:33 <triyo> so I do use -threaded option in my programs with no problems
13:57:37 <triyo> However I just discovered that I get the same seg fault when trying to do a connect .... conn <- connectSqlite3 "test1.db" (HDBC)
13:58:05 <triyo> this is all within ghci, if compiled, then it runs fine.
13:59:36 <triyo> I'm on a Mac OS X 64bit btw
13:59:55 <gwern> triyo: that's just rubbing salt into your wounds
14:00:50 <tibbe> dcoutts: what exeModules used for in addition to the package check? it doesn't seem to be used anywhere. in particular I can't see that those modules are passed to the compiler somehow. presumably other-modules would be useful if we didn't use ghc --make?
14:02:22 <triyo> hehe, I can imagine, forget about it guys, thanks for your help, I'll give it a try on my PC at work (Ubuntu 10.04) tomorrow morning.
14:03:35 <RyanT5000> hey guys, it's time for me to spam some more :)
14:03:46 <RyanT5000> my company's hiring haskell programmers to work on our video game right now
14:04:04 <Twey> Oh really?
14:04:12 <RyanT5000> yup :)
14:04:22 <RyanT5000> money is now available to write games in haskell :)
14:04:33 <Twey> I'm sadly not available for hire right now, but I'm very interested in the project.
14:04:35 <BoyTito> even for newbies? :p
14:04:47 <RyanT5000> depends :)
14:04:53 <RyanT5000> we don't have *much* money, as we're a startupu
14:05:03 <drautzburg> why are they using haskell for games?
14:05:06 <RyanT5000> however, we do have a pretty strong internship programming as well
14:05:13 * gwern tries to outbid RyanT5000. I offer 10 cents a game!
14:05:22 <Twey> Hehe
14:05:29 <RyanT5000> gwern: you've got a long way to go - even i'm not that cheap :P
14:05:50 <RyanT5000> drautzburg: well, there are a number of advantages to Haskell
14:05:52 <gwern> RyanT5000: hey, I'm offering a better deal - clear terms upfront
14:05:59 <gwern> none of this 'depends' nonsense
14:06:00 <RyanT5000> hahahahaha
14:06:07 <RyanT5000> that's a good point :)
14:06:11 <gwern> I know who I'd rather deal with!
14:06:21 <drautzburg> I mean from a manager's perspective
14:06:26 <RyanT5000> 10 cents in hand is better than two birds in the bush, right?
14:06:48 <RyanT5000> drautzburg: well, i'm the manager/owner, so i can answer that :)
14:06:49 <gwern> yeah. birds are expensive pets
14:06:58 <gwern> they're like *negative* ten cents!
14:07:04 <RyanT5000> well they're not really pets when they're in the bush
14:07:08 <RyanT5000> they usually take care of themselves :P
14:07:12 <Twey> Meh two birds make a good meal, but 10 won't buy even a loaf of bread these days
14:07:26 <gwern> Twey: it'll buy a meal's worth of oats though
14:07:30 <gwern> if you were buying in bulk
14:07:34 <RyanT5000> drautzburg: Haskell's got a lot of technical benefits, which I do care about, but it also has a lot of non-technical ones as well
14:07:38 <RyanT5000> for example, this chatroom is a huge asset
14:07:45 <Twey> Which is an unfair assumption if you're so poor you're eating nothing but oats
14:07:52 <Twey> Also, scurvy :
14:08:02 <RyanT5000> it's an amazing collection of people who can answer really hard questions
14:08:06 <gwern> Twey: pfft. multivitamins can be pretty cheap (if you buy in bulk)
14:08:16 <RyanT5000> not to mention, it can help me find people to hire :)
14:08:20 <RyanT5000> so there's that
14:08:26 <gwern> (and I was thinking more of breakfast anyway)
14:08:27 <Twey> RyanT5000: Don't forget the mailing lists, too.
14:08:28 <RyanT5000> also, Haskell programmers tend to be self-taught and therefore self-motivated
14:08:34 <RyanT5000> Twey: yup, and i've spammed those as well :)
14:08:40 <Twey> Oh, okay.
14:08:45 <gwern> RyanT5000: oh no, next you'll be linking to the Python Paradox!
14:08:55 <sioraiocht> dcoutts: ping?
14:09:02 <RyanT5000> gwern: interesting; i hadn't read taht
14:09:08 * Twey neither.
14:09:12 <Twey> gwern: Looks like you did it, instead.  :
14:09:18 <gwern> RyanT5000: it's more paul grahamism. you can probably guess the thesis
14:09:22 <Peaker> gwern, the Paul Grahamm thing is called that? I remember reading it but I don't remember any "Paradox"..
14:09:23 <RyanT5000> but i did give a talk at MIT's Boston Haskell Users's Group on the same basic thing
14:09:53 <RyanT5000> the fact of the matter is that Haskell has some annoyances - namely that we have to do memory profiling all the time
14:10:17 <RyanT5000> but all together, it lets us find better people who can then write better code
14:10:30 <triyo> RyanT5000: what devices are you guys targeting? (Sorry if I missed it)
14:10:45 <RyanT5000> i don't doubt that other languages would have similar benefits, but haskell's the one i chose to go with :)
14:10:48 <Twey> gwern: I quite like many of the PGisms.
14:10:57 <RyanT5000> triyo: we're targeting smartphones: android, iphone, etc.
14:11:06 <gwern> Twey: yeah, but you ahve to be careful not to be sucked in
14:11:15 <lispy> RyanT5000: performance tuning seems like a small price to pay for the increased ease of correct by construction :)
14:11:25 <RyanT5000> lispy: indeed
14:11:44 <gwern> you want to treat paul graham or steve jobs as like nuclear explosions - they generate a lot of light, but you're better off being far far away
14:12:07 <RyanT5000> one cool thing is that even though we've had to rewrite a few algorithms in C, Haskell has helped us do that: we quickcheck all our C :P
14:12:13 <gwern> remember the inverse square law applies to reality distortion fields just as well
14:12:14 <Jafet> Graham is more like a neutron star
14:12:15 <lispy> PG has a lot of good ideas, but sometimes I think he's become a blub programmer himself
14:12:15 <Peaker> Paul Grahamm has the occasional insight in between a lot of ...
14:12:21 <Jafet> Very interesting, but also very dense
14:13:01 <lispy> Arc was a horrific disappointment from my perspective
14:13:07 <gwern> haha no kidding
14:13:18 <gwern> did it do *anything* interesting?
14:13:25 <RyanT5000> so anyway, guys: games in haskell, tell your friends :)
14:13:27 <Twey> gwern: Heheh.
14:13:34 <RyanT5000> hopefully your haskell-writing friends, not just random friends
14:13:36 <lispy> gwern: yes, if it were released ~50 years earlier
14:13:37 <RyanT5000> :P
14:13:41 <Jafet> What if I have no friends
14:13:44 <Twey> Yeah, Arc was a shame
14:14:03 <RyanT5000> Jafet: then you're useless to me; go cry in a corner
14:14:03 <aristid> RyanT5000: because you want to hire these haskell-writing friends? :P
14:14:03 <RyanT5000> :P
14:14:08 <Twey> RyanT5000: Link to some info on your company and/or project and I'll keep it in mind
14:14:09 <RyanT5000> aristid: of course!
14:14:15 <RyanT5000> ipwnstudios.com
14:14:17 <gwern> RyanT5000 - he's brutal but fair
14:14:23 <RyanT5000> :)
14:14:27 <Twey> Haha
14:14:28 <Peaker> lispy, Yeah, I think Lisp itself is Blub, when compared to Haskell
14:14:34 <RyanT5000> Jafet: or, you could work for me, and *meet* some friends :D
14:14:37 <aristid> RyanT5000: the rotating wheel totally kills firefox
14:14:42 <Jafet> There is no Blub -- only Blubbers.
14:14:43 <Peaker> lispy, The whole notion that macros give you *everything* that any language gives you I think is a fallacy
14:14:52 <RyanT5000> aristid: haha yeah, it's javascript, don't mind it
14:14:58 <Twey> What rotating wheel?  :
14:14:59 <RyanT5000> it's got good performance in chrome
14:15:05 <Peaker> "You have any language you want, you just have to implement it yourself" is wrong -- because macros don't really make all kinds of language features easy to implement
14:15:08 <gwern> Peaker: no no - you want the 'turing tarpit' conception. if macros are TC then they do give you everything
14:15:11 <RyanT5000> Twey: we have a gear on our website that turns when you scroll
14:15:15 <Twey> Oh
14:15:17 <Twey> That rotating wheel
14:15:33 <Jafet> Firefox is notoriously poor at rendering any layered absolute position element
14:15:37 <Twey> That's a very heavy website, with a very tiny font
14:15:39 <Jafet> (It redraws the entire display)
14:15:44 <Peaker> gwern, Sure, but they're not even a good way to do that (might even be better to implement a language from scratch)
14:15:48 <lispy> Peaker: Right.  Macros don't give me static type checking do they?
14:15:50 <Peaker> (Or hack on GHC, or what not)
14:15:57 <Twey> And the wheel does not like it when I zoom
14:16:06 <Jafet> lispy, depends on what a "macro" is and what "static type checking" is
14:16:13 <Peaker> lispy, There's "Qi" or such that does static types with macros -- but it's a large system and apparently nobody uses it, and I doubt it integrates into a dynamic eco-system well
14:16:16 <gwern> lispy: wrap all your code in a macro, which implements a hm typechecker and divides by zero if it detects a type error...
14:16:20 <Twey> (and the font is still tiny anyway)
14:16:20 <lispy> Peaker: if macros could give me a theorem prover for my code I'd like them more; possibly anyway
14:16:30 <Peaker> lispy, I doubt it's easier to implement it all with macros than in GHC or what not
14:16:35 <Jafet> lispy, macros are turing complete!
14:18:07 <roconnor> RyanT5000: you work for ipwn?
14:18:29 <Twey> Judging by the blog post, RyanT5000 *is* ipwn
14:18:30 <RyanT5000> roconnor: i own ipwn (50%)
14:18:33 <Peaker> When are strictness annotations on records disallowed?
14:18:35 <roconnor> :D
14:18:35 <gwern> roconnor: you just now noticed? :)
14:18:39 <roconnor> RyanT5000: awesome
14:18:42 <roconnor> gwern: yes
14:18:42 <Twey> What does the other guy do?
14:18:50 <gwern> 'little man, I *am* ipwn!'
14:18:53 <Peaker> I have something like: data MyRecord = MyRecord { .... someField :: !SomeNewType SomeType }  -- and it refuses
14:18:54 <Twey> Haha
14:18:58 <Jafet> You pwn ipwn?
14:19:00 <copumpkin> RyanT5000: if worse comes to worst you can always go for the cydia store :)
14:19:02 <mauke> Peaker: !(A B)
14:19:04 <gwern> Twey: maybe he's the silent backer, laundering his drug money through it
14:19:07 <Peaker> mauke, ah, thanks
14:19:08 <copumpkin> RyanT5000: plenty of people on that too :P
14:19:15 <roconnor> RyanT5000: who does the art?
14:19:17 <RyanT5000> copumpkin: i will certainly do that if apple spurns us :)
14:19:24 <RyanT5000> roconnor: we have an art team of about 15 folks
14:19:31 <roconnor> :O
14:19:38 <RyanT5000> the other founder and i mostly manage
14:19:39 <roconnor> where do you find 15 artists?
14:19:41 <Twey> Alrighty then
14:19:41 <copumpkin> RyanT5000: 2.8 million unique devices opened the cydia app last week or something
14:19:51 <RyanT5000> roconnor: all over; most of them are local (Boston, MA)
14:19:54 <gwern> roconnor: freelancers, I'd bet my left eyetooth
14:20:01 <RyanT5000> we've canvassed art schools in the area, etc.
14:20:12 <roconnor> damn
14:20:15 <RyanT5000> some of them are interns - i don't mean to imply that we're spending buckets of cash on this
14:20:21 <lispy> RyanT5000: how difficult will it be to support Android instead of iPhone?
14:20:22 <roconnor> can I ask where you get money?
14:20:33 <gwern> roconnor: like I said - drug money
14:20:34 <Twey> I don't think Haskell is allowed on the iPhone
14:20:36 <RyanT5000> lispy: not very hard; we designed for that from the beginning
14:20:43 <roconnor> gwern: makes sense
14:20:45 <copumpkin> Twey: ORLY? I'm sure they didn't know that ;)
14:20:46 <gwern> Twey: you're only repeating the -cafe discussion
14:20:51 <lispy> RyanT5000: In your application or in your GHC patches?
14:21:00 <RyanT5000> Twey: well, i don't want to get into this discussion all over (see my recent email to haskell-cafe) but suffice it to say that i'm not especially afraid
14:21:06 <Twey> gwern: I don't read -cafe, so that would be impressive of me ;)
14:21:22 <gwern> Twey: I meant more like 'yes, that is an obvious and well-discussed issue'
14:21:29 <Twey> Aye.  
14:21:29 <copumpkin> honestly, I think apple would probably accept the app if you don't make a big deal about it being written in haskell
14:21:32 <lispy> RyanT5000: I mean, if I wanted to write an android app in Haskell, would I start from your modified GHC?
14:21:39 <copumpkin> as long as you don't go posting on news sites that "OMG HASKELL ON IPHONE"
14:21:43 <RyanT5000> roconnor: well, the other founder and i both worked full-time as consultants during our last year of law school, so we had some money from that
14:21:53 <RyanT5000> we've gotten some other financing from friends, but it's mostly our money so far
14:21:54 <Jafet> And make sure the news sites don't do it for you.
14:21:59 <roconnor> law school?!
14:22:03 <RyanT5000> we want to keep the company 100% private
14:22:09 <RyanT5000> roconnor: yup, i just graduated a year ago :)
14:22:10 <copumpkin> roconnor: RyanT5000 is amazing
14:22:11 <gwern> consultants during law school?
14:22:20 <RyanT5000> gwern: yeah, we were bored :P
14:22:24 <gwern> I thought law school was supposed to be hard
14:22:25 <gwern> gosh
14:22:25 <lispy> RyanT5000: Have you thought about writing non-mobile games and distributing via Steam?
14:22:27 <Twey> Hehe
14:22:31 <RyanT5000> gwern: the first year is kinda hard
14:22:35 <Twey> lispy: :-\
14:22:36 <roconnor> preflex: nickometer RyanT5000
14:22:37 <preflex>  RyanT5000 is 66% lame
14:22:39 <RyanT5000> gwern: the second and third year are 100% elective classes :)
14:22:47 <Jafet> gwern, compared to getting a 3D real-time Haskell game sold for iPhone?
14:22:50 <copumpkin> roconnor: it's wrong! he's only like 1% lame
14:22:59 <gwern> huh. so you invested in a lawschool education, and you're doing a game startup?
14:23:04 <RyanT5000> preflex: lol that's very prcise of you :)
14:23:07 <lispy> RyanT5000: anyway, I'm really interested Haskell + Android.
14:23:07 <gwern> well, that's a new one on me
14:23:12 <Twey> And know your tech, too
14:23:27 <gwern> I suppose that means you don't need to shill out for legal advice for a while...
14:23:30 <RyanT5000> gwern: yup :) the merits of the law school 'investment' are debatable, lol
14:23:46 <Jafet> That depends on what electives he took...
14:23:48 <RyanT5000> gwern: yeah, i didn't take the bar; i was too busy getting this game company rolling
14:23:50 <gwern> RyanT5000: if I thought law school was a good idea, then I'd be doing it!
14:24:11 <RyanT5000> lispy: have you seen alpheccar's work?
14:24:15 <jmcarthur> RyanT5000: i like lispy am also curious if there are plans to develop for non-mobile platforms in the future
14:24:17 <lispy> RyanT5000: No
14:24:46 <lispy> jmcarthur: you like me? aw shucks ;) (okay, just teasing because english is funny like that)
14:25:20 <Cale> I'm only familiar with his blog, which is quite interesting generally.
14:25:38 <Twey> Most languages are funny when you miss out crucial elements of their grammar.  :
14:25:45 <gwern> I love these speculative CS papers.
14:25:46 <gwern> 'by charging the black hole computers so they become Reissner-Nordstrom black holes it might be possible to create a dense volume of 'black hole processors' where their mutual attraction is balanced by electrical repulsions. What kind of mechanisms would be necessary to create the holes and send/receive information frmo them remains rather speculative.'
14:26:21 <Twey> Hahahaha
14:26:31 <Jafet> How about the accelerating Omega computer (pronounced 'oh-mi-gawd')
14:26:32 <Twey> Was that an actual quote?
14:26:47 <RyanT5000> lispy: http://www.alpheccar.org/en/posts/show/94
14:26:51 <gwern> Twey: yes; I sure don't know what a Reissner-Nordstrom black hole is
14:27:01 <Twey> gwern: Don't feel alone
14:27:06 <RyanT5000> alpheccar has done some work porting our ghc-iphone project to Android and OMAP3
14:27:07 <Peaker> What is this: castSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)
14:27:11 <ddarius> lispy: That wasn't English's fault.
14:27:17 <Peaker> No "unsafe", how come?
14:27:37 <Jafet> ST is pure
14:27:38 <gwern> wikipedia tells me, 'In physics  and astronomy, the ReissnerNordstrm metric is a static solution to the Einstein field equations in empty space, which corresponds to the gravitational field of a charged, non-rotating, spherically symmetric body of mass M.' <-- obvious in retrospect
14:27:42 <Twey> Peaker: Presumably because it's safe?  ;)
14:27:50 <Twey> Peaker: I guess there's an exception of some sort if it fails
14:27:59 <Peaker> ST has exceptions?
14:28:04 <Twey> I've no idea
14:28:06 <ddarius> gwern: There are only three properties that define a black hole: mass, charge, and rotation.
14:28:22 <Peaker> Jafet, Note the "a" becoming a "b"
14:28:31 <gwern> ddarius: yeah yeah, I know that much; I just didn't know the name of a charged non-rotating black hole
14:28:32 <ddarius> Twey: How would it check whether it "fails" or not?
14:28:32 <Jafet> Oh; noted.
14:28:33 <Peaker> Jafet, seems like a sort of unsafeCoerce
14:28:46 <lispy> BlackHole :: a -> ()
14:28:46 <RyanT5000> jmcarthur: we plan to hit lots of platforms in the future
14:28:48 <Twey> ddarius: Hm.  Pass.
14:28:52 <gwern> ddarius: not that I understand why they wouldn't be rotating, though
14:28:53 <jmcarthur> RyanT5000: awesome
14:29:01 <RyanT5000> our game is especially suited for touchscreens, so we'd love to hit DS
14:29:06 <ddarius> gwern: It just assuming they aren't also rotating.
14:29:28 <RyanT5000> we'd need to do a complete UI redesign, but PSP or even "big" platforms (PC, xbox, ps3, wii) are conceivable
14:29:33 <Peaker> the ST module seems poorly designed.. it has unsafeIOtoST and runST in that same module -- so if you bring in ST you must bring in unsafePerformIO
14:29:45 <gwern> I know, but why would the original scheme want them non-rotating? they are symmetrical so wouldn't that mean the repulsion would be constant regardless of rotation?
14:29:54 <ddarius> Schwarzschild = just mass, Kerr = rotating + mass, so Reissner-Nordstrom = charged + mass, what's the name for all of them?
14:30:04 <Jafet> "Your mother"
14:30:10 <Cale> Peaker: I agree about that, it's one of the things you have to be careful about when importing things for an IRC bot :)
14:30:28 <ddarius> gwern: The rotation probably doesn't really affect the computational abilities but it just complicates things.
14:30:44 <Jafet> Rotation causes things like accretion jets
14:30:56 <Jafet> Not that I know of any non-rotating black holes
14:31:05 <Peaker> Cale, They should just take it out and if someone actually uses unsafeIOtoST their code should break until they import it from "Unsafe" :)
14:31:16 <illissius`> doesn't a rotating charge cause a magnetic field or something? *vague memories of maxwell* or is it only moving ones?
14:31:27 <Peaker> What happens if you go out of bounds in ST array indices? Memory corruption or pure exceptions?
14:31:31 <ddarius> illissius`: Moving in general.  Rotating is moving.
14:31:43 <ddarius> Peaker: Exceptions
14:31:48 <Peaker> ddarius, thanks
14:32:11 <Jafet> What's a pure exception? Never heard of those
14:32:17 <Peaker> imprecise exception
14:32:26 <Cale> Peaker: agreed, it would make more sense to have that stuff in Control.Monad.ST.Unsafe, or one of the other places that such hackery is stashed.
14:32:28 <Jafet> Okay
14:32:43 <Peaker> Cale, Yeah... Now I also wonder how I'm support to create an STArray..
14:32:44 <aavogt> what a name... it makes it sound like nobody knows what they are
14:32:52 <Peaker> oh, there's newArray
14:33:03 <gwern> aavogt: one cannot be precisely imprecise?
14:33:22 <Peaker> newArray_ :: (Ix i) => (i, i) -> m (a i e) -- is it populated by bottoms at first?
14:33:40 <Cale> Jafet: it's the sort of exception thrown by 'error'
14:34:07 <Jafet> I've not heard it called a "pure exception" before
14:34:56 <Jafet> I see now, because you can say you're working in pure code
14:35:03 <Jafet> Subtle.
14:35:19 * gwern vaguely remmebers - aren't continuations pure and able to impleement exceptions?
14:36:27 <ddarius> gwern: callCC isn't pure and is able to implement exceptions.  You can use CPS but that's a global transformation.
14:36:40 <lispy> gwern: continuations can do really complicated control flows fairly 'naturally'
14:36:52 <pikhq> gwern: And all other monads...
14:36:52 <Jafet> Why isn't callCC pure though?
14:36:58 <gwern> one day I will understand continuations!
14:37:02 <pikhq> Continuations are the ultimate in flow control.
14:37:10 <ddarius> lispy: It's more that they let you localize the issues.
14:37:10 <mux> Cont is the mother of all monads
14:37:20 <Cale> callCC is pure if you consider the Cont monad pure (and you consider its callCC real)
14:37:29 <siracusa> Why is there a getEnv, but not corresponding setEnv to set an environment variable?
14:37:29 <lispy> ddarius: Isn't that only delimited continuations?
14:37:40 <Jafet> siracusa, because you can't
14:37:49 <aavogt> @hoogle withEnv
14:37:50 <lambdabot> No results found
14:37:56 <lispy> ?hoogle environment
14:37:56 <lambdabot> module System.Environment
14:37:56 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
14:38:12 <aavogt> @hoogle withArgs
14:38:12 <lispy> ?hoogle interactive
14:38:12 <lambdabot> No results found
14:38:12 <ddarius> lispy: I'm saying continuations let you add effects by making local changes to the code.
14:38:13 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
14:38:13 <pikhq> siracusa: The only way to "set an environment variable" is to spawn a process with a modified environment.
14:38:25 <mauke> pikhq: how do you modify an environment?
14:38:32 <Saizan> aavogt: "imprecise" stands for "the exception reported is non-deterministically chosen among the possible ones" or "we want to be able to switch the order of bottoms during optimizations"
14:38:43 <mux> that's blatantly false
14:38:47 <mauke> siracusa: there problaby is one in the unix package
14:38:54 <mux> see standard libc functions setenv() and putenv()
14:38:56 <pikhq> mauke: Modify the [(String, String)] from getEnvironment?
14:39:10 <siracusa> mauke: I need one for Windows
14:39:12 <Cale> break (=='=') str -- heh
14:39:13 <mux> err, putenv() ain't standard though :-P
14:39:23 <mauke> is libc standard?
14:39:35 <mux> mauke: it all depends which standard you consider :-)
14:40:00 <mauke> getenv() is standard C, anything else isn't
14:40:05 <pikhq> mux: Those are modifying a global variable where the environment that new processes from the appropriate libc functions will be spawned with.
14:40:22 <pikhq> Erm. Append an "is" to that.
14:40:24 <mux> pikhq: no, those are modifying the environment, period
14:40:31 <aristid> when would you use the Cont monad?
14:40:34 <mux> ie, a subsequent getenv() will return modified values
14:40:41 <pikhq> No, they're modifying a char**.
14:40:47 <mux> mauke: right, setenv() is actually a POSIX extension
14:41:03 <mux> pikhq: yes, and that involves lots of trickery, but they still are modifying the environment
14:41:04 <pikhq> getenv() itself accesses said char**, as a POSIX extension. :)
14:41:35 <Peaker> Cale, Why wouldn't you consider Cont's pure callCC real?
14:41:36 <pikhq> Just a char** which got set to the contents of the environment by _start.
14:42:29 <mux> pikhq: sigh, try it and see for yourself: stick a setenv() call in-between two getenv() calls
14:42:49 <ddarius> aristid: Mostly to implement other stuff.  It's rare that callCC is the thing you actually want unless you are doing semantics for a language with it.
14:43:02 <pikhq> mux: Yes, they're just modifying a char** which getenv() happens to access.
14:43:16 <copumpkin> omg what is this c talk I hear in #haskell
14:43:20 <copumpkin> BEGONE, ALL OF YOU
14:43:23 <pikhq> That's going to do nothing to the envp argument to main. :)
14:43:25 <mauke> pikhq: and that char ** is the environment
14:43:33 <mux> pikhq: they are modifying the environment because a subsequent call to getenv() (which is the only standard way to access the environment) reflects the setenv() changes.
14:43:35 <Jafet> Stop talking so imperatively, copumpkin.
14:43:57 <copumpkin> Jafet: hmm, I'll have to figure out how to do it purely
14:43:59 <pikhq> mux: We're clearly thinking at different levels of abstraction here.
14:44:14 <Jafet> You could be lazy, and ignore our transgressions
14:44:17 <lispy> Implement callCC in C?
14:44:22 <copumpkin> Jafet: oh, that works :)
14:44:31 <mux> pikhq: let me remind you what you just said: "you cannot modify the environment". So yes, you were wrong, get over it!
14:44:44 <mux> pikhq: I'm done on this matter :-P
14:45:12 <pikhq> I'm thinking of the environment as "that array that the kernel shoves on the stack when spawning a process, that _start does a lot of magic to", and you're thinking of it as the environment vector that libc has functions to deal with.
14:45:19 <Saizan> maybe pikhq meant "you can't modify your parent's environment"
14:45:57 <mauke> pikhq: I'll just memcpy into the stack
14:46:00 <mauke> bam, modified
14:46:24 <pikhq> mauke: Hah.
14:46:26 <aristid> ddarius: so in normal haskell code you don't need Cont?
14:46:46 <copumpkin> aristid: you do need it if you're l33t
14:46:55 <mux> pikhq: yes, of course, it makes a lot of sense to think about the environment that way when the guy originally wanted to modify the environment, ie call setenv(). it's just very convenient for you to backpedal like this in order to not be proved utterly wrong
14:46:56 <copumpkin> aristid: are you l33t?
14:46:59 <mux> whatever
14:47:02 <copumpkin> * r u l33t
14:47:21 <pikhq> mux: ...
14:47:30 <pikhq> mux: Why the hell would I do that?
14:47:34 <aristid> copumpkin: uh... "shizzle my nizzle"?
14:47:41 <gwern> fo zhizzle
14:47:41 <pikhq> I'm the first to admit that I'm wrong a hell of a lot of the time.
14:47:42 <copumpkin> aristid: nope, wrong one
14:47:48 <copumpkin> pikhq: liar
14:47:57 <copumpkin> lyre?
14:48:00 <aristid> copumpkin: i guess i'm not 1337 then
14:48:01 <mux> pikhq: I'm done - if you want to speak more about it, query me.
14:48:05 <pikhq> At this point, you're just being insulting for no good reason.
14:48:14 <mux> and I'd recommend you do the same
14:48:35 <pikhq> You insulted me and now want to stop the conversation.
14:48:48 <aristid> copumpkin: "l13r"?
14:48:49 <Cale> aristid: Cont is really just a bunch of combinators for manipulating functions of a particular type (that have been wrapped up inside a datatype). You could always avoid using it.
14:49:28 <Cale> aristid: and it's somewhat rare that it's useful. It might be quite handy when writing certain types of interpreters.
14:49:58 <aristid> Cale: can you think of other use cases?
14:50:05 <aristid> i just want to understand this better :)
14:50:07 <copumpkin> aristid: bending your mind, too
14:50:11 <Cale> There's only one that I'm aware of
14:50:32 <Cale> You can unwrap some of the things from Control.Monad and you get sometimes-handy functions...
14:50:35 <copumpkin> aristid: continuations can also be useful if you're returning existential things, but Cont won't do that for you
14:51:08 <copumpkin> it might with impredicative types actually
14:51:10 <pikhq> aristid: Continuations get you weird flow control. Obviously, weird flow control is only needed in weird cases.
14:51:11 <copumpkin> but those are on the way out
14:51:15 <lispy> Well, continuations (specifically delimited continuations) can be used to model complex co-routines like OS system calls, databases, network protocols, and so on
14:51:48 <lispy> In the OS system call case, the transfer of control between OS and process is the delimiter
14:52:03 <lispy> Oleg has a paper that describes this
14:52:08 <lispy> The Zipper FS paper
14:52:14 <aristid> pikhq: because haskell already has other monads for normal control flow, so continuations are the best solution in only some weird corner cases?
14:52:25 <Cale> runCont . sequence . map Cont :: [(a -> r) -> r] -> ([a] -> r) -> r
14:52:25 <pikhq> aristid: Basically.
14:52:34 <aristid> continuations are by nature a very low-level structure
14:52:35 <Cale> ^^ that one in particular is handy
14:52:48 <aristid> Cale: what's it do?
14:52:52 <pikhq> Cale: Oooh, that's nice.
14:53:00 <Cale> There's a common idiom of writing functions whose name starts with 'with'
14:53:03 <aristid> :t runCont . sequence . map Cont
14:53:04 <lambdabot> forall r a. [(a -> r) -> r] -> ([a] -> r) -> r
14:53:29 <Cale> for allocating some resource, applying a function to it to get a result, and then deallocating after
14:53:36 <Cale> (mostly in IO)
14:53:44 <copumpkin> I love that function
14:53:50 <copumpkin> Cale++
14:53:59 <mux> that's so old-school: the cool kids use iteratees now. ;-)
14:54:06 <Cale> that function will take a list of with-style functions (really just CPS), and give a with-style function which passes a list of the results
14:54:09 <copumpkin> mux: not really for the same purpose
14:54:18 <mux> copumpkin: yes, I was only kidding.
14:54:21 <copumpkin> :)
14:54:41 <mux> I love how just having higher-order functions is enough to cover a very important use case of substructural types
14:54:47 <aavogt> there's a problem sometimes with those in that the `a' can escape in the `r'
14:54:58 <mux> (I think those I'm thinking of are linear types)
14:55:59 <Cale> I still rather dislike iteratee for a reason that I have trouble articulating.
14:56:01 <aavogt> at which point the actual resouce that the `a' refers to may be unusable
14:56:08 <Peaker> Dijkstra has a paper about why he prefers [x..y) ranges.. Haskell has pervasive use of [x..y] ranges.  It's a little annoying to go back to these
14:56:20 <Peaker> (I've used [x..y) ranges for many years and come to like them
14:56:22 <copumpkin> Cale: too explicit?
14:56:44 <Cale> copumpkin: Maybe that's it. It seems more complicated than it ought to be given what it does.
14:56:46 <aavogt> I think matching those would be more tricky
14:56:51 <Zao> I'm still rather annoyed at everywhere in stochastics where they for some reason use P(20 < X <= 30).
14:57:01 <Peaker> Zao, Heh
14:57:02 <copumpkin> Cale: I sort of feel the same way
14:57:12 <Zao> They seem to arbitrarily interchange < and <= wherever it feels good too.
14:57:14 <copumpkin> but for now it's not too bad
14:57:16 <Peaker> Array ranges being inclusive at both ends is a little ugly
14:57:23 <gwern> Zao: it's called job security
14:57:53 <aavogt> Zao: it doesn't make much difference here, right?
14:58:00 <mux> the big problem I see with iterateers vs lazy IO is that lazy IO allows you to completely forget about incrementality and you just lift pure functions onto your lazy IO result; but one may argue that this conveniency is just a lie, given the other problems it creates
14:58:22 <aavogt> or are there cases with X being extremely likely to be exactly 30
14:58:26 <Cale> I also think that a lot of the problems regarding lazy IO just stem from poor OS design.
14:58:28 <Zao> aavogt: Probably, at least not when non-discrete.
14:58:47 <Cale> Like, only being able to open a tiny number of handles.
14:58:53 <Zao> In this case it's uniformly distributed, so highly neglible.
14:58:53 <mux> iteratees require that you code in a special way, unlike lazy IO
14:58:57 <Cale> (because select is dumb)
14:59:09 <Peaker> Cale, That's not the issue -- there's the issue of mutability and visibility of effects such as reading/closing files
14:59:11 <mux> Cale: this isn't really a select() problem
14:59:19 <Peaker> mux, purity requires that you code in a special way
14:59:26 <Peaker> mux, But being in #haskell I suppose you like it
14:59:37 <aristid> Cale: well haskell could use epoll instead
14:59:43 <aristid> or kqueue
14:59:53 <Peaker> Cale, The FD leak is not the only issue..
14:59:56 <mux> or any stateful multiplexing interface
15:00:08 <ddarius> aristid: The issue is that continuations are very powerful and its not common that you need their full power.
15:00:15 <aristid> mux: i wish all systems had simply implemented kqueue
15:00:17 <Cale> aristid: and GHC will be soon enough, but as far as I know, it doesn't change the draconian limitations on open file descriptors?
15:00:23 <mux> Peaker: yes but I'm talking about haskell only, not haskell and some other language - that is, iteratees require me to code in a special style within haskell
15:00:25 <aristid> epoll works but it's a pile of shit compared to kqueue
15:00:28 <mux> aristid: I so wish that too.
15:00:32 <mux> epoll() sucks design-wise
15:00:33 <gwern> why do we have so few file handles anyway?
15:00:48 <mux> aristid: but people just use libev/libevent anyways, and I'm fine with that.
15:00:53 <aristid> Cale: i think you can lift them with ulimit or so
15:00:54 <pikhq> gwern: Legacy.
15:01:04 <mux> gwern: fds cost kernel resources
15:01:14 <mux> those are not to be taken lightly
15:01:28 <gwern> mux: so do processes, but we don't worry about not being able to spawn them
15:01:33 <mux> yes we do
15:01:45 <mux> this is why there are ways to limit them, because.. you know... fork bombs.
15:01:46 <Peaker> mux, They just make the effects explicit in IO -- because their order does matter.. Saying it does not and letting evaluation drive them is IMO pretty much the same as impurity in other languages (convenient at first, leads to problems, later)
15:01:52 <aristid> i remember the fun of getting "could not fork" errors in some c++ program
15:02:10 <mux> Peaker: here I totally agree - this was what I meant when I said "this conveniency may be a lie"
15:02:11 <Peaker> aristid, Why is kqueue better than epoll? I know a bit about epoll (seems terribly complex) and almost nothing about kqueue
15:02:28 <soupdragon> What is everyone doing with haskell
15:02:29 <soupdragon> ?
15:02:32 <soupdragon> why do you program haskell
15:02:33 <mux> Peaker: epoll() only deals with file descriptors still; which is stupid if you want to block on other things.
15:02:35 <soupdragon> what are you writing people
15:02:46 <mux> Peaker: this is why Linux needed to implement signalfd()
15:02:50 <aristid> Peaker: well, kqueue has better signals/timer stuff, and it has a slightly nicer interface
15:03:03 <aristid> also kqueue predates epoll and does everything epoll does
15:03:13 <aristid> so there was NO NEED to create a new API...
15:03:15 <gwern> soupdragon: I program in haskell because I have vowed to save all sentient beings
15:03:19 <Peaker> mux, "unsafeInterleaveIO" (lazy I/O) is basically saying: Expect no determinism at all from the times when these effects will be executed.. These effects are often both: A) visible (when you read or close a pipe, it is visible)  B) depend on world state (A file can change as you read it)  -- so this non-determinism is just wrong
15:03:24 <aristid> just implement friggin kqueue, but linux... oh well
15:03:35 <Peaker> aristid, :-(
15:03:35 <mux> aristid: but we're all very acustomed to the NIH-syndrom accursed Linux devs
15:03:45 <Cale> Peaker: there are a large number of cases where a program reads files that it won't write and which won't be expected to change during the program's execution, and for all those cases, lazy I/O would be fine apart from the FD problem, which limits the number of files one could sensibly open that way.
15:04:03 <aristid> mux: i mostly stay away from monitoring kernel development.
15:04:24 <Peaker> Cale, Can you give some examples of that?
15:04:50 <aristid> Cale: couldn't lazy I/O somehow magically close and open files? :D
15:05:06 <Cale> aristid: That's a good point, maybe it could.
15:05:12 <mux> Cale: I think that (in general) not being able to precisely know when resources are deallocated rules out a fair number of programs
15:05:36 <mux> and Oleg's paper specifically mentions the case of long-running server-type applications
15:05:37 <RyanT5000> i want a lazy IO library that gives me pure access to filesystems
15:05:45 <Cale> mux: The only reason we care so much is because the resources (FDs) are so ridiculously limited.
15:05:52 <RyanT5000> perhaps using ZFS/btrfs/etc.'s instant snapshotting capability
15:06:01 <mux> Cale: they're not really ridiculously limited
15:06:12 <gwern> RyanT5000: you confused me there for a moment - thought you were referrng to oleg's zfs
15:06:26 <mux> they're limited for a good reason, and that being said, most modern OSes (Linux and FreeBSD) come to mind, can dynamically resize the fd table capacity
15:06:38 <RyanT5000> gwern: nope; Sun/Oracle ZFS
15:06:45 <Cale> mux: If I could just fill memory with as many FDs as I could create, I would never have cause to care that I was creating so many.
15:06:48 <copumpkin> RyanT5000: that would be neat
15:07:01 <RyanT5000> yeah
15:07:05 <RyanT5000> and then you could integrate STM
15:07:10 <RyanT5000> with a transactional filesystem!
15:07:11 <Cale> Just let the garbage collector pick things up as usual.
15:07:13 <aristid> Cale: if your program could shut down the whole system that way, it wouldn't be fun
15:07:14 <RyanT5000> or a database
15:07:28 <RyanT5000> though, frankly, i haven't seen a great Haskell representation of a database-like structure
15:07:34 <mux> Cale: you're still not thinking about the kernel, which has to allocate a potentially very large structure for every fd
15:07:38 <RyanT5000> there's HAppS's IxSet
15:07:44 <RyanT5000> which i haven't looked at in a while
15:07:47 <aristid> RyanT5000: LVM has snapshots too
15:07:50 <mux> Cale: and you cannot handle memory that liberally in the kernel
15:08:02 <RyanT5000> aristid: are they cheap?
15:08:05 <ddarius> RyanT5000: I haven't seen too many database-like structures period in any language.
15:08:07 <mux> what do you do when you exhausted kernel memory? you call panic()
15:08:15 <mux> so you better not
15:08:20 <aristid> RyanT5000: they slow down writing drastically  but i don't think the others can be much better
15:08:22 <RyanT5000> ddarius: that's true; is there a good reason we can't have those?
15:08:22 <gwern> RyanT5000: oleg's zfs is basically a transactional fs, iirc
15:08:27 <Cale> mux: As far as I'm concerned, that's a design problem with the kernel.
15:08:40 <aristid> RyanT5000: i mean ultimately all the implementations of snapshots do roughly the same stuff
15:08:40 <RyanT5000> aristid: ZFS's snapshots are supposed to be very fast
15:08:51 <mux> Cale: well you're welcome to come and correct all those badly designed open-source OSes :-)
15:08:52 <RyanT5000> aristid: yes, but they're journal-based in the first place
15:08:55 <aristid> RyanT5000: you'd need to actually compare...
15:09:00 <mux> Cale: I beg to differ, this isn't an easy matter
15:09:05 <Cale> mux: There's no real reason that we shouldn't be able to hold open lots of files, if you consider all possible ways to design the system.
15:09:07 <RyanT5000> aristid: of course
15:09:40 <Cale> mux: Can you think of one, perhaps?
15:09:47 <aristid> RyanT5000: lvm snapshots are pretty elegant imho
15:09:51 <mux> Cale: I thought I gave one already (honest)
15:09:58 <RyanT5000> aristid: however, a COW filesystem does have two advantages: more logical information about what's going on and more liberties with what it provides to things that use it
15:10:18 <tag> Can anyone suggest a program to read, of medium complexity, that is well commented and uses a good set of haskell features?  Something that would help answer some holistic questions about the general anatomy of a system built in haskell, without being completely overwhelming?
15:10:18 <RyanT5000> i'd assume that LVM is more constrained on both of its major interfaces
15:10:29 <gwern> tag: xmonad
15:10:35 <aristid> RyanT5000: LVM does it block-wise afaik
15:10:37 <ddarius> RyanT5000: A query language interface isn't usually particularly efficient and is often overly general.  In the case of actual databases the former is mitigated by the scale of processing and the latter by the relatively strong separation of concerns.
15:10:48 <Cale> mux: What you said doesn't sound like a universal problem, perhaps I misunderstand you.
15:11:01 <tag> A window manager, that actually looks like it would be a reasonable example.  Thank you gwern.
15:11:07 <mux> Cale: think that when you allocate a fd, you fill it with many parameters, buffers and what not; pointers to read()/write()/fcntl() handling functions, you initialize mutexes and/or condition variables, etc
15:11:15 <gwern> tag: be sure to read dons blog posts about zippers
15:11:20 <tag> especially if it doesn't have too many damned features :-)
15:11:38 <mux> Cale: an fd may be just an int in userland, but it really takes room in the kernel
15:11:47 <Cale> mux: Okay, why is that a problem? I have lots of memory.
15:12:02 <Cale> Why can't I allocate as many of those as I have memory for?
15:12:09 <aristid> the limit should be more than 1024 for sure
15:12:10 <RyanT5000> ddarius: sure, but surely we could get something closer to a table without ruining performance
15:12:24 <mux> Cale: as I said, you cannot handle memory that liberally and easily in the kernel; if you run out of it, most of the time, it'll cause a panic()
15:12:28 <tag> gwern: oh this is a very fine example indeed.
15:12:33 <arw> Cale: in many operating systems, certain operations are O(n) where n is the number of file descriptors a process has.
15:12:36 <Cale> mux: I'm not talking about linux specifically.
15:12:45 <aristid> Cale: that said, a limit of maybe 1M might be a good idea anyways
15:12:45 <mux> Cale: I'm not either
15:12:45 <Cale> mux: I'm talking about in an arbitrary operating system.
15:12:49 <mux> okay.
15:12:57 <ddarius> RyanT5000: Logic languages accomplish something vaguely like that.
15:13:00 <aristid> Cale: to prevent the system from getting bogged down by a single process
15:13:14 <Cale> Suppose we can design the system however we like. Why can't we design it so that this is not an issue?
15:13:26 <aristid> no idea.
15:13:33 <mux> Cale: considering an arbitrary operating system, with totally new APIs and not POSIX ones, I guess you can do many things to alleviate the problems, but it would still be wise to enforce a limit
15:13:36 <matt_m> aristid: Let's make it 1234567.  That'd be a good number of file descriptors
15:13:42 <ddarius> Namely, design it so that the memory is taken from the process so the process only runs out of -its- memory.
15:13:46 <aristid> matt_m: yes.
15:13:56 <mux> ddarius: heh, like that is easy.
15:14:03 <aristid> matt_m: well, let's be generous. 1234568
15:14:11 <arw> ddarius: which does exactly what ulimit currently does
15:14:19 <Cale> mux: Sure, but I think we could do a *lot* better than we currently get ;)
15:14:29 <arw> ddarius: you allow a certain number of file descriptors for a certain process.
15:14:36 <mux> Cale: I'm sure we can do better, I think we always can :-)
15:14:39 <Cale> (sufficiently so that this file descriptor issue just wouldn't be a concern for most programs)
15:14:46 <copumpkin> let's start a purely functional OS project!
15:14:59 <copumpkin> not house
15:14:59 <mux> but I don't think even that unrealistic goal would be the perfect cure for lazy I/O
15:15:13 <ddarius> arw: I'm saying allow as many file descriptors as the process can fit in its address space.  Limit memory then if you want, but there's no reason to limit file descriptors.
15:15:36 <arw> ddarius: there is. file descriptors can't ever live in a processes address space.
15:15:37 <gwern> copumpkin: let's get a copy of the haskell version of l4 and work from there instead
15:15:45 <ddarius> arw: Why not?
15:15:48 <matt_m> aristid:  Well, 1048576 is a power of 2.  Should probably stick with that, for performance reasons
15:15:54 <mux> Cale: I can imagine many schemes where the resource lazy IO holds on to is not a file descriptor. what then?
15:16:16 <Cale> mux: There are certainly things which lazy IO is just totally unsuited for.
15:16:18 <mux> Cale: what if I have some kind of a handle to a database connection, and I gather results via lazy IO?
15:16:19 <arw> ddarius: because they are kernel datastructures which no process should ever be able to touch?
15:16:36 <mux> Cale: should we redesign all the db software to not be pesky about open connections too? :-P
15:16:37 <mightybyte> Does Cabal/cabal-install have some kind of behavior that searches for .cabal files in subdirectories of the project?
15:16:38 <arw> ddarius: because processes must be able to share fds?
15:16:49 <Cale> mux: I'm talking about the situations where lazy IO would seem appropriate and yet isn't.
15:17:10 <ddarius> arw: I'm not talking about Linux.  And in general neither of those preclude the kernel allocating the memory away from the process.
15:17:14 <aristid> matt_m: 1048575, for the trailing zero.
15:17:22 <Cale> mux: Well, that's probably the case, though lazy I/O is more questionably suited to database access.
15:17:41 <mux> I suppose that lazy I/O would be a lot more usable if there was a way to say "from that point forward the resources allocated by that lazy IO call should be released"
15:18:06 <mux> Cale: I think lazy I/O is unsuited to anything that involves resources, because resources being what they are, you sometimes have to release them ;-)
15:18:18 <Cale> mux: It would also be a lot more usable if there was a way for the resources attached to be better-managed.
15:18:19 <aavogt> mux: that way is by forcing the calculation you did with the results of your IO
15:18:46 <matt_m> aristid: done
15:18:48 <Draconx|Laptop> ddarius, no, but hardware limitations might, assuming you care about your OS performing well.
15:18:49 <arw> ddarius: you can of course decrease the free memory a process will be able to obtain. thats even possible in current operating systems, with a little tweaking. but in any arbitrary operating system, file descriptors will always have to be in kernel.
15:19:01 <tag> :t inc
15:19:02 <lambdabot> Not in scope: `inc'
15:19:26 <mux> Cale: this is where you are supposed to have genius kind-of-moment and come up with some new I/O primitive that would obsolete both iteratees and lazy I/O
15:19:26 <Cale> (like, opening and closing certain resources as appropriate/possible -- or at least having resource problems trigger a garbage collection)
15:19:31 * mux stares at Cale intensely
15:19:42 <mux> please do.
15:20:59 <Cale> I don't think iteratees are completely the wrong idea. It's just that every presentation of them that I've seen has been much too complicated to be right. :)
15:21:03 <matt_m> arw:  An arbitrary operating system needn't have either file descriptors or a kernel...
15:21:15 <ddarius> arw: I'm not saying give the process direct access to the internals of the FD, just account for the memory against the process.  Then there is no reason to limit file descriptors.  If a process wants to open a million, it can go ahead.  Its only hurting itself.
15:22:02 <mux> ddarius: hardware paging does force you most of the time to treat kernel memory and userland memory as two really different, isolated things
15:22:49 <mux> ddarius: it's not like the kernel can touch any process' memory "like that"
15:23:16 <mux> and you don't want the userland process to be able to tamper with kernel-private data, which could leave you in an unstable state
15:23:40 <mux> which further complicates the problem, possibly *ruining* performance on some architectures if you need to enforce this
15:24:05 <mux> and unless you're coding a toy OS, you do need to enforce it :-P
15:24:16 <ddarius> mux: On the x86 and at least a few other architectures, you can mark pages as user/supervisor per page.  Also, the mechanism could be similar to current mmap and virtual memory things.
15:24:24 <RyanT5000> alright, i'm off
15:24:54 <RyanT5000> for anyone new, my company writes video games in Haskell! email me at ryan@ipwnstudios.com if you're interested in a job
15:25:25 <mux> ddarius: as you said, "on some architectures"
15:25:36 <mux> but in general, you cannot
15:25:59 <mux> and the mechanism can't really be similar to mmap()
15:26:44 <mux> most importantly, you'd just ruin performance for sure
15:27:01 <EvanR-work> a job making games in haskell?
15:27:04 <EvanR-work> he must be phising
15:27:27 <ddarius> I doubt that that's for sure even doing it portably though the naive way is likely "for sure" on some architectures.
15:27:37 <jkingkong> Question, if I put objects in a Data.Map in ascending order of the keys, will the "maxKey" function be in O(1) time?
15:27:46 <jkingkong> normally, it's O(log n)
15:27:59 <ddarius> jkingkong: Just assume it won't be.
15:28:01 <jkingkong> but I was wondering if anybody knew the implementation of the top of his head
15:28:20 <jkingkong> ddarius: is there a reason?
15:28:20 <EvanR-work> better idea, but the objects into a list in ascending order, now max is definitely O(1)
15:28:21 <ddarius> jkingkong: The implementation is a balanced ordered tree so it probably won't be.
15:28:35 <mux> ddarius: well that's my opinion as former kernel developer :-P
15:28:38 <ddarius> jkingkong: The reason is you generally don't assume implementation details.
15:28:46 <jkingkong> oh I see, I wasn't sure whether it was a normal binary tree or whatever
15:29:01 <EvanR-work> jkingkong: well its an abstract data type
15:29:13 <jkingkong> EvanR-work: I would use a sorted list but I need to access other values in Log n time preferably
15:29:26 <EvanR-work> what about Data.Sequence
15:29:26 <mux> imagine a poll() or select() call, needing to copy potentially several pages of fd-specific data in order to be able to get a hold on it
15:29:29 <arw> ddarius: you can account that memory on a process, true. but its always necessary for the kernel to iterate over the list of file descriptors of a process, for example to decide wether to schedule a process for running because it might get input from a blocking fd. and that will get more expensive for the kernel.
15:29:39 <jkingkong> EvanR-work: thanks I'll look into that
15:30:06 <arw> matt_m: an arbitrary sorting algorithm might still not be faster than O(n log n)...
15:31:01 <arw> matt_m: there are certain things your operating system will always need to do. one of the most basic is "moving data to and from processes"
15:31:21 <tag> Once I come to understand what all this syntax actually means, in terms of relative semantic, I will have to dissect the output of ghc to understand what it means in terms of machine instruction.
15:31:36 <mightybyte> Does cabal recursively execute .cabal files in subdirectories?
15:31:38 <ddarius> mux: Do you think it is possible to securely and efficiently provide an interface that would allow potentially application-specific filesystems?
15:31:52 <mux> ddarius: besides, you still need to address this data, whether it's attributed to the process or not; so you need the address space at some point, so you're equally likely to run out of the KVM, which isn't going to be pretty at all
15:32:06 <mux> ddarius: doesn't fusefs do that already?
15:32:10 <mux> in some kind of way.
15:32:29 <Cale> tag: which syntax? Haskell syntax?
15:32:31 <mux> fusefs offers a consistent API through a kernel module, which allows userland filesystems to be plugged in
15:32:39 <mux> it works on BSD, Linux, lalalaa
15:32:39 <tag> yes
15:32:53 <tag> haskell syntax.
15:33:07 <Cale> tag: Let us know if you have any questions about it...
15:33:45 <Cale> http://cs.anu.edu.au/student/comp1100/haskell/tourofsyntax.html -- there's a nice quick tour/cheat sheet of the main syntactic features of Haskell here
15:34:23 <pikhq> tag: Looking at the output of GHC almost certainly will not help you.
15:34:33 <Cale> It doesn't account for extensions
15:34:37 <tag> pikhq: I'm just dying to know what this really means
15:34:40 <tag> :-)
15:34:43 <pikhq> GHC does some rather stunning transformations on your code.
15:34:46 <Cale> tag: Something in particular?
15:34:53 <Cale> tag: Or just generally? :)
15:35:12 <Cale> tag: Toy models are usually a lot nicer to work with than what the real machine does
15:35:31 <pikhq> tag: If GHC knows how to, it will *gladly* replace some code with code that produces the same value.
15:35:37 <tag> that is true, toy models tend to be easier to deal with.
15:35:41 <Cale> tag: When I think about how Haskell code is being evaluated, I rarely go any lower-level than to think about expressions being rewritten into other expressions.
15:35:51 <ddarius> mux: Does fuse provide a means of multiplexing the hard disk or is it just a way to add "virtual" trees to the file system and if you want hard disk backing you use a file?
15:36:09 <pikhq> For instance, it's perfectly feasible for "sum [1..100]" to get replaced with a constant.
15:36:10 <Cale> tag: Occasionally, I'm forced to notice that expressions are really graphs at runtime, and not trees.
15:36:11 <tag> pikhq: It's true that the compiler optimizations may obfuscate the relative impact, I'm sure there are no shortage of scenarios
15:36:43 <pikhq> tag: There's optimizations pretty much of the time.
15:36:57 <mux> ddarius: AFAIK, and I haven't looked at it in details, fuse just allows you to plug-in userland filesystems; that is, filesystems that will get mounted like any other, that you access via the usual system calls and so on, so it's transparent to other userland applications.
15:37:18 <mux> ddarius: what do you mean by multiplexing the hard disk?
15:37:32 <mux> logical volume management and the like?
15:37:49 <gwern> pikhq: feasible, but I'm pretty sure ghc doesn't do that much partial evaluation
15:37:57 <Cale> tag: The most useful description of how Haskell code is probably going to evaluate is just to assume lazy evaluation, which just means that expressions are evaluated outermost-first, and that parameters to a function which occur more than once in the body will share any evaluation which is done to the argument between the copies.
15:38:42 <Cale> tag: If you want, I could type out some examples of evaluating an expression under strict evaluation (innermost-first), plain outermost-first evaluation, and lazy evaluation.
15:39:48 <soupdragon> what should I write a tutorial about
15:39:52 <_nickel> has anyone worked with Text.JSON
15:40:06 <Cale> tag: One thing about Haskell is that despite the fact that everyone talks about laziness, it's actually not specified what order expressions get evaluated in, and any order which terminates as much as possible is acceptable. (Strict evaluation will sometimes not terminate when it should, so totally strict evaluation is not allowed)
15:40:15 <pikhq> _nickel: I'm sure several people have.
15:40:29 <_nickel> pikhq: I never know how to begin :P
15:40:30 <ddarius> mux: A single hard disk is a single global resource.  Various processes will want to use it and so you'll need some way of sharing it without them being able to interfere with each other.  The typical way this is done is with a kernel controlled file system.
15:40:49 <Cale> tag: The compiler really does take advantage of this though, and reorders evaluation sometimes when it can prove that there will be no problem in doing so.
15:41:54 <mux> ddarius: so you really were looking for a way to access a disk "raw", and deal with that yourself?
15:41:59 <_nickel> pikhq: I'm confused on why JSObject is recursive
15:42:31 <ddarius> mux: As raw as possible while still being secure and performant, yes.
15:42:39 <_nickel> s/on w/. W/
15:42:52 <_nickel> pikhq: urg
15:42:57 <mux> ddarius: without going into the micro-kernel designs on architecture that support different privilege levels, this is going to be... annoying
15:43:13 <ddarius> mux: Well, it's been done.
15:43:22 <mux> you'll need to access the disk controller; there would be no way to even limit yourself to a single hard drive
15:43:36 <mux> that means talking to it via the MMIO interface
15:43:53 <mux> but then again, how will you acknowledge interruptions? etc
15:44:14 <_nickel> pikhq:  I guess I could understand if it was recursive like JSObject (JSValue, JSValue, JSObject)
15:44:19 <mux> well, afaik, micro-kernels are still forced to delegate a lot of things up to the lowest levels.
15:44:38 <ddarius> mux: Have you read the papers (theses) on Xok?
15:44:48 <mux> nope
15:45:00 <ddarius> mux: I highly recommend that you do at some point.
15:45:09 <Cale> tag: http://cale.yi.org/share/fib.png -- an example I drew up a while back of some of what might happen in a toy model Haskell evaluation. These graph transformations actually closely resemble what goes on in memory.
15:45:27 <soupdragon> help
15:45:47 <mux> ddarius: I'm not much into kernel coding anymore, haven't done anything in like two years now.
15:46:08 <gwern> mux: microkernels? no one cares about those; exokernels are more interesting!
15:46:21 <ddarius> mux: http://pdos.csail.mit.edu/exo/theses/engler/thesis.ps This one in particular.  The techniques used are interesting in general and applicable beyond just kernel coding.
15:46:35 <mux> gwern: I don't care much about mks :-P
15:46:42 <Cale> tag: This represents the evaluation of the expression (fib 0 1 3), with the program  fib a b 0 = a; fib a b n = fib b (a+b) (n-1)
15:46:50 <gwern> you may not care about war, but war cares about you
15:48:44 <sinelaw> ahola
15:49:24 <soupdragon> bhuhoi
15:49:53 <sinelaw> 'sup?
15:50:02 <soupdragon> urhg i feel shit
15:50:22 <Cale> It's much too hot here.
15:50:55 * Cale is not ready for 29 degrees C.
15:51:02 <sinelaw> 29 is cool
15:51:16 <Cale> Yeah, for you maybe. :)
15:51:42 <Cale> In Israel, I'm sure it is ;)
15:51:54 <sinelaw> well, maybe not "cool", but not too bad
15:52:16 <mux> at least you're living in a civilized country that uses the metric system :-)
15:52:18 <Cale> 19 is my ideal operating temperature
15:52:34 <sinelaw> yeah
15:52:36 <Peaker> I just encountered a disadvantage of too-general a type: GHC 6.12 thinks my action returns an "a" when it returns () and thus complains about ignoring its result
15:52:45 <soupdragon>  i couldn't sleep
15:53:05 <Cale> actually, sometimes I like it a bit cooler than that, 17 is nice too
15:53:16 <sinelaw> 17 is winter, as in ice
15:53:21 <Cale> heh
15:53:26 <sinelaw> :P
15:53:28 <dolio> That sounds more like a disadvantage of having that silly warning.
15:53:46 <sinelaw> i was working and network connection to work failed
15:53:50 <Peaker> dolio, well, the warning is nice :)
15:53:54 <Peaker> dolio, it caught some real bugs!
15:53:55 <sinelaw> so i have no choice but to stop
15:54:16 <dolio> Not for me it hasn't. :)
15:54:24 <Cale> It's not really winter until snow will stick to the ground.
15:54:35 <Peaker> dolio, But I guess it really only makes sense in a case where there's a sum type somewhere in there, or there's no information you can extract out of it
15:54:40 <copumpkin> omnom
15:54:45 <Peaker> dolio, Maybe that's too complicated to figure out
15:56:17 <ksf> If I had to rate my haskell aptitute on a scale from 1 to 10, how would I do that?
15:56:35 <mux> on a scale from 1 to 10, I'm yellow.
15:57:42 <soupdragon> 1 - you did porject euler
15:57:45 <soupdragon> 2 - you used fold
15:57:51 <soupdragon> 3 - you defined your own data types
15:57:59 <soupdragon> 4 - you used typeclasses in a stupid way
15:58:13 <soupdragon> 5 - you used ST and didn't get compile errors
15:58:20 <soupdragon> 6 - you understand GADTs
15:58:28 <soupdragon> 7 - you ACTUALLY understand GADTs
15:58:37 <mux> 42 - Oleg calls you for hints & advices
15:58:39 <ksf> erm where's the difference?
15:58:42 <soupdragon> 8 - you actually read academic papers about theoretical computing topics
15:58:47 <soupdragon> 9 - you write something useful
15:58:56 <soupdragon> 10 - nirvana
15:59:05 <ddarius> 10 is always "Your name is Simon."
15:59:10 <mux> hahaha
15:59:13 <wli> That's a rough ranking scale.
15:59:31 <copumpkin> ksf: I'm going to make a haskell achievements site eventually
15:59:34 <ksf> we can't have so many people at 9
15:59:35 <copumpkin> it's on my todo list
15:59:48 <copumpkin> like xbox achievements of ps3 trophies ;)
16:00:00 * mightybyte thinks soupdragon's scale needs to be higher
16:00:08 <mux> we need much more levels
16:00:09 <soupdragon> 11 - Audrey Tang
16:00:41 <aristid> soupdragon: that scales are a bit hard to read
16:01:06 <aristid> soupdragon: what if i have read academic papers (well, one at least) but am otherwise at 4?
16:01:13 <soupdragon> 4
16:01:27 <aristid> :(
16:01:55 <mux> are we required to finish the entire problems of PE to reach level 2?
16:02:00 <aristid> soupdragon: also means that if you write something useful but don't understand GADTs, you'r 5 at max?
16:02:06 <mux> because, you know, I'm still at only 141 problems solved :-P
16:02:07 <soupdragon> yes
16:02:12 <mux> damn.
16:02:15 <aristid> oh
16:02:20 <aristid> i'm at level 0
16:02:35 <aristid> i guess Cale is at that level too, which is comforting
16:02:38 <mux> err, yes, s/1/0/
16:03:02 <mux> int-e qualifies for level 1
16:03:23 <aristid> mux: int-e?
16:03:30 <ksf> shouldn't 5 be "you understand when and why you need UndecidableInstances"?
16:03:34 <mux> @seen int-e
16:03:35 <lambdabot> Unknown command, try @list
16:03:53 <mux> I would have sworn there was a @seen command
16:03:57 <mux> @last int-e
16:03:57 <lambdabot> No module "int-e" loaded
16:04:04 <Saizan> there was.
16:04:09 <Saizan> preflex: seen int-e
16:04:10 <preflex>  int-e was last seen on #haskell 11 hours, 58 minutes and 24 seconds ago, saying: scree: heh. "large enough" = Steve Jobs has it on his iPhone and enjoys the game? ;-)
16:04:30 <aristid> int-e actually solved all project euler problems?
16:04:43 <mux> he sure did, they keep adding new ones, so I'd have to check
16:04:55 <aristid> mux: in case of doubt he's level 0
16:05:05 <mux> hahaha.
16:05:16 <aristid> haskell is very egalitarian: everybody (well, almost) is at the lowest level
16:05:39 <sinelaw> i didn't solve even one
16:05:55 <aristid> sinelaw: level 0.
16:06:05 <mux> aristid: he's at 234, and there are now 293 problems!
16:06:42 <Peaker> @hoogle modifySTVar
16:06:42 <lambdabot> No results found
16:07:00 <aristid> mux: that's pretty much not all of them.
16:07:11 <sinelaw> i think i'll stay comfortably at 0
16:07:16 <mux> aristid: yes, but it used to be :-)
16:07:43 <wli> I'm not sure Project Euler is all that great a metric for programming anything (or, for that matter, a number of the other things).
16:07:55 <mux> wli: oh, we do it for fun
16:08:07 <mux> if you like coding, and you like math, it's a killer
16:08:20 <sinelaw> killer indeed
16:08:27 <sinelaw> #haskell conversation killer
16:08:57 * soupdragon doesn't like the math on project euler, too hard - I can't solve them and it makes me feel bad
16:09:39 <aristid> soupdragon: that's why you, too, are stuck.
16:09:59 <wli> Depends on what kind of math you're interested in. Anyway, I'd use vastly different programming metrics to "rank people."
16:10:29 <Cale> soupdragon: I dislike the math there for an entirely different reason.
16:10:37 <wli> The Project Euler stuff is a sort of "math" that I don't find very interesting.
16:11:10 <Cale> wli: yeah, I agree
16:11:28 <Cale> All the problems have a number as their solution :P
16:11:28 <sinelaw> exactly
16:11:47 <sinelaw> more like arithmetic
16:11:54 <pikhq> A computable number, no less!
16:11:58 <Cale> Very few genuinely interesting problems have a number as their solution.
16:12:06 <Axman6> dons: are you around?
16:12:16 <Peaker> Cale, But you could usually perform some kind of "hash" on the interesting problem's solution to get a number, right?
16:12:27 <pikhq> Cale: Many of them have a number as a valid solution.
16:12:35 <Peaker> Cale, (e.g: Take the resulting equation and try it on some given number)
16:12:41 <pikhq> Though said number may just be the TeX document of the solution.
16:12:42 <pikhq> :D
16:12:53 <sinelaw> Cale: Godel numbers? :)
16:13:08 <pikhq> sinelaw: Only works for things that are computable.
16:13:11 <aristid> i think Gdel should be transliterated Goedel
16:13:29 <ksf> aristid, you think correctly.
16:13:42 <sinelaw> prove that you can't prove it
16:13:54 <soupdragon> Prove 7
16:14:01 <aristid> i don't like that umlauts are often transliterated by just dropping the dots
16:14:12 <aristid> as if they were unimportant /o\
16:14:19 <soupdragon> they are unimportant to me
16:14:50 <soupdragon> foreign pronunciation seems utterly arbitrary, what effect could these extra markings possibly have
16:14:51 <soupdragon> ?
16:15:02 <ksf> erm
16:15:16 <aristid> soupdragon: german pronunciation is a lot more regular than english pronunciation, at least.
16:15:17 <ksf> well, in english it's not the pronounciation that's arbitrary but the spelling.
16:15:20 <theorbtwo> That's because you don't know that goedel is properly pronounced something like gurdel.
16:15:36 <soupdragon> godel sounds nicer than GURGLE
16:15:49 <aristid> because it's not gurgle but GDEL
16:15:55 <sinelaw> if i have no idea what the umlauts mean i might as well drop them
16:16:09 <aristid> sinelaw: or transliterate them according to the rules
16:16:17 <aristid> ->ae, ->oe, ->ue
16:16:23 <aristid> ->ss
16:17:13 <ksf> there's definitely no "r" in there.
16:17:31 <Cale> Well, okay, you could always *encode* the solution to an interesting problem as a number, but that doesn't mean that it's the most natural way to write it :P
16:17:34 <aristid> http://upload.wikimedia.org/wikipedia/commons/f/fd/Kurt_g%C3%B6del.ogg
16:18:04 <sinelaw> nah
16:18:07 <soupdragon> @let transliterate = ((let t ''="ae"; t ''="oe"; t ''="ue" ; t x = [x] in t) =<<)
16:18:08 <lambdabot>  Defined.
16:18:20 <soupdragon> > transliterate "Gdel"
16:18:21 <lambdabot>   "Goedel"
16:18:29 <aristid> lol
16:18:45 <mauke> warning: that system only works for german
16:19:02 <arw> soupdragon: ''="ss" is missing
16:19:11 <Philonous> Why can't I use "|" as an operator?
16:19:15 <soupdragon> serves it right for being on it's own line
16:19:17 <pikhq> Does not work for English.
16:19:21 <ksf> because it's pattern choice.
16:19:28 <Philonous> Ah right. Thanks
16:19:31 <Peaker> So when will Rank-2 types go into Haskell's standards?
16:19:34 <pikhq> (though the diaresis isn't commonly used in English any more...)
16:19:48 <Peaker> How can Haskell not have ST in its standard? :)
16:19:53 <aristid> Peaker: why not RankNTypes?
16:19:56 <Peaker> It's way too important :)
16:20:06 <Peaker> aristid, Well, the least radical thing that works for ST, I suppose
16:20:23 <pikhq> Peaker: Existentials.
16:20:29 <aristid> Peaker: why not be radical?
16:20:30 <Cale> Existentials?!
16:20:33 <Peaker> pikhq, what about them?
16:20:36 <pikhq> Erm.
16:20:41 <aristid> Cale: EXISTENTIALS!!
16:20:42 <pikhq> Never mind, I should shaddup.
16:20:43 <Cale> Peaker: You need at least Rank2Types for runST
16:21:02 <Peaker> Cale, thus: <Peaker> So when will Rank-2 types go into Haskell's standards?
16:21:06 <aristid> Peaker: ghc supports RankNTypes so it seems to be possible
16:21:20 <aristid> Peaker: why only Rank2 when you can have RankN?
16:21:26 <Cale> That was quite fancy at the time of Haskell 98 :)
16:21:38 <sinelaw> how about RankRTypes?
16:21:41 <Peaker> aristid, Why does GHC separate the two?
16:21:49 <sinelaw> or  RankCTypes?
16:21:53 <aristid> Peaker: noidea
16:21:53 <Zao> Different guarantees for 2?
16:21:59 <Cale> I believe some implementation only supported rank 2
16:22:01 <wli> Row kinds/types?
16:22:02 <Cale> Hugs?
16:22:03 <Zao> Doesn't N completely crush inference or something?
16:22:04 <pikhq> sinelaw: Computers hate non-computables.
16:22:11 <aristid> Peaker: i just know what the ghci autocompletion says
16:22:16 <sinelaw> pikhq, crybabies
16:22:20 <wli> Zao: They're only ever explicitly annotated.
16:22:55 <pikhq> Zao: The trick is to just say that inference is crushed, and move on.
16:23:12 * Zao stealthily enables impredicative types for pikhq 
16:23:14 <Cale> http://cvs.haskell.org/Hugs/pages/users_guide/quantified-types.html
16:23:29 <Cale> yep, hugs only supports rank 2 types
16:23:46 <wavewave> hello, anyone help me.
16:23:53 <wavewave> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25729#a25729
16:24:03 <wavewave> why does this have space leak?
16:24:40 <soupdragon> wavewave, because of the Put
16:24:51 <wavewave> ?
16:24:57 <soupdragon> change m `seq` put (m+1) to put (m+1)
16:25:01 <soupdragon> but use !Int instead of Int
16:25:22 <Cale> wavewave: What space leak?
16:25:47 <Cale> oh, stack
16:27:06 <Cale> soupdragon: What's !Int ?
16:27:11 <Philonous> soupdragon: You can add bangs to types?
16:27:17 <Cale> soupdragon: That would make sense inside a data declaration
16:27:20 <mux> not in type annotations
16:27:35 <wavewave> soupdragon: yes I got an error message.
16:28:07 <Cale> Switch to using the strict state monad.
16:29:07 <wavewave> Cale: Oh. Yes, it works. Thanks.
16:29:08 <Cale> also, it's not related to the problem, but  forM_ [1..n] (\_ -> x)  ==  replicateM_ n x
16:29:23 <wavewave> Cale: thanx. :)
16:30:29 <wavewave> Cale: so any accumulator type operation with huge number must be strict State Monad.
16:30:30 <wavewave> ?
16:33:53 <Cale> wavewave: Yeah, I think it's because what happens is that with the lazy state monad, you end up with lots of pattern bindings for pairs coming from the let expressions inside the definition for >>=
16:34:01 * syntaxglitch reminds himself that his rep on stack overflow is not a measure of his value as a human being, and does not warrant inordinate amounts of time spent on the site
16:34:32 <Cale> wavewave: and then, lazily at the very end, you need to evaluate one of the bound variables there (execState pulls out a component)
16:34:52 <Cale> wavewave: and this forces a tremendous number of pattern matches to occur all at once, and they all go on the stack
16:35:21 <Cale> wavewave: With the strict state monad, you instead have case expressions inside each bind
16:35:26 * copumpkin plays with impredicative Cot
16:35:27 <copumpkin> Cont
16:36:05 <wavewave> Cale: I see.. hard to get that point before I look at the code insdie state monad..
16:36:06 <Cale> and those force the pattern matches to occur "as you go" in a sense, so you don't end up with so many on the stack all at once
16:36:36 <Cale> (you'd have to do some evaluation by hand to really see what's going on)
16:37:20 <Cale> But the main difference between the lazy and strict state monads is this line...
16:37:28 <Cale> Lazy:
16:37:30 <Cale>     m >>= k  = State $ \s -> let
16:37:30 <Cale>         (a, s') = runState m s
16:37:30 <Cale>         in runState (k a) s'
16:37:36 <Cale> Strict:
16:37:41 <Cale>     m >>= k  = State $ \s -> case runState m s of
16:37:41 <Cale>                                  (a, s') -> runState (k a) s'
16:38:55 <wavewave> hmm.. this is really hard to see 'strictness'
16:39:04 <Peaker> Shouldn't it also "seq" the s' itself?
16:39:20 <Cale> Peaker: Nope, that's not what the 'strict' actually means :)
16:39:22 <wavewave> For me, it looks the same...
16:39:39 <Peaker> Cale, the strict state monad is about the tuple extraction being strict?
16:39:40 <Cale> The difference between let and case here is that the let does not cause runState m s to be evaluated
16:39:52 <wavewave> pattern matching /= let binding. hmm.
16:39:55 <Adamant> syntaxglitch: it's not uncommon for a lot of the high-ranking scorers at decent advice sites to be either retired or underemployed.
16:40:06 <Cale> Instead, it binds the variables a and s' so that if either of those are ever evaluated, the runState m s will happen *then*
16:40:56 <Cale> When you evaluate the case expression, on the other hand, it first forces the evaluation of runState m s, and pattern matches the result immediately.
16:41:26 <mux> IIRC, in the core GHC calculus, case is even the only construction that forces evaluation
16:41:30 <soupdragon> Universal Lambda Calculus
16:42:08 <mux> mm, I suppose seq is special too
16:42:12 <wavewave> mux: that means 'seq' is implemented as case statement??
16:42:22 <mux> wavewave: I don't think that's actually possible
16:42:29 <Cale> Now, that one case expression will go on the stack while the initial runState m s is evaluated, but that won't take long, since your >>='s will be nested so that the left hand side of each is a small amount of work
16:42:36 <mux> if you don't know the type, what can you pattern match it against?
16:42:36 <pikhq> wavewave: No, seq is magic from the runtime.
16:42:37 <Cale> So the stack never really builds up in the case version
16:42:55 <Cale> wavewave: seq *could* be implemented with case, for a lot of concrete types
16:43:16 <mux> case fromDynamic .. ?
16:43:17 <pikhq> The seq function as it stands cannot be written in Haskell.
16:43:21 <copumpkin> okay, impredicative Cont isn't working the way I wanted it to
16:43:24 <Cale> wavewave: But it's actually magic, and it works even for types like functions and IO
16:43:53 <wavewave> Cale: I see. thx very much for detail explanation.
16:44:01 <Cale> For instance, for Maybe, we could write  seq x y = case x of Nothing -> y; Just k -> y
16:44:14 <pikhq> One could do something like a seq :: (Seq s) => s -> a -> a
16:44:23 <mux> pikhq: it used to be this way
16:44:49 <Cale> There used to be an Eval class, but as far as we could tell the last time we looked in the old standards, seq was always magic.
16:44:50 <soupdragon> impredicative Cont is impredicative
16:45:12 <tag> Wow, I just discovered my congressman is the first openly atheist member of congress.
16:45:13 <mux> Cale: ah, ok
16:45:14 <Cale> But when it was a typeclass, there was less reason for that, other than just to make it work with functions.
16:45:23 <theorbtwo> tag: Good for him.
16:45:34 <pikhq> tag: Nice.
16:46:06 <tag> I like that idea just on principal, irrespective of any personal beliefs I or anyone else may have.  Diversity is good.
16:46:07 <Cale> wavewave: anyway, do you see what I mean about the let-bindings building up, and then at the very end, you end up doing a ton of pattern matches all at once?
16:46:14 <Cale> wavewave: It might be a little hard to "see"
16:47:01 <Cale> wavewave: The stack in GHC's implementation consists essentially of all the pattern matches which are waiting to happen because the thing they match on hasn't been evaluated enough yet.
16:47:16 <pikhq> tag: Yeah, there's been shockingly few non-Christian Congressmen. Quite odd when one considers just how diverse the US is, religion-wise.
16:47:25 <wavewave> Cale: yes. I got to understand that point.
16:47:59 * ksf utterly fails to describe his own haskell aptitude
16:48:20 <Cale> wavewave: anyway, there are clever uses for the lazy state monad, but for large computations like this, the strict one is usually better.
16:48:49 <tag> pikhq: exactly
16:49:17 <wavewave> Cale: hmm now I have another question.
16:50:28 <Cale> For example, consider this program:  foo = do foo; xs <- get; put (1:xs)
16:50:44 <Cale> That will work in the lazy state monad, but is impossible in the strict one
16:51:34 <aristid> @undo foo = do foo; xs <- get; put (1:xs)
16:51:34 <lambdabot> foo = foo >> get >>= \ xs -> put (1 : xs)
16:51:39 <wavewave> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=25730#a25730
16:51:39 <aristid> @. pl undo foo = do foo; xs <- get; put (1:xs)
16:51:40 <lambdabot> foo = fix ((put . (1 :) =<<) . (>> get))
16:51:54 <wavewave> would you tell me what is the problem in this code?
16:52:27 <Cale> wavewave: Would you save me the trouble of running it? What seems to be the problem with it?
16:52:41 <Cale> Stack overflow?
16:52:48 <wavewave> Cale: yes.
16:53:02 <kagami_> Hi. Does the strict pure version of Data.Map module exist? I tried Data.Array.Unboxed, but it doesn't have update/insert/delete operations
16:53:04 <Cale> Okay, that would be because you're building up giant expressions inside your Data.Map
16:53:30 <Cale> The value at the key 1 in your Map looks like ((...)+1)+1)+1
16:53:45 <Cale> and is 500000 levels deep before it gets evaluated
16:53:47 <wavewave> Cale: Yes..
16:54:19 <wavewave> Cale: so I have to strictify at every level ?
16:54:35 <wavewave> I do not have any clue..
16:54:52 <Cale> You should use insertWith'
16:55:00 <wavewave> aha...
16:55:39 <Cale> Not only does it have a bit of extra strictness which you need here, it also does what you want with fewer keystrokes :)
16:56:34 <Cale> wavewave: General rule of thumb for when you want strictness is wherever you're taking lots and lots of data, and summarising it down to a simple value with not many parts.
16:56:58 <Cale> (and not just by searching through the data, but doing something which really depends on all of it)
16:57:29 <Cale> So here, you're taking about 500000 1's, and adding them up, so you want that to be strict.
16:57:49 <wavewave> Cale: I learned a lot.. I am looking at the source of  insertWithKey'
16:58:06 <wavewave> Cale: now I understand the use of case..
16:58:50 <kagami_> Cale: I have similar trouble. insertWith' is strict, ok, but how about strict adjust and delete?
16:58:54 <Cale> wavewave: Well, yeah, it's generally just how we pattern match things.
16:59:13 <wavewave> I always got a trouble with 'seq'..
16:59:19 <Cale> kagami_: strict delete is unnecessary (it's already strict enough)
16:59:30 <kagami_> hmm
17:00:00 <wavewave> 'seq' was not enough for a certain strictness.. and I always frustrated to solve it...
17:00:01 <Cale> You're just deleting something from the map, there's no potential for a giant buildup of expressions inside the map when you do that.
17:00:23 <Cale> wavewave: and yet, along with a handful of functions which use it, it's usually enough.
17:00:41 <wavewave> Hmm now case is another way to enforce strictness... That's really a lesson!
17:01:03 <Cale> wavewave: Some people sledgehammer the strictness into their program by strictifying everything, but usually just one seq in the right place will fix the problem.
17:01:21 <wavewave> Thanx!
17:01:43 <Cale> It takes a while to get a feel for how the evaluation works, and where problems can occur, but eventually it gets easier :)
17:02:33 <Cale> kagami_: As for adjust...
17:02:56 <Cale> kagami_: I think it may be strict enough as well, because it *has* to evaluate the Maybe value which is the result of the function you give it.
17:03:19 <Cale> ... yes, it does, it uses a case expression to match it.
17:03:45 <Cale> So you can easily ensure that the thing you apply 'Just' to when you build the result of your function is already evaluated.
17:04:28 <Cale> er, sorry, I was looking at update
17:04:53 <Cale> Okay, a strict version of adjust might be handy
17:05:51 <Cale> adjustWithKey' :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
17:05:51 <Cale> adjustWithKey' f k m
17:05:51 <Cale>   = updateWithKey (\k' x' -> let y = f k' x' in y `seq` Just y) k m
17:06:03 <gwern> I wonder what happened to that tool which tried to use GAs to evolve optimal strictness annotations
17:06:10 <Cale> adjust' :: Ord k => (a -> a) -> k -> Map k a -> Map k a
17:06:10 <Cale> adjust' f k m
17:06:10 <Cale>   = adjustWithKey' (\_ x -> f x) k m
17:06:41 <wavewave> gwern: what is GA?
17:06:48 <Cale> genetic algorithm
17:07:08 <aristid> @unpl ((put . (1 :) =<<) . (>> get))
17:07:08 <lambdabot> (\ f -> (f >> get) >>= \ i -> put (1 : i))
17:07:25 <aristid> @. do unpl ((put . (1 :) =<<) . (>> get))
17:07:26 <lambdabot> (\ f -> do { i <- (do { f; get}); put (1 : i)})
17:08:03 <wavewave> By the way, how about having let' ?
17:08:44 <wavewave> syntatic sugar of strict  case matching.
17:08:45 <aristid> Cale: wow this recursive State monad forced me to bend my mind a lot
17:08:56 <gwern> syntactic sugar causes cancer of the exclamation...
17:11:23 <kagami_> Cale: hmm, looks like I don't completely understand strictness in haskell; if I have lazy values, but use Data.Map.update, will it be evaluted at point? my program looks like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25734#a25734
17:12:26 <Cale> kagami_: update can do both strict and lazy updates, because internally it is strict (pattern matches on) the Maybe value which is returned by the updater function you give it
17:13:00 <Cale> kagami_: But it only pattern matches on the constructor of that Maybe value (the Just or Nothing), and doesn't necessarily force the evaluation of the x in Just x
17:13:16 <Polarina> How do I efficiently send/recieve UDP packets using a ByteString?
17:13:26 <Cale> But you can make sure to write the function you give it in such a way that if it gets as far as the Just, the x will already be evaluated.
17:13:28 <wavewave> Haha.. I finally caught the memory leak problem in my research code.. So happy..
17:15:11 <kagami_> Cale: so I need something like x `seq` Data.Map.update (const $ Just x) key map ?
17:15:15 <Cale> kagami_: Something like  \x -> let y = f x in y `seq` Just y, or more succintly, \x -> Just $! f x
17:15:31 <Cale> kagami_: The seq goes inside the function that you pass to update
17:15:50 <kagami_> ok, thanks, I will try it
17:16:34 <Cale> kagami_: Oh, sorry, your example would work as well
17:16:41 <Cale> kagami_: In the case of a constant like that
17:17:03 <Cale> kagami_: But you shouldn't be using update for that, why not just use insert?
17:17:36 <Cale> insert again isn't strict, but doesn't need to be, you can force the value to be inserted beforehand.
17:18:17 <Cale> (like you did in your example)
17:18:20 <kagami_> why insert? because of strict insertWith' ?
17:18:55 <Cale> The strict insertWith' is only necessary because the value you're putting into the map isn't available at the place you call insertWith'
17:19:13 <Cale> (instead, it's being constructed from the value already in the map, and the value you're trying to insert)
17:20:14 <Cale> and so the difference between insertWith and insertWith' is that the latter will evaluate the result of the function before putting it into the map
17:20:31 <Cale> While the lazy insertWith will just stick the whole expression into the map without evaluating it.
17:20:44 <kagami_> And one more question about strictness. In rwh http://book.realworldhaskell.org/read/profiling-and-optimization.html it says what `seq` stops at the first constructor. But value what I want to insert is consist of several constructors. Will it work well?
17:21:53 <Cale> Well... you can always make sure that things are evaluated as far as you need them to be by using more seqs, or things built up from them
17:22:33 <Cale> There's a library called deepSeq, or Control.Parallel.Strategies has a (typeclass) function called rnf which will evaluate data structures more deeply
17:22:48 <Cale> I don't often find that I need them, but they're there.
17:23:20 <kagami_> Oh, thanks, forget about it.
17:23:31 <Cale> Well... hmm, how can I explain this...
17:23:46 <Polarina> Does Network.Socket work on windows?
17:24:11 <Peaker> Rank-2 polymorphism messes up refactorings like: f (g x) -> (f . g) x -- makes stuff less polymorphic when using (.)
17:24:17 <Cale> The reason that we don't need an insertWith' which is even stricter, is that you can always use one of these other things (or any of a number of other ways) to make sure that all the evaluation that you need happens, as long as evaluation gets started in the first place.
17:24:54 <Cale> Peaker: Yep. You can't write runST . foo or runST $ do ...
17:25:34 <Zao> Polarina: Naturally.
17:25:35 <Cale> Peaker: Though I think GHC has some weird exceptions to try to handle the latter awkwardly -- or maybe those are gone now, I'm not sure.
17:26:01 <Peaker> Cale, I was just messing around with SEC style for modifying my Image which has a polymorphic-on-s field in it
17:26:13 <Polarina> Zao, I know Network does, but does Network.Socket? Since the haddoc page says it's an interface to the POSIX functions.
17:26:31 <Peaker> Cale, and:  atMyField (inSomeThing x)  works, but (atMyField . inSomething) x  now doesn't
17:26:52 <Peaker> Maybe the type of (.) could be generalized for Rank-2 to work in all these cases?
17:26:55 <Cale> Peaker: atMyField is higher-rank?
17:27:04 <Zao> Polarina: Is it part of the network package of from some other bastard one?
17:27:05 <Cale> Peaker: Maybe, but it's hard to express.
17:27:16 <Zao> Polarina: I'm fairly sure that anything in network works.
17:27:22 <Zao> If it doesn't, I'd say it's a bug.
17:27:33 <Polarina> Zao, all right, thanks. :)
17:27:35 <Peaker> Cale, Yeah, it is higher-rank
17:27:36 <Cale> Peaker: Well, really the problem is that the typechecker *never* instantiates a type variable to a polytype
17:28:02 <kagami_> Cale: but we than Data.Map type in structure still be lasy. Does this mean that it should be declared as 'someValue :: !(Data.Map.Map a b)' ?
17:28:14 <kagami_> but then*
17:28:28 <Cale> kagami_: If you want it to be strict, then yes.
17:29:23 <Cale> kagami_: That is, if you want to make absolutely sure that when something pattern matches on your datastructure, the Data.Map field is evaluated and not just an expression for building a map, before it can match.
17:31:05 <Cale> kagami_: The cases where you'd potentially care a lot about this is where you're iteratively building up a value of your datastructure type, possibly with a whole lot more modifications to the Map value than there are actual values inside it.
17:31:33 <kagami_> Cale: but values in Data.Map will still be lazy?
17:31:42 <Cale> kagami_: They could very well be
17:32:21 <kagami_> hmm, so maybe it will be better to use deepSeq for Data.Map in each loop iteration?
17:32:22 <Cale> kagami_: The internal tree structure of the Data.Map itself is always strict, but the values held at the leaves are lazy
17:32:33 <Cale> That's likely just to waste a lot of time
17:32:52 <Cale> deepSeq would have to traverse the whole Map
17:32:54 <c_wraith> Data.Map happens to be mostly strict internally.  The tree structure and keys are strict.  (well, the keys are only guaranteed to be strict to whnf).  The values are not strict, but that usually isn't an issue, because you're usually not building up thunks in the values.
17:33:24 <c_wraith> When you *are* building up thunks in the values, it's time to rethink what you're doing.
17:33:52 <Cale> Sometimes putting expressions (or thunks as some people like to call them) in the values is just what you want.
17:34:08 <kagami_> c_wraith: I construct new values based on previous Data.Map state, so they will be lazy (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25734#a25734)
17:34:15 <Cale> You can define a Data.Map where the values recursively depend on each other.
17:35:56 <Cale> kagami_: Yeah, in cases like that, you typically just want to make sure that the new value you computed to put in the Map is evaluated before you put it in, and yes, you probably do want to make all the fields of ProgramState strict.
17:36:41 <Cale> You can do that just by using something like  x `seq` Map.insert k x m
17:37:51 <Polarina> Why does this code snippet not work? http://codepad.org/FC5JNoEH
17:37:55 <Polarina> I get no output.
17:38:10 <Cale> kagami_: Or, just ignore the problem, and complain to us if it breaks ;)
17:38:16 <kagami_> Cale: but the problem what fields not simple type like Int and seems like `seq` will not evaluate them completely
17:38:26 <c_wraith> I had a use case a while back where I was using adjust a LOT.  That, by definition, builds up long chains of unevaluated expressions inside the map.  I was sad it was so much work to fake a strict variant of adjust.
17:38:58 <Cale> kagami_: Well, so long as the expression which starts evaluating triggers enough evaluation to ensure that things stay evaluated, you're fine
17:39:12 <kagami_> Cale: hmm, the problem is memory leak :) (about 2G of ram and 1G swap)
17:40:45 <Cale> kagami_: For example, if you have something like f x y z = Just (x + y + z), and you have  y = f 1 2 3, and you seq y ..., then it'll evaluate to Just (1 + 2 + 3) and then stop evaluating y there, yeah?
17:41:20 <Cale> However, you could always write  f x y z = v `seq` Just v where v = x + y + z
17:41:21 <kagami_> Cale: yeap, It's how i'm understanding rwh chapter
17:42:19 <Polarina> Any ideas? :(
17:42:28 <Cale> Now when you do that same thing, it'll start evaluating y, and get to let v = 1 + 2 + 3 in v `seq` Just v, but that's not in the form of a constructor yet, so it has to keep going
17:42:31 <kagami_> Cale: heh, it requires to correct a lot of code...
17:43:05 <Cale> kagami_: It's usually surprisingly little
17:43:50 <Cale> Though I don't know, you could always be right for your particular case :)
17:44:30 <Cale> Polarina: Sorry, I never use the low-level network API...
17:44:47 <Cale> Polarina: Do you know which step it's getting to there?
17:45:24 <kagami_> but for example if i have "adjust' key value map = value `seq` adjust ..." and pass to adjust value argument like "f1 $ f2 $ 1 + 2 + 3" it will not be strictly enough?
17:45:37 <Polarina> Cale, nope. :(
17:45:48 <Cale> Polarina: maybe make it print some stuff as it goes
17:45:56 <Polarina> Cale, will try,.
17:45:58 <Cale> kagami_: It might very well be strict enough
17:46:35 <kagami_> Cale: Ok, will try at first. thanks
17:46:37 <Polarina> Cale, it's getting stuck in recvFrom.
17:48:03 <Cale> kagami_: Remember that pattern matching is the same as using seq, so if you've already pattern matched some variable using case, or you're just about to pattern match it, there's no point in using seq on it.
17:49:00 <Polarina> Cale, I am just using the low-level interface because the high-level one is crap, even for the simplest tasks.
17:49:15 <Cale> Polarina: oh?
17:49:19 <Polarina> Cale, binary-data.
17:49:51 <c_wraith> in that case, wouldn't you be better off with network-bytestring?
17:50:03 <Polarina> c_wraith, yes, and it's not working.
17:50:05 <Polarina> I get no data.
17:50:06 <Cale> Polarina: Of course, don't use sendTo or recvFrom in the Network library
17:50:23 <Polarina> Cale, that's what I am doing...
17:50:41 <Cale> Polarina: Just use listenOn/accept for a server, and connectTo for a client.
17:50:59 <Polarina> Cale, UDP...
17:51:05 <Cale> Oh, okay
17:51:12 <Cale> You actually care that it's UDP.
17:51:25 <kagami_> Cale: yes, it will be better "adjust' key !value ..."
17:52:07 <Cale> kagami_: Right, you can do that too :)
17:52:37 <Cale> Polarina: You're using a different sendTo/recvFrom than I'm talking about :)
17:52:53 <Polarina> Cale, oh?
17:53:06 <Cale> (The ones in Network.Socket are different from the ones in Network)
17:53:15 <defn> how do i get documenation about a function at the Prelude>
17:53:19 <Polarina> I am using the ones in Network.Socket.ByteString.
17:53:39 <Cale> defn: By opening your web browser and pointing it at the documentation ;)
17:53:48 <defn> :D
17:53:52 <Cale> defn: You can get the type of a function from ghci using :t
17:54:03 <Cale> defn: and sometimes a bit more info using :info
17:54:23 <Cale> (:info also works on other stuff, like types)
17:54:32 <Cale> But no documentation
17:54:58 <Draconx|Laptop> I often wish ghci could spew out the haddock documentation for a function.
17:56:04 <c_wraith> I figured out how to hack together a correct Typeable instance for a monad transformer today.  There's some...  unfortunate...  hacks involved.  Also, I think my solution depends on ScopedTypeVariables
17:56:09 <Zao> The vim suite for Haskell can jump to haddock pages for things.
17:56:11 <Zao> Quite handy.
17:56:33 <byorgey> c_wraith: nothing wrong with ScopedTypeVariables.
17:56:42 <Cale> I guess the first problem with that at present is that the documentation isn't actually stored in the object code, so we would either have to start doing that, or else ghci would have to learn where the haddocked documentation is kept and parse it.
17:57:00 <illissius`> if you make a ForeignPtr and don't add any finalizers, it'll just do nothing, right?
17:57:26 <Cale> illissius`: right, it'll be garbage collected uneventfully
17:57:43 <pastorn> Draconx|Laptop: yes, that would be truly awesome
17:57:44 <illissius`> okay, thanks
17:58:37 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25736#a25736  <-- how to build a Typeable instance for a monad transformer
17:59:15 <Cale> c_wraith: figured it out, eh? :)
17:59:20 <Cale> nice
18:00:13 <Saizan> ?djinn Not (Not (((t -> b) -> u -> b) -> ((t1 -> t) -> b) -> (t1 -> u) -> b))
18:00:13 <lambdabot> f a =
18:00:13 <lambdabot>     void (a (\ _ _ b ->
18:00:13 <lambdabot>              void (a (\ _ c ->
18:00:13 <lambdabot>                       void (a (\ _ _ _ ->
18:00:13 <lambdabot>                                c (\ d ->
18:00:15 <lambdabot>                                   void (a (\ e ->
18:00:17 <lambdabot>                                            void (a (\ _ _ _ ->
18:00:19 <lambdabot>                                                     e (\ f -> c (\ _ -> f)) (b d))))))))))))
18:00:25 <Saizan> ugh, sorry :)
18:00:28 <defn> oi vey
18:00:33 <Cale> Saizan: haha, what prompted that?
18:00:42 <c_wraith> a thread on -cafe
18:01:27 <Saizan> yeah, and the desire to prove the function couldn't exist in agda, but it appears you can't prove that :)
18:01:39 <Cale> hehe
18:03:30 <Saizan> mh, though maybe there's some gotcha with the position of quantifiers?
18:03:40 <c_wraith> I'm right that my particular implementation is depending on ScopedTypeVariables, and it'd require some additional work to build that function without that extension?
18:04:23 <ski> Saizan : why couldn't you do that in Agda ?
18:04:32 <ski> (it looks doable to me)
18:05:02 <ski> (hm .. or maybe you mean't without the double negation ?)
18:05:18 <copumpkin> yeah, I think you need the double negation
18:05:21 <Saizan> ski: i mean i was trying to prove the single negation
18:05:31 <ski> huh
18:05:37 <copumpkin> actually that makes no sense
18:05:45 <Saizan> ski: but if djinn can prove the double then i'm screwed :)
18:05:52 <Saizan> unless agda is inconsistent..
18:05:58 <ski> hm, ok
18:06:20 <ski> why were you trying to prove the single negation ?
18:06:48 <Saizan> to prove there's no function with the non-negated type
18:06:50 <copumpkin> ski: have you seen the ((t -> b) -> u -> b) -> ((t1 -> t) -> b) -> (t1 -> u) -> b type?
18:07:00 <copumpkin> it doesn't look very possible
18:07:03 <ski> above, yes :)
18:07:57 <copumpkin> I was trying to prove it in agda but can't seem to do it
18:08:33 <ski> hm ..
18:08:38 <ski> @djinn (u -> t) -> ((t1 -> u) -> (t1 -> t))
18:08:38 <lambdabot> f a b c = a (b c)
18:13:45 * ski wonders whether `((t -o b) -o u -o b) -o ((t1 -o t) -o b) -o (t1 -o u) -o b' is provable in linear logic
18:17:16 <ski> ((Not t (+) b) -o (Not u (+) b)) -o ((t1 (*) Not t) (+) b) -o ((t1 (*) Not u) (+) b)
18:18:02 <ski> hm .. it looks provable, i think
18:19:02 <ski> hm .. well, actually not (in the way i was thinking)
18:20:14 <ski> ((t (*) Not b) (+) (Not u (+) b)) -o ((t1 -o t) (*) Not b) (+) ((t1 (*) Not u) (+) b)
18:21:04 <sfultong> byorgey: salutations!
18:21:16 <byorgey> sfultong: greetings!
18:21:30 <sfultong> woah, you're responsive
18:22:23 <sfultong> so... I'm not keen on the diagrams Option list for rendering...
18:23:55 <sfultong> I'm not sure how you intend to treat optional and required Options
18:25:08 <gwern> byorgey: salutations!
18:25:16 * BMeph longs for the "old days", when ways to code programs were called "notations"...
18:25:22 <gwern> hm. guess that wasn't a script
18:25:48 <gwern> BMeph: I long for the old days where 'legacy' was something you wanted
18:25:52 <sfultong> gwern: yeah, I was just wondering that myself
18:25:58 <byorgey> gwern: greetings!
18:26:04 <sfultong> aha!
18:26:13 <sfultong> script with lag?
18:26:19 <gwern> sfultong: no, even if his machine was way loaded a script would've replied quicker
18:26:23 <byorgey> sfultong: greetings!
18:26:37 <gwern> sfultong: IRC is just text processing, after all, and that's really fast these days
18:26:38 <byorgey> gwern: greegreetinnggs
18:26:51 <gwern> daisy, daisy, give me an answer do...
18:26:56 <byorgey> =)
18:27:26 <byorgey> sfultong: hm, good point re: optional + required options
18:27:26 <Cale> http://www.theonion.com/articles/entire-facebook-staff-laughs-as-man-tightens-priva,17508/
18:27:42 <BMeph> gwern: Hm, that is a good one. It reminds me...when did "relic" become old and _UN_valuable?
18:28:19 <gwern> BMeph: old objects have always been ambiguous; look to Qin Shi Huang Di burning all old books
18:29:02 <byorgey> sfultong: so, the other option would be to have each backend declare a single type Options, and have the rendering function just take a single Options argument
18:29:02 <gwern> Cale: the onion started being depressing ever since that article heralding bush's 1st inauguration - 'our long national nightmare of peace and prosperity is over'
18:29:13 <byorgey> sfultong: so it would probably be a record of some sort
18:29:18 <gwern> BMeph: or more recently, the french or cultural revolutions
18:29:21 <sfultong> byorgey: yeah, that was what came to my mind
18:29:56 <byorgey> sfultong: then optional options would just be a Maybe field in the Options record
18:30:05 <sfultong> byorgey: exactly
18:30:17 <byorgey> ok, you've convinced me =)
18:30:47 <sfultong> byorgey: sweet!
18:31:00 * gwern isn't. your force tricks will only work on weak-minded fools
18:31:10 <sfultong> oh, foo
18:31:25 <byorgey> these aren't the catamorphisms you're looking for
18:31:45 <gwern> byorgey: 'folds' would fit the rhythm better
18:32:01 <byorgey> true, I blame time pressure
18:32:14 <dancor> Evan Hollingsworth
18:32:38 <byorgey> um
18:34:51 <byorgey> sfultong: so are you going to change the Backend class, or should I?
18:36:09 <sfultong> byorgey: I'm doing it
18:36:21 <byorgey> ok, awesome
18:36:33 <sfultong> byorgey: I'm trying to flesh out the Cairo backend
18:36:40 <byorgey> great!
18:36:49 <sfultong> it's certainly nice that gtk2hs is in cabal now
18:36:54 <byorgey> yes, indeed
18:37:23 <byorgey> have you taken a look at the code in the version of diagrams on Hackage?  there should be some Cairo stuff you can rip out of there
18:37:29 <byorgey> I forget if we already talked about this
18:37:35 <sfultong> you emailed me
18:37:41 <sfultong> and I'm using it as a reference
18:37:43 <byorgey> oh, right. ok, cool.
18:38:04 <byorgey> ok, I need to go, leave me a message with lambdabot if you have more questions
18:38:10 <soupdragon> http://www.seas.upenn.edu/~cis500/current/sf/html/
18:38:15 <soupdragon> Brent Yorgey ??
18:38:24 <soupdragon> that name is familiar.....
18:38:33 <byorgey> soupdragon: that's me
18:39:04 <byorgey> I TA'ed that course this past spring and contributed a bunch to the text
18:39:12 <soupdragon> wow that is so cool
18:39:57 <sfultong> byorgey: ok
18:45:58 <soupdragon> byorgey what was it like for the people in the class?
18:46:05 <soupdragon> was progress rapid or not?
18:59:29 <jeeez> how do i convert a floating number into an integer in haskell?
18:59:45 <soupdragon> floor
18:59:47 <SubStack> floor, round, ceiling
19:00:01 <copumpkin> truncate!
19:00:08 <tensorpudding> > (floor 3.2, round 3.2, ceiling 3.2)
19:00:09 <lambdabot>   (3,3,4)
19:00:43 <wli> properFraction
19:00:44 <jeeez> thanks
19:00:53 <BMeph> > (floor -3.2, round -3.2, ceiling -3.2, truncate -3.2)
19:00:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
19:00:54 <lambdabot>    arising from a use of `...
19:01:02 <liyang> I'll just leave this here: http://www.cs.brown.edu/people/acb/codebubbles_site.htm 
19:01:06 <tensorpudding> truncate would be floor right?
19:01:08 <soupdragon> my book here says:  25^2 + 26^2 + 27^2 + ... + 623^2 + 624^2 = 9010^2
19:01:11 <soupdragon> what's the significance of this?
19:01:13 <Draconx|Laptop> tensorpudding, no.
19:01:20 <arw> tensorpudding: not for negative floats
19:01:21 <BMeph> > (floor (-3.2), round (-3.2), ceiling (-3.2), truncate (-3.2))
19:01:22 <lambdabot>   (-4,-3,-3,-3)
19:01:28 <tensorpudding> right, that would make sense
19:01:34 <wli> soupdragon: Faulhaber formulae
19:02:07 <wli> soupdragon: I think the one he was most famous for was sums of squares being related to the square of the sum or something on that order
19:02:18 <soupdragon> wli oh wow nice
19:03:26 <BMeph> wli: fst.properFraction, right? ;)
19:03:48 <jeeez> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25739#a25739 still haven't gotten used to the type stuff in haskell, can someone tell me why it doesn't work?
19:05:52 <Philonous> jeeez: You could just leave out the type signature and let ghc deduce it
19:06:16 <BMeph> jeeez: My first guess is, of course: "UR DOIN IT RONG!!!111!1!11ichi!11!" ;
19:06:28 <soupdragon> lol
19:06:36 <jeeez> yeah i know :\
19:06:44 <tensorpudding> I would guess it is with floor
19:07:01 <jeeez> it is!
19:07:23 <Philonous> jeeez: It doesn't work because floor needs it's argument to be RealFrac, so you need to add RealFrac a to you context
19:07:31 <tensorpudding> Do you want (floor x)/10 or floor (x/10)
19:07:35 <Cale> jeeez: You don't want floor x / 10, you want x `div` 10
19:07:44 <tensorpudding> in either case, it won't work, since x and floor x are both integers, and / isn't defined for them
19:08:15 <Cale> Or div x 10, to parallel your use of mod
19:08:20 <BMeph> jeeez: As a hint, there's even a function, "divMod", for when you want them both from some number. :)
19:08:22 <jeeez> Cale: awesome!
19:11:22 <jeeez>  div works! thanks.
19:12:09 <jeeez> but if i wanted to make floor work, how do i do it?
19:12:43 <tommd> > floor 10.1
19:12:44 <lambdabot>   10
19:13:26 <jeeez> why does floor (10/4) work but not floor 10/4?
19:13:42 <tommd> jeeez:   floor 10 / 4 == (floor 10) / 4
19:14:00 <interferon> i'm trying to install the snap-server cabal package and i get:   directory-1.0.1.1 was excluded because ghc-6.12.1 requires directory ==1.0.1.0
19:14:00 <tommd> jeeez: and (/) :: Float ->Float -> Float
19:14:03 <interferon> how can i get around this?
19:14:06 <tommd> But floor :: Float -> Int
19:14:21 <tommd> so you are trying to feed an Int to "div".
19:14:31 <dcoutts> interferon: I expect there's more to the error message than that little snippet
19:14:39 <systemfault> > 10 `div` 2
19:14:40 <lambdabot>   5
19:14:57 <tommd> systemfault: yes, Cale already showed him the proper way to perform integer division.
19:15:10 <dcoutts> interferon: you probably want to use the existing directory-1.0.1.0 that you've already got, rather than a newer version
19:15:13 <interferon> dcoutts: http://gist.github.com/415353
19:15:22 <dcoutts> interferon: you're not using cabal upgrade are you btw?
19:15:34 <interferon> dcoutts: no, cabal install
19:15:43 <tommd> jeeez: Does that explanation of types make sense to you?   (floor 10) :: Int and thus can't be the first argument of (/).
19:16:13 <dcoutts> interferon: do you have multiple versions of directroy installed? use ghc-pkg list to check
19:16:16 <jeeez> tommd: i'm wondering. can't Int get promoted to Float automatically? i thought it wasn't possible only the other way
19:16:33 <interferon> dcoutts: ah, i do
19:16:52 <interferon> i guess i want to remove the one in ~/.ghc
19:17:02 <soupdragon> @let palindrome x = show x == reverse (show x)
19:17:03 <lambdabot>  Defined.
19:17:07 <interferon> dcoutts: should i use unregister?
19:17:14 <soupdragon> > find (palindrome . (*72)) [1..]
19:17:15 <lambdabot>   Just 88
19:17:18 <dcoutts> interferon: so cabal is trying to pick the newer one and then it finds it cannot because the ghc package needs the older one.
19:17:20 <soupdragon> > 88*72
19:17:21 <lambdabot>   6336
19:17:26 <soupdragon> > find (palindrome . (*31227)) [1..]
19:17:27 <lambdabot>   Just 6133
19:17:33 <soupdragon> > 6133*31227
19:17:34 <lambdabot>   191515191
19:17:45 <dcoutts> interferon: for future reference, you can get more info using -v, it explains more about the dependency resolution process, what it tried picking etc
19:17:53 <dcoutts> interferon: yes, ghc-pkg unregister
19:17:58 <jeeez> > "i'm a bot!"
19:17:59 <lambdabot>   "i'm a bot!"
19:18:29 <soupdragon> > find (palindrome . (*1729)) [1..]
19:18:31 <lambdabot>   Just 43
19:18:33 <jeeez> that's really nifty :)
19:18:34 <soupdragon> > 43*1729
19:18:35 <lambdabot>   74347
19:18:59 <interferon> dcoutts: thanks
19:19:34 <dcoutts> interferon: np
19:19:35 <gwern> @hoogle Int -> [Int]
19:19:35 <lambdabot> Data.Graph.Inductive.Graph newNodes :: Graph gr => Int -> gr a b -> [Node]
19:19:35 <lambdabot> Data.Graph.Inductive.Query.BFS bfs :: Graph gr => Node -> gr a b -> [Node]
19:19:35 <lambdabot> Data.Graph.Inductive.Query.DFS reachable :: Graph gr => Node -> gr a b -> [Node]
19:19:56 <tommd> jeeez: Sorry, stepped away.  No, you must convert between types - welcome to strong static typing.
19:20:03 <interferon> @hoogle Int -> [a] -> [[a]]
19:20:04 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
19:20:04 <lambdabot> Prelude drop :: Int -> [a] -> [a]
19:20:04 <lambdabot> Prelude take :: Int -> [a] -> [a]
19:20:38 <jeeez> tommd: after a short stint with perl, that's like trying to choke myself!
19:20:47 <tommd> jeeez: If you find yourself converting too much then step back and think "maybe I've set this up wrong" but some conversions are unavoidable.  Just remember "round" "floor" "ceiling" and "fromIntegral"
19:21:07 <jeeez> tommd: yes sir!
19:21:12 <gwern> interferon: I was wondering if there were any function for taking a number apart into digits - eg. 349 would be [3,4,9] which would simplify the palindrome
19:21:23 <BMeph> jeeez: Just to let you know, Haskell doesn't auto-cast - on purpose. We like knowing what type things are here. :)
19:21:49 <interferon> > map read $ show "123"
19:21:51 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:21:51 <lambdabot>         against inferred ty...
19:22:02 <interferon> > map read $ show "123" :: [Int]
19:22:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:22:03 <lambdabot>         against inferred ty...
19:22:17 <Null-A> Are there any more cool haskell tutorials like "Writing a scheme interpreter" ?
19:22:21 <interferon> > map read "123" :: [Int]
19:22:22 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:22:22 <lambdabot>         against inferred ty...
19:22:27 <BMeph> > map ((+0).read) $ show "123"
19:22:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:22:28 <lambdabot>         against inferred ty...
19:23:05 <BMeph> Oh... 'show "123"'. That's twisted. :\
19:23:48 <BMeph> > map digitToInt $ "123"
19:23:49 <lambdabot>   [1,2,3]
19:24:08 * BMeph whistles aimlessly and walks likewise...
19:24:12 <copumpkin> > map (read . pure) $ "123" :: [Int]
19:24:13 <lambdabot>   [1,2,3]
19:24:22 <jeeez> BMeph: i think i understand. i was confused between automatic type inference and type casting
19:24:30 <nik4> hello every1
19:24:54 <nik4> sorry to be off-topic, but does any1 know how to work with z80?
19:25:07 <BMeph> jeeez: Wow, I'd say so - those are possibly mortally opposed to each other... 8*O
19:25:27 <BMeph> nik4: Yes. :)
19:25:31 <kmc> nik4, that's very clever... you've found a way to save two characters by abbreviating "one" as "1"
19:25:57 <nik4> sorry about that... just a little bit tired... its 3 am here
19:26:08 <pikhq> nik4: Might I suggest investing your time in learning how to touchtype? You seem to not be able to.
19:26:38 <Veinor> what category is z80 in? Hask?
19:26:42 <nik4> @pikhq: certainly doing that!
19:26:42 <lambdabot> Unknown command, try @list
19:27:02 <pikhq> Also, @notation is a Twitter-only thing, and makes lambdabot cry.
19:27:04 <copumpkin> nik4: anyway, no z80 in here
19:27:15 <Veinor> pikhq: yeah, why do people do that in here? it annoys me
19:27:26 <jeeez> BMeph: you're bent on making me feel stupid! :\
19:27:40 <pikhq> Veinor: Beats me.
19:27:40 <jeeez> BMeph: automatic type inference is for variable, not values, is that right?
19:27:58 <kmc> jeeez, technically, the type of every expression is inferred
19:28:02 <_swift_> pikhq: could swear i saw that on a variety of other media (blogs, irc, etc) years before twitter existed
19:28:41 <Veinor> I think consumerist comments use @person: foo
19:28:45 <pikhq> jeeez: Actually, it's just that read and show break type inference.
19:28:48 <kmc> jeeez, values are a run-time concept.  values are what expressions evaluate to
19:29:39 <jeeez> kmc: that busted the next question i was about to ask.
19:29:47 <nik4> BMeph, if I have an attribute map on the display, how would I update the screen more efficiently than by linear iteration? Eg: updating the generation in a game of lime...?
19:29:53 <BMeph> jeeez: Think about it like this (please, someone feel free to throw my "favorite" phrase at me if I stray...):
19:30:42 <jeeez> BMeph: listening!
19:30:58 <BMeph> jeeez: Type inference if figuring out what type something is by looking at the functions used on it. Type casting is changing the type of something based on the function used on it.
19:31:17 <BMeph> Er, inference *is
19:32:03 <kmc> "type casting" usually refers to one of two things, neither of which is done in normal Haskell code
19:32:48 <jeeez> BMeph: got it
19:34:08 <jeeez> if i did 3.2+4, unless it converts 4 to 4.0, it should throw an error right?
19:34:28 <jeeez> > 3.2+4
19:34:28 <lambdabot>   7.2
19:34:31 <kmc> jeeez, if you use a literal "4" it's okay, because numerical literals are overloaded
19:34:33 <tensorpudding> 4 is special, since it has (Num a) => a
19:34:41 <kmc> jeeez, 4 is syntactic sugar for (fromInteger 4)
19:34:42 <tensorpudding> it can be defaulted to any numeric type you want
19:34:46 <kmc> :t fromInteger 4
19:34:48 <lambdabot> forall a. (Num a) => a
19:35:12 <tensorpudding> 4.0 is less general
19:35:13 <kmc> so in particular, (4 :: Double) is already valid
19:35:45 <kmc> one meaning of "type casting" is the thing where, in C, if you call a function expecting "double" with an "int" value, it will do a conversion
19:35:54 <Gracenotes> :t fromRational 4
19:35:56 <lambdabot> forall a. (Fractional a) => a
19:35:57 <kmc> in Haskell this would be like having the compiler insert "floor" or "fromIntegral" for you, which it doesn't
19:36:10 <BMeph> jeeez: It's like this, you wrote 4, but you added it to a Float, so you "really" meant 4 as a Float. So, that's what it "pretended" you typed in the first place. Since no one else said otherwise, it all worked out. :)
19:36:11 <jeeez> okay, this is a pointless discussion[my fault! i should read up first. suggest some good guide? half way through Learn You A Haskell~
19:36:33 <kmc> the other meaning of "type casting" is to just tell the type system to shut up and assume things are already the same type when they aren't
19:36:48 <kmc> this is not a conversion; it's computationally trivial
19:37:05 <kmc> and it will cause all kinds of trouble if you assumed wrong
19:37:28 <BMeph> jeeez: If you learned something, it wasn't pointless. :)
19:37:31 <kmc> C confuses the issue further by using the same syntax for both sorts of "cast"
19:37:32 <jeeez> yeah, i've run into loads of issues with that :\
19:38:08 <kmc> and the two meanings sort of coincide for pointer types
19:38:45 <jeeez> BMeph: going defensive because most channels would ask me to ST*U and read the manual/documentation/guide/faq.
19:38:54 <kmc> in Haskell we don't choose one particular function of type Float -> Int to be special and have special syntax
19:40:07 <kmc> if we told people to STFU and read the book, nobody would learn Haskell
19:40:08 <BMeph> jeeez: Naugh, we haave all the status we need here - we're talking about Haskell! So, we're a lot friendlier and more helpful than you may be used to. ;)
19:41:00 <jeeez> kmc: true! [that's my excuse for giving up on perl ;) ]
19:41:15 <soupdragon> > find (palindrome . (*1337)) [1..]
19:41:17 <lambdabot>   Just 143
19:41:27 <soupdragon> > 1337*143
19:41:28 <lambdabot>   191191
19:42:02 <kmc> i wonder if saying the word "perl" is enough to provoke an argument
19:42:11 <kmc> as it is for That Other Language
19:42:50 <jeeez> now that i know some of the basics of the language, suggest something more rigorous to read on Haskell?
19:42:57 <jeeez> kmc: if it was, no one's taken the bait yet :)
19:43:07 <_swift_> now to experimentally determine what That Other Language is
19:43:11 <_swift_> c++!
19:43:22 <kmc> omg C++ sucks, templates raped my kitten
19:43:39 <kmc> no seriously you guys, templates are a pure functional language
19:43:47 <jeeez> it sure would've done it "fast" :)
19:43:55 <Gracenotes> for serious??
19:43:57 <kmc> personally i believe C++ has its flaws but is essentially suited for one niche
19:44:04 <kmc> no i believe you're wrong and you should just use C for that
19:44:33 <kmc> no C++ is great because the version released in two years will have lambda and type inference
19:45:11 <_swift_> haha kmc i can see you've been through this discussion a few times
19:45:22 <kmc> you only hate C++ because you read the C++ FQA
19:45:28 <kmc> no, you only like C++ because you read the C++ FAQ
19:46:18 <jeeez> kmc: okay, the bait was taken eventually! :|
19:46:21 <kmc> jeeez, did you read RWH?
19:46:31 <kmc> great book
19:46:35 <copumpkin> lol, it's so weird to see people talking to jeeez
19:46:37 <kmc> covers a lot of things that other "tutorial-level" introductions don't
19:46:40 <jeeez> kmc: yet to! will start with it today
19:46:43 <kmc> why copumpkin
19:46:55 <BMeph> why, copumpkin! ;)
19:47:00 <copumpkin> kmc: cause it sounded like you're pissed off when you write "jeeez, did you read RWH?"
19:47:06 <kmc> haha
19:47:17 <jeeez> copumpkin: that's because i'm a nice person :)
19:47:22 <copumpkin> :)
19:47:37 <kmc> jeeez, there's also the Gentle Introduction to Haskell, which is not a tutorial
19:47:48 <jeeez> drat! i thought you'd do a 'jeeez: :) '
19:47:52 <BMeph> Nor is it gentle... ;)
19:48:13 <kmc> it is a gentle version of The Haskell 98 Report
19:48:21 <kmc> it's not a tutorial
19:48:45 <kmc> URL aside
19:49:00 <jeeez> okay guys, i guess i have to get going now. i'll look through all of those and read the easiest.thanks for the help.
19:49:43 <kmc> :D
19:49:47 <alexyk> how do I print a string without "\"...\\\"...\"" extra level of escaping?
19:49:58 <kmc> alexyk, putStr
19:49:58 <Axman6> putStrLn
19:50:09 <Gracenotes> make your own Show ins... er. right. duh.
19:50:10 <kmc> alexyk, print = putStrLn . show
19:50:17 <kmc> > show "foo"
19:50:18 <lambdabot>   "\"foo\""
19:50:21 <kmc> > iterate show "foo"
19:50:22 <lambdabot>   ["foo","\"foo\"","\"\\\"foo\\\"\"","\"\\\"\\\\\\\"foo\\\\\\\"\\\"\"","\"\\\...
19:50:23 <alexyk> well, I get a JSON from a database and it does that, even with . show
19:50:43 <alexyk> ah!
19:50:47 <alexyk> show is nasty there
19:50:48 * Axman6 rages at C libraries causing traps >_______<
19:51:08 <kmc> alexyk, "show" turns a Haskell value into a Haskell literal for that value, suitable for pasting into source code
19:51:20 <kmc> in the case of String that involves adding "" and escaping special characters
19:51:32 <copumpkin> > fix show
19:51:33 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
19:51:38 <alexyk> okok, kiling it for now, wanna raw json
19:51:45 <kmc> this is the uniform way to do things
19:51:55 <kmc> other languages have a special case for String (like Python's str(), but not repr())
19:52:13 <kmc> > fix error
19:52:14 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:53:24 <Gracenotes> > fix (read . show) :: String
19:53:28 <lambdabot>   mueval-core: Time limit exceeded
19:53:42 <kmc> Haskell interview question: explain in detail why "fix error" produces an open-quote before the exception
19:54:10 <kmc> speaking of jobs, do any of the iPwn Studios guys hang out here?
19:54:53 <alexyk> so before doing any databases, I have to learn how do jump over both IO and my DB monads, reading tons of buggy sources.  Now how's that for beginner friendly?  Making I/O complicated for the rest of us is like the shoebomber sabotaging check-in.
19:55:40 <kmc> let's pick a fight about it on IRC
19:55:58 <alexyk> e.g., the declare things with let ... -- no in -- inside a do
19:56:07 <alexyk> just like in ghci
19:56:08 <Saizan> you should learn you a type system before massing with databases :)
19:56:16 <kmc> alexyk, you can use "let .. in ..." too
19:56:18 <Saizan> *messing
19:56:39 <kmc> "do { x; let v = y; z }" is sugar for "do { x; let v = y in do { z } }"
19:56:53 <kmc> alexyk, i agree that there are lots of bad sources for learning how IO works
19:57:11 <alexyk> kmc; ah, ok
19:57:16 <kmc> in particular, "learn how to do IO" and "learn what monads are" are very distinct goals, but are often conflated by student and teacher alike
19:57:31 <kmc> because the full generality of Monad is not relevant to just doing IO
19:57:33 <kmc> and conversely, IO is a bad example of a monad
19:57:43 <kmc> http://haskell.org/haskellwiki/Introduction_to_IO is a good intro
19:57:46 <kmc> which avoids the m-word
19:58:16 <alexyk> kmc: I need to suck the JSON out of TokyoCabinet.  Said bindings glitter with various sample usages each begging to read half of RWH.
19:58:34 <kmc> you should read RWH
19:59:30 <alexyk> I managed to make it work out of sheer geek's habit making programs work by random sample composition.  Now I need to undertand why.  I read RWH all the time now, but suddenly I can't fully understand a simple IO program without COntrol.Monad!
19:59:56 <kmc> Haskell has a pretty steep learning curve
20:00:04 <alexyk> just sayin' :)
20:00:19 <kmc> i think our learning resources could use some work, but it'll never be a language where a Python programmer jumps right in and starts interfacing JSON to a database
20:00:49 <alexyk> kmc: I dislike Python.  Here, Google.  I sid it.
20:00:51 <alexyk> said
20:00:54 <kmc> ?
20:01:14 <kmc> i don't know what you mean though
20:01:24 <alexyk> kmc: being associated with even a hypothetical Python progrmmer annoys me :)
20:01:41 <alexyk> Google relies on Python extensively
20:02:05 <alexyk> and Guido want(s/ed) to drop functional remnants from it as "confusing"
20:03:06 <alexyk> or there was a joke to that extent
20:03:19 <kmc> yeah
20:03:29 <byorgey> soupdragon: progress was rapid for some of the students, not so much for others
20:03:36 <kmc> Python programmers often profess to hate functional programming while using it constantly
20:03:54 <byorgey> soupdragon: but most of the students did fairly well
20:04:08 <kmc> every instance method in Python is a partially applied first-class function closed over a free variable
20:04:10 <alexyk> http://www.artima.com/weblogs/viewpost.jsp?thread=98196
20:05:10 <ddarius> Haskell programmers often profess to hate object oriented programming while using it constantly
20:05:16 <kmc> ddarius, yeah, that bugs me
20:05:37 <kmc> perhaps Haskell programmers think that OO == Java, and Python programmers think that FP == Scheme
20:06:03 <kmc> though Scheme and Python are pretty close in the grand scheme
20:06:25 <alexyk> kmc: Haskell and Scheme are closer in an even grander scheme
20:06:34 <hstefan> kmc: the name java turns my rage mode on. It's the worst OO language that I've ever seen.
20:06:43 <ddarius> I would say Scheme and Python are a lot closer than Haskell and Scheme.
20:06:46 <kmc> alexyk, i don't really agree
20:07:01 <alexyk> kmc: you can't possibly know my grander scheme
20:07:05 <pikhq> alexyk: Scheme's primarily a metaprogramming language. Haskell is not.
20:07:05 <kmc> hehe
20:07:44 <kmc> saying Scheme and Haskell are related because they both have first-class functions
20:07:56 <hydo> Does anyone happen to know if cs.vu.nl (the site that hosts the Scrap Your Boilerplate home page) down forever or just happens to be down for a bit at the moment/
20:07:56 <kmc> is like saying FORTRAN and Haskell are related because they both have integers
20:08:27 <alexyk> Scheme and Haskell make people use fold and map and filter all the time.  That's basically the meat of the matter.  All FP languages are closer together for it, and even IO madness doesn't distinguish Haskell into a third party.
20:08:28 <kmc> first-class functions aren't a "paradigm", they're an essential feature that every general-purpose language should have
20:09:19 <pikhq> alexyk: "Functional programming" is not even much of a paradigm.
20:09:41 <pikhq> "Oh, its functions are first-class and close over free variables."
20:09:43 <ddarius> alexyk: If you want to say the Scheme community is closer to the Haskell community than the Python community is to the Scheme community, I'll agree with that.
20:09:52 <pikhq> That's no more a paradigm than possessing if statements.
20:10:06 <alexyk> ddarius: deal
20:10:08 <kmc> i'd say that "functional programming" is a fuzzy description of a style of code, and that "functional language" is at best an even fuzzier description of what languages encourage that style
20:10:24 <danharaj> all programming is about functions
20:10:27 <kmc> same for "object-oriented programming".  and if you look at languages that encourage a clean OO style, Java and C++ are pretty far down the list
20:10:31 <kmc> danharaj, not in Prolog ;)
20:10:38 <danharaj> kmc: pff.
20:10:48 <kmc> the ideal of declarative programming is relational, not functional
20:10:54 <pikhq> Definitely. Java's higher up than C++, but still...
20:11:03 <kmc> you just give some facts and the machine magically decides things
20:11:08 <pikhq> A *real* OO language would be something like... Oh. Smalltalk.
20:11:10 <systemfault> Well.. not if java continues to stall..
20:11:22 <ddarius> pikhq: Smalltalk sucks.
20:11:38 <systemfault> C++ is going to get type inferance, lambdas and a few other nice features before java
20:11:40 <kmc> C# is much closer to an OO language than Java
20:11:51 <alexyk> kmc: yeah, that'll be the next step -- offshore programming.  You call a 1 800 number, narrate what you need, paypal, and it's done.  Declarative programming at its best.
20:11:55 <ddarius> I really think Newspeak will be a "better Smalltalk" than Smalltalk was.
20:11:55 <kmc> for example, the syntactic choice between "x.f" and "x.f()" is not tied to implementation details
20:11:57 <systemfault> C# is a lot nicer as a language than Java, indeed
20:12:00 <kmc> hehe alexyk
20:12:04 <pikhq> ddarius: Yes, but it's quite heavily object-oriented.
20:12:41 <alexyk> of course, if you narrate that you want it in Haskell, they'll hang up on you.
20:13:09 <ddarius> alexyk: They'll tell you they have 30 years experience in Haskell and give you VB.
20:13:36 <alexyk> ddarius: in visual haskell for teams 2012
20:13:43 * jesusabdullah has never really looked at smalltalk
20:13:50 <jesusabdullah> Not that this means much!
20:14:01 <kmc> visuall haskell dot net
20:14:04 <pikhq> jesusabdullah: You may know it for such concepts as "objects".
20:14:10 <jesusabdullah> Heh
20:14:24 <jesusabdullah> I'm aware of objects, and I've heard of smalltalk, but I've never really actually *looked* at it
20:14:25 <kmc> is it fair to say that the closest mainstream offspring of Smalltalk is ObjC?
20:14:27 <jesusabdullah> y'know?
20:14:30 <alexyk> haskell# enterprise edition with gold foundation silverlight
20:14:33 <jesusabdullah> Makes me feel kinda silly on some level
20:14:38 <ddarius> kmc: Objective C isn't mainstream.
20:14:54 <pikhq> kmc: Yeah; ObjC is little more than Smalltalk + C, after all.
20:15:05 <pikhq> (with pointless reference counting)
20:15:21 <jesusabdullah> Microsoft Visual Haskell.NET 2010 Enterprise Edition (tm) ?
20:15:42 <alexyk> jesusabdullah: I'll order 2!
20:16:11 * jesusabdullah bills alexyk for two site licenses of Microsoft Visual Haskell.NET 2010 Enterprise Edition
20:16:16 <kmc> Objective C would become mainstream if only someone would invent a good pocket-size computer, sell 50 million of them, and encourage people to code for it in ObjC
20:16:42 <alexyk> Haskell Server version includes a talking paperclip-like Haskell Curry.
20:16:49 <copumpkin> dolio: nice optimization on that function equality tester!
20:17:04 <jesusabdullah> "It looks like you're trying to write a monad!"
20:17:10 <dolio> I'm an optamizing machine!
20:17:12 <jesusabdullah> *go away*
20:17:53 <gwern> dolio is a machine for transforming coffee into coffee?
20:18:21 <copumpkin> and ffee into ffee?
20:18:25 <alexyk> "hm, it looks like you're struggling with IO..."
20:18:28 <pikhq> kmc: Pity some company like Apple's not bothering.
20:18:28 <pikhq> :P
20:18:36 <gwern> copumpkin: watch your mouth
20:18:45 <gwern> there are juveniles in this channel
20:18:53 <copumpkin> gwern: yessir!
20:19:23 <pikhq> gwern: Any cojuveniles?
20:19:32 * gwern is unsure
20:20:08 <alexyk> jesusabdullah: an evil paper clip: "Hmm, looks like you're a pretty clueless programmer... Why don't you do something else for a living?"
20:20:17 <jesusabdullah> >:O
20:20:23 <jesusabdullah> I'll have a clue someday
20:20:25 <jesusabdullah> You just wait
20:20:36 <jesusabdullah> I'll be an internet STAR!
20:21:14 <jesusabdullah> And I'll come back to my home irc channel and everyone will be babying Excel sheets wrapped in vb6 macros
20:21:26 <jesusabdullah> and guess who will have the last laugh? THATS RITE
20:21:34 <gwern> meowth!
20:21:40 <jesusabdullah> Damn!
20:21:50 * gwern snickers. you set yourself up there
20:22:30 <jesusabdullah> Curse you Team Rocket!
20:22:33 <jesusabdullah> Curse youuuuu
20:22:55 <gwern> jesusabdullah is suicide-blasting off again!
20:23:13 <jesusabdullah> wat
20:23:14 <gwern> (the ratings are low and so this will be a short season. very short.)
20:23:20 <pikhq> My inner child would like to highfive both of you.
20:23:28 <jesusabdullah> ^5
20:23:55 <kmc> jesusabdullah is a pretty cool nick
20:24:10 <jesusabdullah> hah, thanks :3
20:24:28 <jesusabdullah> Back in middle school, it was a password that I accidentally used as a username
20:24:30 <jesusabdullah> and, well
20:24:33 <jesusabdullah> I'm not very creative
20:24:38 <gwern> (the suicide joke comes from the fact that jesus commited suicide, and I hope I don't need to explain the abdullah part)
20:24:42 <jesusabdullah> or, I am, but only sometimes
20:24:43 <kmc> nobody fucks with the jesus
20:25:13 <franki^> Jesus didn't commit suicide....
20:25:49 * alexyk googled meowth and wonders what's that metal thing... http://republika.pl/blog_qt_3590223/4323444/tr/very_happy_meowth.jpg
20:25:52 <pikhq> He was merely executed by the local justice system for crimes he was accused of.
20:25:53 <winxordie> kmc - nice reference
20:25:58 <kmc> thanks
20:26:27 <gwern> franki^: of course he commited suicide. whether you step in front of the train or fail to move out of its way, same thing
20:26:45 <jesusabdullah> Yeah, ihnfi what the metal thing is either
20:26:48 <gwern> alexyk: it's hard to explain. it's a joke on cats liking chiny things and old japanese currency
20:26:54 <pikhq> gwern: Whaddya want him to do, make Caeser bow before him?
20:27:10 <gwern> pikhq: as a god, I expect him to not get killed
20:27:11 <jesusabdullah> He did kinda set himself up for that one
20:27:23 <pikhq> gwern: Son of a diety!
20:27:35 <winxordie> And there goes the #divinity train...
20:27:40 <franki^> gwern: Failing to move out of the way of a train, and failing to move out of the way of a lot of people trying to kill you isn't exactly the same thing
20:27:45 <gwern> alexyk: the curled paw is easier to explain - that's the old come-hither japanese gesture
20:27:57 <gwern> franki^: when you are omnipotent, the latter is exactly as easy as the former
20:28:13 <syntaxglitch> I think the technical term in this case is "suicide by cop"
20:28:26 <pikhq> gwern: *Son* of someone that's omnipotent.
20:28:31 <gwern> alexyk: you or I might wave at someone to get them to come closer; the old japanese expression is to curl the hand. really, they both make the same sense
20:28:35 <franki^> gwern: Right, but I fail to see the relevance of that statement.
20:28:37 <pikhq> Makes your dad an asshole, not you a suicide.
20:28:44 <gwern> pikhq: sounds like someone isn't familiar with the doctrine of the trinity
20:29:03 <pikhq> gwern: Familiar and arguing for no good reason.
20:29:07 <pikhq> ;)
20:29:15 <alexyk> gwern: wow, a cultural heritage! :)
20:29:38 <gwern> alexyk: so, now you understand meowth. go forth and change the world
20:29:46 <winxordie> might be my impression here, but it seems like #haskell turns into the best #generalnerdchat late at night (from the US).
20:30:03 <kmc> even later, it becomes #advancedcategorytheorytomeltyourbrain
20:30:12 <winxordie> kmc - that's for early morning ;)
20:30:21 <alexyk> gwern: looks closer to District 9 prawn than a cat so far
20:30:28 <pikhq> And on random whims, it becomes #haskell
20:30:30 <gwern> fookin prawns!
20:30:30 <monochrom> species and functors and types, oh my! <duck> XD
20:30:41 <gwern> let's eat them and gain their power
20:30:46 <alexyk> indeed
20:30:58 <kmc> monochrom, good paper ;)
20:31:22 * syntaxglitch really needs to start reading interesting papers faster than they get created
20:31:30 * BMeph waits patiently for "Learn You a Spiecies"...
20:31:42 <winxordie> syntaxglitch: I've concluded that's impossible
20:31:43 <kmc> syntaxglitch, i think that's been impossible since the early 19th century or so
20:31:47 <BMeph> *Species
20:31:54 * syntaxglitch wants to see "Learn You An Agda"
20:31:57 <kmc> i'm waiting for Real World Agda
20:32:05 <alexyk> let's eat some RWH and gain its power
20:32:11 <monochrom> Complex World Haskell
20:32:13 <winxordie> I'm still trying to figure out what IS Agda. >.<
20:32:18 <pikhq> syntaxglitch: Sorry, stopped being possible at about the same time it became impossible to know all of science.
20:32:23 <copumpkin> winxordie: a neat language
20:32:24 <kmc> winxordie, it's a functional programming language with dependent types
20:32:33 <copumpkin> in which it's possible to prove false!
20:32:39 <winxordie> ooh
20:32:43 <kmc> winxordie, meaning that pretty much any correctness property of your program can be stated and checked within the type system
20:32:49 * BMeph thinks he should save "Learn You a Coq" joke for reddit... ;)
20:32:54 * alexyk observes that haskell works only if an alien claw cradles it
20:33:02 <winxordie> ok, that's hooked my interest
20:33:03 <gwern> copumpkin: but if you can prove false, and you can prove true, isn't that kind of useless?
20:33:03 <kmc> winxordie, www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf is a good intro
20:33:11 <copumpkin> gwern: yes! yay
20:33:11 <monochrom> hahaha
20:33:15 <kmc> if you are familiar with Haskell and some features like GADTs, Agda will feel very familiar
20:33:25 <copumpkin> gwern: but you need to go out of your way to prove false
20:33:27 <BMeph> True proves itself! :)
20:33:38 <kmc> i think that a dependent type system is actually a lot simpler than what we have in Haskell + GHC extensions
20:33:52 <gwern> BMeph: I need a proof of that
20:34:03 <syntaxglitch> BMeph, just make the Coq joke, don't chicken out
20:34:04 <winxordie> gwern: T -> T?
20:34:05 <kmc> instead of a number of different interacting hacks, you have first-class types, and you manipulate them with the same features as any other value
20:34:20 <gwern> winxordie: but what's the rule which specifies that we can follow that rule?
20:34:21 * syntaxglitch pauses for the rimshot after the stupid pun
20:34:31 <alexyk> somebody explain why Nordic nations are especially proficient in functional languages.
20:34:33 <BMeph> syntaxglitch: ...and gain its power! ;
20:34:46 <gwern> alexyk: alcohol. and melancholy.
20:35:00 <pikhq> alexyk: Hey, gotta do something in the winter.
20:35:04 <gwern> when you're pessimistic you never assume that your code works
20:35:06 <alexyk> gwern: granted; now extrapolate to FP?
20:35:15 <winxordie> gwern: I hear riding the axiom train to the last stop goes nowhere :P
20:35:27 <syntaxglitch> consider also that Finland has the world's highest per-capita coffee consumption and gave the world both Linux and IRC
20:35:31 <syntaxglitch> I rest my case
20:35:37 <gwern> if you don't assume your code works, then programming in c and java make a mockery of all of existence, lies lies lies all lies
20:35:37 <alexyk> but the Japanese went the Ruby way.  And they're not very happy people either.
20:35:57 <monochrom> Finlandia
20:36:07 <gwern> winxordie: hey, I'm just trying to be rigorous here.
20:36:11 <alexyk> the Finns prefer OCaml.
20:36:16 <winxordie> alexyk: the Japanese have made a LOT of languages; only Ruby became popular in the West
20:36:18 <alexyk> and Mathematica.
20:36:29 <BMeph> pikhq: So, besides Sarah Palin, why isn't Alaska a powerhouse of FP, or any ..P? ;)
20:36:30 <winxordie> gwern: if only the term 'rigorous' could be made rigorous
20:36:31 <kmc> gotta do something in the winter? sex not good enough?
20:36:38 <alexyk> winxordie: that's what counts in the West where we are.
20:36:53 <pikhq> BMeph: Alaska drains intelligence.
20:37:03 <copumpkin> kmc: computer geeks and sex? don't be silly
20:37:05 <syntaxglitch> I'm not convinced Alaska is actually inhabited
20:37:08 <pikhq> kmc: These are programmers you're talking about.
20:37:08 <alexyk> pikhq: but pumps perkiness.
20:37:12 <winxordie> sex, beer, 'n' programming - not a bad combo
20:37:13 <kmc> har har
20:37:15 <wli> winxordie: Really? What examples are there?
20:37:15 <pikhq> alexyk: Most definitely.
20:37:20 <kmc> winxordie, that's pretty much my life goal
20:37:21 <copumpkin> syntaxglitch: so x -> Alaska is equivalent to not x?
20:37:37 <alexyk> BMeph: it's a powerhouse of F.
20:37:44 <syntaxglitch> copumpkin, if x means going to Alaska then I don't want anything to do with x, so yes
20:37:46 <gwern> kmc: the problem is, the women are melancholy and alcoholic as well. and men already complain about their low libido...
20:37:48 <monochrom> Either x (x -> Alaska)
20:38:00 <gwern> ah, alaska - where the odds are good but the goods are odd
20:38:04 <copumpkin> monochrom: Not (Not (Either x (x -> Alaska)))
20:38:22 <copumpkin> @djinn-add type Alaska = Void
20:38:27 <copumpkin> @djinn Not (Not (Either x (x -> Alaska)))
20:38:28 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
20:38:32 <copumpkin> there we go
20:38:41 <monochrom> (Either x (x -> Alaska) -> Alaska) -> Alaska
20:38:44 <kmc> :( gwern
20:38:52 <kmc> solution: viagra and prozac in the water supply
20:38:56 <elliottcable> no.
20:39:00 <winxordie> wli: there's a family of concurrency-related ones made back in the 70s; I can't remember an example of the bat, but I was surprised by the sheer number
20:39:02 <syntaxglitch> kmc, that won't work
20:39:03 <elliottcable> wait, what? Alaska?
20:39:05 <copumpkin> elliottcable is a witness!
20:39:08 <elliottcable> Im from Alaska, why are we talking about Alaska?
20:39:08 <syntaxglitch> put it in the beer instead, that might help
20:39:12 <kmc> haha syntaxglitch
20:39:12 <copumpkin> we have a witness
20:39:17 <elliottcable> what?
20:39:17 <winxordie> oh boy
20:39:23 <gwern> kmc: wait, how does viagra fix the women problem?
20:39:27 <monochrom> inhabitant!
20:39:28 <elliottcable> I have no idea whats going on. I just /go #Haskell
20:39:34 <copumpkin> elliottcable: your existence is proof that Alaska is inhabited
20:39:36 <elliottcable> I AM SO CONFUSED
20:39:39 <elliottcable> oh, yes.
20:39:41 <kmc> gwern, low libido.  sort of, not really
20:39:43 <elliottcable> theres plenty of people up here.
20:39:46 <elliottcable> too many, some times.
20:39:49 <winxordie> gwern: I still don't understand the assumption that women have low libido.
20:39:52 <kmc> we can talk about haskell you know
20:40:01 <elliottcable> or fuck that and talk about Paws
20:40:04 <monochrom> Now, try Greenland
20:40:11 <winxordie> Finland!
20:40:11 <elliottcable> speaking of which, Im writing my first actual program in Paws. its fun.
20:40:13 <BMeph> Sorry, he said he was _from_ Alaska, not _in_ Alaska. "Pics, or it isn't true!" ;)
20:40:20 <elliottcable> BMeph: Im both.
20:40:22 <monochrom> Either x (x -> Greenland) -> Greenland -> Greenland
20:40:29 <gwern> winxordie: not much of a ssumption. it's confirmed by wide anecdotal report, I believe it's well established in the literature, and there's a clear evolutionary justification
20:40:34 <kmc> what's Paws?
20:40:43 <copumpkin> @djinn Not (Not (Either x (x -> Greenland)))
20:40:43 <lambdabot> Error: Undefined type Greenland
20:40:46 <monochrom> pics or it is not proven that it is not true
20:40:47 <copumpkin> damn
20:41:11 <_swift_> gwern: alternate theory: perhaps the typical woman does not have low libido so much as the typical man sucks at sex
20:41:16 <winxordie> gwern: I'm one of them sociology-types by training and I'm still trying to discern if that's just a social construct
20:41:28 <elliottcable> heres myself up here: http://drp.ly/151zf1
20:41:32 <elliottcable> enough proof?
20:41:43 <gwern> _swift_: you need an additional axiom - that men enjoy sucky sex much more than women do
20:41:47 <monochrom> Either Pics (It -> Void, (It -> Void) -> Void)
20:41:49 <winxordie> _swift_: I hear sex is a tango for two
20:41:56 <_swift_> gwern: confirmed by wide anecdotal report =)
20:42:21 <monochrom> Oh, wait, that's wrong.
20:42:28 <syntaxglitch> elliottcable, I don't see any mooses, not convinced that's actually Alaska
20:42:37 <copumpkin> monochrom: yeah, you'd have to have pics then
20:42:42 <elliottcable> syntaxglitch: yeah, uh, Im not getting close enough to a moose to take a picture
20:42:49 <elliottcable> syntaxglitch: one nearly killed my mother, and one *did* kill one of my dogs
20:42:51 <copumpkin> syntaxglitch: meese?
20:42:51 <_swift_> winxordie: yes i believe i heard something about that
20:42:55 * gwern ponders _Clannad: After Story_. it's pretty happy so far, which only makes every ep more harrowing as one wonders when the shoe will finally drop
20:42:55 <Squarism> doesnt haskell have classes ?
20:42:56 <elliottcable> syntaxglitch: those things are fucking vindictive and evil
20:43:05 <copumpkin> Squarism: it most certainly does! but they don't do what you think they do
20:43:14 <pikhq> elliottcable: So *this* is why a room with a moose is scary.
20:43:22 <monochrom> haskell have classes. I have classes too. Tomorrow.
20:43:35 <Squarism> but you know what i mean
20:43:37 * syntaxglitch has no class. Er, classes.
20:43:53 <BMeph> elliottcable: Evil, but Tasty. Like coffee! >:)
20:43:53 <wli> Those things are averages. Particular individuals vary.
20:43:56 <monochrom> there is no meaning
20:44:00 <Squarism> it has some form of structured data?
20:44:02 <Squarism> right
20:44:11 <copumpkin> Either Pics (It -> Void) seems sufficient, assuming the or in common usage is exclusive
20:44:15 <winxordie> everything has some form of structured data
20:44:34 <elliottcable> BMeph: fuck coffee
20:44:37 <elliottcable> BMeph: but yes, I love moose steak
20:44:40 <winxordie> or rather, enough of anything
20:44:42 <Squarism> can i have Person type with age and name fields?
20:44:50 <pikhq> elliottcable: I'd rather not; that seems hot and painful.
20:44:51 <monochrom> Yes.
20:44:55 <gwern> premises. 1. nature is made of patterns. 2. all patterns can be expresed as numbers.
20:44:55 <copumpkin> data Person = Person { age :: Int; name :: String }
20:45:04 <syntaxglitch> winxordie, C doesn't really have structured data, it just has piles of bits and a gentleman's agreement to pretend structure exists
20:45:06 <copumpkin> or was that a comma?
20:45:13 <monochrom> comma
20:45:24 <copumpkin> damn, I fail hard
20:45:25 <winxordie> syntaxglitch: but it's so pretty and it's called "struct"!
20:45:38 * syntaxglitch likes to describe C not as having a "static type system" so much as "types on the honor system"
20:45:47 <elliottcable> syntaxglitch: great way to put it
20:45:50 <elliottcable> syntaxglitch: youre my new favourite person
20:45:53 <Squarism> can Person take type arguments?
20:46:02 <monochrom> haskell has a gentlemen's agreement to pretend unsafeCoerce does not exist
20:46:30 <winxordie> unsafeCoerce? o.O?
20:46:34 <elliottcable> holy crap unsafeCoerce is evil
20:46:37 <elliottcable> why does that exist! O_O
20:46:42 * elliottcable shat brix when he googled it
20:46:45 <syntaxglitch> monochrom, not so much a gentleman's agreement as the mind recoiling in horror at Things Man Was Not Meant To Know
20:46:47 <gwern> elliottcable: freedom isn't free!
20:46:54 <elliottcable> ahhhhhh *screams and hides*
20:46:57 <winxordie> Do I want to know what this is?
20:47:02 <byorgey> winxordie: NO
20:47:04 <copumpkin> @hoogle unsafeCoerce
20:47:05 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:47:08 <copumpkin> :)
20:47:11 <winxordie> ...
20:47:12 <gwern> unsafeCoerce is for extraordinary rendition of variables
20:47:14 <byorgey> the type tells you everything you need to know
20:47:27 <byorgey> if that type does not frighten you, you don't know Haskell very well
20:47:27 <winxordie> why?
20:47:29 <kmc> it's a general purpose portal to Hell
20:47:31 <winxordie> why on earth
20:47:35 <winxordie> would you ever use that
20:47:40 <c_wraith> I thought unsafeCoerce was for segfaulting
20:47:41 <blackdog> FFI stuff
20:47:43 <copumpkin> winxordie: plenty of good reasons to
20:47:47 <blackdog> i'd imagine...
20:47:50 <kmc> byorgey, well, it *could* be (const undefined)
20:47:50 <copumpkin> evil optimizations!
20:47:51 <Squarism> is haskell like PHP?
20:47:52 <kmc> which wouldn't be so bad
20:48:04 <winxordie> *shudder*
20:48:09 <byorgey> kmc: true, that wouldn't be as bad.
20:48:11 * syntaxglitch proposes moving unsafeCoerce into the module Hastur.Hastur.Hastur
20:48:11 <copumpkin> Squarism: depends what you mean by "like"
20:48:12 <kmc> Squarism, very much so.  Haskell is exactly like PHP except you don't have to write "<?php" at the beginning of your file
20:48:13 <winxordie> That'll give me nightmares for days now.
20:48:13 <c_wraith> :t const undefined
20:48:15 <lambdabot> forall a b. b -> a
20:48:23 * monochrom enjoys citing heresy
20:48:26 <elliottcable> 03:47:48 < kmc> Squarism, very much so.  Haskell is exactly like PHP except you don't have to write "<?php" at the beginning of your file
20:48:27 <copumpkin> c_wraith: that's unsafeCoerce, but backwards ;)
20:48:28 <Squarism> lol
20:48:37 <c_wraith> So it's safe?
20:48:41 <Squarism> just kidding
20:48:42 <copumpkin> c_wraith: yeah.
20:48:51 <syntaxglitch> copumpkin, so that'd be safeErce, right?
20:48:59 <kmc> :t cast
20:49:00 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
20:49:05 <c_wraith> oh, ouch.  too many arrows turning around
20:49:11 <kmc> unsafeCoerce is not really useful for FFI stuff
20:49:19 <kmc> one use case is in implementing the safe "cast"
20:49:25 <elliottcable> http://tau.pe/14810537568
20:49:29 <kmc> though that is only really safe if Typeable instances do not lie
20:49:31 <Squarism> i know you all language purist phD's coding with a glass of wine on your desktops
20:49:35 <elliottcable> kmc: youve been immortalized :3
20:50:00 <copumpkin> omg immortal on twitter
20:50:05 <Squarism> "Today, ill write 5 mathematically correct lines of golden haskell"
20:50:05 <elliottcable> indeed
20:50:06 <kmc> oh em gee
20:50:13 <copumpkin> kmc: you should get on twitter, anyway
20:50:18 <elliottcable> copumpkin: you on Twitter?
20:50:22 <BMeph> unsafeCoerce: Function Call of C'thulhu! =8*O
20:50:32 <elliottcable> I archive my tweets all over the place. My stream *is* immortalized ;3
20:50:40 <copumpkin> elliottcable: yep! I could've sworn you used to follow me, too. But then you had a big round of unfollowing and unfollowed me
20:50:41 <byorgey> Squarism: I don't like wine that much, but otherwise guilty as charged ;)
20:50:49 <elliottcable> copumpkin: link that shit up
20:50:55 <copumpkin> twitter.com/copumpkin :)
20:50:56 <Squarism> byorgey: =D
20:51:13 <elliottcable> copumpkin: mind you Ill probably unfollow you again by accident if you dont talk to me a lot. I have a bad habit of unfollowing everybody at one go, and only refollowing people whore in the past months worth of @mentions or so.
20:51:16 <alexyk> Twitter agreed to be archived in the Library of Congress, so it's indeed demortalized.
20:51:24 <alexyk> so long as that stands.
20:51:29 <elliottcable> copumpkin: what the hell, 6k followers? Who *are* you?
20:51:30 <copumpkin> elliottcable: ah, that was probably it :)
20:51:59 * syntaxglitch has previously compared invoking unsafePerformIO to reading the Necronomicon but unsafeCoerce is probably worse
20:52:23 <kmc> much worse
20:52:37 <winxordie> syntaxglitch: I've read several books claiming to be the Necronomicon - not so bad, kinda poetic.
20:52:38 <kmc> though, you can implement unsafeCoerce using unsafePerformIO
20:52:43 <kmc> for a specific technical reason
20:53:09 <alexyk> copumpkin: did you get the 6K by publishing that Twitter research? :)
20:53:20 <Squarism> are there any cool implemenations using haskell that REALLY showcases its strong points?
20:53:31 <kmc> implementation of what?
20:53:33 <Squarism> ...preferably with a nice visual feedback o it
20:53:34 <gwern> of what, the necronomicon?
20:53:38 <Squarism> kmc: whatever
20:53:38 <syntaxglitch> kmc, so not really worse so much as unsafeCoerce is the express train to hell, instead of a brisk walk
20:53:39 <copumpkin> alexyk: hah, nope
20:53:54 <BMeph> syntaxglitch: Like I said, Function Call...dare I speak its Name again?!?
20:53:58 <kmc> hehe yes syntaxglitch
20:54:07 <alexyk> copumpkin: I'll train my reputation explaining robots on you and see what they dig :)
20:54:12 <gwern> ah, Call of Unsafecoerce; my favorite game
20:54:30 <winxordie> gwern++ - that was one fun game.
20:55:28 <copumpkin> alexyk: omg what will you find?!
20:55:42 <alexyk> copumpkin: the process takes time
20:56:08 <copumpkin> :O
20:56:37 * syntaxglitch reflects that talking in #haskell is cutting into his Haskell programming time :(
20:57:15 <monochrom> "haskell is not #haskell"
21:30:17 <ManateeLazyCat> For add data directory and it's files, i need write "data-dir" and "data-files" in .cabal file, have any option that add subdirectory recursive? I mean don't need put all data files in .cabal file, just give it data directory.
22:08:36 <dmwit> > 160 + 140 + 150 + 125
22:08:37 <lambdabot>   575
22:10:18 <dmwit> That's what I'm talking about! Max out that disk bus! uh huh
22:13:34 <babusri> I have a question about high allocation of memory when using mutable vectors. I have provided the details in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25743
22:15:37 <copumpkin> babusri: have you tried mutable unboxed vectors?
22:15:54 <copumpkin> it should be sufficient to change your import to Data.Vector.Unboxed.Mutable
22:16:30 <copumpkin> you're creating a lot of boxes and aren't evaluating them much
22:16:59 <copumpkin> it'll also be faster
22:17:46 <babusri> copumpkin: Thanks. I will try that. The lfsr is linear feedback shift register. I need to do this for a ciphering algorithm.
22:17:56 <copumpkin> if you don't want that, you can also just force the values
22:18:00 <copumpkin> but you might as well make it unboxed
22:20:06 <copumpkin> I'd also avoid a mutable vector unless I'm positive an immutable one won't work well
22:22:33 <BMeph> I would heartily recommend...NOT DOIN IT RONG! But, that's just me. ;)
22:22:51 <babusri> copumpkin: Much better. Though bytes allocated is still 50%, I get 8632 copied during GC, 2532 bytes maximum residency, 1 MB total memory in use. Question is why is it doing gc?
22:23:15 <copumpkin> rl is the vector man :) you could ask him
22:23:20 <copumpkin> but I'll take a look in the mean time
22:23:41 <kmc> BMeph, you're helpful ;P
22:23:50 <kmc> babusri, have you tried some RTS options
22:24:01 <kmc> i find that +RTS -A100M often dramatically reduces time spent in GC
22:24:16 <babusri> Thanks. I cannot avoid mutable. Algorithm I am implementing is Snow3G ciplering and integrity.
22:24:41 <kmc> copumpkin, does vector support good update on immutable vectors?
22:25:07 <copumpkin> kmc: well, things can fuse nicely, but it depends what you're doing. Individual small updates aren't good
22:25:24 <ibt> is there a way to make code nice when you're dealing with many methods in IO that are IO Maybe, IO Either, and IO Bool?
22:25:42 <kmc> ibt, can you hpaste a more specific example?
22:26:07 <ManateeLazyCat> What? cabal "data-files" don't support subdirectory? I have add "DirA" in "data-dir", and "data-files" don't accept "DirA/DirB/FileC" ? Only accept "DirA/FileB" ?
22:27:20 <ibt> kmc: i don't have any code in particular at the moment. i know that ErrorT or EitherT would help make stuff nice when it is consistent, but i don't want to force methods to be in ErrorT just for the sake of making something simpler elsewhere
22:27:32 <kmc> ibt, are you familiar with fmap / liftM / (<$>)
22:27:44 <kmc> also the other stuff in Control.Monad
22:27:56 <ibt> isn't <$> basically fmap?
22:28:04 <kmc> yes
22:28:24 <Veinor> @quote endofunctor
22:28:24 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
22:28:24 <kmc> i meant them as a single thing with three names
22:28:25 <babusri> kmc: With -A100M, copied during GC dropped from 8k to 2k, residency went up from 2.5k to 4k. Memory in use jumped from 1 MB to 97 MB.
22:28:30 <Veinor> @quote endofunctor
22:28:30 <lambdabot> elly says: I leave for five minutes and godel numbering of endofunctors is invokved as a potential proof that the universe is simulated. Thanks, #haskell :P
22:28:35 <Veinor> @quote endofunctor
22:28:36 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
22:28:41 <kmc> (except the type on liftM is more restricted)
22:28:42 <ibt> yeah, i'm familiar with those. that doesn't seem to help me combine IO Either and IO Maybe without a case and junk
22:28:54 <kmc> ibt, you can use the function like "maybe" and "either"
22:28:55 <kmc> :t maybe
22:28:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:29:00 <kmc> :t either
22:29:01 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
22:29:26 <ibt> except i want it to short circuit on Left e or Nothing
22:29:26 <duplode> Hi all, could you help me with a tricky newbie problem of the memory-hungry-list-processing kind?
22:29:50 <ibt> i can see that i would have to add more information to a Nothing so it would make sense in Either
22:29:53 <ManateeLazyCat> duplode: Ask real problem.
22:30:28 <copumpkin> duplode: nope, sorry
22:30:32 <copumpkin> :)
22:30:48 <ManateeLazyCat> ibt: I have library to handle many IO Maybe
22:30:48 <copumpkin> duplode: but maybe if you leave the question in the channel for long enough the answer will come to you magically!
22:30:52 <ibt> kmc: ioEitherFunction `mysteryOperator` mToE ioMaybeFunction >>= ioEitherFunction2  .. i've done stuff similar to that, but it just seems bad
22:31:07 * ManateeLazyCat pasted "Maybe.hs" at http://paste2.org/get/853151
22:31:10 <ManateeLazyCat> ibt: Looks above
22:31:20 <copumpkin> MaybeT IO?
22:31:40 <copumpkin> ManateeLazyCat: maybeHead = listToMaybe
22:31:50 <ManateeLazyCat> ibt: (?>=) and (?>=>) make you write shorter code.
22:31:56 <kmc> ibt, if you can hpaste a complete example i can try to give advice
22:32:14 <ManateeLazyCat> ibt: Special you have many "IO Maybe" function need to handle.
22:32:38 <ManateeLazyCat> ibt: Maybe (>?>=>) and (>?>=) is more handy.
22:32:42 <ibt> ManateeLazyCat: it's mixed IO Bool, IO Either, IO Maybe and i just want to write it in a nice way
22:33:24 <kmc> ibt, does the Left type of your Either have a "default" value?
22:33:25 <ManateeLazyCat> ibt: Yeah, my library (http://paste2.org/get/853151) will avoid you write unnecessary Nothing branch.
22:33:33 <kmc> ibt, if so i might lift those all up
22:33:38 <ManateeLazyCat> ibt: (?>=) :: Monad m => Maybe a -> (a -> m ()) -> m ()
22:33:42 <kmc> to Either
22:33:59 <ManateeLazyCat> ibt: For (?>=), you just need focus *Just* branch, and don't care *Nothing* branch.
22:34:02 <kmc> ibt, remember that you can write your own IO combinators.  if there's a pattern your recognize you can probably make it into a function
22:34:05 <kmc> as ManateeLazyCat did
22:34:30 <copumpkin> ibt: IO Maybe and IO Either don't make sense as types :P
22:34:44 <kmc> IO (Maybe a), IO (Either a b)
22:34:49 <ManateeLazyCat> ibt: Others function is same principle that try to avoid unnecessary Branch from Maybe return.
22:34:51 <copumpkin> kmc: shh, I'm being obtuse
22:34:51 <duplode> okay, essentially what I am trying to do is to make a fold-like function, except that the function I am using for the fold relies on elements extracted from the list at regular intervals.
22:35:14 <ibt> okay, maybe i'll try to come up with an example
22:35:31 <ibt> ManateeLazyCat: some of this code looks very similar to things i've tried
22:35:51 <copumpkin> ManateeLazyCat: a lot of your functions are library functions already
22:36:01 <ManateeLazyCat> ibt: Maybe have other advanced moand to handle Maybe (like MaybeT), but my library won't change your exist code.
22:36:10 <BMeph> duplode: So, foldr f . chunk n $ list? ;)
22:36:11 <ManateeLazyCat> ibt: And make your code clearer.
22:36:47 <ManateeLazyCat> copumpkin: Can you point which functions is duplicate?
22:36:49 <ibt> ManateeLazyCat: yeah, i'm just wanting to write new code that's clearer. not filled up with nested case/if that heads off the right of my screen.
22:37:02 <copumpkin> maybeAlternate :: Maybe a -> a -> a is fromMaybe
22:37:08 <copumpkin> or rather, flip fromMaybe
22:37:13 <copumpkin> :t fromMaybe
22:37:14 <lambdabot> forall a. a -> Maybe a -> a
22:37:20 <kmc> > fromMaybe ()
22:37:21 <lambdabot>   Overlapping instances for GHC.Show.Show (Data.Maybe.Maybe () -> ())
22:37:22 <lambdabot>    aris...
22:37:23 <ManateeLazyCat> ibt: Yes, you need (?>=>) (>?>=>) (?>=) (>?>=)
22:37:26 <kmc> yikes
22:37:30 <ibt> ManateeLazyCat: i think i want EitherT/ErrorT and extra combinators that make it nice
22:37:36 <dmead> !yow
22:37:46 <ManateeLazyCat> ibt: I think Either is same principle
22:37:49 <ibt> ManateeLazyCat: but, there is no existing library or solution on hackage?
22:38:16 <ManateeLazyCat> ibt: I prefer to write those library myself, more fun. :)
22:38:25 <copumpkin> maybeBranch :: Monad m => Maybe a -> (a -> m b) -> m b -> m b is flip maybe, with a more restricted type
22:38:39 <copumpkin> @typo flip maybe :: Monad m => Maybe a -> (a -> m b) -> m b -> m b
22:38:40 <lambdabot>     Couldn't match expected type `Maybe a'
22:38:41 <lambdabot>            against inferred type `a1 -> a -> m b'
22:38:41 <lambdabot>     In the first argument of `flip', namely `maybe'
22:38:44 <copumpkin> gah
22:38:47 <copumpkin> anyway, you know what I mean
22:38:58 <BMeph> maybeBool = maybe not const, for example. :)
22:38:58 <dmwit> Not enough Maybe in the type of flip maybe.
22:39:30 <copumpkin> :t maybe
22:39:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:39:31 <dmwit> oh, I see it
22:39:34 <dmwit> sorry
22:39:37 <ibt> ManateeLazyCat: well, i'm trying to get real stuff done, not just make new combinator libraries to impress my friends :)
22:39:40 <copumpkin> it needs moar flippage though
22:39:42 <ManateeLazyCat> ibt: And my code is make function at *last* position, then you can write lambda expression and don't need parentheses, so you will got clearer code and less indent
22:39:44 <copumpkin> deepFlip
22:40:05 <dmwit> ?pl \x y z -> f z x y
22:40:05 <lambdabot> flip . flip f
22:40:18 <kmc> @nixon
22:40:19 <lambdabot> You won't have Nixon to kick around anymore, because, gentlemen, this is my last press conference.
22:40:28 <copumpkin> Monad m => Maybe a -> (a -> m (Maybe b)) -> m (Maybe b)
22:40:40 <ibt> ManateeLazyCat: been kind of thinking about writing a 'robust' library with useful combinators to help with this kind of stuff in IO. think it's a lot better than error or exceptions
22:40:50 <Veinor> type FilePath String means that FilePath is a synonym for String, yeah?
22:41:03 <dmead> Filepath = string?
22:41:04 <dmead> tyea
22:41:06 <dmead> yea
22:41:17 <dmwit> Yes, but you're not allowed to assume it.
22:41:26 <ManateeLazyCat> ibt: Sometimes error is need.
22:41:32 <ManateeLazyCat> ibt: Like my maybeError
22:41:35 <Veinor> What are we allowed to assume then?
22:41:36 <dmwit> s/allowed/supposed/
22:41:39 <copumpkin> :t (>>=)
22:41:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:41:44 <duplode> @BMeph: chunk splits a list in equal-length segments? That's equivalent to what I'm doing; the problem is that I need to keep the first element of each chunk as I move down the list
22:41:44 <dmwit> Only the public API. =)
22:41:44 <lambdabot> Unknown command, try @list
22:42:14 <BMeph> maybeAlternate = flip (flip maybe id)
22:42:20 <dmead> Veinor, it's just to add conext to the data... filepaths could be some composite type that carries around more stuff
22:42:25 <Veinor> yeah, I figured
22:42:27 <dmead> *context
22:42:29 <copumpkin> a lot of these feel a bit like traversable stuff, but with restrcited types
22:42:33 <kmc> too bad you can't not export a type synonym
22:42:43 <kmc> which would be like a wrapper-free newtype
22:42:47 <kmc> Hugs has something like this
22:43:01 <duplode> and I think that is making it impossible not to load all the list into memory at once
22:43:05 <copumpkin> BMeph: maybe id = fromMaybe :)
22:43:09 <ibt> ManateeLazyCat: i don't know. i'm not a fan of weird exceptions being thrown. haskell documentation/compiler warnings don't seem to mention that kind of thing.
22:43:21 <ibt> ManateeLazyCat: uncaught exceptions, that is.
22:43:29 <kmc> :t either (error.show) id
22:43:30 <lambdabot> forall a b. (Show a) => Either a b -> b
22:44:25 <Veinor> @src join
22:44:25 <lambdabot> join x =  x >>= id
22:44:37 <copumpkin> @src meet
22:44:38 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:44:39 <Veinor> thought so
22:44:55 <kmc> har
22:45:11 <ManateeLazyCat> ibt: Looks my maybeError.
22:45:28 <ManateeLazyCat> ibt: If Nothing branch is error, you can add some debug information in maybeError.
22:45:57 <ManateeLazyCat> ibt: When program reach Nothing branch, you can find where the problem from maybeError output.
22:46:24 <ManateeLazyCat> ibt: General, i write current toplevel-function information in maybeError.
22:46:58 <duplode> Looks like I need to provide an example of what I'm trying to do... to use hpaste.org I just have to save my code and post the link, right?
22:47:04 <andrewhavck> I've only been coding Haskell for a couple days, I have a question regarding local functions.. I keep getting a parse error on input `=' with the following code http://gist.github.com/415507.. Is my indentation incorrect?
22:47:04 <kmc> yeah
22:47:13 <Veinor> I forget, how can I get the source of the [] monad's implementation of >>=?
22:47:24 <kmc> flip concatMap
22:47:30 <kmc> @src (>>=) []
22:47:30 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:47:32 <ibt> ManateeLazyCat: i want to avoid error in my libraries
22:47:33 <kmc> @src [] (>>=)
22:47:34 <lambdabot> xs >>= f     = concatMap f xs
22:47:50 <kmc> andrewhavck, works fine for me
22:47:54 <kmc> andrewhavck, are you using tabs?
22:48:05 <kmc> never use tabs ever
22:48:09 <andrewhavck> Egh, I might need to edit my gvimrc for .hs
22:48:16 <andrewhavck> yeah, that's probably the issue
22:48:24 <Veinor> yeah, it works for me
22:48:40 <andrewhavck> thanks
22:48:52 <kmc> :)
22:49:12 <ibt> ManateeLazyCat: anyway, thanks for the hpaste stuff. i think i'll end up with something similar.
22:49:19 <ManateeLazyCat> ibt: Yes, me too. But sometimes explicitly error is better than blet queit.
22:49:29 <ManateeLazyCat> ibt: np :)
22:55:56 <duplode> here is my leaking algorithm (I simplified some of the details related to my problem domain to avoid obfuscating the issues)
22:55:56 <duplode> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25747
22:56:14 <kmc> duplode, thank you for simplifying :)
22:56:24 <kmc> it's nice that people put in the effort :)
22:57:01 <copumpkin> looks like you tried to make it tail-recursive
22:57:08 <copumpkin> which would be great in a strict language
22:57:53 <copumpkin> enable bang patterns and write g !acc
22:57:56 <kmc> duplode, first of all, the disclaimer that lazy I/O is a hack.  the simple (but ugly and un-composable) solution is to make an IO action to feed you values incrementally
22:58:09 <kmc> the nice but mind-bending solution is to learn how iteratees work and use that
22:58:12 <copumpkin> actually, since acc is a list that won't help much
22:58:14 <kmc> which is somewhere on my to-do list
22:58:48 <copumpkin> also, don't use == on phs when you can pattern match
22:58:54 <duplode> compukin: I tried that (and all sorts of tricks with seq) and they didn't help, indeed
22:58:57 <kmc> that's just sugar
22:59:14 <copumpkin> yeah, the ! won't evaluate what you want it to
22:59:21 <copumpkin> but you can add a seq, or do a deeper strict pattern match
23:00:24 <copumpkin> duplode: can you explain on a high level what this is doing? it might be possible to rewrite without explicit recursion
23:00:30 <copumpkin> thus making it much clearer and probably more efficient :)
23:01:26 <duplode> kmc: yes, incremental IO would make things way too ugly for my tastes...
23:02:48 <duplode> copumpkin: let's try it... I will use concrete values to help picturing things
23:02:53 <ManateeLazyCat> What's mean "cabal: demo/treeList/resListDND: inappropriate type" when i do "cabal sdist" ?
23:02:57 <kmc> Robin Milner: still dead
23:03:14 <copumpkin> kmc: would you prefer he be removed from the topic?
23:03:22 <copumpkin> :)
23:03:39 --- mode: ChanServ set +o copumpkin
23:03:50 <ManateeLazyCat> cabal don't support recursive directory?
23:03:54 --- topic: set to '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Milner, Rudin, Gardner"]' by copumpkin
23:03:58 <kmc> put in "RIP Alonzo Church"
23:03:59 <duplode> suppose hist, the big list, has 2000 elements
23:04:07 --- topic: set to '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Church, Milner, Rudin, Gardner"]' by copumpkin
23:04:25 --- mode: ChanServ set -o copumpkin
23:04:52 <copumpkin> duplode: ok
23:05:03 <BMeph> Add Linkletter, kplzthx! ;)
23:05:03 <alexsuraci> what about Curry?
23:05:19 <copumpkin> alexsuraci: too lazy to get up there again
23:05:23 <alexsuraci> haha
23:05:31 <BMeph> What about Schoenfinkel? ;
23:05:32 <duplode> from these 2000 elements, I will pick a number of *origins*, separated by, say, 100 elements
23:06:24 <duplode> for each of these origins I want to make a list with the difference of all elements ahead of the origin to the origin
23:06:48 <copumpkin> ah, I see
23:06:54 <duplode> the function will then return a list of these lists
23:07:25 <copumpkin> are the origins points or indices?
23:07:37 * Raynes huggles copumpkin
23:07:39 <Raynes> <3
23:07:41 <copumpkin> of all elements in what, anyway?
23:07:57 <copumpkin> Raynes: :O
23:08:10 <duplode> of all elements in the list
23:08:33 <duplode> the first origin is the first element, and I will calculate the diffs from the 1999 elements ahead
23:09:01 <duplode> the next origin would be 100 elements after, and would call for 1899 diffs and so on
23:09:11 <copumpkin> oh, hmm
23:09:17 <copumpkin> so can you give me sample input and output for a short list?
23:09:27 <copumpkin> I guess I could call the function myself :P
23:10:31 <duplode> no need, just ghci'd it
23:10:34 <duplode> tricky 2 [1..10]
23:10:44 <duplode> [[1],[3,2,1],[5,4,3,2,1],[7,6,5,4,3,2,1],[9,8,7,6,5,4,3,2,1]]
23:10:52 <copumpkin> oh, that's very regular
23:11:03 <copumpkin> that's pretty easy looking actually
23:11:22 * copumpkin thinks
23:11:44 <dmwit> > [[n, n-1 .. 1] | n <- [1, 3 .. 10]]
23:11:45 <lambdabot>   [[1],[3,2,1],[5,4,3,2,1],[7,6,5,4,3,2,1],[9,8,7,6,5,4,3,2,1]]
23:12:08 <copumpkin> it'd be nice to have more sharing
23:12:10 <copumpkin> since it's possible
23:12:30 <copumpkin> hmm
23:12:59 <kmc> > reverse . takeWhile (not . null) . iterate (drop 2) $ [1..10]
23:13:00 <lambdabot>   [[9,10],[7,8,9,10],[5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]]
23:13:11 <kmc> > reverse . takeWhile (not . null) . iterate (drop 2) $ [10,9..1]
23:13:13 <lambdabot>   [[2,1],[4,3,2,1],[6,5,4,3,2,1],[8,7,6,5,4,3,2,1],[10,9,8,7,6,5,4,3,2,1]]
23:13:15 <kmc> that will share
23:13:42 <dmwit> > let tricky n xs = iterate (drop n) (drop (length xs `mod` n) (reverse xs)) in tricky 2 [1..10]
23:13:42 <lambdabot>   [[10,9,8,7,6,5,4,3,2,1],[8,7,6,5,4,3,2,1],[6,5,4,3,2,1],[4,3,2,1],[2,1],[],...
23:14:04 <dmwit> oops
23:14:37 <duplode> *thinking on the suggestions...
23:16:47 <dmwit> > let tricky n xs = takeWhile (not . null) . iterate (drop n) . drop ((length xs - 1) `mod` n) . reverse $ xs in tricky 2 [1..10]
23:16:48 <lambdabot>   [[9,8,7,6,5,4,3,2,1],[7,6,5,4,3,2,1],[5,4,3,2,1],[3,2,1],[1]]
23:17:01 <dmwit> > let tricky n xs = takeWhile (not . null) . iterate (drop n) . drop ((length xs - 1) `mod` n) . reverse $ xs in tricky 3 [1..10]
23:17:02 <lambdabot>   [[10,9,8,7,6,5,4,3,2,1],[7,6,5,4,3,2,1],[4,3,2,1],[1]]
23:17:34 <dmwit> tricky is a weird thing to want
23:17:45 <dmwit> I'll be surprised if it ends up really being what you meant.
23:18:14 <duplode> don't worry, semantically it is correct
23:18:35 * dmwit remains unconvinced
23:20:01 <duplode> later on my program adds up all of these lists element-by element (sorta like zipWith (+), but appending the end of the longer list instead of dropping it)
23:20:29 <copumpkin> duplode: it seems like there's a more explicit way of getting the same thing
23:20:35 <copumpkin> since the "structure" of tricky is so regular
23:20:47 <copumpkin> like a scanl (+)/cumsum kind of thing, almost
23:21:52 <dmwit> > iterate (\(x:xs) -> (x+2) : (x+1) : x : xs) [1]
23:21:53 <lambdabot>   [[1],[3,2,1],[5,4,3,2,1],[7,6,5,4,3,2,1],[9,8,7,6,5,4,3,2,1],[11,10,9,8,7,6...
23:22:14 <copumpkin> it wouldn't always be with enumFromTo-generated lists though
23:22:19 <copumpkin> I'm guessing?
23:22:23 <dmwit> naturally
23:22:59 <dmwit> > map head . chunk 2 . reverse . tails . reverse $ [1..10]
23:23:00 <lambdabot>   Not in scope: `chunk'
23:23:05 <dmwit> arg
23:23:12 <copumpkin> I could've sworn split used to be loaded
23:23:13 <dmwit> > Data.List.Split.chunk 2 [1..10] -- ?
23:23:14 <lambdabot>   Not in scope: `Data.List.Split.chunk'
23:23:18 <duplode> yep, the Integer list was just a simplification so that the algorithm wasn't obfuscated
23:23:41 <dmwit> ?let chunk n [] = []; chunk n xs = take n xs : chunk n (drop n xs)
23:23:42 <lambdabot>  Defined.
23:23:46 <dmwit> > map head . chunk 2 . reverse . tails . reverse $ [1..10]
23:23:47 <lambdabot>   [[],[2,1],[4,3,2,1],[6,5,4,3,2,1],[8,7,6,5,4,3,2,1],[10,9,8,7,6,5,4,3,2,1]]
23:24:03 <Cromulent> I'm a complete newbie with haskell but can anyone explain why this producing a parse error in GHCi 6.12.1? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25750#a25750
23:24:12 <dmwit> > map (!!1) . chunk 2 . reverse . tails . reverse $ [1..10]
23:24:13 <Cromulent> it's straight out of book
23:24:13 <lambdabot>   [[1],[3,2,1],[5,4,3,2,1],[7,6,5,4,3,2,1],[9,8,7,6,5,4,3,2,1],*Exception: Pr...
23:24:29 <dmwit> ahghgh
23:24:53 <dmwit> Cromulent: Your indentation is probably screwed up before line 39.
23:24:54 <duplode> The actual type of hist is [[(Double,Double,Double)]], with each tuple corresponding to a line of my input file
23:25:05 <kmc> Cromulent, works for me as is
23:25:18 <kmc> Cromulent, but you have some leading spaces on those lines, which might be problematic
23:25:39 <dmwit> ...or your indentation could be screwed up *on* that line. =P
23:25:45 <Cromulent> dmwit and kmc: ah ok - I'll check that out - thanks for the tip
23:28:09 <duplode> the takeWhile / iterate / drop attempts look familiar; many algorithm rewrites ago I tried something of that sort but abandoned it because I thought that was causing my memory woes
23:28:39 <duplode> given the changes I later did to the algorithm it could be worth it to give that another try.
23:29:53 <BMeph> "takeWhile / iterate / drop" is chunk, just "homestyle, as it were. :)
23:30:35 <duplode> BMeph: :) (what should I import to get chunk?)
23:31:11 <duplode> oops, Data.List.Split.chunk, saw it above :)
23:31:18 <kmc> you need the "split" package
23:31:30 <BMeph> duplode: According to dmwit, Data.List.Split, from the "split" package. :)
23:31:56 <dmead> :t split
23:31:57 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
23:32:02 <dmead> :t splitBy
23:32:03 <lambdabot> Not in scope: `splitBy'
23:33:07 <duplode> seems I don't have Dat.List.Split in my installation right now, so for the moment I will implement it explicitly
23:33:27 <copumpkin> cabal install split
23:35:11 <Kaidelong> realizing that init is constant time was pretty enthralling
23:35:29 <dmwit> init is not constant time if you demand the whole thing.
23:35:30 <copumpkin> it's hard to measure time in haskell :)
23:35:43 <copumpkin> it's a function of what you ask for
23:35:51 <copumpkin> we should come up with a good way of measuring time complexity
23:35:54 <glguy> dmwit: it just adds a constant factor to the algorithm that uses the whole list anyway
23:35:57 <Kaidelong> dmwit: but demanding the whole thing without init is no worse!
23:36:04 <Kaidelong> err
23:36:06 <Kaidelong> no better
23:36:13 <Kaidelong> not asymptotically
23:36:50 <dmwit> Something that adds a constant factor to an already-linear-time algorithm is not constant time.
23:37:42 <dmead> tis still linear :o
23:37:47 <dmead> hi dan
23:37:51 <dmwit> hi dan
23:37:57 <dmead> what happening?
23:38:06 <dmead> philly lambda is at your school tomorrow night
23:38:22 <dmwit> huh
23:38:40 <dmead> PL has a meeting at wharton tomorrow night
23:39:07 <copumpkin> wow, too many dans in here
23:39:09 * copumpkin leaves
23:39:25 <dmwit> where/when?
23:39:42 <copumpkin> it will forever remain unknown now
23:39:47 <dmwit> Well, a Dan certainly left.
23:39:55 <dmwit> Not the one I was expecting, though.
23:39:58 <copumpkin> I had him assassinated for stealing my name
23:40:03 <dmead> murp
23:40:52 <dmead> http://groups.google.com/group/philly-lambda
23:41:47 <duplode> tricky' sep hist = map g $ takeWhile (not . null) . iterate (drop sep) $ hist where
23:42:02 <duplode>     g (x:xs) = map (subtract x) xs
23:42:21 <duplode> tricky' 2 [1..10]
23:42:37 <duplode> [[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7],[1,2,3,4,5],[1,2,3],[1]]
23:43:27 <duplode> (which is ok since I can just reverse the lists later on if need be)
23:43:33 <dmwit> dmead: I can't see anything; I'm not a group member.
23:43:39 <Kaidelong> still
23:43:49 <Kaidelong> strictly, init always has worst case behavior
23:43:55 <dmead> dmwit, just request to join. it's only private to avoid spam
23:43:59 <duplode> will try it something big now
23:44:36 <Kaidelong> and probably some more since with strict behavior you would need to make an entirely new list
23:45:03 <Kaidelong> while with lazy behavior no new list has to be made
23:45:14 <dmwit> That is not true.
23:45:21 <dmwit> init creates an entirely new list.
23:45:34 <dmead> dmwit, msg me your email and i'll forward the meeting announcement
23:45:41 <dmead> if you'd care to go etc etc
23:45:46 <dmwit> *tail* is constant time and does not create a new list
23:46:11 <dmwit> dmead: I can't promise I'll be able to, but you can send it to anything at dmwit.com.
23:46:15 <Kaidelong> dmwit: but wouldn't init just be defined with the init of the tail until there is only one element?
23:46:24 <dmwit> ?src init
23:46:24 <lambdabot> init [x]    = []
23:46:24 <lambdabot> init (x:xs) = x : init xs
23:46:24 <lambdabot> init []     = undefined
23:47:02 <dmwit> See that colon on the right? That's making a new list. =)
23:47:11 <dmwit> (the [] on the right is, too)
23:47:24 <Kaidelong> dmwit: okay, it is a new list, but it isn't *really* a new list
23:47:30 <dmwit> ?
23:47:36 <Kaidelong> from what I understand
23:47:41 <Kaidelong> all it stores is "init xs"
23:47:50 <dmwit> It's a different location in memory, a different thunk. How much more different can it get?
23:48:29 <dmwit> Okay, yes: you only pay for what you demand. But you need to be aware of what you're doing. You don't get to push the costs around forever.
23:48:36 <BMeph> Kaidelong: As in, it can't be shared, because the two lists end at different elements. :)
23:48:36 <dmead> > init [1..5]
23:48:37 <lambdabot>   [1,2,3,4]
23:48:40 <dmead> > inits [1..5]
23:48:41 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
23:50:30 <Kaidelong> dmwit: I suppose it's as much as a list as any list is a list in haskell, though
23:50:45 <Kaidelong> but from my background init seems amazingly forgiving
23:52:24 * dmwit nods
23:52:45 <ManateeLazyCat> Convert gnomevfs repository is darcs-2 too slow.... :-(
23:53:10 <alexsuraci> ManateeLazyCat: what darcs version?
23:53:50 <ManateeLazyCat> alexsuraci: In gtk2hs repository, we use darcs-hased format, now i'm trying to split gnomevfs from gtk2hs repository, perhaps patches is too many, convert is too slow.
23:54:09 <ManateeLazyCat> alexsuraci: I use darcs-2.4.1 (release)
23:54:33 <freiksenet> hello! I need to make a tree that can have two kind of nodes (let's say a and b) and while a can have both a and b as a child, b can only be terminal nodes. How is that possible to do that?
23:55:02 <alexsuraci> ManateeLazyCat: there was a regression that made converting very slow (exponentially so), it's fixed in 2.4.3
23:55:18 <alexsuraci> (latest is 2.4.4 now)
23:56:05 <dmwit> freiksenet: Sounds like homework.
23:56:21 <dmwit> freiksenet: We've got a very strict no-homework policy around here, as do most language channels.
23:56:24 <dmead> freiksenet, 50 bucks
23:56:27 <dmead> ;)
23:56:31 <freiksenet> :)
23:56:34 <freiksenet> that's not a homework
23:56:44 <freiksenet> I graduated one week agon.
23:56:49 <freiksenet> I am just learning haskell.
23:56:49 <dmwit> What have you tried?
23:56:53 <freiksenet> data ProjectFS = FSDirectory Directory [ProjectFSElement] | FSFile File [String]
23:56:54 <freiksenet> data ProjectFSElement = Directory String | File String
23:56:58 <ManateeLazyCat> alexsuraci: So it's a bug of darcs-2.4.1 ?
23:56:59 <duplode> okay, tested the takeWhile / iterate / drop strategy with my "production" code
23:57:01 <freiksenet> this obviously didn't work
23:57:22 <duplode> it is semantically correct, but still takes unacceptable ammounts of memory :(
23:57:26 <dmwit> freiksenet: How about taking some type variables as parameters? =)
23:57:35 <dmead> freiksenet, just have a box type you store everything in
23:57:38 <dmwit> data Tree a b = {- think about this bit some -}
23:57:44 <freiksenet> aah
23:57:45 <freiksenet> ok
23:57:55 <freiksenet> thanks
23:58:09 <alexsuraci> ManateeLazyCat: possibly, yes. a conversion I was doing of one repo on 2.4.(1 or 2, not sure) kept taking longer and longer for each patch (I eventually ctrl-C'd), with 2.4.4 it's instantaneous
23:58:35 <ManateeLazyCat> alexsuraci: Okay, i upgrade darcs now.
23:59:08 <dmwit> freiksenet: As for your actual problem, Haskell has two namespaces, the type namespace and the value namespace. They never mix.
23:59:31 <dmwit> freiksenet: In data declarations, everything to the left of the equals sign is in the type namespace. On the right, the constructors are in the *value* namespace.
23:59:42 <freiksenet> ok, thanks.
23:59:54 <duplode> it seems that the successsive drops force all of the input list to be evaluated (and taken to memory) at once
