00:02:42 <roconnor> when ghc says "out of memory (requested 2097152 bytes)" what sort of memory did it run out of?
00:02:48 <roconnor> I mean, the heap is supposed to be unlimited, right?
00:03:13 <copumpkin> you on a 32-bit machine using loads of memory, maybe?
00:04:35 <roconnor> ya
00:04:45 <roconnor> it seem to die at about 1.4 Gb
00:04:47 <roconnor> hmm
00:04:51 <roconnor> acutally that is really big
00:05:01 * roconnor sighs
00:05:04 <roconnor> laziness
00:05:09 <pastorn> haha
00:05:13 <pastorn> roconnor: deepseq :)
00:05:23 <roconnor> @index deepseq
00:05:23 <lambdabot> bzzt
00:05:41 <roconnor> I don't know how you guys deal with lazy balanced binary trees
00:05:57 <pastorn> http://hackage.haskell.org/package/deepseq
00:06:16 <gio123> copumpkin: hi
00:06:23 <copumpkin> hi!
00:06:33 <pastorn> roconnor: or do you have som infinitely growing tree?
00:06:43 <roconnor> pastorn: no I'm *deleteing* nodes
00:06:51 <pastorn> haha
00:06:52 <roconnor> if I don't delete nodes it runs fine
00:06:59 <pastorn> awesome :)
00:07:04 <roconnor> but if I delete notes, then the tree is rebalanced
00:07:10 <pastorn> true
00:07:13 <roconnor> lazily
00:07:32 <gio123> copumpkin: can u see pm for a minute
00:07:33 <pastorn> well, deepseq will make sure the whole structure gets evaluated
00:07:44 <roconnor> Well, I don't yet really understand why deleting nodes makes me run out of memory
00:08:06 <pastorn> roconnor: might be the rebalancing...
00:08:26 <pastorn> roconnor: what do you use to remove?
00:08:32 <pastorn> which function?
00:08:56 <pastorn> also: are you sure you're dropping old values (to get GCd)?
00:09:18 <roconnor> PSQ.updateWithKey
00:09:24 <pastorn> PSQ?
00:09:27 <pastorn> not Data.Map?
00:09:31 <roconnor> Data.PSQueue.updateWithKey
00:11:05 <pastorn> how big is your tree?
00:11:23 <roconnor> 200,000 nodes
00:11:23 <pastorn> (length . toList)
00:11:27 <pastorn> oh
00:12:00 <MarcWeber> Is Contorol.Monad.ST actually used anywhere?
00:12:16 <roconnor> (NFData (PSQ.PSQ (Int, Int) (Int, Int, Int)))
00:12:17 <roconnor> er
00:12:22 <copumpkin> MarcWeber: yes
00:12:24 <roconnor> No instance for (NFData (PSQ.PSQ (Int, Int) (Int, Int, Int)))
00:12:31 <pastorn> chucks
00:12:46 <copumpkin> roconnor: is PSQ your own structure or is it some opaque priority search queue?
00:13:06 <MarcWeber> copumpkin: Google search on hackage was not the way to find those packages. Maybe I have to fetch all sources and grep them
00:13:17 <roconnor> http://hackage.haskell.org/package/PSQueue-1.1
00:13:28 <pastorn> @hoogle ST
00:13:29 <lambdabot> module Control.Monad.ST
00:13:29 <lambdabot> module Data.Array.ST
00:13:29 <lambdabot> Control.Monad.ST data ST s a
00:13:30 <Jonno_FTW> .
00:13:37 <pastorn> Jonno_FTW: well?
00:13:56 <Jonno_FTW> nothing
00:13:57 <pastorn> Jonno_FTW: did you fix that cyclic import stuff?
00:14:00 <Jonno_FTW> nope
00:14:02 <pastorn> Just undefined
00:14:09 <pastorn> *baradish*
00:14:26 <roconnor> copumpkin: it appears to me to be basically a binary tree with nodes labed with size data and minimum key/data data for the entire tree
00:14:29 <Jonno_FTW> I thought about completely redoing the irc bot
00:14:39 <pastorn> copumpkin: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/PSQueue
00:14:59 <pastorn> Jonno_FTW: i like rewrites
00:15:09 <pastorn> because you know where you got stuck last time :)
00:15:24 <Jonno_FTW> i got stuck at the same place last time
00:15:30 <Jonno_FTW> at the beginning of the rewrite
00:15:35 <roconnor> why is there no instance for NFData?
00:15:42 <copumpkin> roconnor: the person probably forgot to write one
00:15:51 <copumpkin> roconnor: if the constructors are exported you could
00:16:02 <roconnor> you have to write one?
00:16:07 <copumpkin> even if they aren't, you could write a lame one
00:16:19 <copumpkin> rnf . toList or something like that
00:16:22 <Jonno_FTW> I'll use the network.irc module
00:16:34 <Jonno_FTW> If I can figue out how to use it
00:17:12 <copumpkin> roconnor: or just avoid writing one altogether and use rnf . toList
00:17:18 <pastorn> roconnor: to write an instance of NFData you probably just have to map deepseq over all the keys and values
00:17:41 <Jonno_FTW> pastorn: I'll have some free time in about 3 weeks to work on it
00:18:04 <pastorn> Jonno_FTW: it's not hard at all... you just use decode and then some basic functions
00:18:12 <pastorn> you'll get the grips of it in no time at all _)
00:18:13 <pastorn> :)
00:19:22 <pastorn> Jonno_FTW: there's a new library on hackage now :)
00:19:28 <pastorn> http://hackage.haskell.org/package/fastirc
00:19:45 <Jonno_FTW> this is relevant to my interests
00:19:49 <pastorn> indeed
00:20:06 <pastorn> oh, the Command datatype looks really nice
00:20:40 * EvanR is up late and read that as 'Commando' datatype
00:21:04 <pastorn> EvanR: complete with Arnie carrying logs over his shoulder
00:21:38 <EvanR> lol
00:21:39 <pastorn> EvanR: http://www.youtube.com/watch?v=Ceq19u-t_pM
00:22:14 <Jonno_FTW> hehe
00:22:23 <Jonno_FTW> I don't get it, how do I use this module?
00:23:10 <kmc> MarcWeber, did you get an answer to your question about ST? i'm slightly confused by what you're asking
00:23:49 <pastorn> Jonno_FTW: hmmm... Network.FastIRC.Session seems really weird
00:24:04 <pastorn> like it should be in the ./examples/ of the source, not as an exported module
00:24:27 <roconnor> pastorn, copumpkin: um, I think that using deepseq has turned my O(log n) delete into O(n) delete.
00:24:41 <copumpkin> roconnor: deepseq will automatically be O(n)
00:24:44 <pastorn> Jonno_FTW: you just use FastIRC.IO and FastIRC.Messages mostly, i figure...
00:24:53 <roconnor> copumpkin: this is unacceptable
00:24:55 <pastorn> roconnor: yes it has :)
00:25:06 <copumpkin> roconnor: I thought it was just for testing... no real algorithm should use deepseq
00:25:10 <roconnor> ah
00:25:13 <pastorn> roconnor: then have amortized deepseq
00:25:23 <pastorn> like... every tenth deletion you sync it
00:25:55 <roconnor> pastorn: that is still O(n)
00:26:20 <MarcWeber> kmc: I stumbled upon the Control.Monad.St module when reading about type families. Then I looked into it. However I can't remember having seen this module in any package in the past. That's why I asked about whether its used.
00:26:36 <pastorn> roconnor: true...
00:26:38 <roconnor> copumpkin: it's hard to tell if it the test is working since I cant get to the point where I get my space leak
00:26:44 <copumpkin> ah :/
00:26:45 <roconnor> because it is taking too long
00:27:05 * roconnor reduces the number calls to deep seq
00:27:16 <pastorn> roconnor: how's the control flow? is it first all adding and then all deleting?
00:27:37 <pastorn> or do you add and remove whenever it's needed?
00:27:39 <roconnor> pastorn: it builds a big tree
00:27:47 <roconnor> then looks up the min
00:27:57 <roconnor> and adjusts/deletes a handfull of nodes based on that
00:27:58 <kmc> MarcWeber, it's pretty important.  it's basically how we can implement algorithms that need real mutation, and call them as pure functions
00:27:58 <pastorn> oh, and removes it :)
00:28:05 <roconnor> then repeats the lookup cycle
00:28:26 <pastorn> roconnor: how about just running deepseq once the tree is built?
00:28:28 <kmc> MarcWeber, it's in the "base" package so it wouldn't be obvious just from Hackage pages which packages use it
00:28:38 <pastorn> (and just once)
00:28:49 <roconnor> I could try that
00:29:12 <roconnor> I guess (x `deepseq` x) isn't as stupid as (x `seq` x)
00:29:23 <kmc> MarcWeber, if you know how IORef works then it is not hard to learn ST, with its STRefs.  the only tricky thing is convincing yourself that "runST" actually enforces the guarantee that it would need to enforce
00:29:25 <copumpkin> yeah
00:29:40 <kmc> because "runST" is really the only thing ST can do that IO can't
00:31:23 <roconnor> pastorn: still leaks like a sieve
00:31:32 <MarcWeber> Its quite old so it surprised me that I learned about it some days ago.
00:31:32 <roconnor> I'll try with deepseq *outside* my foldr
00:31:33 <pastorn> hmm...
00:32:06 <kmc> and it's not necessary to convince yourself that "runST" is safe, if you trust the people who wrote it
00:32:25 <pastorn> roconnor: haha
00:32:29 <kmc> but it's an interesting motivating example for rank-2 types
00:32:29 <pastorn> data PSQ k p = Void | Winner k p (LTree k p) k
00:33:11 <pastorn> that's some good constructors :)
00:34:26 <jbapple> roconnor: Are you wedded to the PSQ package? If not, you could try a different balanced tree implementation
00:34:47 <jbapple> I think, based on the exposed PSQ functions, any balanced tree will do
00:35:08 <roconnor> jbapple: I'm not wedded.  It was simply jlouis's suggestion
00:35:28 <roconnor> pastorn: not it very slowly runs out of memory
00:35:34 <roconnor> pastorn: now it very slowly runs out of memory
00:36:01 <pastorn> roconnor: what is it you're actually building?
00:41:21 <roconnor> sorry that last test locked up my computer
00:41:34 <roconnor> I don't get why deepseq didn't work
00:43:27 <jbapple> So, to recap, you added some intermittent deepSeqs, but you still ran out of heap when the only live item should have been a PSQ of size ~200k words?
00:43:28 <eevar> roconnor, might want to set a GHCRTS=-MXXXm to avoid swapping to death when you have a space leak
00:43:44 <roconnor> ya
00:43:53 <roconnor> where do I set that
00:43:59 <eevar> environment vars
00:44:00 <djahandarie> That's nice
00:44:01 <roconnor> or is it just the commandline?
00:44:04 <roconnor> oh
00:46:55 <jbapple> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/runtime-control.html
00:49:40 <roconnor> pastorn: I tried making all the fields of LTree strict.
00:49:42 <Kaidelong> existential types poses their own problems
00:49:47 <roconnor> should that have worked?
00:50:03 <pastorn> roconnor: maybe trying to force it is the wrong way of doing this...
00:50:20 <Kaidelong> I think the simplest solution for me will be to restrict people to Doubles for orderables and Word32s for discretes
00:50:33 <Kaidelong> it's all going to be read from a CSV file anyway
00:51:41 <jbapple> You could try forcing a GC run
00:52:34 <jbapple> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Mem.html#v:performGC
00:52:47 --- mode: ChanServ set +o copumpkin
00:52:50 --- mode: copumpkin set +b *!*~BjornLop@201.160.239.146.cable.dyn.cableonline.com.*
00:53:10 <roconnor> woah
00:53:15 --- kick: BjornLopez was kicked by copumpkin (BjornLopez)
00:53:26 <copumpkin> (he's pming people with racist stuff)
00:53:33 <roconnor> filtering my initial list of data to fill the queue also makes it run out of memory
00:53:36 <roconnor> wtf?
00:53:40 --- mode: ChanServ set -o copumpkin
00:53:48 <roconnor> copumpkin: thanks
00:54:15 <copumpkin> my client picked a pretty shitty hostmask for that ban
00:56:54 <roconnor> how can building a smaller initial tree make me run out of memory?
00:57:47 <jbapple> does the filter run out of memory, or does building the tree run out of memory, or does the function you are working on (with the tree alterations) still run out of memory?
00:57:53 <jbapple> could you pastebin it?
00:58:32 <roconnor> jbapple: it manages to do some processing before running out of memory
00:59:41 <roconnor> jbapple: it runs fine when my filter condition is [..., 0 < v] -- but this will always be true
00:59:43 <roconnor> however
00:59:53 <roconnor> jbapple: it runs fine when my filter condition is [..., 1 < v] -- now it runs out of memory
01:00:00 <roconnor> err
01:00:05 <roconnor> jbapple: when my filter condition is [..., 1 < v] -- now it runs out of memory
01:00:27 <roconnor> buildDb2 db1 = x `deepseq` x
01:00:28 <roconnor>  where
01:00:30 <roconnor>   x = PSQ.fromDistinctAscList [(i,j) :-> (-v,i,j)|((i,j),v)<-assocs db1, 0 < v]
01:01:29 <roconnor> hmm
01:01:35 <eevar> pastebin.org
01:01:38 <roconnor> my original data length is a power of 2
01:02:52 * Kaidelong now starting work on Desurveymonkey
01:03:07 <roconnor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25675#a25675
01:06:31 <jbapple> roconnor: can you give us some input to test?
01:13:50 <jbapple> roconnor: "PSQ.size $ buildDb2 (listArray ((1,1),(1000,1000)) [1..1000000])" works for me
01:14:03 <roconnor> jbapple: nope, the paste is too big :(
01:14:14 <roconnor> hmm
01:14:55 <jbapple> so does "PSQ.size $ buildDb2 (listArray ((1,1),(1000,1000)) (filter (const True) [1..1000000]))"
01:15:03 <jbapple> Maybe there is another way to share the data with us
01:16:50 <roconnor> jbapple: http://r6.ca/temp/751b059112568840c0a4012dbbfc6ae8a8bca7de.in
01:17:57 <jbapple> PSQ.size $ buildDb2 (listArray ((1,1),(1000,1000)) (map snd (filter fst ([(True,i) | i <- [1..1000000]]++[(False,0)])))) also works for me
01:23:11 <hydo> seen cale
01:24:29 <Kaidelong> does Integral imply Enum?
01:24:35 <Kaidelong> I imagine it does
01:24:55 <roconnor> jbapple: did that test data work or not work for you?
01:25:12 <Kaidelong> > succ 5
01:25:14 <lambdabot>   6
01:25:17 <jbapple> It output a few lines
01:25:35 <Kaidelong> > succ :: (Integral a) => a -> a
01:25:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
01:25:37 <lambdabot>    arising from a use of `...
01:25:48 <Kaidelong> :t succ :: (Integral a) => a -> a
01:25:49 <lambdabot> forall a. (Integral a) => a -> a
01:25:53 <Kaidelong> okay
01:25:59 <Kaidelong> I guess that answers my question
01:26:05 <jbapple> roconnor: 3, I think, of the form "Case #:..:.."
01:26:35 <jbapple> Now I've isolated the array passed to builddb2 to see if I can make that cause a problem
01:26:39 <roconnor> jbapple: if you change (0 < v) to (1 < v) you should run out of memory
01:26:40 <kmc> preflex, seen Cale
01:26:40 <preflex>  Cale was last seen on #haskell 7 hours, 34 minutes and 24 seconds ago, saying: @tell dibblego exponentiation is right-associative
01:29:01 <jbapple> roconnor: yup
01:29:07 <roconnor> :)
01:29:20 <roconnor> finally, an explaination for this insanity
01:29:23 <jbapple> Maybe it's a rewrite rules thing
01:29:43 <jbapple> wait, that doesn't make any sense
01:32:18 <Kaidelong> how can I find out how tightly an infix operator binds without looking at source?
01:32:46 <jbapple> roconnor: Here is a fix. I do not know why it works. Maybe GHC core can tell you:
01:33:01 <jbapple> oh, wait, that's not a fix at all
01:33:01 <jbapple> nm
01:36:01 * Kaidelong needs an operator to bind more tightly than (!) for arrays but can't find out what (!)'s fixity is
01:36:05 <jbapple> roconnor: Maybe its a bug in PSQueue
01:36:11 <roconnor> jbapple: ah I think I found a fix
01:36:18 <jbapple> This is why libraries should be verified
01:36:18 <roconnor>                    | otherwise = Just (v',(db1' `deepseq` db1',db2'))
01:36:21 <pastorn> Kaidelong: :i (!)
01:36:37 <roconnor> jbapple: I think it is my db1' that is overflowing the memory
01:36:54 <roconnor> before when db2 was full it would be always accessing every point in db1
01:36:56 <Kaidelong> pastorn: that didn't help
01:37:08 <roconnor> but now that I remove elements of db2, it doesn't touch db1 as much anymore
01:37:09 <Kaidelong> it printed its type, and then said -- Defined in Data.Array.Base
01:37:21 <pastorn> Kaidelong: hmm...
01:37:27 <roconnor> and since db1 is being updated
01:37:52 <roconnor> if it isn't entirely forced it keep *the entire previous array* (I conjecture) around
01:38:21 <Kaidelong> patorn: it works on other infix operators, but not (!)...
01:38:22 <pastorn> Kaidelong: it's the same as standard defined operators...
01:38:23 <roconnor> I should use unboxed arrays
01:38:24 <pastorn> whatever that is
01:38:45 <roconnor> or diff Arrays
01:39:19 <jbapple> ok
01:39:32 <jbapple> Well, I'm glad you have it worked out now
01:39:41 <roconnor> would a memory profiler have helped?
01:39:45 <jbapple> But I'm sad Haskell made it hard
01:39:52 <pastorn> Kaidelong: i.e. :i (+) gives you it's fix:ness
01:39:52 <roconnor> does it say what things are leaking space?
01:40:22 <jbapple> Well, it tells you what is allocating, but it seems like you already had that figured out
01:40:59 <roconnor> does it say what is being deallocated?
01:41:16 <Kaide> pastorn: Yeah, it works with other things, just not (!)
01:41:18 <roconnor> my problem is that since I was modifying db2 I assumed it was db2 that was leaking
01:41:25 <roconnor> when in fact it was db1
01:41:28 <Kaide> or (!!)
01:41:43 <Kaide> but (!!) has a fixity of 9, so I suppose (!) has the same
01:41:53 <Kaide> I'll give mine 9 too then
01:41:57 <jbapple> roconnor: I don't think so, and I think local definitions are not profiled at all
01:42:04 <pastorn> Kaide: just try it out
01:42:24 <pastorn> (fromList [1..10]) ! 1 + 100
01:42:36 <pastorn> and then try different functions until you break something
01:45:22 <roconnor> http://www.haskell.org/haskellwiki/Arrays
01:45:45 <roconnor> wait, nevermind
01:51:59 * hackagebot arrows 0.4.2.0 - Arrow classes and transformers  http://hackage.haskell.org/package/arrows-0.4.2.0 (RossPaterson)
01:52:15 <copumpkin> I wonder what's new there :o
02:04:25 <kmc> arrows 420 :O
02:05:19 <copumpkin> you know what that means
02:05:30 <roconnor> I think just switching to DiffArrays makes my leak disappear
02:05:32 <copumpkin> #haskell-stoners
02:06:36 <kmc> joining
02:08:33 <Kaidelong> if I want a type alias like this: (Integral s) â‡’ LabeledTable s = (Schema s, Table s Entry)
02:08:42 <Kaidelong> do I use newtype or data?
02:08:45 <pimeys> #haskell-stoners <3
02:08:48 <pimeys> :D
02:09:31 <kmc> Kaidelong, «newtype A = A (X, Y)» and «data A = A X Y» will have very similar runtime repr. on GHC
02:09:59 <kmc> the point of newtype is to not introduce another layer of wrapping.  and the tuple is already a layer of wrapping, so you might as well merge it into your type
02:10:16 <kmc> unless you have other code which needs that tuple exactly
02:10:20 <kmc> and so you want to unwrap to it
02:10:31 <kmc> anyway when you say "type alias" i think not newtype or data but rather "type"
02:10:35 <kmc> which is just a synonym
02:10:41 <Kaidelong> kmc: type doesn't allow for contexts
02:10:53 <kmc> damn
02:12:42 <Kaidelong> maybe I'm looking for type families
02:13:14 <Kaidelong> no I'm not
02:14:30 <kmc> use type families if you want to "pattern match" on the lhs of the =, that is have types other than wariables
02:14:40 <hydo> Coudn't match the expected type Data.ByteString.Internal.ByteString against inferred type Data.ByteString.Lazy.Internal.Ha.Ha.Dude.You.Suck.ByteString... There's got to be something that makes this easier that I'm just not getting.
02:14:40 <kmc> type First (a,b) = a; type First (a,b,c) = a
02:14:44 <roconnor> wow
02:14:58 <roconnor> for the first time I don't know how to do this problem efficently in haskell
02:15:12 <roconnor> at least not without resorting to using the ST monad
02:15:29 <copumpkin> type instance?
02:15:32 <Jedai> hydo: You "just" have not to mix lazy and strict bytestring....
02:15:35 <agapeamarante>  /msg lambdabot @. elite nixon
02:15:46 <pastorn> roconnor: i think you should avoid diffarrays
02:15:55 <roconnor> pastorn: I think so too
02:15:56 <pastorn> roconnor: at least if you ever touch old values
02:16:02 <Jedai> roconnor: What is it ? (and I second pastorn about diffarray
02:16:03 <roconnor> I don't ever touch old values
02:16:35 <pastorn> they're supposedly good for just doing stuff with the latest values, but if you ever need old iterations there's a big performance hit
02:16:36 <roconnor> Jedai: google code jam round 1C question C.
02:16:50 <Jedai> Every time I used DiffArray I was consterned by the performances
02:16:53 <Cale> hydo: looking for me?
02:17:03 <roconnor> pastorn: well, laziness might make me touch old values
02:17:18 <roconnor> since the new values are based on the old valuese
02:17:21 <roconnor> values
02:17:46 <roconnor> oh
02:17:51 <roconnor> that gives me an idea
02:18:14 <pastorn> @hoogle String -> ByteString
02:18:14 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
02:18:14 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
02:18:14 <lambdabot> Prelude read :: Read a => String -> a
02:18:32 <hydo> Cale: Oh yea - Is there a way to load an image with your imlib package from a (Byte)String?  I looked at the haddock docs and didn't see one, but I thought I'd ask you just in case there was something I missed.
02:18:35 <kmc> yeah, i meant "type instance" sorry
02:18:46 <Cale> hydo: ByteString didn't exist when I wrote that package
02:19:15 <hydo> Cale: awright..
02:19:21 <roconnor> Chess0: <<loop>>
02:19:25 <roconnor> ah right, that doesn't work
02:19:33 <Kaidelong> :i Word32
02:19:44 <roconnor> I forgot
02:19:44 <Kaidelong> hmm
02:19:52 <roconnor> the new values are based on the old values and the new values!
02:19:59 <Kaidelong> oh ok
02:20:19 <copumpkin> lol, http://gergo.erdi.hu/projects/metafun/
02:20:29 <copumpkin> compile your haskell(-like language) to c++ templates!
02:20:57 <Cale> hmm
02:21:13 <systemfault> Haha
02:21:14 <pastorn> roconnor: no, i was talking about do { a0 <- mkDiffArr; a1 <- modifyDiffArr; stupidUsage a0 }
02:21:30 <systemfault> copumpkin: Fun project :)
02:21:39 <roconnor> pastorn: ya none of that
02:21:46 <roconnor> my array access is "sequential"
02:21:58 <pastorn> then you can probably use diffarr
02:22:09 <pastorn> oh
02:22:17 <pastorn> *modifyDiffArr a0
02:22:20 <roconnor> it's still too slow
02:22:24 <pastorn> but i guess you got that
02:22:28 <roconnor> ya I got that
02:23:32 <Kaidelong> hmm
02:23:34 <pastorn> nooooooooooooooooooooooooooooooooooooooooooooooooooooo
02:23:36 <pastorn> not this shit again
02:23:39 <pastorn>     Couldn't match expected type `Data.ByteString.Internal.ByteString'
02:23:41 <pastorn>            against inferred type `ByteString'
02:23:45 <pastorn> i hate this
02:23:58 <Kaidelong> I guess the lesson I'm learning is not to mess with polymorphism in haskell unless you really, really, really have to
02:24:15 <copumpkin> pastorn: you're using a lazy one and it wants a strict one
02:24:22 <roconnor> @type runST
02:24:22 <copumpkin> from/toChunks
02:24:23 <lambdabot> forall a. (forall s. ST s a) -> a
02:24:50 <pastorn> copumpkin: there's no Data.ByteString.Strict.Char8
02:24:55 <Cale> Kaidelong: Well, what do you mean by that?
02:25:07 <roconnor> is there a function to convert a boxed array to an unboxed array?
02:25:09 <Cale> Kaidelong: We use polymorphism all over the place.
02:25:10 <copumpkin> it'd be nice if runST could be extract
02:25:29 <kmc> polymorphism is really fundamental
02:25:38 <Kaidelong> Cale: but it introduces a lot of hurdles when trying to do things
02:25:41 <kmc> what are you trying to do that's problematic?
02:25:58 <Kaidelong> kmc: I was trying to make a type alias that worked with any integral s
02:25:58 <copumpkin> polymorphism is very natural ;)
02:26:07 <copumpkin> type aliases tend to be ugly
02:26:09 <Kaidelong> but you can't have a context in a type alias
02:26:10 <Cale> Kaidelong: It's possible to abuse it and invent all sorts of typeclasses you don't really need...
02:26:20 <Kaidelong> so I ended up just using Int
02:26:21 <copumpkin> Kaidelong: I think there's an extension that lets type aliases do more
02:26:34 <copumpkin> can't remember what it's called now
02:26:43 <pastorn> Kaidelong: that's what you have GeneralizedNewtypeDeriving for :)
02:26:57 <kmc> i thought we had that for making our type system unsound ;P
02:27:13 <pastorn> Kaidelong: http://necrobious.blogspot.com/2009/03/fun-example-of-haskells-newtype.html
02:27:22 <EvanR> Kaidelong: i think its more common to make function polymorphic than data types
02:27:23 <copumpkin> has anyone proposed a fix for that btw?
02:27:37 <EvanR> make your functions operate on any Integral type for example
02:28:24 <Kaidelong> EvanR: yes, I was doing that all the time before, but now that I'm really starting to learn about classes and data types, suddenly I find out that there are a lot of limits on what you can do without extensions
02:28:38 <Kaidelong> and some problems when you do use the extensions
02:28:40 <kmc> yeah
02:28:50 <kmc> but i think the inability to put contexts on type synonyms is a pretty specific thing
02:28:51 <EvanR> instance of a class doesnt need to be polymorphic
02:28:59 <kmc> and that it would be wrong to draw the conclusion "don't use polymorphism"
02:29:09 <kmc> but you are right that various caveats apply
02:29:38 <Kaidelong> kmc: it seems to make it very difficult to make the compiler happy, as opposed to just saying "this field is an Int" or "this field is a Double"
02:29:44 <kmc> yeah
02:29:52 <kmc> it is harder to write more general code
02:30:04 <kmc> parametric polymorphism is pretty straightforward
02:30:12 <roconnor> what I really need is a lazy unboxed array.
02:30:14 <Kaidelong> perhaps in the future whatever comes after haskell will make it easier to write more generic data types
02:30:16 <kmc> but type classes (ad-hoc polymorphism) introduce extra complication
02:30:23 <copumpkin> roconnor: how would that work?
02:30:34 <copumpkin> the laziness comes from it being a closure
02:30:39 <copumpkin> unboxed makes it not be
02:30:40 <kmc> because they are basically a system of implicit arguments and parameters
02:30:47 <roconnor> copumpkin: like excel
02:30:47 <kmc> which can get messy
02:30:55 <pastorn> Kaidelong: checked that link?
02:31:03 <Kaidelong> pastorn: some of it
02:31:07 <copumpkin> roconnor: hmm, not sure how excel is unboxed
02:31:08 <pastorn> it's neat stuff :)
02:31:12 <Kaidelong> pastorn: now all of it
02:31:14 <kmc> "lazy unboxed" could work with tagged values
02:31:17 <kmc> it would be a pretty massive hack
02:31:26 <kmc> but you'd still have to check every value before you used it
02:31:27 <pastorn> Kaidelong: that's how you avoid space shuttles to burn and die :)
02:31:33 <copumpkin> hmm
02:31:33 <kmc> which might actually be more expensive than entering a closure
02:31:37 <EvanR> generic data seems doubly polymorphic, if you are also talking about instancing
02:31:42 <kmc> perhaps a packed bitfield of "is it evaluated or not"
02:31:45 <Kaidelong> pastorn: wasn't that a probe?
02:31:48 <roconnor> copumpkin: isn't the entire sheet computed when only part of it is displayed?
02:31:49 <kmc> + a dense strict unboxed array
02:31:53 <pastorn> Kaidelong: might have been
02:31:53 <kmc> + a sparse map of thunks
02:32:06 <copumpkin> roconnor: oh, not sure
02:32:12 <copumpkin> still not what I'd call unboxed
02:32:21 <copumpkin> I typically just mean a flat representation with no pointers
02:32:24 <roconnor> ah
02:32:32 * Kaidelong has to go, thanks everyone for helping though
02:32:38 <pastorn> what was the problem with Challenger?
02:32:39 <copumpkin> damn, I'm tired
02:32:39 <roconnor> pastorn: I finally found the right magic set of seq statements to get this to work
02:32:41 <copumpkin> must stay awake
02:32:49 <pastorn> roconnor: hahahaha
02:32:56 <pastorn> roconnor: no deepseq?
02:33:00 <copumpkin> randomly permute until it works!
02:33:01 <roconnor> nope
02:33:06 <pastorn> cool
02:33:07 <roconnor> pastorn: deepseq is too slow
02:33:17 <copumpkin> or too deep
02:33:17 <roconnor> pastorn: it works on the entire structure, not the points I modified
02:33:21 <pastorn> roconnor: yes, you created a pair :p
02:33:37 <roconnor>   db1' = db1//updates
02:33:38 <roconnor>   db1'' = foldr (\(a,_) b -> db1'!a `seq` b) db1' updates
02:33:42 * kmc slaps pastorn around a bit with a rusty O-ring
02:33:48 <roconnor> that is my magic set of seqs
02:34:01 <roconnor> so db1' is updated
02:34:05 <pastorn> hehe
02:34:08 <roconnor> then I force all the new cells to be evaluted
02:34:19 <roconnor> copumpkin: like in excel :D
02:34:24 <copumpkin> :P
02:34:58 * pastorn tries to use the fastirc library...
02:35:21 <roconnor> pastorn: so my optimization of actually removing stuff from my priorty queue brought my runtime down from 3 min to 2m30s
02:35:31 <roconnor> not so bad
02:35:37 <roconnor> still too slow
02:35:47 <roconnor> I'd really like to do this in under 10 seconds
02:35:58 <roconnor> but I might need more radical adjustments
02:36:05 <pastorn> roconnor: do you know that that is possible?
02:36:19 <roconnor> not sure
02:36:26 <roconnor> I think C programs do this in a second
02:36:32 <pastorn> oh, ok
02:36:41 <roconnor> I guess I could try them
02:38:31 <copumpkin> roconnor: what are you making?
02:39:00 <roconnor> copumpkin: google code jam round 1C problem C
02:39:25 <copumpkin> 2009?
02:39:47 <roconnor> 2010
02:40:01 <djahandarie> 2020
02:40:10 <copumpkin> lol
02:40:11 <c_wraith> making chess boards?
02:40:17 <roconnor> yes
02:40:20 <copumpkin> " It is a little-known fact that chess boards are made from the bark of the extremely rare Croatian Chess Board tree, (Biggus Mobydiccus)."
02:40:23 <roconnor> I'm trying to implement the given solution
02:40:36 <roconnor> so far it has been 12 hours I've been at it :D
02:40:43 <roconnor> but I slept for most of that time
02:41:09 <keep_learning> kindly tell me what is the difference between these two haskell codes map (\x->x**2) [1..10] and map (\x->x*x) [1..10]
02:41:18 <keep_learning> it gives me a list
02:41:49 <keep_learning> [1,4,9,16,25,36,49,64,81,100] from first one
02:41:59 <pastorn> @type (**)
02:41:59 <lambdabot> forall a. (Floating a) => a -> a -> a
02:42:00 <roconnor> keep_learning: one uses floating point
02:42:08 <pastorn> @type (*)
02:42:09 <lambdabot> forall a. (Num a) => a -> a -> a
02:42:13 <keep_learning> [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0]
02:42:20 <copumpkin> keep_learning: you have them backwards :)
02:42:41 <copumpkin> > map (\x->x**2) [1..10]
02:42:42 <lambdabot>   [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0]
02:42:45 <copumpkin> > map (\x->x*x) [1..10]
02:42:46 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
02:42:53 <keep_learning> thank you all
02:42:55 <c_wraith> huh.  the problem tells you exactly what search heuristic to use, so it's really juse about using dynamic programming effectively?
02:43:12 <c_wraith> err, *just
02:43:13 <copumpkin> use the histodynamoprhism!
02:43:14 <copumpkin> ;)
02:43:15 <roconnor> c_wraith: I even read the solution
02:43:25 <copumpkin> , luke
02:43:39 * copumpkin misses lunabot
02:44:13 <markus_> hi! a noobish question: I have a module Field with "data Field = Field (Int,Int) [[Cell]]". I import this module into another and when I create a function which tries to pattern-match the Field constructor like "Field (x,y) table", then GHCi says that "data constructor Field is not in scope"...
02:44:23 <roconnor> pastorn: er okay.  So the first C program I tried also to 2m30 sec
02:44:25 <roconnor> :D
02:44:27 <kmc> keep_learning, it's inferring the type of x.  if you use (**) then it knows x has to be in the "Floating" type class, and will default to Double
02:44:37 <markus_> but using Field in the function-signatures works
02:44:46 <kmc> keep_learning, if you only use (*) then it only knows that x has to be in "Num" (which is a superset of "Floating") and it will default to Integer or something
02:44:49 <markus_> and also using other functions from that module works
02:45:08 <kmc> markus_, does the module export the type constructor Field *and* the data constructor Field
02:45:15 <kmc> module Foo(Field) where -- only the type ctor
02:45:23 <kmc> module Foo(Field(..)) where -- type ctor and all data ctors
02:46:12 <djahandarie> roconnor, lies! Keep optimizing!!
02:46:29 <markus_> this was it -- thank you!
02:46:53 <markus_> it only exported the type constructor
02:47:05 <pastorn> roconnor: cool :)
02:47:17 <pastorn> roconnor: BUT what was the C implementations memory footprint?
02:49:21 <roconnor> I think the C code is just a dumb search
02:50:06 <pastorn> roconnor: is it using proper priority queues?
02:50:31 <roconnor> okay this other c code runs in 4 seconds
02:50:37 <pastorn> haha
02:50:57 <roconnor> I didn't see any priority queues in the first program
03:03:04 <Cale> I find it somewhat surprising how much more attention the final episode of Lost is getting on the torrents than the rest of the episodes. Who watches only the last episode of a TV series? :)
03:05:28 <xerox> @seen Pseudonym
03:05:29 <lambdabot> Unknown command, try @list
03:05:33 <xerox> copumpkin: yah
03:06:02 <copumpkin> too late!!
03:06:10 <kmc> it just came out
03:07:20 <Cale> kmc: The other episodes had just come out when I downloaded them too :)
03:07:34 <xerox> I was sleeping :(
03:07:39 <Cale> (but there are at least twice as many people on this one)
03:07:48 * copumpkin is reading awodey on his ipad
03:07:59 <copumpkin> trying to keep myself awake
03:08:24 <kmc> copumpkin, you have an ipad? you must be awesome
03:08:30 <copumpkin> I most certainly am
03:08:39 <Cale> That book has so many plot twists
03:08:46 <kmc> awodey?
03:08:49 <Cale> hehe
03:08:54 <copumpkin> hell yeah
03:09:10 <kmc> spoiler alert
03:09:34 <xerox> two great mathematicians dead in three days :(
03:09:42 <copumpkin> yeah :/
03:09:43 <kmc> who died?
03:09:43 <systemfault> A jailbroken ipad with hugs on it is cool :P
03:10:01 <xerox> on the 20th walter rudin, on the the 22nd martin gardner
03:10:07 * copumpkin was too lazy to jailbreak his ipad
03:10:16 <xerox> respectively 89 and 95 years old
03:11:11 <kmc> also, Robin Milner is still dead
03:11:17 <copumpkin> lol
03:11:32 <copumpkin> maybe that should go in the topic?
03:11:55 <djahandarie> Why am I getting this type signature? join (.) :: (Monad ((->) (b -> b))) => (b -> b) -> b -> b
03:11:56 <alpounet> xerox, who's the second ?
03:12:08 <copumpkin> alpounet: gardner
03:12:09 <alpounet> oh
03:12:15 <copumpkin> gardiner?
03:12:30 <copumpkin> no i
03:12:30 <xerox> alpounet: he had a famous column called "mathematical games" in scientific american, for a very long time
03:12:57 <xerox> besides the many books :)
03:13:11 <alpounet> yeah
03:13:28 <Cale> :t join (.)
03:13:29 <lambdabot> forall a. (a -> a) -> a -> a
03:13:33 <Cale> djahandarie: import Control.Monad.Instances
03:14:27 <djahandarie> Ah
03:15:05 <Cale> The instance of Monad for functions isn't in the Prelude for some reason
03:15:29 <copumpkin> "it might confuse people! heaven forbid"
03:15:41 <xerox> that clashes with function-are-first-class-citizens
03:15:43 <copumpkin> why did people even create Reader?
03:16:01 <copumpkin> just symmetry with writer?
03:16:33 <xerox> after do they were out of sugar
03:17:33 <quicksilver> copumpkin: if you mean, why Reader as opposed to just (->) r, the answer is probably that monad instances for newtypes are less confusing than monad instances for (->)
03:17:35 <pastorn> copumpkin: it's easier to grasp than (r -> a) ?
03:17:47 <copumpkin> I guess
03:17:49 <pastorn> echo
03:18:25 <quicksilver> in particular, the main problem with a monad instance for (->) it it makes lots of typoes (missing of the large argument of a function in a monadic operation) turn into things that type-check in surprising ways
03:18:35 <quicksilver> s/large/last/
03:18:44 <djahandarie> :t join (.) concat
03:18:45 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
03:18:45 <lambdabot>       Expected type: [[a]] -> [a]
03:18:45 <lambdabot>       Inferred type: [[a]] -> [[a]]
03:18:49 <pastorn> quicksilver: you echo badly :(
03:18:55 <quicksilver> ...which then leads to either surprising behaviour, or a surprising type error elsewher.e
03:19:30 <quicksilver> :t putStrLn >> putStrLn
03:19:31 <lambdabot> String -> IO ()
03:19:33 <quicksilver> for example.
03:20:20 <copumpkin> that's amusing :)
03:21:06 <kmc> what quicksilver said
03:21:20 <quicksilver> if GHC's error messsage were generally good, then this would be an excellent reason to keep the instance out of the prelude.
03:22:08 <quicksilver> however, since GHC's error messages are generally about as useful to a new haskell programmer as a bicycle to a fish, the argument rings a little hollow.
03:22:26 <systemfault> Ah... I'm not alone then
03:22:58 <systemfault> I always found pages of C++ template errors easier to understand than GHC errors :(
03:23:02 <quicksilver> it's extremely difficult to produce good error messages for haskell, for some reason.
03:23:13 <pastorn> systemfault: heh :)
03:23:23 <quicksilver> the problem is that the compiler can't distinguish between an elementary mistake and some altogether more general class of mistake
03:23:29 <quicksilver> so it's forced to give the general error.
03:23:40 <copumpkin> systemfault: wow, I don't find them bad at all
03:23:50 <copumpkin> and after years of c++ I still wince at large template error
03:23:51 <copumpkin> s
03:23:52 <systemfault> That's a problem of GHC or a more general haskell problem?
03:23:59 <quicksilver> it's a general haskell problem.
03:24:05 <systemfault> Ah ok :)
03:24:17 <copumpkin> the main issue with ghc's errors for me is remembering what's expected and what's inferred
03:24:19 <pastorn> systemfault: the only error that i get confused by is "type is not unambiguous enough"
03:24:29 <quicksilver> copumpkin: they're mostly fine once you know what they mean. (haskell error message)
03:24:36 <quicksilver> but they're very unapproachable until you do.
03:25:16 <systemfault> I'll get used to them :)
03:25:24 <systemfault> I love Haskell so far
03:27:39 <copumpkin> yay
03:27:50 * hackagebot Eternal10Seconds 0.1 - A 2-D shooting game  http://hackage.haskell.org/package/Eternal10Seconds-0.1 (HirotoKoyama)
03:28:17 <djahandarie> So why does join (.) concat try to construct an infinite type?
03:28:28 <copumpkin> :t join (.)
03:28:29 <lambdabot> forall a. (a -> a) -> a -> a
03:28:31 <copumpkin> :t concat
03:28:32 <lambdabot> forall a. [[a]] -> [a]
03:28:35 <copumpkin> stick those together :)
03:28:43 <copumpkin> (a->a) and [[a]] -> [a]
03:28:51 <copumpkin> it's saying that [[a]] and [a] must be the same
03:28:54 <copumpkin> or that [a] = a
03:28:56 <djahandarie> Ah
03:30:35 <djahandarie> I should probably not be coding right now because these are some painfully obivous questions I'm asking
03:30:52 <Axman6> anyone know a good dool for doing a binary diff?
03:30:55 <Axman6> tool*
03:30:58 <copumpkin> bdiff
03:31:01 <copumpkin> :P
03:31:05 <Axman6> dounds good to me
03:31:10 <copumpkin> djahandarie: not painfully obvious
03:32:03 <djahandarie> copumpkin, obivous enough that I would have caught them myself any other day
03:34:35 <Axman6> copumpkin: macports didn't have bdiff, but it did have vbindiff, which is quite nice indeed
03:35:18 <Axman6> now i just wonder wtf a pdf made using ps2pdf from a ps file made from haskell profiling data would have a full stop after the EOF
03:50:19 <djahandarie> Is there a irc bot which is just basically a wrapper around mueval?
03:54:04 <xerox> preflex?
03:56:22 <copumpkin> I don't think preflex does any haskell eval does it?
03:57:02 <xerox> , 2+2
03:57:12 <xerox> hmm
03:57:12 <Philippa> djahandarie: if you keep asking the questions there's no reason not to code, you'll just be slower? It's when you don't ask either that you're  in trouble
03:58:13 <djahandarie> Philippa, ... huh?
03:59:13 <xerox> which one was the bot that did ,time <expr>
04:01:24 <quicksilver> xerox: lunabot
04:02:21 <Philippa> djahandarie: painfully obvious questions just mean you're having a slow day, it doesn't make you dangerous. It's the stuff you think you have an answer to and don't that's dangerous/means you shouldn't code.
04:03:35 <Philippa> in other words, don't kick yourself too hard :-)
04:03:37 <Axman6> , 1+1
04:03:47 <zygoloid> knowing what you don't know is valuable
04:04:05 * hackagebot Eternal10Seconds 0.2 - A 2-D shooting game  http://hackage.haskell.org/package/Eternal10Seconds-0.2 (HirotoKoyama)
04:04:48 <Axman6> factories are always the answer
04:05:00 <Axman6> especially when it comes to making more factories
04:05:11 <djahandarie> Philippa, I wasn't kicking myself. I was just saying I should take a break because I've been failing to notice simple things.
04:06:01 <Philippa> *nod*. Ah, temporary stop rather than for the day, my bad
04:10:53 <roconnor> @type maybe
04:10:54 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:12:38 <roconnor> @type fromMaybe
04:12:39 <lambdabot> forall a. a -> Maybe a -> a
04:20:09 * hackagebot clientsession 0.4.0.1 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.4.0.1 (MichaelSnoyman)
04:21:51 <janbanan> Is the regular expression ab+abab(ab)* equal to (ab)*?
04:22:00 <ivanm> no
04:22:21 <ivanm> for starters, the first one allows abbbbbbbbbbbbbbbbbabab
04:22:30 <Axman6> (ab)* can't match abbbab, which the first one can
04:22:43 <ivanm> Axman6: the first one can't match that either!
04:22:48 <Axman6> that was just excessive ivanm :P
04:22:48 <ivanm> you need an extra ab on the end
04:22:53 <Philippa> no, you don't
04:22:55 <ivanm> eh
04:22:59 <Philippa> * matches 0 or more
04:23:02 <Axman6> ah so you do
04:23:05 <ivanm> Philippa: look at it again!
04:23:23 <ivanm> that's equivalent to ab+(ab){2,} (if I have the {} syntax right)
04:23:48 <Philippa> oh, sorry, misread Axman6
04:23:53 <Axman6> the first one is the same as abb*abab(ab*)
04:24:08 <ivanm> Axman6: which is even more verbose
04:24:14 <ivanm> you can also have ab+ab(ab)+
04:24:14 <Axman6> yes...
04:25:37 <Axman6> in reality, + is unnecessary in regular expressions right?
04:25:44 <mjrosenb> Axman6: yes
04:25:48 <Axman6> well, in theory i guess
04:25:51 <Philippa> there's a much shorter counterexample though - the second accepts "", the first takes "ababab" as smallest input
04:25:56 <mjrosenb> X+ == XX*
04:25:56 <Axman6> it's handy in reality :)
04:26:20 <ivanm> preflex: seen dobblego
04:26:20 <preflex>  dobblego was last seen on #haskell 5 days, 23 hours, 40 minutes and 22 seconds ago, saying: there are copy/paste implementations in Java/C#
04:26:21 <mjrosenb> useful if you wantto avoid grep -E :-p
04:26:35 <dobblego> ivan, hmm?
04:26:40 <dobblego> ivanm,
04:26:51 <ivanm> dobblego: any chance yet of you coming to AusHack?
04:27:01 <dobblego> there is a chance, yes
04:27:08 <ivanm> \o/
04:28:27 <Axman6> hooray :)
04:28:34 <ivanm> Axman6: oh, for AusHack, I've got the option of staying in the same hotel as you and Sarah or the one next door for $5/night cheaper (with only a single room rather than a double) >_>
04:29:03 <Axman6> what's the other one offer, apart from being cheaper?
04:29:20 <dobblego> @where aushack
04:29:20 <lambdabot> I know nothing about aushack.
04:29:45 <ivanm> @where+ AusHack http://www.haskell.org/haskellwiki/AusHac2010
04:29:46 <lambdabot> Okay.
04:30:35 * copumpkin has been awake for way too long
04:30:55 * ivanm bangs copumpkin over the back of his head with a four-by-two
04:31:01 <copumpkin> nah, I must not sleep!
04:31:02 <Lemmih> copumpkin: Did your lady friend find a place to stay?
04:31:25 <ivanm> copumpkin has a lady friend again?
04:31:26 <mjrosenb> copumpkin: you sound like a good man
04:31:28 <copumpkin> Lemmih: nah, (almost) everything that could go wrong did go wrong, which is why I'm still up :P
04:31:30 <ivanm> >_>
04:32:06 <copumpkin> ivanm does not approve!
04:32:16 * ivanm didn't say that...
04:32:24 * copumpkin can read his shifty eyes
04:32:24 <ivanm> I'm just amazed, that's all! :p
04:32:28 <copumpkin> lol
04:32:30 <copumpkin> ssh
04:32:34 <nominolo> preflex: seen byorgey
04:32:35 <preflex>  byorgey was last seen on #haskell 20 hours, 5 minutes and 29 seconds ago, saying: bah
04:32:41 <ivanm> preflex: seen dons
04:32:41 <preflex>  dons was last seen on #haskell 14 hours, 26 minutes and 48 seconds ago, saying: and more
04:36:09 <roconnor> pastorn: w00t down to 26 seconds for my haskell solution
04:36:17 <roconnor> that's probably good enough for me
04:36:19 <copumpkin> roconnor: yay!
04:36:36 <roconnor> about 5x the C code
04:37:12 <roconnor> though my code could use some serious clean up now that it has been modified so much.
04:37:42 <roconnor> Bonus, I don't use seq at all anymore
04:37:47 <roconnor> I never did like seq
04:37:50 <copumpkin> bang patterns?
04:37:54 <roconnor> nope
04:37:55 <copumpkin> or just better code
04:37:59 <roconnor> better code
04:38:06 <roconnor> only create data that I will use
04:38:08 <roconnor> :D
04:38:35 <roconnor> or something like that
04:39:30 <copumpkin> :)
04:39:58 <roconnor> actually
04:40:06 <roconnor> I think the big win is removeing array updating
04:40:10 <roconnor> aka (//)
04:40:22 <roconnor> now my arrays are static and have short liftetimes
04:40:36 <roconnor> the are created and then used to update the priority queue
04:40:41 <roconnor> and then they disappear
04:41:12 <roconnor> my priority queue has to do a bit more work, but still it is clearly an overall win
04:41:23 <roconnor> since this is 5x faster than my previous code
04:42:50 <copumpkin> cool
04:43:47 <roconnor> copying arrays is a killer :D
04:44:08 <ivanm> roconnor: what's this that you're writing?
04:44:58 <roconnor> ivanm: google code jam Round 1C question C
04:45:15 <ivanm> ahhh
04:45:33 <mjrosenb> wait, gcj has started?
04:45:49 <roconnor> mjrosenb: 2 weeks ago
04:46:01 <roconnor> was the qualfication round
04:46:17 <mjrosenb> FFFFFFFF
04:46:27 * mjrosenb fails at being notified when this happens
04:48:49 <janbanan> The pumping lemma is not sufficient to prove that a language is regular? If the lemma holds the language can still be non regular?
04:49:40 <roconnor> janbanan: depends on exactly how you state it
04:50:00 <roconnor> ah
04:50:01 <roconnor> wait
04:50:06 <janbanan> No?
04:50:06 <roconnor> janbanan: yes you are correct
04:50:18 <roconnor> there is only one way to state the pumping lemma
04:50:41 <roconnor> er
04:50:43 <roconnor> hmm
04:50:55 <roconnor> at least I'm pretty sure you are correct
04:51:17 <roconnor> it should be easy to construct some sort of undecidable language and then pump it
04:51:25 <roconnor> and still get an undecidable language
04:52:01 <janbanan> But what method are you supposed to use if you want to prove that a language is regular?
04:52:28 <roconnor> janbanan: construct a regular expression for it?
04:52:30 <roconnor> :D
04:52:34 <janbanan> Yeah :P
04:52:49 <mjrosenb> and/or write an fsm that accepts it
04:52:59 <janbanan> In some cases that can take some time
04:53:00 <mjrosenb> which makes the whole pumping thing easier
04:53:13 <Cale> Show that it's the preimage of a subset of a finite monoid under a homomorphism from a free monoid
04:53:19 <copumpkin> lol
04:53:42 <mjrosenb> copumpkin: that would be too obvious.
04:53:44 <mjrosenb> err
04:53:49 <mjrosenb> Cale: that would be too obvious
04:53:58 * mjrosenb ^I fail
04:56:16 <Cale> Actually, that definition often works out rather well
04:57:10 <ivanm> Cale: did tomberek talk to you earlier about function names for FGL?
04:57:23 <Cale> Not much?
04:57:44 <ivanm> OK: what are good function names for testing if a node or edge is in a graph?
04:58:00 <ivanm> i.e. graph -> node -> Bool and graph -> edge -> Bool
04:58:26 <kmc> janbanan, pumping lemma is mostly useful for proving things aren't regular
04:58:44 <Cale> ivanm: hasNode and hasEdge?
04:58:52 <Cale> isNodeOf?
04:59:04 <ivanm> Cale: heh, I was hoping there was a technical name for them ;-)
04:59:06 <janbanan> kmc yes i understand that
04:59:10 <mjrosenb> kmc: morning
04:59:14 <kmc> though you can of course take its contrapositive
04:59:16 <ivanm> tomberek was using member and connected, but I pointed out that the latter especially is wrong
04:59:17 <kmc> hi mjrosenb
04:59:24 <Cale> I mainly just don't like the incomprehensible short forms in FGL
04:59:34 <ivanm> like suc and pre ?
04:59:35 <copumpkin> yeah, same here
04:59:48 <Adamant> Cale: when your only tool is category theory, everything looks like a zyglomorphism? :P
04:59:48 <copumpkin> suc sucs
04:59:50 <ivanm> Cale: don't worry, just about everything is becoming more verbose! :p
05:00:02 <janbanan> kmc yeah but then it's not actually proved
05:00:13 <ivanm> the only exception to that is now, rather than having "(Graph g) => g a b -> ..." you have "(Graph g) => g -> ..."
05:00:16 <Cale> Adamant: That's not even what I'd consider a category theoretic definition, it's just normal abstract algebra.
05:00:16 <copumpkin> ivanm: not too verbose I hope!
05:00:22 <copumpkin> gotta strike the perfect balance!
05:00:22 <ivanm> copumpkin: mwahahahah!
05:00:24 <ivanm> nah, not too much
05:01:02 <Cale> ivanm: There were worse things, I can at least guess what suc and pre mean
05:01:03 <ivanm> I'm mainly trying to constrain tomberek for having too many methods in the classes (as he's hoping that there would be some uber graph type that could optimise it all up the wazoo :s
05:01:07 <ivanm> Cale: *nod*
05:01:12 <ivanm> Cale: what in particular do you hate then?
05:01:42 <Cale> hang on while I try to load the documentation for fgl so that I can remember
05:01:59 <ivanm> k
05:02:12 <Philippa> ivanm: that second type's a good argument for fundep style, IMO
05:02:18 <Cale> I seem to remember a lot of acronyms
05:02:23 <ivanm> Philippa: well, we're using ATs rather than fundeps
05:02:51 <Philippa> yeah, what I mean is you can't always read the node and edge types straight off from the type
05:03:07 <ivanm> Philippa: with ATs, we can have fixed/constrained label types easier than with MPTCs + FunDeps
05:03:21 <Philippa> *nod*
05:03:32 <ivanm> since the latter would see you have "instance Graph (Gr a b) a b" for the general case, which is too verbose IMHO
05:04:06 <ivanm> this way, you can just have "NLabel g", "ELabel g", etc. (or whatever they're called; tomberek is taking care of most of the API design atm and I'm just commenting and pointing out stupid stuff)
05:06:01 <Cale> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Query-BFS.html -- oh, here's a perfect example
05:06:31 <ivanm> oh, ignore the Query ones
05:06:37 <ivanm> I'm going to completely re-write them at some point
05:06:43 <Cale> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Query-DFS.html -- this too :)
05:06:53 <ivanm> since they piss me off by returning [[Node]] rather than [graph]
05:07:06 <ivanm> so I'm going to port over my Graphalyze ones where appropriate
05:07:13 <ivanm> and do an fgl-algorithms package like what vector has
05:07:26 * hackagebot wumpus-core 0.19.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.19.0 (StephenTetley)
05:07:53 <mjrosenb> oh man, the ps generation would have been useful like
05:07:59 <mjrosenb> 2 months ago
05:08:21 <ivanm> ps generation for what?
05:08:41 <mjrosenb> ivanm: making a large table that i wanted to print out
05:08:56 <ivanm> oh, from wumpus-core?
05:09:18 <mjrosenb> well wumpus may have made it easier
05:11:27 * hackagebot non-negative 0.0.6 - Non-negative numbers  http://hackage.haskell.org/package/non-negative-0.0.6 (HenningThielemann)
05:13:06 <ivanm> so.... Word?
05:13:45 <copumpkin> you mean T
05:14:29 <ivanm> OK, AFAICT non-negative is just the Natrual type from the numbers package put into a class...
05:14:32 <ivanm> copumpkin: huh?
05:14:33 * hackagebot yesod 0.2.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.2.0 (MichaelSnoyman)
05:15:02 <roconnor> jlouis: you around?
05:15:10 <ivanm> oh, wait, there's also Floating variants
05:15:19 <ivanm> it still looks horrible though (the way its written)
05:15:35 <copumpkin> he just has a different style :)
05:15:52 <ivanm> + having compulsory QC is definitely bad form
05:16:13 * ivanm is waiting for ndm to apply his patch to tagsoup's cabal file to let you build it without QC and HUnit
05:19:30 <jlouis> roconnor: yes
05:19:31 <roconnor> jlouis: you know how PSQueue is implemented, right?
05:19:31 <jlouis> roconnor: somewhat
05:19:31 <roconnor> how is it different from a balanced binary tree with each node stroing the lowest priority of its children?
05:19:35 * hackagebot storablevector 0.2.6 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.6 (HenningThielemann)
05:20:36 * hackagebot event-list 0.0.11.1 - Event lists with relative or absolute time stamps  http://hackage.haskell.org/package/event-list-0.0.11.1 (HenningThielemann)
05:20:45 <jlouis> roconnor: the child with the lowest priority tends to be at the top of that tree
05:21:25 <roconnor> jlouis: but the tree is still sorted by key order?
05:21:44 <roconnor> jlouis: they just rearrange pivot points to try to put lower priority elements higher?
05:21:57 <roconnor> maybe pivot is the wrong word here
05:22:16 <Eludias> (newby question) How is the function called to get from [1,2,3,4,5,6] to [[1,2],[3,4],[5,6]] (so group by fixed number of elements)?
05:22:43 <copumpkin> @hackage split
05:22:43 <lambdabot> http://hackage.haskell.org/package/split
05:23:04 <ivanm> Eludias: use the split package copumpkin has pointed out or manually define a chunk function using recursive calls to splitAt
05:23:16 <jlouis> roconnor: you have two things, the key and the pri. it is arranged such that you kan find the subtree having a given key in O(1) and the priority is heap-ordered (less than its children). I don't know how the balancing acts are done though
05:23:37 <jlouis> Ralf Hinze's paper has the details
05:23:46 <Eludias> copumpkin: thanks.
05:24:37 <roconnor> ok
05:25:00 <roconnor> jlouis: I kinda wish PSQueue had unionWith
05:25:11 <roconnor> but I'm reading cafe list saying unionWith is slow for some reason
05:25:18 <roconnor> (slow for Data.Map)
05:25:24 <roconnor> http://www.mail-archive.com/haskell-cafe@haskell.org/msg40408.html
05:30:01 * roconnor is tempted to try out Data.FingerTree.PSQueue
05:30:12 <roconnor> oh it looks like a drop in replacement
05:30:14 * copumpkin gives roconnor the finger
05:30:24 <copumpkin> tree
05:30:40 <ivanm> heh
05:31:29 <Cale> roconnor: I was made aware of some bugs in it the other day...
05:31:38 <Cale> Still have to fix them up :)
05:31:40 <roconnor> noooo
05:32:11 <Cale> hm?
05:32:28 <Cale> They're pretty simple things to fix.
05:32:45 <Cale> I'll do it now if you want :)
05:33:23 <djahandarie> Hmm... Trying to cabal install ghc-paths here, but its complaining about not having the Cabal library. It isn't provided in Debian's repo either...
05:34:22 <ivanm> djahandarie: it comes with GHC
05:34:28 <ivanm> djahandarie: ghc-pkg list Cabal
05:35:01 <Cale> roconnor: I stuck it up on hackage without testing or using it at all ;)
05:35:40 <ivanm> Cale: :o
05:35:42 <djahandarie> ivanm, seems like the version is too low in that case... it wants >= 1.4 but I got 1.2.3.0
05:35:50 <ivanm> djahandarie: :o
05:35:59 <ivanm> are you still using GHC 6.8?
05:36:12 <djahandarie> Yeah
05:36:26 <djahandarie> (On the machine I'm trying to get this to work on)
05:37:46 <roconnor> ok
05:37:47 * hackagebot snap-core 0.2.3 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.3 (GregoryCollins)
05:37:55 <ivanm> nope, it appears debian _doesn't_ have Cabal
05:37:57 <roconnor> so fingertree-psqueue isn't working at all for me
05:38:02 <ivanm> well, I like: it has it for hugs...
05:38:08 <ivanm> djahandarie: upgrade GHC! :p
05:38:12 * djahandarie sighs
05:38:21 <ivanm> or else be naughty and install Cabal 1.4 by hand
05:38:27 <ivanm> e.g.: cabal install Cabal
05:38:55 <djahandarie> Last time I tried doing something like that I faced the mighty iron fist of god smashing down on me
05:39:02 <ivanm> :o
05:39:25 <Axman6> how can you use -XOverloadedStrings in ghci so that "foo" :: ByteString? the only instances implemented for IsString is for String
05:39:26 <djahandarie> i.e., everything was bricked until I aimless ran commands to fix it
05:39:42 <ivanm> Axman6: do it when launching ghc?
05:40:09 <yhosok> if data ABC = A | B | C then can i get [String] from the data?
05:40:09 <ivanm> yhosok: hmmm?
05:40:09 <Axman6> yhosok: huh?
05:40:09 <Zao> Axman6: Last time I used that extension, bytestring had an instance.
05:40:09 <Cale> roconnor: Okay, give me a minute so I can download and try to repair it :)
05:40:09 <ivanm> yhosok: well, if you derive Show, then you can probably do this:
05:40:09 <gcollins> Axman6: ":set -XOverloadedStrings"
05:40:09 <yhosok> ["A","B","C"]
05:40:09 <mjrosenb> yhosok: i suspect that you want derive Show
05:40:11 <roconnor> Cale: :D
05:40:12 <Zao> Axman6: At least the Char8 ones.
05:40:39 <ivanm> oh, and derive Bounded and Enum
05:40:39 <ivanm> map show [minBound .. maxBound]
05:40:39 <ivanm> yhosok: ^^
05:40:39 <Axman6> yhosok: data ABC = A | B | C deriving Show
05:40:48 * hackagebot snap-server 0.2.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.2 (GregoryCollins)
05:40:55 <ivanm> Axman6: I think he wants _all_ strings
05:41:08 <yhosok> yes. i want all element to string
05:41:20 <Axman6> gcollins: i did that, maybe it's a 6.10.3 thing
05:41:29 <ivanm> yhosok: data ABC = A | B | C deriving (Bounded, Enum, Show); main = putStrLn . map show $ [minBound..maxBound]
05:41:33 <ivanm> that should do it
05:41:59 <Axman6> it won't
05:42:01 <yhosok> ivanm: thats nice. thanks !
05:42:13 <Axman6> you're trying to putStrLn a [String]
05:42:14 <ivanm> Axman6: it won't? why?
05:42:18 <ivanm> Axman6: oh, right
05:42:26 <ivanm> meh, you get the point
05:42:29 <ivanm> he wanted [String] anyway
05:42:43 <djahandarie> ivanm, well, things suprisingly worked fine this time
05:42:45 * ivanm has done the Bounded+Enum trick to define Arbitrary instances for QC
05:42:51 <ivanm> djahandarie: Cabal is safe to upgrade
05:42:57 <ivanm> it's the only library that comes with GHC that is
05:43:03 <gcollins> Axman6: the IsString instances are in D.B.Char8
05:43:10 <Axman6> ah
05:43:11 <roconnor> ivanm: you should make arbitrary instances for compact types
05:43:13 <Axman6> thanks :)
05:43:30 <ivanm> roconnor: hmmm?
05:43:42 <b_b> Hi, is any way I can load in ghci, a file which uses a c library, I mean, can i compile the c  source, and the passing it to ghci with -L option ?
05:43:55 <ivanm> b_b: usually not
05:44:21 <Axman6> as if you can't?
05:44:41 <ivanm> Axman6: well, I've had problems before with ghci trying to link to C libraries
05:44:52 <ivanm> well, link and use
05:45:38 <kmc> if i want to slurp all of stdin into a (Data.Sequence.Seq Char), is there a faster way than reading it to a String or ByteString first?
05:45:50 <b_b> ivanm: thanks.
05:45:58 <ivanm> kmc: probably not
05:46:26 <roconnor> kmc: I think someone finished Data.Ropes
05:46:43 <ivanm> well, edwardk was working on it...
05:47:24 <Axman6> kmc: why, you could use Iteratees
05:47:26 <Axman6> >_>
05:47:30 <kmc> ;P
05:47:31 <Axman6> </buzzwords>
05:47:40 <kmc> i heard they're like kirby eating a burrito
05:47:50 <Axman6> http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/ seems to do quite a good job at explaining them
05:47:57 <ivanm> iteratees sound cool, but I'm still not sure how they work or what's the main advantage of them (apart from minimising use of Handles)
05:48:00 <kmc> yeah, that's on my queue
05:48:06 <ivanm> I read that blog post as well as the TMR article
05:48:45 <Axman6> ithey make prediction resource usage much easier
05:48:46 <kmc> the advantage is composable IO without reading everything into memory at once, and without the hack that is "lazy IO"
05:49:11 <ivanm> well, most of my IO is all-at-once-stuff
05:49:17 <kmc> one of the fun things about FP is that you can invert your program's control flow seven times without noticing
05:49:21 <ivanm> though I do see the connection between iteratees and combinator parsing
05:49:26 <ivanm> kmc: heh
05:49:35 <ivanm> @remember kmc one of the fun things about FP is that you can invert your program's control flow seven times without noticing
05:49:35 <lambdabot> It is forever etched in my memory.
05:49:53 <Axman6> @flush
05:49:53 <lambdabot> Not enough privileges
05:49:56 <Axman6> :(
05:50:06 <Axman6> but it smells bad in here!
05:50:19 <ivanm> heh
06:00:35 <vmixey> Anyone seen: Structure and interpretation of quantum mechanics: a functional framework?
06:01:04 <vmixey> "We conclude that functional languages are right tools for formal computations in quantum physics"
06:01:22 <xerox> nice conclusion
06:01:53 <kmc> there's also _Structure and Interpretation of Classical Mechanics_
06:02:39 <kmc> which is a text on Lagrangian mechanics using Scheme as the notation for both symbolic and numerical calculations
06:04:00 <Axman6> @tell dons Please thank whoever is responsible for there (in the future) being video for Galois tech talks like the L4.verified one, there's been so many awesome talks i've missed out of because of the lack ofr video.
06:04:00 <lambdabot> Consider it noted.
06:07:12 <Cale> roconnor: Okay, I think I have it fixed. I'll upload it and you can try it out and let me know :)
06:07:41 <roconnor> Cale: ok
06:08:36 <dpratt71> For those mathophiles among you, if I wanted to try to get a sense of what it is you're talking about, could this book be a good starting point? http://www.amazon.com/Princeton-Companion-Mathematics-Timothy-Gowers/dp/0691118809/ref=sr_1_3?ie=UTF8&s=books&qid=1274706074&sr=1-3
06:09:13 <vmixey> That is a great book if you are wondering what advanced mathematics looks like
06:09:23 <roconnor> Cale: let me know when it is uploaded
06:09:32 <vmixey> you wont learn very much from it though, it's sort of like one of these encylopedias you give a child
06:09:35 <xerox> dpratt71: no
06:10:14 <Phyx-> vmixey: lol, nice analogy
06:10:33 <dpratt71> vmixey: I already know what it looks like: an entire blackboard filled with greek letters and other strange notations
06:10:40 <vmixey> heh
06:12:36 <kmc> the sort of math typically discussed here is pretty specialized
06:12:54 <kmc> i think the average mathematician sees people who study logic and category-theory-itself as weirdos
06:13:04 * hackagebot fingertree-psqueue 0.2 - Implementation of priority search queues as finger trees.  http://hackage.haskell.org/package/fingertree-psqueue-0.2 (CaleGibbard)
06:13:10 <Accidus> I still didn't find the correct example for: A a CCC, but A^J isn't (exercise from Mac Lane)
06:13:11 <Cale> roconnor: ^^
06:13:12 <xerox> not really
06:13:46 <Cale> Accidus: The tiny categories didn't work out?
06:14:07 <dpratt71> xerox: might you have an alternate suggestion?
06:14:20 <Accidus> No. If you only have one morphism between any two objects, you only have 2 kinds of homsets, which you can embed inside the category 0->1
06:14:22 <quicksilver> kmc: the average mathematician sees everyone who finds anything other than the precise little detail of maths on which he has wasted the last 15 years of his life as a weirdo.
06:14:29 <quicksilver> let us not be average.
06:14:38 <kmc> hehe
06:14:41 <Accidus> I mean, only 2 kinds of homsets of natural transformations
06:14:44 <roconnor> Cale: okay now it works
06:14:52 <Cale> roconnor: Awesome :)
06:15:15 <dpratt71> kmc: I don't imagine myself grokking all that is discussed here from reading one book; I'm looking for a stepping-stone to get there from HS-level math
06:15:18 <kmc> i mean, if you think of the mainstay of maths as being algebra, analysis, geometry, topology, combinatorics, etc.
06:15:23 <roconnor> Cale: though in my case it is slower than Data.PSQueue
06:15:26 <xerox> dpratt71: bridge to abstract mathematics
06:15:35 <roconnor> Cale: 45 seconds vs 25 seconds
06:15:50 <kmc> then logic and category theory are sort of off to the side... building the foundations those guys use, and giving them a useful vocabulary
06:15:50 <dpratt71> xerox: I'll check that out; thanks
06:15:52 <roconnor> Cale: er
06:16:00 <xerox> dpratt71: worked for me :)
06:16:02 <roconnor> Cale: 45 seconds until it overflows the stack I guess
06:16:05 <roconnor> :(
06:16:08 <dpratt71> :)
06:16:11 <kmc> dpratt71, have you read _Gödel, Escher, Bach_?
06:16:13 <Accidus> So you need J to have more structure than A (in particular, J's cannot be A-enriched), A needs to have at least 2 objects with more than 1 morphism between them
06:16:26 <dpratt71> kmc: no
06:16:30 <kmc> dpratt71, great book
06:16:36 <xerox> keep it that way
06:16:39 <Accidus> But then verifying functoriality and naturality becomes an annoying hassle
06:16:43 <dpratt71> kmc: added to the list, thanks
06:16:51 <kmc> it has a very accessible yet not dumbed-down introduction to some of the most important results in formal logic
06:17:19 <kmc> as well as some enjoyable speculations about philosophy of mind, biology, art, music, and everything else
06:17:33 <dpratt71> kmc: sounds like an interesting read
06:17:36 <kmc> very
06:17:36 <vmixey> http://www.amazon.co.uk/Structure-Interpretation-Quantum-Mechanics/dp/0674843924 <--- this seems to be a different one since it doesn't mention haskell
06:17:53 <kmc> GEB has a way of convincing people it presents a coherent philosophy of mind and worldview
06:17:56 <kmc> which i think it doesn't really
06:17:59 <kmc> but it's still worth reading
06:18:02 <djahandarie> I'm confused... how am I suppose to use the mueval interpreter when it is -> Interpreter() ?
06:18:09 <djahandarie> Err Interpreter ()
06:18:26 <xerox> if want to learn math that book does not help at all
06:18:34 <Phyx-> dpratt71: oh, btw, forgot to tell you yesterday, I periodically post updates of progress on http://blog.zhox.com/ . I just uploaded a video infact.
06:19:02 <kmc> djahandarie, the Interpreter type is from "hint"
06:19:07 <kmc> and can be run in IO
06:19:10 <dpratt71> Phyx-: nice! I'll check it out when I have a few minutes undistracted
06:19:27 <Phyx-> dpratt71: cool
06:19:32 <djahandarie> Hm
06:19:34 <kmc> xerox, GEB? if you want to learn formal logic it's a good start
06:19:49 <xerox> i'd rather suggest a book on logic
06:19:51 <kmc> (though as i said, it has lots of other stuff besides that)
06:19:52 <vmixey> If you want to learn mathematics start with Group Theory
06:20:16 <vmixey> Group Theory is a tool that will help you with number theory and geometry
06:20:37 <vmixey> and it the gateway to abstract algebra
06:20:51 <ddarius> Group theory -is- abstract algebra.
06:20:54 <vmixey> (I am assuming some kind of basic level of mathematics)
06:21:01 <kenjin2201> Hello, I have a little experience in Lisp and was very impressed with the book SICP, can I find a book for Haskell that's comparable to SICP?
06:21:03 <vmixey> ddarius yes but we don't tell them that!
06:21:07 <mjrosenb> kmc: not to mention a bunch of cool recursive formulas
06:21:22 <ddarius> kenjin2201: Not really.
06:21:27 <kmc> kenjin2201, not really.  there are some Haskell tutorials we recommend but none are very much like SICP
06:21:32 <vmixey> kenjin2201, well. no. But there is LYAH which is great in its own right
06:21:35 <kmc> some of the SICP exercises would be suitable exercises in Haskell
06:21:49 <ddarius> And by "some" kmc means "almost all"
06:22:10 <bremner> for the remainder, first write scheme in haskell :)
06:22:12 <kmc> not the stuff that depends on strict evaluation
06:22:21 <kmc> @google write yourself a scheme
06:22:22 <lambdabot> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
06:22:22 <lambdabot> Title: Write Yourself a Scheme in 48 Hours - Wikibooks, collection of open-content text ...
06:22:36 <vmixey> I'm not keen on that tutorial mysfel
06:22:36 <Cale> Accidus: So this means that the square is a CCC?
06:22:39 <kmc> the metacircular stuff in SICP would be a huge undertaking
06:22:46 <ddarius> kmc: I don't think there is any stuff until mutation is introduced that depends on strict evaluation and mutation is the bigger issue in those cases.
06:22:47 <Cale> Accidus: (a single commutative square)
06:22:49 <kenjin2201> I'm completely new to haskell though.
06:23:04 <kmc> kenjin2201, then i'd say you should follow LYAH or RWH, and also do SICP exercises as you like
06:23:53 <kenjin2201> Thank you all. I heard haskell community is warmer than Lisp. That seems like true
06:24:11 <Cale> kenjin2201: Yeah, don't be afraid to ask any questions you might have here.
06:24:37 <kmc> kenjin2201, i hope we can live up to the reputation :)
06:24:39 <Accidus> Cale, seems like it
06:24:53 <Accidus> Cale, actually... what about products?
06:25:19 <Accidus> Yeah, it is.
06:25:22 <Accidus> It's a lattice
06:25:28 <Accidus> and as such ccc
06:25:32 <Cale> okay
06:25:35 <Accidus> I mean, finite cartesian
06:25:40 <kmc> the thing about Lisp is that they've been around for about 50 years, through the rise and fall of many other languages and practices, always off to the side shouting "We've done this before, and better too"
06:25:40 <Accidus> whatever
06:25:43 <Cale> What's (1,0)^(0,1)?
06:25:48 <kmc> i'm not sure what effect that has on the community
06:25:54 <kmc> i would find it depressing personally
06:26:03 <Accidus> 0
06:26:08 <kmc> Haskell is newer (in absolute terms, and in terms of popularity) and maybe we are still starry-eyed idealists ;)
06:26:10 <ddarius> Cale: It has a terminal object and finite products and the adjunction seems to hold.
06:26:54 <Cale> okay...
06:26:54 <Accidus> I think.
06:27:43 <Accidus> It has to be the largest object such that (0,1) * x <= (1,0), and this has to be x = (0,0)
06:27:50 <Accidus> yeah
06:27:59 <mjrosenb> kmc: scheme's (and lisp's) "we can do that with macros" is just a bit horrific
06:28:14 <xerox> mjrosenb: (and scheme's lisp's)
06:28:14 <ddarius> Every (small) category is a colimit of 2, so perhaps you should check 2 and see if A^Colim(D) = Lim(A^D) is still cartesian closed.
06:28:42 <kmc> yeah
06:29:16 <kmc> @quote majesty
06:29:16 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
06:29:21 <Accidus> ddarius, but that's the problem with 2. It has at most 1 morphism between any pair of objects, which leads to having at most one natural transformation between any two functors
06:29:29 <vmixey> "Here the Haskell multiparametric classes with functional dependencies are very helpful" -- urhg.. I'm not looking forward to this
06:29:49 <Accidus> ddarius, and then you can simply choose 0 or 1, depending if there /is/ a natural transformation or not
06:30:03 <mornfall> It's not like fundeps were very useful without multiple parameters.
06:30:06 <Cale> Accidus: aha, good point
06:30:18 <mjrosenb> vmixey: "and now we beat you with a baseball bat until you agree"
06:30:26 <vmixey> lol
06:30:31 <kmc> hehe
06:30:45 <Accidus> the only lever in that case is naturality of the bijection, but I have no idea how fruitful that will be.
06:31:12 <vmixey> monkey pull level.. monkey get banana
06:31:17 <kmc> i dunno, i don't think MPTC are that esoteric.  it seems like something you'd expect to have unless you learned specifically that H98 type classes are restricted to one parameter
06:31:37 <kmc> fundeps are a bit odd, and are falling out of favor
06:32:01 <kmc> when i was learning Haskell i just turned on -fglasgow-exts and went wild
06:32:05 <kmc> i realize now this may have been a mistake
06:32:13 <Axman6> heh
06:32:51 <Blkt> how do I get a pdf from a lhs file_
06:32:54 <Blkt> ?
06:33:47 <kmc> using lhs2TeX and pdflatex
06:34:03 <Blkt> thanks
06:34:48 <Cale> Blkt: lhs2TeX is a bit less than completely straightforward to set up, make sure to read at least the first section of its manual.
06:35:04 <Cale> (there are some TeX things you have to install alongside it)
06:36:56 <vmixey> "ab ovo"?
06:37:21 <vmixey> "cum grano salis"?
06:37:29 <vmixey> I can't read this :"|
06:37:32 <EvanR-work> watch your language
06:37:36 <kmc> haha
06:37:41 <kmc> where is this?
06:37:51 <vmixey> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.6171
06:37:58 <vmixey> Structure and Interpretation of Quantum Mechanics - a Functional Framework
06:38:02 <kmc> that's amusing
06:40:41 <Blkt> Cale: thank you
06:41:15 <Cale> vmixey: "ab ovo" means "from the egg", and "cum grano salis" means "with a grain of salt"
06:41:29 <vmixey> ahh! I should have guessed the first one
06:42:27 <kmc> one can google these things
06:42:33 <kmc> still, it's a great way to turn readers off your paper
06:43:01 <EvanR-work> hey, it doesnt turn people off the catholic church
06:43:04 <vmixey> ket :: (HBase a) => a -> (HV (HV a))
06:43:13 <vmixey> ket = flip id -- also called the T combinator
06:43:16 <kmc> EvanR-work, they're not supposed to know what the words mean ;)
06:43:26 <vmixey> I'm starting to think this paper is just a april fools or something
06:43:27 <Cale> EvanR-work: Then again, the rape of small boys won't even turn some people off the Catholic church.
06:43:37 <EvanR-work> snap
06:43:54 <kmc> the idea is to say a bunch of stuff that makes no sense and is directly contradictory, and to convince people it's very important
06:44:06 <kmc> then when they are confused, you can plug them directly into a hierarchical command structure
06:44:22 * hackagebot lhc 0.10 - LHC Haskell Compiler  http://hackage.haskell.org/package/lhc-0.10 (DavidHimmelstrup)
06:44:35 <kmc> nice, another compiler
06:44:41 <kmc> i still have dibs on the name "thc" by the way
06:44:47 <kmc> gonna finish that some day
06:45:01 <Saizan> no release no dibs.
06:45:17 <vmixey> Saizan is right you better get your game on
06:45:27 <Lemmih> kmc: I wanted to call the compiler that at first but then I got high and forgot.
06:45:38 <Saizan> (that's how we got the algebra package i guess..)
06:45:43 <djahandarie> I still can't figure out mueval
06:45:51 <djahandarie> I want to get a string out of it
06:45:53 <kmc> haha
06:46:39 <kmc> djahandarie, "hint" examples are here: http://code.haskell.org/hint/devel/examples/
06:46:44 <EvanR-work> again were back to the pot jokes
06:46:45 <kmc> djahandarie, i guess mueval is a wrapper on hint?
06:47:06 <EvanR-work> is the haskell community composed of stoners or what
06:47:14 <djahandarie> kmc, yes, it does a bunch of checks to make sure there is no bad input though
06:47:31 <kmc> djahandarie, looks like the result of the action returned by "interpreter" is a triple of (expression, expression type, result), all as string
06:47:51 <djahandarie> Oh
06:47:53 <kmc> djahandarie, so you should be able to get that with just hint's runInterpreter, in the IO monad
06:48:24 <Saizan> djahandarie: how are you calling mueval?
06:48:55 <kmc> Language.Haskell.Interpreter.runInterpreter . Mueval.Interpreter.interpreter :: Options -> IO (Either InterpreterError (String,String,String))
06:49:16 <djahandarie> I was using interpreterSession
06:49:24 <Jafet> EvanR, at least we're based in Cambridge, not Berkeley
06:49:38 <djahandarie> But now it seems like I should just use interpreter and extract stuff from that
06:50:10 <Blkt> could anyone explain me the syntax to make an instance of a Monad? Something like "type Parser a = String -> [(a,String)] ... instance Monad Parser where blabla"
06:50:26 <kmc> Blkt, do you know how type classes work?
06:51:06 <mjrosenb> Blkt: also, you need to use newtype or datatype in order to declare a typeclass with a type.
06:51:12 <vmixey> This "Structure and Interpretation of Quantum Mechanics" is defeating me, maybe I have to get a haskell compiler out
06:51:16 <kmc> that's a prerequisite for understanding anything about monads (except perhaps using the IO monad on a practical level)
06:51:26 <Blkt> kmc: I just read a chapter about it from Programming in Haskell, but I don't have a working knowledge about it
06:51:36 <Jafet> ...is quantum mechanics pure?
06:51:40 <kmc> Blkt, okay, study that first.  typical early examples of type classes include Show and Eq
06:52:04 <Blkt> kmc: yes, it dows
06:52:08 <Blkt> does*
06:52:18 * mjrosenb used a combination of List and Maybe to understand monads
06:52:27 <kmc> Blkt, "Monad" is just the name of a particular type class in the standard library
06:52:40 <EvanR-work> Jafet: what you get out is a random function of the inputs ;)
06:54:05 <Blkt> kmc: I understood that while reading the book, but a lot of examples from the chapter about Parsers won't work if you don't "implement" (if you allow me that word) the Monad class
06:54:17 <kmc> okay
06:54:22 <Blkt> kmc: and so also those from the chapter about interactive programs
06:54:28 <kmc> you're saying they're missing some code?
06:54:39 <vmixey> SIQM in Haskell is a great idea, I wish this was was a full book
06:54:40 <Blkt> yes
06:54:46 <kmc> Blkt, i can tell you what's wrong with what you have above specifically
06:55:02 <vmixey> we should get some of the folks here to write it
06:55:02 <kmc> which is that you can't partially apply a type synonym
06:55:27 <Blkt> that helps, thanks
06:55:55 <kmc> Blkt, in a real parser combinator library you would wrap the function type
06:56:04 <kmc> newtype Parser a = Parser (String -> [(a,String)])
06:56:24 <Blkt> I see
06:56:31 <kmc> instance Monad Parser where { return x = Parser (\s -> [(x,s)]) ... }
06:57:14 <vmixey> (although SIQM is sort of hard to pronounce)
07:00:33 <djahandarie> Hmm, seems like the version of mueval/hint that I'm using just doesn't give back a String
07:00:54 <kmc> :(
07:00:56 <djahandarie> The latest verison looks quite easy to work with
07:02:25 <djahandarie> http://hackage.haskell.org/packages/archive/mueval/0.6.3/doc/html/Mueval-Interpreter.html is what I'm using
07:03:08 <djahandarie> And Language.Haskell.Interpreter.GHC gives WithSession which is Interpreter a -> IO a
07:03:19 <djahandarie> withSession*
07:03:36 <djahandarie> So I'm still stuck with ()
07:03:41 <kmc> i have a simple example working with the latest mueval / hint
07:03:46 <kmc> which you probably worked out already
07:04:14 <djahandarie> Yeah the latest one looks easy, I'm just stuck with this older one
07:04:24 <kmc> :/
07:04:26 <kmc> why's that?
07:04:35 <djahandarie> Old GHC version
07:13:50 <IceKiller> hmm could somebody help me? i'm trying to make iterations of a word but having a difficult time :-/
07:14:12 <vmixey> what is iterations of a word?
07:14:45 <copumpkin> ugh, I'm still awake!
07:15:48 <IceKiller> umm basicly trying to "fix" a typo in a word, lets say you enter : hlelo
07:16:02 <vmixey> oh right, permutations!
07:16:06 <copumpkin> > permutations "hello"
07:16:07 <lambdabot>   ["hello","ehllo","lehlo","elhlo","lhelo","hlelo","lleho","lleho","lelho","l...
07:16:08 <IceKiller> permutations yea srry ^^
07:16:13 <vmixey> yeah I can show you how to write this recursively if you want
07:16:16 <copumpkin> I'd look at edit distance
07:16:20 <Jafet> That is a terrible way to "fix" typos
07:16:34 <Jafet> > length $ permutations "goodbye"
07:16:35 <lambdabot>   5040
07:16:41 <copumpkin> you want  a good datastructure that allows you to look things up by levenshtein distance
07:17:37 <mjrosenb> copumpkin: sounds like a nice datastructure
07:17:44 <monochrom> @vixen people should speak clearly
07:17:44 <lambdabot> you are soooo interesting
07:17:46 <copumpkin> mjrosenb: yeah, I don't know of one, but I'm sure people have done it
07:17:53 <copumpkin> also, the -damerau extension adds letter exchange too
07:18:11 <copumpkin> which is probably common in huamn typing ;)
07:18:38 <mjrosenb> copumpkin: wyh would you say that?
07:18:51 <monochrom> teh human typing
07:18:53 <copumpkin> woh knows
07:20:12 <Jafet> The most common cause is the return key.
07:20:17 <IceKiller> hmm vmixey yae i guess its permutations
07:20:17 <IceKiller> but instead of creating them all and then checking
07:20:17 <IceKiller> i would like to create the first one then check against a Map, if its not correct then the next etc
07:20:30 <IceKiller> (using Map.lookup)
07:20:55 <copumpkin> permutations increase factorially
07:20:57 <copumpkin> which is very bad
07:20:58 <vmixey> IceKiller, well you understand lazy evaluation means that "creating them all and then checking" does what you said
07:21:02 <copumpkin> you don' want to be storing them all
07:21:44 <monochrom> > map sort ["hello", "pumpkin", "monotone"]
07:21:45 <lambdabot>   ["ehllo","ikmnppu","emnnooot"]
07:21:48 <monochrom> Store those.
07:22:07 <vmixey> So anyway, the permutations of [] and {[]}, and for the case of (x:xs) if the permutations of xs are {S} then we simply take each element s <- S, and insert x into it to get the permutations
07:22:12 <monochrom> Does "holle" match one of them, and which one? sort "holle" to find out.
07:22:20 <monochrom> > sort "holle" == "ehllo"
07:22:21 <lambdabot>   True
07:22:24 <monochrom> Success.
07:22:48 <IceKiller> wait wait why did it store ehllo instead of hello? :p
07:23:08 <kmc> > sort "hello"
07:23:09 <lambdabot>   "ehllo"
07:23:10 <monochrom> normal form. canonicalization
07:23:30 <djahandarie> Hi IceKiller
07:23:35 <kmc> the idea is to use the sorted word as a key to find the real word from the mistyped word
07:23:37 <janbanan> Is it correct that the following language don't have a CFG? L = {a^n, b^n, c^k | n=<k}
07:23:39 <kmc> since they should be the same when sorted
07:23:56 <Silvah> Hi.
07:24:16 <kmc> janbanan, seems likely.  do you have a proof it can't be pumped?
07:24:26 <kmc> pumping lemma for context free grammars is pretty hairy
07:24:43 <janbanan> Yeah i don't really get it
07:24:52 <janbanan> But will give it a try i think
07:25:02 <kmc> oh, you could use Ogden's lemma
07:25:02 <Jafet> LiceLiker, era oy rue us shit I as do go oilsnout?
07:25:58 <IceKiller> hey djahandarie :)
07:26:44 <djahandarie> Oilsnount, hehe
07:33:08 <Silvah> Interesting. I wrote a strict list library but I don't know why I wrote that.
07:36:46 <Cale> Silvah: hehe
07:37:25 <monochrom> usually libraries are wrote to shut up complaints
07:38:42 <Silvah> Does anyone want to take a look?
07:39:51 <copumpkin> nope
07:40:00 <jmcarthur> heh
07:40:01 <copumpkin> just kidding :P
07:40:16 <jmcarthur> @remember monochrom usually libraries are wrote to shut up complaints
07:40:17 <lambdabot> I will remember.
07:40:28 <ezyang> Good morning #haskell!
07:40:42 <vmixey> I don't think there's much demand for a strict list library
07:40:42 <jmcarthur> Good morning ezyang!
07:41:00 <ezyang> Good morning jmcarthur!
07:41:05 <vmixey> I certainly don't need one..
07:41:23 <ezyang> Strict linked lists... sound like a solution in search of a problem
07:41:30 <ezyang> Better use strict arrays instead
07:41:58 <kmc> or strict finger trees
07:45:37 <monochrom> there is not much demand for a strict list library. but the demand, though small, demands the whole list.
07:46:25 <Ke> code.haskell.org is down again
07:46:39 <scree> I suggest we have a lazily evaluated strict list library
07:46:53 <scree> people write functions only as they need them
07:59:20 <shapr> copumpkin: ?
07:59:56 <triyo> hexpat-0.16 failed to install on Ubuntu10.0.4,  * Missing C library: expat. I've run 'apt-get install expat' and it installed but I get the same error. Am I missing something?
08:00:57 <monochrom> libexpat1-dev
08:02:06 <triyo> monochrom: thx
08:02:24 <monochrom> also expat is not needed because you already have libexpat1
08:16:16 <vmixey> haha wtf
08:16:23 <vmixey> workerwrapper.com
08:16:48 <jmcarthur> wait, a whole domain just for worker wrapper?!
08:34:00 <alpounet> they must have had great fundings for that research
08:34:15 <ezyang> "domains are cheap"
08:36:05 * alpounet will register ghc-llvm-backend.com
08:38:48 <vmixey> what's the point of torrents that nobody seeds :|
08:38:54 <vmixey> oh there we go
08:38:55 <vmixey> thank you :p
08:42:55 <ezyang> I wonder if there exists of common bindings from Prelude that are hidden.
09:30:22 <BMeph> Would it be appropriate (would it be inappropriate?) to add an "RIP Martin Gardner" to the motd?
09:31:56 <xerox> ...and Walter Rudin.
09:43:31 <BMeph> xerox: Agreed. :(
09:44:44 <dayz> hi
09:45:35 <dayz> when I try to compile this program, I keep getting an error complaining "ghc-pkg: cannot find package glade" is glade on hackage?
09:46:02 <xerox> it's part of gtk2hs, so no
09:46:42 <danderson> gtk2hs is an exception in the haskell world, in that it's not cabalized. You have to install it by painful hand.
09:46:57 <danderson> (this is changing soon I believe, there are alpha cabal packages out there somewhere)
09:47:03 <dayz> right
09:47:15 <Ke> or via package manager I hope
09:47:44 <danderson> if you mean your distribution's package manager, then maybe. That's up to the distro maintainers.
09:49:17 <arkrost> Hi! I want to learn haskell. Tell me please what book I should start with.
09:49:48 <jmcarthur> @where rwh
09:49:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:49:50 <jmcarthur> @where lyah
09:49:50 <lambdabot> http://www.learnyouahaskell.com/
09:49:55 <Zao> LYAH, I'd say.
09:50:08 <jmcarthur> arkrost: either of the above, depending on your mood and previous experience with programming
09:50:59 <jmcarthur> arkrost: LYAH is a bit slower paced and simpler. RWH goes into a lot more depth and is a bit more dense
09:51:03 <jmcarthur> but not too dense
09:52:26 <Phyx-> @hoogle ghc static flags
09:52:27 <lambdabot> No results found
09:52:45 <Phyx-> @google ghc static flags
09:52:46 <lambdabot> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/flag-reference.html
09:52:46 <lambdabot> Title: 4.18.ï¿½Flag reference
10:08:54 <ezyang> Oh god, I was rereading "Evolution of a Haskell Programmer" and got to the line fac = para phi and thought to myself "Of course a factorial is a paramorphism..." >.>
10:09:50 <mauke> ASSIMILATION COMPLETE
10:10:36 <Kaidelong> http://hackage.haskell.org/packages/archive/OpenAL/1.4.0.0/doc/html/Sound-OpenAL-ALC-Capture.html
10:10:42 <Kaidelong> Anyone used this?
10:36:03 <ezyang> Category theory time!
10:37:22 <ezyang> I want to express A = {17} (i.e. the singleton set containing 17) in category theory terms. This is proving slightly difficult, namely because I don't see how you can distinguish {17} from, say, {19}, without appealing to non-category theory notions, like, the identity on this object is precisely the function that always returns 17.
10:38:23 <dmwit> In category theory, you don't *want* to differentiate between {17} and {19}.
10:38:38 <Saizan> depends on how you define the naturals i guess
10:38:43 <vmixey> A = {17} seems fine to me
10:39:01 <ezyang> dmwit: I could believe that. But Fokkinga is asking me to find a categorically expressed property P
10:39:04 <vmixey> why complicate things
10:39:07 <dmwit> Things that are equal up to isomorphism are generally considered "as good as equal".
10:39:08 <xerox> Set doesn't distinguish between sets with the same cardinality
10:39:22 <xerox> as Saizan says, maybe you just need a different category
10:39:30 <ezyang> I could believe that Fokkinga posed the question to demonstrate that it's not actually possible.
10:39:58 <ezyang> Saizan: We're in the category of Sets.
10:40:05 <dmwit> ezyang: With functions as arrows?
10:40:06 <xerox> what is the property P?
10:40:14 <ezyang> Yep.
10:40:27 <ezyang> P(A) \equiv A = {17}
10:40:47 <dmwit> Yeah, not really possible using only objects and arrows from Set.
10:40:53 <dmwit> See if you can prove it. =)
10:41:01 <dmwit> (It's not hard, once you observe that they're isomorphic.)
10:41:20 <ezyang> Ok!
10:41:28 <Kaidelong> is there anything like ArrowChoice for monads?
10:41:38 <Kaidelong> I imagine you don't need anything like that
10:41:55 <c_wraith> @src ArrowChoice
10:41:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
10:42:00 <c_wraith> boo
10:42:02 <ezyang> Kaidelong: Well, you could use it directly with Kleisli
10:42:12 <Kaidelong> oh right!
10:42:14 <Kaidelong> monads are arrows
10:42:20 <mreh_> @hoogle Ratio a -> Integer
10:42:22 <lambdabot> Data.Ratio denominator :: Integral a => Ratio a -> a
10:42:22 <lambdabot> Data.Ratio numerator :: Integral a => Ratio a -> a
10:42:22 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:42:56 <mreh_> hmm
10:43:03 <ezyang> I don't see anything specialized on that for monads tho
10:43:05 <mreh_> that doesn't make a lot of sense anyway
10:44:51 <dmwit> There's EitherT, isn't there?
10:45:36 <ezyang> Oh, it's true!
10:46:47 <ezyang> durr, I see the isomorphism, but I'm failing to see the technical trick that I should make to derive the contradiction
10:47:07 <danderson> I'm trying to use c2hs and getting a puzzling error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25680#a25680
10:47:29 <danderson> Any idea on how to convince c2hs that ModuleRef and (ModuleRef) are the same thing (or, failing that, what am I doing wrong?)
10:47:31 <dmwit> ezyang: No need to derive a contradiction. Take any diagram where you can place {17} and observe that, because of the isomorphism, you can place {19} in the same spot.
10:47:52 <ezyang> Oh, I thought I had to show that.
10:48:00 * ezyang goes and doublechecks what he can do with isomorphism 
10:48:12 <dmwit> ezyang: Yeah, the last clause is the bit you have to show.
10:49:04 <danderson> dcoutts: would you happen to be around with some c2hs wisdom to share?
10:49:14 <dcoutts> danderson: possibly :-)
10:49:20 <dmwit> i.e. given some arrows to and from {17}, you have to construct some arrows to and from {19} that still make the diagram commute.
10:49:52 <dmwit> But because {17} and {19} are isomorphic, you've got arrows f and f^{-1} that go between {17} and {19} that compose to id...
10:49:55 <danderson> dcoutts: see above, c2hs is complaining that it's failing to marshal between ModuleRef and (ModuleRef) in the binding I'm writing, which is puzzling me to say the least
10:52:57 <dcoutts> danderson: have you declared a {-# pointer #-} hook ?
10:53:10 * ezyang does mental translation into function terms 
10:53:16 <dcoutts> danderson: there is no automatic mapping, beyond the builtin types
10:53:30 <ezyang> So, constant function f(17)=19 and f(19)=17
10:53:31 <danderson> dcoutts: yes, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25680#a25680 has the relevant parts of the .h, .chs and the output of c2hs
10:53:42 <ezyang> erm, g(19)=17
10:54:36 <BMeph> Distinguishing objects is teh evil! -- categorically, of course
10:55:23 <dcoutts> danderson: oh, right, it's simply that there are no default marshalers
10:55:38 <dcoutts> danderson: supply a marshalling function, it'll be trivial
10:55:58 <dcoutts> danderson: pointer hooks declare the type mapping, but not any default marshaling
10:56:15 <ezyang> and the arrows all look precisely the same
10:56:17 <danderson> aah.
10:56:22 <dcoutts> in fact there is no way to extend the default marshaling, all non-builtin types need to be given a marshaler at the point of use
10:56:35 * dcoutts notes there is a feature request to be able to do so
10:56:35 <danderson> dcoutts: this makes sense, I was expecting the pointer hook to do more than it does. Thanks.
10:57:05 <dcoutts> danderson: I tend to forget that since I never use the fun hooks, just call hooks
10:57:22 <dcoutts> (which are lower level and don't use any default marshaling)
10:57:42 <ezyang> dmwit: Can I just say all of the arrows look the same?
11:00:34 <danderson> dcoutts: ah, I see. Now that I can see the code generated by the fun hook, it makes more sense.
11:00:38 <danderson> cheers
11:00:56 <dcoutts> ok good
11:04:42 <pastorn> roconnor: cool! so what was the change that made you code get 4x faster?
11:05:30 <roconnor> pastorn: did you see the past of the old slow code yesterday?
11:05:38 <byorgey> preflex: seen nominolo
11:05:39 <preflex>  nominolo was last seen on #ghc 6 hours, 23 minutes and 51 seconds ago, saying: I'm assuming that stands for programme committee
11:06:14 <pastorn> roconnor: yes, but i didn't understand it all :/
11:06:35 <byorgey> @tell nominolo apparently you are looking for me but we keep missing each other.  feel free to leave me a message or send me an email or whatever. =)
11:06:36 <lambdabot> Consider it noted.
11:07:16 <roconnor> pastorn: well, if you recall I had two objects keeping my state before: a big array of size m*n and a psqueue also of about that size, maybe less
11:08:12 <pastorn> yeah
11:08:16 <roconnor> pastorn: the array held some values and the psqueue had basically the same data but the priority would tell you quickly which index had the smallest value
11:08:37 <roconnor> pastorn: So I basically got rid of the array
11:08:53 <pastorn> ok
11:08:56 <roconnor> pastorn: now each step I build a small array of size (sz*sz) or less
11:09:01 <pastorn> so you only needed one way to access it...
11:09:04 <roconnor> pastorn: and then use that array to update the psqueue
11:09:12 <roconnor> then the small array is tossed away
11:09:16 <pastorn> hmmm...
11:09:22 <pastorn> cool :)
11:09:56 <roconnor> so lessons learned:  using (//) to update big arrays is not very fast.
11:10:27 <pastorn> haha
11:11:05 <roconnor> perhaps I should have used ST to solve this problem
11:11:24 <roconnor> but I like folds and iterate so much better
11:11:56 <pastorn> roconnor: yeah, resolving to ST seems like a bad idea :)
11:15:42 <roconnor> pastorn: I also tried Cale's fixed Data.FingerTree.PSQueue but it was 2x slower on this benchmark
11:15:55 <roconnor> too bad.  I like finger trees
11:16:33 <pastorn> heh... now you must've learned a lot about the haskell datastructures :)
11:17:17 <Cale> roconnor: I have done absolutely nothing to be cautious about performance in that package
11:17:27 <Cale> (in fact, I wasn't even careful about correctness ;)
11:17:46 <roconnor> Cale: oh that's fine
11:18:23 <roconnor> all I mean is that, for now, if someone wants to use a psqueue there is some evidence they should use Data.PSQueue at the moment.
11:19:14 <Cale> yeah
11:21:04 <roconnor> hmm
11:21:07 <roconnor> return alwaysFails `catch` errorHandler
11:21:12 <vmixey> how do I install GHC using apt-get?
11:21:26 <roconnor> it is pretty clear to me that "return x" will never throw an exception
11:21:42 <vmixey> oh probably  apt-get install ghc
11:22:28 <Phyx-> doesn't that need a sudo?
11:22:29 <Phyx-> :P
11:24:20 <vmixey> how do I install cabal??
11:24:24 <vmixey> it seems like I can't use ghc
11:24:31 <vmixey> I mean, can't use apt-get
11:24:54 <Phyx-> what platform are you on vmixey
11:25:09 <mike-burns> I used: sudo apt-get install cabal-install
11:25:11 <mike-burns> On Debian.
11:26:03 <rajeshsr> roconnor, do you mind telling what problem you were trying to solve?
11:26:38 <rajeshsr> Cale, am trying to learn about using arrays, in my sudoku code. What array you recommend to start with?
11:26:45 <Twey> Cabal comes with GHCâ€¦
11:27:07 <Phyx-> sure, but he wanted cabal-install
11:27:11 <Cale> rajeshsr: Start with just plain Array
11:27:28 <rajeshsr> Cale, hmm, ok!
11:27:35 <roconnor> rajeshsr: google code jam, round 1C, question C
11:27:52 <roconnor> rajeshsr: or were you refering to the return x not throwing exceptions
11:27:53 <rajeshsr> roconnor, ha, cool!
11:28:11 <rajeshsr> well, you were talking about the speed of your code..
11:28:29 <roconnor> rajeshsr: I wanted to get the execution time to something reasonable
11:28:39 <roconnor> the C code I downloaded ran in 4 seconds
11:28:53 <rajeshsr> oh, ok!
11:29:00 <rajeshsr> So, you are qualified?
11:30:54 <vmixey> thanks you guys
11:31:47 <roconnor> rajeshsr: ya I made it into Round 2
11:32:04 <rajeshsr> roconnor, congrats!
11:32:25 <roconnor> I'd like to make it in the top 1000 of round 3
11:32:32 <roconnor> but that isn't going to happen I don't think
11:32:50 <roconnor> I'm starting to remember why I don't like these very short duration programming contests
11:32:59 <roconnor> There is no time to make beautiful code
11:33:24 <roconnor> that's why I prefer the ICFP contests
11:37:48 <rajeshsr> roconnor, ha, cool! I never knew about ICFP. Is that a functional programming contest?
11:38:16 <rajeshsr> you could check out marathon matches in TopCoder, if you want a long term contest..
11:38:18 <roconnor> rajeshsr: that's the name, but because no one is sure what a functional language is, any language is allowed
11:38:20 <jmcarthur> it's a conference with an associated contest
11:38:24 <roconnor> usually C or C++ wins
11:38:32 <rajeshsr> roconnor, haha!! :)
11:38:40 <roconnor> rajeshsr: AFAIK TopCoder doesn't do Haskell
11:38:51 <rajeshsr> yep, no Haskell
11:38:59 <roconnor> rajeshsr: if you are looking for some practice do the 2006 contest
11:39:00 <rajeshsr> but python is there for Marathos i suppose
11:39:24 <roconnor> rajeshsr: though I would somewhat advise writing the virtual machine in C
11:39:52 <roconnor> rajeshsr: http://boundvariable.org/task.shtml
11:40:40 <rajeshsr> roconnor, thanks! Lemme check out.
11:41:16 <rajeshsr> Anyway, curious about how C/C++ wins in ICFP! :) Shouldn't Functional Programming languages be given more importance?
11:41:47 <Twey> Maybe it's written in a functional style.
11:41:52 <dcoutts> rajeshsr: the contest is fair, so sometimes people using non-functional languages win
11:41:52 <Twey> â€¦ bahahaha.
11:42:12 <roconnor> there are more C/C++ programmers than functional programmers
11:42:19 <dcoutts> there are a lot of people out there who are well practised at programming contests
11:42:35 <rajeshsr> yeah! most of them use C/C++
11:42:58 <mauke> none of them use C/C++ :-|
11:43:21 <Twey> But isn't it a *functional* programming contest?
11:43:23 <pikhq> It's possible to write C/C++ in a functional style. Granted, the language doesn't lend itself to it at all.
11:43:38 <Twey> Surely it should be something that's hard to do imperatively.
11:43:42 <soupdragon> lol mauke
11:43:55 <dcoutts> Twey: not really, it's a programming contest organised by a functional programming conference
11:44:04 <Twey> dcoutts: Oh, fair enough then
11:44:18 <mauke> preflex: ? c/c++
11:44:18 <preflex>  factoid not found
11:44:18 <Twey> pikhq: Yeah.  The laughter was because the resulting code is so convoluted that it can hardly be considered functional at all.
11:44:27 <dcoutts> Twey: obviously we hope FP languages do well! :-)
11:44:28 <mauke> preflex: store c/c++ http://www.cpax.org.uk/prg/portable/c/c++/rfe00002.html
11:44:47 <soupdragon> cabal install cabal-install # breaks :(
11:44:48 <dcoutts> Twey: it was partly a publicity thing and partly because FP languages were excluded from the ACM contest
11:45:09 <dcoutts> soupdragon: oh noes!
11:45:13 <dcoutts> soupdragon: how so?
11:45:17 <Twey> dcoutts: Really?  :-\  But why?
11:45:17 <rajeshsr> Twey, well, i would assume that ICFP will be interested in FP. There are too many programming contests these days to organize yet another programming contest.
11:45:35 <Twey> rajeshsr: Interested in, yes; oriented towards, apparently not.
11:45:36 <dcoutts> Twey: dunno, ask ACM
11:46:08 <dcoutts> Twey: they had a limited number of "popular" languages, perhaps they've relaxed it in recent years
11:46:53 <dcoutts> soupdragon: any details?
11:47:24 <camio> I competed in my University and I remember how much trouble they had making the infastructure for just java and c++.
11:48:19 <soupdragon> I had to run it again to get the error and it grinds my computer almost to a halt to do so
11:48:49 <soupdragon> Linking dist/build/cabal/cabal ...
11:48:54 <soupdragon> cabal-install-0.8.2 failed during the building phase. The exception was: ExistFailure 9
11:49:08 <soupdragon> that's on 64 bit ubuntu 10.04
11:49:11 <olsner> I usually think of the "functional" in ICFP mostly as "geared towards slightly smarter programmers than all the other programming contests"
11:49:22 <dcoutts> soupdragon: oh, is that a rather low memory machine?
11:49:45 <Twey> camio: Heh, you should see the setup for the my computing AS with six languages
11:49:45 <soupdragon> dcoutts, well yes I suppose so - I have to run it on a VM because I couldn't managed to install the OS on my actual computer
11:49:48 <dcoutts> soupdragon: on some machines the linker takes loads of memory and the kernel kills it
11:49:56 <soupdragon> I'm just using ubuntu because the haskell platform is broken..... :/
11:50:10 <Twey> camio: We (the candidates) basically had to set everything up ourselves, because the college doesn't know what to do with anything that doesn't run in Visual Studio
11:50:43 <dcoutts> soupdragon: you can try making more memory available and try the linking again
11:50:55 <olsner> Twey: what does AS mean in "computing AS"?
11:51:20 <dcoutts> soupdragon: if you need to use a highly memory constrained box to do the building then it is possible to build ghc differently, but it's a PITA
11:51:37 <camio> Twey: One of the people on our team sent the people running the competition bug fixes for their submission code after he hacked a way into it. All this while the competition was running.
11:51:40 <Twey> olsner: â€˜Advanced Subsidiaryâ€™
11:52:00 <Twey> camio: You should so get extra points for that.
11:52:06 <freiksenet> how is it idiomatic in haskell to solve the problem that you usually solve with OO in other languages? Eg widgets tree in GUI libraries, objects in game etc.
11:52:28 <Twey> freiksenet: Depends
11:52:48 <freiksenet> Twey: is there any good article I can read on it?
11:53:09 <Twey> freiksenet: There's no real hammerâ€¦ we do have OO in Haskell, but we use it a lot less.  A lot of problems we prefer to express in more functional terms, like applicatives, or arrows
11:53:31 <camio> freiksenet: Often I find that what objects usually solve, a DSEL is better suited.
11:53:33 <Twey> I don't think there's a single paper, because we don't usually see it as a single problem.  We break the problem domain down a lot more.
11:54:11 <freiksenet> well I have game-like problem. I have set of types and set of "things" that they can do.
11:54:36 <Twey> Consider rethinking your problem entirely
11:54:55 <freiksenet> in OO langauge I would make a class "base-object", that can do nothing, then inherit class "fooable" from it that can do foo etc
11:55:14 <monochrom> scratch base object.
11:55:37 <monochrom> write an abstract type for foo.
11:55:39 <Twey> There was an excellent article in which someone programmed Pacman in Erlang that gives a good account of the sort of paradigm shift required to stop thinking of things that do things and start thinking of things that are
11:55:42 <freiksenet> I was thinking typeclasses "fooable" that will apply to all types that foo and so on
11:56:00 <olsner> one way to map OO into functional is to make your entire "class hierarchy" a single algebraic data type instead, and use pattern matching instead of polymorphism
11:56:08 <olsner> it only works for some problems of course
11:56:09 <Philonous> What was the name of the package that allowed you to compile and run strings of haskell code?
11:56:20 <camio> +1 olsner
11:56:31 <monochrom> the package is perhaps hint.
11:57:01 <olsner> esp. if your code involves the visitor pattern ("smelly visitor" pattern? :P)
11:57:02 <Philonous> monochrom: Thank you. I was close
11:57:16 <Twey> For example, the dots flash on and off â€” rather than saying that the dot turns on, then it waits for one second, then the dot turns off, &c., you say that the dot's visibility is a function of game time in which the visibility is identical to the divisibility of the current number of seconds by two
11:57:40 <freiksenet> visitor is how they call real object systems in java?
11:57:49 <freiksenet> :)
11:57:59 <freiksenet> it looks suspiciously like CLOS generics
11:58:12 <Twey> Ah, here it is: http://prog21.dadgum.com/23.html
11:58:34 <freiksenet> meh, design patters make me sick.
11:58:42 <freiksenet> Twey: thanks
11:59:00 <sm> I like that dadgum blog, but I don't remember getting anything.. substantial out of it
11:59:13 <freiksenet> so is idea with type classes that represent various "doable actions" and types that implement 1 or more of them good?
11:59:41 <Twey> I don't know about â€˜substantialâ€™.  It doesn't have a lot of hard information, but it does trigger some insights.
12:00:00 <sm> it asks questions and I keep looking for answers :)
12:00:08 <sm> but they don't come
12:01:25 <Twey> Hehe
12:02:13 <sm> actual functional games, eg. But that reminds me.. puppygames.com new game beta out today!
12:02:26 <camio> freiksenet: If you want an OO solution written in a functional language, yeah.
12:02:40 <freiksenet> camio:
12:02:44 <freiksenet> oops
12:02:45 <Twey> freiksenet: But you probably don't.
12:02:54 <freiksenet> I don't
12:02:55 <Twey> sm: Hadn't heard of puppygames.  What is it?  Functional games?
12:02:59 <freiksenet> I want to improve my knowledge of haskell
12:03:13 <sm> they make superb retro games. Java, I believe
12:03:19 <Twey> Ah
12:03:42 <camio> freiksenet: I feel you. I can recommend something for you, but it isn't a quick way to enlightenment.
12:04:04 <camio> freiksenet: http://people.cis.ksu.edu/~schmidt/text/densem.html
12:04:33 <camio> Best book on haskell ever written.
12:04:55 <camio> Before haskell was even a language.
12:05:24 <freiksenet> ok, I'll check it out.
12:06:41 <ohwow> hi
12:09:35 <freiksenet> hm, I though about it.. I have quite a limited and finite set of possible types so it might be that I can easily go with pattern matching to solve this problem
12:13:32 <soupdragon> What sort of category theory could I use to defien something along the lines of these type theory which lets you write proofs?
12:14:04 <soupdragon> I want to make some language that I can implement categories in (maybe in haskell) and have proofs too
12:14:25 <camio> soupdragon: Are you familiar with agda?
12:14:27 <soupdragon> yes
12:15:30 <c_wraith> err.  the current release of haskell platform doesn't work with 6.12.2?
12:15:41 <monochrom> likely
12:15:45 <camio> soupdragon: http://www.iis.sinica.edu.tw/~scm/pub/aopa.pdf <- This might help if you haven't seen it yet.
12:16:02 <c_wraith> it explicitly depends on base-4.2.0.0, and 6.12.2 comes with base-4.2.0.1
12:16:17 <c_wraith> I wonder what happens if I just hack that requirement.
12:16:29 <monochrom> likely inconsequential
12:16:45 <c_wraith> the change, or how much it helps install platform? ;)
12:16:55 <monochrom> but I would recomment 6.12.3 over 6.12.2 while you're at it. 6.12.2 introduced a serious bug
12:17:11 <Phyx-> .3 is out already?
12:17:19 <Phyx-> and i'm still on .1
12:17:20 <Phyx-> lol
12:17:36 <monochrom> release-candidating. one person reported lack of problem.
12:17:53 <c_wraith> what was the problem introduced?
12:17:54 <Phyx-> monochrom: out of curiosity, what's the serious bug in .2?
12:18:28 <soupdragon> http://hackage.haskell.org/package/CPL <--- Cool
12:18:54 <Phyx-> is... there an option to tell ghc to ignore line pragmas?
12:19:28 <Phyx-> or must I adjust the ranges myself
12:19:55 <monochrom> http://hackage.haskell.org/trac/ghc/ticket/4038 and http://hackage.haskell.org/trac/ghc/ticket/4041
12:21:25 <monochrom> I miscounted. Two persons reported lack of problems with 6.12.3RC. In fact one of them explicitly tested against a 6.12.2 bug.
12:22:14 <camio> soupdragon: Sorry, I was way off on what you were looking for.
12:22:17 <monochrom> So, to me: 6.12.1 if just an end-user, 6.12.3RC if a pioneer
12:22:47 <monochrom> there is no tenable reason to use the worst of both worlds that is 6.12.2
12:22:48 <soupdragon> I have a feeling that what I want to do is too difficult for me
12:23:06 <Phyx-> lol, i'm rocking 6.10.4, 6.12.1 and 6.13.20100521
12:24:41 <geheimdienst> lol: Category theory is known as highly abstract mathematics. Some call it abstract nonsense. It chases abstract arrows and diagrams, proves nothing about those arrows and diagrams, rarely talks about what arrows are for and often concepts go beyond oneâ€™s imagination.
12:24:42 * Polarina is patient and simply uses 6.12.1 while waiting for 6.14.
12:24:52 <geheimdienst> (from the thesis that introduced CPL)
12:24:53 <Phyx-> lol, on that 4041 Simon Marlow is refering to himself in the third person
12:25:09 <geheimdienst> a phd thesis, no less
12:26:13 <danderson> c2hs really is amazing once you get over the initial hump. At times it's as if it reads my mind to produce the binding code.
12:26:27 <Phyx-> geheimdienst: for a secret service you're not to secretive :P
12:26:39 <monochrom> someone wrote his mind into c2hs.
12:26:54 <Phyx-> or his mind produced c2hs
12:29:33 * Phyx- taps the mic.. tough crowd
12:30:36 <danderson> heh.
12:31:12 <monochrom> There is no mic.
12:31:28 * geheimdienst in all seriousness thought "4041 Simon Marlow" was the name of an asteroid. geheimdienst needed to google it to realize that "4041" is a trac ticket.
12:31:39 <monochrom> hahahaha
12:32:21 <Phyx-> haahaha
12:32:32 <Polarina> Haha!
12:32:35 <monochrom> "water is found on 4041 Simon Marlow. now we look for bugs, to prove extra-terrestrial life"
12:33:09 <danderson> when bugs achieve sentience, we are well and truly screwed
12:33:52 <geheimdienst> i mean, phyx even wrote that something occurs _on_ 4041 Simon Marlow
12:34:21 <Phyx-> geheimdienst: lol, yeah, but just a few lines earlier monochrom pasted the link to the ticket
12:34:39 <geheimdienst> i'm pretty sure on that asteroid you could profitably mine monads or something
12:36:12 * Polarina went monad mining, but only found some monoid minerals.
12:36:51 <burp> lol
12:36:59 <monochrom> you have to put monoid in a category refiner to get monads. and oop as waste.
12:37:36 <Twey> Objects are formed from monoids now?
12:37:46 <Twey> I just can't keep up :Ã¾
12:37:47 <monochrom> build a stronger container for your category refiner because the process of refinery involves mine explosions.
12:37:53 * Polarina scetches up a blueprint for a category refiner. Now that's applicative!
12:41:28 <nothing> @djinn String -> String
12:41:28 <lambdabot> Error: Undefined type String
12:41:42 <nothing> @djinn Int -> Int -> Int
12:41:43 <lambdabot> Error: Undefined type Int
12:41:56 <nothing> @djinn Integer -> Integer -> Integer
12:41:56 <lambdabot> Error: Undefined type Integer
12:42:05 <nothing> @djinn a -> a -> a
12:42:05 <lambdabot> f _ a = a
12:42:25 <Twey> const
12:43:33 <geheimdienst> no, i think it's flip . const or something
12:43:38 <nothing> @pl x (a,b) = putStrLn $ a ++ " - " ++ b
12:43:39 <lambdabot> x = uncurry ((putStrLn .) . (. (" - " ++)) . (++))
12:44:02 <nothing> is there a way to make an arrow using first and second that does that?
12:44:06 <mux> I cannot seem to be able to use iteratee and enumLines in order to extract & process lines in an effectful way
12:45:14 <mux> can someone show me how I could reimplement printLines using enumLines (with strict bytestyring's) or should I go at it another way?
12:45:28 <nothing> @djinn (a,b) -> m ()
12:45:29 <lambdabot> -- f cannot be realized.
12:46:43 <byorgey> nothing: not really.
12:47:36 <byorgey> nothing: Control.Arrow has some nice combinators for working with pairs, but nothing for eliminating them (other than uncurry).
12:47:49 <mosowski> how to ask ghci about unary (-) type ?
12:48:57 <nothing> byorgey: i'm happy to use uncurry :)
12:49:19 <nothing> byorgey: i guess i wouldn't need an arrow at all then huh
12:49:22 <camio> :t negate
12:49:22 <lambdabot> forall a. (Num a) => a -> a
12:50:09 <nothing> byorgey: i'm trying to make a nice version of this (foldable F) : printNumberedList  = F.mapM_ (\(n,g) -> putStrLn (show n ++ " - " ++ show g)) . (zip [1 ..]) . F.toList
12:50:30 <nothing> byorgey: and i want to pointfree the lambda expression cuz i think it's ugly
12:51:43 <nothing> byorgey: and i'd also like to abstract the fact that i have to call 'show' twice there
12:52:57 <nothing> byorgey: unfortunately 'join (***) show' makes it so i can only apply this to foldables of Num and Enum -- i am always running into this problem w/haskell - any way to rethink things?
12:53:16 <Twey> Hate that.  â˜¹
12:53:43 <Twey> :t join (***)
12:53:44 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
12:55:21 <Twey> I can't even see how to rewrite that using existentials.
12:55:48 <nothing> twey: yeah that's exactly the problem.  by 'hate that' you mean you hate that this isn't nice in haskell too?
12:56:24 <Twey> I mean that this particular example annoys me.
12:57:33 <Twey> â€˜join (***) :: forall b c. (b -> c) -> (b, b) -> (c, c)â€™ is just the normal one.  :-\
12:58:31 <Twey> :t ((undefined :: (forall a. a) -> (forall b. b)) *** (undefined :: (forall a. a) -> (forall b. b))
12:58:32 <lambdabot> parse error (possibly incorrect indentation)
12:58:47 <Twey> Hmph
12:58:55 <Twey> Oh
12:59:06 <Twey> :t (undefined :: (forall a. a) -> (forall b. b)) *** (undefined :: (forall a. a) -> (forall b. b))
12:59:07 <lambdabot> forall b. (forall a. a, forall a. a) -> (forall b1. b1, b)
12:59:34 <Twey> Oh, I guess
12:59:49 <Cale> That's an interesting result
12:59:55 <Twey> Indeed
13:00:01 <pastorn> i win!
13:00:03 <pastorn> ghc: panic! (the 'impossible' happened)
13:00:13 <nothing> twey:  :)  i seem to always run into situations where i want to do stuff like this -- what is it you don't like?
13:01:05 <soupdragon> Cale can you help me
13:01:11 <Cale> soupdragon: maybe
13:01:20 <soupdragon> i had this cool idea but I don't know if it's plausible
13:01:35 <soupdragon> something like a proof checker except it's based on category of categories
13:01:37 <Twey> :t (join (***) show :: (forall a. Show a => a, forall b. Show b => b) -> (String, String)) (5, 'a')
13:01:38 <lambdabot>     No instance for (Show (forall a. (Show a) => a))
13:01:38 <lambdabot>       arising from a use of `show' at <interactive>:1:12-15
13:01:38 <lambdabot>     Possible fix:
13:01:46 <soupdragon> so you can define new categories in it and write proofs
13:02:00 <Twey> I'm confused by this error.
13:02:03 <Cale> soupdragon: That would be interesting
13:02:09 <soupdragon> it might be a good project to do in haskell too but I don't really know like what it should be
13:02:18 <soupdragon> sort of like a dependent type system I think
13:02:35 <soupdragon> I've implemented a basic one of those but it's not exactly what I need
13:03:18 <soupdragon> Cale - it's because I have this book 'Computational Category Theory' and they use SML to implement everything.. and I was thinking it would be nice to have proofs too, it's just that doing it in Coq or whatever doesn't really work out
13:03:46 <nothing> twey: isn't it that join (***) isn't existential?  it requires tuples of type (a,a) instead of (Show a, Show a') => (a,a')
13:03:59 <Cale> I sort of think that the future of type systems is somewhere out in that direction, but I don't really know what a language with first class categories should look like
13:04:23 <Twey> nothing: But I explicitly made that â€˜aâ€™ (forall a. Show a => a) so that they could be different.
13:04:34 <soupdragon> maybe I just want something like a dependently typed CPL
13:04:37 <soupdragon> I'm not sure really
13:04:58 <Twey> I was half expecting some kind of error, but not that one â€” (forall a. Show a => a) *clearly* has a Show instance.  In fact, that's its sole defining feature.
13:05:20 <Cale> soupdragon: I can imagine it would be rather handy even just to be able to define free categories, and functors between those, and from those back to an ordinary category of types and functions.
13:06:10 <Cale> (I guess GADTs are not unlike that at times)
13:06:41 <Cale> I'm about to collapse and it's only 4pm here, so perhaps I should take a nap :)
13:06:52 <soupdragon> see ya!
13:07:13 <Twey> Aw.
13:07:26 <xerox> nothing
13:07:36 <nothing> xerox: ?
13:07:49 <xerox> > uncurry ((. (" - " ++) . show) . shows) (100, Just 0)
13:07:50 <lambdabot>   "100 - Just 0"
13:08:10 <xerox> if only I could it only with shows
13:08:11 <nothing> xerox: yeah but that's not prettier than a lambda :)
13:08:16 <Twey> xerox: The aim was to avoid repeating â€˜showâ€™.
13:08:23 <Twey> Using â€˜showsâ€™ instead isn't much of an improvement ;)
13:08:24 <xerox> but repeating shows is good
13:09:14 <mux> can someone show me how I'm supposed to process input line by line using iterarees?
13:09:26 <geheimdienst> this might be silly, but when i have a list of functions and an argument, how would i apply each of them to the argument? producing a list of results
13:09:45 <Botje> map (\f -> f x) fs
13:09:48 <bremner> hey, that was an exam question from a course I taught last term
13:09:56 <Botje> (and the lambda is usually written ($x) )
13:10:01 <Twey> mux: http://ianen.org/articles/understanding-iteratees/ http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/
13:10:26 <mux> Twey: I read both links already, I'm trying to use the enumLines enumerator from the iteratee package
13:10:39 <xerox> > [succ, (2*), (10^)] `sequence` 2
13:10:41 <lambdabot>   [3,4,100]
13:10:42 <Twey> mux: Then I'll get back to you when I've finished reading them ;)
13:10:47 <geheimdienst> thanks botje
13:10:56 <xerox> for a more compact way :)
13:14:01 <zygoloid> Twey: i think the error makes sense. how do you create a ShowDict (ShowDict a -> a)? perhaps you meant (exists a. Show a => a, ...) ?
13:15:07 <Twey> zygoloid: I don't knowâ€¦ what is a ShowDict?
13:15:31 <zygoloid> Twey: a dictionary of Show methods
13:15:41 <nothing> :t (join (***) show :: (exists a. Show a => a, exists b. Show b => b) -> (String, String)) (5, 'a')
13:15:42 <lambdabot> parse error on input `.'
13:16:19 <nothing> zygoloid: i have not heard of exists (tho i wish existentials used it instead of forall) -- does it -- erm -- exist?
13:16:40 <zygoloid> nothing: iirc JHC has it. GHC does not.
13:17:17 <nothing> zygoloid: my understanding was that forall essentially means exists...  (as difficult as that is to swallow)
13:18:29 <zygoloid> nothing: forall means forall :)  (forall a. a) is the type of things which are of every type
13:18:46 <zygoloid> "data X = forall a. C a" has constructors "C a" for all types a.
13:19:54 <soupdragon> scary looking forall
13:20:07 <soupdragon> much more comfortable with  data X where C :: a -> X
13:20:18 * zygoloid agrees, gadt syntax is lovely :)
13:22:21 <nothing> :t (join (***) show :: (forall a. Show a , forall b. Show b) => (a,b) -> (String, String)) (5, 'a')
13:22:22 <lambdabot> malformed class assertion
13:23:32 <nothing> :t (join (***) show :: forall a b. (Show a , Show b) => (a,b) -> (String, String)) (5, 'a')
13:23:33 <lambdabot>     Couldn't match expected type `a' against inferred type `b'
13:23:34 <lambdabot>       `a' is a rigid type variable bound by
13:23:34 <lambdabot>           an expression type signature at <interactive>:1:27
13:25:25 <aristid> :t join (**) show
13:25:26 <lambdabot>     No instance for (Floating [Char])
13:25:26 <lambdabot>       arising from a use of `**' at <interactive>:1:5-8
13:25:26 <lambdabot>     Possible fix: add an instance declaration for (Floating [Char])
13:25:33 <aristid> :t join (***) show
13:25:34 <lambdabot> forall b. (Show b) => (b, b) -> (String, String)
13:26:19 <aristid> :t join
13:26:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:26:33 <aristid> :t (***)
13:26:34 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:26:57 <aristid> :t join (***)
13:26:58 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
13:30:36 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25684#a25684 :)
13:30:48 <HugoDaniel> my haskell perlin noise implementation
13:31:17 <Polarina> Source?
13:32:19 <HugoDaniel> Polarina: not yet available, soon...
13:32:42 <HugoDaniel> it is still slooowwwww 2s for a 1024x1024 texture :/
13:32:54 <HugoDaniel> (in a quad-core... it is runing in parallel)
13:33:15 <c_wraith> have you benchmarked lower numbers of processors to see what that curve looks like?
13:33:28 <c_wraith> err, lower numbers of OS threads
13:33:47 <HugoDaniel> no, i mostly use 4 threads on this
13:33:50 <HugoDaniel> let me try it
13:35:41 <nothing> can anyone think of a nice way to do this, without the lambda and multiple calls to show?  (foldable F) : printNumberedList  = F.mapM_ (\(n,g) -> putStrLn (show n ++ " - " ++ show g)) . (zip [1 ..]) . F.toList
13:37:03 <zc00gii> ok, I don't use haskell for the record, but I'm compiling something with cabal, and I have everything installed, but it's giving me errors, is there a way I can skip them?
13:38:16 <monochrom> strange approach to problems. you must be alexander the great reborn.
13:38:44 <zc00gii> monochrom, who me? well, version problems I just ignore
13:38:57 <zc00gii> but it says ==
13:38:59 <c_wraith> @pl \(n,g) -> putStrLn (show n ++ " - " ++ show g)
13:38:59 <lambdabot> uncurry ((putStrLn .) . (. ((" - " ++) . show)) . (++) . show)
13:39:12 <c_wraith> that doesn't count as nice. :)
13:40:39 <Phyx-> zc00gii: what;s the error?
13:40:45 <zc00gii> Phyx-, nvm I fixed it ;)
13:40:56 <Phyx-> mkay :)
13:42:20 <monochrom> I know conquerors and managers alike who take this approach to problems. "It says error, how do I tell it to shut up?"
13:42:45 <monochrom> Presumably every space shuttle fatality is caused by this approach.
13:43:07 <monochrom> "The engineers say something is wrong. How do I tell them to shut up and continue?"
13:44:09 <zc00gii> monochrom, heh, I don't normally. I use C and Python to program in =P
13:44:20 <camio> monochrom: Do you know of some succesful managers who encourage naysayers?
13:46:05 <aristid> monochrom: i presume this was a joke? there are many other things that can cause problems, too
13:47:08 <monochrom> My understanding of Feynman's minority report is this is not a joke.
13:54:33 <EvanR-work> > evalRand (getRandom :: Int) (mkStdGen 0)
13:54:34 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:54:34 <lambdabot>         against inferred type ...
13:54:45 <EvanR-work> > evalRand (getRandom :: Rand StdGen Int) (mkStdGen 0)
13:54:46 <lambdabot>   -117157315039303149
13:54:50 <EvanR-work> > evalRand (getRandom :: Rand StdGen Int) (mkStdGen 1)
13:54:51 <lambdabot>   7917908265643496962
13:55:03 <c_wraith> > cake !! 22
13:55:04 <lambdabot>   "Nine large egg yolks."
13:55:10 <c_wraith> > cake !! 23
13:55:12 <lambdabot>   "Twelve medium geosynthetic membranes."
13:55:15 <EvanR-work> ._.
13:55:19 <Polarina> xD
13:55:32 <EvanR-work> ive been generating random content the entirely wrong way this whole time
13:55:38 <geheimdienst> >cake
13:55:42 <geheimdienst> > cake
13:55:43 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
13:56:02 <Olathe> > length cake
13:56:03 <lambdabot>   42
13:56:06 <EvanR-work> > cake !! 43
13:56:09 <lambdabot>   "*Exception: Prelude.(!!): index too large
13:56:17 <geheimdienst> > cake !! 42
13:56:18 <lambdabot>   "*Exception: Prelude.(!!): index too large
13:56:20 <geheimdienst> > cake !! 41
13:56:21 <lambdabot>   "That will deodorize and preserve putrid tissue."
13:56:27 <geheimdienst> > cake !! 40
13:56:29 <lambdabot>   "And it contains proven preservatives, deep penetration agents, and gas and...
13:56:35 <Olathe> O-o
13:56:39 <Polarina> > last cake
13:56:40 <lambdabot>   "That will deodorize and preserve putrid tissue."
13:56:53 <Olathe> > drop 20 $ cake !! 40
13:56:54 <EvanR-work> > reverse cake
13:56:54 <lambdabot>   "en preservatives, deep penetration agents, and gas and odor control chemic...
13:56:55 <lambdabot>   ["That will deodorize and preserve putrid tissue.","And it contains proven ...
13:57:00 <Olathe> > drop 40 $ cake !! 40
13:57:01 <lambdabot>   "ep penetration agents, and gas and odor control chemicals."
13:57:23 <EvanR-work> > sort (cake !! 20)
13:57:24 <lambdabot>   "  .Faabceeefgiilnrrrsssssu"
13:57:36 <geheimdienst> > cake !! 20
13:57:37 <lambdabot>   "Fiberglass surface resins."
13:57:38 <Olathe> > sort (concat cake)
13:57:40 <lambdabot>   "                                                                          ...
13:57:52 <Olathe> Wow
13:58:03 <Olathe> cycle " "
13:58:04 <monochrom> my god, it's full of spaces!
13:58:11 <Olathe> > cycle " "
13:58:12 <lambdabot>   "                                                                          ...
13:58:35 <EvanR-work>  cycle " " -- haskell poetry
13:58:35 <Polarina> > cycle " " == sort (concat cake)
13:58:36 <lambdabot>   False
13:58:58 <monochrom> at least it terminates
13:59:06 <Mathnerd314> @src cake
13:59:06 <lambdabot> Source not found. Just try something else.
13:59:09 <Olathe> > map (\xs -> head xs, length xs) . group . sort . concat $ cake
13:59:10 <lambdabot>   Not in scope: `xs'
13:59:15 <aristid> < cake
13:59:15 <Olathe> Lies
13:59:20 <Polarina> > length cake
13:59:20 <geheimdienst> > dropWhile (== " ") $ sort (concat cake)
13:59:20 <aristid> > cake
13:59:21 <lambdabot>   42
13:59:21 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:59:21 <lambdabot>         against inferred ty...
13:59:21 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
13:59:27 <Olathe> > map (\xs -> (head xs, length xs)) . group . sort . concat $ cake
13:59:28 <lambdabot>   [(' ',162),('\'',3),(',',4),('-',4),('.',43),('1',1),('2',1),('5',1),('8',1...
13:59:30 <geheimdienst> > dropWhile (== ' ') $ sort (concat cake)
13:59:31 <lambdabot>   "''',,,,----...........................................1258:AAAAACCCDFFFFFF...
13:59:43 <EvanR-work> > length (cycle " ")
13:59:45 <aristid> > concat cake
13:59:47 <lambdabot>   "One 18.25 ounce package chocolate cake mix.One can prepared coconut pecan ...
13:59:48 <xerox> where does cake come from
13:59:48 <lambdabot>   mueval: ExitFailure 1
13:59:50 <geheimdienst> woah, the only digits are 1, 2, 5 and 8
14:00:05 <monochrom> interesting
14:00:14 <EvanR-work> geheimdienst: and they are all from the first one
14:00:24 <EvanR-work> > cake !! 0
14:00:25 <lambdabot>   "One 18.25 ounce package chocolate cake mix."
14:00:32 <Olathe> @let blend = map (\xs -> (head xs, length xs)) . group . sort . concat
14:00:33 <geheimdienst> you're right
14:00:34 <lambdabot>  Defined.
14:00:36 <Olathe> > blend cake
14:00:37 <EvanR-work> > take cake
14:00:37 <lambdabot>   [(' ',162),('\'',3),(',',4),('-',4),('.',43),('1',1),('2',1),('5',1),('8',1...
14:00:37 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:00:38 <lambdabot>         against inferred type ...
14:00:47 <EvanR-work> > take 1 cake
14:00:48 <lambdabot>   ["One 18.25 ounce package chocolate cake mix."]
14:01:01 <Olathe> @type sortBy
14:01:03 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:01:03 <aristid> > map fst (blend cake)
14:01:04 <lambdabot>   " ',-.1258:ACDFINOPSTUabcdefghijklmnoprstuvwxyz"
14:01:16 <Mathnerd314> say, is that the cake from Portal?
14:01:34 <geheimdienst> so we have established the cake recipe uses the letters a-z and a little punctuation
14:01:37 <aristid> > length "abcdefghijklmnoprstuvwxyz"
14:01:38 <lambdabot>   25
14:01:47 <monochrom> and lots of spaces
14:01:50 <geheimdienst> well, q is missing
14:01:50 <jyper> ssh aragog
14:01:57 <jyper> oops
14:02:01 <geheimdienst> > length (concat cake)
14:02:02 <EvanR-work> > 'q' `elem` "abcdefghijklmnoprstuvwxyz"
14:02:02 <lambdabot>   1393
14:02:03 <lambdabot>   False
14:02:10 <xerox> > length . filter isSpace . concat $ cake
14:02:12 <lambdabot>   162
14:02:14 <aristid> > ['a'..'z']
14:02:15 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
14:02:38 <EvanR-work> > ['a'..'$']
14:02:39 <lambdabot>   ""
14:02:43 <monochrom> this is worthy of HWN. "this week, #haskell used haskell to deconstruct cake..."
14:03:39 <Olathe> @let stir = map snd . sortBy (comparing fst) . zip (randoms (mkStdGen 0)) . concat
14:03:40 <lambdabot>  <local>:23:25:
14:03:40 <lambdabot>      Ambiguous type variable `a' in the constraints:
14:03:40 <lambdabot>        `...
14:03:54 <Olathe> @let stir :: [String] -> String; stir = map snd . sortBy (comparing fst) . zip (randoms (mkStdGen 0)) . concat
14:03:55 <lambdabot>  <local>:23:53:
14:03:55 <lambdabot>      Ambiguous type variable `a' in the constraints:
14:03:55 <lambdabot>        `...
14:04:00 <sm> does anyone know how to build portable mac binaries ?
14:04:19 <Olathe> @let stir :: [[a]] -> [a]; stir = map snd . sortBy (comparing fst) . zip (randoms (mkStdGen 0) :: [Int]) . concat
14:04:21 <lambdabot>  Defined.
14:04:26 <Olathe> > stir cake
14:04:27 <lambdabot>   "a esdeskmooe-tndaepaiua neAou hnnene. nu puha.reudu dpjed So neoi lsb hajl...
14:04:34 <sm> with ghc 6.8, I was able to do it by deactivating gmp port and compiling with  -optl-L/usr/lib
14:04:46 <pikhq> That's quite well-stirred.
14:04:51 <Olathe> Thank you
14:05:06 <sm> I want to build binaries that don't require macports (/opt/local/lib) stuff
14:05:07 <pikhq> Unfortunately, I like my cake shaken, not stirred.
14:05:14 <Olathe> Ahh.
14:05:20 <EvanR-work> Olathe: dammit, you should have made the mkStdGen 0 mkStdGen x ;)
14:06:05 <geheimdienst> > sort $ map length cake
14:06:05 <Twey> :t mkStdGen
14:06:06 <lambdabot>   [13,13,16,17,18,20,20,20,21,21,23,23,24,25,25,25,26,27,28,30,31,34,35,35,35...
14:06:07 <lambdabot> Int -> StdGen
14:06:17 <geheimdienst> > maximum $ map length cake
14:06:18 <lambdabot>   98
14:06:20 <tensorpudding> mm, now i'm imagining mixed drinks with cake batter
14:06:23 <geheimdienst> woah, 98
14:07:06 <pikhq> Yes, GLADoS makes some quite ingredient-filled cakes.
14:07:24 <hpc> :t cake
14:07:25 <lambdabot> [[Char]]
14:07:25 <Polarina> > last $ sortBy (\x y -> length x `compare` length y) cake
14:07:27 <lambdabot>   "And it contains proven preservatives, deep penetration agents, and gas and...
14:07:31 <Olathe> > map snd . maximumBy fst . map (\x -> (length x, x)) $ cake
14:07:32 <lambdabot>   Occurs check: cannot construct the infinite type:
14:07:32 <lambdabot>    a = (a, b) -> GHC.Orde...
14:07:41 <Olathe> > map snd . maximumBy (comparing fst) . map (\x -> (length x, x)) $ cake
14:07:42 <lambdabot>   Couldn't match expected type `[(a, b)]'
14:07:42 <lambdabot>         against inferred type `(a1,...
14:07:49 <Polarina> Olathe, already solved that problem.
14:07:53 <Olathe> Ahh.
14:08:18 <geheimdienst> > sortBy (\x y -> length x `compare` length y) cake
14:08:20 <lambdabot>   ["Alpha resins.","Cranial caps.","Four large eggs.","Fish shaped dirt.","On...
14:08:43 <monochrom> cranial caps?!
14:08:44 <Olathe> > sortBy (comparing length) $ cake
14:08:45 <lambdabot>   ["Alpha resins.","Cranial caps.","Four large eggs.","Fish shaped dirt.","On...
14:08:56 <geheimdienst> elem 42 $ map length cake
14:08:57 <Olathe> > reverse . sortBy (comparing length) $ cake
14:08:58 <lambdabot>   ["And it contains proven preservatives, deep penetration agents, and gas an...
14:09:03 <Mathnerd314> > filter ((98 ==) . length) cake
14:09:04 <lambdabot>   ["And it contains proven preservatives, deep penetration agents, and gas an...
14:09:06 <geheimdienst> > elem 42 $ map length cake
14:09:07 <lambdabot>   True
14:09:30 <geheimdienst> > filter ((42==) . length) cake
14:09:31 <lambdabot>   ["Three slash four cups butter or margarine."]
14:09:41 <geheimdienst> "three slash four"?
14:09:42 <Olathe> Three slash four !
14:09:48 <Polarina> 3/4
14:09:49 <geheimdienst> Â¾
14:09:55 <xerox> > "///4"
14:09:56 <lambdabot>   "///4"
14:10:02 <Olathe> I think, as the author went along, he got more and more insane.
14:10:13 <geheimdienst> > 3 / 4
14:10:14 <lambdabot>   0.75
14:10:29 <Polarina> We have the scalar, what's the scale?
14:10:39 <hpc> > cups
14:10:40 <lambdabot>   Not in scope: `cups'
14:10:46 <Polarina> Oh.
14:10:46 <Olathe> The scale is the thing that tells us what the ingredients weigh.
14:11:05 <hpc> but who was phone?
14:11:25 <Olathe> @src comparing
14:11:26 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:11:40 <hpc> :t comparing
14:11:40 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:12:39 <aristid> :t compare
14:12:40 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
14:12:48 <aristid> :t (compare `on`)
14:12:49 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
14:12:58 <hpc> @src on
14:12:59 <lambdabot> (*) `on` f = \x y -> f x * f y
14:13:40 <Olathe> :t on
14:13:41 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:14:29 <hpc> @djinn forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:14:29 <lambdabot> f a b c _ = a (b c) (b c)
14:14:39 <geheimdienst> > let a = 42
14:14:41 <lambdabot>   not an expression: `let a = 42'
14:14:51 <hpc> @let
14:14:52 <lambdabot>  Defined.
14:14:56 <Polarina> o.O
14:14:57 <Olathe> Yes !
14:14:58 <hpc> oh shit
14:15:04 <Olathe> @let ;
14:15:05 <lambdabot>  Defined.
14:15:10 <Olathe> @let ;;;;;;;;;;;;;;;;;
14:15:11 <lambdabot>  Defined.
14:15:17 <geheimdienst> @let a = 42
14:15:19 <lambdabot>  Defined.
14:15:22 <geheimdienst> @let a = a+3
14:15:22 <lambdabot>  <local>:28:0:
14:15:23 <lambdabot>      Multiple declarations of `L.a'
14:15:23 <lambdabot>      Declared at: <local>:...
14:15:31 <hpc> @src a
14:15:31 <lambdabot> Source not found. My mind is going. I can feel it.
14:15:32 <geheimdienst> @let a = 0
14:15:33 <lambdabot>  <local>:28:0:
14:15:33 <lambdabot>      Multiple declarations of `L.a'
14:15:33 <lambdabot>      Declared at: <local>:...
14:15:48 <hpc> @forget
14:15:48 <lambdabot> Incorrect arguments to quote
14:16:20 <geheimdienst> ok suppose we wanted to come up with a command that shows the "next" line of the recipe
14:16:41 <nostrand> is there some page that lists cool tricks in Haskell to show to those who haven't seen the light?
14:16:47 <geheimdienst> so that you can read the whole thing, line by line, by pressing cursor-up and enter
14:17:05 <geheimdienst> that's pretty impossible, right?
14:17:13 <Polarina> geheimdienst, state?
14:17:16 <aristid> geheimdienst: why would it?
14:17:58 <ddarius> @where whyfp
14:17:59 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
14:18:00 <geheimdienst> because haskell is pure ...? i mean, the same expression can't have different results
14:18:13 <Polarina> geheimdienst, but what if you introduce impurity? ;)
14:18:48 <aristid> geheimdienst: you asked about commands, not expressions.
14:19:04 <hpc> that whyfp is a 404
14:20:15 <geheimdienst> hpc, try this: http://www.informatik.uni-rostock.de/mmis/courses/ss07/23002/whyfp.pdf
14:20:32 <hpc> yay
14:21:21 <geheimdienst> aristid, yeah i said "commands" without thinking, i mean "what comes after the > when we talk to lambdabot"
14:22:05 <geheimdienst> (for the record, when googling "why fp matters", result #4 is a youtube video entitled "why family planning matters")
14:22:19 <monochrom> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.pdf
14:22:23 <monochrom> IOW s/math/cs/
14:22:39 <geheimdienst> and s/html/pdf
14:23:06 <monochrom> Actually I prefer the html: http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
14:23:31 <monochrom> It has abstract, and offers choice of ps and pdf, and links to japanese and chinese translations too.
14:23:47 <monochrom> and link to bibtex entry if you want
14:24:01 * geheimdienst wishes the html would have the fulltext
14:24:02 <monochrom> The paper alone just doesn't cut it.
14:24:48 <roconnor> Configuring tagsoup-0.8...
14:24:49 <roconnor> Warning: This package indirectly depends on multiple versions of the same
14:24:51 <roconnor> p
14:24:54 <roconnor> package
14:24:59 <roconnor> what does this warning mea?
14:25:02 <roconnor> mean?
14:25:10 <roconnor> package Cabal-1.6.0.3 requires filepath-1.1.0.2
14:25:12 <roconnor> package process-1.0.1.1 requires filepath-1.1.0.3
14:25:20 <roconnor> where do these packages come from?
14:25:21 <monochrom> The html has links to 4 fulltexts.
14:25:36 <roconnor> afaik nothing depends on process or directory
14:26:41 <roconnor> oh wait
14:26:52 <roconnor> there is a bunch of crap in my .ghc
14:27:34 <roconnor> crap
14:27:40 <roconnor> how do I uninstall things?
14:27:40 <monochrom> (why does everything have botched .ghc?)
14:27:52 <monochrom> ghc-pkg unregister
14:28:05 <monochrom> s/everything/everyone/
14:28:36 <c_wraith> I tried using ghc-pkg unregister earlier.  I eventually ended up in a state ghc-pkg check said was fine, but was still broken.  I gave up and reinstalled ghc at that point.
14:29:29 <monochrom> If you change ghc version, you should wipe .ghc anyway.
14:30:00 <c_wraith> yeah.  But what actually happened was that I upgraded bytestring, which it seems is something you shouldn't do.
14:30:10 <roconnor> monochrom: is that a safe operation?
14:30:13 <monochrom> As though lib binaries built for 6.10.3 would really work for 6.10.4, yeah.
14:30:24 <roconnor> monochrom: do I wipe .cabal as well?
14:31:14 <monochrom> .cabal can be kept
14:31:14 <Igloo> .ghc contains version-specific directories, so you shouldn't need to remove it, although you'll recover disk space if you do
14:31:55 <geheimdienst> yes, i have a .ghc/i386-linux-6.12.1/...
14:32:21 <monochrom> oops, then no need to wipe .ghc either
14:32:52 <roconnor> runhaskell Setup.hs install says:
14:33:01 <roconnor> tagsoup-0.8: dependency QuickCheck-2.1.0.3 doesn't exist (use --force to override)
14:33:06 <roconnor> but AFAIK it does exists
14:33:09 <roconnor> so what's up with that?
14:33:24 <mux> yay, as expected, ghc 6.12.3rc1 fixes the bug with blocking file descriptors
14:33:48 * mux postpones learning iterareews
14:33:49 <geheimdienst> roconnor, maybe you have quickcheck but not the right version?
14:33:53 <mux> err, iteratees
14:34:27 <roconnor> do I need to uninstall QuickCheck 1.2.0.0 ?
14:34:27 <EvanR-work> iterareews, the diminutive version of iteratees
14:34:41 <roconnor> /nix/var/nix/profiles/per-user/roconnor/profile/bin/../lib/ghc-pkgs/ghc-6.10.4/QuickCheck-2.1.0.3.installedconf:
14:34:42 <roconnor>     {QuickCheck-2.1.0.3}
14:34:46 <geheimdienst> as in, "eew gross"
14:34:56 <roconnor> so QuickCheck-2.1.0.3 is installed
14:35:26 <geheimdienst> does "cabal info quickcheck" agree?
14:36:02 <geheimdienst> also, use the verbose switch, it's pretty helpful
14:36:04 <roconnor> geheimdienst: I don't have cabal-install installed
14:36:33 <c_wraith> roconnor: doesn't Setup.hs look in global package repositories only?  any chance you have qc in a uesr package repository?
14:36:39 <roconnor> Registering tagsoup-0.8...
14:36:40 <roconnor> create dist/installed-pkg-config
14:36:42 <roconnor> /nix/var/nix/profiles/per-user/roconnor/profile/bin/ghc-pkg --user update dist/installed-pkg-config
14:36:43 <roconnor> Reading package info from "dist/installed-pkg-config" ... done.
14:36:45 <roconnor> tagsoup-0.8: dependency QuickCheck-2.1.0.3 doesn't exist (use --force to override)
14:36:56 <roconnor> c_wraith: I'm using --user
14:37:11 <roconnor> I do have qc-1 installed locally
14:37:14 <c_wraith> well, that should take care of that.
14:37:39 <mux> cabal-install has been acting a bit weirdly for me recently; I've seen it reinstalling base packages with no good reason two times already
14:37:56 <mux> I'm being extra careful and using --dry-run all the time now, no problems for now
14:39:01 <roconnor> I can't unregister QuickCheck-1.2  I need it for hledger
14:39:26 <roconnor> can I only have one QuickCheck installed?
14:40:20 <sm> roconnor: no, you can have 1 and 2 installed
14:41:38 * geheimdienst innocently ran ghc-pkg list quickcheck. geheimdienst was told "you have broken packages -- run ghc-pkg check". geheimdienst did, and 3 packages were reported as broken. geheimdienst told cabal to reinstall one of them. now ghc-pkg check says there's 4 packages broken.
14:43:13 <roconnor> fuck this, I'll just use --force
14:43:57 <sm> I think that will make it worse
14:44:33 <sm> I've noticed it's getting harder to satisfy dependencies for my various installed packages
14:44:51 <roconnor> well, the packages do exist
14:44:56 <roconnor> so I don't know why it is complaining
14:45:01 <sm> I think upgrading to ghc 6.12 and/or nuking my installation and starting over makes it easier
14:45:39 <sm> ie, a ghc/cabal install has a limited lifetime, as things get updated on hackage and you install new stuff
14:46:25 <sm> roconnor: are you using cabal's --constraint flag ? I have found that helpful
14:46:37 <roconnor> sm: I'm not using cabal install
14:46:43 <sm> oh
14:46:56 <sm> maybe you should ?
14:47:39 <roconnor> Configuring hxt-8.5.2...
14:47:40 <roconnor> Warning: This package indirectly depends on multiple versions of the same
14:47:47 <roconnor> package Cabal-1.6.0.3 requires filepath-1.1.0.2
14:47:48 <roconnor> package hxt-8.5.2 requires filepath-1.1.0.3
14:47:50 <roconnor> but
14:47:58 <roconnor> hxt-8.5.2 is what I'm installing
14:48:07 <roconnor> and it doesn't require filepath-1.1.0.3
14:48:17 <roconnor> it will take any filepath-1.1 or higher
14:48:21 <geheimdienst> i thought cabal was the package manager ... so what is ghc-pkg? is a ghc-pkg the same as a cabal (hackage) package?
14:48:53 <roconnor> oh wait
14:48:55 <roconnor> I see
14:49:23 <roconnor> ah right
14:49:32 <roconnor> hleger require filepath-1.1.0.3
14:49:41 <monochrom> cabal is not manager. just installer. ghc-pkg is the manager. except it doesn't delete files.
14:50:07 <roconnor> or I guess it was just build with it
14:50:13 <roconnor> oh
14:50:15 <roconnor> ok
14:50:36 <nus> roconnor, so APIs conflict?
14:51:29 * geheimdienst thinks using haskell is not for the easily confused
14:51:32 <roconnor> I'll just temporarily remove hleger
14:51:37 <roconnor> and rebuild it later
14:51:59 <sm> sometimes I'll do a cabal install --reinstall and it helps, iirc
14:52:31 <sm> with --constraint, maybe
14:52:32 <roconnor> I'm been meaning to update hledger anyways
14:53:06 <nus> @where hledger
14:53:07 <lambdabot> I know nothing about hledger.
14:53:27 <monochrom> "how are ghc libs installed and known" is just poorly documented, that's all.
14:53:35 <nus> @hackage hleger
14:53:35 <lambdabot> http://hackage.haskell.org/package/hleger
14:53:39 <monochrom> perhaps non-existently
14:54:06 * roconnor uses --force again
14:54:29 <monochrom> oh, there is --force. next time I see a manager type, I can suggest that!
14:54:46 <roconnor> problem solved!
14:56:12 <roconnor> though I don't really understand why I need to use --force
14:56:19 <geheimdienst> ... just make sure that when the day comes, said manager is riding the shuttle
14:57:21 <geheimdienst> found some doc on ghc-pkg http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/packages.html i'm now learning about it
15:00:03 <IceKiller> vervangK :: Int -> String -> Char -> String
15:00:05 <IceKiller> vervangK x xs y = take (x-1) xs ++ (y:[]) ++ drop x xs
15:00:05 <IceKiller> vervangK :: Int -> String -> Char -> String
15:00:05 <IceKiller> vervangK x xs y = take (x-1) xs ++ (y:[]) ++ drop x xs
15:00:10 <IceKiller> woopz
15:00:40 <IceKiller> http://www.privatepaste.com/8751ae12bb how does that exactly work?
15:00:52 <roconnor> it's like ghc-pkg update totally ignore the global data base when given the --user flag
15:01:44 <monochrom> It has a right type.
15:01:48 <sinelaw> hi
15:03:54 <JoeyA> Is there a nice way to get the minimum of [Maybe Int] (only returning Nothing if there are no Justs) ?
15:04:14 <JoeyA> > Data.Foldable.minimum [Just 3, Just 5, Nothing]
15:04:16 <lambdabot>   Nothing
15:04:23 <JoeyA> T'is not what I want.
15:04:48 <JoeyA> > minimum $ filter isJust [Just 3, Just 5, Nothing]
15:04:49 <lambdabot>   Just 3
15:05:08 <JoeyA> T'is what I want, though it doesn't seem that idiomatic to me.
15:05:25 <c_wraith> that will also explode on you
15:05:36 <JoeyA> why?
15:05:37 <c_wraith> > minimum $ filter isJust [Nothing]
15:05:38 <lambdabot>   *Exception: Prelude.minimum: empty list
15:05:47 <JoeyA> Oh
15:05:54 <JoeyA> Indeed, it should be Nothing in that case
15:06:04 <JoeyA> so I'd have to say:
15:06:11 <nus> roconnor, as you are using Nix, weren't you supposed to create/update the nixpkgs for the new versions of the hackages?
15:06:31 <roconnor> nus: In theory
15:06:36 <nus> aha
15:06:40 <roconnor> nus: in practice that strikes me as insane
15:06:44 <roconnor> but perhaps I'm wrong
15:06:49 <JoeyA> > (\x -> if null x then Nothing else minimum x) filter isJust [Nothing]
15:06:50 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
15:06:50 <lambdabot>         against inferred type ...
15:07:05 <JoeyA> > (\x -> if null x then Nothing else minimum x) $ filter isJust [Nothing]
15:07:06 <lambdabot>   Nothing
15:07:14 <JoeyA> > (\x -> if null x then Nothing else minimum x) $ filter isJust [Nothing, Just 3, Just 5, Just 2]
15:07:15 <lambdabot>   Just 2
15:08:01 <JoeyA> I guess what I want is a way to compare Maybes that avoids Nothing whenever it can.
15:08:26 <geheimdienst> icekiller, if i'm reading that correctly, it's a function that you give a string and that replaces one char at one index. (y:[]) is a little strange, it turns the char y into a list of chars (= a string). perhaps [y] would be clearer. take and drop are simple functions from Prelude
15:09:20 <roconnor> > catMaybes [Nothing, Just 3, Just 5, Just 2]
15:09:21 <lambdabot>   [3,5,2]
15:09:50 <roconnor> > (\x -> guard (not (null x)) >> return (minimum x)) $ catMaybes [Nothing, Just 3, Just 5, Just 2]
15:09:51 <lambdabot>   No instance for (GHC.Show.Show (m a))
15:09:51 <lambdabot>    arising from a use of `M4903921635...
15:10:00 <roconnor> > (\x -> guard (not (null x)) >> return (minimum x)) $ catMaybes [Nothing, Just 3, Just 5, Just 2] :: Maybe Int
15:10:01 <lambdabot>   Just 2
15:10:20 <roconnor> > (\x -> guard (not (null x)) >> return (minimum x)) $ catMaybes [Nothing] :: Maybe Int
15:10:21 <lambdabot>   Nothing
15:10:48 <pikhq> @pl (\x->guard (not (null x)) >> return (minimum x)):: Int -> Maybe Int
15:10:49 <lambdabot> (line 1, column 56):
15:10:49 <lambdabot> unexpected ">" or "-"
15:10:49 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:10:57 <pikhq> @pl (\x->guard (not (null x)) >> return (minimum x)) :: Int -> Maybe Int
15:10:57 <lambdabot> (line 1, column 57):
15:10:57 <lambdabot> unexpected ">" or "-"
15:10:57 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:11:03 * pikhq mutters
15:13:47 * hackagebot hexpat 0.17 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.17 (StephenBlackheath)
15:14:15 <JoeyA> > let {f Nothing Nothing = Nothing; f Nothing (Just x) = Just x; f (Just x) Nothing = Just x; f (Just x) (Just y) = Just (min x y)} in foldl' f Nothing [Nothing, Just 3]
15:14:16 <lambdabot>   Just 3
15:17:49 * hackagebot hexpat-iteratee 0.5 - Chunked XML parsing using iteratees  http://hackage.haskell.org/package/hexpat-iteratee-0.5 (StephenBlackheath)
15:18:12 <roconnor> > min Nothing (Just 5)
15:18:14 <lambdabot>   Nothing
15:18:22 <roconnor> > min (Just 5) Nothing
15:18:23 <lambdabot>   Nothing
15:18:40 <roconnor> :(
15:19:07 <roconnor> > max Nothing (Just 5)
15:19:08 <lambdabot>   Just 5
15:19:37 <copumpkin> roconnor: what?
15:19:41 <roconnor> JoeyA: you could make your own Maybe type that adds a Top instead of a bottom
15:19:48 <roconnor> JoeyA: or make a wrapper around Maybe
15:20:18 <copumpkin> JoeyA: what are you trying to do?
15:20:22 <JoeyA> A generic variant of what I'm doing is something like:  maybeFoldL :: (a -> b -> a) -> Maybe a -> [Maybe b] -> Maybe a
15:20:36 <copumpkin> hmm
15:20:40 <JoeyA> copumpkin: trying to get the minimum of a list of Maybes, returning a Maybe and disregarding Nothings.
15:20:45 <roconnor> JoeyA: catMaybes!
15:21:07 <copumpkin> > maximum [Nothing Just 3]
15:21:08 <lambdabot>   Couldn't match expected type `(a1 -> Data.Maybe.Maybe a1)
15:21:08 <lambdabot>                  ...
15:21:11 <copumpkin> > maximum [Nothing, Just 3]
15:21:12 <lambdabot>   Just 3
15:22:34 <copumpkin> JoeyA: oh, you want the minimum of the Justs?
15:22:42 <pikhq> > minimum . catMaybes [Nothing, Just 3, Just 2]
15:22:44 <lambdabot>   No instance for (GHC.Num.Num [a])
15:22:44 <lambdabot>    arising from a use of `e_132' at <inte...
15:22:46 <pikhq> > minimum . catMaybes $ [Nothing, Just 3, Just 2]
15:22:47 <lambdabot>   2
15:22:54 <pikhq> > minimum . catMaybes $ [Nothing]
15:22:55 <lambdabot>   *Exception: Prelude.minimum: empty list
15:22:56 <copumpkin> damn, beat me to it :)
15:23:54 <copumpkin> > foldr min Nothing . catMaybes $ [Nothing]
15:23:55 <lambdabot>   Nothing
15:24:01 <monochrom> > Nothing < Just (-3)
15:24:02 <lambdabot>   True
15:24:04 <copumpkin> > foldr min Nothing . catMaybes $ [Nothing, Just 3, Just 2]
15:24:05 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
15:24:05 <lambdabot>    arising from a use of...
15:24:29 <copumpkin> > foldr min Nothing . catMaybes $ [Nothing, Just 3, Just 2] :: Maybe Int
15:24:31 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
15:24:31 <lambdabot>    arising f...
15:24:44 <monochrom> > negate . maximum . fmap negate $ [Nothing, Just 3, Just 2]
15:24:44 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
15:24:44 <lambdabot>    arising from a use of...
15:24:44 <pikhq> > (\x -> if not (null x) then Just (minimum x) else Nothing) . catMaybes $ [Nothing]
15:24:45 <copumpkin> oh, duh
15:24:45 <lambdabot>   Nothing
15:25:01 <copumpkin> > foldr min Nothing . map pure . catMaybes $ [Nothing, Just 3, Just 2]
15:25:01 <pikhq> Erm.
15:25:02 <lambdabot>   Nothing
15:25:07 <monochrom> @type maximum
15:25:07 <copumpkin> okay, whatever
15:25:08 <lambdabot> forall a. (Ord a) => [a] -> a
15:25:24 <copumpkin> mine made no sense
15:25:30 <pikhq> > (\x -> if not (null x) then Just (minimum x) else Nothing) . catMaybes $ [Nothing, Just 3, Just 2]
15:25:32 <lambdabot>   Just 2
15:25:36 <pikhq> Mine works.
15:25:42 <copumpkin> AREN'T YOU COOL
15:25:47 <monochrom> > fmap negate [Nothing, Just 3, Just 2]
15:25:48 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
15:25:48 <lambdabot>    arising from a use of...
15:25:59 <pikhq> Hah.
15:26:00 <monochrom> @tyep negate
15:26:00 <lambdabot> forall a. (Num a) => a -> a
15:26:15 <monochrom> Oh I see!
15:26:24 <monochrom> > negate . maximum . map (fmap negate) $ [Nothing, Just 3, Just 2]
15:26:25 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
15:26:25 <lambdabot>    arising from a use of...
15:26:36 <burp> > fmap (fmap negate) [Nothing, Just 3, Just 2]
15:26:38 <lambdabot>   [Nothing,Just (-3),Just (-2)]
15:27:46 <monochrom> > map (fmap negate) [Nothing, Just 3, Just 2]
15:27:46 <lambdabot>   [Nothing,Just (-3),Just (-2)]
15:28:01 <monochrom> Oh, I see again.
15:28:04 <monochrom> > fmap negate . maximum . map (fmap negate) $ [Nothing, Just 3, Just 2]
15:28:05 <lambdabot>   Just 2
15:28:41 <c_wraith> there's a solution that works for Num.
15:28:50 <c_wraith> Doesn't work that well when all you have is Ord
15:29:10 <roconnor> monochrom: I thought of that, but it really only works for numbers
15:29:14 <roconnor> ah
15:29:18 <roconnor> c_wraith beat me
15:29:35 <monochrom> Need DualableOrd
15:29:42 <roconnor> we need a general
15:29:44 <roconnor> ya that
15:29:55 <roconnor> I wrote a Backwards instance for Traversable once
15:30:01 <monochrom> everyone speaks your mind!
15:30:01 <roconnor> similar idea
15:30:26 <monochrom> need moar brains!
15:30:57 <xerox> > let justs xs = [ x | x@(Just _) <- xs ] in fmap minimum . sequence . justs $ [Nothing, Just 3, Just 2]
15:30:59 <lambdabot>   Just 2
15:31:16 <roconnor> xerox: catMaybes
15:31:28 <xerox> loses []
15:31:34 <xerox> scratch that
15:31:34 <roconnor> for gods sake everyone: catMaybes already
15:31:36 <xerox> loses Maybe
15:35:39 <nothing> is there usually a way to get an irc client to suppress joining/leaving msgs?
15:35:56 <copumpkin> yeah
15:36:39 <monochrom> You risk talking to people who have left.
15:37:06 <copumpkin> you can still have autocomplete
15:37:34 <nothing> :) a cool lambdabot feature to listen in and inform you if there's an "x left" message above your message starting "x: ..."
15:38:32 <monochrom> haskell: 1, vb: 0
15:38:51 <monochrom> "<lambdabot> haskell left"
15:39:10 <monochrom> @vixen haskell: 1, vb: 0
15:39:10 <lambdabot> Ooh, functional programmers are so hot!
15:40:39 <monochrom> You will also find that "x: ..." does not mean telling something to x.
15:40:58 <burp> you can disable them in xchat and still have nick autocompletion
15:41:32 <BMeph> In theory, that should only work for Bounded types. Of course, "in theory", Bounded should be Lattice, and it should have Meet and Join "sub-classes", etc, etc, etc.... :)
15:45:04 <monochrom> I know bounded non-lattice partial orders. Even finite.
15:46:59 <monochrom> unfortunately the smallest example needs 6 elements.
15:48:31 <BMeph> monochrom: Pair partitions of a set of four? :)
15:49:26 <monochrom> sorry I don't know what that is.
15:52:18 <BMeph> monochrom: Or did you mean somethihng likeone- and two-element subsets of a three-element set?
15:52:25 <BMeph> like one*
15:52:45 <monochrom> I need 6 elements.
15:54:23 <jbapple> even getting five elements is tough
15:54:27 <jbapple> > leeloo
15:54:28 <lambdabot>   Not in scope: `leeloo'
15:54:54 <monochrom> bounded non-lattice partial order: http://pastebin.com/dxTFstpe
15:54:56 <nus> roconnor, ever seen http://github.com/MarcWeber/haskell-nix-overlay ?
15:55:13 <roconnor> nus: yes
15:55:29 <roconnor> I kinda want to hear someone try it first
15:56:33 <nus> oh
15:56:56 <nus> well, it *sounds* easy, at least according to this http://www.haskell.org/haskellwiki/Hack-Nix (-:
16:07:04 <BMeph> monochrom: How is it not a lattice?
16:07:39 <monochrom> the two elements on line 3 don't have meet. the two elements on line 5 don't have join.
16:23:17 * hackagebot hfiar 2.0.0 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-2.0.0 (FernandoBenavides)
16:56:17 <ezyang> Fokkinga really is a much easier read
16:56:27 <ezyang> imo
16:56:33 <monochrom> I agree! :)
16:56:42 * monochrom is fan of Fokkinga
16:56:51 * copumpkin refrains from making a fokking joke
16:57:05 <copumpkin> ezyang: what are you reading?
16:57:36 <ezyang> The Category Theory one
16:58:10 <copumpkin> aha
17:01:45 * ddarius isn't sure what monochrom is agreeing with.
17:02:05 <copumpkin> Fokkinga being an easier read than X, forall X, maybe?
17:02:08 <monochrom> that Fokkinga is an easier read
17:02:52 <monochrom> implicitly, Fokkinga's category theory tutorial, calculational approach
17:03:19 <ddarius> copumpkin understands me
17:04:30 <monochrom> and yeah, also implicitly, all other category theory introductions. can omit "other" if "easier" follows the french convention: "easier or equal to", then it's a nice forall.
17:05:00 <monochrom> the french convention is much easier, too. :)
17:07:22 <ddarius> I don't think Fokkinga is bad, but, like Rydehard and Burstall, I see it as more of an alternate perspective than "the" way to think about CT.
17:08:00 * edwardk waves hello.
17:08:03 <edwardk> preflex: xseen cale
17:08:03 <preflex>  cale was last seen on freenode/#haskell 4 hours, 1 minute and 21 seconds ago, saying: I'm about to collapse and it's only 4pm here, so perhaps I should take a nap :)
17:08:52 * edwardk curses cale's name for rambling on about manufactoria enough on channel that he spent his afternoon on it ;)
17:09:21 <copumpkin> edwardk: did you pound it into submission?
17:10:09 <edwardk> copumpkin: i still have a couple of levels to go
17:10:13 <ddarius> edwardk: The linux flash plugin doesn't like keyboard capture (or something) so I'm safe.
17:10:19 <edwardk> copumpkin: but it was fun nonetheless
17:10:27 <Olathe> Ooh ! Manufactoria ! Looks cool.
17:10:57 <edwardk> i need to figure out a version of the tape adder that fits in the room given ;)
17:13:54 <dancor> is this the coolest js lib for porting haskell funcs: http://demos.flesler.com/HS/
17:14:17 <Kaidelong> http://research.microsoft.com/en-us/projects/asml/
17:15:14 <dancor> Kaidelong: is that for me?
17:15:27 <Kaidelong> not for anyone in particular, but I think it is interesting
17:15:39 <Kaidelong> and I'm thinking of using it for my proposal writing project
17:16:08 <Kaidelong> not AsmL, I mean theme the proposal assignment about proposing to use it
17:17:46 <Kaidelong> also microsoft is just handing out those publications they're citing, which is handy
17:18:03 <Kaidelong> saves me the trouble of going to the library
17:24:52 <Kaidelong> hmm, papers claim that AsmL has a high amount of inherent parallelism but last I knew ASMs were inherently sequential?
17:25:12 <Kaidelong> perhaps if a single transition does multiple things, it can do them in parallel?
17:26:12 <dancor> flesler's js lib doesn't address [4] /= [4] at all
17:28:38 * hackagebot hoauth 0.2.3 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.2.3 (DiegoSouza)
17:40:41 <djahandarie> Is there a function.... f a b c = if a==b then c else a
17:41:25 <dancor> @pl \ a b c -> if' (a == b) c a
17:41:25 <lambdabot> flip =<< ((flip . if') .) . (==)
17:41:42 <ezyang> feh
17:41:46 <djahandarie> lol
17:42:10 <lazyshrk> how about: f a b c = if a == b then c else a
17:42:28 <lazyshrk> i mean you just created that function
17:42:55 <djahandarie> I meant one already existing in some common package
17:43:55 <dancor> i think that function is weird enough to not exist in a common package
17:44:14 <lazyshrk> i think so too
17:45:16 <copumpkin> equality sucks, anyway
17:45:38 <dancor> lol.  well: if' (a /= b) a c
17:45:52 <dancor> in some ways that form seems less weird to me
17:46:15 <djahandarie> @pl \a b c -> if' (a /= b) a c
17:46:15 <lambdabot> flip =<< (if' .) . (/=)
17:46:51 <dancor> :t (\ f g -> flip =<< f . g)
17:46:52 <lambdabot> forall (f :: * -> *) a b a1. (Functor f) => (a1 -> f (a -> b)) -> (a -> a1) -> a -> f b
17:47:10 <djahandarie> lolsigh
18:22:54 <ezyang> What does Fokkinga mean when he states g : (++) -> Mon<*> in Example 1.40?
18:23:02 <ezyang> The type of g, seems to me, to be Seq A -> B
18:23:38 <dolio> Where is example 1.40?
18:24:09 <ezyang> page 28
18:24:13 <dolio> Of what?
18:24:18 <ezyang> oh right
18:24:29 <ezyang> http://wwwhome.cs.utwente.nl/~fokkinga/mmf92b.html
18:24:31 <deech> Hi all, I know this question has probably been asked before, but are there any good guides to Haskelldb?
18:24:40 <ezyang> tsk tsk omitting important details
18:24:56 <copumpkin> adjunctions on page 26 :o
18:25:37 <dolio> Oh.
18:25:47 <dolio> I think the Mon is supposed to be attached to the arrow.
18:25:55 <ezyang> hmm
18:26:17 <dolio> And g is probably a monoid homomorphism.
18:26:27 <ddarius> dolio: Yes and yes, from the free monoid.
18:26:38 <dolio> (++A) being one of the monoids, and <*> being the other.
18:26:44 <dolio> Naming them after the binary operation.
18:26:53 <ezyang> Oh!
18:27:01 <ezyang> Ok. I thought it was a morphism on the operators
18:27:13 <ezyang> which I guess in a strict sense is true, but not from a function perspective.
18:28:54 <fcahoon> i'm looking for help understanding binary file IO -- trying to write a program to break up a large binary file into a bunch of smaller ones
18:29:31 <fcahoon> it's something i could easily do in a procedural language but i'm trying to learn haskell
18:29:54 <ddarius> readFile fp >>= mapM_ (uncurry writeFile) . zip fps . chunk size
18:30:16 <copumpkin> omg (.) and (>>=) in one expression
18:30:23 * copumpkin darts back and forth
18:30:38 <copumpkin> @typo mapM_ (uncurry writeFile) . zip fps . chunk size <=< readFile
18:30:39 <lambdabot> Not in scope: `fps'
18:30:39 <lambdabot> Not in scope: `chunk'
18:30:39 <lambdabot> Not in scope: `size'
18:30:48 <fcahoon> ok i know . is function concatenation but am not yet familiar with >>=
18:31:28 <zachk> fcahoon: thats a semicolon ; or better known as bind
18:31:33 <copumpkin> harpfork: having fun there? :)
18:31:46 <elliottcable> ugh
18:31:49 <elliottcable> donâ€™t even ask
18:32:05 <copumpkin> decided to give #haskell a try?
18:32:12 <elliottcable> hm?
18:32:21 <elliottcable> do I know you?
18:32:45 <copumpkin> we've spoken at various points on IRC but I'm not very memorable. I used to hang out in various ruby channels and git, and I think we followed each other on twitter for a while ;)
18:33:04 <elliottcable> lol
18:33:06 <elliottcable> â€™k
18:33:06 * pikhq_ too has seen elliottcable now and again
18:33:09 <elliottcable> nope, been in here a while
18:33:14 <copumpkin> ah ok
18:33:17 <elliottcable> honestly, I ignore all the channels Iâ€™m in on Freenode
18:33:27 <elliottcable> all of my time is going into Paws, so ##Paws is the only place I pay any attention
18:34:24 <Eridius> elliottcable: what is Paws?
18:34:34 <elliottcable> oh lol itâ€™s Eridius
18:34:40 <pikhq_> Plan About World Subjugation
18:34:41 <pikhq_> ?
18:34:42 <Eridius> :D
18:35:09 <elliottcable> mmm itâ€™s a language, of sorts, that Iâ€™ve been pouring my soul into this year
18:35:19 <Eridius> is there somewhere I can read about it?
18:35:23 <elliottcable> not really.
18:35:25 <pikhq> Soul-powered programming, then.
18:35:28 <elliottcable> well. http://â€º.ws/paws
18:35:49 <elliottcable> but I doubt youâ€™ll learn anything interesting about Paws unless you sit down and have it explained to you, and Iâ€™m too busy to do that right now /-:
18:36:08 <Eridius> haha
18:36:14 <elliottcable> itâ€™s too unusual.
18:36:20 * Eridius wonders what "fully async" means
18:36:36 <elliottcable> long story short, itâ€™s built to operate on the client *and* the server, sharing code and data as necessary/convenient
18:36:42 <Eridius> huh
18:36:45 <elliottcable> removing the client/server barrier for web development
18:37:26 * Eridius will have to take a look as soon as he finds some time
18:37:30 <elliottcable> reference implementations of the interpreter in both C and JS
18:37:40 <elliottcable> heh, lurk ##Paws, youâ€™ll eventually find it out
18:38:00 <elliottcable> I believe some of your friends are already in there; ocassionally we see jane and NoOneButMe
18:38:34 <Eridius> nobm is _not_ my friend
18:38:52 <elliottcable> sorry, I know thereâ€™s some sort of drama there, I just donâ€™t really know what it is.
18:38:55 * elliottcable stays out of it
18:38:59 <Eridius> heh, good idea
18:39:10 <elliottcable> Iâ€™m just here to make a fucking sexy webdev language :3
19:02:02 <bremner> #ruby is =>
19:10:33 <jmcarthur> ha, so last week i was wishing i could go to hac phi in philadelphia in what was the upcoming weekend. now my wife is wanting to go to http://libregraphicsmeeting.org/ *this* upcoming weekend. i guess that's just karma
19:11:15 <jmcarthur> because she was being all practical last week about spur of the moment trips to philadelphia and of course now she wants to go to brussels
19:16:29 <gwern> jmcarthur: karma?
19:16:35 <gwern> seems more like irony to me
19:17:05 <gwern> (to be karma she would have to have done wrong and now be suffering for it; but what's to punish about being all practical?)
19:19:37 <dolio> It is quite like a traffic jam when you're already late.
19:20:11 <dfkjjkfd> i haven't been able to access hayoo for quite a while, is it dead?
19:20:17 <gwern> that's not ironic either; that's just adding insult to injury, or rubbing salt in the wound
19:20:26 * gwern blames Morriset for debasing the term irony
19:20:47 <dolio> I saw an e-mail recently that hayoo was back online.
19:20:51 <dolio> Maybe it went off again.
19:23:46 <dfkjjkfd> without hayoo, how do you respond to an unfamiliar function that is not explicitly imported?
19:23:56 <dolio> I use hoogle.
19:24:38 <dfkjjkfd> locally?
19:24:50 <dolio> No.
19:25:27 * ddarius almost never uses Hoogle's type searching capability.
19:26:17 <copumpkin> @typo on
19:26:18 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:27:12 <soupdragon> @type off
19:27:13 <lambdabot> Not in scope: `off'
19:27:36 <copumpkin> @typo on :: (->) ((->) b ((->) b c)) ((->) ((->) a b) ((->) a ((->) a c)))
19:27:37 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:27:44 <gwern> dfkjjkfd: if I can't find it in hoogle, I run 'find' over my collection of 900 repos or so. that usually does the trick
19:28:11 <Pseudonym> @pl \op on x y -> op (f x) (f y)
19:28:11 <lambdabot> const . flip flip f . ((.) .) . (. f)
19:28:22 <Pseudonym> @pl \op f x y -> op (f x) (f y)
19:28:23 <lambdabot> join . ((flip . ((.) .)) .) . (.)
19:29:05 <Pseudonym> Nobody ever uses the W combinator any more.
19:29:31 <pikhq_> Except perhaps your mother.
19:29:33 <gwern> the cool kids have moved on to the Z combinator
19:29:36 <dfkjjkfd> gwern: ill try that
19:30:28 <glguy> :t on
19:30:28 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:30:59 <copumpkin> I prefer forall a b c. (->) ((->) b ((->) b c)) ((->) ((->) a b) ((->) a ((->) a c)))
19:31:31 <glguy> ?. djinn type on
19:31:31 <lambdabot> f a b c _ = a (b c) (b c)
19:31:45 <copumpkin> faildjinn
19:31:48 <glguy> who needs that second parameter??
19:32:02 <copumpkin> I thought djinn went to an effort to use all parameters
19:32:07 <glguy> ?. djinn type (.)
19:32:07 <lambdabot> Cannot parse command
19:32:18 <glguy> ?. djinn type (Prelude..)
19:32:19 <lambdabot> f a b c = a (b c)
19:33:38 <Pseudonym> on = B (W (B (C B))) B
19:33:51 <Pseudonym> I think.
19:36:02 <Pseudonym> No, not quite.
19:36:53 <trie> Can someone provide me an example  of a type with a class context of the form: SomeTypeClass (atypeVar SomeType AnotherType ...)
19:37:19 <trie> An example from the prelude would be nice.
19:39:51 <soupdragon> "The Mellin transform is the most popular transform in the analysis of algorithms."... yet I've never heard of it before!
19:41:21 <wli> I thought the "z transform" was the most popular transform, not the Mellin transform.
19:41:25 <Pseudonym> I've heard it, but it's news to me that it's the most popular transform.
19:42:12 <soupdragon> oh here we go:
19:42:28 <soupdragon> "in the mid 60â€™s, however, Flajoletâ€™s school systematized and applied the Mellin transform to a myriad problems of analytic combinatorics and analysis of algorithms"
19:42:48 <ddarius> wli: "for the analysis of algorithms"
19:43:05 <ddarius> soupdragon: You've probably never heard of any other transform being applied to the analysis of algorithms.
19:43:11 <soupdragon> :)
19:43:13 <soupdragon> you're right
19:44:28 <monochrom> perhaps those are combinatoric algorithms too
19:54:33 * hackagebot hfiar 2.0.1 - Four in a Row in Haskell!!  http://hackage.haskell.org/package/hfiar-2.0.1 (FernandoBenavides)
20:06:54 <ClaudiusMaximus> trie: how about:
20:06:55 <ClaudiusMaximus> foo :: (Eq (f Int), Applicative f) => f Int -> f Int -> f Bool
20:06:55 <ClaudiusMaximus> foo x y = (==) <$> x <*> y
20:11:51 <byorgey> I don't think you need the Eq (f Int) constraint there, do you?
20:12:17 <monochrom> I think it is a contrived example.
20:12:51 <monochrom> > ((==) <$> x <*> y) [1,2] [1,2]
20:12:52 <lambdabot>   Couldn't match expected type `t1 -> t'
20:12:52 <lambdabot>         against inferred type `GHC.B...
20:13:11 <ClaudiusMaximus> missing lambdas
20:13:21 <monochrom> > ((==) <$> x <*> y) [1,2] [1,2]
20:13:22 <lambdabot>   Couldn't match expected type `t1 -> t'
20:13:22 <lambdabot>         against inferred type `GHC.B...
20:13:26 <monochrom> sorry, typo
20:13:33 <monochrom> > (\x y -> (==) <$> x <*> y) [1,2] [1,2]
20:13:33 <lambdabot>   [True,False,False,True]
20:13:40 <monochrom> interesting
20:14:08 <copumpkin> why not just liftA2 (==) ?
20:14:10 <ClaudiusMaximus> :t liftA2 (==)
20:14:11 <lambdabot> forall a (f :: * -> *). (Eq a, Applicative f) => f a -> f a -> f Bool
20:14:14 <monochrom> anyway, my \ key is too close to my enter key, so the 2nd one is typo trying to \ but entering!
20:14:21 <pastorn> copumpkin: that's too easy
20:14:30 <byorgey> hehe, oops
20:14:44 <monochrom> @type liftA2 (==)
20:14:45 <lambdabot> forall a (f :: * -> *). (Eq a, Applicative f) => f a -> f a -> f Bool
20:15:16 <ClaudiusMaximus> it was contrived, i must contrive harder to find a useful example..
20:16:03 <pastorn> > liftA2 (==) "foo" "foo"
20:16:04 <lambdabot>   [True,False,False,False,True,True,False,True,True]
20:16:43 * hackagebot linkcore 0.4.1 - Combines multiple GHC Core modules into a single module  http://hackage.haskell.org/package/linkcore-0.4.1 (TimChevalier)
20:20:15 <ClaudiusMaximus> :t \x y -> (x == y, (length . Data.Foldable.toList $ x) == (0::Int))
20:20:16 <lambdabot> forall a (t :: * -> *). (Eq (t a), Data.Foldable.Foldable t) => t a -> t a -> (Bool, Bool)
20:20:57 <ClaudiusMaximus> :t \x y -> (x == y, (\l -> l + head l) (Data.Foldable.toList x) == (0::Int))
20:20:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
20:20:58 <lambdabot>       Expected type: [a]
20:20:58 <lambdabot>       Inferred type: a
20:21:11 <ClaudiusMaximus> oops
20:21:19 <ClaudiusMaximus> :t \x y -> (x == y, (\l -> length l + head l) (Data.Foldable.toList x) == (0::Int))
20:21:20 <lambdabot> forall (t :: * -> *). (Eq (t Int), Data.Foldable.Foldable t) => t Int -> t Int -> (Bool, Bool)
20:21:43 <ClaudiusMaximus> victory
20:34:25 <djahandarie> Hmm... damn monads
20:35:16 <copumpkin> why?
20:36:05 <djahandarie> They are cropping up in places I don't want them to. :(
20:41:44 <djahandarie> Say I have data A = A Int (Maybe Handle); and then I have as :: [A]. I have f :: Int -> IO Handle.  I want to   (map (something) as)  which evaluates to a new list where all the A have been filled up
20:42:42 <djahandarie> Except I'm not sure how to deal with that IO
20:44:41 <mjrosenb> djahandarie: mapM
20:45:43 <djahandarie> Hmmmm
20:54:52 <byorgey> @type mapM
20:54:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:55:08 <byorgey> so in this case  mapM f as  will have type  IO [Handle]
20:55:19 <byorgey> @src mapM
20:55:20 <lambdabot> mapM f as = sequence (map f as)
20:55:34 <byorgey> map f as will give you [IO Handle]
20:55:49 <byorgey> then sequence runs all the IO actions in sequence and returns a list of their results
20:55:52 <byorgey> @type sequence
20:55:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:56:22 <pikhq> @src sequence
20:56:22 <lambdabot> sequence []     = return []
20:56:22 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:56:22 <lambdabot> --OR
20:56:22 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:57:44 <edwardk> heya byorgey, thanks again for hosting hac-phi, it was incredible amounts of fun as always. =)
21:04:06 <pastorn> > liftA2 (*) [2,3] [5,6]
21:04:07 <lambdabot>   [10,12,15,18]
21:04:25 <pastorn> > liftM2 (*) [2,3] [5,6]
21:04:25 <lambdabot>   [10,12,15,18]
21:04:33 <pastorn> ok....
21:05:24 <byorgey> edwardk: you're welcome!  thanks for coming.  I hold you responsible for much of the fun. =)
21:06:03 <byorgey> pastorn: liftA2 and liftM2 should always be the same, for things which are instances of both Applicative and Monad.
21:14:07 <djahandarie> byorgey, that is how I was originally doing it, but my problem is that I want `something` in (map something as) to be A -> A....
21:15:07 <djahandarie> I can do [Int] -> IO [Handle], but don't know how to work in this A Int (Maybe Handle)  into the equation
21:17:14 <djahandarie> I think what I'm trying to do is just not allowed
21:17:21 <ClaudiusMaximus> somethingA (A x _) = do h <- something x ; return (A x h)  -- perhaps?
21:18:28 <djahandarie> Hmmm
21:20:56 <ClaudiusMaximus> @pl \f g h x -> g x `f` h x
21:20:56 <lambdabot> liftM2
21:28:12 <glguy> ClaudiusMaximus: the only time to use liftM2 for that function is when you are running code on lambdabot :)
21:29:30 <ClaudiusMaximus> glguy: the output surprised me
21:29:43 <glguy> Do you understand why that works?
21:31:57 <ClaudiusMaximus> glguy: not at first glance, but i could probably figure it out by staring at types for a bit
21:32:06 <glguy> OK
21:59:31 <djahandarie> I seem to be ending up with a lot of IO [()] as result of sequence [IO ()]... I really just want IO (), what would be the proper way to make that happen?
21:59:41 <c_wraith> :t sequence_
21:59:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
21:59:55 <djahandarie> Well that's nice
22:00:03 <c_wraith> :)
22:00:09 <djahandarie> :t mapM_
22:00:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
22:00:15 <djahandarie> Cool
22:00:18 <c_wraith> you've learned the secret pattern!!!
22:00:41 <djahandarie> +10 exp
22:00:42 <glguy> :t traverse_
22:00:43 <lambdabot> Not in scope: `traverse_'
22:00:50 <glguy> :t Data.Foldable.traverse_
22:00:50 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
22:02:57 <kmc> djahandarie, if m :: IO T, then (m >> return ()) :: IO ()
22:03:09 <kmc> but it'll be more efficient to use sequence_, rather than constructing a list of () and throwing it out
22:04:54 <djahandarie> Well I have [IO ()] so I need to run sequence on it already
22:05:02 <djahandarie> @src sequence_
22:05:02 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
22:05:13 <djahandarie> @src sequence
22:05:13 <lambdabot> sequence []     = return []
22:05:13 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:05:13 <lambdabot> --OR
22:05:13 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:06:18 <djahandarie> Ah I see
22:26:49 <altmattr> how can one chain calls to mkQ in data.generics?  Since the first argument is type a and the result is (b-> a) I can't work it out.
22:27:34 <altmattr> @type mkQ
22:27:35 <lambdabot> forall r b a. (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
22:27:55 <altmattr> @type (True `mkQ` (\x -> False))
22:27:56 <lambdabot>     Ambiguous type variable `b' in the constraint:
22:27:56 <lambdabot>       `Typeable b' arising from a use of `mkQ' at <interactive>:1:1-24
22:27:56 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
22:28:26 <altmattr> @type (True `mkQ` (\x::Int -> False))
22:28:27 <lambdabot>     Illegal result type signature `Int'
22:28:28 <lambdabot>       Result signatures are no longer supported in pattern matches
22:28:28 <lambdabot>     In a lambda abstraction: \ x :: Int -> False
22:28:49 <altmattr> @type (True `mkQ` (\(x::Int) -> False))
22:28:50 <lambdabot> forall a. (Typeable a) => a -> Bool
22:29:31 <altmattr> @type (True `mkQ` (\(x::Int) -> False)) `mkQ` (\(y::Float) -> True)
22:29:32 <lambdabot>     Couldn't match expected type `a -> Bool'
22:29:32 <lambdabot>            against inferred type `Bool'
22:29:32 <lambdabot>     In the expression: True
22:29:58 <altmattr> I feel like there is a clear and obvious solution, I just can't grab it
22:30:53 <ManateeLazyCat> I have many explicit argument need to transform from one function to another, i use runStateT manage argument in function body, but i still need return new state to write back to share environment, when "input argument and return new state" is too many, i'm not happy, i wonder have a advanced monad give me less pain? ReaderT is right moand?
22:31:16 <allbery_b> hm, perhaps that initial True should be (\_ -> True) ?
22:31:52 <altmattr> @type ((\_ -> True) `mkQ` (\(x::Int) -> False)) `mkQ` (\(y::Float) -> True)
22:31:53 <lambdabot>     Couldn't match expected type `t -> Bool'
22:31:53 <lambdabot>            against inferred type `Bool'
22:31:53 <lambdabot>     In the expression: False
22:33:27 <altmattr> @type (True `mkQ` (\(x::Int) -> False))
22:33:28 <lambdabot> forall a. (Typeable a) => a -> Bool
22:33:54 <altmattr> @type ((\_ -> True) `mkQ` (\(x::Int) -> False))
22:33:55 <lambdabot>     Couldn't match expected type `t -> Bool'
22:33:55 <lambdabot>            against inferred type `Bool'
22:33:55 <lambdabot>     In the expression: False
22:34:04 <m3ga> i found a haskell source file with a .hsc extention. anyone know why that is .hsc and not .hs?
22:34:29 <allbery_b> it needs to be preprocessed with hsc2hs to handle foreign definitions
22:34:42 <m3ga> allbery_b: thanks!
22:35:00 <ManateeLazyCat> m3ga: gtk2hs have many .hsc
22:35:27 <kmc> http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
22:35:52 <m3ga> so its still current technology! it uses library functions that disappeared after ghc 6.2
22:36:14 <allbery_b> hsc2hs is current, that says nothing about the rest of it :)
22:36:19 <kmc> hehe
22:36:27 <IceKiller> could anybody look over my code and see a way to optimize it?
22:36:54 <ManateeLazyCat> IceKiller: Just paste it, don't ask to ask.
22:37:09 <allbery_b> !paste
22:37:14 <allbery_b> @paste
22:37:15 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
22:37:34 <IceKiller> http://www.privatepaste.com/53593c1761
22:37:34 <allbery_b> so much for that reflex...
22:38:41 <altmattr> woah - that is a lot of code
22:39:09 <altmattr> and I am afraid those comments are unintelligible to me :(
22:39:22 <copumpkin> ohai, pls 2 fix mai code kthx
22:39:25 <ManateeLazyCat> IceKiller: Install hlint.
22:39:47 <IceKiller> i know editsD2 takes a long time cause its basicly abused editsD1
22:40:02 <copumpkin> alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
22:40:09 <copumpkin> > ['a'..'z']
22:40:11 * ManateeLazyCat pasted "hlint suggestions." at http://paste2.org/get/849891
22:40:11 <ManateeLazyCat> IceKiller: Hlint will give you many suggestions like above.
22:40:12 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
22:40:12 <Botje> length(x) == 0  better written as null x
22:40:28 <Botje> actually
22:40:34 <Botje> deleteLeeg better written as filter (not . null)
22:40:50 <Botje> pasAan: map changeWord
22:41:10 <ManateeLazyCat> IceKiller: cabal install hlint
22:41:12 <copumpkin> IceKiller: in general, it seems like you're not aware you can do deep pattern matching
22:41:12 <djahandarie> I don't know if I like String = [Char]
22:41:24 <IceKiller> i know.. i'm not that goo din haskell
22:41:39 <copumpkin> IceKiller: you can pattern match things like ([5] : xs) if you want
22:41:40 <Botje> vergelijk is already implemented as (==)
22:42:39 <djahandarie> Heh
22:44:22 <djahandarie> IceKiller, your problem is that you are nubbing everywhere, I think
22:44:49 <IceKiller> yea but i kinda need too? or would it be faster to do it without the nubbing?
22:45:07 <djahandarie> Well, think of another way to do it that doesn't involve creating duplicates
22:45:14 <IceKiller> hmm k
22:45:18 <glguy> IceKiller: You should make that changes that hlint suggested so that we can look at it and focus on the algorithmic changes
22:45:49 <IceKiller> yea need to see how i can install it in the windows version
22:46:05 <ManateeLazyCat> IceKiller: http://paste2.org/get/849891 have many suggestions by hlint.
22:46:27 <ManateeLazyCat> IceKiller: Install haskell-platform?
22:49:29 <altmattr> to answer my own data.generic question - should use extQ instead of mkQ
22:53:44 <IceKiller> ManateeLazyCat i have it installed, i mean i don't see a cabal for hlint ;)
22:53:53 <IceKiller> > ['a'... 'z']
22:53:54 <lambdabot>   Not in scope: `...'
22:54:02 <IceKiller> > ['a'..'z']
22:54:08 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
22:55:42 <Jafet> > map fromEnum [97..122] :: String
22:55:47 <ManateeLazyCat> IceKiller: If you have install haskell-platform, can you do "cabal install hlint" ?
22:55:48 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
22:55:48 <lambdabot>         against inferred type...
22:56:03 <Jafet> > map toEnum [97..122] :: String
22:56:04 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
22:56:39 <copumpkin> > map chr [97..122]
22:56:40 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
22:56:41 <ManateeLazyCat> IceKiller: You need run "cabal update" first.
23:01:05 <IceKiller> http://www.privatepaste.com/bf89b53656
23:04:03 <ManateeLazyCat> IceKiller: Please use hlint clean code first, then we can help you improve code algorithm, and not code detail.
23:04:11 <IceKiller> k
23:04:58 <ManateeLazyCat> IceKiller: Hlint can install by cabal after you install Haskell-Platform.
23:05:09 <ManateeLazyCat> IceKiller: "cabal update && cabal install hlint"
23:05:12 <IceKiller> yip install now :)
23:05:19 <IceKiller> installing
23:09:22 <dibblego> who owns lambdabot these days?
23:09:51 <pastorn> dibblego: everyone!
23:09:53 <pastorn> @botsnack
23:09:53 <lambdabot> :)
23:10:04 <dibblego> @join #functionaljava
23:10:05 <lambdabot> Not enough privileges
23:10:09 <dibblego> doesn't seem so
23:10:49 <TheHunter> @join #functionaljava
23:10:56 <dibblego> heh
23:15:51 <IceKiller> hmm what does :" Eta reduce" mean,
23:16:57 <Jafet> eta is a passive-aggressive variant of lambda reduction
23:20:14 <BMeph> IceKiller: It means, "Keep your eyes on you own paper, and finish that hlint!" >:)
23:20:15 <ClaudiusMaximus> in haskell would eta-reduction be   f x = g x   ~~>   f = g   ?
23:22:44 <Jafet> There is no Eq instance for (a -> b)
23:23:02 <Jafet> Some here may disagree
23:23:09 <Jafet> However kindly note that they are all wrong
23:24:33 <Jafet> Eta reduction in haskell is as usual, x is equivalent to (\unused -> x) anything
23:25:49 <Jafet> :t const
23:25:50 <lambdabot> forall a b. a -> b -> a
23:26:22 <jmcarthur> sometimes haskell makes me feel like a genius
23:28:20 <IceKiller> BMeph
23:28:23 <IceKiller> its hlint that gives it out :p
23:30:05 <ManateeLazyCat> jmcarthur: Sometimes haskell makes me feel like a idiot. :)
23:30:12 <djahandarie> Hm, doing (forever . sequence) should work, shouldn't it?
23:30:34 <djahandarie> (i.e., do a sequence of [IO a] forever)
23:30:35 <ManateeLazyCat> Bye all, need use ReaderT clean my code....
23:30:36 <ManateeLazyCat>  
23:30:44 <glguy> :t forever . sequence
23:30:44 <lambdabot> forall (m :: * -> *) b a. (Monad m) => [m a] -> m b
23:30:57 <glguy> It certainly does something
23:31:04 <IceKiller> http://www.privatepaste.com/c967fd5cec
23:31:05 <IceKiller> there ^^
23:31:34 <djahandarie> It seems like it doesn't do everything in the sequence, at least not all the time
23:31:39 <copumpkin> > forever . sequence $ []
23:31:40 <lambdabot>   No instance for (GHC.Show.Show (m b))
23:31:40 <lambdabot>    arising from a use of `M7422769353...
23:31:46 <copumpkin> > forever . sequence $ [] :: String
23:31:47 <lambdabot>   "*Exception: stack overflow
23:31:52 <copumpkin> :P
23:32:19 <copumpkin> I sort of doubt it does anything useful, given that type :)
23:32:21 <glguy> > forever $ sequence_ []
23:32:21 <lambdabot>   No instance for (GHC.Show.Show (m b))
23:32:22 <lambdabot>    arising from a use of `M8420770207...
23:32:33 <djahandarie> Actually it did work
23:32:35 <glguy> > forever $ sequence_ ""
23:32:35 <copumpkin> I guess it could sequence a lot of IO
23:32:35 <lambdabot>   Couldn't match expected type `m a'
23:32:35 <lambdabot>         against inferred type `GHC.Types...
23:32:37 <djahandarie> My internet was just langing hardcore
23:32:41 <djahandarie> laging rather
23:34:45 <glguy> copumpkin: (forever . sequence) [print 1, print 2]
23:34:45 <IceKiller> any hints ^^
23:34:57 <copumpkin> yeah, it makes sense now
23:35:11 <glguy> deleteLeeg = filter (not.null)
23:35:47 <djahandarie> Agh
23:35:52 <Jafet> mapM_ print $ cycle [1,2]
23:35:55 <djahandarie> It depends on the previous one to finish though
23:36:06 <glguy> changeWord = map toLower . filter isAlpha
23:37:07 <Jafet> Is icekiller still writing a spell checker despite having written the better half of an anagram generator
23:37:12 <glguy> Doesnâ€™t the Haskell Report say something about writing your programs in English so glguy knows wtf is going on?
23:37:43 <Jafet> I hear they couldn't decide to standardize on which english
23:38:01 <glguy> They should have asked me!
23:38:41 <Jafet> A better question is why that code is in some english-dutch pidgin
23:39:13 <BMeph> Erik Meijer pwns you n00bz! ;p
23:39:28 <IceKiller> :p
23:40:24 * glguy would have at least used the Ä³ ligature in his code
23:40:29 <Jafet> You should seriously fire off an email to Meijer or Peyton Jones, depending on which language you side with
23:41:48 <glguy> vervangLÄ³ï¬†
23:41:59 <IceKiller> replaceList ;p
23:42:31 <Jafet> Call it a "Haskell Upgrading Handout" (or "HUH")
23:43:53 <k23z__> is Learn You a Haskell supposed to be read before or after Real World Haskell ? or are they on the same level of learning haskell ?
23:44:32 <pastorn> k23z__: RWH is for people who know how to program
23:44:42 <k23z__> pastorn, who know how to program what ?
23:44:44 <pastorn> for LYAH you don't necesarily have to
23:44:56 <pastorn> k23z__: any language...
23:47:38 <IceKiller> http://www.privatepaste.com/ce281baf46 better guys? ^^
23:48:31 <copumpkin> 		| compare x y = removeFromList x ys
23:48:33 <copumpkin> how does that work?
23:48:42 <glguy> it works by not compiling
23:48:46 <copumpkin> ;)
23:48:53 <copumpkin> anyway, removeFromList is also in the standard library
23:49:06 <copumpkin> :t delete
23:49:07 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
23:49:15 <glguy> delete only deletes one
23:49:21 <copumpkin> \\ then?
23:49:31 <IceKiller> yea :p
23:49:31 <glguy> \\ only deletes one per entry
23:49:34 <copumpkin> ugh
23:49:40 <IceKiller> need to replace stuff that also exists in haskell itself
23:49:46 <copumpkin> why?
23:49:54 <glguy> > [1,1] \\ [1]
23:49:54 <lambdabot>   [1]
23:50:00 <glguy> delete 1 [1,1]
23:50:02 <glguy> > delete 1 [1,1]
23:50:03 <lambdabot>   [1]
23:50:04 <Jafet> Dutch, sounds like homework
23:50:06 <copumpkin> lame!
23:50:18 <Jafet> You only asked to delete one!
23:50:30 <glguy> hurray!
23:52:16 <IceKiller> http://www.privatepaste.com/bc9e08c714
23:52:26 <IceKiller> copumpkin ;-)
23:52:46 <glguy> IceKiller: your removeList looks like:
23:53:17 <copumpkin> train wrds = M.fromListWith (+) (zip wrds (replicate (length wrds) 1))
23:53:23 <glguy> > let f xs = [a ++ b | (a,_:b) <- zip (inits xs) (tails xs)] in f "test"
23:53:23 <lambdabot>   ["est","tst","tet","tes"]
23:53:28 <copumpkin> you don't need a replicate there, and that unnecessarily traverses the list twice
23:53:39 <copumpkin> map (,1) words
23:53:44 <copumpkin> if you're in ghc 6.12 and have tuple sections
23:54:23 <k23z__> pastorn, and what exactly do you understand by "know how to program" , I mean, does he also know how to write threaded code before reading RWH ? does he have to know how to write parsers in a different language before RWH ... what kind of things does he have to know ?
23:54:24 <glguy> IceKiller: generally if youâ€™re calling â€œlengthâ€ youâ€™re doinâ€™ it wrong
23:54:38 <k23z__> pastorn, does he have to know all the stuff explained in RWH in another language to understand it ?
23:54:40 <copumpkin> 		| length(cList xs y) > 0 = cList xs y
23:54:44 <copumpkin> another :)
23:55:09 <IceKiller> hlint said replicate
23:55:12 <copumpkin> IceKiller: lists are singly linked lists... they are good for some things and bad for others :)
23:55:20 <IceKiller> hehe ^^
23:55:35 <IceKiller> train wrds = M.fromListWith (+) (zip wrds (take (length wrds) (repeat 1))) was original
23:55:47 <copumpkin> oh, well yeah
23:55:54 <rtq> Question - isbthere
23:55:55 <glguy> IceKiller: right, replicate n 1 is better than take n (repeat 1)
23:55:59 <pastorn> k23z__: you might have to had some experience before reading it, that's all i'm saying
23:56:08 <glguy> IceKiller: that doesn't say anything about length
23:56:17 <pastorn> maybe having written a simple java swing app or whatever
23:56:25 <glguy> map (const 1)   is better still
23:56:39 <glguy> it doesn't have to traverse the list to start producing
23:56:47 <IceKiller> hm so replace take (length wrds) (repeat 1)) with map (const 1) ?
23:56:49 <pastorn> so you've seen different parts of programming (datastructures, doing IO, maybe a parser or two)
23:56:49 <rtq> Is there a way to invoke impure IO code from a pure function?
23:56:52 <BMeph> Almost as bad as if (some_condition) == True then... ;p
23:57:01 <copumpkin> IceKiller: map (,1) wrds :P
23:57:12 <glguy> copumpkin: (,1), eh?
23:57:22 <glguy> when did we get those
23:57:22 <IceKiller> train wrds = map (,1) wrds really that would work?
23:57:22 <IceKiller> :p
23:57:26 <copumpkin> glguy: in 6.12!
23:57:35 <copumpkin> TupleSections :)
23:57:36 <ClaudiusMaximus> > [1,2,3] `zip` repeat 1
23:57:36 <lambdabot>   [(1,1),(2,1),(3,1)]
23:57:43 <copumpkin> I wonder if lambdabot is up to date
23:57:46 <copumpkin> > (,5) 3
23:57:47 <lambdabot>   <no location info>: parse error on input `5'
23:57:49 <copumpkin> ugh
23:57:56 <glguy> <interactive>:1:0: Illegal tuple section: use -XTupleSections
23:58:09 <copumpkin> Cale: we can haz tuple sections kthx? :)
23:58:23 <copumpkin> glguy: they're super flexible too
23:58:35 <copumpkin> you can write (,6,,,True,"zomg",,3,,)
23:58:41 <copumpkin> and it'll give you a massive function
23:58:41 <IceKiller> Illegal tuple section: use -XTupleSections hmm
23:58:42 <Jafet> rtq, that would be simonSaysPerformIO
23:59:18 <glguy> rtq: would â€œtraceâ€ be sufficient, or do you need the full destructive power of â€œunsafePerformIOâ€?
23:59:21 <glguy> :t trace
23:59:22 <lambdabot> Not in scope: `trace'
23:59:26 <glguy> :t Debug.Trace.trace
23:59:27 <lambdabot> forall a. String -> a -> a
23:59:29 <rtq> Jafet, interesting
23:59:48 <Jafet> @quote simonSays
23:59:48 <lambdabot> lilac says: ponders whether unsafePerformIO would be better as simonSaysPerformIO
