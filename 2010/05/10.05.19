00:01:01 <Gracenotes> in this case, resorting to exceptions is somewhat like giving up needlessly
00:02:16 <Silvah> Then simply catch the exception and make your function return Maybe instead.
00:03:13 <falbani> copumpkin: many thanks
00:03:34 <copumpkin> falbani: if it's a haskell/math question maybe we can help though?
00:04:02 <Gracenotes> that's also giving up! but, yes, it's what I'm doing. Exception catching is messy and inexact still.
00:04:35 <copumpkin> are there any plans to make alex support unicode?
00:04:50 <falbani> copumpkin: It's about an article about Negative probabilities and QM... I need to ask him about particular things he wrote... I don't think you can help me... but I really appreciate your offer... thanks!
00:05:01 <Silvah> Workdarounds for poor API design are surprisingly common...
00:05:31 <copumpkin> @ask JaffaCake are there any plans to make alex support unicode input directly?
00:05:32 <lambdabot> Consider it noted.
00:05:47 <Silvah> workarounds*
00:12:18 <Silvah> It's rather a shame that documentation of alex is so poor... I read it and I still don't know anything. Are there any tutorial about alex or something?
00:13:00 <copumpkin> it's pretty similar to (f)lex
00:18:21 <Gracenotes> "can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)" ... oh mai
00:18:40 <Gracenotes> it's a wonder my system is still running without pthread!
00:20:55 <Gracenotes> like most linker issues, ghc --make seems to make it go away..
00:21:02 <Gracenotes> *linking
00:39:48 <ramb0> Hey
00:40:11 <kmc> hi
00:40:37 <silver> hey
00:42:18 <ramb0> hi
00:42:22 <copumpkin> be vewwy quiet
00:42:30 <copumpkin> I'm hunting bunny wabbitz
00:42:32 <ramb0> i don't remember my password for my user :(
00:42:50 <copumpkin> no chanserv 4 u!
00:42:57 <ramb0> :(
00:43:07 <ramb0> what can I do?
00:43:53 <copumpkin> talk to someone in #freenode
00:43:58 <copumpkin> I'm sure they can sort you out :)
00:44:18 <ramb0> thanks :)
00:44:25 <DigitalKiwi> nickserv > chanserv
00:44:54 <ramb0> I don't know much about irc :$
00:45:10 <Gracenotes> @vixen What is ramb0's password?
00:45:10 <lambdabot> whoa whoa whoa, one question at a time!
00:45:21 <Gracenotes> uh.
00:45:26 <ramb0> almost
00:45:39 <DigitalKiwi> @faq can haskelll guess ramb0's password?
00:45:40 <lambdabot> The answer is: Yes! Haskell can do that.
01:05:34 <JaffaCake> copumpkin: re Alex & Unicode, Jean-Philippe Bernardy was working on it and had it working to some extent, but I haven't heard anything for a while
01:05:35 <lambdabot> JaffaCake: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:05:45 <copumpkin> aha
01:06:08 <JaffaCake> copumpkin: I gave him some feedback on the first round of patches
01:06:36 <JaffaCake> the approach was to lex UTF-8, basically
01:06:42 <copumpkin> I see
01:06:58 <JaffaCake> expand Unicode characters and ranges in the grammar to UTF-8 automatically
01:07:44 <Kaidelong> I'm still trying to wrap my head around the fact that blogger managed to design such an awful WYSIWYG
01:08:06 <djahandarie> Is there a non-stop-the-world garbage collector in the works for ghc 6.14?
01:10:14 <JaffaCake> djahandarie: not sure about 6.14, but it's in the works yes
01:10:29 <JaffaCake> turned out to be a bit more tricky than I thought :)
01:10:46 <djahandarie> Oh, hi there, heh
01:11:14 <djahandarie> JaffaCake, are there any notes or such about its progress?
01:11:27 <JaffaCake> not really
01:11:44 <JaffaCake> I have notes of course, but nothing published
01:12:13 <JaffaCake> first priority when it's working will be to write a paper
01:12:21 <JaffaCake> do lots of measurements etc.
01:14:18 <djahandarie> Cool, I'll be on the lookout for that.
01:39:58 <ivanm> anyone know who this is? http://www.reddit.com/r/programming/comments/c5dby/leksah_08_haskell_ide/c0q8yzv
01:40:21 <ivanm> mpiechotka: did that patch for haskell-updater end up doing what you wanted?
01:43:43 <copumpkin> so much boilerplate
01:43:59 <ivanm> hey copumpkin
01:44:01 <copumpkin> maybe I should scrap it
01:44:02 <copumpkin> allo
01:44:04 <ivanm> what boilerplate?
01:44:19 <copumpkin> writing a token parser and pulling out the fields from gentokenparser
01:45:56 <copumpkin> for my pet language
01:48:04 <ivanm> what kind of pet is it?
01:48:14 <ivanm> something cute or a viscious killer that you think is cute?
01:48:15 <ivanm> :p
01:48:31 <copumpkin> something cute :P
01:48:36 <copumpkin> ;)
01:49:12 <quicksilver> copumpkin: obsessing over the best way to scrap boilerplate can seriously impede making interesting progress, you know ;)
01:49:29 <copumpkin> I'm just writing it out by hand for now
01:49:31 <copumpkin> but it's annoying!
01:49:35 <quicksilver> copumpkin: a quick editor macro / search and replace and move on to the important work.
01:49:37 <siracusa> Can I make darcs tell me what patches I have to remove from the repo so that applying a new patch will not cause any conflicts?
01:49:42 <copumpkin> I want a record wildcard at the top level
01:49:49 <copumpkin> case lexer of TokenParser{..} ->
01:49:51 <copumpkin> :P
01:51:48 <ivanm> siracusa: well, you can find which patches affect a certain file...
01:51:50 <ivanm> but that's about it
01:52:17 <cads> copumpkin: there's a particular rule of threes that states this - the first time you do something just get it done even if you have to do it slowly by hand. The second time see if you can factor out some repition. The third time - and this sounds suspiciously like something from the ruby community- make a framework :)
01:52:44 <siracusa> ivanm: That would help, how do I do that?
01:53:12 <ivanm> siracusa: darcs changes Foo --max-count=50 (--max-count is optional)
01:53:38 <siracusa> Thanks
01:53:43 <copumpkin> cads: hah
01:54:36 <cads> I think this way you neither get stuck writing boilerplate in the long term, nor do you do that whole non-starting
01:54:51 <copumpkin> I'll fix the boilerplate if it ends up getting in the way
01:54:52 <cads> 'paralylsis my analysis bit'
01:54:55 <copumpkin> right now a regex replace did fine
01:55:11 <cads> you are in the second stage alredy :D
01:57:32 <kmc> Robin Milner: still dead
01:58:18 <ivanm> kmc: well, yeah, very few people recover from death...
02:00:05 <rizlah> cads, from what you said above, do you mean to say that the majority of the time people get stuck trying to structure a program, and that they should just write it out and make it work, then structure it?
02:02:40 <cads> well this works with any repetitive task, where the "framework" bit is actually a well thought out method that you develop only after having spent enough time slogging through the problem the obvious way that you know how to improve things
02:03:55 <rizlah> I couldn't agree more with that. I've been spending too much time trying to get the thread pool section of some C code 'perfect', so to speak. Not much interesting progress there. I thought I was a bit OCD
02:04:11 <rizlah> Good to know its a common issue
02:04:34 <cads> and I'm not sure the average person will get stuck trying to analyze a better way from the beginning - more likely they'll slog through it ineffciently each time
02:07:40 <cads> well, some of us are lazy and perfectionistic at the same time which really kills productivity. But it feels freeing to let go of perfectionism at least in the initial stages of a project, since that lets you learn things through simple repitition
02:07:41 <ivanm> in a .cabal file, what does the "extra-libraries" line refer to? C libraries?
02:09:53 <Baughn> Yes
02:11:41 <Silvah> @localtime Silvah
02:12:00 <ivanm> :o
02:12:10 <ivanm> his client must hate CTCP...
02:17:38 <Silvah> @localtime Silvah
02:18:05 <Botje> Silvah: you could also look at a clock near you, of course ;)
02:18:40 <Silvah> I could if I had any ;)
02:18:56 <tensorpudding> Your computer doesn't have a clock?
02:19:01 <ivanm> Silvah: if you're using a *nix-based OS, just run the date command
02:19:23 <Botje> /exec date # ftw
02:19:25 <kmc> go to whattimeisit.com
02:21:38 <Silvah> It has, though I've hidden the clock and now I don't know how to make it visible again.
02:29:28 <Botje> what OS are you on?
02:31:49 <Lutoma> hmm
02:32:03 <Lutoma> <ksf> das modell is von #haskell abgeguckt, dem nettesten channel in allen IRC-netzen.
02:32:03 <Lutoma> soso.
02:32:27 <copumpkin> #haskell.de ?
02:32:46 <ksf> #piratenpartei
02:33:58 <Valodim> #piratenpartei? war da kurz vor der Wahl mal drin, das war reine #polemik :|
02:48:06 <ivanm> jao: are you the guy responsible for the wireless plugin in xmobar?
02:53:26 <Silvah> Silence here? Impossible...
02:53:55 <ivanm> @. elite protontorpedo
02:53:56 <lambdabot> 7|-|E tHiNgz I d0tN g3+ ABOu7 R3L4tIn41 dAT48453$ Is +h4T tHeY +Ax3 wR0k 7O m4In7AIN
02:54:08 <kmc> @nixon
02:54:09 <lambdabot> It is necessary for me to establish a winner image. Therefore, I have to beat somebody.
02:54:13 <kmc> @nixon
02:54:13 <lambdabot> Once you get into this great stream of history, you can't get out.
03:08:53 <mreh> Could not deduce (random-1.0.0.1:System.Random.RandomGen g)
03:08:53 <mreh>       from the context (RandomGen g)
03:09:27 <mreh> this seems symptomatic of conflicting versions of Random install, but I've hidden every version apart from 1.0.0.1
03:09:37 <mreh> s/install/installed
03:09:59 <mreh> do I need to rebuild something else? I've tried to re-build everything I know that uses random
03:10:01 <quicksilver> mreh: diamond dependency I imagine
03:10:12 <quicksilver> you're using at least one lib that depends on the 'wrong' random.
03:10:26 <mreh> this is why cabal is good
03:11:17 <mreh> cabal install --reinstall would be sufficient, non?
03:14:47 <mreh> cabal configure just tells you right off the bat what's conflicting
03:16:20 <mreh> Yampa makes no restriction as to the version of random it wants, but cabla insists it needs 1.0.0.2
03:16:41 <mreh> and it doesn't have any other dependencies
03:17:19 <quicksilver> mreh: I think random is one of the packages you can't upgrade because it's tied to GHC
03:17:24 <quicksilver> but I may well be wrong.
03:17:32 <kmc> @nixon
03:17:32 <lambdabot> Always remember that others may hate you but those who hate you don't win unless you hate them. And then you destroy yourself.
03:17:34 <mreh> quicksilver, you can, but it ruin everything
03:25:11 <Silvah> :t flip
03:25:12 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
03:25:25 <Silvah> :t Prelude.flip
03:25:26 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
03:26:21 <quicksilver> mreh: Right. By "can't" I meant "can't without runing everything"
03:26:36 <Silvah> :t flip flip
03:26:37 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
03:26:55 <Silvah> :t flip Prelude.flip
03:26:56 <lambdabot> forall a a1 c. a1 -> (a -> a1 -> c) -> a -> c
03:27:52 <Silvah> :t flip flip Prelude.flip
03:27:53 <lambdabot> forall (f :: * -> *) b a b1 c. (Functor f) => f (((a -> b1 -> c) -> b1 -> a -> c) -> b) -> f b
03:28:11 <Silvah> :t flip Prelude.flip Prelude.flip
03:28:12 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
03:29:18 <Silvah> :t flip Prelude.flip Prelude.flip Prelude.flip
03:29:19 <mreh> I've just destroyed my package library
03:29:19 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
03:29:21 * rizlah dies from all the haskell syntax
03:29:56 <mreh> including haskell98 1.0.1.0
03:29:59 <Silvah> .oO
03:32:03 <mreh> can I re-register packages once broken?
03:35:07 <mreh> I need to fix these core libraries and everyone tells me I cant
03:37:32 <Silvah> You can fix them... if reinstalling GHC counts as "fix".
03:38:10 <mreh> Silvah: unacceptable :)
03:38:27 <ivanm> mreh: you can but it's a PITA to do it properly
03:41:15 <mreh> ivanm: lesson learned
04:17:09 <Taejo> sigfpe calls Identity the trivial monad -- but what about "data Z a = Z"?
04:17:28 <quicksilver> Taejo: not a monad.
04:17:37 <Taejo> isn't it?
04:17:41 <quicksilver> indeed not.
04:18:20 <quicksilver> violates return a >>= f === f a, doesn't it?
04:18:56 <Taejo> aren't both sides equal to Z?
04:19:00 * quicksilver is suddenly not so sure.
04:19:47 <Taejo> aren't all the monad laws equations on values of type (m a)?
04:19:57 <Taejo> and all values of type (Z a) are equal
04:20:02 <Taejo> so all equations hold
04:20:20 <xerox> return a >>= f  =  f a
04:20:26 <xerox> m >>= return  =  m
04:20:42 <xerox> (m >>= f) >>= g  =  m >>= (\x -> f x >>= g)
04:20:51 <Botje> what if a is undef?
04:21:16 <Botje> oh, wait
04:21:19 <quicksilver> return (undefined) is still Z ;)
04:21:29 <quicksilver> Taejo: I think you're right. Sorry for initial wrong answer.
04:21:35 <Taejo> no problem?
04:21:40 <Taejo> s/?/.
04:22:09 <Botje> the only a that can be passed through >>= is undef
04:22:13 <Botje> soo ..
04:22:20 <Botje> return 3 >>= f vs f 3
04:22:26 <Botje> in the first case, f will be called with undef
04:22:58 <quicksilver> but the only possible value remains Z
04:23:22 <Botje> but what if f is strict?
04:23:37 <quicksilver> you have to ignore such things otherwise no laws work :)
04:23:39 <Botje> then it does make a difference
04:23:58 <Botje> i was under the impression the laws had to work for all possible inputs :P
04:25:40 <Taejo> m >>= f == join (fmap f m) == const Z (fmap f m)
04:26:05 <Taejo> so the strictness of f doesn't matter, only the non-strictness of const
04:26:13 <Botje> oh.
04:26:20 <Botje> that's cheating! ;)
04:27:00 <Taejo> well you can define m >>= f = Z straight off, if you prefer
04:27:15 <Taejo> but I prefer to think of fmap, join and return
04:27:32 <Botje> fair enough..
04:27:40 * Botje gets back to something less interesting
04:29:07 * Taejo is tempted to say something like Identity is initial and Z is final, but doesn't know what a morphism of monads looks like
04:30:07 <dolio> Z only works if you don't worry about bottom.
04:30:24 <dolio> Otherwise you need just 'data Z a'.
04:30:56 <quicksilver> but the >>= rules are almost never true if worry about bottom
04:30:56 <Taejo> don't most monads have a similar problem in Haskell? But you are right that in this case it can be fixed
04:31:08 <quicksilver> because of the difference between _|_ and \_ -> _|_
04:31:37 <quicksilver> roughly speaking, equational identities involving functions always trip over that.
04:32:16 <dolio> Well, in this case, it's due to: return a >>= \_ -> undefined = Z /= undefined
04:32:53 <quicksilver> Taejo: a morphism between monads is a natural transformation between the functors, preserving the laws?
04:33:24 <Taejo> I guess it's that simple
04:33:40 <quicksilver> noting that in haskell polymorphic functions are inherently natural
04:33:45 <quicksilver> you just have to worry about the laws.
04:33:47 <jkramer> Hi
04:34:11 <quicksilver> which boils down to preserving return and (>>) I suppose.
04:34:19 <Silvah> Hi.
04:34:46 <quicksilver> Taejo: so, there is a map *from* Identity a to any monad (m a) which takes "Identity a" to "return a"
04:35:08 <quicksilver> Taejo: and there is a map *to* Z a from any monad (m a) which takes all values to Z
04:35:17 <quicksilver> Taejo: so your intuition was right. Identity is initial and Z is final.
04:35:18 <Taejo> yes
04:35:35 <quicksilver> (I didn't prove those maps were unique, but they kind of obviously are)
04:36:12 <quicksilver> Taejo++ # theorem before lunch on a wednesday
04:38:31 <Rectal> HEy IVanm you there?
04:39:03 <Rectal> Or any other ANU tutors?
04:39:36 <bremner> heh. Welcome to the internet, support system for ANU students
04:40:03 <dolio> That's what I signed on for.
04:40:42 <Rectal> Sorry :D
04:40:54 <Rectal> Just wanted to know how to use SSH
04:41:23 <Rectal> To submit my assignment, it takes a password, before it asks for any login ID
04:42:08 <Rectal> nvm got it
04:42:19 <dolio> If your sshing from a unix, at least, I think it automatically uses whatever username you're logged in as unless you tell it otherwise.
04:42:22 <Rectal> Idiot should have looked up commands first before being retarded
04:43:15 <Rectal> Does Haskell written in a windows system also compile when in a Linux system?
04:43:27 <dolio> Depends.
04:43:33 <Silvah> It depends.
04:43:40 <Rectal> On what?
04:43:43 <Rectal> Libraries used?
04:43:45 <quicksilver> normally, yes, Rectal
04:43:52 <quicksilver> but not if you use some windows-specific stuff.
04:43:54 <dolio> Yes, libraries.
04:44:02 <Rectal> If it has no libraries, will it be fine?
04:44:06 <quicksilver> yes.
04:44:10 <Rectal> Thank you
04:44:32 <Rectal> I am glad we learn't haskell in first year, cause I never would have looked at it otherwise
04:44:32 <dolio> If it's a homework assignment, I wouldn't anticipate any problems.
04:44:56 <Rectal> I am not if I like Haskell though.... Its good, but not easymode like C
04:45:24 <Rectal> I mean, I can do lots of stuff with C, not effectively, or coherently, I hear Haskell is much faster and better in every way
04:45:38 <Rectal> Just depends who you ask I guess
04:46:04 <dolio> Faster?
04:46:07 <bremner> and whether your definition of "do stuff" includes lots of random crashes
04:46:40 <Silvah> Faster.
04:46:44 <dolio> Faster to write, perhaps. Getting Haskell programs to outperform C can be quite difficult.
04:46:50 <Silvah> Haskell often actually outperforms C.
04:47:26 <quicksilver> s/often/occasionally/ ;)
04:47:52 <dolio> I guess I have one. Last I checked, some of my sorting stuff outperforms C's standard sort. But that's probably because I use better algorithms.
04:48:04 <FliPPeh> I wonder, can you create unary operators in Haskell?
04:48:11 <Silvah> It depends on what you're writing.
04:48:15 <quicksilver> yes, we call them functions, FliPPeh ;)
04:48:24 <quicksilver> > let f x = x + 1 in f 4
04:48:25 <lambdabot>   5
04:48:26 <FliPPeh> quicksilver: Something like "i++" i mean
04:48:29 <quicksilver> f is a unary operator.
04:48:30 <dolio> FliPPeh: GHC has an extension for unary postfix operators, but it's kind of unsatisfying.
04:48:32 <FliPPeh> Basically without the updating part
04:48:45 <dolio> > let (!) n = product [1..n] in (5!)
04:48:45 <lambdabot>   120
04:48:50 <bremner> > 1 (+1)
04:48:50 <FliPPeh> Just a shorthand without writing (i+1)
04:48:50 <lambdabot>   Ambiguous type variable `a' in the constraint:
04:48:51 <lambdabot>    `GHC.Num.Num a' arising f...
04:48:54 <FliPPeh> But (i++) :)
04:49:05 <FliPPeh> 'succ i' just doesn't look as cool
04:49:05 <quicksilver> FliPPeh: you're right, that is much shorter.
04:49:14 <Rectal> Guh, worst part of coding is checking the comments for errors imo
04:49:32 <FliPPeh> Double tapping a key is better than pressing the '+' and all the way over to '1' again!
04:49:33 <quicksilver> > (length "(i+1)", length "(i++)")
04:49:34 <lambdabot>   (5,5)
04:49:37 <FliPPeh> That's wasted lifetime!!!
04:49:41 <dolio> Well, just write types and then the compiler will check them for you. :)
04:49:57 <quicksilver> FliPPeh: the short answer is no. Haskell makes a simple lexical distinciton.
04:49:59 <luite> Rectal: that's why most packages on hackage don't have comments at all
04:50:02 <quicksilver> alphanumeric = prefix
04:50:05 <quicksilver> symbolic = infix
04:50:12 <FliPPeh> k
04:50:19 <FliPPeh> Could have been fun :)
04:51:48 <Silvah> quicksilver: often, and sometimes even by an order of magnitude.
04:52:16 <dolio> FliPPeh: Switch to Agda!
04:52:26 <dolio> You can have operators of arbitrary fixity.
04:52:27 <FliPPeh> Don't know that one :)
04:52:41 <dolio> You can define if_then_else_ as a normal definition.
04:53:02 <Rectal> If I have modules, they will still compile fine in Linux when written on a windows based computer?
04:53:44 <FliPPeh> > let c ? (y,n) = if c then y else n in sqrt (25) == 5 ? ("Yes!", "Nay!")
04:53:45 <lambdabot>   No instance for (GHC.Float.Floating [GHC.Types.Char])
04:53:46 <lambdabot>    arising from a use...
04:53:47 <FliPPeh> :(
04:53:57 <FliPPeh> > let c ? (y,n) = if c then y else n in 5*5 == 25 ? ("Yes!", "Nay!")
04:53:58 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
04:53:58 <lambdabot>    arising from the literal ...
04:54:03 <FliPPeh> I hate you
04:54:04 <quicksilver> Silvah: with respect, you don't know what you're talking about.
04:54:15 <FliPPeh> > let c ? (y,n) = if c then y else n in (5*5 == 25) ? ("Yes!", "Nay!")
04:54:16 <lambdabot>   "Yes!"
04:54:57 <Silvah> I know...
04:56:27 <Silvah> Strict semantics is not good for some problems, in C you have no choice unless you'll emulate it manually.
04:56:52 <Silvah> By 'it' I mean non-strict semantics, of course.
04:58:35 <Kaidelong> > let c ? (y,n) = if c then y else n in (sqrt(5*5) == 5) ? ("Yes!", "Nay!")
04:58:36 <lambdabot>   "Yes!"
04:58:45 <Kaidelong> parenthesis solve everything
04:58:48 <Kaidelong> apparently
04:59:14 <Silvah> I really saw a situation where Haskell code was ca. 5 times faster than C code.
04:59:15 <Kaidelong> that's so much nicer than a ternary operator IMO
05:00:06 <Kaidelong> silvah: you could probably write the C code to match or do better. Not always the case vice versa, but the payoff is worth it, right?
05:00:50 <quicksilver> Silvah: the occasional interesting case is not "often", though.
05:01:10 <Kaidelong> flippeh: if you could set ? to have a lower precedence than , you could get some really interesting syntax
05:01:10 <Rectal> I am sad now, I just had an infinite loop of y's appearing on my screen
05:01:13 <Rectal> silly Cygwin
05:01:35 <Kaidelong> p ? x,
05:01:38 <Kaidelong> q ? y,
05:01:42 <Kaidelong> z
05:02:11 <Kaidelong> oh whoops, no, that would not work
05:02:22 <Kaidelong> but it'd be so cool if it did
05:03:23 <quicksilver> has anyone looked at hashimoto's "has" package?
05:03:26 <Silvah> It's not occasional, at least not for me.
05:03:45 <quicksilver> it looks intriguing but I have a feeling it must be a bit evil since it uses overlapping instances.
05:03:57 <Kaidelong> Silvah: working at a higher level of abstraction helps programmers most of the time IIRC. They did studies on it or something
05:04:36 <Kaidelong> but in theory a really good superhuman programmer would just do everything in machine code
05:05:26 <Kaidelong> since they'd effectively be better than any compiler
05:05:29 <Rectal> So if I have other haskell files copiled on Linux and use haskell files written on Windows, will they compile on a linux computer
05:05:41 <quicksilver> Rectal: Yes.
05:05:45 <Rectal> Thank you
05:05:53 <Rectal> Just gotta figure this SSH thing now to submit it
05:06:15 <Kaidelong> Rectal: provided you aren't doing anything strange with libraries that don't work on linux, which will be FFI libraries
05:06:26 <Kaidelong> and not standard ones
05:08:10 <dolio> quicksilver: Doesn't look like you could eliminate the overlapping instances without a lot of work.
05:08:51 <quicksilver> dolio: well, the quicksilver prejudice scale suggests this must be a design flaw ;)
05:09:02 <quicksilver> dolio: perhaps I should look at it to form a better opinion though.
05:09:08 <dolio> It gets used for Contains y (x ::: y ::: z ::: ...)
05:09:58 <quicksilver> could you resolve that by using a wrapper like 'Atomic' to indicate where you want the search to stop?
05:10:01 <dolio> instance Contains e (e ::: _) ... ; instance Contains e r => Contains e (h ::: r) ...
05:10:28 <quicksilver> hmm. That is a nasty one.
05:10:44 <Rectal> What is the best way to transfer files over SSH?
05:10:49 <quicksilver> does GHC event get that right?
05:10:56 <dolio> No idea.
05:11:01 <quicksilver> I'd have thought GHC could easily choose the wrong search path there.
05:11:11 <quicksilver> type class resolution doesn't backtrack.
05:12:03 <djahandarie> Rectal, scp
05:12:13 <djahandarie> Rectal, check out winscp
05:15:40 <Athas> Anyone got a wrapper for Xutf8LookupString?
05:16:12 <Rectal> Thanks dj, works a treat
05:16:24 <Rectal> only 20 b/s, luckily its only a couple source files
05:22:18 <quicksilver> dolio: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=25589#a25589
05:22:29 <quicksilver> dolio: as far as I can see, that overlapping scheme fails (as I'd expect it to)
05:22:39 <quicksilver> GHC goes down the wrong path, and since that fails, it gives up.
05:24:55 <dolio> Oh, does it choose the second instance whenever r is part of a Contains instance?
05:25:41 <quicksilver> no, instance heads are ignored in instance selection.
05:25:41 <portnov> @pl \l x -> l >>= \x-> replicateM x get
05:25:42 <lambdabot> const . (flip replicateM get =<<)
05:25:59 <quicksilver> erm is head the right word?
05:26:14 <dolio> How does it choose between them, then? They're almost identical.
05:26:15 <quicksilver> instance head *contexts* are ignored in the selection process.
05:26:22 <quicksilver> dolio: arbitrarily as far as I know
05:26:23 <Kaidelong> @pl \unknown -> foldl' (+) 0 . map (abs . uncurry(flip (-))) . zip unknown . fst
05:26:23 <lambdabot> ((foldl' (+) 0 . map (abs . uncurry subtract)) .) . (. fst) . zip
05:26:39 <quicksilver> dolio: it prefers the ones who match more concrete type constructors
05:26:44 <portnov> ?quote flip
05:26:45 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
05:26:57 <quicksilver> dolio: since in this case they both match the same number of concrete type constructors (the ::: alone)
05:27:10 <quicksilver> dolio: then I think it's probably entirely arbitrary.
05:27:17 <dolio> Yeah, but I'm pretty sure it complains if you have instances that are identical by that criterion.
05:27:32 <dolio> So it has something that it's using to make the choice.
05:27:42 <quicksilver> I'm sure I've been told it's not the context.
05:27:44 <Kaidelong> @unpl ((foldl' (+) 0 . map (abs . uncurry subtract)) .) . (. fst) . zip
05:27:44 <lambdabot> (\ e q -> foldl' (+) 0 (map (\ k -> abs (uncurry subtract k)) (zip e (fst q))))
05:27:58 <quicksilver> I could be wrong in my memory or the person who told me that could have been wrong ;)
05:28:00 <Rectal> Night guize
05:28:07 <Taejo> what is the best package for simple iteratee-based I/O?
05:28:20 <Kaidelong> I think my version is the nicest of those three really
05:28:52 <Kaidelong> although the unpl version is definitely more understandable than ".) . (."
05:29:21 <dolio> quicksilver: If I have a class and try 'instance Foo [a] ; instance Foo [b]' it complains for instance.
05:29:36 <dolio> So the e appearing in both circumvents that.
05:29:52 <dolio> But I don't understand why that'd be the more general instance.
05:30:07 <dolio> Anyhow, I'm not too surprised that it doesn't work.
05:30:08 <mreh> is yampa-users@cs.yale.edu defunct? I can communicate with the mailing list server, haven't seen my message delivered yet
05:30:23 <mreh> man, the history shows nothing sent since 2008
05:30:36 <quicksilver> dolio: I keep meanign to post a rant to haskell-cafe on what type class resolution *isn't*
05:30:45 <quicksilver> dolio: and this does seem like a good example of what it isn't.
05:31:12 <dolio> I thought the algorithm for overlapping instances actually took the context into account.
05:31:16 <dolio> But perhaps I'm wrong.
05:31:22 <quicksilver> dolio: with the hope that some clarity might emerge which might go onto a web page.
05:32:52 <quicksilver> dolio: "Suppose an instance declaration does not match the constraint being looked up, but does unify with it, so that it might match when the constraint is further instantiated. Usually GHC will regard this as a reason for not committing to some other constraint. But if the instance declaration was compiled with -XIncoherentInstances, GHC will skip the "does-it-unify?" check for that declaration"
05:32:59 <quicksilver> I'm not sure that make it clearer.
05:33:30 <quicksilver> (from the fine manual)
05:33:57 <xerox> (which shall be read)
05:34:12 <cozachk> uhhh on ubuntu how would i get ghci to load module files from the local directory? i tried adding :./ and :/. to my $PATH but that doesnt seem to work :(
05:35:11 <quicksilver> cozachk: by doing nothing.
05:35:20 <quicksilver> cozachk: ghci always loads module files from the current directory.
05:35:26 <dolio> quicksilver: I guess I'm wrong. I tried "instance Foo [a] ; instance Foo b => Foo [b]" and that still gets pegged as duplicate.
05:35:50 <quicksilver> cozachk: it follows a naming convention to find them, so import Foo.Bar; will look in Foo/Bar.hs
05:35:58 <Botje> cozachk: you can load modules with "m
05:36:00 <Botje> :m
05:36:16 <quicksilver> Botje: actually :m just changes the current context (scope), it doesn't load anything.
05:36:19 <quicksilver> Botje: :l loads.
05:36:32 <quicksilver> ":m Data.List" <- bring Data.List into scope, it was already loaded, though.
05:36:53 <Botje> okay
05:37:46 <cozachk> only one module per file right?
05:38:38 <quicksilver> yes.
05:40:35 <McManiaC> whats the easiest way/lib to draw something?
05:40:47 <McManiaC> or which lib would you recommand?
05:40:49 <Silvah> Well, okay, let's pretend that I was horribly wrong.
05:40:57 <McManiaC> a full gui lib?
05:41:35 <cozachk> McManiaC, try gloss and gloss-examples you can cabal install them
05:41:48 <McManiaC> okay cool
05:42:10 <quicksilver> Silvah: well, you were exagerrating. There are some very interesting examples of haskell outperforming C but anyone with considerable experience in haskell will tell you they are a tiny minority.
05:42:43 <cozachk> quicksilver, when does haskell outperform c?
05:42:45 <quicksilver> dons did some great stuff with bytestring/binary, for example, but he did this by hacking the optimisation directives for the compiler - that's not really haskell any more.
05:42:56 <quicksilver> cozachk: seldom :)
05:43:19 <Silvah> ...the important part is "let's pretend".
05:43:28 <dolio> quicksilver: Anyhow, rant away. I've had people argue with me about whether overlapping instances are all sweetness and light. At the time, I could only think of not particularly convincing examples (that overlapping is in a sense inherently incoherent), but this is better.
05:45:01 <Silvah> Several days ago there was a guy who wrote a brainfuck interpreter in Haskell and C++, and the Haskell version was actually faster...
05:46:04 <liyang> In other news, hell froze over?
05:47:04 <tao> hi
05:47:20 <Kaidelong> Silvah: as I was pointing out, C is still at a low level of abstraction, and he could re-invent the haskell version in it, the question is whether it is worth it and if he'll get it right
05:47:25 <Kaidelong> lower*
05:47:27 <Taejo> I want to write a program that reads whitespace-separated tokens of the form alpha/beta, and builds histograms of alphas and betas, and also bigrams and trigrams thereof
05:48:29 <McManiaC> cozachk: what is the glut32 dll/where can I get it?
05:49:11 <Taejo> I meant to add "How do I do that with iteratees?"
05:49:13 <dolio> quicksilver: "It doesn't do what you think it does" is a little more compelling than "this is theoretically unpleasing."
05:49:57 <arw> McManiaC: glut is opengl utils. usually, the vendor of your graphics driver should distribute that. don't know if current windows versions still include software-opengl
05:49:57 <quicksilver> dolio: Right. It's not prolog. It doesn't do *even* do fully backtracking first-match search, let *alone* an exhaustive best-match search.
05:50:12 <Silvah> Kaidelong: he could even write it in assembly and, assuming he knows assembly good enough, easily outperform everything else. The question is: who is so insane to do that?
05:50:27 <quicksilver> dolio: plenty of people hope it will do the second and some hope more modestly for the first.
05:50:39 <Kaidelong> Silvah: that's basically what I was saying yes
05:50:57 <Kaidelong> it does mean "haskell does this faster than C" is meaningless to say, though
05:51:12 <Kaidelong> it meant that in that case, the compiler was smarter than the programmer
05:51:16 <quicksilver> dolio: one can also demonstrate how it breaks parametric polymorphism, or at least uniform compilation of such polymorphism. (parametric compilation?)
05:51:19 <Kaidelong> and the higher level of abstraction paid off
05:52:49 <Silvah> Strictly speaking, no language can be faster than another. Only particular implementations of these languages can be.
05:52:57 <Kaidelong> that is also true
05:53:13 <dolio> Well, that depends.
05:53:48 <Kaidelong> you could however design a language that allows for programs that cannot actually be compiled though, could you?
05:53:57 <Kaidelong> because it'd halt any concievable compiler
05:55:14 <dolio> You could have a language that allowed you to prove to the compiler that it could do certain optimizations that couldn't be done in general, and for which the proof couldn't be automatically discovered in general (and thus, languages that lack such capabilities couldn't just figure it out).
05:56:20 <Kaidelong> dolio: and I suppose some languages like python or haskell might stop you from writing in those optomizations yourself for various reasons?
05:56:26 <Kaidelong> or require more overhead to manage it
05:56:57 <temoto> Hey i just found MacOSX has sparks. Called grand central dispatch. Pretty cool.
05:58:25 <dolio> Kaidelong: I mean like in Java, array accesses have bounds checks. But if you can prove statically that you never use a value outside the bounds, you can eliminate the checks.
05:58:44 <Silvah> You *can*.
05:59:08 <dolio> You could turn off the checks anyway, but then safety conditions aren't being enforced.
05:59:48 <Silvah> It's always possible to write a compiler which generates outright atrocious contraptions.
06:01:05 <aavogt> perhaps your target will refuse to execute ugly code
06:03:54 * cozachk found that ghci is case sensitive on linux with filenames and not so on windows so his loading problem is fixed
06:04:38 <stroan> cozachk: I imagine that's a platform related issue more than a GHCI issue
06:04:48 <sepp2k> cozachk: It's not ghci that's case sensitive - the file system is.
06:05:15 <p_l> cozachk: case sensitiveness is a system setting on Windows NT
06:05:19 <temoto> cozachk, actually, you can turn case sensivity on for NTFS.
06:05:35 <p_l> temoto: it's not NTFS, it's for the whole OS
06:05:49 <stroan> I did not know that. I wonder how many applications that would break
06:06:28 <p_l> stroan: I managed to run rather well with that, but I suspect many internal apps or cheap shareware/freeware or just plain old stuff might break
06:06:37 <temoto> Not so much, actually.
06:06:51 <temoto> Who uses hardcoded paths anyway...
06:11:10 <quicksilver> OSX is similar but in OSX it's the file system not the OS.
06:11:19 <cozachk> I am gonna give a 10 minute presentation on doing linear algebra in haskell (wrote my own code) to my linear algebra class, any suggestions? :-D
06:11:25 <quicksilver> I did once format an OSX disk case sensitive and not much broke.
06:17:26 <temoto> cozachk, show'em who's the man!
06:18:04 <ClaudiusMaximus> cozachk: i used hmatrix to do svd (iirc, would have to dig out the code) for as-rigid-as-possible shape interpolation for animation
06:24:59 <Kaidelong> :t (+5)
06:25:00 <lambdabot> forall a. (Num a) => a -> a
06:25:08 <Kaidelong> :t (+5.0)
06:25:09 <lambdabot> forall a. (Fractional a) => a -> a
06:25:48 <edwardk_> hrmm i should look into doing forward/reverse ad on matrices too. there was a nice paper on the topic, about dealing with taylor series of matrices rather than matrices of taylor series.
06:26:33 <edwardk_> (mainly because the former can leverage existing blas bindings, etc)
06:27:58 <ivanm> what? you're doing ads on matrices?
06:27:58 <ivanm> :/
06:28:13 <edwardk_> ivanm: yeah the first column gets replaced with spam
06:28:26 <ivanm> oooohhh....
06:28:37 <ivanm> does that type-check?
06:28:40 <ivanm> :p
06:28:54 <edwardk_> yeah error "Buy Now!" -- i can't unbox the matrix though ;)
06:29:00 <ivanm> heh
06:29:02 <Schalken> I have a lazy ByteString which is the contents of a file. Will calling 'length' on the string cause it to read the entire file, or does it somehow already know the strings length?
06:29:09 <edwardk_> Schalken: yes it will
06:29:32 <edwardk_> well, technically, it'll force it when you first look at the length
06:29:33 <McManiaC> http://npaste.de/Tm/ fuuu windows
06:29:34 <McManiaC> :O
06:30:06 <Schalken> edwardk_: Right, because the value of the length will in turn be lazy...
06:30:17 <edwardk_> yeah
06:30:30 <ivanm> McManiaC: heh, a couple of weeks back I had to fix student errors dealing with gloss :p
06:30:30 <ivanm> do you have freeglut installed?
06:30:39 <McManiaC> nope
06:30:43 <McManiaC> where do I get it?
06:31:05 <Schalken> edwardk_: So generally speaking, evaluating the spine of a lazy ByteString will cause its source data to be read in?
06:31:20 * ivanm gets the link
06:31:22 <edwardk_> Schalken: yeah
06:31:30 <Schalken> edwardk_: Awesome. Thanks.
06:32:00 <ivanm> McManiaC: http://www.cs.rpi.edu/~girdhy/komputer_grafix/installing_glut.html
06:32:22 <ivanm> you might need to put that dll file in the folder you've got the haskell code in...
06:33:00 * ivanm -> dream land
06:33:16 <McManiaC> ivanm: ah
06:33:19 <McManiaC> already did that
06:33:34 <ivanm> oh
06:33:43 <ivanm> well, that's the only thing I could think of there ;-)
06:34:03 <McManiaC> I can see the graphics/animations etc
06:34:10 <McManiaC> but I cant stop it
06:34:37 <McManiaC> I have to close the whole cmd window where ghci is running in and restart/reload the whole file
06:36:10 <McManiaC> or I'm too stupid to cancel a running progress in the stupid cmd thing here
06:36:11 <McManiaC> :>
06:36:23 <vmixey> whats a cool haskell program to try my hand at
06:36:24 <vmixey> ?
06:36:45 <edwardk_> vmixey: irc bot is the classic starting point ;)
06:37:12 <stroan> edwardk_: and yet there doesn't seem to be a nice IRC package on hackage from what I can tell
06:37:22 <edwardk_> stroan: very well then.
06:37:31 <stroan> I don't disagree :)
06:37:35 <edwardk_> vmixey: an irc package for hackage seems to be the classic starting point. ;)
06:37:41 <Axman6> heh
06:37:42 <edwardk_> problem solved ;)
06:37:45 <Axman6> then a monad tutorial
06:37:46 <stroan> IRC is a nice simple protocol
06:37:55 <stroan> great for learning
06:38:13 <Axman6> bittorrent's protocol is much nicer imo
06:38:27 <stroan> A Monad is much like an IRC package on hackage... (two birds with one stone)
06:38:31 <Axman6> completely different, but i prefer binary protocols to text ones
06:38:57 <edwardk_> or even an introduction to monads via an irc monad
06:39:27 <temoto> vmixey, an interpreter for a toy language.
06:39:44 <EvanR-work> real world haskell makes a pointer of defining strong typing in haskell. is this definition 'official'? that is to say, ill typed expressions will be rejected by the haskell implementation?
06:39:50 <EvanR-work> s/pointer/point/
06:40:09 <edwardk_> > "Hello" + 12
06:40:10 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
06:40:10 <lambdabot>    arising from the literal ...
06:40:16 <edwardk_> yes
06:40:38 <McManiaC> there actually *is* a irc lib on hackage
06:40:39 <EvanR-work> > (5 :: Int) + 3.14
06:40:39 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
06:40:40 <lambdabot>    arising from the lit...
06:40:44 <McManiaC> it has everything you need
06:40:44 <McManiaC> :>
06:40:48 <edwardk_> McManiaC: 2-3 but they are all just parsers
06:40:51 <McManiaC> yeh
06:41:00 <Axman6> vmixey: what are you interested in?
06:41:01 <McManiaC> what else do you need? Network already is pretty easy to use
06:41:11 <McManiaC> *is already
06:41:14 <vmixey> I don't know what
06:41:16 <EvanR-work> edwardk_: ok, then i will embrace this terminology in this context, then ;)
06:41:16 <edwardk_> McManiaC: i don't know of one that manages the network connection, logs in, responds to pings for you, and lets you chat
06:42:01 <vmixey> I just want to create some thing but I haven't got an idea
06:42:42 <McManiaC> edwardk_: if that would already exist - what else would you have to do? :)
06:43:16 <edwardk_> mcmaniac write interesting commands for the bot... thats the hard part
06:43:34 <edwardk_> you know commands that don't forget their state every time you restart the bot like *cough* lambdabot ;)
06:45:05 <McManiaC> ^^
06:45:05 <vmixey> human brain is interesting but I can't really program one of those
06:45:30 <edwardk_> the human brain is vastly overrated ;)
06:45:36 <vmixey> lol
06:46:22 <EvanR-work> i know right
06:46:38 <EvanR-work> we need elaborate static type systems to fix its abundant errors
06:47:18 <vmixey> I don't really know what I should try to do
06:47:19 <EvanR-work> if brains cant write code correctly the first time, what about politics?
06:47:35 <vmixey> I think I have enough basic ability to actually write the program but I just don't know what it is yet
06:48:03 <Berengal> vmixey: IRC bot is a decent idea. Or make up your own IRC-like protocol and write a server and a client for it
06:48:05 <mdmkolbe> Arrrrgg, why don't these types work? http://pastebin.org/254219
06:48:26 <Berengal> mdmkolbe: they're lazy types. Beat them with a stick
06:48:34 <stroan> vmixey: I was recommended to write a small interpretter / parser as my first main project. It's a good idea. Especially helps with getting to grips with monads
06:49:09 <temoto> vmixey, start with print "hello world" and dream on, see where it gets you.
06:49:26 <Berengal> mdmkolbe: From the looks of the error message, you're not being polymorphic enough
06:49:43 <pastorn> mdmkolbe: the type checker cannot deduce which instance to use
06:49:45 <Berengal> mdmkolbe: What's the type of mkQ?
06:50:05 <temoto> i heard one guy once wrote a process scheduler and file system started from hello world
06:50:09 <pastorn> mdmkolbe: at least i got this message when i was messing with typeclasses
06:50:10 <mdmkolbe> @type mkQ
06:50:11 <lambdabot> forall r b a. (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
06:50:13 <vmixey> I've written a lot of interepreters.. don't know what language I would implement next
06:50:13 <mdmkolbe> @type mkT
06:50:15 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
06:50:44 <pastorn> vmixey: work on this :) http://www.cs.st-andrews.ac.uk/~eb/Idris/
06:50:45 <temoto> vmixey, wanna language to implement?
06:51:02 <exDM69> vmixey: I had a blast implementing the prolog-like logic programming language from SICP
06:51:27 <Kaidelong> so what would I use as an antonym of "operational"?
06:51:33 <vmixey> well it's just that I've already written various prolog implementations
06:51:33 <Kaidelong> "denotational"?
06:51:49 <vmixey> so I don't think I will implement another language
06:51:54 <p_l> implementing a language seems to be quite useful project - PAIP used similar approach
06:51:55 <Kaidelong> "algebraic"?
06:52:01 <vmixey> especially because I don't have any original ideas for a new language
06:53:12 <zakwilson> There are original ideas for new languages?
06:54:01 <vmixey> zakwilson, look at one of these programming language timelines -- there are really cool new stuff popping up every few years
06:55:04 <zakwilson> Yes, but most of the time those ideas are just making some design pattern idiomatic. That's a Good Thing, but whether it's original is debatable.
06:55:07 <vmixey> maybe the hardware will have to change before we get any fundamentally new langauges
06:55:36 <zakwilson> There might be some room for that with gpgpu
06:58:33 <Berengal> Honestly, I don't think there's any fundamental different between "new" and "better".
06:58:57 <Berengal> *fundamentally
06:59:24 <vmixey> any other ideas
06:59:24 <vmixey> ?
06:59:28 <vmixey> what I should o
07:00:28 <temoto> vmixey, how about some bycicle ride?
07:00:31 <vmixey> :[
07:01:21 <vmixey> it's frustrating that everything is too easy or too hard
07:01:25 <temoto> If you spin wheels for 2-3 hours, i promise, you will have ideas.
07:01:27 <stroan> vmixey: recreate the processing API in haskell
07:02:03 <EvanR-work> what is with this magic guarantee of at least 29 bits wide Ints ?
07:02:06 <EvanR-work> 29?
07:02:16 <EvanR-work> conjures up images of UTF9
07:02:27 <opqdonut> EvanR-work: leaves some for tagging
07:02:35 <temoto> EvanR-work, don't like number 29?
07:02:42 <tromp> you're looking for any programming task, vmixey?
07:02:49 <EvanR-work> so two bits of tagging
07:02:49 <vmixey> yeah
07:03:23 <tromp> how about converting a 155 bit number into a chess position?
07:03:33 <EvanR-work> i suppose theres similar room in Char (because of unicode's limited range) and Float
07:04:02 <EvanR-work> or, possible room
07:06:42 <temoto> EvanR-work, unicode is not limited.
07:07:25 <vmixey> > 155-64
07:07:26 <lambdabot>   91
07:07:40 <earthy> actually, tags tend to be stored in the pointer for boxed types
07:07:45 <vmixey> 91 bits is enough to say something like "king,pawn,pawn,..."?
07:07:46 <earthy> as long as there's not too many alternatives
07:08:06 <dolio> Kaidelong: I'm not sure there's a sensible opposite of operational.
07:08:15 <Kaidelong> I'll say that b `pseq` a `pseq` b = a `pseq` b holds algebraically
07:08:18 <EvanR-work> temoto: an entire Word32 bits arent used
07:08:19 <Kaidelong> but not operationally
07:08:44 <dolio> In that case, denotationally would work fine.
07:08:53 <vmixey> oh actually it will have to say the color too
07:09:10 <temoto> EvanR-work, used and limited are orthogonal.
07:09:43 <EvanR-work> so the implementation can use those bits for tagging, like the 29 bit Int
07:10:12 <tromp> i wrote a haskell program to count chess positions at http://www.cwi.nl/~tromp/chess/chess.html
07:10:29 <temoto> EvanR-work, unicode as in character set is not limited. We use only a small portion of infinite unicode space, yes.
07:10:31 <tromp> it comes to a hair under 2^155
07:10:45 <vmixey> that's pretty cool
07:11:01 <tromp> so it would be cool to generate random chess positions, and see what percentage is actually legal
07:11:07 <EvanR-work> temoto: since when is the unicode character space infinite
07:11:07 <temoto> EvanR-work, are you trying to invent a utf-32 with that Word32? :)
07:11:54 <EvanR-work> no, if you read above i was asking about 29 bit Ints. if the answer is tagging, the question is where is this reservation made for other basic types. i came to the conclusion its built into Char by virtue of unicode
07:11:57 <temoto> EvanR-work, well, since the beginning, i guess. (actually i haven't pay much attention to it's development)
07:12:35 <EvanR-work> unicode is limited to a specific range of code points something like 0x10ffff or something
07:12:40 <EvanR-work> is the max
07:12:51 <EvanR-work> not all below that are allocated
07:13:56 <temoto> EvanR-work, i could be wrong here, wait a minute...
07:15:52 <vmixey> @let choose n k = product [k..n] / product [1..k]
07:15:53 <lambdabot>  Defined.
07:16:04 <vmixey> > log (choose 64 32) / log 2
07:16:05 <lambdabot>   65.66861663700344
07:16:23 <dolio> > logBase 2 (choose 64 32)
07:16:24 <lambdabot>   65.66861663700344
07:16:27 <EvanR-work> > 2 ** 65.66861663700344
07:16:27 <vmixey> > 155-66
07:16:28 <lambdabot>   5.864397251016291e19
07:16:28 <lambdabot>   89
07:16:32 <temoto> EvanR-work, sorry, for some reason i thought there could possibly be infinite list of unicode planes.
07:16:53 <edwardk_> > 2^155 < 10^50
07:16:55 <lambdabot>   True
07:16:57 <temoto> they state it's only 17
07:17:05 <EvanR-work> that would require a fairly interesting default representation
07:17:06 <edwardk_> tromp you should go update wikipedia to reflect your upper bound ;)
07:17:08 <tromp> its only 154 bits if you ignore whose turn it is
07:17:16 <tromp> i did update wikipedia
07:17:35 <tromp> http://en.wikipedia.org/wiki/Game_complexity
07:17:36 <edwardk_> > 2^155 / 10^50
07:17:37 <lambdabot>   4.567192616659071e-4
07:17:49 <edwardk_> the main chess article mentions a complexity range too
07:18:31 <tromp> ah yes, i can update that too
07:19:26 <vmixey> > 89/4
07:19:27 <lambdabot>   22.25
07:20:01 <dolio> > choose 2 1
07:20:02 <lambdabot>   2.0
07:20:04 <vmixey> my way must be wrong if there are that many left over bits
07:20:20 <dolio> > choose 3 1
07:20:21 <lambdabot>   6.0
07:20:40 <Kaidelong> > choose 4 3
07:20:41 <dolio> > choose 3 2
07:20:41 <lambdabot>   3.0
07:20:41 <lambdabot>   2.0
07:20:45 <tromp> what is ur way?
07:20:46 <edwardk_> toying with 3 extensions to the ad code, unboxing (for efficiency), allowing mixing of types (for generality) and allowing you to take forward derivatives of the output of the reverse mode pass.
07:20:51 <vmixey> I was thinking if you number the squares of the board, then we can use 66 bits to determine which squares have a peice on them or not
07:21:08 <vmixey> then we can use the remaining bits to say which peice is on each bit (and of which color)
07:21:13 <EvanR-work> not all pieces can be on all squares
07:21:14 <dolio> I think your algorithm is incorrect.
07:21:15 <edwardk_> why 66?
07:21:18 <Kaidelong> shouldn't choose 3 2 be 3? or did I forget something
07:21:23 <EvanR-work> and the order of moves also restricts things
07:21:24 <tromp> that will take up much more than 155 bits
07:21:40 <dolio> choose n k = product [n-k .. n] / product [1..k]?
07:21:45 <vmixey> > log (choose 64 32) / log 2 -- we have to choose 32  peices from the board of 64 squares
07:21:46 <lambdabot>   65.66861663700344
07:22:00 <EvanR-work> like you can move your bishop to behind the enemy line of pawns that havent moved yet
07:22:03 <EvanR-work> cant*
07:22:10 <tromp> must be less than  64
07:22:19 <dolio> > product [3-1..3] / product [1..1]
07:22:20 <lambdabot>   6.0
07:22:26 <tromp> sum (64 choose i) = 2^64
07:22:26 <vmixey> oh yeah there are peices who can only be on a certain color
07:22:52 <dolio> > product [3-2..3] / product [1..2]
07:22:53 <lambdabot>   3.0
07:22:56 <EvanR-work> vmixey: yes and see the above missing positions too
07:22:59 <jmcarthur> wait, what exactly does choose mean here?
07:23:05 * jmcarthur just entered this conversation
07:23:26 <tromp> your choose def is wrong
07:23:36 <edwardk_> plus whether or not the pawn has advanced to some other type is an issue, etc.
07:23:41 <edwardk_> er a
07:23:42 <tromp> you have k+1 factors in numerator
07:23:52 <dolio> jmcarthur: Presumably n!/k!(n-k)!.
07:24:01 <Kaidelong> product [1..3] / (product [1..1] * product [1..1])
07:24:26 <Kaidelong> would yield choose 2 out of 3, I believe
07:24:28 <edwardk_> Kaidelong: is one of those bottoms a 1..2?
07:24:33 <Kaidelong> > product [1..3] / (product [1..1] * product [1..1])
07:24:34 <lambdabot>   6.0
07:24:41 <Kaidelong> yes apparently
07:24:50 <Kaidelong> > product [1..3] / (product [1..1] * product [1..2])
07:24:51 <lambdabot>   3.0
07:24:56 <Kaidelong> one of them is 1..k
07:25:00 <Kaidelong> the other 1..n-k
07:25:03 <edwardk_> yes
07:25:06 <Kaidelong> > choose 3 2
07:25:07 <lambdabot>   3.0
07:25:12 <Kaidelong> oh
07:25:12 <dolio> > (product [3-1+1..3] / product [1..1], product [3-2+1..3] / product [1..2])
07:25:13 <lambdabot>   (3.0,3.0)
07:25:16 <Kaidelong> it works just fine, nm
07:25:26 <Kaidelong> choose 4 3
07:25:26 <jmcarthur> i don't want to work today. i just want to work on my dctp implementation
07:25:33 <Kaidelong> > choose 4 3
07:25:34 <lambdabot>   2.0
07:25:38 <tromp> @let choose n k = product [n-k+1..n] `div` product [1..k]
07:25:39 <lambdabot>  <local>:2:0:
07:25:40 <lambdabot>      Warning: Pattern match(es) are overlapped
07:25:40 <lambdabot>               In...
07:25:44 <Kaidelong> > choose 4 1
07:25:46 <lambdabot>   24.0
07:25:50 <Kaidelong> ...???
07:25:53 <hpc> @src choose
07:25:53 <lambdabot> Source not found. Where did you learn to type?
07:26:08 <dolio> @undefine
07:26:16 <jmcarthur> :t choose
07:26:17 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
07:26:18 <dolio> Now define it.
07:26:42 <tromp> @let choose n k = product [n-k+1..n] `div` product [1..k]
07:26:44 <lambdabot>  Defined.
07:26:48 <Kaidelong> > product [1..4] / (product [1..3] * product [1..1])
07:26:49 <lambdabot>   4.0
07:26:55 <Kaidelong> > product [1..4] / (product [1..1] * product [1..3])
07:26:56 <lambdabot>   4.0
07:27:04 <Kaidelong> > choose 4 3
07:27:05 <lambdabot>   4
07:27:08 <Kaidelong> > choose 4 1
07:27:09 <lambdabot>   4
07:27:16 <Kaidelong> wtf just happened
07:27:19 <edwardk_> Kaidelong: the first n terms cancel
07:27:31 <jmcarthur> > choose 32 64
07:27:31 <edwardk_> er k
07:27:32 <lambdabot>   0
07:27:46 <Kaidelong> edwardk scroll up
07:27:49 <jmcarthur> > choose 64 32
07:27:50 <lambdabot>   1832624140942590534
07:27:55 <Kaidelong> lambdabot was retur...
07:27:58 <Kaidelong> yes
07:28:02 <Kaidelong> oh
07:28:10 <jmcarthur> heh
07:28:17 <Kaidelong> well
07:28:22 <Kaidelong> it was answering "24.0"
07:28:25 <Kaidelong> for 4 choose 1
07:28:29 <dolio> We changed it.
07:28:30 <Kaidelong> and "2" for 4 choose 3
07:28:32 <Kaidelong> ah ok
07:28:32 <jmcarthur> right. it was wrong
07:28:47 <edwardk_> someone probably defined it in a /msg and then the later def didn't take
07:28:58 <dolio> > map (3 `choose`) [0..3]
07:28:59 <lambdabot>   [1,3,3,1]
07:29:28 <dolio> > map (\n -> map (n `choose`) [0..n]) [1..]
07:29:29 <lambdabot>   [[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,...
07:29:30 <jmcarthur> it looks like LB interpreted the later def to be another pattern for the first. i was surprised it did that
07:29:34 <quicksilver> does @let work by appending a line to L.hs, trying to compile it, and restoring the old L.hs if compile fails?
07:29:42 <quicksilver> jmcarthur: they must have be adjacent in the file, I think.
07:29:46 <tromp> @let pascal  = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
07:29:47 <lambdabot>  Defined.
07:29:50 <jmcarthur> oh!
07:29:57 <jmcarthur> i didn't realize all this was stored in a file
07:30:07 <tromp> > pascal!!3
07:30:08 <lambdabot>   [1,3,3,1]
07:30:16 <hpc> > pascal
07:30:17 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
07:30:20 <edwardk_> jmcarthur: yeah, low tech ;)
07:30:49 <dolio> @let choose' n k = pascal !! n !! k
07:30:50 <lambdabot>  Defined.
07:31:16 <dolio> > choose' 4 2
07:31:17 <lambdabot>   6
07:32:11 <dolio> > choose' 64 32
07:32:11 <lambdabot>   1832624140942590534
07:32:32 <aristid> > map . sum $ pascal
07:32:33 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
07:32:39 <aristid> :t pascal
07:32:40 <lambdabot> forall a. (Num a) => [[a]]
07:32:56 <aristid> > map sum pascal
07:32:57 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
07:33:17 <aristid> > map product pascal
07:33:22 <lambdabot>   [1,1,2,9,96,2500,162000,26471025,11014635520,11759522374656,324060912000000...
07:33:26 <EvanR-work> > map product delphi
07:33:26 <edwardk_> > let expand xs = 0: xs++[0] in iterate (ap (zipWith (+)) tail . expand) [1]
07:33:27 <lambdabot>   Not in scope: `delphi'
07:33:28 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
07:33:50 <edwardk_> hah i see tromp pasted one above
07:37:36 <piotr__> Hi
07:38:07 <Botje> hallo!
07:40:45 <dolio> > choose 1000 1000
07:40:46 <lambdabot>   1
07:40:50 <dolio> > choose 10001 10001
07:40:51 <lambdabot>   1
07:42:35 <piotr__> Hi! I'm newby and am having some problems defining my own monad
07:42:46 <piotr__> Compiler comes in the way and complains about 'rigid' variables
07:42:57 <jmcarthur> piotr__: paste it on hpaste.org
07:43:02 <jmcarthur> ... or is it .com?
07:43:03 <edwardk_> piotr__: can you paste it to hpaste or lisppaste or something?
07:43:03 <piotr__> alright
07:43:05 <jmcarthur> what's wrong with me?
07:43:09 <jmcarthur> org
07:43:15 <jmcarthur> sorry about that mental lapse
07:43:21 <jmcarthur> hey look server error
07:43:28 <edwardk_> jmcarthur: clearly you're strung out from the agonizing decision you had to make about hac phi
07:43:34 <jon_of_arc> Don't suppose there's a way to convert an exception-throwing function to a maybe-returning function without going all the way back out to IO, is there?
07:43:40 <jmcarthur> that's exactly it, edwardk_
07:44:01 <jmcarthur> can't we just move hac phi down to alabama on a whim to satisfy my desires?
07:44:03 <edwardk_> jon_of_arc: depends on the kind of exception, if it is an IO exception? good luck, if its using MonadError? you can catch it
07:44:23 <piotr__> hpaste is having some problems currently
07:44:32 <piotr__> do you know an alternative?
07:44:33 <edwardk_> you should just organize a hac birmingham or something
07:44:41 <jmcarthur> hac huntsville
07:44:49 <jmcarthur> more engineers here :)
07:44:50 <edwardk_> http://paste.lisp.org/
07:44:52 <edwardk_> yeah
07:44:54 <jon_of_arc> Whatever failed record applications toss out
07:45:24 <jmcarthur> i doubt it would be very big though. fewer major cities near huntsville
07:45:52 <ddarius> jmcarthur: You're in Alabama?
07:46:00 <jmcarthur> yes sir
07:46:13 <ddarius> You visit shapr?
07:46:37 <jmcarthur> well, i met him a couple times since he moved
07:46:48 <Darthreborn> hi all ...i'm looking for a JavaScript parser in haskell...is hjs the best one ?
07:46:55 <jmcarthur> he hung out with a hackerspace i'm involved with a few times
07:47:44 <piotr__> ok. my paste: http://paste.lisp.org/+24Q
07:48:28 <jmcarthur> piotr__: that link takes me to a gcc error, something about gnome...
07:48:44 <piotr__> oops it seems truncated
07:48:54 <EvanR-work> jmcarthur: alabama, greetings from louisiana.
07:49:05 <piotr__> http://paste.lisp.org/display/99465
07:49:09 <EvanR-work> southern pride for the win
07:49:32 <jmcarthur> EvanR-work: huntsville is more like the North surrounded by the South
07:49:37 <EvanR-work> lol
07:49:43 <jkingkong> Hey #haskell, I get the error     Couldn't match expected type `Data.Array.Parallel.Unlifted.Array a'
07:49:45 <jkingkong>            against inferred type `[a1]'
07:50:01 <jkingkong> when i try to run anifest (Z:.2) [2,3]
07:50:10 <jkingkong> *manifest (Z:.2) [2,3]
07:50:19 <Raynes> jmcarthur: It's still the South, and it still sucks.
07:50:40 <jkingkong> the second argument Array a is a type synonym of [a]
07:50:47 <jkingkong> so i'm not sure why it doesn't like [2,3]
07:50:50 <jkingkong> brb 2 min
07:51:13 <jmcarthur> Raynes: well, the alabama state government certainly sucks
07:51:47 <Raynes> jmcarthur: I loathe this state very much.
07:51:55 <jmcarthur> i quite like huntsville overall, aside from being far from anything terrible cool
07:51:57 <jmcarthur> *terribly cool
07:52:12 <Raynes> I've never been to Huntsville.
07:52:16 <piotr__> jmcarthur: i pasted the fixed link some lines above. Did you see it?
07:52:29 <jmcarthur> huntsville is really a lot like i said... the North surrounded by the South
07:52:37 <jmcarthur> piotr__: yeah i'm taking a peek right now
07:53:06 <jmcarthur> piotr__: i can take a guess at what's going on here, but first i'm going to guess your intent
07:53:07 <BMeph> Rednecks w/ Rockets -- should be the "new" Alabama State Motto! ;)
07:53:17 <piotr__> jmcarthur: If I truncate my definition of DrawingState so that the left constructor takes nothing.
07:53:45 <piotr__> jmcarthur: i mean takes no arguments.. then like with Maybe it compiles
07:54:09 <piotr__> jmcarthur: i just want to "tag" the result of computation
07:54:09 <jmcarthur> piotr__: i'm guessing that you are wanting to only apply the function if the consstructor is Drawn?
07:54:20 <piotr__> jmcarthur: correct
07:54:54 <jmcarthur> piotr__: think about the type of (>>=)...  DrawingState a -> (a -> DrawingState b) -> DrawingState b
07:54:59 <BMeph> tromp: Just curious (that means, "uh-oh, here comes another BMeph zinger..."), but do you account for the King's movement against castling, as well as the rooks? :)
07:55:10 <jmcarthur> piotr__: if you don't apply the function, what is the type of the result?
07:55:32 <sepp2k> piotr__: Why are you hiding >>= ?
07:55:33 <piotr__> The type is DrawingState a
07:55:38 <tromp> yes, i account positions with castling rights separately
07:55:51 <jmcarthur> piotr__: right, but the type of (>>=) won't like that. that's the problem
07:56:00 <piotr__> sepp2k: some leftover from various experiments. no need for it.
07:56:47 <BMeph> tromp: Okay, I just saw a lot of stuff about the rooks, but nothing about Ol' Gimpy, so I wanted to be sure. :)
07:56:59 <jmcarthur> piotr__: the type of (>>=) requires that the result type must be the same as the result type of the function parameter
07:57:00 <piotr__> jmcarthur: you mean because I narrow the return type to be of DrawingState a
07:57:15 <tromp> see comments near bottom: -- the first seven tuples count configurations -- of kings that can castle in various ways
07:57:30 <jmcarthur> piotr__: it's not even narrowing really so much as it is simply not meeting the type requirements at all
07:58:10 <jmcarthur> piotr__: think about what it would be like to *use* your definition of (>>=). how would you know the type of the result if it could be either the original type or the transformed type?
07:59:00 <piotr__> jmcarthur: yeah.. I kind of get the feeling
07:59:02 <jmcarthur> piotr__: i have a solution for you, but i want to make sure you understand why yours isn't working
07:59:55 <piotr__> jmcartur: I don't fully understand yet. I'm thinking about Maybe monad.
08:00:01 <jmcarthur> i also don't know if it will be quite what you want
08:00:07 <piotr__> jmcarthur: there its very similar.
08:00:07 <jmcarthur> yeah, my solution is a lot like the maybe monad
08:00:46 <jmcarthur> piotr__: consider this:   data DrawingState a b = StillDrawing a | Drawn b
08:00:47 <piotr__> the problem with the Maybe monad is that in case of 'Nothing' I loose the result of computation
08:01:06 <jmcarthur> piotr__: that would allow you to retain a value that is different from the final drawing type if it's not done yet
08:01:17 <jmcarthur> piotr__: and it would make the Monad class happy :)
08:01:51 <piotr__> jmcarthur: I don't think so. I think I tried it too. It's now more like Either Monad.
08:01:54 * BMeph thinks someone should tell piotr__  that his monad is more like Something Else besides Maybe...
08:01:57 <jmcarthur> right
08:02:30 <jmcarthur> piotr__: Maybe and Either have a lot in common
08:03:12 <piotr__> But in case of Either it also does not work if  '>>= (Left x) f = Left x
08:03:21 <jmcarthur> sure it does
08:03:41 <jmcarthur> piotr__: Left x leave the second type variable free, so it can unify with anything
08:03:44 <jmcarthur> *leaves
08:04:57 <piotr__> Ok. Thanks for help. I'll try it.
08:05:04 <jmcarthur> piotr__: the monad instance you wrote will probably work without changing at all if you rewrite the DrawingState definition to what i said, even :)
08:05:22 <EvanR-work> > even 'x'
08:05:22 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
08:05:23 <lambdabot>    arising from a use of...
08:05:35 <EvanR-work> > even (fromEnum 'x')
08:05:36 <lambdabot>   True
08:05:42 <jmcarthur> > even . ord $ 'x'
08:05:43 <lambdabot>   True
08:05:55 <ski> @src Either (>>=)
08:05:56 <lambdabot> Left  l >>= _ = Left l
08:05:56 <lambdabot> Right r >>= k = k r
08:05:56 <EvanR-work> :t ord
08:05:57 <lambdabot> Char -> Int
08:06:05 <EvanR-work> > ord 'x'
08:06:06 <lambdabot>   120
08:06:11 <EvanR-work> > fromEnum 'x'
08:06:11 <lambdabot>   120
08:06:41 <jmcarthur> @check liftA2 (==) ord fromEnum
08:06:42 <lambdabot>   "OK, passed 500 tests."
08:07:16 <EvanR-work> :t liftA2
08:07:17 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
08:07:35 <EvanR-work> @src Applicative
08:07:35 <lambdabot> class Functor f => Applicative f where
08:07:35 <lambdabot>     pure  :: a -> f a
08:07:35 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
08:07:39 <EvanR-work> ok ill stop
08:07:42 <jmcarthur> in that case, f == (->) Char
08:08:05 <EvanR-work> :t (->)
08:08:06 <lambdabot> parse error on input `->'
08:08:17 <jmcarthur> :k (->)
08:08:18 <lambdabot> ?? -> ? -> *
08:08:22 <EvanR-work> :o
08:08:33 <jmcarthur> just treat it like * -> * -> *
08:08:41 <jmcarthur> that kind is special for a GHC trick
08:08:44 <piotr__> jmcarthur: i submitted an annotation. Could you take a look again: http://paste.lisp.org/display/99465#1
08:09:21 <jmcarthur> piotr__: hmm
08:09:48 <jkingkong> :t Manifest
08:09:49 <lambdabot> Not in scope: data constructor `Manifest'
08:09:56 <jmcarthur> piotr__: oh... return can't be StillDrawing
08:10:04 <jmcarthur> it needs to be Drawn
08:10:15 <jkingkong> import Data.Array.Repa
08:10:22 <jkingkong> ?
08:10:27 <jmcarthur> piotr__: return :: b -> DrawingState a b
08:10:40 <jkingkong> :t Delayed
08:10:40 <lambdabot> Not in scope: data constructor `Delayed'
08:11:04 <piotr__> jmcarthur: ok. works now. Now I need to think it through
08:11:37 <piotr__> jmcarthur: thank you for your help
08:11:47 <jmcarthur> piotr__: no prob
08:13:47 <jmcarthur> piotr__: just by the way, now your monad exactly mirrors what the Either monad should be (but the actual Either monad instance is dumb and has a constraint on the first type parameter...)
08:20:12 <piotr__> jmcarthur: what is the constraint. Just tried to find the impl of Either monad. But quick search failed to give something reliable.
08:20:14 <piotr__> ?
08:21:10 <ski> piotr__ : `instance Error e => Monad (Either e)' i think
08:21:33 <quicksilver> Control.Monad.Error
08:22:34 <quicksilver> it's not really that annoying because it's easy to give a stupid instance of Error.
08:22:41 <rovar> http://gist.github.com/406413
08:22:58 <ski> @source Control.Monad.Error
08:22:58 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
08:22:58 <rovar> i'm having a "thread blocked indefinitely" problem
08:23:13 * ski finds it really annoying
08:23:35 <rovar> syncRequests creates a QSem and a channel. then spawns a bunch of workers
08:23:59 <ski> (you can't give a stupid instance of `Error' when you working polymorphically)
08:23:59 <rovar> the idea is to wait on the QSem and have each worker write their results into the channel and then flip the qsem
08:24:21 <BMeph> rovar:Hint: Blocking your main thread is likely not what you wanted... ;)
08:24:47 <rovar> BMeph,  I do need to wait for the call to complete before exiting
08:25:05 <BMeph> rovar: Then again, I could just be talking into my hat. :)
08:26:09 <rovar> could it be a problem of laziness? e.g. the worker threads aren't forced to execute therefore they're not triggering the qsem?
08:26:19 <k23z__> does Data.List.Split come with ghc by default ?
08:26:28 <Botje> no, it's in the split package
08:26:28 <jmcarthur> piotr__: http://www.haskell.org/ghc/docs/6.8.3/html/libraries/mtl/src/Control-Monad-Error.html
08:26:36 <Botje> i don't know if it comes with the haskell platform, though
08:27:36 <jmcarthur> i mean, they could have just left the Error constraint on the MonadError class and instances and left it off the Either monad instance completely
08:27:39 <jmcarthur> :\
08:27:48 <jmcarthur> well, i guess that would mess up fail though
08:27:58 <jmcarthur> the failure is fail *and* the either monad
08:28:21 <aavogt> you'd rather have only an instance for  Either String?
08:28:28 <jmcarthur> no
08:28:31 <jmcarthur> for Either a
08:28:46 <jmcarthur> just without the constraint
08:28:56 <aavogt>  fail _ = Left undefined  seems rather dangerous
08:29:08 <jmcarthur> aavogt: right. fail is fail, too
08:29:11 <ski> (.. `fail' should be in another class anyway :)
08:29:13 <jmcarthur> it shouldn't be in Monad
08:29:24 <aavogt> to the point that the instance wouldn't achieve it's intended purpose
08:29:45 <jmcarthur> aavogt: if it has an intended purpose aside from the natural semantics of Either then it should be a newtype wrapper or something, IMO
08:30:01 <gwern> @quote fail
08:30:01 <lambdabot> dons says: hugs should spot the blackhole, or fail gracefully
08:30:15 <gwern> ...ok that's not very funny and I'm going to remove it
08:30:23 <gwern> @forget dons hugs should spot the blackhole, or fail gracefully
08:30:24 <lambdabot> Done.
08:30:27 <gwern> @quote fail
08:30:27 <lambdabot> lambdabot says: <+lambdabot> Plugin `compose' failed with: Unknown command: "3|I+E"
08:30:34 <jmcarthur> o_O
08:30:37 <rovar> much better
08:30:52 <dolio> @elite elite
08:30:52 <lambdabot> 1337
08:30:54 <gwern> no it isn't. at least dons was informative
08:30:59 <gwern> @forget lambdabot <+lambdabot> Plugin `compose' failed with: Unknown command: "3|I+E"
08:30:59 <lambdabot> Done.
08:30:59 <dolio> @elite @elite
08:31:00 <lambdabot>  @eLI+E
08:31:03 <gwern> @quote fail
08:31:03 <lambdabot> Berengal says: [On infinitely fast computers] The OS probably has a failsafe built in: If a program is  running it's in an infinite loop and needs to be killed...
08:31:20 <gwern> heh. that's a decent quote
08:31:41 <gwern> I guess infinitely fast computers are infinitely fast on all operations, else amdahl's law :)
08:32:00 <jmcarthur> shouldn't an infinite loop on an infinitely fast computer be more like NaN?
08:32:10 <jmcarthur> that is, not possible :)
08:32:13 <Berengal> _|_
08:32:21 <dolio> gwern: I guess you can't write programs that are user-bound.
08:32:29 <dolio> Unless we have infinitely fast users.
08:32:30 <aavogt> you're not going to finish the infinite loop?
08:32:38 <aavogt> :P
08:32:46 <aristid> @. elite quote aavogt
08:32:47 <lambdabot> A4V0gt $ay$: y0U CAN'T 937 Ou+ Of FoREVeR \/\/i7HOU+ 5oMe ADDi7IOnAL +rick5
08:32:47 <k23z__> Botje, how can I find out ?
08:32:48 <jmcarthur> actually i think this is an interesting mind exercise
08:32:56 <gwern> dolio: just write a loop to search through all possible turing machines until you find one that emulates the user, and use the emulation everytime you need user input
08:33:06 <dolio> :)
08:33:07 <aristid> :t forever
08:33:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
08:33:16 <aristid> @src forever
08:33:16 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:33:39 <aristid> @hoogle forever
08:33:40 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
08:33:42 <Botje> k23z__: start ghci and try to :m +Data.List.Split
08:33:43 <aavogt> so, reality?
08:33:46 <jmcarthur> i think this says something about the impossibility of infinitely fast computers... unless they are only capable of executing total programs
08:33:49 <Botje> if that gives an error it's not installed :)
08:34:00 <Botje> k23z__: but you can install it with cabal install split
08:34:11 <gwern> aavogt: a referentially pure reality, of course
08:34:12 <aristid> @. elite type forever
08:34:13 <lambdabot> ph0ra11 (m :: * -> *) a b. (MON4d M) => M 4 -> M b
08:34:17 <k23z__> Botje,   http://pastebin.com/JwCCZvhL
08:34:25 <k23z__> what the hell ?
08:34:42 <Botje> k23z__: no, the package is called split
08:34:44 <k23z__> Botje, how did you know it's called split , the package ?
08:34:47 <k23z__> Botje, ?
08:34:50 <gwern> 'hell is a comonad'?
08:34:52 <aavogt> we need an elite that respects syntax
08:34:59 <Botje> k23z__: i know because i looked it up recently
08:35:13 <Botje> k23z__: also, if you google for data.list.split, the hackage page should come up
08:35:25 <Botje> i don't know if you can look it up using the cabal binary
08:35:28 <aristid> aavogt: or a ghc that respects elite
08:35:29 <aavogt> and/or variable renaming to `theme' your code
08:35:34 <dolio> I don't know. "ph0rall" is pretty good.
08:35:35 <gwern> Botje: 'cabal list'|grep split ?
08:35:44 <dolio> I'd use a language with that.
08:36:03 <Botje> gwern: k23z__ wanted to know if you can look up which package a certain module is in
08:36:11 <gwern> .o( wasn't just yesterday dolio haiting on memes like 1337? )
08:36:30 <McManiaC> ivanm: first try: http://n-sch.de/plot.png
08:36:31 <dolio> If it was, I must have been blacked out at the time.
08:36:31 <McManiaC> :D
08:36:32 <aavogt> halting memes
08:36:34 <gwern> Botje: hm, I'm sure the ghc-pkg db has that info
08:36:48 <gwern> aavogt: have you heard charles stross is writing _Rule 34_?
08:36:57 <gwern> er, no, not that rule. the other one
08:37:02 <gwern> or was that right?
08:37:05 <Botje> yes, 34
08:37:08 <aavogt> I'm confused
08:37:15 <Botje> but i'm not sure if it'll be /about/ rule 34 :P
08:37:23 <gwern> oh good it's rule 34
08:37:27 <aavogt> 34 is the one involving art?
08:37:28 * jmcarthur search for "infinitely fast computer" and found a forum thread with Berengal participating in it
08:37:31 <jmcarthur> *searched
08:37:45 <gwern> Botje: if you think it isn't about the meme rule 34... you don't know stross very well
08:38:00 <gwern> Botje: AFAIK the cellular automaton rule 34 isn't interesting
08:38:21 <aavogt> there are that many rules for cellular automata?
08:38:27 <gwern> aavogt: oh there are hundreds
08:38:34 <gwern> it's a new kind of science :)
08:38:35 <rovar> anyone have any tips for debugging "thread would block indefinitely" errors?
08:38:47 <aavogt> gwern: can I blame wolfram?
08:38:50 <rovar> because, IMO, the runtime is wrong ;)
08:38:54 <gwern> see http://atlas.wolfram.com/01/01/34/01_01_1_34.html
08:39:12 <dolio> aavogt: Wolfram actually invented the numbering system.
08:39:14 * hackagebot rangemin 2.1.5 - Linear range-min algorithms.  http://hackage.haskell.org/package/rangemin-2.1.5 (LouisWasserman)
08:39:18 <Botje> gwern: i've read most of his work atm, except for saturn's children and the merchant princes series
08:39:24 <dolio> One of his few actual accomplishments in the area. :)
08:41:24 <EvilMachine> hello. :)
08:41:50 <dolio> > foldl (\r b -> 2*r + b) 0 [0,0,1,0,0,0,1,0]
08:41:51 <lambdabot>   34
08:42:28 <Berengal> jmcarthur: That thread's been going on forever...
08:42:28 <Botje> eek! binary! :P
08:42:33 <EvilMachine> is there a compatibility problem with leksah-server 0.80.02 + ghc 6.10.4 + cabal 1.8.0.4?
08:43:16 <EvilMachine> dolio: wouln't a bitshift be more efficient?
08:43:37 <Botje> i'm sure the compiler is smart enough
08:43:49 <EvilMachine> i hope. i'm not sure, though
08:43:56 <gwern> Botje: I think it would default to Integer...
08:44:00 <dolio> Did lambdabot not give the result fast enough for your taste?
08:44:01 <k23z__> uh splitOn works for strings
08:44:06 <EvilMachine> but hey, at least ghc is a lot smarter than your usual compiler
08:44:06 <k23z__> what can I use for lists ?
08:44:09 <aavogt> integer has a Bits instance
08:44:12 <Botje> it can infer types and straighten out obscure functional programming idioms, it damn well better support bitshifts :))
08:44:14 <EvilMachine> dolio: lol
08:44:40 <Botje> k23z__: splitOn works on any [a], according to the documentation
08:44:50 <EvilMachine> dolio: i'm a machine, you insensitve clod! do you know how boring 100 ms is to a machine? it feels like years!
08:44:51 <hpc> :t splitOn
08:44:52 <gwern> aavogt: Integer may have Bits instance, but I don't see * or + defined in the Bits typeclass...
08:44:52 <lambdabot> Not in scope: `splitOn'
08:44:53 <EvilMachine> ;)
08:45:16 <hpc> @hoogle splitOn
08:45:17 <lambdabot> No results found
08:45:32 <gwern> hpc: most hoogles are limited to base
08:45:35 <gwern> and suchlike
08:45:56 <aavogt> some hoogles are better than others
08:46:00 <k23z__> anna1.hs:13:33:
08:46:00 <k23z__>     Couldn't match expected type `Char'
08:46:00 <k23z__>            against inferred type `[String]'
08:46:04 <k23z__> why ?
08:46:34 <EvilMachine> k23z__: Char /= [Char]
08:46:36 <aavogt> gwern: Bits is involved in the hypothetical substitution of a shift for 2*
08:46:54 <theorbtwo> [Char] == String.  Char /= [String]
08:46:59 <dolio> And it certainly doesnt equal [[Char]].
08:47:00 * edwardk_ is contemplating using like ~10 different types for AD, not sure if the end user will want to care about that many but i think i can largely hide it from them
08:47:00 <EvilMachine> exactly
08:47:02 <nobrain> String = [Char]
08:47:05 <gwern> aavogt: and what, you think there's a rewrite rule in ghc? '2*x::Integer = shift x'?
08:47:10 <Botje> k23z__: can you put code on a pastebin?
08:47:18 <aavogt> gwern: I don't know
08:47:23 <k23z__> Couldn't match expected type `Char' against inferred type `[Char]'
08:47:38 <aavogt> possibly that sort of optimization is done in the processor
08:47:46 <gwern> > shift 2 (20::Integer)
08:47:47 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:47:47 <lambdabot>         against inferred type ...
08:47:58 <gwern> > shift (20::Integer) 2
08:47:58 <aavogt> @type shift
08:47:59 <lambdabot>   80
08:48:00 <lambdabot> forall a. (Bits a) => a -> Int -> a
08:48:07 <gwern> > shift (20::Integer) 1
08:48:08 <lambdabot>   40
08:48:09 <k23z__> Botje, http://pastebin.org/254542
08:48:16 <gwern> hm, so n-1?
08:48:40 <rokoteko> k23z__: "anna_test1.txt" should be 'anna_test1.txt'
08:48:46 <gwern> @check \x y -> x*y == shift (x-1) (y::Integer)
08:48:47 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:48:47 <Botje> k23z__: wo :: [String]
08:48:48 <ski> edwardk_ : Automatic Differentiation ?
08:48:52 <dolio> a * 2^n = shift a n
08:49:02 <k23z__> Botje, is that a cast ?
08:49:14 <EvilMachine> k23z__: your are trying to match a single character (Char) against a list of lists of Chars ([[Char]] = [String]).
08:49:18 <Botje> k23z__: no, it's a statement :) (:: means 'has-type')
08:49:20 <gwern> @check \x (y::Integer) -> x*y == shift (x-1) y
08:49:20 <lambdabot>   Parse error in pattern at "->" (column 17)
08:49:21 <dolio> @check \k n -> (k * 2^n) == shift k n
08:49:21 <lambdabot>   Add a type signature
08:49:37 <dolio> @check \k n -> (k * 2^n) == (shift k n :: Integer)
08:49:37 <lambdabot>   "*Exception: Negative exponent
08:49:40 <k23z__> woo..
08:49:46 <edwardk_> enumerating the cases that actually happen in production code, the cases that look like they'd be worth optimizing are forward single derivative, reverse single derivative (to obtain grad, and most jacobians), forward of reverse (to build hessians), forward towers (rarely useful on their own), forward towers on reverse (higher order derivatives of complicated functions), and unboxed versions of those
08:49:47 <Botje> k23z__: and you're calling splitOn "." wo, that's not correct
08:49:47 <dolio> @check \k n -> n > 0 ==> (k * 2^n) == (shift k n :: Integer)
08:49:47 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:49:48 <lambdabot>                     (Test.QuickCh...
08:49:49 <edwardk_> ski: yeah
08:49:53 <EvilMachine> rokoteko: uum, 'something' does not work, does it?
08:49:54 <dolio> Bah.
08:50:02 <dolio> @check \k n -> n > 0 || (k * 2^n) == (shift k n :: Integer)
08:50:03 <lambdabot>   "*Exception: Negative exponent
08:50:05 <edwardk_> er that probably got clipped
08:50:06 <k23z__> Botje, why ?
08:50:10 <dolio> @check \k n -> n < 0 || (k * 2^n) == (shift k n :: Integer)
08:50:11 <lambdabot>   "OK, passed 500 tests."
08:50:12 <Botje> k23z__: because the types don't match
08:50:23 <Botje> k23z__: you /might/ want map (splitOn ".") wo, but i'm not sure.
08:50:28 <ski> edwardk_ : ".. and unboxed versions of those"
08:50:39 <edwardk_> ski: then it didn't clip =)
08:50:41 <k23z__> Botje, so again, what should I split on ?
08:50:52 <k23z__> "." :: [String] ?
08:50:57 <aavogt> no
08:50:58 <Botje> k23z__: no, that's an error.
08:51:03 <k23z__> ok, so ?
08:51:06 <k23z__> what should I split on ?
08:51:09 <Botje> k23z__: splitOn demands that the types of its two arguments are the same
08:51:10 <aavogt> > "." :: String
08:51:11 <lambdabot>   "."
08:51:12 <edwardk_> ski: counting that up i see about 10 cases worth of AD code worth implementing in a comprehensive library, and the ability to choose the canonically correct choice for most of the combinators provided by Numeric.FAD
08:51:17 <Botje> so you should do map (splitOn ".") wo
08:51:38 <Botje> which will give you a [[String]]
08:51:46 <k23z__> Botje, is that a string list ?
08:51:51 <Botje> a list of list of strings
08:51:55 <k23z__> w?!!
08:51:58 <edwardk_> the only ambiguous case would be jacobian which can be build using forward or reverse and the complexity depends on the size of the arg vs the size of the result
08:52:00 <k23z__> list of list of strings ?
08:52:02 <Botje> k23z__: yes..
08:52:09 <Botje> k23z__: can you explain in english what you want to do?
08:52:23 <gwern> or a list of list of list of chars
08:52:34 <aavogt> > cycle "list of "
08:52:36 <lambdabot>   "list of list of list of list of list of list of list of list of list of li...
08:52:36 <k23z__> Botje, it would ruin the thrill of me trying to solve a problem, but thank for the advice
08:52:42 <gwern> I like saying quark
08:52:47 <k23z__> Botje, please tell me where I can get a type hierarchy of haskell ?
08:52:50 <gwern> quark quark quark
08:52:56 <Botje> k23z__: haskell doesn't have subtyping.
08:53:03 <edwardk_> unboxed single derivative forward automatic differentiation is worth handling separately because it gives me fast "diff?U" operations and they can be stored unboxed in arrays
08:53:09 <gwern> k23z__: no such thing. perhaps you'd prefer a typeclass hierarchy? see typeclassopedia
08:53:10 <k23z__> Botje, what does it have then ?
08:53:14 <Botje> k23z__: types?
08:53:21 <k23z__> gwern, ok that then
08:53:23 <edwardk_> which can matter if i have a lot of them in memory
08:53:31 <aavogt> you're not using typeclasses though
08:53:31 <gwern> there's kinds, I suppose, but I doubt that would help k23z__ either
08:53:31 <Botje> k23z__: to figure out your problem, take a look at the types of splitOf, "." and wo
08:53:44 <EvilMachine> k23z__: there is no hierarchy. and i consider that a good thing.
08:53:55 <k23z__> gwern, what do you suggest would help me ? a strong drink and a cuban cigar ?
08:53:56 <Botje> splitOf needs the same types in its arguments, you're giving it "."::String and wo::[String]
08:54:05 <Botje> which is an error
08:54:29 <gwern> k23z__: no. cuban cigars are illegal to import last I heard.
08:54:32 <k23z__> EvilMachine, I did not argue it wasn't a good thing, I just want to know what possible types there are
08:54:36 <gwern> far be it from me to suggest such a thing
08:54:40 <EvilMachine> k23z__: hookers and booze, and your own space station? :D
08:54:50 <k23z__> EvilMachine, and haskell yeah
08:54:50 <gwern> EvilMachine: blackjack, I think you mean
08:54:51 <edwardk_> the only pain in the neck part is implementing AD 10 times ;)
08:54:56 <EvilMachine> gwern: not here :D
08:55:00 <lodi> Hello all.  Anybody know how I can get cabal to compile a c-program?  And link it with the haskell/ffi library I just had it build?
08:55:15 <Botje> k23z__: there's an infinite amount of types, because you can create new types using e.g. lists and tuples
08:55:19 <EvilMachine> gwern: yes, that too
08:55:22 <edwardk_> though i can probably get away with 3 + anything unboxed i want to deal with
08:55:28 <lodi> or a better place to ask cabal questions is this isn't it?
08:55:39 <k23z__> Botje, ahahhahahaha , comeon man you know what I mean
08:55:40 <lodi> *if
08:55:42 <dcoutts> lodi: just list the c files in the c-sources field
08:55:46 <EvilMachine> Botje: let's say base types
08:56:00 <EvilMachine> Botje: or: everything that was declared with "data"
08:56:21 <Botje> k23z__: (), Int, Float, Double, Char, Boolean
08:56:30 <aavogt> > True :: Boolean
08:56:31 <lambdabot>   Not in scope: type constructor or class `Boolean'
08:56:34 <lodi> dcoutts: what do I put in the main-is field?  it seems to want only haskell sources
08:56:38 <piotr__> jmcarthur, ski, quicksilver: Thanks for explanations. Very educational.
08:56:41 <Botje> argh, is it Bool? I always forget
08:56:42 <k23z__> so those are the primitive types
08:56:48 <k23z__> and is  [[Char]] = String ?
08:56:49 <hpc> :t True
08:56:50 <lambdabot> Bool
08:56:55 <Botje> no. String = [Char]
08:57:00 <jmcarthur> piotr__: you're welcome! hang around
08:57:04 <hpc> [[Char]] is [String]
08:57:05 <Botje> [[Char]] = [String]
08:57:09 <dcoutts> lodi: yes, currently it only supports main being in a Haskell module
08:57:44 <dcoutts> lodi: ah I see what you mean now, ok, so cabal does not help with that bit, just with building the Haskell lib
08:58:01 <dcoutts> lodi: you can use ghc to link the C main with the Haskell lib
08:58:04 <EvilMachine> again: is there a compatibility problem with leksah-server 0.80.02 + ghc 6.10.4 + cabal 1.8.0.4? i can't compile leksah-server here.
08:58:26 <lodi> (basically I'm writing a haskell library to interface with c code, and I wrote a little toy program in c to test it)
08:58:39 <dcoutts> lodi: right, just use ghc directly for the last bit
09:00:09 <ski> edwardk_ : hm, maybe you can generate them ?
09:00:32 <edwardk_> ski: they'd use type families so TH is tricky ;)
09:00:45 <lodi> ok thanks a lot duncan... while I have you here, do you by any chance know what's happening here: http://www.haskell.org/pipermail/haskell-cafe/2010-May/077873.html
09:00:59 <c_wraith> does this just mean that TH needs an update to support more extensions?
09:01:03 <EvilMachine> does anyone recognize this error when compiling leksah-server (or another package): http://pastebin.com/VyN4XqL2
09:01:09 <aavogt> it does support type families
09:01:11 <edwardk_> i'm willing to go through and use the 'view' trick to make unboxed ad cases for floats, doubles and complex floats and doubles, which should cover a good portion of it
09:01:19 <aavogt> but only in the most recent version
09:01:36 <edwardk_> aavogt: *nods*
09:01:43 <dcoutts> lodi: btw, if making C progs with cabal would be really useful to you, there's an open ticket on doing just that, patches would be welcome.
09:01:49 <edwardk_> so a $(deriveAD ''Float) -- wouldn't be impossible then
09:02:01 <Saizan> EvilMachine: the second one means you're trying to use two versions of Cabal (maybe indirectly) in your build
09:02:17 <aavogt> oddly enough, ghc-6.12 allows top level splices without the $( )
09:02:24 <edwardk_> aavogt: yeah
09:02:27 <aavogt> which are allowed without -XTemplateHaskell
09:02:32 <aavogt> I'm not sure if that's a bug
09:02:34 <EvilMachine> Saizan: hmm... yes, that smells like a hint.
09:02:53 * BMeph is pretty sure that it's legal to import Cuban cigars...
09:03:05 <edwardk_> well they explicitly allowed the non-$'d splices, but that they work even without TH flagged is probably a bug
09:03:15 * BMeph means: ...if you're Cuban! ;)
09:03:39 <aavogt> gwern: some fixes happened to HList, you can make a release, or should I?
09:03:42 <EvilMachine> BMeph: In the USA...
09:04:33 <BMeph> EvilMachine: Still legal, if _you_ are Cuban! :)
09:04:45 <EvilMachine> BMeph: yep, I misunderstood you.
09:05:10 <dcoutts> lodi: not sure what is going on there, I'd have to try reproducing it with a full example.
09:05:40 * BMeph isn't sure about the legality of importing Cubans into the USA, though... ;)
09:05:59 <edwardk_> afk a bit
09:06:31 <hpc> cubans are illegal
09:06:42 <hpc> er, cigars or people?
09:06:45 * hpc assumed cigars
09:07:03 <lodi> dcoutts: okay thanks, I'll get that up in a sec...
09:07:05 <EvilMachine> Saizan: Hmm... ghc-6.10.4 requires cabal-1.8*, while leksah-0.8* requires >cabal-1.6.0.1. But with ghc-6.12* haddock and lots of other libraries fails.
09:07:08 <gwern> aavogt: wasn't it already upladed?
09:07:10 <hpc> yeah, cigars are illegal
09:07:10 <tromp> memories of seinfeld...
09:07:54 <k23z__> Botje, ok so basically what you're telling me is to try     let sentences = map (splitOn ".") wo :: [String]
09:08:16 <Saizan> EvilMachine: "ghc-6.10.4 requires cabal-1.8" looks wrong to me, can you paste ghc-pkg list ?
09:08:19 * EvilMachine is happy that cuban cigars are not illegal here. ..and closes the topic. :P
09:08:28 <k23z__> Botje, as a Perl prorammer that makes no sense to me because in Perl it would be      $sentences = map { splitOn($_) } @wo;
09:08:38 <Saizan> EvilMachine: and "ghc-pkg describe ghc"
09:08:44 <EvilMachine> Saizan: yes, i did write it the wrong way around. sorry, hold on...
09:08:51 <k23z__> Botje, we could ommit $_ if splitOn was written to take it by default
09:08:51 * Saizan doesn't have ghc-6.10.x here
09:09:08 <EvilMachine> Saizan: I meant to say: Hmm... ghc-6.10.4 requires cabal-1.6.0.1, while leksah-0.8* requires >cabal-1.8*. But with ghc-6.12* haddock and lots of other libraries fails.
09:10:01 <EvilMachine> Saizan: hence the conflict. (I found a: "Warning: This package indirectly depends on multiple versions of the same")
09:10:12 <Saizan> EvilMachine: haddock should work with ghc-6.12 (you've to upgrade the whole compiler btw, you can't just upgrade the package)
09:10:15 <aavogt> gwern: some changes since apr30
09:10:17 <Schalken> This question might not have a simple answer, but: In JavaScript there is a function setTimeout function to have a function called some number of milliseconds from now. How would I say "run this IO action x seconds from now" in Haskell?
09:10:28 <gwern> aavogt: if you're keen on it, I suppose you can do it
09:10:40 <aavogt> ok, I'll do it later today
09:10:49 <gwern> Schalken: something like 'forkIO (threadDelay x >> action >> return ())'?
09:10:53 <EvilMachine> Saizan: i did previously upgrade ghc to 6.12.1. it worked fine. but haddock failed.
09:11:12 <Saizan> EvilMachine: you mean leksah-haddock?
09:12:10 <EvilMachine> Saizan: no haddock
09:12:37 <Saizan> EvilMachine: http://hackage.haskell.org/packages/archive/leksah-server/0.8.0.6/leksah-server.cabal <- doesn't seem to require Cabal-1.8.* btw
09:12:52 <EvilMachine> Saizan: hmm... interesting
09:13:07 <Saizan> EvilMachine: what happens if you try "cabal install leksah-server --constraint="Cabal == 1.6.0.3" ?
09:13:09 <EvilMachine> Saizan: ah, found it: Dependency Cabal >=1.6.0.1: using Cabal-1.8.0.4
09:13:29 <Schalken> gwern: That would do it. :|
09:13:34 <Schalken> gwern: Thanks.
09:13:34 <EvilMachine> Saizan: can't use cabal install here, since that messes up the package manager. :/
09:13:37 <Saizan> err, mismatched " there, but you get the point :)
09:13:51 <EvilMachine> Saizan: (the OS-native one)
09:13:54 <Saizan> EvilMachine: how come? cabal install installs things locally?
09:13:56 <gwern> @hoogle threadDelay
09:13:56 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
09:14:03 <duairc> Why exactly does this code require both flexible instances and undeciable instances? http://paste.lisp.org/display/99471
09:14:53 <Saizan> EvilMachine: anyhow, you can pass --constraint="Cabal == 1.6.0.3" to Setup configure too
09:14:54 <c_wraith> duairc: by itself, that block requires neither.
09:15:05 <EvilMachine> Saizan: i guess it's a bug. using cabal install with root installs packages in root's home dir like expected. but then the package manager picks them up anyway. stupid, i know.
09:15:06 <c_wraith> duairc: you're probably declaring another instance of Functor' somewhere?
09:15:19 <EvilMachine> Saizan: i'll check that.
09:15:20 <zygoloid> i have a C struct in a header which I'd like to use from haskell via the FFI, but I don't know what fields it has. I want something like: newtype MyCStruct = MCS Map String Dynamic, with an appropriate Storable instance
09:15:54 <zygoloid> is there a C ~> haskell convertor which can do that? (I can roll one myself with Language.C and TH but would rather not duplicate the effort...)
09:17:10 <duairc> c_wraith: I'm not, that's literally the whole file, and when I run it with GHCi it says "Illegal instance declaration for `Functor' m" and then suggests -XFlexibleInstances and when I do that it suggests -XUndecidableInstances and then eventually works
09:17:57 <c_wraith> duairc: oh, I see.  GHC actually interprets that as declaring an instance for *all* types.
09:18:16 <c_wraith> duairc: well, all types with kind * -> *
09:18:32 <zygoloid> duairc: well, it certainly needs FlexibleInstances, but i can't see why it needs UndecidableInstances
09:18:57 <jmcarthur> zygoloid: it's not 100% automatic, but http://hackage.haskell.org/package/bindings-DSL has some nice macros to help
09:19:03 <zygoloid> oh, right, the context is no smaller than the instance head
09:19:22 <jmcarthur> zygoloid: you still have to name and type the fields, but it generates the actual accessors and Storable instances and stuff
09:19:47 <zygoloid> jmcarthur: yeah, i looked at that. it doesn't seem so helpful given that i don't know what the fields are called (they vary between platforms)
09:19:49 * BMeph things ":t let sentences = map (splitOn ".") wo  in sentences" should respond: "sentences:: [[String]]"
09:19:53 <jmcarthur> ew
09:20:03 <jmcarthur> i don't know of anything else
09:20:21 <jmcarthur> zygoloid: if you don't know what the fields are called then how will you access them?
09:20:36 <jmcarthur> or do you not intend to at all outide of Storable?
09:20:48 <zygoloid> jmcarthur: something like a Map String Dynamic :)
09:20:51 <jmcarthur> *of the Storable instance
09:20:53 <jmcarthur> ah
09:21:07 <k23z__> can someone here explain this ? splitOn :: Eq a => [a] -> [a] -> [[a]]
09:21:11 <duairc> c_wraith, zygoloid: http://www.haskell.org/ghc/docs/6.10-latest/html/users_guide/type-class-extensions.html#instance-rules seems to imply that it's a perfectly valid instance declaration by Haskell 98
09:21:11 <jmcarthur> okay i'm pretty sure you will have to hack that together yourself
09:21:13 <zygoloid> i think maybe i'll just hard-code it for the two platforms i care about
09:21:50 <zygoloid> duairc: h'98 instances must be of the form "instance ctx => Class Type var1 var2 ..." where var1, var2 are variables and Type is not iirc
09:21:56 <gwern> k23z__: seems perfectly explicable. what do you not understand?
09:22:12 <Berengal> k23z__: splitOn is a function that takes two arguments that are lists of a type 'a' that can be compared for equality and returns a list of lists of type 'a'
09:22:20 <zygoloid> duairc: in your case, Type is a type variable
09:22:29 <k23z__> gwern, the parameters are Eq and a right ?
09:22:34 <k23z__> gwern, the types of the parameters
09:22:38 <duairc> zygoloid: Ah okay, I see that now
09:22:53 <sepp2k> k23z__: The types of the parameters are [a] and [a]
09:23:05 <gwern> k23z__: there's just one type involved, which must be an implementor of Eq; there are multiple arguments of that one type
09:23:06 <sepp2k> Eq is a typeclass that has to be instantiated by a
09:23:10 <k23z__> for real ?
09:23:29 <zygoloid> duairc: as for the undecidable instances thing, the termination checking requires that the context be "smaller" than the instance head. "Monad m" is no smaller than "Functor' m"
09:23:37 <sepp2k> The part before the => is a type constraint.
09:23:54 <zygoloid> (imagine if there were also an instance Functor' m => Monad m to see why that's necessary)
09:24:05 <sepp2k> What comes after the => are the arguments and the return type.
09:24:21 <gwern> k23z__: be it so amazing?
09:24:22 <BMeph> k23z__:  ^^
09:24:56 <duairc> zygoloid: Hmmm, okay. So you can't in general automatically make every type that is an instance of A be an instance of B?
09:25:12 <zygoloid> duairc: not in haskell'98.
09:25:22 <Twey> Not 'til class aliases, no?
09:25:45 <zygoloid> but there's no need to, because that would make class B worthless.
09:26:05 <jmcarthur> B can be a synonym for A
09:26:11 <gwern> zygoloid: really? so I couldn't do something like 'instance Bool a => ReverseBool where rtrue :: a -> Bool; rtrue a = not a'?
09:26:13 <jmcarthur> it doesn't add anything new, but i wouldn't call it worthless
09:26:15 <zygoloid> (class B's members could be changed to have an A constraint instead of a B constraint and the result would be the same)
09:26:43 <EvanR-work> cool. ubuntu (at least the version on our server) does not have a haskell platform package. and we 'only' have 512M ram on that virtual machine... compiling (linking it seems) is making it thrash like crazy and going very slow
09:26:46 <jmcarthur> still requires overlapping instances though
09:26:50 <Berengal> zygoloid: Not really useless. Every Monad is a Functor, but not every Functor is a Monad
09:26:53 <zygoloid> gwern: the general case covers more interesting instances
09:27:20 <Berengal> zygoloid: So (Monad m) => Functor m doesn't cover all instances of Functor
09:27:21 <zygoloid> Berengal: you can't make every type that is an instance of Monad be an instance of Functor without making every type be an instance of Functor.
09:27:22 <duairc> Is every Monad actually a functor though or do you have to explicilty make an instance of Functor for every Monad?
09:27:27 <zygoloid> (with a Monad side-condition)
09:27:42 <stroan> you need to instance Functor
09:27:45 <Berengal> zygoloid: Not in vanilla Haskell.
09:27:56 <jmcarthur> duairc: unfortunately you have to do it explicitly
09:27:58 <Berengal> zygoloid: You can with some unadvisable magic.
09:28:01 <jmcarthur> duairc: same for Applicative
09:28:26 <zygoloid> Berengal: even IncoherentInstances doesn't violate that. but it does allow you to specialize the instances...
09:29:20 <zygoloid> at least Applicative has a Functor constraint, so you are required to write the instance :)
09:29:21 <Berengal> zygoloid: Well, true enough. You won't get your program to compile without either a Monad or Functor instance for your type when you use it though.
09:29:26 * zygoloid looks disapprovingly at class Monad
09:30:10 <zygoloid> Berengal: fair point :)
09:30:23 <dcoutts> EvilMachine: oh you mean it's a bug in the distro package management that it looks for packages registered in the per-user package db belonging to root?
09:30:48 <dcoutts> EvilMachine: ping
09:30:54 <duairc> Is it considered a problem that there is no way of automagically making all Monads Functors?
09:31:05 <duairc> Or am I missing something by wanting to do that?
09:31:24 <Olathe> @src Functor
09:31:24 <lambdabot> class  Functor f  where
09:31:24 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:31:25 <Berengal> duairc: It offends my aesthetics, but otherwise it's not a large problem
09:31:26 <dcoutts> EvilMachine: re your earlier conversation, do mean that it is a bug in the distro package management that it looks for packages registered in the per-user package db belonging to root?
09:32:07 <Olathe> Is it possible to have a monad that's not a functor ?
09:32:11 <Apocalisp> no
09:32:25 <vmixey> :t (>>=)
09:32:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:32:27 <lodi> dcoutts: okay sorry for the delay, here's the example:  http://pastebin.com/aLdyFMPg
09:32:28 <Berengal> Only if it's not really a monad (i.e. it doesn't follow the laws)
09:32:39 <Olathe> Ahh, OK.
09:32:41 <vmixey> :t (=<<) (return . ?f)
09:32:42 <lodi> dcoutts: let me know if you want it in another format
09:32:42 <lambdabot> forall a (m :: * -> *) a1. (Monad m, ?f::a1 -> a) => m a1 -> m a
09:32:47 <vmixey> that's fmap there
09:32:50 <duairc> (=<<).(return.) is fmap for all monads
09:32:51 <duairc> Yeah
09:32:58 <pchiusano> hi, can anyone tell me something about this datatype: data Foo f a = Pure a | Wrap (f a), assuming Zip f ?
09:33:01 <vmixey> you can prove the functor laws from the monad laws now
09:33:22 <quicksilver> duairc: there is a fairly good way of doing it, which is to make Functor a superclass of Monad.
09:33:41 <vmixey> oh yeah that's a good point
09:33:51 <quicksilver> duairc: I believe the reason they didn't was that would force all Monad authors to supply a Functor instance before they could write their Monad instance.
09:33:52 <vmixey> one way to define monad is {bind,return} but another way is {fmap,join,return}
09:34:00 <EvilMachine> dcoutts: yes
09:34:04 <pchiusano> general idea is that Pure a `zip` f b == fmap (\b -> (a, b)) (f b)
09:34:04 <quicksilver> if that is, indeed, the reason, I think it's daft.
09:34:06 <vmixey> so immediately we see that monads are functors
09:34:08 <duairc> quicksilver: Would it though? I mean when you have a default implementation
09:34:17 <lodi> (I'm linking manually like this:  ghc -o ctest -threaded -L. -lfoo ctest.o -optl-Wl,-rpath,'$ORIGIN'
09:34:22 <quicksilver> duairc: you can't have a default implementation for Functor basd on Monad, no
09:34:31 <quicksilver> duairc: because Functor is the superclass of Monad, not the other way around.
09:34:54 <quicksilver> you could have a default implementation of Monad based on functor, but, weirdly, that doesn't make it any easier.
09:35:04 <quicksilver> even given fmap, you still have to define two things.
09:35:13 <Berengal> quicksilver: I think the real reason is that they didn't think of it
09:35:24 <quicksilver> Berengal: I don't believe that for a moment. How could they not think of it?
09:35:33 <quicksilver> it's not like they didn't know what superclasses were and what they were for.
09:35:58 <Berengal> quicksilver: Because it's more forgiveable?
09:36:13 <quicksilver> ;)
09:36:25 <lodi> and the error in the cabal case is:  ./libHStest-0.0-ghc6.12.1.so: undefined reference to `__stginit_CInterface'
09:36:31 <duairc> Hehe
09:36:40 <quicksilver> Berengal: in 1994, Functor was a superclass of Monad.
09:36:45 <Berengal> :(
09:37:25 <quicksilver> "...I think this was the wrong decision, but I seem to remember that the rationale was that it would be too onerous to require programmers to write a Functor instance every time they want a Monad instance.  Bah!..."
09:37:26 <Berengal> I also hear fmap was called map back then...
09:37:34 <quicksilver> ^^ that quote from augustss
09:37:45 <Berengal> augustss++
09:38:04 <ski> (imo, we need a way to provide default implementations of methods of `C' in a subclass `D' of `C')
09:38:38 <quicksilver> ski: I keep being told that there are problems with the various variants of the class alias / subclass proposal floating around.
09:38:42 <Berengal> imo we need reified typeclasses...
09:38:45 <quicksilver> of course I can't remember what the actual problems are.
09:38:53 <vmixey> Berengal, what does that mean?
09:39:01 <ski> (quicksilver : also, `instance Functor Blah where fmap = default_fmap_from_Monad' .. but you know this)
09:39:04 <Berengal> vmixey: You can manipulate them like any other value
09:39:11 <vmixey> can't i alrready do that?
09:39:17 <Berengal> No, they're not a value
09:39:23 <vmixey> with records
09:39:25 <Berengal> You can't take the Eq instance of Int and stuff it in a list
09:39:50 <vmixey> data Eq a = EqInstance { (==) :: a -> a -> Bool }
09:39:52 <Berengal> You can use records to the same effect, but they're not the same. I want to make them the same
09:40:00 <EvilMachine> Berengal: sounds as if it would be cool if you could, though...
09:40:03 <vmixey> why should thye be the same?
09:40:04 <dcoutts> lodi: what ghc and cabal version are you using?
09:40:13 <vmixey> I mean what if you just don't use any typeclasses at all
09:40:16 <vmixey> then everything is the same
09:40:28 <ski>   data EqInstance a where EqInstance :: Eq a => EqInstance a  -- does this work ?
09:40:37 <Berengal> Typeclasses would be a mechanism for "inferring values" depending on types, but if you felt non-conformist you could provide that value explicitly
09:40:49 <quicksilver> ski: I think so, yes.
09:40:51 <vmixey> that is currently possible
09:40:56 <lodi> dcoutts: ghc 6.12.1, cabal 0.8.2, caballibrary 1.8.0.2
09:41:06 <quicksilver> also, you can just do this:
09:41:17 <quicksilver> > [(==) :: Int -> Int -> Bool]
09:41:18 <lambdabot>   Overlapping instances for GHC.Show.Show
09:41:18 <lambdabot>                              (GHC.T...
09:41:27 <quicksilver> so I'm not quite sure what Berengal means by 'can't just stuff it in a list'
09:41:32 <quicksilver> you can, and I just did.
09:41:51 <ski> quicksilver : but how do you then pass that to `elem' (not `elemBy') ?
09:41:52 <aristid> :t [(==) :: Int -> Int -> Bool]
09:41:53 <lambdabot> [Int -> Int -> Bool]
09:42:03 <dcoutts> lodi: ok here's the reason
09:42:11 <quicksilver> data EqReify a = { eq :: a -> a -> Bool }
09:42:12 <dcoutts> lodi: it's all about symbol names
09:42:21 <Berengal> quicksilver: No, you just stuffed a function in a list. That's the same as [intEq (==)], which is not the same as [intEq], assuming intEq :: EqDict Int
09:42:25 * ski thinks Berengal wants integration with the existing class constraint system
09:42:47 <quicksilver> mkEqReify :: Eq a => EqReify a; mkEqReify = EqReify { eq = (==) }
09:43:00 <quicksilver> Berengal: I know what I did. What I don't know is what you meant.
09:43:01 <dcoutts> lodi: when you compile a hs file using just ghc -c foo.hs, it is part of the "main" package.
09:43:37 <dcoutts> lodi: when you build a module that is intended to be part of a Haskell/ghc package, then it gets a package name (ghc -package-name foo-1.0)
09:43:42 <Berengal> quicksilver: Basically, I want to use records instead of type classes, and have a defaulting mechanism in the compiler that defaults certain arguments to certain values based on the types of other arguments
09:43:51 <dcoutts> lodi: that package name gets baked into the internal symbols
09:43:52 <quicksilver> ski: my version lets you talk about them even in the absence of an Eq instance, and then use the instance explicitly if you want to.
09:44:06 <ski> quicksilver : how do you write `EqReify a -> (Eq a => f a) -> f a', then ?
09:44:07 <quicksilver> ski: but is otherwise similar to yours.
09:44:12 <lodi> dcoutts: oh wow I just got it... the cabal version is exporting it with the package name built in right?
09:44:34 <lodi> dcoutts: right... so __stginit_testzm0zi0_CInterface
09:44:41 <quicksilver> ski: well, if you give me local data and local instance....
09:44:42 <ski> (or i suppose `f a' could be simplified to `o', in this case=
09:44:43 <dcoutts> lodi: exactly __stginit_testzm0zi0_CInterface (package "test-0.0") vs __stginit_CInterface (package "" aka package main)
09:44:43 <ski> )
09:44:52 <ski> quicksilver : .. exactly
09:45:02 <dcoutts> @zdecode __stginit_testzm0zi0_CInterface
09:45:03 <lambdabot> Unknown command, try @list
09:45:16 <ski> quicksilver : i believe something like that was Berengal's point
09:45:38 <lodi> dcoutts: so I have to manually synchronize that export when I bump up the package version?
09:45:46 <EvilMachine> Hey, which ghc flags are generally a good idea? I love -dynamic. -O2 also sounds like a good idea. And -threads too. But what else would you generally recommend?
09:45:53 <vmixey> preflex: zdec __stginit_testzm0zi0_CInterface
09:45:53 <preflex>  __stginit_test-0.0_CInterface
09:45:54 <Berengal> quicksilver: Say you want to sort a list in reverse, but sortBy is illegal in your country of residence. In my ideal world you could go "(\{ordDict :: OrdDict a} -> sort {reverseOrdDict ordDict})"
09:46:03 <dcoutts> vmixey: ah, thanks
09:46:21 <ski> Berengal : btw, do you want to scrap coherence ?
09:46:27 <dcoutts> lodi: alternatively, you can hack it and specify -package-name "" or something like that in the .cabal file.
09:46:35 <quicksilver> Berengal: in general, that construct breaks invariants
09:46:47 <quicksilver> Berengal: ...in particular, the kind of invariant currently guaranteed by type classes.
09:47:00 <quicksilver> which some people have described hyperbolically as the entire point of typeclasses.
09:47:05 <quicksilver> (some people == quicksilver)
09:47:05 <dcoutts> lodi: I think this is also an excellent opportunity to complain to the ghc devs that this init stuff is even necessary, given how hard it is to do.
09:47:09 <Berengal> ski: No, not really. I admit I haven't worked out the quirks, or tears for that matter
09:47:27 <lodi> dcoutts: okay that actually makes a lot of sense now... thanks!
09:47:37 <dcoutts> lodi: ie email the ghc users list and/or file a ticket giving this example and how it's totally confusing, even to experts.
09:47:40 <quicksilver> \({ordDict :: ordDict a} -> insert x m ordDict)
09:47:46 <quicksilver> I'm not really sure what your syntax means
09:47:50 <lodi> dcoutts: well I've found that I don't even need that line sofar, but I'm not sure if something will break later on if I omit it
09:47:57 <quicksilver> but by locally overrider the ord-dict for a single call to insert, you break the Data.Map
09:48:02 <quicksilver> I'm sure you get the idea :)
09:48:28 <dcoutts> lodi: I think it's needed only in some circumstances, but that's only a quirk of the implementation. I think it is essential for profiling builds.
09:48:30 <quicksilver> even via my incoherent spelling and sentence construction, hopefully.
09:48:38 <lodi> dcoutts: not sure if it's something that they've deprecated for 6.12, but it's still in teh manual
09:48:54 <Berengal> quicksilver: Yes, I do, and yes, it's easy to ruin things that way. You could solve it by storing the ord instance in the map though...
09:49:07 <lodi> dcoutts: yes I found a mailing list post from one of the simons that mentioned something about it only being used for profiling
09:49:08 <ski> Berengal : then you lose merges
09:49:12 <Berengal> quicksilver: But in general, there is more opportunity for messing things up
09:49:22 <dcoutts> lodi: it's not deprecated, to "do it right" according to the ghc devs you still have to do that stuff, it just happens not always to be necessary at the moment, but no guarantees.
09:49:46 <dcoutts> lodi: and we should complain about how hard it is to "do it right"
09:50:22 <quicksilver> Berengal: my current view on this is that really by doing this you are ditching almost everything good about type classes.
09:50:32 <quicksilver> Berengal: you may be inventing something which is, itself, useful and powerful
09:50:35 <quicksilver> but it's not typeclasses.
09:50:51 <quicksilver> you couldn't safely use the Monad typeclass if (>>) could be locally overriden, etc etc.
09:51:14 <lodi> dcoutts: okay thanks again for the help, I'll send this example upstream as you suggested
09:51:39 <ski> there might be a disciplined way of doing these local overrides .. but i'm not sure what it is
09:51:46 <dcoutts> lodi: ok great
09:52:25 <dcoutts> lodi: convincing examples of real people doing useful stuff getting confused is always more convincing than complaints from me :-)
09:52:27 <Berengal> quicksilver: I know it stuffs things up badly. That's why I'm not really shouting too loud about it. Perhaps having both would be possible, so you could use typeclasses when you need coherence, and implicit records when you just need the polymorphism
09:52:29 <k23z__> si there an equivalent to typeof() ?
09:52:45 <k23z__> like I have something and I wanna see what type it is
09:52:53 <k23z__> I'm in ghci right now
09:53:02 <Berengal> k23z__: :type
09:53:03 <zygoloid> quicksilver: it's already possible to write a non-law-abiding Monad instance
09:53:18 <k23z__> Berengal, where do I write that ?
09:53:21 <zygoloid> would Berengal's proposal change things that much?
09:53:26 <Berengal> k23z__: On the prompt
09:53:27 <ski> k23z__ : `:type map length ["ab","cde"]', e.g.
09:54:07 <zygoloid> Berengal: what you want seems basically to be achievable with implicit parameters
09:54:53 <k23z__> seems to work
09:55:00 <jmcarthur> i think i would rather use sortOn than messing with dictionaries like that :)
09:55:00 <Berengal> zygoloid: And a defaulting mechanism so the compiler knows which values to provide
09:55:14 <zygoloid> Berengal: right. top-level ?foo =  bindings, perhaps
09:55:29 <Berengal> zygoloid: Soemthing like that
09:55:40 <lodi> dcoutts: I'm just shocked that I didnt' put two and two together when I saw '_testzm0zi0_' in the nm output.  Now I know to use descriptive package names, even in toy programs :-)
09:55:41 <Berengal> Hmm, that could actually work...
09:57:41 <dcoutts> lodi: :-)
09:58:22 <zygoloid> > let sort' = sortBy ?cmp in   let ?cmp = flip compare in sort' [1,4,2,3]
09:58:23 <lambdabot>   [4,3,2,1]
09:58:41 <gwern> what's with the ??
09:58:50 <jmcarthur> :t sortOn
09:58:50 <zygoloid> can i build multiple cabalized packages out of the same directory?
09:58:50 <lambdabot> Not in scope: `sortOn'
09:59:00 <jmcarthur> @let sortOn = sortBy . comparing
09:59:01 <lambdabot>  Defined.
09:59:54 <gwern> zygoloid: I don't think so; there's nowhere in 'runhaskell Setup.hs foo' to specify a .cabal or another
10:00:27 <ski> @type sortOn
10:00:28 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
10:00:33 <jmcarthur> that sortOn could probably be made more efficient
10:00:41 <EvilMachine> jmcarthur: hey, can everybody define stuff with let like that? sounds like it's easy to abuse lambdabot that way...
10:00:49 <dcoutts> gwern: the way I imaging extending it is to say cabal configure foo (meaning foo.cabal)
10:00:51 <jmcarthur> EvilMachine: yes and yes
10:00:58 <EvilMachine> jmcarthur: oh-oh
10:01:03 <jmcarthur> but you can also undefine them all in one swoop
10:01:06 <Saizan> fsvo abuse
10:01:07 <gwern> @unlet
10:01:08 <lambdabot>  Defined.
10:01:12 <gwern> oops?
10:01:14 <ski> hehe
10:01:15 <EvilMachine> jmcarthur: ah, ok. luckily
10:01:16 <dcoutts> zygoloid: the answer is no, not at the moment.
10:01:16 <EvilMachine> lol
10:01:23 <jmcarthur> :t sortOn
10:01:24 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
10:01:37 <gwern> dcoutts: I'm not sure that should be supported anyway; where do we want multiple .cabals in the same dir?
10:01:55 <c_wraith> @undefine
10:01:58 <jmcarthur> lambdabot is shared, mutable state
10:01:59 <jmcarthur> :t sortOn
10:02:00 <lambdabot> Not in scope: `sortOn'
10:02:02 <dcoutts> gwern: well I certainly want cabal to work with multiple packages in different local dirs
10:02:13 <gwern> EvilMachine: and if you can abuse mueval just by defining functions, then that's a bug anyway because of 'let'
10:02:25 <gwern> dcoutts: but we already have cabal working in differet local dirs...
10:02:30 <dcoutts> gwern: it's probably handy to people during development. It does not prevent them being distributed separately.
10:02:35 <EvilMachine> gwern: no idea what a mueval is...
10:02:48 <dcoutts> gwern: but I mean in one go, cabal install ./foo/ ./bar/
10:02:49 <gwern> EvilMachine: the executable that lambdabot invokes on all >s
10:02:50 <c_wraith> mueval is the execution engine lambdabot uses
10:03:03 <EvilMachine> gwern: ah, ok
10:03:22 <zygoloid> > let ?x | True = 42 in ?x
10:03:23 <lambdabot>   <no location info>: Parse error in pattern
10:03:25 <zygoloid> > let x | True = 42 in x
10:03:26 <lambdabot>   42
10:03:28 <zygoloid> weird
10:03:34 <dcoutts> gwern: fear not, I will not compromise on individual cabal packages being distributed individually in tarballs, no bundling multiple .cabal packages in a single tarball on hackage.
10:03:46 <Saizan> dcoutts: well, if instead of directories you take .cabal files as arguments you cover both cases :)
10:03:51 <gwern> oh so we won't engage in *utter* madness. that's good to know
10:04:13 <dcoutts> Saizan: well not quite, since it needs support from the Setup.hs to do multiple .cabal files in a single dir.
10:04:22 <dcoutts> gwern: :-)
10:04:42 <gwern> zygoloid: are you trying to use implicit variables? I'm not sure those are enabled in mueval
10:04:45 <dpratt71> something I've been wondering about lambdabot: when I do something like this:
10:04:50 <dcoutts> gwern: people used to suggest "distributions" you know, multiple packages bundled in one distributable tarball
10:04:52 <dpratt71> > let x = 5
10:04:54 <lambdabot>   not an expression: `let x = 5'
10:04:57 <zygoloid> > let sort' = sortBy ?cmp in   let cmp a b | a .&. b == a = GT | a .&. b == b = LT | otherwise = EQ in let ?cmp = cmp in sort' [1..10 :: Int]
10:04:59 <lambdabot>   [7,3,5,9,1,6,10,2,4,8]
10:04:59 <gwern> or if they are, I need to figure out how to kill implicit vars in mueval...
10:05:04 <dpratt71> hmm
10:05:15 <Saizan> gwern: why do you have to kill them?
10:05:15 <dpratt71> how to "define" something
10:05:16 <gwern> dcoutts: ick. although I can sort of understand that
10:05:17 <dpratt71> ?
10:05:21 <zygoloid> gwern: they certainly are. but anything more complex than 'let ?x = y' seems to be a parse error
10:05:25 <Saizan> @let x = 5
10:05:26 <lambdabot>  Defined.
10:05:36 <dpratt71> Saizan: thanks
10:05:37 <jmcarthur> it would be nice to show flags you can enable for the build on hackage and/or in cabal-install package listings
10:05:39 <gwern> Saizan: because they seem horrible to me and make code less clear and whatnot
10:05:44 <dcoutts> Saizan: but yes, I'd also like to let people use .cabal files as targets in cabal-install, but subject to the one per dir constraint.
10:05:58 <dpratt71> so my question is, is "x = 5" true for everyone?
10:05:59 <zygoloid> > let y = 0 in let ?x = y in ?x
10:06:00 <lambdabot>   0
10:06:06 <zygoloid> > let y = 0; ?x = y in ?x
10:06:06 <dcoutts> Saizan: and .tar.gz packages
10:06:07 <lambdabot>   <no location info>: Parse error in pattern
10:06:19 <dpratt71> and how long does lambdabot remember "x = 5"?
10:06:27 <jmcarthur> and it would also be nice to be able to put those flags on the packages listed in build-depends
10:06:36 <jmcarthur> but then we'd have a lot of conflicts i think
10:06:37 <zygoloid> dpratt71: yes, for everone, and until someone does an @undef
10:06:45 <Saizan> gwern: doesn't make much sense to me, are you going to enforce good indentation and a naming convention too?:)
10:06:56 <aristid> zygoloid: or when it is reset?
10:07:03 <gwern> Saizan: no. too much work. also, how would we do indentation in >?
10:07:07 <dpratt71> zygoloid: interesting; seems as though that could occaisionally produce confusion
10:07:26 <jmcarthur> dpratt71: when it does you just undef
10:07:46 <Saizan> gwern: you can use more or less whitespace and put the braces differently etc..
10:07:53 <jmcarthur> @undefine
10:07:59 <jmcarthur> > x
10:08:00 <lambdabot>   x
10:08:14 <vmixey> > f x x
10:08:15 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:08:15 <lambdabot>    `GHC.Show.Show a'
10:08:15 <lambdabot>      a...
10:08:36 <dpratt71> @let x = 5
10:08:37 <lambdabot>  Defined.
10:08:42 <dpratt71> > x
10:08:43 <lambdabot>   Ambiguous occurrence `x'
10:08:43 <lambdabot>  It could refer to either `L.x', defined at <local...
10:08:48 <jmcarthur> > foldr f z [a,b,c,d]
10:08:49 <lambdabot>   f a (f b (f c (f d z)))
10:08:56 <dpratt71> > L.x
10:08:58 <lambdabot>   5
10:09:02 <dpratt71> interesting
10:09:22 <Berengal> Implicit defs aren't bad. They show up in the constraints.
10:09:26 <dpratt71> what would be the other "x"?
10:09:36 <jmcarthur> dpratt71: expressions, like this:
10:09:38 <jmcarthur> > a
10:09:38 <vmixey> x = var "x" or something
10:09:39 <lambdabot>   a
10:09:53 <Berengal> > var "x"
10:09:54 <lambdabot>   x
10:09:58 <jmcarthur> @undefined
10:09:59 <jmcarthur> > x
10:10:00 <lambdabot>   x
10:10:01 <jmcarthur> oops
10:10:02 <Berengal> > var "x" == x
10:10:03 <lambdabot>   Couldn't match expected type `Data.Number.Symbolic.Sym a'
10:10:04 <lambdabot>         against i...
10:10:04 <jmcarthur> well that worked too
10:10:29 <dpratt71> > z
10:10:30 <lambdabot>   z
10:10:35 <dpratt71> > aaa
10:10:36 <lambdabot>   Not in scope: `aaa'
10:10:38 <Berengal> @type x
10:10:39 <lambdabot> Expr
10:10:43 <Berengal> @type var "x"
10:10:44 <lambdabot> forall a. Sym a
10:11:00 <jmcarthur> @type text "x"
10:11:01 <lambdabot> Doc
10:11:05 <k23z__> anybody know where I can find a copy of "real world haskell" offline please ?
10:11:08 <jmcarthur> > text "x"
10:11:09 <lambdabot>   x
10:11:11 <Saizan> ?type z
10:11:11 <lambdabot> Expr
10:11:22 <k23z__> I know it also has many comments from users , if it's possible I'd like that also
10:11:27 <Saizan> ?type var "x"
10:11:27 <lambdabot> forall a. Sym a
10:11:38 <jmcarthur> k23z__: the comments are only on the online version
10:11:53 <jmcarthur> k23z__: i've seen the dead tree version at my local barnes and noble
10:13:14 <jmcarthur> k23z__: if you can't find it locally you could always just order online
10:13:26 <k23z__> jmcarthur, thanks
10:20:07 <Gracenotes> well well, Happstack.Server.MessageWrap is oddly named
10:35:21 <tromp> :t sqrt
10:35:22 <lambdabot> forall a. (Floating a) => a -> a
10:35:31 <tromp> > sqrt 28 :: CReal
10:35:32 <lambdabot>   5.2915026221291811810032315072785208514205
10:36:06 <tromp> > (sqrt 28)**(2%3) :: CReal
10:36:07 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
10:36:07 <lambdabot>         against infe...
10:36:14 <tromp> :t (**)
10:36:15 <lambdabot> forall a. (Floating a) => a -> a -> a
10:36:32 <tromp> > (sqrt 28)**(2/3) :: CReal
10:36:33 <lambdabot>   3.0365889718756625194208095785056696355815
10:37:04 <tromp> > (sqrt 28+sqrt 27)**(2/3) + (sqrt 28-sqrt 27)**(2/3) :: CReal
10:37:05 <lambdabot>   5.0
10:37:51 <BMeph> tromp: After your chess-pos kick, have you thought about doing your LC-magic using Jay and Given-Wilson's F combinator? :)
10:39:01 <tromp> what is the F combinator?
10:39:55 <tromp> reading a PDF about it...
10:41:27 <BMeph> tromp: ...right. Sorry for being slow. :)
10:42:35 <aristid> @pl f x y = not . (x y)
10:42:36 <lambdabot> f = ((not .) .)
10:42:48 <aristid> @pl f y = not . (id y)
10:42:48 <lambdabot> f = (not .)
10:42:56 <aristid> @pl f y = not . ((+) y)
10:42:57 <lambdabot> f = (not .) . (+)
10:43:22 <Botje> k23z__: sorry, i was on the train
10:43:35 <pastorn> @type (not .)
10:43:36 <lambdabot> forall (f :: * -> *). (Functor f) => f Bool -> f Bool
10:43:39 <k23z__> Botje, you were on the train ... ok
10:43:40 <Botje> k23z__: i'm a perl programmer as well (do you visit #perl regularly?)
10:43:57 <k23z__> Botje, I am banned permanently without any chance of getting back to #perl
10:44:06 <k23z__> Botje, but you must know that already since you're asking
10:44:20 <pastorn> k23z__: haha... how did you do that?
10:44:27 <Botje> k23z__: haskell's types make what you want impossible
10:44:36 <k23z__> pastorn, do what ?
10:44:44 <tromp> BMeph funny that F is square root of K :)
10:44:44 <pastorn> permban from #perl
10:45:02 <k23z__> pastorn, I was perm banned from #perl on FreeNode and g-lined on all of irc.perl.org
10:45:33 <ben_m> Is there a debugger for Haskell?
10:45:37 <silver> lol why?
10:45:40 <ben_m> one that lets me step through my program
10:45:46 <ben_m> and inspect values
10:45:53 <Berengal> ben_m: ghci has one built in
10:46:08 <ben_m> ooh.
10:46:19 <Berengal> ben_m: But usually "stepping through the program" is useless
10:46:45 <Berengal> Since Haskell programs don't have a concept of steps
10:46:46 <ben_m> I think it would help me in this case
10:46:47 <ben_m> :)
10:47:02 <ben_m> solution to one of the puzzles you can find on facebook
10:47:05 <ben_m> "solution"
10:47:10 <BMeph> tromp: Ain't it, though? :)
10:47:12 <k23z__> silver, I used extremely strong language repeatedly with an operator
10:47:20 <ben_m> Gives me wrong results so I wanted to see what it does on each recursion step
10:47:31 <k23z__> silver, because I thought he was acting inappropriately
10:47:55 <tromp> BMeph: looks very neat! i'll sure think about the implications for shortest universal machines
10:48:04 <silver> oh ok, I thought you just hate perl
10:48:28 <k23z__> silver, actually I write some high-level Perl, to the point where Perl cannot express what I want to say with it ...
10:48:41 <Kaidelong> parMap rwhnf (^2) [1..10]
10:48:44 <Kaidelong> > parMap rwhnf (^2) [1..10]
10:48:45 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:48:50 <k23z__> silver, that's why I'm here
10:48:55 <Kaidelong> about to post a blog entry
10:48:57 <silver> hehe
10:49:13 <pastorn> @type parMap
10:49:14 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
10:49:19 <pastorn> @type rwhnf
10:49:20 <lambdabot> forall a. a -> Done
10:49:41 <pastorn> Kaidelong: what have you done?!
10:50:21 <Kaidelong> pastorn: mapped (^2) over a list in parallel? I think that's what I did, anyway
10:51:11 <BMeph> tromp: The only caveat I see it that everything F works on has to have a normal form.
10:52:10 <tromp> so does everything S works on:)
10:52:52 * BMeph waits breathlessly for Kaidelong to drop another blog in the pool...
10:53:14 <Kaidelong> BMeph you flatter me
10:53:24 <Kaidelong> it's done and ready for flames
10:53:28 <Kaidelong> I'll get it posted
10:53:54 <Kaidelong> http://advfp.blogspot.com/2010/05/parallel-programming-in-haskell.html
10:54:37 <Kaidelong> done using the blogspot wysiwyg
10:54:40 <Kaidelong> I'm not happy with it
10:55:14 <Botje> k23z__: so, did you make any progress in your problem?
10:57:15 <BMeph> Hmm, I should try that with my free tree counter, it's wicked-recursive...
10:59:20 <lodi> dcoutts: okay, I found a year-old ticket of my issue so I added my specific details: http://hackage.haskell.org/trac/ghc/ticket/3252#comment:4
10:59:33 <k23z__> Botje, some yes...
10:59:58 <k23z__> Botje, how do I print in a compiled Haskell program like I do when I'm in the ghci and I just write the name of the variable ?
11:00:07 <k23z__> Botje, like the equivalent of Data::Dumper from Perl
11:00:22 <lispy> k23z__: print
11:00:24 <lispy> :t print
11:00:24 <Botje> k23z__: you can't easily print stuff in pure code
11:00:25 <lambdabot> forall a. (Show a) => a -> IO ()
11:00:29 <Botje> k23z__: but there's the Debug.Trace module
11:00:48 <Botje> or, indeed, you can print stuff in the main function
11:01:04 <lispy> k23z__: ghci is implicitly in the IO monad
11:01:29 <lispy> sneaky ghci
11:01:44 <k23z__> lispy, so ... how can I print stuff ?
11:01:54 <k23z__> Botje, ah yes I'll have a look
11:02:04 <lispy> k23z__: well, the print function will do it whenever you're in IO
11:02:07 <k23z__> Botje, so just Show <stuff> ?
11:02:12 <Botje> no
11:02:18 <k23z__> lispy, ah so I have to import IO ?
11:02:27 <Botje> k23z__: main = print some_variable
11:02:30 <lispy> k23z__: hmm...I sense that you're new to haskell :)
11:02:38 <k23z__> lispy, indeed
11:02:45 <Botje> k23z__: that's all you need to know until you need to do more than simple printing
11:03:09 <lodi> k23z__: inside the main function you can use `putStrLn "hello"`, etc.
11:03:10 <lispy> k23z__: Yeah, as Botje says, for now main is your IO monad, so do that :)
11:03:15 <k23z__> ok worked
11:11:06 <hpc> @src print
11:11:06 <lambdabot> print x = putStrLn (show x)
11:12:01 <applicative> @type print
11:12:02 <lambdabot> forall a. (Show a) => a -> IO ()
11:13:24 <brachiel> hi! I'm looking at the window-class and it has two classes. Now I want to use hookmanager to match this window, but (className =? "a" <&&> className =? "b") doesn't work; is there a way to do this?
11:14:14 <brachiel> oh sorry, wrong channel :P
11:29:06 <Veinor> print vaguely annoys me
11:29:14 * copumpkin slaps Veinor 
11:29:19 <Veinor> I'd like it more if it didn't print quotes
11:30:13 <Veinor> because that's how I expect it to work :P
11:31:21 <silver> :t print
11:31:23 <lambdabot> forall a. (Show a) => a -> IO ()
11:31:32 <silver> print 1
11:31:35 <silver> > print 1
11:31:36 <lambdabot>   <IO ()>
11:31:38 <Twey> It doesn't print quotes if you print a number ;)
11:32:16 <silver> :t putStr
11:32:17 <lambdabot> String -> IO ()
11:35:25 <BMeph> Veinor: But...but...how are you going to know that you're printing a string? ;)
11:36:16 <Kaidelong> BMeph: I'll check out that video later today, thanks for the reference
11:36:41 <swift-prime> print shouldn't be implemented in terms of show is the thing, really
11:37:45 <Veinor> why not?
11:39:08 <silver> :t show
11:39:09 <lambdabot> forall a. (Show a) => a -> String
11:40:07 <arcatan> :t print
11:40:08 <lambdabot> forall a. (Show a) => a -> IO ()
11:40:28 <Veinor> hm. if you made a Printable typeclass with printMe :: (Printable a) => a -> IO (), could you have printMe default to print for things with Show instances but still be able to override it?
11:40:32 <silver> @src print
11:40:32 <lambdabot> print x = putStrLn (show x)
11:40:38 <BMeph> Kaidelong: You bet, I enjoyed it, and it goes along with the topic.
11:41:35 <silver> > show 1
11:41:36 <lambdabot>   "1"
11:42:39 <swift-prime> Veinor: because read(show x) is supposed to work. that's why you get things like quotes when printing strings
11:42:51 <Veinor> ah.
11:43:04 <Kaidelong> > read . read . show . show $ ""
11:43:04 <lambdabot>   *Exception: Prelude.read: no parse
11:43:26 <Kaidelong> > read . show . show $ ""
11:43:27 <lambdabot>   *Exception: Prelude.read: no parse
11:43:49 <silver> > show . read . show . read $ "1"
11:43:50 <lambdabot>   "*Exception: Prelude.read: no parse
11:44:02 <silver> > (show . read . show . read) $ "1"
11:44:03 <lambdabot>   "*Exception: Prelude.read: no parse
11:44:14 <ski> > (read :: String -> String) . (read :: String -> String) . show . show $ ""
11:44:15 <lambdabot>   ""
11:44:53 <Kaidelong> @type read . read . show . show $ ""
11:44:54 <lambdabot> forall a. (Read a) => a
11:45:03 <ski> probably it tried to read the outer `read' into `()'
11:45:35 <ski> > read . read . show . show $ "" :: String  -- so this context suffices to disambiguate
11:45:36 <lambdabot>   ""
11:45:50 <ski> > read . read . show . show $ 42 :: Int
11:45:51 <lambdabot>   42
11:47:38 * hackagebot concurrent-extra 0.5.1 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.5.1 (BasVanDijk)
11:47:40 * hackagebot threads 0.1.0.1 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.1.0.1 (BasVanDijk)
11:50:49 <sepp2k> > (read . read . show . show $ 41) + 1
11:50:50 <lambdabot>   42
11:51:25 <jkramer> Can someone please help me with this snippet? http://pastie.org/968129
11:51:39 <lowasser> For instance, can a Char always be converted to an Int without losing data?
11:51:44 <ben_m> > read . show . show $ "foo"
11:51:45 <lambdabot>   *Exception: Prelude.read: no parse
11:51:48 <ben_m> hum.
11:51:54 <jkramer> It thought $! would force the evaluation of content, but it looks like it's still too late (i.e. after opening the file for writing)
11:53:10 <jkramer> content `seq` writeFile "foo.txt" content    doesn't seem to work either
11:54:16 <copumpkin> what is content?
11:54:21 <copumpkin> seq only evaluates to whnf
11:54:29 <c_wraith> I'm assuming the result of hGetContents
11:54:36 <c_wraith> which means seq is not good enough
11:54:37 <jkramer> copumpkin: Something I read from a file - see http://pastie.org/968129
11:54:39 <copumpkin> then you want rnf
11:54:43 <copumpkin> or deepsqe
11:54:45 <copumpkin> deepseq
11:55:42 <c_wraith> jkramer: seq only forces the top-level constructor in a data type.  that means the first (:) constructor of a long list.
11:55:42 <jkramer> Isn't there an easy way to do it, without additional libs?
11:56:02 <copumpkin> jkramer: you can ask for the length of contents but it's not a very good approach
11:56:06 <copumpkin> or a very clean one, at least
11:56:33 <copumpkin> hGetContents could conceivably be lazy enough to not bother reading in the other stuff
11:56:42 <jkramer> (length content) `seq` writeFile "foo.txt" content    works
11:56:48 <c_wraith> you could re-implement rnf/deepseq for Strings, as it's not very hard.
11:57:01 <copumpkin> or you could just import another module...
11:57:06 <copumpkin> avoiding libraries is silly
11:57:21 <copumpkin> especially since it's a basic distribution library (at least the control.parallel one)
11:57:31 <jkramer> copumpkin: Sure, I just thought there should be something really simple in Prelude for such a problem
11:57:38 <dolio> Or don't write to the same file you're reading.
11:57:41 <copumpkin> it's not a very common need actually
11:57:51 <BMeph> lowasser: Yes. Next question? ;)
11:57:56 * dolio doesn't understand how people run into this so often.
11:58:19 <jkramer> Poeple are editing files I guess :)
11:58:26 <k23z__> what is Ord ?
11:58:47 <c_wraith> jkramer: It's more common to just avoid lazy IO.
11:59:13 <c_wraith> jkramer: using read instead of hGetContents, for instance
11:59:31 <jkramer> But readFile is so handy :)
11:59:38 <c_wraith> err, whatever the function name is..
12:00:04 <edwardk_> i took some time and sketched out what i was thinking about in terms of how to build one big common ad implementation, ski turned out to be right w.r.t getting parts of it to be shared (rather than autogenerate i concocted a newtype)
12:00:11 <edwardk_> i'm thinking something like http://paste.lisp.org/display/99477
12:00:12 <EvanR-work> so ld has exhausted memory on my server while building haskell platform. is there a way to tell ghc to use -no-keep-memory when using ld ?
12:00:23 <edwardk_> er one big common AD implementation that is
12:00:37 <c_wraith> EvanR-work: using the no-split-objs flag will help a lot
12:00:49 <EvanR-work> ok
12:00:57 <edwardk_> er s/Jacobian/Mode in that code
12:01:03 <EvanR-work> is that part of haskell platform, or do i have to hack the individual Setup files
12:01:21 <c_wraith> it's an option to the installer.
12:01:28 <EvanR-work> ok
12:01:36 <k23z__> err, I'm reading "Learn you a Haskell" ,  it talks about Ord, but it doesn't define it
12:01:40 <k23z__> I get it's some sort of type
12:01:42 <edwardk_> @src Ord
12:01:43 <lambdabot> class  (Eq a) => Ord a  where
12:01:43 <lambdabot>     compare      :: a -> a -> Ordering
12:01:43 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:01:43 <lambdabot>     max, min         :: a -> a -> a
12:01:47 <k23z__> of object which have an order relation
12:01:50 <k23z__> *objects
12:02:02 <edwardk_> yeah, Ord gives you those methods
12:02:03 <k23z__> and a comparison function
12:02:15 <edwardk_> (<), (<=), (>), (>=), max, min, compare
12:02:16 <c_wraith> @src Ordering -- just for completeness
12:02:17 <lambdabot> Source not found.
12:02:20 <k23z__> can I promote a list of strings to a type derived from Ord ?
12:02:23 <c_wraith> @src Ordering
12:02:23 <lambdabot> data Ordering = LT | EQ | GT
12:02:34 <c_wraith> a list of strings is an instance of ord
12:02:40 <c_wraith> all lists are an instance of ord
12:02:44 <edwardk_> > ["Hello","Nurse"] < ["Yes","You","can"]
12:02:45 <lambdabot>   True
12:03:01 <k23z__> what is their compare function ? length ?
12:03:05 <edwardk_> there is an instance of Ord for lists of values that are an instance of Ord
12:03:07 <ben_m> @src instance Ordering List
12:03:07 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:03:10 <Veinor> c_wraith: all lists of things that are in ord, yes
12:03:10 <ben_m> doh :D
12:03:11 <edwardk_> it compares lexicographically
12:03:14 <k23z__> c_wraith,   what is their compare function ? length ?
12:03:35 <c_wraith> k23z__: it hands it off to the list elements, in order
12:03:56 <ben_m> > [1, 2, 3] < [1, 2]
12:03:58 <lambdabot>   False
12:04:15 <Veinor> > [2,4,6] > [1,2]
12:04:16 <lambdabot>   True
12:04:19 <Veinor> > [2,4,6] > [1,2,3,4,5]
12:04:20 <lambdabot>   True
12:04:29 <EvanR-work> c_wraith: i dont see that in ./configure --help
12:04:34 <ski> k23z__ : lexicographic ordering
12:04:35 <edwardk_> [] is smaller than (x:xs), (x:xs) < [], [] is equal to []otherwise it compares (x:xs) against (y:ys) by comparing their heads, if they are equal it compares the tails, otherwise it returns that comparisons result
12:04:35 <k23z__> ok thank you I understand
12:04:39 <ben_m> > [2, 0, 0] > [1, 100, 100]
12:04:40 <lambdabot>   True
12:04:50 <k23z__> I want to write my own type deriver from a list of strings , how can I do that ?
12:04:51 <hpc> > [2] > [1..]
12:04:52 <lambdabot>   True
12:04:57 <k23z__> MyType :: [String]   ?
12:05:04 <edwardk_> k23z__: wrap it in a newtype
12:05:09 <edwardk_> newtype MyType = MyType [String]
12:05:17 <BMeph> Off to lunch; see y'all in a bit...
12:05:20 <ben_m> oh yes I was going to ask ... what's the difference between type and newtype?
12:05:23 <ski> (edwardk_ : .. s/(x:xs) < []/[] < (x:xs)/)
12:05:25 <edwardk_> then you'll need to deal with that constructor
12:05:26 <hpc> or type MyType = [String]
12:05:30 <edwardk_> ski: yeah
12:05:45 <ben_m> or data/newtype
12:05:51 <edwardk_> hpc: the hazard of that is he can't then define instances
12:06:05 <edwardk_> ben_m: newtypes exist only at compile time, they have no runtime cost
12:06:07 <k23z__> edwardk_, and now how do I promote a list of strings to MyType ?
12:06:08 <ski> `type' just gives a synonym to existing types
12:06:11 <ben_m> edwardk_: ah :)
12:06:11 <hpc> depends on if that's what he wants
12:06:17 <ski> `newtype' and `data' creates new types
12:06:20 <edwardk_> k23z__: foo = MyType ["Hello"]
12:06:25 <k23z__> oh that's fantastic
12:06:36 <k23z__> this language blows everything I've seen so far
12:06:50 <edwardk_> you pattern match on it like bar (MyType (x:xs)) = ... or bar (MyType xs) = .. or bar (MyType []) = ...
12:07:07 <edwardk_> k23z__: we're rather fond of it ourselves around here ;)
12:07:15 * ski wonders what languages k23z__'s has seen, so far ..
12:07:15 <heropass> > show "abcd'
12:07:16 <lambdabot>   <no location info>:
12:07:16 <lambdabot>      lexical error in string/character literal at end o...
12:07:52 <edwardk_> k23z__: if you want to borrow some functionality from [String] you can use 'deriving' on the newtype to avoid having to define instances yourself.
12:07:57 <k23z__> ski, Perl , Prolog , C/C++ , Python , Javascript , Assembly(NASM)
12:08:04 <edwardk_> i.e. if you want to be able to use 'show' on your MyType you can
12:08:16 <edwardk_> newtype MyType = MyType [String] deriving (Show)
12:08:34 <edwardk_> and then show :: MyType -> String will work (and a few other misc functions)
12:08:34 <k23z__> edwardk_, what is Show ?
12:08:41 <edwardk_> > show 123
12:08:42 <lambdabot>   "123"
12:08:53 <edwardk_> > show ("hello",'c',1234)
12:08:54 <lambdabot>   "(\"hello\",'c',1234)"
12:08:57 <hpc> >show [1..5]
12:09:01 <heropass> nice, ok thanks for illustrating that
12:09:03 <ski> k23z__ : that `MyType ["Hello"]' in haskell corresponds to saying `my_type(["Hello"])' in Prolog  (but Prolog's not statically typed, though)
12:09:04 <hpc> > show [1..5]
12:09:05 <lambdabot>   "[1,2,3,4,5]"
12:09:43 <edwardk_> you can also derive "Read" which lets you go from String -> MyType
12:09:50 <edwardk_> > read "1" :: Int
12:09:51 <lambdabot>   1
12:10:26 <ben_m> > data Foo = Bar | Baz deriving (Show, Read)
12:10:27 <lambdabot>   <no location info>: parse error on input `data'
12:10:28 <ski> k23z__ : a type is in the type class `Show' when one has defined how to convert it into a string
12:10:30 <ben_m> > let data Foo = Bar | Baz deriving (Show, Read)
12:10:31 <lambdabot>   <no location info>: parse error on input `data'
12:10:34 <ben_m> meh.
12:10:36 <ben_m> I fail at lambdabot.
12:10:38 <ben_m> Disregard.
12:10:55 <edwardk_> @let data Foo = Bar | Baz deriving (Show, Read)
12:10:55 <lambdabot>  Invalid declaration
12:10:57 <edwardk_> awww
12:11:20 <ski> (doing that requires being Cale)
12:11:24 <edwardk_> ah
12:11:29 <heropass> hmm, interesting, i thought the let would work
12:11:44 <edwardk_> data cannot be defined in a local lexical scope
12:12:00 <edwardk_> it needs to be done at the module level
12:12:07 <lowasser> I feel kind of n00bish, but I'm trying to construct an order-preserving injection from Word to Int
12:12:20 <lowasser> \ x -> let maxInt = maxBound :: Int in if x <= fromIntegral maxInt then x - maxInt else fromIntegral (x - fromIntegral maxInt)
12:12:24 <heropass> that makes sense, to prevent breakage
12:12:36 <edwardk_> lowasser: map 0 to minBound
12:12:37 * ski isn't sure that really makes sense
12:13:10 <lowasser> that was my plan, I'm trying to make sure I've got it all right
12:13:19 <Polarina> What are your opinions towards the extension GeneralizedNewtypeDeriving?
12:13:26 <edwardk_> Polarina: made of win
12:13:40 <lowasser> Polarina: for great justice
12:13:42 <jmcarthur> lowasser: unsafeCoerce  :D
12:13:44 <k23z__> thanks edwardk_
12:13:47 <jmcarthur> but don't do that, really
12:14:02 <lowasser> would never happen =P
12:14:03 <k23z__> how do I promote an entire list of list to strings to MyType ?
12:14:08 <edwardk_> unsafeCoerce wouldn't be order preserving thogh
12:14:11 <k23z__> map (MyType) (list) ?
12:14:22 <lowasser> personally, I'm rather surprised that the Enum instance for Word doesn't already take care of this
12:14:27 <ben_m> k23z__: minus the parentheses
12:14:32 <ski> that would give a list of `MyType's
12:14:35 <lowasser> but nope, it goes and fails on half the range of Word
12:14:42 <edwardk_> k23z__: newtype MyType = MyType [String] -- so you can turn a list of Strings into a MyType just by calling MyType
12:14:48 <EvanR-work> well the 'solution' was to increase the virtual machines memory to 2G from 512M
12:14:54 <edwardk_> toMyTypeFromStrings = MyType ;)
12:14:55 <EvanR-work> but seriously
12:15:10 <ski> edwardk_ : note "list of list"
12:15:17 <edwardk_> ohh
12:15:21 <k23z__> toMyTypeFromStrings ?!?
12:15:25 <k23z__> what is that ?
12:15:30 <k23z__> I should define/implement that ?
12:15:32 <ski> irrelevant
12:15:42 <edwardk_> k23z__: i misheard your question
12:15:48 <k23z__> edwardk_, let me explain
12:15:54 <ben_m> k23z__: map MyType [["foo", "bar", "baz"], ["one", "two", "three"]]
12:15:56 <edwardk_> k23z__: map MyType list will give you a list of MyTypes
12:15:58 <lowasser> Dudes, stop whining that GeneralizedNewtypeDeriving breaks things, it's the coder's responsibility to make sure it preserves transparency
12:16:09 <edwardk_> you need to 'concat' the list first to go from [[String]] -> [String]
12:16:09 <k23z__> yes like ben_m said
12:16:11 <edwardk_> @type concat
12:16:12 <lowasser> even though you can use it for dark and dirty magics
12:16:12 <lambdabot> forall a. [[a]] -> [a]
12:16:38 <k23z__> edwardk_,  err what's that ? de-nesting ?
12:16:41 <edwardk_> > concat [["Goodbye"],["Cruel","World"]]
12:16:42 <lambdabot>   ["Goodbye","Cruel","World"]
12:17:00 <edwardk_> concat removes one level of nesting
12:17:14 <ski> > map concat [["Goodbye"],["Cruel","World"]]
12:17:15 <lambdabot>   ["Goodbye","CruelWorld"]
12:17:22 <ski> (is another way)
12:18:10 <lowasser> oh, geez, edwardk_
12:18:13 <lowasser> how exactly do you
12:18:22 <k23z__> how can I write on one single line multiple Haskell lines ?
12:18:33 <ben_m> semicolon
12:18:36 <k23z__> ah yes
12:18:39 <lowasser> um
12:18:42 <copumpkin> k23z__: don't do it!
12:18:51 <lowasser> gah nvm
12:18:52 <edwardk_> so in that case you'd define something like fromListOfListOfStrings = MyType . concat -- or fromListOfListOfStrings xs = MyType (concat xs)
12:18:58 <ski> lowasser : what things does `GeneralizedNewtypeDeriving' break ?
12:19:05 <k23z__> > newtype Sentence = Sentence [String] deriving (Show)  ; map Sentence [["foo", "bar", "baz"], ["one", "two", "three"]]
12:19:06 <lambdabot>   <no location info>: parse error on input `newtype'
12:19:13 <k23z__> > newtype Sentence = Sentence [String] deriving (Show)
12:19:15 <lambdabot>   <no location info>: parse error on input `newtype'
12:19:16 <ben_m> k23z__: yeah can't define newtypes for lambdabot
12:19:17 <k23z__> why ?
12:19:23 <edwardk_> ski: it can do some pretty nasty dictionary conversions if you're not careful
12:19:36 <k23z__> I was trying to exemplify my point
12:19:37 <ski> like ?
12:19:45 <ben_m> k23z__: That would work though.
12:19:46 <k23z__> ben_m, the map you gave me above    map MyType list doesn't work for me
12:19:46 <copumpkin> k23z__: it doesn't maintain state across messages, so it generally wouldn't be very useful
12:20:19 <edwardk_> ski: see http://www.haskell.org/pipermail/haskell-cafe/2010-March/074305.html and http://www.haskell.org/pipermail/haskell-cafe/2010-March/074325.html
12:20:22 <k23z__> in ghci how do I evaluate a .hs ?
12:20:28 <copumpkin> :l moo.hs
12:20:31 <copumpkin> or :r to reload
12:20:36 <ben_m> k23z__: You can also just define Sentence as an alias of [String]: type Sentence = [String]
12:21:20 <k23z__> ben_m, it's not just an alias, I want to overload the compare function
12:21:29 <ben_m> oh yeah then you need newtype/data
12:21:29 <k23z__> ben_m, can I do that with an alias ?
12:22:52 <edwardk_> k23z__: what you want is newtype Sentence = Sentence [String] deriving (Show); fromLOL xxs = Sentence (concat xxs)
12:23:00 <edwardk_> k23z__: or something like that
12:23:10 <ben_m> Are you sure that's what he wants?
12:23:13 <edwardk_> no
12:23:22 <edwardk_> but it gets him something that typechecks
12:23:32 <ski> edwardk_ : interesting. ty for the links
12:23:33 <edwardk_> then he can complain about what it does and we can refine the specification ;)
12:24:06 <edwardk_> ski: did you see the link i pasted above for the sketch of how i'm thinking about proceeding with the AD code?
12:25:09 <edwardk_> k23z__: you might also be interested in some built in functions:
12:25:14 <ski> edwardk_ : i didn't
12:25:15 <edwardk_> > words "This is a test"
12:25:16 <lambdabot>   ["This","is","a","test"]
12:25:32 <edwardk_> and lines which similarly carves things up on newlines
12:25:40 <edwardk_> ski: http://paste.lisp.org/display/99477
12:25:43 <k23z__> I'm aware of those yes
12:26:00 <edwardk_> ski: i apologize in advance for any typos in the code i wrote it all stream of consciousness after we talked earlier
12:26:28 <k23z__> edwardk_, I understand what you wrote, but I don't want to concatenate all the lists into just one and then promoting that as a Sentence
12:26:45 <k23z__> edwardk_, I want to promote the individual lists into a sentence each
12:26:48 <edwardk_> k23z__: what do you want to do with the list of lists of strings?
12:26:49 <gwern> suck it up! if that's what edwardk said you puke you'll do it
12:26:51 <hpc> also, unwords and unlines
12:27:01 <gwern> in my day we did everything with 1s! we didn't even ahve 0s!
12:27:02 <hpc> > unlines ["123", "456"]
12:27:02 <edwardk_> then map Sentence is exactly what you need
12:27:03 <lambdabot>   "123\n456\n"
12:27:13 <gwern> my god you haven't lived until you're written a porn site in unary
12:27:18 <k23z__> edwardk_, I want to compare them by length, so that's why I'm making my new type :)
12:27:22 <gwern> bleeuuurgggh!
12:27:29 <edwardk_> map Sentence will take you from [[String]] -> [Sentence]
12:27:33 <aristid> holy shit: binaryP :: (a -> a -> a) -> (a -> AD t s a -> AD t s a -> (AD (Partial t) s a, AD (Partial t) s a)) -> AD t s a -> AD t s a -> AD t s a
12:27:34 <ski> k23z__ : then `map MyType' seems to be what you want
12:27:51 <ski> aristid : looks nice, eh ? :)
12:28:08 <edwardk_> aristid: a tidge verbose, but it lets me recycle the code for the jacobian across 6 types ;)
12:28:34 <aristid> edwardk_: no way to accomplish that AND have it a bit shorter?
12:28:38 <edwardk_> aristid: fraid not
12:28:53 <dolio> ski: Have you read A Typed Pattern Calculus?
12:28:59 <aristid> edwardk_: not even with rank n types?
12:29:02 <edwardk_> aristid: there isn't a higher order "Num" instance that i could use
12:29:03 <edwardk_> nope
12:29:13 <ski> dolio : i don't think so ?
12:29:22 <ski> why ?
12:29:22 <aristid> edwardk_: :/
12:29:22 <edwardk_> aristid: it took me an hour to get it down that far ;)
12:29:44 <edwardk_> aristid: i originally didn't have the AD's in there, but that meant i had to make instances for Num, Floating, etc. for allthe individual modes
12:29:53 <edwardk_> so i didn't derive much benefit from sharing the jacobian code
12:29:54 <dolio> I did yesterday, and it reminded me of your ideas on patterns being linked with expressions. For instance, it has or patterns that are correlated with or expressions.
12:29:59 <lowasser> is there a good way to determine, in GHC, at compile-time, if Int32 has the same range as Int?
12:30:06 <edwardk_> the AD newtype lets me recycle the jacobian code over and over
12:30:11 <aristid> edwardk_: i don't really understand the code anyways :D
12:30:14 <edwardk_> lowasser: CPP?
12:30:16 <lowasser> (I'm thinking some kinda preprocessor thing, but I don't know what)
12:30:29 <k23z__> how do I say that my function is taking [Sentence] and returning [Int] ?
12:30:29 <lowasser> yeah, I'm wondering if there are any nice built-in preprocessor directives
12:30:38 <lowasser> all I've ever seen is #ifdef __GLASGOW_HASKELL__
12:30:39 <Cale> lowasser: I can imagine you could use TH and maxBound for that
12:30:41 <dolio> And the paper shows how the pattern rules are linked with a sequent calculus.
12:30:56 <Cale> lowasser: What do you need to know for?
12:31:03 <edwardk_> aristid: the idea is to unify the code in http://hackage.haskell.org/package/fad and http://hackage.haskell.org/package/rad while making it more efficient
12:31:33 <lowasser> mostly, I'm trying to construct a type class of functions with order-preserving injections to Int, and I want it to include as many base types as possible
12:31:49 <lowasser> *type class of types
12:32:17 <lowasser> and I'm trying to figure out if I can get Int32 and Word32 in there
12:32:20 <Cale> That's what Enum is, though it does it in an awkwardly imprecise way
12:32:20 <edwardk_> lowasser: just omit the instances for the Foo64 types, you should be safe in assuming Int has at least 30 bits, that is iirc all you get out of the haskell spec
12:32:27 <k23z__> how do you call this in Haskell ? splitOn :: Eq a => [a] -> [a] -> [[a]]   <------ prototype ?!?
12:32:29 <edwardk_> in practice ghc gives you all 32
12:32:32 <ski> dolio : "A typed pattern calculus" <http://www.pps.jussieu.fr/~kesner/papers/pattern-calculus.ps.gz> by Delia Kesner,Laurence Puela,Val Tannen, 1995 ?
12:32:37 <lowasser> the problem is I want to make sure there's at _most_ 32
12:32:37 <dolio> ski: I think it's a classical sequent calculus, as well, which you might expect to lead to a nondeterministic lambda calculus, but the or rules are used for the or patterns and corresponding expressions, so the calculus as a whole isn't nondeterministic.
12:32:40 <copumpkin> k23z__: a type declaration?
12:32:47 <k23z__> copumpkin, ah yes thanks
12:32:49 <lowasser> which GHC can't guarantee for 64-bit systems
12:33:07 <copumpkin> lowasser: why not just use Int32
12:33:11 <ski> k23z__ : type signature for `splitOn'
12:33:13 <dolio> ski: Yes. That's the one.
12:33:38 <Cale> GHC doesn't even ensure that Int has 32 bits.
12:33:43 <lowasser> Exactl
12:33:44 <Cale> Er, Haskell doesn't ;)
12:33:48 <k23z__> ski, so type signature or type declaration ?
12:33:53 <ski> dolio : yes, i've been thinking to create a sequent calculus for this. ty for the link
12:33:56 <lowasser> for all we know, Int could a subset *or* a superset of Int32
12:34:00 <edwardk_> lowasser: as i said, you only get the guarantee that Int has 30 bits
12:34:02 <Cale> Int could be as few as 30 bits.
12:34:12 <k23z__> copumpkin , ski can you guys agree on what's that called ? signature or declaration ?
12:34:16 <lowasser> so I want to determine, with the preprocessor, if Int has at most 32 bits
12:34:16 <edwardk_> lowasser: so even the Word instance is ghc specific
12:34:30 <Cale> The only way you can really tell is to use maxBound and minBound.
12:34:33 <ski> k23z__ : i would say "type signature", reserving "type declaration" for things like `type Foo = ...', `newtype Foo = ...' and `data Foo = ...'
12:34:35 <edwardk_> lowasser: use template haskell and check maxBound Int ;)
12:34:55 <ski> copumpkin : what say you ? :)
12:35:02 <lowasser> bah.  I don't like adding another dependency, but all right
12:35:17 <edwardk_> using template haskell should bind you pretty tightly to ghc anyways so then you can assume it is at least 32 bits safely ;)
12:35:17 <copumpkin> I dunno, I was just thinking it was associated with the splitOn declaration, but maybe you're right :P I'm definitely no expert :)
12:35:43 <lowasser> I mean, "at least" doesn't help me when I'm interested in "at most 32 bits"
12:36:03 <lowasser> OH WAIT
12:36:09 <Cale> It seems awkward to me to have whether or not some type is an instance of a class depend on the architecture you're building on.
12:36:15 <lowasser> Data.Bits.bitSize
12:36:27 <lowasser> Cale: I mean, I'm only using it for specializing rewrite rules
12:36:35 <lowasser> it's not visible outside my library
12:36:37 <Cale> hmm
12:36:41 <edwardk_> lowasser: yes, all we're doing is giving you grief that you can't even be sure you can fit Word32 in Int ;)
12:37:50 <edwardk_> > bitSize (undefined :: Integer)
12:37:51 <lambdabot>   *Exception: Data.Bits.bitSize(Integer)
12:37:53 <edwardk_> =)
12:38:36 <k23z__> ski,   how do I say that my function is taking [Sentence] and returning [Int] ? what would be the appropriate type signature ?
12:38:53 <tensorpudding> f :: [Sentence] -> [Int]
12:39:26 <ski> > bitSize (undefined :: Int18446744073709551616)
12:39:26 <lambdabot>   Not in scope: type constructor or class `Int18446744073709551616'
12:39:53 <ski> k23z__ : `foo :: [Sentence] -> [Int]' ?
12:41:04 * ski is covertly complaining about the limited precision in the type of `bitSize'
12:41:07 <k23z__> Illegal signature in pattern: [[Sentence] a] -> [Int]
12:41:18 <k23z__> I wanted actually    foo:: [[Sentence] a] -> [Int]
12:41:26 <k23z__> can I do that as well ? I tried that and that's the error I got
12:41:32 <k23z__> Illegal singnature
12:41:35 <k23z__> why do I get that ?
12:41:35 <ski> where did that extra pair of square brackets, as well as the `a' come from ?
12:41:49 <ski> why have you written an `a' in there ?
12:41:59 <k23z__> ski, count_words :: [ [Sentence] a] -> [Int]
12:42:13 <ski> you have defined something like
12:42:23 <ski>   newtype Sentence = MkSentence [String]
12:42:24 <ski> yes ?
12:42:39 <k23z__> ski, newtype Sentence = Sentence [String] deriving (Show)
12:42:48 <ski> ok (that's a yes)
12:43:10 <k23z__> ski, so why am I getting this weird illegal signature error ?
12:43:14 <ski> so, if you want to convert a list of sentences into a list of `Int's, the correct type signature is
12:43:28 <ski>   count_words :: [Sentence] -> [Int]
12:43:47 <k23z__> ski, where do I plug the a ?
12:43:58 <ski> why do you want to plug an `a' anywhere ?
12:44:09 <vitka> It's only for abstract data types.
12:44:13 <k23z__> ski, because I want to use an argument to define my function
12:44:19 <tensorpudding> It looks like Sentence has kind *
12:44:26 <k23z__> ski, what you wrote is just the type signature but I want to actually implement it
12:44:31 <ski> k23z__ : well, that doesn't go in the type signature
12:44:32 <ben_m> kind is something I never read until I started idling in here
12:44:33 <ben_m> :/
12:44:47 <ski> it goes in the defining clause(s)/equation(s)
12:44:52 <ski> like
12:45:12 <ski>   count_words a = map wordsInSentence a
12:45:16 <k23z__> ski, so man count_words :: [Sentence] -> [Int]   <-- this is the singature right ? where do I plug the actual parameter so I can use it ?
12:45:37 <k23z__> so I can actually implement count_words
12:45:51 <vitka> foo (Sentence ws) = ... that way list of strings ws is available in function.
12:46:05 <ski> the actual parameter goes in the actual definition of `count_words'
12:46:39 <ski> the type signature is only for telling what the types of the arguments and the result should be (so that callers of `count_words' know what to pass, and what to expect back)
12:46:56 <edwardk_> k23z__: what i'd do is define a function 'words' that takes a sentence and tells you how many words it has. then you can map that over the list of sentences
12:47:05 <ski> k23z__ : so start by writing `count_words a = ..a..' on the next line, e.g. ?
12:47:11 <dpratt71> k23z__: unlike other languages you may be familari with, Haskell does not combine function type signatures and function declarations
12:47:15 <k23z__> edwardk_, good idea
12:47:17 <dpratt71> *familiar
12:47:39 <ski> (where `..a..' should be replaced by the actual code the computes the list of counts, using `a' which is a list of sentences)
12:47:39 <edwardk_> words :: Sentence -> Int ;; words (Sentence xs) = length xs; words_in_sentences :: [Sentence] -> [Int]; words_in_sentences = map words
12:47:48 <dpratt71> (the Italian accent shows up sometimes)
12:48:10 <copumpkin> Italian accent?
12:48:12 <lowasser> I'm guessing, but someone tell me if I'm wrong, that Char always has an injection to Int32 as well as Int?
12:48:21 <lowasser> (since Int may be bigger)
12:48:32 <dpratt71> copumpkin: referring to my typo (familari)
12:48:33 <c_wraith> Int may also be smaller than Int32
12:48:43 <copumpkin> ah :)
12:48:54 <edwardk_> lowasser: that should be safe for Char since Char values are only defined up to plane 1
12:48:55 <gwern> c_wraith: it can? when have any haskell compilers run on 16-bit archs?
12:49:11 <lowasser> gwern: the Report only guarantees 2^29
12:49:11 <edwardk_> gwern: 30 bits is all haskell 98 says
12:49:12 <c_wraith> gwern: Int can be 29 bits, according to the spec.
12:49:18 <edwardk_> or 29 or whatever
12:49:29 <copumpkin> I think it's 29 in either sign
12:49:30 <ski> 30 bits, including sign bit, iirc
12:49:30 <gwern> stupid report
12:49:38 <gwern> why did it go and say that
12:49:46 <copumpkin> gwern: they wanted to let people have tag bits
12:49:49 <edwardk_> gwern: in case someone wanted to tag ints ala lisp
12:50:00 <aristid> ghc doesn't use tagging does it?
12:50:03 <copumpkin> nope
12:50:04 <edwardk_> aristid: nope
12:50:07 <copumpkin> I think hugs doe sthough
12:50:08 <edwardk_> aristid: well, 'kinda'
12:50:14 <k23z__> ski, so I specify separately the signature and then separately I implement it ? I thought I'd do it all-in-one
12:50:14 <edwardk_> aristid: but not in a way that affects this ;)
12:50:27 <ski> k23z__ : yes, separatedly
12:50:50 <c_wraith> k23z__: the signature is optional.  That means you need to put all the argument name binding in the definition
12:51:08 <ski> k23z__ : you can even place the signature in another place in the module, if you want to .. it's common to place it just above the defining equation(s)/clauses(s), though
12:51:21 <edwardk_> k23z__: if you omit the signature haskell will figure out what your type is (in all but a few pathological corner cases you'll discover way later)
12:51:49 * ski disputes polymorphic recursion is pathological :)
12:51:59 <edwardk_> ski: 'advanced' then ;)
12:52:01 <gwern> bleh tagging
12:52:03 <hpc> the signature is recommended though, since you can catch a lot of logic errors
12:52:11 <gwern> once again stupid implementation issues muck things up
12:52:21 <gwern> raeg
12:52:35 <ski> also, putting a type signature can help narrow down causes of type errors
12:52:36 <copumpkin> does parsec notice whether its applicative interface is used exclusively or if you use monads too?
12:52:59 <edwardk_> copumpkin: nah its pretty dumb in that regard
12:53:03 <copumpkin> boo
12:53:10 <edwardk_> copumpkin: if you want that use uuparsing-lib
12:53:24 <edwardk_> that uses a special parser for the final set of applicative bindings
12:53:24 <dpratt71> hpc: the thing I don't like about type signatures is that the inexperienced (i.e. me) will often make the type too specific
12:53:26 <aristid> @quote infinitely fast
12:53:27 <lambdabot> No quotes for this person. Maybe you made a typo?
12:54:04 <hpc> dpratt71: my trick is to write the function with type signature, get it to work, then delete the signature and :t in GHCi
12:54:08 <dpratt71> like specifying 'Int' when 'Num a' would be better
12:54:10 <ski> dpratt71 : often one can ask what the inferred type is, and the include (a prettified version of) it as a type signature
12:54:10 <k23z__> do I really need to define length for MyType which is just a list of strings ? doesn't it know what length means for a list of strings ?
12:54:11 <c_wraith> I think people should be more willing to use uu-parsinglib anyway.  Unless you need really blazing performance, it's so worth it just because it's easier to get right.
12:54:12 <hpc> and put that signature into the file
12:54:23 <copumpkin> edwardk_: or your magic nameless parsing lib!!
12:54:29 <edwardk_> copumpkin: there is that ;)
12:54:35 <copumpkin> c_wraith: easier to get right?
12:54:38 <edwardk_> copumpkin: but there it can't even handle the monad case
12:54:46 <hpc> then you know when a change later causes the function to specialize
12:54:50 <copumpkin> edwardk_: monic fail!
12:54:52 <dpratt71> hpc: yeah, I've been known to do that
12:54:53 <ski> k23z__ : `length' will work on a list of `MyType's, as well
12:55:06 <ski> k23z__ : that's (parametric) polymorphism for you
12:55:14 <edwardk_> c_wraith: the main problem i have with it is the code makes my eyes bleed
12:55:18 <c_wraith> copumpkin: you don't need to mess with try, letting you create much more generic combinators.
12:55:21 <edwardk_> c_wraith: otherwise it has some good ideas
12:55:25 <copumpkin> c_wraith: ah
12:55:36 <copumpkin> yeah, I have one try in my code already
12:55:43 <dpratt71> putting the type sig in initially is a useful trick for F# since you get intellisense and type tooltips, etc. as you go
12:55:53 <ski> k23z__ : otoh, a single sentence is not a list of strings (it contains a list of strings)
12:56:01 <copumpkin> dpratt71: lucky for us we don't have intellisense, so we don't need type sigs ;)
12:56:05 <copumpkin> oh wait
12:56:11 <dpratt71> copumpkin: :)
12:56:17 <edwardk_> k23z__: your MyType isn't a list of strings it is a 'MyType' constructor wrapped around around a list of strings. length knows not what to do with a MyType
12:56:34 <copumpkin> you should unsafeCoerce it!
12:56:38 <dpratt71> dpratt71: you caught my implied wish, I see
12:56:44 <ski> k23z__ : i would recommend defining something like `newtype Sentence = Sentence {getWords :: [String]} deriving Show'
12:56:53 <EvanR-work> unsafeTasteTheWater
12:56:55 <c_wraith> note to self: never believe anything copumpkin says to beginners.
12:56:59 <copumpkin> lol
12:57:00 <ski> k23z__ : then you can use `map (length . getWords)' to get the length
12:57:03 <copumpkin> hey, it's safe!
12:57:03 <ski> s
12:57:06 <hpc> > unsafeLaunchMissiles
12:57:07 <lambdabot>   Not in scope: `unsafeLaunchMissiles'
12:57:08 <copumpkin> ...if it's a newtype, which I think it is
12:57:14 <hpc> aw
12:57:28 <c_wraith> copumpkin: that's correct, but really horrible advice
12:57:30 <c_wraith> :)
12:57:34 <copumpkin> :(
12:57:36 <copumpkin> :'(
12:58:14 <EvanR-work> how to install cabal packages for the whole system?
12:58:30 <dolio> I thought haskell programmers put type annotations on their code because the type system was fundamentally weak and broken. :)
12:58:37 <ski> k23z__ : in case you wonder, this will automatically define `getWords :: Sentence -> [String]' as `getWords (Sentence wordList) = wordList' for you
12:58:39 <c_wraith> dolio: only dph has that issue
12:58:47 <k23z__> ski,  http://i.imgur.com/KVl22.png
12:58:51 <copumpkin> c_wraith: huh?
12:58:54 <copumpkin> oh, humor
12:59:01 <c_wraith> err. whatever his name is.  I've forgotten already.  dph is the wrong acronym. :)
12:59:08 <k23z__> edwardk_, http://i.imgur.com/KVl22.png
12:59:33 <ski> k23z__ : see what i said above :)
12:59:50 <copumpkin> c_wraith: jdh?
12:59:58 <edwardk_> newtype Sentence = Sentence { getWords :: [Sentence] };; count_words = map (length . getWords)
13:00:08 <c_wraith> copumpkin: yes.  that's it.  holy crap, conferences melt engineer brains.  I don't belong here!
13:00:09 <silver> k23z__, oh pretty colors, which editor do you use?
13:00:29 <ski> k23z__ : and `length . getWords' is the function that first extracts the list of words, using `getWords', then uses `length' on that list
13:01:01 <dolio> @quote idiomatic.Haskell
13:01:01 <lambdabot> JonHarrop says: You annotated the types by hand because that is idiomatic Haskell. That is idiomatic Haskell because the type system is too easily misled by design (flaw).
13:01:01 <k23z__> silver, V    I    M
13:01:23 <ski> (edwardk_ : heh, did you write `getWords' independently ? :)
13:01:30 <copumpkin> lol
13:01:40 <edwardk_> ski: nah stole it from you ;)
13:01:46 <k23z__> ski, is . function composition ?
13:01:50 <ski> yes
13:01:51 <edwardk_> @type (.)
13:01:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:01:55 <edwardk_> gah
13:01:57 <edwardk_> don't look at that
13:01:59 <ski> @type Prelude..
13:02:00 <lambdabot> parse error on input `Prelude..'
13:02:01 <edwardk_> @type (Prelude..)
13:02:02 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:02:07 <ski> ty
13:02:08 <k23z__> ski, 67:16: Not in scope: `getWords'
13:02:09 <edwardk_> that is what (.) is ;)
13:02:12 <vitka> @type fmap fmap
13:02:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
13:02:22 <edwardk_> k23z__: did you see the redefinition of Sentence above?
13:02:25 <ski> k23z__ : "<ski> k23z__ : i would recommend defining something like `newtype Sentence = Sentence {getWords :: [String]} deriving Show'"
13:02:30 <edwardk_> where it grew a little more complicated?
13:02:56 <ski> <ski> k23z__ : in case you wonder, this will automatically define `getWords :: Sentence -> [String]' as `getWords (Sentence wordList) = wordList' for you
13:03:26 * ski waits for the penny to drop
13:03:27 <edwardk_> (and it'll make your Show instance a bit scarier)
13:04:07 <k23z__> ski, 63:60: Not in scope: type constructor or class `Show''
13:04:26 <k23z__> wait it works !!!
13:04:31 <k23z__> I had an apostrophe
13:04:33 <buntfalke> how's the newline denoted?
13:04:37 <buntfalke> as a character
13:04:41 <k23z__> buntfalke,  \n ?
13:04:44 <ski> > "foo\nbar"
13:04:45 <edwardk_> congratulations k23z__ =)
13:04:45 <lambdabot>   "foo\nbar"
13:05:04 <edwardk_> > unlines "foo\nbar"
13:05:05 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:05:05 <lambdabot>         against inferred ty...
13:05:12 <buntfalke> hm...doesnt quite work: lexical error in string/character literal at character '\''
13:05:12 <edwardk_> > lines "foo\nbar"
13:05:13 <lambdabot>   ["foo","bar"]
13:05:15 <ski> > ord '\n'
13:05:15 <lambdabot>   10
13:05:21 <k23z__> edwardk_, thanks, but you guys really know Haskell
13:05:31 <k23z__> edwardk_, what have you been reading/doing with it that you know so much ?
13:05:32 <k23z__> ski,  ?
13:05:40 <k23z__> ski, you people here really know it extremely well
13:06:18 <buntfalke> hmm. thanks. (bbl)
13:06:18 <edwardk_> k23z__: i write a bunch of scary stuff on http://comonad.com/ about category theory in haskell and try to use it to exploit the freedom from side effects to make parallel code really fast
13:06:58 <k23z__> holy mother of goat
13:07:12 <Eduardo_> is that possible to have a local function with typing?
13:07:18 <Eduardo_> something like
13:07:19 <EvanR-work> one reduction per cpu, throw enough cpus at it, job done
13:07:24 <edwardk_> Eduardo_: yes, you can throw types on a where clause
13:07:35 <edwardk_> and in a let
13:07:56 <Eduardo_> can you show me an example of it using let ?
13:07:56 <edwardk_> > let a :: Double; a = 12 in a
13:07:57 <lambdabot>   12.0
13:08:07 <Eduardo_> :o~
13:08:18 <Eduardo_> thanks man
13:08:24 <edwardk_> > let f :: Double -> Int; f = fromIntegral in f (1 + 2)
13:08:26 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
13:08:26 <lambdabot>    arising from a use ...
13:08:31 <ski> if you indent properly, you can omit the `;'
13:08:31 <edwardk_> er toIntegral
13:08:41 <edwardk_>  > let f :: Double -> Int; f = toIntegral in f (1 + 2)
13:08:52 <edwardk_> helps i suppose not to include the extra space
13:08:58 <edwardk_> > let f :: Double -> Int; f = toIntegral in f (1 + 2)
13:08:59 <lambdabot>   Not in scope: `toIntegral'
13:09:17 <edwardk_> > let f :: Double -> Int; f = ceiling in f (1 + 2)
13:09:18 <lambdabot>   3
13:09:20 <edwardk_> ;)
13:09:47 <dpratt71> edwardk_: I keep bumping into material such as you've posted and other somewhat related stuff such as is posted by sigfpe and wishing to understand it
13:09:59 <edwardk_> Eduardo_: you may need to use ScopedTypeVariables if you want to mix types that are bound by surrounding lexical scopes
13:10:08 <dpratt71> since going and getting a Math degree really isn't in the cards at the present, I'm hoping that I'll keep reading this stuff and it will eventually sink in
13:10:26 <pchiusano> hi, I am looking at the Iteratee article in latest Monad reader
13:10:43 <edwardk_> heya paul
13:11:14 <pchiusano> question - it looks straightforward to "zip" together two Iteratees, but not to zip together two enumerators
13:11:17 <EvanR-work> :t ceiling
13:11:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:11:21 <pchiusano> hi edwardk_ :)
13:11:56 <edwardk_> Enumerator a = Iteratee a -> Iteratee a -- ?
13:12:16 <copumpkin> EvanR: omg a piece of an adjunction! :P
13:12:16 <k23z__> can I overload the already define length() function to accept my new type ?
13:12:20 <Eduardo_> I'm trying to hack something here, I got type "IO [FilePath]", how can I filter this and compare this FilePath (as in docs say is a String) with a string?
13:12:36 <copumpkin> k23z__: no
13:12:40 <Eduardo_> I know how to use filter, the problem is with types
13:12:42 <k23z__> copumpkin, but why not ?
13:12:46 <copumpkin> :t length
13:12:47 <edwardk_> k23z__: fraid not, length is defined monomorphically
13:12:47 <lambdabot> forall a. [a] -> Int
13:12:48 <pchiusano> edwardk_: Iteratee (a, a)
13:13:03 <ski> k23z__ : no, but if you really want to, you can define a type class with a `length' method that you can overload like that
13:13:03 * hackagebot HList 0.2.3 - Heterogeneous lists  http://hackage.haskell.org/package/HList-0.2.3 (AdamVogt)
13:13:18 <pchiusano> erm
13:13:56 <k23z__> ski, a class ?
13:13:56 <pchiusano> not sure if my question makes sense
13:14:23 <ski> k23z__ : only operations that are defined in type classes can be overloaded individually for new types
13:14:36 <edwardk_> pchiusano: well, an enumerator sends more data to an iteratee, zipping enumerators could send different amounts of data to each 'side' of an iteratee
13:14:37 <ski> k23z__ : e.g. `Show' is a type class that has the operation `show'
13:14:40 <edwardk_> which could be bad
13:15:01 <ski> k23z__ : the `deriving Show' you added is just a shorthand for overloading `show' on your new type
13:15:13 <pchiusano> edwardk_: why would that be bad?
13:15:21 <gwern> huh. did you know the game 'Telephone' was in an earlier Victorian incarnation named 'Russian Scandal'?
13:15:27 <EvanR-work> k23z__: theres genericLength, so its not unprecedented to make your own length function with its own name ;)
13:15:34 <edwardk_> k23z__: you could define: class Size t where size :: t -> Int; instance Size [a] where size = length; instance Size Sentence where size (Sentence xs) = length xs
13:15:40 <ski> k23z__ : similarly, you can define a new type class, `HasLength' (or whatever you want to call it)
13:16:09 <EvanR-work> can you make a HasLength instance for lists?
13:16:09 <k23z__> ah yes I'll just make my own
13:16:17 <k23z__> you guys shoot at me so many methods my head explodes
13:16:26 <ski> EvanR-work : see what edwardk_ said :)
13:16:29 <EvanR-work> ah
13:16:35 <k23z__> and I thought Perl was TIMTOWDI, Haskell blows Perl the fuck away
13:16:58 <ski> k23z__ : a little head explosion now and then is good for your mental health :D
13:16:59 <edwardk_> well, taking the simple oleg era definition of Enumerator a as Iteratee a -> Iteratee a, then zipping Enumerators would take Enumerator a -> Enumerator b -> Enumerator (a,b) -- but enumerators can chunk up input, feed input to iterators, and generally do all sorts of wacky things
13:17:21 <edwardk_> i can't feed data to one half of an Iterator (a,b)
13:17:21 <EvanR-work> what is this mythical oleg
13:17:35 <gwern> @quote oleg
13:17:36 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
13:17:47 <gwern> @fact oleg
13:17:47 <lambdabot> I know nothing about oleg
13:17:58 <ski> @where oleg
13:17:58 <lambdabot> http://okmij.org/ftp/
13:17:59 <gwern> oh noes did we lose our oleg facts again?
13:18:08 <gwern> @quote oleg
13:18:09 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
13:18:12 <gwern> @quote Oleg
13:18:12 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
13:18:12 <edwardk_> EvanR-work: really smart guy who works at FNMOC and comes down from the mountain to bless us with emails that routinely demonstrate something that was once thought to be impossible to be easy to implement... and usually implements it in the type system
13:18:31 <gwern> @quote Oleg
13:18:32 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
13:18:37 <gwern> hm. I guess so
13:18:58 <gwern> @quote OlegFacts
13:18:58 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
13:19:12 <EvanR-work> lol
13:19:24 <gio123> ski:
13:19:26 <gio123> ski:
13:19:43 * EvanR-work uses his coder ring to see what gio123 said
13:19:46 <Raynes> skiddy
13:20:05 * hackagebot hpage 0.10.2 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.10.2 (FernandoBenavides)
13:20:06 <edwardk_> pchiusano: consider the action of one enumerator that wants to feed you 50 a's and one that wants to chunk your input up into 1k fragments before sending it to b, you _can_ define a way to zip enumerators, but you have to buffer up one side or the other, and lose all the nice space guarantees
13:21:27 <pchiusano> here, here is the function I am trying to write: Enumerator a -> Enumerator b -> Iteratee a r1 -> Iteratee b r2 -> Iteratee (a,b) (r1,r2)
13:22:00 <aavogt> @type ***
13:22:01 <lambdabot> parse error on input `***'
13:22:05 <aavogt> @type (***)
13:22:06 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:22:15 <k23z__> Botje,   does Haskell have    the     <=> from Perl ?
13:22:20 <k23z__> Botje, are you still on the train ?
13:22:21 <ben_m> k23z__: compare
13:22:25 <ben_m> :t compare
13:22:25 <k23z__> compare nice :)
13:22:26 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:22:29 <Veinor> > compare 2 3
13:22:29 <edwardk_> k23z__: compare
13:22:30 <lambdabot>   LT
13:22:31 <Veinor> > compare 4 3
13:22:33 <lambdabot>   GT
13:22:34 <k23z__> thanks :)
13:22:35 <ski> > 42 `compare` 23
13:22:36 <lambdabot>   GT
13:22:48 <pchiusano> edwardk_: it sort of seems like I want something that pauses after each push of data to the iteratee
13:22:49 <ski> @src (<=)
13:22:50 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
13:23:10 * ski prefers writing it infix
13:23:19 <edwardk_> in perl it gives you -1, 0, or 1, 'fromEnum' on the 'Ordering' you get back gives you exactly that, but you can also just use the Ord instance to compare those directly, etc.
13:23:24 <EvanR-work> in real world haskell it suggests an expression  fst (e1, e2) may return e1 OR one of several nasty things, one of which is an infinite loop. how is that possible?
13:23:25 <edwardk_> > fromEnum LT
13:23:26 <lambdabot>   0
13:23:53 <Veinor> > let x = (x,2) in fst x
13:23:53 <edwardk_> odd, i thought fromEnum LT was -1, i must have misremembered
13:23:54 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t, t1)
13:24:08 <Veinor> > let x = x in fst (x,2)
13:24:09 <pchiusano> but yeah I guess that would be a problem if the two enumerators have different chunk sizes
13:24:12 <lambdabot>   mueval-core: Time limit exceeded
13:24:39 <edwardk_> pchiusano: sadly yes
13:24:43 <EvanR-work> ah
13:24:49 <EvanR-work> Veinor: good call
13:25:03 <pchiusano> you could do it with fixed size chunking
13:25:04 <ski> > map (fromEnum `graph`) [LT .. GT]
13:25:05 <lambdabot>   [(LT,0),(EQ,1),(GT,2)]
13:25:26 <edwardk_> EvanR-work: fst undefined; fst (let x = x in x), ...
13:25:27 <Botje> k23z__: no, <=> is compare in haskell
13:25:31 <Botje> k23z__: but i'm playing left 4 dead 2 :p
13:25:45 <EvanR-work> edwardk_: right in particular i was asking about infinite loops
13:25:48 <edwardk_> @type graph
13:25:49 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
13:25:52 <triyo> Anyone know of a cheat-sheet that has Functor, Applicative, Monoid, Monad and related class type and function signatures with their laws?
13:25:57 <ski> @type cograph
13:25:58 <lambdabot> forall (ar :: * -> * -> *) a b. (ArrowChoice ar) => ar a b -> ar (Either a b) b
13:26:11 <EvanR-work> triyo: sounds like a fun rainy day project
13:26:17 <Veinor> I kind of want to make this now
13:26:27 <edwardk_> cute
13:26:30 <ski> edwardk_ : sometimes handy to use
13:26:40 <copumpkin> Veinor: what?
13:26:46 <triyo> indeed, especially would suit a n00b like myself. ;)
13:27:29 <triyo> If no one is keen, I'd be happy to do it over the weekend
13:27:35 <Veinor> a cheatsheet with the {monoid,functor,applicative,monad} laws
13:28:34 <EvanR-work> any non pathological function of type (a,b) -> a must do what fst does?
13:28:48 <ski> yes, more or less
13:28:57 <ski> (it could use `seq' on the right part)
13:29:11 <pchiusano> edwardk_: I vaguely remember in your original monoids talk you made some offhand remark about an improvement to Iteratees, do you remember what you said?
13:29:18 <aristid> @hoogle (a, b) -> a
13:29:19 <lambdabot> Prelude fst :: (a, b) -> a
13:29:19 <edwardk_> monoid: mempty `mappend` a = a `mappend` mempty = a; (a `mappend` b) `mappend` c = a `mappend` (b `mappend` c); fmap f . fmap g = fmap (f . g); fmap id = id; return >=> f = f >=> return = f; (a >=> b) >=> c = a >=> (b >=> c) -- and the applicative stuff ;)
13:29:19 <lambdabot> Data.Tuple fst :: (a, b) -> a
13:29:19 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
13:29:41 <EvanR-work> ski: is this a general property of all polymorphic functions
13:29:42 <aristid> EvanR-work: a partially applied uncurry has that type, too
13:29:42 <edwardk_> pchiusano: what i defined wasn't strictly an improveent to iteratees, just something that made them suitable to my needs
13:29:45 <c_wraith> fish!
13:29:56 <gwern> triyo: typeclassopedia?
13:30:01 <ski> EvanR-work : yes, it comes from parametric polymorphism
13:30:09 <edwardk_> pchiusano: what i did was gave iteratees access to their history so i could run parsec parsers over them
13:30:10 * hackagebot TTTAS 0.4.0 - Typed Transformations of Typed Abstract Syntax  http://hackage.haskell.org/package/TTTAS-0.4.0 (MarcosViera)
13:30:12 <ski> EvanR-work : look up "Theorems for Free !" by Wadler
13:30:25 <ski> @free (a,b) -> a
13:30:25 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
13:30:28 <edwardk_> pchiusano: without using the magic out-of-band backtracking machinery that you use for it now
13:30:29 <k23z__> ski, http://i.imgur.com/4knj3.png
13:30:32 <triyo> gwern: I was just gonna mention that now "typeclassopedia" is awesome
13:30:36 <ski> @free foo :: (a,b) -> a
13:30:36 <lambdabot> f . foo = foo . $map_Pair f g
13:30:39 <k23z__> ski, I tried to declare a comparison function and I got an error
13:30:41 <edwardk_> i was doing so because i was using them in a reducer/measure over a fingertree of bytestrings
13:30:54 <pchiusano> edwardk_: right, so you could reparse
13:30:55 <k23z__> it says I used it as a class
13:31:02 <Veinor> something I don't get: don't pretty much all parametric classes have an a -> m a?
13:31:02 <edwardk_> pchiusano: yeah
13:31:11 <pchiusano> edwardk_: okay, makes sense
13:31:30 <Veinor> or at least, some way to make one of them
13:31:34 <ski> k23z__ : `sCompare :: (Sentence a) => a -> a -> Ordering' is incorrect for what you want to do
13:31:44 <c_wraith> Veinor: Functor doesn't
13:31:51 <edwardk_> k23z__: what you want is sCompare :: Sentence -> Sentence -> Ordering
13:31:52 <ski> k23z__ : you want (i think) `sCompare :: Sentence -> Sentence -> Ordering'
13:32:02 <edwardk_> you want a function that takes two sentences and gives you an ordering between them
13:32:10 <triyo> gwern: only thing I'm thinking is all summarized on few short pages and not 40+ :)
13:32:10 <k23z__> edwardk_ ski  ok I'll use that
13:32:12 <Veinor> c_wraith: what's an example of a Functor that doesn't have one?
13:32:30 <c_wraith> Veinor: ((,) a)
13:32:44 <ski> k23z__ : btw, in the `otherwise' case, i think you probably want to compare the actual contents of the sentences, no ?
13:33:01 <Veinor> where ((,) a) b is the tuple (a,b)?
13:33:06 <c_wraith> yes
13:33:07 <edwardk_> veinor there are lots of them, you need to be able to construct the rest of the 'stuff' in your functor. ((,) a) is a good one
13:33:11 <Veinor> ahh.
13:33:20 <c_wraith> > fmap (+10) ("foo", 15)
13:33:20 <lambdabot>   ("foo",25)
13:33:32 <gwern> triyo: you want a cheathsset of a cheatsheet?
13:33:33 <gwern> hardcore
13:33:36 <Veinor> is (a (,)) a functor as well?
13:33:40 <edwardk_> yeah
13:33:52 <Veinor> > fmap (+10) (15, "foo")
13:33:53 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
13:33:53 <lambdabot>    arising from the literal ...
13:33:59 <Veinor> didn't think that'd work.
13:34:03 <aavogt> what is (a (,))?
13:34:05 <edwardk_> the opposite also fails to hold there exist functors for which you can't safely define f a -> a -- either
13:34:08 <Veinor> why is the one definition used and not the other?
13:34:12 <Veinor> edwardk_: like IO!
13:34:13 <ski> Veinor : itym `(,a)' aka `\x -> (x,a)'
13:34:23 <c_wraith> Veinor: I'd use Maybe as an example for that. :)
13:34:30 <Veinor> or []
13:34:31 <edwardk_> Veinor: exactly =) IO, [], Maybe, etc.
13:34:52 <ski> (`(,) a' can be written as `(a,)', though i don't think that's valid GHC haskell atm)
13:34:54 <aavogt> doesn't `a' in (a (,))  have kind     (* -> * -> *) -> ...
13:35:00 <k23z__> ski,  how can I derive from Ord as well and impose my new type to have a particular comparison function which I specify ? I want to do this in order to be able to use maximum on a list of MyType
13:35:00 <edwardk_> Veinor: but there are a whole class of functors for which you can. i.e. (,) a -- can have an extract = snd that does just that
13:35:20 <aavogt> ski: -XTupleSections
13:35:21 <k23z__> ski, the otherwise case is ok
13:35:21 <Veinor> well, I guess my question is
13:35:28 <ski> aavogt:h, ty
13:35:33 <c_wraith> edwardk_ is talking about Pointed and CoPointed classes now.  indirectly.  :)
13:35:33 <ski> s/h/ah/
13:35:38 <edwardk_> k23z__: instance Eq Sentence where Sentence a == Sentence b = length a == length b; instance Ord Sentnce where compare = sCompare
13:35:51 <ski> k23z__ : well, by not deriving `Ord', instead writing an instance of `Ord' manually
13:36:11 <ski> k23z__ : `instance Ord Sentence where a `compare` b = ..a..b..'
13:36:12 <k23z__> edwardk_, can you please explain what does that mean ?
13:36:21 <edwardk_> @class Ord
13:36:21 <lambdabot> Unknown command, try @list
13:36:23 <edwardk_> er
13:36:25 <edwardk_> @src Ord
13:36:26 <lambdabot> class  (Eq a) => Ord a  where
13:36:26 <lambdabot>     compare      :: a -> a -> Ordering
13:36:26 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
13:36:26 <lambdabot>     max, min         :: a -> a -> a
13:36:37 <edwardk_> note that to be an "Ord" you must first be an instance of "Eq"
13:36:39 <edwardk_> @src Eq
13:36:39 <lambdabot> class  Eq a  where
13:36:39 <lambdabot>     (==), (/=)   :: a -> a -> Bool
13:36:58 <edwardk_> Eq has two members, (==) and (/=) which are interdefined, so defining one or the other is sufficient
13:37:06 <Veinor> I guess my question is: what's the type constructor that sends String to (String, a) called?
13:37:22 <edwardk_> you want your Sentence to be a valid 'instance' of Eq, so that you can substitute 'Sentence' for the 'a's in the type signature there
13:37:22 <ski> Veinor : it can't be expressed in haskell
13:37:35 <Veinor> but the one that sends it to (a, String) can?
13:37:39 <copumpkin> yeah
13:37:43 <Veinor> as ((,) a)
13:37:45 <Veinor> why?
13:37:46 <ski> Veinor : yes, because of the currying order
13:37:57 <edwardk_> haskell classes work differently in haskell than you might be used to
13:37:59 <k23z__>  instance Eq Sentence where Sentence a == Sentence b = length a == length b; instance Ord Sentnce where compare = sCompare
13:38:24 <k23z__> what I understood was just the part about      compare = sCompare
13:38:29 <k23z__> the other stuff I didn't understand
13:38:32 <edwardk_> instance Eq Sentence where Sentence a == Sentence b = length a == length b -- is defining your Eq instance, which is a prerequisite to being an Ord instance
13:38:44 <ski> `(a, String)' really means `(,) a String' (which *really* is `((,) a) String', since application is left-associative), so if we set `f' to be `(,) a', we get `f String'
13:38:47 <aristid> @hoogle (,)
13:38:47 <lambdabot> Prelude undefined :: a
13:38:48 <lambdabot> Test.QuickCheck.Batch bottom :: a
13:38:48 <lambdabot> Data.Function fix :: (a -> a) -> a
13:38:50 <ski> Veinor : ^
13:39:03 <edwardk_> you're saying i want to be able to substitute 'Sentence' for a' in the definitions given by the class Eq I showed above
13:39:13 <Veinor> ski: ahh, I get it now
13:39:46 <edwardk_> Sentence a == Sentence b = ... is just defining a function
13:40:03 <ski> Veinor : one can of course define `type Foo x = (x,a)' but that doesn't help, since GHC doesn't allow you to use `Foo' here, except applied to an argument
13:40:27 <edwardk_> but you can't just define it at the top level because you want to make your '==' function play nice with all the others. hence the instance
13:41:04 <ski> k23z__ : to overload `compare' (and `(<)' and `(<=)' and ...) on your new type `Sentence', you "make `Sentence' an instance of the type class `Ord'", by saying `instance Ord Sentence where compare a b = ...'
13:41:37 <edwardk_> k23z__: http://www.haskell.org/onlinereport/basic.html defines a bunch of built in typeclasses, scroll down to 6.3.1 and you'll find the definition for Eq, and the definition for Ord right below it
13:41:48 <ski> k23z__ : but `Ord' requires you to make an instance of `Eq', first (you need to define `(==)',`(/=)' first (one of them is enough, the other will be defined in terms of the first)
13:42:33 <k23z__> ski, but isn't == for lists already defined as element-wise equality ? why do I have to do it ?
13:42:45 <ski> k23z__ : your new type `Sentence' is not a list
13:42:52 <ski> it contains lists
13:42:55 <edwardk_> k23z__: because your (==) should be compatible with your 'compare'.
13:42:56 <ski> that's not the same thing
13:42:59 <k23z__> ski, it's a list of strings
13:43:02 <ski> no
13:43:06 <ski> it *contains* a list of strings
13:43:08 <edwardk_> a == b = compare a b == EQ -- should hold
13:43:17 * hackagebot ChristmasTree 0.2 - Alternative approach of 'read' that composes grammars instead of parsers.  http://hackage.haskell.org/package/ChristmasTree-0.2 (MarcosViera)
13:43:20 <ski> maybe you don't *want* `(==)' defined on `Sentence'
13:43:26 <ski> Haskell has no way of knowing
13:43:27 <k23z__> ski, what do you mean contains ?
13:43:29 <edwardk_> and [String]'s compare would compare the text, not the lengths
13:44:41 <ski> k23z__ : if you have a list of strings, like `["Hi","there"]' (which has type `[String]'), then can you use the `Sentence' data constructor to wrap this into `Sentence ["Hi","there"]' (which now has type `Sentence')
13:45:05 <ski> `["Hi","there"]' is not the same as `Sentence ["Hi","there"]'
13:45:10 <ski> the latter contains the former
13:45:17 <k23z__> ah ok I get it
13:45:21 <k23z__> now returning
13:45:25 <k23z__> I need to make an instance
13:45:33 <ski> two instances :)
13:45:41 <ski> (one for `Eq' and one for `Ord')
13:46:55 <ski> (btw, this is one reason why i prefer naming data constructors differently than the type constructor, when explaining)
13:47:02 <edwardk_> ChristmasTree (Changing Haskell's Read Implementation Such That by Mainpulating ASTs it Reads Expressions Efficiently) as an acronym is a bit forced ;)
13:47:05 <k23z__> ok it worked !!!!
13:47:09 <k23z__> aaaaaaaaaaaa !!!
13:47:17 <k23z__> great
13:47:25 <k23z__> now I have to fucking understand what the hell I just did
13:47:29 <k23z__> I will re-read edwardk_ and ski
13:47:45 <nostrand> !seen walt
13:47:46 * edwardk_ is re-read. it tickles.
13:47:59 * ski re-writes edwardk_
13:48:14 <Silvah> Could you stop using such offensive language?
13:48:19 * hackagebot AspectAG 0.2 - Attribute Grammars in the form of an EDSL  http://hackage.haskell.org/package/AspectAG-0.2 (MarcosViera)
13:48:47 * edwardk_ is pure and functional. you can't rewrite me. you can only copy me and have your way with my clone
13:49:32 <ski> (hm .. an army of edwardk_ clones .. might be handy, somehow)
13:49:47 <edwardk_> ski: between us, some day we might even finish kata ;)
13:50:21 <copumpkin> right ;)
13:50:25 <gwern> and start work on its successor, kumite
13:50:30 * ski lost track of the current state
13:50:47 <copumpkin> :t get
13:50:48 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
13:50:53 <copumpkin> ski: there you go
13:51:00 <Silvah> lol
13:51:10 <gwern> it's the same as always - emergency
13:51:16 <ski> well, i need to figure out how to execute it remotely, too !
13:51:49 <k23z__> is this stuff I just did in any way efficient ?
13:51:52 <k23z__> is Haskell efficient ?
13:51:55 <edwardk_> gwern: heh i was going for randori, but that works too ;)
13:52:03 <gwern> and better
13:52:04 <Silvah> It is not.
13:52:07 <k23z__> it seems I've just done some really crazy stuff I wouldn't have imagined to do anywhere else
13:52:17 <copumpkin> k23z__: it can be efficient :)
13:52:46 <k23z__> copumpkin, I suppose it can if you don't use extremely fancy stuff from the arsenal right ?
13:52:50 <olsner> what is/was/will-be kata?
13:52:54 <edwardk_> k23z__: it is reasonably efficient. your sentences could hold onto their lengths, etc. if you really wanted to speed things up a tiny bit, but its not likely to help much
13:53:01 <copumpkin> k23z__: oh no, the extremely fancy stuff can be just as efficient
13:53:08 <Cale> k23z__: What is it that you've just done?
13:53:14 <copumpkin> k23z__: you have no real penalty for going fancy, if you're fancy in the right way
13:53:18 <k23z__> Cale, something really crazy
13:53:25 <k23z__> Cale, let me show you, the guys are witnesses
13:53:29 <Veinor> what's the recommended way to read in a file and split it into lines? I seem to remember readFile and then lines being bad in some way
13:53:40 <Veinor> because of lazy IO
13:53:44 <ski> Cale : k23z__ defined a new type to be an instance of `Eq' and `Ord'
13:53:58 <c_wraith> :t mapM readLine
13:53:59 <lambdabot> Not in scope: `readLine'
13:54:01 <Cale> oh, that's not *so* crazy :)
13:54:11 <edwardk_> olsner: lemme dig up a syntax fragment ;)
13:54:17 <ski> i'd even wager to say it is quite normal :)
13:54:34 <Veinor> c_wraith: I guess the question is: how do you strictly read a file into a string?
13:54:37 <Cale> k23z__: Judging efficiency is something that is really quite hard to do as a beginner in Haskell. Treat it kind of like your first programming language -- it (probably) took a good while before you had a good handle on what was efficient or not in that as well :)
13:54:47 <c_wraith> Veinor: I'd use readLine, as it strictly reads one line of input.
13:54:53 <edwardk_> hrmm hpaste.org seems to have eaten itself, but here is the google cache http://webcache.googleusercontent.com/search?q=cache:vIav2Sn7GyMJ:hpaste.org/fastcgi/hpaste.fcgi/view%3Fid%3D23226+kata+hpaste&cd=1&hl=en&ct=clnk&gl=us&client=firefox-a
13:54:57 <c_wraith> err, getLine
13:55:11 <Veinor> getLine reads from stdin
13:55:12 <Cale> k23z__: But defining Eq and Ord for a new type is just writing a normal function or two and giving them appropriate names :)
13:55:14 <ski> @type readLine
13:55:15 <lambdabot> Not in scope: `readLine'
13:55:17 <c_wraith> :t System.IO.hGetLine
13:55:18 <lambdabot> GHC.IOBase.Handle -> IO String
13:55:22 <ski> @type readLn
13:55:23 <lambdabot> forall a. (Read a) => IO a
13:55:24 <edwardk_> k23z__: don't worry about efficiency until you have something that runs slowly ;)
13:55:39 <Veinor> hmm.
13:55:40 <c_wraith> Veinor: you can add an h in front of most IO functions to make them work with a handle
13:55:52 <Silvah> And by slowly he means... oh well.
13:55:53 <olsner> edwardk_: the best thing about that advice is that it applies to all languages!
13:56:16 <zachk> k23z__: how does effeciency matter when we all have dual/quad cores and over 2 gigs of ram ... just wing it ... sometimes i let things run for a few hours, if i get no output then i kill it
13:56:21 <c_wraith> well, I should say "many", not "most".  But it gets the point across.
13:56:22 <aavogt> there may be some languages where efficiency leads to prettier code
13:56:25 <Cale> k23z__: I suppose the jarring thing is that you *can* define functions whose names consist of a bunch of symbol characters and are written infix, or that you can write definitions of functions which work differently on different types.
13:56:53 <Silvah> zachk: write some programs for GBA.
13:57:04 <edwardk_> oslner: did that link work?
13:57:09 * dolio doesn't have a dual or quad core.
13:57:24 * hackagebot SyntaxMacros 0.1 - Syntax Macros in the form of an EDSL  http://hackage.haskell.org/package/SyntaxMacros-0.1 (MarcosViera)
13:57:35 * zachk has a gba a dual core laptop and a quad core 
13:57:42 <Eduardo_> read lots about Monads and IO, but still don't know the difference of "IO Bool" and "Bool"
13:57:45 <Eduardo_> what is it?
13:57:45 <zachk> i rather like my gba micro
13:58:01 <Cale> Eduardo_: an IO Bool is a description of some things which could be done to produce a Bool
13:58:01 <copumpkin> Eduardo_: don't try to figure out monads this early. IO Bool is just an imperative computation that returns a Bool
13:58:04 <zachk> i think of IO a as actions
13:58:16 <zachk> you can only pull stuff out of them in an IO monad
13:58:24 <olsner> edwardk_: ah, there! looks like the link worked... was about to ask "which link" but turns out I skipped the line with the link at all since it was so full of gobbledygook :)
13:58:24 <zachk> a bool is just True or False
13:58:26 <Cale> Eduardo_: and normal Haskell evaluation doesn't cause that description to execute
13:58:34 * BMeph has a dual-core 64-bit Pentuim (not PIII, not P5) at home!
13:58:36 <Eduardo_> hmm
13:58:43 <Cale> (any more than opening up the source code of a program in a text editor would cause it to run)
13:58:44 <Silvah> Well, why everyone wants to undestand monads ASAP?
13:58:51 <Eduardo_> hahah
13:58:54 <copumpkin> Silvah: because everyone hypes them up so much
13:59:01 <edwardk_> Eduardo_: think of an IO Bool as 'something you can do that might have side effects that will get you a Bool' where a a Bool is something you can inspect to get a Bool that won't have any further side effects
13:59:06 <Eduardo_> well I'm trying to hack a code which uses IO
13:59:08 <copumpkin> Silvah: and most programmer types consider themselves intelligent and want to learn these supposedly arcane things
13:59:52 <Eduardo_> got it edwardk_
13:59:54 <Eduardo_> at least in theory
13:59:59 <Cale> Eduardo_: It's important to understand the words that Haskell programmers use: Evaluation is the process of turning expressions into values. Execution means carrying out the instructions that an IO action describes.
14:00:15 <Silvah> I still don't understand monads, yet I know how to use them. This will suffice.
14:00:16 <edwardk_> Eduardo_: first thing most people ask is how can i get a value out of IO. the answer that they don't like, but which is at least conceptually true is that you can't.
14:00:22 <olsner> edwardk_: so the summary is kind of that kata is a new functional language with a more CT:y base than haskell?
14:00:23 <Cale> And evaluation never (okay, *almost* never) causes execution to occur.
14:01:28 <edwardk_> olsner: kata is basically an dynamically-typed haskell like language, giving up types means i give up typeclasses, so i rederive them using ml-like modules passed around as explicit dictionary objects, but to get code reuse i use inheritance when building the dictionaries
14:01:30 <Cale> Only execution causes more execution to occur, and in a compiled program, main gets executed.
14:01:53 <jmcarthur> edwardk_: how is that working out, btw?
14:02:08 <edwardk_> jmcarthur: good, except i've had limited time to work on it
14:02:19 <jmcarthur> that is something i definitely understand
14:02:28 <Eduardo_> Cale: that's hard to understand in theory
14:02:43 <Veinor> c_wraith: okay, so using hGetContents I then have to unpack ot to work with my existing String function
14:02:43 <Cale> Eduardo_: We have do-notation, which will let you compose smaller IO actions into larger ones. Writing v <- x inside a do-block means "execute the action x and name its result v"
14:02:46 <Eduardo_> since i'm a beginner to functional programming
14:02:46 <Veinor> which makes it run slower
14:02:52 <edwardk_> jmcarthur: i finally worked out all of the issues i was having with the interaction between hygienic macros, layout, imports, and infix operators though
14:03:11 <edwardk_> jmcarthur: and the way lexical scoping works coming in and out of classes
14:03:19 <Cale> Eduardo_: It'll become clearer with some examples, perhaps.
14:03:28 <ski> edwardk_ : hygienic macros ? shiny !
14:03:31 <edwardk_> that interaction caused me no end of grief for the better part of a year
14:03:34 <Eduardo_> Cale: right
14:03:38 <k23z__> oh great another beginner
14:03:45 <k23z__> I thought there were only ninja's here
14:03:45 <Eduardo_> so the IO you're talking about is the concept
14:03:49 <k23z__> *ninjas
14:03:59 <ski> k23z__ : there's lots of beginners :)
14:04:12 <jmcarthur> beginner ninjas are still ninjas
14:04:13 <copumpkin> edwardk_ is a mysophobe
14:04:22 <Eduardo_> and not the `IO' thing
14:04:25 <Eduardo_> Cale: is it?
14:04:27 <zakwilson> I've been using Haskell for over a year. I'm still most certainly a beginner.
14:04:27 <jmcarthur> or at least ninja-ish
14:04:31 <Cale> Eduardo_: So, when you write a do-block, you chain together a bunch of actions, with the later ones perhaps depending on the results of the previous ones, and you make a new IO action.
14:04:46 <Cale> That is, the do-block as a whole is itself an IO action.
14:04:48 <edwardk_> copumpkin: you actually said that while i was applying hand sanitizer ;)
14:04:52 <Cale> and it's built up of simpler ones
14:04:58 <olsner> edwardk_: and dynamically typed here means something like every object carrying around a list of type-class dictionaries?
14:05:03 <Cale> So, we have:  getLine :: IO String
14:05:10 <Cale> putStrLn :: String -> IO ()
14:05:12 <copumpkin> edwardk_: yeah, I set up a camera to observe you! if I am to become you I need to learn your ways
14:05:16 <Cale> and we can put them together like this:
14:05:26 <Cale> do x <- getLine; putStrLn x
14:05:32 <Cale> :: IO ()
14:05:56 <Cale> The IO action always has the same type as the last line of the do-block
14:06:21 <Cale> and each of the lines of the do-block consists of an action to run (or a 'let' with some definitions)
14:06:35 * ski grins at #haskell in action
14:06:44 <BMeph> k23z__: We're Humble in Haskell - everyone's a beginner! (Except maybe the Simons and augustss....)
14:06:54 <copumpkin> Cale: :: IO ()
14:07:02 <Veinor> okay... how do I get the Word8 corresponding to the letter 'q'?
14:07:06 <copumpkin> BMeph: not I! I know everything and then some
14:07:06 <Eduardo_> how that differs from getLine :: String ?
14:07:10 <edwardk_> olsner: yes and no. you use classes like you do in haskell, you want smart objects manipulating 'dumb data'. so an object is a dictionary, the monad class defines a set of methods for manipulating the values in the monad.dynamically typed says the compiler doesn't check that the object you look up the dictionary slot in actually has an entry for it
14:07:16 <tromp> > (sqrt 28+sqrt 27)**(2/3) + (sqrt 28-sqrt 27)**(2/3) :: CReal
14:07:17 <Cale> Eduardo_: If getLine was a String, which string would it be?
14:07:17 <lambdabot>   5.0
14:07:18 <Silvah> We seriously need other name for that concept, cuz current one often frightens small programmers...
14:07:30 <jmcarthur> > fromIntegral . ord $ 'q' :: Word8
14:07:31 <lambdabot>   113
14:07:32 <Cale> Eduardo_: It can't be "hello", because I might not type that.
14:07:36 <jmcarthur> Veinor: ^^
14:07:40 <Eduardo_> err
14:07:58 <Eduardo_> forget that was a user-input-string
14:08:00 <Eduardo_> :P
14:08:05 <Veinor> > fromIntegral . ord $ 'j' :: Word8
14:08:06 <lambdabot>   106
14:08:13 <ski> Silvah : maybe "warm fuzzy thing" ?
14:08:14 <edwardk_> olsner: you can go off and define class rectangle public width; height; area = width * height -- style objects, but in general the way things work is the object plays the role of the instance, and you work with dumb data.
14:08:26 <Cale> Eduardo_: Right, getLine is not a String, but instead a description of something the computer could do to make one.
14:08:39 <Cale> Eduardo_: Which is, in this case, to prompt the user for input.
14:08:48 <Silvah> ski: erm... nope?
14:08:54 <Eduardo_> oh...
14:09:18 <olsner> ah, so then you can use different objects to operate on the same dumb data, where haskell instead maps each kind of dumb data to a specific instance?
14:09:38 <edwardk_> olsner: the type checker checks to make sure that when you instantiate an object that you supply all the members it expects, but it doesn't check that when you ask for a member of an object that the object can supply it
14:09:41 <Eduardo_> ok, but the IO as output?
14:09:47 <edwardk_> yeah
14:09:47 <Veinor> okay... this is weird
14:09:55 <Veinor> the more bytestring stuff I add the slower my program is going :(
14:10:06 <Cale> Eduardo_: Well, things which have output effects often don't have meaningful results, right?
14:10:06 <hpc> Eduardo_: think of IO as your door to the outside world
14:10:08 <Eduardo_> something that may produce an output of X
14:10:12 <edwardk_> so saying foo = new rectangle with width = 12 -- would be complained about at compile time, because you didn't specify height.
14:10:14 <Cale> Eduardo_: They just do some output, and they're done.
14:10:33 <Cale> Eduardo_: So what we do by convention is just to have those things produce empty tuples as their result
14:10:39 <Cale> putStrLn "hello" :: IO ()
14:10:58 <Cale> This is the action which prints hello on the screen, and its result is just an empty tuple.
14:11:10 <edwardk_> olsner: but if you wrote foo x = x.height -- the compiler won't check that the object passed in x actually has a height field.
14:11:15 <copumpkin> > iterate not False
14:11:16 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
14:11:22 <jmcarthur> Veinor: clearly something is wrong with your approach :)
14:11:38 <Eduardo_> got it, Cale
14:11:42 <Eduardo_> at least I think I do
14:11:52 <BMeph> copumpkin: You do? Awesome! Please send me the link to your implementation of Levien's Io programming language. :)
14:12:19 <Cale> Eduardo_: It'll get clearer as you try to use it. So long as you always maintain in your head the difference between a value of type IO t, and its result of type t, you should be fine :)
14:12:20 <ski> Silvah : "Simon Peyton Jones once commented that the biggest mistake Haskell made was to call them \"monads\" instead of \"warm, fluffy things\"."
14:12:38 <copumpkin> BMeph: I lost it when my hard drive exploded, sorry... too busy right now to write it again from memory
14:12:45 <Cale> Eduardo_: This means, for example, that if you want to putStrLn the result of getLine, you can't write  putStrLn getLine
14:13:04 <edwardk_> ski: nah because we'd start with WarmFluffyThing and then people would start abbreviating it WFT's on channel, and then the internet would start fearing WFTs instead
14:13:15 <Silvah> ski: yeah, I know that.
14:13:19 <Cale> Eduardo_: because getLine isn't a String, it's an IO String, a way to make a String. You have to run it first, and pass its result to putStrLn
14:13:26 <BMeph> copumpkin: But,...but,...you know EVERYTHING!!!
14:13:32 <Cale> So:  do x <- getLine; putStrLn x
14:13:56 <copumpkin> BMeph: sure, but I also know that there's no way for me to give myself more time!
14:14:05 <Veinor> jmcarthur: clearly
14:14:11 <copumpkin> BMeph: because I'm already using my time in the best possible way for my objective function
14:14:22 <Cale> and we have handy operators and such to make these patterns simpler, so you could also get away with writing  putStrLn =<< getLine  but for now, you might be more comfortable sticking with do-notation.
14:14:24 <Veinor> right now, what I'm doing is: w <- readFile "/usr/share/dict/words"
14:14:30 <edwardk_> copumpkin: clearly you need to change your objective function ;)
14:14:44 <copumpkin> edwardk_: to what!
14:14:48 <edwardk_> my objective function is a random number generator
14:14:50 <BMeph> Veinor: Or, as I like to (unhelpfully) put it... "UR DOIN IT RONG!" :)
14:14:55 <copumpkin> my objective function is the best function, because I know everything
14:15:00 <jmcarthur> > concat . iterate (liftA2 (/=) [True, False]) $ [True]
14:15:01 <lambdabot>   [True,False,True,True,False,False,True,False,True,True,False,True,False,Fal...
14:15:04 <Veinor> jmcarthur: so just doing that and printing it back out again takes up about .25 seconds whereas it's .003 seconds with cat
14:15:05 <Cale> Eduardo_: make sense?
14:15:11 <Veinor> so clearly I'm doing something wrong
14:15:15 <Eduardo_> yes
14:15:26 <jmcarthur> Veinor: you must be using strict bytestrings
14:15:34 <Eduardo_> i was doing some tests with the examples you typed
14:15:35 <Cale> Eduardo_: Another nice thing about this way of doing things is that you *can* write functions which take IO actions as parameters
14:15:36 <Veinor> I'm not using any bytestrings right now, I scrapped that code
14:15:46 <copumpkin> use Text
14:15:49 <edwardk_> Veinor: you're probably appending bytestrings somewhere
14:15:54 <Cale> Eduardo_: and then they get to decide if and when and how many times to run them :)
14:15:56 <edwardk_> never append strict bytestrings
14:15:56 <Veinor> just w <- readFile "file"; print w
14:16:02 <Cale> (in their IO action results)
14:16:05 <jmcarthur> Veinor: well, with strict bytestrings, it would read the entire file in before outputting anything. that's not so with String
14:16:12 <Cale> Such functions behave like control structures
14:16:16 <Veinor> right, but I'm not using bytestrings in my code right now
14:16:16 <Cale> For example...
14:16:18 <edwardk_> unless you need to splice one or two across a chunk boundary here or there
14:16:23 <aristid> forM
14:16:25 <Cale> forever x = do x; forever x
14:16:33 <Veinor> my entire main function is just do w <- readFile "/usr/share/dict/words"; print  w
14:16:39 <aristid> @src forever
14:16:39 <lambdabot> Source not found. There are some things that I just don't know.
14:16:43 <aristid> Cale: ^^^
14:16:51 <Cale> With this, we can write   forever (putStrLn "hello")
14:16:59 <jmcarthur> Veinor: try it with lazy bytestrings instead
14:17:03 <Eduardo_> and putStrLn is an action
14:17:05 <Silvah> Why one should never append strict bytestrings?
14:17:06 <Cale> yeah
14:17:09 <Veinor> okay
14:17:10 <Eduardo_> wow
14:17:12 <Eduardo_> great
14:17:17 <jmcarthur> Silvah: it's an O(n) operation
14:17:18 <edwardk_> Silvah: because it takes time proportional to the sum of their lengths
14:17:23 <edwardk_> if you want fast append use Data.Rope ;)
14:17:32 <Veinor> jmcarthur: so, how do I do that?
14:17:35 <Eduardo_> I'm in love with Haskell
14:17:41 <copumpkin> Eduardo_: yay
14:17:45 <Cale> Eduardo_: So we don't need any more built-in control structures, we already have enough to invent any that we might need on the spot.
14:17:45 <Eduardo_> :D
14:17:55 <Cale> (and there are a bunch in the libraries)
14:17:58 <aristid> @djinn IO ()
14:17:59 <lambdabot> Error: Undefined type IO
14:17:59 <mreh> shh, people might hear
14:18:03 <jmcarthur> edwardk_: quick summary of Data.Rope vs. Data.Sequence in algorithmic complexity of common operations?
14:18:03 <Silvah> So exactly as in imperative languages.
14:18:15 <jmcarthur> Veinor: import Data.ByteString.Lazy
14:18:18 <meiersi> edwardk_: couldn't you also use Data.Binary.Builder for quick append?
14:18:23 <jmcarthur> Veinor: and use readFile from that module
14:18:27 <copumpkin> @djinn Not (a, Not a)
14:18:28 <lambdabot> f (a, b) = b a
14:18:31 <copumpkin> @djinn Not (Not a, a)
14:18:32 <lambdabot> f (a, b) = a b
14:18:36 <copumpkin> omg
14:18:46 <tensorpudding> @djinn Not (Not a, Not a)
14:18:46 <lambdabot> -- f cannot be realized.
14:18:53 <edwardk_> jmcarthur: Rope ~ Seq ByteString -- so divide through by big constants proportional to chunk size. reduce space dramatically and it doesn't have the gc traverse the unboxed leaves
14:19:08 <jmcarthur> Veinor: and try using one of the print functions from that module, too
14:19:13 <k23z__> Haskell ternary operator... anything ?
14:19:17 <copumpkin> @djinn Either (Not a) a
14:19:18 <lambdabot> -- f cannot be realized.
14:19:20 <copumpkin> damn!
14:19:23 <Veinor> jmcarthur: okay, yeah
14:19:24 <Eduardo_> Cale: you are a nice teacher :D
14:19:24 <jmcarthur> edwardk_: oh okay cool
14:19:31 <copumpkin> @djinn Not (Not (Either (Not a) a)
14:19:32 <lambdabot> Cannot parse command
14:19:36 <copumpkin> @djinn Not (Not (Either (Not a) a))
14:19:36 <Veinor> B.putStr on a lazy bytestring is pretty fast
14:19:37 <lambdabot> f a = void (a (Left (\ b -> a (Right b))))
14:19:58 <edwardk_> copumpkin: 'devil's bargain'
14:20:07 * copumpkin laughs evilly
14:20:08 <jmcarthur> Veinor: make sure for your benchmarks that you are piping to /dev/null or something
14:20:08 <tensorpudding> Does Haskell even have operators?
14:20:15 <copumpkin> sell me your soul and I will allow you to use LEM
14:20:19 <edwardk_> tensorpudding: they are standing by
14:20:20 <jmcarthur> Veinor: since a lot of time will be spent on the rendering of the text and stuff
14:20:25 <copumpkin> tensorpudding: this channel?
14:20:25 <tensorpudding> There is some special syntax like case, do and if
14:20:29 <BMeph> k23z__: We're Lazy - make one! :)
14:20:32 <tensorpudding> But everything else is a function
14:20:38 <aristid> @undo forever x = do x; forever x
14:20:39 <lambdabot> forever x = x >> forever x
14:20:46 <Veinor> jmcarthur: yeah, I'm piping to /dev/null
14:20:47 <copumpkin> tensorpudding: not values
14:20:51 <jmcarthur> good
14:20:57 <tensorpudding> Well, values or functions
14:20:58 <jmcarthur> Veinor: is this fast enough now?
14:21:02 <Veinor> .014 s for lazy bytestrings, .24 for String, .003 for cat
14:21:09 <aristid> @. pl undo forever x = do x; forever x
14:21:09 <lambdabot> forever = fix (ap (>>))
14:21:12 <jmcarthur> ah much better
14:21:22 <aristid> @src ap
14:21:22 <lambdabot> ap = liftM2 id
14:21:30 <tensorpudding> In any case, a ternary operator wouldn't really work
14:21:39 <Veinor> now back to what I was trying to do!
14:21:40 <aristid> @src liftM2
14:21:41 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:22:02 <Silvah> @pl (\xs -> if not . null . drop 10 $ xs then take 10 xs else replicate 10 Nothing)
14:22:02 <lambdabot> flip (ap (if' . not . null . drop 10) (take 10)) (replicate 10 Nothing)
14:22:06 <edwardk_> jmcarthur: in general the constant factor is pretty good iirc the chunk size varies between 32 bytes and the size of the input, operations in a chunk are at bytestring speed, etc. i mentioned their asymptotics and constant factors at the end of my fingertree talk
14:22:18 <meiersi> jmcarthur: Doesn't the String version also decode the input file and encode it again? couldn't also this account for part of the difference?
14:22:21 <tensorpudding> I guess if/then/else is ternary
14:22:29 <edwardk_> http://comonad.com/reader/wp-content/uploads/2010/04/Finger-Trees.pdf (last couple of slides)
14:22:36 <jmcarthur> Veinor: keep in mind that lazy bytestrings may have simply been faster at this particular task. it may turn out for whatever you are ultimately doing that strict bytestrings (or maybe even the string version) could be faster
14:22:47 <aristid> :t ap
14:22:47 <jmcarthur> depending on the algorithm and such
14:22:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:22:53 <copumpkin> I can't wait until pejo gets supero into ghc
14:23:14 <jmcarthur> meiersi: a big part of it, i'm sure
14:23:25 <Veinor> jmcarthur: right, right
14:23:50 <copumpkin> llvm, the new concurrent GC, dph, supero, constraint families
14:23:58 <copumpkin> man, I can't wait for ghc 6.16 or 7 :P
14:24:02 <edwardk_> heh
14:24:05 <jmcarthur> yeah really
14:24:28 <Silvah> Will it finally support Windows?
14:24:31 * edwardk_ is somewhat sad that dana xu's static contract checking stuff seems to have petered out
14:24:52 <zachk> Silvah: haskell platform supports windows fine
14:24:59 <edwardk_> Silvah: nah. why would the Microsoft Research guys working on the compiler want to bother supporting windows? blech. ;)
14:25:07 <tensorpudding> 6.16 is three major releases in the future isn't it?
14:25:30 <jmcarthur> 2
14:25:42 <tensorpudding> Okay, two.
14:25:44 <aristid> tensorpudding: 6.12 has already arrived :)
14:25:47 <jmcarthur> we are on 6.12, 6.14 is next, then is 6.16
14:25:48 <copumpkin> hagane no renkinjutsushi!
14:25:51 <tensorpudding> So at least a few years in the future
14:25:59 <Silvah> Well, 6.12 AFAIR doesn't support Windows properly, i.e. there's no dynamically linked runtime.
14:26:01 <jmcarthur> more like 1.5 years
14:26:34 <aristid> how can i remember what ap does?
14:26:35 <jmcarthur> ghc releases are, what, around october or something?
14:26:47 <edwardk_> @type (<*>)
14:26:48 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:26:55 <tensorpudding> How often does GHC get major updates?
14:27:03 <jmcarthur> every year
14:27:14 <copumpkin> tensorpudding: the major version number is pretty hard to bump
14:27:20 <edwardk_> f <$> a <*> b <*> c = liftM3 f a b c
14:27:24 <copumpkin> I was told that there may never be another major version bump :P
14:27:30 <Cale> Every year, *just* after the Ubuntu freeze ;)
14:27:43 <Silvah> copumpkin: what did you write?
14:27:49 <jmcarthur> actually it seems there is not a "usual" time of year
14:27:52 <copumpkin> Silvah: ?
14:27:52 <tensorpudding> Err, I meant the minor update.
14:27:57 <jmcarthur> oh maybe i'm wrong
14:28:03 <tensorpudding> Or whatever.
14:28:09 <Silvah> I mean, that Japanese (?) text.
14:28:12 <aristid> @src (<*>)
14:28:12 <lambdabot> Source not found. You untyped fool!
14:28:25 <tensorpudding> I was considering 6.12.1 to 6.12.2 to be minor, and 6.10 to 6.12 to be major
14:28:32 <copumpkin> Silvah: full metal ( actually means steel) alchemist :P
14:28:32 <aristid> edwardk_: <*> is ap?
14:28:38 <ski> aristid : yes
14:28:41 <jmcarthur> 6.12.1 was december. 6.10.1 was 13 months before
14:28:42 <edwardk_> aristid: 'spiritually' yes ;)
14:28:55 <aristid> spiritually? oO
14:28:55 <ski> (and `pure' is `return')
14:28:57 <tensorpudding> Was 6.10 really that short?
14:29:21 <jmcarthur> tensorpudding: major ghc releases are typically about a year apart
14:29:33 <tensorpudding> I'm pretty sure 6.8 was around when I was getting started with Haskell.
14:29:37 <ski> (and `liftM3' is `liftA3' and `fmap' is `liftM' is `liftA' and we're all happy)
14:29:38 <Veinor> jmcarthur: okay, yeah, it's being slow again
14:29:38 <edwardk_> aristid: Applicative's <*> is to ap as fmap is to liftM. they are what the latter should be if the latter was written with compatibility with the former in mind ;)
14:29:56 <tensorpudding> and that was in like...2007?
14:29:57 <edwardk_> @type ap
14:29:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:30:00 <edwardk_> @type <*>
14:30:01 <lambdabot> parse error on input `<*>'
14:30:04 <edwardk_> @type (<*>)
14:30:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:30:07 <Eduardo_> Cale: forever (putStrLn "hello")
14:30:16 <Cale> Eduardo_: yeah?
14:30:19 <edwardk_> if Applicative was a superclass of Monad then they'd be the same
14:30:22 <Veinor> jmcarthur: http://pastebin.com/M3jb5z05
14:30:25 <edwardk_> @type liftM
14:30:26 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:30:27 <edwardk_> @type fmap
14:30:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:30:34 <Eduardo_> Haskell will not evaluate putStrLn "hello" first?
14:30:38 <ski> @type liftA
14:30:39 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
14:30:54 <ski> Eduardo_ : right
14:30:58 <edwardk_> liftA is just silly
14:30:59 <Silvah> @src liftA
14:31:00 <lambdabot> liftA f a = pure f <*> a
14:31:02 <aristid> edwardk_: ah, <*> is a generalisation of ap
14:31:11 <Eduardo_> and then I'll have an IO ()
14:31:11 <Cale> Eduardo_: It happens that it won't, but even if it did, that wouldn't cause "hello" to be printed
14:31:15 <edwardk_> aristid: conceptually, yes
14:31:15 <ski> (Eduardo_ : and even if it did, it wouldn't print anything at that point)
14:31:36 <tensorpudding> GHC seems to update a lot more often than other compiles.
14:31:38 <tensorpudding> compilers*
14:31:51 <Silvah> @src State fmap
14:31:52 <lambdabot> Source not found. :(
14:31:54 <tensorpudding> At least, established ones
14:31:57 <copumpkin> tensorpudding: for great justice
14:32:26 <edwardk_> liftA is a 'free definition' of fmap given pure and <*>. liftM is a free definition of fmap given return and (>>=), ap is a free definition of <*> given return and (>>=), etc.
14:32:43 <edwardk_> @src ap
14:32:44 <lambdabot> ap = liftM2 id
14:32:47 <Eduardo_> Cale, ski : so it *does not* evaluate parameters when the function expects them as IO ?
14:32:52 <edwardk_> @src liftM2
14:32:53 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:32:55 <tensorpudding> It does not fit into my lazy update cycle
14:33:07 <ski> Silvah :  fmap f (State ma) = State (\s0 -> let (a,s1) = ma s0 in (f a,s1))
14:33:23 <jmcarthur> yeah, ghc being kind of a center for research it tends to get features and stuff very quickly
14:33:42 <aavogt> bugs too :)
14:33:47 <jmcarthur> yes, and bugs
14:33:51 <edwardk_> so ap m1 m2 = liftM2 id m1 m2 = do x1 <- m1; x2 <- m2; return (id x1 x2) = do x1 <- m1; x2 <- m2; return (x1 x2)
14:33:53 <systemfault> That's why I picked haskell as my first functional programming language :P
14:33:57 <DigitalKiwi> free bugs with features
14:34:03 <Cale> Eduardo_: It actually never evaluates parameters first
14:34:09 <Silvah> ski: thanks.
14:34:14 <tensorpudding> Though then again.
14:34:15 <Cale> Eduardo_: But *evaluating* an IO action isn't the same thing as *executing* it
14:34:18 <ski> Eduardo_ : haskell never evaluates parameters, unless required by pattern-matcing
14:34:20 <aavogt> ghc-hq has been rather good about fixing those bugs
14:34:25 <tensorpudding> The fact that they're making an LLVM backend is exciting.
14:34:33 <Cale> Eduardo_: Evaluating an IO action would just be determining what to do, not actually doing it.
14:34:46 <edwardk_> which could be written ap mf mx = do f <- mf; liftM f mx
14:34:46 <aristid> edwardk_: yeah i did the same calculations half an hour ago, but i fear that it won't stick as is
14:34:49 <Eduardo_> hmm
14:34:54 <jmcarthur> Veinor: you know if you import Data.ByteString.Char8.Lazy instead then you can use Char instead of Word for the elements of the bytestring, right?
14:35:14 <Cale> Eduardo_: Imagine that maybe IO is internally a bunch of source code for a program that'll eventually get run
14:35:29 <Cale> Eduardo_: then evaluating the IO action just determines the source code of that program
14:35:36 <edwardk_> gotta run
14:35:40 <Cale> It doesn't actually execute it
14:35:41 <jmcarthur> Veinor: it won't speed it up, but it will read better at least :)
14:36:00 <Eduardo_> yes but
14:36:09 <copumpkin> Veinor: did you ever do anything with your nimbers?
14:36:27 <tensorpudding> IO is pure!
14:36:33 <Cale> Eduardo_: so when we *evaluate*  putStrLn "hello", we just get back a value which represents the action of printing "hello" on the screen
14:36:53 <Cale> When we *execute* that action, we actually print "hello" on the screen :)
14:36:56 <Eduardo_> that i understood
14:36:58 <tensorpudding> also C is functional, war is peace, etc.
14:36:58 <Cale> okay :)
14:37:06 <Eduardo_> and the action is our parameter
14:37:07 <roconnor> @bab nl en samenvatting
14:37:08 <Cale> yeah
14:37:08 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
14:37:12 <ivanm> @tell McManiaC cool! Axman6 and I have been discussing using gloss to make plots (or just opengl proper)!
14:37:12 <lambdabot> Consider it noted.
14:37:25 <McManiaC> ivanm: hehe
14:37:26 <lambdabot> McManiaC: You have 1 new message. '/msg lambdabot @messages' to read it.
14:37:54 <ivanm> @tell Axman6 by McManiaC: http://n-sch.de/plot.png
14:37:54 <lambdabot> Consider it noted.
14:38:05 <Eduardo_> thank, Cale
14:38:07 <Eduardo_> thanks*
14:38:26 <McManiaC> ivanm: very basic: http://npaste.de/Tn/
14:38:56 <Cale> So, we might evaluate  forever (putStrLn "hello")  by hand, in a not-totally-systematic way, and get something like:   forever (putStrLn "hello") --> do putStrLn "hello"; forever (putStrLn "hello") --> do putStrLn "hello"; (do putStrLn "hello"; forever (putStrLn "hello")) --> ...
14:39:12 <ivanm> McManiaC: Axman6 wanted to use gloss for plots because gtk2hs is a PITA to get working on OSX for criterion
14:39:20 <Cale> and of course, if we continued like that, we'd never finish
14:39:42 <lowasser> Can I put pragmas in TH code?
14:39:43 <Cale> But in practice, the processes of evaluation and execution are interleaved so that it's not a problem
14:40:01 <ddarius> ivan: A witch!
14:40:20 <Cale> The RTS evaluates things just enough to decide what to execute next, and then executes it, and then goes back to evaluating :)
14:40:37 <aavogt> lowasser: in the generated code?
14:40:40 <lowasser> Yes.
14:40:45 <ski> roconnor : i'd guess "summary" or maybe "abbreviation"
14:40:45 <aavogt> only a few pragmas are supported
14:40:50 <lowasser> {-# RULES #-} ?
14:40:56 <Eduardo_> and how do I return a value as an IO ?
14:40:59 <aavogt> I don't think so
14:41:04 <lowasser> balls
14:41:04 <aristid> as always, the list and maybe monads help me understand \o/
14:41:10 <copumpkin> > return 5 :: IO Int
14:41:12 <lambdabot>   <IO Int>
14:41:18 <aavogt> though {-# INLINE #-} and maybe a couple others are in there
14:41:20 <Cale> Eduardo_: There's a function   return :: a -> IO a
14:41:22 <lowasser> I need TH to tell whether or not I can get away with certain rewrite rules
14:41:26 <roconnor> ski: summary
14:41:37 <Cale> Eduardo_: Which takes a value, and produces the action which "does nothing" and returns that value.
14:41:42 <lowasser> and the rules don't seem to fire if they're just triggered by a type class instance
14:41:49 <lowasser> or perhaps I'm doing that wrong
14:41:55 <roconnor> ski: I'm going to put my thesis summary on my web page and use language negotation to select dutch or english.
14:42:03 <roconnor> ski: and no one will ever see the dutch page...
14:42:19 <Cale> Eduardo_: and of course, you can use that at the end of a do-block to decide what the final result of an action will be (the result of a do-block is always the result of the last action in it)
14:42:30 <ski> roconnor : a-ok :)
14:42:39 <lowasser> how do I write a rewrite rule for (foo x) that fires if x is an instance of a given type class?
14:42:56 <lowasser> I tried forall (x :: Foo a => a), but it doesn't seem to fire
14:43:09 <aristid> @pl fmap x y = ap (return x) y
14:43:09 <lambdabot> fmap = fmap
14:43:18 <Eduardo_> Cale: I see
14:43:19 <aristid> cool.
14:43:33 <Eduardo_> almost getting it
14:43:37 <aristid> pl can deal with ap / return combinations
14:43:39 <Eduardo_> just need to get the test working
14:44:00 <Cale> Eduardo_: as another fun example like forever, we also have something called sequence
14:44:23 <k23z__> if I have a map and I want to return nothin from the functor how do I do that ?
14:44:24 <Cale> sequence takes a list of IO actions, and produces an IO action which when executed, will execute each of the actions from the list, and return a list of their results
14:44:29 <Cale> So its type is
14:44:36 <Cale> sequence :: [IO a] -> IO [a]
14:44:36 <k23z__> ah yes filter
14:44:37 <k23z__> sorry
14:44:41 <k23z__> I should use filter
14:44:48 <aristid> @src *>
14:44:48 <lambdabot> (*>) = liftA2 (const id)
14:44:53 <Cale> and we write it just using recursion:
14:44:54 <aristid> @src liftA
14:44:54 <lambdabot> liftA f a = pure f <*> a
14:44:55 <Eduardo_> Cale: nice!
14:44:58 <Cale> sequence [] = return []
14:45:13 <Cale> When the list is empty, we produce the action which just returns an empty list
14:45:25 <Cale> sequence (x:xs) = do v <- x; ...
14:45:26 <aristid> so liftA is like fmap for Applicative?
14:45:35 <jmcarthur> the actual definition isn't explicitly recursion is it?
14:45:41 <Cale> When the list is nonempty, we want to run the first action, getting its result v
14:45:56 <Cale> and then we want to run the rest... and thankfully we have a function to do that, called sequence :)
14:46:04 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
14:46:17 <Cale> and then we just need to return the list of all the results:
14:46:21 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:46:42 <Eduardo_> at least this part of lists/recursion i got fine
14:47:46 <Cale> So we can now write things like:
14:47:54 <Eduardo_> Cale: now I understand why people say Haskell doesn't need macros
14:47:55 <Cale> sequence [print n | n <- [1..10]]
14:48:31 <Cale> Yeah, things like this make it easier to get by without them for most of the time
14:48:33 <ski> aristid : yes
14:48:49 <aristid> @src fmap
14:48:49 <ski> (or like `liftM' for `Monad', if you prefer)
14:48:49 <Eduardo_> that will call sequence [print 1, print 2, print 3, ...], right?
14:48:49 <lambdabot> Source not found. Take a stress pill and think things over.
14:48:55 <Cale> yeah
14:49:00 <ski> @src [] fmap
14:49:00 <lambdabot> fmap = map
14:49:09 <ski> @src Maybe fmap
14:49:10 <lambdabot> fmap _ Nothing       = Nothing
14:49:10 <lambdabot> fmap f (Just a)      = Just (f a)
14:49:17 <aristid> ski: cool feature
14:49:38 <k23z__> if I write a function
14:49:38 <aristid> @src liftM
14:49:38 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:49:45 <k23z__> and I need to write a    let varname = ...
14:49:46 <k23z__> in it
14:49:47 <Cale> Eduardo_: So sequence acts as a sort of primordial loop: if we can decide what to do on each iteration, then sequence will glue our list of actions together into a complete loop.
14:49:52 <k23z__> how can I do that ?
14:49:59 <pikhq> Eduardo_: Haskell does have macros, though. Not as good as Lisp's, but they certainly do exist.
14:50:01 <k23z__> because it wouldn't be a function any more
14:50:08 <Cale> Eduardo_: using sequence, we can write a for-each loop:
14:50:10 <vmixey> hm haskell odesn't have macros
14:50:13 <ski> (Eduardo_ : Haskell actually "needs" macros .. but not as much as strict languages)
14:50:19 <pikhq> vmixey: Template Haskell
14:50:26 <Cale> forM xs f = sequence (map f xs)
14:50:29 <pikhq> k23z__: foo bar = let baz = qux in ...
14:50:46 <vmixey> Template Haskell is not standard
14:50:47 <k23z__> pikhq, what's the "in" ?
14:50:48 <Cale> and with that, we could write:
14:51:02 <ski> k23z__ : sure it would be a function, still
14:51:11 <ski> > let x = 2 in x + x
14:51:11 <lambdabot>   4
14:51:12 <Cale> forM [1..10] $ \n -> do print n; print (n^2)
14:51:13 <k23z__> ski, can you give an example please ?
14:51:25 <ski> k23z__ : `let x = 2 in x + x' is an expression
14:51:43 <aristid> @src sequence
14:51:43 <lambdabot> sequence []     = return []
14:51:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:51:43 <lambdabot> --OR
14:51:43 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:51:47 <ski> k23z__ : the `x = 2' is a local definition of `x' that is only visible in the expression after the `in' (here `x + x')
14:51:52 <k23z__> ah yes it works
14:51:54 <k23z__> ski,  thanks
14:51:58 <k23z__> pikhq, thx
14:52:05 <aristid> @src sequence_
14:52:05 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:52:34 <Eduardo_> Cale: that's wonderful
14:52:42 <ski> k23z__ : btw, note that instead of writing `f x = let y = x*x in ...' you can write `f x = ... where y = x*x' (where the `where ...' is usually put on subsequent lines, for readability)
14:52:59 <aristid> forever = sequence_ . repeat?
14:53:08 <Cale> aristid: yep, that works
14:53:37 <aristid> uh different type
14:53:38 <copumpkin> different type though
14:53:40 <sinelaw> aloha
14:53:43 <sinelaw> !
14:53:47 <copumpkin> also, can you even sequence infinite things?
14:53:52 <copumpkin> for IO
14:54:00 <aristid> :t fix (ap (>>))
14:54:01 <Cale> Eduardo_: It's good to know that there are versions of sequence and forM and mapM and a bunch of other functions which have underscores at the end of their names -- the convention is that these functions discard the results rather than collecting them into a list
14:54:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:54:16 <Cale> Eduardo_: Sometimes it's important to conserve memory, for example if the loop runs forever.
14:54:38 <aristid> forever f = (sequence_ . repeat $ f) >> undefined
14:54:44 <FunctorSalad> ddarius: any reason ParsecT shouldn't be a (higher) functor in the monad? tmap :: (forall a. m a -> n a) -> ParsecT s u m b -> ParsecT s u n b
14:54:50 <aristid> @pl forever f = (sequence_ . repeat $ f) >> undefined
14:54:51 <lambdabot> forever = (>> undefined) . sequence_ . repeat
14:55:19 <vmixey> What's the best haskell program?
14:55:25 <Eduardo_> Cale: right but, how they discard the values if there must be always a return value?
14:55:27 <copumpkin> vmixey: mine
14:55:29 <FunctorSalad> ddarius: there seems to be a choice here though (inner "m" first or outer first...) maybe it doesn't matter due to parametricity, haven't thought about it
14:55:30 <Eduardo_> Cale: using the "Maybe" ?
14:55:30 <vmixey> show it
14:55:41 <copumpkin> vmixey: nah, I'm self-conscious
14:55:54 <Cale> Eduardo_: sequence_ [] = return (); sequence_ (x:xs) = do x; sequence xs
14:55:55 <FunctorSalad> m (Consumed (m (Reply s u a))) <-- these are what I mean by inner/outer
14:55:56 <Cale> er
14:55:59 <Cale> Eduardo_: sequence_ [] = return (); sequence_ (x:xs) = do x; sequence_ xs
14:56:03 <sinelaw> conal: hey :) i'm presenting my project in a few days
14:56:03 <Cale> (typo :)
14:56:16 <Cale> Eduardo_: We just don't bind the results to variables at all
14:56:25 <Cale> and produce an empty tuple in place of a list
14:56:31 <sinelaw> how many slides is it reasonable to push in 8 minutes?
14:56:40 <copumpkin> sinelaw: about 4 to 6
14:56:47 <sinelaw> oh no
14:56:53 <sinelaw> i have 12 now
14:56:54 <copumpkin> sinelaw: unless you're a good presenter and like lessig's style
14:56:59 <FunctorSalad> a fraction of one, depending on contents ;)
14:57:00 <copumpkin> sinelaw: practice it! time yourself :P
14:57:02 <pikhq> sinelaw: Does your audience run on a stack-based architecture?
14:57:06 <Eduardo_> because it is recursive it will only return a []
14:57:14 <copumpkin> sinelaw: don't just guess
14:57:15 <sinelaw> pikhq: heh
14:57:26 <ski> Eduardo_ : s/[]/()/
14:57:29 <sinelaw> copumpkin yeah i know....no test audience though
14:57:33 <pikhq> If so, then as many as won't produce a stack overflow. :)
14:57:38 <Eduardo_> oh yeah
14:57:39 <copumpkin> sinelaw: you can practice by yourself, too
14:57:50 <sinelaw> copumpkin, yeah, that's my intention
14:57:53 <Eduardo_> return () not [] ; mistaken
14:58:35 <sinelaw> i have 8 minutes to introduce electrical engineers to functional programming and frp
14:58:46 <FunctorSalad> :D \o/
14:58:49 <copumpkin> don't try to cram too much in
14:58:51 <copumpkin> you'll just turn them off
14:58:53 <aristid> ghci seems to "default" to the IO monad
14:59:07 <aristid> return () just does nothing, for example
14:59:18 <FunctorSalad> aristid: well the toplevel *is* the body of an IO-do-block more or less
14:59:20 <pikhq> aristid: GHCi can be *kinda* considered a REPL in do notation.
14:59:43 <FunctorSalad> you can enter "x <- foo" with foo IO
15:00:09 <FunctorSalad> (and only then, AFAIK... so it's not just defaulting)
15:00:17 <sinelaw> what if i talk really fast? :)
15:01:04 <FunctorSalad> btw did you know the :cmd command? only noticed a few days ago
15:01:53 <k23z__> Botje, my let max = ..
15:01:55 <FunctorSalad> (string-level metaprogramming ;))
15:01:55 <k23z__> lol
15:02:16 <k23z__> Botje, don't you feel like Perl is a complete crap when you look at what Haskell can do ?
15:02:29 <aristid> FunctorSalad: :cmd is a kind-a eval?
15:02:42 <k23z__> I mean I don't think there is another functional language quite like Haskell (maybe Pure or Clean)
15:02:47 <FunctorSalad> aristid: yes, with ghci-commands as language
15:02:48 <k23z__> anybody here writes Clean ?
15:02:54 <FunctorSalad> (the other :foo commands)
15:03:09 <FunctorSalad> takes a haskell expression or type IO String
15:03:12 <k23z__> Clean , the programming language developed at Nijmegen in The Netherlands , anyone ?
15:03:13 <aristid> FunctorSalad: infinite recursion!
15:03:56 <ivanm> k23z__: well, this isn't #clean... :P
15:04:00 <Eduardo_> let go :: IO String; go = do init "not" :: IO String
15:04:15 <ivanm> k23z__: AFAICT, clean has the disadvantage of requiring you to pay for it to really be able to use it
15:04:19 <ivanm> and so hardly anyone does
15:04:21 <FunctorSalad> aristid: I don't know any way to programmatically obtain the output of a ghci command though... not that you'd really want to; at some point you probably want to just modify ghci proper
15:04:26 <k23z__> ivanm, well #clean doesn't exist ... :P
15:04:38 <k23z__> ivanm, that's not true
15:04:47 <FunctorSalad> (for a complex enough extension...)
15:04:54 <aristid> FunctorSalad: can you make me an infinite :cmd?
15:05:07 <FunctorSalad> but at least I have a color prompt now iff tput colors is >= 8 :D
15:05:15 <k23z__> ivanm, http://clean.cs.ru.nl/Download/main/main.htm
15:05:22 <k23z__> ivanm, you don't have to pay
15:05:29 <aristid> @hoogle tput
15:05:29 <lambdabot> Network.CGI.Protocol CGIOutput :: ByteString -> CGIResult
15:05:29 <lambdabot> Network.CGI output :: MonadCGI m => String -> m CGIResult
15:05:29 <lambdabot> Network.CGI outputError :: (MonadCGI m, MonadIO m) => Int -> String -> [String] -> m CGIResult
15:05:36 <FunctorSalad> aristid: shell command
15:05:40 <k23z__> ivanm, it even has sources available
15:05:50 <k23z__> ivanm, and a couple of books on the net about it
15:05:55 <FunctorSalad> aristid: you can do rawSystem inside the IO String...
15:06:03 <k23z__> I understand from what I've read that Clean was written before Haskell
15:06:10 <k23z__> but something happened to it, I can't understand what
15:06:20 <k23z__> is this true ?
15:06:28 <ivanm> k23z__: I use linux; unless its changed recently the linux version was missing stuff compared to the windows version and the commercial license
15:06:42 <k23z__> ivanm, what stuff
15:06:49 <ivanm> k23z__: haskell was written as a standardised language, whereas clean seems to be used only by the one uni
15:07:03 <k23z__> ivanm, in any case I'm not defending it, I just want to know how it is in compariso to Haskell
15:07:13 <ski> ivanm : it has changed the license, i think
15:07:35 <ivanm> ski: nah, license looks the same; it was more a practical consideration IIRC
15:07:36 <FunctorSalad> aristid: :cmd (return ("cmd: "++someQuine))
15:07:37 <FunctorSalad> ?
15:08:00 <ivanm> OK, the "Clean_language" on wikipedia isn't about this :p
15:08:05 <FunctorSalad> I don't see an elegant way to quine there though
15:08:27 <ski> (well, s/changed/added/)
15:08:35 <ski> ivanm : it is available under LGPL
15:08:37 <aristid> > fix show
15:08:38 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
15:08:43 <copumpkin> > fix fail
15:08:44 <lambdabot>   ""
15:08:44 <ivanm> k23z__: what I'm talking about: http://en.wikipedia.org/wiki/Clean_%28programming_language%29#Platforms
15:08:47 <FunctorSalad> fix won't do because you can't show functions ;)
15:08:51 <aristid> :t fail
15:08:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
15:08:56 <ivanm> > fix undefined
15:08:56 <vmixey> > fix fix
15:08:57 <lambdabot>   *Exception: Prelude.undefined
15:08:58 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
15:09:05 <aristid> > fix fail :: IO ()
15:09:06 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO ()'
15:09:06 <lambdabot>         against inferred ty...
15:09:09 <ski> > fix error
15:09:10 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:09:17 <ivanm> aristid: the type is wrong
15:09:24 <FunctorSalad> the concise lisp one relies on that, I think
15:09:24 <ivanm> @type fix
15:09:26 <lambdabot> forall a. (a -> a) -> a
15:09:34 <aristid> :t fix fail
15:09:35 <lambdabot> String
15:09:46 <FunctorSalad> (that the resulting lambda expression is a valid output too)
15:09:47 <aristid> oh, fix fail uses the list monad!
15:09:49 <aristid> :t fix error
15:09:50 <lambdabot> [Char]
15:09:51 <ivanm> k23z__: this appears relevant: http://old.nabble.com/Why-can%27t-Haskell-be-faster--td13505750.html
15:09:54 <copumpkin> > 5 (-5)
15:09:55 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:09:55 <lambdabot>    `GHC.Num.Num a'
15:09:55 <lambdabot>      aris...
15:10:37 <FunctorSalad> so I guess you'll need textual substitution with escaping hell ;)
15:10:39 <ivanm> heh, the reasons why Clean > Haskell all seem to be based on the shootout and people's blog posts :P http://wiki.clean.cs.ru.nl/FAQ
15:11:44 <k23z__> so the Clean compiler produces code much faster than GHC
15:12:00 <copumpkin> k23z__: no
15:12:01 <k23z__> at least that's what they write in that mailing list
15:12:05 <k23z__> copumpkin, no ?
15:12:06 <copumpkin> it's from 2007
15:12:13 <k23z__> ah so the situation has changed ?
15:12:15 <copumpkin> ghc has advanced enormously since then
15:12:21 <copumpkin> and clean has more or less stagnated from what I've heard
15:12:28 <tensorpudding> Clean's website is oooold.
15:12:50 <copumpkin> k23z__: don't dwell on dumb benchmarks :P even the front page of the shootout says they're dumb
15:12:52 <k23z__> tensorpudding, so what, they have very smart guys over there IMHO
15:13:04 <copumpkin> http://snapplr.com/vf5g
15:13:05 <zygoloid> in TH, how can i get a QType for a class?
15:13:08 <tensorpudding> I'm sure there are tons of smart guys, working on projects...
15:13:15 <zygoloid> [t|ClassName|] gives an error :(
15:13:17 <copumpkin> k23z__: there are smart people everywhere :P
15:13:17 <aristid> k23z__: haskell has very smart people too
15:13:45 <copumpkin> smart people are a dime a dozen!!
15:13:49 <ivanm> arguably, haskell has more smart people due to it having a larger community
15:13:55 <tensorpudding> There's tons more smart people working on more popular languages than Haskell.
15:14:02 <DigitalKiwi> quality vs quantity!
15:14:09 * ski idly wonders what is being discussed
15:14:10 <k23z__> copumpkin  aristid   tensorpudding  http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=clean&lang2=ghc
15:14:15 <aristid> i'll take a kilo of them apples please
15:14:20 <ivanm> copumpkin: I'd give you a dime to help you buy a dozen smart people to help you sort out your personal problems, except I don't have any USA currency floating around
15:14:44 <ivanm> k23z__: part of that is people caring enough to sit down and optimise code for the shootout
15:14:52 <tensorpudding> Clean has the downside of being less actively developed.
15:14:58 <tensorpudding> Also, last I checked it was Windows-only.
15:15:12 <ivanm> it doesn't help that with GHC being a moving target, something that's good for one version mightn't be as good for another
15:15:14 <copumpkin> ivanm: :P
15:15:23 <ivanm> tensorpudding: not quite, but the windows version has more features
15:15:46 <k23z__> ivanm, right, I'm sure a lot of Perl hackers tried their best, the problem is Perl is just too slow for any benchmark ... it's superior only to PHP
15:16:04 <DigitalKiwi> ...
15:16:06 <aristid> perl is a beautiful functional language
15:16:06 <ivanm> ski: good question!
15:16:07 <copumpkin> "perl" isn't slow
15:16:12 * copumpkin summons kmc 
15:16:19 <ivanm> preflex: seen kmc
15:16:19 <preflex>  kmc was last seen on #haskell 11 hours, 58 minutes and 49 seconds ago, saying: @nixon
15:16:27 <aristid> @nixon
15:16:27 <lambdabot> I reject the cynical view that politics is a dirty business.
15:16:31 <copumpkin> PHP isn't slow
15:16:33 <copumpkin> C isn't fast
15:16:38 <aristid> @. elite nixon
15:16:38 <lambdabot> Do u kn0W \/\/HA+ |-|app3NED T0 +HE r0m4nS? 7|-|E 1Ast six Rom4N E/\/\PEr0rS weRe phAGs. . . . yOU kN0W wha+ |-|aPP3NEd T0 +HE P0pE5? I7'5 all rI9|-|T +HAt p0P3z0rz WEr3 LAyinG th3 nUn5.
15:16:42 <EvanR-work> gah. when using transformers over IO i keep having to do liftIO
15:16:45 <ivanm> so, nixon wants the positive view that politics is a dirty business? :p
15:16:46 <k23z__> copumpkin, why did you want to summon kmc ?
15:16:49 <k23z__> copumpkin,  ?
15:16:53 <EvanR-work> ReaderT would be nice otherwise
15:16:58 <copumpkin> k23z__: because he'll bite your head off
15:17:04 <tensorpudding> Does Clean have a community?
15:17:06 <copumpkin> for talking about language speeds
15:17:07 <DigitalKiwi> lulzy
15:17:20 <ivanm> tensorpudding: AFAIK, no
15:17:24 <systemfault> I'm comparing implementations, not languages.
15:17:29 <k23z__> copumpkin, because he writes Perl right ? I write Perl too , but I don't care about it as much as kmc does.. if there's a better tool out there I will use it
15:17:36 <aristid> nom nom k23z__'s head
15:17:37 <copumpkin> k23z__: no, he doesn't write perl
15:17:45 <tensorpudding> Haskell has a community that is growing but still tiny.
15:17:49 <copumpkin> it's not personal interest, it's principle
15:17:59 <k23z__> copumpkin, and what principle is that ?
15:18:03 <systemfault> I wouldn't want #Haskell to become like ##C :(
15:18:18 <k23z__> ah nevermind take this to #haskell-blah
15:18:31 <DigitalKiwi> i dun wanna join another channel
15:18:32 <copumpkin> k23z__: it's silly to be comparing language speeds. It's also silly to be dwelling on speed when most of the time people don't care. And citing flawed benchmarks that claim to be flawed doesn't help one's case
15:18:34 <DigitalKiwi> so stay here!
15:18:42 <ivanm> tensorpudding: well, it depends; I would argue that in terms of people who actually care about their language out community is probably competitive in size to other languages (probably not as much as python or perl, but still)
15:18:54 <ivanm> e.g. who actually cares about Java? :p
15:19:02 <copumpkin> k23z__: but anyway, "haskell" is "fast"
15:19:10 <ivanm> copumpkin: s/claim/admit/
15:19:38 <DigitalKiwi> copumpkin: but "clean" is "faster" ;D
15:19:44 <aavogt> ivanm: the people who are paid to care?
15:19:44 <copumpkin> DigitalKiwi: damn, I concede
15:19:56 * DigitalKiwi wins the internets
15:20:08 <ivanm> aavogt: who then go home and write cool libraries and discuss it in their spare time?
15:20:10 <aristid> DigitalKiwi: as the price, you can eat k23z__'s head.
15:20:17 <DigitalKiwi> D:
15:20:25 <danderson> put another way: the Haskell language doesn't have major impediments that would prevent an appropriately sophisticated compiler implementation from making it run fast
15:20:27 * ivanm passes DigitalKiwi the salt
15:20:38 <danderson> proof by existence: ghc is one such implementation :)
15:20:38 <DigitalKiwi> nah man i have medusa in my closet
15:20:44 <k23z__> in any case I like Haskell a lot
15:20:46 <Gracenotes> @type \f x -> maybe (return Nothing) (fmap Just f) x
15:20:47 <lambdabot> forall a a1. (a1 -> Maybe a) -> Maybe a1 -> Maybe (Maybe a)
15:20:51 * DigitalKiwi gets ivanm to look at medusa
15:20:53 <ivanm> danderson: yeah, I'm quite interested in seeing how JHC is going to turn out
15:20:56 <Gracenotes> ... hm.
15:21:02 <copumpkin> k23z__: if you want to get excited about what's on the todo list: http://community.haskell.org/~ndm/downloads/slides-supercompilation_for_haskell-03_mar_2009.pdf :)
15:21:03 <DigitalKiwi> who then turns into a pillar of salt! ;D
15:21:05 <Gracenotes> @type \f x -> maybe (return Nothing) (fmap Just . f) x
15:21:06 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => (a1 -> m a) -> Maybe a1 -> m (Maybe a)
15:21:07 <ski> Clean is interesting because of its uniqueness typing
15:21:10 <ivanm> DigitalKiwi: that's not medusa...
15:21:20 <systemfault> Haskell can be really really fast even be faster than C in some cases.
15:21:26 <Gracenotes> that's more like it. now if the nice way of saying that >_<
15:21:33 <Gracenotes> *is there a
15:21:34 <ivanm> that was Lot's wife...
15:21:36 <k23z__> ski, let's go to -blah please I'm interested in Clean there
15:21:47 <DigitalKiwi> oh was it stone?
15:21:52 <ivanm> DigitalKiwi: yup
15:21:53 <danderson> ivanm: interesting, didn't know about that. Does the j stand for JVM, or the letter of the roman alphabet?
15:21:55 <DigitalKiwi> :(
15:22:05 <dcoutts> Gracenotes: remind me again when your exams are done
15:22:08 <ivanm> danderson: John Meacham is the dev...
15:22:09 <ivanm> ;-)
15:22:16 <danderson> ah, indeed :-)
15:22:31 <Eduardo_> Thanks everyone for all help.
15:22:37 <Eduardo_> got to go
15:22:51 <dcoutts> Gracenotes: erm I mean, remind me again, when are your exams done? :-)
15:23:01 <mreh> wnat
15:23:05 <mreh> oops
15:23:19 <Gracenotes> dcoutts: they are done! Right now I'm working on a Happstack imageboard (262 lines so far..) to get up to speed with Happstack and Text.XHtml
15:23:25 <mreh> is := a type operator?
15:23:30 <danderson> ivanm: his blog has C, haskell and electronics in it. Sounds like an awesome person. jhc should turn out okay :P
15:23:33 <vmixey> it can be
15:23:34 <Gracenotes> and having fun, etc.
15:23:36 <dcoutts> Gracenotes: woo! happy with how they went?
15:23:52 <danderson> (this summary evaluation of awesomeness brought to you by my personal interests)
15:24:03 <dcoutts> Gracenotes: right, letting off the exam pressure, v. important
15:24:12 <ivanm> danderson: heh
15:24:17 <Gracenotes> think so. all went well, except for OS but I did well otherwise inthe class so should be fine
15:24:52 <zygoloid> ugh, defining instances in TH is /horrible/
15:25:15 <aavogt> mreh:  data a := b = a := b -- only one of these := is a type operator
15:27:11 <aristid> do type operators have precedence?
15:27:14 <Gracenotes> dcoutts: it seems both Happstack and XHtml are relatively painless once you learn their idioms. I haven't figured out how to make UTF8 work nicely with macid, which seems to be a daunting problem so I'm not dealing with it atm :)
15:28:06 <ski> aristid : yes, the same precedence as normal ones
15:28:20 <ski> (btw, type operators is an extension)
15:29:10 <dcoutts> Gracenotes: I didn't realise it was a problem
15:29:44 <Gracenotes> getting some weirdness, is all.. lemme try serializing bytestrings instead of strings
15:30:18 <dcoutts> Gracenotes: hmm, it uses Binary underneath and that uses UTF8 for [Char]
15:32:46 <Gracenotes> well, I am passing it through a MessageWrap function...
15:35:03 <Gracenotes> dcoutts: ah. problem with GETs (formDecode), not with POSTs (bodyInput)
15:35:17 <dcoutts> Gracenotes: clearly you're learning more about happs than me :-)
15:35:25 * dcoutts has never encountered MessageWrap
15:35:59 <Gracenotes> seems to be entirely for forms.
15:36:22 <Gracenotes> either multipart (file-uploading) ones, or plain-old-encoded-data ones..
15:37:02 <dcoutts> ok
15:37:16 <Gracenotes> you can use SimpleHTTP.look and not have to deal with it at all..
15:42:14 <ben_m> Just learned that the list instance of monad is used for nondeterministic stuff
15:42:17 <ben_m> That is pretty awesome :D
15:42:33 <Axman6> ?
15:42:33 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
15:42:53 <Axman6> @messages
15:42:53 <lambdabot> ivanm said 1h 4m 59s ago: by McManiaC: http://n-sch.de/plot.png
15:42:56 <zygoloid> huh. TH's automatic lifting isn't referentially transparent. :o
15:43:23 <McManiaC> hehe
15:44:00 <Axman6> nice work McManiaC :)
15:44:12 <zygoloid> "let n = 1 + 1 in [|n|]" is different from "[|1 + 1|]"
15:44:20 <sinelaw> preflex, seen Peaker
15:44:20 <preflex>  Peaker was last seen on ##C 2 days, 17 hours, 4 minutes and 42 seconds ago, saying: C++ really screwed things up w.r.t struct/union namespaces
15:44:22 <sinelaw> preflex, seen PeakerWork
15:44:22 <preflex>  PeakerWork was last seen on #haskell 37 days, 10 hours, 14 minutes and 54 seconds ago, saying: Jafet: (.) is associative and ($) isn't
15:44:30 <k23z__> hpaste is down
15:44:33 <k23z__> a replacement perhaps ?
15:44:36 <McManiaC> Axman6: its very basic, maybe spend half an hour: http://npaste.de/Tn/
15:44:41 <sinelaw> k23z__ moonpatio
15:45:17 <McManiaC> it also has some wrong - here and there
15:45:17 <McManiaC> :D
15:45:41 <McManiaC> plot (\x -> sin x) (0, 2*pi) -- will look weird :>
15:45:58 <k23z__> so this be what I've been working on for the last 2 hours with the guys in this channel http://npaste.de/Tq/
15:46:08 <McManiaC> k23z__: <3
15:46:12 <k23z__> McManiaC, <3
15:46:22 <McManiaC> npaste is mine \o/
15:46:29 <McManiaC> :D
15:47:09 <ben_m> I wish Emacs would treat stuff between :{ and :} as one history item
15:47:20 <aavogt> isn't that a ghci thing?
15:47:31 <aavogt> ben_m: there's a ghc feature request on that
15:47:48 <ben_m> :{ and :} are ghci features, yeah
15:47:56 <McManiaC> what do they do? :>
15:48:02 <aavogt> multiline input
15:48:08 <ben_m> yes
15:48:33 <Eduardo_> > :t System.Directory.getDirectoryContents
15:48:34 <lambdabot>   <no location info>: parse error on input `:'
15:48:39 <Eduardo_> >:t System.Directory.getDirectoryContents
15:48:40 <ben_m> I just wish that when I press alt-p that all the lines get recalled :)
15:48:51 <hpc> :t System.Directory.getDirectoryContents
15:48:51 <aavogt> http://hackage.haskell.org/trac/ghc/ticket/3984
15:48:52 <lambdabot> FilePath -> IO [FilePath]
15:49:03 <aavogt> same here, ben_m
15:49:03 <Eduardo_> how do I iterate over this?
15:49:04 <hpc>  :t isn't haskell
15:49:23 <Eduardo_> hpc: thanks, forget how to use it
15:49:27 <hpc> @src FilePath
15:49:28 <lambdabot> type FilePath = String
15:49:48 <hpc> so it is actually String -> IO [String], with some sugar attached
15:50:49 <Eduardo_> hpc: can you give me an example? i'm lost
15:50:51 <k23z__> McManiaC, rly ?
15:50:59 <McManiaC> yup
15:51:14 * zygoloid learned today that GHC can only count up to six. :)
15:51:29 <k23z__> zygoloid, xampl ?
15:51:38 <hpc> you have a directory "/dir", so in main you can do
15:51:47 <ski> k23z__ : at line 64.5(?), `map (words) (splitOn "." f)' can be written as `map words (splitOn "." f)' .. similarly with `(Sentence)' on next line
15:52:07 <hpc> main = do files <- getDirectoryContents "/dir"; map putStrLn files
15:52:10 <aavogt>  words `map` splitOn "." f
15:52:25 <k23z__> ski, ah thanks :) <3
15:52:28 <hpc> files is a [String] containing a list of file names in the directory
15:52:29 <zygoloid> k23z__: "newtype Foo = C1 | C2 | C3" gives the error "A newtype must have exactly one constructor, but Foo has three"
15:52:40 <hpc> and you map putStrLn over it, which prints every item
15:52:47 <zygoloid> k23z__: once you get above six constructors it starts using numbers rather than words :)
15:53:08 <ski> k23z__ : at line 68.5,  let m = maximum'(sentences)  can be simpler written as  let m = maximum' sentences
15:53:35 <ski> k23z__ : at line 81, `(\x -> length x)' can be replaced with `length'
15:53:58 <aristid> :t maximum'
15:53:59 <lambdabot> Not in scope: `maximum''
15:54:06 <aristid> :t maximum
15:54:07 <lambdabot> forall a. (Ord a) => [a] -> a
15:54:22 <aristid> ski: what's maximum'?
15:54:32 <aristid> @hoogle maximum'
15:54:33 <lambdabot> No results found
15:54:35 <ski> aristid : defined at the end of the paste
15:55:19 <ski> k23z__ : at line 103.3, `slength a = (length.getWords) a' can be simplified to `slength = length . getWords'
15:55:42 <Eduardo_> thanks, hpc
15:55:46 <aavogt> monomorphism restriction?
15:55:59 * ski wonders what's with the fractional line numbers ..
15:56:38 <hpc> line.column?
15:56:43 <aavogt> oh there's a type signature there
15:57:17 <aavogt> @type comparing
15:57:18 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
15:57:41 <EvanR> alright. lets combine a Reader with a Rand...
15:57:51 <EvanR> whats the easiest way
15:58:00 <aavogt> an yes, why is maximum' defined, k23z__?
15:58:01 <vmixey> :k ReaderT
15:58:02 <lambdabot> * -> (* -> *) -> * -> *
15:58:03 <ski> hpc : no, the line numbers don't line up exactly with the code lines, when i display the page in $BROWSER
15:58:03 <vmixey> :k Rand
15:58:04 <aristid> k23z__: why do you reimplement maximum?
15:58:05 <lambdabot> * -> * -> *
15:58:20 <EvanR> how does this help...
15:58:29 <vmixey> :k forall a k x y. ReaderT a (Rand k) x y
15:58:30 <lambdabot>     Kind error: `ReaderT' is applied to too many type arguments
15:58:30 <lambdabot>     In the type `ReaderT a (Rand k) x y'
15:58:31 <k23z__> aristid, for great good
15:58:41 <vmixey> :k forall a k x. ReaderT a (Rand k) x
15:58:42 <lambdabot> *
15:58:47 <vmixey> :k RandT
15:58:48 <lambdabot> * -> (* -> *) -> * -> *
15:58:52 <aristid> k23z__: doing things for great good, that of course is good!
15:58:59 <k23z__> aristid, :)
15:59:08 <aavogt> it's not though
15:59:09 <ski> @unmtl RandT () Maybe ()
15:59:09 <lambdabot> () -> Maybe ((), ())
15:59:13 <aavogt> @src maximum
15:59:14 <lambdabot> maximum [] = undefined
15:59:14 <lambdabot> maximum xs = foldl1 max xs
15:59:20 <ski> @unmtl Fix Maybe
15:59:21 <lambdabot> Fix Maybe
15:59:25 <aristid> ski: what does @unmtl do?
15:59:30 <aavogt> you use a right fold though
15:59:51 <ski> @unmtl StateT String (ReaderT Bool IO) Int
15:59:51 <lambdabot> String -> Bool -> IO (Int, String)
15:59:56 <hpc> it desugars monad transformers, i think
16:00:05 <ski> aristid : unwraps some monad transformers
16:00:13 <ski> @help unmtl
16:00:13 <lambdabot> unroll mtl monads
16:00:15 <aavogt> it doesn't make sense to use a right fold for max, unless    max maxBound undefined = maxBound
16:00:26 <aavogt> > max maxBound undefined
16:00:27 <lambdabot>   *Exception: Prelude.undefined
16:00:30 <aavogt> > max maxBound undefined :: Int
16:00:31 <lambdabot>   *Exception: Prelude.undefined
16:00:42 <aristid> @unmtl RandT () IO ()
16:00:42 <lambdabot> () -> IO ((), ())
16:00:58 <aristid> @unmtl IOT () Maybe ()
16:00:59 <lambdabot> IOT () Maybe ()
16:01:10 <aristid> @unmtl IoT () Maybe ()
16:01:10 <lambdabot> IoT () Maybe ()
16:01:11 <EvanR> @unmtl ReaderT () (Rand ()) ()
16:01:11 <ski> @unmtl RandT g Maybe a
16:01:11 <lambdabot> g -> Maybe (a, g)
16:01:12 <lambdabot> () -> () -> ((), ())
16:01:13 <aristid> hmm
16:01:19 <aavogt> aristid: there is no IOT
16:01:26 <EvanR> @unmtl ReaderT r (Rand g) a
16:01:26 <lambdabot> r -> g -> (a, g)
16:01:31 <aristid> aavogt: why?
16:01:44 <EvanR> cool thats the type i needed
16:01:46 <ski> aristid : what would `IOT [] a' mean ?
16:02:00 <aristid> ski: i'd need to ask @unmtl
16:02:06 <ski> aristid : you'd need multiple universa to do that
16:02:18 <EvanR> so Rand g is a monad?
16:02:25 <ski> yes
16:02:33 <aavogt>  [IO a], where only the combination that actually gets chosen is executed
16:02:33 <EvanR> i need to get used to these partially evaluated types
16:02:41 <aristid> ski: why? [IO ()] makes sense
16:02:51 <ski> aristid : that's not what it would do
16:02:58 <aavogt> aristid: because it's not exactly like that
16:03:19 <aavogt> ski: am I wrong?
16:03:29 <ski> aristid : it should split the universe in as many branches as the action says, and continue to perform `IO' actions in them
16:03:37 <ski> cf.
16:03:46 <ski> @unmtl StateT s [] a
16:03:46 <lambdabot> s -> [(a, s)]
16:04:50 <EvanR> if i do a ReaderT r (Rand g) a, then i can ask. but to use generate random numbers, i have to use liftM or something?
16:05:16 <ski> (now the `IO' as `State RealWorld' model is a bit simplicitic, but we can't even do that)
16:05:36 <ski> EvanR : no. use`lift'
16:05:40 <EvanR> ah
16:06:55 <EvanR> is there a way to avoid using lift
16:07:04 <EvanR> to be able to use both ask and randoms
16:07:24 <ski> @type randoms
16:07:25 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
16:07:29 <hpc> lift is the preferred solution
16:07:49 <EvanR> ehm
16:07:54 <hpc> i don't know of any others
16:07:54 <ski> possibly the same module that provides `Rand' also provides a class `MonadRandom' (or something similar) with overloaded operations
16:07:58 <ski> ?
16:08:10 <ski> (like `ask' is overloaded over any instance of `MonadReader')
16:08:46 <EvanR> i meant getRandoms
16:08:48 <EvanR> :t getRandoms
16:08:49 <lambdabot> forall (m :: * -> *) a. (MonadRandom m, Random a) => m [a]
16:09:23 <EvanR> ski: so you are saying id have to make a new monad manually and define those operations?
16:09:47 <ski> why ?
16:10:01 <ski> can't you use `getRandoms' on `ReaderT r (Rand g)' ?
16:10:01 <EvanR> i guess that means no
16:10:13 <EvanR> i thought it was lift getRandoms
16:10:37 <ski> well, if `getRandoms' is already overloaded, then you don't need to use `lift'
16:10:45 <EvanR> oh
16:10:50 <EvanR> well thats nifty
16:10:53 <ski> (if you wanted to use `randoms', like you asked about first, then you do need to use `lift')
16:11:12 <EvanR> that was a typo
16:11:28 <EvanR> randoms is a regular functions, i dont think i need lift
16:12:47 <EvanR> so a ReaderT r (Rand g) is automatically an instance of MonadRandom?
16:14:17 <ski> i would expect so
16:14:23 <ski> you could check the docs
16:15:01 <EvanR> thats means someone had to specifically think of it though, right. its not a magic typeclass inheritance thing is it
16:15:10 <ski>   instance MonadRandom m => MonadRandom (Reader r m)  -- something like this should be in the docs, in case it's ok
16:15:36 <aristid> @hoogle MonadRandom
16:15:37 <lambdabot> No results found
16:15:37 <EvanR> thats interesting
16:15:45 <ski> well, they only need to have thought of including the `Reader r m' case, for `m' already in `MonadReader'
16:16:11 <ski> er, for `m' already in `MonadRandom'
16:16:26 <ski> (this is how it is done with `MonadReader',`MonadWriter',`MonadState',`MonadCont',&c.)
16:16:36 <EvanR> theres a straightforward way to 'promote' any transformer that contains exactly one MonadRandom
16:16:37 <dpratt71> do Haskell and Clean share a common ancestry? I was just looking at some examples of Clean and the syntax looks pretty close
16:16:57 <chamitae> hey guys, I've done, as an exercice, an heterogeneous list library using type families: http://npaste.de/Tr/, now I have a question
16:17:28 <EvanR> ski: yeah, the standard ones... but the instances are all pretty similar. seems like it could have been derived
16:17:46 <gwern> dpratt71: I think so - both are sort of miranda derived, although haskell is much more so
16:17:58 <gwern> each has a different answer to IO, I like to think of it
16:18:02 <gwern> except clean is dying
16:18:13 <chamitae> How do I implement a TLUnappend kind of operation, which takes a list of type similar ~ TLAppend l l', and will give me (l, l')?
16:18:16 * ski initially read "hey guys, I've done, as an exercice" as "hey guys, I've done, as an excentric"
16:18:36 <gwern> @wn excentric
16:18:38 <lambdabot> No match for "excentric".
16:18:45 <dpratt71> gwern: interesting; I've seen several references to Miranda, but no actual code of the same
16:18:47 <gwern> ski: you are bad and should feel bad
16:19:13 <EvanR> dpratt71: the book implementation of function programming languages uses miranda for examples
16:19:18 <gwern> dpratt71: no reason you should. it's even more dead than clean. that's what happens to proprietary languages
16:19:21 <wlangstroth> @wn eccentric
16:19:22 <lambdabot> *** "eccentric" wn "WordNet (r) 2.0"
16:19:22 <lambdabot> eccentric
16:19:22 <lambdabot>      adj 1: conspicuously or grossly unconventional or unusual;
16:19:22 <lambdabot>             "restaurants of bizarre design--one like a hat,
16:19:22 <lambdabot>             another like a rabbit"; "famed for his eccentric
16:19:24 <lambdabot> [13 @more lines]
16:19:56 * ski bows head in shame
16:20:15 <EvanR> i wonder if this makes sense
16:20:38 <edwardk> ski is no longer centric, he is ex-centric
16:21:09 * ski dually wonders what "in-centric" might mean
16:21:31 <zygoloid> chamitae: i don't understand what you want. do you want f :: TLAppendT l l' -> (l, l') ?
16:21:33 <DigitalKiwi> probably the same as centic
16:21:59 <DigitalKiwi> inflammable == flammable ;D
16:21:59 <EvanR> monadSmush :: (Monad m1, Monad m2) => m1 -> m2 -> Smush m1 m2
16:22:06 <dpratt71> I've noticed many Haskellers are a bit apologetic of IO in Haskell; is IO in clean worse? the same? better?
16:22:06 <EvanR> its missing the 'a'
16:22:12 <heropass> @wn haskell
16:22:13 <lambdabot> No match for "haskell".
16:22:25 <wli> Apologetic?
16:22:32 <EvanR> some 'algorithmic' way to combine any two monads
16:22:35 <chamitae> zygoloid: well yes in a sort, suppose I have a type list which matches TLAppendT l l', I want to split it to (l, l')
16:22:36 <EvanR> like a tuple
16:22:39 <ski> dpratt71 : in some sense, nicer, in other, worse. iiuc
16:22:47 <gwern> dpratt71: different. it uses linear types; faster, but less general than monads, is the viewpoint I saw back when people still knew of and discussed haskell vs. clean
16:23:02 <edwardk> maybe he really likes triangles and wants to stay within the excircle by the excenter, incentric individuals would be even more tightly constrained to the incircle by the incenter
16:23:05 <zygoloid> chamitae: on the type level, it can't be done that way around: there are multiple (l, l') pairs a given type could decompose into
16:23:34 <zygoloid> if you already know l and l' then you can do that sort of thing on the value level
16:23:42 <ski> s/linear/uniqueness/
16:23:45 * dpratt71 tries to reason what iiuc means...
16:23:50 <edwardk> aavogt: I managed to trim the types in that line
16:23:56 <edwardk> 'if i understand correctly'
16:24:01 <hpc> yeah
16:24:05 <chamitae> zygoloid: ok
16:24:09 <dpratt71> edwardk: thanks :)
16:24:22 <chamitae> zygoloid: indeed I already know l and l'
16:25:49 <chamitae> zygoloid: but even if I know l and l', I can't do it in the type level?
16:27:23 <zygoloid> well, you can, but that's not really splitting the TLAppendT l l' so much as just writing down the answer :)
16:27:33 <lowasser> obtw, if anyone who was there remembers, it turns out apparently that "MachDeps.h" is included with GHC
16:27:33 <LegendaryPenguin> whenever I use readLn it keeps saying No Parse
16:27:50 <lowasser> #including it, regardless of where you are, gets you all sorts of lovely information about the size, in bits, of the various types
16:28:37 <zygoloid> LegendaryPenguin: are you sure it's using the right type? (defaulting may have picked something unfortunate)
16:29:05 <EvanR> the question i got was, when doing ReaderT r IO a, why we have to use liftIO around every IO action. the only answer i could come up with is so that the types match up. but then i tried to figure out a better reason, the 'real' reason. and i couldnt
16:29:18 <LegendaryPenguin> do x <- readLn; putStrLn x
16:29:26 <heropass> @wn patchbay
16:29:27 <lambdabot> No match for "patchbay".
16:29:38 <aristid> @undo do x <- readLn; putStrLn x
16:29:39 <lambdabot> readLn >>= \ x -> putStrLn x
16:29:39 <heropass> @patch
16:29:40 <lambdabot> Unknown command, try @list
16:29:40 <soupdragon> do x <- readLn; putStrLn x = readLn >>= putStrLn
16:29:44 <aristid> @. pl undo do x <- readLn; putStrLn x
16:29:44 <lambdabot> putStrLn =<< readLn
16:29:50 <heropass> @wn patch
16:29:51 <lambdabot> *** "patch" wn "WordNet (r) 2.0"
16:29:51 <lambdabot> patch
16:29:51 <lambdabot>      n 1: a small contrasting part of something; "a bald spot"; "a
16:29:51 <lambdabot>           leopard's spots"; "a patch of clouds"; "patches of thin
16:29:51 <lambdabot>           ice"; "a fleck of red" [syn: {spot}, {speckle}, {dapple},
16:29:53 <lambdabot> [26 @more lines]
16:29:54 <zygoloid> EvanR: i guess the 'real' reason is that IO predates MonadIO, so the functions are all :: a -> IO b, not :: MonadIO m => a -> m b
16:29:58 <c_wraith> EvanR: you could have just used lift, rather than liftIO.
16:29:59 <heropass> must get sleep ...
16:30:30 <aavogt> edwardk: which line?
16:30:37 <heropass> \quit
16:31:02 <c_wraith> EvanR: and the "real" reason to use lift is to properly wrap inner monad behavior in the transformer behavior.
16:31:03 <zygoloid> EvanR: nothing stops someone writing a library exporting "putStrLn :: MonadIO m => String -> m ()" etc.
16:31:24 <zygoloid> EvanR: another reason is that functions which /take/ IO actions (such as forkIO) can't work for an arbitrary MonadIO.
16:31:29 <c_wraith> EvanR: that works as the "real" reason why liftIO is necessary.  You need to wrap the IO behavior in the transformers tack behavior.
16:31:35 <sm> how do I prevent double compilation for exe and lib with cabal-install 1.8 and ghc 6.12 ?
16:31:46 <EvanR> so on one hand, the 'nice' way is 20/20 hidesight, and on the other, theres some semantic value is explicitly wrapping everything?
16:31:57 <edwardk> aavogt: was it you who made the comment earlier about a slightly more complicated     binaryP :: (a -> a -> a) -> (a -> t a -> t a -> (Partial t a, Partial t a)) -> t a -> t a -> t a -- or was that aristid?
16:32:09 <aristid> edwardk: it was me
16:32:13 <edwardk> ah
16:32:23 <EvanR> c_wraith: ok the last thing you said is good
16:32:29 <edwardk> aristid: in response to your boggled reaction i removed some subscripts ;)
16:32:47 <c_wraith> EvanR: Unfortunately, ReaderT doesn't really *have* behavior, so it's a sort of silly answer in that case. :)
16:33:00 <aristid> edwardk: almost readable now, eh?
16:33:14 <edwardk> aristid i think so. its slowly coming together
16:33:23 <EvanR> c_wraith: so a MonadIO that isnt IO is basically going to be a transformer containing IO
16:33:33 <c_wraith> EvanR: yes
16:33:41 <EvanR> but it doesnt have to be, and its required by the type system
16:33:45 <EvanR> and those cant do forkIO
16:33:52 <EvanR> s/its/isnt/
16:34:12 <EvanR> hrm >_<
16:34:14 <edwardk> this approach promises to let me insert reversed direction checkpoints in the code and do all sorts of fun things
16:34:14 <c_wraith> they can do forkIO, actually.  There's no type-system level why not.
16:34:30 <aristid> edwardk: now you only need that burst of insight that shrinks it down to something as simple as liftM2? :D
16:34:43 <edwardk> aristid: heh 'binaryP' _is_ my liftM2 ;)
16:34:50 <edwardk> aristid: i use it to shrink other code down ;)
16:34:54 <EvanR> c_wraith: ok so the forkIO thing is irrelevant
16:35:07 <c_wraith> EvanR: yeah, I don't see any connection
16:35:18 <EvanR> oh, that was zygoloid
16:36:03 <edwardk> the goal there was to let you just write sin = unary sin cos -- to package up the type with its derivative regardless of the ad mode being used
16:36:04 <EvanR> c_wraith: transformers tack behavior?
16:36:05 <aristid> edwardk: maybe you should go for something like f <$> x <*> y instead? :D
16:36:15 <EvanR> stack
16:36:18 <c_wraith> EvanR: typo.  I meant "transformer stack" behavior
16:36:21 <EvanR> gotta reread now
16:36:35 <zygoloid> the forkIO issue is that you can't write a general lifted version of forkIO :: MonadIO m => m () -> m ThreadId
16:36:55 <aristid> @hoogle forkIO
16:36:56 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
16:37:01 <c_wraith> Yes, that's a good reason why you need an explicit IO type sometimes.
16:37:11 <edwardk> or (+) = binary (+) 1 1; (*) = binaryP (*) (\_ b c -> (lift c, lift b)) -- and then i only have to write that latter code once due to the other crazy newtype wrappers
16:37:12 <aristid> zygoloid: why not?
16:38:09 <aristid> edwardk: can you explain the purpose of the package in simple words? :)
16:38:22 <zygoloid> aristid: how would it work? what would forkIO do for StateT s IO a?
16:38:56 <EvanR> do the action in another thread
16:39:01 <edwardk> aristid: it lets you take arbitrary haskell functions and automatically calculate their derivatives efficiently
16:39:12 <zygoloid> EvanR: and do what with the state?
16:39:47 <aristid> edwardk: oh, cool
16:40:01 <EvanR> zygoloid: the same thing it does with the () in IO () ?
16:40:06 <aristid> edwardk: so you have a Num instance for that?
16:40:11 <edwardk> aristid: so diff sin ~ cos, etc
16:40:40 <aristid> edwardk: does it work with recursive functions too?
16:40:47 <edwardk> yes, though its a bit tricky because it calculates them numerically by multiplying fragments of the jacobian
16:40:47 <zygoloid> EvanR: so, copy the state in on fork and discard it on exit? you can't do that in a way which is parametric over the MonadIO instance
16:40:51 <edwardk> aristid: yeah
16:41:42 <EvanR> zygoloid: so were talking about an instance of MonadIO that is StateT s IO, method forkIO
16:41:44 <aristid> edwardk: do i understand correctly that it works in a mixed numeric/algebraic method?
16:41:59 <EvanR> er
16:42:06 <EvanR> MonadIO m => StateT s m
16:42:17 <edwardk> aristid: that is a reasonable statement
16:42:32 <zygoloid> EvanR: forkIO is not a member of MonadIO
16:42:38 <EvanR> oh
16:43:01 <EvanR> ok the were defining MonadIO m => IO () -> IO ThreadId
16:43:14 <EvanR> erm
16:43:22 <EvanR> MonadIO m => m () -> m ThreadId
16:43:39 <EvanR> now we dont even know that its a StateT so why do we need to figure out what to do with it
16:43:48 <edwardk> aristid: the 'rad' and 'fad' packages have simpler versions of this to play with
16:43:50 <aristid> @hoogle liftIO
16:43:51 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
16:43:52 <zygoloid> my point was merely that it can't be done parametrically
16:44:08 <zygoloid> StateT was a poor choice of example. there are monad transformers where it can't be done at all.
16:44:38 <aristid> edwardk: i saw them on hackage and thought "no clue what this is about".
16:44:42 <EvanR> im lost
16:44:44 <EvanR> :(
16:44:54 <soupdragon> me too
16:45:08 <c_wraith> zygoloid: ContT?  It's always a fun one
16:45:28 <EvanR> running the StateT action in another thread and ignoring the final state seems like a very IO thing to do
16:45:33 <zygoloid> c_wraith: yeah, that's a better example
16:45:34 <EvanR> the action can still use its state
16:46:10 <aristid> generally many hackage packages have subpar documentation :/
16:46:25 <edwardk> aristid: sorry bout that ;)
16:46:35 <EvanR> alright ContT, guess i gotta go learn that now.
16:47:13 <c_wraith> The thing about ContT is that you could ask it to un-fork.  That's going to have unpleasant consequences.
16:47:27 <Gracenotes> whoever made DiffTime didn't have serialization of UTCTimes in mind...
16:47:28 <zygoloid> EvanR: if you have to be able to perform forkIO :: m () -> m ThreadId, that means ContT r IO can't be a MonadIO any more
16:47:49 <conal> sinelaw: awesome!  good luck on your presentation.
16:48:23 <aristid> @hoogle ContT
16:48:24 <lambdabot> Control.Monad.Cont newtype ContT r m a
16:48:24 <lambdabot> Control.Monad.Cont ContT :: ((a -> m r) -> m r) -> ContT r m a
16:48:24 <lambdabot> Control.Monad.Cont mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a
16:48:30 <EvanR> zygoloid: thats sounds pretty cool to me
16:48:40 <EvanR> even more ridiculous than goto ;)
16:49:18 <edwardk> hrmm i suppose i should define an instance for VectorSpace for the AD types
16:52:06 <EvanR> c_wraith: so is the final answer that IO is just special like that.
16:52:58 <c_wraith> EvanR: as has been pointed out before, IO doesn't have formal semantics, and possibly can't.  So yeah, IO is special in some ways.
16:53:43 <EvanR> theres gotta be a solution ;)
16:59:31 <MoALTz> > id 2 3 4
16:59:32 <lambdabot>   Ambiguous type variable `t' in the constraint:
16:59:32 <lambdabot>    `GHC.Num.Num t' arising f...
16:59:38 <MoALTz> > 1 + id 2 3 4
16:59:39 <lambdabot>   3
17:01:13 <soupdragon> > 1 + id 2 3 4
17:01:15 <lambdabot>   3
17:01:20 <soupdragon> :t id
17:01:21 <lambdabot> forall a. a -> a
17:01:26 <soupdragon> :t 1 + id 2 3 4
17:01:27 <lambdabot> forall t. (Num t) => t
17:01:30 <soupdragon> :t id 2 3 4
17:01:32 <lambdabot>     Ambiguous type variable `t' in the constraint:
17:01:32 <lambdabot>       `Num t' arising from the literal `4' at <interactive>:1:7
17:01:32 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
17:01:35 <soupdragon> :t 1 + 2 3 4
17:01:36 <lambdabot> forall t. (Num t) => t
17:01:42 <soupdragon> > 1 + 2 3 4
17:01:43 <lambdabot>   3
17:01:46 <soupdragon> > 1 + 2 3
17:01:48 <lambdabot>   3
17:01:56 <soupdragon> > 1 + 2 776876
17:01:57 <lambdabot>   3
17:02:21 <Gracenotes> oh, urgh, UTCTime just isn't worth it..
17:02:31 <soupdragon> > ((+1) + (*3)) 4
17:02:32 <lambdabot>   17
17:02:35 <soupdragon> WTF
17:02:51 <EvanR> > 4 6
17:02:52 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:02:52 <lambdabot>    `GHC.Num.Num t' arising f...
17:02:55 <tensorpudding> @type (+)
17:02:56 <dolio> > sin^2 + cos^2 $ 384
17:02:57 <lambdabot> forall a. (Num a) => a -> a -> a
17:02:57 <lambdabot>   1.0
17:03:01 <tensorpudding> hmm
17:03:07 <Gracenotes> haha
17:03:14 <Gracenotes> instance Num b => Num (a -> b)
17:03:22 <tensorpudding> Yeah.
17:03:25 <EvanR> is someone going to explain to me all this
17:03:37 <EvanR> arithmetic is out the window or what
17:04:09 <c_wraith> What, that instance makes perfect sense to me.
17:04:39 <tensorpudding> > (*5) + (-3)
17:04:40 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:04:40 <lambdabot>    arising from a use of `...
17:04:45 <tensorpudding> eh
17:04:50 <tensorpudding> > (*5) + (-3) $ 10
17:04:51 <lambdabot>   47
17:05:03 <EvanR> Num instance for functions?
17:05:05 <tensorpudding> > (-3) + (*5) $ 10
17:05:06 <lambdabot>   47
17:05:15 <tensorpudding> buh?
17:05:16 <EvanR> is this design specifically to cause heads to explode or what
17:05:53 <tensorpudding> how did it know the right way to do that?
17:06:13 <EvanR> :t (-3)
17:06:14 <lambdabot> forall a. (Num a) => a
17:06:21 <tensorpudding> err damn
17:06:24 <tensorpudding> foiled
17:06:33 <tensorpudding> but how did that typecheck then?
17:06:45 <tensorpudding> (*5) and (-3) would have different types
17:06:49 <Draconx> fromInteger turned (-3) into const (-3)
17:07:07 <dolio> > 1 + (*5) $ 10
17:07:08 <lambdabot>   51
17:07:14 <tensorpudding> that's...unexpected
17:07:31 <Draconx> tensorpudding, it's how Num instances work.
17:07:32 <dolio> > 1 + sin $ pi/2
17:07:33 <lambdabot>   2.0
17:07:41 <tensorpudding> > (- 3) + (*5) $ 10
17:07:42 <lambdabot>   47
17:07:44 <EvanR> > fromInteger (-3) :: (Bool -> Int)
17:07:44 <sinelaw> what's this witchery
17:07:45 <lambdabot>   *Exception: show: No overloading for function
17:07:48 <tensorpudding> hmm
17:07:53 <Gracenotes> 1 is a function which returns 1
17:08:01 <tensorpudding> > (*5) + (- 3) $ 10
17:08:03 <lambdabot>   47
17:08:20 <Gracenotes> @type subtract 3
17:08:21 <lambdabot> forall t. (Num t) => t -> t
17:08:31 <tensorpudding> > (*5) + (subtract 3) $ 10
17:08:33 <lambdabot>   57
17:08:45 <tensorpudding> how did it get that?
17:08:58 <EvanR> so wheres the corresponding instance for Show... shouldnt it just pass undefined to the result and print the number
17:09:00 <Draconx> tensorpudding, same reason.
17:09:08 <dolio> (10*5) + (subtract 3 10)
17:09:25 <EvanR> > (const 5) undefined
17:09:27 <lambdabot>   5
17:09:40 <aavogt> EvanR: because most of the time your result will depend on the input
17:10:00 <EvanR> aavogt: so whats +
17:10:11 <aavogt> it would take some magic to tell  show sin   from   show 1
17:10:18 <soupdragon> > show sin
17:10:18 <tensorpudding> so the Num instance for Num b => (a -> b) is (f + g) = \n -> (f n) + (g n)?
17:10:19 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:10:19 <lambdabot>    arising from a use of `...
17:10:21 <Draconx> tensorpudding, er, I read "subtract" but thought "negate".  It works because both arguments to + are appropriately valued functions.
17:10:33 <Gracenotes> argh, just trying to find a simple way to get the number of milliseconds since the epoch without all this Data.Fixed nonsense
17:10:43 <wli> tensorpudding: Yes.
17:11:00 <aavogt>  liftA2 (+)
17:11:13 <tensorpudding> For some reason I was expecting something more like (.), but now that I think on it I'm realizing that was silly.
17:11:15 <aavogt> for applicative functor (a -> )
17:11:15 <Gracenotes> looks like old-time < time here
17:11:18 <Gracenotes> *>
17:11:20 <wli> tensorpudding: This is new BTW. Maybe it's Caleskell, maybe it's newer ghc libs.
17:11:32 <tensorpudding> I know it's new.
17:11:43 <Draconx> > (const 3) == (const 5)
17:11:44 <dolio> It's from some module Cale imported.
17:11:44 <lambdabot>   *Exception: (==): No overloading for function
17:11:51 <tensorpudding> is (->) an applicative?
17:12:00 <aavogt> :k (->)
17:12:01 <lambdabot> ?? -> ? -> *
17:12:09 <tensorpudding> rather, (->) a
17:12:17 <c_wraith> yes, it is
17:12:27 <Draconx> tensorpudding, (-> a).
17:12:27 <ski> every monad is an applicative functor
17:12:29 <c_wraith> the same way it's a Monad
17:12:30 <dolio> Or it was. Perhaps he put it in manually because importing the module caused a conflict with the show instance for functions.
17:12:30 <aavogt> it's rather confusing to write it prefix
17:12:39 <ski> Draconx : `(a ->)'
17:12:42 <tensorpudding> I hadn't remember it being a Monad, just a Functor.
17:12:56 <Draconx> ski, oh, oops.  I thought it was the other.
17:12:57 <tensorpudding> but the Monad instance would make sense.
17:12:58 <aavogt> or those sections don't work how the rest of them work
17:13:13 <ski> tensorpudding : it's basically `Reader a'
17:13:30 <ski> @unmtl Reader r a
17:13:30 <lambdabot> r -> a
17:14:10 <Draconx> ah, ghci writes it as ((->) a), probably explaining my confusion :)
17:17:05 <ski> Draconx : it is similar to `(/) 2' being `(2 /)' and not `(/ 2)'
17:17:26 <Draconx> ski, yeah, I see that now.
17:18:25 <c_wraith> > (+) <*> (*3) $ 5
17:18:26 <lambdabot>   20
17:18:39 <c_wraith> whoo!  I remembered what <*> does! :)
17:23:06 <kmc> > [pred, succ] <*> [5,8]
17:23:06 <lambdabot>   [4,7,6,9]
17:23:06 <dolio> > ((+) + (*)) 1 2
17:23:06 <lambdabot>   5
17:23:06 <kmc> > [(+), (*)] <*> [3,4] <*> [700,800]
17:23:06 <lambdabot>   [703,803,704,804,2100,2400,2800,3200]
17:23:06 <soupdragon> what the carp!
17:23:07 <EvanR> my next question about transformers. i established that i can easily use ask and getRandoms by using ReaderT r (Rang g)
17:23:07 <EvanR> Rand
17:23:29 <EvanR> can i easily use functions (x -> y) in a ContT, or do i need to lift them
17:23:36 <EvanR> liftM...
17:24:24 <c_wraith> there's also lift . liftM, if you want to lift into the inner monad.  Transformers have lots of fiddly details.
17:24:42 <EvanR> gah
17:25:24 <c_wraith> follow the types
17:25:26 <c_wraith> :t liftM
17:25:27 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:25:32 <c_wraith> :t lift . liftM
17:25:33 <lambdabot> forall (t :: (* -> *) -> * -> *) a1 r (m :: * -> *). (MonadTrans t, Monad m) => (a1 -> r) -> t ((->) (m a1)) (m r)
17:25:57 <EvanR> ._. k
17:25:57 <aavogt> it takes some time to learn monad transformers
17:26:19 <jmcarthur> hmm... if i have a function like this, does it make another copy of the constructor of the argument?   foo (Bar a) = Bar a
17:26:33 <jmcarthur> for example, if the argument and the result have different types?
17:27:01 <jmcarthur> say:   data Baz a b = Bar a | Bar2 b
17:27:14 <jmcarthur> i guess Bar2 is unnecessary for my example
17:27:20 <aavogt> @type \(Right a) -> Right a
17:27:21 <lambdabot> forall t t1 a. Either t t1 -> Either a t1
17:27:32 <dolio> > ((+) * negate) 5 6
17:27:32 <c_wraith> :t right
17:27:33 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
17:27:33 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
17:27:58 <jmcarthur> @type \(Left a) -> Left a
17:27:59 <lambdabot> forall t t1 b. Either t1 t -> Either t1 b
17:28:01 <aavogt> jmcarthur: if it does, would an as pattern help here?
17:28:29 <jmcarthur> aavogt: you mean like a@(Bar _) = a?
17:28:34 <aavogt> yes
17:28:43 <jmcarthur> that wouldn't work since it would be insufficiently polymorphic
17:29:01 <aavogt> @type \ x @ (Right {}) -> x
17:29:02 <lambdabot> forall t t1. Either t t1 -> Either t t1
17:29:07 <jmcarthur> @type \a@(Left _) = a
17:29:08 <lambdabot> parse error on input `='
17:29:13 <jmcarthur> @type \a@(Left _) -> a
17:29:14 <lambdabot> forall t t1. Either t t1 -> Either t t1
17:29:24 <aavogt> you're asking for an unsafeCoerce then?
17:29:28 <aavogt> :)
17:29:39 <jmcarthur> well, i'm just wondering if it would do that in the compiler anyway
17:29:47 <jmcarthur> i guess i could just look at the generated code
17:30:53 <siracusa> Has anyone achieved to successfully build and run gtk2hs from the latest repo on a Windows machine?
17:33:53 <EvanR> > runCont (return 5 >>= return . (+3)) id
17:33:55 <lambdabot>   8
17:34:33 <EvanR> i cannot figure out how to plug liftM into there to remove the return .
17:34:41 <EvanR> :t (.) return
17:34:42 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
17:34:52 <EvanR> wait what
17:34:54 <aavogt> > runCont (liftM (+3) $ return 5) id
17:34:55 <lambdabot>   8
17:34:55 <sinelaw> @pl (.) return
17:34:56 <lambdabot> (return .)
17:35:19 <copumpkin> > runCont (liftM (+3) (return 5)) id
17:35:20 <lambdabot>   8
17:35:20 <EvanR> aavogt: ah
17:35:26 <sinelaw> @pl (>>= return)
17:35:27 <lambdabot> id
17:35:35 <aavogt> @pl pl lp
17:35:35 <lambdabot> pl lp
17:38:42 <EvanR> :t callCC
17:38:43 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
17:40:43 <applicative> @instances MonadCont
17:40:43 <lambdabot> Cont r, ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
17:40:56 <applicative> familiar friends....
17:41:30 <EvanR> friends, or simply people who take you for granted
17:42:15 <applicative> Well, it's not me taking them for granted...
17:43:54 <gwern> friends, haskellers, countrymen - lend me your lambdas
17:44:08 <gwern> I come not to bury impurity, but to praise it...
17:46:34 <EvanR> > runCont (callCC (\k -> return 4 >>= k) >>= return . (+3))) id
17:46:35 <lambdabot>   <no location info>: parse error on input `)'
17:46:40 <EvanR> > runCont (callCC (\k -> return 4 >>= k) >>= return . (+3)) id
17:46:42 <lambdabot>   7
17:46:49 * EvanR feels accomplished
17:46:49 <gwern> (but wadler tells us impurity is harmful, and wadler is a wise man)
17:47:07 <Armada64> Wow, she's hot. http://webbax.se/pics/hotgirl.jpg
17:47:16 <EvanR> Armada64: im sure
17:47:27 <EvanR> probably a huge penis or something
17:47:36 --- mode: ChanServ set +o copumpkin
17:47:45 <c_wraith> or that javascript exploit that was flooding channels here a couple months ago
17:47:52 <Armada64> :-P
17:47:53 <Armada64> neither
17:48:03 <gwern> flash. figures
17:48:10 <EvanR> that exploit was genius
17:48:20 <c_wraith> eh.  flash, javascript...  neither works in my browser. :)
17:48:28 <EvanR> which one
17:48:48 <tensorpudding> That's no picture.
17:48:56 <c_wraith> oh.  which browser?  firefox.  with noscript set to block everything.
17:49:15 <EvanR> ah that one
17:49:23 <tensorpudding> It's a flash embedded in HTML
17:49:54 <gwern> tensorpudding: points for starting with a star wars ref, and a demerit for failing to carry it out
17:50:02 <Armada64> i'm sure it could be replicated as a GIF, right
17:51:48 * applicative agrees that EvanR is accomplished
17:52:20 <tensorpudding> So did anyone actually watch the flash? I'm curious what it is.
17:52:39 <Armada64> it's a hot girl..
17:53:03 <Armada64> well actually, two.
17:53:51 <k23z__> hey I'm lookin for some people to write some Haskell with
17:53:52 <k23z__> what up ?
17:53:57 <k23z__> anyone wanna do this ?
17:54:44 <applicative> k23z_, as long as you are defining the reverse of a String, I'm ready
17:54:57 <EvanR> k23z__: homework?
17:55:20 <k23z__> EvanR: no man, like real street Haskell :)
17:55:26 <EvanR> lol
17:55:53 <ejpbruel> hey
17:55:56 <applicative> yeah man, let's like get the compile to list the primes and not pay...
17:55:58 <ejpbruel> i have a quick question
17:56:06 <applicative> compiler
17:56:26 <applicative> ejpbruel, good
17:56:27 <ejpbruel> f nil = \ x -> x f (cons h t) = \ x -> f t
17:56:37 <EvanR> lets start with a ReaderT WriterT StateT RandT ContT
17:56:37 <ejpbruel> wait, sorry
17:56:42 <EvanR> IO
17:56:45 <ejpbruel> f nil = \ x -> xf (cons h t) = \ x -> f t
17:56:50 <ejpbruel> f nil = \ x -> x f (cons h t) = \ x -> f t
17:56:51 <ejpbruel> damnit
17:56:59 <ejpbruel> f nil = \ x -> x
17:57:05 <ejpbruel> f (cons h t) = \x -> f t
17:57:08 <ejpbruel> thats betters
17:57:16 <ejpbruel> i was wondering
17:57:18 <ejpbruel> a function like that
17:57:19 <k23z__> > concat (reverse (splitOn "" "asdasfas"))
17:57:20 <lambdabot>   Not in scope: `splitOn'
17:57:24 <ejpbruel> would that be well typed in haskell?
17:57:29 <k23z__> > import Data.List.Split; concat (reverse (splitOn "" "asdasfas"))
17:57:30 <lambdabot>   <no location info>: parse error on input `import'
17:57:37 <gwern> if we want to discuss porn, consider this: http://thegrandnarrative.com/2009/03/05/zoe-tay-imedeen-skin-whitening-advertisement/
17:57:41 <k23z__> applicative,   > import Data.List.Split; concat (reverse (splitOn "" "asdasfas"))
17:58:59 --- mode: ChanServ set -o copumpkin
17:59:10 <k23z__> ah damn reverse was already implemented for strings
17:59:29 <applicative> k23z__, very sophisticated string reversal.  I was hoping for something at the type level
17:59:31 <kmc> @unmtl ReaderT r (WriterT w (StateT s (ContT e IO))) a
17:59:31 <lambdabot> r -> s -> (a -> w -> s -> IO e) -> IO e
18:00:01 <k23z__> applicative, I don't exactly understand what you mean ..
18:00:17 <kmc> ejpbruel, you can upload code to hpaste.org
18:00:25 <kmc> or when that's broken codepad.org
18:00:49 <applicative> k32z_, i was kidding. I was pretending to want something even more complicated and crazy than concat. reverse . splitOn ""
18:01:23 <applicative> there was a video about a type level spell checker somewhere, a witty haskell joke.
18:02:19 <applicative> ejpbruel, f (cons h t) = \x -> f t -- here the h isn't used, do you want that
18:05:38 <applicative> ejpbruel, they are easier to read, the two lines, if you chuck the lambdas  f nil x = x ; f (cons h t) x = f t
18:06:28 <ejpbruel> @kmc, would that also tell me *why* a function is not well typed?
18:06:28 <ejpbruel> yes, its not supposed to be a useful function, just a thought experiment
18:06:28 <ejpbruel> as i suspected, haskell gives me the following
18:06:28 <ejpbruel>  - Type error in function binding *** Term           : f *** Type           : [[a]] -> c -> b -> b *** Does not match : [a] -> b -> b *** Because        : unification would give infinite type
18:06:28 <ejpbruel> @kmc, thank you for the tip
18:06:29 <lambdabot> Unknown command, try @list
18:06:29 <lambdabot> Unknown command, try @list
18:08:52 <kmc> IRC /= Twitter
18:08:58 <kmc> ejpbruel, i didn't mean to upload it there to typecheck
18:09:01 <kmc> you should do it on your own machine
18:09:11 <kmc> i meant to upload it there so you can give us the URL and we can read your code
18:09:23 <copumpkin> hmm, my parser just ate up all my memory
18:09:29 <copumpkin> I'm guessing that means I'm doing it wrong
18:09:38 <ben_m> Can anyone (I'm sure you can :) think of a better way of doing this: substrings n xs = filter ((== n) . length) $ map (take n) $ tails xs
18:10:12 <ejpbruel> @kmc right, but nevertheless, i did get the answer i was looking for (and expected)
18:10:12 <lambdabot> Maybe you meant: ghc rc src
18:10:22 <kmc> ah
18:13:51 <applicative> ejpbruel, I meant to be saying, nothing like this could be well typed since  in " f (cons h t) x = f t  " takes two arguments on the left, one on the right
18:14:47 <pikhq> applicative: Does not parse, actually.
18:15:12 <pikhq> Hint: cons is not a data constructor. :)
18:15:31 <copumpkin> uu-parsinglib isn't very well documented
18:15:36 <applicative> pikhq, i was thinking we were trying to solve for f, cons, nil, h, t and x
18:15:58 <applicative> copumpkin, what about that awesome examples file...
18:16:01 <gweber> has anyone used Matrix.Simplex ? http://hackage.haskell.org/packages/archive/dsp/0.2.1/doc/html/Matrix-Simplex.html I am a little confused on how to form a matrix for it
18:16:06 <copumpkin> applicative: lol
18:19:32 <Cale> > let substrings n xs = zipWith (flip const) (drop (n-1) xs) . map (take n) . tails $ xs in substrings 5 "helloworld"
18:19:33 <lambdabot>   ["hello","ellow","llowo","lowor","oworl","world"]
18:20:07 <Cale> > let substrings n xs = zipWith (flip const) (drop (n-1) xs) . map (take n) . tails $ xs in substrings 5 [1..]
18:20:09 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
18:24:43 <ben_m> nice :)
18:36:54 * FunctorSalad just wasted an hour or so making a white-on-black/darkred/darkblue/darkpurple haddock theme
18:37:53 * applicative could do with a new haddock theme; gloomy could be good.
18:38:26 <ben_m> what's haddock again?
18:38:32 <copumpkin> a kind of fish
18:38:39 <SamB_XP> isn't that some kinda fish that hook hates?
18:38:53 <copumpkin> ben_m: also, the haskell documentation system
18:39:14 <ben_m> that's what I assumed and why I'm confused
18:39:18 <gwern> @quote haddock
18:39:18 <lambdabot> No quotes match. Wrong!  You cheating scum!
18:39:22 <gwern> astounding
18:39:24 <kmc> this documentation is dark like my soul
18:39:26 <kmc> @dict haddock
18:39:27 <lambdabot> Supported dictionary-lookup commands:
18:39:27 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
18:39:27 <lambdabot> Use "dict-help [cmd...]" for more.
18:39:32 <kmc> @wn haddock
18:39:33 <ben_m> custom user theme for haddock sites?
18:39:33 <lambdabot> *** "haddock" wn "WordNet (r) 2.0"
18:39:34 <lambdabot> haddock
18:39:34 <lambdabot>      n 1: lean white flesh of fish similar to but smaller than cod;
18:39:34 <lambdabot>           usually baked or poached or as fillets sauteed or fried
18:39:34 <lambdabot>      2: important food fish on both sides of the Atlantic; related
18:39:34 <FunctorSalad> ben_m: bright-on-dark css file for haddock
18:39:35 <lambdabot>         to cod but usually smaller [syn: {Melanogrammus aeglefinus}]
18:39:46 <ben_m> yeah.
18:39:51 <SamB_XP> @quote had.ock
18:39:51 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
18:39:56 <ben_m> It's 3:40 in the morning here and I haven't slept yet.
18:40:07 <ben_m> And I have to get up at 6... bloody Haskell keeps me awake :D
18:42:23 <FunctorSalad> http://code.haskell.org/~daniels/dark_haddock_of_darkness/example.html
18:42:36 <ben_m> good night!
18:42:43 <Saizan> cool :O
18:43:20 <applicative> ben_m dont go, we haven't defined any instances of Applicative
18:43:30 <Saizan> except that bright-on-dark monospaced fonts look weird here in general
18:43:57 <applicative> FunctorSalad, cool.  Now if only I could get my browser to do a little transparency...
18:43:58 <FunctorSalad> at first I just wanted to do a quick white-on-black but then it became unintentionally really sinister with the purples :o
18:44:08 <FunctorSalad> (at least in a dark room)
18:44:27 <Saizan> you should try with purple as the background.
18:44:39 <Saizan> that's how i like my terminals anyway :)
18:44:41 <applicative> FunctorSalad, you should convince Hackage to use it for ugly things like bindings to C libraries...
18:45:00 <applicative> FunctorSalad, I meant, sinister things
18:45:07 <FunctorSalad> applicative: hehehe
18:46:11 <applicative> FunctorSalad, I see there is a difficulty distinguishing code linked by Haddock and regular code in the commentary
18:46:47 <bob`> q
18:47:33 <FunctorSalad> applicative: hmm I think that's intentional (I set both 'pre' tags and visited links to purple since I tried to make code in general purple and almost all links are code)
18:47:47 <FunctorSalad> (could special-case the ones in the header/footer which aren't)
18:51:35 <FunctorSalad> Saizan: hmm but wouldn't that "waste" the black? at least if you consider the contrast at the bottom of brightness limiting ;)
18:52:11 <FunctorSalad> Saizan: (that's also why I'm generally puzzled by "white-on-black" schemes with gray background... it's hard enough to get a laptop screen black as it is)
18:57:08 <napping> Has anyone tried mixing lhs2TeX and docutils?
18:57:18 <applicative> the Opera browser misrenders Haddocked html
18:57:56 <FunctorSalad> applicative: the normal one too you mean?
18:58:13 <applicative> FunctorSalad, yeah, both.  I noticed it with yours first
18:58:36 <bob`> first appear
19:00:23 <napping> It's too bad literate haskell mode doesn't seem to recognize \begin{code}\end{code}
19:01:16 <applicative> FunctorSalad, It's baffling, the example code is appearing in sensible monotype, but the Haddocked lines are in some third font.  I wonder if they're right and everyone else is wrong.  Probably not.
19:01:17 <FunctorSalad> napping: I've never tried it myself but I've seen that in standard libs
19:01:31 <Veinor> <FunctorSalad> napping: I've never tried it myself
19:01:34 <Veinor> my god, man
19:01:36 <Veinor> you're missing out!
19:01:55 <FunctorSalad> ? ;)
19:02:04 <applicative> napping, you want the compiler read those, instead of birdtracked lines?
19:02:28 <FunctorSalad> (maybe it was in addition to those "birds")
19:03:26 <applicative> napping, sorry, i mean, you would like the lhs-preprocessor, or whatever its called, to strip off all but whats in \begin{code}..\end{code}
19:04:00 <FunctorSalad> applicative: FWIW, I have no fonts in the css and I think I only changed the html by adding the css link... (though apparently I managed to sneak on open angle bracket into the rendered contents :o)
19:05:55 <napping> no, I'd like the emacs mode to syntax highlight code in them, instead of just code with >
19:06:13 <napping> I think lhs2Tex only works with the begin/end form
19:08:40 <FunctorSalad> napping: maybe mmm-mode can do that
19:09:15 <FunctorSalad> if it's possible to get it to make the > invisible to the embedded haskell-mode
19:10:04 <napping> I think mumamo working with \begin/\end once, which would be ok
19:10:52 <napping> haskell mode already works with > on lhs files, so the question if I'm using ReST is if lhs2TeX is fine with it
19:12:58 <applicative> napping, how are you turning your .rst file into .tex
19:15:27 <applicative> napping, I notice pandoc puts code blocks marked as ~~~~{.haskell} into \begin{code}, code blocks marked as ~~~~{.python} into \begin{verbatim}
19:15:42 <napping> oh, that could help
19:16:00 <napping> just have to figure out how to get the %include lhs2TeX.fmt line then
19:16:20 <applicative> napping, actually it claims to have the ability to read  rst+lhs
19:17:40 <napping> where?
19:18:05 <applicative> napping, not sure if its in the docs, i just did > pandoc --help
19:18:25 <napping> an pandoc claims, not lhs2TeX
19:19:43 <FunctorSalad> btw head = foldr const undefined
19:19:44 <FunctorSalad> ;)
19:19:48 <applicative> sorry, yes, pandoc claims to be able to read rst files as literate haskell so it can output tex appropriate for lhs2tex
19:21:23 <FunctorSalad> (semi-wrong channel)
19:21:53 <applicative> #pandoc or #lhs2tex ?
19:21:55 <BlackM> FunctorSalad: \o/
19:22:16 <FunctorSalad> applicative: I meant myself
19:22:42 <FunctorSalad> warnings against 'head' were the topic in #xmonad, but I didn't want to further confuse the haskell intro
19:23:43 <applicative> i see, i thought you were just spreading awareness that head = foldr const undefined
19:24:12 <copumpkin> > head []
19:24:13 <lambdabot>   *Exception: Prelude.head: empty list
19:24:26 <FunctorSalad> modulo error message :p
19:24:26 <copumpkin> > foldr const (error "Prelude.head: empty list") []
19:24:28 <lambdabot>   *Exception: Prelude.head: empty list
19:24:55 <applicative> but which error is it???
19:25:20 <FunctorSalad> I thought all errors, undefined, and nontermination were all equal from the backing-theory's point of view
19:25:27 <copumpkin> nice, I can define empty data instances
19:25:33 <FunctorSalad> someone said something about them not being so in IO though
19:25:48 <applicative> > foldr const (error "Prelude.head: HAHAHAHAHA") []
19:25:49 <lambdabot>   *Exception: Prelude.head: HAHAHAHAHA
19:25:59 <FunctorSalad> since exception handling in IO is outside the realm of type theory...
19:26:34 <FunctorSalad> (at least in the IO == unpredictable view)
19:27:00 <applicative> > foldr const (head []) []
19:27:01 <lambdabot>   *Exception: Prelude.head: empty list
19:27:09 <napping> you can abstract them all to _|_ if you like, but the imprecise exception semantics is more interesting
19:28:13 <napping> You allow sets of possible exceptions as values, and claim IO makes a nondeterministic choice in catch
19:28:23 <applicative> FunctorSalad, no, I see my question rested on a confusion;  I thought there were two ways the interpreter could hit bottom
19:28:44 <gwern> applicative: drugs and women?
19:29:09 <gwern> as a rothschild once said, "There are 3 roads to ruin: gambling, women &mdash; and engineers. The 1<sup>st</sup> 2 are more pleasant, but the last is the most certain."
19:29:09 <applicative> > foldr const (error "Prelude foldr const error") (error "empty list")
19:29:10 <lambdabot>   *Exception: empty list
19:30:26 <applicative> > foldr (error "no function")  (error "Nothing to start from ") (error "Nowhere to go)
19:30:27 <lambdabot>   <no location info>:
19:30:27 <lambdabot>      lexical error in string/character literal at end o...
19:30:36 <BlackM> > (\xs -> null xs ? 0 ?: length xs) [0..4]
19:30:37 <lambdabot>   5
19:30:44 * BlackM wins!
19:31:12 <applicative> > foldr (error "no function")  (error "Nothing to start from ") (error "Nowhere to go")
19:31:13 <lambdabot>   *Exception: Nowhere to go
19:32:04 <gwern> you know, that's almost a haiku
19:32:17 <FunctorSalad> "engineers" is a bit unclear
19:32:26 <FunctorSalad> but since he was wealthy I assume "employing engineers"
19:32:30 <gwern> FunctorSalad: he meant railroad engineers
19:32:52 <gwern> FunctorSalad: this was in the context of the 1800s, where the second british railroad bubble was still on peoples' minds
19:33:20 <BlackM>  > foldr (error "There is no function here;")  (error "Nothing to start working from, ") (error "Nowhere left to go.")
19:33:21 <FunctorSalad> gwern: hmm that's a total gap in my knowledge
19:33:41 * BlackM wins AGAIN!
19:34:00 <gwern> FunctorSalad: the first railraod bubble, incidentally, is argued over - because it was profitable and largely not wasted, does it really count as a bubble?
19:34:14 * BlackM flags himself for excessive syllables - awww.....
19:34:52 <tensorpudding> Railroads were when it all started going downhill.
19:35:04 <BlackM> > foldr (error "This is no function;")  (error "Nothing to start working from, ") (error "Nowhere left to go.") -- much better!
19:35:05 <lambdabot>   *Exception: Nowhere left to go.
19:35:24 <applicative> Yep, that's when the rot set in.  Then Haskell was defined.
19:36:01 <FunctorSalad> tensorpudding: ??
19:36:47 <tensorpudding> Eh, maybe it was already bad before that.
19:36:50 <FunctorSalad> not sure which negative consequence you're thinking of, but things weren't so great before them either :O
19:36:56 <FunctorSalad> mhm
19:36:57 * applicative wonders when someone will arrive with an elementary Haskell 98 type error, so he can do his good deed for the day.
19:37:21 <EvanR> > length 'a'
19:37:22 <lambdabot>   Couldn't match expected type `[a]'
19:37:22 <lambdabot>         against inferred type `GHC.Types...
19:38:01 <FunctorSalad> (I'm told that people only put up with the horrible conditions in industry because it was even worse in the country... but I'm not an expert in any way on this)
19:38:15 <gwern> FunctorSalad: if you are interested, you may like http://www.dtc.umn.edu/~odlyzko/doc/hallucinations.pdf
19:38:19 <applicative> well, EvanR, you see 'a' isn't a list type, what would it be a list of?  Its a character.
19:38:30 <tensorpudding> Railroads were big one step in the expansion of the USA
19:38:36 <napping> This seems to work: pandoc -H lhs2tex.inc -r rst+lhs -w latex+lhs
19:39:02 <gwern> FunctorSalad: at least, I thought it was a very interesting read. you may not
19:39:05 <napping> where lhs2tex.inc just has the line %include lhs2TeX.fmt
19:39:06 <EvanR> applicative: there you go then
19:39:09 <tensorpudding> also the creation of sprawl
19:39:21 <applicative> EvanR, but I say you using runCont above so I don't think I've done my good deed yet
19:39:28 <EvanR> lol
19:39:42 <applicative> napping, really
19:40:09 <gwern> how did Hitchiker's go? 'In the beginning, the universe was created. this has been roundly criticized ever since.'
19:40:11 <leejr> Cale,  I've started the sets book.  it's telling me things I figured out for myself.  I love it!
19:40:53 <FunctorSalad> gwern: thanks, maybe too advanced with my lack of economic prerequisite knowledge though
19:40:53 <applicative> napping, good news, I hope the details work out.
19:41:21 <p_l> gwern: given that it was a universe were watching its death was a common practice...
19:41:49 <gwern> FunctorSalad: I didn't think it was advanced; it's all qualitative; few people know anything about the railraod bubbles so the paper/book takes pains to explain everything
19:42:50 <applicative> leejr, what sets book are you reading
19:43:11 <gwern> he's dead, Jim.
19:43:16 <tensorpudding> v-ger?
19:43:19 <aavogt> gwern: what are these railraods?
19:43:30 <gwern> aavogt: they're like railroads, but less so
19:43:41 <aavogt> so much more bubbly?
19:43:44 <gwern> they're kind of like - furi-kuri if you know what I mean
19:43:46 <iaefai> Is there a built in method for doing a delay in IO? I am doing a quick test of my editor and need to have some method of delaying between putStrLn in an infinite loop.
19:43:54 * gwern makes fooly-cooly gestures with vis hands
19:43:57 <applicative> aavogt, there was a railraod bubble, thats why we don't hear about them so much
19:43:59 <FunctorSalad> iaefai: threadDelay?
19:44:11 <FunctorSalad> or threadSleep dunno
19:44:15 <aavogt> because it happened a long time ago
19:44:18 <gwern> @hoogle threadDelay
19:44:18 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
19:44:38 <gwern> aavogt: and as we all know, the past holds no lessons for us. how could anything that happened in the 1800s to white people matter?
19:44:55 <iaefai> might work, thank you
19:45:00 <applicative> how long does threadDelay 17  delay the thread
19:45:01 <napping> applicative: It's a very simple document, but the resulting tex is suitable for lhs2TeX
19:45:05 <iaefai> It just needs to be able to work with runhaskell
19:45:09 <gwern> applicative: 17 milliseconds iirc
19:45:48 <gwern> pretty sure the Int isn't microseconds
19:46:11 <applicative> napping, cool.   pandoc will also highlight your html when you post it on your blog
19:46:18 <FunctorSalad> gwern: micros
19:46:28 <gwern> noooo
19:46:28 <napping> applicative: The fancy lhs2TeX alignment stuff seems to work, at least
19:46:29 <FunctorSalad> at least on that order
19:46:39 <FunctorSalad> (tried with 10^6)
19:46:45 <gwern> FunctorSalad: well, there's only an order between milli and micro?
19:47:26 * BlackM hauls a Cosmic Stratocaster from HammerSpace(TM) and smashes gwern's face with it!
19:47:56 <applicative> gwern, this is what Haskell gets for not having type-imposed measures like F#
19:48:02 <FunctorSalad> gwern: three as they are usually understood, no? anyway, I'm not high enough to be unable to tell 0.1s or 10s from 1s, but strictly speaking I haven't excluded the possibility that it's some furlong-based unit which is roughly 1.2s etc
19:48:33 <aavogt> three orders, gwern
19:48:53 <gwern> shut up. I'm developmentally-disabled - I grew up in the US under the imperial system
19:49:03 <gwern> applicative: I can't disagree with that. f# does benefit in some ways from being so new
19:49:09 <EvanR> i started real world haskell. and it keeps talking about functions with side effect i.e. 'impure' functions, no, not unsafePerformIO, just anything which returns IO a
19:49:13 <EvanR> very confused
19:49:25 <kmc> yeah that's annoying incorrect terminology
19:49:39 <kmc> applying a Haskell function never has a side effect
19:49:42 <kmc> unless you cheat
19:50:06 <applicative> > putString "Side effect"
19:50:07 <lambdabot>   Not in scope: `putString'
19:50:08 <kmc> it's misleading and wrong to say that "IO" is a type-level separation between pure and impure functions
19:50:16 <applicative> > putStrLn "Side effect"
19:50:16 <gwern> BlackM: you think you're so clever; I'll bet you've never watched _Gunbuster_
19:50:17 <lambdabot>   <IO ()>
19:50:20 <EvanR> maybe the real explanation is too above python programmers, which this seems to be directed at
19:50:33 <applicative> kmc, didn't I apply a function to an argument
19:50:39 <kmc> applicative, yeah
19:50:45 <kmc> you got an IO action back
19:50:50 <EvanR> today i tried to explain the >>= thing, but got a puzzled look
19:51:00 <gwern> @quote Neo
19:51:00 <FunctorSalad> programmable semicolon
19:51:00 <lambdabot> gwern says: Unfortunately Neo, no one can be *told* what the Monad is.
19:51:04 * BlackM pays off gwern's bet
19:51:07 <kmc> the IO action is a value deteremined deterministically and without side effect from the input
19:51:09 <EvanR> FunctorSalad: haha
19:51:16 <FunctorSalad> best attempt if you only have three seconds I'd say
19:51:17 <FunctorSalad> ;)
19:51:17 <kmc> you can execute the action later, or not
19:51:28 <BlackM> gwern: That is correct, sir.
19:51:46 <gwern> BlackM: well, you should. gainax is more than just eva & flcl & gurren lagann
19:51:47 <kmc> i think it's not too hard to explain what a first-class action is
19:52:29 <BlackM> gwern: Well, sure...it's GAINAX!!!
19:53:04 <gwern> I did a marathon session a few days ago of Gunbuster & Diebuster. pretty sweet
19:53:04 <napping> EvanR: ever tried the diagrams from ttt?
19:53:10 <EvanR> maybe RWH will correct itself later, but none of the webcomments are
19:53:11 <applicative> kmc, but couldn't you say 'side effects are first class values; of course you have to execute a side effect for anything to happen.' or something like that
19:53:15 <gwern> less insight than I expected into Eva, though
19:53:28 <kmc> yeah
19:53:29 <EvanR> napping: ttt??
19:53:31 <kmc> i do say that, all the time
19:53:34 <applicative> kmc, do you think "IO a " is misnamed
19:53:39 <kmc> no
19:53:45 <kmc> did i say it was
19:53:51 <kmc> i said "impure functions" were misnamed
19:54:04 <kmc> unless you mean some low level GHC stuff that's usually hidden
19:54:09 <EvanR> the author specifically says 'functions that cause side effects'
19:54:12 <kmc> and which *doesn't* have a type distinct from pure functions
19:54:14 <napping> EvanR: "Toposes, Triples and Theories"
19:54:17 <kmc> EvanR, :(
19:54:24 <kmc> the authors of RWH are smart dudes
19:54:25 <EvanR> and calls them impure
19:54:28 <kmc> so i'm sure they had a good reason
19:54:30 <napping> EvanR: a category theory book that at least used to be linked from the reference page
19:54:35 <kmc> but i'd generally object
19:54:36 <copumpkin> omg ttt in #haskell
19:54:38 <copumpkin> who would've thought
19:54:43 <napping> EvanR: the Monad chapter starts with some pretty commutativity diagrams
19:54:49 <EvanR> napping: gonna have to check that
19:54:57 <applicative> kmc, i see, it is the combination with the word "function".  they only map around in the space of Values; then some of those values can be executed.
19:55:05 <kmc> yeah
19:55:14 <kmc> just like the string "send an email to the pope" could be executed
19:55:20 <kmc> (by a human)
19:55:31 <kmc> sendEmail :: String -> String; sendEmail x = "send an email to " ++ x
19:55:36 <kmc> not an impure function ;)
19:55:37 <applicative> kmc, but the function never takes you to the execution; at best to something executable, thus putStrLn "Hello"
19:55:40 <Berengal> I use "impure function", but only as an abreviation
19:55:40 <copumpkin> EvanR: you learning category theory?
19:55:48 <Berengal> I use "action" when it's not a function
19:55:53 <copumpkin> EvanR: because TTT isn't an "intro" book
19:56:06 <napping> You certainly avoid misleading analogies that way :)
19:56:07 <EvanR> no
19:56:17 <EvanR> just reading the basics of haskell again
19:56:20 <copumpkin> oh ok
19:56:34 <applicative> \me thought, for a second, that EvanR was calling the authors of RWH 'impure'
19:56:35 <EvanR> i learned that in ghci you can do :set +t or something, but thats about it
19:56:41 * applicative thought, for a second, that EvanR was calling the authors of RWH 'impure'
19:56:57 <aavogt> aren't they?
19:57:00 <Berengal> applicative: I'd hope they wash regularly, but I don't really care that much.
19:57:17 <gwern> @quote chanting
19:57:18 <lambdabot> Berengal says: '"Go away! You're not like us!" the other values yelled. "You're impure! Impure! Impure! Impure!" they started chanting.'
19:57:20 <aavogt> they did enough IO to at least write that book after all
19:58:17 <napping> Sad, looks like pandoc kills the |inline code| bars
19:58:17 <FunctorSalad> I liked copumpkin's (? iirc) exposition as "evaluation vs execution"
19:58:23 <EvanR> and then theres conal's blog, which heretically questions haskells pure IO system
19:58:24 <FunctorSalad> that's something positive
19:58:29 <copumpkin> FunctorSalad: probably not me, I don't do good stuff
19:58:32 <FunctorSalad> instead of "there are no impure functions but ..."
19:58:48 * BlackM cringes in expectation of an "In Soviet Russia,..." joke
19:59:27 <FunctorSalad> then you can say that "->" is always only talking about evaluation...
19:59:27 <gwern> there is no impure function but unsafePerformIO and Conal is its prophet
19:59:30 <conal> EvanR: i prefer peter landin's term "denotative", which he recommended as a replacement for "functional".
19:59:32 <gwern> that better
19:59:51 <FunctorSalad> whereas execution happens by starting from main and moving through the chain of >>='s
19:59:55 <conal> gwern: :)
20:00:07 <Berengal> FunctorSalad: You can even say that Haskell only ever does evaluation. Any eventual execution is done by an outside system (aka. runtime)
20:00:12 <FunctorSalad> (of the particular ones in the IO monad and bound to main)
20:00:17 <conal> in a sense, all of haskell except IO is build out of unsafePerformIO
20:00:26 <EvanR> yes
20:00:28 <FunctorSalad> Berengal: yes, like that
20:01:25 <applicative> conal, what is the explanation of this paradox:  in a sense, all of haskell except IO is built out of unsafePerformIO
20:01:31 <FunctorSalad> copumpkin: thought you had written about it on reddit
20:01:42 <kmc> hehe
20:01:43 <copumpkin> FunctorSalad: possibly! I am forgetful
20:02:28 <Berengal> I seem to remember the "evaluation vs execution" explanation being born during a particularly populated discussion with a newbie
20:03:08 <Berengal> It went through several stages, with terms like "open models", "unicorns", "recipies" and "cake"
20:03:15 <FunctorSalad> :)
20:03:23 <conal> applicative: basic ops like addition use machine instructions, and are therefore potentially effectful (like any FFI import).  the compiler & library implementors have taken responsibility for the proof obligation that these ops are indeed purely functional.  which is exactly the meaning of unsafePerformIO.
20:03:42 <conal> applicative: the only exceptions are the ops/imports are are of type IO
20:04:30 <applicative> conal, right, i think i was getting  this.
20:04:37 <Berengal> conal: To be fair, that isn't Haskell. That's a Haskell _implementation_
20:04:41 <BlackM> "unsafePerformIO" is the antithesis until Haskell produces the Synthesis of the Comonadic Dialectic! Or, something like that... :)
20:05:05 <conal> Berengal: or a haskell library implementation.  could call it either.
20:05:39 <conal> e.g., whether Int is part of the language or the implementation.
20:05:51 <conal> oops -- i mean the language or library
20:06:03 <FunctorSalad> hmm the language? thought the formalization never finished
20:06:06 <FunctorSalad> I might be wrong
20:06:13 <Berengal> conal: Indeed. The point is the language doesn't specify that you have to use unsafePerformIO to do stuff. It just gives you the denotational semantics
20:06:30 <FunctorSalad> (maybe demanding formal semantics is too much)
20:06:33 * BlackM hadn't noticed the formalisms ever starting, frankly...
20:07:14 <napping> If only there were better tools for discharging such obligations. Ynot is promising.
20:07:14 <Berengal> FunctorSalad: It's finished for some given value of finished less than 100%
20:07:28 <EvanR> finished formalization, sounds profoundly like human complementarity process or something ;)
20:07:52 <conal> my point is that we use something built from the equivalent to unsafePIO whenever we use non-IO types in haskell.
20:08:20 <conal> and i don't insist that others look at it this way.  just an invitation to entertain another perspective.
20:08:51 <applicative> conal, but it was sounding like any implementation of a pure / functional / denotative language would have to do something like this; the implementation would involve the massive proof obligation, etc.
20:09:04 <Berengal> My brain doesn't use unsafePerformIO when it's evaluating Haskell programs...
20:09:31 <applicative> Berengal, mine neither, the neurons just won't fire when I tell them to.
20:09:33 <EvanR> unsafePerformIO isBigBrotherReal
20:09:38 <conal> applicative: could be true, but that'd be a much bolder claim than i was making.
20:10:16 <napping> conal: I think you are conveying your meaning clearly enough, but unsafePerformIO might be emphasizing the wrong thing - or perhaps not
20:10:21 <FunctorSalad> EvanR: wait I think that's off but I can't remember the term either
20:10:30 <FunctorSalad> instrumentality
20:10:30 <FunctorSalad> ?
20:10:37 <EvanR> yeah, in english they use both
20:10:42 <EvanR> to mean the same thing
20:11:05 <napping> the thing with unsafePerformIO is it lets you get away with mutation without necessarily having a proof
20:11:29 <conal> napping: yes.  so does being a language implementor.
20:11:43 <conal> and giving a "pure" annotation to an ffi decl.
20:11:45 <napping> yes, that's why it is perhaps more correct
20:11:53 <conal> ?
20:12:20 <napping> The "interesting" thing about unsafePerformIO is that you can use it to break referential transparency
20:12:31 <BMeph_> conal: Have you ever run into Rafael Levien's Io programming language? :)
20:12:39 <Cale> You can also use it to break the type system entirely
20:12:45 <napping> the surprising thing about Haskell implementations is that they seem to (more or less) provide you with a faithful implementation of denotational semantics
20:13:03 <FunctorSalad> Cale: with IORefs but I don't really get why
20:13:09 <conal> i like the perspective that unsafePIO is a tool for language extension.  i think simon pj described it as such in "stretching the storage manager".
20:13:09 <napping> But, I guess they haven't offered complete proofs they get it right either.
20:13:20 <conal> BMeph_: no.
20:13:48 <Cale> FunctorSalad: yes, because you can create an IORef which is completely polymorphic, set it with a value of one type, and then read it back as a value of another.
20:13:51 <napping> I like runST
20:13:57 <conal> napping: exactly.  that's what i was saying.  consider unsafePIO as a language implementor/extender tool
20:14:27 <EvanR> isnt unsafeCoerce an easier way to do that IORef trick
20:14:30 <FunctorSalad> napping: there is this issue of some supposed equalities only working if you ignore certain corner cases which are due to const undefined being unequal to undefined
20:14:53 <FunctorSalad> napping: there is the "moral equivalence" paper which is nice, but didn't cover all of haskell I think
20:14:56 <napping> In a language with more explicit proving around, you might imagine having something like "safePerformIO" which actually requires a proof
20:15:04 <Draconx> EvanR, yes.
20:15:05 <Cale> unsafeCoerce x = unsafePerformIO (do writeIORef r x; readIORef r) where r = unsafePerformIO (newIORef undefined)
20:15:15 <napping> FunctorSalad: Isn't that just evidence you have a const _|_ distinct from _|_ in your semantics?
20:16:02 <napping> FunctorSalad: It's not an implementation of the nicest categorical stuff, but I think you can still come up with a perfectly respectable denotational model
20:16:19 <FunctorSalad> napping: maybe accepting that would complicate things a lot, "domain theory for beginners" (all I know) uses pointwise function spaces after all
20:16:32 <FunctorSalad> pointwisely ordered, that is
20:16:42 <FunctorSalad> which quite simplifies things
20:16:47 <Berengal> napping: runST is sort of like a safePerformIO, and the proof is in the types.
20:17:11 <napping> It's a quite limited case.
20:17:20 <conal> napping: yes! (safePIO)
20:17:32 <FunctorSalad> napping: so an interesting alternative solution is to force the two to be the same under some equivalence
20:17:42 <FunctorSalad> (like that 'moral equivalence')
20:18:17 <conal> runST handles one special case.  unsafePIO catches the rest, but unsafely.  i'd like to see lots of exploration in the safe space beyond runST.
20:18:24 <conal> does anyone know of any research after the runST paper?
20:18:35 <napping> FunctorSalad: I think that may come down to losening some identities in a cartesian closed category to isomorphism, or something like that
20:18:58 <EvanR> youre all nuts. the machine has finite memory, the system cant be proven safe
20:19:03 <conal> (for type-ensured safe wrapping of imperative computation into purely functional?)
20:19:23 <napping> conal: What sort of research? There's Oleg's static capability stuff for leveraging types to at least localize your proof obligations
20:19:34 <aavogt> EvanR: so that allows proof by exhaustion :)
20:19:47 <napping> and on the other hand there's the body of work not explicitly connected to runST on foundational semantics
20:20:47 <napping> If you did a verified Haskell implementation like Xavier's C you would probably end up with some invariants on the imperative bits, and then  you might imagine admitting any string of machine instructions that could be proved to respect those invariants
20:21:01 <FunctorSalad> napping: (I'm mostly thinking by analogy to analysis here that pointwise convergence is far simpler than various kinds of uniform convergence)
20:21:08 <FunctorSalad> maybe that's to broad an analogy :)
20:21:09 <napping> I don't think the state of the art is quite up for it yet.
20:21:10 <FunctorSalad> *too
20:21:33 <FunctorSalad> (but at least they can both be expressed topologically ;))
20:21:44 <napping> Incidentally, I just re-read the "very modal model" paper from Appel et. al, and the math at least is pretty nice
20:22:53 <napping> conal, it seems like the sort of thing you might like. Very semantic, though it doesn't seem to support strong update, but that might be cured by liberalizing their choice of worlds
20:23:24 <conal> napping: thx!
20:24:25 <napping> FunctorSalad: I don't see what that has to do with it. Your function space gets a _|_ just because stuff is pointed, and then above that you have all the continous functions between the spaces you are interested in, ordered pointwise
20:24:41 <applicative> what is a good elementary example of the use of unsafePerformIO in one of the libraries?
20:24:47 <napping> you might like it if const _|_ was actually the same as _|_, but I don't see it actually breaks anything
20:25:08 <napping> applicative: perhaps the unique source in Data.Unique?
20:25:21 <FunctorSalad> napping: are you saying that you just sacrifice antisymmetry?
20:25:27 * applicative confesses he has never used 'unsafePerformIO'
20:25:37 <FunctorSalad> pointwise order implies that const _|_ = _|_
20:25:48 <FunctorSalad> (with antisymmetry)
20:25:59 <c_wraith> Every once in a while I want to use unsafePerformIO.  Then I realize it's wrong for my case, and sigh in relief.
20:26:10 <napping> applicative: It's probably just the "var = unsafePerformIO (newIORef 0)" for a global var for a counter
20:26:52 <FunctorSalad> napping: but is it just a single "exception" for higher-order function spaces?
20:26:57 <napping> FunctorSalad: I meant pointwise order on all the other functions.
20:27:29 <Cale> applicative: Typically unsafePerformIO is used to implement low-level datastructures which have pure interfaces.
20:27:38 <c_wraith> I do wish there was a convention for IO actions at startup, with their results bound to top-level names.  That's something unsafePerformIO is sometimes used for, but it has lots of gotchas when you use it that way.
20:28:08 <Cale> c_wraith: I rather wish people would just not do that at all.
20:28:11 <EvanR> napping c_wraith just today we wanted to replace the 'constant' configuration values in the program with a config file
20:28:14 <FunctorSalad> napping: or maybe the "const _|_ /= _|_" problem isn't all there is to the seq-and-functions problem... that was just my summarization
20:28:25 <EvanR> you can just unsafePerformIO to decode the config file and make global names
20:28:35 <EvanR> but instead we ReaderT'd the entire bitch
20:28:41 <EvanR> that was fun
20:28:45 <Cale> Well, okay, config files are a bit less evil than the top-level IORef.
20:28:48 <c_wraith> That's the main case where it'd so attractive...  loading config files at startup
20:28:58 <c_wraith> err, *it's
20:29:03 <FunctorSalad> Cale: they are?
20:29:07 <napping> That seems like a bit much to be doing automatically at startup
20:29:18 <Cale> FunctorSalad: Well, they're only loaded once per program run
20:29:18 <Berengal> So far I've been perfectly happy with just slapping a ReaderT on and call it a day. No need for global IORefs
20:29:28 <Cale> FunctorSalad: (assuming that they are)
20:29:30 <napping> Tracing paths and stuff to find the config, in some half initialized world where you might have rouble reporting an error
20:29:32 <FunctorSalad> Cale: ok, if "config" means that :)
20:29:50 <Cale> So at least it's like you're running a well-behaved, but different program every time.
20:29:55 <EvanR> Berengal: heh. well liftIO everywhere, and the ReaderT on my Rand was a head explode :(
20:30:05 <Cale> I prefer the XMonad-style configuration for that though.
20:30:11 <FunctorSalad> files are also still better as global state than the environment btw ;-)
20:30:35 <Cale> Just make the program be its own configuration. :)
20:30:39 <FunctorSalad> or I'm just not good at it... but it's hard to track down all the points where it changes
20:30:44 <c_wraith> I went with a different approach in the end...
20:30:55 <EvanR> Cale: yeah but then we have to recompile when we change the config
20:30:56 <FunctorSalad> (the unix variables env, I mean)
20:30:59 <applicative> Cale, I think I grasped that, abstractly, but what Conal was saying inclined me to look into it, so I asked for an elementary example to reflect on.
20:31:01 <napping> I don't see any way to get Pandoc pass |code| out as TeX unchanged
20:31:10 <Cale> EvanR: Yeah, but that can also be automated handily enough :)
20:31:15 <napping> applicative: oh, then I gave you a completely misleading suggestion
20:31:15 <c_wraith> Since I had more static resources than user-level config files, I compiled them in with TH.
20:31:33 <EvanR> Cale: even more automatic is reading a config file when run
20:31:44 <Berengal> EvanR: It can cause some irritation at first, but I usually find that I'm not really inside my MainApplicationMonad very much anyway. I often go "ask >>= runSomeOtherMonad . someActionTakingConf"
20:31:49 <napping> applicative: Statically allocating an IORef cell is pretty safe, but very touchy and a little different.
20:32:13 <sm> speaking of pandoc.. it doesn't support --toc with restructured text, or does it ?
20:32:15 <EvanR> Berengal: yes
20:32:24 <Cale> Generally, I think unsafePerformIO should be used with the same sort of gravity that one would take in modifying one's compiler.
20:32:27 <applicative> sm, it should
20:32:40 <napping> maybe DiffArray? I'm not sure how tricky it is inside, but it is certainly providing an imperative implementation of a pure structure
20:32:44 <sm> I see it hyperlinks all the headings, but no table of contents appears
20:33:08 <EvanR> DiffArray could be pretty cool
20:33:09 <applicative> sm, what do the hyperlinks link
20:33:14 <sm> to #TOC
20:33:17 <napping> sm, are you using rst as output?
20:33:21 <Cale> Make *really* sure that you need it before you go using it, and even then, make sure you're really sure you know what the compiler is going to do with it.
20:33:26 <Berengal> Cale: In general, yes, but there are specific cases where that's not true (FFI, for one)
20:33:27 <sm> no, I'm rendering rst as html
20:33:27 <c_wraith> DiffArray would be cool if it wasn't bafflingly slow.
20:33:28 <applicative> sm, which doesn't exist?  hmm
20:33:31 <sm> right
20:33:39 <applicative> sm, did you specify as standalone document?
20:33:59 <napping> sm: There's your problem. toc support is controlled by the output format. That said, I'm not sure if it makes tocs in html
20:34:06 <sm> probably not.. I'm using hakyll
20:34:15 <sm> thanks for the tip
20:34:22 <Cale> Berengal: Well, even with FFI, I'd imagine you can get bit pretty hard if you're not sure that the C functions you're calling really are pure.
20:34:27 <applicative> napping it certainly does, from markdown, but i'm confused by the rst claim
20:34:35 <napping> "This option has no effect with man, docbook, or s5 output formats."
20:34:49 <napping> so, sounds like it should
20:35:44 <Berengal> Cale: Yes, you still have to prove to yourself that it's safe to do, but you don't have to go into full "this is just as hacky as extending the compiler" mode.
20:35:56 <FunctorSalad> Berengal: / Cale: how remote exception cases do you take into account? ;)
20:36:19 <FunctorSalad> (is "tail" pure? what if there's some basic system failure...)
20:36:46 <c_wraith> that's an operational detail.  semantically, it's pure. :)
20:36:47 <napping> conal: the main trick in the paper seems to be the use of step-indexing so they can keep a simple set-theoretic semantics, and then the "later" modality so you don't often have to deal directly with steps
20:36:48 <Axman6> well, it calls error, so not really imo
20:36:53 <FunctorSalad> (against which haskell functions aren't immune either)
20:36:57 <FunctorSalad> c_wraith: mhm
20:37:06 <Berengal> Axman6: error is pure.
20:37:20 <c_wraith> pure doesn't mean total
20:37:29 <napping> FunctorSalad: system failure seems to fall more on the guarantees of your implementation than on the language semantics
20:38:39 <napping> Imaginary Haskell Semantics says tail does such and such pure thing, Specified Haskell Implementation promises to evaluate programs to the result demanted by the semantics unless a number of enumerated errors such as out of memory or multiple bit flips occur
20:39:08 <FunctorSalad> napping: yeah but I mean it seems to be a judgment call what is semantics and what implementation in the foreign code (C)
20:39:22 <napping> not if you had a language semantics
20:39:44 <FunctorSalad> even if C has one, wouldn't you need one for the whole library?
20:39:53 <FunctorSalad> maybe I'm confused there...
20:40:26 <napping> sm: seems you need -s
20:40:39 <sm> napping: thanks!
20:40:40 <FunctorSalad> well, I didn't mean things quite as absurd as bit flips, but for example writing to a log file, or process accounting
20:40:43 <napping> (or a template with a reference to $toc)
20:41:06 <FunctorSalad> (logging if the file is monitored by inotify or whatever)
20:41:10 <sm> I need to get hakyll & pandoc to be just a bit more flexible
20:41:19 <napping> Well, that's more cheating with unsafePerformIO
20:41:23 <FunctorSalad> (these are side effects)
20:41:34 <napping> not something that is actually valid
20:41:45 <Berengal> FunctorSalad: The language specifies that functions are pure, and so you should make sure that any functions you do expose through FFI *are* pure. If they have internal state, you must make sure that that state absolutely cannot leak through any interface.
20:41:58 <FunctorSalad> (ok, the file thing is a bad example since 'tail' can only hope to be pure when operating on strings)
20:42:04 <napping> In a more perfect language such a function would have to be typed as possibly doing logging
20:42:40 <jmcarthur> does stream fusion kill sharing?
20:42:54 <applicative> sm, yeah i get a table with -s only, which fits with the intention.
20:43:23 <napping> and then you might have some nice way to say that you don't care about logging, and then get to use it in your pure(ish) code (and the annotation on tail would have to say it's safe to call lazily despite side effecting)
20:43:32 <FunctorSalad> Berengal: hmm. Is it a "leak" if the side effects (say, execution of 'tail' being logged) are observable from a later IO action? (readFile log)
20:43:45 <applicative> sm, otherwise i just get links to #TOC which fits with the idea that in the default case, pandoc is producing fragments, sections and so forth.
20:43:49 <FunctorSalad> Berengal: it isn't if IO is considered random, I suppose
20:44:19 <c_wraith> You have to treat lazy IO as a type of concurrency
20:44:34 <FunctorSalad> ISTR there was a similar discussion concerning whether lazy IO enables side effects in pure code
20:44:38 <napping> jmcarthur: that depends. The fusion goes end to end from a producer to consumer.
20:44:42 <Berengal> FunctorSalad: IMO yes.
20:45:06 <napping> it might decide to fuse up to the production of the shared list, and then fuse from there to the consumers, or might do something else
20:45:39 <napping> Also, there's that stuff about projection thunks (wrong name?), but that probably doesn't matter here
20:45:57 <applicative> sm, what flexibility are you missing in pandoc?
20:46:15 <FunctorSalad> (the side effects that lazy IO has on file handles etc would only be observable through later IO actions, AIUI)
20:46:49 <sm> applicative: if I can remember, I'll let you know
20:46:55 <sm> nothing coming right now
20:48:29 <applicative> sm, pandoc hacking is the one thing i'm semi-competent at... ha
20:49:08 <copumpkin> applicative: are you john mcfarlane?
20:49:09 <napping> applicative: I'd like some way to get paired | passed through to latex+lhs output, so I can use them for lhs2TeX inline code
20:49:11 <copumpkin> mac
20:49:21 <napping> or some way to produce them
20:49:48 <jmcarthur> napping: say i have a value that i am pretty sure would be better off shared. should i mark it NOINLINE or something?
20:50:03 <sm> applicative: good to know! :)
20:50:07 <applicative> copumpkin, I wish
20:50:09 <FunctorSalad> Berengal: but that'd seem to make for a pretty impossible standard :) for unsafeIO'ing ffi calls
20:50:18 <FunctorSalad> Berengal: if I understood your 'yes' correctly
20:50:20 <napping> That sounds right, but I haven't tried to do that. You can always check the core
20:50:32 <jmcarthur> alright. thanks
20:50:37 <Berengal> FunctorSalad: It does, but fortunately I'm full of double standards.
20:50:38 <FunctorSalad> (that side-effects only observable through IO are side effects too)
20:50:45 <sm> I have unfinished code to go in to it (moinmoin reader), but the test suite is painful
20:50:51 <FunctorSalad> Berengal: ;)
20:51:27 <napping> selector thunks, that was the name
20:51:47 <napping> Is unzip actually an efficient way to lazily produce a pair of lists?
20:52:20 <Berengal> Anyway, there are worse things than unrestricted IO. After all, most programming is done in languages with no concept of pure vs impure computation, and they still seem to work after a sort.
20:52:44 <Berengal> (Lazyness complicates things a bit though)
20:53:24 <napping> Not quite, it seems you'll hang onto the wrong component of pairs for too long
20:54:19 <napping> Wait, that's only if unzip ls were actually (map fst ls, map snd ls)
20:54:32 <napping> I guess the selectors probably do fix it.
20:58:20 * BMeph_ notices that codolio is here, and goes to take some deine, to stay awake better...
20:59:07 <FunctorSalad> BMeph_: :p
20:59:09 <napping> applicative: Is there any way to get those raw || in the pandoc latex+lhs output?
21:02:35 <augur> well i guess i dont have to feel bad now about my shitty client app e.e
21:05:58 <JoeyA> > do {i <- [1..3]; j <- [1..i]; return (i,j);}\
21:05:58 <applicative> napping, it came to me that the | is generally just passed along like a letter in pandoc markdown, does ReST reserve | for something?
21:06:27 <napping> I think the problem is more that | is a math character in latex, so it gets escaped on output
21:07:06 <JoeyA> Hmm, I wonder where lambdabot went.
21:07:08 <applicative> napping, right, I was experimenting with html; hadn't looked at latex output
21:07:17 <napping> and it seems like there is not a lot of fine control over the output
21:07:33 <napping> you can do tons of things with format directives in lhs2TeX
21:08:26 <napping> I don't see any similar sort of function definition in the pandoc template definition
21:09:00 <napping> I could try to make a latex+lhs2tex style, but it's a pain to keep local forks
21:10:10 <applicative> napping, yes I see, a | goes to | in html, but to \textbar{} in latex
21:10:55 <napping> yep. I've considered trying to define \textbar{}, but I don't think I could get to it early enough for the lhs2TeX lexer to see it, unless I added another pass
21:11:36 <napping> Wait, I'm going about this the wrong way. Does ReST have syntax for inline code?
21:13:49 <Gracenotes> @hoogle splitExtension
21:14:51 <napping> does pandoc support custom roles?
21:16:08 <napping> well, ``text`` goes to verb at least
21:18:35 <applicative> napping, this is crazy, but you could strike the line that escapes | in the Text.Pandoc.Writers.Latex module  line 107 and recompile
21:18:37 <applicative> http://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Writers/LaTeX.hs
21:19:59 <napping> Sounds like a quick solution. Where's the interchange format defined?
21:20:26 <applicative> napping, I think this might be worth writing to the list about.  I think this hasn't come up.
21:20:53 <napping> If you've got a notion of inline code elements it should be easy enough to recognize a custom interpreted text role in the ReST
21:23:53 <napping> Aha, data Inline = ... | Code String
21:25:08 <applicative> napping its just that the inline code constructor doesn't have room for a language to be specified, as it does for a code block
21:25:31 <napping> hmm, that's not quite. It seems that you always consider a `` inline in ReST as code, when it's just documented as verbatim
21:26:18 <napping> oh, I guess Code is the closest there is
21:28:00 <napping> well, that gives an equally quick hack in the LaTeX writer
21:30:07 <edwardk1> preflex: xseen alpounet
21:30:07 <preflex>  alpounet was last seen on freenode/#haskell 9 days, 4 hours, 54 minutes and 23 seconds ago, saying: #lgorithms ? maybe
21:30:28 <edwardk1> heya shapr
21:51:46 <applicative> napping, i have to go, but I can't find any grave danger in just cabal unpack pandoc, then go to src/Text/Pandoc/Writers/Latex, striking line 107 and then cabal install --force-reinstall
22:04:13 <wagle_> why is wagle banned on haskell-in-depth?
22:04:52 <wagle_> freenode is confused
22:05:32 <wagle_> or maybe not
22:11:37 <FunctorSalad> it always reinstalls if you're in the unpacked source dir ;) (pointless nitpick)
22:14:58 <dibblego> wagle, I don't think you are banned in #haskell-in-depth
22:32:48 <wagle> 0519 22:04:35 * 435 wagle #haskell-in-depth Cannot change nickname while banned on channel
22:32:53 <wagle> but i seemed to fix it
22:33:37 <wagle> dibblego: thanks for info, though
22:38:00 <dmead> byorgey, you there?
22:39:21 <dmead> byorgey, i've been a in a starcraft hole for a week... hac phi is on for tomorrow yea?
22:40:06 <edwardk> dmead: it better be or i'll have a wasted ticket to get there ;)
22:40:18 <dmead> :P
22:40:22 <dmead> i'll be there
22:40:28 <dmead> might skip out on tomorrow night though
22:40:33 <edwardk> fun times
22:40:35 <dmead> as the flyers are still in it
22:41:12 <dmead> we're trying to improve cabal right?
22:41:24 <edwardk> i'm mostly going to be hacking on my ad code
22:41:49 <dmead> ad?
22:42:01 <dmead> i've got a theorem prover
22:42:07 <edwardk> i may wind up derailed back into kata again, but i'm hoping to finish up a good mixed-mode automatic differentiation package and maybe bundle up a new version of my rope library
22:42:08 <dmead> and an SQL implementation i could work on
22:42:28 <dmead> ad like advertisement?
22:42:36 <edwardk> ad like automatic differentiation ;)
22:42:39 <dmead> ah
22:42:49 <dmead> yea thats cool
22:42:57 <dmead> i had to write one in a class a few years ago
22:42:57 <edwardk> diff sin x ~ cos x kinda stuff
22:43:08 <dmead> ya
22:43:12 <edwardk> i got a reverse mode ad codebase working in haskell exploiting stablenames
22:43:27 <edwardk> so now i'm implementing tangent-on-reverse, etc so i can do fast hessians
22:43:30 <arcatan> i read rope library as rape library and was very confused
22:43:32 <dmead> do you do algebraic simplification?
22:43:54 <dmead> hessians?
22:43:56 <edwardk> i use observable sharing and only calculate the portion of the jacobian used in the output
22:44:23 <edwardk> dmead: http://hackage.haskell.org/packages/archive/rad/0.1.4/doc/html/Numeric-RAD.html
22:44:59 <edwardk> grad is the vector of partial derivatives of a function, jacobian is the generalization of that to a matrix for functions that return multiple outputs.
22:45:42 <edwardk> the hessian is the square matrix of second partial derivatives of a function with one output or a tensor of m of those square matrices, if the function has m outputs
22:46:13 <dmead> oh you're actually trying to get answers
22:46:24 <dmead> when people say AD i think it's just symbolic
22:46:39 <edwardk> so if you use 'diff' from there diff sin and cos will give the same answer
22:46:47 <dmead> ah
22:46:59 <dmead> i see you worked it into the type system
22:47:15 <edwardk> lots of fun hacks ;)
22:47:56 <edwardk> what i'm doing now is working the jacobian forward or backwards depending on the shape of the function you want to calculate derivatives for, and based on how many derivatives you need
22:48:21 <edwardk> that is proving to be an interesting process of abstraction
22:48:46 <edwardk> since it is somewhat tricky to tease out the code that is common to going both forward or backwards for the derivatives
22:49:19 <dmead> you mean this?
22:49:20 <dmead> http://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant#Jacobian_matrix
22:49:33 <edwardk> yeah
22:50:17 <edwardk> the figures on http://en.wikipedia.org/wiki/Automatic_differentiation might be handy to figure out my ramblings ;)
22:50:32 <edwardk> figure 2 shows forward mode
22:50:47 <edwardk> figure 3 describes how to work backwards to get reverse mode
22:50:59 <edwardk> but to do the operations in figure 3 efficiently you need to observe sharing
22:51:28 <edwardk> or you wind up with a terribly non-idiomatic api, since it would be a pretty crappy Num instance or very slow ;)
22:52:59 <edwardk> each of the nodes in that graph has associated with it a jacobian matrix which is almost the identity matrix. but has one or two off axis entries for its arguments describing how it affects the jacobian of the overall function
22:54:00 <shapr> edwardk: y0
22:54:17 <edwardk> when you work in forward mode you work with the jacobian matrix (or rather the excessively sparse choice of the representation of one or two off axis elements), when you work in reverse mode you use the transpose of it. but the off axis elements are the same regardless so i can share the code that generates them
22:54:19 <edwardk> heya shapr
22:54:44 <dmead> edwardk, is it really that much slower to derrive an expression tree and then have a solver for it?
22:55:07 <dmead> edwardk, unless you're using mutable arrays to represent your matricies, it's still going to be kinda slow
22:55:21 <edwardk> dmead: there is no matrix here. the matrix is the conceptual model
22:55:29 <dmead> ah
22:55:55 <edwardk> in forward accumulation you just wind up with an extra value for the derivative next to everything
22:56:06 <edwardk> in reverse mode you need the tree of arguments which is a lot like your expression tree
22:56:29 <dmead> neat
22:56:32 <edwardk> but without all the nonsense, since the only thing you need out of the tree (nay, actually, the graph) is the partial derivatives
22:56:45 <edwardk> so the graph gets stored as something like
22:57:07 <edwardk> data Tape a t = Constant a | Variable a Int | Unary a a t | Binary a a a t t
22:57:10 <Cale> http://i.imgur.com/c2oo4.jpg
22:57:46 <edwardk> where t are the nodes in the graph, and the first 'a' is the value of the node, and the other a's are the partials. no symbolic 'Sin' constructors floating around etc.
22:58:44 <edwardk> cale: ouch
23:06:34 <Cale> I would love to see that one on "Who Wants To Be A Millionaire" :)
23:07:11 <tensorpudding> But there's two answers which are the same!
23:07:36 <Cale> That's part of it.
23:07:47 <tensorpudding> How do you choose which one is right?
23:07:56 <spawn> dern
23:07:58 <ville> heh
23:08:15 <ville> tensorpudding: trolling?
23:09:31 <Cale> If A is correct, then D must be as well, and so the probability that you'll get it right if you guess in a uniform random way would be 50%, and so neither A nor D can be correct.
23:10:00 <Cale> If B is correct, then the chance would be 25%, which is not 50%, and so B can't be correct.
23:10:18 <Cale> If C is correct, then the chance would again be 25%, which is not 0%, so C can't be correct.
23:10:58 <dmead> 25% of the time, it works 100% of the time
23:11:20 <Cale> So it would appear that none of them are correct, which would make C correct, however, we ruled that out already.
23:12:00 * sepp2k hates paradoxes. They're so paradox.
23:12:05 <FunctorSalad> @let (...) = (+)
23:12:35 <FunctorSalad> @bot
23:12:51 <dmead> edwardk, can you paralellize AD?
23:12:59 <FunctorSalad> seems like that is actually legal...
23:13:14 <dmead> cause it seem the symbolic method is more easily broken up
23:13:24 <FunctorSalad> is any operator token whatsoever legal as long as the whole token doesn't match a special token?
23:13:45 <edwardk> dmead: the symbolic method and the jacobian method are isomorphic
23:13:51 <FunctorSalad> (like ..)
23:14:07 <edwardk> dmead: the symbolic method just makes you interpret some constructor to figure out the shape of the derivative
23:14:28 <dmead> ah
23:15:11 <dmead> yea, thats pretty kewl
23:15:46 <edwardk> funny how you can sum up an arbitrary algebraic constructor with 1-2 numbers like that ;)
23:15:46 <dmead> seems like both methods have roughly the same overhead too
23:16:17 <edwardk> well one is an 'initial' and one is a 'final' model of the same idea
23:16:46 <Olathe> > let f :: a -> a; f x = g where g :: a; g = x in f 1
23:17:24 <Olathe> Netsplits...
23:17:46 <Olathe> I get Couldn't match expected type `a1' against inferred type `a'
23:19:08 <dmead> > let f :: a -> a; f x = g;   where g :: a; g = x in f 1
23:19:23 <Olathe> Is there a proper way to do a type signature for g if it uses one of the inputs to f without it being explicitly passed to g ?
23:19:24 <dmead> lambdabot, why have you forsaken me!!
23:19:48 <dmead> Olathe, the type of the inputs of f?
23:19:53 <GonzoChurch> lambdabot is on drugs
23:20:26 <Olathe> Yeah, f takes something of type a as input. I use that (the variable x) in g without taking it as an input to g.
23:20:37 <Olathe> But whenever I try to give g a type signature, it fails.
23:21:02 <Olathe> lambdabot is away due to a netsplit
23:21:05 <dmead> so g is just an identity?
23:21:16 <Olathe> Well, it works for more complex things.
23:21:53 <Olathe> let f :: (Num a) => a -> a -> a; f x y = g where g :: (Num a) => a; g = x + y in f 1 2
23:22:06 <Olathe> Couldn't match expected type `a1' against inferred type `a'
23:22:49 <Olathe> If I remove the type signature for g, I get 3 as a result.
23:22:59 <sepp2k> Olathe: You need the ScopedTypeVariables extension
23:23:07 <Olathe> Ahh, thanks :)
23:24:09 <sepp2k> And then use forall in f, but not g to make clear that g is supposed to use f's a, not a new one.
23:25:50 <dmead> Olathe, yea i removed the type sig for g as well
23:25:52 <dmead> xD
23:25:59 <dmead> it works then
23:26:06 <tempo> @djinn (c->b->d)->(a->b->c)-> a->b->d
23:26:52 <tempo> @djinn a->a
23:27:08 <dibblego> @type fmap . fmap -- tempo
23:27:27 <tempo> hm
23:28:08 <Olathe> sepp2k: Ahh, OK.
23:35:02 <Gracenotes> uh. is it possible to do conversions between lazy and strict bytestrings swimmingly?
23:35:35 <edwardk> Gracenotes: fromChunks toChunks from Data.ByteString.Lazy
23:36:26 <Gracenotes> it seems Data.ByteString.UTF8 is far-less-than-ready for prime time, in that respect...
23:36:35 <edwardk> it is easy to make a lazy bytestring from a strict one, going the other way can take a while because you have to walk the entire lazy bytestring, find out how big it should be, then allocate the strict bytestring, but typically 'toChunks' which gives you a bytestring list works fine
23:36:46 <Gracenotes> hence the experimental tag
23:36:48 <edwardk> Gracenotes: data.rope works in utf8 mode ;)
23:37:41 <Gracenotes> one libraries gives me a lazy bytestring. another library expects a strict one. I suppose I could convert it to a rope inbetween if I feel like wasting cycles :w
23:37:50 <edwardk> heh
23:37:52 <edwardk> fair enough
23:39:14 <Gracenotes> hm. I suppose concat . toChunks should do it
23:39:44 <edwardk> yeah
23:40:08 <edwardk> what library is wanting the strict bytestring?
23:40:32 <Gracenotes> this un: http://hackage.haskell.org/package/gd-3000.4.0
23:40:53 <Gracenotes> last updated 2.5 yrs ago
23:41:29 <Gracenotes> it's a bindings package
23:46:24 <edwardk> so 15 minutes later you can put together a Graphics.GD.Lazy and slap it on hackage as gd-lazy and not have to worry about it ;)
23:48:01 <Gracenotes> 15 minutes later I'll have guessed why GHC is complaining about where my do construct ends in a 30-line function
23:48:17 <edwardk> =)
23:48:49 <Gracenotes> aha. misaligned let statements
23:52:30 <Gracenotes> well. the resulting executable is only 8.9 MB. o_O
23:52:44 <copumpkin> "only"
23:55:49 <Gracenotes> looking at the -v output, it's linked against such things as gd, libpng, libjpeg, all the happstack components (network, binary, QuickCheck, HUnit, etc.)..
23:56:23 <Gracenotes> happstack-server, happstack-state, happstack-util, happstack-data..
23:57:17 <Gracenotes> well. this better work the first time I run it.
