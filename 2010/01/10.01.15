00:00:01 <adu> is there a GHC language extension to have operator types? like (a ~> b) for arrow?
00:00:01 <jrockway> exceptions and returning from functions didn't make any sense in that case, so i just did CPS
00:00:09 <jrockway> and used an Either-like type to handle errors
00:00:14 <adu> or (a +> b) for Map?
00:00:23 <jrockway> (i wrote it for a specific application, but never got around to writing the app; lol...)
00:01:06 <jrockway> mxc: is your code available anywhere other than that screenshot? :)
00:01:24 <Eduard_Munteanu> I don't think '->' is an operator.
00:01:30 <Eduard_Munteanu> :t (->)
00:01:30 <lambdabot> parse error on input `->'
00:01:55 <kmc> adu, yes
00:01:58 <kmc> TypeOperators iirc
00:02:39 <jrockway> Eduard_Munteanu: example of it in use: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-Reader.html
00:04:31 <adu> kmc: oooo you just have to add ":" its not a language extension :P
00:05:12 <Eduard_Munteanu> jrockway, hm, interesting. Though it's a bit confusing to redefine ->.
00:05:22 <jrockway> it's not redefining it there
00:05:45 <jrockway> it's just defining an instance of the typeclass for that type
00:06:20 <Eduard_Munteanu> jrockway, oh.
00:09:18 <jrockway> i think i have also seen functions like Arrow a => a b c -> a b d written as something like c ~> d
00:09:18 <jrockway> (since arrows are like functions, but with different semantics)
00:09:18 <jrockway> someone else can explain better than me, though, as i have not used that in real code :)
00:12:47 <merehap> how did you know it was zelazny?
00:12:48 <tensorpudding> because zelazny is always splitting
00:13:07 <merehap> ah, he clicks every spam link that comes along? :)
00:14:07 <c_wraith> the quit messages shown on a split contain the name of the server that split
00:14:09 <tensorpudding> the grass is always greener on the other side of the netsplit
00:14:36 <merehap> oh, and leguin is his node, gotcha
00:14:42 <mental> what if one day a server splits and never comes back
00:14:51 <jrockway> on my machine, it says kubrick split
00:14:52 <tensorpudding> that doesn't happen
00:15:01 <adu> is there a Jabber version of freenode?
00:15:04 <mental> it will if the server software allows it
00:15:10 <jrockway> hmm, maybe not, as that's the server i'm on
00:15:11 <tensorpudding> it never says that your own server split
00:15:15 * jrockway un-delurks
00:15:16 <adu> so netsplits still happen in Jabber?
00:15:21 <tensorpudding> i don't think
00:19:36 <phr> anyone got a language they like for midsized embedded systems?  i.e. haskell is too big but c/asm is too unsafe/underpowered
00:20:57 <merehap> Ada, maybe
00:21:12 <phr> i shoulda said, too verbose
00:21:19 <merehap> ah
00:21:24 <c_wraith> Ada.  Food enough for the military, good enough for me to ignore. :)
00:21:24 <phr> i.e. something like j2me is ok for the machine, but also too verbose
00:21:34 <c_wraith> ....  *good enough
00:21:35 <phr> hedgehog lisp is pretty cool, but it's lisp ;)
00:21:42 <c_wraith> time for me to sleep, I think
00:21:58 <phr> ada seems like an improvement over c ;)
00:22:05 <merehap> how is j2me ligher weight than haskell?
00:22:05 <Eduard_Munteanu> Agda seems smaller, but I'm not sure how much of a headache it might be to do actual practical programs.
00:22:31 <Eduard_Munteanu> and Agda is quite similar to Haskell.
00:22:41 <phr> haskell too big => i mean the runtime is too big.  the compiler and language size don't matter, as it would be cross compiled
00:22:50 <merehap> ah, makes sense
00:23:22 <merehap> there isn't too much that meets your requirements
00:23:40 <phr> merehap yeah, it sort of seems that way, what a shame
00:24:00 <c_wraith> forth? >_>
00:24:21 <merehap> there you go :)
00:25:13 <phr> the hedgehog lisp guy has been wanting to make an ML-ish version
00:25:13 <phr> but i get the impression that ML is pretty obsolete
00:25:13 <phr> i've never used it
00:25:13 <phr> does anyone use liskell any more?  it would seem to make haskell dsl's much easier to write
00:25:13 <phr> c_wraith :-P
00:25:33 <Eduard_Munteanu> phr, have a look here as well: http://stackoverflow.com/questions/699908/making-small-haskell-executables
00:25:44 <Eduard_Munteanu> I also hear nhc98 gets you smaller binaries.
00:25:57 <phr> jhc also
00:26:10 <merehap> haskell DSLs for C might be worth looking into
00:26:25 <merehap> sort of in the way that seL4 was made
00:26:27 <phr> merehap, i'm looking at atom right now, it's pretty cool, but very limited
00:26:28 <c_wraith> not that forth is safer than C
00:26:28 <c_wraith> But it's sure small!
00:26:29 <adu> DSLs for C? :)
00:26:30 <phr> what's sel4 ?
00:26:50 <merehap> the first formally verified operating system kernel
00:26:56 <merehap> (microkernel, of course)
00:27:05 <phr> c_wraith, forth just seems nuts, i can't understand why anyone clueful would want to use it even for the tiniest systems these days
00:27:16 <phr> merehap oh right, i remember that
00:27:41 <merehap> so the code ends up in C, but was prototyped in a Haskell DSL, if I remember correctly
00:27:43 <c_wraith> phr: I wouldn't.  But it's *an* option for small embedded stuff.
00:28:00 <phr> i like the atom edsl approach and have done things like that in lisp, but it's rather painful in haskell because you have to hack around all the collisions with haskell built-ins
00:28:09 <phr> no separation of the meta and object languages
00:28:31 <phr> c_wraith forth might be an interesting target language for an EDSL :-P
00:28:52 <Eduard_Munteanu> Wasn't there a Haskell compiler that could output C code?
00:28:58 <phr> eduard, yeah, JHC
00:29:04 <Eduard_Munteanu> phr, I see.
00:29:19 <Eduard_Munteanu> You probably have to deal with memory allocation, though. I'm not sure.
00:29:25 <phr> JHC is an interesting thought
00:29:37 <phr> i don't remember if it has a gc at all
00:29:44 <phr> i like the idea of using the hedgehog virtual machine
00:29:54 <phr> or even J2ME
00:30:09 <merehap> what kind of collisions have you had to deal with for Atom? I can't imagine them being too intractable
00:30:23 <phr> merehap the collisions aren't intractable, they're just annoying
00:30:45 <Eduard_Munteanu> phr, OTOH, I hear GHC 6.12 will allow you to do dynamic linking, so you can have multiple smaller executables (your code) and only one bigger .so
00:30:51 <phr> all the keywords and operators, having to say .&. instead of &  and so forth
00:32:33 <merehap> it seems the default then would be to hide the prelude in all modules except where you are building up your DSL on top of Atom, but like I said, I don't know enough about Atom yet
00:32:34 <phr> that's sort of interesting but the ghc runtime is still quite large and memory hungry
00:32:34 <merehap> I mean hiding prelude imports seems pretty common in haskell
00:33:03 <phr> you'd have to redesign atom quite a bit for that, but it's also an interesting idea
00:33:12 <merehap> I don't know how it compares to j2me, but in general it seems that tightly written haskell code beats out java
00:33:25 <merehap> for memory, that is
00:33:37 <merehap> well, going based upon the language shootout
00:33:38 <phr> the thing is, atom is a monad, i.e. you write   do {action1; action2; action3...}
00:33:49 <merehap> ah
00:33:53 <phr> so there is normal haskell evaluation going on before the monadic result comes out
00:34:03 <phr> you're really writing in two languages at the same time
00:34:19 <phr> in return you get the benefit of the haskell type checker and parser
00:34:33 <phr> but, parsing is easy these days, it would be nicer to just design your own syntax and use parsec
00:34:40 <phr> except then you don't have all that nice type inference
00:35:10 <phr> thus the question earlier about whether liskell was still active ;)
00:35:34 <merehap> hm, there has to be a happy middle ground somewhere, though I wouldn't know where it lies, maybe liskell would be it
00:35:41 <phr> i saw something in the atom slide presentation saying it used GADT's, but i just read most of the source code and didn't see any anywhere
00:35:50 <adu> phr: I <3 Liskell :)
00:36:15 <phr> liskell seems like a nice target for a parsec parser
00:36:33 <merehap> the other thing is the potential of syntax rewriting rules
00:36:50 <adu> merehap: Haskell is #1 at thread-switching :)
00:38:02 <phr> atom bypasses threads altogether ;)
00:38:02 <merehap> that is, for example, how augustss made his pretty BASIC implementation
00:38:29 <merehap> within close to haskell98 syntax, that is
00:39:00 <merehap> again, I don't know how pretty syntax rewrite rules are, but they could be worth a try
00:39:23 <phr> what do you mean by syntax rewriting rules?  you mean GHC rules?
00:39:24 <phr> i have a borrowed book about ML that i didn't like much when i first looked at it (before i knew anything about FP) but might look at it again now that i've been messing with haskell for a while
00:39:50 <merehap> yes, GHC rules
00:39:58 <phr> hmm
00:40:38 <phr> it all seems pretty kludgy... i like clean separation between the levels of a system like that
00:41:26 <merehap> http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
00:42:03 <merehap> he ends up with a nice result, I'm just not sure if it was built on a pile of hacks
00:42:28 <phr> yeah i remember that
00:43:22 <phr> it uses LLVM ;)
00:43:22 <phr> BASIC beats C :)
00:43:22 <Saizan_> GHC RULES are for optimizations in the backend, not for syntax
00:43:25 <merehap> sorry for being, loose with my language
00:44:29 <merehap> though I think I can call whatever augustss uses to create basic in haskell "syntax rewriting rules" for the front-end
00:44:51 <Saizan_> though maybe augustss is being evil like that and implementing the right semantics for the statements by using RULES?
00:44:51 <Saizan_> it seems weird, since it looks like it's building an AST there
00:44:51 <Saizan_> *he's
00:45:47 <phr> i wondered how he did stuff like "10 gosub 1000"  i.e. did he have some awful Num instance that was also a function returning a monad action?
00:45:47 <phr> so that 10 is a function?
00:45:47 <phr> Atom is basically StateT IO, i think
00:46:21 <phr> i may try to write soemthing with it tomorrow... i'm too sleepy now
00:46:33 <Saizan_> i think it's pretty misleading, those terms usually indicate some sort of macro system
00:46:34 <merehap> ugh, we need to force him to publish his BASIC module, I haven't been able to find it
00:46:49 <Saizan_> while here's he's doing only nasty stuff with typeclasses
00:53:42 <Eduard_Munteanu> I created a Gtk2Hs application, but it's ugly because I pass around all widgets from main. Any idea how to do this cleanly?
00:53:51 <Eduard_Munteanu> Would it be wise to pass the xml object around instead? (I used glade to create the UI)
00:54:10 <Eduard_Munteanu> Or would getting the objects from xml every time (say on events) be a performance issue?
00:54:26 <merehap> well, knee jerk reaction from me would be that that wouldn't be wise
00:54:45 <merehap> beyond being a performance issue, it would be an abstraction issue
00:55:02 <merehap> why not make a type that represents the relevant data from the xml?
00:55:14 <merehap> and just pass that one thing around
00:55:24 <merehap> the best of both worlds, imho
00:55:44 <PepeSilvia> hi, sorry if this is a stupid question but the description on the site left me wondering a bit: how do I get a Hackage username?
00:56:51 <Eduard_Munteanu> merehap, hm, that could do. I mean creating a structure containing all objects retreived from the xml object.
00:57:00 <Eduard_Munteanu> Thanks.
00:57:26 <merehap> XML is a storage format for hard disk storage or network transmission, I always try to minimize how long I have to be exposed to it, if possible
00:58:13 <merehap> rather than xpath here, xpath there, which I've found gets tedious and error prone
00:58:37 <merehap> YMMV
00:59:01 <Jafet> XML can refer to two things. The data structure, or the standard textual (or binary) representation of said data structure
00:59:08 <Eduard_Munteanu> merehap, no, I mean there's an xml object created like this: Just xml <- xmlNew "main.glade"
00:59:26 <merehap> yes, I'm referring to the data structure, not the text
01:00:04 <merehap> I'm saying that I consider the data structure itself cumbersome
01:01:24 <Jafet> Bah, IRC lags
01:01:35 <merehap> (and not too well type-validated, you lose a lot of Haskell's power by leaving it in that format)
01:01:55 <Lemmih> PepeSilvia: Seen http://hackage.haskell.org/packages/accounts.html ?
01:02:01 <phr> but it's generated by glade, is it likely to be mis-typed?
01:02:03 <Eduard_Munteanu> Hm, I should use a tuple or an array perhaps to represent it.
01:02:04 <Jafet> I wouldn't be surprised if you can encode XML schema in Haskell types
01:02:27 <merehap> I wouldn't either, but I would still consider it inferior even if you could
01:02:28 <Eduard_Munteanu> Perhaps tuple since I already know the size?
01:02:32 <phr> jafet yeah, that's how happs state works
01:03:02 <PepeSilvia> Lemmih: yeah, so I should e-mail him out of the blue? :p
01:03:16 <merehap> Eduard_Munteanu: I don't know the specifics of your data, so I couldn't say
01:03:28 <Lemmih> PepeSilvia: Yep.
01:03:39 <merehap> but if it is just a simple few items, then you could get away with a tuple
01:03:48 <PepeSilvia> Lemmih: ok, thanks!
01:03:59 <merehap> in general, I'd think the algebraic data type route is the way to go, though
01:05:50 <merehap> I've had the misfortune of working at a job where people believe that XML is the cure for all programming ailments
01:05:54 <merehap> and as a result I've innoculated myself against it
01:05:59 <merehap> :)
01:06:12 * Jafet slaps merehap with a golden hammer
01:08:02 <merehap> if you had to deal with all of the DSLs written in XML, you'd understand...
01:08:18 <merehap> MSBuild is an absolute piece of junk, for example
01:08:39 <phr> apache ant ?
01:08:46 <merehap> a midget programming language made of XML!
01:09:04 <merehap> I don't remember my one experience with ant, unfortunately
01:09:24 <merehap> or fortunately
01:10:23 <Jafet> I'm not really sure why people avoid XML.
01:11:26 <merehap> it isn't evil, but it is heavily overused
01:11:26 <merehap> XML is good for organizing content on webpages, storing SMALL configuration files, and serializing data
01:11:40 <drhodes> is there a parFilter, it looks like parallel list comprehensions are used for this, but I don't see how.
01:11:42 <merehap> there is no reason to make programming languages out of it
01:11:42 <merehap> or control logic of any type
01:11:52 <merehap> you lose any benefits that a compiler can provide
01:13:17 <Jafet> XML doesn't make programming languages any more than S-expressions make Lisp.
01:13:17 <Jafet> For example?
01:13:17 <merehap> at MSN, there are multiple XML technologies that reinvent inheritance (poorly), or provide non-technical person readable code (extremely poorly)
01:13:23 <merehap> MSBuild
01:13:35 <merehap> MSN's whole site layout/templating system
01:13:45 <merehap> I guess probably apache ant
01:13:47 <Jafet> Ah, doing that in XML isn't the best of ideas
01:13:54 <Jafet> They should've used UML instead
01:13:58 * Jafet snark
01:14:01 <merehap> ha :)
01:14:06 <merehap> you scared me for a second
01:14:36 <otulp> The good thing about XML is that it is everywhere, so you will not have to write your own parser. That's it.
01:14:36 <Jafet> Or CORBA!
01:14:47 <merehap> otulp: agreed
01:15:03 <Jafet> XML syntax is trivial to parse because it conveys almost no structure.
01:17:05 <merehap> anyway, now you might know why I would love a haskell job
01:17:05 <merehap> when you write your configs in the same language that your write your code in, OH HAPPY DAY
01:17:34 <Jafet> XML schemas convey structure, but you have to write then
01:17:34 <Jafet> s/then/them/
01:17:34 <Jafet> And your lunch will be $20, sir.
01:18:46 <merehap> ugh, writing XSLTs, XSDs, all that nonsense just because XML isn't a language with proper support, kills me
01:19:35 <Baughn> merehap: Really? It kills you?
01:19:53 <merehap> well, it has come close a few times anyway
01:20:14 <merehap> but more so it kills me slowly
01:20:24 <merehap> when I'm not paying attention
01:20:24 <Baughn> Then you should probably stop doing it.
01:20:41 <otulp> How sensitive.
01:20:49 <merehap> well don't tell anyone, but I plan on ditching MS is a few days :)
01:21:09 <merehap> I'll get my soul back, and maybe a few other fringe benefits
01:21:26 <dmead> i'd get rid of windows too
01:21:32 <dmead> but i enjoy killing zombies too much
01:21:36 <merehap> :)
01:21:46 <Eduard_Munteanu> Should I refrain from passing a large tuple instead of a data structure in Haskell between functions?
01:21:58 <dmead> how large?
01:22:09 <dmead> and a tuple is a data structure :/
01:22:18 <merehap> > (,,,,,,,) 3 4 5 6 1 2 3 4
01:22:18 <Eduard_Munteanu> dmead, say 20 items consisting of objects from Gtk2Hs
01:22:19 <lambdabot>   (3,4,5,6,1,2,3,4)
01:22:31 <Baughn> Eduard_Munteanu: Definitely.
01:22:36 <Jafet> It might not have enough structure, though
01:22:45 <Baughn> 2-tuples are fine. I can accept 3-tuples, and 4-tuples make me queasy
01:22:46 <Eduard_Munteanu> How should I do it then?
01:22:47 <Baughn> 20-tuples?
01:22:58 <dmead> if it's more than 4, use a list
01:22:59 <Baughn> Eduard_Munteanu: Eh, an ADT? With named fields.
01:23:01 <merehap> is there any hierarchy to the data?
01:23:05 <dmead> simply for readability
01:23:12 <dmead> bullllocks i say to efficiencyt
01:23:29 <Eduard_Munteanu> Baughn, don't get me wrong, I don't intend to write 'func (a,b,c,...)', but 'func tuple'
01:23:44 <Baughn> Eduard_Munteanu: Doesn't matter. Use an ADT. You'll be much happier.
01:23:48 <merehap> try to find the natural hierarchy, and have maybe a small tree of ADTs
01:23:54 <Eduard_Munteanu> Baughn, thanks.
01:23:54 <Baughn> That too
01:23:55 <merehap> if you actually have 20 disjoint values
01:24:16 <dmead> maybe you want to organize your widgets in some container types
01:24:21 <Eduard_Munteanu> The data can't grow in size, it's stuff I get from glade.
01:24:34 <Eduard_Munteanu> The structure is set in stone.
01:24:34 <Baughn> What /is/ the data, exactly?
01:24:46 <Baughn> Eduard_Munteanu: ..yeah, sounds like a thing for records.
01:25:09 <Eduard_Munteanu> Baughn, stuff like this from Gtk2Hs: menuQuit <- xmlGetWidget xml castToMenuItem "menuQuit"
01:25:10 <Jafet> What you say you want to do is to throw away that stone structure and stuff it into a 20-tuple
01:25:15 <Baughn> Eduard_Munteanu: Also look up the NamedFieldPuns/RecordWildCards extensions.
01:25:31 <Eduard_Munteanu> Baughn, I simply need to pass around the widgets.
01:25:31 <Jafet> I find that strange
01:25:52 <dmead> fer shizzle
01:26:12 <dmead> what sort of app are you writting?
01:26:50 <Eduard_Munteanu> So I can write "onEvent menuQuit $ menuQuitHandle widgets", instead of passing only the widgets I need (I need to specify a lot then)
01:26:50 <Eduard_Munteanu> dmead, some Gtk2Hs app.
01:28:45 <Baughn> Eduard_Munteanu: This sounds environmental, which would make it a case for Reader
01:28:45 <dmead> yes
01:28:45 <dmead> you need some state
01:28:45 <dmead> some mutable state
01:28:45 <Eduard_Munteanu> Baughn, you mean I should use some sort of monad to keep global variables?
01:28:45 <Eduard_Munteanu> dmead, I don't need it mutable.
01:28:45 <Baughn> Eduard_Munteanu: The Reader monad, specifically
01:29:07 <Eduard_Munteanu> dmead, the objects themselves provide for mutability by design.
01:29:17 <Eduard_Munteanu> Baughn, I see, lemme take a look...
01:29:22 <dmead> ah
01:30:09 <Baughn> When it comes to Reader, I'm always torn between using the monad and using explicit parameters
01:30:17 <Baughn> ..and I usually come down on the "parameters" side.
01:30:25 <Baughn> Still, you should have a look.
01:30:36 <Baughn> (ReaderT is something else again; that's more useful)
01:31:24 * Berengal too tends to use parameters
01:31:42 <merehap> Baughn: is your reasoning that sometimes you end up "leaking" more parameters to certain functions than they should see?
01:31:56 <merehap> I haven't had a chance to use Reader, yet
01:31:57 <Baughn> merehap: No, it's that calling ask is inconvenient.
01:32:03 <merehap> oh
01:32:09 <merehap> gotcha
01:32:28 <Axman6> wtf?
01:32:34 <Berengal> Besides, there's already the (->) e monad
01:32:45 <merehap> at least it wasn't another netsplit :)
01:32:54 <Axman6> what... was it?
01:33:00 <Baughn> A netsplit, looks like
01:33:04 <merehap> I dunno
01:33:06 <Baughn> Just.. outside the irc network
01:33:13 <Eduard_Munteanu> Baughn, what if I simply use an ADT? Is there a disadvantage?
01:33:15 <merehap> sweet
01:33:32 <merehap> you wouldn't have named parameters
01:33:32 <Baughn> Eduard_Munteanu: As opposed to Reader? Well, you have to explicitly pass it everywhere.
01:34:53 <Eduard_Munteanu> Baughn, it seems I have to pass it here explicitly too: runReader func env
01:35:02 <Baughn> Eduard_Munteanu: Yeah, but only at the top-level, once.
01:35:09 <Baughn> Eduard_Munteanu: It only makes any sense if you go on to call other functions from func
01:35:42 <Eduard_Munteanu> Baughn, thanks, I see.
01:35:42 <Eduard_Munteanu> Baughn, I could pass the ADT again then. The depth of the call tree is very small (2-3 functions at most).
01:36:01 <Berengal> Eduard_Munteanu: Yes, but env is available to every Reader inside that one
01:36:01 <Berengal> e.g. an eval function is sensible to turn into a reader
01:36:01 <merehap> Eduard_Munteanu: I would suggest just experimenting around, I'm not sure if we can give you a definite answer
01:36:01 <merehap> rewriting code after realizing it could be better is always enjoyable
01:36:01 <merehap> well, to me, anyways
01:36:01 <merehap> it helps build an intuitive sense of the problem for next time
01:36:32 <Berengal> Yes, use a record
01:36:40 <Eduard_Munteanu> merehap, yeah, currently my app is too much copy-paste work.
01:37:15 <Berengal> With RecordWildcards or whatever the extension is called, records are pretty neat bundles of variables
01:37:58 <Eduard_Munteanu> Berengal, the thing is I don't even need to modify those variables. They're mutable in themselves (that's how Gtk2Hs stuff works)
01:38:28 <merehap> yes, but you will want to access them by name
01:38:34 <Eduard_Munteanu> merehap, yes.
01:38:38 <Berengal> Eduard_Munteanu: Actually, mutating records is the most painful part of them (though not very)
01:38:40 <merehap> rather than just their position in a 20 long ADT
01:39:07 <Baughn> Berengal: We could do better. We have the lenses.
01:39:16 * Baughn desperately hopes someone will implement that for 6.14
01:39:19 <Eduard_Munteanu> merehap, um, I mean something like 'data Widgets = Widgets { button :: Button, ... }'
01:39:30 <merehap> oh, ok, cool
01:40:52 <Eduard_Munteanu> And I can access them using the field constructor.
01:40:53 <Baughn> field /accessor/, rather
01:40:54 <Baughn> Widgets is the constructor
01:40:54 <Eduard_Munteanu> Baughn, hm, yeah. Though it's still a constructor :)
01:40:54 <Eduard_Munteanu> or?
01:40:54 <Baughn> Eduard_Munteanu: Nope
01:40:54 <Eduard_Munteanu> Oh, I see.
01:41:57 <Eduard_Munteanu> It's possible to not define that data beforehand, right?
01:42:03 <Berengal> Eduard_Munteanu: Record syntax is just shorthand for 'data Foo = Foo Int String ...; count (Foo i _ ...) = i; name (Foo _ name ...) = name' etc
01:42:55 <Eduard_Munteanu> Berengal, hm, interesting. I'll look into it.
01:43:23 <Berengal> Baughn: Of course Widgets is a constructor. What else would it be?
01:44:07 <Eduard_Munteanu> Berengal, um, I meant field.
01:44:07 <Eduard_Munteanu> as in 'button'.
01:44:07 <Berengal> Oh, right
01:44:17 <Berengal> Then yes, it's just convenient shorthand
01:44:37 <Baughn> I still say we need lenses.
01:44:37 <Berengal> And with some extensions enabled, it's even more shorthand
01:44:52 <Berengal> lenses are a category
01:45:12 <sinelaw> lenses?
01:45:16 <sinelaw> like contact lenses?
01:45:25 <merehap> my question too...
01:45:42 <Eduard_Munteanu> Can I simply assign data to an undefined structure and have the compiler infer the data T = T { x :: Type, ... } definition?
01:46:00 * sinelaw noticed that CT gets more bizarre each day
01:46:00 <Baughn> I'd explain it, but I've got to run.
01:46:06 <Berengal> Lenses offer views on data, so you can read and write things nested inside other things without explicitly wrapping/unwrapping
01:46:08 <Berengal> Also, they compose
01:47:14 <sinelaw> like fc_labels?
01:47:14 <Berengal> Ish. I'm still a bit fuzzy on the concept myself
01:48:09 <merehap> oh tamiko, and you wonder why no one connects to your node anymore... :(
01:48:33 <Berengal> They could, presumably, be made to access not only real fields, but virtual fields as well, sort of like views in a database
01:48:39 <Berengal> (that you can write to)
01:50:43 <sinelaw> ANNOUNACE: I have a great mathematical discovery!
01:50:50 <sinelaw> ANNOUNCE even...
01:51:13 * sinelaw didn't learn to spell before making the great mathematical discovery
01:51:15 <therp> N=NP?
01:51:18 <therp> err P=NP
01:51:20 <merehap> goldberg's conjecture solved? good news everyone!
01:51:21 <sinelaw> therp, nope! guess again.
01:52:15 <kmc> ah, to be young again.  and also a robot.
01:52:32 <Berengal> 2+2=2, for some rings?
01:52:55 <merehap> kmc: :)
01:53:14 <merehap> makes me feel warm inside
01:53:14 <sinelaw> > pi
01:54:12 <kmc> > pi :: CReal
01:54:12 <lambdabot>   3.141592653589793
01:54:12 <merehap> it isn't something to do with sine?
01:54:12 <sinelaw> thanks lambdabot. now watch this:
01:54:12 <merehap> or the law thereof?
01:54:28 <Berengal> > 22 / 7
01:54:30 <lambdabot>   3.1415926535897932384626433832795028841972
01:54:30 <lambdabot>   3.142857142857143
01:54:42 <merehap> which is which? omg
01:54:44 <Berengal> ...
01:54:55 <knobo> Loading package HDBC-sqlite3-2.1.0.2 ... can't load .so/.DLL for: HSHDBC-sqlite3-2.1.0.2
01:54:56 <knobo> anyone?
01:55:08 <merehap> that was quite a climax and disappearing act, sinelaw
01:55:13 <Berengal> knobo: Do you have sqlite installed?
01:55:14 <merehap> oh, you're back
01:55:18 <sinelaw> sorry, bad connection.
01:55:29 <Berengal> sinelaw: Bad connections does not a pie make
01:55:46 <sinelaw> here it is:
01:56:03 <sinelaw> > sqrt(pi*sqrt(pi*sqrt(pi))) - exp(1)
01:56:04 <lambdabot>   4.457964363955735e-3
01:56:10 <Eduard_Munteanu> I'd like to do something like 'let x = X { text = "Hello", other = " Other" }' without predefining X, is it possible?
01:56:19 <Baughn> Eduard_Munteanu: No.
01:56:19 <Eduard_Munteanu> It should be easy to infer.
01:56:24 <sinelaw> tada!
01:56:29 <Eduard_Munteanu> Baughn, :(
01:56:31 <merehap> uh
01:56:44 <Baughn> Berengal: Oh, and look up the data-accessors package for a nice example of lenses.
01:56:55 <merehap> I guess I'm not smart enough, or something
01:56:59 <Baughn> ..well, maybe not /that/ nice, but lenses.
01:57:07 <sinelaw> so sqrt(pi * (sqrt (pi * sqrt pi))) is _almost_ e!
01:57:13 <sinelaw> that's all. :(
01:57:15 <merehap> oh
01:57:19 <merehap> makes sense :)
01:57:25 <Eduard_Munteanu> I wish it could do such inference.
01:57:31 <sinelaw> merehap, it does??
01:57:32 <Berengal> Baughn: I've looked at it a bit. It is nice, but it still doesn't get rid of the boilerplate
01:57:41 <Berengal> Well, _entirely_
01:57:50 <Baughn> Berengal: Right, getting rid of the boilerplate would imply a GHC extension.
01:57:53 <merehap> now I understand, what I was getting it
01:57:56 <Berengal> Indeed
01:58:03 <merehap> but no, I have no idea why it comes so close
01:58:11 <merehap> that part obviously doesn't make sense
01:58:36 <sinelaw> i was just fiddling with my calculator
01:59:00 <sinelaw> what a fortunate way to be remembered for ever in the annals of science!
01:59:05 <merehap> though I wouldn't say that it is as exciting as floor pi
01:59:12 <Jafet> You can approach any real number with those symbols
01:59:12 <merehap> @let π = 3
01:59:13 <lambdabot>  Defined.
01:59:23 <Axman6> > π
01:59:24 <merehap> @underfine
01:59:25 <lambdabot>   3
01:59:29 <Berengal> > exp 1 - (head . drop 20 . iterate ((*pi) . sqrt)) pi
01:59:30 <lambdabot>   -7.15131179799409
01:59:31 <merehap> @undefine
01:59:33 <quicksilver> Berengal: once you've decided which system + cmobinators to use, getting rid of the boilerplate is a SMTH
01:59:41 <quicksilver> (tm)
01:59:41 <merehap> @let π = floor pi
01:59:41 <lambdabot>  Defined.
01:59:55 <merehap> not as exciting as floor pi
02:00:03 <merehap> > π
02:00:04 <lambdabot>   3
02:00:05 <Berengal> quicksilver: SMTH?
02:00:10 <sinelaw> merehap, ?
02:01:18 <merehap> don't ask :)
02:01:18 <quicksilver> Simple Matter of Template Haskell
02:01:30 <merehap> just say, "mmm... floor pi"
02:01:40 <quicksilver> SMOTH, rather ;)
02:02:15 * Berengal doesn't get it
02:02:15 <merehap> SMTH = super monkey template haskell, obviously
02:02:15 <sinelaw> well, i'll be off to accept my Fields' medal
02:02:15 <sinelaw> you guys keep playing with that CT stuff
02:02:22 <merehap> that's OK, I'm not sober, so good night
02:03:37 <sinelaw> i didn't either
02:03:38 * Berengal thought it might be Super Mutant Template Haskell
02:03:38 <sinelaw> but that's only because my mind is specifically tuned to abstract thinking, as my recent discovery shows
02:03:38 <sinelaw> Beelsebob, heh
02:03:38 <sinelaw> oops. Berengal that is
02:03:39 <Baughn> quicksilver: I /guess/ I could create a TH function to make ADTs..
02:03:40 <ElfArmy> ceiling cat wants floor pi
02:03:53 <Baughn> quicksilver: I'd just much rather use the normal syntax
02:04:12 <Baughn> quicksilver: There's no way I could hook and alter any data statements called after/before a TH call in the file, is there?
02:04:15 <Berengal> I still consider TH a bit of a hack...
02:04:15 <Berengal> It doesn't a good API make
02:04:21 <quicksilver> I didn't mean a TH function to make ADTS.
02:04:29 <quicksilver> just a TH function to generate the lenses from the ADT
02:05:57 <Baughn> That still requires you to name the normal ADT accessors _like _this, and then add an explicit TH call
02:05:57 <sinelaw> I don't know much about TH, but it sounds like "here's something we can't figure how to do properly in Haskell, so do it with TH"
02:05:57 <kmc> TH is a blunt instrument
02:05:57 <kmc> also, super mutants?!?!?
02:06:00 <Berengal> Perhaps quasiquoting could work?
02:06:00 <Baughn> sinelaw: Record syntax /is/ a sore spot. Few people would deny that it needs fixing.
02:06:00 <Baughn> TH works as a way to prototype fixes.
02:06:00 <sinelaw> that;s fair
02:06:00 <Berengal> sinelaw: TH just inserts nodes into the AST at compile time. It's like macro programming
02:06:06 <Berengal> Except uglier than LISP
02:06:12 * Baughn disappears again
02:06:23 * kmc reaches for his Fat Man
02:06:38 <Eduard_Munteanu> LOL, FO3 player :)
02:06:43 <Berengal> [data| Foo = Foo {bar :: Int, baz :: String} |]
02:06:49 <kmc> sinelaw, indeed.  you can consider TH a comparatively lightweight way of adding extensions to GHC
02:06:51 <Berengal> I might be able to live with that...
02:07:06 <kmc> uglier than LISP, far better than C++ templates
02:07:29 <kmc> Haskell has rich abstractions that don't involve low-level metaprogramming
02:07:35 <kmc> so we don't need macros as much as LISP does
02:08:07 <kmc> perhaps the same abstractions exist in LISP, but they are cumbersome to use, because the syntax of LISP is designed for ease of metaprogramming almost to the expense of ease of programming
02:08:07 <Berengal> I still think it might be possible to write a better TH. Something that's a bit more high-level and descriptive than what we've got not
02:08:12 <Berengal> But I'm not TH expert...
02:08:18 <kmc> oh, certainly
02:08:33 <kmc> for starters, the duplication between GHC, TH, and haskell-src-exts is fairly objectionable
02:08:36 <Berengal> And by descriptive I mean declarative
02:09:07 <Peaker> > fix (\x -> sqrt(pi * x))
02:09:11 <lambdabot>   mueval-core: Time limit exceeded
02:09:27 <Peaker> any lazy representation of numbers for which this would work?
02:09:59 <Berengal> kmc: Some duplication cannot be avoided. GHC doesn't care about comments or layout, but haskell-src-exts does (iirc, I haven't used it). It'd be bad to remove a feature for one set of users, or force the other set of users to deal with annoying details such as whitespace in the AST
02:10:07 <Peaker> > iterate ((*pi) . sqrt) pi
02:10:08 <lambdabot>   [3.141592653589793,5.568327996831707,7.413311979421837,8.553739330769334,9....
02:10:56 <kmc> Berengal, true, but it seems like this could be alleviated with sufficiently clever use of parametricity, typeclasses, etc.
02:11:15 <sinelaw> Peaker, that doesn't seem right
02:11:32 <Berengal> kmc: Perhaps, but such things increase complexity as well
02:11:47 <kmc> it's clearly a very hard problem to design something like TH
02:12:02 <Berengal> Indeed
02:12:08 <kmc> i think it's a big step forward from pure static preprocessors, for many tasks
02:12:25 <sinelaw> > iterate ((*pi) .sqrt) 1
02:12:25 <lambdabot>   [1.0,3.141592653589793,5.568327996831707,7.413311979421837,8.55373933076933...
02:12:25 <kmc> the reification feature is used quite a lot
02:13:02 <Veinor> http://www.yooouuutuuube.com/v/?rows=18&cols=18&id=nk2wViKSh_M&startZoom=1
02:13:02 <Veinor> Wrong channel
02:13:38 <Berengal> I think quasiquoting is the better choice as far as providing external APIs go
02:13:38 <kmc> hmm... GHC-API plus GHC LLVM backend with JIT compilation plus super mutant TH...
02:13:38 <kmc> sounds like we could really eliminate the compile time / run time staging boundary
02:13:39 <Berengal> But it does require implementing parsers, and it does introduce arbitrary new syntax
02:13:40 <kmc> and in a strongly statically typed language
02:13:54 <Eduard_Munteanu> BTW, does anyone know a language-independent smart preprocessor?
02:14:03 <kmc> M4 is... well, not as dumb as CPP
02:14:04 <Berengal> Eduard_Munteanu: sed, awk
02:14:05 <Eduard_Munteanu> Something you could use with a variety of languages/compilers.
02:14:15 <Eduard_Munteanu> kmc, hm, M4 could do.
02:14:30 <Berengal> Heck, even perl...
02:14:34 <kmc> or python
02:14:37 <Berengal> Or parsec
02:14:44 <Eduard_Munteanu> Berengal, nah, I mean something that's decent to work with.
02:14:48 <kmc> i've quite often written e.g. a python script that generates LaTeX
02:15:00 <kmc> as an alternative to learning TeX's bizarro world scripting language
02:15:03 <Eduard_Munteanu> Berengal, I don't want to define the metalanguage itself.
02:15:15 * Berengal has written haskell that writes python to write java to write xml
02:15:21 <kmc> oh dear
02:15:23 <Eduard_Munteanu> Berengal, :))
02:15:55 <Eduard_Munteanu> What was that, an instance of "you can solve almost any CS problem with another level of indirection"? :P
02:16:29 <kmc> indeed many problems in general
02:16:40 <Berengal> Eduard_Munteanu: It was easier than writing a haskell<->java interop to get the libraries I needed (same went for haskell<->python)
02:17:32 <Berengal> That is, I generated python so I could include python libraries in my haskell code, which in turn generated java so I could include java libraries
02:18:08 <Eduard_Munteanu> Berengal, um, isn't FFI easier?
02:18:09 <Berengal> Those java libraries in turn generated xml... I didn't feel like decompiling the class files to get at the xsds...
02:18:25 <Eduard_Munteanu> at least for Python compiled code.
02:18:25 <Berengal> Eduard_Munteanu: It is... if you're interoping with C
02:18:40 <kmc> it's good to know a lot of languages
02:18:45 <kmc> Python-C interop is very easy
02:18:50 <kmc> at least with the CPython interpreter
02:18:56 <kmc> Python-Java interop is supposedly easy with Jython
02:19:03 <kmc> and Python-.NET with IronPython
02:19:04 <Eduard_Munteanu> Oh, I thought you could compile Python to something that exposes C-like ABIs.
02:19:06 <Berengal> Yeah, I was using Jython
02:19:23 <Berengal> But I had to provide a Java result, because of company policy etc.
02:19:32 <Eduard_Munteanu> Heh.
02:19:34 <kmc> Eduard_Munteanu, not compile really, but you can link the CPython interpreter into your C program
02:19:44 <kmc> Boost provides a nice C++ wrapper over the reasonably hairy CPython API
02:19:49 * Berengal almost replaced himself with a small haskell-script
02:19:58 <Eduard_Munteanu> :))
02:20:10 <kmc> CPython API is mostly used to provide modules to Python programs, not the other way, but both are possible
02:20:22 <kmc> the easiest way to call C functions from Python is the ctypes module
02:20:49 <kmc> and for completeness i should also mention Pyrex and Cython
02:21:23 <Berengal> I like the Haskell FFI. It doesn't make you write your wrappers in C
02:21:35 <kmc> Cython will actually compile unmodified Python code into C code that calls the CPython API... you save a little speed there already
02:21:48 <DekuNut> Berengal, I JUST opened the chat to ask about the FFI
02:22:41 <DekuNut> I'm trying to understand roughly where the line is on what's built into the compiler, and what can be defined by the user
02:23:14 <DekuNut> In particular, if I wanted to redefine Foreign.C.Types, would I have to modify the compiler itself or would it be possible to create it in other ways?
02:23:15 <kmc> what's definitely built in to the compiler are the new top-level declarations using the "foreign" keyword
02:23:21 <DekuNut> Rofl
02:23:25 <DekuNut> Mind reader kmc?
02:23:29 <kmc> hehe
02:23:54 <kmc> what do you want to change about that module?
02:23:55 <DekuNut> Wait wait, what do you mean by top level?
02:24:03 <kmc> syntactically
02:24:07 <DekuNut> Nothing, I'm just curious as to what CAN be changed without modifying the compiler itself
02:24:20 <DekuNut> Like for example, would I have been able to define my own CDouble
02:24:22 <kmc> with FFI enabled you can write a declaration "foreign import whatever :: IO ()"
02:24:51 <DekuNut> Oh yeah, I figured as much but, what about types and such?
02:25:26 <kmc> i do not know how baked-in the primitive C types are
02:25:50 <Berengal> DekuNut: Take a look at the Foreign.C.Types source
02:26:12 <DekuNut> Berengal, silly question but, where can I find it, all I find in my installed package are .hi files
02:26:16 <kmc> when a C API exposes a compound C type, e.g. ptr to struct, you can define a Haskell type with similar fields, and do the marshalling on the Haskell side
02:26:29 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/src/Foreign-C-Types.html
02:26:31 <Berengal> DekuNut: If you have documentation installed, it should be in .caba/share/docs
02:26:39 <Berengal> Or online, as kmc just proved
02:26:44 <DekuNut> Rofl
02:26:50 <DekuNut> Thank you, I'll take a look now
02:27:10 <phr> zomg, not only is liskell.org empty now, but "liskell" gets no ghits
02:27:15 <Berengal> Oh, and right, it's in base, which is basically untouchable by us mortal men
02:27:24 <kmc> Proof.  exists "src/Foreign-C-Types.html". assumption. Qed.
02:27:26 <Ke> kind of assumption that everyone has per-user installation of ghc
02:27:37 <Ke> <3
02:27:38 <Berengal> phr: Time to create HASP?
02:28:41 <DekuNut> There's some
02:28:46 <DekuNut> Ungodly syntax in here I've never come accross before
02:30:41 <Berengal> It's full of preprocessing mumbojumbo
02:31:32 <DekuNut> "fromIntegral/a->CChar"   fromIntegral = \x -> CChar   (fromIntegral x)
02:32:14 <kmc> that's a GHC pragma
02:32:19 * hackagebot upload: EditTimeReport 1.0 - Query language and report generator for edit logs. (BartSpaans)
02:32:19 <kmc> a RULES pragma
02:32:23 <kmc> rewrite rules for optimization
02:32:57 <DekuNut> I see, I'll read that up now
02:33:07 <kmc> {-# RULES "map/map" map f (map g xs) = map (f . g) xs #-}
02:33:17 <DekuNut> Just found that page rofl
02:33:27 <kmc> rofl
02:38:18 <Ke> btw is cabal or conspiracy or a horse http://www.haskell.org/cabal/FAQ.html , no mention here
02:38:56 <quicksilver> it's the Complete Automated Build system for Applications and Libraries, or something
02:39:25 <dcoutts> Ke: there is no Cabal
02:40:46 <dcoutts> quicksilver: Common Architecture for Building Applications and Libraries
02:40:55 <quicksilver> so close, but no cigar
02:41:50 <Ke> heh
02:46:00 <aleator> Hi, what is status of "cabal interactive" (ticket 382). Does it work
02:46:37 <dcoutts> aleator: I'm not aware of anyone actively working on it? Are you interested in implementing int?
02:46:40 <dcoutts> int/it
02:47:37 <aleator> Maybe. I need something like this butI'm not sure it is exactly what cabal interactive would do
02:48:04 <dcoutts> aleator: it would start hugs/ghci with all the right parameters
02:48:39 <dcoutts> it'd also pre-process the sources as necessary
02:49:41 <aleator> I'm trying to solve the problem, where I have a big project (using c2hs) and I want to use cabal for parts of it and then still be able to use ghci
02:50:40 <dcoutts> aleator: so if you're just looking for a quick hack, then cabal build, that'll pre-process stuff, then launch ghci with some special flags like -idist/build
02:50:44 <aleator> Now cabal places all preprocessed sources under dist/ and I cannot use it to build ghci stuff
02:50:48 <dcoutts> so that it'll find the pre-processed sources
02:50:59 <aleator> Ah!
02:51:51 <DekuNut> I see how types in haskell are mapped now, i.e #define HTYPE_SHORT Int16, but two questions, I read that page on rewrite rules
02:51:53 <DekuNut> and I'm a little lost
02:52:07 <DekuNut> "fromIntegral/a->CChar"   fromIntegral = \x -> CChar   (fromIntegral x)
02:52:19 <DekuNut> It rewrites fromIntegral, to what's on the right of the = right?
02:53:31 <dcoutts> DekuNut: yes, it's a left to right rewrite rule
02:53:32 <quicksilver> if the type matches, yes.
02:53:33 <DekuNut> The rewrite rule page said that, forall x y. f x y = f y x    would go into an infinate loop
02:53:47 <DekuNut> Which makes sense, f y x will just match against f x y again, in which case
02:53:54 <DekuNut> Why doesn't that fromIntegral break into an infinate loop?
02:54:01 <OrangeMage> Hello people. Haskell uberNoob here (started it yesterday). Used a bit of my hacker-wanabee noggin' and wrote a little function to take a string and return a list of every word in the string. It's giving me an error in the difference between the expected and inferred type. Was hoping one of the pro's here could check it out and let me know whats wrong -> http://dpaste.com/145510/
02:54:08 <DekuNut> Seeing as fromIntegral is on the right of the expression, does it not end up constantly rewriting itself?
02:54:09 <quicksilver> DekuNut: because of the type of 'CChar'
02:54:29 <quicksilver> DekuNut: that fromIntegral inside the CChar constructor can't be at the same type.
02:54:54 <DekuNut> Ah so it's not like the C preprocessor, it doesn't just rewrite blindly
02:55:37 <quicksilver> DekuNut: that bit after the /
02:55:39 <quicksilver> DekuNut: that's the type
02:55:47 <quicksilver> OrangeMage: lines 5 and 7 are not consistent with each other
02:55:52 <DekuNut> The rules page described that, what's in the "" are JUST a name
02:55:57 <DekuNut> Didn't say anything about it meaning anything
02:56:07 <Eduard_Munteanu> OrangeMage, the indentation is wrong
02:56:16 <DekuNut> "Each rule has a name, enclosed in double quotes. The name itself has no significance at all. It is only used when reporting how many times the rule fired."
02:56:18 <quicksilver> Eduard_Munteanu: no it's not.
02:56:23 <dcoutts> DekuNut: ghc's intermediate language is fully typed, it's not possible to do ill-typed rewrites.
02:56:25 <OrangeMage> the indentation is custom just to make it clear to read....
02:56:32 <quicksilver> Eduard_Munteanu: there is no indentation-sensitive construct there
02:56:35 <OrangeMage> but the compiler doesnt balk at the indentation...
02:56:36 <Eduard_Munteanu> quicksilver, it's also that.
02:56:56 <quicksilver> OrangeMage: lines 5 and 7 aren't consistent with each other
02:57:07 <quicksilver> OrangeMage: one has [] around the same things the other one has
02:57:09 <quicksilver> that is not what you mean
02:57:12 <Eduard_Munteanu> quicksilver, the if-then-else.
02:57:17 <quicksilver> one of those is build a list and one is build a list of list.
02:57:19 <quicksilver> Eduard_Munteanu: No.
02:57:20 <DekuNut> dcoutts, I see but, I also don't see why the fromIntegral inside CChar is a different type
02:57:27 <quicksilver> Eduard_Munteanu: if-then-else is not an indentation-sensitive language
02:57:33 <quicksilver> DekuNut: because of the type of CChar
02:57:38 <OrangeMage> ..basically the result im trying to get is something like
02:58:08 <OrangeMage> ['a'] : ['b','c'] => ['a','b','c']
02:58:17 <quicksilver> OrangeMage: the syntax for that is
02:58:17 <OrangeMage> and thats what im trying to do there..
02:58:17 <DekuNut> quicksilver, HOld on let me see some examples of fromIntegral
02:58:21 <quicksilver> 'a' : ['b' , 'c']
02:58:37 <quicksilver> OrangeMage: : takes a single element on the left and a list on the right.
02:58:51 <quicksilver> OrangeMage: alternatively, ['a'] ++ ['b','c'] would also be correct
02:58:57 <quicksilver> ++ takes lists on both sides.
02:58:59 <OrangeMage> hmm...so  head xs : [ listWords (tail xs) ] would work ?
02:59:17 <Paczesiowa> is creating fake executable that runs my script still the best way to do cabal test?
02:59:21 <quicksilver> I think you just want "head xs : listWords (tail xs)"
02:59:27 <quicksilver> listWords (tail xs) is already a list
02:59:37 <quicksilver> by wrapping it on [] you're just turning it into a list of lists.
02:59:46 <Eduard_Munteanu> I wouldn't write that that way.
02:59:49 <quicksilver> like the difference between [1,2,3] and [[1,2,3,]]
02:59:49 <shambler> @hoogle append
02:59:49 <lambdabot> Data.ByteString append :: ByteString -> ByteString -> ByteString
02:59:50 <lambdabot> Data.ByteString.Char8 append :: ByteString -> ByteString -> ByteString
02:59:50 <lambdabot> Data.ByteString.Lazy append :: ByteString -> ByteString -> ByteString
03:00:06 <quicksilver> one is a list of three elements, one is a list of one lement containing a list of 3 elements.
03:00:13 <DekuNut> quicksilver, ok so. If I had for example x :: CChar ; x = fromIntegral 15   --   It would be rewritten as:     x :: CChar ; x = (\x -> CChar (fromIntegral x)) 15     right?
03:00:17 <OrangeMage> hmm....well I do want a list of 'strings'
03:00:50 <OrangeMage> it's basically a program that should take something like "I am stuff" and return ["i","am",stuff"}
03:00:58 <quicksilver> DekuNut: that looks right.
03:01:12 <quicksilver> OrangeMage: well I understand what you're doing and I could just write it for you, but that's not the help you're after.
03:01:20 <quicksilver> OrangeMage: you want to understand how to write it yourself, which is fair enough.
03:01:22 <DekuNut> Ok, and it figures out which rule to rewrite based on the part after the slash? Or based on the expression fromIntegral is found in?
03:01:37 <quicksilver> DekuNut: the stuff after the slash is just a name, it's not understood by the compiler
03:01:46 <quicksilver> DekuNut: but it is understood by me and you as a remark on the type.
03:01:53 <OrangeMage> ok....am I on the right track though ?....it's the first program i've written in haskell
03:01:55 <DekuNut> Ok good, because you said '<quicksilver> DekuNut: that bit after the /' earlier
03:01:56 <DekuNut> And confused me
03:02:04 <quicksilver> yes, I'm sorry for being confusing
03:02:06 <quicksilver> it *is* the type
03:02:11 <quicksilver> but it's not there for the compiler to see
03:02:17 <quicksilver> it's just a comment that "this is what the compiler will deduce"
03:02:20 <DekuNut> Yeah, it's what the compiler does that I'm trying to see
03:02:33 <quicksilver> (and it's useful because it appears in the debug output when you ask it to dump optimisations)
03:02:42 <DekuNut> Right well, what is the type of the fromIntegral within the braces then? And why isn't it rewritten?
03:02:57 <quicksilver> DekuNut: do you know what the type of CChar is?
03:03:09 <quicksilver> (the constructor CChar, I mean)
03:03:19 <quicksilver> because if you don't you can't work it out ;)
03:03:22 <quicksilver> and the the compiler *does* know
03:03:27 <DekuNut> No idea, the only definitions of CChar I've seen are INTEGRAL_TYPE(CChar,tyConCChar,"CChar",HTYPE_CHAR)
03:03:28 <quicksilver> so the compiler *can* work it out.
03:03:30 <DekuNut> And I don't know what that produces
03:04:09 <Eduard_Munteanu> OrangeMage, more like listWords xs = let cond = (\= ' ') takeWhile (cond) xs : listWords $ dropWhile (cond) xs
03:04:18 <Eduard_Munteanu> Or something like that, didn't check.
03:04:35 <quicksilver> DekuNut: I think it's something like "newtype CChar = CChar Word32"
03:04:39 <Eduard_Munteanu> *in takeWhile
03:04:56 <quicksilver> DekuNut: depending on your architecture and how C on your platform passes Char parameters.
03:04:57 <OrangeMage> holy cow, you went WAY beyond the expressions i've learnt in Haskell yet...
03:05:08 <OrangeMage> but i can understand the code you've written
03:05:08 <quicksilver> I don't think OrangeMage wants to use dropWhile
03:05:16 <quicksilver> I think OrangeMage wants to write this "by hand" himself
03:05:24 <quicksilver> otherwise he could just use "words" ;)
03:05:26 <OrangeMage> i was just trying to use the most basic stuff i've learnt in haskell
03:05:29 <quicksilver> > words "hello to orangemage"
03:05:30 <lambdabot>   ["hello","to","orangemage"]
03:05:42 <OrangeMage> ...oh so there is a builtin function to do this
03:05:44 <OrangeMage> cool..
03:05:45 <OrangeMage> still...
03:05:48 <DekuNut> quicksilver, right, so the integralChar in the brackets has the type Word32 then? I take it because there's no reule for Word32, that's why it doesn't spin off into a loop?
03:05:49 <Cale> Eduard_Munteanu: The parens around cond aren't needed
03:05:56 <OrangeMage> this is my first Haskell program ever...so lets see
03:05:58 <Eduard_Munteanu> Cale, yeah.
03:07:03 <quicksilver> DekuNut: yes.
03:07:16 <quicksilver> DekuNut: well there might be a different rule for Word32 which might also apply, who knows
03:07:24 <quicksilver> DekuNut: but the *same* rule definitely doesn't apply.
03:07:31 <DekuNut> Ok I see, thanks quicksilver, I appreciate the help
03:07:41 <DekuNut> Now I'm going to go find out what INTEGRAL_TYPE is :o
03:07:55 <quicksilver> something to automaticlaly make the right newtypes I think
03:08:03 <quicksilver> based on your actual architecture at compile time
03:08:09 <DekuNut> Yeah but, I want to see what it expands too
03:10:00 <OrangeMage> 'kay, it's 3 and I cant figure it out. I removed the [] from around head xs but that still doesnt work..
03:11:06 <OrangeMage> any more clues
03:12:43 <Veinor> what're you trying to do?
03:12:44 <Eduard_Munteanu> OrangeMage, you need to return a list of lists.
03:12:53 <OrangeMage> right...
03:12:56 <Eduard_Munteanu> OrangeMage, that is, a list of strings.
03:13:20 <OrangeMage> hmm...
03:14:12 <ceii> OrangeMage, mind posting your current code?
03:14:49 <OrangeMage> http://dpaste.com/145510/
03:15:16 <ceii> thanks
03:15:22 <pozic> OrangeMage: if and else are not aligned correctly?
03:15:45 <OrangeMage> in the code yes, the thing in the dpaste is just how i put it in dpaste for easier viewing
03:15:54 <OrangeMage> compiler doesnt bug me about indentation
03:16:07 <OrangeMage> no it's a type error
03:16:18 <ceii> you removed the [] around the first (head xs) since then, right?
03:16:26 <OrangeMage> Eduard and quicksilver pro'lly figured it out the second they saw it..
03:16:27 <Paczesiowa> @src system
03:16:28 <lambdabot> Source not found. Do you think like you type?
03:16:40 <OrangeMage> yeah..
03:16:44 <OrangeMage> still give's me an error
03:16:45 <pozic> OrangeMage: easier viewing? You must be joking. If you don't show exactly what you input, how do you expect us to give a sane answer?
03:16:55 <idnar> > take 1 [1..]
03:16:56 <lambdabot>   [1]
03:16:59 <idnar> > take 1 []
03:17:00 <lambdabot>   []
03:17:07 <OrangeMage> *sigh*..right..
03:17:15 <ceii> the problem's in your last branch
03:17:17 <pozic> OrangeMage: [ listWords (tail xs) ]
03:17:37 <pozic> OrangeMage: that is not consistent with your last branch.
03:17:43 <ceii> you want to extract the first word from listWords (...) and prepend your x to it
03:18:05 <ceii> I think you'll need to case on the result of listWords to do that
03:18:20 <pozic> OrangeMage: and it also helps if you put a comment near the code explaining what the specification is of the code.
03:18:54 <pozic> Broken code by itself doesn't have any meaning, unless you wrote it yourself.
03:18:57 <OrangeMage> right, so thats a good point....how do you put a omment in haskell......I was reading something about putting a '--' but that said that it comments the entire line...
03:18:59 <ceii> also, all your branches presuppose a non-empty list
03:19:09 <pozic> OrangeMage: -- oh look a comment
03:19:11 <ceii> you should add the terminal case for the empty list
03:19:16 <pozic> OrangeMage: {- Oh, look another -}
03:19:17 <Eduard_Munteanu> OrangeMage, the comment starts at the --\
03:19:19 <OrangeMage> right....
03:19:22 <OrangeMage> ok cool..
03:19:22 <ceii> or {- look another comment -}
03:19:23 <Eduard_Munteanu> s/\\//
03:19:33 <Eduard_Munteanu> OrangeMage, like in C++ style comments
03:19:41 <OrangeMage> i spent like 10 minutes googling 'haskell wiki comments' and couldnt find anything about it
03:19:51 <pozic> OrangeMage: a bad investment of time.
03:20:00 <pozic> OrangeMage: just read the report.
03:20:16 <pozic> OrangeMage: Haskell98 report in google terms.
03:20:18 <ceii> now that's a bed investment
03:20:26 <ceii> when you don't already know the language
03:20:35 <OrangeMage> hmm....
03:20:36 <OrangeMage> ok
03:20:52 <pozic> ceii: it pretty much is the definition of the language, so an excellent resource if you don't know it yet.
03:21:09 <ceii> actually, you might be right
03:21:09 <pozic> ceii: it doesn't read quite as fast an any other document, but the signal/noise ratio is very high.
03:21:16 <ceii> at least for syntactic questions
03:22:01 <OrangeMage> well I'm scanning over this and for a haskell noob like me it doesnt really seem that intuitive...you guys still suggest trudging through it ?
03:22:20 <pozic> OrangeMage: through what?
03:22:36 <OrangeMage> Haskell 98 report
03:22:38 <ceii> nah, he only said you could have looked for the comment syntax in it
03:22:45 <OrangeMage> oh...
03:22:57 <OrangeMage> so it's like a reference...
03:23:00 <OrangeMage> ill keep that in mind
03:23:05 <pozic> http://www.haskell.org/onlinereport/intro.html seems to start easily.
03:23:07 <ceii> but do try to follow another tutorial
03:23:21 <OrangeMage> currently im just trying to get my feet wet through Real world haskell
03:23:27 <ceii> okay
03:23:32 <pozic> OrangeMage: the thing is, the report is the primary source.
03:23:37 <OrangeMage> that program is just what i improvised over reading the first chapter....:\
03:23:47 <Berengal> Read the report after you've gained some familiarity with the language
03:23:51 <OrangeMage> right...
03:24:02 <Berengal> Otherwise you won't have any hooks to hang any new knowledge on
03:24:11 <pozic> OrangeMage: you can also better begin with "Programming in Haskell" for example.
03:24:13 <ceii> btw, is there anything about pattern matching in that chapter?
03:24:29 <OrangeMage> Chap 1 ?.....
03:24:32 <ceii> yes
03:24:34 <Cale> There are some things which are described in the Report that seem to be left out of many tutorials somehow.
03:24:48 <pozic> OrangeMage: I don't think RWH is a good book for a complete beginner.
03:24:49 <ElfArmy> I seem to remember that pattern matching is brought in fairly early.
03:25:05 <OrangeMage> I've heard that term through around when reading about haskell, but no, not in the first chapter, and I have no idea what it is about
03:25:11 <Berengal> OrangeMage: Are you familiar with programming in other languages? Other functional languages?
03:25:21 <Cale> ElfArmy: In what?
03:25:22 <pozic> OrangeMage: it is more for people who already had a functional programming course (or two) and then think "well, can I use this Haskell thing also for "real things""?
03:25:35 <OrangeMage> Yeah, I'm in my last year of CIS..
03:25:37 <ElfArmy> Cale, RWH
03:25:51 <Cale> ElfArmy: It's essential to Haskell programming, so you could expect it to be near the beginning of any text.
03:26:17 <ceii> defining your listWords function by pattern matching would make it _way_ easier to write
03:26:23 <OrangeMage> Found haskell cool when I was reading about it in some blog ages ago. Bookmarked it.....visited it again recently.....have some time, so stopped coding Django and have trying to pick it up..
03:26:25 <OrangeMage> hmm...
03:26:26 <Cale> It's really hard to get anything done without having at least a rough idea of how pattern matching works
03:26:33 <ceii> so you might want to read on until you get to that
03:26:37 <OrangeMage> well regardless....it's 'possible' the way im doing it right ?...
03:26:40 <ceii> yes
03:26:49 <OrangeMage> i mean I get the idea you guys have the solution on the tip of your fingers..
03:26:55 <ceii> first thing, you need a case for the empty list
03:27:10 <OrangeMage> I'm not coming from a functional bg, so this was just some kinda of spaghetti mess i threw together..
03:27:14 <Cale> OrangeMage: Sorry, what are you trying to do?
03:27:17 <ceii> all your branches use (head xs) so they presuppose the list is non-empty
03:27:27 <Berengal> Everything becomes easy once you've broken it down into base- and inductive cases
03:27:40 <Cale> oh, found your paste
03:27:52 <OrangeMage> ceii: well what you are saying is that I have to consider the possibility of an empty list ?
03:28:07 <ceii> yes, because your recursion will eventually reach it
03:28:13 <OrangeMage> ...........OH..
03:28:15 <Berengal> hopefully...
03:28:20 <OrangeMage> yeah, i think i did do something
03:28:26 <OrangeMage> and the compiler worked
03:28:31 <OrangeMage> and i was wondering what did i do..
03:28:34 <ceii> lol
03:28:42 <Cale> OrangeMage: Yeah, try to pretend that the 'head' and 'tail' functions don't exist, and it will help :)
03:28:46 <OrangeMage> yeah....hate it when it works without me knowing why...
03:29:12 <OrangeMage> well, i thought 'head' and 'tail' were the most basic functions to use.....is there something more basic ?
03:29:17 <Cale> OrangeMage: Instead of using head and tail, define listWords for [] and (x:xs)
03:29:25 <Berengal> OrangeMage: Try considering the two branches independently. What do you do in the empty list case? What do you do in the non-empty list case?
03:29:41 <ceii> what Cale's talking about: pattern matching
03:29:46 <Cale> (actually, you might have to be more subtle than that for the actual problem here)
03:30:21 <Cale> But for instance, if you instead put:
03:30:27 <Cale> listWords (x:xs) = ...
03:30:29 <OrangeMage> before we go on I gotta tell you guys, I'm amazed at how helpful you all are....like seriously, kudos to the haskell community. I come from programming Django, and when I post a query there (usually something fairly high-level too), I go out for lunch and come back before I've had a reponse (usually "Read the Docs"...)
03:30:35 <Berengal> Well, breaking down problems into subproblems is a recursive algorithm :)
03:30:36 <Cale> then x refers to the head of the list, and xs to the tail
03:30:45 <ceii> (he hasn't read about pattern matching yet)
03:31:12 <Cale> and if you write listWords [] = ...  then this definition is only used when the list is empty
03:31:14 <OrangeMage> I feel like the little kid who hasnt learnt about sex now.....: \
03:31:27 <Berengal> Haskell makes you feel dumb at times...
03:31:38 <ceii> basically, you can write your definition in several clauses
03:31:52 <ceii> and for each clause, you specify the "shape" of the arguments
03:31:52 <Berengal> But then all off a sudden you've done the impossible, and you forgive it
03:32:06 <Cale> Every list is either the empty list, written [], or it is a nonempty list with a first element x and tail xs, written (x:xs)
03:32:09 <ceii> so you might define listWords [] = ...
03:32:10 --- mode: irc.freenode.net set +o ChanServ
03:32:13 <ceii> for the empty list case
03:32:19 <OrangeMage> I think I'll go back to RWH tomorrow after a solid sleep and read another chapter before tackling this gain...
03:32:26 <ceii> and listWords (x:xs) = ...
03:32:33 <Cale> When we write functions, we can make use of this:
03:32:38 <Berengal> OrangeMage: LYAH is also recommended, to get a grasp of the language basics
03:32:39 <ceii> for the case where there's a first element, x
03:32:40 <Berengal> @where LYAH
03:32:41 <lambdabot> http://www.learnyouahaskell.com/
03:32:44 <Cale> > let sum [] = 0; sum (x:xs) = x + sum xs in sum [1,2,3]
03:32:45 <lambdabot>   6
03:32:49 <OrangeMage> oh yeah
03:32:58 <OrangeMage> LYAH is where i was trying to learn from to begin with
03:33:03 <OrangeMage> i finished the first few pages..
03:33:08 <OrangeMage> got into type classes or something
03:33:12 <OrangeMage> and totally lost it..
03:33:22 <Cale> So here, I've defined the sum of an empty list to be 0, and then the sum of a nonempty list to be the first element, plus the sum of the tail.
03:33:40 <Berengal> OrangeMage: It helps to read more than one tutorial, and it's perfectly fine to jump between them.
03:33:55 <OrangeMage> Yeah, I have that on constant open tab too..
03:34:09 <tensorpudding> RWH is a good source, especially the online version which has comments
03:34:09 <OrangeMage> I'll go back to it after another chapter or two of RWH
03:34:16 <Cale> another thing to note is that if/then/else is naturally indented in a somewhat different way
03:34:26 <Cale> You should write it like:
03:34:29 <Cale> if foo
03:34:31 <Cale>    then bar
03:34:33 <Cale>    else quux
03:35:02 <Cale> The important thing being that the 'then' and 'else' are siblings, so they align vertically, and they're part of the 'if', so they're indented more.
03:35:02 <tensorpudding> though you don't have to indent if/then/else that way, it makes it more readable if you do
03:35:18 <tensorpudding> there is a similar design with case
03:35:38 <Cale> Right, it's not enforced, but the style you were using has some problems with it if used inside 'do', which you'll learn about later.
03:35:56 <tensorpudding> if it's short using one line is better
03:36:11 <OrangeMage> Quick question before I leave..
03:36:31 <Cale> sure :)
03:36:32 <OrangeMage> whats the most 'real world' application that haskell is used for. I mean like a web site or something....
03:36:37 <tensorpudding> if it is really long or you want to nest, you probably should be using guarded statements
03:36:52 <fasta> How would you call a function which computes the distance to the intersection point of the bisectors of two vertices from the first vertex?
03:37:00 <tensorpudding> there is xmonad, the X11 tiling window manager
03:37:11 <OrangeMage> Yeah I wiki'd that....that was interesting
03:37:11 <Berengal> tensorpudding: Or abuse lazyness and `where'. That's one's always an ice-breaker at parties
03:37:16 <fasta> OrangeMage, open-source?
03:37:17 <OrangeMage> there's darcs too i guess...
03:37:28 <Berengal> gitit is nice
03:37:29 <fasta> OrangeMage, closed-source there is quite a lot, I think.
03:37:35 <OrangeMage> is there ?...
03:37:35 <Berengal> And real-world... it's a wiki
03:37:37 <tensorpudding> and a major Perl 6 implementation called Pugs
03:37:39 <Cale> OrangeMage: Well, there are a lot of things now... it's used to design crypto hardware and other high-assurance stuff, in the financial industry...
03:38:03 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_industry
03:38:22 <OrangeMage> yeah I checked that.....saw a lot of banks and financial institutions using it
03:38:26 <tensorpudding> there is a cryto DSL in haskell
03:38:34 <Berengal> cryptol?
03:38:40 <tensorpudding> and agda, the dependently-typed proof language
03:38:54 <Cale> Well, the crypto stuff is separate from the financial stuff, in case that was unclear.
03:39:36 <OrangeMage> kay, thanks a lot people. It's been an interesting, definitely enlightening 20 minutes. I'm sure I'll visit frequently as I get more familiar with haskell. I can only hope to get good enough at it to write something applicable in the near future. Cheers and thanks again.
03:39:43 <tensorpudding> hackage has a lot of packages, though a lot of them are binding libraries to this than and the other
03:39:47 <fasta> OrangeMage, calling C code is really easy, though. Calling good C++ is relatively easy too, calling bad C++ is a nightmare, though.
03:40:07 <Berengal> Bad C++ is always a nightmare...
03:40:20 <fasta> The concept of a build-engineer scares me.
03:40:31 <Cale> It works well in a lot of areas, but it seems to give the most leverage compared to other things in cases where the domain is fairly complicated, and where you'd really like to be able to construct a domain-specific language in which to express the solutions to your problems
03:41:00 <Berengal> fasta: As in "the one who builds the software"?
03:41:00 <fasta> That should be an automated process solved in the language (and it has already been a solved problem for more than 30 years).
03:41:04 <Cale> It's a great language in which to write compilers and interpreters, but also you can very nicely embed domain specific languages into Haskell.
03:41:17 <fasta> Berengal, as in a complete person allocated to doing that all day long.
03:41:38 <tensorpudding> hmm, forgot to mention the three or so web frameworks that are around
03:41:53 <Cale> ah, missed the disconnect :)
03:42:06 <Berengal> fasta: How can you even program like that? I require input from my programs less than a minute after writing them, or I'll loose the flow
03:42:42 <fasta> Berengal, a build should be ./build.sh or ./configure && make, but requiring anything else basically guarantees your project is going to fail.
03:43:05 --- mode: irc.freenode.net set +o ChanServ
03:43:08 <fasta> Berengal, what do you mean?
03:43:27 <Berengal> fasta: I mean I wouldn't survive without REPLs
03:43:39 <osfameron> tests help with that too
03:43:44 <Berengal> Yes, they do
03:44:05 <osfameron> is there something like SLIME for haskell?
03:44:06 <fasta> Berengal, I also don't like the way C++ works in general, although there are also C++ interpreters.
03:44:09 <Berengal> Though sometimes I feel like TDD is a bad substitution for a REPL
03:44:19 <Paczesiowa> osfameron: haskell-mode?
03:44:25 <fasta> Berengal, I try to write the code to be obviously correct.
03:44:31 <osfameron> Paczesiowa: that's in emacs too?
03:44:32 <Berengal> fasta: I don't try. I do :P
03:44:36 <Paczesiowa> osfameron: yes
03:44:54 <osfameron> this is why I should try to learn emacs again sometime...
03:44:55 * osfameron sighs
03:44:56 <Berengal> fasta: But then I need to check the compiler doesn't have any bugs
03:44:59 <Paczesiowa> osfameron: it's probably not even close to slime, but I've never used slime so...
03:45:03 <fasta> Berengal, so, I use the REPL to just see that it compiles, which probably means it is close to working.
03:45:20 <tensorpudding> everyone is saying that haskell-mode is great
03:45:22 * osfameron neither tbh... I tried on Windows, years back, and couldn't even install a version of LISP that it liked
03:45:34 <osfameron> is there a haskell-mode equiv for vim?
03:45:35 <tensorpudding> which it is, but so are a lot of emacs modes
03:45:38 <fasta> No, there is nothing like SLIME for Haskell.
03:45:47 <Paczesiowa> what's so great about slime?
03:45:52 <fasta> There are only things which people claim work, which don't.
03:45:55 <Berengal> fasta: A lack of REPL is somewhat alleviated by a clever IDE, but the fast response, and ability to test distinct parts of your program in separation is hard to emulate
03:46:14 <fasta> An IDE makes people write code which is incorrect per standards.
03:46:15 <tensorpudding> SLIME has a level of integration that is hard to get
03:46:37 <fasta> An IDE makes people think they are writing correct software, while in fact it only works on their machine.
03:46:52 <Jafet> SLIME relies on a lot of features of Lisp implementations that you don't get in Haskell yet
03:46:57 <Berengal> fasta: Not always.
03:46:59 <osfameron> fasta: that's not necessarily an immutable feature of IDEs
03:47:00 <fasta> The difference between a C++ Windows developer and let's say a Solaris developer.
03:47:00 <Paczesiowa> fasta: same thing with "it compiles -> it works"
03:47:05 <Jafet> fasta, what nonsense is that
03:47:29 <Berengal> fasta: At work I program in Java, and we've recently switched to building with maven. Now life's much easier
03:47:40 <fasta> Jafet, it is a rule which holds in >50% of the cases, so it has predictive value and thus is not non-sense.
03:47:44 <Jafet> Or are you using a funny definition of IDE that happens to fit whatever you're saying?
03:47:56 <fasta> Jafet, Visual Studio?
03:48:03 <Jafet> Or are you trolling? That sounds likely, so carry on
03:48:08 <Jafet> Ok.
03:48:31 <Berengal> NetBeans even uses maven almost exclusively in maven-projects now, which means that if it works in NetBeans it works in maven
03:48:40 <Berengal> (Which wasn't always the case before)
03:48:49 <osfameron> IDEs can abstract the build process, which either makes things easier or harder... when I briefly played with J2ME I found that I didn't even understand how the IDE build system worked, so dropped down to Ant scripts instead
03:48:58 <fasta> I liked NetBeans for Java development 4 years ago already.
03:49:11 <tensorpudding> i got the idea that writing java code outside of an IDE is a difficult proposition, to say the least
03:49:51 <Jafet> Adding Java code to existing Java code, perhaps.
03:49:56 <fasta> osfameron, it is just that the people who use them tend to work in that way.
03:49:59 <Berengal> tensorpudding: It's tedious to the extreme, but not especially difficult (unless you consider the tedious-tax, which _is_ real)
03:50:01 <Jafet> Unless you care to read through most of the existing Java code
03:50:12 <fasta> osfameron, if you would use it or let's say mauke, that would not happen.
03:50:35 <tensorpudding> i remember mauke and i had a rather tedious argument over emacs
03:50:49 <fasta> tensorpudding, which was?
03:50:49 <Jafet> fasta, that isn't even a relevant argument against IDEs then
03:51:00 <fasta> Jafet, I am not against IDEs.
03:51:07 <fasta> Jafet, just how Visual Studio works.
03:51:23 <fasta> Jafet, and the social effects it has.
03:51:27 <tensorpudding> he hated emacs, and argued that everything it did made it more difficult to use than vim
03:51:32 <Jafet> It enables incompetent developers to feel competent. So?
03:51:45 <Gilly> Anyone know what's the best way to integrate LaTeX generated formulas with webpages nowadays? I think that there are still modern browsers that don't support MathML. So plain pictures or jsmath or something else?
03:51:56 <fasta> Jafet, so, there is more software which only works on Windows.
03:52:00 <tensorpudding> and i disagreed politely
03:52:02 <fasta> For some value of working.
03:52:04 * Lycurgus uses Latex2HTML.
03:52:10 <Gilly> I think pandoc had support for at least jsmath.
03:52:25 <Jafet> There has been, is, and will always be crap software. That doesn't mean anything about Visual Studio
03:52:46 <Jafet> You could blame, oh, Turbo Pascal, ten years ago, you could.
03:53:02 <tensorpudding> you can criticize visual studio for its UI if you wanted
03:53:40 <jystic> visual studio is nothing more than a hosting platform for ReSharper =)
03:53:47 <Gilly> Lycurgus: Going to check that out - thanks.
03:53:48 <fasta> Jafet, the problem is that when someone publishes some code using Visual Studio he/she basically forces you to also use Visual Studio.
03:53:57 <osfameron> is resharper good?
03:54:15 <Jafet> fasta, the same thing happens with autoshit
03:54:18 <Jafet> So?
03:54:23 <jystic> it makes life is visual studio bearable :P so yeah, definately
03:54:24 <Paczesiowa> fasta: s/Visual Studio/GPL/ :)
03:54:31 <Ke> Jafet: not with automako though
03:54:36 <Ke> gaah
03:54:41 * osfameron enjoyed using IntelliJ IDEA briefly, made Java programming almost fun.  Never played with resharper though
03:54:43 <Ke> Jafet: not with cmake though
03:54:44 <Jafet> automook is the worst of all
03:54:54 <Ke> fixec
03:54:56 <fasta> Jafet, with the difference that autoshit always works on Linux at least, since all the external libraries are already packaged.
03:54:56 <Ke> fixed
03:55:05 <Jafet> fasta, you think?
03:55:08 <Ke> typomasta is hree
03:55:13 <fasta> Jafet, yes, I think.
03:55:18 <jystic> osfameron: ReSharper brings most of IntelliJ IDEA to C#, just a shame it's hosted in the visual studio memory hog machine
03:55:27 <fasta> Jafet, or maybe I stopped using craptastic software.
03:55:34 <osfameron> this is the nice thing about using dynamic languages.  Perl has a (fairly) standard build system (or at least, a choice between only 2 standards :-) and it mostly JustWorks.
03:55:34 <Jafet> fasta, even if that was correct, so what? unix and windows. Same difference.
03:56:01 <Geheimdienst> hey guys, i'm trying to install darcs on my shiny new arch linux. the problem is that cabal can't compile array-0.2 (a dependency of darcs)
03:56:06 <fasta> Jafet, no, since you can install MingW on Windows and still build it.
03:56:10 <fasta> Jafet, or Cygwin.
03:56:22 <Jafet> Hacks.
03:56:24 <Geheimdienst> any help? cabal's output is here: http://pastebin.com/d841e57a
03:56:25 <tensorpudding> installing darcs on cabal?
03:56:37 <Geheimdienst> well, doing "cabal install darcs"
03:57:17 <Geheimdienst> (that's a normal thing to do, right?)
03:57:18 <jystic> fasta: why do you need to use visual studio with published windows code? if it's .net you're talking about you can use msbuild to compile visual studio's .sln .csproj etc files no problem, no IDE
03:57:38 <tensorpudding> oh..um
03:57:44 <dcoutts> Geheimdienst: you're running "install", not "upgrade" right?
03:57:44 <tensorpudding> your error message is in swedish
03:58:02 <Geheimdienst> dcoutts, yes, that's what i did
03:58:26 <Geheimdienst> tensorpudding: oh, i forgot to say LANG=C, sorry ...
03:58:42 <dcoutts> Geheimdienst: can you paste the output of "cabal install darcs --dry-run -v"
03:59:26 <tensorpudding> but anyway, it seems that the error is with some C code in compiling the unix package
03:59:27 <fasta> jystic, you don't need an installation of Visual Studio to do that? I didn't know that.
03:59:40 <Geheimdienst> in line 262, cabal tries to compile file "6 of 10". this fails and 7/8/9/10 are never attempted
03:59:52 <dcoutts> no, the problem is that it's rebuilding the array package at all
04:00:05 <jystic> yeah, you should be able to build any .net only stuff with just the .NET SDK
04:00:11 <Geheimdienst> dcoutts: is that any different from "cabal install darcs -v"? because that's what i posted to pastebin ...
04:00:15 <jystic> C++ is out of the question though
04:00:21 <dcoutts> Geheimdienst: yes, it's different
04:00:22 <jystic> you need visual studio for that
04:00:35 <fasta> jystic, it was C++ that I was talking about.
04:00:43 <dcoutts> Geheimdienst: it says what it's going to install, and some indication of why
04:00:51 <fasta> jystic, I don't think I know anything implemented on .NET which doesn't exist in C++.
04:02:23 <Geheimdienst> dcoutts, cabal info darcs tells me that darcs has a dependency of "array >=0.1 && <0.3"
04:02:47 <tensorpudding> i had a brief desire to try f#, but trying to get mono to play with it made that desire evaporate
04:02:47 <Geheimdienst> so it seems pretty expected that cabal first installs array-0.2 ...
04:03:18 <tener> does -XPackageImports extension support package versions?
04:03:20 <tensorpudding> have you done a cabal update first?
04:03:34 <dcoutts> Geheimdienst: no, it's not expected. You've already got array installed.
04:04:08 <dcoutts> tener: yes, but only exact versions.
04:04:21 <Geheimdienst> tensorpudding: yes, i set up ghc and cabal just this morning
04:04:34 <dcoutts> Geheimdienst: can you paste the output of "cabal install darcs --dry-run -v"
04:05:53 <tener> dcoutts: I'm trying to compile something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15927#a15927
04:06:53 <Geheimdienst> dcoutts: sorry, not right now -- i'm booted into the old ubuntu, i'd have to reboot into the misbehaving arch linux ...
04:07:18 <tener> dcoutts: the idea is to import the same module from different versions of package and provide code for migration between datatypes from both versions
04:07:23 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15928#a15928 <- Can someone with ghc 6.12 try to install happstack-data?
04:07:51 <Geheimdienst> but you're saying that the array package should be installed already and cabal should not try to reinstall it, right?
04:08:59 <dcoutts> Geheimdienst: right, sometimes it's necessary to reinstall packages to make dependencies consistent, but it should not be necessary to reinstall array.
04:09:19 <dcoutts> that's why I wanted to see the output of --dry-run -v, to see why it wants to reinstall array
04:09:47 <dcoutts> tener: hmm, I'm mistaken, there's no mention of version http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports
04:10:20 <dcoutts> tener: I'd assumed "foo-1.0" just worked
04:10:31 <Berengal> dcoutts: I think I've been able to use versions there
04:10:38 <dcoutts> ok
04:10:51 <Berengal> But they have to be exact...
04:11:06 <dcoutts> tener: so does that actually work then?
04:11:18 <tener> dcoutts: no, not really
04:11:28 <tener> dcoutts: even further: if i strip one import
04:11:54 <tener> dcoutts: and compile with exact version (ghc -package foo-version file.hs)
04:12:03 <tener> dcoutts: it still fails
04:12:25 <Geheimdienst> ok, i'm getting an idea of what's happening ... arch gave me ghc-6.12, which includes array-0.3. however, darcs depends on array < 0.3 ... that's why cabal tries to download + install array-0.2
04:12:32 <Berengal> tener: Are you sure the version is exact? No spelling errors?
04:12:43 <dcoutts> Geheimdienst: ah, yes, that's it
04:13:26 <tener> Berengal: yes, i'm pretty sure
04:14:41 <tener> see here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15927#a15929
04:15:21 <tener> it's funny: if I specify one version, it yells for another one
04:16:20 <Berengal> tener: In that case, it's not possible then. Perhaps if you jump through some hoops and wait for the next full moon..
04:18:17 <Geheimdienst> i guess it boils down to "ghc-6.12 is too new for darcs". so what do i do? should i install 6.10 alongside, just for darcs?
04:18:20 <tener> Berengal: it seems my setup violates some assumptions regarding package versions in GHC
04:18:43 <Paczesiowa> didn't some xmonad guy boast huge uptime and using xmonad since early alphas without restarts? that kind of thing would require migrating data types or extra-stable api.
04:19:25 <tener> Berengal: interestingly, removing version from qualified import does make it compile
04:19:27 <Berengal> happstack has some provisions for migrating datatypes...
04:19:30 <Geheimdienst> or is there a newer darcs that can swallow array-0.3?
04:19:52 <Berengal> tener: But do you get the versions you want, or does it just select one version?
04:20:32 <Cale> Paczesiowa: It's probably a bit of a lie, in that what XMonad does to change configuration is to recompile itself and exec the resulting executable.
04:21:20 <Paczesiowa> Cale: I know, that's why it would need some migration eventually
04:21:27 <tener> Berengal: if I don't specify version in import, it falls back to default algorithm for picking up packages
04:21:49 <Berengal> tener: So it just picks one. No wonder it works then
04:21:51 <tener> Berengal: default is the most recent one, but I can overload it with -package or -hide-package
04:22:47 <Cale> Paczesiowa: I'm not really sure how much valuable state there is to migrate outside of the actual source code.
04:23:16 <Cale> Paczesiowa: At worst I would think you'd just lose the current arrangement of your windows.
04:24:18 <Geheimdienst> ok i gotta run. thanks for the help so far :-) catch you later
04:24:34 <Paczesiowa> Cale: you don't have to keep some handles to those windows?
04:25:00 <ceii> XMonad jsut Shows all its state into a property of the root window
04:25:04 <ceii> and Reads it back
04:25:11 <ceii> it fails as soon as a type changes somewhere
04:25:18 <Cale> Paczesiowa: I don't think so. X will keep windows open even if the window manager dies, and starting another window manager after will typically result in all those existing windows being managed.
04:25:24 <_Fury> Hi :)
04:25:42 <ceii> hello
04:25:48 <Cale> (In the past, I've switched between various WMs while X was running without losing my programs)
04:26:01 <quicksilver> Cale: except any programs which were children of the WM :)
04:26:06 <quicksilver> which depends how you launch programs
04:26:08 <Cale> Well, yeah.
04:26:10 <tener> Berengal: happstack has Happstack.Data.Migrate module with unhelpful function migrate :: a -> b
04:26:17 <quicksilver> but in the 'old days' launching them from the fvwm menu was a common way.
04:26:28 <tener> Berengal: to implement it i would need two versions of the same module
04:26:34 <Cale> Ideally, the WM would be disowning processes it created.
04:26:35 <quicksilver> these days people tend to launch them from new fangled docks and task bars which aren't children of the WM, so it works.
04:26:48 <Berengal> tener: Take a look at the happstack tutorial for how to properly use it
04:26:49 <Paczesiowa> Cale: that's boring... where's the fun of keeping all the dynamic state between reloads
04:26:54 <quicksilver> Cale: well it should reparent them to the session
04:26:58 <tener> Berengal: or perhaps I can deal with some proxy package... hmm...
04:27:05 <quicksilver> Cale: but I'm not sure there is an easy way to deduce what the session is.
04:27:09 <tener> Berengal: i'll try it
04:27:24 <Cale> Paczesiowa: I think it does try to do that, but I'm not sure if it's expected to work between versions. I don't use XMonad myself.
04:29:00 <_Fury> Im trying to do sth.  with monads http://pastebin.com/d294cbb5b but i get the error "parse error on input `='" and i cant figure out why.... can so. help?
04:29:02 <tener> XMonad used to keep the state as input arguments of another instance
04:29:10 <tener> I'm not sure it does that now
04:29:49 <Axman6> fasta: you need to indent 'S t2 = f x' so that it lines up with '(s2, x) = t1 s1'
04:30:14 <Axman6> uhm, _Fury not fasta
04:30:18 <_Fury> ok ill try thanks :)
04:31:03 <Axman6> _Fury: http://pastebin.com/d1fa5e4f7
04:31:06 <_Fury> i still get the same error :(
04:31:40 <Cale> tabs!
04:31:45 <Axman6> don't use tabs
04:31:46 <Cale> There are tabs in your source.
04:31:48 <_Fury> the = in the 3 line
04:32:01 <_Fury> no tabs?
04:32:03 <Axman6> _Fury: don't ever use tabs
04:32:06 <Cale> Configure your editor to properly convert tabs to spaces
04:32:19 <_Fury> ok ill try taht
04:32:26 <Cale> It matters how things line up, and tabs make lining things up a horrible nightmare.
04:32:38 <quicksilver> or use tabs carefully and consistently if you prefer. But it's much easier not to use them.
04:33:01 <Axman6> Cale: unless you set tabs to be shown as eight spaces
04:33:11 <quicksilver> in particular if you did like using them, you need a newline after every construct which introduces layout
04:33:19 <quicksilver> which in practice I find wastes Vertical Space
04:33:26 <Cale> Axman6: yes, but even then, don't use them, because it will just create problems when you try to work with other people
04:33:42 <quicksilver> very important in this age of stupidly designed monitors with aspect ratios designed for watching films not doing work.
04:33:43 <Axman6> indeed
04:34:07 <tener> Berengal: I skimmed through http://nhlab.blogspot.com/2008/12/data-migration-with-happs-data.html and paragraph titled "Using separate files to manage type history" says it all: you need another copy of files around
04:34:25 <Berengal> tener: There you go then...
04:34:36 <Cale> quicksilver: This age of *absurdly inexpensive* monitors with aspect ratios designed for watching films and not doing work.
04:34:43 <tener> Berengal: this setup is pretty obvious
04:34:55 <quicksilver> Cale: well, that too.
04:34:58 <tener> Berengal: i wanted something better
04:35:12 <quicksilver> Cale: but it's not convenient to buy two and mount them one above another however tempting the idea is :)
04:35:16 <mux> I'm perfectly happy with 16/10th monitors for doing work
04:35:58 <tener> Berengal: keeping another copy of files is not satisfactory
04:36:22 <_Fury> i still get the same error :(
04:37:04 <Cale> It angers me slightly to see 24 inch widescreen LCD displays for $200 when I think about how much I paid for this 17 inch display. :)
04:37:12 <_Fury> it looks like that now: http://pastebin.com/d33c6d89a
04:37:40 <_Fury> 24 inch for $200...
04:37:56 <Cale> _Fury: the S t2 is indented one space too many, making it part of the previous line
04:37:57 <_Fury> i payed 250 € for my 22"
04:38:42 <Cale> http://www.tigerdirect.ca/applications/searchtools/item-Details.asp?EdpNo=5532033&sku=P109-2410%20CA
04:38:49 <_Fury> thanks cale, now it works... i did not know that indentation is that important... :(
04:39:20 <tensorpudding> indentation is important
04:39:31 <Cale> _Fury: Basically, the rule is that if things are siblings, they must align vertically (start in the same column), and if one thing is the child of another, it should be indented more
04:39:34 <quicksilver> _Fury: it's not, unless you choose to use it.
04:39:46 <tensorpudding> if the language uses significant whitespace
04:39:47 <quicksilver> _Fury: you could have used {} and ; instead, and then indentation would have been ignored.
04:40:04 <quicksilver> but after initial anger, most people prefer the whitespace I find.
04:40:09 <Cale> (but almost nobody uses that style unless compressing things onto one line)
04:40:15 <ceii> quicksilver and your code would have been ignored by any other haskell programmer
04:40:22 <quicksilver> ceii: rubbish
04:40:22 <_Fury> yes... it is like in python. I did not know that
04:40:42 <quicksilver> why would a haskell programmer ignore code that happened to use {;} ?
04:41:04 <ceii> I would, it's way too hard to read
04:41:16 <quicksilver> "and your code would have been ignored by ceii"
04:41:22 <ceii> might be because I haven't seen Java code for too long though
04:41:23 <quicksilver> you can say that and I won't argue.
04:41:32 <ceii> alright, I'll correct
04:41:40 <tensorpudding> writing code that uses { } and ; to format the code is not invalid, but it's much less pleasant to read
04:43:10 <tensorpudding> despite a large number of languages not having significant whitespace, i'm not sure what makes people so hostile to it
04:43:25 * osfameron likes the haskell indentation rules.  They don't reduce its expressive power, and seem relatively sane
04:43:49 <osfameron> they do still confuse me sometimes, but I'm happy to put that down to me... :)
04:44:36 <_Fury> now i can use sth. like this : http://pastebin.com/d5dc18ee7
04:45:00 <_Fury> an execute it with run testdo
04:46:28 <dansa> what's a intuitive difference between a section and partial application?
04:46:40 <dansa>        an
04:46:55 <mux> a section is just partial application applied to an infix operator; so there can be a right or a left section
04:46:56 <dansa> a section is something like (2^), right?
04:46:59 <mux> I don't see other differences
04:47:08 <dansa> yeah; okay;
04:47:13 <tensorpudding> _Fury: what do you mean by run testdo?
04:47:21 <Botje> dansa: a section allows you to give the SECOND argument
04:47:37 <dansa> Botje: oh, that's true; that is a difference
04:47:47 <Botje> whereas a partial application needs a flip
04:48:05 <quicksilver> I would still call a section a kind of partial application
04:48:25 <Botje> yup
04:48:29 <quicksilver> if haskell supported the syntax "foo _ a" to partially apply on a non-first argument
04:48:38 <quicksilver> I think we'd still call it a kind of partial application.
04:48:53 <dansa> is a section mere syntax sugar for partial application?
04:48:55 <quicksilver> although there is something slightly deeper going on with the 'normal way'
04:49:00 <_Fury> run is a function, that does the monadic computation while hiding the state
04:49:01 <quicksilver> dansa: yes.
04:49:03 <Botje> dansa: yup
04:49:12 <quicksilver> in the 'normal way' the function can (possibly) actually do some partial work
04:49:22 <quicksilver> whereas a flipped partial application can't possibly do any work
04:49:41 <quicksilver> haskell doesn't let you write functions which can do partial work on whichever arg they get first
04:49:49 <quicksilver> (without adding a layer of indirection to the whole thing)
04:50:22 <quicksilver> so (1*) can possibly do partial work but (*1) definitely can't.
04:50:48 <tensorpudding> _Fury: assuming that it typechecks i suppose
04:51:08 <dansa> new question; suppose i have f x y = ...; now i wanna define notf; it appears that notf = not f doesn't work, and notf = not . f also doesn't; what is my misunderstanding here?
04:51:15 <_Fury> yes
04:51:32 <_Fury> this was a task for university.
04:51:47 <quicksilver> either 'run' has another parameter you haven't told us about, or it assumes you start with an empty stack
04:51:51 <quicksilver> but that's quite sane.
04:52:21 <ceii> dansa: you'd need (not .) . f if I'm not mistaken
04:52:28 <quicksilver> dansa: basically, "not ." puts a not in front of a unary (one-parameter) function
04:52:32 <tensorpudding> @type not
04:52:33 <lambdabot> Bool -> Bool
04:52:43 <_Fury> quicksilver it starts with an empty stack
04:52:50 <quicksilver> dansa: in front of a binary function you need the rather ugly (not .). as ceii says
04:53:08 <Cale> It would be possible to adopt some kind of evaluation model where functions which are partially applied to later parameters might be able to do some partial evaluation.
04:53:11 <BONUS> notf x y = not (f x y)
04:53:11 <ceii> I'd say pointful style is simpler though
04:53:13 <_Fury> i dont use haskell productively ... i just have a course for one semester
04:53:19 <quicksilver> @pl notf x y = not (f x y)
04:53:20 <lambdabot> notf = (not .) . f
04:53:22 <tensorpudding> > let f x y = if even (x+y) then True else False in (not . f) 2 2
04:53:23 <lambdabot>   Couldn't match expected type `t1 -> t'
04:53:24 <lambdabot>         against inferred type `GHC.B...
04:53:32 <quicksilver> Cale: sure, I was only meaning to say our implementations don't.
04:53:47 <Cale> Yeah, and that seems somewhat complication-inducing for what benefit it would bring.
04:53:50 <dansa> ``(not .) . f'' worked, but i'm very puzzled now :) this looks very unguessable to me
04:54:01 <quicksilver> Cale: the haskell report doesn't really forbid it although some of the assumptions people make about how sharing works do kind of assume a certain operational idea
04:54:07 <tensorpudding> > let f x y = if even (x+y) then True else False in (not (f 2 2))
04:54:08 <lambdabot>   False
04:54:14 <quicksilver> dansa: it's not guessable, but it is work-out-able in time.
04:54:18 <ceii> function composition with (.) passes _one_ argument through the pipe
04:54:26 <_Fury> Do you also use Lisp?
04:54:36 <ceii> so not . f means f gets one argument, returns a function (Int -> Bool)
04:54:43 <ceii> and that is passed to not
04:55:14 <dansa> ceii: that's somewhat sensible; so we have two dots because f takes two args?
04:55:30 <ceii> yes
04:55:37 <ceii> the (not .) part is a section
04:56:00 <Cale> You could also write fmap not . f
04:56:03 <dansa> if f took only one, my initial attempt would've worked? ``yes, it would''
04:56:15 <Berengal> Some define (.:) = (.) . (.)
04:56:18 <Cale> But that requires the instance of Functor for functions which is foolishly not in the Prelude
04:56:33 <ceii> so applied to the Int -> Bool it just composes it with not
04:56:40 <ceii> and you get what you wanted
04:56:51 <ceii> (yes it would)
04:57:11 <dansa> ceii: but ``.:'' will then only work for two args, or would it take two or more?
04:57:15 <dansa> @src .:
04:57:16 <lambdabot> Source not found.
04:57:20 <dansa> @src (.:)
04:57:21 <lambdabot> Source not found. Take a stress pill and think things over.
04:57:30 <dansa> hehe, sure, mr lambda
04:57:35 <Berengal> Alternatively, (g .: f) x y = g (f x y)
04:57:35 <Berengal> Only two
04:58:07 <Cale> (.:) = fmap . fmap  -- :)
04:58:12 <dansa> the definition of (.:) looks really unguessable to me :)
04:58:16 <Berengal> (.:) = fmap fmap famp
04:58:18 <Berengal> fmap*
04:58:36 <hatds> then don't guess :)
04:58:37 <Axman6> @let (g .: f) x y = g (f x y)
04:58:38 <lambdabot>  Defined.
04:58:39 <ceii> help, I'm trapped in a fmap factory
04:58:40 <Axman6> :t (.:)
04:58:42 <lambdabot> forall t2 t3 t t1. (t2 -> t3) -> (t -> t1 -> t2) -> t -> t1 -> t3
04:58:43 <dansa> i wish haskell had only one map; just map; fmap is some kind of monadic map, i guess
04:58:59 <ceii> fmap is map for any functors
04:59:01 <Axman6> dansa: there's nothing monadic about it
04:59:06 <_Fury> Do you have to use things like :. at work??^^
04:59:07 <Berengal> It's functoric
04:59:07 <tensorpudding> haskell should have just fmap
04:59:11 <ceii> so it's like map on lists, but it also works on maybes, trees
04:59:13 <tensorpudding> since map is just fmap
04:59:13 <ceii> etc
04:59:24 <tensorpudding> but for lists
04:59:28 <Axman6> tensorpudding: it should have just map, and work on all ufnctors imo :)
04:59:30 <Cale> In Haskell 1.4, map *was* what fmap is now.
04:59:33 <dansa> if i see ``Maybe'' I think ``monad'' not ``functor''
04:59:41 <Cale> Haskell 1.4 was so much cooler than Haskell 98 :(
04:59:48 <Axman6> well, it's both, but fmap is for functors
04:59:52 <dansa> Cale: so the change of name is for... some kind of compatibility?
04:59:55 <tensorpudding> Axman6: fmap is a better name for emphasizing what it does
04:59:59 <dansa> map should be the most general one
05:00:03 <tensorpudding> (i think)
05:00:15 <ceii> the change of name is because errors with typeclasses are comfusing, I guess
05:00:19 <Cale> dansa: "Beginners are confused!!!11"
05:00:23 <tensorpudding> @type map
05:00:24 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:00:26 <tensorpudding> @type fmap
05:00:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:00:31 <ceii> since map is usually one of the first functions introduced to beginners
05:00:32 <dansa> cale, lol
05:00:34 <Berengal> I wish haskell had something like -XAlternativePrelude Foo
05:00:38 <dansa> ``!!11'' -- i love that
05:00:42 <Berengal> Instead of just -XNoImplicitPrelude
05:01:20 <tensorpudding> a prelude of light
05:01:53 <Berengal> That way it could be package-based, not just module based
05:02:16 <tensorpudding> we should get rid of concat and just have join
05:02:50 <Cale> tensorpudding: For a while I thought that, but I actually think that concat might be better generalised in the direction of monoids.
05:03:04 <Berengal> The problem isn't really alternative names for the specialized functions, but that sometimes the specialized functions take names the general versions should've had
05:03:13 <tensorpudding> as a parallel with mconcat?
05:03:16 <Cale> tensorpudding: So we'd have join :: (Monad m) => m (m a) -> m a, and concat :: (Monoid m) => [m] -> m
05:03:22 <tensorpudding> or mappend, or whatever
05:03:26 <Cale> and drop mconcat, because that's a stupid name
05:03:37 <Cale> and steal (++) for the monoid operation name
05:03:39 <tensorpudding> i can't remember the monoid names
05:03:59 <Cale> :t mappend
05:04:00 <lambdabot> forall a. (Monoid a) => a -> a -> a
05:04:01 <hatds> I'm picturing a lambdacats photo idea right now
05:04:03 <Cale> :t mempty
05:04:05 <lambdabot> forall a. (Monoid a) => a
05:04:10 <Cale> :t mconcat
05:04:11 <lambdabot> forall a. (Monoid a) => [a] -> a
05:04:19 <tensorpudding> i like fmap though
05:04:20 <Berengal> Is Alternative equal to MonadPlus?
05:04:27 <Cale> I'd prefer those were (++), zero, and concat respectively.
05:04:32 <mchase> Hi.  It appears that cabal-install will not work with 6.12 of ghc.  What is the most recent version of ghc that works with them most recent cabal-install version?
05:04:37 <tensorpudding> if only because i pronounce it fuh-map
05:04:37 <Cale> Berengal: very roughyl
05:04:42 <Cale> *-ly
05:04:49 <Berengal> Cale: So not exactly?
05:05:05 <Berengal> Cale: Because I'd love to get rid of MonadPlus in favor of Alternative
05:05:13 <ceii> mchase: 6.10.4
05:05:15 <Cale> Berengal: Well, MonadPlus at least is *supposed* to have some laws which interact with the monad operations
05:05:30 <Cale> Berengal: But there are really two separate ideas being crowded into the one class right now.
05:05:31 <ceii> It's still the "stable" ghc until the haskell platform releases with ghc 6.12
05:06:08 <ToRA> @type Data.Foldable.fold
05:06:09 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
05:06:10 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
05:06:13 <Berengal> Cale: I haven't really seen a decent set of laws for MonadPlus. They seem to fit the monad, instead of the monad fitting them
05:06:27 <kaol> and let's get rid of fail too, if we're talking about MonadPlus
05:06:50 <Cale> We really should split things into MonadZero, MonadPlus, and MonadOr
05:07:03 <kaol> that didn't make it into haskell prime?
05:07:16 <Cale> Haskell 2010 didn't do much of anything
05:07:26 <tensorpudding> fail is pretty fail
05:07:34 <tensorpudding> i don't think anyone uses it though
05:07:36 <mchase> thanks, ceii.
05:07:37 <kaol> Monad fail (imagine an image caption of that)
05:07:43 <ToRA> tensorpudding: what? you're kidding
05:07:45 <Cale> But I think the standards process is the wrong place to change these things.
05:07:56 <tensorpudding> people use fail?
05:07:58 <Cale> The right place to change these things is in the implementations.
05:08:06 <ToRA> any pattern match in a monad uses fail i think
05:08:09 <kaol> every time you pattern match in do, you potentially use fail
05:08:14 <Cale> tensorpudding: I mostly just try to ignore that it exists.
05:08:23 <tensorpudding> i meant
05:08:29 <Berengal> I use fail for monads that can fail, e.g. lists
05:08:29 <tensorpudding> people don't define fail
05:08:33 <Berengal> But it still feels wrong
05:08:38 <Cale> tensorpudding: Yeah.
05:08:46 <tensorpudding> in the monads that they have
05:08:55 <ToRA> tensorpudding: most people don't define their own monads though...(do they?)
05:09:08 <syntaxglitch> Doesn't Parsec use fail for some types of parsing errors?
05:09:10 <ToRA> (wonders what implicit set he's assuming for "most people")
05:09:13 <Cale> When I define monad instances, I usually leave fail out.
05:09:29 <Cale> Probably "most people who define monad instances"
05:09:40 <tensorpudding> it matters a lot if you define a monad that can fail
05:09:47 <kaol> When's haskell prime prime coming?
05:10:24 <hatds> <12 months?
05:10:25 <ceii> it's not "coming" anytime anymore, instead we'll have new small language versions every year
05:10:28 * kaol suspects that Haskell has became too successful
05:10:30 <tensorpudding> i thought haskell prime was just a list of extensions they want to formalize at some point, which they will release in stages
05:10:37 <Cale> I think that the standards process is, and should be, fundamentally boring.
05:10:39 <tener> does anyone can point me to code that successfully uses PackageImports extension?
05:10:43 <ceii> Haskell 2010 is standardized already
05:11:04 <Cale> Only standardise what's been implemented and in common use already.
05:11:13 <Cale> The interesting stuff should happen in the implementations.
05:11:16 <Berengal> Cale: Agreed
05:11:18 <tensorpudding> haskell 2010: the year we made contact
05:11:35 <Paczesiowa> just like with java and closures!
05:11:50 <dansa> a std should be just a document listing the common subset of popular implementations
05:12:08 <dansa> not suggesting anything
05:12:10 <Berengal> But we need things like -XAlternativePrelude to make some interesting alternatives to the existing standard
05:12:10 <Ke> Cale: I hear this leads to brutal conflicts when there is 2 implementations of similar function
05:12:43 <Cale> Paczesiowa: Every time someone refers to "closures" as a language feature, the flying spaghetti monster strangles a kitten with his noodly appendage.
05:14:26 <ceii> lol, my Arch just upgraded me to ghc 6.12 and compiling xmonad is spitting warnings without end
05:14:28 <dansa> it's not a feature? what's the relationship between closure and a language? what's the word use? ``the language supports closure'' is something improper to say?
05:14:36 <ceii> module `Prelude' is deprecated
05:14:38 <ceii> wow
05:14:59 <Berengal> Java has closures already
05:15:32 <Berengal> All that remains is to standarize on some Function classes, and add some syntactic sugar
05:15:32 <ceii> 'cept they're called internal classes
05:15:45 <Cale> dansa: yeah, closures are an implementation mechanism for several possible features
05:16:07 <Berengal> ceii: No, usually they're anonymous classes
05:16:22 <ceii> okay
05:16:23 <Paczesiowa> I'll spare us 2 hour argument - closures are poor man's objects and objects are poor man's closures. that is all.
05:16:27 <dansa> Cale: so it's a technique for generating the target code?
05:16:28 <ceii> my Java is getting old
05:16:30 <ceii> T_T
05:16:32 <Cale> dansa: yeah
05:16:52 <Cale> A closure consists of a PAIR consisting of a piece of code with some free variables in it (represented somehow), together with a map from those free variables to values.
05:16:52 <BONUS> most people mean anonymous blocks with some added scoping rules afaik when they talk about closures
05:17:32 <dansa> cale, i can follow this definition; but now, ... what's a feature then? say, tell me a feature of C
05:17:50 <Cale> The important keyword being that it's a pair, and not a function. If you can't separate the code from the data anymore because it's behind some kind of abstraction, you're not looking at a closure anymore, you're looking at something else that's been implemented using a closure.
05:17:51 <Axman6> stupid C++ making me write haskell code like reflRayProc (ray,obj,x',n,nl,f,p',depth,into,nc,nt) =
05:18:53 <Cale> The most common thing which closures are used to implement are indeed (first class) functions though, and this is usually what people mean when they refer to closures as a language feature.
05:19:16 <tensorpudding> C has a type system, i guess that is a feature
05:19:20 <Cale> But closures are also used to implement objects, and other mechanisms are used to implement functions as well.
05:20:08 <dansa> i see
05:20:51 <dansa> i like your pair definition; we have some free variables, and we close the expression with a value for each of them
05:21:03 <Cale> So people shouldn't ask whether a language supports closures as a language feature (you can implement closures in most languages after all), but whether the language supports (first class) functions.
05:21:35 <dansa> it seems to me you're saying closures iff first class functions
05:21:40 <Cale> Or first class procedures, if they're side effectful.
05:22:05 <Cale> No, closures are just one way of implementing first class functions/procedures.
05:22:20 <dansa> i see; i understand what you said now
05:22:26 <Cale> You can also do it, for a simple example, with template instantiation.
05:22:34 <dansa> you mean people are usually looking for whether there are first class functions in the language
05:22:44 <Cale> yeah
05:22:46 <dansa> and then they ask for closure
05:22:47 <dansa> i see
05:24:33 <BONUS> i think what most people want when they say closure is stuff like x=1; 5.times { x++ }
05:24:52 <BONUS> so not only first class functions but the ability to capture free variables and change their values
05:25:17 <Paczesiowa> 1.times { BONUS++ }
05:25:18 <Cale> Well, normally this is just what first class procedures means.
05:25:24 <BONUS> haha
05:25:30 <BONUS> ah
05:26:04 <Cale> But if you want to emphasise it, you can tack on "with lexical scoping" or something to that effect.
05:26:49 <Cale> (dynamic scope has generally been found to be a terrible idea though)
05:28:23 <BONUS> i used to define closure as just a function with free variables, but i like your pair definition, because the values of those free variables are important too
05:34:39 <BriGe> http://www.lostworlds.lv/go.php?1139723800 New TORENT.
05:36:20 <theclaw> is there an easy way to get the implementations of haskell functions?
05:36:41 <theclaw> mainly those in Prelude or other modules which are packaged with ghci
05:36:53 <theclaw> lambdabot doesn't e.g. have the implementation of "lift"
05:36:58 <theorbtwo> theclaw: The @src bot command in here, or read the haskell report.
05:37:17 <theorbtwo> (I think.)
05:39:05 <hatds> you can use http://www.haskell.org/ghc/docs/latest/html/libraries/, navigate to the module and click source in upper right
05:39:47 <theorbtwo> http://www.haskell.org/haskellwiki/Lifting is possibly what you want.
05:39:51 <theclaw> hatds: thanks!
05:40:37 <theclaw> theorbtwo: helpful, yes ;)
05:41:39 <hatds> http://www.haskell.org/onlinereport/standard-prelude.html is a reference implementation of the Prelude also
05:42:26 <theclaw> hatds: updateParserState :: (Monad m)
05:42:27 <theclaw>                   => (State s u -> State s u) -> ParsecT s u m (State s u)
05:42:27 <theclaw> updateParserState f
05:42:27 <theclaw>     = ParsecT $ \s -> let s' = f s
05:42:30 <theclaw> sorry
05:43:18 <theclaw> hatds: Why doesn't http://www.haskell.org/ghc/docs/latest/html/libraries/ contain Control.Monad.Trans?
05:45:06 <hatds> theclaw: not sure, maybe it was moved out of ghc
05:45:11 <BriGe> http://www.lostworlds.lv/go.php?1139723800 Please everybody click on this site.. thats not a virus
05:46:43 <hatds> theclaw: http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/index.html   here, this is for ghc 6.10
05:47:28 <Paczesiowa> theclaw: mtl has that module]
05:47:29 <Polarina> Is there a more elegant method if interfacing C# both-ways with Haskell without stdin and stdout?
05:47:30 <ToRA> theclaw: the underlying answer is because it's provided by mtl (or monads-XX ?) packages which is now available through hackage
05:47:42 <ToRA> and not bundled with the compiler any more
05:47:50 <Paczesiowa> Polarina: there's a .net bridge on hackage
05:48:02 <Polarina> Paczesiowa: Do you have a link?
05:48:19 <Paczesiowa> http://hackage.haskell.org/package/hs-dotnet
05:48:30 <Polarina> Thanks.
05:50:56 <HugoDaniel> hi
05:54:30 <SamB_XP> nuts, even the latest unofficial build of x-chat for Windows doesn't redraw text that was previosly covered by another window when it autoscrolls :-(
05:55:01 <theclaw> okay, thanks :)
05:56:02 <SamB_XP> so if you have the top edge of a window overlapping your x-chat's text area, you end up with a bunch of blitted copies of that top edge :-(
05:56:45 <SamB_XP> I wonder if that's a bug in GTK, GDK, or xchat?
05:56:54 <hatds> sounds like a poorly written program
05:57:18 <SamB_XP> well, it doesn't happen on Linux
05:57:22 <ElfArmy> If they changed the window style from using SAVEBITS or whatever they style is that might happen.
05:58:33 <SamB_XP> ElfArmy: I'm pretty sure that it doesn't use the equivalent thing under X ...
05:59:29 <fasta> SamB_XP, for some reason the Windows builds of XChat are always crippled.
05:59:43 <SamB_XP> fasta: this is an unofficial one, though
05:59:50 <SamB_XP> not that shareware crap
05:59:55 <ElfArmy> Ah, what is their strategy for building against new versions of GTK?
05:59:58 <voidprayer> excuse me. what's the function to get out every (a | func a == True) from the list? span/break will stop after the first match/mismatch.
06:00:02 <voidprayer> thank you
06:00:21 <Paczesiowa> > filter even [1..10]
06:00:23 <lambdabot>   [2,4,6,8,10]
06:00:30 <SamB_XP> ElfArmy: well, this one came with GTK 2.14.7
06:00:33 <mux> > partition even [1..10]
06:00:34 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
06:00:42 <mux> voidprayer: is that what you want?
06:00:57 <mux> oh, no, you probably meant filter
06:01:18 <SamB_XP> it's the "silverex" build
06:01:24 <Paczesiowa> > let func = even in [a | func a == True, a <- [1..10]]
06:01:25 <lambdabot>   []
06:02:19 <Paczesiowa> > let func = even in [a | a <- [1..10], func a == True]
06:02:21 <lambdabot>   [2,4,6,8,10]
06:02:41 <fasta> SamB_XP, which shareware crap?
06:02:45 <Paczesiowa> why did that previous version work at all?
06:03:01 <SamB_XP> I honestly wouldn't be surprised at all if the issue was somehow caused by an unexpected difference between X and win32 ...
06:03:17 <fasta> SamB_XP, me neither.
06:03:22 <SamB_XP> fasta: the official Windows builds of x-chat are shareware
06:03:35 <voidprayer> mux, Paczesiowa: ... i should notice that
06:03:44 <voidprayer> mux: Paczesiowa: thank you very much!!!!
06:04:01 <SamB_XP> but, I would have expected this to have been fixed in GTK by now if it were caused by an X/win32 difference liked that...
06:04:04 <fasta> SamB_XP, ah, yes. I don't use those, but as far as I am concerned someone can still build another IRC client on Windows.
06:04:08 <SamB_XP> s/liked/like/
06:04:27 <voidprayer> mux: in fact, i mean partition, but which module to import?
06:04:36 <Paczesiowa> Data.List
06:04:38 <fasta> SamB_XP, I used YChat for some time and now something else, but I don't really like installing random binaries of the Interwebs.
06:04:45 <voidprayer> > :i partition
06:04:46 <lambdabot>   <no location info>: parse error on input `:'
06:04:49 <BONUS> when the haskell platform gets GHC 6.12, will mtl be included with the haskell platform?
06:04:54 <Paczesiowa> :i partition
06:04:59 <Paczesiowa> :t partition
06:05:01 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:05:05 <voidprayer> >:i partition
06:05:16 <SamB_XP> fasta: well, I was linked from a quasi-official-looking wikipage ;-)
06:05:32 <Paczesiowa> voidprayer: use either "> " or ":" for lambdabot
06:05:43 <voidprayer> Paczesiowa: ... i lost the "Data.List" above. sorry again and thank you.
06:05:46 <SamB_XP> also, the name "silverex" sounded a bit familiar ...
06:05:48 <voidprayer> Paczesiowa: thank you.
06:06:47 <fasta> SamB_XP, yes, same here.
06:07:20 <SamB_XP> i.e. I think someone in #zsnes probably told me they were using that ages ago
06:18:32 <Donny__> Hi all, is there a haskell function that takes two lists and merge them?
06:18:38 <Donny__> e.g. [a] -> [a] -> [a]
06:19:33 <fasta> @hoogle  [a] -> [a] -> [a]
06:19:34 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
06:19:34 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
06:19:34 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:19:37 <SamB_XP> Donny__: you you mean so that if they were both sorted, the resulting list is sorted too?
06:19:57 <SamB_XP> or just concatenating them together ?
06:20:14 <Donny__> just concatenation.
06:20:33 <fasta> Donny__, then the first result is what you want.
06:20:35 <SamB_XP> that would be ++, yes
06:20:50 <SamB_XP> > [1..10] ++ [100..200]
06:20:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,100,101,102,103,104,105,106,107,108,109,110,111,112,1...
06:20:55 <Donny__> hmm... silly me, I must've had a brain freeze. :) Thank you SamB_XP
06:21:00 <fasta> Donny__, /msg lambdabot <myquery> also works.
06:21:22 <SamB_XP> hehe
06:21:29 <SamB_XP> I figured you were just new ;-)
06:21:38 <Donny__> Yeah I am new :D
06:21:53 <Donny__> Just trying to implement Algorithm W in Haskell.
06:22:17 <SamB_XP> I mean, new enough not to even know about (++), rather than just new enough to have forgotten it temporarily ;-P
06:22:33 <Zaph0d_> Hi. In GHCi (v6.10.4) I am unable to load the source from package: directory-tree (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/directory-tree)
06:22:36 <benmachine> @type (++)
06:22:37 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:22:40 <benmachine> heehee
06:22:46 <Donny__> @type (++)
06:22:47 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:22:49 <Zaph0d_> I can cabal install, but load gives error: Class `Exception' used as a type
06:22:59 <benmachine> Donny__: lambdabot has some things a little different
06:23:17 <Donny__> hmm how do I test out queries with lambda bot?
06:23:25 <Donny__> I tried querying him with [1..3]++[3..5]
06:23:29 <benmachine> > text "like this"
06:23:30 <lambdabot>   like this
06:23:33 <benmachine> note the >
06:23:36 <Botje> don't forget the >
06:23:43 <Donny__> >[1..3] ++ [5..6]
06:23:48 <Zaph0d_> Loading the source gives an error. Loading the compiled module works.
06:23:58 <Donny__> >[1..3]++[5..6]
06:24:14 <SamB_XP> hmm, it looks like I have to reboot because of that pesky "can't unlink running code" restriction in Windows :-(
06:25:04 <SamB_XP> where by "unlink", I mean disconnect the .exe/.dll file from its name
06:25:33 <SamB_XP> (in order to replace it with a newer version)
06:25:35 <fasta> SamB_XP, you can load a DLL from memory if you want on Windows.
06:25:49 <benmachine> Zaph0d_: cabal is probably being cleverer about which libraries to use
06:25:51 <fasta> SamB_XP, (I am not sure exactly what you are talking about)
06:26:08 <benmachine> it might be using the old exception library, for example
06:26:10 <Zaph0d_> SamB_XP: Try rename the DLL. Add your replacement and start a new instance of the exe. When you reboot you can delete the renamed dll.
06:26:10 <fasta> SamB_XP, but it is not part of the standard Windows API, which only works on files.
06:26:43 <SamB_XP> well, I just installed a new version of 7zip and it says I have to reboot to finish the install :-(
06:26:57 <benmachine> Zaph0d_: yeah, it looks like that package uses base-3
06:26:57 <fasta> SamB_XP, often those installers also lie.
06:27:02 <benmachine> when Exception meant something else
06:27:27 <benmachine> it's really due an upgrade, it probably won't work with 6.14
06:27:34 <SamB_XP> fasta: this installer doesn't tell me that for 1st installs
06:28:02 <Zaph0d_> benmachine: I kinda wanted to play with the source as a learning exercise. Can I get GHCi to load the source? I tried a verbose cabal install for clues but didn't see anything obvious.
06:28:10 <fasta> SamB_XP, ok, well, run wine and Linux if you don't want that ;)
06:28:13 <Donny__> >text "testing"
06:28:30 <Donny__> I don't think lambdabot likes me :P
06:28:33 <fasta> SamB_XP, wine has a way to "reboot Windows", which takes about 0.1 seconds :)
06:28:45 <Botje> Donny__: first a >  then a space.
06:28:50 <Botje> > "hi"
06:28:50 <Donny__> ah
06:28:50 <lambdabot>   "hi"
06:28:52 <Zaph0d_> benmachine: Can I get GHCi to switch to base-3 ? Also how did you know that?
06:28:57 <Donny__> > hi "hiiii"
06:28:58 <lambdabot>   Not in scope: `hi'
06:29:01 <Donny__> > text "hiiii"
06:29:02 <lambdabot>   hiiii
06:29:17 <Donny__> > nub [1..5] ++ [4..7]
06:29:18 <lambdabot>   [1,2,3,4,5,4,5,6,7]
06:29:38 <benmachine> Zaph0d_: I knew that because when cabal succeeds at building something that ghc didn't it's usually because of cabal's fiddling with old library versions
06:29:59 <benmachine> and because the cabal file on the hackage page doesn't specify which version of base should be used
06:30:14 <benmachine> can you get ghci to switch to base3, I'm not sure
06:30:23 <benmachine> you might be able to using -package or -hide-package
06:31:16 <benmachine> for me, ghci -package base-3.0.3.2 seems to work
06:31:26 <benmachine> but I guess you'll probably have 3.0.3.1 or something?
06:31:42 <benmachine> base-3 might work
06:31:50 <benmachine> no it doesn't
06:32:09 <Cale> > nub ([1..5] ++ [4..7])
06:32:10 <Zaph0d_> benmachine: I could also try changing the source to make it current. I tried changing Exception to SomeException but that  failed.
06:32:10 <lambdabot>   [1,2,3,4,5,6,7]
06:32:17 <Cale> Donny__: ^^
06:32:42 <benmachine> Zaph0d_: yeah, it's probably more complicated than that, but you could try just replacing imports of Control.Exception with Control.OldException
06:32:49 <Donny__> yep :D
06:33:01 <Donny__> Thanks Cale, just realised the precedents.
06:33:07 <benmachine> which is a stopgap solution
06:33:18 <benmachine> until someone can redo things with the proper new classes
06:33:25 <Cale> Yeah, function application always takes precedence over any infix operator
06:33:59 <Zaph0d_> OldException works. tyvm
06:34:46 <aavogt> > (,) {}
06:34:48 <lambdabot>   (* Exception: <interactive>:1:133-138: Missing field in record construction
06:35:24 <aavogt> > const 1 *** const 2 $ (,) {}
06:35:25 <lambdabot>   (1,2)
06:36:08 <benmachine> nice
06:36:18 <benmachine> > (1, 2) {}
06:36:19 <lambdabot>   <no location info>: Empty record update
06:36:32 <aavogt> I don't think it has any selectors
06:36:46 <benmachine> so why is yours a runtime exception and mine doesn't compile?
06:37:11 <ToRA> hey, can anyone suggest a simple (ideally few dependencies) library on hackage that has quickcheck tests
06:37:31 * benmachine wonders if quickcheck has quickcheck tests
06:37:38 <ToRA> I've already got xmonad
06:37:44 <ToRA> benmachine: my supervisor's asked me that before
06:37:55 <HugoDaniel> how do i reference a tuple like it was a list ?
06:38:07 <HugoDaniel> to access, say, the 10th element
06:38:13 <aavogt> > Endo id {}
06:38:14 <lambdabot>   <no location info>: Empty record update
06:38:20 <benmachine> HugoDaniel: by pattern-matching
06:38:25 <aavogt> > Endo {}
06:38:26 <lambdabot>   No instance for (GHC.Show.Show (Data.Monoid.Endo a))
06:38:26 <lambdabot>    arising from a use ...
06:38:30 * benmachine almost wrote patching-mattern
06:38:34 <HugoDaniel> benmachine, oh :(
06:38:38 <aavogt> > appEndo (Endo {}) undefined
06:38:39 <lambdabot>   * Exception: <interactive>:1:142-148: Missing field in record construction ...
06:38:39 <HugoDaniel> ok then
06:38:52 <benmachine> HugoDaniel: there's no general way, because tuples are heterogenous
06:38:59 <aavogt> @hackage tuple
06:39:00 <lambdabot> http://hackage.haskell.org/package/tuple
06:39:05 <benmachine> so your !! function wouldn't have a sensible type
06:40:00 <Berengal> There is, with unsafeCoerce
06:40:02 <aavogt> I think you could work out a sensible type for it
06:40:35 <aavogt> like what is done in that tuple package
06:40:35 <benmachine> Berengal: whaaaat
06:41:41 <Berengal> benmachine: snd . unsafeCoerce fetches the second value of the first constructor of any ADT with two or more fields in the first constructor
06:41:56 <Berengal> Og course, it's not guaranteed to do so forever, and it's terribly unsafe
06:42:03 <benmachine> of course.
06:42:18 <Berengal> But you might be able to build something safe on top of that...
06:42:22 <benmachine> of course, it's very likely to break everything in ways you can't even be sure will crash
06:42:37 <aavogt> how do you mean?
06:42:51 <benmachine> well, suppose there isn't a second value
06:43:01 <aavogt> as long as the compiler has the same representation for regular ADTs as tuples, it should work, no?
06:43:10 <benmachine> that is basically going to end up being an uninitialised memory access
06:43:28 <benmachine> suppose the second value is not the same size as the type you are fetching
06:43:30 <benmachine> etc. etc.
06:43:36 <Berengal> aavogt: That's not guaranteed. Haskell doesn't specify layout at all
06:43:58 * benmachine likes etc. as a way of saying, I've run out of arguments
06:44:00 <aavogt> of course not
06:44:07 <Berengal> And for unboxed values things are probably going to break
06:44:42 <noteventime> Is it possible to set type class constraints on type family?
06:44:42 <temoto> :src reverse
06:45:01 <temoto> Something wrong with bot?
06:45:03 <dansa> @src reverse
06:45:03 <lambdabot> reverse = foldl (flip (:)) []
06:45:48 <aavogt> Berengal: it does indeed cause a segfault for unboxed tuples
06:46:07 <Berengal> aavogt: Well, if you're lucky...
06:46:24 <aavogt> you think it's worse to get wrong values?
06:46:28 <Berengal> I do
06:46:52 <Berengal> What if the wrong value is a thunk that formats your harddrive?
06:47:18 <aavogt> why would the OS allow that to happen?
06:47:30 <benmachine> why would the OS allow rm to delete your files?
06:47:38 <Berengal> What if it's a thunk that setuid's to root, then formats your harddrive?
06:47:52 <benmachine> you can't setuid to root :P
06:48:08 <Berengal> Some super user
06:48:13 <Berengal> Or it could just delete $HOME
06:48:26 <benmachine> what if it's a thunk that exploits a hitherto undiscovered kernel bug to disable the cooling fan on your CPU and melt your motherboard
06:48:28 <aavogt> yeah, $HOME is fair game for such a bug
06:48:29 <benmachine> what THEN
06:48:44 <Jafet> benmachine, at least your harddisk is intact!
06:49:00 <aavogt> depends how vigorously it melts
06:49:01 <_andy_> can i assume that if i have a function, with a "case x of" where x is free variable, that the case will only be evaulated once?
06:49:06 <Jafet> Actually your computer would just shut off
06:49:25 <benmachine> Jafet: that is the boring answer :(
06:49:30 <Jafet> x is evaluated when it needs to be patternmatched
06:49:41 <Berengal> A more likely scenario is that it evaluates to a value that invalidates your invariants and crashes the program two weeks later, rendering any data produces in the meantime useless
06:49:42 <ddarius> It's hard to find expository accounts of right adjoints to exponential functors.
06:49:47 <_andy_> so say you have:
06:49:52 <benmachine> mm
06:49:58 <_andy_> f x = case g y of ...
06:50:15 <_andy_> and g is a function defining an extensive computation
06:50:28 <_andy_> g will only be evaluated once, even if f is called repeatedly?
06:50:37 <Cale> _andy_: It's not safe to assume that, but it may be the case.
06:50:37 <ddarius> _andy_: No.
06:50:53 <_andy_> ok
06:50:58 <benmachine> _andy_: that would not be a good idea if the result of computing g took lots of memory, and f was called only rarely
06:50:58 <aavogt> Cale: safe?
06:51:14 <ddarius> It probably won't be the case, and I'm pretty certain for GHC it won't be the case.
06:51:22 <_andy_> f will most definitely be called once, generally much more
06:51:25 <Cale> _andy_: If you want to ensure that it's only evaluated once and reused for every x, you should define a constant g y outside the function.
06:51:31 <_andy_> ok
06:51:32 <_andy_> thanks
06:51:49 <ddarius> Cale: That doesn't ensure anything in general.
06:51:51 <aavogt> I don't think that having wrong idea about how things are evaluated can break programs (well other than say stack overflows)
06:52:05 <benmachine> aavogt: depends what you mean by break
06:52:08 <Cale> ddarius: Well, yes, a general Haskell implementation is allowed to re-evaluate it.
06:52:15 <Berengal> aavogt: Stack overflows and memory exhaustion
06:52:20 <benmachine> a desktop calculator that takes 3 weeks to add four numbers is broken in my book
06:52:37 <Cale> But a lazy evaluator won't if you lift it out like that.
06:52:45 <ddarius> benmachine: What if they are really big numbers?
06:53:08 <benmachine> ddarius: then my point is totally invalidated
06:53:54 <aavogt> Berengal: those are performance issues, not correctness issues
06:54:00 <Jafet> Then they won't fit on a desktop calculator
06:54:01 <ufopp> how do I concat a list of strings into a single string?
06:54:08 <aavogt> ufopp: concat
06:54:17 <benmachine> aavogt: so, safe from performance issues
06:54:23 <ddarius> numdam is handy
06:54:35 <Berengal> aavogt: If you consider bottom to be a correct answer
06:54:38 <benmachine> :t concat
06:54:39 <lambdabot> forall a. [[a]] -> [a]
06:54:40 <Berengal> aavogt: Which, in a sense, it is...
06:54:43 <temoto> , a + b where (a,b) = (2,5)
06:54:44 <lunabot>  luna: parse error on input `where'
06:54:50 <benmachine> should concat = mconcat?
06:54:56 <temoto> > a + b where (a,b) = (2,5)
06:54:57 <lambdabot>   <no location info>: parse error on input `where'
06:55:00 <Jafet> Correct answer to what question?
06:55:00 <benmachine> if we're going with (++) = mappend
06:55:04 <aavogt> @src mconcat
06:55:05 <lambdabot> Source not found. :(
06:55:09 <Berengal> Jafet: Any question
06:55:15 <Jafet> > let (a,b) = (2,5) in a+b
06:55:16 <temoto> How to eval that?
06:55:16 <lambdabot>   7
06:55:17 <aavogt> mconcat == foldr (++) mempty
06:55:22 <temoto> oh
06:55:28 <temoto> so anyway, here's the question
06:55:50 <temoto> Haskell doesn't specify order of evaluation of a and b in expression a+b, right?
06:55:54 <Jafet> Berengal, like "what should I fondle today"?
06:56:01 <temoto> a may be evaluated first or second
06:56:05 <temoto> right?
06:56:05 <Cale> temoto: right.
06:56:09 <benmachine> temoto: how would you tell?
06:56:14 <Cale> temoto: Nor should it matter.
06:56:25 <temoto> So, the question: what does it give?
06:56:32 <Cale> ?
06:56:39 <temoto> how this undeterminism is useful for haskell?
06:56:41 <ddarius> temoto: Or in parallel.
06:56:44 <aavogt> > let ans = a + b where (a,b) = (2,5) in ans -- temoto
06:56:45 <lambdabot>   7
06:56:49 <Jafet> benmachine, trace
06:56:51 <temoto> for programmer it is obviously not useful
06:56:57 <benmachine> Jafet: without cheating
06:56:57 <Berengal> Jafet: Indeed. You can consider the definedness order to be an approximation order. In this order, bottom is the least defined, or least accurate approximation
06:56:58 <Cale> Actually, for most types (like Integer, Double), they're both evaluated.
06:57:02 <Jafet> temoto, you obviously don't understand Haskell.
06:57:05 <Cale> (regardless)
06:57:06 <ddarius> temoto: You don't lose anything.
06:57:08 <Cale> So it doesn't matter.
06:57:25 <temoto> Jafet: not useful doesn't mean harmful.
06:57:35 <Jafet> How is it not useful, then?
06:57:44 <benmachine> hold on, the evaluation order of a and b could be defined by the equations for + couldn't it?
06:57:47 <Cale> temoto: How would you tell which order they were evaluated in anyway?
06:57:52 <ddarius> benmachine: Yes.
06:58:12 <temoto> Cale: trace?
06:58:13 <benmachine> but + in most of its uses is a primitive operation anyway
06:58:19 <Jafet> temoto, in fact, a and b do not have to be evaluated before a+b is. Do you also consider that "not useful"?
06:58:19 <Cale> temoto: Well, okay.
06:58:32 <temoto> I'm not going to use the order, i'm interested why is the order unspecified?
06:58:41 <Cale> temoto: Because the order doesn't matter.
06:58:52 <temoto> Jafet: how is that?
06:58:53 <Cale> and if one order is better, we want the compiler to be free to use it.
06:59:01 <benmachine> fewer specification = more better
06:59:04 <Jafet> temoto, how is what?
06:59:07 <Cale> It would be valid for a compiler to do it in parallel.
06:59:14 <temoto> Jafet: don't have to be evaluated.
06:59:19 <Berengal> If we keep setting things in stone we'll never get out of the stone age...
06:59:24 <Cale> (but probably foolish to always do that)
06:59:30 <Jafet> > const 1 undefined
06:59:31 <lambdabot>   1
06:59:38 <Jafet> Here undefined isn't evaluated before const is.
06:59:46 <ddarius> temoto: What benefit is there to specifying the order?
06:59:54 <Jafet> In fact, the reverse is true for normal-order evaluation, as in Haskell
07:00:09 <Berengal> ddarius: In cases where the compiler is too dumb to choose the best one. This is why we still have seq
07:00:27 <ddarius> Berengal: I'm talking about the language.
07:00:52 <temoto> ddarius: Can't come up with one.
07:01:39 <Berengal> ddarius: Okay. Then the case becomes much weaker. The "benefit" of being able to specify the order of side-effecting evaluations is, I guess, the main reason other languages do it
07:02:02 <ddarius> temoto: Okay, then you can't think up a benefit, but it is harmful in limiting the implementations (theoretically) and also in some spurious restrictions in the standard with no enforcibility..
07:02:12 <Donny__> question: is there a built in method in Haskell that checks if a List contains an item?
07:02:19 <Berengal> Donny__: elem
07:02:20 <Donny__> e.g. a -> [a] -> bool
07:02:22 <aavogt> @type null
07:02:23 <lambdabot> forall a. [a] -> Bool
07:02:26 <Jafet> Actually, the problem is even more serious than that, ddarius.
07:02:30 <rovar> anyone here familiar with Lazy.hGet ?  I'm getting intermittent responses from a tcp server, I suspect it's because of laziness, but it may be incomplete tcp transmission, although that seems unlikely.
07:02:38 <Jafet> We'd have massive arguments over which order to use!
07:02:40 <ddarius> Donny__: Haskell doesn't have "built-in methods," but yes, there is a standard library function 'elem'
07:02:49 <Donny__> > elem 1 [1...6]
07:02:50 <lambdabot>   Not in scope: `...'
07:02:53 <Donny__> > elem 1 [1..6]
07:02:54 <lambdabot>   True
07:03:03 <fasta> Algorithmic constant factor optimizations in the main description of the algorithm... meh...
07:03:04 <Donny__> ah, thank you Berengal and ddarius
07:03:16 <ddarius> > elem 10 [0..]
07:03:17 <lambdabot>   True
07:03:37 <fasta> First you say how the algorithm works and what is provable about its performance and then you talk about making it marginally faster.
07:03:38 <Cale> Jafet: Well, there is an obvious choice.
07:03:54 <Jafet> There always is to everyone. What's yours?
07:04:00 <rovar> here is the relevant code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15933#a15933
07:04:07 <Cale> Jafet: Every function really only has one parameter.
07:04:23 <Cale> Jafet: So it has to be left to right, if anything. :)
07:04:28 <rovar> i have a sniffer on the tcp port, it appears that data is being sent, but it is logging as received only infrequently..
07:04:29 <Jafet> What about infixes?
07:04:35 <Cale> Even infixes
07:04:46 <Jafet> (:[1]), for example
07:04:50 <aavogt> > (1 `succ`)
07:04:51 <rovar> i suspect it may be line 12ish
07:04:51 <lambdabot>   2
07:05:07 <Cale> (:[1]) is syntax sugar for (\x -> x:[1]), and can't be evaluated further
07:05:13 <ddarius> Jafet: The meanings of sections are explicitly specified.
07:05:37 <temoto> BTW yesterday i had an enlightment. Every function doesn't even has parameters. Only closure.
07:05:49 <Cale> temoto: hm?
07:05:59 <temoto> foo x  is foo without arguments closured on x.
07:06:11 <temoto> i don't know how to say 'closured' in proper english
07:06:11 <aavogt> Cale: (1 `succ`) needs  -XPostfixOperators
07:06:15 <Cale> I don't understand what you mean by 'closure' here.
07:06:21 <Jafet> Cale, ah, didn't know that.
07:06:35 <Cale> aavogt: succ 1 doesn't.
07:06:36 <temoto> Cale: you know when function uses variables from outer scope.
07:07:05 <aavogt> infix operators that are unary are postfix operators to me
07:07:07 <Berengal> closures are an implementation detail
07:07:10 <Cale> temoto: oh, okay, best not to confuse implementation details like closures with lexical scoping.
07:07:11 <temoto> as in   adder n = \x -> x + n
07:07:43 <temoto> alright, then i don't know the difference between two
07:07:48 <gwern> Berengal: closures are a poor man's object
07:08:07 <Jafet> n is not part of the closure of adder. It is part of the closure of the lambda expression
07:08:09 <Cale> closures are pairs consisting of a chunk of code with some free variables in it, and a mapping from those free variables to values
07:08:18 <Cale> they're an implementation mechanism for functions
07:08:22 <gwern> > 24 * 60 * 60
07:08:23 <ddarius> gwern: objects are a poor man's closure
07:08:23 <lambdabot>   86400
07:08:25 <Jafet> n is a parameter for adder.
07:08:29 <ddarius> gwern: Us programmers are poor people.
07:08:30 <Berengal> gwern: objects are a rich man's structs
07:08:39 <Cale> But they can also be used to implement objects, for example
07:08:45 <Jafet> Poor programmers should start unions
07:08:49 <gwern> > 3000000 / (24 * 60 * 60)
07:08:50 <lambdabot>   34.72222222222222
07:08:51 <aledge> Jafet, ++
07:08:57 <Cale> and procedures (with effects)
07:09:27 <Cale> and all those things can be implemented in ways which don't use closures
07:09:42 <Cale> So it's best to separate the details of the implementation (closures) from what's being implemented (functions)
07:09:54 <Berengal> @remember Jafet <gwern> closures are a poor man's object <ddarius> objects are a poor man's closure <Berengal> objects are a rich man's structs <Jafet> Poor programmers should start unions
07:09:54 <lambdabot> Okay.
07:09:55 <ddarius> "Toward the description in a smooth topos of the dynamically possible motions and deformations of a continuous body"  Yay, Lawvere.
07:10:01 <Berengal> @quote unions
07:10:01 <lambdabot> Jafet says: <gwern> closures are a poor man's object <ddarius> objects are a poor man's closure <Berengal> objects are a rich man's structs <Jafet> Poor programmers should start unions
07:10:05 <gwern> @mlish
07:10:05 <lambdabot> Maybe you meant: flush list
07:10:18 <Cale> Of course, when we say "functions" around here, we mean first class functions with lexical scoping.
07:10:23 <gwern> @mmush
07:10:27 <temoto> Jafet: right n is a parameter in declaration. But where it is used, i.e.  print $ adder 10 $ 20  <- here n is 10. expression adder 10 can be seen as  just lambda  adder' closured on n=10.
07:10:42 <gwern> I should figure out what's the furthrest away from @flush I can get away with
07:11:00 <temoto> or maybe lexically scoped, if this word fits better
07:11:12 <ddarius> temoto: "closured" is usually written "closed over"
07:11:19 <temoto> ddarius: thanks.
07:11:41 <temoto> closed over surely looks better :)
07:11:43 <Berengal> gwern: I've got some dict-searching code all ready to go...
07:11:44 <Jafet> temoto, that is partial evaluation or currying, whichever is the correct term for Friday here
07:11:55 <gwern> Berengal: great! I look forward to the results
07:12:09 <Berengal> gwern: How does lb handle different-length words in this regard?
07:12:16 <ddarius> Jafet: It's definitely not "partial evaluation" nor "currying"
07:12:31 <gwern> Berengal: I'd assume it drops them
07:12:33 <gwern> @list
07:12:34 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:12:55 <gwern> hm, but no, commands are different lengths
07:12:58 <aledge> @elite what does this do
07:12:58 <lambdabot> W|-|a7 d0ez 7|-|I5 do
07:12:59 <gwern> so maybe it pads them out
07:13:01 <aledge> oh.
07:13:04 <temoto> Jafet: yeah, today with my friend we discovered that closures and partial application stand so close to each other.
07:13:11 <Berengal> @liste
07:13:11 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:13:13 <Cale> temoto: well, it's just the function adder applied to the value 10...
07:13:15 <Berengal> alist
07:13:16 <benmachine> why does lb faff around with spelling and confuse people
07:13:17 <Berengal> @alist
07:13:17 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:13:20 <benmachine> @lis
07:13:21 <lambdabot> Maybe you meant: list listall listchans listmodules listservers
07:13:22 <Berengal> @aliste
07:13:22 <lambdabot> Maybe you meant: elite list
07:13:30 <aledge> @elite list
07:13:31 <lambdabot> LIS+
07:13:35 <aledge> false
07:13:42 <Cale> temoto: Every function in Haskell really has exactly one parameter
07:13:46 <Jafet> ddarius, adder::a -> a -> a; adder 10 --> a -> a; smells like curry
07:13:55 <ddarius> Lambdabot uses levenshtein distance
07:13:59 <Cale> temoto: and the ones which appear to have more just produce other functions as their results
07:14:01 <temoto> Cale: what about f= 5 ?
07:14:06 <Cale> That's not a function
07:14:13 <ddarius> Jafet: Currying is turning a function (A,B) -> C into a function A -> (B -> C).
07:14:16 <temoto> How isn't it?
07:14:21 <Cale> It has no parameters
07:14:30 <temoto> I know its domain, codomain, i can draw its graph.
07:14:30 <aledge> temoto, f x = 5 mb?
07:14:39 <Cale> temoto: What's its domain?
07:14:43 <temoto> aledge: no, i really meant const.
07:14:54 <Cale> f = const 5 is a different matter
07:14:58 <ddarius> Jafet: adder 10 is just application.  Partial application if you want to emphasize that there are other arguments, but the distinction between application and partial application is minor in Haskell.
07:15:05 <temoto> Cale: empty set
07:15:29 <Jafet> Oh hi, I typed "evaluation"
07:15:46 <aledge> temoto, but a function maps elements from the domain to the codomain, so if the domain is the empty set doesn't it stand that the codomain must also be the empty set?
07:15:49 <Cale> temoto: Are you sure?
07:15:57 <temoto> Cale: no :)
07:15:57 <Cale> aledge: No, that's false.
07:16:00 <Jafet> Wonder why
07:16:08 <Cale> The codomain can be anything, but the range will be empty.
07:16:22 <aledge> oh true
07:16:23 <Berengal> gwern: Just ["blush","brush","clash","crush","faust","flas","flash","flask","flesh","flos","floss","flubs","flues","fluff","fluid","fluke","fluky","flume","flung","flunk","flus","flush","flute","fresh","plush","shush","slash","slosh","slush"]
07:16:28 <Berengal> That's the equal-length words
07:16:33 <Cale> There's only one function from the empty set to any other, and it makes no associations.
07:16:35 <soupdragon> anyone know how to fix cabal: failed to parse output of 'ghc-pkg dump'?
07:16:44 <temoto> aledge: it must not, but handling empty domain is a really special case so it would depend on how we implement evaluation.
07:17:20 <blackh> soupdragon: Use a newer version of cabal
07:17:28 <aledge> soupdragon, or an older ghc ;)
07:17:35 <Cale> temoto: You can try to consider x = 5 to be a "nullary function", but that's silly, because then every value is also a function, and there's no distinction. You might as well just use the word "value"
07:18:24 <benmachine> is x = x a function?
07:18:41 <Cale> benmachine: uh... it doesn't typecheck
07:18:51 <Berengal> > let x = x in 5
07:18:52 <Cale> er, oh
07:18:52 <knobo```> (=) x would be a function
07:18:52 <lambdabot>   5
07:18:57 <benmachine> heh
07:19:01 <Cale> heh, that 'a' is separate
07:19:10 <temoto> clarkb: nullary function?
07:19:11 <benmachine> oh, yes
07:19:16 <benmachine> x = x
07:19:19 <ddarius> benmachine: It can be applied.
07:19:23 <benmachine> is what I meant
07:19:25 <Cale> x = x is polymorphic enough that it might define a function, but not necessarily
07:19:25 <temoto> clarkb: sorry, not to you
07:19:29 <Jafet> :t let x = x in x
07:19:29 <soupdragon> I'm trying to update cabal but the stupid thing wont do it because it's not new enough
07:19:29 <lambdabot> forall t. t
07:19:30 <Cale> Depends on the actual type
07:19:35 <temoto> Cale: nullary function? What is that?
07:19:46 <Cale> temoto: The idea of a function with 0 parameters
07:19:48 <benmachine> temoto: nullary = takes no arguments
07:19:56 <benmachine> like, True is a nullary type constructor
07:20:00 <temoto> ahh that's about ary - arity
07:20:01 <benmachine> er
07:20:04 <benmachine> value constructor
07:20:04 <Cale> yeah
07:20:17 <Cale> 0-ary would be another way to write that :)
07:20:23 <temoto> I got it :)
07:20:30 <Jafet> Wouldn't evaluating x = x give <<loop>>?
07:20:39 <temoto> Jafet: it gives.
07:20:49 <c_wraith> > let x = x in x
07:20:52 <temoto> Jafet: i use it to make ghc "think" few times a day.
07:20:53 <lambdabot>   mueval-core: Time limit exceeded
07:21:06 <Jafet> ghc is mindless
07:21:07 <soupdragon> cabal install cabal-install doesn't work
07:21:12 <benmachine> Jafet: I think you need optimisations for that
07:21:44 <c_wraith> soupdragon: is it possibly a path issue?  it installs the new version to someplace searched after where the old version is?
07:21:55 <Polarina> Is it possible to use something similar to unwords, but works only on tabs?
07:22:02 <Cale> Jafet: sometimes
07:22:03 <benmachine> @src unwords
07:22:03 <lambdabot> unwords [] = ""
07:22:04 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
07:22:09 <aledge> soupdragon, probably just download cabal from hackage?
07:22:27 <benmachine> Polarina: I guess there isn't a standard function, but that definition can easily be adapted
07:22:28 <Polarina> What's foldr1?
07:22:34 <Polarina> benmachine: Thanks.
07:22:34 <Cale> Jafet: But the loop detection doesn't work in the bytecode interpreter
07:22:37 <aledge> @src foldr1
07:22:37 <lambdabot> foldr1 _ [x]    = x
07:22:38 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
07:22:38 <lambdabot> foldr1 _ []     = undefined
07:22:46 <c_wraith> > intercalate "X" ["One", "two", "three"]
07:22:48 <lambdabot>   "OneXtwoXthree"
07:22:52 <Polarina> @src foldr
07:22:52 <lambdabot> foldr f z []     = z
07:22:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:23:02 <c_wraith> Polarina: is intercalate what you're looking for?
07:23:03 <Jafet> Well, solving the halting problem isn't trivial.
07:23:08 <Polarina> c_wraith: Nope.
07:23:28 <c_wraith> Polarina: then you'll have to describe what you want a bit more
07:23:32 <djahandarie> Jafet, undecidable in fact.
07:23:33 <quicksilver> I think Polarina meant words, not unwords.
07:23:46 <c_wraith> oh.
07:23:49 <benmachine> @src words
07:23:49 <lambdabot> words s = case dropWhile isSpace s of
07:23:50 <lambdabot>     "" -> []
07:23:50 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
07:24:02 <quicksilver> and no, there isn't, although there is Data.List.Split on hackage
07:24:15 <aavogt> > isSpace '\t'
07:24:15 <quicksilver> or just rework 'words' definition above appropriately ;)
07:24:16 <lambdabot>   True
07:24:28 <Polarina> c_wraith: I have a String that contains tabs, I want a list of Strings, where the string has been split at each occurrence of a tab.
07:24:30 <HaskellLove> If I can represent 10 with only [1,2] in 6 ways, then in how many ways can i represent 10 with [1,2,5] ?
07:24:38 <c_wraith> Polarina: right, you meant words.  I see
07:24:59 <Polarina> Oh, yeah. Sorry. :(
07:25:07 <djahandarie> HaskellLove, are you still doing those Euler problems?
07:25:13 <soupdragon> Do I have to install all these manually HTTP >=4000.0.2 && <4001, network >=1 && <3, zlib >=0.4 && <0.6
07:25:33 <quicksilver> yes, although there is a bootstrap script that's supposed to do so that sometimes works
07:25:34 <soupdragon> bootstrap is doing it
07:25:35 <c_wraith> soupdragon: there's a shell script for bootstrapping those for you
07:25:40 <quicksilver> or you can just download the haskell platform.
07:25:49 <soupdragon> I need .12
07:26:36 <c_wraith> @hoogle splitOn
07:26:37 <lambdabot> No results found
07:26:41 <c_wraith> @hoogle spliton
07:26:41 <lambdabot> No results found
07:26:44 <Berengal> soupdragon: If you're on .12, would you mind trying to install happstack-data?
07:26:50 <ddarius> And to think a few years ago everything was configure;make;make install and there was no Hackage or Cabal or Haskell Platform.
07:27:01 <HaskellLove> djahandarie yeah man i am stuck with 31
07:27:43 <c_wraith> Polarina: the split package has a function "splitOn" that will do what you want.
07:28:11 <soupdragon> look at this,  cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.8.0.2, now Cabal-1.6.0.3). Additionally the compiler is different (was ghc-6.12, now ghc-6.10) which is probably the cause of the problem.
07:28:22 <soupdragon> so I try cabal configure and it says cabal: failed to parse output of 'ghc-pkg dump'
07:28:31 <benmachine> oh hey that reminds me, I want someone on .12 to check if cabal fails when profiling builds are enabled and vanilla builds are disabled
07:28:42 <Berengal> soupdragon: Get rid of everything ghc and cabal-ish, and install anew
07:28:58 <soupdragon> I think I'll just give up
07:28:59 <sproingie> soupdragon: at the least you'll need to get rid of your ~/.ghc
07:29:29 <sproingie> probably best to nuke ~/.cabal too
07:29:38 <sproingie> do both of those and you're fine
07:29:53 <Berengal> benmachine: Fails how?
07:30:00 <Berengal> benmachine: Works for me-ish
07:30:09 <sproingie> BTW, wouldn't it be nice if it were ~/.ghc-6.12 instead?
07:30:10 <HaskellLove> soupdragon did you even read the install manual
07:30:15 <Berengal> (I don't have profiling libs built, so I can't install much)
07:30:32 <soupdragon> HaskellLove all I read what you swearing at me
07:31:01 <HaskellLove> where is that, you must have mixed me with someone else
07:31:11 <sproingie> i don't see any swearing going on
07:31:20 <soupdragon> other channel
07:31:48 <aledge> put aside your other channels
07:33:38 <Cale> soupdragon: hmm
07:33:50 <Cale> soupdragon: You have a mismatched cabal and ghc?
07:34:28 <soupdragon> something like that
07:34:50 <soupdragon> I had to upgrade ghc but then I had to upgrade cabal
07:34:51 <Cale> soupdragon: Note that before you install GHC 6.12, it's supposed to be important to cabal update && cabal install cabal-install beforehand
07:34:58 <temoto> In Haskell, does print waits until bytes are actually flushed to stdout or is it non-blocking IO?
07:35:14 <temoto> well maybe flushed is misleading.
07:35:39 <temoto> is print blocking or non-blocking write(2)?
07:35:50 <Jafet> > print "asdf"
07:35:51 <lambdabot>   <IO ()>
07:36:01 <soupdragon> now even cabal configure says failed to parse output of 'ghc-pkg dump'
07:36:06 <temoto> That doesn't show anything.
07:36:13 <Jafet> Exactly.
07:36:13 <soupdragon> after deleting .ghc and .cabal
07:36:24 <ben0x539> temoto: The write is non-blocking, but that is misleading.
07:36:28 <lispy> Hello
07:36:32 <Jafet> There is no write.
07:36:37 <temoto> It would show if there was a program like      print $ repeat 1000000 "a"
07:36:51 <temoto> for non-blocking it would only print a few kilobytes
07:36:54 <Jafet> temoto, perhaps you should read some introductory text on how Haskell works.
07:36:56 <temoto> and then program terminates
07:36:58 <ddarius> Heya lispy
07:37:17 <Cale> temoto: whaaaaaat...
07:37:45 <Berengal> I don't think I've read anything about non-blocking output in any introductory text. Not blocking output either, for that matter.
07:37:53 <lispy> temoto: are you using ghc-6.12?
07:38:00 <soupdragon> any idea how to get .12 working
07:38:01 <Jafet> > "wh" ++ (repeat 1000000 'a') ++ "t..."
07:38:01 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> m'
07:38:02 <lambdabot>         against inferred...
07:38:08 <Cale> I don't understand what it means for output to block.
07:38:09 <Jafet> > "wh" ++ (repeat 1000000 "a") ++ "t..."
07:38:10 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> m'
07:38:10 <lambdabot>         against inferr...
07:38:15 <Jafet> Gnarh
07:38:19 <Cale> Obviously it doesn't just give up halfway, that would be broken.
07:38:23 <temoto> lispy: no, 6.10. How does it matter?
07:38:24 <lispy> temoto: oops, meant that for soupdragon
07:38:27 <temoto> ok
07:38:39 <ben0x539> Cale: Output can block when your pipe is full, no?
07:38:40 <lispy> soupdragon: You need a new cabal/cabal-install
07:38:41 <Cale> It prints the entirety of what you ask it to print before continuing
07:38:44 <aavogt> > "wh" ++ replicate 1000000 'a' ++ "t..."
07:38:45 <lambdabot>   "whaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
07:38:49 <soupdragon> which cabal says /usr/local/bin/cabal
07:38:51 <soupdragon> that can't be right
07:38:56 <taruti> Hackage upload gives an "Internal Server Error" today :(
07:39:11 <temoto> Cale: any kind of input-output is really a waiting for until that action ends.
07:39:12 <lispy> soupdragon: you need cabal 1.8 and then to build cabal-install against it
07:39:23 <taruti> (Checking a cabal package works, but the actual upload fails)
07:39:57 <Cale> ben0x539: Oh, I suppose if it weren't attached to a terminal which immediately empties that buffer... hmm
07:40:01 <lispy> soupdragon: cabal update; cabal install cabal --constraint="cabal >= 1.8"
07:40:13 <temoto> Cale: so i was asking whether evaluation of print "foo" actually waits until underlying output finishes.
07:40:33 <ben0x539> temoto: I expect it does
07:40:56 <lispy> soupdragon: when that finishes, you probably will need to do, cabal install --reinstall cabal-install
07:40:57 <Cale> Well, the execution waits.
07:41:00 <Berengal> Depends on what you mean by underlying output and whatever buffers there might be inbetween the program and that
07:41:07 <temoto> Cale: thanks, that what i asked about.
07:41:10 <benmachine> the existence of http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-IO.html#v:hPutBufNonBlocking would suggest so
07:41:17 <Berengal> I don't think it'll flush
07:41:23 <Cale> temoto: You can find that out by printing an infinite list
07:41:27 <temoto> no, flushing is other thing
07:41:29 <ben0x539> Assume that you are using a system that works like I imagine ghc does, then the print will result in blocking the current thread and post your output request to the runtime system which will do something unspecified about it and then unblock your thread when the IO is done.
07:41:34 <lispy> soupdragon: BTW, *most* people shouldn't upgrade to ghc-6.12 until the next release of the Haskell Platform
07:41:35 <soupdragon> cabal install --reinstall cabal-install has problems
07:41:40 <ben0x539> @src print
07:41:40 <lambdabot> print x = putStrLn (show x)
07:41:41 <Cale> temoto: It won't continue printing the list while the rest of the program proceeds to run
07:41:56 <ben0x539> That flushes if your stdout is linebuffered, which I think it is by default or something.
07:42:03 <Cale> But you can make it do that with  forkIO (print [1..])
07:42:19 <temoto> :t forkIO
07:42:19 <lambdabot> Not in scope: `forkIO'
07:42:26 <Cale> Control.Concurrent
07:42:29 <lispy> soupdragon: What problems does it have?  Issues reading the pkg list?
07:42:29 <sproingie> ghc has some nonblocking stuff.  it's pretty low-level.
07:42:37 <ben0x539> IO a -> IO () or something
07:42:41 <soupdragon> no it was all the deps failed
07:42:50 <Cale> :t Control.Concurrent.forkIO
07:42:51 <lambdabot> IO () -> IO GHC.Conc.ThreadId
07:42:53 <ben0x539> whoops
07:43:07 <Cale> It should be IO a -> IO ThreadId though
07:43:07 <Berengal> benmachine: You're correct in Hugs, where type ThreadID = ()
07:43:22 <soupdragon> I think I got everything installed
07:43:24 <lispy> soupdragon: hmm...can you put the error on hpaste?
07:43:45 <soupdragon> lispy I skipped that step and everything else worked
07:43:48 <temoto> Why is it called ThreadId and not just Thread?
07:44:00 <soupdragon> now I am getting she: src/HaLay.lhs:(144,39)-(158,51): Non-exhaustive patterns in case
07:44:00 <lispy> soupdragon: okay, so now cabal/cabal-install is happy with the pkg list?
07:44:11 * benmachine pokes Berengal 
07:44:15 <Berengal> temoto: Because it's a thread id and not a thread
07:44:17 <lispy> soupdragon: ah, I can't help you with she :)
07:44:18 <soupdragon> yes
07:44:25 <temoto> Berengal: what is a thread then?
07:44:40 <Berengal> temoto: A thread running on your system
07:44:46 * Berengal pokes benmachine back
07:44:57 <Cale> Actually, a thread here isn't the same as an OS thread either.
07:45:04 <ben0x539> temoto: I hypothesise that it is because if it was Thread, the expectation would be that the lifetime is depending on the gc and you holding a reference to it or whatever
07:45:11 <temoto> ThreadId must be newtype on Integer or something, which doesn't give anything useful.
07:45:14 <Cale> GHC has an N:M scheduler which runs N Haskell threads on M OS threads.
07:45:20 <ben0x539> as opposed to a million other things like it being done, it being thrown an exception, or whatever
07:45:25 <rovar> can someone help me debug a socket issue?  I am expecting a response to my client, the server sent said response, but my client doesn't process it.   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15933#a15933
07:45:26 <temoto> I mean, we don't use StringId and all, right?
07:45:40 <Cale> It doesn't really matter what ThreadId is. I believe it's opaque anyway.
07:45:41 <Berengal> ben0x539: You do with ThreadID as well. It won't gc threads you've still got the id to
07:45:51 <ben0x539> Berengal: Well, okay, but they will stop running.
07:46:03 <quicksilver> I think temoto is right
07:46:05 <ben0x539> and presumably responding to async signals
07:46:12 <quicksilver> given that it's opaque it might as well be Thread
07:46:24 <quicksilver> we don't call "Handle" "HandleRef" or "FileId"
07:46:25 <rovar> when the server sends a response, sometimes I get the output printed at line 13, but the next print checkpoint does not get run.
07:46:28 <Berengal> ben0x539: What, when they're done?
07:46:29 <gwern> Berengal: I like faust
07:46:32 <gwern> @faust
07:46:32 <lambdabot> Maybe you meant: fact flush
07:46:40 <gwern> noo
07:46:41 <Berengal> Foiled!
07:46:49 <gwern> @crushed
07:46:50 <lambdabot> Unknown command, try @list
07:46:57 <taruti> Any idea when the hackage migration to the new server will be ready?
07:47:03 <gwern> @slosh
07:47:12 <Berengal> @slosh
07:47:12 <lambdabot> Not enough privileges
07:47:15 <Berengal> :)
07:47:17 <gwern> well, at leat that worked, although I dislike the lsh
07:47:28 <aavogt> @slash
07:47:28 <lambdabot> Maybe you meant: flush slap
07:47:38 <ben0x539> Berengal: yeah
07:47:40 <Berengal> @flume
07:47:41 <lambdabot> Not enough privileges
07:47:51 <Cale> Well, from the comments in the source, it looks like they plan to maybe one way make ThreadId into a weak pointer to a thread.
07:47:53 <Berengal> @flashy
07:47:53 <lambdabot> Not enough privileges
07:47:57 <ben0x539> quicksilver: we call it Handle and not OpenFile, though ;)
07:48:00 <Cale> one day*
07:48:17 <gio123> Cale: translation
07:48:18 <gio123> :)
07:48:26 <Jafet> @vixen Flash for us!
07:48:26 <lambdabot> Hmmm
07:48:30 <Berengal> @flux
07:48:30 <lambdabot> Not enough privileges
07:48:38 <benmachine> @vixen savedeveryoneofus
07:48:38 <lambdabot> are you horny?
07:49:12 <Cale> But since the underlying type ThreadId# is unlifted, they can't presently use it as a parameter to Weak
07:49:30 <gio123> Cale: translation
07:49:34 <ddarius> Now this is a section heading: "Representability of the tanget bundle. Special formula for the tangent bundle of a flat space. And rapid intuitive and rigourous proofs of all basic results of differential and integral calculus."
07:49:34 <temoto> What is 'unlifted'?
07:49:42 <quicksilver> I just don't see the point in indicating to the user that it's an Id
07:49:42 <Cale> gio123: I'll get to you
07:49:49 <quicksilver> surely it's enough that it's a thread.
07:49:50 * quicksilver shrugs
07:49:51 <leimy> unboxed?
07:49:53 <quicksilver> it's not important though :)
07:49:56 <Cale> unboxed, yes
07:50:01 <Cale> (same thing)
07:50:04 <temoto> What is unboxed?
07:50:15 <ddarius> unboxed /= unlifted
07:50:23 <Cale> ddarius: er, hmm...
07:50:29 <leimy> ddarius: yeah they are
07:50:31 <Cale> ddarius: Oh, I suppose that's true
07:50:32 <leimy> lift into the Functor :-)
07:50:36 <leimy> :-)
07:50:53 <lispy> instannce Functor Box where ...
07:51:13 <leimy> yourmom = makes me a ham sandwich?
07:51:28 <leimy> mmm ham sandwich
07:51:32 <Berengal> quicksilver: A thread presumably has a stack, instruction pointer,  and/or whatever other execution mechanisms it needs. A threadid doesn't... Still, to the user, this shouldn't be any different
07:52:14 <Cale> temoto: anyway, normally, values in GHC are represented as pointers to code which when run the first time will compute the value before rewriting the pointer to point at a shorter piece of code which will just return the already-computed value
07:52:36 <Cale> (before returning it)
07:52:49 <temoto> Cale: is that called thunks?
07:52:53 <leimy> It's like a Java Future
07:52:56 <leimy> or a thunk
07:52:57 <gio123> Cale: I sent the text
07:53:00 <Cale> temoto: that's one of the things called thunks, yes
07:53:11 <temoto> Cale: how is that different from memoization?
07:53:21 <Cale> It is a *sort* of memoisation.
07:53:29 <Cale> But it's different from memoising functions.
07:53:38 <Cale> It's just memoising the computation of constant values.
07:53:43 <temoto> It's a memoisation of expressions?
07:53:46 <Cale> yeah
07:53:47 <sproingie> memoizing implies that you have a cache of computed values
07:54:00 <lispy> leimy: java has Futures?
07:54:05 <leimy> yep
07:54:09 <sproingie> lispy: java.util.concurrent
07:54:14 <temoto> GHC destroys cache when refcount to expression is zero?
07:54:25 <lispy> I didn't realize that
07:54:26 <sproingie> ghc doesn't do that kind of caching memoization afaik
07:54:31 <Cale> If you have some variable which is defined as some expression, evaluating the value of the variable (pattern matching on it), should reduce the expression so that that computation doesn't happen again next time the value is pattern matched on
07:54:53 <ben0x539> It is not memoization in that doing 1 + 1 multiple times will not reuse the previous results, only doing let r = 1 + 1 and reusing that r, no?
07:55:08 <leimy> http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/Future.html
07:55:37 <temoto> But r + r would evaluate 1+1 only once, right?
07:55:58 <jmcarthur> right
07:56:22 <temoto> alrgiht, thanks
07:56:26 <leimy> partially evaluated haskell expressions are like executing Java Futures on cooperative threads.
07:56:29 <temoto> Cale: How does it relate to boxing?
07:56:35 <leimy> Haskell has a sort of in-built concurrency to the language.
07:56:48 <lispy> Those futures look kind of cool
07:56:49 <sproingie> unboxed values are strict
07:57:12 <ben0x539> I believe that the process in which you retrieve the memoised value is just part of the implementation of the boxes?
07:57:13 <Cale> temoto: This extra pointer indirection is the "box"
07:57:15 <leimy> yeah it's like using the <V> from Future <V> :-)
07:57:26 <temoto> sproingie: i know what 'expression is strict' means. What 'value is strict' mean?
07:57:47 <Cale> temoto: The important thing being that all values being pointers to code, have a uniform representation in memory, and so polymorphic functions can all operate on them in a uniform way.
07:57:52 <jmcarthur> temoto: you can observe this by trying: let r = trace "foo" (1 + 1) in r + r
07:57:55 * benmachine wonders whether the result of step-evaluating (\(x:y:ys) -> (x, y, ys)) (1 : [2, 3]) is (\(x:y:ys) -> (x, y, ys)) (1 : (2 : [3])) or (\(y:ys) -> (1, y, ys)) [2, 3]
07:58:03 <ben0x539> @src trace
07:58:04 <lambdabot> trace string expr = unsafePerformIO $ do
07:58:04 <lambdabot>     hPutStrLn stderr string
07:58:04 <lambdabot>     return expr
07:58:06 <jmcarthur> temoto: trace comes from Debug.Trace
07:58:27 <jmcarthur> "foo" will only be printed once
07:58:29 <leimy> jmcarthur: trace is my favorite use of unsafePerformIO :-)
07:58:40 <jmcarthur> heh
07:58:44 <jmcarthur> i've never actually used it
07:58:54 <leimy> I have.
07:58:54 * Berengal uses logic, not trace
07:58:56 <jmcarthur> testing that line in ghci is the first time i ever even imported Debug.Trace
07:59:00 <sproingie> temoto: every value gets lazily computed.  a strict value can't be, there's no room for a pointer
07:59:03 <Cale> ben0x539: Well, [1,2,3] is really syntax sugar
07:59:22 <sproingie> er i mean an unboxed value
07:59:34 <ben0x539> Cale: Hm?
07:59:35 <Cale> ben0x539: So there's no distinction between [1,2,3] and 1:2:3:[] really.
07:59:45 <lispy> > 1:2:3:[]
07:59:46 <lambdabot>   [1,2,3]
08:00:06 <benmachine> Cale: so I could just immediately evaluate all lists to their :[] form
08:00:07 <Cale> They don't just evaluate to the same thing, but actually are the same thing in memory at runtime, at least in GHC.
08:00:19 <Cale> You could handle it differently
08:00:26 <ben0x539> I do not understand why you are bringing this up
08:00:35 <leimy> huh it's not 1: [2 : [3 : [] ] ] ?
08:00:36 <benmachine> ben0x539: mistab, I think >_>
08:00:38 <temoto> So is it that hard to wrap ThreadId# into some function which returns a boxed value?
08:00:44 <ben0x539> ooh
08:00:55 <benmachine> leimy: no, [3 : []] is [[3]]
08:00:58 <ben0x539> benmachine: I checked for you talking, I must have missed the /me
08:00:59 <sproingie> leimy: : is right-associative
08:01:00 <ben0x539> ;)
08:01:03 <leimy> AHHH!
08:01:03 <Polarina> @src lines
08:01:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:01:05 <leimy> cool!
08:01:09 <leimy> I forgot that.
08:01:19 <ben0x539> Right, this is not working out
08:01:24 <Polarina> @src Data.List.lines
08:01:24 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:01:26 <benmachine> nooo
08:01:33 * Polarina slaps lambdabot
08:01:36 <benmachine> hmm, Vanadium's not a bad name
08:01:46 <benmachine> but ben is a better one
08:01:57 <Vanadium> It is not good because it keeps getting in the way :)
08:02:06 <benmachine> anyway Cale: you mean like, not reduce the list syntax at all?
08:02:56 <benmachine> that makes sense I suppose
08:03:09 <Cale> benmachine: I mean, you *could* treat desugaring the list syntax as an evaluation step if you really wanted to
08:03:17 <Cale> But in practice it's not.
08:03:32 <temoto> @src print
08:03:32 <lambdabot> print x = putStrLn (show x)
08:03:49 <benmachine> Cale: mm, fair enough
08:03:51 <lispy> ?pl print x = putStrLn (show x)
08:03:51 <lambdabot> print = putStrLn . show
08:04:03 <lispy> ?. pl src print
08:04:03 <lambdabot> (line 1, column 1):
08:04:03 <lambdabot> unexpected end of input
08:04:03 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:04:10 <benmachine> this way was simpler code-wise but I don't imagine it'd be hard to change it
08:04:52 <temoto> @src putStr
08:04:53 <lambdabot> putStr s  = hPutStr stdout s
08:05:04 <temoto> @src hPutStr
08:05:05 <lambdabot> Source not found. Sorry.
08:05:16 <quicksilver> hPutStr has no source, it just is ;)
08:05:23 <temoto> So this is the lowest level.
08:05:34 <quicksilver> you could imagine hPutStr h s = mapM (hPutChar h) s
08:05:39 <temoto> AHAAAA!!!!!!!!
08:05:42 <Vanadium> You could probably build hPutStr using some FFI stuff, though
08:05:48 <ddarius> mapM_
08:05:51 <temoto> god you said that!
08:05:54 <ddarius> :t hPutStr
08:05:54 <lambdabot> Not in scope: `hPutStr'
08:05:55 <quicksilver> thanks ddarius
08:06:07 <temoto> oh i'm so happy
08:06:24 <temoto> But that's not really that, right?
08:06:53 <temoto> Because putStr probably does single write() while map would do (length s) write(), right?
08:06:53 * Berengal has written a few implementations of putStr himself
08:07:02 <sproingie> could be.  strings are lists after all
08:07:23 <aavogt> > gshow (1:2:3:[])
08:07:24 <lambdabot>   "((:) (1) ((:) (2) ((:) (3) ([]))))"
08:07:27 <sproingie> i should hope it collects them into a buffer at least
08:07:35 <Vanadium> temoto: you can call hPutChar a dozen times and still end up with a single write() because there almost certainly is application-level buffering
08:07:35 <benmachine> temoto: it's probably buffered, like C's stdio
08:07:45 <benmachine> and by probably I mean definitely
08:07:55 <temoto> Vanadium: application-level buffering?
08:08:05 <Berengal> Printing is interleaved with evaluation at least, and it doesn't force values until it's definitely going to print them
08:08:30 <temoto> benmachine: OS buffering is different matter. Let's not touch it to be clear.
08:08:52 <Vanadium> temoto: hPutChar does not translate into a write() with length 1, but into something that puts the character into a secret internally shared buffer, and then it checks whether the buffer is full and maybe calls write()
08:09:10 <Vanadium> Depending on buffering strategy, anyway
08:09:19 <temoto> Vanadium: isn't that against hPutChar definition?
08:09:38 <leimy> nope
08:09:45 <leimy> that's why you can set the buffering on a handle
08:09:45 <temoto> but mapM_ hPutChar, indeed should have the characteristics you described
08:09:52 <Vanadium> Presumably not, buffering is entirely legitimate
08:09:54 <leimy> hSetBuffering NoBuffering if you like.
08:09:57 <shapr> Vanadium: So, should I learn Haskell?
08:10:00 <leimy> no
08:10:02 <leimy> don't do it!
08:10:03 <leimy> :-)
08:10:09 <shapr> I've heard it's a fun language.
08:10:11 <Vanadium> shapr: Avoid it at all costs
08:10:18 <temoto> leimy: i guess that's about OS buffering, no?
08:10:30 <Vanadium> temoto: What do you mean by OS buffering, then?
08:10:34 <leimy> it doesn't have to be.
08:10:41 <Vanadium> Before it actually goes and talks to the filesystem/hard drive or whatever?
08:10:42 <leimy> I think he means stdout needs flushing :-)
08:10:46 <leimy> on a lot of platforms
08:10:56 <temoto> Vanadium: well OS buffers, you know. yeah.
08:10:59 <temoto> those
08:11:08 * benmachine is wondering about the relationship between things like fflush and things like fsync
08:11:28 <Vanadium> That is behind write(), and I am almost certain that even in C a putchar() or whatever will not immediately result in a write()
08:11:31 <temoto> like write() may write to those buffers, but flush() would wait until it actually done all talkings
08:11:34 <sproingie> OS buffering's similar but without application buffering you've already gone through the very slow path of a syscall every write
08:11:59 <sproingie> ANSI C does its own buffering
08:12:03 <quicksilver> if you are in fact curious, the GHC source to hPutStr is at http://www.haskell.org/ghc/dist/current/docs/libraries/base/src/GHC-IO-Handle-Text.html
08:12:26 <RayNbow> > head . sort $ "is it true that this has O(n) behaviour as said in http://www.reddit.com/r/programming/comments/ajztk/followup_to_functional_programming_doesnt_work/c0i075p ?"
08:12:27 <lambdabot>   ' '
08:12:45 <Vanadium> I believe it does
08:12:53 <Berengal> Haha, `getSomeCharacters :: Handle__ -> CharBuffer -> IO CharBuffer'
08:12:53 <temoto> Hm.. i'd expect C putchar() be not library-level buffered. I mean with unbuffered stdout, i'd expect putchar to be a real syscall every time.
08:12:57 <sproingie> it's likely O(n log n)
08:13:02 <benmachine> temoto: you can use a program like strace to find out when the actual write() occurs
08:13:08 <Ke> only application buffered changes are not visible outside the program, os buffering has no visible effects
08:13:10 <temoto> right
08:13:17 <Vanadium> temoto: unbufferd stdout is not the default, is it?
08:13:31 <temoto> Vanadium: i'm not sure.
08:13:32 <benmachine> temoto: FILE basically exists so that buffering can happen
08:13:40 <sproingie> actually sort could be partially finished but worst-case would still be n log n
08:13:40 <benmachine> otherwise everyone'd just use file descriptors
08:13:47 <Cale> It's very likely O(n)
08:13:57 <quicksilver> Haskell and stdio both default to line buffered for terminals, block buffered otherwise
08:14:02 <temoto> benmachine: FILE is an abstraction.
08:14:08 <Cale> and getting the first k elements, I believe is O(n log k)
08:14:08 <quicksilver> (although haskell doesn't *use* stdio buffering, it does its own)
08:14:15 <benmachine> temoto: but it's not a typedef int
08:14:27 <quicksilver> this is unix tradition.
08:14:29 <temoto> It ought to be an opaque thing.
08:14:29 <Cale> But I forget the exact analysis
08:14:42 <quicksilver> although being sensitive to whether it's a terminal or not is a gotcha which has confused many programmers :)
08:14:50 <benmachine> temoto: well it is, but if you go and look at the actual library it's a big struct
08:15:36 <Vanadium> temoto: putchar('x'); fputc('y', stderr); putchar('\n'); results in "yx" being displayed in my terminal, anyway - stderr is unbuffered by default, I believe stdout is linebuffered if C does that
08:15:38 <Berengal> quicksilver: You just need to remember to flush, something every child should know.
08:15:42 <sproingie> unix tradition that windows faithfully replicates
08:16:37 <temoto> Vanadium: wait, the 'line buffered' ought to be application level thing.
08:16:42 <Vanadium> It is!
08:16:45 <sproingie> i wouldn't mind the distinction in unix if it weren't so damn hardwired
08:16:47 <Jafet> Cale, lazy quicksort
08:16:50 <Cale> RayNbow: That's a nice thing about lazy evaluation and clever mergesort algorithms
08:16:51 <temoto> Vanadium: kernel should not know about line endings, right?
08:16:53 <Vanadium> I am just talking about application-level things
08:17:16 <quicksilver> temoto: these things are at the C library (and haskell library) level
08:17:16 <Cale> I'm not sure if it applies to quicksort as well
08:17:18 <temoto> Vanadium: so it means that C stdlib buffering is application (or library) level.
08:17:20 <quicksilver> so, yes, they are application level.
08:17:21 <Vanadium> yes
08:17:25 <Jafet> The implementation I'm thinking of can use up to O(n) space lying around, though
08:17:27 <quicksilver> the kernel is not involved there.
08:17:31 <Vanadium> But anyway, I fear I am not being very helpful and I have to leave in any case, so I am going to have to withdraw from this discussion
08:17:35 <sproingie> it's deeply wired into libc, not the kernel
08:17:47 <temoto> So then hPutChar buffering chars makes same sense as stdlib line buffering.
08:18:09 <quicksilver> Cale: yes, quicksort also defers (some of) the comparisons
08:18:14 <quicksilver> Cale: which is what makes you win.
08:18:17 * benmachine wonders what O(n log n) means when n = 1
08:18:27 <temoto> Vanadium: thanks for your help :)
08:18:28 <Jafet> In fact I'm not familiar with lazy mergesort, only quicksort
08:18:29 <quicksilver> Cale: but it does depend where your pivots end up.
08:18:30 <sproingie> you can unbuffer yourself but if you're using a pipe you can't control the other end.  telnet got this right, it can negotiate this sort of thing
08:18:41 <Cale> temoto: GHC puts a complicated layer in between the IO library and the OS which makes interactions with concurrency and such a good deal saner.
08:19:10 <Cale> temoto: So it's rather complicated to understand what things like putChar "really do" from the OS perspective.
08:19:14 <temoto> Cale: yeah i'mm tring to read the source :)
08:19:29 <temoto> hPutChar handle c = do
08:19:31 <temoto>     c `seq` return ()
08:19:31 <leimy> curiosity is bad
08:19:35 <temoto> this one i can't understand
08:19:37 * RayNbow just found http://stackoverflow.com/questions/1829038/short-circuiting-sort linking to further pointers about lazy sorting/selection
08:19:39 <Cale> quicksilver: Yeah, QuickSort is really O(n^2) anyway
08:20:01 <leimy> temoto: that forces c to be evaluated, and returns the value of return ()
08:20:10 <Cale> quicksilver: I wonder if that means it's worst case O(nk) or something to get the first k elements, hmm :)
08:20:16 <Jafet> Cale, it depends on the pivot selection
08:20:27 <leimy> it depends on luck
08:20:29 <leimy> and the pivot
08:20:29 <Cale> Yeah, I'm talking about the worst case.
08:20:29 <temoto> leimy: but there's more code after that!
08:20:32 <leimy> :-)
08:20:33 <Jafet> If you select somewhere close to the median each time it's O(n log n), of course
08:20:37 <sproingie> wow sort is insertion sort
08:20:44 <sproingie> @src sort
08:20:44 <lambdabot> sort = sortBy compare
08:20:46 <quicksilver> sproingie: no it's not. What are you reading is a lie.
08:20:46 <sproingie> @src sortBy
08:20:47 <Jafet> But that's expensive, might as well mergesort
08:20:47 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
08:20:55 <Cale> sproingie: It's not really. It's only *specified* that way.
08:20:57 <leimy> nooooo!
08:21:02 <jmcarthur> it's merge sort
08:21:05 <quicksilver> I think it's a stable merge sort.
08:21:08 <Jafet> sproingie, at least it isn't named qsort!
08:21:09 <Cale> GHC's sort is a merge sort
08:21:17 <sproingie> so the prelude lies?
08:21:25 <leimy> no.
08:21:29 <quicksilver> the prelude is a specification, not an implementation.
08:21:29 <benmachine> lambdabot lies quite frequently
08:21:35 <Cale> sproingie: The Report Prelude is intended as a specification, not an implementation.
08:21:43 <Cale> heh
08:21:47 <leimy> what those guys said!
08:21:48 <quicksilver> well arguably it is an implementation btu it's not compulsory to use it :)
08:21:50 <Cale> We all think almost identically now.
08:21:59 <benmachine> quicksilver: does it even compile?
08:22:00 <quicksilver> it's a specification and an example implementation ;)
08:22:10 <leimy> Cale: that's because we're not evaluated deeply enough
08:22:11 <quicksilver> no, because some things need a lower level
08:22:12 <Cale> THE HASKELL HIVE MIND WILL ASSIMILATE ALL
08:22:18 <quicksilver> and those things are left.
08:22:18 <benmachine> doesn't it have bits like data Integer = 1 | 2 | -- etc
08:22:19 <leimy> so we all appear to thunk the same way :-)
08:22:21 <quicksilver> (like putChar)
08:22:21 <sproingie> in the immortal words of johnny carson, "I did not know that.  That is weird wild stuff."
08:22:34 <quicksilver> groupthink++
08:22:49 <shapr> Whoa, I just realized I can defect... and be a student coder for Google SoC!
08:22:54 * ddarius highly suspects that the Prelude sort definition and GHC's differ on the behavior of not totally defined lists.
08:23:07 <Cale> ddarius: I was about to mention that
08:23:16 <Cale> ddarius: also, partially defined comparison functions
08:23:20 <leimy> quicksilver: groupthunk?
08:23:39 <rovar> is :   !foo <- doSomething     a valid use of a bang pattern?
08:23:49 <rovar> e.g. it will force the evaluation of doSomething?
08:23:57 <benmachine> ooh, giving ghci the same file multiple times confuses it
08:23:59 <quicksilver> Cale: partially defined comparison functions are clearly illegal Ord instances :)
08:24:00 <ddarius> rovar: It will force the evaluation of the result.
08:24:03 <shapr> rovar: I'd believe it... does it work?
08:24:24 <Cale> ddarius: We should be jerks and complain that GHC's sort is undefined in cases where the Report implementation is defined ;)
08:24:25 <rovar> i'm not sure. I'm trying to pinpoint the cause of  blocking/laziness in my tcp client
08:24:26 <sproingie> rovar: try it and see
08:24:40 <Cale> quicksilver: Well, it's more of an issue for sortBy, I suppose.
08:24:42 <rovar> it compiles and runs.. and sometimes partially works..
08:24:45 <quicksilver> rovar: magic 8-ball says : buffering.
08:24:49 <sproingie> ooh partially
08:25:02 <quicksilver> rovar: make sure you hFlush after every single write to a TCP socket.
08:25:03 <rovar> quicksilver,  i've disabled buffering on the socket, but I tend to agree with you
08:25:29 <quicksilver> are you writing and reading in different threads?
08:25:35 <quicksilver> if not it's a bit easy to deadlock.
08:25:39 <rovar> yea.. i'm sniffing the tcp port of the server and client.. the sends are getting sent.. and the replies are getting replied.. but my client doesn't acknowledge the replies
08:25:46 <sproingie> disable nagle
08:26:09 <sproingie> TCP_NODELAY i believe
08:26:09 <rovar> down with nagle!
08:26:12 <quicksilver> Cale: sortBy has a precondition that 'compare' should be a legal Ord instance :)
08:26:14 <rovar> hrrm..
08:26:22 <Cale> quicksilver: ah, okay
08:26:27 <leimy> nagle is an optimization that isn't
08:26:36 <quicksilver> I doubt that's rovar's problem but it's probably a good thing to eliminate.
08:26:43 <Jafet> Cale, demand quickchecking of the predicate!
08:26:50 <mux> leimy: nagle *is* an optimization, it just not appropriate if you care about latency
08:26:50 <sproingie> it was very useful when network interfaces were slow
08:26:57 <Berengal> groupBy has a precondition that 'eq' is an equivalence ;)
08:27:00 <leimy> mux: kind of.
08:27:04 <quicksilver> @hoogle NoDelay
08:27:05 <lambdabot> Network.Socket NoDelay :: SocketOption
08:27:15 <quicksilver> that's the haskell binding
08:27:20 <leimy> I'm trying to remember when nagling wasn't something I didn't want to turn off.
08:27:25 <leimy> and having difficulty :-)
08:27:35 <mux> actually, everytime you transmit a significant amount of data
08:28:01 <Cale> I think the preconditions on groupBy and nubBy should be removed.
08:28:09 <sproingie> a significant amount in small chunks that is
08:28:19 <Berengal> Cale: I agree, they're silly.
08:28:33 <quicksilver> Cale: as long as the specification is enhanced to explain the behaviour expected, yes.
08:28:41 <mux> in big or small chunks, same deal with respect to Nagle
08:28:42 <quicksilver> (I agree there is one sensible thing to expect)
08:28:47 <Cale> and GHC keeps getting the implementations wrong because of the silly incorrect spec.
08:28:52 <sproingie> you didn't want to buffer too much data in the application, and the network stacks didn't do zero-copy so you'd pay the price twice if you did
08:29:12 <rovar> hrrmm. how does one convert a Handle to a Socket?
08:29:14 <sproingie> thus you let the network stack do some of that buffering for you
08:29:22 <Cale> quicksilver: There's an easy way to specify it in English, but the code in the Report does an admirable job as well.
08:29:32 <rovar> i have socketToHandle
08:29:41 <leimy> I guess I'm kind of the exception though, since I write HPC apps that need the data to really get there, and TCP is not really a great choice for a set of messages.
08:29:49 <rovar> can I call   1/socketToHandle ?
08:30:00 <Berengal> That would be awesome if you could
08:30:17 <rovar> :P
08:30:23 <leimy> I'd like to see Nagle with some real time enhancements :-)
08:30:28 <leimy> and how nasty that'd get.
08:30:28 <mux> sproingie: besides, transmitting a significant amount of data in small chunks makes little sense with TCP
08:30:46 <leimy> big honkin headers :-)
08:30:53 <leimy> telnet is a great example
08:30:59 <rovar> i'll switch to non blocking read and see how much data actually arrives
08:31:00 <leimy> each character has like 40 bytes of overhead.
08:31:09 <sproingie> mux: some sources can't avoid it.  sensors may send lots of packets
08:31:13 <mux> pretty much anything not interactive benefits from Nagle's optimization
08:31:15 <temoto> Where is seq defined?
08:31:29 <Berengal> leimy: You don't know overhead until you've tried sending a byte array over SOAP...
08:31:31 <sproingie> there's also every time you type, tho i'm not sure that's a "significant amount"
08:31:35 <copumpkin> temoto: not within the language :)
08:31:39 <leimy> Berengal: Oh I've done SOAP
08:31:49 <leimy> Simple Object Access Protocol, my ass
08:32:02 <mux> sproingie: sensors?
08:32:12 <leimy> if SOAP were worth a damn, REST wouldn't have come along :-)
08:32:19 <Berengal> Indeed
08:32:26 <djahandarie> leimy, just like The Democratic People's Republic of Korea.
08:32:37 <leimy> the analogy is lost on me.
08:32:44 <sproingie> mux: yeah, like physical sensor data.  you might get tons of data in small packets.  tho i'd agree TCP is pretty crappy for that
08:32:48 <temoto> :t seq
08:32:49 <lambdabot> forall a t. a -> t -> t
08:32:57 <Berengal> Also, who thought it'd be a good idea to base64 encode the bytes, then split them up and send each in an <element></element> tag?
08:33:08 <djahandarie> leimy, it isn't democratic, the people's or a republic.
08:33:10 <sproingie> leimy: REST isn't an API or a library or anything but a style
08:33:16 <leimy> XML as a transport encoding is brain dead from day 1.
08:33:24 <temoto> Why does seq needs a t?
08:33:30 <mux> sproingie: sure; if you're not going to use congestion control, you have little to benefit from TCP, only retransmission and ordering
08:33:30 <sproingie> lots of polemic, few solutions to anything but CRUD apps
08:33:38 <temoto> Why isn't it just a -> a?
08:33:41 <leimy> temoto: chaining
08:33:48 <jmcarthur> temoto: what would force evaluation?
08:33:48 <leimy> a `seq` b `seq` c
08:33:49 <mux> and one could argue that in that case, SCTP is much more appriate
08:34:10 <leimy> sproingie: REST is like HTTP enhanced. :-)
08:34:13 <leimy> with some decorations.
08:34:16 <Berengal> "but XML is human readable!", well, read my SOAP messages if you can. I certainly can't...
08:34:18 <taruti> of course SCTP is not a realistical option at the moment (with firewalling nats)
08:34:19 <leimy> HTTP needs to die too actually
08:34:22 <leimy> and is dying
08:34:23 <sproingie> more like HTTP overloaded.  "four verbs".  piss off.
08:34:43 <jmcarthur> temoto: the idea is that you want to force the first argument whenever the whole expression is evaluated. if it was just a -> a then seq wouldn't acually be doing anything because that argument would have been evaluated anyway
08:34:45 <mux> taruti: and also few systems implement it for now
08:34:47 <leimy> WebSockets could have been avoided if we moved to something like BEEP
08:34:49 <lispy> leimy: the HTTP package on hackage or the protocol itself?
08:34:53 <temoto> jmcarthur: i think defining an argument doesn't imply it will be evaluated.
08:34:53 <leimy> HTTP itself
08:34:59 <leimy> it's been spread too thin :-)
08:35:08 <leimy> people don't want to admit they want peer to peer
08:35:17 <leimy> and they keep calling things service oriented architectures that aren't.
08:35:20 <Berengal> HTTP is good at what it's supposed to do
08:35:24 <leimy> yes.
08:35:28 <jmcarthur> temoto: consider this:
08:35:28 <sproingie> seriously i actually like REST, it's just the RESTifarians that bug me
08:35:30 <leimy> but it's abused.
08:35:36 <Berengal> But what it was supposed to do was decided 25 years ago
08:35:38 <leimy> sproingie: yeah.
08:35:56 <leimy> I mean google wants you to run your web apps in what amounts to a javascript powered VM.
08:35:59 <idnar> HTTP is just an implementation of REST
08:36:09 <leimy> with bidirectional communicative capabilities
08:36:13 <Berengal> leimy: Written in Java
08:36:15 <leimy> why stretch out a client server architecture for that?
08:36:19 <jmcarthur> > let foo (Just 5) = "foo" in const 2 (foo undefined) -- foo is strict, but in this use of it the argument is not evaluated because foo is not forced
08:36:20 <lambdabot>   2
08:36:30 <leimy> Berengal: java had a chance to be that VM platform for the web.
08:36:32 <leimy> but failed
08:36:42 <leimy> Inferno from Bell Labs had a chance to beat Java to the punch, and they failed.
08:36:44 <Berengal> leimy: Yes, but then they invented the java -> javascript compiler
08:36:47 <jmcarthur> temoto: foo, in this case, is a lot like your proposed seq. it takes a single argument
08:37:06 <leimy> now we have broken implementations of Javascript all over the place that are sometimes compatible.
08:37:07 <Berengal> leimy: And now you can write serverside and clientside code in the same language
08:37:10 <jmcarthur> temoto: but it will only be evaluated if the result is needed, which means it would have been evaluated anyway
08:37:15 <leimy> we'd have been better off with Java apps :-)
08:37:17 <sproingie> java's startup time and memory overhead really doomed it on browsers for the first several years
08:37:20 <Berengal> Hah
08:37:29 <leimy> yeah you can.
08:37:33 <leimy> but look at all the work you have to do to get there
08:37:36 <leimy> it's totally boneheaded
08:37:53 <leimy> It's like hack after hack, instead of a design, and an implementation.
08:38:02 <inimino> leimy: nonsense, JavaScript is quite interoperable
08:38:07 <temoto> jmcarthur: so it introduces another value for you to depend on, so if you depend on 't', then 'a' would *also* be evaluated?
08:38:12 <leimy> inimino: riiiiiight
08:38:14 <Berengal> leimy: I agree, the current situation is a bit messy to say the least
08:38:17 <leimy> tell that to my web developer friends :-)
08:38:20 <sproingie> once it started up, the performance was pretty nice.  i resorted to a lot of frame tricks to keep applets in the page
08:38:29 <sproingie> this was before iframes
08:38:33 <jmcarthur> temoto: that's the idea
08:38:35 <leimy> And then get back to me as to why Google's Wave doesn't work in Opera
08:38:42 <lispy> leimy: I'm not sure that design and implement works well for the first gen.  The first gen seems to grow up ad-hoc and organically
08:38:48 <mux> JavaScript interoperable? that would be nice.
08:38:53 <temoto> jmcarthur: thanks, i got it
08:38:59 <idnar> JavaScript is pretty interoperable
08:39:03 <idnar> it's the browser APIs that aren't
08:39:03 <sproingie> leimy: wave doesn't work for anyone not special enough to get the invite anyway
08:39:05 <inimino> leimy: perhaps you're confusing the language with the DOM
08:39:06 <jmcarthur> temoto: seq is just a way to say that you want one thing to be forced whenever another thing is forced
08:39:08 <mux> in theory sure.
08:39:13 <leimy> sproingie: you need an invite?
08:39:13 <temoto> But then i don't understand why hPutChar forces evaluation of its argument.
08:39:16 <mux> in pratice it ain't nowhere near that
08:39:16 <leimy> I've got 12 left
08:39:20 <leimy> and I'm not selling them on ebay
08:39:21 <idnar> it's like a bunch of different Haskell implementations with completely different and conflicting Preludes
08:39:21 <sproingie> leimy: sure, lay one on me :)
08:39:27 <mux> this is the reasons why jQuery, prototype and others exist
08:39:28 <leimy> msg me your email.
08:39:32 <idnar> well, I guess Prelude is the wrong module
08:39:45 <anee> people sell them? oh man
08:39:51 <idnar> the language itself is pretty near perfectly interoperable these days
08:39:59 <mux> in theory, sure
08:40:04 <rovar> runGet won't block if it doesn't have enough data, correct? I mean it should throw an error
08:40:05 <inimino> leimy, mux: can you name a single language feature that's not interoperable, without looking it up?
08:40:07 <inimino> mux: no, they exist because DOM is a poorly designed API, and poorly implemented
08:40:09 <inimino> mux: no, in practice
08:40:09 <idnar> in practice, too
08:40:10 <mux> you haven't done a lot of javascript lately, did you?
08:40:34 <idnar> mux: I spend about 50% of my time writing javascript
08:40:37 <mux> the practice is that sometimes you have to make your JS code work for IE6
08:40:51 <idnar> mux: I think you're missing my point
08:41:02 <leimy> inimino: no, because I've no desire to even try javascript at this point.
08:41:07 <idnar> mux: there's a difference between a language and an API
08:41:09 <inimino> mux: it's what I do full-time
08:41:22 <Jafet> DOM is part of Javascript as much as the GHC runtime is part of Haskell
08:41:24 <leimy> so why doesn't Wave work on Opera?
08:41:28 <leimy> if it's so compatible
08:41:33 <leimy> someone has to prove that it works
08:41:35 <leimy> not prove it doesn't work.
08:41:44 <mux> idnar: and there's a difference between theory and practice :-) yes, the ECMAScript standard defines a nice and interoperable language; in the end, you have to go through hoops to have your code work everywhere
08:41:44 <idnar> leimy: because it uses APIs that aren't implemented in Opera :P
08:41:49 <sproingie> it's amazing how much spam in my spam folder purports to come from me
08:41:51 <leimy> I mean it's easy to prove stuff doesn't work, like swine flu vaccines :-)
08:42:02 <mux> it is about the same for the DOM API or the language itself
08:42:04 <leimy> idnar: oh so it's not compatible :-)
08:42:04 <idnar> mux: I'm not aware of any outstanding ECMAScript incompatibility bugs in any of the major browsers
08:42:09 <inimino> Jafet: um, no.
08:42:14 * inimino sighs
08:42:14 <leimy> So the claim is it's a platform issue not a language issue?
08:42:15 <idnar> leimy: that has nothing to do with the language itself, though
08:42:21 <leimy> hmmm
08:42:23 <idnar> leimy: yeah, exactly
08:42:25 <Jafet> inimino, Javascript is not ECMAScript.
08:42:26 <leimy> ok
08:42:28 <leimy> I'll accept that
08:42:34 <astroboy> is there a way to have a o
08:42:37 <leimy> so Javascript as a platform is not compatible :-)
08:42:42 <idnar> leimy: there are specifications like DOM that are a) poorly implemented, but also b) insufficient in scope
08:42:44 <astroboy> to have a xoncurrent timeout with non-IO actions
08:42:44 <leimy> but Javascript as a language is pretty solid.
08:42:48 <Jafet> Javascript is that big moving browser target that changes buzzwords every five years
08:43:01 <rovar> wow.. it's blocking where i didn't expect it to block:
08:43:11 <inimino> leimy: maybe you missed it when I said "<inimino> leimy: perhaps you're confusing the language with the DOM"
08:43:11 <mux> idnar: you must be kidding; you're considering IE6, right?
08:43:14 <rovar> can I paste 3 lines? or should i use hpaste
08:43:14 <inimino> leimy: and JavaScript /isn't/ a platform, it's a languge
08:43:18 <leimy> inimino: probably :-)
08:43:29 <idnar> mux: what ECMAScript bugs does IE6 have?
08:43:44 <sproingie> "it's too big and it's too slow"
08:43:51 <pikhq> idnar: Most of them.
08:43:53 <jmcarthur> rovar: if you don't do it often i think three lines is okay. usually hpaste is easier to read anyway, though
08:43:56 <idnar> there may be one or two minor issues that I've forgotten, but everyone is pretty much on board these days
08:43:57 <Jafet> "I did her anyway"
08:44:09 <leimy> inimino: you're talking about the language as a specification, and then saying that the implementations are more or less compatible or correct, but they're not useful without the platform to run stuff on.
08:44:13 <inimino> leimy: the browser is the platform
08:44:13 <idnar> older versions of webkit had some rather serious problems parsing various forms of the function definition syntax, for example
08:44:14 <rovar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15937#a15937
08:44:15 <inimino> or rather, the browsers
08:44:26 <leimy> inimino: fair enough, so the problem is there's too many browsers
08:44:37 <rovar> so the putStrLn on 2 prints the correct value... putStrLn on 4 doesn't print at all.
08:44:43 <mux> idnar: so many that it's hard to list; off the top of my head for instance it doesn't properly handles some keywords being using as hash keys (in JSON notation)
08:44:49 <leimy> that doesn't change the crux of my argument that web devel is just such a quagmire I don't want to touch it.
08:45:15 <inimino> leimy: the only real problem is that people use IE.
08:45:15 <idnar> mux: I can't say I've ever run into that
08:45:18 <leimy> I've watched too many friends get old too fast fighting browsers :-)
08:45:21 <mux> idnar: but if we're talking about recent versions of ECMAScript,  IE6 even lacks implementing most of the language
08:45:21 <jmcarthur> rovar: a bug in getReply?
08:45:41 <leimy> inimino: wouldn't it be nice if people did all their webbing in a VM that was ported everywhere?
08:45:44 <leimy> oh, like Java :-)
08:45:52 <Berengal> rovar: Not even the first string?
08:45:52 <idnar> mux: well, I mean the version of ECMAScript it actually corresponds to
08:45:57 <leimy> I mean, I don't love java or anything either
08:45:57 <Berengal> rovar: The first part, that is
08:46:07 <idnar> obviously it doesn't implement ECMAScript versions that are newer than it
08:46:07 <leimy> but that vs browser incompatibility just sucks.
08:46:12 <rovar> Berengal,  nothing from line 4.
08:46:12 <leimy> maybe Chrome will just win.
08:46:15 <inimino> leimy: and for something like Google Wave, obviously they don't care much about making it work in other browsers at this point, they can't even make it stable in their own browser yet
08:46:16 <leimy> and take everything over.
08:46:18 <inimino> leimy: no, that would suck
08:46:20 <inimino> mux: IE implements ES3, just like every other current browser engine
08:46:23 <Berengal> rovar: Strange
08:46:25 <idnar> leimy: Java VM incompatibility isn't much fun, either
08:46:26 <sproingie> IE6 can be safely written off pretty soon
08:46:27 <mux> idnar: oh, another one, in IE6 there is no support for accessing a specific element of an HTMLElementCollection object with [i] syntax, as permitted by the specs
08:46:32 <leimy> inimino: it works in Firefox, Safari, and Chrome
08:46:34 <leimy> that's pretty good.
08:46:39 <idnar> mux: that's a DOM API issue
08:46:41 <rovar> jmcarthur,  getReply is a very simply set of get*s
08:46:43 <Jafet> Hi and welcome to #javascript
08:46:47 <rovar> i'll post it
08:46:48 <jmcarthur> hmm
08:46:53 <leimy> idnar: well j2me profiles suck
08:46:59 <temoto> Why hPutChar forces evaluation of its argument (the char)?
08:47:04 <Jafet> Please feel free to confuse it with Java.
08:47:05 <Berengal> getReply shouldn't be run before starting to print the string anyway
08:47:10 <leimy> heh
08:47:18 <mux> idnar: do you realize JavaScript is the ECMAScript language + the DOM API and afew other APIs? this whole conversation started out because we're saying *JavaScript* is not interoperable
08:47:20 <inimino> mux: that's not a language issue
08:47:31 <leimy> lol
08:47:34 <mux> idnar: you cannot walk into the discussion and make an arbitrary separation like that, you're not talking about the same thing.
08:47:35 <rovar> but i'm using !resp =   in hopes that it strictly evaluates
08:47:36 * leimy goes back to work :-)
08:47:49 <jmcarthur> well, it might not in the order it looks like though
08:47:51 <mux> inimino: that's a JavaScript issue.
08:48:01 <jmcarthur> Berengal: he might not see any output depending on buffering mode
08:48:10 <jmcarthur> some might still be evaluated properly
08:48:20 <inimino> mux: ...no it isn't
08:48:22 <inimino> mux: so, this whole conversation is about you not knowing what "JavaScript" means
08:48:25 <rovar> i've disabled buffering on the socket with hSetBuffering  NoBuffering
08:48:33 <idnar> mux: I don't think it's an arbitrary distinction, I think it's a pretty important one: if there's a platform incompatibility, you can write conditional code that implements platform-specific behaviour that corresponds to the platform you're running on
08:48:35 <jmcarthur> rovar: what about on stdout?
08:48:41 <rovar> ah..
08:48:41 <idnar> mux: if there's a language incompatibility, you can't even run your code
08:48:44 <rovar> not there...
08:48:51 <rovar> i will flush stdout
08:48:53 <mux> inimino: I just gave you the definition, if you look up, but that leads nowhere apparently. if you don't want to understand what I'm saying I'll stop there
08:48:59 <idnar> you have to just hope the common subset is sufficient to do what you need
08:49:07 <rovar> although i thought that putStrLn did it's own flush
08:49:14 <jmcarthur> eh, i would change the buffering so you can see the partial output of line 4
08:49:20 <inimino> mux: http://en.wikipedia.org/wiki/JavaScript
08:49:22 * inimino goes back to writing JavaScript for a living
08:49:29 <absentia> argh!
08:49:29 <jmcarthur> rovar: it might not flush until the whole string is output
08:49:31 <mux> idnar: the fact that it's not arbitrary, granted, doesn't still allow you to tell me I'm wrong by changing the meaning of what I originally said
08:49:38 <rovar> okay...
08:49:40 * Twey buys inimino a sympathy beer.
08:49:48 <jmcarthur> if only part of it evaluates successfully then a call to flush might never happen
08:50:12 * mux goes back to haskell coding
08:50:22 <inimino> thanks Twey :)
08:50:29 * jmcarthur goes back to linux kernel hacking
08:50:32 <Berengal> No sympathy bears for haskell coders
08:50:44 <idnar> mux: okay, sorry; given the definition of JavaScript you provided just now, I indeed agree with what you were saying
08:51:06 <mux> idnar: don't be sorry - let's just move on :-)
08:51:13 <rovar> jmcarthur, I have altered it so that it should be, most definitely printing "received" to stdout... it doesn't
08:51:51 <lispy> > let everyone = ":(" in \sympathy -> everyone
08:51:52 <lambdabot>   {()->":("}
08:51:58 <lispy> (sympathy lambda)
08:52:02 <jmcarthur> rovar: paste?
08:52:02 <Twey> Hehe
08:52:07 <rovar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15938#a15938
08:52:36 <aavogt> > asTypeOf ":("
08:52:37 <lambdabot>   ""->
08:52:37 <lambdabot>    ":("
08:52:37 <lambdabot>  "a"->
08:52:37 <lambdabot>    ":("
08:52:37 <lambdabot>  "aa"->
08:52:39 <lambdabot> [5 @more lines]
08:52:53 <rovar> getIntFromW32 = getWord32le >>= return . fromIntegral
08:52:56 <jmcarthur> rovar: if it blocks before it gets to hFlush then it will never flush
08:53:04 <jmcarthur> rovar: you should change the buffering mode on stdout instead
08:53:17 <lispy> > id
08:53:18 <lambdabot>   {()->()}
08:53:32 <rovar> but putStr "decoded response"  should never block, yes?
08:53:37 <lispy> The usefulness of that {} output is highly questionable, if you ask me
08:53:49 <lispy> Neat idea, but a little weird
08:53:50 <jmcarthur> rovar: you said it doesn't even print "received: "
08:53:53 <sproingie> rovar: it could if stdout is a pipe
08:53:56 <Jafet> It's not meant to be useful
08:54:08 <idnar> it's from smallcheck or something, right?
08:54:16 <Berengal> > (+1)
08:54:17 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
08:54:33 <rovar> I'm testing this in the ghci, would that make a difference?
08:54:42 <jmcarthur> dunno
08:54:49 <sproingie> in a dos window, stdout can block if you just start selecting text
08:55:04 <Berengal> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib
08:55:06 <lambdabot>   * Exception: stack overflow
08:55:12 <Berengal> :O
08:55:25 <jmcarthur> o_O
08:55:26 <Jafet> A strange value.
08:55:38 <jmcarthur> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 4
08:55:39 <lambdabot>   3
08:55:44 <rovar> okay... i disabled buffering on stdout.. same result.. it displays  "received: 20"
08:55:46 <mux> sproingie: that can happen under unix too, depending on the OS/terminal emulator
08:55:48 <rovar> then blocks indefinitely
08:56:04 <jmcarthur> rovar: oh so it *does* output "received: " ...
08:56:07 <Berengal> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib . (+3)
08:56:08 <lambdabot>   {-3->0;-2->1;-1->1;0->2;1->3;2->5;3->8}
08:56:26 <jmcarthur> rovar: did it output the 20 before?
08:56:31 <rovar> received, yes.. it doesn't print "decoded response"
08:56:34 <rovar> jmcarthur,  yes.
08:56:37 <jmcarthur> okay
08:56:43 <rovar> and 20 is correct.
08:57:03 <sproingie> mux: i've not seen that happen on any decent terminal but i suppose there's plenty of lousy ones
08:57:11 <jmcarthur> what does getBSONObject do?
08:57:29 <sproingie> finds the higgs bson
08:57:34 <rovar> and 20 bytes should be enough to decode the reply
08:57:52 <mux> sproingie: some make that happen when you use scrolling; for a more specific example, if you suppress output with the scroll lock key in a FreeBSD local tty, you can have stdout block
08:57:57 <rovar> jmcarthur,  more gets :)
08:58:04 <mux> sproingie: I found a locking bug in some code of mine once because of that
08:58:05 <sproingie> mux: oh right, i forgot about flow control
08:58:45 <rovar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15939#a15939
08:58:58 <mux> sproingie: in any case it's MUCH better to always consider stdout as potentially blocking
08:59:03 <rovar> starting on line 148
08:59:07 <mux> sproingie: this way your code will still works with shell redirections and pipes ;-)
08:59:22 <Jafet> > let fib n = case n of 0 -> 0; 1 -> 1; otherwise -> if n < 0 then fib (n+2) - fib(n+1) else fib (n-1) + fib (n-2) in fib
08:59:23 <lambdabot>   {-3->2;-2->-1;-1->1;0->0;1->1;2->1;3->2}
08:59:25 <sproingie> mux: don't i know it.  i go crazy with pipes.
08:59:55 <jmcarthur> eh, i have no idea what's going on
09:00:36 <rovar> :(    runGet shouldn't block.. if there isn't enough data present it should fail
09:00:43 <jmcarthur> yeah
09:00:58 <mux> sproingie: oh also, FWIW, in C, always assume that may get short writes on stdout (for similar reasons)
09:00:58 <rovar> unless.. maybe... since it is a Lazy ByteString  and the socket is Lazy.. it's trying to refill itself because it does need more data..
09:01:03 <rovar> but that seems highly unlikely..
09:01:15 <sproingie> mux: shouldn't get short writes if it's blocking
09:01:20 <jmcarthur> rovar: now that you have turned off buffering on stdout, what happens if you remove the ! from resp?
09:01:28 <mux> sproingie: pipes
09:01:37 <sproingie> mux: should only happen for broken pipes
09:01:45 <mux> they usually have a static buffer
09:01:50 <mux> they can totally return short writes
09:01:53 <sproingie> mux: sure, and when it fills, it blocks
09:02:03 <rovar> jmcarthur,  hah :)  it prints  "decoded response: " but not the  (show resp)
09:02:18 <mux> sproingie: I've *seen* code break because it didn't handle short writes on stdout, trust me!
09:02:29 <jmcarthur> rovar: yeah, that is definitely looking like a problem with either runGet or getReply
09:02:34 <rovar> that is crazy..
09:02:39 <sproingie> mux: i'll take your word for it, just haven't run into it myself
09:02:42 <rovar> jmcarthur, alright.. thanks for your help
09:02:55 <mux> sproingie: maybe it was with fifo?
09:03:05 <mux> but really you shouldn't assume anything about stdout
09:03:15 <mux> it could totally be a TCP socket
09:03:19 <sshc> why is "fail" a part of the Monad class?
09:03:27 <temoto> c `seq` return ()   evaluates c if 'return ()' is evaluated, right?
09:03:27 <rovar> i have to run to a meeting anyways..
09:03:34 <jmcarthur> rovar: you could try feeding runGet getReply the input directly instead of using the sockets stuff
09:03:36 <sproingie> sshc: it's a wart.  was there to handle pattern match failures for monad comprehensions
09:03:43 <jmcarthur> to make absolutely sure
09:03:43 <sproingie> actually for any do-block
09:03:46 <noddy2000> hey people? anyone has a copy of Ralph Hinze's Fun with phantom types handy? his former homepage went down it seems, and the new one doesn't host the papers...
09:03:48 <jmcarthur> probably much easier to test anyway
09:04:02 <rovar> jmcarthur,  I've tested the BSONValues stuff quite thoroughly
09:04:10 <mux> FreeBSD's portalfs (now dead) allowed stuff like: > /p/tcp/1.2.3.4/123
09:04:17 <mux> quite plan9-ish
09:04:24 <rovar> lots of crazy unit tests including bad strings.. it never blocked.
09:04:35 <Berengal> temoto: Yes, and return () is evaluated if it's in a do block
09:04:38 <jmcarthur> noddy2000: is it slides or a pdf or a blog article?
09:04:44 <leimy> someone tried to bring portalfs back
09:04:44 <sproingie> mux: i think gawk still has something like that built in (it's a hack of course)
09:04:51 <temoto> Berengal: aha, that's what i wanted to ask next.
09:05:01 <noddy2000> jmcarthur: a pdf
09:05:02 <temoto> Berengal: why return () is evaluated in do block?
09:05:06 <leimy> now it's all FUSE :-)
09:05:15 <jmcarthur> noddy2000: here are some slides http://docs.google.com/viewer?url=http://www.comlab.ox.ac.uk/people/ralf.hinze/talks/FOP.pdf&pli=1
09:05:19 <sproingie> i think all filesystems should be userspace
09:05:23 <mux> leimy: yeah, I think we got off nice on this one :-)
09:05:24 <Berengal> temoto: Well, not always, but it is in IO. It's how >>= works for IO
09:05:30 <jmcarthur> noddy2000: that's actually a pdf, i mean
09:05:33 <jmcarthur> but it's slides
09:05:38 <leimy> mux: FUSE is ok... I don't mind it much.
09:05:38 <leimy> I
09:05:38 <leimy>  th
09:05:38 <leimy> nk
09:05:39 <leimy>  
09:05:41 <leimy> whoah
09:05:44 <leimy> keyboard fail
09:05:45 <jmcarthur> o_O
09:05:48 <leimy> epic
09:05:50 <sproingie> e.e. leimy
09:05:52 <mux> leimy: that's basically what I was saying (I kinda like FUSE)
09:05:52 <noddy2000> jmcarthur: yeah, google, i think i heard of it sometimes..
09:06:03 <noddy2000> jmcarthur: but this is what i wanted: http://www.iai.uni-bonn.de/~ralf/publications/With.pdf
09:06:06 <p_l> sproingie: it's useful to have them in userspace, but sometimes you might want extra speed. OTOH, if you have hierarchical address spaces, you can have both ;-)
09:06:18 <leimy> NetBSD has a filesystem userspace layer too, and they integrated FUSE with it.
09:06:20 <sproingie> p_l: eh.  i think FUSE should be fixed so it's fast.
09:06:27 <taruti> p_l: actually FUSE can be quite fast.
09:06:29 <temoto> Berengal: >>= for IO evaluates stuff?
09:06:39 <Berengal> temoto: It's a useful trick if you need to control evaluation, for example when timing something you can do {start <- getCurrentTime; foo bar `seq` return(); stop <- getCurrentTime}
09:06:44 <leimy> There's also CUSE
09:06:49 <leimy> Character Devices in Userspace
09:06:53 <sproingie> it can be faster than the kernel since it admits threading much more easily.  but it still isn't all there.
09:06:53 <leimy> based on FUSE.
09:06:55 <pikhq> temoto: No, >>= states the order of evaluation.
09:06:59 <Berengal> temoto: It evaluates the IO actions. In a sense, this is where all evaluation is started
09:07:03 <pikhq> GHC evaluates main.
09:07:06 <p_l> sproingie: you can't get certain optimizations without kernelspace code (mainly playing around with caches)
09:07:11 <sproingie> how about Advanced Block Devices in Userspace?
09:07:13 <taruti> p_l: I got 600mbytes/sec write throughput in Fuse test (should release the new pure Haskell fuse binding soonish)
09:07:25 <mux> yay for pure haskell fuse bindings
09:07:27 <leimy> coool
09:07:33 <drhodes> anyone know if there's a parFilter?
09:07:41 <taruti> probably will have it on hackage in a week.
09:07:45 <sproingie> p_l: eh then imho that cache-playing-around should also be userspace
09:07:47 <leimy> FUSE let's you plug into KDE's kioslaves too I think
09:08:01 <sproingie> p_l: i'm a big believer in microkernels in case you hadn't noticed :)
09:08:24 <leimy> Plan 9's favored filesystem stuff is all userspace
09:08:33 <sproingie> plan9 is more unix than unix
09:08:38 <leimy> yep.
09:08:42 <taruti> and quite dead
09:08:45 <sproingie> :(
09:08:46 <leimy> it takes the philosophy of unix to the network.
09:08:56 <leimy> it's dead unless you buy anything from Coraid :-)
09:08:57 <sproingie> it takes it to the freakin window system
09:08:57 <Berengal> Unix is all about shell scripts...
09:09:02 <leimy> then you're getting Plan 9.
09:09:12 <mux> yeah, even the mouse driver outputs the mouse coordinates through a file
09:09:24 <leimy> and you can share all of that via 9P :-)
09:09:25 <sproingie> there was some oracle spinoff doing video streaming that ran on plan 9
09:09:27 <leimy> on the network.
09:09:28 <sproingie> ncubed i believe
09:09:32 <p_l> sproingie: sure, L4 has hierarchical Address Spaces, and is actually my preferred microkernel ;-)
09:09:33 <taruti> and of course there is 9vx too.
09:09:33 <mux> Plan9 sometimes sound like a bad joke, like Linux's procfs taken to the extreme
09:09:35 <sproingie> er ncube
09:09:44 <mux> I don't believe it makes sense to force every possible thing into the file abstraction.
09:09:49 <p_l> mux: except that procfs was imported from Plan9
09:09:49 <taruti> mux: it is actually very nice.
09:09:50 <leimy> Linux didn't invent procfs
09:09:52 <leimy> nor did Plan 9
09:10:00 <Jafet> unix relies too much on files already
09:10:01 <leimy> it came from a much later version of Unix :-)
09:10:04 <mux> I'm referring to their extended use compared to BSDs
09:10:09 <taruti> p_l: L4 lacks capabilities...
09:10:10 <mux> Linux puts a lot more things there than we do
09:10:20 <leimy> taruti: OKL4 has em!
09:10:24 <sproingie> actually plan9 isn't so much a filesystem abstraction as a remote stream abstraction via 9p
09:10:25 <leimy> well version 3.0 anyway.
09:10:30 <sproingie> the filesystem is just a convenient interface to 9p
09:10:45 <p_l> leimy: procfs was actually introduced in its current form in Plan9, but yes, Research Unix was there first
09:10:46 <mercury^> mux: you are a FreeBSD developer?
09:10:55 <mux> mercury^: yes
09:11:04 <leimy> p_l: yes
09:11:21 <leimy> being able to import a remote procfs to debug a process on a remote machine is nice.
09:11:21 <sproingie> sad to say i don't get into system-level programming any more
09:11:26 <mercury^> I agree that one can overexpose things through files.
09:11:30 <sproingie> i strictly deal with portable things like haskell and python and java
09:11:37 <leimy> The TCP/IP stack is in the filesystem too
09:11:47 <Jafet> sproingie, *cough*
09:11:55 <p_l> taruti: also, modern L4 has capabilities, also L4 only does minimal work in kernel, you want security, implement it in userspace ;-)
09:11:55 <jmcarthur> i get tired of system-level programming
09:11:59 <leimy> you can authenticate with a remote unix box, fire up "sshnet", and it creates a filesystem of handles that interface the remote TCP/IP stack
09:11:59 <mux> mercury^: nearly all the security bugs related to procfs stem from the fact that people tried to force some abstractions into the wrong shape
09:12:08 <mux> I think that's telling
09:12:12 <leimy> you can bind that over a process's /net, and voila, instant tunnel.
09:12:15 <taruti> leimy: haven't used OKL4 but it seems interesting
09:12:29 <leimy> taruti: it's heading towards the SeL4 stuff
09:12:31 <leimy> or L4se
09:12:35 <leimy> whatever it is :-)
09:12:43 <taruti> Coyotos seemed promising but is dead.
09:12:43 <leimy> and they dropped x86 support :-(
09:12:52 <Jafet> I think systems should rise in abstraction, instead of requiring programmers to fall
09:12:58 <leimy> Pistachio is still being developed though
09:13:01 <mwc> Hahaha, are we talking about hurd?
09:13:02 <p_l> mux: P9 doesn't clutter the namespace so much, but it also doesn't force everything into filesystem (there was proposition for exec()/fork() to be there...)
09:13:22 <mercury^> Of all the fancy operating systems of late, Singularity has the most appeal by far to me.
09:13:23 <leimy> p_l: processes only need to bind what they want to see.
09:13:29 <p_l> mwc: nah, not Mach-based stuff... Mach was a "giant-kernel" :P
09:13:29 <mux> p_l: sure; my opinion is just that they still go too far in that direction
09:13:34 <leimy> then the namespace seems sall.
09:13:42 <p_l> mux: have you seen PlanB ?
09:13:44 <leimy> mercury^: Singularity is a lot like Inferno
09:13:45 <mux> p_l: nope
09:13:52 <tener> what should i do to get containers working with GHC 6.12.1 ?
09:13:54 <jmcarthur> p_l: hurd isn't mach-based anymore, is it?
09:13:57 <leimy> single address space OS.
09:14:00 <mwc> ahhh, see, Hurd started on Mach, then went to L4, now is on Coyotos
09:14:01 <jmcarthur> i thought they were moving to l4 or something
09:14:10 <taruti> jmcarthur: currently it is mach based.
09:14:11 <sproingie> mwc: cue up duke nukem forever jokes
09:14:13 <mwc> or they're porting to Coyotors or something
09:14:18 <Jafet> leimy, the similarity extends farther
09:14:22 <mercury^> leimy: I did not read about inferno very much. But I disliked some things about the language used, and I did not hear about static verification of security properties either.
09:14:30 <jmcarthur> mwc: and i thought coyotos was also going to use l4
09:14:35 <taruti> they first tried to port it to L4. failed. then coyotos. then coyotos died.
09:14:36 <p_l> mux: it exploits 9p to create a cluster system with various nice ubiquitous computing capabilities, without making a single change in kernel
09:14:43 <leimy> mercury^: Limbo does put some folks off.  Some of Limbo lives on in Go.
09:14:49 <jmcarthur> ah
09:14:53 <sproingie> there are probably still more developers interested in coyotos than hurd
09:15:10 <p_l> leimy: Well, Go is actually implemented using P9 tools... :P
09:15:14 <leimy> Inferno is cool because it runs hosted on my Mac, and I can compile it for my nintendo DS,
09:15:19 <leimy> and it runs the same binaries :-)
09:15:21 <leimy> like java.
09:15:21 <taruti> Go has potential to be kind of nice.
09:15:29 <mux> p_l: as Jafet said - I think - I'm more interested in seeing OSes move into higher levels of abstractions, and use higher-level languages from the ground up
09:15:34 <Jafet> Like buttsex
09:15:40 <taruti> Buf currently is quite lacking.
09:15:49 <mux> p_l: not saying that what they're doing isn't interesting either
09:15:53 <tarleb> brief style question: which method is preferable when combining functions: foo $ bar $ baz n  or foo . bar . baz $ n ?
09:16:01 <leimy> p_l: the plan 9 compiler toolchain is really simple.
09:16:06 <mercury^> tarleb: the latter.
09:16:14 <tarleb> mercury^: k, thanks
09:16:19 <mercury^> But it's a bit harder to write down I find. :(
09:16:24 <mercury^> You have to think more.
09:16:39 <tarleb> true
09:16:48 <Berengal> What do you people think of an -XAlternativePrelude extension to haskell, or some other way of importing a module in every other module in a build?
09:16:50 <p_l> mux: I'm personally interested in something similar to Sun's Spring OS, with extra support for high-level languages (current plans for my own implementation suggest runtimes for CL, Forth, Erlang and Haskell :D)
09:17:01 <Jafet> It depends on whether you (want the reader to) think in terms of data processing, or composing functions, tarleb
09:17:09 <leimy> But yeah Singularity looks neat
09:17:24 <Twey> Berengal: Sounds good
09:17:32 <mercury^> Jafet: the associativity of ($) is deprecated.
09:17:34 <mwc> Hmph. Posix should have mmap. The mmap package doesn't have a wrapper accepting a plain file descriptor. As far as I can tell then, System.Posix.SharedMem is completely useless.
09:17:36 <Twey> Can we specify the module to import somehow?
09:17:37 <leimy> Jafet: sometimes I'm able to explain a haskell program in terms of the way data flows through transformations.
09:17:49 <jmcarthur> Berengal: so instead of import AlternativePrelude you do {-# LANGUAGE AlternativePrelude #-}? ...
09:17:58 <solidsnack> Berengal: I would like it.
09:18:02 <Berengal> Twey: Obviously, or it'd be quite useless
09:18:03 <jmcarthur> and still have to specify the module somehow
09:18:14 <solidsnack> Berengal: Especially for use with -e
09:18:19 <Jafet> mercury^, what do you mean? It isn't associative anymore?
09:18:19 <Berengal> jmcarthur: Yes, or -XAlternativePrelude=MyPrelude
09:18:20 <leimy> In fact, I wrote a simulator for a piece of hardware we had in 100% point free style.
09:18:27 <jmcarthur> i guess for a .cabal file it would be alright
09:18:33 <mercury^> Jafet: it will be left associative in the future.
09:18:33 <leimy> I said "hey boss look!  No variables!"
09:18:34 <Twey> Berengal: Well, I thought perhaps you had a particular alternative prelude in mind (alt-stdlib, NumericPrelude, UnicodePrelude, &c.)
09:18:35 <sproingie> jmcarthur: i imagine it would be something you'd specify in cabal
09:18:49 <Berengal> jmcarthur: To make it easier to try out a different Prelude, rather than importing the alternative specifically in every module
09:19:11 <jmcarthur> Berengal: yeah, that would be nice
09:19:24 <Berengal> Twey: Not one specific, but the set of alternatives we have, to make it easier to try out alternatives
09:19:26 <Twey> It annoys me to have to {-# LANGUAGE NoImplicitPrelude #-} import SomeOtherPrelude every time
09:19:27 <Jafet> Berengal, sed!
09:19:28 <jmcarthur> Berengal: i would love it for alt-stdlib, once we are at a point where it's worth playing with
09:19:29 <Twey> *nod*
09:19:30 <Kruppe> is "read" from Prelude really slow?
09:19:32 <Twey> I like the sound of that
09:19:35 <Twey> Kruppe: Not really
09:19:41 <Twey> It's pretty fast
09:19:48 <sproingie> Berengal: you may as well generalize it.  -XSubstituteModule="Prelude=MyPrelude".  or whatever hairy syntax would be better.
09:20:02 <Twey> sproingie: :-\
09:20:05 <Jafet> sed.
09:20:05 <jmcarthur> there are several things i would like to add/change in ghc for alternative preludes
09:20:07 <Twey> I'm not sure I like that.
09:20:08 <aavogt> mercury^: you had me confused by suggesting we ever had:  f $ (g $ x)  == (f $ g) $ x
09:20:11 <solidsnack> It would be nice to have a `.ghcrc' with these things in them.
09:20:14 <Kruppe> doing a profile on the execution of my program and it looks like a function which only really uses read is taking up most of the cpu time
09:20:15 <Twey> Jafet: Doesn't work
09:20:25 <Jafet> sed is turing-complete
09:20:29 <Berengal> sproingie: Well, the Prelude is the only implicitly imported module we have. I don't expect the alternatives to have the same interface, which may indeed be the point
09:20:29 <Twey> Jafet: ‘Prelude’ would have to be imported specifically anyway
09:20:41 <Twey> And it would still have to be done to every file
09:20:44 <jmcarthur> i would also like to change the way do notation works. currently if you separate fail into a separate type class then do notation will require it even if you don't use a failable pattern
09:20:58 <Jafet> Twey, it would
09:21:09 <Twey> Thereby completely defeating the point :þ
09:21:20 <Berengal> jmcarthur: No, that works with -XNoImplicitPrelude
09:21:20 <Twey> jmcarthur: How would you suggest it work?
09:21:22 * Jafet sticks a thorn into Twey
09:21:30 * Twey enjoys
09:21:46 <Cale> Twey: Presumably something similar to how 1.4 did it with MonadZero
09:22:23 <jmcarthur> Twey: i think do notation currently inserts uses of fail even when it's impossible for them to be called. i would propose to get rid of that unnecessary behavior for patterns that are not failable
09:22:41 <Kruppe> could the supposed slowness of read in my case potentially be that thats only part of my program where the thunk actually gets calculated?
09:22:45 <Cale> That is, only introduce fail in cases where pattern matching on a constructor of a type which has more than one (a failable pattern)
09:22:53 <jmcarthur> right
09:23:29 <lispy> Where is the haskell platform?
09:23:37 <Twey> Cale, jmcarthur: Aha
09:23:40 <taruti> an easy way is just to avoid do-notation for your structure ;)
09:23:44 <aavogt> @undo do First x <- First (Just ()); return $ x `mappend` Nothing
09:23:45 <lambdabot> First (Just ()) >>= \ a -> case a of { First x -> return $ x `mappend` Nothing; _ -> fail ""}
09:23:46 <Twey> That's true
09:23:55 <Twey> Though I also have a problem with fail being so limited
09:24:21 <Twey> (and MonadZero with MonadPlus might be a fairly confusing choice of name)
09:24:24 <jmcarthur> taruti: yeah, but even i will admit that do notation sometimes is syntactically preferable
09:24:34 <taruti> Twey: what would you like the type of fail to be?
09:24:34 <Twey> It surely is
09:24:58 <Twey> taruti: fail :: a -> m b
09:25:22 <aavogt> so a multiparameter typeclass?
09:25:37 <Twey> Hm
09:25:39 <taruti> Twey: so how would a failed value be catched? nothing useful can be done with 'a'.
09:25:42 <Twey> Not ‘a’
09:25:57 <Twey> Some sort of useful information about the actual failure
09:26:09 <aavogt> class Failing m a | m -> a where fail :: a -> m b
09:26:13 <jmcarthur> i think it would be nice to have a normal algebra and also an algebra for functors. maybe not as complex for the latter since it is probably less used anyway
09:26:23 <taruti> well you can have "failFoo :: MyType -> MyMonad b"
09:26:26 <Twey> Is it possible for the monad to provide its own type to use there?
09:26:28 <jmcarthur> and the whole "fail" thing would be captured in the algebra
09:26:32 <lispy> Is this link broken for you guys? http://hackage.haskell.org/platform
09:26:37 <Twey> aavogt: Ah, that sounds right, maybe
09:26:39 <leimy> yes
09:26:46 <Twey> Argh
09:26:48 <taruti> fail is only needed for automatically generated code from the do-notation.
09:26:50 <Twey> Hackage is down *again*
09:26:59 <leimy> no
09:27:03 <leimy> but the platform page is.
09:27:03 <taruti> Twey: it is being migrated. See the ml.
09:27:04 <aavogt> but that sort of destroys properly polymorphic monadic code
09:27:12 <Twey> Oooh, Haskell 2010
09:27:23 <Cale> Haskell 2010 is *really* boring
09:27:37 <lispy> Igloo: Paul tells me I should ping you about this instead of him.  It looks like the HP is missing at the moment, http://hackage.haskell.org/platform
09:27:39 <taruti> the most conservative extensions possible.
09:27:42 <HugoDaniel> why Cale ?
09:28:00 <Cale> There are even boring extensions that everyone uses which weren't included.
09:28:02 <Twey> aavogt: Hmm :-\
09:28:04 <aavogt> as in,   when  m :: Either String, fail :: String -> Either String a, but  m :: Maybe, fail :: () -> Either String a
09:28:05 <Twey> Yeah.
09:28:11 <lispy> Boring in the sense that it's conservative and non-novel
09:28:12 <jmcarthur> Haskell 2010: "Hey look, we're actually getting something done!"
09:28:13 <taruti> most of hackage is not haskell2010 compatible.
09:28:27 <Twey> Perhaps a Failure type that contains actual useful readable information about the failure
09:28:30 <jmcarthur> Haskell 2011: "Okay, let's do something useful now."
09:28:41 <Twey> (the value passed, the pattern that failed on that value, &c.)
09:28:44 <Twey> jmcarthur: Heh, yeah
09:28:46 <leimy> haskell 2010, because C++0x is a misnomer, unless they meant C++0xa
09:28:46 <Cale> and one of the things which was approved is a step in the wrong direction :P
09:28:58 <Cale> (The do-and-if-then-else thing)
09:29:06 <leimy> Cale: hmmm?
09:29:08 <Twey> Which one is that?
09:29:08 <leimy> got a link to that?
09:29:16 <leimy> n+k patterns going away seems good :-)
09:29:24 <jmcarthur> well, good-ish
09:29:48 <Cale> http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
09:29:51 <jmcarthur> i don't think their presence was harmful besides more to maintin in the compilers
09:30:00 <taruti> base is not Haskell-2010 compatible :(
09:30:01 <Cale> "let's help beginners indent their code improperly"
09:30:02 * ddarius is also against that proposal.
09:30:12 <Cale> *facepalm*
09:30:23 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15940#a15940
09:30:31 <leimy> oh
09:30:33 <HugoDaniel> is haskell 2010 going to be released in 2012 ?
09:30:33 <leimy> duh
09:30:37 <jmcarthur> ew
09:30:50 <Berengal> HugoDaniel: Haskell 2010 was released last November
09:30:53 <Twey> Oh, that one
09:31:07 <Twey> Hm, I don't really see the problem
09:31:19 <Twey> It's an unambiguous parse, and it does make sense semantically
09:31:32 <jmcarthur> Berengal: is that how it works or how it *should* work?
09:31:41 <Berengal> jmcarthur: It's how it works
09:31:53 <Twey> It fits well with (the existing) case layout, too
09:31:55 <Berengal> jmcarthur: You don't even need the pattern in nofail2 to be irrefutable
09:32:03 <leimy> Cale: I guess I don't care about that so much
09:32:14 <Cale> leimy: Well, yeah.
09:32:20 <Cale> It's just awkward.
09:32:21 <jmcarthur> Berengal: huh... because it's lazy?
09:32:21 <taruti> Berengal: "class MonadFail m where" => "class Monad m => MonadFail m where"
09:32:24 <leimy> I think that indentation having semantics is a mixed bin of pain
09:32:31 <leimy> it's both nice, and dumb to require it
09:32:35 <Berengal> jmcarthur: No, because there's only one constructor
09:32:39 <ddarius> It's not required.
09:32:42 <leimy> but Haskell in non-layout mode looks weird to me now.
09:32:49 <Cale> leimy: It's already not required.
09:32:50 <Berengal> jmcarthur: Make the Just x case irrefutable as well, and it removes the call to fail
09:33:00 <leimy> Cale: yeah I know you can code Haskell without layout
09:33:05 <jmcarthur> Berengal: i could have sworn that do notation simply forced me to use fail
09:33:08 <leimy> i just say it looks odd to  me now.
09:33:20 <leimy> Python, for better or worse, is readable sort of universally.
09:33:26 <Cale> leimy: But I actually think that if/then/else in layout mode should have *stricter* rules.
09:33:28 <leimy> due to forcing people to use a layout.
09:33:35 <Berengal> jmcarthur: It doesn't. Do notation is desugguared before name-bindings happen
09:33:36 <aavogt> @undo do First x <- First (Just ()); return $ x `mappend` Nothing -- this is not an unnecessary fail?
09:33:36 <lambdabot> First (Just ()) >>= \ a -> case a of { First x -> return $ x `mappend` Nothing; _ -> fail ""}
09:33:37 <leimy> Cale: Yeah, imagine nesting them.
09:33:43 <Cale> In particular, I think we ought to insist that the 'then' and 'else' should line up.
09:33:49 <leimy> however, I have to say, I never use if then else :-)
09:33:52 <Berengal> jmcarthur: I think the GHC docs have a complete list of things that are rebindable with NoImplicitPrelude
09:33:57 <leimy> a lot of times, I don't think it's useful :-)
09:34:15 <Cale> Well, it's nicer than using case
09:34:24 <leimy> It can be.
09:34:28 <Cale> I suppose another option is to use a function
09:34:32 <leimy> I find a lot of times when I have to "if" I'm using Maybe
09:34:39 <leimy> and when I use Maybe, I use MonadPlus :-)
09:34:42 <Cale> But that's often kind of hard to read by comparison
09:34:43 <Twey> Hehe, aye
09:34:49 <Twey> Or Either
09:34:52 <leimy> so I avoid case and if a lot.
09:34:56 <leimy> right
09:35:09 <aavogt> MonadPlus Maybe has an arbitrary order if both are Just
09:35:19 <aavogt> > Just 1 `mplus` Just 0
09:35:20 <lambdabot>   Just 1
09:35:27 <leimy> are you saying that could be Just 0?
09:35:35 <jmcarthur> yeah, i'd prefer MonadPlus First and MonadPlus Last instead of MonadPlus Maybe
09:35:38 <Cale> actually, I suspect a lot of the times that I use if/then/else, what I really want is  bool :: a -> a -> Bool -> a
09:35:41 <Twey> leimy: filter = fmap rights . flip ap id . fmap (zipWith (Right ?? Left)) . fmap
09:35:47 <Twey> *grin*
09:36:04 <Twey> Cale: Well yeah, it can always be replaced by bool/(??)
09:36:11 <aavogt> yes, leimy
09:36:14 <leimy> I'm pretty sure that mplus has to apply currying doesn't it?
09:36:15 <leimy> a
09:36:15 <leimy> nd
09:36:15 <leimy>  e
09:36:16 <leimy> va
09:36:16 <leimy> l
09:36:17 <leimy> u
09:36:20 <jmcarthur> o_O
09:36:21 <leimy> wow this keyboard is effed
09:36:23 <mercury^> Cale: err, is there a semantic difference between the two?
09:36:33 <Twey> Woah
09:36:33 <gio123> Cale: I pasted again a short text
09:36:33 <Cale> mercury^: no
09:36:33 <gio123> :)
09:36:43 <leimy> That was weird.
09:36:45 <Twey> mercury^: No, it just results in nicer code 90% of the time
09:36:48 <leimy> brb
09:36:49 <Polarina> Is it possible to have something similar to 'break', but does not include the element it was reading when it got a True.
09:37:04 <jmcarthur> :t break
09:37:05 <Twey> (10% it requires an extra pair or two of brackets)
09:37:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:37:11 <mercury^> Just define it then.
09:37:22 <Berengal> Polarina: second tail . break
09:37:22 <Twey> Polarina: first init . break?  :þ
09:37:31 <Twey> Oh, it goes in the snd?
09:37:33 <Twey> D'oh.
09:37:36 <Polarina> I'll try these out.
09:37:37 <Cale> mercury^: I'm thinking it would be nice to have bool in the Prelude.
09:37:40 <leimy> anyway, I thought that the first argument to mplus would have to be evaluated first, but i guess not.
09:37:46 <Berengal> Twey: Either way, we must now fight to the death
09:38:14 * Twey takes out his bat'leth
09:38:28 <Twey> Cale: I concur
09:38:35 <aavogt> > let mplus _ (Just x) = Just x; mplus (Just x) _ = Just x; mplus _ _ = Nothing in Just 1 `mplus` Just 0
09:38:35 * Berengal selectes some pointy lambdas
09:38:36 <lambdabot>   Just 0
09:38:45 <Polarina> Berengal, Twey: These are not going to work as the snd of the pair can be an empty list (nothing to break).
09:39:05 <jmcarthur> Polarina: second (drop 1) . break
09:39:21 <Twey> Oh, yeah, that's nicer… I was going for a Maybe solution :þ
09:39:23 <leimy> Well I read the definition of mplus for Maybe, and it does what I want.
09:39:42 <Twey> leimy: It does what you want, but for no good reason.
09:39:44 <Polarina> @src second
09:39:44 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:39:44 <leimy> problem is that can't be counted on.
09:39:50 <Twey> That's what the ‘arbitrary’ bit means.  :þ
09:39:53 <Polarina> jmcarthur: What's 'second'?
09:39:53 <Twey> @src (->) second
09:39:54 <lambdabot> second f = id *** f
09:39:55 <leimy> yeah I got that.
09:40:00 <Twey> Polarina: It's an Arrow method
09:40:02 <jmcarthur> :t second
09:40:03 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
09:40:06 <Polarina> Twey: ?
09:40:06 <aavogt> @src (,) second
09:40:07 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:40:17 <Polarina> I don't know what that is.
09:40:17 <jmcarthur> @src (->) second
09:40:17 <Twey> Er, yeah
09:40:17 <lambdabot> second f = id *** f
09:40:24 <jmcarthur> @src (->) (***)
09:40:24 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
09:40:38 <Polarina> Could someone explain, without code?
09:40:41 <Twey> :t second (undefined :: a -> a)
09:40:42 <lambdabot> forall b d. (d, b) -> (d, b)
09:40:50 <Twey> :t second (undefined :: a -> b)
09:40:51 <lambdabot> forall b c d. (d, b) -> (d, c)
09:40:52 <jmcarthur> > second (+5) (1, 2)
09:40:53 <lambdabot>   (1,7)
09:41:02 <jmcarthur> Polarina: ^^ there's a simple example
09:41:09 <leimy> again, i think this arbitrary choosing of which side to evaluated first for mplus or to return is yet another example of why "Yes, you do have to learn category theory to use haskell, because the APIs seemingly assume you do know it."
09:41:21 <jmcarthur> Polarina: but second is actually more general than that
09:41:40 <jmcarthur> leimy: huh?
09:41:43 <aavogt> leimy: how does category theory help you there?
09:41:45 <Twey> leimy: I don't think that this is covered by category theory…
09:41:54 <jmcarthur> leimy: it's just a bad design choice
09:41:58 <leimy> Isn't MonadPlus some weirdo category theory stuff?
09:41:58 <Twey> Category theory certainly doesn't insist upon arbitrariness :þ
09:42:00 <Polarina> jmcarthur: Thanks.
09:42:07 <Twey> No
09:42:11 <leimy> hmmm
09:42:14 <jmcarthur> leimy: if we had MonadPlus First and MonadPlus Last instead of MonadPlus Maybe then this problem wouldn't exist
09:42:14 <leimy> ok I stand corrected
09:42:17 <leimy> it's just the docs that suck then.
09:42:17 <Polarina> But 'second' is not defined in my ghci interface.
09:42:29 <jmcarthur> Polarina: it's in Control.Arrow
09:42:29 <Twey> jmcarthur: I have no idea what you just said!
09:42:31 <leimy> Warning, don't use this, it's meaningless :-)
09:42:31 <aavogt> newtypes are inconvenient sometimes though
09:42:37 <Polarina> jmcarthur: Thanks.
09:42:42 <jmcarthur> Twey: see First and Last in Data.Monoid
09:42:45 <Twey> Oh
09:42:46 <leimy> yeah
09:42:56 <leimy> hmm one could write that.
09:43:15 <Cale> Maybe shouldn't even be MonadPlus, it should be MonadOr
09:43:30 <Twey> Cale: So then it's left-first?
09:43:34 <Cale> Yeah
09:43:41 <leimy> ooh
09:43:51 <aavogt> or is like plus
09:43:51 <leimy> Maybe on MonadOr would rock.
09:43:52 <Twey> It's still arbitrary, but I guess it's de-facto–standardly arbitrary :þ
09:44:04 <Cale> leimy: MonadPlus doesn't really correspond to anything commonly defined in category theory
09:44:11 <jmcarthur> i'd still prefer First and Last
09:44:19 <leimy> Cale: so why call it "Monad" anything?
09:44:24 <aavogt> Monador
09:44:27 <ehird> @hoogle <$>
09:44:27 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
09:44:29 <jmcarthur> Cale: well, it's a Monoid
09:44:38 <jmcarthur> oh, yeah, not category theory specifically
09:44:39 <leimy> MonadPlus and Monoid aren't the same though
09:44:44 <leimy> people keep saying that to me when I started
09:44:46 <Cale> leimy: Because it's a class of monads which have an operation that interacts with the monad operations in a particular way
09:44:53 <leimy> even though they seemed related.
09:45:04 <jmcarthur> leimy: yeah, MonadPlus requires that it be a Monoid even not taking the argument into account
09:45:08 <jmcarthur> they are related
09:45:09 <leimy> So why not call it "PlusMonad" :-)
09:45:09 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
09:45:11 <Cale> ^^ read
09:46:19 <leimy> I think in a lot of cases, I should just learn to use Applicative in a better way
09:46:27 <leimy> and stfu and like it.
09:46:36 <Cale> Though the commentary under "Discussion" is silly.
09:46:51 <quicksilver> Alternative is their for Applicative
09:47:04 <quicksilver> but isn't Alternative supposed to be more like MonadOrElse?
09:47:12 <leimy> ugh
09:47:14 <quicksilver> s/their/there/
09:47:17 <temoto> Given a list of IO (), how would you wait for completion of all operations?
09:47:27 <jmcarthur> i think it is unspecified how Alternative is related to MonadPlus
09:47:31 <opqdonut> temoto: sequence_
09:47:35 <opqdonut> :t sequence_
09:47:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
09:47:43 <leimy> So is Alternative a better choice than mplus ? :-)
09:47:46 <leimy> for Maybe stuff?
09:47:55 <leimy> or is it too an arbitrary evaluation order
09:47:55 <jmcarthur> depends on if they gave it the same behavior
09:48:00 <aavogt> > Maybe 1 <|> Maybe 0
09:48:00 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe'
09:48:05 <jmcarthur> well, it must be *arbitrary*
09:48:09 <leimy> > Just 1 <|> Just 0
09:48:09 <aavogt> > Just 1 <|> Just 0
09:48:10 <lambdabot>   Just 1
09:48:10 <lambdabot>   Just 1
09:48:15 <taruti> leimy: Alternative is nice
09:48:17 <jmcarthur> since there are two valid possibilities
09:48:26 <phr> > sequence [[1,2],[3,4,5]]
09:48:27 <lambdabot>   [[1,3],[1,4],[1,5],[2,3],[2,4],[2,5]]
09:48:28 <leimy> > Nothing <|> Just 1
09:48:29 <lambdabot>   Just 1
09:48:32 <quicksilver> temoto: make them all write to an MVar when done.
09:48:37 <leimy> > Just 1 <|> Nothing
09:48:38 <lambdabot>   Just 1
09:48:40 <quicksilver> (or a Chan)
09:48:57 <leimy> I'm more concerned with a real evaluation order.
09:49:06 <Polarina> Could someone explain to me (***)? Please, don't do @src. :(
09:49:07 <temoto> Somewhy i like sequence_ because it's type looks like what i want.
09:49:14 <temoto> What does sequence_ do?
09:49:18 <leimy> @src (***)
09:49:19 <lambdabot> f *** g = first f >>> second g
09:49:19 <temoto> @src sequence_
09:49:19 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
09:49:23 <quicksilver> temoto: runs them one after another
09:49:34 <quicksilver> temoto: something about your wording suggested to me oyu wanted to run them concurrently.
09:49:37 <temoto> of course! foldl
09:49:43 <aavogt> again, arbitrary choices!
09:49:44 <quicksilver> temoto: if you want them one after another, then, yes, sequence_ is what you want.
09:49:53 <jmcarthur> > (+4) *** (-4) $ (10, 10)
09:49:53 <lambdabot>   No instance for (GHC.Num.Num (b' -> c'))
09:49:54 <lambdabot>    arising from a use of syntactic...
09:50:04 <taruti> Has anyone implemented counters in STM with better handling of contention (since counters don't need to rollback other transactions as often)?
09:50:06 <jmcarthur> > (+4) *** (*4) $ (10, 10)
09:50:07 <lambdabot>   (14,40)
09:50:21 <Polarina> jmcarthur: Ah, nice. Thanks.
09:50:26 <rovar> jmcarthur,  http://www.haskell.org/pipermail/libraries/2008-May.txt  (search for "it blocks"
09:50:54 <temoto> :t >>
09:50:55 <lambdabot> parse error on input `>>'
09:50:59 <temoto> :t (>>)
09:51:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:51:06 <jmcarthur> rovar: yuck
09:51:12 <Twey> @info Applicative
09:51:13 <lambdabot> Applicative
09:51:17 <Twey> Bah
09:51:38 <temoto> quicksilver: thank you.
09:52:06 <taruti> Using a "TVar Int" has too much contention and while "TChan ()"  may be better it seems like a suboptimal solution...
09:52:13 <CESSMASTER> what happened to the haskell platform?
09:52:23 <Twey> Transitioning…
09:53:02 <pikhq> CESSMASTER: ... It exists?
09:53:09 <pikhq> It still does?
09:53:34 <CESSMASTER> a 404 exists at its URL
09:53:49 <taruti> Having an "increment :: TCounter -> STM ()" would not need to rollback other transactions doing "increment"
09:54:56 <jmcarthur> hmm, from the spec for MonadOr, it looks like \a -> mzero /= return a
09:55:07 <Polarina> jmcarthur: Could you explain the type of (***) to me? I do not see the pattern between your example and its type. :(
09:55:48 <Twey> jmcarthur: Isn't that already the case?
09:55:53 <nolrai_FG> @type (***)
09:55:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:56:03 <Twey> It's easier with an infix Arrow type
09:56:35 <temoto> map doesn't specify the order in which the list would be processed, right?
09:56:50 <jmcarthur> Twey: it means that you can't define MonadOr for e.g. a Void type. i just find that interesting, i guess
09:56:54 <solidsnack> temoto: Well, no.
09:56:54 <temoto> @src map
09:56:54 <lambdabot> map _ []     = []
09:56:55 <lambdabot> map f (x:xs) = f x : map f xs
09:56:58 <Polarina> temoto: It's only logical that it goes left to right.
09:56:59 <Twey> Polarina: Arrow (~>) => (a ~> b) -> (a' ~> b') -> ((a, a') ~> (c, c'))
09:57:07 <jmcarthur> VoidM, i guess
09:57:10 <Polarina> Twey: What's an arrow?
09:57:12 <jmcarthur> the trivial monad?
09:57:29 <solidsnack> temoto: The implementation does but there's no dependence on the ordering.
09:57:31 <Twey> Polarina: An arrow is a generalisation of some sort of transformation on a datum
09:57:31 <jmcarthur> actually i guess you can
09:57:38 <Polarina> Twey: Erm...
09:57:44 <Twey> The simplest Arrow is just (->), functions
09:57:44 <temoto> Intersting :)
09:57:46 <jmcarthur> the rules applies to everything *but* the trivial monad
09:57:54 <Twey> (and that's all you'll encounter 90% of the time)
09:58:24 <jmcarthur> which is not Void, now that i get the stupid out of my head
09:58:42 * Polarina doesn't understand arrows. :(
09:58:55 <Twey> jmcarthur: *headscratch*
09:58:56 <pikhq> Polarina: Do you understand functions?
09:58:58 <leimy> no one does :-)
09:59:01 <leimy> arrow are really hard.
09:59:02 <Polarina> pikhq: Yes
09:59:18 <pikhq> Generalise that.
09:59:27 <jmcarthur> arrows aren't that hard themselves, but Control.Arrow is not designed very well IMO
09:59:32 <Polarina> pikhq: What's generalise?
09:59:48 <leimy> jmcarthur: I can't figure out where I really truly need arrows.
10:00:10 <mux> I find it weird that arrows include the notion of splitting
10:00:27 * Polarina doesn't understand Monads. :(
10:00:30 <mux> I would have had that in another typeclass, I think
10:00:44 * dansa sides with Polarina
10:00:58 <CESSMASTER> what's the current wisdom about GHC on Snow Leopard?
10:01:21 <leimy> I'm running it
10:01:23 <leimy> 6.12 that is
10:01:33 <leimy> but you end up building cabal-install your self.
10:01:35 <pikhq> Polarina: ... I'll let you go through a few more enlightening experiences, mmkay?
10:01:44 <Polarina> pikhq: Please do. :)
10:01:45 <CESSMASTER> leimy: the .pkg on the ghc website works?
10:01:51 <leimy> CESSMASTER: yes
10:01:52 <ElfArmy> The problem with Monads is that they need a certain level of symbolic proceds
10:01:53 <leimy> I'm using it right now.
10:01:55 <ElfArmy> processing rather
10:02:16 <ElfArmy> A lot of people try to understand what it is in real terms, and there's not a lot of good material about what it looks like in real terms
10:02:29 <jmcarthur> "real terms"?
10:02:33 <CESSMASTER> leimy: ah, thank you. it said "for 10.5" and I was afraid of downloading 100mb on this slow connection and then having the package refuse to install
10:02:47 <leimy> It's working fine on Snow Leopard.
10:02:53 <jmcarthur> i think the problem is that people expect monads to *do* something. they don't do anything
10:03:03 <leimy> I didn't even have to hack around with the shell scripts like I did on 6.10 :-)
10:03:13 <ElfArmy> A monad is pretty abstract, it's fairly easy to say what it does. But what it is and what it looks like is more complicated.
10:03:31 <jmcarthur> just because we use monads to sequence our IO doesn't mean it does anything
10:03:32 <leimy> I think of a Monad as a context around a value or values.
10:03:48 <jmcarthur> i think of Monad as an interface with some laws
10:03:58 <ElfArmy> Okay, what it is used for rather.
10:04:01 <leimy> it's both right? :-)
10:04:01 <Polarina> I don't know anything about Moands, everyone's lazy, not writing anything about them. :'(
10:04:11 <pikhq> I think of Monad as just meaning that >>= and return have meaning.
10:04:14 <temoto> lol
10:04:23 <leimy> pikhq: even better :-)
10:04:32 <temoto> Polarina: do we have a troll here? :)
10:04:34 <Twey> I think of Monad as just meaning that ‘join’ has meaning
10:04:39 <jmcarthur> it's a monoid on the category of endofunctors
10:04:44 <pikhq> Twey: You still need return.
10:04:55 <Polarina> temoto: No, I truly don't know anything about them, but I really would like to.
10:04:57 <jmcarthur> i actually find that description helpful, but that's only through experience, honestly
10:05:05 <aavogt> Twey: and fmap
10:05:14 <Twey> Sure, but those are provided by Pointed and Functor, respectively.  ;)
10:05:25 <temoto> Polarina: but "everyone not writing anything about them" is a troll :)
10:05:30 <aavogt> well, that's three things to know
10:05:39 <Twey> aavogt: But not about Monads :þ
10:05:41 <Polarina> temoto: :(
10:05:46 <temoto> Polarina: because web largely consists of porn and monad tutorials.
10:05:54 * Twey laughs.
10:06:12 <aavogt> well just return and bind are sufficient, no?
10:06:22 <Polarina> I've seen no monad tutorials in human-english.
10:06:25 <Twey> aavogt: Sure, but ‘return’ is just another name for pure anyway
10:06:36 <rovar> arg.. i thougth that was it.. turns out I don't use getLazyByteString.. and I changed the socket operations to ByteString from ByteString.Lazy and it still blocks
10:06:44 <aavogt> what I'm saying is that bind does more than join
10:06:50 <jmcarthur> Polarina: i think the easiest way to learn monads is to not learn monads
10:06:52 <Twey> Which is why it shouldn't be the core method
10:07:00 <Polarina> jmcarthur: Erm?
10:07:19 <jmcarthur> Polarina: if you just use haskell then you will eventually catch on to monads
10:07:29 <Polarina> I am not following you.
10:07:36 <jmcarthur> Polarina: just by using various types that expose monadic APIs
10:07:53 <jmcarthur> just don't try too hard. that's all
10:07:54 <Polarina> The only thing I know is IO(), because learnyouahaskell explained them.
10:08:05 <Polarina> But that book is abandoned and not updated anymore. :(
10:08:10 <jmcarthur> it's not abandoned
10:08:18 <Polarina> Hasn't been updated for years.
10:08:18 <Vanadium> Polarina: BONUS_ here is writing lyah
10:08:20 <jmcarthur> BONUS: you haven't abandoned LYAH, have you?
10:08:27 <jmcarthur> Polarina: it's not even years old...
10:08:39 <leimy> Monads are really easy
10:08:41 <ddarius> Are you thinking YAHT?
10:08:50 <_andy_> @src mconcat
10:08:50 <lambdabot> Source not found. Wrong!  You cheating scum!
10:09:02 <leimy> in fact people've been using them for a while without noticing I suspect.
10:09:04 <aavogt> but YAHT sees some updates as a wikibook?
10:09:04 <_andy_> >import Data.Monoid
10:09:12 <_andy_> @src mconcat
10:09:12 <lambdabot> Source not found. Just try something else.
10:09:19 <_andy_> @src concat
10:09:20 <aavogt> @src [] mconcat
10:09:20 <lambdabot> concat = foldr (++) []
10:09:20 <lambdabot> Source not found. Just try something else.
10:09:21 <ddarius> mconcat is a method
10:09:34 <aavogt> @src [] mappend
10:09:34 <lambdabot> Source not found. Maybe you made a typo?
10:09:36 <_andy_> then has a default definition
10:09:39 <_andy_> *that
10:09:51 <leimy> I think a lot of what makes monads seem magical is the "do" syntactic sugar in Haskell
10:10:04 <leimy> and I think that really causes a bunch of confusion.
10:10:11 <Twey> Probably
10:10:17 <nolrai_FG> leimy: that is quite posible.
10:10:18 <leimy> It's meant to help people, but it's a crutch that prevents one from learning what's really going on.
10:10:18 <Twey> We shouldn't introduce it until later.  ;)
10:10:26 <leimy> Yeah.
10:10:37 <nolrai_FG> looks nicer though.
10:10:38 <leimy> I think you should appreciate what do gives you before you use do.
10:10:45 <leimy> then monads will likely be easier to grasp.
10:10:51 <aavogt> but you don't need to know what's going on to do useful things
10:10:57 <leimy> no you sure don't
10:11:00 <ddarius> It gives you almost nothing unless you are using refutable patterns.
10:11:08 <leimy> you can write useful programs with do, and not know what you're doing.
10:11:17 <leimy> I mean damn.  I don't really know how my car works, but I drive it anyway.
10:11:18 <jmcarthur> nolrai_FG: i don't even think it looks nicer most of the time
10:12:01 <jmcarthur> it just looks imperative, which for a lot of people is more *familiar*
10:12:13 <jmcarthur> but deceptively familiar, since monads aren't necessarily imperative at all
10:12:21 <aavogt> it helps you to avoid parentheses
10:12:28 <ddarius> aavogt: Nope.
10:12:31 <jmcarthur> eh
10:12:44 <Cale> I don't think that understanding monads is important to understanding most examples of monads.
10:12:46 <Twey> It helps me avoid lambdas.
10:12:46 <jmcarthur> i've never saved parens by switching to do notation
10:13:13 <aavogt> @undo do x <- g $ h y; x z
10:13:14 <lambdabot> g $ h y >>= \ x -> x z
10:13:20 <jmcarthur> it just replaces backslashes with new lines
10:13:25 <Twey> If it doesn't help me avoid lambdas, I don't do it.
10:13:36 <aavogt> that desugaring isn't right?
10:13:41 <Twey> jmcarthur: Sounds good to me
10:13:43 <ddarius> aavogt: No, it isn't.
10:13:51 <aavogt> @undo do x <- (g $ h y); x z
10:13:52 <lambdabot> (g $ h y) >>= \ x -> x z
10:13:53 <leimy> Can't you avoid lambdas with "let" ? :-)
10:14:02 <ddarius> where
10:14:19 <Twey> leimy: That's only slightly better :þ
10:14:24 <leimy> heh
10:14:26 <Polarina> In all my haskell coding, I've never encountered anything that can be done with let but not where.
10:14:35 <Twey> Polarina: Variables in guards.
10:14:37 <aavogt> jmcarthur: ^^  you've never seen stuff like that?
10:14:44 <Twey> That's basically the whole point of where.
10:14:44 <ddarius> Polarina: let and where are not even in the same syntactic class.
10:14:45 <Polarina> Twey: Huh?
10:15:07 <Twey> Polarina: f x | y > 0 = ... where y = x + 2
10:15:09 <jmcarthur> aavogt: i count the ($) as a paren
10:15:11 <leimy> > let z x y =  x + y in z 3 5
10:15:12 <lambdabot>   8
10:15:12 <Polarina> ddarius: let is prefixed, where is postfixed. That's the only difference I see.
10:15:29 <ddarius> Polarina: let is an expression, where is part of the syntax of function declaration.
10:15:43 <Twey> It's Magic Let for Guards.
10:15:55 <aavogt> jmcarthur: well it's not ;)
10:16:03 <quicksilver> ddarius: s/function declaration/value definition/
10:16:19 * Polarina still doesn't get the difference.
10:16:28 <Twey> 18:14:44 < Twey> Polarina: f x | y > 0 = ... where y = x + 2
10:16:34 <Twey> You can do this with where.
10:16:37 <Twey> You can't do this with let.
10:16:43 <aavogt> you can do it with let:
10:16:47 <Polarina> Twey: What can't I do with a let?
10:16:49 <Twey> (although you can if you desugar the guards to a case)
10:16:54 <ddarius> Polarina: Expressions have a value, declarations do not.
10:17:01 <aavogt> f x = case x + 2 of y | ... -> ...
10:17:08 <leimy> > let let x y =  x + y in let 3 2
10:17:08 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:17:10 <aavogt> whoops, there's no let there
10:17:11 <leimy> doh!
10:17:23 <jmcarthur> ($ z) <=< g . h $ y  -- looks fine to me
10:17:24 <Twey> Polarina: Insert it between a function and a guard
10:17:25 <aavogt> f x = let y = x + 2 in case () of _ | ... -> ...
10:17:38 <Polarina> Twey: What do you mean with "in between"?
10:17:39 <ddarius> I can pass an expression to a function.  Passing a declaration (let alone part of one) to a function isn't even sensical.
10:17:47 <quicksilver> ddarius: or better, 'equation'
10:18:01 <Twey> Polarina: Use the argument to a function in a guard for that same function.
10:18:46 * Polarina still doesn't see a difference and continues ignoring let forever.
10:19:04 <quicksilver> Polarina: "x+y" is an expression. "let x = 2 in x+y" is an expression.
10:19:07 <ddarius> Polarina: You can't write: f (x where x = 3), you can write: f (let x = 3 in x)
10:19:10 <dsouza> howdy folks
10:19:13 <quicksilver> Polarina: "x+y where x= 2" is nonsense.
10:19:22 <quicksilver> Polarina: (not valid haskell)
10:19:24 <dsouza> is hackage.haskell.org/platform down?
10:19:38 <Polarina> Oh, ok. Thanks.
10:19:47 <Twey> @let f x = x + y where y = 3
10:19:48 <lambdabot>  Defined.
10:19:57 <Twey> (because you all did it to me :þ)
10:20:07 <leimy> >f 3
10:20:07 <Twey> dsouza: Yes
10:20:15 <Twey> Hackage is down.  Again.
10:20:19 <taruti> Is there a more sensible way of doing STM counters than http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15943 ?
10:20:20 <leimy> >f 3
10:20:21 <dsouza> ouch!
10:20:24 <Twey> > f 3
10:20:25 <lambdabot>   Ambiguous occurrence `f'
10:20:25 <lambdabot>  It could refer to either `L.f', defined at <local...
10:20:32 <Twey> > L.f 3
10:20:34 <lambdabot>   6
10:20:35 <quicksilver> Parsers traditionally parse streams of tokens.
10:20:38 <dsouza> is there other sources to download platform?
10:20:51 <quicksilver> If you have somethng "like a parser" which acts on something more like a tree or an ADT, what do you call that?
10:20:53 <leimy> this isn't erlang
10:20:57 <leimy> we're not distribtued yet.
10:20:58 <Eduard_Munteanu> Hi
10:21:02 <ddarius> quicksilver: A tree parser.
10:21:15 <Berengal> quicksilver: A processor?
10:21:20 * quicksilver nods
10:21:21 <quicksilver> thanks
10:21:22 <leimy> an interpreter?
10:21:23 <jmcarthur> aavogt: if y was an argument to the function and i have (applyTo = flip ($)) defined (which i do sometimes) then i can just say (applyTo z <=< g . h) for your example. no parens or anything
10:21:35 <quicksilver> I want something 'like a parser' which acts by pattern matching on a deep (recursive) ADT
10:21:55 <leimy> :t flip ($)
10:21:55 <ddarius> http://www.antlr2.org/doc/sor.html
10:21:55 <quicksilver> where what I mean by 'like a parser' is I can build it up out of combinators and if it fails, it fails.
10:21:55 <lambdabot> forall a b. a -> (a -> b) -> b
10:22:00 <leimy> :t ($)
10:22:01 <lambdabot> forall a b. (a -> b) -> a -> b
10:22:06 <Berengal> quicksilver: I used parsec to do something like that once...
10:22:11 <aavogt> jmcarthur: ($ z) looks better though
10:22:18 <Berengal> quicksilver: Though ArrowList might be a better choice
10:22:20 <leimy> :t (.)
10:22:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:22:24 <leimy> :t flip (.)
10:22:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
10:22:26 <jmcarthur> aavogt: then we aren't saving parens either way ;)
10:22:33 <Eduard_Munteanu> Can somebody explain to me the difference between recursion and corecursion (perhaps data and codata)? After reading the Wikipedia article I can't say there's much of a difference.
10:22:38 <jmcarthur> i like either depending on my mood
10:22:48 <quicksilver> Berengal: really? Paressec doesn't assume it acts on a stream of tokens?
10:22:54 <ddarius> Eduard_Munteanu: In Haskell, there is no difference.
10:23:04 <aavogt> I think that parens are more expensive the farther apart you put the matching ones
10:23:08 <jmcarthur> ($ z) <=< g . h  -- does indeed look nice
10:23:10 <Berengal> Eduard_Munteanu: recursion has a base case and an inductive case. Corecursion has the final case and subcases
10:23:12 <aavogt> expensive for the reader
10:23:27 <jmcarthur> very much agreed
10:23:37 <Eduard_Munteanu> Berengal, I don't really understand that.
10:23:54 <Eduard_Munteanu> ddarius, hm, but it seems it's the same even in C.
10:24:04 <Berengal> quicksilver: It does. I explicitly pushed back deeper levels onto the token stream
10:24:08 <ddarius> Eduard_Munteanu: It's the same in every Turing-complete language.
10:24:15 <Berengal> quicksilver: It wasn't very pretty, and I didn't really know what I was doing.
10:24:16 <Eduard_Munteanu> ddarius, oh
10:24:28 <Eduard_Munteanu> ddarius, so you mean they're different in total languages?
10:24:31 <quicksilver> aavogt: which is why mathematical typesetting uses bigger parens for the further-apart ones, to help the eyes.
10:24:33 <ddarius> Eduard_Munteanu: Yes.
10:24:37 <Berengal> Eduard_Munteanu: consider this: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
10:24:41 <Eduard_Munteanu> ddarius, oh, that clears it up.
10:24:46 <quicksilver> aavogt: but obviously we don't have that trick available normally when programming.
10:24:46 <Eduard_Munteanu> Berengal, yes.
10:25:16 <Eduard_Munteanu> Berengal, they say it's equivalent to: fibs' x y = x : fibs' y (x+y)
10:25:16 <Eduard_Munteanu> fibs' x y = x : fibs' y (x+y)
10:25:21 <quicksilver> Berengal: OK. I probably won't do it that way then :)
10:25:22 <dansa> @src zipWith
10:25:23 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
10:25:23 <lambdabot> zipWith _ _      _      = []
10:25:24 <Berengal> Eduard_Munteanu: This is a corecursive value. the final value is 0 : 1 : zipWith (+) fibs (tail fibs), the corecursive subvalue is zipWith (+) fibs (tail fibs)
10:25:48 <quicksilver> Berengal: I think I'll probably just use a nest of related functions with 'error'; this whole thing is only a hack anyway.
10:26:03 <Berengal> quicksilver: Mathematics also uses 1.7-dimentional syntax
10:26:21 <quicksilver> Berengal: 1.7? How can we be sure it's not 1.6 or 1.8? ;)
10:26:32 <quicksilver> but I believe I know what you mean.
10:26:48 <dansa> which idiom would you guys use to swap first<->last of a list?
10:26:52 <Berengal> quicksilver: I still think you could get something nice out of ArrowList if you bothered to look. Learning an idiom like that would probably be handy
10:26:59 <ddarius> dansa: I wouldn't do that.
10:27:01 <Eduard_Munteanu> Berengal, so a recursive definition would be f(n > 3) = f(n-1) + f(n-2) ?
10:27:06 <dansa> ddarius: what would you do?
10:27:08 <jmcarthur> dansa: what do you need to do that for?
10:27:15 <dansa> to really swap it :)
10:27:21 <Berengal> Eduard_Munteanu: Yes, or at least the inductive case.
10:27:21 <jmcarthur> dansa: but why?
10:27:22 <dansa> that's really what i want; i'm playing
10:27:33 <jmcarthur> eh...
10:27:39 <dansa> sometimes i ask things like... how would i do that? then i realize it isn't too pretty
10:27:44 <dansa> so i wonder what people do
10:27:57 <dansa> is that a `because' satisfactory enough? :)
10:27:57 <Eduard_Munteanu> Berengal, hm, there doesn't seem to be much of a difference, I'll probably think like ddarius does, i.e. that there's no fundamental diff in a non-total language.
10:28:14 <Eduard_Munteanu> Berengal, ddarius, thanks.
10:28:16 <dsouza> do anyone has haskell platform for windows that could share with me? :-)
10:28:19 <jmcarthur> i would use a sequence instead of a list or something :P
10:28:20 <ToRA> > (liftM2 (:) last init) "hello world"
10:28:21 <lambdabot>   "dhello worl"
10:28:32 <quicksilver> dansa: let (a,b,c) = (head x, init(tail x), last(tail x)) in c:b++[a]
10:28:34 <dsouza> as the site is currently down
10:28:49 <Berengal> Eduard_Munteanu: Recursion: Split the problem into smaller problems, assume you can solve those and return the solution. Solve the "smallest" problems (base cases). Corecursion: Assume you have the final value and use that to describe part of the final value. Describe something that doesn't depend on the final value at all, but is still part of it.
10:28:59 <Raymond> I need experience with haskel
10:29:01 <dansa> quicksilver: i see :)
10:29:06 <ToRA> oop, missed a case
10:29:07 <Raymond> Where should i go from there?
10:29:18 <Eduard_Munteanu> Berengal, oh, that makes sense, nice.
10:29:29 <jmcarthur> Raymond: write some code?
10:29:39 <Raymond> Thats the plan
10:29:44 <Raymond> without any background
10:30:16 <quicksilver> Berengal: my phone company is playing silly buggers with its proxy server. ArrowList is a -> [b] or something else?
10:30:34 <ddarius> Eduard_Munteanu: Folds are a significant class of recursions, unfolds are a significant class of corecursions.
10:30:44 <Berengal> quicksilver: From memory, yes. Let me check
10:31:03 <quicksilver> Berengal: then, yes, I could use that. Or a -> Maybe b. Or a -> Either Failure b
10:31:23 <Eduard_Munteanu> ddarius, yeah, I understand that in terms of ana/catamorphisms, but I couldn't get past the fact that the two look very very equivalent. :)
10:31:37 <quicksilver> Berengal: (which are all arrows, of course)
10:31:40 <Berengal> quicksilver: The neat thing is that you get recursion almost for free, both over lists and over trees
10:31:55 <ddarius> Eduard_Munteanu: unfoldr looks rather different to foldr
10:32:14 <Eduard_Munteanu> ddarius, no, I mean the fibonacci example.
10:32:15 <ddarius> quicksilver: All Kleisli arrows no less.
10:32:29 <quicksilver> Berengal: how would that give recursion over trees for free?
10:32:48 <Cale> > fix ((1:) . (2:) . drop 2 . concat . flip (zipWith replicate) [1..])
10:32:50 <lambdabot>   [1,2,2,3,3,4,4,4,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,9,10,10,10,10,10,11,...
10:32:52 <Berengal> quicksilver: Not entirely for tree, but with a simple getChildren :: Tree a -> [Tree a]
10:33:09 <Cale> nth term is the number of times that n occurs
10:33:41 <Berengal> quicksilver: And then there's the filtering, and creation of new trees at arbitrary points in the tree.
10:33:47 <quicksilver> Berengal: my Tree isn't really a tree, though. It's a heterogenous ADT
10:33:56 <quicksilver> Berengal: I just meant tree in a weak sense
10:34:02 <quicksilver> it's tree-shaped, ish.
10:34:09 <dsouza> mmm... no one?
10:34:09 <jmcarthur> > concatMap (join replicate) [1..]
10:34:11 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
10:34:19 <quicksilver> it's actually a haskell representation of some semi-structured data.
10:34:26 <ddarius> jmcarthur: That's very different.
10:34:50 <jmcarthur> oh!
10:35:03 <Cale> > let phi :: CReal; phi = (1 + sqrt 5) / 2 in [round (phi ** (2-phi) * n ** (phi-1)) | n <- [1..]]
10:35:09 <lambdabot>   mueval-core: Time limit exceeded
10:35:10 <ddarius> quicksilver: Perhaps it might be beneficial to use a more generic underlying representation with a phantom type (or some such) to impose structure over the generic representation.
10:35:16 <aavogt> > map length . group $ fix ((1:) . (2:) . drop 2 . concat . flip (zipWith replicate) [1..])
10:35:17 <lambdabot>   [1,2,2,3,3,4,4,4,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,9,10,10,10,10,10,11,...
10:35:18 <Eduard_Munteanu> What is the Kleisli arrow anyway? return . id ?
10:35:19 <jmcarthur> i was like "what? that can be done much more simply!" and now i'm like "stupid, pay attention"
10:35:38 <Berengal> quicksilver: it might not be as clean, but you can still do the ArrowList thing with selectors of type a -> [b] (instead of just a -> b)
10:35:39 <jmcarthur> Eduard_Munteanu: it's an arrow made out of a monad
10:35:59 <Eduard_Munteanu> jmcarthur, so the application of the monad functor itself, right?
10:36:06 <ksf> these days, arrows are usually made out of glass fibres.
10:36:14 <Eduard_Munteanu> ksf, :)
10:36:16 <ksf> you obviously have no idea what you're talking about.
10:36:19 <aavogt> it's the same sequence
10:36:29 <Twey> @src Kleisli arr
10:36:30 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:36:33 <jmcarthur> Eduard_Munteanu: i have no idea what you're talking about
10:36:35 <Twey> Hmph
10:36:37 <Berengal> quicksilver: If there's something sequence-like anywhere in your structures, this is pretty handy.
10:36:38 <Cale> aavogt: oh?
10:36:49 <Cale> @let golomb = fix ((1:) . (2:) . drop 2 . concat . flip (zipWith replicate) [1..])
10:36:50 <lambdabot>  Defined.
10:37:02 <Eduard_Munteanu> jmcarthur, the monad is defined as a functor. Now I don't know much about arrows, only about monads.
10:37:03 <shapr> Cupid's Kleisli arrow... fall in love with Haskell on Valentine's Day!
10:37:05 <Cale> > (map length . group $ golomb) == golomb
10:37:15 <lambdabot>   mueval: ExitFailure 1
10:37:21 <Eduard_Munteanu> ksf, I concur, I don't know about arrows.
10:37:25 <Cale> ExitFailure 1?
10:37:35 <Eduard_Munteanu> But they seem somewhat important in the definition/use of monads.
10:37:41 <aavogt> > length [1..]
10:37:45 <lambdabot>   mueval-core: Time limit exceeded
10:37:46 <Cale> ah, just a timeout
10:37:48 <jmcarthur> Eduard_Munteanu: being a functor is necessary but insufficient to be a monad
10:37:52 <Cale> > (map length . group $ golomb) == golomb
10:37:55 <Eduard_Munteanu> jmcarthur, yes, I know.
10:37:57 <lambdabot>   mueval: ExitFailure 1
10:38:02 <ddarius> Cale: Derive the definition of golomb from that specification.
10:38:09 <Eduard_Munteanu> jmcarthur, I just want to translate a -> m a into mathematical terms.
10:38:10 <aavogt> @let inf = [1..]
10:38:14 <lambdabot>  Defined.
10:38:18 <aavogt> > length inf
10:38:19 <quicksilver> data Value = Simple Int | Array [Value] | Dict (Data.Map Value Value)
10:38:22 <lambdabot>   mueval-core: Time limit exceeded
10:38:24 <ddarius> Cale: If that equation holds, then there isn't going to be a result...
10:38:32 <Cale> ddarius: I know.
10:38:33 <quicksilver> Berengal, ddarius : something like that.
10:38:40 <Cale> ddarius: I was hoping for Time limit exceeded
10:38:53 <Cale> ddarius: I wonder why the error is different.
10:39:08 <jmcarthur> Eduard_Munteanu: it can mean many things in mathematical terms
10:39:13 <Berengal> quicksilver: Have you used HXT?
10:39:36 <ddarius> quicksilver: If you take Berengal's approach, you can easily write two "getChildren" functions for the array case and for the dict case.
10:39:39 <aavogt> @check \ns -> (==ns) $ map length $ group $ zipWith replicate ns [1..]
10:39:40 <lambdabot>   "Falsifiable, after 1 tests:\n[-1]\n"
10:39:43 <ollie> good evening, anybody who might be able to help me to figure out how to write a (//) function for an Array of Arrays ?
10:39:52 <_andy_> i may have missed this one completely, but is there anything like:
10:39:56 <quicksilver> Berengal: no, but I've used HaXml which uses pretty much the same idea.
10:40:08 <quicksilver> (just without actually making them instances of array)
10:40:08 <aavogt> @check \ns' -> let ns = map (succ . abs) ns' in (==ns) $ map length $ group $ zipWith replicate ns [1..]
10:40:09 <lambdabot>   "Falsifiable, after 0 tests:\n[-2,2]\n"
10:40:17 <Eduard_Munteanu> jmcarthur, how would you formally put what an identity function a -> m a does? I think that's what a Kleisli arrow was in Haskell, or somebody around here said so.
10:40:25 <_andy_> eh nevermind
10:40:33 <ksf> :t (//)
10:40:34 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
10:40:40 <aavogt> @check \ns' -> let ns = map (succ . abs) ns' in (==ns) $ map length $ group $ concat $ zipWith replicate ns [1..]
10:40:40 <Berengal> quicksilver: By array you mean arrow, I presume :)
10:40:42 <lambdabot>   "OK, passed 500 tests."
10:40:47 <quicksilver> Berengal: yes ;)
10:40:58 <jmcarthur> Eduard_Munteanu: that is indeed id on Kleisli
10:41:13 <jmcarthur> Eduard_Munteanu: it's also return on Monad, and pure on Applicative
10:41:32 <ksf> ollie, what do you mean with "array of arrays"?
10:41:37 <ksf> a two-dimensional one?
10:41:45 <ollie> ksf yes
10:41:45 <jmcarthur> Eduard_Munteanu: but put formally... it depends what you want out of it
10:41:48 <quicksilver> Eduard_Munteanu: it's the identity morphism of an object in the kleisli category for the monad m
10:41:49 <Cale> Seems harder to derive a least fixed point representation of it from map length . group, even though it ought to be a fixed point of that.
10:41:55 <ksf> that's usually done by using (Int,Int) as index type
10:42:04 <jmcarthur> Eduard_Munteanu: quicksilver is doing better than i ;)
10:42:09 <Eduard_Munteanu> jmcarthur, let's start from basics... is there anything named Kleisli arrow as something unique?
10:42:20 <jmcarthur> i don't understand the question
10:42:20 <ddarius> Eduard_Munteanu: No.
10:42:27 <Eduard_Munteanu> I see.
10:42:31 <ksf> ...the plumbing in the background then takes care of calculating one-dimensional indices from that and the array's dimensions.
10:42:42 <quicksilver> ddarius: I want to go through the tree 'asserting' "I expect the literal string foo here" and "I expect an array here, and want to return the value of that"
10:42:43 <Eduard_Munteanu> So there is a class of objects (not in a math sense) named Kleisli arrow_s_.
10:42:52 <ddarius> Eduard_Munteanu: Every monad gives rise to a Kleisli category.  Every arrow in a Kleisli category could be called a "Kleisli arrow"
10:42:59 <quicksilver> ddarius: I see that I can use [] to represent failure.
10:43:05 <ollie> i have an index using (Char,Int), but I cant figure out how to iterate over each array replacing the values
10:43:06 <Eduard_Munteanu> ddarius, thanks.
10:43:49 <quicksilver> "literal_string s = \v -> case v of String s -> [()]; _ -> []"
10:43:52 <ddarius> Eduard_Munteanu: However, there is also a notion in Haskell called "Arrow".  There is a type constructor "Kleisli" which witnesses the fact that every monad gives rise to an Arrow.
10:43:58 <quicksilver> ddarius, Berengal: is that what you mean?
10:44:11 <ddarius> Eduard_Munteanu: Arrows arrived at in that way are called Kleisli arrows.
10:44:19 <Berengal> quicksilver: Yes, [] is failure
10:44:24 <Eduard_Munteanu> ddarius, nah, I remember skimming over some papers some time ago and remembering "the Kleisli arrow".
10:44:39 <Eduard_Munteanu> I thought it was something in particular
10:45:05 <ksf> ollie, to map over the elements, use fmap
10:45:28 <Berengal> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15944#a15944 <- has a somewhat big-ass file that uses arrows to parse a tree. In this case, the tree is a HTML tree. It should be relatively structured...
10:45:46 <ollie> :t fmap
10:45:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:45:57 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98-1.0.1.1/Array.html#t%3AArray
10:46:12 <ksf> ...note that (Array i) has a Functor instance.
10:46:21 <quicksilver> Berengal: thanks. I think I get the idea now. This is much like what I did with HaXml many moons ago.
10:46:42 <quicksilver> Berengal: it feels like this technique should have a name?
10:46:44 <Eduard_Munteanu> How would you call "lifting" a value into a monad? As in making something IO (String), or Just Int etc.
10:46:49 <Cale> Eduard_Munteanu: Let's be a little more formal. Given a category C and a monad M, the Kleisli category C_M is the category whose objects are the objects of C, and where each arrow A ~> B in C_M is an arrow A -> M B in C. Identities are given by the unit of the monad, and composition of arrows f: A -> M B, and g: B -> M C to give g * f: A -> M C is accomplished by first lifting g using the monad to get Mg, composing to
10:46:49 <Cale>  get an arrow A -> M (M C), and then composing that with the component mu_C to get A -> M C
10:46:56 <Berengal> quicksilver: arrow-processing?
10:47:05 <kmc_> Eduard_Munteanu, you mean "return"?
10:47:10 <ksf> :t fmap :: (Int -> String) -> Array Int Int -> Array Int String
10:47:11 <lambdabot> (Int -> String) -> Array Int Int -> Array Int String
10:47:17 <Ke> @hoogle LocalTime -> LocalTime ->
10:47:18 <lambdabot> Parse error:
10:47:18 <lambdabot>   --count=20 "LocalTime -> LocalTime ->"
10:47:18 <lambdabot>                                       ^
10:47:21 <Ke> @hoogle LocalTime -> LocalTime -> a
10:47:22 <Eduard_Munteanu> kmc_, yes, but in a mathematical sense. Is there any name to that operation?
10:47:23 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:47:23 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
10:47:23 <lambdabot> Prelude seq :: a -> b -> b
10:47:30 <Berengal> quicksilver: It feels very versatile, but I still haven't internalized arrows enough to make full use of them. I sometimes feel like I've painted myself into a corner with them
10:47:47 <kmc_> Eduard_Munteanu, it's one of the two natural transformations associated with a monad
10:47:56 <Eduard_Munteanu> kmc_, so applying the unit?
10:48:00 <kmc_> yes
10:48:02 <kmc_> i guess
10:48:07 <Eduard_Munteanu> kmc_, I see, thanks,.
10:48:10 <Cale> Eduard_Munteanu: return corresponds to the unit of the monad, usually written eta
10:48:11 <jmcarthur> Eduard_Munteanu: return, pure, point, inject, unit, there are lots of names
10:48:13 <Cale> η
10:48:18 <kmc_> the other is F (F a) -> F a
10:48:22 <kmc_> which is called "join" in Haskell
10:48:31 <Ke> @hoogle LocalTime -> LocalTime
10:48:31 <lambdabot> Prelude id :: a -> a
10:48:32 <lambdabot> Data.Function id :: a -> a
10:48:32 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
10:48:33 <Cale> join corresponds to the multiplication of the monad, usually written mu (μ)
10:48:33 <quicksilver> Berengal: it doesn't really feel to me like it uses the properties of arrows
10:48:33 <Eduard_Munteanu> coduplicate :)
10:48:41 <quicksilver> Berengal: it mostly just feels like it uses the properties of lists.
10:48:44 <mmaruseacph2> i have a function f::a->a which must be iterated over a start value until a certain condition is met but i cannot use until since i need the list of all values obtained in the iteration
10:48:44 <quicksilver> Berengal: (and functions)
10:48:48 <mmaruseacph2> is there something for this?
10:48:53 <kmc_> mmaruseacph2, "iterate"?
10:48:56 <ollie> ksf alright, i see where you are going, im gonna see if i can solve the puzzle with that
10:48:58 <kmc_> > iterate ('x':) []
10:48:59 <lambdabot>   ["","x","xx","xxx","xxxx","xxxxx","xxxxxx","xxxxxxx","xxxxxxxx","xxxxxxxxx"...
10:49:04 <Cale> mmaruseacph2: iterate and takeWhile
10:49:14 <mmaruseacph2> (a->Bool)->(a->a)->a->[a]
10:49:20 <ollie> since im not used to functional programming its both a difficult but challenging task =]
10:49:21 <Cale> Though maybe you really want takeUntil, which is sadly missing
10:49:22 <mmaruseacph2> ah, so there's no single function
10:49:23 <mmaruseacph2> ok
10:49:24 <Raymond> Whats the first step in becoming a programmer?
10:49:31 <mmaruseacph2> takeUntil i wanted
10:49:35 <temoto> Raymond: divorse
10:49:52 <Raymond> What if I'm not in a marriage?
10:49:58 <Cale> Raymond: Learning a programming language.
10:49:58 <Berengal> quicksilver: Indeed, but the arrow framework does make it a bit easier to work with. Mainly it's the fact that arrows have kind * -> * ->, and they have a compose function, that makes it good
10:50:00 <jmcarthur> head . dropUntil foo . iterate f
10:50:01 <temoto> Raymond: you will take it as a first or some middle step.
10:50:05 <jmcarthur> err
10:50:06 <jmcarthur> dropWhile
10:50:47 <Raymond> what programs do you use to write these codes?
10:51:00 <temoto> Raymond: vim
10:51:08 <Berengal> quicksilver: But really, there's not much more to arrows than that... Well, there's not much more to Categories than that...
10:51:13 <mmaruseacph2> i solved it with until and a test comparing only the head
10:51:22 <mmaruseacph2> thanks
10:51:34 <Raymond> and is VIM free to the community?
10:51:48 <aavogt> vim isn't easy at first
10:51:48 <leimy> as in beer?
10:51:50 <mmaruseacph2> Raymond, yes, it is:P
10:51:50 <temoto> Raymond: yes, it's an open source text editor.
10:52:09 <Berengal> Raymond: Which OS are you using?
10:52:12 <kmc_> Raymond, you can write source code in any text editor.  Some of them are specialized for editing code
10:52:13 <temoto> Yes, vim is not easy to learn.
10:52:22 <Raymond> are you guys very professional in this field?
10:52:26 <Raymond> I'm on windows classic
10:52:30 <leimy> vim is based on vi, and is short for "very irritating"
10:52:30 <mmaruseacph2> vim?
10:52:31 * Berengal is a professional
10:52:33 <temoto> classic as in 95?
10:52:38 <burp> lol
10:52:42 <kmc_> of course, just writing down some source code does not give you a program you can run
10:52:43 <Raymond> As in XP downgrade
10:52:46 * jmcarthur uses emacs
10:52:49 <temoto> Or as in windows 2?
10:52:50 <leimy> emacs is "eight megs and constantly swapping"
10:52:55 <leimy> or is that 80 now?
10:52:56 <djahandarie> Common guys... no yi?
10:52:59 <Berengal> Raymond: If you're going to code on windows, I suggest getting something like Notepad++. It's much easier to start using right away than something like vim
10:53:00 * mmaruseacph2 uses vim for 2 years now
10:53:01 <jmcarthur> leimy: you don't have 8 MB of RAM?
10:53:15 <Eduard_Munteanu> Cale, took me a while to parse, but I get the definition you posted ^. Thanks.
10:53:16 <leimy> no I have much more.
10:53:19 <joe1> i am trying to transform an [Int] -> [custom data structures] and I want to use try in a specific scenario. Do I have to use parsec for it? or is there a try without using the parsec module
10:53:19 <jfischoff> try Leksah
10:53:24 <Raymond> Notepad++ is already on the computer as a default, yeah?
10:53:26 <joe1> @hoogle try
10:53:26 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
10:53:26 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
10:53:26 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
10:53:34 <jfischoff> Notepad++ is good too
10:53:38 <Berengal> Raymond: No, only notepad. Notepad is a horrible editor
10:53:39 <leimy> cat > file
10:53:39 <temoto> Raymond: yeah the most important part in any code editor is highlighting of keywords.
10:53:45 <jmcarthur> @karma notepad
10:53:45 <lambdabot> notepad has a karma of 45
10:53:49 <Cale> Eduard_Munteanu: okay, yeah, I'm basically just describing what (<=<) does anyway
10:53:50 <Berengal> jfischoff: leksah works on windows?
10:53:57 <temoto> @karma c
10:53:57 <jfischoff> works great
10:53:58 <lambdabot> c has a karma of 1
10:54:00 <joe1> @karma vim
10:54:01 <lambdabot> vim has a karma of 5
10:54:03 <chrisf> Berengal: sure does.
10:54:07 <ToRA> vim++ notepad--
10:54:07 <Berengal> Neat
10:54:10 * ToRA does his bit
10:54:14 <jmcarthur> temoto: c is an exception in that plugin
10:54:15 <jmcarthur> c++
10:54:18 <jmcarthur> @karma c
10:54:18 <lambdabot> c has a karma of 1
10:54:22 <leimy> copy con file.hs
10:54:26 <djahandarie> How about c--?
10:54:27 <djahandarie> @karam c
10:54:28 <lambdabot> Maybe you meant: karma karma+ karma-
10:54:30 <djahandarie> ..
10:54:32 <djahandarie> @karma c
10:54:33 <lambdabot> c has a karma of 1
10:54:38 <jmcarthur> @karma+ c
10:54:39 <lambdabot> c's karma raised to 2.
10:54:40 <leimy> use "ed"
10:54:43 <jmcarthur> @karma- c
10:54:43 <lambdabot> c's karma lowered to 1.
10:54:48 <jfischoff> Hey what kind of development tools are people using? anyone use hat?
10:54:49 <Eduard_Munteanu> Cale, yeah, that was composition of Kleisli arrows, IIRC.
10:54:55 <djahandarie> I see
10:54:56 <temoto> jmcarthur: does it understand c++++? :)
10:54:56 <ToRA> use butterflys!
10:55:00 <Cale> Eduard_Munteanu: yeah
10:55:10 <jfischoff> Any tool I should definitely be using
10:55:15 <jfischoff> ?
10:55:20 <joe1> i am trying to transform an [Int] -> [custom data structures] and I want to use try in a specific scenario. Do I have to use parsec for it? or is there a try without using the parsec module. basically, is lookahead available outside of parsec?
10:55:23 <Berengal> jfischoff: cabal :P
10:55:27 <Berengal> jfischoff: Also, ghc
10:55:32 * ksf is using vim, make, cabal and ghci
10:55:32 <jmcarthur> a text editor, ghc, ghci, cabal, hlint
10:55:33 <djahandarie> jfischoff, probably your brain also
10:55:41 <Cale> Eduard_Munteanu: and essentially the monad laws are equivalent to this definition properly giving rise to a category :)
10:55:42 <jfischoff> interesting...
10:55:43 <Berengal> A computer is also nice
10:55:45 <jfischoff> go on
10:55:48 <ksf> oh, hlint too, but rarely.
10:55:52 <Berengal> But you can survive with just paper
10:55:59 <ksf> don't forget quickcheck.
10:56:01 <jmcarthur> yeah hlint is just a quick touchup every once in a while
10:56:07 <jfischoff> what is this comp uter you speak of?
10:56:10 <ddarius> Berengal: Since the arrow is a Kleisli arrow, it is equivalent to using a monad.  There is not much significance in using arrow notation.
10:56:10 <jmcarthur> oh yeah, quickcheck, smallcheck, lazysmallcheck
10:56:14 <ksf> I'd love to use hare, but it's dysfunctional for production use.
10:56:17 <jfischoff> quickcheck no doubt
10:56:22 <jfischoff> hlint is good?
10:56:25 <Raymond> Whats the 2nd most important program?
10:56:29 <leimy> ls
10:56:29 <Raymond> I have notepoad++ now
10:56:30 <jfischoff> what's hare?
10:56:33 <quicksilver> Berengal: hmm, in fact, I think I want Either String, because I want sensible error messages.
10:56:34 <Eduard_Munteanu> Cale, yeah, I can see it for return and join.
10:56:35 <Berengal> ddarius: It feels much nicer
10:56:40 <jmcarthur> hlint is good (sometimes gives wrong output, but it's clear when it does)
10:56:47 <mmaruseacph2> is there a way to get the ghci results in a unix pipe?
10:56:48 <quicksilver> Berengal: and I don't think I ever want multiple results, as it happens.
10:56:54 <ksf> the second most important program is xmonad.
10:56:58 <mmaruseacph2> i mean, is there a way to run some code when ghci is called?
10:57:00 <jmcarthur> darcs
10:57:01 <jfischoff> smallcheck nice
10:57:03 <Eduard_Munteanu> ksf, xmonad FTW :)
10:57:06 <joe1> git
10:57:14 <leimy> emacs
10:57:17 <leimy> hg
10:57:24 <ksf> ...so I can switch to my test console with capslock+k (or j) and run my shell scripts.
10:57:24 <Eduard_Munteanu> ?
10:57:26 <jfischoff> what's xmonad?
10:57:26 <jmcarthur> let's start a holy war
10:57:30 <Berengal> quicksilver: It's not just about the multiple results, but the ability to perform a transformation everywhere it's applicable, in a single application
10:57:30 <jfischoff> haha
10:57:30 <ToRA> monotone
10:57:35 <kmc_> xmonad is a window manager
10:57:35 <jmcarthur> xmonad is a tiling window manager, and it rocks
10:57:40 <Eduard_Munteanu> I use Win for mod :)
10:57:42 <jfischoff> ah
10:57:46 * hackagebot upload: monad-stlike-io 0.1 - ST-like monad capturing variables to regions and supporting IO. (TaruKarttunen)
10:57:49 <dansa> it does rock :)
10:57:56 <leimy> I don't run X11 unless I have to :-)
10:57:56 <ksf> jfischoff, xmonad is an ancient african word that means "You don't have to use a mouse, dummy"
10:57:57 <jmcarthur> jfischoff: i get insanely frustrated on stacking window managers now
10:57:57 <jfischoff> I like derive
10:57:58 <Cale> Eduard_Munteanu: The identity laws for the category correspond to the unit laws for the monad, and the associativity of composition in the category corresponds to the monad's associativity law
10:57:59 <leimy> I kind of hate it.
10:58:06 <dansa> i use it now with a border of size 0
10:58:11 <temoto> i chose xmonad over wmii, icewm, dwm
10:58:20 <jfischoff> ksf: ah
10:58:27 <dansa> i was using wmii; i thought it was quite friendly
10:58:32 <temoto> compiz is the only one better, but it can't do tiling
10:58:32 <quicksilver> Berengal: hmm. Yes. But I think it is about choosing to select multiple things at aonce (and then do a transformation on them)
10:58:41 * Cale would use xmonad if only he could stand tiling wms at all.
10:58:43 <kmc_> screw compiz
10:58:55 <ksf> temoto, I use xcompmgr with xmonad
10:58:57 <jmcarthur> temoto: then compiz is strictly worse than xmonad :P
10:58:58 <dansa> but then i began  to dislike the fact that it doesn't remember the sizes of windows, when you swtich from stack to mode to some other
10:59:02 <Berengal> quicksilver: It is. If that's not to your liking, then you probably wouldn't have too much use of ArrowList
10:59:02 <temoto> What i like about compiz is (surprisingly) his speed.
10:59:03 <ddarius> Cale: I used xmonad, but I don't use the tiling feature.  Really, xmonad is overly featureful for me.
10:59:09 <jmcarthur> temoto: yeah i also use xcompmgr with xmonad and it's nice
10:59:11 <ksf> ...that gets rid of the red borders and replaces them with transparency.
10:59:23 <temoto> because compiz uses acceleration
10:59:29 <dansa> cale, what kind of use of the computer you do that makes it hard on, say, xmonad?
10:59:29 <Philonous1> Cale: You prefer fiddling windows into their position with your mouse?
10:59:31 <jmcarthur> even get pretty fade animations and stuff
10:59:44 <temoto> ksf: what's xcompmgr?
10:59:46 * hackagebot upload: monad-stlike-stm 0.1 - ST-like monad capturing variables to regions and supporting STM. (TaruKarttunen)
10:59:53 <ksf> it's the x composition manager
11:00:00 <temoto> ksf: what it does?
11:00:05 <jmcarthur> compositing
11:00:05 <Twey> Well, one of them
11:00:10 <quicksilver> Berengal: well I like it as a general notion. I'm just not sure it's the notion I need to solve this particular problem with.
11:00:20 <temoto> what is compositing?
11:00:22 <sshc_> why would I use StateT s IO r rather than IO (State s r)?
11:00:25 <Eduard_Munteanu> How should I understand a -> m a (more specifically the 'm a' part) as written in Haskell, as an automorphism on a?
11:00:26 <quicksilver> Berengal: but you have been most thought-provoking, so thank you!
11:00:30 <Berengal> quicksilver: That's what I really meant :)
11:00:38 <ksf> it's the part of the setup that gets all the graphics data from all the windows, including stuff the window manager does, and composes it.
11:00:40 <jmcarthur> what compiz takes advantage of to make things fast and pretty
11:00:49 <Raymond> What font is prefered by programmers to use in chatrooms?
11:00:49 <ksf> compiz is a combined compositor/window manager
11:00:55 <Raymond> or in general
11:01:03 <Twey> Terminus is nice
11:01:09 <jmcarthur> i'm using Menlo
11:01:13 <ddarius> Raymond: Whichever one they prefer.
11:01:13 <Berengal> Raymond: We can't see your font anyway, if that's what you're thinking...
11:01:14 * ksf uses DejaVu Serif
11:01:14 <Twey> DejaVu Mono, too
11:01:17 <mauke_> Raymond: whatever covers most unicode characters
11:01:17 <Twey> Heh
11:01:29 <Raymond> The point is, maybe the font has an effect on genius thinking
11:01:34 <Raymond> Im on courier
11:01:34 <temoto> ksf: did you just said that xcompmgr would make my xmonad expirience smoother because things will happen faster?
11:01:39 * Twey just uses his system's Monospace — glyph substitution for the win
11:01:39 <mauke_> yeah, because programmers are geniuses
11:01:43 * Berengal uses DejaVu Mono size 10, occationally Purisa when he's doing proofs in Agda
11:01:45 <ksf> there's no real reason to go monotyped in irc
11:01:50 <quicksilver> Berengal: my head is now full of thoughts, with which I shall bombard my code.
11:01:50 <jmcarthur> temoto: a bit
11:01:53 <ksf> temoto, nope.
11:01:59 <jmcarthur> temoto: not noticably
11:02:04 <ksf> xmonad does no effects, after all.
11:02:09 <quicksilver> ksf: people might paste figlet output!
11:02:09 <quicksilver> ksf: :)
11:02:09 <Raymond> Mauke, that's an interesting point
11:02:15 <Twey> ksf: Sometimes people align things
11:02:15 <Raymond> what font covers unicode characters?
11:02:19 <temoto> So what would be a reason to use xcompmgr?
11:02:21 <Berengal> quicksilver: Quick! Forget them before they turn into something useful!
11:02:21 <jmcarthur> xcompmgr does some though, which can be used to *slow* your experience a bit
11:02:28 <Eduard_Munteanu> s/auto/endo/
11:02:28 <ksf> transparency.
11:02:37 <jmcarthur> but aesthetics can help productivity, too
11:02:44 <jmcarthur> and transparency beats thin borders
11:02:49 <ksf> which I use as focus indicator, instead of the default borders.
11:02:50 <jfischoff> Raymond: DejaVu Sans Mono Normal
11:02:57 <jfischoff> its free
11:03:14 <temoto> hm interesting
11:03:25 <temoto> so your inactive windows are semi-transparent?
11:03:29 <jmcarthur> yes
11:03:31 <ksf> jmcarthur, I don't think my graphics card is being stressed by alpha-blending two windows...
11:03:36 <Raymond> Ok, i'll get it
11:03:36 <mental> my intentions are transparent :(
11:03:41 <Raymond> thanks
11:03:44 <Eduard_Munteanu> Because Wikipedia and people here say stuff like A -> M A, and M A should be a transformation of A onto itself. Am I right?
11:03:44 <ksf> temoto, yes
11:03:47 <jmcarthur> ksf: no, but i'm being slowed by the nifty fading effects i enabled :P
11:04:00 <jfischoff> ksf: what os do you have?
11:04:03 <ksf> argh no no fading
11:04:10 <ksf> ...I need instant response
11:04:12 <ksf> linux
11:04:22 <jfischoff> ksf: good luck!
11:04:22 <ksf> gentoo, to be precise.
11:04:26 <mauke_> ᴍᴀɪɴ :: IO Iɴᴛ
11:04:33 <jmcarthur> ksf: well, the fading seems to mostly just overlap with the time it takes a window to redraw anyway
11:04:49 <jmcarthur> and i dont' make it take long
11:04:56 <Berengal> mauke_: Is that legal? If so, perhaps I should start coding in cyrillic...
11:05:13 <jmcarthur> jfischoff: what do you mean good luck?
11:05:29 <jfischoff> I just meant I am no help
11:05:36 <jfischoff> that came out wrong
11:05:41 <Eduard_Munteanu> ksf, um, what was your question? I scrolled up but can't see it.
11:06:05 <temoto> Gotta try xcompmgr then, thanks for hint.
11:06:29 <ksf> Eduard_Munteanu, that might be because I didn't ask one.
11:06:49 <Eduard_Munteanu> I really don't understand.
11:06:53 <Eduard_Munteanu> Nvm.
11:09:00 <CESSMASTER> i'm trying to install cabal-install but it is complaining that I do not have Cabal 1.6.* and base with version between 2.0 and 2.2
11:09:08 <Cale> Eduard_Munteanu: M A might not be the same object as A, but it's some object in the same category
11:09:23 <CESSMASTER> did I stumble across a really old version of cabal install or something? if I did I can't find a newer one
11:09:29 * Berengal suddenly got the urge to run a fourier transform on the chat logs
11:09:31 <Cale> (In the case of Haskell, M A is never the same type as A)
11:10:02 <mauke_> type M α = α
11:10:51 <Eduard_Munteanu> Cale, in Haskell, types are objects (sets for example) in categories (e.g. Set)?
11:10:59 <Berengal> type family M;type instance M A = A
11:11:14 <Cale> Eduard_Munteanu: yes
11:11:33 <Cale> Eduard_Munteanu: Types are the objects of the category, (Haskell) functions are the arrows.
11:12:01 <sproingie> CESSMASTER: which compiler and what version of haskell do you have?
11:12:10 <Eduard_Munteanu> Cale, oh so monads are really functors Set -> Set. I keep saying sets because that describes my intuitive notion of type in programming (integers, characters etc.).
11:12:23 <Cale> Eduard_Munteanu: In general, monads are functors C -> C
11:12:29 <Eduard_Munteanu> Yeah.
11:12:44 <Cale> Eduard_Munteanu: together with natural transformations of the appropriate types
11:13:01 <Philonous1> And two diagrams that commute
11:13:02 <CESSMASTER> sproingie: no it turns out that I /did/ have an outdated version of cabal-install. the cabal webpage claims that 0.6 is the latest
11:13:25 <Eduard_Munteanu> Cale, but going to categories seems another level of indirection to me. Why aren't types simply sets?
11:13:29 <Cale> Two or three, depending on how you count. :)
11:13:31 <Berengal> CESSMASTER: 0.8.0 is the latest, but it's for ghc 6.12
11:13:42 <CESSMASTER> Berengal: yes that's what I have now
11:14:03 <Cale> Eduard_Munteanu: Er... there is a single category of types and functions.
11:14:07 <Berengal> I'm pretty sure ghc and cabal needs to be paired...
11:14:20 <Cale> Call it Hask
11:14:29 <Raymond> good font Dejavu!
11:14:34 <CESSMASTER> Berengal: yeah silly me, I didn't even know that 0.8 existed
11:14:40 <Cale> The objects are each Haskell type, and the arrows X -> Y are the Haskell functions of type X -> Y
11:14:59 <Eduard_Munteanu> Cale, oh, that makes more sense.
11:15:01 <Saizan_> Cabal and cabal-install can generally be upgraded safely, without needing to upgrade ghc
11:15:05 <CESSMASTER> (somebody should update the cabal webpage)
11:15:12 <kmc_> the Haskell Platform website is 404'd... does this mean HP for 6.12 is about to emerge from the birthing chamber?
11:15:13 <Berengal> CESSMASTER: It's a bit hard to find. They have't posted it on the download page yet... I think you have to browse the directory listings to find it
11:15:31 <Cale> Eduard_Munteanu: It turns out you can think of individual types as categories in a profitable way
11:15:37 <CESSMASTER> Berengal: yeah I assumed that if there was a new version they'd put it on their site, but I didn't even see it anywhere until I just checked the hackage page
11:16:04 <Cale> Eduard_Munteanu: Though really it's just putting a definedness ordering on the elements.
11:16:51 <Eduard_Munteanu> Cale, why can't that be done with sets and morphisms, and needs categories and arrows? At first, it seems gratuitous to go one level up.
11:17:06 <jfischoff> is there an version of assert in haskell that will give the line number?
11:17:21 <Igloo> kmc_: No; fixed now
11:17:33 <c_wraith> jfischoff: that'd require template haskell.
11:17:36 <Eduard_Munteanu> Cale, most algebra books would define preorder differently.
11:17:36 <Cale> Eduard_Munteanu: You can consider types as sets, but not all functions between those sets are Haskell-definable, so you really want to put some more structure in.
11:17:38 <aavogt> @hoogle assert
11:17:39 <lambdabot> Control.Exception assert :: Bool -> a -> a
11:17:39 <lambdabot> Control.OldException assert :: Bool -> a -> a
11:17:39 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
11:17:46 <Berengal> jfischoff: I think you have to CPP it in...
11:17:55 <Cale> Well, we like categories wherever we can get them
11:17:57 <aavogt> > assert False 'a'
11:17:58 <lambdabot>   Not in scope: `assert'
11:18:05 <aavogt> > Control.Exception.assert False 'a'
11:18:06 <Cale> Order theory is a special case of category theory ;)
11:18:07 <lambdabot>   Not in scope: `Control.Exception.assert'
11:18:10 <jfischoff> Berengal: cool
11:18:17 <Berengal> jfischoff: Other tricks include incomplete patterns...
11:18:34 <Berengal> But they're not nearly as informative as they could've been
11:18:45 <kmc_> I tremble with anticipation.
11:18:51 <jfischoff> yeah that is hacky but works I guess
11:18:56 <Eduard_Munteanu> Cale, oh.
11:19:04 <aavogt> jfischoff: the assert from Control.Exception seems to add line numbers here
11:19:16 <jfischoff> really
11:19:21 <Berengal> > (\True x -> x) ("assertion"=="true") "return value"
11:19:21 <aavogt> must be some magic in ghc
11:19:22 <lambdabot>   "* Exception: <interactive>:1:134-145: Non-exhaustive patterns in lambda
11:19:32 <Berengal> ↑line numbers
11:19:40 <aavogt> ass.hs: /tmp/ass.hs:3:4-9: Assertion failed
11:19:44 <Cale> Eduard_Munteanu: Though to be fair, fixpoint theory is usually defined in terms of orders
11:19:54 <Eduard_Munteanu> Cale, I was thinking like a -> a is more like a functor.
11:20:01 <c_wraith> Igloo:  I've got a question about http://hackage.haskell.org/trac/ghc/ticket/789 ...  Does the fix that was employed help GHCI?  I managed to get that error in GHCI, when loading a module that had a ton of TH-generated code in it.
11:20:03 <jfischoff> maybe it does in ghci?
11:20:08 <Eduard_Munteanu> Where a is forall a
11:20:24 <Cale> Eduard_Munteanu: well...
11:20:37 <CESSMASTER> is there a reason cabal-install wants to go in my /home?
11:20:39 <Cale> Eduard_Munteanu: that could only be the identity function...
11:20:53 <astroboy> I don't know why, but now in ghci instead of "moduleName" it says Prelude moduleName>
11:20:58 <Berengal> CESSMASTER: /home or $HOME?
11:21:00 <astroboy> and a lot of stuff is out of scopre
11:21:01 <aavogt> jfischoff: ghc removes assertions when you compile with -O2
11:21:03 <astroboy> *scope
11:21:07 <Eduard_Munteanu> Cale, um, why? It can be any permutation or any function.
11:21:15 <CESSMASTER> Berengal: the latter
11:21:20 <aavogt> astroboy: module names must be capitalized
11:21:21 <Berengal> CESSMASTER: It lives under $HOME/.cabal by default...
11:21:49 <astroboy> aavogt: it is capitalized (AI in my case). and everything worked until now |:
11:21:50 <Cale> Eduard_Munteanu: Anything of type forall a. a -> a can't actually observe what element of type a it's getting, because it needs to work on any type at all.
11:21:52 <CESSMASTER> really?
11:21:52 <CESSMASTER> why
11:22:13 <Eduard_Munteanu> Cale, oh, I see.
11:22:20 <astroboy> now it compiles but every variable/function from another module (which is imported) is out of scopre
11:22:24 <astroboy> *scope lol
11:22:31 <ehird> [19:21] [CTCP] Received Version request from tolkad to channel #haskell.
11:22:33 <ehird> lulz.
11:22:34 <Berengal> CESSMASTER: It needs to live somewhere, and it's a per-user thing... I'm quite happy with the arrangement, at least.
11:22:53 <Cale> Eduard_Munteanu: Well, okay, there is one other function: const undefined
11:22:54 <aavogt> @time #haskell
11:22:56 <ehird> CESSMASTER: you can set it to systemwide if you want but it's honestly easier just to leave it like that
11:23:09 <tolkad> Looking for bots
11:23:16 <mauke_> tolkad: again?
11:23:18 <tolkad> yes
11:23:26 <mauke_> tolkad: why?
11:23:36 <tolkad> I'm bored and they are fun to play with
11:23:39 <Zao> Isn't there a !bots or similiar command to have them announce themselves?
11:23:49 <tolkad> nope
11:23:53 <mauke_> tolkad: be bored somewhere else
11:23:55 <aavogt> well they don't have to identify themselves
11:23:58 <Zao> @botsnack
11:23:58 <lunabot>  :o
11:23:58 <lambdabot> :)
11:24:07 <tolkad> Oh come on, what do people have against versions?
11:24:17 <Eduard_Munteanu> Cale, hm, will go reading about this, perhaps I also find a proof of that (seems interesting). Thanks.
11:24:18 <Zao> tolkad: Annoying OMGGREEN line in chat.
11:24:35 * Berengal didn't even notice
11:24:50 <Cale> Eduard_Munteanu: polymorphic functions actually correspond more closely to natural transformations
11:24:59 <tolkad> @help
11:25:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:25:08 <Zao> http://www.acc.umu.se/~zao/version.png <- like that
11:25:42 <Eduard_Munteanu> Cale, I would've thought of them as arrows or something like that.
11:25:55 <inhortte> # rm -rf / ls
11:25:55 <inhortte> total 64
11:25:56 <lunabot>  luna: parse error on input `|]'
11:26:04 -mauke_(n=mauke@p3m/member/mauke)- Zao: how about this? :-)
11:26:12 <Zao> mauke_: A soothing purple.
11:26:20 <Cale> Eduard_Munteanu: Well, they're one arrow for each possible choice of type
11:26:21 <jfischoff> is there a way to get the call stack in an assert?
11:26:24 -sshc_(n=sshc@unaffiliated/sshc)- mauke_: quite
11:26:27 <McManiaC> mauke_: fu
11:26:37 <McManiaC> stupid highlighters
11:26:38 <McManiaC> ^^
11:26:39 <mauke_> McManiaC: fix your client
11:26:53 <Berengal> jfischoff: There was a paper on that somewhere, and a lecture at the last ICFP
11:26:57 <mauke_> you don't want highlights on NOTICE
11:27:38 <endojelly> mauke_, I disagree. in my case, the vast majority of the time, they are interesting to me (and I specifically turned hilighting notices on)
11:27:44 <endojelly> then again, I'm not in 10 IRC channels at once
11:27:50 <jfischoff> Berengal: interesting
11:27:57 <Berengal> jfischoff: It's usually useless, unless you build one yourself though, because of lazyness and all that
11:28:09 <Ke> type DateTime = UTCTime << does this preserve instances of classes
11:28:13 <jfischoff> Berengal: ah
11:28:19 <Ke> ie does type
11:28:29 <sshc_> if I wanted to use Monad transformer for IO (State s r), would I use StateT s IO r or StateT s (IO ()) r?
11:28:40 <Berengal> jfischoff: print someComplexExpression can be reduced to print (head []) before it fails, at which point the stack is just print -> head
11:28:42 <McManiaC> mauke_: not highlights, but urgent hints with irssi + xmonad
11:28:54 <c_wraith> @kind StateT
11:28:55 <lambdabot> * -> (* -> *) -> * -> *
11:28:56 <mauke_> McManiaC: that's crazy
11:29:09 <c_wraith> sshc_: given that kind, the answer is clearly the former
11:29:22 <mauke_> preflex_: nick preflex
11:29:25 <c_wraith> sshc_: because IO has kind * -> *
11:29:35 <jfischoff> Berengal: Right, your missing everything that lead up to that
11:29:35 <c_wraith> sshc_: but IO () has kind *
11:29:40 <Igloo> c_wraith: In 6.12.1?
11:29:58 <c_wraith> Igloo: in 6.10.3.  Is that version actually older than the fix?  If so, I'll feel dumb.
11:30:13 <Igloo> c_wraith: I'm afraid so
11:30:15 <Eduard_Munteanu> What happened to IO (a)?
11:31:04 <Eduard_Munteanu> Or what changed?
11:31:16 <jfischoff> Berengal: looks GHCI has some functionality for getting the call stack
11:32:11 <Berengal> jfischoff: Yes, ghci has a debugger, which changes everything.
11:32:16 <Raymond> What is the most resource friendly website for haskell?
11:32:19 <Raymond> that i can use
11:32:22 <c_wraith> Igloo: well, thanks for clearing that up for me.
11:33:21 <Igloo> np
11:33:31 <Berengal> jfischoff: I've also heard some rumors about ghc leaving breadcrumbs as it evaluates, and picking them up if it fails, though it's not guaranteed to be a real callstack, and the gc might've eaten parts of it
11:33:39 <Eduard_Munteanu> Does latest GHC conform to Haskell 2010?
11:34:03 <Berengal> jfischoff: Basically, yes, it's possible to trace execution in Haskell... -ish. You won't get the callstacks of Java anytime soon
11:34:28 <Berengal> Eduard_Munteanu: Not by default
11:34:44 <Eduard_Munteanu> Berengal, thanks. That's probably due to the n+k pattern removal.
11:35:11 <Eduard_Munteanu> *stuff like
11:35:20 <Berengal> Eduard_Munteanu: I think some of the other extensions added aren't enabled by default either, but it's all there if you want it
11:35:44 <Eduard_Munteanu> I was expecting more of a change from Haskell 2010, but there doesn't seem to be much. GADTs aren't in yet AFAIK.
11:35:51 <ski> Raymond : maybe the wiki ?
11:36:08 <sshc_> c_wraith: how would I execute the monad inside of an IO monad to get the State out of it?
11:36:21 <c_wraith> :t runState
11:36:22 <lambdabot> forall s a. State s a -> s -> (a, s)
11:36:25 <Eduard_Munteanu> Berengal, I see.
11:36:26 <c_wraith> :t runStateT
11:36:27 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
11:36:38 <ski> (sshc_ : s/monad/action/)
11:36:43 <Raymond> good resource are avail on wiki?
11:37:49 <ski> @wiki
11:37:49 <lambdabot> http://www.haskell.org/haskellwiki/
11:37:57 <mauke_> preflex: set Reply:#haskell Notice
11:38:00 <mauke_> let the screaming begin
11:38:13 <Raymond> thansk!
11:38:25 <mbana> can i parse input read from the terminal into a adt?
11:38:39 <mauke_> mbana: how about String?
11:39:02 <c_wraith> preflex: seen mauke_
11:39:03 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- mauke_ was last seen on #haskell 23 seconds ago, saying: mbana: how about String?
11:39:40 <sproingie> mbana: define a Read instance and you're all set
11:39:48 <kmc_> mbana, sure.  look at Parsec
11:40:35 <mbana> im not sure if this is possible.  i got data A = B | C.  now, say, C is read from terminal.  i want to store C into a variable of type A
11:40:37 <mbana> ok thanks
11:41:07 * hackagebot upload: haskell-src-exts 1.7.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
11:41:07 <mauke_> case x of "C" -> C; _ -> B
11:41:34 <c_wraith> sshc_: so if you use runStateT on a StateT s IO a, you'll get back a function s -> IO (a, s), which I think is what you're looking for.
11:41:51 <sproingie> > read "Left 123" :: Either Int Int
11:41:52 <lambdabot>   Left 123
11:44:36 <Berengal> > read "()"
11:44:37 <lambdabot>   ()
11:45:10 <Raymond> Is it necessary to have self mastery on lamdba calculus?
11:45:52 <sshc_> Raymond: necessary for what?
11:47:16 <aavogt> and what is self mastery?
11:48:01 <Raymond> I'm confused as well. i read this "Most functional programming languages are based upon the lambda calculus. "
11:48:42 <sshc_> c_wraith: I want behaviour similar to IO (State s a)
11:48:50 <sshc_> c_wraith: should I use IOT instead?
11:49:03 <aavogt> IOT is very dangerous
11:49:05 <c_wraith> sshc_: there's no IOT unless you invent time travel. :)
11:49:23 <Raymond> dangerous is an intriguing word
11:49:33 <sshc_> aavogt: why is it dangerous?
11:49:37 <c_wraith> sshc_: If you need state in IO, though, there are options like IORefs.
11:49:53 <aavogt> @unmtl StateT s IO a
11:49:53 <lambdabot> s -> IO (a, s)
11:50:26 <c_wraith> sshc_: IOT would imply time travel...  restoring the entire universe to a previous state, in the case that your monad backtracks.
11:50:33 <aavogt> @unmtl IOT (State s) a
11:50:34 <lambdabot> IOT (State s) a
11:51:03 <dolio> If you think of IO as passing the state of the world around, the purpose of IO is to ensure that the world is used linearly.
11:51:05 <aavogt> c_wraith: or your side effects happen all over the place
11:51:22 <dolio> That isn't possible with IOT.
11:51:37 <sshc_> c_wraith: my code actually takes a list of [IO (State s a)], sequences them, and execState's it on an initial state
11:51:46 <sshc_> c_wraith: how would I do that with StateT?
11:52:12 <c_wraith> sshc_: why would you want to?  there's nothing wrong with what your code is doing.
11:52:57 <sshc_> c_wraith: is it impossible to do?
11:53:39 <c_wraith> Probably not, but this conversation requires backing up one step higher.  What are you doing that's resulting in that type?
11:54:29 <monochrom> You can write a function of type [IO (State s a)] -> s -> IO a.  In the last IO a, the IO cannot be avoided.
11:54:56 <monochrom> You can also just admit misdesign and agree to redesign.
11:54:57 <sproingie> Raymond: the knowledge needed to program in haskell is a subset of the knowledge needed to understand every conversation in #haskell
11:55:30 <sproingie> Raymond: knowing what a lambda expression is is useful, that's about all the LC you need.
11:56:01 <ddarius> If you can program in Haskell effectively, you already understand the lambda calculus, though perhaps not its meta-theory.
11:56:41 <Twey> A small subset :þ
11:57:10 <sproingie> i only have the vaguest understanding of things like "head normal form".  let alone simply typed LC.  but i'm probably intuiting most of it anyway.
11:57:16 <Twey> Hmmm
11:57:19 <sshc_> Twey: I it?
11:57:24 <Twey> 19:50:03 < c_wraith> sshc_: IOT would imply time travel...  restoring the entire universe to a previous state, in the case that your monad  backtracks.
11:57:36 <Twey> That's actually possible…
11:57:40 <sproingie> someone should port TimeWarp to haskell
11:58:08 <sproingie> it's a distributed simulation system with only one synchronization primitive, namely rollback
11:58:27 <sproingie> if you think of the timeline going left to right, it really is "just a jump to the left, and a step to the right"
11:58:32 <sproingie> not sure about the pelvic thrusts tho
11:58:36 <Twey> Heh
11:58:43 <c_wraith> well, driving the users insane is bad anyway
11:59:15 <sshc_> where is the documentation for IOT?
11:59:27 <dolio> There is no IOT.
11:59:28 <opqdonut> there is no IOT
11:59:36 <benmachine> > text "there is no IOT"
11:59:38 <lambdabot>   there is no IOT
11:59:38 <c_wraith> there is a spoon, though
11:59:54 <sshc_> @hoogle spoon
11:59:54 <lambdabot> No results found
12:00:04 <sproingie> @hayoo spoon
12:00:05 <lambdabot> Unknown command, try @list
12:00:07 <sproingie> bah
12:00:09 <sshc_> no spoon either
12:00:14 <c_wraith> @hackage spoon
12:00:14 <lambdabot> http://hackage.haskell.org/package/spoon
12:00:16 <sproingie> @hackage spoon
12:00:17 <lambdabot> http://hackage.haskell.org/package/spoon
12:00:19 <sproingie> darn you
12:03:09 * benmachine has a hard time working out where spoon uses ScopedTypeVariables
12:03:27 <Polarina> Is anyone here from Iceland? :)
12:03:47 <dobblego> Polarina, Apocalisp
12:04:01 <Polarina> dobblego: Are you?
12:04:15 <sshc_> spoon uses unsafePerformIO
12:04:17 <dobblego> no
12:04:20 <Polarina> dobblego: :(
12:04:26 <dobblego> sorry :(
12:04:27 <Runar> Hello, yes?
12:04:32 <Polarina> Runar: Hæ!
12:04:35 <sshc_> is there no way to do what spoon does without unsafePerformIO?
12:04:39 <Runar> Gan daginn
12:04:47 <Polarina> Runar: Please use UTF-8.
12:04:59 <benmachine> sshc_: none
12:05:45 <Polarina> Runar: How's life? :)
12:06:32 <Runar> Polarina: Life is freaking awesome. How are you?
12:07:04 <Polarina> Runar: I am chatting with friends on VoIP.
12:07:20 <mental> that was definitely UTF-8
12:07:47 <Runar> I thought I was using UTF-8
12:07:57 <mental> you were
12:08:01 <Polarina> Runar: I saw the special characters as question marks.
12:08:25 <rovar> what is the max size of Int on a 32 bit machine?
12:08:28 <Runar> Maybe you're not decoding UTF-8 properly on your client
12:08:34 <rovar> it's not actually limited to 32 bits is it?
12:08:36 <mauke> äξ€
12:08:44 <Polarina> mauke: :D
12:08:46 <c_wraith> rovar: at least 30 bits, according to the haskell 98 standard
12:09:02 <Polarina> Runar: Perhaps, however I doubt that.
12:09:05 <c_wraith> rovar: ghc, on a 32-bit platform, will use a 32-bit signed primitive type
12:09:07 <benmachine> rovar: maxBound :: Int in ghci is the best way to find out
12:09:16 <rovar> nice
12:09:17 <rovar> thanks
12:09:26 <c_wraith> rovar: if you want an unbounded type, there's Integer
12:09:26 <benmachine> for me it says 2147483647
12:09:28 <rovar> yep
12:09:29 <Runar>  heyrist gnr ma r uxakv og b ts
12:09:45 <Polarina> Runar: I am not able to read your characters, sorry.
12:09:51 <rovar> okay.. so what would be an integral datatype i could use for 64 bit numbers?
12:09:58 <mauke> Polarina: could you see my text?
12:09:59 <Zao> Speaking UTF-8 doesn't help with the language behind anyway.
12:10:02 <c_wraith> rovar: Word64
12:10:02 <Polarina> rovar: Integer.
12:10:05 <sshc_> rovar: if you need fixed width integer, look at Data.Word or Data.INteger
12:10:09 <Polarina> mauke: I was able.
12:10:10 <sshc_> rovar: Int64
12:10:14 <rovar> Integer
12:10:14 <sshc_> rovar: or Word64
12:10:24 <aavogt> or Int64
12:10:32 <sshc_> or Word64
12:10:35 <rovar> in ghci i did  let foo = 234234234234234234234; :t foo
12:10:36 <aavogt> lots of choice :)
12:10:40 <rovar> and it told me Integer
12:10:54 <sshc_> rovar: if you want a fixed-width 64-bit unsigned integer, Word64
12:10:57 <sshc_> then
12:11:02 <Polarina> rovar: Integer is infinitely-sized, in theory, that is.
12:11:08 <rovar> hrrm...
12:11:39 <rovar> it's tricky..  i am interfacing with C structs.. so it ultimately ends up as word64le
12:11:50 <rovar> but I'd like a more user friendly interface...
12:11:58 <sshc_> rovar: it's plenty user friendly
12:12:03 <rovar> i suppose..
12:12:06 <Polarina> I use stdout/stdin myself.þ
12:12:08 <Polarina> s/þ//
12:12:10 <sshc_> rovar: Integer is unbound intereg, can get really huge as you want
12:12:29 <sshc_> rovar: Int is a general integer that the compiler will choose a good value for it
12:12:40 <benmachine> Int is silly
12:12:41 <sshc_> rovar: Int(8|16|32|64) are all signed fixed-width integers
12:12:51 <sshc_> rovar: Word(8|16|32|64) are all unsigned fixed-width integers
12:12:57 <benmachine> there are very few cases where Int is necessary or useful
12:13:18 <sshc_> rovar: Int and Word can be any of their four variants
12:13:32 <Runar> Hvað með núna?
12:13:34 <monochrom> rovar: If you're interfacing with C, there are CInt, CUInt, CLong, ...
12:14:02 <sshc_> benmachine: why wouldn't you use Int when you don't care about the width of it?
12:14:16 <monochrom> See Foreign.C.Types
12:14:21 <benmachine> sshc_: why would you use an Int when you don't care about the width?
12:14:35 <benmachine> it's just an extra way for the program to surprise you
12:14:46 <Polarina> Runar: Frábært!
12:15:05 <sshc_> benmachine: because the compiler will choose the best Int for you?
12:15:14 <sshc_> benmachine: why would you use Int32 instead?
12:15:14 <Runar> Polarina: Hví vildirðu vita hvort Íslendingar væru hér? Ertu frá fróni eða?
12:15:23 <benmachine> sshc_: the compiler will choose Int
12:15:29 <mauke> .oO( "GRUNNUR" )
12:15:46 <Polarina> Runar: Nei, einn vinur minn var að halda því fram að ég væri eini íslendingurinn sem væri það vitlaus, að hanns mati, að nenna að vesenast með Haskell.
12:15:53 <benmachine> it won't choose the best anything
12:16:09 <Runar> Polarina: allt kalla menn vini sína
12:16:13 <sshc_> benmachine: if you use Int16 even if you know the Int won't get bigger than 200, how do you know Int32 won't have better perfomance?
12:16:22 <Polarina> Runar: Kunningi minn þá. :P
12:16:29 <benmachine> sshc_: I am not arguin you should use IntN
12:16:36 <benmachine> I am arguing you should use Integer
12:16:38 <monochrom> This debate is silly. The question started with "I'm interfacing with C", and then suddenly pedants start asking "why Int when you have Integer".
12:16:38 <benmachine> almost always
12:16:51 <sshc_> benmachine: why?
12:16:54 <sshc_> benmachine: it's slower
12:16:59 <monochrom> May as well ask "why C when you have Haskell".
12:17:11 <benmachine> suit yourselves, I am sure
12:17:49 <sshc_> benmachine: if you know that an integer won't get big, why would you use Integer?
12:18:22 <sshc_> although I guess almost always you really don't know it won't grow big
12:18:38 <Runar> Haskell er málið. Það eru allir hinir Íslendingarnir sem eru bara ekki búnir að fatta að þeir eru að leysa sömu vandamálin aftur og aftur.
12:19:34 <sshc_> benmachine: let's take a practical example: a number representing the number of seconds or nanoseconds since some epoch
12:19:43 <Polarina> Runar: Alveg dagsatt.
12:19:49 <Runar> Polarina: Ertu að vinna með Haskell eða bara leika þér?
12:19:52 <Twey> 20:16:36 < monochrom> May as well ask "why C when you have Haskell".
12:19:54 <sshc_> benmachine: if it's updated every frame, would you use Int64 or Integer?
12:19:57 <Twey> Seems a reasonable question to me
12:19:59 <benmachine> sshc_: you're right, it doesn't matter that much
12:20:00 <Polarina> Runar: Það síðarnefnda.
12:20:05 <Polarina> Runar: En þú?
12:20:09 <sshc_> benmachine: which one would you use?
12:20:18 <benmachine> I'd personally use Integer
12:20:25 <sshc_> ok, why?
12:20:27 <benmachine> because it's more flexible
12:20:48 <benmachine> it's more ubiquitous
12:20:51 <c_wraith> Most of the time I use Int, it's because I don't feel like typing "generic" all over the place
12:20:55 <sshc_> how is it more flexible?
12:21:11 <Polarina> Runar: Ég held samt að aðalástæðan hví ég er að læra Haskell sé sú að ég ætla að taka þátt í forritunarkeppni framhaldsskólanna í ár og mig langar að rugla dómnefndina alveg þegar þeir fara yfir verkefnin mín. :P
12:21:16 <Alpounet> @type generic
12:21:17 <lambdabot> Not in scope: `generic'
12:21:30 <c_wraith> :t genericLength
12:21:31 <lambdabot> forall b i. (Num i) => [b] -> i
12:21:38 <benmachine> well, suppose the number was in seconds, I could change it to nanoseconds without worrying about the type
12:21:43 <Alpounet> oh, ok
12:21:53 <monochrom> Twey: It is unreasonable within the particular context. And so is the silly debate.
12:22:31 <Runar> Polarina: Ég er reyndar ekki að vinna með Haskell, heldur Scala, en við dibblego erum búnir að heimfæra helling af dóti úr Haskell yfir í það tungumál.
12:23:03 <Runar> Já flott hjá þér. Ég vona að þú vinnir.
12:23:04 <Polarina> Runar: Er eitthvað vit í Scala?
12:23:10 <Polarina> Runar: Þakka þér.
12:23:21 <Runar> Polarina: Það er eitthvað vit í því, en voða mikið óvit líka.
12:23:44 <Polarina> Runar: Meinar.
12:23:49 <Runar> Polarina: Í hvaða skóla ertu?
12:24:13 <Polarina> Runar: Fjölbrautaskóla Snæfellinga, en ætla í Tækniskólann næstu önn.
12:24:31 <Polarina> Runar: Er að klára grunnfögin eins og er, en þeir kenna enga tölvunarfræði hér.
12:24:49 <opqdonut> icelandic?
12:24:57 <Polarina> opqdonut: Yes! :D
12:25:13 <opqdonut> the thorns give you away
12:25:16 <Runar> já, ókei. Ég var einmitt í Iðnskólanum í Reykjavík sem var og hét.
12:25:39 <Polarina> Runar: Ertu þá nú í háskólanum í reykjavík?
12:25:51 <Runar> Nei ég er reyndar starfandi í Bandaríkjunum.
12:26:07 <Polarina> Runar: Gott starf? Hvað ertu að vinna við?
12:28:24 <Runar> Fínt starf já. Er að forrita greiningar- og líkanaforrit fyrir fjárfestingastofnanir.
12:28:42 <kmc_> bork bork bork
12:28:48 <Polarina> Runar: Sniðugt, og áhugavert. Er það ekki neitt flókið?
12:29:04 <Runar> Jújú, ansi strembið, en það er bara gaman.
12:29:45 <Runar> Ertu strákur eða stelpa, svo maður viti hvort maður eigi að nota eitt enn eða tvö.
12:29:50 <Polarina> Runar: Auðvitað, enda alltaf gaman að sjá sjálfan sig hafa leyst vandamál sem áður fannst manni flókið ellegar ómögulegt.
12:29:57 <Polarina> Runar: Ég er karlkyns.
12:30:22 <Runar> það staðfestir minn grun
12:30:36 <Polarina> :P
12:31:28 <Polarina> Runar: Ég ágiska slíkt hið sama varðandi þig.
12:31:33 <Runar> Já, ég hefði sko alls ekki getað unnið þessa vinnu nema hafa tekið góða dýfu ofan í Haskell.
12:32:01 <Runar> Polarina: Nei, ég er eina íslenska konan sem heitir Rúnar. :Þ
12:32:14 <Polarina> Runar: Sniðugt. Gæti svarið að þú værir hvorugkyns. :D
12:33:01 <Runar> Heh. Maður ætti þá nett vonda foreldra.
12:34:32 <Polarina> Runar: Haha! Ég er sjálfur að vinna í stdin/stdout interfacei fyrir forritunarkeppnina fyrir samskipti milli forrita. Málið er að við erum þrír í liði, hver og einn með sitt forritunarmál.
12:34:52 <Runar> Polarina: jahérna
12:34:54 * osfameron wonders if ragnarok happened
12:34:55 <Polarina> Runar: Ég ég á einnig nett network library sem ég bjó til í Python, þannig að samtals fjögur mál, sem vinna þarf öll saman.
12:35:26 <Runar> osfameron: Two Icelandic Haskellers meeting on IRC is isomorphic to Ragnarrök
12:35:43 <mahogny> <3 isländska
12:35:47 <osfameron> ;-)
12:36:26 <Polarina> Runar: Til að telja upp málin, eru þau: C#, PHP, Python og Haskell.
12:36:29 <Berengal> Icelandic bothers me. It's almost understandable, but not enough that I can actually understand anything. Confuses my brain it does...
12:36:31 * kmc_ wonders how to say "zygohistomorphic prepromorphism" in Icelandic
12:36:53 <cp2> kmc_: foobar foobar foobar
12:36:54 <b_jonas> lol
12:37:08 <EvanCarroll> There is no printable representation of the null value. In this manual the symbol λ
12:37:11 <EvanCarroll> (lambda) is sometimes used to denote the null value.
12:37:34 <b_jonas> EvanCarroll: isn't it capital lambda though?
12:37:36 <Berengal> EvanCarroll: :O
12:37:39 <benmachine> Λ
12:37:40 <EvanCarroll> what i think when i see it.
12:37:42 <EvanCarroll> Null.
12:37:49 <mauke> nuλ
12:38:06 <mahogny> Berengal, really? norwegian? I can make sense of it (swedish), thought you'd be closer?
12:38:23 <Polarina> Nothing's close to Icelandic.
12:39:22 <monochrom> The null calculus.
12:39:32 <Runar> Ju, Foroyska
12:39:56 <Polarina> Runar: Já, en bara það. En minnir mig á það að ég á enn nokkra afganga í buddunni minni. :D
12:39:56 <b_jonas> no, seriously, Knuth uses capital lambda to denote the null pointer. I don't know where it comes from.
12:40:08 <Runar> ojj
12:40:18 <Polarina> Runar: Haha!
12:41:17 <Berengal> mahogny: Spoken icelandic is understandable if spoken slowly. It's almost what my grandparents speak. Written is a bit different, since norwegian writing has rather deep danish roots
12:42:03 <mahogny> Berengal, ah. that is right. and newnorwegian doesn't look very similar either
12:42:20 <Berengal> People from the Faroe islands I can understand pretty decently
12:42:30 <hey> are monads exclusive to haskell?
12:42:34 <dobblego> hey, no
12:42:35 <Runar> b_jonas: beyslissagnhverf forframhverfa
12:42:54 <Berengal> mahogny: Indeed, it's quite different in language. I think written sweedish is actually closer to icelandic than any of the norwegians
12:42:59 <mahogny> yeah
12:43:08 <hey> dobblego: where else?
12:43:19 <dobblego> hey, every turing complete language
12:43:19 <monochrom> Just that haskell has syntax sugar for monads. You can easily do monad in SML if you don't miss the sugar help.
12:43:23 * Berengal is a natural newnorwegian writer, and proud of it
12:43:26 <mahogny> Berengal, is the danish spelling on the way out yet?
12:43:32 <dobblego> hey, I use them in Java regularly; also Scala
12:43:36 <mauke> hey: category theory
12:43:37 <Berengal> mahogny: Not in the least :(
12:43:46 <mahogny> Berengal, bleh
12:44:09 <hey> I meant as a language feature
12:44:11 <Runar> kmc_: beyslissagnhverf forframhverfa
12:44:18 <Runar> sorry, wrong guy
12:44:31 <mahogny> Berengal, how messy is it to learn in fact both? is it easy to guess the newnorwegian spelling or the danish one?
12:44:34 <dobblego> hey, Scala has monad comprehensions; Monads are not a language feature in Haskell except to the extent of do-notation
12:44:47 <b_jonas> monochrom: laziness makes them easier in haskell though
12:44:47 <Runar> kcm_: That is how you say it in Icelandic :)
12:45:12 <Polarina> Runar: Hvar fannstu þessa þýðingu?
12:45:31 <hey> ok, dobblego :)
12:45:52 <Runar> Polarina: Ég bara fann hana upp maður, nýyrðaskáldið.
12:45:57 <Berengal> mahogny: Grammatically they're rather similar, with some weird edge cases. The spelling varies, but mostly in a predictable fashion
12:46:10 <Polarina> Runar: Nýsköpun toppar allt saman. ;)
12:46:27 <Runar> Polarina: Ég tem mér yfirleitt að vera óvenjulega hreintyngdur.
12:46:36 <mahogny> Berengal, "gramatically"?? how does grammar go into the spelling?
12:47:08 <Polarina> Runar: En gamann. :)
12:47:37 <Berengal> mahogny: Things like verb-suffixes and stuff are both grammar and spelling
12:47:44 <monochrom> It is time to tell you to go to #haskell-blah for Scandinavian language discussion.
12:47:51 <Berengal> Agreed
12:47:56 <Polarina> monochrom: Aww. :(
12:48:13 <b_jonas> monochrom: why, you want to ask some actual h question?
12:48:17 <mahogny> Berengal, oh. I see
12:48:42 <mauke> Háskóli Íslands?
12:48:55 <Polarina> mauke: Háskóli Reykjavíkur.
12:49:31 <Runar> no, Háskólinn í Reykjavík
12:49:43 <Polarina> Runar: Alveg nákvæmlega eins.
12:49:48 <Polarina> ;)
12:51:16 <Polarina> Runar: Notar þú eitthverskonar VoIP spjallforrit?
12:51:37 <Runar> ég nota skæp endrum og eins til að hringja heim
12:51:56 <Alpounet> hey
12:52:38 <Polarina> Runar: Ah. Ég nota sjálfur mumble til að spjalla við vini og kunningja.
12:55:54 <Polarina> Runar: Þér er velkomið að koma og spjalla, miðlarinn er opinn almenningi. :)
12:56:24 <Runar> ef til vill seinna
12:56:42 <Polarina> Runar: Skal senda þér slóð með leiðbeiningum ef þú hefur áhuga síðar.
12:56:57 <Runar> takk
12:57:07 <Polarina> Runar: Minnsta málið.
12:57:55 <sm> that fp bibliography tool looks pretty cool
12:58:47 <sm> it found me another nifty spj presentation: http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/ECOOP-July09.pdf
12:59:07 <sm> which includes Haskell the Cat !
13:00:55 <shapr> Icelandic still looks like Swedish to me.
13:01:24 <Twey> You crazy person.
13:01:38 <joed> Very intoxicated swedish viewed through very wrong perscritpion glasses.
13:01:57 <mauke> bork bork bork
13:01:57 <Twey> It looks mostly like Old English to me.
13:06:03 <Runar> There was once an Icelander who went to Denmark for vacation. His friend had told him "don't worry about speaking Danish, just speak very slowly". At a bar in Copenhagen he ordered a drink very slowly: "I ... want ... one .. beer..." Then after a few rounds he says to the bartender "I ... am ... from ... Iceland." and the bartender says "so ... am ... I." to which our friend replies:
13:06:12 <Runar>  "Then ... why .. are ... we ... both ... speaking ... Danish?"
13:06:38 <Polarina> Runar: Haha!
13:07:45 <Polarina> Runar: Hef ekki heyrt þennan áður. :)
13:08:57 <Berengal> Hah, SPJ har xkcd bookmarked
13:09:11 <monochrom> How do you know?
13:09:13 <Berengal> (Assuming that's his browser in the slides)
13:09:21 <monochrom> Oh haha
13:09:41 <pastah_rhymez> #haskell, for all you functional programming gossip needs
13:09:42 <lunabot>  luna: parse error on input `|'
13:10:17 <CESSMASTER> not as good as guido van rossum's Perez Hilton bookmark
13:10:36 <osfameron> at least it wasn't Paris Hilton
13:18:17 <pigdude> what's the name of the function again that will return [a, b] from [a, b, c]?
13:18:23 <pigdude> inverse of tail, sort of
13:18:33 <aavogt> pigdude: init
13:18:52 <pigdude> thanks, I defer to haskell nomenclature in my JS extensions to natives :)
13:18:55 <mental> @src init
13:18:55 <lambdabot> init [x]    = []
13:18:55 <lambdabot> init (x:xs) = x : init xs
13:18:55 <lambdabot> init []     = undefined
13:20:02 <Polarina> @src undefined
13:20:03 <lambdabot> undefined =  error "Prelude.undefined"
13:20:05 <lispy> That version of init seems long
13:20:40 <lispy> Wait, init (x:xs) = x : init xs
13:20:58 <lispy> > init [1..3]
13:21:00 <lambdabot>   [1,2]
13:21:04 <lispy> oh, right
13:21:07 <lispy> I was thinking of tail
13:21:12 <pigdude> init: function() { return this.slice(0, this.length - 1); } // :)
13:21:57 <lispy> > take 1 . init [1..]
13:21:58 <lambdabot>   No instance for (GHC.Enum.Enum [a])
13:21:59 <lambdabot>    arising from the arithmetic sequence...
13:22:54 <Twey> Hmph
13:22:57 <lispy> take 1 $ init [1..]
13:23:06 <lispy> > take 1 $ init [1..]
13:23:07 <lambdabot>   [1]
13:23:10 <ski> > (take 1 . init) [0 ..]
13:23:12 <lambdabot>   [0]
13:23:24 <lispy> Okay, so my only point was that the version using length wouldn't work on infinite listst
13:23:42 <Polarina> > length [5..]
13:23:46 <lambdabot>   mueval-core: Time limit exceeded
13:23:53 <Twey> There's a problem here: how do we reliably optimise ‘take (length xs - 1) xs’ into one pass?
13:24:25 <Twey> That's something I really miss in Haskell.  The lack of it seriously hurts composability.
13:25:09 <aavogt> Twey: init of course
13:25:20 <Twey> aavogt: Generally, I mean
13:25:26 <aavogt> and if you need to drop a lot more off the tail, it's probably worthwhile to reverse the thing
13:25:46 <Twey> ‘Write a new function from scratch to use explicit recursion’ is not a solution, it's a hackaround :þ
13:26:02 <aavogt>  reverse . drop n . reverse
13:26:22 <lahmas> Hey
13:26:24 <aavogt> probably only twice as slow
13:26:39 <aavogt> hey lahmas
13:26:47 <lahmas> I'm new to haskell and wanted to know where it is actually used, could someone tell me that? :)
13:26:59 <Polarina> lahmas: Here.
13:27:09 <pastah_rhymez> lahmas: in the future
13:27:22 <aavogt> @where industry
13:27:23 <pastah_rhymez> @faq Can haskell be used for anything?
13:27:23 <lambdabot> I know nothing about industry.
13:27:23 <lambdabot> The answer is: Yes! Haskell can do that.
13:27:38 <pastah_rhymez> aavogt: haha! NICE!!
13:27:43 <aavogt> @google haskell in industry
13:27:45 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
13:27:45 <lambdabot> Title: Haskell in industry - HaskellWiki
13:28:02 <newsham> ?vixen what do you know about industry?
13:28:04 <lambdabot> i dunno, what about?
13:28:26 <Twey> aavogt: Psst: a function that results in three passes is not a solution to the problem of optimising a two-pass function :þ
13:28:59 <aavogt> Twey: no, my function does two passes, just like yours
13:29:24 <Twey> Ah, I suppose in total
13:29:31 <Twey> Still not an optimisation, though :þ
13:29:46 <aavogt> no, but you don't have to name xs twice :)
13:29:52 <lispy> ?faq Can Haskell solve unsolveable problems?
13:29:52 <lambdabot> The answer is: Yes! Haskell can do that.
13:29:57 <aavogt> @pl \xs -> take (length xs - 1) xs
13:29:58 <lambdabot> take =<< subtract 1 . length
13:30:01 <Twey> If I'd wanted to do that, I'd have used liftM2
13:30:15 <Twey> liftM2 take (subtract 1 . length) id
13:30:26 <dansa> ?faq Can Haskell solve unsolvable problems?
13:30:27 <lambdabot> The answer is: Yes! Haskell can do that.
13:30:32 <aavogt> Twey: how about inits?
13:30:45 <dansa> that's such a cute bot :)
13:30:49 <Twey> What about inits?
13:30:49 <aavogt> > inits "hello" !! 1
13:30:51 <lambdabot>   "h"
13:30:56 <dansa> it even understands typos and stuff :)
13:30:58 <aavogt> > inits "hello" !! 3
13:30:59 <lambdabot>   "hel"
13:31:06 <ski> > (last . inits) "abcd"
13:31:08 <lambdabot>   "abcd"
13:31:09 <Twey> dansa: She's pretty clever.  ☺
13:31:09 <c_wraith> the bot also knows cake
13:31:22 <dansa> she, yeah; i'm sorry :)
13:31:25 <aavogt> it's also not an answer
13:31:28 <c_wraith> > text $ intercalate "\n" cake
13:31:29 <lambdabot>   One 18.25 ounce package chocolate cake mix.
13:31:29 <lambdabot>  One can prepared coconut pecan...
13:31:32 <Twey> So, is there any work on this?
13:31:43 <lispy> ?vixen is the cake a lie?
13:31:44 <lambdabot> let's don't talk about that
13:31:59 <aavogt> use a different data structure
13:32:26 <c_wraith> oh, hey.  text output gets truncated now.  that's new.
13:32:49 <Twey> aavogt: … there's a data structure that's capable of automatically composing passes over it into a single operation?
13:33:00 <aavogt> Twey: Data.Sequence
13:33:17 <xle> Hey all.. Is there a GHC extension that would help me with messages like:     The class method `parsePageAndCommitDB'
13:33:17 <xle>     mentions none of the type variables of the class ParsedInfo p
13:33:18 <xle>     When checking the class method:
13:33:18 <xle>       parsePageAndCommitDB :: Page -> IO ()
13:33:20 <Twey> No, I don't think that Data.Sequence is capable of doing such a thing
13:33:29 <aavogt> so support your operation without requiring multiple passes
13:33:29 <Twey> More to the point, I only used lists as an example
13:33:48 <Twey> aavogt: You don't seem to be getting my question here :þ
13:33:55 <nomadmonad> which XML lib would you recommend as easiest for reading simple XML files (comparable for RSS complexity) into haskell data structures?
13:34:02 <xle> I am trying to define a typeclass method that does not have the respective type in its signature...
13:34:03 <lispy> > "hello\n/me dances"
13:34:04 <lambdabot>   "hello\n/me dances"
13:34:08 <lispy> Hmm...
13:34:14 <dobblego> xle, use a data type instead
13:34:19 <lispy> > text "hello"
13:34:20 <lambdabot>   hello
13:34:23 <mauke> xle: then how would it resolve the method?
13:34:26 <c_wraith> > text "hello\n/me dances"
13:34:27 <lambdabot>   hello
13:34:27 <lambdabot>  /me dances
13:34:32 <c_wraith> that clever space!
13:34:35 <nomadmonad> brief glancing over HXT, HaXML, HXML, libxml, wraxml and xml doesn't reveal immediate winner
13:34:38 <xle> dobblego: I am already instantiating a data type with this class
13:34:44 <lispy> Why does the first line have more spaces?
13:34:49 <mauke> /me is not an irc command
13:34:50 <c_wraith> nomadmonad: xml is the simplest of them
13:35:01 <xle> mauke: I know the current limitation.. that's why I was wondering if there were a GHC extension that i do not know of which would allow me to define things like this
13:35:01 <Twey> The problem is that if you have two operations that iterate over a given data structure, you can't compose them without severely decreasing performance over writing a whole new function that does both
13:35:10 <Twey> Which is completely contrary to the spirit of Haskell
13:35:11 <dobblego> xle, I mean, if the type variable does not appear in the signature, then it's not even suitable for a type-class; it is more suitable for newtype, data or type
13:35:12 <mauke> xle: then how would it resolve the method?
13:35:27 <dobblego> Twey, that's not a property of Haskell; it's a property of the data structure
13:35:38 <Twey> There are a couple of rewrite rules in GHC for things like map and filter, but I wanted to know if there was any work done on a general solution
13:35:49 <aavogt> @where stream-fusion
13:35:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/streams.html
13:35:50 <Twey> dobblego: Oh?
13:36:07 <xle> dobblego: This actually does make sense. The method internally calls other class methods that do have the type in their signatures.
13:36:11 <nomadmonad> c_wraith: xml's home page http://code.galois.com was not too friendly to me, so perhaps I jumped over too quickly
13:36:14 <dobblego> Twey, do not confused [] with say scala.List
13:36:27 <xle> For example:
13:36:28 <c_wraith> Twey: supercompilation is a very generic approach to that sort of thing.
13:36:32 <nomadmonad> c_wraith: do you know if there are some samples or tutorial for using it?
13:36:33 <xle> parse :: Page -> IO [p]
13:36:46 <rovar> jmcarthur, I found the problem.  Get was throwing errors because it didn't have enough bytes, while I had told that thread to throwTo the main thread, it apparently didn't function correctly in ghci
13:36:47 <dobblego> xle, it cannot possible make sense; perhaps you can produce a short example?
13:36:50 <xle> commitManyDB :: [p] -> IO ()
13:36:52 <c_wraith> nomadmonad: I don't recall any, but the API was simple enough that I got everything I needed from the docs
13:36:54 <rovar> so that function just never returned..
13:36:56 <Twey> aavogt: That's interesting
13:36:59 <xle> parsePageAndCommitDB :: Page -> IO ()
13:37:12 <jmcarthur> rovar: oh! that's no good
13:37:14 <xle> dobblego: It makes sense from a designer's point of view. I realize it doesn't make sense to the compiler, which is why it is complaining :)
13:37:21 <Twey> It seems still not to be a completely general solution to the problem, though (it still only works with certain functions), and it also only does lists
13:37:28 <dobblego> xle, no, it doesn't make sense in terms of design at all
13:37:28 <Twey> dobblego: I assure you I'm not ;)
13:37:38 <dobblego> Twey, then how is it a property of Haskell?
13:37:39 <Twey> (I don't even know what ‘scala.List’ does)
13:37:47 <Twey> It's not a property of Haskell
13:37:49 <dobblego> Twey, it's a strict, immutable list
13:38:01 <aavogt> dobblego: it's also finite
13:38:05 <Twey> How would that fuse operations on it?
13:38:05 <dobblego> right
13:38:16 <aavogt> redundancy for emphasis :)
13:38:26 <rovar> jmcarthur, the solution, or at least the way to find the problem, was to get rid of the throwTo's, which caused it to error out properly, at which point I immediately found the problem :)
13:38:35 <dobblego> we had the discussion of "does strict -> finite?" and it was not very fruitful
13:39:18 <aavogt> > repeat 1 -- as in, this list isn't really infinite?
13:39:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:39:26 <rovar> strictly, no
13:39:31 <Twey> So I guess that the answer is that nobody has yet come up with a solution to this problem?
13:39:47 <dobblego> data Pager p = [p] -> IO () :|||: Page -> IO ()
13:39:50 <dobblego> xle, ^^
13:39:56 <dobblego> Twey, what problem?
13:40:01 <Twey> You can have infinite strict lists.  Creating them just takes infinite time.  ;)
13:40:06 <Twey> dobblego: ^ read up
13:40:14 <mental> You can have infinite, strict, circular lists
13:40:26 <dobblego> Twey, your initial complaint was about Haskell, then it was determined to not be about Haskell, so...
13:40:29 <Twey> mental: But only a chunk is then strict
13:40:42 <Twey> dobblego: I never complained about Haskell…
13:40:42 <aavogt> Twey: perhaps the problems of frp (space leaks apparently?) are similar to your problem?
13:40:51 <Twey> I was just asking about a particular optimisation technique.
13:41:01 <Twey> (potential optimisation technique, that is)
13:41:02 <dobblego> <Twey> That's something I really miss in Haskell.  The lack of it seriously hurts composability.
13:41:08 <mental> I suppose if "strict" means "evaluated" then it's pretty obvious that nothing can be both strict and infinite
13:41:15 <ski> > let init xs0 = xs1 where (n,xs1) = loop xs0 (n - 1); loop [] n = (0,[]); loop (x:xs0) n0 = (n1 + 1,x:xs1) where {(n1,xs1) = loop xs0 (n0 - 1)}; loop xs n | n <= 0 = (length xs,[]) in init "abcd"
13:41:16 <lambdabot>   "abcd"
13:41:23 <Twey> dobblego: That's not the same thing.
13:41:31 <dobblego> Twey, ok
13:41:39 <rovar> mental, you can leave logic out of this
13:41:44 <rovar> we're talking about math
13:41:45 <mental> oh ok
13:41:47 <dobblego> Twey, then what? certain complexity properties about []?
13:41:49 <Twey> I miss it in Haskell mostly because Haskell emphasises composability, whereas in other languages it would be normal to write a completely new function here.
13:41:52 <rovar> :P
13:41:52 * ski hmms ..
13:41:55 <Raymond> math isn't logic?
13:42:01 <Twey> It's not a Haskell-specific problem.
13:42:11 <mental> blogic
13:42:16 <rovar> Raymond, not when problems can be too easily solved with logic
13:42:24 <Twey> dobblego: 21:34:38 < Twey> The problem is that if you have two operations that iterate over a given data structure, you can't compose them without  severely decreasing performance over writing a whole new function that does both
13:42:45 <Twey> 21:34:47 < Twey> Which is completely contrary to the spirit of Haskell
13:42:48 <Twey> 21:35:14 < Twey> There are a couple of rewrite rules in GHC for things like map and filter, but I wanted to know if there was any work done on a  general solution
13:42:54 <dobblego> Twey, map (f . g) x ?
13:43:19 <Twey> dobblego: That's a solution for map, yes
13:43:22 <c_wraith> twey: I'm pretty sure that supercompilation is still a general solution to that problem...  among others.
13:43:26 <ski> dobblego : more like `filter (liftM2 (&&) p g)', i think
13:43:35 <Twey> c_wraith: Thank you.  I'll look it up.
13:43:47 <dobblego> ok, I see that problem
13:44:16 <ski> (since in `map f . map g' it's not the same data structure which is handled by the two `map's)
13:46:30 <nomadmonad> c_wraith: this is my first library I'm going to use, so I hope I won't get too stuck with the xml library. But it seems quite straightforward. I'm sure I'll get bogged down, however. Thanks for pointing the lib out!
13:47:10 <c_wraith> nomadmonad: if you have any questions about using it, feel free to ask.  I might not respond, but someone probably will.
13:48:58 <domor> Twey: I understand you mean for example to calculate the length and maximum value of a list in one pass?
13:52:51 <Twey> domor: Yes
13:52:58 <Twey> c_wraith: That's awesome.  ☺
13:53:06 <Twey> Neil Mitchell strikes again.
13:53:19 <ski> > let init xs0 = xs1 where (n,xs1) = loop xs0 (n - 1); loop [] n = (0,xs1) where {xs1 | n <= 0 = [] | otherwise = []}; loop (x:xs0) n0 = (n1 + 1,xs1) where {(n1,xs1') = loop xs0 (n0 - 1); xs1 | n0 <= 0 = [] | otherwise = x:xs1'} in init "abcd"
13:53:20 <lambdabot>   "abc"
13:53:28 <ski> ah
13:53:34 <c_wraith> I'm not sure supercompilation fully solves the problem domor mentions...  But it at least has the potential to
13:53:47 <Twey> Aye
13:54:06 <ski> Twey : thought you wanted to calculate length, and then `take' using that length (minus one) ?
13:54:09 <Twey> Supero's fantastic
13:54:20 <Twey> ski: Yes
13:54:48 <Twey> The point is that that can be done in one pass (give or take an item, depending on how clever you can get)
13:54:49 <ski> Twey : so would you expect operational semantics similar to tha above hand-crafted version of `init' ?
13:55:06 <ski> (from a source `init xs = take (length xs - 1) xs', i.e.)
13:55:13 <Twey> I think so, yes
13:55:28 <domor> as I understand it stream fusion works when you pipe the result, eg. fold over a map over a filtered container
13:55:45 <Twey> You hand-crafted that?  I thought that was the output from something
13:55:48 <Twey> domor: Right
13:56:05 <domor> but I wonder if the compiler couldn't detect that we pass over a container more than once and merge them together under certain conditions
13:56:07 <ski> Twey : it was hand-crafted to possibly have been the output of something ;)
13:56:11 <Twey> Ah :þ
13:56:20 <Twey> domor: That's the question, yes
13:56:23 <Twey> http://docs.google.com/viewer?a=v&q=cache:h5MY3xoXAC4J:community.haskell.org/~ndm/downloads/slides-supercompilation_for_haskell-03_mar_2009.pdf+supercompilation+haskell&hl=en&gl=uk&pid=bl&srcid=ADGEESjQM-jY5u9dZMo3zphmm1M7D-3iD0VdsGoSIHC0IC5W-VmnHECpAXr4x5nsczAPlHAWrvGrmyooV5QnToNarQGSHQIISeKXJ6Thf2ec7oCoNAz8hV7Ho3RU-oHaOaEeD8aqFfYV&sig=AHIEtbR5Mx95tsmFLOmHT0Ke0DFzlv_m7Q
13:56:28 <Twey> Er, sorry
13:56:32 <ski> (hence the silly `xs1 | n <= 0 = [] | otherwise = []')
13:56:37 <Twey> http://community.haskell.org/~ndm/downloads/slides-supercompilation_for_haskell-03_mar_2009.pdf
13:56:41 <Twey> ski: Yeah :þ
13:56:46 <domor> interesting, I've wondered before as well
13:56:57 <Twey> Ooh, there's even http://hackage.haskell.org/trac/ghc/wiki/Supercompilation
13:57:31 <Twey> Yeah, this could even (theoretically?) solve the similar but related problem of ‘if length someList == 1 then …’ not terminating on infinite lists
13:58:10 <c_wraith> a lot of what supercompilation could do is purely theoretical right now, I think.
13:58:15 <c_wraith> But it's still fascinating.
13:58:42 <Twey> From the talk, it seems like ndm has a fairly good bootstrap going.
13:58:43 <ski> (Twey : btw, you've seen <http://squing.blogspot.com/2008/11/beautiful-folding.html> and <http://comonad.com/haskell/Origami.hs>, yes ?)
14:00:14 <Twey> ski: They're good part-solutions
14:00:58 <Cale> Heh, I was about to give the first of ski's links
14:01:56 <ski> Twey : *nod*
14:16:13 <ksf> how would you people implement gotos in haskell?
14:16:21 <voker57> omg
14:16:36 <copumpkin> ksf: mmorrow wrote something for that a while ago
14:16:47 <copumpkin> probably with lots of cont
14:16:47 <ceii> I can't decide if this is a good or awful question
14:16:48 <elly> goto = error "Stop that." ?
14:17:03 <ksf> I vaguely remember that BASIC edsl, but it used line numbers
14:17:06 <taruti> ksf: continuation monads ;)
14:17:21 <mle> continuations let you implement goto fairly straightforwardly
14:17:27 <copumpkin> ksf: well, goto needs a destination
14:17:28 <mle> for good or ill
14:17:32 <Donny__> hmm... simple haskell question.
14:17:38 <ksf> yep,
14:17:40 <Donny__>      (TBool, TBool) -> unify xs
14:17:42 <Donny__>      (TInt, TInt) -> unify xs
14:17:46 <BONUS> CallCC :)
14:17:49 <Donny__> Is it possible to condense those two lines into one line?
14:17:51 <ksf> I should have actually asked "how would you people implement lables"
14:17:55 <domor> the LLVM JIT package has labels and gotos
14:18:04 <Donny__> e.g. (TBool,TBool) && (TInt,TInt) ->unify xs
14:18:24 <taruti> Donny__: (x,y) | x==y -> unify xs ?
14:18:32 <ceii> Donny__: (_, _) if you d'ont have other constructors that could be matched
14:18:39 <ceii> ah yeah
14:18:47 <ceii> need the equalit
14:18:49 <ceii> -y
14:18:58 <Donny__> yep
14:20:42 <ksf> oh. Indexed Monads.
14:20:58 <Donny__> Thank you taruti , it worked like a charm.
14:21:01 <ksf> ...nope.
14:21:05 <Donny__> I am still relatively new to haskell.
14:23:33 <copumpkin> callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a, why isn't that Cont (Cont r a) (a -> Cont r b) ?
14:24:42 <copumpkin> :P
14:24:51 <bos> preflex: seen dcoutts
14:24:52 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- dcoutts was last seen on #haskell 10 hours, 12 minutes and 8 seconds ago, saying: Geheimdienst: ah, yes, that's it
14:25:18 <Berengal> ksf: You can get goto with recursive do
14:25:20 <ksf> mhhh
14:25:35 <ksf> thinking about it, I think callCC is much better.
14:25:50 <ski> @type Cont . (>>=)  -- copumpkin, why isn't this the type of ordinary `(>>=)' ?
14:25:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m a -> Cont (m b) a
14:25:52 <Berengal> But you can't jump forward with callCC, can you?
14:26:05 <ksf> well, define "forward"
14:26:33 <copumpkin> ski: not sure I understand
14:26:42 <Berengal> Yeah, that's the problem with continuations...
14:26:48 <ksf> ...you just have to capture the right amount of computation.
14:27:14 <ski> copumpkin : sorry .. just giving a silly counter-question to a silly (imo) question :)
14:27:23 <copumpkin> :)
14:27:26 <copumpkin> why is it stilly!
14:27:26 <ksf> off the top of my head, I think it's vaguely equivalent to using labled loops in java and continue and break them.
14:27:29 <copumpkin> silly, even
14:27:34 <copumpkin> it fits the Cont pattern!
14:27:41 <copumpkin> callCC is itself a continuation
14:27:46 <ski> copumpkin : the real answer re `callCC' is that it is easier to call it with the current type
14:27:47 <Berengal> ksf: I think you need to capture the continuation at one point, and send it forward to where you're jumping to and then call the old continuation with the current continuation
14:27:53 <copumpkin> :(
14:28:05 <ski> copumpkin : `(>>=)' also fits the `Cont r' pattern
14:28:13 <copumpkin> oh that's what you meant :)
14:28:22 <copumpkin> I guess it does!
14:28:33 * copumpkin amends the standard library to put Cont where Cont belongs
14:28:44 <BONUS> everywhere?
14:28:44 <ski> @src Maybe (>>=)
14:28:45 <lambdabot> (Just x) >>= k      = k x
14:28:45 <lambdabot> Nothing  >>= _      = Nothing
14:28:56 <ski> it's not for nothing the right argument is named `k', there !
14:29:12 <Cale> Yeah, that's the other case ;)
14:29:28 <ksf> you call callCC, and pass a function that takes the continuation, and some code, which then might call that continuation, or not.
14:29:33 <ksf> it's early-exit.
14:30:01 * Berengal still doesn't get how the early-exit thing works...
14:30:44 <copumpkin> Berengal: I just worked through the evaluation by hand
14:30:46 <copumpkin> it makes sense
14:30:52 <ksf> ...compare the last example in http://kerneltrap.org/node/553/2131  with the one in http://www.haskell.org/all_about_monads/html/contmonad.html
14:31:04 <Donny__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15950#a15950 <- Minor dilemma, I am sure this would be something easy but I do not quite understand the error message
14:31:05 <Cale> > runCont (callCC (\ret -> do ret 5; return 3)) id
14:31:06 <lambdabot>   5
14:31:23 <ski> (copumpkin : and, btw, it would be nicer with `ContT a (Cont r) (a -> Cont r b)')
14:31:28 <copumpkin> ski: lol
14:31:30 <Donny__> repeated variable in a pattern.
14:31:37 <Berengal> Cale: So id is the current continuation?
14:31:43 <ksf> there's a callCC block form do C to undo C, do B to undo B and do A to undo A.
14:31:50 <ksf> (each)
14:31:53 <Cale> Berengal: well, in that case, yeah
14:31:56 <copumpkin> Berengal: \ret gives you a handle to the outer continuation, so you can call it directly
14:32:16 <Cale> Berengal: Normally it would be the function from the result of the callCC, through to the result of the whole computation
14:32:18 <sshc> I'm trying to compile some code that's failing to compile, and I want to see what the type of something that was bound by "foo <- bar" is to help me find the problem
14:32:25 <ski> > runCont (liftM succ (callCC (\ret -> do ret 5; return 3))) id
14:32:27 <lambdabot>   6
14:32:31 <ksf> otoh, I heard that continuations are considered kludgy, and that we should all be using delimited ones.
14:33:01 <ski> composable continuations are nice, yes
14:33:05 <c_wraith> :t runCont
14:33:06 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
14:33:11 <Berengal> Cale: That's what I don't get about the "current" continuation... I thought the current continuation was the rest of the computation, i.e. return 3
14:33:20 <Berengal> Cale: And indeed that's how the Cont constructor works.
14:33:40 <ski> Berengal : the current continuation to `do ret 5; return 3' does not contain `return 3'
14:33:48 <Cale> Berengal: It might help to say that in languages like C, it's as if every procedure you write has been implicitly wrapped in callCC, and 'return' just calls that continuation.
14:33:54 <ksf> Berengal, the continuation of "ret 5" would be return 3, if it weren't id because it's another continuation.
14:34:18 <ksf> that is, if ret was foo or something else that hasn't been generated by callCC before.
14:34:21 <Berengal> Cale: Thinking imperatively stopped being useful a long time ago...
14:34:32 <ski> ksf : the current continuation of `ret 5' *is* `\_ -> return 3' !
14:34:36 <mental> What libraries do people use to create "plasma"-like graphical effects popular in screensavers? Blurred edges, continuous gradients of color
14:34:50 <dolio> The direct-style type of callCC is ((a -> b) -> a) -> a. The insertion of Cont r is for where the CPS transformation has altered the type.
14:34:54 <pikhq> Cale: So, Cheney on the MTA.
14:35:00 <Berengal> ksf: Okay, I get that. callCC nests the continuations one level deeper. >>= keeps everything at the same level (just composing more continuations onto eachother)
14:35:05 <ksf> ski, yes, you're right.
14:35:21 <Cale> pikhq: I don't understand.
14:35:26 <dolio> It doesn't just have Cont inserted whenever there's something that looks like "(t -> u) -> u".
14:35:49 <ski> Berengal : i'm not sure what you mean ..
14:36:08 <pikhq> Cale: It's a implementation method for Scheme that implicitly wraps everything in callCC, and just calls the next continuation instead of returning.
14:36:17 <nomadmonad> mental, I used pure assembler and just precalced sin tables, summing multiple functions to form r, g and b values and MOVed those to graphics card memory, no libs needed
14:36:35 <Berengal> ski: The callCC site is where you return to if you call its continuation
14:36:38 <pikhq> Cale: Everything is allocated on the stack, and the garbage collection consists of creating a copy of the stack with the unused objects removed from it.
14:37:07 <pikhq> And then continuing execution via longjmp.
14:38:36 <Cale> pikhq: Calling the next continuation is returning isn't it? :)
14:38:36 <Cale> (I get what you mean though :)
14:38:36 <mental> nomadmonad: that's great but what if I don't want to use assembly?
14:38:36 <ski> Cale : "Cheney on the MTA" is used by the Chicken Scheme compiler. it compiles to C code which never uses `return', always calling further. the GC then kicks in when the C stack (i.e. the Scheme heap) becomes full
14:38:36 <pikhq> Cale: http://home.pipeline.com/~hbaker1/CheneyMTA.html
14:40:30 <monochrom> http://www.vex.net/~trebla/haskell/ContMonad.lhs has examples of Cont
14:40:30 <ski> (s/C code/C code in CPS/)
14:40:30 <ski> Berengal : yes .. i was not understanding what you meant by "nests the continuations one level deeper" and "keeps everything at the same level"
14:40:30 <pikhq> Cale: It explicitly calls the next continuation instead of using the "return" keyword, rather..
14:40:30 <nomadmonad> mental, but surely one would be more intelligent these days, use open gl, generate texture maps, and map moving polygons, running multiple alpha textures on top of each other, and then finalise by operating the image by hand made pixel shaders. One lib needed.
14:40:30 <nomadmonad> mental: well, how about going through open gl path?
14:40:31 <Berengal> ski: So in that way, it sort of _is_ like a callstack...
14:40:31 <Berengal> Except you can pass the stack around, and indeed keep old versions of it...
14:41:02 <mental> hm
14:41:11 <ksf_> so, in your oppinion, which of the delcont operators are most likely to make the imperative mob salivate instead of fleeing in panic?
14:41:56 <ksf> btw, ipv6 seems down.
14:41:57 <mental> nomadmonad: interesting. I think i don't really understand the capabilities of opengl. These screensavers never look anything like "polygons in 3d"
14:43:26 <nomadmonad> mental: how about checking out the C examples and making them work in haskell + opengl starting from the simplest and progressing from there?
14:43:26 <ski> Berengal : "it" being ?
14:43:40 <nomadmonad> mental: like, http://demo-effects.sourceforge.net/  and http://nehe.gamedev.net/data/lessons/lesson.asp?lesson=29
14:44:34 <mental> nomadmonad: ooh thanks
14:49:29 <Berengal> ski: peace, politics, continuations and like stuff...
14:49:29 <dmead> hey channel
14:49:29 <mental> demos are so cool
14:50:49 <nbathum> can someone take a look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15952 and tell me what im doing wrong?
14:51:40 <dmead> what was that library called that lets you visualize your data structures
14:51:40 <dmead> it came out like last year or something
14:52:02 <int-e> nbathum: using :: instead of :
14:52:06 <ddarius> dmead: Vacuum
14:52:18 <Cale> nbathum: you can't put type signatures on patterns like that, but I don't think that's what you mean anyway
14:52:19 <Cale> nbathum: Probably you just want one :
14:53:50 <ski> (ksf : .. that objective being desirable or otherwise ?)
14:53:50 <ksf> :t runCont $ callCC $ id
14:53:50 <ksf> grrrr
14:53:50 <nbathum> Cale: argh you're right. been coding too long when i dont recognize simple typos like that
14:53:59 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
14:53:59 <lambdabot>     Probable cause: `id' is applied to too few arguments
14:53:59 <lambdabot>     In the second argument of `($)', namely `id'
14:54:00 <ksf> :t runCont (callCC $ \x -> x x ) id
14:54:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m b
14:54:00 <lambdabot>     Probable cause: `x' is applied to too few arguments
14:54:00 <lambdabot>     In the first argument of `x', namely `x'
14:54:00 <ksf> is it possible for x to escape runCont?
14:54:31 <ksf> well, I would be scared if it works.
14:55:31 * Cale_ grumbles about all the network fail
14:56:28 <ksf> otoh, when doing a monad for imperative programming, which arguably should be able to do gotos, some kind of runCont would be somewhere at the outermost layer of the program, anyway.
14:56:28 <Cale_> nbathum: did you get your question answered?
14:57:04 <nbathum> int-e: yes, someone pointed that out. however the compiler still does not like it. updated code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15954
14:57:19 <nbathum> Cale: i fixed that typo, but im still doing something wrong
14:57:46 <Cale> nbathum: ah, because the case isn't indented far enough
14:58:01 <Cale> nbathum: It needs to be at least one more space in to be part of the definition of aux c
14:58:17 <Cale> but personally, I'd have put the "case c of" on the preceding line.
14:58:17 <Berengal> ksf: ContT a (State (Map Label cont)) a, then mfix?
14:58:20 <nbathum> Cale: oh. okay thanks, that fixed it
14:58:22 * Berengal ponders the horror
14:58:34 <Cale> nbathum: or perhaps... not used case at all
15:00:28 <monochrom> We don't have mfix for Cont or ContT yet.
15:00:28 <ski> ksf : `\x -> x x' is ill-typed
15:00:28 <Raymondx> Hmm, i am being booted by Douglas?
15:00:28 <Cale> Raymondx: lots of people are having connection problems all at once.
15:00:28 <nbathum> Cale: hmm, perhaps you could show me this better way to write it?
15:00:31 <joevandyk> Why doesn't this work?  (length [1, 2, 3]) / 2
15:00:31 <ksf> Berengal, I'm not sure about labels. maybe it's a better idea to abandon goto and just use continuations directly.
15:00:32 <ksf> ...which are, after all, first class values.
15:00:47 <ddarius> ksf: Yes it is possible to return the continuation callCC provides.
15:01:31 <Berengal> continuations are gotos on steroids
15:02:23 <ksf> indeed. they're the only control structure which are still able to confuse me.
15:02:28 <ksf> ... years after I first came across them.
15:02:39 <Berengal> goto ~ setInstructionPointer, setjmp/longjmp ~ setInstructionPointer + setStackPointer, continuation ~ setInstructionPointer + setStack
15:02:39 <joevandyk_> Why doesn'member:t this work?  (length [1, 2, 3]) / 2
15:02:50 <joevandyk_> ugh.  why doesn't this work?  (length [1, 2, 3]) / 2
15:03:13 <Berengal> (+ setStackPointer)
15:03:50 <Vulpyne_> joevandyk_: Try `div` instead of /
15:03:50 <Berengal> I sort-of get continuations, but I still don't grok them completely...
15:05:37 <ski> monochrom : didn't Magnus Carlsson have some arguments why `mfix' can't be done on `Cont' ?
15:05:37 * ski might remember wrong
15:05:37 <ski> > length [1,2,3] `div` 2
15:05:37 <ski> > fromIntegral (length [1,2,3]) / 2
15:05:37 <ski> joevandyk : wait for lambdabot
15:06:09 <ski> ksf : .. you can do a recursive type ..
15:10:34 <domor> nabthum: how about http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15951#a15955
15:10:34 <domor> nbathum*
15:10:34 <domor> I think using a mapAccum and consing could be faster than the ++'s, if it matters
15:12:28 <dmead> ddarius, thanks
15:12:40 <nbathum> Cale: I don't know another way to write that function without using a case statement :(
15:15:43 <BONUS> whoa
15:16:05 <joevandyk_> Vulpyne_: why would that work?
15:16:05 <joevandyk_> Vulpyne_: and why doesn't this work?  floor $ (length [1, 2, 3]) `div` 2
15:16:18 <Vulpyne_> The IRC server is not a happy little IRC server.
15:18:45 <dmead> i'm doing a haskell workshop at the end of the month
15:18:45 <dmead> gotta find some pretty things
15:19:00 <Vulpyne_> joevandyk_: For your first question, / expects a Fractional and div expects an Integral.
15:19:00 * benmachine giggles at Success as a quit reason
15:19:00 <Cale> joevandyk_: floor doesn't apply to integral things
15:20:13 <jmcarthur> mog: just realized you're in here because i saw your nick scroll by in all the netsplits
15:21:54 <Vulpyne_> You can do: floor $ (fromIntegral $ length [1,2,3]) / 2
15:21:54 <Vulpyne_> Although you can probably just forget the floor and use div.
15:22:04 <jmcarthur> o_O Lag: 34.9 seconds
15:22:06 <nbathum> domor: oh cool, i was not aware of that function :D
15:22:08 <lambdabot>   1.5
15:22:08 <lambdabot>   1
15:22:08 <gwern> hm. I was going back through a cabal 2008 thread in which I was blamed for badly packaging drift, and I thought I'd see about fixing it, and so I pulled, and there's been no patches since :)
15:22:08 <gwern> meachem rarely modifies his software, I suppose
15:22:08 <gwern> makes it easier to maintain a fork!
15:22:10 <bo0ts__> Does anybody kow why haskell-ghci turned obsolete in emacs?
15:22:13 <bo0ts__> And what is there to replace it?
15:22:24 <bo0ts__> Besider just opening a eshell and running ghci...
15:22:29 <bo0ts__> Besides*
15:22:52 <mreh> what's the idiom for list inplace update
15:22:53 <kmc_> there is no such thing
15:22:53 <Cale> bo0ts__: you could always run ghci in a separate window :)
15:23:03 <kmc_> all values are immutable
15:23:18 <Cale> (but honestly, I don't know, I don't use emacs that often)
15:23:18 <ksf> lists aren't made for updates
15:23:18 <ksf> use Data.Sequence
15:23:18 <mreh> what's the idiom that returns a list with the Nth element changed
15:23:27 <kmc_> use Data.Sequence or an array
15:23:30 <ksf> splitAt
15:23:42 <kmc_> despite that, i do think it's a failure of the Data.List API that it doesn't provide this
15:23:51 <koeien37> length [1,2,3] `div` 2 is an Int
15:23:51 <koeien37> you can't floor Ints
15:23:51 <ski> joevandyk_ : `div' is integral division, `floor' doesn't work on integers
15:23:51 <mreh> it's not supposed to be a general solution, I just want to change a short list that comes from a library
15:23:51 <ksf> I don't think so.
15:23:51 <bo0ts__> Cale: That's not considered a solution for an emacs user ;>
15:23:51 <bo0ts__> "What? I have to leave emacs to do that? That sucks!"
15:24:22 <ksf> it's mindboggingly unperformant, so it shouldn't be there.
15:24:22 <Cale> mreh: Change datastructures, probably, or split the list using splitAt
15:24:50 <Cale> mreh: but note that splitAt n is O(n) and xs ++ ys is O(length xs)
15:24:50 <jmcarthur> i'm on the latest haskell-mode that i know of and the ghci minor mode works fine for me
15:24:50 <mreh> it's the minor scale, and I want to add one to the 6th element
15:24:53 <kmc_> :t \n v -> uncurry (++) . second ((v:) . tail) . splitAt n
15:24:53 <lambdabot> forall a. Int -> a -> [a] -> [a]
15:24:55 <kmc_> ksf, so is (++)
15:24:56 <kmc_> and Data.List.intersect etc.
15:24:56 <ksf> > let l ?! n x = { let (h, t) = splitAt n l in h ++ [x] ++ tail t } in "foo" ?! 2 u
15:24:56 <copumpkin> bos: what's broken about kqueue on osx?
15:24:56 <lambdabot>   <no location info>: parse error on input `{'
15:24:56 * hackagebot upload: boomslang 0.0.2 - Boomshine clone (BrianLewis)
15:24:59 <ksf> > let l ?! n x =  let (h, t) = splitAt n l in h ++ [x] ++ tail t  in "foo" ?! 2 u
15:24:59 <lambdabot>   <no location info>: Parse error in pattern
15:24:59 <ksf> > let !!! l n x =  let (h, t) = splitAt n l in h ++ [x] ++ tail t  in "foo" !!! 2 u
15:24:59 <lambdabot>   <no location info>: parse error on input `!!!'
15:24:59 <ksf> > let bar l n x =  let (h, t) = splitAt n l in h ++ [x] ++ tail t  in bar "foo" 2 u
15:24:59 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:24:59 <lambdabot>         against inferred type...
15:25:03 <mreh> I THINK THERE WAS A NETSPLIT!!!
15:25:07 <ksf> :t splitAt
15:25:09 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:25:11 <kmc_> THERE WAS A FIREFIGHT!
15:29:33 <ksf> bo0ts__, maybe you should just accept the fact that emacs isn't a good operating system.
15:29:41 <ksf> hell it doesn't even have a decent terminal, much less a decent editor.
15:29:41 * gwern looks at the drift driver shell script
15:29:41 <gwern> ksf: it beats other OSs all hollow
15:29:41 <gwern> just the docs alone!
15:30:33 <ski> @botsnack
15:30:34 <lunabot>  :o
15:30:34 <Vulpyne_> forall a. Internets a => HappyChannel a -> [SadChannel a]
15:30:34 <bos> copumpkin: it doesn't work against plain files!
15:30:34 <gwern> holy christ I don't enjoy parsing shell scripts metaprogrammed by makescripts
15:30:45 <Vulpyne_> How dare you say such a thing!
15:31:48 <lispy> yay for the new haskell-src-exts!
15:31:48 <lambdabot> :)
15:32:22 <gwern> and oh right, it used the -pgmF ghc option
15:32:26 <Berengal> bo0ts__: Sure it's obsolete? I'm using it just fine...
15:32:34 <gwern> I sometimes wonder whether anyone actually uses that in a non-evil way
15:32:57 <ski> mreh : maybe you want zippers ?
15:35:22 <gwern>     echo @bindir@/DrIFT "$2" -o "$3";
15:35:22 * ksf still thinks Seq should be the more prominent sequence type, if not the default.
15:35:22 <Berengal> ksf: Emacs is an operatOR system
15:35:22 <gwern> wtf, echo doesn't have a -o option!
15:35:28 <gwern> the metaprogrammed shell script is itself metaprogramming
15:35:49 <solidsnack> ksf: Why is that?
15:35:58 <solidsnack> Is sequence finite?
15:36:10 <gwern> solidsnack: sure is
15:36:41 <solidsnack> I think it might be best overall if `[' and `]' were overloaded.
15:36:49 <ski> @let (!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]; (as !!<- i) f = front ++ f a : back where (front,a:back) = splitAt i as
15:36:50 <lambdabot>  <local>:6:120:
15:36:50 <lambdabot>      Couldn't match expected type `Int' against inferred type...
15:39:40 <ddarius> So much crap to read
15:40:24 <bo0ts__> Berengal: Hm, I just looked at the source of haskell-mode.el. They say it is. C-c C-l is still working fine... Confusing...
15:40:34 <benmachine> haskell-src-exts' darcs log makes references to bug/FR numbers, but I can't find a corresponding tracket
15:40:39 <benmachine> *tracker
15:40:41 <bo0ts__> Berengal: http://code.haskell.org/haskellmode-emacs/haskell-mode.el
15:40:42 <benmachine> anyone have any ideas?
15:42:13 <sm> is there a simple way to repair all broken packages, after --force unregister-ing some old versions ?
15:44:59 <ski> (.. such as ?)
15:46:44 <ski> @let (!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]; (as !!<- i) f = front ++ f a : back where (front,a:back) = genericSplitAt i as
15:46:46 <lambdabot>  Defined.
15:47:03 <sm> heh, here's one way: for f in `ghc-pkg check --simple-output`; do ghc-pkg unregister $f; done
15:47:24 <ksf> oh.
15:47:33 <ksf> rm -r ~/.cabal ~/.ghc
15:47:43 <LordRawK> didnt realize warez rooms existed
15:48:03 <ksf> that's good, because they, in fact, do not exist.
15:48:07 <ski> > [[0,1,2,3],[4,5,6],[7,8],[9],[]] !!<- 1 $ \as -> as !!<- 2 $ \a -> a*a
15:48:12 <lambdabot>   [[0,1,2,3],[4,5,36],[7,8],[9],[]]
15:48:12 <LordRawK> lol
15:48:12 <ksf> so you still have connection to reality.
15:49:02 <tensorpu`> warez rooms might exist on networks that aren't freenode
15:50:12 <domor> emacs has quite a nice IRC client (M-x erc). having GHCi and #haskell right there really makes for interactive coding.
15:51:31 <tensorpu`> heh, yeah
15:51:52 <tensorpu`> you can yank code posted on irc and put it into ghci
15:51:52 <tensorpu`> or vice-versa
15:53:36 <domor> there's a name highlighting plugin too, really makes following conversations easier
15:58:59 <ksf> yeah, especially if kmc is around.
15:59:20 <ksf> the best irc conversations happen if noone is writing for anyone specific but to the whole room, and if everyone completely disregards from what nick messages come.
15:59:25 <RAWR> hi anyone know how to hack?
15:59:25 <ksf> just react to what's written.
15:59:35 <RAWR> can u help me?
15:59:43 <RAWR> can u help me?
15:59:47 <aavogt> hackskell
15:59:56 <ksf> RAWR, you might want to consult a woodpecker.
16:00:07 <monochrom> ksf: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6073#a6073 continuation escapes
16:00:10 <aavogt> lumberjack?
16:00:13 <Cale> RAWR: If by "hack" you mean "write haskell code", then yes.
16:01:17 <ksf> if that fails, stand on one leg for two years straight, citing the original lambda papers in pig-latin.
16:02:26 <RAWR> can someone hack habbo.com an make a account an get lots of items or coins plz an ty an give accoutn to me if u want plz
16:02:26 <Badger> I love the names people use in here
16:02:26 <kw317> lol?
16:02:26 * Badger just looked in and saw < Cale> RAWR
16:02:26 <RAWR> plz an ty
16:02:26 <RAWR> :d
16:02:26 <ksf> after that, come back for instructions and your initiation as adept.
16:02:45 <ksf> @ops
16:02:45 <Cale> RAWR: We don't do that sort of thing around here. We write programs in the functional programming language Haskell.
16:02:45 <lambdabot> Maybe you meant: docs oeis pl
16:02:48 <ksf> @where ops
16:02:48 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
16:02:55 <RAWR> o =/
16:03:04 <Cale> ksf: (I'm an op)
16:03:16 <ksf> yeah, I noticed.
16:03:36 <ksf> He's just so stereotypical, he must be a troll.
16:04:15 <Cale> RAWR: If you're interested in learning to program in Haskell though, we'd be happy to help with that.
16:04:17 <inimino> @faq can Haskell break into my ex's computer for ethically questionable reasons?
16:04:17 <lambdabot> The answer is: Yes! Haskell can do that.
16:04:28 <djahandarie> LOL
16:04:42 <RAWR> nah idk how to hack or do stuff like that im 14 :o
16:04:58 <tensorpudding> i'm 14 and what is this?
16:05:00 <RAWR> i tried cheat engine an couldent get it
16:05:04 <ksf> back when I was 14, I already knew how to hack.
16:05:08 <RAWR> XD
16:05:17 <RAWR> well i dont hack often -.-
16:05:18 <sproingie> RAWR: you speak as if anyone could possibly be interested in your drivel
16:05:20 <ski> RAWR : you should start by learning haskell ..
16:05:43 <djahandarie> RAWR, if you hack with Haskell, no one will know what the hell you are doing except you!
16:05:43 <ksf> I deeply grokked lego at the tender age of 6, and modified my first safegames with 8 or so.
16:07:16 <RAWR> agh it hink i got someone that mite no how to hack
16:07:21 <ksf> at some point, though, hacking games isn't fun, anymore. you get a brief satisfaction by doing it, and miss all the fun the game itself is meant to be if you don't exert self-discipline.
16:07:41 <mauke> RAWR: I'd start with learning how to write English
16:07:46 <ksf> hacking something is easy. my math prof termed it "solving by staring"
16:08:00 <RAWR> -.-
16:08:00 <mental> ksf: exactly! It's as if in real life you suddenly became incredibly rich and powerful.
16:08:04 <RAWR> im from florida
16:08:07 <copumpkin> RAWR: I'd start with learning how to write cuneiform, myself. Mauke makes a good point but I think cuneiform is more important.
16:08:16 <mauke> RAWR: that's no reason to give up
16:08:22 <tensorpudding> i want to learn some cuneiform
16:08:24 <Cale> RAWR: In which case English is probably your first language, so you have no excuse :P
16:08:30 <tensorpudding> does emacs have a cuneiform input mode?
16:08:32 <mental> RAWR: it's ok, even people from Florida can learn English
16:08:34 <hatds> is there a "haskell 2010 report" on the web somewhere?
16:08:35 <RAWR> yes i kno im just typing fast
16:08:36 <RAWR> geesh
16:08:37 <copumpkin> RAWR: "hacking" as seen in movies is nothing like the real thing, and you can't just "do it"
16:08:37 <sproingie> oh for gods sake
16:08:38 <tensorpudding> and can i output to stone tablets?
16:08:38 <RAWR> =/
16:08:45 <djahandarie> copumpkin, right, always start from scratch!
16:08:45 <RAWR> i kno
16:08:50 <RAWR> thats why im not doing it
16:08:51 <RAWR> lol
16:08:52 <RAWR> XD
16:08:57 <RAWR> im geting someone to do it
16:09:03 <mauke> RAWR: it's spelt "know"
16:09:03 <copumpkin> RAWR: no you aren't
16:09:07 <ksf> so you want to engage in social engineering.
16:09:09 <RAWR> cus idk how 1 2 i got the cheat engine an it wont work
16:09:14 <ksf> arguably, you are failing, miserably.
16:09:21 <tensorpudding> phishing is much easier than hacking anyway
16:09:30 <aavogt> fishing
16:09:32 <djahandarie> tensorpudding, depends how big the fish is!
16:09:38 <LordRawK> phucking is more fun
16:09:45 <tensorpudding> phreaking?
16:09:46 <djahandarie> I like fscking peronsally
16:09:47 <jmcarthur> RAWR: i can hak dude if u have like $200 4 me
16:09:48 <ksf> LordRawK++
16:09:48 <Mr_Awesome> mauke: it's spelled "spelled". (i'm kidding of course.)
16:09:55 <copumpkin> anyway, let's stop all this
16:09:55 <copumpkin> and get back to haskell
16:09:58 <tensorpudding> i used to read 2600
16:10:02 <Polarina> :D
16:10:10 <copumpkin> jmcarthur: i hak u cuz im l33t so ph33r m3
16:10:21 <jmcarthur> ima real haker i go 2 2600 every month
16:10:24 * copumpkin = wurld-famouz hax0r
16:10:43 <ksf> preflex, nickometer RAWR
16:10:43 <raichoo> copumpkin: f0 r337?
16:10:44 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- RAWR is 69% lame
16:10:53 <LordRawK> what phone booths do you use
16:11:02 <copumpkin> raichoo: f0 sh1zz13 my n1zz13
16:11:09 <jmcarthur> why is preflex doing notifies?
16:11:21 <aavogt> mauke likes it that way
16:11:27 <jmcarthur> well i don't
16:11:31 <copumpkin> mauke's a pervert
16:11:36 <djahandarie> Didn't lambdabot have a function for this
16:11:44 <djahandarie> @leet leet
16:11:44 <lambdabot>   Parse error: SemiColon
16:11:47 <aavogt> @leet oheyah
16:11:48 <lambdabot>   Parse error: SemiColon
16:11:49 <mauke> jmcarthur: is your client stupid?
16:11:51 <djahandarie> ...
16:11:56 <djahandarie> Parse error \o/
16:12:00 <aavogt> @eliteoheyah
16:12:00 <lambdabot> Unknown command, try @list
16:12:03 <aavogt> @elite oheyah
16:12:03 <lambdabot> OHEy4h
16:12:06 <djahandarie> Ah
16:12:18 <jmcarthur> mauke: weechat puts it into buffer 1
16:12:19 <djahandarie> @elite Haskell ftw
16:12:23 <ksf>  @leet is @let after distance editing
16:12:24 <lambdabot> h4zkeL| phTW
16:12:34 <ski> @. elite run hax
16:12:36 <lambdabot> let'5 STOP +A1xInG IN |-|AxoR-$pe4C|-|, oK ?
16:12:43 <mauke> jmcarthur: can that be fixed somehow?
16:12:49 <augustss> howdy
16:12:49 <lambdabot> augustss: You have 3 new messages. '/msg lambdabot @messages' to read them.
16:12:55 <aavogt> it should probably have an alias
16:12:55 <aavogt> @vixen I guess you're just not 1337 enough?
16:12:57 <lambdabot> is that really what you want to know?
16:13:12 <copumpkin> omg augustss is back!
16:13:21 <copumpkin> preflex: seenbeforenow augustss
16:13:24 <copumpkin> :(
16:13:34 <ski> jmcarthur : bots are supposed to respond with notices
16:13:38 * aavogt is awkward
16:13:51 <inimino> jmcarthur: well hack it and fix it yourself
16:13:51 <augustss> I never left, I just took a break. :)
16:14:20 <jmcarthur> ski: really? i made a bot once and everybody in the channel complained that i used notices
16:14:35 <jmcarthur> not #haskell, i mean a different channel
16:14:36 <copumpkin> were you using notices to spread porn and shock sites?
16:14:42 <jmcarthur> absolutely not
16:14:44 <ski> jmcarthur : yes, because their clients probly were broken
16:14:56 <jmcarthur> ski: what clients are not broken?
16:15:04 <tensorpudding> hey, both #math and #haskell are arguing about bots
16:15:22 <ddarius> tensorpudding: That's what people do on IRC.
16:15:26 <ksf> probably memetic induction.
16:15:32 <tensorpudding> by the way, lambdabot was parked in #math again
16:15:51 <ski> irssi appears to not highlight on notices .. possibly others as well, i haven't really checked
16:16:12 <mauke> the notice thing is supposed to be fixed in weechat 2.7, according to this one page
16:16:15 <ddarius> xchat doesn't do anything particularly unusual or annoying.
16:16:24 <copumpkin> tensorpudding: did someone give it a ticket?
16:16:39 <tensorpudding> no
16:16:43 <jmcarthur> preflex: nickometer jmcarthur
16:16:43 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- jmcarthur is 0% lame
16:16:44 <tensorpudding> but it was devoiced
16:18:07 * ddarius reads about category theory applied to relational database theory.
16:18:29 <copumpkin> ddarius: the simplicial database thing?
16:18:36 <djahandarie> ddarius, link?
16:18:37 <ddarius> copumpkin: Yep.
16:19:18 <ddarius> djahandarie: http://lambda-the-ultimate.org/node/3761
16:19:32 <djahandarie> Thanks. :D
16:19:46 <djahandarie> God damn Freenode...
16:19:55 <mreh> what is an ircds?
16:20:27 <mreh> how can you "attract" a software "bug"?
16:20:27 <raichoo> Oh boy why do people just stick with irc rather than xmpp :/
16:20:28 <joevandyk_> anyone got any suggestions on how i can improve this function?  http://github.com/joevandyk/haskell/raw/master/pearls/binary_search/binary_search.hs
16:20:31 <mreh> where am I?!
16:21:03 <mauke> joevandyk_: use linear search instead of binary search
16:21:08 <mauke> it will be tons faster
16:21:12 <joevandyk_> mauke: thats' not the point
16:22:24 <ski> mreh : probably plural of "ircd" ("irc" daemon or something like that)
16:22:49 <ksf> zomg
16:23:02 <ksf> no, don't cease to use binary lookup
16:23:14 <ddarius> mauke: heh, yay length
16:23:17 <ksf> instead, have a look at the comibned complexities of your operations.
16:23:33 <copumpkin> yay binary lookup on a list
16:23:37 <copumpkin> with !!
16:23:39 <copumpkin> sounds awesome
16:23:54 <ksf> ...in short, if you want to do the lookup in code, use a O(1) access structure, like an array.
16:24:04 <ksf> even better, convert the list to a binary tree.
16:25:41 * ddarius wonders what the complexity of this binary search is but not enough to calculate it himself.
16:25:55 <ksf> joevandyk_, in the end, doing it like this will be the fastest: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12290
16:26:17 <ksf> 1) convert the list to a binary tree 2) convert the binary tree to a chain of if elses 3) run the code
16:26:37 <joevandyk_> ksf: i'm not worried about speed.  i'm trying to convert the algorithm to idiomatic haskell.
16:26:53 <syntaxglitch> Using !! is rarely idiomatic
16:27:02 <ksf> ...well, have a look at prepare and lookup.
16:27:02 <Draconx|Laptop> joevandyk_, binary search on a list is not idiomatic.
16:27:03 <ddarius> Idiomatic Haskell involves not treating lists as random access arrays.
16:27:20 <joevandyk_> so step 1 is to use an array, not a list
16:27:26 <copumpkin> or a tree
16:27:37 <copumpkin> arrays aren't terribly functional
16:27:37 <syntaxglitch> Doing anything with a cons list that isn't sequential strikes me as unidiomatic in any language that uses cons lists
16:27:45 <ksf> not really. an array won't be faster than a binary tree, I've tried it.
16:28:06 <ksf> ...and succeeded in introducing four off-by-one errors in four lines of code.
16:28:13 <ksf> er three lines of code
16:28:16 <copumpkin> maybe you just fail :)
16:28:28 <copumpkin> but probably not
16:28:59 <syntaxglitch> If you can get that many off-by-one errors into that many lines of code, you're either doing it deliberately or using a very wrong algorithm
16:29:23 <ksf> ...well, after being pushed back into awareness of the problem, I coded that chunk of TH in the paste without any off-by one error.
16:29:31 <ksf> instead, I messed up the buffer size.
16:30:02 <ksf> syntaxglitch, nope, I just wasn't doing any imperative programming for a cople of years.
16:31:08 <syntaxglitch> Well, I could say something about imperative programming being "a very wrong algorithm" but it does pay my bills so... :(
16:31:42 <tensorpudding> without imperative programming, we wouldn't be able to implement a functional language
16:31:54 <aavogt> syntaxglitch: some people pay bills with other very wrong things?
16:32:34 <j4cbo> the processors we have more or less run imperative code, so things have to get translated somehow
16:32:41 <copumpkin> nuh uh
16:32:43 <augustss> tensorpudding: unless we had a very different kind of computer
16:32:44 <j4cbo> one could argue that this is a failing of the hardware guys :P
16:32:50 <tensorpudding> augustss: yes, of course
16:32:51 <elly> j4cbo: fix it already
16:33:02 <tensorpudding> but so long as you're using the von neumann architecture i'm not sure how you'd get around that
16:33:03 <j4cbo> elly: hey, i switched from ECE to CS
16:33:06 <copumpkin> without imperative code, we'd have had more of these http://en.wikipedia.org/wiki/Lisp_machine and http://www.cs.york.ac.uk/fp/reduceron/
16:33:06 <elly> fix it
16:33:28 * augustss has programmed a functional machine.  Kind of.
16:33:30 <aavogt> tensorpudding: without electronics we wouldn't have programming... I don't see people emphasizing voltages etc. in their code
16:33:38 <augustss> An analog computer.
16:33:59 <syntaxglitch> we need machines that are natively pure functional, no side effects
16:34:00 <tensorpudding> you could make a computer using pneumatics
16:34:08 <p_l> ants
16:34:41 <Cale> Even digital computers are designed in accordance with physical principles that are usually described in a declarative fashion using differential equations
16:34:50 * aavogt says it's as natural to abstract the sequentialness as it is to abstract the mechanism that is actually used
16:34:52 <Badger> ants are finnicky though. one deviant and you end up with a Blue Queen of Death
16:34:58 * ski has played a little with pneumatic "circuits"
16:35:12 <syntaxglitch> tensorpudding, not so much could as it's been done
16:35:26 <syntaxglitch> In a simple fashion, at least
16:35:29 <syntaxglitch> cf. http://en.wikipedia.org/wiki/Fluidics
16:36:34 <ksf> joevandyk_, if you're busy grokking that code, I suggest you put ann, build and acc to the top level and call them seperately with ghci
16:37:43 <ksf> the lookup is really simple after the tree is converted: just recurse down the left or right branch, depending on what's in the node.
16:38:43 <ksf> ...build builds a binary tree out of the list, with labels and values at the bottom nodes, and then ann bubbles them up to the root
16:41:47 <ksf> oh, and http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12187  is the same thing but without all that template haskell stuff.
16:41:47 <ksf> #haskell be my witness that that is ideomatic haskell
16:41:47 <lunabot>  luna: Not in scope: `haskell'
16:41:47 <ski> hehe
16:41:47 <Cale> ahaha
16:41:47 <ksf> (except the abdominal way writeFasta is implemented, but that was dons, and I sure as hell don't know why it's faster than using lazy bytestrings)
16:41:47 <ksf> (what's for sure though is that only dons could make something faster that he failed to make fast enough in the first place)
16:42:44 <CESSMASTER> what an abdominal implementation
16:42:44 <CESSMASTER> it turns my stomach
16:42:44 <ksf> @wn abdomination
16:44:03 <lambdabot> No match for "abdomination".
16:44:03 <CESSMASTER> @wn abomination
16:44:03 <lambdabot> *** "abomination" wn "WordNet (r) 2.0"
16:44:03 <lambdabot> abomination
16:44:03 <lambdabot>      n 1: a person who is loathsome or disgusting
16:44:03 <lambdabot>      2: hate coupled with disgust [syn: {abhorrence}, {detestation},
16:44:03 <lambdabot>          {execration}, {loathing}, {odium}]
16:44:03 <lambdabot> [3 @more lines]
16:44:03 <CESSMASTER> @wn abdomen
16:44:03 <lambdabot> *** "abdomen" wn "WordNet (r) 2.0"
16:44:03 <lambdabot> abdomen
16:44:03 <lambdabot>      n 1: the region of the body of a vertebrate between the thorax
16:44:03 <lambdabot>           and the pelvis [syn: {venter}, {stomach}, {belly}]
16:44:03 <lambdabot>      2: the cavity containing the major viscera; in mammals it is
16:44:03 <lambdabot>         separated from the thorax by the diaphragm [syn: {abdominal
16:44:03 <lambdabot> Plugin `dict' failed with: thread killed
16:44:03 <ksf> heck. yes.
16:44:03 <aavogt> @wn abomen
16:44:03 <lambdabot> No match for "abomen".
16:44:03 <ksf> the term I usually use is "atrocious", actually.
16:44:03 <ski> @wn abo
16:44:04 <lambdabot> *** "Abo" wn "WordNet (r) 2.0"
16:44:04 <lambdabot> Abo
16:44:04 <lambdabot>      n : a dark-skinned member of a race of people living in
16:44:04 <lambdabot>          Australia when Europeans arrived [syn: {Aborigine}, {Aboriginal},
16:44:04 <lambdabot>           {native Australian}, {Australian Aborigine}]
16:44:07 <c_wraith> @wn abdication
16:44:07 <lambdabot> *** "abdication" wn "WordNet (r) 2.0"
16:44:08 <lambdabot> abdication
16:44:10 <lambdabot>      n 1: a formal resignation and renunciation of powers [syn: {stepping
16:44:14 <lambdabot>           down}]
16:44:14 <lambdabot>      2: the act of abdicating [syn: {stepping down}]
16:45:58 <Polarina> Is there something to foldl like mapM is to map?
16:46:09 <Cale> foldM
16:46:15 <Polarina> Thanks.
16:46:29 <Polarina> In what module?
16:46:32 <Cale> Control.Monad
16:46:33 <aavogt> @index foldlM
16:46:34 <lambdabot> bzzt
16:46:45 <Cale> @index foldM
16:46:45 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
16:46:51 <mreh> what does the "try" do in Parsec?
16:46:55 <copumpkin> it tries
16:47:03 <syntaxglitch> And consumes no input on failure
16:47:03 <aavogt> mreh: introduces backtracking
16:47:23 <Cale> mreh: Makes it so that a parser which fails behaves as if it succeeded in eating no characters when it failed.
16:47:41 <Cale> (so that another option will be tried)
16:47:48 <monochrom> Example.  string "xyz" <|> string "xxx"  will never hit the xxx case.  try (string "xyz") <|> string "xxx"  will.
16:47:54 <mreh> why not use <|> in that case?
16:48:00 <ski> `try' makes a parser try harder to behave as it ought to
16:48:04 <syntaxglitch> Because <|> doesn't work if it accepts any tokens
16:48:05 <Cale> mreh: try is often used with <|>
16:48:18 <monochrom> See my example.
16:48:20 <ksf> ...only in parsec, though, due to how parsec is implemented.
16:48:23 <mreh> is it because the first Parser eated an "x"
16:48:29 <monochrom> > parseTest
16:48:29 <ksf> mreh, yes
16:48:30 <lambdabot>   Not in scope: `parseTest'
16:48:41 <syntaxglitch> Once a parser accepts anything Parsec is committed to it, even if it fails later
16:48:42 <monochrom> Oh well can't demonstrate right here.
16:49:00 <aavogt> > parse
16:49:02 <lambdabot>   Not in scope: `parse'
16:49:39 <syntaxglitch> I think the idea is that backtracking after a partial match is slow and awkward, so Parsec forces you to explicitly tell it where you're willing to do so
16:49:48 <ski> @type Text.ParserCombinators.Parsec.Prim.parse
16:49:49 <lambdabot> forall t s a. (Text.Parsec.Prim.Stream s Identity t) => Text.Parsec.Prim.Parsec s () a -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
16:50:00 <Cale> @type Text.Parsec.Prim.parse
16:50:01 <lambdabot> forall t s a. (Text.Parsec.Prim.Stream s Identity t) => Text.Parsec.Prim.Parsec s () a -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
16:50:13 <monochrom> syntaxglitch is right.
16:50:25 <Cale> (the long module path is deprecated)
16:50:57 <mreh> your last Parser in a list of disjunctions (<|>) why might that need a try?
16:51:00 <Polarina> How does foldM work?
16:51:26 <c_wraith> like any other fold, but with a bit more <-
16:51:29 <Polarina> Like, how do I update a and do an IO action.
16:51:31 <mreh> Polarina, if you understand Monads then you can figure it out from the type signature pretty quickly
16:51:32 <hatds> :t foldM
16:51:34 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:51:42 <Polarina> mreh: That's the issue..
16:52:08 <ski> @src foldM
16:52:09 <lambdabot> foldM _ a []     = return a
16:52:09 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
16:52:33 <Polarina> What's that?
16:52:40 <syntaxglitch> Polarina, a good learning exercise with something like foldM is to try and write a function yourself that "performs a fold" and has the same type signature
16:52:55 <Polarina> syntaxglitch: That's the issue.
16:52:58 <monochrom> mreh: The last one doesn't need try if you are sure it is last. OTOH you are never sure.
16:52:59 <augustss> Why isn't foldM named foldlM?
16:53:12 <ski> it ought to be ..
16:53:13 <copumpkin> augustss: it uses the one true fold!
16:53:17 <augustss> I can never remember which way it folds
16:53:25 <copumpkin> ;)
16:53:28 <aavogt> @hoogle foldlM
16:53:29 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
16:53:35 <aavogt> @hoogle foldrM
16:53:35 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
16:54:21 <mreh> monochrom, it might eat part of something that I'm trying to parse afterwards?
16:54:32 <mreh> it it fails
16:54:35 <mreh> if it fails*
16:54:46 <ski> hm .. is `try (try a <|> b) <|> c = try a <|> try b <|> c' ?
16:55:44 <syntaxglitch> mreh, just think of the entire list of parsers combined with <|> as itself a single parser
16:55:45 <monochrom> mreh: Suppose you define «p0 = string "xx" <|> string "yy"». That is fine and cool. As long as you don't one day decide to call «p0 <|> string "yz"».
16:56:08 <syntaxglitch> If the composite parser eats input and fails, it works just like anything else
16:56:48 <ski> monochrom : but `try p0 <|> string "yz"' should be fine, yes ?
16:56:54 <monochrom> Yes.
16:58:10 <kmc> re "foldlM", left-to-right sequencing of actions is implicit in most of the relevant Control.Monad combinators
16:58:16 <monochrom> You effective choose between «every time I compose x and y I need to know their internals» and «every time I compose x and y I just compose».
16:58:23 <kmc> it'd be weird to fold rtl but sequence actions ltr
16:59:36 <syntaxglitch> monochrom, I found it conceptually simpler to always think of any composite parser as a black-box unit
17:00:24 <ddarius> The actions occur left-to-right because one traverses cons lists left-to-right.
17:00:56 <Polarina> I am trying to use foldM_, but I need to both perform an IO() action (putStrLn) and update a. How can I do that.
17:00:58 <syntaxglitch> e.g., only having things use "try" where it makes sense internally, if that means it may consume input and fail then I'd put a try on the whole composite when using it elsewhere
17:01:00 <Polarina> ?
17:01:13 <kmc> :t foldM_
17:01:15 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()
17:01:29 <kmc> Polarina:   putStrLn "foo" >> return newValueOfA
17:01:36 <Polarina> kmc: What's that?
17:01:39 <kmc> or equivalently, do { putStrLn "foo"; return newValueOfA }
17:01:42 <kmc> it's an expression
17:01:44 <kmc> of type IO a
17:01:49 <Polarina> Oh, weird.
17:01:51 <Polarina> Thanks.
17:01:53 <kmc> why is that weird?
17:01:56 <kmc> >> is an infix operator
17:02:04 <Polarina> Because I see no logical explanation on why that works.
17:02:05 <kmc> putStrLn and return are functions
17:02:09 <syntaxglitch> I don't think foldM_ helps, doesn't Polarina want to keep the result?
17:02:20 <Polarina> syntaxglitch: Only while it's folding.
17:02:24 <kmc> Polarina, it works because of how >> and return are defined
17:02:28 <Cale> foldM_ (\a b -> do print (a,b); return (a+b)) 0 [1..10]
17:02:30 <syntaxglitch> ah, okay
17:02:30 <Polarina> kmc: Ok, thanks.
17:02:39 <kmc> (return x) gives you an IO action that does no IO, but produces a result x
17:02:53 <kmc> (a >> b) for two IO actions a,b gives you an IO action that performs both sub-actions, and produces the same result as b
17:04:22 <Polarina> kmc: Thanks. :)
17:04:28 <Polarina> kmc: That explained everything. :D
17:05:05 <syntaxglitch> Is it a bad habit to preferentially write monadic code using infix combinators (including the applicative functor operators) and pointless-style functions?
17:05:21 <Polarina> syntaxglitch: Does it look pretty?
17:05:47 * ski . o O ( `Monad m => (a -> r -> m r) -> r -> [a] -> m [r]' or `Monad m => (a -> r -> m r) -> m r -> [a] -> m [r]' ? )
17:06:02 <syntaxglitch> It's fun, but not always more readable...
17:06:16 <Polarina> syntaxglitch: Does it look pretty or not?
17:06:34 <syntaxglitch> If punctuation is pretty, then... yes
17:06:53 <Polarina> syntaxglitch: Then it's all right.
17:07:02 <Polarina> syntaxglitch: If it's not pretty, it's a bad habbit.
17:11:12 <Berengal> I sometimes tend to batch up monadic actions with the various point-free combinators around...
17:13:37 <syntaxglitch> I've been hacking on some stuff using parsec recently and found that strategic use of >>=, <$>, <*>, and whatnot often turned 3-5 line parsers into mostly readable one-liners
17:14:22 <syntaxglitch> But trying to do the same elsewhere has more often led to a mess of infix garbage that I couldn't make sense of five minutes later :(
17:14:29 <dolio> <$ <* and *> are good, too.
17:16:38 <monochrom> @type (<*>)
17:16:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:17:10 <ski> (.. now if only they had sensible names)
17:18:03 <monochrom> @type fmap (+)
17:18:04 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
17:18:30 <monochrom> > (+) <$> [2] <*> [3]
17:18:32 <lambdabot>   [5]
17:19:13 <tensorpudding> fmap fmap fmap fmap
17:19:20 <syntaxglitch> coming up with sensible names is hard for very abstract higher-order functions
17:19:25 <kmc> :t fmap fmap fmap fmap
17:19:27 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
17:20:01 <monochrom> I should do that more. AppTerm <$> parseTerm <*> parseTerm
17:20:08 <ski> i suppose when i say "sensible", i really mean "not misleading (imho)"
17:20:11 <cobol000> where to look up all those operators?
17:20:27 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/
17:20:28 <monochrom> (is better than do { x<-parseTerm; y<-parseTerm; return (AppTerm x y) }
17:20:30 <kmc> @where hoogle
17:20:30 <lambdabot> http://haskell.org/hoogle
17:20:56 <syntaxglitch> monochrom, very much agreed
17:21:04 <syntaxglitch> ski, misleading how?
17:22:11 <ski> syntaxglitch : the name `<*>' to me suggests that the operator is symmetric, at least up to commutative monads/applicatives
17:22:21 <syntaxglitch> ah
17:23:02 <phr> does anyone know if something is wrong with the "period" operator in atom 0.1.4 ?
17:23:33 <ski> phr : what do you mean by "atom" ?
17:23:48 <ski> > 0.1.4
17:23:50 <lambdabot>   No instance for (GHC.Show.Show (f b))
17:23:50 <lambdabot>    arising from a use of `M7255540593...
17:23:50 <syntaxglitch> ski, I've stopped assuming that any infix operator with three or more characters has any obvious meaning based on its appearance
17:23:55 <phr> http://hackage.haskell.org/package/atom
17:23:56 <phr> ski
17:25:15 <ski> (syntaxglitch : i'd prefer symmetric operator names for symmetric operators, and at least assymetric operator names for assymetric operators)
17:26:16 <ski> phr : is "atom" a function somewhere in this library ?
17:26:35 <syntaxglitch> ski, that would be nice, yes
17:27:33 <ski> phr : .. oh, that "0.1.4" was a version of the package
17:27:42 * ski completely misunderstood
17:28:35 <phr> ski, sorry, yeah.  i'm trying to use the current version and it doesn't seem to be doing the same thing as some blog posts that i read about older versions.  i haven't tried the older versions myself.  i wonder if anyone around here has used it
17:30:43 <Raymond> Is haskell under hacker attack?
17:30:48 <kmc> what would that even mean?
17:30:55 <Raymond> I keep getting booted off
17:31:08 <kmc> you keep getting booted off... a programming language?
17:31:16 <syntaxglitch> FreeNode is having some indigestion
17:31:23 <syntaxglitch> If that's what you're talking about
17:31:30 <hiptobecubic> You mean explosive diarrhea
17:32:37 <lostman> can someone help with category theory stuff? i've been grinding some problems for the last few hours and i'm stuck...
17:33:43 <copumpkin> lostman: sure, like what?
17:33:46 <ski> <http://hackage.haskell.org/packages/archive/atom/0.1.4/doc/html/Language-Atom-Expressions.html> looks interesting ..
17:33:56 <ski> .. i wonder what it's for ?
17:34:14 <copumpkin> ski: a dsl?
17:34:50 <lostman> got this problem: for fixed object A in category C, (-)A: Sets^C -> Sets is a functor
17:34:53 <ski> yes .. but to what end ?
17:35:04 <syntaxglitch> a DSL for embedded hard realtime programs, apparently
17:35:50 <lostman> defined by (F)A = FA, for F: C -> Sets, (a)A = a_A:FA->GA for a natural transformation a: F -> G
17:35:51 <phr> ski, atom is a monad that generates C programs for embedded cpu's
17:36:11 <lostman> and now the thing is to show that (-)A has right adjoint; and i'm not even sure where to start
17:38:36 * ski had some vague recalling that "atom" had something to do with rss
17:39:31 <ski> lostman : i would start with stating the property that a right adjoint must have ..
17:39:58 <phr> ski that's a different atom ;)
17:40:48 <tener> I've just run raytracer from http://poorlytyped.blogspot.com/2010/01/haskell-ray-tracing-parallel.html and i'm quite puzzled. is this a known bug that adding one additional thread to +RTS -N can make the performance worse by an order of magnitude?
17:41:08 <tener> (GHC 6.12.1)
17:41:24 <tener> (Arch Linux 32 bit)
17:42:29 <Berengal> tener: Does the number of threads suddenly exceed the number of cores?
17:42:43 <tener> Berengal: yes, by 1
17:42:48 <lostman> the warmup bit is to show (-)A has right adjoin when C is discrete; so, i need a functor G: Sets -> Sets^C s.t. GD is cofree over D wrt (-)A
17:43:39 <Berengal> tener: Might be some weird linux bug too, or some other weird interactions. More threads than cores is never a good thing when all threads are busy
17:43:59 <phr> ski, are you still looking at expression.hs ?
17:43:59 <tener> Berengal: I use dual core laptop, with -N3 timing goes from 9/5 to 114/59 seconds (cputime/elapsed)
17:44:27 <tener> Berengal: also, gc time goes from 10% to 50%
17:44:39 * ski absentmindedly wonders what `expression.hs' is
17:44:40 <phr> tener, yes, it's known that too many threads can slow down the program under linux, though 10x is more than i had heard
17:44:55 <phr> see http://hackage.haskell.org/trac/ghc/ticket/3553
17:45:19 <tener> phr: I see that for "9 512" arguments
17:45:30 <phr> 9 512?
17:45:34 <tener> uhm
17:45:37 <tener> read the blog post
17:45:49 <tener> 512x512 image, 9 levels recursion
17:45:57 <phr> oh
17:45:57 <tener> anyways
17:46:44 <tener> for harder case, 12 levels, same image size, the change is from 20 to 190 cputime
17:46:51 <tener> so almost the same
17:47:23 <tener> in terms of slowdown
17:48:10 <phr> what 8 core machine are you using?
17:48:28 <tener> i have 2 cores
17:48:39 <tener> i didn't write that blog post
17:48:41 <phr> hmm
17:49:02 <tener> the ticket describes something a bit different though
17:49:17 <tener> according to it, 1 thread should be optimal
17:49:27 <tener> well, it is optimal anyway, but the difference is minor
17:49:39 <lostman> are objects in Sets^C covariant hom-functors?
17:50:58 * ski would think them to be covariant functors
17:51:29 <sshc> how do I use System.IO.Unsafe.unsafePerformIO without importing it?
17:51:45 <copumpkin> sshc: why would you want to?
17:52:03 <sshc> copumpkin: cleaner one-line temporary debug code
17:52:06 <sshc> copumpkin: it's not too big of a deal
17:52:18 <copumpkin> Debug.Trace ?
17:52:32 <sshc> copumpkin: no, unsafePerformIO
17:52:57 <syntaxglitch> If you just want to do occasional output for debugging, that's what Debug.Trace does
17:53:24 <syntaxglitch> it's like old-fashioned printf debugging
17:53:41 <sshc> syntaxglitch: oh, well, in that case, I'm interested
17:53:45 <syntaxglitch> brings back memories of being an undergrad who'd never heard of a debugger
17:53:56 <copumpkin> sshc: sorry, was suggesting it, not asking about it :P
17:54:30 <syntaxglitch> sshc, http://www.haskell.org/haskellwiki/Debugging talks about how to use it
17:55:10 <syntaxglitch> well, only briefly I guess
17:55:40 <monochrom> Debug.Trace is trivial to use. Any tutorial is a one-liner.
17:55:46 <syntaxglitch> True
17:55:56 <sshc> syntaxglitch: hoogle explained it well enough to me
18:04:31 <Berengal> tener: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15957#a15957
18:04:52 <syntaxglitch> Is there a preferred or correct way to handle error recovery using Parsec? Or is it more a matter of "either do something ad hoc or use a different parser library"?
18:05:58 <syntaxglitch> The default behavior to fail immediately, one error message at a time is kind of annoying if you intend to be parsing, e.g., a nontrivial amount of hand-written source code that may have multiple syntax errors
18:06:10 <monochrom> There is no preferred way. I don't think Parsec is designed to help recovery.
18:06:51 <syntaxglitch> I suspect that parser error recovery is a fairly thorny problem with no clear-cut general solutions
18:07:11 <syntaxglitch> But I'm pretty weak on the theory behind this stuff, sadly
18:07:34 <augustss> Doesn't Parsec have some kind of error handling combinators?
18:07:51 <aavogt> yes, it has  <?> "adding a message on failure"
18:07:59 <aavogt> that's not recovery...
18:08:03 <syntaxglitch> not in the sense of recovering from an error and continuing on
18:08:11 <kmc> that'd be <|>
18:08:13 <syntaxglitch> <?> is just for improving error messages
18:08:44 <augustss> Hmmm, that's poor.
18:09:02 <ufopp> the only recovery in Parsec I noticed was <|>
18:09:17 <Berengal> What's wrong with <|>?
18:09:31 <syntaxglitch> <|> is meant for options in a grammar, by error handling I mean "this doesn't match the grammar, skip ahead until we can make sense of stuff and log the error"
18:10:03 <kmc> oh
18:10:04 <augustss> Error recovery is difficult
18:10:04 <syntaxglitch> you could certainly use <|> for error recovery, essentially by bolting on parsers that match any old garbage
18:10:06 <kmc> uu-parsinglib has that
18:10:27 <syntaxglitch> and then stash an error message in state or something, every time you have to use the garbage parser
18:10:30 <hatds> how does ghc manage its error messages?
18:10:36 <hatds> in parsing
18:10:38 <syntaxglitch> and have some way to decide when you're back to sensible input
18:10:57 <tener> AFAIK the most recent parsec supports monad transformer for parsing monad
18:10:57 <kmc> does ghc use alex / happy?
18:11:04 <augustss> yes
18:11:16 <Berengal> tener: Did you see? Pretty horrible... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15957#a15957
18:11:36 <syntaxglitch> so I guess, if I wanted to write a parser with error recovery, I'll have to dump parsec and use something else? :\
18:11:46 <Axman6> eh?
18:11:51 <tener> Berengal: ouch, I missed the last one
18:11:55 <Axman6> parsec has pretty damn good error recovery
18:11:55 <augustss> syntaxglitch: you can try <|>
18:12:12 <Berengal> tener: Note I killed it too...
18:12:16 <Axman6> syntaxglitch: a <|> b tries to parse3 a, if it fails, it tries b
18:12:16 <augustss> syntaxglitch: write a second parser that accepts anything up to some synchronization token
18:12:41 <augustss> syntaxglitch: then build a syntax tree with an error node in it
18:12:57 <syntaxglitch> augustss, yeah, that's roughly how I was thinking I'd do it
18:13:23 <syntaxglitch> but it sounds like other parser libraries have built-in support for handling error recovery, which strikes me as maybe being a better idea
18:13:46 <augustss> syntaxglitch: well, it all depends how much you have invested in parsec already
18:13:50 <tener> Berengal: so it was at least 20 times slower...
18:13:57 <syntaxglitch> my concern is that bolting on parsers that accept garbage input will muddle up the actual structure of the grammar
18:14:12 <syntaxglitch> making it hard to tell at a glance what the parser is actually expecting vs. what'
18:14:17 <pikhq> syntaxglitch: ... Parser libraries with error recovery?
18:14:19 <syntaxglitch> s the error parsers
18:14:28 <augustss> tener: what was the change that made it so slow?
18:14:40 <pikhq> Heck, "parser libraries with meaningful error reporting" are slightly rare. :P
18:14:49 <syntaxglitch> augustss, not much, I've just been toying with it... and was wondering about the error recovery issue in case I wanted to do something more serious later
18:15:09 <augustss> syntaxglitch: then i think you should shop around
18:15:17 <sshc> how do I test if one function in memory is equal to another?
18:15:23 <sshc> I'm debugging a program
18:15:28 <augustss> sshc: you shouldn't
18:15:32 <sshc> augustss: I know
18:15:35 <syntaxglitch> sshc, apply both to all possible inputs
18:15:39 <syntaxglitch> see if any output differs
18:15:43 <syntaxglitch> simple
18:15:53 <augustss> syntaxglitch: but that doesn't answer his question
18:15:57 <tener> augustss: N+1 threads, where N is the number of cores
18:16:04 <sshc> syntaxglitch: finding all possible inputs is not simple
18:16:11 <syntaxglitch> sshc, I was joking :P
18:16:18 <sshc> I see :P
18:16:31 <sshc>  I would like to know if there's a hack or something to see if two functions are equal in memory
18:16:41 <tener> Berengal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15957#a15958
18:16:52 <ski> in some cases, equality over a function type is decidable
18:16:53 <augustss> sshc: (unsafeCoerce# a) `eqAddr#` (unsafeCoerce# b)
18:17:03 <tener> My timings for the same size
18:17:03 <sshc> augustss: what's the # in there?
18:17:04 <Berengal> tener: 8 min 25 sec vs 5 sec? that's 101 times slower by my calculations...
18:17:21 <augustss> sshc: these are low level unsafe primitives
18:17:22 <copumpkin> there's reallyUnsafePtrEquality too
18:17:28 <syntaxglitch> function equality is undecidable in general, though, unsurprisingly
18:17:28 <kmc> there's also StableName which is not "unsafe", but which has weaker guarantees
18:17:36 <augustss> sshc: you'd have to find the right ghc library to include to get them
18:17:47 <kmc> in particular, _ == _ = False is a perfectly conformant implementation of StableNames
18:17:49 <tener> Berengal: I took 20 secs from 'user', but you are right
18:17:55 <sshc> augustss: are # valid chacaters in a name?
18:18:04 <kmc> sshc, with -XMagicHash
18:18:06 <copumpkin> kmc: I thought it wasn't
18:18:14 <kmc> copumpkin, maybe Eq requires reflexivity
18:18:21 <augustss> with the right extension # is allowed
18:18:26 <ski> (see e.g. <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>)
18:18:26 <kmc> StableName only guarantees:      *  If sn1 :: StableName and sn2 :: StableName and sn1 == sn2  then sn1 and sn2 were created by calls to makeStableName on the same object.
18:18:27 <copumpkin> kmc: I thought stablenames were required to have let x = makeStableName ? in x == x had to be true
18:18:39 <copumpkin> kmc: but if they were separate calls of makeStable name, then no guarantees
18:18:44 <sshc> augustss: ok, what do I need to import?
18:19:04 <Berengal> tener: The real/user ratios are pretty much euqal. Using the user timings there's a 103 times increase
18:19:04 <augustss> sshc: I don't know, but I'm sure google does
18:19:20 <pikhq> The form of equality sshc wants is *most definitely* decidable.
18:19:26 <tener> Berengal: yes, i just misread the timings, that's all
18:19:38 <pikhq> He wants to know if the byte sequence representing function a is the same as that for function b.
18:19:51 <pikhq> Not sure how to do that in Haskell, but easily decidable.
18:20:00 <kmc> use vacuum
18:20:12 <augustss> pikhq: he wants something evenstring, he wants to know if they are at the same address
18:20:19 <Berengal> tener: I can't see any real time in your timings. Is it faster with two cores?
18:20:24 <augustss> s/evenstring/even stronger/
18:20:34 <pikhq> augustss: ah.
18:20:41 <pikhq> So he wants pointer comparison.
18:20:42 <sshc> pikhq: for example, foo returns a function, and I want to see if that function is bar
18:20:46 <pikhq> C does it all the time.
18:21:03 <augustss> pikhq: yes, which is what I gave him
18:21:04 <tener> Berengal: 'total' is 'real'
18:21:14 <pikhq> Mmkay then.
18:21:34 <Berengal> tener: Thought that was user + sys, but okay...
18:21:37 <sshc> augustss: GHC.Prim
18:21:54 <Berengal> Seems parallelism is a bit useless with only two cores then
18:22:20 <tener> Berengal: uhm, wait.
18:22:49 <augustss> sshc: you must only use this for debugging, or I will have to punish you
18:22:53 <augustss> :)
18:23:14 <tener> Berengal: isn't real = sys + user?
18:23:28 <Berengal> tener: real is wall-clock, user is cpu-time
18:23:31 <Draconx|Laptop> no.
18:23:45 <Draconx|Laptop> er, that was in response to "real = sys + user"
18:23:56 <Polarina> But it's not wall-clock, it's much more accurate than that.
18:24:21 <Berengal> Well, wall-clock - interference from other processes
18:24:27 <Draconx|Laptop> user + sys can be much more than real in the presence of multiple CPUs.
18:25:08 <Berengal> tener: If you look at my timings, you'll notice real ~ 1/4 user :)
18:25:14 <sshc> does -XMagicHash only enable hashes to be used in names as ''s are?
18:25:19 <Berengal> (for -N4 and -N5)
18:25:21 <sshc> without any other effects?
18:25:28 <copumpkin> sshc: yep
18:25:40 <augustss> sshc: I think so
18:25:57 <hatds> it does affect use of # as an operator, no?
18:26:02 <hatds> gotta use spaces/etc
18:26:16 <sshc> # is a Haskell operator?
18:26:17 <lunabot>  luna: parse error on input `]'
18:26:30 <augustss> sshc: it is if you make it so
18:26:41 <tener> ok, I got confused
18:26:47 <augustss> > let x # y = y - x in 2 # 3
18:26:48 <lambdabot>   1
18:27:15 <sshc> (unsafeCourse# $ ) causes a parse error on input `$'
18:27:21 <sshc> ah, right
18:27:29 <Axman6> @index printf
18:27:30 <lambdabot> Text.Printf
18:27:34 <sshc> sorry, I meant to type
18:27:39 <sshc> (unsafeCourse# $ foo bar) causes a parse error on input `$'
18:27:57 <augustss> with -XMagicHash ?
18:28:18 <sshc> augustss: I have "{-# OPTIONS_GHC -XMagicHash #-}" above that line
18:28:35 <augustss> it should be first in the file
18:28:42 <pikhq> sshc: .. unsafeCoerce, you mean?
18:28:43 <monochrom> Is that a misspell? unsafeInterCourse?
18:28:56 <pikhq> Erm. unsafeCoerce#
18:29:03 <Berengal> sshc: options, language etc. needs to be on the first line(s)
18:29:51 <sshc> oh
18:30:16 <kmc> {-# LANGUAGE MagicHash #-}
18:30:24 <augustss> yes, that's better
18:30:40 <Berengal> It's a bit late to tell ghc which grammar it should use when it's already parsed half the file :)
18:31:49 * augustss has now written his 4th Haskell compiler.  It's getting easier over the years.
18:32:40 <copumpkin> the most tedious bit to me about writing a haskell compiler would be the grammar and ast
18:32:55 <augustss> copumpkin: but for that there is haskell-src-exts!
18:33:03 <sshc> Couldn't match kind `*' against `#' When matching the kinds of `b :: *' and `Addr# :: #' Expected type: Addr# Inferred type: b In the first argument of `eqAddr#'
18:33:03 <monochrom> Then you are the right person to ask: are you sure pointer equality of functions means anything during debugging?
18:33:12 <copumpkin> augustss: but you still need to deal with the fairly complex ast
18:33:21 <copumpkin> sshc: what are you doing?
18:33:25 <augustss> copumpkin: it's very complex
18:33:35 <Axman6> sshc: hash things are special. you often have to match using case to get something of kind #
18:33:36 <augustss> monochrom: no
18:33:40 <Axman6> @src Int
18:33:41 <lambdabot> data Int = I# Int#
18:33:47 <augustss> monochrom: as in, no, I'm not sure
18:33:48 <copumpkin> sshc: are you using something like ($) ?
18:33:57 <sshc> copumpkin: I'm using $
18:33:58 <copumpkin> sshc: unlifted types can't pass through the dollar
18:34:05 <Axman6> to get the Int#, you'd need to use case 1 of I# x -> thing you want to use x in
18:34:07 <augustss> sshc: don't use $
18:34:15 <copumpkin> :t ($)
18:34:16 <lambdabot> forall a b. (a -> b) -> a -> b
18:34:26 <Axman6> wrong type!
18:34:51 <Axman6> so, this smallpt raytracer i'm converting to haskell seems to sort of work
18:34:52 <copumpkin> actually I'm not sure why it wouldn't work, since :k (->) allows a to be ?? and b to be ?
18:35:07 <Axman6> isn't # special?
18:35:12 <tener> deep, dark magic hash
18:35:15 <copumpkin> it's a subkind of ?? and ?
18:35:20 <tener> to dark to me i fear
18:35:21 <kmc> the kind # is special
18:35:22 <sshc> augustss: that worked wonderfully!
18:35:24 <sshc> augustss: thanks!
18:35:29 <Berengal> Axman6: Crap, I was going to do this over the weekend. Now I'm going to be bored...
18:35:30 <kmc> unboxed types have kind #
18:35:32 <augustss> copumpkin: polymorphic type variables cannot be instantiated to # types
18:35:39 <copumpkin> augustss: oh, that would do it
18:35:49 <copumpkin> augustss: is there a fundamental reason for that, or did nobody see the need to just make it work?
18:35:52 <Axman6> Berengal: it's not pretty
18:36:03 <augustss> copumpkin: It would be a lot of work.
18:36:08 <ski> copumpkin : probably the uniform boxed representation ..
18:36:11 <sshc> that was an awful lot of hacking just for a simple debug.trace with a function equality test
18:36:17 <Berengal> Axman6: I don't expect my code to be sprinkled with flowers...
18:36:33 <Axman6> but this is super ugly :P
18:36:44 <copumpkin> ski: yeah, but just looking at the kind of (->) the type of (a -> b) -> a -> b has no fundamental reason not to work
18:36:57 <Berengal> Axman6: And smallpt isn't?
18:37:19 <Axman6> actually, i was suprised i could understand most of smallpt
18:37:28 <augustss> copumpkin: yeah, but it's the kind of a that matters, not the kind of ->
18:37:49 <copumpkin> augustss: and as soon as it's polymorphic, it's a *-based kind?
18:37:50 <Berengal> I too can understand much of it... Haven't really looked that much at the code though, and I don't know anything about raytracing, really.
18:37:59 <augustss> copumpkin: yes
18:38:00 * copumpkin wants universe polymorphism in haskell! why stop at kinds??
18:38:03 <dolio> copumpkin: The type of ($) is actually forall (a :: *) (b :: *). (a -> b) -> a -> b
18:38:05 <ski>   (`forall (a :: *) (b :: *). ..a..b..')
18:38:09 <kmc> copumpkin, seen Omega?
18:38:28 <copumpkin> kmc: I've seen one omega, but it doesn't sound like something you'd bring up for this
18:38:29 <kmc> it's non-dependent but has infinite sort hierarchy and allows you to define datasorts at any level
18:38:37 <copumpkin> oh, a language?
18:38:41 <kmc> yes
18:38:41 <sshc> I've never understood or used "forall
18:38:48 <kmc> looking
18:38:49 <sshc> is it ever necessary to use?
18:38:51 <copumpkin> sshc: you're using it implicitly all the time
18:38:59 <copumpkin> sshc: sometimes it is necessary, yep
18:39:00 <kmc> sshc, yes, with GHC extensions it can be necessary
18:39:04 <Berengal> sshc: Only with higher-ranked types
18:39:07 <augustss> kmc: Does Omega really do universe polymorphism?
18:39:10 <copumpkin> or if you want scoped type variables
18:39:12 <kmc> no i don't think so
18:39:30 * ski str seeing `error :: forall (a :: ?). String -> a' somewhere ..
18:39:36 <Berengal> sshc: Also, it shows up in weird places. For example, how many functions of type (a -> b) are there?
18:39:39 <kmc> http://web.cecs.pdx.edu/~sheard/Omega/index.html
18:39:53 <dolio> ski: It works that way, at least.
18:39:55 <copumpkin> kmc: thanks
18:40:04 <dolio> > error "foo" :: Int#
18:40:04 <lambdabot>   Not in scope: type constructor or class `Int#'
18:40:09 <augustss> @djinn a->b
18:40:09 <lambdabot> -- f cannot be realized.
18:40:11 <kmc> sshc, the type "forall a. a -> Int" means "for any type A you choose, i can convert A to an int"
18:40:12 <dolio> Oh well.
18:40:30 <copumpkin> that's incidentally what a -> Int means too :)
18:40:35 <Berengal> sshc: appart from undefined, none, but how can you provide one to ($), which expects a function of that type?
18:40:42 <dolio> ski: Which is kind of weird, since unboxed types are supposed to be unlifted (I thought).
18:41:02 <sshc> are there any official references or documentation of forall?
18:41:05 <Axman6> @djinn a -> Int
18:41:06 <lambdabot> Error: Undefined type Int
18:41:09 <Axman6> :o
18:41:23 <augustss> dolio: unboxed types are not really unlifted.  they are strange beasts
18:41:23 <Gracenotes> f _ = 42
18:41:26 <kmc> the type "(forall a. a -> Int) -> Char" means "if you give me a function like that, i can give you a Char"
18:41:31 <dolio> Yeah, I know.
18:41:33 <kmc> by "like that" i mean like the one in the previous example
18:41:52 <dolio> Obviously nothing stops you from writing infinite loops with type Int#, either.
18:41:59 <Berengal> forall a. a -> Int ~ Int
18:42:00 <kmc> and the type "forall a. (a -> Int) -> Char" means "for any type A, if you give me a function that converts only that specific A to Int, I will give you a Char"
18:42:05 <augustss> dolio: exactly
18:42:08 <kmc> sshc, that's the case where the placement of the forall matters
18:42:30 <dolio> Oh, maybe error doesn't work that way anymore... I definitely thought it did.
18:42:35 <ski> @type error "foo" :: GHC.Prim.Int#
18:42:37 <lambdabot> GHC.Prim.Int#
18:42:50 <copumpkin> :t error
18:42:51 <lambdabot> forall a. [Char] -> a
18:42:59 <Berengal> sshc: There are some pages on the wiki
18:43:07 <augustss> :k GHC.Prim.Int#
18:43:08 <lambdabot> #
18:43:09 <lunabot>  luna: parse error on input `]'
18:43:11 <augustss> weird
18:43:18 <dolio> ski: In 6.12.1, it complains that * is not #.
18:43:26 <augustss> is there hack for error?
18:43:31 <ski> augustss : so the input to a function of type `Int# -> Bool' can loop ?
18:43:37 <Berengal> sshc: But an easy intuition is to simply consider 'forall a' to be an extra argument of type Type, which all types are values of
18:43:56 <dolio> But it seems to be fine with error "foo" :: (# Int, Int #)
18:43:56 <augustss> ski: computing the argument to the function can loop
18:44:18 <Berengal> sshc: And which later arguments can depend on. A sort of limited dependent typing...
18:44:47 <Gracenotes> augustss: though that's somewhere in a case statement before the function code is actually entered though, right?
18:44:55 <dolio> It doesn't mind 'let f :: Int# -> Int# ; f x = error "foo"', either.
18:44:57 <Berengal> sshc: so e.g. id :: forall a. a -> a is called like `id Int 5' or `id Char 'a''
18:45:15 <augustss> Gracenotes: sure, but the domain for Int# must include bottom
18:45:21 <dolio> Just 'error "foo" :: Int#'.
18:45:58 <Gracenotes> augustss: I thought, being a primitive, it just included 0x00..00 to 0xFF..FF :)
18:46:22 <tensorpudding> > 0xBEEF :: Int
18:46:23 <augustss> Gracenotes: there's nothing primitive about domain theory :)
18:46:23 <lambdabot>   48879
18:46:24 <ski> @type case error "foo" of GHC.Base.I# x -> GHC.Base.I# (x GHC.Base.+# 2#)
18:46:25 <lambdabot> Int
18:46:30 <dolio> Oh, never mind. The problem with 'error "foo" :: Int#' is when ghci tries to print it.
18:46:43 <augustss> > 0xcafebabe
18:46:44 <lambdabot>   3405691582
18:47:50 <p_l> > 0xfoo1foo1
18:47:51 <lambdabot>   Not in scope: `oo1foo1'
18:47:58 <Gracenotes> hm. My mind is getting fuzzy about exactly what it means for primitives to be strict
18:48:01 <sshc> > toHex 636828
18:48:02 <lambdabot>   Not in scope: `toHex'
18:48:08 <p_l> right...
18:48:16 <p_l> > 0xf001f001
18:48:17 <lambdabot>   4026658817
18:48:17 <tensorpudding> > 0xBEEBEEBEEBEEBEE
18:48:18 <lambdabot>   859834499406425070
18:48:39 <monochrom> > 0xbabe
18:48:40 <lambdabot>   47806
18:48:56 <p_l> hmm... and where's the classic?
18:49:00 <p_l> > 0xdeadbeef
18:49:01 <lambdabot>   3735928559
18:49:08 <sshc> > 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
18:49:10 <lambdabot>   191792700306415244701996854887257867476903098904091718482043749260774729387...
18:49:12 <Berengal> In java 0xF00L is a valid literal...
18:49:24 <Berengal> sshc: ... UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
18:49:26 <ski> augustss : yes .. so expressions of that type can have bottom denotation .. but i wonder if there's any point in having some kind of interpretation for values of that type .. so that `a -> b' would be translated to `[[a]] -> Lift [[b]]' (for unboxed `a' and `b')
18:49:26 <tensorpudding> we need some base 36
18:49:39 <dcoutts> augustss: we should have real unlifted types in a sublanguage, only allow System F
18:50:09 <dcoutts> ski: the tricky thing is then how do you compose functions?
18:50:11 <monochrom> we need base 37 so as to allow space.
18:50:32 <Berengal> We need base 2^32, so as to allow unicode
18:50:35 <ski> dcoutts : `Lift' would be a monad, so it's Kleisli composition .. i think
18:50:37 <Berengal> (and other garbage)
18:51:00 <tensorpudding> allowing unicode would make carriage return a number wouldn't it
18:51:02 <augustss> ski: sounds like a plan
18:51:13 <dcoutts> ski: aye, plausible
18:51:27 <augustss> dcoutts: System F is too limited, I want dependent types
18:51:47 <monochrom> System F#  <duck>
18:51:52 <dcoutts> augustss: mm, though System F would be a lot easier to integrate, since it's the same core language
18:52:33 <augustss> > 0xacc01ade
18:52:34 <lambdabot>   2898270942
18:53:06 <augustss> > 0xb100dleaf
18:53:07 <lambdabot>   Not in scope: `leaf'
18:53:19 <augustss> > 0xb100d1eaf
18:53:19 <lambdabot>   47513935535
18:53:26 <dcoutts> ski: I vaguely recall sitting through a talk where someone did something like this with outputs lifted. I don't think they had worked out all the details.
18:53:28 <ski> > 0o00000
18:53:29 <lambdabot>   0
18:54:12 <merehap> > 0x138d5
18:54:13 <lambdabot>   80085
18:55:39 <Berengal> > 0x7A69
18:55:40 <lambdabot>   31337
18:55:56 <dolio> What ski describes is essentially what you get with the partiality monad proposals for total languages.
18:56:15 <augustss> dcoutts: I hear rumours of a shared RTS on windows
18:56:33 <dolio> Since that models strict partiality, with datatypes in the total language always being fully defined.
18:57:09 <hiptobecubic> merehap, :D
18:57:37 <merehap> I'm glad someone appreciates my work :)
18:58:48 <ski> > (take 4 . map (`showHex` ""))  foo
18:58:49 <lambdabot>   ["35","173","1415","18499"]
18:59:32 <ski> (dolio : that's probably so, yes ..)
19:00:15 <copumpkin> > foo
19:00:19 <lambdabot>   mueval-core: Time limit exceeded
19:00:46 <ski> > head foo
19:00:47 <lambdabot>   53
19:01:11 <dolio> Being able to define stand-alone 'i :: Int# ; i = i' would be translated to 'i :: D Int# ; i = later i'.
19:01:20 <dolio> Or something of that sort.
19:01:43 <ski> or possibly the `D' would be lifted around the whole module
19:02:19 <dolio> Well, possibly, but I don't think that happens if you do it in Haskell.
19:02:39 <ski> h, point
19:02:44 <sshc> > foo
19:02:48 <sshc> > bar
19:02:49 <lambdabot>   mueval-core: Time limit exceeded
19:02:49 <lambdabot>   Not in scope: `bar'
19:02:54 <sshc> > foo bar
19:02:55 <lambdabot>   Not in scope: `bar'
19:03:23 <sshc> @let bar = return $ Just $ return . return $ id
19:03:25 <lambdabot>  Defined.
19:03:41 <aavogt> @type bar
19:03:43 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) (m2 :: * -> *) a. (Monad m, Monad m1, Monad m2) => m (Maybe (m1 (m2 (a -> a))))
19:03:50 <dolio> Or, GHC, that is, since Haskell doesn't define unboxed types.
19:04:39 <sshc> @let quux :: (Integral a, Fractional a) => a -> a; quux = a + a
19:04:40 <lambdabot>  <local>:3:53:
19:04:40 <lambdabot>      Couldn't match expected type `a -> a' against inferred ty...
19:04:53 <sshc> @let quux :: (Integral a, Fractional a) => a -> a; quux a = a + a
19:04:54 <lambdabot>  Defined.
19:05:08 <dolio> Apparently top-level bindings for unboxed types aren't allowed, so I guess it doesn't come up.
19:05:09 <sshc> good luck trying to find a working call to either of those!
19:05:40 <sshc> @type bar
19:05:42 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) (m2 :: * -> *) a. (Monad m, Monad m1, Monad m2) => m (Maybe (m1 (m2 (a -> a))))
19:05:43 <sshc> @type quux
19:05:44 <lambdabot> forall a. (Integral a, Fractional a) => a -> a
19:07:50 <dolio> It isn't letting me write direct recursive bindings for Int#, either, so I guess they've ruled out a fair amount of the bad cases.
19:09:03 <merehap> merehap> :)
19:10:04 <merehap> oops, I shouldn't experiment with IRC on a live channel :(
19:12:32 <pikhq> sshc: It's trivial to create something that's an instance of Integral and Fractional.
19:12:34 <Gracenotes> we all experiment with IRC in our youth
19:12:36 <pikhq> It's just pathological.
19:13:14 <Gracenotes> I've been meaning to write a conversion chart between numerical types... er.. for maybe just under a year :x
19:13:20 * pikhq shall define an instance of Num with all the operations evaluation to _|_, just to be evil. :P
19:13:29 <merehap> Gracenotes: if only I hadn't missed that vital part of my youth. then I would have an excuse :)
19:13:34 <pikhq> Erm. Evaluating.
19:13:41 <sshc> pikhq: now try doing it with lambdabot :)
19:14:04 <pikhq> sshc: Meh.
19:14:08 <Gracenotes> pikhq: easy. just say "instance Num YouType" without further qualification. ignore ensuring compiler warnings.
19:14:26 <ski> (pikhq : .. the type in question being `Void' ?)
19:14:29 <pikhq> Gracenotes: Heheheh.
19:14:29 <c_wraith> hey cygnus.  How goes?
19:14:35 <pikhq> ski: Sure.
19:14:39 <cygnus> c_wraith: goes well. :-D
19:19:42 <lostman> right: in Sets^C, objects are hom(X,-); i.e. I give it some c in C and it gives me C(X,c)?
19:21:46 <lostman> so what happens if C is discrete? either I get C(c,c) = {1c} or C(c,d) = {}
19:22:57 <ski> "it" being ?
19:24:01 <ski> iiuc
19:24:02 <dolio> hom(X,-) aren't the only objects in Sets^C, I would think.
19:24:21 <ski>   Hom_C : op C * C >-> Set
19:24:22 <ski> so
19:24:47 <ski>   (Y |-> Hom_C (X,Y)) : Set^C
19:25:01 <lostman> hom(X,-). if I have this functor (-)A that maps from Sets^C to Sets by (F)A = FA then FA = C(X,A) for some X?
19:25:18 <ski> would be an example of an object in `Set^C' (given some object `X' in `C')
19:26:06 <ski> lostman : i'm not convinced of that ..
19:26:13 <lostman> now I'm confused
19:26:25 <ski> (maybe it is the case, but i don't see it)
19:26:51 <lostman> isn't Sets^C a category of functors from C to Sets?
19:27:08 <ski> yes, but is every such functor a hom-functor ?
19:27:32 <ski> (as dolio were commenting on)
19:27:32 <dolio> What if C is the category of small categories?
19:27:52 <dolio> Then you could have a functor that takes a category to its set of objects.
19:28:41 <tensorpudding> a small category is a kittygory
19:28:55 * ski groans
19:29:54 <zeitende> hi
19:30:04 <lostman> *sigh*
19:34:37 <kmc> hi zeitende
19:44:21 <dcoutts> augustss: yes, that's the rumour, I haven't tested it out much yet personally but Ben thinks the core stuff is sorted (like making sure the code gen generates the right inter/intra dll calls)
19:44:31 <zeitende> whats all this
19:44:42 <kmc> all which
19:44:51 <zeitende> oh damn it
19:44:54 <drhodes> for groupBy, I'm building a predicate based on an algebraic type  data Foo a = Bar a | Gorp a | Flork a    where  pred :: Foo a -> Foo a -> Bool,  pred | (Bar _) (Bar _) -> True | (Bar _) _ -> False .. for all permutations!,  is there a short cut?
19:45:00 <zeitende> i just received like 300 private messages
19:45:01 <zeitende> from bots
19:45:18 <zeitende> ugh
19:45:24 <tensorpudding> @botsnack
19:45:24 <lunabot>  :o
19:45:24 <lambdabot> :)
19:45:31 <tensorpudding> lunabot is faster usually
19:45:32 <kmc> drhodes, you can give just the True cases
19:45:32 <merehap> haha :)
19:45:34 <vaymbnpuyf> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:34 <vaymbnpuyf> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:35 <vaymbnpuyf> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:35 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:35 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:36 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:38 <vaymbnpuyf> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:38 <iymprmw> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:38 <iymprmw> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:39 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:39 <iymprmw> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:39 <kmc> and then pred _ _ = False
19:45:41 <vaymbnpuyf> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:42 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:44 <drhodes> ok kmc thanks!
19:45:44 <vaymbnpuyf> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:45 <yrwvaqazbv> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:45 <yrwvaqazbv> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:45 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:46 <yrwvaqazbv> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:47 <vaymbnpuyf> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:48 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:48 <brb> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:48 <brb> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:49 <yrwvaqazbv> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:49 <kmc> oh jesus
19:45:49 <brb> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:51 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:52 <Gracenotes> :|
19:45:52 <brb> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:52 <rpyvtuhsmcl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:52 <rpyvtuhsmcl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:52 <kmc> @where ops
19:45:53 <rpyvtuhsmcl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:53 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
19:45:54 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:55 <gwp> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:55 <gwp> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:56 <gwp> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:56 <rpyvtuhsmcl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:57 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:59 <gwp> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:45:59 <rpyvtuhsmcl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:46:00 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:46:00 --- mode: ChanServ set +o dcoutts
19:46:02 <gwp> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:46:02 <rpyvtuhsmcl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:46:03 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:46:06 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:46:08 <kmc> someone set +v
19:46:09 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:46:12 <tensorpudding> who the hell is stew?
19:46:12 <dcivtmwe> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:46:12 --- kick: dcivtmwe was kicked by dcoutts (dcoutts)
19:46:13 <kmc> err +m whatever
19:46:22 <kmc> tensorpudding, STEW is a fat motherfucker!
19:46:24 <kmc> obviously
19:46:37 <Gracenotes> kmc: set the spammers +v!
19:46:41 <kmc> hehe
19:46:48 <tensorpudding> there is a stew in another channel
19:46:52 <merehap> verbose mode?
19:47:31 <tensorpudding> GNAA is back
19:47:44 <tensorpudding> if they were ever gone
19:48:17 <tensorpudding> hmm, guessing that stew is a freenode admin?
19:48:52 <smzptnrbaim> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:48:52 <smzptnrbaim> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:48:53 <smzptnrbaim> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:48:55 <nndl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:48:55 <nndl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:48:56 <smzptnrbaim> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:48:56 <nndl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:48:59 <smzptnrbaim> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:48:59 <nndl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:49:00 --- kick: smzptnrbaim was kicked by dcoutts (dcoutts)
19:49:02 <nndl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:49:04 --- kick: nndl was kicked by dcoutts (dcoutts)
19:49:18 <rplqr> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:49:18 <rplqr> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:49:19 <rplqr> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:49:22 --- mode: dcoutts set +b rplqr!*@*
19:49:39 --- mode: ChanServ set +o monochrom
19:49:49 <sgyagfnyqvsr> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:49:49 <sgyagfnyqvsr> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:49:50 <sgyagfnyqvsr> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:49:52 --- kick: sgyagfnyqvsr was kicked by dcoutts (dcoutts)
19:50:27 <dcoutts> bah, I don't have this irc client set up with my favourite quick kickban
19:50:42 <merehap> you are still pretty quick with it, though
19:51:35 <[Bool]> hi merehap
19:51:37 <dm`> What happens if you have the plug-in to view that URL?  Is it malware, or just something humorously annoying that you can't kill?
19:51:44 <pdtiqzssqd> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:51:44 <pdtiqzssqd> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:51:45 <pdtiqzssqd> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:51:47 --- kick: pdtiqzssqd was kicked by dcoutts (dcoutts)
19:52:07 <merehap> hi [Bool]
19:52:33 <zxyihpv> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:52:33 <zxyihpv> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:52:34 <Vanadium> Great, now I am curious w.r.t. that url
19:52:34 <zxyihpv> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:52:36 --- kick: zxyihpv was kicked by dcoutts (dcoutts)
19:53:40 <drhodes> Vanadium: ot
19:53:57 <drhodes> it's a link to a page that opens a bunch of inline irc clients
19:54:11 <Vanadium> That sounds hilarious
19:54:42 <ylhrwbhl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:54:42 <ylhrwbhl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:54:43 <ylhrwbhl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:54:46 <ylhrwbhl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:54:49 <ylhrwbhl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:54:55 --- mode: dcoutts set +b ylhrwbhl!*@*
19:54:56 <npy> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:54:56 <npy> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:55:09 <dm`> kick npy
19:55:29 <tensorpudding> he got k-lined
19:55:30 <monochrom> Do those clients join channels and say that url again?
19:55:40 <pxcllnufiu> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:55:40 <pxcllnufiu> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:55:46 <drhodes> monochrom: I don't know, I closed it immediately :3
19:55:59 <Ke> so how does a webpage force my computer to open irc clients?
19:56:06 <monochrom> If they do, that is a clever infectious scheme.
19:56:29 <DigitalKiwi> how does a jpeg do it >.>
19:56:30 <dcoutts> aye, preying on people's curiosity :-)
19:56:31 <tensorpudding> some web browsers seem pretty stupid
19:56:45 <cnktacart> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:56:45 <cnktacart> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:56:46 <cnktacart> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:56:49 <tensorpudding> why should a web link cause a cascade of tabs to open?
19:56:49 <cnktacart> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:57:09 <monochrom> javascript and flash do a lot of things
19:57:17 <tensorpudding> "requested"
19:57:33 <kmc> from the url: setTimeout("unload_goatse()", 3000); // 3s
19:57:35 <Lycurgus> must have a big pool of infected hosts
19:57:35 * DigitalKiwi wonders what links/elinks/lynx/w3m would do...
19:57:50 <abuyimtl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:57:50 <abuyimtl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:57:51 <abuyimtl> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:57:54 <tensorpudding> nothing, because they don't look at javascript
19:58:02 <kmc> it has a list of dodgy urls
19:58:04 <kmc>         "ed2k://|file|Gayniggers From Outer Space [GNAA Digitally Remastered].avi|134174720|F8AF9D8A7091CD7A7B8968C9EB397C02|/",
19:58:08 <tensorpudding> at least, not for opening tabs or windows
19:58:12 <DigitalKiwi> I wonder if just saying that sentence gets you klined now
19:58:15 <Ke> I thought elinks has javascript support
19:58:17 <monochrom> ooh, mreh is collateral damage :)
19:58:33 <tensorpudding> maybe elinks does
19:58:40 <tensorpudding> i was thinking of links/lynx
19:59:00 <tensorpudding> GNAA digitally remastered?
19:59:04 <monochrom> ooh, same IP address, mreh clicked on the url!
19:59:04 <Ke> at least it has javascript use flag
19:59:12 <kmc>   <!-- This object plays the "hey everybody, I'm watching gay porno!" sound -->
19:59:41 <tensorpudding> i clicked the link and it didn't get me k-lined
19:59:44 <DigitalKiwi> LILO was the freenode founder or something?
19:59:48 <tensorpudding> yeah
19:59:57 <absbumwkgk> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:57 <absbumwkgk> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:57 <zkk> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:57 <zkk> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:57 <zktp> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:57 <zktp> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:58 <absbumwkgk> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:58 <zkk> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:58 <zktp> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:58 <gspn> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:58 <gspn> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
19:59:59 <tensorpudding> he got hit by a car and died a couple years ago
20:00:40 <DigitalKiwi> mode +R #haskell
20:00:43 <[Bool]> aww
20:00:46 <[Bool]> that link
20:00:48 <lxyuduawtdfy> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
20:00:48 <lxyuduawtdfy> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
20:00:49 <lxyuduawtdfy> STEW is a fat motherfucker!   http://img527.1-imageshack.us/i/stew4n35.jpg   I wish someone would run him over like Rob Levin (LILO)
20:00:53 <[Bool]> messing up my computer
20:00:57 <DigitalKiwi> will stop all this spam
20:01:05 <tensorpudding> what is +R?
20:01:07 --- mode: monochrom set +R
20:01:11 <DigitalKiwi> and anyone smart enough to use haskell should be able to figure out how to register
20:01:13 <aavogt> need registration
20:01:15 <Lycurgus> only registered users
20:01:17 <tensorpudding> ah
20:01:27 <Lycurgus> that's the only thing that will stop it
20:01:29 <monochrom> unregistered users can't speak
20:01:34 <tensorpudding> that's bad
20:01:40 <Lycurgus> funny it's just this channel of those I'm in
20:01:41 <tensorpudding> for general channels
20:01:56 <kmc> this is one of the biggest channels on freenode
20:01:57 <monochrom> I agree it's a good temporary measure.
20:01:58 <tensorpudding> #math and #debian were hit by them
20:02:00 <pikhq> Still, it's a good response to spam.
20:02:08 <Vanadium> Apparently that thing involves a bunch of iframes that load a form that is automatically submitted by javascript to "http://irc.freenode.net:6667" and has a bunch of IRC commands in POST data.
20:02:16 <pikhq> And +R is actually rather common on large channels on Freenode.
20:02:25 <Vanadium> I am somewhat impressed this works. By impressed I guess I mean "what the hell are browsers thinking"
20:02:26 <pikhq> (#gentoo, for example, has it on always.)
20:02:29 <DigitalKiwi> I think most of the #archlinux channels have it and we almost never have problems like this, or with people not being able to register/talk, at least...we don't hear about it ;D
20:03:03 <tensorpudding> #gentoo gets trolled a lot?
20:03:14 <kmc> gentoo is for ricers
20:03:18 <tensorpudding> or maybe they don't care much for noobs
20:03:23 <tensorpudding> (to irc anyway)
20:03:24 <Lycurgus> well it's common on some channels, dunno how to characterise them other than that req reg
20:03:46 <Lycurgus> *than that they req reg
20:03:58 <tensorpudding> that's a real tongue-twister
20:04:04 <dcoutts> kmc: it does attract some crazy opinionated users :-)
20:04:12 <DigitalKiwi> #ubuntu has like over 9000 bots to handle the spammers
20:04:14 <Lycurgus> what's keeping it from talking?
20:04:18 <tensorpudding> -funroll-loops
20:04:21 * pikhq wgets the link for the sake of cat
20:04:21 <monochrom> hahaha
20:05:06 <pikhq> tensorpudding: -funroll-loops is almost cause for banning.
20:05:07 <tensorpudding> trying to wget the link causes your console to stream text and you have to kill your terminal client
20:05:12 <pikhq> (the use of the flag, not the site.)
20:05:13 <Vanadium> > "is lambdabot identified?"
20:05:13 <Lycurgus> or rather what's automatically k-lining, a lambdabot?
20:05:14 <lambdabot>   "is lambdabot identified?"
20:05:17 <Vanadium> hooray
20:05:49 <monochrom> > 0
20:05:51 <lambdabot>   0
20:06:02 <tensorpudding> hmm, if you got lambdabot to say what was in the link, would lambdabot get k-lined?
20:06:27 <pikhq> That link is rather nasty.
20:06:34 <Vanadium> tensorpudding: Let us not find out
20:06:47 <DigitalKiwi> isn't there a +z that is kind of like +m, but shows ops what people are saying?
20:07:00 <djahandarie> tensorpudding, O
20:07:06 <djahandarie> I'm pretty sure it doesn't automatically k-line
20:07:25 <monochrom> Yes +z does that.
20:07:59 <djahandarie> Since the people outputting that spam aren't exactly "infected" or anything. They just unsuspectingly clicked on a link.
20:07:59 <pikhq>   <!-- This object plays the "hey everybody, I'm watching gay porno!" sound -->
20:08:06 <pikhq> Ebil.
20:09:04 <tensorpudding> > ">_<"
20:09:06 <lambdabot>   ">_<"
20:09:33 <uman> Hi, I'm trying (once more!) to learn Haskell
20:09:48 <uman> in the tutorial I'm reading he says to define a new function by typing something like "doubleMe x = x + x"
20:09:54 <uman> however when I type this into the interpreter I get errors
20:10:03 <kmc> that works in a file
20:10:08 <kmc> in ghci you have to use "let"
20:10:10 <tensorpudding> you can't define functions in the interpreter that way
20:10:11 <kmc> let doubleMe x = x + x
20:10:22 <uman> thanks guys :)
20:10:26 <kmc> the prompt in GHCi is not like the top level of a file; it's like a "do" block
20:10:29 <tensorpudding> it's unfortunate but true
20:10:33 <kmc> however you can load a file into GHCi
20:10:49 <kmc> you can't define new datatypes, typeclasses, or instances in GHCi
20:12:01 <uman> any other gotchas I need to worry about, as a beginner, for working with the interpreter?
20:12:21 <uman> I guess writing code in files is necessary for real applications, but for writing one-liners to follow along with a tutorial it gets annoying...
20:12:36 <damd> pwndzzzz!!!
20:12:54 <DigitalKiwi> lol the global notice from lorez :D
20:13:13 <damd> uman: that's not really a gotcha, it's just that whatever you enter into ghci must be an expression.. and function declarations are not expressions!
20:13:20 <damd> (aiui)
20:13:35 <Vanadium> uman: What you could do is have a file open in which you type definitions, and open that file from running a ghci session in parallel using :load filename.hs, and then doing :r to reload the file whenever you save a new definition
20:13:40 <aavogt> let f x = x -- isn't an expression
20:13:50 <aavogt> but it works in ghci
20:14:02 <damd> Then I Shall Be Quiet.
20:14:28 <uman> Vanadium: right, I guess I'm going to do that
20:14:30 <aavogt> what kmc said is more accurate
20:14:35 <uman> Vanadium: didn't know about r, thanks.
20:16:06 <aavogt> isn't it convenient how ghc 6.12 added this :redir, so :r doesn't expand to  :reload
20:16:24 <Vanadium> It still seemed to expand to that when I last tried
20:17:01 <dolio> :redir isn't a command, unless you've defined it yourself or something.
20:17:10 <kmc> damd, things you type into ghci must be do-statements
20:17:12 <uman> I'm sure I'm using a dog old version of ghc anyway
20:17:23 <kmc> which includes expressions, expressions with a binding (x <- e), and let without "in"
20:17:28 <uman> Ubuntu likes to include dog-old versions of obscure programming languages
20:17:29 <kmc> let-with-in is an expression
20:17:47 <Vanadium> Who are you calling obscure >:I
20:18:06 <aavogt> oh, then ghci now completes commands I've added with let { ... }
20:18:39 <uman> Vanadium: well, to be fair, Haskell is pretty obscure
20:18:44 <monochrom> tensorpu`: If tensorpu` is your favourite second-choice nick, add it to your account, something about /msg nickserv group
20:22:17 * monochrom is tempted to take it one step further, +r, meaning they can't even join.
20:22:32 <hatds> > let f = case () of {_ -> a where a = 1} in f
20:22:33 <lambdabot>   1
20:23:31 <elly> do it, monochrom
20:23:37 <elly> unregistered users, to generalize a bit, are noobs
20:24:23 <sshc> they're attacking #Haskell now!! D:
20:24:38 <sshc> please +r
20:24:55 <hatds> huh, am I being stupid or does  "case () of {_ -> a where a = 1}" yield a parse error according to the official layout rules?
20:25:22 <monochrom> . o O ( Just when I spoke, they tappered off. :) )
20:25:24 <kmc> is where allowed within case like that?
20:25:33 <uman> elly: what have you against noobs? :)
20:25:35 <kmc> i thought where binds to a set of function equations
20:25:40 <hatds> yes, you can put a where after a set of pattern guards
20:25:48 <hatds> > let f = case () of {_ -> a where a = 1} in f
20:25:50 <lambdabot>   1
20:25:50 <kmc> good to know
20:25:58 <kmc> err, those are pattern guards?
20:26:03 <hatds> but the official rules say its a parse error (I think)
20:26:16 <kmc> pattern guards aren't covered in the report
20:26:24 <kmc> i don't think that feature is being used here
20:26:30 <hatds> sorry, not pattern guards
20:26:36 <hatds> "guarded pattern"
20:27:08 <hatds> alt 	 -> 	 pat -> exp [where decls]   | 	pat gdpat [where decls]
20:27:52 <monochrom> Hrm interesting!
20:27:53 <hatds> anyway, according to the layout rules when you encounter an explicit '}' when the current layout context is not explicit it is a parse error
20:28:08 <monochrom> oot I still have hugs! I'll try it.
20:28:40 <monochrom> hugs accepts case () of { _ -> a where a=1 }
20:29:20 <sshc> monochrom: why not +r?
20:29:53 <sshc> monochrom: the end result is not much of a difference from +R
20:29:58 <monochrom> Nothing has happened.
20:30:15 <sshc> monochrom: I don't see why you would choose +R over +r
20:30:37 <sshc> yes, spam has happened, and it probably will happen later on
20:30:58 <hatds> L (}:ts) (0:ms) 	 = 	 } : (L ts ms) 	L (}:ts) ms 	= 	parse-error
20:31:05 <hatds> er whoops
20:32:38 --- mode: monochrom set +v pibymu
20:32:42 <pibymu> hi
20:32:53 <monochrom> Neato.
20:34:39 <sshc> monochrom: setting the channel +r after I suggested to is not a weakness
20:39:53 <hatds> ah, I think I get it
20:40:03 <hatds> "If the innermost context is 0, then no layout tokens will be inserted until either the enclosing context ends or a new context is pushed."
20:40:19 <hatds> so that where inside the case doesn't get translated to a "where {"
20:40:45 <hatds> where is everyone btw?
20:41:16 <lostman> right, I'm stuck with the following problem: fix any object A in C; define (-)A:Sets^C->Sets as (F)A = FA for F:C->Sets, (a)A = a_A:FA->GA for a natural transformation a; now, prove (-)A has a right adjoint when C is discrete; I spent last 4 hours trying to figure this out and have 0 ideas
20:41:28 <lostman> can anyone help?
20:42:54 <uman> am I childish for typing [1..] because I'm curious how big of a list it can make before running out of memory? :D
20:43:29 <dmwit> hatds: Friday night, lol.
20:43:31 <dmwit> uman: nope
20:44:31 <uman> something seems odd though... the list is currently at 22 million or so, and ghci is using 2gb of memory
20:44:38 <uman> why so much?
20:44:42 <kamatsu> hey, for some reason, i've run into this problem again
20:45:13 <kamatsu> rectM m x y w h = m >>= \m' -> rect m' x y w h
20:45:19 <kamatsu> I can't do this point-less ly
20:46:57 <kamatsu> @pl rectM m x y w h = m >>= \m' -> rect m' x y w h
20:46:58 <lambdabot> rectM = (. ((((flip .) . flip) .) . flip . flip rect)) . (.) . (.) . (.) . (>>=)
20:47:00 <kamatsu> bah
20:47:52 <dolio> If C is discrete, then it's roughly a set, so F : C -> Sets is essentially a C-indexed product of sets.
20:48:19 <dolio> If that helps.
20:48:23 <tensorpudding> @src fix
20:48:23 <lambdabot> fix f = let x = f x in x
20:49:34 <phnglui> ribbit.
20:50:16 <monochrom> kamatsu: Perhaps you can define «deepflip f a b c d e = f b c d e a», then write «m >>= deepflip rect x y w h»
20:50:51 <monochrom> Or perhaps just don't pointfree everything in sight.
20:51:09 <kamatsu> monochrom: the reason I want to pointfree it is that I am defining alot of these
20:51:15 <kamatsu> monochrom: with a varying amount of arguments
20:51:25 <kamatsu> monochrom: so I want to be able to write them all basically the same way
20:51:48 <lostman> dolio: thanks; i'll try to think about this
20:52:10 <kamatsu> monochrom: your solution doesn't work for a variety of functions with different amounts of arguments =(
20:53:59 <kamatsu> writing these out pointfully feels too verbose for haskell, i keep feeling like there must be a better way to do it, but i can't see it.
20:54:36 <monochrom> Perhaps rect should have been designed to take m' as the last parameter in the beginning.
20:54:43 <uman> how can I force ghci to invoke the garbage collector?
20:55:07 <kamatsu> monochrom: well, the m one is the surface to draw the rectange to
20:55:24 <kamatsu> monochrom: it's something you might want to partially apply alot.
20:55:41 <kamatsu> monochrom: so i put it at the beginning
20:56:38 <monochrom> might? just might? Do you end up doing things like «rect m x» partially applied like that?
20:56:45 <dmwit> uman: Because it can?
20:56:58 <dmwit> uman: Oh, just saw your second question.
20:57:43 <dmwit> uman: Maybe try something like "ghci +RTS -M1G" or so.
20:57:51 <monochrom> uman: System.Mem.performGC
20:57:56 <dmwit> uman: "ghci +RTS --help" for more information
20:58:00 <uman> monochrom: ty
20:58:09 <uman> dmwit: ty
20:58:54 <kamatsu> monochrom: Also, I think applying surface last is wierd, because it's more important than many of the later arguments, for example, a drawingOptions data at the end.
21:11:07 <dolio> lostman: Another potentially helpful fact is that, I believe, a projection functor P1 : A x B -> A is adjoint to a constant functor K : A -> A^B.
21:11:29 <sshc> < pikhq> That link is rather nasty.
21:11:32 <sshc> pikhq: you actually opened it?
21:12:01 <dolio> So you might expect the adjoint to (-)A to be similar, given that F : C -> Sets is like a projection from a product, for discrete C.
21:12:25 <dolio> Er, F is like a product, and (-)A is like a projection from such products.
21:12:45 <lostman> i can't really see why F is like a product
21:13:59 <pikhq> sshc: I wget'd it.
21:14:09 <pikhq> And "browsed" it with less.
21:14:37 <pikhq> Much goatse.
21:14:49 <copumpkin> what's a good way to rate limit an IO action? is the best way to just call threadDelay and calculate the rate?
21:15:07 <copumpkin> or is there a way to say I don't want more than 100k of these per unit time, but otherwise keep running it?
21:16:20 <copumpkin> and is there a bytestring-based xml parser somewhere?
21:16:58 <kmc> threadDelay is only one part, you'd have to measure times
21:17:33 <copumpkin> yeah
21:17:53 <kmc> which btw gettimeofday can be expensive on some systems
21:18:04 <kmc> at least if you're counting microseconds
21:18:14 <copumpkin> well, I don't need it to be uniformly spaced, so I can just fire off all the requests and then wait for a while until my time period expires
21:18:21 <kmc> ah, that's cool
21:18:31 <kmc> fork a thread for each, delay, repeat
21:18:49 <kmc> <3 lightweight threads
21:18:57 <copumpkin> good idea
21:21:28 --- mode: monochrom set -R
21:21:45 <copumpkin> I want a nice simple specification for transforming XML into haskell types
21:22:08 <copumpkin> and then not have to worry about the details
21:23:13 <lostman> dolio: anyway, thanks for help; maybe i'll figure something out tomorrow
21:28:59 <ddarius> copumpkin: http://valerieaurora.org/synthesis/SynthesisOS/ch6.html
21:29:41 <copumpkin> ddarius: ?
21:29:46 <monochrom> copumpkin: Inside HXT haddock, look for "Pickle". Further options are http://hackage.haskell.org/package/regular-xmlpickler , http://hackage.haskell.org/package/hexpat-pickle , http://hackage.haskell.org/package/generic-xml , http://repetae.net/computer/haskell/DrIFT/
21:31:12 <agyd> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:12 <agyd> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:12 <agyd> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:12 <aldueibrfc> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:12 <aldueibrfc> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:12 <aldueibrfc> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:12 <fhsfactytln> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:12 <fhsfactytln> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:12 <fhsfactytln> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:13 <agyd> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:13 <aldueibrfc> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:13 <fhsfactytln> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:15 <agyd> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:15 <aldueibrfc> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:15 <fhsfactytln> http://upload.wikipedia.cx/wikipedia/commons/i/in/Internet_trolls.jpg
21:31:17 --- mode: monochrom set +R
21:31:18 <copumpkin> @where ops
21:31:19 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
21:31:48 <copumpkin> wow
21:31:50 --- mode: monochrom set +b *!*@89.31.88.211
21:32:11 <copumpkin> pretty lame to try to spam from a single ip
21:32:16 <copumpkin> even 14-year-olds can do better than that
21:32:52 --- mode: monochrom set +b *!*@ppp91-76-87-111.pppoe.mtu-net.ru
21:38:08 <copumpkin> why do packages like hxt have broken docs on hackage?
21:38:20 <monochrom> because of build failure
21:38:52 <copumpkin> it doesn't claim there was a build failure though
21:39:05 <monochrom> eh, that one is weird, no build attempt reported at all.
21:39:47 <monochrom> The home page of hxt has haddock.
21:39:51 <copumpkin> ugh, it's so dauntingly big
21:40:10 <SamB_XP> maybe it daunted the hackage server as well ;-P
21:40:13 <monochrom> Oh, if you are new to hxt, try the other choices.
21:40:21 <copumpkin> people need to learn to not cram everything they can think of into a package :P
21:40:26 <copumpkin> monochrom: yeah, I will
21:40:54 <SamB_XP> copumpkin: yeah, it feels like they just forgot to not export every damn function, for starters ;-P
21:41:34 * copumpkin might just use ruby for this task :/
21:44:54 * monochrom writes some fluffy essay on "the cathedral and the iphone: take 150 years to fulfill one purpose and fulfill it well, vs release often, obsolete often, profit often, and cram everything into it"
21:46:07 <uman> monochrom: hehehe
21:46:16 <SamB_XP> monochrom: well, I think I'd prefer to be somewhere in the middle there ...
21:46:26 <tensorpudding> 150 years?
21:46:27 <SamB_XP> I mean, I don't want to have to update daily!
21:46:43 <copumpkin> my problem is that the hs-twitter library isn't really very suitable for me
21:46:46 <uman> the main purpose of a cathedral is to perpetuate a belief in magic
21:46:57 <SamB_XP> even the bzr people have figured out that THAT isn't very popular ;-)
21:47:01 <tensorpudding> they can look pretty though
21:47:12 <copumpkin> but to query twitter I need to do http and xml/json parsing
21:47:27 <SamB_XP> uman: I though it was to defy gravity!
21:48:14 <uman> SamB_XP: Nope.
21:48:25 <SamB_XP> and yes, those stained glass windows can look mighty pretty
21:48:32 * copumpkin gets frustrated with haskell for the first time in a while
21:48:44 <tensorpudding> as much as i am opposed to churches in general
21:48:51 <SamB_XP> oh, lets not forget: you can get away with painting naked people on the ceilings and such like!
21:48:59 <tensorpudding> i like the idea of spending a long time building a beautiful, grand structure
21:49:51 <SamB_XP> yes, it's too bad the human race doesn't have the attention span for it anymore :-(
21:49:53 <uman> tensorpudding: doesn't it sort of ruin it that the only reason they built it was to glorify a mythical creature and perpetuate belief in the same?
21:49:54 <tensorpudding> there aren't many buildings anymore which signifiy long-termness
21:50:17 <SamB_XP> uman: what, the flying spaghetti monster ?
21:50:54 <tensorpudding> if there were a secular temple that emphasized the progress of humanity, that was built on the vastness of scale as, say, the Sagrada Familia, that would be pretty sweet
21:51:07 <SamB_XP> tensorpudding: WHAT progress ?
21:51:14 <uman> SamB_XP: God/Allah/FSM/Whatever
21:51:28 <uman> SamB_XP: whichever name you use for this concept, it's bullshit all the same.
21:51:48 <monochrom> Ha look what I started.
21:51:52 <copumpkin> #haskell-blah :)
21:51:56 <SamB_XP> no, no, it's politicians and lousy business students that worship bullshit
21:52:02 * copumpkin is trying to bitch about xml library complexity here
21:52:16 <SamB_XP> probably also some women's studies people and such like ...
21:52:51 <SamB_XP> copumpkin: you don't have to bitch about it
21:52:55 <SamB_XP> we ALREADY KNOW
21:53:00 <SamB_XP> and yes, it sux
21:53:03 <copumpkin> the xml library seems less painful
21:53:18 <SamB_XP> oh, I thought you were still talking about HXT ;-P
21:53:30 <copumpkin> hxt is so daunting I'm not even going to try
21:53:52 <copumpkin> if you're going to make something that massive, you'd better have a lot of docs, examples, and the like
21:54:17 <SamB_XP> (it's the overwhelming number of exports in HXT that sux -- it seems like it could be really nice if trimmed down and docced up!)
21:54:38 <copumpkin> make something that sits on top of it and exports the right stuff
21:54:45 <copumpkin> a package whose only dependency is hxt :)
21:55:00 <copumpkin> all I want to do is parse the world's simplest xml structure
21:55:03 <monochrom> copumpkin: an xml library is huge because xml is huge. by that I mean extra parts like dtd, namespace, xslt, relax-ng...
21:55:05 <copumpkin> key/value associations
21:55:19 <copumpkin> monochrom: yeah, but most people don't/shouldn't care about most of that stuff
21:55:26 <SamB_XP> monochrom: it could still be at least more clearly organized than HXT is!
21:55:32 <copumpkin> we come up with nice abstractions elsewhere, why can't we here :)
21:55:41 <uman> "we"
21:55:48 <copumpkin> the haskell/fp community
21:56:05 <SamB_XP> I mean, the relax-ng and HXT stuff is mostly well contained, I'm pretty sure ...
21:56:56 <SamB_XP> but stuff closer to the core seems, well, a lot like my desk I guess
21:57:16 <SamB_XP> lots of useful stuff on it, but it's hard to find anything and there's far too much clutter
22:17:04 <taruti> couldn't they re-export a "simple" api?
22:17:19 <taruti> and offer the full api in an another module
22:17:55 <SamB_XP> taruti: they have dozens of modules!
22:18:11 <taruti> yes, I know.
22:18:14 <Veinor> oh hey when did we get +R?
22:18:16 <SamB_XP> many of them seem to export stuff that should have been hidin inside some .Base. module
22:25:13 * copumpkin settles on just using the ruby twitter library until he gets time to fix the situation here :P
22:27:09 <monochrom> Veinor: We got +R 1.5 hours ago because of a famous spamming.
22:30:21 <bwr> What is +R
22:31:27 <monochrom> unregistered people can't speak.
22:35:14 <Veinor> ah
22:35:20 <Veinor> co/pumpkin
22:35:40 <copumpkin> :o
23:12:58 <copumpkin> what's the nicest date/time api for haskell?
23:14:34 <monochrom> Data.Time.*
23:15:49 <monochrom> The «time» package. It comes with ghc.
23:15:59 <copumpkin> ah
23:17:09 <dolio> @tell lostman I figured out the answer, in case you're interested.
23:17:09 <lambdabot> Consider it noted.
23:17:25 <Geheimdienst> so, does anyone have darcs running with ghc-6.12? for me it won't compile, because ghc comes with array-0.3 but darcs depends on array-0.2
23:18:06 <Geheimdienst> btw, this seems to affect the darcs package in cabal and the current version in the darcs repo
23:19:35 <Saizan> ghc-6.12 is still in a sort of pre-release state
23:19:49 <Saizan> you might ask on #darcs when they intend to support it
23:20:16 <Saizan> or you can hack the .cabal file and hope :)
23:23:05 <Geheimdienst> ah i see. i thought 6.12 was stable, because that's what arch linux gave me when i said i want ghc ...
23:23:29 <Geheimdienst> i guess i'll hack the cabal file. today is a good day to die.
23:26:36 <Saizan> it's mostly meant as a release for developer to use so that their packages will build when 6.12.2 comes out :)
23:26:46 <Saizan> *developers
23:29:18 <mwc_> Geheimdienst: IIRC, GHC 6.12.1 is only in [testing]
23:33:07 <Geheimdienst> hm ... well, when you just say "pacman -S ghc", and it serves you 6.12: http://www.archlinux.org/packages/extra/i686/ghc/
23:33:30 <Geheimdienst> i guess the core issue is that arch is not for sissies
23:33:44 <monochrom> heh
23:45:13 --- mode: monochrom set -R
23:51:28 <tensorpudding> > fix error
23:51:29 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
23:51:49 <mtnviewmark> I'm getting a very perplexing error trying to install happstack
23:52:00 <mtnviewmark> when I cabal install happstack-data
23:52:07 <mtnviewmark> it fails with this cryptic error
23:52:18 <mtnviewmark> unknown symbol `_sybzmwithzmclasszm0zi6_DataziGenericsziSYBziWithClassziInstances_dataTypeZMabOQZN_closure'
23:52:44 <copumpkin> preflex: zdec _sybzmwithzmclasszm0zi6_DataziGenericsziSYBziWithClassziInstances_dataTypeZMabOQZN_closure
23:52:45 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- _syb-with-class-0.6_Data.Generics.SYB.WithClass.Instances_dataType[abOQ]_closure
23:52:48 <mtnviewmark> this happens when compiling a file that uses TemplateHaskell and it appears to happen in that phase where ghc is running ghci
23:53:14 <mtnviewmark> I poked a bit at my lib files for syb-with-class
23:53:26 <mtnviewmark> and they don't have that dataType[abOQ]
23:53:31 <mtnviewmark> plenty of others, but not that one
23:54:02 <mtnviewmark> alas, the list of libs loaded by ghci doesn't seem to help
23:54:14 <mtnviewmark> as the one that caused the error doesn't print
23:54:15 <mtnviewmark> last line is:
23:54:25 <mtnviewmark> Loading package HaXml-1.13.3 ... linking ... done.
23:54:31 <mtnviewmark> after loading MANY packages
23:54:52 <mtnviewmark> all of which is also odd, ad the file being compiled, Happstack/Data/Proxy.hs
23:55:03 <monochrom> the function name is dataType. [abOQ] are probably some strict flags etc.
23:55:06 <mtnviewmark> doesn't use HaXml -- nor does anything it includes
