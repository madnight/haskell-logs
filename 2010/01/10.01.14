00:01:51 <tensorpudding> > filter even [1..10]
00:01:52 <lambdabot>   [2,4,6,8,10]
00:01:52 <cjs> fishey: In a network protocol, I'm supposed to give the IP address of the client to the server in a 12-char field as four three-digit decimal representations of octets, with nothing between them.
00:02:03 <cjs> However, they don't actually seem to care much if it's correct.
00:02:59 <fishey> gotcha.
00:10:12 <Amigoo> :t Bool
00:10:13 <lambdabot> Not in scope: data constructor `Bool'
00:10:19 <Amigoo> @src Bool
00:10:19 <lambdabot> data Bool = False | True deriving (Eq, Ord)
00:14:51 <kmc_> :k Bool
00:14:52 <lambdabot> *
00:14:52 <kmc_> :t True
00:14:54 <lambdabot> Bool
00:16:28 <Amigoo> @src filter
00:16:28 <lambdabot> filter _ []     = []
00:16:29 <lambdabot> filter p (x:xs)
00:16:29 <lambdabot>     | p x       = x : filter p xs
00:16:29 <lambdabot>     | otherwise = filter p xs
00:28:05 <pao> hmmm ... I'm trying to understand if vim/emacs can be configure so that when I try to "tab complete" after 'openFile "foo"' I can cycle on open modes...
00:29:15 <cizra> What are open modes? Read-only & Read-Write?
00:32:20 <dmwit> pao: Well, it should be possible, though you'll likely have to write some code for it.
00:32:25 <dmwit> pao: See omnicomplete.
00:32:45 <dmwit> (for vim)
00:32:54 <pao> dmwit: I hoped that someone already did it for me :-)
00:33:21 <dmwit> Not that I know of.
00:33:49 <pao> dmwit: I'm testing haskellmode omincomplete by Reinke... but either it is not optimal either I'm missing some pieces
00:35:28 <dmwit> Hm, I have an old version of Reinke's plugins.
00:35:39 <dmwit> Yay! =)
00:38:02 <merehap> yay ghc 12.1 is out for Arch
00:53:44 <Amigoo> @src filter
00:53:44 <lambdabot> filter _ []     = []
00:53:44 <lambdabot> filter p (x:xs)
00:53:44 <lambdabot>     | p x       = x : filter p xs
00:53:44 <lambdabot>     | otherwise = filter p xs
00:54:30 <Amigoo> is p the function "_"?
00:54:38 <tensorpudding> no
00:54:49 <tensorpudding> it's doing a pattern match
00:55:03 <tensorpudding> in the first line, it's matching the second argument with [], the empty list
00:55:04 <Amigoo> :t filter
00:55:05 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:55:19 <Amigoo> doesn't p :: a -> Bool?
00:55:25 <tensorpudding> the _ means that you don't want haskell to bother to bind the first argument to a variable
00:55:45 <tensorpudding> yes, p is the first argument, and it has type (a -> Bool)
00:56:04 <tensorpudding> the first line says "ignore the first argument when you see the second argument is [], and just return []
00:56:30 <tensorpudding> if pattern matching on the first line fails, it goes to the second line
00:56:49 <tensorpudding> where it binds the first argument to p, and the second argument gets matched to (x:xs)
00:56:49 <Amigoo> so f(p,[])=[]
00:56:58 <Amigoo> ?
00:57:07 <tensorpudding> that's not the way that the syntax goes, it would go more like
00:57:21 <tensorpudding> > filter undefined []
00:57:22 <lambdabot>   []
00:57:54 <Amigoo> what is "pattern matching"?
00:58:06 <tensorpudding> @src not
00:58:07 <lambdabot> not True   =  False
00:58:07 <lambdabot> not False  =  True
00:58:15 <tensorpudding> ^ that is pattern matching
00:58:36 <Amigoo> so both p and [] is an argument?
00:58:50 <tensorpudding> think of it this way
00:58:53 <tensorpudding> @type filter
00:58:54 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:59:17 <tensorpudding> filter is a function that, if you give it a function (a -> Bool), and a list of type [a], it will return a list of type [a]
00:59:49 <Amigoo> ok, but my tutorial says to crease this filter function on my own
00:59:55 <Amigoo> create*
01:00:18 <Amigoo> I don't know how to create a function :: a -> bool
01:00:37 <tensorpudding> you don't have to create a function like that in order to create filter
01:00:40 <merehap> @let myfun x = True
01:00:42 <lambdabot>  Defined.
01:00:51 <merehap> myfun 3
01:00:55 <merehap> >myfun 3
01:01:02 <merehap> > myfun 3
01:01:03 <Tordmor> Amigoo, and you thougt it a good idea to look for the source of filter to do that? You might have missed the point of the exercise.
01:01:03 <lambdabot>   True
01:01:30 <Amigoo> the tutorial said it's fine to look at anything as long as I understand
01:01:43 <merehap> :t myfun
01:01:44 <Amigoo> well, the tutorial is my friend teaching me actually
01:01:44 <lambdabot> forall t. t -> Bool
01:01:48 <tensorpudding> the argument of filter that is called p is the function that determines whether a value is filtered or not
01:02:06 <tensorpudding> you don't need to know what that function is to define filter
01:02:19 <tensorpudding> and therefore, filter works with any function that has that type
01:02:46 <Amigoo> how do I make a function that has :: a-> Bool so I can use it in the filter function?
01:02:54 <merehap> I just showed you
01:03:05 <Amigoo> o
01:03:06 <merehap> @src myfun
01:03:07 <lambdabot> Source not found. Just what do you think you're doing Dave?
01:03:16 <tensorpudding> Amigoo: first, do you know what it means to have type a -> Bool?
01:03:23 <tensorpudding> specifically, what a means?
01:03:39 <Amigoo> you input a and Bool comes out
01:03:42 <Amigoo> a is anything
01:03:49 <tensorpudding> yes, a is type variable
01:03:54 <merehap> > isfun 3
01:03:55 <lambdabot>   Not in scope: `isfun'
01:04:03 <tensorpudding> unless it is restricted, it can be any type at all
01:04:08 <merehap> @let isfun x = True
01:04:10 <lambdabot>  Defined.
01:04:18 <merehap> > isfun 4
01:04:20 <lambdabot>   True
01:04:31 <tensorpudding> this is parametric polymorphism, sometimes known as generics in other languages
01:04:34 <Amigoo> @let notfun x= false
01:04:35 <lambdabot>  <local>:12:10: Not in scope: `false'
01:04:38 <Amigoo> notfun 44
01:04:43 <Amigoo> >notfun 44
01:04:46 <tensorpudding> you need to put False, not false
01:04:46 <merehap> capital F
01:04:54 <Amigoo> @let notfun x= False
01:04:55 <lambdabot>  Defined.
01:04:58 <Amigoo> >notfun 44
01:05:03 <merehap> space after >
01:05:07 <Amigoo> > notfun 44
01:05:08 <lambdabot>   False
01:05:23 <Amigoo> hmmm
01:05:33 <merehap> @let isA x = x == 'a'
01:05:34 <lambdabot>  Defined.
01:05:39 <merehap> > isA 'b'
01:05:41 <lambdabot>   False
01:05:44 <merehap> > isA 'a'
01:05:45 <lambdabot>   True
01:05:52 <Amigoo> ok
01:05:57 <Amigoo> I think i am getting it
01:06:13 <Amigoo> :t filter
01:06:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:06:24 <merehap> try to make a function isGreaterThan3
01:06:59 <Amigoo> @let isGreaterThan3 x = If x> True else False
01:06:59 <lambdabot>   Parse error: KW_Else
01:07:13 <Amigoo> @let isGreaterThan3 x = If x> 3 True else False
01:07:13 <lambdabot>   Parse error: KW_Else
01:07:17 <merehap> almost
01:07:23 <Amigoo> @let isGreaterThan3 x = If x >= 3 True else False
01:07:23 <lambdabot>   Parse error: KW_Else
01:07:28 <merehap> get rid of if then else
01:07:45 <merehap> @let isGreaterThan3 x = x > 3
01:07:45 <Amigoo> @let isGreaterThan3 x = If x >= 3 then True
01:07:46 <lambdabot>   Parse error: KW_Then
01:07:46 <lambdabot>  Defined.
01:07:58 <tensorpudding> you need if, then and else
01:08:02 <merehap> > isGreaterThan3 2
01:08:04 <lambdabot>   False
01:08:13 <Amigoo> o
01:08:18 <merehap> (that's my version)
01:08:21 <Amigoo> @let isGreaterThan3 x = If x >= 3 then True else False
01:08:22 <lambdabot>   Parse error: KW_Then
01:08:29 <merehap> lower case if
01:08:33 <merehap> and you are good
01:08:36 <merehap> @undefine
01:08:46 <Amigoo> @let isGreaterThan10 x = if x >= 10 then True else False
01:08:47 <lambdabot>  Defined.
01:09:00 <merehap> good, test it
01:09:10 <Amigoo> so how does the bot knows that if it's less than 3 it's false? you never told it
01:09:28 <merehap> that is what the > function does
01:09:38 <merehap> you can think of it as built in
01:09:45 <merehap> > 3 > 2
01:09:46 <lambdabot>   True
01:09:49 <Amigoo> >isGreaterThan 10 4
01:09:52 <merehap> > 5 < 10
01:09:53 <Amigoo> > isGreaterThan 10 4
01:09:54 <lambdabot>   True
01:09:54 <lambdabot>   Not in scope: `isGreaterThan'
01:10:05 <merehap> you put a space there
01:10:13 <merehap> > isGreaterThan10 4
01:10:14 <lambdabot>   False
01:10:27 <Amigoo> > isGreaterThan10 4
01:10:28 <lambdabot>   False
01:10:29 <tensorpudding> that's the thing, is that > is a function, it has a type
01:10:30 <Amigoo> oh ok
01:10:35 <tensorpudding> @type (>)
01:10:36 <lambdabot> forall a. (Ord a) => a -> a -> Bool
01:10:49 <tensorpudding> @type (3 > 2)
01:10:50 <lambdabot> Bool
01:11:03 <Twey> > let isGreaterThanTen = (> 10) in isGreaterThanTen 4
01:11:05 <lambdabot>   False
01:11:16 <merehap> > 'a' > 'b'
01:11:18 <lambdabot>   False
01:11:27 <merehap> > 'z' > 'y'
01:11:28 <lambdabot>   True
01:11:39 <tensorpudding> of course, not all types are able to be ordered with >
01:11:50 <Amigoo> I see
01:11:59 <tensorpudding> also, the two arguments have to have the same type
01:12:02 <merehap> > pi > 3
01:12:03 <tensorpudding> which might bite you
01:12:03 <Twey> if x then True else False = x for all x
01:12:04 <lambdabot>   True
01:12:08 <Twey> That goes for most programming languages
01:12:22 <Amigoo> so to create this filter function, I have filter' :: (a -> Bool ) -> [a] -> [a]
01:12:22 <Amigoo> filter' f [] = []
01:12:22 <Amigoo> filter' f (x:xs) = f x : filter' f xs
01:12:30 <Twey> That's a map
01:12:48 <Amigoo> so how do I fix it?
01:12:59 <tensorpudding> well, first, what does filter actually do?
01:13:00 <Twey> You need to not include x if ‘f x’
01:13:05 <Twey> Oh
01:13:08 <Twey> Sorry :þ
01:13:41 <Amigoo> filter takes function :: a -> Bool and list [a] and make it [a]
01:14:08 <merehap> > filter (<3) [1,9,4,2,3]
01:14:09 <tensorpudding> yes, that is the type
01:14:09 <lambdabot>   [1,2]
01:14:20 <tensorpudding> but what exactly does it do?
01:14:41 <Amigoo> hmmm
01:14:45 <Amigoo> give me a second to think
01:15:04 <Amigoo> takes a function and a list to give back a list
01:15:21 <merehap> how does the new list relate to the old list?
01:15:25 <tensorpudding> obviously, the function, when applied to a value, will return a boolean
01:15:26 <merehap> what is different?
01:15:41 <Amigoo> the new list will have been filtered based on the function
01:15:53 <tensorpudding> so you can differentiate values in the list by what the function does to them
01:15:59 <tensorpudding> yes
01:16:28 <Amigoo> so my filter' :: (a -> Bool ) -> [a] -> [a]
01:16:28 <Amigoo> <Amigoo> filter' f [] = []
01:16:30 <Amigoo> is right?
01:16:45 <tensorpudding> yes
01:16:53 <tensorpudding> obviously, an empty list can't be filtered
01:17:00 <Amigoo> yea
01:17:52 <Amigoo> so filter' f (x:xs) = True if a...
01:17:56 <Amigoo> I don't know how to do this
01:18:02 <Amigoo> it's confusing
01:18:25 <tensorpudding> the filter has to return a list, it can't return a bool
01:18:50 <Amigoo> is f the bool?
01:18:53 <tensorpudding> but say your list is [1,2,3,4,5], and the function returns True if the value is even, false otherwise
01:18:58 <tensorpudding> f is the filter function
01:19:06 <tensorpudding> err, the function which you are filtering by
01:19:25 <merehap> > filter even [1,2,3,4,5]
01:19:26 <tensorpudding> so you have a list, and the first element of the list is bound to x
01:19:27 <lambdabot>   [2,4]
01:19:36 <tensorpudding> so you want to see what f x is
01:19:54 <tensorpudding> f x is type bool, and what it returns will determine what you do
01:20:28 <tensorpudding> f x determines "does x pass the filter?"
01:20:35 <tensorpudding> if True, you want it in the list
01:20:40 <tensorpudding> if False, you don't want it in the list
01:20:44 <Amigoo> so if say f x is True and I want to keep it
01:20:56 <Amigoo> how do I write it down in Haskell?
01:20:57 <tensorpudding> you can express this in an if then else
01:21:01 <tensorpudding> for example
01:21:25 <Amigoo> so filter' f (x:xs) = if f x == true??
01:21:34 <tensorpudding> if (f x) then (code that keeps x in list) else (code that ignores x)
01:21:48 <merehap> you don't need the == True
01:21:54 <Amigoo> o
01:21:56 <cads> have we phrased the problem of filtering a list in terms of choosing what to do with the head of the list, and letting the rest of the list be dealt with later?
01:21:58 <merehap> you can if you want it, it is just redundant
01:22:07 <tensorpudding> that's not finished yet, you need to do something with xs, the part that is bound to the rest of the list
01:22:29 <merehap> cads: no
01:22:45 <tensorpudding> the idea is that you recurse over the rest of the list, by calling filter on xs
01:23:19 <tensorpudding> it's like if you have a stack of papers to sign
01:23:23 <Amigoo> filter' f (x:xs) = if f x : filter f xs
01:23:34 <Amigoo> How do I say if True I want to keep it
01:23:38 <tensorpudding> you take the first one off, sign it, and then you repeat on the remaining stack, until you have no more papers left
01:23:51 <tensorpudding> Amigoo: you need an if then else statement
01:24:11 <tensorpudding> so we have if (f x) then (some code) else (other code)
01:24:15 <Amigoo> the first paper is x, and the rest pile is xs
01:24:23 <merehap> yes
01:24:32 <cads> Amigoo: you want to say "If true, I want to build a list that contains that element as a beginning, if false, I want to build a list without that element as the beginning"
01:24:54 <Amigoo> so True compared to what?
01:24:59 <Amigoo> what is True??
01:25:05 <kalven> not false
01:25:11 <tensorpudding> the (some code) should keep x, and the (other code) should ignore x
01:25:12 <merehap> > not False
01:25:12 <Amigoo> You can't say that
01:25:13 <lambdabot>   True
01:25:26 <Amigoo> that's redundand
01:25:27 <Jafet> True is a data constructor of the type Bool
01:25:34 <Amigoo> then not True is False
01:25:37 <kalven> Amigoo: the result of the predicate applied to the first element
01:25:37 <Jafet> The other constructor being False.
01:25:43 <merehap> > not True
01:25:44 <lambdabot>   False
01:25:58 <tensorpudding> but anyway
01:26:07 <cads>  Amigoo that was an abbreviation for "If my property function applied to the first element _results in_ True, then....."
01:26:21 <Amigoo> then keep it
01:26:26 <tensorpudding> if you want to express the recursive part, by applying filter to xs, how do you do that?
01:26:54 <Amigoo> you would have to add the filter' in itself
01:27:20 <tensorpudding> you call (filter' f xs)
01:27:58 <tensorpudding> do you see?
01:28:22 <Amigoo> filter' f (x:xs) = if f x : filter' f xs True then f x filter'
01:28:36 <Amigoo> filter' f (x:xs) = if f x : filter' f xs True then f x:filter' f xs
01:28:44 <tensorpudding> no
01:28:47 <merehap> almost
01:28:54 <tensorpudding> first of all, you need an else
01:29:00 <Amigoo> o
01:29:18 <tensorpudding> second of all, you don't want (f x) in the list, since that is a bool
01:29:21 <tensorpudding> and you want type a
01:29:24 <merehap> > if 5 > 3 then "Cool" else "how did that happen?"
01:29:26 <lambdabot>   "Cool"
01:29:26 <tensorpudding> so you keep x in the list as is
01:29:38 <Amigoo> f x : filter' f xs will make it a list
01:29:44 <tensorpudding> f x is the part you test
01:29:45 <Amigoo> no?
01:29:55 <tensorpudding> it will make it a list of type [Bool]
01:30:07 <tensorpudding> and it is essentially the same as map
01:30:12 <Amigoo> o
01:30:18 <tensorpudding> map says "take this function, and apply it to every element"
01:30:44 <tensorpudding> filter is different, because it removes elements based on a filter function
01:30:47 <tensorpudding> so anyway
01:30:52 <Amigoo> forAll :: (Int -> Int) -> [Int] -> [Int]
01:30:52 <Amigoo> forAll f [] =[]
01:30:52 <Amigoo> forAll f (x:xs) = f x :forAll f xs
01:31:06 <Amigoo> I made that one, it wasn't super bad
01:31:11 <Amigoo> I just can't comprehend Bool
01:31:18 <Jafet> @src Bool
01:31:18 <lambdabot> data Bool = False | True deriving (Eq, Ord)
01:31:21 <merehap> :t True
01:31:22 <lambdabot> Bool
01:31:23 <merehap> :t False
01:31:25 <lambdabot> Bool
01:31:26 <Amigoo> I am trying to use same logic
01:31:30 <Jafet> :t undefined::Bool
01:31:31 <lambdabot> Bool
01:31:36 <tensorpudding> filter f (x:xs) = if (f x) then _____ else ____
01:31:39 <tensorpudding> is what we have so far
01:31:49 <Amigoo> yea
01:32:00 <tensorpudding> the first blank should be "keep x in the list, and recurse on xs"
01:32:03 <merehap> Amigoo: try writing an if then else expression, forget filter for a second
01:32:08 <tensorpudding> the second blank should be "ignore x, recurse on xs"
01:32:13 <Amigoo> ok
01:32:23 <merehap> > if 3 > 5 then "hi" else "bye"
01:32:24 <lambdabot>   "bye"
01:32:25 <Amigoo> so f x says True?
01:32:32 <merehap> or False
01:32:39 <Amigoo> how do I know?
01:32:50 <merehap> depends on the function
01:32:54 <Amigoo> oh
01:32:57 <merehap> @let f = (>3)
01:32:58 <lambdabot>  Defined.
01:32:59 <tensorpudding> and on the value
01:33:01 <merehap> f 5
01:33:05 <merehap> > f 5
01:33:06 <lambdabot>   Ambiguous occurrence `f'
01:33:06 <lambdabot>  It could refer to either `L.f', defined at <local...
01:33:16 <merehap> @let myF = (>3)
01:33:17 <tensorpudding> it doesn't matter what the function is
01:33:17 <lambdabot>  Defined.
01:33:24 <Amigoo> ok
01:33:25 <merehap> > myF 4
01:33:27 <lambdabot>   True
01:33:30 <tensorpudding> it just matters what (f x) is
01:33:31 <merehap> > myF 2
01:33:33 <lambdabot>   False
01:33:46 <Amigoo> so my f in filter f (x:xs) = if (f x) then _____ else ____ is :: Bool?
01:33:49 <tensorpudding> and if it is true, then x is to be kept in the list, and if it is false, we discard x
01:33:54 <merehap> no
01:34:04 <tensorpudding> no, f is a function
01:34:08 <tensorpudding> (f x) is type Bool
01:34:11 <Amigoo> o
01:34:15 <Amigoo> ok ok
01:34:16 <merehap> :t myF
01:34:17 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
01:34:20 <tensorpudding> but the first blank, we keep x in the list
01:34:22 <merehap> :t myF 3
01:34:24 <lambdabot> Bool
01:34:26 <tensorpudding> so the first blank should have x
01:34:43 <tensorpudding> but we also need the recursive part
01:34:44 <tensorpudding> so
01:34:50 <Amigoo> let's just say f x is True
01:35:05 <Amigoo> then x, which x::a?
01:35:26 <tensorpudding> x is type a, whatever a is doesn't matter
01:35:29 <Amigoo> ok
01:35:36 <tensorpudding> so f x is True, so we keep x
01:35:42 <Amigoo> ok
01:35:48 <tensorpudding> so the first blank is x : (filter f xs)
01:35:59 <Amigoo> can a be [int]?
01:36:04 <merehap> yes
01:36:05 <Beelsebob> it can be anything
01:36:06 <merehap> anything
01:36:06 <tensorpudding> yes
01:36:08 <Beelsebob> that's what 'a' means
01:36:16 <Amigoo> ok
01:36:26 <Amigoo> so why do we need x:xs?
01:36:34 <Amigoo> doesn't that apply to list?
01:36:38 <tensorpudding> because we can only work at one value in the list at a time
01:36:39 <merehap> yes
01:36:42 <tensorpudding> that's why we have recursion
01:36:57 <tensorpudding> we take a value of, call it x, and work with it, and then call the function on the remaining stack
01:37:07 <Amigoo> but if x is list, how can we work in the list 1 at a time?
01:37:19 <merehap> x isn't a list
01:37:19 <tensorpudding> if x is a list, then (x:xs) is a list of lists
01:37:24 <merehap> it is the head element of the list
01:37:25 <Amigoo> oo
01:37:28 <merehap> (x:xs) is a list
01:37:31 <tensorpudding> and we take each list in the list of lists at a time
01:37:38 <Amigoo> ok
01:37:44 <cads> that's called a pattern, it matches our list and gives us handles to the only two parts of the list we can hold at one time, x, which is the head, or first element of the list, and xs, which is a list containing the rest of the elements
01:37:47 <Amigoo> so going back to f x as tensor
01:37:55 <Amigoo> i mean as bool
01:37:59 <cads> hehe
01:38:24 <Amigoo> ok, so if f x is True, then I keep x
01:38:28 <tensorpudding> yes
01:38:32 <Amigoo> if false, how do I say "throw away"?
01:38:41 <tensorpudding> you return x, and attach the remaining recursive part
01:38:56 <tensorpudding> Amigoo: you don't return x, just the recursive part
01:38:59 <Amigoo> so filter' xs?
01:39:03 <merehap> good
01:39:08 <tensorpudding> filter' f xs
01:39:12 <tensorpudding> you need to keep passing it f
01:39:12 <merehap> you still need to pass the function down though
01:39:19 <tensorpudding> but yes
01:39:20 <Amigoo> ok
01:39:24 <tensorpudding> so now you have your whole function
01:39:35 <Amigoo> so that will be the second element on my list?
01:39:43 <tensorpudding> well, that's the thing
01:39:43 <merehap> the rest of your list
01:39:48 <apfelmus> Hello :)
01:39:56 <tensorpudding> you run it on the first element, and it calls (filter' f xs)
01:39:58 <Amigoo> hello apfelmus
01:40:05 <apfelmus> :)
01:40:09 <apfelmus> Is there a way to install extra documentation with cabal?
01:40:11 <merehap> eine apfel
01:40:16 <tensorpudding> and then the pattern matcher binds xs to (x:xs), and peels off the next element
01:40:47 <Amigoo> and the next x will be applied to function f?
01:40:53 <cads> remember the : operator doesn't take two elements, it takes an element and conses it on to the beginning of a list
01:40:57 <Amigoo> and create a Bool?
01:41:05 <Amigoo> ok
01:41:10 <tensorpudding> yes, and then depending on that bool, that x will be kept
01:41:15 <Amigoo> ok
01:41:18 <tensorpudding> let's try it by hand on a simple list
01:41:19 <apfelmus> I.e. I have a package (cabbage?) that not only contains haddock but also another html file.
01:41:21 <Amigoo> i c ic
01:41:25 <Twey> Hmmmm
01:41:34 <tensorpudding> filter' f [1,2,3,4,5]
01:41:41 <apfelmus> And I'd like to install that at the same place as the haddock files or something.
01:41:49 <tensorpudding> so we match [1,2,3,4,5] as (x:xs)
01:41:57 <tensorpudding> which means that x = 1, and xs = [2,3,4,5]
01:42:22 <Amigoo> so, so far we have filter' f (x:xs) = if (f x) then x else filter' f xs?
01:42:38 <tensorpudding> you forgot a bit
01:42:42 <tensorpudding> that should be
01:42:45 <merehap> in the first case, you need to hold on to the rest of the list
01:43:02 <tensorpudding> filter' f (x:xs) = if (f x) then x : (filter f xs) else filter' f xs
01:43:09 <Jafet> > let filter' f = foldr ($) [] . map (\x -> if f x then (x:) else id) in filter' even [1..]
01:43:11 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
01:43:15 <Amigoo> ok, I was wondering about that
01:43:50 <tensorpudding> the first option says "put x in, then filter the rest", the second says "just filter the rest" and x is not included
01:44:25 <Amigoo> so it will keep going until filter f xs is done?
01:44:28 <Amigoo> inside itself?
01:44:39 <tensorpudding> it'll keep calling itself
01:44:43 <merehap> well, that is what your base case is for
01:44:45 <tensorpudding> until it runs out of elements
01:44:52 <merehap> filter' f [] = []
01:44:53 <tensorpudding> and then it calls filter' f []
01:44:58 <tensorpudding> and then it matches the first cast, and returns []
01:45:03 <Amigoo> oh wow, that's amazing, imagine if you have to do that 1 by 1
01:45:17 <merehap> yes, it would become quite tedious :)
01:45:32 <merehap> instead, you have the wonder of recursion
01:45:33 <tensorpudding> essentially, the filter' f [] = [] is the "catch"
01:45:48 <tensorpudding> people call it the "base case", it allows the recursion to end
01:46:30 <tensorpudding> say we had a one-element list
01:46:47 <Amigoo> but if it's false, then it will go on to the next one right?
01:46:56 <merehap> correct
01:46:58 <tensorpudding> so filter' f [1] = if (f 1) then 1:(filter f []) else filter f []
01:47:03 <merehap> it matches patterns
01:47:08 <Amigoo> say it's true, true, then false, then it's gonna go filter' f xs, then it's true again
01:47:22 <Amigoo> then it won't connect with the first one
01:47:26 <tensorpudding> but you can replace everywhere you see filter f [] with just []
01:47:36 <tensorpudding> so that means that you get either 1:[] = [1] or []
01:47:40 <tensorpudding> depending on f 1
01:48:01 <Amigoo> so my list is going to be split into the amount of false I have?
01:48:39 <merehap> if by false you mean "length", then yes
01:49:01 <merehap> well, the number of elements that match the condition
01:49:14 <merehap> yeah, I think you've got it
01:49:24 <Amigoo> well
01:49:32 <Amigoo> what i mean is
01:49:40 <merehap> > filter (<3) [1,2,3,4,5]
01:49:42 <lambdabot>   [1,2]
01:49:47 <Amigoo> so we have==> filter' f (x:xs) = if (f x) then x : (filter' f xs) else filter' f xs
01:49:58 <merehap> there are two elements that that is true for, so the resulting list has length 2
01:50:00 <Amigoo> say first time, f x comes out true
01:50:04 <cads> note, you could say something like
01:50:04 <cads>  filter' f (x:xs) |  f x  = x : (filter' f xs)
01:50:04 <cads>                        | otherwise = filter' f xs
01:50:09 <Jafet> @hoogle if'
01:50:10 <lambdabot> No results found
01:50:19 <Jafet> Strange
01:50:27 <merehap> cads: we haven't done anything with guards
01:50:47 <Amigoo> say first time, f x comes out true, then it's going to go to filter' f xs right?
01:50:52 <tensorpudding> there are lots of different structure things
01:51:05 <tensorpudding> you call filter' f xs regardless
01:51:09 <merehap> either way it will go to filter' f xs
01:51:21 <merehap> you have to apply f for every element of the list
01:51:21 <Amigoo> then it will calculate filter f xs, and say it comes false
01:51:22 <tensorpudding> but if f x is true, then you put x on the list on top of filter' f xs
01:51:42 <Amigoo> x:the first one
01:51:50 <merehap> ?
01:51:53 <Amigoo> x will only be head of the first one
01:51:55 <Twey> filter = fmap rights . flip ap id . fmap (zipWith (Right ?? Left)) . map
01:51:56 <Amigoo> the first true
01:52:17 <tensorpudding> Twey: seriously?
01:52:22 <cads> jesus
01:52:29 <merehap> x will be the head everytime you call filter
01:52:32 <Twey> Apparently so
01:52:36 <merehap> you get a new head
01:52:49 <Amigoo> but if it's false, then the head x won't connect
01:52:57 <merehap> yes
01:53:16 <Jafet> @hoogle (??)
01:53:16 <lambdabot> No results found
01:53:17 <Amigoo> but it calculates again, if it's true, it still won't connect
01:53:20 <merehap> filter (>3) [4]
01:53:27 <merehap> > filter (>3) [4]
01:53:29 <lambdabot>   [4]
01:53:31 <Jafet> Twey, what
01:53:42 <merehap> > filter (>3) [3]
01:53:43 <lambdabot>   []
01:53:46 <Twey> @let (y ?? n) p = if p then y else n
01:53:47 <merehap> > filter (>3) [3,4]
01:53:48 <lambdabot>  Defined.
01:53:48 <lambdabot>   [4]
01:53:58 <merehap> > filter (>3) [3,4,2]
01:53:59 <lambdabot>   [4]
01:54:05 <merehap> > filter (>3) [3,4,2,5]
01:54:06 <lambdabot>   [4,5]
01:54:15 <Twey> > (fmap rights . flip ap id . fmap (zipWith (Right ?? Left)) . map) (> 3) [3, 4, 2, 5]
01:54:17 <lambdabot>   [4,5]
01:54:19 <merehap> Amigoo: see how that works?
01:54:25 <Jafet> Hah
01:54:32 <Amigoo> yea
01:54:51 <Amigoo> but I still don't get it
01:55:22 <merehap> Amigoo: have you looked at learn you a haskell?
01:56:36 <merehap> filter (>3) [6,1,5] is the same as 6 : filter (>3) [1,5]
01:56:57 <Amigoo> ok, let me do hand calculation first, then I'll come back
01:57:04 <merehap> 6 : filter (>3) [1,5] is the same as 6 : filter (>3) [5]
01:57:16 <cads> the thing you have to remember is that filter goes on inside itself, untill it's done
01:57:23 <Amigoo> yea
01:57:27 <merehap> 6 : filter (>3) [5] is the same as 6 : 5 : filter (>3) []
01:57:33 <Twey> … if you look at it
01:57:40 <Amigoo> but the thing is in filter' f (x:xs) = if (f x) then x : (filter' f xs) else filter' f xs, I don't know what happens to the old head when it goes false
01:57:42 <merehap> 6 : 5 : filter (>3) [] is the same as [6,5]
01:57:55 <merehap> it is gone forever
01:58:02 <Amigoo> pp
01:58:03 <Amigoo> ooo
01:58:08 <Amigoo> ok,now I get it
01:58:10 <merehap> you never passed it down
01:58:18 <Amigoo> so what happened to the Bool?
01:58:18 <merehap> you hate it and just want to get rid of it
01:58:28 <merehap> the Bool did it's job
01:58:28 <cads> it's consumed by the if
01:58:35 <cads> noms
01:58:39 <merehap> it determined whether you kept the head or not
01:58:45 <merehap> you don't need it any more
01:58:47 <xerox> > (fmap rights . join . (zipWith (Right ?? Left) .) . map) even [1..10]
01:58:48 <lambdabot>   [2,4,6,8,10]
01:58:53 <xerox> (flip ap id = join)
01:59:01 <Amigoo> it will be 6 : 5 : False, then it doesn't say to connect again
01:59:03 <merehap> it disappears into the void as well
01:59:11 <merehap> no, there is no False
01:59:21 <merehap> 6 : 5 : []
01:59:29 <merehap> > 6 : 5 : []
01:59:30 <lambdabot>   [6,5]
01:59:39 <Amigoo> let myFun x = x> 3
01:59:45 <merehap> we never put a bool into the list
01:59:45 <Amigoo> >let myFun x = x> 3
01:59:53 <merehap> @let myFun x = x > 3
01:59:53 <Amigoo> > let myFun x = x> 3
01:59:54 <lambdabot>   not an expression: `let myFun x = x> 3'
01:59:55 <lambdabot>  Defined.
02:00:08 <merehap> > myFun 4
02:00:09 <lambdabot>   True
02:00:11 <merehap> > myFun 2
02:00:13 <lambdabot>   False
02:00:34 <Amigoo> myFun 3
02:00:35 <merehap> > filter myFun [9,2,4,1,7]
02:00:37 <lambdabot>   [9,4,7]
02:00:40 <Amigoo> > myFun 3
02:00:41 <lambdabot>   False
02:00:52 <sinelaw> umm, pm?
02:01:01 <Amigoo> filter is not my problem, it's filter'
02:01:03 <Amigoo> filter' f (x:xs) = if (f x) then x : (filter' f xs) else filter' f xs
02:01:06 <Amigoo> the one we just made
02:01:29 <Jafet> @vixen private message me
02:01:30 <Twey> No need for any of those brackets
02:01:30 <lambdabot> i'm 19
02:01:37 <merehap> what specifically is the problem?
02:01:44 <Twey> Apart from the set in the pattern
02:01:52 <merehap> that is correct except it doesn't have the base case
02:01:54 <Amigoo> ok, here is the problem:
02:02:24 <Amigoo> say we want odd [1..10]
02:02:31 <Amigoo> 2, 4, 6...
02:02:33 <merehap> > filter odd [1..10]
02:02:35 <lambdabot>   [1,3,5,7,9]
02:02:36 <Amigoo> to throw away
02:02:39 <sinelaw> @vixen you know so many different replies
02:02:39 <lambdabot> yeah, i know
02:02:47 <sinelaw> @vixen smartass.
02:02:47 <lambdabot> you're cute. :)
02:02:59 <merehap> right
02:03:12 <merehap> we accomplish "throw away" by just not writing the x at all
02:03:16 <Amigoo> first time it goes through filter', it will be true right?
02:03:26 <merehap> yes, there for we keep it
02:03:29 <merehap> x :
02:03:48 <Amigoo> then it goes for filter' f xs after the x: right?
02:04:00 <merehap> yes, for the smaller sublist
02:04:05 <tensorpudding> so the first time we call filter' odd [1,2,3,4,5], we make x=1, and determine (odd 1)
02:04:09 <merehap> for the new x, it is false
02:04:24 <Amigoo> yea
02:04:30 <merehap> so we ignore x (we don't put it on the head of the resulting list)
02:04:30 <Amigoo> so when it's false?
02:04:41 <tensorpudding> and odd 1 is True, so we return 1:(filter' odd [2,3,4,5])
02:05:05 <tensorpudding> but this called filter on the smaller list, so we do the process over again
02:05:18 <tensorpudding> but we don't forget the 1 in front
02:05:23 <Amigoo> so then shouldn't it be filter' f (x:xs) = if (f x) then x : ((filter' f xs) else filter' f xs)?
02:05:30 <Amigoo> since I want to connect the earlier x
02:05:32 <Amigoo> the true one
02:05:39 <merehap> yes
02:05:44 <merehap> that is what we had
02:05:51 <Amigoo> we had filter' f (x:xs) = if (f x) then x : (filter' f xs) else filter' f xs
02:06:03 <merehap> what is the difference?
02:06:06 <tensorpudding> when you run the recursive step, the result is appended after the x
02:06:14 <Amigoo> the parentheses
02:06:22 <merehap> the parenthesis dont matter
02:06:23 <Amigoo> o
02:06:28 <tensorpudding> so anyway, we have 1:(filter' f [2,3,4,5])
02:06:38 <Amigoo> so the result is after the x
02:06:40 <tensorpudding> we now want to know what (filter' f [2,3,4,5]) is
02:06:42 <Amigoo> it never showed that
02:06:58 <Amigoo> because there is a gap of Bool False between it
02:07:02 <tensorpudding> so we pop the 2 off the front, and bind that to x, and check (odd 2)
02:07:17 <tensorpudding> but odd 2 is False, so we don't want to keep 2
02:07:23 <Amigoo> then the Bool stays there?
02:07:29 <merehap> no more bool
02:07:32 <merehap> we throw it away
02:07:39 <merehap> we aren't keeping the bool
02:07:42 <Amigoo> but x is head of the Bool
02:07:47 <merehap> no
02:07:54 <merehap> x is the head of the list
02:07:57 <Jafet> You have incredible patience
02:08:01 <merehap> a bool is true or false
02:08:03 <tensorpudding> so we return filter' odd [3,4,5], and in total we have 1:(filter' odd [3,4,5])
02:08:17 <merehap> Jafet: :)
02:08:44 <Jafet> But perhaps you should make sure Amigoo knows what beta reduction is
02:08:50 <tensorpudding> now we recurse again, pop the 3 off, and check (odd 3), it's True, so we have 1:3:(filter' odd [4,5])
02:09:03 <merehap> bool is true or false, list is [1,2,3,4]
02:09:03 <Amigoo> ok
02:10:00 <Jafet> And do use proper capitalization, because we're pedants
02:10:07 <Jafet> It's Bool, True and False.
02:10:31 <merehap> You forgot a period.
02:10:54 <Jafet> @vixen merehap thinks I have periods!
02:10:55 <lambdabot> i'm a huge baseball fan
02:11:27 <merehap> no, that's innings
02:11:36 <merehap> not periods, stupid vixen
02:11:52 <Jafet> Innings? Is that the sound made by a Tampax (R)?
02:12:23 <merehap> Well, you should know, you are the one who has periods.
02:12:56 <merehap> Amigoo: are you a bit more clear now?
02:13:01 <Amigoo> ok thank you guys, I will go through it by hand once, so I make sure I understand it properly
02:13:07 <Amigoo> yea, sort of
02:13:07 * hackagebot upload: afv 0.0.1 - Model checking Atom generated C. (TomHawkins)
02:13:17 <merehap> see how tensorpudding never kept a true false value (a bool)
02:13:43 <merehap> if Bool then List else List
02:13:58 <merehap> that is how the if statement is used
02:14:13 <tensorpudding> > if True then 5 else 8
02:14:14 <lambdabot>   5
02:14:20 <tensorpudding> > if False then 5 else 8
02:14:21 <lambdabot>   8
02:14:34 <merehap> if 5 > 3 then 5 else 8
02:14:44 <merehap> > if 5 > 3 then 5 else 8
02:14:49 <lambdabot>   5
02:15:01 <merehap> > if 2 > 9 then 5 else 8
02:15:08 <lambdabot>   8
02:15:28 <merehap> > True == 5 > 3
02:15:29 <lambdabot>   Precedence parsing error
02:15:30 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
02:15:30 <tensorpudding> but the boolean doesn't matter, the boolean is only telling you what to return, you don't actually return it
02:15:39 <merehap> > True == (5 > 3)
02:15:41 <lambdabot>   True
02:17:03 <merehap> Amigoo: I strongly suggest working your way through learnyouahaskell
02:17:20 <Jafet> > let (:) = (,); (p ? (a, b)) -> if p then a else b; in (True ? 1 : 0)
02:17:22 <lambdabot>   <no location info>: parse error on input `->'
02:17:28 <Jafet> > let (:) = (,); (p ? (a, b)) = if p then a else b; in (True ? 1 : 0)
02:17:29 <lambdabot>   <no location info>: Parse error in pattern
02:17:52 <Jafet> Meh
02:18:16 <merehap> you thought you could rebind cons?
02:18:35 <tensorpudding> @where lyah
02:18:35 <lambdabot> http://www.learnyouahaskell.com/
02:18:43 <Jafet> Apparently I can't bind (?) either, so it's moot
02:21:46 <idnar> > let (?)
02:21:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
02:21:49 <idnar> err
02:22:02 <idnar> > let (?) = (+) in 1 ? 2
02:22:03 <lambdabot>   3
02:22:26 <Jafet> Oh boy
02:22:34 <Jafet> > let (a ? b) = a + b in 1 ? 2
02:22:35 <lambdabot>   <no location info>: Parse error in pattern
02:22:55 <Amigoo> umm real quick, can someone tell me what's wrong with this?
02:22:56 <Baughn> > let a ? b = a + b in 1 ? 2
02:22:56 <Amigoo> Timestwo :: Int -> Int Timestwo x = 2*x
02:22:57 <Amigoo> Evenfun :: [Int] -> [Int] Evenfun [] = []
02:22:57 <Amigoo> Evenfun (x:xs) = if Timestwo x == 2*x then x:Evenfun Timestwo xs else Evenfun Timestwo xs
02:22:57 <lambdabot>   3
02:23:11 <Jafet> Right, I fail
02:23:14 <Baughn> Amigoo: Function names *must* start with a lowercase letter
02:23:23 <Baughn> Amigoo: Only types start with uppercase
02:23:24 <Amigoo> o
02:23:39 <idnar> Baughn: or constructors
02:23:41 <tensorpudding> also, be careful with parens
02:23:44 <Baughn> ..right. Or constructors.
02:23:52 <tensorpudding> evenfun has only one argument
02:23:59 <tensorpudding> but you write evenfun timestwo xs
02:23:59 <Jafet> Or classes!
02:24:04 <Amigoo> timesTwo :: Int -> Int
02:24:04 <Amigoo> timesTwo x = 2*x
02:24:04 <Amigoo> evenFun :: [Int] -> [Int]
02:24:04 <Amigoo> evenFun [] = []
02:24:04 <Amigoo> evenFun (x:xs) = if Timestwo x == 2*x then x:Evenfun Timestwo xs else Evenfun Timestwo xs
02:24:08 <tensorpudding> you need to write evenfun (timestwo xs)
02:24:11 <Amigoo> it doesn't run
02:24:31 <Baughn> Amigoo: You've still got uppercase timestwo/evenfun in there
02:24:42 <idnar> Jafet: those are type constructors
02:25:36 <Baughn> Amigoo: Also, you seem to be passing two parameters to evenFun, but it only takes one
02:25:58 <Amigoo> ok, this
02:26:04 <Amigoo> timesTwo :: Int -> Int
02:26:05 <Amigoo> timesTwo x = 2*x
02:26:05 <Amigoo> evenFun :: [Int] -> [Int]
02:26:05 <Amigoo> evenFun [] = []
02:26:05 <Amigoo> evenFun (x:xs) = if timesTwo x == 2*x then x:evenFun timesTwo xs else evenFun timesTwo xs
02:26:22 <merehap> Amigoo: what Baughn just said is still true
02:26:28 <Baughn> Amigoo: evenFun timesTwo xs translates to (evenFun timesTwo) xs
02:26:41 <Baughn> Amigoo: But even "evenFun (timesTwo xs)" wouldn't actually work
02:27:03 <Amigoo> why not?
02:27:04 <Baughn> Amigoo: timesTwo takes /one/ Int, xs is a list of them
02:27:32 <Baughn> Amigoo: If you want to use timesTwo on /all/ of them, you could use map - "map timesTwo xs" - which calls timesTwo once on each element of the list
02:27:38 <tensorpudding> no
02:27:45 <tensorpudding> just remove timesTwo
02:27:48 <tensorpudding> you don't need it
02:27:50 <Baughn> Probably.
02:27:59 <tensorpudding> where you wrote evenFun timesTwo xs, you mean evenFun xs
02:28:15 <tensorpudding> because timesTwo is not passed as an argument anywhere in the definition
02:28:18 <Amigoo> I want to use the timesTwo again
02:28:24 <tensorpudding> it will be used
02:28:43 <Amigoo> =\
02:28:44 <Baughn> You call evenFun
02:28:49 <Baughn> evenFun calls timesTwo, as usual
02:28:54 <Baughn> So it gets used again.
02:29:12 <merehap> Amigoo: seriously, you would be much better off going through learnyouahaskell, the way of learning you are taking isn't efficient
02:29:26 <Amigoo> I went through it already
02:29:40 <merehap> did you understand every exercise?
02:29:44 <Amigoo> the one with the cow that has "type" on it's neck
02:29:51 <merehap> yes, correct
02:30:09 <merehap> it is ok to go through a tutorial multiple times
02:30:30 <merehap> there is more than just one page to it, you know
02:30:31 <Amigoo> I learn like this better I think
02:30:35 <Amigoo> it's less boring
02:30:47 <Amigoo> yes
02:30:48 * Baughn doesn't really mind.
02:30:48 <merehap> that's your choice
02:31:03 <Baughn> Heh, though I recall I read through the "gentle" introduction ten or fifteen times. :P
02:31:09 <Baughn> Those were the days.
02:31:22 <hatds> it's not that bad: http://www.haskell.org/tutorial/
02:31:30 <hatds> it's not for everyone I suppose
02:31:38 <merehap> poor Baughn
02:31:50 <Amigoo> I like the more interactive part of learning
02:31:59 <Amigoo> it feels like being in a class
02:32:00 <idnar> I'm not sure how I learned, really
02:32:03 <merehap> well that is what the interpreter is for
02:32:23 <merehap> if you just read learnyouahaskell, you wouldn't have learned anything
02:32:26 <idnar> I read a whole bunch of tutorials and hung around here a lot, I guess
02:32:30 <Ke> if only the interpreter had more stuff in default namespace
02:32:34 <Baughn> Back when I learned, we didn't /have/ an interpreter, or a compiler. We beta-reduced manually, without gloves, in a snowstorm, and we were /happy/ about it!
02:32:35 <hatds> you can either struggle to create an understanding or read a top down explanation of the language
02:32:46 <idnar> but I probably learned the most from reading code
02:32:56 <merehap> did you beta reduce up hill both ways, though?
02:33:02 <idnar> haha
02:33:20 <idnar> merehap: they did it in both time directions too
02:33:27 <Baughn> merehap: Ha. Back when I learned, the hill only had one direction. You could go up, but you could never come back down.
02:33:36 <idnar> hahahaha
02:33:41 <merehap> and that's how you got here today...
02:34:01 <Baughn> ..yeah, I'm still stuck on the hill. ;_;
02:34:37 <Amigoo> I don't really have a good background in programming, so maybe one day. I'd like to be able to understand a programming language just by reading and not asking anyone a question
02:34:41 <idnar> at least you're not over the hill
02:34:42 <merehap> #haskell: the place for those with the least potential energy
02:34:44 <lunabot>  luna: parse error on input `|]'
02:34:45 <Twey> Baughn: I used YAHT… ☹
02:34:48 <Amigoo> but for now, I hope you guys don't mind
02:35:07 <merehap> thats what we are here for
02:35:41 <Baughn> Amigoo: Once you've ot three or four languages down, you've got a good chance at what you suggested. For now, though..
02:36:05 <hatds> you don't need that much experience if you have enthusiasm
02:37:46 <merehap> Amigoo: even if you do find it boring, if you can muscle through the pattern matching chapter of lyah, I think you would benefit greatly
02:38:07 <merehap> that, and the recursion chapter
02:38:25 <merehap> once you have those two under your belt, everything in haskell will be a lot more clear
02:38:38 <merehap> and you will be able to ask the right questions on #haskell
02:38:38 <Amigoo> ok
02:39:11 <merehap> though I can't imagine them being too boring if you make sure to make good use of the interpreter
02:40:19 <Amigoo> you know, if I ever become rich, I'd like to sit all day and pay people to answer my questions about programming
02:41:01 <merehap> once it clicks, you don't have to worry about that
02:41:08 <Amigoo> I personally think asking questions to someone with a lot of knowledge is the best way to learn something
02:41:24 <merehap> I would agree, if they were there face to face
02:41:34 <merehap> at least for the beginning period of learning programming
02:41:42 <merehap> after that, it doesn't matter how you learn
02:41:47 <merehap> for the most part
02:42:45 <Amigoo> this is my third day learning Haskell without much background in programming, yesterday, someone chatted with me for 6 hours teaching me just about haskell, and the day before that, we talked for about 7 hours on what "type" means
02:43:22 <merehap> well, you don't actually need to know much about type at this point
02:43:34 <merehap> you know what an integer is, you know what a string is
02:43:46 <merehap> you don't have to be able to explain how they are different
02:44:13 <Amigoo> Sometimes you do
02:44:17 <idnar> merehap: I don't think even I could explain /how/ they're different :)
02:44:19 <Amigoo> because "2345" can be a string
02:44:29 <idnar> they just are
02:44:33 <merehap> though I must say, 3 days versus 3 hours of lyah is a big tradeoff
02:44:46 <merehap> idnar: I agree
02:45:03 <Amigoo> when I was taking thermodynamics, I had problems understanding entropy
02:45:06 <merehap> Amigoo: do you know how to run code from a file?
02:45:12 <Amigoo> no matter what I did,  I couldn't understand it
02:45:22 <Amigoo> not until i spent 5 hours with my professor talking about it
02:45:46 <Amigoo> it turns out entropy is a real quantity that can be defined by numbers
02:46:11 <merehap> I think you might be getting too hung up on definitions
02:46:17 <Amigoo> so I guess my point is, we all learn in different ways
02:46:20 <merehap> you just need to apply the knowledge
02:46:35 <merehap> I don't need to know what entropy is to be able to apply it
02:46:37 <Ke> well real and arbitrary
02:46:49 <merehap> I don't need to know what types are in order to apply them
02:46:54 <Ke> mostly just applicable
02:46:58 <hatds> definitions can feel like nothing but formalism, I think that's his issue
02:47:04 <merehap> I don't need to know what numbers are in order to add them
02:47:17 <Amigoo> you have to know what the number represents
02:47:33 <Amigoo> or else how would you understand it?
02:47:36 <merehap> Amigoo, I could ask you to explain numbers to me for hours on end
02:47:48 <merehap> and you wouldn't make any progress whatsoever
02:48:00 <merehap> you would say some simple properties, and wouldn't get much further
02:48:03 <idnar> that's the beauty of math, though; you can add two numbers even f they don't represent anything
02:48:21 <merehap> Amigoo: just write code, don't overthink it
02:48:38 <hatds> I think he's on the right track, it's good to think about it
02:48:39 <Amigoo> if people believe they don't have to understand the meaning, just know how to apply it, people will say things like "entropy just means "disorder""
02:48:48 <merehap> if you aren't using your compiler once a minute at this point, you are doing something wrong
02:49:06 <merehap> Amigoo: you are overthinking it
02:49:30 <merehap> write code (one minute), run compiler (one minute), repeat
02:49:39 <merehap> don't worry about what it means
02:49:48 <Baughn> Humans learn better by generalizing from specifics than by trying to absorb generalities directly
02:50:02 <merehap> no one on this channel can tell you what a type is
02:50:05 <hatds> on the contrary,  write+compile is what helps you understand
02:50:08 <merehap> since no one on this channel knows
02:50:08 <Amigoo> I actually learned a lot from tensorpudding when i asked him
02:50:08 <Baughn> Everyone figures out their own generalities, then thinks it'd be best to teach /those/, but it isn't. ;)
02:50:11 <Cale> I can
02:50:12 <Amigoo> He's a good teacher
02:50:20 <Baughn> merehap: Oy. ;_;
02:50:41 <merehap> Cale: we'll give some simple properties of types
02:51:05 <merehap> and that is all he needs to get started
02:51:33 <merehap> but the fact that so many papers are written on the definition of a type today, indicates a general lack of knowledge
02:51:47 <Cale> A type is a property of a program for which the program itself can be considered a proof (so that there is an effective method for determining if the property is true from the program code alone).
02:52:21 <merehap> Cale: see, I hardly learned anything from that, and someone who doesn't know programming would stare blankly at you right now
02:52:24 <Baughn> Cale: ..an interesting proposal, but I doubt many would agree
02:52:37 <Amigoo> merehap: it's fine if you don't think my method of learning is proper, I just don't want others to be discouraged from answering my questions
02:52:49 <Baughn> Cale: How about "decidable property of the program" for that?
02:52:54 <merehap> Amigoo: programming isn't about talking, it is about doing, the fact that you aren't programming right now means that you aren't making progress
02:52:56 <Baughn> Or just "decidable"
02:53:21 <merehap> Amigoo: we are answering your questions
02:53:30 <merehap> but that can only go so far
02:53:36 <Ke> Amigoo: btw you can get derivations of entropy for simple systems from statistical mechanics
02:53:44 <hatds> you guys are too hard on him.  I agree it does sound like he could be reading tutorials more than asking questions but he is collecting valuable nuggets of info to digest later
02:53:51 <Amigoo> ok, you are right, the fact that I am not programming right now means I am not making any progress
02:53:55 <Ke> you don't need to understand what you can derive
02:53:58 <Amigoo> I guess I am going back to it
02:54:45 <merehap> hatds: no one is opposed to him asking questions on this channel (that has been the subject of the channel for the last 3 hours)
02:54:52 <Cale> Amigoo: Another way of thinking of types is that they are simply sets of values, but that sort of misses a good deal of the structure.
02:55:04 <merehap> hatds: we are just giving the best advice we can at this point
02:55:32 <Cale> Amigoo: So, for example, the assertion that x :: Integer means that x is among the set of values which are integers.
02:56:11 <hatds> merehap: I'm not opposed to answering questions either, I just meant in terms of efficiency.  It's something other people were talking about too.
02:56:30 <Cale> Amigoo: and  f :: Integer -> Bool  means that f is among the collection of functions which take Integer parameters and produce Boolean results.
02:57:57 <Cale> Amigoo: But of course you won't find a list or other sort of explicit enumeration of such functions inside the compiler for it to check. It's really more of a property which some function definition might satisfy.
03:00:48 <Amigoo> @src odd
03:00:49 <lambdabot> odd = not . even
03:00:50 <Cale> Whenever we have a property of some sort which can be satisfied by some things and not others, it's natural to ask and try to talk about what is the collection of all the things which satisfy the property. (Though this sort of thinking can get one into trouble if one isn't careful.)
03:01:03 <Amigoo> @src even
03:01:03 <lambdabot> even n = n `rem` 2 == 0
03:01:15 <Amigoo> @src rem
03:01:15 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:01:15 <Cale> In the case of programming languages and types though, it's mostly harmless to think that way.
03:01:23 <Amigoo> :t rem
03:01:25 <lambdabot> forall a. (Integral a) => a -> a -> a
03:01:31 <merehap> @src div
03:01:32 <lambdabot> Source not found. My mind is going. I can feel it.
03:01:47 <merehap> > rem 5 3
03:01:48 <lambdabot>   2
03:01:53 <merehap> > rem 5 5
03:01:54 <Amigoo> ok cale, here is my probelm
03:01:54 <lambdabot>   0
03:02:22 <Amigoo> I am trying to make a function that returns Bool
03:02:28 <Amigoo> when the int is even
03:02:33 <besiria> got ghc 6.12.1 on archlinux ! :D
03:02:46 <Amigoo> timesTwo :: a -> a
03:02:46 <Amigoo> timesTwo x = 2*x
03:02:46 <Amigoo> evenFun :: a -> Bool
03:02:46 <Amigoo> evenFun [] = []
03:02:46 <Amigoo> evenFun (x:xs) = if timesTwo x == 2*x then True else False
03:03:11 <merehap> Amigoo: your function is taking a list
03:03:18 <merehap> you want an Int
03:03:31 <Amigoo> oh sorry, i meant list
03:03:35 <merehap> oh
03:03:47 <merehap> > map even [1..5]
03:03:49 <lambdabot>   [False,True,False,True,False]
03:04:01 <Amigoo> I want to make from scratch
03:04:02 <hatds> the first clause evenFun [] = [] is returning a list, not a Bool
03:04:21 <merehap> I think he wants a list of Bool
03:04:32 <merehap> so what he has now is correct
03:04:39 <Cale> Amigoo: Wait, so what type of parameter is the function taking, and what type of result is it producing?
03:04:41 <merehap> for the base case anyway
03:04:49 <Amigoo> i want to even the even in ">filter even [1...10]"
03:04:59 <Cale> > filter even [1..10]
03:05:00 <lambdabot>   [2,4,6,8,10]
03:05:01 <Amigoo> i want to make the even in ">filter even [1...10]"
03:05:10 <Cale> "make the even"?
03:05:18 <Amigoo> the even function
03:05:18 <Cale> > map even [1..10]
03:05:19 <lambdabot>   [False,True,False,True,False,True,False,True,False,True]
03:05:43 <Yolarina> I'm doing a foldl over a list, is it easily possible to get a "Maybe x" where x is the next element in the list, after the current?
03:05:44 <Cale> hmm
03:06:12 <Cale> Yolarina: hmm... perhaps take the tails of the list first
03:06:22 <Yolarina> Hmm.
03:06:37 <merehap> Amigoo: you need to use mod or rem
03:06:41 <Amigoo> :t even
03:06:42 <lambdabot> forall a. (Integral a) => a -> Bool
03:06:42 <merehap> observe:
03:06:43 <lpsmith> Or you could emulate a foldr :-P
03:07:00 <Yolarina> lpsmith: Order of evaluation matters this time.
03:07:04 <merehap> > mod 1 2
03:07:05 <lambdabot>   1
03:07:06 <merehap> > mod 2 2
03:07:07 <lambdabot>   0
03:07:09 <merehap> > mod 3 2
03:07:10 <lambdabot>   1
03:07:13 <merehap> > mod 4 2
03:07:14 <lambdabot>   0
03:07:15 <lpsmith> eh?
03:07:17 <merehap> > mod 5 2
03:07:18 <lambdabot>   1
03:07:21 <Yolarina> merehap: Stop.
03:07:46 <merehap> Yolarina: there are other subjects here besides yours...
03:07:51 <Yolarina> > map (\x = mod x 2) [1..10]
03:07:52 <lambdabot>   <no location info>: parse error on input `='
03:08:02 <Amigoo> let him finish first
03:08:05 <Amigoo> I can wait
03:08:08 <tensorpudding> he's done
03:08:08 <mux> > map (`mod` 2) [1..10]
03:08:09 <lambdabot>   [1,0,1,0,1,0,1,0,1,0]
03:08:15 <Yolarina> merehap: You need not make me scroll twenty pages. :P
03:08:15 <merehap> Amigoo: isn't familiar with lambda expressions
03:08:26 <tensorpudding> we're not going to bother to sit while merehap enumerates the integers :P
03:08:38 <lpsmith> Yolarina:  order doesn't matter unless you are using unsafePerformIO in bad, evil ways
03:08:47 <Yolarina> lpsmith: Oh.
03:08:50 <lpsmith> Associativity of the expression might matter.
03:08:52 <merehap> Amigoo: so you can see how mod 2 returns 0 if the number is even, 1 if it is odd
03:08:56 <Cale> > foldl (\a x -> case x of (x:y:xs) -> (x,y):a; [x] -> (x,x):a; [] -> a) [] . tails $ [1,2,3,4]
03:08:58 <lambdabot>   [(4,4),(3,4),(2,3),(1,2)]
03:09:15 <Cale> (sort of an awkward example, but should give an idea)
03:09:23 <lpsmith> Evaluation order might matter in the sense of resource consumption/efficiency
03:09:31 <lpsmith> but not in the final result
03:09:35 <Amigoo> man, I've been hearing "unsafePerformIO" thing a lot, I hope to know what it means one day
03:09:40 <merehap> Amigoo: you can use that as the condition for even
03:10:00 <hatds> you will, it's not hard to grasp once you get IO and evaluation under your belt
03:10:04 <merehap> Amigoo: don't worry about that right now, that is a subject for another day :)
03:10:16 <Cale> Amigoo: You should mostly pretend that unsafePerformIO doesn't exist.
03:10:19 <merehap> Amigoo: do you understand how mod works?
03:10:22 <int-e> Amigoo: a rough translation is "abandon all hope ye who enter here."
03:10:26 <Amigoo> merehap: yea, but I want to get the bool function from scratch
03:10:26 <Cale> Amigoo: People mention it way too often around here ;)
03:10:28 <lpsmith> anyway,  take cale's advice and use tails,  alternatively you could use foldr to partially emulate a left fold
03:10:34 <hatds> mod feels like cheating for writing an even function
03:10:44 <Amigoo> yea
03:10:47 <lpsmith> tails is probably the less esoteric solution
03:10:47 <Cale> hatds: really?
03:10:52 <merehap> Amigoo: so try writing the bool function based upon mod
03:11:05 <Eduard_Munteanu> Hi.
03:11:12 <Cale> Hello Eduard_Munteanu :)
03:11:16 <merehap> Amigoo: you saw how it alternated 0s and 1s
03:11:19 <Eduard_Munteanu> Wow, I've been reading stuff about the OI Monad.
03:11:22 <Eduard_Munteanu> Crazy :)
03:11:23 <hatds> Cale: sorta
03:11:24 <Amigoo> yea
03:11:27 <Eduard_Munteanu> Cale, hi.
03:11:28 <mux> the OI monad sounds fun
03:11:30 <merehap> Amigoo: how can you make that into an even' function?
03:11:30 <Cale> Eduard_Munteanu: OI monad?
03:11:34 <hatds> Cale: it makes the problem trivial at least
03:11:35 <Eduard_Munteanu> Cale, comonad
03:11:37 <Eduard_Munteanu> sorry
03:12:02 <Eduard_Munteanu> I just found it.
03:12:07 <Amigoo> I can say 1 is False and 2 is True
03:12:13 <merehap> yes
03:12:17 <Amigoo> but I'd rather not use mod if i could
03:12:25 <merehap> mod is appropriate here
03:12:31 <Cale> Eduard_Munteanu: I should warn you that it was determined to be something that pretty much doesn't work.
03:12:38 <Eduard_Munteanu> http://docs.google.com/viewer?a=v&q=cache:Pkrw4vD4_QkJ:citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.45.4741%26rep%3Drep1%26type%3Dpdf+oi+comonad&hl=ro&gl=ro&sig=AHIEtbRE6XWxNzqJdPwE9w2Z4-AAQFIQuA
03:12:41 <Amigoo> it's just application of functions
03:12:43 <Cale> Eduard_Munteanu: Even though a paper was written about it.
03:12:45 <lpsmith> @let myfoldl f b as = foldr (\b k a -> k (f a b)) id as b
03:12:47 <lambdabot>  Defined.
03:12:47 <hatds> he doesn't want to use it, that's fine
03:12:48 <Eduard_Munteanu> Cale, yes, it breaks referential transparency.
03:12:52 <merehap> Amigoo: that is all programming is
03:12:53 <lpsmith> :t myfoldl
03:12:54 <lambdabot> forall a1 a. (a1 -> a -> a1) -> a1 -> [a] -> a1
03:13:13 <Eduard_Munteanu> Cale, there is an alternate implementation on the mailing list that does it correctly for stdin/stdout it seems.
03:13:15 <lpsmith> > myfoldl (flip (:)) [] [1..10]
03:13:15 <hatds> then how would you write mod?  It's the same thing :)
03:13:16 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
03:13:28 <lpsmith> myfoldl is reasonably efficient too
03:13:58 <Cale> Eduard_Munteanu: really? I think the trouble is that you end up having to fork the stdout arbitrarily many times :)
03:14:19 <Eduard_Munteanu> Also there's this paper describing duality of monads and comonads nicely: http://www.cas.mcmaster.ca/~carette/CAS706/F2006/presentations/comonads.pdf
03:14:22 <lpsmith> (on the other hand,  using foldl to emulate foldr is not as reasonable w.r.t. efficiency)
03:14:27 <Eduard_Munteanu> Cale, yeah, I know.
03:14:30 <Cale> Eduard_Munteanu: Like, it sort of almost makes sense if you have this arbitrarily large stack of terminals for output in parallel.
03:15:45 <Cale> Eduard_Munteanu: Yeah, that's the paper I'm thinking of.
03:15:53 <lpsmith> (as using foldl to emulate foldr will require traversing the entire list before you can do anything useful)
03:16:04 <Eduard_Munteanu> Cale, hm, yeah, but I think it's interesting because it all fits when you see both parts of the issue.
03:16:11 <sohum> :t lookup
03:16:12 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
03:16:25 <sohum> @hoogle a -> b -> [(a,b,c)] -> Maybe c
03:16:26 <lambdabot> No results found
03:16:30 <Cale> Eduard_Munteanu: There is a problem with the OI comonad as defined by that paper.
03:16:30 <merehap> Amigoo: the mod solution is the only one that follows from the definition of an even number (any number divisible by 2)
03:17:01 <Cale> (in that it breaks referential transparency and/or forces you into an interpretation of the operations which is unreasonable)
03:17:15 <hatds> merehap: I think he's saying he doesn't want to use out of preference.
03:17:42 <merehap> hatde: I know, but the other methods are more advanced
03:18:02 <hatds> they are more basic in another sense
03:18:05 <Eduard_Munteanu> Cale, yeah, I think the Stream comonad for example is more useful at this point.
03:18:51 <merehap> hatde: ANDing, or showing the string and detecting whether it matches 02468 are both a bit awkward, unless you were thinking of something else?
03:19:21 <besiria> with ghc 6.12.1 i have both base-3 and base-4 listed in ghc-pkg list. should i remove base-3?
03:19:24 <hatds> merehap: the obvious way is to count
03:19:55 <hatds> merehap: and you could do that using addition itself or list processing (like returning the list [1,0,1,0,.] and counting your way along it)
03:20:02 <merehap> hatds: well I guess I would have encouraged that solution, but that didn't seem to be the one he was going for
03:20:13 <hatds> you might be right
03:20:58 <merehap> hatds: that does seem reasonable though, and certainly some people would see it that way rather than division by 2...
03:21:37 <merehap> hatds: it seems to require more haskell knowledge though
03:21:41 <hatds> I'm only guessing that he didn't want to use 'mod' because it's basically the same function.  It begs the question of how one would write mod
03:22:01 <besiria> latest SHA fails to build on ghc 6.12.1
03:22:28 <sohum> @hoogle Eq a => a -> [a] -> [a]
03:22:28 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
03:22:29 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
03:22:29 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
03:22:47 <hatds> merehap: yea, but if this was his reason then he wants to know that knowledge
03:22:50 <merehap> hatds: I'm not sure I would say that, even does compose two different functions, and most people wouldn't think to break isDivisible down further
03:23:13 <merehap> hatds: though I did suspect use of mod felt fishy to him
03:24:05 <Cale> Eduard_Munteanu: http://www.haskell.org/pipermail/haskell-cafe/2003-January/003794.html -- this program shows an example where Kieburtz' implementation of an OI comonad is faulty. It's possible to try to fix it for restricted sorts of effects, but you end up with something not so practical (you have to hang on to every piece of input that you ever get, and it needs to be possible to split the world of output arbitrari
03:24:05 <Cale> ly)
03:24:20 <hatds> merehap: most people wouldn't in a programming context yea, but remember he's talking about drilling down into definitions of entropy and such
03:24:35 <sohum> @pl \x -> map f (g x)
03:24:35 <lambdabot> map f . g
03:24:36 <hatds> it was a possibility, I'm really not any more sure than you are
03:24:37 <merehap> and that's what I'm worried about, overthinking things
03:25:21 <merehap> you never get to write code if every concept is broken down to philosophy/meaning
03:25:28 <merehap> meaning is overrated, I would say
03:25:31 <Eduard_Munteanu> Cale, thanks, I didn't see an usage scenario.
03:25:52 <merehap> but there I go with philosophy
03:26:34 <Cale> merehap: I'm not sure if that's true...
03:26:39 <hatds> he's probably writing code right now in any case
03:26:57 <Cale> merehap: It's certainly possible to give everything in the language a mathematical semantics.
03:27:14 <Cale> Though I'm not sure if you mean a sort of meaning apart from that :)
03:28:09 <merehap> I think "how-to" knowledge almost always precedes deeper knowledge of a subject
03:28:24 <merehap> I knew how to add before I knew what numbers were
03:28:33 <merehap> I knew how to program before I knew what types were
03:28:39 <Eduard_Munteanu> Cale, hm, I think I'll stick to more orthodox stuff, like Stream for now.
03:28:42 <quicksilver> that's a choice of learning style though, merehap
03:28:44 <Cale> Eduard_Munteanu: yeah :)
03:28:49 <quicksilver> it is the more common choice, though.
03:28:59 <hatds> it's the most natural form of learning
03:29:04 <quicksilver> some people however do prefer to learn the theory first and then the practice.
03:29:08 <quicksilver> hatds: no, it's not.
03:29:12 <quicksilver> hatds: it is merely one form of learning.
03:29:14 <hatds> well subjectively :)
03:29:32 <quicksilver> it's certainly preferred by most people, though, in my experience.
03:29:36 <merehap> quicksilver: I don't think a caveman could have ever come upon numbers without building a practical basis for their use first
03:29:45 <Cale> I knew what metric spaces were before I knew how to do most anything with them generally :)
03:29:53 <quicksilver> merehap: that's an entertaining hypothesis and intuitively attractive
03:29:56 <ketil> Anybody using ndm's CmdArgs?  How do I capture the default flags, specifically -q and -v, and use them in my program?
03:30:00 <quicksilver> merehap: but it's pretty hard to prove
03:30:03 <hatds> Cale: because of R^3? ;)
03:30:06 <merehap> Cale: are you sure that you knew what they were then?
03:30:11 <quicksilver> my experience of teaching undergrads shows both types though.
03:30:20 <Cale> (though one could argue that I knew about specific metric spaces before I knew about metric spaces generally)
03:31:07 <Eduard_Munteanu> merehap, well, the discussion about comonads clearly shows people sometimes invent crazy stuff with no _current_ use :)
03:31:10 <merehap> my experience with CS grad students in industry shows that many don't know how to program
03:31:14 <Cale> merehap: Learning what metric spaces are is easy. Learning about their general properties is what takes time.
03:31:46 <quicksilver> I learnt what categories were before I learnt what they were for.
03:31:51 <quicksilver> to be fair, I found that pretty annoying ;)
03:31:54 <quicksilver> because it seemed pointless.
03:31:57 <HaskellLove> merehap where are you looking at? there are lots of crazy people out there
03:32:00 <quicksilver> but nonetheless that's the order it happened.
03:32:10 <Eduard_Munteanu> quicksilver, like most stuff in school, that sounds familiar.
03:32:33 <merehap> I think you had knowledge of what categories were
03:32:34 <Cale> quicksilver: Hehe, how did that happen? Did I have anything to do with that? I forget.
03:32:36 <merehap> beforehand
03:32:57 <merehap> in fact you had been categorizing things from a very young age
03:32:58 <Eduard_Munteanu> merehap, functors as analogies? :)
03:33:02 <Eduard_Munteanu> That's what I think.
03:33:18 <Cale> merehap: The mathematical sense of "category" is *very* different from the ordinary sense.
03:33:39 <merehap> it takes a decent amount of its basis from the ordinary sense though
03:33:44 <Cale> Not really.
03:33:50 <Cale> At least, I don't think so.
03:33:52 <merehap> anyways, I doubt I'll make any headway here
03:34:02 <Cale> I view categories as a sort of cross between preorders and monoids.
03:34:24 <sohum> @hoogle Maybe a -> a
03:34:25 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
03:34:25 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
03:34:25 <lambdabot> Data.Monoid First :: Maybe a -> First a
03:35:04 <merehap> unfortunately you are more well versed in higher math than I am, so you will out knowledge me in that area
03:35:38 <Cale> and most of the structure of most categories is in how the composition operation on arrows works, and arrows don't even correspond to anything in the normal sense of the word "category"
03:35:52 <merehap> I just don't think anyone could ever suddenly realize what a monad is, and then nearly instantly become a master programmer
03:36:10 <Cale> That's not even something which would happen if they did.
03:36:10 <sohum> :t filter
03:36:12 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
03:36:17 <Eduard_Munteanu> Closest would be arrows represent various relations between objects that are similar (belong to the same "category")
03:36:19 <Cale> Monads aren't even all that important to being a good programmer.
03:36:33 <merehap> it was an just an example
03:36:37 <sohum> @hoogle (a -> Bool) -> [a] -> [a]
03:36:37 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:36:37 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
03:36:37 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
03:36:52 <merehap> they appeared in my C# code naturally before I knew anything about them
03:36:59 <Cale> I know people who know what a monad is and yet don't know anything about programming.
03:37:27 <merehap> well, that underlies my philosophy of teaching programming
03:37:43 <fasta> I think most people can easily understand that a certain type is a kind of Foo when it supports certain operations. That people have named a certain set of operations a Monad, well, some people pay too much attention to that and start to think it is something complicated.
03:37:48 <quicksilver> Cale: no, I learnt Category Theory from PTJ about 10 years ago, which is long before I met you.
03:37:49 <Cale> (and when I explain how it relates to programming, they usually get the idea pretty quickly, which is interesting :)
03:37:50 <hatds> merehap just means that category theory is only useful because it can be applied to examples of categories, i.e. things we care about.  It'd be scary if someone could see that without knowing examples exist.
03:37:56 <Cale> quicksilver: ah, cool
03:38:05 <merehap> there are many CS concepts that knowing just the words for doesn't translate into programming practical knowledge
03:38:14 <Cale> quicksilver: I know that I've taught some people around here CT, but I forget who they were exactly :)
03:38:48 <merehap> hatds: yes, category theory was formed over many years of abstracting concrete lessons
03:39:15 <merehap> the order than humanity learns these concepts in is necessarily the order that individuals learn the concepts in
03:39:22 <merehap> there is my thesis statement
03:39:24 * Eduard_Munteanu : cale's list, for enlighting on comonads
03:39:27 <Cale> I totally disagree with that.
03:39:31 <merehap> :)
03:39:38 <Cale> I think a false history works much much better.
03:39:52 <merehap> cavemen didn't know what a monad was
03:40:06 <merehap> there is a lot of knowledge you have to build up before you understand a monad
03:40:10 <Cale> I'm not saying that one should learn monads as one's first mathematical concept
03:40:19 <merehap> (just an example)
03:40:50 <Cale> But that the order in which things were developed historically is much rougher and more difficult a path than our modern insight lets us see.
03:41:13 <Cale> In fact, it's hard to even do things in the historical order because almost no textbooks will do that.
03:41:14 <Eduard_Munteanu> Not all things were invented/discovered by pursuing that exact goal.
03:41:27 <Cale> A lot of concepts have been discarded and replaced altogether.
03:41:32 <merehap> egyptians developed geometry in order to increase crop yields
03:41:42 <merehap> and even gave it a dumb concrete name like geometry
03:41:51 <merehap> geometry has nothing to do with the Earth
03:41:57 <Cale> geometry is a greek name, of course
03:42:09 <merehap> it is a historical relic of concrete thinking
03:42:23 <fasta> Do you happen to know software which lists symbols from a DLL who name is not pexports?
03:42:30 <merehap> yes, but the greeks took the concrete meaning of the word from the Egyptians
03:42:33 <Cale> I'm not denying that concrete thinking had a part in the origins of these subjects.
03:42:35 <fasta> whoms*
03:43:02 <Cale> I'm saying that abstract thinking with hindsight taken into consideration gives us a faster route to enlightenment. :)
03:43:39 <merehap> I can agree with that, though I wouldn't say it contradicts my earlier statements
03:43:54 <merehap> humans are much better at not forgetting abstractions these days
03:44:01 <merehap> well, humanity is
03:44:05 <Cale> So when teaching concepts, it's not necessary to follow the haphazard order in which we actually discovered them.
03:44:08 <merehap> human memory still sucks
03:44:13 <Cale> Often there's a much more efficient order.
03:44:23 <merehap> hm
03:44:29 <Eduard_Munteanu> I need to leave for school, will be back for some more mind warping. Bye.
03:44:55 <merehap> well, there is an element of haphazardness to how humans have obtained their knowledge
03:45:04 <Cale> Or, we can replace the original awkward definitions with modern polished ones right away, skipping over lots of nonsense.
03:45:08 <merehap> but that is just because there are different fields of human knowledge
03:45:30 <merehap> I would still say that within any given field, the arrow has always been concrete -> abstract
03:45:54 <merehap> yes, I realize that astrology is not taught as much anymore :)
03:46:17 <Cale> Well, not just that -- even with non-bullshit things this happens.
03:46:18 <merehap> that's because it was/is a bad abstraction
03:47:27 <Cale> For example, "ideal elements" which were historically discussed in the theory of rings have been refactored into the polynomial ring construction and ring ideals.
03:48:52 <merehap> ugh, outside of my knowledge realm
03:48:53 <Cale> Galois theory is usually not taught the way that Galois did it.
03:49:13 <merehap> Galois theory was probably wrong in several ways
03:49:18 <Cale> Or, more toward the beginner material, vector spaces are often given an abstract definition first.
03:49:23 <merehap> wrong, rather than too concrete
03:49:44 <Cale> I'm not sure I'd say that it was wrong...
03:49:58 <Cale> It's just that the notion of abstract groups didn't exist yet.
03:50:19 <merehap> by the time you have reached vector spaces, you already have a common language well established
03:50:53 <Cale> First day of linear algebra 1 for me was the abstract definition of a vector space, immediately followed by examples.
03:51:05 <merehap> that abstraction allows progress to occur, though inevitably it gives way to higher abstraction which you don't have to language to describe yet
03:51:15 <Cale> Rather than, say, starting from systems of linear equations and the determinant.
03:51:45 <Cale> (Admittedly, people still like to put systems of linear equations first)
03:51:58 <Ke> blasphemy
03:52:07 <merehap> that is just abstract to concrete on a very local level (probably influenced by the teachers philosophy)
03:52:23 <Cale> But the determinant, even though it's historically much much older than the idea of a vector rarely comes before it.
03:52:28 <merehap> I doubt humans on the broad scale actually learn like that
03:52:51 <merehap> long scale, I should say
03:52:58 <Cale> We develop things from concrete to abstract quite often, but then abstract becomes the new concrete
03:53:07 <merehap> agreed fully
03:53:20 <HaskellLove> ah Cale said it wonderfully
03:53:23 <Cale> and you can actually treat it that way and start from the abstraction
03:53:33 <Cale> as the basic concrete thing you're working with
03:53:38 <merehap> well, the new concrete, yes
03:53:42 <merehap> I agree
03:53:49 <merehap> but that is what I've been trying to say
03:53:55 <Cale> okay
03:53:57 <merehap> concrete naturally comes first
03:54:22 <merehap> understanding what entropy is before applying the concept is unnatural
03:54:29 <merehap> perhaps impossible
03:54:31 <Cale> But once you're looking at things like this, there is no absolute sense of abstract and concrete anymore. There's just formal.
03:54:46 <merehap> how so?
03:55:02 <merehap> and why I am debating philosophy at 4am?
03:55:06 <fasta> merehap, they are both statements in a formal language, I suppose.
03:55:11 <sioraiocht> can I give rewrite rules for typeclass functions?
03:55:28 <Cale> Everything you can formalise can be treated as a concrete concept and worked with as if it was the foundational idea, even if its origin is as an abstraction over something else.
03:55:30 <sioraiocht> and if so, can I do it with the typeclass rather than a given instance?
03:55:46 <merehap> anyways, nice talking with you, but I'm waking up in 5 hours for work (after I get to sleep, that is)
03:56:01 <Cale> okay :)
03:56:11 <merehap> thanks, good night
03:58:15 <HaskellLove> Wow Cale you nailed it there. I would just add, you lose sense of what is real, what is abstract and what is concrete. As you said it all just becomes one, formal. I guess that is the Mathematician/programmer Nirvana
03:59:08 <jedbrown> What is the unlifted type in  ((ForeignPtr addr contents), off, len) = Data.ByteString.Intern.toForeignPtr bs  ?
04:01:15 <jedbrown> Adding a bang pattern to the tuple gets rid of GHC's warning, but bang patterns on each of it's entries does not.  Seems odd to me.
04:01:23 <Amigoo> dammit, I can't read the tutorial
04:01:27 <Amigoo> it's not helping me
04:02:28 <jedbrown> I don't see any strictness annotations in the Data.ByteString.Internal.toForeignPtr source.
04:03:46 <Jafet> Amigoo, http://norvig.com/21-days.html
04:05:39 <Amigoo> my school starts next tuesday
04:05:47 <Amigoo> so I am in a hurry
04:05:54 <Jafet> Disregard it
04:06:34 <Amigoo> Learning this is one of the few fun things I can do before school starts
04:06:59 <Jafet> School and Haskell are not mutually exclusive.
04:07:23 <Amigoo> for me it is, my hardest semester is coming
04:07:37 <Amigoo> I won't have any time for Haskell other than like 1 hour a wekk
04:07:40 <Amigoo> week*
04:08:27 <Jafet> http://paulgraham.com/procrastination.html
04:09:42 <Amigoo> so I need to learn to procrastinate better?
04:09:58 <Amigoo> I can't do that, I have a boss who depends on me
04:11:41 <apfelmus> Anyone have an idea how to include external documentation in a cabal package?
04:12:20 <apfelmus> I.e. I want cabal haddock to also install some other .html I'm providing.
04:12:34 <apfelmus> Or cabal install for that matter.
04:13:37 <blackh> Amigoo: What are you learning at the moment?
04:15:10 <sioraiocht> dcoutts: ping?
04:18:45 * hackagebot upload: hakyll 1.0 - A simple static site generator library. (JasperVanDerJeugt)
04:19:47 <int-e> @hoogle URIAuth -> URIAuthority
04:19:48 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:19:48 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
04:19:48 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
04:24:27 <sioraiocht> is it possible to disable foldr/build fusion?
04:33:06 <apfelmus> sioraiocht: http://www.haskell.org/haskellwiki/GHC/Using_rules#Coexistence_of_fusion_frameworks ?
04:34:36 <sohum> @hoogle union
04:34:37 <lambdabot> Data.IntMap union :: IntMap a -> IntMap a -> IntMap a
04:34:37 <lambdabot> Data.IntSet union :: IntSet -> IntSet -> IntSet
04:34:37 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
04:34:49 <sohum> @hoogle Data.Set union
04:34:49 <lambdabot> No results found
04:34:52 <sioraiocht> apfelmus: thanks, do you know anything about my first question i.e. about using rewrite rules with type classes?
04:34:58 <sohum> :t union
04:34:59 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
04:35:05 <sohum> :t Data.Set.union
04:35:07 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
04:35:11 <sohum> yea
04:35:13 <tensorpudding> union [1,2] [3,4]
04:35:18 <tensorpudding> > union [1,2] [3,4]
04:35:18 <sohum> why does that need an Ord a?
04:35:19 <lambdabot>   [1,2,3,4]
04:35:25 <tensorpudding> need to be more awake
04:36:08 <BONUS> sohum: for efficiency. however, the union for lists only needs Eq
04:36:09 <apfelmus> sioraiocht: What was the question exactly? I remember a small pitfall concerning termination  in type classes.
04:36:14 <apfelmus> Other than that, http://www.haskell.org/haskellwiki/GHC/Using_rules#Rules_and_method_sharing ?
04:36:31 <sioraiocht> Just taht I woudl like to specify rewrite rules for type class functions
04:36:31 <sioraiocht> but I am having trouble getting them to fire
04:36:31 <apfelmus> (A rule might applied to a default definition which then loops)
04:37:25 <apfelmus> I have no expertise there. But you may want to have a look at Control.Arrow which does something similar.
04:37:55 <sohum> BONUS: is there then a generic union implementation that only needs Eq?
04:38:19 <BONUS> sohum: yeah, the one from Data.List
04:38:54 <apfelmus> sioraiocht: From the wiki page, I gather that -fno-method-sharing may be useful.
04:40:14 <sajkr> hello everywun. i have a noob question.
04:40:46 <sajkr> my program talks with a server, sending a Request and getting back a Response.
04:41:54 <sajkr> class RoundTrip a b where
04:42:04 <sajkr>     encodeRequest :: a -> Request
04:42:16 <sajkr>     decodeResponse :: Response -> b
04:42:33 <sajkr> ofcourse, it doesn't work.
04:42:53 <sohum> :t Data.List.union
04:42:55 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
04:43:40 <sohum> BONUS: that's not generic... that is, implementation is visible and I can easily make the "sets" not be sets
04:44:02 <tensorpudding> > union [1] [1]
04:44:03 <lambdabot>   [1]
04:44:12 <tensorpudding> @src union
04:44:12 <lambdabot> union = unionBy (==)
04:44:20 <benmachine> @src unionBy
04:44:21 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
04:44:40 <tensorpudding> yeesh
04:44:50 <BONUS> sohum: so you need something exactly like Set only that it has an Eq contraints instead of an Ord
04:44:58 <Gracenotes> sajkr: not working is a very vague attribute. What do you expect it to do that it doesn't?
04:45:10 <sajkr> my question is, how do i tell the type checker that encodeRequest and decodeRequest belong to the same instance?
04:45:11 <Gracenotes> (in this case, I'm guessing compile...)
04:45:35 <benmachine> sajkr: how do you work it out yourself?
04:45:56 <benmachine> (i.e. if you know a does that tell you b, etc.)
04:46:04 <sajkr> roundTrip = decodeResponse . doRoundTrip . encodeRequest
04:46:30 <benmachine> give some examples of instance types
04:46:30 <sajkr> yes, i tried functional dependencies, but still...
04:46:54 <sohum> BONUS: pretty much. I could use lists instead as sets, or I could derive an Ord instance - both aren't really issues for this current thing. But in general, I can see the utility for a generic Eq-only set implementation
04:47:16 <benmachine> sohum: it'd be kind of slow, is the problem
04:47:28 <mokus> sajkr: functional dependiencies are the only way that particular instance can work, because every function only refers to one type variable
04:47:30 <benmachine> adding a new object to the set would require checking every element of the set for equality
04:47:45 <BONUS> i dont know, i think it turned out there isn't really much demand for such a thing
04:47:46 <mokus> sajkr: class, not instance, i mean
04:48:02 <BONUS> you can make an Ord instance for most things that are Eq, evene if the instance is arbitrary
04:48:03 <sohum> benmachine: sure, so when you can have an Ord instance or something you use fastUnion
04:48:20 <BONUS> or if you just want to treat lists like sets quick and dirty, just use the Data.List functions
04:48:26 <sohum> BONUS: what about types you're not in control of?
04:48:42 <benmachine> StandaloneDeriving woo
04:48:45 <BONUS> i think i have yet to encounter a type that's Eq that isn't Ord
04:48:53 <sohum> benmachine: ?
04:48:54 <mokus> sajkr: it would probably make more sense for 'a' and 'b' to be the same variable - you can still decode uisng a different instance from what you used to encode if that's what you want
04:49:27 <benmachine> sohum: a GHC extension that lets you add derived classes for types other than at their declaration
04:49:40 <sohum> benmachine: neaat. what're its limitations?
04:49:44 <benmachine> pass
04:49:47 <Yolarina> BONUS: Many practical thinks are Eq, but not Ord.
04:49:50 <Yolarina> things*
04:50:02 <BONUS> Yolarina: which?
04:50:08 <benmachine> it might have to export its constructors or something
04:50:57 <sajkr> mokus: you mean leaving encodeRequest undefined for response types and vice versa?
04:51:04 <Yolarina> BONUS: For example, a hash table can have an Eq, but an Ord wouldn't make sense.
04:51:09 <benmachine> sohum: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving gives the full list
04:51:29 <sohum> benmachine: that's kinda an issue, right? there's a lot of types that you can only deal with via its library functions, and that's standard library practice
04:51:33 <sohum> benmachine: thanks
04:51:35 <mokus> sajkr: if some types are only requests and some are only responses then they should probably be two separat classes
04:51:56 <BONUS> well, would. but even if it wouldn't make sense, it could be Ord based on some arbitrary rule
04:52:24 <mokus> sajkr: the important thing to remember is that whatever you choose, every function must mention every variable in the class in its type, either directly or through fundeps - otherwise the compiler can't know what instance matches
04:52:28 <BONUS> im saying that in practice, I haven't met a type that's Eq but isn't Ord and also I can't think of one where you wouldn't be able to add an arbitrary Ord instance
04:52:35 <benmachine> sohum: I kind of assumed what I said about constructors, it might be (probably is) nonsense
04:52:55 <mokus> sajkr: if every request has a unique response type and vice versa, then fundeps are what you want, going both ways
04:53:48 <sajkr> mokus: how do i write that?
04:54:01 <koeien37> class X a b | a -> b, b -> a
04:54:12 <sajkr> silly me.
04:54:17 <mokus> sajkr: yea, what koeien37 said
04:54:28 <sajkr> thanks.
04:54:59 <koeien37> how would you model this situation with associated types btw?
04:56:04 <BONUS> two type functions imo
04:56:12 <mokus> data families would work
04:56:43 <mokus> data familes as opposed to type families have an implicit fundep back to their type parameter
04:56:51 <koeien37> data family X a b = ...
04:56:51 <koeien37> ?
04:57:05 <mokus> class X a where data B a
04:57:17 <koeien37> oh. That's what I meant actually, data families instead of type families
04:57:18 <mokus> might work in the standalone data family case too, but i haven't tried
04:57:21 <koeien37> I mixed them up
04:57:46 <koeien37> I haven't done anything 'real' with them yet
04:58:11 <mokus> i've been getting my hands dirty with them trying to write a BEEP library in my spare time
04:58:22 <mokus> hopefully some day i'll even finish it
04:58:28 <mokus> ;)
04:59:26 <Cale> It's annoying that my system generates a locate database more often than I actually use the locate command. locate is useful, but it's silly that the construction of the database has to be done in such a monolithic way, rather than just having the filesystem store things in a way which is sensibly searchable.
04:59:56 <koeien37> true, but locate is not very useful imo
05:00:20 <benmachine> it depends on the sort of user you are I think
05:00:21 <koeien37> i would prefer some kind of indexing system (I'm aware that these exist for most platforms)
05:00:25 <Cale> I find it useful when searching for books or music.
05:00:26 <mokus> that's probably why many systems these days don't enable the update by default
05:00:46 <Cale> I have enough of both of those that I'm not fully aware of what I actually have.
05:01:03 <koeien37> heh. It's easier to google something than to find it on your own machine
05:01:05 <Cale> Even if I do have it fairly well organised.
05:01:13 <mokus> spotlight on the mac is pretty nice for that
05:01:20 <mokus> the OS tells the indexer what's changed
05:01:32 <koeien37> mokus: something like that, yeah. I don't know how well it works in practice, I've only seen it used
05:02:04 <mokus> koein37: works pretty well, and it indexes contents and lots of metadata too
05:02:04 <benmachine> woooo ghc 6.12 is in arch repositories
05:02:15 <benmachine> wooooo hundreds of megabytes of download
05:02:28 <benmachine> wooooooo university internet
05:02:42 <koeien37> I was more annoyed that my ethernet driver crashed, so I had to reboot. took me half an hour to diagnose :(
05:02:58 <koeien37> benmachine: o/
05:03:03 <benmachine> \o
05:03:21 <mokus> koein37: i often find myself searching for haskell code by typing fragments of the program that i remember even when i don't remember the name of the soucre file or maybe even the project
05:03:22 <Yolarina> I have two lists: [1, 2, 3] and [4, 5, 6]. How do I merge them together to form [1, 4, 2, 5, 3, 6]?
05:03:26 <xerox> Yolarina ++
05:03:33 <xerox> oh sorry
05:03:33 <Cale> Yolarina: interleave
05:03:39 <koeien37> :t interleave
05:03:40 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
05:03:44 <Yolarina> Thanks.
05:03:46 <Cale> Oh, that's in LogicT
05:03:47 <koeien37> I had to solve this as an exam problem once.
05:03:54 <Cale> You can write it by hand easily though
05:03:56 <benmachine>     ==> All cabalized and yaourt-installed packages need to be reinstalled now.
05:03:59 <benmachine> touché
05:04:04 <Cale> interleave xs ys = concat (transpose [xs,ys])
05:04:19 <Yolarina> In what module?
05:04:29 <benmachine> this might work out better for me actually, cleans out all my old rubbish
05:04:29 <koeien37> transpose is in Data.List presumably
05:04:36 <Cale> It's in the LogicT package in Control.Monad.Logic
05:04:50 <Yolarina> I mean for interleave. Where is that?
05:04:55 <Yolarina> Cale: Thanks.
05:04:58 <koeien37> what Cale said
05:05:01 <Quadrescence> Cale: You are the best
05:05:10 <koeien37> Cale: You are the best
05:05:15 <Yolarina> :D
05:05:19 <ziman> Cale is the beast :)
05:05:22 <Cale> Yolarina: But I gave an implementation in terms of transpose there which is in Data.List
05:05:23 <benmachine> hah
05:05:32 <Quadrescence> No, not a beast, he's pretty laid back and mellow
05:05:34 <Yolarina> Cale: I know.
05:05:48 <Yolarina> Cale: But if it exists, why reinvent it? :)
05:06:41 <benmachine> cabal: Haddock's internal GHC version must match the configured GHC version.
05:06:48 <Cale> Yolarina: Well, you might not want to take the trouble of downloading that package
05:06:54 <benmachine> ^ looks like haddock hasn't noticed I upgraded?
05:07:05 <Yolarina> Cale: Oh, it's a package. :(
05:07:09 * Yolarina reinvents.
05:07:11 <Yolarina> Cale: Thanks.
05:07:24 <Quadrescence> Cale: Did you write CABAL
05:07:27 <benmachine> oh it does seem to have noticed now
05:07:30 <Cale> Quadrescence: No
05:07:35 <Quadrescence> Cale: Did you make the logo
05:07:38 <Cale> Quadrescence: I did do the Cabal logo.
05:07:54 <tensorpudding> cobol?
05:08:03 <Quadrescence> tensorpudding: I was reading about COBOL last night
05:08:07 <Quadrescence> before bed
05:08:14 <koeien37> makes you fall asleep easily?
05:08:16 <tensorpudding> did you have nightmares?
05:08:18 <Quadrescence> (and had nightmares :(
05:08:19 <Quadrescence> )
05:08:22 <Cale> tensorpudding: No, cabal, the package management system for Haskell.
05:08:26 <tensorpudding> i know
05:08:34 <tensorpudding> i was only poking fun at CABAL
05:09:01 <Quadrescence> Cale: Can you link me to your high-res/SVG of cabal
05:11:02 <Cale> Sure, one sec while I dig it up
05:11:23 <Cale> http://cale.yi.org/share/Cabal-built-with.svg -- here's the built-with version
05:11:26 <Quadrescence> Cale: it's on your server along with the photo of the monad laws
05:11:28 * Yolarina hugs Cale.
05:11:29 <Quadrescence> oh ok
05:11:31 <koeien37> I can hear Cale cursing at "locate" now
05:11:38 <Quadrescence> Yolarina: haha I get it "hugs"
05:11:49 <Yolarina> Quadrescence: Haha!
05:11:52 <benmachine> oh hey, everyone gets fun new warnings to fix in their code
05:12:29 <Cale> http://cale.yi.org/share/Cabal.svg
05:12:33 <Cale> and there's the plain one
05:13:21 <Quadrescence> Cale: Can I see the hand-written monad laws
05:13:21 <Cale> Everyone likes me :)
05:13:26 <Cale> Quadrescence: sure...
05:13:30 <Quadrescence> <_<
05:13:48 <Cale> http://cale.yi.org/share/monadlaws.jpg
05:13:55 <Cale> Well, that's in string diagram notation
05:14:21 <xerox> Cale there's a problem from here, looks like yi.org didn't renew the domain
05:14:34 <koeien37> it works for me now, yesterday it didn't
05:14:42 <Cale> oh, right.
05:14:44 <Cale> blah
05:15:22 <Cale> 99.247.248.73
05:16:00 <Cale> I wonder if yi.org is gone forever or if they'll be back in a while.
05:16:15 <benmachine> url works fine for me
05:16:17 <xerox> it's kind of a cute short domain
05:16:43 <Cale> cale.yi.org resolves okay for me, but www.yi.org doesn't
05:16:56 <koeien37> ack
05:17:08 <benmachine> www.yi.org has address 72.55.145.119
05:17:15 <benmachine> but it doesn't load in FF
05:17:15 <Cale> yeah, that's wrong
05:17:17 <xerox> 69.64.155.21 by OpenDNS
05:17:32 <aep> someone should rewrite emacs in haskell >_<
05:17:33 <Cale> cale@zaphod:~$ host cale.yi.org
05:17:33 <Cale> cale.yi.org has address 99.247.248.73
05:17:37 <xerox> 99.247.248.73 with google dns though
05:17:46 <koeien37> google dns has it wrong too
05:17:49 <xerox> aep yi is something like that
05:18:03 <opqdonut> Cale: is that like expression-subtree-equivalence notation?
05:18:03 * aep googles
05:18:05 <xerox> (two meaning of yi very near, eheh)
05:18:46 <koeien37> two? there are too many meanings of yi :(
05:18:50 <Cale> opqdonut: vertices are natural transformations, lines are functors, 2-D spaces are categories
05:18:51 <benmachine> is it me or has http://hackage.haskell.org/trac/ghc gone funny
05:19:09 <koeien37> Environment not found
05:19:14 <benmachine> mm
05:19:19 <benmachine> who do we poke?
05:19:38 <benmachine> wait
05:20:00 <benmachine> looks like everything except the homepage works
05:20:03 <koeien37> yes
05:20:08 <koeien37> http://hackage.haskell.org/trac/ghc/wiki/ReportABug # works, e.g.
05:20:14 <Cale> opqdonut: It's a notation for composites in "weak 2-categories", of which the category of categories is an example (actually it's a strict 2-category which is even better)
05:21:25 <Cale> opqdonut: I have a whole series on my blog explaining about natural transformations and a bit about what the notation means and why it makes sense.
05:21:40 <Cale> opqdonut: The catsters videos also describe it
05:21:53 <Cale> http://analogical-engine.com/wordpress/?page_id=232
05:22:18 <opqdonut> thanks!
05:23:57 <opqdonut> hey, cool, homotopy of functors
05:24:21 <Cale> :)
05:25:49 <astroboy> I want to make a simple function that gets a character and returns
05:25:50 <astroboy> it
05:25:58 <Cale> id
05:26:07 <Cale> or
05:26:07 <astroboy> it's the first time i play with IO in haskell and I'm quite confused :P
05:26:10 <koeien37> of type :: Char -> Char ?
05:26:20 <astroboy> no I mean gets a character from the console
05:26:21 <koeien37> oh, you mean a character from the standard input?
05:26:22 <Cale> oh, you don't mean a function, you mean an IO action
05:26:24 <koeien37> :t getChar
05:26:25 <lambdabot> IO Char
05:26:27 <astroboy> yes sorry
05:26:38 <astroboy> i wrote something like
05:26:48 <koeien37> getChar is an IO action that when performed will get a character from the standard input
05:26:52 <astroboy> getMove = do x <- getChar
05:27:07 <astroboy> yeah but how do I return it
05:27:10 <Cale> astroboy: need another line
05:27:14 <koeien37> print it?
05:27:26 <koeien37> return x, otherwise
05:27:37 <Cale> do x <- getChar; return x  is the same as  getChar  alone
05:27:38 <astroboy> ah there is return in haskell :P
05:27:39 <koeien37> but, note that the x and 'r' of return should be aligned
05:27:56 <koeien37> astroboy: there is, but it works somewhat differently than you may be used to in other languages such as C
05:27:57 <Cale> astroboy: return x is the IO action which does absolutely nothing, but returns x as its result
05:28:02 <dmwit> astroboy: do { x <- getChar; return x } is exactly equivalent to just "getChar".
05:28:17 <Cale> astroboy: So in particular, if you write return x in the middle of a do-block, it's pointless.
05:28:29 <astroboy> ok, so what do I do?
05:28:36 <Cale> (it does nothing, and has the result x, but that result is ignored, and you continue with the next line)
05:28:37 <benmachine> do { return (); x <- getChar; return x } is also exactly equivalent to getChar
05:28:38 <astroboy> to be more specific I need to convert the char to int
05:28:49 <dmwit> :t ord
05:28:50 <koeien37> :t ord ?
05:28:50 <lambdabot> Char -> Int
05:28:51 <lambdabot> parse error (possibly incorrect indentation)
05:28:55 <Cale> getMove = do x <- getChar; return (ord x) ?
05:29:11 <dmwit> or you may want
05:29:15 <Cale> which is the same as  getMove = fmap ord getChar
05:29:20 <dmwit> :t \c -> ord c - ord '0'
05:29:21 <lambdabot> Char -> Int
05:29:33 <astroboy> no there is digitToInt anyway
05:29:34 <koeien37> :t digitToInt
05:29:35 <lambdabot> Char -> Int
05:29:43 <Cale> or that, yeah
05:29:51 <benmachine> > digitToInt 'a'
05:29:52 * dmwit makes a note
05:29:53 <lambdabot>   10
05:29:57 <benmachine> > digitToInt '#'
05:29:58 <lambdabot>   * Exception: Char.digitToInt: not a digit '#'
05:30:01 <benmachine> oic
05:30:13 <Cale> might want to watch out for those exceptions...
05:30:20 <benmachine> > digitToInt 'g'
05:30:21 <lambdabot>   * Exception: Char.digitToInt: not a digit 'g'
05:30:26 <koeien37> hexadecimal
05:30:31 <koeien37> but not 36-a-decimal
05:30:35 <benmachine> mm, just checking
05:30:44 <Cale> It seems a little odd that it wouldn't do base 36 to me.
05:30:49 <benmachine> I think C's strtol supports base 36
05:30:53 <koeien37> > digitToInt 'A'
05:30:55 <lambdabot>   10
05:30:59 <koeien37> case insensitive
05:31:00 <astroboy> getMove = do x <- getChar; return (ord x) doesn't work
05:31:09 <koeien37> in what sense?
05:31:14 <Cale> astroboy: well, it does
05:31:21 <benmachine> :t \c -> if isHexDigit c then digitToInt c else -1
05:31:23 <lambdabot> Char -> Int
05:31:23 <Cale> astroboy: But maybe it doesn't mean what you want it to mean
05:31:43 <astroboy> Cale: it gives an error
05:31:49 <astroboy>     Couldn't match expected type `Int' against inferred type `IO b'
05:31:50 <astroboy>     Couldn't match expected type `Int' against inferred type `IO b'
05:32:04 <koeien37> aha!
05:32:08 <Cale> astroboy: Did you give it a type signature?
05:32:14 <koeien37> but that is probably a different problem
05:32:17 <Cale> astroboy: it has type  IO Int
05:32:31 <astroboy> getMove :: Int
05:32:33 <koeien37> the type of getMove is IO Int, this means that it is an IO action that, when performed, will eventually return an Int
05:32:34 <Cale> wrong
05:32:37 <dmwit> astroboy: It sounds like you're having trouble with IO!  Here, have a bite of sigfpe:
05:32:40 <Cale> getMove is not an integer, clearly
05:32:44 <dmwit> ?where the io monad for people who simply don't care
05:32:44 <lambdabot> I know nothing about the.
05:32:49 <Cale> (because then, what integer would it be? 5?)
05:32:50 <dmwit> ?google the io monad for people who simply don't care
05:32:51 <koeien37> but getMove is not an Int, it's an IO action that returns an Int
05:32:52 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
05:32:52 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
05:32:55 <koeien37> they are *very* different
05:33:16 <Cale> astroboy: It's an action, which if you execute it, will produce an Int
05:33:43 <astroboy> so how to I get an int from a IO Int
05:33:51 <Cale> You can only execute that action inside another IO action
05:33:56 <koeien37> the same way as you did for getChar
05:34:03 <koeien37> do { x <- getMove; ... do something with x ... }
05:34:07 <Cale> and to do that, you just write   n <- getMove   inside a do-block
05:34:17 <Cale> (and then n is an Int)
05:34:39 <Cale> The do-block as a whole will be another IO action.
05:35:03 <astroboy> but getMove has to return user input sometime, and normal ints other time
05:35:10 <Cale> eh?
05:35:22 <astroboy> i'm writing an AI for a little game
05:35:24 <Cale> If it has to do I/O sometimes, then it must have an IO type.
05:35:31 <astroboy> ok...
05:35:51 <astroboy> haskell is wonderful but for I/O
05:35:51 <astroboy> well
05:35:53 <dmwit> getMove compy = if compy then return findAMove else fmap ord getChar
05:35:59 <Cale> It's wonderful for I/O too.
05:36:01 <koeien37> astroboy: that is not true.
05:36:04 <benmachine> IO in haskell is like that for a reason
05:36:23 <benmachine> it makes it very easy to see which bits of your program are going to behave predictably
05:36:26 <benmachine> and which bits aren't
05:36:30 <koeien37> astroboy: it is confusing because in Haskell, the IO *actions* and their results are clearly separated
05:36:30 <Cale> You'll find that once you get used to this, it's actually pretty flexible. Better than most imperative languages by a good margin.
05:36:44 <koeien37> which is not true in most other languages
05:36:45 <Cale> Of course, there are many people who think it could be improved even further
05:37:09 <koeien37> you can make your own constructs with them, because IO actions are first-class values
05:37:11 <koeien37> :t forever
05:37:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
05:37:20 <koeien37> ^ as an example
05:37:22 <astroboy> well I find haskell really lovely for problem solving
05:37:35 <Cale> Yeah, things like for-each loops don't need to be built into the language because we can write them
05:37:38 <Cale> :t forM
05:37:38 <astroboy> I am using the minmax algorithm and haskell it's just perfect
05:37:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
05:37:52 <Cale> Or, to simplify...
05:38:00 <Cale> forM :: [a] -> (a -> IO b) -> IO [b]
05:38:35 <Cale> So forM takes a list of values (to iterate over), and a function from those values to actions to be performed (a loop body), and produces an action which gives a list of results (the result of each iteration)
05:39:04 <Cale> forM [1..10] $ \x ->
05:39:09 <Cale>   do print x
05:39:14 <Cale>      getLine
05:39:28 <astroboy> i still don't get how do I have to convert my IO Char to a simple Char ):
05:39:35 <Cale> astroboy: by running it
05:39:41 <koeien37> you can't convert it directly. You'll have to run it
05:39:45 <Cale> astroboy: It's an action which if run, produces a Char
05:39:51 <koeien37> just like you did for getChar
05:39:59 <astroboy> so wwait
05:40:10 <astroboy> now I have getMove :: IO Char
05:40:12 <koeien37> getMove = do { x <- getChar; return (digitToInt x) } -- no error checking yet
05:40:15 <taruti> Was disk io done by GHC in safe or unsafe FFI calls?
05:40:27 <Paczesiowa> astroboy has reached the age when someone has to have the talk about monads with him...
05:40:39 <Cale> Paczesiowa: not yet
05:40:40 <koeien37> Paczesiowa: you don't need to know about monads in general to do IO.
05:41:07 <Cale> The fact that anything happens to be a monad is mostly important when you're working with more than one.
05:41:23 <koeien37> IO is not a terribly insightful monad anyway, imo
05:41:32 <Cale> (though it can be helpful to know that you can replace all the m's with IO in type signatures)
05:42:04 <astroboy> pleas could someone give me just a working function? I really need to finish that ):
05:42:12 <Cale> astroboy: What do you want to do?
05:42:13 <koeien37> astroboy: what do you want to do?
05:42:31 <Cale> astroboy: We're worrying about tiny little details here and it's not clear what your program is meant to be doing overall.
05:42:39 <astroboy> a function that returns a number from 0 to 9 fro user input, that's all
05:42:42 <astroboy> *from
05:42:58 <Cale> astroboy: it won't be a function, because it doesn't have any parameters
05:43:01 <koeien37> getInput = do { x <- getChar; return (digitToInt x) } -- this is not a _function, but an IO action.
05:43:02 <Paczesiowa> so you're going to stick with the story about IO and storks?
05:43:18 <Cale> Paczesiowa: The fact that IO is a monad is mostly irrelevant.
05:43:41 <Cale> The more important thing is that IO actions are values, and they can be combined
05:43:58 <Paczesiowa> you're a tough crowd:)
05:44:07 <astroboy> koeien37: <interactive>:1:0: parse error on input `;'
05:44:20 <Cale> astroboy: declarations have to go in a file
05:44:29 <koeien37> if you do this on the GHCi command line, add a "let " in front.
05:44:35 <Cale> astroboy: or you can precede them with let, yeah
05:44:46 <astroboy> ok i've got it
05:45:19 <astroboy> so If I call that in another function
05:45:25 <Cale> But you're liable to end up losing them that way. It's better to put your work in a file and load it in ghci. Most people keep two windows open side by side -- one with ghci, and the other with a text editor.
05:45:28 <astroboy> it will simply return my int?
05:45:32 <Cale> :r will reload the currently loaded file
05:45:42 <tensorpudding> or they keep ghci open in their text editor
05:45:43 <astroboy> Cale: i'm working exactly that way
05:45:43 <koeien37> if you call it from another IO action, it will return your Int
05:45:47 <Cale> astroboy: If you *execute* it in another *IO action* it will produce an Int
05:46:01 <Cale> astroboy: You can't execute IO actions from inside plain functions.
05:46:10 <koeien37> You wouldn't want to, anyway
05:46:15 <koeien37> because haskell functions are pure
05:46:25 <koeien37> and referentially transparent. so f x is *always* the same.
05:46:28 <astroboy> koeien37: mhm ok...
05:46:43 <koeien37> you can, of course, run this action from inside another action
05:46:43 <Paczesiowa> astroboy: read this: http://neilmitchell.blogspot.com/2010/01/haskell-io-without-monads.html
05:46:44 <Cale> If you say that x :: Int, then it means that x is some *specific* machine integer value. It's not a process for constructing one.
05:46:46 <astroboy> but as I sayd
05:46:49 <astroboy> *said
05:46:54 <astroboy> this function
05:46:56 <Cale> and it means that x is a constant
05:47:08 <astroboy> returns the user input and the AI input alternatively
05:47:12 <Cale> astroboy: Functions have a parameter.
05:47:22 <Cale> astroboy: What parameter does your function take?
05:47:34 <astroboy> Cale: what function?
05:47:39 <Cale> astroboy: <astroboy> this function
05:48:07 <astroboy> Cale: this what lol
05:48:08 <koeien37> just erase this from your vocabulary
05:48:26 <koeien37> an "IO Int" is an _action_ that, when performed, will do some IO and eventually yield a value of type Int
05:48:33 <Cale> A function is a mapping from input values to output values. Given a specific input value, it *always* produces the same resulting output.
05:48:34 <koeien37> it is not a function
05:49:01 <tensorpudding> @type return 5 :: IO Int
05:49:02 <lambdabot> IO Int
05:49:09 <astroboy> koeien37: my problem is that I have to return IO and non-IO value alternatively
05:49:09 <Cale> getChar, for example, doesn't take any parameters, and moreover, doesn't produce the same result every time.
05:49:17 <Cale> So it's not a function at all.
05:49:19 <koeien37> astroboy: for that, we have 'return
05:49:20 <koeien37> '
05:49:35 <tensorpudding> why is it called return, anyway?
05:49:38 <astroboy> so you can use return on a simple Int?
05:49:38 <koeien37> like tensorpudding's example. return is a way to convert a pure value to a value of type IO (something)
05:49:42 <koeien37> yes
05:49:48 <koeien37> and that will make it IO Int
05:49:49 <Cale> tensorpudding: because it produces the action which always returns that value.
05:49:58 <astroboy> koeien37: ok, thanks
05:50:06 <tensorpudding> that's not that intuitive, but i guess that is reasonable?
05:50:17 <koeien37> but, this has nothing to do with "abort the execution of the procedure here." like in C
05:50:28 <tensorpudding> by virtue of name it creates cognitive dissonance for people who have used C-like languages
05:50:34 <koeien37> i prefer inject
05:50:46 <koeien37> or eta
05:50:49 <tensorpudding> inject sounds more dual to extract
05:50:50 <Cale> yeah, but they already have lots of cognitive dissonance and shouldn't expect anything to work like C anyway
05:50:58 <benmachine> heh
05:50:59 <Cale> It's foolish to expect anything to be the same.
05:51:07 <koeien37> that is something I can agree with
05:51:10 <benmachine> well, + works similarly
05:51:18 <astroboy> I use python, c and java and yeah I am really confused for the first time in haskell
05:51:24 <Cale> It's like, die doesn't mean the same thing in German as it does in English.
05:51:29 <tensorpudding> :t liftM2 (+)
05:51:30 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
05:51:54 <tensorpudding> now you're adding with style
05:51:56 <Paczesiowa> long time ago, when I didn't understand monads, I was using parsec and I really thought that return returns and it was working just fine
05:52:01 <Cale> Python, C and Java, by contrast with Haskell, are practically the same language.
05:52:19 <tensorpudding> by that metric, Haskell and OCaml are the same language
05:52:50 <Axman6> astroboy: you'll learn to love it, and wonder why those other languages are so primitive in a very short time
05:52:51 <mux> I still think I don't have the slightest clue what a monad is; but I can sue them, create my own via transformers or from scratch, and see when they're useful
05:52:53 <Cale> Well, Haskell's evaluation and IO model is very different from OCaml's, but they're close
05:52:54 <opqdonut> tensorpudding: not by far
05:53:04 <mux> actually, I can use them rather than sue them.
05:53:12 <opqdonut> python, c, java and ocaml all share an evaluation model haskell does not
05:53:13 <koeien37> Python and C may be further apart than OCaml and Haskell
05:53:41 <tensorpudding> python and C are different on a lot of conceptual levels
05:53:43 <fasta> Understanding the differences between Python and C is probably easier than between OCaml and Haskell.
05:53:47 <koeien37> but I won't try to define a metric on the space of programming languages
05:53:57 <tensorpudding> whereas OCaml and Haskell are so superficially similar
05:54:07 <fasta> But it is a completely uninteresting discussion.
05:54:23 <fasta> It is just that everyone is defending some words.
05:54:35 <fasta> Completely worthless.
05:54:38 <fasta> Bye
05:55:04 <Cale> I had a silly diagram somewhere which arranged languages roughly on two axes by similarity and vaguely by "OO-ness" vs. "FP-ness".
05:55:13 <Cale> But I can't find it.
05:55:32 <xerox> It was P-Jones' slides
05:55:38 <tensorpudding> i'm not sure if OO-ness or FP-ness is more ill-defined
05:55:44 <Cale> No, it was my own.
05:55:46 <taruti> lazyness is a *large* difference
05:55:52 <xerox> Ah, he also had one.
05:56:15 <Cale> Yeah, he had a different one, with practical vs. principled
05:56:30 <ddarius> Useful v. safe.
05:57:36 <Cale> yeah, that was it :)
05:58:53 <jedbrown> It's incredible how many people think OO means calling functions as obj.method(other,args) instead of method(obj,other,args).  I think the former is mostly used so that single dispatch seems adequate.
05:59:18 * Axman6 always thinks of it as programming with objects...
05:59:30 <ddarius> The author of "Synthetic Differential Geometry," Anders Kock, has a new book, "Synthetic Geometry of Manifolds" with a final draft available online, for any who would be interested.
06:00:01 <Cale> To me, OO means characterising values in terms of their responses to operations/messages/methods, rather than according to their structure.
06:00:27 * hackagebot upload: haxr 3000.5 - XML-RPC client and server library. (GracjanPolak)
06:01:17 <Jafet> Looks like we're just engaging in small talk here
06:01:20 <Cale> (two objects are the same if they would respond to the same sequence of messages in the same way, independent of anything else going on in the program)
06:01:52 <PeakerWork> What about "Inheritance"?
06:01:56 <Cale> non-essential
06:02:06 <Cale> subtyping can go as well
06:02:25 <PeakerWork> I don't think "inheritance" is really subtyping
06:02:31 <jedbrown> OO philosophy has a lot to do with mutability.  If the objects are immutable, it's mostly just a matter of packaging.
06:02:32 <Berengal> It's not
06:02:33 <Cale> I know.
06:02:37 * ddarius thinks a very natural notion of "object-oriented programming" arises from message-passing concurrency.
06:02:40 <xerox> ddarius what does synthetic entail in a nutshell?
06:02:48 <Cale> It's not, they're different. I'm saying that both of those are not essential to what I think OOP is.
06:03:13 <Berengal> MPC feels rather object-oriented to me...
06:03:27 <Jafet> http://paulgraham.com/reesoo.html
06:03:30 <PeakerWork> "Ill defined fad" :)
06:03:43 <Berengal> But at the same time, functional and data-flow oriented
06:04:10 <mux> well, pi-calculus is about processes and channels; quite close to the message passing paradigm, yet I don't feel as if OOP arises from it
06:04:14 <Cale> core OO <-> existential types,  traditional FP <-> universal types
06:04:22 <ddarius> xerox: The general term in this context, usually means "making non-cartesian closed categories formally cartesian closed."  In an even more general context, the one with "synthetic" v. "analytic," it means working directly with geometric objects rather than breaking them down, conceptually, into sets of points.
06:04:35 <Axman6> i wonder what immutable OOP would be like
06:04:40 <ddarius> mux: Look at the blue and deep blue calculus.
06:04:52 <mux> ddarius: *notes that down*
06:05:11 <ddarius> mux: The pi-calculus leads to CPS-like code.  The (deep) blue calculus is a "direct-style" pi-calculus.
06:05:14 <Cale> Surprisingly similar to mutable OOP. It's just that instead of mutating, you have your object respond to messages with a new object.
06:05:56 <ddarius> mux: Anyway, once you start building processes with the pi-calculus, you often tend to produce actor-like objects.
06:06:29 * hackagebot upload: haxr-th 3000.5 - Automatic deriving of XML-RPC structs for Haskell records. (GracjanPolak)
06:06:29 <mux> ddarius: yes, that is why I was saying it seems quite close to message passing
06:06:36 <b0fh_ua> Hi there! Guys, can somebody please take a look at the code: http://pastebin.com/d144afaee - and let me know, does it really looks like CPS-styled function to read lines from console into a list until "quit" is found?
06:07:01 <ddarius> mux: http://www-sop.inria.fr/meije/personnel/Gerard.Boudol/blue.html
06:07:19 <mux> ddarius: cheers
06:07:24 <mux> err, 404
06:07:32 <mux> err, my fault.
06:07:36 <merijn> Ok, slightly off-topic but this is the place with the highest concentration of language geeks I know: Anyone read Essentials of Programming Languages by Friedman et al.? Is it any good?
06:07:42 <mux> ddarius: yay, fellow frenchmen ;-)
06:08:04 <Cale> OO is what you get when you focus on fixing the operations and making it easy to construct new variations on the values supporting those operations. FP is what you get when you focus on fixing the variations of data and focus on making it easier to construct new operations on those data.
06:08:04 <jedbrown> Cale: I'm not a big fan of the "objects responding to messages" interpretation since single-dispatch is insufficient for lots of problems, and I wouldn't claim that you're not doing OO when using multiple dispatch.
06:08:20 <Adamant> merijn: it's a good starter book
06:08:36 <jedbrown> Cale: Type classes throw a wrench in that FP interpretation.
06:08:39 <ddarius> b0fh_ua: CPS should lead to code that has nothing but tail calls.
06:08:45 <Cale> Typeclasses are orthogonal.
06:09:04 <Cale> (well, almost :)
06:09:13 <jedbrown> Type classes fix the operations and allow variations on the data.
06:09:48 <merijn> Adamant: Which version did you read? Amazon has good reviews on the 2nd edition, but the 3rd edition seems to be getting worse reviews.
06:09:58 <Cale> jedbrown: In a sense... but it's more like they allow variations on the type
06:09:58 <b0fh_ua> ddarius: nextAction line initial (\lines -> cpsReadUntilQuit lines) isn't it looks like you said?
06:10:11 <ddarius> The definition of nextAction is not tail recursive.
06:10:23 <Cale> jedbrown: If you proceed to wrap things up in an existential, you recover my view of OO :)
06:10:24 <Adamant> merijn: second edition, no clue about the third. you could ask on #scheme
06:10:42 * mux wonders if merijn got himself a copy of TAPL yet
06:10:46 <Adamant> Amazon reviews are not even a fairly direct mapping to goodness
06:11:05 <merijn> Adamant: I know, hence my double checking :)
06:11:24 <Adamant> mux: if he's doing TAPL he probably doesn't need EOPL, EOPL is more training wheels for stuff like TAPL
06:11:32 <b0fh_ua> hmm
06:11:37 <mux> Adamant: I think he doesn't need EOPL indeed :-P
06:11:37 <merijn> mux: It's on my list of stuff to read
06:11:40 <jedbrown> Cale: I think type classes provide a superset of OO, roughly speaking.
06:11:52 <Cale> That is, objects are values of a type which is completely determined by the coalgebraic way that it's taken apart, rather than the algebraic way in which it's built up.
06:12:15 <merijn> mux: Could be, if you think TAPL is better I'll just skip to that instead. I just find it hard to know where to start.
06:12:28 <Adamant> merijn: TAPL is different
06:12:40 <mux> merijn: I guess that depends on your goal; should we assume that your goal is learning Haskell?
06:12:47 <Cale> (the ways you can take something apart being similar to the possible messages you can pass it)
06:12:55 <tensorpudding> TTFP is a good book so far
06:13:10 <Adamant> doing EOPL then TAPL would make a lot of sense
06:13:13 <Cale> jedbrown: perhaps look at http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
06:13:35 <mux> Adamant: yes, I'm just thinking EOPL wouldn't teach merijn anything
06:13:35 <b0fh_ua> ddarius: can you correct the definition please?
06:13:43 <Adamant> mux: I have no idea where he is
06:13:52 <Axman6> Cale: i get a domain squatting page for that link...
06:13:53 <merijn> mux: Well, I'm learning haskell. But my goal is to understand programming better. By now I've reached the point where I think that to do that I need learn programming languages better.
06:13:54 <Adamant> so that might be a fair assessment, or not
06:14:04 <Axman6> "Welcome to yi.org"
06:14:04 <Axman6> Adventure Tours
06:14:04 <Axman6> Books
06:14:05 <Axman6> Broadband
06:14:05 <Cale> damnit, I keep forgetting.
06:14:14 <Cale> Half of everyone can't resolve that correctly
06:14:21 <mux> merijn: I stand by what I said, read TAPL
06:14:21 <jedbrown> Cale: it actually worked for me, surprisingly
06:14:29 <Cale> http://99.247.248.73/index.php/A_look_at_OO_from_Haskell  for the rest
06:14:43 <Axman6> thanks :)
06:14:55 <mux> Adamant: I know merijn from other channels.
06:14:57 <Cale> jedbrown: Yeah, I don't know what's going on.
06:15:18 <jedbrown> Cale: must be cached in some DNS server in Europe
06:15:20 <Cale> yi.org isn't my domain, it's a free subdomain provider
06:15:22 <mux> merijn: btw, when I'm not sure about books, I download a PDF first to take a look
06:15:24 <Adamant> mux: alright, then I'll let you make the recommendations :P
06:15:45 <merijn> mux: Ok, I'll go with that one, once I finish Introduction to Algorithms
06:15:48 <jedbrown> Cale: I know.
06:15:51 <mux> merijn: did that for TAPL, and it was so violently interesting that I bought my copy of the book like 2 days later
06:15:52 <rovar> anyone know if there is a trick to connectTo?  I'm trying to connect to a simple TCP server that is up:
06:15:55 <rovar> *MongoClient> connectTo "localhost" $ PortNumber 27017
06:15:55 <rovar> *** Exception: connect: does not exist (Connection refused)
06:16:03 <Cale> cale.yi.org resolves okay for me, but not www.yi.org, strangely enough.
06:16:32 * mux finally went through ATAPL with the feeling of having gotten it all, btw. Yay!
06:16:43 <Axman6> rovar: so you can telnet into that port?
06:16:49 <rovar> yes
06:16:52 <mux> it's a LOT less gentle than TAPL
06:17:44 <jedbrown> Cale: Is it possible to implement a plugin architecture in Haskell?  That is, to dynamically load implementations from a shared library.
06:17:48 <rovar> i have a sniffer of sorts on that port and I'm getting thes when I attempt to use connectTo : *** Invalid IP header length: 0 bytes
06:17:59 <Cale> jedbrown: yes
06:18:28 <jedbrown> Ah, cool.  Last time I snooped around, shared library support was weak/missing.  How?
06:18:30 <Cale> jedbrown: It's easy enough to do with something like hint
06:18:42 <Cale> Oh, .so files I don't know how to manage myself.
06:18:45 <mux> jedbrown: it's in 6.12.1
06:18:51 <mux> and working fine
06:18:54 <Cale> But you can get away with either .hs or .hi and .o
06:19:02 <jedbrown> mux: Yeah, I just updated today.
06:19:06 <Cale> mux: what library?
06:19:14 <rovar> withSocketsDo has no effect (as expected)
06:19:18 <Cale> Are you thinking of just split objects?
06:19:30 <mux> Cale: heh? any library
06:20:53 <Cale> mux: I mean, how to dynamically load code from .so at runtime.
06:21:13 <mux> oh, that I don't know
06:21:19 <Cale> mux: My understanding was that they offer a mode of compilation where the RTS is loaded from a .so
06:21:27 <Cale> but that's not quite the same thing :)
06:21:38 <mux> yes
06:21:45 <jedbrown> So an example use case would be linear solvers.  In a simple world, we have Krylov accellerators, preconditioners, and matrices.  Matrices are assembled through a generic interface, but the format makes a big performance difference, and can be dependent on the preconditioner you want to use with it.
06:21:46 <mux> that would be the -dynamic flag, and that works fine
06:21:56 <mux> I have a bytestring hello world executable here, fully dynamically linked
06:21:59 <mux> (~7kB)
06:22:18 <mux> that means linked to the .so version of the RTS, of bytestring, and a few others
06:22:22 <mux> (base..)
06:22:27 <Cale> yeah
06:23:04 <Cale> jedbrown: I don't really understand why that involves dynamically loading code at runtime, or perhaps I misunderstood your question altogether.
06:23:20 <jedbrown> Vendors implement the Mat so the kernels work well on their hardware, but don't want to distribute source.  So we want to be able to build the user code and the algorithms library, then distribute the vendor's Mat as a separate package.
06:23:21 * Cale feels a vague sense of deja vu...
06:23:28 <Cale> oh, I see
06:23:46 <Cale> Heh, I haven't thought much about non-open-source code in Haskell.
06:24:21 <Cale> But you can get away with something where you distribute .o (and .hi?) files which are loaded at runtime.
06:24:47 <jedbrown> Similarly, other users create new algorithms and want to distribute their PC so that users can experiment with them without recompiling.
06:25:25 <jedbrown> Yeah, that's probably okay, but wouldn't that be slow if there are lots of pieces?
06:26:10 <Jafet> Slow compared to?
06:26:11 <Philonous> Is that on FreeBSD?
06:26:12 <ddarius> b0fh_ua: The thing is, none of your code is in CPS.  nextAction is a HOF, but f isn't equivalent to a continuation; it's just a function.  You can mechanically CPS transform the code, but it isn't going to do any interesting control effects.
06:26:30 <jedbrown> Jafet: compared to loading it from a .so
06:26:49 <Jafet> Well, you only need to load it once...
06:26:55 <Jafet> ...per program run.
06:27:38 <jedbrown> Exactly, and if there are, say 100 of these things to load on every run (because everything is packaged as a plugin), that could be expensive.
06:28:49 <Jafet> Each run of a numerical program does a lot of work, though
06:29:56 <Cale> jedbrown: The biggest issue with it I think is that including the GHC API in your executable makes the program huge.
06:30:09 <Cale> (it contains a complete compiler :)
06:30:10 <jedbrown> When testing, I get annoyed if it takes more than 1 or 2 seconds.  Production runs are different, but the testing phase is when we're changing the algorithms constantly, thus when the plugins are most useful.
06:30:21 <Jafet> Do you have to include all of it all the time?
06:30:32 <Cale> I'm not sure how that goes
06:31:05 <jedbrown> The only reason not to is to speed up the load time.  It's fast now (in C), and I wouldn't welcome reduced flexibility.
06:31:45 <jedbrown> Cale: Yeah, that's a concern, somewhat less so if it's linked as a shared library.
06:31:48 <Jafet> You could put the API in a .so and link to that
06:32:06 <Jafet> echo echo
06:33:30 <Cale> jedbrown: But it is convenient that you can use .hs files directly as modules.
06:33:36 <b0fh_ua> ddarius: I'm just trying to understand how CPS works and when it should be applied
06:34:33 <b0fh_ua> As far as I understood for now, there should be a function, which is called and used to evaluate next expression to evaluate the entire function
06:34:41 <b0fh_ua> but it's still not clear enough for mw
06:34:43 <b0fh_ua> *me
06:36:03 <jedbrown> Cale: Yes, and it enables some interactivity.
06:36:44 <Jafet> Seems to work fine in Lisps
06:37:04 <Jafet> They don't need or use massive compilers, though
06:37:33 <Yolarina> b0fh_ua: CPS is the number of characters typewritten per second.
06:37:35 <jedbrown> Yeah, lisps are good for this, and CLOS is pretty cool.  Though I really like static typing.
06:37:56 <Jafet> As in, their ability to load and freeze code
06:38:09 <Jafet> It's literally push the red button
06:38:58 <jedbrown> We've thought about moving a lot of the high-level dispatch out of C, probably the single biggest limitting factor is poor debugging as you cross back and forth between languages.
06:39:34 <ddarius> b0fh_ua: There's rarely a need to explicitly use CPS, rather, CPS is a way to implement certain control constructs particularly call-with-current-continuation (a.k.a. call/cc).  call/cc and its relatives are typically what you actually use.  I would recommend looking at usages of call/cc and how they are used.
06:44:16 <b0fh_ua> hm
06:44:37 <ketil> Anybody know how to get at cmdargs' default parameters, -v and -q?
06:49:36 * ketil sighs.  It is the global functions is{Loud,Normal,Quiet}
06:49:56 <ketil> I should read the source more often.
06:51:12 <benmachine> is the only disadvantage to library-profiling: True in .cabal/config that I get longer build times?
06:51:20 <benmachine> (and presumably more HD space chewed)
06:51:41 <ddarius> benmachine: Pretty much.
06:51:42 <Saizan> benmachine: yes
06:52:08 <benmachine> I see there's executable-profiling too
06:52:19 <benmachine> under what circumstances would I want to profile an executable?
06:53:04 <Saizan> when it's the one you're developing i think, so i wouldn't turn that on in config
06:53:14 <benmachine> hmm, is it a good idea to save time/space by turning library-vanilla off and only building profiled libraries?
06:53:34 <benmachine> or alternatively, I could probably do fine building only vanilla libraries except when I actually needed to profile
06:53:40 <benmachine> which is basically never
06:54:19 <Saizan> to build an executable with profiling enabled you need the profiling version of all the libs used
06:55:00 <Saizan> profiled libraries and executables are slower
06:55:15 <benmachine> oh? I thought it just didn't get you information about non-profiled libraries
06:55:26 <benmachine> I don't care much about speed
06:55:32 <Saizan> and there's currently no easy way to tell cabal "build me the profiled verion of the deps of this exe too" you've to do that manually
06:55:51 <benmachine> okay
06:58:52 <benmachine> I wish there was an easy way to remove libraries
06:59:44 <Yolarina> I don't use libraries. Solves all my problems. :D
07:00:45 <Jafet> You can't solve any problems
07:00:51 <Yolarina> Haha!
07:01:58 * benmachine is trying and failing to build cpphs as a dynamic library
07:02:04 <benmachine> cabal: <command line>: Failed to load interface for
07:02:04 <benmachine> `Language.Preprocessor.Cpphs':
07:05:14 <benmachine> hmm
07:05:37 <benmachine> it looks like ghc is looking for .hi files to make the ABI hash
07:05:43 <benmachine> but I have .p_hi and .dyn_hi
07:06:20 <benmachine> it only worked when I re-enabled building vanilla libraries
07:08:12 <b0fh_ua> ddarius: can you please explain to me: let's say that I want to convert the function String->[String]->IO([String]) to CPS one. So, I have to provide the additional parameter - a fucntion, which explains what to do next. So it will be String->[String]->()->IO([String]). Which type that function should have, especially it think that it will call itself?
07:08:18 <benmachine> so now I appear to be installing three copies of everything :P
07:08:36 * benmachine gets rid of profiling libraries
07:12:01 <benmachine> can anyone else check if ghc 6.12 has problems when cabal tries to build only profiling libraries?
07:15:41 <ddarius> b0fh_ua: The CPS transform of a type is not to just add a function.  A CPS transformed function doesn't return a value, rather it passes the value it formerly returned to the continuation.  Taking in account the IO monad, you'd want a type like: String -> [String] -> ([String] -> IO a) -> IO a, where instead of returning a [String] you pass it to the continuation.
07:24:01 <b0fh_ua> ddarius: so IO([String]) is wrong in my case?
07:24:52 <ddarius> b0fh_ua: If you choose a to be [String], then you would get that type, but that limits what the (ultimate) continuation can do.
07:25:25 <b0fh_ua> ddarius: I simply can't think in such way :(
07:27:12 <b0fh_ua> I have to write function which takes 3 parameters: current line, previously read lines and the function "what to do next". If "quit" is matched to current line, then I can return previously read lines. If it doesn't - I have to call the function to process the result. Result would be current line appended to previously read lines
07:27:22 <b0fh_ua> Is that still correct?
07:29:02 <ddarius> I don't know what criterion you are using to judge "correct", so, I don't know.
07:31:21 <b0fh_ua> ddarius: http://pastebin.com/d5a6940d6 - that's what I tried to say.
07:33:09 <b0fh_ua> ddarius: and now, I am lost of how to use this function
07:38:05 * hackagebot upload: unix-io-extra 0.1 - Support for writev, pwrite and pread. (TaruKarttunen)
07:41:43 <Runar> Need a clever name for a type class. class (Monoid m) => Foo a m b where {unit :: a -> m; counit :: m -> b }
07:42:04 <Runar> "RunarArrow"
07:43:19 <tromp_> > 871+184
07:43:20 <lambdabot>   1055
07:43:24 <Chaze> Is there a name for (\x y -> x y) ?
07:43:44 <mercury^> flip id
07:44:01 <Paczesiowa> @pl \x y -> x y
07:44:02 <lambdabot> id
07:44:15 <mercury^> oh, thought it was x y -> y x
07:44:41 <Chaze> i'd call it "apply"
07:44:54 <Paczesiowa> we call it ' '
07:44:59 <opqdonut> ($) is a name also
07:45:00 <dino-> :t ($)
07:45:01 <lambdabot> forall a b. (a -> b) -> a -> b
07:45:37 <Chaze> damn, why didn't i think of that :)
07:45:39 <Chaze> thank you!
07:46:58 <dino-> @src ($)
07:46:59 <lambdabot> f $ x = f x
07:53:06 <b0fh_ua> ddarius: Does this one makes more sense? http://pastebin.com/d198a529a
07:57:00 <kaQn4p> hey guys! someone here who could help a student with his exercise in haskell?
07:58:15 <Cale> kaQn4p: not until we know what you're having trouble with ;)
07:58:23 <Cale> kaQn4p: (just ask :)
07:58:53 <ddarius> kaQn4p: Looking at http://www.haskell.org/haskellwiki/Homework_help may also be useful.
07:59:06 <Beelsebob> b0fh_ua: it looks to me like something that really should be done with interact, not lots of IO functions
07:59:30 <b0fh_ua> Beelsebob: it's about CPS, just for learning
07:59:35 <Beelsebob> ah, I see
07:59:48 <Beelsebob> seems sane to me
08:05:00 <ddarius> b0fh_ua: Presumably you want to do something like, readUntil [] readLines, but if you inline that you just get a normal recursive function.  Basically, readLines is just an abstraction of an if-statement.
08:07:51 <b0fh_ua> ddarius: so I missed again? :(
08:10:31 <ddarius> http://pastebin.com/d61fba172
08:10:41 <McManiaC> There are problems in package mtl-1.1.0.2: dependency "base-4.2.0.0-f87cc184652024ad761422b6a80d0306" doesn't exist
08:10:50 <McManiaC> I get this on ghc-pkg check
08:11:00 <McManiaC> after updating to 6.12
08:11:11 <ddarius> :t let readLinesK k = do line <- getLine; if line == "quit" then k [] else readLinesK (\lines -> k (line:lines)) in readLinesK
08:11:12 <lambdabot> forall b. ([String] -> IO b) -> IO b
08:11:50 <taruti> why is: "data T t where A :: { foo :: Int } -> T Int; B :: { foo :: Bool } -> T Bool" not allowed?
08:12:25 <McManiaC> that looks like a class, not data
08:12:52 <aavogt> perhaps that isn't the right form for making record accessors with GADT syntax
08:13:07 <b0fh_ua> ddarius: hm. That completely confuses me.
08:13:48 <taruti> and neither is: "data T t = where A :: { foo :: Int} -> T Int; B :: { foo :: Int } -> T Bool" :(
08:14:05 <aavogt> taruti: I've only seen records defined with the normal ADT syntax
08:14:19 <ddarius> taruti: I'm not aware of any notation for using record syntax with GADTs, but that could be a lack of my own.
08:14:20 <McManiaC> taruti: that doesnt make much sense tbh
08:14:21 <McManiaC> ^^
08:14:26 <taruti> aavogt: there is a record GADT syntax existing.
08:14:39 <McManiaC> what is GADT?
08:14:46 <aavogt> @where gadt
08:14:46 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
08:14:52 <taruti> McManiaC: both could be quite validly typed.
08:14:55 <aavogt> well that's broken
08:14:56 <McManiaC> 404
08:15:02 <Philonous> You can use record fields ind GADTs, but I think you can only have on constructor in that case
08:15:20 <aavogt> @where+ gadt http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
08:15:20 <lambdabot> Okay.
08:15:26 <aavogt> @where gadt
08:15:26 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
08:15:42 <Philonous> taruti: I think ghc is not smart enought to figure out that foo could indeed have a valid type
08:16:28 <ddarius> According to the above, taruti is using the wrong syntax.
08:17:37 <aavogt> Philonous: but it could have a valid type?
08:17:41 <ddarius> taruti should be writing: data T t where A { foo :: Int } :: T Int; B { foo : Bool } :: T Bool
08:17:51 <ddarius> + a :
08:18:13 <taruti> ddarius: actually the arrow notation works, fine.
08:18:22 <Philonous> aavogt: foo :: T a -> a
08:18:42 <aavogt> I see that as defining:    foo :: A Int -> Int, foo :: A Bool -> Bool
08:19:13 <taruti> Philonous: I'd like to have record update syntax, and thus defining by hand does not help.
08:19:35 <ddarius> According to the above, there is a constraint that every field needs to have the same result type, so that you cannot do what you want.
08:20:03 <taruti> ddarius: see the later example, that is not enough.
08:20:25 <ddarius> I.e. data T t where A { foo :: Int } :: T Int; B { foo :: Bool } :: T Int is fine, but data T t where A { foo :: Int } :: T Int; B { foo :: Bool } :: T Bool is not.
08:20:30 <Philonous> taruti: You may want Data.Accessor
08:20:52 <taruti> "data T t where A { bar :: Int } -> T (); B { bar :: Int } -> T Char" does not work either
08:21:12 <ddarius> taruti: Yes, that's another example of that constraint.
08:21:23 <aavogt> Philonous: I think it would be wrong to give foo the generalized type, since that would allow the following update:      (x :: T Int) { foo = 1.2 :: Double }
08:21:24 <taruti> bar :: T any -> Int
08:21:48 <ddarius> When the fields have the same name, the result type (i.e. the final T x) must be the same (i.e. have the same thing for x)
08:22:01 <taruti> Philonous: did data accessor support polymorphic things?
08:22:06 <aavogt> which shouldn't work with any constructor...
08:22:44 <Philonous> aavogt: Right. Didn't thinak about update syntax there
08:24:17 <astroboy_> this language is stunning
08:25:04 <astroboy_> I am writing a minmax-based AI of this game: http://en.wikipedia.org/wiki/Oware
08:25:08 <taruti> of course there is "class HasFoo t where type Foo t; foo :: t -> Foo t; setFoo :: Foo t -> t -> t"
08:25:16 <astroboy_> and the AI in itself is like 70 lines
08:25:24 <astroboy_> and quite fast
08:27:03 <taruti> which generalizes nicely to: "class Accessor struct field where type FType struct field; get :: field -> struct -> FType t; set :: field -> FType t -> t -> t", but that ends up with the open record label declaring hell.
08:29:20 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15896#a15896
08:29:25 <HugoDaniel> can someone help me out ?
08:30:08 <Polarina> What
08:30:08 <taruti> How I wish GHC did support something like Hugs T-Rex :(
08:30:15 <Polarina> What is the difference between CInt and Int?
08:30:33 <taruti> Polarina: they are different types. Use fromIntegral.
08:30:42 <pikhq> @source CInt
08:30:43 <lambdabot> CInt not available
08:30:53 <Polarina> taruti: Ok, thanks.
08:30:54 <ehird> CInt will be 32-bit on amd64 but Int will be 63-bit, I believe
08:31:05 <pikhq> s/63/64/
08:31:06 <Polarina> I see.
08:31:09 <ehird> pikhq: no
08:31:12 <ehird> pikhq: tag bit for the GC
08:31:15 <ehird> i'm fairly sure
08:31:17 <pikhq> Oh, right.
08:31:23 <HugoDaniel> what is the largest tuple ghc supports ?
08:31:25 <pikhq> Anyways. CInt = C long?
08:31:29 <ehird> HugoDaniel: infinite
08:31:29 <quicksilver> ehird: you're wrong.
08:31:35 <HugoDaniel> no
08:31:36 <ehird> HugoDaniel: there's only show instances for up to 8 though iirc
08:31:37 <quicksilver> ehird: GHC doesn't use any bits.
08:31:39 <taruti> pikhq: CInt = "int in C"
08:31:39 <HugoDaniel> its not
08:31:40 <HugoDaniel> ah
08:31:46 <ehird> HugoDaniel: you can write your own ofc
08:31:46 <quicksilver> hmm, what a daft thing to say :)
08:31:57 <quicksilver> but, anyhow, GHC doesn't "steal" any bits from value types like that.
08:31:57 <pikhq> taruti: So, a CInt is 32-bit on amd64.
08:32:03 <quicksilver> a data word is a full word
08:32:08 <ehird> quicksilver: So how does the GC avoid seeing unfortunately-valued integers as pointers?
08:32:10 <ehird> It doesn't?
08:32:15 <ehird> Bah, I hate conservative collectors.
08:32:21 <ehird> I hate them with my eyes.
08:32:21 <HugoDaniel> ehird: how do i do that ?!
08:32:22 <leimy_> I'm wondering what this syntax means "class BuildList a r | r-> a where"
08:32:27 <leimy_> What's with the |?
08:32:30 <quicksilver> ehird: it knows which things are pointers.
08:32:43 <quicksilver> ehird: it never follows an Int, because it knows that's an Int.
08:32:45 <quicksilver> ehird: type systems ftw.
08:32:50 <ehird> HugoDaniel: instance Show (a,b,c,d,...) where show (a,b,c,d,...) = "(" ++ intercalate "," (map show [a,b,c,d,...]) ++ ")"
08:32:58 <HugoDaniel> ah :(
08:32:59 <HugoDaniel> okey
08:33:08 <ehird> quicksilver: Yes, but there is no type information at runtime.
08:33:12 <quicksilver> ehird: just like it never follows the inside of a ByteString, or an UArray, or anything like that.
08:33:15 <aavogt> leimy_: functional fependencies
08:33:17 <pikhq> ehird: Boxing.
08:33:20 <ehird> quicksilver: So clearly the GC must store data somewhere marking what's a smallint.
08:33:30 <ehird> pikhq: no, I'm fairly sure Int is unboxed if you use it directly
08:33:37 <leimy_> ah
08:33:38 <ehird> i'm also fairly sure #Int doesn't break things
08:33:50 <quicksilver> ehird: Int# doesn't break things, but the GC will never follow things
08:33:53 <aavogt> it means that for each r there is only one a
08:33:55 <quicksilver> because it knows it's an Int#
08:34:07 <ehird> quicksilver: That is exactly my point: it has to store the knowledge of what things are somewhere.
08:34:17 <quicksilver> it doesn't have to store that knowledge, its innate knowledge
08:34:21 <ehird> Because GHC erases types in compilation, no?
08:34:33 <ehird> quicksilver: ok, we're not communicating properly here
08:34:38 <leimy_> aavogt: so if means "all a's must be the same" ?
08:34:41 <quicksilver> the very representation of all data distinguishes pointers from non-pointers.
08:34:41 <leimy_> like the same type?
08:34:52 <aavogt> so you could ex. resolve the specific instance based on only   'r'
08:34:55 <ehird> quicksilver: but a pointer is e.g. 0110
08:34:59 <ehird> so if you had the Int 0110
08:35:09 <ehird> it would be indistinguishable from the pointer 0110
08:35:10 <leimy_> aavogt: so each r's a could have been a different type?
08:35:21 <quicksilver> ehird: yes it would, indeed. But it doesn't look at every word.
08:35:24 <ehird> quicksilver: the only way to resolve this without storing information about types *somewhere* is a tag bit.
08:35:32 * leimy_ was trying to understand how the variadic function thing works in Haskell :-)
08:35:35 <quicksilver> ehird: it only looks at those words which might be pointers.
08:35:35 <ehird> quicksilver: so ghc aligns its code so that ints only appear in some positions or sth?
08:35:42 <temoto> Hello. Yesterday you guys talked much about OOP problems, in particular mentioned inheritance as one of major ones. But i didn't understand what's wrong with inheritance.
08:35:43 <quicksilver> no, it's not alignment either.
08:35:52 <quicksilver> it's structured traversal of heap and stack.
08:36:10 <ehird> Okay, so there must be some element of the structure which indicates an int/pointer is here.
08:36:10 <aavogt> leimy_: instance BuildList Int Word where ...  means that you cannot have a:   BuildList String Word where ...
08:36:17 <quicksilver> yes, there is
08:36:18 <ehird> So it is storing something, somewhere, in the structure.
08:36:21 <ehird> Which is my point.
08:36:21 <quicksilver> right
08:36:23 <quicksilver> yes
08:36:33 <quicksilver> but it's not internal to the word.
08:36:35 <ehird> Seems like it'd be a hell of a lot easier just to lose one bit on Ints, though. :)
08:36:39 <quicksilver> it's the structure of GHC heap objects.
08:36:55 <quicksilver> ehird: with respect, you've just demonstrated you don't understand it well enough to make that judgement ;)
08:37:00 <quicksilver> but it is a complex tradeoff.
08:37:27 <ehird> quicksilver: well, tagged ints does indeed make arithmetic slower
08:37:29 <quicksilver> and I certainly dont' understand the details of how it was made.
08:37:53 <pikhq> ehird: Probably no point in tagging boxed Ints. Might as well just have a tag member of the struct.
08:37:56 <ehird> because you have to tag them with 1 (because pointers end in 0) and so you have to unpack them every time you want to do arithmetic
08:37:56 <McManiaC> anyone with archlinux and ghc 6.12 here? mtl is broken because base-4.2 seems to be missing =(
08:38:00 <ehird> pikhq: Int isn't boxed.
08:38:02 <ehird> afaik
08:38:12 <ehird> or at least, Int# doesn't break things, so let's assume we're talking about Int#
08:38:29 <pikhq> Int# is probably tagged.
08:38:34 * leimy_ just installed 6.12.1 on Mac OS X on a different machine yesterday
08:38:48 <pikhq> I'd grep the source, but... That's a lot of source.
08:38:52 <sproingie> woo, unboxed arrays = WIN
08:38:52 <aavogt> leimy_: you don't need fundeps and multi parameter type classes to write variadic functions
08:39:07 <aavogt> :t printf
08:39:08 <lambdabot> forall r. (PrintfType r) => String -> r
08:39:42 <quicksilver> Int# is not tagged.
08:39:44 <quicksilver> Int is boxed.
08:39:47 <leimy_> The r is what?
08:39:49 <aavogt> printf can take multiple parameters, while it uses a single parameter typeclass
08:39:49 <leimy_> anything right?
08:39:51 <quicksilver> In fact, Int is just a boxed Int#
08:39:53 <leimy_> so it could be a continuation?
08:39:55 <ehird> pikhq: considering that you can do T# for any T, I doubt any are special-cased
08:40:02 <ehird> leimy_: continuation is just a function
08:40:03 <leimy_> like another PrintfType.
08:40:07 <ehird> but yeah, that's the idea
08:40:08 <leimy_> right...
08:40:10 <aavogt> leimy_: yeah, you get multiple arguments when r is a function
08:40:16 <quicksilver> ehird: what do you mean you can "do T# for any T" ?
08:40:18 <ehird> r can be (PrintfType r => String -> r)
08:40:23 <quicksilver> ehird: # is just a convention.
08:40:25 <leimy_> And PrintfType itself is a function :-)
08:40:27 <ehird> quicksilver: it is?
08:40:29 <ehird> I'm mistaken, then
08:40:43 <quicksilver> ehird: yes, # is just a convention meaning "this stuff is internal to GHC"
08:40:47 <leimy_> I guess I wonder how it terminates :-)
08:40:54 <aavogt> @instances PrintfType
08:40:55 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
08:41:01 <aavogt> @instances-importing PrintfType
08:41:01 <ehird> quicksilver: The fact that you have to do -XMagicHash made me think it was a magical unboxing facility.
08:41:02 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
08:41:05 <leimy_> There must be a PrintfType instance that is not a function :-)
08:41:09 <ehird> For some reason.
08:41:15 <ehird> leimy_: yes, IO ()
08:41:22 <leimy_> or String
08:41:23 <ehird> or for sprintf, String
08:41:24 <leimy_> :-)
08:41:25 <ehird> etc
08:41:27 <ehird> oh
08:41:30 <ehird> they're the same function, I forgot
08:41:37 <ehird> not sure i like that part so much :)
08:42:28 <quicksilver> ehird: it's just like LaTeX using @
08:42:28 <leimy_> Oh this is a lot easier to understand than I thought...
08:42:29 <leimy_> thanks!
08:42:33 <quicksilver> (if you're familiar with that)
08:42:46 <quicksilver> just a convention of taking an illegal character and making it legal for internals
08:42:51 <ehird> I'm not as familiar with LaTeX as I'd like, but that makes sense.
08:42:56 <quicksilver> to be sure you can't stomp on anyone else's legal characters.
08:43:28 <ehird> I eagerly await the day when we have IsType for every kind of literal.
08:43:35 <ehird> Override function literals? Don't mind if I do.
08:57:57 <tommd> cjs: Data.Binary _can_ get 4 Word8s from a Word32.  Just "Data.Binary.Lazy.unpack $ runPut (putWord32{be, le} val) :: [Word8]"
08:59:43 <cjs> Ah, of course. I was thinking Binary.Char8, not Binary.Word8. Duh. Still, rather a hack....
09:01:58 <holmak> what does black hole mean in the context of concurrent haskell?
09:03:09 <Berengal> holmak: When a thread is evaluating a thunk, it turns it into a black hole such that any other thread that tries to read the same thunk is put to sleep when it does so
09:03:37 <Berengal> holmak: Which means the worker thread is free to make progress on other threads until the thunk is evaluated
09:03:43 <Berengal> (IIRC)
09:04:11 <McManiaC> package mtl-1.1.0.2 is broken due to missing package
09:04:14 <McManiaC> base-4.2.0.0-f87cc184652024ad761422b6a80d0306
09:04:24 <McManiaC> anyone got this error after upgrading to 6.12?
09:04:38 <McManiaC> ghc-pkg list shows base-4.2.0.0
09:05:04 <Berengal> McManiaC: What does ghc-pkg describe base say for its id?
09:05:13 <sproingie> unboxed arrays of Bool aren't actually packed bit arrays, are they?
09:05:23 <McManiaC> id: base-4.2.0.0-2cc27b7e43511c4ca001642a7f77a8f6
09:06:00 <sproingie> i suspect they use a whole byte, just wondering if anyone knows for sure
09:06:02 <Berengal> McManiaC: Have you tried reinstalling mtl?
09:06:04 <thoughtpolice> sproingie: I actually think GHC is smart enough to convert an unboxed array of bools into a compact bit-level representation
09:06:24 <Berengal> sproingie: Take a gander at the code. It'll tell you
09:06:25 <thoughtpolice> at least I've heard it does such optimization - only way to see is to check :)
09:06:36 * hackagebot upload: HaXml 1.20.2 - Utilities for manipulating XML documents (MalcolmWallace)
09:07:08 <Berengal> McManiaC: you might have to purge it entirely, downloading a new version... I have some similar problems, but I haven't solved them
09:07:19 <McManiaC> Berengal: yes I did
09:07:36 <Paczesiowa> any developers of hint package here?
09:07:50 <Berengal> McManiaC: Even the purging bit? I haven't tried that and hoped it would work for me...
09:08:09 <McManiaC> what do you mean by purging?
09:08:29 <Berengal> ghc-pkg unregister, delete files
09:08:39 <McManiaC> hm ok
09:08:42 <McManiaC> gonny try…
09:10:18 <Alpounet> should try bidolio too.
09:10:19 <McManiaC> Berengal: hmm seems to work
09:10:19 <McManiaC> thx
09:10:21 <sioraiocht> with fundeps, can I to class Foo x y | x -> y, y -> x?
09:10:23 <sioraiocht> *do
09:10:33 <Berengal> McManiaC: Awesome
09:10:36 * Berengal does that too
09:11:23 <Berengal> McManiaC: This happening is a bug though. We should probably report it...
09:11:32 <ehird> Is there any reason to use Rank2Types over RankNTypes?
09:12:52 <McManiaC> Berengal: yeah…
09:13:09 * Berengal thinks it happened when he turned on profiling
09:13:16 <Berengal> But I really have no idea...
09:16:07 <joe1> i am just trying out Parsec and noticed that there is Text.ParserCombinators.Parsec . wondering if there is a module to parse binary data? I have binary data that I am converting to bits(in a list) and am planning on using Parsec to parse the data. Any thoughts, please?
09:17:08 <Berengal> joe1: Take a look at the binary package, or cereal
09:17:23 <Berengal> cereal is a bit more like parsec, I think. I haven't used any of them
09:17:29 <Berengal> (But I read blogs)
09:17:54 <joe1> Berengal: I thought you were kidding when you mentioned "cereal". I will just check out "cereal"
09:18:01 <Cale> joe1: Text.ParserCombinators.Parsec is the old module path, by the way
09:18:36 <joe1> Cale: I tried ":m +Parsec", I got the path from RWH.
09:18:37 <Saizan> joe1: see attoparsec
09:18:43 <joe1> Saizan: thanks.
09:18:56 <joe1> Cale: what is the new path?
09:19:03 <Cale> Text.Parsec
09:19:20 <McManiaC> ok another problem with ghc 6.12: System.Log.Logger cannot be found
09:19:27 <McManiaC> but it *is* installed
09:19:58 <maltem> Interesting (to me) newbie performance question: http://www.reddit.com/r/haskell/comments/apm5d/why_are_haskell_complex_floats_so_much_slower/
09:20:04 <Saizan> McManiaC: in the global or user db? and what commad are you running?
09:20:26 <McManiaC> Saizan: user
09:20:31 <McManiaC> and a "import ..." in my .hs file
09:20:54 <temoto> Cale: Hello. Yesterday you talked about OOP problems, in particular mentioned inheritance as one of major ones. But i didn't understand what's wrong with inheritance.
09:21:29 <Saizan> McManiaC: how are you compiling your .hs file?
09:21:34 <temoto> in particular, haskell type classes do inheritance too
09:21:55 <McManiaC> Saizan: ghc --make Main.hs... I cannot load that module in ghci either
09:22:05 <McManiaC> Saizan: although, libs that depended on it build perfectly…
09:22:21 <Cale> temoto: I talked about OOP... I don't think I said that inheritance was a major problem, that might have been someone else. I just don't think it's essential to what OOP is.
09:22:22 <jedbrown> temoto: Inheritance with state is brittle.  Type classes are essentially interfaces which languages like C++ implement using inheritance.
09:22:24 <maltem> temoto, type classes really aren't about inheritance, unless you count default methods as such
09:22:32 <McManiaC> Saizan: the same thing happens with libmpd too.
09:22:45 <Alpounet> class Storage s where smap :: (a -> b) -> s a -> sb
09:22:49 <Alpounet> what's wrong here ?
09:22:53 <Alpounet> s b*
09:22:57 <Saizan> McManiaC: can you tell me the output of ghc-pkg find-module System.Log.Logger ?
09:23:03 <Cale> Inheritance indeed *can* be a problem, in that inherited code is not always the right code, and you can silently create bugs that way.
09:23:12 <Alpounet> I get :
09:23:17 <McManiaC> /usr/lib/ghc-6.12.1/package.conf.d
09:23:17 <McManiaC> /home/nils/.ghc/x86_64-linux-6.12.1/package.conf.d hslogger-1.0.7
09:23:17 <Alpounet> `s' is applied to too many type arguments
09:23:20 <McManiaC> @ Saizan
09:23:21 <Cale> and multiple inheritance has lots of tangly issues associated with it
09:23:44 <aavogt> can you emulate multiple inheritance in Haskell?
09:23:57 <Saizan> McManiaC: then ghc doesn't agree with you about having a package with that module installed :)
09:24:01 <maltem> Alpounet, is there more code to your class definition, where you use s without an argument?
09:24:14 <temoto> aavogt: i believe it doesn't even require emulation.
09:24:16 <McManiaC> Saizan: ?
09:24:24 <Alpounet> maltem, s is always applied to another type
09:24:29 <Philonous> Alpounet: The line you gave is fine
09:24:35 <Paczesiowa> you can things with multiple inheritance in OOHaskell that you can't emulate in other languages
09:24:37 <Saizan> McManiaC: oh, i missed a line
09:24:38 <temoto> aavogt: there is plenty of classes that descend from several other classes.
09:24:45 <aavogt> I know the trick with the    \self -> Constructor { x = f self }
09:24:58 <Alpounet> maltem, Philonous, actually there is a Show constraint on s and 3 other functions, but nothing else.
09:25:08 <Alpounet> I'll paste the whole code wait
09:25:09 <maltem> Alpounet, maybe paste them anyways
09:25:11 <Cale> temoto: typeclasses in Haskell have a concept of "subclass", but typeclasses don't really correspond in such a natural way with OO classes (more like interfaces), and there's no inheritance.
09:25:13 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15900#a15900 <- someone seen this before?
09:25:45 <Cale> temoto: No inheritance at all, let alone multiple.
09:25:53 <aavogt> Paczesiowa: I guess I'll have to finish reading that paper then
09:25:56 <Saizan> McManiaC: weird then, are you sure the ghc you're running is the one corresponding to that ghc-pkg? you could also try ghc-pkg check to see if there's an obvious problem
09:26:06 <temoto> Cale: what about Integral being Ord and Eq and whatelse?
09:26:27 <temoto> i know that haskell type classes aren't OO classes
09:26:30 <Cale> temoto: That just means that anyone who wants to write an instance of Integral for some type must also write instances of Eq and Ord
09:26:44 <Cale> temoto: It doesn't automate the process.
09:26:47 <McManiaC> Saizan: ghc-pkg check gave me a "do a recache" message and this got returned by ghc-pkg recache:
09:26:50 <McManiaC> ghc-pkg: /home/nils/.ghc/x86_64-linux-6.12.1/package.conf.d/hsx-0.5.6-25ea707932cd07eb6c88d729da32c860.conf: hGetContents: invalid argument (invalid UTF-8 byte sequence)
09:26:58 <temoto> Cale: and that's a proof to any users of Integral that they may use Eq methods.
09:27:08 <maltem> Berengal, does it help to reinstall syb-with-class?
09:27:08 <Cale> temoto: right.
09:27:09 <Philonous> Cale: Well, "instance Monad m => Functor m where fmap = liftM" looks a bit like inheritance
09:27:15 <Saizan> temoto: inheritance refers to inheriting the implementation of methods, and it's tied to the open recursion model of OOP objects, typeclasses have nothing of this
09:27:22 <Cale> Philonous: It would, if it were valid.
09:27:24 <Alpounet> maltem, Philonous, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15901#a15901
09:27:28 <maltem> Berengal, not that I'd have an idea ;)
09:27:34 <Berengal> maltem: I've tried that, in several ways, all of which result in the same error
09:27:48 <temoto> hm.. alright, i wasn't thinking about inheritance of implementation
09:27:56 <maltem> Alpounet, ah, "Show s" implies that s has kind *
09:27:58 <Philonous> Cale: What's the problem with it?
09:28:08 <Alpounet> maltem, oh, yeah
09:28:11 <Philonous> Cale: It's valid haskell afaiks
09:28:16 <Alpounet> I should just write deriving Show
09:28:17 <Cale> Philonous: Overlaps with every instance of Functor
09:28:20 <Alpounet> after the typeclass decl
09:28:24 <Alpounet> and it should be okay I guess
09:28:35 <jedbrown> temoto: Then you are just composing interfaces.  Type classes are great at that.
09:28:38 <Saizan> Philonous: you need OverlappingInstances and UndecidableInstances to make that work
09:28:43 <Cale> Philonous: Remember that class contexts can't be taken into consideration when selecting instances.
09:28:49 <maltem> Alpounet, you could use (s a), but maybe it's better to just drop the constraint
09:28:52 <Philonous> Cale: Oh, ok, but in principle it is possible to do this if you don't have other instances
09:28:53 <maltem> *Show (s a)
09:28:59 <Alpounet> malcolmw, yeah
09:29:03 <Alpounet> maltem*
09:29:11 <Cale> Philonous: At least provided enough extensions, yes.
09:29:12 <Alpounet> thanks.
09:29:25 <Cale> Philonous: It's not valid Haskell 98/2010
09:29:40 <Cale> Philonous: Because you need at least one type constructor to select on.
09:29:46 <merehap> Cale: do you know if Amigoo had any luck with his problem?
09:29:52 <Cale> merehap: I'm not sure.
09:30:00 <Philonous> Cale: I wonder whether it would be desirable to extend the instance selection so you can do stuff like that.
09:30:00 <Cale> merehap: I've been away for a while.
09:30:05 <merehap> ah
09:30:15 <Berengal> Such an instance would be pretty useless as well, since you might as well implement it as a regular function
09:30:27 <Saizan> McManiaC: i don't know how to help with that, sorry :\
09:30:46 <Cale> Philonous: It's tough, because it violates principles which make separate compilation reasonable.
09:31:20 * Berengal sometimes wants records instead of classes
09:31:37 <McManiaC> ok, so apperently ghc-pkg is broken… I cannot do anything there… not even a ghc-pkg list
09:31:44 * hackagebot upload: pointless-lenses 0.0.3 - Pointless Lenses library (HugoPacheco)
09:32:10 <Berengal> McManiaC: Time to burn everything!
09:32:11 <djahandarie> Pointless! =D
09:32:15 <temoto> Thanks for sorting things out with inheritance problems.
09:32:19 * Berengal considers doing the same
09:32:31 <Philonous> Cale: It would allow structural recursion over types. You can do that now, but it involves tricking ghc into delaying instance selection
09:32:58 <McManiaC> Berengal: hmmm
09:32:58 <McManiaC> :S
09:33:13 <sereven> McManiaC: your version of hsx may not be ready for 6.12?
09:33:29 <sereven> maybe need a newer version of it
09:33:32 <McManiaC> it should be
09:33:37 <Saizan> sereven: it shouldn't break ghc-pkg though :)
09:33:38 <maltem> McManiaC, in case you have multiple ghc's installed, maybe make sure that you don't have unversioned ghc-blah executables of different versions on your path
09:33:40 <McManiaC> i know its working with 6.12
09:34:20 <jedbrown> For how long has GHC.IO contained the IO constructor?  6.12.1 says that GHC.IOBase is deprecated, but what will I break by getting it from GHC.IO?
09:34:35 <Saizan> McManiaC: it sounds like a bug in ghc, maybe some code is doing Unicode decoding when it shouldn't
09:35:13 <maltem> Berengal, fwiw I couldn't reproduce it just now with ghc 6.12.1, I just get a bogous mkUsageInfo: internal name? Element{tc a9NF}
09:36:17 <Berengal> maltem: I'm in the progress of removing ghc entirely from my machine now. Will see if it works afterwards
09:36:31 <McManiaC> Berengal: me too
09:36:31 <McManiaC> ^^
09:36:31 <temoto> Is matching against some class more "costly" than against concrete type?
09:36:56 <Cale> jedbrown: Why are you using the IO constructor directly?
09:36:58 <McManiaC> I hope I didnt miss out on anything… /usr/lib/ghc* ~/.ghc ~/.cabal - anywhere else where I'd look?
09:37:01 <McManiaC> *should
09:37:30 <Berengal> McManiaC: /usr/local
09:38:00 <McManiaC> kay
09:38:03 <McManiaC> nothing there
09:38:09 <Cale> temoto: Typeclass selection is something which is done by passing records of implementations around, separately from the actual data.
09:38:20 <jedbrown> Cale: to define unsafeInlinePerformIO, before it become available in GHC
09:38:23 <Cale> temoto: There is a bit of an extra cost involved.
09:38:54 <gwern> unsafeInline?
09:39:20 <temoto> Cale: thanks.
09:39:36 <temoto> McManiaC: why do you write things like anythingM?
09:39:50 <jedbrown> gwern: http://hackage.haskell.org/trac/ghc/ticket/2095
09:40:04 <jedbrown> Actually, looking at that, maybe it never went in.
09:40:08 <McManiaC> temoto: hm?
09:40:26 <sproingie> wait wut an IO constructor?
09:40:50 <McManiaC> temoto: you should check your encoding, thats a utf8 char
09:41:05 <sproingie> i had no idea it was exposed somewhere
09:41:10 <joe1> attoparsec looks pretty cool.
09:42:30 <joe1> i cannot get cereal to install and do not get much confidence by googling it.. could be wrong..
09:42:33 <temoto> right, this version of weechat has troubles showing unicode
09:42:56 <jedbrown> unsafeInlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r
09:43:26 <sproingie> my goodness glut is slow on linux
09:44:05 <sproingie> or maybe immediate mode in general is
09:45:50 <ehird> HaXml is the one that enforces XML validity in the type system, right?
09:48:15 <temoto> Wait, what about deriving Show? Isn't it an inheritance of implementation?
09:48:37 <aavogt> temoto: but those are built-in
09:48:45 <McManiaC> Berengal: seems to work
09:48:51 <McManiaC> at least hes finding System.Log.Logger
09:48:51 <temoto> Oh, i can't derive from my class?
09:49:27 <McManiaC> although I havent reinstalled everything yet…
09:53:59 <ehird> temoto: use "derive" to define your own derivative stuffs.
09:54:14 <ehird> http://community.haskell.org/~ndm/derive/
09:54:49 <aavogt> that one isn't so easy to use if you want to add your own, but for the classes already in there it's quite helpful
09:54:58 <joe1> Cale: how do i install Text.Parsec? I could get "cabal install parsec" working but am not sure of how to install Text.Parsec
09:55:16 <mux> joe1: check that you have parsec 3; the Text.Parsec module only exists in this version
09:55:33 <mux> otherwise it's Text.ParserCombinators.Parsec, IIRC
09:55:37 <dcoutts> cabal install 'parsec >= 3'
09:55:41 <dcoutts> since v2 is the default
09:55:50 <mux> yeah
09:56:04 <joe1> yes, parsec-2.1.0.1 seems to be the default.
09:56:13 <joe1> dcoutts: thanks.
09:57:06 <dcoutts> (technically the default is "parsec < 3" and 2.1.0.1 is the highest version satisfying that)
09:59:06 <ehird> [17:45] <ehird> HaXml is the one that enforces XML validity in the type system, right?
09:59:11 <Paczesiowa> dcoutts: why do I get warnings about using base-3* when I install packages that depend on "base" ?
09:59:12 <ehird> or is it that xml toolbox one?
09:59:30 <ehird> HXT that is
09:59:42 <Paczesiowa> ehird: I think both of them are just regular tree based solutions
09:59:49 <dcoutts> Paczesiowa: do you mean deprecation warnings generated by ghc-6.12?
09:59:54 <ehird> I'm sure one of them has a type-system-validity thing
10:00:11 <Paczesiowa> ehird: iirc there was something better, but it was unusable for anything non-trivial
10:00:14 <Paczesiowa> dcoutts: yes
10:00:30 <dcoutts> Paczesiowa: doesn't the deprecation message explain the issue in sufficient detail?
10:01:05 <dcoutts> Paczesiowa: or is it that you're not sure how to do what it suggests?
10:01:08 <Paczesiowa> dcoutts: but why do I have to depend on base-4* ?
10:01:50 <dcoutts> Paczesiowa: you do not have to use "build-depends: base >= 4"
10:02:13 <ehird> I guess I'll have to write my own thingy that enforces validity, then.
10:02:16 <ehird> "How hard can it be?"
10:02:41 <dcoutts> Paczesiowa: if your package works with versions of base between X and Y then use "build-depends: base >= X && < Y"
10:03:15 <Paczesiowa> dcoutts: base > -1 && base < infinity?
10:03:27 <dcoutts> Paczesiowa: if you use just "build-depends: base >= 3" then cabal assumes that you only ever tested it with base 3, so it uses base 3.
10:03:45 <benmachine> my guess is you would always put base < 5 because you haven't tested with base5
10:03:52 <dcoutts> indeed
10:04:08 <dcoutts> using base < 5, indicates you did at least test it with base 4
10:04:44 <dcoutts> so with "build-depends: base >= 3 && < 5" then cabal has two choices, 3 or 4, so it picks 4.
10:04:57 <Paczesiowa> ok. maybe some day Monad(..) will be removed from Prelude:)
10:05:00 <ehird> {-# LANGUAGE ExistentialQuantification, ImpredicativeTypes, FlexibleContexts, MultiParamTypeClasses #-}
10:05:04 <ehird> All in a day's work
10:05:26 <Paczesiowa> ehird: that's it? come on - you can do better!
10:05:36 <ehird> Paczesiowa: I certainly will
10:05:44 <Paczesiowa> ehird: you cannot even loop typechecker with that...
10:05:49 <dcoutts> Paczesiowa: if all you're using is H98 then admittedly this scheme is a bit annoying, because the Prelude is in the base package, not in the H98 package.
10:06:17 <ehird> Gah, this is annoying
10:06:38 <ehird> {-# LANGUAGE ImpredicativeTypes, FlexibleContexts, MultiParamTypeClasses, RankNTypes #-}
10:06:39 <ehird> That's better
10:07:19 <Paczesiowa> dcoutts: ok, confirmation that it indeed is annoying is all I need, sorry to bother you:)
10:07:27 <ehird> It broke, how surprising
10:07:51 <ehird> I used to be able to do this :(
10:08:16 <dcoutts> Paczesiowa: in general, most packages break when you change the version of base they're built with
10:08:36 <dcoutts> Paczesiowa: which is why we implemented this scheme, to smooth the transitions between versions of base.
10:09:06 <dcoutts> many fewer packages broke between 6.8 -> 6.10 -> 6.12 than happened between 6.6 -> 6.8 when most everything broke.
10:09:29 <dcoutts> we got a lot of flak for that, so we've been trying to make the transitions better
10:10:12 <dcoutts> it has some impact on package authors/maintainers to specify more precisely what versions their package works with
10:10:59 <jmcarthur> woot, ghc 6.12 in pacman
10:11:40 <Paczesiowa> there should be a giant testing system that would run tests with different dep versions, and choose constraints isntead of package author.
10:12:03 <ehird> (IsHTML (forall a. (Child HTML a) => a))
10:12:12 <ehird> Isn't this inferrable from `class (IsHTML a, IsHTML b) => Child a b`?
10:12:16 <ehird> (It says there's no instance for it.
10:12:19 <ehird> s/$/)/
10:13:43 <c_wraith> I ran into something strange yesterday.  a small program using a native library worked just fine on two out of three systems I tried it on, but didn't work at all on the third system.  All using os x 10.6, all set up just about the same.
10:14:45 <c_wraith> I guess we never did figure out whether it was the native lib that was broken on his system or not..  But for some reason, GHC produced an executable 4MB bigger on his system.
10:15:10 <joe1> fundamental parsec question: I have a big list of 0 & 1's (as [Int]) that I am trying to analyse. I thought of parsec, but now I am thinking that I do not need to bother with parsec as the data is already a haskell [Int]. I could just put some pattern matching functions together on the list of [Int]. Am I thinking wrong?
10:15:40 <jlouis> joe1: well, what is your analysis?
10:15:43 <c_wraith> Wait, we did rule out the native lib being broken.  the binary from my system worked on his.  the binary from his system didn't work on mine.
10:15:50 <ehird> 0 and 1?
10:15:53 <ehird> That's [Bool].
10:16:02 <ehird> joe1: But you are correct, probably.
10:16:08 <Paczesiowa> joe1: when you use parsec you usually have just a long list of characters and yet you still use parsec.
10:16:08 <ehird> Parsec is likely the wrong choice.
10:16:13 <ehird> ]
10:16:13 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
10:16:15 <ehird> oops
10:16:21 <benmachine> joe1: you can just put together some pattern matching functions to parse anything
10:16:21 <Saizan> ehird: i'm not even sure of what an instance (IsHTML (forall a. (Child HTML a) => a)) would actually mean
10:16:22 <joe1> yes, thinking about it, it is a [Bool]
10:16:29 <benmachine> joe1: parsec is basically some pattern matching functions put together :P
10:16:41 <Paczesiowa> joe1: parsec is abstraction of those pattern matches and shuffling remaining list
10:16:44 <benmachine> question is how complex does your parser need to be
10:16:46 <ehird> Saizan: neither am I... I'm having type issues
10:16:50 <Saizan> from Child HTML a you can derive IsHTML a though, yes
10:16:58 <joe1> jlouis: i want to read it into some messages as a pattern of 15 0's and 15 1's is "x"
10:17:07 <ehird> data HTML = HTML (Element HEAD) (Element (Child HTML a => a)) -- is unfortunately not workable due to rigid type variable blahs
10:17:16 <ehird> (given `data Element a = IsHTML a => Element a`)
10:17:51 <Saizan> ehird: you want data HTML = forall a. Child HTML a => HTML (Element HEAD) (Element a), i think
10:18:51 <ehird> Saizan: oh, I think you're right
10:18:58 <Traveler3> i have a question about real world haskell book. i'm very very newbie to haskell so please answer from this point of view :-)
10:19:01 <aavogt> data HTML where Child HTML a => ... ??
10:19:04 <ehird> Saizan: I am *so* autogenerating this once I know it works
10:19:13 <ehird> aavogt: is that valid?
10:19:16 <ehird> I don't think it is.
10:19:50 <ehird> yay, now "HTML (Element HEAD) (Element BODY)" works, and "HTML (Element HEAD) (Element HEAD)" doesn't type
10:20:00 * hackagebot upload: derive 2.2.0 - A program and library to derive instances for data types (NeilMitchell)
10:20:04 <Paczesiowa> ehird: could you paste something more?
10:20:10 <ehird> "No instance for (Child HTML HEAD)" — pretty good error, actually
10:20:16 <ehird> Paczesiowa: It's working now, or do you mean to take a look at?
10:20:39 <Paczesiowa> ehird: well, if it's working then nevermind:)
10:20:44 <Traveler3> i got to the end of chapter 3 and answerd the almost 7 exercises , but the rest i don't understand. will it be difficult to continue to chapter 4 without answering those questions?
10:20:44 <ehird> :)
10:21:04 <Paczesiowa> ehird: that's not a nice error
10:21:19 <ehird> Paczesiowa: Good enough for me
10:21:30 <ehird> Admittedly for the HTML case it's confusing because you do have a head
10:21:34 <ehird> But that's just because HTML is "special"
10:21:39 <Paczesiowa> "HTML (Element HEAD) (Element HEAD)" gives "No instance for (Child HTML HEAD)" ?
10:21:39 <ehird> (only two children, one is always head)
10:21:44 <ehird> Paczesiowa: Indeed.
10:21:52 <ehird> It's invalid HTML, so it's a type error.
10:22:07 <Paczesiowa> ehird: type errors are easy
10:22:14 <Paczesiowa> ehird: pretty type errors are hard
10:22:23 <ehird> So what, it tells me the info I need to know
10:22:26 <ehird> It's not an end-user thing
10:22:34 <ehird> If it was, I' dextract HTML and HEAD and munge it into something like
10:22:37 <ehird> *I'd extract
10:22:49 <Paczesiowa> ehird: make that "No instance for YouCannotPutTwoThingsInto Head HTML"
10:22:52 <ehird> "You have HEAD as a child of HTML, but this is not valid in context."
10:22:58 <ehird> Paczesiowa: No :P
10:23:10 <ehird> The important thing is that it balks, and gives you a file location, when the HTML is invalid.
10:23:18 <ehird> Everything else is optional.
10:23:49 <Paczesiowa> ehird: wait until you have bigger code, and that error floats upwards
10:24:05 <ehird> Paczesiowa: Patches welcome
10:24:08 <joe1> benmachine: but parsec seems way too complicated to get a grasp of (atleast now). Can I put it in a bunch of functions now and progress to parsec, in a phased manner..
10:24:16 <ehird> joe1: Yes.
10:24:21 <ehird> Parsec is really easy, though.
10:24:25 <ehird> It looks just like a syntax definition.
10:25:01 * hackagebot upload: storable-complex 0.2.1 - Storable instance for Complex (JedBrown)
10:25:25 <joe1> I read RWH but I got scared after I ":t parse"
10:25:31 <Paczesiowa> ehird: if you're interested in pretty errors, there's a nice trick with default instance and IncoherentInstances
10:25:37 <ehird> joe1: don't worry
10:25:38 <joe1> :t parse
10:25:39 <lambdabot> Not in scope: `parse'
10:25:40 <ehird> you don't have to understand that
10:25:47 <ehird> Paczesiowa: Oh?
10:26:45 <joe1> > parse
10:26:46 <lambdabot>   Not in scope: `parse'
10:26:50 <joe1> > :t parse
10:26:51 <lambdabot>   <no location info>: parse error on input `:'
10:26:58 <joe1> > t parse
10:26:59 <lambdabot>   Not in scope: `parse'
10:27:03 <Paczesiowa> :t parse
10:27:04 <lambdabot> Not in scope: `parse'
10:27:06 <quokka70> :t pl \x y -> x y
10:27:07 <lambdabot> parse error on input `\'
10:27:07 <ehird> T PARSE
10:27:12 <ehird> joe1: it's not in scope.
10:27:14 <quokka70> > :t pl \x y -> x y
10:27:15 <lambdabot>   <no location info>: parse error on input `:'
10:27:19 <ehird> anyway, don't worry about it
10:27:21 <quokka70> > pl \x y -> x y
10:27:22 <lambdabot>   <no location info>: parse error on input `\'
10:27:24 <ehird> the type sig of parse is not relevant to using parsec
10:27:27 <ehird> it's easy, trust me
10:27:28 <aavogt> ehird: I meant something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15904#a15904
10:28:06 <aavogt> but there probably is a difference by putting the Class constraint on the outside
10:28:27 <ehird> how does that beat «data HTML = forall a. Child HTML a => HTML (Element HEAD) (Element a)»?
10:28:32 <aavogt> rather than having some sort of Rank2 polymorphism going on in the constructor
10:28:40 <aavogt> it doesn't beat it at all
10:28:43 <ehird> alright :)
10:28:44 <aavogt> it's exactly the same
10:28:48 <ehird> Okay, now I have to think how to do attributes.
10:28:53 <ehird> Type-safe attributes, naturally...
10:28:55 <Paczesiowa> why some packages don't have docs on hackage (and no build failure)?
10:29:28 <aavogt> Paczesiowa: docs aren't generated right away... perhaps they will be created soon?
10:30:23 <Paczesiowa> aavogt: 3 days is not enough?
10:30:35 <ehird> Haha, man, attribute are going to be difficult.
10:31:03 * hackagebot upload: carray 0.1.5 - A C-compatible array library. (JedBrown)
10:32:20 <aavogt> Paczesiowa: 3 days should have been enough...
10:33:33 <jfischoff> is there a template haskell, or other magical way to perform type class forwarding?
10:34:00 <aavogt> specify type class forwarding, jfischoff
10:34:15 <jfischoff> say I have data Pair = Pair SomeInstanceOfATypeClass Double
10:34:40 <jfischoff> and I want Pair to be an instance and delegate the functions to the data member
10:35:06 <cwraith> there *is* template haskell.  It's even called template haskell.  But if you can solve the problem another way, it's probably worth it.  TH destroys compile times.
10:35:07 <jfischoff> sort of like newtype deriving
10:35:15 <jfischoff> ah
10:35:23 <ehird> Also, TH is really complicated to use.
10:35:30 <ehird> Turns out Haskell's AST isn't such a nice data structure.
10:35:38 <jfischoff> TH is way better the c++ way though
10:35:50 <watermind> ehird: AST?
10:35:53 <aavogt> so you want to automatically  fmap all methods of B through a type like  (B b => (a,b))
10:36:03 <kmc> AST = abstract syntax tree
10:36:04 <ehird> watermind: Abstract Syntax Tree.
10:36:08 <watermind> ah thanks
10:36:11 <kmc> it helps that Haskell is a good language for manipulating ASTs of any sort
10:36:18 <ehird> Macros are most popular in Lisp and Scheme for a reason. :)
10:36:25 <jfischoff> aavogt: yeah and have Pair become an instance too
10:36:57 <jfischoff> I haven't used the TH yet, but looking at it last night, my first take away was that it is awesome
10:37:33 <aavogt> so there are two separate cases,    f :: B b => ... -> b -> b, g :: ... b -> somethingElse
10:37:43 <aavogt> possibly a third:    .... -> b
10:38:07 <aavogt> in which case you can't forward the class without additional constraints on the other member
10:38:34 <ehird> jfischoff: tried to write a TH macro yet?
10:38:41 <ehird> I tried that once, and died of horror
10:38:45 <jfischoff> ehird: not yet...soon
10:38:52 <aavogt> it's quite amazing though
10:39:05 * hackagebot upload: fft 0.1.6 - Bindings to the FFTW library. (JedBrown)
10:39:28 <jfischoff> aavogt: don't entirely follow... what is happening with the cases...sort of a newb
10:39:32 <aavogt> but not so much when you start running into the limitations of the antiquoting, and end up manipulating the AST manually
10:39:56 <jfischoff> I was impressed that it had both
10:40:13 <aavogt> jfischoff: for types like the g one, you basically discard your other values
10:40:27 <aavogt> so you are eliminating some   snd   function
10:40:39 <jfischoff> ok...
10:40:41 <aavogt> in the first case you are eliminating some function like fmap
10:40:50 <jfischoff> ah
10:40:55 <aavogt> and in the last case you are creating something out of nowhere
10:41:07 <aavogt> creating your additional context
10:41:13 <jfischoff> yeah
10:41:43 <jfischoff> so your saying that it can't be done without something like TH?
10:41:51 <aavogt> jfischoff: but while this is an interesting problem to solve, maybe there are easier ways to address it than TH?
10:42:26 <jfischoff> aavogt: like not worry about it directly and modifying the design?
10:42:29 <aavogt> I can't think of how to do it without TH, but even then it's difficult since you have to automate figuring out those types
10:42:58 <aavogt> yeah, or just write the two or three lifing functions yourself... it might not be too much more noisy
10:43:11 <McManiaC> Berengal: its working \o/
10:43:24 <Berengal> McManiaC: Awesome
10:43:25 <jfischoff> aavogt: yep, no doubt, that I would ask though. Thanks for the help.
10:43:30 * Berengal is still darcs getting cabal
10:50:32 <Fuco> Is there any build-in way to change k-th item in list?
10:51:11 <c_wraith> :t (\\)
10:51:12 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:51:17 <kmc> by "change" do you mean return a new list which is the same except at that location?
10:51:24 <c_wraith> err, that's not it.
10:51:29 <c_wraith> I thought there was, though.
10:51:33 <mental> i don't think there is
10:51:45 <Fuco> kmc: probably
10:51:49 <c_wraith> I must have been thinking of arrays
10:52:03 <paolino> :t breakAt
10:52:05 <lambdabot> Not in scope: `breakAt'
10:52:13 <paolino> :t splitAt
10:52:14 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:52:15 <kmc> Fuco, i don't know of one.  you might want to use Data.Sequence instead of a list
10:52:17 <mental> Fuco: is it possible you need an array instead, if you need to change k-th item?
10:52:19 <kmc> or possibly an array
10:52:28 <Fuco> hmm, there are arrays? ;)
10:52:42 <Fuco> OK, I'll probably use one
10:52:46 <jlouis> Fuco: try going with Data.Sequence. It is pretty nice
10:52:57 <Fuco> ok, thanks
10:53:12 <Berengal> Arrays are just fine if you don't need to do lots of updating, and your size is fixed
10:53:24 <Berengal> Or possibly, if you can update the entire array at once
10:53:46 <Berengal> (e.g. in game of life)
10:53:50 <jlouis> Fuco: one cool Haskell thing: We have a lot of options when choosing data structure. Often, one suits the problem extemely well
10:55:01 <joe1> is there a 'set -o vi' for ghci?
10:55:18 <Berengal> joe1: What's it supposed to do?
10:55:35 <joe1> i use the vi style in my shell prompt and hope that the ghci interactive editing would behave like that.
10:55:49 <joe1> make the ghci interactive editing work in vi style
10:55:57 * Berengal shrugs
10:56:11 <Paczesiowa> joe1: ghci is based on haskelline
10:56:28 <Paczesiowa> joe1: I think it can be forced to use vi bindings
10:56:45 <kmc> joe1 http://trac.haskell.org/haskeline/
10:56:59 <joe1> thanks, guys.
10:57:02 <Paczesiowa> oh, just one 'l'
10:57:07 <aavogt> ghci doesn't let you declare as many things as other REPLs
10:58:45 <kmc> Fuco, there are actually lots of different types of arrays
10:59:00 <kmc> for different purposes
11:01:15 <paolino> random update of an array is not a frequent pattern
11:10:58 <_andy_> is mapping with a newtype constructor an O(n) operation, or does it even occur?
11:11:04 <_andy_> i.e.
11:11:08 <_andy_> map All
11:11:40 <ben0x539> newtypes supposedly get optimised away by ghc
11:11:51 <ben0x539> I think it is also smart enough to remove maps
11:11:52 <aavogt> _andy_: if you do another list traversal, it might get fused into another loop
11:12:01 <_andy_> ok
11:12:07 <Paczesiowa> _andy_: check ghc-core
11:14:35 <_andy_> it appears "cabal install ghc-core" is not successful
11:15:05 <_andy_> though that probably isn't any help to anybody
11:15:17 <_andy_> (the statement)
11:23:43 <Berengal> Reinstalling ghc didn't fix my problem...
11:23:52 <Berengal> And I still don't know what the problem is rightly
11:23:57 <_andy_> ok after fixing that, other issues as well
11:24:07 <_andy_> the first issue was that it could not find C.ExitException
11:24:13 <_andy_> neither could I..
11:24:17 <Berengal> Anyone with ghc 6.12 tried installing happstack-data?
11:24:55 <b_jonas_> _andy_: try importing Control.OldException instead of Control.Exception
11:25:03 <_andy_> ok
11:25:58 <_andy_> that did it
11:25:59 <_andy_> thanks
11:30:31 <jfischoff> Another newb question: Any resources for wrapping my head around space leaks?
11:33:47 <kmc> there's a heap profiler
11:34:02 <Paczesiowa> is anyone familiar with hint and its thing for unqualifying modules?
11:34:43 * hackagebot upload: derive 2.3.0 - A program and library to derive instances for data types (NeilMitchell)
11:36:17 <luite> @src getStdGen
11:36:17 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:38:01 <_andy_> is the "constant" Infinity defined anywhere?
11:38:06 <_andy_> other than 1/0
11:38:19 <_andy_> :t 1/0
11:38:21 <lambdabot> forall t. (Fractional t) => t
11:38:55 <luite> _andy_: it's a special value for floating point types
11:39:02 <luite> > (1/0)::Double
11:39:04 <lambdabot>   Infinity
11:39:16 <_andy_> also, it appears (perhaps naively) that Bounded Double should exist
11:39:30 <_andy_> >minBound :: Double
11:39:39 <_andy_> > minBound :: Bouble
11:39:41 <lambdabot>   Not in scope: type constructor or class `Bouble'
11:39:43 <_andy_> > minBound :: Double
11:39:44 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
11:39:44 <lambdabot>    arising from a use o...
11:40:43 <_andy_> > -(1/0)
11:40:44 <lambdabot>   -Infinity
11:41:03 <Berengal> Is there a guide to reading core somewhere, or does everyone just pretend to know what's going on?
11:42:44 <_andy_> do you mean the output of ghc-core?
11:43:02 <Berengal> Well, yes
11:43:17 <_andy_> i could a guide as well
11:43:45 <Paczesiowa> Berengal: dons had a blog post about optimizing mean, there was something about core
11:44:09 <Berengal> It's not terribly hard to guess what's going on, but between all the genrated identifiers and weird annotations it's not hard to become lost either
11:45:10 <Paczesiowa> Berengal: those identifiers are the worst thing, it should be possible to use something smarter
11:45:28 <_andy_> @src Foldable [a]
11:45:29 <lambdabot> Source not found. Maybe you made a typo?
11:46:06 <Paczesiowa> Berengal: I once was looking at bytestring core, and there are types with 3 integers inside, and you have to write down which one is which
11:46:16 <Berengal> Paczesiowa: Identifiers you can always brute-force in your brain, but the semantics of the language and some of the syntax needs to be learned
11:46:25 <Paczesiowa> Berengal: then after fix&recompile you have to write them down again
11:47:32 <Berengal> I'm a bit sad to see that mapping newtype wrapping/unwrapping over a list still performs the traversal
11:48:04 <Paczesiowa> Berengal: so does mapping id
11:48:13 <kmc> it has to force the spine of the list
11:48:17 <kmc> according to the semantics of 'map'
11:48:27 <Paczesiowa> Berengal: so it's not about newtypes
11:48:40 <Berengal> kmc: 'map' is neither more nor less defined than the spine already is
11:48:59 <Berengal> Paczesiowa: Well then, it still has to do the id
11:49:35 <kmc> Berengal, true, because the forcing happens when you force cons cells that come out of map.  fair enough
11:49:42 <kmc> i think you can safely unsafeCoerce a list of A to a list of B if A is a newtype of B
11:49:45 <kmc> i'm not positive
11:49:55 <Paczesiowa> Berengal: id is probably gotten rid of by the simplifier
11:50:04 <c_wraith> That sounds like one of the safe cases for unsafeCoerce
11:50:10 <kmc> i don't think it's covered in the (very narrow) guarantees on unsafeCoerce
11:50:31 <joe1> let match (x:xs) | (x < 10) && (x > 0) = "do something on x" : match xs
11:50:34 <joe1> let match [] = [""]
11:50:39 <joe1>  match [1,2,12]
11:50:42 <Berengal> Paczesiowa: Indeed, it is
11:50:46 <_andy_> so assuming Monoid (Max a) and Monoid (Min a) and class Bounds a where bounds :: Foldable f => f a -> (a, a)
11:50:49 <joe1> let match (x:xs) | (x < 10) && (x > 0) = "do something on x" : match xs
11:50:54 <joe1> let match [] = [""]
11:50:54 <Berengal> Paczesiowa: And unFoo . Foo is simplified to id as well
11:50:55 <joe1> > let match [] = [""]
11:50:56 <lambdabot>   not an expression: `let match [] = [""]'
11:51:02 <joe1> > match [1,2,12]
11:51:03 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
11:51:03 <lambdabot>                    ...
11:51:08 <_andy_> will instance Bounds Double where bounds = (,) <$> getMin . foldMap Min <*> getMax . foldMap Max
11:51:13 <_andy_> perform two traversals?
11:51:15 <ddarius> I'm not aware of any guarantees for unsafeCoerce.
11:51:33 <joe1> how can I define a function with multiple matches on ghci prompt?
11:51:40 <_andy_> :{
11:51:41 <Berengal> kmc: I consider unsafeCoerce to only have the basic guarantees of the OS
11:51:42 <_andy_> :}
11:51:52 <joe1> let match (x:xs) | (x < 10) && (x > 0) = "do something on x" : match xs ; let match [] = []
11:51:55 <kmc> Berengal, which are those?
11:52:00 <joe1> > let match (x:xs) | (x < 10) && (x > 0) = "do something on x" : match xs ; let match [] = []
11:52:00 <kmc> joe1, put them in the same let block
11:52:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:52:08 <Berengal> kmc: It'll segfault if it tries to read outside mapped memory
11:52:08 <joe1> kmc: thanks.
11:52:17 <kmc> > let match (x:xs) | (x < 10) && (x > 0) = "do something on x" : match xs ; match [] = [] in match [1,2,12]
11:52:19 <lambdabot>   ["do something on x","do something on x"* Exception: <interactive>:1:165-24...
11:52:59 <kmc> Berengal, you have no way of applying that rule without knowing the in-memory representation of heap values
11:53:05 <Berengal> kmc: Also, it won't delete your files (unless you run as a user with permission to do so)
11:53:49 <Berengal> ((Or it somehow manages to setuid to root))
11:53:54 <ddarius> Well, I guess, between NHC and GHC, they both suggest that unsafeCoercing between newtypes is safe.
11:53:55 <kmc> the rules i refer to (for ghc) are: http://haskell.org/ghc/docs/6.10-latest/html/libraries/ghc-prim/GHC-Prim.html#v%3AunsafeCoerce%23
11:54:08 <joe1> kmc: I am also getting the same error as reported by lambdabot.
11:54:20 <kmc> joe1, the exception?
11:54:29 <kmc> that's because your match function has non-exhaustive patterns
11:54:35 <joe1> ["do something on x","do something on x"*** Exception: <interactive>:1:4-88: Non-exhaustive patterns in function match
11:54:45 <kmc> it has no case for, say, [12]
11:54:59 <joe1> kmc, oh, ok.. thanks.
11:55:20 <joe1> kmc: stupid mistake.. thanks..
11:55:23 <kmc> matches with non-exhaustive patterns create partial functions
11:55:26 <kmc> (and thus are evil)
11:55:59 <ddarius> joe1: GHC will warn you about non-exhaustive patterns with the right flags (which may be set by default).
11:56:03 * Berengal has only used unsafeCoerce to write a polymorphic snd function
11:56:05 <kmc> -Wall is enough
11:56:28 <kmc> the uncontroversial uses of unsafeCoerce are Any and newtypes
11:56:35 <kmc> and phantom types i suppose
11:56:48 <jmcarthur> it won't warn you about bad uses of partial library functions though, like head or tail
11:56:55 <kmc> any use is a bad use
11:57:03 <ddarius> The documentation for unsafeCoerce with regards to NHC doesn't say anything about phantom types, but those are probably safe.
11:57:20 <jmcarthur> i disagree. the proof burden is just on the programmer
11:57:31 <ddarius> jmcarthur: Catch will.
11:58:05 <jmcarthur> ddarius: does catch ever report false negative or false positives?
11:58:10 <Berengal> The way I read the documentation, the only really safe use is casting phantom types and as a primitive for cast
11:58:42 <kmc> and for Dynamic
11:58:49 <ddarius> jmcarthur: I think it says it doesn't know when it doesn't know, so no, but I could be wrong about that.
11:58:51 <kmc> and other uses for Any
11:58:52 <Berengal> cast is in Dynamic, isn't it?
11:58:57 <kmc> no
11:58:57 <Paczesiowa> why unsafeCoerce to Any and back is supposed to be safe?
11:59:05 <Berengal> Paczesiowa: The docs say so
11:59:14 <kmc> Paczesiowa, because Any represents a boxed value about which no more assumptions may be made
11:59:15 <ddarius> Paczesiowa: That's pretty much what Any was added for.
11:59:25 <jmcarthur> ddarius: it's based on YHC, right?
11:59:33 <ddarius> jmcarthur: Sort of.
11:59:40 <kmc> whereas, e.g. unsafeCoerce to () and back is not safe, because a closure for () looks different from a function closure in some important ways
11:59:57 <jmcarthur> just wondering how likely it is to support my favorite language extensions
12:00:11 <jmcarthur> i've not given catch a fair shot yet
12:00:15 <Paczesiowa> so if I cast () to Any and then to Either String String and print it will work how?
12:00:33 <kmc> no
12:00:44 <kmc> cast T to Any and *back to T* is safe
12:00:44 <ddarius> jmcarthur: My impression is that YHC is being made into a side path in the GHC pipeline and that there is or will be GHC Core to YHC Core and back transformations.
12:00:48 <Berengal> Paczesiowa: No, it's safe to cast something to Any, and it's safe to cast some Any back to what it was before
12:00:50 <kmc> not to a different type
12:00:54 <ddarius> Catch operates over YHC Core if I remember correctly.
12:00:58 <jmcarthur> ddarius: ooh
12:01:32 <drhodes> anyone have a point free english sentence?
12:01:43 <Paczesiowa> oh, that kind of "safe"
12:01:44 <Berengal> Paczesiowa: And by safe we mean memory-safe, not type-safe, obviously
12:02:22 <kmc> not sure what definition of "type-safe" you mean but i think an unsafeCoerce from T to Any and back to T should be type-safe
12:02:34 <kmc> it's just that the condition can't be checked at compile time
12:02:42 <Paczesiowa> and casting phantom types could break things
12:02:57 <Berengal> kmc: And since types only exist at compile time, we need to check them then, or it won't be type-safe...
12:02:59 * hackagebot upload: hakyll 1.0.1 - A simple static site generator library. (JasperVanDerJeugt)
12:02:59 <kmc> Data.Typeable.cast and Data.Dynamic use the Typeable class to save a type representation and do the check at runtime
12:03:29 <kmc> if we trust Typeable instances to be faithful, we can defer the check to runtime
12:04:02 <Berengal> Yes, but we need the extra runtime typechecking mechanizm to regain type safety
12:04:03 <Paczesiowa> I don't!
12:04:11 <_andy_> btw I think this is one traversal:
12:04:12 <_andy_>   bounds = ((,) <$> getMin . fst <*> getMax . snd) . foldMap ((,) <$> Min <*> Max)
12:04:51 <Beelsebob> _andy_: you may want to look at the first and second functions
12:04:52 <kmc> basically, you should never ever write your own Typeable instance
12:04:57 <_andy_> ah
12:05:00 <_andy_> :t first
12:05:01 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
12:05:10 <_andy_> :t second
12:05:12 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
12:05:15 * ddarius has written Typeable instances.
12:05:21 <Beelsebob> (notably for the (->) Arrow)
12:05:25 <kmc> ddarius, to what end?
12:05:27 * Beelsebob has written Typeable instances too
12:05:49 <kmc> if you write a Typeable instance you have a similar proof burden as if you use unsafeCoerce
12:06:04 <ddarius> kmc: The recent case, I didn't want to use StandAloneDeriving.  The not recent cases, um, there was no deriving Typeable or anything else...
12:06:22 <kmc> why not use StandAloneDeriving?
12:06:53 <ddarius> Because it is a relatively new extension supported only by GHC.
12:08:00 * hackagebot upload: vacuum-opengl 0.0.3 - Visualize live Haskell data structures using vacuum, graphviz and OpenGL. (BalazsKomuves)
12:08:14 <sshc> how does GHC interpret this line? #!/usr/bin/env runhaskell
12:08:34 <ddarius> It doesn't.
12:08:36 <xerox> possibly it ignores it?
12:08:57 <xerox> ?docs
12:08:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:08:58 <jaspervd1> it should ignore it
12:09:07 <xerox> raise up one level on that url and check
12:09:33 <sshc> I didn't know # started comments
12:09:39 <ddarius> It doesn't.
12:09:49 <sshc> ddarius: how does it ignore it?
12:10:00 <Paczesiowa> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15907 - coercing only phantom types still crashes
12:10:16 <ddarius> sshc: Usually one does that trick with literate Haskell files.
12:10:20 <Ke> well you can easily spec program to ignore shebang
12:10:39 <sshc> ddarius: oh, so it's not valid Haskell code?
12:10:45 <sshc> ddarius: which will result in an error?
12:10:46 <merehap> octothorp, you mean :)
12:10:47 <Paczesiowa> sshc: it's a special case that only works on the first lien
12:10:54 <jaspervd1> It only works if it's the first line iirc
12:11:03 <sshc> Paczesiowa: if it starts with #?
12:11:06 <sshc> or #!?
12:11:15 <jaspervd1> #!
12:11:17 <lunabot>  luna: parse error on input `]'
12:11:25 <sshc> #!Int
12:11:26 <lunabot>  luna: parse error on input `]'
12:11:34 <Paczesiowa> sshc: shebang only
12:11:36 <aavogt> ##!/bin/sh
12:11:37 <lunabot>  luna: parse error on input `]'
12:14:01 <kmc> it's a GHC special case
12:14:06 <kmc> not part of the syntax of Haskell, iirc
12:14:09 <_andy_> Beelsebob: thanks for the advice, ended up with this:   bounds = foldMap (Min &&& Max) >>> getMin *** getMax
12:14:26 <ddarius> kmc: Can you find where it is documented?
12:14:37 <kmc> not sure, but i know i've seen it
12:16:12 <nomadmonad> what is the best way to utilize existing libraries for graph search algorithm development
12:16:54 <nomadmonad> basically I'd like to develop breadth-first or special A*-search, but the Graph.hs says type Vertex = Int
12:17:20 <nomadmonad> so can I extend it from there? Attach more information to the vertices visited?
12:17:51 <c_wraith> I think the general recommendation is to use an IntMap from Vertex to additional properties
12:17:54 <nomadmonad> or should I make my own datastructure and index that with the vertex (int)?
12:17:57 <c_wraith> But I'm not sure of that
12:17:59 <ddarius> nomadmonad: There are other graph libraries, but for that one, the intent is that you do what c_wraith said.
12:19:10 <c_wraith> part of the reason for that design, as I understand it, is to make sharing visible.  ie, you know they're the same node, not just nodes with the same properties
12:20:08 <nomadmonad> ddarius: would you recommend some graph library over others? Edison, Graphalyze, fgl, or some other hackage package?
12:22:30 <Cale> nomadmonad: I implemented a generic A* search which you can find on Hackage
12:22:46 <Cale> nomadmonad: The way I went about it was to treat the search algorithm as a higher order function
12:22:53 <aavogt> kmc: I believe other haskell implementations do such too
12:22:57 <Cale> So that it would be largely independent of the graph representation
12:23:09 <aavogt> hugs respects  a  #!/usr/bin/runhugs
12:23:12 <kmc> one disadvantage of this representation is that you can have at most 18446744073709551616 nodes in your graph
12:23:41 <maltem_> nomadmonad, is that nomad-monad or no-mad-monad?
12:23:44 <Cale> That is an actual disadvantage in some cases.
12:24:25 <Cale> It can be much more natural to represent some graphs as infinite, via something like a function from a vertex to its set of neighbours.
12:25:18 <ddarius> nomadmonad: I would recommend doing something similar to what Cale did and abstract away, to some extent, from the particular graph library.
12:25:44 <Cale> aStar :: (Ord a, Ord c, Num c) => (a -> Set a) -> (a -> a -> c) -> (a -> c) -> (a -> Bool) -> a -> Maybe [a] -- here's the type signature I ended up with
12:25:58 <ddarius> nomadmonad: However, if you haven't actually looked at the papers and such around FGL, I would recommend looking at them as they provide a new perspective.
12:26:31 <ddarius> Well, you could collect the arguments into a record such as GraphInterface.
12:26:36 <sproingie> egad i just started typing "sum $ map " in perl before catching myself
12:26:46 <kmc> you could even put them in a typeclass
12:26:59 <ddarius> sproingie: Use Pugs.  I believe there's a way to drop into Haskell from it.
12:27:10 <Cale> The first parameter is a function from a vertex to its neighbours, the second is the distance between neighbouring vertices, the third is the heuristic distance to the nearest goal, the fourth is a predicate to decide if the given vertex belongs to the goal
12:27:23 <Cale> and the last is the starting vertex
12:28:00 <sproingie> ahahahahahahahahano
12:28:07 <_andy_> @src Ord (a, b)
12:28:07 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:28:16 <kmc> @src (<=) (a, b)
12:28:16 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:28:24 <kmc> @src (<=) (,)
12:28:24 <lambdabot> Source not found. You type like i drive.
12:28:28 <kmc> @src (,) (<=)
12:28:29 <lambdabot> Source not found. My brain just exploded
12:28:34 <kmc> @src (,) compare
12:28:35 <lambdabot> Source not found. Take a stress pill and think things over.
12:28:38 <kmc> @src compare (,)
12:28:39 <lambdabot> Source not found. My brain just exploded
12:28:40 <sproingie> i should break my habit of whipping up one-offs in perl but this was a wrapper for an executable, so i would have otherwise written it in sh
12:28:41 <kmc> screw it
12:28:42 <_andy_> hmm..
12:28:52 <Cale> _andy_: instance (Ord a, Ord b) => Ord (a,b) where compare (x,y) (x',y') = compare x x' `mappend` compare y y'
12:28:59 <ddarius> kmc: It's the lexicographical instance.
12:29:03 <Polarina> How do I convert a Num to a String?
12:29:04 <_andy_> ok
12:29:07 <kmc> Polarina, show
12:29:09 <kmc> > show 12.34
12:29:11 <lambdabot>   "12.34"
12:29:11 <Polarina> kmc: Thanks.
12:29:13 <kmc> Num isn't a type though
12:29:17 <kmc> you mean some instance of Num?
12:29:25 <ddarius> @src Num
12:29:25 <lambdabot> class  (Eq a, Show a) => Num a  where
12:29:25 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:29:25 <lambdabot>     negate, abs, signum     :: a -> a
12:29:25 <lambdabot>     fromInteger             :: Integer -> a
12:29:30 <sproingie> need to learn how to use System.Console.GetOpt
12:29:41 <Cale> > sort [(1,1),(2,1),(1,2),(2,2),(1,3),(3,1)]
12:29:41 <kmc> every type in Num is in Show, though it's not clear why this constraint is desirable
12:29:43 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(3,1)]
12:29:47 <ddarius> sproingie: It's pretty straightforward.
12:29:55 <ddarius> kmc: It isn't...
12:30:12 <sproingie> zOMG it has an example!
12:30:20 <Polarina> How do I convert a String to an Integer?
12:30:26 <Cale> Polarina: read
12:30:27 <benmachine> kmc: if you think of the Num class as being the class of integer literals, it might make more sense
12:30:29 <Polarina> Cale: Thanks.
12:30:33 <benmachine> in a vague not-really kind of way
12:30:39 <Cale> > read "4382791" :: Integer
12:30:39 <kmc> yeah
12:30:40 <lambdabot>   4382791
12:30:45 <kmc> would make more sense to require Read than Show
12:30:47 <benmachine> at least, that's why I assume there is an Eq constraint, for pattern-matching
12:30:47 <Cale> > read "[1,2,3]" :: [Integer]
12:30:48 <lambdabot>   [1,2,3]
12:31:20 <Cale> Yes, the Eq constraint is there for n-patterns
12:31:24 <kmc> Polarina, "read" can fail.  if you need to catch failures, use "reads"
12:31:31 <kmc> > reads "3" :: [(Integer, String)]
12:31:32 <lambdabot>   [(3,"")]
12:31:46 <kmc> list of possible parses, of the form: (parsed value, remaining string)
12:31:47 <Cale> > reads "43abc" :: [(Integer, String)]
12:31:48 <lambdabot>   [(43,"abc")]
12:33:03 <nomadmonad> Cale, which one is your aStar lib?
12:33:06 <Polarina> How does reads work?
12:33:12 <kmc> > map (fmap fst . listToMaybe . reads) ["123", "foo", "45bar"]
12:33:13 <Cale> nomadmonad: astar
12:33:13 <lambdabot>   [Nothing,Nothing,Nothing]
12:33:24 <kmc> > map (fmap fst . listToMaybe . reads) ["123", "foo", "45bar"] :: [Maybe Int]
12:33:25 <lambdabot>   [Just 123,Nothing,Just 45]
12:33:29 <kmc> Polarina, what do you mean?
12:33:38 <nomadmonad> the signature seems a nice start, and perhaps a record is better like ddarius said
12:33:43 <kmc> the details of how you parse a type depends on the type
12:34:04 <kmc> "reads" is implemented differently for each type; that's why it's in a typeclass
12:34:16 <Polarina> kmc: How does reads work? What does it do?
12:34:26 <nomadmonad> maltem_: it is prolly more of a nomad, than nom ad mo nad
12:34:28 <ddarius> It's a parser.
12:34:37 <kmc> Polarina, it takes a String and attempts to parse it as a Haskell value.  it returns a list of possible parsers; each one is a pair of (parsed value, remaining string)
12:34:51 <kmc> > reads "123abc" :: [(Int, String)]
12:34:53 <lambdabot>   [(123,"abc")]
12:34:53 <Polarina> kmc: I am not following you.
12:35:04 <Cale> nomadmonad: Note: I basically translated the imperative code on Wikipedia directly into Haskell code, and did a minimal amount of testing, and no profiling. However, I sensibly used a priority search queue in the implementation which is at least supposed to be asymptotically fast. It seemed to perform okay for the reasonable examples that I ran it on.
12:35:05 <kmc> Polarina, which part is unclear?
12:35:08 <Polarina> > reads "qwerty" :: [(Int, String)]
12:35:09 <lambdabot>   []
12:35:18 <Polarina> kmc: How does it handle invalid input?
12:35:25 <kmc> Polarina, by returning an empty list, as you see there
12:35:27 <peti> Hi. Has anyone updated ArchLinux to ghc-6.12.1 successfully? I get some mad infinite recursion with haskell-cabal and I'm not sure how to resolve it.
12:35:33 <Polarina> kmc: Ah.
12:35:38 <kmc> it returns a list of possible parses.  if the input is invalid, there are no possible parses.
12:35:43 <sproingie> > reads "foo" :: Int
12:35:44 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:35:45 <lambdabot>         against inferred type ...
12:35:45 <nomadmonad> Cale, do you have any benchmarking or comparison
12:35:48 <Polarina> reads "1337" :: [String]
12:36:00 <kmc> > reads "1337" :: [(Int, String)]
12:36:01 <Polarina> > reads "1337" :: [String]
12:36:01 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:36:02 <lambdabot>         against inferred ty...
12:36:02 <lambdabot>   [(1337,"")]
12:36:14 <kmc> > map fst $ reads "1337" :: [Int]
12:36:15 <lambdabot>   [1337]
12:36:20 <sproingie> ah i'm thinking of read
12:36:29 <Cale> nomadmonad: That's what I was just trying to express that I don't have ;)
12:36:31 <kmc> err i said "possible parsers" above and meant "possible parses"
12:36:32 <kmc> my bad
12:36:34 <sproingie> reads is way superior
12:36:46 <kmc> reads is ugly to use
12:36:49 <sproingie> > read "foo" :: Int
12:36:51 <lambdabot>   * Exception: Prelude.read: no parse
12:36:53 <nomadmonad> Cale, well it might be nice exercise for me, to get to use it and see how fast it goes
12:36:55 <Cale> nomadmonad: I have no idea if my aStar performs well, or even if there might be a bug or two in it, though it seems to work fine.
12:36:57 <sproingie> reads is safe tho
12:37:01 <kmc> if you are building complicated read expressions, it's better to use a real parser library
12:37:08 <Polarina> > reads "1337" :: [Int]
12:37:09 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:37:10 <lambdabot>         against inferred type ...
12:37:17 <Polarina> Why doesn't that work?
12:37:24 <kmc> Polarina, because it returns a list of pairs
12:37:26 <sproingie> simple mnemonic: http://www.willamette.edu/~fruehr/haskell/seuss.html
12:37:28 <kmc> of (value parsed, remaining string)
12:37:32 <kmc> > reads "1337" :: [(Int, String)]
12:37:33 <lambdabot>   [(1337,"")]
12:37:35 <Polarina> kmc: Why a pair?
12:37:41 <kmc> because some string might be left over
12:37:42 <nomadmonad> well, this is an excellent starting point for me anyway. Some testing, some benchmarking, some learning how to write a lib, and how to use it.
12:37:42 <Cale> nomadmonad: I wrote it mostly as an exercise, I didn't have any application in mind when I wrote it.
12:37:46 <Polarina> ...
12:37:48 <kmc> and you might want to build compound parsers out of simpler ones
12:37:51 <Polarina> I don't understand this.
12:38:03 <kmc> try to write the "reads" for "instance (Read a) => Read [a]"
12:38:07 <sproingie> > reads "123 456" :: [(Int, String)]
12:38:08 <lambdabot>   [(123," 456")]
12:38:35 <Polarina> > reads "1337 587" :: [(Int, Int)]
12:38:36 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:38:36 <lambdabot>         against inferred type ...
12:38:41 <sproingie> doesn't work like that
12:38:43 <Polarina> This is uncomprehensable.
12:38:44 <nomadmonad> oh, it seems I have largely jumped over Data -section in hackage
12:38:47 <kmc> Polarina, you quite often respond with "..." or "I don't understand".  it would be more useful to describe what exactly you are missing
12:38:48 <sproingie> > reads "123 dfgsdrtsdfg" :: [(Int, String)]
12:38:50 <lambdabot>   [(123," dfgsdrtsdfg")]
12:38:53 <kmc> Polarina, do you understand what a parser does?
12:38:55 <Cale> > let sillyParse :: String -> [(Integer, Integer)]; sillyParse str = [(x,y) | (x,' ':str') <- reads str, (y,"") <- reads str'] in sillyParse "123 456"
12:38:55 <nomadmonad> and there seems to be few jewels in there
12:38:56 <lambdabot>   [(123,456)]
12:38:58 <sproingie> Polarina: the second thing it returns is just the leftover string
12:38:59 <Polarina> kmc: No...
12:39:10 <Polarina> sproingie: Oh.
12:39:10 <kmc> Polarina, it turns a string representation of some value into a value
12:39:32 <Polarina> But why return a list?
12:39:41 <kmc> Polarina, because there can be zero or more possible parses for something
12:39:42 <Cale> Polarina: In case of ambiguity
12:39:43 <kmc> Not for Int
12:39:51 <nomadmonad> how do people keep somewhat up to date what algorithms are published to hackage, and what is their quality of implementation, perhaps even use?
12:39:52 <Polarina> kmc: How can there be more?
12:39:55 <kmc> but more complicated values with syntactic structure could have ambiguity
12:39:58 <Polarina> Cale: Ambiguity?
12:40:06 <sproingie> anyone think of an easy example of an ambiguous parse?
12:40:06 <kmc> Polarina, suppase you are parsing the grammar of arithmetic expressions
12:40:25 <kmc> does "a + b + c" parse as "(a + b) + c" or "a + (b + c)"?
12:40:28 <sproingie> it's way easier to demonstrate it but no one-liners come to mind
12:40:33 <kmc> i feel like this isn't the best example
12:40:48 <ddarius> nomadmonad: They don't.
12:40:54 <c_wraith> kmc: switch it to a non-associate operator, like /
12:40:56 <Cale> Polarina: Yes, none of the Prelude instances make use of this as far as I know, but there are cases where you may want to write Read instances for more complicated structures that have languages with some intermediate ambiguity in them.
12:41:13 <kmc> Polarina, http://en.wikipedia.org/wiki/Context-free_grammar
12:41:22 <sproingie> oh like that's going to clear things up
12:41:28 <c_wraith> 8 / 4 / 2 is either (8 / 4) / 2 = 1 or 8 / (4 / 2) = 4
12:41:30 <nomadmonad> ddarius: is that a statement of the current way, or more of a statement how it should be?
12:41:30 <Polarina> Cale: Ok, thanks.
12:41:37 <sproingie> might as well throw the dragon book at her
12:41:45 <ddarius> nomadmonad: The former.
12:41:52 <Cale> nomadmonad: You can try to watch for hackagebot things here, and there's a Haskell Weekly News which comes out maybe once every couple months ;P
12:42:00 <kmc> if you want to understand how parsers can be ambiguous, you need to understand a little theory of what they do
12:42:09 <Cale> and of course, watching Haskell reddit and the mailing lists
12:42:14 <Polarina> kmc: Go ahead, please. :)
12:42:28 <kmc> Polarina, so for example the wikipedia link i just pasted
12:42:47 <Cale> Polarina: Do you know about regular expressions?
12:42:54 <sproingie> i'd start with http://en.wikipedia.org/wiki/Parsing
12:43:02 <Polarina> Cale: Yes.
12:43:15 <Cale> Okay, so consider the regular expression a*a
12:43:28 <sproingie> regular expressions without backrefs or other funky perlisms are parsers for regular grammars
12:43:30 <Cale> which matches zero or more a's followed by another a
12:43:36 <sproingie> (which is why they're called regular expressions)
12:43:59 <Cale> I'm just going to use this to demonstrate why ambiguity is useful.
12:44:23 <Cale> Suppose we want to match this against some string like "aaa"
12:45:02 <sproingie> huh.  my phone just spontaneously rebooted
12:45:09 <Cale> Now, given that we don't know anything about DFAs and all that, we might start simply by trying to match our initial a* against the string and continuing from there
12:45:48 <Cale> However, a* is capable of matching the entire string right away, and not leaving any characters for the a which follows to match.
12:46:01 <Polarina> Hmm...
12:47:10 <Cale> However, if the result of parsing the string with a* produced a list of possible remaining strings, then we could try each of them in turn
12:47:17 <Cale> and see if any of them succeeded
12:48:17 <Cale> (typically, they would be produced in an order which was greedy, so the first entry in the list would represent the case where the a* eats as many a's as possible, and subsequent entries would back off, eating fewer and fewer.
12:48:20 <Cale> )
12:48:25 <sm> nomadmonad: there's also http://hackage.haskell.org/packages/archive/recent.html and it's rss feed
12:52:13 <Cale> Or, if you're faced with a regular expression like (a|ab)(b|c), it's important that this be able to match the string "ab". If the first bracket matches the whole "ab" right off the bat, then the second bracket will fail. If it matches just the "a", then the second bracket succeeds and matches the "b"
12:54:29 <Polarina> Cale: Ah, cool. Thanks. :)
12:55:10 <sioraiocht> if a parametrically polymorphic function has free theorems due to naturality
12:55:22 <sioraiocht> how does this affect existential types
12:55:37 <aledge> sioraiocht, is that a zen question?
12:55:44 <sioraiocht> stream fusion, for example, is "forall s. Stream (s -> Step s a) s"
12:55:54 <sioraiocht> is there are any free theorems associated with Streams?
12:55:58 <sioraiocht> *re there
13:02:05 <Cale> Polarina: Of course, if you're actually implementing just regular expressions, there's a *far* more efficient way to do it, but this should give the idea for general parsing.
13:02:17 <_andy_> @hoogle a b (c, c) -> a c d -> a b (d, d)
13:02:17 <lambdabot> No results found
13:02:41 <_andy_> :t on
13:02:42 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:02:49 <_andy_> :t curry
13:02:50 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:05:07 <xerox> :t lasagna
13:05:17 <lambdabot> forall a b c d e f g h. ((a, b, c, d, e, f, g) -> h) -> a -> b -> c -> d -> e -> f -> g -> h
13:06:52 <aavogt> :t curry curry curry
13:07:06 <lambdabot>     Couldn't match expected type `(a, b)'
13:07:08 <lambdabot>            against inferred type `(a1, b1) -> c'
13:07:10 <lambdabot>     In the first argument of `curry', namely `curry'
13:07:18 <xerox> Coudln't match lasagna... =)
13:07:22 <aavogt> :t curry . curry . curry
13:07:23 <lambdabot> forall a b b1 b2 c. ((((a, b), b1), b2) -> c) -> a -> b -> b1 -> b2 -> c
13:07:24 <Polarina> lambdabot: lol @ lasagna
13:07:37 <_andy_> @hoogle (a -> b) -> (a, a) -> (b, b)
13:07:37 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:07:38 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
13:07:38 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
13:07:41 <aavogt> :t curry lasagna
13:07:42 <lambdabot>     Couldn't match expected type `(a, b)'
13:07:42 <lambdabot>            against inferred type `(a1, b1, c, d, e, f, g) -> h'
13:07:42 <lambdabot>     In the first argument of `curry', namely `lasagna'
13:08:05 <_andy_> -- @let lasagna = "delicious"
13:08:38 <xerox> ?type join (***) :: (a->b) -> (a,a)->(b,b)
13:08:39 <lambdabot> forall a b. (a -> b) -> (a, a) -> (b, b)
13:09:01 <_andy_> @let test = undefined
13:09:02 <lambdabot>  Defined.
13:09:18 <_andy_> @let map2 f = ((,) `on` f) <$> fst <*> snd
13:09:19 <lambdabot>  Defined.
13:10:22 <benmachine> :t map2
13:10:24 <lambdabot> forall b1 b. (b1 -> b) -> (b1, b1) -> (b, b)
13:10:34 <benmachine> :t join (***)
13:10:35 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
13:10:49 <_andy_> thanks
13:10:54 <_andy_> :t join
13:10:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:11:05 <benmachine> woo awkward typeclasses
13:11:16 <benmachine> :t \f -> join f `const` f undefined
13:11:17 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
13:17:05 <Berengal> Anyone here with ghc 6.12 tried installing happstack-data?
13:17:24 <_andy_> @src join
13:17:24 <lambdabot> join x =  x >>= id
13:17:28 <_andy_> duh..
13:17:42 <xerox> _andy_ specialize join's type for m = "e ->"
13:17:49 <xerox> what type do you get?
13:18:03 <_andy_> start again?
13:18:07 <xerox> :t join
13:18:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:18:15 <xerox> let m = "e ->"
13:18:16 <_andy_> o right
13:18:48 <xerox> what type do you get?
13:18:50 <_andy_> e -> (e -> a) -> e -> a
13:18:57 <_andy_> appears sort of like
13:18:59 <xerox> good
13:19:07 <_andy_> :t ((.) .)
13:19:08 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
13:19:09 <xerox> except not
13:19:15 <_andy_> ok not quite ..
13:19:29 <xerox> use  (m (m a)) -> (m a)
13:20:34 <xerox> ok?
13:21:05 <_andy_> ok so (>>=) :: m a -> (a -> m b) -> m b, (a -> b) -> (b -> (a -> c) -> (a -> c)?
13:21:07 <_andy_> meh..
13:21:19 <_andy_> its wrong, and forgot paren
13:21:19 <xerox> yes but let's start with join
13:21:46 <xerox> bear with me :)
13:22:32 <_andy_> ok so need to define in terms of composition?
13:22:54 <xerox> no
13:23:03 <xerox> if you write it points free, you'd write join again
13:23:07 <_andy_> o
13:23:16 <xerox> the idea is: 1. specialize the type 2. implement the type in pointful manner
13:23:39 <keseldude> Any suggestions? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15910#a15910
13:23:58 <xerox> keseldude sure, remove 'deriving Show'
13:24:21 <xerox> err no.
13:24:21 <aavogt> keseldude: or make Board a newtype
13:24:25 <xerox> that one.
13:24:29 <_andy_> :t const
13:24:30 <lambdabot> forall a b. a -> b -> a
13:24:38 <keseldude> oh okay
13:24:59 <xerox> _andy_ if you write out the type, the implementation will come easily
13:25:04 <Philonous> Why do I get an EOF exception when trying to read from a named pipe via hGetLine instead of blocking behaviour?
13:25:29 <mauke_> because you've reached the end?
13:25:32 <roconnor> @type flip flip
13:25:34 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
13:25:50 <xerox> nice one.
13:26:03 <Berengal> Philonous: Are you sure the pipe is open?
13:26:24 <roconnor> @pl \f x y z -> f z x y
13:26:25 <lambdabot> (flip .) . flip
13:26:59 <Philonous> Berengal: "withFile filename ReadMode $ \handle ... " should do the trick?
13:27:20 <roconnor> @pl \f x y z -> f z y x
13:27:21 <lambdabot> flip . (flip .) . flip
13:27:45 <xerox> even permutations, even number of flips, odd perms, odd number of flips?
13:27:51 <Berengal> Philonous: It should. I would do some experiments...
13:28:28 <_andy_> @let join' x f y = f y
13:28:29 <_andy_> ?
13:28:29 <lambdabot>  Defined.
13:28:33 <_andy_> :t join'
13:28:34 <lambdabot> forall t t1 t2. t -> (t1 -> t2) -> t1 -> t2
13:28:43 <_andy_> ok nevermind
13:28:48 <Philonous> Berengal: When another process is waiting to put something into the pipe, it works.
13:29:05 <xerox> _andy_ nearly, what is the type exactly again?
13:29:18 <Berengal> Philonous: Waiting, as in blocking, or just that it has opened it?
13:29:33 <gwern> huh. this :{ :} ghci syntax, while odd, is very nice
13:29:49 <_andy_> need to enforce t1 in t
13:29:53 <kmc> frowning man w/ moustache
13:29:55 <Philonous> Berengal: blocking. I'Ve tried  "ls . > mypipe"
13:30:01 <benmachine> _andy_: it's not bracketed correctly
13:30:13 <xerox> _andy_ can I persuade you to write down the type y any means? :)
13:30:21 <xerox> s/ y / by /
13:30:26 <benmachine> (t -> (t -> a)) -> (t -> a)
13:30:29 <benmachine> oops
13:30:31 <Philonous> Berengal: I get an EOF as soon as ls exits. I don't know if this is intended, though
13:30:52 <Berengal> Philonous: What about if another process opens it for writing, but doesn't write anything?
13:31:01 <Berengal> (e.g. waiting for user input)
13:31:04 <_andy_> i don't understand s/ y / by /, you mean join' x f by = f by?
13:31:31 <xerox> _andy_ sorry I was correcting my own spelling.
13:31:32 <Berengal> Philonous: Because EOF when no other process has opened it for writing seems like correct behaviour to me
13:31:57 <xerox> _andy_ the pretty thing is that the type constrains you to write one implementation (basically)
13:32:16 <_andy_> o
13:32:22 <Berengal> _andy_: Have you figured out the type of join for m = (e ->) yet?
13:33:01 <Philonous> Berengal: Well, "cat mypipe" blocks until something is written to it.
13:33:33 <mauke_> but cat doesn't open the file in nonblocking mode
13:33:38 <sshc> Could not find module `Control.Monad.State.Strict': it is a member of the hidden package `mtl-1.1.0.2'
13:33:45 <Berengal> Philonous: cat may be smart enough.
13:34:02 <mauke_> cat isn't smart
13:34:10 <Berengal> It's a bit smart
13:34:13 <sshc> excuse me for my lack of searching, please, but is that not part of the standard packages?
13:34:20 <Berengal> Smarter than the average bear, at least
13:34:24 <_andy_> that was above: <_andy_> (e -> (e -> a)) -> (e -> a)
13:34:27 <_andy_> added parens
13:34:30 <Philonous> How would I open a file in blocking mode in haskell?
13:34:32 <mreh> what is that thing that demonstrates the limit of the expressive power of a regular grammar?
13:34:35 <_andy_> right?
13:34:38 <xerox> _andy_ great, now, how many arguments does that function have
13:34:44 <Berengal> sshc: You've probably hidden mtl yourself
13:34:46 <Philonous> mreh: puping lemma
13:34:50 <Philonous> pumping*
13:35:17 <Berengal> _andy_: Right, so write a function with that type
13:35:18 <xerox> _andy_ note that a -> (b -> c) is equal to a -> b -> c
13:35:33 <sshc> Berengal: how could I have hidden mtl?
13:35:36 <_andy_> does that go to:
13:35:39 <mauke_> Philonous: http://haskell.org/ghc/docs/latest/html/libraries/unix-2.4.0.0/System-Posix-IO.html#v%3AopenFd ?
13:35:42 <sshc> Berengal: should I depend upon it in the cabal package?
13:35:50 <mreh> pumping lemma!
13:35:54 <_andy_> i always had trouble there
13:36:04 <_andy_> not: e -> e -> a -> e -> a
13:36:09 <Berengal> sshc: Oh, you're building from cabal? Then yes. Cabal hides all packages that aren't directly depended upon
13:36:10 <xerox> _andy_ right, too much
13:36:16 <Philonous> mauke_: Thanks.
13:36:22 <xerox> _andy_ you can remove parens on the right but not on the left of ->
13:36:50 <sshc> where does ./Setup.hs install install files to?
13:36:54 <_andy_> e -> e -> a -> (e -> a)
13:37:06 <xerox> _andy_ I always confuse right and left too..
13:37:13 <_andy_> o right heh
13:37:34 <xerox> it's so arbitrary (:
13:37:35 <_andy_> (e -> e -> a) -> e -> a
13:37:40 <xerox> awesome
13:37:55 <xerox> so join :: (e -> e -> a) -> e -> a
13:38:06 <Berengal> Now implement!
13:38:16 <xerox> indeed. how many argument does that join take?
13:39:14 <_andy_> i really don't see what could implement that, unless:
13:39:24 <_andy_> @let join' f x = f x x
13:39:25 <lambdabot>  <local>:10:0:
13:39:25 <lambdabot>      Equations for `join'' have different numbers of arguments...
13:39:30 <xerox> exactly :)
13:39:34 <_andy_> @let join'' f x = f x x
13:39:35 <lambdabot>  Defined.
13:39:42 <_andy_> :t join''
13:39:43 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
13:39:44 <xerox> that's how join (***) works
13:39:49 <_andy_> ok
13:39:57 <_andy_> took me a while, but now it makes sense..
13:40:05 <xerox> join (***) f = (f *** f)
13:40:16 <xerox> > join (^) 10
13:40:17 <lambdabot>   10000000000
13:40:29 <_andy_> thats actually rather clever..
13:40:55 <xerox> you can get all sorts of nifty useful combinators by doing the exact same mechanical thing with say: ap, (=<<)
13:41:14 <kmc> :t join (***)
13:41:16 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
13:41:18 <_andy_> :t ap
13:41:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:41:24 <xerox> have fun!
13:41:49 <_andy_> for some reason easier to think in terms of Control.Applicative, at least as far as
13:42:00 <_andy_> understand (->) a as an Applicative rather than a Monad
13:42:04 <dum8d0g> Hi, I just upgraded ghc to version 6.12.1 (latest) and now I get  Could not find module `Text.ParserCombinators.Parsec.Language'.. I looked into ghc package and I cannot find parsec anywhere.. what happend?
13:42:04 <_andy_> *understanding
13:42:13 <kmc> dum8d0g, a lot of things got split out of ghc
13:42:21 <_andy_> i know just different names
13:42:22 <kmc> soon there will be a Haskell Platform release for 6.12.1
13:42:30 <kmc> in the meantime, get cabal-install and install parsec yourself
13:42:41 <xerox> _andy_ here's a list: ap, (=<<) (which are very similar!), fmap, sequence
13:42:43 <kmc> 6.12.1 is not recommended for end users until HP is out
13:42:44 <dum8d0g> :/
13:43:33 <keseldude> Thank you, aavogt; I got it to work :)
13:44:13 <_andy_> fmap and ap get pretty close too
13:44:31 <_andy_> going home now though
13:44:38 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15900#a15900 <- help needed...
13:44:38 <_andy_> thanks for helping me through that
13:45:12 <kmc> eek Berengal
13:45:23 <Berengal> kmc: That's what I've been saying as well
13:45:46 <Berengal> kmc: I've tried everything, including reinstalling ghc (6.12) and cabal, but I get the same result even then
13:45:53 <kmc> can you build Happstack/Data/Xml/Base.hs manually with ghc --make ?
13:46:08 <kmc> also, did you try changing optimization settings
13:47:51 <ElfArmy> Rookie question, does anyone know where I might look to improve the cleanliness of: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15912#a15912
13:48:05 <kmc> use more newlines
13:48:40 <ElfArmy> With regards to brevity? :)
13:48:59 <kmc> with regards to anyone being able to read your code to suggest brevity improvements ;)
13:49:05 <benmachine> ElfArmy: the case statement at the end doesn't handle Nothing, is that intentional?
13:49:22 <Berengal> kmc: Optimization settings doesn't help anything. I'm having a little trouble building that file manually, but I'll try some things...
13:49:29 <kmc> ElfArmy, is the goal to do this in the fewest characters possible?
13:49:35 <kmc> because i feel it would be far more readable with a "do" block
13:49:37 <benmachine> ElfArmy: if it is, you could try using fromJust from Data.Maybe instead
13:49:37 <c_wraith> I'd use the maybe function instead of matching on Maybe constructors, and I'd use a do block
13:49:52 <kmc> also, there may be a "join" in there somewhere
13:49:55 <ElfArmy> Oh, thanks.
13:49:57 <kmc> well, hmm, maybe not
13:49:59 <benmachine> ElfArmy: furthermore, liftM2 lookup (return var) = liftM (lookup var)
13:50:15 <benmachine> and, liftM = fmap
13:50:25 <benmachine> = <$> from Control.Applicative, which is fun to use infix
13:51:12 <ElfArmy> Cheers :)
13:52:02 <kmc> i have a really hard time telling what this code does
13:52:07 <kmc> except by guessing from the type sig
13:52:41 <jmcarthur> ElfArmy: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15912#a15914
13:53:13 <kmc> what's wrong with a do block?
13:53:18 <ElfArmy> Thanks for your help, that is the direction that lambdabot was heading in, but it didn't seem to like case being inline
13:53:20 <jmcarthur> ElfArmy: personally, i would not use fromJust like i did there
13:53:27 <jmcarthur> kmc: talking to me?
13:53:34 <kmc> eh either of you ;)
13:53:54 <mreh> it's easy to show that a grammer is irregular, I don't suppose it is easy to show it is regular apart from exhaustion?
13:53:57 <ElfArmy> Nothing personally
13:54:01 <jmcarthur> kmc: i don't like do blocks because they hide potential abstractions from me fairly often
13:54:16 <kmc> mreh, you mean "show that a language is irregular"?
13:54:22 <kmc> and "that it's regular"?
13:54:36 <aledge> mreh if you can write the grammar in...shit whatever the form is called, I think that will prove it is regular?
13:54:38 <mreh> kmc: proof by contradiction using the pumping lemma
13:54:40 <Berengal> kmc: It does seem to build when building manually
13:54:45 <kmc> you show a language is regular typically by giving a regular expression (or equivalently a finite automaton) and proving that it accepts the language
13:55:07 <mreh> fair
13:57:16 <pvdbrand> I'm writing some code which I'd like to operate over Strings, lazy ByteStrings, strict ByteStrings, and other kinds of lists, while providing just a single generic API. Right now, I've defined my own typeclass ListLike with a few trivial instances. Is there already an existing typeclass or a better approach?
14:03:03 <b_jonas_> pvdbrand: the hexpat module has an existing Text.XML.Expat.Tree.GenericXMLString type, but it's a bit specialized so you might not want that
14:03:10 <b_jonas_> pvdbrand: it might give you ideas though
14:03:44 <b_jonas_> pvdbrand: on the other hand the easiest is usually to choose just one type, operate on it internally, and make a class to convert to and from that type
14:03:51 <jmcarthur> pvdbrand: http://hackage.haskell.org/package/ListLike
14:04:07 <pvdbrand> jmcarthur: wow even the same name!
14:04:11 <pvdbrand> :)
14:04:17 <kmc> there's also Traversable and Foldable
14:04:17 <jmcarthur> yup :)
14:04:19 <kmc> which are more general
14:04:35 <benmachine> which you can derive these days!
14:04:35 <kmc> eek, they put everything in the class
14:04:40 <benmachine> due to the magic of ghc
14:04:41 <jmcarthur> yeah
14:04:44 <pvdbrand> b_jonas_: yeah I considered the 'to and from' approach, but I want to avoid the overhead
14:04:57 <b_jonas_> Foldable means can be converted _to_ a list only
14:05:06 <jmcarthur> ListLike is not very nice, but it gets the job done
14:05:37 <pvdbrand> I think I'll have to read up on Foldable and Traversable
14:05:54 <b_jonas_> or wait, is that Traversable?
14:06:02 <jmcarthur> that's foldable
14:06:16 <jmcarthur> traversable is basically sequence
14:06:36 <kmc> @src Foldable
14:06:37 <lambdabot> Source not found. That's something I cannot allow to happen.
14:06:46 <jmcarthur> @instances Foldable
14:06:47 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
14:06:52 <jmcarthur> grr
14:06:57 <kmc> @instances-importing Data.Foldable Foldable
14:06:58 <lambdabot> Maybe, []
14:07:01 <kmc> heh
14:07:18 <jmcarthur> unfortunately, ByteString can't be an instances of Foldable
14:07:41 <pvdbrand> I also need to construct for example an empty ListLike, like "" for strings and B.empty for ByteStrings
14:07:51 <jmcarthur> the monoids package has a reasonable alternative that is compatible with ByteString though
14:07:59 <jmcarthur> pvdbrand: try an instance of Monoid for that
14:08:11 <jmcarthur> mempty = "" ; mappend = (++)
14:08:15 <kmc> pvdbrand, also, GHC allows overloading string literals
14:08:16 <jmcarthur> String has it already
14:08:18 <pvdbrand> hmmm yeah
14:08:20 <kmc> "foo" :: (IsString s) => s
14:08:22 <jmcarthur> ByeString probably does
14:08:26 <jmcarthur> *ByteString
14:09:08 <kmc> :t fromString ""
14:09:09 <lambdabot> Not in scope: `fromString'
14:09:14 <kmc> :t Data.String.fromString ""
14:09:16 <lambdabot> forall a. (Data.String.IsString a) => a
14:09:34 <kmc> BS should implement that
14:09:46 <pvdbrand> I need: [], null, (:), uncons, reverse, concat, find, elem (some of which can surely be expressed in terms of others)
14:09:57 <kmc> uncons?
14:10:25 <pvdbrand> ByteStirng defines uncons :: [a] -> Maybe (a, [a])
14:10:37 <kmc> ah
14:10:40 <pvdbrand> kind of like (head a, tail a)
14:11:03 <ehird> what's the language extension for ?dynamic_thingies
14:11:33 <kmc> i'd think more like uncons :: (StringLike s) => a -> (Char -> s -> a) -> s -> a
14:12:05 <kmc> i feel like it's some kind of fold or unfold
14:12:21 * Berengal thinks it's somehow installed now
14:12:25 <pvdbrand> I just want to peel of the first item in the list with uncons
14:12:37 <pvdbrand> peel off
14:12:41 <jmcarthur> pvdbrand: http://hackage.haskell.org/packages/archive/monoids/0.2.0.2/doc/html/Data-Generator-Combinators.html and http://hackage.haskell.org/packages/archive/monoids/0.2.0.2/doc/html/Data-Monoid-Reducer.html have a lot of what you want (although they are significantly more general)
14:13:08 <pvdbrand> jmcarthur: more general makes my heart beat faster :)
14:13:15 <pvdbrand> I'll have a look
14:13:18 <kmc> mmmmmmonoid
14:13:54 <Berengal> I think I managed to haxxor cabal and ghc
14:14:16 <aavogt> omonoids?
14:14:36 <aavogt> omonomonoids?
14:14:36 <Berengal> omnomnomoids
14:16:29 <pvdbrand> I guess I'm looking for some kind of Monoid which I can construct *and* break down again
14:17:09 <Berengal> . o O (hyloid)
14:17:13 <kmc> maybe you want DList
14:17:19 <Alpounet> the catamorphism.net idea is very interesting.
14:17:20 <kmc> Berengal, :O
14:17:32 <Paczesiowa> lists based on appends?
14:17:47 <Polarina> Awww... ghci segmentation faulted. :(
14:17:58 <kmc> Polarina, eek.  that's pretty difficult to do
14:18:01 <kmc> what were you doing?
14:18:06 <Polarina> kmc: Actually, not really.
14:18:29 <dibblego> @type if'
14:18:30 <lambdabot> Not in scope: `if''
14:18:31 <Polarina> > reads "1e+9999999999999" :: [(Integer, String)]
14:18:31 <dibblego> @type ifM
14:18:33 <lambdabot> Not in scope: `ifM'
14:18:34 <Polarina> That's what I did.
14:18:35 <dibblego> screw you lambdabot
14:18:36 <lambdabot>   mueval: ExitFailure 1
14:18:36 <ehird> what's the language extension for (?dynamic_thingies)?
14:18:39 <ehird> Sorry if someone replied last time
14:18:43 <ehird> can't find it in scrollback
14:18:47 <kmc> ehird, ImplicitParams ?
14:18:51 <ehird> Thanks.
14:19:04 <pvdbrand> actually, I'm writing an optimized CSV parsing and writing library (why does talking about monoids in the context of a simple CSV parser make me feel like talking about the purpose of life while buying food at a supermarket? :))
14:19:15 <kmc> pvdbrand, i think any Monoid which you can construct and break down would be essentially equivalent to DList
14:19:42 <FliPPeh> User-Agent?
14:19:45 <FliPPeh> Whoops!
14:19:49 <ehird> pvdbrand: hell, I'm applying existential quantification, impredicative types, flexible contexts, multiple parameter type classes and rank N types to the problem of generating HTML.
14:20:06 <Paczesiowa> kmc: you cannot break down DLists
14:20:07 <jmcarthur> i still think the monoids package perfectly captures what it sounds like you are wanting
14:20:49 <pvdbrand> I basically want to support both reading and writing, hence the requirement to construct and deconstruct list like stuff
14:20:52 <jmcarthur> if your monoid is, say, a Generator, you should be able to break it down however you want
14:21:08 <pvdbrand> jmcarthur: I think you're right
14:21:20 <kmc> Paczesiowa, ah, you're right
14:21:25 <Berengal> Grrr, more linker errors!
14:21:28 <pvdbrand> jmcarthur: I'm reading the haddock now
14:21:30 <kmc> maybe a first-order version of DList
14:21:41 <joe1> > let showmatch (("",ys):xs) = do  putStr $ show ys  showmatch xs; showmatch [] = return ()
14:21:42 <lambdabot>   <no location info>: parse error on input `='
14:21:44 <jmcarthur> pvdbrand: the monoids package was actually designed with a new kind of parsing in mind
14:21:58 <Paczesiowa> ehird: well, you probably shouldn't do that, there's a risk of being useful... why don't you stick to the usual? facts, fibs and evals?
14:21:59 <pvdbrand> I think using DList still implies a conversion to and from the source/destination type, right?
14:22:02 <jmcarthur> pvdbrand: edwardk is using it for a monoidal parsing library he's working on
14:22:15 <joe1> how can I define the below let function in ghci prompt
14:22:16 <joe1> > let showmatch (("",ys):xs) = do  putStr $ show ys  showmatch xs; showmatch [] = return ()
14:22:17 <lambdabot>   <no location info>: parse error on input `='
14:22:24 <joe1> it gives out a parsing error
14:22:25 <jmcarthur> although i suspect it will end up being basically lexing and not much else
14:22:44 <Paczesiowa> ehird: and you still can't loop the typechecker:)
14:22:57 <jmcarthur> pvdbrand: http://comonad.com/reader/2009/iteratees-parsec-and-monoid/
14:23:02 <ehird> Paczesiowa: Cyclic HTML page!!!
14:23:08 <ehird> It's the new AJAX 2.0
14:23:16 <pvdbrand> lemme go and read all the pointers you guys gave me, thanks a lot!
14:23:24 * ehird decides to do attributes like Text.XHtml
14:23:35 <ehird> (html ! lang "en") (head_ ...) (body ...)
14:23:39 <ehird> parenfest!
14:23:58 <aavogt> ehird: impredicative types are supposedly going away
14:24:14 <ehird> aavogt: I don't know if I need them any more, since I've been adding and removing extensions for a while
14:24:16 <gwern> interesting. I can no longer cc myself to bug reports
14:24:18 <ehird> But why? :(
14:24:23 <pvdbrand> I hope to put a CSV library on hackage soon which will make everyone forget about csv and bytestring-csv... :)
14:24:55 * Berengal gives up. He wasn't made to haxxor linker bugs
14:24:59 <gwern> anyone know how I get a ghc trac account?
14:25:10 <aavogt> ehird: supposedly they cause lots of trouble without being useful to many people
14:25:24 <ehird> aavogt: Poppycock!
14:25:49 <gwern> ehird: that's bunkum!
14:25:54 <gwern> bosh! bollocks!
14:25:59 <gwern> balderdash!
14:26:00 <jmcarthur> gwern: http://community.haskell.org/
14:26:27 <gwern> jmcarthur: but I already have a c.h.o account
14:26:45 <jmcarthur> gwern: oh i was wrong. that's not necessary
14:26:50 <aavogt> is c code or is c community?
14:27:14 <gwern> aavogt: 'sboth, 'sblood!
14:27:15 <jmcarthur> gwern: i think the process to get an account on a particular project's trac is going to be project specific
14:27:16 <Ke> C is awesome!
14:27:22 <jmcarthur> gwern: what project is it?
14:27:25 <gwern> ghc
14:27:41 <gwern> trying to cc myself to #3813
14:27:56 <gwern> oh fun, the register page is 404d!
14:28:09 <jmcarthur> maybe you have to be added by an admin
14:28:15 <Berengal> Today it feels like nothing works...
14:28:22 <gwern> Berengal: the end is nigh
14:28:25 * Berengal decides he's better off going to bed
14:28:44 <gwern> yes. the whole world is going to bed.
14:28:50 <gwern> for one long snooze to 2013
14:28:53 <gwern> *2
14:29:37 <Berengal> No use in staying up if everything is fubar.
14:29:42 <aavogt> 2222, thank goodness it's so far off
14:30:03 <Berengal> 2048 isn't too far into the future though
14:30:26 <dmwit> gwern, jmcarther, Berengal, and Ke all hash to the same color.
14:30:30 <dmwit> It's very, very confusing.
14:30:35 <Alpounet> I couldn't make it for 1024 but 2048 should be ok
14:30:39 <gwern> dmwit: hash?
14:30:49 <dmwit> Or however irssi chooses colors for your nicks.
14:30:52 <aavogt> you know, the colors?
14:30:55 <astroboy> I've got a strange problem. ghc throws "parse error on input `import'" for a file, even if I import the module in several other files
14:31:01 <gwern> the human eye can see millions of shades and stuff, I heard. how can 4 names hash to the same thing
14:31:12 <dmwit> gwern: terminal apps only get 16 choices ;-)
14:31:24 <aavogt> you can have lots more
14:31:31 <dmwit> ?hpaste it, astroboy
14:31:31 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:31:41 <Ke> I don't know how many irssi supportds
14:31:47 <ehird> dmwit: 256.
14:31:51 <dmwit> aavogt: That would involve hacking perl.  I have so far maintained my perl virginity.
14:31:58 <dmwit> ehird: @you, too
14:32:07 <ehird> TMI
14:32:20 <aavogt> oh, there's no irc client in haskell?
14:32:27 <ehird> there might be
14:32:29 <astroboy> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6064#a6064
14:32:31 <ehird> not everything has to be haskell.
14:32:35 <aavogt> there's lambdabot at least
14:32:39 <dmwit> There is, but it sucks even harder than most of the other IRC clients.
14:32:53 <DekuNut> How would I write my own code that produces side effects, as in for example, if I wanted to write my own version of putStrLn?
14:33:04 <dmwit> ?src putStrLn
14:33:05 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
14:33:06 <Berengal> DekuNut: FFI
14:33:11 <aavogt> @vixen, do you really suck harder than other clients?
14:33:12 <lambdabot> do i not seem real to you?
14:33:43 <DekuNut> Thanks Berengal, this is pretty much exactly what I was hoping for
14:38:53 <tolkad_> !help
14:38:56 <tolkad_> @help
14:38:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:40:17 <tolkad_> Are there any bots in here besides lambdabot?
14:40:34 <xerox> @botsnack
14:40:35 <lambdabot> :)
14:40:35 <lunabot>  :o
14:40:39 <mental> :D
14:40:43 <ElfArmy> What more would you need.
14:40:44 <xerox> haha
14:42:04 <shapr> tolkad_: ?
14:42:21 <tolkad> Well I found how to create an infinite loop between lambdabot and scalabot
14:42:27 <tolkad> And I wanted to try it with other bots
14:42:29 <shapr> Why the channel wide ctcp version?
14:42:34 <shapr> ah
14:42:35 <tolkad> looking for bots
14:42:56 <Ke> he is looking for weaknessess!
14:43:04 <Amigoo> hi can anyone tell me what typeclasses are? I went through http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101,but i still couldn't understand it
14:43:18 <michael|> Aww, that's the link I was going to recommend :-(
14:43:30 <shapr> Amigoo: What do you think typeclasses are?
14:43:37 <Ke> Amigoo: I guess something like C++ virtual classes
14:43:41 <shapr> Amigoo: Or how would you describe what you do or do not understand so far?
14:43:51 <Ke> but nothing like that
14:44:01 <Amigoo> well
14:44:14 <Amigoo> I think typeclasses is just another type
14:44:19 <Amigoo> a function of types
14:45:16 <Ke> Amigoo: class is a set of types that have some features defined for them
14:45:28 <Ke> such as some function or so
14:46:36 <jmcarthur> Amigoo: you can think of a type class as an interface which types can provide
14:47:26 <shapr> Amigoo: I think of typeclasses as a way of writing some code that only applies to a particular type.
14:47:30 <jmcarthur> well, an interface which can do different things for different types
14:47:54 <jmcarthur> but they share the interface in common (and sometimes we impose some unchecked laws on type class instances, too)
14:48:17 <shapr> Yeah, I like jmcarthur's explanation better than mine.
14:48:42 <shapr> Amigoo: For example, it would be nice if you could compare all types for equality.
14:49:08 <Amigoo> what do you mean?
14:49:09 <jmcarthur> if only we could
14:49:15 <jmcarthur> @instances Eq
14:49:16 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:49:18 <jmcarthur> :t (==)
14:49:19 <lambdabot> forall a. (Eq a) => a -> a -> Bool
14:49:47 <Amigoo> ok
14:50:12 <jmcarthur> the type of (==) says that the two arguments must have the same type, but that type must *also* be an instance of Eq
14:50:41 <jmcarthur> Eq is the interface, and the instance of Eq for some type is an implementation of that interface
14:50:55 <Amigoo> what are those 2 arguments?
14:52:04 <jmcarthur> Amigoo: for example, True == False. the two arguments are both of type Bool, and Bool is an instance of Eq
14:52:04 <shapr> Amigoo: Can you read type signatures?
14:52:37 <Amigoo> yea
14:52:49 <Amigoo> but not if there is a typeclass in it
14:52:56 <ehird> how do fundeps work again?
14:53:04 <ehird> if b depends solely on a I do | a -> b right?
14:53:25 <xerox> 'a decides b' right
14:53:29 <jmcarthur> Amigoo: "Eq a =>" just means "oh, by the way, whatever type a is it must provide an implementation of the Eq interface"
14:53:40 <ehird> yess it works
14:54:32 <Amigoo> what does "provide an implementation of the eq interface" means?
14:54:52 <Amigoo> it must do something to eq?
14:54:53 <Ke> provide implementation for ==
14:55:03 <jmcarthur> Amigoo: it means there is an instance of Eq for that type. for example, instance Eq Bool where ...
14:55:09 <mreh> what is Parser, is it State s String?
14:55:17 <mreh> @src Parser
14:55:18 <lambdabot> Source not found. :(
14:55:43 <xerox> http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Prim.html
14:56:14 <jmcarthur> Amigoo: the instance itself doesn't have to be passed around explicitly. it's known implicitly at compile time since for True == False we know it must work for Bool
14:56:21 <xerox> mreh actually http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-String.html
14:56:38 <xerox> mental and there is one for ByteString and another for ByteString.Lazy
14:57:26 <gwern> this is so weird.
14:57:26 <mreh> xerox: cheers
14:57:33 <xerox> np
14:57:39 <Amigoo> :t (==)
14:57:40 <lambdabot> forall a. (Eq a) => a -> a -> Bool
14:57:44 <mreh> the london HUGs website hasn't been updated in a good while
14:57:46 <gwern> apparently you can only use :{ and :} if your case expressions have just one branch
14:57:47 <xerox> gwern the instances are all imported once you import Text.Parsec
14:57:54 <jmcarthur> > True == False
14:57:54 <xerox> ah sorry you meant something else :)
14:57:55 <lambdabot>   False
14:57:57 <gwern> use 2 branches, and the thing blows up
14:58:02 <jmcarthur> > "foo" == "foo"
14:58:03 <lambdabot>   True
14:58:10 <Amigoo> ok
14:58:11 <jmcarthur> > Just 5 == Nothing
14:58:12 <lambdabot>   False
14:58:18 <Amigoo> those make sense
14:58:29 <gwern> 'case undefined of _ -> undefined'? kosher. 'case undefined of _ -> undefined; _ -> undefined'? parse error
14:58:32 <Amigoo> because those are just logic, if they are not the same, then it's false
14:58:36 <jmcarthur> each of those uses a different instance of Eq to come up with the answer
14:58:56 <Amigoo> how?
14:59:06 <Amigoo> how does the process go in the "instances"?
14:59:26 <joe1> @hoogle newLine
14:59:26 <lambdabot> Text.Parsec.Char newline :: Stream s m Char => ParsecT s u m Char
14:59:26 <lambdabot> Text.ParserCombinators.Parsec.Char newline :: Stream s m Char => ParsecT s u m Char
14:59:26 <lambdabot> Text.Regex.Posix.ByteString compNewline :: CompOption
14:59:32 <jmcarthur> Amigoo: it simply uses a different definition of (==) for each type
15:00:11 <dolio> gwern: It works with semicolons. :{ :} must strip out the newlines.
15:00:11 <jmcarthur> Amigoo: in ghc, a record containing the functions of the type class is implicitly passed around, but that's an implementation detail
15:00:24 <gwern> dolio: it's bizarre is what it is
15:00:25 <Amigoo> 1 = "apple"
15:00:32 <Amigoo> > 1 == "apple"
15:00:33 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
15:00:33 <lambdabot>    arising from the literal ...
15:00:33 <gwern> dolio: buggy, I'd call it
15:00:41 <dolio> Report it.
15:00:53 <jmcarthur> Amigoo: but you could imagine the "Eq a =>" stuff being replaced with something like "EqDict a ->" as an additional argument
15:01:07 <dolio> gwern: Same thing happens with do.
15:01:09 <gwern> dolio: also, looks like there are scoping issues
15:01:26 <Amigoo> so is a typeclass a function?
15:01:27 <gwern> dolio: can't use :def inside it, for exmaple, seems
15:01:36 <jmcarthur> Amigoo: where data EqDict a = EqDict { (==) :: a -> a -> Bool ; (/=) :: a -> a -> Bool }
15:01:52 <jmcarthur> Amigoo: a type class is an interface
15:01:55 <gwern> dolio: by which I mean you can't go {: let foo = x ; :def foo foo :}
15:02:01 <gwern> if you follow
15:02:38 <Amigoo> hmmm
15:02:46 <ehird> Why does haskell-indentation indent two spaces by default?
15:02:48 <Amigoo> this thing is very tricky
15:02:49 <ehird> Isn't 4 more common?
15:02:55 <dolio> gwern: That doesn't work on a single line anyway.
15:03:30 <jmcarthur> Amigoo: consider the Num type class as another example
15:03:33 <jmcarthur> > 5 + 4
15:03:35 <lambdabot>   9
15:03:41 <jmcarthur> > 5.3 + 4.5
15:03:42 <lambdabot>   9.8
15:03:58 <jmcarthur> :t 5.3 + 4.5
15:03:59 <lambdabot> forall t. (Fractional t) => t
15:04:03 <jmcarthur> :t 5 + 4
15:04:04 <lambdabot> forall t. (Num t) => t
15:04:08 <jmcarthur> ugh
15:04:11 <jmcarthur> i don't want that
15:04:15 <jmcarthur> :t 5 + 4 :: Int
15:04:16 <lambdabot> Int
15:04:21 <jmcarthur> :t 5.3 + 4.5 :: Double
15:04:23 <lambdabot> Double
15:04:34 <gwern> you'll get what you're served and you'll like it!
15:04:45 <jmcarthur> Amigoo: (+) is a member of the Num type class
15:04:46 <gwern> you can have any color number you want, so longs it black
15:04:46 <jmcarthur> :t (+)
15:04:47 <lambdabot> forall a. (Num a) => a -> a -> a
15:04:51 <Amigoo> ok
15:05:10 <Amigoo> so what's in the eq type class?
15:05:14 <jmcarthur> Amigoo: when we apply (+) to a couple Ints, it uses the definition from the Int instance of Num
15:05:18 <gwern> @src Eq
15:05:19 <lambdabot> class  Eq a  where
15:05:19 <lambdabot>     (==), (/=)   :: a -> a -> Bool
15:05:37 <jmcarthur> when we apply (+) to a couple Double, it uses the definition from the Double instance of Num
15:06:01 <jmcarthur> yeah, the Eq type class is just (==) and (/=)
15:06:08 <dolio> gwern: :{ and :} just let you split a single command over multiple lines, so I wouldn't expect it to do a let and a :def unless you could do both on a single line anyway.
15:06:26 <Amigoo> so is int -> a -> a -> a the same as string -> a -> a -> a in this case?
15:06:29 <dolio> But having it make layout ineffective is a pain.
15:06:32 <gwern> dolio: requiring semicolons is still fail
15:07:09 <jmcarthur> Amigoo: i think that question is not on the right path
15:07:13 <Amigoo> the type of "==" has a typeclass in itself
15:07:40 <Amigoo> I can't understand defining a term in it's own definition
15:07:41 <jmcarthur> Amigoo: when you instantiate Eq for Int, you create a function (==) :: Int -> Int -> Bool and another (/=) :: Int -> Int -> Bool
15:07:52 <Amigoo> that's like saying, what is an apple? an apple is an apple
15:08:11 <Amigoo> apples is made up of many apples
15:08:19 <Amigoo> apples is made up of many apple
15:08:36 <jmcarthur> Amigoo: it just says that because a must be an instance of Eq for (==) to be valid. it's not actually using the instance in this case
15:09:12 <Amigoo> ok, so (==) and (/=) both have the same type class
15:09:20 <jmcarthur> Amigoo: Eq a => is just a type constraint
15:09:30 <jmcarthur> Amigoo: they are both defined in the same type class
15:09:38 <Amigoo> ok
15:09:49 <Amigoo> that part I understand
15:10:09 <Amigoo> but
15:10:34 <Amigoo> ummm
15:10:39 <Amigoo> I am cofusing myself
15:10:51 <jmcarthur> Amigoo: do you know yet how to make your own data types?
15:10:59 <mreh> :t eitherCase
15:10:59 <lambdabot> Not in scope: `eitherCase'
15:11:07 <Amigoo> yea
15:11:33 <mreh> @hoogle eitherCase
15:11:34 <lambdabot> No results found
15:11:40 <jmcarthur> Amigoo: make a simple data type, say data Foo a = Foo a | Bar | Baz a a, and try making an instance of Eq for it
15:11:40 <Amigoo> someFunc :: [Int] -> [Int] -> Bool
15:11:56 <jmcarthur> Amigoo: ah, that's just a type signature
15:12:01 <Amigoo> o
15:12:01 <jmcarthur> i meant like a data structure
15:12:34 <osfameron> o/ traversed for the very first time o/
15:12:42 <Amigoo> let x = [1..10]
15:12:47 <Amigoo> like a list?
15:13:14 <jmcarthur> well, like: data List a = Nil | Cons a (List a)
15:13:23 <jmcarthur> not like a value of type [a]
15:13:36 <Amigoo> no, I guess I don't know how to do that
15:13:43 <jmcarthur> okay
15:14:01 <jmcarthur> in that case, i wouldn't even worry much about how type classes work just yet
15:14:08 <Amigoo> ok
15:14:31 <jmcarthur> i would just internalize that some functions can have different implementations for different types
15:15:03 <jmcarthur> and come back to type classes once you can define new data types (and thus be able to write your own instances of existing type classes)
15:15:14 <jmcarthur> alternatively, you could make a new type class and make instances of it for existing types
15:18:39 <jmcarthur> Amigoo: are you following a tutorial of some sort?
15:19:16 <ehird> I have «data Element a = (IsHTML a) => Element [Attribute a] a»
15:19:26 <ehird> there's no way to have [AnyElement] without] *another* wrapper, is there?
15:19:31 <ehird> [forall a. Element a] doesn't work, etc.
15:19:51 <nettok> hola Amigoo, have you read http://learnyouahaskell.com/ ?
15:21:01 <nettok> I think it is a very good book to start learning haskell
15:21:36 <xerox> ehird (IsHTML a) => [a] ?
15:22:02 <ehird> xerox: that only lets you do a list of the same element, no?
15:22:10 <ehird> [elem,elem] works but [elem,differentelem] doesn't
15:22:29 <ehird> *Main> :t [head_,body] :: IsHTML a => [a]
15:22:30 <ehird> <interactive>:1:0:
15:22:31 <ehird>     Couldn't match expected type `Element HEAD'
15:22:31 <xerox> ehird right
15:22:33 <ehird>            against inferred type `Element BODY'
15:22:34 <ehird> indeed.
15:22:39 <ehird> I think I need to make another wrapper, which is *really* irritating
15:22:54 <xerox> ehird or you can make HEAD and BODY be costrunctors for the same type
15:22:59 <ehird> No, I can't.
15:23:02 <ehird> That would break type-safety.
15:23:12 <ehird> xerox: the whole reason Element exists is to allow doing this
15:23:17 <ehird> as [IsHTML a => a] doesn't work
15:23:19 <ehird> I know this is possible
15:23:23 <ehird> but my adding of constraints has broken it :(
15:23:30 <xerox> you can use GADT I think
15:24:11 <ehird> xerox: yeah I might consider it
15:24:38 <ehird> xerox: actually, no, I don't think so
15:24:59 <ehird> It's *incredibly* annoying if this can't be done
15:25:41 <ehird> Any type wizards know if it can be done? :(
15:25:50 <sjanssen> ehird: "IsHTML a => [a]" is not the right type
15:25:50 <Ke> it's not like haskell is turing complete or anything
15:26:03 <Ke> !
15:26:11 <xerox> What about using a tree instead of a list?
15:26:20 <ehird> sjanssen: That's not what I'm doing.
15:26:28 <ehird> I'm trying to do [forall a. Element a]
15:26:33 <ehird> data Element a = (IsHTML a) => Element [Attribute a] a
15:26:38 <ehird> created specifically because of that problem
15:26:42 <ehird> The issue is, the "a" type parameter is messing it up
15:26:49 <ehird> but it's required elsewhere
15:27:00 <xerox> (does the IsHTML a constraint do actually anything there?)
15:27:05 <ehird> So how can I make a list of arbitrary Elements without making a wrapper type? I doubt I can.
15:27:07 <ehird> xerox: yes.
15:27:24 <sjanssen> ehird: no, what you want is [exists a. Element a]
15:27:40 <sjanssen> Haskell only supports these types if you introduce a wrapper
15:27:44 <ehird> Hmm, right
15:27:50 <ehird> I know that
15:28:00 <ehird> Element is my wrapper, but the problem is adding what I needed broke it :(
15:28:09 <ehird> a two-wrapper solution is totally unworkable for me
15:28:20 <ehird> Is there any way I can change Element to make it work?
15:28:35 <ehird> Say, remove the type parameter but have some sort of backdoor that my implementation can use to pass type parameters to something Element uses?
15:28:38 <ehird> Ehh, I don't know.
15:28:44 <ehird> I guess it's broken. *sigh*
15:28:47 <sjanssen> ehird: you could just not use lists
15:28:54 <ehird> sjanssen: also completely unworkable
15:29:22 <sjanssen> ehird: why is that unworkable?  It seems like you're dismissing all alternatives out of hand
15:29:30 <monochrom> Use Template Haskell to do all the translation for you.
15:29:53 <ehird> sjanssen: Because I want to implement an interface.
15:29:57 <ehird> I can sacrifice all implementation constraints
15:30:00 <ehird> but no interface ones
15:30:14 <ehird> Lists are part of that interfac ooh, I have an idea.
15:30:22 <ehird> I think I can make this work, actually.
15:30:46 <ehird> Thanks for the spark of inspiration :P
15:31:05 <sjanssen> ehird: usually if you want to push the type system this far you need to make compromises on interface
15:31:13 <ehird> Yeah :(
15:31:40 <ehird> I just remembered how I did it last time, though. :P
15:32:14 <ehird> Thankfully the implementation can be as ugly as I want as it's all going to be generated.
15:33:20 <ehird> Uh oh, incoherent instances.
15:34:21 <ehird> Like a big siren saying "your code won't work". :)
15:41:30 <dum8d0g> hi.. is there way to do pattern matching in lamda function?
15:41:57 <aavogt> > (\(x:xs) -> x) " dum8d0g"
15:41:58 <lambdabot>   ' '
15:42:27 <dum8d0g> but if I need more?
15:42:34 <aavogt> if you want to cover more cases, then do the matching in a case expression inside the lambda
15:42:41 <jmcarthur> > (\x -> case x of Just y -> y ; Nothing -> 2) (Just 5)
15:42:43 <lambdabot>   5
15:42:58 <dum8d0g> ha
15:42:59 <dum8d0g> nice
15:43:00 <dum8d0g> thx
15:43:12 <jmcarthur> i would use the maybe function for that particular case, though
15:43:17 <jmcarthur> or fromMaybe, even
15:43:19 <jmcarthur> :t maybe
15:43:20 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:43:22 <jmcarthur> :t fromMaybe
15:43:23 <lambdabot> forall a. a -> Maybe a -> a
15:43:42 <jmcarthur> > fromMaybe 2 (Just 5)
15:43:42 <sjanssen> ehird: I was just looking at this, and I think the trick is to parametrize types by what they can be children of, rather than what they are
15:43:43 <lambdabot>   5
15:45:49 <ehird> sjanssen: possibly; I'm taking a different approach
15:46:06 <ehird> which is to only Element-box the types that need to be (i.e. lists), in a constructor function
15:47:29 <ehird> is there a way to say "a type of the form blah will never be an instance of this typeclass?"
15:47:40 <ehird> So that I can have IsHTML a => AddAttribute a a and also one for functions and they won't be incoherent
15:47:46 <ehird> Because IsHTML a implies not-(->)
15:48:35 <sjanssen> ehird: I know that it's been done
15:48:44 <ehird> Great :P
15:48:48 <sjanssen> @google oleg kiselyov
15:48:49 <lambdabot> http://okmij.org/ftp/
15:48:49 <lambdabot> Title: This FTP site
15:48:55 <sjanssen> there you go.
15:49:22 <ehird> hahaha
15:49:43 <ehird> I might just make it a type family, type families solve everything right?
15:50:20 <sjanssen> I don't think a type family can do this either -- type families must be non-overlapping
15:50:43 <ehird> It worked when all the elements were wrapped in Element >_<
15:50:48 <ehird> Maybe you're right about that children thing
15:50:51 <ehird> Think a GADT would work?
15:52:10 <sjanssen> I don't know your requirements, but the solution I had in mind just needs ExistentialQuantification
15:53:29 <ehird> sjanssen: basic example?
15:53:33 <ehird> I didn't quite grok your solution
15:53:56 <tolkad> Hey, do you think I should call my class ApplicationManagerHelperFactoryFactory or ApplicationManagerFactoryFactoryHelper?
15:54:33 <jmcarthur> AbstractApplicationManagerHelperStrategyFactoryFactory
15:54:34 <xerox> what about Foo.
15:54:55 <ehird> tolkad: ApplicativeEndomorphism
15:56:29 <ehird> sjanssen: like, I don't get what the types would look like
15:56:45 <O1athe> ApplicationManagerLookingForPromotionToChiefTechnicalOfficerHelperFactoryFactory
15:56:54 <pastah_rhymez> are we writing java now?
15:56:56 <ehird> :D
15:56:59 <Zao> Smells like Java in here.
15:57:26 <pastah_rhymez> Zao: better than regular
15:57:47 <tolkad> tolkad's rules of class naming: No nouns converted into words like "Manager", "Constructor", etc. No abstract words like Manager, Helper, etc.
15:58:04 <tolkad> oops
15:58:09 <tolkad> verbs converted into nouns*
15:58:12 <Zao> I prefer Manajor.
15:58:16 <ehird> "NOTE: the impredicative-polymorphism feature is deprecated in GHC 6.12, and will be removed or replaced in GHC 6.14."
15:58:18 <ehird> Sad.
15:58:36 <ehird> sjanssen: no hints? :)
15:58:48 <Saizan> ehird: i think you're not using ImpreidcativeTypes in the end
15:58:55 <ehird> Saizan: yeah, me too
15:59:17 <sjanssen> ehird: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15919#a15919
16:00:10 <joe1> > :t toByte
16:00:11 <lambdabot>   <no location info>: parse error on input `:'
16:00:17 <ehird> sjanssen: objection
16:00:20 <joe1> @hoogle toByte
16:00:21 <lambdabot> No results found
16:00:24 <ehird> that doesn't enforce the number of children to html
16:00:28 <joe1> @hoogle Byte
16:00:28 <lambdabot> System.Posix.Types type ByteCount = CSize
16:00:29 <lambdabot> module Data.ByteString
16:00:29 <lambdabot> module Text.Parsec.ByteString
16:00:33 <joe1> @hoogle stringToByte
16:00:33 <lambdabot> No results found
16:00:38 <ehird> in my way, you must pass the first argument as a head, and the second argument as an html child (body or frameset)
16:00:42 <ehird> and there are no other arguments
16:00:48 <ehird> so yours is less type safe, I think
16:00:50 <aavogt> @type B.pack
16:00:51 <lambdabot> Couldn't find qualified module.
16:00:53 <ehird> you could implement that in the constructor I guess
16:00:59 <aavogt> @hoogle pack
16:00:59 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
16:00:59 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
16:00:59 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
16:01:00 <joe1> aavogt: thanks.
16:01:01 <ehird> so yours basically offloads everything to the constructor, right?
16:01:10 <sjanssen> ehird: so what's the type of html in your version?
16:01:21 <ehird> html :: (Child HTML a) => HEAD -> a -> HTML
16:01:47 <ehird> data HTML = forall a. (Child HTML a) => HTML [Attribute HTML] HEAD a
16:02:43 <sjanssen> ehird: my version offloads everything to the types of the smart constructors
16:02:58 <ehird> right.
16:03:09 <ehird> your approach seems more workable, I'll give it a try
16:03:39 <ehird> "enforcing (some) well-formedness of HTML"
16:03:41 <ehird> what's the (some) there
16:03:46 <ehird> the everything-is-a-list issue?
16:04:03 <sjanssen> html [head, head, head], for example
16:04:06 <joe1> is there a standard function that can convert a list of 8 bits to a byte(Int)?
16:04:17 <sjanssen> I don't know how involved the rules are in HTML
16:04:17 <ehird> sjanssen: right
16:04:22 <ehird> you can fix that in the smart constructor, I think
16:04:24 * ehird gives it a try
16:04:28 <joe1> where the bits are actually [Int]
16:04:41 <ehird> sjanssen: also, how does your scheme do typechecking of attributes?
16:04:46 <ehird> I suspect the answer is "not"
16:04:52 <tromp_> i suggest a fold, joe1
16:04:58 <joe1> bits as [Int] -> byte Int.
16:04:59 <ehird> oh, you could do them with smart constructors, I think
16:05:03 <O1athe> > foldl' ((+).(*2)) 0 [1,1,0,0,0,0,0,0]
16:05:05 <lambdabot>   192
16:05:06 <joe1> tromp: thanks.. will give it a shot.
16:05:10 <ehird> instead of HtmlChild have HtmlIdentifier as a more general name or whatever
16:05:15 <ehird> and have Attribute HtmlIdentifier
16:05:20 <ehird> well
16:05:25 <ehird> IsAttribute HTMLIdentifier a => a
16:05:26 <joe1> O1athe: thanks. looks very simple too..
16:05:27 <ehird> or whatever
16:05:33 <O1athe> You're welcome.
16:05:38 <ehird> sjanssen: erm, wait
16:05:42 <sjanssen> ehird: I'd use the same system as elements currently use
16:05:59 <ehird> in your Element, can't [Element b] only have one value of b?
16:06:02 <ehird> since the forall is outside of it
16:06:06 <sjanssen> yes
16:06:13 <joe1> @hoogle foldl`
16:06:13 <lambdabot> Parse error:
16:06:14 <lambdabot>   --count=20 foldl`
16:06:14 <lambdabot>                    ^
16:06:18 <joe1> @hoogle foldl'
16:06:18 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
16:06:18 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
16:06:18 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
16:06:23 <ehird> sjanssen: your scheme completely breaks for elements that can be the children of multiple elements
16:06:25 <ehird> for instance:
16:06:38 <damd> see this is why haskell shouldn't have type classes!!!!
16:06:44 <ehird> li :: ... -> Element (OLChild | ULChild)
16:06:46 <sjanssen> but the return of the smart constructors is polymorphic -- their ultimate concrete type is chosen when they're nested
16:06:55 <sjanssen> ehird: no, my scheme allows for this
16:06:56 <ehird> hmm, ah
16:06:57 <ehird> you're right
16:07:00 <ehird> your scheme is really nifty
16:07:26 <ehird> I like it a lot
16:07:33 <ehird> btw, you don't need to handle cdata specially
16:07:36 <ehird> just have a fake element cdata
16:07:40 <ehird> and handle it in serialisation
16:07:52 <ehird> well, oh
16:07:55 <ehird> sjanssen: slight issue
16:08:01 <ehird> the arguments need to be typeclasses
16:08:04 <ehird> so that you can pass a string directly
16:08:07 <sjanssen> it is flawed, though.  There is no type for "this value is a <p>"
16:08:08 <ehird> (to the smart constructors)
16:08:25 <ehird> sjanssen: just add it as another argument to Element
16:08:32 <ehird> head :: ... -> Element HeadChild a
16:08:48 <sjanssen> ehird: that will mean that you can't use the elements in lists
16:09:04 <ehird> sjanssen: come to think of it, actually, it's impossible to have [someelem, "foo", someelem] without overridable strings
16:09:07 <ehird> :(
16:09:11 <ehird> I am a sad pony
16:09:24 <sjanssen> ehird: you do know about the OverloadedStrings extension, right?
16:09:30 <O1athe> Sad ponies :(
16:09:41 <Raymond> Are there normal people on xchat?
16:09:46 <ehird> sjanssen: yep
16:09:55 <ehird> sjanssen: and I don't want files merely using my code to require language extensions
16:10:38 <sjanssen> well, no way around that
16:11:09 <ehird> I'm a sad bunny :)
16:11:19 <ehird> ehh, I'll make something work
16:11:32 <ehird> the end goal is a preprocessor that lets you actually use xml syntax to write this stuff, so I can handle it in that
16:12:09 <ehird> sjanssen: instead of Element () shouldn't it be Element Void :-)
16:12:46 <sjanssen> ehird: oh, one other thing: you can't export the HeadC, BodyC etc. classes from your module if you want to guarantee well-formedness.  This means client modules won't be able to write explicit type signatures in some cases
16:12:50 * Gracenotes gives ehird carrots
16:13:02 <ehird> sjanssen: that's... irritating.
16:13:10 <ehird> sjanssen: why, btw? because someone could define an instance?
16:13:18 <ehird> I count that as someone extending the language it serialises
16:13:24 <ehird> not a violation of well-formedness
16:13:35 <sjanssen> ehird: actually, I'd probably make html :: HTML, with HTML being a wrapper around Element ()
16:13:55 <ehird> Why?
16:13:56 <sjanssen> ehird: yes, someone could add an instance.  Up to you whether you want to allow that
16:14:46 <ehird> that why was to [00:13] <sjanssen> ehird: actually, I'd probably make html :: HTML, with HTML being a wrapper around Element ()
16:14:48 <ehird> btw
16:14:50 <sjanssen> I dunno, maybe Element is better.  You might want to embed entire HTML documents in some other schema
16:15:12 <ehird> yeah, but why would you make it HTML?
16:15:24 <ehird> so that people can't embed it in other things?
16:15:26 <ehird> that's kinda lame imo :P
16:16:20 <ehird> Transforming «image path = do (w,h) <- imageDimensions path; return <a href={path}><img src={path} width={w} height={h}/></a>»
16:16:23 <ehird> into
16:17:07 <ehird> image path = do (w,h) <- imageDimensions path; return ((a ! attrHref path) [img ! attrSrc path ! attrWidth w ! attrHeight h])
16:17:09 <ehird> is the ultimate goal
16:17:11 <sjanssen> if you want to allow embedding entire HTML docuemnts, then there ought to be an HtmlC class
16:17:30 <ehird> sjanssen: html will be treat like any other element since i'm autogenerating t his
16:17:32 <ehird> *this
16:17:48 <sjanssen> if you're autogenerating, why do you care about the interface?
16:18:09 <ehird> Because you might want to programmatically manipulate it outside of that preprocessor.
16:18:21 <ehird> Also, because you can't preprocess in GHCi.
16:18:24 <sjanssen> gotta go
16:18:47 <sjanssen> sometimes you can, with OPTIONS_GHCI and -pgmF
16:18:54 <sjanssen> erm, OPTIONS_GHC
16:19:04 <ehird> heh, fun
16:19:33 <ehird> not sure how I'll do namespaces, assuming I'm generating xml
16:19:41 <ehird> maybe foo:bar → attrFoo_Bar
16:22:46 <ehird> ah, a bigger problem is that I can't expose Element or any of the constructors :-)
16:38:43 <sshc> are there any packages that define the Either monad?
16:39:24 <Axman6> GHC.Either maybe?
16:39:30 <c_wraith> Control.Monad.Either defines Either e as a monad.
16:39:34 <Saizan> sshc: mtl, monadLib, ..
16:39:36 <c_wraith> But it's not a very good implementation
16:39:43 <sshc> c_wraith: why not?
16:39:46 <c_wraith> err,  Control.Monad.Error
16:39:57 <c_wraith> Because it requires e to be an instance of Error
16:57:11 <tensorpudding> @djinn (a -> Not a) -> b
16:57:11 <lambdabot> -- f cannot be realized.
17:01:34 <ehird> > foldr f x [a,b,c]
17:01:35 <lambdabot>   Ambiguous occurrence `f'
17:01:35 <lambdabot>  It could refer to either `L.f', defined at <local...
17:01:39 <ehird> > foldr g x [a,b,c]
17:01:40 <lambdabot>   g a (g b (g c x))
17:01:45 <ehird> > foldr id x [f,g]
17:01:46 <lambdabot>   Ambiguous occurrence `f'
17:01:46 <lambdabot>  It could refer to either `L.f', defined at <local...
17:01:48 <ehird> > foldr id x [f,g,h]
17:01:49 <lambdabot>   Ambiguous occurrence `f'
17:01:50 <lambdabot>  It could refer to either `L.f', defined at <local...
17:02:07 <dmwit> ?djinn Either a (Not a)
17:02:07 <lambdabot> -- f cannot be realized.
17:02:29 <dmwit> ?djinn Either a (Not a) -> (a -> Not a) -> b
17:02:29 <lambdabot> -- f cannot be realized.
17:02:36 <dmwit> mmm
17:03:38 <dmwit> I guess I need rank-2 polymorphism to say what I meant.
17:05:26 <Saizan_> ?djinn (a -> Not a) -> Not (Not b)
17:05:27 <lambdabot> -- f cannot be realized.
17:05:35 <aavogt> ?djinn Either a (Not a) -> (a -> Not a) -> a
17:05:36 <lambdabot> -- f cannot be realized.
17:06:27 <dmwit> aavogt: still needs rank-2 ;-)
17:06:30 <Saizan_> (a -> Not a) by itself is not a contradiction, e.g. it's fine for a = Void
17:06:36 <Axman6> @djinn Either a (Not a) -> (Not a -> a) -> a
17:06:36 <lambdabot> f a b =
17:06:37 <lambdabot>     case a of
17:06:37 <lambdabot>     Left c -> c
17:06:37 <lambdabot>     Right d -> b d
17:07:08 <aavogt> ?djinn Either a (Not a) -> (a -> Not a) -> Not a
17:07:08 <lambdabot> f a b =
17:07:08 <lambdabot>     case a of
17:07:08 <lambdabot>     Left c -> b c
17:07:08 <lambdabot>     Right d -> d
17:07:39 <dmwit> :t \e f -> either f id
17:07:40 <lambdabot> forall t a b. t -> (a -> b) -> Either a b -> b
17:07:53 <dmwit> err
17:07:57 <dmwit> :t \e f -> either f id e
17:07:58 <lambdabot> forall a b. Either a b -> (a -> b) -> b
17:08:39 <dmwit> :t left
17:08:40 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
17:08:57 <dmwit> ?hoogle Either a a -> a
17:08:57 <lambdabot> Data.Either rights :: [Either a b] -> [b]
17:08:57 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
17:08:57 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
17:10:07 <dmwit> :t (join either id .) . left
17:10:08 <lambdabot> forall a (a1 :: * -> * -> *) b. (Functor (a1 (Either b a)), ArrowChoice a1) => a1 b a -> a1 (Either b a) a
17:12:29 <Axman6> anyone know a little C++? trying to convert this into a haskell data structure (i've got a Vec type):  struct Ray { Vec o, d; Ray(Vec o_, Vec d_) : o(o_), d(d_) {} };
17:13:13 <kmc> i know more C++ than i'd like to
17:13:17 <kmc> can you take some?
17:13:24 <Axman6> i've got data Ray = R {o,d :: Vec, } so far
17:13:27 <kmc> that's just a pair of vectors
17:13:34 <Axman6> so that's all?
17:13:36 <kmc> yes
17:13:38 <kmc> the last bit is a constructor
17:13:39 <Axman6> ok
17:13:42 <Peaker> Axman6: C++ syntax :-(
17:13:44 <Axman6> ah right
17:13:48 <kmc> it's part of the C++ philosophy of "repeat yourself as much as possible"
17:13:48 <Axman6> Peaker: :(
17:13:52 <kmc> repeat yourself as much as possible
17:13:53 <kmc> repeat yourself as much as possible
17:13:55 <Axman6> heh
17:13:58 <Peaker> You have to write ridiculous amounts of boilerplate in C++ for a tiny type product
17:14:11 <kmc> and far far more boilerplate for a type sum
17:14:18 <Peaker> it didn't seem so ridiculous to me though, before knowing Haskell
17:14:40 <Axman6> kmc: so, i assume that R there would act as the contstructor defined there?
17:14:41 <dolio> It'll be so fast when you're done, though.
17:14:50 <kmc> Axman6, yes
17:14:54 <Axman6> excellent
17:14:58 <kmc> dolio, especially if you don't profile or measure the code at all
17:14:59 <Amigoo> How come it always feel like I am the only person that doesn't know about Haskell?  where are the other people who are trying to learn Haskell?
17:15:01 <Peaker> today, I tried explaining some more Haskell to someone at work, and I decided to use some C++ "equivalent" code to pass a point across, and it reminded me how horrible its syntax is
17:15:02 <kmc> then it will be *really fast*
17:15:09 <kmc> Amigoo, there are lots of them here
17:15:12 <kmc> hang around for a while
17:15:23 <Amigoo> Everyone seems to know so much
17:15:32 <Peaker> Amigoo: that was me, just 18 months ago or so
17:15:41 * theorbtwo doesn't know much, but doesn't talk much either.
17:16:05 <kmc> boost::tuple implements something like Haskell's tuples in only 2600 lines of awful templated C++ code
17:16:30 <Peaker> kmc: haha
17:16:39 <kmc> boost::variant implements Haskell's sum types (e.g. Either) in 5500 lines of same
17:16:47 <erikc> "it'll be so fast when you're done, though." <3
17:16:48 <kmc> and yes it even handles recursive types
17:16:53 <gwern> kmc: really? tell me it does something else like partially evaluate everything at compiletime or something awesome
17:16:56 <erikc> i lol'd
17:17:01 <Peaker> kmc: saying they actually implement something like Haskell's is a bit of an overstatement..
17:17:14 <kmc> it implements halfassed pattern matching via C++ function overloading
17:17:38 <ben0x539> int i, j; boost::tie(i, j) = some_function_returning_pair_of_ints();
17:17:44 <kmc> boost::tuple lets you make a tuple of non-const refs, so you can say:  boost::tie(a, b, c) = myFnThatReturns3Values();
17:17:49 <kmc> an incredible novel feature
17:18:31 <kmc> of course you still need to say the type of a,b,c elsewhere as ben0x539 did, and it can't be inferred.  that feature is scheduled for this year or maybe next
17:18:55 <kmc> you can do it with nonstandard compiler extensions
17:19:04 <kmc> {-# LANGUAGE FirstClassFunctions, TypeInference #-}
17:19:14 <gwern> I somtimes look at things people say about C++, and think, surely it can't be *that* bad and still be a major language
17:19:19 <ben0x539> Really, you can?
17:19:54 <Peaker> gwern: We use C at work, and some people really marvel at how great C++ is
17:19:59 <ben0x539> gwern: I suspect if you found a helpful C++ programmer and named another major language, they could make a convincing case that C++ has significant real-world advantages, etc
17:19:59 <theorbtwo> gwern: Being a major language, or a major anything else, has a lot to do with history, and very little to do with actual fitness for purpose.
17:20:05 <Alpounet> gwern, C++ is definitely not the worst language in there
17:20:10 <Peaker> We have a block of people preventing C++ from entering, though :)
17:20:13 <kmc> C++ is terrible, but unfortunately there is not a strong alternative in its niche
17:20:28 <kmc> its appropriate niche is much smaller than the set of things people use it for
17:20:44 <kmc> for example, it boggles the mind that people write ordinary desktop apps in unsafe unmanaged languages
17:20:51 <Peaker> I don't think C++ buys a lot over C -- and certainly not worth the extra size/complexity/etc
17:20:52 * ben0x539 contributes to a free software project that implements a multiplayer text editor in C++
17:21:07 <Peaker> ben0x539: what??
17:21:13 <erikc> thing is, they dont really develop desktop apps in C++, they develop it using a higher level language embedded in libraries, aka COM
17:21:14 <kmc> thanks Pidgin developers, you used strcpy insetad of strncpy and so some random jackass on MSN can pwn my computer
17:21:14 <Peaker> ben0x539: why not screen -x vim ?
17:21:27 <Peaker> kmc: strncpy is also unsafe, btw
17:21:30 <kmc> ugh
17:21:36 <ben0x539> Peaker: Everybody gets their own cursor
17:21:38 <theorbtwo> C++ is close enough to C for C programmers to pick it up easily enough, and easier enough for people who don't yet know C that it can be a first language.  It makes enough things easier then C that it's useful to learn.
17:21:42 <ben0x539> and there is a chat window!
17:21:42 <gwern> Peaker: is that the start of a simpsons ref?
17:21:46 <kmc> C++ is not close to C at all
17:21:51 <Peaker> gwern: what?
17:21:52 <kmc> C is a tiny subset of C++
17:21:52 <c_wraith> is there a way to get "ghc-pkg check" to list only the packages that are directly broken, not the ones that are transitively broken?
17:22:03 <ben0x539> kmc: C++ has very convenient FFI to C, though
17:22:08 <kmc> not at all
17:22:12 <Peaker> kmc: strncpy doesn't guarantee null termination, and it also zeroizes the entire rest of the dest if it wasn't copied to. Its entirely inappropriate
17:22:12 <kmc> it is much less convenient than a real FFI
17:22:35 <gwern> 'I'd like to use strcpy.' 'Very well. but I must warn you - it is unsafe!' 'ooh, that's bad.' 'but it comes with an easy replacement, strncpy' 'ooh, that's good. 'strncpy is *also* cursed'
17:22:37 <kmc> because keeping C compatability (except not really) has infected the C++ design with all sorts of horrible stuff
17:22:51 <gwern> Peaker: ^
17:22:57 <theorbtwo> kmc: Yes, horrible stuff like *actual users*.
17:23:09 <kmc> theorbtwo, you're right, nobody ever calls C code from other languages
17:23:18 <ben0x539> I do not understand how str[n]cpy is "unsafe". I do not think asking people to consider their preconditions is not too much.
17:23:33 <ben0x539> ... not
17:23:34 <kmc> basically they should have kept the type system a superset of C, but dropped the syntax embedding
17:23:54 <kmc> that's right.  "i use unsafe languages because i'm a REAL PROGRAMMER"
17:23:55 <monochrom> You can understand by noticing that these people call head unsafe.
17:23:56 <ben0x539> kmc: And added a magical #include that handles C properly?
17:24:18 <kmc> ben0x539, well... one of many benefits of dropping C embedding would be a real package and module system
17:24:34 <gwern> monochrom: I keep waiting for a total language to become successful at everything haskell is
17:24:34 <kmc> rather than the atrocious fit between a high level type system and a C-level include-and-link system
17:24:42 <Raymond> Are there computer science majors in here?
17:24:52 <gwern> Raymond: no. this is pure philosophy and math
17:24:52 * kmc BS CS 2008
17:24:59 <dons> Raymond: hehe. yes. many.
17:25:02 <dolio> I looked at the STL a fair amount back when I was working heavily on uvector-algorithms, and it's actually kind of nice for what it is.
17:25:12 <ben0x539> kmc: but the "backwards compatibility" that lets you use all sorts of C libraries without even thinking about it
17:25:23 <theorbtwo> kmc: Yes, there are plenty of things you could do in a C++-like language, if you decided to break C compatability in more places.
17:25:28 <monochrom> oh hi dons!
17:25:36 <Raymond> dons, are you?
17:25:39 <ben0x539> theorbtwo: you ought to be careful not to arrive at Java, though.
17:25:40 <theorbtwo> ...but I don't think that language would have caught on.
17:26:00 <dolio> What it is being an attempt at having somewhat abstract implementations of imperative algorithms over lots of different structures that doesn't have much overhead.
17:26:03 <kmc> the power and danger of C++ is that you can start a mostly C project, and start adding "one or two" C++ features
17:26:09 <kmc> ben0x539, so would a decent FFI.  since the type systems are close, you can autogenerate most wrappers
17:26:21 <dolio> It's kind of better than what I think we can easily do in Haskell, for the same type of thing.
17:26:40 <ben0x539> "most" :/
17:26:49 <ben0x539> Are there any actual success stories for FFI/autogenerated wrappers?
17:26:51 <kmc> you can't include all C headers in actual C++
17:26:58 <Peaker> gwern: hehe
17:27:01 <kmc> ben0x539, Python's ctypes ?
17:27:12 <ben0x539> You get reasonably close and can yell at the C folks to fix their headers instead of having to do the work yourself
17:27:16 <kmc> you don't even autogenerate code, you just import C libraries as if they were Python modules
17:27:22 <erikc> dolio: the template side of C++ is quite good, albeit accidentally, the object runtime side is rubbish
17:27:42 <kmc> the template side of C++ is an awkward metalanguage with *awful* syntax
17:28:02 <kmc> it's powerful despite this and so people claim it as a key success of C++
17:28:08 <dolio> erikc: Yeah, that may be. I kind of don't even pay attention to the object side anymore since I've been doing Haskell so long.
17:28:30 <JohnT1> Hi. I'm new to haskell and was wondering if it is more haskell-like to write "middle a b c = (sort [a,b,c]) !! 1", to write out the comparisons, or if there was another, better, way to write this function?
17:28:34 <Ke> don't you ever the the feeling you have been through these discussions already
17:28:37 <erikc> imo, C++ should be used as an implementation language for C libraries, and that's all
17:28:55 <erikc> extern "C" all the public API, that way other ppl can actually bind to it
17:29:00 <ben0x539> I really, really like the object side in C++ more than that of about any other language since it puts a lot of effort into letting you make types that can be used about as easily as builtin types
17:29:01 <Peaker> erikc: the template side of C++ is much better than it looks, but I wouldn't say its "quite good", even if far better than the rubbish object side
17:29:08 <Ke> I for one think FORTRAN66 with vendor specific extensions is an awesome language!
17:29:15 <ben0x539> instead of having an arbitrary "yeah but you must call .dispose() after using this" gotcha to anything nontrivial
17:29:33 <mental> ben0x539: you haven't used Python, Ruby, Smalltalk, C#?
17:29:39 <monochrom> JohnT1: I think that's fine.
17:29:44 <theorbtwo> ben0x539: No, you get the horrible smart pointers instead.
17:29:53 <Zao> ben0x539: Upon which someone will reply "just use an using block, lol".
17:29:58 <JohnT1> monochrom: thanks
17:30:01 <Zao> theorbtwo: If by horrible you mean awesome, yes.
17:30:14 <theorbtwo> Obscure -- #haskell is talking about C & C++, ##c is talking about haskell.
17:30:30 <monochrom> I guess dons and shapr don't care anymore.
17:30:31 <gwern> theorbtwo: why they are talking behind our backs?
17:30:32 <theorbtwo> Zao: No, awesome would be not needing them, like, oh, just about every other language.
17:30:51 <theorbtwo> gwern: Parens, mostly.
17:30:54 <shapr> monochrom: excuse me?
17:31:05 <shapr> What's going on now?
17:31:29 <Zao> theorbtwo: Well, it's C++. You need them. If you want pansy hand-holding with shitty GC, use another language with shitty GC like C# or Java.
17:31:37 <ben0x539> mental: Not used smalltalk, but none of the others seem to let me pretend I am a builtin type as much as C++ does
17:31:47 <shapr> Zao: Hey, be nice.
17:31:47 <Zao> theorbtwo: The alternative is keeping your tongue in the right mouth with dumb pointers.
17:31:53 <shapr> snart
17:32:07 <Raymond> So many genius in here
17:32:17 <ben0x539> theorbtwo: smartpointers solve problems that other languages do not solve for you either
17:32:18 <kmc> Raymond, oh?
17:32:26 <Raymond> Goood motivating factor
17:32:27 <Zao> shapr: Sorry, the language is close at heart.
17:32:34 <Raymond> Im trying to learn kmc
17:32:43 <Zao> ben0x539: Excellent trolling, sir.
17:32:44 <shapr> As dons would say, perhaps a discussion of C++ belongs more on #haskell-blah ?
17:32:53 <shapr> C'mon, move it along...
17:33:10 <ben0x539> I do not think any of the #haskell-blah regulars care for C++!
17:33:17 <ben0x539> Zao: I take offense
17:33:24 <shapr> ben0x539: dude, don't take offense...
17:33:28 <shapr> We don't give it out here.
17:33:33 <theorbtwo> ben0x539: Er, um... not really, no.  Haskell doesn't force you to worry about memory management, perl doesn't, ruby doesn't...
17:33:40 <Zao> theorbtwo: Space leaks?
17:33:57 <kmc> haskell forecs you to worry about strictness management
17:33:59 <ben0x539> theorbtwo: Memory is not the only thing that you can dispose of
17:34:00 <monochrom> @quote monochrom leaks
17:34:00 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
17:34:17 <ben0x539> perl has a pretty shoddy memory management thing, no?
17:34:24 <shapr> ben0x539: Dude, be nice.
17:34:27 <Raymond> kmc, can I call you sifu
17:34:27 <shapr> ben0x539: Or else.
17:34:38 <ben0x539> shapr: I assumed that I was being relatively civil
17:34:51 <kmc> i don't see why
17:34:52 <shapr> "shoddy" is an emotionally charged word.
17:35:01 <ben0x539> "perl" is an emotionally charged language
17:35:08 <gwern> @quote perl
17:35:08 <lambdabot> mauke says: I'd prefer something hacked up in perl, using regexes
17:35:11 <ben0x539> ruby makes you explicitly use some funny {| | } syntax to make sure your files get closed when you are done with them
17:35:12 <shapr> If perhaps you could explicitly describe what part of the perl memory management you are describing...
17:35:20 <gwern> hm. that's not very funny
17:35:26 <shapr> ben0x539: I don't think you heard me...
17:35:33 <theorbtwo> ben0x539: Not really, no.  It does reference counting.  You leak if you have circular references, and if you make a C extension incorrectly.
17:35:34 <gwern> @forget mauke I'd prefer something hacked up in perl, using regexes
17:35:35 <lambdabot> Done.
17:35:36 <quokka70> I don't think all this language comparison is very constructive
17:35:42 <gwern> @mlish
17:35:42 <lambdabot> Maybe you meant: flush list
17:35:42 <theorbtwo> The first one is easy to fix, and doesn't come up much.
17:35:51 <Raymond> whats the average age in here?
17:35:52 <gwern> @mlusi
17:35:58 <theorbtwo> Almost every language is emotionally charged, to it's advocates.
17:35:58 <gwern> Raymond: 9
17:36:04 <shapr> theorbtwo: truly...
17:36:08 <shapr> and this channel is about Haskell
17:36:12 <gwern> @quote perl
17:36:12 <lambdabot> Tac-Tics says: In fact, @pl is a LB command that turns good Haskell INTO perl
17:36:29 <Raymond> gwern, really?
17:36:37 <theorbtwo> @pl head xs
17:36:37 <lambdabot> head xs
17:36:50 <gwern> Raymond: I was making a sarcastic comment about the silly disscussions and metadiscussions
17:36:51 <theorbtwo> No, not really.
17:37:12 <gwern> Raymond: and also pointing out the vapidity and unverifiable nature of any answer
17:37:34 * gwern thinks any joke which doesn't have at least 2 meanings isn't even bad
17:37:58 <Raymond> gwen, where do you go to college?
17:38:13 <shapr> Oh, I go to college in Alabama!
17:38:14 <theorbtwo> (pl actually converts haskell into "pointless" style, BTW... speaking of two meanings.)
17:38:15 <gwern> Raymond: I'm not in college right now; and it's 'gwern'
17:38:43 <Raymond> what does gwern mean?
17:38:53 <shapr> I think it's his name?
17:38:56 * gwern shrugs. what does any name mean?
17:38:58 * monochrom waits for "a/s/l"
17:39:01 <shapr> Raymond: Where do you go to college?
17:39:04 <Raymond> UCD
17:39:16 <shapr> Are you studying Haskell there?
17:39:26 <Raymond> No i have no idea what haskell is
17:39:32 <shapr> Why are you in this channel?
17:39:35 <trainpic> I'm trying to install the ALSA bindings from cabal
17:39:48 <Raymond> No idea, its the only channel that appealed to me
17:39:48 <trainpic> and it's complaining when I try to build c2hs
17:39:57 <shapr> Raymond: Would you like to learn Haskell?
17:40:02 <trainpic> anyone care to look at the errors?
17:40:03 <Raymond> If i like what it is
17:40:18 <shapr> Raymond: I encourage people to discuss Haskell.
17:40:25 <shapr> Check out http://www.haskell.org/
17:40:29 <shapr> It's way nifty.
17:40:35 <gwern> trainpic: no one is going to pay attention to you wihtout an hpaste
17:40:43 <trainpic> ok...
17:40:51 <erikc> anyone know what the state of COM binding is?
17:41:05 <monochrom> Thank you shapr. I know what to do next time.
17:41:10 <Peaker> what's Ubuntu's package name for Haskell platform?
17:41:19 <shapr> monochrom: hah, assuming I'm at the keyboard :-)
17:41:29 <shapr> monochrom: But yes, feel free to ping me.
17:41:55 <quokka70> Peaker: the package ghc
17:41:57 <theorbtwo> Peaker: Try "ghc" or "ghc6".
17:42:02 <trainpic> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15921#a15921
17:42:05 <gwern> monochrom: we'll have the @napalm installed in lambdabot next time. then we will indeed be able to kill it with fire
17:42:14 <trainpic> error while building c2hs from cabal
17:42:17 <quokka70> Peaker: there is also the package hugs
17:42:19 <Peaker> quokka70: oh, those existed before the platform
17:42:20 <theorbtwo> Haskell is a language, ghc is one implementation of it.
17:42:23 <gwern> @hoogle CLDouble
17:42:24 <lambdabot> Foreign.C.Types data CLDouble
17:42:31 <Peaker> I though the platform had its own packages
17:42:33 <shapr> gwern: haha
17:42:41 <gwern> trainpic: next step, look at the failing file and see how the imports are
17:42:51 <quokka70> Peaker: I am very new to Haskell so I don't know what the platform is
17:43:11 <Peaker> "Haskell platform" on Ubuntu is just the set of ghc6 packages?
17:43:38 <theorbtwo> quokka70: Can you describe what you are looking for without using the term "platform"?
17:44:01 <quokka70> theorbtwo: sorry, I was responding to Peaker's question
17:44:17 <sshc> how do I export an instance of something (perhaps Show (State a b)) in a module?
17:44:19 <theorbtwo> Oh, sorry!
17:44:23 <quokka70> theorbtwo: I answered him incorrectly
17:44:26 <quokka70> no problem!
17:44:43 <Peaker> sshc: all instances are automatically exported, you can't prevent that even if you tried
17:45:00 <quokka70> Peaker: I found this with a quick google search http://sporkcode.wordpress.com/2009/07/11/installing-the-haskell-platform-in-ubuntu/
17:45:01 <Peaker> sshc: and also automatically imported, cannot be prevented
17:45:18 <Peaker> quokka70: heh, you could even use lmgtfy
17:45:24 <quokka70> Peaker: YMMV
17:46:00 <Peaker> ah, need to install it from source
17:46:04 <Peaker> someone ought to make debs
17:46:07 <trainpic> gwern: I'm not really sure what I should be looking for as far as imports
17:46:21 <gwern> trainpic: is it importing Foreign.C.Types at all isa good start
17:46:24 <Cale> http://www.uni-koblenz.de/~laemmel/paradigms0910/ -- has anyone else noticed this course?
17:46:54 <trainpic> gwern: no, just Foreign.C
17:46:56 <Cale> (there are nice lecture videos and slides)
17:47:03 <_andy_> is there a good way to say:
17:47:03 <trainpic> I'd assume that's a problem...
17:47:03 <gwern> trainpic: try adding types then
17:47:11 <trainpic> ok
17:47:19 <_andy_> newtype Thing a = Thing { unThing :: a }
17:47:30 <_andy_> instance Ord a => Ord (Thing a) where ...
17:47:42 <_andy_> instance Bounded a => Bounded (Thing a) where ...
17:47:52 <_andy_> without requiring in the newtype and then deriving?
17:48:05 <_andy_> the best i could do was having a:
17:48:23 <_andy_> class Derived a b | a -> b where derived :: ... derived2 :: ...
17:51:01 <trainpic> gwern: adding Foreign.C.Types didn't do anything
17:51:10 <gwern> really? how peculiar
17:51:36 <gwern> CLDouble is there in my F.C.T
17:52:28 <trainpic> hm...
17:52:59 <trainpic> I just want the ALSA bindings but I need this to build them
17:53:51 <Axman6> i seem to remember hearing that CLDouble didn't exist (anymore)
17:54:01 <gwern> language-c is quite big
17:54:05 <gwern> trainpic: what ghc ver?
17:54:36 <trainpic> ghc 6.12.1
17:55:43 <gwern> ah. I'm on 6.10
17:55:47 <gwern> perhaps something changed in between
17:55:58 <trainpic> hm
17:56:25 <trainpic> so c2hs hasn't been updated for 6.12 I'm guessing
17:56:35 <trainpic> (that would make me out of luck for the alsa bindings...)
17:57:22 <gwern> trainpic: dcoutts last updated the c2hs darcs repo in february
17:57:31 <gwern> trainpic: fixing it would be a yeoman's job indeed
17:57:48 <trainpic> oh dear
17:57:51 <Raymond> Haskell Curry and Moses Schnfinkel are both virgos
17:58:08 <shapr> Raymond: So, do you want to learn Haskell?
17:58:14 <theorbtwo> Are?  I always assumed Haskell Curry was dead...
17:58:28 <gwern> Raymond: virgins must really like haskell
17:58:29 <Raymond> Oh right, he's dead
17:58:35 <gwern> I mean, virgos
17:58:43 <Raymond> lol
17:59:02 <gwern> same bloody word
17:59:07 <gwern> same etymological root I'd bet
17:59:20 <theorbtwo> gwern: Quite certianly.
17:59:34 <shapr> Raymond: What are you studying at UCD?
17:59:40 <Raymond> Economics
17:59:47 <ddarius> heya shapr
18:00:09 <shapr> y0 ddarius! ltns!
18:01:00 <trainpic> gwern: If I try to build the jack bindings, I get an error about missing st.h
18:01:11 <gwern> st.h? not std.h?
18:01:20 <trainpic> yes
18:01:20 <ddarius> shapr: I've been around, though, the past month-ish I was in Japan.
18:01:25 <gwern> (c2hs builds & installs here)
18:01:35 <shapr> Very cool! Lots of coding in Japan?
18:01:59 <trainpic> hm...
18:02:06 <ddarius> shapr: No coding.  Just running around meeting people and eating food and walking up mountains.
18:02:06 <trainpic> maybe I should downgrade my ghc...
18:02:34 <gwern> trainpic: might not be a bad idea. the 10-12 transition seems to be moving much slower than 8-10
18:02:46 <trainpic> hm
18:02:46 <trainpic> ok
18:03:04 <gwern> at least, if you're not willing to update stuff
18:03:13 <trainpic> of course I'm on Arch Linux so downgrading is a massive pain
18:03:15 <trainpic> hm
18:03:30 <trainpic> well I wouldn't have the slightest clue how to work on c2hs...
18:03:31 <shapr> ddarius: Sounds nifty, doing any fun technical stuff lately?
18:04:24 <gwern> trainpic: I doubt it's difficult. probably some tweaking of the cabal, changing some imports
18:04:54 <trainpic> ok
18:04:59 <trainpic> never played with that before
18:05:31 <trainpic> but I could give it a shot
18:06:21 <gwern> christ! how the heck do some latex addons pull in *145* MB of stuff?
18:06:36 <gwern> you could fit multiple OSs into that. I'm not sure emacs takes that much
18:07:36 <Amigoo> what does "|" means?
18:07:48 <Peaker> Amigoo: in "data" declarations?
18:07:49 <shapr> In what context?
18:07:57 <Peaker> Amigoo: or in function definitions?
18:08:04 <Peaker> Amigoo: or in list comprehensions?
18:08:05 <Zao> Amigoo: If in a data declaration, delimits ctors. In a function definition, a guard.
18:08:09 <Amigoo> like Value = Num Int | Jack | Queen
18:08:27 <Peaker> Amigoo: it means that there are multiple possible "constructors" for a type, each of which can have multiple fields inside it
18:08:31 <Cale> Amigoo: it separates the possible cases for the datatype
18:08:51 <tensorpudding> it means that a value of type Value is given by Num a, Jack or Queen
18:08:58 <tensorpudding> for some a :: Int
18:09:03 <Amigoo> o, ok
18:09:08 <tensorpudding> @info Bool
18:09:09 <lambdabot> Bool
18:09:14 <tensorpudding> err
18:09:17 <tensorpudding> @type Bool
18:09:18 <lambdabot> Not in scope: data constructor `Bool'
18:09:19 <Amigoo> but when I try to load, it says parse error "|"
18:09:21 <tensorpudding> bah
18:09:26 <Cale> @src Bool
18:09:26 <lambdabot> data Bool = False | True deriving (Eq, Ord)
18:09:35 <tensorpudding> yeah, the problem is that Num can't be used as a type constructor
18:09:42 <tensorpudding> (i think)
18:09:53 <Cale> Amigoo: you probably forgot the data keyword
18:09:58 <Amigoo> ok
18:10:01 <tensorpudding> oh, yes, that too
18:10:04 <Cale> Amigoo: at least, given that you didn't write it before
18:10:11 <theorbtwo> IIRC, Num is a typeclass, not a type, or a type constructor.
18:10:30 <theorbtwo> @src Num
18:10:31 <lambdabot> class  (Eq a, Show a) => Num a  where
18:10:31 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:10:31 <lambdabot>     negate, abs, signum     :: a -> a
18:10:31 <lambdabot>     fromInteger             :: Integer -> a
18:10:33 <Cale> theorbtwo: right, but in this context it was a data constructor
18:10:45 <tensorpudding> are constructors and classes in different namespaces?
18:10:46 <Amigoo> oh ok, i think i found what's wrong
18:10:58 <Amigoo> thanks
18:10:59 <Cale> types and values live in different namespaces
18:11:30 <theorbtwo> Confusingly, but also conviently, if there's only one constructor for a type, it'll usually have the same name as the type.
18:11:31 <ddarius> shapr: Not really.
18:11:50 <tensorpudding> True and False are constructors for the Bool type
18:11:58 <roooostaj> Cale: doesn't that have to be true... i mean isn't data Val = Val common?
18:12:32 <theorbtwo> roooostaj: Yes, there's a constructor Val and a type Val, that really different thigns, in different namespaces.
18:12:43 <theorbtwo> s/that really/that are really/
18:12:56 <roooostaj> theorbtwo: :)
18:13:18 <tensorpudding> types can be defined recursively too, and a lot of the interesting ones are
18:16:27 <monochrom> «data Val val = Val val» is common and valid. I don't do it to newbies.
18:17:57 * shapr is already confused!
18:18:12 <shapr> At least it's not the Mu and Nu stuff that edwardk used to pull out at lunch.
18:18:46 <ehird> data Val val = Val (val (Val val))
18:18:47 <ehird> Val.
18:18:58 <ehird> data Mu mu = Mu (mu (Mu mu))
18:19:00 <ehird> The cow type.
18:19:06 <tensorpudding> mumu?
18:20:01 <ehird> I really wish you could declare data types in ghci :(
18:20:22 <monochrom> Yes this is why I don't say GHC's REPL is the best.
18:20:35 <tensorpudding> which is the best REPL?
18:20:41 <ehird> tensorpudding: SLIME
18:20:44 <ehird> No competition
18:20:54 <ehird> Calling it a REPL borders on insulting
18:20:59 <Peaker> Python's REPL is nice (interactive docstring formatter/help, all code works in the REPL)
18:21:07 <ehird> But inferior to SLIME. :P
18:21:09 <Peaker> oh wait, you meant Haskell best REPLs :)
18:21:15 <ehird> ah
18:21:20 <ehird> You could do it with a GHCi command, anyway
18:21:25 <ehird> It'd have to append to a file and load it
18:21:27 <monochrom> The best is like the MLs', you can enter a complete module interface and two complete module implementations at the prompt.
18:22:03 <tensorpudding> i dislike repl's that don't have history searching
18:22:43 <ehird> SLIME has interactive documentation lookup of various kinds, absolute integration with the file window, a full integrated debugger, ...
18:24:05 <tensorpudding> SLIME is an IDE masquerading as a repl
18:24:40 <tensorpudding> it'd be nice if it ran something other than lisps though
18:24:46 * ddarius never uses val as a type variable name.
18:24:57 <tensorpudding> i tried getting clojure to work with it once, but that didn't work and i gave up
18:25:11 <ehird> someone did it for clojure
18:25:13 <ehird> and it's been done for scheme
18:25:23 <ehird> someone implement swank in haskell, i dare you :)
18:25:27 <monochrom> «data A a = A a» then. XD
18:25:30 <tensorpudding> but clojure and scheme are lisps
18:25:53 <tensorpudding> clojure has some nice JVM stuff, but it's essentially a lisp
18:26:15 <dmead> hey channel
18:26:25 <dmead> can someone point me to docs about the haskell sql bindings?
18:26:37 <tensorpudding> @hoogle sql
18:26:38 <lambdabot> No results found
18:26:41 <tensorpudding> hmm
18:27:32 <tensorpudding> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database
18:29:05 <dmead> http://en.wikibooks.org/wiki/Haskell/Database
18:29:06 <dmead> yea
18:29:11 <dmead> the docs are decidedly incomplete
18:31:19 <ddarius> This "Synthetic Geometry of Manifolds" is sounding like it will be pretty interesting.
18:35:47 <dino-> How about the RWH chapter on SQL
18:36:18 <dino-> http://book.realworldhaskell.org/read/using-databases.html
18:36:25 <dino-> This is specifically talking HDBC
18:37:57 <dino-> And if this works for you, consider buying the book! It's available in pdf, epub and dead trees.
18:38:51 <gwern> > 103 + 172
18:38:52 <lambdabot>   275
18:39:19 <gwern> > 103 + 244
18:39:20 <lambdabot>   347
18:48:39 <gwern> 270 lines of options and man page, and pdflatex can't have an option 'don't leave all these fsking intermediate files laying around'
18:49:34 <joe1> > let toint xs = (sum . map (\(x,y) -> x*y) . zip (map (2 ^) [0..7]) . fst . splitAt 8 ) xs : (toint . snd . splitAt 8) xs  ; let toint [] = [] ;
18:49:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:51:11 <joe1> toint xs = (sum . map (\(x,y) -> x*y) . zip (map (2 ^) [0..7]) . fst . splitAt 8 ) xs : (toint . snd . splitAt 8) xs
18:51:15 <joe1> > toint xs = (sum . map (\(x,y) -> x*y) . zip (map (2 ^) [0..7]) . fst . splitAt 8 ) xs : (toint . snd . splitAt 8) xs
18:51:16 <lambdabot>   <no location info>: parse error on input `='
18:51:44 <joe1> toint [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0]
18:51:50 <kmc> gwern, pdflatex my_thesis.txt && cat my_thesis.pdf | mail myadvisor@bumblefuck.edu && rm *
18:51:51 <joe1> will give [9,1]
18:52:15 <joe1> wondering if I can write this function better?
18:52:45 <joe1> it takes the first 8 digits (from left to right) and forms an integer.
18:52:51 <PepeSilvia> hey, can anyone recommend a nice charting library? I'm mostly looking for pie charts, but other stuff would be cool too.
18:53:05 <aavogt> > let toint xs = (sum . map (\(x,y) -> x*y) . zip (map (2 ^) [0..7]) . fst . splitAt 8 ) xs : (toint . snd . splitAt 8) xs in xs
18:53:06 <lambdabot>   Not in scope: `xs'
18:53:10 <aavogt> > let toint xs = (sum . map (\(x,y) -> x*y) . zip (map (2 ^) [0..7]) . fst . splitAt 8 ) xs : (toint . snd . splitAt 8) xs in toint
18:53:13 <lambdabot>   mueval-core: Time limit exceeded
18:53:36 <ddarius> joe1: You can combine the map and the zip into a zipWith
18:54:03 <ddarius> joe1: And calling splitAt 8 twice seems silly.
18:54:14 <ddarius> joe1: Either name the intermediate or use take and drop.
18:54:40 <joe1> ddarius: yes, good suggestions.. thanks..
18:55:40 <phr> map (\(x,y) -> x*y)   = uncurry (*)     but why not use listcomps?
18:56:23 <leimy> need a haskell wave bot :-)
18:56:32 <joe1> toint xs = (sum . map (\(x,y) -> x*y) . zip (map (2 ^) [0..7]) . take 8 ) xs : (toint . drop 8) xs
18:57:03 <phr>  map (\(x,y) -> x*y)   = uncurry (*)
18:57:12 <ddarius> phr: - map
18:57:30 <phr> oops too much paste, but yeah
18:57:36 <phr> listcomp might be easier
18:57:38 <ddarius> However, map (uncurry f) (zip xs ys) === zipWith f xs ys
18:57:47 <ddarius> phr: Not really.
18:58:59 <ddarius> joe1: There's also no reason to bound the left argument to zip(With) as it will stop at the shorter, so just zip(With) (iterate (2*) 1)
18:59:04 <ddarius> > iterate (2*) 1
18:59:05 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:59:29 <Axman6> > iterate (`shiftL` 1) 1
18:59:30 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:59:30 <lambdabot>    `Data.Bits.Bits a'
18:59:30 <lambdabot>      a...
18:59:39 <Axman6> > iterate (`shiftL` 1) 1 :: [Integer]
18:59:40 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
19:02:15 <sproingie> @src iterate
19:02:16 <lambdabot> iterate f x =  x : iterate f (f x)
19:02:45 <ddarius> > let toInt xs = sum (zipWith (*) (iterate (2*) 1) start) : toInt rest where (start, rest) = splitAt 8 xs in toInt [1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0]
19:02:46 <lambdabot>   [9,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:02:46 <sproingie> @pl iterate f x =  x : iterate f (f x)
19:02:47 <lambdabot> iterate = fix ((ap (:) .) . ((.) =<<))
19:02:54 <sproingie> oh my
19:03:18 <joe1> toint xs = (sum . zipWith ((*) . (2 ^)) [0..7] ) ( take 8 xs ) : (toint . drop 8) xs
19:03:21 <ddarius> And you need a base case.
19:03:55 <Axman6> :t round
19:03:56 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:04:56 <ddarius> @pl iterate x = x : iterate (f x)
19:04:56 <lambdabot> iterate = fix (ap (:) . (. f))
19:05:33 <sproingie> where's the f?
19:05:45 <ddarius> It's a free variable.
19:06:02 <ddarius> Just like (:) is.
19:06:13 <sproingie> oic
19:08:03 <joe1> toint xs = (sum . zipWith ((*) . (2 ^)) [0..7] . take 8 ) xs : (toint . drop 8) xs
19:10:02 <phr> that can't be right
19:10:10 <phr> (*) and (2^) don't compose
19:11:11 <kmc> sure they do
19:11:15 <kmc> :t (*) . (2^)
19:11:16 <lambdabot> forall a b. (Num a, Integral b) => b -> a -> a
19:11:25 <Chaze> will this be lazy, or go through all my list?  foldl1 (&&) [Bool]
19:11:25 <kmc> :t (:) . succ
19:11:26 <lambdabot> forall a. (Enum a) => a -> [a] -> [a]
19:11:38 <phr> hmm
19:11:57 <phr> ((*) . (2^)) 2 3
19:12:02 <phr> > ((*) . (2^)) 2 3
19:12:03 <lambdabot>   12
19:12:05 <phr> right
19:12:16 <aluink_> i've looked on google but can't seem to find anything good, does anyone here know of a good haskell library for working with email content?
19:12:41 <phr> (a->a->a) . (b->b) = (b->a->a)
19:12:42 <aluink_> just the email itself, i'm not talking about SMTP, POP, IMAP, etc.  Just the email
19:12:54 <theorbtwo> You mean MIME?
19:13:20 <sproingie> hsemail perhaps?
19:13:42 <twb> cabal-install tells me: "Below is the list of packages that it would have tried to upgrade. You can use the 'install' command to install the ones you want. Note that it is generally not recommended to upgrade core packages."
19:13:49 <sproingie> eh hsemail is way low level
19:13:52 <twb> Is there an easy way to know which packages are "core" packages?
19:13:53 <aluink_> i'm learning about what all these terms mean, can you quickly explain what you mean with MIME?
19:14:04 <twb> Currently I've just been assuming anything installed --global is "core"
19:14:41 <sproingie> pretty hard to work with email if you don't know anything about MIME.  i guess you could read the RFC's
19:15:41 <sproingie> mime is not hugely full featured but does have a message parser
19:16:01 <sproingie> @hackage mime
19:16:02 <lambdabot> http://hackage.haskell.org/package/mime
19:16:13 <aluink_> sproingie: yeah, i'm reading RFCs
19:16:46 <aluink_> sproingie: i know i at least have to do that, but i want to see if there's anything out there before i reinvent the wheel
19:16:51 <sproingie> technically MIME is called "Internet Types" now, but everyone just calls it MIME
19:17:12 <theorbtwo> Huh.  I've *never* heard anybody call it that.
19:17:18 <sproingie> well the encoding/encapsulation never got any different names
19:17:18 * aluink_ goes to read up on MIME on wp
19:17:30 <sproingie> stuff like application/x-foo is an "internet type"
19:17:53 <sproingie> but no one really calls it that
19:17:57 <aluink_> is that why we see stuff like mime-type in html and friends?
19:17:59 <twb> sproingie: the RFCs don't mention that phrase
19:18:16 <Saizan_> twb: with a recent ghc that's pretty accurate, since they've stripped down the distribution quite a lot, a notable exception is Cabal
19:19:05 <sproingie> it's just the type registry and character encodings that take the term
19:19:27 <sproingie> sorry "internet media type"
19:19:37 <joe1> > testBit (9::Data.Bits.Bits) 0
19:19:37 <lambdabot>   Class `Data.Bits.Bits' used as a type
19:19:47 <sproingie> i knew i missing a word somewhere
19:20:17 <joe1> > testBit (9::Data.Bits.Bits) 0
19:20:18 <lambdabot>   Class `Data.Bits.Bits' used as a type
19:20:24 <joe1> > :t testBit
19:20:25 <lambdabot>   <no location info>: parse error on input `:'
19:20:33 <joe1> @hoogle testBit
19:20:33 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
19:20:46 <joe1> > testBit (9::Bits) 0
19:20:47 <lambdabot>   Class `Data.Bits.Bits' used as a type
19:21:08 <joe1> any suggestions on how I can use testBit?
19:21:23 <twb> Should there be a haskell-platform metapackage that I can cabal-install?
19:21:24 <Saizan_> ?type testBit
19:21:25 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
19:21:44 <Saizan_> > testBit (9::Word) 0
19:21:45 <lambdabot>   True
19:21:51 <Saizan_> > testBit (8::Word) 0
19:21:52 <lambdabot>   False
19:22:08 <joe1> > testBit (9::Int) 0
19:22:09 <lambdabot>   True
19:22:20 <joe1> Saizan_: thanks.. sorry for the bother..
19:22:26 <Saizan_> np
19:23:24 <Axman6> in C++, what does boolean foo(int &id){...} mean about what id is?
19:23:35 <Axman6> s/boolean/bool
19:23:39 <FauxFaux> Reference.
19:23:54 <Axman6> so what would id = x; do?
19:23:55 <FauxFaux> But, if you don't know that, you really don't want to try reading c+++.
19:24:08 <theorbtwo> You pass foo an integer, and it silently takes a pointer to it, IIRC.
19:24:16 <Axman6> ah, i see
19:24:44 <Axman6> so, it'd be like using int *id in C, ant not having to dereference it to assign to it?
19:25:03 <theorbtwo> I think so.
19:25:10 <theorbtwo> You might ask ##c++
19:25:21 <FauxFaux> Close enough.
19:25:39 <Axman6> well, i thinkt hat's enough to let me turn this into haskell :)
19:26:04 <kmc> Axman6, yes.  it means that id is an alias for another int somewhere else
19:26:31 * Axman6 vomits a little bit and gets back to work
19:26:54 <aluink_> you might think of references in C++ like hardlinks
19:27:03 <kmc> meh, it's not so bad
19:27:07 <kmc> it's how objects work in most languages
19:27:19 <kmc> the bad part about them in C++ is that they're not really first-class, and there are *other* ways to pass objects
19:27:26 <kmc> they duplicate a lot of the functionality of pointers
19:27:32 <FauxFaux> Mmm, it's not really how passing works in anything.  Does anything have parameter assignment working like that?
19:27:47 <FauxFaux> Well, apart from things with explicit pointers, and c# with identical syntax for outparameters.
19:27:48 <aluink_> except that they don't do everything a pointer can do
19:28:07 <ehird> @hoogle Int->a->String
19:28:07 <lambdabot> Prelude replicate :: Int -> a -> [a]
19:28:07 <lambdabot> Data.List replicate :: Int -> a -> [a]
19:28:07 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
19:28:08 * FauxFaux knows c++ rather well, btw.
19:28:10 <aluink_> you can upcast for inherited structures
19:28:12 <kmc> part of the non first classness is that you can't assign to a ref
19:28:14 <ehird> @hoogle (Num a)=>Int->a->String
19:28:14 <lambdabot> Prelude replicate :: Int -> a -> [a]
19:28:14 <lambdabot> Data.List replicate :: Int -> a -> [a]
19:28:14 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
19:28:20 <ehird> meh.
19:28:30 <ehird> (looking for numberInBase)
19:28:52 <kmc> if you have "Foo& r = ...; r = x;", the second '=' invokes the overloaded operator= on Foo
19:29:07 <sproingie> refs basically act like aliases
19:29:39 <theorbtwo> numberInBase supports non-integer bases?
19:29:43 <theorbtwo> :t numberInBase
19:29:44 <lambdabot> Not in scope: `numberInBase'
19:29:47 <sproingie> i try to treat them as immutable.  doing that for real in C++ involves peppering 'const' all over
19:30:07 <sproingie> const foo const * const ( const int const * const = ...
19:34:17 <shapr> @help
19:34:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:37:46 <mental> @halp
19:37:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:38:48 <Axman6> double p = f.x>f.y && f.x>f.z ? f.x : f.y>f.z ? f.y : f.z; // max refl  <-- C++ made small is so annoying to read >_<
19:41:57 <Axman6> fark, that's just max and max >_<
19:56:59 <Olathe> max and max is also more efficient for f.z > f.x > f.y, I think.
19:57:36 <twb> Is max a built-in now?
19:57:46 <Axman6> in what, haskell?
19:57:54 <twb> Oh, sorry, I was thinking this was C
19:58:00 <twb> I didn't look at the channel name
19:58:13 <Olathe> No, in C.
19:58:21 <Olathe> to Axman6
19:58:28 <shapr> g'day twb
19:58:47 <twb> Last time I looked at C, you normally #define MAX(a,b) ((a) > (b) ? (a) : (b)) or so.
19:58:58 <twb> shapr: hi
19:59:11 <idnar> I don't see how min and max can be more /efficient/
19:59:16 <idnar> maybe more concise
19:59:25 <twb> idnar: by assuming the incoming values are fixnums? :-)
19:59:27 <Olathe> Oh, I mean more efficient than the hand-written code above.
19:59:42 <theorbtwo> concision is often programmer-time efficency.
20:00:14 <idnar> Olathe: I would expect min and max to result in the same come
20:00:15 <idnar> *code
20:00:18 <Olathe> If f.x > f.y but f.x <= f.z, then you don't need to check f.y > f.z, because it can't be.
20:00:26 <Olathe> So, there's an extra comparison for that case.
20:01:01 <Olathe> double p = f.x>f.y ? (f.x>f.z ? f.x : f.z) : (f.y>f.z ? f.y : f.z) is better
20:01:11 <idnar> the compiler should optimise that away
20:01:20 <Olathe> Ahh :)
20:01:30 <idnar> but, gah, let's not discuss C++ any more than we have to :(
20:01:35 <Olathe> Good idea :)
20:02:03 <theorbtwo> ##c is over there.  -->
20:02:04 <Axman6> man, i want to go and get lunch, but this album';s too good to leave
20:02:04 <lunabot>  luna: parse error on input `-->|'
20:02:05 <idnar> Axman6: we feel your pain, but we don't /want/ to feel it ;P
20:02:09 <Axman6> i'll have to turn it very loud
20:02:18 <Axman6> idnar: heh :)
20:21:27 <kmc> Axman6, what album?
20:22:26 <Axman6> Mumford & sons - Sign No More
20:22:32 <Axman6> Sigh*
20:23:25 <tensorpu`> muzik!
20:27:48 <Axman6> the song Sigh No More is fantastic once you get past the into
20:28:00 <Axman6> (still a good intro, but get great after that)
20:30:40 <monochrom> Sing No More would be a great album.
20:30:54 <blackh> Favourite bit of Haskell recently... map (arr !) (range boxRange).  This looks up a specified sub-range of an array called arr, but I quite like the piracy on the high seas implied by arr !
20:32:47 <tensorpu`> arr!
20:38:12 <sproingie> harrskull
20:38:19 <Axman6> wtf does n*-1 mean in C++? >_<
20:38:31 <Axman6> oh, times minus 1
20:39:15 <c_wraith> let x *- y = x * y + 3 in 4 *- 8
20:39:20 <c_wraith> > let x *- y = x * y + 3 in 4 *- 8
20:39:21 <lambdabot>   35
20:41:16 <monochrom> haskell is so much fun
20:43:44 <Axman6> > text "s\o\h\u\m"
20:43:45 <lambdabot>   <no location info>:
20:43:46 <lambdabot>      lexical error in string/character literal at chara...
20:43:57 <felzix> How do I make a new StorableArray? It has an instance called Storable but I don't seem to be able to use it like a data constructor.
20:44:35 <kmc> you use newArray
20:44:38 <kmc> from Data.Array.MArray
20:45:01 <kmc> a member of the MArray typeclass
20:46:22 <felzix> newArray complains about StorableArray not being a data constructor, too
20:46:39 <kmc> well, it's not
20:46:43 <kmc> at least not an exported one
20:47:12 <kmc> do a <- newArray (1, 10) 'z'
20:47:14 <pastah_rhymez> @hoogle sumBy
20:47:15 <lambdabot> No results found
20:47:20 <kmc> you'll need something to fix the type of a
20:47:20 <kmc> e.g.
20:47:27 <Axman6> s\o\h\u\m: what're you doing at uni?
20:47:38 <kmc> do a <- newArray (1, 10) 'z' :: StorableArray Int Char
20:47:43 <kmc> err
20:47:55 <s\o\h\u\m> Axman6: trying to figure out where this ghost is from
20:48:00 <kmc> do a <- newArray (1, 10) 'z' :: IO (StorableArray Int Char)
20:48:01 <Axman6> heh
20:48:55 <jaredj> > let x = 5 in x + 3
20:48:56 <lambdabot>   8
20:49:07 <jaredj> is there a way to do that with the type system?
20:49:12 <felzix> kmc: ah, it stopped complaining about types. I'll see if this works, now. thanks!
20:49:22 <jaredj> eg > let x :: Foo in :t Bla x
20:49:22 <kmc> jaredj, a way to add numbers in the type system?
20:49:22 <Saizan_> jaredj: that being?
20:49:58 <jaredj> nono, a way to get a type of an expression given that part of the expr is of a given type
20:50:21 <kmc> data Z; data S a; type family Add a b; type instance Add Z b = Z; type instance Add (S a) b = S (Add a b)
20:50:27 <Saizan_> jaredj: you can do :t Bla (undefined :: Foo)
20:50:45 <jaredj> ah? i think that's what i'm after
20:50:51 <Saizan_> jaredj: or :t let x :: Foo; x = undefined in Bla x
20:51:32 <Saizan_> with ImplicitParams turned on you can do:
20:51:37 <Saizan_> ?type id ?x
20:51:38 <lambdabot> forall a. (?x::a) => a
20:51:46 <monochrom> :t Just (5 :: Int)
20:51:47 <lambdabot> Maybe Int
20:52:00 <Saizan_> ?type id (?x :: Int)
20:52:01 <lambdabot> (?x::Int) => Int
20:52:13 <jaredj> i had a question you see, but then i realized if i could get the types right, the question would answer itself
20:52:27 <jeffwheeler> So, I've been inspired to try to represent recipes as a sort of tree/graph, where the nodes are physical item (leaves being the original ingredients, other nodes being intermediary items). Edges are instructions/functions that take certain nodes and lead to items composed of those nodes.
20:52:36 <jeffwheeler> I'm trying to think of the best way to represent this, though
20:53:08 <jeffwheeler> I was partly inspired by this blog post: http://blog.moertel.com/articles/2010/01/08/a-formal-language-for-recipes-brain-dump, but also the graphs used on Cooking for Engineers, after the last pictures (e.g. http://www.cookingforengineers.com/recipe/274/Hatch-Chile-Infused-Chocolate-Truffles)
20:53:21 <jeffwheeler> I think those tables are brilliant.
20:53:25 <sproingie> jeffwheeler: sounds like an AST to me
20:55:00 <jaredj> jeffwheeler: the first looks a bit like makefile syntax
20:55:29 <tensorpu`> make dessert clean
20:56:40 <jeffwheeler> sproingie: I suppose it does, somewhat
20:56:40 <jeffwheeler> sproingie: not an AST of the description language, but of the process or something
20:56:49 <jeffwheeler> The structure is essentially a tree, but I'm not really sure what the difference between a tree and a graph is, at that point. I care about the edges (trees don't usually), but it usually comes to a point
20:56:57 <sproingie> there are a number of recipe formats out there already, MealMaster being one of them
20:57:06 <jeffwheeler> jaredj: it does, and somebody mentioned that in the comments; it reminded me of YAML
20:57:34 <jeffwheeler> sproingie: yeah, I read this: http://microformats.org/wiki/recipe-formats, but none of them seemed particularly clever
20:57:36 <jaredj> ah yes, that's true too. - data Recipe = Ingredient String | Product Action [Recipe]
20:57:44 <sproingie> mealmaster is probably the most common
20:57:46 <theorbtwo> Could do with parameterization.
20:58:05 <sproingie> well *most* common is plain text of course
20:58:21 <theorbtwo> Also, "1 pie_tin, 9 inch, chilled" shouldn't be an input, you want "1 pie_tin, 9 inch", and then "chill pie_tin".
20:58:29 <jaredj> agree
20:58:42 <felzix> how do I create an instance of this? data Word8 = W8# Word# deriving (Eq, Ord)
20:58:44 <jeffwheeler> I'm not so worried with the specification format yet; I'd more like to generate graphs like those on Cooking for Engineers
20:58:48 <sproingie> http://www.wedesoft.demon.co.uk/anymeal-api/mealmaster.html
20:58:57 <jaredj> Product Chill [Ingredient "pie tin 9 inch"]
20:59:11 <sproingie> that's what mealmaster looks like.  it's designed to be human readable
20:59:16 <jaredj> (Action would be an awfully large enum type though)
20:59:20 * jeffwheeler looks
20:59:46 * jaredj hates the word 'meal'
20:59:58 <sproingie> you'll have a *hell* of a time formally encoding cooking instructions
21:00:08 <c_wraith> > cake !! 17
21:00:09 <lambdabot>   "One cup lemon juice."
21:00:17 <sproingie> > cake !! 30
21:00:18 <lambdabot>   "Three tablespoons rhubarb, on fire."
21:00:20 <jeffwheeler> Here's an example of MealMaster: http://www.garvick.com/recipes-ms/app01101.htm
21:00:28 <theorbtwo> All depends on how formal you want to be.
21:00:32 <c_wraith> > last cake
21:00:32 <lambdabot>   "That will deodorize and preserve putrid tissue."
21:00:33 <jeffwheeler> Not particularly clever.
21:00:43 <jeffwheeler> (I mean, the MealMaster syntax isn't.)
21:00:49 <sproingie> that's a valid mealmaster recipe but not a good one
21:00:58 <sproingie> the paragraphs should be broken out
21:01:12 <jaredj> '> go north'
21:01:13 <jeffwheeler> Oh, I found it through the MealMaster site; I was just looking for a syntax
21:01:18 <jeffwheeler> err, example of the syntax
21:01:30 <sproingie> if you're looking for something that a restaurant chain could use you'll probably need product codes like SKUs
21:01:36 <jaredj> 'You enter a maze of Three tablespoons rhubarb, on fire. You can see One cup lemon juice.'
21:01:48 <c_wraith> > cake 23
21:01:49 <lambdabot>   Couldn't match expected type `t1 -> t'
21:01:49 <lambdabot>         against inferred type `[[GHC...
21:01:53 <c_wraith> > cake !! 23
21:01:54 <lambdabot>   "Twelve medium geosynthetic membranes."
21:01:57 <jeffwheeler> sproingie: not really looking for that; this is mostly for the fun of it :)
21:01:59 <tensorpu`> making a recipe using Inform 7 would be fun
21:02:18 <sproingie> i started a mealmaster parser in python a while back.  lost interest quick.
21:02:19 <theorbtwo> jeffwheeler: I think you can have a better syntax for your actions.  In particular, most of them aren't very clear, from a progmatic point of view, what the inputs and outputs are.
21:02:26 <jaredj> c_wraith: wth kind of cake is that
21:02:30 <Olathe> > cake
21:02:32 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
21:02:38 <c_wraith> jaredj: the portal kind
21:02:41 <Olathe> Haha
21:02:41 <Runar> the cake on the table is the thing which is on the table. It is on the table.
21:02:46 <sproingie> jaredj: GLADDOS's special recipe
21:03:05 <theorbtwo> I think you want, by default, most steps to have a single input of the last listed actions' output, and a single, unnamed output.
21:03:06 <jeffwheeler> I like representing actions as edges between nodes
21:03:08 <jaredj> man. there have been so many portal cake jokes this month and i never played portal :(
21:03:17 <tensorpu`> a cake is a kind of thing. It is usually chocolate
21:03:17 <tehgeekmeister> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15924#a15924 <== really really really wonky linking error trying to compile the happstack blog tutorial
21:03:17 <sproingie> Runar: as cool as i think inform is, that description language is not my favorite
21:03:30 <tehgeekmeister> from http://softwaresimply.blogspot.com/2009/04/basic-happstack-blog-app.html
21:03:33 <theorbtwo> jaredj: You should fix that.
21:03:37 <tensorpu`> ah, but you first need
21:03:40 <tensorpu`> Cake is a room
21:04:11 <Saizan_> jeffwheeler: it seems what you want to do is a call graph
21:04:16 <theorbtwo> jeffwheeler: I like the idea too, but if you want to get graphs from that description, it needs to be somewhat more clear, especially in the combine step.
21:04:41 <jeffwheeler> Saizan_: hmm, I don't think I've ever heard of that
21:04:52 <theorbtwo> One thing I've always wanted is a good search engine for recipies.
21:05:02 <sproingie> personally i think some kind of domain-specific wikitext would be ideal for recipes
21:05:30 <jeffwheeler> Saizan_: after some Googling, it looks like that makes a lot of sense
21:05:33 <theorbtwo> I have some dried apricots, what should I make?  ...no, I don't have any peaches, remove all recpies that need them.
21:05:53 <Runar> What you want is a cake monad.
21:05:56 <theorbtwo> BTW, note that recipies aren't copyrightable, at least in the US.
21:06:01 <jeffwheeler> theorbtwo: agreed; I'd like to search based on my ingredients, too
21:06:09 <sproingie> recipe db's do that pretty well
21:06:31 <Runar> (you can't actually get cake, but you can bind across actions that receive cake)
21:06:32 <jeffwheeler> theorbtwo: sometimes in Google I just do "whatever -ingredent" to subtract ingredients I don't have. Works pretty well.
21:06:42 <jaredj> theorbtwo: "matches, string, two halves of coconuts" [SEARCH] -> "Laser Beam Braised With Inertial Guidance Sauce"
21:07:09 <theorbtwo> jaredj: Now that sounds *very* GLADOS.
21:07:21 <jaredj> oho
21:07:57 <c_wraith> > filter ("laser" `isInfixOf`) cake
21:07:58 <lambdabot>   []
21:08:04 <c_wraith> > filter ("Laser" `isInfixOf`) cake
21:08:06 <lambdabot>   []
21:08:06 <jaredj> :t cake
21:08:07 <lambdabot> [[Char]]
21:08:14 <sshc> how do I test if a file exists?
21:08:23 <c_wraith> sshc:  Look at System.Directory
21:08:31 <c_wraith> It should have a function for that
21:08:33 <theorbtwo> > filter ("fish" `isInfixOf`) cake
21:08:35 <lambdabot>   ["Candy coated peanut butter pieces. Shaped like fish."]
21:09:00 <sshc> c_wraith: yes, doesFunctionExist, thaks
21:09:27 <c_wraith> > filter ("acid" `isInfixOf`) cake
21:09:28 <tehgeekmeister> anyone got an idea about that linking error?  i suspect it's a gcc problem, but i don't know where to start with figuring it out.  =/
21:09:28 <lambdabot>   []
21:09:31 <fata_erro> hello how do i find out which function an exception is being thrown in?
21:10:20 <fata_erro> *** Exception: Map.find: element not in the map
21:10:36 <fata_erro> completelly useless
21:10:50 <c_wraith> fata_erro: functions aren't really evaluated like that in haskell.
21:11:09 <fata_erro> i'm using find in like 20 places
21:11:18 <Axman6> fata_erro: where are you uisng find?
21:11:19 <Saizan_> tehgeekmeister: maybe you want to -fforce-recomp or clean the .hi files first?
21:11:25 <Axman6> :t Map.find
21:11:27 <lambdabot> Couldn't find qualified module.
21:11:30 <Axman6> :t M.find
21:11:32 <lambdabot> Couldn't find qualified module.
21:11:34 <tehgeekmeister> fata_erro: look for one that you're using without being sure that element exists in the map
21:11:35 <jaredj> :t Data.p.find
21:11:36 <lambdabot> Couldn't find qualified module.
21:11:37 <Axman6> :t Data.Map.find
21:11:38 <jaredj> doh!
21:11:39 <lambdabot> Not in scope: `Data.Map.find'
21:11:47 <tehgeekmeister> Saizan_: it turns out i needed to use --make
21:11:48 <Axman6> :t fromList
21:11:49 <c_wraith> @hoogle find
21:11:49 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
21:11:49 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
21:11:49 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
21:11:50 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
21:11:59 <Axman6> :t fromList
21:12:00 <Saizan_> tehgeekmeister: hah
21:12:01 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
21:12:05 <fata_erro> Data.Map
21:12:09 <tehgeekmeister> Saizan_: simple stuff will always get you.
21:12:21 <Saizan_> heh, yeah :)
21:12:22 <sproingie> it can't enforce show on the index, so the error can't tell you which key
21:12:25 <Saizan_> use cabal :P
21:12:32 <tehgeekmeister> i should learn it someday.
21:12:32 <tehgeekmeister> =
21:12:34 <fata_erro> thing is there should not be a missing element
21:12:35 <tehgeekmeister> =P
21:12:47 <sproingie> but oh, asking for something else.  backtrace in haskell, very very tricky notion
21:12:50 <tehgeekmeister> fata_erro: then you didn't write the code you wanted to.
21:12:55 <sproingie> to say haskell inlines is an understatement
21:12:56 <Axman6> fata_erro: time to find out what's gone wrong
21:13:02 <sproingie> you can trace it in ghci
21:13:02 <fata_erro> how
21:13:18 <Axman6> you tell me, it's not my app :)
21:13:26 <tehgeekmeister> now i just have to figure out all the things that are left out of this tutorial.  like how to run the blog, etc.  happstack needs better docs.
21:13:27 <Axman6> i don't know what you're doing
21:13:34 <sproingie> as for how to use ghci's debugging, that's something i don't actually know myself
21:13:40 <Axman6> tehgeekmeister: yes indeed
21:13:40 <sproingie> i'm still learning debugging and profiling
21:14:03 <Axman6> most ghci debugging is just running functions with various inputs
21:14:07 * sproingie profiles the heap with task manager and looking at the resident memory size
21:14:33 <tehgeekmeister> i would try breaking your program down to small, very well defined functions
21:14:46 <tehgeekmeister> fata_erro: and then testing them very well using quickcheck
21:14:55 <jaredj> fata_erro: there's a :trace command in ghci. i used it once and it bent my brain, because i'd forgotten that haskell's a lazy language
21:15:04 <monochrom> fata_erro: something like http://www.haskell.org/ghc/docs/6.10.4/html/users_guide/ghci-debugger.html
21:15:10 <tehgeekmeister> and add type signatures to everything.
21:16:18 <theorbtwo> You can't use typechecking to tell you if your map has a key in it, though.
21:16:26 <theorbtwo> Or, rather, to enforce that it does.
21:16:28 <theorbtwo> (Can you?)
21:16:43 <Axman6> unless you're super clever
21:16:55 <sproingie> if your set of keys is known at compile time you can
21:17:08 <sproingie> whether you would actually want to, different story
21:18:24 <Saizan_> extensible records would be nice, yeah
21:18:46 <fata_erro> grrrr
21:18:49 <sproingie> lots of things would be nice for records
21:19:02 <fata_erro> i just set a bp on every function
21:19:11 <fata_erro> and nothing wtf
21:19:32 <sproingie> how are you running it?
21:19:39 <Axman6> have you read the debugging docs?
21:21:37 <fata_erro> yes
21:22:03 <fata_erro> ghc just has a shitty debugger
21:22:27 <Axman6> well, that's probably because most people don't use it
21:23:15 <tehgeekmeister> anyone on here know if there's an active haskell related meetup in seattle?
21:24:07 <tehgeekmeister> (yes, i've googled.  i know of seafunc, but the website doesn't seem to be updated regularly.)
21:25:03 <c_wraith> http://www.haskell.org/pipermail/haskell-cafe/2008-February/038991.html <-- does that still exist?
21:25:42 <jaredj> do { ...; eithers <- ask; let (lefts, rights) = partitionEithers eithers; ... }
21:25:54 <tehgeekmeister> i never heard of anything after that.  it may?
21:25:55 <jaredj> i don't care about eithers
21:26:01 <jaredj> how can i elide it?
21:26:23 <Axman6> eh?
21:26:29 <fata_erro> Axman6: i think your right
21:26:48 <idnar> (lefts, rights) <- partitionEithers <$> ask
21:26:58 <c_wraith> do { ... ; (lefts, rights) <- asks partitionEithers; }
21:26:59 <jaredj> aha!
21:27:07 <c_wraith> assuming it's the reader monad, anyway
21:27:10 <idnar> ah, I didn't know about asks
21:27:11 <idnar> @type asks
21:27:12 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
21:27:13 <c_wraith> asks is a good function to know about
21:27:13 <fata_erro> if you can'tfind a bug what good is tha language
21:27:15 <idnar> @type ask
21:27:16 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
21:27:18 <jaredj> i didn't know about <$>
21:27:25 <idnar> <$> is just fmap btw
21:27:30 <idnar> @src asks
21:27:31 <lambdabot> asks f = do
21:27:31 <lambdabot>     r <- ask
21:27:31 <lambdabot>     return (f r)
21:27:50 <c_wraith> asks isn'ta mind-blowing function, but it can be helpful
21:28:00 <sproingie> fata_erro: a poor craftsman blames his tools
21:28:04 <idnar> apparently asks is (<$> ask)
21:28:07 <jaredj> c_wraith: indeed a cool function. unfortunately i just picked reader because it was a simple monad; i'm actually in parsec
21:28:18 <c_wraith> jaredj: then fmap is the easy answer.
21:28:38 <sproingie> although i'll admit that haskell could really do with a clicky debugger
21:28:58 <c_wraith> I want a haskell debugger that actually shows the execution as graph reduction.
21:29:12 <sproingie> whatever, as long as it's clicky
21:29:14 <c_wraith> with pretty pictures. :)
21:29:14 <theorbtwo> I think beyond that it could do with better error messages.
21:29:33 <sproingie> hugs has some nice error messages
21:29:38 <jaredj> that's the tricky thing eh, thunks /= call frames
21:29:59 <theorbtwo> For example, while Data.Map might not be able to force it's keys to have Show, couldn't it use it if they did?
21:30:36 <sproingie> i don't see any way of detecting that at runtime
21:30:38 <theorbtwo> Telling us what function we are in, and what the parameters were would be helpful, even if it can't show full names for all of them.
21:31:04 <theorbtwo> ...and yes, thunks aren't the same as call frames, but either is better then neither.
21:31:06 <sproingie> if you overloaded the error handling between show and non-show ... well that would be the kind of overloading haskell doesn't have
21:31:11 <c_wraith> theorbtwo: that's *really* hard when laziness moves your function up to the top level, skipping all the intermediate levels.
21:31:39 <h-cell_> Does anyone know where I can find an algrithm for solving a system of linear equations ?
21:32:52 <sproingie> linear algebra solution would be easiest to port to haskell i imagine
21:33:05 <fata_erro> sproingie: nobody can write
21:33:19 <fata_erro> correct code first time
21:33:39 <jaredj> wasn't there a BLAS binding to haskell or something?
21:33:49 <c_wraith> fata_erro: I've never wanted an interactive debugger for haskell.  And I've worked on some decently-sized systems.
21:33:53 <Saizan_> hmatrix?
21:34:12 <sproingie> i've wanted an interactive debugger, but i get along just fine without
21:34:26 <tehgeekmeister> fata_erro: i already told you how to find the bug.  i guarantee you it'll work.  a different approach is just more fruitful in haskell.
21:34:31 <fata_erro> c_wraith: some things are easier to code then others
21:34:37 <sproingie> because i too have wanted a backtrace feature, even if i have to drop to ghci to use it
21:34:41 <kmc> ghci has an interactive debugger
21:34:48 <c_wraith> fata_erro: I'm betting openid is harder than what you're doing.  :)
21:34:49 <theorbtwo> You can't do print debugging easily either...
21:34:49 <sproingie> in fact it's probably there i just havent bothered to learn it
21:34:55 <kmc> but we have ways to debug other than the debugger
21:35:01 <theorbtwo> (Can you?)
21:35:02 <fata_erro> c_wraith: nah
21:35:05 <tehgeekmeister> fata_erro: make small, appropriately type-signed functions.  test them to death with quickcheck.  combine them in simple ways.  you should be fine.
21:35:07 <monochrom> I am not sure fata_erro is really looking for a debate. Seems more like just venting some emotion.
21:35:08 <jaredj> VE HAFF VAYS
21:35:09 <kmc> theorbtwo, look at Debug.Trace
21:35:23 <tehgeekmeister> monochrom: good point.
21:35:25 <kmc> the usual caveat -- you don't get a printout until the value is evaluated
21:35:37 <kmc> that means you don't get a printout until the code is run, which doesn't sound so unreasonable
21:35:44 <fata_erro> monochrom: maybe your correct
21:35:49 <fata_erro> :)
21:35:57 <kmc> i think the main debugging tactic in Haskell is to write your code as small self contained functions and poke them interactively
21:35:59 <monochrom> My perspective is I have given my advice to my best knowledge, and if the recipient says it doesn't work, end of story.
21:36:08 <kmc> if (f . g) is buggy, then see if f is buggy and if g is buggy
21:36:32 <kmc> there's also QuickCheck and friends, which will find counterexamples for you
21:36:38 <Saizan_> kmc: and (.)
21:36:44 <sproingie> it's possible for neither to be buggy but your assumption about  f . g working may be the problem
21:36:55 <c_wraith> :t (.) . (.)
21:36:56 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:37:09 <sproingie> heck i had good old fashioned off-by-one errors in the code i'm working on now
21:37:30 <c_wraith> sproingie: that's pretty impressive.  I've yet to manage that in haskell. :)
21:37:38 <sproingie> c_wraith: use arrays and you will :)
21:38:01 <c_wraith> I've only used arrays once.  I was careful that once. :)
21:38:08 <sproingie> those off-by-ones were a result of me moving my grid from 1-based to 0-based and forgetting to update a certain function
21:38:25 <sproingie> then i got another off-by-one that just affected the rendering
21:39:04 <sproingie> bugs that crash the program are easy, you can't help but notice them
21:39:18 <sproingie> when you find your output is shifted over by a cell, that's subtle
21:39:24 <kmc> yes, it may be that f and g disagree on what the intermediate value means
21:39:30 <kmc> part of the point of types is to limit such disagreements
21:39:57 <sproingie> or f.g was inappropriate in the first place.  tho i'm hard-pressed to think of an example that isn't a type error
21:40:28 <c_wraith> My one use of arrays was the typical: "I want an O(n) shuffle algorithm...  and one that returned g' at the end would be nice, too".  Given *how* often people end up writing that, I feel like maybe there should be a better shuffle in the std libs
21:40:31 * sproingie has his emacs environment with flymake working on windows now.  full speed ahead.
21:40:37 <kmc> i do not mean only literally (.), but more generally, if function h breaks, see if the functions f,g it uses break
21:41:06 <sproingie> i'm finding that doing opengl learning projects on linux basically sucks.  really bad.
21:41:16 <kmc> it sucks a lot harder on Windows
21:41:22 <kmc> building OpenGL programs on Windows is a pain
21:41:37 <kmc> especially cross-platform ones using gcc to build
21:41:41 <sproingie> i wedge the graphics driver on windows, i can kill the task and everything is back to normal
21:41:48 <sproingie> i do it on linux, i'm reaching for the power button
21:42:01 <kmc> what are you doing that can wedge the graphics driver?
21:42:21 <kmc> sounds like the driver itself is buggy; OpenGL won't let you crash the machine under normal circumstances
21:42:35 <sproingie> infinite loops in a display callback are one good way
21:42:49 <sproingie> technically it's not wedging the driver.  tell linux that.
21:42:55 <theorbtwo> sproingie: Try control-alt-backspace.
21:42:57 <kmc> err, you can't kill the process when it does that?
21:43:01 <sproingie> nope
21:43:06 <kmc> or log in from another VT or from another machine
21:43:12 <theorbtwo> Er, hold on a sec, you might have to enable that specificly.
21:43:43 <sproingie> the quality of the nvidia and ati drivers both precludes the notion of actually switching video modes while it's in the middle of freaking out
21:44:11 <theorbtwo> In /etc/X11/xorg.conf, write Section "ServerFlags"\n Option "DontZap" "off"\n EndSection.
21:44:16 <sproingie> plus i'm finding compiz is an unstable piece of garbage
21:44:18 <theorbtwo> (The quotes are literal, the \ns aren't.)
21:44:48 <theorbtwo> sproingie: ...and when you think you've found a bug in your graphics driver, it may well be because you have, don't hesitate to make bug reports, they are the only way things get better.
21:44:49 <sproingie> my ideal GL dev environment would be a mac
21:45:19 <sproingie> whole desktop is a gl context
21:45:34 <drhodes> have you tried renicing the process to 20 ?
21:45:55 <theorbtwo> sproingie: And you think this will make it *harder* to have a buggy bit of gl code hang the whole machine?
21:46:28 <sproingie> actually yeah
21:46:56 <sproingie> they seem to take a little more care with it
21:48:01 <elspru> okay i've got a real strange erro
21:48:03 <elspru> r
21:48:13 <elspru>     Couldn't match expected type `a -> b'
21:48:13 <elspru>            against inferred type `[String]'
21:48:13 <elspru>     In the first argument of `($)', namely `words'
21:48:13 <elspru>     In the expression: words $ unwords $ sort caseArray
21:48:36 <kmc> sproingie, i'd disable compiz
21:48:45 <kmc> why do you need all your windows to burst into flame when you close them
21:48:45 <monochrom> what is the type of caseArray?
21:48:47 <Axman6> theorbtwo: i've never seen it happen (nat saying it can't, but i have seen it in linux numerous times)
21:48:59 <elspru> why not worky? I checked without the "words" and output is a "string like this"
21:49:03 <Saizan_> elspru: have you a local variables named words?
21:49:18 <elspru> Saizan_: you very smart person :)
21:49:18 <kmc> elspru, do you not want words . unwords . sort $ caseArray
21:49:21 <sproingie> i mostly use compiz so i can do crazy things like have settable hotkeys and change mouse button bindings
21:49:28 <kmc> :t words $ unwords
21:49:29 <lambdabot>     Couldn't match expected type `String'
21:49:29 <lambdabot>            against inferred type `[String] -> String'
21:49:29 <lambdabot>     In the second argument of `($)', namely `unwords'
21:49:33 <kmc> hmm it works either way
21:49:37 <kmc> but you should use (.) anyway
21:49:40 <sproingie> since they removed all customizability from metacity
21:49:50 <kmc> sproingie, there are more than two window managers you know :)
21:49:56 <elspru> Saizan_: merci
21:49:59 <theorbtwo> sproingie: Try sawfish.
21:50:00 <kmc> there are far too many
21:50:03 <kmc> try xmonad
21:50:06 <monochrom> > words $ unwords $ sort ["how","are","you"]
21:50:07 <lambdabot>   ["are","how","you"]
21:50:12 <monochrom> Works fine here.
21:50:29 <elspru> kmc: my version is shorter
21:50:36 <sproingie> right now i'm trying windows, which means i can start playing torchlight when i get bored
21:50:41 <theorbtwo> If you find $ and . confusing, use good old-fashioned parens.
21:50:44 <elspru> :)
21:50:51 <sproingie> probably a reason i should switch back to linux actually
21:51:41 <Saizan_> elspru: np :)
21:51:57 * Axman6 doesn't think there ever a really good reason to switch to linux >_>
21:52:32 <elspru> Axman6: only if you like being a computer person,
21:52:43 <Axman6> i am a computer person
21:52:49 <kmc> i prefer the system that breaks more that i can fix
21:52:50 <elspru> to allow to feel the synergy of man and machine
21:52:56 <kmc> rather than the black box that breaks less but must be reinstalled when it does
21:52:57 <Olathe> Axman6: what do you like to use ?
21:53:00 <Axman6> ha
21:53:04 <elspru> linux, especially command line, is the closest experience
21:53:22 <kmc> if my Linux system is broken or underperforming or just annoying me in some way, i can investigate
21:53:24 <Axman6> OS X on desktops, FreeBSD for servers, and windows for gaming (though i don;t game much)
21:53:28 <kmc> and yes you can waste a lot of time this way
21:53:32 <Olathe> Ahh, OK
21:53:44 <Axman6> elspru: OS x has a command line too, as do all the BSD's...
21:53:54 <elspru> agreed,
21:53:56 <mental> windows has a command line too
21:54:04 <elspru> I love to be free
21:54:08 <mental> it's even typed, unlike the others
21:54:10 <Axman6> mental: yeah, i was going to mention that too, but ...
21:54:12 <mental> don't you love types?
21:54:21 <Olathe> mental: Haha
21:54:23 <monochrom> I even like monad.
21:54:48 <erikc> we heard you guys like shells, this is a POWER shell
21:54:49 <kmc> windows is just like... "from now on, your fonts will double in size every other tuesday.  live with it or reinstall"
21:55:09 <mental> in my experience, that's not true
21:55:10 <sproingie> mmm yeah
21:55:16 <sproingie> never had that problem.  ever./
21:55:19 <mental> i've been using windows for a while and i never had fonts double on tuesday
21:55:23 <kmc> maybe i am bad at administering a windows machine
21:55:30 <sproingie> mental: everyone knows that happens on wednesday
21:55:39 <kmc> a benefit of being bad at windows is that nobody will ask you to fix their computer
21:55:47 <sproingie> i pretend to be bad at it
21:56:02 <Axman6> kmc: tat i do agree with :)
21:56:07 <elspru> kmc: aagreed
21:56:10 <sproingie> "fix your compute?  oh, i just program work machines, it's totally different.  have you tried turning it off and on?"
21:56:19 <elspru> i tell them to install linux, and then i'll help
21:56:22 <mental> kmc: it's very easy to administer a windows machine. Just *don't touch anything*.
21:56:24 <Axman6> well, my girlfriend does, but i can usuyally fix it anyway
21:56:25 <elspru> lol
21:56:36 <p_l> kmc: not really, the only way to not be asked to fix someone's computer is to have a Mac and avoid showing any technical expertise (and this, rarely for me, isn't actually a jab at mac users. Seriously.)
21:56:49 <fata_erro> i'm completely stumped
21:56:50 <sproingie> then i tell them to invert the phase variance warp coil harmonics through the deflector dish
21:57:02 <elspru> mental: but then you'd be infiltrated with malware and viruses
21:57:10 <mental> elspru: so?
21:57:22 <elspru> computer bogged down to the point of uselessness
21:57:53 <elspru> like a pelican that's eaten too much plastic
21:57:59 <monochrom> "Just *don't touch anything*" alone already bogs it down to the point of uselessness.
21:58:06 <mental> elspru: buy another one
21:58:14 <mental> they're not that expensive
21:58:23 <sproingie> never did get into powershell.  i guess if i was an exchange admin it would be different
21:58:24 <elspru> linux is what you describe however, if you do nothing extra to ubuntu, it will work
21:58:28 <elspru> and work quite well
21:58:33 <elspru> always
21:58:42 <sproingie> assuming you don't create files > 512M
21:58:43 <Axman6> but once you try to use it...
21:58:44 <Axman6> >_>
21:58:44 <pastah_rhymez> @pl (\p -> do {a <- p; as <- many p; return (a:as)})
21:58:44 <lambdabot> (line 1, column 11):
21:58:45 <lambdabot> unexpected "{"
21:58:45 <lambdabot> expecting variable, "(", operator or ")"
21:58:56 <elspru> Axman6: it's beautiful
21:59:01 <Axman6> pastah_rhymez: many1 p?
21:59:07 <elspru> so easy
21:59:10 <kmc> i had an app-level problem on linux fixed by rebooting the other day
21:59:10 <pastah_rhymez> Axman6: yes
21:59:11 <kmc> i was shocked
21:59:14 <kmc> usually rebooting creates problems
21:59:16 <Axman6> elspru: it is not, i'm sorry, i cannot agree with you there
21:59:17 <Olathe> @undo (\p -> do {a <- p; as <- many p; return (a:as)})
21:59:18 <lambdabot> (\ p -> p >>= \ a -> many p >>= \ as -> return (a : as))
21:59:21 <kmc> because you have upgraded some package in the past months
21:59:24 <Olathe> @pl (\ p -> p >>= \ a -> many p >>= \ as -> return (a : as))
21:59:25 <lambdabot> ap (>>=) (flip (fmap . (:)) . many)
21:59:32 <pastah_rhymez> Olathe: zomg
21:59:34 <fata_erro> is there a pure print function?
21:59:35 <pastah_rhymez> cool, thanks
21:59:39 <elspru> Axman6: my personal experience points to otherwise
21:59:40 <Olathe> You're welcome
21:59:46 <elspru> though linux is a command line thing
21:59:58 <sproingie> computers suck.  programming would be so much easier without them.
21:59:59 <elspru> i find clicking to be a repulsive activity
22:00:01 <monochrom> fata_erro: Look for Debug.Trace
22:00:07 <fata_erro> ty
22:00:25 <Axman6> i don't have a problem with command lines. i do have a problem with OS's which claim to be user friendly, and still require you to know how to use a command line
22:00:31 <monochrom> OK, OS talks go to #haskell-blah
22:00:46 * Axman6 is done anyway
22:00:48 <elspru> Axman6: well i'm making a HSPL or human speakable programming language
22:00:55 <elspru> so as to be more user friendly cocmmand line
22:00:58 <elspru> :D
22:01:08 <elspru> or spoken is fine to, eventually
22:01:18 <mental> "Computer, entertain me"
22:01:21 <elspru> i'm currently coding in haskell
22:01:22 <sproingie> forth tends to be very speakable
22:01:30 <sproingie> forth love if honk then
22:01:34 <kmc> fata_erro, don't use trace except for debugging
22:01:48 <monochrom> kmc: But fata_erro is debugging.
22:02:21 <elspru> mental: the correct syntax in hspl might be "ya su computer do entertain bo me"
22:02:56 <elspru> sproingie: but forth doesn't have case grammar
22:03:03 <elspru> otherwise i like forth
22:03:26 <kmc> monochrom, i stand by what i said :)
22:04:41 <elspru> entertain might include random sensory stimulous
22:05:04 * fata_erro facepalms
22:05:18 <mental> elspru: that does not sound very entertaining
22:05:21 <fata_erro> damn easy error
22:05:29 <fata_erro> yet so much trouble
22:05:34 <elspru> mental: movies, music, text
22:05:44 <elspru> that's what i do for entertainment, random sensory stimulous
22:06:00 <elspru> random within my range of interests to be more specific
22:06:00 <sproingie> forth's syntax is pretty well programmable
22:06:16 <sproingie> i think of it as the ultimate macro assembler
22:06:18 <elspru> sproingie: really? how to add case grammar?
22:06:32 <sproingie> what's a case grammar?
22:06:43 <elspru> to, of, for, by
22:06:54 <sproingie> prepositions?
22:06:57 <elspru> argument placement prepositions
22:07:12 <elspru> oh and types
22:07:34 <sproingie> there's always parsing words.  if you're in compile mode, then even immediate effects can munge the current word being compiled
22:07:38 <sproingie> tho not in any portable way
22:07:51 <elspru> anyways, so i'm coding in haskell, i found the string manipulation was sorely lacking in standard forth
22:07:53 <sproingie> as for types, fuggedaboutit
22:08:26 <elspru> lol
22:08:50 <elspru> haskell excels in string manipulation,
22:08:52 <sproingie> i had a utf8 encoder and decoder in forth.  it was kind of pretty looking.
22:08:53 <elspru> one of the reasons i love it
22:09:32 <Axman6> you really think so? o.O
22:09:47 <elspru> sproingie: ya, noam chomsky langs like C tend to look odd
22:09:49 <Axman6> string manipulation has often been critisised in haskell
22:10:03 <elspru> really? but it's so easy
22:10:12 <Axman6> not more complex stuff
22:10:14 <fata_erro> is it possible to make a type like data?
22:10:22 <kmc> fata_erro, what do you mean?
22:10:32 <fata_erro> so that one can't mix args up
22:10:34 <elspru> Axman6: i wrote a parser/compiler, what's harder than that?
22:10:42 <kmc> fata_erro, can you give an example?
22:10:45 <Axman6> parsing isn't string manipulation
22:10:47 <fata_erro> i have Category and Word
22:10:52 <elspru> Axman6: ya it is
22:10:56 <fata_erro> both ByteString
22:10:59 <kmc> fata_erro, newtype Category = Category ByteString
22:10:59 <Axman6> it's parsing...
22:10:59 <kmc> ?
22:11:28 <kmc> "newtype" is just like "data" except a) it's only usable in a subset of cases, b) it's more efficient, and c) technical difference i won't bore you with unless you care
22:11:36 <elspru> Axman6: ? well first you brake it up into tokens, so it turns into a [String], then have functions to get certain arguments from that string, perhaps the verb
22:11:37 <fata_erro> kmc: is it drop in replacement?
22:11:48 <elspru> Axman6: so to me that's string parsing
22:11:51 <elspru> or manipulation
22:12:24 <kmc> fata_erro, "newtype" is mostly a drop-in replacement for "data"
22:12:28 <kmc> not for "type"
22:12:36 <Axman6> you're not manipulating anything. string manipulation would be things like replace this substring in this string with this string. the sorts of things perl is good at
22:12:42 <kmc> "type" is just a synonym, like a macro substitution on types
22:12:45 <kmc> it does not create a new type
22:13:14 <fata_erro> i know :)
22:13:28 <kmc> to convert "type" to either "newtype" or "data" you will have to add applications of the constructor to put values into the new type, and pattern matches to bring them out
22:13:32 <fata_erro> can i use deriving for newtype?
22:13:35 <kmc> yes
22:13:38 <kmc> in fact you can derive *any* class
22:13:40 <kmc> under GHC
22:13:42 <elspru> Axman6: hmmm, well I implemented a likewise feature in my Compiler.hs , seemed to be pretty easy
22:13:45 <kmc> with -XGeneralizedNewtypeDeriving
22:13:52 <fata_erro> kmc: thanks?
22:14:14 <fata_erro> i meant thanks theres no question :)
22:14:29 <kmc> the point of "newtype" (as opposed to "data") is that this wrapping and unwrapping of constructors is not present as overhead at runtime
22:14:37 <kmc> but it's as typesafe as if you used "data"
22:15:28 <fata_erro> ya
22:15:46 <fata_erro> i'm going to have to rework code
22:16:46 <fata_erro> it would be nice if no constructor was needed
22:18:32 <monochrom> If no constructor was needed, some other marker would be needed.
22:21:44 <fata_erro> Is there a powered by haskell pic to add to ones site?
22:26:57 <Saizan_> there's an haskell logo
22:28:49 <sproingie> http://uncyclopedia.wikia.com/wiki/File:NarleyYeeaaahh.jpg
22:29:16 <kmc> fata_erro, if no constructor was required, how would it add any safety
22:29:24 <kmc> new type + automatic conversions = type synonym
22:31:53 <fata_erro> I guess your right
22:34:46 * kmc looks to his right
22:34:52 <kmc> you win: a goat
22:35:49 <monochrom> Oh why don't you offer the chance to switch
22:36:16 <kmc> no time for that
22:46:34 <tomoj> are there any tools for haskell which would help in analyzing a number of modules and seeing the connections between modules by looking at imports?
22:46:42 <tomoj> maybe the ghc api or something?
22:47:18 <kmc> tomoj, http://hackage.haskell.org/package/graphmod ?
22:47:31 <kmc> if it's just static analysis you want
22:47:35 <kmc> the GHC API is probably overkill
22:48:27 <kmc> you can parse source with haskell-src-exts
22:48:34 <tomoj> yes, graphmod was exactly what I was looking for I think, thanks
22:48:54 <tomoj> I want to count outgoing dependencies for each module
22:49:25 <jrockway> hello
22:49:36 <jrockway> i am trying to figure out why, on windows, i can "ghci -lfoo" and my (ffi-based) app works, but when i build with my .cabal, ld can't find the symbols in foo.dll
22:49:51 <jrockway> i also have a foo.lib (copied to foo.a and libfoo.a, with no success)
22:51:40 <Saizan_> do you have "extra-libraries: foo" in your .cabal file?
22:51:54 <jrockway> yup
22:52:17 <jrockway> with -v, i can see the "-Lfoo -lfoo" statements (i have the dll/.h/etc. in the foo directory)
22:52:33 <jrockway> dunno if it matters, but this is a "native windows" dll, not a cygwin or mingw dll
22:52:43 <jrockway> (and no, i don't have the source code, otherwise i would not be using windows :)
22:54:31 <jrockway> i have tried poking some windows-specific libraries on hackagedb, and the commands cabal runs are the same for those as they are for mine
22:54:35 <jrockway> only, those succeed :)
23:09:28 <jrockway> i wish there was a way to get gcc/ld to print something like "looking for symbols in this file, nope... not in here"
23:09:37 <jrockway> but even with -v -v -v it prints nothing useful
23:09:50 <jrockway> ok, maybe a little useful, but not *really* useful
23:19:03 <dmead> ?src unfilyrt
23:19:03 <lambdabot> Source not found. Do you think like you type?
23:19:05 <dmead> ?src unfilter
23:19:06 <lambdabot> Source not found. Take a stress pill and think things over.
23:19:09 <dmead> yes, i do
23:19:10 <dmead> thanks.
23:19:17 <dmead> ?src filter
23:19:18 <lambdabot> filter _ []     = []
23:19:18 <lambdabot> filter p (x:xs)
23:19:18 <lambdabot>     | p x       = x : filter p xs
23:19:18 <lambdabot>     | otherwise = filter p xs
23:19:18 <phr> anyone here looked at the code of Atom?  it's more readable than i expected
23:21:20 <c_wraith> > cake !! 29
23:21:21 <lambdabot>   "One teaspoon grated orange rhubarb."
23:21:31 <kmc> > transpose cake
23:21:33 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
23:22:00 <tensorpudding> orange rhubarb is not real
23:22:02 <DarthHaskell> Is this a good place to announce haskell related open source projects?
23:23:10 <phr> darthhaskell, sure, folks here like to hear such things, but you might want to write about it on the web so that HWN can link to it
23:23:12 <phr> and put it on hackage
23:23:43 <phr> or on one of the haskell mailing lists (like -cafe) instead of the web if you prefer
23:24:03 <Saizan_> yeah, with an ANN: in the subject
23:24:37 <Saizan_> but do tell here, i'm curious now :)
23:25:21 <DarthHaskell> There's a site, thought this would be a good place, aimed at anyone looking for a light ide, and would like to contribute code (it's in c/c++ at the moment, wrote it learn haskell).
23:25:26 <DarthHaskell> here is the link
23:25:37 <DarthHaskell> http://hoodoo.kenai.com/
23:26:32 <phr> does tom hawkins ever come on this channel?
23:26:39 <DarthHaskell> I'll post something on the mailing list too
23:28:14 <jrockway> nice
23:28:21 <jrockway> DarthHaskell: you know about Yi, right?
23:28:35 <DarthHaskell> no
23:28:39 <DarthHaskell> whats Yi?
23:28:48 <idnar> > cake
23:28:49 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
23:28:50 <phr> i always thought someone should write a haskell light ide and call it HALIDE
23:29:00 <jrockway> DarthHaskell: a haskell text editor :)
23:29:08 <phr> there's also leksah
23:29:13 <jrockway> http://www.haskell.org/haskellwiki/Yi
23:29:20 <Saizan_> ..and emacs
23:29:30 <DarthHaskell> found leksah scary for first attempts
23:31:01 <DarthHaskell> I started out with VI
23:31:10 <jrockway> vi or vim?
23:31:18 <DarthHaskell> sorry vim
23:31:46 <smorg> The name would seem to imply its more like vi than emacs
23:32:24 <mxc> yi is actually agnostic between emacs style control and vim style control
23:32:33 <mxc> i used to have very high hopes for yi
23:32:51 <mxc> seems like hte proejct is kinda dead now.  I'd love to contribute if it got some momentum going
23:33:00 <jrockway> some day i will write an elisp compiler so that elisp libraries can be used with yi
23:33:03 <smorg> haven't tried it yet. I thought yi was supposed to be emacsish (which I don't know which is why I didn't try it)
23:33:14 <jrockway> the problem with writing a new editor is that you lose 1,000,000 lines of utility code
23:33:30 <mornfall> mxc: Well, it doesn't work like that, unfortunately. You have to give it the momentum, it won't materialize out of thin air...
23:33:38 <mornfall> And with you I mean you personally. : - P
23:33:45 <mxc> smorg: i think its emacsish in terms of a decent scripting language and being full featured, but can work with vim style controls just as easily
23:33:49 <mxc> mornall i know :(
23:34:04 <jrockway> viper is also a good vi
23:34:10 <jrockway> it's what vim should have been :)
23:34:25 <mxc> jrockway - i've tried viper, have lots of problems with it
23:34:46 <jrockway> as an emacs user, i like it a lot
23:34:50 <mornfall> I use viper and vimpulse (viper for a long time, vimpulse just recently...)
23:34:54 <mxc> still need to drop into emacs for a lot
23:34:55 <mxc> w
23:34:55 <mxc> hat
23:34:55 <mxc> s
23:34:59 <mxc> whats vimpulse?
23:34:59 <jrockway> but i learned text editing on emacs, and am very familiar with the internals
23:35:03 <jrockway> and i know nothing about vim
23:35:08 <jrockway> so, viper works for me
23:35:14 <jrockway> but apparently not vim users :)
23:35:15 <mornfall> mxc: visual/block visual/line visual for viper
23:35:44 <dmead> ?hoogle concatmap
23:35:44 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
23:35:44 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
23:35:44 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
23:35:47 <jrockway> "expert mode"
23:35:47 <mornfall> jrockway: I am an ex-vim user (well, I still run vim over ssh, and sometimes locally for one-off edits...)
23:35:49 <smorg> leksah sounds cool but I'll have to fiddle with it to compile on gentoo. The cabal dependencies never seem to match up with what portage says they should be.
23:36:09 <jrockway> basically emacs with an optional way to write complex commands without holding down the control key :)
23:36:14 <dmead> > concatmap [[1],[2],[3]]
23:36:15 <lambdabot>   Not in scope: `concatmap'
23:36:24 <dmead> > concatMap (++)  [[1],[2],[3]]
23:36:25 <lambdabot>   Couldn't match expected type `[b]' against inferred type `a -> a'
23:36:27 <dmead> boo
23:36:34 <Saizan_> jrockway: M-x complex command ?
23:36:40 <dmead> hey guys
23:36:47 <dmead> how the shit do you concat a list of lists
23:36:52 <dmead> it's at the back of my brain
23:36:52 <jrockway> join?
23:36:56 <dmead> ah yes
23:37:01 <dmead> ?type join
23:37:02 <Saizan_> > concat [[1],[2],[3]]
23:37:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:37:03 <lambdabot>   [1,2,3]
23:37:06 <mornfall> mxc: I am too busy fixing up darcs, so I leave Yi for you. : - P
23:37:13 <mxc> hah
23:37:16 <mornfall> And anyway, practice time.
23:37:16 <dmead> or that
23:37:18 <jrockway> Saizan_: vi-style commands are a bit more concise
23:37:20 <Saizan_> > concatMap return [[1],[2],[3]]
23:37:21 <lambdabot>   [[1],[2],[3]]
23:37:42 <mxc> i love my vim commands:
23:37:43 <jrockway> but you know what, i usually forget what to type and just a) "do it manually" or b) write a real program in *scratch*
23:37:46 <jrockway> but i like the idea
23:37:55 <Saizan_> > concatMap id [[1],[2],[3]] -- silly me
23:37:56 <lambdabot>   [1,2,3]
23:37:56 <mxc> maddjp>2'aa--comment
23:38:12 <jrockway> yeah
23:38:20 <dmead>  is there any advantage in doing it monadically?
23:38:48 <Saizan_> dmead: nah
23:39:04 <mxc> there's a thought i've been kicking around in my head, but dont knwo the correct term for
23:39:20 <mxc> basically, the idea of organizing code by files seems a bit dated
23:39:37 <mxc> is there any work on sort of a dynamic, metadata driven system to organize code?
23:39:40 <jrockway> ever use squeak/smalltalk?
23:39:51 <mxc> especially haskell seems well suited for that..
23:39:57 <mxc> nope
23:40:08 <jrockway> well, it's exactly what you want :)
23:40:23 <Stinger> I don't know why we don't have realtime compilers yet :P
23:40:45 <mxc> i want it in haskell :)
23:40:54 <jrockway> yeah :)
23:41:41 <jrockway> sometimes i think i invest too much mental effort in making my source files look nice
23:42:05 <jrockway> if things were just modules and functions, then it wouldn't matter if i put 3 lines between those two functions, or defined foo before using it in bar, and so on
23:42:08 <Stinger> jrockway, who uses your source files?
23:42:25 <jrockway> me :)
23:42:26 <adu> all your source files are belong to us
23:42:44 <Stinger> well it might save you some time when you come back to it in a month :P
23:42:48 <jrockway> (but it is important for them to look nice and to make sense, if you are going to be working with other people)
23:43:03 <mxc> i'm with you jrockway
23:43:52 <Stinger> hey haskell people, what column width do you limit to?
23:44:08 <jrockway> depends on what size monitor i am sitting in front of :)
23:44:22 <jrockway> if my home machine, i have 3 88 column windows
23:44:27 <jrockway> if at work, i have two 82 column windows
23:44:32 <adu> Stinger: 100
23:44:34 <jrockway> and i use all available space :)
23:45:02 <Stinger> hmm 100 might be a decent medium
23:45:28 <jrockway> i think 78 is "standard"
23:45:29 <adu> my default terminal windows are all 100 cols
23:45:38 <jrockway> people will start making fun of you if you do more than that
23:45:49 <adu> although Emacs.app still opens with 80 cols... need to fix
23:45:50 <jrockway> (but i have seen much worse, like 200+!)
23:46:05 <Eduard_Munteanu> Hi.
23:46:16 <Stinger> I thought 80 was old style standard
23:46:24 <Stinger> guess you need scrollbars
23:46:40 <adu> Stinger: it is, 80 is very oldschool
23:46:49 <jrockway> i don't like terminals that are not 80x25
23:46:58 <jrockway> but for code, sometimes it's nice to have more than 80 cols
23:47:06 <jrockway> not for every line, but maybe for 1 in 100 or something
23:47:09 <adu> hence 100
23:47:13 <jrockway> yeah
23:47:20 <jrockway> i am pretty happy with 90ish
23:47:35 <jrockway> there are still times when there are awkward forced breaks though
23:47:46 <Stinger> ok I'm gonna try for 100 then
23:47:55 <adu> that's when i start 'where'ifying
23:48:00 <Stinger> see what it's like
23:48:13 <jrockway> i wrote some overly-long type signature today
23:48:28 <jrockway> (and i have been doing a lot of c2hs lately, which is really ugly no matter what you do)
23:49:08 <Eduard_Munteanu> jrockway, if you worry about writing code and indenting, you can probably configure your editor to warn you when you exceed the 80 cols. That's what I do with vim.
23:49:40 <jrockway> yeah
23:49:49 <jrockway> i am not "worried", but i keep it in mind :)
23:49:54 <adu> random thought: can you make type alias operators?
23:49:56 <Eduard_Munteanu> Heh.
23:50:11 <jrockway> kind of like TeX and "overful hbox" :)
23:50:26 <Eduard_Munteanu> Nice analogy :))
23:51:20 <mxc> i have 3 100 column windows side by side
23:51:39 <mxc> but, the third one goes to 116 (1920 pix wide)
23:51:41 <jrockway> screenshot? :)
23:52:09 <mxc> and i try to keep mycode to 100 cols wide, unless there's a log message trailing off
23:53:03 <mxc> me?
23:53:04 <Stinger> hmm gtk2hs isn't on hackage?
23:54:13 <jrockway> mxc: i am interested in seeing how small the font is
23:54:31 <jrockway> because i use a small font and have a 24" monitor, and i have 30 fewer columns than you (or so)
23:55:10 <mxc> uploading
23:55:12 <mxc> http://dl.dropbox.com/u/3468290/vim-3by2.png
23:55:44 <jrockway> nice
23:55:47 <jrockway> that is a small font :)
23:55:48 <mxc> font = Monaco:h9
23:55:57 <mxc> its perfect for me
23:56:08 <Eduard_Munteanu> Stinger, it's on Cabal iirc.
23:56:10 <mxc> for some reason, antialiased fonts annoy me when i'm coding
23:56:27 <Stinger> is it under some strange name?
23:56:40 <mxc> by the way, feel free to critique/use that CPS implementation of Either
23:57:04 <mxc> by the way, my monitor is a full HD dell that i bought for $180
23:57:06 <mxc> 23"
23:57:18 <mxc> dell computers suck, but the monitors are great
23:57:32 <Saizan_> Stinger: you've to download it from their site
23:57:37 <Saizan_> ?google gtk2hs
23:57:38 <lambdabot> http://www.haskell.org/gtk2hs/
23:57:38 <lambdabot> Title: Gtk2Hs
23:57:47 <jrockway> yeah, i have a similar 24" dell
23:57:53 <jrockway> kind of old now, but still works great
23:57:55 <mxc> hah
23:58:02 <mxc> as i wrote that, i got some spam from dell
23:58:06 <jrockway> also, i did something like CPS +
23:58:12 <jrockway> MonadError in perl
23:58:25 <Eduard_Munteanu> Stinger, hm, seems to be available under the name 'gtk'.
23:58:29 <jrockway> (in Haskell, i have not had a case where ErrorT did not meet my needs)
23:58:36 <Eduard_Munteanu> Stinger, but I installed mine using 'emerge gtk2hs' on Gentoo.
23:58:45 <mxc> apparently, the CPS style is supposed to be faster
23:58:46 <Stinger> heh
23:59:23 <jrockway> yeah
23:59:37 <jrockway> in my case, i was doing some async processing in an event loop
23:59:47 <jrockway> so you would do one thing, set a watcher, and when the event happened, it would call your function
