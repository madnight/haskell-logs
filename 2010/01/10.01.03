00:00:21 <mmmdonuts> If you could figure how to cat the universe's /proc/cpuinfo, that would be a good indication we're running in a simulation.
00:00:49 <tensorpudding> finding /proc/cpuinfo would be hard
00:00:54 <mmmdonuts> My guess is the universe runs on Intel - that would explain a lot.
00:00:54 <tensorpudding> we already know where /dev/null is though
00:01:26 <cads> Jafet: when you code a simulation, aren't you simply building a physical model of an abstract model which you consider to be more ideal and in fact more "real" than your simulation?
00:01:52 <Jafet> @vixen when you code a simulation, aren't you simply building a physical model of an abstract model which you consider to be more ideal and in fact more "real" than your simulation?
00:01:53 <lambdabot> i'm really real
00:02:16 <tensorpudding> @vixen are you on drugs
00:02:16 <lambdabot> i truely am
00:03:12 <cads> in the case that your simulation describes the model perfectly, there is complete correspondence, you might say the simulation is the realization of the abstract model
00:05:07 <cads> but I think the notion of simulation is only valid in the context of a base reality where you consider the physical structure to be conveniently acting similarly to a formal model, with the belief that _your_ subjective reality in which you design simulations is in some way more than a 'mere' abstract model
00:05:57 <Jafet> If you're emulating that crank, why don't you put it on a blog
00:07:01 <cads> heh, I'm trying to make a point but I'm proving that it's really easy to sound crankish when talking about philosophy :D
00:07:52 <Jafet> Fundamentally, philosophy is the art of convincing someone else that your definitions are better than theirs
00:08:56 <cads> I was trying to say that if we're just a sufficiently complicated object in some category, then there is no real "simulation", just equivalences and interpretations of one structure into another, all of varying faithfullness.
00:10:22 <cads> Jafet, were you serious about the godel encoding of endofunctors, or has my string just been twanged?
00:10:42 <Cale> cads: I don't think it makes sense to talk about what we *really* are.
00:11:11 <Cale> cads: We can only talk about what we are relative to certain formal (or informal) systems of reasoning.
00:11:25 <Jafet> @vixen you know I am always serious when I talk about endofunctors, dear
00:11:25 <lambdabot> you're fun too
00:12:43 <Cale> and at the end of the day there's nothing to say whether one of those is better than another apart from some notion of usefulness which probably varies according to situation or person.
00:13:28 <Cale> But despite that we have some really good systems which are quite useful.
00:13:41 <Cale> I just don't think we should expect there to be anything underneath them.
00:15:29 <cads> there's just seems to be this sense of "reality" that the human mind seems desperate to apply to things
00:16:13 <cads> which considering that we're animals first and foremost, make sense - from the perspective of evolution, it's probably not an advantage to be a pure nihilist
00:16:36 * hackagebot upload: yices 0.0.0.6 - Haskell programming interface to Yices SMT solver (KiYungAhn)
00:17:03 <elly> I leave for five minutes and godel numbering of endofunctors is invokved as a potential proof that the universe is simulated. Thanks, #haskell :P
00:18:24 <dolio> I guess that means you shouldn't ever leave again.
00:18:26 <kmc> @remember elly I leave for five minutes and godel numbering of endofunctors is invokved as a potential proof that the universe is simulated. Thanks, #haskell :P
00:18:26 <lambdabot> Done.
00:18:29 <elly> I guess.
00:18:51 <Jafet> Well, it's about as valid as any other proof
00:19:02 * kmc hands out magic sugar cubes
00:19:24 <elly> is my mind about to be expanded?
00:19:31 <kmc> until it snaps
00:19:32 <elly> am I going to learn about monads suddenly?
00:20:46 <mmmdonuts> cads, I think you're placing too much significance on the meaning of "reality".  Philip K Dick had the best definition: "Reality is that which, when you stop believing in it, doesn't go away."
00:20:52 <Jafet> Magic kool-aid cubes
00:21:21 <kmc> Philip K Dick was also absolutely batshit insane
00:21:48 <mmmdonuts> Apparently he knew it.
00:21:52 <kmc> yes
00:21:55 <kmc> VALIS is a good book
00:22:21 <mmmdonuts> To the point where he was able to figure out a better definition of reality than the one #haskell is currently agonizing about.
00:22:27 <kmc> it's a good definition regardless
00:22:52 <kmc> but in PKD's case, "reality" may have included a gnostic pink laser beam from outer space that warns you of obscure medical conditions
00:22:54 <cads> Jafet, you have to expound a bit, or maybe link us to a paper? What you say seems like the proof "We believe god is real because we beleive mathematics to be consistent. But the devil clearly exists, because we can't prove mathematics consistent. Furthermore, if mathematics is actually inconsistent, the devil doubly exists" -- that's taking a result of godels' and using it to 'prove' a philosophical position, ie. the position that "godel's second theorem i
00:23:14 <kmc> hahaha
00:23:29 <Jafet> You seem to have talent
00:24:02 <kmc> Theorem god_exists : exists d, god d. Proof. auto. Qed.
00:24:27 <cads> kmc, note that the above proof doesn't guarantee the existance of god, only the devil :D
00:25:29 <cads> Jafet: I've just been learning a bit of category theory lately, but I loves me some Godel, and when you mentioned a godel encoding of endofunctors why my ears perked right up :D
00:26:33 <mmmdonuts> kmc, I think PKD's definition needs to be expanded to include some notion of peer review.  Of course, that doesn't stop one from imagining could imagine peers.  Epistemology isn't a perfect enterprise, it's ultimately more of a probability game, but people tend to like to compress statistics into yes/no answers and then get confused when they can't be sure whether the answer is yes or no.
00:26:40 <tensorpudding> are we talking about goedel's proof of god
00:27:14 <Cale> cads: Actually, I'd say that's taking a result of GÃ¶del's and completely and utterly butchering it.
00:27:32 <Cale> To the extent that it's entirely unrecognisable ;)
00:27:43 <dolio> That seems to be the most common use of his work.
00:27:47 <kmc> Cale, or simply using very non-standard notation
00:27:52 <Cale> dolio: hahaha
00:28:03 <kmc> where "god exists" is shorthand for "ZFC is consistent"
00:28:18 <kmc> the use of notation designed solely to trick people is generally frowned upon by the mathematical community
00:28:36 <Cale> kmc: heh, okay
00:28:56 <kmc> it's worth noting that compelling empirical evidence that a god exists is impossible
00:29:18 <kmc> therefore (and somewhat ironically i feel) one must turn to pure tricks of logic if one is interested in advancing this point of view
00:29:23 <cads> at best we have a being of arbitrary but finite power
00:29:31 <kmc> yes
00:29:37 <Cale> kmc: Empirical evidence that ZFC is consistent, you mean? :)
00:29:40 <kmc> hehe
00:29:48 <kmc> in fact i think there's a bound on the required power
00:30:04 <tensorpudding> i have a computer that is looking for empirical evidence of omega
00:30:17 <kmc> which is just the ability to simulate a human brain
00:30:21 <Cale> tensorpudding: The first infinite ordinal?
00:30:25 <tensorpudding> yes
00:30:31 <tensorpudding> but i don't think it will halt
00:30:35 <Cale> hehe
00:30:49 <cads> kmc, literally one single human brain, and enough partial brains to convince you the rest of the people you meet are real
00:30:54 <tensorpudding> if i were looking for chaitin's constant, that would be awesome too
00:30:54 <dolio> There are so many omegas.
00:30:57 <kmc> yes, and not even at realtime
00:31:16 <tensorpudding> i am the alpha and the omega = i am the fine-structure constant and chaitin's constant
00:31:23 <kmc> :O
00:31:34 <cads> nice!
00:31:43 <tensorpudding> there aren't enough constants that have alpha
00:32:14 <dolio> Alpha is for arbitrary ordinals.
00:32:27 <dolio> And initial algebra maps, apparently.
00:32:30 <tensorpudding> it's used for angles too
00:32:35 <tensorpudding> but nothing particular
00:32:45 <tensorpudding> except fine-structure, which isn't very mathy
00:32:50 <tensorpudding> but it is pretty fundamental i guess
00:33:10 <tensorpudding> mostly weird because of how close it is to the number 1/137
00:33:40 <cads> hehe, the fine structure constant is a floating point number on our universe's stack
00:34:09 <kmc> as above so below
00:34:11 <tensorpudding> it's not so close to 1/137 that it would be a rounding error, unless the universe is really low-precision floating point
00:34:14 <cads> just an strongly constrained yet arbitrary number we're all super curious about
00:35:20 <kmc> the precision is known and is much better than 32-bit IEEE 754
00:35:38 <kmc> consider the diameter of the observable universe in planck lengths
00:37:21 <cads> wonder if they made any headway on proving that our universe has a toroidal topology that actually repeats _inside_ our imagined hubble volume
00:37:31 <cads> essentially they were looking for parts of the sky that repeat
00:37:58 <tensorpudding> you also need the universe to be curved
00:38:44 <cads> to account for observed phenomena?
00:39:03 <kmc> http://www.youtube.com/watch?v=zSgiXGELjbc
00:39:14 <tensorpudding> well, if the universe has a toroidal toplogy, there should be curvature
00:40:07 <cads> kmc++!
00:40:11 <Cale> cads: I think they ruled out a bunch of simple topologies
00:40:18 <tensorpudding> the lambda-cdm model predicts a very small curvature
00:41:00 <cads> ah, good
00:42:00 <tensorpudding> the curvature is predicted from the densities of the mass-energy
00:42:27 <tensorpudding> most of the attractive gravitational part is dark matter, with a small amount of baryonic matter
00:42:39 <tensorpudding> but it's mostly balanced by the repulsive dark energy part
00:43:13 <cads> so we have that there is a global curvature due to dark energy?
00:44:40 <cads> kmc, much kudos for that link - I think I will make a autotuned remix now.
00:45:37 <kmc> :)
00:45:39 <tensorpudding> the lambda is there to balance the curvature, and to provide an explanation for why the expansion of the universe is accelerating
00:45:52 <cads> http://www.youtube.com/watch?v=OpJGZ9RHAvU&feature=related
00:46:24 <tensorpudding> it turns out that lambda was first introduced by einstein to allow for a static universe, and it returns to explain an accelerating expanding universe
00:47:08 <cads> rest in peace, Carl, Billy!
00:47:32 <tensorpudding> lambda = dark energy, in current models
00:48:50 <bburhans> heheh, I thought this was ##physics. Usually I get about 20 highlights a day there discussing Einstein in one form or another. ;)
00:49:09 <tensorpudding> this conversation evolved a lot
00:50:51 * kmc intelligently designed this conversation
00:51:15 <cads> clearly not divine design
00:51:43 <Cale> http://www.picturesforsadchildren.com/comics/00000305.png
00:51:53 <kmc> <3 that comic
00:54:07 <cads> in the end perhaps we are all just like this caveman fellow: http://dresdencodak.com/2009/09/22/caveman-science-fiction/
00:54:16 <tensorpudding> i are play god
00:54:18 <medfly> this sounds on topic
00:54:28 <Jafet> What topic
00:54:45 <tensorpudding> topic?
00:54:49 <tensorpudding> this is #haskell
00:56:04 <cads> note that the last panel implies toroidal cosmology
00:56:54 <augur> cads
00:57:29 <augur> that story ends like this story by ted chiang called tower of babylon
00:59:57 <cads> is it by any chance an interesting short story?
01:00:12 <augur> its not bad
01:00:32 <augur> they build a great big tower, 60 miles high or something, to reach the vault of heaven
01:00:51 <cads> and he sees all sorts of stuff climbing it?
01:00:52 <augur> and then they travel up it, past the moon and the sun and the stars and they get to the vault of heaven which covers the world and start tunneling and tunneling
01:01:07 <cads> doing spoils!
01:01:12 <cads> don't*
01:01:16 <augur> and they break through to the other side and... its the ground!
01:01:17 <augur> :O
01:01:35 <cads> aw fer peyton jone's sake :P
01:01:50 <augur> :p
01:02:10 <cads> hehe, it's okay, I actually like spoilers if I know the ending then I can read critically
01:02:41 <cads> this thing got a hugo, sounds like good reads
01:02:54 <augur> lots of interesting stories
01:02:58 <cads> thanks for mentioning  it augur
01:03:12 <cads> have you ever read a short story called Diamond Dogs?
01:03:17 <dnquark> hey folks...  I'm trying to learn haskell and feeling pretty dumb here.
01:03:17 <dnquark> How would I map a curried function?  For instance:
01:03:26 <dnquark> showcat::Show a=>a->String->String
01:03:26 <dnquark> showcat a b = (show a) ++ b
01:03:54 <dnquark> now I want to map it over a list [0..3] to produce ["0foo", "1foo"...]
01:04:35 <dolio> @type flip
01:04:37 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
01:04:44 <dolio> Oh, right.
01:04:47 <cads> I think you'd do like   map (flip $ showcat "foo")
01:04:50 <dolio> @type Prelude.flip
01:04:51 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
01:06:23 <cads> > map (flip $ showcat "foobie") [1..3]  where showcat a b = (show a) ++ b
01:06:24 <lambdabot>   <no location info>: parse error on input `where'
01:06:54 <dolio> That $ shouldn't be there.
01:07:00 <dblhelix> Happy New Year, #haskell
01:07:10 <dnquark> ah, thank you.  works without the $
01:07:40 <cads> happy newyear back at ya dblhelix!
01:10:33 <dnquark> that's kinda sneaky...  so is that the only way to do it?..  is it possible to write something like map (show _ ++ "foo") [1..3]
01:10:56 <dnquark> i.e. have an explicit anonymous function
01:11:13 <dolio> map (\x -> show x ++ "foo")
01:12:01 <dnquark> heh, i guess it makes sense in hindsight (up until now haskell has been a read-only language for me)
01:13:18 <cads> that bugged me too at first
01:14:26 <kmc> :t map (show . (++ "foo"))
01:14:27 <lambdabot> [[Char]] -> [String]
01:15:00 <kmc> > map (show . (++ "foo")) (words "hello everyone out there in computer land")
01:15:01 <lambdabot>   ["\"hellofoo\"","\"everyonefoo\"","\"outfoo\"","\"therefoo\"","\"infoo\"","...
01:15:24 <kmc> :t map ((++ "foo") . show)
01:15:25 <lambdabot> forall a. (Show a) => [a] -> [[Char]]
01:15:50 <cads> bang
01:15:54 <kmc> > map ((++ "foo") . show) [1,2,3]
01:15:55 <lambdabot>   ["1foo","2foo","3foo"]
01:16:23 <kmc> bang bang feuer frei
01:16:26 <dnquark> while i'm on a roll asking newb questions...  is there a good way to store state in a function?  for instance, I want the function to store a list ["a","b"] and as a side effect on every invocation it would swap to ["b","a"], then back to "a","b", etc
01:16:47 <kmc> dnquark, applying a function never has a side effect in Haskell
01:17:05 <cads> you can represent and keep track of side effects using monads
01:17:16 <O_4> Though it could return a new function or state.
01:17:18 <kmc> which does not mean haskell has no side effects!
01:17:22 <kmc> they're a separate datatype
01:17:37 <dnquark> gulp.  i have barely written "hello world" here and people are talking about monads
01:17:40 <kmc> in Haskell, side effects are first class
01:17:47 <JohnnyL> what's a good example of OpenGL under GHC?
01:17:53 <kmc> dnquark, don't worry about monads for a while
01:18:02 <kmc> just try to program without side effects
01:18:08 <kmc> by passing around and returning new versions of stuff
01:18:10 <cads> dnquark: but a simple way for a recursive self calling function to keep a "state" is to use an accumulator argument
01:18:58 <kmc> > let mySum n [] = n; mySum n (x:xs) = mySum (n+x) xs in mySum 0 [1..100]
01:18:59 <lambdabot>   5050
01:19:35 <kmc> dnquark, the thing to know as a beginner is that, when people say "Haskell has no side effects", they are lying.
01:19:40 <dnquark> hm, I was thinking about the state in the context of something I wanted to do in xmonad.  the function would actually call some xmonad functionality but I wanted to keep track of state as a side effect
01:19:43 <kmc> Haskell *functions* have no side effects
01:20:01 <kmc> dnquark, is the return value of your function a value in the X monad?
01:20:05 <cads> > let powpowboomboom n a = powpowboomboom (n-1) (n*a) ; powpowboomboom 0 a = a in powpowboomboom 7 1
01:20:06 <kmc> i.e. a value of type (X a) for some a?
01:20:11 <lambdabot>   mueval: ExitFailure 1
01:20:12 <cads> this better work!
01:20:16 <cads> aahc
01:20:17 <kmc> because as i recall X incorporates all of IO
01:20:33 <kmc> so you could use IORefs for mutable state
01:20:36 <kmc> @hoogle IORef
01:20:37 <lambdabot> module Data.IORef
01:20:37 <lambdabot> Data.IORef data IORef a
01:20:37 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
01:20:42 <kmc> :t readIORef
01:20:44 <kmc> :t writeIORef
01:20:46 <lambdabot> Not in scope: `writeIORef'
01:20:46 <lambdabot> Not in scope: `readIORef'
01:20:58 <cads> please nobody correct my code, I think I need to actually study haskell if I'm going to hang out here an give people advice :P
01:21:00 <kmc> :t Data.IORef.readIORef
01:21:01 <lambdabot> forall a. GHC.IOBase.IORef a -> IO a
01:22:24 <Cale> cads: Patterns are tried in the order that you write them
01:22:25 <dnquark> kmc: actually, come and think of it, most likely I'll want to do something like sendMessage $ JumpToLayout "foo", where "foo" is determined by some state configuration
01:22:37 <kmc> which is an X-monad action, right?
01:22:44 <dnquark> so I guess it could return the value corresponding to update state
01:22:46 <dnquark> kmc: yes
01:22:56 <Cale> cads: So if you write a pattern which matches anything, and it's first in line, the rest won't get used.
01:23:23 <blackh> dnquark: One way to keep state in a function is for a function to return a "new version" of itself, that is, a function of the same type.  As long as the caller calls the new version each time, it can maintain state.
01:23:39 <kmc> dnquark, so you can use IO monad actions within the X monad
01:23:51 <kmc> by way of this function:  io :: IO a -> X a
01:23:57 <kmc> makes an IO monad action into an X monad action
01:24:09 <Cale> dnquark: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15110 -- I have an example of mechanically transforming imperative code into functional here :)
01:24:25 <kmc> Cale, i was looking for the simple guide to IO on the wiki
01:24:28 <kmc> and failing at search
01:24:36 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
01:24:53 <kmc> dnquark, see above ^^^
01:25:07 <kmc> a concrete treatment of IO which avoids the more general theory behind monads
01:25:31 <kmc> just be aware, if and when you do study monads in general, that IO is an atypical example of a monad
01:26:06 <dnquark> kmc: thank you; gonna go read through this now...
01:28:46 <kmc> :t forkST
01:28:47 <lambdabot> Not in scope: `forkST'
01:29:05 <kmc> would forkST be a reasonable thing to make?
01:29:17 <Cale> I don't think so, since you can runST and par
01:29:35 <Cale> Well, maybe that's what forkST does :)
01:29:57 <kmc> ah right, it would make runST nondeterministic
01:30:35 <kmc> like unsafeInterleaveST, but more so
01:31:30 * kmc wishes that nondeterminism and side effects were distinguished better
01:31:34 <kmc> from each other, i mean
01:33:03 * altmattr agrees
01:33:51 <Heffalump> nondeterminism is a side effect, though
01:33:58 <Heffalump> at least in the sense of making things impure
01:34:12 <altmattr> but not in the sense of needing to be kept in the same order
01:34:37 <kmc> Heffalump, what i mean by side effect is "observable from outside your program"
01:35:03 <kmc> although of course everything is observable with the right tools
01:35:08 <kmc> so it is somewhat a fuzzy line
01:35:37 <kmc> one of the roles of an operating system is to make rules about what things are observable outside a process under "normal" circumstances
01:35:56 <altmattr> regardless of what to call them, the have different characteristics which mean we want to treat them differently.
01:36:58 <kmc> yes
01:37:21 <altmattr> right now I am reading a phd thesis where someone tries to do this in the type system
01:37:25 <altmattr> interesting
01:37:28 <kmc> just as we've separated the ideas of effects/nondeterminism, argument dependence, and deferred evaluation
01:37:45 <kmc> which are i guess the three intermingled roles of functions in most langugaes
01:37:48 <kmc> maybe there are more
01:38:05 <kmc> encapsulation, sometimes
01:38:15 <kmc> that seems like a higher level concept
01:39:01 <kmc> but maybe not -- the fact that one can close over free variables is a fundamental property of functions
01:40:02 <altmattr> boiling down exactly what roles functions play is hard work
01:40:17 <altmattr> recognising that some have effects and some do not is easy
01:40:26 <altmattr> then just take the next easiest ;)
01:40:57 <altmattr> so far we have ....
01:41:02 * hackagebot upload: threadmanager 0.1.3 - Simple thread management (BrianLewis)
01:41:04 <altmattr> not much
01:43:31 <kmc> i see it the other way
01:43:40 <kmc> a mathematician will not agree that some functions have effects and some do not
01:44:37 <kmc> this part of Haskell's design involved taking apart earlier bad design decisions, not identifying new ones
01:45:06 <altmattr> well..... things get icky here
01:45:20 <altmattr> haskell tags every side effecting function with the type IO a
01:45:32 <altmattr> so it recogises this fact
01:45:37 <kmc> no
01:45:39 <kmc> IO is not just a tag
01:45:52 <kmc> the type constructors IO and (->) are completely orthogonal
01:45:56 <altmattr> i know it is really a type constructo
01:46:11 <kmc> and there are no "side effecting function"s
01:46:28 <altmattr> but if every side effecting funciton has it, and non-side effecting don't, then you can think of it as a tag
01:46:31 <altmattr> what do you mean?
01:46:40 <kmc> altmattr, evaluating a value never has a side effect.
01:46:44 <kmc> even a value of type (IO a)
01:46:48 <kmc> > putStrLn "hello world"
01:46:50 <lambdabot>   <IO ()>
01:47:27 <altmattr> you have lost me - how is putting a string to the console not a side effect?
01:47:52 <altmattr> the type system is placated by the fact that it is "modifying a world value" but this never actually happens
01:48:05 <kmc> altmattr, it is a side effect.  but *evaluating* (putStrLn "hello world") does not perform that effect
01:48:08 <altmattr> sorry, not modifying, createing a new one
01:48:12 <kmc> evaluating an effect is different from executing the effect
01:48:24 <kmc> this is important
01:48:32 <kmc> and it's why IO is not merely a tag attached to impure functions
01:48:39 <kmc> because evaluating a function application *never* has a side effect
01:48:41 <altmattr> right, but every haskell program has all of its effects executed
01:48:45 <kmc> note that getChar is not even a function!
01:48:46 <kmc> altmattr, no
01:48:54 <kmc> the effect named "main" is executed
01:49:01 <kmc> you can build other effects and throw them away
01:49:20 <altmattr> sure, but why are we talking about this?
01:49:39 <kmc> because you claimed that some functions have effects and some don't
01:49:56 <kmc> and i'm claiming that Haskell has a clearer picture of side effects by rejecting this idea
01:51:05 <kmc> plenty of languages allow you to tag a function as pure or impure, but they still muddle together "function" and "effect"
01:51:59 <kmc> from an advocacy point of view, "effect tagging" sounds like an annoying limitation, whereas "first-class side effects" sounds like a useful feature
01:52:03 <altmattr> here is how I understand it - ghc promises to evaluate one method only - main - a method with type IO.  It pretends to pass it a world parameter, but never does.  It simply evaluates the final value of the function and in the process calls some code that could cause changes to the "world" parameter.  Instead of actually cahnging a world paramter thought, it exectues the actions including side effects
01:52:33 <kmc> you're quite confused then
01:53:27 <kmc> sorry to be blunt
01:53:33 <altmattr> blunt is good
01:53:38 <kmc> but there are many things wrong with that description
01:53:40 <altmattr> but so is clarification :(
01:53:51 <kmc> would you like me to clarify?
01:54:03 <altmattr> please do
01:54:26 <kmc> so first of all, ignore the whole "world passing" idea for now
01:54:32 <kmc> that's actually a combination of two things:
01:54:46 <kmc> a) an idea of how you might build a toy model of the IO monad in pure Haskell
01:54:59 <kmc> b) a vague description of some low-level magical things that GHC does
01:55:07 <kmc> neither of these is part of the semantics of the IO monad itself
01:56:26 <kmc> hmm, i think i may have misunderstood you
01:56:39 <kmc> because it is actually an accurate description of that low level GHC magic
01:57:15 <kmc> so if that's what you were describing i apologize :)
01:57:21 <altmattr> indeed it was
01:57:24 <kmc> ah okay
01:57:39 <kmc> at that level, you're right that there are side-effecting functions
01:57:46 <kmc> and you can create new ones with unsafePerformIO
01:57:57 <altmattr> or with access to the compiler :)
01:58:11 <kmc> but those side effecting functions are *not* tagged with IO
02:00:11 <altmattr> putChar for example is provided by the compiler right? and the compiler gives it the type IO ()
02:00:19 <kmc> Char -> IO ()
02:00:29 <altmattr> yep
02:00:39 <kmc> it's a function that returns an IO action
02:00:43 <altmattr> and getChar is also provided by the compiler and has an IO type
02:00:56 <kmc> yes
02:01:04 <kmc> but it's not a function
02:01:23 <altmattr> as does every other function that returns an IO action (or an action that has a side effect or whatever)
02:01:37 <cads> double dang you know, now I want to know how ghc implements the IO monad, also I'm not sure if I believe it's a monad anymore
02:01:42 <kmc> i don't know what you mean by "has an IO type"
02:01:58 <altmattr> io type = IO a for some a
02:02:07 <altmattr> cads - it does not have to do much
02:02:10 <kmc> but that's not true of putChar
02:02:16 <kmc> the outermost tycon of putChar is (->)
02:02:49 <altmattr> as long as it ensures all the right functions get IO types and that the prelude includes a definition of the IO monad - all its work is done
02:03:12 <altmattr> OK, putChar 'a' then
02:03:22 <kmc> the presence of the IO tycon in the return value type does not alter how function application and evaluation works
02:03:29 <kmc> in particular it does not mean that function evaluation has a side effect
02:03:38 <kmc> okay, (putChar 'a') is an IO action
02:03:49 <altmattr> the point being that all funcitons (with necessary arguments to dispatch the collection of required data) that return actions with side effects have an IO type
02:03:55 <altmattr> and no others do
02:03:59 <Cale> cads: It *is* a monad, GHC's implementation does some evil, but there exist possible implementations in which IO actions are completely pure and the RTS contains an impure evaluator for them.
02:04:32 <kmc> altmattr, i can make an IO action without a side effect
02:04:45 <altmattr> true, the ghc does not provide any
02:04:52 <kmc> :t return ()
02:04:53 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
02:04:55 <kmc> that's one
02:04:58 <Spockz|lap> when defining folds, is it custom to name the folds foldDatatype our just datatype as is the case with maybe?
02:05:00 <altmattr> ghc == default haskell standard
02:05:21 <HaskellLove> what can MATLAB do that Haskell can not?
02:05:29 <kmc> get you laid
02:05:31 <altmattr> HaskellLove: heaps
02:05:36 <altmattr> too much to name
02:05:42 <altmattr> them all
02:05:53 <altmattr> but integration of polynomials for a start
02:05:59 <j4cbo> i really doubt that MATLAB can get one laid any more than Haskell can
02:06:11 <altmattr> very fast high precision arithmetic
02:06:17 <HaskellLove> it seems kmc gets laid with haskell
02:06:52 <kmc> @protontorpedo
02:06:52 <lambdabot> what is a good way to handle the ftp transfer and reading of files to mysql?
02:06:53 <kmc> @protontorpedo
02:06:54 <lambdabot> where was haskell during th internet boom?
02:06:55 <kmc> @protontorpedo
02:06:56 <lambdabot> how does haskell do with large systems?
02:07:00 <kmc> @protontorpedo
02:07:00 <lambdabot> wat is lazy evaluation?
02:07:49 <kmc> altmattr, i'm not really sure what we're talking about.  is it the details of how GHC implements the IO monad?
02:08:27 <altmattr> well, I was hoping to convince you taht witnessing actions by special values was a tricky thing and that there might be better ways
02:08:39 <altmattr> but we can't even agree on what an action is, so perhaps we should leave it :)
02:09:34 <kmc> ah
02:09:42 <j4cbo> don't try to convince anyone here that anything to do with haskell is less than perfect; it won't work :P
02:09:42 <bob0> j4cbo: no
02:09:49 <kmc> i thought you were arguing that functions returning actions are special functions
02:09:55 <kmc> the actions themselves are quite special, yes
02:11:15 <altmattr> j4cbo: I have about three such trollish ideas
02:11:25 <altmattr> I keep them quietly hidden most of the time
02:11:36 <kmc> and i don't doubt that a better account of side effects is possible
02:11:51 <kmc> in fact i think that's where we started, with separating side effects from nondeterminism, which Haskell does poorly
02:11:53 <cads> j4cbo: I could provide a counterexample to the matlab statement
02:12:00 <j4cbo> altmattr: you don't happen to like ML, do you? :P
02:12:12 <cads> note, more cute physics undergrads have to learn matlab than haskell
02:12:46 <altmattr> j4cbo: nope, can't stand writing let rec all the time
02:13:03 <altmattr> j4cbo: don't get me started on 'with' and 'and' in ml :)
02:13:13 <j4cbo> oh, ew, OCaml... i should have said SML
02:13:26 <j4cbo> altmattr: POP QUIZ: what does 'withtype' do?
02:13:40 <altmattr> j4cbo: I fail
02:14:33 <j4cbo> lets you make a 'type' declaration mutually recursive with a datatype
02:14:56 <altmattr> only a mother could love it
02:15:07 <j4cbo> yup.
02:16:02 <kmc> are 'type' declarations synonyms as in Haskell?
02:16:22 <j4cbo> yup
02:16:56 <altmattr> j4cbo: right now I am between liking languages :)
02:17:12 <altmattr> or should I say "liking a language"
02:17:36 <medfly> and>?
02:17:41 <j4cbo> i like a C-ish language that doesn't actually exist, and an SML-ish language that doesn't actually exist
02:17:52 <lament> what a coincidence, me too!
02:18:20 <lament> but i also like a smalltalkish language that doesn't actually exist, and a lisp that doesn't actually exist.
02:18:37 <ivanm> I find this quote (context: a Java implementation of Git) interesting: "I imagine a Git-in-Haskell would be very close in performance to the C git. (Then why is Darcs so slow? Because it uses an icky imperative, mutable model, whereas git uses a immutable functional model.)"
02:19:11 <kmc> hahaha
02:19:17 <lament> but darcs is designed by a *physicist*! And it's using an *algebra* of patches!
02:19:21 <ivanm> heh
02:19:23 <altmattr> ivanm: I find it inscrutable
02:19:24 <kmc> a *quantum algebra*
02:19:35 <ivanm> altmattr: what do you mean?
02:19:58 <cads> Q algebra? For real?
02:20:17 <altmattr> first of all, do we agree or disagree?  if disagree, what bit? all of it?  it just seems nonsensical from start to finish
02:20:18 <ivanm> lament: I wonder if Igloo's camp would be much better in that the algebra of patches is fully thought out from the beginning rather than being hacked on as droundy wrote darcs...
02:20:54 <altmattr> so the darcs people still haven't filled in the "theory of patches" yet?
02:20:58 <ivanm> altmattr: I just found it interesting; the first bit is probably true, but I have no idea whether the imperative vs functional bit is
02:21:06 <ivanm> altmattr: nope, not fully AFAIK
02:21:23 <ivanm> I _think_ Igloo is doing that as part of camp; he's doing Coq proofs and everything!
02:21:23 <altmattr> I find the idea of reimplimentind git in other langauges amazing
02:21:24 <ivanm> @where camp
02:21:25 <lambdabot> I know nothing about camp.
02:21:28 <lament> what does darcs mutate that git doesn't?
02:21:30 <ivanm> @where+ camp http://projects.haskell.org/camp/
02:21:31 <lambdabot> It is stored.
02:21:45 <ivanm> lambdabot: the patch application I guess, where it keeps "mutating" the state by applying patches
02:21:50 <ivanm> rather than just getting the current state
02:21:57 <ivanm> (that is, when pulling, etc.)
02:22:12 <lament> oh
02:22:31 <lament> that certainly sounds like a performance killer
02:22:44 <lament> though it's not really an imperative vs functional issue
02:22:46 <cads> I mean, icky - imperative - mutable .... that is Q algebra for ya :D
02:23:47 <ivanm> camp doesn't seem to have had any work on it recently (as in the past year) though from a quick look at the timestamps in the darcs repo :(
02:25:10 * cads is marvelling to find out how steep the theoretical background of darcs is
02:25:36 <altmattr> the camp page gave me an ad for a place I visited today - google scares teh crap out of me
02:25:56 <ivanm> altmattr: firefox + customizegoogle + adblock plus + remove it permanently ;-)
02:25:57 <cads> we don't talk like that anymore, actually
02:26:08 <ivanm> cads: like what?
02:26:23 <cads> ivanm: SHHH... THEY'LL hear us!
02:26:28 <ivanm> ...
02:26:31 <cads> hehe :D
02:26:31 <ivanm> @slap cads
02:26:32 * lambdabot puts on her slapping gloves, and slaps cads
02:26:52 <altmattr> I always thoughto f lambda bot as a man
02:26:59 <andrewe> Shouldn't gtk2hs be included in Haskell platform?
02:27:00 <ivanm> @where lambdabot
02:27:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
02:27:07 <ivanm> andrewe: no, not yet
02:27:09 <stoop> Why?
02:27:18 <cads> altmattr: what ivanm says is true, there is also a greasemonkey script which will stop google tracking
02:27:20 <ivanm> andrewe: first of all, the current implementation of the platform is just the old extralibs
02:27:24 <stoop> Why is that thing which depends on GLUT in the Haskell platform ivanm?
02:27:28 <stoop> I mean, very few applications use it.
02:27:37 <stoop> It seems the only reason is that some course uses it or something.
02:27:39 <ivanm> stoop: secondly, gtk2hs doesn't/can't use cabal
02:27:45 <ivanm> which the platform uses for everythign except ghc
02:27:51 <stoop> No, I'm not taking about gtk2hs.
02:28:01 <stoop> I'm talking about some GL interface.
02:28:06 <stoop> OpenGL interface, that is.
02:28:07 <ivanm> oh, whoops, that was aimed at andrewe
02:28:10 <andrewe> It would be nice to have a cross platform UI toolkit in it.
02:28:22 <ivanm> stoop: because it was part of extralibs
02:28:30 <andrewe> ivanm: I guessed that it was aimed at me. :-)
02:28:31 <kmc> @vixen what's your name?
02:28:32 <stoop> I wish the platform remains slimmed down, just enough for us to use cabal install, etc...
02:28:32 <lambdabot> My name is Emily
02:28:36 <ivanm> andrewe: heh
02:28:39 <stoop> It'll make porting it much easier.
02:28:41 <ivanm> kmc: :o
02:29:12 <andrewe> I just want to use gtk2hs with Mac OS.
02:29:15 <ivanm> stoop: I think in the future the platform will come in two parts: the actual platform containing commonly used base libraries (mtl, etc.), and then a "recommended libraries" list
02:29:18 <andrewe> Anyone uses that?
02:29:19 <ivanm> andrewe: then install it!
02:29:27 <stoop> ivanm, ok, I hope.
02:29:33 <andrewe> How? With cabal?
02:29:35 * ivanm randomly guesses that something like macports would have it
02:29:52 <ivanm> stoop: after all, not everyone would want a high-level graph library or something, etc.
02:29:58 <Athas> I thought mtl was being deprecated?
02:30:00 <ivanm> basically, the platform should be enough for you to get hacking
02:30:12 <ivanm> Athas: it is deprecated, but there's no clear consensus on its replacement
02:30:16 <ivanm> so everyone keeps using mtl
02:30:24 <stoop> andrewe, manual install. See http://haskell.org/gtk2hs/
02:30:27 <Vitka> Hello.
02:30:37 <stoop> ivanm, yes, exactly.
02:30:40 <ivanm> HP-2009.* == ghc + extralibs
02:30:59 <andrewe> stoop: :-(
02:31:03 <ivanm> stoop: of course, the problem is, what is a minimum number of libraries? _should_ we include a GUI toolkit in there?
02:31:13 <stoop> ivanm, personally, I don't think so.
02:31:27 <ivanm> (in which case, maybe something like wxhaskell would be preferable since its more cross platform; however, the problem with most GUI toolkits is that they need a C lib)
02:31:29 <stoop> ivanm, because not all operating systems or environments have a graphical environment (it definitely isn't necessary on most *nix platforms).
02:31:39 <ivanm> stoop: well, some people might because a lot of them do GUI apps...
02:31:42 <stoop> ivanm, for example, this is why I didn't use HP for a server application.
02:31:51 <ivanm> stoop: true; I'm just saying what some peoples opinions might be
02:32:01 <ivanm> bbl
02:32:34 <stoop> ivanm, maybe if cabal offered support for binary packages...
02:32:48 <stoop> ivanm, which is non-trivial. :-(
02:33:02 <stoop> But generally, I agree, it's all SamB_XP's fault.
02:33:04 <stoop> ttyl
02:33:14 <Vitka> Can anyone assist me with a tiny program? It gives proper output when main is interpreted in GHCi but does not when it compiled in GHC.
02:34:01 <blackh> Vitka: Sure. Paste it into the Haskell pastebin and we'll take a look.
02:34:14 <Vitka> Ok,thanks.
02:35:26 <Heffalump> one explanation (aside from a GHC bug) is defaulting: ghci does it differently
02:36:14 <Heffalump> one possible explanation, that is
02:36:22 <Vitka> blackh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15522
02:37:03 <Vitka> Compiled binary gives 1, main in GHCi seems to work alright.
02:38:36 <HaskellLove> is there anything equavalent to PolySpace in Haskell? PolySpace is verification software, finds potential errors in code without compiling it
02:38:46 <medfly> ...
02:39:02 <medfly> HaskellLove: wrong language
02:39:21 <fabjan> Vitka: takeWhile will stop as soon as you find some element that doesn't satisfy the predicate
02:39:48 <altmattr> HaskellLove: nope, nothing like it
02:39:50 <lament> HaskellLove: just compile it and then delete the executable
02:39:59 <HaskellLove> medfly so basically type checking is equavelnt i guess?
02:40:33 <Adamant> HaskellLove: verification is pretty broad
02:40:33 <medfly> woah, left hand delay
02:40:56 <Adamant> HaskellLove: type checking takes care of some verification stuff
02:41:02 <HaskellLove> I see...
02:41:03 <altmattr> HaskellLove: not equivalent to PolySpace, but certainly we claim the strong type checking in haskell makes something like polyspace less usefull/unecessary
02:41:07 <Heffalump> Vitka: I get the same answer from ghci and from ghc (266333)
02:41:36 <Adamant> more complex type systems can end up being equivalent to theorem and program provers
02:41:39 <stoop> > let multsOfLessThan n m = takeWhile (<m) (map (*n) [1..]) in (sum $ multsOfLessThan 3 1000) + (sum $ multsOfLessThan 5 1000)
02:41:39 <lambdabot>   266333
02:42:11 <medfly> uhh
02:42:27 <medfly> is this something about multiples of 3 and 5, I should point out there's 15
02:42:37 <stoop> medfly, this isn't my code. :-)
02:42:47 <stoop> medfly, and I'd rather not give out the solution.
02:43:07 <medfly> sorry
02:44:03 <Vitka> Hmm.
02:45:42 <stoop> > [3, 6 .. 1000]
02:45:43 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
02:45:48 <stoop> > [5, 10 .. 1000]
02:45:49 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,12...
02:46:31 <Vitka> Hmm.
02:46:38 <stoop> > [x * y | x <- [3, 6 .. 1000], y <- [5, 10 .. 1000], x * y < 1000]
02:46:39 <lambdabot>   [15,30,45,60,75,90,105,120,135,150,165,180,195,210,225,240,255,270,285,300,...
02:47:26 <blackh> Vitka: My computer is screwing up.  I'll be back in a minute.
02:48:05 <paolino> Vitka , you need a merging function for 2 lists into one that has no duplicates
02:48:12 <stoop> No.
02:48:43 <Heffalump> at the moment we're just trying to figure out why Vitka gets a different answer from ghc
02:48:50 <paolino> ops
02:48:52 <Heffalump> rather than help with fixing the code itself
02:49:19 <stoop> Vitka, what operating system are you on?
02:49:27 <stoop> Vitka, can we see the output of "ghc --version"?
02:49:52 <Vitka> Good point, paolino, but that I should've found out myself. :) Just one minute.
02:50:58 <paolino> at least I didn't write it for you :-)
02:51:14 <Accidus> Hmm...? Did anyone say something about endofunctors and Goedel encoding?
02:51:29 <blackh> Vitka: Well, the good news is my computer works, so maybe I can help you after all. :)  So what ghc version have you got?
02:51:42 <medfly> @quote endofunctor
02:51:42 <lambdabot> elly says: I leave for five minutes and godel numbering of endofunctors is invokved as a potential proof that the universe is simulated. Thanks, #haskell :P
02:52:15 <Accidus> @quote godel numbering
02:52:15 <lambdabot> No quotes for this person.
02:52:23 <Accidus> @quote "godel numbering"
02:52:23 <lambdabot> No quotes for this person. :(
02:52:29 <Accidus> @quote endofunctor
02:52:30 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
02:52:33 <Accidus> @quote endofunctor
02:52:34 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
02:52:39 <Accidus> @quote endofunctor
02:52:39 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
02:52:43 <Accidus> Hrmph/
02:52:43 <stoop> Stop?
02:52:53 <Accidus> Sorry
02:52:54 <medfly> no, stoop.
02:52:56 <medfly> :)
02:52:56 <stoop> :-P
02:53:09 <Accidus> I'll go and dig up the logs.
02:53:21 <Vitka> GHC 6.10.4, Win32, running on Win7 x64.
02:53:26 <lament> @quote thermo
02:53:27 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
02:54:02 <cads> cale, kmc, pictures for sad children is the most damn depressing comic I've ever read, impressive :D
02:54:29 <stoop> paolino, (note that this can be done O(n)).
02:54:59 <paolino> stoop , did I said the opposite ?
02:55:20 <cads> @quote PhilipWadler
02:55:20 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
02:55:30 <stoop> paolino, yes.
02:55:35 <cads> heh, that's funny because of who philip wadler is
02:55:45 <medfly> who is philip wadler
02:55:50 <stoop> paolino, unless your merge function is magical. :-P
02:55:52 <Accidus> :)
02:56:01 <Accidus> medfly, A researcher
02:56:12 <Accidus> medfly, One of the designers of Haskell
02:56:15 <Vitka> Added ghc and ghci output to http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15522#a15523
02:56:19 <medfly> oh, ok
02:56:31 <paolino> stoop, lists are alreay ordered, there is nothing magical
02:56:32 <Accidus> medfly, Head of LFCS (respekt!)
02:56:39 <medfly> Vitka: do you have anything else loaded or something.
02:56:53 <btutt> Is there a language extension to make this error shut up? is not a (visible) field of constructor `A.Author' the module.hs file exports Author(..)
02:56:54 <medfly> :load magicalThingThatBreaksALotOfStuff
02:57:45 <medfly> Vitka: also, someone said trhis one time that ghc might prefer some other files if say you have 001.o or something
02:57:50 <medfly> and not the 001.hs file
02:58:11 <medfly> something of this sort
02:58:13 <Heffalump> wait a sec
02:58:14 <kmc> @quote stare.at
02:58:14 <lambdabot> PhilipWadler says: To see that "in" and "out" are inverses, stare at the following diagram
02:58:17 <Heffalump> what if you call it 002?
02:58:27 <stoop> paolino, well, my point is it's unnecessary for something so trivial.
02:58:38 <stoop> paolino, and yes, you're right...nothing magical. :-P
02:58:56 <cads> haha, kmc, when was this philipwadler charachter here?
02:59:00 <Vitka> I cleaned up .o's and stuff manually, but I'll try again with different name.
02:59:04 <Heffalump> FWIW it works ok for me on windows (XP, 32 bit) with GHC 6.10.4, but I don't have precisely the platform above
02:59:14 <Heffalump> Vitka: I'm just wondering if something is interpreting the command name as an expression
02:59:50 <Vitka> Ahaha, thanks Heffalump.
02:59:55 <stoop> hehe
03:00:22 <Vitka> Stupid Powershell interpreted 001 as 1, should've used ./001
03:00:51 <paolino> maybe ass "." to the PATH if there is one in windows
03:01:00 <paolino> s/ass/add
03:01:04 <stoop> Bad habit. :-P
03:01:13 <paolino> :)
03:01:25 <Vitka> But then again, I can use ls insted of dir, which is good. :)
03:11:44 <kamatsu> i have a C function that takes a pointer to a surface, and returns a pointer to a new surface that has been transformed
03:12:05 <kamatsu> am I allowed to make that into a pure function in haskell?
03:12:33 <kamatsu> it's not exactly referentially transparent as the pointers it returns are different, but what they point to represents the same stuff
03:15:04 <kmc> kamatsu, it depends where you are drawing the API line
03:15:35 <kmc> presumably you expose some opaque datatype so that Haskell users can't e.g. deref the pointer themselves
03:15:44 <kamatsu> yes, that's right
03:15:56 <kmc> in which case, i think the standard practice is to make the foreign imports return IO actions
03:16:02 <kmc> and wrap your wrappers in unsafePerformIO
03:16:17 <kmc> because they may need to do allocation and pointer manipulation in addition to the foreign call
03:16:52 <kamatsu> right
03:17:10 <kmc> in the FFI chapter in RWH they do this; that's pretty much my only basis for claiming it's standard practice
03:17:29 <matsuura> kamatsu: are you pretty badass when it comes to group/category theory?
03:18:17 <kamatsu> matsuura: er, not really, but i have enough knowledge to write haskell and use monad transformers
03:18:23 <kamatsu> i know what a monoid and an endofunctor is
03:18:46 <matsuura> okay.
03:19:04 <kmc> zero knowledge of group or category theory is required to write haskell and use monad transformers
03:19:12 <kamatsu> well, true
03:19:29 <kamatsu> but i did learn the parts of category theory i could understand that pertain to those topics
03:20:21 <kamatsu> matsuura: why do you ask?
03:20:32 <kmc> i understand how a CT monad and a Haskell monad are the same thing, but i have no use for this fact other than to impress my mathematician friends and scare other people
03:20:52 <matsuura> kmc: never said it was.. I just wanted to know.. haskell duders are ones to know
03:21:15 <kmc> yup, there are some CT badasses who hang out here
03:21:24 <kmc> you can try #math too
03:21:29 <matsuura> too risky
03:21:34 <kmc> ehehe
03:21:56 <matsuura> math can be logical which is philosophical, which results in ban
03:22:02 <matsuura> if you argue that it's math
03:22:08 <matsuura> soo
03:22:53 <Accidus> matsuura, You'll only be banned if you were warned first
03:23:05 <Accidus> And category theory is appreciated in #math (and here as well, I guess)
03:23:12 <Adamant> Accidus: generally they make fun of the person they want to ban and then they ban them
03:24:34 <Accidus> Adamant, I haven't come across that before. In any case, if you're worried about getting banned that you'll probably notice the signs when that's actually going toh appen.
03:25:22 <matsuura> still, interest is interest and to be told you can't talk about something because it's off topic when you know it's not, makes you wonder why you even bothered to ask
03:25:23 <Accidus> Asking "can I ask a question about category theory? I wouldn't like to get banned for philosphising" is more likely to get ridiculed than actually asking the category theoretical question
03:25:41 <matsuura> anyhow, I should get on with the questions
03:25:44 <Accidus> matsuura, Did anyone actually told you that CT is off topic?
03:25:48 <Accidus> * tell
03:25:49 <matsuura> yes
03:25:55 <Accidus> Really?
03:25:57 <matsuura> yep
03:26:04 <matsuura> didn't make sense
03:26:06 <matsuura> CT and CS
03:26:07 <Accidus> I'd love to hear the question then
03:26:21 <matsuura> oh, it's multiple, just to confirm understanding
03:26:35 <matsuura> that's what it was, CT being CS
03:26:36 <Accidus> matsuura, Just ask...
03:26:36 <matsuura> lol
03:26:54 <Accidus> Asking whether you can ask can be more annoying than OT
03:27:01 <matsuura> yeah... >_>
03:27:09 <matsuura> permission sir, permission
03:28:41 <matsuura> anyhow, does each object of set G require an element for x/y of set G?
03:28:48 <matsuura> if so, why is this?
03:29:17 <matsuura> might be obvious, sure, but I was not told why it cannot be
03:29:19 <Accidus> Erm, what does that mean?
03:29:27 <matsuura> umm
03:29:34 <Accidus> What's an object of a set?
03:29:43 <Accidus> And what's x and y in x/y?
03:30:06 <matsuura> for G(x,y), does an element have to exist for G(x) and G(y)?
03:30:31 <Accidus> Nope. Still don't understand what you're talking about.
03:30:37 <matsuura> o_o
03:30:40 <Accidus> G is a set?
03:30:43 <matsuura> yes
03:30:48 <Accidus> What are x and y?
03:31:20 <matsuura> objects
03:31:40 <Accidus> In which category/
03:31:41 <Accidus> ?
03:31:59 <matsuura> G... ?
03:32:05 <matsuura> correct me if i'm wrong
03:32:08 <Accidus> Go G is a category, not a set?
03:32:17 <matsuura> Why not a set?
03:32:29 <Accidus> A category and a set are two different concepts
03:32:40 <Accidus> So G is a category
03:32:47 <Accidus> and x, y are objects in G
03:32:54 <Accidus> G(x,y) are all the morphisms from x to y
03:33:04 <matsuura> Then why am I over complicating this?
03:33:10 <matsuura> o.o
03:33:21 <Accidus> I was confused by the terminology.
03:33:35 <Accidus> If you mean a category, say so. Saying 'set' is not the same as saying 'category'.
03:33:39 <Accidus> So what's the question again?
03:34:10 <matsuura> if an element must exist for objects x and y
03:34:27 <Accidus> Exist where?
03:34:42 <Accidus> in G(x,y)?
03:34:49 <matsuura> for x and y
03:35:04 <Accidus> So your question is: Do any pair of objects x, y in a category G have an arrow x --> y?
03:35:15 <matsuura> no
03:35:20 <matsuura> blah.. brb
03:35:23 <Accidus> So what is your question?
03:35:29 <matsuura> Accidus: I can't ask it
03:35:41 <matsuura> need to go through notes
03:36:01 <matsuura> perhaps i'm confusing something with groupods
03:36:19 <matsuura> groupoids
03:36:21 <Accidus> matsuura, Perhaps.
03:36:33 <Accidus> matsuura, although it doesn't seem to make sense for groupoids either
03:37:17 <matsuura> Accidus: mind if I PM?
03:37:46 <Accidus> Yes. Why should you PM?
03:38:19 <matsuura> so that I don't get mixed answers from anyone or flood channel with stuff that isn't haskell
03:38:43 <Accidus> Well, that sounds more like #math question anyway.
03:39:03 <Accidus> And you can always /ignore/ people's answers
03:39:15 <matsuura> *cough* ban
03:39:21 <matsuura> etc
03:39:25 <matsuura> anyway...
03:39:51 <Accidus> You're not banned, I can see you in #math...
03:39:53 <ivanm> Accidus: how is CT off topic?
03:40:02 <ivanm> Cale brings it up all the time...
03:40:07 <ivanm> @where awodey
03:40:13 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
03:40:45 <matsuura> Accidus: I mean, from here..
03:41:03 <Accidus> ivanm, I guess it depends on what kind of CT. And groupoids is probably more related to #math. But I guess both channels are alright
03:41:13 <Accidus> matsuura, you're not going to get banned without a warning, so just ask
03:41:37 <Accidus> matsuura, I swear, your fear of getting banned for off topic is more annoying than being off topic
03:41:51 <ivanm> Accidus: AFAIK, the off-topic policy here is that as long as there's no on-topic discussion (and there's about 15 min of just you two talking), off-topic is OK
03:42:10 <matsuura> Accidus: cool, thanks
03:42:38 <Accidus> ivanm, Yeah, that's what I figured
03:46:00 <Accidus> matsuura, so... after this tiresome introduction --- what's the question?
03:47:11 <matsuura> Accidus: I told you I have a series of questions.. You've already answered one, now I continue to study until I need to ask the next. :)
03:47:14 <matsuura> Thanks
03:47:23 <Accidus> ah
03:47:28 <ivanm> *cough* textbooks *cough*
03:47:35 * matsuura shrugs
03:56:19 <medfly> I'm told it's okay to talk about non-Haskell things, as long as they're CS or maths
03:56:56 <Adamant> ivanm: I snagged that one a while ago :)
03:57:07 <ivanm> heh
03:57:25 <Adamant> ivanm: how I just have to get through the gobs of other math books I need to read
03:57:33 <Adamant> at least I'm making progress lately, thogh
03:57:56 <ivanm> yes, I've been having fun trying to hint to someone that they should go through some tutorials rather than pestering us here on how to solve project euler problems... >_>
03:58:53 <Jafet> @quote haskelllove
03:58:53 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
03:59:22 <Adamant> I've been thinking about stuff in relation to document/information management
03:59:30 <ivanm> Jafet: omg, how'd you guess who I was talking about?!!?!?!?
03:59:31 <ivanm> ;-)
03:59:46 <Adamant> I kind of want to type documents
03:59:48 <Jafet> Eh? I was just searching for quotes by a random user
03:59:56 <Adamant> like, say, academic papers
04:00:18 <Adamant> and have various subtypes for the different types of academic papers
04:00:19 <kmc> @protontorpedo
04:00:19 <lambdabot> is haskell more powerful than any jedii?
04:01:21 <ivanm> Jafet: ORLY...
04:01:28 <Adamant> do I have to start getting into higher-order type funkery if I wanted to represent that in Haskell, or is there some easy answer I don't know about, or is my only tool a type system and everything is looking like a nail
04:01:50 <kmc> haskell doesn't do subtyping
04:02:15 <Adamant> kmc: any resources on who does and why Haskell doesn't?
04:02:34 <kmc> don't know about that
04:02:43 <kmc> TaPL has a treatment of the theory of subtyping
04:02:49 <Adamant> alright
04:02:50 <Adamant> thanks man!
04:02:53 <kmc> :)
04:03:47 <Jafet> Not sure why you want to embed a flexible ontology inside a static type system
04:04:03 <Adamant> Jafet: yeah, it was probably a bad idea
04:05:21 <Adamant> been looking at various information at rest managers, like ebook databases, paper databases for scientists, technical paper managers, etc.
04:06:13 <Adamant> the problem is I do a little of a lot of stuff, at minimum, I want one manager to manage it all, and not end up loading 7 different management apps depending on what I am doing
04:07:28 <kmc> it's a fine idea to write this in Haskell
04:07:29 <Adamant> wondering if I can create some kind of very general engine and then have views off of it that will be appropriate for people in different fields, and be able to mix and mesh the views for folks from different fields working together
04:07:30 <Jafet> Well, you could write a perl hack that glues those seven apps together
04:07:46 <Adamant> kmc: that's actually the idea
04:08:35 <Jafet> So you want, more or less, an application that lets you store, categorize, index, search through and retrieve content
04:08:41 <Jafet> ...okay.
04:08:42 <kmc> even without representing any metadata in the Haskell type system
04:08:44 <Adamant> yeah yeah, search engine
04:10:34 <Adamant> the problem is I know what I want, but I don't know a lot about information management/document management/etc. type apps yet
04:11:05 <Adamant> I don't even know what the commercial SOTA is
04:13:36 <Phyx-> 08:05:10 [freenode] DCC SEND from bear [0.0.0.0 port 0]: \u043f\u043e\u0266\u029e\u0254\u043f\u025f [0B bytes] requested in channel #haskell
04:13:39 <Phyx-> <-- WTF
04:15:35 <Jafet> Phyx-, cosmic thermal noise, kindly ignore
04:15:38 <kmc> hax
04:15:57 <Phyx-> Jafet: hehehe
04:16:48 <Jafet> Adamant, well, write what you want.
04:16:57 <Jafet> You certainly can't do better than that.
04:18:14 <Heffalump> Phyx-: I got it too, FWIW
04:24:51 <Phyx-> Heffalump: yeah, I got it while I was asleep, wonder what it was trying to do
04:30:50 <paolino> Adamant: possibly use RDF for everything
04:33:19 <Liskni_si> Phyx-: I think certain routers/firewalls may drop the connection, so this is a DoS attempt
04:38:42 <Phyx-> Liskni_si: ah
04:39:50 <Liskni_si> Phyx-: and indeed some 10 users were affected by this if you look at the backlog
04:45:46 <Phyx-> Liskni_si: lol, hehe
04:58:12 <Zeiris> First off: yay Haskell! Second, how big a difference is there performance-wise between working with Ints, and working with a fancy data type that has a unique Int id which is used in custom Eq/Ord instances I wrote?
04:59:24 <Jafet> ...profile them?
05:00:17 <ivanm> Zeiris: if you use a newtype wrapped around Int, then there should be no runtime difference
05:00:29 <ivanm> if you use data, then there will be a slight overhead due to wrapping/unwrapping
05:01:29 <Zeiris> But the overhead is basically equivalent to a pointer dereference, and has no hidden surprises I'm not aware of. Thanks :) (I'll probably try and find a way to profile it once I have enough code written.)
05:01:41 <mxc> dynamic typing sucks: http://yehudakatz.com/2010/01/02/the-craziest-fing-bug-ive-ever-seen/
05:02:07 <ivanm> to profile: compile with -prof -auto-all -caf-all, then run with +RTS -p
05:02:16 <ivanm> that will produce a text file with profiling information
05:02:58 <Zeiris> Last time I tried GHC whined about HDBC not having the source files installed and spoiled my fun :(
05:03:23 <ivanm> Zeiris: yeah, you need to have the libraries you use have profiling support
05:03:39 <ivanm> if you use cabal install, then there's a config option in ~/.cabal/config that you can use to set that
05:04:00 <Jafet> There's good ol' time
05:04:25 <kamatsu> with the ffi, how can i deal with functions that return raw structs?
05:04:57 <kamatsu> i have a storable instance
05:05:28 <ivanm> Jafet: oh, for simple "which one is faster", yeah
05:05:34 <ivanm> or, to get fancy, criterion! ;-)
05:06:30 <ivanm> Bynbo7: going to use your real nick now?
05:07:36 <Jafet> Guess not,.
05:07:47 <ivanm> well, he switched...
05:07:52 <ivanm> so I guess he is
05:09:04 <kamatsu> ghc keeps giving me "unacceptable result type in foreign declaration"
05:09:35 <kamatsu> but google and docs only seem to give information about what to do when it returns a _pointer_ to the struct
05:10:01 <kamatsu> when it returns a raw struct by itself, what do i do? it's very perplexing
05:10:10 <Zeiris> ivanm, thanks for the ./cabal/config tip :)
05:10:18 <ivanm> no worries
05:10:38 <jlouis> mxc: it is more like Ruby has some rather nasty open recursion semantics
05:10:40 <Axman6> maybe you could make a wrapper function which recieves the pointer, dereferences it, and returns it?
05:10:58 <ivanm> Axman6: and then a wrapper function around _that_! ;-)
05:11:09 <Axman6> if needed
05:11:44 <ivanm> heh
05:11:46 <Gracenotes> FFI doesn't seem to like structs-as-byte-representations so much if I recall
05:12:11 <matsuura> woo, I forgot how fun haskell was
05:12:23 <Axman6> how could you forget? :o
05:12:26 <Gracenotes> you just consume them like they were word arrays, not like having actual fields
05:12:27 <matsuura> not sure
05:12:49 <ivanm> Axman6: by being seduced by the dark side (money, etc.)
05:13:46 <Zeiris> I'm very pleased with Haskell so far. I'm nowhere near as fast going from idea to working implementation with it as with Python, but the type system has made me think in many new, better ways. Without it, I'd probably still be thinking of costs in search problems as integer values, and trying to think about complex problems by looking at operations rather than data :D
05:14:27 <Zeiris> This channel is one of the things I have to thank for that :)
05:14:34 <Axman6> data is the key to great programs
05:14:40 <jlouis> Zeiris: here is the crux: when you have an initial Haskell program chances are that it is "fast enough" with optimizations enabled
05:15:20 <Jafet> The flip side is, it's never fast enough once it rolls out the door
05:16:53 <matsuura> that's a lie
05:19:48 <matsuura> so writing a bot in haskell is not something that any one would find suprising, right..?
05:19:58 <matsuura> seems to make such things very very very very non-complicated
05:19:58 <matsuura> o_o
05:20:44 <Axman6> matsuura: it's a good thing to learn a lot about different parts of haskell with
05:21:49 <jlouis> a bot?
05:21:57 <jlouis> IRC bot?
05:21:59 <matsuura> jlouis: chatbot or something
05:22:30 <jlouis> That sounds like an excellent task, altough it might be somewhat big
05:23:28 <koeien37> not really
05:23:42 <Axman6> there's a wiki article on how to get started in fact
05:23:55 <koeien37> if you want to use the irc package, it's quite simple
05:23:59 <Axman6> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
05:24:03 <matsuura> -_-'
05:24:15 <matsuura> thanks guys
05:24:18 <matsuura> I love you
05:24:21 <koeien37> my small IRC bot is 110 lines
05:24:30 <koeien37> including whitespace
05:24:43 <koeien37> and it can probably be shorter & cleaner
05:25:43 <matsuura> yeah
05:26:01 <matsuura> where's the love?
05:33:27 <HaskellLove> matsuura here is the love dont cry, it is me HaskellLove
05:34:56 <Axman6> have you stopped wasting your time on project euler yet HaskellLove?
05:35:10 <nazgjunk> How's that a waste?
05:35:27 <HaskellLove> i dont see waste there sorry
05:35:36 <koeien37> it's one-sided
05:35:43 <koeien37> if you're interested in it, fine, sure, go ahead
05:36:01 <Axman6> because he refuses to learn haskell, and is wasting his time just doing project euler, without learning what using haskell is all about
05:36:17 <HaskellLove> Zeiris yeah that was like a BIG AHA moment for me too man, functional programming is all about DATA and not going STEP BY STEP like the imperative way of doing things
05:36:17 <Axman6> i have no problem with project euler
05:36:22 <medfly> is he at least doing it by himself now?
05:36:53 <medfly> major improvement if so!
05:37:00 <Axman6> indeed
05:37:09 <Axman6> but he still won't learn anything
05:37:09 <medfly> I can't complain then :D
05:37:28 <Zeiris> What -is- using Haskell about?
05:37:41 <koeien37> about monads, of course!!!11
05:37:45 <medfly> not solving project euler problems, that's for sure.
05:37:47 <Axman6> how to compose programs, how to think about things at a high level
05:37:57 <HaskellLove> i am too stupid for monads right now
05:37:58 <cytzol> writing tutorials for.
05:38:12 <koeien37> fix ("write a tutorial for " ++) ++ "monads"
05:38:23 <medfly> needs a >
05:38:26 <Axman6> HaskellLove: why do you think that is? you haven't bothered to learn them yet have you?
05:38:26 <Zeiris> I'm totally gonna write another monad tutorial in a week or so.
05:38:30 <koeien37> i know, wasn't sure if it typechecked
05:38:49 <idnar> Axman6: getting a grip on the general terrain before you head off isn't an entirely bad idea, in my book
05:39:14 <Axman6> idnar: nor mine, project euler is how i learnt to use haskell initially, after being taught it at uni
05:39:20 <koeien37> right. project euler is fine to get started with imo :)
05:39:23 <Axman6> but HaskellLove is going about it the wrong way
05:39:30 <cytzol> Axman6: you were taught it?
05:39:41 <idnar> Axman6: well, the main thing I got out of doing PE problems in Haskell was learning to read and write Haskell syntax
05:39:46 <HaskellLove> Axman6 well i read haskell books and stopped at monads sections, it scared me a loot
05:39:55 <Axman6> intending to consume a year or two of your life solving every problem on project euler will not teach him haskell. it will teach him a lot of maths however
05:39:58 <ivanm> HaskellLove: don't stop
05:40:05 <koeien37> there is no need to get scared by them. You will need a firm grip of type classes
05:40:10 <ivanm> Axman6: I doubt it would even teach him that
05:40:12 <medfly> Axman6: A YEAR OR TWO? :)
05:40:21 <koeien37> I'd start with Functor, maybe?
05:40:22 <ivanm> s/TWO/TEN/
05:40:30 <idnar> medfly: there are a lot of problems on Project Euler :P
05:40:31 <ivanm> koeien37: just go through the typeclassopedia?
05:40:35 <ivanm> @where typeclassopedia
05:40:36 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:40:36 <Axman6> over 260
05:40:39 <ivanm> HaskellLove: ^^ have a look at that
05:40:45 <koeien37> well, yeah, if you can understand it, it's fine
05:40:51 <medfly> if you think it's good for learnin' maths, maybe I'll try to do project euler problems :P
05:40:53 <koeien37> i can imagine it a bit too advanced and abstract
05:40:53 <paolino> @hoogle bool
05:40:54 <lambdabot> module Data.Bool
05:40:55 <lambdabot> Test.HUnit.Base assertBool :: String -> Bool -> Assertion
05:40:55 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
05:41:03 <cytzol> I've done enough Euler problems to earn a four-sided pyramid. I feel so accomplished
05:41:21 <cytzol> *tetrahedron
05:41:22 <koeien37> and the crazy thing is, for Euler they were probably all trivial
05:41:41 <ivanm> cytzol: well, saying "four sided tetrahedron" is a little redundant
05:41:56 <cytzol> ivanm: I know, I just forgot its name temporarily
05:41:57 <Alpounet> Axman6, your blogpost is interesting
05:41:58 <HaskellLove> i know a guy who solved 50 eulers in 3 days ... frickin crazy...
05:42:04 <ivanm> cytzol: as did I ;-)
05:42:08 <koeien37> it's not "frickin crazy"
05:42:09 <Axman6> Alpounet: which one?
05:42:11 <koeien37> lots of them are trivial
05:42:12 <cytzol> the word in my head was "tesseract"
05:42:15 <Alpounet> Axman6, the last one
05:42:29 <Axman6> i'll have to post some code soon. i might do that tomorrow
05:42:30 <ivanm> cytzol: yeah
05:42:39 <Alpounet> hopefully you'll come up with some samples soon about these binary parsing combinators
05:42:42 <koeien37> you need some experience though
05:42:45 <ivanm> they're frigging weird :s
05:42:46 <Alpounet> heh, yay
05:42:53 <ivanm> Axman6: code? what's that? ;-)
05:42:53 <HaskellLove> koeien37 can you back that up with your experience?
05:42:54 <paolino> @hoogle a -> a -> Bool -> a
05:42:55 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
05:42:56 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
05:42:56 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
05:43:07 <medfly> guys, do you reckon solving project euler problems will make you better at maths?
05:43:08 <koeien37> HaskellLove: extrapolating
05:43:13 <koeien37> i didn't do anywhere near 50 myself
05:43:31 <Axman6> medfly: possibly. depends how bad you are at maths and problem solving :P
05:43:31 <koeien37> Axman6: you have a blog? where
05:43:31 <ivanm> medfly: I doubt it
05:43:38 <ivanm> it might make you better at problem solving
05:43:39 <medfly> no?
05:43:44 <HaskellLove> koeien37 well dont say they are trivial then...
05:43:45 <Axman6> http://axman6.com/blog/
05:43:53 <ivanm> and the research you do wo work out wtf a question means might improve your math skills
05:43:55 <medfly> but it requires me to learn about a lot of things in order to properly solve a lot of the questions
05:44:02 <koeien37> HaskellLove: not all. but there are some that are
05:44:20 * koeien37 adds the RSS to liferea
05:44:29 <paolino> mh, how ones fmap the if-then-else function ?
05:44:34 <Axman6> koeien37: the planet haskell one would be more useful :)
05:44:41 <Axman6> @where planet
05:44:41 <lambdabot> I know nothing about planet.
05:44:45 <HaskellLove> i would love to see this ivanm guy solving eulers... it would be interesting to observe
05:44:57 <paolino> @hoogle m a -> m a -> Bool -> m a
05:44:58 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
05:44:58 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
05:44:58 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
05:45:00 <Axman6> @where+ planet http://planet.haskell.org/
05:45:00 <lambdabot> Nice!
05:45:14 <ivanm> Axman6: bugger, you beat me to it ;-)
05:45:19 <ivanm> HaskellLove: I woudn't bother
05:45:25 <ivanm> I have too many _real_ things to code
05:45:38 <Zeiris> Do the standard libraries perchance include a simple priority queue implementation?
05:45:42 <ivanm> Axman6: ndm seems to have stolen your idea...
05:45:48 <Axman6> HaskellLove: you seem to be implying ivanm is not particularly smart. yet he is about to start work on a PhD...
05:45:52 <ivanm> Zeiris: no
05:45:55 <ivanm> but there are some on hackage
05:46:15 <HaskellLove> ivanm sorry then... Phd wow bravo
05:46:33 <Zeiris> Is stuff on hackage all usable/production-ready, or are there occasiona... 'experimental' modules?
05:46:40 <ivanm> HaskellLove: I suggest you follow the "where to go from here" section here: http://neilmitchell.blogspot.com/
05:46:49 <koeien37> ivanm: what are you going tow ork on?
05:46:53 <Axman6> Zeiris: many expeimental packages, but most usable
05:46:54 <ivanm> umm, make that http://neilmitchell.blogspot.com/2010/01/haskell-io-without-monads.html
05:47:05 <ivanm> koeien37: combinatorial algorithms
05:47:11 <ivanm> so I might be using bos' criterion for that
05:47:18 <Axman6> ivanm: what idea of mine was stolen?
05:47:19 <ivanm> going to start off with fullerene algorithms
05:47:28 <ivanm> Axman6: IO without Monads: http://neilmitchell.blogspot.com/2010/01/haskell-io-without-monads.html
05:47:35 <Axman6> i had that idea?
05:47:45 <ivanm> Axman6: didn't you write a blog post to that effect?
05:47:49 <Saizan> sigfpe did that first, actually
05:47:50 * koeien37 feels stupid that he has no idea what combinatorial algorithms are
05:47:54 <ivanm> Saizan: oh...
05:47:55 <Axman6> nope
05:47:56 <koeien37> let me google
05:48:01 <ivanm> koeien37: algorithms for combinatorics
05:48:06 <ivanm> koeien37: graph theory, etc.
05:48:08 <koeien37> yeah i can imagine that
05:48:12 <HaskellLove> ivanm as i said i am too stupid now for monads... i have 5 books to finish before i start monads
05:48:21 <Axman6> didn't gopher have continuation based IO?
05:48:22 <ivanm> Axman6: sure you did, how to do Haskell IO without knowing about monads
05:48:29 <ivanm> HaskellLove: I call bullshit
05:48:38 <ivanm> HaskellLove: no-one is too stupid for monads
05:48:42 <koeien37> oh yes, i know a lot of the algorithms listed
05:48:49 <Axman6> HaskellLove: quit reading books, quit wasting your time on project euler, and start writing some real programs, please!
05:48:49 <ivanm> dibblego taught monads to a random midwife at a hospital IIRC
05:49:03 <ivanm> agreed; start hacking on real code
05:49:04 <koeien37> which analogy did s/he use?
05:49:09 <koeien37> ;)
05:49:11 <ivanm> sure, it'll be absolute garbage to start with
05:49:17 <ivanm> but you live and apparently learn
05:49:28 <ivanm> koeien37: who, Axman6? none; just how to do IO IIRC
05:49:33 <Axman6> HaskellLove: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot gogogo! write your own bot, learn how to actually _DO_ things in haskell!
05:50:24 <Zeiris> Do monad transformer stacks always need an IO at the bottom?
05:50:55 <Twey> No
05:51:01 <Alpounet> ivanm, true story ?
05:51:07 <Axman6> HaskellLove: the way you're learning haskell is like learning C, but learning how to write a basic main function, and writing everything else using CPP macros
05:51:22 <Alpounet> it'd be awesome !
05:51:23 <Twey> IO is just the most common use case for transformers (it's also, not coÃ¯ncidentally, the most common monad)
05:51:23 <ivanm> Alpounet: about dibblego? he was saying something about it the other day here
05:51:36 <ivanm> Zeiris: the usually don't
05:51:39 <Alpounet> yeah about dibblego
05:51:41 <ivanm> (AFAIK, anyway)
05:51:51 <Twey> Properly, every monad transformer stack should have an Identity at the bottom ;)
05:51:55 <Alpounet> haha excellent, will tyr.
05:51:57 <Alpounet> try*
05:52:17 <Saizan> IOT Identity
05:52:18 <ivanm> Twey: should it? if you want Read + State, why make it Read + State + Identity?
05:52:46 <Twey> ivanm: In order to avoid having non-composable non-transformer monads other than Identity
05:52:52 <koeien37> yes!
05:52:57 <koeien37> i've thought about this as well
05:53:00 <idnar> Zeiris: since IOT is impossible, IO needs to be at the bottom if you want IO
05:53:02 <koeien37> but it seems cumbersome in practice
05:53:08 <idnar> Zeiris: but if you don't want IO at all, it doesn't need to be anywhere
05:53:17 <Twey> koeien37: Also difficult to optimise, AIUI
05:53:35 <ivanm> Twey: so you're saying that we should replace all non-Identity monads with monad transformers?
05:53:39 <b0fh_ua> Hi there! Can somebody please take a look at the listing: http://pastebin.com/d19f51acf - and explain, what did I miss when learning IO actions?
05:53:50 <Twey> ivanm: It's not an original idea :Ã¾
05:53:59 <b0fh_ua> I know that there're another way of reading and printing out content of a file :
05:54:03 <ivanm> b0fh_ua: you're doing the reading wrong
05:54:10 <ivanm> @hoogle withFile
05:54:11 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
05:54:16 <Twey> Needz moar Iteratee
05:54:22 <Saizan> b0fh_ua: use readFile
05:54:22 <ivanm> b0fh_ua: I take it back, you are using it properly
05:54:29 <ivanm> b0fh_ua: looks OK to me
05:54:41 <b0fh_ua> ivanm: but doesn't work
05:54:41 <Saizan> that thing won't print anything
05:54:47 <b0fh_ua> it prints the empty content
05:54:47 <Saizan> because hGetContents is lazy
05:54:50 <ivanm> Saizan: why not?
05:54:51 <b0fh_ua> Saizan: why?
05:55:01 <Twey> Won't print force it?
05:55:04 <ivanm> I thought using print on it would force it...
05:55:04 <Saizan> b0fh_ua: it's hGetContents that's special
05:55:15 <ivanm> b0fh_ua: you sure that the file is non-empty? ;-)
05:55:18 <Saizan> Twey: withFile will close the handle before returning
05:55:23 <b0fh_ua> ivanm: absolutely
05:55:23 <Twey> Ah!
05:55:29 <Twey> I see
05:55:33 <ivanm> Saizan: oh, so it has to be forced?
05:55:39 <ivanm> b0fh_ua: contents <- readFile file
05:55:41 <koeien37> or put the print in the withFile
05:55:42 <idnar> once you've used hGetContents, you shouldn't do anything else with the file
05:56:00 <idnar> (including closing it, I think, because you'll get a double-close)
05:56:02 <ivanm> b0fh_ua: or if you want to use withFile, you can't use hGetContents on its own
05:56:07 <Twey> And it's withFile's job to close the handle afterwards, instead of doing the lazy-IO magic
05:56:27 <Twey> So they don't mix
05:56:28 <b0fh_ua> ivanm: it's still not clear for me :(
05:56:34 <ivanm> an alternative is hGetContents >>= evaluate
05:56:39 <ivanm> b0fh_ua: what isn't?
05:56:47 <idnar> ivanm: but you still shouldn't use withFile then
05:56:53 <Twey> b0fh_ua: When you call hGetContents on a handle, it puts the handle into a special âhalf-closedâ state
05:57:02 <ivanm> idnar: just in case he has to / wants to use withFile for some reason
05:57:17 <Saizan> b0fh_ua: the fact is that hGetContents uses unsafeInterleaveIO to really read the file only when you inspect the String it gives you, but withFile is supposed to close the Handle before returning, so when you do the print in the next line and hGetContents starts reading, the Handle is already closed, so it returns the empty String
05:57:17 <b0fh_ua> hmm
05:57:18 <idnar> ivanm: won't your program blow up when you try to close the already-closed handle?
05:57:23 <Twey> b0fh_ua: So that the handle is effectively closed for other operations, but the lazy IO call that half-closed it can still get its contents on demand
05:57:33 <ivanm> idnar: nope, closing a closed handle does nothing
05:57:37 <Saizan> ivanm: evaluate by itself won't help
05:57:42 <idnar> ivanm: oh okay
05:57:46 <koeien37> take its length
05:57:50 <Twey> b0fh_ua: withFile closes the handle properly, which the lazy IO interprets as the end of data
05:57:53 <idnar> anyway, I'd just avoid the use of hGetContents
05:57:55 <ivanm> Saizan: won't it? I thought that forced it...
05:57:55 <Twey> So you get no data
05:58:02 <Saizan> ivanm: only to WHNF
05:58:08 <Twey> idnar: Like I said: needs more Iteratee âº
05:58:11 <matsuura> I've been seeing the word 'lazy' a lot lately
05:58:12 <matsuura> hmm
05:58:13 <ivanm> Saizan: hmmm....
05:58:23 <ivanm> @slap Twey
05:58:24 * lambdabot hits Twey with an assortment of kitchen utensils
05:58:27 <ivanm> stupid smiley faces...
05:58:29 <matsuura> o_o
05:58:31 <Saizan> ivanm: it's like seq, it won't force the whole list
05:58:34 <ivanm> does your client auto-correct or something?
05:58:35 <Twey> :<
05:58:37 <Twey> No
05:58:46 <ivanm> Saizan: *nod* and then you have the same problem wrt non-evaluated output?
05:58:50 <Twey> I get annoyed when things start changing what I'm typing
05:58:54 <ivanm> i.e. you know how long it is, but not _what_ it is?
05:58:58 <koeien37> well, you might get the first character then
05:59:15 <Saizan> ivanm: eh? you don't know how long it is either
05:59:22 <ivanm> Saizan: duh, right
05:59:45 <ivanm> Saizan: duh, right; dcoutts told me to use evaluate . length
05:59:47 <koeien37> hGetContents & manual closing ==> boom
05:59:56 <koeien37> be careful with it
05:59:59 <matsuura> hey, my bot works.. just doesn't speak any languages efficiently.. D:
06:00:09 <koeien37> did you use Network.IRC ?
06:00:15 <b0fh_ua> well
06:00:22 <Saizan> b0fh_ua: so, unless you need to accurately know when the Handle gets closed i'd stick with readFile
06:00:34 <ivanm> koeien37: :o
06:01:10 <ivanm> Saizan: or you want to pass a function in of type FilePath -> IO a that only reads files... >_>
06:01:17 <ivanm> (which is extremely unlikely)
06:01:18 <Axman6> anyone else notice that there's a Real World Haskell book App for sale on the iPhone App store?
06:01:39 <b0fh_ua> Saizan: http://pastebin.com/d752db13a - shouldn't fContent be evaluated first?
06:01:42 * mux gets confused by "| foo <- bar" pattern guards where he expected "| bar == foo"
06:01:48 <Eduard_Munteanu> Hi.
06:01:50 <b0fh_ua> in fact the result of the program is simply "!"
06:02:13 <koeien37> b0fh_ua: no
06:02:20 <Axman6> matsuura: do you know what it means?
06:02:23 <b0fh_ua> omg :)
06:02:24 <mux> what is this | pattern <- name syntax?
06:02:27 <koeien37> b0fh_ua: same problem
06:02:32 <Axman6> uh, mux, not matsuura
06:02:35 <Eduard_Munteanu> I asked yesterday for a math-oriented Haskell book and someone suggested "The Haskell Road To ...". However, I'd rather have something describing category theory, monads etc.. Any other suggestions?
06:02:48 <Saizan> b0fh_ua: no, because hGetContents is lazy in its effects, it's a quite peculiar and not really safe behaviour
06:02:58 <Axman6> mux: it means that name must match the pattern for the guard to be evaluated
06:03:14 <b0fh_ua> Saizan: okay, so what is the way to use hGetContent properly? :)
06:03:19 <mux> Axman6: alright that's what I guessed
06:03:28 <Axman6> so, instead of having foo x | null x = y, you could have foo x | [] <- x = y
06:03:35 <mux> Axman6: that can allow getting rid of some cases for definitions I guess
06:03:50 <Axman6> yeah
06:03:54 <Axman6> i tend to just use case though
06:03:54 <Saizan> b0fh_ua: either don't close the Handle, like withFile does, or force the whole content before closing it
06:04:05 <mux> Axman6: this is from GHC
06:04:11 <koeien37> b0fh_ua: withFile closes the handle. So you'll need to read the whole file into memory
06:04:19 <b0fh_ua> Saizan: didn't fContent ++ "!" forced fContent to be evaluated?
06:04:32 <koeien37> you can do that with force [] = (); force (x:xs) = x `seq` force xs
06:04:37 <ivanm> Eduard_Munteanu: the only other math-related haskell book that I know of is computational oriented matroids
06:04:38 <Axman6> ok, sleep time, night all
06:04:45 <ivanm> but AFAIK it doesn't cover category theory, etc.
06:04:51 <ivanm> Axman6: yeah, I might hit the sack myself
06:04:54 <idnar> why not just use readFile or whatever?
06:05:08 <Saizan> b0fh_ua: no, lazy evaluation means that fContent ++ "!" forced fContent to be evaluated?expression is not evaluated
06:05:14 <b0fh_ua> idnar: because I want to understand things :)
06:05:19 <idnar> well, fair enough
06:05:21 <Eduard_Munteanu> ivanm, thanks. I thought there will be more on this stuff.
06:05:48 <Saizan> b0fh_ua: no, lazy evaluation means that (fContent ++ "!") is not evaluated until "print contents" gets executed
06:06:02 <b0fh_ua> nice
06:06:07 <Eduard_Munteanu> Hm, lemme check Wikipedia for citations on Haskell topics, perhaps I can find some book.
06:06:11 <ivanm> Eduard_Munteanu: most actual haskell books are introductory ones
06:06:11 <b0fh_ua> that makes sense
06:06:34 <ivanm> Eduard_Munteanu: http://haskell.org/haskellwiki/Books_and_tutorials
06:06:35 <Eduard_Munteanu> ivanm, actually introductory is okay as long as its done in a category theory context :)
06:06:40 <ivanm> heh
06:06:41 <Saizan> b0fh_ua: you need something like "length fContent `seq` return ()"
06:06:47 <ivanm> Eduard_Munteanu: there are CS-oriented CT books...
06:06:48 <Eduard_Munteanu> ivanm, thanks, will look there also.
06:06:49 <Saizan> b0fh_ua: to be put above that return
06:07:59 <Saizan> b0fh_ua: because while executing that do-block it'll have to reduce each statement to an action, and to reduce "length fContent `seq` return ()" it'll have to evaluate "length fContent" first
06:08:27 <Saizan> b0fh_ua: and evaluating that will force the reading from the file :)
06:08:32 <Saizan> b0fh_ua: it's a long chain :)
06:09:22 <Saizan> seq is a builtin to add strictness by introducing a fake data-dependency
06:09:24 <Eduard_Munteanu> Programming in
06:09:30 <Eduard_Munteanu> Martin-LÃ¶f's Type Theory seems to be interesting.
06:09:49 <b0fh_ua> Saizan: yeah
06:10:03 <Saizan> it makes sure it's first argument is evaluated until its outermost constructor before returning the second
06:10:06 <Eduard_Munteanu> Not strictly Haskell, but...
06:10:11 <Saizan> Eduard_Munteanu: is that a book?
06:10:13 <b0fh_ua> there're so much things to learn
06:10:46 <Eduard_Munteanu> Saizan, yes: http://www.cs.chalmers.se/Cs/Research/Logic/book/
06:11:14 <xerox> I'd do it like  main = do { (file:_) <- getArgs; cntns <- readFile file; putStrLn (cntns ++ "!") }
06:11:50 <koeien37> that works, unless you need close control of the closed file handles
06:12:25 <koeien37> instead of relying on the garbage collector
06:12:26 <Saizan> b0fh_ua: well, honestly, many think that hGetContents and friends are broken, but they are convenient if you don't want to read the file in memory at once but don't want to do manual chunked reading yourself
06:14:49 <b0fh_ua> Saizan: so it reads things lazily and if the handle is closed before the content was actually evaluated in some way - it returns empty string
06:14:57 <b0fh_ua> correct?
06:14:59 <koeien37> correct
06:15:11 <b0fh_ua> okay, that makes much more sense now :)
06:15:20 <koeien37> hGetContents h   works in O(1)
06:15:44 <Ke> o_O
06:15:57 <Jafet> That's because it doesn't work
06:16:06 <Jafet> Like me
06:16:07 <koeien37> that is debatable
06:16:44 <matsuura> is 20^32 really infinity?
06:16:53 <koeien37> as a Double, probably
06:16:54 <Gracenotes> yes
06:16:58 <matsuura> >_>
06:17:05 <koeien37> that's an IEEE requirement
06:17:16 <matsuura> as a float, you mean?
06:17:17 <matsuura> >_>
06:17:21 <Gracenotes> you only have 64 bits to represent the reals... some things just have to be "too high to represent"
06:17:22 <koeien37> > 20^32 :: Double
06:17:23 <lambdabot>   4.294967296e41
06:17:26 <Jafet> I wonder how you'd express the field containing IEEE floating point
06:17:27 <koeien37> > 20^32 :: Float
06:17:28 <lambdabot>   Infinity
06:17:34 <koeien37> yes, thanks
06:17:40 <Jafet> (Or even if it's a field, modulo NaNs)
06:17:48 <koeien37> it's not a field
06:17:57 <koeien37> not associative
06:17:59 <Jafet> Even Goldberg's paper doesn't seem to say exactly what it is
06:18:00 <Gracenotes> Jafet: I was wondering the other day how you'd do mathematical proofs in the set of IEEEs
06:18:54 <koeien37> > 1/0 + -1/0
06:18:55 <lambdabot>   Precedence parsing error
06:18:55 <lambdabot>      cannot mix `GHC.Num.+' [infixl 6] and prefix ...
06:19:01 <koeien37> > 1/0 + (-1)/0 -- <3 unary minus
06:19:03 <lambdabot>   NaN
06:19:06 <Gracenotes> IEEE floats at least. Don't have much to say about IEEE specs as a set
06:20:22 <b0fh_ua> am I correct if understand that IO action is only evaluated when it's content is being extracted in some way?
06:20:39 <koeien37> no, that is not correct
06:20:55 <koeien37> "evaluation" of IO actions does *nothing*
06:21:08 <koeien37> "performing" or "running" said IO action does something
06:21:18 <kamatsu> right, an IO action is just a value
06:21:22 <Eduard_Munteanu> So IO is strict?
06:21:26 <kamatsu> no
06:21:28 <koeien37> putStrLn "Hello World" actually returns, when performed, the empty tuple
06:21:36 <Eduard_Munteanu> Oh I see.
06:21:38 <Cale> b0fh_ua: *Evaluating* an IO action doesn't do much to it. *Executing* an IO action only happens when that IO action is main, or part of main in some way, or you type it on the GHCi/hugs commandline :)
06:21:46 <koeien37> even if you don't inspect this empty tuple, the Hello WOrld will still be printed
06:21:52 <b0fh_ua> IO actionsd are performed only when they are reaching the main block, right?
06:21:58 <koeien37> yes
06:22:02 <kamatsu> right, or if you use unsafePerformIO
06:22:05 <kamatsu> which you shouldn't
06:22:09 <koeien37> behind "main" there is a secret IO evaluator
06:22:11 <Jafet> trace!
06:22:19 <kamatsu> Jafet: silence!
06:22:26 <Gracenotes> I would say IO is a strict monad, in terms of talking about monads being strict and lazy, which is hazy to begin with
06:22:46 <Saizan> b0fh_ua: generally the effects are performed regardless of you inspecting the result or not
06:22:46 <kamatsu> Gracenotes: it is? If i do a getContents, it doesn't get all the contents
06:22:58 <Cale> kamatsu: getContents is magic
06:22:58 <koeien37> right, that's because of unsafeInterleaveIO
06:23:06 <Saizan> b0fh_ua: this is where hGetContents is weird
06:23:27 <kamatsu> Cale: Right, but I think that means you could say that IO is lazy, after a fashion
06:23:37 <b0fh_ua> okay, in this case the problem with my code is the fact that the handle gets closed BEFORE any data extracted from stream, served by hGetContents?
06:23:44 <koeien37> correct
06:23:44 <Gracenotes> it is a weird function. unsafeInterleaveIO is a way to delay IO past bindIO, among other interesting things
06:24:01 <matsuura> i've been playing with haskell since 12:00AM... 6 hours 23 minutes minutes later, i'm still doing such things... Should I sleep? :o
06:24:09 <koeien37> never!
06:24:16 <matsuura> :(
06:24:16 <kamatsu> matsuura: no no, keep playing
06:24:24 <flux> @type unsafeInterleaveIO
06:24:26 <lambdabot> Not in scope: `unsafeInterleaveIO'
06:24:31 <koeien37> IO a -> IO a
06:24:45 <maurer_> I've tried looking on hoogle, but can't seem to find a function that essentially does (iterate f x) !! n, for some f x and n
06:24:49 <matsuura> > :t sleep
06:24:49 <b0fh_ua> allright, that looks like if I start to read from file in one thread and in another one just closed the file stream BEFORE something was actually read
06:24:50 <lambdabot>   <no location info>: parse error on input `:'
06:24:58 <Cale> maurer_: you just wrote it ;)
06:25:02 <maurer_> Using that snippet itself generates some kind of horrible code
06:25:07 <Gracenotes> matsuura: it certainly is a lazy function, but IO is what we might call a "lazy" monad anyway. I think some characteristics of a lazy monad is passing undefined >> return () == return ()...
06:25:08 <koeien37> maurer_: i'm not sure about an easier way, really
06:25:09 <kamatsu> b0fh_ua: how are you opening thee handle?
06:25:21 <b0fh_ua> kamatsu: withFile
06:25:34 <matsuura> Gracenotes: what?
06:25:35 <Cale> maurer_: But yeah, I'd like to have such a function (and maybe a strict variant of it as well), but it's not in the standard library.
06:25:39 <maurer_> Cale: If I use that snippet, I print the last value more than twice as slowly as if I do mapM print (take n (iterate f x))
06:25:45 <Gracenotes> matsuura: er, rather, it's strict. Also, lazy monads have a habit of accumulating monadic actions on the heap, which IO tends not to do
06:25:53 <kamatsu> b0fh_ua: then, you should have a guarantee that the handle will be open for use within withFile..
06:25:57 <maurer_> As in, 2 minutes vs 45 seconds
06:26:04 <Gracenotes> sorry, my brain is not in remembering mode
06:26:10 <maurer_> Printing out more values shouldn't speed me up this much :(
06:26:16 <matsuura> Gracenotes: :t monad
06:26:23 <Cale> maurer_: Really? Printing the whole list goes faster than printing the one value?
06:26:29 <maurer_> Yeah.
06:26:34 <Cale> maurer_: By how much?
06:26:40 <maurer_> 45 seconds vs 2 minutes
06:26:46 <Cale> interesting.
06:26:54 <idnar> maurer_: are both of those code snippets exactly what you're using?
06:26:58 <kamatsu> okay, seeing as sdl_gfx basically sucks, I have implemented a set of partial bindings to sprig that covers most of the basic use cases.
06:27:14 <kamatsu> downsides are that i haven't done any haddock documentation and i haven't tested every binding
06:27:19 <kamatsu> should I submit to hackage anyway?
06:27:25 <Gracenotes> > undefined >> return () == return () :: Maybe ()
06:27:26 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe ()'
06:27:27 <lambdabot>         against inferred...
06:27:28 <Eduard_Munteanu> Perhaps building f(f(f(...)))
06:27:30 <Eduard_Munteanu> is expensive
06:27:36 <Gracenotes> binding meh
06:27:47 <matsuura> Cale: what is a composition?
06:27:56 <maurer_> idnar:not quite, onesec and I'll pastebin stuff (it is certainly equivalent)
06:27:59 <Eduard_Munteanu> Whereas the other might evaluate progressively?
06:28:01 <kamatsu> matsuura: f(g(x)) ==  f . g (x)
06:28:01 <matsuura> Cale: like G o F
06:28:11 <kamatsu> or maybe the other way around
06:28:16 <Cale> matsuura: (f . g) x = f (g x)
06:29:05 <Cale> That is, (f . g) is the function which when applied to the parameter x, gives the result of applying g to x, and then applying f to the result
06:29:20 <Eduard_Munteanu> I always thought it would be useful to have a reverse composition operator.
06:29:30 <Eduard_Munteanu> A kind of 'then' for function composition.
06:29:32 <koeien37> right, that is very useful
06:29:34 <Cale> It's common to read  f . g  as "f following g"
06:29:44 <koeien37> ; in category theory
06:29:49 <maurer_> idnar: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15527#a15527
06:29:59 <matsuura> Cale: thanks :)
06:30:02 <Jafet> @hoogle (a -> b) -> (b -> c) -> (a -> c)
06:30:03 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
06:30:04 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
06:30:04 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
06:30:06 <Cale> Sometimes people just reverse the convention altogether and reuse the circle in reverse order
06:30:19 <maurer_> idnar: Err, forgot to change the last print statement in the second one, but you get the idea
06:30:20 <koeien37> do they write the circle the other way around then, too? ;)
06:30:24 <Cale> hehe
06:30:29 <maurer_> idnar: It's the second to last line that's slow anyways.
06:31:01 <Jafet> koeien37, there's probably a Unicode point for that too
06:31:11 <koeien37> > last (take 10 [1..]) == [1..] !! 10
06:31:11 <lambdabot>   False
06:31:17 <koeien37> that might be a problem
06:31:29 <koeien37> > last (take 10 [1..]) == [1..] !! 9
06:31:31 <lambdabot>   True
06:31:35 <maurer_> Is there a good way to force values in an iterate like structure?
06:31:42 <Cale> koeien37: Oh! Good catch :)
06:31:46 <Gracenotes> last.take sort of has an implicit count starting from 1
06:31:59 <maurer_> I'm guessing the reason mapM print is making this faster is it's adding implicit strictness
06:32:11 <Gracenotes> at least compared to the !! count which starts from 0, if you're concerned with getting list elements
06:32:14 <koeien37> that would be my guess, too, yeah
06:32:17 <idnar> so the 100001st net just takes a lot longer to construct?
06:32:25 <koeien37> that could be, but that seems unlikely
06:32:30 <Cale> maurer_: Well, it does do that, but I'm surprised that it's more than a trivial amount of overhead
06:32:34 <idnar> 45s vs 120s is quite a large discrepancy
06:32:35 <Gracenotes> not sure what I'm going on about
06:32:47 <idnar> but, I suppose it should be tested
06:32:53 <koeien37> can you watch the memory usage?
06:32:55 <idnar> maurer_: try changing it to !! 99999
06:32:57 <maurer_> OK
06:33:08 <Eduard_Munteanu> Perhaps the (iterate f x) !! n version builds a rather large thunk?
06:33:15 <Cale> Eduard_Munteanu: it does
06:33:31 <Cale> One solution would be to write an iterate'
06:33:46 <idnar> @src iterate
06:33:47 <lambdabot> iterate f x =  x : iterate f (f x)
06:33:48 <Cale> iterate' f !x = x : iterate' f (f x)
06:33:50 <koeien37> iterate' f x = x `seq` (x:iterate' f (f x))
06:33:59 <Eduard_Munteanu> Yeah.
06:34:00 <idnar> maurer_: also, this is just me flailing about randomly, but are you compiling with -O2? (and if not, does that make a difference?)
06:34:16 <maurer_> idnar: Yes compiling with O2 already.
06:34:25 <maurer_> On a side note, I generate a stack overflow when not using mapM if I don't artificially enlarge the stack
06:34:37 <koeien37> yeah, then it's excessive laziness
06:35:06 <koeien37> iterate f x !! n will bill up a quite large thunk of (f.f.f.f.....f) x
06:35:08 <Cale> maurer_: Yeah, if that's the case, don't artificially enlarge the stack, just add strictness wherever you're building up a large expression like that
06:35:22 <maurer_> Cale: Yeah, what's that ! operator you're using?
06:35:28 <koeien37> bang patterns
06:35:28 <maurer_> Does that just make a function strict in its argument?
06:35:33 <koeien37> you guessed it
06:35:40 <idnar> oh yes, of course
06:35:46 <koeien37> f !x = ...    => f x = x `seq` ...
06:35:50 <Cale> maurer_: It's a bang pattern -- you'll need {-# LANGUAGE BangPatterns #-}
06:35:55 <maurer_> Won't that cause a problem when it is generating an infinite list though?
06:36:09 <Cale> no, because it only evaluates that argument
06:36:10 <koeien37> no, we are merely evaluating the x at each point in time
06:36:16 <maurer_> Oh, cool.
06:36:25 <Cale> It makes sure the elements are evaluated as you walk down the list
06:36:27 <koeien37> @src foldl'
06:36:27 <lambdabot> foldl' f a []     = a
06:36:27 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:37:19 <Eduard_Munteanu> Though I wonder why building the thunk is slower than actual printing all values... sounds bad.
06:37:33 <maurer_> Cale: The iterate' you gave earlier claims to generate a parse error in the pattern...
06:37:44 <koeien37> {-# LANGUAGE BangPatterns #-} enabled?
06:37:58 <Eduard_Munteanu> Or use -fglasgow-exts
06:38:01 <koeien37> if you don't like 'em, you can use the definition i gave as well, they are equivalent
06:38:16 <maurer_> koeien37: I've got that at the top of my document, that should do it, right?
06:38:23 <koeien37> that should do it, yes
06:38:41 * mux starts another -j6 build of GHC
06:38:54 <maurer_> Nevermind, I had it below module Main, evidently it doesn't like that.
06:39:56 <matsuura> Cale: do you want to explain functors to me or shall I wait to read it in this article thing?
06:40:17 <matsuura> that and partially ordered sets
06:40:30 <Cale> matsuura: In a bit perhaps.
06:40:30 <matsuura> and closure operations
06:40:35 <matsuura> :D
06:41:05 <maurer_> Even with the iterate', I still generate more than the stack now (whereas with the take/mapM version I don't)
06:49:17 <paolino> maurer_: print is going deeper then seq then
06:49:52 <paolino> s/print/show
06:51:00 <paolino> iterate'' f x = rnf x `seq` x : iterate'' f (f x)
06:51:59 <paolino> iterate'' f x = last (show x) `seq` x : iterate'' f (f x) -- should be compatible also
06:52:17 <Drunkenmonkey> why would you want to do that
06:52:59 <Drunkenmonkey> seq is evil and I do not think it should be used
06:53:20 <Drunkenmonkey> laziness is not just a programming style it is a lifestyle
06:53:24 <Cale> What's a good pretty LaTeX code environment?
06:53:30 --- mode: ChanServ set +o Cale
06:53:41 <Cale> Drunkenmonkey: are you done with that?
06:53:52 <koeien37> vim imo. i use vim + latexmk
06:54:15 <Cale> koeien37: I mean the definition for the meaning of \begin{code}
06:54:28 <Cale> There are some examples on the wiki for using the listings package
06:54:41 <koeien37> ahw. do you know lhs2TeX ? it comes with some stylesheets AFAIR
06:54:49 <Cale> ah, okay
06:55:05 <koeien37> lhs2TeX is great!
06:58:22 <anhe> I had trouble with special characters in lhs2TeX with pdflatex, so I switched back to listings and the styles in the haskell wiki
06:58:33 <Eduard_Munteanu> Literate programming in Haskell?
06:58:48 <koeien37> yes, .lhs files are "literate Haskell"
06:58:53 <Eduard_Munteanu> Nice.
06:59:54 <mreh> @hoogle (a -> b) -> (a, a) -> (b, b)
06:59:54 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
06:59:54 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
06:59:54 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
07:00:29 <mreh> that's not what I want
07:03:33 <Eduard_Munteanu> mreh, um... something like f (x, y) = (f x, f y) ?
07:03:46 <koeien37> :t (&&&)
07:03:47 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:04:06 <koeien37> :t join (&&&)
07:04:07 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
07:04:09 <Ferdirand> @type join (><)
07:04:11 <lambdabot> forall a. (Gen a -> Gen a) -> Gen a -> Gen a
07:04:20 <koeien37> :t join (***)
07:04:22 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:04:22 <mreh> Eduard_Munteanu: I didn't want to have to define it myself
07:05:36 <maurer_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15532#a15532
07:05:47 <mreh> Eduard_Munteanu: Haskell's best feature IMO is the high composability of some basic ideas
07:05:51 <maurer_> So, iterate'' was a clear winner, I'm just confused as to why it was better than iterate'
07:06:02 <mreh> it makes it so much more readable
07:06:20 <maurer_> Drunkenmonkey: How would you solve the issue I was running into in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15532#a15532 without seq or bang patterns?
07:07:10 <b0fh_ua> would readFile suck entire file content into memory?
07:07:24 <Drunkenmonkey> that is quite a slowdown
07:07:37 <Botje> b0fh_ua: if there is a reason to keep it there, yes.
07:07:58 <Saizan> b0fh_ua: it'll do it as lazily as hGetContents, but you don't have a chance of closing the Handle
07:08:00 <b0fh_ua> Botje: I will split the content into lines and process line by line then
07:08:04 <Ke> actually I think glibc quite often reads the whole file at once
07:08:11 <b0fh_ua> Saizan: okay, thanks
07:09:35 <mreh> > 1 ++ 2 : [3,4]
07:09:36 <lambdabot>   No instance for (GHC.Num.Num [t])
07:09:36 <lambdabot>    arising from the literal `1' at <inter...
07:09:43 <mreh> > 1 ++ (2 : [3,4])
07:09:44 <lambdabot>   No instance for (GHC.Num.Num [t])
07:09:44 <lambdabot>    arising from the literal `1' at <inter...
07:10:13 <mreh> > [1] ++ 2 : [3,4]
07:10:15 <lambdabot>   [1,2,3,4]
07:10:26 <Saizan> maurer_: what's the type of nets?
07:10:32 <paolino> maurer_: seq is evaluating the outer shell of its value, but your value has an inside part which is kept as an unevaluated thunk with iterate'
07:10:57 <mreh> preflex: seen mmorrow
07:10:57 <preflex>  mmorrow was last seen on #haskell 4 days, 6 hours, 37 minutes and 2 seconds ago, saying: * mmorrow refocuses back on topic
07:11:02 <maurer_> Saizan: Nets is [[Matrix Double]], where Matrix is from Data.Packed.Matrix
07:11:25 <Drunkenmonkey> maurer_: it is not a problem per say, listen to what I have to say
07:11:27 <Drunkenmonkey> You have to ask yourself though, while those two minutes are passing by have you not earned a break? I have incorporated this Haskell way of licing my life and I now always carry around a rucksack. When people give me some work to do I put it in there, later on when they ask for the results I pull out the thing and start working on it. My life has improved quite a bit as a result of this "evaluation strategy".  You need to
07:11:29 <maurer_> paolino: It feels like there should be a better way than show to force that.
07:11:52 <Saizan> maurer_: there is
07:12:10 <Saizan> maurer_: import Control.Parallel.Strategies, you can use rnf then
07:12:10 <maurer_> Saizan: Ah?
07:12:15 <maurer_> OK
07:12:19 <Saizan> ?type Control.Parallel.Strategies.rnf
07:12:20 <lambdabot> forall a. (NFData a) => a -> Done
07:12:23 <Botje> Drunkenmonkey: "per se" :)
07:12:33 <Drunkenmonkey> yes, thanks
07:13:08 <Saizan> Drunkenmonkey: ok, last warning, stop trying to be fun with people seriously asking for help.
07:14:16 <paolino> maurer_: show goes down to the values to show them and last compute the last character of the string, then seq force the evaluation of that character
07:15:05 <maurer_> paolino: Yes, this makes sense. I am now testing out rnf--I was mostly confused because I erroneously assumed that something used for forcing (like seq) would act deeply.
07:15:22 <paolino> rnf is not very different from show, in the spirit
07:15:33 <paolino> @src rnf
07:15:34 <lambdabot> Source not found. I feel much better now.
07:15:41 <paolino> @src NFData
07:15:41 <lambdabot> Source not found. Just try something else.
07:15:57 <paolino> @src Show
07:15:57 <lambdabot> class  Show a  where
07:15:57 <lambdabot>     showsPrec :: Int -> a -> ShowS
07:15:57 <lambdabot>     show      :: a   -> String
07:15:57 <lambdabot>     showList  :: [a] -> ShowS
07:16:57 <paolino> well , not so much in the semantic
07:17:18 <maurer_> paolino: I see what you mean, but in cases other than this specific one, show doesn't always need to look at all of the data.
07:17:29 <paolino> that is
07:17:37 <Saizan> show's implementations are much more complex, so they tend to waste time if you only want to force the values
07:18:50 <paolino> well also NFData implementation can be fakes, you must be faithful
07:18:58 <maurer_> Ah, unfortunate. In this case, I'll have to use Show or similar, as hmatrix's Matrix and Vector don't have NFData.
07:19:21 <Heffalump> x == x is usually a good one too
07:20:21 <maurer_> Thanks for all the help guys. I can express stuff, but I'm still getting the hang of forcing values when they need to be forced.
07:21:30 <maurer_> Oh man, with ==, it's down to 7 seconds. This is so much better than before :)
07:21:34 <Saizan> for Matrix maybe you just need seq, i'd imagine it's strict on the elements
07:22:24 <Saizan> the problem is the surrounding list
07:23:35 <paolino> you could write instance NFData (Matrix a) where rnf x = x `seq` () -- I guess
07:24:42 <maurer_> Saizan: You're right, I fixed it with a fold
07:24:43 <maurer_> iterate' f x = (foldl1' seq x) `seq` x : iterate' f (f x)
07:26:27 <Saizan> nice
07:26:38 <paolino> :t foldl1'
07:26:39 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:27:54 <paolino> [[Matrix Double]], you want to go deeper than that
07:28:33 <maurer_> paolino: [[Matrix Double]] is the result of the iterate computation. x :: [Matrix Double]
07:28:44 <paolino> right :)
07:29:09 <paolino> :t foldl1' seq
07:29:10 <lambdabot> forall a. [a] -> a
07:29:53 <maurer_> Writing an NFData instance also appears to work. Thanks for all the help.
07:30:22 <Olathe> Can anyone recommend any good programming podcasts ?
07:33:14 <mistermattaway> anyone have any haskell GUI recs?
07:33:26 <araujo> recs?
07:33:32 <Ke> recommendation
07:33:45 <mauke> let recs
07:33:57 <araujo> mistermattaway, recs for what?
07:34:13 <mistermattaway> a GUI library
07:34:20 <araujo> I like gtk2hs
07:34:37 <Ke> mistermattaway: do you have any experience in using some library already with C or so?
07:35:16 <mistermattaway> not much
07:35:26 <Ke> I guess I could spend some time learning haskell todea
07:35:59 <Saizan> gtk2hs is probably the most robust, though the API is somewhat constrained by the fact that it's a binding to the C gtk
07:36:17 <DerisionSnort> I want to count the elements of a list like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15533
07:36:18 <DerisionSnort> Is there a built-in function that achieves that?
07:36:31 <matsuura> Tell me about first and third class functions
07:37:43 <Saizan> ?type Map.fromListWith
07:37:44 <lambdabot> Couldn't find qualified module.
07:37:48 <Saizan> ?type M.fromListWith
07:37:50 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
07:38:23 <Saizan> > M.fromListWith (+) . zip (repeat 1) $ [1,2,3,3,4,5,4,4,1,6]
07:38:24 <lambdabot>   fromList [(1,33)]
07:38:31 <Saizan> oops
07:38:39 <Saizan> > M.fromListWith (+) . flip zip (repeat 1) $ [1,2,3,3,4,5,4,4,1,6]
07:38:41 <lambdabot>   fromList [(1,2),(2,1),(3,2),(4,3),(5,1),(6,1)]
07:39:01 <Saizan> DerisionSnort: like that? ^^^^
07:39:04 <matsuura> no
07:39:33 <DerisionSnort> > M.fromListWith (+) . flip zip (repeat 1) $ [1, 1, 5, 1, 3, 7, 2, 1, 8, 9, 1, 2]
07:39:34 <lambdabot>   fromList [(1,5),(2,2),(3,1),(5,1),(7,1),(8,1),(9,1)]
07:39:57 <DerisionSnort> seems to do the job :)
07:40:04 <DerisionSnort> now i just need to understand it
07:40:12 <mauke> > M.fromListWith love . flip zip (repeat 1) $ [1, 1, 5, 1, 3, 7, 2, 1, 8, 9, 1, 2]
07:40:13 <lambdabot>   fromList [(1,5),(2,2),(3,1),(5,1),(7,1),(8,1),(9,1)]
07:40:53 <mistermattaway> is gtk2hs bundled with GHC?
07:41:27 * araujo points mistermattaway to haskell.org/himerge
07:41:34 <araujo> (as an example app)
07:41:35 <mauke> > M.fromListWith love . map (flip (,) 1) $ [1, 1, 5, 1, 3, 7, 2, 1, 8, 9, 1, 2]
07:41:37 <lambdabot>   fromList [(1,5),(2,2),(3,1),(5,1),(7,1),(8,1),(9,1)]
07:42:13 <mercur1> @src love
07:42:13 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:42:19 <Saizan> mistermattaway: no
07:43:22 <mistermattaway> I didn't see the vanilla package on the hackage list, but I found an installer
07:43:24 <mistermattaway> thanks guys
07:43:40 <matsuura> I think my batteries are empty
07:47:34 <mistermattaway> (naturally the installer isn't made for GHC 6.10.4, but 6.10.3)
07:48:03 <DerisionSnort> Saizan: Thanks, I understand your solution now
07:48:36 <DerisionSnort> > love
07:48:38 <lambdabot>   -3->
07:48:38 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
07:48:38 <lambdabot>  -2->
07:48:38 <lambdabot>    {-3->-5;-2->...
07:48:48 <DerisionSnort> wtf?
07:48:53 <Saizan> DerisionSnort: np :) and glad that you do
07:49:00 <Saizan> love = (+)
07:49:17 <Saizan> and that's how SmallCheck implements Show for functions
07:49:22 <Alpounet> it should be (<3)
07:49:26 <Saizan> > id :: () -> ()
07:49:28 <lambdabot>   {()->()}
07:49:32 <mauke> > (<3)
07:49:33 <lambdabot>   {-3->True;-2->True;-1->True;0->True;1->True;2->True;3->False}
07:49:42 <mercur1> Alpounet: :>
07:50:24 <idnar> haha
07:53:37 <arjanb> andyjgill: how's Kansas Lava coming along? i'm interested in trying it out
07:56:06 <andyjgill> Hi ajhager. We are using it at KU on a couple of projects, but it is not ready for primetime yet. Needs better documentation!
07:56:23 <andyjgill> Have you a project in mind?
07:59:20 <arjanb> i'm working on some hobby project and now looking for what to use to get the haskell code i have now closer to hardware
08:01:11 <arjanb> the thing is too complex to go directly to vhdl and kansas lava looks like a nice next step
08:01:14 <andyjgill> ajhager: A big problem with the Lava implementations is they are not well documented! Including Kansas Lava.
08:01:24 <Heffalump> andyjgill: your tab completion is misbehaving :-)
08:01:44 <andyjgill> Yes, it is!
08:01:49 <mauke> tabwned
08:01:57 <andyjgill> arjanb: A big problem ...
08:02:11 <andyjgill> Happy new year, all!
08:02:24 <maurer_> arjanb: http://en.wikipedia.org/wiki/Bluespec may be interesting to you.
08:02:40 <andyjgill> Got to go.
08:03:36 <Heffalump> Bluespec is a commercial product, though. Is there some free version too?
08:04:04 <maurer_> Heffalump: Unfortunately I haven't found one. It is a haskell-based hardware description language that is production grade though.
08:04:12 <Zeiris> How could I go about changing a type's Ord implementation based on some user input?
08:04:26 <maurer_> Heffalump: I've been looking to play with it, but haven't gotten around to finding a way to get it.
08:04:57 <Jonno_FTW> :t digitToInt
08:04:58 <lambdabot> Char -> Int
08:05:10 <Jonno_FTW> @src digitToInt
08:05:10 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:05:25 <Heffalump> Zeiris: with difficulty.
08:05:41 <Heffalump> do you just want to select between a pre-determined set of Ord implementations?
08:05:49 <Zeiris> I guess I could have one of the type's properties be a comparison function. And implement the Ord instance via that comparison function?
08:05:58 <Zeiris> I'd like it to be as flexible and expandable as physically possible.
08:06:06 <Heffalump> Zeiris: yes, that would work, cunning
08:06:18 <Jonno_FTW> > map digitToInt $ show 5^55
08:06:19 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
08:06:20 <lambdabot>    arising from a use of `GHC...
08:06:29 <Heffalump> but what'll you do when comparing two different values with different comparison functions?
08:06:35 <maurer_> Zeiris: Beware of serialization issues with that though--you will have a hard time saving objects of this type to any permanent location.
08:06:46 <Jonno_FTW> > digitToInt $ show 5
08:06:47 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:06:48 <lambdabot>         against inferred type...
08:06:57 <Jonno_FTW> > digitToInt 5
08:06:58 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:06:58 <lambdabot>    arising from the literal `5...
08:07:01 <Jonno_FTW> > digitToInt '5'
08:07:03 <lambdabot>   5
08:07:16 <Zeiris> Pick one and roll with it. And I don't think serialization will be a problem, since once the algorithm finishes the comparison function isn't important...
08:07:23 <maurer_> OK.
08:07:37 <Jonno_FTW> > show 5
08:07:38 <lambdabot>   "5"
08:07:50 <Jonno_FTW> > head $ show 5
08:07:51 <lambdabot>   '5'
08:25:05 <burp> > tick
08:25:06 <lambdabot>   "tock"
08:25:52 <xerox> > [(),()] >> tick
08:25:53 <lambdabot>   "tocktock"
08:25:56 <xerox> who's there?
08:26:20 <nazgjunk> says
08:26:33 <holmak> :t tick
08:26:34 <lambdabot> [Char]
08:26:41 <holmak> > tick
08:26:42 <Jonno_FTW> > return "here"
08:26:42 <lambdabot>   "tock"
08:26:43 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
08:26:43 <lambdabot>    arising from a use ...
08:26:51 <Olathe> > fun "tock" :: Expr
08:26:52 <lambdabot>   tock
08:26:53 <Jonno_FTW> > print "here"
08:26:54 <lambdabot>   <IO ()>
08:27:15 <Jonno_FTW> .....
08:27:27 <xerox> > text "Jonno"
08:27:28 <lambdabot>   Jonno
08:28:09 <Jonno_FTW> > putStr "xerox"
08:28:11 <lambdabot>   <IO ()>
08:28:21 <Jonno_FTW> what's going on lambdabot?
08:28:23 <c_wraith> lambdabot doesn't execute IO
08:28:28 <Jonno_FTW> > getLine
08:28:29 <lambdabot>   <IO [Char]>
08:28:38 <Cale> It only evaluates the IO, doesn't execute it for obvious reasons.
08:28:42 --- mode: Cale set -o Cale
08:28:49 <c_wraith> She just uses a Show instance that shows the type of the resulting expression
08:28:52 <Jonno_FTW> sounds reasonable
08:32:37 <mercur1> > runKleisli (Kleisli return . Kleisli (\x -> [x,x])) 3
08:32:38 <lambdabot>   Couldn't match expected type `a -> b'
08:32:38 <lambdabot>         against inferred type `Contro...
08:32:49 <mercur1> Cale: I guess that's why some people complained.
08:33:15 <Cale> mercur1: hm?
08:33:23 <Cale> mercur1: Is that supposed to typecheck?
08:33:31 <mercur1> You defined (.) as fmap.
08:33:35 <Cale> right.
08:33:54 <mercur1> That does not work for categories as far as I can see.
08:33:59 <Cale> Well, yes.
08:34:13 <Cale> Though we don't have many good examples of instances of the Category typeclass.
08:34:14 <mreh> what class is (/) from?
08:34:18 <mreh> :info (/)
08:34:23 <Cale> So it seems wasteful to me to use up (.) on it
08:34:26 <skorpan> @hoogle (/)
08:34:27 <lambdabot> Prelude (/) :: Fractional a => a -> a -> a
08:34:27 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
08:34:27 <lambdabot> Prelude (/=) :: Eq a => a -> a -> Bool
08:34:39 <Cale> mreh: Fractional
08:34:39 <mercur1> And I find categories to be the appropriate place for the composition operator.
08:34:51 <Cale> mercur1: Right, but Control.Category isn't just general categories
08:34:52 <mercur1> There's already a short operator for fmap.
08:34:53 <mreh> Damn these non-negative wrappers
08:35:07 <mreh> they're so useful, but confusing :(
08:35:31 <Cale> It's a very special type of category which is built on the objects of Hask and whose composition operator is functorial and natural in a very special way
08:36:32 <Cale> (well, it's a natural transformation because of its polymorphism)
08:36:55 <mreh> I need to divide two non-negative Rational objects, then round them
08:37:07 <mreh> to an Integral
08:37:14 <Cale> :t round
08:37:15 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:37:38 <Cale> > round (127 % 100)
08:37:39 <mercur1> What do you mean with the composition being functorial here?
08:37:39 <lambdabot>   1
08:38:19 <Cale> mercur1: Well, actually that was an awkward choice of words. There are some functors which it's a natural transformation between.
08:38:28 <mreh> RealFrac seems like a contradiction in terms...
08:38:39 <mreh> or maybe not, Real numbers aren't irrational are they?
08:38:46 <Cale> not necessarily
08:38:48 <c_wraith> some of them are
08:38:54 <mreh> but not in a computer
08:38:55 <c_wraith> ....  technically, most of them are
08:39:05 <Cale> But "Real" doesn'
08:39:10 <mreh> real = floating point in this context
08:39:15 <Cale> But "Real" doesn't really mean much
08:39:30 <c_wraith> computers can represent some irrational numbers exactly.  But only a countable subset of them
08:39:42 <Cale> The "Real" typeclass is poorly named
08:39:52 <mreh> c_wraith: interesting, tell me more
08:40:23 <c_wraith> mreh: there are the algebraic numbers...  ie, the roots of polynomials with integer coefficients.  The representation of those could be the polynomial.
08:40:44 <Cale> mreh: pi is representable, for example
08:40:47 <mercur1> In that way, you can represent every definable number.
08:41:01 <c_wraith> not true.  there are a few numbers that are definable but not computable
08:41:12 <c_wraith> chaitan's constant, etc
08:41:25 <Cale> Well, you can technically represent all the definable numbers. You just can't do much with the ones which aren't computable.
08:41:41 <CESSMASTER> reals are just like that to make analysis work properly you don't need to worry about representing them on a computer
08:41:43 <Cale> (and people usually don't do that because it's a lot of work)
08:42:00 <mreh> People just approxiamte pi to 100s of decimal places
08:42:13 <mercur1> Analysis works properly with computable reals.
08:42:28 <c_wraith> does CReal exactly represent pi?  I don't actually know what it uses, internally
08:42:38 <Cale> Yeah, to a certain extent the point of analysis is to tell you when it's okay to say "okay, this is enough work now"
08:42:49 <Cale> c_wraith: yes
08:42:57 <ray> it uses a formula for computing pi internally
08:43:14 <c_wraith> ray: what representation does it use internally?
08:43:29 <CESSMASTER> computable analysis is barbaric
08:43:33 <ray> arctan whatever blah blah blah
08:43:53 <Cale> data CReal = CR (Int -> Integer)
08:44:20 <c_wraith> interesting.  I guess all the fun is in the instances
08:44:43 <Cale>   pi = 16 * atan (fromRational (1 % 5))
08:44:43 <Cale>                 - 4 * atan (fromRational (1 % 239))
08:44:44 <Taejo> CESSMASTER: how is it barbaric?
08:45:14 <Cale> instance Fractional CReal where
08:45:14 <Cale>   recip (CR x') = CR (\p -> let s = head [n | n <- [0..], 3 <= abs (x' n)]
08:45:14 <Cale>                               in round_uk (2^(2*p+2*s+2) % (x' (p+2*s+2))))
08:45:14 <Cale>   fromRational x = fromInteger (numerator x) / fromInteger (denominator x)
08:45:15 <ray> the reals are the way they are to make things easier for analysts :)
08:45:36 <Cale> round_uk :: Rational -> Integer
08:45:36 <Cale> round_uk x = floor (x+1 % 2)
08:45:43 <CESSMASTER> let me rephrase
08:45:50 <CESSMASTER> why does anybody care about computable analysis
08:46:05 <CESSMASTER> it's not like your computer is going to be doing real analysis
08:46:23 <c_wraith> because it's interesting to see what you can do without requiring the exist of uncountable sets.
08:46:48 <Eduard_Munteanu> BTW, are there any uncountable number sets defined in Haskell?
08:47:13 <CESSMASTER> i want to see somebody try to reconstruct real analysis without the axiom of infinity or existence of the power set
08:47:16 <Cale> Eduard_Munteanu: depends on how you interpret 'uncountable'
08:47:20 <Eduard_Munteanu> I mean abstractions that you can collapse into reals when evaluating.
08:47:42 <McManiaC> can you kill a thread that is blocked because its waiting for an mvar?
08:47:43 <Cale> Eduard_Munteanu: [Bool] looks uncountable, but of course, you can only internally define countably many lists of that type.
08:47:44 <c_wraith> CESSMASTER: that was the point of computable analysis.
08:47:53 <ray> i guess you could make a type that had uncountably many values, but they'd be uncomputable
08:48:11 <Eduard_Munteanu> Cale, I see.
08:48:16 <CESSMASTER> c_wraith: precisely
08:48:32 <c_wraith> oh, where was that paper on exhaustive searchs of infinite spaces in finite time?
08:49:01 <Cale> Eduard_Munteanu: Of course, there are countable models of ZFC too, with only countably many sets, even though some of them are uncountable :)
08:49:31 <Eduard_Munteanu> I'd just like to do something like fromUncountable $ integral 0 1 f*dx :))
08:49:37 <c_wraith> ah, here's a blog post about it:  http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
08:49:37 <Cale> (the difference being how you're examining them -- that there are only countably many sets is only apparent from outside the system)
08:50:10 <Cale> c_wraith: yeah, the references on that blog post are rather good too
08:50:29 <Stalafin> heya! i have a function f x y z and i am trying to use flip on it in such a way that i can call it with f y z x  (or f z y x for all i care... just the x has to be at the end)... and i don't quite get it... can somebody help?
08:50:45 <c_wraith> that program searches an uncountable space in finite time.  That's a neat trick, even when it is somewhat limited.
08:50:50 <Cale> Particularly the "Synthetic Topology of data types and classical spaces" one
08:51:23 <mauke> @pl \x y z -> f y z x
08:51:23 <Cale> @pl \f y z x -> f x y z
08:51:24 <lambdabot> (flip .) . flip
08:51:24 <lambdabot> flip (flip . f)
08:51:53 <Cale> Stalafin: really, use a lambda, that's what they're for :)
08:52:00 <Phyx-> gaaaah.... just broke my earphones
08:52:02 <Eduard_Munteanu> For example it would be nice to invoke integration, then evaluate according to an arbitary division dx.
08:52:04 * Phyx- throws a lambda at them
08:52:21 <Eduard_Munteanu> Or just pass on the abstraction.
08:52:25 <Stalafin> Cale: you mean how you did it?
08:52:27 <Stalafin> Cale: with
08:52:37 <Stalafin> Cale: \f y z x -> f x y z
08:52:50 <Cale> Stalafin: well, probably drop the f parameter and use your actual f
08:53:04 <Stalafin> Cale: i dont understand :(
08:53:12 <Cale> Stalafin: What are you *actually* trying to do?
08:54:11 <Stalafin> Cale: i am trying to map a function onto a list, just that the element of the list actually comes first as a parameter in the function, and there are two variables which come last... i need the elements from the list to be the last parameter
08:54:43 <Cale> Stalafin: right, so you'll write something like  map (\x -> foo x bar baz)
08:54:46 <Eduard_Munteanu> Hm, what about curry . flip . uncurry ?
08:54:58 <Cale> Where foo, bar, and baz are something specific which you didn't tell me
08:55:09 <yhosok> when haskell platform for 6.12 is out ?
08:55:11 <Eduard_Munteanu> :t uncurry
08:55:12 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
08:55:17 <holmak> Using pointfree here seems like a bad idea...
08:55:23 <Eduard_Munteanu> :t flip . uncurry
08:55:25 <lambdabot> forall a b a1 b1. (a1 -> b1 -> a -> b) -> a -> (a1, b1) -> b
08:55:41 <Stalafin> Cale: bar and baz are just two variables i am passing... they are fixed
08:55:51 <Stalafin> Cale: say, Double
08:56:06 <Cale> yeah, you just didn't tell me what their real names were, or I'd have used them
08:56:25 <Stalafin> Cale: ah, okay... so that lambda you gave me does what i want?
08:56:29 <Cale> yes
08:56:47 <Stalafin> Cale: interesting, thx
08:57:04 <Cale> Stalafin: note that you could also use a list comprehension
08:57:14 <Cale> [foo x bar baz | x <- someList]
08:57:21 <Eduard_Munteanu> :t curry . flip . uncurry
08:57:22 <lambdabot> forall a b b1 a1 b2. (a1 -> b2 -> (a, b) -> b1) -> a -> b -> (a1, b2) -> b1
08:57:33 <Eduard_Munteanu> Bah, hard to read.
08:57:40 <Cale> heh
08:57:44 <Stalafin> Cale: true, that looks like it makes sense, too
08:58:07 <Phyx-> Does anyone know how to work around that GHC only does instance head matching? e.g. Num a => Class a a and Functor f, Class a b => Class (f a) (f b) no longer overlap?
08:58:36 <Saizan> ?google haskellwiki Advanced Overlap
08:58:37 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_system
08:58:38 <lambdabot> Title: GHC/Type system - HaskellWiki
08:58:38 <Cale> Phyx-: Use newtypes to select instances
08:58:41 <Stalafin> Cale: with the lambda it's the following, right? >> i create an anonymous function (the \), where the map grabs one element from the list and passes it as a paramenter to the \, which then calls foo x bar baz with it ??
08:58:57 <Cale> Phyx-: At least, that's the possibly tedious but principled way of doing it
08:59:22 <Cale> Phyx-: You can also start turning on all sorts of funky extensions to the instance selction and hope that they do the right thing for you
08:59:34 <Saizan> http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap <- i was thinking of this, if you want to go the hacky route
08:59:39 <Eduard_Munteanu> Stalafin, it creates an anonymous function that takes your function as an argument (along with its args) and flips its args.
09:00:16 <dmhouse> Phyx-: well, those instances do actually overlap, don't they?
09:00:45 <Phyx-> Cale: hmm, got an example?
09:00:58 <mercur1> Saizan: the paper you gave me a few days ago does not actually solve the problem of the identity functor.
09:01:02 <dmhouse> Phyx-: what if I wrote an instance Num [Int]? Then Class [Int] [Int] would match both instance declarations
09:01:12 <Phyx-> dmhouse: well, they shouldn't for instance if i want to use the instance matching IO Int, there's no reason why the Num one should match
09:01:15 <mercur1> It mentions it at the beginning, but at the end it cannot solve it.
09:02:05 <Stalafin> Eduard_Munteanu: so in theory i could do that by hand? (with flip?)
09:02:10 <matsuura> there is no make uninstall in this makefile o_o
09:02:14 <Saizan> mercur1: ah, i didn't remember exactly how the valid instances were extended, though you should have an idea of the problems now at least?:)
09:02:20 <matsuura> how am I suppose to remove haskell now D:
09:02:35 <Phyx-> dmhouse: i deal with lists in a different way, but yeah, that would overlap if defined. but in general i have an instance saying Storable a => Class [a] (Ptr a)
09:02:41 <Cale> Phyx-: I just mean introduce a trivial newtype wrapper to help select the instance
09:03:13 <Cale> newtype InstanceA a = InstanceA a
09:03:16 <Eduard_Munteanu> Stalafin, well you could think of flip as \f x y -> f y x
09:03:17 <Cale> newtype InstanceB a = InstanceB a
09:03:27 <Phyx-> Saizan: yeah, I began to implement that, but someone told me it wouldn't solve my problem, so i stopped mid way
09:03:31 <Stalafin> Eduard_Munteanu: yeah, with 2 variables i perfectly understand that
09:03:38 <Stalafin> Eduard_Munteanu: it's 3 variables, where it gets tricky
09:03:58 <Phyx-> Cale: hm, think I know what you mean, I'll give it a try, thanks
09:04:03 <Cale> er, well, perhaps those will look a little different
09:04:11 <Cale> maybe you'll want to mention the functor
09:04:16 <mercur1> Saizan: allowing arbitrary lambda terms as types results in uncomputable typechecking, so they chose a subset that is decidable. That does not mean that allowing the identity would necessarily be undecidable.
09:04:20 <Cale> But yeah, I think you get the idea
09:04:26 <mercur1> as type operators*
09:04:50 <Eduard_Munteanu> Stalafin, why? It's pretty straightforward, you can actually have stuff like \f a b c d e f -> f c e f b a d
09:05:12 <Eduard_Munteanu> Forget about the stray f's.
09:05:28 <Eduard_Munteanu> \f a b c d e -> f c e b a d
09:05:39 <Saizan> mercur1: sure
09:06:18 <Stalafin> Eduard_Munteanu: so you mean i should essentially really on lambdas?
09:06:59 <Eduard_Munteanu> Stalafin, that's just a way of writing it. Another is defining it as:
09:07:03 <burp> @pl \f a b c d e f -> f c e f b a d
09:07:04 <lambdabot> const ((((flip . (flip .)) .) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip flip id . (ap .) . flip . flip id)))
09:07:07 <burp> you surely don't want this :P
09:07:17 <holmak> Stalafin: For functions of more than two arguments, lambdas are easier to read.
09:07:25 <holmak> ...than flips and curries
09:07:27 <Stalafin> okay yeah..... this is crazy :D
09:07:29 <Cale> burp: heh, that's actually a syntax error
09:07:37 <Cale> (but somehow @pl didn't mind)
09:07:40 <lhoersten> I'm trying to thread some state through my UDP networking abstraction and cant seem to manage. This is my first attempt at monad transformers. Can someone give me a hand? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15538
09:07:51 <burp> oops yes, f twice
09:08:04 <Eduard_Munteanu> Stalafin, flip3 f a b c = c a b
09:08:06 <ski> @pl \x x -> x
09:08:07 <lambdabot> const id
09:08:19 <Eduard_Munteanu> Stalafin, sorry, flip3 f a b c = f c a b
09:08:25 * hackagebot upload: data-clist 0.0.4 - Simple functional ring type. (JohnVanEnk)
09:08:34 <holmak> lhoersten: If you have any IO functions in a StateT typed function, you need to 'lift' them.
09:08:40 <holmak> @info lift
09:08:41 <lambdabot> lift
09:08:46 <holmak> hm
09:08:46 <ski> @type lift
09:08:47 <mercur1> So it only remembers the last argument of the same name.
09:08:48 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:09:10 <ski> @index lift
09:09:11 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
09:09:11 <lambdabot> ParserCombinators.ReadPrec, Text.Read
09:09:12 <holmak> That type signature is very unsettling
09:09:23 <lhoersten> holmak: what do you mean?
09:09:29 <Cale> holmak: ignore everything before the period
09:09:43 <Cale> (MonadTrans t, Monad m) => m a -> t m a
09:09:47 <holmak> I know, I know, its just alarming at first sight
09:09:54 <Eduard_Munteanu> @src flip
09:09:55 <lambdabot> flip f x y = f y x
09:09:55 <Cale> the rest is just kinding BS
09:10:12 <holmak> "Just use lift! -- :t lift -- GIBBERISH"
09:10:12 <ski>   lift :: IO a -> StateT MyState IO a  -- e.g.
09:10:49 <burp> @pl deadbeef a b d e f = d e a d b e e f
09:10:50 <lambdabot> deadbeef = flip flip id . ((flip . (ap .)) .) . flip flip id . ((flip . (ap .)) .) . flip . (flip .) . join . (flip .) . flip flip
09:11:01 <Cale> @pl \x x -> x
09:11:02 <lambdabot> const id
09:11:05 <lhoersten> holmak: I don't think that's the issue here. The problem is where I actually call handler in the recvLoop
09:11:06 <Cale> @pl \x x -> x x
09:11:06 <lambdabot> const (join id)
09:11:08 <Cale> hmmm
09:11:18 <burp> find a useful application for the deadbeef operator
09:11:22 <blackh> lhoersten: The line that says 'handler addr msg' is of type 'MessageHandler s'.  You need to say 'execStateT (handler addr msg) s' where s is a value of type s.  You don't have a value of type s, so you need to get one from somewhere
09:11:25 <Cale> ah, shadowing, okay
09:11:26 <Eduard_Munteanu> Wow... what does @pl do? Convert a function into point free?
09:11:31 <Cale> Eduard_Munteanu: yeah
09:11:35 <Eduard_Munteanu> Nice...
09:11:40 <lhoersten> blackh: yeah that's what I was looking for! thanks!
09:11:50 <idnar> @pl \x y -> x y
09:11:51 <lambdabot> id
09:11:51 <ski> Cale : probably it adds variables from the patterns from left to right, and doesn't check that the same variable is introduced twice at the same place
09:11:53 <Eduard_Munteanu> @pl flip3 f a b c = f c b a
09:11:54 <lambdabot> flip3 = flip . (flip .) . flip
09:11:57 <Cale> Eduard_Munteanu: and it even accepts things which don't typecheck or apparently which aren't even syntactically correct ;)
09:11:57 <blackh> lhoersten: That is, recvLoop's do block statements are of type IO <something>, and 'handler addr msg' doesn't match that type
09:12:00 <lhoersten> blackh: yeah that's defined elsewhere... by the user of this
09:12:04 <ski> @pl \x0 x1 -> x1
09:12:05 <lambdabot> const id
09:12:07 <ski> @pl \x0 x1 -> x0
09:12:08 <lambdabot> const
09:12:12 <Eduard_Munteanu> Cale, looks nice.
09:12:21 <blackh> lhoersten: You need to pass it in as an argument, presumably
09:12:41 <lhoersten> blackh: that was my second question... I need to pass the state or what?
09:12:51 <lhoersten> blackh: i feel like I need to pass something else in the arg =)
09:12:51 <blackh> lhoersten: e.g. recvLoop :: Socket -> MessageHandler s -> s -> IO ()
09:12:56 <ski> (`\x x -> x' is syntactically correct, but not "scope correct")
09:13:18 <lhoersten> so I still pass my state all round myself?
09:13:22 <idnar> @type \x x -> x x
09:13:23 <lambdabot>     Conflicting definitions for `x'
09:13:24 <lambdabot>     In a lambda abstraction
09:13:42 <lhoersten> i thought the monad would hide it in the argument... i guess I'm not going to use bind here to chain these so it may not be worth it
09:14:13 <Eduard_Munteanu> @type \x _ = x
09:14:13 <ski> @type \x (y | x) (y | not x) -> y
09:14:15 <lambdabot> parse error on input `='
09:14:15 <lambdabot> parse error on input `|'
09:14:24 <idnar> @type let deadbeef a b d e f = d e a d b e e f in deadbeef
09:14:25 <lambdabot>     Occurs check: cannot construct the infinite type:
09:14:25 <lambdabot>       t = t3 -> t1 -> t -> t2 -> t3 -> t3 -> t4 -> t5
09:14:25 <lambdabot>     Probable cause: `d' is applied to too many arguments
09:14:25 <Eduard_Munteanu> @type \x _ -> x
09:14:27 <lambdabot> forall t t1. t -> t1 -> t
09:14:35 <blackh> lhoersten: The type system requires a value of type s to pass to execStateT, so you need to either pass one in or use a type class to create one.  Either way, the type of recvLoop has to change.
09:14:36 <idnar> burp: apparently the deadbeef operator doesn't typecheck ;)
09:14:37 <ski> @type \x y0 y1 in let y | x = y0 | not x = y1 in y
09:14:39 <lambdabot> parse error on input `in'
09:14:46 <ski> @type \x y0 y1 -> let y | x = y0 | not x = y1 in y
09:14:48 <lambdabot> forall t. Bool -> t -> t -> t
09:15:03 <Jonno_FTW> how can i multiline input in ghci
09:15:15 <burp> idnar: oh, I see :(
09:15:17 <ski> `:{' and `:}', iirc
09:15:21 <ski> Jonno_FTW : ^
09:15:30 <Jonno_FTW> ij
09:15:31 <blackh> lhoersten: If you want to not pass your state round yourself, then use this type: recvLoop :: Socket -> MessageHandler s -> StateT s IO ()
09:15:36 <Jonno_FTW> thanks
09:16:00 <lhoersten> blackh: yeah let me try that
09:16:02 <blackh> lhoersten: Then the line 'handler addr msg' can stay as it is
09:16:17 <lhoersten> ok that's what I'm aiming for I think
09:16:27 <blackh> lhoersten: You will also need to lift all your IO actions, e.g. port <- lift $ socketPort sock
09:16:33 <lhoersten> since I changed the handler type, I need to change the guy that passes it around as well
09:16:54 <lhoersten> blackh: cool thanks
09:17:04 <Cale> lhoersten: monads are not magic, nor are monad transformers -- StateT is really just a wrapper around some passing of extra parameters, and so it can't magically preserve the state -- either you use that monad's >>= to chain things together, or you're forced to pass it by hand the way you normally would
09:17:05 <blackh> lhoersten: No worries!
09:17:39 <Cale> (just to set the right expectation :)
09:17:39 <lhoersten> Cale: i didn't mean to imply otherwise
09:18:15 <Cale> lhoersten: Sure, I'm just trying to express why there's a need for it :)
09:18:21 <lhoersten> if you look at my code, what i'm trying to do is thread state implicitly
09:18:37 <edwardk> i'm sure there is a tutorial out that just takes the cop out analogy 'monads are like magic' -- you can wrap magic in magic and its still magic...
09:18:53 <Cale> edwardk: haha
09:19:02 <lhoersten> edwardk: what's that language you work on?
09:19:09 <edwardk> lhoersten: kata?
09:19:13 <lhoersten> yeaaah
09:19:15 <lhoersten> couldn't remember
09:20:22 <edwardk> lhoersten: shopping around for an SMT solver i can bolt into its compiler at the moment ;)
09:20:28 <Cale> edwardk: In the future this will all happen again when Kan extensions make it into the Prelude, and every beginner writes a tutorial explaining how Kan extensions are like air, etc.
09:20:51 <edwardk> cale: hah. they are in my kata prelude, whats the problem. =)
09:21:08 <mercur1> How do you use Kan extensions in Haskell?
09:21:36 <edwardk> mercur1: http://hackage.haskell.org/packages/archive/category-extras/latest/doc/html/Control-Functor-KanExtension.html
09:21:42 <lhoersten> edwardk: that's above me =) I was just telling someone about all the crazy shit people were working on at hacphi
09:22:19 <lhoersten> i couldn't remember if it was agda or something else
09:22:36 <edwardk> mercur1: i have a library of monad transformers all placed in the form of a right kan extension, turns out it often works better for the optimization passes because it leaves unevaluated stuff down the stack fully unboxed
09:22:46 <Cale> Though, sadly, a lot of things trivialise because we can only work with Hask, and don't really have a proper concept of other categories.
09:23:04 * idnar learns about Kan extensions
09:23:05 <edwardk> mercur1: http://hackage.haskell.org/package/monad-ran -- i never did finish up a few of those though
09:23:18 <Cale> So I really doubt all concepts are Kan extensions anymore in this sense
09:23:41 <edwardk> idnar: i have a series of blog posts that try to explain them in somewhat accessible terms
09:23:51 <Accidus> You have libraries for Kan extensions?
09:23:52 <Accidus> Cool
09:23:54 <idnar> that doc page links to comonad.com which appears to be down
09:24:00 <edwardk> idnar: http://comonad.com/reader/2008/kan-extensions/
09:24:08 <mercur1> edwardk: nice, and thanks for the links!
09:24:09 * Accidus sighs at his inadequate knowledge of Haskell.
09:24:10 <edwardk> idnar: its answering me
09:24:11 <idnar> or at least, I'm getting timeouts
09:24:16 <idnar> could be my ISP then
09:24:42 <edwardk> Accidus: i like cale here am a bit of a category theory nut, not too many people use them ;)
09:25:03 <Drunkenmonkey> Category theory is extremely useful
09:25:26 <medfly> Accidus can be called a category theory nut
09:25:29 <medfly> right?
09:25:34 <medfly> you should all get together
09:25:36 <Drunkenmonkey> Discovering useful properties of categories is a extremely noble pursuit
09:25:51 <lhoersten> something I don't understand about the State monad is the runState field. Where does that get bound?
09:25:53 <Cale> Drunkenmonkey: There is definitely an arrow from the terminal object into both of those statements.
09:26:03 <edwardk> lhoersten: in the spirit of what i was doing at hacphi: http://comonad.com/Category.ks
09:26:27 <Drunkenmonkey> Cale: arrow? Please do call it a morphism. We are all adults here
09:26:37 <edwardk> (and in light of the current discussion)
09:26:42 <Accidus> If by "nut" you mean someone who pursues CT, then I am.
09:26:50 <Accidus> But my knowledge is inadequate.
09:27:02 <Cale> I don't really care for the term 'morphism' in the context of abstract category theory.
09:27:17 <Accidus> Cale, Don't you?
09:27:21 <Cale> It makes me think of concrete categories
09:27:25 <edwardk> cale: yeah, but arrow is somewhat loaded in a functional context.
09:27:34 <Philonous> morphism sounds like function
09:27:38 <Accidus> Cale, explain
09:27:41 <Drunkenmonkey> Once you can construct all limits and colimits you will be extremely enlightened. You need to take your time to apreciate cones
09:27:59 <edwardk> i'm probably going to wipe out everything from class morphism to class natural isomorphism in that file and start over
09:28:02 <Accidus> Cale, you mean in the context of abstract algebra, where "morphism" is "preserving structure"?
09:28:08 <Cale> Accidus: yeah
09:28:28 <mreh> I can't do (-) in a section can I?
09:28:28 <dmhouse> Isn't that the point of morphisms in category theory too?
09:28:29 <Accidus> Cale, Ah. Because what you're after is the notion of morphism in /abstract/ categories
09:28:34 <mercur1> But cobordisms are called morphisms too usually.
09:28:39 <Accidus> dmhouse, only in concrete categories
09:28:53 <Accidus> dmhouse, That is, categories in which the objects have some kind of internal structure
09:28:57 <dmhouse> mreh: no, the function `minus' exists for this purpose, but it's a bit confusing, in that x `minus` y = y - x. Best to use a lambda
09:29:02 <edwardk> i needed natural isomorphisms for some properties further down and i felt it was best to just start at the top
09:29:12 <dmhouse> Accidus: ah. (There are others?)
09:29:14 <Cale> Accidus: Right, I find that 'arrow' has less internal structure baggage, at least in my head. :)
09:29:25 <Accidus> dmhouse, And even then, it's not always in the sense of preserving structure. Just the subset of interesting maps
09:29:40 <Accidus> Cale, Yeah, I understand.
09:29:43 <ben> @type minus
09:29:44 <lambdabot> Not in scope: `minus'
09:29:49 <ben> @type subtract
09:29:49 <lambdabot> forall a. (Num a) => a -> a -> a
09:29:55 <dmhouse> Oops, I meant subtract
09:29:55 <ben> @src subtract
09:29:56 <Accidus> Cale, it's just that I learned about morphisms before I knew about homomorphisms
09:29:56 <lambdabot> subtract x y = y - x
09:30:11 <ben> It makes sense since you are subtracting x from something
09:30:12 <Cale> ah :)
09:30:15 <dmhouse> > map (subtract 5) [1..10]
09:30:16 <lambdabot>   [-4,-3,-2,-1,0,1,2,3,4,5]
09:30:17 <Accidus> dmhouse, Yes, there are. There are abstract categories, in which the objects have no internal structure (necessarily)
09:30:29 <Accidus> dmhouse, Like abstract syntax categories
09:30:32 <Cale> Accidus: Yeah, for the same reason, I tend to use C(X,Y) rather than Hom_C(X,Y)
09:30:40 <Cale> (easier to write too)
09:30:53 <dmhouse> > map (\x -> x - 5) [1..10] -- much clearer
09:30:54 <lambdabot>   [-4,-3,-2,-1,0,1,2,3,4,5]
09:30:56 <mercur1> C_Y^X
09:31:09 <Accidus> Cale, Aye, you've mentioned. I tend to use the former because it's clearer and more compact (handy when you work with Yoneda a lot)
09:32:04 <Accidus> dmhouse, A very easy example is a poset considered as a category. The objects are the elements of the poset, they have no internal structure. The morphisms are just the fact that the domain is less than or equal to the codomain
09:32:06 <Cale> Yeah, the implicit Hom(X,Y) which forces you to remember which category you're talking about can be confusing as well.
09:32:12 <Accidus> dmhouse, Hence they are not maps at all
09:32:23 <dmhouse> Accidus: I see
09:34:18 <Drunkenmonkey> So who here has some CT work that has produced something meaningful
09:34:49 <Cale> Drunkenmonkey: Personally?
09:34:50 <edwardk> Drunkenmonkey: i got some nice speedups for some real monads out of it
09:34:57 <Accidus> Drunkenmonkey, me
09:35:01 <edwardk> Drunkenmonkey: from a practical computer science perspective
09:35:06 <edwardk> but i'm a hack as a CT guy ;)
09:35:10 <Accidus> Drunkenmonkey, I'm trying to solve some open problems in semantics
09:35:10 <Drunkenmonkey> show it please
09:35:22 <edwardk> Drunkenmonkey: that monad-ran link above
09:35:30 * Accidus has to leave.
09:35:35 <Accidus> I'm off to Penicuik
09:35:47 <Heffalump> to where?
09:35:47 <Accidus> Sleighing :)
09:35:54 <Accidus> (Is that how it's called?)
09:36:13 <Cale> Accidus: probably? :)
09:36:14 <edwardk> Drunkenmonkey: there is a bunch of unboxed versions of those that were kicked around on here about 8 months to a year ago that performed VERY nicely for certain state operations.
09:36:33 <Accidus> Ciao.
09:37:34 <Drunkenmonkey> interesting
09:38:13 <Drunkenmonkey> Cale: Yes, personally
09:38:30 <Drunkenmonkey> any paper is good as well
09:40:21 <lhoersten> Here is what I'm trying to do without the State monad. Can someone help me convirt that to using State (I actually think it has to be StateT) so I can get a better sense of what's going on? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15538#a15539
09:42:08 <monochrom> one moment
09:42:15 <lhoersten> ty
09:43:04 <Cale> Hmm, I'd say that probably the main reason I like category theory isn't any particular result, but the change in the way that I approach definitional problems. It's caused me to look at logic, order theory, topology, computation and all sorts of other things in a new way.
09:43:30 <edwardk> lhoersten: you can mechanically transform a bit of that into: type MessageHandler s = SockAddr -> String -> StateT s IO ()
09:43:38 <edwardk> lhoersten: if you're looking to start using StateT
09:44:02 <lhoersten> edwardk: yeah that's what I was trying to do =) I don't understand where runState is bound though
09:44:10 <lhoersten> in the State definition
09:44:24 <Drunkenmonkey> I guess if you try to connect various theories you end up with some kind of CT anyways
09:44:28 <c_wraith> @src StateT
09:44:29 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:44:31 <c_wraith> @src State
09:44:32 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:44:33 <Drunkenmonkey> just seems some people are taking it a little too far
09:44:48 <c_wraith> Hmm.  I'm surprised @src doesn't have either of those.
09:44:57 <Cale> Drunkenmonkey: "Too far"?
09:45:00 <edwardk> lhoersten: newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
09:45:06 <edwardk> lhoersten is the same as
09:45:09 <Saizan> when you've a compound expression like (a + b) * c, you can decompose it into let t1 = a + b in t1 * c, so that the operands are only variables, is there an algebraic treatment of this transformation?
09:45:22 <edwardk> newtype StateT s m a = StateT (s -> m (a,s); runStateT (StateT x) = x
09:45:37 <edwardk> er with the addition of course of the missing )
09:45:52 <lhoersten> yeah but where does runState ever get bound?
09:45:53 <Botje> Saizan: that's ANF. i guess the papers about it will discuss it?
09:46:01 <lhoersten> it's actually bound to a function at some point right?
09:46:10 <Drunkenmonkey> Cale: not producing anything useful with it
09:46:17 <Cale> Drunkenmonkey: Higher dimensional category theory seems to envelop a lot of really interesting structures (even without considering non-categorical things which are examples of these definitions, but just the pure CT itself)
09:46:43 <Cale> Drunkenmonkey: What counts as useful?
09:46:53 <edwardk> lhoersten: its a member accessor. you can make up data types like: data Foo = Foo { x :: Int, y :: Double } -- then x (Foo 10 12) returns 10
09:47:11 <c_wraith> lhoersten: anything with a type of return type of  (StateT ...) creates a specific runStateT function.
09:47:22 <edwardk> lhoersten: it is defined and given its type and implemented by the newtype or data declaration
09:47:25 <lhoersten> right so somewhere someone had to be like "State func" right? to give it that runState function?
09:47:34 <Cale> Drunkenmonkey: I think that category theory is *at least* as interesting and worthwhile (if not much moreso) as, say, group theory.
09:47:46 <edwardk> newtypeÂ StateÂ s a =Â StateÂ {runStateÂ :: (s -> (a, s))} -- is in Control.Monad.State
09:47:47 <Saizan> Botje: thanks
09:47:48 <Drunkenmonkey> Cale: something that makes my personal life better.
09:47:49 <ben> But is it as interesting as, say, C?
09:47:54 <ben> Or libsdl?
09:48:10 <Drunkenmonkey> Cale: group theory has a lot of applications
09:48:24 <lhoersten> edwardk: so is it up to me to give runState an implementation or it's already bound?
09:48:36 <Botje> it's already defined.
09:48:40 <Cale> Sure, and so does category theory, even within group theory.
09:48:46 <lhoersten> ok thanks
09:48:50 <edwardk> so if you call runState (State (\s -> (s,s))) -- the result is (\s -> (s,s))
09:49:14 <ben> @pl \f -> runState (State f)
09:49:14 <lambdabot> runState . State
09:49:16 <ben> :,
09:49:22 <monochrom> lhoersten: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15538#a15540
09:49:34 <edwardk> lhoersten: to use state your goal is to fill in a state constructor with the body you want it to have, this is usually done with >>=, return, get and put.
09:49:57 <monochrom> lhoersten: Sorry, that is wrong. Wrong paste. I will fix it.
09:50:10 <c_wraith> lhoersten: it's useful to think about the implementation of return for State.  return x = State (\s -> (x, s)).   You see that it actually creates a function inside the return.
09:50:32 <lhoersten> aaah i see
09:50:43 <monochrom> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15538#a15541
09:50:57 <lhoersten> for some reason I didn't put it together that it was using runState but not binding it with record syntax
09:51:00 <lhoersten> thanks
09:51:10 <edwardk> return x = State (\s -> (x,s)); get = State (\s -> (s,s)); put s' = State (\_ -> ((),s'))
09:51:43 <edwardk> yeah
09:51:46 <jenifer> http://www.lostworlds.lv/go.php?1139747394
09:51:48 <lhoersten> these are all just different implementations of runState then
09:51:58 <edwardk> you could write State { runState = \s -> (x,s) } -- but that'd be very verbose =)
09:52:04 <maartenm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15542#a15542
09:52:12 <lhoersten> yeah gotcha
09:52:13 <ben> runState is the function to get the monadic function out of the newtype wrapper, lhoersten
09:52:18 <maartenm> mandelbrot.hs:20:50:     Couldn't match expected type `[e]'            against inferred type `Array (Int, Int) Int'
09:52:22 <maartenm> I don't understand
09:52:25 <Botje> jenifer: let me send a friendly mail to abuse@lostworlds.lv.
09:52:31 <maartenm> I am trying to pass the Array around to each iteration
09:52:34 <lhoersten> ok thanks so much guys!
09:52:41 <lhoersten> monochrom: thanks a ton btw
09:52:48 <Drunkenmonkey> Cale: I am interested in the more practical applications of CT within a programming context.
09:52:57 <lhoersten> monochrom: I've spent hours trying to get this =) I just needed an example in my context
09:53:12 <maartenm> (although I realize buddhabrot doesn't returnt he correct type yet, but that's a different error)
09:53:40 <Cale> Drunkenmonkey: Well, so far, it's been a rich place to mine for library abstractions.
09:54:21 <Drunkenmonkey> Cale: please elaborate
09:54:28 <Cale> Drunkenmonkey: Of course, everyone likes to talk about monads in particular.
09:54:59 <Cale> Other special sorts of functors are also quite interesting and haven't been explored as fully
09:55:12 <Drunkenmonkey> To me it seems as if Monads could just as well be explain from a purely set theoretical stance
09:55:26 <Cale> Well, once you specialise them to Hask, yes
09:55:44 <Cale> But monads don't exactly jump out at you from a set theory standpoint.
09:56:59 <Cale> Comonads seem to capture notions of dataflow programming fairly naturally, and make evaluation of cellular automata really simple.
09:57:19 <Saizan> maartenm: it seems you're using that Array as a list somewhere
09:57:27 <Cale> and there are probably lots of nice examples of those we haven't seen yet
09:57:33 <McManiaC> <interactive>: <socket: 11>: hGetLine: end of file
09:57:33 <maartenm> I don't understand where
09:57:37 <McManiaC> what kind of error is that
09:57:37 <McManiaC> ?
09:57:46 <maartenm> buddhabrot shoudl return an Array
09:57:50 <edwardk> comonads also seem to nicely model a bunch of gpu-style programs where you don't have random writes
09:57:59 <maartenm> well, a 'matrix', an array with type Array (Int,Int) Int
09:58:03 <Philonous> I think we often use monads when we really mean arrows. (or applicatives)
09:58:07 <edwardk> but can see all of a source texture or something along those lines
09:58:12 <maartenm> I foldl over a list of tuples [(x,y)]
09:58:20 <maartenm> with a funcitont hat takes an array and a tuple
09:58:29 <matsuura> hey, http://pastebin.com/m60fcb8ff <-- someone want to explain this to me?
09:58:29 <holmak> McManiaC: you are trying to read when you have already read to the end of the file
09:58:30 <matsuura> :(
09:58:33 <edwardk> i think applicatives are a more useful abstraction than arrows have proven to be
09:58:34 <Cale> Cartesian closed categories can be seen as the natural most general place in which to interpret the lambda calculus, and the Curry-Howard isomorphism jumps out at you very clearly and strongly from that perspective.
09:58:34 <Eduard_Munteanu> Philonous, as far as I understand, we mean strong monads.
09:58:37 <maartenm> and an initialized 'matrix'
09:58:46 <McManiaC> holmak: is that from hGetLine ?
09:59:02 <Cale> Yeah, applicative functors are essentially (a special case of) lax monoidal functors.
09:59:36 <holmak> McManiaC: Yes, that is the function hGetLine throwing an exception because it is at the end of the file it is reading.
09:59:38 <edwardk> cale: which is easy because every functor in haskell is strong
09:59:50 <Saizan> maartenm: splitEvery expects a list, i think?
09:59:54 <Cale> Which is one of the first steps toward 2-categories
09:59:59 <Drunkenmonkey> Cale: Tell you what, I will make an effort to read some CT papers
10:00:04 <Saizan> maartenm: so toPPM expects a list too
10:00:06 <maartenm> ah goddamn, that shouldn't be there
10:00:09 <maartenm> sorry
10:00:14 <Cale> Drunkenmonkey: Read Awodey's book, it's a good starting point
10:00:15 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Strong_monad
10:00:18 <Drunkenmonkey> Cale: I think it can be used for trolling
10:00:21 <holmak> McManiaC: It is a runtime exception, not a compiler error, in case that is not clear.
10:00:24 <Cale> Drunkenmonkey: heh
10:00:36 <heatsink> matsuura: IIRC, it tests by trying to compile a C file that includes with that header.  If the header doesn't compile properly, you get the error.
10:00:37 <Drunkenmonkey> I have read one book
10:00:43 <Drunkenmonkey> let's see..
10:00:55 <Eduard_Munteanu> :t >>=
10:00:56 <lambdabot> parse error on input `>>='
10:01:02 <matsuura> heatsink: why wouldn't it compile correctly?
10:01:02 <maartenm> Saizan: is this a good way to update an array over an iteration, btw?
10:01:03 <matsuura> o_o
10:01:05 <heatsink> matsuura: Can you turn on a verbose flag to see what it's doing?
10:01:10 <matsuura> sure
10:01:11 <Eduard_Munteanu> :t (>>=)
10:01:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:01:15 <maartenm> I pass the array as input to the function, which outputs another array
10:01:18 <heatsink> matsuura: Perhaps HsOpenGL.h includes another header file that is not found.
10:01:24 <maartenm> in Erlang I would do it with an accumulator and patternmatch that
10:01:25 <Drunkenmonkey> Cale: this one
10:01:26 <Drunkenmonkey> http://www.amazon.com/Categories-Software-Engineering-Jos%C3%A9-Fiadeiro/dp/3540209093/ref=sr_1_3?ie=UTF8&s=books&qid=1262541643&sr=8-3
10:01:29 <holmak> McManiaC: Consider using the function hGetContents instead, separating into a list of lines using the "lines" function, and processing that list.
10:01:31 <edwardk> cale: i gave myself call/cc in kata, so i lose some of the results about strength and costrength that hold for haskell, i'm curious to see where it goes
10:01:32 <Drunkenmonkey> Pretty bad book
10:01:55 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
10:01:57 <Saizan> maartenm: you should use foldl', and maybe UArray if e is going to be Int
10:02:10 <djwonk> is there a recommended function for composing functions in 'reverse' order. opposite of (.)?
10:02:21 <maartenm> my problem is that in this case I will create an output array using anothe rlist comprehension
10:02:32 <Cale> ^^ this is the best intro to classical category theory I've found, and it's nice because it doesn't have so many prerequisites.
10:02:33 <maartenm> which takes all the values of the input array and makes any updates if necessary
10:02:40 <maartenm> that sounds awfully inefficient
10:02:41 <Saizan> maartenm: foldl' is exactly your "recurse with an accumulator" loop, as a function :)
10:02:44 <edwardk> which should make every functor over kata costrong
10:02:50 <maartenm> hmm, ok
10:02:56 <holmak> djwonk: You can use Control.Arrow.>>> if you really want to.
10:03:03 <maartenm> not sure how that will change my expressionf or creating the output array
10:03:04 <holmak> @info Control.Arrow.>>>
10:03:04 <lambdabot> (Control.Arrow.>>>)
10:03:11 <holmak> :t Control.Arrow.>>>
10:03:12 <lambdabot> parse error on input `Control.Arrow.>>>'
10:03:17 <holmak> @src Control.Arrow.>>>
10:03:18 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:03:40 <McManiaC> holmak: looking at Control.Exception â what kind of exception is that?
10:03:43 <mauke> :t ( Control.Arrow.>>>)
10:03:45 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
10:04:12 <Cale> http://arxiv.org/pdf/math/0305049v1 -- this book on higher dimensional category theory and operads gets kind of crazy quickly, I'm still making my way through it, but it's got some rather nice motivational material in the opening
10:04:26 <holmak> McManiaC: the kind of exception you are seeing from hGetLine is what happens when you call "error "some_message"".
10:04:39 <mauke> holmak: really?
10:04:43 <mauke> I find that unlikely
10:04:46 <Drunkenmonkey> I will look into it
10:04:53 <Saizan> maartenm: ah, well, the list comprehension gets hopefully fused, so the list never comes into existence
10:05:02 <McManiaC> holmak: "ErrorCall"?
10:05:19 <holmak> McManiaC: Maybe you should ask mauke, I might be confused here.
10:05:22 <Saizan> maartenm: though creating a new array each time can be less efficient than descructively updating the same one
10:05:25 <maartenm> sso if I have an input array Array (i,i) e
10:05:32 <maartenm> I shoudl sue that 'e' when creating th eoutput
10:05:35 <maartenm> *use
10:05:38 <McManiaC> mauke: do you know what error gets raised be hGetLine? :)
10:05:54 <mauke> the obvious one
10:05:58 <maartenm> I don't knwo how to destructively chnage the same one, without monads
10:06:02 <maartenm> it sounds.. impossible :)
10:06:05 <matsuura> heatsink: i'm not getting much useful :(
10:06:11 <Saizan> maartenm: it is impossible without monads :)
10:06:19 <holmak> McManiaC: But I still recommend using hGetContents instead of hGetLine, since you won't get an end-of-file exception.
10:06:30 <Eduard_Munteanu> Cale, what do you think about the "Topos, Triples and Theories" for learning Category Theory?
10:06:43 <maartenm> I will try this solution instead, first
10:06:49 <maartenm> it is a very large array though
10:06:54 <maartenm> 1 million tuples
10:06:54 <Eduard_Munteanu> http://www.cwru.edu/artsci/math/wells/pub/ttt.html
10:06:57 <maartenm> more, even
10:07:00 <djwonk> holmak: thanks. it uses a data type i'm not (yet) familiar with. i might stick with (.) for simplicity
10:07:05 <mauke> McManiaC: it's an IOException
10:07:05 <McManiaC> holmak: I need lines tho
10:07:12 <mauke> :t lines
10:07:13 <holmak> djwonk: that is probably best
10:07:14 <lambdabot> String -> [String]
10:07:29 <Saizan> maartenm: i'd use unboxed arrays if you can
10:07:49 <holmak> McManiaC: What mauke said, "lines" breaks one big string into a list of strings, each of which is a line
10:08:00 <McManiaC> holmak: i know :P
10:08:11 <holmak> McManiaC: Oh ok, sorry.
10:09:00 <McManiaC> holmak: no problem, but with sockets etc I dont want to wait until the client closed its connection ;)
10:09:35 <holmak> @src interact
10:09:35 <lambdabot> interact f = do s <- getContents; putStr (f s)
10:09:44 <Cale> Eduard_Munteanu: I've read a bit of it, but that was quite a while ago. I don't remember liking it quite as much as I like Awodey's presentation, though perhaps I should return to it. It does cover a different set of topics.
10:10:45 <holmak> McManiaC: I don't think that's actually a problem. IIRC, the laziness of lists means that you can read the contents of a stream, work on it line by line, and it won't wait til the stream closes to do the work.
10:10:58 <Eduard_Munteanu> Cale, thanks... I'll start on Awodey's then. I just read a part of the 1st chapter from TTT and wondered if it's best.
10:11:01 <holmak> McManiaC: See "interact"; it does something similar with stdin/out
10:11:36 <Berengal> Lazy IO is the devil after your program reaches 350 lines of code
10:12:07 <Berengal> It's perfectly suitable for anything less than 83 lines of code though
10:12:12 <Berengal> Just a heads up :)
10:12:42 <Cale> Eduard_Munteanu: TTT seems to be mainly concerned with the more advanced topics that it's going to cover, and races through the fundamental stuff.
10:12:46 <holmak> McManiaC: That said, you might not want to rely on that. It might explode. Ask Berengal, I've never used it in a large program.
10:13:23 <McManiaC> holmak: explode?
10:13:46 <Cale> Eduard_Munteanu: It doesn't do a terrible job of it, but it does go quickly, where perhaps a bit more exposition would be nice.
10:13:46 <Berengal> Basically, if you're doing complicated things to handles, you want full control over what gets read when, and that's impossible to orchestrate with lazy IO.
10:14:34 <Berengal> It's fine if it's a small action that only reads one file or opens one connection
10:15:13 <Berengal> And there's always hIsEOF
10:15:13 <Cale> Yoneda's lemma is on page 22, and it seems to do nothing to motivate it, which is kind of bad.
10:15:27 <holmak> McManiaC: As Berengal says. It works in theory, but can behave strangely in practice. I wouldn't have recommended getContents had I know you were working with sockets, thats my bad.
10:15:38 <Phyx-> Berengal: hmm i have a 5200 lines program using lazy I/O I violate your constraint :P
10:16:02 <mercur1> It motivates the Yoneda lemma by the "extended set notation" that describes categorical constructions.
10:16:13 <Berengal> Phyx-: What?! Madman! Delete it now, before the appocalypse is upon us!
10:16:48 <mercur1> Such as [(x,y) : fx = gx] for the pullback of f and g.
10:17:10 <Berengal> Phyx-: You probably need to burn any devices that ever contained it as well, including your brain, just to be on the safe side.
10:17:24 <Phyx-> Berengal: well, i could switch it out for Iteritees or something rather easily :P
10:17:25 <Cale> mercur1: Perhaps later on?
10:17:39 <mercur1> Very close to the lemma as far as I remember.
10:17:44 <heatsink> matsuura: I don't know what to do, other than find out what commands Setup is running and then determine why they fail.
10:18:12 <Phyx-> Berengal: well, i read files in, parse, and output the processed file. I think lazy I/O would do fine for that no?
10:18:49 <Cale> mercur1: Ah, yeah, okay, I see it now.
10:18:53 <Berengal> Phyx-: In such cases, yes, as long as you're careful about your file handles
10:19:09 <Eduard_Munteanu> Cale, I see, will go with Awodey's... I only looked into TTT because I knew no other option :)
10:19:24 <Cale> mercur1: For the most part, how I think of Yoneda's lemma is that it's a kind of completion theorem for categories.
10:19:25 <Phyx-> Berengal: great :) I just saved my svn server's life , lol
10:19:32 <Berengal> Phyx-: Sometimes I wish there was a strict readFile... Perhaps I just haven't searched enough
10:20:09 <holmak> Berengal: Is there a ByteString version?
10:20:27 <Cale> (In fact, I think that's how people should refer to it, not that Yoneda doesn't deserve the credit, but I like descriptive names)
10:20:28 <Berengal> holmak: Yes, but sometimes ByteString is a bit overkill
10:20:47 <Berengal> String is a very nice representation of strings
10:21:02 <monochrom> Berengal: http://hackage.haskell.org/package/strict
10:21:08 <Phyx-> Berengal: same, or atleast that ghc gave you more control over I/O
10:21:15 <mercur1> Hmm, I always hate it when I hear a non-descriptive name of a theorem I do not know, but I remember named theorems better than unnamed ones.
10:21:22 <Berengal> monochrom: Nice, thanks.
10:21:38 <holmak> okay. I would think that once you don't want lazy IO, you would also be ready for ByteStrings
10:22:07 <Berengal> Phyx-: You can always use withOpenFile and use hGetContents in there, but you have to be careful not to leak the resulting string, either directly or indirectly
10:23:12 <Cale> Yoneda's lemma takes your possibly poor category and embeds it into a larger one which has almost all the constructions you could ever want, and it does it in a way that lets you use the ideal constructions to prove the existence of arrows in your original category.
10:23:13 <Berengal> holmak: Not always. When doing simple socket programming you almost never want lazy IO, but String can still be the easiest choice of string structure
10:23:27 <maartenm> I changed import Data.Array to import Data.Array.Unboxed
10:23:28 <Phyx-> Berengal: for any large IO intensive  program I write i'd prolly use Iteratee-based I/O
10:23:33 <maartenm> and Array constructors to UArray
10:23:37 <maartenm> and now I get: mandelbrot.hs:44:14: Not in scope: data constructor `UArray'
10:23:51 <c_wraith> Iteratee sounds too much like Slithergadee.  I keep expecting it to eat me.
10:24:03 <Phyx-> c_wraith: hahaha, it just might
10:24:16 <int-e> maartenm: import Data.Array.Unboxed
10:24:20 <Cale> c_wraith: Iteratee chewed off half my left leg.
10:24:24 <Berengal> Phyx-: I'm not a big fan of Iteratee. A bit too much overhead... Then again, I've never really written IO programs _that_ intensive
10:24:28 <maartenm> I did
10:24:40 <maartenm> and removed the import Data.Array as well
10:24:42 <int-e> oh. "data constructor"
10:25:17 <maartenm> goddammit
10:25:19 <maartenm> of course
10:25:24 <maartenm> I tried to use it as a data constructor
10:25:28 <Phyx-> Berengal: I must admit that I haven't used it myself yet, I saw it first time 2 weeks ago when Oleg was giving a talk on it. It looked interesting
10:26:54 <Eduard_Munteanu> Cale, I just wish there was a Haskell + category theory book, instead of all those For Dummies spinoffs.
10:27:29 <Berengal> Phyx-: The general framework he sets up has a bit of overhead, especially in the types. I'm just not sure that overhead is worth not having to write the ad-hoc solutions that usually accomplish the same
10:28:24 <Phyx-> Berengal: well, that overhead does give you precise control over resources, you always know at what point you can free them, which for services is a good thing no?
10:28:58 <monochrom> trading data structure for control structure
10:28:59 <lbeew2000> Hello, is there a way to simply 'add' two Html's? i.e. put them beneath each other
10:29:26 <Eduard_Munteanu> lbeew2000, cat a.htm b.htm :P
10:29:38 <Stalafin> priceless :D
10:29:52 <Cale> Phyx-: It's potentially good for those cases, but it seems so complicated given the job that it does. At least to me. Perhaps if you're Oleg it's just fine ;)
10:29:53 <Berengal> Phyx-: The same can be achieved with ad-hoc solutions (which can be general enough to be implemented once for an application), but without the overhead. The only problem is those solutions need to be rewritten when the application's domain changes significantly, or you're working on a different app.
10:30:14 <Eduard_Munteanu> lbeew2000, anyway, you're looking to concatenate two files.
10:30:23 <lbeew2000> Eduard_Munteanu: they're not files - i mean Html type
10:30:34 <Eduard_Munteanu> Oh, sorry.
10:30:35 <Cale> type EnumeratorN s_outer el_outer s_inner el_inner m a = IterateeG s_inner el_inner m a -> IterateeG s_outer el_outer m (IterateeG s_inner el_inner m a)
10:30:37 <Phyx-> Cale: hahah, he did admit the first version of the library was a bit complicated, he said he's since then simplified it somewhat
10:31:08 <Phyx-> Berengal: basically comes down to which tradeoffs you want to accept then I think
10:31:28 <maartenm> I don't quite understand how to use arrays efficiently by passing them through in folds:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15543#a15543
10:31:34 <maartenm> cpould someone point me int he right direction?
10:32:11 <lbeew2000> Eduard_Munteanu: i could make strings and then add those and back to html but i was hoping for a nicer way lol :p
10:32:31 <Berengal> Phyx-: Indeed. Also, they don't work for every case either, and needs inversion of control, which isn't always suitable for a problem.
10:32:52 <lbeew2000> nvm, i found it
10:32:55 <lbeew2000> it was +++ lol
10:32:59 <Berengal> They're not a bad, but I think something better exists somewhere in the ether.
10:34:20 <Phyx-> Berengal: but you're right, I would use something like Strict IO on normal strings far sooner than iteritees though, if it was there
10:34:53 <DerisionSnort> @src on
10:34:53 <lambdabot> (*) `on` f = \x y -> f x * f y
10:35:07 <Cale> I think we just need better automatic resource collection
10:35:33 <mreh> is anyone else confused by this: No instance for (random-1.0.0.1:System.Random.RandomGen
10:35:33 <mreh>                        System.Random.StdGen)
10:35:33 <mreh>       arising from a use of `evalRand'
10:35:38 <Cale> Well, and operating systems which aren't retarded about things like filehandles.
10:35:44 <Phyx-> lol
10:35:52 * monochrom is not confused.
10:36:19 <mreh> I am, because StdGen is an instance of RandomGen
10:36:33 <Cale> I really don't understand why I should not be able to just open as many filehandles as the machine has memory to store.
10:36:39 <mauke> wrong module version
10:37:33 <maartenm> my wife wants to go iceskate.. if someone could annotate my hpaste and help me out when I come back I woudl be eternally grateful
10:38:03 <mreh> marrtenm, what are you doing?
10:38:12 <maartenm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15543#a15543
10:38:14 <maartenm> learning..
10:38:34 <maartenm> don't know how to do it in haskell, using the contents of the old array in an efficient way
10:39:04 <Cale> maartenm: arrays are not very efficient when it comes to updating -- that's going to copy the array for each update.
10:39:05 <mreh> you're the only person I know to have started on UArray before they got to fold
10:39:21 <maartenm> I gpot help of Saizan :)
10:39:38 <Cale> maartenm: It might be okay though, since your intended array is small
10:39:46 <maartenm> no my itnended array is huge :)
10:39:53 <maartenm> buddhabrot fractal, a screen of 10 million pixels
10:39:54 <Cale> and dense?
10:39:56 <Cale> ah
10:39:59 <mercur1> Cale: those are the things you say until you want to write your own operating system. :>
10:40:04 <Phyx-> Cale: which os limit these?
10:40:11 <Cale> Phyx-: all of them
10:40:15 <maartenm> so I should use lists?
10:40:26 <Cale> Phyx-: well, all of them that I've run into
10:40:32 <maartenm> I can use lists, no problem.. arrays seemed easier because buddhabrots have a "dictionary" algorithms
10:40:32 <Phyx-> Cale: I was searching for the limit in windows, but couldn't find it mentioned on msdn
10:40:43 <mreh> so why does my code want Random1.0.0.1? I have 1.0.0.2 installed...
10:40:46 <Cale> maartenm: well, you may want to use STArrays and mutation for something like this
10:41:01 <mreh> how does GHC even know about the package versions?
10:41:25 <maartenm> I will check out STArray when I come back... I thoguht this was a faq problem
10:41:38 <Cale> maartenm: If the data were sparser, I'd suggest Data.Map, but since it's dense, and you're going to do a hell of a lot of computation revising the structure, mutable arrays are probably the way to go
10:41:39 <monochrom> "ghc-pkg list" proves that ghc knows about package versions.
10:42:01 <maartenm> mutable arrays, they have functions that work ont he original array and efficiently produce an output array?
10:42:12 <doserj> mreh: i would guess one of your dependencies was compiled against random-1.0.0.1
10:42:14 <mreh> i thought ghc just knew about a namespace... hmm
10:42:25 <mreh> doserj, okay
10:42:44 <Cale> maartenm: Then again, maybe there's a way to rephrase the whole computation as a single immutable array.
10:42:59 <maartenm> well
10:43:04 <mreh> random 1.0.0.1 must come with the ubuntu package I installed
10:43:05 <Cale> maartenm: But you're not going to be able to get away with quite the same algorithm...
10:43:05 <int-e> @type accumArray
10:43:06 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
10:43:06 <maartenm> accumArray
10:43:10 <maartenm> yes, accumArray
10:43:13 <maartenm> I was looking at that
10:43:22 <maartenm> would that be mroe efficient or is it internally the same as what I'm doing?
10:43:47 <int-e> internally it'll use an ST(U)Array, freezing it when it's done accumulating.
10:43:51 <maartenm> it would function well for the buddhabrot
10:43:53 <maartenm> ah, cool
10:43:58 <Cale> accumArray would be far more efficient than updating repeatedly
10:44:33 <maartenm> I could probably write buddhabrot entirely on top of mandelbrot that way, extremely elegantly
10:44:34 <maartenm> thankis!
10:44:36 <Cale> ah, right, this is ideal for something like Buddhabrot.
10:44:39 <Cale> right
10:44:40 <Cale> yeah
10:45:31 <Cale> Heh, the Haddock documentation for accumArray looks a bit messed up
10:45:38 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html#v%3AaccumArray
10:46:49 <Cale> Haddock is missing the parens around the (e -> e' -> e), as well as the comment for that parameter (which is in the source...)
10:47:07 <mreh> doserj, monochrom: thx, it has compiled
10:47:17 <Phyx-> speaking of which, who needs to be spoken to to fix  the links in hoogle?
10:47:26 <mreh> preflex: seem mmorrow
10:47:31 <mreh> preflex: seen mmorrow
10:47:32 <preflex>  mmorrow was last seen on #haskell 4 days, 10 hours, 13 minutes and 36 seconds ago, saying: * mmorrow refocuses back on topic
10:47:45 <Cale> Phyx-: I don't know, but maybe if we complain to the Libraries list someone will know.
10:48:46 <Cale> Phyx-: The problem is that somehow the package directories got version-tagged again
10:49:16 <Phyx-> heh
10:49:34 <Cale> (this happened before)
10:49:36 <Phyx-> it's happened before?
10:49:38 <Phyx-> oh
10:49:54 <Cale> I think maybe it happened on the 6.6 -> 6.8 switch
10:49:58 <Cale> I forget
10:50:27 <twanvl> there is already a discussion going about the broken links on the glasgow-haskell-users list
10:50:30 <Phyx-> is hoogle still under developement if you know?
10:50:51 <Phyx-> or is Neil no longer working on it
10:53:54 <ksf> is there going to be hugs 10?
10:55:02 <Ke> is there some sort of unwords with?
10:55:22 <monochrom> No.
10:55:26 <Ke> like ["a","b"] to "a,b"
10:55:32 <Phyx-> foldr
10:55:36 <monochrom> Oh, intersperse
10:55:48 <Ke> Phyx-: that's what I used yes
10:55:51 <RayNbow> > intercalate "---" ["a","b"]
10:55:52 <lambdabot>   "a---b"
10:55:57 <ksf> do we have something like wordsBy?
10:56:02 <monochrom> > intersperse "," ["how", "are", "you"]
10:56:04 <lambdabot>   ["how",",","are",",","you"]
10:56:09 * hackagebot upload: uniplate 1.3 - Help writing simple, consise and fast generic operations. (NeilMitchell)
10:56:11 * hackagebot upload: derive 2.1.0 - A program and library to derive instances for data types (NeilMitchell)
10:56:14 <monochrom> oops, intercalate then.
10:56:21 <Phyx-> lol, speak of the devil
10:56:22 <Phyx-> lol
10:56:35 <ksf> Often, I just want to parse something mindboggingly simple and always feel like overkilling things by relying on a parsing lib
10:56:52 <monochrom> you could use regex.
10:56:58 <ksf> that's overkill.
10:57:02 <ksf> in fact, that's worse.
10:57:10 <Phyx-> monochrom: the Text.Regex seems to suck....
10:57:15 <heatsink> You could use pattern matching and corecursion.
10:57:22 <RayNbow> I used to use intersperse and concat until hlint told me that there was this function called intercalate
10:57:23 <Phyx-> either that, or my regex skills are non-existent anymore
10:57:44 <monochrom> Humans underestimate the complexity of parsing.
10:57:45 <Phyx-> RayNbow: that's not a name i'd ever remember :P
10:57:54 <ksf> I'm rather thinking along the lines of a simple, minimalistic, applicative-only parser over sequences that'd be in the standard libs.
10:58:35 <Cale> Phyx-: It sucks a good deal more than it should by trying to be perl.
10:58:45 <Cale> (more perly than perl)
10:58:54 <ksf> applicative-only because iiuc all that backtracking etc. evil is introduce by monads...
10:59:09 <Phyx-> Cale: LOL
10:59:33 <monochrom> Then you didn't understand correctly.
11:00:12 <ksf> or I could somehow force everyone to change to uu-parsinglib.
11:00:33 <ksf> though it could certainly use a more intuitive haddock.
11:00:42 <ksf> it's not that it's hard to use, it's just tooooooo general.
11:01:59 * ksf bets that there's something that gets harder by going context-dependant, but is too drunk to care what it is.
11:02:18 <monochrom> Oh you're drunk, no wonder.
11:02:31 <ksf> slightly past the ballmer peak.
11:03:03 <ksf> you know, the peak isn't only hard to hit exactly, it's also problematic because it not only makes coding easier, but also drinking more.
11:03:14 * hackagebot upload: haskell-src-exts 1.5.3 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
11:03:25 <ksf> grammatical gobbeldygock, that is.
11:04:22 <ksf> in fact, exchange "easier" and "coding", and it's unambiguous, again.
11:08:36 <Phyx-> wow, the version numbers for haskell-src-exts are sure flying these days
11:09:02 <Phyx-> i only have 1.3.3
11:09:06 <Phyx-> i should prolly upgrade
11:09:17 <Phyx-> but don't wanna break my tool again
11:09:54 <patch-tag> Can I check if a file system object exists (could be, file, dir, link, etc) with a single call, that's a library function?
11:10:13 <heatsink> patch-tag: I think access does that
11:10:47 <patch-tag> heatsink: what package?
11:11:00 <holmak> What kind of tools have people made with haskell-src?
11:11:28 <holmak> @hoogle access
11:11:29 <lambdabot> No results found
11:11:30 <heatsink> patch-tag: System.Posix.Files.fileExist
11:11:43 <heatsink> It calls the C function 'access'
11:12:12 <patch-tag> thanks, heatsink.
11:12:18 <heatsink> np
11:12:41 <Cale> Kind of sucks to lose potential for windows compatibility over something that simple though
11:12:49 <Phyx->  holmak i'm making a hs2c tool basicallu
11:12:57 <andrewe> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15545#a15545
11:13:20 <andrewe> gives a no instance error
11:13:26 <ksf> aren't parts of system.posix also available under windoze?
11:13:27 <holmak> Phyx-: Do you mean, a tool for making haskell functions available to C code?
11:13:31 <andrewe> can someone explain that?
11:14:01 <andrewe> (trying to follow http://www.haskell.org/tutorial/arrays.html)
11:14:02 <ksf> no instance for what, where?
11:14:23 <andrewe> for (IArray a Int)
11:14:31 <Phyx-> holmak: yes, it generates the required export calls, and storable instances, and convertion between the normal calls and exported calls, and the c header files, and compiles them to a lib, on windows a .dll
11:14:37 <ksf> oh. you have to give a type sig, because it can't tell what type of array you want to have.
11:14:45 <ksf> IArray is just an interface.
11:14:57 <holmak> Phyx-: That is cool!
11:15:17 <andrewe> ksf: The tutorial does not mention that.
11:15:19 <maartenm> does accum also use STArray internally?
11:15:49 <Phyx-> holmak: I have it working for the most part, it passes most of my tests, I just have  afew small things to change still
11:16:28 <ksf> yep, seems to be out of date.
11:16:43 <ksf> nowadays, it's array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
11:17:19 <Phyx-> holmak: works by having you just add -- @@ Export [= <exportname] above a function you want exported
11:17:23 <Phyx-> it does the rest
11:17:49 <ksf> andrewe, those are the choices:  http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html#t%3AIArray
11:18:00 <Phyx-> finds out which types are used by that function, etc, traces dependencies and if it has everytype it'll proceed, else it'll ask you for the ones it's missing
11:18:57 <Cale> andrewe: The tutorial you're reading is based on the Haskell 98 array library which is Data.Array, rather than Data.Array.IArray (and friends)
11:19:54 <ksf> andrewe, listen to cale instead of me
11:19:57 <Cale> andrewe: The new IArray interface is more general, but that also leads to ambiguity.
11:22:27 <Cale> Another difference is that the IArray library has an operation amap which applies a function to each element of an array, which is strangely missing from the original Haskell 98 library.
11:22:49 <CalJohn> eval "['c']" [] :: IO (Maybe Int) <-- why does this result in Nothing and not ['c'] ?
11:22:57 <CalJohn> (hs-plugins)
11:23:28 <ksf> There's a Functor instance for Array, though.
11:23:29 <mauke> did you mean: Maybe String
11:23:30 <CalJohn> or eval "'c'" [] :: IO (Maybe Char), even
11:24:10 <Phyx-> :t eval
11:24:12 <lambdabot> Not in scope: `eval'
11:24:12 <CalJohn> no, I don't think I do
11:24:26 <CalJohn> (http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-4.html)
11:24:53 <Cale> btw, rather than hs-plugins, you may want to try hint
11:25:25 <andrewe> Thanks, Cale.
11:26:38 <andrewe> Thanks, too, ksf. :-)
11:27:23 <CalJohn> i will try hint
11:27:57 <ksf> all praise should go to http://en.wikipedia.org/wiki/Glenfiddich instead of me
11:28:34 <andrewe> ksf: not my cup of tea.
11:28:35 <copumpkin> lol
11:29:10 <Cale> CalJohn: You might have to write a bit of a wrapper around the precise functionality you're trying to get at there (it requires you to specify which modules you want loaded), but it's pretty usable :)
11:33:29 <ksf> Oh. I need to smartass about the ch in glenfiddich being pronounced as in loch ness or bach, not "tsh", the next time the opportunity arises.
11:33:43 <ksf> ...now that wikipedia enlightened me.
11:34:08 <anhe> just like TeX!
11:34:17 <ksf> er no.
11:34:24 <ksf> that's a soft ch, not a hard one.
11:34:36 <Cale> ghci> let eval' x = runInterpreter (do setImports ["Prelude"]; interpret x infer)
11:34:46 <Cale> ghci> eval' "let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs" :: IO (Either InterpreterError [Integer])
11:34:46 <Cale> Right [0,1,1,2,3,5,8,13,21,34]
11:34:50 <heatsink> A palatal 'ch'?
11:35:29 <ksf> dunno what "palatal" means. the soft one is in the front, the hard towards the throat.
11:35:32 <Phyx-> :t dataTypeOf
11:35:34 <lambdabot> forall a. (Data a) => a -> DataType
11:35:50 <Phyx-> :t dataTypeOf (undefined::[Int])
11:35:51 <lambdabot> DataType
11:35:55 <Phyx-> ?
11:36:07 <anhe> ksf, it's the same as in loch according to IPA
11:36:17 <kmc> > dataTypeOf (undefined::[Int])
11:36:18 <lambdabot>   DataType {tycon = "Prelude.[]", datarep = AlgRep [[],(:)]}
11:36:35 <ksf> ...then maybe I pronounce the greek "xi" wrong.
11:36:54 <andrewe> ksf: how do you pronounce it?
11:36:57 <Phyx-> kmc: oops, didn't even noticed the :t
11:36:58 <Phyx-> lol
11:37:16 <heatsink> Well, xi is pronounced both ways, depending on dialect and context.
11:37:30 <Phyx-> > ConstrB
11:37:31 <lambdabot>   Not in scope: data constructor `ConstrB'
11:37:32 <fabjan> Bach and TeX have the same IPA in the end according to wikipedia
11:37:34 <Phyx-> :t ConstrB
11:37:35 <Eduard_Munteanu> ksf, isn't that like in "oxy"?
11:37:35 <fabjan> [x]
11:37:36 <lambdabot> Not in scope: data constructor `ConstrB'
11:37:38 <Phyx-> :t ConstrM
11:37:39 <lambdabot> Not in scope: data constructor `ConstrM'
11:38:04 <ksf> yep. the x in tex is supposed to be hard.
11:38:18 <ksf> x is the soft one, Ï the hard one.
11:39:44 <Eduard_Munteanu> ksf, I'm not sure about the greek chi, is it like in "cheers"?
11:39:50 <heatsink> ksf: Palatals are closer to the front than velars.  IPA chart here http://upload.wikimedia.org/wikipedia/commons/1/15/IPA_chart_2005.png
11:40:06 <anhe> Eduard_Munteanu: no, like in 'bach'
11:40:12 <ksf> it's definitely not a "tsh"
11:40:30 <Eduard_Munteanu> Oh, thanks.
11:40:50 <ksf> ...or "loch ness", which fits into the scottish theme.
11:40:56 <anhe> :)
11:41:15 <Eduard_Munteanu> So it's something like "hee".
11:41:29 <ksf> nope, it's a fricative.
11:41:35 <ksf> an h is basically just breathing.
11:41:57 <ksf> http://en.wikipedia.org/wiki/Voiceless_uvular_fricative
11:42:11 <Eduard_Munteanu> Uh, it's complicated... my language is 100% phonetical.
11:42:28 <Eduard_Munteanu> So every letter corresponds to a certain sound, it's not context-dependent.
11:42:52 <ksf> we'd have to have a gazillion different writing modes in german, then.
11:42:54 <Eduard_Munteanu> Well, as much as it can be without degenerating into an IPA alphabet.
11:43:15 <ksf> frensh always suprised me wrt. that.
11:43:16 <Eduard_Munteanu> ksf, Romanian is like Greek or Turkish in that perspective.
11:43:29 <ksf> I was able to have the best pronounciation and still get the worst marks.
11:43:29 <Eduard_Munteanu> my LANG ^
11:43:43 <anhe> the closest to "tex" would be "tech" in english
11:44:08 <Eduard_Munteanu> anhe, we'd write that teh.
11:44:24 <mercur1> It is amazing how slow this G4 feels when one is used to the newer x86 chips.
11:44:32 <ksf> if you pronounce "tech" and then add an k, you get close.
11:44:48 <ksf> that is, bend the tounge backwards.
11:44:59 <mercur1> Remove the 'k' you mean.
11:45:05 <anhe> Eduard_Munteanu: you'd know how eastern european people mispronounce 'h' then, because they don't have the regular 'h'
11:45:10 <lament> Eduard_Munteanu: which language is 100% phonetical?
11:45:49 <Eduard_Munteanu> lament, Romanian (mine), Turkish, Greek. Well as much as possible I mena.
11:45:51 <Eduard_Munteanu> *mean
11:46:02 <ksf> add as in "move your tounge"
11:46:11 <mercur1> What does it mean for a language to be phonetical?
11:46:19 <Eduard_Munteanu> anhe, hm, I'm not sure what you mean by regular 'h'.
11:46:30 <Eduard_Munteanu> mercur1, 1 to 1 correspondence between letters and sounds.
11:46:32 <ksf> low saxon is, too.
11:46:52 <ksf> although you're quite free when it comes to vowels, as long as you keep it consistant.
11:47:13 <Eduard_Munteanu> Yeah... depends on regional accent too.
11:47:28 <anhe> Eduard_Munteanu: in english, that is. as in "help". in a thick slavic-deriving accent it sounds exactly like the chi.
11:48:15 <mercur1> Eduard_Munteanu: that's not true for greek as far as I can tell.
11:48:18 <Eduard_Munteanu> anhe, as in German 'hast' too. Yeah, that's what our 'h' is.
11:48:31 <lament> xelp
11:48:32 <mercur1> Omicron Ypsilon is pronounced as 'u'.
11:48:36 * ksf remembers trying russians to say "Ïamburg" instead of "gamburg"
11:48:43 <Eduard_Munteanu> mercur1, yeah, there is Y.
11:48:46 <ksf> er trying to teach
11:48:47 <Eduard_Munteanu> in greek.
11:49:06 <Eduard_Munteanu> But it's mostly historical AFAIK, only older words use it as 'U'.
11:49:10 <aep> is cabal superseeded by something? there is at least one broken package per dependency chain for whatever i try to install
11:49:17 <Eduard_Munteanu> 'u' from 'you'.
11:49:25 <ksf> it's also fun to nag frensh until they learn to pronounce their h's.
11:49:33 <emma> unquery
11:49:50 <mercur1> Eduard_Munteanu: There are many ancient greek words that have "oy", but of course one cannot be sure how exactly it was pronounced.
11:49:55 <Eduard_Munteanu> ksf, because they use a silent 'h'?
11:49:57 <ksf> "'e 'as thrown 'is ball"
11:50:14 <ksf> yep
11:50:25 <Eduard_Munteanu> Heh.
11:51:07 <Phyx-> > id
11:51:08 <lambdabot>   {()->()}
11:51:11 <ksf> actually, it was a belgian I nagged. He confessed that having the h makes sense, though.
11:51:17 <lament> MY language is difficult to pronounce for native speakers of YOUR language!
11:51:22 <Phyx-> > foldr (.) id
11:51:23 <lambdabot>   []->
11:51:24 <lambdabot>    {()->()}
11:51:24 <lambdabot>  [{()->()}]->
11:51:24 <lambdabot>    {()->()}
11:51:24 <lambdabot>  [{()->()},{()->()}]->
11:51:25 <lambdabot>    {()->(...
11:51:28 <Phyx-> lol
11:51:33 <Eduard_Munteanu> lament, which is it?
11:51:38 <lament> who cares?
11:51:41 <Eduard_Munteanu> :))
11:51:45 <ksf> but then belgians seem to be more sensible than french, anyway. like not saying four twenty nineteen.
11:52:02 <anhe> celtic influences!
11:52:19 <Phyx-> > foldr (.) id [(+1),(-5),(*4), join(*)]
11:52:20 <lambdabot>   No instance for (GHC.Num.Num (b -> b))
11:52:20 <lambdabot>    arising from a use of syntactic n...
11:52:25 <Eduard_Munteanu> ksf, lol, I hate the way French count.
11:52:28 <Phyx-> > foldr (.) id [(+1),(-5),(*4)]
11:52:30 <lambdabot>   No instance for (GHC.Num.Num (b -> b))
11:52:30 <lambdabot>    arising from a use of syntactic n...
11:52:33 <Phyx-> hm
11:52:44 <Phyx-> :t [(+1),(-5),(*4), join(*)]
11:52:46 <lambdabot> forall a. (Num a, Num (a -> a)) => [a -> a]
11:52:46 <ksf> french has germanic influences, too.
11:52:55 <Eduard_Munteanu> Yeah, I know.
11:52:57 <ksf> like the voulez- questions
11:52:59 <Phyx-> :t foldr (.) id [(+1),(-5),(*4)]
11:53:01 <lambdabot> forall b. (Num b, Num (b -> b)) => b -> b
11:53:07 <Phyx-> it is type correct
11:53:14 <Phyx-> > foldr (.) id [(+1),(-5),(*4)]
11:53:16 <lambdabot>   No instance for (GHC.Num.Num (b -> b))
11:53:16 <lambdabot>    arising from a use of syntactic n...
11:53:20 <Phyx-> boo you suck
11:53:34 <Eduard_Munteanu> ksf, you mean the same thing as in English? Inverting the order of words when asking questions?
11:53:37 <anhe> ksf: sure, but I meant the twenty thing. the celtic number system is 20-based, so 'four twenty four' makes sense there when you think 84.
11:53:52 <Phyx-> > foldr (.) id [(+1),(-5),(*4)] 9
11:53:53 <lambdabot>   No instance for (GHC.Num.Num (b -> b))
11:53:54 <lambdabot>    arising from a use of syntactic n...
11:54:05 <Phyx-> > (foldr (.) id [(+1),(-5),(*4)]) 9
11:54:06 <lambdabot>   No instance for (GHC.Num.Num (b -> b))
11:54:07 <lambdabot>    arising from a use of syntactic n...
11:54:16 <Phyx-> :t (foldr (.) id [(+1),(-5),(*4)]) 9
11:54:18 <lambdabot> forall b. (Num b, Num (b -> b)) => b
11:54:22 <defun> Could one say that a data structure with multiple constructors (i.e. data Struct = ConsOne Int | ConsTwo String), is analogous to C unions?
11:54:33 <mauke> defun: yes, but tagged
11:54:36 <merehap> Phyx-: it is telling you that you can't have a function of type Num
11:54:39 <mauke> i.e. you know which variant is in use
11:54:50 <Phyx-> merehap: yes, and i want to tell it i do want it!
11:55:07 <Veinor> :t foldr
11:55:09 <ksf> Eduard_Munteanu, "voulez-vous" is exactly the same as "wuerden sie"
11:55:09 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:55:12 <Phyx-> defun: like mauke said, i use an enum for that
11:55:12 <ksf> it's a german import
11:55:28 <merehap> Phyx-: I think there was some discussion of that on the wiki, but I don't think it is possible now, could be wrong...
11:55:32 <ksf> ...and, yes, engilsh "would you" is the same, too.
11:55:36 <Eduard_Munteanu> ksf, uh, I don't know much French. But German... I don't know anything at all.
11:55:46 <defun> mauke: could you please elaborate or provide an example illustrating what you mean by 'tagged'?
11:55:51 <Veinor> I don't get why Phyx-'s example isn't working either *_*
11:55:55 <Phyx-> merehap: oh it's the -5
11:56:01 <Phyx-> stupid unirary ops
11:56:04 <Veinor> ohhh.
11:56:16 <Phyx-> > foldr (.) id [(+1),(subtract 5),(*4)] 9
11:56:17 <lambdabot>   32
11:56:21 <mauke> defun: no, gotta play irc trivia
11:56:27 <defun> ok
11:56:28 <merehap> Phyx-: ah :)
11:56:32 <defun> thanks, though.
11:56:32 <Veinor> why can't it just do what I mean? :(
11:56:46 <Eduard_Munteanu> WYSIWIM?
11:56:52 <ksf> I guess in russian one could say "mozhetye vi", but "vi ne mozjetye" is more ideomatic.
11:57:02 <Eduard_Munteanu> s/IM/YM/
11:57:21 <Phyx-> defun: well, it's simple, when you have the union, you need to know which construct was used, e.g. ConsOne or ConsTwo in your example
11:57:36 <defun> Oh, ok. that's what I thought, but wasn't sure.
11:57:39 <Eduard_Munteanu> One thing I find interesting about cultures is that most first names are present in all languages/cultures.
11:57:40 <anhe> is there a quick and easy way to find out what library dependencies you need to add to a .cabal?
11:57:40 <defun> thanks
11:58:03 <ksf> christianity had a big influence, there.
11:58:03 <Eduard_Munteanu> Like it's difficult to even find one first name in Europe that couldn't be Russian, English or French.
11:58:13 <Eduard_Munteanu> Hm, interesting.
11:59:36 <ksf> like "michael", which relates to http://en.wikipedia.org/wiki/Michael_(archangel)
11:59:37 <anhe> you'd mean greek, latin or hebrew :p
11:59:44 <Eduard_Munteanu> A similar thing is happening to the Japanese (or other Asians) AFAICT... you see all those Jackie Chan, John Chi-Yu names :))
11:59:53 <ksf> ...al those -el names tend to be hebrew-based, -el means "angel"
11:59:59 <Eduard_Munteanu> anhe, hm, good point.
11:59:59 <monochrom> Nice, ghc (sans extra libs) builds in 45 minutes on my laptop.
12:01:35 <ksf> but you won't see "ariel" being used by german parents.
12:01:41 <kmc> i thought "el" was a name of god
12:01:49 <kmc> and they were all something-of-god
12:01:56 <ksf> ...because of http://en.wikipedia.org/wiki/Ariel_(laundry)
12:02:04 <ksf> my hebrew is non-existant.
12:02:09 <ksf> it's just the pattern I noticed.
12:02:12 <Eduard_Munteanu> Ariel? It's a detergent here as well.
12:02:30 <kmc> what's wrong with detergent
12:02:31 <ksf> well, as in "the angel of purity/cleanliness"
12:03:00 <ksf> nothing. but I wouldn't name my kid after one.
12:03:47 <ksf> there'd be problems with the german beaurocracy, too, names have to be sexually unambigious.
12:04:09 <maartenm> Cale: hmm, I tried to rewrite buddhabrot as follows: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15549#a15549
12:04:34 <maartenm>    No instance for (Ix Double)      arising from a use of `accumArray' at mandelbrot.hs:23:9-163    Possible fix: add an instance declaration for (Ix Double)    In the second argument of `($)', namely ..
12:04:45 <maartenm> I don't understand what it expects me to specify further
12:05:02 <ksf> maartenm, it doesn't make sense to index an array with a double, does it?
12:05:11 <maartenm> well I need it here
12:05:12 <ksf> :t round
12:05:13 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:05:29 <ksf> arrays are discrete.
12:05:30 <maartenm> because I effectively want to make a dictionary of (x,y)
12:05:43 <maartenm> oh, it can only handle enums?
12:06:10 <maartenm> ok I'll map it to screen coordinates first
12:06:16 <ksf> well, you could diagonalize rationals...
12:06:30 <ksf> but real numbers are going to be problematic.
12:06:33 <Eduard_Munteanu> ksf, lol, here we have various people naming their children after foreign celebrities, but spelt bad... like "Bred Pit" :)
12:06:42 <Eduard_Munteanu> This one was real, saw it on local TV.
12:07:00 <maartenm> I thought the array was more like a dictionary
12:07:01 <Eduard_Munteanu> Mostly gypsies.
12:07:04 <maartenm> than an actual array
12:07:22 <ksf> ...well, then use a Map.
12:08:17 <ksf> "Ari" is a swiss name iirc, though.
12:09:52 <doserj> Ari is jewish, I would guess.
12:10:08 <kw317> does anyone know what's the name of this theorem: fix(f . g) = f(fix(g . f))?
12:10:13 <ksf> http://en.wikipedia.org/wiki/Ariel
12:10:43 <monochrom>  #haskell-blah
12:10:44 <drhodes> there are no nerd credentials in this channel
12:10:44 <anhe> ari is from greek
12:10:45 <dolio> @free fix
12:10:46 <lambdabot> f . g = h . f => f (fix g) = fix h
12:10:49 <heatsink> kw317: It looks like the definition of fix.
12:11:08 <heatsink> um, no, I misread it.
12:11:33 <drhodes> crap, wrong channel, sorry guys :|
12:11:38 <kw317> nah, it's a thm but I don't know if it's got a name
12:12:38 <kw317> it might come god damn handy in my denotational semantics exam and I'd like to be able to call it something ;-)
12:13:38 <dolio> Let g = g' . f', f = f', h = f' . g' ==> "f' . g' . f' = f' . g' . f' =>f' (fix (g' . f')) = fix (f' . g')
12:13:59 <dolio> So it's a specialization of the free theorem for fix.
12:14:35 <Phyx-> I finally kicked my farmville addiction
12:14:35 <Phyx-> yay
12:14:44 <kw317> free theorem for fix?
12:14:47 <kw317> don't know that one
12:14:55 <monochrom> kw317: Roland Backhouse calls it "rolling rule".
12:15:04 <dolio> Lambdabot just printed it.
12:15:09 <dolio> @free fix
12:15:11 <lambdabot> f . g = h . f => f (fix g) = fix h
12:15:24 <maartenm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15549#a15550  I now have "error in array index"
12:16:06 <maartenm> oh, dammit
12:16:13 <maartenm> ok, arrays are not a good solution for this problem
12:16:17 <mercur1> The bad thing about free theorems is that they are mostly obvious.
12:16:27 <conal> kw317: discussed & used in the worker/wrapper transfo paper
12:16:39 <conal> kw317: by andy gill & graham hutton
12:16:45 <kw317> conal: yes, I remember that paper
12:16:54 <maartenm> does Map also have something similar to accumArray ? Where you take a list of colliding date and accumulate a dictionary from it
12:16:56 <maartenm> *data
12:16:58 <kw317> I was acutally pleased that I proved this stuff before I read it ;-)
12:17:07 <Phyx-> Question, general question, not having too much to do with haskell, But do you guys think a PhD in comp.sci is useful at all?
12:17:15 <kw317> my only point is that if I just want to use it in the exam, I need to call it something
12:17:16 <mercur1> Was it not first used by Wadler?
12:17:19 <ksf> depends.
12:17:22 <ksf> vastly.
12:17:23 <kw317> Phyx-: useful.. no, good to have, yes
12:17:24 <monochrom> f . g = h . f => f (fix g) = fix h  is also called fusion.
12:17:26 <kw317> ;-)
12:17:57 <kw317> I can always just state it w/o proof, but that's a bit risky..
12:17:58 <conal> kw317: probably named in that paper
12:18:01 <ksf> on where you graduate (as in, are you actually learning something), and whether or not your future empoyers care.
12:18:08 <kw317> conal: I'll have a look
12:18:36 <Phyx-> kw317: how so good to have?
12:18:52 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15552#a15552 -- could someone see why they think "findTrill" never returns? It takes a finite list of numbers and tries to find any combination of them whoes concatonation length is no more than 'n'
12:18:59 <Phyx-> my question is basically outside of the research field, is there any point in having it.
12:19:03 <mreh> @src tails
12:19:03 <lambdabot> tails []         = [[]]
12:19:03 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
12:19:14 <kw317> well, there are few jobs that require PhD before your name if you want to be considered, plus you get certain skills that are useful
12:19:16 <ksf> if you, for example, have the opportunity to get it at chalmers or such, hacking away on haskell compilers, go for it.
12:19:17 <Phyx-> does it help when interviewing for an engineering position?
12:19:38 <kw317> it's more what you make of yourself during your phd (it's pretty much about self-development, isn't it?) rather than what you get
12:19:43 <ksf> OSS experience might be more useful
12:19:53 <ksf> also, prior employment.
12:19:59 <Heffalump> Phyx-: it's helpful for the more interesting/challenging engineering positions
12:20:10 <Heffalump> but not for most, and in most cases not as helpful as n years experience would be instead
12:20:11 <kw317> plus if you get some nice scholarship you can live comfortably for couple of years without doing much real "work"
12:20:33 <Phyx-> ksf: I want to do OSS, but most project even though OSS don't really want "outside" developers than the group doing it in my experience
12:20:37 <kw317> so if your demand for cash tails off reasonably quickly, then doing phd is a way to go
12:21:00 <Phyx-> Heffalump: but straight out of uni, i wouldn't have years of experience, outside my own projects
12:21:02 <Heffalump> Phyx-: most small OSS projects welcome new developers
12:21:06 <ksf> it's always a bit hard to prove yourself, in the beginning.
12:21:11 <kw317> plus you then go work in an investment bank and cash 100k+ a year ;)
12:21:13 <Heffalump> Phyx-: right, but you could spend n years getting experience, or n years doing a PhD
12:21:21 <ksf> and yes, aim for smaller projects, less red tape, there.
12:21:40 <Phyx-> Heffalump: so does a PhD count for experience
12:21:50 <kw317> not really
12:21:56 <Heffalump> kw317: I work for an investment bank, and we don't require PhDs for the computing side of things, though they do help. But again, not as much as the same period of experience.
12:21:58 <Phyx-> ksf: i have done some work on some small projects, never recommit my changes though
12:22:00 <Heffalump> Phyx-: in some jobs, yes.
12:22:00 <kw317> it's more about your brain afterwards
12:22:14 <mreh> can we take this offtopic please?
12:22:17 <mreh> :D
12:22:20 <kw317> Heffalump: well, I'm talking more about quant jobs
12:22:34 <monochrom>  #haskell-blah
12:22:36 <Phyx-> sure, what's the haskell off topic channel again?
12:22:36 <Heffalump> well, I work for a quant group. If you want to do quant stuff rather than quant dev stuff, then yes.
12:22:40 <kw317> Heffalump: would you mind if I asked you which one?
12:22:44 <Heffalump> kw317: Credit Suisse
12:22:46 <monochrom> Why do people avoid #haskell-bah
12:22:49 <Phyx-> kw317: Heffalump mind joining me there?
12:22:56 <Phyx-> monochrom: too much blah
12:22:57 * Heffalump doesn't think this is that far off topic, but could move if there's really a strong mood.
12:23:04 <conal> Phyx-: i think you'll find a variety of reactions to a PhD from interviewers & managers, some biased toward and some biased against.
12:23:24 <Eduard_Munteanu> What's #haskell-blah?
12:23:34 <mreh> the off topic channel for #haskell
12:23:37 <monochrom> Just go and find out will you?
12:23:38 <Eduard_Munteanu> Oh.
12:23:43 <Phyx-> conal: kinda like certs
12:23:48 * ksf is fine with phd's as long as they don't assume three letters to make them smart.
12:23:56 <conal> Phyx-: what are certs?
12:24:13 <monochrom> Like if someone posts an url you involuntarily click on it. But if someone posts a channel name you don't involuntarily join it. What's the logic here?
12:24:17 <mreh> please go off-topic, i posted a haskell question and it's been pushed to oblivion
12:24:46 <mreh> i... think... they've....... gone
12:25:31 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15552#a15552 -- could someone see why they think "findTrill" never evaluates? It takes a finite list of numbers and tries to find any combination of them whose concatenation length is no more than 'n'
12:25:47 <mreh> I thought this was the model of lazy programming, until it didn't work
12:25:47 <conal> personally, in considering co-workers, i look for inventiveness & open-mindedness more than knowledge.  a PhD is nearly neutral for me.  ditto for a bachelors or even a high school diploma.
12:25:56 <Eduard_Munteanu> monochrom, I thought there's a guy in that channel, then I join, then he says "Ha! Tricked you!".
12:26:11 <mreh> oh for goodness sake :)
12:26:11 <Eduard_Munteanu> :P
12:26:45 <conal> though, i'm interested in forging new paths, which is probably not typical of job situations.
12:27:05 <heatsink> > tails [1,2,3,4]
12:27:06 <holmak> mreh: That's some meaty code.
12:27:06 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
12:27:39 <mreh> I know why, i'm an idiot
12:27:44 <mreh> holmak, uh.... thanks
12:28:10 <mreh> it's real world haskell!
12:28:25 <holmak> mreh: Ha, I say so because I was trying to figure out the problem. But I was intimidated!
12:28:37 <holmak> mreh: You figured it out though?
12:29:36 <maartenm> hmm, if you ahve an array with type Array (Int,Int) Int
12:29:37 <c_wraith> > tails [1..]
12:29:38 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:29:52 <maartenm> then, "elems" returns the elements in order of the indices
12:29:52 <c_wraith> yeah, tails of an infinite list only returns the first element
12:30:09 <mreh> i was trying to concat an infinite list, bad idea
12:30:15 <maartenm> but how does it order the tuples? does haskell have an Ord class for tuples?
12:30:16 <c_wraith> concat of an infinite list is fine
12:30:19 <mreh> it was a semantic error
12:30:20 <Heffalump> > map (take 3) (tails [1..])
12:30:21 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
12:30:25 <Heffalump> c_wraith: not at all.
12:30:31 <c_wraith> @instances Ord
12:30:32 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:30:37 <mreh> > concat . tails [1..]
12:30:38 <lambdabot>   No instance for (GHC.Enum.Enum [a])
12:30:39 <lambdabot>    arising from the arithmetic sequence...
12:30:40 <mreh> > concat . tails $ [1..]
12:30:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:30:42 <monochrom> > tails [1..] !! 3
12:30:44 <lambdabot>   [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
12:30:55 <maartenm> > (1,2) < (1,3)
12:30:55 <lambdabot>   True
12:30:57 <c_wraith> > concat $ repeat [1, 2, 3]
12:30:59 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
12:31:02 <maartenm> > (2,2) < (1,3)
12:31:03 <lambdabot>   False
12:31:06 <c_wraith> you can concat an infinite list
12:32:53 <mreh> @src concat
12:32:53 <lambdabot> concat = foldr (++) []
12:33:49 <mreh> you know when you mean to do something else but spend the whole day doing haskell?
12:34:51 <Raevel> YES
12:35:03 <Raevel> i love those days
12:35:30 <mreh> like bury dead relatives... just kidding
12:35:49 <mreh> birth of a child
12:36:03 <mreh> take some pictures, i'll look at them later
12:36:12 <systemfault> I know I already asked that question a few days ago but.. is there any way to make that code faster (A similar speed to C) without explicit memoization? http://www.ideone.com/5z3Icote
12:37:06 <maartenm> I finaly have the buddha on my screen!
12:37:28 <maartenm> well, three of them, interlaced, but still, thankis for the help awesome haskell channel
12:38:16 <mreh> maartenm: what?
12:38:27 <mreh> can i see?
12:38:49 <maartenm> sure :)  as I said there's still a bug in it though.. which makes it that more mysterious
12:38:55 <maartenm> let me run it on a bigger resolution
12:39:07 <mreh> by bug... you mean programmer error :)
12:39:13 <mreh> darn those sneaky bugs!
12:40:19 <maartenm> .. sure takes a long time
12:40:52 <mreh> lots more pixels
12:41:20 <mreh> as resolution grows, pixels grow quadratically
12:42:07 <maartenm> http://imgurl.filetac.com/img/25512910.png
12:42:23 <maartenm> there, it is interlaced bya ccident, packing the data wrong
12:42:28 <Phyx-> 21:27:27 < c_wraith> you can concat an infinite list
12:42:32 <Phyx-> really? how?
12:42:34 <maartenm> and each row shifts to the right accidentally.. but it's the buddhabrot
12:42:47 <c_wraith> > cycle [1, 2, 3]
12:42:48 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
12:42:58 <c_wraith> > concat (cycle [1, 2, 3])
12:42:58 <maartenm> only 50 iterations
12:42:59 <lambdabot>   No instance for (GHC.Num.Num [a])
12:42:59 <lambdabot>    arising from the literal `1' at <inter...
12:43:07 <holmak> @src cycle
12:43:08 <lambdabot> cycle [] = undefined
12:43:08 <c_wraith> err
12:43:08 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:43:13 <mreh> c_wraith, you can't concat an infinite list by definition
12:43:24 <c_wraith> > repeat [1,2,3]
12:43:25 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1...
12:43:30 <c_wraith> > concat $ repeat [1,2,3]
12:43:32 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
12:43:45 <mreh> tell me what the last element of that list is?
12:43:46 <c_wraith> you can't concat a list of infinite lists.
12:43:58 <Phyx-> c_wraith: concat if foldr, which performs the operation right associatively, so it'll never even start on an infitite list, and yes by definition you can't concat infinite lists
12:43:59 <c_wraith> But you can concat an infinite list of finite lists
12:44:18 <monochrom> define "can"
12:44:24 <dolio> You can concat an infinite list of infinite lists, it's just identical to the first list.
12:44:25 <Phyx-> c_wraith: i don't see how, you would need every element of the list
12:44:31 <mreh> c_wraith, I can take the first n elements of a concatenation of an infinite list of finite lists
12:44:44 <Phyx-> mreh: sure, but not with concat
12:45:06 <c_wraith> ....  seriously, what part of concat $ repeat [1, 2, 3] do you believe isn't working?
12:45:07 <monochrom> I'm serious. There is "can" meaning the compiler accepts the code. There is "can" meaning it makes a difference.
12:45:11 <mreh> > take 5 .concat $ repeat [1,2,3]
12:45:12 <lambdabot>   [1,2,3,1,2]
12:45:18 <mreh> why not?
12:45:22 <copumpkin> dolio: but after the last element of the first list you start getting the second list!
12:45:41 <dolio> Yes, of course.
12:45:42 <mreh> lol, monochrom is right, this is a definitional thing
12:45:48 <dolio> And it cant' be diagonalized!
12:45:58 <copumpkin> :(
12:46:28 <Phyx-> heh
12:46:29 <monochrom> Too much opinion, too little math and logic.
12:46:46 <Phyx-> ouch...
12:47:09 * copumpkin never has an opinion
12:47:22 * Phyx- won't from now on either
12:47:34 * conal smiles
12:47:36 <c_wraith> @check  \a -> cycle a == concat (repeat a)
12:47:42 <lambdabot>  Terminated
12:47:45 <c_wraith> hehe
12:47:56 <Phyx-> bbl
12:48:36 <c_wraith> @check  \a -> take 50 (cycle a) == take 50 (concat (repeat a))
12:48:39 <lambdabot>   "* Exception: Prelude.cycle: empty list
12:48:44 <c_wraith> nice
12:48:56 <copumpkin> why should cycle complain about an empty list?
12:49:01 <copumpkin> damn unchecked exceptions
12:49:21 <conal> copumpkin: it's a more informative bottom
12:49:22 <c_wraith> @check  \a -> (not . null) a ==> take 50 (cycle a) == take 50 (concat (repeat a))
12:49:23 <lambdabot>   No instance for (Test.QuickCheck.Testable
12:49:24 <lambdabot>                     (Test.QuickCh...
12:49:53 <mreh> Is using your intuition a bad thing is haskell? I tend to find it's normally correct
12:50:00 <copumpkin> conal: it'd still be nice to have an indication of the exceptions in the type somewhere
12:50:01 <mreh> some people say they just sit there and compute
12:50:23 <conal> copumpkin: yeah.  as with head etc?
12:50:28 <copumpkin> yep
12:50:30 <copumpkin> not sure how I'd do it
12:50:39 <monochrom> It doesn't matter. At the end just make sure you're correct.
12:50:40 <copumpkin> probably just not throw an exception in the first place, and just stick it in Maybe :P
12:50:43 <CalJohn> @src fix
12:50:44 <lambdabot> fix f = let x = f x in x
12:50:56 <CalJohn> heh, cheat
12:51:01 <copumpkin> monochrom: we can tell all the rubyists the same thing
12:51:31 <monochrom> Of course all thinking methods are not made equal.
12:52:14 <CalJohn> > fix (+1) 1
12:52:15 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
12:52:16 <lambdabot>    arising from the literal `1' at <...
12:52:29 <Saizan_> > fix (+1)
12:52:33 <lambdabot>   mueval-core: Time limit exceeded
12:52:50 <Philonous> copumpkin: Maybe it would be a good idea to have a compiler-checked total sublanguage of haskell
12:52:55 <copumpkin> I just think there's a bit of a double standard. "Eww, null in every type, so many potential runtime errors! Must use Maybe" vs. "Calling head on an empty list is a logic error, of course it should throw an error and crash your program at runtime"
12:53:15 <copumpkin> (in an uncatchable manner in pure code)
12:54:00 <monochrom> I don't participate in that particular double standard. I am not against null.
12:54:05 <Philonous> Thought it would probably be tricky to convince the compiler that my list here is in fact not emnpty
12:54:11 <CalJohn> partial functions like head and tail are perhaps that most disappointing aspect of haskell
12:55:08 * kmc is waiting to read Real World Agda
12:55:54 <dolio> The difference is that null is a value/pointer/whatever that you're supposed to handle specifically.
12:57:24 <dolio> Bottom is a value where the computation has failed.
12:57:35 <dolio> It's already dereferenced the null pointer.
12:57:37 <mle> it's not hard to implement a safe head, if that is useful.
12:57:51 <dolio> So if you use it, you blow up. In a strict language, you'd always blow up.
12:58:49 <c_wraith> dolio, that's not strictly true.  A calculation that diverges also is considered to return _|_
12:59:03 <dolio> Yes, I'm aware of that.
12:59:14 <dolio> A calculation that diverges has blown up.
12:59:22 <c_wraith> Which isn't the same as an error, though.
12:59:48 <conal> copumpkin: amen about the double standard.  similarly for the one about dis'ing imperative thinking while championing IO.
13:00:35 <conal> copumpkin: and the consequent confusion about wtf our message is.
13:00:35 <dolio> I'm not really wild about head/tail. But I can see the difference.
13:00:49 <Saizan_> it's quite different, you can't use _|_ in APIs like you do with null, precisely because it's uncatchable
13:01:23 <Saizan_> head/tail are "convenience wrappers" like read is, never meant for real use
13:01:26 <dolio> [] is the null in those cases, not _|_.
13:02:07 <conal> Saizan_: sort of like unsafePerformIO perhaps
13:02:23 <Saizan_> conal: or unamb :)
13:02:23 <conal> does a job when our current type system falls short
13:02:36 <conal> Saizan_: yeah!
13:02:40 <conal> Saizan_: touche!
13:03:10 <tensorpudding> if you do (!!) for a list lazily-generated with iterate, does it store the whole list up to the index that you call?
13:03:35 <Philonous> tensorpudding: only the spine
13:03:36 <dolio> Is it shared and used elsewhere?
13:03:49 <conal> in all of these cases (head/unsafePerformIO/unamb), our type system isn't up for capturing the required proof obligation.
13:03:56 <tensorpudding> dolio: no
13:04:03 <dolio> Then no.
13:04:26 <conal> s/unamb/lub/
13:04:52 <dolio> "iterate f x !! i" can discard cons cells as it goes along.
13:05:14 <tensorpudding> okay
13:06:01 <conal> even *recycle* cons cells
13:06:01 <dolio> However, it probably builds nested thunks f (f (f (f ... x)))
13:06:13 <tensorpudding> calculating the 7000th element of this list took (113.56 secs, 4266262996 bytes)
13:06:39 <conal> yeah. our evaluator and garbage collector aren't intimate enough yet.
13:07:14 <dolio> And that thunk probably takes O(n) space.
13:07:39 <tensorpudding> well, it turns out the iterate was generating lists of increasing size as elements
13:07:42 <conal> waiting for a clever phd student to solve, i guess.
13:08:02 <tensorpudding> so the size of elements was growing linearly
13:09:20 <copumpkin> tensorpudding: the bytes are the total allocated btw
13:09:29 <copumpkin> not necessarily how much real memory it used
13:10:42 <tensorpudding> i know
13:20:32 <monochrom> @src iterate
13:20:33 <lambdabot> iterate f x =  x : iterate f (f x)
13:21:16 <monochrom> Try this: myiterate f x = x `seq` (x : myiterate f (f x))
13:21:44 <monochrom> It will show you the problem is not with the cons cells.
13:22:00 <jdavis> Most examples I see online are about how to catch an exception. Is there a simple example of how to throw a user-defined exception from a pure function and catch it in main?
13:22:24 <Saizan_> don't!
13:22:32 <monochrom> I'm afraid can't.
13:22:33 <jdavis> Saizan_: oh, why?
13:22:43 <Beelsebob> jdavis: if your function can return an exceptional value encode that into the type
13:22:57 <kmc> :t throw
13:23:00 <lambdabot> Not in scope: `throw'
13:23:00 <Beelsebob> data Exceptional a = Normal a | Exception -- Also known as Maybe
13:23:04 <kmc> :t Control.Exception.throw
13:23:06 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
13:23:06 <jdavis> Beelsebob: Oh, I see.
13:23:11 <Beelsebob> myFunction :: a -> Exceptional b
13:23:14 <monochrom> But actually the lib allows it. Fine. :)
13:23:31 <kmc> jdavis, i agree, it's not a common thing to do, but you can do it
13:23:49 <Beelsebob> jdavis: I tend to find Either a [String] is a good type for computations which can fail
13:23:53 <monochrom> Write a 10-page essay justifying why you do it. :)
13:24:27 <Saizan_> Beelsebob: not Either [String] a ?
13:24:34 <Beelsebob> one or the other
13:24:37 <kmc> exceptions are mostly for handling IO errors and truly asynchronous things
13:24:45 <Beelsebob> I guess that's more condusive to typical error monads
13:24:53 <monochrom> It is actually not too bad because you have to catch exceptions inside IO anyway.
13:24:56 <kmc> error handling in pure code is better dealt with by an error monad of some kind
13:25:21 <kmc> which (unlike true exceptions) has a simple description in terms of the semantics of pure Haskell
13:25:27 <joe5> i am trying to profile a haskell program and am getting the error: Perhaps you haven't installed the profiling libraries for package `bytestring-0.9.1.5'?
13:25:28 <Beelsebob> which is probably what jdavis needs after that â if you then use the Monoid a => Applicative (Either a) applicative, you can join your computations together nicely :)
13:25:38 <mle> unless you're doing unsafeInterleveIO or the getContents stuff that uses it, IO errors really are synchronous.
13:25:40 <Saizan_> it doesn't violate ref. transparency, but it's a pain to deal with such a function
13:25:44 <joe5> i have installed the bytestring profiling debian package.
13:25:56 <monochrom> joe5: Then like it says, you need to install the profiling version of bytestring-0.9.1.5.
13:26:02 <joe5> just wondering if there is a way to install all required profiling libraries
13:26:04 <Saizan_> joe5: is that for version 0.9.1.5 ?
13:26:07 <monochrom> Oh I see. Then I don't know.
13:26:30 <Saizan_> joe5: no, there isn't an automated way
13:26:37 <kmc> mle, yes, but other things like throwTo aren't
13:26:48 <monochrom> Generally look for libghc6-*-prof
13:26:58 <joe5> monochrom: saizan_: is there a way to install the corresponding profiling library from cabal?
13:27:15 <jdavis> Ok, thank you for the suggestions everyone. I'll look into it.
13:27:27 <mle> yeah that gets tricky.
13:27:34 <joe5> monochrom: saizan_: i installed the package from cabal.
13:27:35 <Saizan_> joe5: cabal install binary-0.9.1.5 -p --reinstall
13:27:47 <joe5>  saizan_: thanks a lot
13:28:49 <monochrom> In my .cabal/config I turn on library-profiling: True
13:29:37 * monochrom has just started using cabal-install yesterday. From Haskell Platform.
13:32:42 <raceRider> do expressions in where clauses of a function definition get resolved once or as many times are they are used in that block?
13:32:54 <adu> i'm confused
13:33:10 <adu> what is the difference between Language.Core.Core and Language.Core.Syntax?
13:33:43 <monochrom> raceRider: I don't understand the question but I make a guess what the question is and then the answer is once.
13:33:49 <Botje> raceRider: if they're values: at most once.
13:33:59 <monochrom> Perhaps define "resolve" mathematically.
13:34:01 <Botje> if they're functions: as much as they're called
13:35:41 <raceRider> by resolve I mean, calculating a result in a guard in the same function. I know lazy part. What I'm not able to figure out is if the resolution happens once (and cached) or as many times as that expression is used in the function?
13:36:41 <holmak> raceRider: Semantically, you shouldn't be able to tell, due to purity. Are you asking for performance reasons?
13:37:00 <Lemmih> adu: The modules are from two different packages, iirc.
13:37:06 <holmak> (I hope I'm right about the semantics statement there, correct me if not)
13:37:41 <adu> Lemmih: it looks like the only difference is "GadtConstr"
13:38:02 <raceRider> holmak, both for performance and for clarity in writing the functions. If cached, I'd move it to where clause, if not, I'll use the expression directly.
13:38:05 <adu> Lemmih: I wonder if its possible to unsafeCast between them...
13:38:47 <Lemmih> adu: No, you should not do that.
13:39:51 <holmak> raceRider: I'm almost completely sure that putting something in a where clause will not hurt your performance. I expect GHC to be much smarter than that.
13:40:45 <Lemmih> adu: Why would you want to use both packages?
13:40:58 <adu> i don't, just curious
13:41:14 <holmak> Surely someone on here can definitively answer raceRider's question...
13:41:48 <holmak> raceRider: If no one can tell you for sure, I would say use the where clause and just use the profiler later, when you have performance problems.
13:41:53 <Heffalump> holmak: botje has already done so
13:42:16 <raceRider> holmak, thanks
13:42:25 <holmak> Gah, reading comprehension failure
13:42:42 <holmak> My apologies
13:43:05 <monochrom> f x = y where {y | x<0 = '-'; y | otherwise = '+'}
13:43:50 <monochrom> the value of y has to be re-computed for every different call to f.
13:45:06 <monochrom> g x = y where y=f 0   this one may be memoized but consider it an optimization not a given.
13:50:59 <raceRider> monchrom, yes thanks
13:56:59 <joe5> i am profiling a program to see if it can run any faster: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15555#a15555
13:57:09 <joe5> wondering if you have any suggestions/comments?
13:59:09 <Lemmih> joe5: Why are using Integers?
13:59:21 <koeien37> Integer -> Int is a start, yeah
13:59:26 <koeien37> although it's slightly evil imo
13:59:35 <joe5> lemmih: just as I do not know any differently. any suggestions, please?
13:59:36 <Axman6> Integer-- for performance critical work
13:59:49 <Axman6> use Int
13:59:50 <Lemmih> joe5: Also, see testBit.
13:59:52 <koeien37> Integer is unbounded, Int is basically a machine-sized integer
13:59:53 <tensorpudding> is Integer that much slower than Int?
14:00:05 <koeien37> i'm not sure, but it's a start. you can find out easily
14:00:17 <Axman6> tensorpudding: there's some pattern matching overhead for every Integer operation i think
14:00:21 <koeien37> or use Word8, saves a conversion
14:00:40 <joe5> > :t testBit
14:00:40 <Axman6> Word8's good too
14:00:41 <lambdabot>   <no location info>: parse error on input `:'
14:00:43 <koeien37> also, try avoiding reverse, I guess
14:00:47 <tensorpudding> Word8 is your standard 8-bit unsigned int
14:00:49 <Axman6> :t testBit
14:00:50 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
14:00:58 <dolio> Even if you could unbox everything, Integer stuff would have to do overflow checks on lots of operations.
14:01:14 <joe5> ok, will try out Int. Thanks a lot folks.
14:01:25 <ehamberg> i'm rewriting some code to use MonadRandom instead of explicitly passing random generators everywhere. problem is, i have a function returning Rand g a and i need to evaluate another Rand function, and for this i need the random generator. is my thinking wrong if i need the generator? how should this be done?
14:01:33 <tensorpudding> the downside to Int is that you have to be vaguely careful about overflows
14:01:49 <koeien37> right. that's not an issue in this code, but it's good to keep in mind
14:01:59 <tensorpudding> though some domains you never have to worry about it
14:03:02 <joe5> tensorpudding: thanks
14:03:08 <joe5> koeien37: thanks
14:03:37 <joe5> :src testBit
14:03:43 <joe5> @source testBit
14:03:43 <tensorpudding> @src testBit
14:03:43 <lambdabot> testBit not available
14:03:44 <lambdabot> Source not found. Maybe you made a typo?
14:03:51 <joe5> @src testBit
14:03:52 <lambdabot> Source not found. Take a stress pill and think things over.
14:03:58 <tensorpudding> it is in Data.Bit..
14:04:04 <joe5> thanks again.
14:04:12 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15556#a15556
14:04:13 <koeien37> Data.Bits ?
14:04:15 <Berengal> Thoughts?
14:04:16 <tensorpudding> err, Data.Bits
14:04:43 <Axman6> joe5: also, the return () at the end of main is unneeded
14:04:52 <Axman6> :t writeFile
14:04:54 <lambdabot> FilePath -> String -> IO ()
14:04:58 <tensorpudding>     x `testBit` i       = (x .&. bit i) /= 0
14:05:14 <tensorpudding> hmm
14:05:19 <koeien37> Berengal: curious
14:05:22 <tensorpudding>     bit i               = 1 `shiftL` i
14:06:01 <Berengal> koeien37: It's probably possible to get rid of the intermediate list in "step" altogether, but I suspect GHC is already doing a good job of that.
14:08:58 <Heffalump> Berengal: unlikely; it only does foldr/build and unfold/destroy fusion.
14:08:58 <Berengal> I see I also made a bad
14:09:10 <Berengal> Heffalump: In that case, get rid of it
14:09:14 <Berengal> The list that is
14:09:35 <Berengal> However, I noticed fact2 is much better than mconcat...
14:10:34 <dolio> GHC doesn't do unfold/destroy, does it?
14:10:56 <joe5> > testBit 8 2
14:10:58 <lambdabot>   Ambiguous type variable `t' in the constraint:
14:10:58 <lambdabot>    `Data.Bits.Bits t'
14:10:58 <lambdabot>      a...
14:11:16 <koeien37> > testBit (8::Word8) 2
14:11:17 <lambdabot>   False
14:11:39 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15556#a15560
14:11:55 <Berengal> mconcat isn't even optimized, unlike product
14:12:22 <joe5> 26 seconds chopped off by changing the definitions from Integer to Int
14:12:29 <povman> Why is build :: (forall b. (a -> b -> b) -> b -> b) -> [a]     rather than   build :: ((a -> b -> b) -> b -> b) -> [a]  ?
14:12:34 <joe5> koeien37: thanks.
14:12:49 <dolio> Those are significantly different types.
14:12:59 <povman> What's the difference?
14:13:05 <koeien37> Int is bounded
14:13:10 <koeien37> Integer is an integer
14:13:30 <koeien37> > maxBound :: Int
14:13:31 <lambdabot>   9223372036854775807
14:13:34 <koeien37> > maxBound :: Integer
14:13:34 <dolio> For the latter, the caller of build gets to choose b. For the former, build does, essentially.
14:13:35 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
14:13:35 <lambdabot>    arising...
14:13:37 <conal> Int is not only unbounded but even undefined / platform-specific
14:13:49 <koeien37> bounded, you mean
14:14:04 <Berengal> Int is at least 29 bits...
14:14:20 <dolio> At least 30, no?
14:14:23 <conal> koeien: yes.
14:14:37 <Berengal> dolio: Perhaps it was 29 bits without the sign...
14:14:49 <conal> it's the "at least" part that troubles me, in a language with otherwise mostly unambiguous semantics.
14:14:49 <dolio> -2^29 to 2^29 - 1.
14:15:14 <koeien37> Int is mainly about performance
14:15:31 <koeien37> I don't really see the problem, I use Integer most of the time, except in calls to take and so on
14:15:35 <conal> and pervasive in other types' interfaces.
14:15:46 <Lemmih> joe5: You could make it even faster.
14:15:47 <povman> dolio: cool, thanks
14:15:49 <koeien37> that's the mean issue, although you could use genericLength & friends
14:16:09 <Berengal> genericLength and friends are hacks
14:16:10 <Paczesiowa> is patch-tag broken? I've been waiting for a new repo for 10 minutes.
14:16:12 <conal> koeien37: where available.
14:16:51 <joe5> lemmih: will refactor the code with testBit. I think it will be faster with that.. let  me try..
14:17:12 <conal> koeien37: about "I don't really see the problem", you're not alone.  so i wrote a blog post a while back: http://conal.net/blog/posts/notions-of-purity-in-haskell/
14:18:09 <Lemmih> joe5: Also, you don't actually want to use Int's. Remove the fromIntegral's and see what types you end up with.
14:18:12 <koeien37> cool, I'll read
14:18:52 <conal> koeien37: it was a controversial post.  not everyone shares my ambitions of purity for haskell.
14:19:55 <koeien37> I disagree with it mainly out of practicality
14:20:10 <koeien37> you should be able to optimize the hell out of a Haskell program without resorting to FFI
14:20:29 <koeien37> if that's possible with Int32, fine, use that
14:20:37 <conal> koeien37: many folks believe they can't have practicality and purity both.
14:20:55 <mreh> Can you program a LALR parser in haskell?
14:21:05 <koeien37> @faq Can you program a LALR parser in Haskell?
14:21:05 <lambdabot> The answer is: Yes! Haskell can do that.
14:21:05 <mreh> ...easily
14:21:25 <Berengal> conal: x^2 = 0 -> x = 0 is either False or True depending on the mathematical environment too
14:21:25 <mreh> what's the appropriate monad?
14:21:28 <dolio> Int32 isn't the right Int for speed on all platforms.
14:21:34 <conal> koeien37: while i'm optimistic -- encouraged with the progress we've already made to practical purity.  i like to keep pushing.
14:21:38 <koeien37> dolio: which is my point
14:21:50 <koeien37> conal: my default would be to use Integer
14:22:19 <koeien37> if I see some performance bottleneck, I'd like to be able to prove that it's within a certain range and use Int then
14:22:30 <koeien37> maybe we should call it UnsafeInt
14:22:35 <mreh> I need to access a token stream with a lookahead, what's the best way to do that implicitly?
14:22:36 <dolio> So removing Int means you get to use CPP.
14:22:51 <conal> Berengal: you mean depending on the types and the chosen meanings of ^ and 0 (and maybe =)?
14:23:14 <koeien37> whether we are working in a ring without zero divisors, I'd presume
14:23:17 <altmattr_> just read that blog post - what is the justification for system.info not having an io type?
14:23:22 <Berengal> conal: No, without overloading any of those.
14:24:20 <Axman6> altmattr_: possibly because they're all things that can be there at compile time
14:24:43 <koeien37> mreh: any reason not to use Parsec or Happy?
14:24:50 <Berengal> conal: It depends on if your universe has some numbers which name I always forget
14:24:55 <Axman6> though maybe not, since it seems to refer to the system the program is running on, not compiled on
14:24:55 <Heffalump> altmattr_: it depends what you expect the scope of referential transparency to be.
14:25:02 <koeien37> Berengal: zero divisors?
14:25:08 <altmattr_> right,  won't change during execution
14:25:09 <mreh> koeien37, i'm not actually making a parser, but I'm doing something analogous to it I think
14:25:15 <Heffalump> altmattr_: if you expect it to be the universe, clearly it should have an IO type. If you expect it to be a single program run, then the existing type is fine.
14:25:22 <Berengal> koeien37: No, they're just so small that x^2 = 0, but they're not zero
14:25:34 <conal> Berengal: if you remember the details and you think you have a new & relevant contribution to make to the blog discussion, please go for it.
14:25:37 <Heffalump> of course, once we get mobile code, some rethinking will be needed.
14:25:46 <altmattr_> heffalump: ah
14:25:50 <koeien37> yeah, Erlang style code would break here
14:26:01 <dolio> Infinitesimals.
14:26:04 <mreh> koeien37, it's an automatic music generation kit, and notating a load of generated music is hard, I need to look ahead to decide the right accidentals
14:26:06 <koeien37> passing functions to other nodes
14:26:11 <Berengal> conal: I know I can find the details, but I feel it's mostly a philosophical issue
14:26:24 <aep> hmpf ok i think i need to learn category theory to get anything done. Is there any self contained manual for it without all the science?
14:26:35 <koeien37> i doubt you need it
14:26:36 <Berengal> dolio: No, not those, but they could be used to derive functions (without calculus)
14:26:46 <conal> Berengal: "philosophical" meaning you don't know how to relate it to language design?
14:26:54 <koeien37> to "get anything done". Although CT might be interesting
14:27:08 <conal> Berengal: asking, as i have not problem with philosophy
14:27:11 <conal> s/not/no/
14:27:26 <Berengal> conal: Yeah, mostly. Or, at least, it's irrelevant to anything practical. What normal people usually call semantics ;)
14:27:39 <aep> well pretty much every document in haskell refers to some math stuff i never heared of and when i google it, it turns out to be simple category theory, which i happened to suck at in school
14:27:43 <koeien37> what's the problem with it not having an IO type?
14:28:06 <koeien37> aep: you mean Functor or Monad?
14:28:16 <koeien37> you might want to read the Typeclassopedia
14:28:19 <aep> monad i guess.
14:28:23 <conal> Berengal: oh yeah.  i'm always baffled when people say "it's *just* semantics".  as if there were something more important about utterances than their meanings.
14:28:38 <aep> i STILL dont know what a monad is, even after writing two toy haskell programs
14:28:45 <c_wraith> don't worry about it.
14:28:53 <koeien37> oh, right. Then try Cale's introductions imo
14:28:55 <c_wraith> If you know how to use IO, ignore what monads are, for now.
14:28:55 <koeien37> a bit dense
14:29:06 <koeien37> do you know what typeclasses are?
14:29:07 <c_wraith> You'll figure it out in a while.
14:29:20 <aep> koeien37: the haskell ones, yeah. no idea how it relates to math
14:29:27 <aep> c_wraith: while writing stuff? that would be cool
14:29:37 <Berengal> conal: Anyway, I'll probably post a blog about it when my blog engine has a comment system... I've got a couple of other posts lying around as well
14:29:48 <koeien37> If you want to know about monads, I'd read http://haskell.org/haskellwiki/Monads_as_computation . If you want to know about just IO, ignore monads for now, yes
14:29:50 <conal> Berengal: cool!
14:30:04 <Philonous> A monad is a monoid in the category of endofunctors, what's the problem?
14:30:15 <koeien37> monoidal object*
14:30:16 <aep> yeah io is easy, but then there is stuff like StateT. the docs just point to some paper
14:30:20 <int-e> @quote monoid
14:30:20 <lambdabot> kmc: says: (): worst monoid ever
14:30:21 <c_wraith> aep:  pretty much.  You'll eventually see the pattern that monads abstract out.  But really, it's just a design pattern that happens to work well for certain kinds of problems.
14:30:27 <conal> aep: the main purpose of Monad is to unnecessarily confuse newbies.
14:30:34 <aep> heh
14:30:55 <conal> aep: a secondary purpose is some nice structuring of abstractions.
14:31:10 <ben> Monads apply the type system to ensure that newbies do not escape from their tutorials
14:31:44 <c_wraith> Really, ignore the details about monads, and just write programs.
14:31:53 <conal> ben: heh!
14:32:04 <aep> thanks for the heads up.  going to :)
14:32:05 <c_wraith> After you start to learn more libraries, you'll see how the common pattern develops
14:32:25 <koeien37> yeah, Parsec is an example
14:32:39 <aep> btw i read "Monads as computation". it makes sense, but sometimes haskell people mention stuff that doesnt to me
14:32:48 <koeien37> feel free to ask
14:32:48 <c_wraith> I think it was when I was learning Parsec that I really understood how useful it was to just have a common abstraction.
14:33:21 <c_wraith> I was like...  "hey, I can treat this just like all those other things I've learned.  And it just works!"
14:33:26 <ben> I think the best plan is to ignore IO and learn the rest of haskell syntax and types and then read one of those tutorials that make you implement the state monad or something
14:33:31 <koeien37> after knowing the semantics of some toy imperative language, and then learning Haskell, I discovered how easy they are
14:34:03 <aep> hmm i think i'll go check out parsec. thanks!  i love to learn by doing
14:34:04 <koeien37> learning a little bit about IO is useful imo. not everything should be in the IO monad, but just easy printing/reading files
14:34:38 <koeien37> I couldn't write Hello World after my functional programming course
14:34:58 <aep> yeah me neither
14:35:10 <aep> i forgot everything from it anyway
14:35:24 <aep> it was all about drawing circles around stuff...
14:35:26 <koeien37> which was fine, in a sense, because we learned all kinds of stuff that I know recognize as category theory and universal algebra so on :)
14:35:59 <mreh> preflex: seen mmorrow
14:35:59 <preflex>  mmorrow was last seen on #haskell 4 days, 14 hours, 2 minutes and 4 seconds ago, saying: * mmorrow refocuses back on topic
14:36:07 <koeien37> nowadays they changed the course to be more practical, and they're using Gtk2Hs -- a better idea
14:36:09 <mreh> @tell
14:36:09 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
14:36:22 <mreh> @list
14:36:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:36:53 <Philonous> I wonder, where do we use the fact that IO is a monad (and not only an arrow)?
14:37:08 <joe5> Lemmih: testBit was a brilliant idea. It has simplified the code so much. Thanks a lot..
14:37:24 <Philonous> Would we loose much if we only had access to the arrow interface when trying to do IO?
14:38:57 <Berengal> Philonous: It'd be even more verbose than it is today, I think. It's not like it's hard to use <=< when that fits best anyway
14:39:15 <mreh> any haskorers out there? making an improv library, could sure use some input.
14:39:26 * gwern grins as he uses 'rubose', 'mephitic', and 'horripilating' in a patch description
14:39:35 <c_wraith> I still fail to use <=<
14:39:40 <c_wraith> :t (<=<)
14:39:42 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:39:48 <mreh> @wn rubose
14:39:50 <lambdabot> No match for "rubose".
14:39:56 <mreh> @wn mephitic
14:39:56 <lambdabot> *** "mephitic" wn "WordNet (r) 2.0"
14:39:57 <lambdabot> mephitic
14:39:57 <lambdabot>      adj : of noxious stench from atmospheric pollution [syn: {miasmic}]
14:40:00 <heatsink> @wn horripilating
14:40:01 <lambdabot> No match for "horripilating".
14:40:14 <Philonous> Berengal: Well, I'd rather have more syntactic sugar than an abstraction that doesn't fit
14:40:19 <gwern> my vocab is too awesome for WordNet
14:40:26 <c_wraith> oh.  it's monad action composition
14:40:32 <gwern> heatsink: protip, never search with endings like 'ing'
14:40:37 <gwern> @wn horripilate
14:40:37 <lambdabot> *** "horripilate" wn "WordNet (r) 2.0"
14:40:38 <lambdabot> horripilate
14:40:38 <lambdabot>      v 1: have one's hair stand on end and get goosebumps; "I
14:40:38 <lambdabot>           horripilate when I see violence on television"
14:40:38 <lambdabot>      2: cause (someone's) hair to stand on end and to have
14:40:38 <Philonous> Berengal: And do notation for arrows isn't much worse than for monads
14:40:39 <lambdabot>         goosebumps; "Hitchcock movies horripilate me"
14:40:43 <povman> :t (<*>)
14:40:44 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:40:47 <c_wraith> I probably should use it in my code.
14:40:48 <Berengal> Philonous: The translation is
14:40:54 <Berengal> Philonous: And Monads don't fit?
14:41:20 <dolio> Obviously it does fit, because we have a Monad instance.
14:43:21 <c_wraith> @src (<=<)
14:43:22 <lambdabot> Source not found. It can only be attributed to human error.
14:43:26 <Berengal> Philonous: It's not like you can't use arrows for IO as it is anyway. There's a few wrappers, sure, but you could always alias them to "io" or something
14:45:20 <Cale> c_wraith: Indeed. Actually, (<=<) might be the nicest possible way to define what a monad is.
14:45:28 <m0nkfish> firstonly = foldassoc (\x y -> y)
14:45:36 <m0nkfish> is \x y -> y the same as const
14:45:46 <m0nkfish> or rather, the opposite
14:45:46 <Tobsan> m0nkfish: yes
14:45:53 <Tobsan> @src const
14:45:53 <lambdabot> const x _ = x
14:46:02 <Cale> c_wraith: Because if you write the monad laws in terms of (<=<), they turn into  return <=< f = f,  f <=< return = f,  and  (f <=< g) <=< h = f <=< (g <=< h)
14:46:02 <m0nkfish> ok so its flip const
14:46:19 <Tobsan> m0nkfish: no, it's the opposite of const
14:47:04 <koeien37> I like join
14:47:05 <Philonous> Berengal: Yes, I was barking up the wrong tree. ArrowApply actually gives us something
14:47:33 <c_wraith> is join actually weaker than >>= ?  It kind of looks like you need fmap and join to build >>=
14:47:38 <koeien37> but, yeah, (m >>= k) >>= l === m >>= (\x -> k x >>= l) is a bit messy
14:47:39 <Tobsan> m0nkfish: nvm what I said. Of course it is flip const
14:47:49 <Cale> c_wraith: in a sense, yeah
14:47:52 <koeien37> yeah, but every Monad is (should be) a Functor anyway
14:47:55 <Berengal> conal: http://en.wikipedia.org/wiki/Dual_number
14:47:58 <skorpan> @pl \x -> k x >>= l
14:47:58 <lambdabot> (l =<<) . k
14:48:04 <conal> Berengal: yep
14:48:51 <joe5> > map fromEnum $ zipWith (flip testBit) [0..7] $ replicate 8 (5::Int)
14:48:53 <lambdabot>   [1,0,1,0,0,0,0,0]
14:49:17 <c_wraith> koeien37: I'm thinking about "if we made the typeclasses make sense, what's the minimal definition of Monad, in terms of being the weakest operation that gives what is necessary".
14:49:47 <Cale> c_wraith: The traditional definition of Monad is fmap/return/join
14:50:11 <c_wraith> and if the typeclasses made sense, fmap and return would come from other classes.
14:50:17 <Cale> (Well, that's the nearest translation into Haskell)
14:50:37 <ben> @pl \x -> f x . g . h x
14:50:37 <lambdabot> liftM2 (.) f ((g .) . h)
14:51:57 <ben> @pl \x -> (x, g x)
14:51:57 <lambdabot> ap (,) g
14:52:12 <ben> @src ap
14:52:12 <lambdabot> ap = liftM2 id
14:52:28 <c_wraith> I'm curious about fitting applicative functors in.  they're somewhere between pointed functor and monad.  Is there something even weaker than join that you can add to applicative functors, taking advantage of <*> ?
14:54:10 <ben> ap is terrible
14:54:44 <Cale> What's wrong with ap?
14:55:00 <ben> I do not understand what @pl just did
14:55:49 <Cale> ben: The instance of monad for functions makes ap into the traditional S function
14:56:02 <Cale> ap x y z = x z (y z)
14:56:19 <Cale> (if you know SKI-calculus, this will be familiar)
14:56:46 <conal> (SKI) especially if you look at Applicative before Monad
14:56:53 <Cale> indeed
14:57:08 <Cale> pure and <*> are exactly K and S respectively
14:57:25 <Cale> > (do x <- id; y <- reverse; z <- map toUpper) "hello"
14:57:26 <lambdabot>   <no location info>:
14:57:26 <lambdabot>      The last statement in a 'do' construct must be an ...
14:57:31 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
14:57:32 <lambdabot>   ("hello","olleh","HELLO")
14:58:04 <Cale> So, there's an example that pretty clearly shows what it means to "run" a function -- it just means to apply it to the parameter that the whole function is applied to
14:59:01 <Cale> what ap does can also be written  ap f x = do g <- f; y <- x; return (g y)
15:00:02 <Cale> So perhaps you can see how that works out, roughly :)
15:00:16 <joe5> is it preferable to have a function that operates on a list item and then do the concatMap in the higher order function or have a function that can take the whole list as an argument?
15:01:01 <Cale> joe5: depends on what you're doing / either seems fine :)
15:01:03 <joe5> i know that it does not have any effect on the program output but am wondering which the correct way of going about it would be.
15:01:40 <osfameron> what's the nicest idiom to apply a transformation to nth element of a list ?
15:01:43 <Cale> What's your function?
15:01:46 <joe5> does it matter from a performance standpoint?
15:02:01 <joe5> Cale: splitToBits = map fromEnum $ zipWith (flip testBit) [0..7] $ concatMap (replicate 8)
15:02:20 <joe5> Cale : or splitToBits = map fromEnum $ zipWith (flip testBit) [0..7] $ replicate 8
15:02:35 <joe5> and do concatMap in the calling function?
15:03:12 <Cale> joe5: Seems to depend on whether you ever expect to need this on one element at a time
15:03:34 <Cale> Also, shouldn't those be (.) rather than ($)?
15:03:57 <joe5> where? that line tests fine in ghci?
15:04:03 <joe5> where? that line tests fine in ghci.
15:04:28 <joe5> > map fromEnum $ zipWith (flip testBit) [0..7] $ replicate 8 (5::Int)
15:04:30 <lambdabot>   [1,0,1,0,0,0,0,0]
15:04:48 <Cale> See, this is why (.) is nicer than ($) ;)
15:04:52 <joe5> > map fromEnum $ zipWith (flip testBit) [0..7] $ replicate 8 [(5::Int),(6::Int)]
15:04:54 <lambdabot>   No instance for (Data.Bits.Bits [GHC.Types.Int])
15:04:54 <lambdabot>    arising from a use of `...
15:04:57 <Cale> Try making either one of those definitions :)
15:05:07 <Stalafin> in lyah they wrote "indentation is important in haskell" ... what's that supposed to mean? in how far is it important?
15:05:17 <Cale> :t let splitToBits = map fromEnum $ zipWith (flip testBit) [0..7] $ concatMap (replicate 8) in splitToBits
15:05:18 <lambdabot>     Couldn't match expected type `[b]'
15:05:19 <lambdabot>            against inferred type `[a] -> [a]'
15:05:19 <lambdabot>     In the second argument of `($)', namely `concatMap (replicate 8)'
15:05:23 <Cale> ^^ see?
15:05:37 <sjanssen> Stalafin: indentation changes the meaning of your code
15:05:38 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
15:05:43 <jlouis> Stalafin: identation is used to separate certain things, variants in case statements for instance
15:06:13 <Stalafin> sjanssen, jlouis: can you give me an example where i should really take care of that?
15:06:31 <joe5> Cale: sorry, I do not understand.
15:06:41 <jlouis> Stalafin: consider a case in a case and then line up the cases incorrectly
15:06:43 <Cale> Stalafin: It means to configure your text editor to produce spaces and not tabs right now, or else lose all your hair when you pull it out in frustration.
15:06:52 <joe5> Cale: i would like to use . instead of $ as I think it is more elegant
15:07:02 <joe5> Cale: but I doubt that I can do so here.
15:07:05 <Stalafin> Cale: my vim produces for spaces instead of one tab :)
15:07:19 <Stalafin> Cale: s/for/four/
15:07:22 * osfameron comes up with: mapElem f i a = let (pre, (me:post))  = splitAt i a in pre ++ (f me) : pos
15:07:25 <Cale> joe5: Whenever you have  f $ g $ h $ x  because $ has the wrong associativity, it means the same thing as  f . g . h $ x
15:07:36 <Cale> But f $ g $ h is a type error
15:07:54 <joe5> Cale: thanks, will give it a try.
15:07:55 <mux> or f . g $ h x  -- one operator less
15:07:59 <Cale> Because that means to apply f and g to *h* and not the result of h
15:09:15 <Cale> joe5: f $ x = f x, but with really low precedence (the important part), and right associative (for now, but this was an unfortunate mistake and it really should have been left associative)
15:09:51 <dolio> I'm becoming less optimistic that ($) will ever be left associative.
15:10:02 <Cale> So whenever you see f $ x, f needs to be a function, and x needs to be a value to which f can be applied
15:10:16 <ben> Do we have an @unlistcomprehension command?
15:10:27 <dolio> It's @undo
15:10:48 <Cale> @undo [f x | x <- [1..n], y <- [1..x], x + y == z]
15:10:49 <lambdabot> concatMap (\ x -> concatMap (\ y -> if x + y == z then [f x] else []) [1 .. x]) [1 .. n]
15:10:52 <ben> oi
15:11:21 <ben> @undo [(a, b) | a <- list, b <- list, a /= b]
15:11:22 <lambdabot> concatMap (\ a -> concatMap (\ b -> if a /= b then [(a, b)] else []) list) list
15:12:16 <Cale> joe5: Whereas (.) means function composition, and so whenever you see f . g, both f and g should be functions, and f should be a function whose parameter is the same type as g's result.
15:12:31 <Stalafin> in a do block in a main function, why do i have to use a let statement to bind values to names? why can't i just bind values to names w/out the let?
15:12:46 <Cale> Stalafin: What's that supposed to mean?
15:13:04 <ben> @undo [(a, b, c, d) | a <- list, b <- list, c <- list, d <- list, a /= b, b /= c, c /= d, a /= c, b /= d, a /= d, sort (a++b) == sort (c++d)]
15:13:04 <lambdabot> concatMap (\ a -> concatMap (\ b -> concatMap (\ c -> concatMap (\ d -> if a /= b then if b /= c then if c /= d then if a /= c then if b /= d then if a /= d then if sort (a ++ b) == sort (c ++ d)
15:13:04 <lambdabot> then [(a, b, c, d)] else [] else [] else [] else [] else [] else [] else []) list) list) list) list
15:13:09 <Cale> Stalafin: What syntax would you use?
15:13:30 <joe5> :t :t concatMap ( map fromEnum . zipWith (flip testBit) [0..7] . replicate 8 ) (Data.ByteString.Lazy.unpack contents)
15:13:30 <Cale> Stalafin: v <- x means "Run the action x, naming its result v"
15:13:31 <lambdabot> parse error on input `:'
15:13:33 <joe5>  :t concatMap ( map fromEnum . zipWith (flip testBit) [0..7] . replicate 8 ) (Data.ByteString.Lazy.unpack contents)
15:13:42 <joe5> Cale: how about this?
15:13:46 <joe5> > concatMap ( map fromEnum . zipWith (flip testBit) [0..7] . replicate 8 ) (Data.ByteString.Lazy.unpack contents)
15:13:48 <lambdabot>   Not in scope: `Data.ByteString.Lazy.unpack'Not in scope: `contents'
15:13:55 <Cale> Stalafin: which is not the same as let v = x which means "define v to be the same thing as x"
15:13:56 <Stalafin> Cale: it's hard to explain: http://learnyouahaskell.com/input-and-output#hello-world here, when they explain a <- return
15:14:25 <Stalafin> they basically say that a <- return "bla" is the same thing as let; a = "blah"
15:14:37 <Cale> let a = "blah"  rather
15:14:37 <Stalafin> Cale: and i am trying to understand why there is the need of let
15:14:44 <Stalafin> Cale: well, yeha
15:14:55 <Cale> It's not really the same in all cases
15:15:05 <Cale> But it's pretty close
15:15:07 <Stalafin> Cale: if you search for let a = "hell" on the page i gave you
15:15:16 <Stalafin> Cale: that's the piece of code i mean
15:15:26 <joe5> > concatMap ( map fromEnum . zipWith (flip testBit) [0..7] . replicate 8 ) [1::Word8,2::Word8]
15:15:27 <lambdabot>   [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0]
15:15:28 <Cale> Stalafin: sure
15:15:34 <Stalafin> Cale: and i don't understand why we need a let there at all
15:15:38 <joe5> > concatMap ( map fromEnum . zipWith (flip testBit) [0..7] . replicate 8 ) [1::Word8,3::Word8]
15:15:39 <Stalafin> Cale: why we can't just omit the let
15:15:39 <lambdabot>   [1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0]
15:15:51 <Cale> Stalafin: because the syntax demands that we put it in.
15:16:05 <Stalafin> Cale: so, may i ask, what if not?
15:16:14 <Cale> Stalafin: You will get a syntax error
15:16:19 <Stalafin> ok oO
15:16:31 <Cale> Or you're wondering the reason for the syntax?
15:16:37 <Stalafin> yeah
15:16:39 <Stalafin> actually, that
15:16:47 <Cale> hmm...
15:17:36 <Cale> I suspect that parsing becomes complicated in some way without the let and the secret braces and semicolons that the layout translator's going to insert there
15:17:47 <Cale> See, you can define more than just constants
15:17:49 <Stalafin> Cale: all they explain there is what <- is in regards to all those funky I/O statements, but they don't understand why we need a let
15:18:07 <Cale> You can put any set of function definitions, complete with type signatures in there
15:18:37 <Cale> I suspect one reason it's complicated is that the parser would have to guess where the block of definitions ends
15:19:19 <Cale> So the explicit let and layout help the parser know when your block of (possibly mutually recursive) definitions ends
15:20:16 <Cale> do let { <decls> }; <stmts>   --->   let { <decls> } in do <stmts>
15:20:50 <Stalafin> Cale: hm... okay... i guess i will just have to accept that..
15:20:52 <Cale> That's the translation rule which is part of how do-notation gets de-sugared away
15:21:00 <Cale> along with
15:21:08 <Cale> do { x } = x   -- base case
15:21:27 <Cale> do { x ; <stmts> } = x >> do <stmts>
15:21:38 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do <stmts>
15:21:55 <Stalafin> Cale: suffice to say, i don't exactly understand that ^^
15:22:04 <jlouis> Stalafin: it is a parsing problem. In C you can't omit the parens in if (x == 0) ...
15:22:05 * sinelaw just lost a battle to Matlab
15:22:13 <Cale> Well, perhaps you've not seen the >> and >>= operators yet
15:22:22 <Stalafin> Cale: i haven't
15:22:40 <Cale> Stalafin: But you can sort of work out what they must mean if you can understand the do-notation there
15:22:43 <Stalafin> Cale: for now, i am just gonna stick with the do being some sort of iteration
15:22:53 <Stalafin> Cale: which is bad :D
15:23:01 <Cale> @undo do u <- x; v <- y; return (f u v)
15:23:01 <lambdabot> x >>= \ u -> y >>= \ v -> return (f u v)
15:23:19 <Cale> Those two mean the same thing
15:23:40 <Stalafin> sure ^^
15:23:41 <Cale> The do notation is really syntactic sugar for using this >>= function over and over
15:24:24 <Cale> x >>= f  roughly means "the action which when you run it will run x, and give the result of that to the function f which will tell us what to do next, and do that"
15:24:43 <Cale> That is, it means the same thing as   do v <- x; f v
15:25:09 <Stalafin> Cale: well, alright; thanks for the eplanation; for now i am just gonna stick with that... guess i just need a little time with the language
15:25:28 <Cale> (but of course, you can't just go in circles, you have to stop somewhere, and we cut it off by defining >>= explicitly
15:25:29 <Cale> )
15:25:46 <Stalafin> ok
15:26:05 <EvanCarroll> @src intersperse
15:26:06 <lambdabot> intersperse _   []     = []
15:26:06 <lambdabot> intersperse _   [x]    = [x]
15:26:06 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
15:26:36 <Cale> anyway, the real purpose of let is that it's sometimes convenient to make some definitions based on the results of actions which came before that point in the do-block
15:26:59 <Cale> So, for instance, I can get a line of text from the user, and then define a new function which uses that line of text
15:27:39 <Cale> do x <- getLine; let f y = x ++ y; ... do stuff with f ...
15:27:40 <EvanCarroll> > intersperse 0 [1,2,3,4,5,6]
15:27:41 <lambdabot>   [1,0,2,0,3,0,4,0,5,0,6]
15:28:25 <Stalafin> Cale: well, that makes sense... obviously we wouldn't be able to define a function with main= without that
15:28:31 <Cale> If I defined f separately, it would have to take x as an extra parameter, and sometimes that's not as convenient
15:29:10 <Cale> (this particular example is a bit silly, but imagine f being something more complicated, and possibly using more results of previous actions)
15:29:37 <Stalafin> Cale: indeed.... from that example i don't see your point, but i guess that make sense further down the road
15:30:10 <Cale> Another common case is to define and then use some sort of loop
15:30:31 <Stalafin> Cale: but don't we hate loops?
15:30:33 <Cale> do let { loop = do putStrLn hello; loop }; loop
15:30:52 <Cale> Though for this exact case, we have a function called forever in Control.Monad
15:31:12 <Cale> So you could also write that as  forever (putStrLn hello)
15:31:36 <sinelaw> conal, hey. i'm finally free from that communications assignments. met some interesting examples of systems on the way
15:31:37 <Stalafin> ah, ok... such a loop :D
15:31:40 <Cale> There are also handy things in there like forM/mapM
15:31:54 <Cale> forM [1..10] $ \x -> print x
15:31:56 <conal> sinelaw: woot!  congrats.
15:32:11 <Cale> ^^ this is our equivalent of a for-each loop. It's just a library function. :)
15:32:40 <Cale> Well, in this case, probably more sense to use forM_
15:32:51 <Cale> which is the version that doesn't collect the results of the actions in a list as it goes
15:33:18 <Stalafin> Cale: ok :D thanks for all the explanations :D
15:33:19 <Cale> (If you try that in ghci, you'll see a list  [(),(),(),(),(),(),(),(),(),()]  which is the result of the action)
15:33:38 <Stalafin> Cale: yeah, i think i saw smth along the lines explain in lyah
15:37:58 <sinelaw> is every continuous haskell type isomorphic to a subset of R?
15:38:09 <Cale> continuous?
15:38:21 * gwern pipes up, 'no, because of bottom!'
15:38:30 <sinelaw> semantically continuous
15:38:45 <Cale> I don't know what it means for a type to be continuous
15:38:47 * gwern has no idea what sinelaw is asking, but has observed that when anyone asked does X guarantee hold, the answer is always 'no, because of bottom'
15:38:56 <Cale> I know what it means for a function between types to be continuous
15:39:22 <Cale> Actually, bottom is the whole reason we care about this topological/order theoretical viewpoint
15:39:34 <sinelaw> gwern, you were right then.
15:39:36 <sinelaw> Cale, how so?
15:39:36 <Cale> Otherwise we wouldn't mention continuity at all :)
15:39:49 <Cale> sinelaw: Because continuous functions are the definable ones
15:40:31 <joe5> > fromEnum $ testBit (5::Word8) 0
15:40:33 <lambdabot>   1
15:40:35 <sinelaw> Cale, ok, what about uncountably infinite?
15:40:48 <joe5> I can get the above to work. but I cannot get the below to work
15:40:49 <sinelaw> Cale, not that i understood what you just said....
15:40:58 <CESSMASTER> Cale: oh yeah I asked you a while ago, are the resulting topological spaces hausdorff/whatever?
15:40:58 <Cale> There's an ordering placed on values of any Haskell type which is more or less that x <= y whenever y can be obtained from x by substituting occurrences of _|_ in x with other values.
15:40:58 <joe5> > (fromEnum . testBit) (5::Word8) 0
15:41:00 <lambdabot>   Couldn't match expected type `t1 -> t'
15:41:00 <lambdabot>         against inferred type `GHC.T...
15:41:12 <Cale> It's a directed complete partial order
15:41:34 <sinelaw> Cale, y is more defined than x?
15:41:40 <Cale> sinelaw: yes
15:41:57 <Cale> sinelaw: so _|_ is at the bottom of the ordering (which is why it uses that notation and name)
15:42:27 <Cale> CESSMASTER: hmm, I haven't really given much thought to their separation properties
15:43:37 <Cale> CESSMASTER: Also, it's important to note that they're only topological spaces in kind of a funny setting. You have to treat the "arbitrary" union thing with care.
15:43:59 <CESSMASTER> what does that mean
15:44:59 <CESSMASTER> you only get countable or finite unions or whatever?
15:45:11 <Cale> CESSMASTER: The function from indices to sets to be unioned has to be computable
15:45:33 <Cale> There are other ways to put that
15:46:07 <Cale> But basically you need some restriction to account for the fact that there are subsets of N which are not open, even though every point is.
15:46:30 <CESSMASTER> um what
15:46:37 <CESSMASTER> how is there a subset of N that is not open
15:46:58 <Cale> Open sets are the semidecidable ones, right?
15:47:11 <CESSMASTER> ohhhh
15:47:13 <CESSMASTER> with this topology
15:47:13 <CESSMASTER> yes
15:47:15 <Cale> yeah
15:47:29 <Cale> So it's not really traditional topology, but it's very close
15:47:49 <Cale> You're allowed to take any union for which you can compute the members
15:49:24 <CESSMASTER> so the idea is to end up using topological tricks to talk about computability?
15:49:35 <Cale> Actually, the way things are set up in Escardo's book, he defines continuous functions first, as being all the functions which are definable (in Haskell say), and then defines open sets, and the rest of the topological concepts in terms of that
15:49:38 <Cale> yeah
15:50:13 <roconnor> this doesn't sound like a topology to me.
15:50:24 <CESSMASTER> it's not but allegedly it's close
15:50:31 <roconnor> every {n} is decidable
15:50:32 <CESSMASTER> i'm confused as to how useful that could be
15:50:46 <roconnor> and hence induces a descrite topology.
15:51:01 <CESSMASTER> most powerful tools in topology seem to require very strong restrictions on your spaces
15:51:24 <CESSMASTER> and I can't imagine these almost-spaces as being very well behaved
15:59:28 * osfameron fails to write a 45-degree list-of-list transpose function :-(
16:00:37 <osfameron> I have an intuition it'd be an unfoldr
16:01:41 <joe5> > zipWith (\x y -> (fromEnum . testBit y) x) [0..7] (replicate 8 (5::Int))
16:01:43 <lambdabot>   [1,0,1,0,0,0,0,0]
16:01:55 <joe5> is there a shorter form of defining the above function?
16:03:05 <copumpkin> > mapM testBit [0..7] 5
16:03:06 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:03:07 <lambdabot>    `Data.Bits.Bits a'
16:03:07 <lambdabot>      ...
16:03:15 <copumpkin> > mapM testBit [0..7] (5 :: Int)
16:03:16 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:03:16 <lambdabot>    `Data.Bits.Bits a'
16:03:16 <lambdabot>      ...
16:03:32 <copumpkin> > mapM (flip testBit) [0..7] (5 :: Int)
16:03:34 <lambdabot>   [True,False,True,False,False,False,False,False]
16:03:54 <copumpkin> > mapM (fromEnum . flip testBit) [0..7] (5 :: Int)
16:03:55 <lambdabot>   Couldn't match expected type `m b'
16:03:55 <lambdabot>         against inferred type `GHC.Types...
16:04:15 <joe5> i get the idea, thanks.
16:04:37 <joe5> why mapM though? there is no monad there?
16:04:50 <joe5> > :t mapM
16:04:52 <lambdabot>   <no location info>: parse error on input `:'
16:04:56 <joe5> :t mapM
16:04:57 <koeien37> [] is a monad
16:04:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:05:08 <copumpkin> I'm using the function monad
16:05:14 <koeien37> oh, sure
16:05:23 <joe5> gotcha..
16:05:30 <joe5> thanks, guys.
16:05:37 <koeien37> the original version is clearer
16:05:51 <copumpkin> not really
16:05:53 <copumpkin> the zip should at least be a map
16:06:06 <copumpkin> and even if it's a zip, at least repeat instead of replicate
16:06:15 <koeien37> ok sure
16:06:39 <joe5> why do you like repeat? it provides an infinite list of elements?
16:06:46 <copumpkin> yep
16:06:54 <koeien37> you duplicate the fact that you want 8 elements
16:06:56 <copumpkin> why bother figuring out the right length when zip can do it for you
16:06:58 <joe5> i would assume that replicate is faster as it knows the exact number of elements to reproduce.
16:07:04 <koeien37> not at all
16:07:10 <copumpkin> nope, if anything it needs to keep more state
16:07:14 <joe5> oh, ok.. gotcha..
16:07:27 <copumpkin> repeat just makes a circular list with one element
16:07:56 <CalJohn> @src repeatM
16:07:56 <lambdabot> Source not found. You speak an infinite deal of nothing
16:08:07 <copumpkin> :t replicateM
16:08:08 <kmc> @src replicate
16:08:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
16:08:09 <lambdabot> replicate n x = take n (repeat x)
16:08:15 <kmc> replicate uses repeat
16:08:25 <copumpkin> yeah
16:08:32 <copumpkin> still needs to keep more state
16:08:32 <kmc> repeat doesn't really do any computation.  it just makes a circular list
16:08:35 <kmc> @src repeat
16:08:35 <lambdabot> repeat x = xs where xs = x : xs
16:08:44 <CalJohn> @let repeatM = sequence . replicate
16:08:45 <lambdabot>  <local>:17:21:
16:08:45 <lambdabot>      Couldn't match expected type `[m a]'
16:08:45 <lambdabot>             against...
16:14:10 <copumpkin> > iterate (zipWith (+) <$> ([0] ++) <*> (++ [0])) [1]
16:14:12 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
16:14:53 <mux> nice pascal's triangle
16:15:34 <anhe> huh. whoa
16:15:36 <copumpkin> doesn't look very triangular to me!
16:16:26 <mux> the PP work is left as an exercise for the reader
16:17:22 <copumpkin> > fix ((1:) . (>>= sequence [(+), (1/) . (+1)])) :: [Rational]
16:17:23 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t
16:17:31 <copumpkin> > fix ((1:) . (>>= sequence [(+1), (1/) . (+1)])) :: [Rational]
16:17:32 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
16:19:05 <mux> copumpkin: are you training for the haskell obfuscated code context?
16:19:15 <copumpkin> just playing with stuff
16:19:18 <mux> contest, rather
16:19:22 <copumpkin> :)
16:19:38 <CalJohn> @let repeatM x = liftM ((:) x) (repeatM x)
16:19:39 <lambdabot>  Defined.
16:19:47 <CalJohn> > repeatM (randomRIO (1,3))
16:19:48 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.IOBase.IO t]))
16:19:48 <lambdabot>    arising from a use...
16:19:51 <kmc> (>>=) sections are good fun
16:19:57 <copumpkin> :t bracket
16:19:59 <lambdabot> Not in scope: `bracket'
16:20:01 <CalJohn> > repeatM (return 3)
16:20:02 <lambdabot>   No instance for (GHC.Show.Show (m1 [m t]))
16:20:02 <lambdabot>    arising from a use of `M81864...
16:20:10 <copumpkin> :t Control.Exception.bracket
16:20:12 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:20:24 <copumpkin> @let nest = runCont . sequence . map Cont
16:20:26 <lambdabot>  Defined.
16:20:39 <joe5> is there a function that does this:  (5::Int):[]
16:20:43 <copumpkin> > (nest .) . Control.Exception.Bracket
16:20:44 <lambdabot>   Ambiguous occurrence `nest'
16:20:44 <lambdabot>  It could refer to either `L.nest', defined at ...
16:20:48 <joe5> I have hoogle'd repeat
16:20:50 <kmc> :t (:[])
16:20:51 <lambdabot> forall a. a -> [a]
16:20:51 <copumpkin> @undef
16:20:52 <CalJohn> joe5: return
16:21:02 <CalJohn> > return 5 :: [Int]
16:21:03 <copumpkin> or pure
16:21:03 <lambdabot>   [5]
16:21:04 <kmc> > (:[]) 5
16:21:05 <lambdabot>   [5]
16:21:07 <copumpkin> > (nest .) . Control.Exception.bracket
16:21:08 <lambdabot>   Not in scope: `Control.Exception.bracket'
16:21:24 <copumpkin> :t (nest .) . Control.Exception.bracket
16:21:26 <lambdabot>     Couldn't match expected type `Int'
16:21:26 <lambdabot>            against inferred type `(a -> IO c) -> IO c'
16:21:26 <lambdabot>     Probable cause: `Control.Exception.Base.bracket' is applied to too few arguments
16:21:28 <joe5> kmc: thanks
16:21:32 <joe5> caljohn: thanks
16:21:41 <copumpkin> :t nest
16:21:43 <lambdabot> Int -> Doc -> Doc
16:21:47 <copumpkin> blah
16:21:59 <copumpkin> @let multiCont = runCont . sequence . map Cont
16:22:00 <lambdabot>  Defined.
16:22:07 <copumpkin> :t (multiCont .) . Control.Exception.bracket
16:22:09 <lambdabot>     Couldn't match expected type `[(a -> r) -> r]'
16:22:09 <lambdabot>            against inferred type `(a1 -> IO c) -> IO c'
16:22:09 <lambdabot>     Probable cause: `Control.Exception.Base.bracket' is applied to too few arguments
16:22:15 <copumpkin> oh duh
16:22:24 * copumpkin stops messing around
16:22:51 <CalJohn>  /> repeatM (randomRIO (1,3)) <- on my machine this blocks until the stack overflows.  Shouldn't it be a lazy list of random numbers?
16:23:07 <copumpkin> nope
16:23:19 <CalJohn> why am i confused then?
16:23:27 <uorygl> Does Haskell have a mascot?
16:23:40 <copumpkin> uorygl: a narwhal!
16:23:55 <kmc> noooo
16:24:20 <CalJohn> oh, hold on, i am making more than one mistake
16:25:29 <copumpkin> :t mfix
16:25:31 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
16:26:28 <iago> Someone would suggests to me what is the simplest library to generate XML?
16:26:48 <iago> please
16:27:06 <mauke> putStr "<xml></xml>"
16:27:57 <iago> oh, there is no a simpler one?
16:28:03 <koeien37> there is
16:28:09 <uorygl> Eh, it has a logo: "a right angle bracket kerned with a lowercase lambda partially obscuring an equals sign". I can fashion that into a frown, should the need come up.
16:28:25 <koeien37> maybe HaXml, I don't know
16:28:42 <copumpkin> uorygl: good to know
16:29:03 <uorygl> ...Did I just make *another* plan for a hypothetical situation that's unlikely to come up?
16:29:22 <iago> well, I will try with HaXml, I ask because I see many others, maybe there was someone with experience here
16:29:36 <uorygl> That's the second time this... this nothing, because this is the first Sunday of the year.
16:29:43 <koeien37> I've used only HaXml
16:29:48 <koeien37> don't know if it's the easiest one
16:31:30 <joe5> > (\x -> [(0,x),(1,x),(2,x),(3,x),(4,x),(5,x),(6,x),(7,x)]) (4::Int)
16:31:31 <lambdabot>   [(0,4),(1,4),(2,4),(3,4),(4,4),(5,4),(6,4),(7,4)]
16:31:33 <joe5> > zip [0..7] $ repeat 4
16:31:34 <lambdabot>   [(0,4),(1,4),(2,4),(3,4),(4,4),(5,4),(6,4),(7,4)]
16:31:42 <joe5> is there a smarter way of doing the above?
16:31:58 <koeien37> map (,4) [0..7] , {-# LANGUAGE TupleSections #-}
16:32:00 <joe5> I think it is redundant to be using both repeat and [0..7]
16:32:22 <Zeiris> Between Data.PriorityQueue, Data.PurePriorityQueue, Data.FingerTree.PSQueue, and Data.PSQueue, is there any clear winner for which one's "best"?
16:32:29 <uorygl> > map (,4) [0..4]
16:32:30 <lambdabot>   <no location info>: parse error on input `4'
16:32:35 <copumpkin> what koeien37  said, as of 6.12
16:32:46 <uorygl> > map (flip (,) 4) [0..7]
16:32:47 <lambdabot>   [(0,4),(1,4),(2,4),(3,4),(4,4),(5,4),(6,4),(7,4)]
16:33:05 <joe5> cool, thanks.
16:34:22 * uorygl suddenly gets a vestige of the feeling that the following would be a useful feature: "let [0,1,2,3,4,5,6,7] = [0..7] in [(0,x),(1,x),(2,x),(3,x),(4,x),(5,x),(6,x),(7,x)]"
16:35:02 <koeien37> you can use that now, if x is in scope
16:35:13 <koeien37> not particularly useful though
16:35:20 <heatsink> You wish to define the numbers 0 through 7 to be themselves?
16:35:36 <joe5> uorygl: i cannot use map as the 4 is an argument to the function..
16:36:09 <opdolio> > (\n -> [0..n]) 5
16:36:11 <lambdabot>   [0,1,2,3,4,5]
16:36:18 <joe5> something like "perform something with an argument 0 thru 8 on an argument"
16:36:35 <copumpkin> joe5: sure you can
16:36:48 <joe5> something like "perform something using values 0 thru 8 and an argument"
16:36:50 <copumpkin> > mapM (,) [0..4] 5
16:36:51 <lambdabot>   [(0,5),(1,5),(2,5),(3,5),(4,5)]
16:37:10 <uorygl> heatsink: yeah! Then if I make a mistake, and the compiler is also intelligent, it will say, "Hey, you made a mistake."
16:37:12 <joe5> copumpkin, thanks
16:37:29 <DerisionSnort> @pl take 1
16:37:30 <lambdabot> take 1
16:37:36 <uorygl> @type mapM
16:37:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:38:02 * copumpkin is in a mapM mood tonight
16:38:23 <opdolio> That was a nice one.
16:38:47 <joe5> copumpkin: i am getting a no instance for monad. I tried importing control.monad, without effect..
16:38:55 <copumpkin> :m + Control.Monad.Instances
16:39:04 <joe5> ok, thanks.
16:39:10 <copumpkin> :)
16:39:43 <uorygl> > log (product [1..8]) / log 2
16:39:43 <lambdabot>   15.29920801838728
16:39:58 <koeien37> > logBase 2 (product [1..8])
16:39:59 <lambdabot>   15.29920801838728
16:40:10 <uorygl> That's not the traditional way of doing logs. :-(
16:41:04 <uorygl> So, English text has an entropy of about one bit per character, and an English word, including the space before it, has about six characters. Therefore, it should be possible to type two and a half words by mashing eight keys at once.
16:41:09 * uorygl is a genius!
16:41:27 <osfameron> @src transpose
16:41:28 <lambdabot> transpose []             = []
16:41:28 <lambdabot> transpose ([]   : xss)   = transpose xss
16:41:28 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
16:42:05 <uorygl> Alas, it's probably impossible to mash eight keys at once in a specific order.
16:42:39 <copumpkin> alack!
16:43:42 <uman> CESSMASTER: Didn't know you were interested in Haskell
16:44:28 <CESSMASTER> i'm not but i'm interested in pestering people about logic and cs once in a while
16:44:33 <CESSMASTER> and that sure isn't gonna happen in #math
16:45:01 <uman> CESSMASTER: You should try ##c++, I accidentally set off a two hour argument over whether O(n) means the same thing as O(2n)
16:45:22 <copumpkin> lol
16:45:26 <heatsink> uorygl: Or we could all learn ithkuil and then convey the same meaning in vastly shorter phrases.
16:45:28 <skorpan> does it?
16:45:51 <CESSMASTER> uman: that's the kind of channel I don't want to put up with
16:45:52 <uman> skorpan: if I told you, someone would start arguing with me.
16:46:03 <skorpan> uman: naturally, everyone knows it doesn't mean the same thing...
16:46:07 <skorpan> ...right?
16:46:09 <skorpan> ;-)
16:46:26 <CESSMASTER> at least haskell users once in a while know their definitions
16:47:02 <uman> got a guy in there claiming all the "very experienced C++ programmers at his work" say things like "this function is O(142.3log(n))" all the time
16:47:15 <skorpan> haha
16:48:05 <uorygl> heatsink: English translations of Ithkuil example sentences tend to be... well, here's one:
16:48:19 <uorygl> "On the contrary, I think it may turn out that this rugged mountain range trails off at some point."
16:48:38 <uorygl> He could just say "It might trail off."
16:50:54 <uorygl> And ponder how often those things contain various ways of saying "set of".
16:51:07 <uman> skorpan: also got a guy claiming of two different algorithms "Well, their asymptotic behavior may be the same, but their big-O is different" :(
16:51:10 <copumpkin> O(142.3log(n)) is excellent
16:51:33 <uman> skorpan: (asymptotic as n->infty, that is)
16:52:07 <uman> copumpkin: makes you wonder why they need the O at all
16:52:56 <CESSMASTER> because these people operate on a purely syntactic level
16:53:04 <kmc> people also get excited by the difference between O(log n) and O(1), even if n is 7
16:53:34 <CESSMASTER> oh dear
16:53:38 <lament> i hated having to prove O bounds in my CS course
16:53:55 <lament> we had to do it the specific way with finding witnesses, and couldn't use limits like all normal people
16:54:11 <uman> lament: what is a witness?
16:54:20 <uman> (in this context)
16:54:28 <lament> something in the definition of big O
16:54:40 <uman> the definition of big-O is pretty simple
16:54:41 <theorbtwo> If you can show me a new algorithm that you make my program run 142.3 times faster, I'll be excited, even if it technically has the same O() as the old one.
16:54:46 <lament> one function times coefficient plus another coefficient
16:55:00 <lament> you need to find values for those coefficients such that the inequality holds
16:55:21 <lament> and we were required to actually do that
16:55:27 <uman> lament: doesn't make sense for someone to tell you "you have to prove something this way". A proof is a proof I would think
16:55:34 <sinelaw_> conal, btw, do you have an example of a system that requires polymorphism? i though of the graph-editing gui as an example of "use events and behaviors to transform abstract data structures" example
16:55:44 <copumpkin> theorbtwo: you are hereby expelled from the guilt of computer scientists
16:55:47 <lament> uman: yeah but it's CS, what do you expect :)
16:55:49 <theorbtwo> I don't run my programs with infinite sized input; the behavior as the input size approaches infinity isn't actually terribly relevant.
16:55:56 <uman> theorbtwo: uhh it doesn't have the same O(). One is O(142.3logn) and one is O(logn) are you a fucking idiot
16:56:03 <sinelaw_> conal, in contrast to controlling robots and such, which is a solved problem in systems semantics
16:56:22 <troutwine> lament: I would expect that a proof is a proof.
16:56:23 <conal> sinelaw_: hm.  by "polymorphism", do you just mean a variety of types involved in the description?
16:56:54 <sinelaw_> conal, at least that, it's more than R^m->R^n
16:57:36 <sinelaw_> conal, but i can't think of one that really motivates *any* type
16:57:43 <sinelaw_> except that it's more reusable etc.. to write code that way
16:57:43 <Saizan_> troutwine: sure, 142 speedup is nice to have, just use something else to express the complexity of your function.
16:57:52 <sinelaw_> more general, all the good stuff
16:57:59 <copumpkin> that proof sounds irrelevant :P
16:58:06 <theorbtwo> If I taught, I think I'd make my students compute the crossover point occasionally -- at what size input does your O(log n) algo actually beat the O(n) algo?
16:58:08 <uman> another guy startied talking about how central to his work is a function that is, ahem, O(floor(n/143))
16:58:32 <uman> err s/that is/that is the implementation of an algorithm that is/
16:58:36 <conal> sinelaw_: any type other than R^m->R^n, you mean?
16:58:48 <theorbtwo> You should never get so engrossed in computer science that you forget how to do computer engeneering, or vice-versa.
16:58:51 <troutwine> Saizan_: I think, perhaps, your comment was directed at another person?
16:59:08 <Saizan_> troutwine: oh, yeah, sorry, it was for theorbtwo
16:59:08 <copumpkin> theorbtwo: you're assuming that one exists to facilitate the other
16:59:36 <troutwine> Saizan_: Ah, good. I was quite confused.
16:59:44 <theorbtwo> copumpkin: I think I'd describe them as symboitic.
16:59:53 <sinelaw_> conal, any type at all, yes
17:00:41 <sinelaw_> conal, or any other example that demonstrates why a certain property is desired in the denotational semantics
17:00:55 <conal> sinelaw_: sry, i'm still confused.  you use vectors in these descriptions, right?  R and R^m are types, aren't they?  (puzzled about "any type at all")
17:01:58 <conal> sinelaw_: are you thinking of any particular properties of semantics?
17:02:40 <sinelaw_> conal, i am.........
17:02:57 * sinelaw_ 's mind trails off into a dreamy world of associations
17:03:02 <sinelaw_> good night :)
17:11:24 <mreh> these X11 bindings, is that to the C libraries?
17:12:03 <Saizan_> yes
17:12:04 <joe5> i am trying to find more functions with functionality as zipWith. wondering where I can look...
17:12:05 <mreh> found them
17:12:22 <mreh> they are cryptically called libx11-dev with ubuntu
17:12:44 <DerisionSnort> @pl reverse . sort
17:12:44 <lambdabot> reverse . sort
17:12:55 <gwern> sweet. I added an emacs --daemon to my xmonad startup, updated my aliases, and rebound C-x C-c to close the server if it's open or kill emacs otherwise; now I can just type 'e file' for instant emacs, and C-x C-c like normal without bothering with C-x #
17:12:56 <Absolute0> Is there a version of takeWhile that takes a function with 2 arguments instead (\i j -> foo) ? where i is the previous element and j is the current one.
17:13:26 <Absolute0> i am thinking of using scanl instead
17:13:34 <mreh> Absolute0: use a sneaky trick, like zip
17:13:48 <Absolute0> oh
17:13:53 <Absolute0> zip list with list+1
17:13:56 <Absolute0> nice
17:14:13 <Absolute0> actually list-1 with list
17:14:13 <gwern> Absolute0: why not write a function to convert [a] into [(a,a)] and then map it? or does each element need to be fst and then snd?
17:14:38 <mreh> > (\xs -> zip xs (tail xs)) [1..]
17:14:39 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
17:15:00 <Paczesiowa> what's the status of mtl? which version should be used?
17:15:32 <DerisionSnort> @pl (==) `on` snd
17:15:33 <lambdabot> (==) `on` snd
17:15:34 <mreh> Absolute0, what do you want to do?
17:16:17 <joe5> copumpkin: I cannot get mapM to work with 2 functions. such as:  mapM (fromEnum $ flip testBit) [0..7] (5::Int)
17:16:25 <joe5> :t fromEnum $ flip testBit 0 (5::Int)
17:16:26 <lambdabot> Int
17:16:32 <joe5> :t mapM (fromEnum $ flip testBit) [0..7] (5::Int)
17:16:34 <lambdabot>     Couldn't match expected type `a -> m b' against inferred type `Int'
17:16:34 <lambdabot>     In the first argument of `mapM', namely `(fromEnum $ flip testBit)'
17:16:34 <lambdabot>     In the expression:
17:16:52 <joe5>  fromEnum $ flip testBit 0 (5::Int)
17:17:00 <joe5> > fromEnum $ flip testBit 0 (5::Int)
17:17:02 <lambdabot>   1
17:17:04 <Absolute0> mreh: takeWhile (\i j -> boolFunc i j) $ iterate foo i, where i is the previous element and j is the current
17:17:34 <mreh> :t iterate
17:17:35 <lambdabot> forall a. (a -> a) -> a -> [a]
17:17:36 <Absolute0> mreh that lambda isnt necessary :)
17:17:48 <joe5> copumpkin: any suggestions, please? i could get the whole thing working using zipwith but am trying to expand my knowledge by using mapM
17:18:19 <joe5> > zipWith (\x y -> (fromEnum . testBit y) x) [0..7] $ repeat (5::Int)
17:18:20 <heatsink> :t testBit
17:18:21 <lambdabot>   [1,0,1,0,0,0,0,0]
17:18:21 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
17:18:31 <mreh> Absolute0, give me a high level definition of the problem
17:18:38 <mreh> i.e. in English
17:18:49 <mreh> i'm still not sure what it is you want to do
17:18:57 <Absolute0> mreh: iterate moves of a chesspiece
17:18:58 * heatsink doesn't see a monadic computation in this task
17:19:08 <DerisionSnort> @pl \(a, b) -> a * b
17:19:09 <lambdabot> uncurry (*)
17:19:11 <Absolute0> iterate would take the increments
17:19:32 <joe5> heatsink: i do not understand.
17:19:50 <Absolute0> ie: horizontal: (+1) (-1), diagnol: (+7) (+9) (-7) (-9)
17:20:02 <Absolute0> and then i need to check if the next increment is valid
17:20:04 <joe5> heatsink: do you mean to say that I cannot use mapM on fromEnum and testBit together?
17:20:16 <Absolute0> for diagnal it has to be one rank/file apart
17:20:24 <Absolute0> etc.
17:21:19 <heatsink> joe5: mapM is for applying a monadic computation to each element of a list.  What functions are you using that have monads in their types?
17:21:34 <heatsink> joe5: If you want to map an ordinary function over each element of a list, use map.
17:22:35 <joe5> ok, it appears that testBit is not fast. It actually made my program time worse (though not by much)
17:23:10 <joe5> it is faster to just do the integer to binary conversion rather than use testBit.?
17:23:38 <Lemmih> joe5: You most likely used it wrong.
17:23:50 <Absolute0> >testBit 0 0x1
17:24:02 <joe5> with testBit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15561#a15561
17:24:05 <heatsink> > testBit 0 0x1
17:24:06 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:24:06 <lambdabot>    `Data.Bits.Bits t'
17:24:06 <lambdabot>      a...
17:24:16 <heatsink> > testBit 0 (0x1 :: Word32)
17:24:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:24:18 <lambdabot>         against inferred type ...
17:24:20 <joe5> without testBit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15555#a15555
17:24:31 <Absolute0> :t testBit
17:24:32 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
17:24:44 <joe5> I have put the profiling information of both programs at  the above links..
17:24:59 <Absolute0> > testBit 0x1::Word64 0
17:25:00 <lambdabot>   Only unit numeric type pattern is valid
17:25:17 <Absolute0> > testBit (0x1::Word64) 0
17:25:18 <lambdabot>   True
17:25:35 <Absolute0> @src testBit
17:25:36 <lambdabot> Source not found. You untyped fool!
17:26:24 <joe5> sorry, I take that back.
17:26:30 <tensorpudding> @src Data.Bits.testBit
17:26:31 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:26:41 <joe5> Lemmih: sorry, I think testBit was a bit faster.
17:26:59 <tensorpudding> testBit uses bit shifts, it's probably not very slow
17:27:16 <joe5> with testBit: 159 secs and without testBit: 177 secs
17:28:05 <heatsink> joe5: zipWith f xs (repeat y) === map (flip f) xs
17:28:30 <Absolute0> I am using log and / to test which bits are on, is that better than testBit each digit?
17:28:47 <Absolute0> I think my way is fastest
17:29:05 <Absolute0> calling testBit each time would run O(n) every time
17:29:09 <Absolute0> even when not needed
17:29:31 <joe5> Absolute0: can you show me what you are doing.
17:30:00 <joe5> heatsink: I am still trying to comprehend what you have written.
17:30:13 <Lemmih> joe5: Why do you want a list of bits?
17:30:57 <joe5> it is just a electronic signal that I am sampling
17:30:59 <heatsink> joe5: You can rewrite "zipWith (\x y -> f x y) [0 .. 7] $ repeat a" as "map (\x -> f a x) [0 .. 7]"
17:31:36 <joe5> heatsink: yes, you are correct.
17:31:54 <joe5> heatsink: cannot believe i did not think of that.
17:31:59 <joe5> heatsink: thanks.
17:32:39 <Saizan_> @pl \a -> map (\x -> f a x) [0 .. 7]
17:32:40 <lambdabot> flip map [0..7] . f
17:32:59 <Saizan_> = map
17:33:15 <Saizan_> = mapM (flip f) [0..7] -- for fun
17:33:26 <mreh> how do you pronounce (***)
17:33:47 <mreh> my brain says "weeeuuurp"
17:34:03 <opdolio> Times.
17:34:07 <heatsink> mreh: My brain says it shouldn't be pronounced in polite company.
17:34:14 <Absolute0> joe5: can't find the code right now but it goes like this: let x  = logBase 2 n, f (n-2^x)
17:34:30 <Lemmih> joe5: You're not gonna get accurate performance data using that representation.
17:34:51 <Absolute0> joe5: each iteration adds the next index to the list
17:36:14 <joe5> Lemmih: what are you referring to?
17:36:28 <joe5> Absolute0: let me try to understand it.
17:37:13 <mreh> so how does one "run" and arrow
17:37:19 <mreh> s/and/an
17:38:04 <mreh> @hoogle Arrow a => a b c -> b -> c
17:38:05 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
17:38:05 <lambdabot> Control.Monad.State.Lazy evalState :: State s a -> s -> a
17:38:05 <lambdabot> Control.Monad.State.Strict evalState :: State s a -> s -> a
17:40:11 <Absolute0> joe: let f  n = let log = logBase 2 n in log:f (n-2^log)
17:40:26 <Absolute0> maybe thats clearer
17:41:11 <Absolute0> of course theres also a base case not to go below 0
17:41:16 <Lemmih> joe5: Your program is likely to spend most of its time creating intermediary lists. If you're testing how fast you can process data, you're doing it wrong.
17:42:31 <joe5> Lemmih: any recommendations on what I should be doing.
17:42:40 <joe5> Absolute0: thanks.
17:42:44 <joe5> it helpse.
17:42:46 <joe5> it helps.
17:42:59 <Lemmih> joe5: What are you trying to achieve?
17:43:23 <Lemmih> joe5: I doubt printing a long list of ones and zeroes is your goal.
17:43:36 <lament> unless you're a HACKER
17:43:36 <joe5> Lemmih: i am just trying to get the program faster so that I can run it in ghci.
17:43:59 <Lemmih> joe5: Comment out code. Then it will run fast.
17:44:00 <joe5> lemmih: i am trying to analyse the signal from the command prompt.
17:44:36 <joe5> lemmih: and then write a quick parser to convert the signal into readable data.
17:45:13 <Lemmih> joe5: Ok, first step is to not split the data into bits.
17:45:27 <Lemmih> joe5: Let 'getdata' return a ByteString.
17:48:32 <Lemmih> joe5: Once you do, your program should take less than a second to run.
17:50:25 <joe5> lemmih: but i need to comprehend the signal and that is why I am putting out zero's and one's now.
17:51:05 <Lemmih> joe5: You don't need a list of bits to comprehend the signal.
17:51:13 <joe5> lemmih: the run time is ok for now. I cannot run it from ghci, no biggie.. I am outputting a file that I will analyse through vim / sed.
17:53:33 <Lemmih> joe5: You really want to convert 11megs of data to a list of ones and zeroes?
17:54:00 <Lemmih> And that's all you want to do?
17:54:19 * Lemmih is baffled.
17:55:07 <joe5> lemmih: for now, the device is not working and I am trying to see what is off.. when I am satisfied that the signal seems ok from eyeballing, I plan to translate the signal into meaningful data.
17:55:53 <joe5> lemmih: i am also trying to learn haskell so what I am trying to do is also expand  my haskell knowledge...
17:55:56 <joe5> too..
18:01:07 <Lemmih> joe5: Well, ok. If converting to binary is what you want, here's how to do it: Use an array from Word8s to strict ByteStrings.
18:02:35 <Lemmih> joe5: Also, use Data.Word instead of GHC.Word.
18:04:31 <joe5> lemmih: will try. thanks for your help.
18:07:36 <gwern> https://secure.wikimedia.org/wikipedia/en/w/index.php?title=User:Gwern/Permutations.hs&curid=10451533&diff=335684087&oldid=270799246 o.0
18:07:45 <gwern> strangers seem to really care about making my code clean
18:10:15 <Axman6> gwern: and why not?
18:11:25 <Lemmih> A stranger is just a Haskell hacker you haven't met yet?
18:13:04 <gwern> just unusual, is all
18:17:57 <Pseudonym> True Haskell hackers can't stand unclean code. Unless it's deliberate, of course.
18:18:22 <Pseudonym> I've received many patches from stranges, but not for my IOHCC entry.
18:18:33 <dark> hahahahahahaha
18:18:42 <dark> there is a iohcc
18:18:46 <Pseudonym> Was once.
18:18:49 <Pseudonym> Twice, maybe.
18:18:59 <dark> i don't imagine how would be the entries
18:19:07 <Pseudonym> I got a "worst abuse of the rules" award!
18:19:14 <dark> ahahahahahah!!!!
18:19:20 <Pseudonym> There wasn't a rule which said that judges couldn't enter.
18:19:41 <dark> ahhhhhhh lol :)
18:19:55 <dark> someone should do it again
18:20:04 <dark> it's nice for educational purposes
18:20:19 <Pseudonym> shapr usually does the organising, but I'm sure if someone else wanted to step up to the virtual plate...
18:20:26 <Axman6> hmm, is using SKI easy in haskell?
18:20:33 <heatsink> To keep your house safe from Haskell programmers, hang ten pages of perl code hanging above your door.  They will be compelled to stop and spend all night rewriting the code.
18:21:00 <dark> hahahaha
18:21:09 <Pseudonym> Especially do that with the evil mangler.  It needs a rewrite.
18:21:15 <Axman6> heatsink: or ask your local university's first year haskell assignments, for even more time to get away
18:21:45 <Pseudonym> Olegs can be warded off by adding a note claiming that it's impossible to implement in the type system.
18:22:02 <Pseudonym> For at least a week.
18:22:09 <dark> ps: the haskell community is still interacting with perl 6? (i heard something like that)
18:22:14 <Axman6> Pseudonym: ha
18:22:27 <Pseudonym> dark, I think it was just Audrey.
18:22:38 * Pseudonym might be wrong about that
18:22:48 <Axman6> @remember Pseudonym Olegs can be warded off by adding a note claiming that it's impossible to implement in the type system.
18:22:49 <lambdabot> Good to know.
18:23:04 <dark> it seemed that haskell hackers elected perl 6 as the scripting language of choice
18:23:11 <dark> or something like that
18:23:27 <Axman6> dark: not from what i've hears. but the first working implementation of perl 6 was written in haskell
18:23:31 <Axman6> heard*
18:23:40 * hackagebot upload: hricket 0.2 - A Cricket scoring application. (AnthonySimpson)
18:24:01 <Pseudonym> Axman, that only makes sense in context with heatsink's joke.
18:24:10 <Axman6> not really
18:24:12 <colton_> Anyone here ever used qt haskell?
18:24:12 <bob0> colton_: no
18:24:14 <Axman6> it still works
18:24:28 <Pseudonym> According to lambdabot's quotes, all I ever do is make Oleg jokes.
18:24:31 <colton_> ?
18:24:51 <Axman6> @quote Pseudonym
18:24:52 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
18:24:58 <Pseudonym> See?
18:25:01 <Axman6> @quote Pseudonym
18:25:01 <lambdabot> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
18:25:09 <Axman6> @quote Pseudonym
18:25:10 <lambdabot> Pseudonym says: You want to do protein folding, and you don't even know what source control is?
18:25:19 <Axman6> @quote Pseudonym
18:25:19 <lambdabot> Pseudonym says: Olegs can be warded off by adding a note claiming that it's impossible to implement in the type system.
18:25:27 <Axman6> 3/4, not bad :P
18:25:31 <Pseudonym> :-)
18:25:32 <heatsink> Well, it doesn't seem out of place.
18:26:07 <dark> what is oleg?
18:26:15 <dmhouse> ?where oleg
18:26:16 <lambdabot> http://okmij.org/ftp/
18:26:37 <dolio> It's a dependently typed language detailed in Conor McBride's thesis.
18:27:05 <Pseudonym> "Oleg" is a unit of type hackery, named after Haskell type hackery's most notable practitioner.
18:27:36 <elly> the more useful unit is the microoleg
18:28:56 <mental> ...
18:32:01 <joe5> is there a function like splitAt but returns [[a],[b]] instead of what split does ([a],[b])
18:32:29 <joe5> i could transform the splitAt result but am wondering if there is anything that does it already.
18:32:50 <Axman6> [([a],[b])] perhaps?
18:33:18 <Axman6> [[a],[b]] doesn't make any sense
18:33:28 <blackdog> Axman6: it does in that context
18:33:41 <blackdog> although techincally it's [[a],[a]]
18:33:55 <joe5> blackdog: yes that is what I looking for.
18:34:00 <blackdog> (happy new year, btw. didn't make it as far as canberra, sorry mate)
18:34:06 <Axman6> ah, in that case, then sure
18:34:12 <mm_freak> splitAt doesn't return ([a],[b]) anyway
18:34:19 <mm_freak> it returns ([a], [a])
18:34:38 <joe5> mm_freak: yes you are correct.
18:34:46 <joe5> i am looking for [[a],[a]]
18:35:06 <joe5> breaking a list into two lists  based on the position
18:35:29 <blackdog> joe5: don't think there's a standard version
18:35:37 <mm_freak> probably easiest by pattern matching
18:35:39 <joe5> blackdog: thanks.
18:35:40 <mm_freak> there is nothing predefined
18:35:50 <blackdog> when you know how many elements something has, it's idiomatic to use a tuple
18:36:02 <joe5> thanks guys, I can whip up something with lambda but just wanted to make sure.
18:36:20 <troutwine> joe5: Why do you want a list, rather than a tuple?
18:36:59 <mm_freak> troutwine: i found myself preferring lists over tuples, too
18:37:06 <mm_freak> they are much easier to process
18:37:26 <joe5> i am trying to  [1,2,3,4,5] => [1,2,3,"\n",4,5]
18:37:41 <blackdog> joe5: the types are wrong there
18:38:05 <mm_freak> > let (xs,ys) = splitAt 2 [1..10] in [xs,ys]
18:38:07 <lambdabot>   [[1,2],[3,4,5,6,7,8,9,10]]
18:38:32 <joe5> blackdog: got me there..
18:39:04 <joe5> mm_freak: that is smart..
18:39:28 <mm_freak> joe5: that's about the most straightforward way i could think of
18:39:35 <joe5> mm_freak: sorry but I cannot understand it though..
18:39:43 <mm_freak> it's pattern matching
18:39:43 <joe5> mm_freak: give me a few more mins.
18:39:56 <mm_freak> one of haskell's main strengths
18:39:59 <imperialenforcer> yeah that seems pretty straight forward and the easiest way to do it
18:40:03 <mm_freak> you should get used to it =)
18:42:03 <mm_freak> > (\(xs,ys) -> [xs,ys]) . splitAt 2 $ [1..10]
18:42:04 <lambdabot>   [[1,2],[3,4,5,6,7,8,9,10]]
18:42:15 <mm_freak> but i find the let version much better
18:42:29 <roostaj> @src sum
18:42:30 <lambdabot> sum = foldl (+) 0
18:42:40 <roostaj> @src foldl
18:42:40 <lambdabot> foldl f z []     = z
18:42:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:43:31 <joe5> mm_freak: I can understand this.
18:44:19 <roostaj> @src scanl
18:44:20 <lambdabot> scanl f q ls = q : case ls of
18:44:20 <lambdabot>     []   -> []
18:44:20 <lambdabot>     x:xs -> scanl f (f q x) xs
18:46:37 <mgsloan> hmm, has anyone ever made a bits instance for UArray?
18:46:53 <Axman6> o.O
18:47:25 <mm_freak> mgsloan: what for?
18:47:33 <mm_freak> there is UArray with Bool
18:47:39 <Axman6> seems you might be able to make an instance for Bits a => UArray b a fairly easily
18:48:11 <mgsloan> Axman - exactly
18:48:48 <mm_freak> mgsloan: don't think in C
18:49:00 <mm_freak> there is UArray Int Bool, which is a bitfield
18:49:42 <mgsloan> I'm trying to extend the features of Data.BloomFilter, which utilizes UArray / STUArray
18:50:22 <Axman6> why not just use the UArray Int Bool?
18:50:40 <mgsloan> UArray Int Word32, specifically.  But yeah, I would write an instance for (Bits a) => UArray Int a
18:50:41 <mm_freak> does the library expect UArray Int SomethingOtherThanBool?
18:50:53 <mgsloan> well for the library this is an implementation detail
18:51:09 <mgsloan> it isn't exposed, and i assume word32 was chosen for efficiency
18:51:36 <mm_freak> you need to address bits using a field-global address?
18:53:05 <cads> what kind of techniques and papers could research to help someone who was in mind the embedding of the ruby syntax as a domain language in haslkell?
18:53:15 <cads> this dude is nutso
18:53:54 <mgsloan> mm_freak: not sure what you mean by that, but anyway, I'm just going to write a patch for Data.BloomFilter
18:54:07 <cads> he's all about dissecting ruby down to its giblets, and then helping me make a haskell equivalent
18:54:28 <blackdog> cads: who's doing that?
18:54:40 <mm_freak> mgsloan: i mean what do you want your Bits instance to do?  Word32 is a Bits instance
18:55:08 <cads> a toking buddy from school
18:55:21 <cads> we;re slacking off for now
18:55:36 <cads> but I am the haskellite, and he is the javadrone
18:55:53 <cads> errm ruby*
18:56:07 <Saizan_> mh, the experience report about Paradise should be a nice start, augutss' blog too
18:57:31 <mgsloan> mm_freak: my bits instance would basically perform zips of the appropriate bitwise ops down two arrays
18:57:32 <heatsink> Can I print non-ASCII characters as utf8 with putStrLn?
18:57:43 <mgsloan> I'm not sure what the proper behavior should be for different size arrays
18:57:48 <cads> I am going to have to learn a bit parser and compiling , and doubtlessly evoke holy higher order thinking
18:57:54 <mgsloan> either error out, or assume zeros
18:58:14 <mm_freak> mgsloan: that's my pointâ¦  i don't understand what your instance should do at all
18:58:26 <mm_freak> for most things you have amap at al
18:58:27 <mm_freak> et al
18:58:28 <cads> but do you guys think that embedding ruby in haskell would be a positive or negative thing?
18:58:41 <cads> or a too hard thing that will never be done :P
18:58:41 <Axman6> cads: ask blackdog
18:58:46 <Pseudonym> It would be morally neutral, but you'd learn a lot if you tried.
18:58:54 <Axman6> he's already working on a ruby/haskell binding
18:59:36 <mgsloan> mm_freak: I'd probably implement an arrzip :: (Ix i) => (v -> v -> v) -> UArray i v -> UArray i v ->UArray i v
19:00:14 <heatsink> cads: What would make it better than programming in Ruby or Haskell?
19:00:20 <mgsloan> actually probably for IArray
19:00:44 <Pseudonym> heatsink: The whole cannot be less than the sum of its parts.
19:01:41 <Saizan_> it might even become the fastest ruby implementation :)
19:01:44 <mm_freak> mgsloan: what should it do?  intersperse the second array's elements between the elements of the first?
19:02:11 <mgsloan> :t zipWith
19:02:12 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
19:02:30 <mm_freak> oh, sorry
19:02:31 <mm_freak> sure
19:02:32 <mgsloan> yeah, even better, the types would be a b c
19:02:40 <mgsloan> rather than all v
19:02:51 <heatsink> Pseudonym: Complexity is a liability.  Perhaps some benefits outweigh it.
19:03:00 <cads> I feel like it would be a great framework to understand the subtleties of the ruby language at a deeper level
19:03:00 <matsuura> it's so nice being able to understand what's going on now :)
19:03:21 <heatsink> matsuura: Did you figure out the OpenGL thing?
19:03:27 <matsuura> heatsink: nope
19:03:31 <mm_freak> mgsloan: how is that related to the Bits thing?
19:03:58 <cads> you guys might say ruby is bloated and cluttered and doesn't have any particualrly divine notions and it;s slooooooo
19:04:01 <dolio> Ruby has all kinds of stuff that probably can't be feasibly replicated in Haskell.
19:04:14 <dolio> As an EDSL, that is.
19:04:53 <mgsloan> mm_freak: (.&.) == arrzip (.&.)
19:05:13 <cads> it would be wierd so see a block of hask  with ruby code sandwidtched here and there
19:05:52 <mm_freak> mgsloan: yeah, then arrzip is a great idea
19:05:55 <cads> and to the answer of what would be the piont - socially, I think it would pring a lot more curious programmers to haskell
19:06:34 <cads> the ruby comunity is pretty laid back and wise
19:06:43 <esdegan> Just double checking: parsec 2 doesn't support bytestring, does it? I should install parsec 3, right?
19:06:57 <dolio> Yes, you should install parsec 3.
19:07:03 <esdegan> thanks
19:07:41 * Axman6 really likes cereal for bytestring parsing
19:08:05 <dolio> New parsing library?
19:08:29 <Axman6> lacks some of the parsec combinators, but i'm at some stage going to write a library to make a more parsec like interface to cereal
19:08:42 <dolio> Ah, serializing.
19:08:43 <Axman6> dolio: not really, a nicer version of binary
19:08:54 <Axman6> but it has the all important Alternative instance
19:09:43 <dolio> So the Get does backtracking of some sort?
19:09:51 <Axman6> yeah
19:10:33 <dolio> What sort?
19:10:48 <dolio> Is it just naive backtracking?
19:11:14 <Axman6> so, you can write things like: many p = many1 p <|> return []; many1 p = (:) <$> p <*> many p
19:11:28 <Axman6> no idea, i haven't looked into it
19:16:23 <troutwine> Anyone familiar with Data.MemoCombinators? I'm failing to memoize a ([a] -> [b] -> r) function over [a] and [b].
19:18:23 <mgsloan> mm_freak: yeah, I think it's alright. here's a definition:
19:18:23 <mgsloan> zipArray :: (Ix i, IArray u a, IArray v b) => (a -> b -> a) -> u i a -> v i b -> u i a
19:18:23 <mgsloan> zipArray f a = accum f a . assocs
19:20:00 <roostaj> @src fromJust
19:20:00 <lambdabot> fromJust Nothing  = undefined
19:20:00 <lambdabot> fromJust (Just x) = x
19:20:18 <roostaj> :t undefined
19:20:19 <lambdabot> forall a. a
19:20:37 * Axman6 wishes that functions like would at least be kind enough to use error "helpful error message"
19:20:54 * roostaj has thrown a helpful error message
19:21:23 <hatds> doesn't it actually say error "fromJust"?
19:21:49 <roostaj> i think it throws an exception yes
19:22:11 <roostaj> > fromJust Nothing
19:22:12 <lambdabot>   * Exception: Maybe.fromJust: Nothing
19:22:31 <Axman6> luckily the actual implementations usually do do the right thing :)
19:22:46 <cads> Axman6: I asked but got no reply
19:22:56 <Axman6> blackdog!
19:22:58 <roostaj> > fromJust (Just Nothing)
19:22:59 <lambdabot>   Nothing
19:23:03 <cads> blackdog, are you nearby?
19:23:13 <Axman6> he'll be around eventually
19:23:16 <hatds> is there a way to query heap size during runtime?
19:23:21 <roostaj> fromJust (Just fromJust)
19:23:25 <roostaj> > fromJust (Just fromJust)
19:23:26 <lambdabot>   * Exception: Maybe.fromJust: Nothing
19:23:48 <cads> blackdog: sorry for the messages in privat
19:23:50 <hatds> or query anything memory related
19:24:30 <Axman6> > fromJust (Just fromJust) Nothing
19:24:31 <lambdabot>   * Exception: Maybe.fromJust: Nothing
19:24:38 <Axman6> > fromJust (Just fromJust) (Just 3)
19:24:39 <lambdabot>   3
19:24:48 <roostaj> > fromJust (Just fromJust) $ Just Nothing
19:24:49 <lambdabot>   Nothing
19:25:45 <roostaj> > fromJust (Just fromJust) (Just fromJust) 3
19:25:46 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
19:25:47 <lambdabot>    arising from the lite...
19:26:11 <roostaj> > fromJust (Just fromJust) (Just fromJust) Just 3
19:26:12 <lambdabot>   Couldn't match expected type `a -> Data.Maybe.Maybe a'
19:26:12 <lambdabot>         against infe...
19:26:16 <roostaj> > fromJust (Just fromJust) (Just fromJust) (Just 3)
19:26:17 <lambdabot>   3
19:26:56 <roostaj> fromJust . cycle (Just fromJust) $ Just 3
19:27:24 <skorpan> > fromJust . cycle (Just fromJust) $ Just 3
19:27:26 <lambdabot>   Couldn't match expected type `[a]'
19:27:26 <lambdabot>         against inferred type `Data.Mayb...
19:27:27 <Axman6> cycloe is not the right function
19:32:26 <Axman6> cycle*
19:33:33 <roostaj> :t (:)
19:33:35 <lambdabot> forall a. a -> [a] -> [a]
19:34:17 <Axman6> :t cycle
19:34:18 <lambdabot> forall a. [a] -> [a]
19:34:54 <DerisionSnort> @pl zip xs (chain xs)
19:34:55 <lambdabot> zip xs (chain xs)
19:36:09 <Axman6> @pl \xs -> zip xs (chain xs)
19:36:10 <lambdabot> ap zip chain
19:38:34 <cads> hey is it possible to track back responses this guy guy to his "why haskell has not succeeded" rant?
19:38:43 <pastah_rhymez> @hoogle exitFailure
19:38:44 <lambdabot> System.Exit exitFailure :: IO a
19:38:44 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
19:39:17 <cads> http://www.jelovic.com/articles/why_people_arent_using_haskell.htm
19:39:29 <Gracenotes> am I people? D:
19:39:41 <Axman6> i think we both are :O
19:40:04 <tensorpudding> am i a people?
19:40:12 <cads> mmmmmbeblortbazazazazammmmmmm,,,,blort
19:40:31 <Gracenotes> yeah, we need a Haskell-pushing campaign with the slogan "Am I People?"
19:40:35 <Gracenotes> that'll work great
19:40:44 <tensorpudding> the idea of haskell was to never break mainstream wasn't it?
19:40:56 <pastah_rhymez> is it bad style to do "unless b exitFailure" in main?
19:41:10 <michael|> I kind of like that there aren't those snazzy, do-everything libraries.
19:41:33 <cads> yeah, haskell is a big scheme to keep aweme modes of programmign awaaay from the public.
19:42:03 <michael|> Not bashing on python or anything, but I've seen far too many people go into the channel and talk of doing something, only to have their idea disregarded "because it's already been done, use <X> library" That doesn't promote improvement, of the programmer or community.
19:42:15 <cads> well, the fellow does seem to fail to mention stuff like cabal
19:42:30 <Axman6> cads: that article must be quite old
19:42:35 <Gracenotes> if not text manipulation, it's the complicated, better-phrased-declaratively problems that work snazzily
19:42:36 <tensorpudding> code reuse is only good if code is general enough to be using
19:42:47 <tensorpudding> also, yeah, it references hugs98...
19:43:01 <Axman6> so, i'd going to pass it off as irrelevant
19:43:15 <cads> Axman6: and I bet it received a lot of positive linkbacks where we'd say "hey you said this, now look ath _this_!"
19:43:20 <Philonous> I wonder how old this article is. Doesn't seem to be that new.
19:43:27 <cads> 5 years old
19:43:29 <tensorpudding> hugs is pretty dead
19:43:48 <Axman6> a hell of a lot has happened in the last 5 years
19:43:58 <tensorpudding> haskell 2010 happened
19:44:01 <Axman6> possibly much more than  happened in the 15 previous
19:44:08 <Gracenotes> still. it's a bad thing to be immune to criticism.
19:44:09 <cads> also, not that in 05 they weren't so concerned about concerrency as now - it's not mentioned
19:44:35 <tensorpudding> someone could probably write an article that said most of the same things and it'd still be somewhat relevant
19:44:51 <Axman6> oh gross, that page was written in frontpage
19:45:41 * michael| clears his browser's leftover data, before the Frontpage produced html eats away at his machine
19:45:51 <jaredj> help, i need to parse an sgml file
19:46:13 <tensorpudding> there could probably be more bland "interface with foo" libraries
19:46:20 <jaredj> it's rather well-structured but not enough to use the xml libraries
19:46:55 <roostaj> is (:) right associative?
19:47:01 <mauke> yes
19:47:08 <tensorpudding> and it definitely needs more work on GUI libraries
19:47:15 <roostaj> mauke: thanks,  i thought so
19:47:16 <tensorpudding> and multimedia too
19:48:57 <Gracenotes> jaredj: well-structured? not HTML?
19:49:14 <jaredj> yes, well-structured. OFX 1.x
19:49:27 <jaredj> i've tried to use parsec but ran into typing problems
19:50:10 <jaredj> (open financial exchange, data from a bank)
19:50:13 <Gracenotes> would a non-validating XML not choke?
19:50:19 <Gracenotes> XML parser
19:50:31 <tensorpudding> despite having three different web frameworks, none of them have really evolved into anything mature
19:50:38 <roostaj> Is there an easy way to say | data Tup a = Cons a (Tup b) | Empty ?
19:50:49 <roostaj> I can't say Tup b
19:50:56 <tensorpudding> you need to have the b on the left side also
19:51:01 <tensorpudding> data Tup a b
19:51:05 <jaredj> Gracenotes: no, there are many optional closing tags which are left out
19:51:19 <c_wraith> tagsoup, then?
19:51:24 <roostaj> tensorpudding: but I wouldn't want to do that would I
19:51:25 <jaredj> that gets me one step, yes
19:51:29 <Gracenotes> roostaj: you're looking for a heterogeneous list?
19:51:39 <roostaj> gracenotes: like a Tuple, yes
19:51:41 <Gracenotes> I was thinking tagsoup. although that is meant for HTML moreso
19:51:48 <jaredj> it works great for this stuff.
19:52:02 <jaredj> but then i need to parse the soup. that's what i tried tagsoup-parsec for
19:52:04 <roostaj> Gracenotes: actually its a more general question I suppose
19:52:13 <Gracenotes> roostaj: it's not typesafe unless you specify the type of every position. Which you just use a normal list for.
19:52:19 <Gracenotes> I mean, a normal tuple
19:52:56 <Gracenotes> For lists which can contain one of X types, just make a data type with X constructors
19:53:23 <Gracenotes> and use an [XData]. But for mixed list, you can see why that might be an issue, right.
19:54:07 <jaredj> ah - here in RWH is an example of parsing something tree-like with parsec, not just a CSV
19:54:35 <Gracenotes> (incidentally, if you only want the list elements for their typeclass-using properties, some forall datatype qualification can be used)
19:54:43 <jfischof> Trying to cabal with setup.hs. Almost works, fails at the end with a : ar is required but could not be found. what's ar?
19:54:58 <jfischof> opps I mean trying to build cabal
19:55:11 <Cale> roostaj: Think of types as permission to use a piece of data in particular ways. If the type of some value could be anything at all, then you're essentially not allowed to inspect it in any way.
19:55:28 <joe5> wondering if you have any comments on the code : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15564#a15564
19:55:33 <jaredj> i think i found the kind of data structure i need to put the data in
19:55:44 <elly> Cale: _|_!
19:56:00 <joe5> i think the function next16bytes is a bit iffy. just curious if there are ways to make it simpler/better.
19:56:03 <tensorpudding> i'm trying to think of situations when a heterogenous list would really be more useful than fixed tuples and standard lists
19:56:15 <jaredj> Gracenotes, c_wraith: i'll hack some now, thanks for your help
19:56:39 <Cale> elly: Exactly :)
19:56:40 <roostaj> tensorpudding: i was just experimenting with recursive types.... i doubt there is a use
19:56:49 <augur> conal
19:56:59 <conal> augur: hi
19:57:03 <augur> i tried watching your beautiful differentiation video again
19:57:05 * hackagebot upload: hricket 0.3 - A Cricket scoring application. (AnthonySimpson)
19:57:10 <pastah_rhymez> @type exitSuccess
19:57:11 <augur> i still dont understand it. :(
19:57:11 <lambdabot> Not in scope: `exitSuccess'
19:57:12 <Axman6> jfischof: what Os are you on?
19:57:13 <roostaj> Cale: right
19:57:13 <augur> too mathy :(
19:57:17 <pastah_rhymez> @type exitSucess
19:57:18 <lambdabot> Not in scope: `exitSucess'
19:57:19 <jfischof> joe5: I think the idea of storing chained functions is pretty useful
19:57:21 <pastah_rhymez> @type exitSucces
19:57:23 <lambdabot> Not in scope: `exitSucces'
19:57:28 * pastah_rhymez gives up
19:57:33 <jfischof> Axman6: windows
19:57:39 <conal> augur: sorry :(
19:57:48 <augur> but i get the feeling its awesome and cool, so
19:57:50 <Axman6> ah, can't help then
19:58:19 <joe5> is there a fold on a list of lists?
19:58:21 <jfischof> Axman6: do you know if it is an exe of a haskell thing?
19:58:46 <Axman6> it's a C compiler thing afaik, it's what joins .o files (i think...)
19:58:58 <jfischof> cool thanks
19:59:05 <Axman6> joe5: what shoudl it do?
19:59:09 <joe5> jfischof: where can i find an example of this.
19:59:17 <Cale> roostaj: There are existential types which let you essentially forget the particular type that some type variable is, but of course, it's a useless thing to do unless you also bundle the value with some operations that you'll be able to apply to it.
19:59:18 <conal> augur: is there a particular point at which you get lost?
19:59:19 <roostaj> tensorpudding: data Tup a b = Cons a (Tup b a) | Nil makes a fun alternating homogenous list lol
19:59:32 <joe5> Axman6: just reads a binary file into a string of bits and writes it back in lines.
19:59:33 <tensorpudding> heh
19:59:45 <roostaj> tensoring: hetero.
19:59:47 <augur> conal: i think right about the beginning where you mention differentiation ;)
19:59:49 <joe5> Axman6: just reads a binary file into a string of bits and writes it back in lines of 16 bytes each.
19:59:56 <augur> no but seriously, probably once you hit linear maps
19:59:59 <Axman6> joe5:  a fold on lists of lists?
20:00:02 <jfischof> joe5: look at the thrist  package on hackage...or give me a sec and i'll put some code on paste
20:00:13 <joe5> jfischof: thanks.
20:00:21 <conal> augur: it does get pretty abstract, because i wanted to show the very essence of automatic differentiation, and show a methodology for getting to the essence of other algorithms as well, as well as structuring them.
20:00:22 <joe5> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15564#a15564
20:00:25 <roostaj> Cale: I was curious as to how tuples were implemented... I assume the example isn't as straightforward as a list?
20:00:55 <joe5> Axman6: the function next16bytes works on the first 16 bytes each time and I wish there was a fold that could do that.
20:00:55 <conal> augur: have you looked at http://conal.net/papers/type-class-morphisms ?
20:00:59 <augur> conal: yeah. i'm not sufficiently familiar with math to grasp what went on after that
20:01:04 <augur> no, ill check it out tho
20:01:21 <Cale> roostaj: They're all just separate types with special syntax
20:01:35 <conal> augur: the TCM paper gives a general methodology, of which beautiful differentiation is a special case.
20:01:40 <Axman6> joe5:  i'm assuming next16Bytes is based on splitAt?
20:01:42 <joe5> result is a list of lists (a function returns a list) -- put together by the fold on list of lists..
20:01:47 <Gracenotes> a tuple with n elements is just a single constructor with n fields
20:01:49 <augur> conal: awesome. ill take a look
20:01:49 <Cale> roostaj: like   data Triple a b c = Triple a b c  except with some syntax sugar
20:01:51 <conal> augur: and "push-pull functional reactive programming" is another special case.
20:01:53 <joe5> Axman6: yes
20:02:02 <augur> conal: oh you and your frp :)
20:02:05 <conal> augur: i'm very excited about this methodology.
20:02:07 <conal> :)
20:02:15 <Gracenotes> conal: push-pull has something to do with differentiation?
20:02:18 <augur> i didnt get that talk either D:
20:02:18 <jfischof> joe5: Here is a test I made for chaining invertible functions: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15565#a15565
20:02:47 <Axman6> well. why not just define, splitsAt n [] = []. splitsAt n xs = let (ys,zs) = splitAt n xs in ys : splitsAt n zs?
20:02:51 <conal> Gracenotes: yes.  they share a development methodology, described in http://conal.net/papers/type-class-morphisms
20:03:09 <Axman6> > let splitsAt n [] = []. splitsAt n xs = let (ys,zs) = splitAt n xs in ys : splitsAt n zs in splitsAt 16 [1..]
20:03:10 <lambdabot>   <no location info>: parse error on input `='
20:03:41 <Axman6> > let splitsAt n [] = []. splitsAt n xs = let (ys,zs) = splitAt n xs in ys : splitsAt n zs; in splitsAt 16 [1..]
20:03:42 <lambdabot>   <no location info>: parse error on input `='
20:03:44 <Axman6> bah
20:03:46 <roostaj> Cale: GraceNotes: ah ok. So does the compiler perform some magic when you try to create a tuple?
20:03:46 <conal> lots of activity on http://www.reddit.com/r/programming/comments/al2gf/why_program_with_continuous_time/ .  contributions/votes anyone?
20:03:58 <Axman6> > let splitsAt n [] = []; splitsAt n xs = let (ys,zs) = splitAt n xs in ys : splitsAt n zs; in splitsAt 16 [1..]
20:04:00 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],[17,18,19,20,21,22,23,24,25,26,27...
20:04:04 <Cale> roostaj: Well, depends on what you call magic. Not really.
20:04:24 <Cale> roostaj: They're a special case in the parser and compiler to some extent, I suppose.
20:04:25 <augur> btw, guys, why is it that type classes can have functions of, say, a -> b -> c, where a is an instance, but b isnt?
20:04:33 <roostaj> Cale: :D.. that is what i meant
20:04:33 <Axman6> roostaj: there's nothing magic about tuples
20:04:38 <Gracenotes> conal: ah.. type class morphisms. I had watched the video about types being calling conventions (strict core), and someone asked about them... was that you?
20:04:56 <Cale> roostaj: But they're implemented the same as any other datatype
20:05:09 <conal> Gracenotes: different talk
20:05:15 <Axman6> data (,) a b = (,) a b
20:05:20 <Axman6> roughly
20:05:23 <Gracenotes> yeah, I know, but audience questions and such
20:05:31 <roostaj> Axman6: what about 3 tuples?
20:05:37 <roostaj> Axman6: oops ignore
20:05:43 <augur> is there some principled difference between having it that way and inverting the type classes so that everything that previous was the instance now is just some participating type for a new instance?
20:05:44 <roostaj> Axman6: lol *slap*'
20:05:45 <Axman6> data (,,) a b c = (,,) a b c
20:05:45 <Cale> roostaj: the same, but with another parameter and another comma ;)
20:06:03 <Axman6> on to a 63 tuple, in GHC
20:06:13 <conal> Gracenotes: oh.  someone asked about TCMs in the calling-conventions talk?  i'd forgotten.
20:06:16 <roostaj> Axman6: can't go bigger than 63?
20:06:18 <Cale> It's almost silly to support tuples that large
20:06:29 <Axman6> they aren't defined any bigger than 63 in ghc
20:06:34 <Gracenotes> conal: possibly. But I guess it's what's new in the types community, then :)
20:06:48 <Axman6> no practical reason i can think of for not going any higher though
20:06:50 <roostaj> Cale: Axman6: that was my real question... i was wondering if they were actually defined somewhere or if the compiler did some magic at compile to fit any size tuple
20:06:54 <Gracenotes> > (3, 'a', ()) :: (,,) Int Char ()
20:06:56 <lambdabot>   (3,'a',())
20:07:12 <Cale> Axman6: They're defined larger than that. It's that the instances cut out.
20:07:21 <Axman6> file:///Users/Axman/usr/share/doc/ghc/libraries/ghc-prim/GHC-Tuple.html
20:07:24 <Axman6> uh
20:07:26 <Cale> Axman6: try  :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)  or something :)
20:07:28 <conal> Gracenotes: :)  i hope people get into them.  sure was an epiphany to me.  and one that i muddled into just because i like to make my code poetic, and my semantic specifications also.
20:07:33 <Axman6> the corresponding file in the GHC docs :)
20:07:59 <Axman6> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:08:01 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
20:08:01 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q ->
20:08:01 <lambdabot> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 ->
20:08:01 <lambdabot> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 ->
20:08:04 <lambdabot> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 -> t89 -> t90 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33,
20:08:05 <Axman6> >_>
20:08:07 <lambdabot>  t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69, t70, t71, t72,
20:08:09 <lambdabot> t73, t74, t75, t76, t77, t78, t79, t80, t81, t82, t83, t84, t85, t86, t87, t88, t89, t90)
20:08:10 <Cale> I didn't mean in the channel. :P
20:08:13 <conal> Gracenotes: and so i started noticing the relationships.  thought it was a fluke at first.  now if i don't see TCMs, i know to redesign my library.
20:08:14 <elly> ...dammit, lambdabot
20:08:15 <Axman6> XD
20:08:25 <conal> yow!  quite a type.
20:08:51 <holmak> eh? TCM?
20:09:00 <holmak> tail call ___?
20:09:08 <tensorpudding> they defined the tuple constructor that large?
20:09:13 <lambdabot> That was exhausting.
20:09:19 <Axman6> tensorpudding: no
20:09:19 <Cale> holmak: typeclass morphism
20:09:20 <conal> holmak: type class morphism
20:09:23 <Gracenotes> they are defined, so to speak, in http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html
20:09:24 <Axman6> compiler magic
20:09:29 <holmak> ah, thanks. google time...
20:09:44 <Gracenotes> Manuel says: Including one more declaration gives a segmentation fault.
20:09:52 <roostaj> GHCI won't go higher than 16
20:10:00 <Cale> roostaj: It will.
20:10:04 <tensorpudding> manuel?
20:10:12 <Cale> The instances of various things are missing beyond that though.
20:10:22 <roostaj> Cale: oh, don't split hairs :D
20:10:24 <Cale> Like, eventually you won't be able to show them
20:10:36 <roostaj> Cale: ah i see
20:10:37 <Cale> But you can create and pattern match on them
20:11:03 <Gracenotes> there is a lot of RTS overhead in huge tuples
20:11:47 <roostaj> Cale: besides the fact that large tuples aren't a great idea... there has to be a constructor for every size and every function that uses tuples (such as print) has to support it as well
20:12:26 <roostaj> not every.... but if its a general(ish) function
20:12:49 <Gracenotes> well. show instances mean that generic types lug their own instances around.
20:12:52 <Axman6> A 69-tuple is too large for GHC (max size is 62) Workaround: use nested tuples or define a data type
20:13:02 <Cale> Nobody ever uses tuples much larger than triples anyway
20:13:06 <Axman6> when doing let x = 42 in (x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x)
20:13:10 <Cale> Even triples are kind of rare
20:13:17 <Axman6> aye
20:13:43 <Cale> Eventually you define your own datatype (and if it has that many fields, you're probably doing something wrong anyway)
20:13:49 <roostaj> Cale: Axman6: thanks for the insight
20:13:59 <Twey> Can HList replace tuples?
20:14:17 <Cale> Oh, that's funny.
20:14:19 <dolio> Depends.
20:14:54 <Twey> Cale: Hmm?
20:15:10 <Cale> The fact that GHC refuses to make a tuple that large at all
20:15:15 <Twey> Ah
20:15:22 <Cale> despite the fact that it will tell you the type of that constructor
20:15:34 <Twey> Haha, really?  Huh
20:15:47 <Twey> :t let x = 42 in (x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x)
20:15:48 <heatsink> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:15:48 <lambdabot>     A 69-tuple is too large for GHC
20:15:48 <lambdabot>       (max size is 62)
20:15:48 <lambdabot>       Workaround: use nested tuples or define a data type
20:15:49 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n
20:15:49 <lambdabot> -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> (a, b, c,
20:15:50 <lambdabot> d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45)
20:15:53 <Twey> No it won't
20:16:06 <Axman6> o.O
20:16:08 <Twey> Oh
20:16:09 <Twey> Huh.
20:16:13 <Axman6> i did a much larger one before
20:16:18 <Axman6> how odd
20:16:26 <tensorpudding> making a 62+ entry record type would be "fun"
20:16:26 <heatsink> ^______________________________________^
20:16:39 <dolio> GHC will tell you the type of arbitrarily large tuple constructors.
20:16:40 <augur> anyone? anyone?
20:16:53 <heatsink> I made a rather large record type a while ago.
20:16:54 <Cale> ah, you can use (,,,,...,,) x x x x ... x notation
20:16:59 <dolio> And it will actually let you apply them to as many elements as they take.
20:17:04 <Cale> It's just the special syntax it doesn't like
20:17:06 <dolio> But I don't know what happens from there.
20:17:21 <dolio> It can't show them, for instance, because there's no instance that big.
20:17:44 <pikhq> dolio: Presumably you could create the instances.
20:17:52 <tensorpudding> what are the theoretical limits on the size of a record type?
20:17:55 <pikhq> >:D
20:18:11 <pikhq> tensorpudding: *Theoretical*?
20:18:23 <pikhq> Infinity.
20:18:27 <Gracenotes> the limits of memory, really
20:18:30 <tensorpudding> in haskell, i mean
20:18:38 <pikhq> tensorpudding: Yes.
20:18:56 <heatsink> Hmm, my record type only had 42 fields, I guess it doesn't count.
20:19:10 <tensorpudding> if you had a number of fields that was greater than the maximum for Int, for example
20:20:33 <tensorpudding> that would be a truly astonishing thing
20:21:01 <pikhq> tensorpudding: Haskell does allow it (though probably no implementation does)
20:21:50 <orbekk> tensorpudding: Int isn't really a maximum. it is easy to represent arbitrarily large tuples. just think of it as an array of pointers
20:22:27 <orbekk> tensorpudding: in *practice* the maximum number is limited by the amount of memory, as Gracenotes pointed out
20:22:46 <tensorpudding> okay
20:22:48 <jaredj> data Thing = Record1 { foo :: Int } | Record2 { bar :: Bla }
20:22:49 <tensorpudding> that does make sense
20:23:04 <jaredj> something is syntactically wrong and staring me in the face
20:23:12 <jaredj> but i don't know what
20:23:35 <tensorpudding> what happens if you use foo on a Record2?
20:23:56 <jaredj> erh is that what's wrong
20:24:03 <jaredj> that makes sense
20:24:14 <heatsink> tensorpudding: run-time error
20:24:24 <Philonous> Pattern match failure
20:24:36 <tensorpudding> well, i'm pretty sure you can't create enumerations with records as constructors
20:24:56 <jaredj> makes sense.
20:29:51 <jaredj> this is blowing my mind. the data is so simple but i can't make the right shaped container for it
20:30:53 <heatsink> jaredj: What is the data?
20:33:15 <jaredj> at the core, a transaction response contains an account (with three bits of info), a transaction list (a list of transactions, each of which has eight bits of data), plus an ending balance, which is two bits of data)
20:33:28 <jaredj> other parts of the file are similar.
20:34:44 <heatsink> That does sound like a straightforward data constructor.
20:35:28 <Axman6> sounds like you've just described your datatypes quite clearly
20:37:12 <Twey> 04:24:12 < tensorpudding> well, i'm pretty sure you can't create enumerations with records as constructors
20:37:16 <Twey> I think you canâ¦
20:37:26 <Twey> So long as you write the instance yourself
20:38:14 <megacz> Is there a canonical name for the function \x->(x,x)?  Hoogle doesn't return anything interesting for ::a->(a,a)
20:38:25 <Axman6> join (,)
20:38:26 <megacz> (category theorists call this the "diagonal map" or \Delta)
20:39:03 <Twey> @hoogle a -> (a, a)
20:39:04 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
20:39:05 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
20:39:05 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
20:39:11 <jaredj> Axman6: i thought so. problem is, i run into type problems writing the parser
20:39:22 <Twey> Huh.  I'd've thought it would return join.
20:39:32 <Axman6> jaredj: perhaps you couls share some code?
20:39:47 <jaredj> :d lemme see what i recorded last
20:39:55 <Axman6> Twey: doesn't really have a hooglable type
20:40:07 <megacz> Axman6/Twey, isn't "join" the thing you use on monads?
20:40:11 <megacz> @hoogle join
20:40:12 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
20:40:12 <Twey> megacz: Yes
20:40:12 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
20:40:12 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
20:40:20 <Twey> (r ->) is a monad
20:40:21 <Axman6> yes, (,) is a function, which is a monad
20:40:22 <megacz> Oh, I see.  You're using it for the pair monad.  Cute.
20:40:27 <Twey> Function monad.
20:40:33 <megacz> Er, yes.
20:40:36 <Axman6> there is no pair monad
20:40:41 <megacz> Still, I think it deserves its own name in the prelude.
20:40:48 <matsuura> can you explain => and -> to me/.
20:41:01 <Axman6> :t (+)
20:41:02 <lambdabot> forall a. (Num a) => a -> a -> a
20:41:14 <Twey> Axman6: Hm, but Hoogle usually mentions functions that can be curried into the right type
20:41:18 <jaredj> Axman6: http://patch-tag.com/r/jaredj/ofx1/snapshot/current/content/pretty/Text/OFX1
20:41:25 <Axman6> the Num a puts a constraint on the a's in the type, which says that the a's must implement the Num class
20:41:31 <jaredj> Types.hs has all the record types
20:41:33 <matsuura> wait, nvm.. got it
20:41:34 <matsuura> :p
20:41:51 <jaredj> GradualRecord.hs has the stateful parsing tomfoolery that gets me into such trouble
20:42:06 <Axman6> Twey: only if they're single functions. join (,) is two functions joined together
20:42:44 <Twey> Hm, I suppose
20:43:02 <Axman6> Gracenotes: and what errors are you having?
20:43:23 <Gracenotes> what errors where?
20:43:24 <Axman6> s/two functions joined together/one function applied to another
20:43:32 <Axman6> uh, sorry, that was for jaredj
20:44:12 <jaredj> ehe. well my idea was to parse a tag nested inside a larger tag by first consuming its entire contents, then running a parser on it
20:44:31 <Axman6> that doesn;t sound like how it should be done
20:44:43 <jaredj> likely not.
20:45:33 <jaredj> i thought it would give me the freedom to make the subparser's state be of any type
20:45:38 <megacz> Here's another one
20:45:38 <megacz> @hoogle (a->b)->(c->d)->((a,b)->(c,d))
20:45:39 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:45:51 <jaredj> but ghc gets its panties in a bunch when it isn't the same type as the outer parser
20:45:54 <megacz> Now, why would one need to import some graph library to get such an obvious function?
20:46:19 <mauke> megacz: because it's not very common
20:46:28 * megacz meant (a->c)->(b->d)->((a,b)->(c,d))
20:46:33 <megacz> @hoogle (a->c)->(b->d)->((a,b)->(c,d))
20:46:34 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:46:44 <Axman6> :t (&&&)
20:46:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:46:49 <megacz> &&& is for arrows
20:46:53 <mauke> :t (***)
20:46:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
20:46:55 <megacz> And yes, it's super-useful there...
20:46:59 <Axman6> megacz: of which (->) is
20:47:03 <mauke> megacz: functions are arrows
20:47:11 <Axman6> even looks like an arrow :O
20:47:13 <megacz> Oh, cool!  I get it.  Treat (->) like an arrow.  Okay, I'm starting to get the hang of this.
20:47:25 <Axman6> it _is_ an arrow :P
20:47:37 <tensorpudding> it is the most common arrow
20:47:40 <Twey> Haha, yes
20:47:41 <Axman6> just replace a with (->), and you've got your type
20:48:34 <Twey> It's the only common arrow ;)
20:48:46 * Saizan_ loves DeriveFunctor
20:48:52 <megacz> Twey, I beg to differ!  Every monad is an Arrow.
20:49:41 <Twey> megacz: I think you got your capitalisation backwards.  :Ã¾
20:50:03 <megacz> heh.  Matter of perspective, I guess... :)
20:50:22 <Axman6> are Monads arrows?
20:50:35 <Twey> Thanks to Kleisli, yes
20:50:36 <Axman6> they seem to have the wrong kind...
20:50:41 <megacz> @hoogle Kleisli
20:50:41 <lambdabot> Control.Arrow newtype Kleisli m a b
20:50:42 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
20:50:42 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
20:50:51 * Axman6 doesn;t know what Kleisli is
20:50:51 <Twey> They're arrows, but they're not Arrows
20:50:52 <megacz> Comonads are Arrows too.
20:51:18 <Twey> Axman6: http://www.haskell.org/haskellwiki/Arrow_tutorial#Kleisli_Arrows
20:51:43 <Saizan_> s/are/give raise to/g
20:51:46 <megacz> Twey, you seem to be making some distinction based on capitalization.  Could you enlighten me?
20:51:54 * mauke gives Saizan_ a raise
20:52:29 <Twey> megacz: While monads are conceptually arrows, Haskell Monads are not immediately members of the Arrow typeclass, nor can they be directly made so
20:52:30 <Saizan_> heh, *rise
20:53:01 <megacz> Oh, I see.  You mean that it is not the case that (Monad m) => (Arrow m).  I agree.
20:53:27 <dolio> Monads aren't conceptually arrows either, really.
20:53:48 <megacz> dolio, how do you mean?  I think of Arrows as generalizing monads and comonads (and other things too).
20:53:50 <Twey> I guess that's where Saizan's âgive rise toâ comes in.
20:54:35 <dolio> A monad is a functor T : C -> C with some natural transformations. An arrow (in the Arrow sense) is something C^op x C -> C, or something of that sort.
20:55:05 <megacz> dolio, a monad is a monoid in the functor category Cat[C,C].  An arrow is a monoid in the bifunctor category Cat[C*C^op,C].
20:55:28 <megacz> .. and a comonad is a monoid in Cat[C^op,C]
20:56:51 <megacz> so monads and comonads are just arrows that ignore one of their arguments.
21:00:01 <dolio> Is that right? I hadn't really thought about it.
21:00:21 <megacz> http://www.comlab.ox.ac.uk/people/chris.heunen/publications/2006/arrows/arrows.pdf
21:00:21 <Saizan_> that seems to match the Kleisli and CoKleisli constructions
21:00:36 <megacz> (that paper made way more sense to me than any of the papers on Freyd categories)
21:00:37 <dolio> A comonoid in Cat[C,C] is a monoid in Cat[C^op,C]
21:01:11 <dolio> Yeah, I've never investigated much of the literature on arrows.
21:01:17 <Saizan_> all these monoids are using functor composition as the monoidal product, right?
21:01:28 <dolio> Yes.
21:03:07 <Saizan_> you can compose a functor C^op -> C with itself?
21:03:37 <dolio> Well, I don't actually know about the ones involving C^op.
21:04:18 <dolio> That doesn't matter when you say that a comonad is a comonoid in Cat[C,C].
21:04:37 <Saizan_> trye
21:04:41 <Saizan_> *true
21:04:50 <megacz> Saizan_, it need not be.  The monoids are in the internal language of a functor category.  So the monoid is given by an object F of the functor category (ie a functor) plus two morphisms in the functor category (ie natural transformations) id:1->F and mult:F*F->F such that certain ways of composing id/mult satisfy certain equations.  So the monoid's multiplication is actually a natural transformation, not a functor.  That natural
21:04:51 <megacz> transformation F*F->F might be the one that composes its arguments as functors, but it need not be.  As you observe, in the case of the functor caetegory Cat[C^op,C], it cannot be composition.
21:05:57 <dolio> Is that a check mark?
21:06:05 <megacz> check mark?
21:06:11 <dolio> caetegory
21:06:16 <dolio> How did that happen? :)
21:06:49 <Saizan_> well, but for "a monoid in the functor category Cat[C,C]" te be a monad it needs to be composition, right?
21:07:09 <megacz> Saizan_, I know it *can* be.  I'm not sure that it *must* be.  But I cannot come up with an example off of the top of my head.
21:07:42 <dolio> To define a monoid in a category, the category needs to be monoidal.
21:07:47 <Saizan_> well, you don't get join : M . M -> M otherwise
21:08:16 <Saizan_> ..i'd think
21:08:42 <dolio> Monads are monoid objects in the monoidal category Cat[C,C], where the monoidal action is functor composition, and the identity functor is the unit of the monoid.
21:09:45 <megacz> Saying that a category is monoidal is saying something about its objects (for every object A and object B there is an object A-tensor-B with certain properties).  Saying that there is a monoid *in the internal language of a category* is to say that it has finite products and that certain morphisms compose in certain ways.
21:09:59 <dolio> Then monoid objects are objects M together with morphisms I -> M and M (x) M -> M.
21:10:07 <megacz> I'm a real stickler for inserting the phrase "in the internal language of" even when it gets pedantic.  I wish the people who taught me this stuff had done that!
21:10:26 <megacz> dolio, yes, that's a monoid in the internal language.  A "monoidal category" is something else.
21:10:34 <dolio> Yes I know.
21:10:35 <megacz> It's like a weaker version of "has finite products"
21:10:47 <dolio> But the category needs to be monoidal to define a monoid object in it.
21:11:01 <megacz> Sure.  In fact, it needs to have finite products (an even stronger property).
21:12:09 <dolio> No, the monoid objects in Cat[C,C] (monads) don't make use of products.
21:12:47 <Saizan_> can a category be monoidal in more than one way?
21:13:02 <dolio> The identity functor isn't initial, and F . G is not a product.
21:13:24 <dolio> Probably.
21:14:17 <dark> it's fun when people terminate statements with .
21:15:01 <dark> But it's fairly common on technical channels.
21:20:21 <dolio> Wait, my bad, the identity functor would have to be final for it to be a 0-ary product.
21:20:31 <dolio> But I don't think it's that, either.
21:27:23 <dolio> Also, you can define monads *in* an arbitrary 2-category.
21:29:09 <dolio> I'll have to think about the definition, though. But it involves a 1-cell t : C -> C, and some 2-cells eta and mu.
21:29:29 <dolio> And then a monad over a category C is a monad in the 2-category of 1-categories.
21:29:59 <dolio> And, as I recall, a monoidal category is a 2-category with a single object.
21:30:42 <dolio> For instance, the monoidal category Cat[C,C] would be the 2-category with 0-cell C, 1-cells functors, and 2-cells natural transformations.
21:31:46 <dolio> Oh, I know, the 2-cells are eta : id -> t, and mu : t t -> t.
21:33:30 <dolio> And, I suspect, monoids in a monoidal category are monads in the corresponding 2-category.
21:37:21 <roostaj> @src error
21:37:21 <lambdabot> error s = throw (ErrorCall s)
21:37:31 <roostaj> @src ErrorCall
21:37:31 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:37:40 <roostaj> :t ErrorCall
21:37:41 <lambdabot> Not in scope: data constructor `ErrorCall'
21:40:06 <roostaj> @src throw
21:40:06 <lambdabot> throw exception = raise# exception
21:40:17 <roostaj> @src raise#
21:40:17 <lambdabot> Source not found. Sorry.
21:40:23 <roostaj> :t raise#
21:40:25 <lambdabot> Not in scope: `raise#'
21:40:33 <roostaj> :t raise
21:40:34 <lambdabot> forall (a :: * -> * -> *) ex b. (ArrowError ex a) => a ex b
21:46:53 <c_wraith> @djinn (s -> (a, s)) -> (a -> (s -> (b, s)) -> (s -> (b, s)
21:46:54 <lambdabot> Cannot parse command
21:47:04 <c_wraith> oops
21:47:11 <c_wraith> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s)
21:47:11 <lambdabot> Cannot parse command
21:47:17 <c_wraith> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
21:47:17 <lambdabot> f a b c =
21:47:18 <lambdabot>     case a c of
21:47:18 <lambdabot>     (d, e) -> b d e
21:47:44 <c_wraith> heh.  djinn can derive >>= for State.
21:50:06 <dolio> Apparently it likes strict state.
21:50:14 <MarcWeber> I forgot to add build-depends while patching this .cabal file: http://dpaste.com/140815/   What happens to those lines 42 and 39 ? Should there be at least a warning?
21:55:36 <Saizan> i'd hope so
22:03:05 <MarcWeber> Saizan: There is none. I'll write to the mailinglist then.
22:11:32 <OmniSord> Hello.  If I have 2 data structures, say A and B, both of which should have a field that represents someones name, how can I reuse the name of the field?  i.e. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15566#a15566
22:11:52 <OmniSord> (disclaimer, completely new to haskell)
22:12:05 <mtnviewmark> you cant, unless they are in different modules
22:12:26 <OmniSord> mtnviewmark, I can't even have a type declaration for it and use that?
22:12:56 <mtnviewmark> well -- you could have a type class   Named that has a member function, name
22:13:09 <mtnviewmark> but each structure would still need their own field name (if you continued to use record syntax)
22:13:36 <mtnviewmark> data A = A { nameA :: String }     instance Named A where name = nameA
22:13:37 <OmniSord> mtnviewmark, is using record syntax recommended for readability, or should i just switch from it?
22:13:52 <mtnviewmark> very hard to say - depends on the data structure
22:14:09 <mtnviewmark> if you have seven fields most of which are String --- I'd say use record syntax
22:14:16 <mgsloan> instance (IArray u a, Eq a) => Eq (u Int a) where
22:14:20 <mtnviewmark> if you have exactly one field who's value is String
22:14:22 <mtnviewmark> don't
22:14:35 <bos> oh, my liver for first-class records.
22:14:36 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
22:14:46 <mtnviewmark> between those two extremes there is personal choice
22:15:03 <OmniSord> mtnviewmark, ok thank you.  i havent learned about the instance keyword yet, i will look into that
22:15:04 <mgsloan> ^ this instance is causing a "Overlapping instances for Eq (Int, Int)"
22:15:22 <bos> copumpkin: wrt your question about statistics and Double and Float, no, i haven't worried about polymorphism.
22:16:00 <mgsloan> err, nvmind, I found a workaround
22:16:25 <mtnviewmark> OmniSord - OH - I read your question as about type classes,
22:16:29 <mtnviewmark> not type declarations
22:16:54 <mtnviewmark> type Name = String  -- just creates a synonym
22:17:09 <mtnviewmark> then   data A = A Name    and    data B = B Name
22:17:28 <mtnviewmark> still doesn't get you a single function   name   that gets you the "name" field of A or B
22:18:50 <OmniSord> right, though it is a smaller structure, i could use the type synonym for readability, and then create methods to return the name using name (A name) = name, and name (B name) = name, yes?
22:19:10 <Axman6> no
22:19:19 <OmniSord> * not sure why i said smaller structure, meant not record syntax...
22:19:22 <Axman6> if A and B are different types, then you can't do that
22:19:36 <Axman6> its type would be both A -> Name, and B -> Name, which can't happen
22:19:57 <Axman6> if you made A and B of the same type though, it could be done
22:20:16 <Axman6> so, data NamedThings = A Name | B Name | C Thing
22:24:31 <OmniSord> hmm, with the structure ive got i could create a data type with multiple declarations each using record syntax (forgive my incorrect wording)
22:24:33 <OmniSord> i.e. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15566#a15568
22:24:56 <OmniSord> (the Letters type)
22:25:27 <OmniSord> actually, for my type that looks cleaner
22:25:32 <Axman6> the latter would work, yes
22:25:51 <Axman6> and i think record syntax allows you to do that just fine
22:26:33 <OmniSord> great, thank you greatly Axman6 and mtnviewmark !
22:26:57 <Axman6> no worries. and keep asking questions :)
22:28:46 <roostaj> @src fromMaybe
22:28:46 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
22:29:07 <roostaj> :t fromMaybe
22:29:08 <lambdabot> forall a. a -> Maybe a -> a
22:29:46 <mtnviewmark> OmniSord - are the real A and B types going to contain many fields?
22:29:48 <roostaj> > fromMaybe 3 (Just 4)
22:29:49 <lambdabot>   4
22:29:55 <roostaj> > fromMaybe 3 Nothing
22:29:56 <lambdabot>   3
22:29:58 <OmniSord> mtnviewmark, A has 3, B has 2
22:30:48 <OmniSord> this is really the first program ive written in haskell, just figured it would be fun to learn.  if someone doesn't mind, i will post the code when im done to see what i could do better with it
22:30:50 <mtnviewmark> and will you have more than one or two functions that will need to take an A or a B and process the 'name' field?
22:30:52 <OmniSord> (its not a complicated app)
22:31:31 <OmniSord> so far i have 2 functions taking the name field
22:31:39 <mtnviewmark> please - feel free to post your code and I'm sure more than one of us will be happy to do a code review
22:32:25 <OmniSord> great!
22:32:39 <mtnviewmark> well - here's a question: in some other language that you know, would you have likely used a base class (or super class or interface) for "things which have a name" in this case?
22:33:36 <mtnviewmark> if so, then a type class is probably what you want
22:34:00 <mtnviewmark> (though algebraic data types with multiple constructors can often do the job)
22:34:45 <OmniSord> mtnviewmark, probably not because the few amount of fields
22:35:07 <OmniSord> and there is only 1 field shared
22:35:15 <Stalafin> is the last output ghci produced given some value too? (like 'ans' in matlab or some pocket calculators)
22:35:22 <Stalafin> given some value to*
22:39:02 <mtnviewmark> OmniSord - reload your paste page:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15566#a15569
22:40:08 <OmniSord> mtnviewmark, ah i see now, thank you (i havent gotten to classes yet in Real World Haskell)
22:40:33 <mtnviewmark> while more lines, I think the first way is more in-line with what you've described
22:41:20 <mtnviewmark> one thing I like about Haskell is the ease with which you are led to express "Not all Letters have an address" by having the return type be Maybe Address
22:46:35 <OmniSord> yea, i havent quite grasped the Maybe thing yet, but as i go further in the book im sure i will
22:53:47 <roostaj> Stalafin: yes it is bound to "it"
22:54:52 <roostaj> Stalafin: try : 3 + 3 and then it + 4
22:54:57 <roostaj> you should get 10
22:55:53 <roostaj> Stalafin: also you can use ":show bindings" to show bindings in the prompt... "it" should be one of them
22:57:23 * hackagebot upload: Geodetic 0.3 - Geodetic calculations (TonyMorris)
22:57:25 * hackagebot upload: liboleg 2010.1.1 - A collection of Oleg Kiselyov's Haskell modules (2009-2008) (DonaldStewart)
22:59:09 <mtnviewmark> OmniSord - I have to say, Maybe was one of the first things I fell in love with in Haskell
22:59:19 * mtnviewmark <3's Maybe
23:01:45 <roostaj> @src otherwise
23:01:45 <lambdabot> otherwise = True
23:01:50 <roostaj> lol now that's clever
23:01:56 <roostaj> i don't know why that amuses me
23:02:02 * roostaj giggles childishly
23:07:24 <mtnviewmark> Woot! My holiday vacation project is finished: UUID package sped up significantly
23:08:34 <mtnviewmark> literally an 11th-hour finish (at least in my time zone)
23:08:53 <bos> mtnviewmark: patch accepted?
23:09:10 <mtnviewmark> i have commit rights on the repo -- it's pushed!
23:09:23 <mtnviewmark> but I'm leaving it to Antione to package and submit to hackage
23:09:31 <mtnviewmark> since I'm ignorant of that
23:10:07 <bos> ah, you should get yourself a hackage account.
23:10:15 <mjrosenb> what is the syntax for telling ghc to compile a given source file with an option?
23:10:20 <mtnviewmark> I should probably now extract my work in exploring six different ways to store 16 bytes in Haskell into a single file of benchmarks
23:10:35 <bos> mtnviewmark: doing a submission, once you have an account, is just a matter of "cabal sdist; cabal upload file-it-created"
23:10:36 <mauke> ghc -option file.hs
23:10:57 <mjrosenb> mauke: i meant within the source
23:11:30 <mtnviewmark> ah - easy - but again, as Antoine is the official maintainer, I'll let him do it -- he and I have been actively working on this together, so he'll probably get to it within 24hrs
23:12:20 <bos> cool
23:12:24 <mtnviewmark> is a hackage account the same as a haskell community account?
23:12:42 <bos> mtnviewmark: no - http://hackage.haskell.org/packages/accounts.html
23:13:26 <bos> mtnviewmark: i guess you just send mail to ross and ask for an account
23:13:39 <c_wraith> mjrosenb: {-# GHC_OPTION ... #-}
23:13:48 <mauke> o rly?
23:13:49 <c_wraith> or GHC_OPTIONS
23:13:53 <c_wraith> I can't remember which
23:13:53 * bos is happy with the night's hacking on the new event manager code
23:13:59 <mauke> it's OPTIONS_GHC
23:14:33 <c_wraith> figures  I got it that wrong
23:15:11 <mauke> do you know latex?
23:15:36 * mjrosenb does
23:15:45 <mauke> think OPTIONS_{GHC}
23:17:08 <roostaj> When using guards, if a pattern matches is it's body evaluated?
23:17:15 <roostaj> its*
23:17:25 <mauke> huh?
23:17:55 <roostaj> @src ($!)
23:17:56 <lambdabot> f $! x = x `seq` f x
23:18:06 <roostaj> @src (|)
23:18:07 <lambdabot> Source not found. Wrong!  You cheating scum!
23:18:18 <roostaj> mauke: are you talking to me?
23:18:35 <mauke> roostaj: yes
23:18:46 <mauke> what exactly does "it" refer to?
23:19:19 <roostaj> mauke: sorry, i'm refering to the body of a guard pattern
23:19:20 <roostaj> example:
23:19:39 <roostaj> foo x | x == 3 = (38 + 3)
23:19:43 <roostaj> (38+3) would be the body
23:19:46 <roostaj> x == 3 is the pattern
23:19:56 <roostaj> is 38+3 evaluated if x==3 ?
23:20:08 <roostaj> bad example because i was thinking of a recursion happening
23:20:20 <c_wraith> actually, 'x' is the pattern.  'x == 3' is the guard
23:20:32 <mauke> roostaj: no
23:20:34 <roostaj> c_wraith: ok sorry
23:22:59 <roostaj> mauke: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15573#a15573 then why does length' work and length'' overflow when calling the functions with [1..1000000]
23:23:39 <mauke> because length'' doesn't evaluate n
23:23:43 <mauke> also it doesn't overflow
23:23:48 <mauke> looking at its result does
23:24:24 <OmniSord> mtnviewmark, im confused, if i read a file via readFile, which gives me an IO String, how do i execute lines against it, which takes just String?
23:24:30 <roostaj> mauke: i'm aware of the technicality, thanks. But, I just asked if using guards caused evaluation and you said no
23:24:43 <OmniSord> google is leaving me short handed, i must not be searching right...
23:25:10 <newsham> cs <- readFile "foo"    binds the result from readFile to the name x which can be used in other expressions later
23:25:22 <newsham> so that cs will be of type String
23:25:24 <mauke> roostaj: no, you asked if it evaluated the body
23:25:33 <mtnviewmark> OmniSord:      do { f <- readFile "foo.txt"; return someFuncOnStrings f; }
23:25:40 <mauke> roostaj: the guards themselves are evaluated, of course
23:25:42 <OmniSord> so i cant combine them?
23:25:55 <newsham> combine what?
23:25:57 <mtnviewmark> or      someFuncOnString `fmap` readFile "foo.txt"
23:26:36 <mtnviewmark> think of "IO String" as --- "there's a result in there, honest, but you have climb up inside IO to get at it"
23:26:44 <roostaj> mauke: yes, I know the guards are evaluated :D, but I don't see how length' doesn't overflow if (n+1) isn't evaluated
23:26:45 <OmniSord> newsham, lines and getFile
23:26:52 <OmniSord> ok, thanks
23:26:56 <mtnviewmark> now taking a pure function (String to String, say) and "lifting it up into IO" is easy
23:27:03 <newsham> you can use "cs" in any expressions in the do block following the bind
23:27:14 <mauke> roostaj: because n is evaluated at that point
23:27:23 <newsham> such as:   do { cs <- readFile "foo"; putStrLn (lines cs !! 2) }
23:27:24 <mauke> roostaj: so your thunk is only one level deep
23:29:21 <roostaj> mauke: Ah! I got it now, Thanks mauke
23:29:38 <mtnviewmark> OmniSord --- you might be interested in the function interact
23:29:39 <roostaj> mauke: I was about to be angry at Haskell if it was flipping evaluations on me
23:29:40 <mtnviewmark> :t interact
23:29:41 <lambdabot> (String -> String) -> IO ()
23:29:46 <roostaj> :D
23:30:22 <cybercobra> newbie Parsec problem - http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15576#a15576  thoughts?
23:30:40 <newsham> someone should make batch :: (String -> String) -> IO ()
23:31:18 <roostaj> @src length
23:31:19 <lambdabot> Source not found. Wrong!  You cheating scum!
23:31:50 <roostaj> :t length
23:31:51 <lambdabot> forall a. [a] -> Int
23:31:56 <newsham> length [] = 0; length (_:xs) = 1+length xs
23:32:48 <roostaj> newsham: :), that seems too slow to be the implementation of length
23:32:55 <dblhelix> newsham: any ambition for becoming a bot? :)
23:33:01 <newsham> cybercobra: how about breaking out some of the code as separate functions and adding type annotations to tell it what you think the type should be
23:33:02 <roostaj> lol dblhelix :D
23:33:08 <newsham> then it will complain at the place where you and it disagree
23:33:37 <newsham> rostaj: how is it supposed to be faster?  lists are O(n) to count length of
23:34:26 <Gracenotes> does it end up storing a series of 1+1+1+1+... on the heap?
23:34:30 <dblhelix> newsham, roostaj: you can make it stricter, of course
23:34:46 <roostaj> newsham: well I am suspicious because it has overflow issues
23:34:54 <mtnviewmark> cyberrcobra: I think you want      intChar = do { c <- oneof ['0'..'9']; optional (char '_'); return c }
23:34:57 <Gracenotes> iirc an accumulator version would avoid the issues
23:35:00 <dblhelix> newsham, roostaj: or just rely on the compiler to do so
23:35:36 <Gracenotes> len [] a# = I# a#
23:35:38 <Gracenotes> len (_:xs) a# = len xs (a# +# 1#)
23:35:58 <Gracenotes> but that's just implementation details, anyhow..
23:36:00 <roostaj> Gracenotes: i'm not familiar with the # symbol. What is it exactly?
23:36:18 <newsham> just char to let you know its builtin stuff
23:36:27 <newsham> unboxed I think?
23:36:41 <c_wraith> # doesn't mean unboxed by itself.
23:36:43 <lunabot>  luna: parse error on input `]'
23:36:54 <Gracenotes> here, using the unboxed version, where it doesn't check and pattern match int constructor
23:36:58 <newsham> # luna parses comments.  pass it on
23:36:59 <lunabot>  luna: parse error on input `|]'
23:37:13 <c_wraith> It's just that unboxed types tend to be named things that end with #
23:37:32 <cybercobra> mtnviewmark: ah, hadn't thought about putting it in the "lexer" like that...
23:37:37 <dblhelix> length' = len 0 where { len acc [] = acc ; len acc (_ : xs) = acc `seq` len (ac\
23:37:38 <dblhelix> c + 1) xs }
23:37:38 <c_wraith> > let q# = "foo" in reverse q#
23:37:40 <lambdabot>   "oof"
23:37:44 <Gracenotes> roostaj: you can ignore it, meaning the implementation of length in GHC: length list = len list 0 where len [] a = a; len (x:xs) a = len xs (a+1)
23:38:11 <newsham> with a strict +, right?
23:38:50 <Gracenotes> er, yeah, with the strictness. a bit closer to len (_:xs) a = let a' = a+1 in a' seq len xs a'
23:39:18 <roostaj> Gracenotes: ah, ok. You definitely want the (a+1) to be evaluated ASAP
23:39:25 <dblhelix> or: length' = foldl' (const succ) 0
23:39:36 <roostaj> does the compiler make those sorts of optimizations if you do it newsham's way?
23:39:57 <roostaj> :T const
23:39:58 <roostaj> :t const
23:39:59 <lambdabot> forall a b. a -> b -> a
23:40:04 <roostaj> @src const
23:40:04 <lambdabot> const x _ = x
23:40:10 <newsham> > const 3 100
23:40:11 <lambdabot>   3
23:40:18 <roostaj> just forces evaluation?
23:40:22 <Gracenotes> switching from foldr-like to foldl-like recursion isn't something the compiler can do by itself so much
23:40:22 <roostaj> err... wait
23:40:35 <dblhelix> er... length' = foldl' (flip const succ) 0 ... of course
23:40:44 <newsham> > (const succ "stuff") 1
23:40:45 <lambdabot>   2
23:41:15 <Gracenotes> foldr-like is newsham's version (the standard length definition that is nonetheless mighty spiffy), foldl-like is the accumulator version
23:41:27 <dblhelix> ength' = foldl' (flip $ const succ) 0 -- and now I'm awake
23:41:47 * roostaj throws dblhelix an "l"
23:41:49 <newsham> > foldl' (flip $ const succ) 0 "test"
23:41:50 <lambdabot>   4
23:41:56 <cybercobra> mtnviewmark: huzzah! thanks!
23:42:00 <mtnviewmark> welcome
23:42:19 <newsham> > foldl' (flip $ const succ) 0 (x:y:z:[])
23:42:20 <roostaj> :t foldr-like
23:42:20 <lambdabot>   3
23:42:21 <lambdabot> Not in scope: `like'
23:42:35 <roostaj> Gracenotes: is foldr-like a function?
23:42:36 <dblhelix> foldl' is the strict version of foldl
23:43:00 <newsham> > foldl' (flip $ const succ) x "test"
23:43:01 <lambdabot>   succ (succ (succ (succ x)))
23:43:31 <Gracenotes> it's recursion that can be expressed as a foldr. It basically means structural recursion on lists, whereas foldl means recursion with an accumulator
23:44:05 <newsham> gracenote is saying that my explicit recursion is equivalent to a foldr
23:44:33 <luqui> ISTR a paper comparing the expressive power of arrows vs. applicatives (vs. one more thing -- maybe monads?)  anybody remember what that is?
23:44:37 <newsham> i iterate w/ the illiterate and recurse w/ the worst
23:44:51 <roostaj> Gracenotes: newshame: gotcha
23:45:02 <Stalafin> when i call the function openTempFile, what would be the difference between passing it "." (my current directory) or the result of getCurrentDirectory ?
23:45:04 <roostaj> @src foldl
23:45:04 <lambdabot> foldl f z []     = z
23:45:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:45:06 <roostaj> @src foldl'
23:45:06 <lambdabot> foldl' f a []     = a
23:45:06 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:45:23 <roostaj> damn, i don't know seq yet
23:45:27 <roostaj> @src seq
23:45:27 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:45:34 <roostaj> @src (seq)
23:45:34 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:45:36 <roostaj> :(
23:45:40 <newsham> seq forces evaluation of something before returning the other thing
23:45:54 <newsham> its a way to manage the non-strictness
23:46:26 <newsham> so a' gets evaluated before returning the foldl' f a' xs
23:46:50 <roostaj> newsham: ah ok
23:46:51 <newsham> so if a' is  (2 + 1) it gets collapsed to 3 before recursing
23:47:16 <cybercobra> how does one debug a stack overflow when :trace and :history don't work in that circumstance?
23:47:25 <luqui> ah!  "Idioms are oblivious, arrows are meticulous, monads are promiscuous" by Lindley, Wadler, & Yallop
23:47:42 <newsham> wadler and his titles :)
23:48:22 <newsham> hows the language coming along, luqui?
23:48:42 <luqui> newsham, back burner
23:49:05 <luqui> newsham, following through with my new years resolution
23:49:13 <luqui> of writing my ideas as haskell modules and publishing them
23:49:33 <newsham> isnt that itself an idea?
23:49:52 <luqui> er... specifically the code ideas that i put on hold in order to research frp
23:50:00 <luqui> ironically i am writing an frp module atm :-P
23:50:15 <luqui> well, restricted subset.  trying to get Futures only
23:50:43 <luqui> I think Futures are arrows!
23:51:08 <newsham> luqui newyears = publish
23:51:37 <cybercobra> there's a light cone joke in there somewhere
23:53:03 <luqui> cybercobra, it would be relevant though.  the reason futures (or rather transformations on futures) should be arrows is precisely because of causality.  If Future a = (spacetime, a) instead of just Future a = (time, a), then the arrows would be transformations within a lightcone
23:53:11 <luqui> i have to shut up....
23:53:31 <luqui> getting excited.   channel into code, not chat.
23:54:49 <newsham> time flies like an arrow
23:54:54 <newsham> fruit flies like a banana
23:55:38 <luqui> oooh that second one is even more ambiguous :-)
23:55:54 <cybercobra> how does one debug a stack overflow when :trace and :history don't work in that circumstance?
23:57:50 <luqui> cybercobra, :set -fbreak-on-error doesn't break?
23:59:47 <cybercobra> luqui: I didn't know of that option (newbie here)
