00:07:43 <xerox> Cale also it's not enough to add a space before that, it also have to add spaces between subsequent broken lines
00:08:08 <xerox> ?quote kristnjov
00:08:08 <lambdabot> blackdog says:  <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was
00:08:08 <lambdabot> given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me
00:08:08 <lambdabot> still
00:08:24 <orgullocachanill>  It is time to put those Haitian jigaboos in their place!  No matter how many times the civilized world donates money, opens schools, rebuilds their nation, and holds their little monkey paws, the damn niggers can never get it right.  They never will!  The same goes for New Orleans!  Cancun in Mexico suffered few fatalities after their major hurricane, and the rebuilding is already completed.  What have the niggers in New Orlean
00:08:24 <orgullocachanill> s done?
00:08:24 <orgullocachanill>   If you are sick of this, join Chimpout Forum! http://www.chimpout.com/forum
00:08:32 <xerox> I banned you!
00:08:43 --- mode: ChanServ set +o xerox
00:09:00 --- mode: xerox set +b orgullocachanill!*@*
00:09:10 --- mode: xerox set +b *!*@ip72-207-23-78.sd.sd.cox.net
00:09:13 --- kick: orgullocachanill was kicked by xerox (orgullocachanill)
00:10:02 <ivanm> yay! lambdabot is back!
00:10:02 <lambdabot> ivanm: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:10:18 <medfly> basically, lambdabot needs to append a space before every line that goes out
00:10:37 <xerox> well said
00:10:47 <ivanm> wait, is this the _real_ lambdabot?
00:10:51 <medfly> yes
00:11:33 <ray> @quote ta
00:11:33 <lambdabot> Twey says: <idnar> O(1) is a lie anyway <Twey> I just can't stand the constant lies!
00:11:52 <medfly> hahaha
00:13:10 <xerox> :Ã¾
00:15:23 <DigitalKiwi> preflex doing notices is annoying :(
00:15:43 <DigitalKiwi> anyone know in irssi how to disable notices pinging me? or who to complain to that he is the worst irc bot ever
00:16:18 <xerox> what do you have /set hilight_level
00:17:34 <DigitalKiwi> 2:16 activity_hilight_level = MSGS DCCMSGS
00:17:35 <DigitalKiwi> 02:16 hilight_level = PUBLIC DCCMSGS
00:21:39 <koala_man> DigitalKiwi: the worst part is that it's technically correct. notice was always meant for automated replies
00:22:39 <DigitalKiwi> a lot of things are technically correct but that doesn't mean you should do stuff that way :(
00:23:34 * hackagebot upload: clientsession 0.2.0 - Store session data in a cookie. (MichaelSnoyman)
00:24:25 <djahandarie> I think the real issue is that the client won't differentiate between a notice sent to a channel and to the client specifically.
00:24:43 <djahandarie> Holy moley, it's 3:24
00:24:46 <djahandarie> Night folks
00:24:48 <DigitalKiwi> bai
00:25:20 <ivanm> no it isn't! it's only 6:24 PM!
00:25:21 <ivanm> ;-)
00:26:24 <DigitalKiwi> hmm 2:25...
00:27:01 <ivanm> morning or afternoon?
00:28:38 <DigitalKiwi> well afternoon would be 14:25 now wouldn't it ;p
00:28:54 <augur> ivanm: australia?
00:29:07 <ivanm> augur: for me, yes
00:29:22 <ivanm> of course, "/whois ivanm" would help you work that out...
00:29:24 <ezyang> If I wanted a "word for word" implementation of Python dict's, would Data.HashTable would be it?
00:29:25 <ivanm> @time augur
00:29:27 <lambdabot> Local time for augur is Sun Jan 31 03:29:04 -0500 2010
00:29:39 <ivanm> ezyang: Data.HashTable is there as an example about what you shouldn't do
00:29:40 <ivanm> ;-)
00:29:44 <ezyang> heh
00:29:53 <ivanm> ooohhhhh..... lambdabot's @time plugin is getting better
00:29:54 <ivanm> !
00:30:00 <ivanm> it now reports the timezone as well!
00:30:04 <ezyang> I'm trying to prove to myself that I can write Python in Haskell w/o having to do anything too tricky (except w.r.t. types)
00:30:06 <ivanm> (or is that just augur's client doing that?)
00:30:15 <ivanm> ezyang: IIRC, dictionary == Data.Map.Map
00:30:18 <augur> ivanm: sure, but how useful is it to whois you when i can GUESS! :D
00:30:22 <augur> its not my client, btw.
00:30:27 <augur> @time ivanm
00:30:29 <lambdabot> Local time for ivanm is Sun Jan 31 18:30:05
00:30:35 <ivanm> OK, so it's your client
00:30:44 <ivanm> augur: heh
00:30:45 <augur> what
00:30:45 <ezyang> ivanm: I'm embracing mutation in this exercise :-)
00:30:48 <ivanm> (about the guess)
00:30:48 <augur> no its not :|
00:30:50 <ivanm> @slap ezyang
00:30:50 * lambdabot karate-chops ezyang into two equally sized halves
00:31:02 <xerox> definitely mutated
00:31:09 <ezyang> kekeke
00:31:36 * hackagebot upload: yaml 0.2.0 - Low-level binding to the libyaml C library. (MichaelSnoyman)
00:33:37 * hackagebot upload: data-object-yaml 0.2.0 - Serialize data to and from Yaml files (MichaelSnoyman)
00:33:41 <DigitalKiwi> @time DigitalKiwi
00:33:45 <lambdabot> Local time for DigitalKiwi is Sun Jan 31 02:33:19 2010
00:33:57 <xerox> no timezone!
00:34:01 --- mode: xerox set -o xerox
00:34:14 <DigitalKiwi> what's it do if I have ctcp replies disabled?
00:34:28 <DigitalKiwi> fail or try to guess based on ip? that would be awesome
00:34:53 <ivanm> DigitalKiwi: it will quietly fail
00:35:02 <DigitalKiwi> :(
00:37:46 <rhz> has anyone noticed that haskell array index bounds aren't checked correctly at runtime?
00:38:09 <rhz> (in ghc 6.10.4)
00:38:44 <ivanm> AFAIK, they never were
00:38:48 <ivanm> especially if you use !
00:38:57 <ivanm> ! is not safe
00:42:56 <rhz> ok..
00:45:08 <rhz> is it not safe, or just weird?
00:45:40 <xerox> maybe the docs has something?
00:45:42 <xerox> ?docs
00:45:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
00:46:19 * ezyang is currently reading what's up with hash tables in Haskell and wincing 
00:48:56 * ksf thinks yhc's javascript backend is underused
00:48:57 <lambdabot> ksf: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:49:01 <ivanm> from memory, it doesn't do any checking
00:49:08 <ivanm> ksf: I thought it was unmaintained...
00:49:13 <ksf> it is
00:49:26 <ksf> ...it works, though.
00:50:25 <ezyang> Oh dude http://hackage.haskell.org/trac/ghc/ticket/650 yay
00:50:41 <ksf> ...which means that it's at least supported enough not to bitrot
00:50:50 <ksf> (or yhc is composed of fairy dust)
00:51:49 <ksf> the point, though, is that writing webapps in pure haskell is a very, very cool thing.
00:52:33 <ksf> ...and an xhtml dom isn't the worst gui interface one can come up with.
01:01:20 <ksf> oh, btw, cabal update is getting slow
01:01:32 <ksf> I think it's time to switch to rsync or such, before it becomes worse
01:02:00 <ksf> ...and worry about mirrors
01:02:17 <ksf> ...and while I'm at it, p2p cabal and haskell-torrent
01:02:35 <ksf> I'd like a pony, too.
01:04:21 <ivanm> ksf: IIRC, hackage has a pony package
01:04:21 <ivanm> ;-)
01:04:28 <ksf> I know
01:04:35 <ksf> but it's an unicorn
01:04:48 <copumpkin> it was made for me
01:04:49 <copumpkin> it's mine!
01:05:23 <ivanm> copumpkin: then take your toy away from there if you don't want to share!
01:05:35 <copumpkin> I can't take it off
01:05:40 <copumpkin> or I would!
01:05:48 <ivanm> heh
01:05:51 <ivanm> blame dons
01:06:31 <ksf> meh http://github.com/tibbe/event 's configure lacks an input file
01:09:44 <ksf> oh. I should run autoheader, too.
01:10:30 * ksf wonders whether autohell or intercal is the worst gnu thing ever.
01:10:47 <ksf> ...well, actually that'd be emacs.
01:10:52 <jrockway> so i'm looking at this ac-easyraster-gtk module
01:10:59 <jrockway> and it has haddock, but hackagedb didn't seem to build it
01:11:06 <jrockway> if i run "cabal haddock", it is generated perfectly
01:11:13 <jrockway> anyone know what would cause that to happen?
01:12:00 <ksf> cabal-setup: At least the following dependencies are missing:
01:12:00 <ksf> base >=4 && <5 && <4, gtk ==0.10.*
01:12:39 <ksf> erm
01:12:43 <ksf> that doesn't make sense
01:12:55 <ksf> >= 4 && < 4
01:13:16 <ksf> ...anyway, it won't build because hackage can't build gtk
01:13:21 <ivanm> hmmm...
01:13:38 <jrockway> interesting
01:13:46 <jrockway> so no docs if a dependency can't install?
01:13:52 <ivanm> jrockway: gtk2hs isn't cabalised, so hackage doesn't know anything about it
01:14:00 <ivanm> though I would think dcoutts would just install it there...
01:14:04 <ksf> I suppose it could build the docs
01:14:13 <ksf> ...if that's possible without configuring
01:14:23 <jrockway> it is, but not via "cabal haddock"
01:14:50 <jrockway> at least i now know, "no docs on hackagedb" doesn't necessarily mean "no docs anywhere"
01:15:42 <ksf> it'd certainly be nice if hackage would link to the source when it can't build docs
01:16:09 <jrockway> yeah
01:16:09 <Saizan> @tell luqui there's Buildable: False
01:16:09 <lambdabot> Consider it noted.
01:16:27 <jrockway> i hate having to "cabal unpack" just to glance at the source code
01:16:33 <jrockway> cpan does not make me do that ;)
01:17:48 <Saizan> patches welcomed as always, i think :)
01:17:49 <ivanm> jrockway: ummmm.... how do you look at large perl programs then?
01:18:26 <jrockway> there is a point between "i wonder what this does" and "i'm going to hack on it"
01:18:54 <jrockway> and at some point, sure, you unpack to disk somewhere, and poke with your editor
01:19:02 <jrockway> but that point is after you take a look to see what the module does
01:19:15 <ivanm> jrockway: yes, but you still haven't answered my question
01:19:26 <ivanm> how are you meant to glance at the source code without unpacking it?
01:19:33 <jrockway> i click the links on the web page
01:19:41 <ivanm> jrockway: *cough* hackage *cough*
01:20:00 <jrockway> did you read any of the conversation before you started talking?
01:20:11 <jrockway> i am talking about a case where hackagedb failed to create the docs
01:20:13 <jrockway> even though they existed
01:20:15 <ivanm> aha
01:20:29 <jrockway> someone else mentioned "it would be nice if it generated links to the source code in that case"
01:20:30 <ivanm> jrockway: HackageDB-2 should help
01:20:32 <jrockway> i agreed
01:20:37 <ivanm> since people can upload docs if the build failed
01:20:47 <jrockway> excellent
01:20:55 <jrockway> i mean, i *can* unpack and generate the docs myself
01:20:59 <jrockway> but it does take additional effort
01:21:05 <ivanm> I think the problem with that proposal (building source links) is that the way hscolour integration is currently set up is that you can only reach it via haddock
01:21:30 <jrockway> makes sense
01:21:43 <jrockway> i found it weird when generating docs for my own app that it missed some modules when generating index.html
01:21:46 <abccc> hello, what is the best way to parse a String like "ab.de.ef" into my datatype - dt String String String
01:21:50 <jrockway> but it did actually generate the HTML for them
01:22:01 <aavogt> @hackage split
01:22:01 <lambdabot> http://hackage.haskell.org/package/split
01:22:11 <ivanm> agreed
01:22:15 <ivanm> (to aavogt)
01:22:37 <ivanm> abccc: actually, a better way would be to use polyparse, parsec or one of the other parsing libraries ;-)
01:23:09 <QtPlatypus> ivanm: sounds like overkill
01:23:31 <jrockway> it does, but writing a parser does not involve more than a line of code in many cases, and it offers potentially more robust results
01:23:35 <ivanm> QtPlatypus: he did say _parse_ ;-)
01:23:58 <abccc> thx... I take a look at split.. seems to be the easiest solution ;)
01:24:01 <ksf> jrockway, only exposed modules are linked
01:24:15 <ksf> ...you can reach the rest via the other pages, then.
01:24:26 <jrockway> hmm
01:24:30 <jrockway> i don't think i could in my case
01:24:40 <jrockway> although obviously i could just go to the directory listing and click as appropriate :)
01:30:13 <Saizan> it'd be nice if hscolour made identifiers link to their definition
01:30:41 <ksf> an xhtml interface that works both with the browser's native dom when compiled to js and "statically" on the server side would be cool
01:30:43 <Saizan> the problem is that it'd need to really parse the thing, and that would break if the source isn't just haskell
01:31:43 <jrockway> yeah
01:31:55 <jrockway> i am not used to expecting that much from a syntax-highlighter
01:32:02 * Saizan is
01:32:09 <jrockway> so even if it broke horribly on some inputs, i would be thankful for the times it worked ;)
01:32:13 <Saizan> i've been spoiled by Agda
01:32:35 <jrockway> i think even java does that (*shudder*)
01:32:46 <ksf> it's one of the reasons why ghc's parser should be extendable
01:32:58 <jrockway> i would say i'm jealous of java programmers for its advanced static analysis libraries
01:33:02 <Saizan> maybe we could try parsing and fall back on just highlighting if it fails
01:33:04 <aavogt> haskell-src-exts?
01:33:06 <jrockway> but ... it's java, so i'm not :)
01:33:10 <ksf> jrockway, have a look at hare
01:33:24 <jrockway> oh, interesting
01:33:24 <Saizan> aavogt: that breaks on e.g. .chs
01:33:46 <ksf> ...or ixdopp
01:34:10 <Saizan> does hare use the new haskell-src-exts ?
01:34:24 <ivanm> Saizan: not yet
01:34:30 <ivanm> I suggested it to Simon Thompson though
01:34:35 <ivanm> they're going to compare it to ghc's parser
01:34:48 <ivanm> the problem IIRC is that hsx doesn't provide enough contextual parsing information
01:34:51 <Saizan> ah, it's using ghc parser currently?
01:34:58 <ivanm> nope
01:35:02 <ivanm> programatica
01:35:10 <ivanm> which only accepts H98
01:35:13 <Saizan> k
01:35:16 <ivanm> hence why hare sucks for modern haskell code
01:36:02 * Saizan wonders if someone has solved the problem of having extensible parsers
01:36:13 <TwMadCow> why can't I understand functional programming :'(
01:36:22 <jrockway> because there is nothing to understand
01:36:24 <jrockway> you have functions
01:36:25 <ivanm> TwMadCow: because you don't understand functional programming
01:36:26 <jrockway> you pass them values
01:36:28 <jrockway> they return a value
01:36:32 <jrockway> that's it.
01:36:47 <medfly> TwMadCow, ask a better question
01:37:05 <TwMadCow> why can't I think in functional programming terms
01:37:14 <jrockway> heh
01:37:16 <Saizan> TwMadCow: you lack experience
01:37:20 <jrockway> is there something specific that's bothering you?
01:37:21 <ivanm> exactly
01:37:30 <medfly> TwMadCow, what are you trying to do?
01:37:33 <Saizan> TwMadCow: a way to gain it is to read some good functional code
01:37:44 <jrockway> try thinking about a few functional "problems" from start to finish, and you'll find you'll be more able to understand it in general
01:37:45 <Saizan> TwMadCow: like e.g. the core of xmonad
01:37:50 <TwMadCow> whenever somebody mentions "maps" or "do" my brain closes and thinks "for loop"
01:37:53 <RichardO> And don't just read functional code. Understand it.
01:38:12 <theorbtwo> TwMadCow: Don't think about "do" for a while.
01:38:13 <medfly> TwMadCow, I learnt Haskell mostly by re-writing some of the functions, like map, fold, etc.
01:38:24 <jrockway> the first step is identifying the problem, the second step is making the necessary changes to your way of thinking
01:38:31 <jrockway> for is a control structure, map is a function
01:38:38 <Saizan> TwMadCow: implement your for loops via recursion then :)
01:38:39 <jrockway> forget control structures and think about functions
01:38:51 <medfly> TwMadCow, I saw this one implementation, and tried to implement another function which is pretty similar, using similar techniques.
01:39:18 <TwMadCow> what's a good book that introduces functional programming
01:39:28 <TwMadCow> i've tried reading haskell books but they assume you already know functional programming
01:39:32 <medfly> @where lyah
01:39:32 <lambdabot> http://www.learnyouahaskell.com/
01:39:35 <jrockway> does RWH?
01:39:39 <medfly> this one seems to assume you know imperative programming.
01:39:44 <Saizan> the nice thing about laziness and functional programming is that you can implement your control structures simply as functions
01:39:56 <jrockway> exactly
01:40:05 <jrockway> there is no magic provided by the langauge (*), everything is just functions
01:40:14 <jrockway> (*) ok, there's some magic, but you can ignore it :)
01:40:18 <theorbtwo> jrockway: I'm not sure I'd go that far.
01:40:39 <ksf> map in scheme is quite like a for loop, but in haskell it's more like a generator that polls another generator
01:40:43 <TwMadCow> are people over exaggerating when they say learning functional programming changed the way they think?
01:40:43 <theorbtwo> Do is a nicer syntax around some function calls, which is why I suggested ignoring it for a while.
01:41:02 <ksf> ...in the end, thinking "for loop" isn't wrong at all, if "for loop" means "do one thing to each element"
01:41:03 <Saizan> "everything is just functions" means quite little so it's not really falsifialbe :)
01:41:03 <jrockway> TwMadCow: not really
01:41:13 <jrockway> it helps many people think about programs in terms of operations on data
01:41:19 <jrockway> rather than mechanical application of for loops
01:41:28 <ksf> TwMadCow, otoh, you could meditate about fmap
01:41:34 <jrockway> Foo -> Bar instead of "loop from 1 to 10 on $foo, then calculate f(foo[$i]), ..."
01:41:38 <medfly> TwMadCow, Haskell introduces a lot of cool things.
01:41:48 <ksf> ...noting that "map" and "." are the same
01:42:09 <TwMadCow> well I am very excited to say the least
01:42:16 <theorbtwo> :t .
01:42:17 <lambdabot> parse error on input `.'
01:42:19 <medfly> TwMadCow, I find that it is a language whose users seem to constantly find patterns in code that they are writing and generalising that, and coming up with something really powerful like that.
01:42:21 <ksf> > toUpper . "amazing, ain't it?"
01:42:23 <lambdabot>   "AMAZING, AIN'T IT?"
01:42:24 <medfly> :T (.)
01:42:26 <theorbtwo> :t (.)
01:42:26 <medfly> :t (.)
01:42:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:42:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:42:31 <medfly> hehe
01:42:34 <TwMadCow> and learnyouahaskell.com sounds like exactly what I needed
01:42:34 <medfly> :t (Prelude.)
01:42:35 <lambdabot> Not in scope: data constructor `Prelude'
01:42:38 <medfly> :t (Prelude..)
01:42:40 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
01:43:02 <jrockway> what module is this (.) in?
01:43:05 <jrockway> control.arrow?
01:43:11 <ksf> prelude
01:43:11 <medfly> it's fmap
01:43:14 <ksf> @src (.)
01:43:14 <lambdabot> (f . g) x = f (g x)
01:43:14 <Saizan> TwMadCow: after a while writing idiomatic haskell i got quite shocked by some normal imperative programming i had to do, so i guess it really changed my way of thinking :)
01:43:22 <medfly> :t fmap
01:43:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:43:28 <jrockway> my prelude does not have it typed that way
01:43:32 <TwMadCow> Does anyone here use haskell at work?
01:43:33 <jrockway> (.) :: (b -> c) -> (a -> b) -> a -> c
01:43:35 <jrockway> TwMadCow: yes
01:43:59 <medfly> TwMadCow, I think that a lot of time when I write imperative code I can repeat the same thing a lot of time without even noticing it
01:44:05 <jrockway> i use it for data munging, at a large company you have probably heard of :)
01:44:36 <TwMadCow> microsoft/ibm :P
01:44:43 <TwMadCow> or google..
01:44:54 <ksf> TwMadCow, do you understand how (Functor f) => (a -> b) -> f a -> f b  can be specialized to (b -> c) -> (a -> b) -> a -> c ?
01:44:56 * hackagebot upload: elerea 1.2.3 - A minimalistic FRP library (GergelyPatai)
01:44:58 <c_wraith> I use it for web services at a company you probably haven't heard of...  Though you've heard of our customers.
01:45:21 <TwMadCow> I work on games some of you may have played..
01:45:21 <ksf> ...or, fwiw, (a -> b) -> [a] -> [b]
01:45:29 <TwMadCow> if i even mention haskell at work my manager will eat me :P
01:45:48 <jrockway> probably because you have a lot of existing C/C++ libraries that you don't want to throw away?
01:45:54 <jrockway> incidentally, haskell has a very nice FFI
01:46:03 <jrockway> that is why i'm using it at work, incidentally
01:46:10 <ksf> it's also a very nice systems language
01:46:10 <theorbtwo> For what it's worth, I'm attempting to learn haskell to get some of that mind-altering goodness, and not seeing terribly much of it, for what it's worth.
01:46:21 <c_wraith> even though tim sweeney has strongly argued for a language with many of haskell's features in gaming?
01:46:21 <jrockway> writing code in C/C++ is too unsafe, but sometimes we need to use C/C++ libraries (that are sometimes windows-only)
01:46:25 <theorbtwo> Er, feel free to delete one of those redundant clauses...
01:46:28 <jrockway> haskell is the solution :)
01:46:45 <ksf> c_wraith, yep.
01:46:51 <jrockway> theorbtwo: interesting
01:47:00 <ksf> things like lazy IO are a killer, though, but we know that...
01:47:20 <theorbtwo> jrockway: Part of that, I think, is that I tend to write my perl in a reasonably functional style.
01:47:25 <jrockway> i bring this up a lot, but i am still amused at structures like application vs. fmap
01:47:28 <jrockway> foo $ x
01:47:28 <jrockway> foo <$> xs
01:47:45 <jrockway> (and this is generalized, i guess to (.) for all "categories")
01:48:00 <jrockway> theorbtwo: yeah
01:48:04 <TwMadCow> I'll start on learnyouahaskell.com so I can know what you guys are talking about :P
01:48:05 <c_wraith> . is not $ for functions
01:48:06 <Saizan> theorbtwo: it doesn't happen automatically, for example i've written in prolog for quite a while like if it were a borked functional language and as a result i didn't really realize what the paradigm was about
01:48:14 <jrockway> c_wraith: i know
01:48:25 <theorbtwo> Hm, why does ghci not like :t <$> or :t (<$>) -- is it a special form?
01:48:32 <jrockway> no
01:48:36 <jrockway> but it needs parens when not infix
01:48:39 <jrockway> :t (<$>)
01:48:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:48:43 <Saizan> theorbtwo: you've to import Control.Applicative
01:48:45 <c_wraith> theorbtwo: is it not imported?
01:48:47 <ksf> theorbtwo, it's in Control.Applicative
01:48:48 <ivanm> TwMadCow: for haskell for games, IIRC the guy from id studios did this big thing about why languages like Haskell are the future...
01:48:51 <Saizan> then :t (<$>) works
01:48:52 * jrockway can't read. :)
01:48:59 <theorbtwo> Saizan, c_wraith, ksf: Makes sense, thanks.
01:49:00 <c_wraith> ivanm: that was tim sweeney from unreal
01:49:08 <c_wraith> err, from epic, of unreal fame
01:49:15 <aavogt> (<$>) is an expression, while <$> isn't without arguments on both sides
01:49:16 <ivanm> c_wraith: yeah, that's the one
01:49:26 <ivanm> c_wraith: I don't play enough games to care really ;-)
01:49:29 <ivanm> especially new games
01:49:36 <aavogt> I dunno why   :info <$> -- is the way it's done
01:50:04 <c_wraith> ivanm: ok then.  epic of zzt fame.  :)
01:50:04 <aavogt> I guess it's to be consistent with fixity declarations
01:50:13 <ivanm> c_wraith: heh
01:50:19 <ivanm> never heard of zzt either...
01:50:20 <aavogt> and also, info doesn't take expressions...
01:50:21 <Saizan> well, :info doesn't accept expressions anyhow
01:50:21 <jrockway> theorbtwo: so i guess what i got out of haskell, is learning how everything is the same
01:50:26 <ivanm> (unreal, however, I _have_ heard of)
01:50:28 <ivanm> Saizan: sure it does
01:50:36 <ivanm> it just tries to give you info on each part of the expression...
01:50:43 <c_wraith> zzt was a popular series in the early 90s shareware games. :)
01:51:08 <Saizan> ivanm: uh? :info 1 + 2 doesn't seem to work
01:51:25 <aavogt>  :info a b c -- does three at once
01:51:33 <theorbtwo> Aaah, zzt was *awesome*, and I'm really showing my age, it seems.
01:51:38 <ivanm> Saizan: hmmm.... I typically do stuff like ":info foo bar" (where foo and bar are entities in my code)
01:51:43 <ivanm> aavogt: yeah
01:51:58 <theorbtwo> ...and I can certianly seethe connection; one of the most interesting things about zzt was it's programming language.
01:51:58 <Saizan> it's more like it parses each identifier by itself
01:52:23 <Saizan> :info map id [] Read <- works, and it's not a valid expression
01:52:33 <solrize> "I am utterly frustrated with the software I have to deal with. Windows is beyond comprehension! UNIX is no better. DOS is no better. There is no reason for an OS. It is a non-thing. Maybe it was needed at one time."
01:53:04 <jrockway> unix is better than windows :)
01:53:15 <jrockway> it's just that neither are good
01:53:17 <ksf> indeed
01:53:24 <ksf> all that's needed is the ghc rts
01:53:37 <solrize> "I would like a floppy, one meg is enough. It would have a 10K program and the rest is data. When it boots it gets into memory and is ready for operation while the rest of memory is loaded. It should start in a second or two. You don't want to do this on your hard disk and turn it into a dedicated machine."
01:53:53 <solrize> those were both supposed to be for haskell-blah, but what the heck ;)
01:54:13 <jrockway> i assume this is a blog post somewhere?
01:54:21 <solrize> http://www.ultratechnology.com/moore4th.htm
01:54:32 <ksf> coreboot boots in less than a second or two...
01:54:42 <medfly> I know you can make websites with Haskell, but how unusual is it to find a server that is usually used to hold websites that can manage it?
01:54:49 <theorbtwo> Yey, the old floppy-flipping OS.
01:54:49 <solrize> he says he wrote his CAD package with no loops... turns out he uses something like replicateM_
01:55:01 <theorbtwo> That was *great*, before I had a hard drive.
01:55:04 * theorbtwo ducks.
01:55:40 <theorbtwo> No loops, to my way of thinking, isn't something to aspire to, nor something that is pratical.
01:55:43 <solrize> there is some kind of great idea in it but i can't quite figure out what it is
01:55:59 <ksf> even with a hard drive, I had at least 4 different boot options in my config.sys to be able to play every game and use all the hardware
01:56:02 <ksf> (not at the same time)
01:56:03 <solrize> theorbtwo, it's like writing in haskell with no recursion, just do everything with folds :)
01:56:09 <theorbtwo> ...but that's partly because I see the truth, which is that map is a loop, a control structure, and a function.
01:56:21 <theorbtwo> solrize: But folds are recursion!
01:56:35 <medfly> isn't map recursive rather than iterative?
01:56:38 <medfly> ? :o
01:56:46 <aavogt> @quote recursion
01:56:46 <lambdabot> mmorrow says: [regarding excessive use of categorical recursion schemes] a morphasm?
01:56:49 <jrockway> a loop is just a control structure built on top of recursion
01:57:00 <jrockway> map is another control structure built on top of recursion
01:57:02 <jrockway> as is fold
01:57:11 <ksf> map doesn't really imply an order, or any other operational semantics
01:57:13 <c_wraith> recursion and iteration aren't fundamentally different.  I don't see a reason to think of them as something different
01:57:18 <theorbtwo> A loop is a control structure that involves doing something more then once.
01:57:18 <aavogt> @quote goto
01:57:18 <lambdabot> DonaldKnuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
01:57:18 <lambdabot>  might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
01:57:24 <jrockway> ksf: good point
01:57:38 <jrockway> it's good to decouple implementation from your mental model of a function
01:57:42 <theorbtwo> Recursion and iteration are implementaiton details.
01:57:45 <jrockway> fmap is just "apply a function inside a functor"
01:57:47 <ksf> ...in fact, you'll find that if you only request one element, the mapped function only gets applied once.
01:57:47 <medfly> I think of recursion as having a bit of stuff which is not passed with the function, which is hidden. it is the result of seeing SICP as the bible of definitions.
01:57:48 <jrockway> for lists, this is a lot like a loop
01:58:08 <jrockway> i don't think fmap in general could be implemented with only looping though :)
01:58:27 <medfly> SICP SAID SO!
01:58:37 <ksf> recursion is a thing that belongs to syntax, not semantics.
01:58:46 <ksf> it's there to make infinite concepts expressible.
01:58:50 <jrockway> (also, yay for graphics.easyraster.gtk. i don't think i have ever written a computer program that output an image, and doing so only took like 5 lines of code!)
01:58:54 <ksf> ...by itself, it doesn't do a thing.
01:58:59 <solrize> is FORTH just insane???
01:58:59 <theorbtwo> jrockway: Any recursion can be rexpressed as a loop, I think.
01:59:09 <gmux> no
01:59:16 <medfly> the other way around
01:59:20 <medfly> any loop can be expressed as a loop
01:59:22 <solrize> "In Classic Forth we used
01:59:22 <solrize> IF ELSE THEN
01:59:22 <solrize> And I have eliminated ELSE.
01:59:22 <solrize> I don't see that ELSE is as useful as the complexity it introduces would justify"
01:59:34 <gmux> any loop can be expressed as recursion, but not the other way around
01:59:38 <medfly> not so bad
01:59:45 <jrockway> if x == 42 then foo, if x != 42 then bar
02:00:07 <solrize> "About a thousand instructions seems about right to me to do about anything. To paraphrase the old legend that any program with a thousand instructions can be written in one less. All programs should be a thousand instructions long."
02:00:20 <ksf> gmux, it can, if you have a stack to push stuff onto.
02:00:20 <gmux> I believe the ackermann function would be the classical example of a recursive function that you can't write with loops/iteration alone
02:00:36 <ksf> ...I've done that more than once in assembly code.
02:00:44 <medfly> but if then else is far from complicated;)
02:00:51 <gmux> ksf: then you're essentially reimplementing recursion so that it doesn't blow up because your language can't do it
02:01:34 <theorbtwo> gmux: I didn't say that it was the best way to write everything -- far from it.
02:01:40 <Saizan> loop + stack = recursion; when you write a recursive definition that's equivalent to a loop, good compilers remove the stack :)
02:02:21 <Saizan> this is operationally speaking
02:02:30 <gmux> theorbtwo: sure, but it is an important result from CS that general recursion is strictly more expressive than loops/iteration
02:02:36 <Saizan> when you write recursive code you shouldn't think about how it unfolds
02:02:45 * ksf really likes the idea of tibbe's event lib
02:02:52 <Saizan> you should just trust the inductive step
02:03:21 <c_wraith> ksf: I caught his presentation on it at galois
02:03:28 <medfly> if I write a Haskell website, will it be hard for me to find some webserver host willing to run it?
02:04:10 <ksf> ...most IO stuff should be event-based
02:04:29 <ksf> and unified into a common structure
02:04:36 <ksf> like, e.g. inotify
02:05:09 <Saizan> medfly: you can make it work as a [fast]cgi application, that should be supported on most hosts
02:05:14 <solrize> medfly, you'd use a vhost
02:05:23 <Saizan> medfly: otherwise you need a virtual machine or something
02:06:06 <medfly> ?
02:06:15 <medfly> what?
02:06:19 <medfly> why a virtual machine?
02:06:33 <c_wraith> or a real machine, but virtual ones are cheaper to rent, generally
02:06:42 <Saizan> well, you'd need an host that let you run your own server
02:10:20 <medfly> oh, okay... thanks
02:11:52 <gmux> set up a small restart time though; GHC's GC never returns memory to the OS so the fastcgi processes are likely to grow indefinitely
02:12:25 <ksf> er no
02:12:46 <ksf> it's not like memory isn't reused
02:13:02 <ksf> ...it's just that ghc holds onto it even if it isn't needed, anymore
02:13:10 <gmux> memory is reused by the GC but the process size keeps growing because it's not returned to the OS ever
02:13:18 <gmux> this is exactly what I've been saying :->P
02:13:24 <sizur> :i throw
02:13:40 <ksf> ...iff your process doesn't run in aproximately constant space
02:13:45 <Saizan> it doesn't necessarily keep growing
02:13:55 <medfly> sounds horrible
02:13:59 <medfly> anything else I should be made aware of?
02:14:04 <medfly> :)
02:14:06 <sizur> :t throw
02:14:07 <lambdabot> Not in scope: `throw'
02:14:08 <gmux> I think it is and it's supposed to be fixed maybe for 6.14
02:14:18 <gmux> I also think it is an underestimated problem
02:14:23 <sizur> :t Control.Exception.throw
02:14:24 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
02:14:27 <ksf> it's only a problem if you need a huge amount of ram at startup, _and_ have to run other processes that want the same ram.
02:14:47 <ksf> medfly, you can vote for the bug by cc'ing yourself to the ticket
02:15:01 <medfly> o.O?
02:15:04 <sizur> dowsn't throw break referencial transparency?
02:15:09 <Saizan> gmux: suppose your process uses memory M at some time, then drops to N < M, and needs more memory again, it can still use M - N memory to fill its needs without asking more memory to the OS
02:15:24 <medfly> I am just wondering if it is a good idea to write something in Haskell or use PHP. (I know this makes you shudder.)
02:15:34 <ksf> sizur, depends
02:15:34 <gmux> Saizan: yes I know
02:15:42 <ksf> or, actually, it doesn't.
02:15:51 <whoppix> interestingly, many language seem to take that route - most scripting languages like perl, ruby, python and co. don't ever seem to return memory either.
02:15:51 <ksf> still, exceptions are evil and shouldn't be used.
02:16:18 <medfly> hah. and we laugh at those C/C++ programs and their memory leaks.
02:16:19 <ksf> php might be a viable choice if you need a preprocessor
02:16:29 <ksf> but then, you could just use a sane one.
02:16:30 <sizur> i'm wondering why throwing exceptions by pure code made it into the standard library....
02:17:02 <jrockway> to avoid cluttering up the type signatures, probably
02:17:10 <ksf> there have to be some exceptions because haskell isn't total
02:17:19 <jrockway> "head :: [a] -> a" is easier to talk about in classes, etc.
02:17:20 <Saizan> because we live in a world of partial functions anyhow
02:17:24 <ksf> ...and people want to be able to call head on empty lists, for some reason.
02:17:25 <medfly> ok , thanks for the info
02:17:27 <jrockway> rather than "head :: [a] -> Maybe a"
02:17:37 <Saizan> so instead of just recursing forever you can be more informative with an exception
02:17:38 <jrockway> because now what do you do with this "nothing"
02:17:46 <jrockway> how do you weave Just x into the next computation?
02:17:47 <jrockway> etc.
02:18:00 <jrockway> we know the answer, but it might not be what you want to start Haskell 101 with
02:18:31 <sizur> so instead we make it implicit.  sounds like a million and a one thing to keep in mind by coder
02:18:37 <Saizan> head :: [a] -> Maybe a is useless anyhow
02:18:47 <Saizan> just pattern match on the list at that point :)
02:19:17 <gmux> ksf: it is also a problem if your haskell code needs some significant amount of memory at specific & rare times; your haskell processes would still hang onto that memory that could be better used elsewhere
02:19:49 <Saizan> sizur: throwing exceptions from pure code should be done only in the cases where a programming error occurred, not as a way to report errors
02:20:20 <ksf> gmux, yes, but so far noone complained loud enough for the bug to have a high priority
02:20:22 <Saizan> sizur: e.g. when the programmer violated some precondition of the function, not when some network problem occurred
02:20:24 <sizur> Saizan: i fail to discern
02:20:46 <ksf> generous swap space is also a way to fix the problem
02:20:49 <sizur> well network problem is IO, so cannot be pure :P
02:20:54 <Saizan> sizur: or when a parse failed.
02:21:06 <ksf> IO is pure
02:21:11 <ksf> unless you use unsafePerformIO
02:21:13 <sizur> yeah right
02:21:27 * gmux ponders going to read some more data structures stuff on wikipedia for his tuesday technical interview with google
02:21:40 <sizur> pure with closed eyes and ears :)
02:21:59 <nlogax> i can't hear you over all this purity
02:22:05 <Saizan> IO doesn't violate referential transparency
02:22:19 <Saizan> still when we talk about "pure code" we mean IO-free one
02:22:20 * gmux intends to introduce haskell into google discreetly so that it's too late when they realize it
02:23:13 <Saizan> they are probably already using it for something
02:23:23 <sizur> do you mean referencial transparency where we simply ignore the sideeffects?
02:23:26 <gmux> yeah I guess so, but more would be cool
02:23:51 <Saizan> sizur: no
02:24:37 <sizur> if i have main :: IO () -- no matter what main does, it always evaluates to IO (), but the sideffects can be different with each run though
02:24:50 <Saizan> sizur: you just have to realize that do x <- getLine doesn't means x is equal to getLine, let x = getLine means that
02:25:14 <Saizan> sizur: main evaluates always to the same IO action
02:26:24 <Saizan> IO () can be thought of as an AST that expresses side effects
02:27:25 <Saizan> so, yeah, you don't have side-effects in the evaluation of haskell code, in this context, they are executed by the RTS interpreting your action
02:27:29 <sizur> I guess i'm wierd in thinking that a pure code to which i cannot pass exactly the same state of the world twice is not really a pure code.
02:28:23 <solrize> well if you have a way to capture the state of the world in a variable...
02:28:26 <Saizan> that thing about the State RealWorld doesn't really hold itself to reality
02:28:32 <solrize> or, think of it as linear typing
02:29:09 <Saizan> because you can't capture the world as a value of your language
02:29:23 <ksf> ...but "readLine" isn't a function. it's a token in a language that's used to talk to the os. it's not part of "core haskell"
02:31:07 <Saizan> the nice way is that you can pass these ASTs around and build your own control structures :)
02:32:55 <sizur> but to get back to head function.  in production code you need to account for empty list, so either paternmatch on Maybe or catch exception.  dont we prefer type signatures expressing what function does?
02:33:03 <Daerim> Hey haskell channel...
02:33:14 <Saizan> sizur: yeah, head should never be used in production code
02:34:11 <ksf> oh, and don't catch the exception
02:34:12 <sizur> should we have a two-column page where left is playfull function and right is serious?
02:34:23 <aavogt> sizur: you might have invariants that say your list is nonempty...
02:34:24 <ksf> that's fixing a bug and introducing a new one.
02:34:25 <Saizan> unless for some weird reason you end up writing code like "if null xs then .. else .. (head xs)"
02:34:59 <Saizan> even if you have invariants i'd use something that reports a more useful error if that invariants ever gets broken
02:35:04 <sizur> head is just an example
02:35:24 <ksf> one should, in general, keep things as total as possible.
02:35:25 <aavogt> but the better way to write that is:   case xs of [] -> ... ; hd:tl -> ....
02:36:07 <aavogt> @type listToMaybe
02:36:08 <lambdabot> forall a. [a] -> Maybe a
02:36:47 <Daerim> if I wanted to read an int of a bytestring, how would I go about it? binary package and getWord32 might be involved I image, but how do I convert the word32?  toInteger?
02:36:56 <Daerim> *I imagine
02:37:02 <ksf> uncons :: a -> (b -> [b] -> a) -> [b] -> a
02:37:29 <ksf> :t fromIntegral
02:37:30 <Saizan> Daerim: fromIntegral
02:37:30 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:37:40 <Saizan> however bytestring has a readInt too
02:37:43 <Saizan> ?type readInt
02:37:44 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
02:37:51 <Saizan> ?hoogle readInt
02:37:51 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
02:37:52 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
02:37:52 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
02:38:09 <ksf> that's ascii, isn't it?
02:38:30 <sizur> so am i right to think that throw was introduced as a better evil than error?
02:38:30 <Saizan> oh, right
02:38:39 <ksf> also known as bulat's thorn?
02:38:48 <Daerim> Ohh, right. Thank you :)
02:38:51 <Saizan> ksf: hehe
02:39:15 <Daerim> @faq can haskell help me cure cancer?
02:39:15 <lambdabot> The answer is: Yes! Haskell can do that.
02:39:21 <Daerim> excellent
02:39:57 <Saizan> sizur: yeah
02:40:50 <tensorpudding> @botsnack
02:40:50 <lambdabot> :)
02:40:53 <tensorpudding> :)
02:41:57 <nus> @seen unseen
02:41:58 <lambdabot> Unknown command, try @list
02:42:17 <ivanm> nus: the seen plugin is gone
02:42:25 <ivanm> use "preflex: seen" instead
02:42:26 <ivanm> e.g.
02:42:29 <ivanm> preflex: seen unseen
02:42:29 -preflex(~preflex@95-88-118-220-dynip.superkabel.de)- Sorry, I haven't seen unseen
02:42:39 <nus> preflex, help
02:42:39 -preflex(~preflex@95-88-118-220-dynip.superkabel.de)- try 'help help' or see 'list' for available commands
02:43:00 <Mortomes> Could that bot please *not* use notice?
02:43:05 <ivanm> Mortomes: no
02:43:47 <sizur> what's the latest on HaXml vs hxt?
02:44:43 <ksf> last time I needed xxml I went for haxml, as I had a dtd
02:47:45 <nus> dcoutts, ping
02:48:43 <ivanm> preflex: seen dcoutts
02:48:43 -preflex(~preflex@95-88-118-220-dynip.superkabel.de)- dcoutts was last seen on #haskell 3 days, 1 hour, 7 minutes and 2 seconds ago, saying: kamatsu: since it's not on hackage
02:49:54 <nus> ivanm, yep, thank you, did that already
02:50:35 <ivanm> just indicating the general unlikelihood of dcoutts responding to your ping, that's all
02:50:37 <ivanm> @time dcoutts
02:50:38 <lambdabot> Local time for dcoutts is Sun Jan 31 10:50:15
02:50:39 <Zao> http://codepad.org/9BBfCuxh
02:50:47 <Zao> That was more painful than it should've been :)
02:53:56 <nus> ok, JFYI, if anybody cares, cabal-install-0.8.0.exe from h.h.o. fails unpacking the package index. Now, the package rebuilt locally doesn't.
02:54:18 <nus> oh, and that's with 6.12.1.
02:55:46 <Saizan> you could report that on the bug tracker
02:56:57 <Zao> I never used the hho one, but my local one works like a charm (0.8.0 with 1.8.0.2)
02:57:59 <nus> Saizan, sure, been wondering if this happened elsewhere too.
02:58:08 <nus> Zao, what ghc vers?
02:58:17 <Zao> nus: 6.12.1
02:59:46 <nus> zao, that's on windows, right?
05:02:21 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
05:02:21 --- topic: set by glguy!~glguy@unaffiliated/glguy on [Sat Jan 30 19:06:07 2010]
05:02:21 --- names: list (clog dschoepe interferon smorg IceDane bgs100 kqrx jutaro nick8325 jrib trin_cz gonsor arjanb rhox maskd tarleb_ Nereid_ masxmasx watermind cheater2 Nereid danvet voker57 phyrex1an greap BCoppens Alpounet paper_cc Chaze Bassetts Draconx lvillani pukka OscarZ derenrich drbean RayNbow rdd` jtootf__ sioraiocht hrehf psychicist_ Schmallon shambler u_quark Daerim pantsman comak der_eq malun Zephyrus damd TR2N lsthemes integral paulvisschers dr_maligno dolio abccc)
05:02:21 --- names: list (int-e solrize fmardini copumpkin ksf LeNsTR|away qwertycute rhz Icewing ttmrichter kniu paolino bel5f5 tensorpudding tgdavies dmwit aluink mereale Athas hackagebot nullren Liskni_si pheaver Woof alip lambdabot wisemanby Mowah path[l] ttt-- PepeSilvia Jonno_FTW pflanze elspru portnov meanburrito920_ domor blackdog Apocalisp mmaruseacph2 jorizma augur prateek ivanm astrocub laurent_atl m3ga potatishandlarn zakwilson emma kamatsu Philonous1 drwho Draconx|Laptop)
05:02:21 --- names: list (weihsiu Adamant ablokzijl absentia Argue otto_s_ SimonRC ski_ jfredett CcSsNET hiredman rprije medfly G0SUB Nshag sshc dcolish sm araujo thoughtpolice mun snhmib djahandarie BMeph Wooga dnm_ glith theorbtwo chrisdone RichardO jlouis go|dfish Khisanth eldragon LouisJB kmc beza1e1 danderson tkr idnar wto erk @ChanServ Twey desu monochrom stroan MadX` quuxman Baughn Botje karld LeoD jayne sgf jedediah allbery_b webframp sproingie mullein Ytinasni shachaf)
05:02:21 --- names: list (magicman|sleep +preflex shapr mercury^ mlh CalJohn anji JaffaCake Gabbie Spockz ski michael| cheddar nominolo ville ezeike Raevel mjv _br_ liesen kevinclark gmux mjrosenb c9s deadguys osfameron jrockway uorygl equanimity netcat rntz int_e geir_ clarkb guerrilla Milo- duairc amiri Sagi aiko andrewsw suiside McManiaC jystic koninkje_away Aisling cods baaba Dashkal pikhq tab cheater DekuNut bwr newsham jql a11235 mokus deavid Heffalump jmcarthur dfeuer)
05:02:21 --- names: list (koala_man BONUS saccade_ eelco BrianHV arw BONUS_ nniro jfoutz joga AndyP flori tommd cjay Taggnostr dcoutts albertosantini Sisu thetallguy olsner smg sahazel flux dumael tmug reltuk edwinb Exteris zygoloid ToRA helgikrs boyscared eagletmt_ wang ahihi ezrakilty dejones zhijie stepnem wharrgarble SmurfOR Cyneox wormwood htoothrot jvoorhis tafryn encryptio gbeshers tromp npouillard _Jordan_ zacharyp dino- poucet shortcircuit kosmikus aavogt noddy pragma_)
05:02:21 --- names: list (Ornedan bd_ Saizan mrd gdsx tilman alexbobp caligula_ tumult dobie_gillis __marius__ wagle ClaudiusMaximus flippo Eelis ehamberg pwerken burp ttvd AnMaster lhnz nlogax emias fabjan ahf kolmodin Polarina Ferdirand welterde jlaire jix jan_ lenbust_ Jaak kfish J-Mad keseldude calvins juhp Shimei pcc1 smiler mauke mreggen ath ziman srcerer solidsnack inimino sothim Deewiant impl temoto StoneToad whoppix felipe_ jones- Anti-X Becquerel fritschy ulfdoz s76__)
05:02:21 --- names: list (cebewee The_third_man Vulpyne dilinger sbok Paradox924X DrSyzygy peddie theclaw geoaxis shawn eno dropdrive SubStack otulp wdonnelly Davse_Bamse petekaz kar-1 saurik gogonkt Lajla ksandstr drhodes StarFire tapa ido FauxFaux det Reisen MrDomino dreixel mfp tltstc 94SAAANLT hariju xerox sfuentes Cale aleator stoltene2 ibt Dessous mmmdonuts gniourf_gniourf_ Muad_Dibber mahogny p_l tomoj juhp_ alvarezp yahooooo @Lemmih mattam anee dang`r`us blazzy kw317 shrimpx)
05:02:21 --- names: list (Vq dufflebunk orbitz djinni Bleadof epmf BurgessShale mfoemmel And[y] Daminvar Cthulhon Valodim EvanCarroll gds wolverian mikezackles syntaxglitch kynky qebab davidL electrogeek lament nathanic_work untwisted eek mornfall kalven etpace jtra DigitalKiwi nathanic snorble gbacon sebbe1991 blackh prigaux soeren oeblink crem jontore nwf cathper jre2 inhortte Mortomes dejai o-_-o Innominate_ anekos Counter-Strike Runar fnordus khiroc dionoea quicksilver)
05:02:21 --- names: list (companion_cube luite Stephan202 byorgey Blub\0 QtPlatypus Zao jbauman dons joni6128 lostlogic Colours kadoban Feuerbach willb taruti aep Igloo brx pettter trez jvogel EvanR-work ve kaol majoh mietek joed daed ben0x539 nimred M| mdordal2 rapacity bran levitation_ galdor bolmar jkarlson sohum laz0r Veinor harlekin TML jayrk lefant 77CAAAPYY Laney C-S ibid dixie Boney thingwath tamiko Cobra^^ shepheb sjanssen Torrieri cYmen saiam nothingmuch Gilly cygnus_ icee)
05:02:21 --- names: list (glitch ketil qz jonafan alexsuraci Tupis matthew-_ Arnar Twigathy mikste xinming dogmaT PsiOmega Raku^ fihi09 ortmage ennen agemo Zeiris_ pastorn Gracenotes thorkilnaur t sieni OnionKnight dMazz slc benmachine MacCoaster epokal ps-auxw canvon dju cognominal birkenfeld abbe gnuvince endojelly mrothe arjanoosting ray profmakx dqd Astro alios mm_freak Guest55225)
05:03:10 <kamatsu> oh wait
05:03:11 <kamatsu> logic error fail
05:03:13 <kamatsu> nevermind
05:04:24 <masxmasx> :t (<<)
05:04:25 <lambdabot> Not in scope: `<<'
05:04:41 <Polarina> Can I somehow print the content of a ByteString to a terminal?
05:05:43 <jrockway> "print string"?
05:06:06 <damd> @instances ByteString
05:06:06 <lambdabot> Couldn't find class `ByteString'. Try @instances-importing
05:06:10 <damd> hm
05:06:14 <damd> oh, right.
05:06:28 <damd> @instances Show
05:06:29 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
05:06:31 <ksf> iirc older versions of bytestring had a broken show instance
05:06:38 <Polarina> @instances Data.ByteString.Lazy
05:06:39 <lambdabot> Couldn't find class `Data.ByteString.Lazy'. Try @instances-importing
05:06:51 <ksf> ...if that's the problem, use unpack
05:06:55 <Polarina> @instances-importing Data.ByteString.Lazy
05:06:56 <lambdabot> Couldn't find class `Data.ByteString.Lazy'. Try @instances-importing
05:06:59 <jrockway> it has a show instance on my machine
05:07:09 <ksf> or, well, the bytestring io primitives.
05:07:25 <damd> roots, bloody roots! back to the primitive!
05:08:09 <jrockway> OTOH, the show instance for .Lazy is a little different
05:08:16 <jrockway> (Chunk "foo" Empty), for example
05:08:25 <Polarina> o.O
05:08:36 <jrockway> so if you are printing debugging information for yourself, print should be fine
05:08:45 <jrockway> if you want literal output, then use the relevant function
05:08:57 <Polarina> I would just like to print one byte to stdout for every byte there is in the ByteString.
05:09:22 <Polarina> jrockway, literal output.
05:09:46 <jrockway> then just B.putStr
05:09:50 <jrockway> http://www.haskell.org/ghc/docs/6.10.4/html/libraries/bytestring/Data-ByteString.html#27
05:10:32 <Polarina> Cool! :D
05:13:29 <voker57> is there an IO action that can move files between devices? System.Directory.renameFile can't
05:15:21 <Polarina> copyFile?
05:15:49 <Polarina> copyFile -> fSync -> deleteFile.
05:17:55 <voker57> that will sure have overhead in non-cross-device case
05:19:33 <Polarina> Certainly.
05:19:48 <Polarina> Then try renameFile, if an error: copyFile -> fSync -> deleteFile.
05:20:06 <voker57> makes sense
05:20:24 <Polarina> The fSync, or whatever it's called in haskell -- is *very* important.
05:20:47 <Polarina> Or you will make your users hate you.
05:21:05 <Polarina> You fSync the new, copied file, that is. :)
05:32:08 * hackagebot upload: haskell-src-exts 1.8.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
05:37:43 <kamatsu> cool, i made a simple chat room with web sockets and haskell :D
05:37:46 <chrisdone> OUT NOW a double album DVD; The Very Best of Simon Peyton Jones, and , S. Marlow and Jones: The Selected Functional Works 89-98, with all your favourite singles such as "We Put the 'Funk' in Function" and "Glorious Glasgow Haskell Programmer part 2", "My other car is a well typed constructor", "Bitches don't know bout my loeb :: Functor a => a (a x -> x) -> a x", "Arrow Calculus and The Essense of Music ft. Big P. Wadler" including live
05:37:46 <chrisdone> performances at Google, Glasgow, with "6th European Symposium on Programming" (REMASTERED EDITION)! Experience well typed purely functional imperative generic composable pattern matched parallel programming like never before!
05:38:54 <jrockway> my first thought was "oh no, the spammers are back"
05:38:57 <jrockway> but that can't be spam
05:39:05 <Adamant> I have no idea where that came from, but it's pretty awesome
05:40:14 <jrockway> incidentally, i decided to write a mandelbrot set generator because of a song called "mandelbrot set" by jonathan coulton
05:40:33 <jrockway> i copied the song's algorithm verbatim, and it worked :)
05:40:41 <Axman6> ha
05:40:44 <BCoppens> chrisdone: are they the first edition, and signed by all performers? If so, I want a set!
05:40:51 <Axman6> jrockway: which was?
05:41:09 <Axman6> z = z^2 + c?
05:41:12 <jrockway> yeah
05:41:46 <chrisdone> BCoppens: out in March!
05:42:10 <jrockway> http://www.youtube.com/watch?v=0uluZMafXVE
05:42:36 <BCoppens> chrisdone: goodie, I'll mail you my visa info right away!
05:43:18 <jrockway> skip the first minute though, youtube uploaders don't know how to edit...
05:43:58 <Adamant> jrockway: you can add a #t=1m0s
05:44:05 <Adamant> to the youtube URL
05:44:35 <chrisdone> jrockway: nice, butterfly effect as intro to mandelbrot
05:45:03 <Axman6> fook yeah! the HTML5 player in youtube caches the videos :D
05:45:23 <Veinor> is there any way to get lambdabot functionality (:src, :hoogle, etc.) in ghci?
05:45:29 <Veinor> I tried using GOA but that requires a lambdabot binary
05:46:10 * smorg also wonders this
05:46:11 <Veinor> and I can't get lambdabot to install >:/
05:46:19 <chrisdone> Veinor: well seeing as GHCi lets you write IO functions, you could whip a hoogle up trivially
05:46:33 <Veinor> well yeah, but :P
05:46:35 <chrisdone> Veinor: why can't you get lambdabot to install?
05:46:46 <Veinor> deps conflict
05:47:07 <smorg> The lambdabot ebuild on gentoo hasn't worked in ages :/
05:47:27 <Veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16831#a16831
05:47:30 <chrisdone> I just use cabal O_o
05:47:46 <Veinor> yeah, I can't get cabal to install it
05:48:24 <Veinor> for that reason.
05:48:38 <chrisdone> so tagsoup and show are incompatible
05:48:42 <chrisdone> are any of those already installed?
05:48:42 <Veinor> right
05:49:13 <smorg> Though I'm sure someone just cooked it up in hackport
05:49:20 <Veinor> chrisdone: nope.
05:49:33 <Veinor> it looks like if I install tagsoup-0.6 it might work
05:49:51 <chrisdone> yeah could do
05:49:57 <Veinor> because that doesn't have a QuickCheck dep.
05:50:11 <Veinor> yeah, that worked.
05:50:13 <chrisdone> yay
05:50:35 <Veinor> and several other things are failing >:/
05:50:56 <chrisdone> haha
05:51:11 <chrisdone> this ain'tcho lurky day, boy
05:51:20 <Veinor> missing happy and libreadline5-dev
05:51:43 <rhox> i yesterday finally managed to install lambdabot with tagsoup-0.6, but lambdabot didn't work correctly
05:52:04 <rhox> today i've found this: ...
05:52:14 <rhox> http://www.haskell.org/haskellwiki/Lambdabot/Building
05:52:32 <rhox> but I haven't tried it yet
05:53:20 <Veinor> hm.
05:53:29 <Veinor> well, I figure there's no harm in installing the packages anyway :D
05:54:26 <rhox> i have used libreadline-dev from my package management (ubuntu)
05:54:44 <rhox> and happy from cabal
05:56:49 <rhox> and: cabal --constraint="tagsoup == 0.6" install lambdabot; maybe it works for you
05:57:01 <Veinor> it's working for me.
05:57:05 <Veinor> at least, :src is
05:57:59 <rhox> installing worked, but evaluation with lamdabot didn't
05:58:04 <Veinor> what do you mean?
05:58:26 <rhox> open lampdabot and enter e simple example
05:58:37 <rhox> i got only "Terminated"
05:58:45 <Veinor> oh, I'm running it from ghci via GOA
05:59:27 <rhox> i didn't know, that this is possible
05:59:34 <rhox> whats GOA?
05:59:38 <Veinor> GHCI On Acid
05:59:44 <Veinor> lets you do stuff like :src blah
06:00:19 <rhox> i have already removed it
06:00:26 <Veinor> hm. the hoogle function doesn't seem to work.
06:00:42 <rhox> i tried for example @run map (+1) [1..10]
06:14:35 <MoeJoe> good morning
06:15:32 <MoeJoe> in a Map, how can I find the largest value <= a given key?
06:16:57 <Veinor> take the list of elements, filter by being less than or equal to the value, and find the max of that list?
06:18:23 <luite> MoeJoe: split, or splitLookup, followed by findMax
06:19:00 <Veinor> ... or that.
06:19:11 <Daerim> with Data.Binary.Get....how would I read Int's? I can read Words, and floats using the ieee754 package, but what if I want a signed integer?
06:19:13 <Veinor> > let map = fromAscList [(1,2), (2,3), (4,7)]; maxVal = 5 in findMax . fst . split maxVal $ map
06:19:14 <lambdabot>   Not in scope: `fromAscList'Not in scope: `findMax'
06:19:43 <Veinor> :/
06:20:28 <jmcarthur> :t M.split
06:20:29 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> (M.Map k a, M.Map k a)
06:20:30 <Veinor> oh, hm.
06:20:41 <Veinor> M.split splits on keys, not on values.
06:21:23 <luite> yes, I was assuming that's what he meant, possibly wrongly :)
06:21:26 <jmcarthur> for values i think you pretty much have to do it the slow way
06:21:47 <Veinor> > let map = fromAscList [(1,2), (2,3), (4,7)]; maxVal = 5 in max . filter (< maxVal) . elems $ map
06:21:48 <lambdabot>   Not in scope: `fromAscList'
06:21:56 <Veinor> > let map = M.fromAscList [(1,2), (2,3), (4,7)]; maxVal = 5 in max . filter (< maxVal) . M.elems $ map
06:21:58 <lambdabot>   []->
06:21:58 <lambdabot>    [2,3]
06:21:58 <lambdabot>  [-2]->
06:21:58 <lambdabot>    [2,3]
06:21:58 <lambdabot>  [-2,-1]->
06:22:00 <lambdabot> [4 @more lines]
06:22:05 <Veinor> ...
06:22:23 <jmcarthur> s/max/maximum/
06:22:42 <damd> what
06:23:00 <jmcarthur> > let map = M.fromAscList [(1,2), (2,3), (4,7)]; maxVal = 5 in maximum . filter (< maxVal) . M.elems $ map
06:23:01 <lambdabot>   3
06:23:13 <Veinor> oh yeah.
06:23:27 <MoeJoe> Veinor: my fault, I meant keys
06:23:31 <jmcarthur> :t (max, maximum)
06:23:32 <lambdabot> forall a a1. (Ord a, Ord a1) => (a -> a -> a, [a1] -> a1)
06:24:11 <MoeJoe> I was hoping for a more direct way than splitLookup followed by maxView
06:24:12 <jmcarthur> MoeJoe: luite's suggestion is better for keys
06:24:35 <MoeJoe> thanks
06:24:56 <MoeJoe> oh, and is there a way to generate a Haskell function given a type?
06:24:59 <damd> :t maxView
06:25:00 <lambdabot> Not in scope: `maxView'
06:25:04 <MoeJoe> e.g. (a -> b -> c -> d) -> (b -> c -> a -> d)
06:25:08 <jmcarthur> MoeJoe: like djinn?
06:25:10 <damd> @djinn (a -> b -> c -> d) -> (b -> c -> a -> d)
06:25:10 <lambdabot> f a b c d = a d b c
06:25:13 <luite> > let maxWithKeyAtMost m k = let (l,e,_) = splitLookup m k in e `mplus` (fst <$> maxView l) in maxWithKeyAtMost (fromList [(1,10),(3,30)]) 2
06:25:14 <lambdabot>   Not in scope: `splitLookup'Not in scope: `maxView'
06:25:18 <MoeJoe> :t Data.Map.maxView
06:25:19 <lambdabot> forall k a. M.Map k a -> Maybe (a, M.Map k a)
06:25:35 <jmcarthur> @. @pl @djinn (a -> b -> c -> d) -> (b -> c -> a -> d)
06:25:36 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
06:25:42 <jmcarthur> @. pl djinn (a -> b -> c -> d) -> (b -> c -> a -> d)
06:25:42 <lambdabot> f = (flip .) . flip
06:26:30 <MoeJoe> extremely cool
06:26:48 <MoeJoe> might there be other ways to write the same function?
06:27:00 <jmcarthur> there are always other ways
06:27:09 <MoeJoe> interesting ones
06:27:11 <Veinor> I don't think there's any other total function that does that.
06:27:29 <MoeJoe> Veinor: I meant intentionally, not extensionally
06:27:32 <Veinor> ah.
06:28:38 <MoeJoe> I have the following code liftM2 (...) xs xs
06:28:52 <MoeJoe> (...) is very long
06:29:05 <MoeJoe> I would like to write it after the xs xs
06:29:18 <MoeJoe> is there a nicer way than (flip .) . flip ?
06:29:22 <ivanm> then define your own version of liftM2
06:29:24 <xerox> > join f xs xs
06:29:25 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
06:29:28 <xerox> > join f x x
06:29:29 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:29:29 <lambdabot>    `GHC.Show.Show a'
06:29:29 <lambdabot>      a...
06:29:31 <ivanm> @pl \ f -> liftM2 f xs xs
06:29:31 <lambdabot> flip (flip liftM2 xs) xs
06:29:33 <xerox> > join f x x :: Expr
06:29:34 <lambdabot>   f x x x
06:29:48 <ivanm> > liftM2 f x x :: Expr
06:29:48 <xerox> ahah too many :P sorry for the spam  join f x = f x x
06:29:49 <lambdabot>   Couldn't match expected type `m a1'
06:29:49 <lambdabot>         against inferred type `SimpleRe...
06:30:44 <MoeJoe> oh, that's not the monadic join
06:30:56 <xerox> m = e ->
06:31:10 <MoeJoe> ahhh
06:31:13 <MoeJoe> :)
06:31:19 <xerox> =)
06:31:24 * hackagebot upload: wikipedia4epub 0.0.2 - Wikipedia EPUB E-Book construction from Firefox history. (RadoslavDorcik)
06:32:44 <MoeJoe> where can I read about the function monad?
06:33:07 <xerox> see Control.Monad.Reader
06:34:51 <MoeJoe> nice way to think of it, thanks
06:50:51 <MoeJoe> is there a shorter way of writing 'length . filter id' ?
06:51:28 <xerox> length.filter id
06:51:48 <nominolo> nah, don't do that
06:51:50 <MoeJoe> 'length $ filter id $ liftM2 (\x y -> ...) xs xs' to be precise
06:51:55 <MoeJoe> xerox: haha
06:52:13 <xerox> what's ... ?
06:52:27 <MoeJoe> a long predicate
06:52:51 <nominolo> MoeJoe: you could write it as a list comprehension
06:53:13 <nominolo> length [ () | x <- xs, y <- xs', ... ]
06:53:53 <xerox> put undefined instead of () for added thrill
06:54:03 <MoeJoe> lolll
06:54:06 <mreh_> is that a useful expression? doesn't it just do nothing? I'm just curious
06:54:34 <olsner> mreh_: yeah, it produces the number of matching items
06:54:36 <xerox> length $ do { x <- xs; y <- xs; guard (... x y) }
06:54:45 <nominolo> mreh_: length only cares about the list structure
06:54:50 <mreh_> oh, length
06:54:58 <mreh_> I missed that
06:55:13 <xerox> no () needed!
06:55:24 <nominolo> :t guard
06:55:25 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
06:55:51 <nominolo> I prefer list comprehensions instead of do-notation when working with lists
07:09:20 <MoeJoe> is there a good reason why where-clauses can only be used at the top level?
07:09:47 <burp> what do you mean by top level?
07:09:57 <MoeJoe> top level function definitions
07:10:21 <burp> you mean you can't do nested "where's"?
07:10:23 <burp> that works
07:11:05 <MoeJoe> you can't write: (\x -> y where y = x+1)
07:11:13 <burp> oh ok
07:11:31 <MoeJoe> aren't nested wheres the same as a chain of where-definitions?
07:11:32 <burp> you can't?
07:11:41 <MoeJoe> :t (\x -> y where y = x+1)
07:11:42 <lambdabot> parse error on input `where'
07:11:42 <burp> > let f x = y where y = x+1
07:11:43 <lambdabot>   not an expression: `let f x = y where y = x+1'
07:11:52 <soupdragon> you can do nested wheres though
07:11:53 <burp> > let f x = y where y = x+1 in f 10
07:11:54 <lambdabot>   11
07:12:11 <MoeJoe> that defeats the point of anonymous functions
07:12:21 <burp> hm I understand what you mean
07:12:29 <burp> seems you can't
07:12:36 <MoeJoe> yeah, I wonder why
07:12:58 <soupdragon> f = 3
07:13:03 <soupdragon> g = h f
07:13:03 <soupdragon>  where h x = f + x
07:13:03 <soupdragon>         where f = 7
07:13:10 <soupdragon> g is 10
07:13:19 <burp> he doesn't mean that
07:13:39 <soupdragon> I think this is a reasonable thing to call 'nested wheres' ?
07:14:44 <MoeJoe> > g = h f where h x = f + x where f = 7
07:14:45 <lambdabot>   <no location info>: parse error on input `='
07:14:58 <MoeJoe> > let g = h f where h x = f + x where f = 7 in g
07:14:59 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:14:59 <lambdabot>    `SimpleReflect.FromExpr ...
07:15:19 <MoeJoe> soupdragon: why is it 10?
07:15:36 <xerox> http://haskell.org/onlinereport/decls.html#sect4.4.3
07:15:46 <xerox> where is defined as part of a function binding
07:16:22 <MoeJoe> soupdragon: my ghc says the f is not in scope
07:16:49 <soupdragon> MoeJoe maybe you got the indentation wrong or something
07:17:19 <MoeJoe> soupdragon: can you walk me through the computation? I don't see how you get 10 from 7
07:17:33 <soupdragon> you add 3!
07:17:37 <MoeJoe> xerox: why not define it as sugar for let ... in ?
07:17:49 <MoeJoe> oh, sorry I didn't see the preceding line
07:18:31 <MoeJoe> soupdragon: you are right, nested wheres are different
07:19:17 <MoeJoe> why not define 'u where x = t' as sugar for 'let x = t in u' ?
07:21:07 <soupdragon> MoeJoe.. well that would be the obvious thing to do.... but I am sure Those Who Designed Haskell have some reasons..
07:23:46 <MoeJoe> soupdragon: I'm sure, too ;) just wondering whath those reasons are
07:24:07 <soupdragon> MoeJoe, what I mean is that it seems completely irrational not to do what you are suggestion
07:24:10 <soupdragon> suggesting*
07:26:41 <MoeJoe> MoeJoe: maybe it has to do with typing...
07:26:53 <MoeJoe> soupdragon: maybe it has to do with typing...
07:28:18 <Vitka> @pl pairs (a:[]) = []
07:28:18 <lambdabot> (line 1, column 14):
07:28:19 <lambdabot> unexpected "="
07:28:19 <lambdabot> expecting variable, "(", operator or end of input
07:29:09 <Vitka> @pl map (\x -> (a,x)) as ++ pairs as
07:29:09 <lambdabot> map ((,) a) as ++ pairs as
07:29:23 <ehamberg> âIt is not possible, however, to hide instance declarations in the Preludeâ â hmm, is there then an easy way to have doubles âshowân with only two digits after the period?
07:31:18 <medfly> hmph, multiply by 100, floor, divide by 100? :-D
07:31:23 <olsner> printf might have more fancy floating-point formats
07:31:50 <Gracenotes> even dividing by 100 can yield ambiguities
07:32:08 <medfly> yeah? isn't this supposed to be easy with how doubles are made?
07:32:18 <medfly> you only change the exponent :o
07:32:21 <olsner> you have some variants of showFloat in Numeric too: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Numeric.html
07:32:30 <Gracenotes> twould be a base 2 exponent
07:32:37 <olsner> medfly: only if you have decimal floating point
07:32:37 <medfly> oh >.<
07:32:44 <medfly> gah, okay.
07:32:46 <medfly> <- stupid
07:32:53 <Gracenotes> I can't think of any examples where it wouldn't work off the top of my head...
07:33:30 <ehamberg> yes, looks like i want showFFloat (Just 2).
07:33:36 <Gracenotes> but one could engineer such a thing. still, the multiply/floor/divide trick seems to be used in places
07:55:24 <jrockway> btw, here's the output of my program: http://jrock.us/mandelbrot-big.png
07:55:37 <jrockway> 400M pixels :)
07:55:39 <jrockway> and 9 hours of CPU time
07:55:42 <jrockway> (2 hours wall clock time)
07:56:16 <Gracenotes> firefox loved it so much it immediately crashed
07:56:26 <jrockway> yeah, it's a big image :)
07:56:39 <Twey> Chromium screamed and ran away, too
07:56:42 <jrockway> looks like every other mandelbrot set
07:56:45 <Twey> Sadtab'd
07:56:46 <jrockway> so you aren't really missing anything
07:56:50 <burp> my chrome likes it
07:56:57 <burp> I don't like the colors :>
07:56:57 <Gracenotes> time to wget
07:57:06 <Twey> Hehe
07:57:12 <jrockway> i don't like the colors either
07:57:19 <jrockway> but there was no library to give me pretty colors
07:57:29 <jrockway> so i picked 255,255,255; 255, 255, 0; ...
07:57:41 <olsner> opera seemed to handle it fine :)
07:57:57 <burp> oh
07:58:01 <Gracenotes> HSV, varying H, tends to look pretty
07:58:03 <burp> that tab in chrom enow uses 1.5G
07:58:05 <burp> lol
07:58:12 <jrockway> haha
07:58:22 <olsner> uses a bit of memory though, I'm guessing 1.2 or 1.6GB just for the image
07:58:52 <jrockway> when the program was almost done running, it was using about that much memory
07:58:57 <Gracenotes> also, you might like xaos
07:59:17 <Saizan> jrockway++ -- for 70s psychedelic effect
07:59:20 <jrockway> yeah, i've seen that
07:59:32 <jrockway> this was kind of a spur of the moment thing
07:59:39 <jrockway> i heard a song about it, and implemented it in haskell
07:59:44 <jrockway> then let the program run for a few hours :)
07:59:53 <Gracenotes> I patricularly like xaos's newton fractal
08:00:08 <jrockway> i am tempted to optimize and make it interactive, but there would be no point
08:01:26 <temoto> jrockway, i don't understand 2 hours of time vs. 9 hours CPU time.
08:01:40 <medfly> maybe he has more than one CPU
08:01:44 <temoto> jrockway, do you have 4.5 cores?
08:01:44 <medfly> kind of like manhours
08:01:56 <medfly> MAYBE HE DOES!!!!!!!!
08:02:22 <jrockway> yeah, my machine is quad-core
08:02:28 <jrockway> but with hyperthreading, which seemed to help slightly
08:02:41 <jrockway> i did +RTS -N6, as that seemed to be the fastest setting
08:02:48 <temoto> Ah, so virtually 16.
08:02:54 <jrockway> virtually 8
08:03:06 <olsner> hmm, N6 was fastest? last-core slowdown or something?
08:03:07 <temoto> right
08:03:28 <jrockway> the cpu runs slower (for this workload, anyway) when it is doing 8 things at once
08:03:35 <temoto> jrockway, did you tried 6.12 thread statistics?
08:03:44 <jrockway> no, i haven't tried 6.12 yet
08:04:05 <jrockway> i don't think gtk2hs is ported anyway
08:04:22 <jrockway> but hyperthreading is interesting
08:04:31 <jrockway> for things like make, make -j8 will run faster (wall-clock) than make -j4
08:04:37 <jrockway> but it will use like 1.8x CPU time
08:04:42 <temoto> jrockway, they have nice stats on how many sparks it actually used, how many `par`-s skipped, how much time spent in GC, etc.
08:04:44 <jrockway> meaning the CPU "gets slower" as you schedule virtual threads
08:04:58 <jrockway> i didn't use `par` though, i did producer/consumer with chans
08:05:19 <Gracenotes> quadcore. is nice.
08:06:24 <jrockway> this is the code, if anyone cares: http://gist.github.com/291074
08:06:30 <jrockway> the implementation is not exciting in any way
08:06:38 <olsner> you mentioned it using a lot of memory when it was done, did you generate the entire buffer then write it out? if you have a line-oriented PNG encoder (the format is iirc quite line-oriented) you should only need buffering for a few scanlines really
08:06:40 <jrockway> it's the dumbest possible way to solve the problem :)
08:06:51 <jrockway> yeah, it wrote the whole image out at once
08:07:16 <jrockway> i calculated that 400000000 24-bit pixels is about 1.1G and that's about what the program was using at the end
08:08:11 <temoto> @type id
08:08:12 <lambdabot> forall a. a -> a
08:08:51 <temoto> @undo { putMVar mvar True ; myThreadId >>= killThread }
08:08:52 <lambdabot>  Parse error at "{" (column 1)
08:08:57 <temoto> @undo do { putMVar mvar True ; myThreadId >>= killThread }
08:08:58 <lambdabot> putMVar mvar True >> myThreadId >>= killThread
08:09:18 <temoto> @do putMVar mvar True >> myThreadId >>= killThread
08:09:18 <lambdabot> do { a <- do { putMVar mvar True; myThreadId}; killThread a}
08:09:58 <temoto> Wow, never seen inner do.
08:09:58 <jrockway> i think i used the most concise notation possible ;)
08:10:22 <temoto> jrockway, it's just hard for me to understand >>=
08:10:34 <ManateeLazyCat> I saw some code of concurrent server program code: "mvar <- newEmptyMVar; takeMVar mvar", those code make `main` running infinite loop, can someone explain above code how to work? I can't understand.
08:11:08 <ManateeLazyCat> @type (>>=)
08:11:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:11:17 <ManateeLazyCat> temoto: See above.
08:11:30 <temoto> ManateeLazyCat, i know, but still it's hard to read it.
08:11:51 <jrockway> if it weren't monadic it would be "killThread myThreadId"
08:12:02 <jrockway> maybe "killThread =<< myThreadId" would have been easier to read?
08:12:09 <Saizan> if main is just that nothing is going to write in that MVar, so the RTS spots that the takeMVar will block forever and kills it
08:13:28 <jrockway> servers aren't designed to exit anyway
08:13:57 <ManateeLazyCat> Saizan: I see, when i use "mvar <- newEmptyMVar" create new MVar, then use takeMVar read value, main loop will block until some *someone* put value to mvar, right?
08:14:07 <jrockway> yes
08:14:23 <Saizan> yeah
08:14:25 <temoto> jrockway, great point. I hate those guys with --daemonize option.
08:15:53 <kamatsu> cool, I have the basic foundation for an operational transforms-based haskell editor server complete :D
08:15:58 <ManateeLazyCat> Saizan: So, above code just *one* point, don't exit current main loop, haven't any other mean?
08:16:14 <kamatsu> now i'm off to bed :D
08:16:14 <ManateeLazyCat> Saizan: Infact, haven't *anyone* will put value in `mvar`, right?
08:17:33 <Polarina> How do I use sqlite with haskell? :)
08:17:47 <Saizan> Polarina: see the HDBC package on hackage
08:17:52 <Polarina> Ok.
08:18:01 <Saizan> ManateeLazyCat: mh, i don't understand
08:18:21 <ManateeLazyCat> Saizan: Wait, i post example code.
08:18:36 * ManateeLazyCat pasted "Server.hs" at http://paste2.org/get/642518
08:18:45 * ManateeLazyCat pasted "Client.hs" at http://paste2.org/get/642520
08:18:45 <Saizan> you need a way to make the main thread wait forver?
08:19:31 <ManateeLazyCat> Saizan: Yeah, see Server.hs, it's do a Server daemon and run forever.
08:19:51 <ManateeLazyCat> Saizan: Server.hs provide "add" server on DBus.
08:19:53 <Saizan> forever $ threadDelay maxBound
08:19:56 <olsner> @ty \f -> (>>= \a -> State $ \ts -> f (a,ts)) -- hmm, I wrote this, but now I have no idea what it means :/
08:19:57 <lambdabot> forall a s a1. ((a, s) -> (a1, s)) -> State s a -> State s a1
08:20:26 <ManateeLazyCat> Saizan: When Client.hs request "add" service through DBus, Server.hs will return result to Client.hs.
08:20:46 <ManateeLazyCat> Saizan: So Server.hs design for running forever.
08:21:10 <Saizan> ManateeLazyCat: "forever $ threadDelay maxBound" should work if you want the main thread to sit there endlessly doing nothing
08:21:28 <Polarina> How do I call C functions and libraries from Haskell?
08:21:34 <ManateeLazyCat> Polarina: FFI
08:21:39 <Polarina> FFI?
08:21:44 <Saizan> @where FFI
08:21:44 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
08:21:52 <ManateeLazyCat> Yep, above link
08:22:30 <Polarina> Cool.
08:23:29 <Daerim> don't suppose any of you cool haskell-sharks knows of a fast and efficient way to put the content of a bytestring into an array?
08:23:40 <ManateeLazyCat> Saizan: So in `main` function of Server.hs, have different between "mvar <- newEmptyMVar; takeMVar mvar" and "forever $ threadDelay maxBound"?
08:24:17 <olsner> Daerim: it's already an array though
08:24:21 <Saizan> ManateeLazyCat: you are asking if those two will behave differently?
08:24:30 <ManateeLazyCat> Saizan: Yep.
08:24:45 <olsner> i.e. maybe you can just use the bytestrings directly
08:24:55 <Polarina> unpack?
08:24:58 <Vitka> Is there a way to use parser combinators on tokens? Like "fs <- many float"? Something like "p = do natural ; fs <- many1 float ; return acs" generates type error, but simple sequence of "a <- float" compiles.
08:25:15 <Saizan> ManateeLazyCat: yes, the former will actually make the process die with an exception, the latter will make it never terminate
08:25:47 <Twey> Vitka: What is the type of âfloatâ?
08:25:54 <Daerim> olsner It's chunks of arrays from what I understand?
08:26:56 <ManateeLazyCat> Saizan: I see. Thanks for your explain, i think i need former, because if DBus send some exception to Server.hs, i need terminate it.
08:27:00 <Daerim> Polarina, unpack would mean O(n) time to unpack and mean using lists, which might be a tad slow for 9mb of binary data
08:27:09 <Polarina> o.O
08:27:28 <olsner> Daerim: not entirely sure how the internal magic works, but I think normal bytestrings are always one chunk of a (single) bytearray and lazy bytestrings are lazy lists of such chunks
08:27:35 <Saizan> ManateeLazyCat: the former will make it die immediately, it'll generate the exception itself
08:28:08 <Vitka> Things would be much simpler if I understood relations between GenParser, TokenParser, ParsecT and so on. Let me try...
08:29:27 <Saizan> ManateeLazyCat: the latter is the one to use
08:29:31 <Daerim> olsner, hmm I'm using lazy bytestrings currently, but it's hardly a dealbreaker. I'll take a look at the internals. Thanks :)
08:29:57 <Saizan> ManateeLazyCat: if some exception is thrown to the main thread it'll still receive it and escape from the forever
08:30:13 <Vitka> Float is ParsecT s u m Double, while many1 is ParsecT s u m a -> ParsecT s u m [a]. Why wouldn't they produce ParsecT s u m [Double]?
08:30:45 <ManateeLazyCat> Saizan: I have use your code replace former, works well.
08:30:53 <Saizan> Vitka: in fact it should work
08:31:11 <ManateeLazyCat> Saizan: So you mean when something with MVar, will kill itself?
08:31:15 <Saizan> Vitka: can you paste the code and the exact error somewhere
08:31:15 <Vitka> Hmm.
08:31:19 <Saizan> ?
08:31:21 <Vitka> Ok.
08:31:23 <ManateeLazyCat> When something wrong with MVar
08:31:53 <ahihi> where is STM nowadays?
08:32:03 <Saizan> ManateeLazyCat: if ghc detects that a takeMVar or putMVar can never succeed it raises an exception, yeah
08:32:20 <ManateeLazyCat> Saizan: I see, thanks. :)
08:32:30 <Saizan> ahihi: hackage?
08:33:10 <ahihi> it's been removed from the default GHC installation?
08:33:48 <Saizan> in ghc-6.12.1 the installation has only the packages needed to make ghc work
08:34:13 <Saizan> since the rationale is that you should use the Haskell Platform if you want libs
08:34:14 <Vitka> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16833#a16833
08:34:43 <ManateeLazyCat> Hi, guys, if you want some efficient IPC for multi-processes communication, i recommend use John's DBus implement, it's really cool and easy to use.
08:34:50 <ManateeLazyCat> @where dbus-core
08:34:50 <lambdabot> I know nothing about dbus-core.
08:34:52 <ahihi> ah, okay
08:35:11 <ManateeLazyCat> @package dbus-core
08:35:12 <lambdabot> http://hackage.haskell.org/package/dbus-core
08:35:18 <ManateeLazyCat> @package dbus-client
08:35:19 <lambdabot> http://hackage.haskell.org/package/dbus-client
08:35:31 <ManateeLazyCat> Just see above two link for DBus implement.
08:36:04 <Saizan> Vitka: float is an accessor function for the GenTokenParser record datatype
08:36:22 <Saizan> Vitka: so you've to apply it to such a record, to extract the field
08:36:23 <ManateeLazyCat> GHC-6.12.1 have include Cabal, so you don't need install Cabal after you install GHC.
08:36:51 <Vitka> Record being value of makeTokenParser?
08:37:21 <Vitka> I tried, but it gives different error.
08:37:33 <Saizan> the result
08:37:40 <Saizan> which error?
08:37:54 <soupdragon> @dict litany
08:37:55 <lambdabot> Supported dictionary-lookup commands:
08:37:55 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
08:37:55 <lambdabot> Use "dict-help [cmd...]" for more.
08:38:01 <soupdragon> @all-dicts litany
08:38:02 <lambdabot> *** "Litany" gcide "The Collaborative International Dictionary of English v.0.48"
08:38:02 <lambdabot> Litany \Lit"a*ny\ (l[i^]t"[.a]*n[y^]), n.; pl. {Litanies}
08:38:02 <lambdabot>    (l[i^]t"[.a]*n[i^]z). [OE. letanie, OF. letanie, F. litanie,
08:38:02 <lambdabot>    L. litania, Gr. litanei`a, fr. litaney`ein to pray, akin to
08:38:02 <lambdabot>    li`tesqai, li`ssesqai, to pray, lith` prayer.]
08:38:04 <lambdabot> [39 @more lines]
08:38:28 <Twey> Oh really?
08:38:37 <mreh_> > readFloat 9.9990000e+03
08:38:38 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Base.String)
08:38:39 <lambdabot>    arising from the l...
08:38:43 <Twey> @lojban plixau
08:38:45 <lambdabot> Error: 501 Syntax error, illegal parameters
08:38:51 <Twey> Boo
08:39:06 <mreh_> > readFloat 9.9990000e+03 :: RealFrac
08:39:07 <lambdabot>   Class `GHC.Real.RealFrac' used as a type
08:39:15 <mreh_> > readFloat 9.9990000e+03 :: Real
08:39:16 <lambdabot>   Class `GHC.Real.Real' used as a type
08:39:17 <Saizan> mreh_: quotes.
08:39:25 <mreh_> > readFloat "9.9990000e+03"
08:39:26 <lambdabot>   [(9999.0,"")]
08:39:33 <mreh_> hmm
08:39:39 <Vitka> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16833#a16834
08:40:48 <Saizan> Vitka: it seems "float" changed type in the middle of this
08:40:57 <Saizan> Vitka: can you paste the whole module?
08:41:08 <Saizan> complete with imports.
08:41:57 <Saizan> or maybe you're using primitive somewhere else that expects a different type?
08:42:48 <Vitka> Hmm, can it clash with some library function?
08:42:52 <Vitka> @hoogle primitive
08:42:53 <lambdabot> No results found
08:43:11 <Saizan> that wouldn't be a problem
08:43:37 <Saizan> oh
08:43:43 <Saizan> you've to apply natural to gi too.
08:43:55 <Saizan> natural is an accessor just like float.
08:44:15 <Vitka> Oh.
08:44:20 <Vitka> Lemme try.
08:45:22 <temoto> @hoogle mapped
08:45:23 <lambdabot> Network.Socket AI_V4MAPPED :: AddrInfoFlag
08:45:28 <temoto> @hoogle mappend
08:45:28 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
08:45:30 <doserj> btw, do { a <- x; return a } is simply x
08:46:18 <temoto> Is there something like pythonrc.py for ghci?
08:46:30 <temoto> a script that would be executed on every start
08:46:31 <Vitka> Thanks, that seemed to do the trick. Now on to other type errors. :)
08:46:36 <Saizan> temoto: .ghci
08:46:38 <Twey> temoto: ~/.ghci
08:46:41 <temoto> Thanks.
08:46:51 <temoto> i guess i need to put a lot of imports in there
08:47:08 <Twey> Might want to change your prompt, too
08:47:27 <temoto> To simple ">" ? :)
08:48:51 <Twey> To something that's going to leave some space for you to see your code when you've got all those imports there :Ã¾
08:49:27 <Twey> It would be nice to be able to say âdon't show these imports in the promptâ, so you could show only the ones that are unusual
08:52:13 <temoto> How do i tune prompt?
08:55:09 <Twey> temoto: :set prompt "New prompt> "
08:55:27 <olsner> hmm, is there a way to get records etc pretty-printed with indentation so they're readable?
08:55:51 <Twey> I'm sure you should be able to
08:56:34 <temoto> twanvl, thanks, it works.
08:56:54 <twanvl> yay!
08:57:04 * Twey wants twanvl's job
08:57:06 <olsner> rather, is there a nice way that doesn't require me to do much stuff manually... based on the same information that generates Show instances, you should be able to generate code in some pretty-printing monad for instance
08:57:13 <Twey> Sitting around getting thanked all dayâ¦ :Ã¾
08:57:13 <temoto> twanvl, no, sorry it's meant for Twey
08:57:27 <Twey> My
08:57:35 <olsner> twanvl: shame on you for stealing the credit :P
08:57:42 <twanvl> :)
08:57:53 <temoto> It's not the first time, right?
08:58:40 <temoto> olsner, there's PrettyPrint in standard library.
08:58:47 <twanvl> right. the same thing happend a couple of weeks ago
08:59:23 <temoto> olsner, it doesn't do what you want, though. But it allows you to build your own pretty printer kinda easily.
09:02:20 <Saizan> olsner: there's hstidy as a CLI tool
09:03:07 <Saizan> olsner: thin wrapper around haskell-src-exts
09:04:40 <olsner> hmm, so using hstidy on the printed output might be workable
09:05:27 <bt> hi can someone please tell me what kind of operator ">.>" is ?
09:05:43 <Saizan> ?hoogle (>.>)
09:05:44 <lambdabot> No results found
09:05:46 <byorgey> bt: where did you see this operator?
09:05:50 <bt> its for IO
09:05:56 <byorgey> it's not in any standard library as far as I know
09:06:00 <olsner> the suspicious-look operator?
09:06:02 <bt> i guess like the c stream  >>
09:06:14 <byorgey> bt: yes, but where did you actually see this?
09:06:17 <bt> but i didnt find any description on the net
09:06:29 <Saizan> bt: if you can load your module in ghci you can use :i >.> to tell where it's defined
09:06:36 <pikhq> bt: >> is not a "stream" operator, it's a right bitshift.
09:06:48 <Twey> I think bt meant C++
09:06:52 <bt> yep
09:07:02 <pikhq> Still a right bitshift.
09:07:02 <bt> cout and cin with >> and <<
09:07:14 <byorgey> pikhq: it's overloaded.
09:07:15 <pikhq> For some reason bitshifting an istream by a variable does input.
09:07:23 <pikhq> byorgey: Still a right bitshift.
09:07:36 <Twey> It's not a bitshift if it doesn'tâ¦ erâ¦ bitshift :Ã¾
09:07:45 * byorgey looks at pikhq suspiciously >.>
09:07:48 <Twey> It may be the bitshift operator, but it's not a bitshift.
09:08:02 <sshc> Warning: The export item `Foo(..)' suggests that `Foo' has (in-scope) constructors or class methods, but it has none
09:08:06 <sshc> how do I disable that warning?
09:08:22 <olsner> just export Foo without the (..)?
09:08:46 <sshc> olsner: when I write things for Foo, I want them all to be exported
09:08:56 <sshc> olsner: I also want (..) for style reasons
09:09:14 <sshc> olsner: (..) should export everything, even when the number of those things is 0
09:09:48 <olsner> right, for future expansion basically? so you want to disable the warning, not get rid of it, which is probably why you asked exactly that :P
09:10:35 <Saizan> sshc: see ghc flag reference
09:10:44 <sshc> Saizan: where can I see that?
09:10:50 <Saizan> sshc: there's usually a -fno-warn-something
09:10:56 <Saizan> ?google ghc flag reference
09:10:57 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
09:10:57 <lambdabot> Title: 4.18.ï¿½Flag reference
09:11:24 <sshc> Saizan: how do I disable that in the source file iteslf?
09:11:37 <Saizan> sshc: {-# OPTIONS -fno-warn-... #-}
09:11:51 <sshc> Saizan: wouldn't that be GHC_OPTIONS ?
09:12:02 <Saizan> yeah, or maybe OPTIONS_GHC ?
09:12:20 <Saizan> OPTIONS works too, but less friendly with other implementations
09:12:52 <Twey> Yeah, it's OPTIONS_GHC
09:13:13 <sshc> there's a big list in man ghc
09:13:27 <sshc> I can't find any name that would suggest permitting (..)
09:15:01 <olsner> -fwarn-dodgy-exports:
09:15:30 <olsner> maybe, it might also be doing something else
09:15:41 <sshc> hmm, that's not in the man page
09:16:14 <olsner> found it here: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html
09:17:25 <sshc> Causes a warning to be emitted when a datatype T is exported with all constructors, i.e. T(..), but is it just a type synonym.
09:17:28 <sshc> Also causes a warning to be emitted when a module is re-exported, but that module exports nothing.
09:17:37 <sshc> I'm exporting a data type, not a type synonym
09:19:45 <sshc> is there a flag I can pass to GHC to  disable this warning?
09:20:17 <Saizan> -fno-warn-dodgy-exports
09:20:22 * hackagebot upload: cpphs 1.11 - A liberalised re-implementation of cpp, the C pre-processor. (MalcolmWallace)
09:20:52 <Twey> Liberalised, eh?
09:21:03 <pikhq> Does it not suck?
09:24:19 <Twey> It's a textual preprocessor.  Of course it sucks.
09:25:14 <olsner> not just textual, it's a *c* preprocessor
09:25:30 <pikhq> Hmm. It sucks less than most C preprocessors in only one way...
09:25:36 <pikhq> It gives useful line numbers.
09:25:55 <pikhq> It doesn't do token concatenation, so I can't use it to get some useful errors out of my ungodly C code, though.
09:40:00 <paolino> mh, I just installed ghci on windows, it seems it cannot open files in current dir
09:41:23 <paolino> I'm not a a window user, also
09:42:42 <paolino> probably current dir is not current dir ..
09:43:42 <bt> (-<-) :: (a->b) -> (b->c) -> (a->c) , does this kind of syntax for function composition have a name?
09:44:21 <soupdragon> awesome cool function sequencing operator
09:44:34 <bt> dunno how to call the (a->b)... ah okay
09:44:56 <paolino> ah, windows is not case sensitive on file names!
09:44:56 <tumult> :t (>=>)
09:44:57 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:45:02 <tumult> :)
09:45:23 <tumult> kleisli composition?
09:45:34 <tumult> (i think that is what you are looking for)
09:46:12 <mreh_> is that arrow syntax?
09:46:15 <mreh_> (-<-)
09:46:57 <mreh_> :t (-<-)
09:46:58 <lambdabot> Not in scope: `-<-'
09:46:59 <bt> thats just my own operator
09:47:09 <bt> which im defining
09:47:13 <mreh_> :t flip (.)
09:47:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
09:47:24 <mreh_> :t (.)
09:47:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:47:32 <doserj> :t (>>>)
09:47:33 <bt> for stuff like  f-<-g-<-h
09:47:33 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
09:47:45 <mreh_> bt: use function composition (.)
09:48:05 <mreh_> it's already been defined :)
09:48:43 <bt> well its for learning purposes not for writing beautifull code :P
09:48:44 <mreh_> ignore the funny type signature with Functor, for functions it should read (.) :: (b -> c) -> (a -> b) -> a -> c
09:51:58 <BMeph> I'd use '>>>' myself; the shape is suggestive. Also, it's already defined. :)
09:52:12 <BMeph> ...never mind. :|
09:57:51 <Relofazius> Hi, what's the best way to see, how ghc optimizes a function? P.ex.
09:58:53 <Relofazius> a print (mysum 80) of mysum n = sum [1..n] - does it become "print 3240" (at compile time)?
09:59:09 <sjanssen>  it won't
09:59:30 <Twey> It will once we get supercompilation :Ã¾
09:59:35 <Philonous1> Is there a feasible way to interface with C vararg functions?
09:59:39 <sjanssen> Relofazius: the best thing to look at is the core output, but reading it is a black art
10:00:07 <Relofazius> is there a way with template haskell?
10:00:08 <sjanssen> Relofazius: try 'ghc -ddump-simpl' or ghc-core from hackage
10:01:40 <Philonous1> Relofazius: It won't get simplified to 3240, but the intermediate list might be eliminated by deforestation
10:02:09 <sjanssen> Philonous1: it won't be (in current GHC)
10:02:51 <Philonous1> sjanssen: Oh. I thought list comprehension and foldls would play together nicely. Bummer.
10:03:54 <sjanssen> Philonous1: the system GHC uses is called "foldr/build" or "short-cut deforestation".  That system can't fuse foldl
10:04:32 <Philonous> Ok. Then maybe sum should be rewritten to use foldr
10:04:56 <sjanssen> Philonous: that would use O(n) stack, which negates any advantage
10:05:14 <sjanssen> Relofazius: main = print $(lift $ mysum (80 :: Int)) -- will evaluate at compile time
10:05:26 <mreh_> @pl fromLists . map (map (fst . head . readFloat) . words) . lines $ file
10:05:27 <lambdabot> fromLists (map (map (fst . head . readFloat) . words) (lines file))
10:09:16 <Gracenotes> @hoogle fromLists
10:09:16 <lambdabot> No results found
10:11:37 <Relofazius> sjanssen: Not in scope: 'lift'/'mysum' - with {-# LANGUAGE TemplateHaskell #-} and import Language.Haskell.TH
10:14:44 <sjanssen> Relofazius: Language.Haskell.TH.Syntax
10:14:57 <sjanssen> Relofazius: and you might have to define mysum in a different module, I can never remember how that works
10:28:35 <Relofazius> works: Main.main = print_rSy (GHC.Integer.smallInteger 3240) - thanks a lot
10:34:44 <jmv_> Hi      I'm learning Haskell, in the middle of Learn_Haskell_in_10_minutes ,
10:34:47 <jmv_> I'm on Ubuntu 9.10, and I don't know the Ubuntu package for library Data.Map
10:35:03 <copumpkin> someone seriously wrote a "learn haskell in 10 minutes" tutorial?
10:35:13 <copumpkin> that's going to have a lot of disappointed readers :P
10:35:13 <djahandarie> lol
10:35:28 <Twey> jmv_: It's included in the standard distribution
10:35:32 <wto> copumpkin: http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
10:35:35 <wto> apparently...
10:35:49 <jmv_> copumpkin,    http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes#Using_libraries
10:36:14 <copumpkin> I see
10:36:15 <sjanssen> jmv_: libghc6-containers-dev
10:36:41 <Twey> Really?
10:37:07 <jmv_> <sjanssen> thanks ; but I'll have to add a package depot
10:37:37 <sjanssen> jmv_: really?  I don't recall having to do that on my system
10:37:42 <jmv_> at least I have the name
10:37:51 <monochrom> libghc6-containers-dev is just in the "universe". ghc6 is in the "universe" to begin with.
10:38:06 <jmv_> I have ghc6
10:38:19 <copumpkin> 6.10 or .12 I hope
10:38:28 <monochrom> it's 6.10.4
10:38:29 <jmv_> plus ghc6-doc libghc6-parallel-dev
10:39:08 * zakwilson_ could imagine "learn the basics of Haskell syntax in 10 minutes if you already know another lazy functional language"
10:39:32 * soupdragon images learn haskell in 0 seconds, if you know haskell
10:39:52 * pikhq imagines "Learn Haskell in 10 minutes if you already know Core".
10:40:11 <monochrom> If you teach haskell for 10 minutes, is it learn haskell in -10 minutes?
10:40:12 <djahandarie> soupdragon, it'd probably still take over 10 minutes to learn Haskell even if you knew Haskell already
10:40:19 <Twey> Haha
10:40:47 <jmv_> I found these tutorials nice; I already know classical languges, XSLT, Prolog
10:40:59 <temoto> Anyone playing farmville on facebook?
10:41:01 <pikhq> "Topics that don't fit into 10 minutes"
10:41:08 <pikhq> "... Everything."
10:41:30 <jmv_> <sjanssen> but I don't find my package on Ubuntu : http://packages.ubuntu.com/search?suite=karmic&section=all&arch=any&lang=fr&searchon=names&keywords=containers
10:43:06 <temoto> jmv_, did you install ghc6?
10:43:19 <sjanssen> jmv_: I don't know what the problem would be.  I'm on Karmic and I've got libghc6-containers-dev
10:44:32 <temoto> The problem is that it's not a separate package, but it is provided by ghc6.
10:45:05 <monochrom> The problem is the search engine
10:45:06 <Twey> pikhq: Yeahâ¦ we need to make that list much bigger :Ã¾
10:46:03 <temoto> monochrom, apt-cache doesn't find it either. The problem is that such package doesn't exist as a separate one. You can't install libghc6-containers-dev.
10:46:06 <monochrom> Oh, temoto is right. libghc6-containers-dev is alias to ghc6
10:47:53 <sjanssen> jmv_: so if you've got GHC you should already have containers, what exactly isn't working?
10:49:06 <jmv_> thanks <monochrom> , <sjan so it's another problem :
10:49:10 <jmv_> ghc -o use_map  use_map.hs
10:49:10 <jmv_> compilation IS NOT required
10:49:10 <jmv_> use_map.o: In function `rFX_info':
10:49:10 <jmv_> (.text+0xea): undefined reference to `containerszm0zi2zi0zi1_DataziMap_lookup_closure'
10:49:34 <monochrom> ghc --make -o use_map  use_map.hs
10:50:23 <jmv_> Sorry, yes , it works
10:50:57 <jmv_> Many thanks, <monochrom> and <sjanssen>
10:53:55 <mreh_> > maxBound :: Double
10:53:56 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
10:53:57 <lambdabot>    arising from a use o...
10:54:02 <mreh_> hmm
10:54:35 <mreh_> the mysteries of floating point
10:54:58 <temoto> > maxBound :: Int
10:54:59 <lambdabot>   9223372036854775807
10:55:12 <mreh_> > minBound :: Int
10:55:13 <lambdabot>   -9223372036854775808
10:55:24 <temoto> Is that a 64bit value?
10:55:30 <mreh_> > maxBound + minBound :: Int
10:55:31 <lambdabot>   -1
10:55:42 <mreh_> twos complement
10:55:54 <mreh_> > 2^64
10:55:55 <lambdabot>   18446744073709551616
10:56:02 <mreh_> > 2^64 / 2
10:56:03 <lambdabot>   9.223372036854776e18
10:56:08 <mreh_> > (2^64) / 2
10:56:09 <lambdabot>   9.223372036854776e18
10:56:12 <temoto> div
10:56:14 <mreh_> it seems to be
10:56:18 <mreh_> > (2^64) `div` 2
10:56:19 <lambdabot>   9223372036854775808
10:56:28 <temoto> Yeah seems so.
10:56:32 <mreh_> minus one for the twos complement
10:56:52 <mreh_> that's rubbish
10:57:00 <mreh_> minus one because zero is also a number
10:57:20 <mreh_> that's the number of values it may take
10:57:31 <mreh_> i need a large double
10:57:34 <mreh_> hehehehe
10:58:11 <Vitka> > product [1..100]
10:58:12 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
10:58:35 <Vitka> > fromIntegral $ product [1..100]
10:58:36 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
10:59:31 <Vitka> > fromInteger $ product [1..100]
10:59:32 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
10:59:37 <mreh_> that's an Integer
10:59:41 * Vitka sighs.
10:59:45 <mreh_> fromInteger can cast to Integers
10:59:58 <mreh_> > fromInteger $ product [1..100] :: Int
10:59:59 <lambdabot>   0
11:00:16 <mreh_> Vitka: is that what you wanted?
11:00:32 <mreh_> can and will cast to Integers
11:00:36 <Vitka> > product [1..100] :: Double
11:00:37 <lambdabot>   9.33262154439441e157
11:00:49 <Vitka> > product [1..150] :: Double
11:00:50 <lambdabot>   5.7133839564458505e262
11:01:04 <Vitka> > product [1..1000] :: Double
11:01:05 <lambdabot>   Infinity
11:01:06 <Vitka> boom
11:02:45 <Vitka> Actually I have an unrelated question. Concerning my struggle with Parsec and monads in general.
11:03:28 <mreh_> that's not unrelated
11:03:33 <mreh_> go ahead
11:03:45 <mreh_> > 0.01 == 0
11:03:46 <lambdabot>   False
11:03:49 <mreh_> > 0.001 == 0
11:03:50 <lambdabot>   False
11:03:52 <mreh_> > 0.0001 == 0
11:03:53 <lambdabot>   False
11:04:08 <Saizan> unrelated to Double's i guess
11:04:17 <Vitka> Is "do x <- expr1; y <- expr2; return (x,y)" supposed to work when x and y are off different types?
11:04:27 <Saizan> yes
11:04:28 <monochrom> Yes.
11:04:41 <soupdragon> :t do x <- ?expr1; y <- ?expr2; return (x,y)
11:04:42 <lambdabot> forall (m :: * -> *) t t1. (?expr1::m t, Monad m, ?expr2::m t1) => m (t, t1)
11:05:00 <soupdragon> type inference yes
11:05:10 <mreh_> as long as expr1 and expr2 are the same type
11:05:18 <Saizan> uh?
11:05:19 <idnar> why do they need to be the same type?
11:05:21 <Vitka> Aha.
11:05:21 <mreh_> same monad
11:05:22 <Philonous> > do x <- Just 4; y <- Just "foo"; return (x,y)
11:05:23 <lambdabot>   Just (4,"foo")
11:05:27 <Vitka> What if they aren't?
11:05:34 <idnar> oh, same monad, yes
11:05:37 <Saizan> same monad, but the result types can be different
11:05:43 <idnar> if they're not the same monad, then that code doesn't make any sense
11:06:13 <Saizan> sometimes you can transform an action in some monad into another
11:06:18 <mreh_> he said "suppose to work", what's the problem Vitka?
11:06:19 <Vitka> How to get "a <- symbol tp; b <- natural tp; return stuff" to work?
11:06:21 <Saizan> expecially if you're using transformers
11:06:22 <idnar> you're going to have to lift one or both expressions into the same monad in order to use them at the same time
11:06:27 <Saizan> like ParseT
11:06:39 <idnar> @type symbol
11:06:40 <lambdabot> Not in scope: `symbol'
11:06:47 <Vitka> I'm talking about token parsers, yes.
11:06:48 <Saizan> @hoogle symbol
11:06:49 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
11:06:49 <lambdabot> Text.ParserCombinators.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
11:06:49 <lambdabot> Text.Read Symbol :: String -> Lexeme
11:06:56 <idnar> @hoogle natural
11:06:56 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
11:06:56 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
11:06:56 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
11:07:05 <Saizan> Vitka: symbol needs two arguments.
11:07:06 <idnar> those look like the same monad to me
11:07:41 <Vitka> Oh.
11:08:00 <Vitka> What about "a <- string; b <- natural tp; return stuff"?
11:08:16 <Saizan> string needs an argument too.
11:08:27 <Vitka> Hrm.
11:08:39 <idnar> man, I keep getting GADT syntax and record syntax confused
11:09:16 <Saizan> ?type isAlpha
11:09:17 <lambdabot> Char -> Bool
11:09:32 <Saizan> Vitka: maybe you want many1 (satisfy isAlpha)?
11:09:42 <Saizan> it'll parse any sequence of letters
11:09:54 <Saizan> ?hoogle letter
11:09:54 <lambdabot> Text.Parsec.Char letter :: Stream s m Char => ParsecT s u m Char
11:09:54 <lambdabot> Text.ParserCombinators.Parsec.Char letter :: Stream s m Char => ParsecT s u m Char
11:09:54 <lambdabot> Data.Char LetterNumber :: GeneralCategory
11:10:01 <Vitka> Actually, just any string terminate by newline.
11:10:03 <Saizan> many1 letter then.
11:10:52 <Saizan> and add a char '\n' on the next line
11:11:09 <Vitka> manyTill newline char?
11:11:43 <Saizan> do a <- many1 letter; char '\n'; b <- natural tp; return ..
11:11:48 <Vitka> manyTill char newline actually.
11:11:58 <Saizan> char needs an argument.
11:12:04 <Vitka> Right.
11:12:07 <Vitka> Hmm.
11:12:07 <Saizan> and i'm not sure there's a newline
11:12:13 <monochrom> look for "any"
11:12:20 <Vitka> There is.
11:12:30 <Vitka> manyTill anyToken newline
11:15:43 <Vitka> Hmm.
11:17:19 <Vitka> @hoogle isAlpha
11:17:19 <lambdabot> Data.Char isAlpha :: Char -> Bool
11:17:19 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
11:18:11 <idnar> what does Foo {} fill the missing fields in with? bottom?
11:18:38 <monochrom> > let hmm = Just{} in "hello"
11:18:39 <lambdabot>   "hello"
11:18:47 <monochrom> > let hmm = Just{} in fromJust hmm
11:18:48 <lambdabot>   * Exception: <interactive>:1:143-148: Missing field in record construction
11:19:02 <idnar> ah
11:20:05 <Vitka> @hoogle Integer -> Int
11:20:05 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
11:20:05 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
11:20:05 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
11:21:35 <monochrom> haskell98-compliant too. it says "Fields not mentioned are initialized to _|_."
11:21:37 <idnar> fromInteger is probably what you want
11:22:11 <monochrom> unless you have strict fields. "A compile-time error occurs when any strict fields (fields whose declared types are prefixed by !) are omitted during construction."
11:22:14 <Vitka> Yeah, fromInteger worked.
11:28:13 <chrisdone> what would make a good lambda case syntax?
11:28:23 <sm> cabal install soegtk complains about missing gtk and cairo; macports says both are installed: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16845 - help ?
11:28:51 <idnar> am I correct in thinking that you can use parsec to parse arbitrary value graphs, not just strings?
11:29:00 <soupdragon> case of
11:29:00 <Saizan> sm: what does ghc-pkg list says?
11:29:03 <soupdragon>  A -> ...
11:29:05 <soupdragon>  B -> ...
11:29:13 <chrisdone> (\case of x -> ...; y -> ..)?
11:29:18 <soupdragon> no
11:29:21 <Saizan> idnar: see the Stream class
11:29:38 <chrisdone> soupdragon: the suspense is killing me
11:30:05 <sm> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16845#a16846
11:30:17 <Vitka> @hoogle parseTest
11:30:18 <lambdabot> Text.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
11:30:18 <lambdabot> Text.ParserCombinators.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
11:30:42 <Vitka> @hoogle readFile
11:30:42 <lambdabot> Prelude readFile :: FilePath -> IO String
11:30:42 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
11:30:42 <lambdabot> System.IO readFile :: FilePath -> IO String
11:31:10 <Saizan> sm: ah, those packages in macport are the C libs
11:31:22 <Saizan> sm: cabal is complaining about the haskell wrappers
11:31:26 <soupdragon> if then p else q  could denote  \g0213 -> if g0213 then p else q
11:31:27 <Saizan> ?google download gtk2hs
11:31:29 <lambdabot> http://www.haskell.org/gtk2hs/download/
11:31:29 <lambdabot> Title: Gtk2Hs Â» Download
11:31:37 <Saizan> sm: there ^^^
11:31:44 <sm> I see, port install gtk2hs may do.. thanks Saizan
11:31:52 <sm> I always forget how this works
11:32:21 <chrisdone> n/m (\case of x -> ..) is a good idea I'll use that
11:32:54 <soupdragon> I think that lambda is wrong
11:33:26 <chrisdone> dats grate
11:36:50 <soupdragon> chrisdone don't be such a twerp, piss off you're going to say sarcastic remarks to everyone that answers your question -- if you don't care for answers asking is just obnoxious
11:38:07 <dolio> \case of ... is the one that's already been proposed.
11:38:56 <gwern> ?src (!!)
11:38:56 <lambdabot> xs     !! n | n < 0 = undefined
11:38:56 <lambdabot> []     !! _         = undefined
11:38:56 <lambdabot> (x:_)  !! 0         = x
11:38:56 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:39:14 <gio123> does somebody has following book:
11:39:16 <gio123>  All About Maude - A High-Performance Logical Framework:
11:39:26 <gio123> ?
11:41:09 <gwern> http://news.ycombinator.com/item?id=1090785 <-- the leapfrog approach is obvious enough, and it seems to me easy to do any fixed n with pattern-matching - eg, for 3, you'd have matches like [] = []; a:b:c:[] = a; a:b:c:d = recurse d, but is there any general pattern-matching approach?
11:42:03 <soupdragon> gwern just write two functions
11:42:41 <sinelaw> yo.
11:43:12 <gwern> soupdragon: how would that work?
11:43:28 <soupdragon> gwen you already wrote one (in the specific form), the other just generalizes the 3 into any n
11:43:35 <soupdragon> gwern*
11:43:47 <gio123> does somebody has following book:
11:43:55 <gio123>  All About Maude - A High-Performance Logical Framework: ?
11:44:13 <soupdragon> gio123, does someone /have/ the following book
11:44:28 <kmc> i don't think any of us bought it since you last asked
11:44:42 <soupdragon> I have read it in the past but I don't own it
11:47:21 <Cale> > let nthLast n xs = last (zipWith const xs (drop n xs)) in nthLast 5 "hello, world!"
11:47:22 <lambdabot>   'w'
11:47:38 <jmv_> within ghci, how can I get help on a library function ?
11:47:45 <Cale> jmv_: You can't.
11:47:56 <Cale> jmv_: You open your web browser and point it at the documentation ;)
11:48:13 <Cale> Well, that's not entirely true. You can get the type of a library function.
11:48:17 <Cale> :t foo
11:48:18 <lambdabot> Not in scope: `foo'
11:48:30 <Cale> Which is often enough help on its own.
11:49:07 <jmv_> Cale, but if I want some text in command line ?
11:49:30 <jmv_> some help text in ghci
11:50:13 <Cale> jmv_: I suppose you could try to write something which locates haddock documentation snippets attached to a declaration in a particular piece of source code.
11:50:27 <Cale> But the source code for many of the libraries won't actually be on your system.
11:50:48 <Gracenotes> Cale: cute
11:50:48 <jmv_> cale , I see
11:50:56 <Gracenotes> the nthLast
11:50:58 <ezyang> I find myself often wanting hoogle docs for versions of the library that haven't been put up yet.
11:51:00 <Cale> :)
11:51:27 <jmv_> Cale, you know what calé means in french slang ?
11:51:31 <Cale> nope
11:51:42 <jmv_> smart, knows a lot
11:51:45 <Cale> heh
11:53:05 <Saizan> jmv_: if you install hoogle and get the index files for the library in question installed you can do :! hoogle --info foo
11:53:57 <laurent_atl> however recalé is someone who fails an exam, so be sure not to be yourself again...
12:00:24 <dons> Hey all. Status update for Haskell on Arch. lots of details. http://archhaskell.wordpress.com/2010/01/31/arch-linux-updates-to-ghc-6-12/
12:02:12 <dozu> hi guys
12:02:22 <dozu> i need some help
12:02:24 <Cale> hello
12:02:52 <Cale> Of course, we can't help if we don't know what the problem is :)
12:03:04 <Twey> dons: Nice!
12:03:24 <jmv_> Saizan, the hoogle page is not explicit about how to install http://www.haskell.org/haskellwiki/Hoogle
12:04:00 <dozu> the problem is about RoseTree
12:04:21 <dozu> i want to write a "mirror" function
12:04:27 <dozu> but i cant still figure it out :(
12:04:39 <kmc> dozu, where does this RoseTree data type (?) come from?
12:04:44 <kmc> also, what would a "mirror" function do?
12:04:56 <Twey> Data.Tree, reverse the order of all nodes?
12:05:01 <dozu> its like : data RoseTree = Node a [RoseTree a]
12:05:01 <kmc> is it like the "Rose" type at http://www.haskell.org/haskellwiki/Algebraic_data_type
12:05:02 <Cale> Probably reverse the order in which the branches occur
12:05:07 <kmc> dozu, ah
12:05:25 <dozu> mirror func. just swap the values in each levels
12:05:31 <Cale> dozu: Okay, so  mirror (Node x ts) = ...
12:05:41 <copumpkin> Cofree []
12:05:46 <dozu> mirror :: RoseTree a -> RoseTree a
12:05:49 <Cale> dozu: We know that the result has got to be a Node.
12:05:53 <Twey> mirror (Node v bs) = Node v . reverse $ map mirror bs
12:05:56 <Cale> So we can fill that part in
12:06:00 <Cale> dozu: Okay, so  mirror (Node x ts) = Node ...
12:06:05 <Cale> er
12:06:05 <Cale> he
12:06:28 <dozu> hmm
12:06:31 <dozu> wait a sec :9
12:06:43 * Cale needs to finish this coffee, his typing is haphazard :)
12:06:51 <Cale> okay
12:07:01 <Twey> Hehe
12:07:31 <dozu> Twey ... cool thing. but what the "$" do? :)
12:07:39 <kmc> @src ($)
12:07:39 <lambdabot> f $ x = f x
12:07:44 <Twey> I think Cale's working up to it a bit more slowly.
12:07:50 <kmc> mirror (Node v bs) = Node v . reverse (map mirror bs)
12:07:56 <kmc> ^^^^ without using $
12:08:02 <Twey> kmc: No
12:08:09 <Cale> kmc: whaaaat
12:08:12 <Twey> Node v (reverse (map mirror bs))
12:08:14 <dozu> omg you guys haskell cracks :D
12:08:19 <kmc> sorry
12:08:22 <kmc> Cale / Twey is right
12:08:32 <zakwilson> I have about half a gig of data I want to store in a way that's quick to query and can check for duplicates very quickly. Is trying to use sqlite sane, or is there a better (possibly Haskell-specific) option?
12:08:32 <kmc> mirror (Node v bs) = Node v (reverse (map mirror bs))
12:08:47 <Cale> anyway, I'm trying to explain how to come up with this in the first place...
12:08:47 <kmc> what kind of queries do you need
12:08:59 <Twey> Yeah, follow Cale's explanation, dozu
12:08:59 <dozu> thanks a lot guys
12:09:02 <Cale> dozu: okay
12:09:06 <Twey> You'll benefit from it
12:09:37 <Cale> So we start by providing mirror with a general tree, and asking what we know about the result, in order to start writing down what mirror should produce:
12:09:46 <Cale> mirror (Node x ts) = ...
12:10:06 <Cale> Here, x and ts are any value (for the root node), and list of subtrees
12:10:50 <Cale> We know that the mirror of any tree is going to be another tree, and the only means we have at the moment for building trees is essentially the Node data constructor, so we might as well use it
12:10:57 <Cale> mirror (Node x ts) = Node ...
12:11:03 <dozu> ok , but i still dont geht how the result should be a whole tree again
12:11:24 <Cale> dozu: Well, we're trying to flip the tree over left to right, yeah?
12:11:36 <dozu> ok
12:11:37 <Cale> So the input is a tree, and the output is another tree
12:12:00 <dozu> ok , but how i rebuild a whole tree?
12:12:11 <Cale> Don't worry about that for now.
12:12:18 <kw317> the way the tree is defined - recursively
12:12:27 <Cale> Just worry about which tree it is that mirror produces in this case
12:12:37 <dozu> ok
12:12:42 <Cale> We also know what the value at the root node will be
12:12:51 <Cale> It should be the same as the input tree, of course, right?
12:13:01 <dozu> right
12:13:03 <Cale> mirror (Node x ts) = Node x ... -- so we have this much now
12:13:12 <dozu> ok sounds good
12:13:18 <Cale> Now, we just need to decide what the subtrees will look like
12:13:52 <Cale> If we flip the tree over from left to right, that means that the subtrees come in the opposite order
12:13:52 <dozu> ok , so we need to swap the values recursivly
12:13:55 <dozu> or what
12:13:56 <dozu> :)
12:14:13 <monochrom> I don't actually know what is "swap the values".
12:14:17 <Cale> and not only that, but each of the subtrees will be the mirror image of the corresponding subtree in the original
12:14:26 <Cale> yeah?
12:14:30 <dozu> yep
12:14:41 <Cale> Thankfully, we have a perfectly good function for finding the mirror image of a tree.
12:14:54 <Cale> It just happens to be the function we're defining at the moment.
12:15:22 <dozu> sounds little bit crazy for me :)
12:15:26 <Cale> So, we mirror image all the subtrees:
12:15:40 <Cale> map mirror ts
12:15:46 <Cale> and reverse the order
12:15:49 <Cale> reverse (map mirror ts)
12:15:50 <dozu> there is my problem
12:16:01 <Cale> and that's the list of subtrees that we want
12:16:12 <Cale> mirror (Node x ts) = Node x (reverse (map mirror ts))
12:16:26 <Cale> Why should we expect this to work?
12:16:50 <Cale> First of all, just convince yourself that the equation is something that we'd want a mirror function to satisfy
12:16:51 <dozu> i like can not imaginate this function (map mirror ts) , i know whats do but because of recursivation its hard for me to realize that
12:17:28 <Cale> When you're defining a recursive function, you always assume that it will work for all subparts of its input.
12:17:43 <laurent_atl> zakwilson: do you need your data to be persisted to disk?
12:17:53 <zakwilson> laurent_atl: yes.
12:18:01 <dozu> ok i think i need to work on this little bit more
12:18:15 <Cale> dozu: Don't try to trace inside what the map mirror ts is doing
12:18:38 <Cale> Just take it for granted that it forms a list of mirrors of each of the trees in ts
12:19:00 <RayNbow> "You canât use âyaourtâ any more â it is broken on Haskell dependencies" <-- ah, so this might be the reason xmonad no longer compiles on my Arch netbook :p
12:19:14 <laurent_atl> zakwilson: then sqlite is probably reasonable
12:19:49 <Cale> dozu: Are you familiar with induction?
12:19:57 <Cale> Let's try to show that this mirror function will always work, starting with one-node trees (which are the smallest trees in your RoseTree type)
12:20:11 <laurent_atl> zakwilson: but 1/2 G fits in RAM on most machines so if you want the fastest query a hashtable would be better
12:20:13 <dozu> yeah i know how it works
12:20:24 <Cale> One-node trees look like  (Node x [])  for some x
12:20:38 <Cale> and the mirror image that we want is of course just the same tree: Node x []
12:20:51 <Cale> If we take the equation:
12:21:05 <Cale> mirror (Node x ts) = Node x (reverse (map mirror ts))
12:21:13 <Cale> and substitute ts = []
12:21:17 <Cale> we get:
12:21:22 <Cale> mirror (Node x []) = Node x (reverse (map mirror []))
12:21:26 <dozu> ok
12:21:40 <Cale> and map f [] for any function f is just [], so we have
12:21:48 <Cale> mirror (Node x []) = Node x (reverse [])
12:21:51 <zakwilson> laurent_atl: I don't have a single unique thing to query by.
12:21:58 <dozu> sounds good
12:22:12 <Cale> and reverse [] is []
12:22:24 <dozu> Cale, i know what you mean. its really a good start
12:22:28 <Cale> so we get: mirror (Node x []) = Node x []
12:22:32 <dozu> maybe i should try this way
12:22:34 <Cale> and that's what we wanted
12:22:35 <dozu> next time
12:22:40 <Cale> So it works for one-node trees
12:23:13 <laurent_atl> zakwilson: if you already have a relational data model then you do need sqlite
12:23:40 <Cale> dozu: Now, suppose that mirror works correctly for all trees whose depth is less than n
12:23:58 <Cale> dozu: We want to show that it works for a tree of depth equal to n
12:25:03 <Cale> Of course, when we have that (Node x ts) is a tree of depth equal to n, we know that ts is a list of trees of depth less than n
12:25:10 <Cale> (at most depth n-1)
12:25:12 <jmv_> is there a compiler with friendlier error messages than ghc ?
12:25:27 <Cale> jmv_: not that I'm aware of
12:25:30 <dozu> but ts is a list of leaves , right?
12:25:39 <Cale> dozu: Not necessarily
12:25:51 <dozu> but in my case
12:25:56 <kmc> jmv_, but read about Hugs (not a compiler) and Helium (not standard Haskell)
12:26:08 <Cale> dozu: Well, if you just wanted to treat trees of depth 1
12:26:21 <Cale> Or 2, depending on how you count...
12:26:24 <kmc> jmv_, this channel can help you decode GHC errors
12:26:26 <zakwilson> laurent_atl: It need not be relational, though it might eventually have benefits if it was.
12:26:58 <Cale> jmv_: If you put some code and error messages on hpaste, we'll be happy to help you understand them.
12:27:19 <shemale-magic> what? there is a relational db done in haskell? what liek a tutorial D implementation?
12:27:30 <Cale> jmv_: Asking questions here is often a lot easier than looking through documentation, and has the added benefit of helping hundreds of people procrastinate.
12:27:33 <dozu> Cale thanks a lot mate.
12:28:15 <laurent_atl> zakwilson: not knowing more it is hard to help you there
12:28:24 <Cale> dozu: So, you get how it works? Supposing that mirror does the right thing for all trees of depth less than n, it'll work on a tree of depth n, yeah?
12:28:27 <zakwilson> The next question is: what are the relative merits of the two or three different ways to talk to sqlite from Haskell? Is there one that "everybody" uses?
12:28:58 <Cale> dozu: That actually isn't *quite* enough to say that it works on all trees in Haskell, because it misses out all the infinite trees. But it's close enough for now :)
12:29:02 <zakwilson> laurent_atl: I'm storing and querying chat data for experiments involving author identification.
12:29:04 <dons> ones based on hdbc are the most popular.
12:29:53 <Cale> dozu: (and the function *does* work on infinite trees :)
12:30:20 <Twey> Modulo stack explosion
12:30:42 <Twey> Wait, does that stack-explode?
12:30:45 <Cale> Nah, pretty hard to coerce a stack explosion out of this.
12:30:55 <copumpkin> trees can be infinite in two directions
12:30:56 <dozu> i think its a good start to understand that function. i need someone to explain me some things :)
12:32:52 <dozu> see you next time mates :)
12:32:52 <Cale> ...
12:32:52 <Cale> Okay :)
12:32:52 * copumpkin eats cheddar 
12:32:52 <Cale> It always confuses me when people don't just ask their questions :)
12:32:52 <jmv_> Cale, where is hpaste ?
12:32:52 <FauxFaux> What, Cale, you aren't psychic like the rest of us?
12:32:52 <Twey> Heh, yes
12:32:52 <Cale> @where hpaste
12:32:52 <Twey> hpaste.org
12:32:52 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
12:32:52 <yrlnry> I had some idea that the [ foo | bar <- baz ] notation would work with any monad, or at least any MonadPlus, and not just with the list monad.  Did I hallucinate this?
12:32:52 <Twey> yrlnry: Time-travelled, maybe
12:32:52 <Cale> yrlnry: That's in Haskell 1.4
12:32:52 <copumpkin> yrlnry: a million years ago
12:32:53 <Twey> It used to, but it was considered too confusing
12:32:59 <Cale> yrlnry: But it was sadly removed in Haskell 98 :(
12:33:09 <Twey> There are motions to bring monad comprehensions back, I believe
12:33:09 <laurent_atl> zakwilson: relational databases are not the best tools for indexing text
12:33:11 <yrlnry> Okay, I was not remembering it then.
12:33:15 <yrlnry> Thanks.
12:33:16 <Twey> Say, was there a Prime proposal for that?
12:33:52 <Cale> Haskell Prime wouldn't be the right place to add something like that. We should have at least one current implementation of it first :)
12:34:01 <Twey> True
12:34:02 <yrlnry> Speaking of Prime, I was rereading Bird and Wadler last night, and found a nice passage where they say that the n+k notation is superior to the alternative.
12:34:11 <Twey> Oh?
12:34:22 <zakwilson> laurent_atl: I'm not indexing the text. I'm indexing the date/time.
12:34:33 <yrlnry> They are not talking about Haskell, of course.
12:34:39 <Peaker> bring Haskell 1.4 back!  not just monad comps, also MonadZero for "fail"
12:34:39 <yrlnry> I can't quote it right now; it's at home.
12:34:46 <Cale> Peaker: Yeah
12:34:47 <yrlnry> ARRRGH "fail"
12:34:54 <yrlnry> fail is fail.
12:35:02 <laurent_atl> zakwilson: what else will you query by?
12:35:31 <zakwilson> laurent_atl: I may not even store the text directly - just the featurized text, which at the moment will be orthogonal sparse bigrams.
12:35:44 <zakwilson> laurent_atl: username
12:37:58 <Vitka> Whew, so I guess I managed to get my combined parser to compile. Now parseTest complains there are no instance of Show for it.
12:38:26 <yrlnry> Presumably your parser is a function?
12:38:29 <Vitka> Am I missing something?
12:38:35 <Vitka> Yes.
12:38:42 <yrlnry> Functions don't normally have show instances.
12:38:53 <Vitka> @hoogle parseTest
12:38:54 <lambdabot> Text.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
12:38:54 <lambdabot> Text.ParserCombinators.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
12:39:23 <Vitka> @hoogle Parsec
12:39:23 <lambdabot> module Text.Parsec
12:39:23 <lambdabot> module Text.ParserCombinators.Parsec
12:39:23 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
12:39:36 <Vitka> Hmm.
12:39:39 <laurent_atl> zakwilson: sqlite would do the job, but then i am not sure why you need it. a hash table might be enough if you only need 1/2 G of data
12:41:53 <Vitka> @hoogle parse
12:41:53 <lambdabot> Text.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
12:41:53 <lambdabot> Text.ParserCombinators.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
12:41:53 <lambdabot> Network.URI parseAbsoluteURI :: String -> Maybe URI
12:43:16 <zakwilson> laurent_atl: A hash table only allows lookup by one unique key. There won't be a single unique key. Any of date, time, username and message will be identical for multiple messages. I'd still have to examine every value to query it.
12:44:06 <zakwilson> laurent_atl: I could use the entire value as the key, which would get me fast duplicate detection, but otherwise it would just act like a list or array for my purposes.
12:45:47 <Vitka> @hoogle Char
12:45:47 <lambdabot> module Data.Char
12:45:47 <lambdabot> module Text.Parsec.Char
12:45:47 <lambdabot> module Text.ParserCombinators.Parsec.Char
12:46:09 <Vitka> @hoogle Stream
12:46:09 <lambdabot> module Network.HTTP.Stream
12:46:09 <lambdabot> module Network.Stream
12:46:09 <lambdabot> Network.Socket Stream :: SocketType
12:46:42 <laurent_atl> zakwilson: what is your concern about using sqlite, then?
12:46:52 <jmv_> Cale, I put my ugly code on hpaste
12:47:51 <Cale> jmv_: okay, so the problem is that  n read l :: Int  isn't a valid declaration
12:48:06 <Cale> You probably want to write an equation there -- you need at least an = sign
12:48:56 <zakwilson> laurent_atl: that there might be some wonderful Haskell-oriented way of doing things I wasn't aware of. I'm still a bit of a Haskell newbie.
12:49:14 <jmv_> right , Cale , it works
12:49:18 <Cale> :)
12:49:33 <yrlnry> There's a function in Control.Concurrent that forks a new thread, namely forkIO, which yields a thread ID, but there doesn't seem to be any way to find out whether a certain thread has completed, or to wait until a certain thread completes.
12:49:37 <yrlnry> What am I missing?
12:50:47 <JohnnyL> are there any languages (including DSL) that are based on Combinators?
12:51:06 <yrlnry> JohnnyL:  unlambda.
12:52:23 <Cale> yrlnry: Maybe you're looking for MVars?
12:52:25 <laurent_atl> zakwilson: i am not an expert either... but i have not heard of anything
12:52:55 <Cale> yrlnry: You could create an empty MVar which is associated with the given thread -- having the thread fill it with () when it completes.
12:53:03 <gwern> hm. what's the emoticon for slack-jawed incomprehension?
12:53:05 <yrlnry> Yeah, I was going to ask if that is the way to do it.
12:53:12 <yrlnry> gwern:  O_o
12:53:17 <Cale> yrlnry: Anything that wants to wait for that thread to finish can then just use  readMVar
12:53:28 <gwern> yrlnry: doesn't feel strong enough
12:53:31 <yrlnry> Okay, thanks.
12:54:08 <zakwilson> laurent_atl: have you used any of the libraries for talking to SQL databases?
12:54:40 <JohnnyL> yrlnry thx
12:54:56 <Philonous> When c2hs asks me for an in marshaller from C-type (Ptr ()) to haskell type (Ptr ()), will id do the trick?
12:55:13 <Vitka> So parseTest gives error "No instance (Show (GenParser  Char st  [([Char],  Double,  (Double, Double, Double), [([Char], [[Double]])])]))". Not having Show for this piece of... data is understandable, but tuples and lists are showable. Do I need to do anything to unwrap them for something? I'm using parseTest myCombinedParser inp, where inp is from readFile.
12:55:26 <MissPiggy> Vitka that's kind of hard to read!!
12:55:33 <MissPiggy> what does ']])])]))' mean
12:55:33 <MissPiggy> ?
12:56:01 <Botje> Vitka: it looks like you're trying to print a parser object
12:56:03 <jmv_> is there a compile option to avoid Exception at execution like  Non-exhaustive patterns in function
12:56:04 <Vitka> Well, the problem it tries to show GenParser monad.
12:56:07 <Vitka> Yes.
12:56:23 <Vitka> Parentheses come from nested lists and tuples.
12:56:36 <Vitka> How do I make parseTest print actual parser output?
12:56:36 <kmc> Vitka, it's trying to show the parser.  you're probably not using parseTest right
12:56:43 <Vitka> Yes.
12:56:47 <kmc> are you invoking parseTest from ghci?
12:56:49 <Cale> Vitka: When you have complicated nested lists and tuples like that, it's a good sign that you're not defining enough of your own datatypes
12:56:51 <Vitka> I'm trying to figure it out.
12:56:56 <Botje> jmv_: uh, that error means haskell doesn't know how to proceed.
12:57:01 <kmc> @type parseTest
12:57:02 <Vitka> I will define later.
12:57:02 <lambdabot> Not in scope: `parseTest'
12:57:07 <laurent_atl> zakwilson: only for very simple things
12:57:09 <kmc> parseTest :: Show a => GenParser tok () a -> [tok] -> IO ()
12:57:18 <kmc> Vitka, parseTest takes two arguments and returns an IO action
12:57:23 <kmc> the IO action has no useful result
12:57:27 <kmc> in other words, it will do the printing for you
12:57:27 <Botje> Vitka: what's the type of myCombinedParser?
12:57:33 <kmc> is it possible that you're passing in a parser-parser?
12:57:39 <Vitka> main = do inp <- readFile "1.f" ; parseTest parseInput inp
12:57:40 <kmc> that is, a parser whose output is another parser?
12:57:50 <Vitka> Hmm, probably.
12:57:52 <kmc> do you have type signatures on all the parsers you define?
12:57:52 <Cale> jmv_: You can turn on -fwarn-incomplete-patterns
12:58:05 <Vitka> Nope. Let me check.
12:58:12 <Cale> jmv_: Which will (hopefully) warn you at compile time when you've not finished defining a function.
12:58:39 <Vitka> So, for main parsing function, I need to use "parse", or "runParser", something like that?
12:58:56 <Botje> just parse, i think.
12:59:04 <kmc> parseTest is for testing
12:59:12 <kmc> it should work in "main" like you pasted
12:59:19 <Cale> It's not on by default, because it's a little imprecise as of yet -- particularly when dealing with various extensions to the language.
12:59:41 <Vitka> But my parseInput generates parser, and it tries to show this parser.
12:59:46 <Twey> Yet warn-overlapping is on by default
13:00:05 <Botje> Vitka: yes. you should put explicit types on sub-parsers to see which one is wrong
13:00:19 <Vitka> Hmm.
13:01:07 <Botje> or put your parser on hpaste and let us take a look at it :)
13:02:56 <jmv_> Cale, i just get a message on main missing, that I can't eliminate :
13:02:58 <jmv_> ghc -no-hs-main -fwarn-incomplete-patterns fwarn-incomplete-patterns.hs
13:02:58 <jmv_> fwarn-incomplete-patterns.hs:1:0:
13:02:58 <jmv_>     The function `main' is not defined in module `Main'
13:03:22 <Cale> jmv_: Right, if you want to compile a program, you need to define a main IO action.
13:03:43 <Cale> (which says what the program ought to do when it's run)
13:03:44 <jmv_> there is note the equivalent of gcc -c ?
13:03:56 <Cale> Oh, you can compile just an object file, I suppose.
13:04:06 <Cale> But that's not very useful.
13:04:17 <DiaZ> i people and haskell masters, sorry to bother, but i am with a doubt could u help me? ^^
13:04:18 <Cale> If you just want to test the definitions in the program, use ghci
13:04:19 <jmv_> for testing syntaxes :)
13:04:28 <Cale> ghci myFile.hs
13:05:05 <Cale> and then you'll get any syntax or type errors, and if the file loads correctly, a prompt at which you can type expressions in order to test the definitions
13:05:20 <Cale> DiaZ: Just ask :)
13:05:24 <DiaZ> i have defined this in my file:
13:05:24 <DiaZ> data Expr = Val Int | Add Expr Expr | Mult Expr Expr | Subt Expr Expr
13:05:48 <DiaZ> and i wanted to instance this as an Eq
13:06:01 <Cale> okay
13:06:05 <DiaZ> but me problem
13:06:09 <DiaZ> *my
13:06:20 <Cale> Do you want structural equality, or equality under evaluation?
13:06:38 <Cale> Like, is  Add (Val 3) (Val 5) supposed to be equal to Val 8 ?
13:06:45 <DiaZ> is that for example the Add, i want to see if they are equal comparing the value of the adition
13:06:53 <Cale> okay
13:06:56 <DiaZ> yes
13:07:00 <jmv_> thanks Cale, indeed ghci accepts also option   -fwarn-incomplete-patterns , which says apropriately
13:07:03 <DiaZ> something like that ^^
13:07:06 <Cale> jmv_: :)
13:07:13 <Cale> DiaZ: So first you need to write an evaluator.
13:07:17 <jmv_> Warning: Pattern match(es) are non-exhaustive
13:07:17 <jmv_>              In the definition of `charName':
13:07:17 <jmv_>                  Patterns not matched:
13:07:17 <jmv_>                      GHC.Types.C# #x with #x `notElem` ['a', 'b', 'c']
13:07:17 <DiaZ> it is an exercise i am doing to train
13:07:28 <kmc> DiaZ, write eval :: Expr -> Int
13:07:50 <kmc> then:  instance Eq Expr where { (==) = (==) `on` eval }
13:08:08 <Cale> jmv_: whoa, what a strange way to display that message...
13:08:29 <Cale> kmc: heh
13:08:48 <Cale> kmc: Given that he's a beginner, I'd stay away from the points-free definition :)
13:08:49 <DiaZ> hmm, i indeed have something like that in mt book, an eval function but i am getting confused because i wasn't sure to put that function inside the instance block or outside
13:09:01 <kmc> DiaZ, put it outside it's generally useful
13:09:04 <DiaZ> *my
13:09:07 <Cale> DiaZ: The definition of (==) needs to go inside the instance
13:09:10 <kmc> the stuff in the "instance" block has to be part of the Eq typeclass
13:09:14 <Cale> Everything else can go outside.
13:09:18 <kmc> but it can use stuff defined elsewhere
13:09:28 <Cale> instance Eq Expr where
13:09:40 <Cale>   x == y  =  eval x == eval y
13:09:47 <Vitka> @hoogle symbol
13:09:48 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
13:09:48 <lambdabot> Text.ParserCombinators.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
13:09:48 <lambdabot> Text.Read Symbol :: String -> Lexeme
13:09:51 <DiaZ> hmm ok, gonna try and see if i get what i want thanks
13:10:07 <Cale> (this is equivalent to what kmc wrote, just might be easier for you to understand :)
13:11:13 <jmv_> Cale, I must say that I expected Haskell to be more severe by default at the compile step ; are there other program that can be detected at compile time, than "Pattern match(es) are non-exhaustive"
13:11:29 <jmv_> other program defects
13:11:32 <Cale> jmv_: Oh, lots.
13:11:45 <Peaker> jmv_: For example, one atypical defect that is detected is NULL pointer dereference.  Haskell detects those at compile-time as simple type errors
13:11:57 <Peaker> atypical-to-detect, programming-language-wise, I meant :)
13:12:08 <Cale> Peaker: You could claim that failing to match some patterns is similar.
13:12:32 <Peaker> Cale: Its similar, but the response would be that even C and C++ have a switch() not matching all cases warning
13:12:36 <Cale> Though when someone receives a Maybe value and ignores the Nothing pattern, well, it's usually pretty obvious.
13:12:38 <Peaker> But C and C++ don't have an option type
13:12:49 <jmv_> is there something like  -fwarn-all-potential-problems ?
13:12:50 <Peaker> switch() on enums
13:12:54 <Cale> jmv_: hehe
13:12:56 <kmc> jmv_, -Wall
13:12:57 <Cale> jmv_: -Wall
13:13:03 <jmv_> :)
13:13:11 <jmv_> i nkew this one
13:13:13 <kmc> jmv_, but many classes of defect are caught as type errors, anyway
13:13:16 <kmc> which you cannot ignore
13:13:30 <Cale> Consider something like the standard 'map' function
13:13:37 <Cale> map :: (a -> b) -> [a] -> [b]
13:13:44 <kmc> there are standard functions like "head" that can throw an exception for some inputs
13:13:53 <Cale> Suppose we write this type signature, and try to define map as follows:
13:13:55 <kmc> unfortunately there's no simple way to get a warning if they're being used
13:13:57 <Cale> map f [] = []
13:14:01 <Cale> map f (x:xs) = x : map f xs
13:14:12 <JohnnyL> any game companies using haskell for scripting?
13:14:15 <Cale> oops! We forgot to apply f to the first element of the list!
13:14:28 <Cale> The compiler will actually detect that as a type error.
13:14:44 <Cale> JohnnyL: Not so far as I'm aware of.
13:14:59 <JohnnyL> Cale ok thanks
13:15:04 <kmc> JohnnyL, check http://www.haskell.org/haskellwiki/Haskell_in_industry
13:15:06 <kmc> i think none are listed
13:15:09 <jmv_> Thanks Cale, I'll keep that to recompile in my head when I'll read the necessary stuff
13:15:17 <Cale> JohnnyL: However, Tim Sweeney seemed really interested in using Haskell to write games.
13:15:31 <ddarius> Cale: If you provide a type signature, otherwise it will type albeit with the obviously suspect type: (a -> b) -> [c] -> [c]
13:15:41 <Cale> ddarius: right.
13:15:58 <Cale> Sometimes you can even catch infinite loops that way :)
13:16:12 <Cale> You end up with a type which is obviously much too polymorphic
13:16:20 <Cale> because the result never exists.
13:16:37 <kmc> jmv_, if you are interested in compile-time verification, read about languages like Agda, which allows you to express *any* property in the type and prove that it holds
13:17:19 <Peaker> ddarius: or the type a -> [b] -> [b] :)
13:17:43 <Peaker> since its just:  map f = foldr (:) []
13:17:51 <Cale> jmv_: Haskell's type system catches a lot of defects, but it does require the programmer to lean on it to some extent. There are certain library designs where type errors are more meaningful than others.
13:18:20 <kmc> catching errors with Haskell's type system also requires that you use it to full advantage
13:18:22 <jmv_> I get that
13:18:29 <kmc> e.g. newtype over type, custom types over tuples, etc.
13:18:43 <Alpounet> kmc, I guess that's what Cale meant by "lean on it"
13:18:46 <Peaker> btw, the "newtype" trick is also applicable in C (Wrap a type in a single-field struct)
13:18:53 <kmc> ah, yeah
13:18:55 <kmc> Peaker, cool
13:19:03 <Cale> and yeah, pattern match failure is bad, which is why we try to avoid any functions which fail to match all patterns -- though things like 'head' and 'tail' are occasionally quite useful when you know that a list is *certainly* nonempty, for example.
13:19:32 <Peaker> data [] a = [] | (:) { head :: a , tail :: [a] }
13:19:38 <Cale> hehe
13:19:43 <kmc> heh Peaker
13:21:10 <copumpkin> omg
13:21:37 <kmc> head :: [a] -> a; head xs = fst (unsafeCoerce xs :: (a, [a]))
13:22:43 <Cale> ghci> let head :: [a] -> a; head xs = fst (unsafeCoerce xs :: (a, [a]))
13:22:43 <Cale> ghci> head [1,2,3]
13:22:43 <Cale> Segmentation fault
13:23:24 <Peaker> hah
13:23:40 <Peaker> it would be nice to have a "safe Haskell" subset where you have "cast" but not "unsafeCoerce" or "unsafePerformIO"
13:23:47 <Peaker> some standardized sandbox
13:24:19 <Cale> It would be nice to require a special flag in order to compile a module which uses unsafePerformIO or unsafeCoerce.
13:24:22 <ben0x539> @type cast
13:24:23 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
13:24:33 <Cale> (a flag which can't be put into a pragma in the source)
13:25:21 <copumpkin> it would require PCC with a proof that you didn't use those functions :P
13:25:29 <Cale> Typeable is also a problem in that you can write fake instances of it.
13:25:40 <Cale> GHC shouldn't allow you to write your own instance of Typeable.
13:26:40 * sinelaw munches popcorn from his powerpop bowl
13:27:10 <Alpounet> haha
13:27:17 <sinelaw> best 15$ i ever spent
13:27:40 <sinelaw> better than an iPad, be sure of that!
13:27:50 <Peaker> Cale: if GHC derived Typeable on everything automatically, you could get a conflicting instance :)
13:27:52 <dolio> We should just get rid of Typeable and build in compiler support for some kind of runtime type information.
13:27:59 <Peaker> dolio: why?
13:28:08 <kmc> Cale, yeah, importing the "data constructor" for the Typeable dictionary is like importing unsafeCoerce
13:28:14 <dolio> 1) So you can't write unsafeCoerce.
13:28:25 <Cale> Peaker: Well, also you can turn on IncoherentInstances and write an instance for 'a'
13:28:35 <dolio> 2) So you can have type-reps of (constrained) polymorphic values without IncoherentInstances.
13:28:37 <kmc> but there's no way to export a class without allowing to write instances of it
13:28:37 <Peaker> dolio: The ability to write unsafeCoerce stems for the existence of IORefs, let-polymorphism, and unsafePerformIO
13:28:39 <Cale> and use that to write unsafeCoerce
13:29:23 <copumpkin> kmc: there are a couple of ways to do that
13:29:31 <dolio> Peaker: You can write instances of Typeable currently that give you unsafeCoerce.
13:29:35 <Cale> I agree with dolio on that. Typeable is a cute trick, but some sort of built-in type representation could do better.
13:30:22 <kmc> faster too
13:30:24 <Peaker> dolio: well, if you remove Typeable, you could still write unsafeCoerce. I think its nicer to forbid instances of Typeable than add a parallel/overlapping mechanism to the language itself (making it unnecessarily bigger)
13:30:27 <kmc> ghc already has info pointers for every type
13:30:48 <Peaker> kmc: surely if ghc is guaranteed that all typeable instances are ghc's, it could be just as fast?
13:31:06 <kmc> yeah
13:31:24 <dolio> Built-in support for type reps would simply be better than Typeable is capable of being.
13:32:00 <kmc> better than user-provided Typeable instances, sure
13:32:02 <dolio> Unless someone really revolutionizes type classes.
13:32:15 <kmc> but is there an interface better than the Typeable class itself?
13:32:27 <kmc> one can imagine simply typeOf :: a -> TypeRep
13:32:45 <kmc> if that's allowed, parametricity goes out the window
13:33:13 <kmc> the Typeable class constraint is a useful indication that your function might have stealth ad-hoc polymorphism
13:33:31 <dolio> You can keep a constraint.
13:33:47 <dolio> But making it a class, even an auto-derived class, limits it.
13:34:00 <kmc> so you'd introduce a new sort of type constraint?
13:34:04 <dolio> Even an incoherent-instance class, I think.
13:34:08 <kmc> it limits it because typeclass instances must be monomorphic?
13:34:19 <kmc> then let's invent polymorphic typeclasses ;)
13:34:40 <Peaker> dolio: what kind of extra freedom would you have from it being something other than a type-class?
13:35:27 <dolio> Peaker: Type classes only deal in monomorphic types.
13:35:38 <sillysausage> data Foo = Foo | Bar (Foo -> Foo) deriving Show -- compile error
13:35:58 <aavogt> how would you show a function?
13:35:59 <sillysausage> data Foo = Foo | Bar (Foo -> Foo) \n instance Show Foo --- evaluate Foo and it results in a stack overflow
13:35:59 <Peaker> dolio: I am not sure I understand what you mean
13:36:18 <sillysausage> is this a bug?
13:36:30 <Cale> sillysausage: No.
13:36:34 <MissPiggy> sillysausage seems fine
13:36:40 <dolio> Peaker: What if I want to wrap something of type "(forall a. Num a => a -> a) -> [Int]" in a Dynamic, and get something of that type back out?
13:36:43 <sillysausage> Cale: why does it happen?
13:37:11 <Cale> sillysausage: You haven't defined a definition of show or shows etc. so the mutually-recursive default definitions take effect.
13:37:35 <Peaker> dolio: Oh, that type cannot have a Typeable instance?
13:37:38 <Cale> sillysausage: and because they're mutually recursive and can't make any progress without a *real* definition among them, you get a stack overflow
13:38:05 <dolio> I'm pretty sure even Oleg's incoherent instances hack can't handle it.
13:38:06 <Peaker> dolio: Well, I think revolutionizing type-classes to support that sounds more attractive :)
13:38:06 <sillysausage> Cale: that makes sense
13:39:03 <dolio> Peaker: Well, that wouldn't be bad either, but I'm not holding my breath.
13:39:42 <sillysausage> Cale: I suppose I expected an error to say that it couldn't derive an instance. I guess it doesn't do a normal deriving procedure
13:39:51 <Vitka> @hoogle readFile
13:39:51 <lambdabot> Prelude readFile :: FilePath -> IO String
13:39:51 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
13:39:51 <lambdabot> System.IO readFile :: FilePath -> IO String
13:41:16 <Peaker> dolio: does supporting it raise problematic semantic issues, or mostly ghc implementation issues?
13:42:41 <dolio> I'm not sure it raises any issues, other than that no one's really thought about how it would work.
13:42:55 <dolio> But I'm not familiar with much work on type-case like stuff.
13:44:23 <shemale-magic> anyone using haskell for transaction big database in an enterprise?
13:45:23 <DiaZ> Not to be boring, but just to be sure, can someone look? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16848#a16848 i think it is fine, if u see something stupid please tell me
13:45:31 <Polarina> shemale-magic, I am sure someone does.
13:45:36 <dolio> Peaker: Part of the complication at least, is that polymorphic instantiation is implicit in Haskell.
13:46:20 <Peaker> dolio: you mean instance type variables are implicitly quantified?
13:46:38 <dolio> Peaker: So if I ask for the type of 'e :: forall a. a', should it give me a type rep representing that polymorphic type, or should it instantiate to some concrete type, and give me the type rep for that?
13:47:37 <dolio> Currently, the answer is that there is no type case (class instances, what have you) for such polymorphic types, so the answer is "instantiate", and it probably complains, because it doesn't know what to instantiate to.
13:48:23 <Peaker> dolio: I'd want it to represent the polymorphic type -- the other option sounds weird
13:49:27 <dolio> Peaker: I mean there's no explicit type application. If you're explicit about type passing, then it's obvious that 'e :: forall a. a' has that type, because any monomorphic instantiation of that would have to be written 'e@t' or something.
13:49:33 <MissPiggy> DiaZ: I say that you can do it better
13:49:40 <MissPiggy> DiaZ: define (==) using eval
13:49:49 <dolio> But in Haskell, that e@t is just written e.
13:50:15 <MissPiggy> DiaZ: well you already did but I mean, you can just say x == y  =  eval x == eval y
13:50:21 <MissPiggy> no need to divide it into cases
13:50:21 <dolio> Like, if 'e :: forall a. a' and 'f :: Int -> Int', I don't have to write 'f (e@Int)', I can just write 'f e'.
13:51:02 <Peaker> dolio: Well, if there's unification of a concrete type with a universally quantified one, that's a different case from "asking the type of", iiuc (typeOf?)
13:51:26 <arjanb> DiaZ: you can add 'deriving Show' to the data declaration instead of writing it by hand
13:52:34 <dolio> This also makes the type system more essentially impredicative, so to speak.
13:53:00 <Peaker> dolio: I don't know what "impredicative" means :)
13:53:05 <dolio> Hindley Milner and Haskell maintain a sort of conceptual divide that isnt' really spelled out very well in GHC.
13:53:33 <dolio> If it were more explicit, there'd be two different * kinds, in a way. *m and *p.
13:54:04 <dolio> *m is the kind of monotypes, like Int. And *p is the kind of polytypes, like forall a. a -> a.
13:54:44 <DiaZ> ok thanks, that case of the (==) well i'm really dumb xD lol, about the show i did it on purpose to see if i could do it
13:54:46 <copumpkin> Peaker: I think impredicative just means a definition that can refer to itself, but with things like sets it leads to russell's paradox and other evil (but I'm no expert)
13:55:04 <dolio> The idea being that the quantification in a forall only ranges over monotypes, although that isn't adhered to strictly.
13:55:25 <jlouis> copumpkin: yeah, impredicative is to define an object in terms of the objects themselves
13:55:29 <copumpkin> forallp a. a
13:55:38 <dolio> That is why you need ImpredicativeInstantiation for stuff like 'Maybe (forall a. a)', though.
13:57:02 <Peaker> dolio: I can imagine how it could complicate the ghc guys, but I don't see the semantic difficulty with allowing forall to quantify over all types
13:57:10 <dolio> Anyhow, currently you also only get class instances/type case on stuff built out of *m. What we're talking about would be like merging *m and *p back into a single *, as far as classes are concerned.
13:57:58 <Peaker> dolio: imho (admittedly not deeply thought-out) it seems like they shouldn't be separate
13:58:32 <dolio> Well, there are reasons to be wary of impredicativity, although probably not from a Haskell perspective.
14:01:00 <DiaZ> Thanks for who helped
14:02:59 <dolio> Anyhow, I'm not sure where I was even going with that line of thought. Just making a note.
14:03:08 <Alpounet> is the "last core problem" for parallelisation actually true ?
14:04:56 <Younder> Hi, anyone know how to backend tof open GL (Tesla's etc. ) is coming along?
14:05:32 <endojelly> which symbol would you use to denote function application?
14:05:41 <MissPiggy> no symbol
14:05:46 <sjanssen> endojelly: ' '
14:05:46 <MissPiggy> juxtaposition
14:05:46 <endojelly> instead of the f(x) notation or f x
14:05:51 <endojelly> sjanssen, not an option :(
14:05:55 <MissPiggy> f $ x = f x
14:05:56 <MissPiggy> in haskell
14:06:11 <endojelly> doesn't have to be ASCII
14:06:19 <endojelly> is $ common as application?
14:06:23 <MissPiggy> no
14:06:25 <MissPiggy> only haskell
14:06:39 <endojelly> is anything more common?
14:06:58 <MissPiggy> APPLY
14:07:00 <Peaker> Dijkstra has a paper where he uses some other symbol..
14:07:10 <tensorpudding> function application is usually given as function(x) in other languages
14:07:15 <MissPiggy> APPLY[F,X]
14:07:16 <tensorpudding> though lisp has apply
14:07:18 <copumpkin> including much math
14:07:25 <copumpkin> but not all math
14:07:28 <MissPiggy> Ev_x(f) in math
14:07:40 <copumpkin> allo MissPiggy
14:07:45 <MissPiggy> hey
14:07:54 <tensorpudding> you can only have apply if you allow functions as arguments to other functions
14:07:54 * hackagebot upload: tabular 0.2.2.1 - Two-dimensional data tables with rendering functions (EricKow)
14:08:09 <MissPiggy> copumpkin I faild et
14:08:12 <copumpkin> unless apply is a primitive or syntax
14:08:19 <tensorpudding> that too
14:08:21 <copumpkin> MissPiggy: ?
14:08:29 <Younder> apply really only makes sense if you have a seperate namespace for functions and variables
14:08:43 <zakwilson> Lisp apply is not the same as f(x). CL has funcall, which is (funcall #'f x), because it has a separate namespace for functions.
14:09:16 <Younder> ie. in Common Lisp you can write (let ((list (list 1 2 3)) list)
14:09:19 <tensorpudding> i suppose funcall is what i meant (i don't really know lisp but i knew it had a function like that)
14:10:07 <zakwilson> *some* Lisps have a function like that. Scheme and Clojure do not.
14:10:41 <MissPiggy> copumpkin at installing arch
14:10:46 <copumpkin> oh
14:10:55 <copumpkin> I'd like to try arch
14:11:03 <MissPiggy> me too! lol
14:11:07 <Gracenotes> I have it in a VM. no X server though.
14:11:08 <copumpkin> :)
14:11:16 <Younder> here list is a variable and (lisp...) is a function. You can always tell which is which because if it is in the first position it is a function and otherwise a variable.
14:11:16 <copumpkin> pff who needs X anyway
14:11:18 <tensorpudding> endojelly: does that answer your question?
14:11:39 <temoto> copumpkin, do you use Ywindow?
14:11:48 <copumpkin> temoto: I'm a macwhore
14:11:50 <Philonous> Do I have to do more than cabal install c2hs to get the c2hs libraries? It seems to only install the binary
14:11:50 <endojelly> tensorpudding, a bit, thanks
14:12:07 <Peaker> Younder: Its so hard for me to comprehend how people think a separate function namespace is a good idea
14:12:08 <dcoutts> Philonous: there are no c2hs libs as such
14:12:08 <lambdabot> dcoutts: You have 10 new messages. '/msg lambdabot @messages' to read them.
14:12:15 <Younder> I should mention that let is a special form and that this is why let ((list.. isn't seen as a function
14:12:16 <copumpkin> oh wow, dcoutts gets all the love
14:12:34 <dcoutts> copumpkin: na, I just havn't been checking my mail :-)
14:12:38 <temoto> copumpkin, ah that quartz thing is good, i guess. Too bad it's not open.
14:12:38 <Philonous> dcoutts: Oh, but the examples include a C2HS module
14:12:45 <copumpkin> :)
14:12:48 <knobo> After changing my .xmonad/xmonad.hs how do I apply the changes withoug restarting xmonad?
14:12:50 <copumpkin> temoto: yeah :/
14:12:54 * MissPiggy doesn't know what X is
14:13:00 <dcoutts> Philonous: right, c2hs bundles a C2HS module that you can use if you want
14:13:10 <tensorpudding> X11, that window manager thing
14:13:12 <Younder> Peaker, originally it was to reduce name clashes. This was invented long befor packages (your modules)
14:13:17 <dcoutts> for some marshaling utils
14:13:51 <Peaker> Younder: still, people nowadays defend that choice as viable today (which I guess is true for any design choice for any thing in use, no matter how horrible)
14:14:18 <sjanssen> MissPiggy: an X11 server is what most Unix systems use to display graphics
14:14:41 <temoto> MissPiggy, it's a graphic layer on top of linux/bsd/minix. Technically, it's a program that talks to video card and provides abstractions to you to draw stuff in hardware independent way.
14:15:05 <Peaker> an "X server" is basically a bridge connecting a terminal (keyboard, screen) to a bunch of "X clients" that all get partial access to that terminal
14:15:20 <tensorpudding> a program which uses the X server to provide a windowing environment is called a window manager
14:15:27 <Philonous> dcoutts: Should I copy it to my project folder or is there a way to install it system-wide?
14:15:33 <copumpkin> I may note that X got its server/client backwards
14:15:34 <Peaker> (through an interface that can be serialized over a network connection, too)
14:15:45 <dcoutts> Philonous: just copy it if you find you need it (you may not)
14:15:47 <temoto> X also includes remote access abstraction, so you can run ssh -X gedit on some server. So you will access its files but it is drawn on your side.
14:15:50 <Peaker> copumpkin: X is technically a server
14:15:52 <tensorpudding> some examples include KDE, GNOME, LXDE, Xfce
14:16:08 <temoto> LXDE?
14:16:11 <Younder> Peaker, it helps when writing macros. The chances of accidental capture of a variable is less. And.. It is sometimes nice to write list when I mean list ranther that lst like I would have to in scheeme.
14:16:15 <dcoutts> Philonous: it'd be silly for every package to depend on the c2hs tool just for one small collection of trivial functions
14:16:19 <tensorpudding> err, LDXE? i can't remember the name
14:16:31 <zakwilson> Peaker: today's justification is that without the separate namespace, there would be name collisions in macros. Pretty much every Lisp since CL has not copied that decision.
14:16:31 <Peaker> Younder: why not "xs" ? :)
14:16:41 <tensorpudding> Lightweight X Desktop Environment
14:16:45 <sjanssen> copumpkin: I don't think X11 uses the terms backward
14:16:57 <dcoutts> Philonous: and you don't even need to use the C2HS module itself, you can provide the required marshaling functions any way you like
14:17:01 <Younder> Peaker, In general I think it is real asset or hinder. It is just one of the many oddeties of this language.
14:17:04 <Peaker> zakwilson, Younder: Aren't there better solutions for macros? (hygeinic macros, etc)
14:17:13 <Philonous> dcoutts: Well, if the package uses c2hs anyway it would be nice to have all the standard marshallers at hand
14:17:20 <Peaker> Younder: I think it gets in the way of using higher order functions
14:17:22 <knobo> aha, just run xmonad with --restart
14:17:32 <copumpkin> sjanssen: well, its use of the terms is unintuitive in most cases... I'd say they should pick new terms for the ideas that don't act as false friends :)
14:17:40 <tensorpudding> desktop environment is what people call a platform that provides a ton of libraries and desktop programs which run on top of a window manager
14:17:42 <Younder> Peake, for scheme, yes. But they are much more complicated.
14:17:58 <Peaker> Younder: and complicates all the namespace related forms (e.g: let also needs letf, ...)
14:18:12 <temoto> [imaginable language] What do you think about this? f x = x + 1; g x = f; # so g 2 == 3. It's like closing over names you don't know yet.
14:18:21 <sjanssen> copumpkin: an X11 server is a server in just about every aspect: it waits for incoming connections from many clients on a socket
14:18:46 <tensorpudding> the confusion results when people conflate desktop environments with the operating system
14:18:47 <Peaker> temoto: I think points-free style achieves this more elegantly :)
14:18:47 <copumpkin> sjanssen: yeah, but the way people use it is backwards... it'd be like saying an ftp client is an ftp server because of how the ftp protocol works
14:19:01 <Philonous> dcoutts: Well, should one distribute the chs files and let the client run c2hs or is it preferred to c2hs the the source and distribute the result?
14:19:10 <Peaker> temoto: why not: g = f ?
14:19:16 <copumpkin> I connect to you asking you to connect to me, therefore I am the server
14:19:23 <temoto> Peaker, because then x is not bound.
14:19:32 <Peaker> temoto: it is, by f
14:19:34 <dcoutts> Philonous: it depends on whether the headers are platform dependent or not
14:19:39 <Peaker> temoto: or do you mean: f = x + 1 ; g x = f ?
14:19:47 <Draconx|Laptop> copumpkin, but the X server does not connect to clients and ask them to connect to it.
14:19:51 <dcoutts> Philonous: eg gtk2hs runs c2hs on the target and does not use any C2HS module.
14:19:51 <temoto> Peaker, yes, pretty much.
14:19:57 <Peaker> temoto: that smells of dynamic scoping rather than lexical scoping - which makes it harder to reason about programs statically
14:20:02 <jmv_> can I query the interpretor , asking e.g.   what are the functions that take 1 argument of list type ?
14:20:05 <copumpkin> Draconx|Laptop: no, but the clients do it through a side channel
14:20:05 <Younder> Peaker, It make the syntax more clumsy. But it doesn't prevent you from using higher order funtions. (function name) can be used to pass a function (or #'name). apply can apply a function on a list. ie (apply c (list 1 2 3)) means (c 1 2 3) or funcall (funcall c 1 2 3)
14:20:14 <temoto> Peaker, i knew it must have a name :)
14:20:22 <copumpkin> Draconx|Laptop: often through an ssh -X session or whatever
14:20:24 <sjanssen> copumpkin: what do you mean "side channel"?
14:20:25 <temoto> Peaker, thanks.
14:20:34 <tensorpudding> i thought i read that dynamic scope prevented you from making closures
14:20:37 <Peaker> Younder: I didn't say prevent, just gets in the way :)
14:20:51 <temoto> jmv_, no, but you can hoogle for that.
14:20:54 <sjanssen> copumpkin: actually, the most common use of X is over Unix domain sockets where the server and client run on the same machine
14:20:57 <Philonous> dcoutts: Ok, makes sense. Thanks.
14:21:05 <temoto> @hoogle [a] ->
14:21:05 <lambdabot> Parse error:
14:21:06 <lambdabot>   --count=20 "[a] ->"
14:21:06 <lambdabot>                    ^
14:21:10 <Peaker> Younder: All these things have been solved so much more nicely in Haskell, why would anyone want CL? :)
14:21:13 <temoto> @hoogle [a] -> a
14:21:13 <lambdabot> Prelude head :: [a] -> a
14:21:13 <lambdabot> Prelude last :: [a] -> a
14:21:14 <lambdabot> Data.List head :: [a] -> a
14:21:20 <temoto> jmv_, something like this.
14:21:28 <Draconx|Laptop> copumpkin, that's like saying that two hosts on a LAN communicate through a side channel because they communicate through a switch.
14:21:40 <Younder> Peaker, yes programmin haskell in Lisp would be a pain.
14:21:51 <copumpkin> sjanssen: in which case I think the client/server distinction isn't useful for the end-user... my basic point is that it's an implementation detail. We talk about ftp servers as things that serve up content despite the fact that the clients actually listen for connections
14:22:50 <copumpkin> Draconx|Laptop: no it isn't
14:23:08 <Younder> Peaker, typcally CL is functional in the way the handle data inn and out of functions, but applicative inside the function. Ie. side effect have to be explicitly avoided by the programmer.
14:23:18 <sjanssen> copumpkin: but the X11 server really is the server -- it does all the work
14:23:42 <Peaker> sjanssen: all the terminal-related work, not the computational work
14:23:48 <copumpkin> from the user's point of view, the client is serving up content and the X "server" is consuming it
14:23:55 <Peaker> I think its more about who initiates the connection
14:23:59 <Draconx|Laptop> copumpkin, ssh -X just forwards TCP traffic over the SSH connection.  It isn't any different from ssh -L to forward any other kind of traffic.
14:23:59 <copumpkin> the fact that the connection goes the opposite direction is irrelevant
14:24:11 <Peaker> copumpkin: well, content flows both ways
14:24:17 <copumpkin> Peaker: I said the conection
14:24:19 <sjanssen> copumpkin: "server" and "client" aren't user-facing terms anyway
14:24:31 <Draconx|Laptop> copumpkin, and this forwarding is not different from the kind of forwarding done by an ethernet switch.
14:24:37 <sjanssen> and the programmer needs to understand how things actually work, so we use terms that are accurate
14:24:41 <copumpkin> Draconx|Laptop: you're missing my point
14:24:42 <Peaker> Maybe #-blah ?
14:25:05 <sjanssen> yes, good call
14:25:23 <Draconx|Laptop> copumpkin, probably... can you explain why ssh -X forms a side channel?
14:25:46 <copumpkin> not in here
14:26:26 <BCoppens> copumpkin: side channel as in side-channel attack?
14:26:35 <copumpkin> nope, but not in here :P
14:27:39 <BCoppens> copumpkin: I'm only interested in them if they're security-related, so I'll shut up again ;)
14:27:48 <Philonous> dcoutts: Is there a way to tell c2hs that no marshalling is required? Should I just pass id as the marshaller ?
14:28:33 <dcoutts> Philonous: that would work
14:28:52 <Philonous> Thanks again
14:31:45 <Polarina> What's c2hs?
14:33:49 <kmc> @google c2hs
14:33:51 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
14:33:51 <lambdabot> Title: Manuel M T Chakravarty - C->Haskell
14:34:45 <Younder> For me the interest in Haskel is the abillity to efficiently use all 12 core and hopefully the testla as well. Coding this sort of thing in C is a real pain as it send to scatter program fragments to the 4 winds making maintenance a nightmare.
14:38:57 <Peaker> Younder: For me it is the high-level-ness (which I see as the closeness of the code to the spec/intent, rather than implementation details), type-classes, things like equational reasoning, richness of information you get out of types.. so many things :)
14:40:36 <Younder> Peaker, yes, it is a interesting language. Though I haven't figured out how to debug it beyond print and tests.
14:41:34 <kmc> how to debug Haskell?
14:42:02 <dolio> Just prove it correct.
14:42:09 <kmc> mostly by interactively evaluating functions
14:42:20 <Cale> Usually you remove bugs by trying to separate things into simpler parts until they can't be wrong anymore. :)
14:42:27 <Twey> Debug.Trace can be helpful, too.
14:42:49 <kmc> especially if you want to know when something is actually being evaluated
14:43:00 <Twey> Aye
14:43:07 <kmc> (or *if* it's actually being evaluated)
14:43:13 <Cale> Debug.Trace is useful when the inputs to a function get really complicated.
14:43:20 <kmc> which is not normally a source of correctness errors, but is often a source of performance issues
14:43:46 <Twey> kmc: Well, if non-termination is a performance issue :Ã¾
14:43:51 <kmc> heh
14:44:22 <Younder> Yes I have been playing with Isablell/Isaar/Haskabelle to proove some properties of the program say (transform transforn x) = x
14:44:24 <kmc> laziness can't make a program non-terminating that would have terminated under strict evaluation
14:44:36 <Peaker> Younder: debugging Haskell is more of a pain than debugging other languages, but there's so much less of it that overall there's still much less pain :)
14:45:02 <kmc> debugging Haskell is easier than debugging C or C++
14:45:08 <kmc> because of type safety
14:45:16 <kmc> however, most other popular languages have that
14:45:17 <Twey> I agree
14:45:20 <Twey> Also purity
14:45:20 <Peaker> kmc: I disagree.. "gdb" is just much better than anything I could find for ghc
14:45:30 <Polarina> Peaker, :)
14:45:32 <MissPiggy> Younder: link?
14:45:32 <Twey> Peaker: Bad comparison
14:45:38 <Peaker> debugging C is usually easier for me than debugging ghc
14:45:46 <Younder> But getting the types to line up can be a real pain. At least to a beginner like me.
14:45:57 <kmc> gdb is good for finding low-hanging fruit bugs, the kind that Haskell's types catch
14:46:10 <kmc> a tricky C bug is something that silently corrupts memory and then crashes later at an indeterminate place
14:46:11 <MissPiggy> <dolio> Just prove it correct. -- haha
14:46:11 <Twey> gdb wouldn't be all that useful for Haskell, anyway
14:46:16 <kmc> gdb is really not so helpful for those
14:46:20 <kmc> something like valgrind perhaps is
14:46:21 <Peaker> kmc: I agree -- the over-all pain with Haskell w.r.t is lower, but when you do debug, the pain is worse
14:46:21 <Twey> You'd be jumping around all over the place
14:46:35 <arw> nope. gdb is also good for the "the programmer thought wrong"-kind of bugs, which aren't visible in a type-error.
14:46:40 <Peaker> kmc: w.r.t debugging*
14:46:53 <Twey> arw: But we have GHCi for those.
14:47:03 <kmc> what do you mean by "the programmer thought wrong"?
14:47:09 <Peaker> kmc: I don't have silent memory corruption bugs in C
14:47:28 <Twey> kmc: Logic errors, I suspect
14:47:30 <kmc> Peaker, then you are very lucky, or you're smart *and* you only debug code written by you
14:47:36 <Peaker> kmc: I have a lot of "bracket" bugs (forgetting to release a mutex)
14:47:48 <Cale> Peaker: It depends on what you consider "debugging"
14:47:48 <Younder> kmc, that sound more historical than factual. Today's C systems have bounds checking on arrays, check that the stack is not corrupted and that memory is freed. (if compiled for debug)
14:48:18 <Peaker> kmc: I debug the C code written by me mostly, but some of my coworkers too -- we never had memory overruns or such.  We did have some thread wrongness which corrupted data structures, but never memory overruns
14:48:18 <Twey> So why are there still so many memory leaks in C programs?
14:48:25 <Twey> And overflows
14:48:30 <Younder> MissPiggy, http://www.cl.cam.ac.uk/research/hvg/Isabelle/
14:48:40 <MissPiggy> Younder I meant to your stuff
14:48:41 <arw> kmc: stuff like if (something) instead of if (! something) or if (foo || bar) instead of if(foo && bar).
14:48:46 <kmc> ah, yes
14:48:47 <MissPiggy> which haskell codes you have proved
14:48:52 <Peaker> Twey: I guess they are written by less experienced C programmers who use a different style.  We don't use malloc in C, for example
14:49:02 <Cale> If your program is designed in such a way that the only hope for understanding what's going on is to step through the execution one step at a time, then a whole bunch of things are wrong with how you've broken the problem up.
14:49:05 <kmc> meh, i'm not talking about memory leaks
14:49:07 <pikhq> Twey: No garbage collection, and people who can't do manual memory allocation.
14:49:07 <Younder> MissPiggy, http://www.cl.cam.ac.uk/research/hvg/Isabelle/haskabelle.html
14:49:17 <kmc> i'm talking about memory *corruption*
14:49:26 <ben0x539> Peaker: I am interested in your C methodology
14:49:41 <kmc> and the tools Younder mentioned are useful, but they stop far short from checking that every pointer is valid and every piece of memory is initialized
14:50:07 <MissPiggy> :(
14:50:09 <Peaker> kmc: I've had things like linked-list corruption due to 2 threads updating it at the same time, or refcounts that went out of sync, and stuff like that.  We are careful with our pointer arithmetic and memory management and indeed very few of us ever encountered memory overruns in our very large C codebase
14:50:24 <kmc> ah, that's good
14:50:41 <kmc> i sometimes have to debug C++ code written by people who do things like returning the address of an auto variable
14:50:45 <Peaker> ben0x539: Basically avoiding malloc (using custom bound slub allocators/memory pools for every resource) and not doing any fancy pointer arithmetic
14:51:07 <pikhq> Peaker: So, instead of malloc you *implement* malloc.
14:51:09 <kmc> that was pretty obvious once i knew which function to read
14:51:11 <pikhq> :P
14:51:15 <dons> MissPiggy: we did several automated proofs on xmonad's core structures
14:51:18 <dons> via Coq.
14:51:27 <MissPiggy> awesome
14:51:42 <Peaker> pikhq: Well, its not really malloc since: A) Each allocation has its own "tag" (which memory pool it uses) B) each pool has its upper bound.   Leaks are found quickly and localized easily
14:51:48 <BCoppens> dons: is there an article or so about that?
14:52:06 <dons> no, not yet.
14:52:07 <Peaker> pikhq: And memory overruns are also localized if they do happen (which they don't :-)
14:52:29 <pikhq> Peaker: So, malloc with a large number of heaps. :P
14:52:44 <Peaker> pikhq: Bound heaps of a constant allocation size, yeah
14:52:45 <jmv_> some people using http://eclipsefp.sourceforge.net/ , an eclipse plugin for haskell ?
14:52:58 <Peaker> pikhq: and also, as much as possible is pre-allocated statically, rather than from a dynamic pool
14:53:21 <BCoppens> dons: is it the StackSet.v proof only, or is there more?
14:54:10 <dons> BCoppens: that's it.
14:54:28 <dons> we also used Catch. though its not terribly formally sound, imo.
14:55:00 <pikhq> Peaker: There's a much easier way of doing it, y'know. Stick everything on the stack, use continuation-passing style. :P
14:55:29 <pikhq> ... And implement your garbage collector with the stack as the first generation of your generational garbage collector.
14:55:43 <Paczesiowa> can someone confirm that HList failure under 6.12 is caused by ghc bug involving EmptyDataDecls with type context being mistaken for GADT?
14:56:33 <BCoppens> dons: cool :)
14:57:06 <Peaker> pikhq: Heh, our purpose with our schemes is the ability to reason about the correctness of resource management - as well as localizing errors when they do happen
14:57:38 <Peaker> pikhq: (with an added bonus of performance, as most allocations are statically done, and the dynamic ones are O(1) for both alloc and free [freelists])
14:58:12 <BCoppens> Peaker: what kind of system is that code used in?
15:29:16 * hackagebot upload: failure 0.0.0.3 - A simple type class for success/failure computations. (MichaelSnoyman)
16:02:28 <gwern> @quote Hmm
16:02:28 <lambdabot> olsner says: hmm, so perl basically has all harmful features ever invented?
16:02:34 <gwern> @quote Hmm\.\.
16:02:34 <lambdabot> Berengal says: I'm going to write a module Hmm with a (.) operator in it, so I can go 'Hmm..' in my code
16:02:48 <gwern> @quote discrete.*math
16:02:48 <lambdabot> clarkb, says:  in CS they dont teach you to program...You learn Data Structures, Algorithms, Logic, Discrete Math, Language theory, etc and happen to pick up programming on the way
16:02:55 <gwern> @quote unboxes
16:02:55 <lambdabot> dons says: hey i love core. i dream about unboxes
16:03:07 <ivanm> gwern: hint: /msg lambdabot :p
16:03:11 <gwern> @quote the.*irony.*being
16:03:11 <lambdabot> kmc says: the irony being, the abstraction that gets the most complaining and general noise [from imperative programmers] is the one that captures imperative programming
16:03:22 <gwern> ivanm: actually, there's a good reason to not do this in privmsg; channel logs
16:03:34 <kmc> oh no i'm quoted again :/
16:03:46 <gwern> ivanm: this means that if all of lambdabot's state gets lost, I can restore it just by catting in all #haskell logs
16:04:00 <ivanm> gwern: :/
16:04:02 <gwern> at least, for @remembers
16:04:10 <mauke> meh, just grep for @remember
16:04:12 <gwern> (doing @quotes in public means I can grep for them later, though)
16:04:21 <ivanm> mauke: agreed
16:04:25 <gwern> mauke: and also @forgets too
16:04:41 <gwern> @quote Jack
16:04:41 <lambdabot> emu says: hijack the stack and take this compiler to Fun-land!
16:04:47 <gwern> @quote am.*Jack
16:04:48 <lambdabot> kmc says: i am Jack's monad operator
16:04:57 <gwern> I never got that fight club joke
16:05:04 <gwern> @quote feed.*trolls
16:05:04 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
16:05:10 <kmc> hahaha
16:05:13 <gwern> @quote a.*basic.*law
16:05:13 <lambdabot> arw says: ...and a basic law of haskell is, 50% of all documentation has to be monad tutorials :)
16:05:25 <gwern> @quote learned.*to.*speak
16:05:26 <lambdabot> bartek says: It took me 2 years of studying teachings of Oleg Kiselyov (who was raised among types, where he learned to speak their language), but finally, I have the solution.
16:05:33 <monochrom> The other 50% is combinator tutorials :)
16:05:36 <Twey> Hahaha
16:05:39 <gwern> that was a funny blog post, even though I dislike exceptions
16:05:48 <gwern> @quote milliolegs
16:05:48 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
16:06:06 <gwern> @quote Enterprise.*variant
16:06:06 <lambdabot> DRMacIver: says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprise variant functors. Commutative UML diagrams.
16:06:16 <gwern> @glish
16:06:16 <lambdabot> Maybe you meant: flush list
16:06:27 <gwern> oh come on, flush is way closer than 'list'
16:06:28 <mauke> @slush
16:06:29 <lambdabot> Not enough privileges
16:06:41 <jmcarthur> dang. i remember i asked here a long time ago about why rewrite rules are not defined generically for more type classes, and i mentioned fmap f . fmap g = fmap (f . g) as a case where i couldn't imagine a case where applying the rule would harm performance
16:06:45 <mauke> @slush
16:06:47 <gwern> @fluri
16:06:47 <jmcarthur> but now i thought of one :\
16:06:58 <kmc> jmcarthur, cool, what's the example?
16:07:17 <sjanssen> jmcarthur: GHC has trouble matching rules that are overloaded on classes
16:07:19 <gwern> jmcarthur: you can do rewrite rules on typeclasses?
16:07:31 <jmcarthur> gwern: doesn't Arrow have some?
16:07:32 <Cale> gwern: depends on how it measures distance... glish -> lish -> list, glish -> flish -> flush
16:07:56 <mauke> @flunk
16:07:56 <gwern> Cale: that's broken, though - g is closer to f than l
16:08:14 <ddarius> It's replaces, deletions, and insertions.
16:08:23 <jmcarthur> kmc: this particular example requires constraint families. if the functor is Set then the first fmap could reduce the size of the Set, meaning the second fmap doesn't have to be applied to as many elements
16:08:37 <jmcarthur> kmc: but the rewrite rule would mean that both functions are applied to all elements
16:08:38 <ddarius> @google "Levenschtein distance"
16:08:39 <lambdabot> http://en.wikipedia.org/wiki/Levenshtein_distance
16:08:39 <lambdabot> Title: Levenshtein distance - Wikipedia, the free encyclopedia
16:09:02 <mauke> @eval 1/0
16:09:09 <kmc> @run 1/0
16:09:10 <lambdabot>   Infinity
16:09:15 <kmc> @run 1 / (0 :: CReal)
16:09:19 <lambdabot>   mueval-core: Time limit exceeded
16:09:32 <kmc> > let x = 0.0/0.0 in x == x
16:09:33 <lambdabot>   False
16:09:46 <mauke> @oval square
16:09:58 <jmcarthur> sjanssen: really? that's a shame :( but then again, maybe it's not so bad considering the possibility that it's not necessarily always a good thing?
16:11:17 <ivanm> jmcarthur: ummm.... first of all, Set isn't an instance of Functor
16:11:22 <ivanm> because of the Ord constraint
16:11:42 <ivanm> even ignoring that, then that (the size of the Set shrinking) disobeys the Functor laws
16:12:01 <Cale> ivanm: hm? It wouldn't disobey the functor laws.
16:12:20 <ivanm> Cale: I thought fmap wasn't meant to change the structure of the data type
16:12:36 <ivanm> and if the Set shrank, doesn't that change the structure?
16:12:38 <Cale> Well, fmap f . fmap g = fmap (f . g) and fmap id = id
16:12:50 <Cale> But those are the only laws :)
16:12:55 <kmc> "don't change the structure" is an informal interpretation of a law
16:12:58 <ivanm> true
16:13:01 <ivanm> kmc: fair enough
16:13:11 <MissPiggy> kmc, hmmmm
16:13:14 <MissPiggy> interesting thought
16:13:23 <ivanm> I suppose there's nothing there that forces you to actually make the structure the same
16:13:25 <MissPiggy> can you make that formal?
16:13:28 <ivanm> *keep
16:13:29 <MissPiggy> like what is structure?
16:13:43 <kmc> categories ;)
16:13:44 <Cale> It's sort of *because* we can't have qualified types that makes "don't change the structure" a good approximation of the laws.
16:13:45 <ivanm> MissPiggy: my interpretation was, the chain of constructors, etc. remains the same
16:13:53 <ivanm> Cale: right
16:14:06 <MissPiggy> what is a qualified type?
16:14:10 <ivanm> Cale: because to be able to do anything with the types being "stored" in the structure implies a qualified type
16:14:21 <ivanm> MissPiggy: well, Set a requires that a is an instance of Ord
16:14:25 <ivanm> hence it's qualified
16:14:27 <ivanm> @type Set
16:14:28 <kmc> if you wanted to require "not changing the structure" you might require that all functors are bijective
16:14:28 <lambdabot> Not in scope: data constructor `Set'
16:14:32 <ivanm> @hoogle Set
16:14:33 <lambdabot> module Data.Set
16:14:33 <lambdabot> Data.Set data Set a
16:14:33 <lambdabot> Network.Browser setAllowBasicAuth :: Bool -> BrowserAction t ()
16:14:51 <mauke> :t S.singleton
16:14:52 <lambdabot> forall a. a -> S.Set a
16:14:53 <kmc> @kind Set
16:14:54 <lambdabot> Not in scope: type constructor or class `Set'
16:14:55 <ivanm> kmc: really? the actual function you're fmapping might not be bijective
16:15:09 <ivanm> @kind S.Set
16:15:10 <lambdabot> * -> *
16:15:13 <kmc> yes, but the functor itself should be
16:15:20 <kmc> as a map on types and functions
16:15:31 <ivanm> ignoring the actual values you mean?
16:15:56 <kmc> i mean that a functor F maps every type T to a type (F T) and every function f to a function (fmap f)
16:16:14 <ivanm> kmc: OK
16:16:27 <kmc> and so what if we require this mapping to be invertible
16:16:39 <kmc> (which is unrelated to whether any particular f is invertible)
16:16:41 <ddarius> That would more or less come out to meaning F is (part of) an equivalence of categories.
16:16:51 <ddarius> F is full and faithful and essentially surjective on objects.
16:16:57 <ivanm> kmc: right, I thought you mean we should be able to invert the fmap
16:17:07 <kmc> ivanm, yeah, so did i initially ;)
16:17:14 <ivanm> heh
16:17:15 <kmc> but i decided that was not reasonable
16:17:18 <ddarius> ivanm: He does, where fmap : Hom(A,B) -> Hom(FA,FB)
16:17:35 <kmc> every Functor instance is an endofunctor of Hask
16:17:45 <ddarius> That doesn't mean (fmap f) is invertible
16:17:53 <Philonous> is nullPtr = (void*)0 in c ?
16:18:13 <kmc> probably.  what type has nullPtr?
16:18:17 <ivanm> methinks this guy doesn't know what he's talking about: http://jfm3-repl.blogspot.com/2010/01/associativity-and-muse.html
16:18:26 <mauke> @hoogle nullPtr
16:18:27 <lambdabot> Foreign.Ptr nullPtr :: Ptr a
16:18:30 <Philonous> kmc: Ptr a
16:18:43 <mauke> Philonous: then it's (a *)0 for any a
16:18:50 <kmc> err, in your C code
16:19:06 <Philonous> mauke: Is that guaranteed? I want to marshall an 0-terminated array of CStrings
16:19:18 <kmc> heh, «typedef (forall a. a) void;»
16:19:41 <kmc> that's a surprising confluence between C and Haskell
16:19:50 <ben0x539> It is not guaranteed that the bit pattern that represents (void*) 0 in memory is all zeroes
16:19:53 <ben0x539> hope this helps
16:19:58 <kmc> that's sad
16:20:12 <mauke> Philonous: the FFI assumes some things about the C implementation
16:20:32 <mauke> like that all data pointer types are the same, basically
16:20:39 <ben0x539> Philonous: Surely there is a function for that already
16:21:05 <ben0x539> Hm. I was thinking off
16:21:11 <ben0x539> @type pokeArray0
16:21:12 <lambdabot> Not in scope: `pokeArray0'
16:21:15 <ben0x539> but I guess that does not help at all
16:21:16 <Philonous> ben0x539: I was trying to use peekArray0 in concert with peekCString,
16:21:47 <Philonous> Problem is, I need a Ptr CChar thats all zeroes as a terminator
16:22:24 <mauke> what
16:22:27 <mauke> what do you mean by "all zeroes"?
16:22:39 <Philonous> It's bits are all zeroes
16:22:46 <mauke> why?!
16:23:11 <Philonous> Because I get a 0-terminated array of char*
16:23:22 <kmc> can't you just compare to nullPtr?
16:23:39 <mauke> Philonous: (char *)0 is not all bits zero
16:23:42 <Philonous> kmc: That was my question, but apparently nullPtr is not 0
16:23:49 <mauke> WHAT
16:23:51 <ben0x539> Neither is a C null pointer
16:23:54 <kmc> that's madness
16:23:54 <mauke> Philonous: what do you mean by "0"?
16:24:02 <ben0x539> It is a pointer that is initialised from a 0 integer literal
16:24:06 <kmc> i would hope that nullPtr is equal to whatever "null pointer" means on your platform
16:24:08 <ivanm> kmc: ssshhh.... let Philonous explain what he wants first, and _then_ make fun of his ideas!
16:24:09 <kmc> in C
16:24:09 <ivanm> ;-)
16:24:19 <ben0x539> Use nullPtr, that will be the right thing until proven otherwise
16:24:55 <Philonous> ok
16:24:57 <Philonous> thanks
16:27:36 <CalJohn> i'm not a C expert, but I thought it was bad practice to use the 0 null pointer literal over NULL
16:27:41 <Philonous> Btw I wasn't the one how brought up the idea that (void*) 0 is all bits zeroes ;)
16:28:30 <mauke> Philonous: you were the one who wanted to make a pointer with all bits zeroes
16:28:39 <ben0x539> CalJohn: In C, I believe you need an explicit cast to go from 0, type integer, to a null pointer
16:28:40 <Philonous> Nope, I wanted (void*) 0
16:28:51 <ben0x539> CalJohn: But you still start with the number 0 at some point
16:28:55 <mauke> <Philonous> Problem is, I need a Ptr CChar thats all zeroes as a terminator
16:29:14 <mauke> Philonous: so which is it?
16:29:15 <Philonous> mauke: Yeah, after someone else mentioned that.
16:29:31 <mauke> what?
16:30:17 <CalJohn> ben0x539: it's generally unclear, though
16:30:50 <ben0x539> I wonder whether it is guaranteed that converting a null pointer back to int will result in 0
16:31:03 <mauke> ben0x539: no
16:31:07 <ben0x539> I love C
16:31:31 <mauke> converting a 0 int to a pointer will not necessarily give you a null pointer either
16:32:14 <ben0x539> Right
16:32:21 <mauke> as in int i = 0; void *p = (void *)i;  // ???
16:32:23 <ben0x539> Only a 0 literal?
16:32:26 <ben0x539> Craz
16:32:26 <ben0x539> y
16:32:39 <CalJohn> ben0x539: by the way, NULL is exactly the same semantically as 0, so i'm not sure why you where talking about type casting difference before
16:32:50 <mauke> ben0x539: no, not a literal
16:32:57 <mauke> it just has to be a constant
16:33:12 <ben0x539> I am not sure I am familiar with the difference in C
16:33:23 <ben0x539> Does that mean that (void*) (42 - 42) == NULL?
16:33:24 <mauke> CalJohn: not exactly the same because NULL + NULL may be invalid
16:33:27 <mauke> ben0x539: yes
16:33:29 <ben0x539> Neat
16:33:43 <kmc> again, madness
16:34:18 <mauke> #define NULL ((void *)(sizeof *"" / 2))  // silly but valid
16:35:54 <Dashkal> I may be misunderstanding Control.Concurrent.  Do I have to use forkOS to get true concurrent processing (one on each core)?
16:35:59 <kmc> Dashkal, no
16:36:03 <theorbtwo> Er, the C99 spec, IIRC, says that NULL must be (void*) 0.  However, (void*) 0 needn't mean all bits are zero.
16:36:13 <kmc> you have to use forkOS if you are FFI-calling some library that cares about "which thread" its calls come from
16:36:19 <mauke> theorbtwo: no, NULL is either 0 or (void *)0
16:36:23 <CalJohn> Dashkal: no
16:36:29 <kmc> for concurrency within Haskell it suffices to use forkIO.  the -N option to the GHC runtime selects how many OS threads there are
16:36:30 <theorbtwo> That said, this is really a question for ##c.
16:36:39 <Dashkal> ahh, perfect.  danke
16:36:45 <ben0x539> Can NULL be 0 in a conforming C implementation?
16:36:48 <kmc> (if you want parallelism rather than concurrency, you don't even need to spawn threads)
16:36:50 <ben0x539> As opposed to C++, etc
16:37:04 <quuxman> here's an uninformed question: is there anything out there about a type system that represents concurrency? So for example, forkIO would have a type signature that represented two threads of execution
16:37:06 <mauke> ben0x539: yes (in C++ it is required to be 0)
16:37:28 <Dashkal> That's what I hoped was happening.  And it's concurrency I want, not parallelism.  One thread handling socket IO, one handling the actual engine.
16:37:37 <quuxman> Is that a non-sensical idea? Types represent data, not computation in Haskell
16:37:41 <Dashkal> actually, since I don
16:37:42 <ben0x539> Is that not going to mess up when you call a function without a prototype with NULL on a platform where NULL is not all bits zero?
16:37:49 <Dashkal> 't see select, probably N threads for IO
16:37:54 <kmc> quuxman, not in Haskell
16:38:03 <kmc> (not in haskell would its type represent concurrency)
16:38:04 <c_wraith> daskal: the IO manager does select for you
16:38:05 <mauke> ben0x539: yes, and it might mess up anyway because different types
16:38:21 <ben0x539> I am never calling var-args functions again
16:38:24 <theorbtwo> The silly thing is that the C specs allow for a good many things that you will never see on any real implementation of C.
16:38:24 <quuxman> kmc: right. Are there any languages out there that atempt that, or articles that talk about it?
16:38:30 <mauke> ben0x539: different pointer types may have different sizes/storage formats/null pointers, but the haskell FFI doesn't really care :-)
16:38:43 <kmc> quuxman, well, the relationship between STM and IO in Haskell says something about concurrency
16:38:45 <Dashkal> c_wraith: Where should I look for documentation on that?  I have n TCP sockets connected and I need to process data from them.
16:38:56 <kmc> namely, by converting an STM value to an IO value you make it into an atomic operation
16:38:57 <ben0x539> :O
16:39:10 <c_wraith> dashkal: it basically just works.  You don't need to worry about the details
16:39:10 <kmc> Dashkal, just do blocking IO in many threads
16:39:36 <kmc> the details are going to get better soon :)
16:39:42 <Dashkal> alrighty.  n threads is just fine.  I have figured out that forking 100 haskell threads /= forking 100 os threads.
16:39:51 <kmc> yes
16:39:56 <kmc> the GHC RTS can handle millions of threads
16:40:03 <kmc> Dashkal, did you see http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
16:40:05 <c_wraith> yeah, haskell does green threads with its own scheduling.
16:40:09 <kmc> well, GHC does
16:40:10 <Alpounet> btw that feature is really great
16:40:15 <ben0x539> mauke: Oh, you can only convert between pointers that share the same alignment, or something?
16:40:16 <c_wraith> err, yes, ghc.  not haskell
16:40:20 <ben0x539> I was not really aware of that.
16:40:28 <quuxman> kmc: I was thinking it would be quite useful if you could somehow represent forking and blocking with the type system
16:40:28 <kmc> the design of the Control.Concurrent API is careful to not constrain implementations
16:40:30 <mauke> ben0x539: huh?
16:40:35 <Dashkal> I've also realized that I'm tied to GHC thanks to some things I need (thread waiting)
16:40:38 <mauke> ben0x539: in general you can't convert between pointers
16:40:46 <Dashkal> Not that I really intended to use HUGS, but I like being portable
16:40:49 <ben0x539> I mean, convert and convert back and get back the same result.
16:40:49 <kmc> yeah, GHC is the best Haskell implementation for most things
16:40:57 <kmc> and some GHC extensions are pretty vital for real-world stuff
16:41:14 <ben0x539> I was wondering how that could work if pointer types have differing sizes
16:41:29 <mauke> ben0x539: I think that's only guaranteed for void * and char *
16:41:29 <Cale> None of the concurrency stuff in GHC is really standardised in any way.
16:41:30 <Dashkal> So far I haven't had to use any extensions in my own code.  A library I'm making use of, but not mine. So far.
16:41:39 <ben0x539> apparently
16:41:45 <dons> Cale: well, somewhat. there are published semantics/apis.
16:41:45 <Dashkal> *nods* That's really why tying to GHC is bothering me.  No standards.
16:41:52 <Cale> dons: yeah
16:42:05 <dons> its not like it is just hacked together in secret.
16:42:19 <ben0x539> Sorry for bringing my excitement for C here. I shall no longer speak in this dark tongue in this place.
16:42:23 <ddarius> Dashkal: The basic concurrency stuff has been there for over 10 years without any major (external) changes.
16:42:24 <dons> other implementations could happily implement preemtive threading if they wished, ala concurrent haskell 1995.
16:42:29 <ddarius> Dashkal: I think you're safe there.
16:42:29 <Dashkal> Still, all the concurrency stuff is localized to one part of the program, so I'll be fine if things change a little.
16:42:40 <Dashkal> Isn't there a new haskell standard coming soon?
16:42:50 <kmc> Dashkal, i'm glad you care about standards.  too many programmers are just like "well i'll write whatever code Perl 5.10.1 accepts"
16:42:57 <kmc> Haskell 2010 is already out
16:43:02 <c_wraith> I doubt any of the rolling standards will diverge from what GHC does.  too much.
16:43:09 <Dashkal> mmm, I should have a peek at that sometime
16:43:10 <dons> the LANGUAGE pragmas keep you honest anyway
16:43:13 <kmc> for the most part it simply codifies a few of the more conservative GHC extensions
16:43:17 <ddarius> Dashkal: There's nothing to see there.
16:43:22 <dons> forcing you to say up front - and think - about what you're doing.
16:43:40 <kmc> anyway, if you are looking for a GHC-independent specification of some of GHC's extensions, the place to look would be the haskell-prime trac wiki
16:43:44 <Dashkal> *nods* I really need to have a long look at the various extensions
16:44:22 <Dashkal> But most of the code is pure haskell 98 anyway, so I'm not terribly concerned.  The messy threading stuff is the worst of it.
16:45:05 * glguy remembers good old {-# OPTIONS -fglasgow-exts #-}
16:45:05 <Dashkal> I say messy without judgement of haskell's concurrency libs, I'm also a java dev.  *shudder*
16:45:07 <kmc> if you use module names with . in them you are not writing Haskell 98 ;)
16:45:17 <ben0x539> I was about to ask.
16:45:19 <kmc> how did hierarchical modules not make it into the original spec?
16:45:28 <dons> glguy: back in my day ...
16:45:36 <dons> we had to put that in the HC_FLAGS build.mk
16:45:40 <ben0x539> kmc: Maybe they did not like the idea of making . special
16:45:43 <monochrom> hahaha
16:45:46 <kmc> hehe
16:45:48 <dons> you kids and your pragmas
16:45:58 <kmc> i think they disallowed . in module names
16:46:08 <Dashkal> I also saw mention of type constructors with multiple parameters as non-standard?  Or did I misunderstand?
16:46:16 <kmc> Dashkal, type classes with multi params
16:46:17 <kmc> are nonstandard
16:46:25 <ben0x539> I assumed module names were restricted to valid identifiers anyway
16:46:27 <dons> Dashkal: code in the Haskell you need to, in order to get the job done.
16:46:27 <Dashkal> ahh, type classes.  gotcha
16:46:33 <kmc> . in module names is not really special; it's an implementation detail whether they correspond to directories or whatever
16:46:38 <dons> all the extensions are documented and flagged with -XFoo flags
16:46:47 <ben0x539> It is special in that it messes with the . operator, I mean
16:46:50 <Dashkal> dons: Absolutely.  I just want to really understand _why_ I'm deviating before I do.  When I must, *shrugs* so be it.
16:46:50 <dons> so you'll be safe.
16:46:57 <ben0x539> because suddenly module names are not \w+ anymore
16:46:58 <dons> right. the -X flags help there.
16:47:07 <dons> things won't compile, and you can investigate why.
16:47:19 <kmc> ben0x539, ah that's true
16:47:30 <Dashkal> For example, this design is getting nowhere without threadDelay.
16:47:30 <kmc> GHC also changes the syntax for module-qualified infix operators for this reason
16:47:47 <ddarius> kmc: The Hierarchical Modules proposal was not ratified before the Haskell committee disbanded.
16:47:57 <dons> Dashkal: you should feel safe with Control.Concurrent.* -- its only 15 years old now
16:48:01 <kmc> grr, committees
16:48:23 <Dashkal> heh, fair enough
16:48:29 <dons> STM is 6 years old. Clojure / F# are all blips compared to these APIs.
16:48:30 <kmc> Haskell has no BDFL
16:48:42 <Dashkal> I don't really have a grasp of how stable various things are yet.  I'm still very new to the language.
16:49:04 <dons> 'sok. generally people will yell at you if you use something super weird
16:49:21 <ddarius> dons: Kids these days are all about those GADTs and type families...
16:49:24 <ben0x539> kmc: As a dirty C++ fanboy, I still think they should have gone with :: for hierarchical modules and come up with something else for type signatures
16:49:27 <Dashkal> I've noticed that, so I tend to bring up designs that start to smell.
16:49:29 <kmc> haskell is too old to be popular :/
16:49:33 <dons> always with the GADTs!
16:49:33 <kmc> we should change the name and not tell anyone
16:50:03 <Dashkal> Heh, now that I've been converted to purity, I can't go back.  Java code is fugly now.
16:50:11 <damd> haskell needs a new website to be popular
16:50:16 <ddarius> Dashkal: Write pure Java code.
16:50:18 <kmc> maybe once the GHC LLVM backend is ready
16:50:22 <Dashkal> ddarius: I fully intend to
16:50:38 <ben0x539> Monads in Java must be fun
16:50:40 <dolio> I suspect pure Java code will still be fugly.
16:50:45 <Dashkal> But there are haskell tricks that Java, no matter how many extends they add, cannot do cleanly.
16:50:57 <ben0x539> such as defining operators
16:51:02 <kmc> "a powerful multiparadigm language with excellent support for concurrency and a blazing fast multiplatform LLVM-based compiler"
16:51:08 <kmc> everyone on reddit will go crazy for it
16:51:23 <damd> as if anyone actually programs concurrent applications
16:51:28 <kmc> hehe
16:51:31 <ddarius> dolio: Well you don't need to go to Haskell to find a language that makes Java look fugly.
16:51:46 <dolio> Yes, that's true.
16:51:48 <damd> hasn't concurrency been "crucial in the next few years" for like five years already?
16:51:49 <dons> damd: ...
16:51:58 <dons> damd: multicore parallelism
16:52:00 <kmc> damd, el oh ell
16:52:01 <dons> not concurrency.
16:52:07 <kmc> well i said "concurrency"
16:52:09 <kmc> both are important
16:52:15 <kmc> anyway, damd is just having a bit of fun with us
16:52:16 <dons> damd: never written a web server. massively concurrent.
16:52:30 <dons> and lots of people write concurrent haskell programs (forkIO is pretty common)
16:52:39 <ben0x539> damd: I did my homework in C++ class in a concurrent way a few times
16:52:42 <kmc> Java isn't ugly, it's more like a featureless gray expanse
16:52:44 <Dashkal> damd: Desktop apps aren't dead, and anythign with a gui requires two threads at least to be responsive and non-trivial (well, not strictly true, but such a pita in one thread)
16:52:48 <dons> now, parallel applications are relatively few, though they pop up more and more.
16:52:50 <damd> it's way too easy to troll this channel
16:52:54 <ben0x539> Turns out I was wasting more time on synchronisation than I gained from using more than one core, but, well.
16:52:56 <dons> don't do that then.
16:53:08 <damd> i wasn't even trolling, i was joking
16:53:13 <mauke> damd: parts of the channel enjoy it
16:53:21 <Dashkal> mmm, breaking up long tasks into many many small portions and scheduling them in the event loop.
16:53:23 <dons> it would have been funny if you hadn't mixed up concurrency and parallelism
16:53:28 <kmc> hey guys, how do i convert an IO String to a String
16:53:29 <dons> which is kind of a faux pas in #haskell
16:53:34 <dons> kmc: :)
16:53:39 <damd> dons: i didn't mix them up, kmc *said* "concurrency"
16:53:41 <mauke> kmc: unsafeCoerce
16:53:43 <kmc> i hear monads are real important
16:53:53 <Dashkal> I'm still not fully clear on the difference, except that concurrency is where the threads do different things entirely.
16:53:55 <kmc> i hear that a monad is like a burrito
16:54:07 <ddarius> mauke: I usually recommend (const "foo")
16:54:12 <damd> Dashkal: concurrency as i understand it is "the impression of parallelism"
16:54:17 <dons> THE OFFICIAL LINE: http://ghcmutterings.wordpress.com/2009/10/06/parallelism-concurrency/
16:54:19 <kmc> Dashkal, you can evaluate deterministic code in parallel, as an implementation detail
16:54:21 <dons> stay on message, peoples.
16:54:35 <kmc> or you can write code with *semantics* of multiple things going on at once
16:54:39 <dons> right
16:54:45 <mauke> kmc: show
16:54:46 <kmc> parallelism vs. concurrency resp.
16:55:15 <Dashkal> reading before commenting further
16:55:30 <mauke> > show (putStrLn "hello, world")
16:55:31 <lambdabot>   "<IO ()>"
16:55:57 <ddarius> mauke: That just leads people into asking why that doesn't work in their GHCi.
16:55:59 <mauke> > fix print
16:56:01 <lambdabot>   <IO ()>
16:56:01 <Dashkal> Before I write the real mechanics of the threading I'm about to do, I need a much better grasp on STM.
16:56:12 <dons> oh, you're planning on using STM?
16:56:23 <Dashkal> not planning, considering as an option
16:56:26 <dons> i'd say - learn that after you learn basic preemptive concurrency first.
16:56:44 <Dashkal> The current design is to use channels and just have socket IO in other threads with a single engine thread.
16:56:45 <dons> learn forkIO and shared memory locks via MVars. then look at STM
16:56:47 <mauke> STM = thread-safe variables
16:56:55 <kmc> the RWH chapter on STM is good
16:56:55 <Dashkal> But that isn't nearly maximal use of multiple cores
16:57:32 <Dashkal> From my (currently VERY limited) understanding of STM, if I were to use it naievely, it wouldn't offer me anything since only one thread could do anything at a time.
16:57:48 <Dashkal> I'm not so egotistical to actually believe that's the case, so I need to learn more :P
16:57:57 <mauke> why only one thread?
16:58:33 <Dashkal> Hrm, a little detail will help. sec
16:59:06 <c_wraith> dashkal: STM basically checks on commit that no TVar you read from has been written to from another thread.  If it has, it restarts the transaction.  It's very much like database rollbacks
16:59:36 <kmc> Haskell's STM is optimistic and lockless
16:59:42 <Dashkal> here's my core data structure for game state: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16852#a16852
16:59:51 <kmc> if you have many threads in a tight loop hitting the same data, it will perform terribly
16:59:53 <Dashkal> I'm not sure how to interleave MVars into that so STM becomes a net gain.
16:59:55 <c_wraith> dashkal: if two threads are concurrently updating different TVars, they don't interfere with eacc other
16:59:57 <kmc> because they will step on each other
17:00:01 <kmc> you don't use MVars with STM
17:00:03 <kmc> you use TVars
17:00:07 <Dashkal> erm, TVars.  sorry
17:00:12 <kmc> (or perhaps TMVars, but less commonly)
17:00:38 <Dashkal> basically there's one instance of World kept in a state monad.
17:01:12 <Dashkal> as it is, only one thread can operate on it at a time.  To break out of that, I need to somehow break up the structure.  I'm not sure how.
17:01:16 <kmc> state monad actions are sort of inherently single-threaded
17:01:28 <quuxman> what if you could pause an IO monad?
17:01:41 <kmc> quuxman, what do you mean?
17:01:41 <gwern> you mean, sleep?
17:01:48 <Dashkal> I'm not married to the state monad (or anything else, really).  This is jsut the only design I've so far been capable of coming up with
17:01:53 <mauke> quuxman: there is only one IO monad
17:02:01 <kmc> Dashkal, you probably want to turn your monadically-threaded functional state into real mutable state
17:02:04 <kmc> which could be STM stuff
17:02:06 <quuxman> kmc: a continuation. So instead of return, you could say continue, which returns a new IO type that contains the rest of the actions
17:02:18 <quuxman> er, same type, but new IO value
17:02:18 <kmc> quuxman, you can already do that
17:02:24 <kmc> IO actions can yield other IO actions
17:02:26 <Dashkal> mmm, going back to mutability...  I'm not certain I'm ready to do that.  I have many many bad habits from Java.
17:03:23 <Dashkal> But yes, turning it into a fully mutable tree would allow concurrent modification.  I already worked otu the rules for when two threads can operate at the same time.
17:03:26 <ddarius> Dashkal: Concurrency almost always implies mutability.
17:03:55 <Dashkal> ddarius: Almost.  The current design requires no mutable variables.  Just a state monad in a forever loop.
17:04:15 <Dashkal> Actually, StateT GameState IO
17:04:20 <ddarius> Dashkal: With concurrency mechanisms, you can model mutable variables.
17:04:32 <ddarius> Dashkal: And separate processes seem like mutating objects.
17:05:42 <Dashkal> If I were to make each WorldEntry instead a MVar WorldEntry, I'd have a fully mutable tree, but then I'm abck to having to handle all the lovely locking and such to maintain validity.  STM, OTOH, may save me from that.  I need to understand it better.
17:06:24 <Dashkal> Maintaining validity was a pain enough as it was pure.  I kept getting parents without links to their children or vice versia.
17:06:31 <ddarius> Dashkal: You don't manipulate locks with STM, so it would certainly save you from that, but you can still have concurrency bugs.
17:06:35 <monochrom> Dashkal: I'll share with you my recent example. Several threads access the same map (as in Data.Map), which is a tree internally. I just have one MVar referring to the current tree. (You could use TVar, same deal.) To change, I takeMVar the old tree, then putMVar the new tree. Note there is no race condition. Another thread gets the old snapshot or the new snapshot, never a mix of both.
17:06:40 <ddarius> Dashkal: Why do you feel you need concurrency at all again?
17:07:04 <dons> its a networking/server problem?
17:07:20 <Dashkal> Strictly speaking I don't.  This can and will run in a single thread (so long as I have asynchrinous IO).
17:07:30 <dons> e.g. designing a scalable server in concurrent Haskell, with the option of moving to multiple calls to increase performance?
17:07:34 <dons> cores.
17:07:42 <Dashkal> If you've ever delved into DIKU based mud code you'll see what I mean.
17:07:46 <dibblego> @hoogle [m (f a)] -> (m (f [a]))
17:07:47 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
17:07:47 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
17:07:47 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
17:07:51 <monochrom> You risk over-engineering if you make individual nodes MVar's or TVar's.
17:08:01 <Dashkal> I want my performance to scale with available cores.
17:08:24 <ddarius> Dashkal: Perhaps you should consider trying to separate your game logic from IO more.
17:08:27 <Dashkal> Well, there are situations where multiple modifications of that map are safe.  Basically when they affect non-overlaping parts of the tree.
17:08:59 <Dashkal> For the purists, not a tree, a directed cyclic graph.  Cycles are legal.
17:09:36 <Cale> Dashkal: How big is the map?
17:09:44 <Dashkal> As big as the game world.  Every entity is in there.
17:09:55 <Dashkal> One WorldEntry for every room, mobile, or item in the game.
17:10:21 <Cale> Right, so "not so huge as to require mutation"
17:10:40 <Dashkal> Based on the last mud I coded for, somewhere in the 3000 entry range.  not super huge.
17:10:52 <Cale> You can use an immutable Data.Map to store it reasonably well
17:11:00 <Dashkal> Which is what I'm using atm.
17:11:24 <Dashkal> The problem is pretty much everything that happens mutates that map.
17:11:49 <monochrom> Do you have benchmark results saying it's slow?
17:11:50 <Dashkal> Everythign that happens in the game world does.  Only things that affect server state avoid it (new connections and the like)
17:12:10 <Dashkal> I don't have my initial implementation yet.  I'm just trying to design so I have the option to head in a different direction if need be.
17:12:56 <Cale> I would start out just designing the game world as a big immutable structure (obviously chosen to have efficient immutable updates though)
17:13:21 <dibblego> how can I get a function :: [m (f a)] -> (m (f [a])) using mapM/sequence?
17:13:28 <Dashkal> *nods* I'm pretty sure this is clean enough.  Inventory trees generally won't go deeper than 3 entities, so the map won't slow me down any.
17:14:07 <Dashkal> Pathological russian doll cases aren't likely enough to be worth performance tuning for (especially at this stage)
17:15:15 <ivanm> dibblego: is f a functor or another monad?
17:15:28 <dibblego> ivanm, it can be monad
17:15:28 <ivanm> @type liftM sequence . sequence
17:15:29 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => [m1 (m a)] -> m1 (m [a])
17:15:42 <ddarius> :t sequence . sequence
17:15:43 <lambdabot> forall a. [[a]] -> [[a]]
17:15:43 <dibblego> I swear I did that
17:15:55 <dibblego> @type fmap fmap fmap sequence
17:15:56 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (m :: * -> *) a. (Functor f, Functor f1, Monad m) => f (f1 [m a]) -> f (f1 (m [a]))
17:16:14 <dibblego> oh silly me, thanks
17:16:51 <ddarius> > (sequence . sequence) [[1,2,3],[8,9]]
17:16:52 <lambdabot>   [[1,1,2,2,3,3],[1,1,2,2,3,9],[1,1,2,2,8,3],[1,1,2,2,8,9],[1,1,2,9,3,3],[1,1...
17:16:56 <dibblego> @type fmap (fmap sequence) sequence
17:16:57 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f, Monad f) => [f (m a)] -> f (m [a])
17:17:00 <ivanm> ddarius: ooohhhh....
17:17:23 <ivanm> dibblego: and you're using fmap rather than . ?
17:17:35 <monochrom> haha
17:17:37 <Dashkal> Alrighty.  Danke for the hints.  Now to read.
17:17:40 <mreh_> @hoogle Int -> m a -> m [a]
17:17:41 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
17:17:41 <lambdabot> Text.ParserCombinators.ReadP count :: Int -> ReadP a -> ReadP [a]
17:17:41 <lambdabot> Prelude drop :: Int -> [a] -> [a]
17:17:53 <dibblego> ivanm, no, I'm just working out where I made the error (since I thought I'd initially tried what you suggested)
17:18:09 <ivanm> right
17:18:18 <mreh_> :t (\n -> sequence . repeat n)
17:18:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> [m [a]]
17:18:33 <ivanm> but in that last @type you did, AFAIK you have that the first fmap corresponds to my .
17:18:47 <mreh_> :t sequence . repeat
17:18:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
17:19:00 <ivanm> @type fmap sequence <$> sequence
17:19:01 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f, Monad f) => [f (m a)] -> f (m [a])
17:19:21 <mreh_> :t sequence . replicate
17:19:22 <lambdabot>     Couldn't match expected type `[m a]'
17:19:22 <lambdabot>            against inferred type `a1 -> [a1]'
17:19:22 <lambdabot>     Probable cause: `replicate' is applied to too few arguments
17:19:27 <ivanm> now, what would be cool is if djinn could derive that for you...
17:19:35 <mreh_> @hoogle Int -> a -> [a]
17:19:35 <lambdabot> Prelude replicate :: Int -> a -> [a]
17:19:35 <lambdabot> Data.List replicate :: Int -> a -> [a]
17:19:35 <lambdabot> Prelude drop :: Int -> [a] -> [a]
17:19:46 <ivanm> mreh_: sequence (replicate n) doesn't really make sense...
17:20:03 <ivanm> mreh_: "sequence . replicate n" does make sense however
17:20:05 <mreh_> ivanm: why not?
17:20:07 <ivanm> @pl \ n -> sequence . replicate n
17:20:08 <lambdabot> (sequence .) . replicate
17:20:16 <mreh_> oh right
17:20:16 <ivanm> mreh_: don't forget, . only gets you one argument
17:20:19 <ivanm> replicate needs 2
17:20:21 <ddarius> mreh_: That it doesn't type check would be a pretty good reason...
17:20:26 <ivanm> heh
17:20:40 <ivanm> ddarius: I think he was wondering more along the lines of _why_ it didn't type check...
17:20:43 * ivanm has done that before
17:20:44 <monochrom> Yeah, why do you need any other "reason" or "intuition".
17:20:57 <mreh_> you can only compose sequence with replicate n
17:21:19 <ivanm> @type (sequence .) . replicate
17:21:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:21:47 <mreh_> I dont understand how you got that points free
17:21:54 <dibblego> @type fmap fmap fmap sequence sequence
17:21:55 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Functor m1, Monad m, Monad m1) => [m1 (m a)] -> m1 (m [a])
17:21:56 <monochrom> 99% of nonsense can be screened by just checking syntax and types.
17:22:41 <mreh_> there are often things I'd like to write, for example "(\f -> blah . map f)", pointsfree
17:22:54 <mreh_> :t (.) (.)
17:22:55 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
17:23:11 <ddarius> @pl \f -> blah . map f
17:23:12 <lambdabot> (blah .) . map
17:23:45 <mreh_> I don't get it
17:23:55 <ddarius> mreh_: Work through it mechanically.
17:24:06 <mreh_> :t (blah .)
17:24:07 <lambdabot> Not in scope: `blah'
17:24:17 <mreh_> :t ((+) .)
17:24:18 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
17:24:20 <ddarius> mreh_: Not the type, the value.
17:25:00 <Dashkal> Ok, read the parallelism vs concurrency post linked.  I definitely want concurrency.  There's actually very little (non-trivial) use for parallesllism in this design.
17:25:10 <mreh_> ddarius: I don't understand
17:25:58 <monochrom> sectioning: (\f -> g . map f) = (\f -> (g .) (map f))
17:25:58 <mreh_> oh, I think I get it
17:26:19 <mreh_> (blah .) is a HOF
17:26:28 <monochrom> composition: (\f -> (g .) (map f)) = (\f -> ((g .) . map) f)
17:26:54 <monochrom> eta: (\f -> ((g .) . map) f) = ((g .) . map)
17:27:52 <monochrom> This is why school teaches algebraic skills.
17:28:58 <mreh_> f :: * -> * isn't a functor surely?
17:29:08 <mreh_> a -> is the functor right?
17:30:43 <mreh_> this has been very enlightening
17:34:26 <mreh_> @pl \ n m -> (sequence . replicate m) . randomPermTree n
17:34:26 <lambdabot> flip ((.) . (sequence .) . replicate) . randomPermTree
17:34:55 <monochrom> I personally don't worry about pointfreeing too much.
17:35:11 <dolio> Because you can't pointfree too much?
17:35:13 <dolio> Bam!
17:35:17 <mreh_> heh
17:35:36 <mreh_> zing!
17:36:51 <ben0x539> @hoogle (m a, m a, m a) -> m (a,a,a)
17:36:52 <lambdabot> No results found
17:37:45 <dolio> @type \(m,n,o) -> liftM3 (,,) m n o
17:37:46 <lambdabot> forall a1 a2 a3 (m :: * -> *). (Monad m) => (m a1, m a2, m a3) -> m (a1, a2, a3)
17:37:56 <monochrom> It is possible to go very pointfree and very streamlined at the same time, but you need a lot more combinators. Things like "flip ((.) . (sequence .) . replicate) . randomPermTree" is a sign of insufficient combinators so that you have to force-fit everything as flip and .
17:37:59 <tavelram> @hoogle (m a, m a) -> m (a,a)
17:38:00 <lambdabot> No results found
17:38:22 <mreh_> ben0x539, tuples are not homo-thingy
17:38:29 <ben0x539> Well, this one is!
17:38:40 <dolio> @type uncurry $ liftM2 (,)
17:38:41 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
17:38:48 <mreh_> ben0x539,  yeah, but in general
17:39:45 <mreh_> the correct response that I was looking for was "who are you calling a homo"
17:40:06 <monochrom> what are you calling a homo
17:40:49 <ben0x539> I am not entirely comfortable with humour that revolves around denigrating people's sexuality. :|
17:41:23 <mreh_> but I'm gay
17:41:28 <mreh_> it;s okay
17:41:42 <monochrom> I was thinking "homo sapiens"
17:41:45 <Lycurgus> if embarassing
17:42:04 <monochrom> Calling a tuple "homo sapiens" is insulting to the tuple.
17:42:09 <copumpkin> mens hominis sapientis
17:43:07 <mreh_> homo lupis hominem
17:43:11 <mreh_> is that the expression?
17:43:13 <copumpkin> homo capiens
17:43:26 <Lycurgus> "homo" in a context like this means "same", "single", "self", etc. not the childish stuff
17:43:39 <mreh_> teehee
17:43:46 <Twey> flip (fmap . fmap sequence . replicate) . randomPermTree
17:43:49 <Twey> Not so scary
17:44:11 <mreh_> (.) = fmap?
17:44:18 <mreh_> for -> a
17:44:24 <Twey> fmap is (.) on functions, yes
17:44:42 <mreh_> :t fmap
17:44:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:44:56 <tensorpudding> > (+5) <$> (-5) $ 10
17:44:57 <lambdabot>   No instance for (GHC.Num.Num (a1 -> a))
17:44:57 <lambdabot>    arising from a use of syntactic ...
17:45:07 <tensorpudding> > (+5) <$> (+5) $ 10
17:45:08 <lambdabot>   20
17:46:22 <tensorpudding> > (+) <$> 5 <*> 10
17:46:24 <lambdabot>   No instance for (GHC.Num.Num (f a))
17:46:24 <lambdabot>    arising from the literal `5' at <int...
17:46:27 <tensorpudding> hmm
17:46:53 <tensorpudding> > (+) <$> Just 5 <*> Just 10
17:46:54 <lambdabot>   Just 15
17:47:07 <tensorpudding> applicative has all the good combinators
17:47:07 <Twey> Yep
17:47:10 <Twey> Yep
17:47:19 <Twey> > Just (+ 5) <*> Just 10
17:47:19 <lambdabot>   Just 15
17:47:25 <Twey> > Nothing <*> Just 10
17:47:26 <lambdabot>   Nothing
17:47:57 <mreh_> :t <*>
17:47:57 <Twey> Applicatives are vastly underrated
17:47:58 <lambdabot> parse error on input `<*>'
17:48:01 <Twey> Monoids, too
17:48:03 <mreh_> :t (<*>)
17:48:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:48:06 <mreh_> :t ap
17:48:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:48:16 <Twey> mreh_: It takes a function in a functor and applies it to a value in a functor
17:48:20 <Twey> Yeah
17:48:29 <Twey> ap is <*> for monads
17:48:37 <monochrom> > (,) 2 "2"
17:48:38 <lambdabot>   (2,"2")
17:48:43 <Twey> Because someone forgot the Functor m constraint on Monad ;)
17:48:45 <mreh_> haskell has too many operators
17:48:56 <mreh_> Twey: yes!
17:48:58 <Twey> mreh_: Haskell doesn't have operators
17:49:04 <idnar> Twey: you mean the Applicative m constraint?
17:49:04 <Twey> Just infix functions
17:49:08 <Twey> idnar: That one, too
17:49:09 <monochrom> You need moar operators for pointfree.
17:49:18 <idnar> Twey: having both would be stupid
17:49:23 <mreh_> Twey: they are operators, you define them as operators in your source file
17:49:33 <tensorpudding> the way it's defined, though, is that applicative is usually written in terms of the monad forms
17:49:38 <Twey> idnar: I think it's required, isn't it?
17:49:39 <tensorpudding> with pure = return and <*> = ap
17:49:42 <Twey> mreh_: Not necessarily
17:49:44 <kmc> > (2,)
17:49:45 <tensorpudding> instead of the other way around
17:49:45 <lambdabot>   <no location info>: parse error on input `)'
17:49:48 <kmc> , (2,)
17:49:57 <idnar> Twey: why? the Applicative constraint implies it
17:50:00 <idnar> @src Applicative
17:50:00 <lambdabot> class Functor f => Applicative f where
17:50:00 <lambdabot>     pure  :: a -> f a
17:50:00 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
17:50:13 <Twey> idnar: But sadly Haskell types don't currently work like that
17:50:25 <Twey> If you want to use Functor methods, you have to specify Functor
17:50:32 <Twey> Even if it's already implied by Applicative
17:50:48 <Twey> That's what class aliases are meant to fix
17:50:58 <tensorpudding> it'd be nice if you only had to specify a monad instance
17:51:01 <idnar> Twey: seriously?
17:51:11 <Twey> *nod*
17:51:14 <tensorpudding> and then all the others would mystically appear
17:51:22 <Twey> Hehe, yeah
17:51:34 <Twey> I think class aliases allow that, tooâ¦
17:52:07 <tensorpudding> fmap would default as liftM if you define a monad instance
17:52:11 <solrize> Nobody expects the Haskell language system.  Our chief weapon is polymorphism... polymorphism and type classes ... type classes and polymorphism.  Our two weapons are type classes and polymorphism.. and lazy evaluation.  Our three weapons are type classes, and polymorphism and lazy evaluation... and an almost fanatical devotion to monads.  Our four... no... amongst our weapons ... Amongst our weaponry... are such elements as type classes, po... I'll c
17:52:11 <solrize> ome in again.   [plagiarized from here:  http://www.mirandabanda.org/cogblog/2009/01/14/under-cover-contexts-and-the-big-frame-up/ ]
17:52:27 <Twey> Hahaha
17:53:28 <idnar> Twey: I can't reproduce that
17:54:12 <idnar> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16853
17:54:31 <idnar> am I missing something?
17:56:04 <Twey> It's also possible that I'm horrendously wrong
17:56:08 <Twey> It has been known to happen
17:57:19 <idnar> maybe that's not a good example, how about: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16853#a16854
17:57:49 <idnar> I thought class aliases was just about combining a bunch of different classes into a single constraint
17:59:49 <ivanm> Twey: ORLY?
17:59:53 <ivanm> ;-)
18:00:32 <shemale-magic> whos got a happstack site up n running an profitable
18:00:43 <dons> ah, it has been a while!!
18:00:45 --- mode: ChanServ set +o dons
18:00:46 --- mode: dons set +b *!*gav@*.socal.res.rr.com
18:00:46 --- kick: shemale-magic was kicked by dons (shemale-magic)
18:00:48 --- mode: ChanServ set -o dons
18:01:10 <ivanm> dons: how did you know shemale-magic was a spammer (apart from the actual nick)?
18:01:11 <dons> gavino, trolling the same old path for nearly a decade.
18:01:31 <dons> oh, same nick used maybe 5 years ago. characteristic bad punctuation, 'gav' nick,
18:01:33 <monochrom> a decade already?! I am that old?
18:01:40 <ivanm> what? but we haven't had happstack for a decade yet!
18:02:13 <dons> usually asks questions in FP about commercialization, intentional confusion of terms/ideas, cross-language comparison questions
18:02:23 <dons> often with long, offensive nicks.
18:02:41 <kmc> get this info to the FBI Troll Profiling Center, stat
18:02:41 <solrize> jdh30 ?
18:02:45 <solrize> lol kmc
18:02:45 <dons> the least interesting troll, in a way.
18:02:47 <ivanm> well, this time [s]he just asked about who bothered to use a particular web stack to make money
18:02:48 * idnar generates a profit table
18:02:49 <kmc> get a police sketch
18:03:01 <tensorpudding> trollfiling
18:03:07 <Adamant> ivanm: he was banned from #lisp yesterday with the exact same setup
18:03:09 <Veinor> # Berengal: I'm going to write a module Hmm with a (.) operator in it, so I can go 'Hmm..' in my code
18:03:09 <dons> has no investment in the technology, just enjoys trolling irc.
18:03:12 <Veinor> haha
18:03:13 <idnar> kmc: "well, the subject was about 12 letters long or so; double barreled, I think"
18:03:16 <ivanm> I wonder if there's any statistics on general profitability of websites
18:03:20 <ben0x539> I wonder whether I can turn strings into a functor so that fmap (+1) "42" results in "43"
18:03:21 <idnar> kmc: "I didn't get a good look at his hostname, though, he got banned too quickly!"
18:03:27 <dons> ?proton-torpedo
18:03:28 <lambdabot> Im not a loser
18:03:35 <dons> was a nick used by gavino in the distant past
18:03:37 <dons> was a nick used by gavino in the distant past
18:03:38 <dons> ?proton-torpedo
18:03:39 <lambdabot> can haskell do data transfer from box to box over sockets?
18:03:42 <dons> ?proton-torpedo
18:03:42 <lambdabot> on the haskell site they compare haskell to a spreadsheet
18:03:45 <solrize> gavino?  zomg
18:03:46 <dons> ?proton-torpedo
18:03:46 <lambdabot> I had one guy tell me he was 16x as fast to develop something in smalltalk
18:03:48 <ivanm> (I'm referring to sites that are designed specifically as a business, not say a web site for a shop or someone putting adsense on their blog)
18:03:49 <Adamant> dons: he doesn't even do any good trolling.
18:04:05 <ivanm> ben0x539: that doesn't really make sense
18:04:07 <dons> right. very poor. not interesting. easy to spot. but persistant. years of the same line.
18:04:13 <mreh_> is anyone aware of the computational the complexity of (@@>)?
18:04:17 <idnar> oh, so I finally meet the famous proton-torpedo
18:04:22 <solrize> can someone explain gavino?  for irrelevant reasons i just happened to be looking at comp.lang.forth and someone named gavino was trolling there too.
18:04:26 <mreh_> Data.Packed.Matrix.(@@>)
18:04:38 <ivanm> mreh_: is this hmatrix?
18:04:43 <mreh_> ivanm: yes
18:04:47 <dons> solrize: gavino lives to do poor quality trolling. kind of retro/sad now.
18:04:58 <tensorpudding> it's a tradition
18:05:08 <tensorpudding> you got to keep traditions
18:05:17 <dons> yeah, in a way.
18:05:18 <ivanm> mreh_: looks rather efficient
18:05:26 <dons> appears here once every few months, gets banned again.
18:05:31 <tensorpudding> maybe he grew up since then, but he keeps trolling every now and then when nostalgia kicks in
18:05:39 <solrize> that is pretty wide spectrum trolling, getting all the way from a forth usenet group to here.  wow ;)
18:06:07 <mreh_> ivanm: do you know what `at` is in the source
18:06:14 <mreh_> Data.Packed.Common
18:06:16 <ivanm> mreh_: probably an internal function
18:06:29 <tensorpudding> If GNAA is the Wal-Mart of trolling, then maybe he is the artisan cheesemaker of trolling
18:06:48 <ivanm> uhhh.... I don't see Data.Packed.Common there...
18:06:55 <Veinor> tensorpudding: that's... a pretty great analogy
18:07:09 <ivanm> mreh_: you mean Data.Packed.Internal?
18:07:14 <mreh_> ivanm: yeah
18:07:19 <dons> old gavino quotes, grep for protontorpedo in http://code.haskell.org/lambdabot/Plugin/Quote/Text.hs
18:07:29 <diegoeche> Hi... I just installed Haskell platform and I'm having troubles installing HLint
18:07:36 <ivanm> mreh_: http://hackage.haskell.org/packages/archive/hmatrix/0.8.2.0/doc/html/src/Data-Packed-Internal-Common.html
18:07:46 <solrize> lol
18:07:49 <ivanm> diegoeche: what's the error?
18:07:53 <solrize> make mroe money!!!
18:08:03 <ivanm> mreh_: but at isn't in that one
18:08:14 <diegoeche> src/HSE/All.hs:33:68:
18:08:15 <diegoeche>     Couldn't match expected type `[Char]'
18:08:15 <diegoeche>            against inferred type `IO String'
18:08:15 <diegoeche>  
18:08:33 <ivanm> mreh_: http://hackage.haskell.org/packages/archive/hmatrix/0.8.2.0/doc/html/src/Data-Packed-Internal-Vector.html <-- this has at
18:08:38 <ivanm> diegoeche: which version of hlint?
18:08:45 <ivanm> which version of haskell-src-exts do you have?
18:08:51 <diegoeche> I tried upgrading
18:08:55 <diegoeche> hlint-1.6.16
18:08:58 <diegoeche> sorry
18:09:01 <ivanm> does "ghc-pkg check" say anything?
18:09:24 <diegoeche> nothing
18:09:39 <ivanm> mreh_: anyway, it's in the ST monad I think, so it's pretty efficient
18:09:49 <ivanm> diegoeche: OK, what version of haskell-src-exts do you have?
18:09:59 * ivanm just built hlint-1.6.16 the other day with no problems
18:10:09 <ivanm> diegoeche: oh, and which version of ghc?
18:10:52 <diegoeche> diegoeche@HYXOS:~/Documents$ ghc-pkg describe haskell-src-exts
18:10:52 <diegoeche> name: haskell-src-exts
18:10:52 <diegoeche> version: 1.6.1
18:10:52 <diegoeche>  
18:11:15 <diegoeche> The Glorious Glasgow Haskell Compilation System, version 6.10.4
18:11:41 <ivanm> diegoeche: OK, which version of uniplate do you have?
18:11:59 <ivanm> and cpphs
18:12:20 <diegoeche> version: 1.5.1
18:12:27 <diegoeche> I tried upgrading cpphs
18:12:36 <diegoeche> but it didn't upgrade
18:12:49 <ivanm> to what?
18:13:27 <ivanm> I built hlint with cpphs-1.9
18:14:16 <diegoeche> version: 1.11
18:14:16 <diegoeche>  
18:14:33 <diegoeche> maybe I should "downgrade" to that version?
18:15:00 <diegoeche> because the error seems related to a cpphs function.
18:15:24 <diegoeche> It says "In the second argument of `maybe', namely `(`runCpphs` file)'
18:16:24 <sealion> I'm getting the same thing when I try pulling hlint 1.6.1 via cabal.  The dependencies had to be pulled in and built by Cabal, too.
18:16:30 <sealion> ghc 6.10.4
18:18:18 <ivanm> diegoeche: yeah, trie that
18:18:41 <tensorpudding> tries are fun
18:19:04 <ivanm> *try
18:19:05 <ivanm> @slap tensorpudding
18:19:06 * lambdabot slaps tensorpudding
18:19:29 <tensorpudding> @slap ivanm
18:19:29 * lambdabot locks up ivanm in a Monad
18:20:09 <diegoeche> ok... A bit n00b here. How can I downgrade the cpphs lib?
18:20:56 <ivanm> diegoeche: what did you use to install it? cabal-install?
18:21:03 <diegoeche> yes
18:22:28 <diegoeche> How can I install a previous version with cabal-install?
18:22:50 <ivanm> good question...
18:23:01 <ben0x539> @pl \a b c -> f b c a
18:23:01 <lambdabot> flip (flip . f)
18:23:13 * ivanm isn't sure how to specify a version to cabal-install
18:23:30 <Raevel> cabal install "foo == 1.0"
18:23:49 <ivanm> OK, in that case you want: cabal install --reinstall "cpphs == 1.9"
18:23:56 <ivanm> Raevel: it was the quotes I had no idea about
18:24:10 <ivanm> or it's just cpphs-1.9 without the quotes
18:24:30 <Raevel> yeah.. i usually end up creating a bunch of files with >= :-)
18:26:09 <sealion> I can confirm that cabal will build hlint if cpphs-1.9 is already installed.
18:26:43 <diegoeche> cpphs fails to install :-(
18:26:50 <ivanm> diegoeche: :o
18:26:56 * ivanm wonders if it works with 1.10...
18:28:35 <diegoeche> I'm getting some linking errors with both :S
18:30:45 <sealion> hlint compiles for me with cpphs-1.10 via Cabal.
18:31:40 <ivanm> diegoeche: well, it's a bit hard for us to help you if we don't see the errors in question...
18:33:29 <diegoeche> sorry... http://gist.github.com/291411
18:34:43 <ivanm> methinks you stuffed something up....
18:34:51 <ivanm> what version of cabal-install are you using?
18:35:01 <ivanm> did you ever do "cabal upgrade" and have it upgrade everything for you?
18:36:53 <diegoeche> I followed this guide: ttp://davidsiegel.org/haskell-platform-in-karmic-koala/
18:37:44 <diegoeche> Maybe I tried to do a cabal upgrade
18:37:45 <monochrom> I followed it in a virtual machine and no error.
18:37:47 <vyom> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16858#a16858 I have a conceptual query.. Is there any way to avoid calling the `encode` function multiple times in the getParams function...
18:38:01 <mreh_> any idea how to make this prettier ? (((@@>) adjMx .) . (-) 1)
18:38:23 <mreh_> any idea how to make this prettier ? (((@@>) adjMx .) . flip (-) 1)
18:39:26 <aavogt> > (flip (-) 1 2, subtract 1 2)
18:39:27 <lambdabot>   (1,1)
18:39:27 <Twey> fmap (@@>) adjMx . subtract 1
18:39:27 <ivanm> mreh_: well, "subtract 1" == "flip (-) 1" == pred
18:39:31 <bnijk> pertaining to combinators, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16859#a16859
18:39:36 <bnijk> somebody please take a look at that
18:39:39 <bnijk> and tell me why it doesn't work
18:39:40 <Twey> Then give things better names than âadjMxâ :Ã¾
18:39:46 <ivanm> mreh_: but on the other hand, I would do-pointfree it
18:39:47 <ivanm> ;-)
18:39:50 <diegoeche> well... I'll try to do it again. Thanks for the help :)
18:39:50 <monochrom> vyom: No.
18:39:59 <Twey> Oh, yeah, pred too
18:40:06 <Twey> fmap (@@>) adjMx . pred
18:40:16 <Twey> ivanm: You'd seriously stick a load of points on that?
18:40:26 <ivanm> not a load
18:40:29 <mreh_> > pred 1.01 :: Double
18:40:30 <lambdabot>   1.0000000000000009e-2
18:40:31 <monochrom> bnijk: What is sdfh?
18:40:33 <Twey> But why?
18:40:41 <ivanm> but I find that if you're doing (f .) . g, it's usually nicer to just add a point and get f . g x
18:40:42 <Twey> It's fine as it is, apart from the silly names
18:40:42 <mreh_> > pred . pred 1.01 :: Double
18:40:43 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
18:40:43 <lambdabot>         against inferred ty...
18:40:43 <bnijk> monochrom: it has to do with combinators
18:40:49 <mreh_> > pred . pred $ 1.01 :: Double
18:40:49 <lambdabot>   -0.99
18:40:55 <Twey> ivanm: There's nothing wrong with fmap f . g
18:41:12 <ivanm> Twey: well, I'm not a big fan of the ((->) a) functor either ;-)
18:42:39 <monochrom> bnijk: I don't see valid haskell code. The second line is "   sdfh d  ASUIO)0s90s "  Tell me you are not trolling.
18:42:52 <mreh_> > (\x -> zip x . drop 1 . cycle $ x) [1..10]
18:42:53 <bnijk>  +"trolling" is a harsh word
18:42:53 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,1)]
18:42:57 <bnijk> i'm really just kidding around ;)
18:43:07 <ivanm> @slap bnijk
18:43:07 <lambdabot> why on earth would I slap bnijk?
18:43:11 <bnijk> lol
18:43:14 <ivanm> bnijk--
18:43:16 <ivanm> there
18:43:19 <bnijk> bnijk++
18:43:27 <bnijk> good as new
18:43:28 <ivanm> no, that's cheating
18:43:29 <mreh_> bnijk++
18:43:31 <ivanm> @karma-- bnijk
18:43:32 <lambdabot> bnijk's karma lowered to -1.
18:43:36 <ivanm> @slap mreh_
18:43:36 * lambdabot clobbers mreh_ with an untyped language
18:43:41 <mreh_> @karma mreh
18:43:41 <lambdabot> mreh has a karma of 2
18:43:42 <bnijk> @karma++ bnijk
18:43:42 <lambdabot> You can't change your own karma, silly.
18:43:47 <ivanm> aha!
18:43:48 <bnijk> stupid bot
18:43:51 <mreh_> @karm ivanm
18:43:51 <lambdabot> Maybe you meant: karma karma+ karma- karma-all
18:43:55 <monochrom> smart bot
18:43:55 <mreh_> @karma ivanm
18:43:56 <lambdabot> ivanm has a karma of 18
18:43:59 <monochrom> @botsnack
18:43:59 <lambdabot> :)
18:44:00 <bnijk> i'll show you lambdabot
18:44:02 <monochrom> lambdabot++
18:44:02 <bnijk> if it's the last thing i do
18:44:09 * bnijk shakes his fists
18:44:19 <mreh_> @karma monochrom
18:44:20 <lambdabot> monochrom has a karma of 5
18:44:28 <mreh_> @karma lambdabot
18:44:28 <lambdabot> lambdabot has a karma of 2
18:44:32 <mreh_> d'oh
18:44:38 <ivanm> monochrom: I have more karma then you? :o
18:44:43 <bnijk> what is the haskell equivalent to "cherrypy"
18:44:57 <ivanm> bnijk: since I have no idea what cherrypy is...
18:45:12 <bnijk> it's a little thing you set itup
18:45:16 <mreh_> monochrom lives in an existential universe, he doesn't believe in karma
18:45:20 <bnijk> hooking up HTTP requests to functinos
18:45:20 <monochrom> please just stop. and please just stop feeding.
18:45:35 <bnijk> i'm getting the feeling it's happs or happstack
18:45:47 <bnijk> i'm asking earnestly monochrom ... don't be a dick
18:46:06 <mreh_> don't start flaming in here guys, #haskell has a good reputation
18:46:12 <mreh_> we'd like to keep it that way
18:46:41 <bnijk> are any of you guys happs wizards
18:50:10 <bnijk> the minute somebody pulls out the word "troll" - any chance of a decent conversation - whoosh - right out the window
18:50:17 * bnijk waves
18:50:31 <mreh_> it probably means "no" bnijk
18:50:41 <ivanm> especially since happs is dead...
18:50:42 <mreh_> don't start stiring things up again either!
18:50:47 <jmcarthur> ivanm: i know Set isn't a functor. i was talking about the hypothetical scenario in which we had constraint families, in which case Set could be a functor
18:51:22 <mreh_> @hoogle (a -> b) -> (a, a) -> (b, b)
18:51:22 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
18:51:22 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
18:51:22 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
18:51:53 <aavogt> @type join (***)
18:51:54 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
18:52:00 <mreh_> good call
18:52:04 <aavogt> @type join (***) . (id :: a -> b)
18:52:05 <lambdabot>     Couldn't match expected type `b' against inferred type `a'
18:52:05 <lambdabot>       `b' is a rigid type variable bound by
18:52:05 <lambdabot>           an expression type signature at <interactive>:1:25
18:52:14 <ddarius> :t join (***) :: (a -> b) -> (a,a) -> (b,b)
18:52:15 <lambdabot> forall a b. (a -> b) -> (a, a) -> (b, b)
18:52:54 <jmcarthur> ivanm: because we could include the Ord constraint on the type parameter in Functor
18:53:11 <mreh_> @type join (***) (id :: a -> b)
18:53:11 <lambdabot>     Couldn't match expected type `b' against inferred type `a'
18:53:12 <lambdabot>       `b' is a rigid type variable bound by
18:53:12 <lambdabot>           an expression type signature at <interactive>:1:23
18:53:27 <ddarius> id does not have type forall a b. a -> b
18:53:28 <mreh_> oh, it's an arrow
18:53:38 <mreh_> @type join (***) (id :: a -> a)
18:53:39 <lambdabot> forall c. (c, c) -> (c, c)
18:53:53 <aavogt> @type join (***) . (id :: (a -> b) -> a -> b)
18:53:54 <lambdabot> forall b c. (b -> c) -> (b, b) -> (c, c)
18:54:09 <mreh_> he put a >>> in there too
18:54:14 <mreh_> i.e. (.)
18:54:35 <mreh_> :t join (***) pred
18:54:36 <lambdabot> forall c. (Enum c) => (c, c) -> (c, c)
19:26:57 <mreh> does anyone here keep a separate build path using GHC?
19:27:27 <kmc> my ghc is installed to a prefix in my homedir, if that's what you mean
19:28:11 <mreh> kmc: more like, when you build your projects the binaries and header files go into a separate parallel file structure
19:28:29 <mreh> sounds like I started using an IDE
19:28:53 <jmcarthur> mreh: cabal does that automagically
19:28:59 <mreh> ooh
19:29:13 <mreh> I don't use cabal
19:29:18 <jmcarthur> well, i don't know about a perfectly parallel file structure... maybe it does
19:29:23 <jmcarthur> it puts it all in another directory though
19:29:40 <mreh> jmcarthur: that's irrelevant, it makes backups 10x faster/easier :D
19:29:58 <ivanm> mreh: I have ghc installed globally
19:30:17 <jmcarthur> mreh: cabal also has a dist command to put all your files into a tarball without the build products
19:30:18 <ivanm> and yeah, I use ghci to test individual files and cabal-install to test overall building
19:30:19 <mreh> ivanm: i'm talking about projects, not ghc itself
19:30:21 <jmcarthur> mreh: darcs, too
19:30:26 <ivanm> mreh: yeah, I got that afterwards ;-)
19:30:42 <ivanm> jmcarthur: except if you're using cabal, cabal-install's sdist is better than darcs' one
19:30:56 <jmcarthur> ivanm: how is it better?
19:30:58 <mreh> all these new tools are scawy
19:31:20 <jmcarthur> ivanm: on the downside, cabal's will only work if you declare all your modules in the .cabal file
19:31:26 <jmcarthur> and other files
19:31:51 <ivanm> jmcarthur: well, if I have some files that I keep in darcs but don't want packaged in the .cabal file (test routines, etc.) then darcs sdist will include it in the tarball whereas cabal sdist won't
19:32:05 <ivanm> mreh: ummm.... cabal-install isn't _that_ new
19:32:09 <jmcarthur> ah... i can't think of many situations where i would need that though
19:32:26 <mreh> ivanm: to me it is
19:32:31 <ivanm> yeah, it's mainly if I have a file that I'm using for testing purposes, etc.
19:32:37 <ivanm> mreh: not our fault if you're not keeping up ;-)
19:32:42 <ivanm> and that's only one tool that's relatively recent
19:33:16 <jmcarthur> i never put files in my repo that i wouldn't want to be in tarballs anyway
19:33:45 <mreh> I have so many other fields to keep up in, there's my subscription to the discovery institute, the institute of noetic sciences...
19:33:57 <ivanm> what's "noetic sciences"?
19:34:00 <aavogt> poetic science
19:34:14 <ivanm> jmcarthur: I have a file I use as a code generator that I only recently started including in the tarball
19:34:16 <ivanm> aha
19:34:27 * ivanm marks that down as "another useless pseudo-scientific field"
19:34:27 <mreh> ivanm: some parapsychology research group, they were mentioned in Dan Brown's book, the last one
19:34:37 <ivanm> oh, that idiot
19:34:51 <jmcarthur> ivanm: that sounds like something i would have included in the build system
19:34:51 <mreh> it's no pseudo-science, it's just not very hard science
19:35:02 <ivanm> jmcarthur: nah, I generate the code at write time
19:35:07 <jmcarthur> ah
19:35:16 <mreh> *everybody* knows that telepathy happens
19:35:17 <ivanm> jmcarthur: it was just to save me doing multiple tweaks if I changed one big data structure
19:35:22 <jmcarthur> gotcha
19:35:41 <ivanm> jmcarthur: http://code.haskell.org/graphviz/Data/GraphViz/AttributeGenerator.hs
19:35:52 <mreh> -blah, anyway
19:37:00 <ivanm> @quote orbit
19:37:00 <lambdabot> DRMacIver says: #haskell doesn't so much wander off topic as orbit it. :)
19:37:24 <ivanm> hmmm.... haven't seen DRMAcIver around for a while actually...
19:37:29 <ivanm> preflex: seen DRMacIver
19:37:29 <preflex>  DRMacIver was last seen on ##C++ 68 days, 13 hours, 9 minutes and 28 seconds ago, saying: Anyway, got to go for now. Thanks for help and suggestions.
19:37:52 <mreh> he must have popped off to shoot himself
19:38:06 <mreh> i really hope that isn't true
19:39:13 <medfly> probably not. maybe he died in a car accident.
19:39:29 <mreh> it must have taken ages for the administrators at freenode to learn that for example lilo died, you only have contact over a terminal
19:39:29 <monochrom> cruel people, you
19:39:36 <ivanm> or he's been taken by government agents to go and work in a secret lab...
19:39:47 <medfly> actually, they realised he is going to die before he died, afaik.
19:40:06 <medfly> or maybe they didn't, not sure
19:40:06 <mreh> medfly... oh, urgh
19:40:25 <Adamant> maybe the guy is on a beach in some country where he can get drinks with the little umbrella in them
19:40:25 <medfly> hehe
19:40:26 <kmc> preflex, seen god
19:40:26 <preflex>  god was last seen on ##c++ 120 days, 4 hours and 35 minutes ago, saying: I don't really know either actually
19:40:32 <Adamant> always so negative.
19:40:34 <aavogt> hmm, preflex doesn't use NOTICE anymore
19:40:45 <mreh> it must be desperate when your wife comes on IRC to look for you
19:40:48 <medfly> well, I know of people who quit IRC.
19:40:54 <medfly> haha >.<
19:41:14 <medfly> I heard lilo's family got some financial help from freenode...
19:41:27 <Adamant> quitting IRC is probably a good way to get a lot more work done if you need to.
19:41:34 <mreh> did he earn his living from freenode?
19:41:35 <medfly> right
19:41:51 <mreh> that's why he was riding a bike
19:41:56 <mreh> I'm really sorry everybody
19:42:12 <quuxman> how do I fine what package a module belongs to?
19:42:40 <jrockway> ghc-pkg find-module
19:43:13 <kmc> http://holumbus.fh-wedel.de/hayoo/hayoo.html
19:43:31 <quuxman> jrockway: thanks
19:44:24 <quuxman> kmc: ah nice, Hayoo has more packages than Hoogle
19:44:43 <ivanm> yup
19:44:49 <ivanm> hayoo indexes all of hackage IIRC
19:44:58 <ivanm> ndm is working on having hoogle have similar functionality
19:45:20 <monochrom> Nice.
19:45:40 <ivanm> hopefully he isn't going to use web 2.0 "technologies" though
19:45:54 <monochrom> Nice = so if I ask hayoo for "Control.Monad.State" it will list every package and its grandma :)
19:46:00 <ivanm> aha
19:46:06 <tommd> What are peoples thoughts on package hierachies and typeclasses?  I typically want the package declaring the ADT to include helpful class instances (ex: prettyclass) even at the cost of added package dependencies.  Some people believe the instances belong in a third package (such as an application package), at the risk of lower code reuse.  Typical examples:  GPS "Coordinate" instance (class in GPS and coordinate-instance-able types in GPX a
19:46:09 <ivanm> monochrom: so it's sexist? :p
19:46:29 <ivanm> tommd: pretty much depends on the situation IMHO
19:46:32 <monochrom> No, I mean there are so many alternative implementations of "Control.Monad.State".
19:46:42 <mreh> > scanl1 (+) [1..5]
19:46:42 <ivanm> monochrom: yeah :s
19:46:42 <lambdabot>   [1,3,6,10,15]
19:46:56 <ivanm> tommd: though having a package just for instances is probably a bad idea
19:46:56 <cygnus> Does anyone know if the author of Bamboo hangs out in here?
19:47:05 <ivanm> cygnus: who is the author?
19:47:06 * cygnus waves to tommd
19:47:16 * tommd waves back
19:47:18 <cygnus> ivanm: Wang, Jinjing <nfjinjing@gmail.com>
19:47:36 <ivanm> I've seen him (?) here once or twice before I think
19:47:38 <ivanm> not often though
19:47:42 <cygnus> ivanm: what's his nick?
19:47:43 <ivanm> @slap date-based version schemes
19:47:44 * lambdabot smashes a lamp on date-based version schemes' head
19:47:49 <ivanm> cygnus: jinjing methinks
19:47:54 <ivanm> preflex: seen jinjing
19:47:54 <preflex>  jinjing was last seen on #haskell 21 hours, 5 minutes and 5 seconds ago, saying: where did data.array.diff go in ghc 6.12?
19:47:59 <cygnus> ivanm: Okay. Thanks!
19:48:02 <ivanm> (at least I _think_ that's the same jinjing)
19:48:06 <mreh> > scanl (+) 0 [1..5]
19:48:07 <lambdabot>   [0,1,3,6,10,15]
19:48:07 <cygnus> heh
19:48:27 <ivanm> but really.... using a date as a version string? where did that stupidity come from?
19:48:42 <monochrom> come from "windows 98"
19:48:43 * cygnus wants (to help make) better bamboo documentation. :)
19:48:58 <ivanm> monochrom: there was 95 before that...
19:49:01 <medfly> :)
19:49:05 * medfly was just about to type that
19:49:06 <mreh> @hoogle (a -> Bool) -> [a] -> ([a],[a])
19:49:06 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
19:49:06 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
19:49:06 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
19:49:12 <monochrom> Oh, I forgot, haha
19:49:13 <ivanm> but I'm talking about year.month.day
19:49:30 <tommd> ivanm: Well, it is clear what version is newer - isn't it?
19:49:33 <ivanm> it makes it a pain to try and tell how much upgrade work is needed and to provide sensible dependency bounds
19:49:42 <monochrom> So, since "windows 95", people felt safe to do "SML 97", "HOL 98", "Haskell 98"...
19:49:44 <ivanm> tommd: yes; but it is also clear in the case of 1.1 vs 1.2
19:49:55 <ivanm> monochrom: for a standard, it makes sense
19:50:03 <ivanm> for a library that gets released often? not really...
19:50:14 <aavogt> FORTRAN 66
19:50:23 <medfly> Haskell98 ;)
19:50:28 <monochrom> Oh bother, "HOL 88" predates "windows 95". And yes "HOL 88" means HOL year 1988.
19:50:34 <ivanm> aavogt: that wasn't a standard IIRC
19:50:38 <ivanm> monochrom: heh
19:51:05 <medfly> it's reasonable for languages, I guess...
19:51:11 <aavogt> ivanm: it's something earlier than everything else that's year-based
19:51:22 <ivanm> true
19:51:24 <aavogt> regardless of whether or not it was a proper standard
19:51:26 <monochrom> Algol 60
19:51:29 <mreh> @hoogle (a -> Bool) -> [a] -> a
19:51:30 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
19:51:30 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
19:51:30 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
19:51:36 <kamatsu> C89
19:51:45 <ivanm> ooooh, FORTRAN 66 _was_ a standard
19:51:51 <ivanm> but it was more an industry standard
19:52:06 <monochrom> So we computer scientists came up with it.
19:53:08 <ivanm> monochrom: nah, I'm sure they had treaties, etc. that were labelled with years
19:53:24 <aavogt> right... wars
19:53:33 <aavogt> 1812 etc.
19:53:59 <ivanm> 1812 overture? ;-)
19:54:06 <medfly> hehe
19:54:10 <medfly> that's not from 1812, iirc
19:54:31 <aavogt> well it's about a war around 1812, hence the cannons
19:54:45 <ivanm> medfly: and how many language standards actually come out in the year attached to them?
19:54:58 <kmc> hehe
19:55:06 <kmc> C++9999
19:56:13 <mreh> I saw that once, they had these black boxes that exploded
19:56:28 <mreh> the percussionist triggered them with switches
19:56:44 <mreh> not as good as the real article mind
19:57:21 <medfly> so that's what those black boxes in computer science courses mean
19:57:22 <medfly> :-D
19:57:58 <mreh> "how do you know it's working?", "it gets warm"
19:58:34 <mreh> I've seen the score, he was anal enough to compose the cannons shot exactly
19:58:47 <monochrom> "it emits photons with this distribution of wavelengths as planck's formula says"
19:58:58 <medfly> haha
19:59:25 <aavogt> "black body"
20:00:37 * Zao hugs 14882:1998 and 14882:2003
20:01:02 <aavogt> 9001??
20:01:13 <Zao> Ye Olde C++ Standarde.
20:01:55 * kmc waits for 14882:2101
20:04:22 <mreh> how can I implement roulette wheel selection efficiently?
20:04:29 <mreh> a.k.a fitness proportional selection
20:04:43 <mreh> o(n) is too slow
20:06:30 <QtPlatypus> mreh: How are you doing it at the moment?
20:06:40 <mreh> QtPlatypus, i'll paste it
20:07:09 <QtPlatypus> mreh: Use paste bin, or just describe your algorythum.
20:07:36 <mreh> population is zipped up with the cumulative fitness
20:08:26 <mreh> I generate a random number between 0 and the cumulative fitness - 1 and hunt through the list for the element that is selected
20:09:24 <mreh> I thought about binary trees, but how would you know which element to select, you already have to hunt through a list, although I don't have any plans of removing the element from the list, which is a little bit of a cheat
20:10:23 <mreh> removing something from a list is only O(n) right?
20:10:38 <monochrom> right
20:10:55 <pikhq> Because indexing is O(n), right.
20:10:55 <c_wraith> just beware of doing it in a loop
20:11:13 <kmc> erm, isn't evaluating the fitness already O(n)
20:11:26 <mreh> kmc: yes
20:11:34 <kmc> so why is an O(n) selection over that a big deal?
20:11:47 <jrockway> because 1 < n
20:11:47 <kmc> surely your fitness function takes longer than a single comparison
20:11:58 <kmc> much much longer
20:12:04 <mreh> yeah, the fitness function is O(n)
20:12:19 <mreh> which means evaluating fitness is O(n^2)
20:12:43 <kmc> i'm confused, are you doing fitness-weighted selection within the fitness function?
20:12:50 <mreh> kmc: no
20:13:03 <mreh> I'm confused
20:13:15 <kmc> for each individual, you compute its fitness
20:13:34 <mreh> yes
20:13:44 <kmc> ah, and then you want to choose from those weights n times
20:13:52 <kmc> so each one takes O(n), so it's O(n^2) total
20:13:53 <kmc> i see
20:14:38 <mreh> well n/m times
20:14:46 <mreh> but that's a numerical constant
20:15:20 <kmc> quantize the normalized weights to be rationals with some denominator k
20:15:34 <kmc> then put your individuals into an array of size k with the appropriate number of repetitions
20:15:40 <kmc> and repeatedly choose integers from [0..k-1]
20:16:13 <mreh> or a permutation of [0..k-1] and take the first n/m
20:16:15 <mreh> :D
20:16:54 <jmcarthur> if you put all your individuals into a finger tree where the measure is Sum Weight then you can query it in O(log n)
20:16:58 <mreh> I'll need GCD for this
20:17:26 <mreh> that's a great one
20:17:31 <kmc> permutation would select occurrences without replacement
20:17:33 <mreh> i've just done a finger tree aswell
20:17:36 <kmc> that would skew your probabilities
20:17:58 <mreh> kmc: no it wouldn't it normalises the probabilities
20:18:13 <mreh> they are individuals, they can't be selected multiple times
20:18:20 <kmc> ah
20:18:25 <kmc> that's not what i understood by the original problem
20:18:42 <mreh> :)
20:19:03 <mreh> jmcarthur: "that's a great one" was to your suggestion
20:19:10 <jmcarthur> mreh: :)
20:19:22 <mreh> by finger tree, you mean complete tree with totals in the nodes
20:19:28 <mreh> jmcarthur ^
20:20:45 <jmcarthur> from left to right the measure is the cumulative total of the weights up to that point
20:20:55 <jmcarthur> if that's what you mean
20:21:43 <jmcarthur> you can even use the construction of that structure to get the grand total without yet another pass :)
20:22:53 <mreh> jmcarthur: \0/
20:23:03 <mreh> it'll be sitting in the last node, just for me!
20:23:06 <mreh> in the root node
20:23:23 <jmcarthur> right
20:35:23 <jmcarthur> i love finger trees
20:47:04 <merehap> @pl \l -> not (null l) && null (drop 2 l)
20:47:04 <lambdabot> ap ((&&) . not . null) (null . drop 2)
20:47:35 <copumpkin> merehap: genericLength on a lazy natural?
20:47:51 <copumpkin> would be more legible, too
20:47:52 <merehap> ooh, sounds like what I need
20:48:07 <merehap> hadn't heard of that before, will research
20:48:11 <merehap> thanks!
20:48:51 <copumpkin> > map (\l -> not (null l) && null (drop 2 l)) (iterate (1:) [])
20:48:51 <lambdabot>   [False,True,True,False,False,False,False,False,False,False,False,False,Fals...
20:53:19 <jmcarthur> > genericLength [1..] > (2 :: Natural)
20:53:20 <lambdabot>   Not in scope: type constructor or class `Natural'
20:53:27 <jmcarthur> > genericLength [1..] > (2 :: Nat)
20:53:28 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
20:53:28 <lambdabot>    arising from the literal `2' at <int...
20:53:52 <jmcarthur> i thought we kept a Nat or Natural around on lambdabot?
20:54:01 <jmcarthur> or something like that
20:56:02 <ivanm> Natural I thought...
20:56:09 <ivanm> unless she's lost something with the recent crashes...
20:57:54 <merehap> is this just theoretical, or is it in any standard library?
20:58:04 <merehap> I can't find Nat anywhere
20:58:18 <merehap> other than a few stray blog posts
20:58:56 <ivanm> it's in the numbers library IIRC
20:59:10 <ivanm> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-Natural.html
20:59:14 <ivanm> @type Natural
20:59:16 <lambdabot> Not in scope: data constructor `Natural'
20:59:19 <ivanm> @hoogle Natural
20:59:19 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
20:59:19 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
20:59:19 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
20:59:23 <ivanm> @type infinity
20:59:24 <lambdabot> Natural
20:59:31 <ivanm> so lambdabot _does_ know about Natural
20:59:38 <ivanm> > (2 :: Natural)
20:59:39 <lambdabot>   Not in scope: type constructor or class `Natural'
20:59:50 <ivanm> but not properly
20:59:51 <merehap> awesome, thanks
21:01:36 <sjanssen> > infinity
21:01:37 <lambdabot>   Not in scope: `infinity'
21:03:51 <ivanm> a nice trick they use for the max definition for Natural though
21:03:58 <ddarius> There are a few packages with a definition of a natural type.
21:04:12 <ivanm> S x `max` S y = S (x `max` y); x `max` y = x + y
21:04:20 <ivanm> ddarius: yes, but lambdabot used the numbers one
21:06:09 <trie> Hmmm. Can instance declarations ever change the inferred type of a function?
21:07:17 <jmcarthur> what do you mean "change"?
21:07:57 <trie> "change" as in assign a different principal type depending upon what instance declarations are present
21:08:06 <ivanm> suddenly make (+) :: [a] -> Maybe b -> Either c d ?
21:08:15 <ivanm> trie: still not following
21:08:35 <trie> Change the inferred context?
21:09:04 <trie> for example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16860#a16860
21:10:08 <jmcarthur> an overlapping instance?
21:10:15 <trie> If you comment out the highlighted bool instance ghci shows the type of gsh as (Data a) => a -> String
21:10:19 <ivanm> still don't follow what you're trying to do there
21:10:42 <ivanm> trie: yeah, instances like "instance Foo a => Bar a where ..." do weird things
21:10:46 <ivanm> and you really shouldn't do that
21:10:48 <jmcarthur> maybe ghci is trying to be smarter than it should
21:10:53 <ivanm> since it means you can't do any more instances :s
21:11:14 <ivanm> jmcarthur: nope; with only that one instance it means that only instances of Data can be instances of Sh
21:11:23 <ivanm> and hence puts the (Data a) constraint on gsh
21:11:31 <ivanm> preflex: seen bos
21:11:31 <preflex>  bos was last seen on #ghc 2 days and 35 minutes ago, saying: gotta run - have a good weekend
21:11:56 <jmcarthur> the instance Foo a => Bar a pattern is a syntactic implementation of constraint synonyms
21:12:27 <ivanm> :o
21:12:47 <jmcarthur> but of course it requires extensions that we shouldn't really need in isolation
21:13:28 <jmcarthur> but the constraintTerms preprocessor literally translates constraint Bar a = Foo a to instance Foo a => Bar a
21:13:48 <jmcarthur> which is perfectly fine, since you aren't supposed to instantiate Bar yourself anyway
21:13:53 <copumpkin> jmcarthur: really? the difference (in theory) is that you could potentially have instances of Bar that aren't instances of Foo
21:14:16 <copumpkin> I guess as long as you don't go around the mechanism you're fine
21:14:18 <jmcarthur> copumpkin: it's just a synonym
21:14:40 <copumpkin> yeah, but the reason it's supposedly undecidable is because you can do more than just make it a synonym with exactly that syntax
21:14:54 <jmcarthur> what do you mean?
21:15:02 <jmcarthur> any other instances would be overlapping
21:15:05 <jmcarthur> no?
21:15:26 <copumpkin> hmm
21:15:27 <trie> not really.
21:15:34 <trie> They could have different constraints
21:15:43 <jmcarthur> trie: the type system still counts that as overlapping
21:15:49 <ddarius> trie: Haskell doesn't consider constraints.
21:16:02 <copumpkin> jmcarthur: ah, I see
21:16:24 <trie> right! i forgot "GHC takes no account of the context of the instance declaration (context1 etc)"
21:17:04 <ddarius> trie: I'm pretty sure that's a Haskell in general thing (though GHC does have to extend the notion to other extensions.)
21:18:07 <copumpkin> and that's primarily because all typeclasses are open and they could potentially overlap in the future if someone made a suitable instance
21:18:09 <copumpkin> ?
21:18:21 <jmcarthur> basically
21:18:49 <Gracenotes> :.
21:19:00 <trie> and potential overlap is not a problem just actual ones at compile time.
21:19:01 <jmcarthur> really, when you define any function or instance polymorphically with a constraint, you're defining it for *all* types, but that constraint is required whenever the function or instance is used
21:20:28 <jmcarthur> so if you define one instance polymorphically and then define another for the same class, you really are overlapping with the first even if the constraints should prevent that from manifesting in practice
21:21:07 <hatds> :t \x -> do x
21:21:07 <lambdabot> forall t. t -> t
21:21:14 <trie> that is a good explanation. I was just surprised that "class Sh a where gsh :: a -> String" did not imply that :t gsh :: (Sh a) => a -> String
21:21:15 <hatds> :t \x -> do _ <- undefined; x
21:21:16 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> m b
21:21:17 <jmcarthur> essentially for exactly the reason copumpkin guessed, as far as i know
21:21:34 <hatds> anyone else find it strange that these two functions have different types?
21:22:15 <kmc> it's not strange according to the desugaring rule
21:22:17 <jmcarthur> hatds: the former doesn't actually use (>>=) or return in the desugaring
21:22:22 <kmc> but it is a strange consequence of the rule
21:22:25 <hatds> yea, I realized
21:22:25 <jmcarthur> @undo \x -> do x
21:22:25 <lambdabot> \ x -> x
21:22:36 <kmc> how would you write the desugaring in order to force them to have the same type?
21:22:38 <hatds> :t \_ -> do 1
21:22:39 <lambdabot> forall t t1. (Num t1) => t -> t1
21:22:39 <jmcarthur> @undo \x -> do { _ <- undefined; x }
21:22:39 <lambdabot> \ x -> undefined >>= \ _ -> x
21:22:51 <kmc> possibly «do { e }»  ==>  «e >>= return»
21:23:16 <hatds> I don't know, but you got to admit it is surprising
21:23:21 <jmcarthur> nah
21:23:28 <jmcarthur> i find it relieving
21:23:31 <kmc> don't tell me what i have to admit ;)
21:23:34 <hatds> :)
21:24:00 <jmcarthur> it means if i redefine monad somehow then the correct type will be inferred anyway
21:24:35 <jmcarthur> (the correct one being my own versions of >>= and return)
21:24:48 <jmcarthur> (and fail, i guess)
21:25:13 <kmc> i'm in favor of keeping the desugaring rules simple
21:25:48 <jmcarthur> me too
21:28:27 <cjs> Any idea why, when trying to build cabal-install 0.8.0 it might say "/usr/bin/ld: cannot find -lHSrtsmain"? I both gave the correct $prefix to ghc's base dir (the one containing bin/ghc, as well as lib etc.) and have $prefix/bin in my path. The zlib and so on packages all worked fine.
21:28:46 <cjs> Hm. I suppose the one difference was that they didn't like a program, just libraries.
21:32:43 <cjs> So why can't the linker find that?
21:37:15 <cjs> Adding --extra-lib-dirs=$prefix/lib/ghc-6.12.1 doesn't seem to help.
21:43:23 <ivanm> cjs: try to build a simple package (e.g. pony) by hand
21:43:37 <ivanm> a simple package that has an executable that is
21:43:43 <ivanm> (actually, pony might be a library...)
21:44:51 <cjs> It builds an executable. Good thought.
21:46:39 <cjs> Same issue there. Hm. And cranking up verbosity to 3 doesn't give me the darn ld line that cabal is using.
21:46:46 <kmc> strace?
21:47:53 <cjs> It's ghc, actually.
21:48:14 <cjs> (Doh. shoulda tried that first.) I must have mucked up my install of that somehow.
21:51:19 <cjs> Ah, something borked my permissions.
21:53:28 <uorygl> :t ((&&),not)
21:53:29 <lambdabot> (Bool -> Bool -> Bool, Bool -> Bool)
21:54:17 <uorygl> @check let x &! y = x && not y in ((x &! y) &! z) == (x &! (y &! z))
21:54:17 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
21:54:35 <uorygl> @check let x &! y = x && not y in \x y z -> ((x &! y) &! z) == (x &! (y &! z))
21:54:36 <lambdabot>   "Falsifiable, after 1 tests:\nTrue\nTrue\nTrue\n"
21:54:55 <ivanm> heh
21:55:00 <jrockway> @check 1 == 1
21:55:01 <lambdabot>   "OK, passed 500 tests."
21:55:11 <jrockway> that is somewhat useful
21:55:37 <uorygl> They passed every test of equality!
21:55:58 <kmc> @check \xs -> xs == reverse xs
21:55:59 <lambdabot>   "OK, passed 500 tests."
21:56:04 <jrockway> also, i am perplexed
21:56:18 <jrockway> i could not succesfully make a writer monad that did not use all memory when recursing monadically
21:56:23 <jrockway> i switched to statet, and it works fine
21:56:38 <jrockway> (with tell == get/put)
21:56:42 <ezyang> jrockway: Well, the writer monad will accumulate values..
21:56:55 <ivanm> yeah
21:57:11 <ivanm> Reader + Writer =/= State
21:57:15 <jrockway> exactly
21:57:17 <jrockway> state works, writer doesn't
21:57:20 <jrockway> that is why i am confused
21:57:27 <jrockway> if state didn't work, i would not be confused :)
21:57:29 <ivanm> jrockway: Writer is more for logging values...
21:57:38 <jrockway> that is exactly what this process is
21:57:38 <ivanm> @hoogle tell
21:57:38 <lambdabot> Control.Monad.Writer.Class tell :: MonadWriter w m => w -> m ()
21:57:39 <lambdabot> System.IO hTell :: Handle -> IO Integer
21:57:45 <jrockway> it's like compiler warnings
21:57:48 <ezyang> do you have some sample code to show?
21:58:00 <kmc> jrockway, were you using strict or lazy writer monad?
21:58:02 <jrockway> both
21:58:10 <jrockway> i also wrote my own, which i will hpaste
21:58:18 <ivanm> IIRC, tell uses ++ by default
21:58:36 <kmc> i thought it worked with any monoid
21:58:36 <c_wraith> well.  it uses mappend
21:58:37 <jrockway> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16862#a16862
21:58:49 <jrockway> even if i do a monoid like Any, it still runs out of memory instnatly
21:58:50 <ivanm> @hoogle mappend
21:58:51 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
21:58:52 <jrockway> let me paste the driver also
21:58:59 <ivanm> c_wraith: by default though, doesn't Writer use [a]
21:59:09 <c_wraith> No, Writer is any Monoid
21:59:42 <jrockway> indeed
21:59:50 <c_wraith> > runWriter (replicateM 5 (tell 1))
21:59:51 <lambdabot>   Ambiguous type variable `w' in the constraints:
21:59:51 <lambdabot>    `GHC.Num.Num w' arising ...
21:59:52 <jrockway> so there's this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16862#a16863
22:00:15 <jrockway> basically, you can run f in a variety of contexts to observe its behavior
22:00:16 <cjs> jrockway: You know that seq only brings things to head normal form, right?
22:00:19 <jrockway> yes
22:00:29 <ivanm> Weak head normal form...
22:00:36 <cjs> Sorry, that was what I meant.
22:00:36 <ivanm> use deepseq!
22:00:46 <jrockway> i don't think that's the issue
22:00:57 <kmc> in particular, seq on a list does not do very much
22:01:00 <jrockway> anyway, try it with IO, Reader, State, and so on -- works fine
22:01:08 <jrockway> but with my W or with the real Writer, it uses all memory
22:01:14 <cjs> So you're using on an "atom" (i.e., something without internal pointers)? Like an Int?
22:01:18 <jrockway> (with Writer it uses heap, with W it uses stack)
22:03:03 <jrockway> this is also not an artifical problem with my test case
22:03:18 <jrockway> in my real app, using writer makes it run out of stack after about 200,000 iterations (this is a big database)
22:03:20 <c_wraith> @instances Monoid
22:03:21 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
22:03:28 <jrockway> using State; uses 4M of memory the whole time :)
22:03:55 <jrockway> i am not sure whether or not to be happy though, because writer should work! :)
22:04:26 <xerox> > getSum . execWriter . replicateM 5 . tell . Sum $ 1
22:04:27 <lambdabot>   5
22:04:50 <c_wraith> yeah, that.
22:05:01 <c_wraith> @hoogle sum
22:05:01 <lambdabot> Prelude sum :: Num a => [a] -> a
22:05:01 <lambdabot> Data.Foldable sum :: (Foldable t, Num a) => t a -> a
22:05:01 <lambdabot> Data.List sum :: Num a => [a] -> a
22:05:06 <c_wraith> @hoogle Sum
22:05:06 <lambdabot> Data.Monoid newtype Sum a
22:05:06 <lambdabot> Data.Monoid Sum :: a -> Sum a
22:05:06 <lambdabot> Prelude sum :: Num a => [a] -> a
22:05:20 <xerox> > getProd . execWriter . replicateM 5 . tell . Prod $ 1 -- will it float?
22:05:21 <lambdabot>   Not in scope: `getProd'Not in scope: data constructor `Prod'
22:05:31 <jrockway> product :)
22:05:57 <xerox> also a not very nice way to write 1
22:06:16 <jrockway> > getProduct . execWriter . replicateM 5 . tell . Product $ 2
22:06:17 <lambdabot>   32
22:10:41 <jrockway> @check \x -> 0 > (getProduct . execWriter . replicateM 5 . tell . Product $ x)
22:10:42 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
22:15:09 <bnijk_> what software is lambdabot written in
22:15:12 <bnijk_> and can i have it
22:15:19 <xerox> ?version
22:15:19 <lambdabot> lambdabot 4.2.2.1
22:15:20 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:15:20 <c_wraith> haskell.  it's on hackage
22:15:26 <bnijk_> nifty
22:15:37 <bnijk_> graci
22:15:59 <xerox> another satisfied customer
22:16:18 <xerox> please fill the evaluation card on your way out, have a good day
22:16:49 <monochrom> > scanl (*) 1 [1..10]
22:16:50 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800]
22:17:14 <monochrom> > scanl1 (*) [1..10]
22:17:15 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
22:21:21 <monochrom> jrockway: main = putStrLn (execWriter (forever (tell "hello ")))
22:21:56 <monochrom> I tried it with Control.Monad.Writer.Lazy and ghc -O . Memory footprint seems to stay constant.
22:23:40 <copumpkin> > scanl1 lcm [1..30]
22:23:41 <lambdabot>   [1,2,6,12,60,60,420,840,2520,2520,27720,27720,360360,360360,360360,720720,1...
22:23:53 <copumpkin> > scanl1 gcd [1..30]
22:23:54 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
22:23:58 <Nomad010> nice
22:23:59 <copumpkin> > scanr1 gcd [1..30]
22:24:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,30]
22:24:04 <copumpkin> :P
22:24:13 <Nomad010>  > scanl1 gcd [2..30]
22:24:16 <Nomad010> > scanl1 gcd [2..30]
22:24:17 <lambdabot>   [2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
22:24:21 <Nomad010> neow
22:25:57 <copumpkin> > scanr1 gcd [15..30]
22:26:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,30]
22:26:45 <xerox> ?scheck \op k xs -> scanl (op :: Int -> Int -> Int) k xs == scanl1 op (k:xs)
22:26:47 <lambdabot>   Overlapping instances for GHC.Show.Show
22:26:49 <xerox> what is the problem here?
22:26:49 <lambdabot>                              (GHC.T...
22:37:40 <EvanCarroll> hrm
22:37:48 <EvanCarroll> i think i found an error in LYAH
22:37:55 <EvanCarroll> is [a] a concrete type? I think No.
22:38:30 <ezyang> I guess it depends on what a concrete type is...
22:38:41 <dufflebunk> I think I see why point free style isn't used all the time.
22:38:42 <dufflebunk> @pl \s c l k -> (nextKeyState s c, nextKey c l k)
22:38:42 <lambdabot> (`ap` nextKey) . (((.) . (.) . (,)) .) . nextKeyState
22:39:42 <EvanCarroll> actually it says [a] is a conrete type
22:39:48 <EvanCarroll> i guess I stlil don't understand this.
22:39:55 <EvanCarroll> I'll read more tomorrow
22:40:03 <copumpkin> it's polymorphic
22:40:32 <ezyang> dufflebunk: Heh. But it's "oh so much fun!"
22:43:11 <dufflebunk> ezyang: Yes it is. Some of the stuff turns out nice though. But that one...
22:45:31 <ivanm> EvanCarroll: actually [a] is a wooden type, not a concrete type
22:45:32 <ivanm> ;-)
22:45:57 <kmc> but is it rigid?!?
22:46:29 <kmc> wooden types are the ones that have hylomorphisms
22:48:14 <ivanm> heh
22:48:54 <ivanm> OK...
22:49:45 <kmc> maybe the seventh time the flood will get through
22:50:06 <ivanm> heh
22:50:44 <adu> wow
22:51:16 <adu> its almost as if they have their quitting message set to "Excess Flood"
22:51:59 <kmc> so many people lurk in this channel
22:52:34 <kmc> :t (((.) . (.) . (,)) .)
22:52:35 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) a1 (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f2 a1 -> f2 (f (f1 a) -> f (f1 (a1, a)))
22:53:48 <ivanm> wait for it...
22:54:14 <ivanm> kmc: looks like the 7th time is the charm...
22:54:18 <kmc> yup
22:54:30 <ivanm> alt-dot-net-geek: so, are you connected or not?
22:54:39 <copumpkin> probably idle even if connected :P
22:54:51 <ivanm> copumpkin: heh, true
22:56:00 <alt-dot-net-geek> yes ivanm ... sorry about that
22:56:07 <alt-dot-net-geek> my client went beserk
22:56:36 <jrockway> you should use the type system to prevent your client from going berserk :)
22:56:56 <alt-dot-net-geek> nah ... just use a reputable client :-)
22:57:10 <alt-dot-net-geek> I'm kind of new to IRC
22:57:42 <copumpkin> yeah, don't pick up clients on street corners
22:57:48 <copumpkin> only go through an agency
22:57:54 <copumpkin> much safer
22:58:32 <ivanm> heh
22:58:37 <ivanm> copumpkin: you know from experience I take it?
22:58:38 <ivanm> ;-)
22:58:59 <alt-dot-net-geek> wish I could have made a better first impression though ...
22:59:43 <copumpkin> yeah
23:00:15 <copumpkin> that was my favorite internship ever
23:00:47 <ivanm> copumpkin: heh
23:00:54 <ivanm> why, where else have you done internships?
23:07:01 <o-_-o> which is the original paper on monads ?
23:08:32 <ski> maybe you mean work by Moggi ?
23:08:49 <ski> or maybe Wadler ?
23:09:17 <ski> Moggi applied monads in denotational semantics, to explain effects
23:09:29 <path[l]> I finally understood monads I think, but now I see some papers talking about how monads are passe and arrows are the new cool
23:09:35 <path[l]> I dont understand arrows
23:09:39 <ski> Wadler started using monads in FP
23:09:52 <ski> (and Moggi got them from Category Theory)
23:10:57 <ski> dolio : pong
23:12:36 <bnijk_> whenever i use cabal to install much of anything, i get     Could not find module `Distribution.Simple':
23:12:51 <bnijk_> i tried unregistering cabal from the per-user ghc-pkg database
23:12:56 <bnijk_> now i'm out of ideas
23:13:12 <o-_-o> http://lambda-diode.com/programming/monads-are-a-class-of-hard-drugs
23:13:24 <nus> bnijk_, what does 'ghc-pkg list Cabal' say?
23:13:30 <o-_-o> one of you should write a rebuttal to the above article
23:13:43 <bnijk_> one in /usr/lib, one in my home
23:13:48 <bnijk_> both package.conf.d
23:13:52 <o-_-o> as a newbie to haskell that article scares me
23:14:00 <CcSsNET> O.o
23:14:05 * CcSsNET reads as a noob
23:15:58 <adu> o-_-o: wtf
23:16:40 <nus> bnijk_, tried ghc-pkg check && recache?
23:16:58 <bnijk_> lots of broken packages
23:17:32 <nus> first recache, then check?
23:17:51 <bnijk_> still lots
23:21:37 <adu> Monad transformers = "crackoin" lololol
23:33:50 <jrockway> i stopped reading when he started "explaining" monads
23:34:28 <jrockway> kind of like explaining that money are pieces of paper you use to buy coffee
23:34:35 <jrockway> * is
23:36:06 <jrockway> also, darcs is the perfect argument for functional programming
23:36:11 <bnijk_> i met a cute chinese girl on chat roulette
23:36:11 <jrockway> it goes out of its way to have a very mutable model
23:36:15 <jrockway> and is, as a result, slow
23:36:18 <bnijk_> do you want to hear about it jrockway
23:36:34 <jrockway> git has a totally immutable model, and is very fast as a result
23:36:49 <jrockway> what's "chat roulette"
23:36:56 <bnijk_> random video chat
23:37:03 <BMeph> 1) Why reply to an article written over a year-and-a-half ago; 2) Why reply to someone who wants to look at Haskell programs, but can't be bothered to try Cabal...which is a Haskell program?
23:37:10 <bnijk_> it was a memorable experience
23:38:17 <Gracenotes> you get a lot of pointy objects with chat roulette
23:38:54 <BMeph> "Haskell programs tend to be slow, save for shootout-optimized ones." No data, no comparisons, and again, from a year and a half ago. Color me unimpressed.
23:38:54 <bnijk_> i believe you are speaking in euphemisms Gracenotes =-o
23:39:40 <Gracenotes> why, that's a decade in internet time
23:40:11 <jrockway> turns out monads are the same now as they were a year ago :)
23:40:37 <jrockway> i don't understand "you can only optimize haskell programs if you read about optimizing haskell programs"
23:40:50 <jrockway> because the obvious counter is "you can only optimize C programs if you read about optimizing C programs"
23:40:59 <jrockway> wow, you have to know how to program to program?
23:41:02 <jrockway> i didn't know that!
23:41:14 * bnijk_ knew that
23:41:31 <Gracenotes> I see both of those as being true
23:41:43 <jrockway> exactly
23:42:08 <jrockway> now, there might be a lot of literature on optimizing C programs, because people have been doing it for longer
23:42:10 <CcSsNET> yea i read that entire thing it didnt seem logical to me. like an excuse not to care haha
23:42:17 <jrockway> yeah, exactly
23:42:18 <jrockway> well said
23:42:31 <jrockway> "i know ML, and am going to continue using it" is not a very good blog post though
23:42:42 <CcSsNET> haha
23:42:56 <CcSsNET>  < didnt know ML existed O:-)
23:43:37 <Gracenotes> you may be surprised how many things exist :o
23:43:54 <CcSsNET> indeed, o hey look a wart
23:43:55 <bnijk_> he has a point about monads being a pain in the ass
23:44:12 <solrize> so if you write an imperative subroutine using iorefs as mutable variables, does ghc optimize it like a C compiler would, putting those iorefs in registers and so forth?
23:44:19 <dmwit> Yeah, it's a shame other languages have such lousy support for them.
23:44:25 <BMeph> "The essence of monads is to use abstract types to enclose a mutable state,"...except, of course, when then Don't. :|
23:44:43 <jrockway> > Just 42 >> Nothing
23:44:44 <lambdabot>   Nothing
23:44:45 <CcSsNET> i has lots to read -.-
23:44:54 <jrockway> oh noes, ABSTRACT TYPE ENCLOSING MUTABLE STATE
23:44:56 <jrockway> oh wait, no
23:45:04 <jrockway> a combinator to sequence related computations
23:45:10 <jrockway> that doesn't sound as scary i guess
23:45:21 * bnijk_ stopped listening when you guys started talking about haskell
23:45:24 <nus> bnijk_, re Distribution.Simple, perhaps recently broke some of Cabal dependencies?
23:45:30 <bnijk_> that is likely
23:45:46 <nus> like, say, filepath?
23:45:55 <Gracenotes> solrize: IO refs are, as the name implies, more like using pointers than primitive types (ints you'd fit into registers)
23:46:35 <solrize> Gracenotes, yes, but of course in principle, ghc could optimize them away a lot of the time.  i'm wondering if it actually does that.
23:46:39 <Gracenotes> they can be modified anywhere at any time if, say, one is passed to you... still, I'd think some optimization exists somewhere
23:47:04 <solrize> right, escape analysis can tell if they don't get passed anywhere
23:47:17 <solrize> so it's just a matter of how much the compiler knows about them
23:47:35 <Gracenotes> wonder how down+dirty you can get with whole-program supercompilation
23:47:45 <solrize> yeah
23:47:58 <dmwit> solrize: I bet there's a lot of low-hanging fruit in optimizing IO stuff.
23:48:04 <dmwit> You should go for it!
23:48:45 <Gracenotes> unplucked? :|
23:49:30 <solrize> i tried doing http://rubyquiz.com/quiz76.html in haskell and ended up putting the whole thing in IO in order to use RandomRIO
23:50:02 <solrize> i'm really not keen on the idiom of passing a StdGen because there's no type-level protection against using the same StdGen twice
23:50:05 <Gracenotes> as it is, ghc makes pretty mutable stuff out of pure funcs
23:50:40 <Gracenotes> not that useful of a point
23:52:47 <dmwit> solrize: uh
23:53:22 <dmwit> solrize: How does using randomRIO address the "no using the same StdGen twice" concern?
23:54:06 <solrize> randomRIO is an i/o action sequenced by the i/o monad
23:54:13 <dmwit> yeah
23:54:22 <dmwit> So is getStdGen and setStdGen.
23:54:35 <dmwit> So there's no type-level guarantee for randomRIO, either.
23:54:54 <solrize> i can't get randomRIO to repeat a state
23:55:00 <dmwit> Yes, you can.
23:55:02 <solrize> how?
23:55:46 <dmwit> do { g <- getStdGen; randomRIO (3, 100) >>= print; setStdGen g; randomRIO (3, 100) >>= print }
23:56:33 <dmwit> Might as well use MonadRandom, is all I'm saying.
23:56:51 <solrize> oh i see, setStdGen messes with a global generator.  that's actually kind of lame, but it's still pretty hard to do that by accident
23:57:28 <xerox> with great IO power comes great responsibility
23:57:36 <dmwit> MonadRandom is pure, and makes it equally hard to reuse a stdgen by accident.
23:57:59 <dmwit> Harder, really.
23:58:46 <dmwit> err... can be pure; IO is probably an instance =)
