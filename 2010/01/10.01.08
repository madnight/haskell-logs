00:00:41 <ivanm> grrr.... suddenly ghci keeps complaining about pcre-light problems with my code, when it shouldn't be using pcre-light at all :s
00:08:00 <glguy`> I just made a vty-based "Set" game, if anyone is interested
00:08:27 <glguy`> http://github.com/glguy/set-game/tree/vty
00:08:48 <glguy`> well, I made the original set stuff a few days ago, but the vty stuff is new tonight
00:09:56 <lament> what's it do?
00:10:31 <glguy`> It is a card game where you deal out 12 cards and look for sets of 3. each card has 4 attributes: filling, shape, count, color.
00:10:49 <glguy`> A set of 3 cards is one which for each of the attributes they are all the same or all different
00:11:19 <glguy`> same color, different count, same shape, same shading (there are 3 of each attribute)
00:11:38 <glguy`> the card game is often played with a group of people all racing ot find the sets
00:11:47 <glguy`> I haven't implemented scoring or anything yet
00:12:03 <lament> is this a real game?
00:12:13 <glguy`> You can buy it in stores, if that is what you are asking
00:12:24 <lament> 81 cards?
00:12:29 <glguy`> correct
00:16:17 <glguy`> This was my first use of the vty library, so it might be a little rough
00:17:48 <Nereid_> ooh, set
00:18:48 <glguy`> http://www.galois.com/~emertens/setgame.tiff
00:19:03 <glguy`> That's what it looks like with my colors and fonts...
00:19:15 <glguy`> (Unicode-art can be fussy)
00:20:18 <glguy`> Nereid_: If you've played the real game, I'd love to hear your impressions of this interface
00:20:24 <Nereid_> I have.
00:20:30 <Nereid_> I'll have a look.
00:21:41 <glguy`> I made it because I wanted to play on the airplane
00:21:51 <glguy`> and the cards kept sliding around during takeoff
00:22:16 <Nereid_> lol
00:27:42 <Nereid_> I should really be going to bed instead. :/
00:27:55 <glguy`> The code will be on github tomorrow :)
00:28:14 <Nereid_> What makes you think I'm going? :)
00:29:11 <Nereid_> The graphics look alright to me.
00:31:46 <Nereid_> You should make it multiplayer over the network ;)
00:32:19 <glguy`> That's what my grandpa said, too
00:35:14 <bos> Woohoo! I can now open 200,000 file descriptors concurrently in GHC and send messages through them efficiently.
00:35:22 <Nereid_> I hit a bug, glguy`
00:35:27 <Nereid_> resizing the terminal kills the game
00:35:33 <glguy`> heh
00:35:35 <Axman6> bos: you're a champ :) which OS's?
00:35:35 <glguy`> Umm...
00:35:39 <bos> Axman6: linux
00:35:49 <kmc> bos, nice! using epoll() ?
00:35:53 <glguy`> Nereid_: What terminal? I don't see that in OS X's terminal
00:35:53 <bos> yep
00:35:58 <kmc> cool
00:35:59 <Axman6> know if what you've used would work on OS X too?
00:36:00 <Nereid_> xfce4 terminal
00:36:07 <Axman6> think it has epoll
00:36:11 <bos> Axman6: we have a kqeueue back end for OSX and BSD
00:36:13 <Nereid_> same in xterm though
00:36:19 * bos `ap` bed
00:36:23 <Axman6> is that just as good?
00:37:41 <Nereid_> anyway I better head to bed.
00:37:50 <glguy`> goodnight
00:37:55 <glguy`> thanks for trying the game
00:38:02 <Nereid_> :)
00:38:03 <Nereid_> bye
00:55:02 <ziman> glguy`, what font is that in the screenshot?
00:55:18 <glguy`> Menlo Regular 11pt.
00:56:23 <ziman> thanks
01:31:49 * adu </3 NaN
01:32:19 <Axman6> but she's been so good to you!
01:32:28 <Jafet> Fun: implement IEEE 754 in Haskell
01:32:53 <adu> NaN is not good
01:33:10 <Jafet> She's naughty and infectious.
01:33:13 <adu> any why in hell in any sane world would
01:33:16 <adu> NaN :: Number
01:33:25 <adu> its not a Number! so why is it a Number?
01:33:30 <Jafet> > NaN
01:33:34 <lambdabot>   Not in scope: data constructor `NaN'
01:33:37 <adu> yey
01:33:41 <Axman6> :t 0/0
01:33:43 <ray> it's not a number, but it is a double
01:33:44 <lambdabot> forall t. (Fractional t) => t
01:33:53 <Jafet> > (0/0)::Num
01:33:54 <lambdabot>   Class `GHC.Num.Num' used as a type
01:34:06 <glguy`> Didn't we learn that you shouldn't put your non-members into your type? That's what Maybe is for
01:34:23 <Jafet> ALUs don't have Maybes
01:34:30 <adu> yes, NaN should by Nothing
01:34:32 <Jafet> FPUs, even
01:34:43 <Ytinasni> Jafet: sure they do: they're called NaN.
01:35:06 <Ytinasni> and they work a lot like Maybe's >>=
01:35:12 <Jafet> Actually, you could probably wrap IEEE 754 in a more type-safe interface
01:35:24 <Jafet> (That compiles down to the same thing.)
01:36:00 <adu> Jafet: that would be totally awsome
01:36:03 <shambler_> > 1/0
01:36:05 <lambdabot>   Infinity
01:36:06 <Jafet> isNaN :: IEEEFloat -> Bool; isNaN f = f == Nothing;
01:36:10 <shambler_> > 0/0
01:36:11 <lambdabot>   NaN
01:36:29 <shambler_> > Infinity/0
01:36:31 <lambdabot>   Not in scope: data constructor `Infinity'
01:36:41 <shambler_> @hoogle Infinity
01:36:42 <lambdabot> No results found
01:36:42 <Axman6> > (1/0)/0
01:36:44 <lambdabot>   Infinity
01:36:45 <Jafet> s/Nothing/NaN/ -- it's a data constructor!
01:37:08 * Axman6 votes that NaN be renamed to Ow
01:37:10 <glguy`> > read "Infinity" :: Float
01:37:12 <lambdabot>   Infinity
01:37:29 <glguy`> Quit pushing on the read/show warts
01:37:32 <glguy`> ;)
01:37:46 <Jafet> > read "Inf" :: Float
01:37:48 <lambdabot>   * Exception: Prelude.read: no parse
01:38:07 <Jafet> > read "NaN" :: Float
01:38:08 <lambdabot>   NaN
01:38:18 <adu> Axman6: is that what the computer is saying?
01:38:22 <shambler_> Why (1/0)/0 is Infinity? o_O
01:38:23 <Axman6> yes
01:38:39 <Jafet> Depends on the CPU signalling setting
01:38:48 <shambler_> should be NaN as far as I understand
01:38:52 <Jafet> "Ow, dispatch interrupt"
01:39:53 <Axman6> i saw a commit a while ago (possibly xkcd?) which equated NaN's to those dreams you have as you're falling alseep where you trip or something, and physically jump and wake yourself up
01:39:58 <adu> Ow! that hurt my memory!
01:39:59 <Axman6> comic even
01:40:09 <Axman6> too much RCS
01:40:17 <shambler_> haha
01:40:51 <adu> NaN == nightmare?
01:41:09 <Axman6> yup
01:41:09 <Jafet> @hoogle ieee
01:41:10 <lambdabot> Prelude isIEEE :: RealFloat a => a -> Bool
01:41:20 <Jafet> How coy.
01:42:00 <adu> (Just x + Just y)/(Just z)
01:42:09 <adu> maybe that wouldn't be so great
01:42:52 <Jafet> The magic of newtypes.
01:43:10 <Jafet> And Num instances.
01:43:28 <adu> oh, so (instance Num (Maybe Double))?
01:43:37 <Jafet> What
01:43:45 <Jafet> instance Num IEEEDouble
01:43:56 <adu> right, whatever
01:43:56 <Jafet> instance RealFrac, too
01:44:14 <Jafet> You'd need some small language extensions, ideally
01:44:18 * glguy` finds his last set for the night
01:44:24 <glguy`> ciao
01:45:51 <adu> Jafet: what would be supernice is a Boolean typeclass, and an implementation of (Boolean (Set Bool)) without an (Ord a =>) constraint
01:46:27 <adu> Jafet: or (Set anything) without an (Ord a =>) constraint for that matter...
01:46:43 <Jafet> You have to look at the problem from a different perspective.
01:47:24 <trzkril> adu: there is a -> Bool
01:47:28 <Jafet> For example, PolynomialField (GaloisField 2)
01:47:40 <adu> ooo interesting
01:47:49 <Jafet> Actually, what would Boolean (Set Bool) even mean?
01:47:58 <adu> Jafet: like what? I like different perspectives :)
01:48:59 <adu> Jafet: suppose "class Boolean a where false, true :: a; not :: a -> a; and, or :: a -> a -> a" or something
01:49:58 <Jafet> I don't see how to interpret Set Bool as an instance of a boolean type
01:50:02 <adu> then false = fromList [False], true = fromList [True], ...
01:50:53 <Jafet> @hoogle a -> Bool
01:50:54 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
01:50:54 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
01:50:54 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
01:51:24 <adu> and not = fromList . map not . toList, and = fromList . foldr and . toList, ...
01:51:48 <trzkril> adu: remind me of the monoid instances for Bool
01:51:53 <trzkril> reminds
01:51:55 <Axman6> adu: formList . return ....
01:52:09 <adu> Axman6: what?
01:52:25 <Axman6> oh maybe not
01:52:27 <Axman6> hmm
01:52:40 <Axman6>  :t toList here?
01:57:14 <adu> Jafet: basically each function would be the "image" of the input sets
01:59:28 <Jafet> Not even sure what Set Bool would mean, come to think of it
01:59:47 <Jafet> You lose all information except the number of true and false values
02:02:57 <kmc> sets hold unique values
02:03:11 <kmc> there are four values of type Set Bool
02:03:55 <kmc> extensionally and disregarding bottom etc.
02:05:01 <Jafet> Yeah
02:05:11 <adu> Jafet: it can be enumerated as "data SetBool = Nothing | False | True | TrueFalse
02:05:50 <adu> Jafet: its basically a (Maybe Tribool)
02:06:01 <Jafet> Heh
02:07:13 <Jafet> That makes it even harder for me to see it as an instance of Boolean...
02:07:45 <Paczesiowa> why doesn't CPP skip #! on the first line?
02:08:12 <adu> Jafet: do you know what a functional image is?
02:08:35 <adu> for example, recip 2 = 1/2
02:08:54 <adu> image recip [0..1] = [1..Infinity]
02:09:13 <Jafet> I thought I did, but then you put it in quotes!
02:09:19 <adu> oh
02:09:33 <adu> Jafet: you just take every value in the set and pass it through the function
02:09:50 <Jafet> Very well. Now all I'm missing is a use for it
02:10:01 <trzkril> adu: but the image of Nothing ist Nothing, the image of TrueFalse is TrueFalse, so what is the gain over Bool?
02:10:43 <adu> it is useful for checkboxes
02:11:31 <Jafet> Wouldn't that be a [] Bool?
02:11:48 <ivanm> *sigh* the problem with writing a library and the application that uses that library at the same time is that it's hard to work out where the bugs are coming from... :s
02:12:39 <trzkril> ivanm: at any given time you can only work on one of the two, so you can easily blame the other
02:13:10 <tibbe> @tell dons ghc-core needs to be migrated to the new exception module, it currently fails to compile on 6.10.4
02:13:10 <lambdabot> Consider it noted.
02:13:25 <Axman6> :(
02:13:30 <ivanm> trzkril: I was certain that the bug was in the application, but it ended up arising from an assumption from an older version of the library that remained when I re-wrote that part of it to add functionality
02:13:34 <adu> Jafet: [] Bool has many more values
02:13:35 <ivanm> tibbe: that's a known problem
02:13:44 <ivanm> tibbe: I've bitched to him about it enough times already ;-)
02:13:47 <tibbe> ivanm: ok
02:13:51 <Jafet> I would model one checkbox with one Bool
02:13:52 <ivanm> (for using base < 10 everywhere)
02:13:56 <Jafet> And multiple checkboxes with [] Bool
02:17:13 <ivanm> @slap data structures without show instances
02:17:14 * lambdabot will count to five...
02:17:42 <ivanm> I can't debug my code using FGL graphs by taking it from one module to another using show and read because it doesn't have reliable Show and Read isntances! :@
02:18:32 <Jafet> instance Show Graph where show g = startGraphViz $ serialize g
02:19:24 <ivanm> and for read? ;-)
02:19:40 <Jafet> Reader's exercise
02:19:43 * ivanm is considering resorting to labNodes/labEdges + mkGraph
02:19:45 <ivanm> Jafet: heh
02:23:28 <ivanm> damn; I just realised that I can't go to the other module to debug anyway, as it won't have the correct types defined :@
03:12:21 <pozic> What is a reasonable amount of time to bind to an unknown C++ library where you are only interested in one function?
03:13:43 <quicksilver> depends quite a lot on the type signature of the function.
03:13:56 <Zao> Free or member function?
03:14:00 <quicksilver> making a simple C wrapper and compiling that and FFI'ing to it is 5 minutes work
03:14:09 <quicksilver> a bit more if you need to remember which command line options to use.
03:14:24 <quicksilver> but if the function takes or returns custom data types, you will need to wrap those also somehow
03:14:52 <quicksilver> and then you need to know if you need an opaque wrapping or a full one etc etc
03:23:23 <mir4u> SALaaaaaaaaaaaaam  / HI /  2  ALL
03:23:40 <osaunders> Any ideas how I could improve this: <http://codepad.org/US1OGozO>?
03:23:49 <osaunders> Oh whoops wrong channel.
03:23:59 <osaunders> Sorry that's C not Haskell. Ignore me. Carry on!
03:24:09 <osaunders> ...with haskell discussion.
03:25:47 <mir4u> ISLAM ! UR Life right n Best future  www.turntoislam.com   www.sultan.org  www.raastenraah.com
03:26:18 <osfameron> !ops > mir4u
03:26:26 <pozic> Zao: member function.
03:26:28 <osfameron> or whatever the pesky command is
03:26:35 * osfameron sighs
03:26:36 <ksf> ...you know, compiling everything twice, that is, with profiling and without profiling was kinda adorably cute.
03:26:57 <Zao> pozic: That implies that you need to wrap creation and destruction of the object it's a member of.
03:27:03 <ksf> ...but compiling stuff thrice, that is, statically, profiled-statically and dynamic, is a bit telling.
03:27:09 <Zao> Unless you mean static member function, which is equivalent to free function.
03:27:30 <ksf> @ops
03:27:30 <lambdabot> Maybe you meant: docs oeis pl
03:27:31 <pozic> Zao: how are static member function denotes in C++ again?
03:27:34 <ksf> @where ops
03:27:34 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
03:27:38 <pozic> Zao: denoted*
03:28:00 <Zao> pozic: struct S { static void f(int); }
03:28:01 <Zao> ;
03:28:28 <pozic> Zao: ah, so nothing special :)
03:28:30 <Zao> Callable via S::f(42) or s.f(42) where s is an instance of S (which will not be used).
03:28:32 --- mode: ChanServ set +o Igloo
03:28:48 --- mode: Igloo set +b *!*@117.20.26.32
03:28:53 --- kick: mir4u was kicked by Igloo (Igloo)
03:29:06 * ksf tries setting library-vanilla to false
03:29:11 <ksf> ...which does'nt work.
03:29:42 <pozic> Zao: it also takes longer when the project that it contains has a built system from 500BC.
03:29:49 <pozic> build system*
03:31:11 <ksf>  *** This will be an error in GHC 6.14! Fix your code now!
03:31:14 <ksf> ++ghc
03:31:18 <ksf> ...for being explicit.
03:31:19 * zygoloid ponders what mir4u was hoping would happen
03:31:45 * hackagebot upload: hack-handler-epoll 0.1 - hack handler implementation using epoll (ToralfWittner)
03:35:06 <kmc> hmm, islam spam
03:35:09 <kmc> that's a new one
03:35:31 <ivanm> kmc: nah, seen that here before IIRC
03:36:07 <ivanm> ksf: what causes that? :o
03:36:45 <kmc> @ghc
03:36:46 <lambdabot> ghc says: Duplicate binding in parallel list comprehension
03:52:27 <HaskellLove> anyone has solved euler 27 please let me know i have a question?
03:55:02 <zygoloid> HaskellLove: yeah, i've solved it
03:55:14 <Zao> Yes.
03:56:39 <Zao> I do not have my implementation around, but it should be trivial.
03:56:45 <HaskellLove> after two days on the problem i cant figure out where i am wrong. here is the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15723#a15723 the result so far i get is 1 for a and 41 for b, which is not the constants i should get
03:57:06 <Zao> HaskellLove: Should be brute-forcable.
03:57:21 <HaskellLove> Zao it probably is but i get the wrong result
03:57:56 <HaskellLove> n² + an + b     I get 1 for a and 41 for b, which is Eulers formula and produces 40 primes, but it is not the optimal formula
03:59:53 <Zao> If you feed your code a=-79 and b=1601, does it produce the right count?
04:00:07 <Zao> If not, investigate why.
04:06:10 <HaskellLove> all fine there, i get all 80 as i should
04:08:15 <zygoloid> HaskellLove: you're not trying negative values of a
04:08:52 <zygoloid> HaskellLove: try changing a <- [1..1000] to a <- [-1000..1000]
04:09:41 <HaskellLove> yeah i think i did that and i messed the code but i get same result... and yes a goes -1000..1000 and be is positive to 1000 ... let me try again, did not work last night
04:12:07 <HaskellLove> -59231 i got it, wtf? i guess i was sleepy to miss that... thanks guys
04:39:10 * hackagebot upload: hakyll 0.4 - A simple static site generator library. (JasperVanDerJeugt)
04:44:47 <RayNbow> preflex: seen lunabot
04:44:48 <preflex>  lunabot was last seen on #haskell 8 hours, 13 minutes and 3 seconds ago, saying:  :o
04:44:52 <RayNbow> preflex: seen luite
04:44:53 <preflex>  luite was last seen on #haskell 6 hours, 4 minutes and 47 seconds ago, saying: a soft hyphen
05:29:21 * Cyneox re
05:47:12 <pham> how do you write an if with only one branch in a do block?
05:48:36 <mux> you mean with only a then and no else?
05:48:42 <pham> I guess you'd use unless or when from Control.Monad, but why is the type signature "m ()" instead of "m a"?
05:48:43 <mux> because that doesn't exist, you want when
05:48:44 <mux> :t when
05:48:46 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:48:55 <mux> unless p = when (not . p)
05:49:58 <jlouis> :t unless
05:49:59 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:50:52 <edwardk> preflex: xseen luqui
05:50:53 <preflex>  luqui was last seen on freenode/#haskell 3 days, 1 hour, 4 minutes and 26 seconds ago, saying: well it's not specific, and surely more than just an internal colonel
05:51:22 <mux> pham: (hadn't see your last comment) when/unless cannot return anothing meaningful since if the condition isn't met, the code won't run and there would be nothing to return; so they return ()
05:51:37 <mux> when/unless could however have the more general type:
05:51:46 <mux> Monad m => Bool -> m a -> m ()
05:52:23 <raichoo> Hi, everyone. I'm totally new to haskell. Is there any particular naming scheme behind the functions that are written in backticks? I'm a bit confused when to write something like `mod` or `elem`.
05:52:44 <zygoloid> raichoo: they're just normal functions
05:52:44 <mux> raichoo: we use that just when it feels natural
05:52:54 <zygoloid> raichoo: any function can be used between backticks
05:52:57 <mux> raichoo: like 10 `div` 2 is more natural than div 10 2
05:53:10 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=28 is there any interesting thing to know about spiral numbers before i tackle the problem?
05:53:19 <Ke> > 10 `(2)` 2
05:53:20 <lambdabot>   <no location info>: parse error on input `('
05:53:25 <raichoo> and why not just 10 div 2? why the backticks?
05:53:26 <Ke> > 10 `(+)` 2
05:53:27 <lambdabot>   <no location info>: parse error on input `('
05:53:32 <Saizan_> raichoo: the backticks are not part of the name of the function, you use them to make the function infix
05:53:40 <copumpkin> HaskellLove: the fact that you can figure them out just by looking at the for a little while
05:54:18 <Jafet> Ke, lol syntax.
05:54:29 <shambler> nice try tho
05:54:33 <raichoo> Ok so you just use the backticks to say: this is meant to be infix?
05:54:37 <zygoloid> Jafet: i think haskell'09 allows `(+)`
05:55:08 <Jafet> It's not meant to be infix, but with the backticks it is
05:55:26 <Jafet> > let a + b = 42 in (+) 1 2
05:55:28 <zygoloid> (it's part of sorting out the Prelude.+ fiasco iirc, you now write Prelude.(+) and `Prelude.(+)` if you want infix)
05:55:28 <lambdabot>   42
05:55:38 <Jafet> > let foo a b = 42 in 1 `foo` 2
05:55:39 <lambdabot>   42
05:56:01 <Jafet> zygoloid, so how would it be done in hs98?
05:56:01 <raichoo> Ah ok
05:56:17 <raichoo> Now i get it nice :)
05:56:19 <raichoo> Thanks
05:56:23 <zygoloid> Jafet: it's "a Prelude.+ b" in '98
05:56:33 <opdolio> (`(`(`(+)`)`)`)
05:56:42 <Jafet> Oh, duh
05:56:57 <Jafet> How's that a fiasco though?
05:56:57 <Ke> awesome!
05:57:01 <b_jonas> > Prelude.(+) 3 8
05:57:03 <lambdabot>   Not in scope: data constructor `Prelude'
05:57:10 <b_jonas> > (Prelude.+) 3 8
05:57:11 <lambdabot>   11
05:57:37 <shambler> > 3 `(Prelude.+)` 8
05:57:38 <lambdabot>   <no location info>: parse error on input `('
05:57:43 <Saizan_> so you can no longer say Prelude.+ ?
05:57:51 <zygoloid> Jafet: it makes things hard to read, since operators can start with alphabetic characters, and it generates confusing lexemes such as Prelude..
05:57:51 <HaskellLove> copumpkin ok cool, you know i have to ask when i see something new so :) so i dont reinvent wheels and stuff
05:58:08 <Saizan_> that's crazy, should i write `(M.!)` when i use Data.Map, now?
05:58:10 <Jafet> Indeed.
05:58:12 <copumpkin> the whole point of project euler is to reinvent wheels
05:58:20 <copumpkin> ten thousand people have already solved each problem :P
05:58:29 <shambler> hehe
05:58:35 <copumpkin> bbl
05:58:37 <Jafet> copumpkin, or copied them off of other people who have
05:58:41 <zygoloid> http://hackage.haskell.org/trac/haskell-prime/wiki/QualifiedOperators
05:58:49 <Jafet> Yeah, don't come back!
05:59:19 <shambler> Jafet, why copy? Solving problem will not give you money or girls
05:59:31 <b_jonas> why, what's wrong with Prelude.+ apart from when the name of the op itself has dots?
05:59:43 <Jafet> Why don't you ask the poor virgins who do it?
05:59:47 <Ke> not even google money?
06:00:10 <Jafet> The official currency of Googleland
06:01:18 <shambler> :)
06:01:28 <paolino> Saizan_: `M.(!)` ?
06:01:39 <Saizan_> paolino: it seems
06:01:47 <pham> I want a function of type "Maybe String -> Maybe String" where if the argument is "" then it returns Nothing, otherwise it's id
06:02:05 <Jafet> let a ! b = M.(!) a b
06:02:06 <Saizan_> qualified names were already pretty ugly to use, now they want people to stop using qualified operators i think :)
06:02:26 <Jafet> Saizan, sneaky.
06:02:42 <zygoloid> in fact, ignore my assertion that this is in haskell'10; i obviously fail at telling the difference between 'complete' and 'accepted'
06:03:20 <Saizan_> pham: Maybe String -> Maybe String or String -> Maybe String ?
06:03:36 <Jafet> Well, technically you only said that it's in "haskell'09", whatever that is
06:03:46 <pham> I guess this is fine: validate (Just "") = Nothing; validate s = s
06:03:48 <Botje> pham: (>>= (\x -> if null x then Nothing else Just x)
06:03:56 <paolino> I predict some more double imports , qualified and not, of the same module, or worse custom forged operators
06:04:21 <pham> Botje: thanks. That's what I was looking for
06:04:44 <pham> Botje: I think the pattern matching version is a lot more readable though ;)
06:04:48 * hackagebot upload: Graphalyze 0.9.0.0 - Graph-Theoretic Analysis library. (IvanMiljenovic)
06:04:50 * hackagebot upload: SourceGraph 0.6.0.0 - Static code analysis using graph-theoretic techniques. (IvanMiljenovic)
06:04:56 <Botje> yup :)
06:07:02 <Phyx-> pham: alternatively
06:07:04 <Phyx-> (>>= (\x -> guard (not $ null x) >> return x))
06:07:08 <Phyx-> would work aswell
06:07:33 <Phyx-> @pl (>>= (\x -> guard (not $ null x) >> return x))
06:07:33 <lambdabot> (ap ((>>) . guard . not . null) return =<<)
06:10:04 <pham> Phyx-: I don't even understand that on
06:10:07 <pham> e
06:10:33 <Jafet> :t (ap ((>>) . guard . not . null) return =<<)
06:10:35 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m [a] -> m [a]
06:10:38 <Phyx-> pham: the one i posted or the pointfree one?
06:10:40 <Jafet> Amazing clarity.
06:10:47 <joe3> :t forM
06:10:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
06:12:30 <joe3> :t appendFile
06:12:32 <lambdabot> FilePath -> String -> IO ()
06:12:40 <joe3> :t writeFile
06:12:42 <lambdabot> FilePath -> String -> IO ()
06:13:43 <Phyx-> pham: it's actually quite simple, it says that, if x is not null, then proceed, if x is null the guard function calls fails, which in the case of the Maybe Monad returns Nothing
06:13:48 <Phyx-> @src guard
06:13:49 <lambdabot> guard True  =  return ()
06:13:49 <lambdabot> guard False =  mzero
06:14:06 <Phyx-> @src MonadPlus Maybe
06:14:07 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:14:14 <b_jonas> though if you really wanted to, you could use the specialized functions in Data.Maybe instead of monad magic
06:14:20 <Phyx-> @src Maybe MonadPlus
06:14:21 <lambdabot> Source not found. That's something I cannot allow to happen.
06:14:34 <Phyx-> how does that work again....
06:14:51 <Jafet> @src MonadPlus
06:14:51 <lambdabot> Source not found. There are some things that I just don't know.
06:15:21 <Phyx-> Jafet: well, MonadPlus is a class, so it would need an instance, if i understood correctly
06:15:30 <Phyx-> @src MonadPlus (Maybe a)
06:15:31 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:15:32 <Jafet> src can display classes
06:15:32 <doserj> @src Maybe mzero
06:15:33 <lambdabot> mzero = Nothing
06:15:38 <Jafet> @src Num
06:15:39 <lambdabot> class  (Eq a, Show a) => Num a  where
06:15:39 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:15:39 <lambdabot>     negate, abs, signum     :: a -> a
06:15:39 <lambdabot>     fromInteger             :: Integer -> a
06:15:45 <doserj> @src Maybe mplus
06:15:46 <lambdabot> Nothing `mplus` ys = ys
06:15:46 <lambdabot> xs      `mplus` ys = xs
06:15:59 <Phyx-> what an odd bot..
06:16:11 <Jafet> Ask whoever maintains the database to add MonadPlus?
06:17:42 <masxmasx> :t readFile
06:17:44 <lambdabot> FilePath -> IO String
06:20:22 <Axman6> huh, who would have thought that creating a marking spreadsheet in Numbers would be so interesting
06:20:32 <masxmasx> when reading a file using readFile, how can I have it give my error instead of haskell's when file is not found?
06:20:54 <Saizan_> you can catch the exception
06:21:03 <Saizan_> see Control.Exception.catch
06:21:11 <masxmasx> okay thanks :)
06:27:13 * hackagebot upload: SourceGraph 0.6.0.1 - Static code analysis using graph-theoretic techniques. (IvanMiljenovic)
06:30:11 <ivanm> stupid bugs...
06:31:15 <Alpounet> haha
06:32:06 <joe3>          dplusfiles <- globDir1 (compile "dplus*") "/tmp/data/" dplus <- mapM getdata $ sort dplusfiles writeFile "dplus" $ unlines $ map show $ concat dplus
06:32:12 <ivanm> OK, I've finished SourceGraph only 3 days after my initial estimated deadline...
06:32:20 <ivanm> now I"ve just got to write the talk! :s
06:32:29 <ivanm> but that's for later...
06:32:34 * ivanm -> collapses in bed
06:32:35 <joe3>          dplusfiles <- globDir1 (compile "dplus*") "/tmp/data/" ; dplus <- mapM getdata $ sort dplusfiles ; writeFile "dplus" $ unlines $ map show $ concat dplus
06:32:45 <joe3> is there a smarter way of doing the above
06:32:54 <joe3> getdata :: String -> IO [[Int]]
06:33:09 <joe3> i thought of using liftM.
06:33:37 <ivanm> replace unlines with lenth . filter ((==) '\n') ? :p
06:33:45 <joe3> I am more worried from a performance standpoint. but, do I need to worry about its performance as it is lazy evaluation?
06:34:04 <joe3> it is definitely running slow but I have a crappy machine too.
06:34:31 <joe3> Just curious if there are any big performance 'no-no's in that code.
06:35:07 * Axman6 would say that using f $ g $ h x is a no-no, but not an important one
06:36:30 <dino-> Axman6: What's no-no about that?
06:37:43 <Axman6> the preferred way to write that would be f . g . h $ x
06:37:59 <Axman6> (.) is for function composition, ($) is for removing brackets
06:38:15 <Axman6> (so, you write f . g . h $ x instead of (f . g . h) x
06:38:17 <dino-> Ok, I can agree with that.
06:38:29 <Axman6> )
06:38:35 <masxmasx> in an html request: GET  /index.html  HTTP/1.1, how would I just grab the entry "/index.html" from the request?:$
06:40:42 <masxmasx> as in, i want a word out of a sentence, but I don't know what the word is, or what the rest of the sentence is, but i know at what place it is, how would I do this?
06:41:04 <Jafet> > words "GET  /index.html  HTTP/1.1"
06:41:06 <lambdabot>   ["GET","/index.html","HTTP/1.1"]
06:41:21 <Axman6> (!! 2) . words >_>
06:41:27 <Axman6> uh, 1
06:42:16 <Axman6> though, i'd recommend doing some actual parsing
06:42:36 <masxmasx> if I knew how to, Axman6 :p
06:42:46 <Axman6> time to learn some parsec :)
06:43:01 <masxmasx> I just have to do this as an universityexcersise, I find haskell really hard...=\
06:43:12 <Axman6> i though parsing would be really hard for a long time, but it turns out it's actually quite fun, onve you get the hang of it
06:43:21 <shambler> it's the matter of habbit
06:43:23 <shambler> at least basics
06:43:41 <dino-> masxmasx: If you're using Network.CGI, there is a call to isolate that part of the request
06:43:43 <Axman6> masxmasx: it'll grow on you, and then you'll be wishing all other languages were more like haskell :)
06:44:03 <masxmasx> I am, dino-, how would I see how to use that?
06:45:16 <masxmasx> the hackage for that isn't really helpful
06:45:36 <Phyx-> Network.CGI requestURI :: MonadCGI m => m URI
06:45:39 <Phyx-> i think
06:45:40 <dino-> masxmasx: I'm no expert, but have used pathInfo and there is also progURI, queryURI and requestURI
06:46:11 <dino-> All in Network.CGI
06:46:54 <masxmasx> wow, i got a lot to learn about haskell..
06:47:07 <Botje> masxmasx: some people have been at it for ten years now ;)
06:47:27 <dino-> Exploring this person's web app done with Network.CGI helped me quite a bit with how these modules work. http://jekor.com/article/is-haskell-a-good-choice-for-web-applications
06:47:53 <dino-> And this: http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell
06:49:08 <masxmasx> oh, im using Network.URI and Network.Shed.Httpd instead of Network.CGI :(
06:49:51 <Phyx-> masxmasx: same thing applies though
06:50:00 <Phyx-> Httpd shed has a reqURI method
06:51:58 <Phyx-> masxmasx: http://hackage.haskell.org/packages/archive/httpd-shed/0.4/doc/html/Network-Shed-Httpd.html#v%3AreqURI
06:52:14 <Phyx-> and damn, i should watch that button, :s
06:53:16 <masxmasx> thanks
06:54:27 <pham> How do you perform IO actions in a do block that's of type "(Monad foo) => foo IO a" ?
06:55:17 <Axman6> i don't believe that type makes any sense
06:55:20 <pham> specifically "ServerPartT IO Response" (from Happstack)
06:55:34 <Gracenotes> if it's MonadIO, you use liftIO
06:55:43 <pham> :t liftIO
06:55:44 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
06:55:46 <Axman6> ah, that's a monad transformer
06:56:06 <pham> ah, liftIO is what I need
06:56:54 <masxmasx> how to use this reqURI? :$ using readFile (reqURI) does not simply work, as reqURI does not give me a FilePath
06:57:26 <Axman6> well no
06:57:34 <Axman6> what is the type of reqURI?
06:57:41 <masxmasx> Request -> URI
06:58:02 <Axman6> so, firstly, you need to give it a request
06:58:09 <Gracenotes> readFile does do files, on the filesystem.
06:58:12 <Axman6> then you need a way to turn a URI into a FilePath
06:58:46 <Gracenotes> unless it's something like file:///home/blah/file, not much to do
06:59:14 <masxmasx> I just want it to use the same folder as the fileserver runs in
06:59:20 <Alpounet> network-download (or something similar) on Hackage may be of help for that.
07:00:29 <Axman6> i think he's required to use certain libraries
07:00:38 <Phyx-> :t uriPath.reqURI
07:00:39 <lambdabot> Not in scope: `uriPath'
07:00:39 <lambdabot> Not in scope: `reqURI'
07:01:44 <masxmasx> yes, im required to use Network.URI or Network.Shed.Httpd
07:03:27 <Phyx-> masxmasx: http://hackage.haskell.org/packages/archive/network/2.2.1.3/doc/html/Network-URI.html#t%3AURI
07:03:53 <Phyx-> if you use reqURI to get the uri, you can use those methods on the URI you get
07:05:35 <masxmasx> awesome! thank you :)
07:05:46 <fahmi> terima kasih
07:05:48 <Phyx-> wow, this channel was really small back in '04
07:06:04 <fahmi> baikkkkkkkk :'(
07:06:14 <Phyx-> fahmi: english please
07:06:41 <Phyx-> ok...
07:06:50 <masxmasx> :t reqURI
07:06:51 <lambdabot> Not in scope: `reqURI'
07:06:56 <Axman6> good chance they didn't knwo where they were
07:07:22 <Phyx-> Axman6: that and it's odd to join and say "thank you" as the first thing
07:09:07 <Axman6> ah
07:10:24 <masxmasx> readFile (uriPath(reqURI)) doesn't work, that gives: couldn't match expected type `URI' against inferred type `Request -> URI'
07:10:29 <masxmasx> halp?:(
07:11:45 <doserj> readFile (uriPath (reqURI yourRequest))
07:11:49 <doserj> I would guess
07:12:59 <Phyx-> yes, you still need to give reqURI a Request object to work on
07:13:55 <Phyx-> and uriPath will always include a leading slash
07:14:17 <masxmasx> why?
07:14:58 <masxmasx> what would a slash be for?:$
07:16:13 <damd> there's nothing in the URI spec that says uriPath must include a leading slash
07:16:23 <damd> aiui, "hello" is a valid URI
07:16:50 <masxmasx> ah, a leading slash, i see
07:19:50 <Phyx-> damd: uriPath returns everything after the scheme and the authority up to a ? or #
07:20:01 <Phyx-> http://foo/test -> /test
07:20:08 <damd> Phyx-: right, but what about relative URIs?
07:20:45 <Phyx-> damd: what about them? uriPath doesn't resolve any paths. it just gives you part of the string
07:21:10 <damd> Phyx-: then what says that uriPath will always include a leading slash?
07:22:05 <damd> "hello" is a relative URI in which uriPath is "hello", is it not?
07:22:14 <Phyx-> no
07:22:19 <Phyx-> because a in a valid uri
07:22:36 <Phyx-> hello would be <scheme><authority>/hello
07:22:47 <Phyx-> in which case "/hello" is given back
07:22:59 <damd> so you're saying "hello" is not a valid URI?
07:23:55 <Phyx-> damd: no, i'm saying, reqURI will never just return "hello"
07:24:55 <masxmasx> but wouldn't uriPatch take the slash from the /hello?
07:25:16 <Phyx-> the request is just parsed not processed when the Request object is made.
07:35:10 <masxmasx> !pastebin
07:35:13 <masxmasx> !paste
07:35:18 <masxmasx> !haskellpaste
07:35:22 <masxmasx> :(
07:35:28 <Ke> hpaste.org
07:35:29 <masxmasx> what's that pastebin that supports haskell again?
07:35:31 <masxmasx> ah thanks
07:35:53 <voker57_> @where paste
07:35:54 <lambdabot> http://hpaste.org/new
07:36:26 <benmachine> quite a few pastebins support haskell but hpaste is our favourite I think
07:36:42 <masxmasx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15725#a15725 can someone take a look at that?
07:36:48 <masxmasx> all work well, cept for fileServer
07:36:49 <benmachine> see also: unsafecoerce.com
07:37:08 <masxmasx> I think I misunderstand how simpleServer works
07:37:14 <Jafet> What's the opinion on codepad.org?
07:37:48 <benmachine> it's a nice idea but often not necessary imo
07:38:24 <McManiaC> is it possible to get a strace of an error message?
07:38:53 <masxmasx> you were talking to me, McManiaC?
07:39:02 <McManiaC> hm? no
07:39:06 <McManiaC> in general
07:39:07 <masxmasx> ah
07:39:10 <benmachine> what's an strace of an error message
07:39:13 <masxmasx> ^
07:39:33 <McManiaC> well a stack trace of that error
07:39:37 <benmachine> oh
07:39:44 <benmachine> call them stack traces, strace is something else
07:39:52 <McManiaC> kay
07:39:53 <McManiaC> ^^
07:39:56 <benmachine> (a program for tracing system calls)
07:41:14 <benmachine> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html 'There is currently no support for obtaining a “stack trace”, but...'
07:41:28 <benmachine> there are a few ways of getting things which are helpful
07:41:34 <benmachine> probably none of them are exactly what you want
07:41:38 <Jafet> Well, sometimes the stack isn't there anymore
07:42:30 <McManiaC> hmmm
07:44:01 <benmachine> http://hackage.haskell.org/package/control-monad-exception the description for this soudns like it might be useful
07:44:09 <benmachine> but I haven't the experience to tell you exactly
07:44:18 <benmachine> what it does
07:44:43 * hackagebot upload: PortMidi 0.1.3 - A binding for PortMedia/PortMidi (PaulLiu)
07:44:59 <McManiaC>     Could not find module `System.Log.Logger':
07:44:59 <McManiaC>       Perhaps you haven't installed the profiling libraries for package `hslogger-1.0.7'?
07:45:10 <McManiaC> in ghci I can load System.Log.Logger
07:45:25 <McManiaC> any idea why ghc ... -prof -all-auto doesnt find it?
07:45:36 <benmachine> because the library wasn't compiled with profiling support
07:45:57 <McManiaC> hm oka
07:45:57 <McManiaC> y
07:46:01 <benmachine> I think there's a config option
07:46:12 <benmachine> or you could look at cabal install --help
07:47:01 <Saizan_> -p
07:47:02 <benmachine> if you want to enable profiling support for all newly installed libraries, you can set the library-profiling option in ~/.cabal/config
07:47:42 <McManiaC> ok cool
07:50:29 <Phyx-> McManiaC: actually, Simon P Jones recently wrote a paper on how to get stack traces in haskell
07:50:38 <Phyx-> no idea if that will eventually be ported into ghc
07:50:48 <McManiaC> hmm
07:51:45 <McManiaC> hmmm :S
07:51:54 <McManiaC> I get a lot of "not in scope" errors now…
07:52:14 <Phyx-> masxmasx: look at the type of the 3rd argument of response. and then look at the type of "leesBestand". that should be your first clue
07:53:45 <Phyx-> McManiaC: http://research.microsoft.com/~simonpj/papers/stack-trace/DebugTraces.pdf btw, just for reference
07:56:20 <mmorrow> hola
07:56:24 <mmorrow> > fix error
07:56:26 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
07:56:44 <Phyx-> lol
07:56:59 <mmorrow> that's funny no matter how many times you see it
07:57:25 <Phyx-> yes... which is an indication that i need to get out more
07:57:38 <Jafet> @quote fix.error
07:57:38 <lambdabot> Berengal says: I was squashing a bug, got frustrated, and typed "fix error" in ghci...
07:57:51 <Jafet> Exceptional.
07:58:15 <mmorrow> Saizan hacked that behavior into lambdabot, unfortunately that won't happen in ghci
07:58:23 <masxmasx> Phyx-: what 3rd argument? there are only two?
07:58:41 <mmorrow> although i think it'd be relatively easy to do
07:58:57 * mmorrow tries to remember or guess what Saizan did
08:00:04 <Phyx-> masxmasx: right, then you're giving  the wrong ones. the second argument to Response is the headers, of tpe [(String,String)], you're supplying an IO String
08:00:15 <Phyx-> masxmasx: look at simpleServer
08:00:58 <masxmasx> simpleServer works fine
08:01:14 <masxmasx> the only problem is fileServer
08:01:20 <masxmasx> I didn't write simpleServer myself
08:01:40 <Phyx-> i know simpleServer looks fine, which is why i said to look at it.
08:02:04 <masxmasx> ah
08:02:10 <masxmasx> sorry :) my bad
08:02:13 <Phyx-> the type of response is Int -> [(String,String)] -> String -> Response
08:02:30 <mmorrow> hmm, i guess actually lambdabot or some controlling code must be catching the exception from error, rather that it being some modified error function..
08:02:40 * mmorrow gives up for now
08:02:55 <McManiaC> :S
08:02:58 <Phyx-> the second argument is the header, if you look at simpleServer you'll see how one is constructed
08:03:08 <McManiaC> ok, I lost connection… how do you build base with profiling?
08:03:56 <Phyx-> the third argument should be the body, e.g the string you want to send back. In the case of simple server, the request object is shown and returned
08:04:08 <Phyx-> @unpl return . Response responseOK [contentText] . show
08:04:09 <lambdabot> (\ c -> return (Response responseOK [contentText] (show c)))
08:04:16 <Phyx-> see
08:05:15 <blobl> is wxhaskell really working???
08:05:45 <mmorrow> if anyone is still thinking about fix error, it looks like mubot/lambdabot's code that does this is bottom of http://code.haskell.org/mubot/mueval/Mueval/Interpreter.hs
08:07:01 <copumpkin> omg it's mmorrow
08:07:30 <mmorrow> zomgomnom!
08:07:50 <mmorrow> sup
08:08:03 <benmachine> mmorrow: what do you mean that won't happen in ghci?
08:08:35 <mmorrow> benmachine: haha, for some reason i thought it didn't
08:08:45 <mmorrow> maybe it didn't use to or something (??)
08:08:51 * benmachine shrugs
08:08:56 <benmachine> it makes sense that it does
08:09:23 <masxmasx> so Phyx-, show sends back the request sent by the browser?
08:09:44 <masxmasx> if it's a parameter of Response, why is there a period included?
08:10:00 <benmachine> when it tries to show the error message, it evaluates the argument to error, which is fix error
08:10:03 <benmachine> which throws an error
08:10:08 <mmorrow> benmachine: "fix id" used to make ghci lock up (killall -9 ghc)-cold before like 6.10
08:10:10 <benmachine> madness results
08:10:29 <benmachine> mmorrow: fair enough
08:10:38 <mmorrow> iirc there was some change with ghci-related rts signal handling or some such
08:10:43 * benmachine doesn't have an installation of 6.8 anymore so shrugo
08:10:47 <benmachine> er, shrug
08:10:49 <mmorrow> hah, me neither
08:10:55 <benmachine> oh wait I might do
08:10:58 * mmorrow is yum list *ghc*
08:11:28 <benmachine> 6.8.2 does the same thing for fix error
08:11:32 <mmorrow> nice
08:11:53 <Phyx-> masxmasx: because the function is written in a pointfree notation
08:12:00 <Phyx-> @unpl return . Response responseOK [contentText] . show
08:12:00 <lambdabot> (\ c -> return (Response responseOK [contentText] (show c)))
08:12:11 <Phyx-> masxmasx: those two are equivalent
08:12:25 <Phyx-> which is the same as
08:12:34 <Phyx-> simpleServer c =  return (Response responseOK [contentText] (show c))
08:12:44 <benmachine> mmorrow: and 'fix id' almost immediately gets me a stack overflow
08:12:48 <masxmasx> ah okay thanks :)
08:13:05 <benmachine> this is some ssh shell I have so maybe it's ulimited in some strange way
08:13:21 <mmorrow> benmachine: but you can break from "fix id" without a SIGKILL in your 6.8?
08:13:50 <mmorrow> oh, hmm
08:13:54 <benmachine> mmorrow: it doesn't last long enough for me to be sure :
08:13:54 <mmorrow> i get stack overflow too
08:13:55 <benmachine> :P
08:14:02 <mmorrow> ohh, right.
08:14:05 <mmorrow> let x = x in x
08:14:11 <benmachine> ah
08:14:12 <mmorrow> is what'll lock you up pre-6.10
08:14:47 * benmachine stops trying to find ways to break things
08:19:03 <Phyx-> fix "whooo"
08:19:13 <Phyx-> > fix (const "whooo")
08:19:14 <lambdabot>   "whooo"
08:19:24 <Phyx-> > fix (++"whooo")
08:19:28 <lambdabot>   mueval-core: Time limit exceeded
08:19:31 <Phyx-> lol
08:19:37 <Phyx-> > fix ("whooo"++)
08:19:38 <lambdabot>   "whooowhooowhooowhooowhooowhooowhooowhooowhooowhooowhooowhooowhooowhooowhoo...
08:21:54 <lispy> preflex: seen Cale
08:21:54 <preflex>  Cale was last seen on #haskell 9 hours, 16 minutes and 45 seconds ago, saying: > join (++) "echo"
08:21:55 <MoALTz> fix (:[])
08:21:58 <MoALTz> > fix (:[])
08:22:00 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:22:27 <lispy> ?tell Cale in the email I sent you about show, it's possible the 0.6/1.6 vs. 0.8/1.8 distinction is a red herring
08:22:28 <lambdabot> Consider it noted.
08:22:32 <Jafet> :t fix
08:22:34 <lambdabot> forall a. (a -> a) -> a
08:22:42 <Jafet> :t (:[])
08:22:44 <lambdabot> forall a. a -> [a]
08:22:57 <Jafet> > fix (++[])
08:23:01 <lambdabot>   mueval-core: Time limit exceeded
08:23:02 <Arxor> hi
08:23:18 <lispy> Hello
08:25:19 <Arxor> Im trying to create a html code with haskell and   thehtml << body << p << bold << "Hello, World!"  creates bold text with hello world in it, but how can I for instance add a new paragraph with new text?
08:26:08 <lispy> Arxor: are you using a particular library?
08:26:15 <cnwdup> There was something like +++ to add a new html block without declaring it as child.
08:26:39 <Arxor> yes the library Text.Html
08:26:58 <Arxor> and with +++ I only manage to add it after the </html> tag
08:27:32 <Twey> Arxor: You need to be more careful with your precedence
08:27:46 <cnwdup> thehtml << body << (p << bold << "Hello, World" +++ "Hello") or something should work.
08:28:01 <Twey> thehtml << body << (p << bold << "Hello, World!" +++ p << bold << "Hi!")
08:28:03 <Twey> Yeah
08:28:24 <lispy> :t (<<)
08:28:26 <lambdabot> Not in scope: `<<'
08:28:43 <Twey> (IMO, (<<) should be flip (>>)
08:28:44 <Twey> )
08:28:49 <Arxor> ah it works, thanks a lot guys!
08:28:52 <lispy> Twey: yeah
08:29:21 <lispy> Twey: I was quite confused on that.  I thought, "Oh, they made a monad instance for HTML, clever...but why not use do-notation...)
08:29:26 <Twey> Seems silly that we have a (=<<) but not a (<<)
08:29:31 <Twey> Yeah, heh
08:29:44 <Gracenotes> >>_<<
08:31:15 <Gracenotes> > let (<<) = flip (>>); __ = ":o " in "hi" >>__<< "#haskell"
08:31:16 <lambdabot>   ":o :o :o :o :o :o :o :o :o :o :o :o :o :o :o :o "
08:32:42 <idnar> @hoogle (<<)
08:32:42 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
08:32:42 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
08:32:42 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
08:36:16 <dhaivat> what is haskell mainly used for?
08:36:36 <Phyx-> making ponies
08:36:40 <benmachine> ass-kicking and name-taking
08:36:51 <Jafet> Creative grad students have also found it a great tool for writing theses
08:37:04 <Jafet> Although the new tool of choice seems to be Coq
08:37:06 <fasta> dhaivat, mostly moving bits around in a computer.
08:37:27 <jlouis> Coq is great for writing theses, as is Haskell
08:37:34 <dhaivat> no seriously. Like, what would be a normal use for it? For example, a sane person wouldn't use assembly to write a video edtior
08:37:49 <fasta> dhaivat, in fact assembly is used in those applications.
08:38:06 <Jafet> I wouldn't use a video editor that doesn't use assembly
08:38:19 <benmachine> http://haskell.org/haskellwiki/Haskell_in_industry here are some people who use haskell in industry
08:38:29 <dhaivat> fasta: I meant write the whole thing in assembly
08:38:41 <dhaivat> benmachine: thanks.
08:38:45 <benmachine> http://haskell.org/haskellwiki/Haskell_in_education here are some people who use haskell in education
08:38:47 <jlouis> dhaivat: it is a general purpose language, but it really excels in symbolic manipulation and, lately, concurrency and parallellism
08:39:11 <Jafet> I've never used Haskell for symbolic manipulation, really
08:39:13 <fasta> dhaivat, it is like an efficient version of Python and is used for the same things.
08:39:20 <Gracenotes> it is rather strong when it comes to problem-solving. the more problemy, the better.
08:39:33 <benmachine> my impression is that haskell is good for applications where correctness is important
08:39:35 <Jafet> @remember fasta Haskell is like an efficient version of Python and is used for the same things.
08:39:36 <lambdabot> Nice!
08:39:51 <benmachine> it is not so good for when you need to be able to control memory usage or timing precisely, I think
08:39:53 <fasta> dhaivat, and replacing things for people used to always write in C.
08:40:00 <Gracenotes> in terms of being a version of Python, it's a lot more than efficient...
08:40:10 <benmachine> yes
08:40:23 <fasta> benmachine, atom can do that, but it not really Haskell more at that point.
08:40:47 <benmachine> fasta: I suppose so
08:40:51 <fasta> Universities tell that Haskell is great for writing parsers and compilers.
08:41:07 <benmachine> universities are great at writing parsers and compilers, I think
08:41:18 <fasta> I think it is nice for software development in general ( the language). The tools could just be better.
08:41:18 <dhaivat> fasta: I was going to try that.
08:41:29 <dhaivat> fasta: then I found out about lex and yacc :)
08:41:49 <fasta> dhaivat, lex and yacc are just faster versions of less expressive grammars.
08:42:25 <fasta> dhaivat, often a premature optimization unless you already know the exact grammar and know that you won't change it for a long time.
08:42:43 <fasta> That's really the thing with every restricted language.
08:43:32 <dhaivat> hmm... thanks a lot guys. Maybe I'll start learning Haskell tommorrow...
08:43:34 <fasta> With regular expressions you have the same thing: You have a problem and you solve it with regular expressions. Then 5 months later they ask you "Can you add this or that?". Then you have to rewrite the whole thing often.
08:44:02 <fasta> With for example Parsec you can write a maintainable parser.
08:44:20 <fasta> It is not the fastest thing in the world, but at least you know it is going to work.
08:44:20 <benmachine> parsec is fun
08:44:25 <benmachine> quite fast, too
08:44:34 <benmachine> there are probably faster but it's not bad
08:44:59 <benmachine> but if I was to try to demonstrate to anyone how easy it is to write things in haskell I'd probably consider using parsec to do it
08:45:05 <Phyx-> @package pony
08:45:06 <lambdabot> http://hackage.haskell.org/package/pony
08:45:58 <Gracenotes> expressiveness vs. speed is the most clear conflict when it comes to parsing
08:46:19 <Gracenotes> (of course, the most common conflict is first/follow)
08:47:15 <HaskellLove> Am i safe with these things in haskell without brackets? 4*n^2 - 10*n + 7
08:47:35 <benmachine> depends what you mean by safe
08:47:43 <benmachine> it will probably work how you expect
08:47:49 <benmachine> but you can check the fixities to be sure
08:47:52 <benmachine> use :i in ghci
08:49:20 <lispy> HaskellLove: you'll be type safe assuming there isn't a malicious instance of Num floating around
08:49:37 <HaskellLove> no type safe i meant asociativity safe
08:50:05 <lpsmith> Gracenotes:  expressiveness versus speed is a consequence of choosing to represent strings as linked lists :-)
08:50:32 <lpsmith> Which is a very nice, uniform way of working with strings,  that even generalizes reasonably nicely to unicode.
08:50:44 <whoppix> HaskellLove, should usually work as expected, but when in doubt, give it a try in ghci or so.
08:51:04 <lpsmith> But... it's not a good choice for an application that does heavy-duty string manipulation
08:51:10 <Gracenotes> lpsmith: thinking more along the lines of chomsky hierarchy
08:51:26 <Jafet> Ropes are good. I think Haskell should use that as the default
08:51:31 <lpsmith> Gracenotes:  how so?
08:51:41 <Gracenotes> not specifically von neumann-based data structures
08:52:22 <Jafet> I wouldn't doubt you can do in Haskell what lex and yacc do in C.
08:52:28 <lispy> lpsmith: if you're doing heavy duty string lifting we have libraries such as bytestring
08:52:28 <Gracenotes> smaller subsets of grammars in the hierarchy are easier to deal with
08:53:00 <HaskellLove> what is this error i get: <<loop>> ?
08:53:23 <lispy> HaskellLove: GHC just solved the halting problem
08:53:28 <Jafet> Finally, you're learning Haskell.
08:53:44 <HaskellLove> wow take it slow what is going on :)
08:54:28 <Phyx-> lol
08:54:33 <HaskellLove> from here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15730#a15730
08:54:59 <HaskellLove> euler 28
08:55:01 <Phyx-> lol, seriously, sometimes.. you guys are comedy gold
08:56:38 <Phyx-> HaskellLove: well, you're defining n interms of n itself, so when evaluating n, ghc would need to know the value of n
08:56:42 <Phyx-> see the <<loop>>
08:57:05 <HaskellLove> ouch it should be x yes
08:57:13 <HaskellLove> damn it am i blind already
09:02:17 <dhaivat> lispy: wait, what. Who solved the Halting problem?
09:03:09 <aavogt> ghc does for specific cases
09:03:19 <aavogt> so it isn't really a solution
09:04:10 <fasta> dhaivat, the Halting problem for Turing-machines is only a theoretical problem.
09:04:16 <Gracenotes> Haskell is all about lazily evaluating thunks. So when GHC gets to the point that, in order to evaluate a thunk, you must first evaluate itself, then it gets suspicious
09:04:17 <lispy> dhaivat: GHC can't always solve it correctly (it's undecidable you know) but it can solve it for some specific instances
09:04:39 <Philippa> fasta: insofar as nobody works with actual turing machines, sure
09:05:17 <fasta> Philippa, we only work with a finite tape, that was all I was saying.
09:05:39 <bnijk_> she doesn't listen fasta
09:06:11 <Gracenotes> it's not really solving specific instances... in cases where GHC <<loop>>s, it couldn't do much else
09:06:15 <Philippa> disclosure: I just booted bnijk_ from -blah
09:06:40 <Philippa> fasta: yeah, but people regularly take that further than it deserves - we don't necessarily know at compile time how big the tape at run-time can be
09:06:42 <Gracenotes> (mainly because it blacks out thunks in line to be evaluated to GC reasons...)
09:07:25 <fasta> Philippa, I know at run-time that it won't be larger than the size of my virtual memory. Of course real applications also do I/O so it stops working.
09:07:31 <Philippa> except perhaps with a bound that's too big to usefully exploit at compile-time anyway
09:08:20 <fasta> Philippa, yep, the size is ridiculously large :)
09:08:44 <Philippa> so in practice the analogue of the TM problem is still often the relevant one
09:09:10 <Philippa> (but not so much so if you're coding for 4- or 8-bit microcontrollers)
09:09:25 <fasta> I wonder how much you can prove within a day time.
09:09:43 <HaskellLove> I get 5351362013 for euler 28, anyone has solved it so i see if i am far from result?
09:10:20 <fasta> HaskellLove, the last 8 digits are equal to the final digits of pi, IIRC.
09:10:32 <fasta> Now smile.
09:10:40 <Phyx-> "final digits of pi" ? isn't Pi infinite?
09:10:51 <Gracenotes> the final digits to some unknown precision, I take it
09:11:09 <mux> rather, pi's decimal expansion is infinite - it's an irrational number
09:11:14 <fasta> "Now smile. "?
09:11:20 <Phyx-> rofl
09:12:16 <Gracenotes> pi is not guaranteed to ultimately have an arbitrary digit sequence
09:13:57 <burp> pi is a transcendental number
09:14:28 <mux> which means it's also an irrational number; you don't need to be transcendental to have an infinite decimal expansion
09:15:13 <burp> yes
09:15:29 <Lycurgus> infinite is the wrong word, nonrepeating or the like prolly
09:15:46 <Lycurgus> as far as digit sequences go
09:15:48 <Phyx-> i got a 10 hour flight tomorow, and 3 hours of battery on my lappy. anyone got any suggestion for the other 7 hours?
09:16:01 <Lycurgus> get another battery
09:16:05 <Lycurgus> that's what I do
09:16:11 <Locke1689> hey guys I had a quick question. I'm attempting to use HUnit to write test cases for a simple grammar parser. The problem is that I'm using parsec and the return type for the parse is String -> Either ParseError String. I was trying to use assertEqual to show that my test cases result in the correct answer, but apparently I need to coerce the ParseError so that the TestCase fails. Since I'm still learning Haskell idio
09:16:12 <Locke1689> does anyone have a good suggestion to fix this?
09:16:15 <Gracenotes> funny. almost all numbers are normal, but we don't know any that aren't constructed straight from their digits..
09:16:35 <burp> what do you mean?
09:16:41 <Phyx-> Lycurgus: getting a new lappy soon, so saving up
09:16:56 <HaskellLove> fasta thanks man that sure helped a lot
09:17:17 <Lycurgus> Phyx-, right that's when to do it (get the extra battery).
09:17:52 <patch-tag> is there a way to tell cabal install it can download packages from somewheres other than hackage?
09:18:33 <aavogt> patch-tag: remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
09:18:38 <aavogt> in ~/.cabal/config
09:18:45 <aavogt> looks suspicious
09:19:13 <lispy> Is there a way to ask cabal for the version of a package's dependencies?  So imagine I have QC installed; how do I find out what version of base it was compiled against?
09:19:39 <Phyx-> Lycurgus: i was gonna get a 9 cell, instead of a standard 6 cell :) I'll guess i'll try sleeping. and reading some research papers
09:19:54 <fasta> Phyx-, which OS do you run on your laptop?
09:21:28 <Phyx-> fasta: win7
09:22:23 <lispy> Hello Guest28453
09:22:57 <aavogt> @src <**>
09:22:58 <lambdabot> (<**>) = liftA2 (flip ($))
09:23:17 * hackagebot upload: uhexdump 0.2.3 - hex dumper for UTF-8 text (EricKow)
09:24:20 <HaskellLove> euler 28 http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15731#a15731 i get wrong result why? anyone has the solution number? mine is 5343342001, not correct. I checked the functions are fine, they generate the right sequences, so what else can go wrong
09:25:28 * burp reminds HaskellLove of solutions on haskellwiki
09:25:32 <polux_> hey
09:25:44 <burp> just run these and you get the result
09:25:49 <polux_> is there something similar to make -j n for ghc --make ?
09:25:56 <polux_> (or for cabal build)
09:26:03 <HaskellLove> burp never thought of that thanks
09:26:06 <polux_> i didn't find such an option in the manual
09:27:16 <copumpkin> HaskellLove: off by 2x
09:27:49 <patch-tag> aavogt: thanks, I'll have a look at ~/.cabal/config
09:28:43 <zygoloid> > sum . take 2001 $ scanl (+) 1 ([2,4..] >>= replicate 4)
09:28:44 <lambdabot>   669171001
09:28:48 <zygoloid> HaskellLove: ^^ something liek that i think
09:29:12 <HaskellLove> anyways guys i found this today, solving eulers will be lot easier with this http://www.research.att.com/~njas/sequences/index.html?q=1%2C3%2C13%2C31%2C57%2C91%2C133%2C183&go=Search
09:29:27 <HaskellLove> you just type sequence and it gives you characteristics
09:29:36 <ben0x539> 669171001? I got that but I have no idea what your code is doing, zygoloid :O
09:29:38 <copumpkin> HaskellLove: only if they're in the database
09:29:46 <copumpkin> HaskellLove: anyway, you made a fairly simple mistake
09:30:00 <zygoloid> ben0x539: the scanl is working out the diagonals of the spiral
09:30:08 <zygoloid> > scanl (+) 1 ([2,4..] >>= replicate 4)
09:30:09 <lambdabot>   [1,3,5,7,9,13,17,21,25,31,37,43,49,57,65,73,81,91,101,111,121,133,145,157,1...
09:30:19 <HaskellLove> copumpkin what mistake i tested the formulas
09:30:22 <ben0x539> Craziness
09:30:27 <zygoloid> from 1, you add 2 four times then add 4 four times then add 6 four times then...
09:30:27 <copumpkin> HaskellLove: what does the question ask for
09:30:44 <ben0x539> Yeah... I did the same thing, except more explicitly, ie. lamely.
09:30:50 <ben0x539> @src scanl
09:30:51 <lambdabot> scanl f q ls = q : case ls of
09:30:51 <lambdabot>     []   -> []
09:30:51 <lambdabot>     x:xs -> scanl f (f q x) xs
09:30:51 <HaskellLove> in one diagonale only?
09:30:57 <copumpkin> HaskellLove: no, read the question
09:31:28 <HaskellLove> copumpkin i dont get what you mean, tell me so we are clear
09:31:37 <copumpkin> I want you to think :P
09:31:48 <copumpkin> and am trying to lead you to your problem without just feeding you a chewed-up answer
09:32:01 <Phyx-> copumpkin++
09:32:02 <HaskellLove> anyways you guys can recommend me other "TOOLS" to solve eulers like this one i found, the encyclopedia of integer sequences which is a killer i must say
09:32:10 <copumpkin> HaskellLove: your head
09:32:15 <zygoloid> > let diags = scanl (+) 1 ([2,4..] >>= replicate 4) in map (\n -> sum $ take (4 * n + 1) diags) [0..]
09:32:17 <lambdabot>   [1,25,101,261,537,961,1565,2381,3441,4777,6421,8405,10761,13521,16717,20381...
09:32:17 <ben0x539> Curse your use of the list monad.
09:32:30 <zygoloid> @oeis 1 25 101 261 537 961
09:32:31 <lambdabot>  Sum of all terms on the two principal diagonals of a 2n+1 X 2n+1 ssquare spi...
09:32:32 <lambdabot>  [1,25,101,261,537,961,1565,2381,3441,4777,6421,8405,10761,13521,16717,20381,...
09:32:52 <merehap> HaskellLove: the sloane database is cheating, imho
09:32:55 <burp> no gain at all -.-
09:33:09 <HaskellLove> merehap it is a tool man what cheating?
09:33:12 <ben0x539> zygoloid: why are you taking 2001?
09:33:25 <zygoloid> ben0x539: that's the number of diagonal entries in the 1001x1001 spiral
09:33:36 <ben0x539> Well, yeah. Why? :<
09:33:38 <merehap> just like all the places that list the correct answers are tools, right?
09:33:49 <zygoloid> ben0x539: 'cause that's what the question asked for ;)
09:33:51 <HaskellLove> copumpkin trust me you need more then just a human head
09:34:06 <ben0x539> zygoloid: No, I mean, how do you go from 1001x1001 to 2001?
09:34:12 <ben0x539> I must be missing something simple :v
09:34:30 <zygoloid> ben0x539: 1001 on one diagonal, 1001 on the other, but you count the middle one twice. or, 500 on each arm plus one in the middle
09:34:59 <ben0x539> ... right, thanks
09:35:01 <HaskellLove> merehap you miss the point dude, you read a sequence characteristics what is wrong here? every time you need to do something you would rather spent weeks finding patterns? how stupid is that?
09:35:24 <EvanR-work> ._.
09:35:25 <ben0x539> HaskellLove: The point of Project Euler is making you think. When you find ways to require less thinking, you are missing the point.
09:35:53 <ben0x539> If you find thinking about the problems to be stupid, maybe you should find another use for your time. Passing Project Euler is not a prerequisite for learning haskell.
09:36:04 <HaskellLove> ben0x539 no the point of project euler is not to get maximum hit points with your head in the wall
09:36:17 <copumpkin> HaskellLove: anyway, since you don't seem interested in finding the answer through my attempts to lead you to it, your square is 1001 on each diagonal, or 1001 + 1 + 1001 = 2003 x 2003
09:36:29 <copumpkin> HaskellLove: the question asks for a 1001 x 1001 square
09:36:34 <copumpkin> so each diagonal only needs 500 elements
09:36:45 <copumpkin> of course, if you'd looked carefully you could've easily seen that
09:36:55 <ben0x539> > let spiral n = result 1 2 0 0 where { max = n * n ; result n step count acc | n > max   = acc | count > 3 = result n (step + 2) 0 acc | otherwise = result (n + step) step (count + 1) (acc + n) } in spiral 1001
09:36:56 <lambdabot>   669171001
09:36:58 <HaskellLove> copumpkin i got into the conversation had no time to think what you said but yeah thanks :_)
09:41:34 <merehap> HaskellLove: I've completed 1/3 of the problems, and I haven't touched a math book for 3 years, there are ways to do them
09:42:03 <HaskellLove> merehap yes but you are probably way more experience then me doing first time such problems
09:42:04 <merehap> (without Sloane)
09:42:54 <HaskellLove> merehap any other cool tools you can recommend me? I use Octave for ploting too which is handy
09:43:46 <merehap> I hadn't done any online problems like Euler before Euler, I'm not saying that they aren't hard, but many you can find the answer by just making a few guesses and refining your answer
09:43:57 <ben0x539> HaskellLove: Why are you doing those problems
09:44:03 <merehap> unfortunately I'm not too familiar with tools like Octave
09:44:41 <HaskellLove> ben0x539 so i can climb a mountain one day and roar like a lion "I solved all Eulers"
09:44:58 <copumpkin> you won't get there without revising your thought process a bit
09:45:00 <ben0x539> I suggest you work on the mountain climbing part first
09:45:05 <edwardkmett> HaskellLove: and then the next day you'll get an email announcing that they added a challenge ;)
09:46:03 <HaskellLove> edwardkmett and then i will throw myself down the mountain in despair
09:46:42 <edwardkmett> HaskellLove: they've added problems fairly regularly. consequently you might consider not finishing, as your suicide would be almost assured.
09:46:45 <copumpkin> edwardkmett probably wrote an eulermorphism to solve them all at once, in parallel, with maximal sharing
09:47:17 <dmhouse> Wow, I just had the hardest interview of my life. And it was only the first round, brilliat
09:47:31 <copumpkin> dmhouse: can the company be named?
09:47:51 <Phyx-> anyone here use beamer to show haskell code transformations? i'm wondering how to best to it
09:47:51 <edwardkmett> copumpkin: no need to define a separate eulermorphism, i just used a futumorphism to travel back in time from when i solved them and give myself the answers.
09:47:58 <Phyx-> e.g. a running example of a algorithm
09:48:01 <copumpkin> oh nice
09:48:06 <dmhouse> copumpkin: Jane Street, a smallish algorithmic trading company. (You might have seen their adverts if you use Gmail and read the Haskell mailing list.)
09:48:19 <copumpkin> dmhouse: oh yeah, the ocaml people
09:48:21 <dmhouse> Yeah
09:48:28 <edwardkmett> dmhouse: ah nice.
09:48:34 <copumpkin> sounds like a fun place :)
09:48:45 <edwardkmett> dmhouse: smerdyakov was there for a while
09:49:10 <dmhouse> I flew through the functional stuff (once I remembered that foldl was tail recursive...), but they asked me a bunch of stuff about garbage collection which I really didn't know very much about, and some stuff on fork() where I had to guess a bit
09:49:30 * Phyx- goes to test his library some more before submitting to hackage
09:49:47 <dmhouse> They also asked me about the Fisher-Yates shuffle, which I think I nailed
09:49:55 <dmhouse> So hopefully done enough to make it to the next round
09:50:01 <edwardkmett> dmhouse: a fairly well rounded interview
09:50:34 <dmhouse> There was a tiny bit of maths as well but it was incredibly token. (I toss a coin 3 times. What's the probability of HHT? What about HHT in any order? What about at least one H?)
09:50:41 <copumpkin> dmhouse: did they ask you to estimate the number of hairs on someone's head and stuff like that?
09:50:45 <dmhouse> Considering I'm studying maths not compsci that wasn't fair... :)
09:50:58 <dmhouse> copumpkin: no, it was all compsci stuff. (This was just a first-round phone interview.)
09:51:30 <copumpkin> ah
09:52:04 <copumpkin> I wonder what salaries are like there
09:52:08 <ben0x539> Wow, literally token math.
09:52:19 <edwardkmett> copumpkin: pretty good as i understand it, they are in new york
09:52:23 <dmhouse> To come is, assuming I pass each round, another phone interview, possibly a third, then I'll have to send some code in, an interview down in London, then maybe an interview in New York
09:52:47 <copumpkin> edwardkmett: good for new york or good in general? good in general is only decent in nyc :P
09:52:49 <dmhouse> So it'd better be a fucking good job :)
09:52:51 <copumpkin> from what I hear
09:53:00 <copumpkin> not that I have any "real-world" experience whatsoever
09:53:01 <dmhouse> I've heard the salaries are pretty big
09:53:06 <edwardkmett> copumpkin: good in general. i know some exact figures from former employees
09:53:41 <edwardkmett> copumpkin: its one of the places i've looked at going if i ever leave the defense space
09:53:53 <dmhouse> So, TIL what "mark-and-copy" means :)
09:54:17 * dmhouse was surprised the Dragon book didn't have more to say about GC
09:54:17 <Jonno_FTW> TIL? that's reddit speak
09:54:18 <copumpkin> edwardkmett: aha :) good money + FP does sound too good to be true
09:54:55 <copumpkin> next up, a company that offers half a million a year for theorem proving games
09:54:59 <EvanR-work> we can all strive to use functional programming principles in our everyday work, like webmonkey javascript crap
09:55:18 <osfameron> TIL?
09:55:22 <copumpkin> theorem proving games = treating theorem proving as a game or a puzzle, not proving games to be correct :P
09:55:25 <c_wraith> mark-and-copy sounds like a garbage collector scheme
09:55:26 <dmhouse> osfameron: today I learnt
09:55:41 <osfameron> TIL what TIL means
09:55:41 <dmhouse> c_wraith: yeah, it is. But it's not reference-counting, which is the only one I knew about
09:55:46 <osfameron> I think I'll forget by tomorrow though
09:55:57 <EvanR-work> mark-and-copy sounds superficially like basic 'copy collecting'
09:55:58 <dmhouse> (At least I knew reference counting has problems with cyclical data structures.)
09:56:07 <c_wraith> dmhouse: wow.  reference counting is basically the worst GC scheme, unless latency is your only concern
09:56:13 <dmhouse> c_wraith: yeah, I knew that too
09:56:27 <dmhouse> But it's also pretty simple, and I've never written a compiler (much to my shame)
09:56:48 <copumpkin> edwardkmett: did you see the simplicial database category that sigfpe posted on twitter?
09:57:32 <osfameron> reference counting has a few useful side-effects
09:57:52 <osfameron> like deterministic end-of-scope actions for file-handles
09:58:30 <edwardkmett> no i hadn't
09:58:37 <lispy> osfameron: bracket :)
09:58:39 <dmhouse> He also asked some bullshit questions on the differences between memory allocation profiles of object-orientated languages vs functional languages, and I had no idea what he was getting at
09:58:59 <copumpkin> edwardkmett: http://tinyurl.com/ycgkabw
09:59:16 <copumpkin> dmhouse: maybe the fact that we tend to allocate a lot?
09:59:26 <copumpkin> I dunno :)
10:00:01 <dmhouse> You reckon? More than OO? I'm not sure why that would be true
10:00:38 <EvanR-work> a sane GC will make allocation very cheap
10:00:42 <copumpkin> yeah
10:01:16 <copumpkin> dmhouse: mutation means that they keep old things around and reuse them, we throw them out and wait for the GC to get rid of them, which isn't expensive but maybe that's what he was getting at?
10:01:32 <xerox> those big numbers that show up in profiling all the time
10:01:34 <masxmasx> in a html request, using Network.shed.httpd and Network.URI, i want to find the filename requested, so I use reqURI, but what would I use as the parameters of that?
10:01:51 <copumpkin> :set +s will show you more memory than exists in your computer for even fairly simple functions
10:01:52 <dmhouse> Perhaps, copumpkin.
10:01:57 <dmhouse> Yeah, I've seen that
10:02:12 <osfameron> lispy: bracket?
10:03:21 <benmachine> osfameron: bracket is a good way of getting deterministic end-of-scope actions for file-handles
10:03:24 <benmachine> :t bracket
10:03:25 <lambdabot> Not in scope: `bracket'
10:03:29 <benmachine> hmph
10:03:31 <dmhouse> ?hoogle bracket
10:03:32 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:03:32 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:03:32 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:03:35 <osfameron> ah I see
10:03:45 <Phyx-> masxmasx: a Request object, the type of fileServer is :: Request -> IO Response. which means, you get the request object as a parameter
10:04:08 <benmachine> well, it's possible for the end of the bracket to not be the end of the scope, but if you are sensible about it then it's fine
10:04:33 <Arxor> hey I made a data type    data Inline = Bold String| Italic String   how can I request from an Inline instance what it's type (Bold/Italic) and what the string contains?
10:04:47 <benmachine> Arxor: pattern matching
10:04:50 <copumpkin> Arxor: I'd just use pattern matching
10:05:06 <copumpkin> Arxor: you can write a Bool function to tell you which is which but you'd be reinventing pattern matching
10:05:20 <dmhouse> case foo of Bold str -> {- it's bold, the string is str -}; Italic str -> {- it's italic, the str is str -}
10:05:26 <copumpkin> Arxor: you might also want to factor the Bold and Italic out
10:05:38 <masxmasx> Phyx-: can i talk in private to you? makes it easier to read back
10:05:39 <copumpkin> data Style = Bold | Italic
10:05:47 <copumpkin> data Inline = Inline Style String
10:05:54 <Phyx-> masxmasx: sure
10:06:15 <Gracenotes> (don't forget about <em> and <strong> -.-)
10:06:54 <burp> http://bellard.org/pi/pi2700e9/
10:07:00 <burp> "On December 31st, 2009, about 2700 billion decimal digits of Pi were computed using a single desktop computer. This is presently the World Record for the computation of Pi."
10:08:34 <medfly> o.O
10:09:32 <zygoloid> that's about a terabyte of pi, i think?
10:09:42 <burp> "The base 10 result needs about 1137 GB of storage."
10:10:33 <dmhouse> You can store one digit in 4 bits so you could store that in 2.7e12 / 2 bytes
10:11:16 <lispy> Given the reliability of storage mediums and ram, I wonder what is the likelyhood that at least one digit of that is actually wrong
10:11:21 <dmhouse> > 1.35 * 10^12 / (1024^12)
10:11:22 <lambdabot>   1.0156271191104564e-24
10:11:37 <dmhouse> Oops
10:11:53 <dmhouse> > 1.35 * 10^12 / (1024^4)
10:11:54 <lambdabot>   1.2278178473934531
10:11:59 <burp> lispy: he checked it
10:12:31 <burp> see http://bellard.org/pi/pi2700e9/announce.html or the paper attached
10:12:46 <zygoloid> you can store three digits in 10 bits, so you can store it in 2.7e12 / 3 * 1.25 bytes
10:12:59 <EvanR-work> how do you check that the world record number of digits is correct
10:13:19 <burp> "The binary result was verified with a formula found by the author with the Bailey-Borwein-Plouffe algorithm which directly gives the n'th hexadecimal digits of Pi."
10:13:34 <zygoloid> > 2.7 * 10^12 * 1.25 / 3 / (1024^4)
10:13:36 <lambdabot>   1.0231815394945443
10:13:41 <lispy> burp: hah, cool!
10:14:01 <EvanR-work> burp: whats the credability of this site
10:14:10 <EvanR-work> formula for the hex digits of pi, i mean...
10:14:24 <zygoloid> i would imagine that's 1137 GB not 1137 GiB
10:14:32 <zygoloid> > 2.7 * 10^12 * 1.25 / 3
10:14:33 <lambdabot>   1.125e12
10:15:22 <burp> http://en.wikipedia.org/wiki/BaileyBorweinPlouffe_formula
10:17:14 <Arxor> how do I convert a string into an HTML code, without adding anything to its layout (for instance, bold << txt makes <b> txt </b>, but now without the bold tags)
10:17:22 <Arxor> using the text.html import
10:17:55 <Gracenotes> burp: link turned out odd for me... en dash not encoded UTF-8
10:18:16 <Gracenotes> uri-encoded, I got http://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula
10:18:24 <EvanR-work> is haskell seriously useful for web programming?
10:18:44 <Arxor> probably not, but it's a school assignment
10:18:49 <EvanR-work> in terms of library support, fanboy geek-out factor, etc?
10:19:03 <EvanR-work> things required to make something viable for the web
10:19:21 <burp> Gracenotes: http://goo.gl/1fRC .. but I assume you already found it
10:19:45 <mental> i don't think any websites run on haskell
10:19:58 <Gracenotes> there's probably a redirect with hyphens
10:19:59 <mental> other than hpaste and the happs page maybe
10:20:08 <Veinor> I've found that in imperative programming languages, I tend to give variables and functions very descriptive names.
10:20:14 <EvanR-work> so they dont run on it, could they without much effort?
10:20:20 <Veinor> in haskell, I tend to write doThatThing x y = ...
10:20:33 <mental> Veinor: urdoingitwrong
10:20:41 <Veinor> yeah, I know.
10:20:42 <copumpkin> Veinor: doDatThang
10:20:45 <Gracenotes> Veinor: well, it is the functions that are the important part, not as much the data that happens to be passing through them
10:20:55 <Gracenotes> pointless style is nice like that
10:22:22 * Veinor flicks his eyes at saccade
10:22:30 <benmachine> Veinor: I tend to find that names in haskell are much more short-lived
10:22:50 <benmachine> so it's not as big a deal if they aren't descriptively named because you can see their entire lifespan on the right hand side of the =
10:22:51 <Veinor> indeed
10:23:04 <Veinor> cause of purity and all that.
10:23:41 <Twey> mental: I believe many do
10:23:55 <mental> really, examples?
10:23:59 <Twey> chrisdone was doing some commercial development with happs last I heard
10:24:24 <Twey> And some big site used Haskell behind the scenes, Facebook or YouTube or something
10:24:39 <benmachine> facebook had some element using haskell yeah
10:24:39 <Twey> Oh, plus that 4chan-scraper, though it died
10:24:54 <benmachine> I don't think it *runs on* haskell
10:24:57 <benmachine> but uses it somewhere
10:25:02 <Twey> Aye
10:25:05 <mental> facebook "runs on" PHP
10:25:23 <Veinor> mental: is that the same sense in which twitter "runs on" ruby?
10:25:35 <c_wraith> a lot of twitter is scala, now, actually
10:25:46 <c_wraith> but facebook uses haskell to refactor php code
10:26:14 <benmachine> google just turns up england rugby star james haskell
10:26:21 <benmachine> who was apparently rude on facebook
10:26:31 <Twey> c_wraith: Haha.  Nice.
10:26:33 <Twey> benmachine: Heh
10:26:34 <mental> Veinor: haha, yeah, hence the quotes
10:26:51 <Arxor> how do I convert a string into an HTML code, without adding anything to its layout (for instance, bold << txt makes <b> txt </b>, but now without the bold tags)
10:26:58 <c_wraith> Well, almost all of the Language.PHP modules are contributed by facebook
10:27:08 <Twey> Arxor: You can use strings as-is, I believe
10:27:18 <voker57_> stringToHtml
10:27:27 <Arxor> ah thanks :)
10:27:36 <Twey> Really?  I thought there was an Element instance for String
10:27:38 <Berengal> stringToHtml escapes, I think
10:27:44 <Berengal> primHtml doesn't
10:27:53 <voker57_> there is
10:28:04 <Berengal> Well, assuming the Text.XHtml modules
10:28:19 <Arxor> no, just the Text.html module
10:28:22 <benmachine> http://www.facebook.com/careers/puzzles.php this is sort of interesting except that they're now two major versions behind on GHC
10:28:40 <Berengal> Could still be true...
10:29:21 <c_wraith> Hmm.  Text.Html generates *really* ugly rendered output.
10:29:28 <c_wraith> Text.XHtml is a lot less ugly
10:29:37 <aavogt> @hoogle toHtml
10:29:38 <lambdabot> Text.Html toHtml :: HTML a => a -> Html
10:29:38 <lambdabot> Text.XHtml.Frameset toHtml :: HTML a => a -> Html
10:29:38 <lambdabot> Text.XHtml.Strict toHtml :: HTML a => a -> Html
10:30:23 <Veinor> http://www.facebook.com/careers/puzzles.php?puzzle_id=7
10:30:24 <aavogt> there's an instance HTML for String (which does escaping), if you want to be less explicit
10:30:24 <Berengal> c_wraith: I don't care about the rendering. I make it output everything on one line anyway.
10:30:25 <Veinor> oh hey it's fizzbuzz
10:30:26 <c_wraith> I quit using Text.Html as soon as I saw the output it produced.  >_>
10:31:02 <c_wraith> Berengal: What about the comments it inserts saying how great of a library it is?
10:31:03 <Berengal> What do you need the raw output for anyway?
10:31:09 <Twey> c_wraith: There's a reason for that
10:31:14 <Gracenotes> your criterion for ugly is indentation, or something?
10:31:23 <Twey> You can use the prettyPrint function to format it classically
10:31:39 <Twey> It's not the default because the inserted whitespace won't always be ignored (hence the weird output style)
10:31:41 <c_wraith> Either indent sanely, or don't indent at all.  What it does by default is horrible.  newlines before every >  ?  really?
10:32:07 <Berengal> Again, why do you want the raw output?
10:32:33 <c_wraith> Berengal: I like my generated markup to be readable in case I want to debug it.
10:32:49 <Gracenotes> okay, newlines before every > is fishy
10:32:51 <Twey> No
10:32:58 <Gracenotes> even if it's just to group attributes
10:33:00 <Twey> Please read what I said >.<
10:33:02 <Twey> It's not
10:33:12 <Berengal> c_wraith: I thought so too for a while, but then I realized it's much easier to debug before the output is generated
10:33:21 <Twey> It's a technical limitation, not a stylistic decision
10:33:38 <Twey> Whitespace inside elements is not necessarily ignored
10:33:53 <Gracenotes> in terms of HTML that I'd want to read. Still, I would rather have it all on one line, if I were interesting in preserving whitespace
10:34:00 <Twey> So it puts the > directly before the next opening < to ensure that any extra whitespace appears inside the tag, and is ignored
10:34:25 <Twey> It's the only sane thing to do on arbitrary input
10:34:53 <Berengal> It's not like it's harder to read anyway
10:35:02 <Twey> It takes some getting used to
10:35:38 <Gracenotes> I don't see much harm in doing it for block elements
10:35:52 <Twey> Gracenotes: Except that it then has to know which elements are block and which aren't
10:36:06 <Gracenotes> that is quite true. and people who do HTML by hand do.
10:36:08 <Twey> And with XHTML, there might be arbitrary elements from other namespaces embedded
10:36:27 <Twey> With no way of knowing which is which
10:36:29 <Gracenotes> still, right, automatic generation is limited in that way
10:36:55 <Twey> And what would be the point, anyway?  You'd still have to use the current style for any elements where whitespace is important
10:37:02 <Twey> So it would just be inconsistent
10:37:05 <Arxor> Another question (sorry for being so ignorant) I want to make a hyperlink from the String "home.html" and link << "home.html" gives me a htmlattr(html attribute), how do I make real html code out of that? (importing text.html)
10:37:22 <Gracenotes> Twey: no, I'd put it all on one line
10:38:19 <pelotom> hi all, I'm trying to understand monads and such things
10:38:19 <Twey> Gracenotes: Even if it were huge?
10:38:27 <doserj> Arxor: is this homework? you are the third guy in three days with this question, I think
10:38:27 <pelotom> is there a name for a function that takes a list of functions [a -> m b, b -> m c, ..., y -> m z] where m is a monad, and outputs a function m a -> m z that results from binding them all together?
10:38:30 <voker57_> Arxor: hotlink "http://url" (toHtml "description")
10:38:32 <Gracenotes> and, in the case of (e.g.) form elements, specify whitespace
10:39:13 <voker57_> (link is attribute function, not tag)
10:39:17 <c_wraith> Berengal: It's really the ad for itself that Text.Html produces that made me stop using it.  I'd rather use a library that doesn't advertise itself on every page view.
10:39:17 <Gracenotes> Twey: don't see the harm. there are some things you don't want hierarchical. possibly even line breaks would be nice, on existing whitespace in text
10:39:24 <Arxor> thanks voker :)
10:40:09 <HaskellLove> zip [1..3] [1] this will produce just [(1,1)], so you have to use repeat for the smaller list. Is a function written, maybe some new zip that makes sure when it zips to produce a list with number of elements as the bigger list?
10:40:10 <Twey> Gracenotes: The harm is that it's completely unreadable if you have an arbitrarily large chunk of code stretching across the page
10:40:17 <Twey> That's the point of indenting it in the first place
10:40:21 <Berengal> c_wraith: I never used Text.Html in the first place...
10:40:50 <c_wraith> Berengal: ah.  Take a look at its output sometime.  >_>
10:40:55 <Twey> > zip [1 .. 3] $ repeat 1
10:40:57 <lambdabot>   [(1,1),(2,1),(3,1)]
10:41:10 <Gracenotes> I'm guessing not much less readable than the rendering, if none of them are block elements
10:41:20 <Berengal> HaskellLove: Not ready made as far as I know, but it's pretty easy to write one yourself
10:41:28 <Twey> Gracenotes: Inline elements wrap in the rendering
10:41:39 <Berengal> HaskellLove: You'll have to use Maybe, or monoids to get the "empty" elements though
10:41:49 <Berengal> HaskellLove: Or just cycle
10:42:10 <Twey> > zip [1 .. 5] $ cycle [1, 3]
10:42:11 <Gracenotes> you missed my suggestion about line breaks? :X
10:42:12 <lambdabot>   [(1,1),(2,3),(3,1),(4,3),(5,1)]
10:42:13 <HaskellLove> i will just test who is the smaller list of given lists a and b and repeat it
10:42:32 <Boxo> just cycle both
10:42:42 <Twey> Gracenotes: Ah, very well… but it's still about five times more complicated :þ
10:43:16 <Boxo> > let zup = zip `on` cycle in zup [1..5] [1,3]
10:43:18 <lambdabot>   [(1,1),(2,3),(3,1),(4,3),(5,1),(1,3),(2,1),(3,3),(4,1),(5,3),(1,1),(2,3),(3...
10:43:40 <Berengal> HaskellLove: No, testing the lengths is the wrong way. That would require traversing both lists (and fails in the case of an infinite list)
10:43:43 <Gracenotes> if you have walls of text, like on blogs, where you have long paragraphs interspersed with links, strong tags, and the like, I don't see the strength of hierarchical display
10:44:30 * hackagebot upload: hpage 0.5.3 - A scrapbook for Haskell developers (FernandoBenavides)
10:44:32 * hackagebot upload: GLFW-b 0.0.1 - GLFW bindings (BrianLewis)
10:45:00 <Berengal> HaskellLove: It's better to `(++ repeat Nothing) . map Just' the lists, then zip as long as there's a Just
10:45:12 <Berengal> HaskellLove: But this would give you a list [(Maybe a, Maybe b)]
10:45:30 * hackagebot upload: GLFW-b-demo 0.0.1 - GLFW-b test\/example\/demo (BrianLewis)
10:46:04 <Berengal> HaskellLove: Alternatively, you could cycle mempty and check for that, giving you (Monoid a, Monoid b, Eq a, Eq b) => [(a, b)]
10:47:43 <HaskellLove> i dont know monoid monad stuff so i will just wrap my simple function if not i will just write it for the specific case and apply repeat myself
10:47:56 <lpsmith> pelotom:   you can't write a list like that
10:48:07 <lpsmith> pelotom:   lists have homogeneous types
10:48:17 <pelotom> lpsmith: right, I just realized that :)
10:48:46 <Berengal> HaskellLove: Monoids are simple. They're values that have an "empty" value (and a way of combining them, but that's not important in this case)
10:48:53 <pelotom> lpsmith: so I guess what I'm describing is a "family" of functions that look like: (a -> m b, b -> m c, c -> m d) -> (m a -> m d)
10:49:04 <lpsmith> although,  with a few GHC extensions and some type hackery,  you can do something along those lines
10:49:20 <pelotom> or (a -> m b )->(b -> m c)->(c -> m d)->(m a -> m d)
10:50:11 <lpsmith> :T \ab bc cd ma -> ma >>= ab >>= bc >>= cd
10:50:23 <lpsmith> :t \ab bc cd ma -> ma >>= ab >>= bc >>= cd
10:50:25 <lambdabot> forall (m :: * -> *) a a1 a2 b. (Monad m) => (a -> m a1) -> (a1 -> m a2) -> (a2 -> m b) -> m a -> m b
10:50:26 <pelotom> which I guess do notation is designed to express fairly succinctly
10:50:40 <lpsmith> yeah
10:52:05 <pelotom> what about chaining together an arbitrary list of (a -> m a)'s?
10:52:05 <Berengal> pelotom: In the static case, you can just use <=< to compose monadic functions. In the dynamic case all the actions need to be of the same type anyway, since you can't get typechecking
10:52:44 <Berengal> foldr (<=<) return
10:53:06 <Berengal> Or (>=>) would probably be better in that case...
10:53:25 <Berengal> @type foldr (>=>) return
10:53:26 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
10:54:30 <pelotom> Berengal: ok, thanks
10:55:12 <pelotom> @type (>=>)
10:55:13 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:55:31 <lispy> >=> is very similar to (.)
10:55:35 * hackagebot upload: font-opengl-basic4x6 0.0.1 - Basic4x6 font for OpenGL (BrianLewis)
10:56:07 <pelotom> lispy: yeah, it's like composition of binds, which is what I was trying to get at
10:57:23 <masxmasx> "The equation(s) for `htmlBestand' have one argument, but its type `String' has none" <-- what does this error mean?
10:57:42 <dmhouse> `let' bindings are monomorphic, right?
10:57:59 <Twey> masxmasx: It means that you've defined a function, but given it a non-function type.
10:58:01 <dmhouse> > let x = fromIntegral 4 in (x :: Double, x :: Int)
10:58:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:58:03 <lambdabot>         against inferred type ...
10:58:18 <dmhouse> (And this is a Good Thing.)
10:58:39 <masxmasx> thanks Twey
10:59:19 <Twey> > let f :: String; f x = x ++ "foo" in f "hi"
10:59:20 <lambdabot>   The equation(s) for `f' have one argument,
10:59:20 <lambdabot>  but its type `GHC.Base.String' ...
10:59:35 <Berengal> dmhouse: Only by default
10:59:51 <Berengal> dmhouse: It's caused by the monomorphism restriction, which is a candidate for removal anyway
10:59:57 <dmhouse> Berengal: are you sure?
11:00:01 <doserj> > let f = id in (f 1, f 'a')
11:00:02 <lambdabot>   (1,'a')
11:00:15 <doserj> looks polymorphic to me
11:00:24 <dmhouse> Okay, something is definitely monomorphic and it's not due to MR
11:00:26 <Berengal> dmhouse: Try that in a file with {-# LANGUAGE NoMonomorphismRestriction #-}, or in ghci with :set -XNoMonomorphismRestriction
11:00:35 <doserj> http://www.haskell.org/ghc/docs/latest/html/users_guide/monomorphism.html
11:00:38 <dmhouse> > (\f -> (f 1, f 'a')) id -- lambdas, perhaps
11:00:39 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:00:40 <lambdabot>    arising from the literal `1...
11:00:42 <Berengal> dmhouse: function parameters are monomorphic
11:00:44 <dmhouse> There ew go.
11:01:05 <Berengal> Those require higher-ranked type to make polymorphic
11:01:14 <dmhouse> Yeh, okay.
11:01:14 <Berengal> types*
11:01:21 * dmhouse disables MR and stops worrying
11:01:25 * dmhouse -> noodles
11:01:54 * kmc_ </3 MR
11:02:06 <aavogt> you ever loved it?
11:02:35 * kmc_ \not <3 MR
11:02:44 <Berengal> I think it's mathematically proven that MR >= 3
11:02:57 <MRLove> {-# LANGUAGE YesMonomorphismRestrictionLoveLoveKissKissKiss #-}
11:03:38 <MRLove> Too bad there are still limits on nickname length so I can't really be MonomorphismRestrictionLove.
11:04:03 <burp> phew, good there is nickname length limit
11:09:36 <Yrogirg> I have a problem with ghci in ubuntu 9.10 --- home, delete, end keys don't work. GHC 6.10.4 (from repos), I'm using gnome terminal. Anyway to fix it?
11:11:39 <c_wraith> Yrogirg: I ended up installing from the generic linux binary package because of that bug.  >_>
11:12:06 <c_wraith> Yrogirg: somehow, the ubuntu package messed up haskeline (the input processing library)
11:12:23 <MRLove> And I used the generic linux binary package since day one (I'm on ubuntu too) and never knew of that problem. :)
11:12:46 <lpsmith> pelotom:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15732#a15732
11:12:57 <Veinor> I can't install the generic linux binary package on this machine cause I don't have root :(
11:12:58 <lpsmith> pelotom:  I'm not sure what it's useful for though
11:12:58 <Yrogirg> well, I'll better then search for some ppa's with ghc
11:13:20 <c_wraith> Yrogirg: the generic linux binary package really is painless to install
11:14:27 <Yrogirg> ok, ty
11:14:27 <Veinor> at least cabal and ghc know how to install packages as nonroot :D
11:16:05 <MRLove> Veinor: ./configure --prefix=${HOME}/myghc ; make ; make install
11:16:06 <lpsmith> pelotom:  with the existential type,  there isn't a whole lot you can do with the type of Seq
11:16:21 <Arxor> how do I convert the datatype hotlink to html ( {hotLinkUrl = "home.html", hotLinkContents= home} to <a href="home.html"> home </a>? thanks in advance :)
11:16:29 <MRLove> Does not require root. Add ${HOME}/myghc/bin to your PATH.
11:16:42 * hackagebot upload: random-fu 0.0.3.2 - Random number generation (JamesCook)
11:17:14 <Twey> Arxor: You should read http://hackage.haskell.org/packages/archive/html/1.0.1.2/doc/html/Text-Html.html#t%3AADDATTRS
11:17:20 <Veinor> MRLove: ... :O
11:17:25 <lpsmith> pelotom:  you could concatenate two compatible Seqs,   but you can do that with >=> anyway
11:17:43 <Veinor> would I then have to reconfigure cabal to work with that ghc instead?
11:17:47 <Twey> Er, minus the fragment
11:18:42 <MRLove> Only if you care about the "install-dirs global" section in .cabal/config
11:18:48 <Veinor> which is?
11:19:18 <MRLove> which is the "install-dirs global" section in .cabal/config.
11:19:28 <pelotom> lpsmith: I see
11:19:33 <Veinor> basically right now I just cabal install stuff to wherever cabal installs things when configured for non-roto stuff
11:19:38 <MRLove> Or ${HOME}/.cabal/config if you want me to spell it out.
11:19:43 * hackagebot upload: boomslang 0.0.1 - Boomshine clone (BrianLewis)
11:19:47 <Veinor> if I set up myghc, will it then find those packages and be happy?
11:22:49 <McManiaC>     Warning: A do-notation statement discarded a result of type Char.
11:22:49 <McManiaC>              Suppress this warning by saying "_ <- wsp",
11:23:00 <McManiaC> is this the new wanted style?
11:23:03 <McManiaC> O.o
11:24:00 <theclaw> can somebody tell my why http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15733#a15733 fails?
11:24:09 <Twey> McManiaC: *shudder*
11:24:31 <theclaw> "Could not deduce (Show a) from the context (Show (List a))"
11:24:40 <Twey> If this is the new default, I'm going to be using do-notation a lot less :þ
11:24:40 <theclaw> I'd don't quite understand this error message :/
11:25:38 <McManiaC> theclaw: instance (Show a) => Show (List a) where -- maybe
11:25:44 <Botje> theclaw: you need to tell the compiler that a should also be Showable
11:25:51 <Botje> .. like McManiaC shows :)
11:25:58 <McManiaC> :)
11:26:05 <McManiaC> Twey: me too :O
11:26:34 <theclaw> thanks :)
11:27:18 <McManiaC> Module Prelude is deprecated
11:27:18 <McManiaC> lol
11:27:39 <McManiaC> okay…
11:27:51 <mle> just import everything.
11:27:59 <mle> in pieces.
11:28:45 * hackagebot upload: GLFW-b 0.0.2 - GLFW bindings (BrianLewis)
11:29:08 <kmc_> McManiaC, Twey yes, ghc warns on that now
11:29:25 <kmc_> but not if the value discarded has type ()
11:29:27 <Twey> What's the flag to turn it off?
11:29:34 <kmc_> -fno-warn-whatever
11:29:43 <kmc_> i dunno
11:29:43 <idnar> how often do you execute an action and discard a result that's not ()?
11:29:46 <kmc_> why is this so objectionable?
11:29:58 <idnar> that sounds like either a bug in your code, or in the API you're using
11:30:10 <aavogt> McManiaC: base-3 Prelude is deprecated
11:30:17 <kmc_> it can be convenient to return optionally useful values
11:30:20 <idnar> (with some exceptions, obviously)
11:30:23 <kmc_> but it's not done so much in Haskell, it seems
11:33:47 * hackagebot upload: GLFW-b-demo 0.0.2 - GLFW-b test\/example\/demo (BrianLewis)
11:43:31 <jmillikin> Are there any users of pre-3 base any more?
11:44:34 <McManiaC> http://npaste.de/Bh/ ← any idea what this error is? I already installed hslogger
11:45:07 <EvanR-work> idnar: that would be the case if functions either returned a value or return m () and had a side effect
11:45:14 <EvanR-work> but i bet some do both
11:45:44 <roostaj> @src readFile
11:45:45 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
11:47:29 <idnar> EvanR-work: sure, but I think it's the exception, not the rule
11:47:31 <mtnviewmark> damn you Haskell!  You've made me loathe writing C++ code.....
11:47:35 <McManiaC> Twey:              or by using the flag -fno-warn-unused-do-bind
11:47:35 <idnar> EvanR-work: like non-exhaustive pattern matches
11:48:03 <roostaj> @src writeFile
11:48:04 <lambdabot> writeFile f txt = withFile f WriteMode (\ hdl -> hPutStr hdl txt)
11:48:25 * EvanR-work laughs at mtnviewmark. haha lucky i have to write javascript at work ;)
11:48:32 <Twey> McManiaC: Ah, that's the one.  Phew!
11:48:50 <Twey> EvanR-work: Rather that than C++!
11:49:04 <EvanR-work> yes
11:49:16 <EvanR-work> but which is worse, c++, or php!
11:49:27 <McManiaC> php :D
11:49:33 <Raynes> C++
11:49:40 <EvanR-work> flameon!
11:49:52 <McManiaC> indeed =(
11:49:53 <Raynes> PHP++
11:49:54 <FauxFaux> php++
11:49:57 <FauxFaux> JINX
11:50:04 <Raynes> FauxFaux: :O
11:50:48 <monochrom> No language flame war in #haskell.
11:51:01 <monochrom> LANGUAGE pragma flame war is OK.
11:51:12 <Philonous> That's what #haskell-trolling is for
11:52:12 <bnijk_> php has its uses
11:52:25 <bnijk_> namely, for programming in a team environment, when everybody else only knows php
11:52:43 <Berengal> bnijk_: Sounds like a circular argument to me
11:52:48 <EvanR-work> lowest common denominator feature
11:52:58 --- mode: ChanServ set +o monochrom
11:53:03 <monochrom> Are you done yet?
11:53:08 <bnijk_> Berengal: that is precisely the point
11:53:30 <McManiaC> no guns in #haskell :O
11:53:33 <bnijk_> there is a reason i'm in #haskell, after all
11:54:20 <Berengal> bnijk_: Oh, me, I just like to point the obvious ;)
11:54:58 <McManiaC> can someone tell me why I get "not found" errors for my cabalized packages? :S
11:55:06 <McManiaC> namely hslogger & libmpd…
11:55:18 <bnijk_> McManiaC: typo?
11:55:18 <Berengal> McManiaC: Are they present in ghc-pkg list?
11:55:31 <McManiaC> Berengal: yes they are
11:55:35 --- mode: monochrom set -o monochrom
11:55:50 <bnijk_> you were getting excited weren't you, monochrom ;O
11:56:12 <McManiaC> and no, bnijk_, everything worked before upgrading to ghc 6.12
11:56:19 <bnijk_> ah
11:56:26 * bnijk_ yields the floor
11:56:35 <monochrom> That is none of your business.
11:56:45 <bnijk_> is it not?
11:57:10 <Berengal> McManiaC: Can you provide a more comprehensive error?
11:57:20 <McManiaC> .xmonad/xmonad.hs:141:7: Could not find module `Network.MPD':
11:57:24 <McManiaC> what more do you need? ^^
11:57:38 <bnijk_> in my years of experience of getting banned for stupid reasons, monochrom, somebody giving themselves ops is like a dog climbing up your leg, getting ready to start humping at it
11:57:42 <thaldyron> Does gtk2hs work with ghc-6.12?
11:57:50 <Berengal> thaldyron: No
11:57:52 <bnijk_> that's all i have to say on the subject
11:57:56 * hackagebot upload: empty 1.0 - Class for types with an "empty" value. (JohnMillikin)
11:58:17 <EvanR-work> in my experience you are about to be banned
11:58:36 <bnijk_> EvanR-work: sometimes you have to say what's true, regardless
11:58:37 <monochrom> I'm going to continue this in #haskell-blah
11:58:54 <bnijk_> monochrom: i got banned from their earlier, for asserting a universal standard of human rights
11:59:00 <bnijk_> s/their/there/
11:59:02 <Berengal> McManiaC: Can you load it in ghci?
11:59:09 <McManiaC> Berengal: nope, its not in the list
12:00:34 <Berengal> McManiaC: What isn't in what list?
12:00:43 <McManiaC> :m + Network.<tab>
12:00:51 <McManiaC> doesnt display Network.MPD
12:01:14 <McManiaC> and the only completition to System.L<tab> is System.Locale
12:01:31 <Berengal> McManiaC: Is it perhaps a user install and you're running as a super user somehow?
12:01:40 <Berengal> McManiaC: Works on my box at least, just tested
12:01:55 <McManiaC> nope
12:02:07 <Berengal> Try deleting it and reinstalling
12:02:14 <McManiaC> a friend of mine is missing Network.HTTP*
12:02:21 <McManiaC> how do you delete a package?
12:02:30 <Berengal> Then cast some runes and pray it works...
12:02:36 <McManiaC> hehe
12:02:39 <Berengal> ghc-pkg unregister, then delete from wherever it's install
12:02:40 <Berengal> ed
12:03:33 <Cale> You can skip the second step, but obviously, it will leave bits of garbage on your system. Usually I clean things up in a wholesale fashion when installing a new version of GHC.
12:03:34 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:04:01 <Cale> lambdabot: @join #functionaljava
12:04:06 <Berengal> Ditto
12:05:13 <osfameron> is Berengal spanish for Aubergine?
12:05:28 <osfameron> ah no, that's Berenjena
12:05:47 <ksf> gf is truly a hell of a i18n library
12:05:52 <idnar> what's english for Aubergine?
12:06:08 <Cale> Aubergine or Eggplant
12:06:15 <ksf> if I remember sam&max correctly, aubergine
12:06:27 <McManiaC> Berengal: not there =(
12:06:57 <McManiaC> http://npaste.de/Bi/
12:07:00 <osfameron> Aubergine is English ;-)
12:07:04 <osfameron> (Eggplant is American)
12:07:08 <idnar> oh, right; I think I call that Brinjal
12:07:11 <Berengal> osfameron: It's dutch for bear bile, apparantly, but I didn't know that when I made it up
12:07:11 * bnijk_ jams his hand into ksf's stomach to retrieve McManiaC's packages
12:07:18 <bnijk_> i knew i left that somewhere
12:07:21 <osfameron> Berengal: hehe
12:07:32 <Cale> "The eggplant, aubergine, begun, or brinjal (Solanum melongena), is a plant of the family Solanaceae (also known as the nightshades) and genus Solanum."
12:07:49 * ksf stitches himself up with an applicative functor and glares at bnijk_ 
12:08:10 <jlouis> ksf: try using a zipper next time :)
12:08:24 <idnar> huh, didn't know it was a nightshade
12:09:49 <osfameron> so are potatos and tomatoes iirc
12:10:22 <maltem> potatoes? Those really grow in the shade, yeah ;)
12:10:47 <copumpkin> @hackage empty
12:10:47 <lambdabot> http://hackage.haskell.org/package/empty
12:11:06 <copumpkin> mauke_: that looks like your default package doesn't it?
12:11:13 <osfameron> oh, also tobacco, chili peppers, mandrake, and petunias
12:11:16 <osfameron> useful family
12:11:30 <McManiaC> same with hslogger: http://npaste.de/Bj/
12:11:30 <McManiaC> wtf
12:13:11 <McManiaC> http://npaste.de/Bk/ ← its there…
12:13:11 <McManiaC> =(
12:13:37 <Phyx-> I wonder why i'm so lazy today.. must be something in the air...
12:13:44 <Berengal> McManiaC: What version of base have you set up in your cabal file?
12:14:05 <McManiaC> ehm, how can I check?
12:14:19 <Berengal> ... Open the file and read...
12:14:32 <Berengal> (The cabal file for your project that is)
12:15:06 <McManiaC>         build-depends: base >= 3 && < 4, containers, directory, process,
12:15:17 <copumpkin> Phyx-: maybe you're just lazy
12:15:38 <copumpkin> bnijk_: I imagine you could probably get unbanned now if you tried
12:15:54 <Phyx-> copumpkin: well, I'm supposed to work on a few projects, but the hard parts are over, all that's left is some bug fixes and minor tweaks
12:16:00 <Phyx-> but.... can't be bothered atm
12:16:47 <Phyx-> hmm, i wonder if writing a standalone rts for haskell would be that much wokr
12:16:48 <bnijk_> copumpkin: tried with who
12:17:22 <copumpkin> bnijk_: one of the ops of the channel :) /cs access #haskell-blah list
12:17:36 <bnijk_> ugh
12:17:39 <bnijk_> if you do it for me
12:18:57 <Berengal> McManiaC: I'm sorry, but I'm a bit stuck... Last attempt: Paste your ghc-pkg list, ghc-pkg describe hslogger, and your project cabal file
12:20:07 <McManiaC> http://npaste.de/Bk/ ghc-pkg list
12:20:35 <edwardkmett> preflex: xseen luqui
12:20:36 <preflex>  luqui was last seen on freenode/#haskell 3 days, 7 hours, 34 minutes and 9 seconds ago, saying: well it's not specific, and surely more than just an internal colonel
12:20:41 <McManiaC> http://npaste.de/Bl/ ← describe hslogger
12:20:53 <McManiaC> and well… no project cabal file :)
12:21:25 <McManiaC> just a simple "import System.Log.Logger" / "import Network.MPD"
12:23:43 <Berengal> McManiaC: Try writing a simple cabal file, see if you can use cabal to build it then. If that doesn't work I'm officially out of ideas
12:24:04 <McManiaC> do you mean the cabal files of libmpd/hslogger?
12:24:13 <Berengal> No, for your project
12:24:52 <Berengal> Or, well, a project that simply imports those
12:26:05 <McManiaC> echo "import Network.MPD" > Foo.hs && ghci Foo.hs
12:26:06 <McManiaC> ^^
12:26:10 <McManiaC>     Could not find module `Network.MPD':
12:26:40 <edwardkmett> preflex: xseen conal
12:26:40 <preflex>  conal was last seen on freenode/#haskell 1 day, 3 hours, 21 minutes and 46 seconds ago, saying: sproingie: (\ x y -> (max x y) / (min x y)) = max / min with applicative-numbers
12:27:21 <conal> edwardkmett: hi
12:29:08 <edwardkmett> conal: question, re unamb, would it make sense to just build a partiality monad that can be run for a small number of steps and try to redefine improving values as racing two comparisons in that monad instead of using the heavyweight thread machinery?
12:29:30 <conal> edwardkmett: yes
12:29:35 <edwardkmett> i.e. data Partial a = Total a | Partial (Partial a)
12:29:53 <conal> edwardkmett: i've been playing with that type lately.
12:30:01 <edwardkmett> conal: has that been done in one of the plethora of FRP implementations out there?
12:30:39 <edwardkmett> conal: ah, good, wanted to make sure that it wasn't a terrible idea for some technical reason I hadn't foreseen before I went down that road ;)
12:30:47 <conal> edwardkmett: i don't think so.  hm.  i've written about that type recently.  maybe i have an unfinished blog post on the topic.
12:30:48 <McManiaC> =(
12:30:53 <McManiaC> so my ghc is broken… great
12:30:59 <conal> edwardkmett: there are a couple of reasons i'm not pursuing it.
12:31:18 <edwardkmett> conal: i used it when motivating Iteratees in the last set of slides i put up
12:31:38 <edwardkmett> oh?
12:31:47 <andrewe> McManiacC: what a pity, what broke it?
12:32:23 <conal> edwardkmett: have you seen "Partiality is an Effect"?
12:32:30 <aiko> I Still can't get cabal to install stuff the way Setup.hs wants it. Can anybody help? http://pastebin.ca/1743146
12:32:32 <edwardkmett> conal: yeah
12:32:35 <conal> k
12:33:29 <edwardkmett> conal: dolio encoded that in agda a year or so back as well
12:34:23 <conal> edwardkmett: you using continuous time?
12:34:46 <edwardkmett> all i was looking at was using it for racing the "compareI" calls
12:34:55 <c_wraith> @quote robot monkey
12:34:56 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
12:35:05 <edwardkmett> so the underlying continuity of discreteness of time winds up irrelevant
12:35:05 <c_wraith> @quote robot.monkey
12:35:06 <lambdabot> No quotes match. Take a stress pill and think things over.
12:35:33 <edwardkmett> something like: data Improving a = Imp { exact :: a, compareI :: a -> Partial Ordering }
12:35:49 <edwardkmett> then race the two compareI calls
12:36:01 <edwardkmett> as a first stab anyways
12:36:14 <Saizan> aiko: pass --user to configure
12:36:32 <Saizan> aiko: ./Setup.lhs configure i mean
12:36:41 <conal> edwardkmett: let me know how it goes.  i'm curious to know whether you run into the same problems with this model as i did and how you resolve them.
12:36:46 <Saizan> aiko: or you could use "cabal configure" from the same directory
12:36:51 <dolio> I never finished all the proofs, because some of the later ones got very difficult with Agda's at-the-time issues with coinduction and subject reduction and stuff.
12:37:01 <edwardkmett> k. i'll hack it together real fast
12:37:04 <dolio> And you can't cheat in agda like you can in coq with the rewrite tactic.
12:37:04 <conal> edwardkmett: especially w/ continuous time.
12:37:41 <dolio> Plus, I think I was running out of memory with all the proofs.
12:37:44 <andrewe> How can I find out which version of a package is installed with cabal?
12:37:44 <edwardkmett> conal: i'm curious what issues you ran into. i obviously don't have all of the surrounding machinery of an FRP implementation, just a quick idea about how to encode the problem
12:37:51 <edwardkmett> dolio: not surprised =)
12:38:10 <andrewe> oops, got it
12:38:15 <andrewe> cabal info
12:38:17 <bnijk_> edwardkmett: how to encode the problem is the only part that's FRP ;)
12:38:27 <Saizan> andrewe: or ghc-pkg list $pkgname
12:38:56 <edwardkmett> bnijk_: what i meant was, i don't have all of the compelling use cases for it
12:39:05 <bnijk_> what?
12:39:19 <andrewe> Saizan: thanks, I'm trying to install HOC and it keeps telling me I need parsec version >= 3.0, but I have 3.0.1
12:39:34 <aiko> Saizan: thanks, --user worked
12:39:46 <Saizan> andrewe: how are you installing it?
12:40:00 <conal> edwardkmett: you won't need the implementation machinery.  would you like me to tell you now, or wait until you've played more with the ideas yourself?
12:40:01 <andrewe> Saizan: from source
12:40:16 <Saizan> andrewe: which command?
12:40:16 <edwardkmett> conal: feel free to spoil me =)
12:40:30 <andrewe> Saizan: runhaskell Setup.lhs configure
12:40:32 <edwardkmett> conal: never let it be said i didn't take the easy way out ;)
12:40:45 <Saizan> andrewe: you need to pass --user
12:40:57 <Saizan> andrewe: since cabal-install by default installs packages in the user db
12:41:23 <Saizan> andrewe: OTOH, you can just run "cabal install" from HOC's directory instead of using the Setup script directly
12:41:30 <andrewe> Saizan: great, that works.
12:41:57 <andrewe> Saizan: oh, it doesn't, but let me try "cabal install" first.
12:42:41 <conal> edwardkmett: :).  one is that selective/explicit partiality/progression is like selective/explicit laziness.  laziness & lub are ideas that can apply pervasively.  the other is that i don't know where to get the checkpoints, especially with continuous time.
12:42:45 <jmillikin> copumpkin: it's simular to default, but specifically for "empty" values. eg, it doesn't apply to numbers, monads, or functions.
12:43:17 <copumpkin> jmillikin: empty in what sense? as the unit of some binary operation?
12:43:24 <jmillikin> Well, I suppose it applies to some monads
12:43:28 <edwardkmett> hrmm, I suppose another encoding issue is whether or not I should encode 'exact' and the arg to compareI as Improving values as well: data Improving a = { exact :: Partial a , compareI :: Partial a -> Partial Ordering }
12:43:53 <edwardkmett> all very good concerns
12:44:17 <jmillikin> copumpkin: as in "does not contain a value" -- for example, an empty list or Nothing
12:44:32 <copumpkin> or 15? :)
12:44:34 <andrewe> Saizan: same error with both cabal and runhaskell Setup.lhs, if you want to have a look: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15734#a15734
12:44:37 <jmillikin> Integers, IO, etc always have a value.
12:44:42 <copumpkin> ah
12:45:08 <jmillikin> If somebody figures out how to create an empty integer, that would be a neat trick
12:45:08 <b-rock> Having problems with Statistics package
12:45:11 <b-rock> Prelude Statistics.Distribution.Normal> fromParams 1 1 Loading package syb ... linking ... <interactive>: C:\Program Files\Haskell\er 1.0.0.0\ghc-6.10.4\HSerf-1.0.0.0.o: unknown symbol `_erfc' : unable to load package `syb'
12:45:31 <copumpkin> jmillikin: I was placing too much emphasis on the "contains" part of your definition :)
12:45:37 <jmillikin> Oops, sorry
12:45:45 <copumpkin> but yeah, I think I get it
12:46:22 <b-rock> and
12:46:23 <b-rock> Prelude Statistics.Distribution.Normal> fromParams 1 1 Loading package syb ... linking ... <interactive>: C:\Program Files\Haskell\er 1.0.0.0\ghc-6.10.4\HSerf-1.0.0.0.o: unknown symbol `_erfc' : unable to load package `syb'
12:46:42 <jmillikin> The main purpose is for implementing <http://hackage.haskell.org/package/capped-list> -- without Empty, I couldn't define "return".
12:47:10 <jmillikin> and it seemed like a general enough concept that others might be interested
12:47:16 <Saizan> andrewe: well, that's a problem with HOC's sources in particular, i don't know what could be causing it
12:47:26 <copumpkin> cool :)
12:47:44 <andrewe> Saizan: are you using HOC yourself?
12:49:03 <Saizan> andrewe: no
12:49:27 <andrewe> Saizan: damn ;-)
12:49:52 <SamB_XP_> Saizan: how is that not a problem with syb?
12:51:41 <edwardkmett> conal: starting to see it, by just trying to define Ord, and EQ, etc. you'd ideally be able to lift those to compare' :: a -> a -> Partial Ordering, etc.
12:52:02 <edwardkmett> conal: you wind up transforming the entire runtime system to accomodate this artificial notion of racing
12:52:57 <conal> edwardkmett: i guess so.  or continually crafting ad hoc opportunities for cooperative multi-tasking.
12:53:34 <edwardkmett> conal: ok, i'm won back over to the threaded implementation, if only because the alternative is so horrid ;)
12:53:58 <Phyx-> LOL, ghc just paniced because it couldn't find a module
12:54:03 <Phyx-> how melodrametic
12:54:05 <conal> edwardkmett: don't rush to "the".  there may be less horrid alternatives.
12:54:10 <Veinor> I... I'm going crazy!
12:54:36 <edwardkmett> conal: well, in kata i can expose some of the speculation machinery to make unamb less expensive in the common case.
12:54:52 <conal> edwardkmett: what common case?
12:55:19 * hackagebot upload: capped-list 1.0 - A list-like type for lazy sequences, with a user-defined termination value. (JohnMillikin)
12:56:46 <edwardkmett> conal: allow let speculation on the first branch and if it finishes before speculation gives up, you have your answer, otherwise the speculation engine will capture the current delimited continuation for everything that it was too eager for, as you unwind past the unamb frame you stop and try to speculate the other side, if both took too long then the result is a lazy value that should try to race the two continuations furth
12:58:20 <edwardkmett> all of that relies on the machinery i'm using for speculative evaluation, but should allow for speculation over unamb, and an ad hoc bit of machinery for keeping one processor evaluating both alternatives in parallel
12:59:26 <edwardkmett> conal: i realize thats more operational than you care to be ;)
13:00:32 <conal> edwardkmett: yep.  and it doesn't addresses my two concerns.  and i'd hope concurrency support in the RTS would handle interleaving for me, and do so efficiently.
13:00:37 <edwardkmett> conal: the gamble is that the common case is that one branch of the unamb will finish within the speculation threshold of maybe a dozen small allocations
13:00:59 <edwardkmett> conal: in which case, there is no overhead at all
13:01:16 <edwardkmett> conal: since it never actually leaves the stack
13:03:44 <edwardkmett> conal: i guess thats where i'm more pessimistic. projects like cilk can do a better job of allowing this sort of very cheap fork/join parallelism than the machinery provided by our RTS. cilk threads cost a few instructions and kata fork/join tasks are effectively free, except when speculation ends or they are forced to the heap. unamb has to at least allocate a stack, etc. within the current capability
13:05:50 <conal> edwardkmett: do you suppose your operational ideas could apply to implementing unamb (or amb) as a primitive in the ghc rts, while keeping the types simple/general (not Partial)?
13:06:55 <edwardkmett> conal: well, it probably wouldn't work to get it into ghc as they rely on a bunch of stuff that was originally written for ghc, but never integrated. (rob ennals' dissertation on speculative evaluation)
13:07:33 <conal> edwardkmett: k
13:07:53 <b-rock> I'm having issues with packages, can someone take a look at a ghci error?
13:08:30 <monochrom> Yes.
13:08:43 <edwardkmett> conal: http://berkeley.intel-research.net/rennals/rennals/pubs/thesis.pdf is the dissertation, which describes the changes to ghc necessary to add let speculation, which at the time netted a pretty respectable ~20% performance increase and a considerably better increase for 'naive code'
13:09:04 <edwardkmett> conal: but it seems the changes were probably considered too invasive
13:09:12 <conal> oh well
13:09:36 <edwardkmett> conal: however, as i'm starting from scratch, i don't have such constraints ;)
13:09:44 <b-rock> monochrom: it's at hpaste.org
13:10:00 <edwardkmett> conal: except insofar as i'd like to ship something eventually ;)
13:12:23 * Baughn wonders if there are any knights of lambda in here. conal?
13:12:34 <copumpkin> lol
13:12:35 * bnijk_ is a knight of lc
13:12:48 <bnijk_> want to see my decorative pin?
13:13:02 <Baughn> I've got one of those too. :
13:13:03 <Baughn> :P
13:13:10 <bnijk_> bullshit
13:13:13 <bnijk_> i'd know about you by now
13:13:17 <Baughn> Mass-produced.
13:13:23 <bnijk_> psh, yeah
13:13:24 <bnijk_> the fake ones
13:13:51 <Baughn> Makes it a bit hard to tell, though
13:13:57 * p_l wanted to join but 6.001 died too early
13:14:08 * Baughn is too european to join
13:14:23 <Baughn> (And too.. uninterested in lambda calculus)
13:14:46 <bnijk_> yours get scratched when you press them against a hard surface
13:15:20 <Drunkenmonkey> stop with this gay shit
13:15:26 <EvanR-work> are theres knights of ski calculus
13:15:26 <kmc_> @ops
13:15:26 <lambdabot> Maybe you meant: docs oeis pl
13:15:30 <copumpkin> @where ops
13:15:30 <kmc_> @where ops
13:15:30 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
13:15:30 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
13:15:39 <kmc_> Drunkenmonkey, we won't have sex with you, quit begging for it
13:15:44 <Drunkenmonkey> lol
13:15:56 <Phyx-> wtf
13:16:01 <Drunkenmonkey> only if you can make a useful program
13:16:05 <damd> kmc_: cock blocker
13:16:06 <Drunkenmonkey> that's the rules
13:16:06 * Phyx- checks the channel name
13:16:09 <Veinor> p_l: self-declare yourself as one :O
13:16:10 <kmc_> coq blocker
13:16:15 <kmc_> Drunkenmonkey, lolololol
13:16:20 <copumpkin> agda blocker
13:16:22 <kmc_> "haskell is useless", never heard that before
13:16:24 <Baughn> bnijk_: Are you telling me that yours is made using raw spatial geometry, and immune to mere physical forces? o_O
13:16:26 <kmc_> i will compose a scathing reply on reddit
13:16:29 <Veinor> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
13:16:30 <Veinor> tada~
13:16:36 <kmc_> seriously,
13:16:37 <kmc_> @where ops
13:16:37 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
13:16:40 <p_l> Veinor: self declaration would be like blowing hot air... not interested ;-)
13:16:45 <xerox> kmc_ yes?
13:16:56 <monochrom> Seriously, why do you feed the troll and call up the ops.
13:17:02 <Veinor> Seriously seriously.
13:17:03 <kmc_> because a ban is in order
13:17:17 <Gracenotes> @vixen is a ban in order?
13:17:17 <bnijk_> there's no such thing as "trolls"
13:17:18 <lambdabot> who's to say?
13:17:19 <Baughn> Feeding the troll is a bannable offense?
13:17:21 <bnijk_> there are only human beings
13:17:28 <EvanR-work> > repeat 'seriously '
13:17:29 <lambdabot>   <no location info>:
13:17:29 <lambdabot>      lexical error in string/character literal at chara...
13:17:35 <Drunkenmonkey> I have an alibi
13:17:38 <EvanR-work> doh
13:17:39 <Drunkenmonkey> I am drunken
13:17:43 <kmc_> Drunkenmonkey, sucking dicks behind a dumpster?
13:17:53 --- mode: ChanServ set +o Igloo
13:17:54 <Veinor> > fix ("seriously " ++)
13:17:55 <lambdabot>   "seriously seriously seriously seriously seriously seriously seriously seri...
13:17:58 <xerox> The signal/noise ratio has dropped. Maybe +m for a while?
13:18:00 <Baughn> ..seriously, kmc_, stop that.
13:18:03 <kmc_> okay, fine
13:18:06 * kmc_ shuts up
13:18:11 <Drunkenmonkey> hey I would not hide it
13:18:20 <Gracenotes> why not +m
13:18:27 * p_l is just passing by while dealing with windows used through CLI... should have sent that job to a troll ;-)
13:18:43 <mle> +m isn't viable as no one is voiced.
13:18:57 <sproingie> it'd sure help the S/N ratio
13:18:58 <Veinor> p_l: why would you inflict that on yourself? :(
13:19:03 <bnijk_> there is no noise in here
13:19:08 <bnijk_> you people are nuts
13:19:12 <monochrom> b-rock: Which version are you using? I just "cabal install statistic" at version 0.4.1 and it works fine.
13:19:14 <Drunkenmonkey> so why aren't the ops banning left and right here now
13:19:17 <Gracenotes> pot, kettle.
13:19:21 <Drunkenmonkey> an outrage
13:19:27 --- mode: ChanServ set +o monochrom
13:19:31 --- mode: monochrom set +m
13:19:36 --- mode: monochrom set +v b-rock
13:19:45 <b-rock> monochrom: i found this http://hackage.haskell.org/trac/ghc/ticket/3536
13:20:01 --- mode: Igloo set -m
13:20:07 <monochrom> Oh Windows. Oops sorry I only tried on Linux.
13:20:09 <copumpkin> aw
13:20:19 <copumpkin> sad troll is sad
13:20:33 <b-rock> monochrom: but I don't know how to get the fix... 6.12 will fix it?
13:20:44 <monochrom> I don't know.
13:20:59 <b-rock> monochrom: i compiled it and it works fine,, it's just ghci
13:25:06 --- mode: monochrom set -o monochrom
13:25:23 <bnijk_> -m--
13:25:38 <elly> I... see...
13:26:08 * Phyx- shakes head
13:27:01 <EvanR-work> bnijk_: i would like to buy a vowel
13:27:10 --- mode: ChanServ set +o monochrom
13:28:08 <bnijk_> EvanR-work: http://omploader.org/vMm5pag
13:28:20 <ksf> cale?
13:28:25 <Cale> yes?
13:28:32 <ksf> we sooooo have to get a gf framework for lambdabot.
13:28:36 <Cale> gf?
13:28:48 <ksf> It can spit out wisdom like "otherwise less heavily than nothing , my ninety thousand right brothers of everything from there switched on"
13:28:53 <ksf> grammaticalframework.org
13:29:06 <monochrom> grammatical framework framework
13:29:08 <bnijk_> are you making fun of my book ksf
13:29:46 <bnijk_> what just happened
13:29:53 <monochrom> Your book is off-topic.
13:29:54 <ksf> gf says: then let's always sell to ourselves everybody
13:30:01 <bnijk_> it's really not monochrom
13:30:07 <bnijk_> if you read it you would know that
13:30:17 --- mode: monochrom set +b *!n=ush@*
13:30:54 <ksf> mhhh.
13:31:26 <ksf> I'd have to continue reading that to decide whether it's a james joyce clone or a darn good markoff.
13:31:33 <Veinor> what
13:31:38 <Veinor> I literally have no clue what just happened
13:31:47 <ksf> http://omploader.org/vMm5pag
13:32:06 <ksf> which seems to be bnijk_'s opus.
13:32:35 <luite> is there some way to filter invalid utf8 characters out of a String?
13:33:00 <Baughn> luite: System.IO offers several ways to deal with invalid encodings
13:33:08 <ksf> there's no invalid "utf8 characters" in a string.
13:33:17 <ksf> those things are composed out of codepoints
13:33:28 <luite> Baughn: which are only available on systems with iconv (i.e. not on windows)
13:33:46 <ksf> there's icu
13:33:52 <sproingie> there are invalid codepoints, and there are invalid incodings
13:34:04 <sproingie> encodings
13:35:07 <luite> I'm not sure what exactly it is, but I read the characters from an utf-8 encoded xml file. when I putStrLn the string with utf-8 encoding, the program quits with an invalid argument error
13:35:33 <luite> utf-16 works fine
13:35:42 * ksf files bnjk under "obsessive-compulsive pinealist"
13:37:11 <luite> and I presume that UTF-8//IGNORE would also work, with a few missing characters
13:37:26 <gwern> does anyone know who has commit access to base?
13:37:42 <gwern> I'm trying to figure out who I need to pressure :)
13:37:45 <Baughn> luite: Decoding errors should produce a specific exception, not something generic like that
13:38:15 <luite> Baughn: oh it is more specific than that, let me run the program again if you want the full error message
13:39:06 <sproingie> gwern: sounds like a job for a trac ticket
13:39:15 <gwern> sproingie: oh, there's already one...
13:39:29 <dolio> gwern: Good to hear about sort, by the way.
13:39:31 <gwern> and a libraries@ thread that's been running for over a year
13:39:45 <gwern> dolio: yeah, that ate up a good day or so. criterion is hard to use
13:40:19 <luite> Baughn: pdfinfo.exe: <stdout>: commitAndReleaseBuffer: invalid argument (character is not in the code page)
13:40:22 --- mode: monochrom set -o monochrom
13:40:47 <gwern> dolio: now if I could only get Control.Monad.ignore in!
13:40:56 <gwern> or void as I'm going to have to call it
13:41:11 <dolio> Can't say I really care about that one. :)
13:41:28 <Rotaerk> hmm... that book of bnijk's ...
13:41:48 <gwern> the mad arab prophet bnijk?
13:42:30 <Rotaerk> yea, he needs to learn english grammar >_>
13:42:40 <Rotaerk> vocabulary alone doesn't cut it
13:42:48 <monochrom> Why is /join #haskell-blah so hard?
13:43:03 <Rotaerk> not everyone knows about it I guess
13:43:07 <Rotaerk> did you suggest that to him?
13:43:26 <monochrom> I am suggesting it to you, Rotaerk, and you, gwern.
13:43:53 <Rotaerk> oh, I was talking about it in here, because he was in here, not #haskell-blah
13:43:58 <Rotaerk> but I'm done...
13:44:11 <gwern> monochrom: Data.List.sort and Control.Monad.void aren't -blah topics
13:44:13 <kmc_> @bot
13:44:13 <lambdabot> :)
13:44:13 <lunabot>  :o
13:44:48 <sshc> how do I convert an Int64 to a Word32?
13:44:56 <kmc_> :t fromIntegral
13:44:56 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:45:00 <kmc_> :t fromIntegral :: Int64 -> Word32
13:45:01 <lambdabot> Int64 -> Word32
13:45:44 <kmc_> > fromIntegral ((2^63) :: Int64) :: Word32
13:45:45 <lambdabot>   0
13:45:48 <kmc_> > fromIntegral ((2^20) :: Int64) :: Word32
13:45:48 <leimy> which word32 do you get? :-)
13:45:49 <lambdabot>   1048576
13:46:02 <kmc_> don't ask me, ask instance Num Word32
13:46:56 <leimy> how do you get the "other" Word32 from Int64? :-)
13:47:12 <dolio> Right shift 32 bits.
13:47:22 <leimy> That's what I'd expect too ;-)
13:47:28 <leimy> I'm sure it works.
13:49:43 --- mode: ChanServ set +o Cale
13:49:56 --- mode: Cale set -v b-rock
13:49:58 --- mode: Cale set -o Igloo
13:50:00 --- mode: Cale set -o Cale
13:50:31 <kmc_> > fromIntegral (((2^63) `shiftR` 32) :: Int64) :: Word32
13:50:32 <lambdabot>   2147483648
13:50:35 <kmc_> not so pretty
13:50:54 <Cale> er, does lunabot really need +v? Since when do we use +v?
13:51:02 --- mode: ChanServ set +o Cale
13:51:05 --- mode: Cale set -v lunabot
13:51:08 --- mode: Cale set -o Cale
13:51:16 <Cale> there we go :)
13:51:17 <Baughn> > fromIntegral (-14 :: Int32) :: Word32
13:51:18 <lambdabot>   4294967282
13:51:57 <FunctorSalad> hmm am I doing it wrong or does gtk2hs darcs head still not work with 6.12.1?
13:51:59 <copumpkin> Cale: why not?
13:52:13 <copumpkin> Cale: it lets people know what is a bot and what isn't, if nothing else
13:52:32 <copumpkin> preflex and lambdabot had +v for a while too
13:52:36 <Cale> I suppose we could give +v to all the bots.
13:52:50 <Baughn> Then we can program the bots not to respond to anyone with +v
13:52:52 <mental> I for one welcome our new bot overlords.
13:52:56 <Cale> Seems a little odd to me, since the channel is never moderated anyway
13:53:20 -Baughn(n=svein@40.39.202.84.customer.cdi.no)- But really, they should just reply this way.
13:53:23 * EvanR-work changes nick to anna to get a +v
13:53:26 <Cale> I agree.
13:54:01 -Baughn(n=svein@40.39.202.84.customer.cdi.no)- > Testing, testing
13:54:21 <FunctorSalad> for easier ignoring?
13:54:34 <Cale> Though many IRC clients mishandle notices.
13:54:37 <Baughn> FunctorSalad: Because the IRC spec (or.. something) says bots should not respond to notices
13:55:01 <Baughn> Bot loops are ugly. That prevents them entirely.
13:55:03 <Cale> There's even an IRC client which handles channel notices with popup windows.
13:55:13 <Cale> Which is obviously completely broken
13:55:19 <elly> wtf hax.
13:55:21 <Baughn> That's even more reason to use notices, then
13:55:35 <Cale> heh, yeah, get people to switch to something saner.
13:55:46 <copumpkin> roconnor: your fewdigits represents reals as Rational -> Rational, right?
13:55:48 <b-rock> what is the binding to compile and/or run in Yi?
13:56:45 * hackagebot upload: capped-list 1.1 - A list-like type for lazy sequences, with a user-defined termination value. (JohnMillikin)
13:58:59 * Cale wonders why bnijk_ seems to think asking to be unbanned by someone who isn't even in the channel he was banned from is productive.
14:00:47 <gwern> b-rock: what?
14:00:52 <HaskellLove> Wroking on euler 31 gets me into lot of mess. I end up having lists of lists and i use zip and soon you have a list of tuples of lists of lists of tuples of god knows what. Is this the time to use ADTs?
14:01:17 * gwern submits http://hackage.haskell.org/trac/ghc/ticket/3292#comment:5 . If after all this nothing happens, then a plague on everyone's houses!
14:01:18 <mental> No, the time to use ADT was way before that.
14:01:22 <Baughn> HaskellLove: It's ALWAYS time for ADTs
14:01:30 <monochrom> hehehe mental
14:01:53 <lpsmith> HaskellLove:  just use recursion
14:01:58 <Baughn> HaskellLove: If it helps, I've seen much worse. Pretty sure I've got a three-line type here somewhere.
14:02:11 <b-rock> gwern: i'm trying to use Yi and start writing/learning... is there a way to simply compile and run... or maybe a better way to ask, how do you have your development environment set up
14:02:15 <lpsmith> You don't need lists of lists or anything
14:02:17 <c_wraith> hmm.  the Maybe monad isn't really lazy.
14:02:20 <monochrom> In an imperative language I once used pointer to pointer to pointer to double. It's nothing.
14:02:23 <gwern> b-rock: well, you should have the source handy
14:02:28 <gwern> b-rock: you can see my config in it
14:02:33 <Gracenotes> gwern: what now about void = return ()? :/
14:02:35 <Baughn> c_wraith: Well.. it can't be, can it?
14:02:57 <gwern> Gracenotes: you dropped the most important part!
14:03:04 <b-rock> gwern: yeah, i was looking as you replied
14:03:07 <Gracenotes> nay, I think void to be a nicely return ()
14:03:11 <Baughn> Gracenotes: void = return undefined
14:03:21 <gwern> Gracenotes: and the >> ?
14:03:28 <Gracenotes> that would be 'ignore'
14:03:29 <c_wraith> > let x = do { a <- Just 5 ; b <- undefined ; c <- Just 6 ; return (a + c) } in x
14:03:30 <lambdabot>   * Exception: Prelude.undefined
14:03:32 <FunctorSalad> c_wraith: incidentally I think lazier erroring is the purpose of the package hackagebot just mentioned :)
14:03:34 <gwern> -_-
14:03:46 <Baughn> Or better yet, class Void where void :: a; void = undefined; instance Void () where void = ()
14:03:54 <gwern> auughhh
14:03:57 <Gracenotes> don't make your chibi face with me now
14:04:00 <Baughn> c_wraith: Nonono, /return/ undefined
14:04:01 <gwern> STAY AWAY FROM MY BIKESHED YOUR PERVERTS
14:04:06 <FunctorSalad> (at least if it's the one belonging to the -cafe thread I was thinking of)
14:04:22 <c_wraith> I just think there's nothing wrong with that example resulting in Just 11
14:04:26 <Gracenotes> anyway, void being a "do nothing" sort of thing
14:04:38 <Gracenotes> very useful in monadic ifs and the like
14:04:49 <Gracenotes> er. wait, no, not monadic ifs, we have when and unless for that
14:05:06 <gwern> Gracenotes: this is for forkIO and stuff
14:05:27 <lpsmith> HaskellLove:  recursion makes a lot of previously difficult problems easy,  once you get the hang of it
14:05:33 <c_wraith> Having seen just how lazy State.Lazy is, I figure it should be possible to write >>= for Maybe in a similar manner.
14:05:36 <gwern> 'forkIO(forkIO(foo >> return()) >> stuff >> return ()) etc
14:05:42 <Gracenotes> gwern: well, I like void = return () particularly for case statements and the like
14:06:01 <HaskellLove> lpsmith i cant do it with recursion my data structures become a mess even in the first cases like 5 for example
14:06:28 <lpsmith> HaskellLove:  You don't need a datastructure,  and what that means is that you aren't doing the recursion right
14:06:35 <FunctorSalad> c_wraith: what would you expect in the snipped you pasted? it has to evaluate b
14:06:49 <FunctorSalad> iff b = Nothing, the result will be Nothing
14:06:59 <Gracenotes> gwern: I have a few dozen instances of return () in my code
14:07:00 <copumpkin> @query lambdabot
14:07:00 <lambdabot> Unknown command, try @list
14:07:05 <c_wraith> FunctorSalad: the lazy dream is that it won't look at the undefined at all, since b is never requested.
14:07:12 <gwern> Gracenotes: everyone does
14:07:14 <Gracenotes> and some of them are >> return (), yes
14:07:28 <FunctorSalad> c_wraith: it is
14:07:29 <HaskellLove> lpsmith look at my mess at start: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15737#a15737
14:07:30 <Gracenotes> so add both. keep the masses happeh
14:07:36 <copumpkin> > ways [100,50,20,10,5,2,1] !! 100
14:07:37 <lambdabot>   4563
14:07:39 <c_wraith> FunctorSalad: look at the first example here:  http://blog.melding-monads.com/2009/12/30/fun-with-the-lazy-state-monad/
14:08:30 <c_wraith> FunctorSalad: I figure if the state monad can be written in a way that defers evaluation to that degree, it might be interesting to see what can be done with Maybe
14:08:48 <FunctorSalad> > let x = do { a <- Just 5 ; b <- Nothing ; c <- Just 6 ; return (a + c) } in x
14:08:49 <lambdabot>   Nothing
14:08:56 <copumpkin> Maybe doesn't really offer you any latitude with the monad definition does it?
14:08:57 <FunctorSalad> @c_wraith
14:08:58 <lambdabot> Unknown command, try @list
14:09:08 <c_wraith> FunctorSalad: sure, but that's a strict definition.
14:09:40 <Gracenotes> if you get Nothing, the binding function simply isn't called
14:09:42 <c_wraith> It might be the case that there is no lazy implementation possible.
14:09:43 <monochrom> You can't use Maybe for this. You can define another data structure doing a similar job as Maybe but lazier.
14:09:43 <FunctorSalad> c_wraith: ok so you want an altogether different monad, not just Maybe with lazier evaluation
14:09:59 <copumpkin> > Nothing >>= undefined
14:10:00 <lambdabot>   Nothing
14:10:10 <b-rock> gwern: all i can find is crtl-x e : evalRegionE
14:10:28 <gwern> b-rock: what are you trying to evaluate?
14:10:32 <monochrom> Maybe even s/define/design/
14:10:42 <FunctorSalad> ("not compareable in information ordering" is what I mean with "altogether different", I guess o_O)
14:10:42 <copumpkin> > ways [200,100,50,20,10,5,2,1] !! 100
14:10:43 <lambdabot>   4563
14:10:48 <c_wraith> monochrom: would be be flat-out impossible to use the same data structure?
14:10:50 <copumpkin> > ways [200,100,50,20,10,5,2,1] !! 400
14:10:51 <lambdabot>   1960497
14:11:03 <copumpkin> > ways [200,100,50,20,10,5,2,1]
14:11:04 <lambdabot>   [1,1,2,2,3,4,5,6,7,8,11,12,15,16,19,22,25,28,31,34,41,44,51,54,61,68,75,82,...
14:11:07 <monochrom> Yes.
14:11:15 <copumpkin> @oeis [1,1,2,2,3,4,5,6,7,8,11,12,15,16,19,22,25,28]
14:11:15 <lambdabot>  Sequence not found.
14:11:21 <copumpkin> @oeis 1,1,2,2,3,4,5,6,7,8,11,12,15,16,19,22,25,28
14:11:24 <b-rock> gwern: right now I'm just learning, I want to be able to quickly run the compiler (typecheck) or even run
14:11:31 <monochrom> > (undefined >>= return True) :: Maybe Bool
14:11:32 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Bool.Bool'
14:11:33 <lambdabot>         again...
14:11:36 <lambdabot> Plugin `oeis' failed with: thread killed
14:11:40 <gwern> b-rock: so you mean laod a file into ghci perhaps?
14:11:46 <monochrom> > (undefined >> return True) :: Maybe Bool
14:11:47 <gwern> my config has an example of that
14:11:47 <lambdabot>   * Exception: Prelude.undefined
14:11:57 <HaskellLove> copumpkin what is that function you wrote it? it is here in lambdabot?
14:12:01 <monochrom> That is the problem. That stops you from "pro = do pro; ..."
14:12:07 <b-rock> gwern: then perhaps I don't have your config
14:12:11 <copumpkin> HaskellLove: I put it into lambdabot but I didn't write it
14:12:15 <copumpkin> why?
14:12:16 <HaskellLove> > ways [1,2,5,10,20,50]
14:12:17 <lambdabot>   [1,1,2,2,3,4,5,6,7,8,11,12,15,16,19,22,25,28,31,34,41,44,51,54,61,68,75,82,...
14:12:22 <gwern> b-rock: should be in src/Yi/Users/Gwern.hs or whatever
14:12:39 <HaskellLove> copumpkin i might need it for euler 31 haha
14:12:57 <c_wraith> monochrom: that's an implementation detail of (>>=), not a feature of the data structure.  I'm asking if it's impossible to change the implementation of >>= without changing the data structure.  (it might be, but you're not answering that question)
14:12:57 <copumpkin> HaskellLove: well, you might indeed as it will give you the answer to euler 31, but I'm not giving it to you
14:13:15 <mental> :t ways
14:13:16 <lambdabot> forall a. (Num a) => [Int] -> [a]
14:13:24 <monochrom> I think it is impossible to change the implementation of >>= without changing the data structure.
14:13:26 <HaskellLove> nah i am kidin i will do my own... after a week i guess, i want to think about it , really a cool problem lot to learn from it
14:13:32 <copumpkin> :)
14:14:00 <Gracenotes> what data structure is the argument motivator here?
14:14:19 <Phyx-> can i just say.. I wish you could hide instances in Haskell
14:14:40 <c_wraith> It probably would take something closer to State...  the underlying data structure should be a function, in order to reach that degree of laziness, I suppose.
14:14:54 <Gracenotes> Phyx-: or, rather, selecting instances
14:15:03 <Gracenotes> we do have newtypes anyway
14:16:24 <Phyx-> Gracenotes: yeah, but that's more work then just being able to like you said select instances
14:17:09 <c_wraith> Phyx-: only slightly, give the GeneralizedNewtypeDeriving extension
14:17:18 <c_wraith> *given
14:17:49 <Phyx-> oooh, didn't know about that one
14:17:55 <c_wraith> learning about that extension made me *much* happier with newtypes
14:18:14 <Phyx-> hehehe
14:18:27 <Phyx-> yes, I think you might have made me very happy too
14:20:54 <lpsmith> HaskellLove:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15737#a15738
14:21:05 <lpsmith> Hope that helps,  I need to leave for a while
14:21:08 <copumpkin> he's gone
14:21:34 <copumpkin> @tell HaskellLove lpsmith left you this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15737#a15738
14:21:34 <lambdabot> Consider it noted.
14:27:24 <lpsmith> thanks copumpkin
14:27:24 <luite> has anyone here made freetype 2 bindings perchance (and forgot to upload them to hackage) ? :)
14:27:48 <lpsmith> Admittedly that's not the simplest of recursions
14:27:53 <shapr> http://www.n-heptane.com/nhlab/repos/haskell-freetype/ ?
14:27:53 <lpsmith> but I gotta go :)
14:28:30 <shapr> luite: Have you already seen that binding?
14:28:57 <monochrom> Haha, some ghc tickets have "milestone" set to _|_
14:29:02 <copumpkin> yeah :)
14:29:03 <shapr> haha
14:29:04 <copumpkin> quite a few actually
14:29:09 <copumpkin> like the hs-boot ticket
14:29:44 <Phyx-> monochrom: that kinda looks like the tivket is giving you the finger :P
14:30:06 <luite> shapr: hmm, no, thanks for the link
14:30:15 <McManiaC> sooo
14:31:28 <Phyx-> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html <-- what's the correct url for that? these broken links are starting to get annoying
14:33:10 <Phyx-> It's such a kill joy when your program segfaults...
14:33:16 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html
14:33:44 <c_wraith> > unsafeCoerce () ()
14:33:45 <lambdabot>   Not in scope: `unsafeCoerce'
14:33:58 <c_wraith> Good \bot.  Way to not segfault! :)
14:34:04 <McManiaC> few new people here… did anyone have any issues with cabal not registering new packages correctly after an upgrade to 6.12?
14:34:35 <monochrom> And also type-class-extensions.html and type-families.html and other-type-extensions.html
14:34:46 <Phyx-> monochrom: ah, thanks
14:34:47 <McManiaC> or ghc just not showing / loading those modules
14:34:53 <Veinor> c_wraith: ha. why does that segfault?
14:35:02 <Veinor> oh.
14:35:06 <luite> shapr: looks incomplete though, I mainly need it for font metrics
14:35:37 <tener> are there any plans to remove hs-boot files entirely? Or perhaps this isn't possible?
14:35:50 <copumpkin> tener: it is definitely possible, but not a priority at all
14:36:17 <c_wraith> Veinor: it tries to make () into a function.  Which essentially results in a jump to memory address 0, in GHC
14:36:27 <Veinor> so null pointer derefernce, basically?
14:36:34 <c_wraith> yep
14:36:46 <Veinor> awesome.
14:36:49 <koeien37> you're lucky
14:36:56 <c_wraith> there's a reason the name has "unsafe" in it. :)
14:37:11 <koeien37> that is crashes
14:37:20 <kmc_> what's more, you're not guaranteed something nice like a segfault
14:37:26 <kmc_> it might silently corrupt data and continue to run
14:37:32 * monochrom is reminded of the traditional computability course, which says "run () with () as input, does it halt?"
14:37:34 <c_wraith> true.  it could actually do *anything*.  it's nice that it segfaults in ghc.  (usually)
14:37:57 <kmc_> c_wraith, i've actually found it pretty difficult to make unsafeCoerce cause a segfault
14:38:05 <kmc_> a cast between two algebraic types will sometimes map the ctors in order
14:38:34 <kmc_> anyway, i think little is promised about the semantics.  the only safe cases i know of are: a newtype to its wrapped type, and any type to Any and back to the same type
14:38:42 <copumpkin> listToMaybe = unsafeCoerce
14:38:46 <kmc_> haha
14:38:51 <Gracenotes> monochrom: *hands you busy beaver function*
14:39:05 <c_wraith> the sad thing is, copumpkin's definition would basically work. :)
14:39:20 <kmc_> wow, it does work
14:39:24 <kmc_> in simple cases at least
14:39:24 <c_wraith> (in ghc.  probably.  nothing's guaranteed)
14:40:06 <kmc_> now, the question is, if you write the "correct" listToMaybe, is GHC smart enough to see that it's a no-op?
14:40:07 <tener> runtime system guru, also known as evil sorceror
14:40:10 <kmc_> (it's probably not, either)
14:41:06 <kmc_> Prelude Unsafe.Coerce> unsafeCoerce (Just ()) :: [()]
14:41:08 <kmc_> [(),(),()Segmentation fault
14:41:13 <kmc_> now that's a little strange
14:41:21 <copumpkin> why?
14:41:29 <copumpkin> makes sense to me
14:41:29 <kmc_> so it reads beyond the end of the closure
14:41:32 <kmc_> for the cdr cell
14:41:39 <kmc_> i guess it sees another () by coincidence
14:41:47 <copumpkin> well everything is ()
14:41:55 <copumpkin> in the () type
14:41:57 <kmc_> yeah, it's quite non-deterministic how many () you get
14:41:58 <kmc_> oh right
14:41:59 * hackagebot upload: GPX 0.4.5 - Parse GPX files (TonyMorris)
14:42:06 <Gracenotes> also, it's pretty sane to use coerce between numeric types
14:42:09 <idnar> it's the (:) constructors that you trip on
14:42:19 <copumpkin> kmc: eventually it stepped into memory it didn't have access to and died
14:42:22 <Gracenotes> certain numeric types
14:42:27 <gwern> that GPX package annoys me
14:42:27 <kmc_> Gracenotes, boxed or unboxed?
14:42:28 <Veinor> I ran unsafeCoerce (Just ()) :: [()] a bunch of times
14:42:30 <idnar> > unsafeCoerce (46 :: Integer) :: ()
14:42:31 <lambdabot>   Not in scope: `unsafeCoerce'
14:42:35 <gwern> since I have a GP2X and I keep getting confused
14:42:37 <idnar> oh, of course I can't do that
14:42:38 <Veinor> I got 2, then 1, then 1, then 1 followed by segfault
14:42:47 <Gracenotes> kmc_: boxed, given word constructor
14:43:17 <kmc_> not all boxed numeric types have the same closure layout, do they?
14:43:22 <kmc_> because not all the unboxed types have the same size
14:43:39 <c_wraith> well, small Integer and Int are the same thing
14:43:42 <Veinor> @src (&&)
14:43:42 <c_wraith> @src Integer
14:43:43 <lambdabot> True  && x = x
14:43:43 <lambdabot> False && _ = False
14:43:43 <lambdabot> data Integer = S# Int#
14:43:43 <lambdabot>              | J# Int# ByteArray#
14:43:46 <c_wraith> @src Int
14:43:47 <lambdabot> data Int = I# Int#
14:43:58 <kmc_> littleEndian = unsafeCoerce (1 :: Word32) == (1 :: Word8)
14:44:04 <c_wraith> So you can use it to convert between the small cases of Integer and Int.
14:44:40 <kmc_> then when you get to J# ctor it is not even deterministic :)
14:45:03 <c_wraith> Yeah, but no one uses J#.  >_>
14:45:13 <copumpkin> why not?
14:45:22 <c_wraith> it was a bad joke at microsoft's expense
14:45:22 * copumpkin has used J#
14:45:26 <copumpkin> oh
14:45:44 <Phyx-> what's a J#?
14:45:51 <kmc_> boo hiss
14:45:58 <copumpkin> a massive integer
14:46:01 <Phyx-> or rather, why does it have a ByteArray# field?
14:46:01 <copumpkin> like, THIS big
14:46:13 <copumpkin> Phyx-: that's where GMP's integer lives
14:46:16 <kmc_> unsafeCoerce :: Int -> Integer should be totally safe in GHC, right?
14:46:23 <idnar> Phyx-: J# is just a constructor name
14:46:37 <pikhq> kmc_: Probably.
14:46:40 <copumpkin> kmc: not sure what it would do
14:46:41 <Phyx-> copumpkin: GMP?
14:46:46 <Gracenotes> kmc_: even so, there's no integer representation that will fall apart
14:46:46 <Phyx-> idnar: yes, i get that part
14:46:48 <copumpkin> Phyx-: big integers!
14:46:51 <Phyx-> oh
14:46:59 <Phyx-> well, why didn't you just say so!
14:47:05 <Phyx-> using fancy words :P
14:47:10 <idnar> haha
14:47:11 <pikhq> copumpkin: I'm pretty sure it would do the obvious Int->Integer function.
14:47:12 <copumpkin> :)
14:47:17 <copumpkin> pikhq: why would it?
14:47:19 <kmc_> i can't use unsafeCoerce on prim values :/
14:47:20 <kmc_> kind error
14:47:25 <Gracenotes> kmc_: all ranges of bit are good, since every number needs representation. except, of course, in the case the integer has too large a byte array length and runs off into segfault territory
14:47:30 <copumpkin> unsafeCoerce#
14:47:31 <Gracenotes> darned polymorphism
14:47:52 <pikhq> copumpkin: Because an Int is an I# Int#, and an Integer *can be* an S# Int#.
14:48:00 <kmc_> copumpkin, same type, same error
14:48:13 <kmc_> and I# and S# are the 0th ctors of their respective types
14:48:15 <copumpkin> pikhq: yeah, but it can also be a J# .... How do you know which constructor it will use?
14:48:44 <benmachine> by experimentation
14:48:47 <pikhq> copumpkin: That's a very good point, and hell if I know.
14:48:53 <Gracenotes> hum.
14:48:54 <pikhq> It's almost certainly undefined behavior.
14:48:58 <copumpkin> :)
14:49:02 <benmachine> if it doesn't go horribly awry, it used the right constructor
14:49:07 <Gracenotes> we shall define it then!
14:49:10 <pikhq> As is most of what else unsafeCoerce can do.
14:49:21 <benmachine> unsafeCoerce is an undefined function, isn't it? :P
14:49:31 <benmachine> (as in, it's not in any standard, I'd have thought)
14:49:52 <pikhq> benmachine: Its behavior is specified. In source code. :P
14:50:17 <koeien37> it's unspecified
14:50:19 <koeien37> not undefined
14:50:33 <benmachine> pikhq: the question is what would you accept as a sensible unsafeCoerce
14:50:50 <koeien37> id if a = b, const undefined otherwise
14:51:02 <koeien37> anything more is a plus
14:51:10 <benmachine> mm
14:51:19 <pikhq> benmachine: Coerce "Foo Int" to "Bar Int" is probably not going to break.
14:51:20 <pao> hi all :-)
14:51:22 <c_wraith> I think it actually is specified in the case involving All, as mentioned about
14:51:31 <Gracenotes> a sensible unsafeCoerce would involve bit patterns in constructors
14:51:35 <copumpkin> :t fix ($) -- yay, unsafeCoerce
14:51:36 <lambdabot> forall a b. a -> b
14:51:36 <benmachine> pikhq: but if it did, you wouldn't submit a bug report to GHC
14:51:45 <pikhq> Though why you're not just doing "let (Foo x) = foo;bar = Bar x" is beyond me.
14:52:01 <Gracenotes> very internal represetationy
14:52:12 <doogie> guys... what does this mean? non-exhaustive patterns in function...
14:52:13 <pao> I need to cabalize a project with multiple executables... is it still better to have un package per executable?
14:52:19 <pikhq> benmachine: I consider unsafeCoerce "magic". I wouldn't submit a bug report if it launched the missiles.
14:52:45 <c_wraith> doogie: it means you're pattern-matching in a function, and you missed at least one case.
14:53:04 <benmachine> doogie: like if you wrote a function from Maybe a -> a that didn't handle Nothing
14:53:21 <pikhq> > fix ($) (1 :: Int) :: Integer -- And watch as it doesn't terminate!
14:53:27 <lambdabot>   mueval: ExitFailure 1
14:53:34 <c_wraith> doogie: or a function from [a] -> a that doesn't handle []
14:55:17 <kmc_> doogie, are you compiling with GHC?
14:55:19 <kmc_> did you turn on -Wall ?
14:55:33 <doogie> yeah... i'm looking at http://git.mercenariesguild.net/?p=rivertam.git;a=blob;f=src/Main.hs;h=8aff75dc28b4ecb470f849bf2301d1fa73733319;hb=HEAD
14:56:08 <kmc_> where says it this
14:56:15 <doogie> line 116, runtime error
14:56:37 <benmachine> woo mercenariesguild
14:56:50 <kmc_> where is the datatype External defined?
14:57:02 <c_wraith> doogie: it means there are more constructors for External than that function is handling
14:57:08 <benmachine> this is why people should import explicitly
14:57:15 <koeien37> benmachine: yes
14:57:23 <koeien37> and import should import qualified by default
14:57:42 <benmachine> that's just messy
14:57:53 <kmc_> it's the standard in python
14:58:03 <benmachine> in python I from-import everything
14:58:09 <benmachine> unless the list of things is really really long
14:58:13 <koeien37> never from .. import * , right
14:58:21 <benmachine> or if the naming scheme is silly
14:58:28 <koeien37> datetime.datetime()
14:58:59 <kmc_> from os import path
14:59:29 <benmachine> like the regex library, where the compile function doesn't really make sense unless it has re. on the beginning
14:59:31 <kmc_> from datetime import datetime
14:59:38 <benmachine> anyway
14:59:44 <kmc_> that's not silly, it's good design
14:59:52 <kmc_> use simple short names and let qualification do the work
15:00:00 <benmachine> doogie: what function had non-exhaustive patterns?
15:00:10 <kmc_> instead of having every function start with a prefix myRegexLibrary that can't be stripped
15:00:23 <kmc_> that pattern is a large part of why C code looks ugly, visually
15:00:31 <benmachine> kmc_: I suppose that makes sense in some cases
15:00:38 <benmachine> but I don't like qualified names in haskell
15:00:50 <c_wraith> Yes, but the other extreme is Henning code
15:00:52 <kmc_> in Haskell, at least there is sane treatment of conflicts
15:00:52 <koeien37> I do
15:01:01 <kmc_> in Python your second from foo import * will just clobber the first
15:01:44 <c_wraith> I have a data type.  let's call it T.
15:02:07 <kmc_> hi, T
15:02:16 <idnar> kmc_: that's just one of the reasons why "import *" is a bad idea
15:02:54 <koeien37> T, welcome! String and Integer are here. IO () is over there, sitting silently in a corner
15:03:35 <monochrom> We love newbie types.
15:05:17 <Veinor> koeien37++
15:05:27 <Phyx->  monochrom lies
15:05:38 <Veinor> sometimes IO () will just shout something out at random. we don't know why. :/
15:05:46 <koeien37> he is shunned by the others
15:06:00 <idnar> IO () is really angry
15:06:16 <monochrom> Not as angry as IO (IO ())
15:06:22 <Phyx-> IO () can easily be silenced though
15:06:23 <koeien37> but they can join
15:06:58 <Veinor> monochrom: Mu IO
15:11:42 * pikhq winces at Mu IO
15:11:51 <kmc_> eek
15:11:56 <kmc_> :t fix join
15:11:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
15:11:57 <lambdabot>       Expected type: m (m a)
15:11:57 <lambdabot>       Inferred type: m a
15:12:18 <Veinor> god, I love google chrome
15:12:19 <pikhq> :t join fix
15:12:20 <lambdabot>     Occurs check: cannot construct the infinite type:
15:12:20 <lambdabot>       m = (->) (m a -> m a)
15:12:20 <lambdabot>     Probable cause: `fix' is applied to too few arguments
15:15:01 <mreh> is explicit parameter passing preferred over State monad when you know you're working with recursive data structures that are only dependent on their parents?
15:15:14 <kmc_> :t fix (join . fmap out)
15:15:15 <lambdabot> forall (m :: * -> *). (Monad m, Functor m) => m (Mu m)
15:15:22 <mreh> would anyone consider State monad in those conditions?
15:15:28 <kmc_> :D
15:15:46 <kmc_> > fix (join . fmap out) :: [Mu ([])]
15:15:47 <lambdabot>   No instance for (GHC.Show.Show (L.Mu []))
15:15:48 <lambdabot>    arising from a use of `M377485...
15:15:54 <mreh> like because functions can't pass extra arguments back up the stack to the function that called it, too easily
15:16:09 <kmc_> > length (fix (join . fmap out) :: [Mu ([])])
15:16:12 <lambdabot>   mueval-core: Time limit exceeded
15:16:24 <kmc_> > length (fix (join . fmap out) :: Maybe (Mu Maybe))
15:16:25 <lambdabot>   Couldn't match expected type `[a]'
15:16:25 <lambdabot>         against inferred type `Data.Mayb...
15:17:01 <kmc_> > maybe 'n' (const 'j') (fix (join . fmap out) :: Maybe (Mu Maybe))
15:17:05 <lambdabot>   mueval-core: Time limit exceeded
15:17:13 <mreh> what the hell is going on?
15:19:32 <gwern> mreh: the High Mages of the lost continent of Mu disapprove
15:20:01 <benmachine> :t fmap out
15:20:03 <lambdabot> forall (f :: * -> *) (f1 :: * -> *). (Functor f1) => f1 (Mu f) -> f1 (f (Mu f))
15:20:07 <Saizan> mreh: it seems like Reader would be more adequate
15:20:38 <Saizan> mreh: with local the caller can alter the environment the callee sees
15:20:49 <kmc_> two functors at the same time
15:22:13 <mreh> bum
15:23:13 <mreh> Reader looks good to me
15:23:20 <mreh> thanks Saizan!
15:24:03 <kmc_> :t mfix out
15:24:04 <lambdabot> forall (m :: * -> *). (MonadFix m) => m (Mu m)
15:24:15 <kmc_> > length (mfix out :: [Mu ([])])
15:24:19 <lambdabot>   mueval-core: Time limit exceeded
15:28:06 <mreh> does Reader e a, define a class of monads over e?
15:28:31 <Saizan> there's the MonadReader class
15:28:52 <mreh> I didn't mean class in that sense
15:29:54 <Saizan> ah, yeah, for each choice of e you've a different monad
15:30:14 <copumpkin> omg a kroo
15:30:19 <Saizan> btw Reader e a ~ e -> a
15:30:24 <mreh> it's a whole new monad, I can't combine Reader e with Reader e1, simple a
15:30:51 <mreh> what notation is that?
15:31:00 <EvanR-work> monad transformers!
15:31:09 <copumpkin> ~ is from TypeFamilies
15:31:13 <Saizan> just vague notation for "is isomorphic to"
15:31:16 <copumpkin> is type equality, but he's just using it for isomorphic
15:31:16 <Saizan> in this case
15:31:26 <mreh> monads in disguise?
15:31:35 <Saizan> i.e. newtype Reader e a = Reader (e -> a)
15:32:03 <mreh> yeah, I understand
15:32:19 <FunctorSalad> ≅
15:32:23 <Saizan> mreh: you could use Reader (e,e1) or ReaderT e (Reader e1), though maybe it's getting clumsy :)
15:32:50 <mreh> that looks a bit exciting
15:33:40 <kmc_> > let mk 0 = In Nothing; mk n = In . Just . mk $ (n-1); In Nothing +++ n = n; In (Just m) +++ n = In . Just $ (m +++ n); unMk (In Nothing) = 0; unMk (In (Just n)) = succ (unMk n) in unMk (mk 2 +++ mk 3)
15:33:41 <lambdabot>   5
15:34:10 <kmc_> > let mk 0 = In Nothing; mk n = In . Just . mk $ (n-1); In Nothing +++ n = n; In (Just m) +++ n = In . Just $ (m +++ n); unMk (In Nothing) = 0; unMk (In (Just n)) = succ (unMk n) in unMk (mk 127 +++ mk 128)
15:34:11 <Gracenotes> @hoogle In
15:34:11 <lambdabot>   255
15:34:12 <lambdabot> Network.Socket iN6ADDR_ANY :: HostAddress6
15:34:12 <lambdabot> Network.Socket iNADDR_ANY :: HostAddress
15:34:12 <lambdabot> Text.Parsec incSourceColumn :: SourcePos -> Column -> SourcePos
15:34:13 <FunctorSalad> hmm I once used Reader e, where e was built with HList, but I don't quite remember what the point of that was
15:34:15 <FunctorSalad> :)
15:34:19 <kmc_> @src In
15:34:19 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
15:34:20 <Gracenotes> :| big bunch of help
15:34:39 <kmc_> (Mu f) is the least fixed point of the functor f
15:34:50 <kmc_> the least fixed point of Maybe is isomorphic to the natural numbers
15:35:00 <kmc_> data Maybe a = Nothing | Just a
15:35:05 <kmc_> data Nat a = Zero | Succ (Nat a)
15:35:19 <kmc_> Mu is like 'fix' at type level
15:35:36 <Gracenotes> oh, it's one of dem special L.hs types
15:35:40 <Saizan> FunctorSalad: i was trying to make first class modules out of that
15:35:41 <ezyang> Submitted app for the NIA/Galois thing. Fingers crossed.
15:35:50 * copumpkin crosses them
15:36:05 <shambler> NIA?
15:36:11 <Saizan> what's the NIA/Galois thing?
15:36:20 <ezyang> National Instute of Aerospace
15:36:25 <ezyang> lemm find the mail that was sent to haskell-cafe
15:36:35 <mreh> they host hackage
15:36:38 <FunctorSalad> Saizan: did it work out? sounds like it could
15:36:44 <ezyang> http://www.haskell.org/pipermail/haskell-cafe/2009-December/070558.html
15:36:54 <FunctorSalad> (first glance)
15:36:57 <damd> ok
15:38:06 <shambler> wow, that is awesome stuff
15:38:20 <jaredj> help i don't understand parsing :(
15:38:25 <Saizan> FunctorSalad: it's problematic if your modules have a type parameter that doesn't get instantiated to a concrete type by the action
15:38:30 <ezyang> jaredj: Ask your question ;-)
15:40:19 <jaredj> :) i can make a simple :: GenParser Tag () (String, String) and a compound :: GenParser Tag () TheRecordType, and compound can call simple no problem
15:40:41 <jaredj> but how do i say compound <|> simple and still end up with something typeable?
15:41:10 <ezyang> you need a wrapper datatype
15:41:32 <Saizan> FunctorSalad: i.e. if you end up with (HasModule (Foo a) l, HasModule (Bar b) l) => Reader l c, you can't satisfy those constraints, unless your "module" implementation is polymorphic on those parameters
15:41:45 <jaredj> i need a lot of wrapper datatypes then :(
15:42:00 <Saizan> (or maybe neither then? it's been a while)
15:42:08 <kmc_> jaredj, specifically you need a function String -> TheRecordType
15:42:23 <kmc_> which expresses how a "simple" item is itself a (presumably simple) record
15:42:30 <FunctorSalad> hmm
15:42:31 <jaredj> kmc_: but it isn't
15:42:44 <kmc_> oh, then you want to parse into an Either type or such
15:43:09 <kmc_> (Left <$> simple) <|> (Right <$> compound) :: GenParser Tag () (Either (String, String) TheRecordType)
15:43:11 <monochrom> liftM Left simple <|> liftM Right compound :: GenParser Tag () (Either (String,String) TheRecordType) ?
15:43:14 <jaredj> e.g. data StatusRec = { code :: Int, severity :: String }
15:43:33 <kmc_> jaredj, but this is usually a sign that you should extend your record type to cover the simple cases too
15:43:34 <jaredj> comes from <STATUS><CODE>0<SEVERITY>INFO</STATUS
15:43:37 <kmc_> or embed them both in a variant
15:43:40 <monochrom> Or you should just redefine and unify some of your data structures.
15:44:02 <vovik> anyone know why ghc won't compile anything on snow leopard? i always get an error about 'cannot do signed 4 byte relocation' or '32-bit absolute addressing is not supported for x86-64'
15:44:23 <jaredj> monochrom: i'm open to that, but so far they're just mirroring the structure of the file
15:44:25 <vovik> :t liftM
15:44:27 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:44:45 <monochrom> liftM and <$> do the same thing.
15:44:58 <kmc_> except <$> works on more things
15:45:03 <monochrom> liftM is an older name.
15:45:17 <kmc_> monochrom, that's misleading, they don't have the same type
15:45:27 <monochrom> Yes I'm lying in a tutorial.
15:45:37 <ezyang> "oh man"
15:45:43 <jaredj> isn't there a pair of facebook groups for this or something
15:45:47 <monochrom> The same approved lie as (+)::Int->Int->Int
15:46:08 <sproingie> except Monad isn't strictly a subclass of Functor
15:46:11 <kmc_> jaredj, basically, tuples and Either are some algebraic types provided for you.  usually if you define your own algebraic types, it will be a better fit for your problem
15:46:16 <sproingie> it just happens that most good monads are made that way
15:46:25 <kmc_> monochrom, but that's a valid annotation on (+).
15:46:29 <kmc_> it's a specialization of the type
15:46:36 <copumpkin> vovik: is it 6.12?
15:46:44 <mreh> :t runReader
15:46:46 <lambdabot> forall r a. Reader r a -> r -> a
15:48:10 <jaredj> kmc_: so simpleOrCompound = (simple >>= (return . Left)) <|> (compound >>= (return . Right)) or so
15:48:21 <kmc_> if you wish
15:48:37 <sproingie> :t (<|>)
15:48:38 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
15:48:40 <koeien37> Left <$> simple
15:49:53 <jaredj> the thing is there's a syntactical distinction of whether this tag contains others or not, and a quite different semantical idea of what tags it should contain. the simplest code captures the syntax, but i want the semantics reflected in my types
15:50:54 <jaredj> anybody could get a tree of strings out of this file, but i want more significant output
15:51:18 <ray> :t )Left .)
15:51:19 <lambdabot> parse error on input `)'
15:51:21 <ray> :t (Left .)
15:51:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (Either a b)
15:51:27 <ray> caleskell strikes!
15:51:46 <vovik> copumpkin: 6.10.4
15:51:56 <copumpkin> vovik: there's a known bug, just upgrade to 6.12
15:52:03 <kmc_> jaredj, so create an algebraic type
15:52:13 <kmc_> data Tag = Simple stuff | Complex stuff
15:52:21 <jaredj> done
15:52:28 <jaredj> i have a tree of strings
15:52:28 <kmc_> cool
15:52:32 <jaredj> now i need to parse it (!)
15:52:39 <pikhq> :t fmap.fmap
15:52:40 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:52:45 <kmc_> well, do you not also want this distinction at the parsed level
15:52:45 <vovik> copumpkin: thanks, i'll try that
15:52:47 <pikhq> Yay.
15:52:57 <mreh> :t local
15:52:58 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
15:53:03 <jaredj> kmc_: yes, but also more.
15:53:38 <jaredj> kmc_: e.g. a <ST
15:53:43 <jaredj> dangit i can't type a capital m!!
15:54:06 <koeien37> M <-- copy/paste these ;)
15:54:12 <kmc_> mm anyway got to go
15:54:24 <jaredj> thanks lol
15:54:28 <jaredj> er
15:54:34 <tener> i have couple of monad stacked on each other
15:55:00 <tener> what is the best way to get value several levels lower from state monad? (using get)
15:55:13 <tener> *and* keep that readable
15:55:28 <tener> s/monad/monads/
15:55:50 <Saizan> so you're using transformers, right?
15:55:53 <tener> yes
15:55:54 <monochrom> jaredj: I am convinced you are supposed to unify (String,String) and TheRecordType and whatnot under one single type.
15:56:38 <Saizan> tener: well, if they have a MonadState instance it should just work, otherwise you've to use lift, maybe nested
15:56:46 <monochrom> It's the same problem and same solution as how to store an abstract syntax tree.
15:56:47 <mreh> > let folder (x:xs) = local (+x) (folder xs); folder [] = ask in folder [1..5]
15:56:48 <lambdabot>   No instance for (GHC.Show.Show (m t))
15:56:48 <lambdabot>    arising from a use of `M6990348388...
15:57:05 <mreh> > let folder (x:xs) = local (+x) (folder xs); folder [] = ask in runReader folder [1..5] 0
15:57:06 <lambdabot>   Couldn't match expected type `Control.Monad.Reader.Reader r a'
15:57:06 <lambdabot>         agai...
15:58:16 <McManiaC> does "template-haskell" build for anyone?
15:58:22 <McManiaC> Language/Haskell/TH/Quote.hs:31:12: Not in scope: data constructor `CharConstr'
15:58:24 <koeien37> McManiaC: you are not supposed to buy it.
15:58:27 <koeien37> build*
15:58:38 <koeien37> if you're trying to install data-accessor-template
15:58:45 <koeien37> add --constraint='template-haskell < 2.4'
15:58:52 <McManiaC> hmkay
15:59:51 <McManiaC> thx, seems to work
16:00:45 <b-rock> when you guys write haskell code... what is your workflow? editor -> commandline compile/run -> editor  or do you use ghci, or.....?
16:00:46 <mreh> monad reader was found in multiple packages?
16:01:07 <mreh> b-rock, editor and ghci works pretty well for me
16:01:23 <McManiaC> b-rock: in vim I have a keymap for :!ghci %
16:01:53 <tener> Saizan: i have following definitions
16:01:55 <monochrom> emacs (editor -> ghci)
16:02:00 <tener> type ResourceM = StateT ResourceST IO
16:02:04 <tener> type Net = ReaderT ConnInfo ResourceM
16:02:08 <tener> type PromptM = StateT PromptInfo Net
16:02:09 <mle> b-rock: emacs+ghci.
16:02:29 <tener> on PromptM i'd like to get state from ResourceM
16:02:42 <monochrom> In emacs (editor -> ghci), I just press C-c C-l and C-x b return
16:02:42 <b-rock> thanks everyone... seems like editor to ghc/ghci is the winner
16:02:53 <mle> though indentation in haskell-mode is occasionally a source of controversy and consternation.
16:02:59 <monochrom> err, s/C-x b return/C-x o/
16:03:15 <mreh> b-rock, it is about all there is right now
16:03:41 <Saizan> tener: then define e.g. inResource m = lift (lift m), so you can say inResource get
16:03:49 <monochrom> I'm also open to doing it in Eclipse.
16:04:18 <b-rock> mreh: yes, i came across leksah and yi, but i haven't found a good IDE type
16:04:29 <tener> Saizan: ah, ok, I was wondering if there is a better way to do it. thanks.
16:04:46 <b-rock> monochrom: is there an equivalent in yi?
16:04:58 <monochrom> I don't know. I haven't used yi.
16:05:08 <Saizan> tener: you could get to just say "get", but not with the current MonadState class
16:06:29 <mreh> > let folder (x:xs) = local (+x) (folder xs); folder [] = ask in runReader (folder [1..5]) 0
16:06:30 <tener> Saizan: with current meaning with current definition of MonadState or there is it my code that needs changing?
16:06:31 <lambdabot>   15
16:06:35 <vovik> copumpkin, thanks, that worked
16:06:46 <mreh> I am so smart, S-M-R-T, i mean s-m-a-r-t
16:07:04 <b-rock> thanks Homer
16:07:30 <Saizan> tener: the former
16:08:18 <monochrom> Please don't tell me it's the beginning for "the progress of a monad fanboy in summing up numbers"
16:08:50 <mreh_> lol, monad fanboy?!
16:09:00 <Saizan> tener: though i think defining a getResource and getPrompt might actually make the code more readable
16:09:27 <tener> Saizan: i hope so
16:09:43 <tener> Saizan: this isn't the best code i've seen: wrld <- (unref <$> world) =<< (lift (lift $ get))
16:10:11 <monochrom> "with Reader", then "with State", then "with ReaderT State"... then "with LogicT ReaderT PromptT StateT DelimitedContT WriterT ContT STM"
16:10:40 <FunctorSalad> lift (lift get) should rarely be neccessary
16:10:45 <Saizan> tener: yeah, you really want to hide the lift behind an higher-level named function
16:10:48 <FunctorSalad> the outer monad should be MonadState too
16:11:00 <Saizan> FunctorSalad: he has nested StateT
16:11:03 <FunctorSalad> (no idea which monad we are talking about)
16:11:05 <FunctorSalad> Saizan: oh
16:11:13 <Phyx-> hmm, I need a very small, (1-2 lines) function in the prelude that does pattern matching and if recursive on the matched algorithm
16:11:23 <monochrom> ReaderT StateT IO can still use get directly.
16:11:37 <monochrom> Even ContT ReaderT StateT IO.
16:11:44 <FunctorSalad> Saizan: thought that errored out with fundep errors
16:11:54 <Saizan> by nested i meant two StateT in the stack
16:12:03 <monochrom> Oh haha, I see now.
16:12:11 <Saizan> with a ReaderT in the middle in this case
16:12:34 <Saizan> FunctorSalad: no, it just means you can only have it work for the outermost one, even if the state types are different
16:13:21 <FunctorSalad> hmm, why doesn't the lower one bubble up?
16:13:42 <monochrom> I recommend redesign and merge the two states and have ReaderT ? (State (A,B))
16:13:47 <FunctorSalad> ((MonadState s m) => MonadState s (ReaderT e m))?
16:14:03 <mle> Phyx-: why in the prelude?
16:14:07 <monochrom> Yes that's right.
16:14:24 <tener> redesign is not applicable
16:14:39 <tener> I encode kinds of state there
16:14:45 <monochrom> In ReaderT e m, get calls m's get
16:15:08 <FunctorSalad> ah, but it doesn't bubble from ReaderT to StateT
16:15:19 <FunctorSalad> silly me :)
16:15:23 <mle> Phyx-: getLine, sorta
16:15:43 <monochrom> But of course, in StateT X (AnotherT (StateT Y ...)), get is StateT X's get.
16:16:00 <monochrom> Shadowing!
16:16:27 <FunctorSalad> (the fundep error I was thinking of was what happens if you try to MonadState innerState outerMonad, anyway)
16:16:38 <mle> scanl, lines, words, read might be better
16:16:51 <Phyx-> mle: i'm looking for a small function to use as an example in a talk, but getLine is way to big
16:16:57 <FunctorSalad> monochrom: shadowing? there just isn't any MonadState instance
16:17:00 <Phyx-> i'll use drop or last
16:26:28 <c_wraith> http://hackage.haskell.org/trac/ghc/ticket/650
16:26:37 <c_wraith> difficulty:  2-5 days.  hah.  :)
16:27:04 <c_wraith> Still, awesome to see that getting fixed.
16:31:51 * hackagebot upload: hack-handler-epoll 0.1.1 - hack handler implementation using epoll (ToralfWittner)
16:40:00 <Saizan> let's hope they'd be faster than ML or F# arrays, otherwise i don't want to see jdh's reaction
16:42:49 <sjanssen> Saizan: if Haskell's are faster, you won't see a reaction at all
16:42:51 <McManiaC> does anyone use the yi editor?
16:43:07 <Cale> c_wraith: It's funny how often the difficulty will say something like "a few hours", and then SPJ will work on it a bit, and it'll change to "2-5 days"
16:43:30 <McManiaC> are there any haddocks anywhere?
16:44:00 <c_wraith> that seems a lot more reasonable to me.  At least more reasonable than "2-5 days" being the hardest level of difficulty the tracker supports
16:44:52 <c_wraith> I mean...  where's the "3-4 years" option?
16:45:14 <Saizan> you should break those down into smaller tickets :P
16:45:20 <Cale> I guess things which take that long are beyond the scope of the bug tracker
16:46:46 <c_wraith> :t map . map
16:46:48 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
16:46:51 <Saizan> McManiaC: i think you've to make your own locally
16:47:11 <c_wraith> :t map . map . map
16:47:12 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
16:47:49 <c_wraith> Hmm.  TH doesn't have access to the inferred type of the expression it's splicing in, does it?
16:47:56 <c_wraith> I really think that would enable some cool tricks.
16:48:09 <McManiaC> Saizan: well, haddock seems to be stuck :S
16:48:23 <Heffalump> c_wraith: sadly not
16:48:56 <Saizan> is typechecking for the surrounding expression even started when the macro is evaluated?
16:49:14 <c_wraith> I'm sure it's not...  and that's why the information isn't available.
16:50:30 <copumpkin> bos: you accidentally the verb! the whole thing! (what's that about, by the way?)
16:50:45 <c_wraith> still, being able to write a generic deepMap that could be generated purely from context at compile time would be awesome.
16:51:03 <copumpkin> c_wraith: oleg had something like that somewhere I think
16:51:13 <bos> copumpkin: you don't know the original reference?
16:51:29 <copumpkin> bos: oh I do, I meant what were you actually talking about? :)
16:51:30 <c_wraith> I mean, the alternative is just use syb, which doesn't suck.
16:51:46 <c_wraith> So it's really just an idea for a parlor trick.  But it'd still be cool
16:51:49 <bos> copumpkin: just being a goof
16:51:55 <copumpkin> oh :)
16:52:36 <dmwit_> Hey all!
16:53:00 <Phyx-> hi dmwit_
16:53:37 <bos> copumpkin: i'm fixing some event bugs on OS X, so debugging code for a platform i don't use
16:53:44 <Phyx-> OH NOES, a computer that wakes itself up!, SKYNET!
16:53:56 <dmwit_> I'm quite proud of this little hack I just came up with. =)
16:54:25 <dmwit_> :t join . liftIO $ catch (fmap return io) (fmap return m)
16:54:26 <lambdabot> Not in scope: `io'
16:54:26 <copumpkin> the one on reddit?
16:54:29 <copumpkin> ah yep :)
16:54:35 <dmwit_> yup =)
16:54:51 <dmwit_> :t \io m -> join . liftIO $ catch (fmap return io) (fmap return m)
16:54:52 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> (IOError -> m a) -> m a
16:56:20 <copumpkin> this needs the multiCont treatment :P
16:56:29 * dmwit_ googles
16:56:31 <Astro> I'm wondering about strict binary parsing with the get monad
16:56:49 <copumpkin> dmwit: [(a -> r) -> r] -> ([a] -> r) -> r
16:56:53 <Astro> if I progress byte-wise, will it result in copying the string again and again for each byte?
16:57:06 <copumpkin> dmwit: not really sure what it would be for in this case :)
16:57:18 <dmwit_> heh
16:57:32 <Astro> or do strict bytestrings have a fast shortcut for the tail fun?
16:58:01 <Heffalump> I believe one possible representation is just a window into another.
16:58:52 <Saizan> yeah, only the offset will change
16:59:02 <Saizan> ?src ByteString
16:59:03 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:59:05 <heatsink> Life is but a journey from an initial representation to a final one.
16:59:28 <heatsink> sorry.
16:59:30 <Saizan> a bytestring is just a (length,offset,pointer) tuple
17:00:18 <copumpkin> a strict bytestring :)
17:00:18 <Astro> oh yeah
17:00:21 <Astro> that's awesome
17:00:45 <Phyx-> hmmm, i have an idea... i'll need ductape...
17:01:07 <Astro> the sky breaks open
17:01:37 <Phyx-> Astro: are you the dog astro, or the boy astro?
17:03:04 <Astro> boy
17:03:14 <Astro> with rocket legs
17:04:41 <Phyx-> and the gun in his butt
17:10:06 <tener> can you have simultanious read's and write's on network handle?
17:10:17 <tener> more specifically
17:10:27 <tener> can I have one thread wait on getLn
17:10:35 <tener> and other write something to the handle in the same time?
17:10:36 <monochrom> I believe yes.
17:10:53 <mux> tener: yes you can
17:11:08 <mux> (not a pun)
17:11:09 <tener> cool, thank you
17:16:36 * benmachine wonders why withState isn't (MonadState s m) => (s -> s) -> m b -> m b
17:17:04 <Phyx-> :t withState
17:17:06 <lambdabot> forall s a. (s -> s) -> State s a -> State s a
17:17:38 <Phyx-> benmachine: good question
17:18:13 <benmachine> :t \f m -> modify f >> m
17:18:14 <lambdabot> forall s (m :: * -> *) b. (MonadState s m) => (s -> s) -> m b -> m b
17:18:23 <copumpkin> omg magick
17:18:48 <Saizan> ?type withState
17:18:50 <Phyx-> @src withState
17:18:50 <lambdabot> forall s a. (s -> s) -> State s a -> State s a
17:18:50 <lambdabot> Source not found. That's something I cannot allow to happen.
17:18:58 <benmachine> Phyx-: I looked it up
17:19:03 <benmachine> withState f m = State $ runState m . f
17:19:08 <lispy> lambdabot: ?src fix
17:19:09 <lambdabot> fix f = let x = f x in x
17:19:17 <dmwit_> Hm, turns out my hack probably was unnecessary. =P
17:19:29 <dmwit_> :t catchError
17:19:30 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
17:19:36 <copumpkin> aw
17:19:49 <copumpkin> maybe someone will be inspired to do great things by it
17:19:59 <dmwit_> =)
17:20:16 <Phyx-> with great hacks come great responsibility
17:20:49 <lispy> Thanks Uncle Ben
17:20:51 <Phyx-> benmachine: I don't know, doesn't seem like there's a reason other than they were just systematically defining everythin in terms of interactions on the State object
17:20:54 <copumpkin> is it sad that when I saw the title of http://www.scheme.com/ I had an urge to call join on it?
17:21:20 <benmachine> no
17:21:29 <benmachine> it is a sign of your inherent awesome
17:21:39 <copumpkin> aw thanks
17:21:44 <Phyx-> hahahah
17:22:05 <Phyx-> !google
17:22:09 <Phyx-> @google
17:22:10 <lambdabot> Empty search.
17:22:18 <Phyx-> @google Latex symbol guide
17:22:20 <lambdabot> http://www.ctan.org/tex-archive/info/symbols/comprehensive/symbols-a4.pdf
17:22:20 <lambdabot> Title: The Comprehensive LaTeX Symbol List
17:22:28 <Phyx-> thanks you lambdabot
17:23:41 <Phyx-> lispy: i'm uncle Joe, uncle Ben died remember
17:26:25 <mreh_> When Conal composes the composition operator, it makes my heard hurt
17:26:36 <mreh_> result = (.)
17:26:50 <copumpkin> it's not that bad
17:27:23 <mreh_> :t (.) . (.)
17:27:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:27:39 <mreh_> or even, total recall!
17:27:45 <mreh_> :t (.) (.) (.)
17:27:46 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:28:25 <mreh_> old joke huh?
17:28:33 <Phyx-> > fix (.)
17:28:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
17:29:11 <copumpkin> > fix (const (.)) (*3) (+1) 5
17:29:14 <lambdabot>   18
17:29:34 <Phyx-> right, but that one's easy
17:29:36 <deulamco> Hey yo !!
17:29:38 <copumpkin> :)
17:30:18 <deulamco> anyone here try to make a Haskell starcraft proxybot /
17:30:19 <deulamco> ?
17:30:27 <copumpkin> can't say I have
17:30:39 <mreh_> can't say I know what I would do with one
17:31:03 <holmak> Humiliate south korean starcraft champions?
17:31:10 <dmwit_> ?hackage ConfigFile
17:31:10 <lambdabot> http://hackage.haskell.org/package/ConfigFile
17:31:11 <Phyx-> i can't say i even know what it is...
17:31:58 <mreh_> it's a national sport over there!
17:32:00 <deulamco> No.. It's AI competition 2010 from ESI
17:32:02 <deulamco> EIS
17:32:12 * mreh_ sniggers
17:32:20 <mreh_> AI... *gaffaw*
17:33:05 <mreh_> id like to do my machine learning coursework in haskell
17:33:11 <mreh_> but NO I have to use MATLAB
17:34:35 <Phyx-> i've recently started watching the west wing, and like it
17:34:45 <Phyx-> that's gonna cut into my haskell time
17:35:22 <mreh_> the president gets altzheimers, there I've ruined it for you
17:35:55 * Phyx- blackholes mreh_ 
17:36:10 <mreh_> gah! spaghettification!
17:37:19 <Phyx-> I wonder if the real white house is that exciting
17:37:52 <mreh_> no
17:38:49 <Phyx-> no? why do you keep crushing my hopes tonight!
17:41:55 <mreh_> Neil DeGrasse Tyson = Carlton Banks?
17:50:27 * gwern ponders http://www.scheme.com/tspl2d/further.html#g1835 Is there any haskell tutorial about continuations?
17:51:34 <heatsink> lambdabot: @where cps haskell
17:51:35 <lambdabot> I know nothing about cps.
17:51:44 <heatsink> @gg cps haskell
17:51:45 <lambdabot> Maybe you meant: . ? @ bf bug do ft ghc id msg pl rc v wn
17:51:59 <heatsink> There;s http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
17:52:31 <gwern> mm. see how that goes
17:52:36 <heatsink> It seems like a fairy advanced topic though.
17:52:49 <heatsink> I dunno if it really needs a tutorial.
17:55:33 <gwern> advanced topics especially need tutorials
17:56:46 <xle> does anyone have any experience with hdbc-odbc with mysql on os x? I keep getting: can't load .so/.DLL for: odbc (dlopen(libodbc.dylib, 9): image not found)
17:57:15 <Heffalump> when building GHC from source, is it normal for System/Console/Terminfo/Effects.o in libraries/terminfo to take a huge amount of memory to compile?
18:00:13 <gwern> ...
18:00:26 <gwern> heatsink: yeah, I don't think I'm going to learn continuations from that module
18:01:24 <mle> xle: is it looking for .dylib when there's a .so instead, or vice versa?
18:01:29 <mle> (Haven't used it, no)
18:01:36 <mle> or worse, .bundle
18:02:10 <interferon> are there java bindings for haskell?  i'd like to run haskell code in tomcat
18:02:37 <Axman6> not that i know of
18:02:44 <Axman6> you'd need to go through C
18:02:52 <Axman6> or use some kind of RPC
18:02:52 <Heffalump> I thought there was a bridge somewhere.
18:06:24 <copumpkin> there have been things but I think they're mostly bitrotted
18:06:34 <xle> mle: let me take a look
18:06:44 <interferon> hmm
18:06:53 <interferon> that's surprising
18:07:10 <c_wraith> hey interferon.  How goes the learning?
18:07:25 <xle> there is a libodbc.a in /usr/lib
18:07:36 <CalJohn_> if there are java bindings to C, you can probably make it work that way around, interferon
18:07:57 <CalJohn_> i think the FFI allows C to call haskell
18:08:20 <CalJohn_> probably that is hassle
18:08:21 <xle> mle: and the .dylib version is inside /opt/local/lib
18:08:39 <xle> but when I symlink it to /usr/lib, i get this error:
18:09:02 <mh__> gents could pls help me understand why this is not parsing data Vector :: Integer -> * -> * where         Nil :: Vector 0 a        Cons :: a -> Vector n a -> Vector (n+1) a
18:09:20 <mh__> I get invalid Integer error
18:09:35 <xle> mle: odbc.hs: <command line>: can't load .so/.DLL for: odbc (dlopen(libodbc.dylib, 9): no suitable image found.  Did find:
18:09:35 <xle> 	/usr/lib/libodbc.dylib: stat() failed with errno=62)
18:09:39 <copumpkin> mh__: you need another language :)
18:09:48 <mh__> :)
18:09:48 <copumpkin> try #agda
18:09:57 <copumpkin> (I'm not kidding)
18:10:02 <copumpkin> you can approximate that
18:10:11 <copumpkin> not sure you'd want a vector with a negative length anyway
18:10:14 <interferon> c_wraith: not bad
18:10:33 <mh__> I understand that agda is best for dependent types
18:10:43 <damd> better than haskell at least
18:10:46 <mh__> but how to do it using vector in haskell?
18:10:51 <sjanssen> mh__: in that code you use Integer where a kind is expected.  Integer is a type, not a kind
18:11:10 <mh__> ouch
18:11:31 <copumpkin> data Z = Z; data S n = S n; data Vector n a where Nil :: Vector Z a; Cons :: a -> Vector n a -> Vector (S n) a
18:11:49 <copumpkin> mh__: alternately, you can use SHE
18:11:59 <mh__> SHE?
18:12:03 <aavogt> you would use her?
18:12:14 <sjanssen> http://hackage.haskell.org/package/she
18:12:25 <copumpkin> http://personal.cis.strath.ac.uk/~conor/pub/she/
18:12:34 <copumpkin> the SHE on hackage isn't up to date
18:14:20 <Piratero> Hello everyone!
18:14:36 <Piratero> The latest version of haskell-x11 is located in DARCS, correct?
18:15:23 <damd> sounds like a reasonable assumption
18:15:49 <mh__> I see the link to darcs, I will check it out
18:16:45 <michael|> Why did I never start learning haskell earlier in my life?
18:16:51 <michael|> All of those years...just wasted.
18:17:24 <copumpkin> michael|: I feel the same way
18:17:51 * Axman6 can't imagine life without haskell anymore
18:20:05 <BMeph> I've noticed that there are a lot of C/Java-type bloggers that seem angry at Haskell's new-found popularity. What's up with that?
18:20:09 <c_olin> I took a term of haskell in college... but for some reason I didn't realize how much I liked it until about a month ago
18:20:34 <c_olin> now I wouldn't be sad if I never touched C++ again
18:21:18 <copumpkin> BMeph: it's a threat to their little bubble of expertise
18:21:21 <michael|> BMeph: Jealousy, I can only assume?
18:23:02 <Adamant> BMeph: OMG I might have to learn something new!
18:23:06 <Piratero> "Preprocessing library X11-1.4.6.1..."
18:23:16 <gwern> and thus we of wisdom & reach, by indirections find directions out
18:23:26 <Twey> BMeph: Got a link to that?
18:23:33 <Piratero> I just checkout'd a new version of it.
18:23:42 <Piratero> Why am I still compiling the old version?
18:23:50 <BMeph> Twey: I was looking at it at work; let me poke around...
18:23:58 <gwern> Piratero: there's currently some oddity with x11
18:24:02 <gwern> which repo are you using?
18:24:20 <Piratero> gwern: http://darcs.haskell.org
18:24:23 <Piratero> Ah, OK.
18:24:37 <Twey> Always nice to see some bile going the other way ;)
18:24:37 <gwern> Piratero: see? you're using the old one
18:24:40 <Piratero> Ah!
18:24:48 <Piratero> What is the new one?
18:24:54 <gwern> c.h.o
18:25:01 <Piratero> ...?
18:25:12 <copumpkin> code.haskell.org
18:25:21 <Piratero> Ah, OK.
18:25:22 <Piratero> Thank you!
18:26:19 <Piratero> Got it! Thanks!!!
18:27:37 <gwern> @tell dons it would be good to make darcs.haskell.org/x11's MOTD point at the new c.h.o repo; more than one person has been confused by it & the hackage version number
18:27:39 <lambdabot> Consider it noted.
18:27:41 <gwern> @flish
18:28:16 <aavogt> @fosh
18:28:17 <lambdabot> Not enough privileges
18:28:40 <aavogt> @flop
18:28:41 * lambdabot hits  with an assortment of kitchen utensils
18:28:58 <dino-> I've had a lot of grumpy times with Perl people at jobs when bringing Haskell up.
18:29:57 <dino-> I think Haskell has a lot of the terseness that is touted as a major strength in Perl.
18:30:19 <aavogt> somebody today had trouble defining an essence of functional programming
18:30:28 <gwern> aavogt: brandy
18:30:31 <dino-> Like this: map { print "$_\n" } (sort @l);
18:30:41 <dino-> (mapM_ putStrLn) . sort $ l
18:30:46 <Piratero> Is haskell-x11-xft no longer existant?
18:31:01 <dino-> Which IMO looks cleaner by far. And is typed. What's not to like.
18:31:33 <tensorpudding> haskell can be pretty terse, but it's not for the same reasons that perl is
18:32:08 <gwern> dino-: actually, if I were trying to convince someone, I'd write it as mapM_ putStrLn (sort l)
18:32:16 <gwern> definitely not using both . and $
18:32:43 <dino-> gwern: But composition is *the shit*
18:32:54 <dino-> Kidding, I get what you mean
18:32:57 <gwern> yeah, and you get that just fine wih parens too
18:33:17 <gwern> if you wanted composition, you should've said '(mapM_ putStrlin) . sort'
18:33:27 <tener> :t mapM_ putStrLn . sort
18:33:29 <lambdabot> [String] -> IO ()
18:33:51 <dino-> :o Even more terse!
18:33:56 <theorbtwo> If I wanted to convince somebody that my language of choice was better then there language of choice, a core function with a name ending in an underscore isn't a good way to do it.
18:33:58 <gwern> tener: use mapM and you get IO [String]
18:34:13 <theorbtwo> ...and neither is something where my language of choice isn't particularly more readable.
18:34:40 <aavogt> how would you convince somebody?
18:34:50 <theorbtwo> mapM_ putStrLn (sort l) isn't more readable then map { print "$_\n" } (sort @l) if you already know perl and not haskell.
18:34:55 <aavogt> and why bother anyways, theorbtwo?
18:35:05 <tensorpudding> what makes a language good?
18:35:11 <gwern> Piratero: X11-xft seems to be happily in existence
18:35:15 <hatds> a nice creamy center
18:35:34 <theorbtwo> I'd show them something common where Haskell's way is actually clearer then perl's.
18:35:49 <theorbtwo> (Nope, I don't know what that'd be -- my Haskell isn't nearly good enough.)
18:35:56 <tensorpudding> hatds: i prefer chewy toffee centers
18:35:56 <aavogt> does   map (print "$_\n") (sort @l)   work in perl?
18:35:59 <gwern> theorbtwo: sure, but suppose you know neither. middle school math means you know the haskell syntax, and you can assume mapM_ does something, and 'sort' is dead obvious, and 'putStrLn' is easily puzzled out
18:36:00 <Piratero> gwern: Thanks. I'll check it from DARCS.
18:36:26 <tensorpudding> syntax is one part of a language, and not always the biggest part
18:36:27 <gwern> theorbtwo: the perl, on the otherhand is mysterious. "$_\n" ??? @l ? {} *and* () ?
18:36:41 <gwern> map, fine, print, fine, sort, fine. but the rest...
18:36:42 <theorbtwo> gwern: What do you mean, middle school math?
18:37:04 <theorbtwo> Middle school math doesn't tell you what mapM_ means, or ., or $.
18:37:05 <gwern> theorbtwo: by middle school you've learned the f(g(x)) syntax for algerba
18:37:29 <aavogt> they do teach function composition syntax someplaces
18:37:45 <Veinor> what's the copyright status of the haskell wiki
18:37:52 <theorbtwo> Yes, you have.  In fact, you've also learned how commas work, which perl uses, unlike haskell.
18:37:55 <gwern> Veinor: bsd, essentially
18:37:59 <Veinor> kay.
18:38:07 <gwern> theorbtwo: where are commas in that perl example?
18:38:14 <Veinor> aavogt: no, but map { print "$_\n" } (sort @l) does
18:38:22 <hatds> I don't think people really understand f(g(x)) if they aren't math/science oriented
18:38:38 <theorbtwo> gwern: Nowhere; there aren't any multi-argument functions there.  It was an asside.
18:38:49 <Veinor> er, you might need a comma
18:39:05 <gwern> theorbtwo: a third of US casaulties on Okinawa were psychiatric casaulties
18:39:17 <tener> hatds: those people won't get anywhere near programming at all
18:39:19 <gwern> oh, I'm sorry, was that entirely irrelevant? it was just an asside
18:39:31 <Veinor> no comma.
18:39:39 <theorbtwo> gwern: Wow.  Way to be an ass, there.
18:42:04 <aavogt> Veinor: the {} must be used for functions?
18:42:12 <Veinor> {} denotes a block of code.
18:42:25 <Veinor> so { print 1} refers to an anonymous function that prints 1.
18:42:33 <dino-> aavogt: It's like a lambda, the $_ variable is set for you.
18:42:37 <aavogt> what's the difference between that and a value (sort @l)
18:42:43 <theorbtwo> The question is not "you've got somebody who knows no programming languages, how do you convince them that haskell is cooler then perl".  It's "you've got a guy who knows perl, how do you convince him that he should learn Haskell too."  The answer is that you talk about how static typing can catch errors, and doesn't have to suck.
18:42:43 <tensorpudding> wonder what kind of mind breaking would happen if people learned haskell as a first language
18:43:02 <Veinor> aavogt: you know how in Haskell an array has to be delimited by []? in Perl code blocks have to be delimited by {}
18:43:27 <dino-> aavogt: The (sort @l) is evaluating to the sorted list @l and being passed to map (that new list)
18:43:27 <theorbtwo> aavogt: (sort @l) isn't a value that sorts a list, that's sub{sort @l}.  (sort @l) sorts @l right there, and has a value of @l, sorted.
18:43:35 <Piratero> pwd
18:43:41 <Piratero> Oops, wrong window!
18:43:46 <dino-> But the first arg to map has to be a code block or function ref
18:43:47 <j4cbo> su -
18:43:48 <j4cbo> hunter2
18:44:03 <Piratero> :-D
18:44:03 <theorbtwo> dino-: Actually, it doesn't, but the other form is a bit obscure.
18:44:04 <dino-> That's actually not strictly true, there is a map EXPR, LIST form
18:44:08 <tener> one day i've showed an article on Haskell's lazyness to an architect (the kind that design buildings) and she understood the code easily.
18:44:10 <gwern> tensorpudding: not much. if you don't know programming, haskell is pretty sensible. it's algebra with bits that do stuff
18:44:32 <tener> it's not hard really.
18:44:38 <dino-> Yes, what theorbtwo  said.
18:44:59 <copumpkin> tensorpudding: there's a paper about that
18:45:16 <gwern> @wn hammer
18:45:18 <lambdabot> *** "hammer" wn "WordNet (r) 2.0"
18:45:18 <lambdabot> hammer
18:45:18 <lambdabot>      n 1: the part of a gunlock that strikes the percussion cap when
18:45:18 <lambdabot>           the trigger is pulled [syn: {cock}]
18:45:18 <lambdabot>      2: a hand tool with a heavy rigid head and a handle; used to
18:45:20 <lambdabot> [17 @more lines]
18:45:26 <aavogt> does haskell have this many special cases?
18:46:06 <gwern> aavogt: in the core Prelude only? I seriously doubt it. but if you pulled in everything in base, then you might be able to draw up a Haskell Periodic Table of Operators too
18:46:10 <theorbtwo> The thing you need to get about about comparing haskell to perl is that perl doesn't actually suck.  It has easy lambdas (which we tend to call closures), maps, all sorts of fun stuff.  It doesn't have easy lazyness and typing.
18:46:14 <aavogt> I don't see them, but that's probably because I'm familiar with it
18:46:23 <tensorpudding> haskell has those combinators
18:46:24 <hatds> gun hammer listed before tool hammer, really?
18:46:51 <theorbtwo> The other thing is that haskell has a lot of nonspecial cases that might be easier if they were special.
18:47:06 <theorbtwo> You've got foldl and foldr and foldl'.
18:47:23 <theorbtwo> map and mapM and mapM_.
18:47:26 <tensorpudding> so many folds
18:47:31 <c_olin> tensorpudding: At Portland State University they are supposedly going to start teaching Haskell for the first year Computer Science classes
18:47:31 <hatds> what's a special case in this context?
18:47:38 <ivanm> what's the current topic of discussion/flaming?
18:47:43 <c_olin> which could be one's first programming encounter
18:47:49 <tensorpudding> c_olin: interesting
18:47:55 <theorbtwo> ...and that's just the ones I know about already.
18:48:00 <tensorpudding> yeah, i wonder how that would go over
18:48:02 <aavogt> do you mean how other languages have regular sequences, and also iterators. lazy lists do both...
18:48:05 <ivanm> preflex: seen cjs
18:48:05 <preflex>  cjs was last seen on #haskell 30 days, 19 hours and 22 seconds ago, saying: I didn't realize that Haddock generated an index-frames.html as well.
18:48:20 <c_olin> Mark Jones (writer of hugs) will probably be teaching it
18:48:23 <tener> c_olin: they already do that elsewere
18:48:44 <theorbtwo> aavogt: Many languages don't have iterators as a major feature, and don't really miss them.
18:49:49 <Adamant> c_olin: second semester or first?
18:50:54 <BMeph> Twey: ping
18:51:07 <tensorpudding> there are probably some intro to programming classes that don't mention recursion
18:51:32 <theorbtwo> Quite a lot, I think.
18:51:39 <mm_freak> some of you have noted that coq and agda are even more advanced than haskell, but i'm reading that programs in both languages must always terminate
18:51:48 <mm_freak> so a program like main = main is impossible?
18:51:59 <gwern> I remember my algorithms class. the teacher had us use it, but reminded us often that recursion was inefficient and slow
18:52:09 <aavogt> mm_freak: you won't be able to write a type signature for that main I think
18:52:12 <theorbtwo> mm_freak: Er, um... halting problem?
18:52:12 <tensorpudding> i'd imagine you couldn't make it through a course on algorithms without learning recursion though
18:52:14 <EvanR> gwern: had the same experience!
18:52:15 <gwern> because it would eat up stack space and required all those function calls, you see
18:52:27 <Veinor> gwern: haha
18:52:38 <Veinor> whereas iteration is always fast?
18:52:46 * theorbtwo shrugs.
18:52:47 * gwern thought the teacher should've mentioned that some non-java languages actually did TCO
18:53:01 <Twey> BMeph: Pong
18:53:03 <theorbtwo> It's generally pretty good advice.
18:53:11 <mm_freak> aavogt: i didn't go that deep into them yet, i'm just asking whether those languages are useful for actual application development (disregarding lack of libraries)
18:53:45 <theorbtwo> In some cases, yes, recursive algorithms are clearer, but in most languages a well-written iterative approach will beat it in efficency.
18:53:49 <mm_freak> theorbtwo: if i read right, the halting problem is irrelevant in those languages, because every program terminates
18:53:54 <Axman6> theorbtwo: i think in Agda or Coq (possibly both, i can't remember), you're required to prove termination
18:54:09 <Twey> theorbtwo: Halting problem only applies to Turing-complete languages
18:54:14 <BMeph> Twey: You asked about a link to someone complaining about Haskell. Well, technically, it's about how wonderful it is to program with impurity - check it out: http://debasishg.blogspot.com/2010/01/pragmatics-of-impurity.html
18:54:18 <theorbtwo> Twey: Yes.  Exactly.
18:54:21 <dino-> theorbtwo: The closures in Perl aren't as powerful as first-class functions, you end up with a function ref that has to be dereferenced to be used.
18:54:23 <Axman6> theorbtwo: not if the recursive code is compiled into similar code as the iterative code :)
18:54:38 <copumpkin> ZOMG RECURSION SLOW
18:54:46 <copumpkin> UZE A 4 LOOP
18:54:49 <theorbtwo> Axman6: Yeah.  Most languages, most compilers, won't do that.
18:54:54 <Twey> They get around that by not being Turing-complete (although AIUI at least one has ‘unsafe’ escapes)
18:55:02 <Axman6> GHC seems to, in general
18:55:10 <Axman6> well, if you treat it properly
18:55:11 <copumpkin> omnom
18:55:15 * copumpkin strokes GHC
18:55:15 <Twey> BMeph: Ooh
18:55:26 <mm_freak> ok, then i conclude that agda and coq are great for research, but not so great for application development
18:55:35 <theorbtwo> dino-: Er, that's just a syntatic difference, isn't it?
18:55:36 <copumpkin> mm_freak: why?
18:55:37 <gwern> mm_freak: not unless you have gobs of money
18:55:57 <BMeph> Hey! Don't you be bad-mouthing my Coq, you har? ;p
18:56:05 <copumpkin> mm_freak: agda will deal with nonterminating functions if you don't mind them (and don't try to use them in types)
18:56:14 <gwern> I imagine that if you're shelling out for ada development to a Z model in really high assurance situations, coq/agda might be cheaper
18:56:15 <mm_freak> dunno, it's my intuition =)
18:56:20 <copumpkin> mm_freak: in general though, unrestricted nontermination isn't what you want
18:56:27 <copumpkin> you want productive corecursion probably
18:56:38 <Axman6> gwern: shelling out for Ada?
18:56:55 <EvanR> copumpkin: at work they use for loops for everything, makes my cry :(
18:56:56 <gwern> Axman6: well, development that way is expensive
18:57:09 <gwern> Axman6: you ever read that fast conmpany article about nasa development?
18:57:13 * Axman6 <2 Ada
18:57:13 <copumpkin> EvanR: FOR LOOPS ARE AWESOME! DON'T CRY
18:57:14 <Adamant> gwern beat me to it
18:57:17 <Twey> BMeph: Amusing
18:57:26 <Axman6> gwern: i think so, and if it's the one i'm thinking of, i loved it :)
18:57:28 <Twey> BMeph: Someone needs to introduce that guy to Debug.Trace
18:57:39 * Axman6 <3 Ada too
18:57:40 <mm_freak> which language do your people prefer?  seems like agda is a bit cleaner and has better haskell integration
18:57:43 <EvanR> copumpkin: if the problem is especially difficult, they use 2 or even 3 at once!
18:57:44 <idnar> mm_freak: applications that loop forever without doing anything aren't usually very useful
18:57:48 <Adamant> gwern: NASA is more or less using a statistical approach
18:57:54 <Adamant> no proof systems
18:57:56 <copumpkin> mm_freak: agda over coq
18:58:06 <mm_freak> idnar: sure, but nevertheless a general purpose language should be able to express them
18:58:10 <gwern> Adamant: iirc, they specify everything in Z, which is a formal language
18:58:11 <idnar> Adamant: I don't think NASA is a good model for anything except failure
18:58:13 <copumpkin> but I can't say I've used coq beyond the tutorial :)
18:58:19 <idnar> mm_freak: why?
18:58:24 <copumpkin> agda feels more like programming though
18:58:33 <mm_freak> idnar: because that might be your application
18:58:36 <idnar> mm_freak: the inability to express buggy programs sounds like a feature to me, not a bug
18:58:37 <Axman6> NASA do a hell of a lot of good work, and i don't think it's fair to bad mouth them
18:58:53 <theorbtwo> If you can't possibly write something in your programming language, it's not really general purpose, is it?
18:58:57 <mm_freak> idnar: of course, but infinite loops don't _have_ to be bugs
18:59:04 <gwern> 'The Z notation (formally pronounced /zɛd/), named after Zermelo–Fraenkel set theory, is a formal specification language used for describing and modelling computing systems.'
18:59:17 <idnar> mm_freak: the only purpose a nonproductive infinite loop has is burning CPU cycles
18:59:29 <idnar> mm_freak: which you could just as easily do by producing data that you throw away
18:59:29 <copumpkin> mm_freak: that's what I meant about being productive. If your infinite loops (recursion) produce something observable, you're good
18:59:37 <mm_freak> idnar: indeed
18:59:39 <Axman6> gwern: correctly pronounced zɛd ;)
18:59:51 <BMeph> Twey: As long as they don't show him 'unsafePerformIO' - it'd likely blow his mind!
18:59:57 * Twey laughs.
19:00:04 <idnar> mm_freak: so infinite recursion is essentially useless
19:00:06 <gwern> theorbtwo: not sure any language besides asm lets you write *anything* without some sort of escapehatch. how do you set individual processor registers in either haskell or perl?
19:00:14 <Adamant> gwern: maybe now.I think their main theory when they started was "a code base of this size should have X number of bugs. find them all, find the bugs we deliberately put in the codebase for you to find, and then spend a few months extra looking for bugs"
19:00:24 <mm_freak> idnar: i use 'forever' a lot
19:00:38 <mm_freak> in haskell that is
19:00:40 <dino-> theorbtwo: Not exactly. You can use (2 *) in Haskell anywhere you'd expect a number, but $f = sub { 2 * $_[0] } is a ref to a function. You have to $f->(2); to call it.
19:00:54 <Adamant> idnar: they are many reasons to hate on NASA, but their software folks are not commonly considered to be one of them
19:01:01 <idnar> mm_freak: I would guess that your use cases are actually corecursion, though
19:01:03 <dino-> It's indirected away from the type it evaluates to by another level.
19:01:05 <gwern> wonder what typesystem Z uses
19:01:09 <theorbtwo> gwern: In both cases, I'd say you use the C extension mechinisim.  I take your point.
19:01:21 <copumpkin> idnar: superficially they look the same
19:01:25 <dino-> I mean, anywhere you'd expect a function that does something to a number.
19:01:26 <dino-> bleh
19:01:44 <idnar> Haskell doesn't really distinguish between recursion and corecursion, so it doesn't really matter how you frame things
19:01:49 <theorbtwo> (OTOH, I can think of at least one way to cheat in perl, but it is horribly evil.  Eviler then unsafePerformIO.)
19:02:05 <idnar> in languages like agda, you do have to distinguish between them
19:02:12 <copumpkin> :)
19:02:19 <Axman6> unsafePerformIO isn't evil, it's people who misuse it that are
19:02:40 <idnar> which is good, because you can write unlimited corecursion without accidentally introducing unlimited recursion
19:02:45 <theorbtwo> dino-: You can put sub {2*shift} anywhere you expect a function that returns a number, because that's how you take that... hm.  Maybe not...
19:02:53 <mm_freak> idnar: mostly i use forever in a state monad, so it's really classic looping
19:03:07 <mm_freak> idnar: but usually it's in a ContT, so i escape via callCC
19:03:27 <BMeph> Pop quiz: How many people snickered the first time they heard the US pronunciation of the name for the letter 'Z'? :)
19:03:39 * Axman6 puts his hand up
19:03:44 * Twey too
19:03:49 <EvanR> i resemble that remark
19:03:53 <dino-> $ perl -le '$x = 3 * { 2 * $_[0] }; print "$x"'
19:03:56 <theorbtwo> BMeph: I didn't.  I did, however, snicker the first time I heard the british version.
19:03:58 <dino-> 454907976
19:04:15 <idnar> mm_freak: my point is, I'm pretty sure you can write the same kind of programs in Agda as you are in Haskell
19:04:16 <Twey> Even more when I learnt that the reasoning behind it was so that it could rhyme in a children's song for remembering the alphabet.
19:04:21 <Axman6> it's not the british version, it's the correct one :)
19:04:26 <Adamant> Twey: huh
19:04:47 <idnar> you just need to think about recursion and corecursion differently
19:04:48 <Axman6> Twey: yeah, i think that's what always annoyed me most about it
19:04:51 <theorbtwo> > 3 * (2*)
19:04:51 <lambdabot>   No instance for (GHC.Num.Num (t -> t))
19:04:52 <lambdabot>    arising from the literal `3' at <...
19:05:03 <BMeph> theorbtwo: O RLY? What about the German version, then? ;
19:05:10 <Adamant> Axman6: the letter z has no connection with space aliens
19:05:22 <dino-> sorry, screwy example on my part
19:05:27 <Axman6> Adamant: glad to hear it... o.O
19:05:28 <Adamant> and I see no idea why you want to establish a linkage between the two
19:05:33 <theorbtwo> BMeph: Upsalon?
19:05:45 <aavogt> that's Y
19:05:49 <aavogt> try again
19:06:05 <EvanR> i griega!
19:06:17 <dino-> I guess if you could do it, maybe: perl -le '$x = { 2 * shift } (3); print "$x"'
19:06:21 <dino-> But that doesn't compile.
19:06:24 <idnar> Twey: the version of the alphabet song I learned had 'Z' pronounced 'Zed', so I'm not really sure what the problem is
19:06:30 <dino-> Anyway, enough with the Perl! :)
19:07:08 <Twey> idnar: I never learnt one :-\
19:07:13 <idnar> Twey: heh
19:07:18 <Axman6> heh
19:07:21 <ivanm> Axman6: so is dons going to be doing a talk @ ANU?
19:07:28 <idnar> Twey: I should add that I only learned it years after I learned the alphabet ;P
19:07:31 <Twey> Haha
19:07:33 <Axman6> i hope so, but i haven't heard anything
19:07:39 <ivanm> *nod*
19:07:49 <idnar> Twey: but the american version scans really awkwardly, it's like they weren't even trying
19:08:06 <Adamant> Zed definitely has rhythm
19:08:11 <Twey> Yeah… the extra bit on the end just to make it up, and so
19:08:28 <Twey> On the other hand, I remember the metre for the British one being really off
19:08:46 <Twey> You have to learn to pronounce ‘double-you’ in four beats
19:08:56 <theorbtwo> Aha, zet.  I will admit having to look it up.
19:09:11 * Twey knew it from the name of the ess-zet
19:09:12 <theorbtwo> Anyway, everybody knows that Zed's dead, baby.  Zed's dead.
19:09:23 <idnar> bizarrely, I have better recall of the hebrew alphabet than the roman alphabet, even though I've forgotten nearly every hebrew word I ever knew
19:09:27 <Adamant> or a Power Ranger enemy
19:09:27 <Saizan_> mm_freak: there's generally a way to express why you think your loop would terminate for recursion, or produce values lazily for corecursion, though with the current termination checker (in agda at least) that's not always straigthforward, but i'm hopeful that can be improved :)
19:09:28 * aavogt calls it a beta, however wrong that is
19:09:39 <Twey> aavogt: Haha
19:09:45 <Twey> Terribly wrong :þ  They're not even related
19:09:51 <EvanR> im trying to lurk here and scrape some valuable information about haskell. stop singing alphabets!
19:09:53 <Twey> It's a ligature of ſs
19:09:53 <aavogt> they look the same
19:09:58 <idnar> aavogt: that must be ever so confusing to people\
19:10:03 <theorbtwo> Twey: It took me a really long time to understand that, because I was only taught the modern ss, not the older sz.
19:10:04 <aavogt> I write them the same
19:10:14 <mm_freak> Saizan_: to be honest, i'm not going to use agda seriously, but it's an interesting language, so i'll at least play with it
19:10:21 <Twey> .u ßϐ
19:10:27 <Twey> Er, no bot
19:10:28 <idnar> ßβ
19:10:32 <Twey> But they look pretty different to me
19:10:40 <idnar> beta should have a tail on it
19:10:42 <tensorpudding> the etymology is different
19:10:42 <Twey> The beta is either more rounded or has a tail
19:10:50 <idnar> er, what's that called; a descender?
19:10:54 <Twey> Yes
19:11:02 <idnar> although, hmm
19:11:07 <idnar> is there a capital esset?
19:11:08 <aavogt> doesn't the s which looks like a f have a descender?
19:11:12 <Twey> idnar: No
19:11:13 <theorbtwo> idnar: No.
19:11:22 <Twey> aavogt: No
19:11:29 <aavogt> so you wouldn't keep that in the ligature?
19:11:30 <tensorpudding> the german double s is a ligature between a typographic long s (the one that looks like an f without a bar) and a short s
19:11:41 <Twey> aavogt: There is no descender to keep
19:11:52 <Twey> tensorpudding: I just said that :þ
19:11:57 <Twey> 03:09:29 < Twey> It's a ligature of ſs
19:12:08 <tensorpudding> oh, that was before i paid attention, sorry
19:12:11 <idnar> ßβBBϐ
19:12:16 <Saizan_> mm_freak: kk, just trying to support the idea that non turing complete languages can be general purpouse
19:12:18 <theorbtwo> It's one of those things that mkaes handling text interesting.
19:12:36 <Twey> idnar: Ess-zet, lower-case beta, ?, ?, symbol beta
19:12:45 <Twey> One of those in the middle is presumably a Latin B
19:12:49 <Twey> And the other… capital beta?
19:13:01 <idnar> first one was latin B
19:13:06 <Twey> They're almost identical in my font, though
19:13:09 <idnar> second one capital beta
19:13:10 <tensorpudding> possibly the cyrillic В
19:13:14 <Twey> I think the latter is slightly wider
19:13:15 <idnar> and they're completely identical in my font
19:13:16 <Twey> Oh yes
19:13:17 <aavogt> Twey: how about this one: http://en.wikipedia.org/wiki/File:Fraktur_humboldtfraktur.png
19:13:25 <idnar> then there's В which is cyrillic capital ve or whatever it's called
19:13:30 <tensorpudding> yes
19:13:33 <Twey> Yeah
19:13:40 <aavogt> wait, there's no s in there
19:13:43 <tensorpudding> it derives from the same greek for beta, but is pronounced differently
19:13:45 <BMeph> "Veh"
19:13:48 <theorbtwo> In my current font, beta and esszet are completely identical...
19:13:50 <idnar> and I think there's one or two more characters which render the same in most fonts
19:14:03 <theorbtwo> ...but that's probably because I haven't bothered to start X!
19:14:11 <idnar> theorbtwo: they're both boxes?
19:14:14 <tensorpudding> it's paired with Б which actually sounds like the latin B
19:14:19 <idnar> theorbtwo: unicode_start!
19:14:21 <mm_freak> Saizan_: unfortunately i know what impact haskell had on me…  since i know how nicely things can be expressed/solved in haskell, programming in other languages is very tiring and annoying
19:14:21 <Twey> ßβBBϐВБ
19:14:40 <mm_freak> so i fear that agda will have the same impact even looking at haskell
19:14:50 <idnar> uhm, so what the heck is ϐ?
19:14:57 <theorbtwo> idnar: I'm in unicode mode, but I'm still limited to the 256 chars this font supports, so they both look like beta.
19:15:00 <Twey> ‘Symbolic beta’, says Unicode
19:15:08 <idnar> theorbtwo: ah
19:15:15 <tensorpudding> where is the phoenician
19:15:46 <theorbtwo> I think it's there for beta, the way mathematicians write it, which isn't the same as the way modern greeks write it.
19:15:53 <Twey> Speaking of Haskell in other languages… http://erxz.com/pb/22633 yea or nay?  (Javascript)
19:16:05 <tensorpudding> which is the common root of the greek and hebrew alphabets
19:16:06 <Twey> I'm told that ‘Object.extend(this, Object.fromPairs(lines.slice(1, lines.length - 2).map(bind(true, "split", [/\s*:\s*/]))));’ is ‘completely write-only’
19:16:12 <Twey> But it looks perfectly reasonable to me
19:16:23 <tensorpudding> though it doesn't much look like either of them at all
19:16:26 <idnar> Ȥ
19:16:30 <idnar> ȥ
19:16:32 <gwern> Twey: in js, I think I'd name some of the intermediate values
19:16:35 <gwern> as documentation
19:17:01 <dfrey> I am accepting user input in the form "Int Int" and I want to get the two numbers into Haskell Ints.  How should I do this?  I know that the read function can take a string and convert to an Int, but I don't understand whether there is anything I can do when read fails
19:17:06 <idnar> Twey: yeah... that's expression soup to me
19:17:12 <tensorpudding> the pronunciation of phoenician letters seems to match the semitic languages more
19:17:12 <Twey> Hmmm
19:17:21 <idnar> Twey: it's not as dense as a regex, so I can pick it apart, but I'd have to do it every time I look at it
19:17:27 <Twey> It's only nested four-deep
19:17:30 <Axman6> dfrey: try map read . words
19:17:45 <idnar> Twey: the regex thrown in at the end there just adds insult to injury
19:17:48 <Axman6> > map read . words $ "1 2" :: [Int]
19:17:50 <idnar> [/\s*:\s*/]))))
19:17:50 <lambdabot>   [1,2]
19:17:52 <Twey> I think the main impediment to legibility is the fact that the direction of reading keeps changing, and you have to start somewhere in the middle
19:17:56 <Axman6> > map read . words $ "1 2 2 9 987  98 987 97 9 7987 89 7" :: [Int]
19:17:58 <lambdabot>   [1,2,2,9,987,98,987,97,9,7987,89,7]
19:18:11 <dino-> > map read . words $ "foo bar" :: [Int]
19:18:12 <lambdabot>   [* Exception: Prelude.read: no parse
19:18:24 <idnar> Twey: at the very least, wrap it to 80 chars ;)
19:18:39 <dfrey> > map read .words "1 2 3 abc 4 5 6] :: [Int]
19:18:40 <Twey> Well, yeah
19:18:40 <lambdabot>   <no location info>:
19:18:40 <lambdabot>      lexical error in string/character literal at end o...
19:18:50 <dfrey> > map read .words "1 2 3 abc 4 5 6" :: [Int]
19:18:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:18:52 <lambdabot>         against inferred type ...
19:18:56 <idnar> Twey: frankly, if you wrote the equivalent in Python or Haskell, it would probably be legible
19:18:57 <Axman6> > map read . words $ "1 2 2 9 987  98 987 97 9 7987 89 7 abd" :: [Int]
19:18:58 <lambdabot>   [1,2,2,9,987,98,987,97,9,7987,89,7,* Exception: Prelude.read: no parse
19:19:14 <dfrey> Axman6: what do I do about that
19:19:25 <idnar> lines.slice(1, lines.length - 2) is way more effort to mentally parse than lines[1:-2]
19:19:29 <Twey> Yeah
19:19:33 <Axman6> shout at your users :)
19:19:33 <Twey> I concur
19:19:59 <jmillikin> *sigh* I think my Haskell lesson for today is that if something really obvious hasn't been done yet, there's probably a damned good reason.
19:20:05 <idnar> also, I tend to just use anonymous functions instead of tricks like bind()
19:20:09 <idnar> but I suppose that's more of a subjective style issue
19:20:16 <dfrey> Axman6: seriously though, any ideas?
19:20:21 <sjanssen> jmillikin: what really obvious thing?
19:20:31 <jmillikin> sjanssen: capped-list
19:20:46 <Axman6> > map read . filter (all isDigit) . words $ "1 2 3 4 abd 35 d"
19:20:48 <lambdabot>   [* Exception: Prelude.read: no parse
19:20:51 <sjanssen> jmillikin: capped?
19:20:56 <idnar> Twey: bind() might be a bit more legible if you make it varargs instead of using an explicit list
19:21:01 <Axman6> > map read . filter (all isDigit) . words $ "1 2 3 4 abd 35 d" :: [Int]
19:21:01 <jmillikin> it seemed like a good idea at the time, but now I'm up to my armpits in "oh shit, this doesn't make any sense"
19:21:02 <lambdabot>   [1,2,3,4,35]
19:21:03 * ivanm guesses a list with a maximum size
19:21:10 <Axman6> how's that dfrey?
19:21:14 <theorbtwo> Yeah, that's one thing that gets me about Haskell -- and I'm sure I'm about to be crucified here -- it doesn't make error handling easy.  You can't let errors handle, and trap them where you want them, you need to think about it at every layer, or just let errors be fatal.
19:21:14 <Axman6> how's that dfrey?
19:21:17 <Axman6> whoops
19:21:22 <jmillikin> sjanssen: http://www.haskell.org/pipermail/haskell-cafe/2010-January/071803.html
19:21:28 <sjanssen> jmillikin: oh, a list where the last element is another type
19:21:29 <Axman6> > map read . filter (all isDigit) . words $ "1 2 3 4 abd 35 d not an int!" :: [Int]
19:21:30 <lambdabot>   [1,2,3,4,35]
19:21:35 <ivanm> Axman6: have a maybe version of reads with mapMaybe?
19:21:35 <Twey> idnar: It's more annoying to use, though
19:21:38 <gwern> capped-list? is that our normal lazy list with a size limit?
19:22:01 <jmillikin> tldr; some guy suggested a simple data structure on haskell-cafe, I implemented it, turns out there's a bunch of fiddly little details that make it annoying to implement / use
19:22:07 <Twey> I avoid varargs in JS in general because you have to screw about with .apply() to call them with variable arguments, then
19:22:10 <ivanm> @type let mReads s = case reads s of [(r,_)] -> Just r; _ -> Nothing in mReads
19:22:11 <lambdabot> forall a. (Read a) => String -> Maybe a
19:22:16 <idnar> Twey: I would expect 95% of uses to construct the argument list in-place
19:22:27 <Axman6> > map read . filter (all (`elem` "-1234567890") . words $ "1 2 3 4 abd 35 d not an int! negative -1234" :: [Int]
19:22:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:22:34 <idnar> Twey: for the other 5%, you could always have another version
19:22:38 <Axman6> > map read . filter (all (`elem` "-1234567890")) . words $ "1 2 3 4 abd 35 d not an int! negative -1234" :: [Int]
19:22:39 <sjanssen> jmillikin: what makes it so complicated?  The only problem I see is append
19:22:40 <lambdabot>   [1,2,3,4,35,-1234]
19:22:49 <ivanm> preflex: seen gour
19:22:49 <preflex>  gour was last seen on #haskell 66 days, 18 hours, 45 minutes and 59 seconds ago, saying: opqdonut: yes
19:23:00 <dino-> Can we do experessions with catch or handle here?
19:23:05 <Axman6> > map read . filter (all (`elem` "-1234567890")) . words $ "1 2 3 4 abd 35 d not an int! negative -1234 problem 123-456" :: [Int]
19:23:07 <lambdabot>   [1,2,3,4,35,-1234,* Exception: Prelude.read: no parse
19:23:16 <mistermattaway> how would you write soemthing like 'find the second smallest number in a list' in haskell? I tried to sit down to do it but I couldn't
19:23:19 <jmillikin> sjanssen: I'm trying to figure out how to get any interesting class instances without depending on Monoid for the cap
19:23:20 <Twey> idnar: I don't think that a single pair of square brackets harms legibility that much
19:23:21 <sjanssen> dino-: in lambdabot?  No, IO is not allowed
19:23:34 <idnar> Twey: of course, you do have to deal with "arguments" being something that walks like an Array and talks like an Array but doesn't quack like an Array
19:23:37 <Twey> Actually, it kind of helps it, by keeping the arguments grouped and separate from the rest
19:23:38 <idnar> so maybe that's worth avoiding
19:23:59 <Twey> idnar: Well yeah, but that's easily solved with an application of Array.prototype.slice()
19:24:29 <jmillikin> so that I can have (for example) concatMap on (CappedList (Maybe Integer) String), but the more I look at it, I think GHC is right and my goal here is just a really bad idea.
19:25:06 <jmillikin> It's sort of humbling when the computer can prove me stupid
19:25:07 <sjanssen> jmillikin: I think that you should omit the instances
19:25:46 * Twey chuckles.
19:25:51 <Axman6> GHC says: I can see what you're doing there, and you don't want to do that...
19:25:52 <tensorpudding> mistermattaway: i can think of a few ways, but they feel a bit hacky
19:25:55 <sjanssen> jmillikin: and make append :: CappedList unused a -> CappedList b a -> CappedList b a
19:26:03 <EvanR> mistermattaway: with two tries?
19:26:04 <idnar> Twey: I also dislike Ruby-style mutation of built-in prototypes, but again, I guess that's a style issue
19:26:41 <idnar> oh wait, you're not actually mutating the prototypes
19:26:44 <Cale> mistermattaway: sort xs !! 1
19:26:46 <Twey> idnar: Well, so do I
19:26:48 <Twey> Right ☺
19:26:49 * idnar scratches his head
19:27:01 <idnar> I don't even want to think about what that code does, but I guess it's fine
19:27:05 <Twey> Although I was thinking that maybe it would be better if I did there, because I could make the reading more linear
19:27:26 <tensorpudding> > max 2 3
19:27:28 <lambdabot>   3
19:27:29 <Twey> It's just using Object as a convenient namespace.
19:28:26 <Axman6> :t mapMaybes
19:28:28 <lambdabot> Not in scope: `mapMaybes'
19:28:31 <Axman6> :t mapMaybe
19:28:33 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
19:28:59 <idnar> @src mapMaybe
19:28:59 <lambdabot> Source not found. Just try something else.
19:29:03 <mistermattaway> I'm not really caring about the running time. I can write it in C++ but I cant figure out how to do it in haskell
19:29:06 <idnar> is that catMaybes . map ?
19:29:29 <Axman6> sounds likely
19:29:35 <Axman6> mistermattaway: what are you trying to do?
19:29:44 <mistermattaway> second smallest value in a list
19:29:52 <Cale> (!! 1) . sort
19:29:58 <Axman6> yeah, i like cale's idea
19:30:01 <Cale> assuming the list has at least two elements
19:30:19 <Axman6> or, (!! 1) . map head . group . sort
19:30:28 <ivanm> idnar: yes
19:30:42 <Axman6> > (!! 1) . map head . group . sort $ [1,2,3,1,4,6,4,3,6,76,3,5,34,6
19:30:43 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:30:44 <Axman6> > (!! 1) . map head . group . sort $ [1,2,3,1,4,6,4,3,6,76,3,5,34,6]
19:30:45 <lambdabot>   2
19:30:50 <Axman6> > (!! 1) . map head . group . sort $ [1,3,1,4,6,4,3,6,76,3,5,34,6]
19:30:52 <lambdabot>   3
19:30:53 <Cale> sort is lazy, so this should still be O(n)
19:31:14 <BMeph> > head . tail . sort $  [1,2,3,4,35,-1234]
19:31:15 <lambdabot>   1
19:31:26 <Cale> Though if you really care about performance, you might want to write the traversal by hand to kill off overhead
19:32:47 <BMeph> > (\(x:y:_) -> y) . sort $  [1,2,3,4,35,-1234,3,1,4,6,4,3,6,76,3,5,34,6]
19:32:49 <lambdabot>   1
19:33:03 <tensorpudding> > fst $ foldr (\x (s,l) -> if (x >= l) then (l, x) else (max x s, l)) (0,0) [1..100]
19:33:05 <lambdabot>   99
19:33:09 <tensorpudding> hooray, hack
19:34:07 <Cale> > let secondSmallest (x:y:xs) = f (min x y) (max x y) xs where f u v [] = v; f u v (x:xs) | x < u = f x u xs | x < v = f u x xs | otherwise = f u v xs in secondSmallest [1,2,3,4,35,-1234,3,1,4,6,4,3,6,76,3,5,34,6]
19:34:09 <lambdabot>   1
19:34:42 <tensorpudding> oh wait, this was the secondsmallest
19:35:18 <Saizan_> tensorpudding: i spent quite a while trying to figure out your code, before looking at the result :)
19:35:46 <tensorpudding> it'd be easier with an auxiliary function
19:36:12 <tensorpudding> also mine probably wouldn't work on lists of all negative numbers, huh
19:37:19 <aavogt> probably the simplest way to fix that is to compare on starting   (Nothing, Nothing)
19:37:54 <gwern> @hoogle trace
19:37:55 <lambdabot> Debug.Trace trace :: String -> a -> a
19:37:56 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
19:37:56 <lambdabot> module Debug.Trace
19:38:06 <tensorpudding> hmm
19:38:10 <tensorpudding> > Nothing < 0
19:38:11 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
19:38:12 <lambdabot>    arising from the lite...
19:38:22 <gwern> @hoogle unsafePerformIO
19:38:23 <lambdabot> Foreign unsafePerformIO :: IO a -> a
19:38:23 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
19:38:30 <aavogt> > Nothing < Just minBound
19:38:32 <lambdabot>   True
19:38:51 <aavogt> > Nothing < Just (minBound :: Int)
19:38:53 <lambdabot>   True
19:38:55 <tensorpudding> wrapping things in Just would make it less readable and longer
19:39:11 <aavogt> more correct?
19:39:14 <tensorpudding> well, yes
19:39:21 <interferon> do lhs files allow reordering of code, like knuth's tools?
19:39:43 <jmillikin> No
19:39:55 <tensorpudding> actually, why not use foldr1
19:39:57 <aavogt> the order of declarations in haskell doesn't matter though
19:39:59 <tensorpudding> @type foldr1
19:40:00 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
19:40:04 <tensorpudding> ah, right
19:40:05 <mistermattaway> clearly I have a long way to go with haskell
19:40:08 <jmillikin> .lhs is basically just verbose comments, it does not support Knuth-style literate programming
19:40:09 <tensorpudding> types would not work
19:40:44 <aavogt> top level declarations to be more specific, though if you use template haskell, that isn't really true anymore
19:42:38 <ivanm> jmillikin: :O how doesn't it support knuth-style literate programming?
19:42:48 <jmillikin> ivanm: it's not possible to re-arrange code segments
19:43:15 <ivanm> what do you mean?
19:43:25 <ivanm> you can move where you define a function in the file...
19:43:41 <jmillikin> for example, you can't say (function A code) (function B) (more function A)
19:44:02 <jmillikin> All imports have to be at the top, instead of where they're used. Ditto exports.
19:44:05 <ivanm> ahhh
19:44:15 <ivanm> you can actually do that in cweb?
19:44:18 <jmillikin> Yep
19:44:22 <haole> hello there... are you the guys who maintain the haskell overlay in gentoo?
19:44:32 <interferon> aavogt: that's an excellent point
19:44:37 <ivanm> haole: some of us are; see #gentoo-haskell
19:44:46 <haole> ivanm, ok thanks
19:44:55 <interferon> aavogt: forgot that definitions can be out of order :)
19:44:59 <jmillikin> The entire point of cweb / noweb / etc is to decouple what the compiler processes and what the author writes
19:45:01 <gwern> hm. does the ST monad use unsafePerformIO?
19:45:19 <ivanm> gwern: what does the source say? ;-)
19:45:23 <gwern> I don't know
19:45:24 <dolio> ST doesn't use any IO.
19:45:46 <gwern> import GHC.IOBase       ( stToIO, unsafeIOToST, unsafeSTToIO )
19:45:47 <gwern> ?
19:45:50 <gwern> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/Control-Monad-ST.html
19:46:11 <dolio> Those are conversions between the two.
19:46:39 <dolio> Stuff like 'stToIO (ST s) = IO s'.
19:46:48 <idnar> that's just importing the implementations anyway
19:46:59 <idnar> the real code is in GHC.ST
19:47:34 <dolio> ST stuff is pretty similar to IO stuff, though.
19:47:49 <Axman6> just cooler
19:48:04 <dolio> And runST may be a lot like unsafePerformIO. I'm not really sure where it gets the "initial store" from.
19:48:08 <dolio> Since it doesn't really use a store at all.
19:48:24 <mistermattaway> I wonder if I should stick to c
19:48:28 <dolio> @src runST
19:48:28 <gwern> hm. good thing I didn't claim ST uses unsafePerformIO
19:48:28 <lambdabot> runST st = runSTRep (case st of { ST st_rep -> st_rep })
19:48:45 <dolio> @src runSTRep
19:48:45 <lambdabot> runSTRep st_rep = case st_rep realWorld# of (# _, r #) -> r
19:49:23 <idnar> @type realWorld#
19:49:23 <Axman6> mistermattaway: bad idea. you'll be stuck in the dark ages forever :)
19:49:25 <lambdabot> Not in scope: `realWorld#'
19:49:37 <gwern> only one case match?
19:49:48 * gwern wonders how that works
19:49:50 <Axman6> @hoogle RealWorld
19:49:50 <lambdabot> No results found
19:49:59 <interferon> is MACID in wide use or do people generally use rdbms's?
19:50:06 <idnar> @src realWorld#
19:50:07 <lambdabot> Source not found. Where did you learn to type?
19:50:13 <idnar> wait, am I reading that syntax correctly?
19:50:28 <Axman6> @src RealWorld
19:50:28 <aavogt> @google macid
19:50:28 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:50:29 <lambdabot> No Result Found.
19:50:32 <Axman6> @src RealWorld#
19:50:33 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:50:34 <aavogt> @google acid
19:50:35 <lambdabot> http://en.wikipedia.org/wiki/Acid
19:50:35 <lambdabot> Title: Acid - Wikipedia, the free encyclopedia
19:50:38 <Axman6> @src IO
19:50:39 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
19:50:41 <gwern> interferon: macid is no wider use than happstack?
19:50:46 <aavogt> @google acid consistency
19:50:47 <lambdabot> http://en.wikipedia.org/wiki/ACID
19:50:47 <lambdabot> Title: ACID - Wikipedia, the free encyclopedia
19:51:00 <idnar> anyhow, http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/GHC-ST.html
19:52:01 <idnar> @src STRep
19:52:02 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
19:55:04 <idnar> uhm, where does realWorld# come from?
19:55:28 <c_wraith> idnar: it's magic
19:56:39 <pikhq> idnar: Well, you see, GHC pretends that IO consists of functions from a RealWorld to a RealWorld and a result value.
19:56:42 <idnar> well, sure, but it must come from somewhere
19:57:10 <idnar> I just can't see where it's imported from
19:57:10 <BMeph> idnar: Dude, it's turtles all the way down. ;)
19:57:12 <interferon> how does liftIO get the IO monad it's contained in?
19:57:27 <copumpkin> idnar: GHC.Prim, it's not defined anywhere but that primops.txt I think
19:57:27 <pikhq> RealWorld is, of course, nothing more than a hack to represent mutation semantics in a purely functional language.
19:57:45 <dolio> I don't think primops.txt is really used anymore.
19:57:49 <idnar> GHC.Prim isn't imported there either
19:57:52 <dolio> At least, I seem to recall reading that.
19:58:10 <idnar> ah, it's reexported from GHC.Base
19:58:16 <copumpkin> dolio: that's how I added new gmp stuff just before they added the foreign prim imports
19:58:21 <pikhq> idnar: In short: RealWorld is magic. Significantly more magical than everything else GHC does.
19:58:34 <copumpkin> but they may have killed it between now and then
19:58:41 <idnar> pikhq: I understand that just fine; but it's not so magic that it appears from thin air without even being imported
19:58:54 <dolio> Hmm. Well, I don't think it was that recently that I read it.
19:59:10 <dolio> I thought I read it digging through the code thinking about adding those same primops. :)
19:59:12 <pikhq> Hrm. I thought the unboxed types were at about that level of magic?
19:59:29 <copumpkin> idnar: I remember tracking that down once
19:59:38 <copumpkin> you mean the realWorld# function, not the RealWorld type, right?
19:59:42 <idnar> copumpkin: right
19:59:48 <blackdog> anyone got a reference to how lexical scope can be implemented efficiently? my google-fu is failing me.
19:59:55 <idnar> copumpkin: well, I think it's more of a value than a function, but yeah
20:00:01 <copumpkin> yeah :)
20:00:36 <idnar> pikhq: it would kinda break the encapsulation if the compiler just injected realWorld# into your namespace everywhere
20:00:58 <pikhq> idnar: Ah.
20:00:58 <Cale> interferon: typeclasses?
20:01:03 <pikhq> Yeah, true.
20:01:10 <Cale> interferon: Not sure I understand the question
20:01:42 <interferon> suppose you're inside a State monad, nested inside an IO monad.  how does a liftIO inside the State monad refer to the outer IO monad?
20:02:02 <idnar> pikhq: GHC.Prim is magic in the sense that there's no Haskell source for it anywhere, I believe
20:02:06 <Cale> Do you mean that you're working with a StateT transformed IO monad?
20:02:07 <c_wraith> interferon: IO is never the outer monad.
20:02:10 <aavogt> by nested you mean  StateT SOMETYPE IO?
20:02:10 <copumpkin> idnar: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15741#a15741
20:02:13 <Cale> "outer monad"?
20:02:25 <idnar> interferon: you can't nest State inside IO, because there's no IOT
20:02:34 <Cale> Monad transformers are not a way to glue monads together, they're a way to transform monads into different monads.
20:02:47 <aavogt> State SOMETYPE (IO a)    probably doesn't have a MonadIO instance
20:02:49 <interferon> hmm
20:02:50 <idnar> (and there can't be, unless you have some really advanced technology)
20:02:56 <gwern> monad transformers: oleg sez ur doing it wrong
20:02:56 <aavogt> it could though, right?
20:03:15 <c_wraith> why wouldn't it have a monadIO instance?
20:03:17 <idnar> gwern: what are we supposed to use instead?
20:03:19 <copumpkin> idnar: it injects them into the GHC.Prim and .Base modules that way
20:03:26 <pikhq> @instances MonadIO
20:03:26 <copumpkin> the gHC_PRIM
20:03:27 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
20:03:34 <idnar> copumpkin: awesome
20:03:35 <Cale> c_wraith: because it's just a plain State computation, and not StateT over IO
20:03:45 <gwern> idnar: urticate me with a thousand asps if I understand his 'modular interpreters'!
20:03:45 <Cale> :t liftIO
20:03:46 <copumpkin> idnar: but obviously haddock never hears of that
20:03:47 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
20:03:49 <pikhq> c_wraith: Because nobody's defined one.
20:03:52 <aavogt> c_wraith: it probably needs some ghc extensions?
20:03:54 <dolio> I looked at that composable interpreters thing, and I wasn't sure what I was looking at at the end.
20:03:55 <pikhq> :)
20:04:02 <c_wraith> Oh, I missed that it was State, not StateT
20:04:06 <copumpkin> dolio: oleg's thing?
20:04:19 <Cale> liftIO defines a way to turn IO computations into computations in some monad which has presumably been constructed from IO in some fashion
20:04:33 <dolio> Yeah. It looked like all the code was written as term structures, like if I were writing a lambda calculus interpreter or something.
20:05:05 <Cale> How it does this is dependent on the actual monad transformers which have been applied -- they typically each have instances of MonadIO
20:05:07 <idnar> liftIO is a typeclass method, so the answer to "how does liftIO do X" depends on the instance definition
20:05:08 <Summermute> Haskel newb with basic question: Best material to learn ghc + general compilation + package installation + etc. mechanics ???
20:05:08 <dolio> Like "App (Lam ...) ...".
20:05:20 <dolio> Which doesn't strike me as ideal, but maybe I was missing something.
20:05:56 <dolio> Unless the point is to use a quasiquoter or something.
20:05:56 <idnar> I haven't even written any code with monad transformers yet
20:06:04 <Summermute> There's lots of great material on the language. I'm interested now in the mechanics of the tools and managing code/libraries/etc.
20:06:12 <Cale> Summermute: Well... there's the GHC manual itself. For installing packages, get hold of cabal-install.
20:06:13 <gwern> Summermute: real world haskell, I suppose, covers a lot of that
20:06:17 <pikhq> Summermute: GHC documentation, GHC documentation, and Cabal documentation, respectively.
20:06:21 <aavogt> there's a paper on that... wait no
20:06:29 <idnar> maybe I should wait a bit longer to do it ;)
20:06:31 <Cale> http://www.haskell.org/haskellwiki/Cabal-Install
20:06:31 <pikhq> Summermute: To be specific, the "usage" section.
20:06:59 <Summermute> Ok. I'll look to the system docs and cabal docs centering on the "usage" section
20:07:02 <c_wraith> It seems like instance "(MonadTrans t, MonadIO m) => MonadIO t m where liftIO = lift . liftIO" should work most of the time.
20:07:03 <Summermute> Thanks!
20:07:21 <tensorpudding> is there a rot13 encoder module, or do i have to roll my own?
20:07:29 <aavogt> well somebody has to define the MonadTrans instance then
20:07:45 <idnar> @hoogle rot13
20:07:46 <lambdabot> No results found
20:07:51 <c_wraith> Sure, but the only thing I'd expect to be MonadIO and not MonadTrans is...  IO
20:07:52 <SubStack> hooray, my Network.RFB module is rendering png images from a qemu image with the vnc interface enabled ^_^
20:08:15 <pikhq> tensorpudding: Eh, roll your own it looks like. Not too hard at all.
20:08:25 <SubStack> and then the web part of this looks pretty straight-forward with hack and loli
20:08:26 <interferon> i think i need to explore monad transformers more
20:09:10 <tensorpudding> well, i know it's not
20:09:32 <tensorpudding> but i wondered if that might be something they'd have packaged in some encryption lib somewhere
20:10:02 <aavogt> double rot13 encoding, anybody?
20:10:09 <idnar> rot26 encoding
20:10:18 <idnar> anyhow, there's http://en.literateprograms.org/Rot13_%28Haskell%29
20:10:20 <dolio> copumpkin: http://okmij.org/ftp/Haskell/ExtensibleDS.hs
20:10:23 * arr2 used to own rot26.net
20:10:31 <dolio> copumpkin: All the code even uses strings as variable names.
20:10:32 <arr2> .... in like 1995 .. sigh old
20:10:40 <copumpkin> dolio: ah yeah, I remember glossing over that
20:11:08 <pikhq> aavogt: rot26? How's about we golf that.
20:11:30 <aavogt> it
20:11:31 <aavogt> id
20:11:37 <c_wraith> pikhq: join reverse
20:11:39 <c_wraith> :)
20:11:47 <pikhq> > let rot26::[Char]->[Char];rot26=id in rot26"foo"
20:11:48 <lambdabot>   "foo"
20:11:49 <c_wraith> err.  crap.  that's wrong!!!
20:12:11 <c_wraith> join (.) reverse
20:12:14 <c_wraith> there.  that's what I meant
20:12:14 <pikhq> I'm going to insist on it being of type String->String, and no more generic than that. :P
20:12:17 <aavogt> > let rot26 = join (.) reverse in rot26 "hai"
20:12:18 <lambdabot>   "hai"
20:12:23 <mauke_> c_wraith: join const
20:12:31 <pikhq> :t join(.)reverse
20:12:32 <lambdabot> forall a. [a] -> [a]
20:12:37 <c_wraith> you want the high score in golf, right?
20:12:38 <pikhq> TOO GENERIC.
20:12:41 <copumpkin> join const o.O
20:12:49 <aavogt> Too<generic>
20:13:12 <mauke_> :t (""++)
20:13:13 <lambdabot> [Char] -> [Char]
20:13:26 <pikhq> Win.
20:13:43 <aavogt> :t (++"")
20:13:44 <lambdabot> [Char] -> [Char]
20:13:46 <mistermattaway> do you guys think that my algorithms teacher would be pissed if I submitted haskell one liners for stuff? instead of writing out for loops and thigns in java/c?
20:13:58 <idnar> "The present code is not written in idiomatic Haskell and does not take
20:13:59 <pikhq> :t ('':)
20:14:00 <lambdabot>     lexical error in string/character literal at character '\''
20:14:01 <aavogt> are you allowed any language mistermattaway?
20:14:05 <idnar> advantage of types at all."
20:14:07 <pikhq> Curses.
20:14:15 <mistermattaway> aavogt, iirc yes
20:14:27 <aavogt> perhaps the easiest thing is to ask the person in question
20:14:36 <mauke_> mistermattaway: sounds like a challenge!
20:14:36 <pikhq> mistermattaway: I don't *care* if he gets pissed, submit Haskell one-liners. ;)
20:14:49 <mauke_> use the most obscure language you can find
20:14:53 <pikhq> If he does get pissed, do it in Brainfuck.
20:14:54 <c_wraith> intercal
20:15:07 <mauke_> whitespace
20:15:09 <pikhq> Intercal compiled to Brainfuck.
20:15:10 <idnar> malbolge
20:15:10 <pikhq> By way of C.
20:15:17 <mauke_> OISC
20:15:34 <pikhq> NES assembly.
20:15:38 <mauke_> (I have a brainfuck->OISC compiler)
20:15:38 <mistermattaway> he said he'd be impressed if we submitted something in cobol, but would get no points
20:15:58 <c_wraith> even if you implemented the algorithm correctly?
20:16:01 <pikhq> mistermattaway: Eeeew.
20:16:02 <pikhq> Yeah, no Cobol.
20:16:03 <dolio> Write some for-loop combinators. :)
20:16:26 <SubStack> abuse the list monad!
20:16:41 <SubStack> also convert everything to pointfree
20:16:42 <mauke_> bonus points if you can find a use for reverse state
20:17:03 <pikhq> Do it all in State.
20:17:08 <pikhq> Pointfree, without do notation.
20:17:16 <dolio> Reverse state is good if you want to write infinite loops.
20:17:27 <mauke_> mistermattaway: well, haskell is pretty much the anti-cobol, but asking him first can't hurt
20:17:30 <dolio> Or mapAccumR.
20:17:52 * pikhq imagines something less comprehensible than Perl...
20:17:57 <mauke_> or this: http://mauke.ath.cx/stuff/haskell/posi.hs
20:18:03 <mauke_> it's reverse state, except not
20:18:08 <mistermattaway> I'll ask
20:18:56 <dolio> mauke_: Is that like reverse ST?
20:19:09 <mauke_> dolio: yes
20:19:13 <dolio> Heh.
20:19:23 <mauke_> but it actually works :-)
20:19:33 <copumpkin> wow
20:19:43 <dolio> You need to throw in some mdo so you can declare PVars after they're used. :)
20:19:47 <copumpkin> did you make it look intentionally unlike haskell?
20:19:58 <mauke_> copumpkin: yes, because the original code was in perl
20:20:03 <copumpkin> ah :)
20:20:59 <mauke_> Positronic.hs is in the same directory, btw
20:30:00 <roostaj> > "foobarfoo" =~ "foob[!z]r*" : (String,String,String)
20:30:02 <lambdabot>   Not in scope: data constructor `String'Not in scope: data constructor `Stri...
20:30:10 <roostaj> > "foobarfoo" =~ "foob[!z]r*" :: (String,String,String)
20:30:11 <lambdabot>   ("foobarfoo","","")
20:30:24 <roostaj> > "foobarfoo" =~ "foob[!z]r" :: (String,String,String)
20:30:26 <lambdabot>   ("foobarfoo","","")
20:30:41 <roostaj> > "foobar foo" =~ "foob[!z]r" :: (String,String,String)
20:30:42 <lambdabot>   ("foobar foo","","")
20:31:12 <roostaj> > "foobar abc" =~ "foob[!z]r" :: (String,String,String)
20:31:13 <lambdabot>   ("foobar abc","","")
20:31:29 <mauke_> …
20:31:48 <roostaj> > "foobar abc" =~ "foobar" :: (String,String,String)
20:31:50 <lambdabot>   ("","foobar"," abc")
20:31:54 <jmillikin> What's the procedure to remove a package from Hackage?
20:32:04 <Axman6> it's there forever!
20:32:33 <blackdog> yeah, we don't hold with destructive update
20:32:34 <Axman6> but, you could ask dcoutts about it
20:35:10 <sproingie> create a new hackage without the package :)
20:36:00 <jmillikin> ha! but that would be quite an expensive operation.
20:36:19 <Axman6> not really, the source is all in a darcs repo
20:36:41 <jmillikin> Well, in terms of getting a server, downloading the tarballs, keeping it sync'd...
20:37:14 <Cale> maybe email ross@soi.city.ac.uk (who gives out accounts on hackage, so...)
20:37:36 <jmillikin> I'm just going to go the easy way and upload a version of the package saying "don't use this"
20:37:37 <aavogt> gwern can too
20:37:46 <ivanm> jmillikin: why do you want to remove the package?
20:37:53 <raceRider> what's a good ref book that's in print that I can buy for functional programming
20:37:54 <aavogt> oh wait, hackage and not the wiki
20:37:57 <aavogt> sorry gwern
20:38:03 <jmillikin> 'cause it turned out I was solving a problem which really didn't need solving
20:38:06 <ivanm> raceRider: beginners? advanced?
20:38:07 <sproingie> might be nice if hackage used DOAP
20:38:14 <jmillikin> and now there's a dumb package up that *somebody* is going to trip over
20:38:20 <raceRider> ivanm, intermediate to adv
20:38:33 <gwern> jmillikin: have ross mark it deprecated
20:38:39 <ivanm> well, there's real world haskell, but that's more on how to use Haskell rather than just FP per se
20:38:44 <ivanm> but it's probably your best bet
20:38:45 <Axman6> jmillikin: submit a new package, with the code removed, and a big warning :)
20:39:08 <sproingie> sure it doesn't need solving?  maybe it just needs tweaking?
20:39:13 <sproingie> what's the package?
20:39:14 <raceRider> got Real World, anything else with FP background/basics
20:39:23 <jmillikin> sproingie: almost certain.
20:39:43 <Cale> raceRider: Well, if you're interested in type systems, TaPL is a good book on implementation and properties of them.
20:39:48 <Cale> You might have a look through http://www.haskell.org/haskellwiki/Books
20:40:07 <Cale> Richard Bird's book is supposed to be good, though it's probably aging a bit
20:40:20 <jmillikin> it was "empty" -- a type class for types which can contain "nil" values. I made it so I didn't have to depend on Monoid for cases where appending isn't used, but it turns out that the case I was thinking of was insensible.
20:40:58 <Cale> Okasaki's book about data structures in functional programming languages is good if you're looking for stuff about that specifically.
20:41:08 <raceRider> How's Simon Thompson's Craft of FP? Any thoughts
20:41:12 <ivanm> Cale: I don't recall it being really going up to advanced techniques though
20:41:12 <aavogt> submitting a new empty package probably breaks all the packages that depend on that one
20:41:18 <ivanm> raceRider: as a haskell tutorial its good
20:41:27 <jmillikin> aavogt: there are no packages depending on this (and there shouldn't be)
20:41:32 <aavogt> ok
20:41:37 <ivanm> but again, it's not really covering intermediate to advanced FP techniques IMHO
20:41:38 <jmillikin> maybe I'll put it in ACME as a joke? That would actually be sort of funny.
20:41:52 <ivanm> Cale: agreed; I wish it was updated to include bloom filters, etc. though
20:42:02 <aavogt> raceRider: that book covers a decent amount of stuff (monad transformers too??)
20:42:14 <jmillikin> Are the Hackage categories case-sensitive?
20:42:25 <sproingie> jmillikin: make it so it can throw NullPointerException then put it in acme
20:42:37 <ivanm> jmillikin: I think so...
20:43:09 <dfrey> How do you express that something is optional in parsec?  I want to parse a positive or negative integer, so I can accept "12", "-1", "700" etc.  I sort of figured out "many1 digit" for the numeric part and "char '-'" for the negative sign, but I don't know how to make the negative sign optional
20:43:57 <bd_> dfrey: use <|> to alternate with something that doesn't consume any input
20:44:07 <bd_> eg, (char '-' >> return True) <|> (return False)
20:44:21 <sproingie> how many Simons are in the haskell community anyway
20:44:26 <mauke_> bd_: why so complicated?
20:44:37 <jmillikin> I think it's just "optional"?
20:44:37 <jmillikin> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Combinator.html#v:optional
20:44:38 <jmillikin> oh, no, optionMaybe
20:46:04 <bd_> mauke_: it's been a while since I did parsec >.>
20:46:38 <Cale> http://www.cs.cmu.edu/~rwh/plbook/book.pdf -- this book (draft) looks rather good too
20:47:40 <Cale> Though, maybe a bit on the logician's side of things
20:47:53 <dfrey> bd_, optionMaybe looks promising.  I really need to figure out how to read Haskell types better.  I have no idea what any of the types mean in Parsec
20:48:00 <ivanm> Cale: there's a Real World Haskell user at CMU? ;-)
20:48:17 <Cale> Robert W. Harper
20:49:05 <ivanm> Cale: yeah, I figured it was something like that
20:49:12 <j4cbo> yeah, don't confuse rwh with rwh :P
20:49:18 * hackagebot upload: empty 9 - Ceci n'est pas une package (JohnMillikin)
20:49:25 <ivanm> it's just that RWH has become synonymous with the book by dons, bos and CosmicRay ;-)
20:49:35 <ivanm> jmillikin: now, wtf does the description mean? ;-)
20:49:54 <jmillikin> http://en.wikipedia.org/wiki/Ren%C3%A9_Magritte#Philosophical_and_artistic_gestures
20:49:59 <j4cbo> Haskell is not very popular at CMU.
20:50:26 <ivanm> jmillikin: so that package isn't a pacakge? ;-)
20:50:35 <jmillikin> not any more!
20:50:48 <syntaxglitch> John Millikin presents: The Treachery of Packages
20:50:50 <ivanm> hmmm... what's a polite way I can say in my talk that one of the reasons I chose Haskell was to piss off my supervisor? ;-)
20:50:50 <copumpkin> n'est plus!
20:50:54 <ivanm> syntaxglitch: heh
20:51:14 <jmillikin> jmillikin presents: the treachery of trying to be more clever than GHC
20:51:46 <Cale> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ -- hey, cool
20:51:47 <jmillikin> new years resolution: from now on, I wait at least two days before uploading anything, to see if it still makes sense in the morning.
20:51:59 <syntaxglitch> jmillikin, I've learned rather a lot trying that actually
20:52:13 <dfrey> gnuvince: Long time no IRC
20:52:28 <tensorpudding> i tried reading TTFP one
20:52:28 <syntaxglitch> Mostly I was learning that GHC was, in fact, cleverer than me, but still
20:52:29 <tensorpudding> once*
20:52:44 <ivanm> what's TTFP?
20:52:51 <tensorpudding> check the link Cale posted
20:52:52 <Cale> The book I just linked to
20:53:06 <tensorpudding> i first heard about Curry-Howard from that book
20:53:07 <ivanm> ahhh
20:55:15 * sproingie replaces jmillikin's head with a large green apple
20:56:18 <Cale> http://homepages.cwi.nl/~jve/cs/ -- and yet another book that I was previously unaware of
20:56:33 <Cale> Seems to have a linguistics bent to it
20:57:54 <Lemonator> hey, what if I create a list
20:58:00 <Lemonator> [C a => a]
20:58:01 <Lemonator> ?
20:58:13 <Lemonator> Isn't that a sort of non-homogeneous lists?
20:58:24 <jmillikin> Sort of -- you need to wrap the values in a GADT
20:58:28 <Cale> If you make an existential type of that sort
20:58:52 <Cale> You can't just write that, because it's a syntax error.
20:59:05 <Lemonator> yeah, well
20:59:06 <dolio> [exists a. C a => a]
20:59:11 <copumpkin> :)
20:59:18 <copumpkin> doesn't jhc support that?
20:59:19 <Lemonator> I wrote exactly that, and it compiled.
20:59:23 <Lemonator> in GHC
20:59:23 <dolio> Which not even UHC gives you, unfortunately.
20:59:24 <Cale> Did it?
20:59:32 <Lemonator> albeit with a whole bunch of extensions.
20:59:35 <dolio> Because existentials don't work with classes in UHC.
20:59:45 <Cale> Maybe impredicative polymorphism?
20:59:48 <dolio> (Last I checked, anyway.)
20:59:48 <copumpkin> Lemmih: hmm
20:59:52 <Lemonator> -XRankNTypes -XImpredicativeTypes -XFlexibleContexts
20:59:53 <copumpkin> Lemonator: I mean
20:59:57 <Cale> ah okay
20:59:58 <copumpkin> Lemonator: you needed a forall didn't you?
21:00:02 <copumpkin> I can see it working then
21:00:02 <Cale> then it doesn't mean what you think it means
21:00:03 <Lemonator> no forall needed.
21:00:06 <copumpkin> but that gives you something else
21:00:11 <Cale> It means [forall a. (C a) => a]
21:00:21 <copumpkin> Lemonator: it wants polymorphic values in the list
21:00:34 <copumpkin> [forall a. a] means you can't stick any non-_|_ values in that list
21:00:36 <Cale> That is, it's a list of polymorphic values
21:01:03 <Lemonator> is it any different from "C a => [a]"?
21:01:27 <Cale> yes
21:01:40 <Cale> Well...
21:01:43 <sproingie> "C a =>" means a is an instance of C, and it also means it's a specific instance of it
21:02:25 <Torrieri> how can i take elements from a list while a string is encountered?
21:02:26 <Cale> Only very subtly different from that
21:02:27 <Saizan> with [C a => a] you get to choose a different type for each element of the list
21:02:40 <Lemonator> yeah, that's what I want.
21:02:41 <Cale> Torrieri: hm?
21:02:49 <Cale> :t takeWhile
21:02:51 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:02:55 <sproingie> can you express [C a => a] literally?
21:03:06 <Saizan> C a => [a] you can choose any type, but only once for the whole list
21:03:06 <Lemonator> sproingie, what do you mean?
21:03:06 <copumpkin> Saizan: ? really?
21:03:07 <Axman6> literally?
21:03:10 <Cale> Torrieri: I don't know what you mean by "while a string is encountered"
21:03:15 <sproingie> i mean is that even valid syntax?
21:03:20 <Torrieri> cat but with takeWhile i can take a char
21:03:22 <Lemonator> It compiled.
21:03:25 <Torrieri> not string
21:03:31 <Lemonator> thus it must be valid syntax.
21:03:37 <Cale> sproingie: given ImpredicativeTypes (which are deprecated)
21:03:40 <Saizan> Lemonator: i don't think you want that, because it's the caller that chooses, not the constructor of the list
21:03:42 <Lemonator> I have still to see whether I can create any values of that type.
21:03:46 <sproingie> Cale: ah i never learned those
21:04:05 <Cale> They're only deprecated because the implementation in GHC is too complicated (apparently)
21:04:14 <sproingie> heck i just recently got rank-2 types drilled into my thick head
21:04:20 <kmc> data AnyC = forall a. (C a) => MkC a
21:04:21 <Cale> and so they're either going to reimplement them or drop the feature by the next release of GHC
21:04:22 <kmc> [AnyC]
21:04:25 <Saizan> copumpkin: yes
21:04:26 <kmc> that's the existential
21:04:31 <Torrieri> Cale, with takeWhile i can match a char and i wanna math a string
21:04:46 <Lemonator> Saizan, the caller chooses what?
21:04:50 <copumpkin> Saizan: so writing [C a => a] gives me an implicit existential? not a universal?
21:04:50 <Cale> Torrieri: okay...
21:04:52 <Torrieri> Cale, match
21:05:00 <Saizan> copumpkin: it's universal
21:05:02 <copumpkin> Saizan: I thought I was forced to write a wrapper type to get an existential
21:05:04 <Cale> Torrieri: Can you give me a concrete example of what you're trying to do?
21:05:13 <copumpkin> Saizan: ah okay then, so you can't choose the type you put in
21:05:24 <Saizan> copumpkin: who takes apart the list can choose
21:05:30 <Cale> Torrieri: Obviously, takeWhile would also work when applied to a list of words.
21:05:32 <copumpkin> yeah :)
21:05:41 <Saizan> copumpkin: that's what i was saying :)
21:05:58 <copumpkin> Saizan: ah I guess I was thinking of it from the other side when I read "you" :)
21:06:18 <Saizan> copumpkin: and that in particular, a different type can be chosen for each element
21:06:23 <copumpkin> yep
21:07:05 <Cale> > takeWhile (> 3) . words $ "take only words from the start of the string whose length is larger than 3"
21:07:07 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
21:07:07 <lambdabot>    arising from the literal `...
21:07:14 <Cale> > takeWhile ((> 3) . length) . words $ "take only words from the start of the string whose length is larger than 3"
21:07:15 <lambdabot>   ["take","only","words","from"]
21:07:34 <Saizan> Lemonator: the type, i.e. if you give me a list xs of type [forall a. a] i can do let (a:b:_) = xs in (a :: Int, b :: Char)
21:07:41 <Torrieri> Cale, a sec, my english is so bad
21:08:34 <Torrieri> Cale, i wanna do something like this takeWhile (/="This") "This is a sentence"
21:08:51 <Torrieri> Cale, that dont work
21:08:52 <Cale> Torrieri: which would result in [] ?
21:09:08 <Cale> maybe you want dropWhile?
21:09:18 <Cale> > dropWhile (/= "This") . words $ "This is a sentence"
21:09:20 <lambdabot>   ["This","is","a","sentence"]
21:09:22 <Cale> er
21:09:31 <Cale> > dropWhile (== "This") . words $ "This is a sentence"
21:09:33 <lambdabot>   ["is","a","sentence"]
21:09:40 <Cale> > dropWhile (== "This") . words $ "This This This is a sentence"
21:09:41 <lambdabot>   ["is","a","sentence"]
21:09:52 <Torrieri> Cale, thx
21:09:55 <Raynes> takeWhile and dropWhile look at each individual character when given a string. It doesn't look at words unless you make it by using the 'words' function.
21:10:00 <Axman6> Torrieri: can you give an example of what you expect the output of your takeWhile (/="This") "This is a sentence" would be?
21:10:16 <Axman6> takeWhile (/="This") "This is a sentence" = ???
21:10:34 <Axman6> " is a sentense" perhaps?
21:10:43 <Lemonator> Axman6, that doesn't make any sense.
21:10:51 <Lemonator> you can't compare characters to strings.
21:10:55 <Axman6> Lemonator: it may to someone new to haskell
21:11:08 <Axman6> you're missing my point i think
21:11:25 <Saizan> also, you don't just transliterate c to s randomly like that :P
21:12:02 <c_wraith> also, takewhile /= is very strange there.  even if it was coherent, it'd be strange. :)
21:12:21 <sproingie> why not fire up ghci and  try it out?
21:12:29 * hackagebot upload: capped-list 1.2 - A list-like type for lazy sequences, with a user-defined termination value. (JohnMillikin)
21:12:40 <sproingie> or there's always lambdabot :)
21:13:09 <kquick2> import Control.Monad.Trans complains that both mtl and transformers provide that module.  I can ghc-pkg hide one or the other but different packages seem to want one or the other.  What's wrong with my setup?
21:13:25 <c_wraith> kquick2: nothing.  you've discovered the horrible shame of hackage
21:13:26 <sproingie> hide transformers
21:13:28 <jmillikin> kquick2: nothing's wrong on your end
21:13:37 <Axman6> nothing, it's what's wrong with them both existing -_-
21:13:43 <sproingie> cabal will use hidden packages if you request them
21:13:59 <sproingie> so no need to worry unless you get the dreaded diamond dependency problem
21:14:00 <syntaxglitch> Hiding one package shouldn't impact packages that explicitly request it, right?
21:14:07 <jmillikin> Right
21:14:21 <syntaxglitch> Yeah, what sproingie just said, heh
21:14:34 <sproingie> you're only screwed if you have one app that indirectly tries to use both
21:14:36 <sproingie> then one of them has to change
21:14:44 <kquick2> How does explicit request work?  Is a cabal file dependency somehow provided to the ghc import?
21:14:52 <sproingie> it just ignores hiding
21:14:54 <aavogt> in other words, whoever uploaded transformers causes everybody a great inconvenience because you should be using transformers and not mtl?
21:15:24 <Saizan> kquick2: Cabal ignores the hiding of ghc-pkg, and hides all packages except the ones listed in build-depends when calling ghc
21:15:32 <sproingie> there's probably a flag.  cabal -v -v build ought to reveal it
21:15:45 <kquick2> Bingo.  Thanks, folks!
21:16:36 <Lemonator> Axman6, just because noobs find something confusing doesn't mean there's something wrong with the language.
21:16:38 <sproingie> transformers may or may not be better, but lot more things use mtl
21:16:42 <Saizan> aavogt: i don't blame the uploader, i blame the packages that depend on it
21:17:06 <Axman6> Lemonator: what i was trying to do was figure out what he wanted to do. it had nothing to do with the language
21:17:22 <sproingie> you'd actually have the same problem in most languages.  just about the only platform that wouldn't have this kind of problem is java+osgi
21:17:56 <sproingie> it's just that haskell loves to reinvent MonadWheel
21:18:28 <aavogt> Saizan: true, users don't really go requesting transformers after all (and if they do, they probably already know how to hide mtl?)
21:18:28 <copumpkin> ArrowLoop
21:18:56 <Saizan> transformers is so similar to mtl that i don't see the point, to use type families perhaps?
21:19:29 <c_wraith> the problem is when you want to use packages that depend on both at the same time
21:20:16 <aavogt> c_wraith: like a package expects to import mtl instance, but it only gets transformers MonadReader instances?
21:20:25 <Saizan> http://hackage.haskell.org/packages/archive/transformers/0.1.4.0/doc/html/Control-Monad-Trans-List.html#t%3AListT <- they haven't even fixed ListT
21:20:51 <c_wraith> aavogt: yep
21:21:40 <copumpkin> Saizan: how do you fix it?
21:23:45 <Saizan> copumpkin: data ListM m a = Nil | Cons a (m (ListM m a)), newtype ListT m a = ListT { runListT :: m (ListM m a) }
21:23:54 <copumpkin> oh, the free monad thing
21:24:07 <Saizan> not quite
21:24:14 <Cale> http://www.reddit.com/r/math/comments/anceh/heres_a_quick_animated_plot_i_made_of_the_number/ -- help my reddit post :)
21:24:29 <Saizan> data Free f a = Var a | Branch (f (Free f a))
21:24:50 <copumpkin> Saizan: ah, fair enough :)
21:25:00 <copumpkin> yeah, silly me
21:27:14 <kquick2> More confusion.  Trying to use control-monad-attempt AttemptT.  An operation lift $ putStrLn "hi" works if transformers is exposed, but if mtl is exposed I get "No instance for (MonadTrans AttemptT) arising from a use of lift".  The cabal file for control-monad-attempt depends on transformers.  So I'm guessing the .hi file for control-monad-attempt indicates that lift is re: transformers, which is why it doesn't associate it with mtl.
21:27:34 <kquick2> Am I correct in this assumption?
21:27:55 <jmillikin> Yes
21:27:57 <Saizan> yeah
21:28:07 <Cale> yeah, that sounds about right. Control.Monad.Attempt must have been built against transformers rather than mtl
21:28:11 <Cale> It's a mess. :/
21:28:13 <Saizan> they are distinct classes with the same name
21:29:13 <kquick2> Yes.  First, this has caused an hour or so of anguish: "lift" is right there and in the docs and why isn't it working!
21:29:15 <kquick2> Argh!
21:30:10 <kquick2> So the discussion just above: if I need to use another module that uses lift from mtl, I'm completely stuck, right?
21:30:57 <c_wraith> unless you want to port one.
21:31:02 <kquick2> Is there any way to specify the package on the import line?
21:31:05 <Saizan> there is a way out, but it's specific to ghc
21:31:13 <nolrai_FG>  so data Foo = Foo {a,b :: Bar} compiles with both a, b having type Bar?
21:31:27 <aavogt> exactly nolrai_FG
21:31:27 <Axman6> yes
21:31:34 <sproingie> isn't this entire package business specific to ghc?
21:31:37 <Cale> It's probably not *too* hard to rebuild something against either mtl or transformers so that everything lines up
21:31:53 <c_wraith> ...  Unless you care what the names a and b actually refer to.  the a and b are actually functions, Foo -> Bar.  >_>
21:32:25 <Cale> sproingie: Cabal is intended to be open and also works with hugs and nhc
21:32:29 <sproingie> well, i guess other haskells are playing along.  not h98 or h2010 afaik
21:32:32 <nolrai_FG> Huh, I would not have expected that. Seems weirdly C like.
21:32:41 <kquick2> In other words, watch for mysterious errors like that, then edit the cabal file to use mtl (or transformers, whichever I decide upon) and rebuild/reinstall.
21:32:45 <roconnor> copumpkin: yes
21:32:49 <Cale> nolrai_FG: Well, what else would it mean?
21:33:10 <Cale> nolrai_FG: Note that you can also do this with type signatures at the top level
21:33:19 <kquick2> But that makes cabal install not very useful.
21:33:39 <sproingie> i guess packaging isn't really language-level anyway
21:33:45 <Cale> or, and :: [Bool] -> Bool
21:34:00 <Saizan> kquick2: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports
21:34:00 <Cale> kquick2: Well, it's still useful when you do that. :)
21:34:19 <sproingie> 'cept for that extension
21:34:37 <Cale> kquick2: You can find the downloaded package among ~/.cabal/packages/, unpack it in place, edit it and then just run cabal install from the directory with the .cabal file in it
21:34:41 <nolrai_FG> Cale: I though the type signature had to be imidately before the definition.
21:34:53 <kquick2> Cale: a bit, but if the package came in as a dependency of another and I have to hand-tweak it then I also have to rinse and repeat for all the deps.
21:35:04 <Axman6> nolrai_FG: no
21:35:08 <Cale> kquick2: true
21:35:08 <sproingie> can also use cabal unpack
21:35:21 <Cale> I don't really understand the purpose of this transformers package.
21:35:33 <sproingie> Cale: keep looking, there's more than meets the eye
21:35:42 * sproingie har har har
21:35:46 <Cale> oh?
21:35:51 <Cale> heh
21:35:59 <Saizan> if you bump the version, then cabal install for the packages that depend on the rebuilt one should use your own custom one at least
21:36:31 <Cale> Heh, unless they specify a maximum version
21:36:32 <kquick2> Saizan: thanks for the link.  Now for an #ifdef ghc  #elsif hugs ...
21:37:39 <kquick2> Can I add a version?  Make transformers-0.1.4.0.1 so that I don't collide with transformers-0.1.4.1 when it appears?
21:37:50 <kquick2> "add a version" meaning another level
21:37:56 <Saizan> yeah, you can
21:39:13 <kquick2> sproingie: I'm more confused than Cale: transformers and mtl seem identical from a doc perspective.  Are they just different implementations or do they fill different niches?
21:39:18 <Saizan> (which solves the maximum version problem too)
21:39:32 <sproingie> i really havent looked at transformers
21:39:45 <sproingie> i was just making a really lame joke :)
21:39:58 <kquick2> OK.  Anyone else know the difference?
21:40:23 <sproingie> possibly mtl folded in any improvements that were in transformers?
21:40:38 <Saizan> in transformers you've only transformers defined, the base monads are defined as FooT Identity
21:40:50 <copumpkin> I thought transformers was trying to use few extensions
21:40:51 <copumpkin> or none
21:41:00 <copumpkin> and mtl was doing all sorts of crazy shit
21:41:08 <Cale> mtl is older
21:41:23 <Saizan> oh, well transformers also doesn't have the classes defined
21:41:34 <Saizan> those are in monads-fd and monads-tf
21:42:05 <Saizan> and mtl is not doing anything crazy, UndecidableInstances is pretty tame
21:43:12 <Saizan> (mind that -fd and -tf also have clashing module names)
21:43:26 <kquick2> So transformers would be the better choice going forward as it's more precise?
21:43:50 <Lemonator> I'm getting linker errors.
21:43:54 <Lemonator> How do I deal with them?
21:43:54 <Cale> Lemonator: --make
21:44:07 <Lemonator> oh
21:44:08 <Lemonator> thanks
21:44:24 <Cale> Lemonator: Most linker errors are the result of not using --make, or not specifying the packages to use.
21:44:37 <Cale> (--make will choose them for you)
21:45:14 <eldragon> if my wife aborts tens of times then how many times have i to fertilize my fucking eggs/balls?
21:45:32 <Cale> eldragon: Wrong channel
21:45:44 <Axman6> @where ops
21:45:45 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
21:45:45 <Saizan> kquick2: i wouldn't think that, it doesn't really fix any of the serious issues with mtl
21:45:49 <Cale> Axman6: ?
21:45:54 <Cale> (I'm an op)
21:46:01 <Axman6> ah, my bad :)
21:46:11 <Axman6> sounded like pretty obvious trolling to me
21:46:31 <Cale> Yeah, usually I try to deal with things using non-technical solutions :)
21:48:08 <Axman6> he;s in #politics, #javascript, and #math, obviously a troll :P
21:48:55 <kquick2> transformers is newer but has the same issues.  What issues? Should I be avoiding transform monads in general?
21:49:12 <copumpkin> kquick2: nah, they can be useful
21:49:34 <Cale> I generally avoid monad transformers except for very specific purposes.
21:49:41 <copumpkin> I want someone to prove that there's a basis of monad transformers that can be composed to achieve any monad definable in haskell
21:49:59 <Cale> I want someone to prove the opposite ;)
21:50:09 <copumpkin> I'd settle for that too :0
21:52:16 <Cale> I rather like state-transformed nondeterminism monads, and variations on those
21:52:25 <Cale> But I never transform IO
21:52:45 <Cale> (especially not with State or Reader)
21:52:49 <copumpkin> hah
21:53:19 <Saizan> kquick2: well, minor things like ListT and the interaction of ContT and StateT which you don't meet very often, then there's a problem with the auto-lifting use of MonadFoo classes, which require O(n^2) instances in the general case
21:53:34 <Cale> ListT is broken and you shouldn't use it
21:53:35 <Saizan> kquick2: though they mostly serve their purpouse
21:53:53 <Cale> (It's not a monad transformer)
21:54:48 <Saizan> i guess there's also the problem that we could have more efficient implementations, even if not with identical semantics
21:55:09 <Cale> I also kind of think that the auto-lifting is evil and contributes to people not understanding how monad transformers work.
21:56:25 <copumpkin> @unmtl StateT (MaybeT (RWST (ReaderT (ContT (ListT IO) a d) b c) x y z) s) t q
21:56:25 <lambdabot> ((((d -> a (ListT IO)) -> a (ListT IO)) -> b c) -> y -> z (Maybe s, y, x)) -> t (q, (((d -> a (ListT IO)) -> a (ListT IO)) -> b c) -> y -> z (Maybe s, y, x))
21:56:32 <Saizan> Cale: yeah, it only makes sense if you're using transformers to program in the small
21:56:37 <copumpkin> I dare you to use that
21:56:48 <Cale> Though sometimes the lifting instances are nontrivial, so it's a bit of a pain to write them manually.
21:56:56 <holmak> lambdabot, wash out your mouth with soap!
21:57:44 <holmak> Has anyone ever used more than two monads/monad trandformers at once?
21:58:04 <Axman6> monad transformer transformer?
21:58:08 * Saizan did several times
21:58:17 <holmak> like, MaybeT StateT IO
21:58:25 <holmak> but correctly spelled
21:58:30 <copumpkin> @unmtl OptimusT (StateT (MaybeT (RWST (ReaderT (ContT (ListT IO) a d) b c) x y z) s) t q) e
21:58:31 <lambdabot> OptimusT (((((d -> a (ListT IO)) -> a (ListT IO)) -> b c) -> y -> z (Maybe s, y, x)) -> t (q, (((d -> a (ListT IO)) -> a (ListT IO)) -> b c) -> y -> z (Maybe s, y, x))) e
21:58:50 <gwern> holmak: I think xmonad uses 3 monads
21:58:51 <holmak> I'm curious what the use case is for a multiple-transformer type
21:59:02 <holmak> gwern: Somehow that does not surprise me at all.
21:59:07 <Cale> gwern: 3 monads or 3 transformers?
21:59:13 <gwern> a stack of 3
21:59:25 <gwern> but it's been a while since I looked
21:59:53 <Cale> newtype X a = X (ReaderT XConf (StateT XState IO) a)
22:00:15 <Saizan> holmak: i actually used that exact type to hold around an heap while i was making IO-involving tests, that propagated their failure via the MaybeT
22:00:35 <Cale> weird, it's a newtype, but haddock documents it as data
22:00:40 <Saizan> s/hold/thread/
22:00:44 <Cale> That's bad.
22:00:52 <copumpkin> Cale: maybe it only recently turned to data and haddock hasn't updated?
22:01:06 <copumpkin> or ratjer
22:01:10 <copumpkin> to newtype
22:01:12 <Cale> copumpkin: Well, I'm looking at the source which is linked from the data
22:01:17 <Cale> er, from the documentation
22:01:20 <copumpkin> oh
22:01:41 <Cale> data X a 	Source  -- click the link --> newtype X a = X (ReaderT XConf (StateT XState IO) a)
22:02:11 <Saizan> maybe haddock hided that detail because the constructor is not exposed?
22:02:39 <holmak> Having just learned how to use monad transformers, I think they are very neat. However, I have to stare at them for a while to make sure I know what is going on.
22:02:39 <Cale> I guess it doesn't matter so much when there's no constructor anyway
22:03:04 <gwern> Cale: I guess that's only 2 monads then, if newtype is a wrapper
22:03:13 <Cale> gwern: 2 monad transformers
22:03:21 <kmc> man up and write your own monad
22:03:30 <kmc> that does everything
22:03:34 <gwern> Cale: what are readert and state transforming?
22:04:20 <Saizan> holmak: there's a bit of that at the start, but the rule of thumb is that effects of the transformers nearer to the base take precedence over the others
22:04:23 <Cale> The IO monad is transformed into (StateT XState IO) which is transformed into (ReaderT XConf (StateT XState IO) a)
22:04:32 <Cale> er
22:04:45 <Cale> (ReaderT XConf (StateT XState IO)), rather
22:05:58 <holmak> Saizan: What are your thoughts on code that uses a type like that? I'm sure it gets the job done, but does is it possible for an outsider to understand?
22:06:46 <Cale> holmak: It's very important to newtype these things and hide the fact that you're using transformers by a module boundary
22:07:29 <copumpkin> yeah, at our age using transformers might be considered inappropriate or even creepy
22:07:32 <Saizan> holmak: the trick is to define custom combinators with sensible names for what the transformers operation actually mean in your code
22:07:34 <Cale> holmak: Typically you write all the operations that you really want, and export versions of them which work in your newtyped monad, and the rest of the program can't tell that you used monad transformers and lifting etc.
22:07:34 <copumpkin> so you must hide it
22:07:54 <Cale> copumpkin: hehe
22:09:19 <holmak> I see, so use transformers to build your new type, but don't expect people to manipulate the newtype with generic monad functions. Interesting!
22:09:36 <Cale> holmak: Well, it's also important for maintenance
22:09:41 <Saizan> well, i'd usually expose the internals of the monad too, it's pretty useful if you've to lift monadic HOFs through it later
22:09:58 <Saizan> holmak: generic Monad functions are fine
22:10:08 <Cale> If you decide to change the type later, it constrains the amount of code you have to rewrite the lifts in to that one module.
22:10:50 <holmak> I just like to think of the power/approachability tradeoff when I write code. Even if people rarely read my code.
22:11:22 <Saizan> holmak: but e.g. instead of "fmap (M.lookup k) get", write your own readVar to apply to k to get the same effect and less obscure code
22:11:24 <Athas> What's the best way to write a Parsec parser that parses "everything but whitespace"?
22:12:16 <gwern> the mtls in my pocket I must protect them; My ergonomic keyboard never leaves me bored...
22:12:18 <Saizan> does parsec have a satisfy combinator?
22:12:35 <Athas> Oh yes, looks like it does.
22:12:54 <Cale> satisfy (not . isSpace)
22:13:59 <Saizan> holmak: functions that just use the Monad class are more widely recognized as just control flow constructs
22:14:09 <Saizan> (and used)
22:14:49 <Cale> Though, you can write significant algorithms as higher order functions and generalise them over the monad
22:15:04 <Cale> It's slightly uncommon
22:15:54 <Cale> in my astar library, I have a version of an A* search which works in an arbitrary monad
22:15:56 <blackdog> gah. i just managed to burn half a day arguing with someone i don't know who's getting excited about a dymanically scoped lisp.
22:16:13 <Cale> blackdog: haha
22:16:15 <Saizan> Cale: which is just a monadified version of a pure function?
22:16:19 <Cale> Saizan: yeah
22:16:48 <blackdog> Cale: "It uses dynamic scope, so it's really really fast!" he says, and my brain begins to melt...
22:17:32 <Cale> blackdog: Which lisp? elisp?
22:17:33 <Saizan> today i discovered that in python funs = [lambda: x for x in xrange(10)]; x = 20; print funs[0](); prints 20, i still have to recover
22:17:47 <blackdog> Cale: no, it's called newlisp
22:17:58 <blackdog> http://www.taoeffect.com/blog/2010/01/how-newlisp-took-my-breath-and-syntax-away/comment-page-1/#comment-659
22:18:02 <ivanm> blackdog: oh, it's rather old IIRC...
22:18:03 <ivanm> ;-)
22:18:09 <Cale> Saizan: yeah, lambda in python is broken
22:18:22 <blackdog> ivanm: an ever-present danger in naming:)
22:18:43 <Saizan> Cale: and list comprehensions don't have their own scope either.
22:18:45 <Cale> Saizan: Probably because Guido doesn't understand anything about functional programming.
22:19:36 <Cale> (or else his comments are carefully worded so as not to reveal any comprehension)
22:19:42 <sproingie> not understanding is one thing.  the rise of a culture actively hostile to it is another
22:20:07 <blackdog> sproingie: i can understand the motivation in trying to keep a language focused
22:21:30 <sproingie> personally i don't call python's lambda syntax broken.  allowing only one expression is in fact very functional
22:22:11 <sproingie> tho i'd say that's by accident
22:23:32 <Berengal> At least it _has_ lambdas...
22:23:50 <Berengal> And you can always implements semicolons yourself ;)
22:23:51 <sproingie> things like refusing to fix the lock contention problems with the GIL
22:24:13 <Saizan> one expression was fine for me, it's really how closures and scopes work which disturbs me, i.e. [(lambda x: lambda: x)(x) for x in xrange(10)] is a completely different thing
22:24:26 <Saizan> beta reduction!
22:24:26 <sproingie> the existence of the damn GIL is not so great, that the GIL itself is stupidly broken is worse
22:24:39 <Berengal> for x in foo: pass; print x # prints last x
22:25:10 <Saizan> however, we're all off topic :)
22:25:19 <mauke_> looks like list comprehensions translate to stores and jumps
22:25:22 <sproingie> Berengal: it's pretty consistent in that only def introduces new scope
22:25:23 <mauke_> literally
22:25:36 <copumpkin> Cale: he's doing it on purpose to piss off the FP people
22:25:43 <copumpkin> but is a closet pure functional programmer himself
22:26:11 <mauke_> http://twitter.com/gvanrossum/status/1838308947
22:27:04 <blackdog> mauke_: classic:)
22:27:22 <blackdog> if only it were "the little schemer"
22:27:32 <Berengal> Another thing that's broke my mind in python is that closures close over _variables_, not values. funcs = []; for x in range(10): funcs.append(lambda : print(x)); for f in funcs: f() # prints only 9s
22:27:50 <mauke_> Berengal: er, that's normal
22:27:53 <Berengal> But I understand this is a problem in other languages as well
22:28:02 <mauke_> that's a feature, not a bug
22:28:15 <Berengal> mauke_: I know it's supposed to be, but I think it's mislabeling
22:28:31 <Berengal> I actually think Java did this right, by only closing over final variables
22:28:56 <Saizan> i'd consider it a feature if there were a way to dereference the actual value and close over that, if you want
22:29:34 <mauke_> Berengal: ew
22:29:46 <mauke_> Saizan: yes, this is called "scoping"
22:29:55 <mauke_> and it's where python totally fails
22:30:23 <dolio> for x in range(1): funcs.append ((lambda y: lambda: print(y))(x))?
22:30:45 <Saizan> dolio: you've to do that, yeah
22:30:48 <Saizan> or!
22:30:49 <dolio> range(10), even.
22:30:51 <sproingie> i would totally expect it to print only 9's.  x is a variable.  mentally replace "x" with "readIORef x"
22:30:59 <Saizan> lambda y=x: print y
22:31:10 <dolio> That works?
22:31:18 <dolio> Yeah, I guess that makes sense.
22:31:36 <Saizan> yes, it's defining x as default value for y, and evaluating that when the lambda is created
22:31:40 <mauke_> Berengal: huhu, you might "enjoy" ploki
22:31:53 <Berengal> mauke_: What's that?
22:32:11 <dolio> This all just goes to show that implicit mutability is confusing. :)
22:32:18 <Saizan> sproingie: except that i can't do v <- readIORef x; return (lambda: return v), i can only lambda: readIORef x
22:32:26 <mauke_> a language I ... uh... "designed"
22:33:29 <mauke_> Berengal: general syntax from basic, control flow structures from asm, expressions inspired by perl
22:33:45 <Berengal> mauke_: Does it have proper closures ;)
22:33:47 <sproingie> Saizan: well that's when you do the define-time trick
22:33:59 <mauke_> and for some reason several of its misfeatures helped me understand aspects of C and functional programming
22:34:09 <mauke_> Berengal: it has no local variables
22:35:08 <dolio> Anyhow, both the python and java solutions are kind of limiting.
22:35:27 <mauke_> see http://mauke.ath.cx/tmp/ploki-0.6.4/ or http://mauke.ath.cx/tmp/ploki-0.6.4.tar.bz2
22:35:51 <mauke_> ploki has no block structure or anything, but it has the concept of "calls"
22:35:55 <dolio> One-expression is functional, but not everything in python is an expression, so even Haskell is more generous on that front, since you can write monadic anonymous functions.
22:36:01 <mauke_> a call is like a jump, but it remembers where it came from
22:36:11 <sproingie> WUNT?
22:36:29 <sproingie> LEET?
22:36:36 <copumpkin> a jump is like a call, but is forgetful
22:36:39 <dolio> And closing over only final variables is much like Haskell, except references are first-class, so you can technically close over mutable variables, too.
22:36:40 <mauke_> it has no local variables, but 'LEET' is a variant of 'LET' that saves the previous value of the variable
22:37:00 <sproingie> ah it's got lolcode
22:37:07 <mauke_> so the next return statement will restore the previous value of those vars
22:37:07 <sproingie> http://mauke.ath.cx/tmp/ploki-0.6.4/examples/facul.pk
22:37:17 <mauke_> this precedes lolcode by years
22:37:25 <SamB_XP_> a jump is like a tailcall except you can't pass arguments :-(
22:37:38 <dolio> Which I suppose you can technically do in Java, as well, by making an object that contains a single field, but that's extra indirection.
22:37:45 <mauke_> so it turns out I reinvented dynamic scoping by letting you temporarily alter global variables
22:38:11 <sproingie> do they revert when you leave the scope?
22:38:29 <mauke_> there is no scope
22:38:33 <sproingie> MOO has a few magic variables like that
22:38:33 <SamB_XP_> Python does have lexical scope
22:38:38 <sproingie> 'player' for example
22:38:53 <mauke_> sproingie: KTHX is the return instruction; it restores variables saved by LEET
22:39:25 <dolio> mauke_: So LET is just assignment?
22:39:32 <mauke_> dolio: yes
22:39:55 <Athas> What's community opinion of Parsec's TokenParser stuff?
22:40:00 <sproingie> you could add scope delimiters with OHAI/BAI
22:40:22 <mauke_> sproingie: no, the entire point of ploki is that it has no structure, only instructions
22:40:30 <sproingie> ah.  kinda like forth
22:40:49 <sproingie> except i guess forth has :;
22:41:06 <SamB_XP_> only, doesn't forth let you have structure-giving WORDs?
22:41:15 <mauke_> @OMFG is technically a unary operator
22:41:15 <lambdabot> Unknown command, try @list
22:41:16 <sproingie> forth has all kinds of weird words
22:41:40 <mauke_> but instead of evaluating its operand, @OMFG returns a point to the code itself
22:41:43 <mauke_> er, pointer
22:41:55 <mauke_> so this is a bit like function pointers/closures
22:41:57 <sproingie> parsing words that read ahead arbitrarily then come back and execute the same words
22:42:00 <Berengal> Sounds delicious
22:42:10 <SamB_XP_> sproingie: yeah, exactly
22:42:29 <sproingie> words with different compile-time and run-time behaviors
22:42:34 <SamB_XP_> " is a funny word
22:42:49 <mauke_> here's the funny bit: before returning its operand, @OMFG goes over the expression and replaces all variables by their current values
22:43:21 <SamB_XP_> reminds me of , somehow ...
22:43:27 <SamB_XP_> or, uh, `
22:43:33 <sproingie> quasiquote
22:43:45 <mauke_> LET x 2; LET y @OMFG x; LET x "zounds"
22:44:03 <mauke_> now y contains an expression that (when evaluated) yields 2
22:46:14 <mauke_> LET f @OMFG @some-user-defined-function #< x \@ #>
22:46:17 <mauke_> REM that was a closure
22:53:55 <mauke_> ooh. bonus points if you can figure out which haskell functions 'map' and 'grep' from http://mauke.ath.cx/tmp/ploki-0.6.4/examples/perl-util.pk correspond to
23:12:20 <Athas> Does anyone here have experience using Parsec's buildExpressionParser?  I can't figure out how to make it work by longest match rules, as it seems to prefer to match operators, even when another, longer lexeme is possible.
23:12:20 <bob0> Athas: no
23:24:59 <DekuNut> I'm trying to understand some of the theory behind haskell, but it's all quite new to me so, I'm just looking for a few hints at these
23:25:24 <DekuNut> I've been reading about catagory theory, and have a rough understanding of what objects, morphisms and functors are
23:26:08 <DekuNut> I read that, Monads are basically a functor that links catagories together
23:26:12 <ivanm> objects? what objects?
23:26:25 <ivanm> hint: you don't need to understand category theory to use haskell ;-)
23:26:42 <DekuNut> Yeah I know rofl, I'm trying to learn anyway, just thought someone could give me a few hints as to what
23:26:45 <kmc> objects correspond to the types of haskell
23:26:49 <Jafet> It's necessary at some PoinT
23:26:50 <DekuNut> Exactly in haskell relates, as I figured
23:26:56 <kmc> not to the values
23:27:10 <kmc> functions (not function types) are morphisms
23:27:56 <kmc> i think of a category as a "typed monoid"
23:28:01 <kmc> in a monoid you can compose any two objects
23:28:03 <DekuNut> Well I haven't seen monoids yet
23:28:07 <kmc> err "elements" let's say
23:28:17 <kmc> DekuNut, monoids are simpler than all of this
23:28:31 <kmc> they are just a set with an associative binary operator, and an identity for that operator
23:28:48 <dolio> Think of it like an asymmetric groupoid, then. :)
23:29:06 <DekuNut> Ah, so just one operator for converting back and forth between two types?
23:29:11 <kmc> a monoid?
23:29:14 <kmc> no, it's entirely one type
23:29:18 <kmc> @src Monoid
23:29:19 <lambdabot> class Monoid a where
23:29:19 <lambdabot>     mempty  :: a
23:29:19 <lambdabot>     mappend :: a -> a -> a
23:29:19 <lambdabot>     mconcat :: [a] -> a
23:29:30 <DekuNut> Oh ok, fair enough
23:29:35 <kmc> so e.g.:  instance Monoid [a] where { mempty = []; mappend = (++) }
23:29:44 <kmc> examples of monoids include: numbers (with 0 and plus, *or* with 1 and times), or lists with [] and ++, etc.
23:30:14 <DekuNut> Right ok, I think I'm with you then
23:30:36 <kmc> let's call the monoid binary operation "compose"
23:31:00 <kmc> then a category is like a monoid, but each element has a "type signature" of the form A -> B
23:31:14 <kmc> and you can only compose two elements if the types match up
23:31:35 <kmc> so you can compose an element of "type signature" (B -> C) with one of (A -> B)
23:31:53 <DekuNut> Just to check I'm with you so far
23:31:56 <Cale> DekuNut: A really good book for learning about categories is this one:
23:31:59 <Cale> @where awodey
23:31:59 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
23:32:18 <DekuNut> No wait, sorry, go on kmc
23:32:26 <DekuNut> Thanks Cale, I'll download it
23:32:26 <kmc> instead of a single identity element, you have one for every signature of the form A -> A
23:32:48 <kmc> it needn't be the only element with that type signature
23:32:54 <kmc> but it will always exist
23:33:17 <dolio> Note that a monoid is a category with a single object.
23:33:24 <dolio> Because then the only possible type signature is A -> A.
23:33:27 <DekuNut> Wait, you lost me a little bit there, kmc did you just switch from describing catagories to mondas?
23:33:29 <DekuNut> monads*
23:33:30 <kmc> no
23:33:31 <dolio> So you can compose every arrow with every other arrow.
23:33:36 <kmc> i haven't said anything about functors or monads yet
23:33:56 <kmc> i'm describing a category.  each element ("morphisms") of a category has a "type signature" of the form A -> B
23:34:16 <DekuNut> Oh right sorry, I misread you, I think I'm with you now yeah
23:34:40 <kmc> the binary operation "compose" is defined iff the types match up, in the usual manner of function composition
23:34:58 <kmc> and you have an identity element for any signature like A -> A
23:35:19 <kmc> as dolio said, if you have only one type, then the only possible signature is A -> A, so any two elements can be composed, so you're back to a monoid
23:35:48 <kmc> now this is sort of backwards -- people prefer to define a category and then define a monoid as a category with one type.  but i like this direction because, well, monoids are simple, and types i already understand from Haskell
23:35:58 <DekuNut> Nah, I like this direction as
23:36:07 <DekuNut> It fits perfectly as to what I'm imagining with this: http://en.wikibooks.org/wiki/File:Simple-cat.png
23:36:19 <dolio> Well, people like that direction when they're doing some sort of categorical foundation.
23:36:32 <Lemonator> so I create an infinite list of random numbers in main,
23:36:39 <dolio> Kind of like how you can define a set as a category with only identity morphisms.
23:36:43 <Lemonator> and pass it to an otherwise pure function.
23:37:06 <Lemonator> Thing is, the function makes multiple calls to itself, each time passing the list.
23:37:41 <Lemonator> Thus, taking the head of the list will yield the same random number for these parallel calls.
23:38:09 <Lemonator> Is there any way to avoid that without having to introduce state into this function?
23:38:45 <gwern> why not get multiple seeds and makes lists based on each seed?
23:39:21 * gwern is unsure the split stuff would work in that situation
23:39:32 <DekuNut> kmc, I think I'm misunderstanding something then. If I imagine instanced of the monoid typeclass (except A->B instead of just A->A), then functors would be transformations between instances correct?
23:39:40 <Lemonator> hm.
23:40:08 <kmc> DekuNut, it's not a matter of substituting A->B for A->A
23:40:41 <kmc> i'm saying that each 'a' of (Monoid a) gets its *own* type of the form A->B
23:41:02 <kmc> let's write it with ~> to avoid confusing with ordinary Haskell functions
23:41:30 <kmc> then:  identity :: forall a. (a ~> a)
23:41:42 <gwern> Lemonator: incidentally, what stops you from doing something like 'foo a:as = stuff : foo as'? where a:as is your random list
23:41:48 <kmc> and: compose :: forall a b c. (b ~> c) -> (a ~> b) -> (a ~> c)
23:42:10 * gwern assumes your list is coming from 'randoms'
23:42:16 <Jafet> That only works well with CPS
23:42:34 <kmc> class Category (~>) where { identity :: forall a. (a ~> a); compose :: forall a b c. (b ~> c) -> (a ~> b) -> (a ~> c) }
23:43:06 <Lemonator> foo (r : rs) = foo rs ??? foo rs ??? foo rs
23:43:08 <DekuNut> Yeah, I've lost you kmc, sorry
23:43:14 <Lemonator> where ??? does stuff.
23:43:17 <kmc> an instance of Category has kind * -> * -> *, whereas an instance of Monoid has kind *
23:43:24 <gwern> Lemonator: a fixed number of foos?
23:43:27 <kmc> DekuNut, where exactly?
23:43:37 <Lemonator> gwern, in each call, yes.
23:43:44 <Lemonator> I think I need some sort of random TREE.
23:43:54 <DekuNut> I'm not so sure anymore, as I thought I was with you when you were first describing a category (which I thought I already understood)
23:44:02 <DekuNut> I guess, as soon as you said it gets it's own type, I was gone
23:44:06 <Lemonator> like, each node is a random number,
23:44:07 <kmc> class Category k where { identity :: forall a. (k a a); compose :: forall a b c. (k b c) -> (k a b) -> (k a c) } -- without the infix notation
23:44:15 <kmc> ah well i'm drunk so maybe i've mixed something up
23:44:19 <gwern> Lemonator: ok, so you could use splitting then
23:44:27 <DekuNut> Rofl, ace
23:44:38 <DekuNut> Also kmc, that looks more familiar
23:44:39 <kmc> :D
23:44:39 <Lemonator> and each recursive call can enter a different branch of the tree and not have to do with each other.
23:44:53 <Lemonator> gwern, how would I split an infinite list, though?
23:44:55 <DekuNut> Though I'm still a little lost as to where this comes into categories
23:45:04 <kmc> well, i've defined what a category is
23:45:05 <Lemonator> oh wait
23:45:05 <gwern> Lemonator: don't create it; keep the generator
23:45:11 <kmc> using Haskell as our metalanguage for describing mathematical structures
23:45:13 <Lemonator> just take every other element.
23:45:28 <Lemonator> first call takes 0, 3, 6, 9, ...
23:45:41 <Lemonator> second call takes 1, 4, 7, 10, ...
23:45:56 <Lemonator> third call takes 2, 5, 8, 11, ...
23:46:02 <DekuNut> Yeah, I understand what a category is, I'm just a little lost as to how monads can be functors, or (assuming the Functor typeclass is a functor), how the functor typeclass acts as a transformation between categories
23:46:03 <gwern> foo stdgen = let (r,r') = split stdgen in let (s,s') = split r' in let (t,t') = split s' in [foo r, foo s, foo t]
23:46:12 <gwern> ^ see what I mean by splits?
23:46:14 <Lemonator> that should preserve mutual randomness, right?
23:46:22 <kmc> DekuNut, so the standard Functor class does not express all functors
23:46:28 <kmc> it only expresses endofunctors in Hask
23:46:32 <Lemonator> :t split
23:46:34 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
23:46:36 <gwern> Lemonator: mm. I'm not sure actually
23:46:42 <gwern> Lemonator:  http://www.haskell.org/ghc/docs/6.10.4/html/libraries/random/System-Random.html#v%3Asplit
23:46:48 <gwern> The split operation allows one to obtain two distinct random number generators. This is very useful in functional programs (for example, when passing a random number generator down to recursive calls), but very little work has been done on statistically robust implementations of split ([System.Random, System.Random] are the only examples we know of).
23:46:55 <kmc> a functor maps one category to another; an instance of the Prelude Functor must map the category Hask to itself
23:47:20 <Lemonator> I'll trust the GHC.
23:47:27 <kmc> because fmap :: (Functor f) => (a -> b) -> (f a -> f b)
23:47:44 <kmc> note that (->) is used on both sides, meaning that our morphisms are Haskell functions, i.e. the morphisms in the category Hask
23:47:50 <kmc> a more general fmap might have type like:
23:48:23 <kmc> fmap' :: (Functor' f (~>) (~~>)) => (a ~> b) -> (f a ~~> f b)
23:49:07 <kmc> i bet you can find that somewhere in category-extras
23:49:27 <gwern> Lemonator: I think you could decompose the list like that; it may be more elegant than splitting, although that's a bit simpler to write
23:49:27 <DekuNut> Give me two seconds to relook at the Functor typeclass, I think it might enlighten me
23:49:46 <gwern> and scales - you have to rewrite your list splitting every time you add a new foo
23:50:05 <kmc> class (Category r, Category t) => PFunctor p r t | p r -> t, p t -> r where { first :: r a b -> t (p a c) (p b c) }
23:50:41 <Lemonator> gwern, by adding a new foo, you mean like making four or five calls instead of three?
23:50:51 <dolio> Even all this doesn't quite capture categories, because they should be able to have different object collections.
23:50:54 <DekuNut> kmc, my brain melts looking at that, I'm not that familiar with haskell yet but, just a second, tell me if
23:50:56 <DekuNut> This sounds about right
23:51:14 <gwern> Lemonator: yeah - if you add a fifth foo then then isn't '3, 6, 9' already taken?
23:51:23 <sproingie> it's hardly the most intuitive looking type class
23:52:05 <Lemonator> same problem with split: I'd have to write two more splits to accommodate five calls.
23:52:06 <DekuNut> Functors in haskell map one category to another right (at least, if I read you right before), and in haskell they map to back to the same category
23:52:12 <gwern> Lemonator: so you'd have to rewrite all 4 others to squeeze the fifth one in with no overlaps, or maybe halve one of them. with splitting, you could just do another s[plit. and it looks to me like splitting is quite refacortable
23:52:18 <kmc> DekuNut, yes
23:52:20 <DekuNut> So in here: map :: (a -> b) -> [a] -> [b]
23:52:23 <gwern> with iterate or some other HOF
23:52:25 <DekuNut> The category is the [] instance?
23:52:28 <Lemonator> hm.
23:52:30 <kmc> the category is (->)
23:52:35 <kmc> the functor is []
23:52:38 <gwern> :t iterate
23:52:39 <lambdabot> forall a. (a -> a) -> a -> [a]
23:52:52 <gwern> > iterate id x
23:52:54 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
23:52:54 <DekuNut> kmc, but that just seems like, ALL categories in haskell are just (->)
23:53:02 <kmc> DekuNut, you can build ones that aren't
23:53:04 <gwern> > iterate (+y) x
23:53:05 <lambdabot>   [x,x + y,x + y + y,x + y + y + y,x + y + y + y + y,x + y + y + y + y + y,x ...
23:53:07 <kmc> if you build a 2-ary type constructor
23:53:13 <kmc> and equip it with identity and composition
23:53:17 <DekuNut> Then what are the objects of the (->) category for example?
23:53:18 <gwern> hm. maybe a fold then
23:53:25 <kmc> the objects are Haskell types
23:53:26 <DekuNut> And the morphisms of it?
23:53:31 <kmc> the morphisms are Haskell functions
23:53:54 <kmc> you are pretty much stuck with "objects = Haskell types"
23:54:03 <sproingie> moar fizzims
23:54:07 <gwern> :t foo x = let (y,y') = split x in y : foo y'
23:54:08 <kmc> but you can create other categories where the morphisms are represented by something other than functions
23:54:08 <lambdabot> parse error on input `='
23:54:36 <gwern> :t let split a = (a,a) in let (y,y') = split x in y : foo y'
23:54:38 <lambdabot> Not in scope: `foo'
23:54:44 <kmc> data Trivial a b = Trivial; instance Category Trivial where { id = Trivial, _ . _ = Trivial }
23:54:45 <gwern> argh
23:54:53 <kmc> there's a category where the morphisms are not functions
23:55:11 <gwern> Lemonator: well, you see what I mean about refacortable. not hard to make a [stdgen] where each entry is generated from the previous entry via splitting
23:55:21 <DekuNut> In that example then, what are the morphisms, objects and what exactly IS the category there
23:55:28 <Lemonator> k, I shall use splitting.
23:55:31 <gwern> Lemonator: then you map/zip it with you [foo, foo, foo ...]
23:55:31 <kmc> the objects are still Haskell types
23:55:32 <DekuNut> I think if I can see the similarities between that and (->), it will make sense
23:55:37 <kmc> the things you fill in for 'a' and 'b'
23:56:04 <kmc> but this category has only one morphism for any a and b
23:56:25 <kmc> and so composition is trivial
23:56:34 <kmc> whereas there are of course many different Haskell functions for a given type signature (A -> B)
23:56:45 <DekuNut> Wait wait, the morphisms ther are id and  _ . _ ?
23:56:49 <kmc> no
23:57:05 <kmc> the morphisms in my Trivial category are the values of type (Trivial a b) for some a,b
23:57:15 <kmc> just as the morphisms in Hask are the values of type (a -> b)
23:57:20 <kmc> which is just ((->) a b) written infix
23:57:20 <DekuNut> But you just said a and b were objects
23:57:24 <kmc> they are
23:57:36 <kmc> every morphism has a "type signature" consisting of two objects
23:57:54 <kmc> "type" is a less confusing term than "object", imo
23:58:00 <kmc> because "object" means many other things in CS
23:58:15 <kmc> the similarities between (->) and Trivial are thus:
23:58:23 <kmc> - both are type constructors taking two type parameters
23:58:49 <Saizan> does parametricity really imply naturality if we've gadts?
23:58:53 <kmc> - both have associative composition, with identities
23:59:46 <kmc> you may be confused because i reused the names id and (.) for the general category identity and composition
23:59:53 <kmc> in the Prelude these are defined for (->) specifically
23:59:57 <kmc> in category-extras they are generalized
