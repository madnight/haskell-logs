00:00:14 <merehap> ugh, darcs push is giving me pain, has anyone else dealt with this error message?:
00:00:18 <theorbtwo> mauke: Er, a string isn't a list of integers in Haskell or Perl; in perl it's just a string, which is a primitive in it's own right; in Haskell it's a list of enumerations.
00:00:18 <merehap> darcs failed:  Couldn't write `0000003931-950067a323f7a924e38a938bc32623a4ccbc40c9ea7f917c06b560008ab6b098'
00:00:22 <merehap> in subdir inventories to sources:
00:00:51 <solrize> lispy|web, looks like the logs are there
00:00:59 <merehap> google hasn't been terribly helpful...
00:03:48 <merehap> ok, in that case I guess it's time to move to git...
00:05:10 <solrize> is this about patch-tag?  it's still down?
00:05:43 <merehap> wait, patch-tag is down?
00:05:54 <solrize> it was down earlier, i thought that's what you were talking about
00:06:12 <merehap> guess that could be it, though a decent amount of the site is up, maybe not their repos though...
00:06:32 <solrize> well why were you describing switching to git?  oh, i see, darcs prob
00:06:32 <merehap> I tried it yesterday as well with no luck
00:06:46 <solrize> that looks like a hash of the thing you were committing, so it wouldn't be in gooble
00:07:10 <solrize> i suppose ask on #darcs ?
00:07:14 <merehap> there is a few google entries when that is taken out, but it is just a file in the inventories folder
00:07:24 <merehap> oh, didn't know about #darcs
00:07:31 <merehap> thanks
00:09:33 --- mode: quicksilver set -b *!*=alexsura@*.aubnin.fios.verizon.net
00:11:41 <ivanm> solrize: "gooble"? :p
00:12:22 <Peaker> I find a bunch of duplicated zipper lists-with-cursor.  Anything in the stdlib?
00:12:40 <merehap> yes
00:12:47 <merehap> oops, wrong screen
00:13:00 <Peaker> ah, ListZipper
00:13:09 <Peaker> (xmonad has its own, as well as the new monad reader article)
00:13:42 <dolio> I don't think there's anything in what I'd call the standard library.
00:13:49 <Peaker> ListZipper is strict...
00:13:54 <Peaker> well, cabalized :)
00:14:05 <dolio> Oh, well, we have a big standard library, then. :)
00:14:13 <Peaker> indeed :)
00:14:31 <dolio> There are probably 10 in the standard library.
00:14:35 <Peaker> I think xmonad and the monad reader use lazy zip lists, and ListZipper is strict-field'd
00:15:00 <joevandyk> if i want to pattern match for a type that's been constructed with a specific constructor, do I have to specify all the arguments to the constructor when defining the function?
00:15:15 <Peaker> joevandyk: no, you can use the syntax: blah SomeConstructor {} = ...
00:15:34 <Peaker> oops, missing ()
00:15:50 <Peaker> joevandyk: or if you want just field x into a variable y, you can have:  blah (SomeConstructor {x = y}) = ... {- Very weird, because the lhs/rhs are reversed from normal use! -}
00:16:01 <ivanm> you don't need () around SomeConstructor{}
00:16:04 <Peaker> at least, iirc
00:16:07 <Peaker> oh, ok
00:16:31 <ivanm> and there's extensions which mean you can just use the field name for the variable IIRC
00:18:04 <joevandyk> if I want to use Data.Maybe.isNothing, I have to import it?
00:18:16 <joevandyk> but I don't if I want to use Nothing and Just ?
00:18:22 <ivanm> yes
00:18:32 <ivanm> because the Prelude re-exports the Maybe type and the maybe function
00:18:35 <joevandyk> ahh
00:18:36 <joevandyk> ok
00:18:37 <ivanm> but not isJust, isNothing and fromMaybe
00:18:41 <ivanm> (and fromJust)
00:22:19 <quicksilver> joevandyk: interestingly, there is almost always a better way than using isNothing
00:22:27 <quicksilver> that's probably why it's not exported by default.
00:22:37 <quicksilver> (not always, but almost always)
00:22:38 <joevandyk> quicksilver: i imagine so, i'm just writing absolutely useless programs
00:23:28 <joevandyk> quicksilver: i.e. http://gist.github.com/286666
00:23:45 <ivanm> I quite like maybe and fromMaybe
00:24:02 <ivanm> I have used fromJust once when I did an if statement using isJust
00:24:09 <quicksilver> joevandyk: yes, that's a reasonable use.
00:24:12 <joevandyk> i'm surprised i'm not hearing more people talking about using thrift and haskell
00:24:16 <quicksilver> joevandyk: basically when you really want a Bool
00:24:20 <quicksilver> ivanm: BZZZT
00:24:27 <ivanm> that was before I knew about fromMaybe though, so I should probably rewrite it
00:24:35 <quicksilver> ivanm: (if + fromJust) ~~> case
00:24:39 <quicksilver> (or maybe or fromMaybe)
00:24:44 <ivanm> yeah
00:24:56 <ivanm> quicksilver: this was when I was writing my first substantial piece of Haskell code
00:25:02 <ivanm> and I hadn't done much IO before that
00:26:19 <Saizan> thrift?
00:28:45 <joevandyk> Saizan: thrift!
00:29:10 <ivanm> I think Saizan was querying what thrift _was_
00:29:21 <Saizan> yeah :)
00:29:23 <ivanm> rather than seeking verification that you were indeed referring to thrift
00:29:36 <joevandyk> haha
00:29:37 <joevandyk> http://incubator.apache.org/thrift/
00:29:57 <quicksilver> facebookware
00:29:59 <ivanm> never heard of it before
00:30:11 <ivanm> and by looking on that page, I have nfi what it actually does
00:30:13 <joevandyk> a IDL / RPC framework.  lets you sneak haskell into a larger system that uses java, c++, ruby, whatever
00:30:25 <ivanm> OK, looks liek it does limited code generation
00:30:26 <quicksilver> it's like IDL done right, or CORBA done right
00:30:40 * ivanm hasn't heard of IDL or CORBA before, so those comparisons don't help
00:30:43 <quicksilver> mind you I'm not sure how it distinguishes itself from the other 12 projects of the last 10 years which were also IDL done right.
00:31:01 <quicksilver> a bit righter?
00:31:01 <joevandyk> ivanm: IDL = interface definition language
00:31:19 <Peaker> quicksilver: about the (exists a. (IO a, IO (a -> a))) example -- luqui responded on Reddit, indeed that's just (IO (), IO ()) (no observations on a)
00:31:44 <Peaker> quicksilver: and if you have (IO a, a -> IO a) then it seems to be equivalent to Mu IO ()
00:32:34 <Peaker> I'm reading about the Prompt monad in the Monad Reader, and it seems to be a more complicated way to define a specialized monad with its own type-class for special operations :-(
00:33:25 <joevandyk> Thrift is a lightweight, language-independent software stack with an associated code generation mechanism for RPC. Thrift provides clean abstractions for data transport, data serialization, and application level processing. The code generation system takes a simple definition language as its input and generates code across programming languages that uses the abstracted stack to build interoperable RPC clients and servers.
00:33:33 <joevandyk> i just wrote that off the top of my head
00:33:42 <joevandyk> :d
00:33:48 <joevandyk> :p
00:34:12 <joevandyk> anyways, it looks like an excellent way to sneak haskell into an existing large software system
00:34:33 <joevandyk> i'm writing a blog post about how to use a rails frontend to integrate into a haskell backend
00:35:13 <Alpounet> nice
00:35:22 <Alpounet> give the link when you're done with it
00:35:27 <dolio> Add a binary operation. (IO a, a -> a -> a, a -> IO a). Then it starts to get unwieldy.
00:35:41 <quicksilver> Peaker: luqui was wrong.
00:35:57 <quicksilver> Peaker: ah no, he wasnt, my example was stupid.
00:36:06 <quicksilver> Peaker: you need either a -> IO () or a -> IO a
00:36:13 <Peaker> dolio: there are still no observations on "a"
00:36:28 <solrize> lippmeier's thesis is really good, i'm in chapter 2 now
00:36:44 <dolio> Peaker: IO side effects are some sort of observation.
00:36:59 <Peaker> dolio: oh, I missed the a->IO a there
00:37:02 <dolio> And the more ways I can combine as, the more combinations of IO actions you have to store.
00:37:16 <Peaker> http://www.reddit.com/r/haskell/comments/atkei/haskell_antipattern_existential_typeclass/c0jbmel?context=3
00:38:26 <Peaker> joevandyk: thrift sounds great
00:39:28 <vegai> huh
00:39:28 <lambdabot> vegai: You have 1 new message. '/msg lambdabot @messages' to read it.
00:39:39 <vegai> we just had a meeting where we considered using thrift
00:39:45 <vegai> Peaker: do you have cameras in here or what?
00:39:53 <vegai> or joe...
00:40:23 <quicksilver> the cameras are unreliable, vegai
00:40:28 <quicksilver> but the microphones work great.
00:50:13 <Alpounet> Peaker, you're writing a tiny GUI toolkit ?
00:50:34 <Peaker> Alpounet: I was.. I am hoping to continue work on it
00:50:44 <Peaker> Alpounet: Need to change use of SDL to OpenGL though
00:51:10 <Alpounet> ok
00:51:14 <Peaker> And use luqui's drawingcombinators instead of my own half-assed image type
00:51:41 <Alpounet> I discovered his drawing-combinators few days ago
00:51:43 <vegai> quicksilver: ha! We were using sign language!
00:51:58 <Peaker> Alpounet: I think LUI is already cute, but there are lots of improvements that I wanna do
00:52:14 <Alpounet> performance-wise, mostly ?
00:52:34 <Peaker> Alpounet: I don't know about that.. not sure what the performance is, I know it feels ok
00:53:26 <Peaker> Alpounet: I like the pure functional widget definition, which is nearly:  Widget model = model -> (Image, Map UserInput (Documentation, model))
00:54:26 <Alpounet> hmm
00:54:28 <Peaker> I want to replace (Documentation, model) with (Documentation, Delta model) -- where Delta is a type family, and there's  Delta model -> model -> model,  but Delta model can also contain more information
00:54:28 <Alpounet> interesting
00:55:02 * Alpounet will take a look at LUI then
00:55:30 <Peaker> There's also: http://github.com/Peaker/lui
00:55:56 <tomberek> Alpounet: hey
00:56:38 <Peaker> If someone was willing to clean up LUI's todo list (Use GLUT/GL instead of SDL, drawing combinators, and Data.Accessor or some other Category instance rather than the hack I have there, ...)
00:56:43 <Peaker> ;-)
00:56:55 <Alpounet> tomberek, hi there :)
00:57:21 <tomberek> I have a state-like naive version now.
00:58:57 <Alpounet> tomberek, let me see
00:59:06 <Alpounet> (or put it in the darcs repo if you want)
00:59:40 <tomberek> so each neuron keeps a state,,,, and it is a polymorphic network, it can take a range of types
00:59:58 <tomberek> it's ugly, but it's giving me more intuition about the problem
01:00:09 <Alpounet> and probably more general yeah.
01:01:07 <tomberek> i'm going to try the typeclass approach next.. see what I can work out.... you had typeclass suggestions?
01:01:43 <Alpounet> tomberek, maybe for input/output value storage
01:02:56 <tomberek> Alpounet, Cale suggested something like this as a way to represent a network    : Map Vertex (Activity Set (Weight, Vertex))
01:03:31 <tomberek> basically keep a map of the vertexes that stores the current activity, and the connections
01:05:49 <Alpounet> what'd be the advantages of that approach over the other ones we already discussed ?
01:06:20 <tomberek> Alpounet, easy to find all the connections to any node
01:06:54 <Alpounet> hmm
01:07:07 <Alpounet> that's really a real-time oriented approach
01:07:12 <Alpounet> (real-time NN, that is)
01:07:43 <tomberek> well... actually a real time NN would be more like mapping what nodes the output is connected to
01:08:25 <tomberek> that way you can calculate the "wave" as it propagates through the NN as just an inline tree traversal
01:08:49 <tomberek> he suggested this where we store the inputs associated with each node
01:09:15 <tomberek> again: 2 different ways with subtle differences.....
01:10:51 <Alpounet> yrp
01:10:54 <Alpounet> yep*
01:12:08 <Peaker> every Monad.Reader issue will have a monad tutorial/explanation-from-scratch?
01:13:17 <ivanm> when profiling, is there a way of getting the actual time taken on a particular function rather than just a percentage spent?
01:13:52 <ivanm> because I think most of the time is spent on waiting for a forked command to finish, yet the profiling output doesn't reflect this :s
01:14:06 <arw> Peaker: after all, its named 'monad reader', and a basic law of haskell is, 50% of all documentation has to be monad tutorials :)
01:14:52 <Peaker> arw: heh, it does create an awful impression
01:15:08 <Alpounet> what about creating The Arrow Reader ?
01:15:17 <vegai> arw: and the other 50% is missing!
01:15:18 * vegai hides
01:16:15 <ray> the kan extension conceptor
01:23:25 <pastorn> @remember <arw> ...and a basic law of haskell is, 50% of all documentation has to be monad tutorials :)
01:23:25 <lambdabot> Nice!
01:24:04 <mauke> @quote <arw>
01:24:04 <lambdabot> <arw> says: ...and a basic law of haskell is, 50% of all documentation has to be monad tutorials :)
01:24:07 <mauke> fail
01:24:17 <pastorn> sorry
01:24:29 <pastorn> @quote arw
01:24:30 <lambdabot> cjeris says: instance (TicTacToe a) => (GlobalThermonuclearWar a) where ...
01:24:57 <pastorn> can't someone mess with lambdabots head to make it right?
01:25:44 <Saizan> pastorn: use @forget and @remember again
01:26:22 <ivanm> *sigh* anyone know how I can fully evaluate (i.e. make an NFData instance of) FGL graphs?
01:26:28 <pastorn> @forget <arw> ...and a basic law of haskell is, 50% of all documentation has to be monad tutorials :)
01:26:29 <lambdabot> Done.
01:26:39 <pastorn> @remember arw ...and a basic law of haskell is, 50% of all documentation has to be monad tutorials :)
01:26:39 <lambdabot> Done.
01:26:44 <pastorn> @quote arw
01:26:44 <lambdabot> arw says: ...and a basic law of haskell is, 50% of all documentation has to be monad tutorials :)
01:26:57 <pastorn> Saizan: yay! cool!
01:27:35 <quuxman> why isn't gtk2hs in hackage yet?
01:28:25 <ivanm> quuxman: because it isn't buildable with cabal
01:28:42 <Saizan> quuxman: it'll be once you make it buildable with Cabal :)
01:28:57 <ivanm> because it's composed of quite a few sub libraries (which cabal can't express yet) and uses c2hs to build (which IIRC isn't compatible with cabal yet)
01:29:14 <ivanm> alternate reason: because dcoutts is too busy to get it in a form suitable for hackage ;-)
01:29:34 <Saizan> well, the sub-libraries would just be other packages
01:29:45 <Saizan> if you install the .chi files somewhere
01:30:02 <Saizan> another problem is that they use a custom c2hs, etc..
01:30:28 <quuxman> one thing that cabal doesn't handle is dependencies outside of its package system
01:30:41 <quuxman> which is natural
01:31:01 <quuxman> but it's annoying having to install a bunch of -dev packages to get the right c header files
01:31:42 <Saizan> well, if the maintainers use extra-libraries: it can at least tell you which libs you need
01:32:36 <quuxman> anyway, ghc is crashing when I try to build gtk2hs
01:32:58 <Saizan> crashing? or simply reporting an error?
01:33:05 <pastorn> quuxman: what OS are you using?
01:33:54 <quuxman> ubuntu. The error is "ghc: panic! (the 'impossible' happened) / (GHC version 6.10.4 for i386-unknown-linux): / Prelude.chr: bad argument"
01:34:28 <Saizan> hah
01:34:47 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16576#a16576  ghc panic
01:34:58 <Saizan> that's pretty bad, it's related to old or corrupted .hi files i think
01:35:08 <Saizan> so cleaning them should help
01:35:10 <quuxman> oh yeah, I've ran in to similar issues before
01:35:43 <quuxman> I should've guessed that was the problem
01:36:26 <quuxman> not surprising you get undefined behavior when you compile something with object files from an old version of the compiler still hanging around
01:36:34 <Saizan> hehe
01:37:11 <Saizan> istr the error message got better in 6.12
01:38:04 <Saizan> solrize: you've to indent the #-}
01:38:18 <Saizan> solrize: it doesn't panic on 6.12.1, fortunately :)
01:39:54 <solrize> yeah, i noticed about the indent, ok i'm glad they fixed it.
01:40:05 <solrize> i already opened a ghc bug so i guess i'll mention that
01:40:30 <pastorn> quuxman: why not just install it through apt?
01:40:50 <pastorn> or do you absolutely HAVE to use 6.12?
01:41:22 <solrize> actually what happened to 6.11 ?
01:43:13 <solrize> so tell me sumpin'
01:43:31 <solrize> a heck of a lot of PL papers have a bunch of sequent diagrams
01:43:40 <solrize> that are big and complicated and fully of little tiny terms
01:43:46 <solrize> and use a lot of space in the paper
01:43:55 <solrize> my question is, does anyone look at them?
01:44:15 <solrize> and how the heck does anyone write them?  are they mechanically checked most of the time?
01:44:24 <pastorn> solrize: example?
01:44:38 <solrize> lemme find one
01:44:57 <solrize> p. 212 of lippmeier's thesis
01:45:11 <solrize> http://cs.anu.edu.au/people/Ben.Lippmeier/project/thesis/thesis-lippmeier-sub.pdf
01:45:15 <Saizan> solrize: you mean like inference rules for type systems and evaluation relations?
01:45:26 <solrize> Saizan, yeah
01:45:38 <solrize> the one i just pasted isn't as bad as some
01:45:49 <Saizan> i do read them
01:46:34 <solrize> would it be better to write them as pseudocode of some sort?
01:46:35 <Saizan> they generally follow the same pattern with some differences peculiar to the paper in question
01:46:43 <solrize> hmm
01:46:48 <Saizan> and those are generally explained in text
01:46:56 <Saizan> well, they are pseudocode :)
01:47:31 <Saizan> not really executable though, they don't have to describe an algorithm, just a relation
01:47:44 <pastorn> solrize: latex?
01:47:50 <Saizan> in fact sometimes you get both the high-level and the syntax-directed version
01:47:51 <pastorn> solrize: lhs2tex?
01:48:02 <Saizan> where the latter is an algorithm
01:48:02 <solrize> pastorn, not sure what you mean about latex
01:48:21 <solrize> oh you mean instead of pdf
01:48:23 <pastorn> solrize: you write them with latex
01:48:24 <solrize> i dunno if he posted it
01:48:34 <solrize> pastorn, :-P
01:49:10 <pastorn> solrize: http://lmgtfy.com/?q=lshort.pdf&l=1
01:49:11 <solrize> it's sort of an untyped language
01:49:33 <solrize> pastorn, i wasn't asking how they were typeset
01:50:13 <pastorn> solrize: but i'm sure you could imlement a deep imlementation of this proof system and write an emitTeX :: Proof -> String function
01:50:15 <Saizan> well, yeah, it works on the syntax of terms, so the only types are those corresponding to the non-terminals of the grammar
01:50:22 <Beelsebob> pastorn: hardly a reason for lmgtfy, because lshort is only a thing you know to google for if you already know laTeX
01:50:25 <pastorn> <solrize> and how the heck does anyone write them?
01:50:57 <pastorn> Beelsebob: copying URLs to PDFs in google usually turns out messy
01:52:37 <Saizan> solrize: so, in the end, they are high-level specifications in a logic programming language for what you're going to implement more clumsily in a functional style in your compiler :)
01:53:15 <solrize> pastorn, let me put it another way.  how does anyone write down all those diagrams with any confidence that they're not full of errors?
01:53:25 <solrize> Saizan, hmm
01:54:16 <pastorn> solrize: as i said, define an embedded language for proofs and let haskell run the proof (or better yet let the haskell typechecker do it!)
01:54:33 <pastorn> then write a function that converts it to TeX-code
01:55:09 <solrize> is it a decidable language?
01:55:13 <Saizan> pastorn: we're not dicussing how to write proofs
01:55:24 <Saizan> pastorn: we're discussing how to write the theory itself
01:55:44 <pastorn> i thought the stuff on p.212 was a proof
01:56:01 * Saizan checks again
01:56:20 <Saizan> no, it isn't
01:56:26 <solrize> i wasn't even looking at the content that closely.  i just am referring to those things generally
01:56:37 <Saizan> those are all axioms defining a relation
01:56:54 <solrize> ok, so machine consistency checking is possible
01:57:59 <Saizan> to some extent, yeah
01:58:16 <olsner> I've always found those diagrams completely unreadable
01:58:30 <Saizan> e.g. that you didn't use the wrong kind of arguments for the relation
01:58:43 <solrize> it doesn't seem like the equations in a math paper, where they carry information and you have to actually figure out what they are saying and follow them
01:58:51 <Saizan> reading TAPL should give you quite some familiarity with the notation
01:59:05 <solrize> yeah PFPL explains it too
01:59:38 <solrize> i tried reading TAPL a year or so ago and it was too hard, but maybe i can try again and do better now
01:59:44 <Saizan> those are all distinct axioms that when put together define some relation
02:00:14 <Saizan> it's the same as defining a GADT
02:00:31 <quicksilver> Peaker: thinking about it, luqui's embedding into Mu IO is wrong, it assumes you only use the first action once. atually you can use it as often as you like and start tracking multiploe as if you want.
02:01:04 <Peaker> quicksilver: reply then :)
02:01:09 <Saizan> each axiom is a constructor, and if you can construct a value of the gadts with some indices, it means those indices are related by the corresponding relation
02:01:14 <quicksilver> Peaker: do I look like I have a reddit account? ;P
02:01:37 <pastorn> solrize: as i said... you can probobly define the thing there in some DSL oa
02:01:40 <solrize> i wonder if the effect system in this thesis could be done with gadt's
02:02:01 <Peaker> quicksilver: Why wouldn't you?
02:02:10 <olsner> is it like this: the stuff above the line is the conditions that must be satisfied to apply the rule below the line? in that case, it feels like prolog might work just as well to express the same thing (although prolog implies sequencing, which the diagrams do not)
02:02:11 <pastorn> and if your nifty only valid things will typecheck :)
02:02:30 <solrize> the thing is, these diagrams just seem far away from what the language designer is actually thinking about
02:02:34 <Saizan> solrize: to be clear, the gadt here would be in the metatheory, not in the language itself
02:02:58 <solrize> Saizan, yeah, i was sort of on another topic
02:03:07 <Saizan> olsner: yeah, it is a logic language like that
02:03:07 <solrize> the thesis is about a haskell dialect with effect tracking in the type system
02:03:10 <solrize> it's pretty cool
02:03:11 <quicksilver> Peaker: I find such sites bad for my blood pressure ;)
02:03:27 <solrize> and i'm wondering whether the effect types could be encoded in gadt's
02:03:43 <Saizan> olsner: in fact there's Twelf, which is a dependently typed logic language, which works quite well for these things
02:05:13 <Peaker> quicksilver: heh
02:05:23 <Peaker> quicksilver: kudos to you being able to avoid them on such grounds :)
02:06:20 <solrize> so how does type inference really work?  i.e. one of the things this thesis says is that ghc's type inferencer uses IORefs which is consistent with what i heard somewhere, which is that naive damas-milner is dog slow (like exponential or something) and you have to use intricate memoization to make it practical
02:06:24 <Saizan> everytime i feel like i should write on reddit because "someone is wrong on the internet" i bump into the registration form and fortunately lose all my initiative :)
02:06:47 <solrize> Saizan, lol
02:06:54 <olsner> Saizan: lucky you, I'm already registered!
02:07:59 <SubStack> subreddits are the best thing ever
02:08:26 <Saizan> solrize: you can use a Map Var Type instead of using IORefs
02:09:04 <solrize> is the algorithm complicated?   i was asking about this on the other channel last night
02:09:12 <Saizan> solrize: basically the point is that you've to implement logic variables in some way, so you can fill them later as you traverse the body of the lambda
02:09:26 <solrize> hmm ok
02:10:28 <olsner> maybe you can fill them in with the final result, in tie-the-knot fashion? I guess it's hard, but these are haskell compiler writers we're talking about :P
02:11:10 <Saizan> it's basically a constraint satisfaction problem, traversing the term you collect all these constraints saying some variable must be equal to some other, and you solve them by unification
02:11:16 <solrize> so you start with the literal terms and then just make repeated passes til you've assigned types to everything?
02:11:36 <Peaker> Saizan: It would be great to have you in the Haskell subreddit though... :)
02:12:12 <solrize> http://en.wikipedia.org/wiki/Algorithm_W#Solving_the_equations
02:12:19 <Saizan> i'm pretty sure you've to traverse the term only once
02:13:24 <solrize> is it worse for haskell (with typeclases, existentials, etc) than ML?
02:13:46 <solrize> i guess TAPL must explain it
02:13:51 <solrize> i still have a borrowed copy around here
02:14:04 <Saizan> (then there's the problem of generalization/instantiation for let-polymorphism)
02:14:15 <solrize> i was asking on the other channel whether there was a canned type inference library around
02:14:27 <solrize> let-polymorphism is the situation where algorithm W is exponential ?
02:14:46 <solrize> but in practice it's usually not deeply nested enough for the blowup to matter?
02:15:18 <Saizan> yeah, basically the type gets exponentially larger than the term, so the algorithm that produces it is exponential
02:15:43 <solrize> there's no possible structure sharing inside the type?
02:16:40 <solrize> i guess the way WP describes it, i could implement it
02:17:32 <Saizan> well, there is in fact structure sharing
02:18:53 <solrize> i've been fooling around with a monadic EDSL and find that the embedded language gets hopelessly mungled up with the host language, so i'm trying to figure out how a more traditional compiler works (parser -> type assignment -> semantic translation -> machine code).  type assignment is the only part that isn't pretty much automated these days.
02:19:07 <Saizan> not anything you can express in the usual grammar for types, but you can in an haskell representation
02:20:06 <Saizan> http://notvincenz.blogspot.com/2008/01/using-typechecker-monad-to-type-check.html <- this article might or might not help with getting some familiarity with the subject :)
02:20:28 <solrize> thanks
02:20:30 <manjunaths> hello
02:20:34 <Saizan> http://www.flippac.org/PrenexF.pdf
02:22:13 <solrize> that looks interesting
02:23:36 <Saizan> http://www.cs.uu.nl/wiki/bin/view/Ehc/EfficientFunctionalUnificationAndSubstitution <- this does a comparison between ways to implement unification
02:24:13 <solrize> why does WP say that system F has undecidable type inference?  i thought it was the ML type system
02:24:36 <dolio> System F has arbitrary rank types.
02:24:45 <solrize> oh i see
02:25:20 <Saizan> Ruler: Programming with Type Rules (included in PhD thesis) <- this one looks interesting but i'm not sure which PhD thesis is referring to
02:25:31 <Saizan> oh, the one above..
02:25:47 <solrize> bookmarking
02:27:44 <Saizan> ah, there's also "typing haskell in haskell", which deals with typeclasses
02:28:30 <ivanm> is there a haskellian equivalent of /dev/null ?
02:28:54 <Saizan> >> return () ?
02:28:55 <ivanm> I want to force evaluation of FGL graphs, and AFAICT the only way to do so is to print them
02:29:13 <solrize> oh there's something in control.monad for that
02:29:13 <ivanm> Saizan: I want it for the redirection capabilities
02:29:15 <solrize> @hoogle evaluate
02:29:16 <lambdabot> Control.Exception evaluate :: a -> IO a
02:29:16 <lambdabot> Control.OldException evaluate :: a -> IO a
02:29:16 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
02:29:22 <ivanm> oh, yeah, I forgot about evaluate
02:29:28 <solrize> yeah, that
02:29:52 <Saizan> evaluate doesn't evaluate more deeply than seq
02:29:59 <olsner> NFData?
02:30:04 <Saizan> ivanm: maybe you can use fold ?
02:30:07 <solrize> rnf ?
02:30:16 <solrize> i thought evaluate did a deep seq
02:30:17 <ivanm> olsner: no idea how to force evaluation of FGL graphs :s
02:30:23 <ivanm> solrize: nope, it says WHNF :s
02:30:27 <solrize> oh well
02:30:34 <solrize> then i guess you want rnf
02:30:36 <ivanm> unless I do evaluate . show ...
02:30:46 <ivanm> wait, evaluate . length . show
02:30:51 <ivanm> that should do it I think...
02:30:57 <solrize> gack
02:31:00 <ivanm> heh
02:31:25 <olsner> should be simple to add an instance of NFData based on the data type definition, I think... might be difficult if the data type is hidden though
02:31:26 <Saizan> evaluate . rnf . show :)
02:31:34 <ivanm> I want to use rnf, but have no idea how to define it for Data.Graph.Inductive.Tree
02:31:40 <ivanm> Saizan: heh
02:31:52 <ivanm> olsner: exactly
02:32:33 <ivanm> Saizan: I might be able to use that for and NFData instance actually....
02:32:37 <olsner> instance NFData Foo where rnf = rnf . show -- :)
02:32:43 <ivanm> yup
02:33:16 <Saizan> something with gfold might waste less time :)
02:33:20 <ivanm> with criterion, am I meant to be passing the arguments to be used as well?
02:33:35 <ivanm> hmmmm....
02:33:43 <ivanm> Saizan: any suggestions how?
02:34:38 <Saizan> ah ufold :: Graph gr => (Context a b -> c -> c) -> c -> gr a b -> c
02:34:53 <Saizan> that's the one i was thinking about
02:35:40 <Saizan> ufold (\cxt -> seq (rnf cxt))  ()
02:36:27 <ivanm> I presume the rnf instance for (,,,) is rnf on all four values?
02:36:38 <Saizan> yeah
02:39:24 <ivanm> so how would one use rnf within IO to evaluate some values?
02:39:42 <ivanm> return $ rnf foo ?
02:41:03 <solrize> jam the value into an ioref ?
02:41:14 <solrize> or even a STref
02:41:14 <ivanm> solrize: what's the point of that?
02:41:22 <solrize> make sure it's completely evaluated
02:41:43 <ivanm> I just want to make sure that the values I'm using for criterion are fully evaluated before I use them
02:41:54 <solrize> yeah
02:42:05 <ivanm> maybe using evaluate . rnf ...
02:45:38 <sohum> @hoogle gr a b -> gr a b -> gr a b
02:45:39 <lambdabot> Did you mean: Gr a b -> Gr a b -> Gr a b /count=20
02:45:39 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
02:45:39 <lambdabot> Data.Map union :: Ord k => Map k a -> Map k a -> Map k a
02:45:51 <solrize> http://hackage.haskell.org/package/deepseq-1.1.0.0
02:48:05 <sohum> @hoogle Tree a b -> gr a b
02:48:06 <lambdabot> Did you mean: Tree a -> Gr a b /count=20
02:48:06 <lambdabot> Data.Graph.Inductive.Basic grev :: DynGraph gr => gr a b -> gr a b
02:48:06 <lambdabot> Control.Arrow ArrowMonad :: a () b -> ArrowMonad a b
02:50:02 <Saizan> ivanm: return $! rnf foo
02:50:11 <Saizan> ivanm: or yeah, evaluate
02:51:01 <Saizan> solrize: putting (rnf something) into an IORef or STRef doesn't make it evaluate
02:51:33 * Alpounet enjoying TMR#15
02:51:35 <solrize> hmm
02:52:09 <quicksilver> solrize: GHC's algorithm is exponential too, it's just that case doesn't appear to often in practical programs.
02:52:22 <interferon> is there a function that's the complement of filter? (i.e. reject)
02:52:30 <quicksilver> solrize: and type classes make it fiddlier but don't make the complexity worse, AFAIK.
02:52:41 <ivanm> OK, did I just use criterion wrong? because it just finished running and didn't spit out any graphs or anything... >_>
02:52:45 <solrize> integral, filter . not
02:52:45 <Alpounet> reject p = filter (not . p)
02:52:47 <sohum> how /would/ you convert a basic implementation of Tree a b into one of fgl's graphs?
02:53:06 <interferon> Alpounet, soirize: ok, thanks
02:53:14 <solrize> Alpounet is right i'm wrong ;)
02:53:44 <Alpounet> @pl \p -> filter (not . p)
02:53:44 <lambdabot> filter . (not .)
02:53:47 <solrize> yeah
02:53:47 <Alpounet> here it is.
02:55:15 <solrize> quicksilver, hmm, good to know.  i guess if i try to code it i'll start with the simple case
02:56:06 <quicksilver> solrize: GHC is super-linear in quite a lot of ways actually, that's one reason separate compilation is pragmatically important
02:56:17 <quicksilver> solrize: not just type inference, but all kinds of things, sadly :(
02:56:41 <solrize> quicksilver, is it in a worse situation than jhc or mlton ?
02:56:46 <quicksilver> no :)
02:56:58 <solrize> in my own situation i don't care much because the programs will be small
02:56:59 <quicksilver> certainly not worse than jhc.
02:57:03 <quicksilver> not sure about mlton.
02:58:11 <solrize> am i being overoptimistic or has writing a simple compiler gotten really really easy?  parsec -> algorithm w -> some haskell pattern matching to make intermediate code -> LLVM -> done
02:58:28 <quicksilver> writing a simple compiler was never that hard :)
02:58:36 <quicksilver> some places do it as an undergraduate project.
02:58:42 <sohum> I believe that in any one game, all of the client keys have to ebe cdifferent and if the server is crackeany one client is cracked the host has to be cracked.
02:58:57 <quicksilver> but certainly good parsing libraries take the pain out of parsing and good codegen libraries take the pain out of codegen.
02:58:57 <Alpounet> quicksilver, I had to write a logo -> postscript compiler last year
02:59:18 <Alpounet> ... in C.
02:59:22 <quicksilver> optimisation is arbitrarily hard, though.
02:59:35 * Alpounet cries
02:59:41 <solrize> well i thought type inference was hard
02:59:52 <solrize> but i guess it's not so bad
03:00:03 <solrize> i was hoping there was a library for it, like there is for parsing and codegen
03:00:07 <solrize> but i guess it's not needed
03:01:09 <Saizan> EHC is supposed to be written in a way that makes it easy to extend the type system afaiu, so they might have something for that
03:01:27 <solrize> hmm
03:02:44 <Saizan> if your type system has a complete algorithm for inference then it's probably quite simple, anyhow
03:03:00 <solrize> complete = total ?
03:03:13 <solrize> i guess ghc's doesn't have that
03:03:29 <solrize> it relies on some programmer annotations but also manages to infer a lot
03:03:38 <solrize> and i wondered if black magic was involved
03:03:55 <solrize> plus i'd also had the impression that more black magic was required to get acceptable speed from HM
03:04:06 <solrize> but i guess that last part is not so bad
03:04:31 <dolio> I'm not sure I really understand how you'd create a library for type inference.
03:04:46 <Alpounet> solrize, what language are you writing a compiler for ?
03:04:55 <dolio> Since it's tied to the terms in your language.
03:05:11 <dolio> Unless you mean just some library for doing unification.
03:05:21 <solrize> dolio you'd give it a syntax tree and it would assign types
03:05:58 <solrize> for example in ghc's system the constraints can be pretty complicated
03:06:07 <ivanm> OK, does criterion only draw one graph at a time?
03:06:21 <solrize> Alpounet, i'm thinking of a typed layer on hedgehog lisp
03:06:34 <Alpounet> solrize, do you have a repo ?
03:06:53 <solrize> Alpounet, so far it's just in my imagination
03:06:57 <solrize> oh yes the other thing
03:07:04 <solrize> i'm playing with atom
03:07:43 <solrize> http://hackage.haskell.org/package/atom
03:07:48 <Alpounet> ok.
03:07:49 <solrize> that's the monadic EDSL that i was mentioning
03:07:56 <solrize> that gets tangled up with haskell
03:08:06 <solrize> so i was thinking it would be better to have a more traditional setup
03:08:17 <solrize> with real syntax instead of a haskell monad
03:08:32 <solrize> so use parsec to read it
03:08:55 <solrize> and have user definable types
03:08:59 <solrize> so it would need type inference
03:09:20 <solrize> then use the existing backend but maybe have it generate asm code instead of C
03:09:38 <Alpounet> Peaker, your isSorted has unnecessary overhead
03:09:40 <solrize> because it seems like it currently depends on special behavior of the target c compiler
03:11:36 <solrize> "In a case that has been winding its way through the courts for a while now, a Wisconsin prison banned inmates from playing Dungeons & Dragons, using the justification that 'one player is denoted the Dungeon Master... [who] is tasked with giving directions to other players... [which] mimics the organization of a gang.'
03:12:12 <PeakerWork> Alpounet: you code reviewing? :-)
03:12:19 <eevar2> solrize: about time
03:12:22 <Saizan> dolio: yeah, it'd be quite weird to translate the source into the language expected by the library before you even know what your source means. a framework which helps with gathering and solving constraints would be nice though, similar to the recent ones for optimization passes maybe
03:12:37 <PeakerWork> Alpounet: If you can compile a list of suggestions, that would be nice :-)
03:12:50 <PeakerWork> Alpounet: or alternatively, a github fork with your fixes
03:13:14 <solrize> Saizan, originally i thought of something like liskell
03:14:23 <Saizan> solrize: as a target?
03:14:58 <solrize> Saizan, you'd parse the input language into liskell and then call the type inference library
03:15:30 <solrize> so you'd be limited to the haskell or ghc type system
03:15:33 <solrize> but that's pretty powerful
03:16:19 <Saizan> you'd be limited to some non-type-directed syntax sugar over haskell, basically
03:17:27 <Saizan> which can be more than enough i guess :)
03:17:29 <solrize> yeah, pretty much.  you'd get rid of all the collisions with haskell built-ins
03:18:26 <solrize> and you could automatically generate haskell annotations based on user types
03:18:38 <solrize> atom has a GADT  carrying all the dsl's types
03:18:57 <solrize> which means you can't really add more types without hacking the compiler
03:19:00 <solrize> you end up with C types
03:19:06 <solrize> and your programs end up with C-like bugs ;)
03:19:51 <Saizan> there's the usual problem that typechecking after desugaring gives bad error messages
03:20:00 <solrize> hmm
03:20:44 <solrize> i guess ghc goes to a lot of trouble to track where the errors came from, and its message still are pretty confusing
03:20:45 <solrize> messages
03:21:55 <Saizan> heh, yeah "imagine what they would be otherwise!" vs. "they are useless anyway."
03:22:05 <solrize> lol
03:22:30 * theorbtwo shrugs.
03:22:52 <Saizan> they generally make sense to me, tbh
03:22:58 <solrize> they're not useless now, but 1) i get the impression that ghc has a lot of hair to make them non-useless; and 2) the desugaring thing would have to have even more hair to do nearly as good a job
03:23:10 <theorbtwo> gcc could eliminate many cases of confusing error messages by making a #included file not found be a hard error instead of warning.
03:23:11 <solrize> so yeah it does sound like a problem
03:23:28 <theorbtwo> (But that'd violate the C spec.)
03:23:43 <theorbtwo> Sorry.  Misread an earlier statement.
03:24:19 <quuxman> is there a way in ghci to say "load definitions from file", that doesn't blow away the existing definitions?
03:24:28 <solrize> :m ?
03:24:33 <mauke> theorbtwo: how would that violate the C spec?
03:24:41 <quuxman> solrize: oh :)
03:24:44 <ivanm> quuxman: :m +Data.Foo
03:25:22 <Saizan> or "import Data.Foo" in recent versions
03:25:24 <theorbtwo> mauke: Because the C spec says that a #included file not being found is not an error (but may be a warning), and that you cannot halt compilation except upon error.
03:25:38 <theorbtwo> I'm not a C standards lawyer by any means, but have been told that it would.
03:26:15 <mauke> well, everything may be a warning
03:26:23 * mauke goes to look for the error
03:26:40 <ivanm> OK, if I use augustsson's timeIt package on Hackage, my code apparently takes 0.34 seconds to run...
03:26:55 <ivanm> but the time program says it takes more like 0.9s to run
03:26:58 <ivanm> so who is lying?
03:26:58 <theorbtwo> Thus, there's a fairly common way to make compilation fail that produces fustrating output -- you get a warning about a missing include file, followed by several hundred lines of missing prototype warnings, followed by a few lines of syntax errors.
03:27:29 <Saizan> ivanm: maybe timeIt is measuring CPU time?
03:27:46 <theorbtwo> ivanm: That suggests that the parts of the program that run before timeIt begins take 0.56 seconds.
03:27:46 <ivanm> yeah, it is...
03:27:59 <ivanm> theorbtwo: main = timeIt $ do ...
03:28:10 <theorbtwo> ivanm: The RTL startup.
03:28:16 <ivanm> you mean RTS?
03:28:21 <theorbtwo> Er, yes.
03:28:22 <ivanm> damn.... didn't think of that :s
03:28:35 <theorbtwo> system, library.  Two acronyms, same thing.
03:28:45 <sohum> @hoogle [m a] -> m [a]
03:28:45 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:28:45 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
03:28:45 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
03:30:47 <ivanm> *sigh* for some reason, it's faster to run dot -Tdot multiple times and parse the result rather than calling dot once with all of the values
03:32:12 <mauke> theorbtwo: as far as I can see the standard just says it's "implementation defined"
03:32:18 <mauke> I think that includes failure
03:32:23 <theorbtwo> Interesting.
03:33:41 <solrize> so they just fixed another buffer overflow bug in gzip... i want to just ban C forever.
03:34:00 <theorbtwo> In that case, I very much wonder why gcc makes it a warning.  It does not make much sense, and commonly leads to annoying-to-diagnose failure modes.
03:34:04 <int-e> ivanm: timeIt doesn't account for time spent in children.
03:34:15 <theorbtwo> Anyway, quite offtopic for here.
03:34:34 <ivanm> int-e: what do you refer to as "children"? forkIO?
03:34:49 <int-e> ivanm: subprocesses. getCPUTime uses getrusage(RUSAGE_SELF,...).
03:35:01 <jogla> Hello
03:35:03 <jogla> I'm trying to do a beta reduction,  but I'm unable to find the right series of reductions
03:35:06 <jogla> http://verify.rwth-aachen.de/fp09/Uebungen/sheet12.pdf
03:35:16 <int-e> ivanm: and timeIt uses getCPUTime (from System.CPUTime)
03:35:27 <ivanm> right
03:35:28 <jogla> It's beta reductions in both ways, <- and ->, but I can't find the right time to do "<-"
03:35:40 <ivanm> so wrt Haskell code, that means stuff I've forkIO'd doesn't count?
03:36:05 <int-e> forkIO counts. forkOS or using System.Process stuff won't count.
03:36:07 <Saizan> stuff like runProcess won't count
03:36:08 <int-e> uhm
03:36:14 <int-e> no, forkOS will work as well
03:36:15 <int-e> sorry
03:36:21 <solrize> jogla, exercise 1?
03:37:07 <mauke> what does ->* mean?
03:37:15 <jogla> solrize: Yes, the first path
03:37:19 <jogla> The b) seems to be rather easy
03:37:23 <int-e> ->* = transitive closure of ->
03:37:36 <mauke> huh
03:37:37 <int-e> or transitive, reflexive closure
03:37:49 <jogla> I think it does mean that I can do -> and <- as often as I want, in any order i want
03:37:57 <mauke> ah
03:38:03 <mauke> ok, that makes sense
03:39:56 <solrize> jogla, does http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion help?
03:41:34 <mauke> Y z = \f -> (\x -> f (x x)) (\x -> f (x x)) = (\x -> z (x x)) (\x -> z (x x)) = z ((\x -> z (x x)) (\x -> z (x x))) = z ((\f -> (\x -> f (x x)) (\x -> f (x x))) z) = z (Y z)
03:41:40 <mauke> no idea how formal this is
03:42:02 <int-e> well, some of these = are ->_beta or <-_beta.
03:42:20 <Saizan> forgot a 'z' in the second term
03:42:22 <mauke> they're mostly -> except for one at the end
03:42:30 <mauke> that too
03:42:54 <mauke> the step where I go from (.. z ..) to (\f -> ...) z is <-_beta
03:43:21 <int-e> ... = ... ->_beta ... ->_beta ... <-_beta ... = ...
03:47:11 <jogla> Ahh, I got it too, thank you
03:48:22 <jogla> When I use the beta reduction, my variables, e.g. x often become x', because there already was a x in the rest of the term
03:48:25 <jogla> Is that false?
03:50:01 <mauke> example?
03:50:25 <jogla> I have e.g.: (\x -> (x y)) y
03:50:36 <jogla> That becomes (y' y), doesn't it?
03:50:40 <jogla> Instead of (y y)
03:50:41 <mauke> why?
03:50:46 <mauke> those y are the same variable
03:50:51 <jogla> Hmm
03:51:04 <mauke> the inner y is not bound by the lambda, so they're in the same scope
03:51:18 <jogla> When would I use the ' then?
03:51:36 <zygoloid> (\x -> (\y -> x y)) y  reduces to  (\y' -> y y')
03:51:51 <jogla> Ahh, ok
03:51:53 <jogla> Thanks
03:55:47 <sieson_> does any know where I can learn about using "par" and "seq" for writing parallel programs in haskell?
03:56:35 <zygoloid> @go writing parallel haskell programs with par and pseq
03:56:35 <lambdabot> Maybe you meant: google googleit do
03:56:39 <zygoloid> @google writing parallel haskell programs with par and pseq
03:56:40 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html
03:56:41 <lambdabot> Title: 7.18.ï¿½Concurrent and Parallel Haskell
03:58:05 <guerrilla> is there a way, with say GHC, to check if a program consists only of total functions?
04:02:59 <jlouis> guerrilla: yes, transcribe it into Coq :P
04:04:37 <dolio> That will only tell you if its functions are accepted by Coq's syntactic termination checker, which is just a subset of total functions.
04:04:52 <guerrilla> jlouis: thanks, already using Agda2
04:04:59 <guerrilla> was just curious if haskell could do that
04:05:14 <guerrilla> oh hi dolio :)
04:05:37 <dolio> There's a tool, catch, written by Neil Mitchell, which does some level of totality checking for haskell programs.
04:05:52 <guerrilla> dolio: thanks, i'll check that out now
04:06:13 <solrize> guerrilla, completely checking = halting problem ;)
04:06:26 <guerrilla> solrize: aware of that
04:06:29 <dolio> I suspect it doesn't deal with syntactic termination guarantees, though. Just totality of matching, I think.
04:06:41 <guerrilla> should restate that i meant specifically pattern-coverage
04:06:47 <guerrilla> it turns out this catch thing seems to do that
04:06:56 <solrize> oh ok, yeah
04:06:57 <guerrilla> from what i read so far
04:07:01 <dolio> But, it's more intelligent than GHC's pattern coverage checker.
04:07:13 <dolio> It can figure out when 'head' is safe to some degree, etc.
04:07:20 <guerrilla> ah yes
04:07:37 <kamatsu> catch depends on yhc, right?
04:07:39 <solrize> yeah, they used it on xmonad and i think it caught something ghc & the devs had missed iirc
04:07:39 <guerrilla> i suppose that can't be done easily without a dependently typed lang
04:08:13 <solrize> kamatsu, IIRC catch uses yhc core
04:08:55 <dolio> Oh yeah, that's the other thing. Your code has to be relatively vanilla, I think.
04:09:13 <guerrilla> ah
04:09:18 <kamatsu> solrize: that's sad, yhc seems dead now
04:13:23 <interferon> is there a function that takes a regex and an input string and returns a list of all the parenthesized groups that matched?
04:13:39 <solrize> do the haskell wiki admins ever come here ?
04:13:52 <solrize> interferon, yes, text.posix.regex has that
04:13:57 <solrize> you probably should look at bos's tutorial
04:14:53 <interferon> i've been looking around but the only thing i see is =~ where you specify the return type as (_,_,_[group1, ...)
04:14:57 <interferon> it's a little unwieldy
04:15:07 <interferon> just curious if there's something better
04:15:15 <quicksilver> all the various overloads of =~ also exist as straight functions
04:15:24 <solrize> it's clumsy, it helps if you define a type alias for the result
04:15:33 <quicksilver> although I do think the overloads are a bit of a mess.
04:15:43 <solrize> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
04:17:41 <quicksilver> bos-- # You can also use the =~~ operator outside of a monad in some cases
04:17:46 <quicksilver> clumsy phrasing!
04:17:59 <quicksilver> really talking about using it in the maybe monad
04:18:02 <quicksilver> not "outside of a monad"
04:18:45 <mauke> the word "monaction" exists now
04:18:45 <quicksilver> good intro though.
04:18:57 <quicksilver> mauke: that doesn't sound like a good thing ;)
04:20:13 <quuxman> ":m +Foo" doesn't seem to be reloading the definitions
04:20:23 <quicksilver> no, it doesn't
04:20:27 <quicksilver> :m just changes your scope
04:20:33 <quicksilver> it doesn't load or reload anything
04:20:35 <quicksilver> :l loads
04:20:40 <quuxman> and :reload clobbers all the existing definitions
04:20:43 <quuxman> and so does :l
04:20:47 <quicksilver> correct.
04:21:02 <quuxman> how do I load/reload definitions without clobbering everything?
04:21:10 <quicksilver> you cannot.
04:21:13 <quicksilver> AFAIK.
04:21:20 <quuxman> that's rather annoying
04:21:29 <quicksilver> it's never annoyed me, but I'll take your word for it :)
04:21:56 <mauke> quicksilver: are you a dirty emacs user?
04:23:35 <quicksilver> mauke: I'm quite clean today, but yes.
04:25:43 <quicksilver> I wonder if we can experiment with turning -R yet
04:26:02 --- mode: ChanServ set +o mauke
04:26:02 --- mode: mauke set -R
04:26:06 <mauke> turns out we can!
04:27:15 <quicksilver> ;)
04:27:16 <pozic> How can Haskell ever be faster than carefully written C code? Haskell basically copies everything and then you have to hope that the compiler can prove that it doesn't need to make a copy, which it cannot always do. Where is the flaw in this reasoning?
04:27:59 <mauke> pozic: haskell never copies anything
04:28:02 --- mode: mauke set -o mauke
04:28:14 --- mode: quicksilver set -o quicksilver
04:28:17 <mauke> unlike C, where you have to make copies all the time
04:28:31 <pozic> mauke: How does foobar{x = 1,y = 2,z = 3} work then?
04:28:45 <mauke> by creating a new value
04:28:51 <pozic> mauke: that is a copy.
04:28:56 <dang`r`us> also, programming languages don't have speed ... implementations have
04:29:00 <mauke> well, it's a different value, so that's not really a copy
04:29:17 <mauke> x = y + 1;  // I wouldn't call x a copy of y
04:29:35 <osfameron> dang`r`us: though programming language semantics constrain implementations thereof, no ?
04:29:55 <maltem> pozic, except for your sophist argument with mauke about what a copy is ;), why do you think that there must be a flaw in your reasoning?
04:30:03 <pozic> mauke: ok, suppose foobar also contains a-y fields.
04:30:21 <pozic> mauke: then how is the physical memory layout going to look like?
04:30:26 <mauke> I have no idea
04:30:56 <pozic> AFAIK, the best thing Haskell can do is never make a copy, which is already the default in C.
04:31:03 <dang`r`us> osfameron, yes, but in my experience people tend to overrate that
04:31:13 * osfameron rather thinks that the new struct is a copy-with-modifications though?  It does have to iterate all the fields involved, for example ?
04:31:17 <mauke> no, C copies by default
04:31:26 <mauke> struct foo = bar; // copy
04:31:33 <mauke> let foo = bar in ... // no copy
04:31:44 <mauke> make that struct T foo
04:31:49 <ivanm> hang on, why does Data.ByteString assume an encoding?
04:31:52 <osfameron> mauke: yeah, but isn't pozic getting at inplace modification?  foo->bar = 1;  foo->baz = 2; (or whatever C syntax is, I'm a scripting language kiddid :D)
04:31:55 <ivanm> I thought it was meant to use raw bytes :s
04:31:56 <pozic> I think most people use pointers in C.
04:32:15 <dang`r`us> one interesting part about C semantics though is pointer aliasing
04:32:16 <pozic> So, they don't create new values.
04:32:17 <mauke> pozic: doesn't help if you really need to preserve the old values
04:32:18 <maltem> ivanm, for I/O?
04:32:23 <Botje> ivanm: for B.pack, maybe?
04:32:27 <ivanm> yeah
04:32:34 <pozic> mauke: which is a case which almost never happens in a lot of domains.
04:32:37 <ivanm> specifically B.hGetContents
04:32:38 <mauke> pozic: because then your code doesn't create new values and you have to make a copy manually
04:32:55 <mauke> happens often enough, especially with some data structures
04:33:07 <maltem> ivanm: That's a minor strangeness about Handles rather than ByteStrings
04:33:15 <ivanm> :s
04:33:22 <osfameron> pozic: pragmatically... if you look at the shootout and other benchmarks, you'll see that Haskell code *can* be faster than C.  (ISTR that mostly it isn't quite, though it's usually a close contender)
04:33:45 <ivanm> I'm switching over to using Text because that way I can enforce UTF-8 by doing the encoding/decoding myself, but now it seems that isn't going to work :s
04:33:48 <maltem> ivanm, for some reason hLookAhead is sometimes called with respect to the encoding, even if you're reading a ByteString
04:34:02 <maltem> for file I/O, withBinaryFile is what you want
04:34:14 <ivanm> maltem: problem is, it isn't a file :s
04:34:16 <pozic> osfameron: is there anything in that benchmark in which updating of large data structures needs to happen in place?
04:34:23 <pozic> osfameron: I don't think so.
04:34:36 <pozic> osfameron: so, it measures only that part where Haskell does not stink.,
04:34:43 <osfameron> pozic: I guess you'd want to compare updates of treelike structures
04:34:44 <mauke> pozic: er, we do have mutable structures
04:34:46 <pozic> Or to be slightly more positive is quite good.
04:34:49 <maltem> ivanm: um, yeah, problem.
04:34:53 <pozic> mauke: I know.
04:35:10 <pozic> mauke: but what this states is that using large functional structures in basically a bad idea.
04:35:12 <mauke> pozic: another issue: memory allocation is slow in C
04:35:43 <pozic> Contrary to the "use FP if you can"-philosophy.
04:35:44 <ivanm> yeah, looks like bos does a lot of hackery for 6.12 to use the native encoding :s
04:35:49 <idnar> pozic: I'd say that it means that using large imperative structures in a functional language is a bad idea
04:36:09 <pozic> idnar: that doesn't make sense from the previous discussion.
04:36:23 <idnar> pozic: you're talking about in-place modification
04:36:23 <dang`r`us> also, algorithmic optimization is often more important than "my compiler/runtime can beat yours"
04:36:25 <pozic> idnar: it is a bad idea to use big functional structures.
04:36:49 <idnar> pozic: if your data structures require in-place modification to be efficient, then they're not going to work very well in an immutable implementation
04:36:51 <pozic> idnar: if your structure is N big, updating a single field takes O(N) time.
04:37:01 <dang`r`us> (that's not to say e.g. ghc shouldn't optimize the hell out of a program)
04:37:02 <mauke> pozic: only for records
04:37:06 <idnar> pozic: so, for example, a doubly-linked list would be horribly inefficient in Haskell
04:37:08 <ivanm> wow, this source code looks really exciting! :p http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/src/Data-ByteString-Fusion.html
04:37:10 <mauke> pozic: for trees it's O(log N)
04:37:28 <idnar> pozic: that just means you should use a more suitable data structure
04:37:31 <osfameron> yarr!  and you get to keep eery intermediate state, without it growing exponentially large
04:37:39 <osfameron> functional trees are beautiful things
04:37:39 <mauke> and records don't matter because they never have more than a few thousand fields
04:37:45 <ivanm> preflex: seen dons
04:37:45 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- dons was last seen on #haskell 5 hours, 48 minutes and 33 seconds ago, saying: reinterpreting commands to the haskell program, and passing them on to sub processes as needed
04:38:04 <osfameron> pozic: if you use zippers, you may be able to do multiple edits in better than O(log n) too
04:38:20 <osfameron> (he says, not being entirely sure how to do it in practise... but the theory is rather pretty :D)
04:38:48 <osfameron> well, I implemented a zipper thingy in mooseperl, I don't grok the haskell implementation :-(
04:39:00 <ivanm> maltem: even better: the documentation for hGetContents says it assumes ISO-8859-1, the same as hGet... except that the documentation for hGet says no such thing :s
04:39:28 <sohum> why isn't abs defined in terms of signum?
04:39:51 <ivanm> sohum: you mean by default?
04:39:54 <ivanm> @src Int abs
04:39:54 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:40:05 <sohum> ivanm: yea
04:40:08 <ivanm> sohum: presumably in case there's more efficient ways of doing so on the machine level
04:40:08 <dang`r`us> I'm constantly amazed at how widespread iso-* still is. utf-8 was invented in 19*92*
04:40:25 <ivanm> preflex: seen dcoutts
04:40:26 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- dcoutts was last seen on #ghc 1 day, 1 minute and 18 seconds ago, saying: * dcoutts disappears
04:40:27 <sohum> ivanm: so it could be overriden
04:40:34 <ivanm> sohum: yeah
04:40:44 <ivanm> as for why a default wasn't mentioned, who knows *shrug*
04:40:56 <ivanm> sohum: I think for cases like Data.Complex where that definition doesn't make sense...
04:41:01 <ivanm> @type signum
04:41:03 <lambdabot> forall a. (Num a) => a -> a
04:41:37 <sohum> what /is/ signum, on data.complex?
04:41:44 * hackagebot upload: data-accessor-template 0.2.1.3 - Utilities for accessing and manipulating fields of records (HenningThielemann)
04:41:52 <sohum> isn't it still exactly (+/-) i?
04:42:03 <sohum> uh
04:42:05 <sohum> s/i/identity
04:42:50 <ivanm> sohum: it's meant to be
04:43:04 <ivanm> ummm.... I thought it was +/- 1
04:43:20 <ivanm> sohum: in which case, for Additive a your proposed default definition doesn't make sense
04:43:25 <ivanm> @hoogle Addition
04:43:26 <lambdabot> No results found
04:43:28 <ivanm> @hoogle Additive
04:43:29 <lambdabot> No results found
04:43:31 <ivanm> bah
04:43:33 <sohum> :t abs
04:43:34 <lambdabot> forall a. (Num a) => a -> a
04:43:53 <ivanm> Sum is what I meant
04:44:08 <ivanm> @src (Sum Int) signum
04:44:08 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:44:10 <ivanm> bah
04:45:12 <ivanm> @ask dons the documentation for Data.ByteString.hGetContents says "As with hGet, the string representation in the file is assumed to be ISO-8859-1." (even though the documentation for hGet says no such thing); is this still correct (with s/file/handle/)?
04:45:13 <lambdabot> Consider it noted.
04:45:21 <maltem> ivanm, actually, what about hSetBinaryMode ?
04:45:34 <ivanm> maltem: yeah, I have nfi :s
04:45:39 <maltem> nfi?
04:45:48 <ivanm> no f'ing idea
04:46:40 <maltem> Well, does  hSetBinaryMode hdl True  help?
04:46:56 <ivanm> maltem: that's the thing, I dont' know if this _is_ a problem
04:46:57 <Saizan> if your Handle is in binary mode then you get no decoding
04:47:22 <ivanm> @ask dons and if it does still assume ISO-8859-1, what about when the handle is set to binary mode?
04:47:22 <lambdabot> Consider it noted.
04:47:27 <maltem> ivanm, hGet can crash if the wrong encoding is set
04:47:32 <Saizan> if it's in text mode then it's decoded according to the locale
04:47:33 <ivanm> Saizan: this is encoding assumptions that _Bytestring_ makes
04:47:58 <Saizan> ivanm: "assumed to be ISO-8859-1" simply means "we don't do any decoding ourselves"
04:48:14 <ivanm> aha
04:48:20 <ivanm> that could have been made clearer ;-)
04:48:33 <maltem> Yeah the docs are a little original here ;)
04:48:51 <ivanm> heh
04:49:22 <manjunaths> The output of a function is IO something, how do I extract the something ?
04:49:37 <manjunaths> IO WordF -> WordF
04:49:40 <Saizan> ISO-8859-1 is like that, it represents the first 255 codepoints of unicode by using the corresponding 8 bits
04:49:54 <Saizan> manjunaths: you don't
04:50:03 <ivanm> manjunaths: you can pretend to do so in a do block however
04:50:09 <Saizan> manjunaths: you use do-notation to build a larger IO Something with it
04:50:10 <ivanm> Saizan: *nod*
04:50:22 <manjunaths> ivanm, Saizan, ok
04:50:31 <manjunaths> can I do it in ghci ?
04:50:41 <manjunaths> or do I need to go to the editor ?
04:50:56 <Saizan> manjunaths: e.g. foo :: IO WordF, x <- foo, then x will be of type WordF
04:51:19 <Saizan> "x <- foo" is a part of do-notation which you can use at the ghci prompt
04:51:24 <maltem> manjunaths, it's saner to edit the file, because in ghci, layout can get a little crowded
04:51:51 <maltem> oh, of course what Saizan said :P
04:52:23 <Saizan> in a file you'd write something like main = do x <- foo; print x
04:53:03 <ivanm> Saizan: well, that's rather useless...
04:53:11 <ivanm> since that's equivalent to just main = foo !
04:53:17 <ivanm> ummm... wait... ignore that :s
04:53:19 <Saizan> ivanm: no :)
04:53:22 * ivanm isn't thinking straight atm
04:54:23 <sohum> ivanm: hm. that's interesting. the only law abs and signum have to follow is that abs x * signum x == x. (importantly, it's /not/ always +/-1 - e.g. signum for Data.Complex is theta.) this is the same as defining abs x = x * signum x iff forall x, (signum x) = (signum x)^-1, which requires the set to be a group under multiplication.
04:54:35 <sohum> ivanm: tell me the numeric hierarchy's going to be cleaned up soon :{
04:54:48 <ivanm> sohum: I can tell you that, but I'd probably be lying...
04:58:03 <pozic> mauke: Re:trees. That's a good point. Now, do compilers actually do that?
04:58:28 <mauke> do what?
04:59:12 <temoto> @src Monoid
04:59:13 <lambdabot> class Monoid a where
04:59:13 <lambdabot>     mempty  :: a
04:59:13 <lambdabot>     mappend :: a -> a -> a
04:59:13 <lambdabot>     mconcat :: [a] -> a
04:59:26 <pozic> mauke: store really big structures as trees.
04:59:30 <temoto> @src Monad
04:59:31 <lambdabot> class  Monad m  where
04:59:32 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
04:59:34 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
04:59:36 <lambdabot>     return      :: a -> m a
04:59:38 <lambdabot>     fail        :: String -> m a
04:59:44 <temoto> @src Applicative
04:59:44 <lambdabot> class Functor f => Applicative f where
04:59:44 <lambdabot>     pure  :: a -> f a
04:59:44 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
04:59:55 <quicksilver> temoto: that's a bit spammy.
04:59:59 <temoto> Sorry.
05:00:06 <quicksilver> temoto: you can use private message too :)
05:00:19 <temoto> I think i should install \bot to my pc.
05:00:25 <temoto> oh
05:00:29 <temoto> or that, thanks
05:00:36 <ivanm> temoto: AFAIK, lambdabot is rather fiddly to get working on your local machine :s
05:00:53 <FauxFaux> "rather" hee hee.
05:01:14 <SubStack> hooray, I can now find all* function composition chains between two types from a pool of monomorphic functions
05:01:14 <ivanm> ?
05:01:15 <zygoloid> especially if you have the audacity to have GHC 6.12 installed
05:01:23 <SubStack> for some value of all
05:01:26 <SubStack> http://modzer0.cs.uaf.edu/~substack/snippets/findPaths.hs
05:01:27 <ivanm> SubStack: \o/
05:01:39 <ivanm> of course, the question arises... why do you want such a thing?
05:02:03 <SubStack> why indeed
05:02:17 <SubStack> type-safe genetic programming is the idea
05:02:29 <pozic> SubStack: and why would you want to do that?
05:02:32 <SubStack> with real haskell instead of some dsl
05:03:00 <pozic> AFAIK, genetic programming is an economic failure.
05:03:09 * quicksilver laughs at pozic.
05:03:11 <SubStack> pozic: undergraduate research
05:03:16 <SubStack> economic failure?
05:03:25 <quicksilver> personally I enjoy spending most of my time doing things which are an economic failure.
05:03:30 <pozic> quicksilver: and why is that?
05:03:32 <quicksilver> it's hardly a criterion I worry about.
05:03:36 <opqdonut> does he mean "an economic way of failing"?
05:03:37 <opqdonut> :)
05:03:39 <ivanm> quicksilver: and turning them into economic successes?
05:03:43 <ivanm> or not worrying about that part of it?
05:03:45 <quicksilver> no
05:03:53 <quicksilver> using other criteria to decide what to do
05:03:59 <quicksilver> like what I enjoy, or what other people have asked me to do
05:04:00 <pozic> quicksilver: fair enough.
05:04:29 <vegai> that's usually what economic non-failure do
05:04:41 <vegai> only with the exception that people will also pay while they're asking
05:04:47 <SubStack> also on some other level, when I write programs in haskell I'm mostly just matching up types
05:04:51 <SubStack> might as well automate that
05:05:25 <pozic> If something does not make real value or money (which is not real value) then it is fairly pointless to do so. In the case of genetic programming, there are better approaches, so it is not interesting from a theoretical point of view and from a economic point of view they just require more resources than "doing it by hand".
05:05:38 <SubStack> with some ghc hacks I should even be able to do polymorphic functions
05:05:50 <manjunaths> I have defined data WordF = Word16 | Word8, how do I convert a type of Word16 that I get from some haskell library to WordF ?
05:06:13 <mauke_> manjunaths: foo x = Word8
05:06:18 <zygoloid> pozic: do you include personal utility in "real value"?
05:06:25 <pozic> zygoloid: yes
05:06:31 <manjunaths> hmmm
05:06:32 <SubStack> pozic: hence, research
05:06:34 <pozic> zygoloid: sort of being equal
05:06:41 <ivanm> yay, by using Text rather than plain Strings, my code is _slower_ by a significant factor!
05:06:47 <SubStack> haskell is pretty good for research I hear
05:06:50 <pozic> SubStack: yes, but why research something which has already been superceded?
05:07:06 <SubStack> by what?
05:07:13 <ivanm> AFAICT, it's because of how I'm converting from Text.PrettyPrint
05:07:18 <pozic> SubStack: although for undergraduate stuff it is a nice exercise.
05:08:02 <pozic> SubStack: Optimal Ordered Problem Solver, for example.
05:08:26 <pozic> SubStack: or Levin Search.
05:09:02 <pozic> SubStack: Towers of Hanoi has been solved by OOPS. Genetic programming never has done that.
05:09:36 <pozic> Genetic programming has little to no theoretical basis.
05:10:38 <osfameron> I thought genetic programming was fairly heavily used in, e.g., handwriting recognition etc. ?
05:11:51 <flux> IMO it seems doubtful, but perhaps it could be used there
05:13:49 <flux> osfameron, but then again I have very little knowledge of GA :). there's a free book called "essentials of metaheuristics" for a practical overview of these matters
05:14:59 <gh_> hi
05:15:40 <gh_> has anyone successfully compiled and installed the haskell platform on ubuntu hardy ? during the checkinstall (==make install) step, i get such an error : "*** glibc detected *** ./Setup: munmap_chunk(): invalid pointer: 0xbf96fe43 ***"
05:15:54 <ivanm> gh_: there are debian packages you can probably use
05:16:00 <luqui> Does anyone know of a reasonably expressive definitional type system?    i.e. where types are defined by Foo = ..., and you can substitute ... for Foo anywhere and it will still typecheck
05:16:00 <lambdabot> luqui: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:17:36 <gh_> ivanm, yes, but i was so close :D
05:18:52 <temoto> I can't get it, how to write custom applicatives.
05:19:33 <luqui> temoto, what are you trying to write?
05:19:41 <temoto> luqui: a zipper for lists.
05:20:44 <luqui> temoto, zipper as in the "zip" function, or as in a list with a hole in it?
05:21:17 <temoto> luqui: second.
05:21:38 <temoto> luqui: i'm not sure why do you say 'hole', though.
05:21:42 <temoto> http://en.wikipedia.org/wiki/Zipper_(data_structure)
05:22:25 <gh_> so, is there a bad interaction between the libc6 of ubuntu 8.04 and ghc 6.10.4 ?
05:22:25 <luqui> temoto, er, the one with a hole in it is half of a zipper.  the thing that goes in the hole is the other half..
05:22:42 <luqui> i unfortunately conflate the "derivative" (structure with a hole) with the zipper itself.
05:22:53 <gh_> the version is glibc-2.7-1
05:23:19 <luqui> temoto, anyway, what do you want the applicative to do?
05:23:32 <luqui> i think there is a canonical one, but define it anyway.
05:23:49 <zygoloid> is it fair to say that a general zipper for a type T(X) = X * dT/dX ?
05:24:57 <zygoloid> or do we also need some way to zip across the structure? :)
05:25:31 <luqui> zygoloid, no i think that pretty much nails it.
05:25:48 <jokeNeedsHelp> hi, anybody here who can help me with bintrees in monads?
05:26:05 <luqui> temoto, a good place to start is to define what liftA2 (,) should do.  Then (<*>) = liftA2 ($)
05:26:13 <jokeNeedsHelp> im really frustrated about a last exercise i have to solve for university
05:26:21 <temoto> luqui: like z2 = (:1) <*> (pure [])
05:26:42 <temoto> no 1:
05:26:57 <luqui> temoto, you mean (1:) <$> pure [] ??
05:27:25 <temoto> i was thinking about applicative, not functor, but semantically yes
05:27:36 <kamatsu> jokeNeedsHelp: bintrees and monads?
05:27:46 <kamatsu> jokeNeedsHelp: they aren't necessarily related
05:27:57 <luqui> temoto, well <*> and <$> are pretty different things, and (1:) <*>  doesn't make a lot of sense
05:28:10 <luqui> :t ((1:) <*>)
05:28:10 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[t]'
05:28:10 <lambdabot>     Probable cause: `:' is applied to too many arguments
05:28:10 <lambdabot>     In the first argument of `(<*>)', namely `(1 :)'
05:29:16 <jokeNeedsHelp> yes ... i have to go through a int-bintree by inorder and set every entry to a fibonacci number in right order
05:29:20 <jokeNeedsHelp> and this
05:29:21 <zygoloid> luqui: re your 'existential typeclass' blog post: how do you do "windowSize $ withAttribute (window ...) (...)" with the record approach?
05:29:30 <jokeNeedsHelp> not normal, instead using monads
05:29:51 <maartenm> hello #haskell
05:30:07 <maartenm> does anyone know a flowchart generator or generator APi in haskell?
05:30:07 <luqui> zygoloid, I'm sorry I don't understand what you are asking...
05:30:08 <mauke> jokeNeedsHelp: which monad_
05:30:24 <maartenm> or another fun language, I need to generate a big flowchart and want it to be fun
05:30:31 <luqui> zygoloid, oh, I see
05:30:39 <jokeNeedsHelp> the problem is that i dont understand the basic system behind the monad do code a thing i explained above in a monad
05:30:44 <zygoloid> luqui: with a typeclass, you can write a general function :: (Widget w) => w -> w, and then you can run w-specific functiosn such as 'windowSize' on the result
05:30:52 <zygoloid> with the record, you don't seem to be able to do that.
05:31:27 <mauke> jokeNeedsHelp: which monad?
05:31:29 <luqui> zygoloid, it is true. withAttribute was the only function which carried assumptions through.
05:31:33 <kamatsu> jokeNeedsHelp: sounds like something easily done with a Reader monad
05:31:43 <kamatsu> is that the monad you're using?
05:31:53 <jokeNeedsHelp> @ mauke : what do u mean with "which monad"
05:31:55 <mauke> Reader? sounds more like State to me
05:32:02 <mchase> hello
05:32:09 <jokeNeedsHelp> yes state could be the right thing
05:32:09 <mauke> jokeNeedsHelp: there's more than one
05:32:11 <kamatsu> mauke: it's just reading fibonnaccis, so no nead for state
05:32:25 <mauke> kamatsu: I'd like to see that
05:32:28 <kamatsu> oh wait
05:32:31 <kamatsu> now i see what you mean
05:32:33 <kamatsu> sorry, brain fail
05:32:34 <kamatsu> yes, state
05:32:54 <luqui> zygoloid, so you can't.  good catch.
05:32:58 <jokeNeedsHelp> i can try to translate my german exercise description to english
05:33:19 <kamatsu> jokeNeedsHelp: well, how about i write what I think you mean, and then you tell me if it's right
05:33:24 <luqui> zygoloid, though I would consider the need to do that a semantic bug in the library that the record approach would clean out for you.   but you're correct that the record is less expressive here.
05:33:35 <jokeNeedsHelp> ok kamatsu
05:33:45 <luqui> i.e. without exposing Window's withAttribute implementation separately.
05:33:49 <jokeNeedsHelp> i think state monad is right
05:34:02 <mauke> jokeNeedsHelp: is the exercise online somewhere?
05:34:04 <jokeNeedsHelp> maybe we write in a querry?
05:34:17 <jokeNeedsHelp> @ mauke : yes, but its written in german
05:34:24 <mauke> link?
05:34:32 <jokeNeedsHelp> http://inpud2.cs.tu-dortmund.de/cms/material/FP%C3%9C/Blatt12.pdf
05:34:36 <zygoloid> luqui: but if you expose a separate withAttribute, any code which wants to be generic needs to use (something morally equivalent to) a typeclass for withAttribute :)
05:34:42 <jokeNeedsHelp> exercise 12.1
05:35:29 <mauke> jokeNeedsHelp: ok, your monad is Mark
05:35:32 <quicksilver> luqui: you are wrong that (IO a, a -> IO a) ~~ Mu IO ()
05:35:35 <jokeNeedsHelp> ok
05:35:41 <mauke> which is a specialization of State in the libraries, but whatever :-)
05:35:42 <luqui> quicksilver, oh?
05:35:48 <jokeNeedsHelp> is it a special basic monad?
05:35:55 <quicksilver> luqui: yes, your embedding only ran the first action (IO a) once
05:36:06 <mauke> jokeNeedsHelp: it's not very special
05:36:08 <kamatsu> mauke: Mark?
05:36:11 <quicksilver> luqui: in fact you have the freedom to run it lots of times, and it will in general return different as
05:36:11 <pozic> gh_: I recommend not living in the Stone Age of computing.
05:36:23 <quicksilver> luqui: and you can keep some of these as around to use later if you want to
05:36:24 <jokeNeedsHelp> or is my newtype Mark a = Label {trans :: Integer -> (a, Integer)} allready a monad?
05:36:28 <mauke> kamatsu: newtype Mark a = Label {trans :: Integer -> (a, Integer)}
05:36:31 <quicksilver> luqui: (and later pass them to the second action)
05:36:48 <mauke> the first thing you have to do is write an instance Monad Mark
05:36:48 <jokeNeedsHelp> is this newtype definition allready a monad?
05:36:58 <jokeNeedsHelp> i got this so far :
05:37:03 <gh_> pozic, is glibc-2.7-1 considered old?
05:37:16 <jokeNeedsHelp> instance Monad Mark where
05:37:20 <jokeNeedsHelp> ...
05:37:35 <jokeNeedsHelp> but i dont know what to do behind that
05:37:48 <zygoloid> luqui: you can fix it with something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16581#a16581
05:38:15 <mauke> jokeNeedsHelp: well, you need to define 'return'
05:38:41 <jokeNeedsHelp> my instance Monad Mark will return something?
05:39:09 <temoto> :t ((1:)<$>)
05:39:09 <mauke> jokeNeedsHelp: have you ever seen a Monad before?
05:39:10 <lambdabot> forall t (f :: * -> *). (Num t, Functor f) => f [t] -> f [t]
05:39:12 <kamatsu> jokeNeedsHelp: "return" is a bad name
05:39:19 <luqui> quicksilver, hm, i was about to clarify with an example, but i can't come up with one.  Can you give a concrete example using (IO a, a -> IO a) that can't be encoded as a Mu IO ?
05:39:31 <jokeNeedsHelp> yes ... i wrote a very simple on
05:39:42 <jokeNeedsHelp> a moment please ...
05:39:50 <temoto> kamatsu: how do you think if 'raise' would be a better name? :)
05:40:22 <kamatsu> temoto: i prefer "unit"
05:40:23 <jokeNeedsHelp> i tried to practice monads by coding the fibonacci function as a monad
05:40:32 <jokeNeedsHelp> i can send u the code as a querry
05:40:54 <mauke> use a paste site
05:41:05 <luqui> zygoloid, I would be happy to settle on "it's less expressive".   Doing encodings like this is kind of contrary to the point about being direct and saying what you mean.
05:41:07 <abccc> hello, how can I make length work on a IO [String] list ?
05:41:12 <luqui> once you start playing tricks, think again...
05:41:32 <luqui> abccc, fmap!
05:41:47 <quicksilver> luqui: let (a,b) = blah in do { a1 <- a; a2 <- a; b1 <- b a2; b2 <- b a1; return (a1,a2,b1,b2) }
05:41:55 <luqui> abccc, length :: [String] -> Int,  fmap length :: IO [String] -> IO Int
05:42:08 <abccc> luqui thank you I will look into fmap
05:42:09 <quicksilver> luqui: (OK the return value can't escape, but you can use it for future invocations of a,b so the information isn't useless.
05:42:35 <luqui> quicksilver, i would prefer if the example were closed.
05:42:44 <luqui> is it okay to drop the return?
05:43:00 <quicksilver> luqui: sure.
05:43:36 <quicksilver> luqui: my point is you have a tree-structure because you can use each 'a' you return multiple times and you can produce as many as as you want by any micture of running the first action, or running the second action with a previous a.
05:43:47 <quicksilver> luqui: whereas your Mu IO is a pretty linear thing.
05:43:57 <kamatsu> jokeNeedsHelp: so, do you understand what a monad is?
05:43:58 <luqui> let mu = blah in do { a1 <- mu; a2 <- mu; b1 <- a2; b2 <- a1 }     -- modulo unwrapping
05:44:04 <Botje> @src last
05:44:04 <lambdabot> last [x]    = x
05:44:04 <lambdabot> last (_:xs) = last xs
05:44:04 <lambdabot> last []     = undefined
05:44:19 <kamatsu> jokeNeedsHelp: if you just need us to explain the state monad, we can do that, but if it's more a complete monad tutorial, i point you to the numerous ones that exist
05:44:33 <dolio> quicksilver: I think you save the 'a' by saving the corresponding result of the a -> IO a.
05:44:34 <luqui> it is not so linear :-)
05:45:28 <mauke> kamatsu: I'm talking to him in /query
05:45:30 <dolio> Any 'a' you get can be immediately be passed to the a -> IO a to get an IO a, and you can pass that around instead.
05:45:44 <mauke> I'm not sure if he has seen typeclasses before
05:46:01 <temoto> He surely have seen interfaces, right?
05:46:08 <dolio> Or an IO (Mu IO), as the case may be.
05:46:21 <kamatsu> ah
05:46:32 <luqui> dolio, that is a good way to think about it.
05:47:33 <dolio> The outermost level of the Mu IO corresponds to the IO (Mu IO) you get from fmapping the single IO a with the builder, so the Mu IO you can get from it varies over time, just like the a you get from the IO a.
05:50:48 <pozic> gh_: old/new doesn't really matter. I can imagine nobody else uses your exact configuration, so while it might work, there is a far higher probability of it working if you use the same as most other people.
05:52:20 <gh_> well, ubuntu 8.04 is a long term release (updated until april 2013), so maybe i'm not alone
05:53:32 * eevar2 shot for arch linux on the new laptop. as debian _testing_ still only has ghc6.8
05:53:47 <vegai> eevar2: beware, we have 6.12
05:54:03 <eevar2> forgive my random debian-bashing, btw ;)
05:55:02 <pozic> All this "stable software" concepts are basically non-sense. Either the developer feels it is solid, or he doesn't.
05:55:26 <pozic> Software doesn't work by hoping that it does.
05:56:00 <pozic> For platform specific code, things might be different, but that's only a tiny fraction of the system.
05:57:01 <MWR_User> what are some pratical uses for haskell?
05:58:09 <shepheb> I've found it excellent for writing software. Not so good at other things.
05:59:39 <vegai> if you're using the *language* for writing software, we're essentially talking about compilers, right?
06:00:40 <shepheb> vegai: no, I mean I use Haskell to write pretty much any kind of software. By "other things" I meant that it doesn't fight crime or clean up the atmosphere.
06:01:15 <kamatsu> in addition to writing software, haskell can be used to prove things
06:01:19 <vegai> although it could be used to write software that fights crime
06:01:21 <kamatsu> somewhat informally
06:01:35 <pozic> Can I instruct ghci to show MYMODULE.ST as ST?
06:01:42 <vegai> mental masochism, perhaps?
06:02:04 <ddarius> It probably has been used to write software that fights crime.
06:02:05 <vegai> in some ways, I suppose, it can be used for extreme nitpicking
06:02:37 <shepheb> Perhaps "breaking down programmers' brains to build them back up again" is a practical use.
06:02:50 <jlouis> eevar2: debian testing only has ghc6.8 because too many bugs are filed against 10.4 I guess
06:04:52 <pozic> jlouis: so by Debian logic 10 is worse than 8?
06:05:44 <vegai> pozic: they follow a process
06:05:49 <vegai> diligently
06:05:58 <pozic> vegai: and that process is?
06:06:17 <vegai> fix bugs before allowing progress
06:06:24 <vegai> I suppose?
06:06:43 <pozic> vegai: I think the idea is that 6.10 fixes bugs in 6.8.
06:06:47 <The_third_man> Hi
06:06:54 <pozic> vegai: and it introduces a few new features.
06:07:26 <pozic> vegai: and I don't see anyone backporting the fixed to Testing.
06:07:29 <pozic> fixes*
06:07:37 <pozic> So, it is just a stupid excuse.
06:08:16 <pozic> The fact that Debian exists is a great thing, but it has nothing to do with "process". More with lack of qualified people to implement the process, I suppose ;)
06:08:16 <The_third_man> http://paste.pocoo.org/show/170219/ << I'm starting Haskell, and I dont understand why i got an "infinite type" error on my delListe wich is a fold function removing an element n from my own list type
06:08:46 <jlouis> pozic: yes. Debian is not about the logic that 10.4 has other things that outweighs the bugs
06:10:09 <pozic> The_third_man: because your definition is bogus :)
06:10:20 <pozic> The_third_man: your second equation in particular.
06:10:38 <pozic> The_third_man: and then the Cons constructor to be specific.
06:10:57 <pozic> The_third_man: look how a real fold is written. Your code is simply wrong.,
06:12:14 <pozic> @src foldl
06:12:14 <lambdabot> foldl f z []     = z
06:12:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:12:16 <pozic> @src foldr
06:12:16 <lambdabot> foldr f z []     = z
06:12:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:12:35 <pozic> The_third_man: see? No Cons on the RHS there.
06:13:33 <The_third_man> yes, but, when I use foldr, my list does not exist anymore ?
06:13:56 <The_third_man> or is it f wich returns a list ?
06:17:26 <Saizan> fold combinators typically let their arguments decide what to construct
06:17:36 <Saizan> they only help with the consuming part
06:18:15 <Saizan> so, if you want to make a function Liste a -> Liste a, it'll be 'f' and 'n' that'll build the components of the resulting list
06:19:46 <The_third_man> ok, thx
06:22:25 <pozic> The_third_man: how exactly are you learning Haskell?
06:23:33 <The_third_man> pozic, with a tutorial, why ?
06:25:05 <pozic> The_third_man: that's a bad idea. You should read a book written by someone qualified.
06:26:10 <The_third_man> pozic, actually the person is qualified
06:27:15 <kamatsu> The_third_man: who is this person?
06:27:17 <The_third_man> but, on this part of code, I tried to make my own type, and create a fold function
06:27:26 <The_third_man> a french guy called Gnomnain
06:28:54 <Banana_> What should I use to make mutable doubly linked lists?
06:29:03 <Zao> Tears?
06:29:05 <shepheb> C?
06:29:06 <Banana_> IORef?
06:29:09 <pozic> Banana_: STRef
06:29:10 <mauke> IORefs
06:29:30 <pozic> Banana_: I already implemented one. Long live capitalism for not sharing.
06:29:43 <Ke> http://www.haskell.org/haskellwiki/Tying_the_Knot ?
06:29:51 <pozic> Ke: fail.
06:29:58 <mauke> Ke: those are not mutable
06:30:22 <Ke> hmm you mean as in global variables oslt
06:30:33 <Ke> nvm
06:30:35 <pozic> Ke: it has nothing to do with global variables.
06:34:04 <Banana_> it should be possible to create a link to the value constructor you are currently constructing
06:34:39 <ddarius> @instances MonadFix
06:34:40 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:37:06 <Botje> @src sum
06:37:06 <lambdabot> sum = foldl (+) 0
06:37:13 <Banana_> eg. "cell { left = prev, right = create THIS, item = something}" where create will use THIS as prev in a new cell and THIS refers to the cell being constructed
06:37:21 <Banana_> but of course I bet that is not possible
06:37:55 <ddarius> Banana_: You are going to need a monadic action, but otherwise, yes that is possible.
06:39:04 <Botje> @src foldl'
06:39:04 <lambdabot> foldl' f a []     = a
06:39:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:39:15 <ddarius> mdo next <- create this; this <- makeCell prev next stuff; return this
06:39:52 <Banana_> yeah
06:40:04 <Banana_> just a little annoying
06:41:05 <Banana_> but I guess it is Just annoying or Nothing, harr harr
06:42:33 <Banana_> I think I will just abuse everything and use IORef
06:45:36 <haskellabuse> is there any place where I can annoy purists with this?
06:52:24 * hackagebot upload: graphics-drawingcombinators 1.0.3 - A functional interface to 2D drawing in OpenGL (LukePalmer)
06:53:24 <mreh> hgalib has been uploaded with .hi files, can I download it, unpack and remove them, then install it manually?
06:53:24 <lambdabot> mreh: You have 1 new message. '/msg lambdabot @messages' to read it.
06:53:37 <mreh> @messages
06:53:38 <lambdabot> lament said 19h 55m 50s ago: Can you credit me somewhere? Also why do you have Modes as well as scales?
06:54:14 <Saizan> mreh: why not?
06:54:42 <Saizan> cabal unpack hgalib btw
06:54:43 <mreh> Saizan: I'm afraid
06:55:47 <mreh> what is an .hi file anyway?
06:55:56 <mreh> like a haskell object file
06:56:06 <Saizan> the object file is .o
06:56:14 <Cale> mreh: It's additional information which doesn't come in the .o which GHC needs to link things.
06:56:16 <mreh> that's a C object file
06:56:31 <Saizan> it's the same :)
06:56:50 <Saizan> .hi corresponds to .h files in C, but they are generated by ghc
06:57:06 <Cale> By the time it's a .o the original language is long gone :)
06:57:59 <Cale> .o files contain native machine code
07:00:19 <mreh> so it's been unpacked, run "find /var -name \*.tmp -ok rm {} \"
07:00:33 <mreh> now what should i do?
07:00:46 <mreh> not *.hi
07:01:00 <mreh> not *.tmp,  *.hi
07:01:21 <Saizan> run "cabal install" from inside the directory
07:01:28 <mreh> ah yes
07:01:29 <mreh> no args
07:02:02 <Saizan> and there's "cabal clean" btw
07:02:08 <kamatsu> Saizan: yes there is ?
07:02:22 <Saizan> kamatsu: ?
07:02:28 <kamatsu> Saizan: oh, sorry
07:02:29 <mreh> was that a question?
07:02:38 <kamatsu> Saizan: i read that as "and there's no "cabal clean" btw
07:02:39 <kamatsu> sorry, tired
07:03:01 <Saizan> mreh: i meant that you could have used "cabal clean" instead of the find incantation
07:03:48 <mreh> it's a pretty horrible way of recursively deleting files
07:03:55 <mreh> rm -r *.hi wont work
07:04:02 <mreh> it's not cleverer
07:09:19 <mreh> this is a bug in ghc 6.10 then? this .hi file malarkay
07:22:05 <Cale> mreh: what?
07:22:33 <mreh> 6.10 dies when you give it a .hi from another machine
07:22:45 <Cale> mreh: Well, yes.
07:22:51 <Lycurgus> lol
07:23:05 <Cale> .hi files are temporary files created while building code
07:23:11 <Cale> You're not meant to keep them.
07:23:32 <mreh> can it not remove them and make new ones>
07:23:42 <mreh> if they're only temporary
07:23:48 <zygoloid> mreh: rm **/*.hi  ;-)
07:24:25 <Cale> It could, but it tries not to recompile things which it's already compiled.
07:24:41 <Cale> Unfortunately, if it gets .hi files from a different version of GHC, it mostly just gets confused.
07:26:50 <pozic> Cale: most people would call that a bug.
07:27:52 <jogla> In our lecture, we've been given the type of an if statement as "for all a: Bool -> a -> a ->", with three a
07:28:17 <mux> yes, that makes sense
07:28:23 <jogla> do you know why there are three? I would have expected something like one a
07:28:40 <mux> jogla: the first two are the then and else clauses, the final one if the return type of the function
07:28:48 <jogla> Ahh
07:28:48 <mux> :t \b x y -> if b then x else y
07:28:49 <lambdabot> forall t. Bool -> t -> t -> t
07:29:03 <jogla> Thank you
07:29:19 <mux> you're welcome
07:29:41 <mreh> thx zygloid
07:30:32 <chris_N> Hello. Does anyone know if template haskell can be used to write program transformations?
07:30:44 <chris_N> For example, a function:
07:30:53 <chris_N> cpsConvert :: Dec -> Dec
07:31:11 <mreh> globbing is witchcraft
07:31:45 <mreh> zygoloid, ^ thanks
07:32:06 <Saizan> chris_N: sure
07:33:02 <chris_N> Saizan: Is there anywhere that explains how to do this?
07:34:15 <Saizan> chris_N: not sure
07:34:34 <Saizan> the hard way is to just pattern match on the AST and produce the one you want
07:35:50 <jogla> I have been asked to give the type of "\x.if x x"
07:36:04 <jogla> So I would say it's Bool -> Bool -> Bool -> Bool
07:36:05 <chris_N> That wouldn't be too bad...
07:36:18 <Saizan> wrong :)
07:36:19 <zygoloid> jogla: not quite
07:36:20 <jogla> Because there are two "x" and the first must be Bool
07:36:31 <chris_N> .... : -(
07:36:38 <jogla> Ahh, 5 times Bool?
07:36:45 <zygoloid> jogla: you're close though. how many more values is 'if' expecting?
07:36:55 <jogla> Only two
07:37:13 <zygoloid> it's already got two. so how many more? :)
07:37:37 <chris_N> When I say it wouldn't be too bad, I mean that is exactly what I'd like to do
07:37:37 <jogla> ahh, only one, and one return value
07:37:52 <chris_N> but I'm aware it's tricky
07:37:57 <zygoloid> right, plus 'x' itself
07:38:09 <Saizan> chris_N: the "wrong" was for jogla there
07:39:06 <jogla> So, because it already has two x, the type is Bool -> Bool -> Bool?
07:39:18 <zygoloid> that's right.
07:39:26 <jogla> Thanks!
07:39:35 <zygoloid> it might be interesting to figure out what it does, too.
07:41:00 <jogla> Hmm
07:41:08 <MissPiggy> what should the operator for a group be in haskell?
07:41:09 <jogla> Does it something I should now?
07:41:19 <jogla> *know
07:41:40 <chris_N> Saizan: Ah, ok, so say I had written my function f:: Dec -> Dec, do you know how I can go about actually using it (or who I should ask to find out)?
07:42:13 <Cale> MissPiggy: Should there even be a single answer?
07:42:34 <MissPiggy> I have to pic something for class Group g where
07:42:34 <Saizan> chris_N: $(liftM (map f) [d| ..your code here.. |])
07:43:08 <nbowler> MissPiggy: * or perhaps ã»
07:43:32 <Cale> nbowler: whoa, a fullwidth character? :)
07:43:32 <chris_N> Can it be done without having to have the 'your code here' part? So like this:
07:43:43 <chris_N> $(liftM (map f) [d| g |])
07:43:59 <chris_N> where g is the function to be transformed
07:44:44 <zygoloid> jogla: yes. it's one of the better known operators in boolean algebra
07:44:50 <Saizan> chris_N: you can't access the code for a function by simply having it in scope
07:45:05 <nbowler> Cale: ah, my input method may have not produced the right symbol when I asked it for "cdot".
07:45:10 <chris_N> Saizan: No...
07:45:25 <Saizan> chris_N: you've to quote the sources directly
07:45:30 <Cale> Â·
07:45:31 <quicksilver> dolio: no, you can use it more than once.
07:45:39 <Saizan> [d| .. |] is the quotation syntax for declarations
07:45:43 <quicksilver> dolio: and it will have different effects each time you feed it to a -> IO a
07:46:09 <dolio> Use what more than once?
07:46:20 <jogla> zygoloid: It's an or!
07:46:20 <MissPiggy> what do you think about nil and ++ for monoid?
07:46:35 <quicksilver> dolio: oh, I see.
07:46:40 <quicksilver> dolio: yes, you're right.
07:47:08 <quicksilver> MissPiggy: I favour an asymmetric symbol for monoid (perhaps +>) but not strongly.
07:47:12 <nbowler> MissPiggy: I think * is better (and more conventional) than ++.
07:47:23 <quicksilver> MissPiggy: I like +> because you can define (<+) = flip (+>)
07:47:48 <zygoloid> jogla: yep :)
07:47:51 <quicksilver> @tell luqui ah yes. I see. Good point.
07:47:51 <lambdabot> Consider it noted.
07:47:58 <zygoloid> @check \x y -> if x then x else y == x || y
07:47:59 <lambdabot>   "OK, passed 500 tests."
07:48:01 <Cale> I'd like to generalise ++ for use with monoids.
07:48:15 <jogla> zygoloid: Thanks for your help
07:48:19 <zygoloid> no problem
07:48:40 <chris_N> Saizan: So there isn't a way of writing a set of transformations and applying them to some source without having the source inside some [| ... |] ?
07:48:44 <quicksilver> > let (+>) = mappend; (<+) = flip (+>) in ("foo" +> "bar","foo" <+ "bar")
07:48:45 <lambdabot>   ("foobar","barfoo")
07:49:05 <Cale> I haven't run into enough instances of things which *needed* to be groups while programming that I'd ever seriously considered defining a typeclass.
07:49:15 <Saizan> chris_N: not that i know of
07:49:31 <chris_N> Saizan: Ok, thanks.
07:50:16 <quicksilver> Cale: in particular for groups to be interesting you'd presumably need to care about cancellation. I wonder if you'd do that dynamically or statically.
07:50:33 <Saizan> chris_N: it'd be nice, but hard to make it work across modules in GHC, most of the sources are thrown away during compilation
07:50:51 <Cale> I think if I was designing a computer algebra system as a collection of Haskell libraries, groups would be a data type, rather than a class.
07:51:08 <chris_N> Saizan: That makes sense
07:51:44 <pozic> Cale: so, you would basically replicate the OCaml functor system?>
07:51:51 * Saizan loves the fact that dep. typed languages have to keep the sources around for typechecking anyway
07:51:56 <Cale> pozic: Huh?
07:52:20 <pozic> Cale: I assume that you want the users to be able to instantiate those group structures.
07:52:24 <Cale> No, I mean, you'd probably want to do various things to manipulate groups, like take semidirect products and such.
07:52:35 <Cale> So it would be awkward to put them on the type level.
07:52:53 <Cale> I'd love an implementation of GAP in Haskell :)
07:53:04 <Saizan> yeah, you'd have a term algebra with a suitable signature, so you can do symbolic manipulation
07:53:30 <Cale> Yeah, I wonder what the right representation looks like...
07:53:33 <chris_N> Saizan: thanks for your help!
07:53:58 <Cale> If you were really serious about it, there would be quite a few special cases that you'd want to deal with.
07:54:50 <Saizan> chris_N: np
07:54:56 <jmcarthur> MissPiggy: you're back! you had a question about constraint synonyms i think, but i never got to answer it
07:55:07 <Cale> (various special types of groups have algorithms which work well on them, while the problems for arbitrary groups are often intractable)
07:55:15 <MissPiggy> I didn't have any particular question
07:55:32 <jmcarthur> i'm trying to remember what it was
07:55:58 <jmcarthur> i think you were asking what the point was or something
07:56:07 <MissPiggy> jmcarthur are you replacing prelude
07:56:08 <jogla> I have another type that I think isn't possible, it's 2b in http://verify.rwth-aachen.de/fp09/Uebungen/sheet12.pdf
07:56:14 <jmcarthur> MissPiggy: eventually yes
07:56:44 <jogla> I think it's not possible because in the end, Cons a (List a), the first a is (x y), and the second list should then be List (x y), but y can't be List (x y)
07:57:05 <Cale> jogla: what?
07:57:41 <Cale> jogla: You seem to be mixing up types and terms
07:58:02 <Cale> List is something on the type level. x and y are on the value level.  List (x y)  makes no sense.
07:58:23 <Cale> That lambda term does typecheck.
07:58:24 <Saizan> unless x is a variable of kind * -> *
07:58:43 <Cale> Yeah, but it's not. It's bound by the lambda
07:58:48 <Saizan> k
07:58:49 <mauke> what's a shallow type schema?
08:00:11 <McManiaC> how do you handle C signals in haskell?
08:00:27 <quicksilver> McManiaC: System.Posix.Signal or something thereabours
08:00:34 <quicksilver> @hoogle signal
08:00:34 <lambdabot> Control.Concurrent.QSem signalQSem :: QSem -> IO ()
08:00:34 <lambdabot> Control.Concurrent.QSemN signalQSemN :: QSemN -> Int -> IO ()
08:00:41 <quicksilver> no, that's not it ;)
08:00:44 <Cale> jogla: It's best to be systematic here. We see that this thing is a function of (at least) two parameters, so let's start by saying that \x y -> Cons Nil (Cons (x y) y) :: a -> b -> c, and then we'll try to refine our understanding of a, b, and c.
08:01:10 <Cale> So we have x :: a, and y :: b, and we know that Cons Nil (Cons (x y) y) :: c
08:01:31 <McManiaC> quicksilver: kay
08:01:50 <Cale> Cons :: forall t. t -> List t -> List t
08:02:09 <Cale> and so we know that  c :: List d  for some type d
08:02:17 <Cale> er
08:02:20 <Cale> and so we know that  c = List d  for some type d
08:02:24 <Cale> sorry
08:02:55 <Cale> and since the first parameter to the Cons is Nil :: forall t. List t, we know that  d = List e  for some type e
08:03:05 <Cale> So  c = List (List e)
08:03:36 <jogla> Hmm
08:03:55 <jogla> Why isn't c = Con Nil (con (a b) b)?
08:04:02 <Cale> c is a type
08:04:09 <Cale> Cons is on the value level
08:04:17 <Cale> c can't be equal to anything containing Cons
08:04:26 <Cale> Cons Nil (Cons (x y) y) :: c
08:04:31 <Cale> But they're not equal
08:04:33 <jogla> Ahh, ok
08:04:54 <Cale> and since we now know that c = List (List e)
08:04:57 <Cale> we have that
08:05:06 <Cale> Cons Nil (Cons (x y) y) :: List (List e)
08:05:12 <Cale> and consequently,
08:05:16 <Cale> Cons (x y) y :: List (List e)
08:05:22 <jogla> Hmm
08:05:27 <jogla> I need a second for that
08:06:06 <jogla> I think I just had the wrong syntax above, I don't understand why I can't say c :: Con Nil (Con (a b) b)?
08:06:08 <Cale> Becasue the second parameter to Cons must have the same type as the result of the Cons
08:06:22 <Cale> c is a type, it goes on the right of the ::
08:06:27 <jogla> Ah
08:06:35 <Cale> a and b are types, they also stay on the right of the ::
08:06:39 <jogla> Con Nil (Con (a b) b :: c
08:06:45 <jogla> Ah, ok
08:06:49 <Cale> Cons is a value, it stays on the left of the ::
08:08:56 <Cale> They're two separate worlds. Until you deal with dependent types (which allow values some upward social mobility), the :: will keep the values to the left (the guys who do all the work) and the upper class types on the right (the capitalist guys who tell the rabble what to do :)
08:09:39 <jogla> Hmm, ok
08:09:40 <BONUS> haha, eloquently put
08:10:01 <jogla> So I know I need a and b because of \x and \y
08:10:09 <jogla> and I will definitely return something
08:10:11 <elly> Cale: I like your metaphor
08:10:15 <jogla> So it's a -> b -> c
08:10:23 <Cale> It's not really mine, I stole it :)
08:10:37 <jogla> x :: a, y :: b, Con Nil (Con (x y) y :: c
08:10:37 <elly> :: is an instrument of oppression? :)
08:10:39 <jogla> Is that right?
08:10:45 <Cale> elly: yeah :)
08:10:58 <Cale> It's Conor McBride's analogy really :)
08:11:04 * elly is secretly a scheme programmer and does not believe in such things
08:11:06 <Cale> jogla: yeah
08:11:32 <jogla> But that's not finished yet, isn't it?
08:11:54 <Cale> elly: http://strictlypositive.org/winging-jpgs/
08:11:57 <Cale> jogla: Right
08:12:21 <Cale> jogla: The idea is just to introduce type variables for each of the subexpressions
08:12:35 <Cale> and then figure out all the equations between them which must exist
08:13:03 <elly> Cale: :)
08:13:54 <jogla> I'm not sure how to write it
08:14:05 <Cale> jogla: Okay, so we have so far:
08:14:08 <Cale> x :: a
08:14:09 <Cale> y :: b
08:14:10 <jogla> I definitely know that y has the type a
08:14:12 <jogla> Yeah
08:14:29 <Cale> Cons Nil (Cons (x y) y) :: c
08:14:46 <jogla> and that's of type List t too
08:15:03 <jogla> Cons Nil (Cons (x y) y) :: List t
08:15:18 <Cale> right, let's just use letters in order :)
08:15:25 <Cale> I used d for that above :)
08:15:28 <jogla> Ah, ok
08:15:38 <jogla> Cons Nil (Cons (x y) y) :: List d
08:15:45 <jogla> And can i say:
08:15:47 <Cale> (not that it matters, but we may need a bunch of them in general)
08:16:07 <Cale> Nil :: d here
08:16:17 <Cale> But Nil :: List e
08:16:24 <Cale> So d = List e
08:16:52 <Cale> yeah?
08:16:59 <jogla> Why is Nil :: List e?
08:17:10 <mauke> it's in the environment
08:17:13 <Cale> Because it is a list (of any type you might care to have)
08:17:30 <mauke> Aâ(Nil) = âÎ±. List Î±
08:17:30 <jogla> I don't understand why Nil has to be a list
08:17:35 <Cale> Nil :: forall t. List t
08:17:39 <jogla> Ah
08:17:43 <jogla> Ok
08:17:48 <jogla> That's right
08:18:04 <jogla> So Nil :: List e
08:18:38 <jogla> (x y) :: List e
08:18:42 <Cale> So yeah, we introduce a new type variable e in order to account for that forall, and it might be specialised to something else, or it might be left unspecialised and re-forall'd later.
08:19:22 <Cale> yep
08:19:37 <Cale> Because (x y) is another element of the same list, it had better have the same type
08:19:47 <Cale> and because it's a function application, we know that
08:19:51 <Cale> x :: f -> g
08:20:05 <Cale> and y :: f
08:20:21 <Cale> But x y :: List e as you just said
08:20:27 <Cale> So g = List e
08:20:39 <Cale> and we said before that x :: a
08:20:53 <Cale> So a = f -> List e
08:20:57 <jogla> I don't understand why it's a function
08:21:02 <jogla> There's no lambda
08:21:10 <elly> but there are arguments
08:21:11 <Cale> Because it must be in order to apply it to a parameter
08:21:33 <Cale> (x y) means "apply the function x to the value y"
08:21:49 <jogla> (x y) :: a -> b -> c (for totally different a b c)?
08:21:53 <jogla> Is that true?
08:21:56 <Cale> mmm... no
08:22:09 <Cale> x doesn't appear to have more than one parameter
08:22:33 <mauke> jogla: (x y) is not a function. x is.
08:22:36 <jogla> I want c to be the return type
08:22:49 <jogla> Hmm
08:23:37 <jogla> I don't understand why that's the case
08:23:57 <mauke> jogla: well, what else could x be?
08:24:04 <jogla> x :: f -> g, so x is a function that returns something of type g
08:24:25 <jogla> I initially though (x y) would be a typle
08:24:32 <jogla> So it would be a list of tuples
08:24:39 <mauke> no, that's (x, y)
08:26:43 <jogla> I don't see how x being a function would change the problem
08:27:03 <jogla> If I evaluate the function, there would be the return value of it and y
08:27:09 <jogla> So two value again
08:27:54 <Cale> jogla: It affects the overall type signature of the function because it is a parameter to the function
08:28:13 <Cale> jogla: So we know from this that the function must take a function as its first parameter.
08:28:17 <elly> :t (&&&)
08:28:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:28:30 <aavogt> jogla: if that was the case, how would you extract single values from the tuple?
08:28:48 <aavogt> you'd have   fst :: (a,b) -> (a,(a,b))
08:28:48 <idnar> what tuple?
08:29:08 <aavogt> [11:24:04]        jogla | I initially though (x y) would be a typle
08:29:39 <idnar> well, you could make (x y) the syntax for a tuple, I don't see why that would change the type of fst
08:30:16 <jogla> Cale: Ahh, ok
08:30:27 <jogla> But i'm still not sure why it has to be a function
08:30:34 <mauke> <mauke> jogla: well, what else could x be?
08:30:38 <jogla> What would y be?
08:30:44 <jogla> mauke: Haha
08:30:49 <jogla> Yeah
08:30:52 <jogla> I don't know
08:31:00 <Cale> jogla: Whenever you have something which looks like x y, x *must* be a function, and y *must* be a value of whatever type x takes as its parameter.
08:31:16 <Cale> jogla: Otherwise, the expression makes no sense.
08:31:26 <Cale> jogla: We use whitespace for function application.
08:31:28 <jogla> Ahh, so y is the parameter of x?
08:31:47 <kmc> many other languages would write that as x(y)
08:31:47 <jogla> Then it makes sense to me
08:31:50 <mauke> (technically, it's an argument, not a parameter)
08:32:14 <jogla> Ah
08:33:29 <kmc> (x y) :: B    if and only if   x :: A -> B and y :: A
08:34:30 <jogla> So x is a function, and (x y) is of type List e
08:34:45 <mauke> yes
08:35:10 * hackagebot upload: morfette 0.3 - A tool for supervised learning of morphology (GrzegorzChrupala)
08:35:16 <jogla> That function takes at least one argument, and has to evaluate to something of type List e
08:35:32 <mauke> s/at least/exactly/
08:36:01 <jogla> <jogla> (x y) :: a -> b -> c (for totally different a b c)?
08:36:06 <jogla> Why is that false then?
08:36:16 <jogla> ahh
08:36:18 <mauke> because (x y) :: List e
08:36:23 <jogla> Because, that's the type of x, not of (x y)
08:36:24 <jogla> ok
08:36:29 <mauke> it's not the type of x either
08:36:38 <temoto> json library seems to get ByteString support, but i don't get how to use it. There's Text.JSON.Generic.toJSON :: Data a => a -> JSValue and it seems to work, but incorrectly for non-ascii bytes.
08:36:47 <jogla> What is the type of x then?
08:36:49 <mauke> x :: f -> List e
08:37:01 <mauke> well, and f = b
08:37:11 <mauke> so it's really x :: b -> List e
08:37:19 <jogla> But where is the y?
08:37:24 <mauke> y :: b
08:37:37 <mauke> y is a value, it can't appear in a type signature
08:37:43 <Saizan> and x :: a from the start, so a = b -> List e
08:37:45 <temoto> > let s = Data.ByteString.Char8.pack "\"hello (non-ascii)\"" in Text.JSON.Generic.toJSON s
08:37:46 <lambdabot>   Not in scope: `Data.ByteString.Char8.pack'Not in scope: `Text.JSON.Generic....
08:38:14 <jogla> Ahh
08:39:46 <temoto> mauke: what's difference between argument and parameter?
08:40:21 <mauke> a parameter is the variable following a lambda
08:40:30 <mauke> \<parameter here> -> ...
08:40:44 <mauke> an argument is a value you apply a function to
08:41:51 <kmc> the parameter is a placeholder for where the argument goes when the function is applied
08:41:53 <temoto> Is that internal GHC terminology?
08:42:02 <kmc> that's mathematical terminology
08:42:05 <temoto> ah
08:42:11 <kmc> it's probably in the Haskell Report too
08:42:12 * hackagebot upload: printf-mauke 0.4 - A Perl printf like formatter. (LukasMai)
08:42:25 <temoto> right, haskell = math.. i should've think that first
08:42:34 <kmc> well, programming languages = math
08:42:58 <mauke> I've learned it from C
08:42:59 <luqui> void foo()...
08:43:00 <kmc> this nomenclature is used in many languages i believe
08:43:00 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
08:45:14 <MissPiggy> I can't program shit this sucks
08:45:46 <temoto> Evaluate it harder, you can!
08:45:47 <lispy> MissPiggy: Hi.  How's it going?
08:45:53 <MissPiggy> awful
08:45:59 <lispy> MissPiggy: why is thta?
08:46:09 <lispy> Homework got you downV
08:46:11 <lispy> ?
08:46:13 <MissPiggy> I just don't have whatever it is people need to do this
08:46:41 <lispy> heh, no one said learning a new language would be easy :)
08:46:54 <lispy> But, I'm sure you've already learned a ton
08:47:07 <MissPiggy> yeah I guess os
08:47:09 <MissPiggy> so*
08:47:17 <Raadad> miss piggy
08:47:18 <kmc> MissPiggy, you're working on the class hierarchy for abstract algebra?
08:47:46 <Raadad> haskell is not for wimps:(
08:47:54 <Raadad> im a wimp
08:47:55 <MissPiggy> I prettymuch give up, I don't think I am capable
08:47:58 <Raadad> but we all start as wimps
08:47:59 <kmc> haskell is for lovers
08:48:05 <MissPiggy> I tried to write this in two other languages
08:48:15 <lispy> kmc: I thought that was Virginia
08:48:17 <pozic> I don't see what's special about Haskell, but that's just me.
08:48:23 <kmc> MissPiggy, what's the end goal -- what are you trying to write?
08:48:36 <kmc> the stuff you were doing earlier seemed quite advanced
08:49:20 <pozic> Developing new algorithms in the quantum monad seems more complicated.
08:49:27 <Raadad> code written in java will look and run like somehting made in china, bits wont really fit together, break easy, made quickly cheaply dirty.
08:50:02 <Raadad> while haskell is like getting something made from a botique workshop in japan
08:50:09 <Raadad> but that all depends on who's coding
08:50:24 <Raadad> but lets say both things were made by supergeek coders
08:50:38 <aavogt> well which is more likely?
08:50:52 <kmc> yeah, i think the biggest effect here might be the set of people who know each language
08:50:58 * CalJohn is doesn't think you have to slag off other languages in #haskell just to fit in
08:51:12 <kmc> eventually Haskell will be popular enough that people learn it just to get a job
08:51:14 * hackagebot upload: darcs-beta 2.3.98.3 - a distributed, interactive, smart revision control system (ReinierLamers)
08:51:19 <kmc> then we will start to see lots and lots of bad Haskell code
08:51:20 <MissPiggy> doesn't make a difference
08:51:41 <Raadad> haskell is rigid
08:52:02 <Raadad> you wount be able to write junk in haskell unless you were trying to
08:52:06 <MissPiggy> nothing I do works, it doesn't make sense
08:52:13 <alp> Peaker, LUI looks very interesting. I'll take a deeper look soon
08:52:15 <mm_freak> IRC is such a crapâ¦  my parser is already over 200 LoC
08:52:28 <alp> mm_freak, there already is one on hackage IIRC.
08:52:29 <kmc> mm_freak, btw there's a parser on hackage
08:52:35 <MissPiggy> it's all so obvious and simple in my head but trying to get the computer to do it just breaks both of us
08:52:46 <kmc> Raadad, that's a serious overstatement
08:52:55 <alp> @hackage irc
08:52:56 <lambdabot> http://hackage.haskell.org/package/irc
08:52:56 <kmc> i've seen lots of junk Haskell code
08:52:59 <temoto> MissPiggy: i know that feeling.
08:53:01 <kmc> i've written lots of junk Haskell code
08:53:05 <alp> mm_freak, ^^^^
08:53:23 <mm_freak> alp, kmc:  i know, but firstly it does only the most basic token splitting, and also it works with String, but i want ByteString
08:53:25 <Raadad> but, lets say you had 5 hours to write something
08:53:33 <Raadad> would it be easier to write junk or good code in haskell
08:53:43 <pozic> kmc: I think there is more crap on Hackage than quality.
08:54:03 <kmc> pozic, certainly there is a lot of bitrot and half-baked packages
08:54:07 <pozic> kmc: so any signal, if it has every existed, is gone.
08:54:13 <pozic> ever*
08:54:16 <kmc> but that's preferable to having that stuff not out there at all
08:54:18 <MissPiggy> hopefully this will make me stop being so arrogant
08:54:25 <kmc> it should get a voting or usage tracking system though
08:54:25 * CalJohn doesn't think "quality code" is dependent on programmers, but on software engineering practices.
08:54:26 <MissPiggy> since I'm actually incapable of doing anything
08:54:50 <mm_freak> kmc: actually for some packages it would be better not to be uploaded to hackage
08:54:57 <pozic> CalJohn: quality without something as Coq needs taste, which is a human attribute.
08:55:08 <kmc> what
08:55:23 <mm_freak> kmc: it gets increasingly difficult to tell useful packages from unfinished alphas
08:55:37 <pozic> mm_freak: yep
08:56:09 <pretsas> Well then allow for an "Unfinished Alpha" flag thing
08:56:11 <pretsas> :P
08:56:18 <pozic> On Hackage every package is considered equal and the platform is next to empty.
08:56:18 <kmc> it won't get set right
08:56:22 <mm_freak> pretsas: it's there, but hackage doesn't use it
08:56:31 <pozic> Not every package is made equal.
08:56:36 <pozic> => mess
08:56:38 <kmc> but rating and usage stats would be a great feature
08:56:39 <CalJohn> I don't really agree.  Basic understanding is required, but good reusable code is more a function of using good SE tools - like static analysis (for which haskell has some built in) and testing and so on
08:56:44 <kmc> people are working on this iirc
08:56:48 <mm_freak> kmc: indeed, hackage could use that
08:57:20 <CalJohn> there is great java code out there
08:57:32 <CalJohn> it's just harder, and there is a higher signal to noise ratio
08:59:28 <MissPiggy> language isn't the problem, I tried various different ones and got nothing
08:59:58 <pretsas> 'tis the community!
09:00:22 <pretsas> Although the language does often have an effect on the community
09:00:29 <quicksilver> and vice versa.
09:01:53 <pozic> CalJohn: real code reuse comes from being able to write foreign import cplusplus, which you cannot right now :)
09:02:14 <pozic> Or foreign import "fortran" and so on.
09:02:31 <pretsas> But then nobody will write anything in haskell!
09:02:42 <pretsas> If you give people the tools to be lazy with, they will be lazy.
09:03:27 <pozic> pretsas: I don't know about you, but reinventing the wheel is not my kind of thing
09:03:31 <pozic> .
09:03:40 <pretsas> But you're writing it in haskell!
09:03:45 <pretsas> It's different :P
09:03:46 <pozic> But in Haskell that's exactly what you often do.
09:04:05 <CalJohn> pozic: i would rather have foreign import java
09:04:13 <kmc> i would rather have foreign import dotnet
09:04:20 <kmc> C++ is a swirling vortex of madness
09:04:24 <pozic> CalJohn: I don't know anything useful in java, but sure.
09:04:33 <pozic> CalJohn: can you tell me a useful library in Java?
09:04:46 <pretsas> a useful library in Java
09:04:47 <pretsas> There
09:04:51 <quicksilver> xerces
09:05:07 <CalJohn> there are many useful java libraries.  for example, web libraries with java are very good
09:05:12 <temoto> Lucene
09:05:19 <kmc> pretsas, if you give people the tools to be lazy, they'll invent something new instead of rewriting existing code for the nth time
09:05:23 <kmc> programming is all about laziness
09:05:29 <quicksilver> xerces is one of the very few free libraries supporting XSD properly.
09:05:31 <pozic> Lucene counts, but only because I don't know about how it works internally.
09:05:59 <temoto> You don't have to know, that's the whole point.
09:06:14 <temoto> of libraries, reusability and all
09:06:24 <pozic> temoto: that's an illusion. If you don't know what you use, you will get problems later on.
09:06:34 <pozic> temoto: in theory, you should not have to.
09:06:53 <pozic> Only with libraries written in Coq that holds.
09:07:00 <kmc> This is Xerxes. Can you not feel the glory of the flesh? Do you not yearn to be free of the tyranny of the individual?
09:07:03 <temoto> pozic: 'i know what i use' and 'i know how it works internally' are different things.
09:07:27 <pozic> temoto: that's just word play.
09:07:34 <pretsas> But knowing how what you use works internally helps you to use it no?
09:07:59 <temoto> pretsas: only in corner cases, like 20k simultaneous connections.
09:08:04 <pozic> temoto: if I use a library and I don't know the complexities of the operations, it is useless.
09:08:37 <temoto> pozic: complexities must be documented. That i put to the 'i know what i use' side.
09:08:50 <pozic> temoto: most of the time they are not.
09:09:20 <temoto> as in "i use data structure with constant element access" <- this is straight answer to "what i use"
09:09:58 <temoto> constant time*
09:09:59 <pozic> temoto: well, and that pretty much means that you know how it could work internally or most of the time actually works, so we agree.
09:11:49 <Wooga> hello, i am trying to implement function "scanSum" that adds the items in a list and returns a list of the running totals. So scanSum [2,3,4,5] returns [2,5,9,14]. i came up with http://paste2.org/p/633243 but when i am trying to do *Main> scanSum [2..5] in ghci, it complains that "[2,5,9*** Exception: func.hs:(2,0)-(3,38): Non-exhaustive patterns in function scanSum". so, how can i make patterns exhaustive?
09:12:13 <temoto> pozic: maybe our argue is a word play, yes. I don't want to know whether array or some kind of perverted hash table is used there. I only need to know features and characteristics. Due to bad engineering practices abstractions leak, you are forced to study internals.
09:12:27 <lispy> > scanl1 (+) [2,3,4,5]
09:12:28 <lambdabot>   [2,5,9,14]
09:12:51 <kmc> hehe, "some kind of perverted hash table"
09:13:00 <Wooga> lispy: thanks!
09:13:24 <lispy> Wooga: if this is homework, using scanl1 is probably worth 0 points :)
09:13:32 <lispy> Wooga: let's look at your code
09:13:35 <lispy> scanSum (x:y:ys)
09:13:47 <lispy> Wooga: so, what if you call scanSum [1,2]
09:13:54 <temoto> Wooga: for straight answer to straight question, you didn't supply a pattern for (_:[])
09:13:57 <lispy> Wooga: what would your definition do with that input
09:13:57 <pozic> temoto: hash tables are not O(1).
09:14:09 <temoto> pozic: i didn't say 1, right?
09:14:29 <kmc> let's argue about O(1) and O(log n)
09:14:42 <kmc> for n ~ 100
09:14:45 * lispy prefers O(1/2) algos since they are faster than O(1) algols
09:14:48 <kmc> because 1 and 7 are so different
09:14:53 <pozic> temoto: well, you were talking about arrays, but it doesn't really matter. Never mind.
09:14:54 <Wooga> lispy: maybe it should out [1,3]
09:15:02 <Wooga> temoto: thanks!
09:15:10 <pozic> kmc: yes, I think O(ln n) is best!
09:15:16 <lispy> Wooga: Okay, but looking at your definition when do you handle that case?
09:15:25 <kmc> i think associative data structures in the real world are dominated by non-asymptotic effects such as cache behavior
09:15:36 <Wooga> lispy: never :P
09:15:44 <temoto> What is associative data str.?
09:15:59 <lispy> Wooga: Do you know how to write foldl?
09:16:08 <kmc> temoto, something which associates keys with values
09:16:14 <lispy> Wooga: I'd probably start there, and then try to make it work like scanl
09:16:15 <kmc> such that you can look up a value by knowing its key
09:16:17 <zygoloid> i prefer O(1/n) algorithms
09:16:38 <kmc> common examples being an array (keys are sequential), a search tree, a hash table, etc.
09:16:42 <temoto> Wooga: wanna spoil?
09:17:01 <temoto> kmc: thanks.
09:17:02 <kmc> anyway, bbl
09:17:31 <Wooga> http://paste2.org/p/633257 works just fine even with [1,2]
09:17:43 <pretsas> But what about [1]?
09:17:55 <temoto> Wooga: it wouldn't work with [] now
09:18:22 <temoto> pretsas: it would work with [1] by first pattern.
09:18:25 <pretsas> Ah, whoops, didn't see the new code :P
09:18:32 <pretsas> My bad
09:19:29 <Wooga> temoto: does that matter?
09:20:14 <temoto> Wooga: well you could either document a special case or add a single line.
09:20:41 <temoto> in the first case you still have non-exhaustive pattern
09:20:54 <Wooga> well, i can add 'scanSum [] = []' to be sure
09:21:26 <temoto> Yeah. Now you are ready for spoil.
09:21:32 <temoto> @src scanl
09:21:32 <lambdabot> scanl f q ls = q : case ls of
09:21:32 <lambdabot>     []   -> []
09:21:32 <lambdabot>     x:xs -> scanl f (f q x) xs
09:21:36 <burp> O(exp(-n))
09:21:55 <temoto> Your scanSum is (scanl1 (+))
09:22:04 <temoto> or (scanl (+) 0)
09:22:08 <zygoloid> @src scanl1
09:22:08 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
09:22:08 <lambdabot> scanl1 _ []     =  []
09:29:26 <MissPiggy> learned lots of useless facts that I can't use to make anything
09:29:44 <MissPiggy> pretty much covers it
09:30:39 <quicksilver> I wonder if krasimir angelov IRCs
09:36:14 <rovar> anyone here worked with the ffi? I'm trying to port some code written for ghc 6.8.10 to 6.10.4, it's segfaulting in hs_init. I think it's relating to my args
09:36:42 <rovar> it expects a number of args and doesn't validate their existence.. and I'm not sure which args to pass.
09:46:41 <rovar> *crickets*
09:49:06 <MissPiggy> :/
09:49:39 <Vulpyne_> Aren't you supposed to pass argv and argc?
09:50:41 <rovar> Vulpyne, yea, but that doesn't make any sense at all in this context.
09:50:51 <rovar> it's a hook for GCC..
09:50:51 <Vulpyne> It looks like void hs_init(int *argc, char **argv[]) is what it wants.
09:51:12 <rovar> yea.. i don't actually understand why they'd want **argv[] in the first place.
09:51:12 <Vulpyne> Just pass it points to a blank char *[] array and a 0 integer variable?
09:51:30 <Vulpyne> Because there's special arguments you can pass to the GHC RTS to make it do stuff like print out when it's doing GC and such.
09:51:32 <rovar> tried it.. there are routines that assume that here is more than one argument passed
09:51:55 <rovar> hs_init itself assumes as much..
09:52:03 <mauke> Vulpyne: but that would be char **argv, not char **argv[]
09:52:08 <Zao> Where does one typically put .a and .dll files in a cabalized tree?
09:52:14 <Vulpyne> void blarg(void) { int fakeargc = 0; char *fakeargc[1] = { NULL }; hs_init(&fakeargc, &fakeargv); }
09:52:17 <Vulpyne> Have you tried something like that?
09:52:49 <Vulpyne> mauke: The actual thing is a char *[], but it's passed with &, which adds a level of pointeryness to it!
09:52:52 <mauke> &fakeargv :: char *(*)[1]
09:53:01 <mauke> that doesn't look compatible with char ***
09:53:01 <jneira> @pl (\(x,y)->(mod x 2)/=0)
09:53:01 <lambdabot> (0 /=) . flip mod 2 . fst
09:53:06 <rovar> Vulpyne, yep.
09:53:18 <rovar> char ** foo[]  should be compatible with char***
09:53:34 <mauke> it's identical
09:53:40 <mauke> as a function parameter, that is
09:53:41 <Vulpyne> rovar: argv[0] often holds the name of the program. Maybe you need at least one entry.
09:53:41 <jneira> @pl (\(x,y)->(x+1,div y 10))
09:53:42 <lambdabot> (1 +) *** flip div 10
09:53:56 <rovar> but as I mentioned, the source of hs_init expects that there is at least 2 args, and it doesn't verify that fact
09:54:04 <rovar> so i guess i'll put in 2 dummy args
09:54:17 <Vulpyne> I could see it expecting 1, but 2 seems weirds.
09:55:20 <rovar> 172: argv[1] = argv[0];   /* ignore the nPEs argument */
09:57:36 <medfly> @src (***)
09:57:36 <lambdabot> f *** g = first f >>> second g
10:00:03 <temoto> @src first
10:00:03 <lambdabot> Source not found.
10:00:14 <temoto> What does it mean?
10:00:19 <mauke> @src Arrow
10:00:19 <lambdabot> class Arrow a where
10:00:20 <lambdabot>     arr, pure   :: (b -> c) -> a b c
10:00:20 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
10:00:20 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
10:00:20 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
10:00:20 <medfly> I guess @src doesn't have everything
10:00:21 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
10:00:23 <temoto> ah
10:00:23 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
10:00:26 <mauke> it's a method
10:00:51 <temoto> arr,pure means synonyms?
10:00:56 <kmc_> temoto: they were
10:00:59 <kmc_> now "pure" is in Applicative
10:01:02 <kmc_> :t pure
10:01:04 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:01:22 <temoto> This doesn't look like arr.
10:01:23 <kmc_> the notation "a, b :: t" doesn't in general mean that a and b are synonyms
10:01:31 <kmc_> it is just shorthand for "a :: t; b :: t"
10:01:50 <temoto> ah, two types
10:01:59 <temoto> their types are identical
10:03:22 <temoto> Arrows are something like monads, right? Means of composing functions?
10:03:35 <Saizan> arr f = pure f <*> id = f <$> id, if you define the right applicative.
10:04:16 <Saizan> temoto: yeah, Arrow is another interface for combinator libraries
10:04:36 <ddarius> :t fmap ?f id
10:04:37 <lambdabot> forall a b. (?f::a -> b) => a -> b
10:04:44 <ddarius> fmap f id = f
10:04:49 <Saizan> Control.Category.id
10:04:55 <temoto> And we are to see Parsec via arrows, etc?
10:05:24 <ddarius> temoto: Every monad gives rise to an arrow, but there is little reason to use that fact.
10:06:03 <temoto> ddarius: did you just say that for some tasks using monads is "enough" and simpler?
10:06:14 <kmc_> for almost all tasks
10:06:33 <kmc_> Arrows are much, much less commonly used than monads
10:06:33 <temoto> *and simpler* ?
10:06:34 <ddarius> temoto: Arrows have -less- structure than monads.
10:07:00 <jmcarthur> temoto: i think "simpler" is not such a meaningful term for this
10:07:02 <temoto> hm less structure than (m a)?
10:07:06 <Saizan> if taken by themselves the Monad interface is more expressive than the Arrow one
10:07:07 <ddarius> temoto: So if arrows are enough, then monads are definitely "enough" as well, but monads will also be nicer to work with since you can use that extra structure.
10:07:11 <kmc_> less structure, in that more things are arrows
10:07:17 <kmc_> every monad is an arrow
10:07:20 <jmcarthur> temoto: arrows alone can't express everything a monad can unless it's an instance of ArrowApply
10:07:22 <kmc_> so monads are more constrained
10:07:40 <kmc_> temoto: the Arrow combinators are, however, commonly used in real code, for the special case of the arrow (->)
10:07:41 <rovar> you know.. i don't see how this code ever worked..
10:07:52 <c_wraith> rovar, don't you hate code like that?
10:07:56 <kmc_> > (succ &&& pred) 3
10:07:57 <lambdabot>   (4,2)
10:08:18 <ddarius> kmc_: That's just because they happen to be handy functions.  That's not taking advantage of "arrowness."
10:08:20 <jmcarthur> i would say that monads are a lot more convenient than arrows
10:08:25 <kmc_> agreed
10:08:56 <tromp> and not just because of syntactical support
10:08:59 <kmc_> it's cumbersome to write arrow code with only the combinators, and the "proc" notation is complicated
10:08:59 <temoto> :t succ
10:09:01 <lambdabot> forall a. (Enum a) => a -> a
10:09:06 <temoto> How is that a b c ?
10:09:10 <rovar> c_wraith, no, this is the RtsStartup code in hs 6.10.4. It doesn't make any sense.
10:09:14 <kmc_> temoto: a = (->)
10:09:23 <kmc_> > succ :: ((->) Int Int)
10:09:25 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
10:09:27 <jmcarthur> if we could transparently translate between kleisli and monads then arrow notation might be more handy for monads, being able to mix the notations, but as it is it's nicer to just stick with the less general combinators that happen to be arrow concepts, like (<=<)
10:09:45 <pokoko222> are groups used in Haskell in any way?
10:09:47 <rovar> it's incrementing pointers to ints as if they were ints..
10:09:48 <ddarius> Monads are like Arrows with higher-order features.  So the difference between using Arrows and using Monads is like the difference between using a first-order language and using a higher-order language.
10:09:51 <temoto> oh boy, now we're taking (->) into account
10:10:04 <temoto> All previous types didn't use that.
10:10:06 <ddarius> pokoko222: The notion of group can't be precisely expressed in Haskell.
10:10:08 <luqui> ddarius, wow, nice description :-)
10:10:16 <jmcarthur> ddarius: really?
10:10:24 <ddarius> jmcarthur: Yes.
10:10:26 <pokoko222> what do you mean
10:10:29 <ddarius> jmcarthur: Just look at ArrowApply.
10:10:30 <pokoko222> too abstract?
10:10:38 <luqui> well sortof.   you can't prove that your inverses are inverses...
10:10:38 <kmc_> pokoko222: if you like, you're using a group every time you add two Ints
10:10:40 <ddarius> pokoko222: Haskell can't capture the group laws.
10:10:40 <jmcarthur> ddarius: i'm talking about groups
10:10:47 <kmc_> but this is not explicitly expressed in the language
10:10:48 <jmcarthur> ddarius: oh, the laws
10:10:50 <luqui> but haskell doesn't capture the functor laws either
10:11:13 <pokoko222> how come haskell does not capture these 4 laws?
10:11:17 <jmcarthur> we typically use the convention that you can put proof burdens on the programmer as he instantiates a type class
10:11:24 <kmc_> Haskell has no way to enforce laws for *any* typeclass
10:11:32 <kmc_> it can no more enforce the group laws than the monoid laws
10:11:36 <kmc_> but we still have a Monoid class
10:11:45 <kmc_> and no standard Group class, though i'm sure it's in someone's library
10:11:45 <ddarius> kmc: Actually, some laws are enforced by the types alone.
10:11:48 <jmcarthur> we can just as easily have a Group class, yes
10:11:53 <PeakerWork> kmc_: it can enforce the law that mappend should get two arguments of the same type, and return a value of the same type :)
10:12:01 <rovar> it would appear that this mangling was fixed in 6.12.1
10:12:10 <kmc_> those laws are so trivial that mathematicians usually don't bother to state them ;)
10:12:19 <ddarius> kmc_: Definitely not true.
10:12:38 <luqui> Peaker, well in particular, given fmap id = id, the parametericity theorems guarantee the other functor law
10:12:42 <luqui> so it's nontrivial sometimes :-)
10:12:44 <pokoko222> u guys have no idea what you talk about do you?
10:12:46 <luqui> i like parametericity...
10:12:58 <kmc_> pokoko222: that's right, we're making it all up as we go
10:13:23 <pokoko222> yeah such is modern math
10:13:24 <zygoloid> luqui: do you even need fmap id = id for fmap f . fmap g = fmap (f . g) to hold? i thought it was a free theorem
10:13:36 <luqui> zygoloid, yeah you do.
10:13:48 <kmc_> pokoko222: was it ever otherwise?
10:13:49 <jmcarthur> zygoloid: consider the case that fmap changes the constructor
10:13:59 <luqui> data Foo a = Foo Int a;  instance Functor Foo where fmap f (Foo z x) = Foo (z+1) (f x)
10:14:13 <jmcarthur> actually...
10:14:14 <zygoloid> @free map
10:14:15 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:14:23 <pokoko222> kmc_ dude all these new theories can kill a man... topology, CT, crazy stuff
10:14:25 <jmcarthur> luqui's example is good, mine is not
10:14:26 <temoto> How come &&& captures (->) in a, when, say, pred :: Int -> Int in 'pred 1' is happy with a single argument?
10:14:27 <zygoloid> yeah, well you need it there :)
10:14:54 <zygoloid> jmcarthur: yours is fine. consider a fmap which takes Left to Right and vice versa. fmap f . fmap g lands on the same ctor, fmap (f.g) lands on the other one
10:14:56 <mauke> temoto: huh?
10:15:07 <luqui> asking about instance Arrow (->)
10:15:10 <luqui> how it works
10:15:16 <temoto> yes
10:15:18 <jmcarthur> zygoloid: ah, indeed. but i wasn't specific enough
10:15:23 <mauke> but that question makes no sense
10:15:25 <medfly> > pred :: ((->) Int Int)
10:15:26 <lambdabot>   {-3->-4;-2->-3;-1->-2;0->-1;1->0;2->1;3->2}
10:15:32 <zygoloid> jmcarthur: i considered your case and found a counterexample. that's enough :)
10:16:09 <temoto> Okay, what is (->) ?
10:16:15 <kmc_> the type constructor of functions
10:16:16 <zygoloid> the free theorem is more like: "fmap f . fmap g = fmap (f.g) . fmap id"
10:16:16 <mauke> the type of functions
10:16:21 <kmc_> :k (->)
10:16:22 <lambdabot> ?? -> ? -> *
10:16:26 <kmc_> like Either, it takes two type parameters
10:16:39 <Gracenotes> (->) Int Int, also written Int -> Int
10:17:17 <zygoloid> temoto: (->) is a type constructor like Maybe or Either.
10:17:18 <Gracenotes> likewise, (->) ((->) [a] Int) Int.. can be written [a] -> Int -> Int
10:17:25 <kmc_> ...thankfully
10:17:31 <ddarius> Gracenotes: Wrong associativity.
10:17:39 <Gracenotes> oh... indeed
10:17:49 <zygoloid> or as (->) ((->) ([] a) Int) Int
10:17:56 <Gracenotes> (->) [a] ((->) Int Int)
10:18:02 <zygoloid> but yeah, associativity :)
10:18:24 <luqui> thank the lord for well-placed syntax sugar :-)
10:18:58 <luqui> $ and infix operators are what make haskell not look like lisp ( = oatmeal with fingernail clippings)
10:19:00 <ddarius> luqui: That's what they write in Scheme (only with one more outer set of parentheses and without the ones around ->)
10:19:13 <kmc_> $ is an infix operator
10:19:30 <luqui> lol you are right and correct
10:19:35 <ddarius> (-> (list a) (-> int int)) but presumably they can also write that (-> (list a) int int)
10:19:47 <kmc_> there are some definite advantages to Lisp-style syntax
10:20:00 <temoto> Like simple parser.
10:20:05 <kmc_> meh, parsing is easy
10:20:10 <kmc_> for any language except C++
10:20:21 <ddarius> or Perl
10:20:24 <p_l> kmc_: not Perl
10:20:24 <sproingie> sexps make macros easy
10:20:24 <zygoloid> or XML
10:20:27 <luqui> or scala
10:20:31 <mauke> perl is reasonably easy to parse
10:20:34 <kmc_> Lisp syntax is great if you're more interested in writing metaprograms than first-order programs
10:20:40 <sproingie> perl can only be parsed with perl
10:20:42 <kmc_> perl is undecidable to parse
10:20:46 <p_l> mauke: except you can't make a complete parser without running perl
10:20:47 <mauke> so is lisp
10:20:48 <Gracenotes> wow, what's the language/line rate here
10:20:49 <Gracenotes> it's through the roof
10:20:51 <sproingie> part of parsing it requires actually running it
10:20:55 <mauke> p_l: see also: LISP
10:21:21 <ddarius> CL really isn't that easy to parse actually (ignoring parse-time execution)
10:21:50 <sproingie> sure it is.  it's got tons of special forms but they all parse the same
10:22:00 <p_l> mauke: LISP doesn't require execution for parsing. #. is an extra declaration for reader, through a well known method, and which can be also easily parsed although not necessarily into final form
10:22:04 <ddarius> sproingie: No, that's not the case.
10:22:22 <MissPiggy> p_l eh
10:22:25 <sproingie> one pair of parens, one form
10:22:36 <mauke> p_l: ok, then parse http://mauke.ath.cx/stuff/lisp/add-x.lisp
10:22:43 <p_l> (and #. is only in CL, not in LISP. I don't know enough about M-Expressions to say about LISP :D)
10:22:44 <mauke> no running code allowed
10:22:47 <temoto> So the only place where one can operate with (->) is class and instance definitions?
10:22:53 <ddarius> sproingie: As a trivial example, in common with all lisps, there is (x . y).  More you have ' and #' and several other things.
10:23:06 <sproingie> istr seeing # in another lisp.  CL probably picked it up from there
10:23:14 <sproingie> mauke: can't connect
10:23:27 <sproingie> (x . y) is still one form
10:23:31 <mauke> sproingie: what ip address do you see?
10:23:42 <ddarius> sproingie: And is ' one form?
10:23:45 <p_l> mauke: what is #$? because sure as hell it isn't in standard
10:24:03 <theorbtwo> So we've found maybe as many as four forms?
10:24:04 <mauke> p_l: bingo. but you said you can parse it anyway.
10:24:04 <sproingie> mauke: 172.24.8.224
10:24:09 <p_l> mauke: oh, I can
10:24:10 <theorbtwo> That's not a difficult-to-parse language!
10:24:11 <sproingie> ' is a reader macro that's expanded first
10:24:16 <ddarius> sproingie: My point is that there are a lot of extra syntactic things beyond just forms in CL.
10:24:18 <mauke> sproingie: should be 95.88.118.220
10:24:30 <p_l> mauke: I just asked what it is ;-)
10:25:12 <mauke> p_l: (f #$ g x) is (f (g x))
10:26:39 <sproingie> no way
10:26:52 <sproingie> is joke?
10:27:08 <mauke> it's real code; the file is in the same directory
10:27:14 <sproingie> huh
10:27:59 <sproingie> does (f g #$ x) become ((f g) x)?
10:28:21 <p_l> mauke: well, I can parse it, it might not exactly parse into what writer intended, but that's because reader macros are hooks into parser
10:28:23 <sproingie> (not all that useful in lisp i imagine)
10:28:24 <mauke> sproingie: no
10:28:51 <mauke> p_l: I could just as well have made #$ a quoting operator (in the perl sense)
10:28:54 * ddarius imagines #$ just adds parentheses around all the forms that follow it.
10:29:21 <mauke> p_l: so you can't parse (common) lisp without 1) loading and 2) running other files
10:30:42 <zygoloid> mauke: could you make it legal to have, say, mismatched parens with such a hack?
10:30:47 <mauke> easily
10:31:15 <sproingie> reader macros can emit anything they want
10:31:44 <mauke> imagine #$ is the start of a string literal: (print #$hello world!$) (print #$))((($)
10:32:05 <p_l> mauke: with this reasoning, I can prove that you can't parse any possible language without executing it, as long as I provide hooks into implementation's parser
10:32:20 <mauke> well, duh
10:32:26 <mauke> that's what happens in perl
10:32:35 <sproingie> if your language's definition uses those hooks, then that's correct
10:32:37 <zygoloid> p_l: yes, hooking the parser is one way to make a language unparseable without executing it
10:32:53 <mauke> but somehow it's a big deal in perl, but completely ignored in lisp
10:33:09 <ddarius> I like how Forth handles it.
10:33:27 <p_l> mauke: maybe because reader-macros are frowned upon because of the problems they bring?
10:33:30 <sproingie> i don't claim CL is usefully parseable without executing it, i just said it has very little syntax when it comes to just parsing to a AST
10:33:49 <zygoloid> the perl problem isn't to do with hooking the parser, though
10:33:55 <sproingie> when you get into how forms have to behave, then lisp has oodles of syntax.  hell, LOOP is to make perl blush
10:33:57 <mauke> zygoloid: what is it?
10:34:05 <zygoloid> whatever  / 25 ; # / ; die "this dies!";
10:34:13 <mauke> zygoloid: how is that ambiguous?
10:34:32 <sproingie> 25 ; # / is a regex literal
10:34:34 <p_l> sproingie: well, when you use a variant without reader macros, you might end up with straight AST. I recall that one lisp system actually didn't have reader at all, since it didn't use textual representation of code
10:34:37 <zygoloid> if whatever takes an argument, the // is a pattern match. if it doesn't, it's division.
10:34:38 <sproingie> argh
10:34:47 <sproingie>  / 25 ; # / is a regex literal
10:34:49 <mauke> zygoloid: how do you know if whatever takes an argument?
10:34:59 <zygoloid> mauke: you run the code and have a look :)
10:35:03 <mauke> zygoloid: wrong
10:35:06 <zygoloid> http://www.perlmonks.org/?node_id=663393
10:35:12 <mauke> zygoloid: you parse the preceding code, as in any other language
10:35:22 <mauke> no, that link doesn't count
10:35:32 <zygoloid> why not?
10:35:53 <mauke> because it's not authoritative, and you don't understand what it says
10:36:00 <sproingie> indirect object syntax is another area where you have to execute perl to parse it
10:36:03 <zygoloid> mauke: don't tell me what i do and don't understan
10:36:07 <kmc_> sigh
10:36:33 <mauke> in the absence of parser hooks, you know exactly what 'whatever' is at that point in the file because you've parsed the preceding code
10:36:43 <theorbtwo> mauke: Er, actually, in certian cases, you have to *execute* the code that preceeds it, because *foo = sub ($$) {bar} is valid code, that creates a sub named foo that has a prototype.
10:37:10 <mauke> theorbtwo: yes, but prototypes only affect the parser, and that code only happens at runtime
10:37:12 <sproingie> istr a claim that perl6 despite its rococo syntax won't actually need to be executed to parse it
10:37:13 <mauke> so no effect
10:37:32 <theorbtwo> mauke: Perl also has a nice construct, BEGIN {}, for executing code at parse-time.
10:37:36 <mauke> theorbtwo: yes
10:37:40 <theorbtwo> (Specificly, as soon as the closing } is parsed.)
10:37:47 <mauke> <zygoloid> the perl problem isn't to do with hooking the parser, though
10:37:51 <mauke> BEGIN {} is a parser hook
10:37:54 <MissPiggy> problem ??
10:38:06 <zygoloid> mauke: no, it's not. it doesnt' change the /behaviour/ of the parser. it runs code at parse time.
10:38:07 <sproingie> the existence of the parser hooks isn't the problem.  indirect object syntax is one.
10:38:15 <zygoloid> c++ allows code to be run at parse time but is still parseable
10:38:17 <sproingie> it's the main one i think
10:38:25 <zygoloid> or at least at compile time
10:38:31 <mauke> sproingie: not really
10:38:42 <theorbtwo> sproingie: Yeah.  As far as I can tell, that was an idea that was deemed less important then having a highly hookable parser.
10:38:43 <mauke> zygoloid: how do you run C++ code at compile time?
10:39:02 <zygoloid> mauke: templates are a turing-complete programming language.
10:39:12 <zygoloid> a horrid one though
10:39:13 <mauke> oh, that kind of code
10:39:15 <sproingie> i would definitely prefer perl to have a highly-hookable parser
10:39:17 <Saizan> not only you're completely OT, but you're also having a lawyer fight over your OT?:)
10:39:27 <zygoloid> Saizan: good point :)
10:39:38 <sproingie> it's perl, it's too late for cleanliness
10:40:53 <mauke> zygoloid: it still seems analogous to lisp to me. (load ...) itself doesn't change the parser, and (macrolet ...) doesn't (necessarily?) run at parse time
10:40:57 <mauke> I might be wrong, though
10:42:10 <zygoloid> mauke: overflow?
10:43:28 <theorbtwo> mauke: Except BEGIN { } does neccessarly run at parse time; that's it's point.  Inside a BEGIN block, you can set up the prototype of a function based on some arbitrary, external, condition.
10:43:55 <mauke> theorbtwo: we're in #haskell-overflow now
10:44:21 <theorbtwo> Ah.  Sorry.
10:49:50 <b0fh_ua> Hi there! Can somebody please suggest a library, which can return list of mountpoints and stats for every mountpoint (total size, capacity, free space etc)?
10:50:35 <Twey> /etc/mtab and df?
10:50:47 <Twey> Orâ¦ just df
10:51:01 <b0fh_ua> Twey: I would like to omit parsing of output of an external tool
10:51:17 <b0fh_ua> because of different formatting for different locales
10:51:24 <b0fh_ua> and passed options
10:51:31 <ve> is there some flag to make a literate Haskell file with #! /usr/bin/env runghc in the first line run correctly? (if there's no file extension)
10:52:27 <Twey> b0fh_ua: Well, you can set the locale and options as you want them.
10:52:38 <b0fh_ua> looks ugly :)
10:52:57 <burp> investigate df source :>
10:52:59 <Twey> As ugly as re-implementing an existing tool from scratch?
10:53:00 <b0fh_ua> but if there's noting similar available in Haskell, I'll probably go this way
10:53:37 <kmc_> linux?
10:53:45 <b0fh_ua> Twey: I guess that there should be something implemented for haskell :)
10:53:48 <kmc_> the info is probably available in more raw form in /proc or /sys
10:54:11 <b0fh_ua> kmc_: that woudn'd work for FreeBSD or macos
10:54:17 <kmc_> ah
11:02:54 <pokoko222> how is automorphism used in haskell?
11:04:26 <pokoko222> I am stuck with Awodey on chapter 4, Groups and categories, anyone interested to mentor this guy for some minutes?
11:07:18 <temoto> So the only place where one can operate with (->) is class and instance definitions?
11:07:55 <kmc_> the type constructor (->) ?
11:07:58 <temoto> Yes.
11:08:04 <kmc_> you can use it in any type
11:08:10 <Saizan> temoto: type signatures, (data)type declarations ..
11:08:12 <kmc_> it's just a type constructor, like Either is
11:08:29 <temoto> which means i can pattern match on it?
11:08:32 <kmc_> no
11:08:34 <luqui> data Foo f = Foo (f Int Int)
11:08:36 <kmc_> you can't pattern match on type constructors
11:08:37 <luqui> now Foo (->) is a type
11:08:39 <temoto> right
11:08:46 <kmc_> they're not part of values
11:08:50 <kmc_> types characterize values
11:09:00 <temoto> But functions operate on values, not on types, right?
11:09:04 <kmc_> correct
11:09:16 <kmc_> > let f :: (->) Char Char; f = succ in f 'x'
11:09:17 <lambdabot>   'y'
11:09:18 <temoto> How come then that first argument of &&& is a type constructor?
11:09:24 <kmc_> it's not
11:09:28 <kmc_> :t (&&&)
11:09:29 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:09:37 <kmc_> the first argument of (&&&) is a value of type (a b c)
11:09:39 <luqui> a is a type constructor.  a b c is a type.
11:10:17 <kmc_> a more specific type for (&&&) is:   (b -> c) -> (b -> c') -> (b -> (c, c'))
11:10:18 <temoto> (b -> c) is a case of more general (a b c) ?
11:10:22 <kmc_> yes
11:10:26 <kmc_> it's the case where a = (->)
11:10:32 <kmc_> (b -> c) and ((->) b c) are equivalent
11:10:44 <kmc_> as with value-level operators, infix type constructors can be written prefix with parentheses
11:10:48 <temoto> oh thanks, at least something is clear
11:10:55 <kmc_> they can't be sectioned, though
11:11:21 <temoto> Either b c too?
11:11:27 <kmc_> too what?
11:11:30 <mauke> (&&&) :: Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
11:11:33 <kmc_> (Either b c) is another type
11:11:35 <temoto> a special case of a b c?
11:11:43 <mauke> yes
11:11:47 <kmc_> temoto: not in this context, because we require that a is an Arrow
11:11:49 <kmc_> in general, yes
11:11:58 <temoto> Alright, now it all makes sense.
11:12:01 <kmc_> > let f :: (a b c) -> (); f _ = () in f (Left 6)
11:12:02 <lambdabot>   ()
11:12:08 <kmc_> > let f :: (a b c) -> (); f _ = () in f Nothing
11:12:09 <lambdabot>   Couldn't match expected type `a b c'
11:12:09 <lambdabot>         against inferred type `Data.Ma...
11:12:19 <mauke> heh, nice
11:12:20 <kmc_> that's a strange strange type signature for a function
11:12:21 <kmc_> but it is legal
11:12:28 <temoto> I guess this is the point where **function** application being default operator makes ambiguity.
11:12:35 <mauke> > let f :: a b c -> (); f _ = () in f f
11:12:35 <kmc_> how so?
11:12:35 <lambdabot>   ()
11:12:44 <kmc_> hahaha mauke
11:12:52 <Zao> Does cabal files have access to environment variables?
11:13:01 <kmc_> that seems like it should have an infinite type
11:13:08 <dcoutts_> Zao: no
11:13:28 <temoto> Well because in 'a b c' i'm more used to read it as a -> b -> c
11:13:32 <Zao> That's unfortunate. Hack time.
11:13:37 <temoto> but stop, that's not in type
11:13:42 <conal> i'm glad to see others using (~>).  that "a b c" notation bludgeons my intuition
11:13:44 <temoto> no, no ambiguity
11:14:11 <kmc_> space is application, for types or for values
11:14:12 <temoto> But yes, intuition is surprised.
11:14:23 <kmc_> type constructors are "functions" that operate on types
11:14:27 <temoto> conal as in tangible functional programming?
11:14:37 <conal> temoto: yeah.  hi.
11:14:45 <temoto> conal: hello, nice to see you.
11:14:54 <temoto> Thanks for that video.
11:15:04 <conal> temoto: :) !
11:15:22 <temoto> conal: we've been discussing here what haskell needs to support that.
11:15:46 <conal> temoto: i'm working my way back around toward a new version of eros.
11:16:15 <conal> temoto: one that generates gpu code for the graphics.
11:16:50 <temoto> There must be some common runtime (or even functional OS) to share types between programs. And then it would be possible to make "pure programs" as in main :: CircleShape
11:17:41 <temoto> @quote kmc type constructors are "functions" that operate on types
11:17:42 <lambdabot> No quotes match. :(
11:17:50 <temoto> @remember kmc type constructors are "functions" that operate on types
11:17:50 <lambdabot> Done.
11:17:53 <kmc_> heh, why is that quotable
11:18:00 <conal> i very much want haskell to get away from requiring "programs" to be imperative (IO)
11:18:15 <temoto> I consider it extremely useful, kmc_ :)
11:18:15 <MissPiggy> conal why
11:18:22 <kmc_> heh
11:18:32 <conal> MissPiggy: because i like programming functional/denotatively.  that's why i use haskell.
11:18:46 <rovar> has anyone tested HaskellPlatform against 6.12.1 and care to report?
11:18:47 <conal> MissPiggy: for precise reasoning, powerful composability, etc
11:18:50 <temoto> i never thought of it like that, but i encountered a decision problem for which this is the answer
11:19:04 <MissPiggy> conal but what if that's not possible for things that do input-output?
11:19:25 <Zao> dcoutts_: On a related note, can one specify somehow that g++.exe should be used over gcc.exe?
11:19:28 <temoto> MissPiggy: it's totally possible, see UNIX pipes. They do implement almost everything of it.
11:19:32 <temoto> But they're not typed.
11:19:49 <conal> MissPiggy: then we discover and unload our assumptions that make it impossible.
11:19:54 <dcoutts_> Zao: --with-gcc=g++  assuming it really can be used as a drop-in replacement
11:20:18 <Zao> Excellent.
11:20:43 <dcoutts_> Zao: what are you trying to do, which would make env vars a good solution?
11:20:46 <Zao> The DirectX headers are a bit moody, and g++ swallows them better for C files.
11:21:05 <Zao> dcoutts_: I would want to use ${DXSDK_DIR} in include-dirs:
11:21:19 <Zao> And preferably for wherever one specifies -L as well.
11:21:19 <temoto> conal: are you familiar with Haiku or Inferno projects, btw/
11:21:50 <Zao> dcoutts_: If I'm ever going to have a remote chance of building this on something not my machine, it's be beneficial to use the standard env var for locating the headers and libs.
11:21:57 <conal> temoto: no, i'm not.  inferno sounds vaguely familiar (rob pike?)
11:22:09 <temoto> conal: both are OS
11:22:22 <dcoutts_> Zao: I see, so that's how they find the location. The standard thing is to code it in the Setup.hs.
11:22:53 <dcoutts_> Zao: various libs have various ways, env vars is one of the rarer ones. More common is blah-config that spits out -L -l flags.
11:23:02 <temoto> conal: and AFAIK both export types out of single program, as in one program can pass an Integer into another without serialization.
11:23:16 <MissPiggy> conal I have struggle to even understand what that could mean!
11:24:25 <conal> MissPiggy: i'm not surprised.  we programmers have been programmed to see things imperatively.  if you don't have any ideas on how to break free, then one way to discover those assumptions is to try turning informal impossibility arguments into precise proofs.
11:24:36 <conal> MissPiggy: akin to the spaniel method of debugging.
11:25:59 <conal> temoto: neat.  is composition still restricted to linear pipelines (function compositions)?  how flexible are the types of data that pass between programs?
11:26:32 <temoto> conal: i'm not that familiar with 'em :)
11:26:53 <conal> k
11:26:56 <temoto> conal: what is beyond linear pipelines?
11:27:09 <kmc_> Arrows :D
11:27:12 <sinelaw> is there any generalization of composition (non-linear) that still allows some sort of currying?
11:27:13 <lambdabot> sinelaw: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:27:54 <conal> temoto: consider that same question for composing within a "program".
11:28:29 <conal> temoto: i want inter-program composition to be as rich as intra-program composition.  and not just as rich, but the same.
11:28:42 <temoto> conal: and what is spaniel method of debugging?
11:28:43 <sinelaw> @tell ivanm can't you somehow cause it to not wait for the entire output? make it line buffered if it isn't, and read from opening { to closing } of each graph output (when the format is -Tdot)?
11:28:44 <lambdabot> Consider it noted.
11:28:58 <conal> anyone have a handy reference to the spaniel method?
11:29:17 <temoto> http://portal.acm.org/citation.cfm?id=307866&dl=GUIDE&coll=GUIDE&CFID=73292240&CFTOKEN=87559766
11:29:20 <temoto> but it wants money
11:29:20 <conal> sinelaw: yes.  (<*>)
11:30:00 <conal> temoto: oh yeah, urg :(  i haven't found a free reference.  and i haven't read that paper.  heard about the method a long time ago.
11:30:23 <MissPiggy> conal what about just function calls instead of composition?
11:30:29 <sinelaw> conal, how do I use that for non-linear composition?
11:31:26 <temoto> If i used <*> in Parsec parser definitions but never used arrows, did i use non-linear composition?
11:32:04 <conal> MissPiggy: sure.  and if you convert to function-level (point-free) form, you get things like linear & non-linear composition.
11:32:16 <kmc_> temoto: <*> is like application
11:32:35 <conal> by "non-linear", i mean tree-shaped, as in <*> and liftA2 etc
11:33:07 <MissPiggy> okay
11:33:46 <temoto> How does it conform with the fact that every haskell function is of one argument?
11:34:11 <conal> the spaniel method is a very powerful technique for debugging programs.  but more importantly for discovering and correcting buggy assumptions that interfere with creative progress.  in particular when you believe something is impossible.
11:34:12 <temoto> It's a binary tree every time, right?
11:34:17 <conal> impossible to achieve.
11:34:34 <conal> temoto: binary trees encode n-ary trees.
11:35:02 <conal> in the spaniel method of debugging, you start with a broken program and you explain to your dog why in fact the program is correct.
11:35:18 <conal> since your dog is not as imaginative as you, you have to fill in a lot of blanks for him.
11:35:56 <temoto> conal: is it like with 'it is all discreete in the end but we don't have to go to the end, we can use some properties at "current zoom level"'?
11:36:16 <conal> hiding in one of those blanks (sometimes named "clearly" or "obviously"), is your mental bug.
11:36:50 <temoto> conal: then i used this spaniel debugging many times :)
11:37:11 <conal> temoto: super!
11:37:30 <temoto> Yeah it always worked.
11:38:00 <temoto> What about non-linear composition then?
11:38:27 <conal> temoto: pipelines are like function compositions, right?  h . g . f
11:38:29 <temoto> Can i see a function of two arguments as non-linear because it takes multiple values in?
11:38:42 <temoto> conal: yep
11:39:17 <conal> temoto: and function compositions arise from translating *some* nested application expressions into point-free form.
11:39:37 <temoto> uhhhhh
11:39:40 <conal> temoto: but some other such expressions don't reduce to (linear) chains.
11:39:51 <conal> temoto: so (.) isn't expressive enough.
11:40:01 <temoto> some don't?
11:40:14 <temoto> Don't we have a @pl bot to prove that all do?
11:40:29 <conal> @pl \ x -> x + x
11:40:29 <lambdabot> join (+)
11:40:42 <conal> @pl \ x -> x + 2 * x
11:40:43 <lambdabot> ap (+) (2 *)
11:41:04 <conal> in other words (+) <*> (2 *)
11:41:11 <temoto> Is this non-linear?
11:41:36 <conal> yes.  in that information doesn't flow through a *chain* (ie linearly)
11:41:47 <conal> instead, it flows through a tree
11:41:51 <temoto> Oh i see now.
11:41:54 <conal> :)
11:42:07 <MissPiggy> why not write it the normal way?
11:42:51 <conal> MissPiggy: which normal?
11:42:56 <temoto> diff was a first non-linear something that ought to be a pipe but it was a pipe because pipes operate on linear compositions only?
11:43:02 <MissPiggy> \ x -> x + 2 * x
11:43:03 <temoto> it was not*
11:44:17 <temoto> conal: well yes, BTW. f x = x + 2 * x, now f is linearly composable.
11:44:21 <conal> temoto: yeah.  i mention diff and several other examples in that "modern marriage" (tangible functional programming) talk where the unix composition mechanism falls short.
11:44:40 <temoto> And i guess diff used exactly that approach.
11:44:54 <temoto> it's a    cat file1 | diff x
11:45:23 <MissPiggy> are you thinking of structuring the program like a flow chart?
11:45:25 <temoto> just like        _ . f x
11:45:30 <MissPiggy> the basic case being pipes
11:45:59 <conal> MissPiggy: i guess the lambda form is not as compositional, ie not made up of independent meaningful & useful pieces.  see backus's turing paper.
11:46:48 <MissPiggy> conal, I thought it had compositional meaning, since  e.g.  meaning of x + y  is just  meaning of (+) applied of meaning of x and meaning of y
11:46:48 <conal> temoto: in "cat file1 | diff x", is x a file name?
11:47:21 <temoto> conal: yes. an argument to diff, completely out of pipe
11:47:33 <temoto> i wanted to use same name as in 'f x'
11:47:36 <conal> temoto: yeah.  breakdown of compositionality.
11:48:31 <conal> "x + y" isn't independently meaningful since x & y are free.  i don't mean to overstate here.  it is literally meaningful in that one can define its meaning as a function from an environment of variable bindings.  but then it's not what i mean by "independent".
11:48:37 <conal> MissPiggy: ^^
11:48:57 <temoto> conal: but actually, it's not, because we can use   cat file1 | diff $(request a file name)    where $(cmd) executes another shell command, another pipe
11:49:02 <conal> MissPiggy: contrast with algebraic approaches.
11:49:03 <jfoutz> backus talked a lot about the x's hiding what functions do. using a matrix instead of a list of linear equations is a great example.
11:49:23 <temoto> this is similar to how  `f x` evaluates x if it's needed in f
11:49:41 <temoto> x can come from another pipe
11:49:42 <conal> temoto: functional semantics??
11:50:20 <MissPiggy> algebraic approaches do you mean like APL?
11:50:48 <conal> MissPiggy: like Backus's FP and like Functor and Applicative
11:50:56 <temoto> conal: you use two kinds of words, i only understand second kind: simple words :)  i'm not sure whether $(another pipe) relates to functional semantics. For example, its evaluation is not lazy.
11:51:30 <conal> MissPiggy: read backus's paper.  he took the time to think deeply about composition and to explain it well.
11:52:10 <conal> MissPiggy: you'll find a reference in my recent blog post http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm/
11:52:11 <gwern> Yukihiro Matsumoto: 'I feel sometimes uneasy by lazy evaluation. You don't specify the execution in a language like Haskell. I describe what I want or what I need, I don't say anything about to which degree I should do or the programming should go or anything like that. That makes me feel uneasy. I sometimes feel like I lost control of the program execution.'
11:52:13 <rittyan> hi all. is there only postfix, prefix and infix functions in our world?
11:52:19 <jfoutz> backus ++. it's a good paper.
11:52:42 <zygoloid> temoto: <(another pipe) is more appropriate, and it is lazy
11:53:25 <temoto> rittyan: if x then y else z  is a mixfix operator with 3 arguments.
11:53:27 <zygoloid> well, almost lazy :)
11:53:45 <rittyan> temoto: thank you!
11:53:55 <gwern> huh. ruby has continuations?
11:54:11 <temoto> And there's some other foofix, which i don't remember.
11:54:20 <zygoloid> outfix?
11:54:22 <temoto> circumfix or something
11:54:30 <temoto> no
11:54:30 <MissPiggy> conal hey I asked you a question on your blog bbut maybe it was a bit of a bad one
11:54:38 <temoto> zygoloid: what's outfix?
11:54:38 <zygoloid> [|...|] is outfix in [| foo |]
11:54:39 <MissPiggy> http://conal.net/blog/posts/is-program-proving-viable-and-useful/
11:54:59 <conal> MissPiggy: what was your question?
11:55:14 <MissPiggy> I just didn't understand the post :(
11:55:50 <conal> MissPiggy: oh: "Hi Conal, I donât understand this post. what do you mean?"  that one?
11:55:54 <MissPiggy> yes
11:56:09 <temoto> zygoloid: outfix is an operator of single argument where notation is to surround the argument with operator symbols?
11:56:10 <rittyan> zygoloid: outfix operator is hmm... parenthesis?
11:56:31 <rittyan> fix: is parenthesis the outfix operator?
11:57:16 <sinelaw> @type (+) <*> (2 *)
11:57:17 <lambdabot> forall a. (Num a) => a -> a
11:57:20 <conal> MissPiggy: well, the post itself is an answer to that question.  i would need something more specific to go on.
11:57:25 <sinelaw> @type (+) <*>
11:57:26 <rovar> is there a way to specify the use of base 4 over base 3 as a system wide default?
11:57:26 <lambdabot> parse error (possibly incorrect indentation)
11:57:34 <rovar> wrt 6.12
11:57:37 <sinelaw> @type ((<*>) (+))
11:57:38 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
11:57:43 <temoto> conal: he (or she?) is just shy. He is trying to implement lambda calculus in plain haskell types (as in data Zero, etc).
11:58:02 <temoto> no it wasn't lambda, but church numbers
11:58:11 <temoto> no matter, he's a very clever guy
11:58:25 <temoto> talking about MissPiggy for disambiguation
11:58:38 <MissPiggy> temoto, I have not tried to implement church numbers
11:59:01 <shepheb> Peano numbers, rather?
11:59:04 <MissPiggy> was that Eduard_Muntanau
11:59:54 <temoto> MissPiggy: yeah you didn't tell what exactly you want to implement but there are logs for proof with very smart words like Ring from you :)
12:00:13 <MissPiggy> I was trying to implement some symbolci algebra but I turned out too stupid to do it
12:00:17 <temoto> Yeah it was Eduard for church numbers.
12:01:14 <temoto> MissPiggy: see, i don't even know what's a symbolic algebra is. So if i understood conal's post about von neumann paradigm, you surely can too.
12:02:51 <jfoutz> not to put words in conal's ... chat, i think he meant there are good abstractions out there waiting to be found. just because the specification we have now is bad/good/whatever, that dosn't mean there aren't better abstractions just waiting to be found.
12:03:29 <conal> jfoutz: awesome!  that's it.
12:03:30 <temoto> conal: so what is functional semantics regarding diff $(another pipe) or, equally regarding 'f (expr)' ?
12:03:56 <MissPiggy> and what exactly is specification
12:04:03 <conal> jfoutz: please say again as a comment on that blog post.
12:04:10 <jfoutz> sure :)
12:04:13 <conal> :)
12:04:46 <temoto> @remember jfoutz There are good abstractions out there waiting to be found. Just because the specification we have now is bad/good/whatever, that dosn't mean there aren't better abstractions just waiting to be found.
12:04:46 <lambdabot> Done.
12:07:02 <jfoutz> i'll just carry on then.
12:07:26 <conal>  especially considering that we have been forced to make our programs precise, but we haven't been forced nearly as much to make our specifications precise.
12:07:39 <jmcarthur> MissPiggy: you're being so self-deprecating! it takes time for new ways of thinking about code and design to sink in
12:07:52 <conal> so there's been more progress on simple precise programs than on simple precise specifications.
12:08:50 <conal> without noting this historical difference, one might mistakenly assume that specifications are inherently resistant to simplicity.
12:09:36 <jfoutz> physics is kinda interesting in that sense. Murray Gell-Mann gave a ted talk, showing the notation getting simpler and simpler as underlying concepts got more and more complex.
12:09:49 <PeakerWork> so we have complex precise programs moving slowly towards more simplicity, and simple specifications (not) moving slowly towards preciesness?
12:09:50 <MissPiggy> jmcarthur, its true though
12:09:54 <jmcarthur> oh that sounds interesting
12:10:13 <jmcarthur> MissPiggy: what's true?
12:10:39 <pettter> @type true
12:10:41 <lambdabot> Not in scope: `true'
12:10:53 <pettter> seems we will never know
12:10:56 <MissPiggy> that whatever I know is useless because I can't do anything with it
12:11:16 <zygoloid> @faq Can haskell leave the mysteries of the universe unresolved?
12:11:16 <lambdabot> The answer is: Yes! Haskell can do that.
12:11:19 <sinelaw> MissPiggy, what do you know?
12:11:42 <PeakerWork> MissPiggy: A specification is a formal definition of expected behavior (i.e semantics).  Since the spec. doesn't necessarily have to execute, people sometimes write them with missing / contradicting details, when they aren't checked/forced to be precise, so they get imprecise specs.  The programs they write get tested and if not precise, they don't work.  So the programs are precise, and this makes simplicity harder to achiev
12:11:45 <MissPiggy> umm that's a difficult one
12:11:56 <PeakerWork> s/formal definition/definition
12:12:11 <McManiaC> is Conctrol.Concurrent.Chan something like Control.Concurrent.MVar?
12:12:15 <conal> from the blog post: "I suspect the crux of the issue here is that combining precision and simplicity is very difficult â whether for specifications or programs (or for many other other human endeavors)."  this statement is the core of the post.
12:12:21 <sinelaw> MissPiggy, i mean what is it that you consider useless, that you know?
12:12:38 <ehamberg> âBuild-Depends: base >=3, MonadRandomâ â what's wrong here? i'm told that âMonadRandom -anyâ is a missing dependency, yet it shows up in âghc-pkg listâ as âMonadRandom-0.1.4â.
12:13:06 <MissPiggy> sinelaw, well I spend years learning to program and what for? I can't even write the programs I want
12:13:15 <conal> PeakerWork: nice summary.  thx.
12:13:28 <sinelaw> MissPiggy, ain't that's how it is for us all?
12:13:52 <sinelaw> MissPiggy, what are the programs you want to write?
12:14:27 <MissPiggy> sinelaw I was trying to make this thing which would solve basic (differential) equations
12:14:38 <sinelaw> MissPiggy, with what method
12:14:46 <damjanzg> I am new to haskell, and I find it very useful but I am getting headick. How to define function when working with mod.
12:14:50 <jmcarthur> sinelaw: he was doing it symbolically iirc
12:14:54 <jmcarthur> symbolicly
12:15:01 <Twey> Right the first time
12:15:09 <alp> McManiaC, not exactly
12:15:13 <sinelaw> jmcarthur, there are different ways to do it though
12:15:14 <jmcarthur> okay, wasn't sure
12:15:16 <alp> have you read its doc ?
12:15:30 * hackagebot upload: failure 0.0.0.2 - A simple type class for success/failure computations. (MichaelSnoyman)
12:15:38 <MissPiggy> sinelaw, like how it's done on paper
12:15:44 <damjanzg> Can I post some code here?
12:15:53 <sinelaw> MissPiggy, on paper there are different ways to do it...which one do you mean?
12:15:58 <kmc_> damjanzg: put it on a pastebin
12:15:59 <alp> a Chan is "something" you put datas in and all the threads that listen to that chan receive it
12:16:04 <kmc_> damjanzg: http://hpaste.org/
12:16:15 <MissPiggy> the way I do it on paper... you know what I mean?
12:16:43 <McManiaC> alp: okay
12:16:48 <pettter> MissPiggy: there's that elusive "precision/simplicity" thingg again
12:16:51 <MissPiggy> lots of methods together make it work
12:16:53 <kmc_> alp McManiaC: only one listener will receive each element, iirc
12:16:58 <alp> oh
12:16:59 <alp> sorry
12:17:00 <kmc_> but you can duplicate a chan to make a "tee"
12:17:00 <alp> yeah
12:17:17 <kmc_> McManiaC: it is like MVar in some ways; for example, synchronization is built in
12:17:24 <jmcarthur> MissPiggy: you could hpaste your code and we could see what's going on with it
12:17:29 <alp> McManiaC, actually, the first thread that is "free" and thus "has the time" to look in the chan what's new, will receive that data.
12:17:36 <sinelaw> MissPiggy, ok, so what problem did you encounter? i mean, i would start by implementing only one method (e.g, Fourier) and later improve on it
12:17:58 <sinelaw> MissPiggy, programs are very, very hard to get right the first time
12:18:07 <damjanzg> I am new so sry for stupid mistakes, but code is here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16599#a16599
12:18:25 <kmc_> damjanzg: don't worry, we're here to help beginners :)
12:18:41 <kmc_> damjanzg: you're defining a function named "red" right?
12:18:45 <kmc_> where did "seq'" come from?
12:18:45 <medfly> a `mod` 2 == 0 ?
12:18:53 <damjanzg> yes
12:19:02 <damjanzg> sry mistake
12:19:07 <damjanzg> seq'
12:19:21 <damjanzg> red is from before
12:19:34 <kmc_> damjanzg: and it should call itself?
12:19:39 <Twey> is for floats, div is for Integrals
12:19:42 <Twey> / is for floats, div is for Integrals
12:19:58 <Twey> :t ((/), div)
12:19:59 <lambdabot> forall a a1. (Fractional a, Integral a1) => (a -> a -> a, a1 -> a1 -> a1)
12:20:12 <Twey> Fractionals, to be precise.  âº
12:20:22 <damjanzg> I got it now
12:20:31 <MissPiggy> sinelaw the first thing I wanted to write is normalization for polynomials, rational expressions then rational expressions with e^
12:20:42 <conal> MissPiggy: one way i like to think about typed, purely functional/denotative programming (e.g., haskell without IO) is that it's mainly a tool for helping you clarify one's own thinking.  as bertrand russell said, "Everything is vague to a degree you do not realize till you have tried to make it precise."
12:20:55 <kmc_> damjanzg: you also have a type error
12:20:56 <MissPiggy> (over the complex field)
12:20:57 <kmc_> for the a==1 case
12:21:01 <kmc_> because you return 1, but that's not a list
12:21:26 <MissPiggy> conal, or in my case Everything is obvious until I try to write it then I realize how I didn't know anything
12:21:36 <damjanzg> how to write that when a is 1 that it should append 1 and stop
12:21:40 <conal> MissPiggy: if you embrace that view of programming, then maybe your efforts will be more satisfying.  because you'll be gaining progress toward clarity, rather than failing to get your program working.
12:21:45 <medfly> [1]?
12:21:57 <damjanzg> would it append?
12:22:01 <conal> MissPiggy: yes!  moving from obvious to don't-know is great progress!
12:22:01 <kmc_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16599#a16600 damjanzg, here's how i would write it... pretty close to what you have
12:22:13 <kmc_> [1] is a list with one element
12:22:26 <kmc_> the other calls will append onto it
12:22:29 <conal> MissPiggy: http://conal.net/blog/posts/fostering-creativity-by-relinquishing-the-obvious/
12:22:30 <medfly> well, if you had red 1 = [1]
12:22:50 <MissPiggy> conal, it feels less like progress and more like I've had a big chunk of my brain eaten since I was last into this talking-to-computers stuff
12:22:53 <kmc_> don't think of it in terms of "doing stuff"... you're just describing values in terms of other values
12:22:54 <alp> I wholeheartedly agree with conal.
12:22:55 <medfly> if you had red 2 = 2 : red 1 = 2 : [1] = [2,1]
12:22:57 <medfly> good, no?
12:23:37 <damjanzg> omg, I am understand it now, stupid as I am
12:24:24 <conal> MissPiggy: i hope the eaten part of your brain is the imperative mindset (program as "do" rather than program as "be")
12:24:32 <damjanzg> tnx everyone I will be back with more question.
12:24:38 <sinelaw> conal, just to throw some idea in the air before i leave, i've been thinking about the connection between information theory and FRP. continuous processes have infinite information, and entropy for them is defined in relative terms. maybe there's something to chase there. i will when i have more time.
12:24:54 <conal> sinelaw: i like it!
12:25:26 <jmcarthur> MissPiggy: unlearning is more important than learning, in my opinion
12:25:45 <conal> jmcarthur: woot!  i was just about to mention unlearning as crucial.
12:25:47 <jfoutz> gah. that's really creapy. sinelaw, i was thinking about the *same* thing.
12:25:59 <temoto> MissPiggy: yeah, btw, unlearning is the only way to understand monads.
12:26:07 <kmc_> temoto: i don't agree at all
12:26:11 <MissPiggy> my program doesn't use monads
12:26:11 <kmc_> let's all stop mystifying monads
12:26:15 <sinelaw> jfoutz, cool
12:26:20 <sinelaw> any ideas?
12:26:21 <kmc_> a monad is an instance of this small typeclass
12:26:25 <kmc_> that's all
12:26:50 <temoto> Yup, and you have to unlearn burritos before you realize this simplicity.
12:27:08 <MissPiggy> I don't think I am unlearning anything or reaching some kind of clearer understanding of whatever, I feel like I just have no clue what I am doing and not getting anywhere because I'm trying to do something that's beyond my thinking ability
12:27:12 <jmcarthur> *knowing* is toxic. only by recognizing one's own ignorance can discovery begin
12:27:24 <jfoutz> sinelaw: more along the lines of, reading from io introduces more information into the system. frp without io ... should be super clean.
12:27:31 <kmc_> but maybe it'd be better if people didn't go through the burrito stage first
12:27:32 <sinelaw> an FRP system must in principle *lose* information to be realistic.
12:27:32 <MissPiggy> if I was the most ignorant person in the world, and knew it, I still couldn't write this program
12:27:41 <kmc_> all the noise about monads makes people think they're both harder and more fundamental to Haskell than is the case
12:27:55 <conal> @remember jmcarthur: *knowing* is toxic. only by recognizing one's own ignorance can discovery begi
12:27:56 <lambdabot> Nice!
12:27:58 <jmcarthur> MissPiggy: the very fact that it seems less obvious to you now than your expectations made it out to be tells me you are in the process of unlearning
12:28:08 <conal> urg.  lost the final "n" :(
12:28:08 <jmcarthur> conal: you broke the quote :P
12:28:16 <sinelaw> @quote toxic
12:28:16 <lambdabot> jmcarthur: says: *knowing* is toxic. only by recognizing one's own ignorance can discovery begi
12:28:34 <conal> @forget jmcarthur: *knowing* is toxic. only by recognizing one's own ignorance can discovery begi
12:28:34 <lambdabot> Done.
12:28:36 <jfoutz> sinelaw: the other thing i was trying to nail down is exactly how much information a function might have. 2^32 (op) 2^32 possible functions for Int -> Int -> Int = 4^32 possible functions? something like that.
12:28:50 <conal> @remember jmcarthur: *knowing* is toxic. only by recognizing one's own ignorance can discovery begin
12:28:51 <lambdabot> It is stored.
12:28:54 <conal> phew
12:29:02 <temoto> kmc_: we discussed it and came to conclusion that people do seek for analogies so burritos were introduced. It's like demand / supply thing.
12:29:11 <conal> @quote toxic
12:29:11 <lambdabot> jmcarthur: says: *knowing* is toxic. only by recognizing one's own ignorance can discovery begin
12:29:30 <kmc_> temoto: there was a burrito committee?
12:29:46 <temoto> kmc_: yup and i believe you participated.
12:29:49 <pettter> jfoutz: take a look at kolmogorov complexity for nifty theories on information
12:29:55 <sinelaw> jfoutz, that's also an interesting question. information content of functions.
12:30:00 <kmc_> were there free burritos served on the burrito committee?
12:30:26 <jmcarthur> MissPiggy: is the program itself the goal? it seems to me that this kind of program is more of an exercise from which to learn. i would say you are in a good position to achieve that
12:30:41 <temoto> kmc_: we came to conclusion that the path is: try to seek for analogies -> find they're all wrong -> give up seeking for analogies -> voila, enlightment.
12:30:52 <sinelaw> pettter, the same kolmogorov from the theorem about FT of a random process' autocorrelation?
12:31:10 <jmcarthur> conal: you broke that quote too :P i'll try and fix it
12:31:11 <pettter> sinelaw: quite possible, I haven
12:31:22 <pettter> *haven't really dug into the area myself
12:31:22 <MissPiggy> yes I just want to write the program, I spent all my time learning so much theory that I can't do anything useful
12:31:25 <jmcarthur> @forget jmcarthur: *knowing* is toxic. only by recognizing one's own ignorance can discovery begin
12:31:25 <lambdabot> Done.
12:31:38 <MissPiggy> I thought I was teaching myself how to program, but I was only learning how to talk about programming
12:31:47 <jmcarthur> @remember jmcarthur *knowing* is toxic. only by recognizing one's own ignorance can discovery begin
12:31:48 <lambdabot> Nice!
12:31:49 <temoto> jmcarthur: you forgot the correct one :)
12:31:58 <jmcarthur> temoto: what?
12:32:18 <temoto> jmcarthur: you issued forget command for the correct quote :)
12:32:22 <jfoutz> sinelaw: all of the physical entropy stuff deals with total energy of the system vs how much is available for work. so ... quantifying the total information + information introduced from events might give some neat insight about frp. (it hasn't yet :) for me anyway.
12:32:27 <temoto> not for 'begi' one
12:32:38 <pettter> MissPiggy: you don't understand the algorithm you are trying to implement
12:32:38 <jmcarthur> temoto: no i didn't. it said that "jmcarthur:" said it
12:33:11 <conal> jmcarthur: oh!  i finally get it.
12:33:11 <conal> jmcarthur: thx
12:33:19 <temoto> jmcarthur: ah never mind, conal already issued forget for wrong quote.
12:33:21 <pettter> the problem is not in transferring your knowledge to the computer, it's actually formalising the knowleddge in your own head first
12:34:08 <conal> pettter: yeah.  and the computer helps by rejecting fuzziness.
12:35:40 <jfoutz> pettter: kolomogrov complexity is neat. i've barely touched the surface. chaitin's got some interesting stuff too.
12:36:04 <conal> MissPiggy: i also like this advice from george polya, for getting unstuck: "If you can't solve a problem, then there's an easier problem you can solve: find it."
12:37:48 <temoto> conal: do you know select(2) unix function?
12:38:26 <conal> temoto: we're acquainted.
12:39:05 <conal> temoto: but not intimate
12:39:36 <pettter> select is a nice and clean interface for multiplexing
12:39:53 <kmc_> ehh
12:39:54 <temoto> conal: would be a bunch of write() on a group of file descriptors from one end and select() on that group on other end be an example of non-linear flow of data?
12:39:55 <kmc_> not so much
12:40:02 <temoto> pettter: and inefficient.
12:40:10 <pettter> temoto: that too
12:40:55 <pettter> temoto: potentially nonlinear, at least
12:41:01 <temoto> I'm still trying to find what's non-linear composition is.
12:41:56 <conal> temoto: here's a simpler example:  \ x -> sin x + cos x.   also written as liftA2 (+) sin cos.  or just sin + cos.
12:42:34 <marlin> hello everyone, i've got a rather specific question on the evaluation in haskell.
12:42:40 <temoto> \x -> sin x + cos x is not the same as sin + cos.
12:42:45 <conal> temoto: info flows into the composite function (sin + cos) and then into sin & cos in parallel.  not a chain.  linear composition isn't adequate to express it.
12:42:56 <conal> temoto: see applicative-numbers
12:43:06 <kmc_> marlin: cool
12:43:13 <jmcarthur> temoto: they are the same
12:43:30 <jmcarthur> or, rather, can be made to be the same
12:43:35 <conal> @wiki applicative-numbers
12:43:36 <lambdabot> http://www.haskell.org/haskellwiki/applicative-numbers
12:43:46 <temoto> > let f = const 1 in f + f
12:43:47 <lambdabot>   No instance for (GHC.Num.Num (b -> t))
12:43:47 <lambdabot>    arising from a use of `GHC.Num.+'...
12:44:18 <jmcarthur> temoto: unfortunately we can't have a *complete* instance of Num for functions with the way our library is designed
12:44:31 <jmcarthur> requiring Eq and Show and stuff
12:44:44 <conal> oh -- i forgot the wiki page was so spartan.
12:44:46 <jmcarthur> so we don't have one defined by default
12:45:13 <temoto> conal: so non-linearity is all about passing multiple values that don't depend on each other?
12:45:14 <marlin> i have: prod [] = 1 and prod (x:xs) = x * prod xs. and i would like to know what exactly happens when i run that function on the input [4,3,2,1].
12:45:37 <kmc_> you don't really "run" functions, you apply them to arguments, and then reduce the result to normal form
12:45:41 <jmcarthur> temoto: with the appriopriate instance defined you could have event just said "1" instead of "const 1"
12:45:51 <jmcarthur> *even just said
12:46:01 <kmc_> marlin: what's your understanding so far?
12:46:14 <temoto> jmcarthur: instance for functions?
12:46:18 <jmcarthur> let f = 1 in 1 + 1 $ "foo"
12:46:18 <marlin> mkc_ yea, that's what i mean ;) anyways, in the first steps it would evaluate to something like 4 * prod [3,2,1] i suppose, right?
12:46:23 <jmcarthur> temoto: yup
12:46:30 <kmc_> yeah
12:46:56 <temoto> jmcarthur: how would it differentiate f _ = 1 from f _ _ _ = 1 ?
12:47:04 <jmcarthur> temoto: type inference
12:47:10 <marlin> but then, do i get 4 * 3 * prod [2,1], or do i get 4 * (3 * prod [2,1])?
12:47:16 <conal> temoto: by "non-linear" composition i mean not linear, and by "linear" i mean (.), as in h . g . f
12:47:18 <jmcarthur> temoto: depends how you use f
12:47:24 <kmc_> marlin: by the former do you mean (4 * 3) * prod [2,1] ?
12:47:26 <kmc_> it's the latter
12:47:39 <marlin> yes, i mean that
12:47:45 <kmc_> as you had:  4 * (prod [3,2,1])
12:47:46 <conal> temoto: so, for instance \ x -> sin (cos x) is linear, because it's equivalent to sin . cos
12:48:01 <kmc_> then you evaluate inside the parens
12:48:06 <kmc_> 4 * (3 * prod [2,1])
12:48:12 <temoto> conal: like a law? non-linear is everything that's not linear, not limited to liftA2 (+) sin cos ?
12:48:25 <marlin> okay, thanks for the answer. ;) now, can you also explain *why* that happens? basically i'm interested in the conditions under whcih haskell adds the brackets around a term
12:48:43 <kmc_> marlin: well, an expression is really a tree
12:48:52 <conal> temoto: i don't know what you mean by "like a law".  yes, to the second question.
12:48:56 <kmc_> parentheses are just a way of writing the tree in linear text
12:49:26 <marlin> okay. so basically, any time i evaluate an expression, haskell actually puts parantheses around it?
12:49:36 <kmc_> what do you mean by "puts parentheses around it"
12:49:42 <jmcarthur> marlin: the parentheses are just syntax
12:49:58 <kmc_> marlin: here's an example of what i mean by "an expression is a tree": http://cale.yi.org/index.php/Fold_Diagrams
12:50:01 <temoto> conal: like (==) = not (/=) law :)
12:50:02 * pettter noms on some syntactic sugar
12:50:31 <jmcarthur> temoto: how would you express the law you are talking about?
12:50:47 <marlin> ah, okay. i think i get what you mean kmc_
12:50:49 <kmc_> marlin: so expressions are trees... and when we evaluate them, we get graphs
12:50:51 <kmc_> for example
12:50:55 <kmc_> > let x = "abc" in (x, x)
12:50:56 <lambdabot>   ("abc","abc")
12:51:12 <kmc_> you can think of that as a single (,) node with *two* arrows going to the *same* string "abc"
12:51:20 <kmc_> not two copies of the string
12:51:43 <kmc_> that's important, because as evaluation proceeds, we will find some function applications within the graph, evaluate them to normal form, and replace that node with the normal form value
12:51:48 <kmc_> and we don't want to duplicate that work
12:51:51 <temoto> jmcarthur: well it's written in Eq class definition, that's precisely how i'd express it but i'd put a triple = in the middle to note that it works both ways.
12:51:53 <conal> temoto: oh, thx.  a definition, not a law.
12:52:10 <temoto> okay, definition
12:52:14 <jmcarthur> temoto: i mean this linear/non-linear thing you are talking about
12:52:43 <marlin> right. i remember it faintly ;) see, i'm currently a tutor for some other students in haskell, but it's been a year since i did anything there and so i wasn't certain about some things anymore
12:52:59 <temoto> jmcarthur: well he said the expression: "non-linear is not linear", i just asked how to interpret it. The answer - it should be interpreted as a definition.
12:53:10 <jmcarthur> ah, okay
12:53:13 <marlin> so basically, it's really a graph, not some sort of text operation :P
12:53:23 <temoto> But x is not y is not constructive.
12:53:34 <conal> in the expression-as-tree POV, "x+y" is (really deserializes to) the same expression as "((x)+(((y))))".
12:53:36 <mauke> hah, a haskell interpreter that uses textual replacement might be fun
12:53:52 <marlin> i mean hey, makes sense of course, but i guess i got foiled by the exercises that ask us to write the evaluation down on paper
12:53:59 <kmc_> marlin: yes, most language implementations operate on syntax trees
12:54:14 <temoto> conal: oh boy, why 3 parens around y while 2 around x ?
12:54:24 <mauke> why not?
12:54:26 <conal> temoto: only one around x.
12:54:29 <kmc_> most good language implementations separate cleanly into at least two phases: turn the text input into a syntax tree, then work on it
12:54:32 <conal> temoto: and one around the sum
12:54:41 <kmc_> some ugly ad-hoc interpreters like perl violate this
12:54:42 <temoto> yeah and 2 around y
12:54:51 <kmc_> and it becomes harder if you want user-definable concrete syntax
12:54:54 <temoto> no, still 3 around y
12:54:57 <conal> temoto: to emphasize the arbitrariness/meaninglessness of parens
12:54:58 <jmcarthur> ((+)(x)(y))
12:55:00 <temoto> ah
12:55:19 <mauke> kmc_: did you mean: /bin/sh
12:55:21 <jmcarthur> ((((((((+))))))))x((((((((((y))))))))))
12:55:23 <kmc_> hehe
12:55:24 <kmc_> that too
12:55:35 <mauke> kmc_: because perl actually compiles code into a tree first
12:55:51 <kmc_> sort of
12:55:53 <pettter> newer versions, at least
12:55:55 <kmc_> sort of doesn't
12:55:55 <marlin> alright, i think i got it folks ;) thanks a lot for your help
12:56:04 <kmc_> perhaps you can consider it a dynamic JIT compiler
12:56:04 <jmcarthur> has perl 5 been proven to be unparsable?
12:56:07 <jmcarthur> *hasn't
12:56:07 <kmc_> yes
12:56:24 <mauke> not this shit again
12:56:32 <kmc_> yeah, sorry i brought it up
12:56:43 <temoto> conal: so there are non-linear compositions and they have that characteristic that in case of liftA2 (+) sin cos, the values *may* potentially be evaluated in parallel.
12:57:06 <temoto> conal: is that (parallelism) all to non-linear compositions, what they are useful at?
12:57:22 <temoto> uh.. what they empower with
12:57:32 <monochrom> I am bind. I mistype >>= as >= and cannot understand the error message "No Ord instance"
12:57:50 <temoto> monochrom: hello, i am return.
12:58:05 <c_wraith> are you two going to free gozer now?
12:58:07 <mauke> <monochrom> I am bind
12:58:10 <kmc_> i am jack's monad operator
12:58:19 <temoto> LOL
12:58:25 <aavogt> haha
12:58:35 <aavogt> I can't see either
12:58:47 <temoto> @remember kmc i am Jack's monad operator
12:58:47 <lambdabot> I will never forget.
12:59:06 <ptolomy2> Someone posted on proggit that they made a fractal generator in haskell, and it was speedy, but they gave up and went for Erlang because they couldn't see how to parallelize it. (Code at http://pastie.org/795329) This marks the first time I'd heard the "Haskell is too hard to parallelize" complaint.
12:59:21 <jmcarthur> profmakx: me too
12:59:29 <jmcarthur> err
12:59:32 <kmc_> well, it's much different from other languages
12:59:35 <jmcarthur> ptolomy2: me too
12:59:42 <shambler> cheesy tab complention
12:59:42 <kmc_> for starters you have the choice between semi-explicit parallelism and explicit concurrency
13:00:02 <temoto> ptolomy2: which is strange, because personally i find parallelization in haskell easier than in erlang.
13:00:07 <pettter> erlang is inherently parallellised in a veryy different way, isn't it?
13:00:07 <ptolomy2> I suppose if you're thinking in terms of spawning threads with state and whatnot, it would seem somewhat hard.. but still easier than pthreads.
13:00:20 <kmc_> i like this talk for a quick intro to parallelizing haskell code: http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
13:00:40 <kmc_> it's not at all hard to spawn a thread with state in Haskell
13:00:55 <jmcarthur> i think the submitter's problem is a mental mixing of parallelism and concurrency
13:01:26 <jmcarthur> he probably had a pure program and thought he had to use forkIO to get parallelism
13:01:45 <jmcarthur> or maybe i should look at the code before i speculate
13:02:02 * ptolomy2 just thinks "oh. `par`".
13:02:04 <aavogt> well you can use forkIO to get parallelism
13:02:09 <jmcarthur> yeah, it looks mostly pure
13:02:11 <marlin> quit
13:02:17 <jmcarthur> aavogt: yeah, in the IO monad
13:02:24 <aavogt> you just have to be careful to force results in the other thread
13:02:31 <jmcarthur> right
13:02:45 <conal> temoto: expressiveness is what i was getting at, not any implementation advantage like parallel evaluation
13:02:46 <jmcarthur> it's troublesome compared to pure parallelism though
13:02:47 <ptolomy2> I guess if you're doing all of your work in a list comprehension, and you think "how can I make this abstract thing happen on N different threads?"
13:03:11 <kmc_> then you use parMap
13:03:11 <aavogt> @docs Control.Parallel.Strategies
13:03:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel-Strategies.html
13:03:23 <kmc_> though, the strategies stuff is still in flux
13:03:29 <jmcarthur> kmc_: right, but i speculate that this isn't the kind of thing that occurred to the submitter on reddit
13:03:35 <aavogt> @hoogle parMap
13:03:36 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
13:03:48 <kmc_> *shrug*
13:03:53 <aavogt> kmc_: who has that module now?
13:03:59 <kmc_> ?
13:08:35 <temoto> conal: alright, and since we totally have non-linear composition in (at least) haskell programs, your primary concern is about non-linear composition of programs, and this is what Eros is about?
13:09:34 <xle> is there anything like ruby on rails for haskell in the works?
13:09:43 <conal> temoto: yeah -- that's part of what eros is about.  non-linear composition.  also semantic/direct/tangible composition.
13:09:51 <jmcarthur> xle: "like ruby on rails" meaning what?
13:10:12 <temoto> xle: yes, Happstack. Tottally far from what RoR is now.
13:10:22 <xle> jmcarthur: meaning a web-app framework based on MVC with easy configuration, and regular bells and whistles to make developers happy
13:10:22 <jmcarthur> xle: we have a few web frameworks with varying degrees of high- and low-levelness
13:10:29 <c_wraith> I'm assuming he means "completely convention driven and ill-suited to anything that works outside of those conventions"
13:10:34 <conal> sadly, on the outside, haskell programs are still basically unix programs
13:10:49 * c_wraith is bitter about how badly rails fails when you want to do something creative
13:10:56 <conal> in that they're imperative and only linearly composable and compose via text streams.
13:11:05 <jmcarthur> xle: what does MVC mean? (i know what it stands for. i'm looking for your own explanation, as the term is ambiguous)
13:11:06 <xle> well, i've been using RoR for about 3 years now and just started using haskell for some of my more algorithmic work
13:11:15 <temoto> conal: okay, happy that i understood a part. What is semantic composition?
13:11:28 <xle> i've been finding myself wishing some of my RoR projects were possible in haskell
13:11:55 <mreh> how do you define the word "framework" in a language context
13:12:03 <jmcarthur> xle: i am a fan of happstack for entirely different reasons than i used to be a fan of rails
13:12:15 <jmcarthur> mreh: yeah good point
13:12:20 <xle> jmcarthur: well i guess MVC mostly is good for its ORM and templating
13:12:31 <xle> jmcarthur: templating is probably not a big deal, so i would say it's all about easy DB access
13:12:39 <jmcarthur> xle: then pick an ORM and a remplating engine and run :)
13:12:50 <jmcarthur> xle: although we don't really have "ORM"s per se
13:12:52 <xle> jmcarthur: :)
13:13:01 <temoto> ^ that's a good point.
13:13:03 <jmcarthur> *templating
13:13:04 <xle> jmcarthur: right.. i've been using hdbc but it still feels a bit low level
13:13:05 <conal> temoto: composition on the level of meanings of programs (ie values).  as contrasted with how programmers form expressions by manipulating syntax (especially in the presence of variables).
13:13:25 <temoto> You don't need any RoR or something to use template engine or ORM.
13:13:37 <jmcarthur> xle: i like takusen
13:13:57 <luqui> conal, i was always terrible at programming with eros
13:13:59 <jmcarthur> xle: i think a good database adapter is going to be low level, otherwise you can't take good advantage of the database's features
13:14:14 <luqui> didn't match the wiring of my brain
13:14:21 <luqui> which i guess is what you are talking about :-)
13:14:48 <xle> jmcarthur: you meantioned you liked happstack for completely different reasons.. what were those?
13:15:11 <temoto> conal: does it relate to types of values?
13:15:25 <conal> luqui: could be.  tfp/eros is aimed at folks who aren't already used to syntax munging and to the syntax/semantics split (program/run).
13:15:26 <xle> btw, i'm not really a fan of rails, although I'm sometimes amazed at what it allowed me to do even just by myself
13:15:45 <jmcarthur> xle: it has no real conventions and is very low level compared to rails
13:15:59 <mreh> is finding the fewest, say, coins to make a total an easy problem to solve?
13:16:00 <jmcarthur> xle: and it all fits together very nicely, for me
13:16:03 <conal> gotta run.  catch you all later.
13:16:07 <mreh> i terms of complexity
13:16:09 <xle> jmcarthur: so you build your own helpers and structure before you start your projects?
13:16:28 <jmcarthur> xle: helpers in the rails sense? that's kind of ambiguous
13:16:54 <jmcarthur> xle: the entire architecture of a project using happstack libraries is up to you
13:17:11 <xle> jmcarthur: ah no, helpers in the general sense.. I meant the building blocks and patterns that you will use over and over again in the project.. stuff that will hopefully help you develop your project much faster
13:17:18 <jmcarthur> there isn't really a "conventional" or "cannonical" architecture
13:17:27 <xle> jmcarthur: I understand that.. I was just asking what you do when you begin a mid/large project on happstack
13:17:32 <jmcarthur> xle: happstack has some basic conveniences
13:17:42 <jlouis> ok, the Numerical tower pulls hair out of my head. I have a Data.Time.Clock NominalDiffTime. I need the seconds in difference it represents as a Double. NominalDiffTime is not an Integral member
13:18:27 <jlouis> time is 1.1.2.4 fwiw
13:18:40 <jmcarthur> xle: happstack is eventually intended to be ideal for mid- and large-sized projects more than for small ones, which is also very different from the typical rails idea of "don't scale until you need to"
13:18:42 <luqui> jlouis, huh?  realToFrac?  or are you complaining that it doesn't have enough accuracy?
13:18:51 <damjanzg> what is the address for pastebin?
13:18:54 <jmcarthur> xle: i don't think happstack is there yet though, regarding that goal
13:19:27 <jmcarthur> xle: the architecture being up to you means you are in charge of your own abstractions, yes
13:19:41 <jlouis> luqui: oh! thanks
13:19:44 <jmcarthur> xle: but like i said, there are some good abstractions already
13:20:05 <jlouis> luqui: I was sure I was missing something simple :)
13:20:45 <jmcarthur> xle: btw, if you are looking for a nice database adapter, i'm a fan of takusen... it's probably extremely different from what you are used to though
13:20:56 <damjanzg> What thoes it mean that something is rigid type variable bound by type signature?
13:21:18 <kmc_> that's hard to explain without context
13:21:22 <kmc_> you got this error from ghc?
13:21:26 <kmc_> can you hpaste the code?
13:21:36 <xle> jmcarthur: thanks for the tip, I'll take a look at takusen
13:21:37 <damjanzg> Can I give you some simple code?
13:21:42 <xle> jmcarthur: i've noticed it before but never really looked at it
13:21:49 <kmc_> yes, upload it to hpaste
13:21:49 <c_wraith> damjanzg: it means you have something like "a" in the type signature, but you're trying to use a specific type there
13:21:58 <jmcarthur> xle: warning: oleg made it
13:22:01 <mauke> > let foo :: a -> (); foo x = x in foo ()
13:22:02 <lambdabot>   Couldn't match expected type `()' against inferred type `a'
13:22:02 <lambdabot>    `a' is a rig...
13:22:05 <xle> jmcarthur: I guess I should give happstack a go and see if I can setup something I'm comfortable with in it
13:23:36 <damjanzg> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16610#a16610 something is wrong with runseq function and I dont see difference from first function that is working.
13:23:55 <mauke> it's length
13:24:11 <mauke> :t length
13:24:12 <lambdabot> forall a. [a] -> Int
13:25:00 <damjanzg> length expect list, and I dont have list
13:25:23 <mauke> length returns Int, not Integral a => a
13:26:19 <damjanzg> I thout that Int is "subclass" of Integral
13:26:30 <mauke> no, Int is a type, not a class
13:26:36 <mauke> it's an instance of Integral
13:27:10 <mauke> but what you're asking for is basically a cross-cast
13:27:21 <damjanzg> Then how to solve a problem here, ?
13:27:37 <mauke> Int -> supertype "Integral" -> random integer subtype
13:27:50 <mauke> well, you could use genericLength
13:27:59 <mauke> or convert the result with fromIntegral
13:29:43 <Zao> I'm starting to get a feeling that if I'm to do serious FFI, c2hs is a Good Thing?
13:36:59 <RayNbow> hmm...
13:37:01 <RayNbow> @src maximum
13:37:01 <lambdabot> maximum [] = undefined
13:37:01 <lambdabot> maximum xs = foldl1 max xs
13:37:49 <RayNbow> ...so that caused a stack overflow in ghci :p
13:38:20 <solrize> use  foldl1'
13:40:19 <RayNbow> solrize: yeah, I did that to solve it :)
13:43:56 <xle> jmcarthur: out of curiosity.. why do you like takusen better than hdbc?
13:46:18 <jmcarthur> xle: efficiency and an api that makes it hard to screw things up
13:46:33 <jmcarthur> not necessarily an "elegant" api, though
13:47:05 <jmcarthur> but i don't consider hdbc to have an elegant api either
13:55:20 <sm> byorgey: nice monad reader, thanks!
13:55:45 <byorgey> sm: thanks, and you're welcome!
13:55:57 <byorgey> most of the hard work was done by the authors, of course.
13:56:05 <sm> indeed, thanks authors
13:56:06 <byorgey> but I am pleased with how it came out. =)
13:56:22 <solrize> byorgey, nice job
13:56:26 <sm> I particularly admired apfelmus' writing
13:56:56 <solrize> also to the authors :)
13:57:26 <meanburrito920_> I'm probably going about this the wrong way, but I'm writing a function to randomly select an element from a list. I'm using randomIO, but that returns an (IO a), so I drop it into a do block. My question is, how do I have my function type be [a] -> a? At the moment it thinks it is [IO b] -> b
13:57:37 <meanburrito920_> or rather [IO b] -> IO b
13:57:39 <byorgey> meanburrito920_: you can't.
13:57:52 <kmc_> meanburrito920_: there is no way to get out of the IO monad.  pull other stuff in instead
13:57:58 <byorgey> meanburrito920_: a function with type [a] -> a must always return the same value given the same input list.
13:58:20 <meanburrito920_> byorgey: it should. the value returned is a randomly selected value from the original list
13:58:35 <alp> byorgey, nice edito :-)
13:58:56 <byorgey> meanburrito920_: if you call your function on [1,2,3], what should it return?
13:59:03 <solrize> meanburrito920_, if it selects the same value every time, that's not very random ;)
13:59:08 <meanburrito920_> 1 or 2 or 3
13:59:24 <meanburrito920_> solrize: it doesnt select the same value every time, it randomly selects one
13:59:25 <Vulpyne> random_number = 4 -- Selected by fair random dice roll
13:59:33 <meanburrito920_> xkcd :)
13:59:38 <solrize> meanburrito920_, a pure function has to return the same value EVERY TIME
13:59:40 <byorgey> meanburrito920_: what I'm saying is, a function of type [a] -> a is pure: functions which are pure always return the same value, given the same input
13:59:49 <pikhq> meanburrito920_: Then it's not [a] -> a, now is it?
13:59:49 <byorgey> meanburrito920_: they cannot decide to do different things sometimes
13:59:49 <solrize> it's like a const declaration in c++ or final in java
13:59:51 <solrize> it can't change
13:59:59 <solrize> if you want it to be able to change, it has to be in IO
14:00:13 <pikhq> meanburrito920_: What you want is a function of type [a] -> IO a
14:00:20 <meanburrito920_> right
14:00:22 <solrize> yeah, what pikhq says
14:00:31 <meanburrito920_> but I'm confused as to how to do that
14:00:41 <kmc_> which is still a pure function -- but what it returns is not an "a", but a recipe for how to get an "a"
14:00:52 <kmc_> meanburrito920_: hpaste the code you have now and i'll massage it
14:01:41 <meanburrito920_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16611#a16611
14:01:43 <meanburrito920_> thanks
14:01:55 <kmc_> solrize: it's not much like const or final.  those express the property that a variable's value can't change.  "pure function" expresses the property that function output is determined solely by input
14:02:03 <kmc_> there are annotations for that in GNU C but iirc not in the standard
14:02:20 <kmc_> in Haskell, all variables have the first property, and all functions have the second property
14:02:28 <kmc_> (unless you are cheating)
14:02:43 <kmc_> meanburrito920_: i think you want "return" on your last do statement
14:02:50 <kmc_> return (xs !! (mod rand $ length xs))
14:03:17 <meanburrito920_>     Couldn't match expected type `IO b' against inferred type `[a]'
14:03:30 <kmc_> because that expression produces an 'a', not an 'IO a'... "return" injects the value into the monad
14:03:41 <meanburrito920_> kmc_: that was with the return
14:03:43 <solrize> sure, it's not isomorphic to const or final, there's just some commonality to the end result
14:03:53 <kmc_> btw, i can give other advice on style and efficiency
14:04:04 <meanburrito920_> kmc_: oops, i forgot the $
14:04:19 <meanburrito920_> kmc_: and if you wouldnt mind giving other advice, that would be great
14:04:51 <kmc_> the code you pasted *is* type correct, and almost does what you wanted.  it takes a list of IO recipes, picks one randomly, and executes it, returning the result
14:04:58 <solrize> what is subject reduction?
14:05:41 <meanburrito920_> solrize: I'm not sure i understand your question
14:05:52 <kmc_> meanburrito920_: first of all, put a type signature on every top level binding
14:06:00 <kmc_> maybe you already had one, and removed it to see the inferred type
14:06:01 <kmc_> that's legitimate
14:06:12 <solrize> meanburrito920_, sorry, question was completely unrelated to your program, it was about PL theory
14:06:21 <solrize> but i think i found some webpages that i can figure it out from
14:06:22 <kmc_> instead of using randomIO and mod, you can use randomRIO
14:06:24 <kmc_> :t randomRIO
14:06:26 <lambdabot> forall a. (Random a) => (a, a) -> IO a
14:06:57 <meanburrito920_> kmc_: yeah i removed it to see the type
14:07:16 <kmc_> also, (!!) and "length" are expensive operations
14:07:28 <kmc_> a list is really not the right data structure for choosing a random element
14:07:33 <meanburrito920_> kmc_: right, but i couldnt see a better way to make sure i was in the correct range
14:07:41 <kmc_> but, if your lists are short or you just don't care about performance, then go for it
14:08:04 <meanburrito920_> kmc_: yeah, i was just going to model some probability problems, i wasnt going to have too long of lists
14:08:46 <kmc_> even if your function must get passed a list, you can put it in an array internally before choosing an element
14:09:06 <solrize> well you have to traverse it to do that
14:09:22 <mreh> > sequence [Maybe 1, Maybe 2, Maybe 3]
14:09:23 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe...
14:09:29 <mreh> damn
14:09:36 <mreh> > sequence [Just 1, Just 2, Just 3]
14:09:38 <lambdabot>   Just [1,2,3]
14:09:45 <mreh> > sequence [Just 1, Nothing, Just 3]
14:09:45 <meanburrito920_> solrize has a point
14:09:46 <lambdabot>   Nothing
14:09:49 <mreh> w00t
14:09:57 <idnar> mreh: there's also catMaybes
14:10:04 <idnar> > catMaybes [Just 1, Nothing, Just 3]
14:10:05 <lambdabot>   [1,3]
14:10:21 <mreh> idnar: I need that failing behaviour
14:10:24 <mreh> cheers though
14:10:26 <idnar> mreh: okay
14:11:35 <meanburrito920_> kmc_: it may be due to my lack of understanding of instances, but I'm a bit confused as to how to use the Random Int instance
14:12:34 <McManiaC> is there a way to kill *all* threads on exit?
14:12:38 <Apocalisp> Can tails be written as a foldl?
14:12:53 <jmcarthur> McManiaC: shouldn't it kill them anyway?
14:13:27 <ddarius> Apocalisp: No
14:13:43 <jmcarthur> @src tails
14:13:43 <lambdabot> tails []         = [[]]
14:13:43 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
14:13:52 <McManiaC> jmcarthur: well, it doesnt
14:14:54 <jmcarthur> > let tails = takeWhile (not . null) . iterate (drop 1) in tails [1..10]
14:14:56 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
14:15:25 <jmcarthur> > let tails = takeWhile (not . null) . iterate (drop 1) in tails [1..3]
14:15:26 <lambdabot>   [[1,2,3],[2,3],[3]]
14:15:35 <jmcarthur> i guess i should leave in a [], too
14:15:59 <Apocalisp> hmm, it's a hylo
14:16:13 <mreh> if I do: do { a <- Nothing ; .... } the evaluation stops there, correct?
14:16:14 <ddarius> Everything is a hylo.  It's a paramorphism.
14:16:47 <jmcarthur> not sure how to leave a [] at the end without (++) in that version without making it more complicated
14:16:55 <Apocalisp> thanks, ddarius
14:16:55 <pikhq> > Nothing >>= \_->return Just ()
14:16:56 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
14:16:56 <lambdabot>         against inferred ...
14:17:01 <PeakerWork> jmcarthur: DLists?
14:17:16 <pikhq> > Nothing >>= \_-> Just ()
14:17:17 <lambdabot>   Nothing
14:17:24 <jmcarthur> PeakerWork: that would work, but i was thinking only in terms of plain lists
14:17:25 <pikhq> mreh: Yes.
14:20:39 <jmcarthur> > let tails = uncurry (:) . head &&& map tail <<< takeWhile (not . null) . iterate (drop 1) in tails [1..3]
14:20:40 <lambdabot>   Couldn't match expected type `(a, [a])'
14:20:40 <lambdabot>         against inferred type `[a1]'
14:20:51 <jmcarthur> > let tails = uncurry (:) <<< head &&& map tail <<< takeWhile (not . null) . iterate (drop 1) in tails [1..3]
14:20:52 <lambdabot>   [[1,2,3],[2,3],[3],[]]
14:20:56 <jmcarthur> :)
14:21:38 <Apocalisp> haha
14:22:14 <damd> > var i = 3; return i * 2;
14:22:15 <lambdabot>   <no location info>: parse error on input `='
14:22:20 <jmcarthur> doesn't really save any time over (++[]) though
14:22:55 <jmcarthur> damd: this isn't javascript
14:23:16 <Olathe> > let i = 3 in i * 2
14:23:17 <lambdabot>   6
14:23:19 <jmcarthur> > let i = 3 in i * 2
14:23:20 <lambdabot>   6
14:23:23 <jmcarthur> grr
14:23:46 <damd> > for (j in (let i = 3 in i * 2)) { i++; } return i;
14:23:47 <lambdabot>   <no location info>: parse error on input `in'
14:23:58 <jmcarthur> damd: ???
14:24:04 <damd> how can i for loop in haskell
14:24:12 <monochrom> haha why do people try so hard to fit foreign ideas such as var and subtype into haskell.
14:24:12 <jmcarthur> you don't
14:24:14 <dino-> > (* 2) 3
14:24:15 <lambdabot>   6
14:24:20 <lispy> damd: flip map
14:24:25 <lispy> :t flip map
14:24:26 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
14:24:36 <damd> what is means flip map
14:24:36 <jmcarthur> damd: what is j supposed to even be?
14:24:53 <damd> jmcarthur: i want j looping from 3 to 6
14:24:56 <lispy> > let for = flip map in for [1..10] (\x -> x+1)
14:24:57 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
14:25:12 <lispy> damd: ^^
14:25:17 <jmcarthur> > length [3..6]
14:25:18 <lambdabot>   4
14:25:20 <Olathe> > map (\i -> i * 2) [3..6]
14:25:21 <lambdabot>   [6,8,10,12]
14:25:39 <monochrom> j loops from 3 to 6, only to increase i every time, then only to provide the final i and throw away everything?
14:25:40 <ddarius> > let paraList c n [] = n; paraList c n (x:xs) = c x xs (paraList c n xs) in paraList [[]] (\x xs tailsXs -> (x:xs):tailsXs) [1,2,3]
14:25:41 <lambdabot>   Couldn't match expected type `t1 -> [t1] -> t -> t'
14:25:41 <lambdabot>         against inferre...
14:26:00 <lispy> damd: if you really want an imperative style loop you could use STRefs
14:26:06 <jmcarthur> damd: you just want the length of a list containing 3 through 6 ;)
14:26:12 <ddarius> > let paraList c n [] = n; paraList c n (x:xs) = c x xs (paraList c n xs) in paraList (\x xs tailsXs -> (x:xs):tailsXs) [[]] [1,2,3]
14:26:12 <jfoutz> > let for = (\s e f -> map f [s..e]) in for 3 6 (+1)
14:26:13 <lambdabot>   [[1,2,3],[2,3],[3],[]]
14:26:13 <lambdabot>   [4,5,6,7]
14:26:29 <lispy> damd: you could store a counter inside the STRef, but Haskell has ways of expressing it that lead to much cleaner code so it's worth it to learn those
14:26:30 <monochrom> jmcarthur: damd just wants i + (6 - 3 + 1)
14:26:40 <jmcarthur> monochrom: :P
14:26:42 <dino-> > foldl (flip id) 0 [ (+ 2), (* 3) ]
14:26:43 <damd> but how i write for example chess??
14:26:43 <lambdabot>   6
14:26:49 <kmc_> haha
14:26:51 <Olathe> > length [3..6]
14:26:52 <lambdabot>   4
14:26:57 <lispy> > "chess" -- done
14:26:58 <lambdabot>   "chess"
14:27:00 <jmcarthur> damd: there are many ways...
14:27:01 <kmc_> > 10 PRINT "HELLO WORLD"; 20 GOTO 10
14:27:02 <lambdabot>   <no location info>: parse error on input `;'
14:27:07 <kmc_> why it doesn't work?!?!?!?!?
14:27:10 <pokoko222> Anyone can tell me example where you have used Kolmogorov complexity?
14:27:18 <ddarius> kmc: You need to load the appropriate library.
14:27:18 <wto> reminds me of this one: http://thedailywtf.com/Articles/G%C3%B6r_spel!.aspx
14:27:22 <kmc_> KolmogorovLove?
14:27:22 <damd> can i use haskell scripting for chess program
14:27:26 <kmc_> yes
14:27:28 <lispy> pokoko222: oh, I have a friend that used it in java, IIRC
14:27:31 <ddarius> @hackage BASIC
14:27:32 <lambdabot> http://hackage.haskell.org/package/BASIC
14:27:35 <jmcarthur> scripting?
14:27:36 <kmc_> yeah
14:27:39 <monochrom> kmc_: You need augustss's monad or maybe it's sjanssen's, I keep mixing them up.
14:27:40 <kmc_> that BASIC module is an epic hack
14:28:01 <kmc_> wto: hahahaha
14:28:02 <ddarius> kmc_: By an epic hacker.
14:28:04 <monochrom> So it's augustss's.
14:28:06 <jmcarthur> "scripting" is an odd word for "programming"
14:28:16 <wto> kmc_: "it's an american computer!"
14:28:21 <HaskellLove> scripting is not programming
14:28:33 <HaskellLove> lispy IIRC?
14:28:33 <kmc_> let's have another pointless argument about words
14:28:35 <damd> please help me i want to learn chess game using haskell
14:28:37 <lispy> damd: I'd start with either real-world haskell or learn you a haskell (both are books freely available check google), and then come back if/when you have questions
14:28:42 <MissPiggy> words!
14:28:42 <jlouis> HaskellLove: beware the turing tarpit
14:28:44 <lispy> HaskellLove: IIRC = if I recall correctly
14:28:51 <jmcarthur> @where lyah
14:28:52 <lambdabot> http://www.learnyouahaskell.com/
14:28:55 <jmcarthur> damd: ^^
14:29:11 <monochrom> "software engineering" is an odd word for "programming".  (There!)
14:29:26 <lispy> Word is an odd word for word.
14:29:31 <jfoutz> scripting is totally programming. you think shakespeare didn't program actors?
14:29:45 <ddarius> jfoutz: He programmed the audience.
14:29:48 <kmc_> damd: you're not optimizing your question
14:29:49 <lispy> jfoutz: shakespear was an OO programmer?
14:29:52 <kmc_> here's how it's done:
14:29:52 <HaskellLove> what i meant by scripting is not programming is that you dont have to be a programmer to script in some program like 3d software or else
14:29:57 <jmcarthur> monochrom: amen
14:29:58 <kmc_> Haskell SUCKS because it can't write a chess program
14:30:03 <kmc_> and i challenge ANYONE to prove me wrong
14:30:12 <lispy> HaskellLove: Some people take the opposite opinion and consider that programming.
14:30:18 <damd> kmc_: shuld i use java or C for it?
14:30:22 <pikhq> kmc_: What programming language *can* write a chess program unaided? :P
14:30:30 <kmc_> damd: you should use Coq
14:30:41 <lispy> damd: It really depends on your goals.
14:30:45 <jfoutz> heck, now days i'd consider cruise control programming.
14:30:46 <dino-> HaskellLove: I do write Haskell scripts with #! /usr/bin/env runhaskell
14:31:07 <medfly> kmc++
14:31:07 <nbathum> help i need to use a global variable
14:31:08 <medfly> hehehe
14:31:13 <kmc_> haha
14:31:38 <damd> nbathum: my friend say in haskell no variables
14:31:40 <damd> i dont understand this
14:31:51 <kmc_> Haskell has variables, but they don't vary
14:32:01 <Philonous> Invariable variables.
14:32:06 <m3ga> they are values rather than variables
14:32:07 <pikhq> damd: There are only names bound to values.
14:32:10 <medfly> damd, you don't go i = i + 1; to increase i by one.
14:32:20 <damd> medfly: in haskell how do i do this
14:32:24 <medfly> damd, do what?
14:32:29 <damd> i = i + 1
14:32:31 <damd> in haskell
14:32:32 <ddarius> > let i = i + 1 in i :: Natural
14:32:33 <lambdabot>   Not in scope: type constructor or class `Natural'
14:32:35 <Cale> damd: Haskell has variables, it's just that their values don't change as long as they remain in scope.
14:32:36 <ddarius> > let i = i + 1 in i :: Nat
14:32:36 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
14:32:36 <lambdabot>    arising from a use of `GHC.Num.+' at...
14:32:37 <kmc_> damd: you probably don't
14:32:43 <kmc_> you can, if you really want to, use mutable state
14:32:45 <kmc_> but it's not the default
14:32:46 <c_wraith> damd:  you probably say "map" or "fold" instead
14:32:52 <kmc_> what you probably want is to call a function with (i + 1)
14:32:56 <kmc_> possibly a recursive call
14:32:57 <damd> > fold 1
14:32:58 <lambdabot>   Not in scope: `fold'
14:32:59 <monochrom> Why do you need i=i+1
14:33:13 * hackagebot upload: glintcollider 0.0.1 - A simple ray tracer in an early stage of development. (ColinHill)
14:33:16 <damd> > map fold i 1
14:33:17 <lambdabot>   Not in scope: `fold'
14:33:20 <kmc_> damd: think of a Haskell function as being a description of a value rather than a sequence of steps to follow
14:33:20 <medfly> > foldr (+) 0 [1,2,3]
14:33:21 <lambdabot>   6
14:33:22 <monochrom> There are even sudoku solvers and they don't need i=i+1.
14:33:25 <Olathe> > map (\x -> x * 5) [1..10] -- Multiply all the numbers from 1 to 10 by 5.
14:33:25 <lambdabot>   [5,10,15,20,25,30,35,40,45,50]
14:33:33 <monochrom> Or are you just trolling.
14:33:40 <c_wraith> tim sweeney's analysis of the unreal engine showed that 90% of the for loops in it are map or fold.  That's a pretty impressive stat
14:33:44 <damd> monochrom: i'm sorry dude... :|
14:33:46 <nbathum> monochrom: i have some code that does i=i+1
14:33:53 <pikhq> c_wraith: Sounds about right.
14:33:58 <idnar> they are variables and they do vary, they just aren't mutable cells :P
14:34:04 <nbathum> its part of an implementation of a type system
14:34:12 <pikhq> c_wraith: And the remaining 10% probably can be done with a tail call.
14:34:15 <idnar> c_wraith: it's not really surprising
14:34:24 <medfly> damd, you need more work to do i = i + 1 in Haskell. this is seen as a good thing, because being able to change the value of something in the middle of a function creates a lot of problems.
14:34:32 <medfly> damd, it forces you to avoid it unless you absolutely need it.
14:34:40 <kmc_> c_wraith: cool, do you have a link?
14:34:44 <idnar> c_wraith: if your for loop isn't map/fold/etc. you're probably doing something wrong
14:34:46 <kmc_> damd: how much Haskell do you know?
14:34:58 <damd> guys i'm sorry
14:35:00 <damd> i just had to
14:35:06 <medfly> TROLL
14:35:08 <c_wraith> kmc_: it was his request for better programming languages from 4 or 5 years ago
14:35:10 <dino-> c_wraith: And the other 10% are code that should be rewritten to be maps/folds? :)
14:35:11 <kmc_> sigh
14:35:32 <c_wraith> (amusingly, his only real knock on haskell was "the syntax confuses C programmers")
14:35:35 <medfly> the question really is what are those other 10% loops
14:35:41 <ddarius> pikhq: All 100% can be done with tail calls...
14:35:53 <idnar> guys, I'm trying to troll #haskell, how do I do this in Haskell?
14:36:04 <kmc_> @faq Can Haskell troll itself?
14:36:05 <lambdabot> The answer is: Yes! Haskell can do that.
14:36:08 <medfly> the first language I became remotely competent at is Haskell, and it wasn't so bad.
14:36:20 <mreh> medfly: seriously?
14:36:23 <c_wraith> kmc_:  http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
14:36:28 <jfoutz> idnar: probably something using the fail function of Monad
14:36:35 <medfly> working for this one fella, he seemed to be impressed by my "coding style" in a non-Haskell language, it was weird.
14:36:38 <ddarius> idnar: There are plenty of loops that don't nicely fit a map or fold model.  It's just that most loops in imperative code do.
14:36:42 <kmc_> ugh comic fucking sans
14:36:45 <pikhq> ddarius: Obviously fold and map can be done with tail calls.
14:37:35 <pikhq> medfly: Do you happen to write explicit thunks? :P
14:37:44 <ddarius> I've done that.
14:37:46 <ddarius> (in C#)
14:37:55 <medfly> what are explicit thunks?
14:38:11 <medfly> I said remotely competent for a reason. I am not that good with everything in Haskell.
14:38:33 <pikhq> medfly: "Thunk" is an implementation of laziness.
14:38:36 <jfoutz> medfly: it's a function with no arguments. it's one way to get lazyness in a strict language.
14:38:49 <pikhq> In essence, instead of computing a value you have a closure with no arguments that computes the value.
14:39:05 <pikhq> I've been doing it in C today.
14:39:13 <pikhq> (writing a quick and dirty SKI evaluator)
14:39:22 <jfoutz> int promise() { /*someday they'll need it...*/ return 1;}
14:39:26 <medfly> I wasn't really satisfied with what I wrote, but it was mostly a time restriction. it was not the most beautiful code. that's why I was surprised with that response
14:39:37 <medfly> s/a time/the time/
14:40:14 <ddarius> A thunk is more than just a nullary function.  It's a memoized, nullary function.
14:40:56 <jfoutz> they're memoized? oh. wow.
14:40:58 <damd> what is "lenient evaluation"?
14:41:36 <medfly> I tried to implement memoisation there, but I kind of got tired with it. the syntax doesn't make it very easy, and I got lazy. :)
14:41:57 <c_wraith> I think he means ml-style, where the evaluation order isn't text-order, but it's not call-by-need, either
14:45:41 <HugoDaniel> im starting to look at arrows... these seem interesting
14:46:19 <damd> in the slide that you linked, c_wraith, he says that "type inference doesn't scale"... but it seems like he basically wants to be able to use strings as integers?
14:46:28 <damd> or am i missing the point?
14:47:08 <c_wraith> damd: I'm not sure what he means there, actually.
14:47:19 <c_wraith> damd: possibly that it doesn't work well with dependent typing, which he wants
14:48:45 <c_wraith> also, possibly that it doesn't work with subtyping like OO languages do, and I don't think he wants to get rid of objects.  He's liked objects since the scripting language for ZZT.
14:50:17 <PeakerWord> I don't see why people say OO has subtyping.. Almost none of the inheritance I've ever seen was about subtyping..
14:50:46 <damd> i'm not sure what subtyping is anymore
14:50:54 <PeakerWord> almost all inheritance relationships are type products against the base type - unlikely to be a sub-type..
14:51:14 <HaskellLove> The belief in the possibility of true induction cannot be justified rationally - what does that mean?
14:51:22 <HaskellLove> oops sorry that was for #math
14:51:36 <monochrom> hahahahaha
14:51:46 <medfly> quick, let's all make fun of HaskellLove!
14:52:11 * lispy hopes we're still being nice to newbies
14:52:33 <medfly> sure, even trolls
14:52:40 <xerox> @keal
14:52:41 <lambdabot> ghc need to have plugin that allow copy paste in xp
14:52:43 <lispy> As Don says, in 2 years they're your experts
14:52:57 <damd> HaskellLove: what is means "induction"
14:53:03 <kmc_> in 2 years, trolls are your expert trolls?
14:53:09 <medfly> hehe
14:53:41 <lispy> Hopefully we can rise above trolling :)
14:53:58 <HaskellLove> stop trolling do you understand above's Hume quote?
14:54:46 <lispy> HaskellLove: there are several terms that are out of context for me, so no.  Also, that might be a better topic for #haskell-blah
14:55:19 <HaskellLove> yes i know but since iwas called troll i wonder if anyone understands that....nevermind i am in #math
14:55:29 <kmc_> it might be a better topic for read a fucking book
14:55:30 <kmc_> a whole one
14:55:33 <kmc_> from front to back
14:55:37 <kmc_> without going on IRC
14:56:23 <HaskellLove> and understanding 20 % of it, good point kmc
14:57:09 <HaskellLove> anyways i am in #math as i said i dont want to interupt and be baned... bye
14:57:31 <mreh> #math sounds like a nice place
14:57:33 <lunabot>  luna: Not in scope: `math'
14:57:41 <mreh> lets go there and make trouble
14:59:05 <medfly> yeaaaah!
15:00:27 <mreh> I was once asking in there about Mathematica, they went mental at me
15:00:40 <mreh> Math-Software has four people in it
15:00:55 <mreh> acutally, one guy went mental at me
15:01:10 <mreh> so mental it made me stay a troll longer than necessary
15:01:31 <medfly> yeah, #math is pretty crazy about off-topic-ness
15:01:45 <medfly> I recall them attacking people that said "hi"
15:01:51 <medfly> :)
15:01:52 <monochrom> hehehe
15:02:42 <xerox> cut the ceremonies, just ask your question
15:03:05 <HaskellLove> math people are nervous guys, if he swears your mother does not mean he hates you ;) hahaha
15:03:11 <medfly> cut the talks about cutting the ceremonies and just ask your question!
15:03:45 <lispy> okay
15:03:58 <lispy> ?faq Can Haskell create a problem Haskell can't solve?
15:03:59 <lambdabot> The answer is: Yes! Haskell can do that.
15:06:04 <mreh> they're also selective about what mathematics is worthy
15:06:08 <mreh> nothing that I know
15:06:44 <mreh> #haskell is honestly the best channel I've spent time in
15:06:46 <lunabot>  luna: Not in scope: `haskell'
15:07:30 <mreh> it's the attitude of the regulars which counts I suppse
15:07:42 <lispy> mreh: I don't think that happened by accident either.  The early founders like shapr were very good about setting the mood.
15:08:19 <olsner> ?faq Can Haskell create a problem Haskell can't solve and then solve it?
15:08:19 <lambdabot> The answer is: Yes! Haskell can do that.
15:08:32 <ddarius> Somehow though, I'm still here.
15:08:42 <mreh> the haskell-loveathon begins here
15:09:00 <lispy> hey ddarius
15:09:06 <lispy> ddarius: how's the code?
15:09:31 <ddarius> lispy: Non-existent.
15:09:55 <mreh> @tell lament Mode is abstract, the scales are concrete, it's just a one to one mapping
15:09:55 <lambdabot> Consider it noted.
15:10:27 <mreh> @tell lament I'll credit you in the source if I ever publish it anywhere i.e. hackage or comercially
15:10:28 <lambdabot> Consider it noted.
15:12:32 * hackagebot upload: protocol-buffers 1.6.0 - Parse Google Protocol Buffer specifications (ChrisKuklewicz)
15:12:34 * hackagebot upload: protocol-buffers-descriptor 1.6.0 - Text.DescriptorProto.Options and Google Protocol Buffer specifications (ChrisKuklewicz)
15:12:34 <McManiaC> what exactly does Control.Concurrent.threadWaitRead wait for?
15:14:32 * hackagebot upload: hprotoc 1.6.0 - Parse Google Protocol Buffer specifications (ChrisKuklewicz)
15:15:57 <srush> is there a way to use Data.Text without all the T.pack's everywhere
15:17:26 <c_wraith> srush: you mean for literals?
15:17:36 <srush> yeah
15:17:36 <c_wraith> srush: if so, the OverloadedStrings extension
15:17:51 <c_wraith> (I think.  I haven't tried it)
15:18:28 <srush> oh nice
15:21:22 <HugoDaniel> are there cases when arrows are prefered to functors ?
15:22:03 <HugoDaniel> ive just started reading about arrows...
15:22:09 <monochrom> arrow does quite a bit more than functor
15:22:33 <dcoutts_> arrow is somewhere between applicative functors and monads
15:22:51 <HugoDaniel> sorry, i meant applicative functors :/
15:22:57 <idnar> I'm not sure "between" is really the right term
15:23:05 <idnar> it's somehow off on a different axis
15:23:11 <dcoutts_> true
15:23:48 <idnar> after all, you have ArrowApply
15:23:49 <HugoDaniel> hmm, im reading the wikibook, and all this seems possible to do with ap and <*>
15:23:56 <HugoDaniel> or maybe im just reading things in the wrong way
15:24:21 <idnar> which gives you Monads and vice-versa via the Kleisli arrow
15:24:42 <idnar> but I guess the point is that you can have arrows without ArrowApply instances but with others
15:25:06 <dcoutts_> right, since the motivation for arrows was to be less powerful than monad
15:26:20 <idnar> I guess they're less powerful than monad, but in a highly granular fashion
15:27:13 <dcoutts_> McManiaC: for the file descriptor to become ready for reading, ie wait for input to become available.
15:27:59 <McManiaC> and what file desc is "fromIntegral (0 :: Int)" ?
15:28:10 <dcoutts_> stdin I think
15:28:26 <dcoutts_> 0,1,2 == stdin, stdout, stderr
15:28:32 <McManiaC> ah okay
15:28:35 <Draconx|Laptop> hm, why are Eq and Show superclasses of Num?
15:28:47 <idnar> Draconx|Laptop: hysterical raisins
15:28:54 <dcoutts_> Draconx|Laptop: to annoy you
15:28:57 <c_wraith> Draconx|Laptop: for pattern-matching instances of Num
15:29:03 <HugoDaniel> im going to ask something completly wrong by haskell terms... but...
15:29:04 <Draconx|Laptop> dcoutts_, ah, that's what I thought.
15:29:07 <McManiaC> dcoutts_: is there a way to just check if its readable?
15:29:15 <dcoutts_> Draconx|Laptop: you're certainly not the only one to complain
15:29:20 <HugoDaniel> how is the speed of fromIntegral compared to a C type cast ?
15:29:43 <Loriel> Which type of fromIntegral?
15:29:47 <monochrom> comparable speed
15:29:59 <Draconx|Laptop> dcoutts_, I guess I'll have to do (==) = undefined and show = const "annoying".
15:31:17 <dcoutts_> McManiaC: I don't think there is directly, but you can do non-blocking reads. What are you trying to do exactly?
15:31:34 <McManiaC> getting rid of a forkIO
15:31:42 <McManiaC> thats what I'm trying to do
15:31:42 <monochrom> Draconx|Laptop: Is it hard to implement a good (==) ?
15:31:42 <McManiaC> ^^
15:32:18 <dcoutts_> McManiaC: forkIO and blocking reads is not a bad approach generally
15:32:19 <Draconx|Laptop> monochrom, my instance is essentially equivalent to instance Num a => Num (-> a)
15:32:43 <Draconx|Laptop> well, that's probably not the right syntax, but...
15:32:57 <monochrom> Ha nevermind. So just make sure you don't use pattern matching such as "myfun 0 = ..."
15:34:05 <McManiaC> dcoutts_: yeh, but I have the problem that *alot* of events happen there, and even after the program ends those threads run on and on
15:35:35 <dcoutts_> McManiaC: you can control when the threads you forkIO end
15:37:21 <McManiaC> dcoutts_: how?
15:37:31 <McManiaC> I could try System.IO.hWaitForInput tho
15:37:43 <mauke> <cfedde> lets hear it for syntactic sugar!  <cfedde> and yeast.  <cfedde> syntactic vodka
15:38:18 <monochrom> Should we @remember it?
15:38:31 <mauke> nah
15:38:32 <monochrom> where did you find cfedde and that saying?
15:38:51 <mauke> cfedde in #perl, saying in http://www.trout.me.uk/quotes.txt
15:39:01 <monochrom> ha
15:41:08 <dcoutts_> McManiaC: you can communicate between the threads using MVars, or you can kill threads asynchronously by throwing exceptions to them (via their ThreadId)
15:44:10 <kmc_> McManiaC: what communication are you trying to do?
15:45:51 <McManiaC> I'm trying to fix the ncurses bindings for haskell
15:46:37 <McManiaC> if you do a lot of resizes and immediatly quit after those, the image will keep on flickering for up to one minute and longer
15:49:46 <shapr> lispy: and we try to keep the mood friendly too.
15:50:08 <MissPiggy> lispy is nice to me
15:50:58 <lispy> shapr: yeah!  #haskell is like home.
15:55:29 <McManiaC> dcoutts_: http://npaste.de/EL/ thats the part I'm trying to improveâ¦
15:55:46 <McManiaC> line 40 is the evil one :S
15:56:01 <mreh> so why does Maybe monad fail when I didn't evaluated the expression that returns Nothing when I binded it
15:56:35 <kmc_> Nothing >>= f = Nothing
15:56:39 <MissPiggy> mreh, do you mean like   x <- Nothing ; ...,  and you didn't use x?
15:56:39 <kmc_> (Just x) >>= f = f x
15:56:46 <mreh> MissPiggy: ya
15:56:59 <mreh> kmc_ I get Maybe
15:57:23 <mreh> I thought it would be lazy and not evaluate x <- thingThatReturnsNothing
15:57:27 <kmc_> mreh: so you see that if the LHS of >>= is Nothing, the result is Nothing
15:57:35 <kmc_> even if the RHS does not use its argument
15:57:42 <kmc_> > Nothing >>= (const (Just ()))
15:57:43 <lambdabot>   Nothing
15:58:03 <mreh> kmc_ ah... bum
15:58:07 <dcoutts_> McManiaC: yes, it's not at all obvious why you need to do that in a separate thread
15:58:09 <kmc_> mreh: that desugars to:  thingThatReturnsNothing >>= (\x -> ...
15:58:21 <kmc_> so by the definition of (>>=), it will evaluate thingThatReturnsNothing to whnf
15:58:28 <mreh> I getcha
15:58:42 <monochrom> If you have Â«return hello >>= kÂ», it is lazy with hello.
15:58:56 <mreh> I'm staying up past my bedtime to do Haskell.. don't tell mum!
15:59:07 <mreh> monochrom: interesting
15:59:11 <dcoutts_> McManiaC: or is there a separate writer for that input channel?
15:59:44 <McManiaC> no
15:59:51 <McManiaC> thats the whole code
15:59:51 <monochrom> It just needs to see "is it Nothing? is it Just?". In case of Just, it does not find out "Just what?". It lets you decide.
16:00:22 <McManiaC> > do { x <- Nothing; Just 5 }
16:00:24 <lambdabot>   Nothing
16:00:26 <McManiaC> :>
16:00:35 <kmc_> > Nothing >> Just 5
16:00:36 <lambdabot>   Nothing
16:00:41 <kmc_> > Nothing >>= (const $ Just 5)
16:00:42 <lambdabot>   Nothing
16:01:31 <damd> > forever Nothing
16:01:32 <lambdabot>   Nothing
16:01:49 <alp> it's normal.
16:02:07 <alp>    Nothing  >>= f = Nothing
16:02:07 <mreh> @hoogle [a] -> a
16:02:08 <lambdabot> Prelude head :: [a] -> a
16:02:08 <lambdabot> Prelude last :: [a] -> a
16:02:08 <lambdabot> Data.List head :: [a] -> a
16:02:16 <damd> @src forever
16:02:16 <lambdabot> Source not found. There are some things that I just don't know.
16:02:19 <alp> whatever f is.
16:02:20 <damd> @src Control.Monad.forever
16:02:20 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:02:30 <kmc_> forever m = m >> forever m
16:02:39 <damd> yes
16:02:53 <dcoutts_> McManiaC: as written it never uses BufDirect and the thread seems quite unnecessary, unless I'm missing something.
16:02:53 <xerox> > forever "young"
16:02:55 <lambdabot>   * Exception: stack overflow
16:03:02 <idnar> haha
16:03:10 <damd> > forever (forever Nothing)
16:03:11 <lambdabot>   Nothing
16:03:16 <McManiaC> dcoutts_: BufDirect is used in line 10
16:03:21 <kmc_> > forever succ 3
16:03:23 <mreh> lastSafe (x:xs) = lastSafe xs
16:03:23 <mreh> lastSafe [x]    = Just x
16:03:23 <mreh> lastSafe []     = Nothing
16:03:26 <lambdabot>   mueval-core: Time limit exceeded
16:03:28 <mreh> pattern matches "overlap"
16:03:34 <mreh> I dont understand
16:03:40 <dcoutts_> McManiaC: yes, but that's never called in getCh
16:03:41 <kmc_> [x] matches (y:ys)
16:03:44 <kmc_> with y = x, ys = []
16:03:50 <mreh> kmc_ ooh
16:03:51 <McManiaC> dcoutts_: basicly, what that code does is look, whether stdin is readable, if not try take something from the chan (put in by ungetCh)
16:03:56 <MissPiggy> hi shapy
16:04:00 <MissPiggy> shapr
16:04:33 <dcoutts_> McManiaC: ah, so you're assuming that some other thread is calling ungetCh
16:04:40 <copumpkin> interesting, on -cafe someone said (a -> b) -> c and a -> b -> c are isomorphic (the polymorphic versions) because they are both empty. I sort of buy it but it also feels weird. Does that mean all empty types are isomorphic?
16:04:43 <McManiaC> dcoutts_: the first event then unblocks the readChan in line 41 and kills the thread (if still up)
16:04:48 <mreh> can't think of a clever way to do lastSafe with monads
16:04:52 <McManiaC> dcoutts_: jup
16:05:30 <ExplicitCall> hi all.  I've just tried to compile clutterhs, but while preprocessing c2hs wastes up to 2 gigs of RAM.  I've profiled c2hs and discovered that problem lies in [CHSToken] used.  That is, lazy list consumes too much memory while processing one moderately sized file.  Am I destined to upgrade my RAM?  Are there any other solution?
16:06:00 <MissPiggy> the question is, _|_ = \_ -> _|_?
16:06:27 <pikhq> mreh: Oh, that's actually monadic. lastSafe maps from a monad to a monad.
16:06:33 <monochrom> copumpkin: I think that's totally wrong. (a->b)->c isomorphic to a->(b->c) ?!
16:06:36 <pikhq> mreh: You're just not using >>= or return. :P
16:06:56 <dcoutts_> McManiaC: does it need to be periodic like this, or can it just continue to pull events from the input?
16:06:57 <mreh> pikhq: I suppose :)
16:07:01 * MissPiggy is isomorphic to a lump of coal
16:07:01 <copumpkin> monochrom: yeah, the fully polymorphic version (i.e., not for specific a, b, c)
16:07:15 <idnar> @type reversed
16:07:15 <syntaxglitch> copumpkin, seems like they're trivially isomorphic in the sense of containing the same things
16:07:16 <lambdabot> Not in scope: `reversed'
16:07:16 <copumpkin> MissPiggy: I have no idea :) both seem hard to reason about
16:07:18 <idnar> @type reverse
16:07:19 <lambdabot> forall a. [a] -> [a]
16:07:24 <ExplicitCall> or should I file this as c2hs bug?  I've just thought that I could fix it by myself, but maybe there are more ways to fix it
16:07:32 <McManiaC> dcoutts_: I dont know ncurses that good :S
16:07:35 <idnar> mreh: I don't think monads are of much use there
16:07:36 <dcoutts_> McManiaC: I mean could it just fork off a thread to get chars from the input one by one and push them into a channel
16:07:36 <kmc_> what does "isomorphic" mean in the context of types? if types are just sets, that merely requires that they have the same cardinality
16:07:43 <idnar> mreh: you could do something like listToMaybe . reverse though
16:07:44 <MissPiggy> lets define it to be true then we can conclude that your abc stuff is isomorphic
16:07:45 <MissPiggy> next!
16:07:46 <kmc_> but i assume we want more structure... a functor, then?
16:07:52 <monochrom> copumpkin: Does that mean (forall a b c. (a->b)->c) and (forall a b c. a->b->c) ?
16:07:53 <McManiaC> dcoutts_: yeh, I had that idea too
16:08:00 <copumpkin> monochrom: yeah
16:08:19 <copumpkin> monochrom: that's just what someone said on -cafe just now... not sure how I feel about either answer
16:08:32 <dcoutts_> McManiaC: it depends on whether there are time when you need to not read from the input as soon as it's available
16:08:36 <MissPiggy> depends on how you define equality of values
16:08:38 <kmc_> i realized today that you can write a function which takes any argument so long as its type is built with an arity-2 constructor
16:08:51 <kmc_> i.e., universal quantification over higher kinded type variables
16:08:56 <mreh> idnar: last [] is an exception though
16:08:58 <kmc_> it's a very odd thing to do
16:09:00 <mreh> :t listToMaybe
16:09:01 <lambdabot> forall a. [a] -> Maybe a
16:09:08 <copumpkin> kmc_: example? :)
16:09:10 <MissPiggy> kmc_, yeah I don't know why they don't just give us HOU
16:09:19 <mreh> huh?!
16:09:22 <idnar> mreh: where did I use last? :)
16:09:23 <ezyang> hallo folks
16:09:23 <kmc_> > let f :: a b c -> (); f _ = () in f (Left 3)
16:09:24 <lambdabot>   ()
16:09:27 <kmc_> > let f :: a b c -> (); f _ = () in f (Just 3)
16:09:28 <lambdabot>   Couldn't match expected type `a b c'
16:09:28 <lambdabot>         against inferred type `Data.Ma...
16:09:30 <copumpkin> mreh: natural transformation!
16:09:35 <MissPiggy> hi ezyaing
16:09:38 <idnar> mreh: listToMaybe [] = Nothing; listToMaybe (x:_) = x
16:09:38 <MissPiggy> exyang*
16:09:40 <mreh> I don't get it
16:09:40 <kmc_> MissPiggy: HOU?
16:09:41 <McManiaC> dcoutts_: yes, and there probably areâ¦
16:09:42 <copumpkin> kmc_: oh yeah
16:09:42 <McManiaC> hmmm
16:09:47 <kmc_> > listToMaybe (repeat 'x')
16:09:48 <lambdabot>   Just 'x'
16:09:53 <MissPiggy> kmc_ type level lambda terms with unification
16:10:03 <idnar> mreh: you could call it "headSafe"
16:10:08 <kmc_> @quote unsafeHead
16:10:09 <mreh> why not listToMaybe xs = Just xs
16:10:09 <lambdabot> Philippa says: plus who wants to get unsafeHead?
16:10:18 <mreh> oh... because of the types
16:10:21 <idnar> mreh: that would just be Just; not very useful...
16:10:26 <kmc_> MissPiggy: ah.  another corner of the lambda cube, then?
16:10:29 <idnar> oh, you mean like that
16:10:35 <mreh> [a] -> Maybe a
16:10:42 <idnar> anyhow, so if you reverse the list first, you get the last element instead of the first one
16:10:48 <mreh> that makes more sense than [a] -> Maybe [a]
16:10:54 <mreh> which is just return
16:11:04 <MissPiggy> @free monadFail :: [a] -> Maybe a
16:11:04 <lambdabot> $map_Maybe f . monadFail = monadFail . $map f
16:11:16 <monochrom> safeGullotineHead?
16:11:30 <idnar> unsafeSeverHead
16:11:30 <MissPiggy> @free safeGullotineHead :: [a] -> (a,a)
16:11:30 <lambdabot> $map_Pair f f . safeGullotineHead = safeGullotineHead . $map f
16:11:36 <idnar> (aka tail?)
16:11:45 <copumpkin> ouch
16:12:19 <monochrom> @hoogle IO a -> a
16:12:20 <lambdabot> Foreign unsafePerformIO :: IO a -> a
16:12:20 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
16:12:20 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
16:12:57 <McManiaC> {-# NOINLINE var #-} -- what does that mean?
16:13:01 * syntaxglitch notes that "guillotine" would make a good alternate name for "tail"
16:13:03 <kmc_> a GHC pragma
16:13:06 <kmc_> says not to inline uses of var
16:13:22 <McManiaC> what is an inline use?
16:13:30 <idnar> syntaxglitch: it would certainly make it harder to use ;)
16:13:31 <kmc_> inlining is a compiler optimization
16:13:39 <kmc_> where the body of the thing defined is substituted in for its use
16:13:40 <kmc_> at compile time
16:13:41 <copumpkin> syntaxglitch: I'd call it uncons
16:13:50 <copumpkin> where guillotine is [a] -> Maybe (a, [a])
16:14:18 <MissPiggy> unicorns :: (a)->
16:14:23 <copumpkin> :)
16:14:32 <idnar> heh
16:14:46 <ezyang> nice one.
16:15:00 <syntaxglitch> copumpkin, my impression is that heads removed by a guillotine rarely have practical use afterwards
16:15:08 <copumpkin> while bodies do?
16:15:08 <syntaxglitch> then again, neither do the bodies, so I guess the analogy fails somewhat
16:15:10 <copumpkin> you pervert!
16:15:13 <idnar> syntaxglitch: I hear you can kick them around
16:15:20 <syntaxglitch> copumpkin, :(
16:15:25 <idnar> not sure what you do with the bodies, though
16:15:31 * copumpkin coughs
16:15:45 * idnar looks innocent and naÃ¯ve
16:15:52 <ezyang> "let's talk about curry-howard isomorphism"
16:15:53 <lament> same thing as with the heads
16:15:53 <lambdabot> lament: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:16:00 <syntaxglitch> okay, point taken, uncons makes more sense as separating the head and keeping both
16:17:29 <MissPiggy> curry-howard design pattern
16:18:16 <idnar> copumpkin, syntaxglitch: http://sexylosers.com/007.html (WARNING: NSFW)
16:18:32 <copumpkin> yep, I've read pretty much the entire webcomic :P
16:18:34 <syntaxglitch> speaking of which, I am consistently unable to read "curry" without thinking of a meal involving spiced sauce
16:18:57 <idnar> copumpkin: ah, excellent :)
16:19:03 <[swift]_> hi, i'm new to haskell and i'm writing a very simple parser as an exercise to learn the language, but i'm getting a syntax error in this attempt at pattern matching: parseExpr x:xs (Terminal c):syms = (... definition ...)
16:19:08 * syntaxglitch declines to admit to reading that webcomic
16:19:17 <[swift]_> what's wrong with my syntax?
16:19:24 <MissPiggy> it wants (x:xs)
16:19:32 <[swift]_> ah ok, thanks
16:19:33 <MissPiggy> and (Terminal c:syms)
16:21:09 <[swift]_> sweet, it works now
16:26:01 <ezyang> I'm having difficulty wrapping my intuition around a Void -> a function
16:26:19 <copumpkin> ezyang: given false you can get anything!
16:26:53 <copumpkin> ex falso quodlibet if you want to sound fancy
16:26:54 <tensorpudding> assuming that bacon is God, haskell is Jesus
16:27:04 <ezyang> So... it's sort of, "if I /did/ get a value, I'd be in trouble, but there's no possible value you can give me, so I'm ok"?
16:27:04 <syntaxglitch> What does Void mean in that context? a bottom type?
16:27:15 <copumpkin> BOOM: http://en.wikipedia.org/wiki/Principle_of_explosion
16:27:35 <MissPiggy> ezyang, well here is a sequence
16:27:40 <syntaxglitch> ezyang, if you prove 0 = 1, you can prove that any pair of integers are equal
16:27:47 <ezyang> syntaxglitch: yes
16:27:48 <tensorpudding> @djinn (a -> Void) -> b
16:27:49 <lambdabot> -- f cannot be realized.
16:27:49 <MissPiggy> for Bool we define two cases: bool True = ..., bool False = ....
16:27:51 <tensorpudding> hmm
16:27:58 <MissPiggy> for Unti we define one case unit () = ...
16:27:59 <tensorpudding> @djinn Void -> a
16:28:00 <lambdabot> f = void
16:28:03 <MissPiggy> for Void we define zero cases:
16:28:07 <tensorpudding> ah
16:28:13 <tensorpudding> @djinn (a -> Void) -> a -> b
16:28:14 <lambdabot> f a b = void (a b)
16:28:17 <tensorpudding> there we go
16:28:27 <ezyang> MissPiggy: hah
16:28:58 <tensorpudding> given that bacon is God is absurd, if bacon is God, Haskell is Jesus
16:30:12 <syntaxglitch> "yields falsehood when preceded by its quotation" yields falsehood when preceded by its quotation.
16:30:15 <syntaxglitch> Hooray, logic is dead!
16:30:27 <ezyang> hmmm
16:30:31 <ezyang> is that Negation?
16:30:55 <tensorpudding> @djinn (a -> (a -> Void)) -> a -> b
16:30:55 <lambdabot> f a b = void (a b b)
16:31:11 <ezyang> :t void
16:31:13 <lambdabot> Not in scope: `void'
16:31:16 <MissPiggy> constructive negation  ~P = a -> P
16:31:16 <tensorpudding> hmm
16:31:22 <ezyang> what's this void djinn is sticking about?
16:31:29 <tensorpudding> it's _|_
16:31:34 <ezyang> is it void :: a -> Void?
16:31:36 <MissPiggy> oops
16:31:41 <MissPiggy> constructive negation  ~P = P -> Void
16:31:41 <tensorpudding> or logically speaking, the absurd proposition
16:32:14 <tensorpudding> hmm
16:32:15 <MissPiggy> but ~~P = (P -> Void) -> Void is not the same as P
16:32:15 <copumpkin> @djinn (a -> Not a) -> a -> b
16:32:16 <lambdabot> f a b = void (a b b)
16:32:26 <tensorpudding> yes, that's constructive logic
16:32:30 <copumpkin> @djinn Not (Not (Not a)) -> Not a
16:32:31 <lambdabot> f a b = void (a (\ c -> c b))
16:32:36 <tensorpudding> no double negatives and no excluded middle
16:33:11 <MissPiggy> what's not constructive  logic?
16:33:17 <tensorpudding> classical logic
16:33:26 <copumpkin> destructive logic
16:33:30 <doserj> ezyang: void:: Void -> a
16:34:10 <tensorpudding> most people use classical logic
16:34:10 <ezyang> oh, ok. that's what I was talking about.
16:34:38 <ezyang> O.o paraconsistent logic
16:34:41 <doserj> ex falso quodlibet
16:35:16 <syntaxglitch> the practical difference is that nonconstructive logic allows proofs of the form "X must exist on pain of contradiction but I'm not telling you anything else about it, ha ha, sucker", right?
16:36:11 <MissPiggy> I think the practical differences are very extreme and still lots unknown
16:36:18 <tensorpudding> the LEM makes sense, but fails constructive logic since to prove the disjunction (a or ~a) you have to have a witness to either a or ~a
16:36:23 <MissPiggy> it is mostly the philosophical distinction that we have got covered
16:36:51 <tensorpudding> and you can't assume that one is true because you can't provide a witness for the other
16:38:07 * syntaxglitch really needs to learn more about non-classical logics
16:38:12 <tensorpudding> nor can you turn a proof of the falsity of one into the proof of the truth of the other
16:38:56 <syntaxglitch> tensorpudding, I think a wikipedia article describes it as preserving justification instead of truth... which sounds sensible but probably has a technical definition that I'm unaware of
16:38:58 <tensorpudding> Type Theory and Functional Programming is a good book to learn about intuitionist logic in the realm of type systems
16:39:20 <tensorpudding> I'm reading it now, though it's on hiatus while I'm reading about ocaml :\
16:39:44 <syntaxglitch> tensorpudding, hm, looks like that's already in my reading queue
16:39:48 <tensorpudding> it's freely available online but it's nearly 20 years old
16:39:56 <syntaxglitch> maybe I should bump it ahead a little
16:40:05 <syntaxglitch> yeah, I have it bookmarked
16:40:05 <tensorpudding> the examples are miranda
16:40:23 <syntaxglitch> that's an ancestor language to haskell, right?
16:40:33 <tensorpudding> yeah
16:40:51 <tensorpudding> it was the first real attempt to make a lazily-evaluated functional language
16:41:03 <tensorpudding> it was not free though
16:41:11 * syntaxglitch sighs and wishes he'd actually learned some of this interesting stuff back in school when he had more time
16:41:15 <tensorpudding> which was part of what stimulated the development of haskell
16:41:50 <MissPiggy> syntaxglitch, yeah I know the feeling thinking back to what you should have studied if you just had proper direction can get damn frustrating
16:42:32 <tensorpudding> there are lots of "could-haves" in that
16:42:37 <syntaxglitch> MissPiggy, especially since I went to a no-name university without much in the way of standards
16:42:52 <syntaxglitch> I slacked off completely and did well anyhow
16:42:58 <MissPiggy> haha
16:43:03 * hackagebot upload: hssqlppp 0.2.0 - Sql parser and type checker (JakeWheat)
16:43:16 <tensorpudding> i'd imagine it'd be worse if you went into the wrong field altogether
16:43:22 <syntaxglitch> I have enough trouble with motivation as it is, being able to practically sleep through courses completely destroyed any inclination I had to learn more :(
16:43:26 * MissPiggy is in the wrong field
16:43:50 * theorbtwo knows an awful lot of people who aren't doing what they studied.
16:44:00 <syntaxglitch> tensorpudding, I was starting to think I had
16:44:28 <tensorpudding> i wonder if under different circumstances i would have gone into biology
16:44:30 <syntaxglitch> but Haskell (among other things) has convinced me that I really do like CS and programming
16:44:41 <tensorpudding> the more i learn about biology the more fascinated i am in it
16:44:51 <tensorpudding> though mostly in connection with maths
16:45:08 <syntaxglitch> what kind of maths?
16:45:18 <tensorpudding> dynamical systems mostly
16:47:23 <syntaxglitch> tensorpudding, of the nonlinear variety? :D
16:49:42 <tensorpudding> nonlinear dynamics is not something i fully understand
16:49:47 <tensorpudding> but chaos sure is purty
16:50:00 <syntaxglitch> I don't think anyone understands nonlinear dynamics
16:59:34 <MissPiggy> since alt is dead, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16614
16:59:41 <MissPiggy> that's my code
17:00:21 <copumpkin> wouldn't you want zero in Add and one in Mul ?
17:00:37 <MissPiggy> maybe
17:00:54 <something> hi all, I'm trying to compile haskell-platform on mac osx.  I'm able to run ./configure ...  but when I do make I get the following error: Configuring cabal-install-0.6.2...
17:00:54 <something> Setup: At least the following dependencies are missing:
17:00:54 <something> HTTP >=4000.0.2 && <4001, zlib >=0.4 && <0.6
17:01:07 <something> oops, sorry about the multi-line paste
17:01:26 <theorbtwo> Hm.  Stupid beginner question: what is wrong with "takeWhile' cond x:xs | cond x =" that makes ghc give me a "Parse error in pattern" on that line?
17:01:49 <monochrom> (x:xs)
17:02:05 <theorbtwo> Damn.  Saw that myself just moments before you pointed it out.
17:02:11 * hackagebot upload: CheatSheet 2.1 - A Haskell cheat sheet in PDF and literate formats. (JustinBailey)
17:02:15 <syntaxglitch> that's two people tonight with parenthesis problems
17:02:30 <MissPiggy> it must be going around
17:02:51 <theorbtwo> Haskell isn't terribly good at having precidence levels that Just Work most of the time.
17:02:51 <syntaxglitch> makes me wish the compiler had a better error message for that
17:03:07 <theorbtwo> Makes the language simpler to define, but harder to use.
17:03:09 <ddarius> theorbtwo: Yes it is.
17:03:15 <MissPiggy> I need to define polynomials (normal form) and rational expressions next
17:03:26 <MissPiggy> and then exponential expressions
17:03:43 <MissPiggy> which also have a normal form if you assume some kind of conjection about algebraic independence
17:04:16 <syntaxglitch> MissPiggy, what are you making? If you mentioned it earlier, I missed it
17:04:27 <copumpkin> wouldn't rationals need some notion of EGCD? a euclidean domain?
17:04:38 <monochrom> This is why you should ditch plain text file and let editors maintain parentheses for you.
17:04:53 <MissPiggy> syntaxglitch an automatic algebra tool
17:04:56 <monochrom> or replace the concept of parentheses altogether.
17:05:26 <MissPiggy> yeah I'll need to implement polynomial GCDs and stuff like that
17:05:38 <monochrom> parentheses is a kludge for force-fitting structures into unstructured plain text.
17:05:52 <Cale> copumpkin: Rationals are a field so everything other than 0 is a unit.
17:05:53 <syntaxglitch> MissPiggy, heh, I was actually just working on something similar earlier
17:06:03 <MissPiggy> syntaxglitch, really??
17:06:06 <MissPiggy> tell me about this
17:06:12 <copumpkin> Cale: I mean the thing they are running over
17:06:29 <Cale> oh, I see
17:06:33 * theorbtwo thinks it'd be very interesting to have editors automagically show the implied parenthesies... but plain-text is entirely too useful to obsolete over this.
17:06:33 <syntaxglitch> MissPiggy, probably something less powerful than what you have in mind
17:07:02 <copumpkin> Cale: not actually sure what would be needed to make a generalized rational, but an EGCD seems like it would be necessary
17:07:22 <MissPiggy> syntaxglitch, did you write up much and what were you aiming at
17:07:24 <MissPiggy> ?
17:07:40 <Cale> An integral domain is all you really need, but computationally, you probably need something like GCD.
17:07:40 <tomberek> hi MissPiggy
17:07:44 <MissPiggy> hi
17:07:59 <copumpkin> ah
17:08:06 <tomberek> hey Cale
17:08:07 <MissPiggy> hey tomberek
17:08:10 <Cale> hey
17:08:22 <syntaxglitch> MissPiggy, my rough goal was a way to express a limited set of simple equations in a way that I could evaluate it for the value of any one variable given the others
17:08:24 <Cale> http://en.wikipedia.org/wiki/Field_of_fractions
17:09:01 <MissPiggy> syntaxglitch, linear equations?
17:09:31 <syntaxglitch> MissPiggy, motivated by something else I was toying with where I had a formula I wanted to apply in different forms and having to manually solve for each variable symbolically and write each as a separate function seemed silly
17:10:46 <syntaxglitch> I didn't finish it due to lack of time, will probably get back to it soon-ish
17:11:09 <MissPiggy> what class of equations?
17:11:35 <MissPiggy> something like variables, constants (real?), and closed by +, * and some functions e^, log?
17:11:49 <syntaxglitch> I hadn't completely decided yet
17:12:34 <syntaxglitch> General plan was +, *, and then anything I could implement easily
17:14:22 <MissPiggy> sounds cool though
17:14:32 <syntaxglitch> Wasn't going to make any attempt at symbolic manipulation, just have it substitute values for all but one variable and do arithmetic to get the answer
17:14:44 <MissPiggy> ahh that's a good problem
17:14:51 <MissPiggy> I know how to implement that
17:15:11 <MissPiggy> this is simpler than simplification
17:15:26 <syntaxglitch> So if you took, say, the ideal gas law or something like that
17:15:54 <syntaxglitch> It'd let you write it once, then substitute all but one parameter to solve for the one you want
17:15:54 <ddarius> syntaxglitch: And if I gave it a polynomial?
17:16:40 <syntaxglitch> ddarius, probably too complicated :P
17:17:15 <syntaxglitch> actually probably not, without symbol manipulation powers and roots are easy enough
17:17:41 <ddarius> syntaxglitch: You think you can write a program to solve arbitrary polynomial equations?
17:18:10 <syntaxglitch> wait, sorry, not enough sleep
17:18:17 <syntaxglitch> no, definitely not anything with more than one instance of a variable
17:18:34 <syntaxglitch> especially not a sum of distinct powers
17:18:50 <jfoutz> x^5 -1?
17:20:16 <syntaxglitch> also I'd have to worry about multiple solutions with roots involved...
17:20:20 <syntaxglitch> meh, forget it
17:20:24 <theorbtwo> syntaxglitch: You might want to look at newton's method.
17:20:59 <syntaxglitch> theorbtwo, that's not solving :)
17:21:03 <MissPiggy> syntaxglitch: were you going to show an eample
17:21:05 <kmc_> how about you write a program that determines whether a given multivariate polynomial has a solution consisting of integers?
17:21:16 <MissPiggy>     pV = nRT ?
17:21:32 <xerox> are we talking fluid mechanics now?
17:21:33 <syntaxglitch> MissPiggy, I didn't have enough written to show :P
17:21:58 <halberd> is it possible to make a compiler that optimizes by doing partial evaluation of expressions at compile time?
17:22:06 <kmc_> halberd: yes
17:22:07 <syntaxglitch> I only mentioned it because what you were doing sounded similar, it's mostly vaporware :P
17:22:08 <ddarius> theorbtwo: Newton's method alone is definitely not going to find all solutions.  It won't even guaranteedly find any.
17:22:20 <kmc_> most compilers do this to some extent -- evaluating expressions consisting solely of constants
17:22:25 <MissPiggy> syntaxglitch: mine too :(
17:22:28 <kmc_> look up "supercompilation" for more advanced techniques
17:22:37 <MissPiggy> syntaxglitch: maybe something will materialize though
17:22:44 <halberd> kmc_, I am talking about it as a general technique, not just for the special case of numeric expressions
17:22:48 <theorbtwo> ddarius: Quite true, but it's a place to start.
17:22:48 <kmc_> http://community.haskell.org/~ndm/supero/
17:24:09 <jfoutz> syntaxglitch: it's a fun thing to build. it's hard though. you might check out "paradigms of ai programming". norvig even builds a symbolic integrator.
17:24:29 <blackh> Err.. how can I put a kind signature on my 'type' declaration?
17:24:40 * syntaxglitch did write a program a while back that used Newton's method and some really horrible hacks to find approximate roots for thousands of polynomials of degree 10+
17:25:09 <jfoutz> blackh: type families?
17:25:22 <jfoutz> http://www.haskell.org/haskellwiki/GHC/Type_families
17:25:30 <medfly> what is newton's method, guess and improve?
17:25:45 <blackh> type X db = something :: * -> * doesn't work
17:25:48 <medfly> (how is it not guaranteed to find something?)
17:25:53 <theorbtwo> medfly: One of them.
17:25:58 <syntaxglitch> medfly, uses the derivative to refine a guess
17:26:04 <jfoutz> medfly, take the derivitive to indicate which way to look.
17:26:05 <syntaxglitch> But some initial guesses don't converge well, or at all
17:26:08 <ddarius> blackh: Why do you think you need a kind signature?  or why do you want one?
17:26:11 <medfly> oh, it improves in a particular way... okay
17:26:13 <theorbtwo> medfly: Because it can get stuck in a local minimia.
17:26:15 * medfly didn't know that part
17:26:32 <syntaxglitch> theorbtwo, I don't think so
17:26:33 <theorbtwo> You need to detect lack of convergence, and nudge it.
17:26:45 <blackh> ddarius: The only reason why I need one is to make it clear what kind it is for people reading the code
17:26:54 <medfly> thanks
17:26:56 <syntaxglitch> It can converge slowly, and it can fail to converge
17:26:57 <blackh> ddarius: Usually 'type' declarations are *, but in this case it's * -> *
17:27:19 <ddarius> blackh: I -often- write type declarations that aren't types.  I always eta reduce.
17:27:30 <ddarius> blackh: I wouldn't worry about it, but if you want to, add a comment.
17:27:42 <medfly> :k Maybe
17:27:44 <lambdabot> * -> *
17:27:50 <medfly> yaay! we can discover this! :)
17:28:06 <MissPiggy> syntaxglitch: actually the algorithm I was thinking for that doesn't work out
17:28:11 <blackh> ddarius: I like doing things properly!  Here's the line:  type PersistenceM db = StateT (PersistenceState db) db
17:28:14 * syntaxglitch also notes that for some polynomials, the boundaries between basins of convergence for newton's method have fractal structure
17:28:24 <kmc_> woah
17:28:38 <blackh> ddarius: It would definitely benefit from a kind signature
17:28:50 <ddarius> blackh: Yes, and that's exactly how I'd write it and I wouldn't bother with any further documentation (there).
17:29:09 <ddarius> blackh: The kind will be clear from any function type.
17:29:20 <blackh> Such a shame, though!
17:30:14 <theorbtwo> syntaxglitch: Not even neccessarly complicated ones.  IIRC, the square root of two does that, if you include initial guesses that are non-real complex numbers.
17:32:06 * EvanCarroll goes back at RWH
17:32:41 <syntaxglitch> theorbtwo, yeah, I only said "some" because there are probably exceptions, probably any nontrivial polynomial works
17:33:14 <aavogt> um, you don't call it newton's method for R^2... do you?
17:33:46 <syntaxglitch> aavogt, maybe not? It's the same algorithm.
17:34:37 <syntaxglitch> on another interesting note, I mentioned graphing all the roots of a lot of higher-order polynomials; for at least some kinds of polynomial the resulting graph also has fractal structure
17:34:42 <theorbtwo> syntaxglitch: Ah.
17:35:50 <syntaxglitch> in particular "all polynomials of degree N with coefficients from [-1, 1]" gives a very nice graph
17:36:16 <halberd> what
17:36:36 <halberd> what would you graph
17:36:42 <syntaxglitch> halberd, all the roots
17:36:46 <ddarius> halberd: A solid line.
17:37:14 <syntaxglitch> take all the polynomials, find all their (approximate) roots, plot each point on the complex plane
17:38:17 <syntaxglitch> the resulting graph is a thick ring with holes in it around certain points and lace-like fractal structures around the inside and outside of the ring
17:38:46 <halberd> I don't think that could be a true fractal because if you vary a coefficient slightly the roots usually vary slightly as well
17:39:07 <ezyang> hmm, it'd be nice if Hoogle was up to date.
17:39:19 <ezyang> Looks like QuickCheck re'orged a bunch of its functions
17:39:31 <syntaxglitch> halberd, not sure what you mean
17:40:00 * syntaxglitch is (for the moment) talking about only coefficients of -1 or 1
17:40:20 <halberd> oh you mean {-1,1}
17:41:11 <syntaxglitch> though you can get a similar graph with other variations
17:41:23 <syntaxglitch> I don't think I tried nonintegral coefficients, though
17:41:25 <ezyang> @hoogle trivial
17:41:26 <lambdabot> Test.QuickCheck trivial :: Testable a => Bool -> a -> Property
17:41:30 <ezyang> hmmmmm
17:41:30 <halberd> [-1,1] generally means the interval
17:41:38 <syntaxglitch> ah, sorry
17:41:43 <syntaxglitch> yeah, bad notation there
17:41:54 <MissPiggy> > [-1,1]
17:41:55 <lambdabot>   [-1,1]
17:41:56 <MissPiggy> hehe
17:42:16 <syntaxglitch> Yeah, I was obviously thinking Haskell lists there :P
17:42:28 <MissPiggy> so anyway
17:42:45 <MissPiggy> it occurs to me that your problem is just* polynomial simplification
17:43:36 <jfoutz> i dunno. [-1,1] seems pretty resonable in #haskell :)
17:43:45 <MissPiggy> if you think about like data Term c v f = Constant c | Variable v | Function f [Term c v f] | Term c v f :+: Term c v f | Term c v f :*: Term c v f
17:44:17 <MissPiggy> you can pretty much treat functions as variables, the only difference is that you simplify the [Term c v f] bits inside too
17:44:36 <MissPiggy> (if you let v = f then nil lets you remove Variable too)
17:45:37 <MissPiggy> there could be some interactions not dealt with though: some sorts of functions f(x*y) = f(x)+f(y) and f(constants) that could be evaluated (any more?)
17:47:26 <syntaxglitch> here's a close-up on someone else's render of polynomial roots: http://math.ucr.edu/home/baez/roots/polynomialroots05expi02.png
17:47:33 <syntaxglitch> suffice it to say that mine did not look that nice
17:47:36 <MissPiggy> looks like an IFT
17:47:39 <MissPiggy> IFS*
17:47:53 <syntaxglitch> MissPiggy, indeed it does
17:47:56 <kmc_> ooh nice
17:48:04 <syntaxglitch> parts of it look rather like the Heighway dragon specifically
17:48:25 <MissPiggy> continuum from kosch to dragon
17:48:27 <[swift]_> that's really cool, syntaxglitch
17:48:41 <syntaxglitch> In general the "twistiness" of the lace-like bits changes depending on the location on the complex plane
17:48:48 <syntaxglitch> which isn't really too surprising, I guess
17:49:04 <MissPiggy> syntaxglitch that was mostly aimed at you btw ^
17:49:05 <MissPiggy> :p
17:49:34 <syntaxglitch> the weird part is that it comes from graphing a whole bunch of points representing the roots of polynomials unrelated except by common structure
17:50:23 <syntaxglitch> so you have something that looks like a line twisted upon itself being built from disconnected points... makes me wonder how it works
17:50:58 <syntaxglitch> MissPiggy, yeah, sorry :P
17:52:56 <syntaxglitch> MissPiggy, anyway yeah, that's about how I was planning to tackle it
17:54:00 <syntaxglitch> MissPiggy, if you want I'll try to remember to let you know when I get back to working on it
17:54:02 <halberd> some languages are designed to make disk access transparent, like Cache
17:54:26 <halberd> are there languages designed to make network access transparent as well, so there's no syntactic difference between accessing a local variable and accessing a network resource?
17:54:58 <kmc_> erlang has stuff like that
17:54:59 <syntaxglitch> doesn't Erlang abstract to a large extent the means of communication between processes?
17:55:07 <kmc_> and many languages implement transparent RPC
17:55:12 <ezyang> Why doesn't this line work? import "QuickCheck-1.2.0.0" Test.QuickCheck
17:55:19 <halberd> oh erlang does
17:55:20 <solrize> http://entiaetnomina.blogspot.com/2009/12/history-of-categorical-logic.html   yall know about this?  a free book on categorical logic
17:55:36 <ezyang> it attempts to match for the latest version...
17:56:05 <ezyang>     Failed to load interface for `Test.QuickCheck':       it is a member of the hidden package `QuickCheck-2.1.0.2'
17:56:13 <halberd> I'm thinking of something like this... you write "blah = foo.bar.baz + 3" and the language decides for you whether it will get foo.bar.baz from local memory, from disk, from the network, by calling a function, etc
17:56:32 <halberd> maybe from a database
17:56:47 <halberd> and the same for blah
17:56:50 <syntaxglitch> halberd, I suspect that in practice that wouldn't work as well as you'd hope
17:57:27 <MissPiggy> syntaxglitch especially if you have any different ideas, or realize some kind of flaw in something I say :)
17:57:27 <halberd> so maybe the "canonical" foo.bar.baz is on a database on a remote server
17:57:34 <ezyang> hmm, maybe package imports just doesn't work with version numbers...
17:57:53 <halberd> but your program grabs the entire foo.bar directory when it starts, because the compiler is smart, so then when you refer to foo.bar.baz it's a local variable
17:57:56 <syntaxglitch> halberd, on the other hand a language like that would be well suited to lazy evaluation, since anyone using it would clearly not care about being able to reason reliably about time complexity
17:58:00 <syntaxglitch> :P
17:58:15 <halberd> the language would have to make smart decisions about time complexity
17:58:21 <halberd> what to cache and when to cache it
17:58:23 <halberd> and when to write it back
17:59:17 <aavogt> well it takes time to make the correct decision, halberd
17:59:24 <halberd> at compile time
17:59:24 <syntaxglitch> halberd, I think that's a hard problem
17:59:25 <aavogt> maybe more than you might gain
17:59:28 <halberd> decide at compile time
18:00:02 <halberd> so that you could have a for loop that's as fast as c, even though the variable in the for loop is "foo.bar.baz.qux" instead of i
18:00:05 <syntaxglitch> possibly hard in the sense where step 1 is "invent human-equivalent AI"
18:00:36 <halberd> and where foo.bar.baz.qux "canonically" refers to a remote database access
18:01:01 <halberd> it would get cached locally
18:02:25 <aavogt> sometimes caching is slower
18:02:50 <halberd> well sometimes you don't have enough space in cache
18:03:18 <copumpkin> @quote scat
18:03:18 <lambdabot> lament says: hmph! i'm perfectly capable of writing obfuscated code by hand.
18:03:27 * copumpkin whistles
18:03:28 <halberd> it's like how a computer is designed to have storage of different levels, faster access levels being smaller and more expensive
18:03:45 <halberd> just add a network level below disk level in that hierarchy
18:04:48 <ddarius> syntaxglitch: Step 1) Invent better-than-human AI
18:05:25 <syntaxglitch> ddarius, nah, it's a problem that humans can solve
18:05:44 <monochrom> Invent better education.
18:05:45 <syntaxglitch> if nothing else step 2 might be "wait for faster hardware to make better use of your AI"
18:06:09 <halberd> one thing is that the compiler would need to know estimated costs of each operation
18:06:42 <halberd> like a network access costs 10,000 maybe, and a local memory access costs 1
18:06:44 <ddarius> syntaxglitch: You really think you can consistently, statically define a caching policy that will perform well?
18:07:44 <syntaxglitch> ddarius, I would expect that a sufficiently skilled person with enough time, optimizing a single program could get some benefits
18:08:05 <syntaxglitch> at least on average
18:08:29 <halberd> some dynamic decisions would also be acceptable if you're already talking about network operations
18:08:39 <halberd> like deciding which server is closer at a given time and going with that one
18:08:56 <halberd> that could all be done behind the scenes without a human coding it
18:09:05 <halberd> well except for the human who coded the compiler
18:09:12 <syntaxglitch> a consistently beneficial and fully general technique on the other hand probably has step 1 as "invent a Halting oracle"
18:09:34 <syntaxglitch> which is slightly less practical
18:09:41 <theorbtwo> syntaxglitch: For a moment there, I thought this was #nethack.
18:09:45 <aavogt> halberd: well you're hoping that the optimal decisions can be made for all possible code for some heuristics
18:10:33 <syntaxglitch> theorbtwo, would you like your possessions identified?
18:10:43 <halberd> a lot of coding decisions about when to cache seem fairly mechanical
18:10:46 <halberd> not much thought  involved
18:10:56 <halberd> a computer could do it
18:13:49 <halberd> let's say to simplify that we are dealing with read access only, to a large data structure that consists of a dictionary with multiple subscripts, like foo("1","2","4")
18:14:23 <halberd> and the client is talking to the server asking it for the values that correspond to various keys
18:14:41 <halberd> a computer could look at those communications and see if anything is redundant
18:14:45 <halberd> asked more than once
18:14:59 <halberd> or if they could ask for a lot in a batch instead of one at a time
18:15:40 <halberd> automatically optimize based on a runtime profile of the network operations
18:15:43 <syntaxglitch> hm
18:16:05 <syntaxglitch> I'm back on the "top haskell answerers from last 30 days" list on stack overflow
18:16:58 <halberd> mumps is a neat language
18:17:04 <scan>  /chat lambdabot @pl \n -> n
18:17:06 <scan> damn
18:19:42 <Philonous> id btw
18:19:53 <scan> was a test
18:20:03 <scan> but thanks
18:20:15 <Philonous> You're welcome ;)
18:28:37 <mreh>  /msg lambdabot @pl \n -> n
18:28:39 <mreh> that works
18:28:48 <mreh> scan ^
18:28:58 <scan> yes thanks
18:29:05 <mreh>  /msg lambdabot pl \n -> n
18:29:08 <scan> i found out
18:29:31 <mreh> she needs the @ in PMs too apparently
18:30:30 <scan> yeah
18:44:42 <thomastang> hello, I'm studying haskell. I met a problem that I can build my little program by 'ghc ...'.
18:45:01 <kamatsu> thomastang: yes, you can build your program with ghc
18:45:38 <thomastang> but when I try to build it by 'runhaskell Setup.lhs configure', it says it cannot found some packages.
18:45:53 <dmwit> Include them in your .cabal file, then.
18:45:57 <dmwit> In the build-depends section.
18:46:33 <thomastang> yes, I have a .cabal file. and put the build-depends there. but it says it cannot find them.
18:46:57 <doserj> --user
18:46:58 <thomastang> I'm sure I've install the package by 'cabal install ...'
18:47:40 <doserj> or build your program with 'cabal install'
18:49:02 <aavogt> otherwise you have to    runhaskell Setup.lhs configure --user
18:49:12 <aavogt> (it defaults to --global)
18:50:09 <thomastang> thanks, that solves my problem.
18:57:38 <thomastang> I've another question that do I have to actually install postgresql server before I can install hdbc-postgresql?
18:58:45 <aavogt> hmm, thomastang, hdbc-postgresql doesn't seem to build on ghc-6.12 though
18:59:11 <thomastang> I'm using ghc 6.10.4 right now.
19:00:31 <thomastang> Shall I upgrade to 6.12?
19:02:17 <aavogt> no, hdbc-postgresql doesn't build with 5.12
19:02:20 <aavogt> 6.12*
19:05:07 <thomastang> maybe I shall just switch to sqlite.
19:06:12 <copumpkin> mmm postgres
19:06:15 <copumpkin> mmmmmmmmmmmmmmm
19:06:27 <alp> any upgrade before hp is reasy is a bit risky :-D
19:30:43 <ezyang> When you're in an imperative language, you may use the "break" construct while in a loop. You can't really do that if you're in the list monad, can you?
19:31:02 <Cale> ezyang: You need callCC
19:31:02 <ezyang> or, at least, you're forced to think about that when you do the <-
19:31:11 <ezyang> let's... not do continuations
19:31:13 <ezyang> :-)
19:31:31 <ezyang> (it's a smidge like cheating in this exercise, I feel like)
19:31:39 <c_wraith> in the list monad, [] is kind of like break
19:31:41 <Cale> That's what break does. It calls the continuation of the implicit callCC which the loop has been wrapped in.
19:31:58 <sohum> if I have a recursive function of the form a -> State b c, where I use mapM to get the [c] in the recursive call and thus sequence the b's, it is the same state that gets threaded, right? and if so, where does the initial state come from? my base case calls get...
19:32:17 <ezyang> c_wraith: not really; it terminates execution for the rest of the "do-block", but it doesn't eliminate any trailing vals from the preceding <-
19:32:22 <ezyang> Cale: It's true.
19:32:33 <ezyang> hmm
19:32:38 * ezyang checks hackage for a "loops" library 
19:33:08 <Cale> sohum: the initial state comes from whatever happens before the mapM, or if that's nothing, it comes from the runState
19:33:25 <dmwit> sohum: The initial state comes from runState.
19:33:38 <dmwit> Oh, I'm way too slow.
19:33:45 * dmwit wanders off
19:34:07 <sohum> Cale, dmwit: aaah, right, because even when I call (function a), that's still of type State b c. to get the b out of that I need runState.
19:34:11 <sohum> right
19:34:12 <sohum> thanks
19:34:13 <sohum> !
19:34:14 <wagle> how do i get xemacs haskell-mode to indent guards correctly?  (it wont line them up)
19:34:17 <Cale> > let inc = do x <- get; put (x+1); return x in runState (do mapM (\x -> do u <- inc; return (x+u)) [10,20,30]) 1
19:34:20 <lambdabot>   ([11,22,33],4)
19:34:26 <sohum> :t runState
19:34:27 <lambdabot> forall s a. State s a -> s -> (a, s)
19:34:30 <Cale> er, no idea why I put that first do in :)
19:34:44 <Cale> > let inc = do x <- get; put (x+1); return x in runState (mapM (\x -> do u <- inc; return (x+u)) [10,20,30]) 1
19:34:45 <lambdabot>   ([11,22,33],4)
19:35:05 <ezyang> Oh, cool; if you use callCC you get reasonable semantics for breaking out of multiple loops ^^
19:35:17 <Cale> ezyang: yep
19:35:21 <Cale> > let inc = do x <- get; put (x+1); return x in runState (sequence [inc,inc,inc]) 0
19:35:22 <lambdabot>   ([0,1,2],3)
19:35:46 <sohum> @hoogle gr a b
19:35:46 <lambdabot> Text.Html background :: String -> HtmlAttr
19:35:46 <lambdabot> Text.XHtml.Transitional background :: String -> HtmlAttr
19:36:08 <sohum> there's no empty in fgl...
19:36:14 <sohum> > buildGr []
19:36:15 <lambdabot>   Not in scope: `buildGr'
19:36:23 <wagle> best I can do is:
19:36:27 <sohum> > Data.Graph.Inductive.buildGr []
19:36:27 <wagle> tokenize' (c : cs) token
19:36:27 <wagle>     | (c == '(') = reverse token : "(" : tokenize' cs []
19:36:27 <wagle>        | (c == ')') = reverse token : ")" : tokenize' cs []
19:36:28 <lambdabot>   Not in scope: `Data.Graph.Inductive.buildGr'
19:36:52 <wagle> it wont line up the |'s
19:37:03 <Axman6> what won't?
19:37:09 <Axman6> are you using tabs?
19:37:32 <tensorpudding> what editor are you using?
19:37:33 <wagle> xemacs..  tab cycles between that and worse
19:38:46 <tensorpudding> does it do that for simpler guarded expressions?
19:39:40 <tensorpudding> by the way, you don't need the parens around c == '(' and c == ')'
19:39:47 <kamatsu> hm, so, GHC can output C, right?
19:39:56 <kamatsu> i wonder if i could make haskell work on Google's Native Client
19:39:58 <ddarius> kamatsu: Sort of.
19:40:17 <wagle> no:
19:40:23 <wagle> foo x
19:40:23 <wagle>     | x == 1 = 2
19:40:23 <wagle>     | x == 2 = 1
19:40:38 <wagle> sigh... xemacs is b0rk yet again
19:41:16 <kamatsu> ddarius: "sort of"?
19:41:19 <tensorpudding> i thought xemacs used the same haskell-mode as gnu emacs
19:42:08 <ddarius> kamatsu: The C code usually produced by GHC is highly GCC specific and even particular versions of GCC specific and relies on a post-processing of the output of GCC.
19:42:24 <kamatsu> ah
19:42:29 <ddarius> There's a reason why GHC distributes with its own copy of GCC.
19:42:32 <wagle> dunno..  it doesnt understand that the '(' is a char
19:42:46 <kamatsu> wait, it does?
19:42:48 <wagle> (ie, i figured it out)
19:42:52 <kamatsu> i thought ghc used Cmm by default
19:42:53 <Axman6> ddarius: it does? :o
19:43:44 <monochrom> I can't find it.
19:45:08 <wagle> emacs gui is still b0rk (since the early 90's), but xemacs is rotting..  sigh
19:45:42 <kamatsu> eh, my lag keeps increasing
19:46:01 <wagle> emacs people will make fun of you for using the mouse..  they dont..  (because the gui has always been broken)..  </rant>
19:46:17 <kamatsu> ah, stopped now
19:47:16 <mreh> Mac/PC users laugh at you for using the keyboard most of the time, you just can't win
19:48:31 <kamatsu> vi?
19:49:08 <mreh> I'm a PC and my wrist joints have turned into marble
19:49:27 <monochrom> xmonad people laugh at you for moving windows manually, by mouse or by keyboard.
19:49:50 <monochrom> @quote console
19:49:50 <lambdabot> No quotes match. :(
19:50:08 <monochrom> @quote voluntarily
19:50:09 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
19:50:10 <mreh> who uses all 9 desktops?
19:50:38 <monochrom> And programmers laugh at you for using windowing.
19:51:26 <monochrom> If you feel that I'm citing degenerate people laughing at you for not being extremist, you're right.
19:51:45 <mreh> programmers are the pro-athletes of the computer world, you should copy what we do, it's just our waistlines follow an inverse proportionality to our level of skill
19:51:45 <monochrom> They are very degenerate, deranged, disturbed people.
19:52:42 * ddarius uses xmonad but only in full screen mode.
19:53:02 <mreh> extremism isn't a bad thing, with obvious exceptions
19:53:07 <pikhq> ... GHC ships with its *own copy* of GCC?
19:53:14 <mreh> functional programming is extreme
19:53:23 * pikhq uses Ratpoison
19:53:23 <Olathe> pikhq: Yep.
19:53:26 <mreh> not as a extreme as Xtreem programming!
19:53:32 <pikhq> Quite nice for swapping between two windows.
19:53:32 <ddarius> pikhq: I thought I saw it on linux.  It definitely does or did on Windows.
19:53:39 <pikhq> Horrible when you  start doing more than that.
19:53:48 <ddarius> There have definitely been times where GHC broke between minor revisions of GCC.
19:54:14 <pikhq> I'm pretty sure that Gentoo ships it using the system GCC.
19:54:20 <mreh> is GHC forward compatible with GCC then?
19:54:36 <pikhq> Of course, Gentoo tries to be rather stable with its system GCC...
19:54:59 <pikhq> Still on GCC 4.3.4 here.
19:55:15 <ddarius> pikhq: Yeah, it looks like Ubuntu does more or less as well and I don't see a local copy of GCC.  So either I am wrong on (at least some) Linuxes or my knowledge is out of date.
19:56:43 <pikhq> ddarius: I wouldn't trust Ubuntu's config, though.
19:56:53 <pikhq> They seem to have a thing for shipping broken compilers.
19:57:10 <ddarius> I don't use the Ubuntu packages for GHC, but otherwise I haven't had any issues with Ubuntu.
19:57:25 <pikhq> (once saw its GCC "optimise" a tail-recursive function by removing the tail call.)
19:59:11 <ezyang> hmm, blobs is reported to be "experimental" on 6.4...
19:59:39 <ddarius> Most modules and libraries are marked as "experimental" or "provisional"
20:11:55 <jmcarthur> OMG! HASKELL CODE HAS TOO MANY ABSTRACTIONS FOR MY IMPERATIVE MIND TO HANDLE. HASKELL MUST SUCK </imperative-programmers-on-reddit>
20:12:09 <xerox> ETOOMANYABSTRACTIONS
20:12:13 <monochrom> abstraction is bliss
20:12:15 <kamatsu> i know, this attitude keeps coming up >_>
20:12:35 <kamatsu> Someone said he tried haskell for *generating fractals* but couldn't figure out how to make it parallel
20:12:46 <jmcarthur> i saw that too
20:12:50 <kamatsu> and so he wrote a parallel version in C and said it was easier
20:12:57 * jmcarthur shakes his head
20:13:00 <monochrom> This is why you need to connect your smarter-than-people AI to the internet to correct and educate people on reddit.
20:13:21 <holmak> aren't there about 50 tutorials on how to use pmap?
20:13:28 <kamatsu> i thought so >_>
20:13:50 <kamatsu> I wonder if he was lying, and just never tried haskell at all, and didn't want haskellers telling him he should've used haskell
20:13:56 <holmak> we should each go post another, then surely no one will fail to parallelize haskell ever again
20:14:01 <jmcarthur> kamatsu: i think he posted the source for it
20:14:08 <kamatsu> jmcarthur: the haskell one?
20:14:17 <jmcarthur> kamatsu: i thought he did. lemme check
20:14:46 <jmcarthur> maybe i was wrong
20:15:09 <kmc> jmcarthur, the irony being, the abstraction that gets the most complaining and general noise is the one that captures imperative programming
20:15:23 <ezyang> I want to write a graphical directed graph editor; any library recommendations?
20:15:40 <kamatsu> ezyang: for the directed graph or the graphics?
20:15:58 <ezyang> graphics
20:16:07 <medfly> lol
20:16:14 <kmc> ezyang, i made a super crappy graph editor with cairo
20:16:16 <kmc> not in Haskell though
20:16:24 <kamatsu> ezyang: do you want a UI toolkit or a simple drawing library?
20:16:25 <medfly> you know guys, I should troll your reddit website similarly
20:16:35 <kmc> i've been disappointed at the lack of free visual graph editors
20:16:36 <medfly> saying that C is too hard because it has crappy syntax which is not like Haskell
20:16:48 <kamatsu> medfly: ah, please do!
20:16:52 <ezyang> kamatsu: It would be really cool if I got a library with all batteries included.
20:16:53 <kamatsu> medfly: post it on /r/programming
20:16:57 <kmc> basically i want to run graphviz for layout, then manually tweak it
20:16:58 <jmcarthur> @remember kmc the irony being, the abstraction that gets the most complaining and general noise [from imperative programmers] is the one that captures imperative programming
20:16:58 <lambdabot> Done.
20:16:58 <medfly> :)
20:17:03 <medfly> I AM LOVED!
20:17:12 <ezyang> since building a GUI interface seems Hard(TM)
20:17:24 <kmc> and i couldn't find any free software to do this :/
20:17:30 <jmcarthur> ezyang: not if you do it in visual basic to track an ip address!
20:17:37 <kamatsu> jmcarthur: hells yeah!
20:17:40 <kamatsu> VB rocks
20:18:06 <kamatsu> All the power of haskell, without all that pesky abstraction or conciseness!
20:18:26 <monochrom> Chinese is better.
20:18:27 <ezyang> If I can't find anything good, I'm tempted to do it instead in Javascript and SVG. Which means I can't use Haskell. :-(
20:18:43 <kamatsu> ezyang: indeed that is sad, but there are lots of drawing libraries
20:18:55 <kamatsu> ezyang: if you want a full toolkit though, you're stuck with: GTK, Qt, Wx
20:18:59 <ezyang> Which ones have primitive for interactivity?
20:19:06 <kamatsu> wait, are there Qt bindings for Haskell?
20:19:10 <ezyang> The rest of the app can be butt-ugly :-)
20:19:22 <ezyang> I'm looking at http://www.haskell.org/haskellwiki/Libraries_and_tools/Graphics
20:19:30 <dolio> Where can I get a Chinese compiler?
20:19:31 <kamatsu> ezyang: if you're really feeling like fun, write it using SDL and my Sprig bindings ;D
20:19:46 <ezyang> blobs actually looked kinda promising, except for the GHC 6.2 thing
20:19:54 <ezyang> kamatsu: fun or "fun"? ;-)
20:19:57 <kamatsu> dolio: unfortunately the only compilers that exist don't fully implement the spec, and they just translate to another language that is equally hard to compile
20:19:59 <kmc> dolio, china
20:20:29 <monochrom> I am a pay-per-use Chinese compiler.
20:20:32 <jmcarthur> kamatsu: there are qt bindings for haskell, but they are (semi?) automatically generated and basically keep the OO design
20:20:56 <kamatsu> ezyang: depends on if you like to write basic ui code yourself or use prebuilt abstractions
20:21:13 <ezyang> I've never done either, except when I was patching some GTK code.
20:21:24 <kamatsu> hm
20:21:49 <kamatsu> well, personally i'd try using gtk2hs and embedding a cairo context for the drawing
20:21:56 <kamatsu> does haskell have cairo bindings?
20:22:03 <dmwit> Yes.
20:22:05 <dcoutts_> kamatsu: they come with gtk2hs
20:22:07 <dmwit> They come with gtk2hs.
20:22:08 <kamatsu> ah
20:22:25 <ezyang> Is gtk2hs reasonably stable?
20:22:30 <dcoutts_> yes
20:22:35 <monochrom> gtk2hs contains cairo binding. but you have to have cairo headers before you build gtk2hs to get it.
20:23:07 <monochrom> gtk2hs's configure detects what headers you have and skip things.
20:23:24 <monochrom> perhaps I mean: detects what headers you don't have and skip things.
20:23:27 <ezyang> How long and hard would this road be?
20:23:38 <kamatsu> ezyang: with gtk2hs, not too hard i'd say
20:23:47 <kamatsu> ezyang: assuming you know Haskell well
20:23:53 <kamatsu> ezyang: and you can learn libraries
20:24:03 <ezyang> cool.
20:24:10 <ezyang> Sounds like a good project to try then.
20:24:26 <kamatsu> i dunno, i like writing Haskell code that has a lot of pure internals
20:24:30 <ezyang> I have very little domain knowledge here, so I'm really shooting in the dark.
20:24:32 <kamatsu> ah, i suppose a graph program would too, nvm
20:25:29 <ezyang> I was half-expecting people to tell me, "what you're attempting is hard, don't bother."
20:25:51 <kmc> it's hard
20:25:53 <kamatsu> if you're a beginner to the language / don't understand monads
20:25:59 <kamatsu> i would say that
20:25:59 <kmc> but we don't discourage hard things
20:26:08 <kmc> earlier i was advising people to solve undecidable problems
20:26:27 <monochrom> I played with gtk2hs a bit. Not hard to use.
20:26:29 <kmc> or rather to write a program which could solve a particular undecidable problem
20:26:39 <kamatsu> it basically feels like an imperative UI lib
20:26:50 <kmc> also, my graph editor in Python is dog slow (running with CPython)
20:26:54 <kmc> in Haskell it'd be much faster
20:27:03 <ezyang> the functional UI libs are, as I understand, still too experimental? ;-)
20:27:16 <copumpkin> omnom
20:27:16 <kmc> don't know about Javascript / SVG... you'd run it in a browser, or something like xulrunner?
20:27:32 <ezyang> kmc: yup
20:27:38 <kmc> ezyang, kamatsu, yes, but Haskell is a fine imperative language
20:27:41 <ezyang> It'd probably be ass slow
20:27:47 <ezyang> kmc: Fair fair!
20:27:49 <kmc> you still get better abstraction than most languages at less cost
20:28:31 <jmcarthur> kmc: you mean IO is a fine imperative language ;)
20:28:49 <kmc> sure
20:28:56 <kmc> Haskell is a fine language for manipulating abstract data, some of which might happen to represent imperative actions
20:29:31 <kmc> etc etc.
20:29:34 <kamatsu> i agree strongly with kmc
20:29:38 <kamatsu> it is a better imperative language than most
20:29:39 <kmc> i agree strongly with kmc
20:29:49 <ezyang> what is the install story for gtk2hs? should I attempt Cabal?
20:29:50 <copumpkin> I strongly agree with kamatsu in his agremeent with kmc
20:29:54 <dons> gwern: hlist doesn't build with 6.12
20:29:56 <kamatsu> haha
20:29:58 <kmc> the beauty of this channel is that everyone agrees strongly with everyone else
20:30:01 <dons> ?tell gwern hlist doesn't build with 6.12
20:30:01 <lambdabot> Consider it noted.
20:30:06 <copumpkin> kmc: I strongly disagree
20:30:18 <kmc> guys, i think Haskell is better than PHP
20:30:22 <kmc> i know this sounds controversial
20:30:23 <kmc> but hear me out
20:30:28 <kamatsu> ha
20:30:29 <jmcarthur> I agree with copumpkin's strong agreement with kamatsu agreeing with kmc.
20:30:37 <copumpkin> jmcarthur: hear, hear
20:30:41 <kmc> @quote PHP
20:30:41 <lambdabot> sieni says: python, like php, is just training wheels without the bike
20:30:46 <copumpkin> @quote scat
20:30:46 <lambdabot> ksf says: Perl is obfuscated by design, haskell is designed by obfuscation.
20:30:53 <copumpkin> @quote scat
20:30:53 <lambdabot> ksf says: Perl is obfuscated by design, haskell is designed by obfuscation.
20:30:56 <copumpkin> :(
20:30:58 <Gracenotes> :|
20:31:06 <copumpkin> @quote tensorpudding
20:31:07 <lambdabot> tensorpudding says: lolcategory demands moarphisms
20:31:14 <kamatsu> hahahahha
20:31:40 <copumpkin> @quote tensorpudding
20:31:40 <lambdabot> tensorpudding says: the Plot monad allow you to keep the story pure by containing all the glaring time travel silliness
20:33:57 <kmc> @quote ruby
20:33:57 <lambdabot> chrisdone says: benchmarks only exist to make fun of ruby
20:34:01 <kmc> @quote ruby
20:34:01 <lambdabot> LeCamarade says: Now, let's say the set is {Haskell, SML, Ruby, Tomatoes, Human, Cabbage, Noise, IRC}.
20:35:28 <Gracenotes> ah, one of those idempotent commutative free monoids
20:36:17 <dmwit> ezyang: In case you haven't figured it out yet, no, you shouldn't attempt cabal-installing gtk2hs.e
20:36:43 <ezyang> yeahhh
20:36:46 <ezyang> using my distro's version
20:36:48 <kmc> what makes a monoid free?
20:37:02 <dmwit> ezyang: smart
20:37:02 <kmc> generators with no equations?
20:37:44 <copumpkin> it's a construction
20:37:50 <doserj> no equations except those implied by the monoid laws
20:37:56 <dmwit> Free monoids are the initial object in the category of monoids with morphisms as arrows.
20:38:09 <kmc> monoid homomorphism?
20:38:11 <dmwit> wait
20:38:16 <dmwit> Is that right?
20:38:22 <kmc> doesn't the category only have one initial object?
20:38:22 <Wooga_tc> @src otherwise
20:38:23 <lambdabot> otherwise = True
20:38:26 <copumpkin> "with morphisms as arrows"?
20:38:31 <copumpkin> kmc: that's a different construction
20:38:35 <kmc> urk
20:38:37 <copumpkin> that's making a category out of a monoid
20:38:50 <kmc> no i mean, in general, can a category have more than one initial object?
20:38:58 <copumpkin> oh sorry :)
20:38:59 <dmwit> Well, any category has only one initial object (up to isomorphism).
20:39:08 <doserj> the free monoid functor Set -> Monoid is the adjoint to the forgetful functor Monoid -> Set
20:39:10 <dmwit> So I think I said it wrong.
20:39:37 <doserj> (don't ask wether left- or right-adjoint...)
20:40:05 <Gracenotes> ooh, I have a great idea: let's add {-# NOINLINE #-} in front of GHC's definition of otherwise
20:40:11 <kmc> how does the free monoid functor choose an identity element?
20:40:20 <kmc> hahaha Gracenotes
20:41:49 <dmwit> kmc: The empty sequence is the identity element.
20:42:04 <kmc> oh, right
20:42:18 <kmc> it's the monoid of every word formed from characters taken from the set
20:42:28 <dmwit> *nod*
20:43:30 <kmc> so in fact this functor is precisely the Haskell functor []
20:43:34 <kmc> lists are free monoids?
20:43:39 <dmwit> yes!
20:43:40 <doserj> yes
20:43:52 <kmc> woooo
20:43:52 <doserj> (well finite-length lists)
20:44:11 <ezyang> http://darcs.haskell.org/gtk2hs/demo/ is broken...
20:44:50 <dcoutts_> ezyang: it's moved to code.h.o
20:45:01 <dcoutts_> which link needs updating?
20:45:26 <ezyang> http://www.haskell.org/gtk2hs/documentation/
20:45:35 <ezyang> demo/ directory
20:48:08 <ezyang> Hmm, I'm going to get very comfortable with Cairo, aren't I...
20:48:25 <dcoutts_> ezyang: thanks, fixed.
20:49:37 <Gracenotes> cairo is relatively pleasant
20:50:22 <Gracenotes> for simple to mid-upper intermediate graphics things, at least
20:50:44 <dmwit> ezyang: What are you doing with it?
20:50:49 <copumpkin> Gracenotes: that's a lot of modifiers on things
20:51:27 <ezyang> dmwit: directed graph editor!
20:51:35 <ezyang> maybe acyclic if it makes it easier.
20:51:45 <Gracenotes> copumpkin: just going south-south-south-west on the path to personal discovery
20:51:45 <dmwit> Neat!
20:51:53 <dmwit> ezyang: What will be better about it than dotty?
20:52:07 <dmwit> (I'm setting the bar nice and low for you here. =)
20:52:12 <ezyang> wait, is /that/ the name of it?
20:52:17 * ezyang was looking for that... 
20:52:26 <ezyang> I want to use it on Git.
20:53:32 <ezyang> but I'm not going to worry about that before then.
20:53:39 <ezyang> I guess I should go try dotty
20:54:29 <ezyang> why, dotty sucks a lot.
20:54:35 <dmwit> Why, yes!
20:57:16 <ezyang> ok, objective one: redrawing nodes will actually work!
20:57:42 <dmwit> Ah!
20:57:50 <dmwit> You just reminded me of my little physics simulation toy.
20:58:05 * ezyang wrote one of those in Java. 
20:58:10 <ezyang> "oh man oh man"
20:58:57 <ezyang> the gtk2hs demo apps take a long time to die...
20:59:00 <dmwit> Ah, yes, but mine uses Chipmunk for the physics and multithreading for the GUI!
20:59:15 <dmwit> Which makes it AWESOME!
20:59:24 <copumpkin> zomg
20:59:44 <copumpkin> ( on a related note, http://powder.unaligned.org/ is awesome )
20:59:50 <ezyang> that is pretty awesome
21:02:21 <dmwit> hm
21:02:30 <dmwit> I feel dirty giving +x to something from the net.
21:02:38 <copumpkin> no, it's awesome
21:02:45 <copumpkin> (an awesome trojan)
21:03:20 <ezyang> that's also awesome...
21:03:43 <copumpkin> I love filling things with gas until the pressure makes it explode
21:04:32 <kmc> that's fun
21:04:34 <kmc> irl too
21:04:36 <kamatsu> copumpkin: I tend to play dan-ball.jp's one the most
21:04:42 <kamatsu> copumpkin: is this one better?
21:04:44 <Gracenotes> you know what? windows can handle gzip'd files
21:04:48 <Gracenotes> it CAN'T
21:04:50 <copumpkin> kamatsu: I haven't tried that
21:04:54 <Gracenotes> I was angered about this earlier
21:05:04 <kamatsu> try dan-ball.jp/en/javagame/dust/
21:05:27 <kamatsu> (unless you speak japanese ;)
21:05:57 <copumpkin> I like this one cause it's beautifully lightweight
21:06:07 <jmcarthur> i wonder how much happier i would be if i stopped reading reddit comment threads. /r/programming and /r/politics, especially
21:06:09 <copumpkin> runs superfast in little memory
21:06:14 <Gracenotes> oh, after downloading.. it's a variant of that game
21:06:24 <monochrom> jmcarthur: Very happy. As happy as me.
21:06:30 <Gracenotes> particles seemingly disperse... oddly
21:06:30 <ezyang> definitely drop politics
21:06:39 <copumpkin> it's fun to put fire on a clone thingy
21:06:40 <Gracenotes> must add to the funness
21:07:03 <ezyang> I can't get my container to 'splode
21:07:06 <ezyang> time to set it on fire
21:07:12 <jmcarthur> ezyang: not a big difference between /r/politics and /r/programming when functional programming comes up
21:07:35 <ezyang> ^^ It's true.
21:07:37 <copumpkin> I like the clone + fire thing because it looks like a real fire
21:07:42 <monochrom> spend more time on haskell-cafe if you need company.
21:07:48 <tensorpudding> reddit is full of people who have very strong opinions
21:07:55 <ezyang> s/reddit/the internet/
21:07:58 <tensorpudding> i.e. geeks who are emotionally invested
21:08:10 <monochrom> s/the internet/the world/
21:08:15 <Gracenotes> copumpkin: how to change cursor size?
21:08:19 <tensorpudding> not everyone has strong opinions on everything
21:08:28 <kamatsu> ahh, this one has pressure and heat
21:08:33 <kamatsu> i'm converting to this one full time :D
21:08:46 <copumpkin> Gracenotes: don't think you can, but particles appear quicker if you move the cursor
21:08:59 * copumpkin made himself a metal cup with a constant fire under it
21:09:00 <monochrom> Â«not everyone has strong opinions on everythingÂ» does not contradict Â«the world is full of people who have very strong opinionsÂ»
21:09:21 <monochrom> e.g., not everyone is a fool, but the world is still full of fools.
21:09:34 * copumpkin puts snow in the cup and waits for it to boil
21:09:52 <copumpkin> it isn't behaving very realistically :(
21:09:52 <kmc> copumpkin, camping?
21:09:58 <kmc> oh right, in the game
21:11:21 <Adamant> it's at the point I yoinked /r/programming out of my RSS reader.
21:12:54 <Wooga_tc> @src group
21:12:54 <lambdabot> group = groupBy (==)
21:13:07 <Wooga_tc> @src groupBy
21:13:08 <lambdabot> groupBy _  []       =  []
21:13:08 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
21:13:08 <lambdabot>     where (ys,zs) = span (eq x) xs
21:13:40 <ezyang> dangnabit you've all distracted me!
21:14:23 <monochrom> o hai ezyang, did you know that reddit.com/r/programming is an awesome site! XD
21:15:41 <ezyang> I should read haskell-cafe more religiously
21:15:46 <ezyang> It's higher volume than reddit though
21:18:59 <tibbe> jetlag sucks
21:21:03 <solrize> planet haskell is good
21:21:34 <ezyang> Yeah, I skim everything there :-)
21:21:56 <solrize> do adjoint functors have anything to do with functional programming?
21:29:17 <kmc> solrize, yes, they relate to monads
21:29:28 <solrize> cool
21:30:41 <ezyang> are these... the Kan extensions?
21:31:18 <solrize> hmm, you use the left adjoint in the bind operation, to get objects out of the monad, then use the right adjoint to put the function value back in?
21:33:09 <solrize> the only category in haskell we talk about is * which is one category, right?  i.e. haskell "functors" are all within * rather than between two categories
21:33:31 <kmc> instances of the haskell typeclass «Functor» are all endofunctors in the category Hask
21:33:40 <eldragon> hi guys
21:33:42 <kmc> the category Hask has as its objects Haskell types, and as its morphisms Haskell functions
21:33:49 <solrize> right
21:33:56 <kmc> you can describe other categories in Haskell
21:34:05 <kmc> and functors between them
21:34:11 <kmc> but it's largely outside the standard library
21:34:14 <solrize> hmm
21:34:18 <eldragon> i'm looking for two rationals a, b that satisfies  b^4 + a^4 +2(a^3)b + 4 = 2a(b^3) + (a^2)(b^2) + 6(b^2) + 4(a^2) + 4ab ; and i don't know how.
21:34:35 <solrize> looks like a binomial expansion
21:34:48 <dolio> You can't really describe other categories very well.
21:35:01 <dolio> They always have to be categories whose objects are Haskell types.
21:35:17 <ezyang> aight, time to head home
21:35:19 <solrize> well they can be values
21:35:21 <ezyang> goodnight #haskell!
21:36:55 <solrize> nite ezyang
21:52:14 <o-_-o> hello
21:52:27 <kmc> hi
21:52:29 <o-_-o> there is a haskell job ad on linked in
21:52:37 <o-_-o> if anyone is interested
21:52:45 <o-_-o> the job is in prague
21:53:48 <sohum> @pl \x -> f (g (h x) y)
21:53:49 <lambdabot> f . flip g y . h
21:54:16 <sohum> maan, flip is awesome
21:54:19 <sohum> :t flip
21:54:20 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
21:54:25 <jmcarthur> does anybody here know how to punch somebody in the face over the internet?
21:54:35 <sohum> CALESKELL *RAGE*
21:55:04 <sohum> :t flip `asTypeIn` \flip -> flip (+)
21:55:06 <lambdabot> forall b. (Num b) => (b -> b -> b) -> b -> b -> b
21:55:06 <jmcarthur> i'm not very good at nonviolent communication
21:55:13 * sohum duh
21:55:29 <sohum> :t flip `asTypeIn` \flip -> flip (undefined :: a -> b -> c)
21:55:30 <Saizan> :t flip `asTypeIn` \flip -> flip const
21:55:31 <lambdabot> forall a b. (b -> a -> b) -> a -> b -> b
21:55:31 <lambdabot> forall a b a1. (a1 -> a -> b) -> a -> a1 -> b
21:55:49 <o-_-o> jmcarthur, if the target is in the channel, get ops and kick them :-) ?
21:56:39 <sohum> @hoogle (a -> b -> c -> d) -> c -> a -> b -> d
21:56:39 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
21:56:39 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
21:56:39 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
21:56:48 <o-_-o> > :t (<$>)
21:56:49 <lambdabot>   <no location info>: parse error on input `:'
21:56:58 <sohum> @djinn (a -> b -> c -> d) -> c -> a -> b -> d
21:56:59 <lambdabot> f a b c d = a c d b
21:57:00 <o-_-o> :t (<$>)
21:57:00 <wagle> woot!  my haskell parser worked just as soon as it typechecked!
21:57:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:57:06 <wagle> inconceivable!
21:57:16 <BMeph> sohum: That, too is "flip". ;)
21:57:49 <sohum> BMeph: it's a variant of flip, but not exactly...
21:58:04 <sohum> @pl \a b c d -> a c d b
21:58:05 <lambdabot> flip . (flip .)
21:58:25 <BMeph> sohum: Where f a :: c -> d -> a. ;)
21:59:02 <kamatsu> copumpkin: can i find a home page for that powder game you linked?
21:59:14 <copumpkin> kamatsu: that url is the home page I think
21:59:20 <kamatsu> copumpkin: yeah, i lost the url
21:59:22 <sohum> BMeph: ?
21:59:30 <copumpkin> kamatsu: powder.unaligned.org iirc
22:01:06 <kamatsu> copumpkin: thanks
22:01:10 <jmcarthur> o-_-o: ha
22:01:24 <jmcarthur> would need to get ops, plus i doubt this guy's in here
22:01:42 <jmcarthur> unless StoneToad_ == StoneCypher
22:02:00 <BMeph> sohum: (a -> b -> (c -> d)) -> c -> (a -> b -> d). Substitute f n = (a -> b -> n) => f (c -> d) -> c -> f d
22:03:18 <sohum> BMeph: I'm still confused. how does that make it exactly flip?
22:03:32 <sohum> :t flip `asTypeIn` \flip -> flip (undefined :: a -> b -> c -> d)
22:03:33 <lambdabot> forall a a1 c d. (a1 -> a -> c -> d) -> a -> a1 -> c -> d
22:08:36 <Saizan> BMeph: except that you need TypeCompose or something to get that instance to work
22:08:51 <Saizan> BMeph: i should have said "a newtype"
22:13:52 <wagle> whats the incantation for searching for a function of a particular type?
22:14:10 <monochrom> @hoogle [a]->Int
22:14:10 <lambdabot> Prelude length :: [a] -> Int
22:14:10 <lambdabot> Data.List length :: [a] -> Int
22:14:10 <lambdabot> Prelude head :: [a] -> a
22:14:26 <wagle> @hoogle String -> Integer
22:14:27 <lambdabot> Prelude read :: Read a => String -> a
22:14:27 <lambdabot> Text.Read read :: Read a => String -> a
22:14:27 <lambdabot> Prelude error :: [Char] -> a
22:14:33 <wagle> duh
22:14:38 <monochrom> heh
22:15:03 <monochrom> The correct answer is Prelude.error! :)
22:15:38 <wagle> well, in this case, i KNOW its all digits..  i looked
22:16:36 <xerox> ...but then I eated it
22:16:47 <wagle> of course, if i blew it, the error message is informative
22:17:05 <monochrom> It's still all digits after you eated it.
22:17:19 <wagle> Prelude> read "123x" :: Integer
22:17:19 <wagle> *** Exception: Prelude.read: no parse
22:17:36 <kamatsu> >reads "123x"
22:17:44 <wagle> ah ha
22:17:49 <kmc> > reads "123x" :: [(Integer, String)]
22:17:50 <lambdabot>   [(123,"x")]
22:17:57 <sohum> @hoogle String -> Maybe a
22:17:58 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
22:17:58 <lambdabot> Prelude fail :: Monad m => String -> m a
22:17:58 <lambdabot> Control.Monad fail :: Monad m => String -> m a
22:18:27 <sohum> why isn't maybeRead in the Prelude?
22:18:29 <kmc> > fst <$> listToMaybe (reads "123x") :: Maybe Integer
22:18:30 <lambdabot>   Just 123
22:18:37 <sohum> :t reads
22:18:37 <kamatsu> sohum: reads is?
22:18:38 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:18:46 <kmc> the reads interface is clunky tho
22:18:49 <sohum> ah, right
22:19:13 <sohum> :t listToMaybe . reads
22:19:15 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
22:20:10 <sohum> @pl \x -> fst <$> listToMaybe (reads x)
22:20:11 <lambdabot> (fst <$>) . listToMaybe . reads
22:20:12 <wagle> | all isDigit cs = TokenNUMBER (read cs)
22:20:26 <wagle> meh
22:20:30 <sohum> :t (fst <$>) . listToMaybe . reads
22:20:31 <lambdabot> forall a. (Read a) => String -> Maybe a
22:20:58 <sohum> :t liftM fst . listToMaybe . reads
22:21:00 <lambdabot> forall a. (Read a) => String -> Maybe a
22:21:26 <sohum> there. a maybeRead.
22:21:43 <kmc> except it's happy to leave some input unconsumed
22:22:03 <sohum> does that matter?
22:22:10 <kmc> well...
22:22:15 <sohum> I suppose it does
22:22:18 <kmc> you might want that behavior, or you might not
22:22:21 <kmc> or you might not care
22:22:33 <sohum> it's semantics are not exactly what you'd expect from spoon . read
22:22:37 <kmc> yes
22:22:47 <kmc> :t spoon
22:22:48 <lambdabot> Not in scope: `spoon'
22:22:51 <kmc> there is no spoon :/
22:22:58 <wagle> in this case, i want to consume the whole thing, or its an error
22:23:05 <kamatsu> kmc: spoon is a library
22:23:12 <kmc> yeah
22:23:17 <kmc> was wondering if lambdabot had it
22:24:45 <dmead> when people run in circles
22:24:46 <dmead> it's a very very
22:24:49 <dmead> maaaad worldddd
22:25:20 <kmc> cellar door
22:36:24 <sohum> :t tell
22:36:25 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
22:44:57 <sohum> @hoogle gr a b -> a -> LNode a
22:44:58 <lambdabot> Did you mean: Gr a b -> a -> LNode a /count=20
22:44:58 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
22:44:58 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
22:47:36 <tomberek> Test
22:48:12 <Veinor> D-, see me after class
22:51:36 <sohum> @hoogle gr a b -> [LEdge b] -> gr a b
22:51:36 <lambdabot> Did you mean: Gr a b -> [LEdge b] -> Gr a b /count=20
22:51:36 <lambdabot> Data.Graph.Inductive.Graph insEdges :: DynGraph gr => [LEdge b] -> gr a b -> gr a b
22:51:36 <lambdabot> Data.Graph.Inductive.Graph insEdge :: DynGraph gr => LEdge b -> gr a b -> gr a b
22:53:13 <sohum> @hoogle [LNode a] -> [LEdge b] -> gr a b
22:53:14 <lambdabot> Did you mean: [LNode a] -> [LEdge b] -> Gr a b /count=20
22:53:14 <lambdabot> Data.Graph.Inductive.Graph mkGraph :: Graph gr => [LNode a] -> [LEdge b] -> gr a b
22:53:14 <lambdabot> Data.Graph.Inductive.Monad mkGraphM :: GraphM m gr => [LNode a] -> [LEdge b] -> m (gr a b)
22:53:18 <sohum> aha
23:01:10 <sohum> @pl \n -> f (g (h n) n)
23:01:11 <lambdabot> f . (g =<< h)
23:01:26 <sohum> :t (=<<)
23:01:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
23:01:41 <sohum> @hoogle (=<<)
23:01:41 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
23:01:42 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
23:01:50 <sohum> prelude, huh.
23:02:59 <sohum> @pl \n -> f (g (h n) n) >> i n
23:03:00 <lambdabot> ap ((>>) . f . (g =<< h)) i
23:03:05 <sohum> ew.
23:03:10 * hackagebot upload: altfloat 0.2.1 - Alternative floating point support for GHC. (NickBowler)
23:05:44 <dmwit> ?pl \n -> liftM2 (>>) (f . g (h n)) i n
23:05:44 <lambdabot> join (flip (liftM2 (>>) . (f .) . g . h) i)
23:18:24 <sohum> :t tell ["foo"]
23:18:25 <lambdabot> forall (m :: * -> *). (MonadWriter [[Char]] m) => m ()
23:21:08 <sohum> :t (>>) tell ["foo"]
23:21:10 <lambdabot>     Couldn't match expected type `w -> b' against inferred type `[a]'
23:21:10 <lambdabot>     In the second argument of `(>>)', namely `["foo"]'
23:21:10 <lambdabot>     In the expression: (>>) tell ["foo"]
23:21:17 <sohum> :t (>>) (tell ["foo"])
23:21:18 <lambdabot> forall (m :: * -> *) b. (MonadWriter [[Char]] m) => m b -> m b
23:22:00 <dmwit> :t (tell ["foo"] >>)
23:22:01 <lambdabot> forall (m :: * -> *) b. (MonadWriter [[Char]] m) => m b -> m b
23:30:10 <dmead> http://en.wikipedia.org/wiki/Monad_%28Greek_philosophy%29
23:48:43 <sohum> :t fmap `asTypeIn` \fmap -> \f -> fmap f ("foo", "bar")
23:48:44 <lambdabot> forall b. ([Char] -> b) -> ([Char], [Char]) -> ([Char], b)
23:49:09 <sohum> dammit.
23:49:27 <copumpkin> it can't be bimap
23:50:55 <sohum> yea
23:52:19 <sohum> @pl \(x,y) -> (f x,f y)
23:52:20 <lambdabot> f *** f
23:52:24 <copumpkin> :)
23:52:26 <copumpkin> join (***)
23:52:45 <copumpkin> note that that forces both f to have the same type
23:53:04 <copumpkin> whereas writing it out by hand doesn't
23:53:20 * sohum nod
23:54:08 <Saizan> a single type for f should be enough for everyone
23:55:10 <tomberek> thanks tolkien
