00:02:50 <Apocalisp> OI String -> () ?
00:02:55 <Cale> falconair: Well, this is edging up on territory (functional reactive programming) where we haven't really found the right primitives. I think I'd have to know more about what Rx actually is in order to say how it translates into this stuff and whether it's actually a comonad or something.
00:03:17 <Cale> Apocalisp: hmm
00:03:44 <Cale> Apocalisp: but any defined function of that type is equivalent to const ()
00:04:09 <Apocalisp> oh wait... it's (OI String -> String)
00:04:15 <Cale> Apocalisp: I was thinking OI () -> String
00:04:22 <Cale> But this has problems
00:04:57 <Cale> consider  foo oi = let x = getLine oi; y = getLine oi in x ++ y
00:05:07 * ski thinks `OI' will not work, except maybe with uniqueness types or something like that
00:05:20 <Cale> ski: That's what I'm demonstrating :)
00:05:41 <Apocalisp> ski: see, I was thinking that uniqueness types were equivalent to OI
00:05:57 <ski> Cale : though `putString' would be better as example, i think ..
00:06:00 <Cale> You need uniqueness types to make OI work properly
00:06:02 <falconair> Cale: I think it is worth checking out, Erik has a fairly large number of videos on the subject at channel9.msdn.com, in which he (and his people) go into detail..unfortunately the detail is in terms of implementations or c# code...the same with various blog posts, with which there was a "Comonad Comprehensions: A Versatile Representation for Streaming Queries"
00:06:33 <Cale> falconair: oh, okay, so perhaps it really is a comonad
00:06:50 <c_wraith> huh.  Rx seems to be a huge improvement in UI design for languages in that family.
00:06:54 <tensorpudding> coinput/cooutput
00:07:34 <falconair> Cale: no no, the "Comonad Comprehensions" line is just a joke, no such paper. I'm saying I wish one existed, Torsten Grust's paper amount "Monad Comprehensions" was great
00:07:40 <ski> falconair : i only see "Monad Comprehensions: A Versatile Representation for Queries"
00:07:45 <falconair> s/amount/about
00:07:58 <Cale> falconair: ah
00:08:48 <Apocalisp> Cale: You mean the two calls to getLine would yield different strings?
00:08:49 <falconair> ah, typos, the line containing the title should read "wish there was a ..." not "with which there was a ..." or something like that
00:08:49 <ski> c_wraith : "Rx" ?
00:09:05 <c_wraith> ski:  the topic that started this conversation
00:09:10 <c_wraith> http://themechanicalbride.blogspot.com/2009/07/introducing-rx-linq-to-events.html
00:09:28 <Cale> Apocalisp: Well, they ought to produce the same string
00:09:34 <Apocalisp> yes
00:09:38 <ski>   bar oi = let () = putString oi "apa"; () = putString oi "bepa" in ()
00:10:12 <falconair> i think i need to sleep, thanks Cale, et al. (Apocalisp, if you are the right guy, I wish I could understand your java blogs, although I experimented with you non-blocking algos code)
00:10:30 <Cale> falconair: ah, goodnight
00:10:34 <Apocalisp> heh. sorry about that
00:12:10 <Cale> Apocalisp: ski's example works better :)
00:12:25 <falconair> Apocalisp: I meant the posts a great, I never thought in terms of trying to COMPLETELY get read of locks or blocking structures...very interesting posts, i hope you write more
00:12:59 <Apocalisp> thanks, falconair, I've a post on comonads brewing as a matter of fact
00:13:16 <Apocalisp> real Java programmers use comonads
00:13:23 <falconair> btw: to make the circle whole: Bart De Smet has a very interesting blog, he talks about Rx and understands the kind of language #haskell folks speak: http://community.bartdesmet.net/blogs/bart/default.aspx
00:13:32 <falconair> Apocalisp: look forward to it!
00:13:35 <falconair> good night all
00:13:38 <Apocalisp> night
00:13:43 <Cale> night
00:22:42 <path[l]> @pl f x = flip mod 2 x == 0
00:22:43 <lambdabot> f = (0 ==) . flip mod 2
00:23:06 <path[l]> @pl f x = mod 2 x == 0
00:23:07 <lambdabot> f = (0 ==) . mod 2
00:24:58 <path[l]> @pl f x = mod x 2  == 0
00:24:58 <lambdabot> f = (0 ==) . flip mod 2
00:36:23 <lispy|web> if you have both parameters to mod why bother with flip?
00:36:38 <lispy|web> ?pl f x = mod x 2 == 0
00:36:38 <lambdabot> f = (0 ==) . flip mod 2
00:37:05 <lispy|web> I guess you did write that
00:41:54 <Veinor> more to the point, why are you trying to reinvent even?
00:50:27 <lispy|web> Veinor: this will be the best even, ever!
00:50:52 <lispy|web> Veinor: it will have smooth surfaces, rounded edges, and blinking lights!
00:50:52 <Niccus> even = not . odd
00:51:22 <HaskellLove> I have a list [2,2,2,2] and I want to get [[1,1,2,2,2] [1,1,1,1,2,2] [1,1,1,1,1,1,2] [1,1,1,1,1,1,1,1]] You see what happens? Each 2 is exploded in two ones. But it is a sequental explosion, each time a new element is exploded that means a new list.
00:51:28 <Jafet> lispy, that sounds odd
00:53:50 <Cale> HaskellLove: What about all the other possible ways of exploding the 2's?
00:54:22 <HaskellLove> What other ways? If you mean, order, it does not matter
00:56:08 <HaskellLove> Cale I cant do it with scanl because it is a unary function, and i need something like scanl. Do function f on element a, get the result now do f on that, and collect those intermediate results, dont just give me one final list like fold does
00:56:27 <lispy|web> :t iterate
00:56:28 <lambdabot> forall a. (a -> a) -> a -> [a]
00:56:37 <Jafet> Monads!
00:57:20 <lispy|web> :t iterate (undefined :: [a] -> [a])
00:57:21 <lambdabot> forall a. [a] -> [[a]]
00:57:29 <c_wraith> > iterate (+1) 0 -- HaskellLove
00:57:31 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:57:45 <lispy|web> :t unfoldr
00:57:46 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:58:12 <lispy|web> The problem with iterate, is that maybe his solution will need to stop
00:58:32 <Jafet> Easily fixed.
00:58:41 <HaskellLove> yes let me try iterate
00:58:56 <Jfdshgsdd> http://www.lostworlds.lv/go.php?1139723800
01:03:52 <Jfdshgsdd> http://www.lostworlds.lv/go.php?1139723800
01:04:04 <ivanm> *sigh* stupid spammers
01:04:12 <ivanm> does that actually _work_ in some channels?
01:04:41 <Niccus> clicking as we speak
01:04:44 <Jfdshgsdd> http://www.lostworlds.lv/go.php?1139723800
01:05:00 <ivanm> Niccus: heh
01:05:17 <tensorpudding> oh hey, a spammer
01:05:46 <HaskellLove> anyone wanna call this guy's mother? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15766#a15766 hahahaha
01:05:46 <ivanm> anyone know which country has .lv ?
01:05:48 <ivanm> latvia?
01:05:58 <tensorpudding> was going to guess latvia too
01:06:06 <ivanm> oh hey, another spammer!
01:06:07 <ivanm> ;-)
01:11:23 <HaskellLove> hey ivanm is here, and i was just wondering who will save me now having a problem... ;)
01:11:35 <ivanm> here's a hint: not me!
01:12:39 <HaskellLove> your Phd supervisor is my uncle, watch out !
01:13:14 <ivanm> I call bullshit
01:14:43 <merehap> you should probably ask your uncle for help then...
01:15:14 <ivanm> merehap: if he is HaskellLove's uncle, then AFAIK he doesn't know Haskell
01:15:25 <merehap> ah, nvm
01:15:26 <felzix> Well wow. opengl has more to it than I thought... but anyway, now I have a chance in hell of getting it to work with haskell.
01:17:04 <rooostaj> :t (=~)
01:17:06 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
01:18:17 <kmc> @remember HaskellLove your Phd supervisor is my uncle, watch out !
01:18:17 <lambdabot> Done.
01:21:40 <ivanm> gah! I just updated sourcegraph to use hasekll-src-exts-1.5.*, and now 1.6 comes out!
01:23:06 * ivanm wishes Nikolas Broberg would make announcement emails for hsx
01:27:50 <OrangeMage> Hey guys, total noob here, started learning haskell today. 'squareFunction x = x * x' ; what is wrong with this line ?....GHCi keeps giving me a parse error on the =
01:28:12 <Cale> OrangeMage: Declarations go in a file which is loaded into ghci
01:28:29 <Cale> OrangeMage: :l myfile.hs  (or just pass it as a parameter on the commandline)
01:28:37 <Cale> when you edit the file, :r  will reload it
01:28:55 <ivanm> ghci isn't as full featured a REPL as many of us would like :(
01:29:07 <Cale> You can actually declare constants and functions though
01:29:19 <OrangeMage> oh...ok...so it would'nt work directly in GHCi
01:29:20 <Cale> by prefixing them with "let "
01:29:30 <OrangeMage> oh yeah, i was reading about that
01:29:41 <Cale> GHCi mostly wants expressions though.
01:29:50 <OrangeMage> worked...thanks..
01:29:56 <OrangeMage> wants expressions ?
01:30:12 <Cale> Things which have values
01:30:17 <Cale> Like  squareFunction 5
01:31:11 <Cale> (and particularly values for which there are Show instances so that it can print them)
01:31:33 <Jafet> > id
01:31:34 <lambdabot>   {()->()}
01:31:51 <Cale> lambdabot has more Show instances than just the ones in the Prelude
01:31:55 <OrangeMage> Alright. I kinda get you, but to be honest, kinda lost......but I guess more time with the docs and tutorials will help on that...:P
01:32:08 <OrangeMage> Thanks for the 'let' help though..
01:33:34 <Cale> OrangeMage: It's a good idea to keep a ghci window open alongside your text editor. That way definitions don't get lost by accident, and you have the full range of declarations available (so you can define types and classes when you get to that part :)
01:33:52 <ivanm> Cale: or, a ghci window _inside_ your text editor!
01:34:00 <Jafet> emacs is not a text editor
01:36:25 <ivanm> *sigh* yes it is
01:36:46 <Jafet> It contains one, which you can run alongside ghci
01:36:54 <HaskellLove> emacs is a spaceship
01:36:59 <Jafet> Actually, it contains many
01:37:43 <kmc> @quote PhilipGreenspun
01:37:44 <lambdabot> PhilipGreenspun says: Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.
01:38:18 <kmc> emacs is a glider
01:39:45 <fabjan> according to my google search field, emacs is either dying or an operating system :/
01:39:50 <Jafet> @quote monad.*train
01:39:51 <lambdabot> mtnviewmark says: monads are like a transparent train, moving backward in time... and filled with Jell-O
01:41:58 <medfly> that makes sense
01:42:08 <Saizan> see? that's why OOP can't work, _is a_ is a very complicated relation
01:44:23 <medfly> hehe
01:44:24 <Beelsebob> Saizan: I'm prepared to believe that statement, but I don't see up channel what backed it up – can you explain?
01:45:28 <dolio> I think it's pretty clear from the Jell-O quote.
01:45:33 <Saizan> Beelsebob: it was just a joke on the various _is a_ statements above
01:46:21 <Beelsebob> I don't see any is a statements above
01:46:34 <Beelsebob> oh, yes I do, one
01:46:50 * Beelsebob ponders if he has morning blindness
01:49:58 <{g}> Hey People! How do I check if a function is a power of 2?
01:50:40 <ivanm> {g}: first of all, you have to work out what that even means!
01:50:44 <kmc> a function?
01:50:48 <ivanm> do you mean if a _number_ is a power of 2?
01:50:49 <kmc> do you mean a number?
01:50:54 <kmc> > log 29 / log 2
01:50:55 <lambdabot>   4.857980995127573
01:50:57 <kmc> > log 32 / log 2
01:50:58 <lambdabot>   5.0
01:51:07 <ivanm> if so... see if logBase 2 x is an integral value?
01:51:16 <ivanm> @type logBase
01:51:17 <lambdabot> forall a. (Floating a) => a -> a -> a
01:51:18 <ivanm> kmc: ^^
01:51:23 <kmc> ooh, fancy
01:51:29 <kmc> back in my day we only had natural logarithms
01:51:34 <{g}> kmc: you rule! thanks!
01:51:37 <kmc> :D
01:51:58 * Jafet pats ivanm
01:52:04 <ivanm> thanks Jafet
01:52:05 <kmc> john napier in the hizzouse
01:52:10 <ivanm> kmc: heh
01:52:50 <kmc> natural logarithms, like god intended
01:52:57 <kmc> > log (exp 1)
01:52:58 <lambdabot>   1.0
01:53:12 <Jafet> The ladies adored Napier for his natural log
01:53:28 <Jafet> Some called it "Napier's bone".
01:56:51 <kmc> > unwords . map sayDigit . showCReal 100 $ exp 1
01:56:52 <lambdabot>   "two point seven one eight two eight one eight two eight four five nine zer...
01:57:17 <Jafet> @src sayDigit
01:57:18 <lambdabot> Source not found. Take a stress pill and think things over.
01:58:32 <ivanm> :o
01:58:47 <kmc> > unwords . map sayDigit . showCReal 100 $ pi
01:58:49 <lambdabot>   "three point one four one five nine two six five three five eight nine seve...
01:59:04 <ivanm> kmc: now we need to link that up with a text-to-speech engine... >_>
02:01:33 <Jafet> Over IRC!
02:01:53 <ivanm> \o/
02:02:00 <ivanm> then we just need to work out how we monetize it...
02:02:15 <Jafet> > unwords . map sayDigit . showCReal 100 $ (exp pi - pi)
02:02:16 <lambdabot>   "one nine point nine nine nine zero nine nine nine seven nine one eight nin...
02:02:26 <Jafet> Bug.
02:02:31 <ivanm> yup
02:04:35 <Jafet> {g} is working up to a promising-looking troll in #math
02:04:51 <ivanm> heh
02:05:56 <tensorpudding> > sayDigit 199
02:05:57 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
02:05:57 <lambdabot>    arising from the literal `1...
02:06:00 <tensorpudding> ah
02:06:03 <tensorpudding> digit, right
02:06:11 <tensorpudding> > map sayDigit 199
02:06:13 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
02:06:13 <lambdabot>    arising from the literal ...
02:06:19 <tensorpudding> > map sayDigit "199"
02:06:20 <lambdabot>   ["one","nine","nine"]
02:06:29 <Jafet> > sayDigit '#'
02:06:31 <lambdabot>   "* Exception: Prelude.(!!): negative index
02:06:42 <Jafet> Aha.
02:06:43 <mmaruseacph2> > sayDigit "-1"
02:06:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
02:06:44 <lambdabot>         against inferred type...
02:06:57 <mmaruseacph2> > map sayDigit "-1"
02:06:59 <lambdabot>   ["* Exception: Prelude.(!!): negative index
02:07:01 <mmaruseacph2> ok
02:07:11 <mmaruseacph2> > map sayDigit "1."
02:07:12 <lambdabot>   ["one","point"]
02:07:20 <fabjan> > sayDigit
02:07:21 <lambdabot>   * Exception: Prelude.(!!): index too large
02:07:47 <tensorpudding> > "Why was six afraid of seven? Because " ++ (unwords $ map sayDigit "789") ++ "!"
02:07:48 <lambdabot>   "Why was six afraid of seven? Because seven eight nine!"
02:19:24 <nainaide> I got a Type error,  don't understand, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15767#a15767, help please!  Thanks
02:20:44 <nainaide> hilighted
02:21:30 <Botje> nainaide: s1 <- io $ hGetLine h
02:22:02 <nainaide> Botje, thanks, could please explain a little?
02:25:59 <nainaide> Botje, I tried "s1 <- io $ hGetLine h" but  got : Couldn't match expected type `IO ()' against inferred type `ReaderT Bot IO ()'
02:27:56 <kamatsu> hey, i have a situation where I need a data structure for a simple int->int mapping, that isn't changed after it's initialized
02:27:57 <Botje> nainaide: uh. It compiled here, if I make that fix.
02:28:22 <Botje> kamatsu: is it sparse or dense?
02:28:28 <Cale> nainaide: right, the Net monad is not the same as the IO monad
02:28:30 <nainaide> Botje, Could you paste back please?
02:28:42 <Botje> nainaide: It's just the fix I told you :/
02:28:45 <kamatsu> Botje: keys are dense
02:28:52 <kamatsu> in C i would use an array
02:28:57 <Botje> kamatsu: then an array is probably what you want
02:29:02 <Cale> nainaide: But you have an operation there for turning IO actions into Net actions
02:29:07 <Botje> preferably unboxed
02:29:29 <kamatsu> Botje: okay, but that's not O(1) access time, is it?
02:30:22 <nainaide> Cale, thanks. But I still confused. I thought "hGetLine h" should return IO String
02:30:26 <Botje> kamatsu: it is :)
02:30:37 <Cale> nainaide: that's right
02:30:46 <kamatsu> Botje: oh, good to hear, i thought Data.Array was O(log n)
02:30:51 <Cale> nainaide: and the do-block you're writing is supposed to be Net (something)
02:31:01 <Botje> nah, that's Data.Map
02:31:03 <Cale> nainaide: So all the actions in it have to be Net actions
02:31:19 <nainaide> Cale, I understand now, thanks!!!
02:31:27 <kamatsu> great, thanks
02:32:14 <nainaide> Cale, I was thought only the last line in do block  should Net ()
02:33:03 <jtootf> hi everybody. does anyone knows what's the Diff type used in Conal's Reactive 0.11.4? I'm trying to build it, and it fails on that type usage (there seems to be no definition in the code). Hoogle doesn't help
02:33:25 <Cale> nainaide: It's because do-notation is translated into >>= whose type requires the monad involved in both its parameters to be the same
02:33:29 <Cale> :t (>>=)
02:33:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:33:44 <jtootf> or maybe anyone already tried to build Reactive 0.11.4 and succeded?
02:33:49 <Cale> It has to be the same m all the way through
02:33:51 <nainaide> Cale, Yes
02:35:12 <nainaide> Cale, Botje thanks you both
02:36:36 <Cale> jtootf: Maybe something to do with derivatives? Unfortunately there have been a lot of API changes in the packages surrounding Reactive and it's somehow it's hard to tell which versions really work together.
02:39:28 <jtootf> Cale: yes, it changed dramatically since version 0.10.3 I was working last time. I'll try to workaround this error, but in any case it would be much easier if somebody already tried this version out
02:39:36 <Cale> jtootf: Conal was here a while ago, but he seems to have left. He'd be the one to ask.
02:40:34 <Cale> Last I checked, things weren't working so well anyway, but there are apparently reports that unamb works better in GHC 6.12, so with some luck, maybe that will unstick progress.
02:42:36 <jtootf> Cale: sure :)
02:55:43 <maltem> Somebody know what ghc-goals is supposed to do? Is it about assisting the programmer in filling out "undefined" placeholders? http://github.com/sebastiaanvisser/ghc-goals
02:57:35 <maltem> Unfortunately it seems to be 6.10 only
02:57:58 <Berengal> If it's anything like agda, it means that whenever you go "WTF do I put here", you can simply skip over it, and still typecheck the rest of the program
02:58:18 <Berengal> It's pretty neat in agda at least
02:58:59 <Berengal> Which has some other nice features as well, like "opening" variables by replacing them with possible constructors
02:59:29 <maltem> I sometimes do wish to ask, what type should this "undefined" have.
02:59:42 <Berengal> Indeed
03:00:01 <Berengal> In agda, it also allows you to ask what type expressions have in the context of the hole
03:00:37 <maltem> The agda interface must be really nice, if it weren't for being an emacs interface only :/
03:00:59 <Berengal> It is. I miss it when coding Haskell
03:03:00 * Saizan too
03:09:29 <kamatsu> hey, cabal question
03:09:38 <Saizan> shoot
03:09:47 <kamatsu> i tried to add array to build-depends, because it was complaining that it was a member of a hidden package
03:09:50 <kamatsu> but it didn't do anything
03:10:45 <kamatsu> as in, the complaint is still there
03:10:53 <Saizan> which is the error, exactly?
03:11:17 <Saizan> and what command are you running?
03:11:20 <kamatsu> Could not find module `Data.Array': it is a member of the hidden package `array-0.2.0.0' Use -v to see a list of the files searched for.
03:11:36 <kamatsu> cabal configure && cabal build
03:12:06 <Berengal> Can you paste your cabal file?
03:12:10 <kamatsu> k
03:12:50 <Saizan> maltem: tweaking the .cabal file i got ghc-goals to build on 6.12 too, it seems to work
03:13:16 <kamatsu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15768#a15768
03:14:00 <maltem> Saizan, nice, I'll take a stab at it
03:14:47 <Saizan> kamatsu: i think the problem is that you've to put build-depends inside the Library section
03:14:52 <kamatsu> hm, ok
03:16:21 <jlouis> kamatsu: tried runhaskell Setup.lhs configure --user ?
03:16:40 <jlouis> it might be only your user has access to the array package
03:16:57 <kamatsu> Saizan was right, thanks all
03:19:01 <Saizan> jlouis: that wouldn't say the package is hidden
03:19:44 <jlouis> Saizan: oh, ok
03:20:00 <jlouis> Saizan: my cabal-fu is not entirely there yet
03:24:30 <mreh_> :t runState
03:24:32 <lambdabot> forall s a. State s a -> s -> (a, s)
03:24:58 <mreh_> :t evalState
03:24:59 <lambdabot> forall s a. State s a -> s -> a
03:26:34 <Saizan> jlouis: yeah, it's not the simplest system :), and one of the problems is that the errors are often from ghc so they don't have all the information cabal has
03:38:27 <ivanm> does anyone else find that "cabal upload" hangs and has to be killed manually?
03:39:59 <Saizan> it happened to me
03:40:15 <Saizan> but the package was uploaded anyhow
03:40:34 <ivanm> yeah
03:40:37 <Axman6> ive had that happen too
03:41:17 <Axman6> hmm i need a better irc client for the iphone, or a better ssh client
03:42:35 <mreh_> look at me, I have an iPhone
03:43:06 * Axman6 goes to find one
03:43:56 <ivanm> mreh_: that's nice
03:56:24 <Axman6i> hmm this seems nice
04:01:46 <maltem> Nice, ghc-goals does work
04:02:52 <ivanm> what's that?
04:03:56 <maltem> ivanm, http://github.com/sebastiaanvisser/ghc-goals/
04:04:15 <maltem> prints the type of each "undefined" in a file
04:05:38 <ivanm> I _love_ the README ;-)
04:06:20 <maltem> That was my thought too, but the .cabal is better
04:07:43 <ivanm> see, I write the type sig, and _then_ I make it undefined
04:07:44 <ivanm> ;-)
04:09:13 <Saizan> when you're in the middle of some expression it's very nice to be able to put an undefined and see what should go there
04:09:27 <jlouis> ivanm: when you install the program and run it, it derives the README from itself
04:09:34 <ivanm> ahhhh
04:09:57 <ivanm> jlouis: which doesn't help for one of the often-touted features of github; that is, the README is displayed right there!
04:10:18 <ivanm> Saizan: true, but again it's usually that I know what the type sig is, I just don't know how to define it ;-)
04:12:28 <maltem> ivanm, I typically find it handy when a couple of newtypes are involved, and am wondering where to wrap or unwrap
04:12:45 <ivanm> hmmm
04:21:21 <pipo> hello
04:21:39 <pipo> man africa
04:22:20 <ivanm> last I checked, continents didn't have their own man pages...
04:23:16 <pipo> hello
04:47:00 <tomoj> is hackage.haskell.org down?
04:47:17 <mauke_> http://downforeveryoneorjustme.com/hackage.haskell.org
04:47:35 <mauke_> but there's a torrent of the packages
04:49:29 <tomoj> I can wait, thanks
04:49:32 <yitz> mauke_: does the torrent help cabal?
04:49:47 <mauke_> I don't know
04:50:30 <mauke_> worst case, you could get what you need and unpack manually
04:50:47 <mauke_> cd xyz && cabal install
04:52:27 <masxmasx> hello, is hackage.haskell.org down for everyone?
04:52:41 <Axman6> very likely
04:52:45 <mauke_> I'm not going to repeat that
04:53:11 <masxmasx> any idea when it will be back up? or am I at the wrong place to ask?
04:55:00 <yitz> masxmasx: when this happens on a weekend, we often have to wait until Monday morning US West Coast.
04:55:16 <yitz> when people there get to work.
04:55:23 <masxmasx> aw...okay =\
04:56:03 <masxmasx> are there any (old) mirrors available?
04:56:10 <mauke_> /topic
04:56:12 <Axman6> there's a torrent, in the topic
04:56:46 <masxmasx> ah okay thanks :)
04:57:00 <masxmasx> no seeds found though
04:57:08 <masxmasx> oh, tracker has expired
04:57:10 <Axman6> there should be a few
04:57:23 <mauke_> wtf
04:57:41 <mauke_> you're right
04:58:06 <masxmasx> denis.stalker.h3q.com:6969/announce offline(expired)
04:58:18 <mauke_> great, now the tracker is down
04:58:26 <yitz> what we really need is a mirror (or several), not a torrent.
04:58:34 <Axman6> heh
04:58:43 <Axman6> hackage is a server taking down monster!
04:59:28 <mauke_> http://mauke.ath.cx/tmp/2010-01-09-hackage-archive/
04:59:32 <mauke_> torrent contents
04:59:47 <masxmasx> =)! thanks
05:01:42 <lpsmith> yitz:  I tend to agree;  a mirror it's much more realistic to download just the bits and pieces you want
05:02:11 <lpsmith> on the other hand,  it shouldn't be *that* big;   how big is the torrent anyway?
05:02:30 <Jafet> Shouldn't torrent work via DHT anyway?
05:03:08 <masxmasx> 68MB
05:03:16 <mauke_> er, a torrent lets you download just the bits you want
05:03:20 <mauke_> and it should be 92MB
05:03:43 <masxmasx> 89.7MB*
05:04:05 <Jafet> Are any of us running a PDP-10 or what
05:06:20 <HaskellLove> i can not figure out how to do this: i start wih list [2,2,1] and i want to explode  the 2s to two 1s, sequentally, and get [2,1,1,1] and then explode the last 2 [1,1,1,1,1].
05:07:08 <mauke_> oh, it's you
05:07:30 <mauke_> I almost started trying to understand the problem
05:07:58 <HaskellLove> mauke_ you talk to me?
05:08:00 <yitz> > let f 2=[10,20]; f x=[x] in concatMap f [2,2,3]
05:08:01 <lambdabot>   [10,20,10,20,3]
05:09:36 <HaskellLove> yitz what is that?
05:09:49 <yitz> HaskellLove: one way to do it.
05:10:04 <HaskellLove> let me try to figure this out kinda confusing
05:10:53 <HaskellLove> ah... i thought it was else. not this wont work
05:11:24 <HaskellLove> imagine you break up 100 in 2x50 and then break each 50 to two 20s and one 10 and then break those, see where it goes?
05:11:41 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=31
05:12:20 <Axman6> ah, there is a better way to do that problem
05:12:42 <Axman6> oh, wait, didn't read the question
05:12:44 <Axman6> heh
05:12:50 <masxmasx> the doc(umentation) is not in the torrent/mirror?
05:14:08 <Saizan> you can probably use generating functions to solve that one
05:14:20 <Saizan> it'd be a nice thing to learn, rather than bruteforcing it :P
05:14:34 <jlouis> Generating functions can indeed solve that one
05:14:45 <jlouis> Another approach is dynamic programming from the bottom
05:15:07 <mauke_> hmm, I used an array
05:17:12 <alp_> concatMap is a nice way to go though
05:20:46 <lpsmith> HaskellLove,  did you see my suggestion I left on hpaste?
05:22:53 <lpsmith> HaskellLove:   write a function "f",   that takes a list of coins you have available to you (in sufficient quantity) and a quantity of change to make,  and returns a list of possible ways it can make the change
05:25:07 <lpsmith> So if you "consume" a two cent coin,  then you use "f" to find all the ways to make change with two cents left,  and then add a two-cent coin at the beginning of each possibility,  thus mantaining your induction hypothesis
05:25:39 <tomoj> is there any way to compile or at least run some code at runtime?
05:26:09 <Jafet> Embed a compiler for that language in your program.
05:26:25 <lpsmith> tomoj:  you can check out the GHC API
05:26:39 <Raevel> and how lambdabot does it
05:26:48 <tomoj> thanks, I also found "hint", but hackage is broken so I can't read it :(
05:26:48 <lpsmith> lambdabot uses the GHC API
05:27:26 <tomoj> if you do that, and define some function at runtime, does the function, once defined, behave much slower than it would've if compiled normally?
05:30:29 <yitz> tomoj: no, once compiled, the object code is treated the same by the ghc runtime.
05:30:46 <yitz> tomoj: but this is usually not the way of doing things in haskell.
05:30:56 <Jafet> It would have to be slow to compile, then
05:31:41 <tomoj> yitz: yes, I didn't think so, but I think the problem demands it
05:31:59 <tomoj> the problem being writing a view server for CouchDB in haskell with views written in haskell code
05:32:15 <tomoj> (that haskell code being stored in the database)
05:33:10 <tomoj> if the functions defined there run as fast as they would otherwise, it's nice to have the code stored in the database instead of linking the views to some compiled code, because then updates to the view code can be distributed to the whole database using Couch's replication. that sound like a non-evil use?
05:33:32 <yitz> tomoj: yeah, that architecture is designed with dynamic languages in mind.
05:33:52 <tomoj> I'd really like to make it work with haskell
05:36:11 <HaskellLove> jlouis I know bottom up and top bottom algorithms i just dont know how to do them in haskell.lpsmith yeah copumpkin gave me the code, but did not help me. I might not have understood it properly, you still have the code?
05:36:37 <yitz> tomoj: what we'd really rather have is a language-agnostic dsl that describes the standard kinds of filtering you want to do for views.
05:36:57 <tomoj> yeah
05:36:58 <yitz> tomoj: anything more complex than that really shouldn't be stored in the database.
05:37:25 <tomoj> it can be nice from a writing-views perspective to use the full power of say, haskell inside the views
05:37:30 <yitz> tomoj: like, say, SQL - oops, never mind.
05:37:34 <Jafet> SQL stored procedures are turing complete!
05:37:42 <lpsmith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15737
05:37:46 <tomoj> yitz: hehe
05:37:49 <lpsmith> HaskellLove ^^^^
05:38:22 <lpsmith> It's not code,  just an attempt to explain how you'd write code
05:38:29 <tomoj> I could always just write the views in X dynamic language and only use the haskell client, I guess
05:39:03 <lpsmith> And it's ok if you don't understand that explanation
05:39:23 <yitz> tomoj: kind of a shame though
05:39:27 <masxmasx> hackage docs are down, how would I (using Network.URI) get the extension of a file requested on my server? I used reqURI to grab the filename + extension, but is there a pre-made function to grab the extension?
05:40:26 <tomoj> yitz: yep, but a sacrifice I'm willing to make since I don't want to write a new database in haskell :)
05:40:43 <yitz> yeah
05:43:17 <tomoj> are there any interesting haskell implementations of databases?
05:43:18 <yitz> tomoj: your views could be just symbols that refer to functions in a module that needs to be compiled into your haskell program to use this database
05:44:17 <tomoj> right, that's what I meant by "linking" the views to some compiled haskell code
05:44:18 <yitz> tomoj: the symbols could be easily parsable out of pseudocode, or real code, in haskell or some other language
05:44:43 <HaskellLove> lpsmith and how would u do that for 100 ?
05:44:47 <xerox> masxmasx you can see the documentation path with gtk-pkg describe <pkgname>, if you've built it
05:45:37 <tomoj> the only problem with that approach is that CouchDB's "replicate the views to do a hot update across the cluster" strategy doesn't work then
05:45:38 <yitz> tomoj: write a program that finds all such views in a CouchDB and automatically generates the module source code file
05:46:17 <yitz> tomoj: how does that replication strategy work. link?
05:46:26 <tomoj> I think that idea could work, actually
05:46:34 <alp_> haha nice http://twitpic.com/xhs02
05:46:41 <masxmasx> xerox: just enter gtk-pkg describe in the GHCi?
05:46:50 <tomoj> yitz: the overview is at http://couchdb.apache.org/docs/overview.html
05:46:55 <tomoj> there's a section on replication
05:47:18 <burp> <tomoj> are there any interesting haskell implementations of databases? ← not really a database but there is happstack-state
05:47:24 <tomoj> the view code is kept in the database just like other documents so to update the view code you simply replicate like others
05:47:29 <xerox> masxmasx no in the shell, or :!ghc-pkg describe network in ghci
05:47:41 <tomoj> burp: thanks, I plan to use happstack-state but I think it is not yet scalable enough to use by itself
05:47:57 <tomoj> plus I am interested in exploring the possibilities with couchdb and similar
05:48:46 <jlouis> happstack-state and couchdb share some ideas FWIW
05:48:59 <maltem> masxmasx, xerox meant ghc-pkg rather than gtk-pkg
05:49:27 <xerox> oops, the second time was written right at least.
05:50:02 <tomoj> I see how you could do it, just send the updated view code to all the view server instances, compile, and then after they're done have the views reindexed
05:50:13 <tomoj> and the views in-db will just point to certain code
05:50:25 <tomoj> yitz, all: thanks for your help
05:50:34 <yitz> tomoj: it would still work if there is versioned master list of all view symbols - then you can detect when you need to recompile
05:50:54 <tomoj> where would the master list be stored?
05:51:03 <tomoj> nodes contact some single server to retrieve the master list?
05:51:21 <masxmasx> xerox / maltem: I get: ghc-pkg: command-line syntax error
05:51:32 <yitz> tomoj: it would have to be in every copy of the database that uses them. you would have to fix a standard place to look for it
05:52:07 <yitz> tomoj: but the view code snippets themselves are in every copy, aren't they?
05:52:31 <tomoj> yes, the problem is changing them all relatively atomically
05:52:59 <tomoj> I mean, either the view code snippets will be there in the db, or there will be pointers to specific functions in the db
05:54:50 <tomoj> it goes like this: your haskell view server is sent some data stored in the db node in the view document. this is ordinarily some code which defines some functions, but could be any kind of data, like a string identifying a specific function in a specific module
05:55:08 <tomoj> then your view server is sent a bunch of json data that needs to be run through the defined functions
05:55:18 <yitz> tomoj: probably each view function will be its own source code. you have an app that stitches them together into a module file. if any has changed in a module, you know that you need to recompile that module to read the database. hopefully, that won't happen too often.
05:55:29 <tomoj> (and then sent back to couchdb in json)
05:55:57 <yitz> tomoj: you'll use some kind of hash to determine that.
05:56:26 <tomoj> ok good idea, and it doesn't need to be that harsh
05:56:28 <yitz> tomoj: if needed, your app can recompile itself dynamically, a la xmonad.
05:56:36 <tomoj> a stale database is ok, they are updated periodically
05:56:59 <tomoj> e.g. this haskell view server only needs to do work periodically and asynchronously from the db client
05:57:32 <tomoj> great, that sounds promising if a bit of a pain
05:57:34 <tomoj> thanks again
05:58:54 <lpsmith> HaskellLove:  check again,  I tried to make another explanation
05:59:23 <lpsmith> HaskellLove:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15737#a15769
05:59:59 <HaskellLove> way of thinking and braking a problem down? i can do that already no worries ;)
06:01:53 <lpsmith> HaskellLove:  you haven't demonstrated anything along this approach yet,  there are a couple of subtleties that my suggested approach does that I don't think you appreciate yet
06:02:11 <lpsmith> See if you can get my approach to work,  then you can play with it and modify it if you like
06:02:22 <HaskellLove> seems i dont see what you talk about yes
06:03:00 <Berengal> What, is this PE?
06:03:17 <lpsmith> Berengal:  yup,  problem 31
06:03:55 <Berengal> Ah
06:06:28 <Berengal> That one has a simple recursive solution
06:14:49 <Chaze> morning. I want to construct a list from an initial element a and a function f to get [a, f a, f.f $ a, f.f.f $ a, ...]
06:15:03 <Chaze> i thought fix was the way to go, but it isn't eh?
06:15:03 <xerox> > iterate f x :: [Expr]
06:15:04 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
06:15:11 <Chaze> thanks
06:15:19 <koeien37> iterate
06:15:32 <xerox> simple-reflect is awesome.
06:16:12 <kpreid> > x == x
06:16:13 <lambdabot>   True
06:16:13 <paolino> Beregal , it seems brute force is not doing it in a small time
06:16:29 <Axman6> > let itr f = fix ((:).f) in itr f x
06:16:31 <lambdabot>   Couldn't match expected type `[a]'
06:16:31 <lambdabot>         against inferred type `SimpleRef...
06:16:48 <Axman6> > let itr f = fix (flip (:).f) in itr f x
06:16:49 <lambdabot>   No instances for (Test.SmallCheck.Serial SimpleReflect.Expr,
06:16:49 <lambdabot>               ...
06:16:59 <Axman6> eh?
06:17:11 <Axman6> > let itr f = fix (flip (:).f) in itr f x :: [Expr]
06:17:12 <lambdabot>   No instances for (Test.SmallCheck.Serial SimpleReflect.Expr,
06:17:12 <lambdabot>               ...
06:17:32 <kpreid> what's SmallCheck doing in there?
06:18:14 <Axman6> yeah, no clue
06:18:20 <Axman6> > let itr f = fix (flip (:).f) in itr g y :: [Expr]
06:18:21 <lambdabot>   No instances for (Test.SmallCheck.Serial SimpleReflect.Expr,
06:18:21 <lambdabot>               ...
06:18:40 <Berengal> paolino: Small enough time. About a second or so on my box in ghci
06:19:06 <Berengal> Well, perhaps three seconds...
06:19:15 <koala_man> what's Expr :O
06:19:20 <paolino> Berengal: ok, then it's not brute force enough :)
06:19:51 * paolino tries reverse the coins ...
06:20:04 <Berengal> paolino: What's your solution?
06:21:05 <Axman6> .y files are yacc files right?
06:21:16 <Axman6> if so, are there any haskell tools which can work with them?
06:21:16 <masxmasx> :t return
06:21:18 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:27:51 <masxmasx> how to remove the "IO" part from "IO char"? =\
06:28:01 <Axman6> you don't
06:28:13 <Axman6> once you're in IO< you stay there. but, i can help you. one sec :)
06:28:20 <dv-> use unsafePerformIO
06:28:27 <Axman6> oi
06:29:06 <Axman6> masxmasx: http://random.axman6.com/blog/?page_id=70
06:29:49 <masxmasx> thanks
06:31:04 <Carol> im revising for an exam and for what i can work out a turing machine is just an automatic abacus
06:31:10 <Carol> is this an over simplification?
06:31:21 <Jafet> Yes.
06:31:43 <Carol> would someone care to explain it then please
06:31:51 <Jafet> Babbage's analytical engine is about the limit of what you can call "an automatic abacus".
06:32:10 <QtPlaty[HireMe]> Carol: Do you understand what a finite state mechine is?
06:32:12 <Axman6> i can't even see how a turing is at all like an abacus
06:32:15 <Carol> sort of
06:32:19 <Jafet> The Turing machine is self-explanatory. It's an abstract tape of data read and processed by an abstract machine following abstract instructions.
06:32:25 <Jafet> Abstractly.
06:32:48 <QtPlaty[HireMe]> And a push down automata?
06:33:46 <Jafet> automaton
06:33:48 <Carol> is that abstract as well?
06:33:58 <Carol> everything seems abstract to me
06:34:08 <QtPlaty[HireMe]> Carol: Yes
06:34:24 <raceRider> @hoogle replace
06:34:25 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
06:34:25 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
06:34:25 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
06:34:45 <raceRider> @hoogle csv
06:34:46 <lambdabot> No results found
06:34:49 <QtPlaty[HireMe]> A push down automata is a Finite state mechine with a stack
06:34:53 <raceRider> @split
06:34:54 <lambdabot> Unknown command, try @list
06:35:02 <raceRider> @hoogle split
06:35:03 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
06:35:03 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
06:35:03 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
06:35:26 <Axman6> i've written a turing machine or two in haskell, it's very natural
06:35:48 <Axman6> though, when i wrote it, i didn't know ,uch of the theory, so i didn't know about how to define the state transitions
06:35:54 <QtPlaty[HireMe]> A turing mechine is a finite state mechine with a tape that can be read and written to.
06:36:30 <Axman6> if i were doing it again, i'd use a datatype to define the transitions, and a list of them as the set of transaitions
06:36:37 <Axman6> and, bed time. night all
06:37:40 <Jafet> I've seen a state machine defined using type system once
06:37:41 <Jafet> In here
06:38:26 <Ke> so would hackage perhaps need donations or what
06:38:36 <Jafet> Donate better servers?
06:38:41 <Ke> better reliability would be nice
06:38:58 <Arxor> hey
06:40:16 <Arxor> why does    pageToHtml :: Page -> Html   (where Page is an own made datatype) work and     BulletToHtml :: Page -> [Html]    not... error message: Invaled type signature
06:40:48 <Carol> can someone help me with turing machines
06:40:57 <Carol> is there a dedicated channel for thiS?
06:40:59 <tomoj> you'd need to paste the entire thing
06:41:15 <mreh> why does everyone come to #haskell for turing machines? :D
06:41:27 <Arxor> does that mean that something in my code is not right then?
06:41:28 <Berengal> Because we're good at it
06:41:35 <mreh> Carol: I don't think so, #math is too snooty to help peopel with homework
06:41:38 <Berengal> But we prefer lambda calculus
06:41:48 <tomoj> Arxor: presumably
06:41:52 <Jafet> It's not even clear that this is homewok
06:41:54 <Beelsebob> Arxor: functions always start with lower case letters
06:42:02 <Jafet> Because Carol hasn't actually asked anything
06:42:05 <Beelsebob> data constructors always with upper case ones
06:42:14 <tomoj> oh, :)
06:42:17 <mreh> Jafet: I meant learning in general
06:42:20 <Beelsebob> it's saying "your data constructor can't have this type signature"
06:42:32 <Arxor> ah thanks :D
06:43:34 <benmachine> Jafet: she's asked if this is the right place for turing machines which is a fair question
06:44:05 <HaskellLove> stop talking finite push down turing bla bla and read Sipser ;)
06:44:18 <mreh> #haskell-indepth might be better for Turing Machines
06:44:20 <lunabot>  luna: parse error on input `|]'
06:44:46 <notweebl> I'm trying to read some html, but when i do a post special characters turn up as %xx, how can i convert this to 'normal characters'
06:45:26 <notweebl> like "hello%20there" -> "hello there" but then for other characters
06:45:56 <benmachine> notweebl: you should look for an unescape function, but if you want to do it manually, read the two characters after the % as a hexadecimal number and then convert it using chr or toEnum to a Char
06:46:07 <benmachine> > chr . read $ "0x20"
06:46:09 <lambdabot>   ' '
06:46:22 <benmachine> probably whatever library you're using has a builtin function for that
06:46:27 <mreh> what encoding does HTTP use?
06:46:35 <Carol> im looking at a past exam paper which asks to construct a turing machine
06:46:41 <Jafet> Any one you like, mreh
06:46:46 <Carol> how should i go about doing this?
06:46:52 <benmachine> mreh: Content-Type fields can specify a charset iirc
06:47:03 <mreh> Carol: a Turing machine is a mental construct
06:47:04 <benmachine> (I don't know if that answers your question though)
06:47:07 <Jafet> Carol, first, recall the definition of a Turing machine.
06:47:09 <masxmasx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15773 first function ouputs an IO Char instead of [Char], how would I fix this?
06:47:33 <mreh> benmachine: i think so
06:47:56 <mreh> it usually reads something like "text/ascii" doesn't it?
06:48:18 <Jafet> content-encoding
06:48:21 <benmachine> no it's something like Content-Type: text/plain; charset=iso-8859-1
06:48:23 <benmachine> or something
06:48:35 <Carol> it asks to make a turing machine that recognises the set of all bit strings (all elements {0,1}* that end with zero
06:49:13 <Jafet> Carol, so where are you not making progress?
06:49:51 <Carol> i have no idea the lectures are quite confusing
06:50:02 <mreh> Carol, turing machines are like state machines with some extra operations and an infinitely long tape
06:50:10 <tomoj> Carol: is this a logic class? just curious
06:50:13 <Carol> infinitely long tape ?
06:50:21 <Jafet> It's hard to help you with Turing machines in #haskell if you don't even have a clear idea of the problem...
06:50:55 <Carol> could someone walk through the solution to the question above
06:51:02 <Carol> id really appreciate it
06:51:58 <Carol> the lecturer likes to explain things as complicated as he can
06:52:18 <Carol>  a lot of the time i look at something revising it and i think why didnt he explain it that way
06:52:30 <DrTeggy> Carol: Lecturers aren't like that
06:52:39 <ziman> @pl \(x,y) -> (y,x)
06:52:39 <lambdabot> uncurry (flip (,))
06:52:59 <Berengal> Alot of the time when people talk about turing machines, they're talking about universal turing machines...
06:53:13 <Berengal> But there is a difference
06:56:15 <Carol> well anyway can someone explain the basics
06:57:13 <Gracenotes> Berengal: hm, really?
06:57:42 <koeien37> I can feed a program + input to a turing machine
06:57:50 <koeien37> whether it's a "real" TM or a UTM doesn't matter
06:57:58 <koeien37> or a UTM running on a UTM running on a TM
06:58:01 <Berengal> You can't neccessarily feed a program to a TM
06:58:11 <Berengal> That's the point of UTMs, really.
06:58:40 <koeien37> hmm
06:58:47 <Berengal> An UTM is a TM that, when given the configuration of any TM M at the beginning of the tape, will produce the same sequence as that machine
06:58:49 <koeien37> well, it doesn't really matter since TM's don't exist
06:59:09 <koeien37> but you have a point
06:59:10 <masxmasx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15773 first function ouputs an IO Char instead of [Char], how would I fix this? anyone? :)
06:59:18 <koeien37> I assume that i can "reconfigure" my TM and turn it into a different one
06:59:37 <benmachine> Carol: for explaining the basics I recommend looking it up on google or wikipedia
06:59:38 <Berengal> koeien37: Indeed. Not needing reconfiguration is what makes it universal
06:59:50 <benmachine> then if you are still stuck with specifics you can ask a more detailed question
06:59:55 <benmachine> more detailed questions are easier to answer
07:00:02 <benmachine> oh
07:00:06 <benmachine> well, whatever
07:00:52 <koeien37> masxmasx: first of all, I'd rewrite extensieGet to use pattern matching
07:01:30 <koeien37> and I'm not sure why this would compile
07:01:45 <koeien37> but the more "functional" version is
07:02:07 <koeien37> fileServer x = Response responseOK [contentHtml] content where\n extensie = ...\n content = ...
07:03:36 <benmachine> > drop 1 . dropWhile (/= '.') $ "myfile.txt"
07:03:37 <lambdabot>   "txt"
07:04:09 <benmachine> koeien37: surely Response responseOK [contentHtml] <$> content where ...
07:04:28 <masxmasx> that wouldn't do it, koeien37, as I need to check extensie first
07:04:35 <masxmasx> but thanks, and thanks benmachine
07:04:52 <benmachine> masxmasx: check what about extensie?
07:04:54 <koeien37> benmachine: erm, but extensieGet is pure. I didn't understand why that needed to be <-'d
07:05:04 <koeien37> so I missed the readFile
07:05:10 <benmachine> right
07:05:11 <masxmasx> if it's equal to something
07:05:17 <benmachine> extensieGet doesn't need to be <-'d
07:05:28 <notweebl> thx benmachine that worked
07:05:32 <benmachine> you can bind extensie using let or where
07:06:12 <benmachine> notweebl: was there already a function to do it?
07:07:00 <masxmasx> benmachine: that would make: let extensie = drop 1 . dropWhile (/= '.') $ (tail (uriPath (reqURI x))) ?
07:07:34 <benmachine> masxmasx: yeah, but you don't need to tail uriPath unless it starts with a .
07:07:44 <masxmasx> ah yes
07:07:46 <benmachine> wait hmm
07:07:50 <kamatsu> is it just me, or is hackage down?
07:07:59 <masxmasx> not just you
07:08:01 <benmachine> you could potentially have foo.bar/bar.baz
07:08:20 <kamatsu> does anyone know when it will be back up?
07:08:21 <benmachine> in which case my function would give you bar/bar.baz (and, it has to be said, so would yours)
07:08:24 <masxmasx> let's not make it too complicated, benmachine :P
07:08:28 <medfly> > reverse . takeWhile (/= '.') . reverse $ "something.something.txt"
07:08:30 <benmachine> as you wish
07:08:30 <lambdabot>   "txt"
07:08:55 <masxmasx> :)!
07:10:09 <kamatsu> masxmasx: can't you use System.FilePath?
07:10:24 <kamatsu> masxmasx: admittedly it's not a URI, but it might still work
07:10:33 <Carol> what does a rectangular symbol on turing machine tape represent?
07:10:40 <masxmasx> what would be the pro of that, kamatsu?
07:10:58 <koeien37> Carol: normally, a blank
07:11:05 <burp> how can I use the hackage torrent for the "local-repo" configuration directive of cabal?
07:11:24 <burp> I tried local-repo: /home/burp/2010-01-09-hackage-archive
07:11:46 <Carol> in a state diagram then
07:11:54 <burp> "Warning: The package list for the local repo is missing. The repo is invalid."
07:11:56 <Carol> 0->rectangle,R means?
07:12:16 <Berengal> Carol: The exact symbols aren't that important. You can redefine them as you wish
07:12:31 <Carol> well for an exam i imagine its best to follow a standard
07:12:42 <koeien37> Carol: it means, "draw a rectangle, and let the tape head go to the right."
07:12:55 <koeien37> Berengal: true, but a rectangle is pretty standard notation for a blank
07:13:19 <masxmasx> ah, kamatsu, no, as it extracts the URI from a browserrequest, not just from a path
07:13:25 <Berengal> koeien37: I was more concerned with the other symbols...
07:13:39 <koeien37> the R is also pretty universal?
07:14:05 <Carol> so how is turing machine different from fsa
07:14:12 <Carol> it has accept,reject states...
07:14:22 <koeien37> it has infinite memory
07:14:28 <Berengal> Carol: They're exactly the same, except turing machines have infinite memory
07:14:31 <koeien37> that is vfery important
07:14:38 <Carol> i dont get that
07:14:41 <Carol> infinite memory
07:14:46 <koeien37> they can use the tape to store symbols
07:15:02 <Carol> yeah but they are gonna run out of tape at some point right..
07:15:06 <Berengal> Nope
07:15:06 <koeien37> no
07:15:09 <Berengal> That's the point
07:15:16 <koeien37> the tape is unbounded
07:15:30 <tomoj> they don't exist in real life, just in math heaven
07:15:31 <Berengal> Or bounded, but arbitrarily extended
07:15:35 <koeien37> a turing machine may accept a^n b^n
07:15:54 <koeien37> that's impossible with a finite state automaton
07:16:08 <tomoj> in principle we can compute most of the things we want to and would be able to with a turing machine, I think
07:16:14 <yitz> tomoj: i wouldn't exactly call turing machines heaven
07:16:18 <koeien37> tomoj: no
07:16:24 <medfly> turing machines are in maths heaven
07:16:28 <koeien37> there are many things undecidable or uncomputable
07:16:30 <medfly> not turing machines are heaven
07:16:32 <tomoj> I meant like plato's heaven
07:16:44 <tomoj> sure, I didn't mean we can compute everything
07:16:48 <koeien37> turing machines model "real" machines like the computer you are using
07:17:00 <tomoj> just that we can compute most of what we would want to that a turing machine could, except without infinite memory
07:17:01 <Carol> but turing machines did exist physically didnt they for example world war 2 cipher cracking
07:17:03 <Carol> ?
07:17:09 <koeien37> no
07:17:10 <tomoj> hah, nice pun
07:17:23 <RayNbow> Turing machines are impossible to build :p
07:17:32 <Carol> so they werent turing machines
07:17:32 <Carol> ok
07:17:34 <pikhq> RayNbow: Lies!
07:17:34 <yitz> if you move on to recursive function theory (or whatever they're calling it now), then you can remove the restrictions of turing machines, too. e.g., compute the halting problem, etc.
07:17:41 <tomoj> those were "turing machines" only to the extent that they were machines associated with turing
07:17:43 <pikhq> Lemme just get my infinite spool of tape, and... :P
07:17:44 <Jafet> Carol, go and ask your teacher or fellow students to teach you what a Turing machine is...
07:17:44 <koeien37> but Alan Turing was involved in WW2 war efforts AFAIK
07:17:50 <Jafet> I don't think anyone here has to motivation or time to teach you what you should be learning in class, over IRC
07:17:54 <yitz> that "math heaven" is even more of a nightmare than turing machines
07:18:03 <damd> i hear turing was gay
07:18:08 <koeien37> he was, yes
07:18:22 <pikhq> koeien37: Yes, he defeated Germany.
07:18:32 <benmachine> he committed suicide
07:18:51 <Jafet> He was Turing-hard.
07:19:20 <yitz> pikhq: he made a huge contribution, but it was single-handed. it involved thousands of man-hours of manual labor by rooms full of mathematicians.
07:19:25 <yitz> *wasn't
07:19:35 <xerox> Recently the UK have made public excuses for how they treated him.
07:19:42 <pikhq> yitz: Yes, I just like to jokingly say that he defeated Germany. :P
07:19:47 <yitz> von neumann was also a key player of course
07:20:24 <pikhq> (even though, as you said, Turing and Von Neumann were merely major contributors in the effort to crack Enigma)
07:20:28 <Berengal> He was part of the team that designed the Bombe, which cracked enigmas, but that wasn't even turing complete...
07:20:58 <yitz> just think of what the world would have been like if the government of England had listened to Babbage and King and built a Turing-complete computer over 100 years earlier
07:21:03 <damd> DAS BOMBÄÄ
07:21:33 <Carol> im sorry im looking this up on the internet dont understand tht concept of infinite tape
07:21:44 <pikhq> Carol: It is a tape, right?
07:21:52 <pikhq> And it doesn't have an end.
07:21:57 <Carol> well its an abstract tape
07:22:10 <yitz> Carol not abstract, imaginary
07:22:14 <Jafet> yitz, very bad steampunk
07:22:19 <damd> not imaginary, complex
07:22:32 <Carol> tape is the turing machines memory right?
07:22:36 <Berengal> Carol: It doesn't have to be infinite, since the machine can only visit a finite part of it in finite time, but it'll never reach the end, as if by magic
07:22:40 <maltem> um - doesn't look like anyone's seeding the hackage torrent? Or is it just me beng dumb with this torrent software?
07:22:42 <Carol> so how can you have infinite memory?
07:22:51 <koeien37> it is a model
07:22:53 <koeien37> Turing machines don't exist
07:22:55 <yitz> Carol: it has 2 kinds of memory, the states and what is written on the tape
07:23:03 <pikhq> Carol: Because we declare it to be that way.
07:23:29 <yitz> Carol: there is never more than a finite amount of symbols written on the tape, but we imagine that we never have to worry about it running out of room.
07:24:02 <xerox> Much like Integer
07:24:05 <Chaze> how would I apply a list of functions to a list of elements?
07:24:15 <koeien37> zipWith ($) ?
07:24:18 <Berengal> Chaze: Depends on how you want them applied
07:24:23 <koeien37> :t ap
07:24:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:24:26 <xerox> > [succ,pred] <*> [1,10,100]
07:24:27 <koeien37> or ap
07:24:27 <lambdabot>   [2,11,101,0,9,99]
07:24:44 <koeien37> (<*>) = ap
07:24:44 <damd> why not do it with c++
07:24:45 <Chaze> zipWith, right. Thanks
07:24:45 <pikhq> :t <$>
07:24:47 <lambdabot> parse error on input `<$>'
07:24:56 <damd> :t (<$>)
07:24:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:25:07 <damd> :t fmap
07:25:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:25:11 <benmachine> > getZipList $ ZipList [succ, pred] <*> ZipList [3, 4]
07:25:13 <lambdabot>   [4,3]
07:25:17 <Berengal> @type \f x -> getZipList $ ZipList f <*> ZipList x
07:25:19 <lambdabot> forall a a1. [a1 -> a] -> [a1] -> [a]
07:25:20 <pikhq> (<$>) = fmap...
07:25:41 <Berengal> @type \f x -> f <*> x
07:25:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:25:50 <medfly> @type <*>
07:25:52 <lambdabot> parse error on input `<*>'
07:25:56 <medfly> @type (<*>)
07:25:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:32:28 <Carol> what does
07:32:35 <Carol> L={w: w contains at least one 0} mean
07:32:54 <Carol> L is a string that must contain at least one 0?
07:33:13 <xerox> no, it's all strings that contain at least one 0
07:33:22 <koeien37> L is a set
07:33:38 <koeien37> the "L" is short for language
07:33:41 <Carol> w is a position on tape or symbol?
07:33:43 <masxmasx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15774#a15774 last statement of a do construct must be an expression. Why is return no expression here?
07:33:45 <koeien37> a word
07:33:50 <koeien37> so a finite string of symbols
07:34:26 <koeien37> masxmasx: count the closing )'s
07:34:34 <koeien37> in uriPath (reqURI x)
07:34:50 <masxmasx> ha i see xD thanks! I feel stupid now
07:34:51 <koeien37> type is a reserved word
07:35:00 <koeien37> you should write it as
07:35:20 <koeien37> let type = case extensie of ".txt" -> ...; ".html" -> ...;
07:35:35 <koeien37> and use something else than "type" , obviously
07:35:44 <koeien37> let contentType = case extensie of ".txt" -> ...; ".html" -> ...;
07:36:04 <Carol> so the formal notation:
07:36:06 <Carol> d(q0,1)=(q0,1,R)
07:36:07 <koeien37> using txt itself is not going to work, even if you have txt = ".txt" somewhere else in the file (this is a common gotcha)
07:36:12 <Carol> q0 is the start state?
07:36:16 <koeien37> not necessarily
07:36:16 <Carol> d is?
07:36:19 <Jafet> You should be using the content-type header
07:36:24 <koeien37> d is a transition function
07:36:28 <Jafet> Only falling back to path extension
07:36:53 <koeien37> d maps states + input symbols to triples consisting of a new state, a symbol to write at the current location, and a direction to move the tape head to
07:37:06 <masxmasx> koeien37,but with let extensie = drop 1 . dropWhile (/= '.') $ (uriPath (reqURI x)), i already removed the dot?
07:37:19 <koeien37> masxmasx: ah ok.
07:37:28 <koeien37> so use "txt" instead of txt
07:37:35 <koeien37> "txt" is a string constant, txt is a variable
07:37:55 <masxmasx> yes :) thanks
07:38:34 <masxmasx> what's the ; for?
07:38:45 <koeien37> oh ignore that
07:38:52 <koeien37> just use newlines and align them like you did
07:38:57 <masxmasx> okay :)
07:39:08 <masxmasx> ; is the same as a new line?
07:39:19 <koeien37> not completely
07:39:32 <koeien37> > case 1 of 1 -> 37; 2 -> 42
07:39:32 <lambdabot>   37
07:39:38 <koeien37> here it is ^
07:39:50 <koeien37> but this is a common problem
07:39:54 <koeien37> @let html = "html"
07:39:55 <lambdabot>  Defined.
07:40:02 <koeien37> @let xml = "xml"
07:40:03 <lambdabot>  Defined.
07:40:18 <koeien37> > case "xml" of html -> "It was HTML" ; xml -> "it was XML"
07:40:19 <lambdabot>   "It was HTML"
07:40:43 <koeien37> the occurence of `html' there matches everything
07:40:50 <koeien37> you will get a warning if you compile with warnings enabled
07:41:08 <masxmasx> how do I know if I compile with warnings enabled?
07:41:26 <koeien37> -W -Wall
07:41:26 <Berengal> -Wall enables them
07:41:34 <koeien37> ah this isn't gcc
07:41:58 <masxmasx> ok :)
07:42:01 <Berengal> The manpages have a list of individual warnings as well
07:42:03 <Carol> so in laymans terms d is ...
07:42:04 <Jafet> The c stands for confusion command line options
07:42:09 <Jafet> s/on/ng/
07:42:36 <koeien37> Carol: "what should the turing machine do when it encounters a certain symbol while being in a certain state"
07:43:00 <Carol> ok
07:46:48 <_Ray_> Err, this is more of a general functional programming question, but thought I should ask. I want to build a list of files, with certain data. I have a function that gets a file, and returns this data, but it's asynchronous, and takes a callback which it'll pass the data. I have a list of files. How could I create an array of this data?
07:48:16 <Cale> Well, callbacks don't compose too well, so you'll have to use mutable variables of some sort to pass the information back.
07:49:07 <_Ray_> What do you mean by "mutable variables"? (Btw, this isn't Haskell, it's JavaScript, but the entire model is asynchronous for this)
07:49:30 <Cale> I mean bits of memory whose value changes over time
07:49:51 <_Ray_> Hrm. Should I "build a buffer" in each callback maybe?
07:50:20 <Berengal> Does the final order matter?
07:50:28 <_Ray_> Yes.
07:50:59 <Berengal> Then how about a map?
07:51:24 <_Ray_> Do maps work well with callbacks?
07:51:27 <Cale> So, in Javascript, I believe everything is mutable. You can set each callback to write into a mutable list/array at the appropriate location.
07:52:08 <koeien37> you pass this array to the callback
07:52:09 <pikhq> If this were Haskell, your functions would have to be holding onto an Mvar to write to, but otherwise this'd work about the same.
07:52:09 <Cale> Of course, given that it's being filled asynchronously, you might have to wait for the whole array to be filled before proceeding.
07:52:22 <koeien37> you could keep a counter of some sorts
07:52:29 <koeien37> to know when every asynchronous call has fired
07:52:50 <koeien37> or loop through the array to check for nulls each time (if it's not too big)
07:52:53 <Berengal> Javascript doesn't have to worry about concurrency issues, does it?
07:52:58 <koeien37> Berengal: no
07:53:07 <Jafet> That's because there are no concurrent implementations yet
07:53:07 <koeien37> unless you run it in a non-browser, then maybe
07:53:24 <_Ray_> Well, there are, if you could WebWorkers - those are native-OS threads.
07:53:29 <_Ray_> But I'm not using those.
07:53:37 <koeien37> is that something new?
07:53:39 * Jafet snorts imagining kids sorting out muxtes and race conditions in dreamweaver
07:53:41 <_Ray_> Yeah
07:53:56 <_Ray_> I'll try the "everything writes to a mutable var" approach and see how it goes, thanks :)
07:54:04 <koeien37> HTML5-related?
07:54:10 <_Ray_> Yep.
07:55:31 <Berengal> Well, you have a single map called `result' and a list called `files'. Loop over the list, call the asynchronous fetcher with a callback with the index of the file. When the callback is called, it has the index and the file contents, so write that in the map. When the map size is equal to the list length, it's done
07:56:07 * Berengal wonders why he bothered with named variables
07:59:20 <rdeshpande> hi all
07:59:38 <rdeshpande> can anyone recommend a good site with haskell coursework ? i think that will be easier to learn than from the books i've been trying.
08:00:36 <Berengal> rdeshpande: What kind are you looking for?
08:01:04 <rdeshpande> beginners coursework, with exercises/homework preferably
08:01:14 <rdeshpande> (and answers)
08:01:23 <Ke> hackage down I am starting to shake already
08:01:26 <Ke> must code moar
08:02:40 <Berengal> rdeshpande: There aren't that many exercises exactly, but take a look at RWH, LYAH and the wikibook.
08:02:49 <Berengal> They should contain some
08:03:03 <rdeshpande> ah ok, thanks
08:03:12 <rdeshpande> i was hoping to tap into a college course or somethign
08:03:45 <Berengal> rdeshpande: There's also http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
08:03:51 <Perry__> Hi all, I am trying to understand how type inferences work in Haskell.
08:04:00 <Perry__> Having some troubles, my Google-Fu is failing me
08:04:02 <koeien37> hackage is up again
08:04:10 <Berengal> Perry__: It's working just fine, thank you :)
08:04:35 <Berengal> Perry__: Any questions in particular?
08:04:43 <Perry__> I'm doing a college course in Haskell,
08:04:48 <Perry__> and for an optional exercise.
08:04:52 <Perry__> e.g.
08:04:58 <Perry__> if   e1 = Lambda (X 2) (V (X 2))
08:05:15 <Perry__> it would return e1 with the type \x -> x
08:05:39 <Berengal> What are X and V?
08:05:41 <Perry__> In order to do this I believe I need a good understanding of the type checking mechanism behind Haskell.
08:06:01 <Perry__> Just abitary data types
08:06:06 <Perry__> or functions
08:07:20 <Botje> Perry__: check out "typing haskell in haskell" and the typing section of "implementation of functional programming languages"
08:07:28 <Berengal> Perry__: Also check out http://en.wikipedia.org/wiki/Type_inference#Hindley-Milner_type_inference_algorithm
08:07:45 <Perry__> Thank you Botje and Berengal.
08:07:56 <Berengal> Haskell isn't exactly HM, but HM gets you a long way
08:08:21 <Perry__> Haskell sure is different from a lot of language I was brought up with.
08:08:24 <tomoj> do you think it would be easier to shell out to ssh with System.Process or write an ssh client in haskell?
08:08:30 <koeien37> the former
08:08:32 <koeien37> by far
08:08:38 <tomoj> ok, thought so :)
08:08:42 <tomoj> just seems nasty :/
08:08:47 <Botje> haskell is HM^(πi)
08:10:40 <masxmasx> i get the warning pattern match(es) are overlapped, in a case alternative: _ -> ...
08:10:56 <masxmasx> but how can this be? i used _ as last alternative
08:11:10 <Twey> Do you have a x -> … pattern above it?
08:11:16 <masxmasx> yes
08:11:20 <Twey> There you go, then
08:11:37 <Twey> They cover the same pattern space, so the _ -> pattern will never be reached
08:11:47 <masxmasx> huh
08:12:01 <masxmasx> i got one alternative above that
08:12:08 <masxmasx> if that one doesnt apply, the _ will be reached?
08:12:17 <koeien37> Just x -> ... ; _ -> ...; also overlap
08:12:21 <Twey> If you have an x -> … pattern, it will alway apply
08:12:30 <Twey> always**
08:12:58 <masxmasx> why? :s
08:13:03 <masxmasx> it only applies if x is true?
08:13:04 <tomoj> koeien37: those overlap because haskell knows the thing is Maybe a ?
08:13:26 <tomoj> if you want it to apply when x is True, put True -> ...
08:13:29 <koeien37> nah, but ghc won't complain
08:13:38 <masxmasx> case a of b -> do this; _ -> do that
08:13:50 <masxmasx> then if a matches b, then it does the first, if it doesnt, it does the second?
08:14:03 <tomoj> but a will always match b
08:14:05 <masxmasx> isn't _ the same as true?
08:14:06 <Twey> masxmasx: The only difference between the two is that in the first the result is bound to b, while in the second it is ignored
08:14:10 <koeien37> masxmasx: no no no
08:14:15 <koeien37> data Bool = False | True
08:14:21 <tomoj> it's not a case statement like in other languages
08:14:27 <tomoj> it's pattern matching, not looking for booleans
08:14:48 <masxmasx> yes, it sees if a applies to b, if it does not, it keeps on looking, and sees the _, which always applies?
08:14:51 <koeien37> > case Just 5 of Just x -> "I got a " ++ show x; Nothing -> "I got nothing"
08:14:52 <lambdabot>   "I got a 5"
08:15:19 <koeien37> depends whether b is a meta-variable here ;)
08:15:35 <masxmasx> a "meta-variable"?
08:15:38 <koeien37> > case Just 5 of x -> "always applied; x = " ++ show x; _ -> "never reached"
08:15:39 <lambdabot>   "always applied; x = Just 5"
08:15:52 <masxmasx> :s
08:15:57 <koeien37> do you have a `b' in your code, literally like that?
08:16:05 <Twey> > "I got " ++ maybe "nothing" ("a " ++) (Just 5)
08:16:06 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
08:16:06 <lambdabot>    arising from the literal ...
08:16:09 <masxmasx> i have a Type on b's place
08:16:14 <Twey> D'oh :þ
08:16:27 <koeien37> masxmasx: that's possible
08:16:28 <Twey> > "I got " ++ maybe "nothing" (("a " ++) . show) (Just 5)
08:16:29 <lambdabot>   "I got a 5"
08:16:46 <koeien37> > case (1<2) of True -> Just "true!"; False -> Nothing
08:16:46 <lambdabot>   Just "true!"
08:16:59 <masxmasx> ill hpaste what i got :)
08:17:01 <masxmasx> sec
08:17:41 <masxmasx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15777#a15777
08:17:55 <masxmasx> in what way does typeContent always match contentNotFound?
08:18:01 <koeien37> contentNotFound will always be matched
08:18:03 <copumpkin> I love it when a newbie says "This looks like a bug but I don't know anything" and ignores the error message that GHC gives him explaining the error
08:18:06 <benmachine> masxmasx: it's a pattern
08:18:09 <koeien37> it is irrefutable
08:18:17 <koeien37> it is a "pattern match"
08:18:23 <benmachine> not an equality comparison
08:18:37 <Adamant> copumpkin: when you start out you usually have very little clue what the error message means
08:18:44 <masxmasx> not sure if I understand
08:18:57 <copumpkin> Adamant: yeah, but at least refrain from calling it a bug until you've done due diligence :)
08:19:14 <pikhq> masxmasx: You're not comparing typeContent and contentNotFound.
08:19:15 <Adamant> copumpkin: which breeds a bad habit when you get better of ignoring it when you should look at because you half or more understand it now
08:19:20 <Berengal> copumpkin: It's a bug in the programmer implementation
08:19:20 <Adamant> copumpkin: definitely
08:19:24 <copumpkin> :P
08:19:25 <masxmasx> I am not, pikhq?
08:19:31 <masxmasx> then what am I doing
08:19:32 <pikhq> You're checking if typeContent matches the pattern contentNotFound, and if it does, place it in contentNotFound.
08:20:00 <masxmasx> :s
08:20:02 <Berengal> masxmasx: contentNotFound is a variable. Variables match anything
08:20:05 <masxmasx> how would I correctly do this then?
08:20:12 <pikhq> > case Nothing of x -> show x; _ -> "Didn't match x? Whachu talking about, Willis?"
08:20:14 <lambdabot>   "Nothing"
08:20:26 <Berengal> masxmasx: If you've previously defined it, it will shadow that binding
08:20:29 <benmachine> masxmasx: if typeContent == contentNotFound then blah else bloop
08:20:46 <masxmasx> like in imperative languages?:o
08:20:46 <benmachine> or case typeContent of x | x == contentNotFound -> blah; _ -> bloop
08:21:23 <Berengal> masxmasx: Like what in imperative languages?
08:21:28 <copumpkin> Adamant: did you see the meessage?
08:21:29 <pikhq> masxmasx: Not quite. In Haskell, the if will always need to evaluate to a value.
08:21:31 <benmachine> masxmasx: pattern matching works on constructors, which always begin a capital letter or a colon
08:21:42 <pikhq> It's actually most similar to C's ternary operator.
08:21:48 <Adamant> copumpkin: que?
08:21:57 <Adamant> the one in question or did you try to PM me?
08:22:07 <copumpkin> Adamant: glasgow-haskell-users
08:22:17 <Adamant> I am not on it
08:22:39 <nainaide> How to pause for a second in a do block ? Please
08:22:47 <copumpkin> @hoogle threadDelay
08:22:48 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
08:22:55 <pikhq> nainaide: Which monad?
08:23:05 <koeien37> threadDelay takes microseconds
08:23:09 <koeien37> so 1 second is 10^6
08:23:19 <nainaide> I defined a monad myself
08:23:27 <koeien37> ah I see
08:23:30 <koeien37> can your monad do IO ?
08:23:32 <copumpkin> zomg
08:23:39 <pikhq> Is it MonadIO?
08:23:43 <nainaide> koeien, yes
08:23:48 <aavogt> > when True (return "hai") :: [String]
08:23:49 <lambdabot>   Couldn't match expected type `()'
08:23:49 <lambdabot>         against inferred type `[GHC.Types...
08:24:00 <koeien37> then make an instance of MonadIO, and do liftIO (threadDelay (10^6))
08:24:14 <nainaide> koeien, thanks!
08:24:20 <aavogt> > runWriter $ when True (tell "hai")
08:24:21 <lambdabot>   ((),"hai")
08:24:38 <Berengal> > guard True >> return "hai" :: [String]
08:24:39 <lambdabot>   ["hai"]
08:25:00 <aavogt> the function when is like an if without the else, masxmasx
08:25:21 <Berengal> aavogt: "like" being a bit of a stretch
08:25:37 <copumpkin> yeah, it's exactly that
08:25:45 <copumpkin> ;)
08:25:59 <aavogt> Berengal: what is the diference, besides where you may use it?
08:26:18 <pikhq> @src when
08:26:19 <lambdabot> when p s = if p then s else return ()
08:26:23 <pikhq> *echm*
08:26:46 <Berengal> aavogt: I'd say the "where you can use it" part isn't entirely insignificant
08:27:13 <aavogt> well other languages have restrictions based on what is a statement and what is an expression too
08:29:13 <Twey> when = flip (?? return ())
08:29:21 <damd> :t (??)
08:29:22 <lambdabot> forall t. t -> t -> Bool -> t
08:29:26 <damd> @src (??)
08:29:26 <lambdabot> Source not found. It can only be attributed to human error.
08:39:30 <Perry__> Hhmm : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15778#a15778
08:39:36 <Perry__> On the second to last line
08:39:47 <Perry__> I get a Syntax error, possibly due to bad layout
08:39:49 <koeien37> indent it more
08:40:11 <koeien37> oh the { }, I'm not sure Haskell is happy with that
08:40:38 <Perry__> oh opps
08:40:40 <Perry__> problem solved
08:40:58 <Perry__> I forgot that the capslock key in German keyboards works like a shift lock too
08:40:59 <Perry__> so instead of [] it outputted {}
08:41:09 <Twey> damd: (y ?? n) p = if p then y else n
08:41:18 <Perry__> Thanks koeien37
08:41:30 <Twey> Perry__: Heh.  My shift-lock does that too (I hardly use it, so it's handy)
08:42:46 <Botje> my caps lock is an escape key
08:42:49 <Botje> muy handy :)
08:42:57 <Twey> My caps lock is a Compose key
08:43:07 <Twey> もっと便利
08:43:23 <Twey> Shift-lock is triggered by hitting both shift keys at once
08:43:24 <uorygl> Did you do that with your compose key?
08:43:29 <uorygl> If so, I'm impressed.
08:43:30 <koeien37> I use SCIM
08:43:31 <Twey> No :þ
08:43:34 <Twey> UIM
08:43:42 <copumpkin> 陰茎
08:44:04 <koeien37> 我不会说日语
08:44:14 <uorygl> 陰 looks like β composed with some Han character.
08:44:15 <Twey> Haha
08:44:31 <copumpkin> uorygl: it is!
08:44:35 <Twey> 我不会说中语!
08:44:44 <Twey> uorygl: That's a common radical
08:44:55 <uorygl> Surely the Greek letter beta itself is not a common radical.
08:45:12 <tomoj> is it possible to define a type constructor which takes arbitrarily many (i.e., a list) of arguments?
08:45:13 * uorygl consults Wiktionary.
08:45:23 <copumpkin> tomoj: nope
08:45:33 <copumpkin> tomoj: unless you want to actually pass it a list
08:45:36 <copumpkin> :)
08:45:39 * uorygl finds the radical; it's 阝
08:45:47 <copumpkin> yep
08:45:48 <Twey> 's the one
08:45:51 <uorygl> copumpkin: he said type constructor, though.
08:46:02 <uorygl> You'd have to construct a type-level list. Which may be possible.
08:46:06 <Twey> It is
08:46:07 <tomoj> maybe I am thinking about this the wrong way
08:46:11 <Twey> Terrifying, but possible
08:46:18 <copumpkin> uorygl: I assumed he was just misusing terminology :)
08:46:22 <copumpkin> but it's possible I guess
08:47:11 <Perry__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15778#a15778 <- Same code, but now it is complaining about multiple declaration of variable 'ftv'
08:47:24 <Perry__> I searched for the error message " Multiple declarations for variable"
08:47:31 <Perry__> and google yielded no results =/
08:47:32 <koeien37> you should indent it
08:47:37 <koeien37> line 14
08:47:46 <koeien37> otherwise the instance declaration ends immediately
08:47:56 <Perry__> Oh?
08:47:57 <tomoj> the goal is that you have a single type which can either be Schemaless or Schema [(x,SomeType),(y,OtherType),(z,AnotherType)] or something like that where those are field names mapping to field types somehow
08:48:00 <Perry__> I was not aware of that.
08:48:02 <Perry__> Thank you again
08:48:31 <uorygl> The Reduceron consists of York Lava, F-lite, and the Reduceron? That sounds like accidental recursion.
08:48:55 <tomoj> hmm, actually, my idea requires defining a new type for each field in a schema
08:49:27 <tomoj> the idea is that if your schema fields have types of their own, you can ensure that a function which changes a document only changes certain fields in the schema, based on its type
08:50:06 <Carol> whats a deterministic state machine
08:50:15 <copumpkin> tomoj: if it's a schema you probably want an hlist
08:50:16 <tomoj> in cases where you need to know that certain parts of the document will not be touched, this would be useful if it were possible and not too much trouble
08:50:18 <koeien37> a finite state machine
08:50:30 <tomoj> copumpkin: thanks, I had seen that before but didn't read too much about it
08:50:45 <copumpkin> it's not terribly pretty but it works
08:51:30 <tomoj> I wonder if it can be wrapped up in a pretty interface
08:55:07 <Cale> Carol: It's a device used to recognise certain strings. It consists of a set of states (which you can picture as dots), one of which is marked as the initial state, and some of which are marked as terminal states. Then there are transitions between the states -- for each state and possible symbol which could occur in the input to the machine, you have a transition which says what state the machine should be in next wh
08:55:07 <Cale> en that symbol is encountered in the given state.
08:55:41 <Cale> (the transitions are usually depicted as labelled arcs)
08:56:13 <Carol> deterministic and non deterministic whats the difference?
08:56:23 <koeien37> Cale: I think s/he knows, because Carol used the word 'finite state machine' before. Correct me if I'm wrong, Carol
08:56:37 <sproingie> hackage down?
08:56:49 <copumpkin> Carol: nondeterministic can go to zero or more new states
08:57:01 <koeien37> sproingie: :( not again
08:57:06 <Cale> Ah, well, in a nondeterministic machine, there can be multiple transitions from a given state with the same symbol. The nondeterministic machine tries all of them at once, and if any path accepts, then the machine accepts the string.
08:57:14 <koeien37> it was up an hour ago or so
08:57:34 <Carol> ok thanks
08:57:38 <koeien37> they are equivalent in power, you can simulate a nondeterministic machine with a deterministic machine
08:58:06 <Cale> (though, using exponentially more states in general)
08:58:06 <koeien37> it can involve a exponential increase in the number of states you need to use, iirc
08:58:42 <Cale> Essentially, you make a state in your new deterministic machine for every possible combination of states you could be in with the nondeterministic one.
09:01:17 <tomoj> copumpkin: thanks, this sounds exactly right
09:01:44 <sproingie> sometimes an intractable number of states
09:01:54 <sproingie> as can happen when converting regexes to dfa
09:02:11 <sproingie> what's cool about dfa regexes is at the end you get every possible match
09:02:25 <Eelis> > sum [1..1000000] -- how do i fix this?
09:02:27 <lambdabot>   * Exception: stack overflow
09:02:43 <aavogt> > foldl' (+) 0 [1..1000000]
09:02:44 <lambdabot>   500000500000
09:02:57 <Eelis> thanks. why doesn't sum do that by default?
09:03:31 <aavogt> because haskell is a lazy language, so the Prelude contains lazy functions
09:03:40 <Eelis> so, shouldn't there be a sum' then?
09:03:47 <maltem> yes there should
09:03:48 <aavogt> but for sum it doesn't really make much sense
09:03:59 <aavogt> > sum [1..] > (100 :: Natural)
09:04:06 <lambdabot>   mueval-core: Time limit exceeded
09:04:06 <lambdabot>  mueval: ExitFailure 1
09:04:11 <Cale> If you wanted a lazy sum, you'd be more likely to want foldr (+) 0
09:04:15 <aavogt> > foldr (+) 0 [1..] > (100 :: Natural)
09:04:22 <lambdabot>   True
09:04:36 <Cale> But when the Prelude was originally written, foldl' didn't exist, for one.
09:04:37 <sproingie> that or scanl
09:04:53 <Eelis> aavogt: so you'd argue that sum in the prelude /should/ be implemented with foldl' ?
09:04:56 <Cale> I think the intention was that the implementations should figure out where things should be strict.
09:05:00 <sproingie> it'd be nice if prelude had more generic functions
09:05:26 <aavogt> Cale: and they do sometimes, no?
09:05:42 <Cale> Indeed they do
09:05:51 * monochrom uploads prelude-twitter to hackage. module Prelude.Twitter contains all functions writable in 140 tokes or less!
09:06:00 <sproingie> that'd be most of the prelude
09:06:02 <Cale> Try compiling a program which does that sum with -O2
09:06:13 <Cale> You'll find that it works okay.
09:06:20 <tomoj> can I take some value and return the type of the value as a string?
09:06:27 <Cale> because the strictness analysis is good :)
09:06:37 <Adamant> monochrom: type, joke, or both?
09:06:40 <Adamant> *typo
09:06:40 <monochrom> joke
09:06:43 <Adamant> lol
09:06:44 <aavogt> > typeOf (+1)
09:06:45 <lambdabot>   Integer -> Integer
09:06:53 <sproingie> haskell is already a very twitter-friendly language
09:06:54 <aavogt> > typeOf $ typeOf (+1)
09:06:56 <lambdabot>   TypeRep
09:07:04 <aavogt> > show $ typeOf (+1)
09:07:05 <lambdabot>   "Integer -> Integer"
09:07:38 <aavogt> tomoj: but what would you do with a String representation of a type? (Note this only works for Typeable things)
09:07:50 <tomoj> aavogt: thanks
09:07:51 <tomoj> oh, humm
09:08:41 <tomoj> well, I will be converting homogenous collections of values of an openended set of types (HList) into json documents
09:09:21 <tomoj> and I'd like the type name to be the key string in the json object
09:09:40 <copumpkin> remember that the types aren't dependent
09:09:44 <Cale> It's too bad that strictness analysis isn't something which you can rely on a little more. I suppose if it were, then problems involving strictness might seem even more mysterious than they already do.
09:09:46 <copumpkin> :)
09:09:59 <tomoj> copumpkin: I think I will have to read more before I can understand that
09:10:01 <Cale> Also, strictness analysis is a hard problem in general.
09:10:05 <copumpkin> the anal isn't strict enough
09:10:26 <copumpkin> tomoj: the types can't depend on runtime values
09:10:40 <tomoj> oh, like pulling a key string out of a DB :(
09:10:46 <copumpkin> well, they can in a very limited manner
09:10:56 <copumpkin> tomoj: oh, that's probably fine
09:11:12 <tomoj> are my concerns addressed later in the HList paper, I guess?
09:11:15 <_Ray_> I ended up doing the async list by making a function that feeds off an array (x:xs), and passes xs to itself, plus a "built" buffer based on x. When xs is empty, I'm done, and I call my callback.
09:11:25 <copumpkin> tomoj: not sure, haven't read it
09:11:30 <conal> jtootf: ping
09:11:31 <aavogt> HList doesn't involve Typeable
09:11:34 <tomoj> oh, ok, well I'll read on
09:11:48 <tomoj> maybe there is some other way to do it
09:12:35 <copumpkin> conal: is it worth arguing with him?
09:12:51 <conal> copumpkin: ?
09:12:58 <copumpkin> Mr. JJ
09:12:59 <conal> copumpkin: with whom?
09:13:31 <copumpkin> I saw your tweet about him yesterday
09:13:58 <conal> copumpkin: no, it's not.  i rarely find it worthwhile arguing with anyone these days.
09:14:07 <copumpkin> :)
09:15:26 <jmcarthur> conal: stress destroys focus. don't do things that stress you!
09:15:47 <jmcarthur> well, it destroys other things too, but i'm selfish, so i want you to focus on the things you are working on :P
09:15:52 <copumpkin> lol
09:15:59 <conal> copumpkin: we briefly had a mentorship understanding.  i was trying to coach on listening & checking assumptions,  to reduce noise.
09:16:12 * benmachine doesn't do things that focus him
09:16:23 <conal> like most of my projects, it's not clear to me when when to give up.
09:16:46 <conal> jmcarthur: stress sure does destroy my focus.
09:18:10 <chrisdone> I once imlpemented a bug-free, efficiently multithreaded real-time clock + infix calculator hybrid under heavy stress
09:18:40 <Gracenotes> was it enterprise quality?
09:18:52 <jmcarthur> it was good enough for government work
09:20:20 <conal> copumpkin: and, while working privately with people does distract me from tech work, it's also important to me to learn how to get past blockages to understanding & compassion.  something i've invested a lot in working with.  way harder through the medium of text, though :(.
09:20:54 <conal> jmcarthur: ^^ meant to include you as well.
09:22:49 <conal> i'm still wrestling with the question of blog moderation.  i moderate to keep the quality high, and i offer directive feedback when i don't pass things through.
09:23:05 <Berengal> conal: 1/3 of the blog posts linked to in the HWN are written by you.. feeling productive lately?
09:23:18 <Berengal> the latest HWN*
09:23:23 <Athas> I'm trying to make Parsec parse a grammar that has both juxtaposition-based application and infix operators.  This is giving me trouble.  Do any of you know of a program that does this?
09:23:29 <conal> Berengal: oh?  i haven't seen hwn.  :)  yeah!
09:23:46 <conal> (latest hwn)
09:24:01 <conal> more posts to come!
09:24:14 <Berengal> Hehe
09:24:50 <Cale> Athas: you may find chainl to be a useful function
09:25:34 <conal> meanwhile, i'm completely neglecting my graphics compiler + iphone project.  and discouraged about commercializing / income.  making things people know they want has never been my strong suit.
09:26:01 <Beelsebob> haha
09:26:07 <Perry__> hmmm... question.
09:26:13 <Athas> Cale: indeed, the big problem is making it work with buildExpressionParser.
09:26:14 <Beelsebob> that sums you up wonderfully conal
09:26:21 <Perry__> Data TVar = Int
09:26:23 <Perry__> data Type = TV TVar deriving (Eq,Ord)
09:26:23 <HaskellLove> iterate :: (a -> a) -> a -> [a]        expand :: Int -> [Int]           This is why i get error right? My function turns an Int into a list of Ints, and you cant have such function in iterate... as it says  (a -> a) it wants a function that takes something of type and and also returns type a, correct?
09:26:42 <Perry__> I am getting an error message of 'An instance of Ord Tvar' is required to derive.
09:26:53 <conal> Beelsebob: :)
09:26:57 <copumpkin> > let expand = iterate (+1) 0 in expand
09:26:58 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
09:27:10 <copumpkin> > let expand n = iterate (+n) n in expand 5
09:27:11 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,12...
09:27:12 <damd> :t iterate
09:27:15 <lambdabot> forall a. (a -> a) -> a -> [a]
09:27:16 <copumpkin> :t let expand n = iterate (+n) n in expand
09:27:18 <lambdabot> forall a. (Num a) => a -> [a]
09:27:22 <aavogt> > enumFrom 1
09:27:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:27:23 <Cale> Perry__: You've defined TVar as a type with one value, specifically the literal Int
09:27:35 <damd> > iterate ('a':) ""
09:27:36 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"...
09:27:58 <Perry__> Cale: yep, but if memory serves, Int can be Ordered
09:28:05 <Cale> Perry__: and not derived instances of Eq or Ord for it, though this is probably a secondary concern
09:28:06 <Perry__> Or is there something I am missing here.
09:28:16 <Cale> Perry__: TVar has nothing to do with the *type* Int
09:28:27 <Cale> Perry__: You defined it as a type with one value whose name is Int
09:28:55 <Perry__> Ah I see
09:28:58 <Cale> (It's confusing because there are now things on the type level and the value level which are both called Int, but they live in separate worlds)
09:29:24 <Cale> Perhaps you want something like data TVar = TVar Int
09:29:37 <Cale> Which defines a data constructor TVar :: Int -> TVar
09:29:41 <Perry__> Currently just trying to learn how to implement  Hindley Milner in Haskell
09:29:42 <Gracenotes> Perry__: constructor names can overlap with type names.. but in this case Int the type name is built-in, and Int the constructor-name-for-type-TVar is something you just made up
09:29:54 <Cale> Perry__: Or possibly just  type TVar = Int
09:30:06 <tomoj> what does the perpendicular / bottom element / ⊥ mean in haskell?
09:30:17 <tomoj> I mean, that's just pdf fanciness, right? is it _|_ ?
09:30:18 <Cale> Perry__: which defines TVar to just be an syntactic alias for Int
09:30:29 <opqdonut> tomoj: usually it means undefined value / non-halting computation
09:30:40 <tomoj> how do you write it out, though?
09:30:43 <sproingie> tomoj: ⊥ is actually the proper symbol, _|_ is just our best ascii approximation
09:30:50 <opqdonut> and it's read "bottom"
09:30:53 <Gracenotes> turnstile means nothing according to a Haskell compiler. but it has a meaning in its semantics, for sure
09:30:55 <Perry__> Cale: yep, yet I am trying to use TVar to hold the data 'Int'
09:30:56 <tomoj> oh, you really put that character in the source?
09:31:00 <sproingie> tomoj: neither are actually defined in haskell, the closest to it is "undefined"
09:31:09 <Perry__> Cale: Since it represents all 'int' in a type inference simulation
09:31:12 <tomoj> oh, hmm
09:31:13 <opqdonut> comes from the scott models for lambda calculus
09:31:20 <tomoj> so I wonder what's in the sources for HList
09:31:20 <opqdonut> tomoj: ghc accepts unicode input
09:31:21 <sproingie> @let ⊥ = undefined
09:31:21 <aavogt> @src undefined
09:31:21 <lambdabot>   Parse error: VarSym "\8869"
09:31:22 <lambdabot> undefined =  error "Prelude.undefined"
09:31:41 <tomoj> ah, I see, thanks
09:31:43 <Gracenotes> tomoj: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
09:32:06 <sproingie> ⊥ must be non-word.  is there an easy way to get unicode properties?
09:32:20 <Gracenotes> @let (⊥) = undefined
09:32:22 <lambdabot>  Defined.
09:32:26 <Cale> Perry__: If you want TVar to actually be a different type from Int (as treated by the typechecker), you would need to use 'data' or 'newtype', and this would make you write a data constructor to construct values of that new type. With 'type', it's treated as the same thing as Int by the typechecker
09:32:41 <tomoj> Gracenotes: thanks
09:32:45 <Gracenotes> > 1 ⊥ 2
09:32:47 <lambdabot>   * Exception: Prelude.undefined
09:33:06 <sproingie> yeah but you can't use it as a plain old value
09:33:15 <sproingie> without the parens anyway
09:33:34 <Perry__> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15783#a15783 <- Does that look better?
09:33:38 <chrisdone> WHERE'S HACKAGE‽
09:33:48 <sproingie> I ATED IT
09:33:53 <chrisdone> ;_;
09:34:10 <Gracenotes> is it gone still?
09:34:17 <chrisdone> down
09:34:38 <Gracenotes> I am still seeding the torrent, at least
09:35:36 <mauke_> the tracker is down
09:35:37 <Gracenotes> and, where was the web interface for it?
09:35:41 <Gracenotes> .. http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html
09:35:46 <Cale> Perry__: that'll work. You may find that writing the X and A type constructors gets a little tiring, depending on how you do things.
09:35:50 <Gracenotes> mauke_: oh. :/ well, I'm still hooked onto something
09:36:01 <sproingie> Gracenotes: it's showing as stalled for me
09:36:11 <chrisdone> hackage is ran by a tracker? huh?
09:36:58 <Perry__> Cale: Except it's still giving me the same error . "  An instance of Ord TVar is required to derive Ord Type"
09:37:08 <Perry__> I'm still rather new to Haskell, so bear with me :/
09:37:36 <Gracenotes> oh. hm. now looking at the properties, it does say the tracker timed out... hm. Well, transmission doesn't seem to care.
09:38:17 <sproingie> ktorrent isn't getting it at all
09:39:38 <Cale> Perry__: You'll need to derive Eq and Ord in more places
09:40:03 <Cale> Perry__: It'd probably be a good idea to derive at least Eq, Ord and Show for all of these types
09:40:42 <Perry__> Cale: I'm going to try that now
09:42:07 <sproingie> Gracenotes: sure you have the right tracker?  i'm showing zero seeds
09:42:28 <sproingie> i'm using the one in the /topic
09:42:46 <Gracenotes> sproingie: what's the URL of that?
09:44:57 <Perry__> Cale:  Thanks it worked :) Also: another question
09:45:13 <Perry__> http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Map.html#v%3Alookup <- I am using Map.lookup
09:45:26 <Cale> mhm
09:45:29 <sproingie> Gracenotes: http://mauke.ath.cx/tmp/2010-01-09-hackage-archive.torrent
09:45:41 <Perry__> Does the lookup function only accept Strings as the look up key?
09:46:00 <Gracenotes> er, not meant that entirely.. just a sec though
09:46:01 * SamB_XP can't help but think that BitTorrent isn't quite ideal for sharing an ever-increasing collection of files like that ...
09:46:06 <Cale> Perry__: It accepts values of whatever type k is.
09:46:22 <Cale> Perry__: The only requirement is that the key type is an instance of Ord
09:46:30 <sproingie> SamB_XP: it is if you tar it up
09:46:37 <Cale> (and that the keys in a Map are all the same type)
09:46:40 <sproingie> SamB_XP: but yah i see your point
09:47:08 <SamB_XP> sproingie: I meant, eventually you'd end up with a bunch of people on different torrents for different versions of the tree
09:47:20 <sproingie> SamB_XP: right
09:47:25 <SamB_XP> or maybe I don't understand what the torrent is of ;-P
09:47:45 <Gracenotes> sproingie: yes, the one I started a few days ago seems to be that same one, with tracker URL http://denis.stalker.h3q.com:6969/announce, which is down
09:47:46 <SamB_XP> is it hackage the software, or hackage the collection of Haskell packages ?
09:47:47 <sproingie> there really should be a delivery system that takes that into account
09:47:52 <sproingie> sort of a peer-to-peer git
09:47:54 <HaskellLove> it would have been cool if haskell had this: [[Int]] ++ [[Int]] so you can check in interpreter what is the type you get
09:48:13 <Cale> Perry__: lookup :: Ord k => k -> Map k a -> Maybe a -- "If k is any ordered type, then lookup takes a value of type k, and a Map from keys of type k to values of type a, and produces a value of type Maybe a"
09:48:30 <SamB_XP> sproingie: there is at least one project by the name of Git
09:48:31 <kpreid> HaskellLove: ask for the type of ((undefined :: [[Int]]) ++ (undefined :: [[Int]]))
09:48:32 <SamB_XP> er.
09:48:34 <Gracenotes> HaskellLove: well, it would be nice to set type variables, add your own type equations
09:48:35 <SamB_XP> the name of GitTorrent
09:48:49 <Gracenotes> ouch
09:49:10 <Perry__> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15784#a15784
09:49:32 <Perry__> Cale: The interesting part is that I have not specified [char] or String anywhere. But it somehow was expecting it as a return type
09:50:03 <Gracenotes> I have an idea.. we can have a central HTTP repository that has all the latest versions of packages.
09:50:08 <sproingie> Perry__: it inferred it somewhere else
09:50:12 <HaskellLove> kpreid I get the same thing ((undefined :: [[Int]]) ++ (undefined :: [[Int]])) :: [[Int]]
09:50:18 <SamB_XP> Gracenotes: and ?
09:50:29 <SamB_XP> ... won't that go down at the darnedest times ?
09:50:41 <gwern> ' Note to Internet friends: I'm extremely grateful that hundreds of you have taken time to read these drafts, and to detect and report errors that you've found. Your comments have improved the material enormously. But I must confess that I'm also disappointed to have had absolutely no feedback so far on several of the exercises on which I worked hardest when I was preparing this material. Could it be that (1) you've said nothing about ...
09:50:44 <Gracenotes> great idea, huh. I also have in the works a tool called "cabal" that downloads from it
09:50:48 <gwern> ... them because I somehow managed to get the details perfect? Or is it that (2) you shy away from the more difficult stuff, being unable to spend more than a few minutes on any particular topic? Although I do not like to think that readers are lazy, I fear that hypothesis (1) is far less likely than hypothesis (2). I may have to remove material that nobody cares about. But I still cling to a belief that these details are extremely ...
09:50:54 <gwern> ... instructive. Thus I would like to enter here a plea for some readers to tell me explicitly, ``Dear Don, I have read exercise N and its answer very carefully, and I believe that it is 100% correct,'' where N is one of the following:'
09:50:59 <gwern> burn
09:51:01 <Cale> Perry__: What's the type of apply?
09:51:01 <gwern> Gracenotes: just use wget
09:51:04 <gwern> that's total NIH
09:51:16 <copumpkin> national institutes of health?
09:51:18 * SamB_XP wishes XP came with wget
09:51:26 <SamB_XP> copumpkin: Not Invented Haskellely ?
09:51:45 <Perry__> Cale: You, good sir deserves a medal.
09:51:50 <copumpkin> omnom
09:51:54 <sproingie> Gracenotes: hey cool, and then when it goes down we can circle back to other distribution ideas
09:52:00 <Perry__> problem solved, thanks sproingie and Cale.
09:52:01 <copumpkin> Perry__: which good sir deserves a medal?
09:52:09 <Perry__> All of you deserves a medal.
09:52:14 <copumpkin> nice! thanks
09:52:18 * copumpkin wears his medal with pride
09:52:20 <Gracenotes> sproingie: don't count your chickens before they time out
09:52:39 <Perry__> Thanks Cale, indeed earlier when I was planning I set the Map to be Map.Map String Type
09:52:55 * SamB_XP finds it's really choking him to wear the same medal as all 646 of the other people in the channel
09:52:56 <kpreid> HaskellLove: and that is the correct answer
09:53:04 <Perry__> I really need to think in *haskell* way instead of the *C* way.
09:53:21 <kpreid> the type of (something of type [[Int]]) ++ (something of type [[Int]]) is in fact [[Int]]
09:53:21 <SamB_XP> Perry__: yeah, C way is really too painful
09:53:40 <HaskellLove> kpreid well you dont get that
09:53:50 <Perry__> SamB_XP: I am still not used to the syntax of functional programming, not to mention that indenting actually makes a difference. :)
09:53:52 <kpreid> HaskellLove: yes you do, it's the part on the right of the outer '::'
09:53:53 <Perry__> But it is lovely though.
09:54:13 <HaskellLove> kpreid dude you get this whole thing ((undefined :: [[Int]]) ++ (undefined :: [[Int]])) :: [[Int]]
09:54:24 <gwern> SamB_XP: it's a normal size necklace. we just define the outside to be in, then there's room enough for everyone
09:54:31 <kpreid> HaskellLove: yes, and the part on the left is what you typed, and the part on the right is the type of it
09:54:36 <kpreid> which is the type you wanted to know
09:54:39 <Cale> :t (undefined :: [[Int]]) ++ (undefined :: [[Int]])
09:54:41 <lambdabot> [[Int]]
09:54:51 <copumpkin> :t (undefined :: [[Int]]) ++ undefined
09:54:52 <lambdabot> [[Int]]
09:55:00 <opqdonut> :t undefined ++ undefined
09:55:01 <lambdabot> forall a. (Monoid a) => a
09:55:04 <HaskellLove> kpreid oh at the end i did not ... am i blind... wow this is so coool
09:55:05 <opqdonut> :)
09:55:07 <copumpkin> :t  undefined ++ (undefined :: [[Int]])
09:55:08 <lambdabot> [[Int]]
09:55:09 <copumpkin> zomg
09:55:13 <kpreid> aaaa, caleskell :-)
09:55:16 <copumpkin> type inference WORKS!!!!!
09:55:17 <copumpkin> ZOMG
09:55:25 <HaskellLove> what is zomg
09:55:32 <copumpkin> like omg but more sarcastic
09:55:37 <mux> heh, base-unicode-symbols transforms haskell into agda.
09:55:42 <sproingie> hint, the
09:55:44 <HaskellLove> like zombies omg?
09:55:45 <Cale> copumpkin: Been watching MIT physics lectures on YouTube?
09:55:49 <copumpkin> mux: unfortunately not
09:55:50 <sproingie> hint, the 'z' key is next to the shift key
09:56:03 <sproingie> it's the same sort of thing as LOL!!!!1
09:56:07 <copumpkin> sproingie: such an etymologist!
09:56:13 <copumpkin> sproingie: ZOMG
09:56:14 <sproingie> i hate bugs
09:56:15 <sproingie> oh wait
09:56:18 <mux> copumpkin: that was obviously a joke :-P
09:56:29 <copumpkin> :) yeah
09:56:48 <Cale> (at least, I heard that comment in Walter Lewin's voice :)
09:56:53 <copumpkin> :)
09:56:57 <copumpkin> I can't say I have
09:58:35 <Cale> When the experiments work according to prediction he tends to shout "physics works!" :)
09:58:43 <HaskellLove> I watched all physics lectures once, the guy is crazy, i wish i had such phyics professor.
09:58:49 <copumpkin> surely it's just a theory
09:59:40 <Gracenotes> I'm in the middle of his electromagnetism course, filmed 2002
09:59:41 <RayNbow> hmm, Ralf Lämmel's lecture on continuations/denotational semantics is pretty nice... :) ( http://www.uni-koblenz.de/~laemmel/paradigms0910/resources/denotational2.html )
09:59:49 <Gracenotes> Lewin's
10:00:09 <Gracenotes> Internet Archive offers mp4 downloads... I prefer native players to flash ones
10:00:15 <opqdonut> :t (?x ++ ?y) :: [[Int]]
10:00:16 <lambdabot> (?y::[[Int]], ?x::[[Int]]) => [[Int]]
10:00:21 <paolino> hackage is refusing to give out the tarball ...
10:00:29 <opqdonut> type inference works in many directions
10:00:45 <copumpkin> opqdonut: in all three directions?
10:01:13 <PeakerWork> argument->result  type inference actually exists in virtually(?) all typed languages -- the other direction doesn't
10:01:14 <Gracenotes> copumpkin: yeah, you're limiting yourself to three axes
10:01:24 <Gracenotes> expand your mind :o
10:01:38 <xerox> Gracenotes I agree. Sometimes in the future with the <video> tag it will be better :)
10:01:54 <aavogt> @faq does type inference work in directions I don't even know about?
10:01:55 <lambdabot> The answer is: Yes! Haskell can do that.
10:02:16 <Gracenotes> xerox: well. that may be so. But *outside* of the browser is the feature I prefer about it
10:03:45 <aavogt> PeakerWork: what do you mean by  argument->result inference? Usually you do have to name result types for functions
10:04:06 <aavogt> int foo (x : Int) { blah }
10:05:18 <PeakerWork> aavogt: Well, when you apply a function - it finds the result type on its own (that of the function) :)  And when you use polymorphic functions (e.g: Operators in C, or templated functions in C++), it has to actually infer the expression's result type, and it does
10:08:10 <HaskellLove> for a function to be recursive its input and output type must be the same, correct? explode :: [Int] -> [[Int]] i would not be able to make that recursive i guess...
10:08:50 <aavogt> recursive functions must call themselves
10:09:02 <c_olin> The input and output can be different
10:09:55 <aavogt> > let explode :: [Int] -> [[Int]]; explode [] = [[]]; explode (x:xs) = [x]:map (x:) (explode xs) in explode [1,2,3]
10:09:57 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3]]
10:10:10 <Gracenotes> I don't see the logic about input and output type having anything to do with each other
10:10:53 <Ke> :t stdout
10:10:54 <lambdabot> Not in scope: `stdout'
10:11:08 <aavogt> @hoogle stdout
10:11:09 <Ke> :t stdInput
10:11:09 <lambdabot> System.IO stdout :: Handle
10:11:10 <sproingie> no io in lambdabot
10:11:10 <lambdabot> Not in scope: `stdInput'
10:11:32 <aavogt> well stdout could still be in scope
10:11:34 <Gracenotes> no harm in adding it, is there?
10:11:44 <Gracenotes> the modules, not IO actions
10:11:57 <paolino> @hoogle Handle
10:11:58 <lambdabot> System.IO data Handle
10:11:58 <lambdabot> Control.Exception handle :: Exception e => (e -> IO a) -> IO a -> IO a
10:11:58 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
10:12:39 <Gracenotes> > return id :: IO (a -> a)
10:12:41 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:12:42 <lambdabot>    `Data.Typeable.Typeable a...
10:13:03 <Gracenotes> > return id :: forall a. IO (a -> a)
10:13:05 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:13:05 <lambdabot>    `Data.Typeable.Typeable a...
10:13:43 <Gracenotes> > (return :: a -> IO a) id
10:13:44 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:13:45 <lambdabot>    `Data.Typeable.Typeable a...
10:14:28 <Gracenotes> ..arising from a use of `M8591467057910635010.show_M8591467057910635010'
10:14:57 <Gracenotes> ah well. I guess its IO-showing isn't as straightforward as I'd imagine
10:15:06 <Perry__> quick question:  Cannot use type synonym in instance head
10:15:34 <Perry__> What exactly does it mean by that? I am dumbfolded by that error message.
10:15:42 <Ke> so I can use closeFd and dupTo before forking just like in C?
10:15:53 <opqdonut> Perry__: it means you have "type Foo = ..." and try to say "instance Bar Foo"
10:16:02 <opqdonut> you should use newtype or data if you want that
10:16:12 <Perry__> Oh.
10:16:18 <opqdonut> or inline the definition of Foo
10:16:20 <Perry__> Let me have a look.
10:16:25 <opqdonut> and possibly use some isntance extensions
10:16:29 <opqdonut> like FlexibleInstances
10:16:51 <sproingie> know what'd be cool is if ghc had a 'splain' program that explained error messages like that
10:17:44 <koeien37> you can do it, it's not H98 afaik
10:18:30 <sproingie> should be pretty simple to write i guess, splain just does a simple search in a file
10:18:42 <Perry__> yep
10:18:49 <Perry__> Thanks opqdonut : I did have     type Scheme  = ([TVar], Context, Type)
10:18:54 <sproingie> mostly the DIAGNOSTICS section in pod
10:19:07 <Perry__> and I tried 'instance Types Scheme where...'
10:19:38 <c_wraith> Perry, that's not complete as it stands.  TVar is a type constructor, not a type.
10:19:58 <c_wraith> :kind TVar
10:20:07 <sproingie> yay hackage is back
10:20:09 <c_wraith> @kind TVar
10:20:10 <lambdabot> Not in scope: type constructor or class `TVar'
10:21:02 <Gracenotes> sproingie: \o/
10:21:39 <Perry__> c_wraith: I made a data type '   data TVar         = A Int deriving (Eq,Ord)'
10:22:19 <c_wraith> Perry__:  Oh.  There's a type in the STM library with the same name, hence my confusion
10:22:45 <Perry__> c_wraith: no problems, I'm just trying to write a simulation for the haskell type interpreter.
10:22:50 <Perry__> and...failing :P
10:29:23 <maltem> D'oh. I was wondering why I had a memory leak, and as it turned out, I had defined (>>=) in terms of fmap, and fmap in terms of (>>=).
10:29:53 <opqdonut> :)
10:30:06 <monochrom> haha
10:30:10 <maltem> But to some degree it worked, so I noticed very late.
10:31:13 <opqdonut> it's pretty rare that that sort of bugs is that subtle
10:31:24 <opqdonut> can we see the relevant pieces of code?
10:31:28 <xerox> evens = 0 : map (+1) odds; odds = map (+1) evens -- but it bootstraps :)
10:31:57 <opqdonut> yeah sure
10:32:01 <opqdonut> but that's correct
10:32:52 <maltem> ok, if you're interested - but I must reestablish what I had 5 minutes ago, so hold on a minute
10:33:11 <opqdonut> well only if it's interesting, of course :)
10:34:05 <maltem> oh not terribly. so I'll save me the trouble :P
10:35:09 <maltem> fwiw, the monad is   newtype CList r a = CList { unCList :: Cont r (Cell r a) };  data Cell r a = Nil | Cons a (CList r a)
10:35:09 <opqdonut> fine by me
10:36:01 <maltem> oh, I notice when I thought it worked, I was not really using my monad instance, but the Cont monad only
10:36:09 <opqdonut> ok
10:36:10 <maltem> that would explain it
10:36:24 <opqdonut> what are you using CList for?
10:37:25 <Perry__> Correct me if I am wrong: But the elements in a Map must  be an instance of Ord
10:38:22 <raichoo> Is there a haskell development environment for mac os snow leopard that you guys recommend?
10:38:50 <maltem> opqdonut, the idea is that you cannot by accident read data from a closed handle
10:39:06 <xerox> raichoo carbon emacs + haskell-mode is the best for me
10:39:25 <raichoo> xerox: Erm sorry, i ment a compiler package etc :)
10:40:04 <xerox> the GHC .pkg on haskell.org
10:40:46 <maltem> opqdonut, there is fromFile :: FilePath -> CList (IO a) ByteString, and the list can be consumed in a pure fashion by functions of type CList r foo -> Cont r bar
10:41:08 <sproingie> if you go the emacs route, i recommend adding flymake
10:42:26 <maltem> umph, now I must have introduced some different memory leak :/
10:43:01 <raichoo> Ok, thanks a lot. Can't wait to get started :D
10:46:31 <maltem> Gnah. (>>=) in terms of concatMap, concatMap in terms of concat, concat in terms of foldr, foldr in terms of (>>=) :(
10:46:42 <monochrom> ooohhh, HWN resumes!
10:47:05 <Perry__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15785#a15785 Is it possible for someone to have a quick look at the code?
10:47:15 <Perry__> The last line in module Check is broken
10:48:36 <copumpkin> maltem: nice
10:49:05 <monochrom> Perry__: Data.Map wants key type to be an Ord instance.
10:49:13 <koeien37> Perry__: Map wants the keys to be Ord instances
10:49:15 <maltem> or was I wrong again?
10:49:35 <monochrom> In fact, Data.Set wants element type to be an Ord instance too.
10:49:37 <koeien37> Perry__: the reason is that maps need to compare the keys, in order to have a sensible implementation of binary trees
10:49:39 * maltem shuts up now
10:49:43 <sproingie> Data.Map is based on trees so it needs Ord
10:49:55 <Perry__> monochrom, koeien37: hmmm that could be difficult.
10:50:05 <koeien37> oh no not at all
10:50:16 <Perry__> Since I can't just strap  'deriving (Ord)' on the back of the data type
10:50:22 <koeien37> add "deriving (Ord)" in ine 39
10:50:24 <monochrom> "data TVar = A Int" is very easy.
10:50:27 <sproingie> sure you can
10:50:37 <sproingie> Ord is one of those things you can automatically derive
10:50:52 <koeien37> Ord, Eq, Show, Read, Enum
10:50:54 <Ke> yay 3. level of do in code
10:50:55 <copumpkin> unless it's a gadt
10:51:34 <koeien37> which this is not
10:51:41 <koeien37> well, it's an ordinary ADT as well
10:51:43 <copumpkin> :)
10:52:22 <Perry__> koeien37: I do not have the permission from my professor to modify the Program module.
10:52:30 <koeien37> copumpkin: do you consider an ADT to be a GADT as well?
10:52:34 <copumpkin> definitely
10:52:44 <Perry__> Putting a deriving (Eq,Ord) would make life a lot easier
10:52:45 <koeien37> Perry__: ah. In that case, you can write   'instance Ord TVar' in the other module too
10:52:49 <copumpkin> I'd be quite happy dropping the regular ADT syntax actually
10:52:55 <koeien37> this is a tiny bit evil only
10:52:56 <copumpkin> I don't care about the extra repetition
10:53:12 <koeien37> copumpkin: I use it for existentials too
10:53:14 <copumpkin> yeah
10:53:15 <koeien37> the syntax, that is
10:53:19 <copumpkin> it's great
10:53:29 <copumpkin> I'm all for cleaning up the repetition in haskell
10:53:36 <copumpkin> I'd like a slightly cleaner syntax
10:53:38 <koeien37> Perry__: alternatively, you can use an association list instead.
10:54:23 <monochrom> association list would require Eq.
10:54:30 <Perry__> koeien37: I'll try the instance method
10:54:31 <koeien37> so you could write   instance Ord TVar where compare (T x) (T y) = compare x y
10:54:36 <koeien37> monochrom: ah yes, of course
10:55:02 <koeien37> generally, you want instances in the same module as the data type
10:55:28 <koeien37> but it is only very slightly evil. some consider it to be not evil at all
10:56:29 <koeien37> So I'd go ahead with writing an Ord instance
10:56:57 <copumpkin> preflex: seen ChilliX
10:56:58 <preflex>  ChilliX was last seen on #ghc 29 days, 6 hours, 55 minutes and 35 seconds ago, saying: sorry, bundled with gmp
10:57:01 <copumpkin> preflex: seen TacticalGrace
10:57:02 <preflex>  TacticalGrace was last seen on #haskell 5 days, 14 hours, 13 minutes and 12 seconds ago, saying: Axman6: yep that was the plan
10:57:30 <koeien37> Perry__: i don't know if this has been mentioned before, but writing "compare" only for the data type is enough
10:57:44 <copumpkin> @ask TacticalGrace how much more work would it take to integrate your student's llvm backend with GHC HEAD?
10:57:45 <lambdabot> Consider it noted.
10:58:24 <Perry__> koeien37: I'll try that, thank you.
10:58:26 * hackagebot upload: SourceGraph 0.6.0.2 - Static code analysis using graph-theoretic techniques. (IvanMiljenovic)
10:58:28 * hackagebot upload: palindromes 0.2 - Finding palindromes in strings (JohanJeuring)
10:59:26 <sproingie> satan oscillate my metallic sonatas
10:59:58 <copumpkin> @hackage palindromes
10:59:59 <lambdabot> http://hackage.haskell.org/package/palindromes
11:00:10 <copumpkin> are palindroms the roads that sarah built in alaska?
11:03:05 <Twey> I think you mean airports
11:05:06 <interferon> is it possible to pattern-match against an empty Seq?
11:08:00 <Twey> Yes
11:08:10 <mmorrow> interferon: no, since the constructors aren't exported. you use (\s -> case s of _ | Seq.null s -> .. | otherwise)
11:08:26 <mmorrow> (err, i took you to mean Data.Sequence)
11:09:17 <mmorrow> foo s | Seq.null s = ...
11:09:21 <mmorrow>      | otherwise = ..
11:09:34 <mmorrow> (that lambda is ugly :)
11:09:37 <koeien37> or maybe view patterns
11:09:39 <mmorrow> ooh
11:09:52 <dolio> The views have empty cases.
11:11:16 <interferon> yes i meant Data.Sequence
11:11:19 <interferon> what are view patterns?
11:12:18 <copumpkin> interferon: allow you to pattern match on the output of functions of bound variables from pattern matching
11:12:44 <harrisonpartch> once again, i have thought of a stupid question
11:13:03 <harrisonpartch> i cannot get many cabal packages to compile. yi for one
11:13:26 <harrisonpartch> i need something in "base" which i do not have
11:13:34 <maltem> Uh. looks like there isn't a non-strict foldr for CList
11:13:36 <harrisonpartch> neither can i install base from cabal
11:13:50 <harrisonpartch> this is on debian
11:13:50 <copumpkin> what's a CList?
11:13:57 <copumpkin> computable lists? :)
11:14:19 <maltem> copumpkin,  newtype CList r a = CList { unCList :: Cont r (Cell r a) };  data Cell r a = Nil | Cons a (CList r a)
11:14:29 <copumpkin> ooh
11:14:31 <maltem> heh, they should be computable too
11:14:46 <maltem> they're related Peaker's MLists
11:15:40 <Masxmasx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15786#a15786 couldn't match expected type `String -> Html' against inferred type `Html', where did I go wrong? I assume I can't apply a textarea like this?
11:16:02 <copumpkin> you forgot to apply the function
11:16:50 <copumpkin> by the way, I'd avoid absolute URLs :P
11:17:19 <Masxmasx> I am obliged to use it like this (university excersise)
11:17:25 <Masxmasx> how would I apply the function? :s
11:20:22 <Masxmasx> copumpkin? :)
11:20:41 <cads> afternoon all
11:20:43 <copumpkin> I don't know, you didn't give enough of the error message to tell what's broken and I don't use haskell html
11:20:45 <copumpkin> :)
11:21:47 <Ke> hatcron.hs:2:23: Module `System.Posix.IO' does not export `Fd(..)' http://hackage.haskell.org/packages/archive/unix/2.4.0.0/doc/html/System-Posix-IO.html
11:21:53 <Ke> what does that mean
11:22:03 <Ke> isn't Fd a type
11:22:04 <copumpkin> it doesn't export Fd
11:22:12 <copumpkin> it intentionally doesn't export it, I guess
11:22:23 <Ke> so omit the (..) ?
11:22:24 <copumpkin> or rather, it doesn't export the constructor
11:22:25 <copumpkin> yeah
11:22:29 <Ke> thanks
11:22:40 <Masxmasx> Couldn't match expected type String -> Html against inferred type Html in the expression: input ! [thetype "submit", value "Submit"] in the second argument of `<<<>', namely `[textfield ! [thetype "textarea", cold "5", ....], input ! [thetype "submit", value "Submit"]]'
11:22:55 <Ke> hatcron.hs:2:23: Module `System.Posix.IO' does not export `Fd' still
11:22:56 <Masxmasx> in the expression: form ! [...
11:24:13 <monochrom> textfield![blah] :: String->Html.
11:24:20 <monochrom> input![blah] :: Html.
11:24:31 <monochrom> Do you agree with my two inferences above?
11:24:38 <Masxmasx> ouch.
11:24:39 <Masxmasx> yes
11:25:35 <Masxmasx> how would I use a textfield then, if the type does not fit?
11:25:57 <monochrom> Fd is from System.Posix.Types
11:26:40 <monochrom> (textfield![blah]) "how are you my friend?"
11:26:47 <Twey> You can make it fit by providing a string to get an Html, Masxmasx
11:27:20 <Masxmasx> ah yes, thanks :)
11:27:34 <mux> IIRC, you can also have textfield "foo" ! [blah]
11:28:00 <Twey> For any ‘a -> b’, if you provide it an ‘a’ you'll get a ‘b’
11:28:03 <Twey> That's what a function is
11:28:31 <Twey> (including functions in ‘a’ and ‘b’)
11:30:57 <interferon> harrisonpartch: get the latest ghc
11:31:02 <interferon> harrisonpartch: i had that problem with yi as well
11:32:19 <Masxmasx> textarea[bla] :: Html -> Html, how would I input Html then?:s
11:32:48 <Masxmasx> and how/why would a textarea need html to be built
11:34:02 <mmaruseacph2> :t textarea[bla]
11:34:03 <lambdabot> Not in scope: `textarea'
11:34:03 <lambdabot> Not in scope: `bla'
11:34:20 <Masxmasx> import Text.Html
11:34:25 <Masxmasx> > import Text.Html
11:34:26 <lambdabot>   <no location info>: parse error on input `import'
11:35:06 <mmaruseacph2> i still don't know how to use lambdabot
11:35:17 <mmaruseacph2> though I'm here for nearly half a month
11:35:24 <mmaruseacph2> *year
11:39:08 <Botje> a textarea could contain .. text? :)
11:39:19 <Masxmasx> yes, but why in Html
11:39:33 <Masxmasx> textareas cant contain html
11:39:36 <Botje> probably because all other tags also want Html.
11:40:21 <Masxmasx> textarea [bla] (stringToHtml "bwa") doesn't help much though
11:40:47 <Botje> why not just textarea (stringToHtml "foo") ?
11:41:04 <ziman> @pl \xs -> map (take n) . take n
11:41:05 <lambdabot> const (map (take n) . take n)
11:41:11 <ziman> @pl \xs -> map (take n) . take n $ xs
11:41:12 <lambdabot> map (take n) . take n
11:41:28 <Botje> no need for the []
11:41:52 <Masxmasx> cause I need to set some parameters for the textarea
11:42:06 <Masxmasx> works fine when using textfields, but not area
11:42:44 <Masxmasx> but that works fine! thanks botje! :)
11:43:05 <Masxmasx> now to find out how to set height :)
11:43:52 <Ke> :t exitSuccess
11:43:52 <lambdabot> Not in scope: `exitSuccess'
11:45:04 <Ke> what's that type of the a in IO a of exit success http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/System-Exit.html
11:45:35 <koeien37> any
11:45:47 <koeien37> you may choose
11:45:57 <koeien37> there is an implicit universal quantification
11:46:02 <koeien37> forall a. IO a
11:46:13 <Ke> where does it get the value
11:46:23 <koeien37> well, the point of exitSuccess is that it does not return
11:46:28 <Ke> true
11:49:17 <Twey> So you can pretend it's whatever you like, since you'll never get to use the value anyway
11:50:11 <koeien37> maybe it would be better to have as value IO (forall a. a)
11:50:33 <koeien37> or IO Void
11:54:21 <Alpounet> isn't ghc 6.12* in arch's repos already ?
11:55:45 <merehap> after a pacman -Syu, I still have 6.10.4, if that answers your question...
11:56:03 <Alpounet> yeah it does, thanks merehap
11:56:22 <merehap> np
11:56:23 <Cale> Hmm, that's interesting. It seems that it would be natural to envision Haskell datatypes as the categories corresponding to the cpos we normally think of them as, because the fixed point theorem for functions and functors are actually the same thing :)
11:58:59 <HaskellLove> I am reading a book called "Thinking recursively" and it talks about beginners not having "recursive instinct" and talks about "recursive leap of faith" you need to learn to trust recursion. cool stuff... any related book recommendations are welcomed ;)
11:59:18 <Cale> In any chain complete category with an initial object 0 and continuous functor F, we can define a chain 0 -> F 0 -> F^2 0 -> ..., and take its limit to be the least fixed point of F.
11:59:27 <monochrom> Read books on divide-and-conquer.
12:00:26 <Cale> (heh, reading my comment as a response to HaskellLove makes it look kind of funny)
12:00:30 <monochrom> Everyone has divide-and-conquer instinct. To sum up 10 numbers, chop them into two bunches, maybe 5-5 but 1-9 is also good.
12:00:39 <Masxmasx> input ! [value "bla" name "foo" thetype "text"] works fine (textfield), but I can't get it working with textarea (stringToHtml "foo") ! [cols "5" row "5"], how would I do this?
12:01:24 <Cale> Masxmasx: are there supposed to be commas there?
12:01:40 <Masxmasx> where?
12:01:44 <Cale> Masxmasx: (which library are you using?)
12:01:56 <HaskellLove> monochrom can you recommend some specific you have on mind? divide-and-conquer is kinda too general i dont know what book to look for
12:02:03 <koeien37> there should be commas yeah
12:02:09 <Masxmasx> cale: Text.Html
12:02:16 <koeien37> input ! [value "bla", name "foo", thetype "text"]
12:02:35 <Cale> thought so
12:02:40 <monochrom> I don't know of one.
12:03:09 <Cale> I was thinking it was either that, or some bizarre continuation passing style trick.
12:03:19 <HaskellLove> i guess you were joking with me... nevermind
12:03:38 <Masxmasx> ahhh, thanks koeien37 & Cale!
12:04:03 <Ke> definition of forkProcess make for a sad pand
12:04:05 <Ke> a
12:04:23 <Cale> HaskellLove: I agree with the statement that people don't have recursion instinct exactly as much as I agree with the notion that people have no instinct for iteration.
12:05:16 <Cale> (which is to say, not a whole lot, but there's a bit of truth in it, in that people usually don't think in such precise terms)
12:05:56 <Cale> In fact, I think the closest thing in the programming world we have to the way people actually think is higher order functions.
12:07:16 <copumpkin> "do this to these"
12:07:25 <Cale> right, operations on collections
12:07:55 <Cale> Compare things like  "pick out all the yellow M&M's"  (filter isYellow)
12:08:01 <HaskellLove> ok i got myself recursion theory books will do some reading this week
12:08:22 <Cale> "wash all the dishes"  (map(M?) wash dishes)
12:08:32 <copumpkin> HaskellLove: recursion theory o.O
12:08:35 <copumpkin> BRING ON THE ZYGOHISTORMORPHIC PREPROMORPHISMS
12:08:40 <copumpkin> -R
12:08:52 <copumpkin> or are you talking about recursively enumerable functions?
12:09:02 <Cale> "glue these sticks together end to end"  (fold glue sticks)
12:09:06 <copumpkin> languages, I guess
12:09:30 <HaskellLove> Cale heh cool ;)
12:09:57 * Twey agrees with Cale.
12:10:08 <Twey> That's what made jQuery initially attractive, to me
12:10:23 <Twey> The ability to treat a whole bunch of things the same as a single thing, without having to manually iterate over them
12:10:25 <koeien37> maybe it's OO thinking
12:10:29 <DigitalKiwi> hi Twey
12:10:38 <Twey> Hi, DigitalKiwi o/
12:10:43 <koeien37> person.eat(pork, using=chopstick)
12:10:43 <monochrom> You know my barbeque joke. At a barbeque, a C programmer does not say or understand "put the sausages from the bag to the grill".
12:11:26 <DigitalKiwi> neither would an english teacher
12:11:30 <HaskellLove> Twey yeah Cale pointed that to me a loot and i think i improved since
12:11:34 <Cale> Well, maybe in part, but many OO languages miss a lot of the expressiveness of language by making higher-order things difficult.
12:13:38 <Athas> Oh man, Parsec's makeTokenParser can't handle similar block- and line-comment starts.
12:13:42 <Ke> so does anyone know whether STM TChans can be passed over forkProcess ?
12:13:43 <Athas> This smells like a lot of work.
12:14:03 <Ke> doesn't seem to crash, but doesn't do anything useful either
12:14:34 <copumpkin> Ke: I doubt it
12:14:44 <copumpkin> Ke: I don't really know how the GHC RTS likes being forked
12:15:00 <HaskellLove> functional programming is "all at once" and imperative is "one step at a time". imperative is closer and easier to the computer engineer, i guess that is why humanity does OO, probably we need to mature more in the field of computer science untill functional programming is a standard. I mean you could not start making a computer telling it, go fly to the moon, it first had to start, put this...
12:15:02 <HaskellLove> ...in the register, and then try not to give me errors and then do that and so on...
12:15:03 <Cale> At least in my mind, the ability to compose complicated verbs from simple ones is a way more important quality of language than the idea of associating nouns with particular collections of verbs and classifying nouns by the verbs which potentially apply to them.
12:15:15 <Ke> well there were warnings, but I really need to execute something
12:15:18 <copumpkin> but I seriously doubt you can use interthread communication mechanisms across processes unless they're doing strange thing :)
12:15:28 <copumpkin> +s
12:15:53 <Ke> copumpkin: well fork shares some parts of the memory at least as copy on write
12:15:58 <copumpkin> yeah, I know
12:16:06 <copumpkin> but as copy on write
12:16:13 <copumpkin> the parent process won't see that anymore
12:16:19 <copumpkin> that's why you have IPC
12:16:32 <copumpkin> or just use a file descriptor
12:16:35 <Ke> yup
12:16:44 <Ke> that's not atomic though
12:17:05 <copumpkin> why must you fork?
12:17:25 <monochrom> @hoogle forkProcess
12:17:25 <lambdabot> No results found
12:17:56 <Ke> to execute  a string
12:18:01 <Cale> Heh, I just had the idea of an object oriented programmer's dictionary of the English language, where every noun explicitly lists all the most common verbs it is used with.
12:18:21 <copumpkin> Ke: huh?
12:18:22 <monochrom> hahaha
12:18:23 <Cale> (perhaps we can save on pages with subclassing ;)
12:18:31 <copumpkin> hah
12:18:50 <Ke> copumpkin: as in cron executing things asynchronously
12:19:31 <copumpkin> Ke: but why does that need access to your channels? you have a process that can run an external process
12:20:21 <monochrom> Don't use TChan. Use posix pipes or stdin,stdout.
12:20:29 <Ke> I wanted to be able to have error handling in the main process, but I guess I can do that elsewhere
12:21:01 <lament> Cale: i'm sure Lojban has something like that
12:21:05 <Ke> well as I said it needs to be atomic or I'll need several channels
12:21:31 <Ke> hmm
12:21:33 <Ke> pipes
12:22:07 <Ke> but I guess I'll figure this one out, I have quite some placeholders right now
12:22:22 <copumpkin> Ke: that's what I meant by file descriptors. You can use a pipe or a socketpair
12:23:27 <gwern> @hoogle 'a -> [a] -> (a, [a])'
12:23:28 <lambdabot> Parse error:
12:23:28 <lambdabot>   --count=20 "'a -> [a] -> (a, [a])'"
12:23:28 <lambdabot>              ^
12:23:34 <gwern> @hoogle a -> [a] -> (a, [a])
12:23:35 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:23:35 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:23:35 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
12:23:50 * gwern scratches head. that seems wrong
12:24:45 <gwern> @hoogle break
12:24:46 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
12:24:46 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
12:24:46 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
12:25:25 <Masxmasx> !hoogle queryToArguments
12:25:29 <Masxmasx> @hoogle queryToArguments
12:25:30 <lambdabot> No results found
12:25:38 <gwern> > break (==4) [1..10]
12:25:39 <lambdabot>   ([1,2,3],[4,5,6,7,8,9,10])
12:25:42 <Masxmasx> :t hoogle queryToArguments
12:25:43 <lambdabot> Not in scope: `hoogle'
12:25:44 <lambdabot> Not in scope: `queryToArguments'
12:25:46 <gwern> > break (==4) [1,2]
12:25:48 <lambdabot>   ([1,2],[])
12:25:50 <Masxmasx> :t queryToArguments
12:25:51 <lambdabot> Not in scope: `queryToArguments'
12:25:52 <gwern> > break (==4) []
12:25:54 <lambdabot>   ([],[])
12:29:30 <Spockz> does someone know how I can alter the Text.Html output generation to let it create lowercase html tags? And proper html?
12:29:56 <c_wraith> Spockz: use Text.XHtml instead.  same api, better output
12:30:12 <Eduard_Munteanu> What should I use to query SQLite from Haskell? I don't want to go through ODBC.
12:30:15 <Spockz> c_wraith: aha!
12:30:52 <Spockz> c_wraith: but that one has a bug. Each closing > of a opening tag is on a newline
12:31:14 <c_wraith> Spockz: there are other render methods.
12:31:35 <c_wraith> Eduard_Munteanu:  http://hackage.haskell.org/package/haskelldb-hdbc-sqlite3
12:31:47 <Eduard_Munteanu> c_wraith, thanks.
12:32:04 <Eduard_Munteanu> I was unsure if HDBC meant it went through ODBC.
12:32:13 <c_wraith> No, it's a different mechanism
12:32:23 <Cale> Spockz: That is not a bug
12:32:41 <Eduard_Munteanu> Great, thanks.
12:32:42 <Cale> Spockz: That's an intentional trick to avoid problems with meaningful whitespace.
12:32:57 <Spockz> Cale: ah seriously? :p
12:33:27 <burp> seriously
12:33:56 <Cale> Yeah, because if you just stick a newline in the middle of a tag, it's text, and a tag which would otherwise have been empty will now contain at least one character.
12:34:09 <Spockz> that shouldn't be a problem as long as the inline element generators don't put extra newline in their content...
12:34:10 <Cale> So it puts all the whitespace that it generates in the inside of tags.
12:34:37 <Cale> It can also slightly change the placement of things.
12:34:41 <Spockz> so <inlinetag>content</inlinetag> instead of <inlinetag>\n{indent}content\n</inlinetag}
12:34:47 <Cale> (by putting a space between them)
12:35:07 <Spockz> Cale: that shouldn't happen with block tags :)
12:35:28 <Cale> Spockz: The problem isn't that it puts an actual newline. The problem is that it puts any whitespace at all.
12:35:41 <Cale> Using a space would have the same effect, and the same problem.
12:35:52 <Cale> (it slightly changes the meaning of the page)
12:36:08 <Spockz> in IE remember yes :p
12:36:13 <Spockz> but it's fine :p
12:36:24 <Cale> Well, it's just how HTML is specified.
12:36:32 <c_wraith> I seem to recall that toResponse dumps everything on one line?
12:36:45 <c_wraith> Or am I remembering a different api?
12:36:50 <Cale> Whitespace is compressed, but leading and trailing whitespace are not trimmed.
12:37:21 <c_wraith> html is so awful in so many ways.  >_>
12:37:33 <Spockz> Cale: okay. never run into that problem when doing my webwork for 5 years.. :p
12:38:58 <sshc> how do I get the directory in which the program lies?
12:39:44 <Cale> Spockz: put two img tags right up against each other, and then try putting a newline between them
12:39:52 <c_wraith> sshc:  that's *awfully* difficult to do correctly and portably.
12:39:53 <Cale> Spockz: and compare the results
12:40:22 <copumpkin> Spockz: anyway, what's the problem with the output? it doesn't match what you would write by hand?
12:40:37 <Ke> copumpkin: I guess pipes with flock would be what I wanted
12:41:02 <Spockz> copumpkin:  mostly that it reads odd :)
12:41:19 <sshc> c_wraith: I have a file that lies in the same directory as the executable, but I don't want to require the user to run the program from that directory only
12:41:24 <copumpkin> Spockz: if you look at the DOM of any regular page, it's full of hundreds of useless text nodes for whitespace between tags
12:41:48 <sshc> c_wraith: where should I put this file?
12:42:00 <c_wraith> sshc:  Is it user-editable?
12:42:08 <Spockz> Cale: yes, but those are inline elements
12:42:20 <Cale> Spockz: Of course, you're not supposed to read the generated HTML :P
12:42:32 <Cale> You read the Haskell program which generates it
12:43:16 <Spockz> until you have to debug some weird html thingy and you have to dive into the html Cale
12:43:27 <sshc> c_wraith: no
12:43:37 <copumpkin> Spockz: if you don't like it, don't use it :)
12:43:45 <copumpkin> or write a new pretty printer for it
12:43:47 <sshc> c_wraith: it's not stripctly necessary that I keep people from editing it, though
12:44:27 <c_wraith> sshc:  What I did in that case was use template haskell to compile it into the program...  Kind of a cheap hack.  Let me see if I can get reasonable path-finding behavior.
12:44:29 <sshc> c_wraith: it's pretty much a default configuration file, and users can override the configuration in ~/.appName/conf
12:44:52 <Spockz> copumpkin: good idea
12:44:58 <sshc> c_wraith: I'm using Data.ConfigFile
12:45:12 <Saizan_> sshc: you could use Cabal's data-files
12:45:15 <Twey> Spockz: At the level of Text.Html, you can see the output by looking at the program
12:45:24 <copumpkin> Spockz: Axman6 was writing another html outputter if I remember correclty
12:45:27 <Twey> It doesn't do clever transformations or anything
12:45:37 <luite> what is the correct way to make loading external libraries work with ghci on windows? I have libfreetype.dll.a, libfreetype.a and libfreetype6.dll, compiling with ghc --make testft.hs -lfreetype works fine (links with the dynamic library), but ghci complains that it cannot load the dll
12:45:56 <Saizan_> sshc: http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
12:46:14 <mreh> > 1%2 - 1%4
12:46:15 <lambdabot>   1 % 4
12:46:36 <mreh> is GHC unable to resolve a qualified type to an equivalent synonym?
12:47:00 <copumpkin> :t replicate 'a'
12:47:01 <lambdabot>     Couldn't match expected type `Int' against inferred type `Char'
12:47:01 <lambdabot>     In the first argument of `replicate', namely 'a'
12:47:01 <lambdabot>     In the expression: replicate 'a'
12:47:06 <copumpkin> :t replicate 5 'a'
12:47:08 <lambdabot> [Char]
12:47:09 <copumpkin> :t replicate 5 'a' :: String
12:47:09 <Saizan_> mreh: it should be able
12:47:10 <lambdabot> String
12:47:28 <copumpkin> :t print (replicate 5 'a')
12:47:29 <lambdabot> IO ()
12:47:35 <Cale> mreh: Type synonyms are just syntactic sugar, and are removed by one of the first desugaring steps.
12:47:46 <Cale> (unless you're talking about associated types)
12:47:58 <mreh> Cale: what is an associated type?
12:48:04 <copumpkin> a type function
12:48:22 <Cale> type declarations occurring inside class and instance definitions
12:48:28 <copumpkin> sometimes associated loosely with a typeclass
12:48:50 <Saizan_> turned on by TypeFamilies
12:49:11 <mreh> not using any of those
12:49:18 * gwern suddenly realizes: unionfind is a monoid
12:49:20 <nominolo> mreh: GHC tries its best to keep the type synonyms the user used
12:49:35 <mreh> but I have qualified the use of the type
12:49:51 <mreh> that wouldn't stop it resolving it though would it?
12:49:52 <nominolo> mreh: but, e.g, [Char] = String = FileName  -- which is GHC to use?
12:49:59 <Perry__> Hmm... still stuck on this problem http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15785#a15785 <- How would one make Tvar an instance of Ord without modifying the *module Program*, I had tried creating an instance Ord TVar but ultimately failed.
12:50:06 <monochrom> Don't worry until you have discovered a counterexample.
12:50:06 <nominolo> mreh: no, it should always resolve it, yes
12:50:16 <koeien37> Perry__: what was the instance that you tried to write?
12:50:27 <mreh> nominolo: it just resolves all of those to [Char]
12:51:11 <nominolo> :t "a"
12:51:12 <lambdabot> [Char]
12:51:25 <Perry__> koeien37:    instance Ord TVar where
12:51:25 <nominolo> :t ("a" :: String) ++ "c"
12:51:26 <lambdabot> String
12:51:35 <nominolo> seems to work
12:51:52 <Perry__> koeien37: and I removed everything after that since it doesn't work.
12:51:55 <koeien37> Perry__: yes, and then you need to write the "compare" function
12:52:02 <Perry__> koeien37: I think i'm on the right track, I wrote a compare function
12:52:06 <koeien37> good.
12:52:09 <koeien37> what is your definition?
12:52:25 <Perry__> That's the part I am unsure about
12:52:29 <Perry__> because
12:52:39 <Perry__>  data TVar         = A Int
12:52:39 <koeien37> did you figure out the type the compare function should be?
12:52:43 <monochrom> paste paste paste. if it's faulty still paste. <3 pasta.
12:52:56 <Perry__> There's no real numerical value to compare.
12:53:08 <koeien37> well, could you give a typical value of type TVar?
12:53:24 <nominolo> Perry__: LANGUAGE StandaloneDeriving then deriving Ord TVar
12:53:37 <koeien37> nominolo: I doubt that is the right way to go now
12:53:39 <nominolo> however, that should fail if it's not possible to write the instance manually
12:53:47 <koeien37> nominolo: it is
12:54:16 <Perry__> "well, could you give a typical value of type TVar?" <- Sorry I am not quite too sure what you meant there.
12:54:17 <danblick> Could anyone comment on the relationship between grammars and types?
12:54:19 <nominolo> ah, right it's just fmap compare
12:54:32 <koeien37> Perry__: do you know what the `A' means?
12:54:40 <koeien37> in data TVar = A Int
12:55:13 <Perry__> koeien37: I do believe that is just an arbitary data type.
12:55:19 <koeien37> ah no
12:55:27 <koeien37> that is probably the reason for your confusion :)
12:55:30 <koeien37> @src Maybe
12:55:30 <lambdabot> data Maybe a = Nothing | Just a
12:55:45 <koeien37> ^ Nothing and Just here are data constructors
12:55:45 <copumpkin> omnom
12:55:52 <Perry__> Ah.
12:56:00 <copumpkin> ADT = arbitrary datatype? :P
12:56:03 <Perry__> Curses, I should have known that.
12:56:07 <koeien37> so A 37 is a typical value of type TVar
12:56:20 <koeien37> you can pattern match on that in the compare function
12:56:26 <koeien37> compare (A x) (A y) = ...
12:56:48 <Perry__> Yep, that makes much more sense now.
12:57:13 <koeien37> type variables may occur too in data declarations, but they may not start with a capital
12:57:19 <nominolo> preflex: losers
12:57:28 <nominolo> preflex: users
12:58:00 <monochrom> maybe lusers
12:58:20 <nominolo> I used /names now
12:58:23 <koeien37> (the Maybe type is a good example of that)
12:58:41 <Perry__> Maybe, is either Nothing or the type after the Maybe keyword?
12:58:58 <koeien37> no
12:59:00 <copumpkin> not a keyword :)
12:59:08 <copumpkin> and it's wrapped in Just
12:59:13 <koeien37> a value of type Maybe a is either `Nothing', or a `Just a'
12:59:18 <koeien37> :t Just "Hello world!"
12:59:19 <lambdabot> Maybe [Char]
13:00:21 <koeien37> :t Nothing :: Maybe Integer
13:00:22 <lambdabot> Maybe Integer
13:00:26 * gwern rewrites a function into the Maybe monad and is shocked that it seems to work as I expected it to
13:00:32 <Veinor> :D
13:01:06 <koeien37> so you can use data constructors to pack values, and you can also pattern match on them.
13:01:24 <mreh> > 0 % 1 == 0
13:01:24 <koeien37> data Tree a = Leaf a | Branch (Tree a) (Tree a) -- maybe you have seen this definition before
13:01:26 <lambdabot>   True
13:01:46 <gwern>  unionSets 'u' 'a' $ insertSet (Set 5 "quux") $ insertSet  (Set 10 "foobar") emptyDS
13:01:49 <gwern> Just (DS [Set 5 "quuxfoobar"])
13:01:52 <gwern> huzzah
13:02:09 <Perry__> hmmm
13:02:17 <gwern> ask for "unionSets 'o' 'a'", though, and you get Nothing
13:02:38 <mreh> > let  f 0 = True; f _ = False in f (0%1)
13:02:39 <lambdabot>   True
13:03:22 <copumpkin> @check (\x -> x /= 0 ==> 0 % x == 0)
13:03:25 <lambdabot>   No instance for (Test.QuickCheck.Testable
13:03:25 <lambdabot>                     (Test.QuickCh...
13:04:44 <gwern> :i Monoid
13:04:55 <copumpkin> @src Monoid
13:04:56 <lambdabot> class Monoid a where
13:04:56 <lambdabot>     mempty  :: a
13:04:56 <lambdabot>     mappend :: a -> a -> a
13:04:56 <lambdabot>     mconcat :: [a] -> a
13:05:53 <knobo> Anyone who could show me a really basic simple example on how the continuation monad works?
13:06:13 <copumpkin> knobo: do you know how to write in CPS?
13:06:33 <gwern> > (\x -> mappend x mempty) 'a'
13:06:35 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
13:06:36 <lambdabot>    arising from a use o...
13:06:43 <gwern> > (\x -> mappend x mempty) 1
13:06:44 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:06:45 <lambdabot>    `Data.Monoid.Monoid a'
13:06:45 <lambdabot>  ...
13:06:46 <knobo> copumpkin: not sure.
13:06:52 <gwern> > ((\x -> mappend x mempty) 1) :: [Int]
13:06:54 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
13:06:54 <lambdabot>    arising from the literal `...
13:07:24 <copumpkin> knobo: the idea of CPS is that instead of returning a value from your function, you take an additional function parameter and call that function with the value you would have returned
13:07:55 <copumpkin> so instead of Int -> Int for a function (+1), you'd instead have Int -> (Int -> r) -> r
13:08:13 <copumpkin> in that, the (Int -> r) parameter is the continuation
13:08:15 <mreh> > 0%1 < 0
13:08:17 <lambdabot>   False
13:08:30 <copumpkin> and your function would add 1 to the first parameter and call the second parameter with the result
13:08:38 <copumpkin> knobo: make sense so far?
13:08:52 <knobo> copumpkin: I think so.
13:09:06 <mreh> why does non-negative wrapper reject 0?
13:09:15 <copumpkin> > let addOne n cont = cont (n + 1) in addOne 5 id -- use id to get the value out
13:09:17 <lambdabot>   6
13:09:24 <copumpkin> :t let addOne n cont = cont (n + 1) in addOne
13:09:25 <lambdabot> forall a t. (Num a) => a -> (a -> t) -> t
13:09:54 <copumpkin> knobo: so Cont takes care of that (a -> t) -> t thing for you, automatically
13:10:07 <copumpkin> because it's a fairly mechanical process to change a normal function to CPS
13:10:15 <gwern> > "" == ()
13:10:17 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:10:18 <lambdabot>         against inferred ty...
13:10:19 <gwern> > "" == []
13:10:20 <lambdabot>   True
13:10:33 <gwern> > [] `elem` ""
13:10:35 <lambdabot>   Couldn't match expected type `[a]'
13:10:35 <lambdabot>         against inferred type `GHC.Types...
13:10:36 * knobo contemplating
13:10:38 <copumpkin> knobo: although it's a fairly simple idea, you can do some neat things with it :)
13:10:53 <copumpkin> knobo: so Cont is actually just a wrapper for a function (a -> r) -> r
13:10:59 <copumpkin> nothing magic at all :)
13:11:33 <copumpkin> Cont r a, that is :)
13:12:31 <copumpkin> @src Cont
13:12:31 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
13:12:49 <copumpkin> knobo: you already know how monads work, right?
13:13:25 <knobo> copumpkin: yes
13:13:53 <copumpkin> can you see how you'd write return for Cont?
13:14:42 <knobo> copumpkin: just a sec..
13:15:15 <copumpkin> I realize I didn't actually give much of an intuition for what the Cont monad instance actually _does_, so I'd be happy to expand a bit if you're having trouble
13:15:16 <knobo> return \x -> x .... something.
13:16:06 <copumpkin> so return for Cont basically needs to give you a -> ((a -> r) -> r)
13:16:27 <knobo> return \x f -> f x ....maybe
13:16:54 <copumpkin> yep :)
13:17:14 <copumpkin> now before skipping to bind, maybe it's best to see what fmap would look like
13:17:25 <copumpkin> (and what it does)
13:17:54 <copumpkin> fmap :: (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
13:18:20 <gwern> @hoogle fold
13:18:21 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
13:18:21 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
13:18:21 <lambdabot> Data.IntSet fold :: (Int -> b -> b) -> b -> IntSet -> b
13:18:27 <gwern> @hoogle foldr
13:18:27 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
13:18:28 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
13:18:28 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
13:18:46 <alp> hi back
13:18:58 <monochrom> knobo: simple example: runCont (do { x <- return 5; return (x+4) }) id = 9.  In general runCont (do { x <- return 5; return (x+4) }) f = f 9.  This is a boring example because it doesn't use callCC.
13:19:59 <copumpkin> mmmm x <- return y ;)
13:20:38 <monochrom> If I had ContT State or something, I could do something more interesting than return.
13:20:40 <sfuentes> anyone know if and when are type signatures required in a function definition?
13:20:44 <sfuentes> newbie here
13:21:55 <monochrom> When colleagues demand it. When certain GHC extensions are used.
13:22:16 <c_wraith> When the Monomorphism Restriction strikes.
13:22:27 <mmorrow> , runCont id (do (x,o) <- labelCC 0; when (x < 4096) (jump (x+7) o); return x)
13:22:28 <lunabot>  4102
13:22:31 <mmorrow> weee
13:22:39 <mmorrow> (monadLib)
13:22:40 <Berengal> Alternatively, when the Monomorphism Restriction is turned off but you want monomorphism
13:22:50 <copumpkin> I prefer epic morphisms
13:23:06 <Berengal> zygohistomorphic prepromorphisms ftw
13:23:30 <copumpkin> http://en.wikipedia.org/wiki/Epimorphism :)
13:23:34 <Berengal> Would constrained polymorphism be olimorphism?
13:23:53 <Twey> Haha
13:23:54 <mmorrow> copumpkin: so epic
13:24:00 <Perry__> hm. Is there a way to create an instance where it is both an instance of Eq and Ord?
13:24:11 <copumpkin> Perry__: deriving (Eq, Ord)
13:24:16 <Perry__> e.g. instance Eq Ord datatype
13:24:26 <monochrom> No, write separately.
13:24:26 <copumpkin> mmorrow: yeah, category theory is pretty epic
13:24:30 <Perry__> copumpkin: without using deriving sorry.
13:24:35 <c_wraith> Perry__: not simultaneously.
13:24:42 <mpiechotka> @pl withCString n (\s -> withForeignPtr ifreq (\p -> open_tap_if s p))
13:24:42 <lambdabot> withCString n (withForeignPtr ifreq . open_tap_if)
13:24:46 <c_wraith> Perry__: it'll take two declarations.
13:24:47 <Perry__> monochrom: oh ok.
13:24:57 <copumpkin> mpiechotka: funny you should mention withCString when we were talking about Cont!
13:24:58 <Perry__> so instance eq datatype where....
13:25:02 <Perry__> and instance ord datatype where...
13:26:32 <mmorrow> instance (Eq a) => Eq (Maybe a) where Just a==Just b = a==b; Nothing==Nothing = True; _==_ = False
13:27:06 <mmorrow> instance (Ord a) => Ord (Maybe a) where compare (Just a) (Just b) = compare a b; ...
13:27:22 <mmorrow> @src Maybe (>>=)
13:27:22 <lambdabot> (Just x) >>= k      = k x
13:27:23 <lambdabot> Nothing  >>= _      = Nothing
13:27:28 <mmorrow> @src Maybe return
13:27:28 <lambdabot> return              = Just
13:27:44 <mmorrow> instance Monad Maybe where ..
13:35:00 <mreh> > second (const 3) (1,2)
13:35:01 <lambdabot>   (1,3)
13:35:13 <mreh> is that idiomatic?
13:35:59 <ben0x539> Beats flip (,) 3 . fst, I guessss
13:36:01 <copumpkin> (,3) . fst
13:36:20 <copumpkin> Cale: any chance of updating lambdabot to 6.12? :)
13:36:24 <raceRider> I need to split a string that has the broken pipe (0xA6, ASCII 166) as the delimiter. The usual string replacement is not working. Should I use UTF8 or something?
13:36:40 <ben0x539> ASCII does not go up to 166
13:37:18 <ben0x539>   TargetType fuck_me_cast(const SourceType& s) {
13:37:18 <ben0x539>     return reinterpret_cast<const TargetType&>(s);
13:37:18 <ben0x539>   }
13:37:21 <ben0x539> ... urgh
13:37:35 <ben0x539> I have no idea how that got into my clipboard, apologies
13:37:35 <ben0x539> Sorry for the C++, I mean.
13:37:37 <Eduard_Munteanu> Does anyone know example code for using HDBC's SQLite interface?
13:37:46 <copumpkin> URGH MY EYES
13:37:48 <koeien37> interesting choice of identifiers
13:37:49 <raceRider> sure
13:37:54 <\toothrot> fuck_me_cast
13:37:56 <\toothrot> nice.
13:38:05 <Twey> > (second . const) 3 (1, 2)
13:38:06 <lambdabot>   (1,3)
13:38:14 <Twey> :t second . const
13:38:15 <lambdabot> forall b c d. c -> (d, b) -> (d, c)
13:38:25 <ben0x539> > takeWhile (/= '¦') "toot¦toot¦toot"
13:38:27 <lambdabot>   "toot"
13:38:33 <Twey> @hoogle c -> (d, b) -> (d, c)
13:38:34 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:38:35 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
13:38:35 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
13:38:58 <Twey> Hm
13:38:59 <Twey> I guess not
13:39:09 <raceRider> ben0x539, want to replace with comma or something though
13:39:10 <copumpkin> it's not really that common
13:39:10 <Twey> I seemed to remember there being an operator for that in Control.Arrow
13:39:20 <monochrom> raceRider: I wonder if you really have 0xA6 in your string.
13:39:21 <copumpkin> to throw a component out like that
13:39:24 <Cale> copumpkin: I think I'll wait for platform to be released, at which point things will hopefully be sufficiently installable that it should be easyish.
13:39:24 <ben0x539> raceRider: what are you doing to that effect?
13:39:28 <ben0x539> Is it a bytestring or something funny?
13:39:35 <copumpkin> Cale: ah okay :)
13:39:59 <raceRider> monochrom, yes I do. It's a capture file where everything is in straight ascii except the delimiter
13:40:09 <Saizan_> ?type (<$)
13:40:11 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
13:40:27 <Twey> Ah
13:40:29 <Saizan_> > 3 <$ (1,2)
13:40:31 <lambdabot>   (1,3)
13:40:40 <Twey> But for the left?
13:41:04 <Saizan_> no love for the left
13:41:10 <monochrom> > break ('\xa6' ==) ['a', 'b', '\xa6', 'z', 'y']
13:41:11 <lambdabot>   ("ab","\166zy")
13:41:16 <monochrom> Works.
13:41:19 <ben0x539> One would think that flip (<$) would do the job...
13:42:04 * Berengal misses gtk2hs
13:42:08 * ben0x539 too
13:42:26 <Berengal> Anyone tried qtHaskell?
13:42:26 <Saizan_> > (uncurry . flip . curry $ (3 <$)) (1,2)
13:42:28 <lambdabot>   (2,3)
13:42:30 <raceRider> ben0x539, made a simple recursion to replace each char when eq 0xA6, and I get an error "___hscore_d_name" or some such
13:43:09 <ben0x539> That is a funny error
13:43:38 <Saizan_> try compiling instead of using ghci
13:44:00 <monochrom> > map (\c -> if c=='\xa6' then ',' else c) ['a', 'b', '\xa6', 'z', 'y']
13:44:01 <lambdabot>   "ab,zy"
13:44:04 <monochrom> still works
13:44:21 <Saizan_> raceRider: and can you paste your test code?
13:44:23 <copumpkin> phyrex1an: into MTG? :)
13:44:44 <raceRider> Saizan_: paste right here?
13:45:03 <koeien37> ?hpaste
13:45:03 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:45:04 <Saizan_> raceRider: a Char is supposed to contain an unicode codepoint, but if you're reading data via IO you've to make sure the right decoding is happening
13:45:19 <Saizan_> raceRider: on the pastebin lambdabot linked just now
13:47:04 <raceRider> Saizan_: just pasted
13:47:22 <koeien37> link?
13:47:25 <jneira> hi people..i'm blocked with a problem of my univ book of declarative programming in haskell
13:47:34 <Eduard_Munteanu> What's the difference between HDBC and HSQL packages?
13:48:07 <jneira> it is simply an implement of "nub" that works with infinite lists
13:48:09 <raceRider> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6004
13:48:40 <Saizan_> raceRider: do you have an example of why that code doesn't do what you want?
13:48:47 <Saizan_> raceRider: it looks fine
13:49:22 <jneira> removeDuplicates $ repeat 2 -> [2]
13:49:24 <raceRider> Saizan_: try this line > repPipe 'a¦b'
13:49:35 <jneira> is it possible?
13:49:44 <koeien37> jneira: no.
13:49:45 <Berengal> jneira: No, not really
13:49:53 <jneira> uf
13:49:59 <koeien37> (repeat 2) ++ [37], or (repeat 2)
13:50:01 <copumpkin> jneira: it's possible if you drop purity
13:50:03 <koeien37> how can you distinguish these?
13:50:05 <jneira> jeroem fokker thinks it is
13:50:17 <copumpkin> jneira: okay?
13:50:31 <jneira> what?
13:50:49 <jneira> drop purity?
13:50:58 <Saizan_> @let repPipe [] = []; repPipe (x:xs) = if x == chr 166 then chr 44 : repPipe xs else x : repPipe xs
13:50:59 <lambdabot>  Defined.
13:51:08 <Saizan_> > repPipe "a¦b"
13:51:10 <lambdabot>   "a,b"
13:51:12 <monochrom> > chr 44
13:51:13 <lambdabot>   ','
13:51:15 <EvanR> dammit. i keep trying to write c code, and running into situations where i want a state monad, a maybe monad, and for crying out loud, a list
13:51:16 <Twey> 21:48:59 < jneira> removeDuplicates $ repeat 2 -> [2]
13:51:18 <copumpkin> jneira: you step outside of haskell into the land of impurity :)
13:51:21 <Saizan_> raceRider: seems to work
13:51:29 <jneira> ah ok
13:51:32 <Twey> It's possible, but the [2] will take forever to evaluate ;)
13:51:34 <raceRider> Saizan_ I see that it works for you!
13:51:40 <jneira> imperativeness
13:51:41 <Berengal> Not only purity, but I think you'll have to surrender portability as well
13:51:46 <copumpkin> GHC will let you see that repeat 2 is actually a circular list
13:51:50 <copumpkin> and then you can shorten it
13:51:52 <Saizan_> raceRider: which version of ghc are you using?
13:52:00 <jneira> mmm
13:52:05 <Masxmasx> Network.Shed.Httpd has a function queryToArguments, that should grab the entry from a Post field, but how do I use this? type is String -> [(String, String)]. I assume input is the fieldname, but why does it output [(String, String)] :s?
13:52:08 <koeien37> reallyUnsafePointerEq ?
13:52:09 <Berengal> And you need to know exactly what you're looking for
13:52:22 <copumpkin> koeien37: or just stable pointers, or something like vacuum
13:52:27 <copumpkin> stable names, even
13:52:45 <koeien37> yeah but you'd have to be lucky
13:52:54 <Berengal> What was the contract of stable names?
13:53:06 <Berengal> That unequal names were guaranteed to be different?
13:53:09 <raceRider> 6.10.4, I also checked on 6.10.1
13:53:20 <copumpkin> Berengal: they'll be equal if resulting from the same call on the same value
13:53:37 <copumpkin> koeien37: vacuum is pretty good
13:53:41 <Saizan_> raceRider: what do you get as output, btw?
13:54:02 <raceRider> Saizan_: may be related to my GHC on a Mac. I'll post my output in pastebin in a second
13:54:14 <copumpkin> formalistfag: o.O
13:54:20 <jneira> mmm the exercise talks about a removeDup that works with infinite lists
13:54:22 <ziman> i have functions working with Ord a => [a] (they insert the elements into a map and move them around); would it yield any performance gain to {-# SPECIALIZE #-} them?
13:54:28 <copumpkin> jneira: can I see it?
13:54:35 <jneira> isnt repeat 2 a infinite list?
13:54:39 <monochrom> Is that supposed to be an insult to us formalists? :)
13:54:45 <Berengal> jneira: nub "works" with infinite lists
13:54:48 <copumpkin> > nub ([0..] >>= replicate 2)
13:54:50 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:54:50 <Berengal> > nub [1..]
13:54:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:54:52 <copumpkin> :)
13:55:06 <Saizan_> raceRider: i think ghci expects input/output to happen in utf8, so you need your terminal to be using that too
13:55:09 <Berengal> > nub (repeat 2)
13:55:13 <copumpkin> it just gets progressively slower
13:55:14 <lambdabot>   mueval: ExitFailure 1
13:55:20 <jneira> jum
13:55:30 <copumpkin> papermachine: O.o
13:55:38 <c_wraith> @src nub
13:55:38 <lambdabot> nub = nubBy (==)
13:55:45 <c_wraith> @src nubBy
13:55:45 <lambdabot> nubBy eq []             =  []
13:55:45 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:55:46 <jneira> ok repeat is a circular list and [1..] a infinite list
13:55:46 <jneira> juass
13:55:54 <Berengal> Saizan_: iirc, 6.10 expects ascii, while 6.12 expects utf8
13:56:01 <Saizan_> > head (nub (repeat 2))
13:56:02 <copumpkin> jneira: you don't know it's circular
13:56:03 <lambdabot>   2
13:56:16 <copumpkin> jneira: it's just infinite for anyone inside haskell :)
13:56:16 <jneira> mmm
13:56:26 <Saizan_> Berengal: i've used symbols outside of ascii in the ghci prompt way before 6.12
13:56:30 <Berengal> jneira: There aren't circular lists in haskell. Well, you can't tell the difference
13:56:41 <Berengal> Saizan_: Yes, but not in IO
13:56:47 <Perry__>  "Cannot use type synonym in instance head" <- Has anyone ran into that error before?
13:56:49 <jneira> mm
13:56:57 <xerox> Perry__ yes you need a newtype or a data
13:57:02 <Saizan_> Berengal: by input/output i meant the repl one
13:57:07 <koeien37> Perry__: it means that you write    instance Class TypeSynonym
13:57:08 <raceRider> Saizan_: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6005#a6005
13:57:10 <Saizan_> Berengal: R and P :)
13:57:19 <Twey> 6.12 introduces automatic recoding
13:57:19 <koeien37> e.g. if you have type T = U, you said instance C T, instead of instance C U
13:57:34 <Twey> Whereas in .10 one had to manually encode/decode where necessary
13:57:35 <koeien37> there is a langauge extension so that you can use it
13:57:36 <Berengal> Saizan_: Ah, R/P, not I/O
13:57:41 <monochrom> Eh? ghc 6.10.4 uses iso-latin-1.
13:57:49 <Twey> Really?  Ew
13:57:58 <Masxmasx> Network.Shed.Httpd has a function queryToArguments, that should grab the entry from a Post field, but how do I use this? type is String -> [(String, String)]. I assume input is the fieldname, but why does it output [(String, String)] :s?
13:58:18 <Saizan_> raceRider: what happens with just "a¦b" ?
13:58:30 <xerox> koeien37 you can instance Class TypeSynonym with the appropriate extension, you can't TypeSynonym a and instance Class TypeSysnonym
13:58:32 <raceRider> Saizan_: I get a?b
13:58:36 <Berengal> Masxmasx: I assume the output is a simple assoclist, which is just a basic kind of map
13:58:40 <raceRider> ? instead of comma
13:58:44 <koeien37> xerox: you can't partially apply type synonyms
13:58:49 <Twey> Yes, but why?
13:59:00 <Perry__> Since what I have now is a type.
13:59:07 <Masxmasx> Berengal: how would I use that? I don't even know what assoclists are :$
13:59:09 <Twey> HTTP POST only allows a single field's value to be at most [String]
13:59:14 <Berengal> Masxmasx: And the input looks like it should be the entire form request then
13:59:17 <xerox> koeien37 oh drag. that's why, you can't partially apply then *anywhere*?
13:59:19 <ziman> i think you would get undecidable types
13:59:22 <Twey> Masxmasx: An assoclist is just a list of pairs
13:59:25 <Saizan_> raceRider: what do you get if you just say "a¦b" at the prompt?
13:59:32 <koeien37> xerox: correct
13:59:32 <Twey> Where the first element of the pair stands for a key and the second for a value
13:59:34 <copumpkin> xerox: it would amount to adding arbitrary type functions to the language
13:59:45 <copumpkin> xerox: something conor argued for last week :)
13:59:53 <copumpkin> but it breaks inference
13:59:56 <xerox> and would that be ... bad? :)
14:00:04 <Twey> > lookup 5 [(1, "foo"), (3, "bar"), (5, "baz")] -- E.G.
14:00:06 <lambdabot>   Just "baz"
14:00:14 <xerox> I like inference.
14:00:17 <copumpkin> xerox: I'd like it to be an option at least
14:00:22 <ziman> Twey, http://kyberia.sk/id/4432031
14:00:22 <Saizan_> copumpkin: where was he arguing this?
14:00:24 <raceRider> Saizan_: I get "a?b" including the " marks
14:00:25 <Berengal> Masxmasx: assoclist is short for association list, which gets its name from the fact that it is a list of associated values, aka. pairs
14:00:32 <copumpkin> Saizan_: on haskell-cafe, let me dig up the post
14:00:43 <monochrom> ghci probably does utf8 but ghc getChar iso-latin-1. This is 6.10.* and before.
14:00:52 <Saizan_> raceRider: ok, i think it's a problem with your terminal then
14:01:01 <Saizan_> raceRider: make sure it uses utf8
14:01:17 <raceRider> Saizan_: How to make sure utf8?
14:01:24 <Twey> ziman: I don't think that was intended for me
14:01:31 <Twey> (though it's certainly interesting)
14:01:33 <Masxmasx> Berengal: I see, so what do you suggest I do to get the postdata from the form? Excersise says use queryToArguments, but this only confuses me
14:01:35 <copumpkin> Saizan_: http://groups.google.com/group/fa.haskell/browse_thread/thread/7421a0fc832e679e
14:01:45 <Saizan_> raceRider: i don't know, it depends on the terminal, and i've never used a mac one
14:01:51 <ziman> Twey, oops, sorry
14:02:01 <monochrom> My perspective and gripe is that raceRider's file format is iso-latin-1 too, so everything you demostrate in ghci is irrelevant.
14:02:24 <raceRider> Saizan_: yes, terminal is UTF8, I can see all strange characters. But not from GHC or GHCI.
14:02:25 <Saizan_> raceRider: however, as another test, you could put something like  test = repPipe "a¦b" in your source file
14:02:32 <Saizan_> raceRider: and then evaluate test at the prompt
14:02:34 <Berengal> Masxmasx: queryToArguments probably needs the entire request data, or at least the request body. It parses it for you and gives you a map in return. At least that's what I assume, but you should read the documentation
14:02:44 <Berengal> Masxmasx: Also, take a look at the prelude lookup function
14:02:48 <Berengal> @type lookup
14:02:49 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:02:59 <raceRider> Saizan_l: let me try that
14:03:11 <Masxmasx> Berengal: there is barely any documentation
14:05:06 <raceRider> Saizan_:     lexical error in string/character literal (UTF-8 decoding error) is what I get when I use a text string in the source.
14:05:18 <xerox> What is the newsgroup fa.haskell?
14:06:12 <Saizan_> raceRider: then it seems you're not inserting utf8 in your file
14:06:55 <raceRider> Saizan_: is there a way to save the source hs file in utf8 format?
14:07:50 <Saizan_> raceRider: depends on your editor
14:08:28 <raceRider> Saizan_: Emacs is my editor now, but will ghc compile?
14:09:10 <Twey> raceRider: Really, you should probably be using UTF-8 as your platform locale default
14:10:58 <raceRider> just checked, UTF-8 is indeed the default. Looks like we are back to GHC issues. Earlier there was comment about GHC and latin characters not working.
14:12:38 <tibbe> dons: hey!
14:15:20 <tibbe> dcoutts: yt?
14:17:35 <knobo> copumpkin: I could use cont to do parsing. (though I've read about other things that is better)
14:18:47 <aledge> has anyone successfully installed GLFW from hackage under os x
14:18:48 <knobo> copumpkin: for example "read a token of type a, if that fails, restart and read a token of type b"
14:18:52 <aledge> ?
14:23:37 <raceRider> > repPipe "a¦b"
14:23:38 <lambdabot>   "a,b"
14:25:23 <Veinor> @src repPipe
14:25:24 <lambdabot> Source not found. I feel much better now.
14:25:38 <raceRider> > repPipe "a¦b¦b¦b¦b"
14:25:39 <lambdabot>   "a,b,b,b,b"
14:26:28 <copumpkin> knobo: you could, probably :)
14:27:47 <phr> @seen roconnor
14:27:48 <lambdabot> Unknown command, try @list
14:27:55 <phr> @last roconnor
14:27:56 <lambdabot> No module "roconnor" loaded
14:28:00 <phr> how do you do that?
14:28:26 <ben0x539> preflex: seen roconnor
14:28:26 <preflex>  roconnor was last seen on #haskell 18 hours, 27 minutes and 14 seconds ago, saying: jlouis: google `three way merge pushout' yields lots of interesting hits
14:28:35 <phr> tx
14:34:03 <sinelaw> preflex: seen PeakerWork
14:34:04 <preflex>  PeakerWork was last seen on #haskell 4 hours, 28 minutes and 46 seconds ago, saying: aavogt: Well, when you apply a function - it finds the result type on its own (that of the function) :)  And when you use polymorphic functions (e.g: Operators in C, or templated functions in C++), it has to actually infer the expression's result type, and it does
14:34:05 <sinelaw> preflex: seen Peaker
14:34:05 <preflex>  Peaker was last seen on #haskell-blah 5 days, 6 hours, 48 minutes and 28 seconds ago, saying: also have been programming for fun since age 10 or so
14:40:25 <koeien37> I love how I can easily refactor my program by changing some stuff and chasing type errors <3
14:41:29 <chrisdone> koeien37: naughty
14:41:29 <Alpounet> what do I have to install to have the 'lambda' char displayed, pretty arrows, etc working with haskell-mode in my emacs ?
14:42:08 <chrisdone> @google emacswiki pretty lambda
14:42:11 <lambdabot> http://www.emacswiki.org/emacs/PrettyLambda
14:42:11 <lambdabot> Title: EmacsWiki: Pretty Lambda
14:42:27 <Alpounet> thanks !
14:42:42 <chrisdone> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Unicodifying_symbols_.28Pretty_Lambda_for_Haskell-mode.29
14:42:44 <Axman6> koeien37: that's often what i do, but it makes for hacky fixees :(
14:42:45 <Twey> Alpounet: Turn it on using customize-group haskell
14:42:55 <koeien37> Axman6: in this case it's not so bad
14:43:04 <Axman6> -e
14:43:31 <phr> @pl (\(x1,y1) (x2,y2)->x1-x2==y1-y2)
14:43:32 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (-)) . flip . (((.) . (==)) .) . (-))
14:43:37 <phr> blecch
14:43:52 <Alpounet> thanks all
14:44:54 <medfly> lol
14:45:13 <medfly> Twey: DO YOU STILL THINK THAT'S BETTER/
14:45:14 <merehap> looks readable to me phr, I say go with it :)
14:45:43 * Axman6 *stabs* merehap 
14:45:47 <koeien37> (==) `on` uncurry (-) or so ?
14:46:03 <koeien37> ah no absolutely not
14:46:28 <Twey> Hahahaha
14:46:30 <Axman6> needs a... transpose or sumfin....
14:46:46 <Arxor> hey,, queryToArguments :: String -> [(String, String)] will return a list of tupels which contains strings. What are the contents of those Strings?
14:46:49 <Twey> Hmm
14:46:55 <Twey> There's a better way of writing that, I think
14:47:04 <Twey> :t \(x1,y1) (x2,y2)->x1-x2==y1-y2
14:47:05 <lambdabot> forall t. (Num t) => (t, t) -> (t, t) -> Bool
14:47:54 <Axman6> Arxor: you tell us
14:47:58 <Twey> :t liftM2 (==) . (uncurry subtract *** uncurry subtract)
14:48:00 <lambdabot> forall a a1. (Num a1, Monad ((,) a), Num a) => ((a, a), (a1, a1)) -> (a, a1) -> (a, Bool)
14:48:22 <phr>  ((==)`on`(uncurry (-))) works
14:48:24 <Twey> No, that's not it… is it?
14:48:26 <Twey> Oh, yeah
14:48:27 <Twey> on
14:48:30 <merehap> Twey: needs more flips
14:48:43 <Twey> :t (==) `on` uncurry subtract
14:48:44 <lambdabot> forall a. (Num a) => (a, a) -> (a, a) -> Bool
14:48:50 <Twey> There you go
14:48:51 <koeien37> phr: it works, but it's not exactly the same as your function
14:48:56 <phr> hmm
14:49:01 <koeien37> x1-x2 == y1-y2
14:49:08 <koeien37> the other is x1-y1 == x2-y2
14:49:15 <koeien37> which is in practice the same
14:49:24 <Twey> Oh, I missed that
14:49:25 <Twey> But yeah
14:49:35 <phr> hmm, maybe i got it wrong the first time
14:49:40 <Twey> I suspect so
14:49:43 <koeien37> and subtract is different again
14:49:44 <Twey> Would seem to make more sense
14:49:50 <Twey> koeien37: Huh?
14:49:52 <Twey> It shouldn't be.
14:49:56 <koeien37> subtract = flip (-)
14:50:01 <Twey> Huh.
14:50:02 <Twey> Why?
14:50:08 <koeien37> > subtract 3 2
14:50:09 <lambdabot>   -1
14:50:13 <Saizan_> > subtract 1 2
14:50:14 <Twey> :t (==) `on` uncurry (flip subtract)
14:50:14 <lambdabot>   1
14:50:15 <lambdabot> forall b. (Num b) => (b, b) -> (b, b) -> Bool
14:50:20 <Twey> There, then!  :þ
14:50:30 <luite> > map (subtract 2) [1..5]
14:50:32 <lambdabot>   [-1,0,1,2,3]
14:50:33 <koeien37> if you're working in a group, it's ok
14:50:55 <koeien37> abelian may be necessary
14:52:38 <Axman6> heh, doing a course with Arxor?
14:52:42 <Axman6> whoops
14:53:15 <Masxmasx> =)
14:54:29 <copumpkin> omg a TacticalGrace
14:55:08 <TacticalGrace> hey copumpkin
14:55:08 <lambdabot> TacticalGrace: You have 1 new message. '/msg lambdabot @messages' to read it.
14:55:12 <copumpkin> :)
14:55:59 <TacticalGrace> re your question
14:56:10 <TacticalGrace> the code is already based on HEAD
14:56:20 <TacticalGrace> it's a matter of cleaning things up
14:56:24 <TacticalGrace> which David is doing
14:56:27 <copumpkin> oh nice
14:56:42 <copumpkin> I'm impressed, most undergrad projects just kinda die after the grade is in :P
14:56:55 <copumpkin> and even grad projects :)
14:57:10 <TacticalGrace> he is pretty committed and I want the stuff in HEAD
14:57:23 <copumpkin> yay
14:57:49 <TacticalGrace> rl wants it, too, to get better register alloc for DPH
14:58:02 <copumpkin> have any of you had a chance to try using it to generate code for other archs? or for JIT?
14:58:15 <TacticalGrace> nope
14:58:33 <TacticalGrace> David originally meant to try x86_64 (Linux), too
14:58:38 <TacticalGrace> but didn't have the time
14:58:40 <copumpkin> ah
14:58:52 <copumpkin> I imagine that's a fairly simple change to parameters for the llvm code generator?
14:58:57 <TacticalGrace> but once it is in the head, I think there are quite a number of qorthwhile follow-on projects
14:59:26 <TacticalGrace> the llvm backend needs a custom calling conventions in LLVM
14:59:31 <copumpkin> oh
14:59:42 <TacticalGrace> and unfortunately, the way llvm is set up, you need to modify llvm for that
14:59:50 <copumpkin> I see
14:59:53 <TacticalGrace> llvm doesn't support register pinning
15:00:18 <TacticalGrace> on the other hand, the custom calling convention means that we have more registers as temps, which is good
15:00:21 <copumpkin> TacticalGrace: have the LLVM people been convinced that it's a worthwhile addition, or will this be a custom patch to LLVM forever (i.e., not in their main tree)?
15:00:53 <TacticalGrace> I don't think it makes sense for the calling conv to go into their tree
15:00:58 <TacticalGrace> it is GHC specific
15:01:06 <TacticalGrace> but I don't think that is a problem
15:01:17 <TacticalGrace> it's just how llvm works
15:01:26 <copumpkin> I'd imagine it might be worthwhile for them to allow some way of overriding calling conventions in general?
15:01:34 <copumpkin> but probably not a high priority
15:01:37 <TacticalGrace> yeah, that'd be good
15:02:24 <TacticalGrace> the impression I got is that they know it is an issue
15:02:42 <TacticalGrace> but as you are saying, nobody could be bothered to fix it yet
15:03:05 <copumpkin> edwardk told me a couple of months ago that he'd spoken to some LLVM guys and had convinced them that several things that GHC needed in LLVM were worthwhile in general
15:03:15 <copumpkin> but I'm not sure how influential those people were :)
15:03:32 <TacticalGrace> hmm, what does GHC need?
15:03:49 <TacticalGrace> (pinned registers are not worth the trouble IMHO)
15:04:02 <copumpkin> TacticalGrace: well, maybe not GHC in particular, but I think he was referring to Lemmih's complaints about LLVM when he was looking for a codegen for LHC
15:04:06 <TacticalGrace> (and the whole tables next to code thing doesn't convince me anymore either)
15:04:32 <TacticalGrace> I don't think Lemmih's issues bothered us
15:04:37 <copumpkin> ah ok
15:05:39 <TacticalGrace> iirc from a conversation with Lemmih, he didn't take a custom calling convention into account
15:05:58 <sinelaw> > Nothing `mappend` Just 3
15:05:59 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:06:00 <lambdabot>    `GHC.Num.Num a' arising ...
15:06:06 <sinelaw> > Nothing `mappend` Just 'a'
15:06:07 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
15:06:07 <lambdabot>    arising from a use o...
15:06:14 <copumpkin> > Nothing `mappend` Just (Sum 3)
15:06:15 <lambdabot>   Just (Sum {getSum = 3})
15:06:16 <TacticalGrace> that just solves most problems and it does so in an elegant and helpful way (as you get the extra temps)
15:06:23 <Lemmih> Calling conventions have nothing to do with my beef with LLVM.
15:06:25 <copumpkin> > Nothing `mplus` Just 3
15:06:27 <lambdabot>   Just 3
15:07:23 <Lemmih> The various LLVM backends are prime examples of why I don't particularly like LLVM.
15:07:23 <sinelaw> > Nothing `mplus` Nothing
15:07:25 <lambdabot>   Nothing
15:07:31 <sinelaw> > Nothing `mplus` Nothing `mplus` Just 3 `mplus` just 5
15:07:32 <lambdabot>   Not in scope: `just'
15:07:35 <sinelaw> > Nothing `mplus` Nothing `mplus` Just 3 `mplus` Just 5
15:07:36 <lambdabot>   Just 3
15:07:36 <copumpkin> Lemmih: how so?
15:08:05 <sinelaw> @pl (\x -> case x of Nothing -> Nothing; Just a -> Just (a,a))
15:08:06 <lambdabot> (line 1, column 26):
15:08:06 <lambdabot> unexpected ">"
15:08:06 <lambdabot> expecting variable, "(", operator or ")"
15:08:19 <sinelaw> @pl \x -> case x of Nothing -> Nothing; Just a -> Just (a,a)
15:08:20 <lambdabot> (line 1, column 25):
15:08:20 <lambdabot> unexpected ">" or "-"
15:08:20 <lambdabot> expecting variable, "(", operator or end of input
15:08:26 <sinelaw> @pl \x -> case x of Nothing -> Nothing; Just a -> Just (a,a);
15:08:27 <lambdabot> (line 1, column 25):
15:08:27 <lambdabot> unexpected ">" or "-"
15:08:27 <lambdabot> expecting variable, "(", operator or end of input
15:08:31 <Saizan_> sinelaw: @pl doesn't undestrand case.
15:08:35 <sinelaw> doh.
15:08:36 <Lemmih> copumpkin: They all do manual stack management to deal with garbage collection and exceptions.
15:08:47 <Saizan_> sinelaw: also, lambdabot responds to privmsgs
15:08:56 <sinelaw> i know. sorry. :(
15:09:24 <copumpkin> :t fmap (join (,))
15:09:25 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
15:09:45 <TacticalGrace> Lemmih: but that is how GHC's backend works anyway
15:10:28 <sinelaw> copumpkin, cool! thanks
15:10:33 <TacticalGrace> (ie, to have a drop-in replacement for current GHC backends, that's what you want)
15:10:56 <Lemmih> TacticalGrace: Yes, but not by choice.
15:11:26 <TacticalGrace> not by choice?
15:12:32 <tibbe> If I need a list with fast ++ are there any other options than difference lists (using type List = [a] -> [a])?
15:12:51 <copumpkin> tibbe: append to front and reverse later? :)
15:13:09 <Lemmih> TacticalGrace: They didn't design it like that for aesthetic or performance reasons. It's purely a concession.
15:13:09 <copumpkin> tibbe: but I'd just use DList
15:13:10 <tibbe> copumpkin: good point, I haven't benchmarked that yet
15:13:25 <dolio> Church encoding is also fast.
15:13:59 <Lemmih> TacticalGrace: We don't know how to do it ('it' being dealing with GC and exceptions) properly, and the LLVM people aren't even trying.
15:14:00 * hackagebot upload: Sprig 0.1 - Binding to Sprig (LiamOConnorDavis)
15:14:41 <TacticalGrace> Lemmih: but the concession was made for the C backend (originally) and clearly there is no choice for the NCGs
15:15:01 <TacticalGrace> Lemmih: so even if LLVM had extra support, it'd require quite a bit of work to even use it
15:15:11 <TacticalGrace> (ie, it would be harder)
15:15:27 <Lemmih> TacticalGrace: I agree (:
15:15:29 <tibbe> copumpkin: I need it to be screaming fast and my data type is fixed so I guess I could go with: data List = Nil | Cons {-# UNPACK #-} !MyType List; newtype DList = DList (List -> List)
15:16:01 <copumpkin> tibbe: if you want it to be screaming maybe you should chunk it up a bit? what kind of operations will you be doing a lot of?
15:16:04 <tibbe> (associated data types really need to become standard so we don't have to make all these specialized data types)
15:16:13 <TacticalGrace> given that the situation for the C and NCG backends is not going to change it is questionable whether it'd be helpful at all to do it differently for LLVM (maybe LLVM could do some clever optimisation, but that would have to be shown first)
15:16:37 <tibbe> copumpkin: empty, singleton, and (++)
15:16:51 <tibbe> copumpkin: I'm traversing a tree and gather all elements <= some value
15:16:53 <Lemmih> TacticalGrace: It's a horribly difficult problem and I don't blame LLVM for not solving it. I'm just pointing out that LLVM is not the silver bullet that many people seem to believe.
15:17:27 <tibbe> copumpkin: and finally convert back to a real list (which I use in the API)
15:17:57 <copumpkin> tibbe: I'd find some value in your thing and then just walk backwards consing onto the list
15:18:04 <copumpkin> no singletons or ++
15:18:23 <lpsmith> Heh,  people think that any new VM is a silver bullet,  when in fact languages are different enough none really have been an ideal solution for multiple languages
15:18:31 <copumpkin> tibbe: or possibly chunk it up if you want it to be really screaming
15:18:46 <copumpkin> but that'd be tedious
15:19:41 <Saizan_> if you {-# UNPACK #-} the recursive case Cons is not longer O(1), is it?
15:20:03 <copumpkin> hm?
15:20:10 <copumpkin> it only unpacks the value in that cell
15:20:28 <Saizan_> ah, i misread
15:20:31 <TacticalGrace> Lemmih: I don't think it is a silber bullet, but it is better than what we (= GHC) have right now
15:20:32 <tibbe> copumpkin: I'm not sure what you mean by backwards consing. Right now I do: myFun max = traverse left max ++ traverse right max
15:20:42 <TacticalGrace> which is good enough for me
15:20:57 <copumpkin> tibbe: I meant (walk backwards), consing every new element onto your list
15:22:28 <tibbe> copumpkin: do you have an example snippet that does that for some kind of tree? I have some difficult picturing the code.
15:22:38 <tibbe> diffculty*
15:22:42 <tibbe> difficulty!
15:22:44 <tibbe> argh!
15:23:04 * hackagebot upload: SFont 0.1 - SFont SDL Bitmap Fonts (LiamOConnorDavis)
15:23:23 <lpsmith> tibbe:  that'd be a b-tree,  if you want to chunk up a tree
15:23:37 <copumpkin> lpsmith: oh I was just talking about chunking up his list
15:23:54 <copumpkin> tibbe: can you write a tree zipper for your tree?
15:23:57 <kamatsu> hey, I just uploaded packages to hackage, but it didn't generate haddock docs, or at least not right away, for both of them
15:24:11 <dolio> It doesn't happen immediately.
15:24:23 <kamatsu> ah, okay, just wondering
15:24:25 <kamatsu> thanks
15:24:36 <tibbe> copumpkin: I guess, it's more or less a weight balanced tree like the one used for Data.Map (it's a balanced priority search tree.)
15:24:57 <Axman6> kamatsu: happens every few hours (6/12/24, i can't remember)
15:25:22 <yitz> oh, hackage back uo?
15:25:35 <tensorpudding> yep
15:26:15 <copumpkin> tibbe: what I mean basically is to find your max element (or where it would be) and get a zipper there, then take your zipper and keep moving backwards, and with each new element cons that onto a list. it would give you the list in ascending order, too
15:26:31 <yitz> yay
15:27:33 <tibbe> copumpkin: Unfortunately the max element is not the max element by key but rather the max element by priority. The shape of the tree is determined by the keys and not the priorities so all smaller values are not necessarily to the "left" of the max value.
15:28:33 <Saizan_> tibbe: did you benchmark the difference list approach?
15:28:53 <tibbe> Saizan_: not the unboxed one, the current one uses as standard difference list
15:29:09 <tibbe> Saizan_: I'm looking for candidates to benchmark :)
15:29:24 <copumpkin> tibbe: what's your tree type look like?
15:29:37 <Saizan_> you could try Data.Sequence too
15:29:49 <tibbe> copumpkin: let me paste it
15:29:55 <Saizan_> or maybe a specialized/strict version of that
15:30:08 <copumpkin> tibbe: anyway, the basic idea is that if you just need singleton, empty ,and ++, that's equivalent to [] and :
15:30:22 <Saizan_> tibbe: and i wouldn't use the newtyped DList btw
15:30:26 <copumpkin> I guess not if you're merging separate lists
15:31:24 <sinelaw> err, i get a runtime exception
15:31:30 <sinelaw> how do i know where it's from?
15:31:39 <sinelaw> ("traceback")
15:32:04 <tibbe> copumpkin: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15790#a15790
15:32:05 <Saizan_> xs ++ ys = \cons nil -> ys cons (xs cons nil) -- this looks pretty fast too :)
15:32:34 <Axman6> looks very church encodingish
15:32:39 <Saizan_> it is
15:32:47 <Axman6> good!
15:32:50 <Saizan_> sinelaw: you could try with the ghci debugger
15:32:56 <Axman6> xs :: ?
15:33:05 <tibbe> Saizan_: why wouldn't you use the newtyped DList?
15:33:22 <Saizan_> Axman6: forall b. (a -> b -> b) -> b -> b
15:33:47 <Axman6> where's the a come from?
15:34:01 <Saizan_> the a is the type of the elements
15:34:13 <Saizan_> i.e. type List a = forall b. (a -> b -> b) -> b -> b
15:34:22 <sinelaw> ghci doesn't seem to support arrow do-syntax
15:34:24 <Axman6> excellent
15:34:35 <copumpkin> tibbe: you could use FMList :)
15:34:39 <Axman6> sinelaw: x <- getLine?
15:34:46 <tibbe> copumpkin: what's that?
15:34:51 <copumpkin> @hackage FMList
15:34:51 <lambdabot> http://hackage.haskell.org/package/FMList
15:34:59 <copumpkin> bah http://hackage.haskell.org/package/fmlist
15:35:02 <sinelaw> Axman6, what?
15:35:07 <Saizan_> tibbe: well, i'd at least check that it's not introducing overhead by inhibiting optimizations
15:35:11 <Axman6> sinelaw: what's the problem?
15:35:21 <Saizan_> sinelaw: :set -XArrows ?
15:35:25 <Axman6> ah
15:35:28 <sinelaw> Saizan_, ok
15:35:32 <tibbe> Saizan_: why would a newtype inhibit optimizations?
15:35:53 <tibbe> "These wild claims are still completely unverified though."
15:35:54 <tibbe> haha
15:37:31 <Saizan_> tibbe: e.g. the use of the constructor may force you into splitting your lambdas at points where you wouldn't, and that affects how closures are made
15:37:41 <Saizan_> though i don't know the details
15:37:42 <jmcarthur> ew
15:37:52 <tibbe> Saizan_: sounds interesting
15:38:07 <tibbe> Saizan_: haven't heard that before
15:39:41 <gwern> "test = fmap (all (λ(Success _) → True)) $ sequence [quickCheckResult checkInsertion, quickCheckResult checkEquality]" <-- any thoughts?
15:40:04 <copumpkin> \Success{}
15:40:22 <copumpkin> or just const True :)
15:40:29 <gwern> that's a crazy bit of syntax
15:40:35 <copumpkin> oh wait
15:40:38 <gwern> copumpkin: but there are multiple constructors for a Result
15:40:50 <gwern> const True I think doesn't do the right thing :)
15:40:54 <copumpkin> yeah
15:40:57 <copumpkin> won't that fail?
15:41:05 <dolio> You want bottoms on the other constructors?
15:41:10 <Saizan_> that code either returns True, or crashes.
15:41:16 <dolio> Because that's what \(Success _) -> True does.
15:41:32 <jmcarthur> oh man: http://www.foobook.org/flyswat/scraps/a-rest-helper-class-for-java/
15:41:43 <jmcarthur> reddit submission title for that: "This is why I hate checked exceptions"
15:41:47 <Veinor> so is the printf hack to write variadic functions considered 'good'
15:41:48 <Veinor> ?
15:42:03 <copumpkin> Veinor: no
15:42:13 <Veinor> well, is there any 'good' way to do that? :P
15:42:19 <copumpkin> no
15:42:19 <gwern> well, bottom would serve to tell me a test failed
15:42:23 <Veinor> Haha
15:42:34 <copumpkin> Veinor: what do you need variadic functions for? :P
15:42:39 <gwern> so that's better than const True even so
15:42:46 <copumpkin> :)
15:42:50 <Veinor> doesn't the vector library do something silly with peany arithmetic?
15:42:51 <Veinor> *peano
15:42:54 <gwern> Veinor: oleg has a better way to do it
15:42:57 <gwern> he always does
15:42:59 <xle> is there another version of head that can operate on empty lists?
15:43:04 <jmcarthur> that's not variadic arguments, though
15:43:07 <Veinor> xle: ... and return what?
15:43:14 <Veinor> I know it's not, I was just thinking aloud
15:43:15 <copumpkin> I've written variadic homogeneous functions using peano naturals
15:43:19 <xle> Veinor: empty list if empty
15:43:20 <copumpkin> it's not very pleasant though
15:43:25 <gwern> xle:  tail is [a] -> [a]
15:43:26 <Veinor> that'd be a type error.
15:43:43 <gwern> xle: the safe package defines safeHead a -> [a] -> a
15:43:45 <jmcarthur> xle: take 1
15:43:56 <xle> thanks all
15:43:57 <jmcarthur> > take 1 []
15:43:58 <lambdabot>   []
15:44:01 <jmcarthur> > take 1 "foo"
15:44:02 <lambdabot>   "f"
15:44:04 <gwern> oops, tail is partial isn't it?
15:44:07 <gwern> > tail []
15:44:08 <koeien37> it is
15:44:09 <lambdabot>   * Exception: Prelude.tail: empty list
15:44:10 <koeien37> drop 1
15:44:22 <gwern> yeah, so I guess drop 1 is the safe head
15:44:27 <koeien37> s/head/tail
15:44:29 <jmcarthur> safeHead = take 1 ; safeTail = drop 1
15:48:02 <xerox> is Num a => Num (a,a) defined somewhere in the library?
15:48:14 <xerox> (just needing +)
15:49:12 <gwern> xerox: what does that mean?
15:49:20 <ziman> you might just define (.+) yourself
15:49:24 <xerox> gwern just component wise sum
15:49:32 <ziman> or use `plus` or something
15:49:33 <yitz> safeHead x ys = fromMaybe x $ listToMaybe ys
15:49:40 <gwern> so, addition on a complex number?
15:49:44 <xerox> yep
15:49:53 <xerox> might use complex numbers...
15:50:10 <copumpkin> there are other non-complex structures you can have on pairs of numbers
15:50:12 * gwern would check, y'know, the Data.Complex module
15:50:20 <xerox> copumpkin in fact I also need - and norm
15:50:25 <xerox> so I guess it's a good idea
16:01:48 <phr> > drop 1 []
16:01:49 <lambdabot>   []
16:06:23 <merehap> is there a preferred mail facility for darcs running on arch? for some reason I can't get sendmail to work with darcs send
16:06:52 <Saizan_> mh, postfix?
16:07:29 <merehap> postfix does work with darcs send? only sendmail and mapi are mentioned in the error message...
16:07:32 <merehap> I'll try that
16:08:32 <merehap> awesome, that worked, might be helpful if they updated the error message to avoid confusion
16:08:39 <merehap> Saizan_: thanks
16:09:14 <Veinor> "Time to write some Lisp." "Lithp?" "Lisp." "Common Lithp or Thceme?"
16:09:16 <Veinor> :D
16:17:20 <BMeph> Ah, so That's why everyone hates Arc... ;p
16:18:02 <tomoj> would it be possible to arrange for the output of Text.JSON for a JSONObject to be transformed into an HList type?
16:18:41 <tomoj> I am fine having the possible key types be determined at compile time, I just need to build them from strings or the results of Text.JSON - impossible?
16:20:19 <gwern> merehap: I like mstmp
16:21:28 <gwern> > foldr (==) [] [[], [], [], []]
16:21:29 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:21:30 <lambdabot>         against inferred type ...
16:21:36 <gwern> :t foldr
16:21:38 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:21:52 <gwern> @src all
16:21:52 <lambdabot> all p =  and . map p
16:22:01 <gwern> @src and
16:22:02 <lambdabot> and   =  foldr (&&) True
16:22:36 <Saizan_> tomoj: so something like the Read class?
16:23:04 <tomoj> Saizan_: that sounds near the mark
16:23:35 <Saizan_> > read "12" :: Int
16:23:36 <lambdabot>   12
16:23:41 <Saizan_> > read "foo" :: Int
16:23:43 <lambdabot>   * Exception: Prelude.read: no parse
16:23:51 <Saizan_> > read "\"foo\"" :: String
16:23:52 <lambdabot>   "foo"
16:24:12 <merehap> gwern: I will check that out when I get a chance, I'm new to this whole minimalism thing :)
16:24:26 <Saizan_> it selects a different instance by looking at the result type
16:24:29 <Saizan_> ?type read
16:24:30 <lambdabot> forall a. (Read a) => String -> a
16:25:38 <tomoj> I guess the problem is, there's some json Result that's either (Ok a) or (Error String), and I want to force this into some custom type and perhaps return some Error if this can't be done, otherwise return a value of my custom type
16:26:21 <tomoj> maybe I am getting too far ahead of myself :(
16:26:45 <Saizan_> tomoj: you can do class FromResult a where fromResult :: Result -> Maybe a
16:27:12 <Saizan_> tomoj: then you make an instance of each of your custom types
16:27:30 <tomoj> ok, but that's a huge pain in the ass, any shortcut?
16:27:35 <copumpkin> omnom
16:27:40 <yitz> sounds like Either
16:27:43 <Saizan_> why huge pain?
16:28:00 <tomoj> there will be a separate type for every column of the db, basically
16:28:16 <Saizan_> you've to write the code to extract your custom type out of the json anyway, no?
16:28:31 <copumpkin> tomoj: just write in agda
16:28:45 <tomoj> Saizan_: yeah that's true
16:29:06 <tomoj> I hadn't thought of that, makes it a pain. most (all?) of the types will just be newtype renamings of like Int, String, etc
16:29:43 <Saizan_> maybe there's a common pattern you can exploit?
16:30:01 <Saizan_> with TH, at worst
16:31:15 <tomoj> yeah I think there would be
16:31:24 <tomoj> most of the extraction code would be the same
16:31:34 <tomoj> I dunno TH yet, will read up, thanks
16:31:50 <Saizan_> TH = TemplateHaskell
16:32:03 <tomoj> yeah just haven't used it yet
16:32:12 <Saizan_> ah, k
16:32:36 <sinelaw> How do I debug a <<loop>>?
16:33:23 <yitz> sinelaw: usually a very tight infinite recursion
16:33:37 <sinelaw> yitz, i know, but how can i find where it happens?
16:34:40 <kmc> ghci debugger?
16:39:23 <sinelaw> preflex, seen luqui
16:39:23 <preflex>  luqui was last seen on #haskell 5 days, 11 hours, 52 minutes and 57 seconds ago, saying: well it's not specific, and surely more than just an internal colonel
16:41:44 <merehap> preflex, seen merehap
16:41:45 <preflex>  merehap was last seen on #haskell 17 minutes and 32 seconds ago, saying: gwern: I will check that out when I get a chance, I'm new to this whole minimalism thing :)
16:42:14 <Veinor> preflex, seen Veinor
16:42:14 <preflex>  Veinor was last seen on #haskell-blah 2 minutes and 16 seconds ago, saying: we won't know until the cops bust in his door
16:42:17 <merehap> darn, I was hoping it would return bottom
16:42:18 <Veinor> :O
16:42:26 <copumpkin> preflex: xseen Veinor
16:42:27 <preflex>  Veinor was last seen on freenode/#haskell 8 seconds ago, saying: :O
16:42:31 <Veinor> xseen?
16:42:36 <sproingie> preflex, seen preflex
16:42:36 <preflex>  what
16:42:41 <copumpkin> wat
16:43:11 <Veinor> haha
16:43:18 <Veinor> preflex, xseen preflex
16:43:18 <preflex>  what
16:43:37 <merehap> preflex, seen wat
16:43:37 <preflex>  wat was last seen on ##c 91 days, 16 hours, 14 minutes and 55 seconds ago, saying: okay, i'll try
16:44:17 <tomoj> maybe I can just provide JSON instances for my types so that they are just converted to/from raw JSON
16:46:16 <tomoj> but is there any way to avoid writing 'instance JSON Foo where readJSON value = Foo ((readJSON value) :: String)' etc for all your variations on 'newtype Foo = Foo String'
16:46:17 <tomoj> ?
16:46:56 <koeien37> GeneralizedNewtypeDeriving
16:47:26 <Trinithis> How can one code finding all combinations of breaking a list into n parts while perserving order? For example, subLists 2 "abc" would yeild [["a", "bc"], ["ab", "c"]]
16:48:04 <tomoj> koeien37: great, thanks
16:48:13 <Trinithis> Wrapping in Maybe is okay too
16:48:45 <merehap> > map inits $ tails "abc"
16:48:47 <lambdabot>   [["","a","ab","abc"],["","b","bc"],["","c"],[""]]
16:49:51 <Axman6> > nub . concatMap inits . tails $ "abc"
16:49:53 <lambdabot>   ["","a","ab","abc","b","bc","c"]
16:50:10 <Axman6> it's hot >_<
16:51:22 <mathijsB> hm, im trying to use the Html library
16:51:24 <mathijsB> anyone knows
16:51:25 <mathijsB> why
16:51:35 <mathijsB> thehtml << body << ((bold << italics << "test") +++ (italics << "test"))
16:51:36 <mathijsB> works
16:51:39 <mathijsB> but
16:51:47 <mathijsB> foldr (+++) (thehtml << body) [(bold << "test"), (italics << "test")]
16:51:49 <mathijsB> doesnt
16:52:04 <copumpkin> you need a base case
16:52:10 <copumpkin> oh you have one
16:52:17 <merehap> @let fun xs = map (flip splitAt xs) [1..length xs - 2]
16:52:18 <lambdabot>  Defined.
16:52:24 <merehap> fun "abc"
16:52:27 <Axman6> the base case it going to be at the end
16:52:32 <merehap> > fun "abc"
16:52:34 <lambdabot>   Ambiguous occurrence `fun'
16:52:34 <lambdabot>  It could refer to either `L.fun', defined at <l...
16:52:48 <merehap> @let funTime xs = map (flip splitAt xs) [1..length xs - 2]
16:52:49 <mathijsB> hmm
16:52:49 <Axman6> that will end up being: (bold << italics << "test") +++ (italics << "test") +++ (thehtml << body)
16:52:49 <lambdabot>  Defined.
16:52:55 <merehap> > funTime "abc"
16:52:55 <Saizan_> mathijsB: foldr (+++) (thehtml << body) [(bold << "test"), (italics << "test")] = (bold << "test") +++ ((italics << "test") +++ (thehtml << body))
16:52:57 <lambdabot>   [("a","bc")]
16:53:31 <merehap> @let funTime xs = map (flip splitAt xs) [1..length xs - 1]
16:53:32 <lambdabot>  <local>:21:0:
16:53:32 <lambdabot>      Warning: Pattern match(es) are overlapped
16:53:32 <lambdabot>               I...
16:53:41 <merehap> @let funTime2 xs = map (flip splitAt xs) [1..length xs - 1]
16:53:42 <lambdabot>  Defined.
16:53:43 <mathijsB> so i need foldl?
16:53:43 <maciej`> hey everyone
16:53:44 <Twey> @let fun = liftM2 ($) (map . flip splitAt) $ enumFromTo 1 . subtract 2 . length
16:53:45 <lambdabot>  <local>:23:0:
16:53:45 <lambdabot>      Multiple declarations of `L.fun'
16:53:45 <lambdabot>      Declared at: <local...
16:53:48 <Twey> :<
16:54:02 <merehap> > funTime2 "abcd"
16:54:04 <lambdabot>   [("a","bcd"),("ab","cd"),("abc","d")]
16:54:32 <maciej`> is there a way to restrict a constructor of a data type to only take arguments from a given type class?
16:54:53 <Axman6> sure, but don't do it, unless you really have to
16:55:26 <Axman6> put the restrictions on the functions using youe type, not the type itself
16:55:27 <Trinithis> Ack... sorry guys, but I have to go
16:55:47 <maciej`> Axman6: thanks for the suggestion. care to explain why?
16:55:48 <merehap> @ let funTimeN n xs = map (flip splitAt xs) $ funTimeN (n-1) [1..length xs - 1]
16:55:55 <merehap> @let funTimeN n xs = map (flip splitAt xs) $ funTimeN (n-1) [1..length xs - 1]
16:55:57 <lambdabot>  <local>:23:16:
16:55:57 <lambdabot>      Couldn't match expected type `Int'
16:55:57 <lambdabot>             against i...
16:56:16 <Axman6> maciej`: because then you have to add unnecessary constraints to all functions that use your type usually
16:56:41 <maciej`> Axman6: aaah, makes sense, thanks!
16:57:30 <Axman6> if you have a good reason to do it, then that's fine, but even if you look at things like Map, i don't believe they have any Ord constraint on the keys, only the functions that use them do
16:58:13 <maciej`> just for the record, how would i do it if i absolutely had to? Say I have data Foo a = Bar a, and I want "a" to be an instance of Eq?
16:58:37 <BONUS> data Eq a => Foo a = Bar a i think
16:58:50 <Axman6> yeah
16:58:50 <BONUS> but yeah don't do it cause you have to repeat those class constraints in functions anyway
16:58:53 <BONUS> sooo
16:59:27 <maciej`> BONUS: yeah i know, i was just curious about the syntax
16:59:33 <BONUS> although i think there's an extension that lets you omit repeating them?
16:59:54 <BONUS> (in function defeinitions if you already have class constraints in data definitions)
17:00:22 <Veinor> oh hay it's BONUS
17:00:24 <Axman6> :o Simon Marlow is now following me on twitter, i feel honoured :)
17:00:34 <BONUS> oh hai just dropping by :D
17:00:42 <Saizan_> data Foo a = Eq a => Bar a
17:00:56 <Saizan_> that will provide the context when you pattern match on Bar
17:01:02 <Saizan_> requires an extension iirc
17:01:15 <Axman6> Saizan_: what's the difference there?
17:01:21 <nominolo> maciej`: BTW, those type class annotations on constructors are internally called "stupid Theta" because they aren't translated into any dictionaries
17:01:51 <Saizan_> Axman6: that e.g. foo :: Foo a -> Bool; foo (Bar a) = a == a; will typecheck
17:02:03 <Axman6> ah, i see
17:02:06 <BONUS> yeah, ah. what's that extension again?
17:02:12 <Axman6> i was wondering about that
17:02:12 <Saizan_> Axman6: operationally the dictionary is stored in the constructor i think
17:02:23 <Axman6> dictionary?
17:02:30 <Saizan_> instance dictionary
17:02:51 <Axman6> hmm, sounds like i should be looking into how GHC is implemented again
17:03:13 <nominolo> Axman6: for existentials
17:03:28 <nominolo> Axman6: but not for, say data Eq a => Foo a = ...
17:03:59 <kmc> that just puts a constraint on the Foo constructor, right?
17:04:10 <nominolo> kmc: Foo is a type name
17:04:17 <kmc> yeah sorry
17:04:22 <kmc> on whatever constructor(s) come after the =
17:04:24 <BONUS> how is data Foo a = Eq a => Bar a expanded into existentials? forall a. data Foo a = Eq a => Bar a?
17:04:32 <copumpkin> kmc: yeah
17:04:41 <kmc> when you pattern match you don't get the class "out of" the constructor, but you get it anyway because the type is exposed
17:04:43 <copumpkin> nope
17:04:52 <Saizan_> BONUS: mh, it's not an existential
17:04:55 <kmc> unlike an existential, where you get the dictionary but don't know what type it corresponds to
17:04:58 <copumpkin> kmc: that was a nope of agreement
17:05:01 <copumpkin> :P
17:05:01 <BONUS> ah
17:05:21 <copumpkin> with a GADT though
17:05:23 <copumpkin> it'll give you the knowledge
17:05:35 <copumpkin> another reason GADTs > ADTs
17:05:47 <Saizan_> it's the same as data Foo a where Bar :: Bar a => a -> Foo a
17:06:09 <copumpkin> Saizan_: except in the latter case pattern matching on Bar gives you the Bar a context
17:06:29 <Saizan_> copumpkin: that happens with  data Foo a = Eq a => Bar a
17:06:37 <BONUS> that seems pretty handy but i kind of don't like it that you have hidden constraints then
17:06:50 <Saizan_> and not with  data Eq a => Foo a = Bar a
17:07:16 <copumpkin> Saizan_: what's the point of the difference in those two then?
17:08:29 <copumpkin> I didn't even realize you could put a constraint on that side of the =
17:08:32 <copumpkin> on the right side, that is
17:09:10 <shapr> @Yow!
17:09:10 <lambdabot> Couldn't find fortune file
17:09:13 <nominolo> copumpkin: I don't think you can, at least not on tyvars mentioned in the type decl
17:09:18 <Saizan_> well, only the latter is haskell98
17:09:19 <copumpkin> oh
17:09:26 <copumpkin> Saizan_: where does the former come from?
17:09:45 <nominolo> existential types, I suppose
17:09:52 <copumpkin> well but a is mentioned in the type constructor
17:09:52 <Saizan_> copumpkin: ghc used to allow it without extensions, now i'm not sure what you've to turn on
17:10:10 <copumpkin> is it shadowing the type constructor's a?
17:10:18 <copumpkin> making that a phantom type + existential?
17:10:21 <copumpkin> :P
17:10:28 <nominolo> copumpkin: probably not
17:10:37 <nominolo> it's just adding a constraint on a
17:10:51 <nominolo> it doesn't bind any tyvars
17:11:05 <BONUS> so wait data Foo a = Eq a => Bar a is H98?
17:11:06 <copumpkin> just thought it might be another implicit forall :)
17:11:11 <BONUS> but putting it before the = isn't
17:11:12 <copumpkin> BONUS: no
17:11:16 <BONUS> ah, the other way around
17:12:07 <nominolo> copumpkin: I assume both forms get translated into the same thing.  In particular, neither requires an actual dictionary anywhere
17:12:20 <nominolo> so they are more or less ignored for all intents and purposes
17:12:38 <copumpkin> nominolo: I'd assume the latter would put the dictionary into the type
17:12:45 <copumpkin> or rather, into that constructor
17:12:46 <copumpkin> like the GADT
17:12:52 <copumpkin> actually no
17:12:58 <Saizan_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15792#a15792 <-
17:13:04 <nominolo> copumpkin: it used to put it into the constructor wrapper
17:13:21 <copumpkin> Saizan_: I see
17:13:34 <copumpkin> Saizan_: can you have different constraints on different constructors?
17:14:12 <BONUS> is using this a good idea though?
17:14:16 <Saizan_> copumpkin: yes
17:14:37 <nominolo> BONUS: no, only with existentials
17:14:38 <Saizan_> copumpkin: it's the same as what you get with gadts i think
17:14:54 <copumpkin> I see
17:14:57 <BONUS> in foo :: FOo a -> Bool, there could be a million constraints on a but none of them are apparent from foo's type
17:15:00 <BONUS> ah
17:15:24 <Saizan_> BONUS: they are apparent in Foo's constructor
17:15:26 <nominolo> BONUS: right, but the constraints are attached to the constructor
17:16:25 <BONUS> yeah, but still, seems shifty to me
17:20:31 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15793#a15793 <-- any thoughts on my unionfind?
17:22:07 * gwern thinks unionSets probably has a better definition
17:22:48 <copumpkin> gwern: I bet it doesn't have an ackermann complexity anymore!
17:22:57 <gwern> copumpkin: no. no, it doesn't
17:23:01 <copumpkin> (inverse ackermann, of course)
17:23:04 <copumpkin> damn immutability
17:23:37 <gwern> copumpkin: this is my reference implementation; I plan to work my way up through variations
17:24:11 <copumpkin> you going by http://portal.acm.org/citation.cfm?id=1292541 ?
17:25:26 <gwern> copumpkin: among others
17:25:53 <copumpkin> ah, that one is fairly DiffArray-ish
17:26:32 <gwern> it is; I found an old STArray one that no longer compiles
17:26:48 <gwern> and then there's the one on hackage using iorefs
17:26:55 <copumpkin> ah
17:27:17 <gwern> it's pretty ugly; I don't understand it
17:28:56 <c_wraith> Strange.  It's a *really* simple algorithm.  How is possible to code it confusingly?
17:30:48 <gwern> c_wraith: implement all the tree and level shuffling stuff, throw in iorefs, and use this pointedsupply thingy, and have no examples of use
17:30:50 <Axman6> what's the algorithm?
17:31:17 <copumpkin> Axman6: the disjoint set one
17:31:20 <gwern> Axman6: see the WP article; it's pretty good
17:31:50 <c_wraith> Wait, I thought there were just two things involved...  Union by rank, and path compression.  what else is going on in that algorithm?
17:36:05 <augur> heyyy haskelliers
17:36:17 <augur> i have a question for you guys
17:36:58 <augur> not a haskell question, actually, but more general related to type systems
17:37:03 <BMeph> Is there a paper or discussion of how undefined is/is not equivalent to None/NULL/nil in other languages?
17:37:38 <gwern> BMeph: what's ==null for undefined?
17:37:46 <copumpkin> spoon! ;)
17:38:48 <augur> namely: aside from pre-compile sensibleness checking, what does a type system afford you (i assume the answer is nothing, but...)
17:39:23 <copumpkin> it affords you whatever you choose to encode in it
17:39:27 <copumpkin> basically
17:39:47 <copumpkin> it gives you a logical framework to describe the behavior of your program that will get checked
17:39:51 <augur> copumpkin: well, ignoring the shady use of type systems to compute ;p
17:39:57 <copumpkin> no, not even that
17:40:00 <twb> ghc 6.12 doesn't build for me!
17:40:05 <twb> Host platform inferred as: x86_64-unknown-linux, Target platform inferred as: x86_64-unknown-linux, Unknown vendor linux
17:40:08 <erikc> augur: it also assigns domains to variables which gives the compiler a fighting chance
17:40:12 <erikc> for performance
17:40:13 <augur> ok so really it affords you an easy way to reason about your programs
17:40:21 <gwern> augur: types allow type-directed stuff. like quickcheck generating test examples, or typeclasses allow abstractions like monoids and monads
17:40:21 <copumpkin> augur: no
17:40:54 <gwern> (what with turing-completeness you can argue there are non-typesystem related ways to do all that stuff, but no one cares about that point in practice)
17:40:55 <nominolo> twb: what's the error message?
17:40:58 <copumpkin> augur: it gives the compiler a way of reasoning about your program, gives you typeclasses, and gives you a way to encode arbitrary amounts of correctness into the types (depending on the type system)
17:41:10 <augur> qwern -- right but you can do monads in a duck-typed language too
17:41:15 <twb> nominolo: I just pasted it
17:41:16 <copumpkin> oh god
17:41:18 <gwern> augur: and yet, no one did
17:41:27 <gwern> augur: see my comment about turing-completeness
17:41:32 <augur> well SOME people have
17:41:41 <copumpkin> multiply :: Mat x y a -> Mat y z a -> Mat x z a
17:41:52 <augur> i mean, monads in haskell are conventions not enforced
17:41:59 <nominolo> twb: that doesn't look like an error to me.  CAn you paste more at hpaste.org?
17:42:01 <augur> but regardless, i dont care about what people _do_ do.
17:42:09 <BMeph> gwern: Good point. So, it's worse, in ways... ;)
17:42:19 <twb> Sure.
17:42:41 <augur> copumpkin: ok, so typeclasses afford you ways of getting some sort of overloading
17:42:42 <gwern> BMeph: well, that's like saying if you're a quadriplegic, it's worse to have your limbs because you'd go faster without them
17:42:55 <copumpkin> augur: they give you a way to encode arbitrary relations of types
17:43:11 <augur> what do you mean arbitrary relations of types
17:43:25 <copumpkin> a relation in the mathematical sense
17:43:42 <augur> and how is this not expressible in a language with type functions?
17:43:51 <augur> eg. isInt(x) etc.
17:44:03 <copumpkin> augur: first of all, those functions are checked at runtime
17:44:03 <gwern> augur: that's a relation of values, I take it
17:44:11 <twb> nominolo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15795#a15795
17:44:13 <copumpkin> ultimately all major languages are turing complete, yes
17:44:15 <gwern> a specific int like 5 will be tested, or not
17:44:24 <copumpkin> augur: second of all, functions are a subset of relations :)
17:44:25 <augur> copumpkin: which functions
17:44:35 <copumpkin> augur: our typeclasses, when used as functions
17:44:45 <augur> copumpkin im not following what you're saying.
17:44:58 <copumpkin> augur: if you write something that says isInt, when does it get run?
17:45:06 <twb> nominolo: now, admittedly, I'm not following any instructions.  I'm just dropping the 6.10 debianization onto 6.12 and seeing what happens.
17:45:15 <augur> copumpkin: at runtime
17:45:22 <copumpkin> augur: when do our typeclasses get resolved?
17:45:41 <augur> im not sure what that question means.
17:45:48 <nominolo> twb: you're trying to debianise 6.12?
17:45:53 <twb> nominolo: yup
17:45:55 <copumpkin> my point is that we get notified about typeclass mismatches at compile time
17:46:04 <augur> right, and i already said that
17:46:05 <augur> :P
17:46:05 <twb> nominolo: informally, that is
17:46:07 <augur> i said BESIDES that
17:46:12 <nominolo> twb: I guess you should ask on #ghc then.  Or on the mailing list
17:46:24 <copumpkin> augur: well yes, ultimately that's all type systems give you. Static checking of the properties you choose to encode in them ;)
17:46:27 <twb> nominolo: ah, sorry.
17:46:28 <gwern> augur: if you sprinkle your program with isInt(x) preconditionals, how many times do you have to run your program before you know it's correct?
17:46:30 <augur> ok
17:46:35 <gwern> over all possible inputs?
17:46:37 <augur> thats what i figured.
17:46:41 <copumpkin> augur: everything you can write in a type system can be done at runtime with runtime errors, sure
17:46:47 <ezyang> Hey guys, I'm trying to come up with a list of things that I should be sure people know before talking about typeclasses.
17:46:47 <twb> I forgot there was a dedicated channel for GHC
17:46:52 <nominolo> twb: no, it's just that I don't know enough of the packaging stuff to help you with this error.
17:46:53 <copumpkin> augur: but generally it's nice to catch errors before you deploy
17:47:05 <augur> ok now heres another question then that i have regarding this sort of thing
17:47:14 <gwern> copumpkin: kind of reminds me 'besides everything that can be encoded into binary, what *else* can a computer do?'
17:47:20 <nominolo> I saw a discussion a while ago that "unknown" is sort of expected on linux
17:47:20 <copumpkin> :)
17:47:25 <copumpkin> yeah
17:47:54 <nominolo> twb: and it sounded like that was a recent change.  I may be completely wrong though.
17:47:56 <augur> is there a significant difference between, lets say, any function at all (e.g. indexOf in indexOf(x,xs))
17:48:02 <augur> and crazy complex types
17:48:03 <augur> like say
17:48:29 <augur> well, lets not use indexOf/2
17:48:35 <augur> lets pretend we're being prology
17:48:43 <augur> indexOf(x,xs,i)
17:49:08 <augur> and some type IndexOfXInXs
17:49:35 <augur> or the type AnXThatsInXSAtIndexI
17:49:42 <augur> or the type AnXSThatContainsXAtI
17:49:45 <copumpkin> um
17:49:50 <copumpkin> I don't get what you're asking
17:49:54 <augur> well
17:49:54 <gwern> oh, and optimizations. we forgot static typing is great for optimizations
17:50:05 <augur> i suppose thats a dependent type system, in some sense, but
17:50:15 <Saizan_> augur: seen Twelf?
17:50:22 <augur> isnt it entirely possible to think of _all functions_ as just REALLY complex types
17:50:33 <copumpkin> augur: yeah, sure
17:50:38 <gwern> augur: types can be turing complete. functions can be turing complete. so yes
17:51:17 <augur> e.g. instead of lets say, elementOf being of type a -> [a] -> Bool, its of type MagicType -> bool, and is defined as \x -> True
17:51:43 <ziman> sometimes the types say enough to derive the implementation automatically :)
17:51:48 <augur> and MagicType is just the type that has as its instances all the pairs of (a,b) where a is in b
17:52:06 <ziman> @djinn Either a b -> (a -> c) -> (b -> c) -> c
17:52:07 <lambdabot> f a b c =
17:52:07 <lambdabot>     case a of
17:52:07 <lambdabot>     Left d -> b d
17:52:07 <lambdabot>     Right e -> c e
17:52:31 <Saizan_> augur: as you put it that works only for predicates
17:52:39 <augur> saizan, yes ofcourse
17:52:43 <Veinor> I want to program things, but I have no clue what to write :(
17:52:50 <augur> but as we know all functions can be lifted to be predicates
17:53:10 <Saizan_> augur: however, in general, you can have the type "foo a0 .. an = r" for any n-ary function foo
17:53:12 <augur> by increasing their arity by one and turning the language into Prolog
17:53:19 <copumpkin> Veinor: haskell_proposals subreddit
17:53:37 <copumpkin> augur: I still don't really get what you're getting at :)
17:53:40 <augur> yeah but foo a0 ... an = r == foo' a0 ... an r = true-or-false
17:54:02 <BMeph> "...the construction of which is left as an exercise." ;p
17:54:17 <augur> copumpkin: im just saying, foo(x,y) = true-or-false is as much a "type function" as isInt(x) is a "type function"
17:54:37 <copumpkin> augur: nobody's arguing that you can't build an equivalence
17:54:42 <augur> im just checking
17:54:47 <augur> that there IS an equivalence
17:54:49 <copumpkin> we're just saying that the type system formulation of that stuff can be verified automatically by the compiler
17:55:04 <copumpkin> because it has a simple logical foundation behind it
17:55:09 <augur> no, copumpkin, i dont care about that, i just want to make sure there there is an equivalence
17:55:24 <augur> and that, ignoring compile-time stuff, these two systems are effectively the same
17:55:33 <copumpkin> yes, it's computation
17:55:50 <augur> good, do you have any suggestions for reading up on this?
17:56:10 <copumpkin> I'd start with http://en.wikipedia.org/wiki/Curry–Howard_correspondence
17:56:18 <gwern> augur: it's an entire ginormous field. there's no real starting point
17:56:25 <augur> because im building an argument in a non-programming-language related discussion and i dont want to talk out of my ass you know?
17:56:55 <copumpkin> augur: but if you don't care about correctness, then type systems aren't useful except for expressiveness
17:57:02 <augur> i know
17:57:03 <copumpkin> so I'm not sure it's worth it
17:57:18 <augur> but theres this raging debate in linguistics over whether or not we want our semantics to have types or not
17:57:32 <copumpkin> why wouldn't correctness matter there?
17:57:49 <augur> because it has no bearing on the questions
17:57:51 <augur> the idea is basically
17:58:08 <augur> the typed-semantics people want to rule out "the destruction was happy" because of some sort of type mismatch
17:58:20 <augur> happy :: Person -> Bool, the_destruction :: Event
17:58:24 <augur> therefore type mismatch
17:58:27 <augur> so its bad
17:58:30 <copumpkin> yeah
17:58:45 <augur> and the type-less semantics people want to say this is not something the semantics cares about
17:59:00 <augur> rather, the general cognitive system is what knows that happiness is something about people, not events
17:59:07 <augur> and so its not that this sentence is BAD
17:59:21 <augur> its just that this sentence means something that doesnt make any sense
17:59:26 <augur> due to world knowledge
17:59:35 <copumpkin> I see, it's basically the same distinction between dynamic and statically checked languages :)
17:59:49 <copumpkin> obviously most of us in here are going to be for the typed answer, though
17:59:53 <augur> e.g. its bad in the same way that "2+2 = 5" is bad -- its false, but not a bad sentence
18:00:12 <copumpkin> not really that
18:00:20 <copumpkin> it's more bad in the way "5 + orange = pear" is bad
18:00:34 <copumpkin> you can't even say if it's true or not because + doesn't make sense on oranges
18:00:45 <augur> sure or that
18:01:00 <Saizan_> + is defined for arguments 2, 2
18:01:02 <copumpkin> so you can tell what my stance is on the typed semantics discussion would be, if I were involved :P
18:01:10 <augur> the idea tho is that untyped semantics leaves that stuff to the CONCEPTUAL system, not the linguistic system
18:01:12 <Saizan_> is it defined for arguments 5 and orange?
18:01:23 <Saizan_> in a dynamic language it must be
18:01:38 <Saizan_> in a static one doesn't have to, if its type says it isn't
18:02:06 <copumpkin> augur: but the linguistic system is an encoding of the conceptual system, and pretty much the only way to communicate with it
18:02:13 <copumpkin> you might as well encode your conceptual constraints in the language
18:02:15 <augur> and what i wanted to argue was that if you have an untyped language, then the sum total behavior of the system is going to look pretty much exactly the same either way
18:02:36 <augur> you wont be able to tell why this expression is bad
18:03:17 <augur> copumpkin: but thats the thing. the linguistics system isnt an encoding of the conceptual system
18:03:35 <augur> it ENCODES stuff from the conceptual system, but its not just a lower level version of it
18:03:57 <augur> there are real constraints on linguistic expressions that dont exist in the conceptual system
18:04:16 <augur> but thats beside the point
18:04:21 <copumpkin> but my point is why let the language encode things that the conceptual system can't process, if you can do a reasonable job excluding them early?
18:04:41 <augur> well it makes no difference either way is my point
18:04:59 <augur> whether you do it in language or the conceptual system, you cant tell the difference
18:05:27 <copumpkin> you in or the well can't
18:05:45 <augur> what?
18:05:49 <copumpkin> exactly :)
18:05:52 * BMeph resolves not to comment on this discussion, since he doesn't follow the linguistic field at all.
18:05:53 <copumpkin> just kidding :P
18:06:14 <augur> except in certain particular cases -- e.g. in a language with isInt(x), and with arbitrary (higher order) functions
18:06:17 <Saizan_> the difference is increased complexity in the conceptual system at least, no idea if that's noticeable
18:06:34 <augur> you can have the function foo isInt = isBool; foo isBool = isInt; foo x = x
18:06:58 <augur> and thus in an untyped system, you can have crazy functions like this
18:07:16 <augur> whereas in a (simple) type system you cant. you'd need a higher order type system with type functors
18:07:16 <mmorrow> augur: this aside though, types can make it always the case that any error in you program is a logic flaw, since 90+% of stupid errors or oversights are caught using types as a mechanism
18:07:35 <augur> whereas in an untyped logic, you dont need anything special
18:07:46 <mmorrow> and types serve as forced organization between units as programs grow larger
18:07:48 <Saizan_> augur: you usually can't pattern match on function names either, but i guess you can encode that pretty easily
18:08:10 <augur> Saizan_: in haskell, but this is an imaginary language constructed for the purpose of demonstration :P
18:09:06 <Saizan_> augur: btw, what kind of languages are we talking about here? natural or formal ones?
18:09:25 <augur> Saizan_: formal semantics of natural language
18:10:27 <Saizan_> with analogies, rhetoric figures etc.. i think the type system for a natural language would be pretty weird
18:10:44 <augur> that sort of stuff is rarely considered in semantics
18:10:49 <Ke> does haskell guarantee read show -compatibility
18:10:50 <mmorrow> augur: in a system like this you're really just using a single ADT, giving every possible combination of possible outcome paths a non-segfault ending, then writing programs on top of that ADT language
18:10:52 <augur> thats mostly a pragmatic concern
18:10:58 <augur> or a conceptual concern
18:11:04 <Saizan_> augur: however, there's the other side of the coin, a dynamic typed language is just a statically typed language with only one type
18:11:05 <augur> analogy, for instance, is really NOT a linguistic process
18:11:09 <Ke> ie. can I use show and read to communicate over pipes
18:11:10 <augur> its actually a conceptual process
18:11:18 <augur> Saizan_: i know :P
18:11:55 <Saizan_> Ke: well, it's one of the laws
18:11:58 <augur> i mean, im already convinced that theres no difference, right, i just wanted to make sure my convinction was justified
18:12:07 <Ke> good
18:12:25 <Saizan_> it's not true that there is no difference
18:12:49 <augur> theres no difference in the semantics, lets say, between type systems and the things typed
18:12:50 <augur> :P
18:13:00 <copumpkin> assuming the things are correct
18:13:04 <augur> the computations and so forth might different, but the end results are ultimately the same
18:13:12 <Axman6> kniu: i wouldn't however. i'd use something like Binary
18:13:27 <kniu> whut
18:13:28 <Axman6> uh, Ke, not kniu
18:13:59 <augur> so now i guess my question is, outside of /computation/, is there a difference between /logics/ with types and logics without types
18:15:25 <Saizan_> mh, set theory and type theory end up being quite different, though that's not entirely because of types
18:15:27 <Axman6> Ke: http://code.haskell.org/binary/
18:16:41 <Saizan_> set theory being the untyped one, that explicitly uses predicates instead
18:16:57 <augur> well, but sorted logics can still employ set theory
18:17:04 <augur> where one of your sorts is sets
18:17:19 <augur> or sets-of-x's if you have more fully typed things
18:17:40 <augur> i mean, you logic can have an incredibly rich type ontology
18:18:02 <mmorrow> augur: in practicality though, it's less the end result that's often important (since that's usually assumed), but /when/ certain parts of this whole computation write-compile-change-compile-run-run-finish pipeline take place
18:18:17 <augur> mmorrow, as i said, none of that matters to me.
18:18:36 <mmorrow> augur: are you talking in the context of programming?
18:19:09 <augur> mmorrow: because its an easier question to answer, i think.
18:19:19 <augur> and something that people here would probably be more readily able to answer
18:19:21 <mmorrow> augur: or is this just in the abstract and using dynamic/static languages as an example of an idea
18:19:43 <augur> if i start bringing up crazy unsorted logics or whatever who knows if the average haskell CS expert will know what im talking about
18:19:51 <copumpkin> :)
18:19:52 <augur> thats all crazy logic
18:19:57 <augur> and god knows what logicians do!
18:20:05 <copumpkin> we're all intuitionists here
18:20:12 <mmorrow> augur: :) ok, i see where you're coming from
18:20:13 <augur> honestly, i had to understand unsorted logic in terms of prolog anyway
18:20:39 <augur> i couldnt for the life of me figure out what the hell it meant to say that you have this logic with no types
18:20:57 <augur> in which the expression 'x ∈ y' was completely valid
18:21:07 <augur> and x and y range over the whole domain of discourse
18:21:11 <augur> 1 ∈ 2?
18:21:11 <augur> what?
18:21:15 <Saizan_> eheh
18:21:25 <augur> then i just thought of this as a prolog expression and it made sense
18:21:42 <mmorrow> "No." ?
18:21:48 <Saizan_> 1 ∈ 2 actually holds with the usual construction for naturals
18:21:49 <augur> exactly
18:21:55 <augur> Saizan_: well true
18:22:00 <augur> but if 1 and 2 were atomic
18:22:05 <augur> or whatever
18:22:30 <augur> ok, Dick ∈ Jane
18:22:32 <Saizan_> only the empty set is atomic in ZFC :P
18:22:34 <augur> where those are people
18:22:39 <copumpkin> augur: eww
18:22:42 <augur> ;P
18:22:51 <copumpkin> very inappropriate
18:22:51 <mmorrow> , let (∈) = (+) in 1 ∈ 2
18:22:52 <augur> since the domain of discourse in natural language certain includes people
18:22:53 <lunabot>  3
18:22:54 <copumpkin> and heteronormative
18:23:18 <augur> depends on your assumption about the genders of these people!
18:23:43 <copumpkin> :O
18:23:58 <augur> Jayne from firefly would disagree :o
18:24:02 <augur> anyway
18:24:15 <augur> obviously with people, element-of isnt remotely possible
18:24:25 <augur> but if this were prolog, so what
18:25:02 <dolio> People are built out of sets in ZFC.
18:25:08 <augur> that was the only way i could make sense of what it means to have an unsorted logic -- thing of it like prolog, where predicates are true because of axioms, or because of proofs that terminate in axioms
18:25:14 <augur> dolio hush dont give them ideas :P
18:25:42 <Saizan_> well, i was going to say it, actually
18:25:43 <augur> and theyre not true or false because of the values themselves. when you think they are, you just dont realize you have axioms at the bottom of it
18:26:04 <augur> and im trying to make sense of the idea that types actually add something to all of this
18:26:07 <augur> and im not convinced they do
18:26:37 <augur> or take anything away, even.
18:27:17 <augur> cause they might constrain the system -- e.g. the simply typed lambda calculus with a requirement that every function is typed has no generic id function
18:27:19 <dolio> There are set theories where 1 ∈ 2 isn't a valid expression, though.
18:27:33 <augur> dolio, thats irrelevant to the point.
18:27:35 <dolio> Presumably using many-sorted logic.
18:27:44 <dolio> Because that sort of thing is nonsense.
18:27:56 <augur> i mean, yes, you can rule out _expressions_
18:28:38 <augur> but in the end, saying "this expression isn't a WFF" doesn't really tell you anything that "false" doesn't
18:28:48 <augur> it just says it differently
18:29:07 <augur> all the true statements are still true either way
18:29:24 <augur> its the other ones that are changed -- some go from False to Type Error
18:29:35 <Saizan_> what about Not (1 ∈ 2) ?
18:29:42 <dolio> 1 ∈ 2 not being well-formed is an important part of those set theories being attractive.
18:29:49 <damd> ∉
18:30:03 <augur> yeah god only knows Saizan_ :P
18:30:20 <Saizan_> that becomes true just because (1 ∈ 2) doesn't make sense?
18:30:37 <augur> does that CHANGE anything?
18:30:57 <Saizan_> it changes which propositions are true
18:31:03 <augur> sort of
18:31:14 <augur> but does it make anything that was true now false
18:31:20 <augur> or does it just add new true statements to the logic
18:31:41 <copumpkin> 1 ∈ 2 is false and Not (1 ∈ 2) is false, you have a problem
18:32:07 <augur> i mean, what im aiming for is a demonstration that the typed and untyped logics are both going to give you the same predictions regarding the statements of natural language
18:32:12 <tensorpudding> if P -> _|_, then P -> A is always true for any A
18:32:53 * Veinor headexplode
18:33:19 <augur> having an unsorted logic that allows you to say Not (1 ∈ 2) = True isnt going to give you any different predictions about natural language
18:33:25 <augur> as far as i can tell
18:33:40 <augur> because you only really ever get into that quandry with quantification
18:34:27 <dolio> I don't know about natural language, but "Not (1 ∈ 2) = True" makes for unsatisfying mathematics (if you ask me, and some other folks).
18:34:30 <augur> and who cares if you have forall x. x in y iff (x in dogs and x barked)
18:34:50 <augur> ok so y isnt the number 2 then, big deal
18:34:54 <Saizan_> your statement seems too vague to have any sort of demonstration/proof :)
18:35:28 <augur> Saizan_: oh god i know, trust me. im trying to get a footing first before i try to climb the mountain of proofs
18:35:50 <augur> if its trivially demonstrable that theres a difference then theres nothing for me to prove
18:36:06 <augur> the debate becomes an empirical one -- which kind of logic does natural language seem to employ
18:36:12 <augur> do experiments, find out.
18:36:14 <roconnor> phr: yes?
18:36:41 <augur> but if theres no difference, then the task is to show that this fact doesnt matter
18:37:18 <Saizan_> augur: i think the situation might get more problematic if you have an higher-order logic
18:37:26 <tensorpudding> we're throwing around natural language without a suitable definition of what that is
18:37:27 <augur> yes, so you can say that 'Not (1 ∈ 2)' is true in Prolog-with-failure-as-negation
18:37:29 <augur> big deal
18:37:33 <Saizan_> i.e. with quantifiers over propositions
18:37:35 <monochrom> Too much natural language. But Russell took a stab on it too.
18:37:37 <augur> this doesnt affect your theories about language
18:37:46 <augur> mm yes, well
18:38:01 <augur> noone has any clue how to really handle propositions
18:38:34 <copumpkin> who's noone? is that a great philosopher?
18:38:43 <augur> ;D
18:38:48 <harrisonpartch> monochrom, have you read betrand russell's short fiction?
18:38:50 <copumpkin> John Noon
18:38:51 <copumpkin> e
18:38:57 <augur> some people think of propositions as sets-of-possible-worlds e.g. { w : p is true in w }
18:39:03 <damd> copumpkin: that's from some film i believe?
18:39:04 <harrisonpartch> "the satan of suburbia" and other stories
18:39:06 <copumpkin> really?
18:39:12 <monochrom> No. But I read how he explained "the king of france is bald".
18:39:12 <damd> copumpkin: yeah, with that guy from dumb and dumber
18:39:16 <copumpkin> http://en.wikipedia.org/wiki/Craig_Noone
18:39:20 <copumpkin> oh, haven't seen it
18:39:21 <Saizan_> augur: propositions are just types :P
18:39:26 <augur> other people think of propositions as pairs of predicates with truth values
18:39:43 <dolio> Russell also figured out when it is numberwang.
18:39:49 <augur> (true, \<> -> fido is a dog)
18:39:51 <damd> my bad, it was "jasper noone"
18:40:10 <augur> some people think propositions are just quoted sentences
18:40:12 <copumpkin> numberwang?
18:40:31 <augur> but noones got any real solid grip on the notion of propositions
18:40:34 <augur> not in natural language anyway
18:40:55 * copumpkin plays with numberwang
18:42:39 <kamatsu> hey, i submitted some bindings to a C library to hackage, but hackage lacks the appropriate C library so it fails to build
18:42:43 <kamatsu> is this okay?
18:42:54 <ivanm> yes
18:42:58 <kamatsu> ok
18:43:08 <ivanm> kamatsu: the next version of hackage will allow you to upload docs for cases such as this
18:43:16 <kamatsu> i see
18:43:23 <Axman6> you just won't have any docs on hackage
18:43:37 <ivanm> and that's a better reason for failing then "oh, we seem to have used two different versions of bytestring! whoops!"
18:43:38 <ivanm> ;-)
18:45:56 <BMeph> copumpkin: Is your numberwang huge? ;p
18:46:05 <copumpkin> BMeph: computing
18:46:07 <kamatsu> Axman6: no docs on hackage? oh noes =(
18:46:23 <kamatsu> i suppose i can host the docs elsewhere
18:48:22 <kamatsu> or just demand people build it themselves
18:48:34 <ivanm> kamatsu: right, which the next version of hackage will fix
18:48:48 <kamatsu> cool
18:48:57 <monochrom> . o O ( cabal install hackage )
18:49:12 <ivanm> I doubt that works somehow...
18:49:23 <kamatsu> anyone know when next version of hackage is expected?
18:50:21 <ivanm> kamatsu: when it's written ;-)
18:50:35 <ivanm> IIRC there's a version of the current state running somewhere...
18:52:03 <mmorrow> @nixon
18:52:04 <lambdabot> I am not a crook.
18:52:34 <kmc> @. elite nixon
18:52:35 <lambdabot> \/OteRS QUIxx1Y ph0RgET W|-|A+ a M4n z4yz.
18:53:28 <Twey> ‘ck’ -> ‘xx’?  Really?
18:53:40 <aavogt> @elite "sick"
18:53:41 <lambdabot> "sixx"
18:53:53 <kamatsu> yeah, because of
18:53:56 <kamatsu> @elite "hackers"
18:53:57 <lambdabot> "hA(KerS"
18:54:00 <Twey> Ah
18:54:00 <kamatsu> what?
18:54:02 <Twey> Hahaha
18:54:04 <Twey> It's random
18:54:07 <kamatsu> @elite "hackers"
18:54:08 <lambdabot> "h4xxers"
18:54:10 <kamatsu> there
18:54:17 <kamatsu> should be h4xx0rz
18:54:19 <kamatsu> or something
18:54:22 * idnar h4xxes kamatsu 
18:54:23 <aavogt> @elite ckckckckck
18:54:24 <lambdabot> xxcxxxxxcK
18:54:28 <idnar> hahaha
18:54:57 <djahandarie> @elite elite
18:54:57 <lambdabot> 3|It3
18:55:01 <djahandarie> >_>
18:55:06 <kamatsu> that is stupid
18:55:09 <kamatsu> @elite leet
18:55:10 <lambdabot> lEET
18:55:12 <kamatsu> oh man
18:55:13 <kamatsu> =
18:55:36 <kamatsu> they should at least special case that
18:56:12 <aavogt> @help
18:56:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:56:18 <aavogt> @version
18:56:19 <lambdabot> lambdabot 4.2.2.1
18:56:19 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:56:36 <djahandarie> I don't really like the lambdabot code
18:56:40 <djahandarie> Messy architecture imo
18:56:40 <BMeph> Special cases roxx0rZ my 8oXX0rZ... ;p
18:57:34 <aavogt> djahandarie: do you have better ideas, or some similar project that works better?
18:57:50 <djahandarie> aavogt, not at the moment!
18:57:55 <djahandarie> In time. >.>
18:58:47 <Saizan_> it's known that lambdabot needs a major rewrite :)
18:59:06 <mathijsB> hm
18:59:09 <Saizan_> though maybe if it keeps evolving it can be the first AI
18:59:12 <kamatsu> maybe if i get time i'll do it
18:59:21 <mathijsB> i have a data type lik data Block  = Bullet Text  | Paragraph Text
18:59:23 <kamatsu> might be fun
18:59:25 <Saizan_> noone knows how it really works already
18:59:36 <mathijsB> say i have 2 variables of type BLock, is there any way to check if they are both Bullet, or Paragraph?
18:59:39 <aavogt> the issues with @seen and @users are quite subtle, right?
18:59:46 <kamatsu> mathijsB: yes
18:59:54 <mathijsB> i can check type using pattern matching, but that wont work in a lambda expression, for example in a dropWhile
18:59:56 <mathijsB> how?
19:00:13 <aavogt> copumpkin: your noone friend seems quite popular today
19:00:20 <kamatsu> isBullet (Bullet _) = True
19:00:23 <kamatsu> isBullet _ = False
19:00:30 <copumpkin> aavogt: indeed :)
19:01:13 <kamatsu> dropWhile isBullet my_list_of_blocks
19:01:17 <aavogt> mathijsB: also   (\x -> case x of Bullet _ -> True; _ -> False), if you only use it in one place
19:01:43 <mathijsB> oki, thanks alot
19:01:58 <mathijsB> is it possible too to just check if variable a has same type as variable b?
19:02:12 <mathijsB> without explictely checking for type Bullet?
19:02:12 <kamatsu> mathijsB: type, or constructor?
19:02:24 <mathijsB> eh, constructor is the rright word i guess
19:02:25 <kmc> it's known at compile time what type variables a and b have
19:02:31 <mathijsB> what i mean : bmade by the same constructor
19:02:54 <kamatsu> mathijsB: there is no built-in way aside from pattern matches
19:02:57 <Pseudonym> mathijsB, if you're planning to do that a lot, I have two suggestions.
19:03:02 <kamatsu> but you could easily write a function
19:03:09 <Pseudonym> The first is to reify the constructor.
19:03:16 <Veinor> just write a function a -> a -> b and call it on them
19:03:19 <Pseudonym> data ConstructorType = BulletT | ParagraphT
19:03:21 <Veinor> if it compiles, they have the same type :D
19:03:30 <Pseudonym> and derive Eq
19:03:31 <BMeph> mathijsB:  It's trivial to do it. The tricky part is arranging the function to accept values where it may not be true. ;)
19:03:51 <Pseudonym> Then make a function which maps a Block to its ConstructorType.
19:03:52 <aavogt> template haskell is another answer
19:04:01 <Pseudonym> I was going to mention SYB.
19:04:21 <Pseudonym> Which essentially does that, only without the B.
19:04:39 <mathijsB> it already derives Eq, just didnt paste the full datatype
19:05:22 <mathijsB> well thing is, i need to build html lists from an array of this data type, so i need to iterate while the elements have the same type to built html lists from them
19:05:23 <Pseudonym> However, I think that it's useful to do it the long way first.
19:05:30 <Pseudonym> You learn a lot that way. :-)
19:16:47 <ivanm> heh: http://twitpic.com/xhs02
19:17:21 <kmc> ha
19:22:19 <tensorpudding> how useful are the GHC extensions anyway?
19:22:35 <copumpkin> some are useless, others are great
19:23:09 <holmak> depends on what library you need to compile :p
19:23:22 <tensorpudding> i mean, for using in your own code
19:23:34 <tensorpudding> i get the vibe they're not "practical"
19:23:45 <holmak> I think some are
19:23:54 <holmak> ForeignFunctionInterface, definitely
19:24:02 <holmak> though that is technically in the standard
19:24:16 <holmak> still has to be enabled by pragma, though
19:24:34 <monochrom> All of them are practical.
19:24:46 <aavogt> even ImpredicativeTypes?
19:24:54 <holmak> I also like TypeSynonymInstances, though I might be a bad person for using them
19:25:06 <copumpkin> tensorpudding: I think most of them are pretty good, and that most of the minor change ones should be on by default
19:25:23 <copumpkin> tensorpudding: that isn't even all of them
19:25:36 <aavogt> some are purely sugar like ScopedTypeVariables
19:25:51 <tensorpudding> it feels hackish to see them
19:25:52 <Saizan_> so if you turn on FlexibleContexts twice you get a different language?
19:25:54 <opdolio> It probably depends on what you mean by "practical."
19:26:03 <copumpkin> tensorpudding: really?
19:26:13 <kmc> ImpredicativeTypes is deprecated
19:26:17 <copumpkin> tensorpudding: I think it's just acknowledging that a lot of interesting stuff has happened since h98
19:26:49 <aavogt> though maybe ScopedTypeVariables interacts with RankNTypes or other type system extensions
19:27:14 <kmc> RankNTypes, Flexible/Overlapping/UndecidableContexts, MultiParamTypeClasses, FunctionalDependencies, ExistentialQuantification are all used by some core stuff
19:27:15 <holmak> some of the stuff seems like it should go in. I have seen convincing use cases for dependent types, based on matrices, for instance.
19:27:21 <monochrom> I even have {-# -fglasgow-extensions #-} in some of my files and I sleep well at nights.
19:27:25 <kmc> and quite useful in code you write as well
19:27:43 <aavogt> interestingly newtype deriving is missing
19:27:43 <opdolio> IncoherentInstances strikes me as something you'd always want to avoid using, but I imagine you could come up with situations where it's useful in practice.
19:27:49 <kmc> tensorpudding, i don't know where you get the idea that they're not practical
19:28:06 <tensorpudding> because they're hard to understand?
19:28:16 <tensorpudding> some of them, anyway
19:28:17 <kmc> not all of them
19:28:21 <kmc> Haskell is hard to understand ;P
19:28:26 <kmc> each extension has a learning curve
19:28:31 <kmc> most of them are worth it
19:28:33 <monochrom> hard-to-understand and practical are independent.
19:28:47 <kmc> the typeclass extensions are mostly about lifting restrictions that seem arbitrary
19:29:00 <kmc> they extend the semantics of typeclasses in the way you'd expect, not by adding new rules
19:29:05 <monochrom> GPS is hard to understand but practical, everyone uses it. Do you understand the general relativity requirements of GPS?
19:29:20 <kmc> so you have to learn what they're good for, and how to avoid certain traps, but otherwise it's pretty intuitive
19:29:27 <copumpkin> yeah, IncoherentInstances is something I've never touched
19:29:33 <copumpkin> UndecidableInstances on the other hand can be quite useful
19:29:34 <tensorpudding> when i say practical, i mean, code that has to be maintained and for which other people will want to read it and be able to understand what it does
19:29:35 <kmc> i have, but it didn't end well
19:29:47 <kmc> tensorpudding, any experienced Haskell dev is going to be familiar with most of these
19:29:55 <kmc> because they really are pervasive
19:30:00 <aavogt> also, has ScopedTypeVariables been renamed?
19:30:06 <aavogt> or is that the new name
19:30:15 <copumpkin> that's the new name I think
19:30:33 <aavogt> Warning: -XPatternSignatures is deprecated: use -XScopedTypeVariables or pragma {-# LANGUAGE ScopedTypeVariables#-} instead
19:31:04 <Saizan_> PatternSignatures got merged into STV, but we already had STV
19:31:26 <kmc> i use -XGADTs a lot to get the nicer GADT syntax, but rarely do I declare a type that's actually a GADT
19:31:41 <kmc> i think the GADT syntax is just better and if i ever write an intro Haskell tutorial, it will use GADT syntax from page one
19:31:54 <aavogt> kmc: don't you lose deriving clauses?
19:31:54 <Saizan_> true
19:31:59 <kmc> no
19:32:00 <Saizan_> aavogt: no
19:32:05 <kmc> you can derive on a GADT, normally or standalone
19:32:06 <aavogt> that's goo
19:32:07 <EvanCarroll> @src seq
19:32:07 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:32:08 <aavogt> good
19:32:15 <mm_freak> kmc: all your types are GADTs
19:32:26 <tensorpudding> i guess my complaint boils down to haskell feeling exceptionally difficult to understand
19:32:33 <sproingie> all your ADT are belong to G
19:32:43 <kmc> tensorpudding, that's fair, but i don't think it has much to do with GHC extensions
19:32:45 <mm_freak> you rarely declare a data type, which is a GADT, but not an ADT
19:32:51 <kmc> yes fine mm_freak
19:33:14 <tensorpudding> does RWH talk about GHC extensions?
19:33:42 <kmc> it uses some, i'm sure
19:33:44 <mm_freak> however, haskell is one of those rare languages, for which there is a certain point, when it makes click and you suddenly understand it all
19:33:47 <aavogt> definitely a couple at least
19:33:51 <kmc> you can't use exceptions or the standard mtl monads without using a few extensions
19:33:53 <kmc> or the ST monad
19:33:57 <aavogt> mm_freak: all of it??
19:34:13 <mm_freak> aavogt: not all of it, but you 'get it'
19:34:34 <mm_freak> suddenly all the average haskell hackery makes sense
19:34:38 <kmc> C++ has a similar property, there is a certain point when it makes click and you suddenly want to stab Bjarne Stroustrup in the eye
19:34:46 <mm_freak> hehe
19:34:50 <copumpkin> lol
19:34:53 <aavogt> some things are pretty tough like TH... it has lots of arbitrary restrictions with quasiquotes
19:34:57 <tensorpudding> you have to learn a lot of haskell before you can write anything useful
19:35:43 <mm_freak> actually C++'s type system is on the right track, but the rest of the language…  well…
19:35:49 <kmc> TH is not used that much, and usually to avoid some serious pain
19:35:57 <kmc> it's a powerful tool-of-last-resort
19:36:17 <kmc> (or maybe second-to-last, rather than actually preprocessing your code using haskell-src-exts)
19:36:17 <mm_freak> TH, the template hack
19:36:31 <Saizan_> TH needs some love from developers to really make it nice to use
19:36:35 <mm_freak> never found a use for it
19:36:49 <kmc> i'm glad that we have powerful metaprogramming, and i'm also glad that it's not the solution to every abstraction problem
19:37:00 <kmc> some LISP programmers have the attitude that everything should be a macro
19:37:15 <sproingie> very little macro use in lisp is actually metaprogramming
19:37:21 <sproingie> most of the time it's just sugar
19:37:39 <kmc> it's a program that manipulates programs
19:37:48 <kmc> it's a metaprogram, if a trivial one
19:38:05 <kmc> people say that "LISP has no syntax"... but no, every special form and every user-defined macro is syntax
19:38:11 <sproingie> a lot of the time it just expands, very little logic
19:38:25 <sproingie> lisp has lots of syntax, it's just mostly uniform
19:38:55 <monochrom> @quote monochrom syntax rules
19:38:55 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
19:39:24 <kmc> heh
19:44:27 <copumpkin> omg a mxweas
19:44:57 <aavogt> omg a gmo
19:45:02 <mxweas> zomgz a pumpkin!
19:45:04 <mxweas> I ate at Morton's steakhouse in vegas last night. The best steak I've ever eaten in my entire life.
19:45:14 <copumpkin> mxweas: awesome :P
19:45:18 <monochrom> > reverse "wtf dsl"
19:45:19 <lambdabot>   "lsd ftw"
19:45:20 <copumpkin> #haskell-blah is probably better for that :)
19:45:21 <lunabot>  luna: parse error on input `)'
19:45:41 * sproingie did too much dsl
19:47:44 * BMeph is thankful sproingie didn't do too much LDS...but, yeah, -blah. ;)
19:50:11 <sproingie> if i have a variable that gets used as a GLint here, a GLsizei there, a GLfloat elsewhere, should I use fromIntegral everywhere, or should i just declare it polymorphic?
19:50:14 <phr> roconnor ?
19:50:54 <Saizan_> sproingie: i'd say the latter
19:51:04 <phr> @tell roconnor i was just going to mention some WP links about non-constructivity of the completeness theorem
19:51:04 <lambdabot> Consider it noted.
19:51:25 <sproingie> starting to lean that way.  GL gets tiresome with all the newtypes
19:52:47 <sproingie> so i went from windowWidth = celllsX * cellWidth to windowWidth = fromIntegral $ cellsX * cellWidth :: (Num t) => t
19:53:26 <mreh> ghc says "expected type" when it calculates the type from the context/signature, and "inferred type" about the type that the thing question actually is, correct?
19:53:41 <sproingie> that sounds right
19:54:17 <sproingie> the type it treats the thing in question as anyway.  i find what it "actually" is a bit slippery
19:54:54 <mreh> spoingie: it just makes the most general type it can doesn't it?
19:55:07 <sproingie> aw shit making it polymorphic didn't work
19:55:09 <mreh> as long as what is expect is as general, that's okay, i think
19:55:40 <sproingie> i use windowWidth as GLsizei on one line then GLdouble on the next and it still needs fromIntegral
19:56:21 <kmc> > let x :: (Num a) => a; x = 3; f :: Float -> (); f _ = (); g :: Int -> (); g _ = () in (f x, g x)
19:56:22 <lambdabot>   ((),())
19:57:46 <sproingie> f isn't using its arg
19:59:12 <kmc> > let x :: (Num a) => a; x = 3; f :: Float -> (); f 3 = (); g :: Int -> (); g 3 = () in (f x, g x)
19:59:13 <lambdabot>   ((),())
19:59:18 <monochrom> But types are checked.
19:59:21 <sproingie> oh hay now it works if i declare it
19:59:49 <sproingie> i originally did windowWidth = fromIntegral $ cellsX * cellWidth :: (Num t) => t
20:00:04 <mreh> can someone cast their eye on this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6008#a6008
20:00:05 <sproingie> which didn't work, but when i used a separate declaration it was fine
20:00:15 <mreh> the type error seems impossible to me
20:00:46 <mreh> I can't fix it if I think it's wrong!
20:05:18 <DekuNut> So, after asking the other day I realised I hadn't read enough to really understand, I've been reading this: http://en.wikibooks.org/wiki/Haskell/Category_theory
20:05:46 <DekuNut> In particular the section 'Functors in Hask' is what made most sense, but kmc mentioned to me that (->) is a category, but that's where I get lost, I don't get how (->) can be a category
20:05:52 <DekuNut> Would someone mind explaining?
20:06:04 <copumpkin> well, (->) isn't a category on its own
20:06:14 <copumpkin> a category is objects and morphisms
20:06:22 <DekuNut> Yeah, well, just to confirm I'm not mistaken
20:06:34 <DekuNut> By default, objects are types, functions are morphisms, this is the category Hask right?
20:06:35 <copumpkin> (->) is the morphisms of the category
20:06:38 <copumpkin> yeah
20:06:54 <DekuNut> So for example, the Maybe type is another category with Maybe Int, maybe Bool being objects of that category
20:07:02 <lhoersten> if I want a doubly linked list, is Data.Sequence the stsandard datastructure implementation for this?
20:07:12 <Twey>            if isNothing first
20:07:19 <bd_> Data.Sequence isn't a doubly linked list
20:07:20 <copumpkin> lhoersten: it isn't a doubly linked list, but you just want fast append?
20:07:22 <bd_> more like a deque
20:07:28 <DekuNut> Sup bd_ :o
20:07:30 <mreh> I fixed it, If anyone asked
20:07:32 <bd_> only with O(lg n) indexing and splitting
20:07:35 <bd_> DekuNut: o/
20:07:37 <DekuNut> But yeah copumpkin, does that sound right about Maybe?
20:07:43 <lhoersten> copumpkin: yeah I want those opperations
20:08:00 <copumpkin> lhoersten: DList or FMList might work well for you too, dunno
20:08:13 <copumpkin> DekuNut: it isn't another category, it's a functor
20:08:16 <lhoersten> copumpkin: and I want to be able to search from head or last looking for something in O(n)
20:08:47 <copumpkin> lhoersten: both of them allow that
20:08:53 <DekuNut> copumpkin, I mean, Maybe takes things from type A to Maybe A right? Which is from one object in one category to an object in another?
20:09:04 <copumpkin> DekuNut: yeah, but they're in the same category
20:09:07 <copumpkin> so it's an endofunctor
20:09:19 <DekuNut> Ah ok, one last thing though
20:09:33 <DekuNut> Morphisms being functions from one object to another, any function Maybe a -> Maybe b is a morphism right?
20:09:33 <lhoersten> copumpkin: both of which? DList, FMList, or Data.Seq?
20:09:41 <copumpkin> lhoersten: DList and FMList
20:09:45 <lhoersten> thanks
20:09:53 <lhoersten> i'm looking for the easiest interface, not efficiency
20:09:59 <copumpkin> DekuNut: sure, if by any you mean for specific values of a and b
20:10:11 <DekuNut> Yeah
20:10:59 <DekuNut> Ah, I think I get it then
20:11:12 <roconnor> phr: WP links?
20:11:13 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
20:11:18 <DekuNut> No wait, I'm a little lost copumpkin
20:11:28 <DekuNut> If f :: Maybe a -> Maybe b ,s a morephism, hos is (->) ALSO a morphism?
20:11:50 <copumpkin> (->) isn't itself a morphism
20:12:05 <idnar> isn't it a type morphism?
20:12:12 <copumpkin> well yeah
20:12:43 <DekuNut> There's different kinds of morphisms? :s
20:12:53 <copumpkin> well (->) takes two types and gives a third
20:13:03 <tensorpudding> (->) is an arrow
20:13:10 <copumpkin> nooo
20:13:17 <copumpkin> that confuses everything in this context :P
20:13:39 <tensorpudding> but Arrows are not category arrows right?
20:13:46 <copumpkin> nope
20:13:49 <DekuNut> Rofl, just guessing but, when you say takes two types and produces a third
20:13:57 <DekuNut> in the case, a -> b, it takes a and b and produces what?
20:14:01 <idnar> DekuNut: (->) itself is a function on types
20:14:08 <copumpkin> DekuNut: it takes a  and b and produces a -> b :)
20:14:24 <idnar> a -> b is really (->) a b
20:14:45 <DekuNut> :o, so it's kindof like, this is probably incorrect but tell me if my thinking is right:
20:14:51 <DekuNut> data (->) = (->) a b ...
20:14:54 <Ke> there is no pam support in haskell?
20:15:02 <Ke> or for
20:15:12 <copumpkin> data (->) a b = undefinable
20:15:40 <DekuNut> ^ yeah but, I meant to put (->) as the value constructor as well because if (->) can be a type and a constructor...
20:15:48 <copumpkin> it's only a type constructor
20:15:52 <copumpkin> it has no value constructors
20:16:11 <DekuNut> Oh right, sorry I was imagining things like 'Just 12', instead of 'Maybe a'
20:16:39 <Saizan_> you can see lambdas as the value constructors
20:16:41 <copumpkin> could you say (->) is a bifunctor?
20:16:54 <copumpkin> covariant in its first argument and contravariant in its second?
20:17:09 <Saizan_> wrong order
20:17:24 <copumpkin> yeah, sorry I meant covariant if you hold the first constant
20:17:33 <copumpkin> ;)
20:17:55 <Saizan_> ah, ok
20:18:02 <uoryfon> Contravariant functors? Interesting.
20:18:28 <Saizan_> with (a -> b) -> f b -> f a
20:18:39 <DekuNut> Ok, I'm still a bit lost then, if -> is a morphism that takes a and b (obects) to a -> b (another object), then f :: Maybe a -> Maybe b      <- in this, then what is f in relation to category theory? A value morphism?
20:18:47 <DekuNut> I'm sorry I seem constantly lost, sorry to drag on like this
20:19:05 <Saizan_> no, -> is not a morphism in that sense
20:19:10 <mathijsB> hm
20:19:17 <copumpkin> DekuNut: it's just a morphism, the _type_ a -> b is just another object
20:19:19 <mathijsB> is it possible to pattern match on an array of some type?
20:19:21 <mathijsB> like
20:19:23 <copumpkin> (for particular values of a and b, that is)
20:19:34 <Saizan_> (A -> B) is the type of morphisms between A and B
20:19:41 <copumpkin> DekuNut: it's an exponential object
20:19:48 <copumpkin> (I think)
20:20:11 <Saizan_> yeah, it's also an exponential object, which is what you get when the category internalizes morphisms
20:20:23 <uoryfon> Saizan_: Interesting use of "and" as a preposition. :P
20:20:23 <Saizan_> like haskell does since it has first-class functions
20:20:55 <DekuNut> Ah I'm so confused
20:20:59 <copumpkin> DekuNut: and exponential objects give you a notion of currying
20:21:20 <copumpkin> I think all regular values in Hask are representted as 1 -> a, aren't they?
20:21:47 <DekuNut> OH, SORRY
20:21:50 <DekuNut> <Saizan_> (A -> B) is the type of morphisms between A and B
20:22:07 <copumpkin> the actual function _values_ are the morphisms
20:22:17 <copumpkin> their domains and codomains are the objects
20:22:19 <DekuNut> Oh, ok then no it doesn't make sense
20:22:27 <DekuNut> What I was about to say was
20:23:11 <DekuNut> Wait, I think I've got it, let me have a go at this, correct me if I'm wrong
20:23:24 <sproingie> oh duh.  forgot to turn off the MR
20:23:31 <copumpkin> DekuNut: okay
20:23:42 <DekuNut> If (f :: a -> b), f has the type a -> b, making it a type itself, which is why functions are first class right? And the function takes a and be itself, which are each objects, so it takes objects from a to be
20:23:49 <DekuNut> But you could also take functions like:
20:23:54 <copumpkin> one way to see it is that haskell types are objects, haskell values are morphisms
20:23:58 <DekuNut> f :: (a -> b) -> (c -> d)
20:23:59 <DekuNut> Right?
20:24:11 <Saizan_> f is not a type.
20:24:19 <DekuNut> No fs type is after the :: I mean
20:24:26 <sproingie> i feel so silly for sprinkling all these fromIntegrals around when i just needed -XNoMonomorphismRestriction
20:24:58 <Twey> Heh
20:24:59 <DekuNut> I didn't mean f itself is a type, as in 'type f', I mean
20:25:05 <DekuNut> f is another object that can be moved from a to b
20:25:09 <Saizan_> what do you mean by "making it a type itself"?
20:25:18 <Saizan_> f is not an object
20:25:23 <Saizan_> f is a morphism
20:25:37 <DekuNut> f is a morphism between a and b right?
20:25:43 <Saizan_> right
20:25:47 <DekuNut> a -> b is the type, or another object right?
20:25:49 <Saizan_> a and b are objects
20:26:04 <copumpkin> and just to confuse things, a -> b is also an object
20:26:12 <copumpkin> but that's the type a -> b
20:26:14 <DekuNut> Yes copumpkin that's what I@m trying to say
20:26:21 <Saizan_> yeah, it is
20:26:22 <copumpkin> values of that type are still morphisms
20:26:26 <DekuNut> So you could also have a morphism that is a morphism between
20:26:29 <DekuNut> a -> b and c -> d
20:26:36 <Saizan_> yes
20:26:43 <DekuNut> Right, I phrased it badly but, I understand now
20:26:49 <DekuNut> Sorry to take so long
20:26:55 <copumpkin> no problem :)
20:26:59 <DekuNut> Really appreciate the help :i
20:27:00 <DekuNut> :o
20:27:13 <Saizan_> not in all categories you can have the collection of morphisms between two objects as an object itself
20:27:28 <copumpkin> DekuNut: do you know what a natural transformation is?
20:27:59 <DekuNut> copumpkin, I don't, but I just read the description
20:28:19 <copumpkin> well if a functor is a morphism between categories, a natural transformation is a morphism between functors :)
20:28:41 <DekuNut> Took the words out of my mouth, that's what I was going to ask rofl, brilliant
20:28:47 <DekuNut> Are there any common examples in haskell?
20:28:52 <copumpkin> all over the place! :D
20:29:05 <DekuNut> :o, mind naming a really common one?
20:29:23 <Twey> Are Haskell Functors completely unrelated to CT functors?
20:29:40 <copumpkin> Twey: they're completely related
20:29:43 <tensorpudding> instances of Functor are functors
20:29:46 <copumpkin> DekuNut: most functions
20:30:06 <copumpkin> DekuNut: any polymorphic function!
20:30:09 <DekuNut> Am I wrong in thinking f :: Mabe a -> Either b?
20:30:13 <tensorpudding> in the sense that the functor maps a to f a, and f to (fmap f)
20:30:13 <Axman6> @src Mayve fmap
20:30:13 <lambdabot> Source not found. :(
20:30:17 <Axman6> @src Maybe fmap
20:30:17 <lambdabot> fmap _ Nothing       = Nothing
20:30:17 <lambdabot> fmap f (Just a)      = Just (f a)
20:30:19 <Twey> But isn't a Functor about wrapping something, whereas a CT functor is a morphism?
20:30:30 <Saizan_> ?type maybeToList -- a natural transformation
20:30:32 <lambdabot> forall a. Maybe a -> [a]
20:30:40 <copumpkin> Twey: not at all, what is Maybe in haskell?
20:30:53 <tensorpudding> in CT, a functor is a morphism between categories that maps objects to objects and morphisms to morphisms
20:31:03 <tensorpudding> functors in Haskell are functors from Hask to Hask
20:31:12 <tensorpudding> Hask being the category of types
20:31:12 <copumpkin> Maybe takes a type (an object in hask) and gives a new type (another object in type), and fmap proves that all the morphisms (the functions a -> b) still exist in Maybe, and the laws say that they still compose correctly
20:31:15 <Twey> I thought that was a function
20:31:19 <Twey> Hum
20:31:28 <Twey> I see
20:31:43 <tensorpudding> if f is a function, then (fmap f) is the image of that function under the functor, so to speak
20:31:47 <copumpkin> think of fmap as (a -> b) -> (f a -> f b)
20:31:59 <copumpkin> it's taking a morphism and giving you a new one
20:32:07 <copumpkin> in the same category (hence the endo)
20:32:19 <copumpkin> but you still want it to compose nicely and stuff
20:32:24 <copumpkin> and that's what Functor's laws say
20:32:52 <DekuNut> That there is a natural transformation between functors?
20:33:25 <tensorpudding> [] is a functor that maps every type a in Hask to [a], and fmap takes functions which act on a's, and returns a function that acts on [a]'s
20:33:37 <Saizan_> no, that fmap respects the identity morphism and composition
20:33:50 <copumpkin> DekuNut: there are two ways of looking for natural transformations in haskell
20:33:50 <Saizan_> i.e. fmap id = id; fmap (f . g) = fmap f . fmap g
20:33:56 <copumpkin> one is a lot broader than the other :)
20:34:04 <DekuNut> Ok
20:34:06 <copumpkin> :t maybeToList
20:34:08 <lambdabot> forall a. Maybe a -> [a]
20:34:17 <copumpkin> Maybe is a functor, [] is a functor
20:34:21 <DekuNut> Oh
20:34:22 <DekuNut> Then yeah
20:34:23 <copumpkin> you're transforming between them
20:34:25 <DekuNut> I wasn't wrong here then: <DekuNut> Am I wrong in thinking f :: Mabe a -> Either b?
20:34:32 <DekuNut> Except it should've been Either a b
20:34:43 <copumpkin> yeah, you could define something like that, except Either takes two arguments
20:34:50 <copumpkin> so Maybe a -> Either () b
20:34:51 <lhoersten> its there a more suitable datastructure than List for finding and changing the nth element while preserving order?
20:34:56 <copumpkin> whoops, not b
20:34:59 <copumpkin> Maybe a -> Either () a
20:35:01 <DekuNut> Rofl
20:35:03 <Saizan_> lhoersten: Data.Sequence
20:35:10 <DekuNut> I had no idea you could do that with ()
20:35:15 <copumpkin> DekuNut: it's just a unit type
20:35:22 <copumpkin> we like to pretend it only has one value
20:35:34 <tensorpudding> dont' forget about _|_
20:35:42 <copumpkin> :(
20:35:45 <DekuNut> A penis?
20:35:49 <copumpkin> in fact, we can talk about Maybe a = 1 + a, and Either a b = a + b
20:35:50 <path[l]> lol
20:35:52 <copumpkin> () = 1
20:35:52 <lhoersten> Saizan_: if I use that, then I can't use (:) to pattern match can I?
20:35:54 <tensorpudding> _|_ is bottom
20:35:58 <copumpkin> so Either () b = 1 + b
20:36:00 <DekuNut> Rofl
20:36:05 <idnar> Void = 0
20:36:11 <DekuNut> Ah
20:36:21 <copumpkin> it has no values (shh tensorpudding)
20:36:21 <tensorpudding> it is the value returned by exceptions and non-halting terms
20:36:31 <Axman6> _|_ = ⊥
20:36:36 <tensorpudding> basically, undefined = _|_
20:36:41 <tensorpudding> @type undefined
20:36:42 <lambdabot> forall a. a
20:36:52 <pikhq> @type error
20:36:53 <lambdabot> forall a. [Char] -> a
20:36:54 <tensorpudding> it is a value in every type
20:37:08 <pikhq> error "any string" = _|_
20:37:10 <idnar> but we pretend it doesn't exist most of the time :P
20:37:27 <DekuNut> Brilliant rofl, this conversation has been really enlightening
20:37:53 <copumpkin> there is a broader sense of natural transformation than listToMaybe though
20:37:59 <copumpkin> or maybeToList
20:38:00 <idnar> hmm
20:38:11 <idnar> (a,b) = a x b
20:38:15 <DekuNut> Broader in what way?
20:38:15 <idnar> a -> b = a^b
20:38:17 <idnar> if I recall correctly
20:38:29 <copumpkin> DekuNut: you can see pretty much all polymorphic functions as being NTs
20:38:31 <copumpkin> b^a
20:38:37 <idnar> oh, whoops
20:38:55 <idnar> my armchair mathematics is showing through again ;)
20:39:16 <opdolio> Sometimes they're dinatural.
20:39:29 <Saizan_> lhoersten: you can't
20:39:32 <DekuNut> copumpkin, how so?
20:39:48 <copumpkin> DekuNut: you know Identity?
20:39:55 <copumpkin> it's the world's most boring functor
20:40:28 <copumpkin> if you have something like Just :: a -> Maybe a
20:40:28 <pikhq> It's the world's most boring instance of just about everything it has a non-pathological instance of.
20:40:37 <tensorpudding> the least fun functor
20:40:44 <copumpkin> DekuNut: if you squint enough, you can think of that as Identity a -> Maybe a
20:40:48 <copumpkin> with the exact same meaning
20:40:51 <copumpkin> and omg it's a NT
20:41:47 <copumpkin> this works for all polymorphic functions
20:41:56 <DekuNut> Sorry, someone linked a video, was busy raging, but er, I think I get you
20:42:05 <tensorpudding> it almost seems natural
20:42:10 <copumpkin> :)
20:42:36 <copumpkin> so something like id :: a -> a
20:42:43 <copumpkin> is actually Identity a -> Identity a
20:43:04 <copumpkin> and is thus a natural transformation from Identity to Identity
20:43:31 <tensorpudding> so id is the most boring natural transformation between the most boring functor to itself
20:43:35 <copumpkin> lol
20:43:48 <DekuNut> Got it, so it's like an endofunctor, though I hav eno idea if you could clal it 'endo'natural transformation rofl
20:44:09 <tensorpudding> all the functors in haskell are endofunctors aren't they?
20:44:13 <DekuNut> before you catch me out there, I don't mean it IS an endofunctor :p
20:44:16 <DekuNut> :o
20:46:57 <tensorpudding> at least, instances of Functor are
20:47:16 <copumpkin> tensorpudding: yep
20:48:59 <tensorpudding> you can think of functors over different categories though
20:52:26 <augur> copumpkin, Saizan_: regarding NOT(1 ∈ 2) from earlier
20:52:46 <augur> you could do a sort of prolog open-world thing
20:52:52 <augur> in which 1 ∈ 2 is unknown
20:52:57 <augur> and that gives you a sort of third value
20:53:12 <augur> sort of like the error value
20:53:21 <augur> and NOT(unknown) = unknown
20:53:26 <augur> so it propogates and so forth
21:05:14 <copumpkin> is a dynamic language a monoid? :)
21:05:46 <elly> I don't see why not
21:07:48 <Saizan_> augur: that makes quite more sense, yeah
21:08:21 <augur> Saizan_: i think thats the best way to view it
21:08:48 <augur> because it lets you say that "the destruction was happy" is not bad, its just a meaning that you dont understand how to answer
21:08:54 <Saizan_> though then you'd ask "when does my formula have a definite truth value?" "when it typechecks."
21:09:14 <augur> sure, but thats for the conceptual system to care about
21:09:33 <augur> linguistic semantics isnt about what is or isnt true but how the compositional system works
21:09:55 <augur> whats the combinatorics of meaning, is it truth-functional or not, etc.
21:11:31 <Saizan_> ok, i've no idea of what linguistic semantics are about :)
21:13:18 <augur> ;)
21:13:23 <augur> its basically the logic of language
21:13:35 <augur>  /meaning
21:13:39 <copumpkin> pff meanin
21:13:43 <copumpkin> who needs that
21:13:48 <augur> :P
21:14:16 <copumpkin> so can we go around calling people who use dynamic languages monoidal programmers?
21:14:20 <augur> its quite a diverse topic, actually, but most of the work has been done in a sort of strongly formal higher-order logic sense
21:23:31 <augur> Saizan_: its not a total solution tho
21:23:55 <Saizan_> augur: found a problem?
21:24:22 <augur> its acceptable as an explanation for how you can have, say, quantification over the whole domain, and not run into puzzles when your quantification results in asking the question '1 ∈ 2'
21:24:37 <augur> but it doesn't explain the unacceptability of sentences like "The destruction is happy"
21:25:01 <augur> '1 ∈ 2' results in 'unknown' precisely because theres no axiom saying its true or false
21:25:09 <augur> but its a question.
21:25:18 <augur> "the destruction of the city" is an assertion
21:25:58 <augur> and so it should be treated similarly to, say, 'assert(1 ∈ 2).'
21:26:09 <tensorpudding> are we still talking about this
21:26:38 <augur> but instead, its just bad, like its a type error. but it cant be that this is because its "unknown", because assertions arent unknown
21:27:03 <tensorpudding> 1 ∈ 2 is not a well-formed formula
21:27:09 <augur> tensorpudding: yes it is
21:27:15 <augur> if ∈ is untyped
21:27:18 <augur> which is the point
21:28:15 <tensorpudding> what does it mean for that to be untyped
21:28:47 <SamB_XP_> generally, 1 \in 2 is considered to be true ;-P
21:29:10 <SamB_XP_> because 2 = {0, 1} or somesuch
21:29:20 <augur> yes, we went over this earlier
21:29:29 <augur> numbers are presumed to be atomic for the purposes of this example
21:29:41 <augur> tensorpudding: the same way predicates are untyped in prolog
21:30:07 <tensorpudding> any sensible formulation of ∈ requires that the term on the right be a set
21:30:13 <vyom> I just installed GHC 6.12 for OS X from here. I am not trying to install cabal, but before that I need parsec and network packages.. how do I install those?
21:30:22 <vyom> http://www.haskell.org/ghc/download_ghc_6_12_1.html#sources
21:30:26 <augur> tensorpudding, its an example
21:30:46 <augur> therefore the sensible formulations are irrelevant
21:31:22 <Saizan_> vyom: "ghc-pkg list" doesn't include network?
21:31:55 <augur> the whole point is that if you have an untyped semantics, then its hard to use the semantics to explain the unacceptability of the sentence "the destruction was happy"
21:32:13 <Saizan_> augur: just use "has no meaning" rather than "unknown"
21:32:28 <augur> Saizan_: "has no meaning" doesn't mean anything :)
21:32:40 <augur> we're trying to explain what it would mean to say that something has no meaning
21:33:05 <Saizan_> that the conceptual system can't interpret it?
21:33:11 <augur> i mean, heres a meaning for it: exists x. the_destruction(x) & happy(x)
21:33:20 <dolio> Why is having 3-valued (or more) logic better than having multi-sorted logic?
21:33:33 <vyom> Saizan_: nope http://pastie.org/773222
21:33:38 <augur> dolio -- the point is to have an /un/sorted logic
21:33:55 <dolio> Yes, and you're inventing new truth values to do so.
21:34:02 <dolio> So why is that better?
21:34:17 <augur> god dont ask me, ask the people who think theres a difference
21:34:20 <Saizan_> vyom: well, you can download the parsec and network tarballs from hackage and install them manually via the Setup script
21:34:23 <copumpkin> > 3 `div` 2
21:34:24 <lambdabot>   1
21:34:30 <augur> im just trying to see if its possible to implement it sensibl
21:34:32 <augur> y
21:35:00 <luite> bah, spent most of the weekend making freetype ffi bindings and now I just found out that freetype doesn't like the fonts I wanted to use it for :(
21:35:00 <copumpkin> > let zomg 0 = 0; zomg 1 = 1; zomg n | even n = zomg (n `div` 2) | otherwise = let q = n `div` 2 in zomg q + zomg (q + 1); in zomg
21:35:03 <lambdabot>   * Exception: stack overflow
21:35:11 <copumpkin> :t let zomg 0 = 0; zomg 1 = 1; zomg n | even n = zomg (n `div` 2) | otherwise = let q = n `div` 2 in zomg q + zomg (q + 1); in zomg
21:35:13 <lambdabot> forall t t1. (Num t1, Integral t) => t -> t1
21:35:22 <copumpkin> > let zomg 0 = 0; zomg 1 = 1; zomg n | even n = zomg (n `div` 2) | otherwise = let q = n `div` 2 in zomg q + zomg (q + 1); in map zomg [0..]
21:35:24 <lambdabot>   [0,1,1,2,1,3,2,3,1,4,3,5,2,5,3,4,1,5,4,7,3,8,5,7,2,7,5,8,3,7,4,5,1,6,5,9,4,...
21:35:48 <copumpkin> > let zomg 0 = 0; zomg 1 = 1; zomg n | even n = zomg (n `div` 2) | otherwise = let q = n `div` 2 in zomg q + zomg (q + 1); in ap (%) tail $ map zomg [0..]
21:35:49 <lambdabot>   No instance for (GHC.Real.Integral [b])
21:35:50 <lambdabot>    arising from a use of `GHC.Real....
21:36:33 <copumpkin> > let zomg 0 = 0; zomg 1 = 1; zomg n | even n = zomg (n `div` 2) | otherwise = let q = n `div` 2 in zomg q + zomg (q + 1); in ap (zipWith (%)) tail $ map zomg [0..]
21:36:35 <lambdabot>   [0 % 1,1 % 1,1 % 2,2 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 % 4,4 % 3,3 % 5,5 % 2,2 ...
21:36:39 <augur> dolio: its actually more that unknown is not actually an answer
21:36:52 <augur> but rather some sort of bottom
21:37:27 <Veinor> why aren't functions in Haskell auto-memoized?
21:37:45 <copumpkin> Veinor: space leakage issues
21:37:45 <augur> the answer is either yes or no, but precisely which depends on your future discovery of the answer, which may not actually happen ever
21:37:48 <Veinor> ah
21:37:55 <Veinor> figured.
21:38:09 <copumpkin> isn't that list cool!
21:38:11 <copumpkin> I just saw it on twitter
21:38:14 <augur> or at least thats how i'd get around having unknown be a new truth value
21:38:35 <augur> but it doesnt actually solve the problem of why having a sorted logic is desirable, ironically
21:38:46 <augur> it merely solves an interesting problem of having an unsorted logic
21:39:48 <Saizan_> augur: maybe trying to work with these three-valued logic will be painful enough that you'd eventually wish a sorted one?:)
21:40:13 <augur> nah. the unsorted semantics never actually reference truth values
21:40:38 <augur> and dont depend on them in any special sense
21:41:33 <augur> any truth functional expression can be understood relatively sensibly with three-valued logic, i think
21:44:33 <CalJohn_> @hoogle ByteString -> Integer
21:44:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:44:34 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
21:44:34 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
21:45:19 <path[l]> I dont understand that zomg function
21:45:43 <copumpkin> path[l]: it's a magic rational-generating machine!
21:45:59 <path[l]> copumpkin: regarding space leakage, I get why its annoying, but I do wish it was possible to auto memoize more elegantly :)
21:46:16 <path[l]> oh does it generate all rational numbers?
21:46:28 <copumpkin> path[l]: go into FP research and make it more elegant :)
21:46:30 <copumpkin> path[l]: yep
21:46:38 <tensorpudding> stern-brocot tree?
21:46:38 <path[l]> ah interesting
21:46:59 <copumpkin> tensorpudding: defined in an odd way though
21:47:18 <copumpkin> not sure if that's got a name, I just saw it on twitter :)
21:48:10 <copumpkin> http://twitter.com/centurymath/status/7568497442
21:48:39 <Axman6> path[l]: there comes a popint where it takes more time to lookup the answer than just compute it. i've wondered for a while if some sort of memoisation annotation wouldn't be useful (like ! for strictness), so you could specify where to memoise a function, and have it off by default
21:50:04 <path[l]> yeah I fully accept the need to have to turn it on or off specifically, and I'm fine with off being the default. But I wish it was possible to do it automagically
21:50:21 <path[l]> the only argument might be that even the choice of the right structure to use to memoize might be important
21:50:24 <augur> Saizan_: ofcourse this only matters if you care about 1 ∈ 2 not being just false
21:50:32 <path[l]> list, map, tree, hash
21:51:16 <augur> if you have this idea that a thing is what it is because of its relationship to other things (e.g. 2 is 2 precisely because succ(1,2), etc.)
21:51:42 <path[l]> :t ap
21:51:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:52:06 <augur> then it might make complete sense to say that 1 ∈ 2 is false -- what makes 2 2 is in part precisely this, and what makes a given set what it is is precisely that for all of the things that are in that set, it bears the ∈ relationship to those things
21:52:15 <path[l]> what does ap mean, I dont get it
21:52:35 <copumpkin> :t (<*>)
21:52:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:52:42 <copumpkin> f (a -> b) -> (f a -> f b)
21:53:02 <copumpkin> you have a function inside a (applicative) functor, and want a function on it
21:53:16 <path[l]> sorry still lost :/
21:53:19 <copumpkin> > Just (+1) `ap` Just 4
21:53:20 <lambdabot>   Just 5
21:53:36 <path[l]> oh
21:53:39 <path[l]> its like lift?
21:53:42 <copumpkin> > [(+1), (*4)] `ap` [1,4]
21:53:43 <lambdabot>   [2,5,4,16]
21:53:46 <copumpkin> path[l]: sort of, but more powerful
21:54:15 <path[l]> it seems to be lifting a 2 parameter function into a monad
21:54:30 <path[l]> what does it do thats different
21:54:39 <copumpkin> well fmap allows you to lift a pure function into a functor, (a -> b) -> (f a -> f b)
21:54:47 <path[l]> Just (+1) `ap` Nothing
21:54:53 <path[l]> > Just (+1) `ap` Nothing
21:54:54 <lambdabot>   Nothing
21:54:54 <copumpkin> <*> or ap allows you to take a function that is itself in the functor
21:55:05 <copumpkin> (a -> b) -> (f a -> f b) vs. f (a -> b) -> (f a -> f b)
21:55:18 <path[l]> hmm
21:55:18 <path[l]> oh
21:55:25 <path[l]> I see your point
21:55:53 <path[l]> thanks :)
21:56:21 <copumpkin> np
21:56:30 <copumpkin> from ap you can easily build liftMn
21:56:43 <copumpkin> and with pure and ap you can get fmap again too :)
21:57:30 <Saizan_> augur: suppose i define not_elem(x,y) = every element of y is not x, then not_elem(1,2) doesn't make sense as much as "1 ∈ 2" doesn't make sense, is not_elem(1,2) false too?
21:57:55 <kniu> I want something in the type system that can check whether a certain vector is of unit length.
21:58:08 <augur> well
21:58:11 <Saizan_> actually, use "differs from" rather than "is not"
21:58:16 <copumpkin> kniu: write a Vec then
21:58:20 <augur> you're defining it in terms of elem, tho
21:58:26 <kniu> can't figure out how.
21:58:36 <kniu> seems to require dependent types.
21:58:45 <augur> forall z. z elem y -> x != z
21:59:00 <copumpkin> kniu: data Z = Z; data S n = S n; data Vec n a where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a
21:59:01 <Saizan_> yup
21:59:05 <augur> if z ranges over everything, including x (where x is a constant term)
21:59:11 <Saizan_> and _ elem 2 doesn't make sense
21:59:22 <copumpkin> kniu: now you can say you want a Vec (S Z) a
21:59:22 <augur> then it must be true that x elem y -> x != x
21:59:28 <Twey> > Just succ `ap` Just 5
21:59:29 <lambdabot>   Just 6
21:59:34 <Twey> @src (<*>)
21:59:35 <lambdabot> Source not found. :(
21:59:36 <kniu> copumpkin, that just ensures vector lengths.
21:59:42 <Twey> @src ap
21:59:43 <lambdabot> ap = liftM2 id
21:59:49 <Twey> Ohh
21:59:51 <copumpkin> <kniu> I want something in the type system that can check whether a certain vector is of unit length
21:59:53 <Twey> Is that all?  Huh.
21:59:58 <augur> if x elem y, then x != x, and this is a contradiction
22:00:02 <augur> but x elem y is false
22:00:13 <copumpkin> kniu: what did you want then?
22:00:15 <augur> and so the only way x elem y could be false, and the whole thing be true, is if x != x is false
22:00:18 <augur> which is sensible
22:00:33 <augur> so your definition of not_elem is actually precisely what you want
22:00:39 <kniu> "Vec a b c :: Vector -> if sqrt (a*a + b*b + c*c) == 1 then (Whatever the rest of the type is) else (throw type error)"
22:00:56 <augur> which i guess is a good thing!
22:01:04 <Saizan_> augur: ok, but a think you can find a construction where this breaks down
22:01:09 <copumpkin> kniu: oh, that kind of length! :P
22:01:09 <augur> maybe
22:01:22 <augur> i mean, it's just the closed world hypothesis, right
22:01:43 <augur> anything that isnt an axiom, or reducible to a conjunction over axioms, is false.
22:01:48 <copumpkin> kniu: yeah, you can't enforce that in haskell's type system, but you can trick it
22:01:56 <copumpkin> kniu: and just use a different vector representation
22:02:04 <augur> all the does, basically, is limit your logic's expressive power to some extent
22:02:19 <augur> but i think the limit is precisely the limit of incompleteness
22:02:29 <kniu> hm.
22:02:30 <augur> in tht there will be some true statements that aren't provable
22:02:37 <kniu> what if I do something like this:
22:02:39 <copumpkin> kniu: spherical coordinates with two coordinates, for example
22:02:40 <dolio> 1 ∈ 2 being either true or false is a perfectly workable situation, if it's okay with you.
22:03:05 <dolio> It must be, because the standard set theory almost everyone in mathematics uses works that way.
22:03:07 <augur> dolio: i'd relly prefer 2 ∈ 1, if you know what i mean ;o ;o ;o
22:03:08 <augur> XD
22:03:11 <copumpkin> kniu: you'd need special definitions of equality and the math might get ugly, but they're guaranteed to be unit vectors :)
22:03:25 <augur> dolio, like i said, numbers are assumed to be atomic for this example
22:03:28 <Twey> Works nicely if you read ∈ as ‘fork’
22:03:47 <dolio> But, some people think that situation sucks, and it seems to me that many sorted logic is the right way to fix that situation, if you don't like it.
22:04:01 <copumpkin> how many sorts?
22:04:04 <kniu> data Unit; data NotUnit; data Vector :: * -> * where makeUnitVector :: Double -> Double -> Double -> Vector Unit
22:04:08 <kniu> wait, shit.
22:04:15 <kniu> that thing can't do any checking.
22:04:19 <copumpkin> :)
22:04:44 <dolio> 3 works. You could probably work with other numbers.
22:05:06 <copumpkin> kniu: type-level length checking would be hopeless :) even agda has no real numbers cause they're a pain to define and work with
22:05:28 <augur> dolio - three sorts?
22:05:29 <copumpkin> of course I guess you could work with an arbitrary normed vector space
22:05:33 <dolio> Yes.
22:05:39 <augur> which?
22:06:00 <dolio> Elements, sets and predicates? Let me check.
22:06:09 <Saizan_> if you define subset(x, y) = forall a elem x -> a elem y, then subset(1,2) holds
22:06:11 <augur> well, that wont work for linguistic semantics ;)
22:06:26 <Saizan_> since there's no a elem 1
22:06:40 <Saizan_> (with the closed world assumtpion)
22:06:42 <dolio> Oh, elements, sets and relations.
22:06:46 <copumpkin> kniu: what's this for, anyway?
22:06:47 <augur> Saizan_: indeed
22:07:00 <kniu> Say we are able to write arbitrary programs at the type-level, and let encountering _|_ during type checking indicate a type error.
22:07:27 <copumpkin> you wouldn't have _|_ probably
22:07:33 <copumpkin> unless you mean the empty type
22:08:14 <augur> tho saizan, theres no reason you couldnt say
22:08:17 <dolio> I suppose relations probably aren't sorts in the logic.
22:08:24 <dolio> So perhaps it's 2-sorted.
22:08:48 <augur> subset(x,y) = set(x) & set(y) & forall a. a elem x -> a elem y
22:08:56 <augur> which is unsorted and correct
22:09:04 <kniu> Then I could just write a type Pi v : Vector. if normal? v then (whatever) else error "Not Unit"
22:09:16 <augur> dolio, they might be. it depends on who's defining the domain
22:09:28 <dolio> The thing I'm looking at isn't written down formally, though, so it's hard to tell.
22:09:33 <kniu> well, in this language I'm assuming there's no line between types and values.
22:09:43 <augur> most linguistic semantics stuff tho has the sorts Entities and Truth Values
22:09:51 <augur> and also usually Events
22:10:01 <augur> and maybe Times and Worlds
22:10:09 <copumpkin> kniu: how would you define reals? :)
22:10:37 <kniu> Can't they just be primitives?
22:10:49 <kniu> Continuous fractions?
22:11:06 <kniu> IEEE floating point?
22:11:07 <copumpkin> it's a tough question though
22:11:11 <copumpkin> if you want length == 1
22:11:24 <copumpkin> == 1 on reals tends to be rather painful/undecidable :P
22:11:32 <copumpkin> IEEE would be inexact
22:11:32 <kniu> very well.
22:11:36 <kniu> ~= 1
22:16:01 <kamatsu> wah, i want hackage to generate my docs
22:16:28 <kamatsu> alternatively, is there any way to host my docs elsewhere but have it generate links to hackage's docs for dependencies?
22:16:44 <copumpkin> kamatsu: I doubt it'll be much longer
22:16:50 <copumpkin> it's definitely no longer than a day
22:17:11 <kamatsu> copumpkin: no, the problem is it's bindings to a C library that the hackage machine doesn't have
22:17:22 <kamatsu> so it fails to build
22:17:22 <copumpkin> oh
22:18:24 <kamatsu> so, any way to generate docs that link to hackage for relevant bits?
22:19:57 <augur> im off to bed guys
22:19:57 <augur> night
22:19:58 <Saizan_> kamatsu: cabal haddock --html-location="http://hackage.haskell.org/packages/archive/\$pkg/\$version/doc/html/" --hyperlink-source
22:20:13 <kamatsu> thanks
22:20:34 * Saizan_ should make a FAQ
22:25:35 <pontybela> hi
22:25:43 <Twey> Hello
22:25:49 <Axman6> o/
22:26:46 <Axman6> oh, heh, pifish's irssi is running on my server
22:26:51 * ivanm waves idly in pontybela's general direction
22:26:55 <ivanm> Saizan_: an FAQ for what?
22:27:05 <Twey> Haha
22:27:33 <Axman6> and i just got disconnected. i don't think my router like this hear
22:27:39 <Axman6> (37.7°C)
22:27:50 <kmc> pour ice water on it
22:27:51 <ivanm> that's not hot!
22:28:00 <copumpkin> -17 here
22:28:28 <ivanm> http://www.tomscott.com/weather/starwars/
22:28:30 <kniu> oh boy.
22:28:40 <ivanm> (it's muggy as hell here atm)
22:28:49 <BMeph> Is graph reduction a form of term rewriting?
22:28:50 <kamatsu> Saizan_: Hm, i have a dependency on SDL, it didn't seem to find links from the SDL package
22:28:56 <kniu> non-deterministic errors while using System.Random
22:29:07 <pontybela> i've this: GHCi, vesion 6.10.4... when i try the simplest examples, i receive this: <interactive>:1:11: parse error on input `=' and i couldn't find out what's wrong
22:29:15 <Twey> −10 or so here
22:29:15 <kniu> put a let in front
22:29:24 <kniu> let x = 10
22:29:25 <Axman6> IT'S LIKETATOOINEOUT THERE
22:29:26 <Axman6> damn right
22:29:49 <mauke_> pontybela: put the code in a file
22:29:51 <copumpkin> Twey: where you at?
22:29:56 <Twey> England
22:29:57 <Axman6> Utinni!
22:30:19 <Twey> Oh, only −3 apparently
22:30:22 <Twey> It's warmed up
22:30:37 <copumpkin> that's t-shirt weather
22:30:51 <Twey> I always get cold this early in the morning
22:30:56 <kniu> I know a guy
22:31:07 <pontybela> aah... so in interactive mode i have to use let, but not when in "file mode"?
22:31:09 <kniu> who wears shorts at all times during a year.
22:31:24 <kniu> Even when it's freezing outside.
22:31:27 <copumpkin> pontybela: you can treat ghci as a big do block in IO
22:31:35 <copumpkin> that happens to accept colon-commands too
22:31:51 <tensorpudding> i can't find anyplace that is really hot apparently
22:31:55 <BMeph> It's 15 here. :)
22:32:00 <Axman6> kniu: i used to do that. rode to school a few times when it was below 0, and had ice form on my face
22:32:23 <kniu> frickin' white guys.
22:32:25 <Axman6> tensorpudding: try australian cities
22:32:40 <tensorpudding> i tried sydney
22:32:49 <kamatsu> i'm in sydney, that's not hot
22:32:52 <ivanm> copumpkin: ssshhh!!! don't let quicksilver hear you say that?
22:32:56 <kamatsu> try Cairns.
22:33:05 <copumpkin> ivanm: oh no, why not?
22:33:07 <Axman6> sydney's not how atm
22:33:10 <Axman6> hot*
22:33:12 <ivanm> kamatsu: it's buggy enough here in Brisbane that I wouldn't _want_ to try cairns or darwin
22:33:12 <BMeph> kniu: I know a couple of guys where I work that only wear shorts. I suspect it's because they're both clost to 2m tall. :)
22:33:22 <BMeph> *close
22:33:26 <pontybela> ok, thanks everyone! let worked. bye!
22:33:28 <kniu> BMeph, that guy I was talking about is 6'6"
22:33:33 <tensorpudding> cairns claims to be 30 C
22:33:38 <kniu> I'm starting to think there's a correlation.
22:33:40 <ivanm> copumpkin: IIRC, he hates the whole "ghci is a do block" statement
22:33:47 <copumpkin> ivanm: why?
22:33:50 <tensorpudding> which is a lot warmer than here
22:33:52 <ivanm> because it isn't
22:33:53 <tensorpudding> but not tatooine
22:34:04 <ivanm> since expressions of other types work, etc.
22:34:06 <kamatsu> anyway, my generated docs source basic stuff like Int etc. from Hackage, but it still doesn't link to SDL types in hackage.
22:34:07 <copumpkin> ivanm: how is it not? it autoshows things, I guess
22:34:12 <kamatsu> any ideas?
22:34:13 <tensorpudding> it says it's Hoth here
22:34:24 <copumpkin> it's pretty hoth here too
22:34:24 <Twey> Heh
22:34:24 <ivanm> copumpkin: right
22:34:29 <Axman6> ivanm: it's a do block with iomplicit print
22:34:32 <Axman6> implicit*
22:35:48 <BMeph> kniu: I'd say so; I'm 6'2" and it's a PITA finding pants in my size. I either wear 'em a couple of inches short, and wear boots, or get a white shirt and pocket protector and REALLY sport the stereotype...or wear shorts. ;)
22:36:08 <copumpkin> lol
22:37:15 <BMeph> copumpkin: It's getting Hoth in there, so put on tons more clothes? ;)
22:37:34 <kamatsu> i'll be back in a sec, if anyone can help me with my Haddock problem, please do
22:39:36 <kamatsu> (back)
22:40:25 <kamatsu> Saizan_'s command didn't change anything =(
22:42:25 <kamatsu> ah, got it
22:47:07 <dous> 6
22:47:22 <elly> 3
23:04:18 <sfuentes> can someone explain to me why this fails: testfunc = [] == []
23:04:19 <sfuentes> ?
23:04:47 <elly> fails how?
23:04:55 <elly> > let testfunc = [] == []
23:04:57 <lambdabot>   not an expression: `let testfunc = [] == []'
23:05:04 <Axman6> > let testFunc = [] == [] in testFunc
23:05:05 <lambdabot>   True
23:05:28 <Axman6> sfuentes: fails where? with what error? what are you doing?
23:05:56 <Axman6> (saying "why does this fail" without context is like me bringing you a bolt, and asking why it doesn't work)
23:06:21 <Perry___> Question: http://haskell.pastebin.com/d28f85f77 <- I am getting an error on line 47 where it says 'Haskell 98 does not support dependant parameters'
23:06:41 <Perry___> Can anyone shed some light into this matter?
23:07:12 <Axman6> what's the type of s?
23:07:17 <sfuentes> Axman6: i was trying to isolate the problem
23:07:29 <sfuentes> the context of which is here: http://pastie.org/773281
23:07:29 <Axman6> sfuentes: is this in ghci?
23:07:49 <sfuentes> its in a file i'm loading into ghci
23:07:53 <mauke_> that doesn't contain [] == []
23:08:04 <Axman6> by the way, palindrones can be odd sized
23:08:26 <Axman6> palindromes even
23:08:38 <sfuentes> Axman6: darn. thanks for the info
23:09:04 <mauke_> this code looks too complicated
23:09:19 <mauke_> isPalin xs = xs == reverse xs
23:09:26 <Axman6> (take (psize (x:xs)))?
23:09:55 <Axman6> :t app (==)
23:09:56 <lambdabot>     Couldn't match expected type `a -> a -> Bool'
23:09:56 <lambdabot>            against inferred type `(b -> c, b)'
23:09:56 <lambdabot>       Expected type: (a -> a -> Bool) -> t
23:09:57 <Axman6> :t ap (==)
23:09:58 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
23:10:12 <Axman6> > ap (==) reverse [1,2,1]
23:10:13 <lambdabot>   True
23:10:15 <sfuentes> i'm pretty new at this haskell stuff so bear with me
23:10:17 <Axman6> > ap (==) reverse [1,2,2]
23:10:18 <lambdabot>   False
23:10:21 <Axman6> jesus, i
23:10:30 <Axman6> i've never been able to use ap like that before :O
23:11:05 <Axman6> sfuentes: in your words, can you explain to me what a palindrome is?
23:11:35 <Axman6> @check \xs -> take (length xs) xs == xs
23:11:36 <lambdabot>   "OK, passed 500 tests."
23:12:40 <sfuentes> Axman6: i had the wrong definition apparently
23:12:56 <Axman6> that's fine. i want to know how you'd explain what a palindrome is :)
23:13:35 <sfuentes> which was a sequence followed/concatenated with the reverse of this sequence
23:13:57 <Axman6> > let palin = ap (==) reverse in palin "able was i ere i saw elba"
23:13:58 <lambdabot>   True
23:14:08 <mauke_> > let xs = [1, 2, 3] ++ reverse xs in xs
23:14:09 <sfuentes> which i guess is a subset of palindromes
23:14:12 <lambdabot>   mueval-core: Time limit exceeded
23:14:18 <mauke_> no, your definition doesn't terminate
23:14:19 <Axman6> sfuentes: more abstract, how would you define a palindrome in english, when talking about words
23:14:44 <Axman6> mauke_: yes it does, it just did didn't it? :P
23:14:58 <mauke_> oh, I misparsed
23:15:15 <Axman6> not really, you were right
23:15:44 <Axman6> sfuentes: i'd define it as: "a word whose spelling is the same as it's reversed spelling"
23:16:07 <sfuentes> Axman6: i was about to say that :)
23:16:37 <Axman6> so, if you look carefully, you can see that, if you have a word x, then it is a palindrome is x = the refersed x, or... isPalin xs = xs == reverse xs
23:16:49 <Axman6> s/is/if
23:16:54 <Axman6> reversed*
23:16:56 <Axman6> -_-
23:17:33 <merehap> isPalin is definitely my favorite function
23:17:34 <sfuentes> Axman6: yes. totally makes sense
23:17:35 <Axman6> (which should be read as, "isPalin xs is defined as xs equals reverse xs"
23:17:43 <merehap> with a close second being canPalin
23:17:58 <merehap> for example canPalin see Russia from her house
23:17:59 <merehap> :)
23:18:02 <Veinor> canPalin = const "you betcha!"
23:18:28 <merehap> > canPalin "See Mother Russia from her house"
23:18:29 <lambdabot>   Not in scope: `canPalin'
23:18:36 <Veinor> also, I'd say that isPalin shouldn't respect spaces
23:18:37 <Axman6> :(
23:18:49 <Jonno_FTW> a man a plan a canal panama
23:18:49 <merehap> @let canPalin = const "you betcha!"
23:18:50 <Axman6> Veinor: i would
23:18:50 <lambdabot>  Defined.
23:18:52 <sfuentes> but there was still something wrong on line 5 that i could not understand after looking at it for the longest time
23:18:54 <merehap> > canPalin "See Mother Russia from her house"
23:18:55 <lambdabot>   "you betcha!"
23:19:02 <Veinor> Axman6: then "a man a plan a canal panama" fails
23:19:16 <Veinor> > canPalin "write a pure function of type IO a -> a"
23:19:17 <lambdabot>   "you betcha!"
23:19:18 <Veinor> :O
23:19:31 <Axman6> sfuentes: ok, well, psize has what type? is it a function? a number? what?
23:19:41 <merehap> damn, should have voted for her...
23:19:48 <Axman6> Veinor: it's an impropper palindrome
23:19:51 <Axman6> >_>
23:19:55 * Axman6 is making shit up
23:20:05 <Axman6> even words it seems
23:20:12 <path[l]> why is it improper
23:20:20 <path[l]> you're counting spaces
23:20:20 <Veinor> cause it messes with spaces
23:20:20 <path[l]> ?
23:20:24 <path[l]> ah
23:20:26 <Veinor> > reverse "a man a plan a canal panama"
23:20:27 <lambdabot>   "amanap lanac a nalp a nam a"
23:20:39 <path[l]> palindrome sentences have always been that way
23:20:40 <mauke_> :t let sp x = const (sp x) [x, return (sp x)] in sp
23:20:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> a
23:20:54 <path[l]> the definition of palindrome involves ignoring spaces
23:21:13 <Veinor> well, "able was I ere I saw elba" is a space-respecting palindrome
23:21:17 <mauke_> :t let sp x = const (sp x) [putStr "IO" >> x, return (sp x)] in sp
23:21:18 <lambdabot> forall a. IO a -> a
23:21:19 <Veinor> so is "rats live on no evil star"
23:21:21 <Veinor> but they're pretty rare
23:21:33 <sfuentes> Axman6: psize is a function i defined that basically is like length
23:21:41 <Axman6> no it's not
23:21:41 <path[l]> lol Ive never heard that one before
23:21:42 <path[l]> nice
23:21:46 <sfuentes> revList is like reverse as well
23:21:47 <path[l]> rats live on no evil star
23:21:48 <Axman6> sfuentes: lsize is no?
23:21:54 <sfuentes> aaggh
23:21:55 <sfuentes> yes
23:21:58 <Axman6> :)
23:22:03 <sfuentes> i misread my own damn code!
23:22:13 <Axman6> so, your first problem is you're trying to apply a number to a list
23:22:31 <sfuentes> Axman6: i appreciate your patience
23:22:33 <Axman6> , but you're also not giving take enough arguments. what you wanted was take psize (x:xs)
23:22:34 <lunabot>  luna: Not in scope: `but'
23:22:41 <Axman6> sfuentes: not a problem :)
23:22:54 <Axman6> sfuentes: also, don't feel bad, feeling stupid makes you learn ;)
23:23:04 <Veinor> lunabot: hush you
23:23:31 <sfuentes> Axman6: well you're right ... i do feel stupid for not seing that
23:24:29 <Axman6> also, you've made my favourite begginner mistake ever
23:24:36 <Axman6> if x then True else False
23:24:46 <Veinor> Haha
23:24:55 <Axman6> or, in english, if x is true, then true, else x is false so false
23:25:29 <Axman6> basically, if x then True else False is exactly the same as x
23:25:49 <sfuentes> Axman6: i can explain that :)
23:26:28 <sfuentes> i was getting frustrated with the err on line 5 and i expanded the code
23:26:32 <Axman6> oh! you've just reminded to email a lecturer to see if i can be a tutor for his haskell course this semester!
23:28:25 * Axman6 -> Dinner
23:28:48 * hackagebot upload: Sprig 0.1.1 - Binding to Sprig (LiamOConnorDavis)
23:29:22 <Axman6> @hackage Sprig
23:29:23 <lambdabot> http://hackage.haskell.org/package/Sprig
23:29:50 * hackagebot upload: SFont 0.1.1 - SFont SDL Bitmap Fonts (LiamOConnorDavis)
23:38:42 <sfuentes> i'm sorry, i don't know what ap is/does
23:39:01 <tensorpudding> @source ap
23:39:02 <lambdabot> ap not available
23:39:14 <tensorpudding> @type ap
23:39:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:40:13 <tensorpudding> > return (+3) `ap` [1..10]
23:40:15 <lambdabot>   [4,5,6,7,8,9,10,11,12,13]
23:41:59 <Raynes> ap is complicated. :<
23:42:24 <Raynes> I had to read the definitions of liftM2 at least 44 times to understand it. :o
23:42:27 <sfuentes> seems so for this new guy
23:42:33 <tensorpudding> ap allows you to lift functions into monads more easily
23:42:49 <sfuentes> don't even know what a monad is at this point
23:43:09 <tensorpudding> there are too many metaphors for monads
23:43:12 <sfuentes> i'm bearly finishing chap3 from real world haskell
23:43:16 <Veinor> monads are like burritos
23:43:18 <Veinor> delicious!
23:43:46 <tensorpudding> monads are like burritos, they can contain some nasty side effects
23:43:49 <sfuentes> a monad sounds like an entity from modern algebra
23:43:58 <Raynes> A monad sounds like a gonad.
23:44:01 <Veinor> cause it is.
23:44:06 <path[l]> I've been stuck on the json chapter of rwh for the last 6 months :/, cause I stopped for a break
23:44:20 <tensorpudding> sfuentes: it is from category theory, which you can imagine is like algebra's daddy
23:44:20 <Raynes> path[l]: The JSON chapter is so godawful boring...
23:44:27 <path[l]> yeah lol
23:44:27 <merehap> Veinor has confirmed that a monad is a gonad. interesting...
23:44:46 <Raynes> A gonad is a whoanad.
23:45:01 <sfuentes> tensorpudding: so who's the bitch? :)
23:45:03 <tensorpudding> a monad is a functor with some extra stuff
23:45:40 <sfuentes> or mom
23:45:42 <Raynes> A functor is a monad's bitch.
23:45:45 <tensorpudding> and you can think of a functor as a mapping over types that preserves the structure of maps
23:46:38 <tensorpudding> as in, if F is a functor, and f :: a -> b, then there is an image of f under F of type F a -> F b
23:46:51 <tensorpudding> where F a and F b are the images of the types a and b under F
23:47:29 <tensorpudding> [] and Maybe are two functors
23:47:57 <tensorpudding> and for [], the image of f under the functor is (map f)
23:48:34 <sfuentes> tensorpudding: i need to let that marinate for a bit
23:49:19 <tensorpudding> i'm being reaaaally sloppy with notation there, i hope it's not confusing...
23:51:56 <sfuentes> tensorpudding: it sounds like my digestive system in another universe
23:55:30 <Veinor> merehap: a monad is like a gonad in that it tend sto fuck you
23:55:38 <Veinor> :D
23:57:41 <merehap> an unfortunate side effect...
