00:00:02 <mm_freak> one of the most powerful monads IMO
00:00:08 <adu> mm_freak: i mean (>>=) is the only way to simulate local variables and such
00:00:50 <adu> the list monad is king
00:00:54 <mm_freak> adu: perhaps you're associating monads with IO too much
00:01:01 <NullEntity> I get it now :D
00:01:05 <Veinor> :D
00:01:39 <mm_freak> adu: i tell C programmers this:  imagine you could write "y = sqrt(x);", then y would represent both results, not just one
00:01:49 <mm_freak> if you print y, you actually print two numbers
00:01:55 <mm_freak> (possibly)
00:01:58 <mm_freak> or none at all
00:02:33 <mm_freak> that's the list monad
00:02:59 <adu> mm_freak: no, but then again, i've only used 3 monads: IO, Maybe, and Parser
00:03:53 <mm_freak> adu: then start working with the list monad and monad transformers =)
00:04:30 <mm_freak> the semicolon overloading doesn't explain it all, but the = overloading does…  however, it's not overloading in the C++ sense
00:04:34 <adu> i know the basics of the list monad, just never used it, but i know it just does all combinations of all lists
00:04:41 <mm_freak> you're overloading the whole meaning, not just the functionality
00:05:27 <adu> mm_freak: I never said the metaphor was approriate for all monads, I just said I liked it
00:05:42 <adu> jeez
00:06:22 <mm_freak> adu: of course, it's just that when i used it a lot of C programmers complained:  "that's just making explicit what C does implicitly very well…  useless nonsense!" =)
00:06:56 <adu> i'm confused now
00:07:22 <adu> there is very few things in C that are implicit
00:08:51 <mm_freak> adu: sure, but that's about the reasoning i get =)
00:10:06 <fatalerrorx> i need help
00:10:12 <adu> hi fatalerrorx
00:10:20 <fatalerrorx> hey
00:10:39 <fatalerrorx> so i installed ghc 6.12.1
00:10:45 <fatalerrorx> on my vps
00:10:56 <adu> VPS = server?
00:11:06 <fatalerrorx> then i started to build cabal-install
00:11:07 <fatalerrorx> ya
00:11:10 <adu> VPS = PostScript?
00:11:17 <fatalerrorx> http://www.linode.com/
00:11:32 <fatalerrorx> server
00:11:38 <fatalerrorx> with 360mb ram
00:11:55 <adu> ooo
00:12:08 <fatalerrorx> anyway everything goes fine until it starts linking cabal
00:12:20 <fatalerrorx> then server dies
00:12:35 <adu> I think cabal-install installs to /home/$USER by default
00:12:39 <fatalerrorx> i think it uses more ram then i have
00:12:48 <ski> @let a `divs` b = (b `div` a) * a == b
00:12:49 <lambdabot>  Defined.
00:12:55 <ski> > 5 `divs` 0
00:12:56 <adu> would that cause a problem?
00:12:57 <lambdabot>   True
00:13:01 <ski> > 0 `divs` 0  -- :(
00:13:03 <lambdabot>   * Exception: divide by zero
00:13:06 <fatalerrorx> yeah
00:13:12 <fatalerrorx> cpu is at 20%
00:13:22 <fatalerrorx> so it must be eating ram
00:13:22 <adu> fatalerrorx: run it with --prefix=/usr/local and see if that helps
00:13:38 <ski> > 0 `mod` 5 == 0
00:13:40 <lambdabot>   True
00:13:44 <ski> > 0 `mod` 0 == 0
00:13:46 <lambdabot>   * Exception: divide by zero
00:13:52 <fatalerrorx> should i stop my rails site?
00:13:56 <adu> or whatever special things you need to do to install it globally
00:14:05 <fatalerrorx> free up ram
00:14:16 <adu> fatalerrorx: that shouldn't matter, but worth a try
00:14:21 <fatalerrorx> ok
00:14:39 <ski> @let mod_ :: Integral a => a -> a -> a; n `mod_` 0 = n; n `mod_` d = n `mod` d
00:14:41 <lambdabot>  Defined.
00:15:07 <ski> @let divides :: Integral a => a -> a -> Bool; d `divides` n = n `mod_` d == 0
00:15:09 <lambdabot>  Defined.
00:15:20 <ski> > 5 `divides` 0
00:15:22 <lambdabot>   True
00:15:23 <ski> > 0 `divides` 0
00:15:24 <lambdabot>   True
00:16:12 <adu> mm_freak: oh, btw, monad transformers scare me
00:16:18 <fatalerrorx> nvm it just finished 30 minutes later :)
00:16:24 <c_wraith> > undefined `divides` 0
00:16:25 <lambdabot>   * Exception: Prelude.undefined
00:16:31 <NullEntity> Veinor: your code isn't working =(
00:16:33 <c_wraith> !!!  unnecessary strictness!
00:16:35 <mm_freak> adu: what scares you about them?
00:16:41 <dolio> > 0 `divides` undefined
00:16:42 <lambdabot>   * Exception: Prelude.undefined
00:16:52 <adu> mm_freak: everything...
00:17:25 <ski> c_wraith : hm, i suppose so ..
00:17:33 <adu> mm_freak: I guess its the same thing that scares people about monads, I don't understand how to fix the compiler errors when I try to use them
00:17:53 <c_wraith> ski: it's the one special case where it could be slightly less strict.  Probably not important to optimize for
00:18:02 <Veinor> NullEntity: what's not working, what error are you getting?
00:18:32 <ski> c_wraith : it'd still irritating that `mod n 0' gives you an error, though ..
00:18:42 <mm_freak> adu: well…  they are actually very simple
00:19:02 <NullEntity> parse error on input `='
00:19:14 <adu> mm_freak: is GenParser a monad transformer?
00:19:15 <ski> (`quot n 0' giving an error might be acceptable)
00:19:22 <ski> (er, s/quot/rem/)
00:19:46 <Veinor> ok, could you put the exact code you put in a pastebin?
00:19:51 <Veinor> http://hpaste.org/
00:20:04 <mm_freak> adu: i don't know what Parsec's basement machinery looks like
00:22:39 <adu> i just remembered, i was going to write a lens library
00:27:22 <dobblego> I have a build error on hackage, but I cannot produce it locally -- is there a usual next step?
00:28:57 <adu> dobblego: what's the error?
00:29:41 <dobblego> adu, http://hackage.haskell.org/packages/archive/GPX/0.4.6/logs/failure/ghc-6.12
00:30:15 <dobblego> seems to be a haddock error?
00:31:13 <c_wraith> dobblego: do you have an non-ascii characters in your source or cabal file?  Someone had issues with that a couple days ago.  (haddock errors because of it)
00:31:17 <c_wraith> *any
00:31:20 <dobblego> c
00:31:27 <dobblego> c_wraith, I really don't think so
00:34:39 <tomoj> is there a method to inspect the type of a function for a specific instance besides just substituting manually?
00:34:59 <tomoj> I feel this would be helpful while trying to understand some code
00:35:45 <c_wraith> :t (?f &&& ?g)
00:35:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (?f::a b c, ?g::a b c', Arrow a) => a b (c, c')
00:35:59 <c_wraith> :t (?f &&& ?g) x
00:36:00 <lambdabot> forall c c'. (?g::Expr -> c', ?f::Expr -> c) => (c, c')
00:36:09 <c_wraith> :t (?f &&& ?g) ?x
00:36:10 <lambdabot> forall b c c'. (?x::b, ?g::b -> c', ?f::b -> c) => (c, c')
00:36:23 <c_wraith> You can do things like that.
00:36:48 <c_wraith> ...  With the proper extension turned on
00:38:02 <tomoj> hmm
00:38:17 <tomoj> I don't understand that at all, I think I'll forge on
00:38:41 <c_wraith> you can also do thing like
00:39:46 <c_wraith> > let argType :: (a -> b) -> a -> (a -> b) ; argType = const in reverse `argType` ""
00:39:47 <lambdabot>   ""->
00:39:47 <lambdabot>    ""
00:39:47 <lambdabot>  "a"->
00:39:47 <lambdabot>    "a"
00:39:47 <lambdabot>  "aa"->
00:39:49 <lambdabot> [6 @more lines]
00:39:51 <c_wraith> :t let argType :: (a -> b) -> a -> (a -> b) ; argType = const in reverse `argType` ""
00:39:52 <lambdabot> [Char] -> [Char]
00:40:07 <c_wraith> sorry, for got I wanted :t on that
00:40:39 <c_wraith> as you can see, reverse is normally polymorphic, but the type signature specialized it
00:42:06 <c_wraith> writing functions that do all their work in their type signature is amusing.
00:42:08 <tomoj> that looks pretty crazy
00:42:24 <tomoj> I think I was trying to understand some stuff that did that a while ago
00:42:41 <tomoj> for now I will just play around at the repl, just want to generate some xhtml
00:45:42 <c_wraith> :t let argType :: (a -> b) -> a -> (a -> b) ; argType = const in (+) `argType` 3.0
00:45:43 <lambdabot> forall a. (Fractional a) => a -> a -> a
00:46:35 <c_wraith> what's an appropriate name for that, anyway?  argType isn't quite right.  argTypeOf?
00:47:08 <c_wraith> :t typeOf
00:47:10 <lambdabot> forall a. (Typeable a) => a -> TypeRep
00:47:29 <copumpkin> t asTypeIn
00:47:45 <copumpkin> :t asTypeIn
00:47:45 <lambdabot> forall a b. a -> (a -> b) -> a
00:50:37 <c_wraith> that seems less interesting.
00:51:00 <c_wraith> It will only tell you what the argument specializes to, rather than what the function specializes to
00:59:20 <manjunaths> hello
00:59:27 <dmwit> hiya
00:59:37 <manjunaths> how do I read an Int from a file ?
00:59:53 <manjunaths> or a byte
01:00:20 <dmwit> hReadLn, hGetChar
01:00:20 <manjunaths> I am trying to parse a binary file, I've opened the file, now I am not sure how to read an integer
01:00:26 <dmwit> ah, okay
01:00:30 <manjunaths> Char is a byte ?
01:00:31 <c_wraith> @hackage binary
01:00:32 <lambdabot> http://hackage.haskell.org/package/binary
01:00:35 <dmwit> In that case, have a look at the binary package.
01:00:42 <dmwit> Char is not a byte.
01:00:48 <manjunaths> ok
01:00:51 <c_wraith> Char is like...  4 bytes.
01:01:04 <dmwit> Char is a Unicode codepoint.
01:01:13 <dmwit> How many bytes it takes in a file depends on the encoding.
01:01:29 <c_wraith> I was assuming in-memory. *shrug*
01:01:30 <manjunaths> ok...
01:02:55 <c_wraith> Unicode is an admission that text is *hard*, when you start considering multiple languages.
01:06:06 <voidprayer> UTF-8 should cost only one byte for normal English Unicode character.
01:06:11 <voidprayer> Why always 4?
01:06:27 <dmwit> Hm?
01:06:31 <paolino> why patch download rate for darcs is 10 KiB/s ?
01:06:49 <Beelsebob> paolino: because your internet connection is sucking?
01:07:15 <dmwit> voidprayer: The in-memory representation of a Char is implementation-dependant.
01:07:27 <paolino> well, I wouldn't ask if that was the case
01:07:28 <voidprayer> dmwit: I see.
01:07:43 <paolino> Beelsebob: can you darcs get --partial http://code.haskell.org/gtk2hs
01:08:10 <paolino> it takes minutes here
01:08:17 <voidprayer> dmwit: btw, if ghc cannot be built under LANG="en_US.UTF-8", should this a bug to report?
01:08:51 <Beelsebob> paolino: yep, it's going slow here, looks like it's galois' connection that's not working so well
01:08:58 <paolino> and no cpus are used for 99% of the time
01:09:17 <dmwit> voidprayer: uh
01:09:26 <dmwit> voidprayer: That question should maybe go to #ghc.
01:09:38 <dmwit> voidprayer: Though I would err on the side of filing too many bug reports than on the side of filing too few.
01:09:48 <dmwit> You can always mark bugs invalid. =)
01:13:00 <hcube> hello
01:13:05 <dmwit> hiya
01:13:33 <hcube> What do you think, which is teh best ffi binding gen tool for haskell?
01:13:35 <hcube> *the
01:14:29 <dmwit> c2hs is popular
01:16:09 <hcube> yes, it seems very feature rich
01:18:40 <tomberek> hello hello?
01:19:37 <dmwit> hey
01:19:44 <tomberek> sweet.. thanks
01:20:03 <dmwit> Now then... what can we help you with? =)
01:20:21 <tomberek> i'm was trying to ask a question regarding monoids vs monads.. both have associativity and a neutral element,, what's the difference?
01:20:39 <dmwit> Ah!
01:20:41 <dmwit> Very astute.
01:20:51 <tomberek> so monads ARE monoids?
01:20:54 <dmwit> Monads are monoids.
01:20:58 <tomberek> yay!
01:20:58 <dmwit> yes!
01:21:04 <tomberek> but not vice versa?
01:21:13 <dmwit> Not all monoids are monads, no.
01:21:38 <Adamant> one might even say that monads are a subset of monoids
01:22:16 <Adamant> if they didn't mind getting cat theorists yelling at them :P
01:22:32 <dmwit> "A monad is a monoid in the category of endofunctors."
01:22:47 <tomberek> wow.. not a single "monad tutorial" said that
01:23:44 <dmwit> I think that sentence has a very narrow audience.
01:24:13 <copumpkin> pretty much every haskell thread that mentions newbies learning monads mentions it
01:24:20 <dolio> Set theorists would probably get mad at you, too.
01:24:28 <dolio> Since there's probably no set of all monoids.
01:24:29 <copumpkin> often with something along the lines of "duh", or "isn't it obvious"
01:24:34 <Adamant> dolio: probably :P
01:24:50 <dmwit> I'm actually quite impressed with tomberek, as he seems to think it is genuinely helpful.
01:25:20 <Adamant> it gave me an excuse to look up endofunctors
01:25:20 <dmwit> He'll be eating dependent types for breakfast by the morning.
01:25:46 <copumpkin> tomberek: the associativity and neutral element for monads is less obvious
01:26:00 <copumpkin> Cale wrote a good explanation of it on reddit once and I wrote a less good one on reddit more recently
01:26:05 * dmwit mumbles something about mollifying set theorists by replacing "set" with "class" a few places
01:26:18 <tomberek> ok ok... i admit I'm new to this.  I'm trying to make a neural network, so I'm running into monad concepts, "tying the knot", and other things I'm not used to... yet
01:26:38 <Adamant> so semi-OT: what is universal algebra still used for in the era of cat. theory
01:27:02 <Adamant> I thought it was an alternative attempt to do something fairly similar
01:27:03 <dolio> Speaking of that, having read stuff at the n-category cafe for a little while, there seems to be an idea floating around...
01:27:17 <copumpkin> need moar operads
01:27:44 <dolio> That the most natural 'collection' of all sets is the category of all sets, and that the most natural collection of all categories is the 2-category of all categories, and so on.
01:28:13 <dolio> And so, that would make a good foundational structure for mathematics.
01:28:33 <dolio> And perhaps, it might be naturally free of Russel style paradox.
01:28:34 <tomberek> you run into the same problem as with cantor numbers
01:29:00 <copumpkin> tomberek: http://www.reddit.com/r/programming/comments/a7cii/what_a_monad_is_not/c0g7711 and http://www.reddit.com/r/programming/comments/aewnc/monads_are_like_burritos/c0h95dh
01:29:39 <dolio> But, I'm not sure it naturally eliminates all size paradoxes.
01:30:43 <ivanm> it's that co-squash character!
01:31:05 <Adamant> copumpkin: thanks!
01:31:18 <tomberek> copumkin: give me sec to get through all this
01:31:18 <Adamant> looking up 'operad' basically told me :P
01:31:56 <copumpkin> :)
01:32:17 * copumpkin gives ivanm the evil eye
01:32:38 * ivanm takes the evil eye copumpkin gave him and ptus it in his evil relics display cabinet
01:32:56 <ivanm> it's not quite the best evil eye I've got, but it certainly has some unique properties
01:33:01 <copumpkin> :O
01:33:08 <copumpkin> giv' it 'ere
01:33:23 <ivanm> for starters, I've never heard of a squash having an eye before, evil or otherwise
01:33:24 <ivanm> :p
01:33:40 <Adamant> ivanm: if potatos can have eyes... :P
01:34:01 <ivanm> Adamant: but potatos aren't squashes...
01:34:20 <copumpkin> P. Tater is my cousin
01:34:22 <Adamant> ivanm: why are you discriminating against the squashes
01:34:35 <sohum> @pl \x y z -> f (g x y z)
01:34:36 <lambdabot> ((f .) .) . g
01:34:42 <ivanm> Adamant: http://en.wikipedia.org/wiki/Pumpkin
01:34:52 <ivanm> copumpkin: heh
01:35:01 <Adamant> lol
01:35:12 <Adamant> I totally forgot about the halloween angle
01:35:13 <sohum> :t \f g -> ((f .) .) . g
01:35:14 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f2 (f1 (f a)) -> f2 (f1 (f b))
01:35:15 <copumpkin> okay, time for me to go to sleep once and for all
01:35:19 <ivanm> Adamant: halloween angle?
01:35:22 <ivanm> silly yanks...
01:35:23 <sohum> wooo caleskell
01:35:31 <ivanm> @slap Caleskell
01:35:31 <lambdabot> I'd rather not; Caleskell looks rather dangerous.
01:35:36 <ivanm> grrrr....
01:35:55 <sohum> :t (.) . (.) . (.)
01:35:56 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
01:36:08 <sohum> same, ok.
01:36:16 <Adamant> ivanm: I know a pumpkin is a squash, but I was thinking in terms of it being a squash and not being a Halloween decoration :P
01:36:30 <ivanm> Adamant: I was thinking in terms of it being a squash...
01:37:22 * ivanm points out that he is from Australia, where they do not have a commercial celebration designed to ensure dentist's livelihoods
01:37:35 <Adamant> not enough Irish?
01:37:45 * copumpkin points out that he is not from the US, once more
01:37:54 <ivanm> copumpkin: but you are _in_ the USA
01:37:54 <Veinor> DENTAL PLAN
01:38:02 <ivanm> Adamant: hmmm?
01:38:02 <copumpkin> ivanm: so you never travel?
01:38:12 <ivanm> copumpkin: sure I travel; I'm in Madrid atm
01:38:20 <copumpkin> ivanm: OMG WHY DO YOU TORTURE BULLS
01:38:22 <tomberek> copumpkin: reading through those pages gives me this idea.  An easier way to explain it is to say that "monoid" is an adjective which when applied to endofunctors IS a thing called a "monad" (noun)
01:38:33 <ivanm> but I was talking about Adamant, not you (for once)
01:38:34 <ivanm> ;-)
01:38:44 <ivanm> copumpkin: but I don't _live_ in Madrid..
01:38:54 <copumpkin> ivanm: I only pretend to live in the US
01:38:58 <Adamant> ivanm: Halloween in America is more or less revised Samhain
01:39:07 <Adamant> which is from the Irish
01:39:18 <Adamant> and I thought Australia had plenty of Irish population
01:39:34 <Veinor> copumpkin, where are you actually from? I forgot.
01:39:37 <ivanm> Adamant: really? Irish children go around and extort items high in sugar from the populace under threat of property damage?
01:39:38 <copumpkin> tomberek: I guess with a sufficiently general definition of associativity and identity that could work
01:39:43 <Adamant> and the carving eyes into various vegetable thing works in all of them :P
01:39:51 <copumpkin> Veinor: I'm from the patch! :P
01:39:57 <ivanm> @slap copumpkin
01:39:57 * lambdabot submits copumpkin's email address to a dozen spam lists
01:40:00 <copumpkin> and/or london/rome
01:40:37 <ivanm> copumpkin: you were born in two cities at once? :p
01:40:46 <Adamant> ivanm: no, but they traditionally carved vegetables into goofy versions of faces
01:40:55 <Adamant> just, you know, turnips and not pumpkins
01:40:58 <tomberek> copumpkin: it isn't perfect, but perhaps would be easier for someone brand new to the concepts
01:41:09 <ivanm> Adamant: right; I was ridiculing the other aspects of Halloween as seemingly practiced in the USA
01:41:20 <copumpkin> almost :) the "where from" question isn't very precise, and according to the two most common definitions that would be my answer
01:41:26 <copumpkin> ivanm: ^
01:41:48 <ivanm> copumpkin: heh
01:41:50 <Adamant> ivanm: I'm tired and slow on the uptake apparently
01:41:57 <Veinor> which were you born in, which were you raised in?
01:41:59 <Veinor> :P
01:42:07 <ivanm> yeah
01:42:23 <Adamant> ivanm: and any humorous response would probably involve ethnic humor against the Irish :P
01:42:44 <copumpkin> born in london
01:43:06 <ivanm> Adamant: oh? since when has that been a problem?
01:43:06 <ivanm> :p
01:44:02 <Veinor> so were you raised in Rome then, or is there some other reason you gave that answer to that question? :P
01:44:23 <Adamant> ivanm: the real Irish have trouble enough right now.
01:44:28 <ivanm> Adamant: true
01:44:29 <copumpkin> Veinor: yeah, only came to the US for college
01:44:53 <Veinor> ah
01:44:58 <ivanm> copumpkin: so which country/countries are you a citizen of?
01:45:02 <Veinor> so is Italian your native language then?
01:45:07 * Veinor renames #haskell to #copumpking
01:45:10 <Veinor> *copumpkin
01:45:11 <copumpkin> lol
01:45:17 <copumpkin> yeah, this is kinda off-topic isn't it
01:45:22 <ivanm> @quote off-topic
01:45:23 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
01:45:26 <ivanm> @quote off-topic
01:45:26 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
01:45:28 <ivanm> bah
01:45:30 <ivanm> @quote topic
01:45:31 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
01:45:32 <ivanm> @quote topic
01:45:33 <lambdabot> DRMacIver says: #haskell doesn't so much wander off topic as orbit it. :)
01:45:37 <ivanm> there we are!
01:45:43 <copumpkin> ivanm: US/UK
01:46:06 <ivanm> copumpkin: so you _are_ a yank, since you have USA citizenship
01:46:23 <Veinor> copumpkin: what languages do you speak, and how fluent are you? :P
01:46:27 <ivanm> (same as how I'm a skippy since I have Australian citizenship)
01:46:28 <Adamant> but also a Brit and a Eyetalian
01:46:41 <ivanm> Adamant: well, he doesn't have Italian citizenship
01:46:47 <tomberek> any other hungarians on here?
01:46:49 <ivanm> and I prefer the term "pom" to "brit" :p
01:47:00 <Adamant> ivanm: but you escaped :P
01:47:37 <ivanm> Adamant: escaped what?
01:47:45 <Adamant> mother englad?
01:47:49 <Adamant> *england even
01:47:50 <ivanm> I have no anglo-saxon heritage
01:48:09 <Adamant> ivanm: gah
01:48:12 <ivanm> :D
01:48:17 <ivanm> (or norman)
01:48:28 <Adamant> I thought you said you were through Britain on the way to Oz
01:48:29 <ivanm> I am purely (as far as I know anyway) of slavic descent
01:48:33 <ivanm> nope
01:48:38 <Adamant> alright then :
01:49:14 <Adamant> the ivan is kind of a tipoff but I thought you hit up the UK first then moved to somewhere warm and sunny
01:49:35 <Adamant> but that was not what you were saying
01:49:58 <ivanm> yup
01:50:31 <copumpkin> ivanm: :(
01:51:22 <ivanm> copumpkin: what?
01:51:31 <Adamant> ivanm: born and raised in Oz, or got there 70's-80's, or post breakup
01:51:31 * copumpkin pouts
01:51:47 <ivanm> I was born and raised in Oz
01:51:54 <Adamant> ah right
01:52:10 <ivanm> my maternal grandparents were refugees after WWII (when the western allies suddenly realised that stalin was _bad_)
01:52:18 <ivanm> my dad came out in the 70s to work
01:52:19 <copumpkin> omg he was bad?
01:52:39 <ivanm> YA
01:52:40 <Adamant> ivanm: have a Ukrainian friend that got out in the late 80's shortly before the collapse and became a citizen here as a kid.
01:52:56 <Adamant> so that's why I asked
01:52:58 <ivanm> yeah, they didn't allow many of them out then
01:53:37 <Adamant> ivanm: what Slavic group specifially if you don't mind me asking
01:53:52 <ivanm> 3/4 Ukrainian, 1/4 Serbian
01:53:55 <Adamant> ah
01:54:45 <Adamant> figured ivan wasn't super common among Poles
01:54:52 <ivanm> heh
01:54:58 <ivanm> it is reasonably common there as well
01:55:05 <Adamant> unless it is and I wasn't paying attention
01:56:15 <Adamant> ivanm: but significantly less common or about the same
01:56:25 <ivanm> I think less common
01:56:50 <ivanm> but Ivan == John
01:56:55 <Adamant> yeah
01:56:58 <ivanm> oh, looks like the Polish use Jan rather than Ivan
01:58:48 <dang`r`us> how can I get local documentation for cabal packages?
01:59:20 <ivanm> dang`r`us: edit your ~/.cabal/config file
01:59:24 <ivanm> and tell it to build documentation
01:59:31 <ivanm> by default, it will go to ~/.cabal/share/doc IIRC
01:59:41 <dang`r`us> ivanm, and then reinstall what I got?
01:59:55 <ivanm> yeah
02:00:40 <dang`r`us> compiling ...
02:01:14 <temoto> @src intercalate
02:01:15 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
02:01:36 <tomoj> suppose I have a function which parses some document from the filesystem and returns a function which takes some arguments and renders a transformed document. I call this function a lot with different arguments. will the parts of the function that don't depend on the value of the arguments be memoized?
02:01:39 <Revelation> how can I return my variables with type information from main=?
02:01:52 <kamatsu> Revelation: what?
02:02:12 <Veinor> tomoj: haskell doesn't do automatic memoization of anything, afaik
02:02:30 <Veinor> unless I'm misunderstanding you
02:02:34 <kamatsu> Identical thunks might not be evaluated twice
02:02:50 <kamatsu> but there is no guarantee
02:02:51 <Revelation> kamatsu: well, I am used to another language and it is possible to return something other than an IO type to main, for example main = [1..5] would return Int:: [1..5] instead of an IO error :)
02:02:52 <tomoj> ok, so how do I tell if the thunks are identical
02:03:11 <tomoj> (I am not sure yet what exactly a "thunk" is
02:03:11 <Revelation> now I am looking for something similar
02:03:15 <kamatsu> Revelation: no, Main is defined to be of an IO type
02:03:18 <Veinor> Revelation: but... why?
02:03:30 <ivanm> Revelation: oh, so when you exit the program?
02:03:33 <ivanm> for error codes?
02:03:38 <kamatsu> tomoj: a thunk is a value that hasn't been evaluated yet
02:03:53 <Revelation> Veinor: it is easy debugging, and I dont want to write a Show function yet
02:04:09 <kamatsu> Revelation: just make it not main, and call it in ghci
02:04:31 <Revelation> kamatsu: ok, I'll try that
02:04:46 <tomoj> ok, so if my function calls a bunch of other functions without passing the values of its arguments, successive calls of the top function might not re-evaluate these calls?
02:04:58 <Veinor> there is no way to return something that isn't an IO () from main
02:05:04 <kamatsu> tomoj: might not, but there is no guarantee
02:05:09 <tomoj> ok
02:05:10 <temoto> Veinor: sure there is.
02:05:15 <Veinor> er, wait
02:05:16 <ivanm> temoto: oh? how?
02:05:18 <tomoj> in practice, any guesses?
02:05:21 <ivanm> there's ExitCodes, that's about it
02:05:27 <temoto> main :: IO String  for example
02:05:29 <tomoj> does it depend on GC?
02:05:33 <ivanm> temoto: you sure?
02:05:35 <temoto> Yes.
02:05:38 <ivanm> pretty sure main has to be IO () ...
02:05:47 <temoto> But the thing has to be IO <something>
02:05:53 <kamatsu> IO Int is fine
02:06:02 <kamatsu> you can definitely do main :: IO Int
02:06:12 <ivanm> hmmm, it does work
02:06:16 <ivanm> thought it had to be IO () ...
02:06:16 <Veinor> really? huh
02:06:18 <dang`r`us> ivanm, thanks for the tip, it worked
02:06:22 <ivanm> no worries
02:06:34 <kamatsu> well, in C, main is defined as "int main (int argc, char* argv[])"
02:06:49 <kamatsu> note the Int return type
02:06:52 <ivanm> kamatsu: right, but the int is for the return code, right?
02:06:58 <ivanm> in haskell, we use ExitCode for that
02:07:00 <ivanm> @hoogle ExitCode
02:07:01 <lambdabot> System.Exit data ExitCode
02:07:22 * Beelsebob really wishes that Main in Haskell didn't have to have type IO ()
02:07:29 <kamatsu> ivanm: you can use IO Int for the same
02:07:35 <ivanm> kamatsu: it works? :o
02:07:41 <Beelsebob> but instead could have any type the runtime knew how to deal with in some way
02:07:43 <ivanm> Beelsebob: we just determined that it doesn't
02:07:45 <temoto> tomoj: in practice, if you need memoization, you do it. In practice you should not rely on compiler optimizations, on your web proxy cache, on file system cache, etc.
02:07:49 <ivanm> but why though?
02:07:56 <tomoj> ok
02:08:09 <kamatsu> ivanm: oh, i just tried it, it doesn't
02:08:18 <kamatsu> ivanm: the return value of the IO action is ignored
02:08:20 <Beelsebob> ivanm: wouldn't it be nice if once for example Reactive got stable enough, main could be a reactive value
02:08:23 <ivanm> kamatsu: yeah
02:08:28 <Beelsebob> or if it could just be a string value, that gets printed
02:08:28 <ivanm> Beelsebob: hmmmm....
02:08:39 <Beelsebob> or even if it could be a function value, where the runtime asks for the arguments in turn
02:08:45 <ivanm> kamatsu: yeah, I tried IO String and it didn't actually return a String ...
02:08:53 <kamatsu> Beelsebob: i'm not convinced it's useful
02:09:05 <kamatsu> ivanm: you can't return a string from a unix process
02:09:08 <kamatsu> ivanm: you can return an int
02:09:09 <ivanm> yeah
02:09:17 <Beelsebob> hell, if it could be any function value, then the runtime could ask for a String as input to our function, lazily read it and run our function, and lazily output...
02:09:21 <Beelsebob> oh look, no need for interact any more
02:09:22 <kamatsu> ivanm: but Haskell doesn't let you return them the "standard" way at all
02:09:27 <dang`r`us> and how can I fetch or generate documentation for base? Install a new base with cabal? (the one I'm using came via haskell platform, I think)
02:09:36 <ivanm> dang`r`us: base comes with ghc
02:09:36 <kamatsu> Beelsebob: it seems to me to be a pointless waste of time
02:09:39 <Beelsebob> kamatsu: Haskell doesn't do a lot of things considered "standard" by C
02:09:42 <kamatsu> Beelsebob: IO glue takes about 5 seconds
02:09:43 <ivanm> so you need to have had ghc install the documentation
02:09:49 <ivanm> (with the same version of haddock IIRC)
02:09:53 <Beelsebob> kamatsu: yes, but shouldn't be necessary anyway
02:10:05 <kamatsu> I dispute that
02:10:05 <dang`r`us> ivanm, I just downloaded a ghc binary package. Does it carry docs?
02:10:11 <ivanm> probably
02:10:16 <Beelsebob> main = lines . process . unlines -- Why should I have to wrap this up?
02:10:35 <dang`r`us> hmmm, the archive has a docs/ directory, but it's not exactly crowded ...
02:10:38 <ivanm> Beelsebob: becaues then you want type inference on stuff coming from the environment?
02:10:58 <Beelsebob> ivanm: huh?
02:11:06 <Beelsebob> do you?
02:11:06 <kamatsu> You are trying to move type information into runtime
02:11:07 <dang`r`us> ah, found it. cool.
02:11:10 <Beelsebob> then main :: String -> String
02:11:20 <Beelsebob> all it needs is the runtime to know how deal with String -> String values
02:11:25 <Beelsebob> like it already knows how to deal with IO values
02:11:40 <Beelsebob> and like ghci already does
02:11:44 <kamatsu> Beelsebob: why extend language semantics when you can trivially add this to a library
02:11:46 <ivanm> Beelsebob: well, if you restrict it to String -> String maybe, but arbitrary values?  how will the runtime know if it's mean to treat the input as String or Int for example?
02:11:47 <Beelsebob> (well, not for String -> String)
02:12:03 <kamatsu> Extending language semantics for no reason is dangerous
02:12:05 <Beelsebob> ivanm: because of the type of the argument to the function
02:12:07 <kamatsu> ask ALGOL people
02:12:15 <Beelsebob> kamatsu: this isn't extending language semantics at all
02:12:20 <dobblego> the runtime should be type-safe haskell!
02:12:20 <Beelsebob> a program has a value
02:12:22 <kamatsu> Beelsebob: Er, yes it is!
02:12:28 <Beelsebob> this has not changed
02:12:31 <ivanm> Beelsebob: and if there's only a class constraint to it?
02:12:37 <ivanm> e.g. main = show . read
02:12:42 <Beelsebob> all that's changed is we've *removed* a rule from the language semantics that that value must be IO ()
02:12:44 <ivanm> or even read . show
02:12:52 <ivanm> hey dobblego
02:12:56 <dobblego> hey mate
02:13:00 <temoto> ivanm: main:: String-> String is not about standart input/output because those are IO. It's about a value of your program.
02:13:01 <Veinor> Beelsebob: just interact $ lines . process . unlines :P
02:13:09 <Beelsebob> ivanm: then it should follow the exact same rules as ghci
02:13:11 <kamatsu> Beelsebob: No, you have extended the language semantics so that Main can be a variety of values
02:13:13 <ivanm> don't know if you got my message yesterday, but I liked your rebuttal to jdh30 on reddit (the Scala post-functional discussion)
02:13:30 <kamatsu> Beelsebob: You need to define exactly how that works
02:13:30 <dobblego> ivanm, I didn't
02:13:54 <Beelsebob> kamatsu: I see that as simplifying the language semantics – you replace "all bindings can have any type,which is inferred, except for main which has to be IO ()" with "all bindings can have any type, which is inferred"
02:14:15 <Beelsebob> you remove a corner case from the language definition
02:14:17 <kamatsu> Beelsebob: Except the programs entry point already has a defined signature
02:14:33 <Beelsebob> kamatsu: does it?
02:14:39 <kamatsu> all your runtime would be doing is growing larger, finding ways to represent behavior for arbitrary values
02:14:51 <Beelsebob> which is already in there
02:14:53 <Beelsebob> (see ghci)
02:14:54 <kamatsu> i.e, ghci's behavior mapped for main is a bigger special case
02:14:58 <kamatsu> ghci is not GHC
02:15:01 <kamatsu> it is not part of the language
02:15:02 <kamatsu> it is a tool
02:15:25 <Beelsebob> what's your point?
02:15:39 <Beelsebob> note – we don't define how compilers must deal with the IO value they get back
02:15:44 <Revelation> ghci can't find my module, even though I start ghci from the same dir..
02:15:47 <Beelsebob> we just have a general understanding of what is a nice thing to do
02:15:55 <kamatsu> We have a well defined way to deal with IO values
02:16:01 <Beelsebob> bull
02:16:04 <Veinor> Revelation: how are you telling it to load it?
02:16:15 <kamatsu> Beelsebob: what? That is true
02:16:18 <Revelation> Veinor: import nono (thats my module name)
02:16:21 <Beelsebob> show me the document kamatsu
02:16:28 <kamatsu> Beelsebob: look at the core output of GHC
02:16:36 <Beelsebob> kamatsu: that's not a definition
02:16:38 <kamatsu> Beelsebob: IO values are mapped into explicit transitions in the system f
02:16:38 <Beelsebob> that's an implementation
02:16:57 <Beelsebob> we have a general understanding that IO values should probably behave roughly like that
02:17:03 <Veinor> Revelation: first, I think the module name has to be Nono
02:17:07 <kamatsu> We don't have a formal specification for any of the language
02:17:14 <Revelation> ok, that could be the problem indeed
02:17:26 <Beelsebob> indeed we don't, but we don't have *any* specification for how IO should work
02:17:27 <Veinor> and then I think :m +Nono should work
02:17:40 <kamatsu> Beelsebob, essentially your idea would require mapping all of your cases to IO values
02:17:42 <Beelsebob> indeed, I *could* build a compiler that actually built an IO data type and printed it's value out if I liked
02:17:47 <kamatsu> Beelsebob: Which is exactly what ghci does
02:17:59 <Veinor> er, :load Nono
02:18:01 <Beelsebob> you're making an assumption that an IO value does actually perform IO actions
02:18:04 <Beelsebob> it doesn't have to
02:18:11 <ivanm> Revelation: is that "Nono" as in "No, no, no, no, no, no, yes" (ala Vicar of Dibley)? :p
02:18:25 <Beelsebob> again, I can if I like implement a compiler that prints out a data structure instead of running an action when it gets an IO value back
02:18:27 <Veinor> also, yeah, that's a very curious name. what's it about? :D
02:18:33 <ivanm> Beelsebob: I would say that your unlines . f . lines example does perform IO ...
02:18:37 <temoto> kamatsu: your point is that writing main ::String would output a program that does nothing because environment is not forced to evaluate the string?
02:18:59 <Revelation> ivanm: hehe no, its a nonogram solver :P
02:19:06 <Beelsebob> ivanm: it would, if and only if the compiler author chose to represent String -> String values that way
02:19:16 <Revelation> the module still wont import :( : Could not find module `Nono':
02:19:24 <Beelsebob> in the same way as the compiler author gets to chose to represent IO () values as a series of actions
02:19:32 <kamatsu> temoto: yes
02:19:47 <kamatsu> Beelsebob: IO actions are required to perform IO in the Haskell Report
02:19:54 <kamatsu> Beelsebob: Pure values are not
02:20:10 <Veinor> Revelation: did you try :load Nono
02:20:12 <kamatsu> Beelsebob: what you're advocating is implicit IO
02:20:20 <kamatsu> Beelsebob: what happens if i write a recursive main, in that case?
02:20:41 <Beelsebob> why would it do anything different to normal?
02:20:49 <Beelsebob> what happens if you write a recursive function?
02:20:50 <kamatsu> Beelsebob: what is normal?
02:21:02 <Revelation> Veinor: now it works :)
02:21:08 <kamatsu> If i get a "main = 4"
02:21:09 <temoto> kamatsu: well that's perfectly fine for  f = "lala" :: String, it just has other name. The string will not be evaluated and that's what programmer wanted. But he could load the module into other program and call that main::String from other program and get a value.
02:21:13 <kamatsu> it could make a thunk, and never evaluate it
02:21:21 <Beelsebob> it could do
02:21:30 <temoto> kamatsu: i get his point as unification of executables and libraries.
02:21:43 <Beelsebob> it could also print 4, that would a useful thing to do
02:21:51 <kamatsu> That's performing IO you might not want
02:21:59 <kamatsu> then I could call main, should it print 4 then too?
02:21:59 <Beelsebob> it is
02:22:21 <Beelsebob> no, it should not, because the printing is part of the runtime
02:22:28 <Beelsebob> not part of the program
02:22:37 <Beelsebob> the runtime receives a computed value from the program
02:22:41 <Beelsebob> and it interprets it in some way
02:23:05 <kamatsu> Right, this interpretation is more ambiguous than explicit IO values
02:23:05 <Beelsebob> main = 4 does not print anything, the runtime on getting 4 back from the program may chose to though
02:23:25 <kamatsu> and also extends the runtime to perhaps make it unsuitable for systems programming
02:23:54 <Beelsebob> the runtime could behave in the exact same way as it does now upon receiving an IO value from the program
02:23:55 <temoto> Beelsebob: so you propose adding some predefined semantics to 'main' types other than IO a?
02:24:00 <kamatsu> the produced output of ghc at the moment gives an entry point that can be started from C.
02:24:08 <tomoj> to be really useful, wouldn't it need to be extensible?
02:24:14 <kamatsu> and it maps exactly to "main"
02:24:15 <Beelsebob> temoto: no, I propose that compiler writers could be free to implement anything they like
02:24:17 <tomoj> and in that case, why not do it like we can already do it, outside the runtime?
02:24:35 <Beelsebob> tomoj: fair point
02:24:42 <kamatsu> moving this into the runtime increases the runtime size for minimal benefit
02:24:47 <kamatsu> it adds complexity for compiler writers
02:24:53 <kamatsu> not reducing it
02:24:53 <temoto> Beelsebob: so same program 'main = 5' would produce different side effects being compiled with GHC and JHC?
02:25:03 <zcombinator> Guys, I need a bit of help pls. I have a function which does 'something' to a list, and need to apply this something function to the list n times. Having some understanding of Scheme, I could write applyNTimes :: Int -> ([a] -> [a]) -> [a] -> [a] ... and got this working OK. But, I suspect this is not idiomatic Haskell and I should be using the State Monad. Am I barking up the right tree or am I just barking mad?
02:25:11 <Beelsebob> temoto: much like programs that return IO () values
02:25:38 <Beelsebob> zcombinator: that absolutely *is* idiomatic haskell
02:25:39 <temoto> Beelsebob: they currently produce the same side effects, IMO.
02:25:45 <EnglishGent> morning folks :)
02:25:48 <Beelsebob> zcombinator: putting everything in monads absolutely *is not* idiomatic haskell
02:25:58 <Beelsebob> temoto: but don't have to
02:26:11 <tomoj> hmm
02:26:16 <kamatsu> No one has to
02:26:27 <kamatsu> The report is very vague on this and most other topics
02:26:33 * Beelsebob nods
02:26:35 <zcombinator> 666bob happy to hear that as haven't quite got to monads yet.
02:26:43 <tomoj> > (iterate (:0) []) !! 3
02:26:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
02:26:52 <tomoj> er,
02:26:58 <tomoj> > (iterate (0:) []) !! 3
02:26:59 <lambdabot>   [0,0,0]
02:27:03 <Beelsebob> zcombinator: good – go visit Functors and Applicatives before you visit Monads
02:27:19 <kamatsu> tomoj: couldn't you do take 3 $ repeat 3 ?
02:27:19 <Beelsebob> Monads get *way* too much credence as the solution to all problems sometimes
02:27:22 <kamatsu> > take 3 $ repeat 0
02:27:24 <lambdabot>   [0,0,0]
02:27:26 <Beelsebob> and it's good to check out the other things that build up to them
02:27:37 <zcombinator> thanks for the tip
02:27:44 <kamatsu> Generally I use monads after i end up implementing them manually first
02:27:55 <tomoj> kamatsu: I was trying to figure out how to do zcombinator's thing
02:27:57 <kamatsu> like, "oh, this is a monad, may as well use the monads"
02:28:07 * Beelsebob nods
02:28:20 * Beelsebob tends to use Applicatives *way* more than monads
02:28:27 <kamatsu> applicative functors are nice
02:28:31 <kamatsu> jQuery is one
02:28:34 * Beelsebob nods
02:28:38 * ivanm has never used applicatives...
02:28:53 <tomoj> I've been reading the typeclassopedia, pretty good
02:29:01 <Beelsebob> Applicatives come out looking much more like Haskell (unsurprising given that the central function is "apply")
02:29:02 <kamatsu> hm, sometimes i import Control.Applicative just for the nice <$> operator for fmap
02:29:12 <ivanm> then again, I don't use a lot of monadic code; just for IO, State and polyparse with the occasional list/maybe to make it a bit cleaner
02:29:19 <kamatsu> is GHC smart enough to just link that one bit, or is it linking all of applicative?
02:29:20 <temoto> Beelsebob: let me clarify, you propose that some compiler BHC should be able to eat 'main = 5' and produce *some* behaviour based on the fast that there is no formal specification on how all haskell compilers must interpret 'main::IO()' ?
02:29:26 * Beelsebob uses Monadic code for IO and very occasionally State
02:29:35 <Beelsebob> parsing, lists and maybes I usually use the Applicative interface
02:29:43 <kamatsu> Recently I did some work with a stack of monad transformers on top of IO
02:29:51 <ivanm> polyparse doesn't support applicative AFAIK
02:29:55 <kamatsu> although it was an entirely and IO library
02:29:59 <ivanm> how does a list applicative look?
02:30:08 <Beelsebob> temoto: right, much like ghci produces "some" behavior when it sees the value 5 come out of an expression
02:30:26 <Beelsebob> ivanm: <*> applies all the functions in the first list to all the arguments in the second list
02:30:36 <temoto> Beelsebob: then you're adding more unspecified chaos.
02:30:40 <Beelsebob> > [(+1), (*2)] <*> [3,4,5,6]
02:30:41 <lambdabot>   [4,5,6,7,6,8,10,12]
02:31:08 <kamatsu> yeah, i agree with temoto
02:31:15 <Beelsebob> I think I agree too
02:31:16 <temoto> Beelsebob: main::IO() at least has a common sense way to interpret: execute the IO.
02:31:19 <Beelsebob> was a nice thought experiment though
02:31:34 <kamatsu> brb
02:31:35 * Beelsebob ponders creating an "Executable" package
02:31:56 <temoto> While someone would think that main::Int must return exit code, while others might think that main::Int must print that value to stdout.
02:31:58 <Beelsebob> which defines class Executable a where main' :: a -> IO ()
02:32:05 <Beelsebob> and some useful instances
02:32:10 <ivanm> hmmmm...
02:32:21 <ivanm> so how does applicative deal with the short-cutting nature of maybe?
02:32:45 <tomoj> Beelsebob: e.g. could you define an instance for functions [String] -> [String] ?
02:32:48 <ziman> > Just (+1) <*> Just 3
02:32:49 <lambdabot>   Just 4
02:32:52 <ziman> > Just (+1) <*> Nothing
02:32:53 <lambdabot>   Nothing
02:32:55 <Beelsebob> ivanm: it applies anything it (maybe) gets in the left argument to anything it (maybe) gets in the argument and (maybe) produces a result
02:33:10 <temoto> Beelsebob: i totally agree that if we had a specified behaviour or some ways to specify it, other types for main would be useful.
02:33:22 <Beelsebob> tomoj: right – probably main' f = interact (lines . f . unlines)
02:33:37 <temoto> @src interact
02:33:37 <tomoj> the way to specify it would be to write the instances in the Executable library, no?
02:33:38 <lambdabot> interact f = do s <- getContents; putStr (f s)
02:33:55 <temoto> :t interact
02:33:56 <Beelsebob> tomoj: right
02:33:56 <lambdabot> (String -> String) -> IO ()
02:34:08 <tomoj> sounds good to me for noobs
02:34:17 <ziman> sʇuǝʇuoɔʇǝƃ <<= ɟ . ɹʇsʇnd >- ɟ\ ld
02:34:19 <ivanm> hmmmm
02:34:19 <ziman> oops
02:34:19 <tomoj> I struggled with what to put in main
02:34:22 <ivanm> @slap ziman
02:34:22 <Beelsebob> temoto: it lazily consumes all input, transforms it with the function, and dumps out anything that the function produces as it comes out
02:34:22 * lambdabot submits ziman's email address to a dozen spam lists
02:34:33 <tomoj> because I didn't really understand IO
02:34:36 <ziman> @pl \f -> putStr . f =<< getContents
02:34:36 <lambdabot> (getContents >>=) . (putStr .)
02:34:41 * ivanm leaves to go catch a plane
02:35:11 <tomoj> so Executable would make it easier for noobs to experiment with pure functions while still being able to compile a binary
02:35:17 * ziman has recently bound `@' as the text flipper -- which was a dumb choice, obviously :)
02:35:17 <tomoj> for common IO patterns
02:35:37 <temoto> We can think of writing main :: IO() = do { B } as an unformal way to specify the behaviour B of our intended main'.
02:35:56 <temoto> While instance of Executable would be a bit more formal.
02:35:57 <Beelsebob> the issue with defining it in a library ofc is that you probably want an instance (Read a, Show b) => Executable (a -> b); but also instance (Read a, Show b) => Executable ([a] -> [b])
02:36:06 <Beelsebob> that disagree
02:37:00 <tomoj> can't you deal with that?
02:37:08 <Beelsebob> I don't think so
02:37:18 <Beelsebob> not in H98 certainly
02:37:27 <temoto> Beelsebob: that seems to unify into Functor F => F a -> F b
02:39:27 <temoto> or, at least into Monad m => m a -> m b
02:41:08 <Ke> fyi, supybot, blasphemy
02:46:47 <temoto> Beelsebob: what about this? main is required to return a parametrized type Exec a. Then all existing programs map to Exec (IO ()), while main = Exec 5 could be executed by special console runtime as print 5, by other GUI runtime as "draw a window with large 5 in it", etc.
02:47:36 <Beelsebob> temoto: interesting
02:48:02 <temoto> Beelsebob: did you see Tangible Functional Programming video on youtube?
02:48:23 * Beelsebob nods
02:48:31 <Beelsebob> conal did his talk directly to me
02:48:42 <Beelsebob> it's fun stuff
02:48:50 <temoto> You were in the room?
02:49:02 <Beelsebob> not that exact room
02:49:20 <Beelsebob> I've been in *a* room in which conal has been talking about tangible functional programming to a small audience
02:49:21 <temoto> Anyway, i think this main :: Exec a would allow his idea.
02:49:32 * Beelsebob nods
02:49:44 <temoto> wait no, we still have no input
02:49:58 <Beelsebob> isn't that just Exec (a -> b)?
02:50:33 <kamatsu> couldn't you have: Class Exec a where toIO :: a -> IO b
02:50:44 <Beelsebob> kamatsu: see upwards
02:50:54 <Beelsebob> too many overlapping instances
02:50:57 <temoto> i was thinking about Input a -> Exec b
02:51:03 <Beelsebob> (it's fine outside H98 though)
02:51:20 <kamatsu> Beelsebob: Well, the whole idea is outside H98
02:51:24 * Beelsebob nods
02:51:26 <Beelsebob> fair point
02:51:28 <temoto> Read a is not quite there because it wants string, is it?
02:51:37 <Beelsebob> indeed
02:51:51 <temoto> What is a generalization of input?
02:54:29 <temoto> :t fmap
02:54:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:56:17 <tomoj> is there a shorter way to do \x y -> (x,y) ?
02:56:19 <temoto> Beelsebob: your Exec (a -> b) ought to have a point but i can't understand it.. this means that main would return a function.
02:56:29 <temoto> tomoj: (,)
02:56:34 <tomoj> oh, of course
02:56:43 <tomoj> thanks :)
02:57:03 <Beelsebob> temoto: right – which notably, has input
02:57:14 <Beelsebob> (as oposed to a constant value which only has output)
02:57:56 <temoto> Beelsebob: what was between "right" and "notably"? My IRC client or terminal is not showing unicode :(
02:58:06 <Beelsebob> temoto: an en-dash
02:59:05 <temoto> Okay, this makes sense, i probably starting to remember that Conal said exactly that: every program is a function.
02:59:32 <temoto> All we need is typing then.
03:00:10 <temoto> Exec (a -> b) is every other possible types a and b.
03:00:29 <temoto> which is not useful
03:03:59 <temoto> Reader seems to be close.
03:09:03 <temoto> How about this: main :: a -> Exec b. Type inferring would replace 'a' with () if program doesn't consume any input or some other type.
03:09:24 <temoto> well same inferring could fix Exec (a -> b)
03:10:46 <temoto> If we rely on inferring replacement, then Exec is practically useless annotation.
03:11:50 <temoto> Beelsebob: main :: a -> b    that's kind what your original suggestion was.
03:12:12 <temoto> "allow other types"
03:16:10 <temoto> This introduces another problem. Types must be global to all programs.
03:16:37 <tomoj> for a program with many entry points you might make use of it?
03:16:47 <tomoj> I mean, with a custom instance?
03:17:02 <tomoj> I mean, a suite of programs really
03:17:49 <temoto> tomoj: suite of programs might make use of sharing types?
03:18:20 <tomoj> oh, I meant might make custom instances of Exec
03:19:08 <tomoj> and yes, sharing types
03:19:08 <temoto> In haskell everything about types (including instances of classes) is program-local anyway.
03:19:24 <temoto> .NET fixes it with common runtime
03:19:34 <tomoj> can't you compile multiple executables which use the same types?
03:19:50 <tomoj> I guess I don't understand what you mean
03:20:35 <temoto> tomoj: it's possible, but limited. My programs would not be compatible with your programs.
03:21:03 <tomoj> I mean, say I write a suite of executables which all use one of a few IO patterns, parsing and outputting types specific to this suite
03:21:11 <tomoj> I could make a few custom instances of Exec and use them all over, no?
03:21:37 <temoto> Sure, but suite1 can't use types of suite2.
03:21:58 <temoto> while all programs in suite1 are compatible with each other
03:22:08 <tomoj> why can't suite2 import the custom instances from suite1?
03:22:24 <temoto> Because they are compiled into native code :)
03:22:58 <tomoj> do you mean "compatible" as in, I can pipe my program into yours?
03:23:06 <temoto> Yup.
03:23:09 <tomoj> oh
03:23:19 <tomoj> well if I output and accept XML ...
03:23:23 <tomoj> or JSON
03:23:30 <tomoj> or whatever it is my programs are often reading and writing
03:24:00 <tomoj> then if you happen to be doing the same in haskell you can import my instances
03:24:08 <temoto> JSON has some types, but limited to numbers, unicode strings, lists and maps.
03:24:24 <temoto> it doesn't even have datetime type
03:24:36 <tomoj> right, what I mean is I could provide Exec (JSON a -> JSON b)
03:25:12 <temoto> Any importing of types from other program would (probably) require a compilator.
03:25:13 <tomoj> and so you write a program with JSON input which outputs JSON just by writing a function of that type
03:25:29 <tomoj> I'm talking about just using my instance from a library
03:25:39 <tomoj> I write a JSON library which provides that instance
03:25:47 <temoto> tomoj: yeah that's basically UNIX pipes extended to JSON instead of plain strings.
03:25:58 <tomoj> now anytime I need to write a program with JSON input and JSON output, I can just use my instance
03:26:05 <temoto> tomoj: we still can't share datetime.
03:26:25 <tomoj> right
03:26:39 <tomoj> not a replacement for some kind of messaging protocol
03:26:47 <tomoj> just a tool for writing haskell programs which process json
03:27:04 <tomoj> I see what you mean about compatibility now though
03:27:34 <temoto> Well there is haskell library for processing JSON. BTW it's slow as hell because it uses String, not ByteString.
03:27:49 <tomoj> that sucks
03:28:07 <tomoj> I was thinking of using protocol-buffers
03:29:06 <temoto> Any serialization is actually evil.
03:29:21 <temoto> (for local machine communication)
03:29:35 <temoto> because you get all speed penalties
03:29:43 <temoto> and still don't share custom types
03:30:29 <temoto> I believe i'd read about Inferno OS which does what we're discussing without serialization.
03:30:53 <tomoj> I'm not doing local machine communication :)
03:31:23 <temoto> ah you was thinking about protobuffers for some your project?
03:31:34 <tomoj> yeah
03:31:53 <tomoj> was originally going to try doing json in haskell
03:31:55 <temoto> For Python, cjson was 20 times faster at decoding.
03:32:02 <tomoj> oh, good idea
03:32:15 <temoto> than protobuffers
03:32:16 <tomoj> I can compare protocol-buffers to the python/java implementations
03:32:21 <tomoj> oh, crap
03:32:36 <temoto> And JSON is human readable.
03:32:39 <tomoj> I thought you meant than haskell's json library
03:32:50 <temoto> That's why we chose JSON for some projects.
03:33:17 <temoto> I believe haskell protobuffers implementation is fast enough, though.
03:34:49 <temoto> I guess they have tcp-dump-parse-protobuf in google.
03:35:02 <tomoj> oh, hprotoc
03:35:19 <kamatsu> there is a haskell protobufs implementation?
03:35:24 <tomoj> http://hackage.haskell.org/package/hprotoc
03:35:37 <temoto> Which would make it almost as readble.
03:35:43 <kamatsu> I work for google, and I use protobufs, and i didn't know this
03:35:49 <tomoj> or maybe http://hackage.haskell.org/cgi-bin/hackage-scripts/package/protocol-buffers
03:35:56 <temoto> Wow.
03:36:38 <temoto> kamatsu: are you in wave team?
03:36:41 <kamatsu> yep
03:36:52 <temoto> cool
03:36:58 <kamatsu> actually, once wave is open sourced
03:37:05 <kamatsu> I am considering writing and operational transforms library for haskell
03:37:14 <kamatsu> which could pave the way for a haskell wave server
03:37:18 <kamatsu> *an
03:37:55 <tomoj> clients don't need to do OT right
03:38:03 <temoto> Operational transforms is something about applying patches to document on server and client so they show the same?
03:38:51 <kamatsu> yes
03:38:58 <kamatsu> Clients do need to do OT right, tomoj
03:39:19 <kamatsu> if the client and the server get the same ops, they must produce the same result
03:39:25 <kamatsu> otherwise composability breaks down
03:39:27 <temoto> kamatsu: is it more complex than diff/patch, like in git?
03:39:33 <tomoj> kamatsu: sorry, that was a question
03:39:49 <tomoj> I thought wave did it special so clients didn't have to do as much
03:39:51 <Heffalump> temoto: it's more like the commutation in darcs
03:40:01 <kamatsu> tomoj: not really, clients and server do the same amount
03:40:10 <kamatsu> but they do add some special goods to make it not horribly slow
03:40:25 <temoto> Heffalump: I'm not familiar with commutation in darcs. :( Could you explain in a few words?
03:40:42 <Heffalump> it's about adjusting positions of patches so you can apply them in a different order
03:40:53 <tomoj> oh, the server doesn't have to do as much
03:41:03 <tomoj> because of the inferred server path
03:41:08 <kamatsu> oh, right
03:41:09 <kamatsu> yes
03:43:49 <kamatsu> the key performance optimizations we use are composability and then from that composition trees
03:44:21 <kamatsu> allowing us to apply from any one point to any other point in log n time
03:44:31 * Heffalump needs to do that for darcs
03:45:19 <kamatsu> Heffalump: you work on darcs?
03:45:23 <Heffalump> yeah
03:45:33 <kamatsu> yeah, composition trees would be really nice
03:45:45 <kamatsu> but they aren't entirely space efficient
03:45:58 <kamatsu> so you should cap their size, you don't need to make a composition tree for the entire thing
03:46:21 <Heffalump> how exactly do they work? I guessed a bit from the name and the fact that I've had ideas about doing something that sounds like that.
03:46:35 <kamatsu> hm, well, basically, you have say, 10 operations
03:46:43 <Heffalump> what I was imagining wouldn't more than double the space requirements
03:46:53 <Heffalump> hmm, or maybe a log n factor actually
03:47:13 <kamatsu> well, say you have 10 ops
03:47:17 <kamatsu> you compose them into 5 ops
03:47:24 <kamatsu> and then 5 ops into 2 or 3 ops
03:47:27 <kamatsu> and then 2 ops into 1 ope
03:47:39 <kamatsu> but you keep all those results, forming a tree structure
03:47:53 <kamatsu> then to get 2 ops forward, you can use the 2-composed ops
03:48:04 <kamatsu> and to get 3 ops forward, you use 2, then 1
03:48:06 <Heffalump> ok, right. That's what I was thinking of, but I was possibly planning some reordering
03:48:14 <Twey> I'm having a hell of a time installing Happstack.
03:48:25 <Heffalump> whereas I think in operational transforms you don't do stuff like cherry picking so reordering is less useful, right?
03:48:32 <kamatsu> right
03:48:36 <kamatsu> we keep the order as is
03:49:11 <Twey> What does it mean if ‘binary-0.5.0.2-f2e0c64369675ad8250958367f72014b is unusable due to missing or recursive dependencies: containers-0.3.0.0-5ca6db1a6d3a4a1ffb04bfdb4004dc80’ where containers-0.3.0.0 is already installed?
03:49:33 <Heffalump> Twey: I suspect it means that the new API hashing in GHC 6.12.1 is biting you
03:49:33 <kamatsu> Twey: GHC version?
03:49:44 <Twey> 6.12.1
03:49:47 <kamatsu> yeah
03:49:49 <Twey> Yeah :þ
03:49:53 <kamatsu> i recommend 6.10 for the time being
03:49:55 <Heffalump> I don't fully understand it, but I suspect it means you installed containers twice, and built different packages against the different versions
03:49:57 <kamatsu> any reason you're using 6.12?
03:50:00 <Twey> Hmm
03:50:06 <Twey> Unicode IO, mostly
03:50:23 <Heffalump> so what you should do is manually reinstall everything that depends on containers
03:50:55 <Twey> ‘Manually’ as in no cabal-install, or ‘manually’ as in no cabal?
03:51:09 <Heffalump> manually as in one by one with cabal-install
03:51:16 <Twey> Oh, I see
03:51:19 <Heffalump> rather than just expecting the dependency tracking to do it for you
03:51:25 <Twey> That's not so bad
03:51:39 <Heffalump> one answer is to iterate with happstack, and reinstall anything it complains about
03:51:48 <Twey> *nod*
03:52:03 <Twey> Oh
03:52:07 <Twey> No, that didn't fix it.
03:52:17 <Heffalump> of course, I could be completely wrong about the cause, but something fairly similar happened to me a day or two ago
03:52:26 <Twey> I did cabal install --reinstall binary
03:52:27 <Heffalump> though I don't think I got quite the same message
03:52:30 <Twey> And it installed fine
03:52:51 <Twey> But when I went to install happstack-data, which is the package that produces the error, the same happens
03:53:01 <Heffalump> not sure then
03:53:21 <Heffalump> but it might be that something else has already selected a different containers
03:53:32 <Heffalump> so you might need to figure out all the inbetween deps manually to figure out what to reinstall
03:53:38 <Twey> Hmm
03:53:50 <kamatsu> has anyone gotten happstack-data to build on ghc 6.12?
03:53:51 <Twey> kamatsu: By ‘for the time being’, what sort of timescale are we talking here?
03:54:00 <kamatsu> Twey: until the haskell platform supports 6.12
03:54:00 <Heffalump> I'll have a go now
03:54:42 <Twey> I have a project due in a few months, so if it's going to be too long I might just downgrade, but if it'll only be a couple of weeks I'd rather wait it out
03:55:07 <EnglishGent> hi Twey, Heffalump :)
03:55:30 <Twey> (I'd much rather have 6.12's IO available for it)
03:55:37 <Twey> Salutations, EnglishGent
03:55:39 <kamatsu> Twey: I don't know how long the haskell platform will take, sorry
03:55:56 <Twey> Okay ☺
03:56:02 <Heffalump> I think in theory the platform is due soon, but I don't know whether in practice it depends on the relevant people having time
03:56:14 <Heffalump> Twey: how far did the install get? Did it fail when planning, or did it start building stuff?
03:56:21 <Heffalump> hi EnglishGent
03:58:24 <Heffalump> Twey: happstack-data just installed fine for me on GHC 6.12.1
03:58:53 <Heffalump> might be simplest just to restart with a fresh package database (not sure of a good way to get a basic one other than reinstalling GHC, or figuring out manually what to unregister)
03:59:20 <Twey> Heffalump: It built some stuff
03:59:25 <Twey> Hm
03:59:39 <Twey> Maybe if I just remove ~/.cabal and start afresh it will help
03:59:44 <Heffalump> I doubt it
03:59:54 <Heffalump> oh, are you installing user packages?
04:00:00 <Heffalump> if so, it might
04:00:09 <Heffalump> I can't remember where the user package DB is stored
04:00:15 <Twey> Yeah
04:00:18 <Twey> ~/.cabal/packages
04:00:26 <Heffalump> yeah, in that case just wiping out that database might help
04:00:43 <Heffalump> ~/.cabal/packages is the download cache
04:00:46 <Heffalump> not the GHC DB
04:00:52 <Twey> Ah, yeah
04:01:04 <Twey> There's ~/.ghc
04:01:19 <Heffalump> that looks more like it
04:01:19 * Twey nukes that, too
04:02:49 <Heffalump> happstack itself also installs fine, FWIW
04:03:08 <Twey> Yeah, I goh happstack itself to install
04:03:11 <Twey> got**
04:03:17 <Twey> But not -server, -state, &c.
04:03:34 <Heffalump> ah, I assumed happstack depended on them all
04:03:42 <Twey> Strangely not
04:15:15 <temoto> kamatsu: btw we've come to conclusion that main type ought to be ::a->b. Compiler infers types of a and b, so all existing programs map to main:: () -> IO (), while new can be of other types. Now semantic is limited to one evaluation which is not bad, because we can evaluate it once more. But the problem is about sharing types of different programs efficiently.
04:16:13 <Beelsebob> temoto: just means we need a functional operating system that knows about the same base types, and method of building ADTs as the programs
04:16:19 <temoto> Serialization would loose efficiency and it can only express a predefined subset of types. One way is to run all programs in a common runtime, what .NET does.
04:16:20 <Beelsebob> then we can easily pass data to and from the OS
04:16:43 <temoto> Beelsebob: yeah, functional OS would be awesome.
04:16:58 <Ke> s/awesome/slow/
04:17:06 <temoto> and that too
04:17:16 <Ke> well ok awesome too
04:17:40 <Ke> but it would need to have all the erlang features then too
04:17:44 <temoto> But hey, imagine then 'cat file' would be pure!
04:18:26 <temoto> Ke: what particular features?
04:18:33 <temoto> Haskell has most of them.
04:18:56 <Ke> I think it allows tracing data of production systems
04:19:03 <Ke> sort of a dtrace
04:19:20 <Ke> and automatic restart of crashed services obv
04:19:24 <temoto> hm, never knew that, interesting feature.
04:19:49 <temoto> Well automatic restart is a trivial wrapper.
04:20:13 <temoto> and that's OTP feature, not erlangs
04:20:14 <Ke> well minix has automatic restart
04:20:29 <Ke>  OTP?
04:20:48 <temoto> Yeah, kinda extension to std library.
04:21:00 <temoto> Haskell Platform is somewhat similar.
04:21:51 <DekuNut> I grabbed lambdabot on my machine, it's been useful so far, especially ?index and ?src but, I'm curious, is there a way I can ?Src a specific instance?
04:21:59 <DekuNut> Like, ?src Applicative ((->) r )
04:22:36 <kamatsu> not sure
04:25:13 <olsner> @src (->) (>>=)
04:25:13 <lambdabot> f >>= k = \ r -> k (f r) r
04:33:02 <DekuNut> Ah thank you
04:41:49 <Baughn> > runKleisli (Kleisli (+1) >>> Kleisli (*2)) 42
04:41:50 <lambdabot>   No instance for (GHC.Num.Num (m b))
04:41:50 <lambdabot>    arising from the literal `2' at <int...
04:42:49 <Axman6> :t Kleisli
04:42:50 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
04:43:06 <Baughn> Hm. Oh, whoops.
04:43:50 <dobblego> > runKleisli (Kleisli [+1] >>> Kleisli [*2]) 42
04:43:51 <lambdabot>   A section must be enclosed in parentheses thus: (+ 1)A section must be encl...
04:45:28 <dobblego> > runKleisli (Kleisli (return . (+1)) >>> Kleisli (return . (*2))) 42 :: [Int]
04:45:29 <lambdabot>   [86]
04:46:57 * Baughn wonders what kleisli arrows are good for
04:47:57 <Axman6> > runKleisli (Kleisli [(+1)] >>> Kleisli [(*2)]) 42
04:47:58 <lambdabot>   Couldn't match expected type `a -> m b'
04:47:58 <lambdabot>         against inferred type `[a1]'
04:48:21 <Axman6> > runKleisli (Kleisli (return . (+1)) >>> Kleisli (return.(*2))) 42
04:48:22 <lambdabot>   No instance for (GHC.Show.Show (m a))
04:48:22 <lambdabot>    arising from a use of `M7663281192...
04:48:24 <Baughn> :t Kleisli (+)
04:48:25 <lambdabot> forall a. (Num a) => Kleisli ((->) a) a a
04:48:41 <Axman6> > runKleisli (Kleisli (return . (+1)) >>> Kleisli (return.(*2))) 42 :: Kleisli [] Integer Integer
04:48:42 <lambdabot>   No instance for (GHC.Base.Monad
04:48:42 <lambdabot>                     (Control.Arrow.Kleisli ...
04:49:08 <Axman6> > runKleisli ((Kleisli (return . (+1)) >>> Kleisli (return.(*2))) :: Kleisli [] Integer Integer) 42
04:49:09 <lambdabot>   [86]
04:49:17 <Axman6> hoorah
04:49:27 <Baughn> :t runKleisli (Kleisli (+) >>> Kleisli (*))
04:49:28 <lambdabot> forall a. (Num a) => a -> a -> a
04:49:37 <Baughn> > runKleisli (Kleisli (+) >>> Kleisli (*)) 42 100
04:49:38 <lambdabot>   14200
04:49:43 <Baughn> Huh.
04:49:43 <Axman6> >_<
04:50:30 <Baughn> Combining the environment monad with arrows. Sounds like fun. :P
04:53:18 <Saizan> anyone has some chunk of Arrowish code written in that Category + reader Applicative style we were discussing yesterday?
05:03:37 <dum8d0g> hi.. I have simple question about cabal.. Suppose I have installed some packages using cabal as ordinary user.. now, if I want to revert back, to the time I have never used cabal before, I guess rm -r ~/.cabal/ would be enough.. right?
05:04:06 <Baughn> dum8d0g: rm -r ~/.{ghc,cabal} will do it
05:04:33 <Baughn> dum8d0g: And actually, deleting ~/.cabal is mostly optional; without references to it in ~/.ghc, it won't affect anything but your disk-space usage.
05:04:43 <dum8d0g> Baughn: ah.. thanks.. so there aren't any DBs or anything like that.. just removing will be safe, allright?
05:04:50 <Baughn> dum8d0g: ~/.ghc has the DB
05:05:12 <Baughn> dum8d0g: ~/.cabal has the actual libraries, interface files and hackage cache
05:05:15 <dum8d0g> ok, that is exactly what I needed to know
05:05:37 <dum8d0g> Baughn: And is there way to "recreate" the ghc DB?
05:05:58 <Baughn> dum8d0g: Not really. Not without saving the same information that's in it in the first place.
05:06:38 <dum8d0g> but everything will work after I will delete .ghc and .cabal dirs.. right? like fresh install
05:06:54 <Baughn> Yes
05:07:04 <dum8d0g> :) thank you
05:11:27 <benmachine> why not move them instead of deleting them
05:11:30 <benmachine> just to see
05:11:40 <Wooga> in http://learnyouahaskell.com/syntax-in-functions said, that i can use pattern match in list comprehensions, like ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]  ghci> [a+b | (a,b) <- xs] , but how do i use more then one pattern match here?
05:12:04 <Twey> Wooga: Separate them with commas
05:12:32 <temoto> What is more than one match?
05:12:54 <Twey> > let xs [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)] in [a + c | (a, b) <- xs, c <- [1 .. b]]
05:12:55 <lambdabot>   <no location info>: parse error on input `in'
05:13:00 <Twey> Oops
05:13:06 <Twey> > let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)] in [a + c | (a, b) <- xs, c <- [1 .. b]]
05:13:07 <lambdabot>   [2,3,4,5,6,7,3,4,5,6,6,7,8,6,7,8,9,10,11,4]
05:13:42 <temoto> You can construct arbitrary complex expression using names from single match.
05:13:51 <temoto> as in ((a,b),(b,a)
05:13:53 <temoto> )
05:14:35 <temoto> And add more sources for names.
05:14:56 <Wooga> i still do not understand how do i match something against two different patterns
05:15:02 <Alpounet> is holding an IORef to a position a good way to store the position of an object we're drawing or are there better practices ?
05:15:07 <temoto> Actually, in expression  "c <- [1..b]"  the 'c' is a pattern.
05:15:14 <kamatsu> Wooga: just use a function that has two patterns
05:15:14 <Wooga> [ a+b, a+b+c | (a,b) <- [(1,2,3)], (a,b,c) <- [(1,2,3)] ] seems like not right expression
05:15:37 <Berengal> Wooga: You can't have alternative patterns in list comprehensions
05:15:49 <Wooga> ah, thats the point
05:15:51 <Wooga> thanks!
05:16:32 <benmachine> > [a + b | (a,b) <- [(1,2,3)], (a,b,c) <- [(1,2,3)]]
05:16:33 <lambdabot>   Couldn't match expected type `(t, t1, t2)'
05:16:34 <lambdabot>         against inferred type `(...
05:16:40 <benmachine> mm
05:16:51 <MissPiggy> (a,b) <- [(1,2,3)] type error
05:17:08 <temoto> yeah
05:17:17 <MissPiggy> :t [(1,2,3)] >>= \(a,b) -> undefined
05:17:18 <lambdabot>     Couldn't match expected type `(t, t1, t2)'
05:17:18 <lambdabot>            against inferred type `(a, b)'
05:17:18 <lambdabot>     In the pattern: (a, b)
05:17:24 <Berengal> > [ x | Just x <- [Just 1, Nothing, Just 3] | Nothing <- [Just 1, Nothing, Just 3]]
05:17:25 <lambdabot>   [1]
05:17:53 <temoto> > [Nothing | (a,b,c) <- (1,2,3), (a,b,c) <- (4,5,6)]
05:17:54 <lambdabot>   Couldn't match expected type `[t]'
05:17:54 <lambdabot>         against inferred type `(t1, t2, ...
05:17:57 <Berengal> Huh, how did that work?
05:18:05 <MissPiggy> @undo [ x | Just x <- [Just 1, Nothing, Just 3] | Nothing <- [Just 1, Nothing, Just 3]]
05:18:05 <lambdabot>  Parse error at "|" (column 43)
05:18:06 <benmachine> Berengal: was wondering that myself :P
05:18:21 <idnar> how did what work?
05:18:27 <benmachine> I guess it turned into a zipWith on the lists [Just 1, Just 3] and [Nothing]
05:18:30 <temoto> lol
05:18:59 <Berengal> > [ x | (Just x, Nothing) <- join zeip [Just 1, Nothing, Just 3]]
05:19:00 <lambdabot>   Not in scope: `zeip'
05:19:04 <Berengal> > [ x | (Just x, Nothing) <- join zip [Just 1, Nothing, Just 3]]
05:19:04 <lambdabot>   []
05:19:11 <temoto> :t [ x | Just x <- [Just 1, Nothing, Just 3] | Nothing <- [Just 1, Nothing, Just 3]]
05:19:12 <lambdabot> forall t. (Num t) => [t]
05:19:30 * idnar is really confused
05:19:58 <Twey> kamatsu, Heffalump: After removing .cabal and .ghc, happstack installed fine.  Thanks.  ☺
05:20:01 <temoto> :t [ x | Just x <- [Just 1, Nothing, Just 3]]
05:20:02 <lambdabot> forall t. (Num t) => [t]
05:20:08 <temoto> > [ x | Just x <- [Just 1, Nothing, Just 3]]
05:20:09 <lambdabot>   [1,3]
05:20:16 <kamatsu> Twey: great
05:21:07 <temoto> Wouldn't zipWith return (Just 1, Nothing) ?
05:21:32 <benmachine> depends what With you gave it
05:21:40 <temoto> @src zipWith
05:21:40 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:21:40 <lambdabot> zipWith _ _      _      = []
05:21:57 <idnar> it's zipWith (\x y -> x) [Just 1, Just 3] [Nothing]
05:22:05 <idnar> effectively
05:22:06 <benmachine> except it isn't
05:22:13 <benmachine> because you get [1] not [Just 1]
05:22:18 <idnar> oh, sorry
05:22:25 <idnar> but you know what I mean
05:22:28 <benmachine> heh
05:22:37 <benmachine> yeah, it sounds likely
05:22:40 <idnar> you can't really write it as zipWith, because the pattern matching doesn't work that way
05:22:45 <temoto> @src const
05:22:45 <lambdabot> const x _ = x
05:22:54 <Berengal> > zipWith (\(Just x) _ -> x) [Just 1, Nothing, Just 3]
05:22:55 <lambdabot>   * Exception: <interactive>:1:150-165: Non-exhaustive patterns in lambda
05:22:58 <idnar> well, I suppose you can
05:23:12 <Berengal> > join (zipWith (\(Just x) _ -> x)) [Just 1, Nothing, Just 3]
05:23:14 <lambdabot>   [1,* Exception: <interactive>:1:156-171: Non-exhaustive patterns in lambda
05:23:34 * benmachine tries to work out why the first one wasn't a type error
05:23:38 <Berengal> I'm really curious now...
05:23:38 <temoto> zipWith (\x y -> x) [Just 1, Nothing, Just 3] [Nothing]
05:23:39 <benmachine> oh because of the silly show instance
05:23:42 <temoto> > zipWith (\x y -> x) [Just 1, Nothing, Just 3] [Nothing]
05:23:43 <lambdabot>   [Just 1]
05:23:45 <benmachine> silly silly show instance
05:24:00 <temoto> > zipWith (\(Just x) y -> x) [Just 1, Nothing, Just 3] [Nothing]
05:24:02 <lambdabot>   [1]
05:24:12 <temoto> you omit last [Nothing]
05:24:29 <idnar> the problem is that pattern match failure in zipWith is an exception
05:24:40 <idnar> > zipWith (\x y -> x) [x | Just x <- [Just 1, Nothing, Just 3]] [Nothing <- [Just 1, Nothing, Just3]]
05:24:41 <lambdabot>   <no location info>: parse error on input `<-'
05:25:00 <idnar> > zipWith (\x y -> x) [x | Just x <- [Just 1, Nothing, Just 3]] [() | Nothing <- [Just 1, Nothing, Just 3]]
05:25:01 <lambdabot>   [1]
05:25:13 <temoto> no no let me try
05:25:13 <Alpounet> is holding an IORef to a position a good way to store the position of an object we're drawing or are there better practices ?
05:25:26 <benmachine> idnar: yes, the list comprehension thing relies on the definition of fail for lists
05:25:32 <benmachine> which we all try to pretend doesn't really exist
05:25:51 <idnar> benmachine: I just pretend it uses mzero
05:25:53 <benmachine> Alpounet: it depends; that strategy forces you to be in IO but if you need IO already it's not bad
05:26:01 <temoto> > [ x <- zipWith (\(Just x) y -> x) [Just 1, Nothing, Just 3] [Just 1, Nothing, Just 3]]
05:26:02 <lambdabot>   <no location info>: parse error on input `<-'
05:26:16 <benmachine> Alpounet: if you don't need IO for anything else it's a bad idea to use it just for that, I think
05:26:21 <temoto> > [ x | x <- zipWith (\(Just x) y -> x) [Just 1, Nothing, Just 3] [Just 1, Nothing, Just 3]]
05:26:22 <lambdabot>   [1,* Exception: <interactive>:1:169-184: Non-exhaustive patterns in lambda
05:26:28 <temoto> whoa
05:26:31 <Alpounet> benmachine, what are the alternatives then to update a value ?
05:26:40 <benmachine> Alpounet: the State monad is a good one
05:26:50 <Alpounet> ok
05:27:01 <Alpounet> I used it for a previous project, for a similar situation
05:27:19 <Alpounet> well I'll see depending on the IO-ness of the code around that.
05:27:29 <Twey> Or just passing the value around
05:27:29 <idnar> oh! I know
05:27:29 <idnar> > [ x | (Just x, _) <- zip [Just 1, Nothing, Just 3] [Just 1, Nothing, Just 3]]
05:27:30 <lambdabot>   [1,3]
05:27:42 <benmachine> passing the value around works too yes
05:27:43 <Twey> That can often be less cumbersome than State
05:27:49 <MissPiggy> > [ x | (Just x, Nothing) <- zip [Just 1, Nothing, Just 3] [Just 1, Nothing, Just 3]]
05:27:50 <lambdabot>   []
05:27:51 <Twey> (for small values)
05:28:14 <Alpounet> Twey, as I said it'd be positions, so nothing very big
05:28:18 * Berengal has no idea why that list comp works the way it does
05:28:19 <Alpounet> yeah it may be fine too
05:28:21 <Alpounet> thanks
05:28:21 <idnar> @ping
05:28:21 <lambdabot> pong
05:28:23 <idnar> wow, I'm lagged
05:28:24 <Twey> Might as well just pass it, ten
05:28:26 <benmachine> Berengal: which one
05:28:26 <Twey> then**
05:28:38 <temoto> So it's a comprehension with multiple lists -> zipWith (multiple lists)   conversion, not comprehension -> comprehension with zipWith on multiple lists one.
05:28:38 <Berengal> benmachine: The weird one that returns [1]
05:28:39 <idnar> > [ x | (Just x, Nothing) <- zip [Just 1, Nothing, Just 3] [Just 1, Nothing, Just 3]]
05:28:40 <lambdabot>   []
05:28:46 <idnar> hmm, no, that doesn't work
05:28:52 <benmachine> Berengal: parallel ones, then?
05:29:08 <temoto> So for many | in comphrenesion every | is replaced with zipWith.
05:29:09 <Berengal> benmachine: Yep. It shouldn't return [1]
05:29:13 <benmachine> Berengal: it does seem a bit odd
05:29:19 * Berengal checks the core
05:29:40 <benmachine> temoto: we know that multiple |s result in the use of some kind of zipping
05:29:43 <idnar> why shouldn't it return [1]?
05:29:44 <benmachine> but we're not exactly clear how
05:29:59 <idnar> the semantics seem clear to me, they're just hard to express in different code
05:30:00 <Berengal> idnar: Because the pattern should fail for the first item as well
05:30:06 <benmachine> idnar: I think we're expecting it to behave like MissPiggy's example
05:30:21 <idnar> Berengal: the Nothing pattern fails for all but one element of the list
05:30:36 <idnar> Berengal: the Just x pattern succeeds for two list elements, but gets truncated due to the Nothing pattern
05:30:42 <benmachine> idnar: it fails for all but the second element of the list, and the Just pattern fails for the second element
05:30:59 <Berengal> idnar: The Just and Nothing patterns are mutually exclusive, so all elements should fail
05:31:14 <idnar> Berengal: the Just and Nothing matches are independent
05:31:23 <benmachine> only if the patterns are matched together, as in the zip example
05:31:33 <idnar> thye're not evaluated in lockstep
05:31:35 <benmachine> (which imo would be the sensible way to do things)
05:31:38 <Berengal> idnar: They are
05:31:41 <idnar> it's just their results that are used in parallel
05:32:10 <idnar> > [(x, y) | Just x <- [Just 5, Nothing, Nothing] | Just y [Nothing, Nothing, Just 10]]
05:32:11 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a]
05:32:11 <lambdabot>                         ...
05:32:15 <Berengal> idnar: They should be. That's the point of parallel comprehension
05:32:16 <idnar> > [(x, y) | Just x <- [Just 5, Nothing, Nothing] | Just y <- [Nothing, Nothing, Just 10]]
05:32:17 <lambdabot>   [(5,10)]
05:32:59 <Berengal> Wait, so...
05:33:13 <benmachine> so basically it translates to zipWithN (result of first branch) (result of second branch) [...]
05:33:27 <Berengal> If one generator fails, it advances without failing everything?
05:33:34 <idnar> right
05:33:50 <idnar> advancing "one place" means advancing until the next pattern match succeeds
05:34:16 <benmachine> shall we just stick to not using parallel list comprehensions? :P
05:34:21 <benmachine> or indeed, any other ones
05:34:26 <Berengal> I think that would be best...
05:34:51 * benmachine thinks that do-syntax is usually clearer than list comprehensions
05:35:16 <Berengal> It's easier to think on do-syntax, I feel
05:40:47 <kamatsu> oh dear, i just discovered irssi plugins, allowing these sorts of shenanigans
05:40:52 <kamatsu>  _               _         _  _  _
05:40:52 <kamatsu> | |_   __ _  ___| |__ ___ | || || |
05:40:52 <kamatsu> | ' \ / _` |(_-<| / // -_)| || ||_|
05:40:52 <kamatsu> |_||_|\__,_|/__/|_\_\\___||_||_|(_)
05:41:25 <Baughn> I'm happy for you. Now stop.
05:41:29 <kamatsu> yup
05:41:44 <Baughn> You'll want to look up the screen_away and splitlong scripts.
05:42:10 <kamatsu> hm, cool
05:42:22 <idnar> uhm, hmm
05:42:22 <Twey> You didn't need a plugin for that.
05:42:31 <Twey> /exec - -o figlet haskell!
05:42:55 <idnar> > do Just x <- ZipList [Just 5, Nothing, Just 10]; Nothing <- ZipList [Just 5, Nothing, Just 10]; return x
05:42:55 <kamatsu> true
05:42:56 <lambdabot>   No instance for (GHC.Base.Monad Control.Applicative.ZipList)
05:42:56 <lambdabot>    arising fro...
05:43:15 <idnar> oh, I guess ZipList isn't a monad
05:44:02 <benmachine> I wrote myself an irssi script that printed the old topic whenever anyone changed it
05:44:19 <benmachine> idnar: apparently it can be as long as all the lists involved are the same length, or so I heard
05:44:51 <benmachine> or, something
05:44:57 <benmachine> I forget how it works exactly
05:45:48 <olsner> seems it should be easy to write a monad instance for ziplists, but it might not obey the laws and stuff (?)
05:46:08 <cheater2> where do i find info about the haskell function "Just"?
05:46:10 <olsner> (since otherwise, I assume there would already be an instance of monad for it)
05:47:02 <cheater2> i just want to find out what it does etc
05:47:26 <idnar> cheater2: it's a constructor for the Maybe type
05:47:28 <idnar> @src Maybe
05:47:28 <lambdabot> data Maybe a = Nothing | Just a
05:47:44 <cheater2> idnar: where do i find this information?
05:48:00 <idnar> cheater2: you can tell by the initial capital letter that it's a constructor
05:48:30 <cheater2> idnar: is there no central documentation for haskell keywords/functions/constructors/etc?
05:48:40 <idnar> cheater2: and the easiest way to find the docs for Maybe is probably to search for "Just" on hoogle
05:48:41 <benmachine> cheater2: there are lots of ways to get documentation
05:48:44 <idnar> cheater2: http://www.haskell.org/hoogle/?hoogle=Just
05:49:01 <benmachine> cheater2: if you have a ghci session where the thing you want to know about is in scope, then :info tells you useful things
05:49:10 <cheater2> i tried googling to find info about the Just keyword but couldn't find it
05:49:20 <cheater2> benmachine: let me tried that
05:49:23 <benmachine> ghci> :i Just
05:49:23 <benmachine> data Maybe a = ... | Just a 	-- Defined in Data.Maybe
05:49:30 <benmachine> cheater2: hoogle is not google :P
05:49:39 <cheater2> i know
05:49:58 <benmachine> hoogle has links to the haddock documentation
05:50:02 <benmachine> as well
05:50:14 <idnar> cheater2: hoogle is case-sensitive, which helps a lot
05:50:21 <cheater2> great
05:50:36 <idnar> you can also search by type and things like that
05:51:25 <cheater2> thanks :)
05:56:14 <MissPiggy> say if I define and additive and a multiplicative monoid on the same set, how do you make a group out of it?
05:56:22 <MissPiggy> err I meant ring not group
05:58:00 <Saizan> you mean using typeclasses in haskell? or in general?
05:58:10 <MissPiggy> using typeclasses
05:58:35 <MissPiggy> what I did first was just define  Add  and  Mul  typeclasses,  but maybe that's not the greatest way
05:59:08 <Saizan> you might want to index the Monoid class by a type for the operation
05:59:26 <Loriel> A group does not involve both addition and multiplcation, does it?
05:59:29 <Loriel> Just one of them?
05:59:33 <Saizan> though that means you end up with phantom parameters or similar
06:00:01 <Saizan> Loriel: group is a monoid with inverses, iirc
06:00:03 <MissPiggy> Loriel, yeah I should have said ring (but them I'm still off a bit)
06:05:50 <benmachine> ring is group and a monoid that distributes, right?
06:07:33 <Saizan> yeah, but the group is commutative
06:07:35 <benmachine> oh, ring addition has to be abelian
06:07:47 <temoto> abelian?
06:08:03 <benmachine> commutative spelt with an a
06:08:10 <benmachine> err, you know what I mean
06:08:14 <MissPiggy> heh
06:08:26 <temoto> :) yes
06:08:33 <temoto> What is a group?
06:08:40 <temoto> in this dirty math sense
06:08:49 <MissPiggy> Is there a good algebra hierarchy in haskell?
06:08:54 <MissPiggy> that someone else wrote
06:09:01 <benmachine> a group is a set with a binary operation to combine elements of the set
06:09:15 <benmachine> such that if a and b are in the set, a*b is in the set
06:09:16 <MissPiggy> temoto, groups are al about pdp^-1
06:09:18 <kamatsu> benmachine: isn't that a monoid?
06:09:27 <temoto> MissPiggy: php^-1?
06:09:28 <benmachine> and, (a*b)*c = a*(b*c)
06:09:31 <benmachine> kamatsu: getting there
06:09:36 <benmachine> what I've described so far is a monoid
06:09:52 <benmachine> no
06:09:55 <benmachine> it isn't
06:10:03 <benmachine> you need an identity e with a*e = e*a = a
06:10:07 <benmachine> then you have a monoid
06:10:10 <kamatsu> ah, right
06:10:12 <benmachine> then to get a group you add inverses
06:10:13 <kamatsu> mzero
06:10:28 <benmachine> i.e. for all a in the group there is a b such that a*b = e
06:10:33 <benmachine> (where e is the identity)
06:10:39 <kamatsu> yup
06:10:39 <benmachine> a*b = b*a = e
06:10:57 <benmachine> usually b is called a^-1
06:10:59 <kamatsu> do you need commutativity?
06:11:09 <Saizan> MissPiggy: maybe numeric-prelude on hackage, it uses a peculiar convention for naming though
06:11:14 <benmachine> no
06:11:31 <benmachine> a group whose operation is commutative is called an abelian group
06:11:41 <temoto> What is ^- ?
06:11:51 <benmachine> temoto: raised to the power of minus
06:12:05 <benmachine> a superscript -1
06:12:11 <temoto> thanks
06:12:33 <temoto> MissPiggy said that groups are all about pdp^-1, what does that mean?
06:12:40 <kamatsu> benmachine: do you need identity for commutativity, if not, is there a name for a commutative monoid?
06:12:53 <kamatsu> oh wait
06:12:58 <kamatsu> do you need inverses for commutativity
06:13:00 <kamatsu> blah
06:13:02 <benmachine> kamatsu: I don't know if there's a name for a commutative monoid
06:13:07 <kamatsu> right
06:13:10 <benmachine> you don't need inverses for commutativity
06:13:17 <benmachine> e.g. max
06:13:27 <benmachine> max is a binary commutative operation without inverses
06:13:35 <MissPiggy> temoto, I was just kidding, it's the nub of many group theory proofs
06:14:12 <temoto> nub is a smallest set for some permutation?
06:14:26 <MissPiggy> no
06:14:28 <benmachine> I think we're using nub in the conventional sense
06:14:34 <benmachine> like, the core or the key
06:14:53 <temoto> ah
06:15:29 <tomoj> hmm.. I have a bunch of 19 element lists from a tab separated file
06:15:32 <temoto> group is like a 'value' in programming?
06:15:37 <tomoj> how can I work these values into the type system?
06:15:52 <tomoj> I made a record type with 19 fields
06:15:55 <benmachine> temoto: erm, I don't know what you mean
06:16:18 <benmachine> tomoj: seems a reasonable way to do it
06:16:28 <tomoj> I was thinking I could fold over a list of values accumulating the curried constructor functions, but I can't figure out how that could work
06:16:29 <rndm> temoto: no. it's an algebraic structure in abstract algebra
06:16:40 <MissPiggy> http://hackage.haskell.org/package/algebra what is the point in this??
06:16:41 <tomoj> since the type of the fold function would need to be different each time
06:16:49 <temoto> As data constructors in haskell?
06:17:10 <Saizan> MissPiggy: we wonder too :)
06:17:20 <MissPiggy> http://hackage.haskell.org/packages/archive/agum/2.2/doc/html/Algebra-AbelianGroup-UnificationMatching.html that's more interesting
06:18:14 <temoto> tomoj: do you need to calculate a sum on a single column in that tsv file?
06:18:44 <tomoj> no, I'm processing a lot of it
06:18:53 <tomoj> only trying to filter by one column for now, though
06:19:06 <Saizan> yeah, a simple fold on the list won't work
06:19:16 <temoto> How fold relates here?
06:19:18 <tomoj> maybe Applicative can help?
06:20:10 <tomoj> I have a type Foo with 19 record fields
06:20:20 <tomoj> and I have lists with 19 elements in them
06:20:52 <tomoj> I thought of folding over the list with initial value Foo (the constructor) and accumulating the functions
06:20:53 <Saizan> are these fields all of the same type?
06:20:53 <temoto> Well write a godzilla pattern then.
06:20:59 <tomoj> the final result would be a Foo
06:21:04 <tomoj> Saizan: they are right now, yeah
06:21:08 <tomoj> but they won't be in the future probably
06:21:14 <tomoj> right now I just left them all Strings
06:21:47 <Saizan> i was going to suggest an Array, but if they are going to be of different types later that won't work
06:21:59 <temoto> makeFoo [a,b,c,d] = Foo a b c d
06:22:00 <MissPiggy> I can't get anything done because of trying so hard to do it right (whatever that means)
06:22:17 <temoto> or even
06:22:19 <benmachine> MissPiggy: I have that problem sometimes
06:22:39 <temoto> foldl ($) Foo list
06:22:48 <temoto> but that won't work, unfortunately
06:23:10 <temoto> no partial data constructors in haskell :(
06:23:19 <Saizan> eh?
06:23:20 <benmachine> there are
06:23:26 <kamatsu> yes there are?
06:23:30 <benmachine> but the problem is that each partial data constructor would have a different type
06:23:32 <Loriel> Yes partial data constructors in haskell, but the type still changes and you cannot fold over it.
06:23:38 <temoto> so (Just) is fine?
06:23:43 <benmachine> :t Just
06:23:43 <Loriel> I was told you needed template haskell to do something approaching what you are doing
06:23:43 <Saizan> yes
06:23:44 <lambdabot> forall a. a -> Maybe a
06:23:49 <temoto> fck
06:23:53 <Loriel> > map Just [1..10]
06:23:54 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
06:24:16 <temoto> no wait
06:24:20 <temoto> of course Just is fine
06:24:28 <temoto> because it is a full function
06:24:43 <temoto> we need a type with two arguments
06:24:51 <Loriel> That will work too.
06:24:51 <benmachine> :t (x:)
06:24:52 <lambdabot> [Expr] -> [Expr]
06:24:57 <Loriel> Yeah, that.
06:25:00 <temoto> data constructor with two arguments
06:25:07 <Loriel> : is a data constructor with two arguments.
06:25:09 <benmachine> :t \x -> (x :+)
06:25:10 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
06:25:15 <kamatsu> > map (:) [1,2,3,4]
06:25:16 <lambdabot>   [[]->
06:25:16 <lambdabot>    [1]
06:25:16 <lambdabot>  [-2]->
06:25:16 <lambdabot>    [1,-2]
06:25:16 <lambdabot>  [-2,-1]->
06:25:18 <lambdabot> [3 @more lines]
06:25:20 <benmachine> :t (1 :+)
06:25:22 <lambdabot> forall t. (RealFloat t) => t -> Complex t
06:25:32 <benmachine> etc.
06:25:57 <temoto> @src foldl
06:25:57 <lambdabot> foldl f z []     = z
06:25:57 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:25:58 <benmachine> tomoj: if you know how long the list is going to be I don't see anything wrong with just pattern-matching the whole thing
06:26:06 <Saizan> in expressions there's no difference between constructors and other function, at all
06:26:11 <tomoj> benmachine: yeah
06:26:15 <tomoj> just ugly :/
06:26:23 <temoto> > foldl (1:) 2 [3..4]
06:26:24 <lambdabot>   Couldn't match expected type `b -> [t]' against inferred type `[t]'
06:26:29 <benmachine> tomoj: if you've got 19 elements you have to do stuff 19 times
06:26:41 <tomoj> yep
06:26:52 <Saizan> i think we can solve this by typeclasses and gadts..
06:26:56 <benmachine> perhaps you should look at where the list is being built and see if you can use the constructor directly?
06:27:21 <benmachine> but if it's the direct result of splitting on tabs then pattern matching is a good way of error checking, too
06:27:24 <tomoj> the list is built by split
06:27:36 <tomoj> yeah, that makes sense
06:27:38 <temoto> > foldl (1:) [2] [[3],[4],[]]
06:27:39 <lambdabot>   Couldn't match expected type `b -> [t]' against inferred type `[t]'
06:27:59 <temoto> Is there other data constructor with two arguments?
06:28:05 <benmachine> :+
06:28:14 <temoto> :t :+
06:28:15 <lambdabot> parse error on input `:+'
06:28:18 <benmachine> :t (:+)
06:28:19 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
06:28:19 <Twey> Ratio
06:28:19 <temoto> :t (:+)
06:28:21 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
06:28:26 <Twey> :t Ratio
06:28:27 <lambdabot> Not in scope: data constructor `Ratio'
06:28:31 <temoto> @src Ratio
06:28:31 <lambdabot> data (Integral a) => Ratio a = !a :% !a
06:28:34 <kamatsu> > foldr (:) [] [1,2,3,4]
06:28:35 <lambdabot>   [1,2,3,4]
06:28:38 <temoto> one
06:28:48 <benmachine> Ratio is a type constructor :P
06:29:01 <benmachine> :% is the value constructor but I think that's not exported?
06:29:06 <benmachine> because you're supposed to use % instead
06:29:12 <temoto> > foldr (1:) [] [3,4]
06:29:13 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[t]'
06:29:21 <temoto> > foldr (:1) [] [3,4]
06:29:22 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[a]'
06:29:29 <benmachine> temoto: foldr takes a binary function, you're giving it a unary function
06:29:40 <temoto> oh
06:29:41 <benmachine> or in the second case, trying to prepend an element to a number
06:29:43 <temoto> :t foldl
06:29:45 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:29:45 <benmachine> which doesn't make sense
06:29:47 <temoto> :t foldr
06:29:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:29:57 <kamatsu> > foldr (:) [4] [1,2,3]
06:29:57 <lambdabot>   [1,2,3,4]
06:30:01 <temoto> so foldl is wrong with unariness too
06:30:11 <benmachine> foldl is right, you're wrong :P
06:30:14 <kamatsu> map is the one that takes a unary function
06:30:17 <benmachine> yes
06:30:47 <temoto> > foldr (\x y -> (x:)) [] [1,2,3]
06:30:48 <lambdabot>   Couldn't match expected type `[a] -> [a]'
06:30:49 <lambdabot>         against inferred type `[a...
06:31:04 <kamatsu> what the hell are you trying to do?
06:31:16 <tomoj> can you build an HList from a [String], I wonder?
06:31:17 <temoto> i don't know :)
06:31:19 <benmachine> :t (\x y -> (x:))
06:31:21 <lambdabot> forall t a. a -> t -> [a] -> [a]
06:31:26 <tomoj> and parse each field a different way :)?
06:31:43 <Loriel> No, because read needs to know what type you want from it
06:31:44 <temoto> tomoj: the last line is called pattern matching :)
06:32:06 <tomoj> sure, and HList knows what type it needs, no?
06:32:09 <temoto> > map (:[1]) [1,2,3]
06:32:10 <lambdabot>   [[1,1],[2,1],[3,1]]
06:32:15 <temoto> oh my
06:32:18 <Loriel> I doubt it
06:32:24 <temoto> partial data constructors
06:32:40 <temoto> because data constructor is an implicit function
06:32:48 <temoto> TADA
06:35:54 <Cale> > head (1 : undefined)
06:35:55 <lambdabot>   1
06:36:37 <Cale> > map (1:) [[2,3,4],[5,6,7]]
06:36:38 <lambdabot>   [[1,2,3,4],[1,5,6,7]]
06:37:30 <temoto> And function is an implicit pattern matching?
06:39:16 <benmachine> not sure there is such a thing as implicit pattern matching
06:39:33 <Gracenotes> and what is pattern matching?
06:39:56 <Gracenotes> constructors are what case statements dispatch on, yes
06:40:26 <Gracenotes> and if statements, function pattern matching, and case statements themselves compile down to case statements
06:40:38 <Gracenotes> in some form
06:42:26 <kamatsu> if compiles down to case?
06:42:40 <kamatsu> oh right, just specialized for bool
06:46:27 <temoto> function pattern matching compiles to case statements?
06:46:39 <temoto> How is that?
06:46:43 * Baughn is getting increasingly convinced that FRP will require arrows, if not actually monads
06:47:13 <Baughn> temoto: Hm? Oh, like this:
06:47:15 <Baughn> f 2 = 3
06:47:22 <Baughn> f n = n - 1
06:47:22 <Baughn> --
06:47:31 <Baughn> f n = case n of 2 -> 3; n -> n - 1
06:47:46 <temoto> ah that
06:47:55 <Botje> /dev/sda5              19G   16G  2.7G  86% /
06:47:55 <Botje> /dev/sda5              19G   16G  2.7G  86% /
06:47:56 <temoto> i thought about evaluation
06:47:58 <Botje> uh
06:48:01 <Botje> what
06:48:03 <Botje> oops
06:48:10 <benmachine> heh
06:48:13 <benmachine> I've done worse
06:48:17 <Gracenotes> 20GB iPod?
06:48:28 <Baughn> temoto: In Core, case is the fundamental operator of inspecting values, while let is the fundamental operator to allocate heap space..
06:48:37 <Botje> Gracenotes: my eee
06:48:39 <Baughn> temoto: So anything that inspects them ends up being a case
06:48:46 <Baughn> temoto: Except when it's a primitive.
06:48:48 <Gracenotes> .nod.
06:49:02 <Baughn> Botje: How fast is the SSD in that?
06:49:10 <Botje> it's an HD model
06:49:17 <Baughn> ..20GB?
06:49:17 <paolino> tomoj: instance selection is done at compile time, I guess you want it runtime
06:49:21 <Gracenotes> even for primitives it's a case, in some form.. the primitive form
06:49:25 <burp> 20GB hd? lol
06:49:34 <Botje> that's just one partition :P
06:49:43 <Baughn> Gracenotes: Well, I don't know if I'd call the primitive #Int+ function a case. :P
06:49:46 <tomoj> paolino: the fields are in order, why would it need to be at runtime?
06:49:53 <Botje> another 30GB for windoze, and 100G for /home
06:49:54 <Gracenotes> oh, iPod would be sdb/c/..
06:50:18 <Gracenotes> Baughn: you do need to case on its result
06:50:23 <Baughn> Gracenotes: Not necessarily. You may have forgotten, but there was such a thing as /dev/hda. :P
06:50:37 <Baughn> Gracenotes: I guess
06:50:45 <Gracenotes> oh, them tricksy devs
07:01:43 <paolino> tomoj : class Fielded a h where set :: h -> a -> h, then you want load :: h -> [String] -> h, but the compiler cannot choose the set instance, in fact I cannot write the constraint for load = foldl (\h -> set h . read)
07:07:30 <tomoj> paolino: sorry, I don't know why I want any of that
07:07:32 <tomoj> :)
07:16:39 <temoto> I couldn't run QuickCheck because of some unknown error, but HUnit works fine.
07:17:29 <manjunaths> hello
07:17:30 <temoto> Though, ubuntu packet libghc6-hunit-dev installs a package in such a way that you can only import Test.HUnit (which makes sense), though HUnit docs says import HUnit.
07:17:37 <temoto> manjunaths: yo
07:17:43 <manjunaths> is there an example of how to use Data.Binary
07:17:54 <temoto> @hoogle Data.Binary
07:17:54 <lambdabot> No results found
07:18:01 <temoto> Nope.:)
07:18:12 <manjunaths> I mean I have a binary file and I trying to read 2 bytes, I have no idea how to use this library
07:18:23 <kamatsu> @hoolge HUnit
07:18:24 <lambdabot> package HUnit
07:18:24 <lambdabot> module Test.HUnit
07:18:30 <kamatsu> package?
07:18:35 <kamatsu> oh right, package
07:18:47 <manjunaths> http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html
07:18:48 <kamatsu> temoto: it's meant to be Test.HUnit
07:25:02 <manjunaths> how do I find all the modules that are there in ghc ?
07:25:17 <Baughn> majoh: That ship with it?
07:25:24 <Baughn> *majunaths
07:25:27 <paolino> tomoj: you can concat nicely a [String] into a String and then just read it
07:25:37 <manjunaths> Baughn, yes
07:25:40 <Baughn> manjunaths: The documentation should be installed as file:///usr/local/share/doc/ghc/html/libraries/index.html or so
07:25:43 <Cale> manjunaths: Well, first of all you should know about http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
07:25:55 <Cale> Well, that's documentation for 6.12
07:26:02 <Cale> If you have 6.10.4...
07:26:07 <manjunaths> Cale, I have that
07:26:29 <Baughn> Does this make sense as (part of) an Arrow type: 'data Agent a b where Print :: Show a => Agent a ()' ?
07:26:41 <Cale> http://www.haskell.org/ghc/docs/6.10.4/html/libraries/index.html
07:26:45 * Baughn is not quite sure about GADTs yet
07:27:17 <Cale> Baughn: Seems like it makes sense
07:27:35 <Cale> manjunaths: After that, you'll need the documentation for the specific packages you're using
07:27:43 <Baughn> Cale: I agree. ^^;
07:27:45 <Cale> manjunaths: It's conveniently linked from Hackage
07:27:53 <Baughn> Ah well, hopefully that's sufficient.
07:28:34 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html -- select the package that you want documentation for, and you'll (usually) find a bunch of links to its documentation.
07:28:50 <manjunaths> wow...I did cabal install binary and it worked
07:29:09 <manjunaths> I have a small peeve about haskell, there are no little programs :-)
07:29:16 <manjunaths> that newbies can learn from
07:29:26 <Cale> Oh?
07:30:07 <manjunaths> anybody has code lying around where they read a binary file ?
07:30:13 <Cale> I would think it would be the opposite. There are not many very large scale programs.
07:30:31 <IceDane> I am no elite haskeller, but from what I've seen, cale is right.
07:30:56 <manjunaths> Cale, no I mean easy programs, not big ones, I think in haskell every program looks small because of the expressiveness of haskell
07:30:57 <Cale> manjunaths: Using Data.Binary?
07:31:03 <manjunaths> Cale, yes
07:31:05 <IceDane> Then there's the fact that more time goes into thinking about how to write the code than writing it, and the code you end up is often relatively small in size, but has a lot of functionality.. At least in my experience.
07:32:12 <paolino> > read $ foldr (\x y -> "(" ++ x ++ "," ++ y ++ ")") "()" ["1","Nothing"] :: (Int,(Maybe (),()))
07:32:13 <lambdabot>   (1,(Nothing,()))
07:32:46 <Cale> manjunaths: Actually, is there a good reason not to use the cereal library?
07:33:12 <manjunaths> Cale, yes, I had never heard of the cereal library until the last line
07:33:16 <Cale> cereal is very similar to Binary, but has better error handling
07:33:18 <manjunaths> last but one
07:33:25 <Cale> http://hackage.haskell.org/packages/archive/cereal/0.2/doc/html/Data-Serialize-Get.html
07:33:41 <manjunaths> :-)
07:33:53 <Baughn> Cereal is also /faster/. I know this from benchmarks. ;)
07:34:12 <Baughn> Well, except in situations where you really want laziness, but I don't think Data.Binary is the answer there. Some kind of chunking would be.
07:34:20 <Cale> The interface is fairly self-explanatory. You construct a parser of type Get t, where t is the type of value you're trying to parse, and then use runGet to run it on a ByteString
07:34:31 * Baughn is definitely falling in love with GADTs now. They got so simple, all of a sudden..
07:35:52 <Baughn> Cale: Also, you're wrong. . should definitely be Category..
07:36:04 <Cale> Baughn: New evidence?
07:36:05 <manjunaths> Baughn, do you have bencmark source, and if can you share it, can I see it ?
07:36:12 <Baughn> Cale: No, just unshakeable faith.
07:36:38 <Baughn> manjunaths: Sorry, just some tiny tests I threw together on my own stuff. I didn't keep it, because it wasn't really what I wanted to benchmark.
07:36:51 <Baughn> manjunaths: Though I think the author of Cereal made some similar comments.
07:36:54 <manjunaths> Baughn, oh..thanks anyway
07:37:13 <Cale> Baughn: The main reason I don't like that is that Control.Category isn't really a good model of categories, and I haven't seen that many good examples of the sort of thing that Control.Category is.
07:37:16 <Baughn> Cale: Opinion, basically. You could make arguments for both, but the way I think of . matches categories better than functors
07:37:35 <manjunaths> Baughn, no I wanted to learn how to use the library by looking at the code
07:37:42 <Cale> Control.Category only pretends to model categories... it's really something much stranger than that.
07:38:12 <Baughn> manjunaths: Binary instances are typically auto-generated anyway
07:38:13 <Cale> The main cause of this being that (.) is forced to be polymorphic in a strange way
07:38:35 <manjunaths> Baughn, ok
07:38:51 <Baughn> manjunaths: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16470#a16470 <-- This is what it would tend to look like
07:39:02 <Baughn> manjunaths: More interesting is using the Get/Put monads yourself
07:39:18 <Cale> If we had a real, good representation of categories that was actually anywhere close to as broad as categories actually are, I'd probably agree.
07:39:21 <orbitz> anyon seen the rich hickey video on time?
07:39:35 <Cale> orbitz: I was too late.
07:39:44 <orbitz> it' son InfoQ if you want to see it
07:39:58 <orbitz> but basicilly, what he is describing sounds exactly like how Haskell handles time
07:40:01 <orbitz> am I wrong here/
07:40:07 <manjunaths> Baughn, I see only ads on the page and nothing else
07:40:19 <manjunaths> Baughn, is there code or something
07:40:27 <Baughn> There's supposed to be.. try reloading?
07:40:30 <Cale> orbitz: Actually, I was joking, and don't know what you're talking about, perhaps I'll google it.
07:40:33 <Baughn> Also, ads? There are ads?
07:40:54 <manjunaths> Baughn, it says this page is parked by godaddy.com
07:40:55 <orbitz> Cale: har
07:41:02 <orbitz> Cale: http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey
07:41:05 <Baughn> manjunaths: http://hpaste.org <-- This?
07:41:09 <manjunaths> Baughn, I did reload, also
07:41:10 <Baughn> manjunaths: Could you get a screenshot?
07:41:17 <manjunaths> Baughn, hang on
07:42:20 <Loriel> http://ilfirin.org/hpaste.png
07:43:07 <Baughn> Whois is /down/? o_O
07:43:15 <orbitz> Cale: his basic idea seems to be OOP gets it wrong because objects have no concept of time yet they change over time, so things should be immutable (values), state is a value and identity is that objects state over time, where time is reprsented by function calls which take one state and produce a new oen
07:43:38 <Baughn> manjunaths: http://64.131.71.66 <- For the time being, use this. First paste.
07:43:47 <Baughn> Er, http://64.131.71.66/fastcgi/hpaste.fcgi/view?id=16470
07:43:52 <manjunaths> Baughn, http://tinypic.com/r/hs8avm/6
07:45:21 <manjunaths> Baughn, thanks
07:45:55 <manjunaths> I think I need to learn monads to read a binary file
07:45:59 <manjunaths> hmm...
07:46:34 <manjunaths> thanks anyway
07:51:45 <Cale> manjunaths: Well, you don't really have to learn about monads, but you do need to understand the Get monad here.
07:52:22 <manjunaths> Cale, I figured as much, because I couldn't figure out some of the symbols and usage
07:54:11 <Cale> manjunaths: So first of all is that if x and y are parsers, then x >> y is the parser which parses x and then y, producing y's result.
07:55:51 <Cale> manjunaths: and 'return v' is a parser which parses nothing, producing the result v
07:56:34 <Cale> But what if we want the following parser to depend on the first thing that was parsed?
07:56:56 <RayNbow> @hoogle Monoid m => (a -> b -> (b,m)) -> (m -> b) -> [a] -> b
07:56:56 <lambdabot> No results found
07:57:21 <Cale> manjunaths: Following this?
08:00:05 <Zao> Is the cplusplus FFI convention alive nowadays, or is it an ancient wart?
08:10:21 <Baughn> Zao: Never heard of it being used, FWIW
08:10:48 <Saizan> *Uncurry> fromList Foo [1..10]
08:10:48 <Saizan> Foo 1 2 3 4
08:13:02 <Zao> Baughn: Pondering whether to access Direct3D via the C++ or C API, but I have a feeling that the C one will be friendlier.
08:13:29 <kamatsu> in haskell, certainly C
08:14:15 <kamatsu> any particular reason why Direct3d?
08:14:20 <kamatsu> as opposed to, say, OpenGL?
08:14:28 <kamatsu> (which we already have bindings for)
08:15:02 <Baughn> Zao: Windows is a second-class platform. You may be able to get your program working on it, but you'll definitely want to develop on a better supported one.
08:15:34 <kamatsu> i think simon marlow uses windows for all his haskell stuff?
08:15:43 <kamatsu> afaict it's not really all that "second class"
08:16:00 <Saizan> tomoj, Loriel: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6460#a6460 <- folding a constructor over a list, with silly names :)
08:16:53 <Loriel> I was going to say "let's not" when you said "we can solve this by typeclasses and gadts" ;)
08:17:01 <Loriel> I do not think I know what half of those extensions do, alone
08:17:13 <Saizan> hehe
08:17:35 <Saizan> it was a fun exercise in type hackery anyhow :)
08:19:25 <Zao> Baughn: As I intend to use Direct3D, there is no other platform.
08:19:36 <Zao> My hands will be dead and cold before they touch GL.
08:21:02 <kamatsu> Zao: Any C functions that return raw structs (i.e not pointers)
08:21:05 <kamatsu> ?
08:21:16 <kamatsu> If so, you've got some fun times ahead
08:21:20 <kamatsu> if not, it should be easy enough
08:21:54 <kamatsu> Also, I don't get the GL hate
08:22:01 <kamatsu> D3D is nice, but GL is okay too
08:22:02 <Zao> kamatsu: Just about all functions work via out parameters.
08:22:26 <kamatsu> should be ok then
08:22:27 <Zao> The math ones return by value, but I do not particularly intend to use those.
08:22:55 <kamatsu> if you don't intend to release your d3d bindings, then you can just write bindings for those functions that you do use
08:24:00 <Zao> I know some other lad was trying to bind d3d a while ago, so I will only serve myself for now.
08:39:10 <sshc> what is "default" in Haskell?
08:39:19 <Botje> in what context?
08:39:22 <thaldyron> Did anyone manage to build ArrayRef with GHC 6.12?
08:39:42 <sshc> Botje: default is a keyboard
08:39:47 <sshc> keyword*
08:39:55 <Botje> in what context are you using it?
08:40:04 <sshc> Botje: I'm not using it in any context
08:40:13 <sshc> Botje: I'm wondering why it's a keyword and purpose it serves
08:41:02 <Botje> the h98 report doesn't show it as being used
08:41:32 <Botje> http://www.haskell.org/haskellwiki/Keywords#default
08:41:33 <Botje> huh
08:41:39 <Botje> i've _never_ used that feature
08:42:01 <Botje> it looks warty.
08:43:05 <Lemmih> > 10+10 -- This uses defaulting.
08:43:06 <lambdabot>   20
08:43:36 <Botje> yeah, but i didn't know you could steer it
08:43:47 <Botje> and it's constrained to Num, so that's _really_ warty.
09:11:05 <c_olin> Are there a ubuntu package repository that has more current versions of ghc?
09:11:24 <c_olin> any*
09:11:28 <kamatsu> no idea, but building the platform yourself is easy enough
09:11:32 <kmc> @where platform
09:11:33 <lambdabot> http://hackage.haskell.org/platform/
09:35:41 <Cale> orbitz: I'm just finishing up watching the talk. It seems that a lot of what he talks about is quite similar to common program designs in Haskell.
09:36:31 <Cale> orbitz: One of the exciting things which people are starting to explore on the Haskell side of things is the idea of continuous time.
09:36:40 <Cale> (and he doesn't address that)
09:39:04 <ddarius> Cale: Talk?
09:39:37 <Cale> ddarius: http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey
09:40:10 <RayNbow> @hoogle (a -> Maybe b) -> [a] -> [b]
09:40:11 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
09:40:11 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:40:11 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:40:39 * RayNbow is surprised that that function already exists in a module
09:42:22 <Cale> Well, it's the same as catMaybes following map
09:42:41 <RayNbow> I knew about catMaybes
09:42:52 <xerox> I feared for a moment the url ended with Are-We-There-Yet-Rick-Astley
09:42:59 <Cale> ahaha
09:43:36 <RayNbow> Are We There Yet is a nice talk :)
09:46:29 * Baughn wonders how he ever survived without GADTs
09:47:33 * MissPiggy wonders how I survived without $thing_i_don't_know_about_yet :(
09:47:41 <gmat> '
09:48:08 * Loriel wonders how he was supposed to survive without GADTs
09:48:34 <Cale> Baughn: They're pretty fun. One of my favourite applications for GADTs is in conjunction with something like MonadPrompt
09:49:14 <Baughn> I imagine they'd be great for anything vaguely resembling an EDSL, yes. :)
09:50:02 <Saizan> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6460#a6460 <- they are great for silly type hackery too
09:50:50 <Baughn> Meep
09:51:24 <Baughn> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16471#a16471 <-- Since you're already doing silly type-hackery, any ideas how I can show the type of the function in Pure?
09:51:37 <Baughn> Of course I can't add a Typeable constraint to arr, no matter how much I want to. :/
09:51:47 <Cale> hpaste.org isn't resolving correctly
09:52:06 <Cale> (someone forgot to renew the domain?)
09:52:09 <b0fh_ua> Hi there! I have met some strange statement
09:52:09 <Baughn> Point.
09:52:13 <b0fh_ua> type State st a = st -> (st, a)
09:52:19 <Baughn> http://64.131.71.66/fastcgi/hpaste.fcgi/view?id=16471 , then
09:52:28 <b0fh_ua> can somebody please explain what's going on there?
09:52:41 <Baughn> b0fh_ua: Well, it's a type alias
09:52:53 <Baughn> b0fh_ua: "Whenever you see "State st a", replace it with st -> (st,a)"
09:53:01 <b0fh_ua> I understand what is it with data types
09:53:11 <b0fh_ua> like "type String = [Char]"
09:53:24 <Cale> b0fh_ua: the very same thing
09:53:30 <Cale> b0fh_ua: Only with different types.
09:53:32 <b0fh_ua> but st -> (st,a) is as function type?
09:53:34 <Cale> yes
09:53:40 <b0fh_ua> omg
09:53:57 <b0fh_ua> yet another way to make things overcomplicated :)
09:54:07 <Cale> Nah, it's simplifying.
09:54:14 <Baughn> b0fh_ua: What would you prefer? ;)
09:54:17 <xerox> actually simpler, nothing special about function types, just types
09:54:33 <Baughn> b0fh_ua: A State "value" is a function from a state to a new state. That's just what it is.
09:54:34 <Cale> You're supposed to reach a point where you don't think of (State s a) values as their underlying functions
09:54:51 <Cale> Actually, this is usually done with a newtype
09:54:59 <sioraiocht> Cale: read a "state", if you will?
09:54:59 <b0fh_ua> http://pastebin.com/dbc931c3 = this make me confused
09:55:02 <Cale> newtype State s a = S (s -> (s,a))
09:55:03 <sioraiocht> *reach
09:55:10 <Cale> sioraiocht: heh
09:55:40 <sioraiocht> hrm, just thinking, but really a State is then just a Stream
09:55:46 <sioraiocht> where states are elements of the stream
09:55:55 <sioraiocht> (or list, if you want)
09:56:00 <Cale> b0fh_ua: Come to #haskell-overflow (so that there will be no noise), and I'll go over the state monad if you like.
09:56:54 <b0fh_ua> Cale: thanks, I will try to read on and understand things first, and them will ask you to explain me points that I am missing up :)
09:56:58 <Baughn> sioraiocht: That's another way of putting it, sure
09:57:18 <sioraiocht> Seems to me it wouldn't help a learner
09:57:20 <ddarius> sioraiocht: Not really.
09:57:21 <Cale> b0fh_ua: The basic idea is pretty simple. A value of type (State st a) is meant to be thought of as a sort of computation which when run, will operate in some fashion on a state of type st, before producing a result of type a
09:57:28 <ddarius> sioraiocht: More like a process tree.
09:57:58 <Cale> b0fh_ua: returnState v  is meant to be the computation which does nothing to the current state -- simply passing it through to the final state -- and which returns the result v
09:58:23 <Baughn> sioraiocht: You could conceivably implement State using an inter-dependent list of states. It is not entirely clear to me how that would help, mind you. :P
09:58:51 <sioraiocht> Baughn: indeed, was an observation, nothing more
09:59:14 <sioraiocht> although you can show that Stream a with a Skip constructor is isomorphic to List (Maybe a(
09:59:35 <Baughn> List is supposed to have an End element too
09:59:47 <sioraiocht> sorry, Stream with Done
09:59:50 <sioraiocht> as well as Skip
10:00:34 <ddarius> The difference between an existential and universal quantification for s is large.
10:02:04 <ddarius> Or more relevant, the difference between existential quantification and parameterization.
10:03:26 <Berengal> Perhaps instead of type-checking we should call it typo-checking?
10:03:26 <ddarius> (Indeed, they are adjoint to each other: exists -| parameterize -| forall)
10:03:44 <Eduard_Munteanu> Hi.
10:04:38 <Eduard_Munteanu> I have 3 data declarations: data A = A1 | A2, data B = B1 | B2, data T = A B
10:04:53 <Eduard_Munteanu> Why do I get an error when trying to construct a T as A1 B1 ?
10:05:06 <Berengal> Eduard_Munteanu: Your T needs a data constructor too
10:05:14 <Berengal> data T = T A B
10:05:41 <Eduard_Munteanu> Berengal, oh, thanks. I thought I didn't need it if it wasn't parametric.
10:06:19 <Berengal> Eduard_Munteanu: Everything needs a data constructor. In some sense, all values are constructors
10:06:19 <Eduard_Munteanu> Is there any variation on data (type, etc.) that I can use to remove the need for a named T constructor?
10:06:33 <MissPiggy> data A = A1 B | A2 B
10:06:41 <Berengal> Eduard_Munteanu: 'type' defines a synonym, you you could use type T = (A, B) and use tuples...
10:07:04 <Eduard_Munteanu> MissPiggy, nah, that would be too many permutations.
10:07:17 <MissPiggy> then you need a constructor
10:07:19 <idnar> Eduard_Munteanu: how would the compiler know what to name the constructor?
10:07:19 <Eduard_Munteanu> (I'm using it to describe chess pieces)
10:07:47 <Eduard_Munteanu> Berengal, oh, so type works with tuples.... I tried it for data and it gave an error, thanks.
10:08:07 <Eduard_Munteanu> idnar, ah, I thought any combination A B would be inferred to T
10:08:23 <Eduard_Munteanu> (esp. since neither of those is parametric)
10:08:43 <Berengal> Eduard_Munteanu: 'A1 B1' means construct an A with a B in it
10:08:57 <idnar> A1 B1 is just a type error
10:09:08 <Eduard_Munteanu> Berengal, yeah, but neither A nor B are parametric. Anyway, I'll use type and tuples.
10:09:09 <Berengal> typo error :)
10:09:13 <Eduard_Munteanu> Heh :).
10:09:17 <idnar> A1 would need to be a function for A1 B1 to work
10:09:56 * Berengal is s/type/typo/g ing
10:10:09 <idnar> typist error
10:25:21 <ddarius> "A categorical setting for the 4-colour theorem" sounds interesting.
10:25:59 <copumpkin> it does
10:26:18 <copumpkin> do they have a proof of it that doesn't involve a computer? :)
10:26:30 <benmachine> I hate computers
10:26:37 <benmachine> whoever achieved anything with computers
10:26:43 <burp> has anyone build gtk2hs with the 6.12 patch and can use glade?
10:27:03 <Loriel> Has anyone build gtk2hs with 6.12 and been able to do anything at all with it?
10:27:34 <SamB_XP> copumpkin: you mean besides for the pretty equations and diagrams ?
10:27:49 <copumpkin> yep
10:27:51 <burp> Loriel: yes
10:28:00 <burp> some demos work
10:28:17 <Loriel> I cannot even seem to link a hello-world
10:28:31 <Loriel> I must be usinsg the wrong patch
10:28:35 <burp> that works for me
10:28:43 <ddarius> copumpkin: "The 4-Colour Theorem has been proved in the late seventies , after more than a century of fruitless efforts. But the proof has provided very little new information about the map colouring itself. While trying to understand this phenomenon, we analyze colouring in terms of universal properties and adjoint functors."
10:28:56 <ddarius> copumpkin: "... In this context, the 4-Color Theorem becomes a statement about the existence of coalgebra structure on graphs."
10:29:03 <copumpkin> ooh
10:29:06 <burp> http://tobias-neumann.eu/tmp/ghc-6.12.dpatch this one?
10:29:36 <ddarius> copumpkin: A lot of interesting sounding papers here: http://www.kestrel.edu/home/people/pavlovic/
10:29:44 <copumpkin> thanks :)
10:30:07 <EnglishGent> hi all :)
10:30:07 <Loriel> Apparently not
10:30:08 <orbitz> Cale: there?
10:30:21 <Loriel> "All these patches have already been applied.  Nothing to do" :/
10:30:25 <Cale> orbitz: Yes, though I'm giving a tutorial in #haskell-overflow at the moment
10:31:05 <copumpkin> I wish people would regenerate their old papers as nice pdfs once in a while
10:31:52 <Loriel> copumpkin: And update them to changes in their code
10:31:55 <orbitz> Cale: okay, well you can take as long as you want to respond, as long as you start off with my name my irc client will notify me.  Anyways, what he describes basically soudns like how peopel use monads in Haskell, except he wants the ability to store the state and observ it inbetween >>'s, is my understanding wrong?
10:33:17 <Cale> orbitz: Er, actually, it doesn't really sound like it's *quite* monad-shaped to me, though you could squish it into that mold.
10:33:34 <SamB_XP> Cale: oh, like egg-molds maybe!
10:33:49 <orbitz> Cale: i guess i saw state as State and his pure functions to move between states as >>=
10:36:25 <Cale> orbitz: That's not *so* far off, though his model is even simpler. There's just a state and a pure function which is being iterated, or a sequence of pure functions being composed to move things along.
10:36:38 <Cale> No "results", like the State monad has.
10:36:58 <orbitz> Ok, so it's basically like any haskell program in that sense, pure functions composed to move from input to output?
10:41:20 <Alpounet> what does  'The type signature for `foo' lacks an accompanying binding' mean ?
10:42:00 <orbitz> Alpounet: you didn't define 'foo'
10:42:38 <Alpounet> oh, yeah, mistyped
10:42:39 <Alpounet> thanks.
10:46:17 <RayNbow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=6462#a6462 <-- I'm wondering whether this function can be written without explicit recursion
10:46:41 <Berengal> RayNbow: Does fix count?
10:48:26 <RayNbow> Berengal: hmm, not sure actually :p
10:48:54 <copumpkin> I'd say it doesn't count, because it always counts
10:49:20 <Botje> RayNbow: that function decides the closest power of f to n, right?
10:49:41 <tibbe> anyone managed to use ThreadScope on OS X?
10:49:42 <Dashkal> Is there any kind of best practice for naming of functions that make pretty printed strings of values?  I hesitate to use show as that's tied to read when serializing.
10:50:36 <RayNbow> Botje: f^(multiplicity n f) divides n
10:50:56 <Botje> fst $ last $ takeWhile ((<= n) . snd) $ zip [0..] $ iterate (*f) 1
10:51:09 <benmachine> no
10:51:13 <benmachine> that doesn't guarantee that it divides
10:51:23 <Botje> neither does his code
10:51:39 <benmachine> yes it does
10:51:46 <benmachine> because the Rem has to be 0
10:51:49 <RayNbow> erm, f^(multiplicity n f) divides n... if multiplicity n f is not 0
10:51:56 <Botje> otherwise the function returns zero
10:51:59 <RayNbow> hmm wait
10:52:05 <RayNbow> it also divides in that case
10:52:22 <Alpounet> how can I get the content of what a ForeignPtr points to ?
10:52:42 <Baughn> > proc x -> x
10:52:43 <lambdabot>   <no location info>: parse error on input `->'
10:52:49 <benmachine> RayNbow: I came up with something using unfoldr
10:52:53 <benmachine> does that count?
10:53:05 <Botje> unfoldr would be my second attempt
10:53:19 <RayNbow> benmachine: I'm interested :)
10:53:20 <Botje> but i never can figure it out without peeking at the type
10:53:30 <benmachine> RayNbow: gotta test it first, one sec
10:54:07 <Alpounet> :t \(!x) -> x
10:54:08 <lambdabot> Illegal bang-pattern (use -XBangPatterns)
10:55:52 <ddarius> @hoogle ForeignPtr
10:55:53 <lambdabot> module Foreign.ForeignPtr
10:55:53 <lambdabot> Foreign.ForeignPtr data ForeignPtr a
10:55:53 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
10:55:54 <benmachine> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=6462#a6463 umm this turns out to be kind of cheating
10:55:58 <benmachine> but I think it works
10:56:03 <ddarius> @hoogle withForeignPtr
10:56:03 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
10:56:15 <benmachine> takes the length of a list of [()] :P
10:56:41 <Alpounet> ddarius, ok thanks
10:58:57 <RayNbow> benmachine: you could also produce a list of ones and sum it :p
10:59:10 <benmachine> yeah, equally good
10:59:18 <benmachine> slash bad
11:00:57 <Berengal> Golfed: mul' n f = length . takeWhile (==0) . unfoldr (Just . swap . flip quotRem f) $ n
11:01:21 <benmachine> nice
11:01:26 <Baughn> "arr? >>> arr? >>> first ((arr? >>> Print 42)) >>> arr? >>> arr? >>> Print 54" <-- I do not normally desire to show functions, but just this once, please...
11:01:42 <benmachine> unfoldr with a Just function is iterate, isn't it?
11:01:58 <aavogt> > unfoldr (Just . succ) 0
11:02:00 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b)
11:02:05 <Berengal> Not entirely
11:02:09 <benmachine> oh no it isn't
11:02:13 <benmachine> but similar
11:02:21 <Berengal> In this case, not similar enough...
11:02:40 <aavogt> map snd . iterate f  -- is closer to the unfoldr . Just?
11:02:42 <Berengal> We need to emit one value but recurse one another
11:02:48 <npouillard> is there a way to know how many packages there is in hackage
11:02:50 <npouillard> ?
11:02:58 <benmachine> :t let m n f = length . takeWhile ((==0) . snd) . iterate (flip quotRem f . snd)
11:02:59 <lambdabot> <no location info>:
11:03:01 <benmachine> er
11:03:01 <lambdabot>     not an expression: `let m n f = length . takeWhile ((==0) . snd) . iterate (flip quotRem f . snd)'
11:03:07 <benmachine> :t let m n f = length . takeWhile ((==0) . snd) . iterate (flip quotRem f . snd) in m
11:03:09 <lambdabot>     Ambiguous occurrence `snd'
11:03:12 <lambdabot>     It could refer to either `L.snd', defined at <local>:9:0
11:03:12 <benmachine> wat
11:03:13 <lambdabot>                           or `Data.Tuple.snd', imported from Data.Tuple
11:03:15 <dum8d0g> Hi, hypotetical question -- is possible to do something like 'clauseNum :: Either Instance Clause -> Int' ??
11:03:19 <benmachine> :t L.snd
11:03:22 <lambdabot> forall t t1. (t, t1) -> t1
11:03:28 <Berengal> npouillard: cabal list | grep '*' | wc -l
11:03:32 <benmachine> how useless
11:03:54 <mauke> @undefin
11:04:17 <aavogt> npouillard: cabal downloads a 00-index.tar, which contains 1813 directories
11:04:19 <npouillard> Berengal: thanks
11:04:26 <benmachine> Berengal: you'd need '^*'
11:04:33 <Berengal> benmachine: Oh, yeah
11:04:38 <benmachine> @undefine
11:04:43 <benmachine> :t L.snd
11:04:47 <lambdabot> Not in scope: `L.snd'
11:04:50 <benmachine> @bots
11:04:51 <lunabot>  :o
11:04:52 <lambdabot> :)
11:04:56 <benmachine> :t let m n f = length . takeWhile ((==0) . snd) . iterate (flip quotRem f . snd) in m
11:04:57 <lambdabot> forall t b. (Integral b) => t -> b -> (b, b) -> Int
11:04:59 <npouillard> Berengal: that's what I did actually
11:05:21 <benmachine> :t let m n f = length . takeWhile ((==0) . snd) . iterate (flip quotRem f . snd) . join (,) in m
11:05:22 <lambdabot> forall t b. (Integral b) => t -> b -> b -> Int
11:05:31 <benmachine> I am making this ever more complicated :P
11:05:49 <benmachine> :t let m n f = length . takeWhile ((==0) . snd) . iterate (flip quotRem f . snd) $ (undefined, n) in m
11:05:50 <lambdabot> forall b. (Integral b) => b -> b -> Int
11:05:59 <benmachine> let m n f = length . takeWhile ((==0) . snd) . iterate (flip quotRem f . snd) $ (undefined, n) in m 8 2
11:06:05 <benmachine> oh well
11:06:08 <benmachine> > let m n f = length . takeWhile ((==0) . snd) . iterate (flip quotRem f . snd) $ (undefined, n) in m 8 2
11:06:10 <lambdabot>   0
11:06:14 <benmachine> :x
11:06:18 <benmachine> never mind
11:06:44 <Cale> orbitz: yeah, though there is this notion that maybe we should package up these "identities" in some meaningful way.
11:07:18 <orbitz> Cale: in Hickey's thing or in Haskell?
11:07:33 <Cale> orbitz: In Hickey's thing.
11:07:41 <orbitz> Cale: what do you thin kof that?
11:08:58 <Cale> It's not wrong. It's nice to expressively capture the notion of something which is changing over time with sequences of immutable values. There are other ways to model them as well.
11:09:28 <path[l]> Im halfway through the talk :)
11:10:23 <dum8d0g> ok, second (final) try..
11:10:28 <dum8d0g> Hypotetical question -- is possible to do something like 'clauseNum :: Either Instance Clause -> Int' ??
11:10:43 <mauke> dum8d0g: I have no idea what you're talking about?
11:11:22 <dum8d0g> mauke: My friend asked me that.. Hi is obviously trying to do some type of overloading
11:11:30 <benmachine> if Clause and Instance are both types, it is possible
11:11:35 <dum8d0g> *He
11:11:39 <mauke> dum8d0g: I don't see how that's overloading
11:12:08 <dum8d0g> benmachine: May it be data?
11:12:34 <benmachine> dum8d0g: the function 'const 1' is type t -> Int for any t you like
11:12:41 <dum8d0g> mauke: I don't understand him too.. but it seems interesting
11:12:47 <benmachine> maybe that's not what you want :P
11:12:59 <mauke> dum8d0g: no, it doesn't
11:14:17 <dmwit> Maybe your friend should come here and ask for himself.
11:14:31 <benmachine> or just pose a question that actually means anything
11:14:39 <dmwit> He'll likely know better what he means, and we won't have to send our explanations/questions through such a high-latency, noisy channel.
11:15:39 <dum8d0g> ok, I asked him to come..
11:23:10 <dum8d0g> He refuses to come because he is scared of you ..
11:23:24 <dum8d0g> so .. question solved.. somewhat..
11:23:43 <Berengal> o.O
11:23:56 <mauke> how old is he?
11:23:56 <Dashkal> Scared of us?  Did he make this mistake of entering java or something?
11:24:12 <benmachine> we're nice promise
11:24:28 <benmachine> #haskell is nicer than most IRC support channels
11:24:30 <lunabot>  luna: Not in scope: `haskell'
11:24:41 <benmachine> and by most I mean every single one I've ever been to
11:25:25 <dum8d0g> thank you guys, but he obviously have some issues with talking to strangers.. :/
11:25:34 <dum8d0g> my mistake
11:25:42 <PepeSilvia> hi nice people :) could anyone recommend an introductionary page or paper on delimited continuations in haskell?
11:25:54 <Dashkal> There seems to be an unfortunate inverse relation between the size of a community and the friendliness of its irc channel...
11:26:21 <Saizan> PepeSilvia: seen this one? http://www.haskell.org/haskellwiki/Library/CC-delcont
11:26:41 <benmachine> Dashkal: there seems to be an unfortunate relation between the friendliness of an IRC channel and "not friendly"
11:26:44 <benmachine> this is the sole exception :P
11:27:02 <Badger> Dashkal: so if 400 people joined #haskell, we'd all become mean and nasty? :P
11:27:04 <benmachine> (where the unfortunate relation is equality)
11:27:19 <Dashkal> Badger: No, just that newbies would see the nasty loud people before the nice ones.  They make more noise.
11:27:25 <Saizan> PepeSilvia: the "Shift to Control" one linked at the end is good to get an intuition about the control operators
11:27:43 <PepeSilvia> Saizan: I believe I have, but I'm looking for something that walks you through the implementation of reset, control, etc. just like they did for undel. cont on the wikibooks page
11:28:15 <Badger> @vixen are you nice?
11:28:16 <lambdabot> i'm nice to everyone!
11:28:20 <Badger> :)
11:28:36 <lament> @vixen even when asleep?
11:28:36 <lambdabot> 19/f/California
11:29:15 <PepeSilvia> like this --> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
11:29:23 <PepeSilvia> Saizan: but thanks, I'll check that paper out
11:30:09 <RayNbow> benmachine: I think I'll stick to the strict tail recursive version :p
11:30:41 <Saizan> PepeSilvia: well, del. continuations with multiple prompts are not as easy to implement, but you might look at the paper from which CC-delcont got implemented
11:30:46 <Dashkal> when a new type is created via newtype, are the source type's typeclass instances inherited or do they need to be declared again?
11:31:07 <mauke> Dashkal: neither
11:31:14 <Saizan> PepeSilvia: a simpler version of del. cont. is presented here http://www.haskell.org/pipermail/haskell/2007-December/020034.html , though
11:31:14 <mauke> you can make completely different instances
11:31:23 <jfoutz> delimeted continuations are unreal.
11:32:07 <xerox> simpler and oleg in the same phrase, weird
11:32:14 <Dashkal> Is there a simple way to grab existing ones?  I'm looking for a simple way to avoid being able to assign a person's height to their age without losing the ability to add.
11:32:18 <benmachine> Dashkal: the ghc extension -XNewtypeDeriving allows you to choose some instances for the newtype to inheirt
11:32:21 <benmachine> inherit
11:32:30 <Dashkal> benmachine: ahh, danke.  I'll look into that
11:32:34 <benmachine> newtype MyInteger = MyInteger Integer deriving Num
11:32:42 <PepeSilvia> Saizan: ah thanks, most of the stuff I found was in scheme/lisp which I'm not that experienced in
11:32:45 <tibbe> anyone managed to build ThreadScope on Mac OS X?
11:33:18 <ddarius> :t unfoldr . (Just . join (&&&))
11:33:19 <lambdabot>     Couldn't match expected type `b -> Maybe (a, b)'
11:33:19 <lambdabot>            against inferred type `Maybe a1'
11:33:19 <lambdabot>     In the first argument of `(.)', namely `Just'
11:33:35 <xerox> :t unfoldr . (Just . join (,))
11:33:36 <lambdabot>     Couldn't match expected type `b -> Maybe (a, b)'
11:33:36 <lambdabot>            against inferred type `Maybe a1'
11:33:36 <lambdabot>     In the first argument of `(.)', namely `Just'
11:33:50 <PepeSilvia> and of course Oleg's page which scares me a bit :p
11:33:53 <ddarius> :t unfoldr (Just . join (,))
11:33:54 <lambdabot> forall a. a -> [a]
11:34:33 <ddarius> :t unfoldr . (Just .) . join (&&&)
11:34:34 <lambdabot> forall b. (b -> b) -> b -> [b]
11:34:35 <xerox> that's not what I meant hehe
11:34:54 <xerox> right
11:35:41 <copumpkin> ddarius: lol
11:36:35 <ddarius> This has an off-by-one error though.
11:36:56 <ddarius> :t unfoldr . (Just .) . (id&&&)
11:36:57 <lambdabot> forall b. (b -> b) -> b -> [b]
11:37:16 <Baughn> @karma+ GADTs
11:37:16 <lambdabot> GADTs's karma raised to 1.
11:38:05 <ddarius> @karma dons
11:38:06 <lambdabot> dons has a karma of 11
11:38:07 <ddarius> @karma lwall
11:38:08 <lambdabot> lwall has a karma of 517
11:38:30 * Baughn wonders what \bot is doing in #perl. The evil mangler?
11:38:37 <xerox> :t unfoldr . (Just .) . second
11:38:38 <lambdabot> forall a b. (b -> (a, b)) -> (a, b) -> [a]
11:38:56 <xerox> nah
11:40:09 <ddarius> second = (id ***)
11:40:29 <ddarius> Baughn: pugs
11:40:45 <Baughn> Ah.
11:49:43 <path[l]> ugh Cale, do you know if infoq allows you to seek?
11:50:17 <Cale> path[l]: It allowed me to seek
11:50:39 <path[l]> hmm wierd.neither firefox nor opera allows me :/
11:51:05 <path[l]> ah got it working
11:58:09 <Alpounet> @src modifyIORef
11:58:09 <lambdabot> modifyIORef ref f = writeIORef ref . f =<< readIORef ref
12:03:30 <Eduard_Munteanu> What should I use for parsing simple stdin? I'm writing something that sits in place of gnuchess and communicates with xboard.
12:04:11 <benmachine> Eduard_Munteanu: if it's simple enough, lines/words/pattern matching
12:04:39 <Eduard_Munteanu> benmachine, yeah, I suppose that would do. Was afraid of writing spagetti.
12:16:56 <Eduard_Munteanu> In (a && b), will Haskell quit evaluating b if a proves false?
12:17:33 <medfly> > False && (sum [1..] == 20)
12:17:34 <lambdabot>   False
12:17:43 <Eduard_Munteanu> medfly, thanks.
12:18:14 <medfly> @src (&&)
12:18:14 <lambdabot> True  && x = x
12:18:14 <lambdabot> False && _ = False
12:18:33 <Eduard_Munteanu> Oh, I can count on it.
12:18:49 <merehap> Eduard_Munteau: yeah, the source of those functions are a nice learning exercise
12:18:57 <merehap> binary ops that is
12:34:44 <tibbe> anyone remember which constraint you need to add to make template-haskell compile?
12:35:05 <benmachine> with ghc 6.12?
12:35:18 <benmachine> base 4.2
12:35:22 <benmachine> I think
12:37:17 <tibbe> 6.10
12:37:26 <tibbe> template-haskell < 2.4 worked
12:42:30 <pretsas> Er, I think there's a mistake in LYAH
12:42:41 <pretsas> At the end of the Files and Streams section
12:42:44 <pretsas> In the I/O chapter
12:42:55 <pretsas> It says
12:42:57 <pretsas> "The reason we used getCurrentDirectory to get  the current directory and then passed it to openTempFile  instead of just passing "." to openTempFile is because .  refers to the current directory on unix-like system and Windows "
12:43:13 <pretsas> When getCurrentDirectory was never actually used anywhere
12:46:07 <aavogt> BONUS: ^^
12:47:05 <aavogt> I think the code is fine, just the explanation is kind of weird (as in "." can be substituted for x <- getCurrentDirectory)
12:47:37 <pretsas> I understand the concept of . and .. :P
12:47:48 <pretsas> But he's referring to nonexistant code
12:48:24 <pretsas> He claims that "we used getCurrentDirectory"
12:48:39 <pretsas> When that is the only occurrence of such a string on that page
12:48:44 <aavogt> well if you flip the sentence around:   we use "." instead of the result from getCurrentDirectory
12:48:49 <pretsas> Ah
12:48:53 <aavogt> then it makes sense :)
12:48:56 <pretsas> Yes
12:49:00 <pretsas> Definitely
12:49:05 <pretsas> But it's still a mistake
12:49:10 <pretsas> And likely to confuse readers :P
12:49:11 <aavogt> I agree
12:50:01 <pretsas> Is work on LYAH being carried out?
12:50:13 <medfly`> yes
12:50:15 <Cale> pretsas: yeah, talk to BONUS
12:50:20 <pretsas> Ah
13:14:02 <burp> does anyone else see godaddy ads on hpaste.org?
13:14:51 <dmwit> oh noes!
13:15:09 <c_wraith> ads?  I don't really see ads on the internet.
13:15:12 <medfly> oh yeah...
13:15:19 <medfly> the paste website is gone, that's what he means.
13:15:21 <Berengal> burp: I don't. Virus?
13:15:35 <benmachine> worksforme
13:15:40 <burp> medfly: yes, godaddy.com domain placeholder
13:16:01 * benmachine reads a paste
13:16:45 <dons> mm
13:16:48 <dons> we lost the domain?
13:17:07 <dons> we did.
13:17:11 <dons> shapr: ?
13:17:13 <benmachine> if we did we did very recently
13:17:29 <benmachine> because it is stubbornly continuing to work for me
13:17:36 <dons> mmm Expiration Date:22-Jan-2011 22:06:54 UTC
13:17:41 <benmachine> wups
13:17:42 <mm_freak> hpaste.org is working for me
13:17:49 <dons> yeah, some dns funkiness?
13:17:56 <mm_freak> % host hpaste.org
13:17:56 <mm_freak> hpaste.org has address 64.131.71.66
13:18:01 <benmachine> I tried an ssh server I have access to
13:18:03 <benmachine> it said 68.178.232.99
13:18:04 <Berengal> 68.178.232.99
13:18:11 <benmachine> whereas locally I get the same as mm_freak
13:18:48 <dons> i see godaddy ads, 68.178.232.99
13:19:03 <dons> but http://64.131.71.66/ works
13:19:12 <benmachine> so I guess those of us for whom it still works are just DNS cached or something
13:19:37 <Berengal> Weird, hpaste.org resolves to 68.178.232.99, but konqueror loads 64.131.71.66
13:19:51 <benmachine> well, we still have unsafecoerce.com :P
13:20:00 <Badger> the poor thing has domain confusion
13:20:01 <burp> it's the cache
13:20:05 <benmachine> should someone change the topic?
13:21:25 <mm_freak> what's wrong with hpaste anyway?  it's failing a lot
13:21:31 <mm_freak> at least that's my impression
13:21:54 <benmachine> never failed for me
13:21:58 <Berengal> Me neither
13:22:58 <monochrom> "this page is parked free, courtesy of godaddy.com"?
13:23:09 <monochrom> @where hpaste
13:23:09 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
13:23:13 <xerox> thank you godaddy
13:23:21 <pretsas> unsafecoerce.com seems to be filled mostly with spam
13:23:37 <Gracenotes> how much do you need to get it back?
13:23:41 <monochrom> Well try http://moonpatio.com/fastcgi/hpaste.fcgi/ I always use it.
13:23:52 <Gracenotes> my firefox bookmarks :|
13:26:37 <monochrom> DNS is sad.
13:27:10 <benmachine> pretsas: yeah but to be fair most of it is two days old
13:27:24 <benmachine> if we started using it regularly it'd all get drowned pretty quickly
13:27:31 <pretsas> Probably
13:27:41 <aavogt> but which one?
13:27:58 <benmachine> I like the name of unsafecoerce.com better
13:28:00 <benmachine> easier to remember
13:28:03 <benmachine> but either is fine
13:28:32 <monochrom> No. I can't remember whether it's .com or .org or .net. Then again same goes to hpaste.org too.
13:29:08 <benmachine> I think most people just click on the link when someone pastes it in the channel
13:29:13 <benmachine> so it doesn't really matter what you use
13:29:13 <aavogt> yeah, best would be to pick a name that you can have all the tldS
13:29:14 <monochrom> And after a while I'll even think "it is unsafe something, but is it unsafe coerce or unsafe perform io?"
13:30:02 <monochrom> Oh but what if I am initiating a paste? I mean that is the only reason to ever remember anything isn't it?
13:30:08 * stoop recently purchased applicative.org
13:31:00 <monochrom> In the end I add them to my firefox bookmarks and google bookmarks. But ha, then I don't care how difficult it is to remember them.
13:32:11 <monochrom> Someone should set up yhjulwwiefzojcbxybbruweejw.com or something!
13:32:19 <monochrom> @yhjulwwiefzojcbxybbruweejw
13:32:19 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
13:32:29 <aavogt> how about arranging something like paste.haskell.org?
13:32:44 <monochrom> @yhjulwwiefzojcbxybbruweejw
13:32:44 <lambdabot> "\""
13:32:47 <monochrom> Hmm!
13:33:09 <monochrom> Yes paste.haskell.org is very good.
13:34:45 <Gracenotes> lambdabot is not indenting?
13:35:19 <Gracenotes> oh god. that string... it's ALIVE
13:35:19 <aavogt> but those are builtin
13:35:25 <benmachine> for some things she doesn't
13:35:35 <Gracenotes> the Google does not help!
13:36:07 <dons> oh, good idea. we should just grab paste.haskell.org
13:36:46 <monochrom> Oh hi Don Stewart!
13:36:59 <monochrom> (Think of it as Don Corleone!)
13:37:21 <Twey> 21:32:21 < monochrom> @yhjulwwiefzojcbxybbruweejw
13:37:25 <Twey> — what?  :þ
13:37:29 <monochrom> Don of the family, err, community!
13:37:47 <Gracenotes> @yhjulwwiefzojcbxybbruwwwww
13:37:47 <lambdabot> Unknown command, try @list
13:37:54 <monochrom> I was suggesting grabbing yhjulwwiefzojcbxybbruweejw.com and setting up as our favourite paste bin!
13:38:06 <Gracenotes> @yhjulwwiefzojcbbbbbruweejw
13:38:06 <lambdabot> "\"#$%&'()*+,\""
13:38:30 <monochrom> But if you asked why yhjulwwiefzojcbbbbbruweejw is a valid command of lambdabot, I don't really know. Ask some lambdabot historian...
13:38:44 <Twey> Crazy stuff
13:38:55 <Twey> What is it actually doing?
13:39:02 <ziman> @yhjulwwiefzojcbbbbbruweejw
13:39:02 <lambdabot> "\"#$%&'()*+,\""
13:39:08 <benmachine> I think it's a @quote special thing
13:39:09 <Twey> Random iterations of ‘show’ on ""?
13:39:09 <benmachine> like @ghc
13:39:13 <Gracenotes> monochrom: well, that's the a valid command because of the edit distance
13:39:19 <benmachine> @v
13:39:20 <lambdabot> "\""
13:39:21 <Twey> No, it gave two different answers
13:39:34 <benmachine> so does @ghc :P
13:39:37 <Gracenotes> the nice b's all lined up in a row. the origin of the other one is probably keyboard noise
13:39:38 <Twey> @ghc
13:39:38 <lambdabot> ghc says: Its main purpose is to encapsulate the Horrible State Hack
13:39:41 <Twey> Ah
13:39:42 <ziman> it has given three distinct answers
13:39:51 <Twey> No, just two, ziman
13:40:00 <Twey> The other was a completely different command with a crazy name!
13:40:01 <xerox> There is this name for the variable that holds the code that was easily guessable, if you fed it back with "> ..." you got weird results. yhjulwwiefzojcbbbbbruweejw should be the actual name.
13:40:04 <Cale> That was, for a while, either the name of the variable which was being let bound when evaluating an expression, or one of the fixed-point bits of gibberish which it was possible to emit by abusing the knowledge of it.
13:40:04 <monochrom> Gracenotes: I looked up http://code.haskell.org/lambdabot/COMMANDS
13:40:18 <ziman> Twey, ah, now i see
13:40:21 <Twey> Nice.
13:40:26 <benmachine> I went and read the chatlogs for that once
13:40:29 <benmachine> it was kind of funny
13:42:10 <merehap> well this is odd:
13:42:12 <merehap>     Ambiguous module name `Control.Monad.Error':
13:42:13 <merehap>       it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.0.0.1
13:42:22 <Gracenotes> oh that :(
13:42:28 <monochrom> You installed both mtl and monads-fd, as the message says.
13:42:35 <merehap> yeah
13:42:36 <Gracenotes> I think the solution is to uninstall one?
13:42:45 <monochrom> And oh what fun, they both provide Control.Monad.Error!
13:42:50 <merehap> what did monads-fd come with?
13:42:53 <dmwit> merehap: Perhaps you should use the extension that allows you to prefix module names with package names.
13:42:55 <ddarius> There are package imports in GHC 6.12 (and 6.10?) to handle that.
13:42:57 <merehap> yeah, why are they doing that?
13:43:07 <Gracenotes> merehap: dependency?
13:43:11 <monochrom> package author feuds?
13:43:15 <merehap> ha
13:43:19 <Gracenotes> monads-fd is a cancer!
13:43:20 <merehap> I hope that isn't it
13:43:33 <monochrom> hide one of them.
13:43:39 <Gracenotes> except it's benevolent
13:43:45 <Heffalump> the idea is that mtl should be refactored into transformers+monads-fd
13:43:48 <merehap> did monads-fd come from missingh? I don't know how I got it
13:43:51 <monochrom> ghc-pkg hide monad-fd  or  ghc-pkg hide mtl
13:44:00 <merehap> ok, thanks
13:44:02 <Heffalump> so that you can also have transformers+monads-tf
13:44:12 <Heffalump> transformers is H98 only, monads-fd is the fundep part
13:44:22 <Heffalump> unfortunately the migration isn't really happening
13:44:44 <merehap> but either will work appropriately?
13:44:55 <monochrom> There is a tedious way to query ghc-pkg to find out who depends on monad-fd
13:45:09 <merehap> I guess I'll go with fd, if it is all the same
13:45:17 <Heffalump> merehap: pretty much, you just need to pick one consistently
13:45:25 <Heffalump> and hope packages you're using have done the same
13:45:47 <merehap> ugh, I just want >>= for Either! no tedious querying
13:45:52 <merehap> ok, will do
13:46:03 <monochrom> This is why if you use cabal for your project, you have to list the packages you want, and cabal hides all other packages.
13:46:25 <Berengal> Overlapping module names still mess with haddock...
13:46:26 <monochrom> So for example if you forgot to say "base" then you really have no Prelude!
13:47:36 <Cale> The monad instance for Either that's in the mtl kind of sucks anyway.
13:47:49 <merehap> really, what's the difference?
13:47:57 <Cale> It's got that silly Error class nonsense.
13:48:00 <monochrom> If you just want >>= for Either... what Cale says. Therefore, by the law of the excluded middle, you should go with monads-fd!
13:48:02 <Gracenotes> I dislike the Error business myself
13:48:10 <Cale> instance (Error e) => Monad (Either e)
13:48:15 <tensorpudding> yeah, code should stay out of errors
13:48:23 <monochrom> This is why excluded middle is useful and realistic!
13:48:35 <merehap> I love when logical proofs are the deciding factor for a real discussion :)
13:48:47 <tensorpudding> most people don't...
13:48:49 <merehap> or logical axioms, anyway
13:49:01 <Gracenotes> excluded middle may be a useful heuristic in real life, but it has no place in our academic halls
13:49:08 <merehap> :)
13:49:27 <Gracenotes> >_>
13:49:39 <monochrom> It surely has importance in my heavily Cont monadic programs.
13:49:50 <monochrom> And all of formal verification.
13:49:59 <Gracenotes> all psuedoscience
13:50:52 <merehap> let's make it as difficult as possible to prove programs
13:51:03 <dons> did people see that CAL is on github now?
13:51:18 <dons> good start for a haskell runtime on the jvm. http://github.com/levans/Open-Quark
13:51:48 <dons> (try to port say, ghc-core to the cal runtime)
13:53:47 <Gracenotes> Ubuntu will run out of alphabet letters in 2017, it seems
13:54:09 <Botje> there's always unicode
13:54:22 <merehap> well that will be the year of the apocalypse
13:54:29 <merehap> not 2012, obviously
13:54:42 <monochrom> haha
13:55:32 <Dodek> there will be 'a' after 'z', carry 'a'
13:55:48 <Gracenotes> ah. good idea.
13:55:50 <monochrom> Perhaps they will continue with Greek letters. Ubuntu αθενα
13:55:58 <Gracenotes> personally I'm a bit worried about the X obstacle
13:56:16 <tensorpudding> they'll skip x probably
13:56:17 <merehap> Xenophobic Xylophone?
13:56:22 <monochrom> ubuntu xylophone xanthum
13:56:37 <Gracenotes> ah yes, just taking my pet xylophone out for a walk
13:56:39 <tensorpudding> and q too
13:56:42 <tensorpudding> well
13:56:46 <tensorpudding> probably not
13:56:50 <tensorpudding> it'll be a quail or something
13:57:01 <monochrom> ubuntu quanlified qualifier
13:57:02 <merehap> quizzical quail
13:57:21 <tensorpudding> quixotic quetzacotl
13:57:23 <Philonous> How do Agda an Epigram compare?
13:57:48 <dolio> They've already used H twice.
13:57:49 <Twey> No way they'll skip X
13:57:50 <merehap> > compare "Agda" "Epigram"
13:57:51 <lambdabot>   LT
13:57:57 <Twey> It's not like a geek to pass up such a challenge
13:58:18 <Twey> I'm sure there's some obscure animal with an appropriate initial
13:58:28 <monochrom> There is no challenge. Just exhaustive-search /usr/dict/words
13:59:36 <Gracenotes> dolio: that's an anomaly
13:59:53 <Philonous> > compare Agda Epigram
13:59:55 <lambdabot>   Not in scope: data constructor `Agda'Not in scope: data constructor `Epigram'
14:00:29 <Gracenotes> well, internet, http://wiki.answers.com/Q/What_are_some_animals_that_begin_with_the_letter_X
14:00:49 <Philonous> Hah. Lambdabot knows nothing of other languages. What a smug attitude.
14:01:05 <Gracenotes> some of them potentially scientific names
14:01:06 <burp> lambdabot knows brainfuck
14:01:58 <Philonous> > haskell <3
14:01:59 <lambdabot>   True
14:02:07 <burp> haha
14:02:22 <burp> > haskell >3
14:02:23 <lambdabot>   False
14:03:00 <monochrom> > haskell
14:03:01 <lambdabot>   2
14:03:18 <merehap> speaking of HaskellLove, where has he been? :)
14:03:37 <monochrom> brain exploded.
14:03:44 <burp> eaten by euler
14:03:51 <merehap> the sad but inevitable fate...
14:03:55 <copumpkin> he's been lovin'
14:04:01 <monochrom> Waiting for computer and naïve algorithm to finish.
14:04:22 <Philonous> Someone told him to evaluate f x = g x; g x = f $ f x by hand. He is still working on it.
14:04:44 <Berengal> preflex: seen HaskellLove
14:04:44 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- HaskellLove was last seen on #haskell-in-depth 5 days, 8 hours, 22 minutes and 2 seconds ago, saying: ok enough theory for today time to do something practical
14:04:55 <merehap> ha!
14:05:00 <merehap> very appropriate
14:05:03 <tensorpudding> there is a #haskell-in-depth?
14:05:15 <benmachine> there are several #haskell-s
14:05:26 <monochrom> for very advanced topics
14:05:29 <merehap> join #haskell-love
14:05:46 <Philonous> #haskell-C++, #haskell-PHP, #haskell-agda
14:05:48 <lunabot>  luna: parse error on input `|'
14:11:14 <Twey> Hm… someone remind me, what's the difference between Monoid and MonadPlus?
14:11:32 <merehap> not much, they should be the same thing irc
14:11:38 <merehap> iirc*
14:11:38 <ddarius> Twey: Their instances don't even have the same kind.
14:11:44 <MissPiggy> MonadPlus is a monad :D
14:11:54 <aavogt> > Just 1 `mplus` Just 2
14:11:55 <tensorpudding> @src Monoid
14:11:55 <lambdabot> class Monoid a where
14:11:55 <lambdabot>     mempty  :: a
14:11:55 <lambdabot>     mappend :: a -> a -> a
14:11:55 <lambdabot>     mconcat :: [a] -> a
14:11:56 <lambdabot>   Just 1
14:12:04 <tensorpudding> @src MonadPlus
14:12:04 <lambdabot> Source not found. Are you on drugs?
14:12:05 <Twey> ddarius: Huh?
14:12:06 <Twey> class (Monad m) => MonadPlus m where
14:12:10 <aavogt> > Just (Sum 1) `mappend` Just (Sum 2)
14:12:11 <lambdabot>   Just (Sum {getSum = 3})
14:12:13 <Twey> class Monoid a where
14:12:19 <MissPiggy> m :: * -> *
14:12:21 <ddarius> Twey: m :: * -> *, a :: *
14:12:23 <Twey> Oh, right
14:12:23 <Cale> There is a difference in kind
14:12:25 <MissPiggy> MonadPlus :: (* -> *) -> *
14:12:28 <benmachine> Twey: the way I had it explained to me is that
14:12:44 <Cale> as well as an expectation that instances of MonadPlus interact with the monad operations in a nice way
14:12:49 <MissPiggy> look at this way: monoids don't have to be a monad
14:12:52 <ddarius> MissPiggy: MonadPlus is not a type constructor, so MonadPlus :: (* -> *) -> * doesn't make sense.
14:12:53 <benmachine> the difference between MonadPlus Maybe and Monoid (Maybe a) is that the latter can place typeclass restrictions on a
14:13:07 <MissPiggy> ddarius: it works in CHR :[
14:13:08 <Cale> However, there's currently at least two definitions of "nice" which ought to be separate classes
14:13:12 <Twey> benmachine: I see.  Thanks.
14:13:15 <benmachine> while MonadPlus can't "see" the type parameter at all
14:13:20 <MissPiggy> ddarius: then again, typeclasses aren't CHR.
14:13:25 <benmachine> which lets you infer more about its behaviour
14:13:30 <ddarius> MissPiggy: However, you could conceive of a system where constructor classes have a target kind, but it wouldn't be *.
14:13:45 <MissPiggy> ddarius: oh good point! thanks
14:13:50 <MissPiggy> that is something I did not even consider
14:13:55 <benmachine> Cale: I've heard x >>= mzero = mzero, what else is there?
14:14:05 <benmachine> or is it mzero >>= x = mzero
14:14:08 <benmachine> or is it both
14:14:11 <c_wraith> both
14:14:12 <Twey> Both, I imagine
14:14:22 <ddarius> (Actually, having something like MonadPlus :: (* -> *) -> 2 wouldn't be (immediately) unreasonable.)
14:14:48 <ddarius> The latter often does not hold.
14:14:58 <ddarius> Er the x >>= const mzero one
14:15:07 <Cale> benmachine: http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
14:17:34 <benmachine> interesting
14:49:06 <Paczesiowa> what's the best, free service (or whatever these things are called) that will let me start a blog with haskell snippets? My knowledge of web development ended with basics of html 10 years ago.
14:49:40 <damd> Paczesiowa: look for blogs which let you use markdown with the codehilite extension
14:49:49 <damd> i haven't looked myself, only written one myself
14:49:57 <damd> (not publically released (yet?))
14:50:08 <damd> publicly*
14:52:54 <bos> tibbe: hey
14:53:23 <tibbe> bos: yo, watching a movie, done in 20 mins
14:53:31 <bos> tibbe: ok. i have data for you.
14:53:36 <tibbe|movie> bos: great!
14:53:43 <tibbe|movie> bos: 20 mins
14:53:48 <bos> :-)
14:55:10 <dons> interesting threadscope report, bos.
14:55:22 <bos> dons: yeah. it's a nifty tool!
14:55:37 <bos> not so nifty when it says "oh, and by the way, you're screwed".
14:55:41 <dons> heh
14:55:59 <dons> orange is GC, is'nt it?
14:56:03 <bos> yeah
14:56:09 <dons> crikey.
14:56:17 <dons> that's some funkiness.
14:56:18 <bos> yeah, that makes no sense at all.
14:56:45 <dons> sounds like a job for ... marlow man
14:57:26 <dons> does it show up under -prof ?
14:57:48 <bos> not really.
14:57:58 <dons> mm
14:58:00 <bos> that tends to make the problem vanish.
14:58:47 <dons> so more allocations in a .prof program -- more context switching. pathological scheduling goes away?
14:58:58 <bos> beats me what's causing that.
14:59:03 <dons> will be interesting to see simonmar's interpretation
15:01:39 <bos> holy cow, it really is spending 75% of its time in the GC.
15:01:50 <bos> i wonder if the GC gets triggered every N context switches, or what?
15:02:15 <bos> because the total amount of heap used is 50MB, which is not big.
15:02:40 <dons> try a -A100M or -H100M setting, to see if that disables the GC
15:02:50 <dons> give the parallel GC more space.
15:02:57 <bos> oh, interesting. the gen-1 collections are taking tens of seconds each.
15:02:58 <dons> (using 6.12?)
15:03:02 <dons> huh
15:03:03 <bos> yes, 6.12.1
15:06:10 <bos> dons: doesn't seem to help
15:06:44 <bos> dons: even with no GC occurring, the program still takes 0.2 seconds sometimes, 20 seconds others
15:06:57 <dons> is there a way to run it under 6.10.4 ?
15:07:27 <bos> it has the same behaviour there.
15:19:12 <tibbe> bos: back. I can see you tried ThreadScope
15:21:21 <Eduard_Munteanu> Aye, these comonads look nice for my chess engine project.
15:21:40 <tibbe> bos: you still around?
15:21:41 <Eduard_Munteanu> I'm thinking to use them to generate moves.
15:23:15 <bos> sort of
15:24:33 <mtnviewmark> hi tibbe
15:24:44 <tibbe> mtnviewmark: hi
15:24:49 <mtnviewmark> I've got haddock all converted to using xhtml
15:24:58 <tibbe> mtnviewmark: cool!
15:25:03 <mtnviewmark> and now am moving the sections, one by one to semantic markup
15:25:20 * tibbe needs to go to be soon. Sledging early tomorrow.
15:25:30 <tibbe> mtnviewmark: that's great news!
15:25:43 <tibbe> mtnviewmark: have you showed your changes to the maintainer?
15:25:47 <mtnviewmark> right - it's winter!  I had to put on a jacket today!  :-)
15:26:16 <mtnviewmark> yes, he's been a great help so far, and is looking forward to the changes
15:26:21 <mtnviewmark> he asked I had been in touch with you!
15:26:34 <mtnviewmark> so - seems this is a happy, all around desired change!
15:27:05 <medfly> what's a good way to hold hierarchical data in Haskell?
15:27:34 <mtnviewmark> like an org. chart?
15:27:41 <medfly> I have no idea what that is
15:28:05 <mtnviewmark> organization chart for a company
15:28:16 <medfly> I dunno, I guess?
15:28:31 <tibbe> mtnviewmark: I really have to go to bed now. keep up the great work!
15:28:34 <mtnviewmark> perhaps then Data.Tree's Tree
15:28:48 <tibbe> g'night all!
15:28:50 <mtnviewmark> later tibbe - I'll send you stuff as I get it done
15:28:56 <tibbe> mtnviewmark: please do
15:28:57 <mtnviewmark> sleep well
15:29:03 <tibbe> bos: we'll talk later :)
15:29:32 <medfly> k thx
15:31:00 <mtnviewmark> but even     data Hierarchy a = HNode a [Hierarchy a]
15:31:06 <mtnviewmark> will work in many cases
15:32:26 <MissPiggy> mtnviewmark that is an excellent type!
15:32:26 <Paczesiowa> that's a RoseTree
15:32:48 <mtnviewmark> oh? seemed like a simple thing that might serve his needs
15:32:50 <MissPiggy> data WonderfulType = o :>-- [WonderfulType o]
15:32:53 <MissPiggy> that's how I define it
15:33:15 <mtnviewmark> Tree, though, has the advantage of being an instnace of Monad, Functor, Foldable, Traversable and Applicative
15:33:26 <MissPiggy> You can write quite a few very elegant programs over it, but I wont spoil the fun by saying what they do :p
15:33:47 <MissPiggy> the resursion structure for it is nice because it leads to one line programs
15:33:48 <medfly> don't worry, there is no fun
15:33:50 <mtnviewmark> The contructor :>-- is sort of cute!
15:34:03 <Alpounet> haha
15:34:11 <idnar> why is it a rose tree? lots of thorns?
15:34:20 <mtnviewmark> It looks like an ostrich sideways
15:34:49 <mtnviewmark> Oddly, in haskell-cafe, a tree question came up, and the type there was
15:35:06 <mtnviewmark> data Tree a = Leaf a | Branches [Tree a]
15:35:17 <mtnviewmark> turns out that is MUCH harder to work with than the rose tree
15:35:29 <copumpkin> Cofree []
15:35:42 <idnar> Coffee []?
15:35:45 <Eduard_Munteanu> :)
15:35:47 <copumpkin> who needs explicit leaves anyway
15:35:49 <mtnviewmark> do you get that a Cofree House?
15:36:13 <Eduard_Munteanu> Free Coffee :)
15:36:14 <xerox> like a skyscraper you can't see the top of
15:36:16 <idnar> I still need to figure out that free/cofree stuff
15:36:19 <mtnviewmark> :info Cofree
15:36:26 <xerox> no :info
15:36:29 <Eduard_Munteanu> It's in category-extras IIRC
15:36:32 <idnar> :i Cofree
15:36:39 <xerox> no :i either
15:36:39 <copumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.2/doc/html/Control-Comonad-Cofree.html makes it quite clear, I think
15:36:44 <idnar> huh
15:36:48 <idnar> @info Cofree
15:36:48 <lambdabot> Cofree
15:36:49 <mtnviewmark>  type Cofree m a = Cofree a (m a)
15:36:51 <mtnviewmark> ?
15:36:54 <xerox> people found it noisy
15:36:55 <mauke> idnar: THERE IS NO @INFO
15:37:02 <copumpkin> mtnviewmark: recursively
15:37:08 <mtnviewmark> ahhhhh
15:37:09 <Eduard_Munteanu> What is it really? A free comodule?
15:37:09 <idnar> mauke: what does @info correct to?
15:37:13 <mtnviewmark> close for my first attempt!
15:37:15 <Berengal> idnar: undo
15:37:20 <idnar> oh, heh
15:37:22 <mauke> @info do { x <- readLn; print x }
15:37:22 <lambdabot> readLn >>= \ x -> print x
15:37:28 <monochrom> Category theorists cannot tell their coffee filter from their cofree ultrafilter.
15:37:29 <idnar> oh well
15:37:30 <copumpkin> Eduard_Munteanu: given a functor, get a comonad for free!
15:37:35 <copumpkin> lol
15:37:36 <Zeiris> Did... hpaste get nabbed by a domain parker, or do I have some kind of virus?
15:37:39 <tomberek> copumpkin: reading through those articles you gave me, and this one:http://haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf  Everything makes a lot more sense now.
15:37:40 <Zeiris> !hpaste
15:37:41 <Eduard_Munteanu> copumpkin, nice :)
15:37:41 * copumpkin needs an ultrafilter
15:37:47 <mauke> Zeiris: the former
15:37:58 <Zeiris> Blaaah. There were two code snippets I was reading on it :(
15:37:58 <Eduard_Munteanu> Heh.
15:38:04 <copumpkin> tomberek: you should thank ddarius :)
15:38:05 * idnar parks his domain around the back
15:38:21 * copumpkin goes and looks for an ultrafilter for his cofree
15:38:30 * mtnviewmark goes back to his mundane, but pretty XHtml work
15:38:39 <Eduard_Munteanu> Math's fun.
15:38:52 <tomberek> he isn't here, but i will when he's back
15:38:55 <copumpkin> :)
15:39:56 <Berengal> Zeiris: http://64.131.71.66/
15:41:17 <Zeiris> Ah, excellent thanks :)
15:41:51 <mm_freak> you say there are too many monads tutorials, but they don't beat the rubik's cube tutorials!
15:42:03 <copumpkin> the rubik monad
15:42:27 <mm_freak> copumpkin: actually there is a rubik's cube group, so you can make it a Monoid instance =)
15:42:41 <Eduard_Munteanu> Hm, do you think my idea of using a comonadic chess board in my chess engine for generating moves is good?
15:45:22 <merehap> I really think harnessing the rubix monad is what is necessary to take haskell to the next level
15:45:52 <c_wraith> rubikT will change the way everyone fails to comprehend monads
15:45:58 <merehap> ha
15:46:07 <idnar> corubik
15:46:08 <mm_freak> hehe
15:46:10 <taruti> how do I write a type like: "foo :: (forall s. S s t -> S s t) -> (t,t)" properly? (where s an universally quantined variable like with ST, but shared for multiple arguments)
15:46:44 <Paczesiowa> taruti: what's wrong with it?
15:46:46 <copumpkin> taruti: what's the problem with it?
15:46:52 <mtnviewmark> http://www.google.com/trends?q=monad%2C+rubik&ctab=0&geo=all&date=all&sort=1
15:47:40 <mauke> it's not multiple arguments there
15:48:55 <taruti> hmm, mispaste
15:50:00 <taruti> "The equation(s) for foo' have two arguments, but its type (forall s. S s t -> S s t) -> (t, t)' has only one"
15:50:48 <taruti> any ideas?
15:50:53 <copumpkin> taruti: hm? you ask for too many parameters?
15:51:13 <copumpkin> taruti: you probably need another parameter?
15:51:37 <mauke> ...
15:51:59 <mauke> foo :: (forall s. S s t, S s t) -> (t, t)
15:52:17 <copumpkin> that's what I mean
15:52:19 <mauke> call as foo (x, y)
15:52:29 <aavogt>           constrainApplicative :: ((x,f y) -> b) -> (x,f y) -> b
15:52:42 <taruti> there is no way to make that curried?
15:52:57 * copumpkin is confused
15:53:24 <aavogt> I had to use such a function (basically id) to eliminate some ambiguous type vars for a TH splice that makes applicative lifting look like normal application
15:53:32 <jeffwheeler> @pl startingWith r a = sumIngredients a [r]
15:53:32 <lambdabot> startingWith = flip sumIngredients . return
15:53:33 <copumpkin> mauke: that requires impredicative polymorphism
15:53:39 <aavogt> well lifting on the second element in the tuple
15:54:14 <mtnviewmark> waaa no tupleSections
15:54:19 <jeffwheeler> @pl startingWith r a = sumIngredients [r] a
15:54:20 <lambdabot> startingWith = sumIngredients . return
15:54:39 <Alpounet> in your opinion guys, what kind of computation abstraction would a neural network fit into ? Arrow, Applicative, Monad, Comonad, ... ?
15:55:26 <tomberek> remember recurrency
15:55:47 <Alpounet> yep
15:55:57 <taruti> ImpredictiveTypes is not enough
15:56:30 <aavogt> well the result is just a function, right?
15:56:42 <Alpounet> yeah
15:57:37 <aavogt> functions are instances of all the classes you mentioned (though I'm not sure about comonad though)
15:57:46 <Alpounet> we need to be able to consider a whole NN and a single neuron as a computation unit, indifferently, even if internally the function of the former would be way more complicated than the latter's.
15:57:47 <aavogt> your question isn't very clear
15:58:10 <Alpounet> thus we need to abstract away this notion of computation over a neural network as well as over a single neuron
15:58:11 <taruti> http://aoi.yi.org/~taruti/T.hs <- fails
15:58:53 <Alpounet> imagine a graph representing a neural network ; we need to be able to reduce "isolated" parts of the graph into a single computation unit, for example.
15:59:19 <monochrom> A neural network is pure functional.
15:59:28 <Alpounet> yeah.
15:59:52 <tomberek> monochrom: there is the matter of state in a neural network as well
16:00:49 <tomberek> monochrom: because the next time you run it with the same input, the last input could still be propagating
16:01:26 <Alpounet> monochrom, we also would like to be able to make a neural network learn without actually rebuilding each time the neural network (it'd be problematic for quite large networks)
16:01:56 <Alpounet> and we're considering having a design letting us have real-time neural networks.
16:02:30 <monochrom> I don't know how to do train-on-the-fly neural network.
16:03:07 <Alpounet> in my opinion, there are two different aspects to consider
16:03:11 <tomberek> Structure-wise: a directed graph sounds correct... but computationally there might be better options
16:03:23 <Alpounet> yeah
16:03:35 <Alpounet> the structural one, and the computational one.
16:06:30 <jeffwheeler> I mentioned this idea about a month ago, and I just published a recipes package: http://github.com/jeffwheeler/Recipes
16:07:02 <mm_freak> there should be a forever_
16:07:15 <jeffwheeler> It contains a parser for a simple DSL, and then represents recipes as a tree. From that, it can generate pretty tables like those on Cooking for Engineers.
16:07:25 <mm_freak> forever_ :: Applicative f => f a -> f ()
16:07:35 <Nafai> jeffwheeler: Nice!
16:08:11 <jeffwheeler> See this page for the table I'm talking about; look underneath the pictures, but before the comments: http://www.cookingforengineers.com/recipe/38/Prime-Rib-or-Standing-Rib-Roast
16:08:38 <jeffwheeler> I think those tables are brilliant; I wish I had come up with them.
16:09:43 <mm_freak> runContT return . (() <$) . forever $ do …
16:09:51 <mm_freak> how can i write this more beautifully?
16:09:54 <mm_freak> any ideas?
16:10:16 <mm_freak> oh well, as a first step, replace 'return' by 'pure' =)
16:10:23 <jeffwheeler> Also, does cabal use -Wall by default? Or, is it necessary to put that in my cabal file?
16:14:02 <idnar> @type forever
16:14:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
16:23:51 <tomberek> monochrom: any ideas for the neural network?
16:24:27 <aavogt> if atomicModifyIORef is enough for my purposes, should I bother using MVars instead of IORefs (in a concurrency situation)?
16:25:21 <mm_freak> aavogt: what's wrong with MVar?
16:25:31 <aavogt> I don't know... is there any difference?
16:25:52 <mm_freak> yes, MVar is safe and made for the job
16:25:55 <mm_freak> IORef is a hack
16:26:08 <aavogt> as in, as long as two sources don't grab the same UID it's fine
16:26:24 <aavogt> which won't be a problem if the IORef can be modified atomically
16:26:45 <mm_freak> MVar can do anything that IORef can do
16:27:09 <MissPiggy> tomberek are you making something with NNs
16:27:10 <MissPiggy> ?
16:28:15 <mm_freak> aavogt: what's your application?
16:29:03 <aavogt> I want to generate unique identifiers for rows being input to a database
16:30:32 <Alpounet> how can I do to add a SSH public key to an existing account on community.haskell.org ?
16:31:22 <aavogt> maybe add to  ~/.ssh/authorized_keys ?
16:31:40 <mm_freak> aavogt: use a generator thread
16:31:45 <Alpounet> aavogt, I was rather asking about how I could upload it to c.h.o
16:32:17 <Alpounet> MissPiggy, yeah, we're totally redesigning HNN (http://haskell.org/haskellwiki/HNN)
16:32:25 <mm_freak> aavogt: do nextID <- newEmptyMVar; forkIO $ mapM_ (putMVar nextID) [1..]
16:32:27 <MissPiggy> what for?
16:33:18 <Alpounet> MissPiggy, 'cause the current version is very simple, and actually too much simple to build complex neural networks (reccurent, real-time, ...) upon it.
16:33:27 <mm_freak> aavogt: then to get the next id, just takeMVar nextID
16:33:38 <MissPiggy> sorry I mean like what can you do with networks ?:)
16:33:48 <MissPiggy> I know it can XOR
16:33:51 <aavogt> is there really a difference between that strategy and incrementing the counter each time I take an ID?
16:34:14 <aavogt> (assuming that the whole operation can be done atomically)
16:34:28 <Alpounet> MissPiggy, it is used for many, many tasks
16:34:35 <Alpounet> financial flow prediction
16:34:39 <mm_freak> aavogt: yes, it's safe in concurrent and parallel environments
16:34:40 <Alpounet> medical diagnosis
16:34:52 <mm_freak> aavogt: the code i've showed you is complete and does everything you need
16:35:00 <Alpounet> plane piloting
16:35:02 <Alpounet> and so on.
16:35:04 <aavogt> so IORefs don't work between multiple threads?
16:35:10 <MissPiggy> oh cool
16:35:20 <mm_freak> aavogt: they do, but you have to guarantee atomicity yourself manually
16:35:36 <mm_freak> IORefs are no concurrency constructs
16:35:42 <Alpounet> MissPiggy, the WP page about Neural Networks may be of interest for you.
16:35:45 <mm_freak> they are made to do imperative programming
16:35:52 <MissPiggy> I've read lots of books on it
16:35:57 <Alpounet> oh
16:36:14 <Alpounet> then you may be interested in joining us ... are you ? :-)
16:36:29 <MissPiggy> well the thing is I'm not very good at haskell
16:36:45 <MissPiggy> but I think I will have a look at this onec there is a new version
16:39:27 <mm_freak> aavogt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16473#a16473
16:39:45 <mm_freak> just use:  generateID <- idGen
16:39:48 <aavogt> hmm, dns doesn't work
16:39:52 <mm_freak> oh, wait
16:39:58 <MissPiggy> and why is NN considered AI?
16:40:19 <dv_> hm?
16:40:33 <dv_> oh yes, there is a distinction between NN and AI
16:40:55 <mm_freak> are there other haskell-capable pasting services?
16:41:08 <Alpounet> MissPiggy, from a philosophical point of view ?
16:41:12 <dv_> though MissPiggy , I dont remember it
16:41:27 <mm_freak> aavogt: http://64.131.71.66/fastcgi/hpaste.fcgi/view?id=16473#a16473
16:41:28 <mauke> mm_freak: codepad.org?
16:41:41 <mm_freak> mauke: thanks
16:41:49 <aavogt> mm_freak: well my point is: if an IORef is enough (to guarantee atomicity for my operations), is it using MVars (which involve more locking)?
16:42:36 <mm_freak> aavogt: ask yourself whether that locking will have an impact on the efficiency of your code
16:42:42 <mm_freak> MVars are very fast for what they do
16:42:58 <mm_freak> my code usually uses a lot of them without breaking down
16:43:29 <aavogt> yeah it won't have an effect here
16:44:24 <mm_freak> then don't even bother asking yourself whether using IORefs is better =)
16:44:40 <mm_freak> you've chosen a safe language after all, and you haven't done that to use unsafe constructs ;)
16:44:52 <sshc> > e
16:44:53 <lambdabot>   e
16:45:30 <dv_> MissPiggy, ah was it that AI proponents want to replicate specific abilities in software, while NN proponents want to model systems using neurons, the neurons being miniscule atomic units?
16:45:52 <sshc> :t e
16:45:53 <lambdabot> Expr
16:46:11 <tomberek> MissPiggy: I actually think Data.Neural might be a good spot for it... but I'm a haskell beginner too and I think we could use all the help we can get
16:46:59 <Ke> neural nets are just universal functions that can be fit to a data set
16:47:06 <Ke> just like polynomials
16:48:29 <Alpounet> it's considered as part of AI techniques/algorithms though.
16:48:42 <MissPiggy> why?
16:49:33 <Ke> it's semantics, why do you care
16:49:39 <tomberek> because they are usually trying to solve problems that are in the realm of AI
16:49:59 <tomberek> Identification, control, etc.
16:50:09 <MissPiggy> okay maybe my questions are to beginner though
16:50:15 <MissPiggy> too*
16:51:13 <tomberek> MissPiggy: usually it is hard to know WHY a neural network works the way it does, so that complexity is seen to be similar to a brain, which is seen as inspiration for many of the models
16:51:59 <MissPiggy> okay
16:52:55 <Alpounet> @index forever
16:52:55 <lambdabot> bzzt
16:53:00 <Alpounet> @hoogle forever
16:53:00 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
17:07:01 <mm_freak> aavogt: i've just benchmarked a bit
17:07:34 <mm_freak> generating a million IDs using a thousand threads takes 5.5 seconds
17:08:50 <mm_freak> aavogt: http://codepad.org/q0iFnUmS ⇐ here is the benchmark code
17:10:35 <mm_freak> interestingly there seems to be a trend here:  the more threads there are, the faster is the code
17:10:57 <mm_freak> generating a million ids with 10000 threads (each of them generating 100 ids) takes only 3.2 seconds
17:19:47 <mm_freak> btw, that 'toEnum' is redundant in the code…  just remove it
17:20:29 <Alpounet> @index zipWIthM_
17:20:29 <lambdabot> bzzt
17:20:36 <Alpounet> @hoogle zipWithM_
17:20:36 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
17:21:35 <McManiaC> how would you realise a simple server-clients-connection in haskells data structure?
17:21:54 <McManiaC> you'd need something like "data Server = Server [Client]; data Client = Client Server"
17:22:20 <mm_freak> McManiaC: startServer :: IO (ServerCommand -> IO ())
17:22:26 <mm_freak> that's what i usually do
17:22:35 <McManiaC> ?
17:22:48 <mm_freak> the server itself uses a Data.Map.Map:  Map Handle ClientInfo
17:23:06 <mm_freak> and it runs in StateT (Map Handle ClientInfo) IO
17:23:34 <McManiaC> what if you get an incoming event from a client? do you run through all elements to get the handle of the server?
17:23:46 <mm_freak> McManiaC: no, there is one thread per client
17:24:50 <McManiaC> ?
17:25:07 <mm_freak> McManiaC: i'll code a simple example
17:26:21 <McManiaC> kay
17:26:55 <McManiaC> what do you put inside the ClientInfo?
17:28:01 <aavogt> mm_freak: thanks
17:29:59 <mm_freak> McManiaC: whatever my application needs, and i've made a mistake
17:30:01 <mm_freak> it's not a Map
17:30:14 <mm_freak> or it may be a Map, depending on the application
17:30:57 <McManiaC> what else is it?
17:35:01 <mm_freak> McManiaC: just a second, i'm writing an example
17:35:10 <McManiaC> kk, sorry :)
17:36:00 <mm_freak> McManiaC: are you new to haskell?
17:36:08 <McManiaC> nope
17:45:18 <mreh> how does arrow syntax get to be so clever
17:45:49 <Berengal> mreh: Is it clever?
17:46:10 <mreh> Berengal: I don't understand it, so I think so
17:46:43 <Berengal> mreh: I don't understand how it desugars either, but I do know how to use (parts of) it
17:47:48 <kmc> it's pretty complicated, compared to do syntax
17:48:24 <Berengal> Yeah. I'm not too big a fan of syntax you can't easily desugar on your own, to be honest
17:48:36 <Berengal> But it does make arrows more useable
17:49:21 <dobblego> arrow syntax?
17:49:31 <kmc> i haven't needed arrows for anything yet
17:50:27 <aavogt> -XArrows
17:50:54 <aavogt> adds a proc keyword and weirdness with    x <- f -< g  -- or some such
17:51:12 <dobblego> ah yeah found it
17:51:56 <mreh> aavogt: oh proc is a keywork, i was just looking at that thinking "wut?"
17:52:40 <monochrom> ha
17:53:14 <sshc> what is the most effecient way to get the greatest key in a Map?
17:53:47 <aavogt> @type M.findMax
17:53:47 <kmc> :t S.findMax . M.keysSet
17:53:48 <lambdabot> forall a a1. M.Map a a1 -> a
17:53:48 <lambdabot> forall k a. M.Map k a -> (k, a)
17:53:56 <sshc> tail . keys $ m -- doesn't seem like the fastet
17:54:21 <sshc> findMax; thanks
17:54:33 <kmc> oh, keysSet is O(n) :/
17:55:04 <monochrom> M.findMax exists
17:55:10 <kmc> yeah
17:55:26 <sshc> I should actually mention that I'm adding a value to a map with key above the max key of the map
17:55:54 <monochrom> Just add after findMax
17:55:56 <aavogt> but should keysSet really be O(n)? I suppose so since all nodes need to discard the values
17:56:23 <Veinor> how fast is 'find the max element of an unsorted set'?
17:56:31 <monochrom> keysSet doesn't quite know you just want the max.
17:56:56 <aavogt> sets are internally sorted Veinor
17:56:59 <Veinor> ah.
17:57:11 <monochrom> But I don't know how lazy is Data.Set.
17:57:43 <Veinor> I think inserting elements one at a time is O(n log n)
17:57:51 <aavogt> > S.member 1 $ S.fromList (1:undefined)
17:57:52 <lambdabot>   * Exception: Prelude.undefined
17:58:02 <aavogt> > S.member 1 $ S.fromAscList (1:undefined)
17:58:03 <lambdabot>   * Exception: Prelude.undefined
17:58:19 <Veinor> because each insertion operation is O(log n) and I'm fairly sure sum [log 1, log 2, log 3... log n] is O(n log n)
17:58:26 <aavogt> Data.Set seems to be quite strict
17:58:27 <monochrom> If lazy enough, subsequent S.findMax may end up merely forcing the spine that leads to the max, and log n.
17:58:54 <Berengal> I'm pretty sure Set is strict
17:58:58 <Berengal> Map too, in the keys
17:59:20 <monochrom> But I'm after the tree nodes.
17:59:31 <Berengal> They're strict in their children
17:59:45 <monochrom> Then that's that.
18:00:10 <Berengal> data Map k a  = Tip
18:00:10 <Berengal>               | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
18:00:26 <Veinor> fromList is O(n log n) anyway, so it doesn't matter that keysSet is O(n) :P
18:01:02 <monochrom> We and our academic asymptoticism.
18:01:26 <kmc> pfft, math in programming? ridiculous
18:01:38 <mm_freak> McManiaC: i've written a very simple chat server
18:04:06 <mm_freak> McManiaC: http://codepad.org/qRHwLu10
18:04:41 <mm_freak> in this case what i called ClientInfo earlier is just the client Handle
18:04:41 <burp> http://hackage.haskell.org/packages/archive/network-fancy/0.1.4/doc/html/Network-Fancy.html#v%3AstreamServer
18:04:44 <burp> also looks nice
18:05:11 <mm_freak> but in real applications it's going to be a record type
18:06:11 <Berengal> Is there something like a zipper-map?
18:07:20 <copumpkin> Berengal: like a zipper on Data.Map?
18:07:25 <Berengal> Yep
18:08:50 <mm_freak> McManiaC: you can safely remove the 'printer' argument to clientManager…  it's not really needed in that code
18:08:54 <Berengal> There have been times when I've wondered something like "What is the third highest less than some value x in this map"?
18:09:02 <Eduard_Munteanu> Any wiki admins here?
18:09:10 <Berengal> highest value*
18:09:31 <copumpkin> Berengal: I thought I'd seen something like that in Data.Map itself
18:09:34 <copumpkin> but I may have been confused
18:10:09 <Berengal> copumpkin: There are some functions, like splitLookup, but they don't provide all the functionality
18:10:53 <Berengal> copumpkin: And if you just implement the missing ones, you'll just have a zipper anyway
18:10:58 <copumpkin> yeah
18:11:06 <Berengal> But leave it to the client to rebuild the map in any reliable fashion
18:12:27 <Eduard_Munteanu> I have an issue regarding the wiki, who could I ask?
18:16:24 <mm_freak> Berengal: (!! 2) . dropWhile ((> 10) . fst) . toDescList
18:18:08 <Berengal> mm_freak: O(n). split is O(log n), and finding the third element lower than the pivot can be done in three steps
18:18:15 <stroan> hmm, anyone have an experience with Alex?
18:18:22 <stroan> any*
18:19:01 <mm_freak> Berengal: i think to*List are lazy functions
18:19:19 <mm_freak> although the dropWhile may take some time
18:19:35 <mm_freak> so split is probably better
18:20:05 <Berengal> mm_freak: They're lazy, but worst case you'd have to evaluate almost the entire list
18:21:21 <Berengal> mm_freak: It's arbitrary which if faster if you use toDescList or toAscList, but one will be as slow as the other's fast
18:22:45 <mm_freak> you could split first, and since toDescList is lazy it should only evaluate exactly three elements
18:22:57 <mm_freak> (!! 2) . toDescList . fst . split 9
18:24:34 <syntaxglitch> Eduard_Munteanu, what's your issue?
18:28:23 <Eduard_Munteanu> Nah, I need to talk in private with one.
18:33:38 <aavogt> does finally actually take arguments in the order here: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Exception.html#v%3Afinally
18:34:26 <aavogt> in Control.Concurrent, it has: orkIO (io `finally` putMVar mvar ())
18:34:50 <EvanCarroll> you know whould be really cool for a bot
18:35:00 <EvanCarroll> to echo the SO questions tagged with haskell using the RSS feed
18:35:24 <aavogt> the mnemonic thing to do is to put the action to run finally last
18:35:30 <aavogt> and that's what the code does
18:35:37 <aavogt> but the documentation says otherwise
18:36:27 <syntaxglitch> EvanCarroll, I have enough trouble getting any reputation answering those as it is, do that and I'll never have a chance :(
18:36:29 <mm_freak> the documentation is correct…  what are you trying to do?
18:36:33 <aavogt> oh, looks like some kind of haddock problem: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/Control-Exception-Base.html#finally
18:37:38 <EvanCarroll> syntaxglitch: I upvote all related and helpfull answers, religiously: http://stackoverflow.com/questions/2125674/what-exactly-does-typesynonyminstances-do
18:37:42 <aavogt> mm_freak: do you see what I mean?
18:38:05 <mm_freak> 'finally x y' runs y and then x
18:38:15 <mm_freak> the type suggest that, too
18:38:31 <harrisonpartch> i wish i could install the packages i want to from cabal. or from darcs repositories, or such.
18:38:37 <aavogt> look at the source link
18:38:46 <harrisonpartch> but often i cannot.
18:39:20 <harrisonpartch> there is some compilatio error or other, or a dependency is unsatisfiable.
18:39:30 <harrisonpartch> compilatioN
18:39:39 <mm_freak> aavogt: ah, you mean because the captions are missing?
18:39:40 <syntaxglitch> EvanCarroll, my problem is I'm always late to the show, usually there's 2-4 answers already and one is accepted
18:39:54 <aavogt> and they are misplaced, mm_freak
18:40:03 <aavogt> well the one that shows up
18:40:05 <mm_freak> aavogt: misplaced?
18:40:22 <mm_freak> aavogt: no, there is one caption missing, but none is misplaced
18:40:30 <aavogt> yeah, in the source, it says: finally :: IO a         -- ^ computation to run first
18:40:39 <aavogt> haddocks: => IO Alpounetcomputation to run afterward (even if an exception was raised)
18:40:53 <mm_freak> huh?!
18:40:54 <aavogt> haddocks: => IO a   computation to run afterward (even if an exception was raised)
18:40:58 <mm_freak> now i'm seeing it
18:40:59 <aavogt> sorry Alpounet
18:41:32 <EvanCarroll> syntaxglitch: you just got the heads up 5 minutes after the post
18:41:35 <EvanCarroll> go answer!!!
18:41:35 <aavogt> I suppose pasting that tab somehow completed your name
18:41:45 <mm_freak> aavogt: i was wrong
18:41:48 <EvanCarroll> syntaxglitch++ #answering my question
18:41:49 <mm_freak> sorry
18:42:17 <mm_freak> hmm
18:42:26 <mm_freak> how can that work?!
18:42:32 <mm_freak> ah, d'oh
18:42:38 <mm_freak> finally rethrows the exception
18:44:40 <Alpounet> np aavogt
18:50:40 <Alpounet> @hoogle (Read a) => String -> Maybe a
18:50:41 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
18:50:41 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
18:50:41 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
18:50:58 <Alpounet> Network.CGI.Protocol ? :/
18:53:43 <mm_freak> > reads "34" :: [(Int, String)]
18:53:44 <lambdabot>   [(34,"")]
18:53:47 <mm_freak> > reads "x34" :: [(Int, String)]
18:53:48 <lambdabot>   []
18:55:31 <mm_freak> > let maybeRead = listToMaybe . map fst . take 1 . reads in maybeRead "32"
18:55:32 <lambdabot>   Nothing
18:55:40 <mm_freak> > let maybeRead = listToMaybe . map fst . take 1 . reads in (maybeRead "32" :: Maybe Int)
18:55:41 <lambdabot>   Just 32
18:55:44 <mm_freak> > let maybeRead = listToMaybe . map fst . take 1 . reads in (maybeRead "x32" :: Maybe Int)
18:55:45 <lambdabot>   Nothing
18:56:33 <mm_freak> hmm
18:56:42 <mm_freak> > let maybeRead = fmap fst . listToMaybe . reads in (maybeRead "x32" :: Maybe Int)
18:56:43 <lambdabot>   Nothing
18:56:46 <mm_freak> > let maybeRead = fmap fst . listToMaybe . reads in (maybeRead "32" :: Maybe Int)
18:56:47 <lambdabot>   Just 32
18:56:49 <mm_freak> there you go
18:56:52 <Alpounet> yep
18:56:57 <Alpounet> saw that here : http://hackage.haskell.org/packages/archive/cgi/3001.1.7.1/doc/html/src/Network-CGI-Protocol.html#maybeRead
19:03:41 <pretsas> What is there in the way of GNU/Linux Desktop Environments written in Haskell?
19:04:06 <xerox> xmonad
19:04:15 <tensorpudding> xmonad is an X11 window manager, that's almost what you asked
19:04:22 <mm_freak> well, almost
19:04:28 <mm_freak> it's not a desktop environment
19:04:36 <Cale> It's the closest thing.
19:04:52 <tensorpudding> none of the desktop environments are written in a single language anyway
19:05:06 <mm_freak> pretsas: to answer your question:  unfortunately haskell still isn't in wide use compared to other languages
19:05:13 <tensorpudding> though the libraries are usually written in C or C++
19:05:34 <tensorpudding> there are GTK bindings for Haskell
19:05:38 <Cale> I'd expect that KDE is forced to be written mostly in C++, due to Qt.
19:05:41 <tensorpudding> there is also wxHaskell
19:05:46 <mm_freak> tensorpudding: GTK bindings are actually not the way to go
19:05:56 <Cale> mm_freak: eh?
19:06:02 <mm_freak> there are some experimental declarative GUI libraries
19:06:19 <Cale> If you're writing a practical program right now, you want Gtk2Hs though.
19:06:27 <Eduard_Munteanu> GTK probably _is_ the way to go if you want something done...
19:06:37 <Eduard_Munteanu> OTOH, I agree that FRP is a really nice idea.
19:06:42 <tensorpudding> what toolkit do the experimental bindings use?
19:06:57 <Cale> If you don't care how long you'll spend doing research while writing your program the right way, then yes, help figure out the right way to do FRP :)
19:07:06 <mm_freak> Cale: right, but that's just because most declarative libraries are experimental yet
19:07:08 <Cale> (and then make it practical :)
19:07:22 <mm_freak> and not very useful really =)
19:07:37 <mm_freak> Eduard_Munteanu: i'm not saying that you shouldn't use GTK
19:07:50 <mm_freak> it's just that you shouldn't interface to it directly in the style of gtk2hs =)
19:08:27 <tensorpudding> what are these bindings called?
19:08:57 <mm_freak> tensorpudding: if you're looking for an adjective, 'imperative' is probably appropriate
19:08:58 <Eduard_Munteanu> tensorpudding, I'm unsure what exactly they use, but look at Grapefruit for example.
19:09:14 <Eduard_Munteanu> if you meant the FRP stuff.
19:09:57 <tensorpudding> i don't know what i want, i'm wondering what these "experimental declarative" bindings mean as far as desktop GUI applications
19:10:26 <mm_freak> tensorpudding: you define GUI elements in a "what they are" fashion instead of "what they do"
19:10:45 <mm_freak> so there are no events, but relationships instead
19:10:55 <Eduard_Munteanu> Grapefruit does some crazy things it looks like control theory to me :)
19:11:02 <Alpounet> there are "bindings"
19:11:07 <Alpounet> between element properties, etc
19:11:19 <mm_freak> think of a excel/openoffice calc spreadsheet…  that's roughly how declarative GUIs work =)
19:11:20 <Alpounet> and transitions from a state to another
19:11:20 <Alpounet> etc
19:11:53 <mm_freak> instead of manipulating cells, you give relationships between them and they update themselves
19:12:29 <Eduard_Munteanu> mm_freak, I could argue it's the same case with Gtk2Hs in some respects, partly due to Gtk stuff being nice.
19:12:33 <tensorpudding> so this isn't a good idea for someone who just wants to write a simple app
19:12:42 <Eduard_Munteanu> I like models/stores in Gtk for example.
19:13:21 <Berengal> It's probably possible to add a layer to gtk2hs that makes it nicer to use without going all the way to FRP
19:13:22 <mm_freak> tensorpudding: it is, as soon as the libraries become practical
19:14:03 <Eduard_Munteanu> tensorpudding, definitely not. Even if you manage to get along with it, it might not be powerful enough.
19:14:19 <Eduard_Munteanu> s/get along/understand/
19:15:08 <harrisonpartch> the nicest OS and GUI ever was Native Oberon. By miles. I do most of my coding in A2 now, an OS also written in Oberon, but a more modern one. But NO was the coolest.
19:15:16 <mm_freak> Eduard_Munteanu: the concept is as powerful as the imperative approach
19:15:20 <mm_freak> it's just that the current libraries are not
19:15:36 <harrisonpartch> But, I want to do a few things in Haskell now.
19:15:37 <Eduard_Munteanu> mm_freak, yeah, I meant the libs, they probably implement very very simple controls.
19:15:40 <harrisonpartch> Mostly graphics.
19:15:58 <tensorpudding> mm_freak: when these libraries are finished, you could use them to easily write a desktop app that would fit in, say, GNOME?
19:16:17 <mm_freak> tensorpudding: probably…  depends on the toolkit used by the library
19:16:24 <Berengal> tensorpudding: That's an implementation detail :P
19:16:37 <Eduard_Munteanu> <rant>I sometimes get the feeling of abandoning wxWidgets completely and forever in favour of Gtk.</>
19:16:54 <mm_freak> GTK is great
19:17:04 <mm_freak> even though its implementation is horrible =)
19:17:07 <mm_freak> i never liked glib
19:17:30 <Eduard_Munteanu> Since I did my last school project in GTK + Haskell, as opposed to wxWidgets + C++, I feel like portability and all the other nice things from wxWidgets aren't worth it.
19:17:47 <tensorpudding> how likely is this FRP graphics library getting done anytime soon?
19:17:51 <Eduard_Munteanu> The switch was definitely worth it.
19:18:00 <mm_freak> tensorpudding: to be honest, don't wait for it
19:18:23 <Berengal> tensorpudding: They're still working out the semantics. Nobody really knows what FRP is yet
19:18:38 <tensorpudding> so basically it's so experimental it doesn't really exist?
19:18:50 <mm_freak> tensorpudding: it exists and works, but it's useless in practice
19:19:01 <Eduard_Munteanu> Yeah, probably Uustalu and Vene will write 20-30 more papers on the maths and definition of FRP before they even start working on usable stuff :)
19:19:02 <Berengal> tensorpudding: Let's just say it has a few bottoms. Don't evaluate it too strictly
19:19:15 <Eduard_Munteanu> tensorpudding, it does exist.
19:19:26 <mm_freak> lol
19:20:18 <Eduard_Munteanu> I wouldn't call it very useless, there seem to be a few semi-useful examples in Grapefruit and others.
19:21:00 <Eduard_Munteanu> In fact, they work and do so well, IIRC.
19:21:16 <Eduard_Munteanu> But don't expect ease of use/programming.
19:21:27 <mreh> Eduard_Munteanu, are you school age?
19:21:57 <Eduard_Munteanu> mreh, depends on what you mean. I'm 21, 3rd year in systems engineering :)
19:22:08 <Eduard_Munteanu> So school is university.
19:22:12 <mreh> gotcha
19:22:38 <Eduard_Munteanu> mreh, but we get to do stupid projects, for the db course and stuff like that.
19:25:06 <Eduard_Munteanu> And Haskell + Gtk2Hs was very nice for doing a project (which we had a deadline of a few months for) and learning some more Haskell in two days :)
19:25:19 <Nafai> Eduard_Munteanu: Nice that you were allowed to use that :)
19:25:36 <mreh> I have to build a GA, can't be arsed, feel like copying the one in hackage
19:25:49 <mreh> but then I'll get busted for "plagarism"
19:26:30 <mreh> at least they let me use haskell, and not the dreaded MATLAB
19:26:50 <Eduard_Munteanu> Nafai, yeah, they didn't care. I presented the project on my laptop. So I chose Haskell, gtk2hs and SQLite. That, I mean, as opposed to MySQL + PHP + WAMP :)
19:27:00 <Nafai> nice!
19:27:04 <Eduard_Munteanu> like 99% else.
19:27:48 <mm_freak> well, don't worry
19:27:58 <mm_freak> knowing haskell makes your code much shorter even in other languages
19:28:06 <mreh> Eduard_Munteanu, did you get many skeptical looks and tuts?
19:28:20 <mm_freak> i've written a monadic parser combinator library in C# in about 150 lines =)
19:28:22 <Eduard_Munteanu> mm_freak, I hear Haskell can cause depression when going back to other langs :)
19:28:30 <mm_freak> Eduard_Munteanu: it does
19:28:41 <mm_freak> really…  it does a lot
19:28:46 <Nafai> Eduard_Munteanu: Indeed.  Made me frustrated with Python at work.
19:29:06 <Eduard_Munteanu> mreh, um yeah, the teacher said "lemme see the code". And he was like "okay, what is this? Nevermind.".
19:29:07 <mreh> let's all set up shop in a big gay software house
19:29:12 <mm_freak> Nafai: actually python is a good language, but by no means reaches haskell's quality
19:29:19 <mm_freak> and i don't like its duck typing
19:29:26 <Eduard_Munteanu> s/he/she/
19:29:34 <Nafai> mm_freak: Python is the most mainstream language that I can tolerate
19:29:42 <mreh> doesn't anyone here try and sell some of their software?
19:29:43 <Nafai> So I've sought jobs programming in it
19:29:56 <Nafai> Starting a job doing C and Python here in a week or so
19:30:42 <mreh> Eduard_Munteanu, "are you sure this is real code?" heh
19:30:46 <mreh> ever had that?
19:30:54 <mm_freak> i used to program in C, but since i started programming in haskell, i find C extremely frustrating even for the simplest tasks
19:31:07 <Eduard_Munteanu> Unfortunately, after getting almost maximum on lab and project, I failed the final exam. We had to write very complicated SQL stuff on paper and I never thought he'd ask for that sort of stuff :(
19:31:50 <Eduard_Munteanu> mreh, lol, not really. They only look very confused after asking "what is this?".
19:32:17 <mreh> Lets all work together!
19:32:18 <Eduard_Munteanu> Like when I join a project group, I do it all myself, but I do it with POSIX-compatible libs :)
19:32:19 <mm_freak> also my code in C tends to get unreadable to the average C programmer
19:32:21 <Berengal> mreh: I had something similar. I wrote a short haskell script for generating some XML at work, and embedded the XML templates in the code. When some of my coworkers saw it they only saw "XML with weird braces and no closing tags"
19:32:48 <mm_freak> void tryOpen(const char *filename, const char *mode, void (*k)(FILE *), void (*error)(const char *));
19:32:49 <Berengal> The interesting generating code was all ninja and hidden
19:32:53 <Eduard_Munteanu> Berengal, lol
19:33:09 <mreh> did you embed XSLT Berengal?
19:33:25 <mreh> that's functional right?
19:33:35 <mm_freak> mreh: declarative, but not really functional
19:33:35 <Eduard_Munteanu> mm_freak, higher order functions? :)
19:33:42 <Eduard_Munteanu> In fact, monads? :)
19:33:56 <mm_freak> Eduard_Munteanu: CPS at least, so yes, higher order =)
19:34:11 <mm_freak> but no monads, because C is not powerful enough to express them in a useful manner
19:34:40 <Eduard_Munteanu> Yeah, it should be a real PITA to do true monads in C methinks.
19:34:56 <mm_freak> not a PITA, but impossible
19:35:12 <kmc> it's not impossible.  you can build closures yourself and do true functional programming
19:35:25 <Berengal> mreh: Can't remember the exact library I used, but it was all just a few simple structures, maps, splices and a parser
19:35:38 <Eduard_Munteanu> Yeah, but it's hard to get powerful static type checking like for Haskell monads.
19:35:38 <mm_freak> kmc: you need polymorphism for real monads (not to be confused with monadic-style coding)
19:35:43 <kmc> you can do polymorphism too
19:35:59 <mreh> can someone explain to me signal functions?
19:36:01 <Berengal> (The parser was for parsing excel-sheets pasted into notepad)
19:36:12 <Eduard_Munteanu> As in yes, you can pretend you do monads, but they're really unsafe.
19:36:12 <mreh> I get the abstract notion of (Time -> a)
19:36:13 <mm_freak> kmc: you can emulate it, but not in the type system
19:36:13 <kmc> mreh, signal functions?
19:36:20 <kmc> oh, FRP?
19:36:22 <mreh> kmc: it's FRP/yampa
19:36:30 <kmc> ah, fun times
19:36:43 <mm_freak> Eduard_Munteanu: you're not using "monads" like you do in haskell
19:36:49 <mreh> kmc: I plan to make games out of this stuff, it's gold
19:36:57 <mm_freak> you're just writing code in a monadic style
19:37:28 <mm_freak> of course you can emulate everything, since both C and haskell are turing-complete
19:38:04 <mm_freak> but turing-completeness is a totally useless measure of language powerfulness
19:38:15 <Eduard_Munteanu> Yeah.
19:38:16 <mm_freak> you can't express monads in C, and that's it
19:38:39 <mreh> KLOC :D
19:38:57 <mm_freak> you can express an interpreter for a language with parametric polymorphism and closures in C
19:39:12 <mm_freak> but then you'll get quite a few lines of C code ;)
19:39:12 <Eduard_Munteanu> Not really, I don't think a Turing-complete Brainfuck would be good.
19:39:27 <Eduard_Munteanu> That would score high on a inverse kloc heuristic.
19:39:28 <mm_freak> Eduard_Munteanu: brainfuck is turing-complete
19:39:45 <Eduard_Munteanu> mm_freak, hm, can it loop? Maybe I don't remember.
19:39:51 <mm_freak> of course
19:39:54 <Eduard_Munteanu> Oh.
19:39:56 <mm_freak> [looping code]
19:40:05 <Eduard_Munteanu> Ah, I remember.
19:41:03 <Eduard_Munteanu> Actually, I think Haskell is more deserving of the name "Brainfuck", at least as far as you can scare n00bs with it :)
19:42:14 <mm_freak> well, i think arrows, type level programming and @pl scare some non-n00bs just as well =)
19:42:58 <Eduard_Munteanu> Heh.
19:43:02 <monochrom> yeah I don't commit type-level programming.
19:43:23 <mreh> what is type-level programming?
19:43:33 <monochrom> I come from formal methods for imperative programming, so just proving data invariants is enough for me.
19:43:43 <Eduard_Munteanu> monochrom, I'm actually disappointed of it that you can't express arbitrary runtime stuff _easily_ using it.
19:43:50 <mm_freak> mreh: http://haskell.org/haskellwiki/Type_arithmetic
19:43:57 <Eduard_Munteanu> mreh, stuff like type arithmetic, for example?
19:44:02 <mm_freak> monochrom: it's actually just type-level prolog
19:44:17 <mm_freak> so if you can program in prolog, you can also write type-level programs
19:44:26 <monochrom> I cannot program in prolog.
19:44:30 <Eduard_Munteanu> :)
19:44:49 * adu <3 prolog
19:45:05 <mm_freak> then learn it (or mercury)…  it's another fascinating language paradigm =)
19:45:17 <Eduard_Munteanu> I tried doing this the other day, it works, but it's rather not straightforward to define a function that takes a value into a type-level representation.
19:45:31 <Eduard_Munteanu> It seems it can only be done using Data.Dynamic or stuff like that.
19:45:56 <monochrom> You can stop evangelizing to me now. For if you continue, I'll just reverse-evangelizing you with formal methods. Proving data invariants is just like comment-level prolog, so if you can program in prolog, you can also write proofs of data invariants.
19:46:21 <mm_freak> hehe
19:46:41 <dolio> Don't learn prolog. Learn a good logic language.
19:46:43 * Eduard_Munteanu wishes for dependent types
19:46:58 <monochrom> Too bad mercury did not exist when I learned prolog.
19:47:09 <mm_freak> Eduard_Munteanu: ditto
19:47:23 <Eduard_Munteanu> They should really try to merge stuff from Agda.
19:47:33 * adu <3 agda
19:47:44 <mm_freak> Eduard_Munteanu: i don't know if i like agda that much
19:47:52 <mm_freak> it tends to get quite verbose
19:48:25 <Eduard_Munteanu> I didn't actually wrote Agda programs, but I read a few and it looks very neat.
19:49:47 <mm_freak> well, its type system enforces termination
19:49:53 <mreh> is "time" stateful in FRP?
19:49:59 <mm_freak> i.e. an agda program cannot loop doing nothing
19:50:16 <mreh> it's like > arr (const 1) >>> integral
19:50:27 <dolio> The type system alone doesn't enforce that.
19:50:32 <mreh> these arrows excite me
19:50:41 <mreh> mmm, pointy
19:50:50 <Eduard_Munteanu> mm_freak, I'm not sure about Agda, but I hear other total languages can do stuff like that using codata/coinduction.
19:51:03 <mreh> can we stop talking about Agda?
19:51:07 <Eduard_Munteanu> :)
19:51:13 <kmc> let's talk about coq
19:51:14 * kmc <3 Coq
19:51:16 <mreh> no
19:51:17 <mm_freak> lol
19:51:31 <mm_freak> dolio: prolog is the only LP language i learned
19:51:32 <Eduard_Munteanu> Why would a bunch of men talk about coq? :P
19:51:37 <mm_freak> what's a good alternative?  mercury?
19:51:45 <mreh> or mercury!
19:51:59 <mreh> take it down -blah alley
19:52:08 <mreh> please :D
19:52:14 <adu> what does ⟦_⟧ mean in Agda?
19:52:19 <dolio> ddarius knows more about good logic languages than I do. Mercury is probably better than prolog. There's also lambda prolog, lolli, ...
19:53:03 <copumpkin> adu: whatever you define it to mean
19:54:18 <adu> woah dude
19:54:31 <copumpkin> ?
19:54:35 <adu> :)
19:54:37 <adu> jk
19:54:47 <xerox> it's a quote from Woodstock (the movie)
19:54:54 <mreh> how does "time" start afresh when you switch into a new signal function with "switch"
19:54:56 <Eduard_Munteanu> sr
19:55:04 <mreh> doesn't it just carry on with the old time value
19:55:06 <copumpkin> xerox knows more about american culture than I do, apparently
19:55:19 <adu> xerox: yes, of course
19:55:45 <copumpkin> :(
19:56:17 <kmc> "woah dude" is a specific quote?
19:56:31 <Eduard_Munteanu> That's what I wonder too.
19:56:52 <monochrom> or perhaps :) is a specific quote
19:57:00 <Eduard_Munteanu> Unless it's like "meh" which I hear was popularized by the Simpsons.
19:57:14 <Eduard_Munteanu> Meh.
19:57:46 <mreh> "we're the MTV generation, we fell neither highs nor lows", "really what's it like", "meh."
19:58:03 <mreh> it was more of a "eh"
19:58:22 <xerox> There's an hippie and someone asks him if he likes to be called freak, and he says he doesn't care, it's a word, it means whatever you define it to mean.
19:58:43 <Eduard_Munteanu> Oh, heh.
19:59:11 <kmc> ah, hippies
20:00:18 <mreh> no it doesn't, it means whatever the person who calls you a freak defines it to mean
20:00:44 <mreh> <_<    >_>
20:00:56 <mreh> what a stupid reason not to care
20:01:00 <monochrom> «_»
20:01:16 <Eduard_Munteanu> I see Kleisli arrow composition in there :P
20:01:23 <mreh> you might as well not care on principle
20:01:25 <Eduard_Munteanu> And bind.
20:01:25 <interferon> i'm looking for a function like groupBy in clojure
20:01:27 <Eduard_Munteanu> Or almost :P
20:01:35 <interferon> it would take a list and a function
20:02:03 <interferon> and return a list of tuples, where each tuple is (the return value of the function, [all the items in the list for which the function returned that value)
20:02:35 <aavogt> then why ask here?
20:02:42 <kmc> looking in Haskell for this function?
20:02:43 <monochrom> heh
20:02:50 <Eduard_Munteanu> s/in/from/ probably
20:03:01 <Eduard_Munteanu> Clojure that is.
20:03:03 <kmc> interferon, did you look at Data.List?
20:03:12 <interferon> i looked
20:03:17 <kmc> it has groupBy, but it doesn't give quite as much information as you want
20:03:22 <interferon> yes, like clojure's groupBy, but in haskell
20:03:31 <interferon> right, the existing groupBy is not quite it
20:03:37 <interferon> but this is a pretty common idiom
20:04:22 <Eduard_Munteanu> Um, you can probably do it with zip and map.
20:04:32 <aavogt> @type groupBy
20:04:33 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
20:04:39 <dmwit> interferon: How long is the output list?
20:04:44 <dmwit> interferon: As long as the input list?
20:04:52 <aavogt> > groupBy (const $ const True) [1..]
20:04:54 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:04:55 <kmc> :t \f -> map (head *** id) . groupBy fst . map (f &&& id)
20:04:56 <lambdabot>     Occurs check: cannot construct the infinite type:
20:04:56 <lambdabot>       a = (a, b) -> Bool
20:04:56 <lambdabot>     Probable cause: `fst' is applied to too many arguments
20:04:57 <interferon> not necessarily.  to give an example:
20:05:06 <Eduard_Munteanu> > zip [1..] $ map (*2) [1..]
20:05:07 <lambdabot>   [(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20),(11,22)...
20:05:21 <adu> > groupBy (const $ const False) [1..]
20:05:22 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17...
20:05:31 <interferon> groupBy category myTransactions => [("food", [tx1, tx2, tx3]), ("taxi", [tx4])]
20:05:33 <adu> woah dude
20:05:43 <aavogt> so the return value is false iff you start a new group
20:05:49 <dmwit> :t Set.fromListWith
20:05:50 <lambdabot> Couldn't find qualified module.
20:05:53 <dmwit> :t S.fromListWith
20:05:54 <kmc> @type  \f -> groupBy ((==) `on` fst) . map (f &&& id)
20:05:54 <lambdabot> Couldn't find qualified module.
20:05:55 <lambdabot> forall a a1. (Eq a) => (a1 -> a) -> [a1] -> [[(a, a1)]]
20:05:59 <dmwit> :t M.fromListWith
20:06:00 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
20:06:03 <dmwit> There we go.
20:06:03 <dolio> > groupBy (\x y -> x + 1 == y) [1..]
20:06:05 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21...
20:06:28 <Eduard_Munteanu> Oh, I got you wrong.
20:06:30 <interferon> is fromListWith for me?
20:06:32 <dmwit> :t \f -> M.fromListWith (++) . map (\k -> (k, [f k]))
20:06:33 <kmc> ah, very nice.  using Map
20:06:33 <lambdabot> forall a t. (Ord a) => (a -> t) -> [a] -> M.Map a [t]
20:06:41 <dmwit> interferon: How about that?
20:07:19 <interferon> dmwit: hmm, let me try
20:07:26 <adu> > groupBy (\x y -> x + 2 == y) [1..]
20:07:27 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17...
20:07:30 <Eduard_Munteanu> You could probably use list comprehensions for that.
20:07:43 <aavogt> > ((map (zip $ True:repeat False) .) . groupBy)  (==) "aaabccd"
20:07:44 <lambdabot>   [[(True,'a'),(False,'a'),(False,'a')],[(True,'b')],[(True,'c'),(False,'c')]...
20:08:05 <aavogt> > ((map (zip $ False:repeat True) .) . groupBy)  (==) "aaabccd"
20:08:07 <lambdabot>   [[(False,'a'),(True,'a'),(True,'a')],[(False,'b')],[(False,'c'),(True,'c')]...
20:08:15 <dmwit> interferon: Sorry, it's backwards.
20:08:18 <dmwit> interferon: I meant this:
20:08:31 <dmwit> :t \f -> M.fromListWith (++) . map (\k -> (f k, [k]))
20:08:32 <lambdabot> forall k a. (Ord k) => (a -> k) -> [a] -> M.Map k [a]
20:08:56 <aavogt> but how useful is this going to be since groupBy doesn't implicitly convert stuff to Bool?
20:08:58 <dmwit> > M.fromListWith (++) . map (\k -> (isUpperCase k, [k])) $ "Hello, World!"
20:08:58 <lambdabot>   Not in scope: `isUpperCase'
20:09:05 <dmwit> > M.fromListWith (++) . map (\k -> (isUpper k, [k])) $ "Hello, World!"
20:09:06 <lambdabot>   fromList [(False,"!dlro ,olle"),(True,"WH")]
20:09:26 <dmwit> funny order =)
20:09:38 <dmwit> > M.fromListWith (flip (++)) . map (\k -> (isUpper k, [k])) $ "Hello, World!"
20:09:39 <lambdabot>   fromList [(False,"ello, orld!"),(True,"HW")]
20:10:08 <dmwit> If you don't mind getting them out in a different order, you can probably make it more efficient with Set instead of [].
20:10:15 <dmwit> :t singleton
20:10:16 <lambdabot> Not in scope: `singleton'
20:10:16 <interferon> i'm a bit overwhelmed :)
20:10:36 <dmwit> interferon: Which bit is overwhelming?
20:10:45 <interferon> many possible solutions
20:10:54 <dmwit> The one you should start with is this:
20:10:55 <kmc> i like this solution using Data.Map
20:11:13 <Eduard_Munteanu> > let f = x+2; r = map f [1..] in map (\t -> (f x, [x | f x = t])) r
20:11:14 <lambdabot>   <no location info>: parse error on input `='
20:11:17 <dmwit> ?let interferon f = M.fromListWith (++) . map (\k -> (f k, [k]))
20:11:18 <lambdabot>  Defined.
20:11:24 <Eduard_Munteanu> > let f = x+2; r = map f [1..] in map (\t -> (f x, [x | f x == t])) r
20:11:26 <lambdabot>   Couldn't match expected type `a -> b'
20:11:26 <lambdabot>         against inferred type `Simple...
20:11:28 <dmwit> interferon: Then complain if that doesn't do what you want. =)
20:11:32 <kmc> interferon, congratulations, you're a function :)
20:11:49 <Eduard_Munteanu> > let f x = x+2; r = map f [1..] in map (\t -> (f x, [x | f x == t])) r
20:11:49 <interferon> :D
20:11:50 <lambdabot>   [(x + 2,[]),(x + 2,[]),(x + 2,[]),(x + 2,[]),(x + 2,[]),(x + 2,[]),(x + 2,[...
20:11:58 <aavogt> > partition odd [1..10]
20:11:59 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
20:12:08 <Eduard_Munteanu> WTF?
20:12:25 <xerox> :t x
20:12:26 <lambdabot> Expr
20:12:30 <interferon> > interferon fst [(1, 2), (1, 3), (2, 4)]
20:12:31 <lambdabot>   fromList [(1,[(1,3),(1,2)]),(2,[(2,4)])]
20:12:33 <dmwit> Eduard_Munteanu: x isn't in scope in your tuple
20:12:37 <interferon> great!
20:12:38 <mm_freak> Eduard_Munteanu: your x in the lambda is not defined
20:12:44 <dmwit> Eduard_Munteanu: Well, it is, but only because lambdabot is doing funny things.
20:12:46 <Eduard_Munteanu> Oh, right.
20:12:48 <mm_freak> so you're using lambdabot's x :: Expr =)
20:12:57 <Eduard_Munteanu> > let f x = x+2; r = map f [1..] in map (\t -> (f t, [x | f x == t])) r
20:12:58 <lambdabot>   [(1 + 2 + 2,[]),(2 + 2 + 2,[]),(3 + 2 + 2,[]),(4 + 2 + 2,[]),(5 + 2 + 2,[])...
20:13:05 <Eduard_Munteanu> Huh?!
20:13:26 <dmwit> Eduard_Munteanu: f isn't defined, either
20:13:28 <Eduard_Munteanu> Anyway, designing groupBy goes like that I think, just don't try it in lambdabot :)
20:13:29 <dmwit> err
20:13:41 <mm_freak> hmm, an empty list comprehension?
20:13:43 <dmwit> Eduard_Munteanu: x still isn't defined =)
20:13:48 <mm_freak> > [ 1 | ]
20:13:49 <Eduard_Munteanu> > let f x = x+2; r = map f [1..] in map (\t -> (f t, [x | x<-[1..], f x == t])) r
20:13:49 <lambdabot>   <no location info>: parse error on input `]'
20:13:52 <mm_freak> > [ 1 | True ]
20:13:53 <lambdabot>   mueval-core: Time limit exceeded
20:13:53 <lambdabot>   [1]
20:14:04 <Eduard_Munteanu> Oh, yeah, I see it.
20:14:08 <mm_freak> huh?!  how does that make sense?
20:14:21 <mm_freak> ah wait
20:14:22 <dmwit> > guard True >> [1] -- mm_freak
20:14:22 <mm_freak> it does
20:14:22 <lambdabot>   [1]
20:14:28 <mm_freak> yes, got it
20:14:37 <interferon> dmwit: thanks a lot
20:14:38 <Veinor> @src guar
20:14:38 <lambdabot> Source not found. I am sorry.
20:14:39 <Veinor> @src guard
20:14:39 <lambdabot> guard True  =  return ()
20:14:39 <lambdabot> guard False =  mzero
20:14:42 <Eduard_Munteanu> > let f x = x+2; r = map f [1..100] in map (\t -> (f t, [x | x<-[1..100], f x == t])) r
20:14:44 <lambdabot>   [(5,[1]),(6,[2]),(7,[3]),(8,[4]),(9,[5]),(10,[6]),(11,[7]),(12,[8]),(13,[9]...
20:14:56 <Eduard_Munteanu> Good, that's it, but it could be better.
20:15:09 <mm_freak> i wonder what MonadPlus is good for…  we should use Alternative
20:15:14 <Eduard_Munteanu> Um, screwed again.
20:15:22 <mm_freak> nicer syntax anyway
20:15:33 <dmwit> I should hack.
20:15:36 <dmwit> I should also sleep.
20:15:38 <dmwit> Hm....
20:15:40 <mm_freak> > pure 1 <|> pure 2 <|> pure 3 :: [Int]
20:15:41 <lambdabot>   [1,2,3]
20:15:53 <mm_freak> dmwit: hack, my friend, hack
20:15:58 <mm_freak> get a cup of coffee
20:16:04 <Eduard_Munteanu> > let f x = x+2 in map (\t -> (f t, [x | x<-[1..100], f x == t])) r
20:16:06 <lambdabot>   Couldn't match expected type `[a]'
20:16:06 <lambdabot>         against inferred type `SimpleRef...
20:16:09 <dmwit> ?index Alternative
20:16:10 <lambdabot> bzzt
20:16:15 <Eduard_Munteanu> > let f x = x+2 in map (\t -> (f t, [x | x<-[1..100], f x == t])) [1..100]
20:16:16 <lambdabot>   [(3,[]),(4,[]),(5,[1]),(6,[2]),(7,[3]),(8,[4]),(9,[5]),(10,[6]),(11,[7]),(1...
20:16:17 <dmwit> mm_freak: I'm not tired.  But I *should* sleep, see...
20:16:35 <Eduard_Munteanu> Bah, I'm getting stupider by the minute.
20:16:37 <mm_freak> dmwit: ah, so you got something to do in the real world tomorrow?
20:16:43 <dmwit> =(
20:16:47 <Gracenotes> that looks brute-force-ish
20:16:57 <mm_freak> Eduard_Munteanu: we have a great Map-based solution =)
20:16:57 <dmwit> Sometimes I wish the real world would go hang for a bit.
20:17:20 <Eduard_Munteanu> mm_freak, yeah, possibly, the list comprehension is a hack.
20:17:40 <mm_freak> i don't like list comprehensions
20:17:41 <Eduard_Munteanu> You can use list comprehensions to solve equations as well, it's very nice to express, but very stupid.
20:18:05 <syntaxglitch> dmwit, real world? doesn't that require the IO monad?
20:18:08 <syntaxglitch> just write pure code instead
20:18:32 <dmwit> =P
20:18:39 <mm_freak> be pure instead
20:18:44 <mm_freak> don't go into the real life
20:18:48 <dmwit> Okay, switching to my hacking workspace.
20:18:49 <Eduard_Munteanu> @quote pure
20:18:49 <lambdabot> jimi_hendrix says: that took longer than it should have, but it feels so pure
20:18:54 <dmwit> I love you guys!  You corrupt me. =)
20:19:14 <Eduard_Munteanu> @quote pure
20:19:15 <lambdabot> jimi_hendrix says: that took longer than it should have, but it feels so pure
20:19:18 <Eduard_Munteanu> Bah.
20:20:13 <mm_freak> is my list monad tragedy still in lambdabot's quotes db?
20:20:15 <Eduard_Munteanu> @faq Can Haskell redeem sins?
20:20:15 <lambdabot> The answer is: Yes! Haskell can do that.
20:20:27 <mm_freak> @quote that is the list monad
20:20:27 <lambdabot> No quotes for this person. Where did you learn to type?
20:20:37 <mm_freak> @quote mm_freak
20:20:37 <lambdabot> No quotes match. I've seen penguins that can type better than that.
20:20:43 <mm_freak> hmm
20:20:46 <mm_freak> =(
20:20:47 <Eduard_Munteanu> @quote Eduard_Munteanu
20:20:47 <lambdabot> No quotes match.
20:20:50 <Eduard_Munteanu> Pfew :)
20:21:21 <syntaxglitch> I don't know about this redeeming sins thing
20:21:28 <syntaxglitch> once you've become impure, I think you're stuck
20:21:58 <Eduard_Munteanu> Yeah, you remain in the HellIO monad forever.
20:21:58 <mm_freak> oh
20:22:03 <dmwit> unsafeRedeemSins -- but the proof of good intentions is left to the reader
20:22:05 <kmc> Jesus is unsafePerformIO
20:22:07 <mm_freak> @quote mm_freak1work
20:22:07 <lambdabot> No quotes match. Do you think like you type?
20:22:07 <kmc> hehe
20:22:11 <mm_freak> hmm
20:22:18 <dmwit> ?quote mm_freak.work
20:22:18 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
20:22:30 <dmwit> Oh, usernames probably don't go by regex, huh.
20:22:30 <mm_freak> <Apocalisp> To be, or not to be, that is the Maybe monad.
20:22:37 <mm_freak> <mm_freak1work> not to be or to be and (not to be or to be and (not to be or to be and …)), that is the list monad
20:22:45 <kmc> hahaha
20:23:08 <Eduard_Munteanu> mm_freak =>> id :P
20:23:18 <mm_freak> not to be, that is the unit monad
20:23:37 * syntaxglitch wonders where the continuation monad fits in
20:23:45 <kmc> witchcraft
20:23:47 <Eduard_Munteanu> That would be cobind ^
20:24:25 <mm_freak> to be later or to be now, that is the continuation monad
20:25:29 <dmwit> Is there a way to say "deriving everything" for newtypes?
20:25:41 <kmc> don't think so
20:25:47 <dmwit> =/
20:25:49 <Gracenotes> usually that's 'type'
20:25:56 <kmc> but you can derive any specific class, in GHC
20:26:02 <mm_freak> dmwit: no, because that would break the standard
20:26:15 <Gracenotes> except with all the extra instance-of-synonym-becomes-instance-of-original
20:26:18 <dmwit> mm_freak: Hm?
20:26:23 <kmc> it'd be an extension, of course
20:26:42 <mm_freak> dmwit: even copying instances explicitly needs -XGeneralizedNewtypeDeriving
20:26:54 <dmwit> I'm fine with extensions.
20:27:08 <kmc> i generally interpret "is there a way" to mean "is there either a standard way or an implemented extension"
20:27:21 <dmwit> I was just wondering if there was a -XAllDerivableTypes or something.
20:27:22 <mm_freak> hmm, good point
20:27:27 <mm_freak> but i still think it's not possible
20:27:32 <kmc> it's not crazy, though
20:27:34 <kmc> you should add it :)
20:27:41 <dmwit> =)
20:27:44 <mm_freak> yeah
20:27:47 <kmc> of course there are a few classes that should not be derived in the newtype-specific way
20:27:54 <kmc> for example Typeable
20:27:58 <dmwit> uh
20:28:03 <kmc> if you defined a class of your own with a similar property, you'd run into trouble
20:28:10 <dmwit> Perhaps I am not the right choice for adding this feature. =P
20:28:32 <Gracenotes> you're not the right choice? sounds serious.
20:28:40 <Gracenotes> unless it's accidentally
20:28:42 <dmwit> "deriving all but Typeable" =P
20:28:46 <mm_freak> what i really miss is the OOP namespace concept
20:28:48 <kmc> one question is, does it derive every class everywhere, or every class in scope over the newtype
20:28:48 * syntaxglitch wonders if something like the module importing syntax would be nice for that
20:28:56 <syntaxglitch> deriving(..)
20:29:17 <kmc> deriving (Typeable) works fine for newtype in GHC; it just makes sure to use the regular Typeable-deriving rather than the newtype-deriving
20:29:38 <Gracenotes> module importation is straightforward about instances.. just register them all
20:29:44 <kmc> deriving (.. hiding Foo)
20:29:52 <mm_freak> kmc: every class in scope makes more sense
20:30:00 <kmc> yeah, and i imagine that'd be easier to implement
20:30:13 <mm_freak> i don't think it makes a difference
20:30:17 <kmc> the newtype-deriving code needs work anyway
20:30:20 <syntaxglitch> kmc, "hiding" doesn't really make much sense here, but creating a new keyword is probably bad too
20:30:30 <mm_freak> it's a matter of hiding/making visible
20:30:36 <syntaxglitch> I guess so
20:30:52 <kmc> yeah
20:31:04 <kmc> but abusing keywords is bad too
20:31:14 <mm_freak> dmwit: what's the point anyway?
20:31:18 <dmwit> Hooray, I'm back to where I started!
20:31:31 <dmwit> mm_freak: Just saves me having to look up all the things this is an instance of and copy them over.
20:31:38 <kmc> dmwit, how about Template Haskell?
20:31:43 <dmwit> How about it?
20:31:49 <kmc> maybe it can help?
20:31:54 <dmwit> Can Template Haskell inspect the instances that are in scope?
20:31:58 <kmc> i'm not sure
20:32:01 <dmwit> Does it matter, now that I've already done it manually?
20:32:01 <kmc> the term would be "reify"
20:32:05 <kmc> probably not :/
20:32:09 <dmwit> =)
20:32:22 <mm_freak> is there anything that's easy to do in TH, but hard in haskell?
20:32:34 <kmc> mm_freak, yes...
20:32:36 <pikhq> Compile-time execution.
20:32:45 <mm_freak> e.g.?
20:32:56 <kmc> compile-time execution
20:32:58 <dmwit> mm_freak: Check out the encoding package.
20:33:05 <kmc> implementing functions which would have dependent types
20:33:11 <kmc> precomputed tables for stuff
20:33:14 <pikhq> TH Brainfuck vs. type-level Brainfuck.
20:33:26 <mm_freak> you can have dependent types using TH?!
20:33:29 <kmc> no
20:33:52 <mm_freak> hmm, ok
20:33:54 <kmc> you can write non-dependently typed metafunctions that output non-dependently typed functions
20:34:00 <dmwit> It uses TH to write the code for encoding/decoding Japanese using a human-readable text file.
20:34:00 <kmc> where the combination together would have dependent type
20:34:03 <kmc> if it were not staged
20:34:13 <pikhq> No. Template Haskell executes at compile-time. That's how you get compile-time execution.
20:34:25 <pikhq> :P
20:34:32 <kmc> a simple example is:   $(get_nth 5) (a,b,c,d,e)
20:34:41 <kmc> to get the nth component of a tuple
20:34:47 <mm_freak> pikhq: wow, that was non-trivial =)
20:34:56 <Eduard_Munteanu> Oh crap, I realize this now...
20:35:01 <kmc> you can't write the get_nth function in one-stage Haskell, since its second argument type depends on the value passed for the first arg
20:35:05 <kmc> that's the definition of dependent types
20:35:16 <Eduard_Munteanu> It seems the first movements in functional programming appeared like 40-50 years ago.
20:35:31 <Eduard_Munteanu> And it's still not popular/known enough.
20:35:34 <kmc> Eduard_Munteanu, at least 74 years ago
20:35:42 <Eduard_Munteanu> Wow.
20:35:51 <kmc> lambda calculus predates electronic computers
20:35:54 <mm_freak> AFAIK the lambda calculus is older than the first computer
20:35:57 <Eduard_Munteanu> kmc, oh, right.
20:36:05 <kmc> and LISP was one of the first languages
20:36:20 <kmc> (though iirc it didn't get first class functions immediately)
20:36:27 <Eduard_Munteanu> Well, Turing et al did a great job thinking about computing at the time they were nowhere close to inventing a practical one :)
20:36:38 <mm_freak> lisp isn't functional by itself
20:36:51 <mm_freak> actually many people argue that e.g. common lisp is an imperative language
20:37:05 <syntaxglitch> combinatory logic dates to the 1920s
20:37:06 <kmc> "functional language" and "imperative language" are not in any way opposites
20:37:07 <pikhq> mm_freak: I'd call it neither.
20:37:08 <kmc> Haskell is both
20:37:17 <elly> I'd like to see a definition of 'functional' that excludes lisp
20:37:24 <pikhq> Lisp is an all-paradigm language.
20:37:25 <Eduard_Munteanu> Shucks, how is this possible? How the hell did COBOL or FORTRAN got so popular?
20:37:36 <Eduard_Munteanu> It makes me sick.
20:37:42 <mm_freak> kmc: of course, but it seems like in practical clisp, you don't do functional programming much
20:37:44 <kmc> they could execute efficiently on ancient machines
20:37:48 <kmc> mm_freak, yeah...
20:37:48 <MissPiggy> um COBOL and FORTRAN are pretty important, historically
20:37:54 <syntaxglitch> Not that combinatory logic is really something you'd want to program in
20:37:58 <Eduard_Munteanu> s/got/get/
20:37:58 <syntaxglitch> But it does predate computers
20:38:13 <Eduard_Munteanu> MissPiggy, yeah, they set a standard for sucking :)
20:38:18 <MissPiggy> no they don't
20:38:25 <kmc> FORTRAN has its appeal
20:38:26 <mm_freak> Eduard_Munteanu: the same way BASIC got popular, a language just as ugly as COBOL/FORTRAN
20:38:37 <kmc> FORTRAN is much easier to optimize and parallelize than C is
20:38:37 <MissPiggy> FORTRAN is in the process of being subsumed btw
20:38:48 <kmc> part of why it's still popular for scientific computing
20:38:55 <pikhq> Eduard_Munteanu: COBOL gets more flack than it deserves. It's just the direct descendent of the first high-level language intended for execution on available computers.
20:39:20 <pikhq> When you consider that, it's easy to see why it did so much poorly: it was completely and utterly unknown how to do anything well.
20:39:20 <mm_freak> i don't think there is any justification for the popularity of COBOL
20:39:23 <kmc> Eduard_Munteanu, if you are contemplating the history of programming languages, you may enjoy: http://www.cowlark.com/2009-11-15-go/
20:39:33 <pikhq> No, there is no justification for its popularity.
20:39:34 <pikhq> None at all.
20:39:40 <Eduard_Munteanu> But still, most widespread languages sucked really really bad... remember AS/400 RPG?
20:39:43 <pikhq> FORTRAN came soon after.
20:39:48 <pikhq> And FORTRAN doesn't *suck*.
20:39:48 <Eduard_Munteanu> kmc, thanks.
20:40:05 <pikhq> It's a bit old and dusty in spots, and it *is* non-functional, but it doesn't *suck*.
20:40:08 <mm_freak> i don't know when BASIC came, but it sucked just like COBOL
20:40:23 <Eduard_Munteanu> FORTRAN might have some advantages, but really, I don't think it's something one should consider in the first place.
20:40:37 <MissPiggy> by Fortress
20:40:47 <mm_freak> Eduard_Munteanu: you may want FORTRAN, if your problem is heavy to compute
20:40:48 <Eduard_Munteanu> Unless you have a prof or two at your univ that can only write that.
20:41:26 <pikhq> Eduard_Munteanu: FORTRAN is useful in many of the same places that C is useful.
20:41:30 <pikhq> However, FORTRAN has saner math.
20:42:01 <kmc> and it's better for compiling to blazing speed numerical code
20:42:04 <Eduard_Munteanu> I'm not sure FORTRAN beats good BLAS stuff written in C _and_ inline asm
20:42:37 <Eduard_Munteanu> In fact I wonder.
20:42:38 <pikhq> FORTRAN is about the same *level* as C, but much easier to optimise.
20:42:53 <mm_freak> i don't think that C has any advantage over FORTRAN
20:43:00 <kmc> C is much better for systems programming
20:43:05 <kmc> FORTRAN is much better for numerical programming
20:43:11 <mm_freak> kmc: why?
20:43:12 <Eduard_Munteanu> Um, I tend to view FORTRAN as more high level.
20:43:15 <MissPiggy> great post kmc :)
20:43:41 <pikhq> Eduard_Munteanu: Nope, maps pretty closely to assembly.
20:44:46 <kmc> FORTRAN prevents you doing some things that make C a bitch to optimize
20:45:12 <mm_freak> i mean, why is C better for systems programming?
20:45:36 <kmc> easier to define structs, work with pointers, etc.
20:45:38 <kmc> that's my understanding
20:45:43 <kmc> i don't know FORTRAN so, ignore me
20:46:05 <mm_freak> i don't know it a lot either
20:46:06 <Polarina> kmc, what things does it prevent you from doing that makes C a bitch to optimize?
20:46:10 <mm_freak> that's why i'm asking =)
20:46:14 <kmc> pointer aliasing
20:46:22 <Polarina> C has pointer aliasing.
20:46:27 <kmc> yes
20:46:27 <pikhq> mm_freak: (short*)0xB8000[x + y*stride] = n;?
20:46:29 <kmc> FORTRAN does not
20:46:31 <Eduard_Munteanu> C99 allows you to specify unaliasable pointers.
20:46:32 <pikhq> Polarina: FORTRAN does not.
20:46:33 <Polarina> o.O
20:46:34 <Eduard_Munteanu> See 'restrict'.
20:46:35 <kmc> therefore, FORTRAN is easier to optimize
20:46:51 <kmc> the strange bit-level pointer stuff that you want for systems programming is precisely what makes it hard for the compiler to make assumptions about your code
20:47:11 <mm_freak> pikhq: isn't that writing to the video memory from DOS times?
20:47:47 <pikhq> mm_freak: No, writing to the video memory using VGA.
20:47:54 <pikhq> Linux still has that in there somewhere.
20:48:00 <Eduard_Munteanu> It probably existed as a pragma way before.
20:48:08 <mm_freak> ok, i've never written anything like that in non-DOS =)
20:48:10 <Eduard_Munteanu> or attributge.
20:48:36 <mm_freak> that's probably because DOS is the only OS where you access hardware directly without any OS watching over it
20:48:50 <kmc> not nearly the only OS
20:49:09 <mm_freak> well, but DOS was about the worst OS i know about
20:49:11 <Eduard_Munteanu> Yeah, the framebuffer is mapped to 0xB8000000
20:49:18 <pikhq> Only OS where direct hardware access was the *norm*.
20:49:56 <Eduard_Munteanu> DOS is just insane considering Unix was way cleaner and better... I don't know why they continued developing and using that crap.
20:50:13 <pikhq> It made sense on the 8086.
20:50:22 <pikhq> And the 286.
20:50:26 <pikhq> No excuse after that.
20:50:26 <kmc> DOS had system calls to avoid direct HW access
20:50:29 <sshc> > 200!
20:50:29 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:50:30 <mm_freak> because bill gates always knew how to sell crap
20:50:33 <kmc> they just didn't extend them to encompass new hardware
20:50:36 <pikhq> Especially since Microsoft had XENIX.
20:50:36 <Eduard_Munteanu> 286 has protected mode.
20:50:37 <sshc> how can I define factorial in Haskell?
20:50:42 <kmc> sshc, :)
20:50:48 <pikhq> kmc: They also sucked.
20:50:53 <pikhq> Eduard_Munteanu: No paging.
20:50:54 <mm_freak> kmc: only for the most trivial I/O
20:50:56 <kmc> ghc does have an extension for postfix operators, iirc
20:51:04 <Eduard_Munteanu> sshc, ana + cata in Uustalu & Vene style :P
20:51:13 <mm_freak> Eduard_Munteanu: 286 has a funny protected mode
20:51:19 <mm_freak> after entering it, you can't leave it
20:51:26 <mm_freak> and you still have only 16 bits registers =)
20:51:27 <Eduard_Munteanu> Um, you can, but it's tricky.
20:51:49 <kmc> 16-bit protected mode
20:51:51 <Eduard_Munteanu> Yeah, 386 is the norm in terms of PE.
20:51:59 <kmc> you can run MINIX in 16-bit protected mode
20:52:01 <sshc> kmc: which extention is that?
20:52:05 <pikhq> mm_freak: You can leave it. ... By restarting the processor.
20:52:06 <kmc> sshc, don't recall
20:52:13 <Eduard_Munteanu> You have to do the triple fault trick to go back to real mode.
20:52:20 <mm_freak> pikhq: i don't call that "leaving" =)
20:52:27 <Eduard_Munteanu> IOW, you really reboot the CPU without losing anything.
20:52:42 <pikhq> mm_freak: Hey, your memory's still intact.
20:52:44 <mm_freak> pikhq: you can end an endless loop by SIGKILL-ing the program, too =)
20:52:54 <Eduard_Munteanu> mm_freak, it actually works fine.
20:53:04 <pikhq> Your CPU just doesn't do much for a bit.
20:53:09 <mm_freak> hmm, how can you reset the processor without rebooting?
20:53:27 <pikhq> Triple fault.
20:53:35 <Eduard_Munteanu> mm_freak, you triple fault and install a special handler in place of the BIOS shadow.
20:53:45 <dmwit> The TI-89 has a command to turn off the CPU until the next interrupt.
20:53:48 <dmwit> real handy for saving battery
20:53:58 <mm_freak> dmwit: x86 has that, too
20:54:00 <Eduard_Munteanu> Um... HLT?
20:54:02 <mm_freak> HLT
20:54:28 <mm_freak> but that's not the way you save power today…  in modern systems, you use ACPI
20:54:29 <dmwit> I'd be very surprised if the TI-89 was the only thing to have this, yes. ^_^
20:54:32 <Eduard_Munteanu> Though it's not actually "turn off"
20:54:48 <Eduard_Munteanu> That's why we still need sane ACPI C/P states.
20:55:20 <kmc> microcontrollers have fun power saving modes
20:55:20 <Eduard_Munteanu> Unless proper hw support is in place (like on laptop CPUs), it will really be in a simple idle state.
20:56:07 <kmc> you can make a microcontroller device which lasts years on a single coin cell waiting for you to press a button
20:56:10 <Eduard_Munteanu> Unfortunately, AMD decided to screw that up and make their so-called C1E state which just sucks.
20:57:16 <Eduard_Munteanu> kmc, yeah, there are many embedded devices which have battery lifetimes equal to shelf life.
20:57:24 <mm_freak> what is an idle state actually?  does the CPU really stop to cycle?
20:57:37 <Eduard_Munteanu> IOW, whether you power it or not, the battery will go dead just as fast.
20:57:54 <kmc> right
20:57:57 <kmc> that's pretty fantastic :)
20:58:23 <Eduard_Munteanu> mm_freak, um yeah. In addition it might also turn off power to some parts.
20:58:56 <pikhq> Man... ldt -1;int 1...
21:05:05 <Eduard_Munteanu> kmc, wow, I wasn't familiar with how Algol looked... At first I thought it was Bash, then C, then sugared Haskell... :)
21:05:54 <Eduard_Munteanu> It looks a lot like C with some bashy idioms, like if/fi
21:06:11 <pikhq> Eduard_Munteanu: The bashy idioms are from Algol.
21:06:22 <Eduard_Munteanu> Yeah, I never knew.
21:06:37 <mtnviewmark> yes, Algol predates C and bash
21:06:46 <Eduard_Munteanu> mtnviewmark, yeah, I know that.
21:07:00 <Eduard_Munteanu> Then the par thing resembled Haskell.
21:07:27 <kmc> the ATmega168 has a mode where all the clocks are disabled, yet it will still wake up on pin change (e.g. button press), or if it sees its address on a serial bus
21:07:36 <kmc> in this mode it uses 100 nanoamperes
21:08:48 <pikhq> The Bourne shell was written by an Algol fan.
21:09:01 <pikhq> Who wrote Algol code in C.
21:09:05 <pikhq> (preprocessor)
21:10:05 <Eduard_Munteanu> kmc, sure, electronics is neat, it's very functional-like :)
21:10:35 <Eduard_Munteanu> Well, it's really really depressing. Why are they inventing lots of similar languages these days?
21:11:03 <Eduard_Munteanu> And it's not like they are inventing some DSLs, no, they aim for general purpose stuff.
21:11:16 <Eduard_Munteanu> Stuff that could be done in something that existed already.
21:11:35 <kmc> well, Go aims to be an evolutionary improvement on C
21:11:44 <kmc> not a fantastic revolutionary paradigm shift
21:11:55 <pikhq> And it's written by the people best-suited to.
21:12:01 <kmc> and while it's unsuitable for some things you'd use C for
21:12:12 <kmc> it's also suitable for a lot of things you might otherwise have to use Java for
21:12:19 <Eduard_Munteanu> pikhq, why?
21:12:28 <kmc> it's an interesting niche, and might become popular, but it's not so interesting theoretically
21:12:36 <kmc> and they got some of the theory just unambiguously wrong
21:12:37 <pikhq> ... Rob Pike and Ken Thompson?
21:13:01 <kmc> like totally punting, yet again, on parametric polymorphism
21:13:02 <tensorpudding> they should write an OS in it
21:13:18 <Eduard_Munteanu> Well, see, I don't really like this. I'd ditch Java and come up with a good bytecode spec. Then if you want stuff to be portable, you just target your compiler for the Java CPU.
21:13:27 <tensorpudding> because they've probably written more OS from scratch than most people
21:13:42 <pikhq> I'd imagine they intend to.
21:13:50 <kmc> Eduard_Munteanu, this is what Microsoft has tried to do
21:13:55 <tensorpudding> eh
21:14:03 <Eduard_Munteanu> kmc, oh, with _*_.NET
21:14:04 <tensorpudding> plan9 is dead
21:14:07 <kmc> you could use JVM itself, and a number of newer languages do, including several functional languages
21:14:12 <pikhq> They've definitely done more serious OS development than most anyone else.
21:14:15 <pikhq> *cough*UNIX*cough*
21:14:15 <kmc> but JVM has some issues for implementing functional languages
21:14:36 <copumpkin> maybe not as of 1.7
21:14:56 <Eduard_Munteanu> kmc, well CPUs also have some issues as far as functional is concerned.
21:14:58 <tensorpudding> actually, if given the chance they'd probably just write an evolutionary UNIX
21:15:06 <tensorpudding> which was kind of what Plan 9 was
21:15:14 <kmc> Eduard_Munteanu, yes
21:15:37 <pikhq> tensorpudding: Not just "kind of"...
21:15:45 <pikhq> That is, in fact, more UNIX than UNIX.
21:15:55 <tensorpudding> though Go has some power that C lacks, which might make some interesting new paradigms in system programming more useful
21:15:59 <kmc> LLVM is a pretty good bytecode / portable assembly language, but it mandates nothing in terms of source-level foreign call semantics, or a common managed environment
21:16:05 <kmc> both of which .NET does
21:16:36 <Eduard_Munteanu> Okay, will look more closely at Go but I really can't tell why those two fellows would go about developing that sort of stuff.
21:17:01 <pikhq> Eduard_Munteanu: ...
21:17:24 <pikhq> You may know them for such other works as "UNIX" and "Plan 9". And Ken Thompson is responsible for this little language called "C".
21:17:27 <tensorpudding> plan9 has something that unix lacks, that i liked
21:17:42 <Eduard_Munteanu> pikhq, um, nah, it's probably some PHDD
21:17:46 <tensorpudding> also, rio and acme
21:17:50 <Eduard_Munteanu> Post-Haskell Depression Disorder
21:18:33 <Eduard_Munteanu> pikhq, yeah... And that's why I wonder why there's nothing really revolutionary, nor really pragmatic in Go at a first look.
21:18:56 <Eduard_Munteanu> The market is teeming with C-like languages.
21:18:58 <kmc> at least it has first class functions
21:18:59 <jrockway> i think Go is basically trying to be C++
21:19:01 <Eduard_Munteanu> GC or not.
21:19:06 <pikhq> Eduard_Munteanu: ... They really didn't do "revolutionary" until Plan 9.
21:19:09 <jrockway> C++ was a nice idea in 1980
21:19:12 <kmc> there is no excuse for a new general purpose language design without first class functions
21:19:13 <jrockway> but it's not 1980 anymore
21:19:18 <pikhq> Otherwise, it's been "make something that doesn't suck".
21:19:31 <kmc> lacking an obvious feature that's been around for the better part of a century is not a "paradigm"
21:19:35 <pikhq> In this case, "Let's make a C++ that doesn't suck."
21:19:45 <kmc> both C and Go are a fraction the size of C++
21:19:50 <tensorpudding> why do people want to make a language that is like C
21:19:52 <Eduard_Munteanu> Yeah, I like how Mutt is advertised, to mention it: "All mail clients suck. This one just sucks less" :)
21:19:57 <kmc> C++ is a huge set of unrelated (and poorly-interacting) extensions to C
21:20:07 <kmc> Go does not aim to replicate each extension
21:20:14 <pikhq> tensorpudding: Actually, very few of them are actually like C.
21:20:15 <mm_freak> tensorpudding: they are used to the syntax
21:20:21 <jrockway> i like C++ a lot, actually
21:20:27 <jrockway> because it gave me a reason to use Haskell for work :)
21:20:27 <kmc> ugh
21:20:30 <Eduard_Munteanu> C++0x will have some neat stuff I hear.
21:20:36 <pikhq> C is a small language with rather simple semantics based around a heap and a stack, and pointer manipulation.
21:20:36 <Eduard_Munteanu> or has, I'm not really up to date.
21:20:38 <jrockway> no, they took all the good stuff out
21:20:41 <kmc> like type inference and lambda expressions!
21:20:43 <kmc> how novel
21:20:48 <jrockway> "type inference"
21:20:56 <jrockway> var foo = 42; # int
21:20:58 <kmc> except it's C++, so you have to manually memory manage your closure objects, of course
21:20:59 <mm_freak> kmc: they didn't feel unrelated and poorly interacting…  it's just that C was not the right language to base them on
21:21:02 <jrockway> var foo = 42d; # double
21:21:05 <jrockway> wow, how did it ever guess!
21:21:21 <kmc> mm_freak, it's true, much of the headache comes from having C "compatibility" instead of just a decent FFI as any other language has
21:21:31 <mm_freak> yeah
21:21:33 <pikhq> Very few other languages can even be said to be "small" these days.
21:21:35 <Eduard_Munteanu> kmc, I guess that's not a problem as long as you can turn on/off a GC.
21:21:43 <kmc> not sure you can
21:21:57 <Eduard_Munteanu> kmc, for instance, Boehm works on pure C code.
21:21:58 <mm_freak> still a lot of people love C
21:22:00 <kmc> i don't know if C++1x mandates the optional provision of an exact garbage collector
21:22:06 <kmc> Boehm is a hack
21:22:11 <Eduard_Munteanu> Yeah.
21:22:12 <kmc> conservative collection, bah
21:22:12 <pikhq> Eduard_Munteanu: Boehm GC is a major hack.
21:22:13 <Eduard_Munteanu> It is.
21:22:17 <kmc> let's just guess about everything
21:22:20 <pikhq> It works quite well for all that, but... Yeah.
21:22:25 <jrockway> it is an awesome hack though :)
21:22:29 <mm_freak> even if their problems can be solved much more easily in more modern languages (not necessarily haskell, but at least modern languages)
21:22:36 <jrockway> just don't have any data that looks like pointers
21:22:41 <kmc> it's essential to know C
21:22:45 <kmc> and it's deserving of love
21:23:09 <mm_freak> C people often confuse responsibility with control
21:23:21 <pikhq> Exact garbage collection of C would be an astounding thing to see.
21:23:21 <Eduard_Munteanu> I'm mainly a C coder.
21:23:23 <mm_freak> they love the responsibility they have over resources and call that "control"
21:23:28 <mm_freak> yes, it's control you don't need
21:23:32 <kmc> C is close to one particular ideal in the design of languages
21:23:41 <kmc> and this makes it very suitable for some particular tasks
21:23:51 <jrockway> when people are criticizing Haskell, they always say things like "i never want my compiler to tell me I can't do something", which is why they use C
21:23:59 <jrockway> but ... I *always* want my compiler to tell me I can't do something
21:24:04 <jrockway> the sooner I find out I'm an idiot, the better
21:24:14 <dmwit> There are 41 packages needed to support this package.  I stand on the shoulders of giants.
21:24:17 <mm_freak> jrockway: well stated =)
21:24:30 <pikhq> "I never want my compiler to tell me I can't do something"? Sounds like the C++ ideal. Except the compiler whines anyways.
21:24:56 <kmc> C++ is a great language if you care deeply about performance, yet you refuse to measure it
21:25:05 <jrockway> you know what's sad though
21:25:08 <pikhq> "I want to overload casting!"
21:25:13 <kmc> because there is all this theory about how C++ should be super fast because the compilers are super smart
21:25:17 <mm_freak> C++ compilers seldomly give useful error messages except on trivial typing errors
21:25:19 <kmc> and they just aren't
21:25:19 <jrockway> i was reading an article in CACM today proposing that all CS classes go back to C++
21:25:23 <mm_freak> "typing" as in using the keyboard
21:25:25 <jrockway> because "it's what the game industry wants"
21:25:27 <Eduard_Munteanu> -Wall sounds like a pesky wife... "You really shouldn't do that, Peter".
21:25:41 <pikhq> template <typename T> operator T(); // This is a REAL FUNCTION DECLARATION.
21:25:52 <kmc> pikhq, hahaha
21:25:54 <kmc> cast to ANYTHING!
21:26:13 <Eduard_Munteanu> jrockway, o'rly, the guys in CS here do Haskell in a course.
21:26:19 <mm_freak> hmm
21:26:27 <Eduard_Munteanu> And Lisp and Prolog.
21:26:28 <pikhq> kmc: Implemented in terms of template <typename T> operator T*();, it has some *vague* meaning.
21:26:30 <mm_freak> C++ with C# syntax would be an enhancement
21:26:40 <mm_freak> or just use D =)
21:26:46 <Eduard_Munteanu> pikhq, heh
21:26:53 <kmc> mm_freak, why not just use C#?
21:26:57 <kmc> possibly with a native-code compiler
21:27:00 <pikhq> That meaning being, of course, "screw the type system entirely".
21:27:22 <pikhq> mm_freak: C++ without all the extra syntax and semantics would be an enhancement.
21:27:27 <Eduard_Munteanu> Oleg has an article on C++ OO vs functional OO.
21:27:31 <mm_freak> kmc: yes, a native code compiler together with a bunch of _useful_ libraries
21:27:33 <kmc> pikhq, right, it's C++, you've got to screw the type system before it screws you
21:27:38 <kmc> pikhq, ;)
21:27:41 <pikhq> kmc: Quite.
21:27:41 <Eduard_Munteanu> or perhaps not OO, but things OO-ish you get in Haskell.
21:28:03 <kmc> C++ OO versus every sane language OO
21:28:07 <mm_freak> pikhq: C# has quite a nice syntax compared to C++
21:28:25 <mm_freak> even with functional elements like lambdas
21:28:33 <pikhq> mm_freak: Why yes, yes it does. It's almost impossible to *not* improve on C++, in fact.
21:28:40 <pikhq> Hell, Perl syntax is an improvement.
21:28:42 <mm_freak> indeed
21:28:57 <kmc> pikhq, Microsoft Managed Extensions for C++
21:29:00 <pikhq> At least all the extra syntax is *useful*.
21:29:02 <kmc> i rest my case
21:29:04 <mm_freak> i think even unlambda is easier to read
21:29:04 <Eduard_Munteanu> Nooo.
21:29:08 <kmc> C# seems like a fine language honestly
21:29:17 <monochrom> Did some troll played with you folks again?
21:29:27 <Eduard_Munteanu> .NET is okay, but MS keeps screwing up with proprietary extensions.
21:29:52 <mm_freak> Eduard_Munteanu: have you written anything but a GUI in .NET?
21:29:58 <pikhq> kmc: C# is not a very astounding language, but it doesn't appear to do anything too poorly.
21:30:06 <jrockway> it is a better Java than Java
21:30:10 <kmc> yes
21:30:13 <dmwit> foldr (/=) False -- ugh, what was I thinking when I wrote this code!
21:30:16 <mm_freak> i've written a server program…  it feels like having NO enhancement over C stdlib
21:30:18 <pikhq> jrockway: Yeah, pretty much.
21:30:23 <Eduard_Munteanu> mm_freak, actually, I didn't write any C#, I don't know it. I talk from a side perspective.
21:30:24 <kmc> it has the Java property that it shrinks the gap between great and mediocre programmers
21:30:27 <jrockway> which is a quite useful role
21:30:28 <mm_freak> you even do the network buffering yourself!
21:30:31 <mm_freak> in .NET, that is
21:30:33 <kmc> it prevents the mediocre programmers from doing too much damage
21:30:41 <monochrom> dmwit: That's xor. Example: foldr False [True,True,False]
21:30:45 <kmc> and prevents the great ones from getting too carried away
21:30:46 <jrockway> there is always that set of developers that wants "a career" rather than to create excellent software
21:30:54 <kmc> (the truly bad programmers will always be able to cause immense damage)
21:30:55 <monochrom> err, foldr (/=) False [True,True,False]
21:30:56 <jrockway> and at least C# pushes them closer to "excellent software" than java will
21:31:00 <Eduard_Munteanu> mm_freak, I mean it's okayish as far as the .NET stuff goes, not C#.
21:31:08 <jrockway> (not that anything M$ is excellent, but their language research stuff is not terrible)
21:31:14 <dmwit> :t xor
21:31:14 <lambdabot> forall a. (Bits a) => a -> a -> a
21:31:15 <kmc> languages like C# and Java are necessary for businesses to be able to build boring software as a repeatable process
21:31:16 <mm_freak> Eduard_Munteanu: C# is fine, but .NET is total crap
21:31:19 <dmwit> monochrom: liar!
21:31:21 <jrockway> exactly
21:31:24 <dmwit> > xor [True, True, False]
21:31:25 <lambdabot>   No instance for (Data.Bits.Bits [GHC.Bool.Bool])
21:31:25 <lambdabot>    arising from a use of `...
21:31:27 <pikhq> jrockway: I suspect they're trying to make up for their Win32 sins.
21:31:39 <jrockway> it's going to take a lot more F#s to do that :)
21:31:41 <monochrom> > foldr (/=) False [True,True,False]
21:31:43 <lambdabot>   False
21:31:51 <dmwit> monochrom: (And yeah, I know how it behaves... but it took me a while to figure it out.)
21:32:01 <Eduard_Munteanu> mm_freak, which is probably why I still wish there was a serious virtual machine specification.
21:32:08 <mm_freak> > foldl1 xor [True, True, False]
21:32:09 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
21:32:10 <lambdabot>    arising from a use of `Da...
21:32:12 <Eduard_Munteanu> One that's decoupled from hardware and language.
21:32:16 <mm_freak> oh
21:32:40 <mm_freak> Eduard_Munteanu: actually the .NET VM is fine for what it does, too
21:32:44 <Eduard_Munteanu> This should be the eleventh commandment: "Though shalt not design a vm spec in concert with a language"
21:32:46 <mm_freak> it's the libraries that suck
21:33:01 <Alpounet> and the mentality around .NET.
21:33:04 <Eduard_Munteanu> *Thou
21:33:07 <mm_freak> just a bunch of unrelated tools with no means of integration/composition thrown in a toolbox
21:33:10 <Eduard_Munteanu> crap, I'm tired :)
21:33:13 <mm_freak> and the tools aren't very good either
21:33:17 <jrockway> Eduard_Munteanu: very good point, though
21:34:14 <Eduard_Munteanu> mm_freak, well it's probably not much of a concern for what I mean. Sure you need a way to abstract hardware, but apart from that it shouldn't tie you to specific functionality.
21:34:27 <monochrom> We need to gather statistics on Mean Time Between C++
21:34:28 <Eduard_Munteanu> It's a VM. It should not be easy to read/interpret/use by a human.
21:34:59 <mm_freak> however, it gets usable with F#
21:35:06 <monochrom> Then we can have a Monochrom's Law.
21:35:25 <mm_freak> actually with F# microsoft managed to come up with a useful functional language
21:35:30 <kmc> hehe
21:35:31 <Eduard_Munteanu> I'm going to research a bit more on .NET, but Sun really botched it with Java tying all that class/types/Java-crap to the VM.
21:35:37 <monochrom> "Mean Time Between C++ in a haskell channel is 23 hours" or something.
21:35:46 <kmc> is it less or greater than the mean time between xkcd reference
21:35:46 <monochrom> Maybe 8 hours.
21:35:50 <mm_freak> interestingly it looks like haskell, has ADTs, even syntax sugar for monad
21:35:53 <mm_freak> but it's strict
21:35:59 <pikhq> monochrom: It's definitely the typelevel computation that does it.
21:36:00 <pikhq> :P
21:36:08 <Eduard_Munteanu> mm_freak, probably SPJ had to provide some justification he was getting paid by MS :)
21:36:21 <mm_freak> Eduard_Munteanu: probably =)
21:36:29 <kmc> i've heard that the problem with F# is that the ML and .NET types live in their separate worlds
21:36:35 <mm_freak> but as usual microsoft invented a new language along the way ;)
21:36:41 <mm_freak> they call closures 'delegates'
21:36:53 <mm_freak> and monadic computations are called 'computation expressions'
21:37:01 <kmc> i thought they were "workflows"
21:37:07 <mm_freak> kmc: they do
21:37:13 <Eduard_Munteanu> Heh.
21:37:14 <danderson> um, hpaste.org expired?
21:37:16 <solrize> lol
21:37:17 <kmc> you can indeed integrate OO and statically typed functional programming, but it's probably harder when you're working towards a preexisting object model from other languages
21:37:19 <mm_freak> F# provides a few things .NET doesn't provide
21:37:36 <danderson> I'm getting a godaddy parking page.
21:37:51 <mm_freak> kmc: 'workflows' is an alternative term, but 'computation expression' is more common
21:37:52 * copumpkin gives danderson a ticket
21:38:05 <kmc> mm_freak, ah
21:38:07 <danderson> yay.
21:38:13 <mm_freak> kmc: they talk about 'workflows' mainly in the context of 'asynchronous workflows'
21:38:27 <danderson> I guess I meant to say: is this just this hotel's internet connection messing with me, and if not, anything I can help with?
21:38:33 <mm_freak> a specific…  uhm…  "F# monad"
21:38:34 <jrockway> danderson: i see the same thing
21:38:36 <kmc> danderson, i get the same thing
21:38:55 <solrize> @quote drmaciver
21:38:55 <lambdabot> No quotes match. :(
21:38:58 <solrize> damn
21:39:07 <monochrom> @quote drmciver
21:39:08 <lambdabot> No quotes match. Are you on drugs?
21:39:09 <solrize> @remember DRMacIver: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprise variant functors. Commutative UML diagrams.
21:39:09 <lambdabot> Okay.
21:39:13 <mm_freak> you can use the IP address of hpaste.org instead:  64.131.71.66
21:39:17 <solrize> http://sequence.complete.org/node?page=7 from there
21:39:29 <Eduard_Munteanu> Is there anythink Haskell.NET?
21:39:36 <mm_freak> but you can also use codepad.org or http://paste.pocoo.org/
21:39:56 <Eduard_Munteanu> s/think/thing/
21:40:18 <mm_freak> Eduard_Munteanu: i don't know what it is, but there is http://hackage.haskell.org/package/hs-dotnet
21:40:58 <danderson> mm_freak: yup. I'm also poking bos, since he apparently owns the domain.
21:40:58 <tomoj> F# is sort of an attempt at Haskell.NET, I think, right?
21:41:06 <tomoj> except not really haskell
21:41:06 <kmc> not really
21:41:09 <jrockway> ML.net
21:41:13 <kmc> F# is descended from ML, not Haskell
21:41:17 <kmc> also we were just talking about it ;)
21:41:20 <Eduard_Munteanu> Hm, it isn't really what I was looking for.
21:41:21 <copumpkin> F# is ocaml with moar stuffz
21:41:26 <tomoj> oh
21:41:32 <tomoj> I was watching the haskell lectures at channel9
21:41:40 <aavogt> but haskell is somewhat influenced by ML though?
21:41:41 <Eduard_Munteanu> I wondered if there was any Haskell to .NET compiler (that is, non-native code)
21:41:43 <tomoj> that guy loves haskell and I guess works on F#
21:41:47 <mm_freak> tomoj: F# is based on ocaml
21:41:58 <tomoj> yeah I believe you
21:41:58 <mm_freak> but it looks and feels a lot like haskell
21:42:11 <tomoj> ah
21:42:13 <kmc> Eduard_Munteanu, not to my knowledge.  there have been attempts to make Haskell *interoperate* with .NET languages
21:42:26 <Eduard_Munteanu> Ah no.
21:42:32 <mm_freak> interestingly the people working on F# don't seem to have much of a clue on language design
21:42:38 <kmc> yeah that's the hs-dotnet i think
21:42:42 <Eduard_Munteanu> Actually, Haskell is a good candidate for vm-isation
21:42:46 <mm_freak> example:  F# features currying just like haskell
21:42:49 <mm_freak> you write f x y z
21:43:03 <kmc> is that not standard to ML?
21:43:10 <mm_freak> but to define a "monad" (a computation expresssion class), you define a function Bind
21:43:16 <mm_freak> that function takes a tuple!
21:43:25 <mm_freak> not two parameters, but a tuple
21:43:25 <jrockway> doesn't that fall out from implementing functions properly? ("currying"?)
21:43:29 <kmc> ah, i see
21:43:43 <kmc> ML also has a similar problem, or at least OCaml does
21:43:47 <jrockway> (f x y === f x = \y -> ...)
21:43:48 <kmc> that constructor arguments are not curried
21:43:50 <monochrom> That is still the prevalent style in ML communities.
21:43:53 <kmc> and indeed constructors are not first class functions
21:44:06 <mm_freak> i found that many functions in F# take tuples instead of multiple parameters
21:44:21 <aavogt> @hogle (a,b)
21:44:22 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
21:44:22 <lambdabot> Data.Map findMin :: Map k a -> (k, a)
21:44:22 <lambdabot> Control.Monad.Writer.Lazy runWriter :: Writer w a -> (a, w)
21:44:23 <pikhq> mm_freak: That's just silly.
21:44:25 <path[l]> crap I missed the fortran discussion
21:44:29 <aavogt> @hogle (a,b) -> c
21:44:30 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
21:44:30 <mm_freak> pikhq: yes
21:44:30 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
21:44:30 <lambdabot> Prelude snd :: (a, b) -> b
21:44:33 <mm_freak> welcome to F# =)
21:44:36 <tomoj> in one of the haskell lectures he wants zip to take a tuple of lists
21:44:43 <path[l]> I too wanted to say fortran should die. it isnt even as fast as C anymore, whats the point
21:44:47 <monochrom> Just like Haskell, ML let's you convert operators to functions and vice versa. Unlike haskell, ML converts via tupling.
21:44:49 <jrockway> tomoj: !!
21:44:52 <jrockway> wow
21:44:54 <tomoj> because then the type is ([a],[b]) -> [(a,b)]
21:44:56 <stoop> @hoogle (a,b)
21:44:56 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
21:44:56 <lambdabot> Data.Map findMin :: Map k a -> (k, a)
21:44:56 <lambdabot> Control.Monad.Writer.Lazy runWriter :: Writer w a -> (a, w)
21:45:01 <tomoj> which is kinda cool, but stupid
21:45:01 <Eduard_Munteanu> tomoj, Channel 9? Is that TV or something?
21:45:06 <stoop> aavogt, what's the difference between @hoogle and @hogle?
21:45:09 <tomoj> it's a microsoft thing
21:45:15 <tomoj> but the haskell lectures are pretty good
21:45:19 <Eduard_Munteanu> Oh, I thought there was Haskell on TV.
21:45:24 <tomoj> if you ignore the C#/VB stuff
21:45:25 <Eduard_Munteanu> Would've been pretty cool.
21:45:34 <danderson> oh, never mind. According to whois, hpaste was renewed today. I guess the DNS just hasn't propagated yet.
21:45:35 <Saizan> stoop: none, lambdabot autocorrects up to an edit distance of 2
21:45:37 <Eduard_Munteanu> VB... Booooo, shooo..
21:45:40 <aavogt> stoop: they're about the same
21:45:56 <Eduard_Munteanu> Levenshtein?
21:45:58 <tomoj> http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/
21:46:05 <Eduard_Munteanu> tomoj, thanks, will take a look.
21:46:15 <tomoj> starts pretty slowly
21:46:31 <tomoj> he takes a lot of diversions to explain why certain things are beautiful
21:46:44 <stoop> Saizan, I see.
21:47:03 <danderson> so, coming back to the question I came here for in the first place: http://64.131.71.66/fastcgi/hpaste.fcgi/view?id=16474#a16474
21:47:18 <stoop> @typa 2
21:47:19 <lambdabot> forall t. (Num t) => t
21:47:21 <Eduard_Munteanu> Something like a week ago, hpaste was dead for a few days.
21:47:23 <mm_freak> well, the designers of F# also knew that monads are powerful, but looking at computation expression syntax, they related them to IO control constructs
21:47:27 <danderson> Looks like I have monadic multiple identity disorder. Which library should I be getting rid of?
21:47:36 <mm_freak> that's why you write:  do! something
21:47:50 <mm_freak> and:  let! x = someComputation
21:47:53 <Eduard_Munteanu> danderson, join, rinse and repeat :P
21:48:01 <path[l]> question. is there a way to automagically build a monadtransformer out of a monad?
21:48:07 <kmc> danderson, maybe you should use a package-qualified import
21:48:09 <kmc> (GHC extension)
21:48:10 <kmc> path[l], no
21:48:13 <mm_freak> path[l]: no, but the other way around
21:48:30 <mm_freak> path[l]: if you want to do it properly, define a monad transformer and the corresponding monad from it
21:48:34 <path[l]> ah I see.
21:48:36 <kmc> danderson, otherwise, use ghc-pkg to hide one of them
21:48:39 <kmc> mtl is more standard
21:48:43 <kmc> but transformers is better?
21:48:51 <danderson> it is?
21:48:55 <path[l]> so is every monad built as a transformer around the identity monad?
21:48:59 * monochrom applies excluded middle again.
21:49:00 <Saizan> i don't see any advantage in transformer
21:49:05 <Saizan> *transformers
21:49:08 <danderson> I've seen mtl here and there, but I don't know how transformers got there
21:49:09 <mm_freak> kmc: it's not better in terms of functionality, but it has saner argument order
21:49:22 <mm_freak> kmc: MonadLib is really better than both mtl and transformers
21:49:26 <Eduard_Munteanu> Well, it's cool to say your code has Transformers inside :P
21:49:45 <Saizan> danderson: maybe you installed yi?
21:49:46 <Eduard_Munteanu> You can name functions Optimus Prime :P
21:49:51 <mm_freak> it even has a real list monad transformer called ChoiceT
21:49:55 <mm_freak> and it makes use of Applicative
21:50:00 <danderson> thing is, this haskell install is a straight ghc + haskell platform install
21:50:03 <mm_freak> so interfaces are saner
21:50:20 <danderson> that's why I'm wondering why a haskell platform install would end up having a conflict like that.
21:50:23 <path[l]> Saizan: my understanding is that building a transformer for say List and Maybe allows you to get a MaybeList for example
21:50:43 <danderson> hmm, actually I take that back
21:50:49 <mm_freak> finally you save a lot of lifts with MonadLib, because it mostly delegates the computation to the right monad when you're stacking them
21:51:05 <danderson> I installed mtl by hand. Looks like transformers came in with the haskell platform.
21:51:31 <mm_freak> so really, if you _use_ monad transformers, go for MonadLib =)
21:52:20 <danderson> mm_freak: I have a monad transformer that I want to use, and don't need any fancy monad underneath. So I'm just after an Identity monad to combine it with.
21:52:21 <mm_freak> path[l]: combining the Maybe and List monads is quite pointless
21:52:29 <mm_freak> Maybe is a special case of List
21:53:07 <Saizan> path[l]: i meant the package
21:53:31 <mm_freak> danderson: the identity monad takes four lines to define
21:53:31 <dmwit> danderson: Is this a transformer you wrote yourself?  Because most transformers in the mtl have a non-transformer version.
21:54:25 <danderson> dmwit: no, it's IterateeG from the iteratees library. afaict, it's explicitly defined only as a transformer, and usually used with State or IO
21:54:38 <dmwit> I see.
21:54:58 <danderson> but I just hid the transformers package for now. Given that mtl is part of the haskell platform, I'll go with using that Control.Monad installation for portability.
21:55:01 <danderson> thanks though!
21:55:31 <mm_freak> danderson: define the identity monad yourself
21:55:38 <mm_freak> then you don't add any dependency
21:55:47 <dmwit> boooo
21:55:58 <dmwit> That is not a scalable solution.
21:56:17 <dmwit> Those giants didn't build a ladder up to their shoulders for nothing.
21:56:33 <jrockway> clearly he should cut-n-paste instead ;)
21:56:46 <jrockway> or even better, write an editor that automates the cut-n-paste
21:56:51 <danderson> heh
21:57:07 <mm_freak> write an operating system that automates the editing =)
21:57:14 <danderson> well, I don't reimplement applicative functor instances either, and each one of those only takes a couple of lines...
21:57:16 <dmwit> Next, on #haskell: how to defeat the benefits of dynamic linking!
21:57:22 <jrockway> mm_freak: now you are talking Enterprise Ready!
21:57:38 <jrockway> (which links everything back to the earlier .NET discussion!)
21:57:46 <kmc> haha
21:57:53 <mm_freak> hehe
21:57:57 <danderson> clearly I should start from first principles, wipe out the prelude, and redefine exactly the constructs I need!
21:58:09 <danderson> I could reimplement Maybe with slightly different semantics! Job security!
21:58:13 <monochrom> Stick to static linking so your users don't have dll hell.
21:58:20 <mm_freak> yeah
21:58:30 <mm_freak> data Maybe a = Nothing
21:58:40 <kmc> MaybeNot
21:59:04 <mm_freak> data UnMaybe a = Nothing a | Just
21:59:09 <jrockway> i have defined a Perhaps type before :)
21:59:09 <danderson> data IDunno a = Yup a | Nope
21:59:22 <jrockway> i think i needed different semantics for the monoid instance
21:59:28 <jrockway> i eventually killed it though
21:59:34 <mm_freak> data Probably a = Just Double a
21:59:47 <Eduard_Munteanu> monochrom, static linking is a hack.
22:00:00 <monochrom> Whatever you say.
22:00:12 <jrockway> how will he have job security if he doesn't use a lot of hacks?
22:00:14 <Eduard_Munteanu> Admittedly, it works okay for an obscure stuff like Haskell.
22:00:53 <Eduard_Munteanu> jrockway, hm good point. I wish Haskell wasn't indent-sensitive so you could obfuscate stuff.
22:01:04 <jrockway> oh, you can obfuscate stuff
22:01:06 <monochrom> Modify GHC so that it expects all modules you use to be in the same file as your main module.
22:01:13 <dmwit> Eduard_Munteanu: All indentation is optional.
22:01:14 <copumpkin> it isn't indent-sensitive if you don't want it to be
22:01:25 <Jonno_FTW> how can i update GHC if i installed with the GHC platform?
22:01:27 <dmwit> Eduard_Munteanu: All blocks can be converted to {;} form.
22:01:29 <Eduard_Munteanu> Oh? Like I can use some braces?
22:01:34 <Eduard_Munteanu> I see, nice.
22:01:36 <copumpkin> yep, and semicolons
22:01:38 <danderson> monochrom: nah, modify GHC adding a mapping of module names you request to module names that are actually imported
22:01:47 <jrockway> but, that's mostly for tools that generate haskell
22:01:49 <copumpkin> we just think it's ugly and avoid it
22:01:53 <jrockway> yeah
22:01:54 <danderson> if I say import Control.Monad, ghc should import Data.ByteString
22:01:54 <Eduard_Munteanu> Oh, I can't wait to see some IOCCC for Haskell spinoff.
22:02:01 <kmc> Eduard_Munteanu, "The meaning of a Haskell program may depend on its layout. The effect of layout on its meaning can be completely described by adding braces and semicolons in places determined by the layout. The meaning of this augmented program is now layout insensitive."
22:02:08 <dmwit> Eduard_Munteanu: There was a guy a while ago on here who kept getting ragged on because he preferred {;} form... until he revealed that he was blind.
22:02:17 <copumpkin> Eduard_Munteanu: http://www.haskell.org/haskellwiki/Obfuscation
22:02:23 <Eduard_Munteanu> dmwit, LOL :))
22:02:23 <kmc> http://haskell.org/onlinereport/syntax-iso.html#sect9.3
22:02:24 <kmc> http://haskell.org/onlinereport/lexemes.html#sect2.4
22:02:42 <kmc> err, the last one should be sec 2.7
22:02:42 <Eduard_Munteanu> Actually sad.
22:02:44 <jrockway> what's interesting is that many tools don't use the brace'
22:02:46 <jrockway> d form
22:02:48 <kmc> dmwit, :O
22:02:54 <kmc> using a screenreader?
22:03:00 <Eduard_Munteanu> Probably.
22:03:01 <kmc> braile?
22:03:04 <jrockway> c2hs just writes "normal code" for example, with the side effects that entails
22:03:06 <kmc> they have them braile ttys
22:03:14 <dmwit> kmc: screenreader, I think
22:03:17 <copumpkin> http://web.archive.org/web/20060117170914/www.scannedinavian.org/iohcc/succzeroth-2004/PiSpigot.hs
22:03:19 <Eduard_Munteanu> And having the software read "space, space" or "4 space" or "tab" doesn't sound good.
22:03:24 <jrockway> it is my goal to learn to use a braille tty sometime soon, in case i ever go blind
22:03:48 <jrockway> it will be hard to order and learn to use a braille tty without the benefit of sight, after all :)
22:03:52 <fatalerrorx> hello
22:03:53 <aavogt> it's probably easier to learn if you actually become blind
22:04:02 <kmc> hi fatalerrorx
22:04:07 <copumpkin> http://web.archive.org/web/20040322180135/iohc.mgoetze.net/Pseudonym.hs
22:04:07 <fatalerrorx> anyone here familiar with alex?
22:04:09 <copumpkin> lots of good stuff
22:04:14 <dmwit> jrockway: What, you don't have any friends?
22:04:20 <copumpkin> fatalerrorx: alex jones? yeah, how do you know him?
22:04:33 <fatalerrorx> :P
22:04:37 <jrockway> dmwit: how will i find my phone to call them if i can't see?
22:04:46 <jrockway> :)
22:04:52 <fatalerrorx> i meant the lexer generator :)
22:04:52 <dmwit> jrockway: Presumably they'll come to visit you in the hospital. =)
22:04:57 <kmc> fatalerrorx, it's not too popular anymore
22:05:10 <fatalerrorx> what should i use?
22:05:14 <kmc> Parsec
22:05:15 <kmc> probably
22:05:20 <fatalerrorx> thats slow
22:05:29 <monochrom> Find an iPhone and just speak to it for phone calls.
22:05:34 <kmc> uu-parsinglib maybe?
22:05:42 <kmc> i don't know of a particular fast lexer library
22:05:42 <jrockway> parrows?
22:05:46 <kmc> maybe you should use alex
22:05:49 <jrockway> more of a parsing thing though
22:05:51 <dmwit> fatalerrorx: Is it?  What's your profiling look like?
22:06:01 <copumpkin> use edwardk's secret monoidal parsing + lexing lib
22:06:19 <dmwit> I'm surprised; I would expect the IO to be slower than the parsing.
22:06:21 <fatalerrorx> dmwot i read its slow
22:06:27 <copumpkin> it was going to be called parsimony but then the parsec guys decided they needed to steal another of the few english pars* words
22:06:29 <fatalerrorx> hav't tried
22:06:31 <jrockway> what are you doing that needs to be fast?
22:06:37 <Eduard_Munteanu> copumpkin, I bet he uses heavy stuff from category-extrax.
22:06:45 <Eduard_Munteanu> s/trax/tras/
22:06:46 <copumpkin> Eduard_Munteanu: not really, mostly from monoids
22:06:48 <dmwit> category-extracts
22:06:49 <fatalerrorx> stock formula lang
22:06:54 <jrockway> if you are iterating over a billion records and want to see which ones contain capital letters, parsec is probably not the right choice
22:06:57 <fatalerrorx> for my site
22:07:08 <copumpkin> fatalerrorx: it's almost definitely fast enough
22:07:09 <jrockway> but if you are implementing a programming language, then definitely use something high-level
22:07:12 <jrockway> like parsec or parrows
22:07:19 <fatalerrorx> really?
22:07:19 <copumpkin> if it turns out to be slow, you can switch parser later on
22:07:28 <jrockway> yeah, 'slow' is a relative term anyway
22:07:33 <copumpkin> are you expecting a million users the first day?
22:07:34 <fatalerrorx> i thought alex and happy
22:07:46 <jrockway> copumpkin: i assume he doesn't need to parse the code once for every user
22:07:52 <copumpkin> who knows!
22:07:59 <jrockway> only once per update, which is even less frequent :)
22:08:10 <kmc> fatalerrorx, Parsec is very popular and is considered fast enough until proven otherwise
22:08:19 <fatalerrorx> i thout alex -> happy -> then some ir lang
22:08:21 <copumpkin> besides, parsec is industrial strength ;)
22:08:31 <fatalerrorx> :)
22:08:32 <jrockway> worry about speed after you have something that works
22:08:34 <monochrom> Perhaps fatalerrorx is working for Wolfram Alpha.
22:08:44 <jrockway> no need to waste time "optimizing" code you're just going to throw away
22:09:03 <copumpkin> pessimizing is so much better anyway
22:09:07 <fatalerrorx> jrockway: no this is planned out
22:09:30 <jrockway> i never worry about speed, and i've never had a program that was "too slow"
22:09:40 <jrockway> although sometimes i run the profiler just to make sure i'm not missing something obvious
22:09:50 <fatalerrorx> jrockway: hosting slice are expensiuve
22:09:54 <jrockway> (which does happen a lot, and then after an hour of hacking my program is twice as fast and equally elegant)
22:10:09 <fatalerrorx> i need max throughput
22:10:15 <jrockway> no you don't
22:10:17 <jrockway> computers are fast
22:10:21 <dmwit> argh
22:10:28 <dmwit> I hate people that tell other people what they need.
22:10:40 <dmwit> The short answer is that nobody in here knows which one is the fastest for your application.
22:10:41 <kmc> dmwit, yeah, it's a common IRC copout
22:10:48 <copumpkin> still
22:10:50 <fatalerrorx> I'll get about 5
22:10:51 <dmwit> If you really want the right answer, you have to try them all.
22:10:59 <fatalerrorx> request per second
22:11:00 <jrockway> ok, he should write a parser generator in hand-coded assembly
22:11:06 <kmc> fatalerrorx, can you build a quick mockup of your language in Parsec and benchmark it?
22:11:19 <fatalerrorx> probably
22:11:20 <jrockway> actually, that is too high-level, better to make his own FPGA ;)
22:11:29 <copumpkin> fuck that
22:11:34 <fatalerrorx> but that seems a waste of time?
22:11:37 <copumpkin> custom-made hardware
22:11:42 <fatalerrorx> lol
22:11:52 <copumpkin> only way to get maximum speed
22:11:55 <kmc> there are lots of people who use custom made hardware for parsing
22:11:56 <dmwit> fatalerrorx: You have to decide how the tradeoff of developer time to CPU time is going to go.
22:11:57 <monochrom> I just feel that we are trolled.
22:12:01 <jrockway> 5 requests per second is rather small
22:12:05 <fatalerrorx> i guess parsec then ir lang and store it in db?
22:12:06 <copumpkin> don't forget to use the n^3 parsing algorithm on your dedicated hardware though
22:12:11 <dmwit> fatalerrorx: Parsec is a very nice library, and it makes very maintainable parsers, and I've never seen one that was too slow.
22:12:20 <kmc> fatalerrorx, of course, don't re-parse when you don't have to
22:12:29 <dmwit> fatalerrorx: But if you really need speed, and any cost to the developers is worth it, then you simply have to try a few.
22:12:47 <fatalerrorx> ok i guess parsec will do
22:13:14 <fatalerrorx> any advice for intepreter?
22:13:28 <dmwit> ghci is a great repl
22:13:30 <fatalerrorx> LLVM bindings?
22:13:31 <kmc> heh, speed is of the utmost, yet you're writing an interpreter?
22:13:35 <kmc> ah
22:13:39 <kmc> yes, that would be faster than an interpreter
22:13:51 <jrockway> i would write an interpreter first though
22:13:54 <kmc> it really depends on the characteristics of the language you're compiling
22:13:57 <jrockway> then when that's too slow, codegen instead
22:14:00 <monochrom> parsec can parse and interpret.
22:14:05 <kmc> yeah, a simple interpreter is a great check against your fancy codegen
22:14:16 <kmc> for bonus points, model them both in Coq and prove them equivalent
22:14:21 <fatalerrorx> lol
22:14:29 <copumpkin> mmmcoq
22:14:49 <fatalerrorx> simple is better
22:14:53 <jrockway> yeah
22:15:08 <kmc> "simple is better" is part of the argument for Parsec over Alex/Happy
22:15:15 <jrockway> my goal is generally to get a working version of something as quickly as possible, so i can find design flaws as quickly as possible
22:15:18 <fatalerrorx> my lang has lots of vector math
22:15:24 <jrockway> no point in having a program that is incorrect but runs really fast, after all
22:15:31 <jrockway> (i am not a game developer though ;)
22:15:34 <dmwit> Compile your language to J. ;-)
22:15:44 <fatalerrorx> kmc: i will use parsec :)
22:15:54 <kmc> fatalerrorx, is the vector math all in terms of predefined operators?
22:16:03 <fatalerrorx> yes
22:16:22 <kmc> i've had good success compiling to C code from Haskell
22:16:25 <fatalerrorx> its working on stock data
22:16:35 <kmc> that is, implementing in Haskell a compiler from my lang to C
22:16:48 <fatalerrorx> kmc i can't have compiling stage
22:16:48 <kmc> and you could provide your vector ops as built in C functions
22:16:57 <kmc> well... LLVM would be a compiling stage
22:16:58 <jrockway> fatalerrorx: your parser / codegen is a compiling stage
22:17:07 <fatalerrorx> ok
22:17:11 <jrockway> you have to somehow go from program text -> results
22:17:17 <fatalerrorx> ya
22:17:17 <jrockway> the -> is the compiler and runtime :)
22:17:54 * jrockway gets mad when people tell him things like "perl is not a compiled language", because it is... it just happens that the compiler doesn't dump anything on disk
22:17:55 <fatalerrorx> i thought ir to make it faster by storing in db
22:18:08 * kmc gets mad when people use the phrase "compiled language"
22:18:14 <jrockway> kmc: yeah, that's fair
22:18:20 <fatalerrorx> it can be intepreted ir
22:18:20 <kmc> i will out-pedant anyone any day :P
22:18:24 <jrockway> :)
22:18:36 <kmc> fatalerrorx, but why not take native machine code as your IR?
22:18:37 <jrockway> fatalerrorx: for most things, a disk is as fast as a database
22:18:41 <kmc> if you need super speed
22:18:43 <jrockway> disks are trees of filename => blobs
22:18:49 <jrockway> databases are trees of primary key => blobs
22:19:06 <fatalerrorx> actually intepreted ir is the best because i need to watch mem usage etc?
22:19:12 <kmc> fatalerrorx, aha
22:19:23 <kmc> well you can do that at the system level too
22:19:34 <kmc> sandbox the binary
22:19:37 <fatalerrorx> i don't want users submitting bad code
22:19:54 <fatalerrorx> hmm
22:20:15 <fatalerrorx> the lang will be in a http server
22:20:16 <dmwit> This is a very mysterious application. =)
22:20:28 <kmc> well, watching mem usage is easy
22:20:32 <kmc> even in compiled code
22:20:38 <kmc> because you control the interface to the system
22:20:49 <fatalerrorx> it will receive code from user browser via jscript
22:20:51 <Eduard_Munteanu> You can even run it as a different user and have PAM enforce memory limits.
22:20:51 <kmc> every time the compiled code wants to alloc memory, it will have to call a function that you write
22:20:55 <Eduard_Munteanu> on Linux that is.
22:21:06 <jrockway> yeah, that would be what i would try first
22:21:07 <fatalerrorx> ah
22:21:23 <jrockway> actually, i would try designing my query language to not use too much memory no matter what
22:21:34 <jrockway> but failing that, just ulimit the process :)
22:21:40 <kmc> jrockway, but then it won't be Turing complete
22:21:44 <fatalerrorx> wouldn't be simpler to buid it into the interpreter
22:21:47 <jrockway> yup, true
22:21:48 <Eduard_Munteanu> :))
22:21:48 <fatalerrorx> ?
22:21:53 <jrockway> turing complete != useful
22:21:53 <dmwit> Turing completeness is overrated.
22:21:58 <kmc> fatalerrorx, an interpreter is easiest in any sense
22:22:07 <kmc> fatalerrorx, but if you care very much about speed, you should compile
22:22:22 <kmc> anyway, it is still good to write the interpreter first
22:22:22 <fatalerrorx> hmm yeah
22:22:25 <kmc> you could also just use Haskell as your query language
22:22:31 <kmc> it already has a great compiler
22:22:32 <jrockway> that was my thought a while ago
22:22:33 <kmc> it's easy to sandbox
22:22:35 <jrockway> why not an "internal DSL"?
22:22:36 <Eduard_Munteanu> I don't really see why interpreters are worthwhile.
22:22:49 <Eduard_Munteanu> I think it's just lazy PHP programmers not wanting to type make :)
22:22:51 <fatalerrorx> internal dsl?
22:22:57 <kmc> embedded DSL?
22:23:03 <jrockway> Eduard_Munteanu: i think even PHP is a compiler
22:23:04 <Eduard_Munteanu> Yeah, that's valid.
22:23:05 <kmc> fatalerrorx, you can write your query lang as an ordinary Haskell library
22:23:11 <kmc> then give your users a sandboxed Haskell compiler
22:23:12 <fatalerrorx> i need to parse txt
22:23:14 <kmc> with your library loaded
22:23:18 <jrockway> text -> parse tree -> AST -> optimizer -> opcodes
22:23:21 <Eduard_Munteanu> But still, there are lots of scripts which could be compiled.
22:23:29 <jrockway> then a VM that runs the opcodes
22:23:36 <dmwit> fatalerrorx: They're suggesting that you let GHC be your parser.
22:23:45 <dmwit> GHC is quite fast. ;-)
22:23:45 <jrockway> "interpreter", in my mind, means "walk the AST and do what the AST says"
22:23:47 <fatalerrorx> how do i do that?
22:23:58 <jrockway> you make the users write haskell
22:24:00 <kmc> fatalerrorx, by letting your users upload Haskell code
22:24:04 <kmc> instead of making a new language
22:24:06 <dmwit> fatalerrorx: Let your language be Haskell. =)
22:24:13 <fatalerrorx> i like the idea of haskell being the parser
22:24:20 <fatalerrorx> lol
22:24:26 <kmc> look at the package "mueval" on Hackage
22:24:28 <fatalerrorx> to hard for users
22:24:28 <kmc> also "hint"
22:24:30 <Eduard_Munteanu> Or implement a type-level arithmetic interpreter :P :P
22:24:31 <kmc> lambdabot uses mueval
22:24:39 <kmc> > fix ((0:) . scanl (+) 1)
22:24:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:24:41 <monochrom> I now feel that we are trolling.
22:24:59 <fatalerrorx> i want users to be able to write for llops etc
22:25:06 <dmwit> Yes, perhaps these suggestions are getting less serious.
22:25:08 <Eduard_Munteanu> Just kidding, don't do that.
22:25:17 <jrockway> but the haskell suggestion is very serious
22:25:21 <kmc> i'm totally serious about "let your users upload Haskell code"
22:25:31 <kmc> perhaps it is not the best solution, but it should be considered along the others
22:25:34 <fatalerrorx> yeah i like that too
22:25:38 <jrockway> if you don't import the prelude, you have a pretty clean slate
22:25:47 <fatalerrorx> but users are to thick
22:25:59 <jrockway> you write your own "variant" of haskell that is haskell but easier
22:26:15 <fatalerrorx> can i add for loops?
22:26:25 <dmwit> :t mapM
22:26:25 <kmc> "for" is an ordinary function in Haskell
22:26:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
22:26:30 <kmc> :t forM_
22:26:30 <Eduard_Munteanu> :t forM
22:26:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
22:26:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
22:26:35 <kmc> hehe
22:26:45 <fatalerrorx> for(i=1; etc
22:26:54 <jrockway> fatalerrorx: are you familiar with "domain specific languages"? that is what you want to make here
22:26:58 <kmc> you want to define your concrete syntax
22:27:00 <kmc> to be exactly like C?
22:27:05 <kmc> a common if regrettable requirement
22:27:09 <fatalerrorx> sort of
22:27:19 <Eduard_Munteanu> for x y z = mapM z [x..y]
22:27:21 <Eduard_Munteanu> :)
22:27:21 <dmwit> "for(i = 0; i < 30; i++) { f(i); }" -> "mapM f [0..30]"
22:27:25 <fatalerrorx> but no type reqa
22:27:36 <dmwit> I prefer the latter, personally.
22:27:39 <dmwit> much shorter
22:27:40 <jrockway> if you are querying stock prices, you might write a library to allow queries like "getStock "FOO" >>= extractPrices >>= groupBy Week >>= printPrices"
22:27:49 <jrockway> it's haskell, but easy for users to learn
22:27:55 <kmc> there are also other languages you could consider embedding in
22:28:00 <kmc> Lua is designed for this sort of thing
22:28:11 <fatalerrorx> sounds good
22:28:12 <kmc> Python is super easy to learn
22:28:16 <kmc> also, Javascript
22:28:17 <jrockway> dmwit: but the haskell loop has one more iteration than the C one :)
22:28:21 <kmc> which is much like Python but with beloved C syntax
22:28:33 <dmwit> jrockway: A bug of the programmer, not the language. ;-)
22:28:52 <jrockway> actually, I was going to blame C for that :)
22:28:57 <kmc> it might be easier for your users to write in a dynamically typed language
22:29:07 <kmc> or it might not
22:29:08 <fatalerrorx> dsl sounds good but maybe to hard for users to grasp
22:29:18 <kmc> fatalerrorx, what you proposed when you came in was a DSL
22:29:28 <jrockway> "external DSL" vs. "internal DSL"
22:29:34 <fatalerrorx> yes
22:29:35 <jrockway> i sound like a ruby programmer now :(
22:29:36 <kmc> the kind which is embedded as an ordinary library in another language is an "embedded DSL"
22:29:38 <Eduard_Munteanu> fatalerrorx, what kind of users do you have? What do they know? Are they programmers?
22:29:49 <fatalerrorx> no
22:29:57 <Eduard_Munteanu> Hm.
22:30:06 <fatalerrorx> most have used easy languages
22:30:19 <jrockway> i work at a financial institution, and i am surprised how easily "non-programmers" can learn to program domain-specific languages
22:30:31 <jrockway> don't overwhelm them with too many CS concepts and you'll be fine
22:30:44 <jrockway> easy words that get them results they need
22:30:44 <Eduard_Munteanu> fatalerrorx, you might consider making some UI for them (either web or a GUI app).
22:30:47 <fatalerrorx> soomething like this http://www.wisestocktrader.com/indicatorpasties/6-better-volume-indicator
22:30:48 <jrockway> or, use Excel
22:30:54 <copumpkin> just use the zygohistmorphic prepromorphism to grab the stock symbols you want
22:30:56 <jrockway> that is the most popular solution, I've found :)
22:30:59 <kmc> "just code your stock query using our monadic combinator library based on the polymorphic lambda calculus"
22:31:05 <kmc> yes copumpkin exactly
22:31:17 <jrockway> kmc: that is what you do, but you call it something like "StockX"
22:31:21 <jrockway> and make a cool logo
22:31:26 <jrockway> step 3) profit!
22:31:35 <copumpkin> the cool logo is key
22:31:37 <monochrom> I feel that copumpkin has a macro for zygohistmorphic prepromorphism.
22:31:42 <copumpkin> nope
22:31:47 <Eduard_Munteanu> copumpkin, yeah, that sounds awesome, saw it on the wiki a few days ago :)
22:31:51 <copumpkin> my client doesn't do macros
22:31:54 <copumpkin> :(
22:31:54 <jrockway> cool logos make people feel good about their choices
22:31:57 <kmc> brain macro
22:32:02 <dmwit> If he had a macro, he wouldn't have misspelled it.
22:32:08 <fatalerrorx> if i let users upload haskell code
22:32:16 <kmc> jrockway, the Christians got pretty far with an execution device as a logo
22:32:18 <copumpkin> oh yeah I missed an O
22:32:22 <fatalerrorx> won't compiling be slow?
22:32:28 <kmc> fatalerrorx, maybe
22:32:33 <kmc> you can interpret it the way ghci does
22:32:42 <kmc> you can get a feel how slow that is by playing with ghc
22:32:46 <copumpkin> fatalerrorx: keep in mind that in computer terms, 5 requests a second is peanuts
22:32:47 <kmc> ghci*
22:32:47 <jrockway> kmc: good point
22:33:08 <Eduard_Munteanu> fatalerrorx, do you really need something that can be compiled, or can you do it by providing a few checkboxes and controls on a page?
22:33:16 <fatalerrorx> kmc but it will do heavy prcessing
22:33:26 <jrockway> copumpkin: indeed.  i have several perl web apps that have better throughput than that
22:33:27 <Eduard_Munteanu> fatalerrorx, I mean, is it necessary that your users write code?
22:33:30 <fatalerrorx> Eduard_Munteanu: no
22:33:32 <jrockway> with haskell, you should have no problems :)
22:33:38 <fatalerrorx> Eduard_Munteanu: yes
22:33:43 <jrockway> (insert standard rant about "but don't use bubble sorts, blah blah blah")
22:33:50 <kmc> fatalerrorx, won't executing your user's query code take longer than compiling it?
22:33:55 <kmc> i assume the queries do something nontrivial
22:34:00 <kmc> and also that you might run them more than once
22:34:03 <kmc> without recompiling
22:34:40 <fatalerrorx> kmc i worried that the lib that will be linking with the user code will be big
22:34:47 <kmc> the lib is precompiled
22:34:53 <dmwit> ?src merge
22:34:53 <lambdabot> Source not found. My mind is going. I can feel it.
22:34:59 <kmc> and the lib interface is pre-parsed
22:35:16 <fatalerrorx> linking can be slow
22:35:22 <fatalerrorx> yes no?
22:35:29 <Eduard_Munteanu> You could expire cached compiled code in a LRU fashion and keep a fixed upper bound on the store.
22:35:34 <kmc> fatalerrorx, yes
22:35:38 <kmc> anything can be slow sometimes
22:35:40 <jrockway> linking is not intrinsically slow
22:35:47 <kmc> fatalerrorx, look at how GHCi does it
22:35:57 <Eduard_Munteanu> Linking is I/O bound AFAICT.
22:36:08 <fatalerrorx> ghci  is slow
22:36:18 <fatalerrorx> and no tail recursion
22:36:23 <kmc> really?
22:36:23 <jrockway> it does more than 5 requests per second
22:36:25 <jrockway> what?
22:36:37 <jrockway> (don't confuse printing the result and computing the result)
22:36:44 <kmc> "tail recursion" has unusual implications with lazy evaluation
22:36:46 <fatalerrorx> ah ok
22:36:47 <Eduard_Munteanu> (or foldl with foldr)
22:36:53 <kmc> but i don't know of a special property of ghci over ghc wrt tail calls
22:37:36 <fatalerrorx> ok i need to think this over
22:37:45 <fatalerrorx> thanks for the help
22:37:51 <kmc> indeed, it's a complicated design space :)
22:37:52 <kmc> good luck
22:37:58 <fatalerrorx> ty
22:38:36 <dmwit> ?src sort
22:38:36 <lambdabot> sort = sortBy compare
22:38:40 <dmwit> ?src sortBy
22:38:40 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
22:38:45 <dmwit> What!
22:38:50 <dmwit> That can't be right.
22:39:17 <dmwit> I it was a merge-sort.
22:39:48 <path[l]> ugh disconnected
22:39:52 <path[l]> mm_freak: still here?
22:41:23 <mm_freak> path[l]: yes
22:41:28 <path[l]> ah
22:41:40 <path[l]> so you were saying Maybe and List are pointless to combine
22:41:42 <path[l]> so I asked
22:41:50 <path[l]>  So what about say IO to console and List? or Like database access and IO? I thought transformers are the only way to get 2 monads to play nice
22:42:06 <path[l]> i think Ive understood monads individually
22:42:11 <path[l]> but not with transformers
22:42:15 <kmc> they are
22:42:27 <jrockway> maybe and list are a special case because list does everything maybe does
22:42:29 <jrockway> [] = Nothing
22:42:32 <jrockway> [42] = Just 42
22:42:32 <jrockway> etc.
22:42:34 <kmc> a monad transformer is a type-level function that takes a monad and gives you a new monad
22:42:55 <kmc> MaybeT IO is quite reasonable combination
22:43:03 <mm_freak> yes
22:43:13 <mm_freak> so is 'ChoiceT IO'
22:43:16 <path[l]> yeah. So I can see why MaybeList itself might be meaningless, but the others seem fine
22:43:17 <mm_freak> (in monadLib)
22:43:19 <path[l]> ah
22:43:25 <kmc> right
22:43:41 <path[l]> would there normally be a difference between M1T M2 and M2T M1 ?
22:43:45 <kmc> yes
22:43:51 <kmc> "All About Monads" talks about this
22:43:53 <dmwit> I have had situations where I wanted both an empty list and a no-result kind of thing.
22:43:56 <path[l]> ah
22:44:09 <jrockway> dmwit: ErrorT List in that case?
22:44:20 <dmwit> I'm not sure I believe this claim that mixing Maybe and [] is silly.
22:44:29 <kmc> e.g. you combine state and error.  one way, a computation either fails or it produces a result and a state update.  the other way, it always produces a state update, and could fail or produce a result too
22:44:40 <mm_freak> well, you _may_ want to combine list and maybe for the sake of clarity
22:44:40 <kmc> in the second monad, the state transformations keep going after failure
22:44:58 <mm_freak> so you have a separate "yes, it worked, but the result is empty" and "it didn't work"
22:45:13 <dmwit> Exactly.
22:45:40 <dmwit> Or, mixing the other way, "only the fourth and sixth attempts worked, and they both gave empty results".
22:45:40 <jrockway> why not ErrorT in that case though?
22:46:15 <dmwit> Maybe there's no good error to give.
22:46:24 <jrockway> [Left "parse error", Left "the server died", Left "OH NOES", Right [], ...
22:46:39 <jrockway> but sure, you can definitely do what you are saying
22:46:48 <jrockway> if you are OK with [Nothing, Nothing, Nothing, Nothing, Just [], Nothing]
22:47:04 <dmwit> If you're going to be returning [Left "", Left "", Left "", Right []], why not just use Nothing and Just? ;-)
22:47:14 <mm_freak> jrockway: because there is a difference between "no result" and "error"
22:47:39 <jrockway> [] is "no result"
22:47:39 <dmwit> anyway
22:47:42 <jrockway> Left "error" is error
22:47:45 <jrockway> so is Nothing, of course
22:47:45 <mm_freak> no
22:47:51 <mm_freak> Just [] = empty result
22:47:55 <mm_freak> Nothing = no result
22:48:04 <jrockway> sure, do that
22:48:04 <kmc> wheel of fish!
22:48:12 <monochrom> We are violently agreeing.
22:48:19 <kmc> monochrom, I agree harder!
22:49:10 * jrockway just enjoys debugging 'Left "the server is down"' more than 'Nothing' 
22:49:33 <copumpkin> pff bugs
22:50:16 <jrockway> yeah, i forgot that the type system prevents that sort of error ;)
22:53:41 <aavogt> is it bad to require -XRelaxedPolyRec without understanding what it does?
22:54:07 <jrockway> probably
22:55:45 <kmc> is it documented in the latest ghc manual?
22:56:04 <kmc> i can't find it
22:56:27 <kmc> ah it's 7.8.7?
22:57:36 <Saizan> aavogt: nah, it just makes type inference for polymorphic recursion saner
22:57:37 <kmc> i'd add type signatures rather than turning on an extension
22:57:51 <kmc> but maybe there's a situation where that doesn't work
22:58:49 <aavogt> I have nasty type signatures due to the use of some extensible record system
22:58:50 <Saizan> the one time i used that extension was to be able to give such a signature like i wanted to
22:59:05 <kmc> hmm
22:59:30 <aavogt> it's awkward to give signatures for just the outer part of the type... which probably doesn't help here
22:59:44 <Saizan> if you've to mutually recusive functions the typeclass contexts must be syntactically equal in haskell98
23:00:05 <Saizan> s/to/two/
23:00:22 <mtnviewmark> what am I missing....
23:00:28 <mtnviewmark> isn't Either a  a Functor?
23:00:40 <kmc> hope so
23:00:47 <mtnviewmark> where is it defined?
23:00:50 <kmc> but it might require (Error a) =>
23:00:55 <aavogt> Saizan: hmm, I don't believe that my functions are mutually recursive
23:00:56 <dmwit> Control.Monad.Error
23:00:57 <mtnviewmark> 'cause gchi is tellin' me it ain't
23:00:57 <kmc> for stupid reasons
23:01:17 <mtnviewmark> even thought Data.Either says it's a Functor
23:01:22 <mtnviewmark> including that doesn't work?
23:01:46 <mtnviewmark> oh man - that's sad
23:02:16 <Saizan> the instance is not defined in Data.Either
23:02:30 <aavogt> Saizan: http://64.131.71.66/fastcgi/hpaste.fcgi/view?id=16475#a16475
23:02:58 <aavogt> I can't see how there is any recursion since I don't call main from anywhere
23:03:11 <mtnviewmark> I see, but somehow Haddock adds the instance info there....
23:03:16 <Saizan> aavogt: ghc thinks otherwise :)
23:03:40 <Saizan> mtnviewmark: haddock simply lists all the instances it knows about under the datatype
23:04:06 <mtnviewmark> I wonder how Haddock knew to include Control.Monad.Error when it was processing Data.Either....
23:07:01 <Saizan> mtnviewmark: the instance is defined in Control.Applicative
23:07:13 <syntaxglitch> hm, it's been a couple months since I started messing with Haskell I think, does that mean it's about time to write my own monad tutorial?
23:07:21 <syntaxglitch> or has that gone out of fashion these days
23:07:58 <Saizan> it's still cool if you do it ironically
23:08:56 <syntaxglitch> I think all the metaphors have been used up, anyway
23:08:59 <mtnviewmark> Saizan: how could one know that? it isn't in the doc for that module at all!
23:08:59 * copumpkin got it all wrong... got posted to reddit with a big rant on how haskell is not about monads
23:09:26 <elly> copumpkin: if it's not about monads, how will people know it's not C++? :P
23:09:29 <Saizan> though there's already a trend of writing them by distilling valuable information from papers.
23:09:30 <jrockway> haskell is monads, lisp is AI, etc.
23:09:33 <Saizan> see sigfpa.
23:09:35 <mtnviewmark> and, actually - id doesn't appear to be there at all!
23:09:38 <Saizan> *sigfpe
23:09:43 <Stinger> Haskell, it's monads all the way down
23:09:44 <jrockway> don't tell me i can use an AI language for writing web apps, or something...
23:09:47 <mtnviewmark> AH
23:09:49 <jrockway> that would totally shatter my world view
23:09:49 <Saizan> mtnviewmark: id?
23:09:51 <copumpkin> elly: onoes!
23:09:52 <mtnviewmark> Control.Monad.Instances
23:09:58 <mtnviewmark> that's where it really is
23:10:24 <syntaxglitch> jrockway, don't be ridiculous, no one ever made any money writing web apps in lisp, that's absurd
23:11:10 <Saizan> mtnviewmark: it's in http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/Control-Applicative.html too
23:11:23 <Saizan> or maybe not.
23:11:27 <jrockway> syntaxglitch: seriously! facebook is php, so that's what every application that generates HTML should be written in!
23:11:40 <Saizan> yeah, you were right, C.M.I
23:11:50 <mtnviewmark> :-)
23:12:06 <Saizan> i thought that one was in mtl
23:12:49 <kmc> come for the monads, stay for the smugness and despair
23:13:08 <Saizan> mtnviewmark: :info in ghci tells you where an instance is defined, btw.
23:13:28 <mtnviewmark> yes - though only once you've managed to get it loaded!
23:13:38 <syntaxglitch> jrockway, on the other hand, if no one wrote web apps in lisp maybe I wouldn't waste so much time reading Hacker News :(
23:13:48 <mtnviewmark> in this case, it wasn't in scope --- :i told me it wasn't a Functor!
23:13:58 <Saizan> mtnviewmark: true
23:14:02 <jrockway> syntaxglitch: don't get me started on news.arc :)
23:14:08 <Saizan> mtnviewmark: write a tool to find instances :)
23:14:21 <mtnviewmark> sorry, I only take on decidable problems!
23:14:34 <mtnviewmark> and don't tempt me with more yak shaving
23:14:37 <Saizan> it is decidable
23:14:42 <mtnviewmark> it's bad enough as it is
23:14:52 * mtnviewmark head back into the guts of haddock....
23:15:45 <Saizan> ah, you are already hacking on haddock?
23:16:24 <mtnviewmark> yup
23:16:41 <mtnviewmark> changing the output from nested tables to semantic markup
23:16:56 <jrockway> nice
23:16:59 <mtnviewmark> I've got a CSS file that makes it look pretty much identical to the way it looks now
23:17:17 <mtnviewmark> BUT - then folks can easily change it radically
23:17:36 <dolio> You should make it not remove parentheses around function argument types when displaying on multiple lines, while you're at it.
23:17:43 <dolio> Assuming it still does.
23:18:03 <Saizan> and add a machine readable output too!
23:18:23 <mtnviewmark> Saizan - Haddock already produces multiple output formats, some of which are machine readable!
23:18:38 <Saizan> mtnviewmark: which, aside from .hoogle?
23:18:42 <mtnviewmark> Hoogle and HaddockDB
23:18:55 <Saizan> HaddockDB lacks lots of informations
23:19:15 <mtnviewmark> true - I just looked
23:19:34 <mtnviewmark> but anyway - if you want some machine readable form, the backends are all easily pluggable
23:19:40 <mtnviewmark> I'm only hacking in the HTML one
23:20:37 * Saizan would also like a format that haddock is able to read back if i miss the sources
23:21:13 <jrockway> cp -a code docs
23:21:31 <jrockway> it's a lossless transformation, and comes in the default install of debian!
23:21:32 <jrockway> :)
23:21:48 <Saizan> too much irrelevant information in the output
23:22:32 <Saizan> and it's not easily machine readable! have you seen how big haskell parsers are?
23:23:03 <dmwit> it make easy with kealmath
23:23:08 <dmwit> i invent kealmath
23:23:22 <dmwit> i show how to spell triangle in only five numbers with dark matrix
23:23:49 <merehap> you are eaten by a gure
23:23:53 <merehap> grue*
23:25:15 <Saizan> are you mocking the way i build my sentences?
23:25:29 <dmwit> no
23:25:33 <copumpkin> :O
23:25:46 <dmwit> That was not the intention, at least.
23:26:12 <dolio> @keal
23:26:12 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
23:26:23 <jrockway> 42, of course
23:26:30 <copumpkin> 62
23:26:39 <copumpkin> if you want to write haskell like c
23:26:46 <copumpkin> in ghc
23:26:49 * jrockway goes to see if that's actually a C limit
23:27:02 <copumpkin> oh, I was just talking about GHC's tuple support
23:27:13 <dolio> So, I'm severely disappointed. They added INu to Pig, but still no cofree comonads.
23:27:21 <copumpkin> what's INu?
23:27:21 * c_wraith ponders zipWith62
23:27:38 <dolio> It's for indexed coinductive families.
23:27:41 * syntaxglitch read cofree as coffee for a moment there
23:27:44 <syntaxglitch> got my hopes up :(
23:27:58 <copumpkin> cofree is so much better than coffee
23:28:15 * jrockway looks at backlog
23:28:16 <copumpkin> as monochrom suggested earlier, ultrafiltered cofree is even better
23:28:29 <danderson> comonadic coffee?
23:28:31 <jrockway> my internal error detection function deleted that entire line from the irc buffer
23:28:34 <jrockway> too many parse errors
23:28:35 <jrockway> :)
23:29:03 <monochrom> Category theorists can't tell their coffee filters from their cofree ultrafilters.
23:29:12 * syntaxglitch now wonders what ffee is
23:29:42 * jrockway makes a note to buy a cofree ultrafilter the next time he is at the cofree shop
23:30:07 <mm_freak> ok, i don't know why but i've just written a brainfuck interpreter in haskell
23:30:18 <copumpkin> in the type system?
23:30:22 <copumpkin> cause otherwise it's uncool
23:30:32 <monochrom> in the kind system
23:30:37 <mm_freak> depends on what you mean by "in the type system" =)
23:30:39 <copumpkin> if only
23:30:39 <Veinor> Ultrafilters. They're like filters, but extreme
23:30:42 <mm_freak> i have a BF type =P
23:30:48 <aavogt> @quote line
23:30:48 <lambdabot> dons says: note that you're using all the advanced features of haskell in 1 line here...
23:30:51 <Veinor> Is the kind system turing-complete? It doesn't seem like it is.
23:30:56 <mm_freak> @quote cofilter
23:30:56 <lambdabot> No quotes match. You untyped fool!
23:30:57 <copumpkin> mm, maybe someone should write a verified brainfuck interpreter in agda
23:31:17 <mm_freak> copumpkin: what if you feed the program +[] into it?
23:31:19 <monochrom> the kind system is limited. I was kidding.
23:31:24 <mm_freak> then you get an endless loop =)
23:31:27 <copumpkin> mm_freak: codata
23:31:29 <syntaxglitch> now I want turing-complete kind-level programming :(
23:31:31 <copumpkin> oh wait, it's not even productive
23:31:32 <copumpkin> but still
23:31:39 <mm_freak> it would work, probably
23:31:44 <Veinor> monochrom: I know you were kidding, it just made me wonder
23:31:51 <copumpkin> well, you wouldn't be able to prove your interpreter terminates
23:31:53 <copumpkin> but whatever
23:32:13 <aavogt> so why does cabal refuse to run my Setup.lhs even when I set my build-type: Custom?
23:32:29 <copumpkin> aavogt: it doesn't like you
23:32:53 <dmwit> aavogt: Does it give an error?
23:33:27 <dmwit> It's definitely possible.
23:34:10 <syntaxglitch> I don't see what the big deal about potentially nonterminating compilers is
23:34:12 <aavogt> oh, if I put an error "ohai" in there, it does reach that code
23:34:32 <syntaxglitch> if you can write a program that doesn't go into an unintended infinite loop you can write metaprograms that don't diverge either
23:34:42 <jrockway> yeah, so copumpkin is right then
23:34:45 <jrockway> it just doesn't like you :)
23:34:49 <copumpkin> as always
23:35:20 <aavogt> if I run the  rawSystem "path/to/script" ["args"]   in ghci, it generates my code properly
23:35:52 <jrockway> you cabal file is sane, right?
23:35:58 <jrockway> it doesn't say build-type: simple or something?
23:36:32 <aavogt> well, now that I print the exitcode...
23:36:43 <aavogt> I have an  ExitFailure 127
23:36:56 <aavogt> too bad there's no way to get the descriptive errorages easily
23:37:13 <monochrom> I like "errorages" :)
23:37:56 <aavogt> but you can help?
23:37:58 <dmwit> Yes, having programs exit with an integer (with a single byte, no less!) was an early mistake.
23:38:08 <dmwit> Plan 9 lets you exit with a string -- much better.
23:38:29 <jrockway> even better: programs should not be allowed to exit with errors
23:38:37 <jrockway> if there is an error, it must fix it before exiting
23:38:37 <dmwit> bollocks
23:38:46 <dmwit> That is a terrible idea.
23:39:01 <jrockway> maybe i should have added a :) at the end ;)
23:39:06 <dmwit> oh, heh
23:39:09 <dmwit> I got trolled.
23:39:24 <syntaxglitch> programs shouldn't be allowed to exit period
23:39:33 <syntaxglitch> if they're done with one task there's plenty more
23:39:40 <dmwit> hm
23:39:44 <syntaxglitch> lazy programs, exiting all the time...
23:39:49 <elly> the only 'program' is the lisp interpreter
23:39:52 <elly> :)
23:39:55 * elly flees
23:39:56 <jrockway> trolling is when someone comes in and asks how to write a parser and then tells everyone "parsec is too slow" without knowing what parsec is :)
23:40:03 <jrockway> i am merely "cute"
23:40:33 <kmc> hmm proving stuff about Brainfuck code in Coq sounds like a fun exercise
23:40:53 <jrockway> "proof: your program is unreadable"
23:40:53 <syntaxglitch> elly, heathen! no untyped lambda calculus in here please >:[
23:41:03 <elly> syntaxglitch: :t apply
23:41:05 <elly> :P
23:41:11 <dmwit> :t ap
23:41:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:41:21 <kmc> :t Data.Dynamic.dynApply
23:41:22 <lambdabot> Dynamic -> Dynamic -> Maybe Dynamic
23:41:32 <monochrom> I heard a reputed respected opinion-leader type of programmer advocating this as defensive programming: write «while (i!=0) ... i-- ...», don't write «while (i>0) ... i-- ...», so that in case you have the bug of initializing i to be negative, you observe an infinite loop, it doesn't exit.
23:41:33 <dmwit> hahaha
23:41:50 <kmc> > toDyn
23:41:51 <lambdabot>   {()-><<()>>}
23:42:04 <dmwit> monochrom: Surely the better way would be
23:42:16 <dmwit> "assert(i>=0); while(either one) { ... }"
23:42:35 <kmc> > (toDyn ()) `dynApply` (toDyn ())
23:42:36 <lambdabot>   Nothing
23:42:40 <kmc> > (toDyn (\() -> ())) `dynApply` (toDyn ())
23:42:41 <lambdabot>   Just <<()>>
23:42:58 <aavogt> > read "<<()>>" :: Dynamic
23:43:00 <lambdabot>   No instance for (GHC.Read.Read Data.Dynamic.Dynamic)
23:43:00 <lambdabot>    arising from a use ...
23:43:27 <kmc> > toDyn 3
23:43:27 <lambdabot>   <<Integer>>
23:43:29 <syntaxglitch> monochrom, I want to hope that there's something missing in the context of that anecdote
23:43:36 <dmwit> > (toDyn ()) `dynApply` toDyn
23:43:37 <lambdabot>   Couldn't match expected type `Data.Dynamic.Dynamic'
23:43:37 <lambdabot>         against inferre...
23:43:48 <dmwit> > (toDyn ()) `dynApply` (toDyn toDyn)
23:43:49 <lambdabot>   Ambiguous type variable `a' in the constraint:
23:43:49 <lambdabot>    `Data.Typeable.Typeable a...
23:43:49 <jrockway> syntaxglitch: it makes sense
23:44:02 <jrockway> why test the boundary case when it's more correct to define the entire range of cases
23:44:16 <jrockway> that way, if you are on the wrong side of the boundary somehow, your program will still work somewhat correctly
23:44:27 <dmwit> jrockway: read again
23:44:34 <kmc> > (toDyn (toDyn :: Char -> Dynamic)) `dynApply` (toDyn 'x')
23:44:35 <lambdabot>   Just <<Dynamic>>
23:44:35 <dmwit> jrockway: You're suggesting the exact opposite of the expert.
23:44:48 <kmc> > toDyn . toDyn . toDyn . toDyn . toDyn $ 3
23:44:49 <lambdabot>   <<Dynamic>>
23:44:59 <dmwit> "expert"
23:45:02 <jrockway> ah
23:45:13 <kmc> > iterate (fromDynamic :: Dynamic -> Maybe Dynamic) . toDyn . toDyn . toDyn . toDyn . toDyn $ 3
23:45:14 <lambdabot>   Couldn't match expected type `Data.Dynamic.Dynamic'
23:45:14 <lambdabot>         against inferre...
23:45:25 <jrockway> sometimes i assume that people know what they're talking about
23:45:28 <jrockway> :)
23:46:12 <dmwit> I think the argument that it's good to observe bugs is sound; the argument that the way to observe them is by looping forever is less convincing.
23:46:12 <monochrom> Of course by and far I agree with assert.
23:46:35 <kmc> but of course, looping forever and using error have exactly the same denotation
23:46:48 <kmc> so why should we have any preference
23:46:49 <mm_freak> kmc: not in C
23:46:50 * syntaxglitch is generally of a mind to prefer a controlled exit with error logging to nontermination
23:46:52 <dmwit> Yes, but bugs don't exist in theory. =)
23:46:59 <kmc> mm_freak, you've a denotational semantics for C?
23:47:20 <dmwit> Also: there *is* a denotational semantics for IO that takes exceptions into account; error and loop do not have the same meaning in that domain.
23:47:23 <kmc> hmm, someone did a verified C compiler, they must've semantificated it somehow
23:47:29 <mm_freak> kmc: no, but C doesn't meet the assumptions haskell's denotational semantics make =)
23:47:57 <kmc> dmwit, i'd like to program in this "Theory" language you describe, it sounds quite nice
23:48:10 <mm_freak> hmm
23:48:16 <mm_freak> i don't think it sounds nice
23:48:18 <dolio> I think that's more of an operational semantics than a denotational semantics.
23:48:33 <dolio> If you're thinking of the somewhat recent catchable exceptions stuff.
23:48:55 <dmwit> I was thinking of "Tackling the Awkward Squad", but you might be right -- it might be operational.
23:49:14 <dolio> Oh, I don't really remember what they do in that paper.
23:49:22 <dmwit> me neither
23:49:28 <kmc> if ZFC is proven inconsistent then all your denotational semantics will be worthless
23:49:52 <monochrom> Tackling the Awkward Squad is operational.
23:50:36 <kmc> or ZF anyway.  doubt any bits of Haskell have a denotation which cannot be constructed without Choice
23:50:50 <mm_freak> i don't think we want more than one of those nasty bottoms =)
23:51:14 <dmwit> I'm generally in favor of bottoms.
23:51:17 <dolio> What makes you think they use objects that rely on ZF? Or even Z?
23:51:25 <kmc> math has to come from somewhere
23:52:09 <dolio> It doesn't have to come from ZF.
23:52:21 <monochrom> ZFC plays the role of GHC. Merely one possible popular implementation of the high-level domains you use.
23:52:32 <kmc> heh
23:52:39 <monochrom> So GHC has bugs? Try Hugs.
23:52:52 <kmc> the Zarathustra FORTRAN Compiler
23:53:05 * syntaxglitch derives all of math via combinatorial logic
23:53:49 <syntaxglitch> ...of course, that's inconsistent, so probably doesn't help much
23:53:56 <monochrom> FWIW some people use category theory instead of ZFC to get the some high-level domains for denotational semantics.
23:54:24 <monochrom> s/the some high/the same high/
23:55:13 <monochrom> Abstraction is bliss.
23:55:40 <dolio> I think a lot of the category theoretic (and similar) foundations people build tend to be inconsistent if ZF(C) is, though.
23:56:01 <dolio> Or close.
23:57:21 <dolio> Not a lot of people out there like roconnor who go around hoping that it's inconsistent so that people will be forced to abandon set theory.
23:57:37 <monochrom> hahaha
23:58:36 <c_wraith> I'm told most people doing research in math have given up on foundations, because caring about them hurts you in a publish or perish environment
