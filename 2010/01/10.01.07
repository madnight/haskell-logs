00:01:47 <Veinor> > let (?) bool a b = if bool then a else b; (??) = ($) in True ? "f" ?? "g"
00:01:48 <lambdabot>   "f"
00:01:52 <ivanm> who owns joyful.com that hackagebot is hosted there?
00:02:17 <ivanm> Veinor: re-creating the ternary operator in C, Java, etc.?
00:02:32 <Veinor> Mmyep
00:02:44 <Veinor> although, you can also write it like this
00:02:53 <Veinor> > let (?) bool a b = if bool then a else b; (??) = ($) in (True?) "f" "g"
00:02:54 <lambdabot>   "f"
00:03:00 <Veinor> which I think is kind of neat.
00:03:14 <ivanm> hmmmmm....
00:06:32 <Veinor> I can't think of any reason not to just use if or something though :P
00:07:19 <ivanm> well, I quite like the fold over Bool
00:07:31 <ivanm> @type bool f t b = if b then t else f
00:07:32 <lambdabot> parse error on input `='
00:07:41 <ivanm> @type let bool f t b = if b then t else f in bool
00:07:42 <lambdabot> forall t. t -> t -> Bool -> t
00:08:28 <ivanm> so rather than doing if (foo $ bar x) ... you can do bool f t . foo . bar
00:08:50 <Veinor> I'd like bool t f instead, but okay :p
00:09:09 <Veinor> so, bool' = flip bool
00:09:26 <ivanm> Veinor: I used to use that as well, but there's a good reason for doing it with false case first
00:09:32 <Raynes> http://gist.github.com/271078 What is wrong here? :\
00:09:36 <Veinor> why?
00:09:48 <ivanm> a generic fold over any data structure (especially church encoding ones) does the "zero" case first
00:10:02 <ivanm> actually.... foldr and foldl don't ... >_>
00:10:05 * ivanm is now confused :s
00:10:08 <ski> > [minBound .. maxBound] :: [Bool]
00:10:10 <lambdabot>   [False,True]
00:10:26 <ski> ivanm : well, they should ! :)
00:10:31 <ivanm> ski: yeah
00:10:40 <ivanm> Raynes: the usual case is to also have "import Data.Map(Map)"
00:10:44 <ivanm> which saves you from doing M.Map
00:10:51 <koeien37> Raynes: you don't have a data constructor
00:10:53 <ivanm> as for why that error is there... I have no idea :s
00:11:01 <Raynes> koeien37: Oh shit.
00:11:02 <koeien37> M.Map is not a valid data constructor identifier
00:11:02 <ivanm> koeien37: doh!
00:11:05 <Raynes> :o How did I miss that.
00:11:17 <Veinor> Raynes: data HGrid a b = HGrid M.Map a (M.Map a b)
00:11:20 <Raynes> That's a sure sign of needing to sleep.
00:11:31 <ivanm> Veinor: needs parens as well
00:11:37 <ivanm> Raynes: eh, I missed it at first as well
00:11:51 <Raynes> ivanm: Thanks for the import tip.
00:12:05 <ivanm> Raynes: IIRC, the documentation for Data.Map says that ;-)
00:12:13 <ivanm> yup, it does
00:13:45 <Veinor> ah, yeah, parens
00:15:01 <ivanm> hmmm.... we need . and $ on the type level!
00:15:18 <ivanm> data HGrid a = HGrid . M.Map a . M.Map a
00:15:19 <ivanm> ;-)
00:15:23 <koeien37> type level functions!
00:16:05 <ski> medfly : i seem to vaguely recall reading that `Double' was expected to be used more often (because of higher precision) than `Float', so more work has gone into optimizing that
00:16:14 <Veinor> I like type level functions, personally
00:16:55 <ski> i wonder if something like L-lambda unification in types would be reasonable to ask for
00:17:30 <ski> (though maybe multi-determinism could be a problem)
00:19:04 * ski wonders whether Raynes would be better off with `data HGrid a b = HGrid (M.Map (a,a) b)'
00:19:14 <ivanm> ski: yeah, that sounds about right
00:19:19 <ivanm> (the Double stuff)
00:19:27 <ivanm> ski: depends on what he's doing I suppose
00:19:30 <Ke> :t pi
00:19:30 <lambdabot> forall a. (Floating a) => a
00:21:35 <koeien37> > showCReal 37 pi
00:21:36 <lambdabot>   "3.1415926535897932384626433832795028842"
00:22:11 <fabjan> > showCReal 100 pi
00:22:12 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
00:22:13 <leimy> > showCReal 100 pi
00:22:14 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
00:22:15 <leimy> lol
00:22:17 <fabjan> -D
00:22:27 <fabjan> oops, a cyclops
00:23:20 <Ke> so the definition has some algorithm to compute pi?
00:23:55 <ski> yes
00:28:53 <medfly> ski: oh, I see. thanks
00:30:42 <Gracenotes> Ke: it's not very efficient for further-out digits
00:32:58 <Raynes> ski: Was going a bit more direct route and making it a map of maps. I suppose it would work either way.
00:33:16 <Raynes> Seemed simpler my way. Probably better your way.
00:33:58 <Raynes> I did it for an unfinished scrabble project a while back, so I thought it might be useful as a library.
00:34:12 * Raynes needs sleep now. :<
00:34:19 <ski> with `M.Map (a,a) b', rectangularity should be enforced, i think
00:34:28 <ski> (not sure if you wanted rectangularity, though)
00:35:03 <Veinor> @src pi
00:35:04 <lambdabot> Source not found. :(
00:35:47 <koeien37> it's a class function of Floating
00:36:53 <ski> @where CReal
00:36:53 <lambdabot> http://darcs.augustsson.net/Darcs/CReal/CReal.hs and http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
01:17:00 <ivanm> @. elite quote
01:17:01 <lambdabot> Plugin `compose' failed with: getRandItem: empty list
01:17:08 <ivanm> bah
01:19:47 <HaskellLove> I got 4207994 for euler 23 but nor correct, someone has solved it? to check the solution if i am even close?
01:20:09 <Botje_> hang on
01:20:31 <Botje_> you've got the right order of magnitude
01:20:40 <Botje_> and you're not really far off
01:23:23 <Beelsebob> you're out by aproximately 30000
01:23:44 <koeien37> now try all solutions :P
01:23:50 <Beelsebob> haha
01:26:30 <HaskellLove> holy sweet aleluja
01:28:15 <HaskellLove> You guys see optimizations or something wrong here that lead to that result ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15684#a15684
01:29:55 <mauke_> sort . nub :-[
01:31:03 <koeien37> then do S.toList . S.fromList
01:32:17 <Botje_> HaskellLove: it's a bit silly to include n for sum_proper_dividers, only to remove it explicitly later on :)
01:32:24 <Botje_> x <- [1..n-1]
01:32:34 <ivanm> koeien37: or map fst . group . sort ;-)
01:32:47 <koeien37> ivanm: sure
01:32:53 <koeien37> map head, you mean
01:33:14 <ivanm> ummm, yeah
01:33:51 <ivanm> actually, for a nub replacement, rather than doing either of those I once wrote a function that did a foldr or something with a Set of seen values
01:34:10 <HaskellLove> Botje_ is even better [1..(n`div`2)] :)
01:34:14 <ivanm> that way, you get laziness + same-order for the results
01:36:00 <Botje_> HaskellLove: takeWhile (<= 28123)
01:36:20 <koeien37> ivanm: yeah. but you will need Ord. Not a problem in practice, I guess
01:36:35 <ivanm> koeien37: right, but you need ord for the sort or Set-based versions
01:36:44 <koeien37> yep
01:36:49 * ivanm goes off to dig the code up
01:36:55 <koeien37> but as a nub-replacement, it falls a tiny bit short
01:37:28 <ivanm> yeah
01:37:33 <ivanm> hmmm.... can't seem to find it...
01:37:59 <ivanm> ahhh, I removed the generalised version
01:38:02 <ivanm> that's why I couldn't find it
01:38:31 <ivanm> and it was a manual list function copying dons' "go" style
01:38:37 <HaskellLove> ivanm that is faster then sort . nub?
01:38:51 <ivanm> since IIRC someone told me that was faster than foldr, etc.
01:38:57 <ivanm> HaskellLove: for finite lists? probably not
01:39:08 <ivanm> but it provides laziness in the result, and since I was dealing with _huge_ lists...
01:39:10 <HaskellLove> <koeien37>	are you sugesting using Data.Map?
01:39:25 <koeien37> I suggested Data.Set
01:39:28 <ivanm> it was indeed faster
01:39:31 <koeien37> but map head . group . sort is better
01:39:45 <ivanm> koeien37: really? I did it just as an alternative
01:39:56 <ivanm> I would think that S.fromList out-performs sort
01:39:59 <ivanm> less ++, etc.
01:40:00 <koeien37> ok, sure
01:40:06 <koeien37> but less to import
01:40:13 <koeien37> saves keyboarding ;)
01:40:13 <ivanm> heh, big difference!
01:40:23 <ivanm> two different lines! (three if you need to add containers to your cabal file)
01:40:35 <Botje_> koeien37: i'm sure leksah will have a "fix imports" (a la eclipse) soon :P
01:40:43 <HaskellLove> ivanm in my case it would be better to go with your version?
01:40:53 <koeien37> Botje_: is Leksah going to find out what I mean by "S.fromList"?
01:41:09 <ivanm> HaskellLove: are you dealing with really long lists?
01:41:17 <Botje_> it could look up fromList in installed packages and give you a choice.
01:41:18 <ivanm> if not, just do Set.toList . S.fromList
01:41:24 <koeien37> Botje_: yep
01:41:37 <koeien37> I realized that as soon as i pressed <enter>
01:41:51 <Botje_> maybe apply a heuristic to make Data.Set the default choice (since it also has a capital S in it)
01:42:08 <Botje_> and since that's often the convention..
01:42:42 <Botje_> damn, now i want to write that code
01:42:48 <Botje_> but i have to do research! RESEARCH!
01:47:15 <dblhelix> Botje_: what are you researching?
01:48:29 <ivanm> Botje_: how will it cope with say mtl vs monads-fd? ;-)
01:51:53 <HugoDaniel> hi
01:51:59 <HugoDaniel> http://www.ddj.com/windows/222200479
01:52:52 <HugoDaniel> "Languages like Haskell are often criticized as being too extreme in not allowing side effects, giving them limited penetration in mainstream development environments. Operations such as reading a file become awkward to code in a language where no side effects are allowed. In contrast, impure, multi-paradigm languages such as F#, a strongly typed, first-class .NET programming language designed by Don Syme and others at Microsoft Research, discourage
01:52:53 <HugoDaniel> side effects and imperative constructs, but make them available alongside their functional brethren."
01:52:56 <koeien37> "Operations such as reading a file become awkward to code in a language where no side effects are allowed."
01:52:59 <koeien37> x <- readFile "bla"
01:53:39 <Jafet> So Microsoft reinvented ML. Let's move along shall we
01:54:16 <koeien37> Microsoft also reinvented Java. But they turned it into a better language
01:54:22 <koeien37> *and* they marketed it
01:54:39 <koala_man> they're not trying to avoid success
01:54:40 <koeien37> increasing its popularity and drawing people/companies away from C++
01:54:49 <HugoDaniel> which is a good thing :)
01:54:50 <Beelsebob> koeien: tbf, hat's not written in a language with no side effects â€“ that's using a language with no side effects to describe the action that must be performed in a language with side effects
01:54:56 <Ke> I think Laziness is far more difficult than functionality
01:54:59 <Beelsebob> and insulating itself from the side effecting language with monads
01:55:05 <HugoDaniel> and they also introduced assemblies to the general public, which are also a good thing
01:55:24 <koeien37> and they pay SPJ, which is also a good thing ;)
01:55:34 <Jafet> Funny thing is, a lot of Haskell research takes place at MSR
01:55:36 <HugoDaniel> yes
01:55:57 <merehap> so why can't they just go with Haskell rather than F#, then?
01:56:01 <HugoDaniel> we could infer that m$ is a goot thing
01:56:23 <HugoDaniel> merehap: because F < H
01:56:37 <merehap> ok, I'll give them some time then :)
01:56:39 <HugoDaniel> now they have to do G#, and maybe in some years they will do H#
01:56:39 <koeien37> merehap: too "different" maybe? not integrateable enough with .NET? viewed as "impractical"
01:56:44 <koeien37> they want their own language ?
01:56:44 <Jafet> > "F#" < "Haskell"
01:56:45 <lambdabot>   True
01:56:57 <Ke> MS is a good thing only stupid people that enhance it's monopolies aren't
01:56:58 <medfly> hehehe
01:57:02 <dibblego> I have stood next to both Erik and Don while Erik berated Don for creating an impure, strict language
01:57:02 <medfly> Jafet: ARGUMENT SETTLED!
01:57:09 <Jafet> INDEED
01:57:24 <koeien37> > "Haskell" < "Pascal"
01:57:25 <lambdabot>   True
01:57:28 <koeien37> zomg
01:57:32 <koeien37> the (<) here is broken
01:57:36 <path[l]> well F# has one really cool thing that haskell doesnt have
01:57:40 <path[l]> the entire .net library
01:57:44 <medfly> lol
01:57:47 <koeien37> and workflows!
01:57:49 <koeien37> hehe
01:57:55 <merehap> > "Pascal" < "SQL"
01:57:56 <lambdabot>   True
01:58:13 <Beelsebob> > "C" < "*"
01:58:15 <lambdabot>   False
01:58:16 <Beelsebob> o.O
01:58:18 <koeien37> path[l]: but we have FFI?
01:58:26 <path[l]> that alone will mean people who want to use functional languages to build enterprisey stuff will take a risk with F#
01:58:42 <medfly> mm, ejterprisey stuff
01:58:46 <koeien37> yeah. Just that it has a Microsoft sticker, and is treated as first-class
01:58:49 <merehap> I'm fine with F# as the gateway drug
01:58:49 <koeien37> IDE support
01:58:53 <koeien37> really important
01:58:59 <path[l]> well its also sitting on the .net clr
01:59:02 <HugoDaniel> im going to be evil now...
01:59:09 <koeien37> and we can divert people to F#, so Haskell will have less success!
01:59:11 <koeien37> everybody happy
01:59:11 <Ke> aren't you guys bitter
01:59:16 <path[l]> ffi is always sorta through the OS calls arent it
01:59:16 <HugoDaniel> > "Python" < "haskell"
01:59:17 <lambdabot>   True
01:59:26 <merehap> :)
01:59:30 <merehap> well done
01:59:36 <medfly> wait, so we want Haskell to be less successful?
01:59:38 <koeien37> path[l]: it can call via the C calling convention
01:59:41 <Jafet> Making Char an instance of Ord doesn't sound like a good idea to me
01:59:47 <Jafet> medfly, d'oh.
01:59:51 <koeien37> medfly: of course. Maybe it's not too late yet
01:59:54 <path[l]> yeah thats not as easy. It seems to mean doing more work
01:59:57 <medfly> I think this channel would much prefer F# over C++, right?
02:00:01 <path[l]> there was an attempt to put haskell on the jvm
02:00:03 <path[l]> jaskell
02:00:07 <path[l]> what happened to it?
02:00:10 <path[l]> anyone know
02:00:17 <HugoDaniel> left to the jackals :P
02:00:21 <koeien37> I think UHC also has a jvm backend, but it isn't useable
02:00:23 <HugoDaniel> nah, i dont really know
02:00:38 <Ke> just port platform to ghc-6.12 make it available on distros and leksah or create proper debugger port haskell to cmake and stop using darcs
02:00:39 <medfly> I think that when Haskell becomes popular you'll all find another language you like, so no problem :p
02:00:43 <Jafet> -fvia-c then use the C to JVM compiler
02:00:47 <medfly> ALSO you'd be able to work doing Haskell! hurray!
02:00:51 <Ke> so haskell might actually become popoular
02:01:20 <Ke> (but I think that's a non-objective for most here)
02:01:24 <koeien37> Ke: I have a hunch that it's gaining in popularity. Although I can't back this up
02:01:33 <merehap> darcs is improving, making progress on it may help haskell
02:01:37 <dblhelix> medfly: I work all day doing Haskell ;-)
02:01:43 <dblhelix> no complaints here
02:01:45 <medfly> dblhelix: do you get paid though?
02:01:46 <HugoDaniel> dblhelix: me too
02:01:50 <HugoDaniel> i get paid
02:01:50 <koeien37> research?
02:01:55 <medfly> really? how come?
02:01:57 <merehap> sorry, I'm with dons, popularity is a good thing for haskell
02:02:04 <dblhelix> medfly: of course I do
02:02:04 <medfly> in the meantime, I'm doing PHP.
02:02:14 <merehap> medfly: oops
02:02:17 <Jafet> It's not a good thing for Haskell, but it's a good thing for people who use Haskell.
02:02:26 <koeien37> it's a mixed blessing
02:02:37 <merehap> I agree with that
02:02:44 <koeien37> but I'm sure there will be a fork of Haskell if it becomes too popular :)
02:02:52 <medfly> hehe
02:03:01 <merehap> well I might jump ship to agda... :)
02:03:06 <medfly> y'all will implement Caleskell
02:03:14 <HugoDaniel> well, being popular certainly would help the task of convincing managers to go for it instead of php or other languages
02:03:19 <medfly> which no newbie would understand
02:03:35 <koeien37> medfly: I don't have a problem with that, necessarily
02:03:38 <Jafet> How about Joy? You could get a job pretending to people that it's FORTH
02:03:38 <HaskellLove> i want to sum elements. Now i have them in a Set, i will have to convert to List and then sum or is there a better way?
02:03:41 <koeien37> I think the Helium approach is sound
02:03:46 <koeien37> HaskellLove: S.fold
02:05:12 <koeien37> medfly: define a sub-language that is easier to understand, and write a compiler for that
02:06:12 <HaskellLove> fold :: (a -> b -> b) -> b -> Set a -> b koeien37 the b thing is initial value i supose, so i can put it to 0 right?
02:06:20 <koeien37> yes.
02:06:27 <koeien37> for sum that is a good choice
02:06:32 <Jafet> koeien, ...ending up with something that resembles Haskell?
02:06:48 <koeien37> Jafet: maybe, yeah :) And then they can use Helium to learn that
02:06:50 <Jafet> "PLT Haskell, coming to lecture halls near you"
02:06:54 <Ke> still haskell is vastly different from generic functional language
02:07:00 <pozic> Popularity in which there are communities with high signal/noise ratio are a good thing. If everyone would use Haskell, we might have some useful libraries, instead of only the low-hanging fruit.
02:07:09 <Ke> for example the strong types and inference
02:07:13 <Adamant> Jafet: that's more or less what Hugs is
02:07:14 <koeien37> pozic: yes
02:07:24 <koeien37> pozic: and better tooling
02:07:47 <ski> Ke : the MLs have that as well (and Clean)
02:08:03 <Ke> lisp doesn't
02:08:07 <ski> (so .. what is "generic functional language" ?)
02:08:08 <pozic> koeien37: yes. Everything has an economy of scale, even, or in particular, software.
02:08:14 <ski> Ke : *nod*
02:08:16 <Jafet> "Generic functional language" refers to Lisp
02:08:22 <Ke> yes
02:08:22 <ski> ok
02:08:25 <Ke> !
02:08:26 * ski didn't know that
02:08:39 <pozic> ski: that is because it is not a fact.
02:08:47 <Jafet> Or, the simple untyped lambda calculus with sequential call-by-value semantics
02:08:50 <koeien37> pozic: it would be cool to have a very well-supported and widely used Haskell, and "caleskell" for the geeks
02:08:54 <Jafet> (Sounds generic!)
02:09:28 <ski> (pozic : well, i didn't say i know it now, either .. ;)
02:09:31 <koeien37> so that people who like that can program in that and get nothing done
02:10:52 <Jafet> All those hours per grad student per degree don't just go away, you know.
02:11:05 <pozic> What I am interested more than languages is algorithms and in particular complete algorithms. If you read any new algorithm these days by most authors, you get an incomplete mess with really too many assumptions that don't hold in the real world.
02:11:33 <pozic> If I were on the committee of a journal, I would reject 95% of that garbage.
02:11:45 <ski> (dibblego : that language being F# ?)
02:11:53 <pozic> Maybe I should just start a high-quality journal ;)
02:11:53 <koeien37> I haven't read recent papers in algorithms. Can you give an example of such assumptions?
02:12:08 <dibblego> ski, yes
02:12:13 <Ke> ski: I can formulate it {functional languages with static typing} \subset {functional languages}
02:12:21 <Jafet> And you'd keep 5% of that garbage, pozic?
02:12:28 <Jafet> Eccentric.
02:12:33 <ski> Ke : agreed
02:12:36 <Ke> ski: and it _will_ make you feel much better
02:12:44 <pozic> Jafet: you know what I meant.
02:12:49 <ski> ("it" referring to ?)
02:12:57 <Ke> nvm
02:14:10 <pozic> koeien37: for example polygons not containing holes.
02:14:45 <pozic> koeien37: not handling "degenerate" cases (e.g. collinear vertices).
02:15:04 <pozic> koeien37: articles referring to vague proofs as an "algorithm".
02:15:36 <paolino> pozic: middle age is over anyway
02:15:38 <koeien37> basically, you want more details?
02:15:50 <pozic> The stuff you read in books is mostly the well-ironed out stuff about which they have done 30 years or something like that.
02:16:07 <koeien37> pozic: sounds like mathematics
02:16:11 <pozic> I don't see what's so hard about writing down a correct algorithm for the whole thing.
02:16:23 <pozic> I have done so, so why can't the rest of the world do that?
02:16:40 <koeien37> convention
02:16:41 <pozic> I don't like to reverse-engineer whatever vague language other people have used.
02:16:58 <pozic> AFAIK, it is just that todays papers are more like advertisements.
02:17:10 <pozic> "Oh, look what we implemented, contact us for details. "
02:17:26 <paolino> you will have an higher rank in peer reviews, good for your next moves
02:18:00 <pozic> paolino: what do you mean? When you do what?
02:18:25 <paolino> if you make good papers , you will be considered better
02:18:34 <koeien37> not necessarily
02:18:54 <paolino> this is the goal, anyway
02:18:55 <pozic> I also think it is a sin to refer to papers that you don't understand fully.
02:19:22 <koeien37> I read a paper, containing "This proof is contained in a paper from the references." *without actually stating the reference*
02:19:38 <pozic> Things like "we use result X from Bob, Baz, and Bar", but nobody has ever managed to implement that result.
02:19:39 <koeien37> sorry, I'm not going to chase 20 papers to find the proof
02:20:02 <paolino> read another author then
02:20:09 <pozic> paolino: and what if they are not there?
02:20:17 <koeien37> paolino: yep, that was what I did :)
02:20:25 <pozic> Really, the most annoying thing is that they present it as if the problem has been solved.
02:20:26 <koeien37> there is often "folklore" in branches of mathematics
02:20:28 <mauke_> http://cr.yp.to/bib/devil-cite.html
02:20:57 <pozic> I have seen a commercial implementation and even that one has "I don't know whether this is true"-comments in it.
02:21:15 <koeien37> mauke_: ah yes, I've read that in the paper of the dutch association of mathematicians
02:22:21 <paolino> pozic: turn off internet
02:22:41 <pozic> paolino: yes, maybe if you do everything from scratch it is even faster.
02:23:08 <paolino> internet is full of half done stuff, that is a feature
02:23:26 <pozic> paolino: this is peer-reviewed stuff.
02:23:33 <pozic> The standards people have are just too low.
02:23:56 <paolino> it's good that now we can measure it
02:24:55 <pozic> paolino: we can?
02:25:07 <paolino> 20 years ago it was impossible to state that
02:25:44 <pozic> paolino: there are several made up numbers associated with a paper, but the only way to truly know its quality is to read it.
02:29:09 * hackagebot upload: Lastik 0.4 - A library for compiling programs in a variety of languages (TonyMorris)
02:30:21 <paolino> pozic: windows is not good , but it made the world, you cannot fight the wind mill, I'd better second the wind and make my way picking what is good for me , which is probably something you point as bad, and I would have nothing to understand with a censor like you. People accessing information have different deegres of culture
02:31:20 <Ke> your life is sad
02:31:39 <paolino> so ?
02:31:58 <medfly> "it made the world"
02:32:08 <medfly> without windows... do you know what would have happened? we'd have another OS. that's all.
02:32:22 <Adamant> medfly: maybe, maybe not
02:32:26 <koeien37> OS/2, apple, whatever
02:32:31 <medfly> it's not like it was the first one or anything.
02:32:43 <pozic> An OS is not like a very complicated piece of software.
02:32:59 <Adamant> medfly: nope, but it did push GUI's forward on the most common and more important business computing platform
02:33:18 <medfly> it didn't invent them though. it wouldn't have been so bad.
02:33:34 <Zr40> I have to say that Windows isn't quite that bad as some people claim it to be
02:34:00 <Adamant> medfly: sometimes stuff gets invented that languishes for years. sometimes the popularizer is as important as the inventor
02:34:02 <koeien37> I haven't used it for some years now
02:35:07 <paolino> medfly I never used anything from microsoft after dos, and think it's avery bad thing to have such a monopoly, but in my country every computer shop sell boxes with vista in it.
02:35:11 <pozic> Backwards compatibility, its user-base and its social implications. Those are the main things wrong with Windows.
02:35:28 <koeien37> backwards compatibility is a feature
02:35:41 <Adamant> backwards compatibility is a blessing and a curse
02:35:46 <Ke> I'll second pozic
02:36:14 <koeien37> there are probably more things wrong with gnu/linux, but it just suits me better
02:36:47 <Beelsebob> packwards compatibility is what makes windows applications 99% rubbish
02:37:03 <paolino> mh, unix was there and obviously better, when dos came out
02:37:52 <paolino> but bill was not enough clever to adapt it
02:38:20 <Adamant> he didn't use it because using Unix on a resource constrained machine back then was not fun times
02:38:49 <Zr40> paolino: actually, windows supports a posix environment
02:38:55 <Zr40> but it's not installed by default
02:39:09 <koeien37> not when DOS came out...
02:39:38 <pozic> Zr40: except that it doesn't work.
02:39:40 <Ke> Zr40: mmap fork?
02:39:47 <Ke> +,
02:39:56 <pozic> Zr40: I know, because I tried the latest release.
02:40:12 <Adamant> also, a multiuser OS on a 8-bit, 16-bit machine that wasn't connected to a network is pretty much overkill
02:40:23 <paolino> Zr40: never met a happy windows user, in 10 years. I blame the non-posix environment for it
02:40:45 <Zr40> paolino: user happiness requires a posix environment?
02:40:46 <koeien37> even I have met those
02:40:46 <Adamant> most of the people who use Windows don't even know what POSIX is
02:40:58 <pozic> paolino: I meet other persons.
02:41:14 <pozic> Still, even ignorant people can be happy.
02:41:26 <paolino> pozic: game players ?
02:41:34 <koeien37> I have met happy windows users that I wouldn't call ignorant
02:41:42 <SmurfOR> I think it's that most people that have issues with their computers did something that they shouldn't have but didn't know they shouldn't have done it.
02:42:00 <pozic> koeien37: me too, but just being happy doesn't mean a thing :)
02:42:11 <koeien37> ack
02:42:16 <pozic> Name one feature Windows has and Linux does not.
02:42:23 <pozic> I know of at least one.
02:42:42 <koeien37> I can install a binary from somewhere, and expect it to work
02:42:45 <Zr40> lots of popular games.
02:42:51 <Adamant> working DirectX
02:42:58 <pozic> I am referring to actual technical features.
02:43:04 <Adamant> I just gave you one
02:43:06 <pozic> DirectX9 also works on Wine.
02:43:07 <koeien37> why does that matter?
02:43:12 <Adamant> pozic: not very well
02:43:20 <dibblego> please name it in #haskell-blah
02:43:26 <koeien37> I couldn't care less if linux supports Ext234234243234 if there is no decent interface for it
02:43:27 <Adamant> good point
02:43:29 <Ke> pozic: trim-support
02:43:31 <koeien37> ack
02:44:14 <paolino> pozic: being happy with a computer for people means "trust the box", noone trusts windows, same is for languages, that is why we are here, and I shut up, we are off-topic
02:44:14 <medfly> pozic: "has lots of money"? :)
02:44:59 <Zr40> I trust windows.
02:45:09 <Zr40> I don't trust random software people install on windows
02:45:10 <koeien37> #haskell-blah
02:45:11 <lunabot>  luna: A section must be enclosed in parentheses
02:46:27 <Beelsebob> Adamant: DirectX is not a technical feature
02:46:35 <Beelsebob> "GPU acceleration of 3D graphics" is
02:46:42 <Beelsebob> "GPU acceleration of computations" is
02:46:48 <Beelsebob> DirectX is an implementation of those features
02:46:56 <Ke> but then again quite a bit of that comes from external drivers
02:47:07 <Beelsebob> indeed
02:47:18 <Adamant> Beelsebob: we can discuss this, -blah or PM
02:47:32 <Beelsebob> get yourself in -blah then! >.>
02:52:10 <HaskellLove> I am having problems with euler 23 anyone has solved it? i have one question
02:52:37 <soiamso> HaskellLove: in haskell wiki have a solution
02:52:54 <therp> HaskellLove: I seem to have solved.. at least according to my euler file
02:57:39 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15686#a15686 i get this huuge number as result and it is not correct 297633032
03:02:46 <therp> I guess the takeWhile is the problem
03:02:58 <zygoloid> yeah, sum_each_other is not sorted
03:03:06 <therp> because it stops taking the numbers as soon as one single entry hits >28123
03:03:17 <therp> I guess you want to filter
03:03:18 <HaskellLove> zygoloid but it does not matter since i use Sets
03:03:34 <therp> S.fromList is called after takeWhile
03:03:35 <zygoloid> HaskellLove: yes it does! takeWhile will stop when it hits the first entry >= 28123
03:03:42 <HaskellLove> aha
03:03:44 <zygoloid> s/>=/>
03:03:47 <Jonno_FTW> hmmm
03:04:12 <therp> takeWhile isn't defined on lists..
03:04:13 <Jonno_FTW> i thought you had that one HaskellLove
03:04:36 <HaskellLove> Jonno_FTW no i skipped it and now i am onto finishing it
03:04:49 <Jonno_FTW> ok, i thought I gave you how i did it
03:06:02 <HaskellLove> problem solved thank you guys, the problem was the takeWhile yes
03:06:39 <HaskellLove> Jonno_FTW i might have just studied it then, i dont copy others code i do it my own, so i might have studied it then and left for some time to pass and now i solved it on my own :)
03:07:03 <Jonno_FTW> good idea, how long did it take to compute?
03:07:05 <therp> HaskellLove: nice solution, mine looks ugly in comparison :)
03:07:30 <soiamso> HaskellLove: may be you can use ghci's debug ability
03:07:43 <HaskellLove> Jonno_FTW less then 10 secs
03:07:54 <Jonno_FTW> faster than mine iirc
03:09:39 <HaskellLove> Jonno_FTW actually sorry no that was another problem i looked at ... this one was 30 secs but still not bad i guess
03:09:49 <Jonno_FTW> hmk
03:09:53 <Jonno_FTW> about what i did then
03:12:27 <paulvisschers> Is it just me or is haddock not working properly anymore?
03:14:19 <koeien37> paulvisschers: more specifically?
03:15:06 <HaskellLove> How am U suposed to get an element from a set given its index? There is no such function, i will have to convert to Data.Map or a list i guess... but since sets are not ordered i guess it is logical not to have indices
03:15:29 <paulvisschers> koeien37: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15687#a15687
03:15:54 <paulvisschers> Without the class constraints it does seem to work properly
03:16:17 <Jonno_FTW> how can i remove the . " / - characters from a string?
03:17:14 <koeien37> paulvisschers: works for me
03:17:30 <koeien37> Haddock version 2.4.2, (c) Simon Marlow 2006
03:17:30 <Jonno_FTW> > filter (/= '.') "str.ing"
03:17:32 <lambdabot>   "string"
03:17:44 <paulvisschers> koeien37: It's probably because I have a new version of ghc with an old haddock executable, I'll try updating
03:17:50 <Jonno_FTW> but with all the characters for any place in the string
03:17:55 <koeien37> > filter (`nonElem` ".\"/") "bla!.//"
03:17:56 <lambdabot>   Not in scope: `nonElem'
03:18:01 <koeien37> > filter (`notElem` ".\"/") "bla!.//"
03:18:03 <lambdabot>   "bla!"
03:18:12 <Jonno_FTW> hmk
03:19:39 <koeien37> paulvisschers: that may be a good idea
03:19:54 <paulvisschers> koeien37: Haddock version 2.6.0, (c) Simon Marlow 2006
03:19:59 <paulvisschers> still same problem
03:20:05 <Jonno_FTW>  filter (`notElem` ".\""""/") "strin./""
03:20:05 <koeien37> ghc 6.12.1?
03:20:09 <paulvisschers> not sure what version I had before this
03:20:14 <Jonno_FTW> > filter (`notElem` ".\""""/") "strin./""
03:20:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:20:23 <paulvisschers> koeien37: yep
03:20:51 <Jonno_FTW> well I have to clean this: -5/39/1 to 5391
03:20:54 <koeien37> I don't have it installed, so can't check
03:21:18 <Jafet> Jonno, how do you write a string containing those four characters?
03:21:40 <Jonno_FTW> it's the input file
03:22:13 <Jonno_FTW> > filter (isDigit) "str4"
03:22:14 <lambdabot>   "4"
03:22:56 <paulvisschers> Jonno_FTW: if you only have numbers, than that would be the way to go, filter isDigit
03:23:09 <Jonno_FTW> that's what i'll use
03:23:23 <Jonno_FTW> I'm doing this btw, http://www.flownet.com/ron/papers/lisp-java/instructions.html
03:24:13 <Jafet> Oh, I remember that one
03:24:23 <paulvisschers> koeien37: well whatever, it's not really relevant
03:24:35 <Jonno_FTW> apparently it was done in 49 lines of lisp
03:24:46 <Jafet> I read about it on Norvig's website and solved it myself, apparently Norvig's solution was wrong
03:25:19 <Jonno_FTW> *55 lines of lisp
03:25:24 <Jonno_FTW> i reckon i could do it in less haskell
03:26:13 <pozic> Jonno_FTW: that has already been done.
03:26:23 <pozic> (don't ask where)
03:26:43 <Jonno_FTW> I'll do it for myself
03:28:08 <koeien37> http://www.haskell.org/haskellwiki/Phone_number
03:30:07 <HaskellLove> filter (listHasMoreElements_21) . concatMap inits . tails $ primes        how can that be written to be faster? I am thinking about filtering in the tails and inits part separately instead of one filter like this one...
03:31:05 <Jonno_FTW> well you can write it faster by using shorter variable names
03:32:03 <Jonno_FTW> you can write a function to check if a list has more than 21 elements shorter than the name you gave it
03:32:16 <HaskellLove> why is hoogle so slow, i search for a function subsequence or something i might use it here
03:32:18 <Jonno_FTW> length xs > 21
03:32:35 <koeien37> ugh
03:32:37 <HaskellLove> Jonno_FTW it is same thing i guess
03:32:44 <Jonno_FTW> but,
03:32:45 <koeien37> (==21) . length . take 21
03:32:48 <Jonno_FTW> horrible to read names
03:33:20 <koeien37> that's length xs >= 21
03:33:27 <Jonno_FTW> > length  "listHasMoreElements_21"
03:33:29 <lambdabot>   22
03:34:12 <HaskellLove> is hoogle this slow for me or what? I am looking for this subsequence command but it still searches :(
03:34:42 <tensorpudding> there is a subsequences command
03:34:44 <Jonno_FTW> > length "(>21).length)"
03:34:45 <lambdabot>   13
03:34:50 <tensorpudding> @src subsequences
03:34:51 <lambdabot> Source not found. My brain just exploded
03:34:54 <tensorpudding> er
03:35:00 <tensorpudding> @type subsequences
03:35:01 <lambdabot> forall a. [a] -> [[a]]
03:35:13 <tensorpudding> > subsequences [1,2,3]
03:35:15 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
03:35:43 <koeien37> > filterM (const [True, False]) [1,2,3]
03:35:45 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
03:36:39 <HaskellLove> Jonno_FTW yeah i see your point, i really should start writing like that instead of looong names
03:37:13 <Jonno_FTW> use comments if you really need to show what you are thinking
03:37:39 <HaskellLove> i will do that from now on thank you
03:38:20 <HaskellLove> it seems to me this is waaay slower concatMap inits . tails $ primes  than this : subsequences primes
03:38:23 <HaskellLove> i might be wrong
03:40:16 <HaskellLove> oh actually i dont need subsequences, since i need CONSECUTIVE numbers so mine is fine i guess using tails and inits
03:43:24 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15688#a15688 I think the first one will be faster what do you guys think
03:45:44 <Gracenotes> > tails [1,2,3]
03:45:45 <lambdabot>   [[1,2,3],[2,3],[3],[]]
03:46:03 <Gracenotes> there is probably a more sensible way of checking when the length stops being >21
03:46:43 <Gracenotes> oh. I don't know what those do. try some profiling. it's not that difficult.
03:47:37 <ski> > genericLength [0..] > (21 :: Natural)
03:47:38 <lambdabot>   True
03:49:19 <HaskellLove> ski it says genericLength is less effecient then length
03:49:54 <mauke_> > not . null . drop 21 $ [0 ..]
03:49:55 <lambdabot>   True
03:49:56 <Gracenotes> @where profiling
03:49:57 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
03:50:45 <HaskellLove> mauke_ that is faster then filtering?
03:51:50 <ski> > length [0..] > 21
03:51:54 <lambdabot>   mueval-core: Time limit exceeded
03:51:59 <ski> see ?
03:52:32 <ski> `length' there is `O(+inf)', while `genericLength' is `O(n)'
03:52:46 <ski> obviously `genericLength' is more efficient !
03:53:53 <int-e> ... right.
03:54:10 <HaskellLove> ski hoogle says else
03:55:20 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15689#a15689 euler 50 i think i might use Set instead of List since the elements are ordered anyway so i might get some speed
03:55:20 <int-e> Amazing what changing representations can do.
03:55:52 <int-e> In reality, length would be just as efficient if it returned a Natural.
03:58:40 <IceDane> Haskellers! My haskell is rusty. Isn't there some really easy way to drop every other element from a list without using modulus and so on?
03:59:15 <Zr40> filter even list
03:59:17 <ivanm> IceDane: pattern matching
03:59:33 <int-e> > map head . takeWhile (not . null) . iterate drop 2 $ [1..11]
03:59:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:59:35 <lambdabot>         against inferred type ...
03:59:46 <int-e> > map head . takeWhile (not . null) . iterate (drop 2) $ [1..11]
03:59:47 <lambdabot>   [1,3,5,7,9,11]
03:59:52 <mauke_> > [ x | x <- "etaoin shrdlu" | b <- cycle [False, True], b ]
03:59:52 <lambdabot>   "etaoin shrdlu"
03:59:53 <Zr40> > filter even [1..11]
03:59:54 <lambdabot>   [2,4,6,8,10]
04:00:01 <Zr40> or odd
04:00:01 <ivanm> > let dropEverySnd (a:_:as) = a : dropEverySnd as; dropEverySnd as = as in dropEverySnd [1..10]
04:00:03 <lambdabot>   [1,3,5,7,9]
04:00:03 <int-e> > transpose . takeWhile (not . null) . iterate (drop 2) $ [1..11]
04:00:04 <lambdabot>   [[1,3,5,7,9,11],[2,4,6,8,10],[3,5,7,9,11],[4,6,8,10],[5,7,9,11],[6,8,10],[7...
04:00:10 <ivanm> mauke_: oooh, yeah, forgot about that kind of thing
04:00:15 <mauke_> except it doesn't work
04:00:22 <int-e> > transpose . takeWhile (not . null) . map (take 2) . iterate (drop 2) $ [1..11] -- oops
04:00:24 <lambdabot>   [[1,3,5,7,9,11],[2,4,6,8,10]]
04:00:27 <IceDane> ivanm: Yours is prefect
04:00:28 <IceDane> thanks
04:00:33 <ivanm> doens't RWH use something with cycle [id, f] for something like that?
04:00:46 <ivanm> mauke_: :(
04:00:49 <ivanm> IceDane: no worries
04:00:55 <mauke_> > map snd . filter fst . zip (cycle [False, True]) $ "etaoin shrdlu"
04:00:56 <lambdabot>   "tonsrl"
04:01:01 <mauke_> there we go
04:01:01 <ivanm> IceDane: there is a "cooler" way of doing it using cycle IIRC; just don't remember how :(
04:01:09 <ivanm> mauke_: using zip is cheating! ;-)
04:01:26 <int-e> > let evens (x:xs) = x:odds xs; evens [] = []; odds (x:xs) = evens xs; odds [] = [] in evens [0..10] -- oh ... and then there's
04:01:27 <lambdabot>   [0,2,4,6,8,10]
04:01:28 <ivanm> @type \ f -> cycle [id, f]
04:01:29 <lambdabot> forall a. (a -> a) -> [a -> a]
04:01:49 <ivanm> int-e: heh
04:02:24 <mauke_> > catMaybes . zipWith id (cycle [const Nothing, Just]) $ "etaoin shrdlu"
04:02:25 <lambdabot>   "tonsrl"
04:02:30 <HaskellLove> I have a huge list should i use filter from Data.List or from Data.Set?
04:02:37 <IceDane> lol, this channel is awesome
04:02:43 <IceDane> One question and everyone's answering it
04:02:59 <mauke_> ivanm: look, no zip!
04:03:21 <ivanm> mauke_: zipWith has a zip in it!
04:03:34 <ivanm> HaskellLove: ummm... if you have a list, it's a no-brainer
04:04:03 <ivanm> I personally don't like doing operations like S.map, etc. because I'm worried that the continual re-organisation of the Set decreases efficiency
04:04:04 <int-e> > foldr (\x ~(as,bs) -> (x:bs, as)) ([],[]) "etaoin shrdlu"
04:04:05 <lambdabot>   ("eai hdu","tonsrl")
04:04:15 <ivanm> so I do a lot of S.fromList . foo . S.toList
04:04:23 <ivanm> (also, there's no S.mapMaybe :p )
04:04:39 <ivanm> int-e: ooohhh.... nice!
04:04:40 <HaskellLove> ivanm what do you mean, i should use filter from Set?
04:04:53 <ivanm> I can never remember... why do you need ~ there?
04:05:00 <ivanm> HaskellLove: you have a list; why use Set.filter?
04:05:01 <int-e> to make it work on infinite lists
04:05:35 <HaskellLove> ivanm Set operations are faster since order does not matter?
04:05:44 <ivanm> int-e: ahhh, yes
04:05:49 <ivanm> HaskellLove: ummm...
04:05:55 <ivanm> Set operations are faster on lookup
04:05:58 <int-e> > take 10 . fst $ foldr (\x ~(as,bs) -> (x:bs, as)) ([],[]) [0..] -- causes a stack overflow without ~
04:05:59 <lambdabot>   [0,2,4,6,8,10,12,14,16,18]
04:06:12 <ivanm> I mean, Set operations are faster for arbitrary insert, delete, member, etc.
04:06:37 <ivanm> HaskellLove: so you only really use them if you need an ordering of elements or you want efficient membership testing
04:06:57 <HaskellLove> got it thank you so much
04:07:07 <ivanm>  take 10 . fst $ foldr (\x (as,bs) -> (x:bs, as)) ([],[]) [0..]
04:07:18 <ivanm> HaskellLove: see, that's the kind of question you should be asking here, not basic stuff ;-)
04:07:23 <ivanm> > take 10 . fst $ foldr (\x (as,bs) -> (x:bs, as)) ([],[]) [0..]
04:07:25 <lambdabot>   * Exception: stack overflow
04:07:27 <ivanm> yup
04:07:30 <ivanm> it does :s
04:07:37 <mauke_> > map (!! 1) . filter (toEnum . fromEnum . head) . takeWhile ((> 1) . length) . transpose $ [cycle "\NUL\SOH", "etaoin shrdlu"]
04:07:38 <lambdabot>   "tonsrl"
04:07:43 <mauke_> ivanm: BLAM
04:07:55 <ivanm> :o
04:08:04 <ivanm> what's the \NUL and \SOH characters?
04:10:30 <ski> > map ((toEnum . fromEnum) `asTypeIn` filter) "\NUL\SOH"
04:10:32 <lambdabot>   [False,True]
04:11:03 <ivanm> @type asTypeIn
04:11:04 <lambdabot> forall a b. a -> (a -> b) -> a
04:11:11 <ivanm> gah!
04:11:15 <ivanm> is that a dynamic typing thing?
04:11:19 <ivanm> @hoogle asTypeIn
04:11:19 <lambdabot> No results found
04:11:26 <ivanm> @index asTypeIn
04:11:27 <lambdabot> bzzt
04:11:28 <mauke_> @djinn a -> (a -> b) -> a
04:11:29 <lambdabot> f a _ = a
04:11:30 <ivanm> bah
04:11:31 <mauke_> ^ that
04:11:38 <IceDane> god, haskell is perfect for wordlist processing
04:11:41 * ivanm facepalms
04:12:07 <ivanm> @type (toEnum . fromEnum) `asTypeIn` filter
04:12:08 <lambdabot> forall a. (Enum a) => a -> Bool
04:12:19 <ivanm> @type toEnum . fromEnum
04:12:21 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
04:12:33 <ski> > map (toEnum . fromEnum :: Char -> Bool) "\NUL\SOH"  -- just another way of saying this
04:12:35 <lambdabot>   [False,True]
04:13:09 <ivanm> oh, wait, it constrains the _a_, not the a -> b
04:13:22 <ski> yes :)
04:13:24 <ski> @type filter
04:13:26 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:13:42 <ivanm> so where does the -> [a] -> [a] bit go from the filter?
04:13:47 <ivanm> ski: I know the type of filter ;-)
04:13:57 <mauke_> ivanm: that's b
04:14:04 <mauke_> and ignored, because we never call filter
04:14:10 <ski> the `[a] -> [a]' bit from `filter' matches the `b' in `asTypeIn'
04:14:34 <ivanm> oh, right, it only constrains the a part
04:14:46 * ivanm is having a really slow day today
04:15:08 <ivanm> I managed to work out that a big bug I had came about because of a new feature I added subtly changing other stuff
04:15:45 <ivanm> still haven't managed to work out how my first fix for that bug ended up with a <<loop>> though :s
04:26:42 <HaskellLove> what am i suposed to use from Data.Map to get the list from this [(5,[0,2,5,10,17])? elemAt does not work, what i need is given the key 5 to get the list [0,2,5,10,17]
04:28:10 <doserj> @hoogle a -> [(a,b)] -> b
04:28:11 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
04:28:11 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
04:28:11 <lambdabot> Language.Haskell.TH RecConE :: Name -> [FieldExp] -> Exp
04:28:23 <b_jonas> lookup 8 [(5,"foo"), (8,"bar")]
04:28:55 <medfly> > lookup 8 [(5,"foo"), (8,"bar")]
04:28:56 <lambdabot>   Just "bar"
04:29:05 <HaskellLove> oh great
04:29:18 * doserj wonders what this has to do with Data.Map, though
04:30:32 <ivanm> doserj: the fact that it isn't a Map? ;-)
04:31:36 <copumpkin> it also isn't a Set
04:31:53 <copumpkin> and isn't even a DList!
04:32:13 <HaskellLove> ok one more question and i am done: (7,[0,2,5,10,17,28,41]) am i suposed to convert to list and get the last element of that list or i can do it with Data.Map, that is, to retreive last element of the value
04:32:27 <HaskellLove> but it seems i will have to convert to list
04:32:50 <ivanm> HaskellLove: you _are_ using a list...
04:33:03 <ivanm> you're not using a Map!
04:33:30 <copumpkin> @let strength = uncurry (fmap . (,))
04:33:31 <lambdabot>  Defined.
04:33:31 <HaskellLove> this is a Map b = M.findMax (M.fromList a)
04:33:39 <copumpkin> o.O
04:33:50 <copumpkin> > strength (7,[0,2,5,10,17,28,41])
04:33:52 <lambdabot>   [(7,0),(7,2),(7,5),(7,10),(7,17),(7,28),(7,41)]
04:34:00 * copumpkin flexes his muscles
04:34:09 <sohum> how do I get cabal to build with optimisations?
04:34:26 <Ke> cabal install --help
04:34:40 <Ke> I think there was a flag
04:34:53 <benmachine> have a look at .cabal/config
04:35:02 <benmachine> there is a line in mine commented out that says
04:35:09 <benmachine> -- optimization: True
04:35:18 <mauke_> yeah, because that's the default
04:35:19 <benmachine> I'd guess that has something to do with it
04:35:48 <sohum> yeesh. that slow with optimisations enabled
04:35:51 * hackagebot upload: hack-handler-simpleserver 0.2.0.1 - A simplistic HTTP server handler for Hack. (MichaelSnoyman)
04:39:50 <HaskellLove> is M.findMax $ M.fromList $ zip [1..] [4,5,6,7 bla bla bla] faster then elemIndex (maximum (map length a)) a
04:40:44 <Botje_> maximum (map length) looks slow.
04:41:14 <Botje_> but your snippets are not easy to understand without context
04:41:42 <copumpkin> they don't even do the same thing do they?
04:42:02 <HaskellLove> Botje well no need for context here... i need to get the maximum element of one list and use its index in that list to retreive an element from another list
04:42:15 <HaskellLove> M stands for Map
04:43:51 <HaskellLove> let ind = elemIndex (maximum a) a where a = (map length a); and then use ind to get an element from another list
04:44:00 <HaskellLove> but the Data.Map thing seems lot faster
04:44:10 <Botje_> uh, yeah. ;)
04:44:56 <Ferdirand> snd . max $ zip l1 l2 ?
04:45:17 <Ferdirand> maximum, not max
04:46:38 <ski> @type let a = map length a in a
04:46:39 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
04:46:40 <lambdabot>       Expected type: [[a]]
04:46:40 <lambdabot>       Inferred type: [Int]
04:47:46 <Phyx-> is there a way to see the C-- code that ghc generates?
04:48:53 <Phyx-> i'm using CWString with FFI and expecting wchar_t* in C, but wprintf only seems to print the first char
04:50:47 <ivanm> Phyx-: --dump or something?
04:50:53 <ivanm> IIRC, there is some way but it's a PITA
04:51:34 <aiko> I'm trying to install the dependencies for haskell-torrent with cabal on debian... what am I doing wrong? (First time working with hackage) http://pastebin.ca/1741360
04:52:07 <aiko> I did cabal update and cabal install cabal-install before without problems
04:52:07 <Phyx-> ivanm: alright, i'll search the manual
04:52:31 <ivanm> aiko: which version of ghc do you have?
04:52:47 <mauke_> huh
04:52:50 <ivanm> aiko: did you do "cabal install base" or something?
04:53:01 <ivanm> looks like you need to explicitly tell cabal-install to use base-4
04:53:13 <doserj> aiko: you need ghc-6.10.x
04:53:13 <ivanm> --constraint="base == 4.*" IIRC
04:53:24 <ivanm> oh, yeah, he's using 6.8.2
04:53:46 <ivanm> aiko: the haskell platform is available for debian (since you seem to be using a debian derivative)
04:53:49 <Phyx-> ah, -ddump-cmm
04:54:12 <ivanm> Phyx-: of course! it's obvious!
04:54:13 <ivanm> ;-)
04:54:49 <Phyx-> ivanm: hehehe
04:56:38 <aiko> ivanm, doserj: so should I install a newer ghc or install the haskell-platform?
04:56:58 <ivanm> aiko: the haskell platform includes newer ghc
04:58:47 <HaskellLove> anyone has solved euler 50? I think i can make a 20 times improvement of mine, so i want to check if i am crazy or not
04:58:55 <doserj> aiko: I don't think there is a haskell-platform package for debian stable
04:59:01 <koeien37> not for debian stable
04:59:05 <ski> > let as = "haskell" in permute (fst (randomR (0,product [1..length as]-1) (mkStdGen 738752981))) as
04:59:06 <Phyx-> I've always wondered why ghc puts the "compiling" messeages on StdErr. they're not really errors, I would expect them to be on StdOut, either that, or the documentation on createProcess is wrong (in the order of the handles)
04:59:07 <lambdabot>   "klaeslh"
04:59:10 <koeien37> back then HP hadn't released yet, I suppose
04:59:26 * ski for some reason thinks that looks like a strange spelling of "kleisli" ..
05:00:05 <koeien37> Phyx-: stderr is also often used for progress
05:00:20 <Phyx-> koeien37: any reason for that?
05:00:40 <mauke_> because they're not part of the main program output
05:00:48 <koeien37> I don't know really. ghc is not supposed to have other output
05:01:10 <mauke_> uh, how about the generated code
05:01:18 <Phyx-> that's never on stdout
05:01:20 <koeien37> eh, yeah, right, but that never goes to the terminal
05:01:39 <mauke_> we're talking about stdout/stderr, not the terminal
05:01:53 <mauke_> Phyx-: that's no reason to move secondary/diagnostic messages to stdout
05:02:18 <koeien37> where do you think make should print its progress, then?
05:02:40 <mauke_> that's a good question
05:02:54 <ivanm> what does gcc do?
05:03:08 <koeien37> gcc doesn't print progress
05:03:19 <koeien37> if you pass --verbose, then stderr
05:03:22 <ivanm> IIRC, javac spits everything out to stderr as well which it admits is a bug but doesn't want to change anything because people have scripts expecting it on stderr, etc.
05:03:59 <mauke_> gcc -E puts code on stdout
05:03:59 <koeien37> warnings also go to stderr
05:04:07 <koeien37> that's the preprocessor output?
05:04:16 <mauke_> yeah
05:04:21 <koeien37> yeah that makes sense
05:04:21 <aiko> doserj: sadly, there does not seem to be a platform package for debian testing (which I'm using) either
05:04:27 <koeien37> then the rest really should go to stderr
05:05:10 <mauke_> gcc -xc /dev/stdin -o /dev/stdout  # whee
05:05:10 <ivanm> aiko: there is IIRC
05:05:16 <ivanm> @google haskell platform debial
05:05:18 <lambdabot> http://wiki.debian.org/Haskell/Platform
05:05:19 <lambdabot> Title: Haskell/Platform - Debian Wiki
05:05:50 <doserj> aiko: you can install the generic ghc-6.10.4 linux binary, and then install the haskell-platform source package
05:06:04 <ivanm> does arjanoosting == arjan from debian?
05:06:40 <ivanm> if so, someone should tell him about how versioning works (stable vs unstable) for regex-*
05:06:41 <koeien37> oh there is -ddump-splices of course
05:06:46 <koeien37> that also goes to stderr
05:06:53 <koeien37> but the Loading package.... stuff goes to stdout
05:07:39 <koeien37> so it's a bit all over the place
05:07:41 <tromp_> > sum [100,110..190]
05:07:42 <lambdabot>   1450
05:07:59 <ski> > take 24 $ (`map` [0 ..]) $ \i -> zipWith const (permute i ['a' ..]) (takeWhile (<= i) (scanl (*) 1 [1 ..]))
05:08:01 <lambdabot>   ["","ba","acb","cab","bca","cba","abdc","badc","adbc","dabc","bdac","dbac",...
05:08:35 <aiko> doserj: does that link mean there is one? I know that I get "E: Package haskell-platform has no installation candidate"
05:09:29 <koeien37> aiko: no afaik it's only in unstable
05:09:33 <doserj> aiko: I meant the tarball from http://hackage.haskell.org/platform/
05:09:57 <koeien37> you need to install GHC 6.10.4 first
05:10:19 <koeien37> there is a binary available. It works on x86 and x86_64, maybe other platforms too.
05:10:21 <koeien37> then you can install HP
05:10:37 <aiko> doserj: I think installing the tarball could break the debian xmonad package I'm using. I'll try installing from unstable
05:11:05 <koeien37> aiko: shouldn't happen, it should be installed in /usr/local . I don't have this setup myself though.
05:11:26 <koeien37> but installing from unstable is fine, too, if it's available
05:14:20 <sohum> cabal configure --enable-executable-profiling -- does it enable profiling for the "Other modules" used?
05:15:02 <Saizan> sohum: yes
05:15:05 <Phyx-> brb
05:18:45 <sohum> Saizan: then what does it mean, in my profiling output, that cost centre MAIN has 90% individual %time and %alloc and like a few other things are 3% or 1.5% or something, and everything else is 0.0%?
05:19:56 <Saizan> sohum: did you use -auto-all and -caf-all?
05:20:16 <sohum> Saizan: don't think so. where do they go?
05:21:17 <koeien37> ghc -auto-all -caf-all --make ...
05:21:36 <sohum> hm. I'm not making it, cabal is...
05:22:21 <Saizan> sohum: put them in ghc-prof-options:
05:23:10 <Saizan> http://hackage.haskell.org/packages/archive/criterion/0.4.1.0/criterion.cabal <- i had to find a cabal that was using it to find the name :)
05:24:06 <sohum> Saizan: aaah, thanks
05:28:17 <Phyx-> *clap clap clap*
05:28:19 <Phyx-> lol
05:29:03 <sunrayser> if I get "<<loop>>" as an "error message" from a haskell program, what does it mean?
05:29:19 <mauke_> sunrayser: you wrote an infinite loop
05:29:19 <Saizan> that you've circular definition
05:29:23 <Jafet> It solved the halting problem
05:29:35 <Saizan> take that, turing!
05:29:43 <sunrayser> how can I determine where?
05:29:52 <Jafet> Trace!
05:29:55 <dblhelix> Jafet: a particular instantiation of it, at least ;-)
05:30:09 <koeien37> yeah, the halting problem is sometimes (often?) solvable :)
05:30:23 <ivanm> sunrayser: with great difficulty by doing it manually :s
05:30:30 * ivanm just managed to track one of those down :s
05:30:48 <sohum> hm. it looks like cabal is silently ignoring ghc-prof-options?
05:30:54 <Saizan> you could try with the ghci debugger and -fbreak-on-exceptions
05:30:56 <sunrayser> the strange thing is that on Linux it doesn't tell me this error, it just sits there using no CPU
05:31:17 <mauke_> did you compile it? with optimizations?
05:31:34 <sunrayser> I think only -fglasgow-exts was on the command line
05:31:35 <ivanm> sunrayser: try getting it to print a value; if you pick the right value, that might force it to <<loop>> instead of hang
05:31:44 <Saizan> sohum: did you reconfigure with -p? try -v to see which arguments get passed to ghc
05:31:57 <Saizan> sohum: -v during build
05:31:58 <sunrayser> I know the value, it's read from a file, if I don't use that in that particular location, it works
05:32:09 <Saizan> sohum: and if you're using the install command you've to pass -p to that one
05:33:08 <sunrayser> it's actually a ([String], [String]) parsed from a haskell source file
05:33:23 <sohum> Saizan: ... -O ./Main.hs -prof -hisuf p_hi -osuf p_o -auto-all -caf-all, so it looks like it isn't ignoring them...
05:34:01 <Saizan> sohum: so maybe it does all happen in your main :)
05:34:10 <sohum> Saizan: but I still have monolithic CAF centres per module, and still have a 90% individual MAIN
05:34:16 <Phyx-> did someone say halting problem?
05:34:17 <b_jonas> so anyway, I know I've asked this already, but do you recommend me to use HaXmL or shoule I try another xml module instead?
05:34:31 <sunrayser> but it can actually print the (same!) value 3-4 times before crashing
05:35:12 <Saizan> sunrayser: it looks like it's something else then?
05:35:15 <b_jonas> I want to use it to get some values from a really simple xml file, and I want a module interface I like
05:36:03 <sunrayser> Saizan: it looks like a deadlock, at least on linux... but I don't think it's multithreaded
05:36:40 <sunrayser> Saizan: I mean, if I define the function as "origname", it works, if I define it as "show d", it crashes
05:36:56 <Saizan> sunrayser: <<loop>> is a genuine circular definition, it happens only when it's evaluating something that's defined non-productively in terms of itself
05:37:02 * b_jonas looks at the list of other modules in hackage -- one of those might be what I want
05:37:14 <sunrayser> Saizan: origname is a simple string, d is the data structure from the file which can be printed a few times before crashing
05:37:27 <Saizan> sunrayser: can you show the code?
05:37:49 <sunrayser> Saizan: which part? it's quite a big project
05:37:50 <Phyx-> Saizan: ah, it prints that when it enters a closure and finds it Blackholed already?
05:37:58 <Saizan> Phyx-: exactly
05:38:11 <koeien37> <<loop>> is not the best error message ever
05:38:27 <sunrayser> Saizan: but I'm interested if you can show a small example generating a <<loop>> and if you tell me why it doesn't complain at build time
05:38:30 <Saizan> sunrayser: the definition of d, and this part where you're using it seem the most relevant
05:38:34 <Phyx-> koeien37: could be worse i suppose
05:38:42 <koeien37> Phyx-: yeah. at least it's not patently false
05:39:06 <Saizan> sunrayser: if you compile main = print (let x = x in x) it'll show a <<loop>>
05:39:08 <koeien37> but what if I'm a user, I have never heard about Haskell, and I run a Haskell program, and this appears :(
05:39:35 <zygoloid> koeien37: is it better or worse than running a program and having it silently hang?
05:39:36 <b_jonas> koeien37: it's better than an infinite loop
05:39:42 <koeien37> true! certainly
05:39:45 <Saizan> sunrayser: with a type annotation
05:40:02 <koeien37> i'd expect something like: "The program you were running has gone into an infinite loop. This is a bug in the program." or so
05:40:09 <ivanm> sunrayser: it can't detect infinite loops at build time...
05:40:19 <koeien37> (also not at run-time)
05:40:33 <sunrayser> Saizan: ok here is the code that sems most relevant http://codepad.org/p5UG66lw here look at the getVariableName
05:40:43 <ivanm> koeien37: but it has some heuristics for detecting them, hence the <<loop>> ?
05:40:48 <koeien37> ivanm: yep
05:40:53 <ivanm> *nod*
05:41:00 <sohum> Saizan: it can't all happen in main anyway, because main is seven very simple lines that all call other things http://haskell.pastebin.com/m3b4b88ed
05:41:03 <koeien37> it could also detect some infinite loops at compile time
05:41:03 <ivanm> because it notices the same thing gets called with the same params?
05:41:09 <b_jonas> if you wanted a better error message, can't you just catch the exception?
05:41:21 <koeien37> b_jonas: oh, if it's an exception, then it's ok
05:41:28 <koeien37> i thought it would just crash the program
05:41:31 <b_jonas> I don't know if it is
05:41:38 <Saizan> sunrayser: so, to recap,  main = print (let x = x in x :: ()) compiled with optimizations
05:42:12 <gwern> fun. template-haskell no longer compiles
05:42:23 <gwern> I wonder what CharConstr is
05:42:26 <koeien37> gwern: yes.
05:42:36 <koeien37> gwern: well, it ought to compile on 6.12.1
05:42:51 <gwern> I am benighted on 6.10
05:43:02 <koeien37> then add --constraint='template-haskell < 2.4'
05:43:32 <b_jonas> gwern: isn't it a Typeable thingy?
05:43:52 <gwern> b_jonas: no idea. I've never seen those constructors before
05:44:41 <sunrayser> Saizan: btw I tried that flag and ghc.exe: unrecognised flags: -fbreak-on-exceptions
05:44:55 <Saizan> sunrayser: it's for the ghci debugger
05:45:02 <Saizan> ?google ghci debugger
05:45:03 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
05:45:04 <lambdabot> Title: 2.5.ï¿½The GHCi Debugger
05:45:39 <Saizan> btw, you can't upgrade template-haskell
05:46:03 <koeien37> Saizan: isn't it a bug in the package that there is no base >= 4.2 constraint?
05:47:17 <sohum> Saizan: any ideas?
05:47:19 <Saizan> koeien37: not sure if that's the right constraint, but i agree one is missing
05:47:43 <koeien37> iirc 4.2 is the version of the base package of GHC 6.12.1
05:47:45 <Saizan> sohum: no, sorry
05:48:06 <Saizan> koeien37: is CharConstr imported from a base module?
05:48:19 <benmachine> was there a base in between 4.1 and 4.2?
05:48:20 <sunrayser> how can I trace main with parameters?
05:48:50 <benmachine> @hoogle CharConstr
05:48:51 <lambdabot> No results found
05:48:51 <Saizan> sunrayser: there's something like :set args
05:49:03 <Jafet> sunrayser, rtfmwwla
05:49:15 <koeien37> @hoogle constrRep
05:49:16 <lambdabot> Data.Data constrRep :: Constr -> ConstrRep
05:49:16 <lambdabot> Data.Data data ConstrRep
05:49:21 <benmachine> CharConstr is in Data.Data
05:49:28 <benmachine> which is in base
05:49:28 <Jafet> Oh, they didn't document it in that page. Funny.
05:49:43 <sunrayser> hehe
05:49:57 <Jafet> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#id2899755
05:51:28 <sohum> ok, to recap. I'm trying to profile my cabal-built program that's one Main.hs and several other modules in Other Modules. I'm getting 90% individual allocation/time in MAIN, call centre no. 1, and the only cost centres for my modules are CAF. (Text.Parsec.Prim and suchlike take up the rest.) ghc-prof-options is -auto-all -caf-all, and I'm configuring with --enable-executable-profiling, which is borne out by my cabal build ...
05:51:35 <sohum> ... -v output. Any ideas?
05:54:02 <b_jonas> oh, typeable is in base because of extensible exceptions. makes sense.
05:54:56 <Saizan> sohum: i'd try compiling some of the lib you use with -auto-all -caf-all too, if they aren't already
05:55:17 <Axman6> you need -prof too no?
05:55:32 <sohum> Saizan: I installed the libs via cabal with cabal install -p, so I'd assume that's done
05:55:32 <Axman6> ... just... making sure people aren't forgetting something very trivial :)
05:55:42 <HaskellLove> anyone has solved euler 50? i am looking for optimizations
05:55:52 <Saizan> Axman6: --enable-executable-profiling passes that
05:56:15 <sohum> Axman6: if I didn't, I wouldn't have profiling output, I think. and yes, the timestamps are updating, I'm not just looking at a stale file
05:56:31 <Saizan> sohum: well no, they might be built for profiling but without the cost centres that -auto-all adds, since most of the time you're interested in the cost centres in your own code
05:56:42 <benmachine> so who do we tell if we think template-haskell needs a base>=4.2 constraint?
05:56:43 <Axman6> righto, i haven't been looking at what's been said too closely :)
05:56:49 <Axman6> (writing a new blog post :o)
05:57:08 <Saizan> benmachine: ghc devs/trac
05:58:19 <sohum> Saizan: fair enough, but I /am/ interested in the cost centres of my own code, which don't show up either.  Actually, come to think of it, only Parsec has non-CAF cost centres, and I'm using things like fgl that I'd not assume to be that speedy
05:59:20 <sohum> Saizan: (incidentally, cabal won't let you configure with --enable-executable-profiling if profiling-enabled versions of your libs aren't available
05:59:23 <sohum> )
05:59:49 <Saizan> sohum: (yeah, i know)
05:59:56 <sunrayser> Saizan: ok now I get GHCi runtime linker: fatal error: I found a duplicate definition for symbol   _hs_gtWord64
06:00:43 <Saizan> sunrayser: no idea on that
06:01:02 <sunrayser> Saizan: maybe I should try manual debugging...
06:01:03 <Saizan> sunrayser: i guess you've to carefully examine your source :)
06:01:39 <Saizan> maybe profiling could help
06:01:48 <sunrayser> Saizan: how?
06:02:21 <Saizan> well, if you compile without optimizations it will probably actually loop instead of detecting the loop and stopping
06:02:42 <Saizan> so, profiling might show a high time spent in the functions involved?
06:02:54 <Phyx-> wow, never press the red button...
06:04:21 <sunrayser> Saizan: hmm ok, can you give me a link other than google where to start on profiling?
06:04:28 <koeien37> RWH or the GHC manual
06:05:03 <sohum> it's actually really weird. this is my profiler output: http://haskell.pastebin.com/m9f49a2e
06:05:04 <Saizan> i suspect you might be reusing the same variable name on both sides of a let binding somewhere, meaning it should get shadowed, but actually defining a circular value
06:05:38 <koeien37> sohum: maybe it's true. what is your code?
06:05:52 <koeien37> Saizan: that is a common mistake for this, yeah
06:05:55 <sohum> koeien37: my main? http://haskell.pastebin.com/m3b4b88ed
06:05:58 <sunrayser> Saizan: I think I have no let bindings related to this part of the code
06:06:30 <sohum> the thing that gets me is that nothing other than Text.Parsec has /any/ cost centres at all
06:06:36 <koeien37> hmm, no, that can't be right
06:06:52 <sohum> lemme pastebin the line cabal build -v gives me
06:07:00 <_andy_> if i have a series of arrays allocated in c, is it more efficient to process as StorableArray's, or as regular lists (assuming pass on each array)?
06:07:02 <koeien37> did you clean in between?
06:07:19 <_andy_> *assuming one pass on each array
06:08:40 <sohum> http://haskell.pastebin.com/d4ed71e64 < cabal build -v
06:08:58 <ZekeDragon> Alright, I might as well speak up, and I apologize if my question is stupidly simple and obvious to a decent Haskell coder, but I'm pretty inexperienced at this language...
06:09:00 <ZekeDragon>  is it possible to make, and if so how do I write the type declaration of, a function who's parameter is defined as another function that accepts the same parameters at the function itself.
06:09:09 <koeien37> sohum: (I have no idea if it'll help) did you clean in between?
06:09:36 <sohum> koeien37: I've never needed to before; cabal is usually pretty good about detecting its own files' changes. I'll try it.
06:09:39 <gwern> > 50 `div` 2
06:09:40 <lambdabot>   25
06:09:55 <koeien37> ZekeDragon: I think that's an infinite type
06:10:19 <ZekeDragon> So it can't be done, okay.
06:10:29 <sohum> koeien37: ....what. it totally did help. grarrr cabal
06:10:36 <koeien37> ok cool :)
06:10:43 <sohum> and thanks Saizan and koeien37
06:10:45 <sunrayser> how can I "install the profling libraries" for a package?
06:10:53 <koeien37> cabal install -p package
06:10:59 <sunrayser> wow thanks
06:11:06 <Axman6> if needed, cabal install --reinstall -p <package>
06:11:20 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15691#a15691 <-- anyone know a better way to shift an entry in a Seq up?
06:11:51 <gwern> I don't want to swap/overwrite, just jump the last entry forward a ways and everything afterwards gets moved down an index
06:12:01 <koeien37> ZekeDragon: f is a function, so of type a -> b (for some a, b). then a should be a -> b too. this is an infinite type as I see it
06:12:17 <sunrayser> koeien37: Axman6: why doesn't it seem to handle package dependencies?
06:12:25 <Axman6> it does
06:12:25 <koeien37> it ought to
06:12:41 <Axman6> but you installed them without proviling
06:12:43 <Axman6> f*
06:13:03 <sunrayser> so do I have to reinstall all of them manually with profiling?
06:13:18 <zygoloid> gwern: i would think you could remove the last element of s more elegantly with viewr
06:13:37 <gwern> zygoloid: hm. think you're right
06:13:42 <ZekeDragon> I already knew I was trying to do something like f :: (a -> (a -> (a -> etc...))) though I had thought I read something in the piles of Haskell educational material I've went through that said that was kosher. Thanks koeien.
06:13:47 <_andy_> also, if i use peekCString, do i need to force the String (from IO String) if the underlying c allocated memory is at risk of being freed prior to the haskell String's use?
06:14:15 <koeien37> ZekeDragon: such a function would be useless, wouldn't it?
06:14:52 <zygoloid> gwern: maybe it's not more elegant; you'd have to explicitly deal with the case where the Seq is of size 1 or 2 :(
06:15:08 <zygoloid> (where s is empty)
06:15:12 <sohum> hm. why is a simple tree-walker allocating 150MB
06:15:31 <Axman6> because you're keeping reference to the now evaluated tree
06:15:36 <Axman6> i'd guess
06:15:38 <gwern> zygoloid: well, shift doesn't make much sense in those cases
06:15:42 <rovar_> i have a design question.  I am building a client for a database.  I have a context which stores sockets, channels, callback mappings, etc.  Currently the type is opaque and I pass it to all requests, and is used a lot in the hidden utility functions.
06:15:44 <ski> @type fix (In . const)  -- ZekeDragon
06:15:44 <gwern> zygoloid: so I guess a guard on the length
06:15:45 <lambdabot> forall b. Mu ((->) b)
06:16:00 <_andy_> rovar_:
06:16:03 <_andy_> :t StateT
06:16:04 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
06:16:24 <ZekeDragon> It was more of a mental exercise to see if I could write something that allowed pass itself and another function in as a tuple parameter, then perform some actions, and call the other function switching the tuple parameters. This way I could build the tuple at runtime based on user input.
06:16:26 * hackagebot upload: regions 0.2 - Provides the region monad for safely opening and working with  scarce resources. (BasVanDijk)
06:16:26 <rovar_> It would clean things up if I used a StateT, however, because of the usage model for the client, I don't want them to have to run their client code in my StateT
06:16:47 <_andy_> ah
06:16:54 <sohum> Axman6: "now-evaluated tree"?
06:16:55 <zygoloid> gwern: actually, s can't be empty (unless adb is) so i think it's prbably OK :)
06:17:06 <ski> ZekeDragon : hm, actually, that's (roughly) a function that *returns* a function of the same type .. not takes it as argument
06:17:15 <gwern> zygoloid: nah, I'm just going to change the function to 'shift n adb = if n < 2 âˆ¨  lst < 2 then adb else r' >< s''
06:17:26 * hackagebot upload: regions-monadsfd 0.2 - Monads-fd instances for the RegionT monad transformer (BasVanDijk)
06:17:29 <Axman6> sohum: you're going to have to share more details about what you're doing to get some help :P
06:17:44 <ski> ZekeDragon : which tuple do you want to avoid building ?
06:18:01 <rovar_> it almost makes sense to make a global TMVar (and completely encapsulated)
06:18:34 * hackagebot upload: regions-monadstf 0.2 - Monads-tf instances for the RegionT monad transformer (BasVanDijk)
06:18:55 <_andy_> rovar_: will this be a threaded?
06:19:01 <_andy_> *threaded application
06:19:02 <gwern> ah, instead of throwing away the last entry with (s' :> _), I can rename the underscore and remove the S.index line!
06:19:16 * zygoloid nods
06:19:36 * hackagebot upload: usb-safe 0.5 - Type-safe communication with USB devices. (BasVanDijk)
06:19:38 <rovar_> yea.. i forkIO the socket and commandChannel listeners
06:20:07 <zygoloid> might be clearer if you viewr then split rather than splitting then viewring
06:20:35 <ZekeDragon> It'd be like this: func (other, this) = {- do stuff -} other (this, other)    then other would call this (other, this) and I could call func initially as "func (someOtherFunction, func)". But yeah I guess it's not really sensible, I'll try something else.
06:20:53 <sohum> Axman6: it's basically f :: Tree String -> [String] that collects the leaves. It's slightly more complicated than that (and I'll pastebin the ~fifteen-line gory details if you like) but that's basically it
06:21:33 <ski> ZekeDragon : so a bit like two coroutines, then ?
06:21:35 * hackagebot upload: safer-file-handles 0.2 - Type-safe file handling (BasVanDijk)
06:21:45 <gwern> zygoloid: maybe, but that doesn't shorten it any?
06:22:43 <ski> ZekeDragon : i think it could be sensible (.. i've done something a bit similar, i think)
06:22:56 <zygoloid> gwern: view patterns might help: let shift n (viewr -> (divide n -> (xs, ys)):>x) = xs |> x >< ys; shift _ xs = xs; divide n xs = splitAt (length xs `div` n)
06:23:09 <ZekeDragon> ski: yeah, something like that. I think I'll end up using a higher-order function that just calls each one back and forth and uses a counter or some condition to stop.
06:23:14 <gwern> zygoloid: what the heck is that?
06:23:39 <Axman6> sohum: well, i'm interested, so go ahead :P
06:23:41 <gwern> hm. what's the character of the delete key?
06:23:45 <gwern> '\d'?
06:23:48 <zygoloid> \DEL
06:23:51 <ski> ZekeDragon : btw, is there a reason you don't just let `func' and `someOtherFunction' call each other directly, rather than indirectly ?
06:24:00 <Jafet> > '\DEL' == chr 127
06:24:01 <benmachine> huh, the docs for base 4.2 aren't on hackage
06:24:02 <lambdabot>   True
06:24:16 <HaskellLove> I am working on euler 50. In Octave I did this http://img138.imageshack.us/img138/6863/screenshotcl.png Those are values for 100,1000,10 000 and 100 000. So you have 4 breakpoints, the 100 one is so small you can barely see it at the start. So now having that, can i predict what will happen for input 1 000 000? Or there is no pattern in euler 50?
06:24:17 <ZekeDragon> Because someOtherFunc may be aThirdFuncIMadeToday, or thatOtherFuncIForgot.
06:24:26 <Axman6> > ord '\DEL'
06:24:27 <lambdabot>   127
06:24:49 <zygoloid> gwern: '\b' is backspace, which is probably what you want (U+0008)
06:24:55 <ZekeDragon> ski: I want to be able to choose which one it'll be at runtime.
06:24:57 <gwern> no, I want delete key
06:25:02 <ski> ZekeDragon : ok, so you want the ability to combine .. ah, right
06:25:10 <gwern> (since it's a delete-buffer/article action)
06:25:30 <ski> ZekeDragon : i think you want to make a recursive type (probably using `newtype')
06:25:59 <ZekeDragon> Googling...
06:26:16 <gwern> > show 5 :: Char
06:26:17 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:26:17 <lambdabot>         against inferred type...
06:26:30 <ski> ZekeDragon : what do you want to return from the function(s) ?
06:26:35 <ski> a monadic action of some kind ?
06:26:41 <gwern> @hoogle (Show a) => a -> Char
06:26:41 <lambdabot> Prelude show :: Show a => a -> String
06:26:42 <lambdabot> Text.Show show :: Show a => a -> String
06:26:42 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
06:26:45 <gwern> bah
06:27:02 <ski> > intToDigit 5
06:27:04 <lambdabot>   '5'
06:27:06 <ZekeDragon> ski: I intended it to be a monadic function, yes.
06:27:13 <ski> ZekeDragon : of what type ?
06:27:15 <ski> `IO ()' ?
06:27:21 <ZekeDragon> ski: Yes.
06:27:25 <ski> then try
06:27:29 <sohum> Axman6: http://haskell.pastebin.com/m31f43808
06:27:30 <gwern> :t zip
06:27:32 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
06:27:33 <ski>   newtype Foo = MkFoo ((Foo,Foo) -> IO ())
06:27:39 <gwern> :t zipWith
06:27:40 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
06:27:51 <ski> or, i suppose
06:27:59 <ski>   newtype Foo = MkFoo {apFoo :: (Foo,Foo) -> IO ()}
06:28:01 <gwern> :t cycle
06:28:02 <lambdabot> forall a. [a] -> [a]
06:28:03 <ski> will be slightly more handy
06:28:05 <gwern> :t repeat
06:28:06 <lambdabot> forall a. a -> [a]
06:28:12 <ZekeDragon> ski: All right, I'll give those a shot. Thanks for the help!
06:28:32 <ski> ZekeDragon : so `Foo' is the type of (packaged) functions that take two `Foo's as argument and return `IO ()'
06:28:40 <sohum> Axman6: uh, try http://haskell.pastebin.com/m5185f0fd instead
06:29:03 <ski> so instead of
06:29:16 <ski>   func (other, this) = do stuff; other (this, other)
06:29:22 <ski> you need to say
06:29:32 <ski>   func (other, this) = do stuff; other `apFoo` (this, other)
06:29:40 <ski> and instead of
06:29:49 <ski>   func (someOtherFunction, func)
06:29:51 <ski> you say
06:29:58 <ski>   func (MkFoo someOtherFunction, MkFoo func)
06:30:01 <ski> ZekeDragon : ok ?
06:30:07 <ZekeDragon> ski: Okay, got it.
06:30:44 <ski> the `MkFoo' and `apFoo' are only for converting between `Foo' and `(Foo,Foo) -> IO ()'
06:31:09 <ski> .. since those two types are not the same type, but a value of the former contains a value of the latter
06:31:51 <ZekeDragon> ski: All right. You've been extremely helpful, thank you.
06:32:03 <ski> np :)
06:32:22 <ZekeDragon> I'm going to read up on newtype and everything else you've alluded to, and I'll experiment with this.
06:32:40 <ski> if Haskell had cyclic types, you could just have said
06:32:48 <ski>   type Foo = (Foo,Foo) -> IO ()
06:33:11 <ski> then those two types would have been the same (and `MkFoo' and `unFoo' wouldn't have been needed)
06:33:54 <ski> but since it doesn't (for reasons of catching more type errors), you need to do the `newtype' (or `data') trick instead, explicitly wrapping and unwrapping
06:37:14 <ski> (minor note : if you change `(Foo,Foo)' into `[Foo]', then you're not far off a (cooperative) thread monad)
06:37:40 <sunrayser> Saizan_: with profiling I got a GHC internal error...
06:37:42 <ZekeDragon> ski: Uh oh, more Googling material.
06:38:09 * ski idly wonders what there was to oogle in that ..
06:39:40 <gwern> sunrayser: using the ghc api?
06:39:44 <gwern> they don't mix at all
06:40:00 <sunrayser> I'm using a wrapper (hint)
06:40:44 <gwern> same thing
06:40:48 <gwern> it's an old bug
06:41:45 <sunrayser> I see
06:49:46 * hackagebot upload: regions-monadstf 0.2.0.1 - Monads-tf instances for the RegionT monad transformer (BasVanDijk)
06:53:06 <sohum> hm. using lists instead of sets in my code gives me a 57% speedup and a 41% memory savings. The only thing I'm doing with these sets (lists) is union (++) and member (elem)
06:53:22 <koeien37> elem is O(log n) instead of O(n)
06:53:38 <koeien37> also (++) may be even slower than you'd expect if you use it incorrectly
06:54:06 <sohum> what? since when?
06:54:24 <sohum> how can elem be O(log n)?
06:54:35 <koeien37> erm, it's called member
06:54:51 <koeien37> elem is O(n)
06:54:56 <sohum> yea, that's what I thought
06:55:14 <sohum> I'm getting the speedup moving from Sets to lists
06:56:25 <shambler> sets can be lists
06:56:36 <sohum> from Data.Set, specifically
06:56:39 <shambler> oh
06:56:47 <lpsmith> sohum,  you might find data-ordlist useful :)
06:56:58 <lpsmith> Although I need to add some specializations
06:57:11 <lpsmith> I'm not sure what specializations would be the most useful though
06:57:40 <sohum> lpsmith: I have no way of guaranteeing the input lists are ordered :(
06:58:42 <CalJohn> sohum: i can only think that you are somehow benefiting from laziness, I would've thought Set would be slower than List for those two operations
06:58:42 <lpsmith> sohum:  thats what sort is for :-P
06:58:54 <sohum> lpsmith: :P
06:59:07 <sohum> CalJohn: is Set strict or something?
06:59:19 <lpsmith> well,  simple linked lists can outperform trees on small datasets
06:59:23 <quicksilver> yes, Set is strict.
06:59:30 <koeien37> it must be, because it has to evaluate (<)
06:59:32 <quicksilver> (++) is faster than union, anyhow
06:59:39 <Axman6> sohum: i'd be interested to see how Seq fares
06:59:45 <quicksilver> (++) is O(n) and union is O(n log n)
06:59:49 * sohum tries Data.Seq!
06:59:53 <lpsmith> not least because trees have an extra pointer (either 32 bits or 64 bits) per node,  and if your elements are small,  that means lists are more likely to fit into cache
07:00:03 <Axman6> sohum: i'm not expecting an improvement though :)
07:00:10 <sohum> quicksilver: well, O(max(n1,n2))
07:00:42 <CalJohn> quicksilver: i thought union was O(n+m)?
07:01:09 <a1o> sup friends
07:02:38 <sohum> :t elem
07:02:40 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:02:51 <sohum> @hoogle (Eq a) => a -> Seq a -> Bool
07:02:52 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
07:02:52 <lambdabot> Data.Foldable notElem :: (Foldable t, Eq a) => a -> t a -> Bool
07:02:52 <lambdabot> Prelude (/=) :: Eq a => a -> a -> Bool
07:03:01 <sohum> ah, foldable
07:03:49 <a1o> could anyone explain noob, what => means, regarding function definition and types?
07:03:57 <quicksilver> CalJohn: don't think so.
07:04:02 <quicksilver> sohum: same thing ;)
07:04:07 <Axman6> a1o: it's a class constraint
07:04:10 <Axman6> :t (+)
07:04:12 <lambdabot> forall a. (Num a) => a -> a -> a
07:04:13 <quicksilver> sohum: (but more precise, in a sense)
07:04:42 <Axman6> a1o: that means that the functions (+) takes two elements, who are of the same type, and that type must implement the Num class
07:04:43 <quicksilver> sohum: well actually, no, less precise, in the sense of wrong ;)
07:04:57 <Axman6> so, (+) can only work on numbers (things which implement Num)
07:04:59 <quicksilver> sohum: if you want to be more specific, it's O(n1) i.e. the left list.
07:05:04 <Axman6> @src Num
07:05:05 <lambdabot> class  (Eq a, Show a) => Num a  where
07:05:05 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:05:05 <lambdabot>     negate, abs, signum     :: a -> a
07:05:05 <lambdabot>     fromInteger             :: Integer -> a
07:05:20 <shambler> @hoogle union
07:05:20 <lambdabot> Data.IntMap union :: IntMap a -> IntMap a -> IntMap a
07:05:20 <lambdabot> Data.IntSet union :: IntSet -> IntSet -> IntSet
07:05:20 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
07:05:36 <CalJohn> quicksilver: do you mean Data.List.union?
07:05:51 <CalJohn> (i assume you do, and i'm confused)
07:06:00 <shambler> @src union
07:06:00 <lambdabot> union = unionBy (==)
07:06:04 <a1o> Axman6: thx, understood
07:06:07 <shambler> @src unionBy
07:06:07 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
07:06:17 <quicksilver> CalJohn: no, I mean Set.union, because that's what we were talking about ;)
07:06:27 <koeien37> that's O(n+m)
07:06:41 <koeien37> pretty sure of that
07:06:42 <sohum> @hoogle (++)
07:06:42 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
07:06:43 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
07:06:43 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
07:06:47 <Axman6> isn't numBy O(n^2)?
07:06:52 <Axman6> nubBy*
07:06:58 <koeien37> yeah
07:07:00 <koeien37> :t nubBy
07:07:02 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
07:07:05 <koeien37> @src nubBy
07:07:06 <lambdabot> nubBy eq []             =  []
07:07:06 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
07:07:14 <quicksilver> List.union should be O(n*m) I'd have thought, without thinking very carefully
07:07:17 <sohum> quicksilver: well, I was thinking in the sense of worst case scenario, not given knowledge of which n/m is for which. but sure.
07:07:22 <CalJohn> http://xrl.in/4715 <- O(n+m)
07:07:26 <shambler> how Data.Sets are implemented?
07:07:30 <quicksilver> trees
07:07:34 <koeien37> shambler: balanced binary trees
07:07:38 <sohum> @src Monoid
07:07:38 <lambdabot> class Monoid a where
07:07:39 <lambdabot>     mempty  :: a
07:07:39 <lambdabot>     mappend :: a -> a -> a
07:07:39 <lambdabot>     mconcat :: [a] -> a
07:07:45 <Axman6> sohum: did you try Seq yet?
07:07:45 <quicksilver> CalJohn: oh, that's odd
07:07:48 * quicksilver thinks it through.
07:07:48 <sohum> oh, right, mappend
07:07:48 <HaskellLove> how can i now predict the answer for 1 000 000 ? http://img141.imageshack.us/i/screenshot1yy.png/
07:07:58 <sohum> Axman6: gimme a sec, need to generalise :P
07:08:05 <koeien37> quicksilver: in operational terms, it's just the merge of two ascending lists
07:08:28 <Axman6> sohum: git to it! i need to go to sleep :P
07:08:36 <quicksilver> koeien37: sure, but it's not clear the the work rebuilding the tree as go along doesn't increase the complexity.
07:08:53 <quicksilver> clever.
07:08:55 <koeien37> quicksilver: fromAscList
07:09:01 <koeien37> + toAscList
07:09:14 <koeien37> that would be a naive implementation, but still O(n+m)
07:09:15 <quicksilver> hmm yes good point.
07:09:28 <sohum> @hoogle concatMap
07:09:29 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
07:09:29 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
07:09:29 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
07:09:38 <sohum> gr
07:10:20 <sohum> :t concatMap
07:10:21 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:10:24 <sohum> :t mconcat . fmap
07:10:26 <lambdabot>     Couldn't match expected type `[a]'
07:10:26 <lambdabot>            against inferred type `f a1 -> f b'
07:10:26 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
07:10:35 <koeien37> :t (mconcat .) . fmap
07:10:36 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> [a1] -> a
07:10:44 <sohum> right, thank you
07:11:07 <sohum> wait
07:11:30 <sohum> :t fmap
07:11:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:11:35 * Axman6 goes to sleep
07:11:37 <sohum> :t mconcat
07:11:39 <lambdabot> forall a. (Monoid a) => [a] -> a
07:11:44 <sohum> oh, there
07:12:02 <sohum> that... actually doesn't matter for my case
07:15:10 <sohum> :t (:)
07:15:12 <lambdabot> forall a. a -> [a] -> [a]
07:15:30 <sohum> :t \x xs -> (return x) `mappend` xs
07:15:32 <lambdabot> forall a (m :: * -> *). (Monad m, Monoid (m a)) => a -> m a -> m a
07:15:46 <koeien37> :t point
07:15:47 <lambdabot> Not in scope: `point'
07:15:54 <koeien37> :t pure
07:15:55 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
07:16:40 <koeien37> :t \x xs -> (return x) `mplus` xs
07:16:42 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => a -> m a -> m a
07:17:40 <sohum> @pl \a b -> f (g a) b
07:17:40 <lambdabot> f . g
07:18:00 * sohum blink
07:18:03 <sohum> :t mappend . pure
07:18:04 <lambdabot> forall a (f :: * -> *). (Monoid (f a), Applicative f) => a -> f a -> f a
07:18:21 * sohum <3 haskell
07:18:41 <koeien37> that's the spirit!
07:18:56 * sproingie â™£  Java
07:19:15 <sohum> ...what
07:19:20 <sohum> I can't import hiding ((:))?
07:19:34 <Beelsebob> sohum: (:) isn't a function
07:19:40 <Beelsebob> it's a constructor
07:19:57 <sohum> aren't... constructors functions?
07:20:05 <Beelsebob> yes, but also no
07:20:06 <sproingie> yeah but import treats them differently
07:20:13 <koeien37> they are functions but more
07:20:31 <Beelsebob> koeien: or functions, but less, depending on how you look at them
07:20:34 <sproingie> you'd have to be able to do something like hiding ([]((:)))
07:20:41 <sproingie> which of course doesn't work
07:21:29 <sohum> so basically I can't override (:) in my code. lovely.
07:21:38 <sproingie> alas
07:21:40 <sohum> I retract my previous <3
07:21:52 <koeien37> boo
07:23:00 <sproingie> you can override string literals, but still not lists
07:23:03 <Beelsebob> sohum: I guess the reason is that it breaks list syntactic sugar... it's annoying how many corner cases such seemingly inocuous things bring in
07:23:15 <Beelsebob> sproingie: how does one override string litterals?
07:23:18 * sohum grumble grumble
07:23:24 <sproingie> Beelsebob: it's a ghc flag somewhere
07:23:29 <Beelsebob> randomness, and cool!
07:23:34 <sohum> Beelsebob: there's an option. gives you IsString a => a
07:23:37 <koeien37> {-# LANGUAGE OverloadedStrings #-} iirc
07:23:41 * Beelsebob hates list syntactic sugar
07:23:52 <sproingie> lets you turn strings into bytestrings for instance
07:23:53 <Beelsebob> it doesn't actually make writing a list take any less time, or be any clearer
07:24:02 <koeien37> it's arguably clearer
07:24:06 <Beelsebob> but it does add lots of corner cases
07:24:09 <sohum> hm, Data.Sequence doesn't have an Applicative instance
07:24:19 <Beelsebob> and reserve (,) to be something special, not just an operator
07:24:24 <sproingie> does [] and : desugar to something more explicit in core?
07:24:41 <Beelsebob> sproingie: no, but [a,b,c] does
07:24:46 <sohum> I could write Monad m => Applicative m, or I could write (<|) = mappend . return
07:24:48 <Beelsebob> (a:b:c:[])
07:25:31 <Saizan_> is Seq an instance of Monad?
07:25:31 <pozic> Beelsebob: What about allowing [1,2,3]::Array Int Int?
07:25:31 <Beelsebob> sohum: unfortunately instance Monad m => Applicative m where... doesn't do quite what you think
07:26:06 <kpreid> Beelsebob: even if lists weren't existant , would still be special
07:26:12 <pozic> Beelsebob: or [1,2,3]::(Int,Int,Int)
07:26:15 <Beelsebob> kpreid: really, why?
07:26:23 <kpreid> for example, its uses in list comprehension syntax
07:26:42 <sproingie> pozic: the latter is a tuple
07:26:43 <kpreid> also, that ((a,b),c) is different from (a,b,c) is different from (a,(b,c)) (bottoms)
07:26:52 <Beelsebob> kpreid: | is used in comprehension syntax too
07:27:12 <Beelsebob> but is still available as a symbol
07:27:13 <pozic> sproingie: I mean overloading the syntax for [] for arbitrary collection types.
07:27:25 <pozic> sproingie: e.g. [1,2,3]::Seq Int would also work.
07:27:28 <Beelsebob> pozic: I would rather just remove the special syntax
07:27:36 <sohum> Beelsebob: it doesn't? I've seen a lot of people do it with strong wording as to how it'd be default...?
07:27:37 <sproingie> pozic: the Array example would be pretty neat.  the tuple one sounds pretty horrifying
07:27:59 <sproingie> removing special syntax for lists would make haskell quite cumbersome to write
07:28:54 <pozic> I would like to see a programming language in which I can draw diagrams.
07:29:15 <sproingie> literate haskell :)
07:29:35 <pozic> sproingie: no, I mean that the actual diagrams are being compiled as code.
07:29:50 <pozic> That they implicity define data structures and so on.
07:30:08 <CalJohn> executable uml
07:30:22 <pozic> Every slightly complicated paper presents complicated examples with diagrams, because they are so easy to understand.
07:30:41 <sproingie> most complicated papers i read are full of greek letters
07:30:48 <quicksilver> rather than just over-ridable [...] I'd quite like custom "bracket fix" operators
07:31:02 <quicksilver> so you could define <| |> or [| |] orr whatever
07:31:12 <quicksilver> requires you to make some quite different lexical design decisions though
07:31:21 <pozic> sproingie: you probably mostly read papers about type-theory, probably.
07:31:46 <quicksilver> there have been a couple of diagram programming languages, IIRC
07:31:52 <sohum> hm. that's interesting
07:31:54 <sproingie> not so much read them as give them that puppy tilt-headed look
07:32:05 <pozic> quicksilver: I have never seen one running on my machinem though.
07:32:10 <pozic> machine*
07:32:15 <sproingie> oleg's papers seem to be the only ones i can really read
07:32:34 <pozic> sproingie: Oleg actually builds software, that's why his papers are readable.
07:33:00 <sm> what software is that ?
07:33:29 <pozic> sm: you can look at his website to see that.
07:33:39 <_andy_> can you escape new lines in strings, such that you can wrap a string on mutliple lines?
07:33:55 <_andy_> would prefer that to unlines
07:34:16 <shambler> who's Oleg? ...because I have that name too ;)
07:34:21 <Cale> _andy_: You can end a line with \ and put a \ at the start of the next line, and it will ignore the whitespace in between
07:34:39 <Cale> _andy_: But it doesn't insert a newline, you'd have to write \n explicitly
07:34:47 <_andy_> ok
07:35:13 <pozic> shambler: someone with a short name who also happens to write functional programming tricks.
07:35:28 <pozic> shambler: okmij.org/ftp, IIRC
07:35:32 <sproingie> shambler: oleg kiselyov
07:35:36 <sm> http://okmij.org/ftp/
07:35:51 <sohum> so explicit lists and the generic code (i.e., the only explictly-listy-bits being the type signatures) behave exactly the same (with respect to time and space at least). Data.Seq gives me a 12% improvement.
07:35:55 <sproingie> @oleg
07:35:56 <shambler> thanks guys
07:35:56 <lambdabot>  Defined.
07:36:00 <sproingie> heh
07:36:02 <sohum> in time, but again, exactly the same in space
07:36:03 <sproingie> @quote oleg
07:36:03 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
07:36:04 <shambler> @where oleg
07:36:05 <lambdabot> http://okmij.org/ftp/
07:36:08 <sproingie> meh
07:36:09 <shambler> cool
07:36:09 <sproingie> @quote oleg
07:36:10 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
07:36:17 <sproingie> i thought he had a bunch of quotes
07:36:49 <pozic> @quote Oleg
07:36:49 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
07:36:58 <pozic> @quote Oleg
07:36:58 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
07:37:01 <pozic> @quote Oleg
07:37:01 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
07:37:32 <pozic> @quote milli
07:37:33 <lambdabot> RobertXCringely says: If automobiles had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing
07:37:33 <lambdabot> everyone inside.
07:37:44 <sohum> but no
07:37:47 <sohum> wait
07:37:51 <pozic> Probably some were deleted.
07:38:16 <sohum> I can't consistently replicate the speeds
07:38:32 <shambler> RobertXCringely says: If automobiles had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing everyone inside.
07:38:37 <shambler> sorry
07:38:39 <sohum> so I'm going to say any difference is lost in the error bars for this data set
07:38:40 <shambler> wrong chan
07:40:54 <pozic> I also just love it when people confuse pointer and "pointee"(is there an English word for this ("the thing pointed to")).
07:42:58 <sproingie> target?
07:43:00 <Gracenotes> the extend to which a number constitutes pointing
07:43:05 <Gracenotes> extent
07:43:09 <sproingie> referent?
07:43:23 <quicksilver> referent is, I think, the technical term althouhg it's very seldom used.
07:44:00 <sproingie> thingie
07:44:12 <Gracenotes> usually, the specific thing being pointed to
07:44:13 <quicksilver> normally people use some variation of the word 'object'
07:44:23 <quicksilver> like 'memory object' or 'heap object' or 'actual object'
07:44:30 <quicksilver> (even when the domain has nothing to do with OO)
07:44:36 <Gracenotes> not a general term, and yeah, general term seems to be object
07:47:32 <pozic> quicksilver: what do you think of the word pointee? IBM and Stanford seem to use it.
07:47:40 <aavogt> pointy
07:49:10 <quicksilver> pozic: a bit too much like 'goatee' for my liking
07:49:29 <quicksilver> I have images of a stern techie with a goatee pointing out my misdemeanours.
07:49:35 <zygoloid> goatee: what a goater goats?
07:49:43 <quicksilver> No, seriously, it seems fine, and it's fairlee clear
07:49:52 <b_jonas> help, I'm getting this error: http://erxz.com/pb/22593
07:50:07 <pozic> quicksilver: Clearlee.
07:50:11 <b_jonas> what did I do wrong or how do I fix it?
07:50:32 <b_jonas> I'm using a ghc 6.12.1 installed from source on a x86 linux machine
07:50:34 <sproingie> why are you running Setup manually?  do you not have cabal?
07:50:49 <b_jonas> sproingie: dunno, I just prefer this way
07:50:52 <b_jonas> I could try cabal
07:50:57 <sproingie> cabal install hexpaty
07:51:00 <sproingie> -y
07:51:40 <b_jonas> won't that try to install to /usr/local by default as the Setup without prefix argument does?
07:51:44 <sproingie> the name of the missing package is pretty weird too
07:52:00 <b_jonas> I don't want to clean up /usr/local after it
07:52:11 <sproingie> cabal by default installs stuff in ~/.cabal
07:52:27 <b_jonas> okay, how do I change that then?
07:52:33 <b_jonas> also, wait, let me install cabal first
07:52:35 <sproingie> edit ~/.cabal/config
07:53:22 <sproingie> that particular broken dep is kind of strange looking tho
07:54:18 <b_jonas> haskell98 and random are supposed to be part of the ghc itself
07:54:44 <b_jonas> could it have been confused and trying to reference packages installed with the older ghc (6.10 which I used to compile this ghc) in a different prefix?
07:54:46 <sproingie> istr having to install random myself
07:55:16 <c_olin> So I'm defining an instance of Num for a Vector data type.  I successfully defined (*), (+), abs, signum, negate, fromInteger... Can I define (-) and (+) given different types?  Such as a Scalar being added to a Vector?
07:55:49 <b_jonas> ghc-6.12.1 comes with random
07:55:56 <pozic> c_olin: you mean 1::Int + v::SomeVector => x::SomeVector?
07:56:07 <c_olin> yes
07:56:10 <pozic> c_olin: only if you do not use the standard +.
07:56:21 <pozic> c_olin: you would have to define a MPTC.
07:56:26 <c_olin> I was afraid of that
07:56:44 <pozic> c_olin: it is also the question whether or not you actually want to do that.
07:57:03 <pozic> c_olin: the thing with these overly general things is that you will always miss some use.
07:57:13 <pozic> c_olin: and it might become hard to read the code later.
07:57:24 <pozic> c_olin: see the regex package of why this is so.\
07:57:27 <zygoloid> c_olin: you can do 'fromIntegral (1::Int) + (v::SomeVector) :: SomeVector'
07:57:36 <c_olin> so are you sugesting just writing a function addScalar :: Vector -> Int -> Vector
07:57:39 <c_olin> ?
07:57:43 <zygoloid> c_olin: and of course '(1 :: SomeVector) + (v :: SomeVector)'
07:57:59 <pozic> c_olin: I would just use an existing library.
07:58:02 <pozic> c_olin: but yes.
07:58:10 <sproingie> i do sometimes miss ad hoc overloading
07:58:29 <b_jonas> but ghc also comes with cabal
07:58:37 <b_jonas> so I should already have it installed
07:58:41 <pozic> It seems obvious at the time you write the code, but when you have to read it later?
07:58:44 <b_jonas> but then where's the cabal executable?
07:58:48 <c_olin> I would use a library as well, but I'm doing this purely for the learning experience. Thanks for the gelp
07:58:49 <sproingie> b_jonas: the haskell platform comes with cabal.  ghc does not.
07:58:51 <c_olin> help*
07:59:42 <pozic> c_olin: if you want to get respect, you just generate your MPTC implementation by using TH ;)
07:59:43 <b_jonas> ah, found it:
07:59:57 <sproingie> addScalar is the next best thing.  v `addScalar` s
08:00:04 <b_jonas> in ghc-6.12.1/libraries/Cabal: "If you also want the `cabal` command line program then you need the `cabal-install` package in addition to this library."
08:00:07 <b_jonas> I see
08:00:22 <b_jonas> so I want cabal-install, not Cabal
08:00:23 <pozic> sproingie: some people prefer Scalar.add then.
08:00:38 <pozic> sproingie: It's rather arbitrary.
08:00:56 <sproingie> arguably the scalar addition "belongs" to the vector in some sense
08:00:56 <b_jonas> or use the shortest sequence of pluses not used yet
08:01:39 <zygoloid> c_olin: fromIntegral is probably the way to go
08:01:57 <c_olin> zygoloid: Thanks.  I'll go with that for now... appreciate the help
08:02:13 <zygoloid> i would suspect that implicit conversion from a scalar to a vector is suitably non-obvious that you'd want an explicit function call in there anyway :)
08:02:14 <Cale> :t \select xs -> runStateT (mapM (const select) xs) xs
08:02:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => StateT [a] m b -> [a] -> m ([b], [a])
08:02:27 <Cale> :t \select xs -> evalStateT (mapM (const select) xs) xs
08:02:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => StateT [a] m b -> [a] -> m [b]
08:02:39 <Cale> :t \select xs -> evalStateT (mapM (const (StateT select)) xs) xs
08:02:41 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => ([a1] -> m (a, [a1])) -> [a1] -> m [a]
08:03:00 <sproingie> multiplying a vector by a scalar is well-defined.  addition i'd say less so.
08:03:07 <Cale> @let build select xs = evalStateT (mapM (const (StateT select)) xs) xs
08:03:09 <lambdabot>  Defined.
08:03:44 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in build select [1,2,3]
08:03:46 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
08:03:59 <Cale> > let select [] = []; select (x:xs) = (x,xs) : select xs in build select [1,2,3]
08:04:01 <lambdabot>   [[1,2,3]]
08:04:29 <Cale> @let buildK select k xs = evalStateT (replicateM k (StateT select)) xs
08:04:31 <lambdabot>  Defined.
08:04:45 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in buildK select 2 [1,2,3]
08:04:47 <lambdabot>   [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
08:04:53 <Cale> > let select [] = []; select (x:xs) = (x,xs) : select xs in buildK select 2 [1,2,3]
08:04:55 <lambdabot>   [[1,2],[1,3],[2,3]]
08:17:40 <mauke_> > iterate (\c -> if c == 'A' then "A CAT" else [c]) "A"
08:17:41 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:17:42 <lambdabot>         against inferred type...
08:17:53 <mauke_> > iterate (concatMap $ \c -> if c == 'A' then "A CAT" else [c]) "A"
08:17:54 <lambdabot>   ["A","A CAT","A CAT CA CATT","A CAT CA CATT CA CAT CA CATTT","A CAT CA CATT...
08:18:06 <mauke_> > iterate (concatMap $ \c -> if c == 'A' then "A CAT" else [c]) "A" !! 4
08:18:07 <lambdabot>   "A CAT CA CATT CA CAT CA CATTT CA CAT CA CATT CA CAT CA CATTTT"
08:18:20 <mauke_> science!
08:19:11 <quicksilver> wow, machine gun sound.
08:21:13 <Cale> Where are all the G's?
08:21:21 <Cale> ;)
08:21:30 <idnar> don't be silly, machine guns don't make "G" sounds
08:22:06 <Beelsebob> no, the gs are in the racist scooters that go run nigga nigga nigga nigga nigga
08:22:25 <_andy_> i find myself often writing "return ()", is there another way of saying "do nothing"?
08:22:43 <Beelsebob> _andre: why the ()?
08:22:48 <lispy> _andy_: the don't package on hackage
08:22:50 <Beelsebob> _andy_: even
08:22:55 <byorgey> _andy_: nope!
08:22:56 <gwern> idnar: sure they do. GACK GACK GACK GACK GACK etc
08:23:00 <Beelsebob> oh wait, wrong channel
08:23:00 <Beelsebob> >.<
08:23:06 <byorgey> _andy_: but there might be better ways of saying whatever it is you're saying.
08:23:11 <Beelsebob> _andy_: do you have an example of where you're doing this?
08:23:12 <mauke_> whatever :: (Monad m) => m (); whatever = return ()  -- there is now
08:23:21 <_andy_> handleEvent _ = return ()
08:23:30 <idnar> gwern: haha
08:23:31 <byorgey> _andy_: yeah, that's fine
08:23:35 <mauke_> import Data.Default
08:23:36 <Beelsebob> _andy_: no, there's no more clear way of doing that
08:23:38 <mauke_> handleEvent = def
08:23:39 <lispy> _andy_: http://hackage.haskell.org/package/acme-dont
08:23:43 <mauke_> THERE IS NOW
08:23:52 <ejt> _andy_: ignore m = m >> return ()
08:24:05 <_andy_> ok, thanks
08:24:08 <byorgey> hey, I think mauke_ is trying to say something!
08:24:14 <_andy_> was just thinking that
08:24:20 <byorgey> ;-)
08:24:22 <mauke_> arf! arf!
08:24:28 <_andy_> yes, boy?
08:24:29 <_andy_> what is it?
08:24:33 <lispy> Oh yeah, I should mention acme-dont is a joke
08:24:36 <byorgey> Cale is trapped in a well?
08:24:46 <mauke_> timmy is trapped in a monad
08:24:50 <lispy> trapped in the Well monad
08:24:54 <byorgey> o noes!
08:24:54 <idnar> gwern: which base is K? :P
08:25:02 <Absolute0> which is faster: (5::Word64) + (5::Word64) or (5::Word64) .|. (5::Word64) ?
08:25:07 <lispy> > unsafePerformIO well
08:25:08 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `well'
08:25:18 <Cale> Hey, I *am* trapped in a well! I hadn't noticed!
08:25:21 <mauke_> Absolute0: 1) who cares?  2) why so many type annotations?
08:25:45 <Absolute0> mauke_: that's not an answer :)
08:25:50 <mauke_> yes, it is
08:25:51 <byorgey> Absolute0: don't those do different things anyway?
08:26:01 <Absolute0> .|. requires it Bit type..
08:26:10 <Absolute0> s/it/a
08:26:14 <gwern> idnar: keto
08:26:20 <Absolute0> byorgey: not for Word64
08:26:35 <mauke_> Absolute0: 5 + 5 == 10, 5 .|. 5 == 5
08:26:36 <byorgey> > (5::Word64) + (5::Word64)
08:26:38 <lambdabot>   10
08:26:45 <byorgey> > (5::Word64) .|. (5::Word64)
08:26:47 <lambdabot>   5
08:26:53 <mauke_> Absolute0: hence 1) who cares?
08:27:03 <Absolute0> oh assume i is a power of 2..
08:27:08 <Absolute0> forgot to mention that :)
08:27:15 <byorgey> ...what is i?
08:27:17 <Absolute0> > 4 + 4
08:27:19 <lambdabot>   8
08:27:23 <Absolute0> > 4 .|. 4
08:27:25 <lambdabot>   Ambiguous type variable `t' in the constraint:
08:27:25 <lambdabot>    `Data.Bits.Bits t'
08:27:25 <lambdabot>      a...
08:27:30 <byorgey> they are still different.
08:27:30 <mauke_> > 4 .|. 4 :: Integer
08:27:31 <lambdabot>   4
08:27:43 <Absolute0> at different positions :-P
08:27:48 <Absolute0> sheesh
08:28:03 <Absolute0> > 4 + 2
08:28:04 <lambdabot>   6
08:28:09 <byorgey> oh, well in THAT case... =)
08:28:14 <Absolute0> > (4::Word64) .|. 2
08:28:15 <lambdabot>   6
08:28:17 <Absolute0> there!
08:28:26 <Absolute0> sorry, didnt thing properly before asking
08:28:30 <pozic> Absolute0: and then the answer depends on the hardware ;)
08:28:32 <Absolute0> think
08:28:47 <byorgey> I still like mauke_'s answer. =)  And if you really honestly care about speed differences like that, then do some profiling.
08:28:57 <pozic> Absolute0: but for sane hardware .|. is going to win.
08:28:59 <Absolute0> I am just curious..
08:29:03 <Absolute0> its fun to think about it.
08:29:14 <pozic> Absolute0: not too long
08:29:35 <Absolute0> I am thinking + needs more memory
08:29:37 <pozic> Did you hear that? Haskell can add numbers!
08:29:52 <Absolute0> each bit goes in a different buffer or something like that
08:30:15 <Berengal> Absolute0: Both require two/three registers
08:30:48 <Berengal> And I think both are one cycle long, usually...
08:30:59 <Absolute0> oh weel
08:31:01 <Absolute0> welll
08:31:04 <Absolute0> :-D
08:31:17 <b_jonas> am still here, just got slow a bit, sorry
08:31:24 <b_jonas> installing cabal-install right now
08:31:34 <b_jonas> then I'll try installing hexpat with cabal
08:34:31 <ejt> ghc-6.10.4 is segfaulting - is this possibly due to old libraries that were built with 6.10.2 ?
08:34:56 <byorgey> ejt: ghc-6.10.4 itself is segfaulting?  or programs compiled with it are segfaulting?
08:35:02 <b_jonas> so where's the docs for this cabal executable and how I set my ~/.cabalwhatever up?
08:35:03 <ejt> itself
08:35:14 <byorgey> hmm, yikes
08:35:35 <byorgey> I don't think old libraries would cause that
08:35:38 <ejt> valgrind confirms it's going bad stuff
08:35:43 <ejt> s/going/doing/
08:35:51 <Berengal> ejt: Where did you get it? Binary?
08:35:53 <byorgey> ejt: does it segfault all the time, or only when compiling certain programs?
08:36:12 <ejt> only when I try and build chart
08:36:18 <jlouis> Absolute0: on modern hardware, there is rarely a difference between bitwise and arithmetic operations
08:36:23 <mauke_> b_jonas: ~/.cabal should be created with default settings when you first use cabal
08:36:32 <mauke_> b_jonas: then you can just edit ~/.cabal/config
08:36:50 <byorgey> b_jonas: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
08:37:09 <b_jonas> and how do I first use cabal without installing anything?
08:37:48 <sproingie> you have to install cabal and its dependencies first.  or just download and use the haskell platform which comes with it.
08:37:52 <ejt> byorgey: I grabbed a binary release (amd_64)
08:38:11 <ejt> I think I'll try and build it myself
08:38:13 <jlouis> Absolute0: on older hardware however, the difference is noticeable, in the bitwise operations favor
08:38:21 <paolino> there is a bootstrap.sh inside the tarball
08:38:22 <Absolute0> jlouis: right, I would assumt the hardware/language would use the most appropriate computation when possible.
08:38:24 <b_jonas> no, I've installed cabal
08:38:28 <b_jonas> that's not the problem
08:38:34 <b_jonas> I have the cabal exec
08:38:42 <b_jonas> how do I run it so that it creates ~/.cabal/config
08:38:46 <sproingie> cabal update
08:38:50 <b_jonas> just cabal --help doesn't do it
08:38:51 <b_jonas> ah, thanks
08:38:53 <jlouis> Absolute0: it takes the same time for a bitwise operations to flow through the execution unit as an (integer) addition
08:39:05 <ejt> or perhaps I should just move to 6.12
08:40:02 <Berengal> ejt: Less things work with 6.12, so there should be fewer segfaults as well ;)
08:40:09 <jlouis> Absolute0: it has nothing to do with reducing one operation to the other. Many compilers reduces certain multiplications to bitwise operations because the difference is still noticeable there
08:40:27 <burp> > [0..8,10] -- short syntax for this instead of [0..8]++[10]?
08:40:27 <jlouis> (however)
08:40:28 <lambdabot>   <no location info>: parse error on input `,'
08:40:29 <Absolute0> is it possible to do: f x y = (max x y) / (min x y) without calling max and min?
08:41:10 <b_jonas> okay, the config file is created, now I edit it
08:41:50 <b_jonas> Absolute0: sure, max x y is just if x < y then y else x
08:41:57 <b_jonas> Absolute0: but there's not much point not calling max
08:42:15 <Absolute0> I meant some clever function instead of (/)
08:42:16 <b_jonas> I mean max might even be faster if the optimizer sucks
08:42:50 <Absolute0> (||) & (-)?
08:43:11 <b_jonas> not likely
08:43:25 <b_jonas> what's wrong with /
08:43:36 <Absolute0> it can't stand straight :(
08:43:40 <medfly> I think he doesn't want to go over the list twice
08:43:50 <pozic> medfly: there is no list in sight
08:44:11 <ejt> Absolute0: order x y = if x < y then (x, y) else (y, x)
08:44:28 <medfly> oh, list
08:44:30 <medfly> errr
08:44:30 <medfly> :)
08:44:32 <ejt> case order x y of; (low, high) -> high / low;
08:45:02 <sproingie> there's lots of ways to get clever.  (max x y) / (min x y) is about as readable as it gets and perfectly efficient
08:45:25 <ejt> y, prove it's a problem first
08:45:29 <medfly> > max 2 3
08:45:30 <lambdabot>   3
08:45:40 <sproingie> if you really can't stand the calls, expand it out.  f x y = if x > y then x / y else y / x
08:45:41 <jlouis> ejt: it is not obvious that it is faster. It converts the control flow into something else
08:45:45 <mauke_> f x y = y' / x' where [x', y'] = sort [x, y]
08:46:02 <sproingie> that's also quite clear.  everything else is golfing
08:46:16 <Twey> liftM2 (liftM2 (/)) max min
08:46:29 <Absolute0> :t liftM2
08:46:30 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:46:40 <Berengal> (/) <$> max <*> min
08:46:46 <Twey> Oooh, that's nice
08:46:49 <Berengal> @type (/) <$> max <*> min
08:46:50 <lambdabot> forall a. (Fractional (a -> a), Ord a) => a -> a -> a
08:46:52 <sproingie> that's awesome
08:46:59 <Absolute0> liftM2 = fmap for monads?
08:47:03 <Twey> Absolute0: Yep
08:47:03 <lispy> :t on
08:47:04 <jlouis> "Twey starts the golfing session with a driver.... A loooong shot at 5 tokens!"
08:47:05 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:47:06 <mauke_> Absolute0: no, liftM = fmap
08:47:08 * Twey laughs.
08:47:52 <Absolute0> mauke_: and liftM2 = ?
08:47:56 <ejt> jlouis: y, you're relying on the compiler to get rid of the pair
08:47:57 <besiria> is there a neural networks library?
08:48:00 <mauke_> Absolute0: is liftM2
08:48:09 <sproingie> besiria: there are several
08:48:12 <sproingie> besiria: check hackage
08:48:24 <sproingie> http://hackage.haskell.org/packages/archive/pkg-list.html
08:48:28 <Twey> @src liftM2
08:48:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:48:32 <Twey> Hmm
08:48:37 <mauke_> Absolute0: http://mauke.ath.cx/tmp/flow.png
08:48:42 <jlouis> ejt: yeah, but max x y is a single instruction on some archs, so the control flow is linear
08:48:58 <besiria> sproingie: yep, found one: hnn
08:49:07 <mauke_> Absolute0: liftM2 c f g x = f x `c` g x
08:49:09 <Absolute0> mauke_: sweet illustration
08:49:13 <b_jonas> okay, now where's the manual?
08:49:18 <Absolute0> mister Cook Island...
08:49:21 <b_jonas> the one that documents the command-line cabal I mean
08:49:23 <Gracenotes> well, max is part of the Ord class
08:49:53 <Absolute0> I am gonna go...
08:49:53 <ejt> jlouis: I didn't know that
08:50:29 <HaskellLove> Can  I optimize this euler 41 of mine? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15695#a15695
08:50:37 <HaskellLove> incredibly slow
08:50:40 <jlouis> ejt: anyway, I am hesitant to do anything here but measure if I cared.
08:50:48 <HaskellLove> L stands for List
08:51:54 <lispy> HaskellLove: it's okay to use more than one line when you write programs :)
08:52:33 <HaskellLove> well people here thought me so, would you like me to guide you through the code to tell you what it does?
08:53:17 <ksf> (*&)*(!!!!
08:53:21 <ksf> werror!
08:53:25 <sproingie> (L.map (read . concatMap show) -- that looks suspicious
08:53:39 <mauke_> does anyone else find HaskellLove annoying?
08:53:43 <sproingie> at any rate it won't be fast
08:54:06 <ksf> I think -werror is annoying
08:54:07 <mauke_> I don't know what exactly it is, but every time he writes something, it makes me less happy
08:54:10 <b_jonas> anyway, I could get cabal configure to give me the same error message as running Setup.hs directly: http://erxz.com/pb/22595
08:54:14 <b_jonas> so now what?
08:54:24 <ksf> especially when it fails for something like -ffi vs. -XForeignFunctionInterface
08:54:34 <ksf> ...which is now ages old.
08:54:51 <HaskellLove> sproingie i need that to convert lists of numbers to numbers... [1,2,3,4] will be converted to 1234 for example
08:54:56 <jlouis> HaskellLove: wrong approach. You seem to generate all permutations and then test each of them. You'll never be done with that idea
08:55:00 <mauke_> b_jonas: sounds like you need to reinstall haskell98 ... weird
08:55:05 <sproingie> b_jonas: you could try reinstalling random.  cabal install random
08:55:09 <medfly> mauke_: some people here say they do
08:55:17 <b_jonas> I think I reinstalled random once
08:55:27 <b_jonas> but it might have been that that was what broke everything
08:55:30 <sproingie> b_jonas: i think your ghc installation may be fux0red then
08:55:38 <b_jonas> sproingie: yes, that's what I fear
08:55:52 <b_jonas> so you say I try reinstalling haskell98? could try
08:56:03 <sproingie> you could try removing all added packages from /usr/local and wherever else they may be hiding
08:56:07 <HaskellLove> jlouis yeah but what else option i have, any sugestions?
08:56:09 <jlouis> HaskellLove: first optimization: You only have to generate primes.
08:56:18 <sproingie> sudo updatedb && locate .hi
08:56:21 <pozic> I have another free tip for you to obfuscate an article. Include a diagram in which the most important lines have width 0.5 mm.
08:56:32 <b_jonas> should I reinstall the one in the ghc source or a separately downloaded one from cabal?
08:56:44 <jlouis> HaskellLove: Second optimization: There is an upper bound on the pandigitals, find it
08:56:47 <b_jonas> sproingie: um, how do I make ghc-pkg (or whatever) show which package is where?
08:56:53 <sproingie> you may have to reinstall ghc.  after wiping out all traces of the old one
08:56:59 <ejt> wow, ghc-6.12 built quickly
08:57:05 <sproingie> b_jonas: ghc-pkg has something, i prefer to just use locate
08:57:13 <pozic> HaskellLove: computer programming and especially Euler is about doing smart things. If you ask everything, you are not programming, someone else is.
08:57:17 <HaskellLove> jlouis generate primes? are you sure you want to search in the 1 000 000 00 to 999 999 999 range?
08:57:24 <copumpkin> jlouis: ORLY! WHAT IF IT'S NOT BASE 10 BUT BASE INFINITY!!!!
08:57:32 <b_jonas> I'm not supposed to have any packages in /usr/local directly, but I might be wrong
08:57:35 <b_jonas> let me look
08:57:40 <HaskellLove> pozic dude stf i am getting opinions mind your own business
08:57:45 <sproingie> base infinity is an interesting concept
08:57:52 <copumpkin> sproingie: DAMN RIGHT
08:57:52 <jlouis> HaskellLove: third optimization: since we are going for the largest such, we might choose the search order cleverly
08:57:54 <sproingie> it's like the set of reals as a digit
08:58:12 <copumpkin> sproingie: base aleph 0 only
08:58:21 <copumpkin> aleph -1!!
08:58:22 <HaskellLove> jlouis but wait your first optimization is wrong, there are too much primes in that range, we are talking close to bilion
08:58:23 * copumpkin shuts up
08:58:30 <mauke_> HaskellLove: didn't you say something like "last question" ... about ten questions ago?
08:58:50 <jlouis> HaskellLove: all project euler problems after 30 or so are constructed so you have to think. Exhaustive search of the space is impossible
08:58:51 <sproingie> maybe make a #haskell-euler
08:59:18 <HaskellLove> jlouis well that is why i say your first optimization is not an optimization really
08:59:26 <mauke_> jlouis: hah, then they're not very well constructed
08:59:41 <j4cbo> no, then they're *very* well constructed
08:59:48 <mauke_> jlouis: I've solved problems in the 30 .. 200 range, and I always use brute force
09:00:11 <HaskellLove> my approach is generate pandigitals first since they are less and then filter primes, the other way around is too slow the one you sugest, generate primes and then test for pandigital property
09:00:16 <jlouis> mauke_: hehe, one of my friends solves in Ruby by brute force. His computations runs for days
09:00:16 <sproingie> i've sort of hit the next thinking barrier in haskell programs.  i know how to maintain state, i just can't figure out identity.
09:00:22 <mauke_> ok, except for the one where doing it by hand was easier than writing a program
09:00:24 <copumpkin> mauke_: there are occasional easy problems in the higher numbers but they're the minority
09:00:29 <MbM313> SALaaaaaaaam  / Hi
09:00:34 <b_jonas> sproingie: I may have some packages registered from ghc 6.10 because I used that to install 6.12
09:00:43 <sproingie> b_jonas: that shouldn't matter
09:00:46 <b_jonas> but I don't know how to find out which packages are from where
09:00:55 <jlouis> mauke_: I solve some by graphviz :)
09:00:56 <solidsnack> We're talking about Sphere Online Judge or Project Euler?
09:01:09 <mauke_> solidsnack: euler
09:01:13 <HaskellLove> jlouis do you see that your approach is wrong from start?
09:01:14 <quicksilver> HaskellLove: you can't test for primes any more efficiently than by generating a list of all primes up to sqrt(n)
09:01:18 <b_jonas> it should, if I still have them then they're supposed to be broken, I want to delete that ghc and have already renamed its directory to simulate deleting
09:01:24 <jlouis> HaskellLove: it isn't, trust me
09:01:25 <mauke_> solidsnack: spoj is generally impossible to solve by hand :-)
09:01:31 <quicksilver> HaskellLove: there is no other general method.
09:01:50 <quicksilver> (there are probabilistic methods but they are not guaranteed)
09:02:11 <quicksilver> stopping at sqrt(n) rather than going to n is a pretty big optimisation though.
09:02:25 <HaskellLove> quicksilver I have like 20 000 numbers to deal with, with my approach. with yours i will generate a looooot of primes in the range of 1 000 000 000 to 9 999 999 999
09:03:01 * medfly wonders what this laziness thing is
09:03:15 <b_jonas> mauke_: some spoj problems would be if they gave you the input
09:03:35 <Ferdirand> HaskellLove: and how will you test for primality whitout generating primes ?
09:03:40 <poucet> quicksilver: not quite true, someone found that there's a way of checking primes that is not is in O(polynomial(size of N))
09:03:48 <poucet> s/not/in
09:04:00 <mauke_> s/is in //
09:04:04 <copumpkin> Ferdirand: trial division of course!
09:04:08 <poucet> mauke_: thank you
09:04:54 <conal> sproingie: (\ x y -> (max x y) / (min x y)) = max / min with applicative-numbers
09:05:08 <HaskellLove> Ferdirand first i get the pandigitals and then i filter them with isPrime
09:05:33 <HaskellLove> with my sweet killer: isPrime n = length (primeFactors n) == 1
09:05:38 <sproingie> conal: ooh nifty
09:05:49 <medfly> :/
09:06:11 <Ferdirand> and what does primeFactors do ?
09:06:21 <medfly> prime factorisation, I guess
09:06:24 <HaskellLove> gets prime factors list what else
09:06:35 <Ferdirand> how so ?
09:06:42 <ski> (medfly : what about laziness ?)
09:06:42 <b_jonas_> (sorry, I have net connection problems)
09:06:49 <medfly> :)
09:06:56 <medfly> I dunno :)
09:07:14 <HaskellLove> well a prime is a number that has just one prime Factor, which is 1
09:07:14 <jlouis> HaskellLove: my "naive" approach with observations one and two from above runs in 15 seconds here on a single core
09:07:15 <quicksilver> poucet: Oh, I did read something but I forgot it. good point.
09:07:33 <mauke_> HaskellLove: 1 is not a prime
09:07:35 <xerox> HaskellLove 1 is not a prime
09:07:40 <HaskellLove> jlouis give me the code then i doubt it ... you generate too much primes
09:07:41 <sproingie> 1 and itself.  which is a pretty darn circular definition
09:07:43 <pozic> HaskellLove: your sweet killer is going to decide how many prime-factors there are.
09:07:44 <ski> `1' is not prime, so it is not a prime factor of anything
09:07:51 <sproingie> if 1 was prime then there would be no other primes
09:07:58 <pozic> HaskellLove: because length is not lazy.
09:08:23 <jlouis> HaskellLove: filter isPandigital $ takeWhile (<7654321) primes
09:08:25 <medfly> isPrime [x] = True; isPrime x = False ? :)
09:08:25 <HaskellLove> well yes 1 is not prime factor but my function does it
09:08:32 <sproingie> your function is wrong
09:08:33 <medfly> woops
09:08:39 <medfly> you need one moar function
09:08:45 <pozic> MOAR
09:08:47 <sproingie> moar funkshuns
09:08:51 <medfly> :)
09:08:53 <medfly> hehehe
09:08:53 <pozic> :)
09:09:05 <HaskellLove> there you go, you might learn something http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15696#a15696
09:09:07 <ski> (s/moar/more/ :)
09:09:18 <pozic> Is anyone going to Zurich?
09:09:53 <Ferdirand> copumpkin: so, you weren't joking ?
09:10:09 <copumpkin> Ferdirand: I was making an educated guess ;)
09:10:14 <pozic> HaskellLove: learn how you do something in a very slow way?
09:10:34 <ksf> is my perception skewed or is 6.12.1 waaaay more zippy than 6.10?
09:10:45 <HaskellLove> you want to test your isPrime with mine?
09:10:45 <medfly> @wn zippy
09:10:47 <lambdabot> *** "zippy" wn "WordNet (r) 2.0"
09:10:48 <lambdabot> zippy
09:10:48 <lambdabot>      adj 1: quick and energetic; "a brisk walk in the park"; "a lively
09:10:48 <lambdabot>             gait"; "a merry chase"; "traveling at a rattling
09:10:48 <lambdabot>             rate"; "a snappy pace"; "a spanking breeze" [syn: {brisk},
09:10:49 <lambdabot> [5 @more lines]
09:10:52 <b_jonas> I can load System.Random in ghci
09:11:06 <ksf> (even though it's outputting a gazillion more warnings)
09:11:11 <ski> @yow
09:11:11 <lambdabot> Couldn't find fortune file
09:11:19 <medfly> aww
09:11:20 <ksf> @yow
09:11:21 <lambdabot> Couldn't find fortune file
09:11:21 <b_jonas> this sucks
09:11:24 <Ferdirand> HaskellLove: your isPrime is wrong on so many levels
09:11:25 <ksf> ...just checking.
09:11:50 <ksf> as, in fact, exactly that fortune line is included in the default unix fortune db.
09:11:59 <HaskellLove> Ferdirand chesus fucking christ, did you even tried it i am using it on eulers since start and i have solved like 50 with it
09:12:26 <jlouis> HaskellLove: another word of advice... many of the early PE problems set the stage for building an effective number library of helpers. Your isPrime is not one of the fastest ones around
09:12:52 <monochrom> Why argue?
09:13:04 * ski has several times read `PE' as "Partial Evaluation", now ..
09:13:14 <monochrom> physical education
09:13:20 * ksf is surprised to see sexual methaphors being used outside of -blah.
09:13:35 <mauke_> HaskellLove: I think you've "solved" all of them by asking a dozen question for each in #haskell
09:13:44 <monochrom> haha
09:14:02 <xerox> aka using an Oracle
09:14:06 <mauke_> heh
09:14:16 <pozic> Super-Turing capability!
09:14:27 <xerox> typical in some academic circles... ;)
09:15:03 <quicksilver> HaskellLove: moderate the language please.
09:15:05 <int-e> HaskellLove++ - not succumbing to premature optimization. ;-)
09:15:25 <quicksilver> (and that is a very slow isPrime)
09:15:27 <monochrom> There are whole hierarchies of Î 1, Î 2, Î 3... and Î£1, Î£2, Î£3...
09:16:06 <HaskellLove> i am not advanced to intuitively understand the advanced algorithms yet, so i use mine isPrime for now
09:16:30 <sproingie> then be satisfied with your execution times
09:16:57 <HaskellLove> it is my algorithm in general not the isPrime function
09:17:15 <mauke_> isPrime is part of the algorithm
09:17:20 <Ferdirand> you could speed things a lot by changing the isPrime function itself, yes
09:17:28 <int-e> > let isPrime p = length [q | q <- [0..p], gcd q p == 1] + 1 == p in filter isPrime [1..]
09:17:32 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:17:33 <HaskellLove> ugly http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15698#a15698
09:17:44 <monochrom> I don't understand why you must correct each other.
09:18:47 <ksf> HaskellLove, don't believe any performance claim that isn't substantiated with a profile run
09:18:49 <int-e> > let gcd p q = max [d | d <- [1..min p q], p `mod` d == 0, q `mod` d == 0]; isPrime p = length [q | q <- [0..p], gcd q p == 1] + 1 == p in filter isPrime [1..] -- It's always possible to do worse. :)
09:18:51 <lambdabot>   No instance for (GHC.Num.Num ([GHC.Types.Int] -> [GHC.Types.Int]))
09:18:51 <lambdabot>    arisi...
09:20:19 <int-e> Oh. max and maximum.
09:20:31 <HaskellLove> the L.filter (\x->x`mod`2 /= 0) thing is not needed, but else is good
09:20:46 <sproingie> :t maximum
09:20:48 <lambdabot> forall a. (Ord a) => [a] -> a
09:21:51 <sproingie> eh.  the only thing that looks really fishy to me is the (read . concatMap show) business
09:22:02 <sproingie> that ain't gonna be fast
09:22:45 <int-e> generating all permutations of 1..9, then filtering out those that don't start with 9 ... that hurts a bit, too.
09:23:04 <sproingie> L.filter (\x-> L.head x == 9) is also stylistically a little naive
09:23:21 <HaskellLove> here is revision removed the part where i test for `div` 2 /= 0 ... no need for that http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15698#a15699
09:24:01 <sproingie> i'd probably just take a page from python and turn those maps and filters into a listcomp
09:24:16 <HaskellLove> why naive what else is there to do?
09:24:28 <c_wraith> forget stylistically.  Isn't it flat easier to just pull 9 out of the list, and then generate the permutations of the remainder and prefix them all with 9?
09:24:37 <HaskellLove> you want to go pm so we dont talk euler here?
09:24:46 <sproingie> other ways to express the same thing without the lambda.  it's not that important.
09:24:54 <Twey> [ x | x@(9 : _) <- xs ]
09:25:09 <Twey> Doesn't explode if there's a null in there, eitherâ€¦
09:25:24 <sproingie> yeah head sucks
09:25:39 <copumpkin> #haskell-euler
09:25:41 <lunabot>  luna: A section must be enclosed in parentheses
09:25:43 <sproingie> (speaking of innuendo)
09:25:49 <copumpkin> omnom
09:25:58 <Guest85079> what is the best tutorial for edison data structures
09:25:58 <Guest85079> I could order the book, but would not be able to read it today
09:26:59 <gwern> Guest85079: okasaki's thesis is online
09:27:04 <gwern> it's part of the bookm, essebntailly
09:27:54 <Guest85079> gwern, thanks! I thought I need to order it.
09:28:06 <gwern> the book is the expanded version
09:28:08 <Guest85079> gwern, is that the best resource to learn the basics?
09:28:24 <gwern> if you just want to know edison's data structure syou could do worse than use the thesis/pdf and ponder the code
09:28:35 <Guest85079> I mean, edison docs seem very useful when you want to use it, but don't give any examples for a total newbie like me
09:29:19 <copumpkin> omg it's coedwardk
09:29:39 <sproingie> lack of examples has ever been my pet gripe with stuff on hackage
09:30:43 <ekmett> @djinn (a -> (a -> f) -> g) -> (   (a -> (b -> f) -> g) -> ((a -> f) -> g) -> ((b -> f) -> g) ) -> (a -> (b -> s -> f) -> s -> g) -> ((a -> s -> f) -> g) -> (b -> f) -> g
09:30:45 <ekmett> heya
09:30:58 <lambdabot> No output from Djinn; installed?
09:30:59 <ekmett> does djinn do rank 2 types?
09:31:08 <gwern> djinn doesn't do a lot
09:31:16 <ekmett> shucks =)
09:31:24 <copumpkin> hi :)
09:32:00 <c_wraith> djinn can write >>= for the strict state monad.  That's decently impressive
09:32:10 <ekmett> @djinn (a -> (a -> f r) -> g r) -> (   (a -> (b -> f r) -> g r) -> ((a -> f r) -> g r) -> ((b -> f r) -> g r) ) -> (a -> (b -> s -> f r) -> s -> g r) -> ((a -> s -> f r) -> g r) -> (b -> f r) -> g r
09:32:25 <lambdabot> No output from Djinn; installed?
09:32:26 <c_wraith> (of course, if you know the whole type signature to give it, you also know how to write the operator anyway)
09:32:26 <copumpkin> c_wraith: it can write methods for a lot of the monads
09:32:38 <ekmett> unfortunately i think i need a rank-2 type to make that solvable
09:33:00 <copumpkin> I wonder if the djinn library can enumerate the solutions
09:34:31 <ekmett> basically i'm looking for the type signature for bind for the state right-kan extension transformer. the first two arguments there are the return and bind of the underlying monad, the rest is the signature of th bind i'm writing
09:34:40 <c_wraith> also, the lazy state monad is kind of trippy, when you're not used to just *how* lazy it can be.
09:35:22 <ekmett> i have a version that works as a monad transformer, but it isn't as efficient as it should be
09:35:43 <sm-afk> c_wraith: I find that with haskell generally
09:36:44 <ekmett> @djinn (a -> (a -> f r) -> g r) -> (   (a -> (b -> f r) -> g r) -> ((a -> f r) -> g r) -> ((b -> f r) -> g r) ) -> (a -> (b -> s -> f r) -> s -> g r) -> ((a -> s -> f r) -> s -> g r) -> (b -> s -> f r) -> s -> g r
09:36:59 <ekmett> -- i was missing the state on the last couple of arguments
09:37:00 <lambdabot> No output from Djinn; installed?
09:37:09 <ekmett> but its apparently a bit too big
09:38:10 <c_wraith> > let pro :: Control.Monad.State.Lazy.State [Bool] () ; pro = do { pro ; s <- get ; put (True:s) } in runState pro
09:38:11 <lambdabot>   Not in scope:
09:38:11 <lambdabot>    type constructor or class `Control.Monad.State.Lazy.State'
09:38:12 <Saizan_> @djinn a -> a
09:38:13 <lambdabot> f a = a
09:38:19 <ski> ekmett : or maybe you need RankN ?
09:38:31 <c_wraith> @. pl djinn a -> a
09:38:31 <lambdabot> f = id
09:38:36 <ekmett> ski: nah, its a rank 2 type, when you sprinkle the quantifications through
09:38:53 <ski> 2 > 1
09:39:21 <ski> @djinn (a -> f a) -> (a -> f (f a))
09:39:22 <lambdabot> -- f cannot be realized.
09:39:26 <ski> @djinn (forall a. a -> f a) -> (a -> f (f a))
09:39:27 <lambdabot> -- f cannot be realized.
09:40:28 <ski> `a -> (a -> f r) -> g r' looks like a `return' thing .. are you sure you only need to apply it on input of type `a' ?
09:40:31 <ekmett> @djinn (a -> forall r. (a -> f r) -> g r) -> (   (a ->  (forall r. (b -> f r) -> g r)) -> (forall r. ((a -> f r) -> g r)) -> (forall r. (b -> f r) -> g r) ) -> (a -> (forall r. ((b -> s -> f r) -> s -> g r))) -> (forall r. ((a -> s -> f r) -> s -> g r)) -> forall r. ((b -> s -> f r) -> s -> g r)
09:40:31 <lambdabot> -- f cannot be realized.
09:40:48 <ski> djinn doesn't handle higher-ranked types at all
09:41:00 <ski> only rank-1 and rank-0
09:41:16 <ekmett> ski: the first is a function i am presupposing the existence of, the return for the underlying ran-based monad. the second is another function i presuppose, the bind of the underlying ran-based monad
09:41:33 <ekmett> the result is the type signature of the bind operation for my ran-transformed monad
09:41:37 <ekmett> the codensity version is easy
09:41:47 <ekmett> @hpaste
09:41:48 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:45:09 <jmcarthur> ekmett == edwardk? why the nick change?
09:45:24 <jmcarthur> woah, edwardk is here too
09:45:27 <ekmett> http://paste.lisp.org/display/93108
09:45:33 <ekmett> jmcarthur: accident =)
09:46:01 <jmcarthur> now it's a great idea
09:46:24 <jmcarthur> dang, jakem is taken
09:46:52 <edwardk> ski: the fragment there shows what i'm trying to do. i want the signature for ran-state.bind
09:47:12 * ski is trying to djinn out the type ..
09:47:23 <edwardk> read : as $ and (foo -> bar) as (\foo -> bar) and you can mostly squint and see haskell
09:47:56 <HaskellLove> I get 987654321 for euler 41 it is not correct, someone has the answer so i see where i am please? By the way the algorithm is crazy now, it is not even a second :)
09:48:19 <edwardk> the 'codense-state' monad works well, if i'm transforming a codensity monad by adding state i get a codensity monad as the result, which means i can use the efficient free implementations of return, bind, etc for codensity on it. and lifting is trivial
09:49:11 <jmcarthur> HaskellLove: so you get the wrong answer really fast!
09:49:17 <edwardk> but ran-state is basically lifting the bind for some cps-transformed monad into one for this cps-transformed monad.
09:49:47 <edwardk> ski: oh you're right, that return should be universally quantified
09:50:03 <ski> i'm not seeing how i could get from `g r' to `f r' in `\return (=<<) -> \amb ma -> \k -> ma (\a s -> (..(amb a k s :: g r)..) :: f r)' ..
09:50:14 <jfischoff> Still new to haskell, wondering if it is better to do newtype Triangle a = (a,a,a) or data Triangle = blah.
09:50:14 <ski> edwardk : and the `bind', too, presumably
09:50:16 <edwardk> @djinn (forall a. (a -> forall r. (a -> f r) -> g r)) -> (forall a b.  ( (a ->  (forall r. (b -> f r) -> g r)) -> (forall r. ((a -> f r) -> g r)) -> (forall r. (b -> f r) -> g r) )) -> (a -> (forall r. ((b -> s -> f r) -> s -> g r))) -> (forall r. ((a -> s -> f r) -> s -> g r)) -> forall r. ((b -> s -> f r) -> s -> g r)
09:50:16 <lambdabot> Error: kind error: (KArrow KStar (KVar 30),KVar 17)
09:50:19 <gwern> > 200 * (1-0.05)^60
09:50:20 <edwardk> yeah
09:50:20 <lambdabot>   9.21395979739041
09:50:35 <jmcarthur> jfischoff: depends one what you are doing with it
09:50:49 <jmcarthur> jfischoff: (most people would say just do what's more convenient for you)
09:51:17 <jmcarthur> jfischoff: the differences between newtype and data are not things for beginners to worry about for the most part
09:51:20 <jfischoff> jmcarthur: Yeah, I'm thinking that the tuple is more convient, cause there is less typing for pattern matching
09:51:24 <gwern> > map (\x -> 200 * (1-0.05)^x) [0..60]
09:51:26 <lambdabot>   [200.0,190.0,180.5,171.47499999999997,162.90125,154.7561875,147.01837812499...
09:51:31 <gwern> > sum $ map (\x -> 200 * (1-0.05)^x) [0..60]
09:51:32 <edwardk> ski: the codensity case is easy because f r = g r
09:51:32 <lambdabot>   3824.934763849582
09:51:34 <int-e> HaskellLove: hint: that's not prime. hint 2: note that 9+8+7+6+5+4+3+2+1 is divisible by 3.
09:51:37 <jmcarthur> jfischoff: but i could try to explain the semantics differences anyway if you want
09:51:47 <edwardk> ski: the general ran case may require more of the machinery i used in my ran-transformers library
09:51:54 <edwardk> er in monad-ran
09:52:02 <edwardk> ran-transformers never saw light of day
09:52:32 <jfischoff> jmcarthur: one thing I just thought of is if I make a tuple version I might not be able to use things like deriveAccessors
09:52:39 <gwern> huh. it always amazes me how fast discounting makes the future worthless
09:52:49 <edwardk> ski: as for realizability: http://hackage.haskell.org/packages/archive/monad-ran/0.1.0/doc/html/src/Control-Monad-Ran.html implements this, but it uses some huge honking combinators that aren't efficient at all
09:52:52 <jmcarthur> jfischoff: yeah you don't get record syntax with newtype
09:52:57 <gwern> the present value of something paying 200$ a year is only 3800$?
09:53:12 <edwardk> you can find the instance for instance RanMonad m => Monad (Ran (StateT s m)) where
09:53:27 <jfischoff> jmcarthur: I guess I loss some template haskell magic for data types
09:53:58 <jfischoff> but do I gain anything besides easier pattern matching?
09:54:09 <jmcarthur> jfischoff: i don't even see what's easier about the pattern matching
09:54:17 <edwardk> but note that it cheats and turns the underlying monad back down into its non-cps transformed form to get something that is easier to think about ;)
09:54:24 <gwern> > 2350 / 10
09:54:26 <lambdabot>   235.0
09:54:27 <gwern> > 2350 / 100
09:54:29 <lambdabot>   23.5
09:54:30 <jmcarthur> jfischoff: there are some things you gain, but they will not reveal themselves in most code
09:54:30 <jfischoff> jmcarthur: maybe I am mistaken
09:54:31 <gwern> > 2350 / 1000
09:54:32 <edwardk> it should be possible to do it without turning everything right-side out first
09:54:33 <lambdabot>   2.35
09:54:58 <jfischoff> jmcarthur: so I guess the answer is go with record syntax
09:55:14 <jmcarthur> jfischoff: newtype Triangle a = Triangle (a, a, a) ; foo (Triangle (x, y, z))     data Triangle a = Triangle a a a ; foo (Triangle x y z)
09:55:36 <jfischoff> jmcarthur: yeah that's right
09:56:21 <edwardk> ski: any luck?
09:56:30 * sproingie wonders why everything is showing up with + and - prefixed now
09:56:41 <jmcarthur> jfischoff: semantic differences: http://haskell.org/haskellwiki/Newtype
09:57:00 <jmcarthur> jfischoff: ignoring those, use whatever is syntactically convenient
09:57:23 <jfischoff> jmcarthur: Its hard for me to predict down the road which will be more convinent
09:57:38 <jmcarthur> jfischoff: you can always change it later
09:57:45 <gwern> > 2000 * (1-0.05)^60
09:57:46 <lambdabot>   92.1395979739041
09:57:49 <edwardk> ski: i'm working on it in kata, because the monad-ran implementation is made incredibly opaque by all the newtypes.
09:57:54 <jfischoff> jmcarthur: true. I guess it is a minor issue
09:58:07 <jfischoff> jmcarthur: thanks for the help
09:58:11 <jfischoff> :0
09:58:11 <gwern> > 200 * (1-0.05)^60
09:58:12 <lambdabot>   9.21395979739041
09:58:13 <jfischoff> :)
09:58:14 <jmcarthur> jfischoff: welcome
09:58:51 <gwern> > 2000 * (1-0.05)^60
09:58:52 <lambdabot>   92.1395979739041
09:59:09 <edwardk> i wind up lost in     Ran g >>= f = Ran (\k -> Endo (\z -> appEndo (g (\a -> Identity (appEndo (getRan (f a) k) z))) z)) -- as oppose to: bind f g k z = g (\a -> f a k z) z
09:59:52 <copumpkin> edwardk: omg
10:00:08 <edwardk> copumpkin: that one is fairly tame =)
10:00:18 <copumpkin> what's it for?
10:01:13 <edwardk> copumpkin: that one appears to be the bind from 'Either' as a right kan extension.
10:01:30 <edwardk> er Maybe actually
10:01:39 <copumpkin> that's the polymorphic cont-like thingy, right?
10:01:49 <edwardk> Maybe ~ Yoneda Endo
10:02:57 <edwardk> Yoneda Endo a ~ (forall r. (a -> r) -> r -> r) -- you need to supply what do to with the Nothing  and what to do with the value
10:03:31 <edwardk> to get that in the form of a right kan extension that i can use type families on and all the dispatch stuff i need to make it work in haskell, i need a crap ton of newtypes.
10:03:34 <ski> @quote Yoneda
10:03:35 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
10:03:35 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
10:04:06 <c_wraith> how do I go about converting between strict and lazy bytestrings?
10:04:15 <HaskellLove> instead of using sort i converted my list to set. so now i cant use drop. Can i simulate drop and take for sets?
10:04:24 <edwardk> c_wraith: you can use toChunks and fromChunks iirc
10:04:33 <lispy> ?hoogle toChunks
10:04:34 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
10:04:34 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
10:04:38 <poucet> c_wraith: Why would you want a lazy one if you have a strict one?
10:04:43 <copumpkin> HaskellLove: nope, which elements would you drop or take?
10:04:52 * ski tries to decipher what `inRan' and `outRan' is for ..
10:04:53 <copumpkin> HaskellLove: you can by converting them back into lists
10:04:58 <HaskellLove> i want to take last 30
10:05:05 <HaskellLove> ok will convert then
10:05:09 <c_wraith> poucet: using different packages.  one creates strict, the other uses lazy
10:05:13 <edwardk> c_wraith cwhat isn't obvious is toChunks takes a Lazy Bytestring and returns a list of strict ones.
10:05:28 <sothim> hello, is there a function for the "cartesian product" of lists, that would yield [t,f] x [t,f] = [(t,t), (t,f), (f,t), (f,f)] ?
10:05:31 <poucet> edwardk: he wants the other direction
10:05:52 <jmcarthur> has anybody ever thought of a syntax for newtypes that doesn't require so many constructors and pattern matches?
10:05:55 <edwardk> poucet: then pass fromChunks the singleton list consisting of your strict bytestring
10:06:16 <edwardk> jcmarthur: yeah, just use ml modules/functors ;)
10:06:27 <edwardk> jmcarthur: no more newtypes, but there goes lots of useful polymorphism
10:06:32 <jmcarthur> :(
10:06:34 <edwardk> er ad hoc
10:07:01 <Twey> @src ((->) r) (>>=)
10:07:02 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:07:08 <Twey> @src Reader (>>=)
10:07:09 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:07:12 <Twey> :-\  Hmph.
10:07:21 <copumpkin> @src (->) (>>=)
10:07:21 <lambdabot> f >>= k = \ r -> k (f r) r
10:07:26 <copumpkin> don't ask me why
10:07:34 <c_wraith> edwardk: I think that was directed at me, and thanks.  :)
10:07:42 <Twey> copumpkin: Heh.  Thanks.
10:07:42 <edwardk> ski: outRan :: (RanFunctor m, RanFunctor (t m)) => Ran (t m) a -> t (Ran m) a; inRan :: (RanFunctor m, RanFunctor (t m)) => t (Ran m) a -> Ran (t m) a
10:07:58 <copumpkin> actually I think I know why too
10:08:08 <Twey> Oh?
10:08:15 <copumpkin> it's simple textual lookup
10:08:20 <Twey> Yeah
10:08:20 <edwardk> a 'ran transformer' is written so that you can just say: Ran (StateT MyState IO) a
10:08:24 <ski> jmcarthur : also The Hugs 98 User's Guide - 7. Hugs-specific language extensions - 7.2. Restricted type synonyms <http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html>
10:08:33 <copumpkin> ((->) r) === ((->) a) === ((->) b) etc.
10:08:40 <edwardk> which in this case looks like
10:08:41 <edwardk> and get a monad
10:08:41 <copumpkin> they didn't want to deal with that so they just got rid of the extra variable
10:08:51 <Twey> But the conventional name is (-> r) or ((->) r)
10:08:56 <Twey> Er
10:08:58 <Twey> (r ->)
10:08:59 <copumpkin> not always r
10:09:10 <Twey> Hmâ€¦ I've only heard it called r
10:09:12 <edwardk> forall r. (a -> MyState -> World# -> r) -> MyState -> World# -> r -- modulo all the newtype noise
10:09:36 <ski> Twey : `rho' or `Integer', &c. works, too
10:09:47 <Twey> I suppose so
10:09:49 <jmcarthur> ski: huh, kind of neat
10:09:58 <edwardk> er State# w or whatever it is
10:09:59 <Twey> @src (Ï ->) (>>=)
10:10:00 <lambdabot> Source not found. You speak an infinite deal of nothing
10:10:06 <Twey> Drat :Ã¾
10:10:07 <jmcarthur> would work great for abstract types
10:10:31 <edwardk> heya lispy
10:10:38 <lispy> hey
10:10:45 <lispy> Pidgin is weird
10:10:52 <idnar> > liftM2 (,) [1,2,3] [4,5,6] -- sothim, like this?
10:10:54 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
10:11:01 <lispy> I thought I was talking to people here and then on one was responding
10:11:13 <sothim> ahhh that looks wonderful :D
10:11:13 <lispy> Turns out I was disconnected but it didn't bother to tell me
10:11:16 <edwardk> copumpkin: trying to get these ran issues worked out so i can have a decent mtl like library to build on (and a non-trivial fragment for the interpreter)
10:11:19 <sothim> thanks!
10:11:26 <copumpkin> edwardk: nice
10:11:39 <copumpkin> I'll cross my fingers and hope your mind doesn't melt in the process
10:11:44 <edwardk> hah
10:11:51 <c_wraith> is there a secure temp file api?
10:12:00 <edwardk> no point in having a prelude that doesn't require a ph.d dissertation or two to document
10:12:06 <Twey> Heheh
10:12:12 <copumpkin> exactly
10:12:49 <Twey> Huhâ€¦ lispy's at Galois?  I never knewâ€¦
10:12:50 <edwardk> copumpkin: after all, these are the 'easy' versions of the definitions. they aren't polymorphic in the underlying category. almost all of these should work over an arbitrary CCC. ;)
10:13:05 <sinelaw> segmentation fault
10:13:08 <lispy> Twey: yeah!  Since about Oct. 2009, so kinda new/recent
10:13:11 <sinelaw> core dumped
10:13:12 <Twey> Ah, right
10:13:12 <edwardk> copumpkin: once they are done we can go through and redefine them using the CCC combinators
10:13:14 <Twey> Congrats!
10:13:19 <lispy> Thanks!
10:13:28 <edwardk> copumpkin: and you'll be able to use the ran-transformed monads over an arbitrary category of your choosing.
10:13:38 <edwardk> copumpkin: not that i have many applications for that right now
10:13:50 <Ke> how can I map imports to cabal packages
10:14:47 <ski> edwardk : hm, it's the same `f' and `g' in the whole type, yes ?
10:14:55 <edwardk> yeah
10:15:01 <c_wraith> Hmm.  there's System.Posix.Temp.  I guess that'll do, if I sacrifice all illusions of portability.  (I don't think this program was portable anyway, come to think of it...)
10:15:21 <edwardk> basically you have an underlying monad M a ~ forall r. (a -> f r) -> g r.
10:15:45 <ski> (/me wonders whether `G' and `H' could be renamed into something more meaningful ..)
10:15:55 <edwardk> and you need to generate the monad for M' a ~ forall r. (a -> s -> f r) -> g r
10:15:59 <edwardk> er
10:16:14 <edwardk> M' a ~ forall r. (a -> s -> f r) -> s -> g r
10:17:31 <edwardk> ski: another way to put it: instance Monad (Ran f g) => (Ran (ReaderT s f) (ReaderT s g)) -- is what we're trying to derive
10:17:45 <Ke> heh, leksah gives an error that it can't determine the version of leksahecho
10:17:53 <ski> edwardk : *nod*
10:18:36 <ski> @unmtl ContT o (ReaderT sr m) a
10:18:36 <lambdabot> (a -> sr -> m o) -> sr -> m o
10:18:38 <ski> @unmtl StateT sr (ContT o m) a
10:18:39 <lambdabot> sr -> (a -> sr -> m o) -> m o
10:18:45 <ski> (basically)
10:19:01 <edwardk> ski: except the m's aren't the same
10:19:05 <ski> right
10:19:13 <edwardk> ski: if they were it'd be codensity and its trivial =)
10:21:13 <edwardk> ski: and like you can see in monad-ran the result is realizable. i suppose we could get to something decent by going through and stepwise transforming the awful instance i have in monad-ran
10:21:37 * ski is worrying that maybe this is hitting on the "monad tunneling problem"
10:21:53 <sproingie> what be that?
10:22:38 <edwardk> ski: well, using  liftRan (StateT m) = Ran (\k -> ReaderT (\s -> getRan (liftRan (m s)) (\ ~(a,s') -> runReaderT (k a) s'))) -- and --    lowerRan (Ran m)          = StateT (\s -> lowerRan (Ran (\k -> runReaderT (m (\a -> ReaderT (\s' -> k (a,s')))) s))) -- i can get there by going in and out of traditional State.
10:22:45 <ski> sproingie : given `Foo a -> Foo b' in some monad `Foo', with an inclusion `forall a. Foo a -> Bar a', lift to `Bar a -> Bar b'
10:23:08 <ski> (`Bar' e.g. being `StateT s Foo')
10:23:10 <edwardk> ski: nah, we're able to sidestep that
10:23:35 <edwardk> you can get there by using the strength of all functors in haskell to lift the state through.
10:25:14 <edwardk> ski: re G and H i'm open to better names. I started with them because that horrible Ran class models Ran G H a for some G and H, and i obtain them from a type family over the monad we're modeling. so Ran m a = forall m. (a -> G m r) -> H m r -- lets me model Ran (G m) (H m) in a form i can provide a monad instance for.
10:25:52 <ski> (.. which horrible `Ran' class ?)
10:26:12 <HaskellLove> anyone has the solution for euler 41? so i adapt my algorithm, it means a lot to me what are the first 3 numbers of the solution
10:26:15 <edwardk> but they aren't always adjoint or related to each other in any meanigul way, they are functors in some category, not necessarily Hask (as evidenced by the fact that Maybe is modeled as Yoneda Endo, and Endo is clearly not a Hask Functor)
10:26:46 <edwardk> ski: er sorry not Ran, RanFunctor
10:26:51 <ski> Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
10:27:02 <ski> (sorry. i find that amusing)
10:27:17 <sproingie> if i see the word "euler" in this channel again i will punch you in the neck
10:27:46 <edwardk> Finding Maybe ~ Yoneda Endo made me very happy, all this machinery just relies on the the fact that G m and H m have kind * -> *. not that they are functors.
10:27:47 <Zao> sproingie: I want to take the eulerian 2-norm of a vector.
10:27:50 <edwardk> so you can't even fmap over them
10:27:55 <ski> (sproingie : even if we decide to talk about how to best implement euler's totient function ?)
10:28:21 <sproingie> Zao: i will get around to punching you in the neck once i understand that
10:29:02 <edwardk> ski: the sad this is once this is figured out, it'll be a one-liner like all of the others and forgotten about ;)
10:29:19 <ski> quite possibly
10:29:37 <edwardk> ski: monad-ran includes probably 95% of the hardest 'proofs' i've had to write in Haskell.
10:30:44 <edwardk> mainly because of all of the continuation passing style and newtype noise. i can take one or the other, but both together made my brain hemmorhage
10:32:52 <ski> hm ..
10:33:05 * ski needs more than a one-liner to scribble on ..
10:33:33 <paolino> euler is the troll
10:34:28 <edwardk> ski: what about if we looked at a middle ground Take Monad (Ran f g) => StateT e m -- the resulting bind is almost right.
10:34:42 <sinelaw> ajax is the troll of doom
10:34:46 <edwardk> er instance Monad (Ran f g) => Monad (StateT e (Ran f g))
10:34:54 <edwardk> that code is already written
10:35:04 <edwardk> the only difference is some currying on the arguments being plumbed around
10:35:07 <edwardk> and some argument orders
10:39:54 <Twey> Hmmm
10:45:35 <edwardk> ski: heh, it may be that the inRan outRan approach is optimal
10:46:12 <edwardk> ski: when i mechanically translate the lifting/lowering version i wind up realizing that you need to pass the state through the underlying monad
10:46:50 <edwardk> which means you need to tuple it with the intermediate result it to get it through as the 'a' ((a -> f r) -> g r)
10:47:09 <edwardk> so it becomes a (forall r. ((a,s) -> f r) -> g r)
10:47:15 <Ke> so is there trivial explanation why foldr on list of 2 entries can stack ocerflow
10:47:20 <edwardk> which i can't curry, because i need to be able to submit it to the underlying bind
10:47:23 <Ke> overflow
10:47:48 <edwardk> ke: perchance the foldr isn't the only recursion in your code?
10:48:25 <xerox> Ke http://haskell.org/haskellwiki/Foldr_Foldl_Foldl'
10:48:31 <Ke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15700#a15700 (makeQueue [QueueEvent 1 "a",QueueEvent 2 "b"]) overflows
10:49:07 <bavardage> can I have a class have two 'params'...?
10:49:13 <bavardage> like I want a vector space class
10:49:19 <edwardk> ke: alas, i don't know what those other methods do
10:49:19 <bavardage> would like to have different fields
10:49:29 <bavardage> i.e. definable over different fields
10:49:31 <edwardk> bavardage: yes
10:49:41 <bavardage> class VectorSpace v f where?
10:49:43 <edwardk> bavardage: multi parameter type classes or type families
10:49:44 <Ke> edwardk: http://hackage.haskell.org/package/pure-priority-queue
10:50:05 <bavardage> edwardk: thanks :D
10:50:16 <bavardage> edwardk: now I have what it's called, I found some stuff
10:50:39 <bavardage> oh, suggestions for the haskell typeclass nearest to a field?
10:50:54 <edwardk> bavardage: MPTCs are the 'old way' and type/data families are the 'new hotness' - but really they both serve different needs
10:51:19 <edwardk> bavardage: i think i might have a Field (I know I have Ring) in monoids 0.1.36
10:51:28 <bavardage> ooh
10:51:57 <xerox> edwardk does it let you use numeric literals and operate in arbitrary finite fields? (I always wanted such a thing)
10:52:01 <edwardk> bavardage: http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring.html
10:52:14 <edwardk> bavardage: includes a Field class
10:53:30 <edwardk> xerox: not quite, the fromInteger, etc stuff isn't quite that friendly, mostly because you'd need to hide so much of the Prelude
10:53:33 <ski> edwardk : hm, i was pondering tupling, too ..
10:53:53 <xerox> edwardk ok I can give up fromInteger.
10:53:54 <ski> (iiuc what you meant)
10:54:15 <edwardk> ski: looks like i need to pass through a tuple to use the underlying monad
10:54:36 <edwardk> ski: so i'm going to incur some overhead
10:54:52 * ski has been attempting to figure out the details of that a short while
10:54:58 <edwardk> ski: just contemplating the type of a 'runStateT equivalent shows that off
10:55:40 <ski> (hm .. maybe this would be easier to prototype in Alfa ..)
10:55:43 <edwardk> ski: just start with m >>= k = State$ \s -> do ~(a,s') <- runStateT m s; runStateT (k a) s -- and then all you need is the definition for runStateT that is appropriate
10:56:05 <edwardk> and the arguments flop around in different order
10:56:06 * ski is working directly on the type given to djinn before
10:56:27 <det> edwardk, type/data families ?
10:57:45 <edwardk> run-state m .bind k m s = m.bind (~(a,s) -> runStateT (k a) s) (runStateT m s) -- where runStateT has the following type
10:58:33 <edwardk> runStateT :: (forall r. (a -> s -> f r) -> s -> g r) -> s -> forall r. ((a, s) -> f r) -> g r
10:58:59 <edwardk> which is pretty easy to write, its just  currying and flopping an arg around
10:59:37 <Twey> Is there a â€˜readâ€™ that raises a catchable exception on parse failure, rather than exploding?
10:59:42 <edwardk> det: http://www.haskell.org/haskellwiki/GHC/Type_families
11:00:38 <xerox> ?type reads
11:00:39 <lambdabot> forall a. (Read a) => String -> [(a, String)]
11:00:50 <Twey> xerox: So, no?  :Ã¾
11:01:07 <xerox> Not sure. That is easier :)
11:01:45 <edwardk> er modulo the fact that i used the same name for the dictionary as one of the other function arguments
11:02:39 <ski> @let readM :: MonadPlus m => ReadS a -> String -> m a; readM reads s = do (a,"") <- foldr (mplus . return) mzero (reads s); return a
11:02:41 <lambdabot>  Defined.
11:03:06 <RayNbow> hmm... is Lisp devoid of syntactic sugar?
11:03:11 <ski> > readM reads "False" :: Maybe Bool
11:03:13 <lambdabot>   Just False
11:03:32 <edwardk> raynbow: depends on the lisp, there is some for vectors, etc.
11:03:46 <ski> RayNbow : `quote',`quasiquote',`unquote',`unquote-splicing'
11:04:13 <c_wraith> '(1 2 3 4) is syntactic sugar for (list 1 2 3 4).  If my memory of lisp is at all right.
11:04:24 <ski> it isn't :)
11:04:36 <c_wraith> You also have things like '(1 2 3 . 4) for doing strange stuff.
11:04:43 <jfoutz> (quote (1 2 3 4))
11:04:46 <ski> the former was syntactic sugar for  (quote (1 2 3 4))
11:04:54 <c_wraith> ah.  whoops. :)
11:06:28 <Twey> Hm
11:06:45 <RayNbow> ah ok, thanks :)
11:06:56 <Twey> If I want to catch one of two separate exception types under the new exception scheme, how should I go about it?
11:07:35 <Twey> I.E. catch (\ x -> if isExceptionA x && isExceptionB x then handleException x else throw x) foo
11:07:42 <Twey> Oops
11:07:48 <Twey> s/\&\&/||/
11:08:25 <edwardk> skI: ran-state base .bind k m s = base.bind (~(a,s) -> run (k a) s) (run m s) where run x y z = x (\a y' -> z (a,y')) y
11:09:27 <edwardk> ski: seems to be the best i can do
11:11:12 <Ke> does anyone know any correct use example of pure-priority-queue
11:11:36 <Ke> stack overflow is definitely happening in an innocent looking insert
11:12:08 <c_wraith> Ke: is the insert in a foldl?
11:12:16 <Ke> c_wraith: debugged that away already
11:12:29 <Ke> I'm fairly certain, it's the insert
11:12:45 <gwern> @hoogle Int -> [a] -> [a]
11:12:46 <lambdabot> Prelude drop :: Int -> [a] -> [a]
11:12:46 <lambdabot> Prelude take :: Int -> [a] -> [a]
11:12:46 <lambdabot> Data.List drop :: Int -> [a] -> [a]
11:14:28 <b_jonas> Twey: there's a Control.Exception.catches function for just what you want I think
11:14:37 <gwern> aw man hoogle is so great for writing tutorials especially when you can link to a type search
11:14:40 <gwern> eg.
11:14:43 <gwern> 'But what's our demand function? A little thinking and we know that we have a list, a number, and we get back a list. [Int -> [a] -> [a]](!Hoogle) describes a few functions, the second of which turns out to be what we want: [take](!Hoogle)'
11:14:46 <edwardk> i may just limit myself to doing codensity transformers and falling back on monad-transformers whenever they arent in codense form
11:14:53 <edwardk> the ran ones are fairly hideous ;)
11:15:47 <gwern> :t cycle
11:15:48 <lambdabot> forall a. [a] -> [a]
11:15:51 <gwern> :t repeat
11:15:52 <lambdabot> forall a. a -> [a]
11:16:00 * ski feels to tired to continue on it atm ..
11:17:01 <ski>   cycle = concat . repeat
11:17:12 <Twey> b_jonas: Hmmâ€¦ not quiteâ€¦
11:17:20 <gwern> :t concat . map
11:17:21 <lambdabot>     Couldn't match expected type `[[a]]'
11:17:21 <lambdabot>            against inferred type `[a1] -> [b]'
11:17:21 <lambdabot>     Probable cause: `map' is applied to too few arguments
11:17:30 <gwern> :t concatMap
11:17:32 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
11:17:34 <ski> @type (concat .) . map
11:17:35 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
11:17:38 <Twey> That requires me to supply a handler for each possible type of exception
11:17:43 <Twey> Which isn't quite as flexibl
11:17:44 <Twey> e
11:17:49 <gwern> @hoogle (a1 -> [a]) -> [a1] -> [a]
11:17:50 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
11:17:50 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
11:17:50 <lambdabot> Control.Parallel.Strategies parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
11:18:21 <ski> Twey : would something like `readM' above work ?
11:19:36 <Twey> Where's that?
11:19:41 <Cale> Twey: You can create a new exception type whose instance of Exception will catch both.
11:19:55 <Twey> Cale: How so?
11:20:25 <ski> @let diag :: [[a]] -> [a]; diag ((a:_):ass) = a : diag (map (drop 1 ass)); diag _ = []
11:20:26 <lambdabot>  <local>:14:56:
11:20:26 <lambdabot>      Couldn't match expected type `a -> b'
11:20:26 <lambdabot>             agains...
11:20:40 <ski> @let diag :: [[a]] -> [a]; diag ((a:_):ass) = a : diag (map (drop 1) ass); diag _ = []
11:20:42 <lambdabot>  Defined.
11:20:47 <gwern> @src uncurry
11:20:48 <lambdabot> uncurry f p = f (fst p) (snd p)
11:20:59 <ski> @type diag . (:[])
11:21:00 <lambdabot> forall a. [a] -> [a]
11:21:11 <ski> > (diag . (:[])) []
11:21:12 <gwern> hm. why doesn't uncurry pattern-match, like 'uncurry f (p,q) = f p q'?
11:21:13 <lambdabot>   []
11:21:14 <ski> > (diag . (:[])) [0]
11:21:16 <ski> > (diag . (:[])) [0,1]
11:21:16 <lambdabot>   [0]
11:21:17 <lambdabot>   [0]
11:21:59 <ski> Twey : about twenty minutes back in time
11:22:33 <Twey> Ah!  I see it.
11:22:38 <Twey> Hmm, maybe
11:22:43 <Twey> Thanks
11:26:24 <aavogt> > uncurry const (1,undefined)
11:26:26 <lambdabot>   1
11:26:38 <aavogt> > (\(x,_) -> x) (1,undefined)
11:26:40 <lambdabot>   1
11:27:17 <aavogt> > (\(x,y) -> const x y) (1,undefined)
11:27:19 <lambdabot>   1
11:27:27 <aavogt> > (\(x,!y) -> const x y) (1,undefined)
11:27:28 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
11:28:07 <Cale> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15702#a15702
11:28:12 <sinelaw> how do you call the (0,0) point? forget the english name
11:28:20 <tromp_> origin
11:28:23 <sinelaw> thanks!
11:28:31 <sinelaw> slipped my mind
11:28:45 <tromp_> such an original name
11:29:08 <ski> > loop (\ ~(x,y) -> (x * y,x)) 2
11:29:10 <lambdabot>   4
11:29:35 <sinelaw> tromp_, originally it was
11:30:20 <Cale> Twey: see how that works?
11:30:28 <ski> > (`map` [0 .. 23]) (`permute` "abcd")
11:30:29 <lambdabot>   ["abcd","bacd","acbd","cabd","bcad","cbad","abdc","badc","adbc","dabc","bda...
11:30:30 <sinelaw> tikz rules!
11:33:11 <Cale> Twey: Though it would be more normal perhaps to use separate handlers for each type of exception that you're catching
11:33:14 <path[l]> :t permute
11:33:15 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
11:33:34 <path[l]> permute 3 "abc"
11:33:44 <path[l]> > permute 3 "abc"
11:33:46 <lambdabot>   "cab"
11:33:57 <_andy_> anyone mind helping me with a weird HDBC related error?
11:34:04 <path[l]> sh
11:34:06 <ski> > (`map` [0 .. 5]) (`permute` "abc")
11:34:07 <path[l]> ah*
11:34:08 <lambdabot>   ["abc","bac","acb","cab","bca","cba"]
11:34:18 <burp> @hoogle permute
11:34:19 <lambdabot> Text.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
11:34:19 <lambdabot> Text.ParserCombinators.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
11:34:19 <lambdabot> System.Console.GetOpt Permute :: ArgOrder a
11:34:29 <path[l]> so it's the nth permutation
11:34:45 <ski> > (`map` [0 ..]) $ \i -> zipWith const (permute i ['a' ..]) (takeWhile (<= i) (scanl (*) 1 [1 ..]))
11:34:46 <lambdabot>   ["","ba","acb","cab","bca","cba","abdc","badc","adbc","dabc","bdac","dbac",...
11:35:05 <ski> path[l] : yes
11:35:22 <ski> burp : i implemented it using `@let'
11:35:27 <burp> ok
11:35:28 <path[l]> isn't there already something to get all permutations
11:35:44 <burp> > permutations "abc"
11:35:45 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
11:35:51 <path[l]> ah
11:35:53 <path[l]> ok
11:35:57 <ski> @index permutations
11:35:57 <lambdabot> bzzt
11:36:11 <ski> @hoogle permutations
11:36:12 <lambdabot> Data.List permutations :: [a] -> [[a]]
11:36:18 <path[l]> > take 5 $ permutations "abc"
11:36:19 <lambdabot>   ["abc","bac","cba","bca","cab"]
11:36:26 <ski> (so i didn't define that)
11:36:27 * hackagebot upload: happstack-helpers 0.49 - Convenience functions for Happstack. (ThomasHartman)
11:37:15 <path[l]> lol
11:37:29 <path[l]> does lambdabot have memory anyway? for you to be able to do that
11:37:33 <path[l]> I would have imagined no
11:37:48 <path[l]> > scanl (*) [1..]
11:37:49 <lambdabot>   No instance for (GHC.Num.Num [t])
11:37:49 <lambdabot>    arising from a use of `GHC.Num.*' at <...
11:37:54 <ski> it remembers `@let'-bound definitions
11:37:55 <path[l]> > scanl (*) 1 [1..]
11:37:57 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
11:37:58 <path[l]> oh
11:38:02 <ski> (until someone undefines them all)
11:38:44 <path[l]> :t scanl
11:38:45 <Twey> Cale: Not at all!  I think I will in the morning, though.  Thanks.
11:38:45 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
11:39:14 <ski> > map (take 5) $ (`map` [0 ..]) (`permute` ['a' ..])
11:39:15 <lambdabot>   ["abcde","bacde","acbde","cabde","bcade","cbade","abdce","badce","adbce","d...
11:39:19 <path[l]> there must be a way for lambdabot to retrieve a 1 line description of  a function too :/
11:39:25 <path[l]> I cant figure out what scanl is doing
11:39:27 <_andy_> anyways:
11:39:34 <ski> @src scanl
11:39:35 <lambdabot> scanl f q ls = q : case ls of
11:39:35 <lambdabot>     []   -> []
11:39:35 <lambdabot>     x:xs -> scanl f (f q x) xs
11:39:49 <path[l]> ah
11:40:17 <ski> `scanl' is basically doing a `foldl', but outputs all intermediate results, not just the final one
11:41:10 <ski> > (`map` [0 .. 5]) (`permute` "abc")
11:41:12 <lambdabot>   ["abc","bac","acb","cab","bca","cba"]
11:41:16 <ski> > (`map` [0 .. 5]) (`invPermute` "abc")
11:41:18 <lambdabot>   ["abc","bac","acb","bca","cab","cba"]
11:41:56 * ski wonders how to do the inversion on the index, though ..
11:42:09 <edwardk> hrmm i wonder if i could make the ran transformer stuff smarter by telling the underlying monad something about the fact that i'm transforming _it_ using a consistent higher order functor.
11:42:10 <path[l]> what are you trying to get
11:42:37 <edwardk> the things i'll do to avoid a tuple
11:43:08 <ski> i want a function `invP' such that `permute . invP = invPermute' (and `invPermute . invP = permute')
11:43:22 <path[l]> ah
11:43:52 <path[l]> @src permute
11:43:52 <lambdabot> Source not found. Sorry.
11:43:57 <ski> hehe
11:44:03 <path[l]> :/
11:44:18 <path[l]> 5 `invPermute` "abc"
11:44:24 <path[l]> > 5 `invPermute` "abc"
11:44:25 <lambdabot>   "cba"
11:44:34 <ski> > permute 3 "abc"
11:44:35 <lambdabot>   "cab"
11:44:36 <ski> > permute 3 "ab"
11:44:38 <lambdabot>   "* Exception: {permute _ []}
11:44:40 <ski> > tail (permute 3 "ab")
11:44:42 <lambdabot>   "ab"
11:45:04 <path[l]> whoa
11:45:17 <ski> (that's just a little fun thing i added, for amusement)
11:45:34 <aavogt> > all (\n -> permute n "abcde" == permutations "abcde" !! n) [0..10]
11:45:36 <lambdabot>   False
11:45:38 <path[l]> that is pretty cool
11:46:18 <path[l]> permutations "abc"
11:46:25 <path[l]> permute 1 "abc"
11:46:28 <path[l]> > permute 1 "abc"
11:46:29 <lambdabot>   "bac"
11:46:33 <path[l]> > permutations "abc"
11:46:34 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
11:46:37 <ski> aavogt : my `permute' is specifically defined so as to be "extensible" for longer and longer lists
11:46:52 <aavogt> I don't understand ski
11:47:21 <ski> aavogt : e.g., the first six permutations only permute the initial three elements on a given list of any length
11:47:22 <path[l]> does permutations work on infinite lists?
11:47:49 <path[l]> > take 5 $ permutations ['a' ..]
11:47:59 <monochrom> Some versions do.
11:48:01 <lambdabot>   ["abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\13...
11:48:11 <luite> the Control.Parallel.Strategies documentation says that NFData is deprecated and that DeepSeq should be used instead. But the deepseq package doen't have a DeepSeq class (and uses NFData instead), what to do?
11:48:25 <ski> > (take 5 . map (take 5)) (permutations ['a' ..])
11:48:26 <lambdabot>   ["abcde","bacde","cbade","bcade","cabde"]
11:48:28 <RayNbow> :t (<*>)  -- does this operator have a pronunciation?
11:48:28 <Tomas_> Just getting into Haskell... is there a project out there that could use some newbie help? I can learn and contribute at the same time?
11:48:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:49:05 <_andy_> so getting this as a compiler error:
11:49:06 <_andy_> No instance for (IConnection Connection)
11:49:11 <_andy_> when using HDBC-sqlite3
11:49:14 <_andy_> as such:
11:49:15 <path[l]> ski looks like permutations does the same
11:49:19 <ski> look how the permutation on index two there, `"cbade"' has permuted not only the initial three elements
11:49:55 <_andy_> bracketDb file action = bracket (connectSqlite3 file) disconnect $ \db -> action (ConnWrapper db) `onException` rollback db
11:50:12 <ski> if `0 <= 0 && i < factorial (length as)' then i want `permute i as ++ [a] = permute i (as ++ [a])'
11:50:50 <ski> (er, s/0 <= 0/0 <= i/)
11:51:56 <RayNbow> luite: are you sure it says deprecated?
11:52:01 <ski> path[l] : ok ?
11:52:17 <path[l]> hmm
11:52:20 <path[l]> I see
11:52:25 <path[l]> so it has to know them too
11:52:30 <RayNbow> luite, on http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/Control-Parallel-Strategies.html it says that NFData is only moved to a different module
11:52:48 <path[l]> I don't get it though. Why is that a bad/good thing?
11:53:17 <luite> RayNbow: oh it has been changed, 2.0.0.0 said that NFData was deprecated, 2.2.0.0 says that is has been moved
11:53:21 <ski> because then i can extend this to do a (finite) permutation of an infinite list, in a systematic way
11:53:34 <luite> RayNbow: I guess that answers my question :)
11:53:41 <RayNbow> :p
11:54:11 <path[l]> ski : but permutations right now seems to perform on infinite lists anyway though?
11:54:24 <ski> for any index `i' there is some least `n' such that `i < factorial n', i then permute any list (including infinite ones) by permuting only the prefix of length `n' by the `i'th permutation
11:56:08 * ski is not sure if `Data.List.permutations' works on infinite lists ..
11:56:28 <ski> but i suppose my focus was on the "systematic"
11:57:41 <ski> example : we can consider a decimal number of `n' digits to be a (total) function of type `N -> D10' where `D10' is the type of the ten digits and `N' is a type with `n' elements
11:58:49 <ski> if we increase `N' by one to get `Maybe N', then `Maybe N -> D10' will model decimal numbers of one more digit
11:59:27 <ski> and there's a natural inclusion from `N -> D10' to `Maybe N -> D10', namely one which maps the "extra" position to the zero digit
12:00:17 <ski> if we do a limit of this, we get functions of type `Nat -> D10', which have "finite support", meaning that only a finite number of inputs may map to non-zero digits
12:00:28 <ski> (where `Nat' is the type of all natural numbers)
12:01:11 <ski> this was for the decimal representation of natural numbers
12:02:08 <ski> above, i was interested in the factoradic representation of natural numbers, specifically interpreting the natural numbers as indices of (finite) permutations
12:02:32 <mreh> class MonadState m s | m -> s where
12:02:32 <mreh>  is that an alternate to =>?
12:02:39 <ski> so for each `N', i get the permutations of a list of length `n'
12:02:41 <tibbe> If I copy and modify someone's BSD licensed code, how do I attribute them properly?
12:02:48 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15703#a15703 the b<-[-1000..1000] causes me problems, i get Prelude.head: empty list. I had no problems when b was [1..1000] why us this change causing that?
12:02:57 <ski> but i wanted to do a natural inclusion here too
12:03:10 <byorgey> preflex: seen dcoutts
12:03:11 <preflex>  dcoutts was last seen on #haskell 8 days, 6 hours, 4 minutes and 39 seconds ago, saying: Raevel: your main modules do not need to be called Main.hs
12:03:16 <HaskellLove> here is the whole code
12:03:18 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15703#a15704
12:03:44 <mercury^> [-1000..1000]
12:03:47 <mercury^> > [-1000..1000]
12:03:48 <lambdabot>   [-1000,-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-98...
12:04:38 <HaskellLove> mercury^ yeah but why does that cause error was my question, in context of that code
12:04:48 <mercury^> I don't know.
12:07:58 <ski> mreh : that `->' is not an alternate to `=>', if that's what you wonder ..
12:08:20 <mreh> ski, i was looking at the '|'
12:09:28 <ski> mreh : the `MonadState m s | m -> s' can be read (apart from declaring the class `MonadState' with parameters `m' and `s') as
12:09:34 <ski>   forall m.
12:09:37 <ski>     unique s.
12:09:43 <ski>       MonadState m s
12:09:48 <ski> or, if you prefer
12:10:01 <ski>   forall m.
12:10:10 <ski>     forall s0 s1.
12:10:24 <kmc_> mreh, that's a "functional dependency" or fundep
12:10:30 <ski>          (MonadState m s0
12:10:45 <ski>          ,MonadState m s1)
12:10:53 <ski>       -> s0 = s1
12:11:03 <kmc_> it says that for any particular type M, there is at most one type S such that (MonadState S M)
12:11:13 <mreh> i should learn these existential qualifiers a bit more thoroughly
12:11:13 <jeffwheeler_> Palm just announced an SDK that permits programming with C/C++ for their phones, which use an ARM processor.
12:11:23 <sproingie> pronounced "m determines s"
12:11:33 <jeffwheeler_> So, I assume, llvm can compile for the phones, too.
12:11:39 <sproingie> "monadstate m s such that m determines s"
12:11:40 <kmc_> meaning that each monad has only one state type
12:11:42 <ski> in words : for any `m', if there's an instance `MonadState m s0' and an instance `Monad m s1' for any `s0' and `s1', then `s0' must be the same
12:11:46 <ski> as `s1'
12:11:46 <jeffwheeler_> But that makes me wonder, is there any support for ARM in GHC?
12:11:58 <kmc_> jeffwheeler_, there are some people doing iPhone dev
12:12:02 <kmc_> with an unregistered via-C build
12:12:11 <mreh> jeffwheeler_ how hard can it be to build an assembler?
12:12:14 <ski> (mreh : i uttered no existential, here :)
12:12:15 <kmc_> LLVM would be a better route once the GHC LLVM backend matures
12:12:18 <mreh> i mean compiler
12:12:38 <mreh> optimising it is a little more tricky
12:12:42 <jeffwheeler_> mreh: well, not so much from scratch :)
12:12:49 <jeffwheeler_> just combining the various tools in the right order
12:13:09 <mreh> there must be a c compiler for arm
12:13:19 <mle> there are many
12:13:20 <mreh> do some cross compilation, fun times!
12:13:21 <jeffwheeler_> mreh: of course there is; both LLVM and GCC can do it
12:13:22 <kmc_> gcc has supported ARM since forever
12:13:24 <b0fh_ua> Hi there! I am trying to understand CPS on this example: http://pastebin.com/d6923cbd5. However it's not cleat for me what is (\y -> cfold' f y xs), and where the \y is taken from
12:13:41 <b0fh_ua> Can somebody please explain in details what's going on there?
12:13:43 <jeffwheeler_> Am I correct in saying that "LLVM . . . can do it"? Does that even make sense?
12:13:55 <kmc_> jeffwheeler_, i unpack that statement to "LLVM has a ARM native compilation backend"
12:13:58 <mreh> what do ARM do that is different that gets them all put it Nintendo DSs and smart phones?
12:14:11 <kmc_> LLVM is a lot of things, three languages as well as various tools for manipulating the languages
12:14:23 <kmc_> interpreters and compilers, language frontends, optimizers, etc.
12:14:49 <jeffwheeler_> yeah, so, at one level, it has an "assembly" that can go to, say, ARM
12:14:57 <kmc_> anyway, yes, you can statically generate ARM assembly from LLVM code
12:15:03 <jeffwheeler_> and in theory, one could build a backend for GHC that would write to that "assembly"
12:15:04 <kmc_> their provided code generator will do this
12:15:13 <kmc_> and that is also being worked on
12:15:18 <kmc_> LLVM backend for GHC
12:15:27 <jeffwheeler_> so it definitely seems like the tools exist, they just might not be totally ready or easy
12:15:28 <jfoutz> b0fh_ua: it's building up functions that contain functions, all down the list
12:15:36 <jeffwheeler_> that's awesome :)
12:15:52 <kmc_> however, you also have to port the RTS
12:15:52 <b0fh_ua> jfoutz: so that "y" doesn't make much sense?
12:15:58 <kmc_> some of which is surely non-portable code
12:16:08 <jeffwheeler_> Hmm, hadn't considered that.
12:16:19 <jeffwheeler_> Is that what the iPhone folks have been working on?
12:16:23 <ski> b0fh_ua : imo, that is a bad example of CPS
12:16:40 <kmc_> some of which is written in C--, though there may be an ARM backend for C--, and also in the process of the GHC-LLVM target you will probably write a C-- to LLVM compiler
12:16:41 <b0fh_ua> ski: that's from YAHT
12:16:42 <jfoutz> b0fh_ua: i guess it depends on what f does...
12:16:46 <mreh> the run time system of GHC?
12:16:57 <kmc_> jeffwheeler_, i think they're using GHC in the mode where it outputs everything including the RTS as straight vanilla C
12:17:01 <kmc_> which has suboptimal performance
12:17:05 <ski> b0fh_ua : i know. i still think it's misleading to someone trying to learn the basics of CPS
12:17:07 <kmc_> because C is not a good portable assembler
12:17:29 <ski> b0fh_ua : it is misleading since it is not fully CPS-transformed
12:17:51 <jeffwheeler_> kmc_: ah, hmm; that might be a good place to start until GHC-LLVM matures to usability, though
12:18:00 <b0fh_ua> ski: I'd say it's completely cumbersome :(
12:18:02 <Ke>  thought that C had pretty good micro-optimization repertoire with typical compilers
12:18:19 <monochrom> I agree with ski. It seems the author cannot make up his/her mind.
12:19:31 <b0fh_ua> however I still want to understand "this" :)
12:19:52 <b0fh_ua> I wouldn't sleep well if I don't :)
12:20:26 <b0fh_ua> I simply don't understand what that \y parameter is bound to
12:20:43 <b0fh_ua> or where it's initial value is taken from
12:20:49 <ski> b0fh_ua : better would be
12:20:56 <ski>   foldrCPS f z [] k = k z
12:21:04 <ski>   foldrCPS f z (x:xs) k = foldrCPS f z xs (\y -> f x y k)
12:21:04 <b0fh_ua> to call that lambda some parameter has to be passed?
12:21:06 <ski> or
12:21:14 <mm_freak> is there some overview of 'mature' haskell libraries?
12:21:18 <ski>   foldlCPS f z [] k = k z
12:21:21 <ski>   foldlCPS f z (x:xs) k = f z x (\y -> foldlCPS f y xs k)
12:21:33 <lpsmith> yay,  real cps!
12:21:35 <b0fh_ua> ski: slow down please :)
12:21:39 <ski> those are CPS-transforms of the usual `foldr' and `foldl' functions
12:21:41 <mm_freak> i find that hackage has grown a lot in the last few months
12:21:49 <monochrom> I can sleep well with the knowledge that I can write faulty code and cause other people to lose sleep on it just because they trust it is not faulty and there is anything to understand.
12:21:58 <mm_freak> and it's not always easy to tell good packages from bad ones
12:21:59 <ski> b0fh_ua : just wanted to state the full definitions, first :)
12:22:04 <monochrom> Perhaps I should do that tonight before I sleep.
12:22:16 <mreh> :t evalState
12:22:17 <lambdabot> forall s a. State s a -> s -> a
12:22:45 * hackagebot upload: tagsoup 0.8 - Parsing and extracting information from (possibly malformed) HTML/XML documents (NeilMitchell)
12:22:59 <b0fh_ua> ski: allright, thank you :) But please explain - where those \y gets bound initially?
12:23:09 <b0fh_ua> wow, tagsoup for haskell
12:23:22 <b0fh_ua> I've used it for java for last few years
12:23:23 <ski> for `foldrCPS' or `foldlCPS' ?
12:23:38 <b0fh_ua> ski: whatever
12:23:51 <ski> @src foldr
12:23:52 <lambdabot> foldr f z []     = z
12:23:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:24:22 <ski> the idea of CPS is that instead of returning a value, we pass the value on to a "continuation" .. we continue
12:24:38 <monochrom> It seems that in foldrCPS, y gets bound finally, not initially.
12:24:39 <lpsmith> @let foldrCPS f z xs k = case xs of { [] -> k z ; (x:xs) -> foldrCPS f z xs (\y -> f x y k) }
12:24:41 <lambdabot>  Defined.
12:24:56 <ski> so instead of returning `z' in the base case of `foldr', we pass `z' to the continuation `k' in the base case of `foldrCPS'
12:24:58 <lpsmith> > foldrCPS (:) [] id [1..10]
12:24:59 <b0fh_ua> monochrom: omg
12:24:59 <lambdabot>   Couldn't match expected type `([t] -> t2) -> t2'
12:25:00 <lambdabot>         against inferred t...
12:25:04 <ski> b0fh_ua : ok, so far ?
12:25:16 <lpsmith> > foldrCPS (:) [] [1..10] id
12:25:17 <lambdabot>   Couldn't match expected type `([t] -> t2) -> t2'
12:25:17 <sproingie> CPS is basically how >>= works
12:25:17 <lambdabot>         against inferred t...
12:25:26 <lpsmith> :t foldrCPS
12:25:27 <lambdabot> forall t t1 t2. (t -> t1 -> (t1 -> t2) -> t2) -> t1 -> [t] -> (t1 -> t2) -> t2
12:25:35 <lpsmith> umm
12:25:37 <b0fh_ua> ski: you said that we are passing some value fo the function.
12:25:43 <lpsmith> @undefine
12:25:45 <b0fh_ua> but... I don't see how
12:26:13 <b0fh_ua> in this one foldrCPS f z (x:xs) k = foldrCPS f z xs (\y -> f x y k)
12:26:24 <b0fh_ua> how the \y is bound?
12:26:35 <ski> @let foldrCPS :: (a -> b -> (b -> o) -> o) -> b -> [a] -> ((b -> o) -> o); foldrCPS f z [] k = k z; foldrCPS f z (x:xs) k = foldrCPS f z xs (\y -> f x y k)
12:26:36 <lambdabot>  Defined.
12:26:46 <b0fh_ua> we have to call lambda? ok, but we have to pass some parameter to it?
12:27:25 <b0fh_ua> so there's the statement that we will pass some parameter called y, and use it in call to f
12:27:32 <b0fh_ua> but... I'm lost :)
12:27:42 <ski> b0fh_ua : hm
12:27:46 <b0fh_ua> there's no any call to that lambda? :)
12:27:50 <lpsmith> > foldrCPS (\x xs k -> k (x:xs)) [] [1..10] id
12:27:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:27:52 <ski> i was attempting to start with the base case
12:28:00 <ski> b0fh_ua : are you ok with the base case ?
12:28:22 <b0fh_ua> basic foldl/foldr are completely understandable for me
12:28:36 <lpsmith> > foldrCPS (\x xs k -> k (x:xs)) [] [1..] id
12:28:39 <ski> yeah, but i meant
12:28:40 <ski>   foldlCPS f z [] k = k z
12:28:42 <lambdabot>   mueval: ExitFailure 1
12:28:44 <ski> that base case
12:29:00 <lpsmith> > foldrCPS (\x xs k -> x : k xs)) [] [1..] id
12:29:01 <b0fh_ua> ah, yes
12:29:03 <ski> lpsmith : unsurprisingly
12:29:04 <lambdabot>   <no location info>: parse error on input `)'
12:29:09 <lpsmith> > foldrCPS (\x xs k -> x : k xs) [] [1..] id
12:29:17 <b0fh_ua> we simply call k with argument z
12:29:17 <lpsmith> ski:  I know :)
12:29:19 <lambdabot>   mueval: ExitFailure 1
12:29:32 <ski> b0fh_ua : yes
12:29:45 <ski> so we "return" by calling `k' on the "result"
12:29:48 <ski> ok, so the recursive case
12:29:50 <ski>   foldrCPS f z (x:xs) k = foldrCPS f z xs (\y -> f x y k)
12:29:55 * b0fh_ua should remember that base case and edge condition are the same here
12:30:05 <ski> the corresponding clause of `foldr' was
12:30:09 <ski>   foldr f z (x:xs) = f x (foldr f z xs)
12:30:31 <ski> so, this code calls `foldr', passes the result to a call to `f', whose result is returned
12:30:42 <b0fh_ua> ski: so we call foldr and than use it's result in evaluation of f
12:30:44 <ski> so the CPS version starts by calling `foldrCPS'
12:31:20 <ski> (as if we were in a strict language .. this is because i'm using the call-by-value CPS transformation here .. there is also a call-by-name one)
12:31:49 <ski> so `foldrCPS' is still called with `f' `z' and `xs' like before
12:32:05 <lpsmith> > foldrCPS (\x xs k -> x : k xs) [] [1..10] id
12:32:06 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
12:32:24 <ski> but instead of `foldrCPS' returning its result directly, it wants us to pass it a continuation, so that it can "return" the result by calling the continuation on it
12:32:58 <monochrom> b0fh_ua: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5976#a5976 has example steps.
12:33:00 <ski> so the fourth argument `(\y -> ...)' to `foldrCPS' here is the continuation that we give to `foldrCPS', and that we expect it to call, when it is finished
12:33:01 <b0fh_ua> ski: so it creates a number of functions until it reaches the base case, corect?
12:33:25 <ski> yes, this `(\y -> ...)' corresponds to creating a stack frame to return to later
12:33:56 <b0fh_ua> ski: damn, looks like I start to understand now
12:34:07 <b0fh_ua> so
12:34:17 <b0fh_ua> \y doesn't needs to be bound
12:34:17 <ski> now, what should happen when the recursive call to `foldrCPS' "finishes"
12:34:24 <b0fh_ua> it's just a function definition
12:34:29 <ski> i.e. what about the insides of `\y -> ...'
12:34:29 <b0fh_ua> nothing more
12:34:31 <lpsmith> > foldlCPS (\x xs k -> x : k xs) [] [1..10] id
12:34:32 <lambdabot>   Not in scope: `foldlCPS'
12:34:40 <ski> `y' is a name for the result of the recursive call
12:34:43 <ski> before we had
12:34:52 <ski>   f x (foldr f z xs)
12:35:13 <ski> so our continuation becomes roughly `\y -> f x y'
12:35:13 <_andy_> @src SomeException
12:35:14 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:35:19 <ski> but
12:35:22 <_andy_> @src Control.Exception.SomeException
12:35:23 <lambdabot> Source not found. Maybe you made a typo?
12:35:24 <b0fh_ua> ski: so now we are passing the same lambda function over all recursive calls
12:35:36 <b0fh_ua> until it reaches the base case and get's evaluated to a value
12:35:40 <ski> the current call to `foldrCPS' was not necessarily the last call, it too has a continuation `k'
12:36:05 <ski> if we assume `f' itself expects a contination (i.e. it is written in continuation passing style), then we thus get
12:36:13 <ski>   \y -> f x y k'
12:36:23 <ski> we could have written
12:36:29 <ski>   \y -> f x y (\z -> k z)
12:36:36 <ski> but that's unnecessary
12:37:19 <lpsmith> @let foldlCPS f b [] k = k b ; foldlCPS f b (a:as) k = f b a (\b' -> foldlCPS f b' as k)
12:37:22 <lambdabot>  Defined.
12:37:22 <ski> so, after `f' has computed the combination of the current list element `x', and the recursive result `y', it should pass its result to `k', since that should be the result of the current call to `foldrCPS'
12:37:28 <lpsmith> > foldlCPS (\x xs k -> x : k xs) [] [1..10] id
12:37:30 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:37:53 <b0fh_ua> ski: seems to be clear enough
12:38:06 <lpsmith> > foldlCPS (\xs x k -> k (x : xs)) [] [1..10] id
12:38:07 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
12:38:14 <lpsmith> > foldlCPS (\xs x k -> x : k xs) [] [1..10] id
12:38:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:38:17 <ski> b0fh_ua : well, we are passing bigger and bigger lambda-functions (/ stacks) to the recursive calls (see monochrom's paste)
12:38:32 <lpsmith> > foldlCPS (\xs x k -> x : k xs) [] [1..] id
12:38:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:38:41 <lpsmith> yay!
12:38:50 <copumpkin> :t foldCPS
12:38:52 <lambdabot> Not in scope: `foldCPS'
12:38:59 <copumpkin> :t foldlCPS
12:39:00 <lambdabot> forall t2 t1 t. (t2 -> t1 -> (t2 -> t) -> t) -> t2 -> [t1] -> (t2 -> t) -> t
12:39:15 <b0fh_ua> ski: looks like it is not efficient?
12:39:30 <ski> b0fh_ua : now, for `foldlCPS' we can note that the continuation passed to the recursive call is the *same* as the one given to the current call .. thus that recursive call is a "tail-call", `foldl' is tail-recursive
12:39:33 <sproingie> they're both pretty inefficient
12:40:00 <ski> b0fh_ua : what would be inefficient, and in comparision with what ?
12:40:10 <sproingie> what would foldlCPS' look like?
12:40:25 <b0fh_ua> ski: with usual foldl/foldr
12:40:57 <lpsmith> sproingie:  CPS can be quite efficient;  GHC is especially good on things written in CPS style
12:41:50 <sproingie> can be, i don't know about these
12:42:36 <lpsmith> > foldlCPS (\xs x k -> x : k xs) [] [1..] undefined
12:42:38 <kmc_> mm_freak, the Haskell Platform is a set of generally respected packages
12:42:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:42:54 <kmc_> beyond that, i don't know.  it would be nice to have usage stats on hackage, or actual voting
12:43:14 <lpsmith> hmm
12:44:00 <absentia> http://www.haskell.org/ghc/download_ghc_6_12_1.html --  For most users, we recommend installing the Haskell Platform instead of GHC. The current Haskell Platform release includes GHC 6.10.4 as well as some other tools (such as cabal), and a larger set of libraries that are known to work together. This initial 6.12.1 release is aimed primarily at package maintainers and early adopters ...  when will 6.12.x be available as a platform download?  In learning Has
12:44:04 <mm_freak> kmc_: the HP is minimalistic
12:44:10 <mm_freak> i'm talking about libraries to actually do something ;)
12:44:15 <lpsmith> methinks there is something interesting going on here,  when you "break" the rules and write the folding function in a not-strictly-cps fashion
12:44:16 <absentia> ded just the language.  I have never used cabal or seen other libs (other than the standard prelude?) ...
12:44:35 <absentia> (OS X - snow leopard)
12:44:41 <lpsmith> err, the folding function meaning the function passed to the fold
12:45:12 <ski> (b0fh_ua : i'm not sure which inefficiency you are trying to point to ..)
12:45:35 <b0fh_ua> ski: I just trying to arrange this in mind :)
12:45:53 <b0fh_ua> still have some problems with understanding, but I'll try to sort it out
12:46:03 <b0fh_ua> may be some coffee-break is needed :)
12:46:11 <ski> b0fh_ua : a variant of CPS-transforming higher-order functions is to assume that the function argument has not been CPS-transformed, so it returns normally instead of being passed a continuation
12:46:15 <ski> then you'd get
12:46:30 <ski>   foldrCPS' f z [    ] k = k z
12:46:49 <ski>   foldrCPS' f z (x:xs) k = foldrCPS' f xs (\y -> k (f x y))
12:46:53 <kmc_> mm_freak, i don't think it's minimalistic at all.  it has unix and Win32 APIs, 3D graphics, HTTP, several parsers, STM, fancy datastructures, test frameworks, XHTML...
12:47:02 <kmc_> doesn't seem like they're trying to keep the package count down
12:47:36 <ski> b0fh_ua : now, as excercise, CPS-transform the usual definitions of `length', `(++)', `filter' and `map'
12:47:59 <lpsmith> b0fh_ua:   the continuation passing style takes a while to wrap your head around,  but it's well worth it
12:48:10 <lpsmith> Heck,  I've been at it a while and still learning new things about it
12:48:12 <b0fh_ua> lpsmith: I see :)
12:48:27 <monochrom> I wrapped CPS around my head instead.
12:48:35 <monochrom> @quote monochrom immersion
12:48:35 <lambdabot> No quotes match. Sorry.
12:48:38 <monochrom> @quote monochrom immerse
12:48:38 <lambdabot> monochrom says: Don't wrap your head around haskell. Immerse! Wrap haskell around your head.
12:48:52 <lpsmith> :)
12:50:49 <b0fh_ua> looks like I've got what I missed
12:50:56 <lpsmith> @let myfoldr f b as = foldlCPS (\a b k -> f a (k b)) b as id
12:50:57 <lambdabot>  Defined.
12:51:12 <lpsmith> > myfoldr (+) 0 [1..100]
12:51:14 <lambdabot>   5050
12:51:27 <lpsmith> > myfoldr (:) [] [1..]
12:51:28 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
12:51:36 <lpsmith> err...
12:51:52 * hackagebot upload: hxt 8.4.0 - A collection of tools for processing XML with Haskell. (UweSchmidt)
12:51:53 <lpsmith> @let myfoldr' f b as = foldlCPS (\b a k -> f a (k b)) b as id
12:51:55 <lambdabot>  Defined.
12:52:00 <lpsmith> > myfoldr' (:) [] [1..]
12:52:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:52:53 * hackagebot upload: hxt-filter 8.4.0 - A collection of tools for processing XML with Haskell (Filter variant). (UweSchmidt)
12:53:53 * hackagebot upload: hxt-xslt 8.4.0 - The XSLT modules for HXT. (UweSchmidt)
12:54:09 <lpsmith> > myfoldr' (\x xs -> x * x : xs)  [] [1..]
12:54:11 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
12:56:01 * hackagebot upload: hxt-binary 0.0.1 - Serialisation and deserialisation of HXT XmlTrees. (UweSchmidt)
12:57:01 * hackagebot upload: hxt-cache 0.0.1 - Cache for HXT XML Documents and other binary data (UweSchmidt)
12:57:31 <luite> if I have data A = A  { unA::String } is there a difference between: rnf a = rnf (unA a) `seq` ()   and  rnf (A xs) = rnf xs `seq` ()
12:57:59 <lbeew2000> how do you take the last 4 characters of a string
12:59:54 <ski> luite : as long as `rnf' on `String' is strict, there shouldn't be a difference
13:00:33 <kmc_> > let last4 xs = drop (length xs - 4) xs in last4 "hello world"
13:00:34 <lambdabot>   "orld"
13:00:47 <kmc_> this will traverse the list twice, but i don't know a good way to avoid that
13:01:00 <kmc_> accessing lists (including strings) from the end is much less efficient than accessing them from the beginning
13:01:08 <kmc_> Data.Sequence is a better choice for these situations
13:01:46 <lpsmith> @pl \b a k -> f a (k b)
13:01:47 <lambdabot> flip ((.) . f) . flip id
13:02:26 <luite> ski: hm, that was what I thought (I need to implement NFData for a data type for which the data constructor is not exported), but it still leaks space. must be something else then
13:02:28 <RayNbow> > let {last4 xs@([a,b,c,d]) = xs; last4 (x:xs) = last4 xs} in last4 [1..10]
13:02:30 <lambdabot>   [7,8,9,10]
13:02:37 <RayNbow> > let {last4 xs@([a,b,c,d]) = xs; last4 (x:xs) = last4 xs} in last4 [1..3]   -- fail... :p
13:02:38 <HaskellLove> what is wrong with my euler 27 solution? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15709#a15709 I get a list where the indices a and b are 1 and 41, which is the formula given there http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15709#a15709 but it seems it cant find another formula to produce more primes
13:02:38 <lambdabot>   * Exception: <interactive>:1:162-211: Non-exhaustive patterns in function l...
13:03:27 <ski> > let last4 (_ : xs @ (_:_:_:_:_)) = last4 xs; last4 xs = xs in last4 "hello world"
13:03:28 <lambdabot>   "orld"
13:03:47 <kmc_> <sproingie> if i see the word "euler" in this channel again i will punch you in the neck
13:04:05 <RayNbow> > let last4 (_ : xs @ (_:_:_:_:_)) = last4 xs; last4 xs = xs in last4 "ski"
13:04:07 <lambdabot>   "ski"
13:04:10 <RayNbow> nice :)
13:04:31 * ski is short
13:05:05 <lpsmith> HaskellLove:  you want to calculate the divisors,   not the prime factorization
13:05:06 <jfischoff> is there a function for taking a list of tuples are creating one big tuple?
13:05:15 <kmc_> :t unzip
13:05:16 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
13:05:34 <absentia> ug, I guess not.
13:05:46 <kmc_> jfischoff, there's no general function to "concatencate" two tuples because the result would have a type depending on the sum of the sizes of the input
13:05:49 <ski> @type fmap unzip . unzip
13:05:49 <lpsmith> For example, the divisors of 12 are 1, 2, 3, 4, 6, 12
13:05:50 <lambdabot> forall a b a1. [(a1, (a, b))] -> ([a1], ([a], [b]))
13:05:53 <luite> > let last n = reverse.take n.reverse in last 4 [1..10]
13:05:55 <lambdabot>   [7,8,9,10]
13:06:03 <jfischoff> kmc_: cool thanks
13:06:04 <kmc_> and the type of 2-tuples is really totally unrelated to the type of 3-tuples, etc.
13:06:08 <kmc_> you might want to work with lists instead
13:06:11 <lpsmith> The proper divisors of twelve are 1,2,3,4,6
13:07:23 <jfischoff> kmc_: I like returning tuples because of the pattern matching. Is there a way to do something similar with lists?
13:07:33 <lpsmith> HaskellLove:  I haven't tried your code,  but it looks like it should work
13:07:52 <lpsmith> HaskellLove:  In that it'll correctly factor something into it's prime divisors
13:08:27 <lpsmith> HaskellLove:  Incidentally,  you basically have code that will calculate all the divisors already...
13:08:56 <kmc_> > let [a,b,c] = [1..3] in a+b-c
13:08:58 <lambdabot>   0
13:09:11 <kmc_> > let (a:b:c:_) = [1..9] in a+b-c
13:09:12 <lambdabot>   0
13:09:24 <kmc_> jfischoff, note that the first one will fail if the input list has more or less than 3 elements
13:09:34 <kmc_> the second one will succeed as long as there are at least 3 elements
13:09:41 <kmc_> > let (a:b:c:xs) = [1..9] in (a+b-c, xs)
13:09:43 <lambdabot>   (0,[4,5,6,7,8,9])
13:09:45 <jfischoff> cool
13:10:00 <kmc_> lists are an algebraic datatype, you can pattern match them like any other
13:10:03 <kmc_> except they have special syntax
13:10:11 <kmc_> without the syntax, it's just:   data List a = Nil | Cons a (List a)
13:10:32 <kmc_> and that would look like:  let (Cons a (Cons b (Cons c xs))) = ...
13:10:37 <xerox> > let f (a:b:c:xs) = (a+b-c,xs) in unfoldr (Just . f) [1..]
13:10:43 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
13:21:32 <lpsmith> HaskellLove:  Alternatively,  there is a way you can calculate the sum of the proper divisors of a number quickly and efficiently,   if you are given the prime factorization already
13:23:17 <monochrom> MÃ¶bius inversion \o/
13:26:50 <hatds> is there a name for this functon? It's not quite 'when':   f pred m = if pred then m else mzero
13:27:14 <monochrom> @src guard
13:27:15 <lambdabot> guard True  =  return ()
13:27:15 <lambdabot> guard False =  mzero
13:27:21 <sinelaw> @type f pred m = if pred then m else mzero
13:27:22 <lambdabot> parse error on input `='
13:27:30 <monochrom> guard pred >> m
13:27:32 <sinelaw> @type \pred m -> if pred then m else mzero
13:27:33 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Bool -> m a -> m a
13:27:47 <sinelaw> @hoogle (MonadPlus m) => Bool -> m a -> m a
13:27:48 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
13:27:48 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:27:48 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:28:16 <hatds> guard pred >> m is probably the closest
13:28:24 <hatds> or simplest
13:28:28 <monochrom> I rely on the law mzero>>m = mzero
13:29:01 <trofi_> @pl \pred m -> if pred then m else mzero
13:29:02 <lambdabot> flip flip mzero . if'
13:29:03 <hatds> suggestions for naming this function then?
13:29:23 <ski> monochrom : möbius inversion, where !?
13:29:33 <monochrom> do_or_die
13:30:11 <trofi_> @src guard
13:30:12 <lambdabot> guard True  =  return ()
13:30:12 <lambdabot> guard False =  mzero
13:30:32 <monochrom> MÃ¶bius inversion helps with sum of divisors, doesn't it?
13:31:00 <ski> hm, it probably does
13:31:40 <monochrom> Oh maybe doesn't need MÃ¶bious inversion. Just prove "is arithmetic function".
13:31:49 <ski> @type let preCond b ma = guard b >> ma in preCond
13:31:50 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> m b -> m b
13:32:35 <monochrom> The problem is that "preCond" doesn't remind you it dies with mzero.
13:33:22 <ski> how would it die, otherwise ?
13:33:48 <idnar> what's wrong with the guard version?
13:33:54 <monochrom> I mean it doesn't remind you it dies.
13:34:01 <hatds> yea, I'm thinking guard might be fine
13:34:14 <hatds> it's saving one operator for one space at most
13:34:20 <idnar> "preCond pred m" vs. "guard pred >> m"
13:34:34 <idnar> > map length ["preCond pred m", "guard pred >> m"]
13:34:35 <lambdabot>   [14,15]
13:34:40 <idnar> one char shorter ;)
13:34:40 <hatds> lol
13:34:54 <monochrom> Oh I know! guard_then.
13:35:04 <ski> hooray !
13:35:05 <hatds> there you go
13:35:41 <ski> on this topic, we should also add `done = return ()'
13:36:12 <hatds> done >> launchMissiles
13:36:26 <idnar> @pl \p m -> guard p >> m
13:36:27 <lambdabot> (>>) . guard
13:36:28 <ski> looks pretty, yes :)
13:36:32 <hatds> :)
13:36:39 <idnar> hatds: haha
13:36:51 <lpsmith> monochrom, ski:  aye,  sum of divisors is a multiplicative function, and you could write a specialized sieve to calculate it rather quickly for a large number of different values
13:37:23 <monochrom> I draw inspiration from the theorem prover HOL. It has many tactics of the form "blah_then". They are CPS: "blah_then k" means perform blah and then go on with continuation k.
13:37:36 <hatds> why doesn't applicative have it's own 'guard'?
13:39:18 <monochrom> Alternative has "empty" and you may be able to build a guard from it.
13:39:20 <idnar> @src guard
13:39:21 <lambdabot> guard True  =  return ()
13:39:21 <lambdabot> guard False =  mzero
13:39:33 <idnar> hatds: what would guardA do?
13:39:39 <idnar> (or whatever you want to call it)
13:39:44 <hatds> well, for alternative
13:39:50 <hatds> :t empty
13:39:51 <lambdabot>     Ambiguous occurrence `empty'
13:39:51 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
13:39:51 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:57:0-22
13:40:31 <idnar> @type empty
13:40:32 <lambdabot>     Ambiguous occurrence `empty'
13:40:32 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
13:40:32 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:57:0-22
13:40:35 <idnar> @type Control.Applicative.empty
13:40:37 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
13:40:42 <idnar> right, I always forget about Alternative
13:41:03 <c_wraith> Alternative is strange, because for some reason, it's not just a monoid
13:41:33 <idnar> MonadPlus isn't a monoid either, is it?
13:41:55 <c_wraith> @src Alternative
13:41:55 <lambdabot> class Applicative f => Alternative f where
13:41:55 <lambdabot>     empty :: f a
13:41:55 <lambdabot>     (<|>) :: f a -> f a -> f a
13:42:17 <c_wraith> I mean...  that's Monoid.
13:42:22 <c_wraith> @src Monoid
13:42:22 <lambdabot> class Monoid a where
13:42:23 <lambdabot>     mempty  :: a
13:42:23 <lambdabot>     mappend :: a -> a -> a
13:42:23 <lambdabot>     mconcat :: [a] -> a
13:42:33 <xerox> if <|> is associative
13:42:52 <c_wraith> I'm pretty sure Alternative is defined that way
13:43:16 <idnar> c_wraith: well, MonadPlus instances aren't always the same as the corresponding Monoid instances
13:43:21 <idnar> so I guess the same may be true for Alternative
13:44:28 <c_wraith> @instances Alternative
13:44:29 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
13:44:36 <c_wraith> @instances-importing Alternative
13:44:36 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
13:44:55 <idnar> @instances-importing Alternative Control.Applicative
13:44:56 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
13:45:05 <idnar> @instances-importing Control.Applicative Alternative
13:45:06 <lambdabot> Maybe, WrappedMonad m, []
13:45:21 <c_wraith> Oh, that's the syntax for instances-importing?
13:45:25 <idnar> > Just [5,6] <|> Just [6,7]
13:45:27 * c_wraith makes a note of that
13:45:27 <lambdabot>   Just [5,6]
13:45:32 <idnar> > Just [5,6] `mplus` Just [6,7]
13:45:33 <lambdabot>   Just [5,6]
13:45:36 <idnar> > Just [5,6] `mappend` Just [6,7]
13:45:37 <lambdabot>   Just [5,6,6,7]
13:45:48 <c_wraith> ah.  so I see
13:45:48 <lispy> preflex: seen dcoutts
13:45:49 <preflex>  dcoutts was last seen on #haskell 8 days, 7 hours, 47 minutes and 17 seconds ago, saying: Raevel: your main modules do not need to be called Main.hs
13:46:35 <c_wraith> I guess Alternative does suggest that it be used as a binary or kind of monoid.
13:46:44 <lispy> Has anyone else had problems with the current release of cabal/cabal-install picking the wrong version of base?
13:47:02 <c_wraith> lispy:  yes.  It's been an issue since packages have started being updated for 6.12
13:47:19 <lispy> The show package on hackage seems to install fine with base3, but the current release of cabal seems to pick base4 even if you add --constraint="base < 4"
13:47:42 <ski> @hoogle f (a0 -> b) -> f (a1 -> b) -> f (Either a0 a1) -> f b
13:47:42 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
13:47:43 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
13:47:49 <lispy> (constraints on base seem to be ignored by cabal)
13:48:11 <c_wraith> lispy:  set the constraint on whatever is trying to download that wants base 4, then
13:48:52 <xerox> what is the class for monoids that arent of kind *->* but *?
13:48:56 <lispy> c_wraith: well, so the show package has compile errors so we tried 'cabal install show --constraint="base < 4""
13:49:01 <copumpkin> xerox: Monoid ?
13:49:19 <xerox> doh!
13:49:33 <lispy> c_wraith: the problem appears to be that when used with base4 it should require syb
13:49:54 <lispy> c_wraith: but outside of releasing a new show package I don't know how to fix it
13:52:08 <xerox> copumpkin is there one that doesn't require associativity?
13:52:23 <copumpkin> only identity, no associativity? :O
13:52:30 <xerox> yes
13:52:34 <copumpkin> not that I know of
13:52:34 <xerox> but commutative! :)
13:52:43 <copumpkin> I'd like these things to be more granular
13:52:53 <copumpkin> I'm not a big fan of the thousand names of algebraic structures
13:53:09 <xerox> .oO(edward)
13:53:13 <sinelaw> yeah, they should be named by their properties
13:53:30 <sinelaw> associative-identity algebra
13:53:41 <copumpkin> magma!
13:53:45 <copumpkin> unless you mean algebra
13:53:46 <sinelaw> commutative-distributive algebra
13:53:54 <jmcarthur> xerox: i think you are looking for Unital (but we don't have one already)
13:53:59 <jmcarthur> err
13:54:05 <jmcarthur> that might not require that unit be an identity
13:54:12 <copumpkin> yeah, I have Unital in my algebra class
13:54:17 <copumpkin> what else would unit be?
13:54:19 <xerox> actually I don't have a unit
13:54:29 <jmcarthur> nope, i was right
13:54:33 <sinelaw> xerox-algebra
13:54:39 <jmcarthur> copumpkin: heck, i dunno :P
13:54:42 <copumpkin> if you only have one operation I don't see what else you could do of interest
13:54:43 <xerox> and just one operation sinelaw :)
13:54:45 <copumpkin> well, an annihilator
13:54:51 <copumpkin> oh wait
13:54:52 <copumpkin> no
13:55:01 <copumpkin> cause you still need a distinguished element to annihilate to
13:55:07 <sinelaw> sinelaw sinelaw sinelaw sinelaw
13:55:15 <sinelaw> = sinelaw
13:55:19 <jmcarthur> but that doesn't mean the distinguished element must be an identity, does it?
13:55:27 <HugoDaniel> i would like to understand monad regions and type families, can someone here point to good tuts about these ?
13:55:35 <copumpkin> jmcarthur: what else would it be?
13:56:07 <jmcarthur> a*0=0 and 0*a=0, but 0 is not an identity
13:56:24 <jmcarthur> not multiplicative, anyway
13:56:33 * sinelaw ponder about the m-power loop
13:56:34 <mreh> :t evalState
13:56:36 <lambdabot> forall s a. State s a -> s -> a
13:56:37 <sinelaw> *ponders
13:56:37 <mreh> :t runState
13:56:38 <lambdabot> forall s a. State s a -> s -> (a, s)
13:58:12 <hatds> HugoDaniel: I would start with http://www.haskell.org/haskellwiki/GHC/Type_families  There's also some papers with more diverse examples that are very readable
13:58:51 <hatds> HugoDaniel: looks like the 'references' links at the bottom of the page isn't working atm though
13:59:27 <HugoDaniel> hatds: ive tried to read through that page
13:59:52 <HugoDaniel> but it seems to require some knowledge of GMap...
14:00:24 <Cale> HugoDaniel: That's an example on the page
14:00:37 <Cale> HugoDaniel: It's not a real library as far as I know
14:01:22 <ski> (sinelaw : moufang loops ?)
14:01:39 <sinelaw> ski, Mth-power loops.
14:02:10 <ski> where only power up to `m' is well-defined ?
14:02:54 <sinelaw> ski, given a M-PSK signal with unknown phase shift, raise it to the power M, feed through Phase Locked Loop and divide frequency by M.
14:03:37 <ski> hm, that doesn't sound like a kind of algebra ..
14:04:03 <sinelaw> ski, i wish
14:04:17 <ski> (unless "phase shift" is an action of some kind)
14:05:13 <sinelaw> i'm trying to figure out how it works
14:05:28 <sproingie> PLL is an analog circuit thingamajiggie
14:05:33 <sproingie> lots of fun things you can do with them
14:05:54 * ski wonders whether it makes sense to consider a weakening of power-associative algebras to ones where only even powers associates
14:05:55 <sproingie> still sounded like treknobabble to me
14:06:54 <sinelaw> i wish it did to me as well
14:07:02 <kmc_> haha
14:07:50 <sinelaw> shouldn't have taken this course
14:09:16 <sinelaw> i'm gonna have to re-format my brain after this
14:11:20 <knobo> Any better way of writing this: concat [ x | Just x <- [Just "a", Just "b"]] ?
14:11:37 <sinelaw> map fromJust
14:11:55 <tibbe> bos: you there?
14:12:10 <sinelaw> > map fromJust [Just "a", Just "b"]
14:12:11 <lambdabot>   ["a","b"]
14:12:12 <bos> tibbe: yep
14:12:17 <sinelaw> > map fromJust [Just "a", Just "b", Nothing]
14:12:18 <lambdabot>   ["a","b","* Exception: Maybe.fromJust: Nothing
14:12:23 <sinelaw> *boom*
14:12:42 <sinelaw> it's a bad idea really.
14:13:25 <sinelaw> @type (\a -> case a of  Just x -> [x]; Nothing -> [])
14:13:26 <lambdabot> forall t. Maybe t -> [t]
14:13:34 <sinelaw> @hoogle Maybe t->[t]
14:13:35 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
14:13:35 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
14:13:35 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:13:47 <sinelaw> knobo, toList
14:13:54 <tibbe> bos: I almost have a complete priority queue now, optimized and all. Since it's based on someone elses (BSD) code I need to give proper attribution somehow. Do you know what people usually do. Add an extra LICENSE.<something> file?
14:13:57 <sinelaw> > toList [Just "a", Just "b", Nothing]
14:13:58 <lambdabot>   Not in scope: `toList'
14:14:07 <sinelaw> > maybeToList [Just "a", Just "b", Nothing]
14:14:08 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
14:14:08 <lambdabot>         against inferred ...
14:14:15 <sinelaw> oops.
14:14:20 <tibbe> bos: my priority queue is more than twice as fast as the current TimeoutTable
14:14:22 <sinelaw> > catMaybes [Just "a", Just "b", Nothing]
14:14:23 <lambdabot>   ["a","b"]
14:14:33 <sinelaw> knobo, catMaybes  - and that's final.
14:14:42 <bos> tibbe: that's great!
14:14:57 <bos> tibbe: i'd just add their name to the list of copyrights in that source file
14:15:06 <tibbe> bos: OK
14:15:21 <knobo> sinelaw: Thanx
14:15:26 <bos> tibbe: we should drop the use of the built-in time types, which would improve speed
14:17:04 <tibbe> bos: yes, I'm using Int priorities for now (but I have a type alias so it should be easy to change)
14:17:14 <bos> tibbe: cool
14:17:23 <bos> tibbe: when are you planning to integrate that code?
14:17:36 <bos> tibbe: i want to make sure i don't touch anything you'll be touching :-)
14:17:41 <tibbe> bos: most of the speed gain is from unpacking and strictifying subtrees. I think I can squeeze a bit more out of the balancing scheme used
14:17:54 <tibbe> bos: don't worry. in the next two days I think
14:17:59 <bos> cool
14:18:15 <bos> is your priority queue using a patricia tree, or hinze's code?
14:18:20 <tibbe> bos: I want to make the `loop` function look a bit more like GHC's. shouldn't break anything you've done though
14:18:37 <bos> tibbe: hmm, maybe don't touch that yet
14:18:40 <tibbe> bos: it's a weight balanced tree. if we stick with int keys we might consider a patricia tree
14:18:55 <tibbe> bos: ok, I'll start by submitting the data structure itself.
14:19:10 <tibbe> bos: and just swap out the calls to TimeoutTable with calls to the PQ
14:19:19 <tibbe> bos: but leave the flow unchanged otherwise
14:19:31 <bos> tibbe: i'm improving the support for other threads to wake up the IO manager, which will include the ability to make the IO manager quit, so we might step on each other's toes.
14:19:40 <bos> tibbe: ok, thanks
14:19:57 <bos> tibbe: also working on use of eventfd for routine wakeups on linux.
14:20:22 <bos> that way, we'll have a pipe for data-bearing wakeups (such as "please die now"), and eventfd for "just wake up".
14:20:24 <tibbe> bos: we also need to think about how the code can survive a `fork`. there are also some threading synchronization that I haven't had time to look into yet
14:20:32 <hatds> huh, for some reason I thought you could use infix syntax (like `elem`) for functions with more than 2 parameters
14:20:43 <bos> hatds: you can
14:20:43 <tibbe> bos: sounds great. I think that's what libev does
14:20:59 <hatds> you do:   arg1 `op` arg2 arg3   yes?
14:21:08 <bos> tibbe: i'm not too concerned about fork yet. right now, all ghc supports is immediate exec.
14:21:22 <tibbe> bos: simon m fixed that a few weeks ago :)
14:21:29 <tibbe> bos: and closed my long standing bug
14:21:29 <bos> oh, huh.
14:22:02 <thoughtpolice> which bug?
14:22:03 <tibbe> bos: it can now recreate the OS state (i.e. create an event fd and add all fds again) from the data structures kept by the I/O manager
14:22:29 <tibbe> thoughtpolice: GHC couldn't daemonize a process as the I/O manager would die
14:22:34 <thoughtpolice> ah
14:22:58 <hatds> foldr (+) 0 [1..3]
14:23:02 <hatds> > foldr (+) 0 [1..3]
14:23:04 <lambdabot>   6
14:23:15 <hatds> > (+) `foldr` 0 [1..3]
14:23:16 <lambdabot>   Ambiguous type variable `t' in the constraints:
14:23:16 <lambdabot>    `GHC.Num.Num t' arising ...
14:23:23 <hatds> I'm doing something stupid
14:23:25 <hatds> ?
14:23:31 <Cale> > ((+) `foldr` 0) [1..3]
14:23:33 <lambdabot>   6
14:23:56 <Cale> You were applying 0 to the list [1..3] as if it were a function
14:24:00 <hatds> I wished it worked my way heh
14:24:08 <bos> tibbe: ok, that's good to know about.
14:24:27 <Cale> > (+) `foldr` 0 $ [1..3]
14:24:29 <lambdabot>   6
14:24:47 <hatds> ah, that's the ticket
14:24:49 <cytzol> infix foldr? wack.
14:25:03 <cwraith> I used the robot monkey operator today.  That made me laugh.
14:25:04 <hatds> it was just the first 3-ary function I thought of
14:25:07 <tibbe> bos: we probably need to store the event mask somewhere (probably next to the callback) so it can be used to recreate the event fd
14:25:55 <tibbe> bos: but that can wait
14:26:55 <systemfault> Hey guys, I'm still learning haskell so don't take what I'm going to say too seriously but... Can a haskell program (compiled with ghc) be fast without sacrificing elegance/purity or by using special techniques like memoization?
14:27:19 <systemfault> I'm a bit deceived by my small tests..
14:27:45 <cwraith> ghc produces pretty fast code, in general
14:28:30 <systemfault> Being a noob, I already had to deal with lazyness problems but I got it
14:28:31 <cwraith> that doesn't help if you use a slow algorithm, of course.
14:28:40 <systemfault> Yeah, definitely
14:29:22 <thoughtpolice> ghc indeed generates good code a lot of the time.
14:29:35 <thoughtpolice> luckily there are lots of already highly optimized libraries out there for doing lots of common things
14:29:48 <sproingie> depends on how fast you want it
14:30:06 <systemfault> thoughtpolice: In my "tests", sometimes it's faster with just ghc and sometimes faster with -fvia-C
14:30:44 <thoughtpolice> typically -fvia-C doesn't make too much of a difference these days
14:30:46 <hatds> I suppose the catch for a beginner is that you have to understand the execution order well enough to know if it's doing something stupid or not
14:31:12 <thoughtpolice> really the only reason -fvia-C still exists is just for porting purposes
14:31:28 <kmc_> "be fast" is an awfully vague standard
14:31:30 <systemfault> Ok, I understand :)
14:31:35 <kmc_> do you want it to be as fast as hand-tuned C code?
14:31:48 <kmc_> or just "fast enough" -- if so, for what?
14:31:55 <mm_freak> kmc_: yes, but say i'd like to have a good MD5 implementationâ€¦  there are lots of them on hackage and i'd like to know, which one of those is mature in that it's fast, correct and easy to use
14:31:56 <systemfault> kmc_: well.. I would like it to be "close" to C code
14:32:06 <systemfault> kmc_: Or just 200% slower.
14:32:24 <kmc_> and C code as compiled by a good optimizing compiler?
14:32:33 <hatds> speaking of which, is stream fusion making it into ghc these days?
14:32:35 <systemfault> kmc_: Yes
14:32:40 <kmc_> btw, there can be a big performance difference bteween gcc and icc on the same platform
14:32:56 <systemfault> kmc_: I know it might sounds unrealistic..
14:33:13 <cwraith> hatds: a couple cases of stream fusion are already supported.
14:33:20 <thoughtpolice> hatds: I think libraries adopt it as a technique more than letting GHC do it automatically - it's already almost automatic when you take RULE pragmas into account :)
14:33:34 <cwraith> hatds: there's some sort of effort being made for full supercompilation, which could *really* improve performance in some cases.
14:33:38 <hatds> again, I'd say (based off limited experience) that if you code is "executing like" a C program it will be nearly as fast
14:34:02 <thoughtpolice> whole-program ftw
14:34:24 <cwraith> yeah, whole-program supercompilation would make most abstractions have near 0 overhead.
14:34:40 <systemfault> hatds: Haskell being a better imperative language? :P
14:35:14 <hatds> systemfault: I don't necessarily mean IO, I mean just avoiding things like calculating average of a list naively
14:36:15 <systemfault> Ok :)
14:36:34 <systemfault> BTW, I love the language :)
14:36:51 <hatds> all you need is love...
14:36:53 <kmc_> systemfault, GHC-Haskell gets within a factor of 2 of GCC-C on most of the shootout programs, fwiw
14:37:01 <thoughtpolice> cwraith: for one, type-based dispatch for typeclass methods could be essentially 100% eliminated, although GHC already does a lot of work to optimize them away when doing cross-module optimizations, etc
14:37:09 <kmc_> whether that's idiomatic Haskell code is debatable, much of it isn't
14:37:26 <systemfault> kmc_: Yeah.. That was part of my original question..
14:37:29 <kmc_> and optimizing Haskell can be very tricky
14:37:31 <thoughtpolice> except for thread-ring :)
14:37:34 <systemfault> "Hey guys, I'm still learning haskell so don't take what I'm going to say too seriously but... Can a haskell program (compiled with ghc) be fast without sacrificing elegance/purity or by using special techniques like memoization?"
14:37:41 <thoughtpolice> which I suspect GHC will dominate for a very long time
14:38:06 <kmc_> i'd rather work hard to get my program running fast than to get it running at all
14:38:15 <thoughtpolice> what, I think the #2 in thread-ring is like 20x slower on 4 core or something?
14:38:20 <thoughtpolice> and it's GCC iirc
14:39:13 <systemfault> FOr thread-ring... haskell rocks :)
14:39:16 <kmc_> i'm looking at the Haskell shootout programs now, and there's a lot of variation
14:39:21 <kmc_> some are pretty close to idiomatic code
14:39:23 <systemfault> Followed by Erlang
14:39:37 <kmc_> e.g. binary-trees
14:39:51 <filesmasta> HOT NEW TORRENT SEARCH SITE http://Torrentpirates.org
14:39:57 <systemfault> ...
14:40:06 <systemfault> Freenode spam....
14:40:07 <shambler> systemfault, not anymore ;)
14:40:15 <shambler> http://shootout.alioth.debian.org/u32/benchmark.php?test=threadring&lang=all
14:40:26 <mental> hackagepirates
14:40:28 --- mode: ChanServ set +o xerox
14:40:31 <sproingie> yarr
14:40:32 <systemfault> Ah.. C is the fastest.
14:40:37 <jlouis> mental: thats me!
14:40:55 --- mode: xerox set +b *!*@92.1.247.*
14:41:03 <kmc_> imo, there's a big difference between whether the code is "idiomatic" and whether it has pure functions only
14:41:10 --- mode: xerox set -o xerox
14:41:30 <kmc_> well, okay -- all Haskell functions are pure functions
14:41:38 <shambler> but wait, there is http://shootout.alioth.debian.org/u64/benchmark.php?test=threadring&lang=all&lang2=java
14:41:43 <shambler> i'm confused
14:41:46 <kmc_> i should say: ...whether it computes solely by graph reduction
14:41:48 <sproingie> kmc_: what about unsafePerformIO?
14:41:53 <kmc_> sproingie, never mind that ;)
14:42:19 <kmc_> anyway i distinguish "idiomatic" from "side-effect-using" because  i don't subscribe to the notion that side-effects are inherently un-Haskelly or second-class
14:42:28 <hatds> say I have something like mapM_ f1 . f2 . f3 $ f4 xs which in theory could be fused to make no intermediate lists.  Is there an easy way to figure out to what extent it is fused and/or how much time there is to potentially gain by making it fuse?
14:42:29 <shambler> ohm that's x64
14:42:43 <kmc_> there is an idiomatic way to deal with side effects in Haskell
14:42:47 <sproingie> sure but writing C in haskell is something you know when you see it
14:43:07 <kmc_> yes.  but a program doing lots of computation in IO is not necessarily "C in Haskell"
14:43:14 <kmc_> for example, in C you can't define your own control flow structures
14:43:37 <Cale> hatds: You could look at the core output from GHC as well as examine the list of rules which fired.
14:43:58 * sproingie has been pondering the object identity problem in FP
14:44:22 <hatds> Cale: is there tutorials for reading Core?
14:44:24 <Cale> hatds: check out the ghc-core tool from hackage which colourises the output of GHC's various intermediate-dumping options.
14:44:38 <sproingie> i guess object identity is only meaningful with state, and i pretty much know how to deal with state
14:44:54 <Cale> Not as far as I know, but it's a fairly simplistic functional language -- a bit like a subset of Haskell
14:47:08 <hatds> sproingie: reminds me of times I wondered about a "cloning" function:  f :: a -> a which is semantically the identity function but the result isn't shared in the lazy-sense with the argument
14:47:26 <kmc_> you would need a deep-copy operation
14:47:31 <sproingie> bit like the inverse of identity there
14:47:39 <sproingie> creating somethign that's "the same but not"
14:47:45 <kmc_> which would require a typeclass or some deep compiler magic
14:47:51 <mle> why would you want a copy?
14:47:59 <hatds> it's just a curiosity
14:48:24 <mle> if the original is immutable... then it can represent every copy
14:48:58 <sproingie> i'm thinking in terms of games which have lots of actors that interact in various stateful ways and need to refer to each other
14:49:25 <hatds> but if the original is a long list, you might want to have careful control over how much is evaluated at one time
14:49:40 <sproingie> i could say screw it and use refs, but i want to think of more elegant ways
14:50:58 <kmc_> sproingie, which problem are you trying to solve exactly?
14:51:18 <sproingie> kmc_: nothing specific, just woolgathering on the problem of identity in general
14:51:33 <sproingie> it occurs to me a lot of it is illusory anyway
14:51:36 <hatds> object identity problem refers to the programmer's problem of keeping track of it, I thought
14:51:50 <kmc_> most languages confuse identity, value, and state
14:51:56 <kmc_> the Clojure guy had a good talk on this topic
14:52:19 <sproingie> i have two axe objects, one of them is the "rusty axe" the other is the "+5 axe of fiery doom", it occurs to me i don't really *need* identity there
14:52:22 <kmc_> i think the pure sense of identity in Haskell is the sense used by pattern matching
14:52:29 <kmc_> same constructor, identical fields
14:52:50 <edwardk1> looks like what i'd hoped for with changing the relationship between the kan-extension transformer and the kan-extension monad transformee won't work, the transformee doesn't know enough to get in and out of the higher order functor involved. =/
14:52:59 <sproingie> one guy picks up +5 AoFD, as long as i ensure there isn't some other AoFD lying around then i've successfully created the idea of identity
14:53:16 <kmc_> (==) might return true for object pairs that don't satisfy this identity, but it must return true for pairs that do
14:53:33 <kmc_> so identity is a subset of equality, as you'd expect
14:53:51 <kmc_> the identity relation is the minimal equivalence relation
14:54:02 <sproingie> i've read rich's talks about state and identity, and frankly it strikes me as a lot of philosophical handwaving
14:54:06 <kmc_> or anyway "a minimal"
14:54:07 <edwardk> kmc: unless you perform ieee floating point semantics to govern your definition of (==)
14:54:11 <kmc_> :(
14:54:15 <hatds> sounds like we're talking about meta-identity of objects in the game, and not things in the program's memory
14:54:26 <kmc_> IEEE floating point makes me sad
14:54:36 <edwardk> > let x = 0/0 in x == x
14:54:36 <kmc_> hatds, i agree
14:54:37 <lambdabot>   False
14:54:56 <aug_triad> Hi, I am getting the error: openBinaryFile: resource exhausted (Too many open files), but I am not exactly sure why this happens. I am doing a lot of reading in chunks, but after each chunk, I close the handle like: handle <- openFile path_form ReadMode and hClose handle. The error only arise  when reading many chunks of data. I am also using importFile file, but this function closes the handle itself, I suppose.
14:54:57 <sproingie> hatds: ah but in most languages the two concepts are essentially the same.  either that or they're goverened by some "unique id"
14:55:01 <edwardk> kmc_: yeah, we need a NaN monad ;)
14:55:33 <kmc_> aug_triad, sounds like lazy I/O gone wrong.  is importFile lazyV
14:55:37 <kmc_> lazy?*
14:55:44 <kmc_> @hoogle importFile
14:55:44 <lambdabot> No results found
14:55:49 <kmc_> where's this come from?
14:56:01 <hatds> sproingie: to me, the existence of another fiery axe isn't easy to determine from the program's memory...  it could be loaded into memory later when you walk into a new room
14:56:18 <kmc_> aug_triad, if you are on UNIX, strace is a wonderful tool to see the exact sequence of open() and close() syscalls
14:56:52 <aug_triad> kmc_:, yes, I'm on UNIX (OS X), I will try it
14:58:41 <mreh> from experience, would you say records work nicely with State monad?
14:58:42 <sproingie> i could keep a map of all objects and just associate them by key and that would be easy and there'd only ever be one authoritative version of the object to ever update
14:58:52 <mreh> seems the only realistic way to encapsulate state
14:59:13 <sproingie> i just wonder if i'm really stuck with that approach
14:59:22 <cwraith> records have an issue with the state monad.
14:59:27 <kmc_> mreh, no, only with one of the packages like fclabels, lenses, data-accessor
14:59:31 <kmc_> otherwise you write lots of boilerplate
14:59:39 <cwraith> that issue is:  modify $ \s -> s { foo = x }
14:59:53 <kmc_> modify (\r -> r { n = f $ n r })
15:00:05 <kmc_> terribly ugly "design pattern"
15:00:36 <hatds> you could use IORef's, it's a compromise in some sense but might be easier to work with
15:00:38 <cwraith> lenses work very cleanly for the state monad.  the other packages work a bit better in non-state cases
15:00:40 <mreh> kmc_ that's record syntax for you
15:00:53 <mreh> data-accessor is another Henning library... noooooooooooooooooo!
15:01:01 <cwraith> mreh: look at lenses, then
15:01:22 <sproingie> yeah refs would be easy, end of story.  i guess i could use both.
15:01:35 <kmc_> consider ST as well
15:01:40 <hatds> sproingie: actually I was talking to mreh
15:01:45 <sproingie> ah :)
15:01:46 <kmc_> the thing is, IO or ST actually changes the operational behavior
15:01:50 <hatds> I'm still thinking about your reply
15:01:52 <kmc_> State is just sugar for pure functional state passing
15:02:07 <mreh> kmc_ mmm, and very sweet it is too
15:02:41 <mreh> i just want the simple abstraction of passing round implicit state
15:02:54 <mreh> passing state round implicitly rather
15:03:14 <edwardk> kmc_ with data-accessor: modify (property ^= value) -- doesn't suck so much
15:03:24 <kmc_> right, that's fine
15:03:24 <mreh> scalability is an issue too
15:03:38 <hatds> sproingie: I think in some sense I would be more tempted to have uniqueness of these items be true by an invariant of the program somehow
15:03:41 <mreh> edwardk: modify what though?
15:04:07 <mreh> :t (^=)
15:04:08 <lambdabot> Not in scope: `^='
15:04:09 <edwardk> mreh: property there is a 'data-accessor' which is basically a functional reference.
15:04:21 <adekoba> hello, if I have a data type: data Colour = Red | Green | Blue, how can I randomly select colours?
15:04:24 <edwardk> http://hackage.haskell.org/packages/archive/data-accessor/0.2.1.2/doc/html/Data-Accessor-Basic.html
15:04:27 <hatds> mreh: pass IORefs :)
15:04:37 <edwardk> mreh: fromSetGetÂ :: (a -> r -> r) -> (r -> a) ->Â TÂ r a
15:04:39 <mreh> hatds: sounds like C programming
15:04:44 <sproingie> maintaining uniqueness is one part of it, the other is who becomes responsible for updates.  passing around refs, easy, anyone can update any object
15:04:45 <edwardk> (^=) : T r a -> a -> r -> r
15:05:03 <sproingie> for some reason that doesn't appeal to me.  if i wanted to do that i'd write it in java
15:05:09 <mreh> s;lk
15:05:13 <mreh> oops
15:05:22 <edwardk> mreh: you make an accessor using fromSetGet for each member of your structure
15:05:31 <mreh> edwardk, oh
15:05:39 * hackagebot upload: safer-file-handles 0.2.0.1 - Type-safe file handling (BasVanDijk)
15:05:42 <edwardk> mreh fc-labels is similar, but the accessors form a Category, so you can compose them with .
15:06:10 <edwardk> mreh: http://hackage.haskell.org/package/fclabels
15:06:33 <mreh> Data.Accessor still has a degree of boilerplate
15:06:54 <edwardk> mreh: $(mkLabels [''Person, ''Place]) -- is the approach for fclabels
15:08:09 <edwardk> where you just say data Person = Person { _field :: Int, _whatever :: Double -> Int, ... } -- and you get appropriate accessors named field and whatever
15:08:46 <edwardk> only problem i have with Data.Accessor is they named the accessors 'get' and 'set', 'set' is fine, but 'get' interferes with MonadState.
15:09:13 <mreh> edwardk, yes it does, import qualified easily sorts that out though
15:09:17 <mreh> not so much of a hassle
15:09:31 <edwardk> mreh: yeah, i do like the package though
15:09:42 <Lemmih> adekoba: randomColor = Green -- Guaranteed to be random.
15:09:45 <hatds> sproingie: what kind of updates are we talking about
15:09:57 <adekoba> Lemmih: >_>
15:10:01 <mreh> $(mkLabels [''Person, ''Place]) -- I still don't understand the syntax here
15:10:17 <kmc_> adekoba, data Colour = Red | Green | Blue deriving (Enum)
15:10:27 <kmc_> adekoba, then pick random integers from (0,2) and use toEnum
15:10:55 <kmc_> > map toEnum $ randomRs (0,1) (mkStdGen 34234961) :: [Bool]
15:10:56 <lambdabot>   [False,False,True,False,True,False,True,False,True,False,False,False,True,F...
15:11:06 <edwardk> mreh: thats template haskell.
15:11:16 <edwardk> $(...) is a splice where code gets inserted
15:11:25 <Ke> :t maybe
15:11:26 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:11:47 <adekoba> kmc_: that works.
15:12:03 <edwardk> ''Person -- translates from the constructor Person in scope into a qualified name referencing it, so TH can inspect the constructor and extract the names of each of its fields
15:12:47 <aug_triad> Is it correct that the only way of getting the error: openBinaryFile: resource exhausted (Too many open files), is if the handle is not closed with hClose ?
15:13:03 <edwardk> er .. s/constructor/type constructor/ above
15:13:09 <edwardk> http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
15:13:11 <mreh> >__<
15:13:22 <mreh> i'll have to learn template haskell then
15:13:27 <shapr> Don't worry, it's way cool.
15:13:52 <kmc_> aug_triad, not sure -- that's more of an OS question than a lanugage question
15:14:28 <mreh> I don't have the time, i'll have to try the easiest one to learn, which seems like Data.Accessor :@
15:14:42 <edwardk> for instance: bar = let foo x y z = .... in $(dosomethingCrazyWith 'foo) -- can generate arbitrary code at compile time. and the 'foo is passed to it, so the code that it generates can reference that function.
15:14:53 <edwardk> mreh: i think fclabels is easier
15:15:05 <edwardk> you don't need to understand TH to use it
15:15:09 <mreh> fclabels, oh okay
15:15:23 <sproingie> hatds: game objects may change state.  weapons and armor may wear down, creatures may be injured, etc.  with refs the problem is super easy, you just update things as a side effect.  clearly there's other ways to think about it though
15:15:29 <kmc_> yes, you can just treat the TH splice as a compiler extension which generates the first-class labels for you
15:15:37 <edwardk> get, set, mod, and mkLabels are all you need
15:15:46 <kmc_> just like "deriving"
15:15:51 <kmc_> you definitely do not need to know how to write a TH splice
15:16:01 <kmc_> which is a whole fun can of worms
15:16:28 <edwardk> yeah i typically write TH for use as $(derivingSomethingComplicatedButMethodical ''Foo)
15:16:35 <mreh> I can't believe how much haskell has sped up my development time
15:16:50 <kmc_> isn't it great to write code which will probably work once it compiles?
15:16:55 <mreh> YES
15:17:10 <mreh> compilation is the hardest part for once
15:17:20 <edwardk> awww. i'm sad. http://cs.acadiau.ca/~dbenoit/research/webcensus/Web_Census/Photos.html#6 doesn't seem to have the original image available anywhere, or i'd download it and twist it into the xkcd internet map form =(
15:17:48 <mreh> the only errors are semantics ones, by definition of having a fantastically rigorous type system
15:18:05 <edwardk> ala http://xkcd.com/195/
15:19:43 <hatds> sproingie: I would use IORefs here because these are things that are persistently in memory anyway
15:19:44 <mle> that's a remarkably terrible picture as-is
15:19:56 <edwardk> yeah exactly
15:21:00 <mreh> there was another xkcd atlas of the web
15:21:16 <mreh> geared towards visitors I think
15:21:44 <mreh> holiday makers etc
15:22:05 <edwardk> mreh: can't find original url, this one? http://www.davidroessli.com/logs/assets/img/xkcd_online_communities_340.png
15:22:13 <tensorpudding> ooh
15:22:15 <tensorpudding> hilbert curve
15:22:40 <edwardk> tensorpudding: yeah, hence why i thought it'd be nice to take that ping map and convert it to xkcd form
15:22:40 <mreh> edwardk: that's the one
15:22:50 <mle> hm, they're assuming /24's and a lot of other moderately brainless things
15:22:56 <edwardk> of course
15:23:09 <kmc_> mreh, i liked bcpierce's point that types force you to prove theorems about your program, and it doesn't even matter so much which theorems you prove, because most errors are obvious to a formal system and will break anything you try to say about that code
15:23:39 <edwardk> kmc_: great point!
15:23:47 <mreh> tesitify
15:23:51 <jlouis> kmc_: it is very true
15:24:02 <edwardk> kmc_: sounds a bit like http://www.codypowell.com/taods/2010/01/learn-from-fairy-tales-guy-steele-style.html
15:24:18 <jlouis> any nontrivial property tends to break if the type system has just a little amount of sanity
15:24:19 <kmc_> i think it does matter which theorems you prove, but that we get a lot even by proving the "obvious" ones
15:24:46 <jlouis> kmc_: certainly, there are degenerate cases
15:25:01 <sproingie> hatds: yah it seems to always come back to IORefs.  eh, i guess i'd otherwise end up reinventing them poorly.
15:25:21 <mreh> what's the best example of haskell blowing competition out the water so far?
15:25:37 <sproingie> hatds: i just hate how imperative my graphics examples have felt that use them
15:26:03 <mreh> I know cases where haskell was used to prototype a system very quickly, but they never used the haskell program
15:26:07 <kmc_> mreh, maybe Atom (the hard-realtime EDSL) or the financial modeling EDSLs
15:26:07 <sproingie> loadAntiShipMissile >>= launch
15:26:16 <kmc_> both linked from the Haskell in Industry wiki page
15:26:33 <kmc_> XMonad is popular too but i don't know how much of that can be attributed to using Haskell
15:26:34 <hatds> sproingie: it's always an option to return new values instead of IORefs, the only thing that makes me shy away from pure updates is if I am updating a very tiny piece of the whole
15:26:54 <Philippa> kmc_: I suspect XMonad's viability is due to haskell
15:27:01 <kmc_> re theorems, i guess it's a matter of whether you want to say specifically "this program has property X" versus just "this program probably does what the author intended"
15:27:03 <Philippa> otherwise it'd probably be patches to an existing project instead
15:27:06 <roconnor> where is that page that shows how darcs does merging properly and everyone else basically fails
15:27:22 <roconnor> because the others ignore history
15:27:23 <mreh> TH, is that some kind of preprocessor?
15:27:29 <kmc_> in the latter case, it mostly suffices to pick *any* set of nontrivial theorems, because failures to express intent usually lead to incoherent code
15:27:33 <mle> mreh: template haskell
15:27:33 <kmc_> mreh, slightly
15:27:35 <jlouis> roconnor: it is a bad example as merging is unimportant :)
15:28:03 <mreh> kmc_ my body almost rejected the impurity
15:28:09 <sproingie> i wouldn't say others do it wrong, they just operate under different assumptions
15:28:33 <roconnor> jlouis: eh?
15:28:37 <kmc_> edwardk, cool link.  glad people are discussing something from Coders at Work other than spolsky's stupid article about jwz's duct tape comment
15:28:51 <jlouis> roconnor: Yes. Branching is much more important than merging.
15:28:55 <kmc_> mreh of what?
15:29:03 <sproingie> the patch commutation algorithm does do wonders for performance
15:29:07 <sproingie> er does NOT
15:29:20 <mreh> kmc_ well it isn't impure is it, it just look like a macro or something of that nature
15:29:24 <kmc_> what is impure?
15:29:26 <kmc_> TH?
15:29:38 <kmc_> what do you mean by "impure"?
15:29:45 <kmc_> it allows you to evaluate Haskell code at compile time
15:29:47 <mreh> it happens on a higher level of abstraction that the program
15:30:00 <kmc_> and to have said code produce a Haskell abstract syntax tree, which is spliced into the code you are compiling
15:30:10 <roconnor> jlouis: doesn't branching imply merging?
15:30:42 <kmc_> it happens that this compile-tiem code generation occurs in a monad which can do IO, if that's what you mean by "impure"
15:30:49 <kmc_> that is not an essential part of the design
15:31:04 <jlouis> roconnor: right, but having a merge algoritm which fails to do the "right thing" in some situations is not as bad as being unable to shuffle, say 100-200 branches at once
15:31:28 <roconnor> people always say things like that.
15:31:33 <roconnor> I don't buy it
15:31:45 <jlouis> Then we disagree. That is fine.
15:31:45 <kmc_> unlike C macros there is a reasonable amount of effort to avoid name capture, and generally to connect names between compilation phases cleanly
15:32:09 <kmc_> mreh http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/meta-haskell.pdf
15:32:56 <kmc_> mreh, great paper.  fig. 1 describes the phases of compilation -- it's more complex than just "TH eval phase" and "compile phase"
15:33:07 <mreh> :t (.)
15:33:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:33:23 <mreh> kmc_ okay
15:33:25 <kmc_> :t let (f . g) x = f (g x) in (.)
15:33:26 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
15:33:40 <mreh> kmc_ i was just interested what class (.) was in
15:33:49 <kmc_> ah in standard Haskell it's not in a class
15:34:03 <kmc_> it's just the function composition (b -> c) -> (a -> b) -> (a -> c)
15:34:10 <mreh> uhuh
15:34:10 <kmc_> it should be a member of the Category class
15:34:16 <mreh> that's what i though
15:34:18 <kmc_> but is not, even in lambdabot's crazy caleskell
15:34:25 <kmc_> it is in category-extras
15:34:42 <jlouis> roconnor: perhaps one can split wrong merges into the categories of: Says OK but is wrong and Says Wrong but is OK (false positives and negatives). The former is the problematic one
15:35:00 <kmc_> class Category (~>) where { id :: a ~> a; (.) :: (b ~> c) -> (a ~> b) -> (a ~> c) }
15:35:10 <mreh> I need to hide (.) id and mod it seems to use fclabels
15:35:13 <kmc_> :t (<<<)
15:35:14 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
15:36:25 <mreh> :t (>>>)
15:36:27 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
15:36:36 <kmc_> (>>>) = flip (<<<)
15:36:37 <mreh> i thought that was arrow syntax,
15:36:45 <kmc_> it is, but it can be generalized to any Category
15:36:46 <mreh> both?
15:36:56 <kmc_> Arrow is sort of "Category with products and other crap"
15:37:15 <kmc_> the class Category I gave above captures the category-theoretic idea of category, and no more
15:37:34 <kmc_> similarly, Functor can be generalized to include all functors, and not merely endofunctors on the (->) category
15:37:38 <jmcarthur> yeah arrow is such an ad hoc class
15:37:39 <mreh> a Category being what exactly?
15:37:47 <kmc_> mreh, something with id and (.)
15:37:54 <kmc_> a category is a "typed monoid"
15:38:07 <kmc_> it has a set of types and a set of "morphisms"
15:38:24 <mreh> that doesn't sound so bad
15:38:26 <kmc_> each morphism has a signature like "S -> T" for type S, T
15:38:49 <kmc_> for every type T, there's a specific "identity morphism" with signature "T -> T"
15:38:55 <kmc_> (there can be other morphisms with that signature)
15:39:11 <jmcarthur> it's instructive to compare id to mempty and (.) to mappend
15:39:30 <kmc_> you also have a composition on morphisms... you can compose a morphism like (B -> C)  with one like (A -> B) to get one like (A -> C)
15:39:56 <kmc_> and you require that composition is an associative operator, and that the identity morphism for any type is an identity for this operator, on the left or the right
15:40:00 <kmc_> and that's what a category is.
15:40:26 <kmc_> in maths people will use the word "object" instead of "type", which is confusing to many programmers
15:40:42 <mreh> GHC compilers TH implicitly does it?
15:40:48 <kmc_> because, while morphisms "look like" functions, they are abstract... you do not apply them to values, only compose them
15:41:02 <mreh> s/compilers/compiles/
15:41:12 <kmc_> mreh, yeah
15:41:21 <kmc_> actually i think it runs some of the TH splice code using the bytecode interpreter
15:41:34 <kmc_> but there is this limit, that you cannot use top-level definitions from a module in a splice in the same module
15:41:48 <kmc_> so often a project will split the compile-time code into another module
15:42:09 <kmc_> Haskell has the property (which not all categories do) that, for any types A, B, there is another type which represents the morphisms from A to B
15:42:20 <kmc_> i imagine this property has a general name but i don't know what it is
15:42:40 <ecooper> exponentials
15:43:26 <kmc_> ah, this has to do with Cartesian closed categories, doesn't it
15:45:03 <ecooper> a CCC has exponentials and products and (I think) coproducts, which is true of haskell's type system
15:45:31 <ecooper> ah, sorry; CCCs needn't have coproducts
15:46:07 <kmc_> what's the terminal object of Hask?
15:46:10 <kmc_> ()?
15:46:31 <ecooper> yes: every type has a unique function into that type
15:46:58 <Saizan_> well, modulo the usual problems with bottom/seq
15:47:11 <kmc_> and there's no initial object
15:47:22 <Saizan_> that would be data Void
15:47:57 <kmc_> how do i write ex_falso_quodlibet :: Void -> a?
15:48:01 <kmc_> it's an empty pattern match?
15:48:07 <kmc_> :t case () of {}
15:48:08 <lambdabot> parse error on input `}'
15:48:11 <kmc_> :t case () of { }
15:48:12 <Saizan_> in a total language it'd be
15:48:13 <lambdabot> parse error on input `}'
15:48:24 <kmc_> Proof. intros H. inversion H. Qed.
15:48:27 <Saizan_> in haskell you can use undefined :P
15:48:28 <ecooper> i think you don't have syntax for it in Haskell.
15:48:32 <kmc_> yeah, that's cheap though
15:49:20 <Saizan_> it's the same handwaving you use when you say there's only one morphism into ()
15:49:20 <ecooper> does anyone know about the LLVM bindings?
15:49:25 <mreh> is (++) r-associative or efficiency?
15:49:45 <kmc_> mreh, probably
15:49:54 <roconnor> jlouis: the former is what the other DVCs have  They can appear to merge properly and be incorrect.
15:49:58 <kmc_> (a ++ b) ++ c == a ++ (b ++ c)
15:50:01 * SamB_XP_ gives mreh an f
15:50:14 <mreh> s/of/for/
15:50:30 <kmc_> so by a naive assumption that (b ++ c) is longer than a, the latter is faster
15:50:38 <kmc_> maybe there is even a rewrite to this effect
15:50:58 <ecooper> a ++ (b ++ c) should be better for laziness, right?
15:51:11 <Saizan_> even if a is longer, a ++ (b ++ c) is faster
15:51:17 <Saizan_> actually, it's even more so
15:51:27 <mreh> in a ++ (b ++ (c ++ d)), b is shorter than a ++ b though
15:51:37 <Saizan_> (a ++ b) ++ c traverses 'a' twice.
15:51:48 <mreh> Saizan_ yes
15:52:27 <Saizan_> with right-associated use of (++) you traverse the each list only once
15:52:37 <_andy_> anyone know of anything like Eq a => [(a, b)] -> [(a, [b])]
15:52:44 <Saizan_> and you can't do better than that
15:52:57 <damd> @hoogle [(a, b)] -> [(a, [b])]
15:52:58 <lambdabot> Data.Graph.Inductive.Query.Dominators dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]
15:53:00 <ezyang> _andy_: what would that do?
15:53:10 <ezyang> oh, I see
15:53:15 <mreh> Saizan_ pretty printing would be faster done backwards then
15:53:16 <mreh> :(
15:53:23 <ecooper> _andy_ : you want to collate the bs that correspond to each a?
15:53:25 <cwraith> it'd collapse things with the same a...
15:53:30 <_andy_> yes
15:53:31 <mreh> oh no wait! it's lazy!
15:53:48 <_andy_> mostly just wondering if it already exists and i just missed it
15:53:50 <Saizan_> mreh: no, you're right, this is a problem for producing Strings from chunks
15:53:57 <Saizan_> mreh: that's why Show uses ShowS
15:54:05 <ecooper> _andy_: I came up dry on that once before and wrote it afresh
15:54:10 <_andy_> (also i doubt a version i write will be that quick)
15:54:11 <Saizan_> mreh: or why we have DList, which is a properly packaged version of that
15:54:15 <_andy_> ok
15:54:49 <mreh> Saizan_: is that a list that keeps track of it's length?
15:54:53 <ezyang> _andy_: Do you have any additional constraints on a?
15:55:00 <Saizan_> mreh: no, it's just ([a] -> [a])
15:55:18 <_andy_> there could be more, in this case its Strings
15:55:20 <Saizan_> mreh: so instead of a list xs, you have (xs++)
15:55:27 <_andy_> the assumption is that it is already sorted on a
15:55:36 <_andy_> or will be when i write it
15:55:41 <mreh> Saizan_ clever
15:55:44 <Saizan_> mreh: and use (.) to compose these, and in the end you apply them to [], and the (++) get right associated
15:56:04 <mreh> DList is just the type
15:56:16 <ezyang> Well, then you get Ord.
15:56:23 <ezyang> maybe you want to stick everything into a map instead?
15:56:31 <kmc_> _andy_, sounds like... yeah, what ezyang said
15:56:32 <kmc_> Data.Map
15:56:34 <_andy_> ok
15:56:42 <kmc_> :t M.assocs . M.fromList
15:56:44 <lambdabot> forall k a. (Ord k) => [(k, a)] -> [(k, a)]
15:57:02 <_andy_> :t M.insertWith
15:57:03 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
15:57:39 <_andy_> thanks
15:58:11 <kmc_> :t M.assocs . foldr (\(k,v) m -> M.insertWith (++) k [v] m) M.empty
15:58:12 <lambdabot> forall k t. (Ord k) => [(k, t)] -> [(k, [t])]
15:58:33 <kmc_> i keep thinking there's a better pattern for foldr over M.insert* but can't find it
15:59:20 <Cale> The DList package sort of makes sense for the Monoid instance, but other than that, it's usually not worth the hassle of importing another module, when you can just use plain functions and composition.
15:59:35 <kmc_> :t M.assocs . foldr (uncurry (M.insertWith (++)) . (id &&& return)) M.empty
15:59:36 <lambdabot> forall a (m :: * -> *). (Monoid (m a), Ord a, Monad m) => [a] -> [(a, m a)]
15:59:53 <kmc_> woah fancy (++)
16:00:14 <copumpkin> omg fancy
16:00:26 <kmc_> :t second return
16:00:27 <lambdabot> forall b (m :: * -> *) d. (Monad m) => (d, b) -> (d, m b)
16:00:36 <copumpkin> :t strength . second return
16:00:37 <lambdabot> Not in scope: `strength'
16:00:38 <kmc_> :t M.assocs . foldr (uncurry (M.insertWith (++)) . (second pure)) M.empty
16:00:39 <lambdabot> forall a b (f :: * -> *). (Monoid (f b), Ord a, Applicative f) => [(a, b)] -> [(a, f b)]
16:00:58 <copumpkin> @let strength = uncurry (fmap . (,))
16:00:59 <lambdabot>  Defined.
16:01:03 <kmc_> :t strength
16:01:04 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => (a1, f a) -> f (a1, a)
16:01:27 <copumpkin> :t (strength =<<) . M.assocs . foldr (uncurry (M.insertWith (++)) . (second pure)) M.empty
16:01:29 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
16:02:16 <copumpkin> useful, eh
16:02:35 <mreh> would you implement a pretty Printer as :: State PrintState (DList String)?
16:03:18 <kmc_> what's the state for?
16:03:38 <kmc_> i'd use Text.PrettyPrint.HughesPJ
16:03:50 <ivanm> kmc_: or one of the other ones on hackage
16:03:59 <kmc_> which has a sort of DList like internal rep
16:04:59 <kmc_> ivanm, cool, do you have one you recommend?
16:05:12 <ivanm> kmc_: nah, I just used HughesPJ for my code ;-)
16:05:30 <ivanm> mainly because I had read through tutorials on it and the differences in the others confused me :s
16:05:52 <ivanm> HughesPJ pisses me off in that it doesn't allow infinite lines with indentation :@
16:05:59 <kmc_> heh
16:10:51 <kmc_> :t words <$> readFile
16:10:53 <lambdabot>     Couldn't match expected type `[Char]'
16:10:53 <lambdabot>            against inferred type `IO String'
16:10:53 <lambdabot>       Expected type: FilePath -> String
16:11:16 <kmc_> :t readFile
16:11:17 <lambdabot> FilePath -> IO String
16:11:36 <kmc_> :t (lines <$>) . readFile
16:11:37 <lambdabot> FilePath -> IO [String]
16:16:29 <ecooper> should i expect the Haskell LLVM bindings to link against LLVM when compiling the bindings, or when loading into Haskell?
16:17:26 <Lycurgus> no
16:17:56 <mreh> kmc_ for the indent
16:19:18 <mreh> and other things, it's a hybrid pretty printer, it optimises certain things as it goes
16:20:38 <joe3> :t fnmatch
16:20:40 <lambdabot> Not in scope: `fnmatch'
16:20:47 <joe3> :src fnmatch
16:21:02 <joe3> @src fnmatch
16:21:03 <lambdabot> Source not found. My brain just exploded
16:22:45 <ivanm> joe3: what do you expect this fnmatch to be?
16:23:08 * ivanm guesses joe3 is trying to understand some code he's been given...
16:24:31 <joe3> i am trying to find a filename matching function. Something that can take a pattern and a directory path and return all the files in that dir matching the pattern.
16:24:47 <joe3> :t getDirectoryContents
16:24:48 <lambdabot> Not in scope: `getDirectoryContents'
16:24:55 <joe3> @src getDirectoryContents
16:24:56 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:27:29 <ezyang> What's an easy way to add code to a lhs file in LaTeX without actually having it executed?
16:27:59 <gwern> not include it in the \code sections?
16:28:13 * altmattr fascinated by "Haskellâ€™s overlooked object system"
16:28:27 <ezyang> gwern: It looks funny like that
16:28:37 * gwern shrugs. you want a funny thing
16:28:39 <ezyang> since the \begin{code} makes it formatted like code in LaTeX
16:28:52 <ezyang> gwern: Not that funny, I think :-)
16:29:12 <ezyang> I want to re-define some typeclasses for clarity sake
16:29:13 <altmattr> I use an \ignore command
16:29:28 <altmattr> and wrap it around the code
16:29:30 <benmachine> I think \ignore lets you include code without it being latexed
16:29:35 <altmattr> ha!
16:29:38 <altmattr> thanks
16:29:43 <ezyang> yeah, that's the other way ^^
16:29:48 <benmachine> but, that's not what you want
16:29:55 <altmattr> create a \begin{notcode} environment
16:29:58 <benmachine> the other way around, I guess you just define a
16:29:58 <benmachine> yeah
16:30:06 <altmattr> or maybe \begin{kode}
16:30:08 <benmachine> one which works like code but with a different name
16:30:11 * hackagebot upload: scc 0.4 - Streaming component combinators (MarioBlazevic)
16:30:32 <joe3> don't bother. found system.filepath
16:30:40 <altmattr> \newenvironment{\kode}{\begin{code}}{\end{code}}
16:31:20 <ezyang> cool show
16:31:39 <ezyang> hm, code seems to be a special form
16:32:01 <jfischoff> having trouble getting a instance definition to work generically
16:32:08 <jfischoff> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15715#a15715
16:32:33 <jfischoff> my triangle arbitrary instance compiles but I have trouble using it later
16:33:14 <jfischoff> getting a No instance for (Positionable (JustPostitionVertex CartPoint3) a)
16:34:08 <chrisf> well, it's not the bug, but `JustPostitionVertex` probably wants to be `JustPositionVertex` ?
16:35:06 <jfischoff> chrisf: yes, yes I can't spell
16:39:15 <jfischoff> I can get it to compile if I define an instance for Triangle CartVert, but not for Triangle v.
16:41:49 <tomoj> can anyone explain why this is happening? https://gist.github.com/179ed72f9aca48088754
16:42:23 <tomoj> trying to upgrade haxml from 1.13.3 to 1.20
16:42:42 <copumpkin> tomoj: you need GHC 6.12
16:43:02 <tomoj> oh, I see, thanks
16:43:18 <ezyang> hmm, according to http://yav.purely-functional.net/haskell_latex.html \begin{example} is what I want, but it doesn't work
16:44:02 <joe3> :t globDir1
16:44:03 <lambdabot> Not in scope: `globDir1'
16:44:12 <copumpkin> ezyang: \DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
16:44:26 <copumpkin> with the fancyvrb, that is
16:44:39 <ezyang> snazzy!
16:44:51 <copumpkin> it's in the article :)
16:44:57 <ezyang> yeah, just saw it ;-)
16:45:10 <ezyang> I wonder who defined code for me...
16:45:25 <joe3> i can see from hoogle that System.FilePath.Glob has the function globDir1 .but I am not able to see that function  from ghci or lambdabot.
16:47:32 <Saizan_> joe3: different version, maybe?
16:47:57 <joe3> ok, checking..
16:49:24 <monochrom> Oh fun, package FileManip or package Glob ?
16:49:40 <copumpkin> http://snapplr.com/ssvt
16:50:07 <joe3> monochrom: the name is System.FilePath.Glob
16:50:17 <joe3> it seems to be a part of FileManip package
16:51:10 <joe3> i think I got it. it was not installed as part of the FileManip package. Installing the Glob package seems to be helping..
16:51:47 <monochrom> Both packages have "System.FilePath.Glob" but contents are vastly different.
16:52:51 <ezyang> Hey, if I wrote out a type definition, omitting existentials and dependent types for clarity, would people stab me?
16:53:01 <ezyang> s/wrote out/wrote out for documentation/
16:53:08 <copumpkin> dependent types :o
16:53:09 <joe3> *Main GOA> :m +System.FilePath.Glob
16:53:09 <joe3> Could not find module `System.FilePath.Glob': it was found in multiple packages: Glob-0.5 FileManip-0.3.2
16:53:24 <copumpkin> lol
16:53:26 <joe3> how do I remove a package from cabal
16:53:27 <monochrom> hide FileManip
16:53:31 <joe3> ok, thanks.
16:54:28 <ezyang> copumpkin: You mock me :-)
16:54:35 <joe3> monochrom: there is no hide in ghci.
16:54:41 <copumpkin> ezyang: nope!
16:54:44 <copumpkin> just wondering what you meant
16:54:58 <ezyang> Oh.
16:55:08 <ezyang> For example, one type is "(forall a. p a -> a) -> Prompt p r -> r"
16:55:13 <monochrom> You have to quit ghci, at shell prompt "ghc-pkg hide FileManip", then start new ghci.
16:55:18 <ezyang> I want to drop the forall, since I don't feel like explaining Rank2 types
16:55:24 <joe3> monochrom: thanks.
16:55:31 <copumpkin> ezyang: oh
16:55:32 <ezyang> maybe I'll keep the dependent type
16:55:35 <copumpkin> then it means something else
16:55:46 <ezyang> yeah...
16:55:46 <copumpkin> I still don't know what you mean by dependent
16:55:59 <ezyang> "class Monad m => MonadPrompt p m | m -> p where"
16:56:03 <copumpkin> oh
16:56:06 <copumpkin> functional dependencies
16:56:08 <monochrom> Every documentation has a minimal education requirement on the reader.
16:56:39 <ezyang> copumpkin: Ok.
16:56:44 <monochrom> For example you can't say "can I delete all English sentences so for clarity to Chinese readers"
16:56:58 <copumpkin> ezyang: you can probably omit fundeps but rank 2 types are significantly different
16:57:59 <ezyang> monochrom: Heh. I think this situation is, "can I delete the hard words for clarity to Chinese readers"
16:58:06 <ezyang> copumpkin: Ok. In they go.
16:59:23 <monochrom> You still can't just delete hard words. You replace by longer chains of easier words preserving semantic equivalence.
16:59:44 <ezyang> monochrom: I picked that analogy carefully :-)
16:59:45 <mreh> can someone explain what I've done wrong? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15716#a15716
16:59:48 <ezyang> I'll add supplemental text.
16:59:59 <monochrom> It is not like you replace "You replace by longer chains of easier words preserving semantic equivalence" by "You replace by longer chains of easier words beep beep beep".
17:00:07 <ezyang> eef, template Haskell.
17:00:34 <mreh> i dont know it, I'm only using it to make first class labels
17:01:24 <monochrom> So if you have a new type expression equivalent to your original one but the new one doesn't use rank-2 and is still equivalent to the original rank-2 one, you can do it.
17:02:01 <ezyang> unfortunately, this is an API doc :-)
17:02:22 <Saizan_> mreh: i'd remove those signatures
17:02:48 <mreh> Saizan_ i wanted to test it worked
17:03:00 <mreh> it clearly hasn't
17:03:07 <mreh> the way it's supposed to
17:04:24 <Saizan_> mreh: so if you remove the signatures and load it in ghci, what happens?
17:05:58 <Saizan_> ah, i think the catch is that you've to give the signatures after the splice
17:06:18 <monochrom> an API doc is required to never lie.
17:06:28 * ezyang nods 
17:06:49 <monochrom> A tutorial can lie. An API doc is a contract. If you say "a->b" you mean it.
17:07:37 <cwraith> a tutorial that lies is rather useless
17:08:09 <mle> abstraction is not lying, but related.
17:08:17 <copumpkin> cwraith: not necessarily
17:08:24 <copumpkin> if it's a white lie :)
17:08:31 <monochrom> I surely lied in my tutorial and it was useful. I wrote "(+)::Int->Int->Int". It's a lie. A later section admitted the lie and told the truth.
17:08:34 <ezyang> abstraction is not lying; it's convenient omission :-)
17:09:59 <jfoutz> it's an assignment problem. Int->Int->Int is more specific, that's ok. claiming to be more general is evil.
17:10:12 <theorbtwo> I think I'd write that with a footnote "[1] This is a white lie.  See section ..."
17:10:13 <Veinor> Integer -> Integer -> Integer
17:10:13 <Veinor> :p
17:10:25 <cwraith> Int -> Int -> Int isn't a lie.  That's one type of (+)
17:10:33 <cwraith> It's just not the only one
17:11:04 <cwraith> @instances Num
17:11:05 <lambdabot> Double, Float, Int, Integer
17:11:23 <cwraith> lambdabot seems to think there are four type signatures for (+).  ;)
17:11:25 <tensorpudding> that's not many instances
17:11:40 <theorbtwo> I would have thought a lot more then that.
17:12:01 <tensorpudding> > (0.0 :+ 1.0) + (1.0 :+ 0.0)
17:12:02 <lambdabot>   1.0 :+ 1.0
17:12:05 * ezyang is still kind of far off having a complete TMR artile. And the submission date is tomorrow >.> 
17:12:17 <jfoutz> hehehe
17:12:26 <theorbtwo> :t (:+)
17:12:27 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
17:12:39 <tensorpudding> hmm
17:12:43 <theorbtwo> Aha.
17:12:43 <tensorpudding> > 1 :+ 2
17:12:45 <lambdabot>   1.0 :+ 2.0
17:12:54 <tensorpudding> yeah
17:13:07 <tensorpudding> > (1 :: Int) :+ (2 :: Int)
17:13:09 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
17:13:09 <lambdabot>    arising from a use o...
17:13:39 <tensorpudding> i guess you need to make your own constructor if you want gaussian integers
17:13:43 <monochrom> rank-2 type is easy. It's even natural, intuitive, and all that. It's the natural next step from higher-order functions.
17:14:25 <monochrom> If I can write a function taking (a->a) as parameter, why can't I go further to make it (forall a. a->a)?
17:16:17 <tensorpudding> what is the difference between the two?
17:16:42 <monochrom> I would need the full signature to show what's going on.
17:16:50 <Cale> tensorpudding: in the second case, the parameter is required to be polymorphic
17:17:06 <Cale> (so, in this case, that means it's id or undefined)
17:17:21 <monochrom> My function may be (a->a) -> a  or  (forall a. a->a) -> b
17:17:44 <theorbtwo> Isn't that the same as declaring it (a->a) -> b?
17:18:01 <jfoutz> no, because, (+1) won't work on all a
17:18:17 <tensorpudding> okay
17:18:18 <monochrom> (a->a) ->a /= (a->a)->b.  (forall a. a->a)->a = (forall a. a->a)->b
17:19:15 <theorbtwo> But is (forall a. a->a)->a = (a->a) -> b
17:19:16 <mental> talking about topology to a bunch of hot freshmen
17:19:23 <mental> oops wrong window
17:19:27 <copumpkin> theorbtwo: nope
17:19:40 <theorbtwo> Hmm.
17:19:40 <Veinor> what is the set of characters that can be used for infix operators?
17:19:44 <Veinor> (without backticks)
17:19:52 <copumpkin> Veinor: anything that passes isSymbol
17:19:57 <copumpkin> > isSymbol '+'
17:19:58 <lambdabot>   True
17:20:01 <Veinor> > isSymbol '\''
17:20:03 <lambdabot>   False
17:20:09 <Veinor> so what passes isSymbol then? :p
17:20:12 <monochrom> I'm lousy.  I mean this: (forall a. (forall a. a->a)->a) = (forall b. (forall a. a->a)->b)
17:20:15 <copumpkin> > length (filter isSymbol [toEnum 0..])
17:20:17 <lambdabot>   4310
17:20:22 <copumpkin> Veinor: the unicode standard tells you
17:20:38 <monochrom> And this: (forall a b. (a->a)->a)) /= (forall a b. (a->a)->b)
17:20:57 <tensorpudding> huh
17:21:04 <tensorpudding> > [toEnum 0..]
17:21:06 <lambdabot>   [()]
17:21:10 <Veinor> > filter isSymbol [toEnum 0..255]
17:21:11 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:21:12 <lambdabot>    arising from the literal `2...
17:21:19 <copumpkin> Veinor: why restrict it to 255?
17:21:22 <Veinor> > filter isSymbol [toEnum 0..toEnum 255]
17:21:23 <lambdabot>   "$+<=>^`|~\162\163\164\165\166\167\168\169\172\174\175\176\177\180\182\184\...
17:21:43 <copumpkin> > text (filter isSymbol [toEnum 0..])
17:21:44 <lambdabot>   $+<=>^`|~Â¢Â£Â¤Â¥Â¦Â§Â¨Â©Â¬Â®Â¯Â°Â±Â´Â¶Â¸Ã—Ã·Ë‚ËƒË„Ë…Ë’Ë“Ë”Ë•Ë–Ë—Ë˜Ë™ËšË›Ëœ...
17:21:47 <Veinor> ` is wrong.
17:21:52 <copumpkin> fine
17:21:55 <Veinor> :p
17:22:07 <cwraith> it seems to be missing /
17:22:29 <benmachine> > isSymbol '/'
17:22:30 <lambdabot>   False
17:22:35 <benmachine> eerm.
17:22:44 <theorbtwo> Also, for that matter, - and '.'.
17:22:51 <cwraith> > isAlpha '/'
17:22:51 <Veinor> I think for purposes of this post I can say $+<=>^|~/.
17:22:52 <lambdabot>   False
17:22:57 <tensorpudding> so will rank N types appear in haskell prime?
17:23:16 <copumpkin> tensorpudding: not in 2010
17:23:20 <copumpkin> but maybe 2011
17:23:33 <benmachine> \ can be used in infix operators
17:23:37 <benmachine> it's not ambiguous with lambda
17:23:48 <copumpkin> tensorpudding: it feels a little inconsistent to have rank n types without impredicativity though
17:23:52 <benmachine> eer, as long as you don't use it on its own, I suppose
17:24:00 <copumpkin> Veinor: read the report :P
17:24:10 <Veinor> oh, so that's how printf does its variable argument magic
17:24:22 <copumpkin> Veinor: with a typeclass?
17:24:22 <copumpkin> yep
17:24:46 <Veinor> so...
17:24:51 <monochrom> > Data.Char.generalCategory '/'
17:24:52 <lambdabot>   OtherPunctuation
17:24:55 <CalJohn> based on the logic of inclusion for 2010, i don't think rank n will be in 2011
17:24:57 <copumpkin> I wrote a function of n arguments once
17:25:03 <copumpkin> in haskell
17:25:05 <copumpkin> with a fixed n
17:25:10 <monochrom> > isPunctuation '/'
17:25:12 <lambdabot>   True
17:25:12 <copumpkin> fixed but variable :P
17:25:16 <monochrom> There.
17:25:18 <copumpkin> aha
17:25:47 <cwraith> let (/..\) = const . const $ moth in 5 /..\ 8
17:25:51 <cwraith> > let (/..\) = const . const $ moth in 5 /..\ 8
17:25:52 <lambdabot>   Not in scope: `moth'
17:26:00 <cwraith> > let (/..\) = const . const $ "moth" in 5 /..\ 8
17:26:01 <lambdabot>   "moth"
17:26:53 <BMeph> > isSymbol '*'
17:26:54 <lambdabot>   False
17:27:03 <hatds> really?
17:27:10 <BMeph> > isPunctuation '*'
17:27:12 <lambdabot>   True
17:27:25 <HugoDaniel> i very much dislike bytestrings encoding glitches :(
17:27:28 <HugoDaniel> somebody should fix that
17:27:55 <BMeph> Interesting, that '+'is a symbol, while '/' and '*' are not... :|
17:28:24 <hatds> makes sense from a writer's perspective I guess
17:28:54 <hatds> isSymbol '&'
17:28:56 <hatds> > isSymbol '&'
17:28:57 <lambdabot>   False
17:30:12 <Veinor> I'm going to look up where in the report it defines the autoinfix characters
17:32:59 <Veinor> uniSymbol -> any Unicode symbol
17:33:01 <Veinor> HOW VERY HELPFUL
17:33:13 <Veinor> :I
17:33:43 <jfoutz> > uniSymbol 'a'
17:33:44 <lambdabot>   Not in scope: `uniSymbol'
17:33:55 <Veinor> or does this just mean 'any unicode character'
17:34:10 <Veinor> apparently so.
17:34:21 <Veinor> I can define the Ã© operator, whatever that means.
17:35:07 <c_olin> Is there a naming convention for module hierarchy?  I've noticed that a lot of libraries that have modules of data name the module Data.Module.  However I have not found any information on if there is a standard on this...
17:35:14 <cwraith> > let x Ã© y = 5 in "one" Ã© "two"
17:35:15 <lambdabot>   Not in scope: `Ã©'
17:35:27 <Veinor> ...
17:35:58 <joe3> any thoughts on this runtime error of ghci: http://pastebin.com/m353a0de1
17:36:01 <Veinor> UNICOOOOOODE
17:36:16 <joe3> #
17:36:16 <joe3> GHCi runtime linker: fatal error: I found a duplicate definition for symbol
17:36:16 <joe3> # __hscore_S_IFDIR
17:36:16 <joe3> #
17:36:17 <lunabot>  luna: parse error on input `]'
17:36:17 <lunabot>  luna: parse error on input `|]'
17:36:18 <lunabot>  luna: parse error on input `]'
17:38:48 <joe3> can anyone help with the ghci runtime error. I think it is being caused by the compile in the globdir1 but I am not sure how I can get away without doing that.?
17:39:05 <joe3> please?
17:40:32 <copumpkin> joe3: sounds like two object files provide the symbol
17:41:46 <hatds> c_olin: sorta http://www.haskell.org/haskellwiki/Hierarchical_module_names
17:42:12 <joe3> copumpkin: seems to be complaining about lib/directory-1.0.1.0/ghc-6.10.4/HSdirectory-1.0.1.0.o
17:42:55 <joe3> should I do a recursive strings on the .cabal/lib directory for the  __hscore_S_IFDIR ??
17:43:18 <joe3> I think I know what the problem is:
17:43:24 <joe3> Loading package directory-1.0.0.3 ... linking ... done.
17:43:32 <joe3> Loading package directory-1.0.1.0 ...
17:43:43 <joe3> different versions of the same package, I think..
17:44:14 <joe3> let me try cabal update and see if it helps..
17:45:10 <c_olin> hatds: Thanks
17:45:56 <joe3> is there a cabal command to get all the packages to their latest versions?
17:46:36 <watermind> hey guys
17:47:05 <watermind> slightly OT
17:47:35 <watermind> in a language like haskell we have cartesian closure
17:47:54 <watermind> that is, it's semantics would be some sort of cartesian closed cat
17:48:22 <watermind> *if* we disregard seq
17:48:26 <watermind> but if we have seq
17:48:33 <watermind> or more simply
17:48:43 <watermind> if we're in a call by value language like ML
17:49:17 <watermind> and we don't have the iso AxB->C = A->(B->C)
17:49:21 <watermind> but just an inclusion
17:49:28 <watermind> what do you call such a category?
17:49:34 <jfoutz> Hask
17:49:45 <jlouis> watermind: you mean the category doesn't have exponentials?
17:50:11 <copumpkin> jfoutz: nah, we have that
17:50:19 <copumpkin> a coCCC
17:50:20 <copumpkin> :P
17:50:22 <copumpkin> j/k
17:50:35 <jfoutz> coC++#0
17:50:40 <watermind> jlouis, nope I mean it has exponentials but not the isomorphism   AxB->C = A->(B->C)
17:50:53 <Cale> co-CCC's are not all that interesting.
17:51:45 <watermind> or if you prefer AxB->C = A->C^B
17:52:01 <jlouis> watermind: as hom sets?
17:52:07 <copumpkin> Cale: what's a co-CCC defined as?
17:52:11 <copumpkin> a CCC in the opposite category?
17:52:20 <copumpkin> or rather, that the opposite category is CC
17:52:22 <copumpkin> ?
17:52:25 <watermind> but instead of that iso, something weaker, corresponding to it's "call by value" version
17:52:33 <watermind> jlaire, yes
17:52:34 <jlouis> watermind: I believe that requirement is equivalent to having exponentials
17:53:34 <watermind> jlouis, not sure if I understand... you can have exponentials and no CC no?
17:54:11 <jlouis> right. A CCC is a cat with a terminal object and having all products and all exponentials
17:54:38 <jlouis> the all exponentials parts can also be expressed in terms of Hom-sets
17:54:41 <Cale> copumpkin: It would mean that you have an initial object, coproducts, and a coexponential: for any two objects X and Y, you have an object [Y,X] such that C(Z,[Y,X]) ~= C(Z+Y,X) ~= C(Z,X) x C(Y,X)
17:54:54 <watermind> jlouis, my bad you're right
17:55:06 <watermind> jlouis, the missing part are exponentials
17:55:13 <Cale> But then taking Z to be the initial object...
17:55:28 <watermind> jlouis, so a sort of ccc with a weaker version of exponential
17:56:21 <watermind> jlouis, I guess the question is... is there some categorical version of "call by value exponential"
17:56:43 <watermind> with some property a bit weaker than the usual isomorphism
17:57:34 <Cale> You see that C(0,[Y,X]) ~= C(0,X) x C(Y,X), but C(0,U) always has exactly one arrow in it because 0 is initial
17:58:00 <jlouis> watermind: I am not aware of any such. But mind you, I am not very fluent in CT either
17:58:02 <Cale> Which means that |C(Y,X)| = 1 for any X and Y
17:58:21 <watermind> jlouis, ok thanks
17:58:37 <Cale> So cocartesian-closed categories are indiscrete categories
17:59:25 <jlouis> watermind: of course you can have a category like yours if you can formally describe the weaker requirements on the exponentials. The question is then: Is it equivalent to something else and is it a proper model of your ML-style Lambda calculus
18:00:30 <PVT_Palazzo> DCC SEND "Ð¿Ð¾É¦ÊžÉ”Ð¿ÉŸ" 0 0 0
18:00:31 --- mode: ChanServ set +o mauke_
18:00:31 --- kick: PVT_Palazzo was kicked by mauke_ (mauke_)
18:00:31 --- mode: mauke_ set +b *!*@12.182.142.213
18:00:50 <copumpkin> wow, I'm surprised so many people died because of his attack
18:00:57 <copumpkin> what clients are vulnerable
18:00:59 <copumpkin> ?
18:01:00 <shepheb> bugger.
18:01:22 <mauke_> copumpkin: AFAIK none, it's a router bug
18:01:25 <copumpkin> oh
18:01:30 <copumpkin> lame
18:01:31 --- mode: mauke_ set -o mauke_
18:01:39 <shepheb> go go script kiddies
18:01:55 --- mode: ChanServ set +o mauke_
18:01:56 --- mode: mauke_ set +d b
18:01:56 --- mode: mauke_ set +d e
18:01:58 <mauke_> what
18:02:17 --- mode: mauke_ set -dd b e
18:02:27 <copumpkin> wat
18:02:31 <Cale> jdavis, sm, kromag, Wardub, phnglui, gnuvince, Elwood123, shapr, r2q2, Nshag, Flarelocke, onodrim, Nereid, systemfault, erikc, wto: you have routers which are vulnerable to the DCC SEND bug. You might want to look into it.
18:03:16 --- mode: mauke_ set -o mauke_
18:03:18 <kromag> Thanks
18:03:28 <systemfault> Damn.
18:03:36 <copumpkin> appropriate name at least
18:03:46 <systemfault> Stupid Linksys router.
18:03:54 <joe3> Prelude Main GOA System.FilePath.Glob> :t getdata
18:03:54 <joe3> <interactive>:1:0: Not in scope: `getdata'
18:04:04 <copumpkin> joe3: um, capitalize?
18:04:18 <joe3> the getdata is my function that I had defined in my file. How can I load the file?
18:04:24 --- mode: ChanServ set +o mauke_
18:04:25 --- mode: mauke_ set +d *shitting*
18:04:59 <Cale> mauke_: what's that about?
18:04:59 <copumpkin> joe3: is it exported?
18:05:03 <joe3> I tried ":load filename" but though it seems to load the file, I cannot get this function to use from ghci
18:05:12 <mauke_> Cale: realname ban
18:05:25 --- mode: mauke_ set -o mauke_
18:05:41 <mauke_> PVT_Palazzo had his set to "shittingdicknipples"
18:05:56 <copumpkin> nice
18:06:01 <joe3> copumpkin: my file is not a module. just an haskell script file.
18:06:19 <copumpkin> joe3: all files are modules, possibly with an implicit module Main where
18:07:06 <joe3> yes, when the file loads. it says "Ok, modules loaded: Main."
18:07:20 <joe3> copumpkin: how can I get all the functions in that file to be exported.
18:07:32 <copumpkin> it should be exported automatically
18:08:12 <joe3> it is a top level function too.
18:08:27 <inhortte> Has anyone here used HPDF?
18:08:30 <mauke_> joe3: did you compile the file with ghc?
18:09:26 <joe3> mauke_: there was an error in the file that was not getting reported with ":load". when I did ":r .." the error was thrown.
18:09:34 <joe3> copumpkin: there was an error in the file that was not getting reported with ":load". when I did ":r .." the error was thrown.
18:09:44 <joe3> i am good now.
18:45:27 <pham> is msum the same as the do syntax?
18:45:35 <damd> @src msum
18:45:35 <lambdabot> msum =  foldr mplus mzero
18:45:43 <mauke_> pham: that doesn't make sense
18:45:44 <ezyang> pham: no.
18:46:03 <pham> I mean if you msum a list, is that the same as a do statement with one line for each element in the list
18:46:19 <ezyang> > msum [1,2,3]
18:46:20 <lambdabot>   No instance for (GHC.Num.Num (m a))
18:46:21 <lambdabot>    arising from the literal `1' at <int...
18:46:23 <mauke_> @src mplus
18:46:23 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:46:39 <kpreid> pham: msum is to mplus as sequence is to >>
18:46:48 <mauke_> pham: that sounds like a description of sequence_
18:46:51 <kpreid> do syntax uses >> and >>=
18:47:20 <kpreid> > msum [[1,2],[3,4]]
18:47:21 <lambdabot>   [1,2,3,4]
18:47:35 <kpreid> > do [1,2]; [3,4]
18:47:36 <lambdabot>   [3,4,3,4]
18:47:47 <kpreid> not the same thing
19:01:42 <RockyDd> anybody?
19:02:02 <ezyang> hm?
19:02:30 <RockyDd> sorry, I just try to confirm I am not banned by this channel.
19:02:45 <mauke_> if you were banned, you wouldn't have been able to join
19:03:00 <RockyDd> o, got it, thanks.
19:03:44 <blackh> RockyDd: Well, whatever you didn't do - keep not doing it.
19:04:12 <RockyDd> Sorry for that. :)
19:04:18 <Axman6> why would you be banned RockyDd?
19:04:53 <RockyDd> Because I didn't see anyone say anything. hehe.
19:05:07 <Axman6> you were here less than a minute...
19:05:24 <Axman6> it can go hours on IRC channels before someone talks
19:05:29 <Axman6> o/ blackh
19:05:49 <copumpkin> the expected duration of silent moments goes down with the number of users
19:06:17 <Axman6> yes, but i've seen this channel nquiet for over an hour quite a few times :)
19:08:19 <RockyDd> Oh, you great! In fact, it's my friend live4thee, who is thinking he is banned or something. So I just say a word to make sure he can see me. Sorry again for the disturbing.
19:08:19 <blackh> Axman6: You might be interested to know about something I've been doing...
19:08:26 <Axman6> yeah?
19:08:45 <blackh> Axman6: I've been doing encoding Haskell data structures into binary for passing to C
19:08:52 <Axman6> oh nice :)
19:09:00 <Axman6> have you seen my recent blog posts?
19:10:02 <blackh> Axman6: Yes - I saw them.  I've got a forward reference thing, so you say   ref <- mkRef ; putRefle ref ;    ... then later ...  here ref ; ... some more data
19:10:34 <blackh> Axman6: The idea is that when I get into C land I can zap through the data structure and add a start address, and then I've got a C data structure with pointers pointing to the right places.
19:10:40 <Axman6> hmm, sounds like this could use an explaining blog post :)
19:11:00 <blackh> Axman6: It's really useful and ... as I know you'll appreciate ... really fast!
19:11:11 <Axman6> hoorah :D
19:11:14 * Axman6 loves fast
19:11:58 <tomoj> how do I write f(n)=n*4+floor(n/4)*30 with type Int -> Int?
19:12:13 <tomoj> I'm getting ambiguous type constraint problems with the obvious attempt
19:12:16 <blackh> Initially I had it based on a StateT <something> IO () containing a map of references and what they were doing, but this was slow
19:12:19 <Axman6> using div instead of /
19:12:33 <tomoj> Axman6: ah, thanks
19:12:33 <ezyang> you don't need floor in that case either
19:12:34 <Axman6> floor (n `div` 4)
19:12:40 <Axman6> yeah
19:12:54 <blackh> Axman6: Also, I 'ran' the monad twice - once to work out the forward references and determine the size, and once to write the output data
19:13:12 <tomoj> so why doesn't the obvious attempt work?
19:13:31 <tomoj> I even tried with doing fromIntegral on n before trying to divide it
19:13:34 <ezyang> :t (/)
19:13:35 <blackh> Axman6: The only was I could get it to be blazing fast was to re-write the internals as IO () and use IORefs inside the 'Ref' type.
19:13:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:13:37 <Saizan_> tomoj: (/) requires a Fractional type
19:13:38 <ezyang> :t floor
19:13:40 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:13:43 <Axman6> sounds very interesting blackh, i'd love to see more
19:13:58 <mauke_> :t \n -> n * 4 + floor (fromIntegral n / 4) * 30
19:13:59 <lambdabot> forall b. (Integral b) => b -> b
19:14:01 <tomoj> fromIntegral can't make an Int into a Fractional type?
19:14:02 <blackh> Axman6: Unfortunately it's proprietary - this is the downside of doing Haskell for my day job
19:14:05 <mauke_> tomoj: works fine
19:14:14 <Saizan_> blackh: maybe you could do only once tying the knot?
19:14:15 <Axman6> ah lame, oh well :)
19:14:37 <tomoj> hmm
19:14:59 <Axman6> @check \n -> n * 4 + floor (fromIntegral n / 4) * 30 == n * 4 + (n `div` 4) * 30
19:15:01 <blackh> Axman6: So I changed from doing it twice to doing it once with a guessed buffer size, and then I kill and re-start the monad with a doubled size if it gets full.
19:15:01 <lambdabot>   "OK, passed 500 tests."
19:15:08 <tomoj> on my attempt ( f n = n*4 + (floor (fromIntegral n)/4)*30 ), I get an error about Fractional Int missing
19:15:15 <blackh> Axman6: Anyway, I hope I've given you some ideas
19:15:22 <mauke_> :t let  f n = n*4 + (floor (fromIntegral n)/4)*30  in f
19:15:24 <lambdabot> forall b. (Integral b, Fractional b) => b -> b
19:15:40 <mauke_> tomoj: yes, because you tried to use / on the result of floor
19:15:49 <mauke_> which is an integer again
19:16:00 <blackh> Axman6: People often don't realize that killing something and re-starting with doubling the size is efficient, even though it sounds terribly inefficient.
19:16:03 <tomoj> oh, whoops
19:16:12 <Axman6> tomoj: what you want is: f n = n * 4 + (n `div` 4) * 30
19:16:14 <tomoj> :( thanks
19:16:20 <roostaj> :t String
19:16:20 <roostaj> oops
19:16:21 <lambdabot> Not in scope: data constructor `String'
19:16:28 <Saizan_> Axman6, blackh: there's an assembler that does a very similar thing in TMR 6, iirc
19:16:35 <Axman6> blackh: yeah, seems to work alright for java ArrayLists
19:17:05 <blackh> Saizan_: What's TMR 6?
19:17:33 <Saizan_> The Monad.Reader issue 6
19:17:34 <blackh> One point about using IO () instead of StateT <something> IO () is that the vast majority of the time you're just poking bytes into memory, and the StateT kills the performance
19:17:56 <blackh> Saizan_: I'll take a look - thanks
19:18:44 <Saizan_> blackh: kills the performance by how much?
19:18:52 <blackh> Axman6: I had performance issues with 'binary' package.  It allocated lots of space while it was running, which was a bit of a surprise.
19:19:07 <Saizan_> one might try with a CPS implementation
19:19:36 <Axman6> blackh: that is interesting. tried cereal?
19:21:06 <blackh> Saizan_: About 6x slower
19:21:40 <blackh> Axman6: Does cereal allow you to directly control what the binary form looks like like 'binary' does?
19:22:12 <Axman6> yeah, it's basically binary, but better: parsing binary data is a hell of a lot easier
19:22:24 <Axman6> i believe it's basically binary 2.0
19:23:18 <blackh> Axman6: Great! I'll have a play. The thing about references is that there's a cost in keeping track of the address.
19:23:30 <Axman6> the Put monad is basically exactly the same, and the Get monad allows for failure, so you can have things like: many p = many1 p <|> return []; many1 p = (:) <$> p <*> many p;
19:23:34 <blackh> Axman6: So I can't imagine most people would want that feature, but I need it for some of what I'm doing.
19:25:17 <blackh> Axman6: I should also mention that at the lowest level, my one uses 'poke'
19:25:55 <Axman6> yeah, thar be dragons there. i try to avooid playing with Prt's and peek/poke
19:26:00 <Axman6> -o
19:27:16 <blackh> What I'm planning on doing when this project is finished and I have some time, is to make a plan with Ryan, and package up some bits of the code and put them on hackage.
19:27:58 <Axman6> sounds good
19:38:53 <interferon> i seem to remember a pretty cool musical score editing tool written in haskell.  anyone know what i'm talking about?
19:39:14 <mauke_> no, but my meme matcher combines haskell and score into haskore
19:39:17 <pikhq> Google does.
19:39:48 <interferon> well if google had turned something up, i wouldn't be here
19:42:59 <interferon> mauke_: thanks!  haskore is what i was thinking aboiut
19:47:25 * hackagebot upload: libxml-sax 0.3 - Bindings for the libXML2 SAX interface (JohnMillikin)
19:50:12 <gwern> does anyone know what happens if you call 'eror' in a forkIO?
19:50:23 <Axman6> death
19:50:26 <Axman6> >_>
19:51:06 <blackh> gwern: Where the expression gets evaluated is where it bombs.
19:51:12 <gwern> Axman6: we aren't talking about walking into Mordor :)
19:51:33 <blackh> The very air is a poisonous fume!
19:51:37 <Veinor> System.Configuration.RuntimeConfigurationRecord.RuntimeConfigurationFactory.InitWithRestrictedPermissions(RuntimeConfigurationRecord configRecord, FactoryRecord factoryRecord)
19:51:40 <Veinor> Aaaaaaa
19:51:53 <kmc> gwern, it's an exception like any other?
19:51:55 <Cale> gwern: The thread dies.
19:52:04 <kmc> can be caught
19:52:12 <gwern> Cale: and the original forkIOer?
19:52:19 <Cale> gwern: Doesn't die.
19:52:20 <aavogt> <error> catch me if you can
19:52:28 <kmc> is fine.  but if the original main thread dies, the program dies
19:52:36 <blackh> It bombs where it is _evaluated_ - this could be in another thread if you pass the value through an MVar
19:53:04 <kmc> Veinor, i hope you're joking
19:53:35 <gwern> :t (>>)
19:53:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:53:48 <gwern> @hoogle m a -> m b -> m b
19:53:49 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
19:53:50 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
19:53:50 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
19:53:58 <gwern> @hoogle (<<)
19:53:59 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
19:53:59 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
19:53:59 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
19:54:03 <gwern> bah
19:56:48 <kmc> @remember PeterOtten [re: design patterns] When most of your code does nothing in a pompous way that is a sure sign that you are heading in the wrong direction.
19:56:49 <lambdabot> I will never forget.
19:57:13 <Veinor> kmc: no :(
19:57:18 <kmc> the problem with a factory is that it's like a regular function, except the workers inside might unionize
19:57:25 <kmc> and then your labor expenses go way up
19:57:29 <ezyang> "mumsie!"
19:58:15 * ezyang can't stop cracking jokes about Conor's slides 
19:59:51 <Veinor> ezyang, haaaaalp
20:00:22 <ezyang> Veinor: Pick three random GHC extensions and talk about them
20:00:28 <Veinor> Haha
20:00:39 <kmc> you're giving a talk?
20:00:48 <Veinor> oh, that's a good point, I haven't even mentioned the existence of GHC extensions
20:00:50 <ezyang> s/giving/has been giving/
20:00:57 <kmc> ah cool, on what topic(s)?
20:01:06 * ezyang will let Veinor explain ^^ 
20:01:07 <Veinor> teaching Haskell to imperative programmers.
20:01:29 <ezyang> Veinor: Look at the table of contents for RWH and see if you've missed anything there
20:01:30 <Veinor> also, this will be a very slide-able topic because I don't think it will involve a lot of code per se
20:02:55 <Veinor> should probably talk about the monomorphism restriction
20:02:58 <kmc> how advanced a topic do you want?
20:03:07 <Veinor> not very.
20:03:21 <kmc> if you have already discussed polymorphism, and you want to cover an extension, existential types are a good one
20:03:31 <kmc> show how to create a heterogeneous list or an extensible variant
20:03:40 <Veinor> I haven't really gone over that level yet.
20:04:05 <kmc> parallel evaluation strategies are another good one
20:04:43 <kmc> or maybe rewrite rules
20:05:21 <aavogt> yes, hlist is an excellent example
20:05:32 <aavogt> lovely type functions
20:05:37 <kmc> i think the other extensions are either pure syntax, relaxing unnatural restrictions, arcane type stuff, or miscellaneous advanced stuff like Template Haskell
20:05:45 <kmc> and none would make a good intermediate-level talk
20:06:02 <kmc> TH might blow their minds but it's not really such a core part of Haskell, and it would be bad to give the impression that it's central
20:06:26 <aavogt> kmc: you skipped over multi parameter type classes & fundeps or type families?
20:06:54 <Veinor> I think this might be more suited for ezyang's talk
20:07:07 <ezyang> I'm not talking about that stuff
20:07:17 <Veinor> what exactly is it that you'll be talking about then?
20:07:29 <ezyang> cool examples of type classes
20:07:32 <aavogt> also GADTs might be worth doing instead of Existential types... they sort of overlap with gadts having a bigger scope
20:07:41 <Veinor> ah
20:07:49 <kmc> aavogt, agree about GADTs, especially since the syntax is nicer even for regular ADTs
20:07:58 <kmc> i guess mptc/fundep and type families are not so arcane
20:08:07 <ezyang> although I got shanghai'd into having to explain existentials/multiparams/fundeps for the prompt monad ^^
20:08:19 <kmc> but still pretty advanced as a subject for a detailed talk
20:08:22 <aavogt> -XImplicitParams !!!!
20:08:40 <Veinor> well, consider that I have about two hours, and I only just covered typeclasses yesterday, and not in terribly much detail.
20:09:00 <aavogt> implicit params are very much like type classes
20:09:07 <kmc> i think existentials (whether or not discussed in the context of GADTs) are important
20:09:16 <ezyang> ==
20:09:18 <kmc> and will be directly recognizable by people who know other popular languages
20:09:28 <kmc> but, best wait until they have a good understanding of regular polymorphism
20:09:40 <ezyang> kmc: I, uh, haven't gotten to that point of recognition yet for existentials ^^
20:10:07 <kmc> but you gave a talk on them?
20:10:15 <Cale> Veinor: wow, all those topics in 2 hours?
20:10:32 <mle> when introducing haskell to imperative programmers, a slight covering of datastructures is also a good idea.  Otherwise they invariable reach for hash tables... a quick demo of Data.Map perhaps
20:10:35 <kmc> where are you guys giving these talks?
20:11:06 <Cale> Veinor: Are you just giving an overview of the features and what they might be good for, or actually explaining them to the point that people should be able to go off and use them?
20:11:15 <Veinor> mm, I don't know
20:11:17 <Veinor> Cale: :P
20:11:24 <kmc> i think you can only do the former, plus give examples and exercises
20:11:32 <kmc> people don't learn how to do stuff from a lecture
20:11:37 <kmc> they learn which things they should try to do
20:11:56 <mle> interactive lectures are vastly more difficult to prepare.
20:12:47 <kmc> you should skip the haskell lecture and ambush them with some Coq instead
20:12:58 <Veinor> I think I'll just go over Data.{Map,Set}
20:13:11 <kmc> don't forget to mention IntMap, even if only one slide
20:13:20 <kmc> it took me far too long to realize IntMap existed
20:13:38 <kmc> all you have to say is "if your keys are Int, there is this faster special case structure with the same interface"
20:13:54 <kmc> although... it would be nice if they *actually* had the same (i.e., typeclassed) interface
20:14:00 <kmc> using asstypes
20:14:16 <hatds> assoctypes
20:14:41 <kmc> too long, asstypes it is
20:15:40 <ezyang> eyes desired: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15717#a15717
20:16:27 <ezyang> does that paragraph make sense?
20:16:30 <kmc> yes
20:22:29 <aavogt> ezyang: perhaps also mention that the search order isn't as constrained with Logic, since you have >>- for interleaving results, while >>= doesn't interleave stuff to preserve associativity
20:22:58 <ezyang> that was the intent of the "control when to perform a computation"
20:23:08 <ezyang> maybe that'll become obvious when I actually talk about the operator
20:23:14 <idnar> @type (>>-)
20:23:15 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
20:23:37 <aavogt> as in:   do x <- [1..]; y <- [1..]; return $ x+y  == [2..]
20:23:51 <aavogt> but if it used >>- it would be [2,4..] I think
20:24:23 <aavogt> that would be the diagonal...
20:24:29 <ezyang> it's not quite diagonal
20:24:33 <ezyang> but that's the spirit.
20:24:56 <aavogt> > zipWith (+) [1..] [1..]
20:24:57 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
20:25:06 <aavogt> ezyang: hmm?
20:25:45 <aavogt> > runLogic $ [1..] >>- \x -> [1..] >>- (x+)
20:25:46 <lambdabot>   Couldn't match expected type `Control.Monad.Logic.Logic a'
20:25:47 <lambdabot>         against ...
20:27:15 <aavogt> @hoogle [a] -> Logic a
20:27:16 <lambdabot> Warning: Unknown type Logic
20:27:16 <lambdabot> Prelude head :: [a] -> a
20:27:16 <lambdabot> Prelude last :: [a] -> a
20:29:29 <ezyang> execution is more like: 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 4, 0,
20:31:44 <kmc> @bot
20:31:45 <lunabot>  :o
20:31:45 <lambdabot> :)
20:32:39 <ezyang> [2,3,3,4,4,4,5,5,6,5]
20:32:42 <ezyang> is with >>-
20:33:25 <Cale> > fix (interleave [0..])
20:33:26 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
20:33:48 <aavogt> @oeis 0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5
20:33:49 <lambdabot>  a(2n) = n, a(2n+1) = a(n).
20:33:50 <lambdabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8,...
20:34:13 <Veinor> Cale: haa.
20:34:34 <Cale> > foldr interleave [] (map repeat [0..])
20:34:36 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
20:35:40 <Cale> @oeis 0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4
20:35:41 <lambdabot>  Exponent of highest power of 2 dividing n (the binary carry sequence).
20:35:41 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
20:36:08 <ezyang> whoa, what is oeis
20:36:23 <Cale> Online Encyclopedia of Integer Sequences
20:36:41 <Cale> > describeSequence [0,1,1,2,3,5,8]
20:36:43 <lambdabot>   Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) =...
20:37:04 <Cale> > extendSequence [0,1,1,2,3,5,8]
20:37:06 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:37:35 <Veinor> describeSequence?
20:37:40 <ezyang> now that's trippy.
20:37:42 <Veinor> :t describeSequence
20:37:42 <Cale> (unfortunately it doesn't extend it into an infinite list)
20:37:43 <lambdabot> SequenceData -> Maybe String
20:37:56 <Veinor> what is this :o
20:38:07 <Cale> See the package oeis on Hackage :)
20:38:21 <Cale> also: http://www.research.att.com/~njas/sequences/
20:38:35 <Veinor> so it has an offline copy of oeis?
20:38:38 <Cale> No
20:38:45 <Veinor> ... so it unsafePerformIOs?
20:38:48 <Cale> yes
20:38:54 <Veinor> :<
20:39:16 <Veinor> > length $ extendSequence [0,1,1,2,3,5,8]
20:39:18 <lambdabot>   39
20:39:28 <kmc> hahaha
20:39:36 <kmc> next time people are golfing fib i will bust that out
20:39:44 <kmc> > extendSequence [1,2,4,8,16]
20:39:46 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
20:39:47 <ezyang> hee
20:39:52 <Cale> > extendSequence [0,1]
20:39:54 <Veinor> it's not infinite though!
20:39:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:39:58 <kmc> > extendSequence []
20:39:59 <lambdabot>   []
20:40:02 <kmc> > extendSequence [0]
20:40:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:40:07 <Cale> heh
20:40:08 <kmc> hahaha
20:40:10 <ezyang> ha!
20:40:13 <Veinor> it sure likes fib!
20:40:34 <Cale> > extendSequence [1,2,3,6]
20:40:35 <lambdabot>   [1,2,3,6,2,3,1,3,2,3,1,5,1,2,3,3,2,3,1,5,4,2,1,4,2,2,2,4,1,4,2,3,2,2,2,6,1,...
20:40:39 <Cale> > extendSequence [1,2,3,6,11]
20:40:41 <lambdabot>   [1,2,3,6,11,23,47,106,235,551,1301,3159,7741,19320,48629,123867,317955,8230...
20:40:43 <Veinor> > extendSequence [4]
20:40:45 <lambdabot>   [4,2,4,3,4,2,6,2,4,4,5,2,6,2,6,4,4,2,8,3,4,4,6,2,8,2,6,4,4,4,9,2,4,4,8,2,8,...
20:40:51 <Veinor> > extendSequence [1,2,3]
20:40:53 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
20:40:57 <Veinor> wow, it really likes fib.
20:41:14 <ezyang> > extendSequence [6, 28, 496]
20:41:14 <Veinor> this is perhaps because it uses the lowest-numbered
20:41:15 <lambdabot>   [6,28,496,8128,33550336,8589869056,137438691328,2305843008139952128,2658455...
20:41:23 <Veinor> and fib is A000045
20:41:23 <ezyang> eeee
20:41:35 <Cale> > describeSequence [6, 28, 496]
20:41:37 <lambdabot>   Just "Perfect numbers n: n is equal to the sum of the proper divisors of n."
20:41:39 <Veinor> hah. A000001 is number of groups of order n.
20:42:47 <Cale> > lookupSequenceByID "A000001"
20:42:48 <lambdabot>   Just (OEIS {catalogNums = ["A000001","M0098","N0035"], sequenceData = [1,1,...
20:42:50 <Veinor> > describeSequence [2,6,3]
20:42:51 <lambdabot>   Just "Least positive primitive root of n-th prime."
20:43:00 <Cale> > description $ lookupSequenceByID "A000001"
20:43:00 <idnar> evilSequence
20:43:01 <lambdabot>   Couldn't match expected type `Math.OEIS.OEISSequence'
20:43:01 <lambdabot>         against infer...
20:43:07 <Cale> > fmap description $ lookupSequenceByID "A000001"
20:43:08 <lambdabot>   Just "Number of groups of order n."
20:43:17 <Cale> > fmap sequenceData $ lookupSequenceByID "A000001"
20:43:19 <lambdabot>   Just [1,1,1,2,1,2,1,5,2,2,1,5,1,2,1,14,1,5,1,5,2,2,1,15,2,2,5,4,1,4,1,51,1,...
20:44:13 <Cale> > fmap sequenceData $ lookupSequence "labelled rooted binary trees"
20:44:14 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
20:44:15 <lambdabot>         agains...
20:44:17 <Cale> hmm
20:44:35 <Cale> > fmap sequenceData $ lookupSequenceByID "labelled rooted binary trees"
20:44:37 <lambdabot>   Nothing
20:44:50 <Cale> hmm
20:45:15 <Veinor> I think ByID requires Annnnnn
20:45:45 <Veinor> > fmap sequenceData $ lookupSequenceByID "A036774"
20:45:47 <lambdabot>   Just [0,1,2,9,60,540,6120,83790,1345680,24811920,516650400,11992503600,3070...
20:46:39 <Cale> It appears so
20:46:54 <_andy_> so if anyone from earlier is on:
20:47:30 <_andy_> ok so where is the pastebin site?
20:47:34 <ivanm> @paste
20:47:35 <Cale> @hpaste
20:47:35 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
20:47:36 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
20:47:42 <_andy_> ah, thank you
20:47:48 <Cale> hmm
20:47:49 <ivanm> it still points to morrow's site? :o
20:47:51 <Cale> @where paste
20:47:52 <lambdabot> http://hpaste.org/new
20:47:55 <ivanm> _andy_: also, /topic
20:48:06 <_andy_> ah i see
20:48:07 <Cale> Well, either one is fine :)
20:48:16 <aavogt> isn't hpaste also mmorrow's site?
20:48:22 <Raynes> Why does @hpaste link to moonpatio and not hpaste.org? :\
20:49:02 <ivanm> Raynes: because no-one has updated lambdabot's source
20:49:07 <ivanm> despite mmorrow asking them to
20:49:09 <_andy_> will it post here when a paste is made?
20:49:15 <ivanm> aavogt: its not his _personal_ one
20:49:17 <ivanm> _andy_: no
20:49:22 <_andy_> ok
20:49:22 <ivanm> the hpaste bot is dead
20:49:29 <Cale> I've been asked?
20:49:35 <ivanm> aavogt: he prefers people to use hpaste
20:49:41 <aavogt> you have now
20:49:41 <ivanm> Cale: he made a general plea a few months back
20:49:43 <ivanm> (IIRC)
20:49:45 <aavogt> ok ivanm
20:49:46 <ivanm> aavogt: heh
20:49:46 <ezyang> Hmm, I'm having difficulty understanding why "MonadPrompt p m | m -> p" needs the fundep
20:49:47 <Raynes> I prefer myself to use hpaste.
20:49:49 <Raynes> :D
20:50:00 <ivanm> ezyang: what's the rest of the definition?
20:50:08 <ezyang> prompt :: p a -> m a
20:50:09 <_andy_> well, anyways, if anyone was looking for something like (a -> a -> Bool) -> [(a, b)] -> [(a, [b])]
20:50:10 <_andy_> its there
20:50:33 <Veinor> can't spell fundep without fun!
20:50:40 <aavogt> ezyang: I think of fundeps as being completly optional if you are willing to add type annotations
20:50:44 <kmc> can't spell asstype without ass
20:50:45 <_andy_> or undep
20:50:54 <_andy_> o.. ep
20:50:57 <_andy_> *or
20:51:03 <Cale> ezyang: In practice of how the library works, the fundep doesn't restrict you, and it's true.
20:51:18 <ezyang> Ah, ok.
20:51:49 <Cale> ezyang: Basically it's just saying that m determines p, which is true in the case of how that library is used because p is actually a parameter to something in m
20:52:01 <aavogt> they just reduce the size of the set of possible instances, which makes choosing instances easier
20:52:24 <Cale> (specifically Prompt or PromptT)
20:52:48 <aavogt> I don't entirely see how they are equivalent to type families yet...
20:52:59 <ezyang> hmm, the haskellwiki page is confusing me slightly
20:53:07 <ezyang> "class Mult a b c | a b -> c" -> This tells Haskell that c is uniquely determined from a and b.
20:53:22 <Cale> Well, you could have an associated type  type PromptType m
20:53:53 <ezyang> oh, I see: MonadPrompt p (Prompt p)
20:53:57 <kmc> aavogt, you could replace that one with "class Mult a b where { type Result a b }"
20:54:16 <Cale> and then in the instances, you'd have something like  instance MonadPrompt (Prompt p) where type PromptType = p
20:54:23 <ezyang> ohhh, that's what associated types do!
20:54:50 <kmc> well, those are associated type synonyms
20:55:05 <kmc> associated types are similar except they create new types, with "data" or "newtype"
20:55:11 <Cale> and then  prompt :: MonadPrompt m => PromptType m a -> m a
20:56:12 <ivanm> the only problem with associated types is that they're so verbose :s
21:02:56 <kmc> they don't seem that verbose
21:14:06 * hackagebot upload: system-uuid 1.2.0 - Bindings to system UUID functions. (JasonDusek)
21:16:36 <ezyang> Apparently, scheme's foldl does the wrong argument order
21:16:52 <ivanm> preflex: seen ndm
21:16:53 <preflex>  ndm was last seen on #haskell 243 days, 18 hours, 58 minutes and 12 seconds ago, saying: plus with current compiler technology, it would be slower
21:24:20 <jfhall>  
21:24:35 <rooostaj> preflew: seen god
21:24:41 <rooostaj> preflex: seen god
21:24:41 <preflex>  god was last seen on ##c++ 96 days, 6 hours, 19 minutes and 16 seconds ago, saying: I don't really know either actually
21:24:58 <kmc> hahaha
21:25:01 <rooostaj> :)
21:25:06 <idnar> haha
21:25:34 <rooostaj> preflex: seen lorindon
21:25:35 <preflex>  Sorry, I haven't seen lorindon
21:26:01 <kmc> @remember preflex god was last seen on ##c++ 96 days, 6 hours, 19 minutes and 16 seconds ago, saying: I don't really know either actually
21:26:01 <lambdabot> Done.
21:27:30 <mauke_> preflex: xseen god
21:27:30 <preflex>  god was last seen on freenode/##c++ 96 days, 6 hours, 22 minutes and 4 seconds ago, saying: I don't really know either actually
21:27:36 <mauke_> hrml
21:29:43 <blackh> I thought god was supposed to be omniscient!
21:29:59 <mauke_> C++ has left him stumped
21:30:17 <blackh> That'll do it to ya
21:32:19 <luite> is there a way to have putStrLn (System.IO.UTF8) ignore invalid characters (or filter them out of a string)?  my program exits with this error: commitAndReleaseBuffer: invalid argument (character is not in the code page)
21:32:24 <idnar> what is xseen?
21:32:54 <kmc> luite, invalid characters? every Unicode char has a UTF8 representation
21:32:59 <kmc> do some Char not represent valid Unicode characters?
21:33:32 <mauke_> idnar: cross-network seen
21:33:33 <luite> perhaps, I read text spans from a pdf file, which sometimes contain strange characters
21:33:41 <idnar> mauke_: ah
21:33:50 <mle> luite: sounds like you're utf8 reading things that aren't utf8
21:34:08 <idnar> "character is not in the code page" sounds like it's trying to convert to the current locale or something, but I know absolutely nothing about System.IO.UTF8
21:34:16 <mle> not all bit sequences are utf8
21:35:42 <luite> hmm, it could be the case that it goes wrong earlier in the code, but that I only notice it now because the output is forced by putStrLn
21:47:28 <luite> when I output the same string with the regular putStrLn, it also gives me the same error, but it outputs much more data before it does
21:56:22 <luite> hmm, linux apparently has the "UTF-8//IGNORE" encoding  ( mkTextEncoding "UTF-8//IGNORE" >>= hSetEncoding stout ), to ignore invalid characters
21:56:30 <luite> but that's missing on windows
21:59:07 <luite> setting the encoding to UTF-32BE works, unfortunately my editor doesn't like this file :)
22:03:19 <mauke_> hah, enjoy your \0\0\0
22:04:50 <luite> ah UTF-16 works too, any idea how to set an emacs 23 buffer to UTF-16? :)
22:05:50 <mauke_> C-x C-c vim file.txt RET
22:06:09 <kmc> haha
22:06:41 <mauke_> wait, can't you just use UTF-8?
22:06:55 <ivanm> luite: format-encode-buffer or something?
22:07:07 <ivanm> or encode-coding-region?
22:08:33 <luite> mauke_: utf8 encoding gives the invalid character errors when I putStrLn, utf-16 and utf-32 work fine though
22:08:55 <mauke_> that makes no sense
22:11:02 <luite> mauke_: I'm not sure what's going on, latin1 also results in an error, but on a different character
22:13:13 <luite> C-x <RET> r utf-16-dos <RET>
22:13:16 <luite> :)
22:17:06 <ezyang> Sanity check: Prompt has kind (* -> *) -> * -> *
22:17:41 <copumpkin> PrompT
22:17:42 <copumpkin> :P
22:17:54 <Veinor> Haha
22:19:07 <Veinor> LisT
22:19:58 * ezyang is confused 
22:22:19 <copumpkin> things with type signatures like that are typically monad transformers, and those usually have a big T suffix
22:23:14 <ezyang> but prompt has two type parameters, I think
22:23:21 <ezyang> and one of 'em is * -> *
22:24:14 <Veinor> ListT :: (* -> *) -> * -> *
22:24:39 <ezyang> :t Prompt
22:24:41 <lambdabot> Not in scope: data constructor `Prompt'
22:24:48 <Veinor> :k Prompt
22:24:50 <lambdabot> Not in scope: type constructor or class `Prompt'
22:24:52 <Veinor> :<
22:24:57 <kmc> <:
22:25:00 <Veinor> <:<
22:25:06 <kmc> :t (:<)
22:25:07 <lambdabot> Not in scope: data constructor `:<'
22:25:28 <ezyang> Ooh, I forgot about :k
22:25:29 <ezyang> Prompt :: (* -> *) -> * -> *
22:35:45 <luite> the bytes for the first offending character are 0xC2 0xAD (or 192 173), which seems wrong
22:37:39 <luite> oops, that is 194 173, which is actually a correct UTF-8 character
22:40:05 <luite> a soft hyphen
22:46:34 <mtnviewmark> I have an MTL question
22:46:39 <kmc> cool
22:46:40 <bos> go for it.
22:46:59 <mtnviewmark> I've got something like     type ModeIO a = ReaderT Mode IO a
22:47:16 <mtnviewmark> where Mode is a perhaps badly named type that has all my args and flags
22:47:21 <mtnviewmark> parsed from the command line
22:47:36 <mtnviewmark> I get how I use liftIO to put all IO actions into ModeIO
22:47:38 <mtnviewmark> BUT
22:47:50 <mtnviewmark> how can I use withFile ?
22:47:53 <mtnviewmark> :t withFile
22:47:54 <lambdabot> Not in scope: `withFile'
22:48:13 <mtnviewmark> well    withFile :: String -> ( Handle -> IO  a) -> IO a
22:48:19 <mtnviewmark> liftIO lifts the result
22:48:35 <Cale> I would seriously consider just making Mode a parameter to the functions you're writing. It's a good deal simpler than introducing a monad transformer formally.
22:48:35 <mtnviewmark> but I need to use it with a function that now has the type     Handle -> ModeIO a
22:48:57 <jmcarthur> mtnviewmark: use runReaderT in the second parameter of withFile
22:49:05 <Cale> @unmtl ReaderT Mode IO a
22:49:05 <lambdabot> Mode -> IO a
22:49:07 <jmcarthur> with the mode from the reader
22:49:08 <mtnviewmark> Indeed, Cale, that is what I had --- I was doing this as an excuse to explore monad transformers
22:49:13 <Cale> ah, okay
22:49:21 <bos> yep, you have to use ask to get the data, then rewrap it internally.
22:49:34 <mtnviewmark> ah - got it
22:49:43 <mtnviewmark> makes sense, and a little bit gnarly
22:49:54 <jmcarthur> mtnviewmark: there is surely a way to abstract the idea
22:49:56 <bos> or you could write a withFile of your own that uses MonadIO
22:50:10 <bos> or write a liftInto
22:50:22 <mtnviewmark> so now the question is --- is that plus all the liftIO litering my code better or worse than the version with all the explicit passing of the mode value
22:50:28 <jmcarthur> bos: i don't think that is a simple thing to do
22:50:28 <mtnviewmark> hmmm.... will have to ponder that
22:50:42 <bos> jmcarthur: which?
22:50:54 <jmcarthur> bos: withFile using MonadIO
22:50:55 <hatds> I'm never really a fan of hiding parameters with monads
22:51:12 <ezyang> "that's the point of the reader monad"
22:51:16 <jmcarthur> bos: well, not in terms of the existing withFile, anyway. i didn't think about using more primitive actions instead
22:51:21 <hatds> although it does have its uses once in a while
22:51:32 <mtnviewmark> I see how to write a version of withFile,,, or even a version of lift that could do it for all things that take a    a -> IO a
22:51:41 <Cale> Reader and ReaderT are a bit silly except as part of something more complicated
22:51:41 <mtnviewmark> BUT - I only have one such call
22:52:07 <mtnviewmark> well - passing the args value around everywhere is cumbersome too
22:52:27 <jmcarthur> mtnviewmark: point free is nice :)
22:52:31 <ivanm> what am I doing wrong here?
22:52:31 <ivanm> @pl \ gd -> f gd \\ (fromList (wantedRootNodes gd))
22:52:32 <lambdabot> (line 1, column 14):
22:52:32 <lambdabot> unexpected "\\"
22:52:32 <lambdabot> expecting variable, "(", operator or end of input
22:52:42 <ivanm> oh, duh
22:52:44 <Cale> mtnviewmark: It's usually less bad than you'd think.
22:52:44 <bos> jmcarthur: probably
22:52:52 <mm_freak> i want to apply a function f n times to a valueâ€¦  my current approach is this:  iterate f x0 `genericIndex` n
22:52:52 <ivanm> I was getting a different error before, didn't see the "\\" bit :s
22:53:01 <mtnviewmark> jmcarthur --- only everything needs to end in IO a.... so mode can't be the common last param....
22:53:18 <jmcarthur> mtnviewmark: why not?
22:53:20 <mm_freak> i thought that list fusion would eliminate the list completely and make it the same as applying f directly in a recursive fashion
22:53:37 <mm_freak> my benchmark shows that the list approach is considerably slower
22:53:39 <mm_freak> why is that?
22:53:44 <mtnviewmark> will have to ponder that, jmcarthur....
22:53:49 <Cale> mm_freak: Check if it's actually happening
22:53:59 <Cale> (I'm not sure that it would)
22:54:00 <mtnviewmark> seems like too much monad machinery needs the monad result last, yes?
22:54:05 <mtnviewmark> er
22:54:06 <mm_freak> Cale: how can i do that?
22:54:15 <jmcarthur> mtnviewmark: also, "everything needs to end in IO" is a sign that you could stand to decompose your program a bit, maybe
22:54:28 <mtnviewmark> er I mean the feed forward value from the  prior monad as the last arg
22:54:37 <jmcarthur> mtnviewmark: the monad result is a result, not an argument
22:54:55 <mtnviewmark> oh - we're only talking about 6 functions in one file -- frankly --- the vast majority of it is all pure
22:55:03 <Cale> Look at the core and/or see if there are rules which apply to iterate and check that they fired. ghc-core is a useful tool for collecting all the info on the intermediate passes GHC does
22:55:07 <jmcarthur> mtnviewmark: could you give an example that you think would be problematic? i'm not understanding
22:55:52 <mtnviewmark> hmmm... I'm looking at my code prior to trying ReaderT here.....
22:56:01 <mm_freak> Cale: never worked with that; could you give me a pointer?
22:56:12 <Cale> mm_freak: You use it just like you would ghc
22:56:23 <mtnviewmark> actually - bizarelly, I *DID* use pointfree style to not have to expressly pass the Mode value around in a few places !  Look at that!
22:56:31 <mm_freak> oh, i see
22:56:32 <mm_freak> thanks
22:56:35 <mtnviewmark> of course, still shows up in the type
22:56:46 <Cale> mm_freak: and it shows and colourises for you a bunch of info emitted by GHC in the intermediate steps
22:57:01 <Cale> mm_freak: It can be a bit hard to interpret
22:57:16 <jmcarthur> mtnviewmark: type ModeIO a = Mode -> IO a
22:57:20 <jmcarthur> :)
22:57:20 <mm_freak> i'll try it out
22:57:34 <jmcarthur> (i'm not actually recommending that)
22:57:38 <Cale> mtnviewmark: Heh, you could also just use the function monad, but that's a little odd :)
22:57:56 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
22:57:57 <lambdabot>   ("hello","olleh","HELLO")
22:58:00 <mtnviewmark> right, but when you've got something that needs to take some other input:     fooAct :: IO a     barAct :: a -> IO b
22:58:08 <mtnviewmark> and want to chain them     fooAct >>= barAct
22:58:15 <mtnviewmark> inserting Mode into that point free?
22:58:38 <jmcarthur> mtnviewmark: where both fooAct and barAct need the Mode parameter?
22:58:42 <mtnviewmark> right
22:58:57 <jmcarthur> @pl \m -> fooAct m >>= barAct m
22:58:57 <lambdabot> liftM2 (>>=) fooAct barAct
22:59:06 <Cale> damn, I was typing that :)
22:59:13 <jmcarthur> not the most beautiful thing in the world, but hey
22:59:38 <jmcarthur> beats liftIO, ask, and runReaderT everywhere
22:59:41 <Cale> Is passing it by hand really so painful?
22:59:46 <mtnviewmark> no, that is a bit of a brain twister
22:59:57 <mtnviewmark> no, Cale, it isn't
22:59:57 <Cale> mtnviewmark: look at my other example
23:00:00 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
23:00:01 <lambdabot>   ("hello","olleh","HELLO")
23:00:06 <mtnviewmark> but I didn't konw that until I tried to user ReaderT
23:00:20 <mtnviewmark> since, it *seems* like that should be easy
23:00:21 <Cale> :t liftM2
23:00:22 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:00:34 <jmcarthur> Reader and ReaderT can be nice, but are often just a pain
23:00:36 <Cale> In the (e ->) monad, this specialises to:
23:00:53 <Cale> (a1 -> a2 -> r) -> (e -> a1) -> (e -> a2) -> (e -> r)
23:01:56 <Cale> That is, it takes a function of two parameters a1 and a2 producing a result r, and it turns it into a function of two functions (e -> a1) and (e -> a2) producing a result (e -> r)
23:02:11 <ksf> http://www.fossfactory.org/
23:02:19 * ksf wonders why there's not a single haskell project there
23:03:00 <Cale> ksf: There are only a couple dozen projects at all
23:03:12 <Cale> (at least, as far as I can see)
23:03:15 <mtnviewmark> hmmm.... seems (e ->) monad might be useful for all sorts of things
23:03:44 <ksf> uh yes. that's not a valid reason not to use it, though.
23:03:48 <c_wraith> mtnviewmark: mostly for obfuscating code. :)
23:03:52 <Cale> > sequence [id, reverse, map toUpper] "hello"
23:03:54 <lambdabot>   ["hello","olleh","HELLO"]
23:04:02 <Cale> Aw, it's not that bad
23:04:18 <Cale> > map (ap (,) (^2)) [1..10]
23:04:19 <lambdabot>   [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
23:04:21 <ksf> > [id, reverse, map toUpper] <*> "hello"
23:04:21 <jmcarthur> i think i'm the only one who doesn't think the (e ->) monad is so confusing
23:04:22 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
23:04:22 <lambdabot>         against inferred ty...
23:04:35 <ksf> > [id, reverse, map toUpper] <*> pure "hello"
23:04:36 <lambdabot>   ["hello","olleh","HELLO"]
23:04:38 <Cale> jmcarthur: you're with me then
23:04:39 <jmcarthur> apparently Cale is with me
23:04:43 <jmcarthur> heh
23:04:53 <hatds> (e ->) often sees use for me when I have a small one line definition
23:05:09 <Cale> > join (++) "echo"
23:05:11 <lambdabot>   "echoecho"
23:05:32 <hatds> well maybe only a couple times now that I think about it :)
23:05:45 <jmcarthur> for whatever reason i end up using (<=<) a lot with the (e ->) monad
23:06:10 <ksf> > join ["con", "cat"]
23:06:11 <lambdabot>   "concat"
23:07:04 * bos wonders why on earth atomicModifyIORef would be blocking
23:07:26 <ksf> ...in fact, using join instead of concat might be a refreshingly evil way to sneak monads into someone's brain.
23:07:38 <jmcarthur> the name makes sense
23:07:44 <jmcarthur> in a ruby way
23:08:35 <jmcarthur> join takes a list of lists and makes a list. it just so happens that it's also vastly generalized
23:10:04 <pham> If I want to re-export all the bindings from an imported module, and export all the definitions in the current module, what's the syntax for that?
23:10:24 <pham> the only way I know how to export all definitions in current module is to have no export list
23:10:35 <ksf> that's correct.
23:10:54 <ksf> the other possibility is to use two modules, one of those only exporting other modules
23:10:57 <ksf> it's a common thing.
23:11:01 <aavogt> module Foo (module Foo.Bar) where import Foo.Bar
23:11:01 <Axman6> i think you can export modules too
23:11:30 <pham> ksf: are you saying I have to either create another module or list every definition?
23:11:35 <ksf> yep
23:11:41 <pham> ksf: bummer
23:11:57 <aavogt> I wrote the syntax for exporting all the definitions imported by a given module
23:12:18 <ksf> listing everything is good practice for released stuff, though.
23:12:34 <ksf> it's also where you specify the order haddock will list the functions
23:12:47 <mtnviewmark> :t join
23:12:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:12:52 <mtnviewmark> :t join (++)
23:12:54 <lambdabot> forall a. (Monoid a) => a -> a
23:13:01 <aavogt> depends, maybe it's more helpful to indicate that those functions _all_ come from a single other module
23:13:06 <ksf> :t (++)
23:13:06 <lambdabot> forall m. (Monoid m) => m -> m -> m
23:13:13 <ksf> that's caleskell, though.
23:13:31 <mtnviewmark> yes, that surprised me --- is that really that way in the Prelude?
23:13:32 <ksf> > toUpper . "awesome"
23:13:33 <lambdabot>   "AWESOME"
23:13:57 <ksf> the prelude one is [a] -> [a] -> [a]
23:14:05 <ksf> :t mconcat
23:14:06 <lambdabot> forall a. (Monoid a) => [a] -> a
23:14:12 <ksf> uh.
23:14:13 <mtnviewmark> that's what I thought
23:14:14 <ksf> :t mappend
23:14:15 <lambdabot> forall a. (Monoid a) => a -> a -> a
23:14:37 <mtnviewmark> lambdabot has some funny bindings?
23:14:47 <ksf> yep
23:14:52 <ksf> all praise goes to cale
23:15:15 <mtnviewmark> doesn't that make things a bit more, er, confusing, for small brained folks like myself?
23:15:34 <ksf> possibly.
23:15:49 <ksf> but then, to not confuse people return should've been called pure
23:16:01 <mtnviewmark> :src join
23:16:16 <mtnviewmark> @src join
23:16:16 <ksf> @src join
23:16:17 <lambdabot> join x =  x >>= id
23:16:17 <lambdabot> join x =  x >>= id
23:16:54 <mtnviewmark> is there a way to ask for src for a particular instance?
23:17:04 <aavogt> @src [] join
23:17:05 <lambdabot> Source not found. I am sorry.
23:17:06 <ksf> @src [] (>>=)
23:17:06 <lambdabot> xs >>= f     = concatMap f xs
23:17:10 <c_wraith> yes, but join doesn't have instance-specific code
23:17:23 <mtnviewmark> @src (e->) (>>=)
23:17:24 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:17:38 <aavogt> it could, since @src is just some manually compiled database, no?
23:17:40 <copumpkin> @src (->) (>>=)
23:17:41 <lambdabot> f >>= k = \ r -> k (f r) r
23:18:12 <c_wraith> that's a bit of a lie.  (->) has the wrong kind to be a monad
23:18:53 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15719#a15719 euler 27, but i dont get correct answer i get 1 and 41 as a and b, and that is a formula that produces 40 primes, i need more but it just cant find it and i cant figure out why
23:18:58 <mtnviewmark> ah, so "intuitively", a sequence of actions in the (->) monad, is a function that passes its one argument to all of them in sequence (possibly chained)
23:19:22 <aavogt> (->) is not a Monad
23:19:36 <aavogt> mtnviewmark: do you know Reader?
23:19:49 <mtnviewmark> which means,   f >> g    is pointless in the (e->) Monad
23:20:05 <mtnviewmark> or rathe the f  is pointless, as it is never needed
23:20:11 <aavogt> f >> g   is useless
23:20:14 <aavogt> yes
23:20:32 <mtnviewmark> aavogt - yes, I'm aware that the (e->) is given as a "simple" Reader monad
23:20:48 <mtnviewmark> and now, I'm begining to understand why
23:21:19 <mtnviewmark> though we were exploring (or rather I was being shown) fasticatical feats one can do with (e->) as a monad
23:21:22 <mtnviewmark> like
23:21:41 <mtnviewmark>  > join (++) "moo"
23:21:48 <mtnviewmark> which now I understand
23:22:30 <nolrai_FG> > join (++) "moo"
23:22:31 <lambdabot>   "moomoo"
23:22:35 * mtnviewmark realizes he shouldn't say "pointless" to mean "without a use" in this channel!
23:22:53 <mtnviewmark> join (*) 42
23:22:59 <c_wraith> wait.  you mean pointless style isn't useless? :)
23:23:03 <mtnviewmark> > join (*) 42
23:23:04 <lambdabot>   1764
23:23:18 <bos> mtnviewmark: has your brain formed a cusp yet?
23:23:26 * Axman6 always hated this:
23:23:31 <Axman6> @pl \x -> x * x
23:23:32 <lambdabot> join (*)
23:23:32 <mtnviewmark> wait......
23:23:48 <mtnviewmark> > (join (.) rev) "foo"
23:23:49 <lambdabot>   Not in scope: `rev'
23:24:00 <mtnviewmark> > (join (.) reverse) "foo"
23:24:01 <lambdabot>   "foo"
23:24:06 <mtnviewmark> it's id!
23:24:15 <Axman6> you invented id :O
23:24:23 <fabjan> @src id
23:24:24 <lambdabot> id x = x
23:24:32 <Jafet> id isn't [a] -> [a] though
23:24:50 <mtnviewmark> > id "looks like it to me"
23:24:52 <lambdabot>   "looks like it to me"
23:24:57 <c_wraith> it's a specialization of id.
23:25:10 <aavogt> @pl reverse . reverse
23:25:11 <lambdabot> reverse . reverse
23:25:31 <c_wraith> @pl \x -> reverse (reverse x)
23:25:32 <lambdabot> reverse . reverse
23:25:32 <aavogt> @pl reverse . reverse $ "haha"
23:25:33 <lambdabot> reverse (reverse "haha")
23:26:23 <Jafet> @check reverse.reverse == id
23:26:24 <lambdabot>   No instance for (GHC.Classes.Eq ([a] -> [a]))
23:26:25 <lambdabot>    arising from a use of `GHC...
23:26:48 <c_wraith> @check \x -> (reverse . reverse) x == x
23:26:50 <lambdabot>   "OK, passed 500 tests."
23:27:25 <Jafet> I like how lambdabot encloses it in quotes.
23:27:48 <medfly> "it's what Haskell said!"
23:27:56 <mtnviewmark> but yes, you were all right --- the ReaderT version of my code is far uglier than the "just pass around the dang value" version
23:28:34 <c_wraith> I feel like Reader is really only useful as part of an application monad stack.
23:29:04 <nolrai_FG> You can also use implicit paramaters I think they are called.
23:29:19 <c_wraith> If you're already using other monad computations, and you want access to some global state, you can just throw in a ReaderT
23:29:33 <ksf> @check \x -> (reverse . reverse . cycle) x == cycle x
23:29:34 <lambdabot>   "* Exception: Prelude.cycle: empty list
23:29:38 <mtnviewmark> I don't have quite enough experience yet -- but from this exercise, if just using ReaderT was this fugly, I can't see how stacking up monads doesn't result in code full of lifts and juggling
23:29:41 <ksf> gnargh.
23:29:57 <Jafet> @check \x -> x == [] || (reverse . reverse . cycle) x == cycle x
23:30:02 <lambdabot>   mueval-core: Time limit exceeded
23:30:03 <ksf> mtnviewmark, MonadTrans
23:30:04 <c_wraith> mtnviewmark: usually by writing a set of helper functions that do the appropriate lifting for you
23:30:04 <bos> mtnviewmark: it can.
23:30:18 <ezyang> mtnviewmark: The key is to see that MonadReader is a typeclass
23:30:21 <ksf> unless you have multiple readers or such, things get lifted automagically
23:30:26 <nolrai_FG> mtnviewmark: also classes that do the lifting for you.
23:30:28 <bos> mtnviewmark: basically, if you have a big teetering stack of monads, you may well be doing things wrong.
23:30:30 <rooostaj> @src getLine
23:30:31 <lambdabot> getLine = hGetLine stdin
23:31:29 <mtnviewmark> how does anything get auto-lifted?   I had to explicitly lift all my IO actions into my ReaderT class....
23:31:41 <bos> you have to lift IO actions, yes.
23:31:59 <mtnviewmark> oh - well.... not that that one is used that much.... :-)
23:32:01 <bos> but if you have a stack of transformers, there's a pile of instances that will lift between transformers for you.
23:32:13 <bos> so usually all you need to do is use liftIO.
23:32:32 <bos> however, don't look too closely at how the auto-lifting is achieved. it will make you sad.
23:32:33 <mtnviewmark> and if you carefully put that all in one tidy place, perhaps you get away with on a few of those, I suppose
23:32:34 <roostaj> @src print
23:32:35 <lambdabot> print x = putStrLn (show x)
23:32:36 <bos> it makes me sad.
23:32:53 <mtnviewmark> recourse to Data.Dynamic?
23:32:55 <roostaj> @src hPrint
23:32:55 <lambdabot> Source not found. My pet ferret can type better than you!
23:33:05 <bos> no, just N^2 instances.
23:33:06 <ksf> or you could do Writer [IO ()]
23:33:18 <ksf> ...not that I've ever tried that.
23:33:48 <copumpkin> DList!
23:34:17 <ksf> Seq?
23:34:39 <roostaj> @src putStrLn
23:34:39 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
23:34:45 <roostaj> @src putStr
23:34:46 <lambdabot> putStr s  = hPutStr stdout s
23:34:49 <ksf> or is Dlist just a reversed []?
23:34:52 <roostaj> @src hPutStr
23:34:52 <lambdabot> Source not found. Do you think like you type?
23:34:58 <copumpkin> ksf: it's a function
23:35:01 <c_wraith> DList is...  [] -> []
23:35:11 <nolrai_FG> but its capital?
23:35:48 <mtnviewmark> bos - by the way, the UUID 1.2 speed up, made the LLSD benchmarks speed up 20%
23:36:20 <ksf> Is there any reason I should prefer it over Seq?
23:36:26 <bos> mtnviewmark: nice!
23:36:47 <mtnviewmark> now, the other speed bump is Date formatting
23:36:53 <mtnviewmark> but, I'm not going there
23:37:00 <c_wraith> ksf: DList is faster for the pattern where you compose a large list, then traverse it once.  that is, as the Monoid for a Writer monad
23:37:15 <fabjan> @src (.)
23:37:15 <lambdabot> (f . g) x = f (g x)
23:37:45 <ksf> so, in the case where I'm unsure what I'm doing with it (which is the case 99% of the time), I should choose seq
23:37:50 <fabjan> @pl (f . g) x = f (g x)
23:37:50 <lambdabot> (line 1, column 11):
23:37:50 <lambdabot> unexpected "="
23:37:50 <lambdabot> expecting variable, "(", operator or end of input
23:38:01 <fabjan> @pl let (f . g) x = f (g x)
23:38:01 <lambdabot> (line 1, column 5):
23:38:02 <lambdabot> unexpected "("
23:38:02 <lambdabot> expecting "()", natural, identifier or "in"
23:38:04 <fabjan> meh
23:38:21 <ksf> which reminds me, we need a common typeclass for sequences.
23:38:47 <ksf> oh, and implicit view patterns, so we can re-use pattern matching on lists.
23:38:49 <hatds> what interface?
23:39:14 <c_wraith> there are a bunch of interfaces that are part of list.  like Foldable and Traverseable
23:39:32 <ksf> hatds, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10699#a10699
23:43:24 <c_wraith> ksf:  I'm not sure I'd use DList except with a Writer monad, but it's *reallY* handy there.
