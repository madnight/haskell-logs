00:00:19 <ivanm> any monad
00:00:28 <ivanm> oh, you mean the zip scanl line?
00:00:39 <ivanm> @type ap zip (scanl1 (+))
00:00:40 <lambdabot> forall b. (Num b) => [b] -> [(b, b)]
00:00:43 <ivanm> the list monad!
00:01:50 <mreh> not clever enough to understand that
00:02:23 <mreh> :t zip
00:02:24 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
00:02:38 <mreh> that would suggest the type of zip is [a->b]
00:02:44 <mreh> but it isn't
00:06:11 <bnijk_> have you guys heard about "swym"
00:06:22 <bnijk_> http://www.chalicegames.com/swym/SwymWebIntro.html <--
00:06:26 <bnijk_> i think it's cool
00:07:18 <mreh> is this spam?
00:09:01 <mreh> my apologies
00:11:19 <bnijk_> nope
00:11:29 <bnijk_> i saw it posted on reddit, i think it came out today
00:11:39 <Jonno_FTW> i saw swym just now
00:11:47 <Jonno_FTW> it looked pretty good
00:11:58 <Jonno_FTW> especially an interpreter written in js
00:12:04 <bnijk_> yeah that part is cool too ;)
00:12:10 <bnijk_> it fits into my theory
00:12:18 <bnijk_> that programming languages are evolving to resemble natural language
00:13:45 <Jonno_FTW> so one day
00:14:03 <Jonno_FTW> all i will need to say, is "Hello World" and the computer will know what i mean?
00:14:09 <bnijk_> no
00:14:11 <bnijk_> you'll have to say
00:14:17 <bnijk_> "say 'hello world'"
00:14:18 <kmc> natural language is terrible for describing instructions precisely
00:14:36 <kmc> i think it's naive to believe that programming languages will approach natural language
00:14:55 <bnijk_> you're entitled to your opinion
00:15:13 <Jonno_FTW> i agree, especially in english
00:15:28 <bnijk_> i think it's naive to believe that people's willingness to learn programming languages is stronger than the willingness of compiler writers to conform to their needs
00:15:32 <Jonno_FTW> natural languages are prone to ambiguity
00:15:45 <bnijk_> it is fully possible to write a specification for a program in english
00:15:49 <bnijk_> without ambiguity
00:16:21 <patc__> natural language comprehension engines are prone to poor performance
00:16:22 <ivanm> yes, but how useful will that language be? ;-)
00:16:33 <bnijk_> as useful as any turing-complete language
00:17:04 <bnijk_> patc: so it will compile slowly...so long as it optimizes well, who cares?
00:17:05 <Cale> Programming languages are already *way* more concise than English, as far as completely and precisely specifying things goes.
00:17:17 <kmc> yup
00:17:28 <Twey> They're terrible for saying ‘I had toast for breakfast last Tuesday’, though ;)
00:17:29 <bnijk_> Cale: that depends on where you draw the "english" line at
00:17:34 <patc__> Mind you it will be very easy to write a compiler.  "Mr Computer, take whatever the user tells you as input, copile that into a very fast machine representation, and them perform those instructions please"
00:18:21 <Twey> patc__: ERROR: Verb ‘copile’ not in scope.
00:18:39 <bnijk_> i may be oversimplifying - the evolution of programming languages is the equilibrium of basal user familiariaty and conciseness
00:18:40 <Twey> patc__: ERROR: Syntax error on ‘them’, expected conjunctive phrase.
00:19:24 <bnijk_> as a function of compiler complexity over net abstracted function :O
00:19:41 <patc__> "Mr Computer, also correct any trivial grammar and spelling mistakes in your input please" :)
00:20:12 <bnijk_> i will put 20 bucks down, 2 to 1 odds, that the first english compiler gets named "hal" by a smartass programmer
00:20:17 <bnijk_> any takers?
00:20:23 <Jonno_FTW> patc__: ERROR, define grammar
00:21:55 <bnijk_> oo wait...either "hal" or "colossus"
00:22:24 <medfly> bnijk_: "or something like that, OK computer?"
00:22:53 <bnijk_> then the computer gets frustrated and starts leaving passive aggressive notes in your ~/
00:23:08 <medfly> heh
00:23:10 <bnijk_> "TAKE OUT THE GARBAGE!"
00:23:37 <bnijk_> "DO YOU EVEN THINK ABOUT WHETHER OR NOT I NEED MORE SWAP SPACE"
00:23:52 <Twey> Hahaha
00:23:59 <bnijk_> favors for favors, fond but not in love, etc
00:24:56 <Jonno_FTW> won't by then, garbage collection be automated?
00:25:21 <Jonno_FTW> robot vacuum cleaners are controlled by your computer
00:25:46 <bnijk_> what was the movie where the robot house is played by the woman from "married with children"
00:25:51 <Jonno_FTW> the computer then formulates opinions about you determined by waste
00:26:26 <mreh> @pl (\f g x -> f x `g` f x)
00:26:27 <lambdabot> flip =<< (ap .) . flip (.)
00:26:50 <mreh> god that's ugly
00:27:27 <mreh> @pl (\f g x -> g (f x) (f x))
00:27:27 <lambdabot> flip =<< (ap .) . flip (.)
00:27:30 <dibblego> @type \f g -> liftA2 g f f
00:27:31 <lambdabot> forall a c (f :: * -> *). (Applicative f) => f a -> (a -> a -> c) -> f c
00:27:45 <Twey> flip =<< ap fmap . flip fmap
00:27:46 <Twey> ;)
00:27:47 <mreh> i hate using things I dont understand
00:27:55 <Twey> So understand it
00:27:58 <Jonno_FTW> i agree ^^
00:28:13 <Twey> Err
00:28:13 <mreh> but I dont want to
00:28:15 <bnijk_> you must have an unsatisfying sex life mreh ;)
00:28:20 <Twey> s/ap fmap/fmap ap/
00:28:27 <Twey> Ha!
00:28:31 <kmc> ehehehehe
00:28:42 <mreh> :(
00:28:48 * bnijk_ pats mreh, there there
00:29:18 <mreh> 8=====>
00:29:25 <kmc> ehehehehe
00:29:48 <bnijk_> oh man...i invented that gag mreh ;)
00:29:48 * kmc drvnk
00:29:58 <Jonno_FTW> 8 == == == > does not make sense
00:30:09 <mreh> it's a new haskell operator
00:30:13 <bnijk_> lol
00:30:21 <kmc> Theorem 8 == == == >.  Proof. tauto. Qed.
00:30:31 <Jonno_FTW> and how is 8 equal to "equal to" and also equal to more than?
00:30:49 <mreh> can we define 8==> to be a new operator?
00:30:55 <kmc> not in Haskell
00:30:57 <kmc> :/
00:31:01 <bnijk_> 8 == == == == > - - - - - - - - map (sin) [1..39]
00:31:18 <kmc> coqslap
00:31:39 <ivanm> if I want to use Reader on top of State, is there any reason why I shouldn't use RWS rather than applying ReaderT on top of State ?
00:31:43 <bnijk_> well, in less than 10 minutes i got #haskell talking about cocks
00:31:46 <bnijk_> my work is done here
00:31:53 <kmc> :D~~~~
00:32:05 <sshc> @let x (======>) = "8================================D"
00:32:06 <lambdabot>  <local>:2:0:
00:32:06 <lambdabot>      Warning: Pattern match(es) are overlapped
00:32:06 <lambdabot>               In...
00:32:26 <sshc> > 8======>
00:32:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:32:29 <ivanm> @slap sshc
00:32:29 <lambdabot> I'd rather not; sshc looks rather dangerous.
00:32:33 <ivanm> grrr...
00:32:40 <kmc> @slap lunabot
00:32:40 * lambdabot hits lunabot with an assortment of kitchen utensils
00:32:47 <kmc> #slap lambdabot
00:32:49 <lunabot>  luna: Not in scope: `slap'
00:32:50 <kmc> :(
00:34:14 <bnijk_> oh one question - are there any good browsers in haskell
00:34:29 <bnijk_> or mail clients
00:34:41 <Jonno_FTW> idk, but midori is pretty sweet browser, scoring 100/100 in the acid3 test
00:34:54 <Jonno_FTW> the only browser i am aware of that can do it
00:34:56 <bnijk_> midori needs more configurability
00:35:05 <Jonno_FTW> perfect score.....
00:35:20 <bnijk_> i am a big fan of 'vimprobable' so far...i would like to see more in that vein
00:35:41 <bnijk_> since the entire haskell community is here to do my bidding
00:35:48 <Jonno_FTW> yes my liege
00:36:08 * bnijk_ hands out castrations, castrations for everyone!
00:36:11 <bnijk_> all hail bnijk_
00:38:24 <ivanm> hmmmm.... bnijk_ anticipated my request for him to leave...
00:39:42 <fabjan> Jonno_FTW: According to wikipedia, Safari, Opera and Epiphany pass acid3
00:40:32 <ivanm> fabjan: AFAIK, all webkit-based ones pass acid3
00:40:37 <ivanm> as well as opera
00:42:12 <Jonno_FTW> i find it funny how IE is the worst of them all
00:42:32 <Jonno_FTW> at the same time it's pretty sad microsoft don't do anything about it
00:44:14 <ivanm> Jonno_FTW: too an extent, they can't; they pushed web developers to use their unofficial dodgy extensions so much, now they can't deprecate them without pissing too many people off
00:44:33 <Jonno_FTW> MICROSOFFFFTTTT HOOOOOOOOOUSSEEEE!
00:44:34 <ivanm> and without those extensions (and with the EU court ruling), there's little reason for using IE
00:44:51 <BMeph> What's really sad is that MS doesn't do anything about it, because IE is an industry standard, and would upset more people by being fixed than it does as it works now... :\
00:45:45 <BMeph> ...or, what ivanm said already. :)
00:47:15 <fabjan> There seem to be more users of non-ie browsers than ie as well.
00:47:41 <fabjan> So people are messing up for more than half their customers by catering to less than half of them.
00:52:54 <ivanm> fabjan: not really
00:53:04 <ivanm> IIRC, IE still has at least 75% market share
00:53:26 <fabjan> oh, perhaps just looking at w3s statistics was silly
00:53:26 <ivanm> because off all the offices that have XP and don't bother upgrading/replacing (and don't let their employees do so) IE 6 :s
00:53:36 <ivanm> heh
00:54:10 <ivanm> OK, wikipedia says about 63% for all IEs
00:54:21 <ivanm> *63.6
00:54:24 <ivanm> firefox about 24.7
00:56:13 <HaskellLove> whats the problem with euler?
00:56:20 <HaskellLove> project
00:56:24 <ivanm> you are
00:56:31 <HaskellLove> or the web does not load for me only
00:56:31 <Jonno_FTW> it's down at the moment
00:56:56 <BMeph> Welcome to the new decade, same as the old decade... ;p
00:57:11 <Jonno_FTW> HaskellLove: http://downforeveryoneorjustme.com/http://projecteuler.net/
00:57:11 <medfly> I'm told that some people who run websites find that they have more non-IE users than IE users
00:57:38 <ivanm> BMeph: it isn't a new decade
00:57:41 <ivanm> next year will be
00:57:48 <ivanm> just as 2001 was the first year of the new millenium
00:58:04 <systemfault> medfly: It always depends on the type of the website..
00:58:15 <medfly> a year where we change a non-first digit
00:58:22 <ivanm> yeah, pro-linux websites for example...
00:58:23 <medfly> :)
00:58:24 <systemfault> medfly: Geek websites are more likely to have a lower IE score.
00:58:29 <HaskellLove> ivanm correct i had to deal with such issue in a euler problem counting all sundays that start on first of months
00:58:59 <ivanm> HaskellLove: I hate to break this to you (well, not really, but I felt I should be polite) but the world doesn't revolve around Project Euler
00:59:23 <kmc> BMeph, won't get fooled again ;)
00:59:26 <HaskellLove> ivanm no? really? oh nooooooooooo :(
01:01:12 <medfly> are you trying to tell me #haskell doesn't solve project euler problems all day?
01:01:30 <ivanm> I have never touched project euler
01:01:38 <medfly> I did for a bit, but I got bored.
01:02:01 <medfly> I was solving questions by hand :)
01:02:52 <ivanm> heh
01:05:07 <mreh> @pl \f g x y -> f x `g` f y
01:05:07 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
01:05:26 <mreh> amazing
01:05:36 <medfly> I wonder what someone that sees flip =<< ((flip . ((.) .)) .) . flip (.) in code thinks
01:05:43 <medfly> "maybe I need to find another job"
01:05:49 <ivanm> medfly: they think "which bastard did that?"
01:05:53 <ivanm> what else would they think?
01:06:02 <medfly> okay, that's just me then
01:06:46 <BMeph> > flip on f ?g x y :: Expr
01:06:48 <lambdabot>   Ambiguous occurrence `x'
01:06:48 <lambdabot>  It could refer to either `L.x', defined at <local...
01:07:02 <medfly> @undefine
01:07:10 <BMeph> > flip on f ?g y z :: Expr
01:07:11 <lambdabot>   Unbound implicit parameter (?g::b -> b -> SimpleReflect.Expr)
01:07:11 <lambdabot>    arising fr...
01:07:25 <ivanm> x is defined internally for lambdabot
01:07:35 <medfly> oh
01:07:40 <portnov> :t \f g x y -> f x `g` f y
01:07:42 <ivanm> as are all single letter variables, but some can be used as functions and the rest have to be variables
01:07:42 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t1 -> t2) -> t -> t -> t2
01:07:46 <portnov> :t on
01:07:47 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:07:48 <BMeph> > flip on f (g :: Expr -> Expr -> Expr) y z :: Expr
01:07:49 <lambdabot>   g (f y) (f z)
01:07:54 <medfly> > t x
01:07:55 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
01:07:55 <lambdabot>         against infe...
01:07:55 <medfly> er
01:07:59 <medfly> @type x
01:08:00 <lambdabot> Expr
01:08:13 <BMeph> :t flip on
01:08:14 <lambdabot> forall b c a. (a -> b) -> (b -> b -> c) -> a -> a -> c
01:08:20 <BMeph> :t \f g x y -> f x `g` f y
01:08:21 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t1 -> t2) -> t -> t -> t2
01:09:22 <mreh> @pl \x y -> f x `g` f y
01:09:22 <lambdabot> (. f) . g . f
01:09:35 <mreh> that's what I meant to do
01:10:25 <BMeph> mreh: That's what 'on' does. Or rather, what `on` does... :)
01:10:42 <mreh> :t (on)
01:10:43 <BMeph> > g `on` f x y
01:10:43 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:10:44 <lambdabot>   Ambiguous type variable `b' in the constraints:
01:10:45 <lambdabot>    `GHC.Show.Show b'
01:10:45 <lambdabot>      a...
01:12:01 <mreh> i would expect f `on` g x y
01:12:11 <mreh> i'm doing f on g of x and y
01:12:20 <mreh> no i'm not
01:14:03 <mreh> > map ((+) `on` length) . tails $ [1..9]
01:14:04 <lambdabot>   [[]->
01:14:05 <lambdabot>    9
01:14:05 <lambdabot>  [-2]->
01:14:05 <lambdabot>    10
01:14:05 <lambdabot>  [-2,-1]->
01:14:06 <lambdabot> [5 @more lines]
01:14:36 <mreh> > foldl1 ((+) `on` length) . tails $ [1..9]
01:14:37 <lambdabot>   Couldn't match expected type `[a]'
01:14:37 <lambdabot>         against inferred type `GHC.Types...
01:15:47 <mreh> :t foldl1
01:15:48 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
01:15:59 <mreh> :t ((+) `on` length)
01:16:00 <lambdabot> forall a. [a] -> [a] -> Int
01:16:42 <mreh> > foldl ((+) `on` length) 0 . tails $ [1..9]
01:16:43 <lambdabot>   Couldn't match expected type `[a]'
01:16:43 <lambdabot>         against inferred type `GHC.Types...
01:16:47 <mreh> :t foldl
01:16:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:17:00 <mreh> > foldr ((+) `on` length) 0 . tails $ [1..9]
01:17:00 <lambdabot>   Couldn't match expected type `[a]'
01:17:01 <lambdabot>         against inferred type `GHC.Types...
01:17:10 <mreh> gah, sry about that
01:27:59 <mreh> :t on
01:28:00 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:56:49 <mreh> is there a faster way to do > foldr1 (+) . map length . tails $ [1..9]
01:57:10 <mreh> > foldr1 (+) . map length . tails $ [1..9]
01:57:11 <lambdabot>   45
01:58:22 <Ke> don't you know the result forehand
02:01:20 <mreh> \xs -> foldr1 (+) . map length . tails $ xs -- not when I make it into a function
02:01:42 <mreh> anyway, calculating it this way takes two folds
02:01:47 <Ke> like       let n =length [1..9] in n^2+n oslt
02:02:56 <mreh> how can you apply this to what I've done?
02:04:04 <Ke> isn't that just like a sum i= 1..length xs   xs
02:04:38 <ivanm> mreh: what are you wanting to do?
02:04:52 <ivanm> mreh: I'd be tempted to do length . concat . tails
02:04:56 <shachaf> Ke: That would be (n^2+n) `div` 2.
02:05:11 <Ke> yup
02:05:22 <ivanm> @type foldr1 (+) . map length . tails
02:05:23 <lambdabot> forall a. [a] -> Int
02:05:33 <ivanm> @type length . concat . tails
02:05:34 <lambdabot> forall a. [a] -> Int
02:06:02 <ivanm> mreh: and doesn't sum = foldr1 (+) (or close enough)
02:06:23 <shachaf> ivanm: What's the point of using tails at all?
02:06:46 <Jonno_FTW> how come this won't work: f x = foldl' (+) 0 $ map (\(a,b) -> (a^b) * (fib b)) (zip (cycle x) [1..50])
02:06:47 <mreh> what's the point in anything!
02:06:55 <mreh> why don't i just go and shoot myself
02:07:04 <Heffalump> mreh: what would be the point?
02:07:04 <Jonno_FTW> > let x = 3 in  f x = foldl' (+) 0 $ map (\(a,b) -> (a^b) * (fib b)) (zip (cycle x) [1..50])
02:07:06 <lambdabot>   <no location info>: parse error on input `='
02:07:14 <ivanm> shachaf: he's wanting to for some reason
02:07:15 <adu> mreh: I think you should be careful about saying things like that
02:07:23 <ivanm> but actually, you could work out what it does...
02:07:29 <Heffalump> Jonno_FTW: you say let ... in <expr>, not let ... in <def>
02:07:33 <ivanm> isn't that going to be the equivalent triangular number?
02:07:35 <adu> Heffalump: thats bad! don't say that... mreh might do it
02:07:41 <Heffalump> > f x
02:07:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
02:07:43 <lambdabot>    `GHC.Show.Show a'
02:07:43 <lambdabot>      a...
02:07:44 <mreh> adu: I dont own a gun
02:07:44 <ivanm> no, wait, half of squaring it
02:07:46 <shachaf> ivanm: Yes, that's what Ke said.
02:07:56 <ivanm> did he? must have missed it
02:08:02 <shachaf> ivanm: let n = length ... in (n^2+n) `div` 2
02:08:04 <shachaf> I think.
02:08:05 <adu> mreh: oh ok then, you should buy one then
02:08:18 <Jonno_FTW> > let x = 3 in  foldl' (+) 0 $ map (\(a,b) -> (a^b) * (fib b)) (zip (cycle x) [1..50])
02:08:20 <lambdabot>   Not in scope: `fib'
02:08:38 <Jonno_FTW> it's the nth fibonacci number you silly bot
02:08:46 <shachaf> @let fibs = 1 : 1 : zipWith (+) fibs (tail fibs); fib n = fibs !! n
02:08:47 <lambdabot>  Defined.
02:08:51 <Jonno_FTW> > let x = 3 in  foldl' (+) 0 $ map (\(a,b) -> (a^b) * (fib b)) (zip (cycle x) [1..50])
02:08:52 <lambdabot>   No instance for (GHC.Num.Num [a])
02:08:53 <lambdabot>    arising from the literal `3' at <inter...
02:08:58 <mreh> @slap adu
02:08:58 * lambdabot will count to five...
02:09:04 <Jonno_FTW> what's going wrong?
02:09:25 <shachaf> @ty cycle
02:09:26 <lambdabot> forall a. [a] -> [a]
02:09:32 <shachaf> You want repeat, perhaps?
02:09:38 <Jonno_FTW> oh right
02:09:44 <Jonno_FTW> > let x = 3 in  foldl' (+) 0 $ map (\(a,b) -> (a^b) * (fib b)) (zip (repeat x) [1..50])
02:09:45 <lambdabot>   18413361568086373680663219146505525
02:10:12 <Jonno_FTW> > let x = 0.5 in  foldl' (+) 0 $ map (\(a,b) -> (a^b) * (fib b)) (zip (repeat x) [1..50])
02:10:13 <lambdabot>   2.9999233790048763
02:10:30 <Jonno_FTW> when x = 0.5 it should be 2
02:11:03 <Heffalump> what's the point of the whole zip and repeat x thing, btw>
02:11:11 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=137
02:11:23 <mreh> yes, what is the point?! really!
02:11:23 <Heffalump> > let x = 0.5 in foldl' (+) 0 $ map (\b -> x^b * fib b) [1..50]
02:11:25 <lambdabot>   2.9999233790048763
02:11:32 <Jonno_FTW> such that it can raise the power to n and get the nth fibonacci
02:11:54 <Heffalump> > let x = 0.5 in foldl' (+) 0 $ map (\b -> x^b * fib b) [1..500]
02:11:56 <lambdabot>   3.0
02:13:18 <shachaf> > sum [0.5^b * fib b | b <- [1..500]]
02:13:19 <lambdabot>   3.0
02:13:55 <Jonno_FTW> the series is supposed to be infinite
02:14:11 <Ke> shachaf ivanm: am still way too drunkish to get any coefficients right though
02:14:43 <shachaf> Jonno_FTW: Maybe it's becaues of my definition of fib?
02:14:47 <shachaf> > sum [0.5^b * fib (b - 1) | b <- [1..500]]
02:14:48 <lambdabot>   2.0
02:14:59 <Jonno_FTW> oh
02:15:02 <shachaf> Since their F_n starts at 1.
02:15:06 <Jonno_FTW> yep yep
02:15:24 <shachaf> @undefine
02:15:38 <mreh> @src scanr
02:15:38 <lambdabot> scanr _ q0 []     =  [q0]
02:15:38 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
02:15:38 <lambdabot>     where qs@(q:_) = scanr f q0 xs
02:15:51 <shachaf> @let fibs = 1 : 1 : zipWith (+) fibs (tail fibs); fib n = fibs !! (n - 1)
02:15:52 <lambdabot>  Defined.
02:16:33 <shachaf> > let x = sqrt 2 - 1 in sum [x^b * fib b | b <- [1..1000]]
02:16:34 <lambdabot>   1.000000000000001
02:16:39 <mreh> @src scanr1
02:16:39 <lambdabot> scanr1 f []     = []
02:16:39 <lambdabot> scanr1 f [x]    = [x]
02:16:39 <lambdabot> scanr1 f (x:xs) = f x q : qs where qs@(q:_) = scanr1 f xs
02:17:28 <HaskellLove> anyone has solved euler 50? after some hours spent on wrong solutions, i dont even know if i understand how to solve it
02:18:12 <Jonno_FTW> well
02:18:15 <ivanm> it's zen: you're not meant to solve it
02:18:25 <Jonno_FTW> generate a list of problems below 1E6
02:18:29 <ivanm> so please STFU about project euler!
02:19:25 <Jonno_FTW> then generate  lists of consecutive primes below 1/2 n
02:19:30 <HaskellLove> ivanm wtf is your problem dude?
02:19:46 <HaskellLove> Jonno_FTW thanks, wanna go pm or here?
02:19:57 <Jonno_FTW> that's pretty much it
02:20:12 <Jonno_FTW> i'm sure there's a less complex solution
02:20:30 <ivanm> HaskellLove: that you keep harping on about project euler
02:20:53 <Jonno_FTW> stackoverflow is useful if you have troubless
02:21:57 <shachaf> HaskellLove: The point of the Project Euler problems is that you solve them for yourself, I believe. :-) Particularly if your questions are about the problem itself rather than some aspect of the language.
02:22:10 <ivanm> shachaf: exactly
02:22:23 <HaskellLove> shachaf yeah but i am one day on this problem and make no progress
02:22:26 <Jonno_FTW> i agree, come up with the algorithm yourself
02:22:28 <ivanm> but not in the sense that you try to ask people how to solve project euler to learn the language
02:22:32 <HaskellLove> i had several tries but i got wrong answers
02:22:33 <Jonno_FTW> wait a bit if you can't get it
02:22:42 <Jonno_FTW> come here for specific code troubles
02:22:47 <HaskellLove> ok
02:22:51 <Jonno_FTW> *code specific
02:23:05 <Jonno_FTW> algorithm and actual thinking are for you to do
02:23:11 <HaskellLove> I will go to math or something, for the algorithms part then
02:23:12 <shachaf> HaskellLove: If you're completely stuck, leave the problem alone for a while, perhaps.
02:23:23 <Jonno_FTW> no
02:23:31 <shachaf> What's the point? Why do you care about getting another checkmark?
02:23:35 <Axman6> HaskellLove: i see you didn't listen the other day :(
02:23:40 <Jonno_FTW> think of it yourself, if you can't get the solution you need in one sitting, wait a bit
02:24:43 <Cale> tsk, I implemented `on` entirely in terms of pure and (<*>), but the expression is a bit too long to fit on one line of IRC :)
02:24:43 <ivanm> Axman6: s/didn't listen the other day /don't listen/
02:24:51 <Cale> (<*>)((<*>)(pure(<*>))((<*>)(pure((<*>)(pure(<*>))))((<*>)(pure((<*>)(pure((<*>)(pure (<*>))))))((<*>)(pure((<*>)(pure((<*>)(pure pure)))))((<*>)((<*>)(pure(<*>))((<*>)(pure pure)((<*>)(pure(<*>))((<*>)(pure pure)((<*>)pure(pure::a->b->a))))))(pure((<*>)((<*>)(pure(<*>))((<*>)(pure pure)((<*>)pure(pure::a->b->a))))(pure((<*>)pure(pure::a->b->a))))))))))(pure((<*>)(pure pure)((<*>)((<*>)(pure(<*>))((<*>)(pure pure)((<*
02:24:51 <Cale> >)pure(pure::a->b->a))))(pure((<*>)pure(pure::a->b->a))))))
02:24:52 <ivanm> Cale: ala fermat?
02:24:54 <ivanm> ;-)
02:25:07 <Jonno_FTW> parantheses
02:25:10 <ivanm> Cale: so you can't use lambdabot to prove it with @type ?
02:25:14 <Jonno_FTW> are in excess today are they?
02:25:22 <Cale> Are they?
02:25:39 <Jonno_FTW> we had an extra large shipment of parantheses come in by mistake
02:25:44 <Axman6> Cale: now do it by removing as many brackets as possible
02:25:59 <Jonno_FTW> replace with $
02:26:02 <ivanm> Cale: let s = (<*>) in ... ?
02:26:03 <adu> Cale: ...
02:26:17 * adu *blinks*
02:26:18 <Cale> Yeah, let's do that
02:27:43 <ivanm> Cale: you do it on your end; I"m going to stuff up trying to re-write it out by hand
02:27:46 <Cale> :t let s = (<*>); k = pure in s(s(k s)(s(k(s(k s)))(s(k(s(k(s(k s)))))(s(k(s(k(s(k k)))))(s(s(k s)(s(k k)(s(k s)(s(k k)(s k(k::a->b->a))))))(k(s(s(k s)(s(k k)(s k(k::a->b->a))))(k(s k(k::a->b->a))))))))))(k(s(k k)(s(s(k s)(s(k k)(s k(k::a->b->a))))(k(s k(k::a->b->a))))))
02:27:47 <lambdabot> forall b a b1. (b1 -> b1 -> b) -> (a -> b1) -> a -> a -> b
02:27:53 <Cale> :t on
02:27:54 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
02:28:14 <Accidus> :)
02:28:23 <ivanm> Cale: the type variables used are a bit weird though :s
02:28:55 <Cale> I had to give some explicit signatures to disambiguate the instance of Applicative before.
02:29:14 <ivanm> ahhhh
02:29:15 <Cale> (basically, in all the SKK's
02:29:17 <Cale> )
02:29:18 <ivanm> I see it now
02:29:32 <shachaf> lambdabot should have a primitive @pl that turns everything into S and K.
02:29:57 <ivanm> shachaf: well, go forth and implement!
02:31:44 <Jafet> Haskell->Jot, go go go
02:32:05 <ivanm> Cale: now, do I dare ask why you bothered to do that derivation?
02:34:18 <elly> Cale: you're a bad person
02:34:28 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=5683#a5683 <-- here's the quick hack I wrote to do it
02:35:53 <Cale> (you can load that up and  t on'  in ghci to see the SK expression
02:36:05 <Cale> )
02:36:27 <Jonno_FTW> what is the difference between ** and ^^ ?
02:36:49 <ivanm> @type (**)
02:36:50 <lambdabot> forall a. (Floating a) => a -> a -> a
02:36:51 <ivanm> @type (^^)
02:36:52 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
02:36:54 <Cale> ^^ works with any fractional base, but integer exponents
02:37:07 <ivanm> Jonno_FTW: (^^) is more efficient for integer exponents
02:37:07 <Cale> ** works with only floating bases, but also floating exponents
02:37:13 <ivanm> @src (^^)
02:37:13 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
02:37:17 <ivanm> @src (**)
02:37:17 <lambdabot> Source not found. :(
02:37:19 <Cale> Neither is more general than the other
02:37:23 <ivanm> I think that uses logs, etc.
02:37:37 <Jafet> You made lambdabot sad
02:37:41 <Jonno_FTW> > 0.5^^3
02:37:43 <lambdabot>   0.125
02:37:46 <Jonno_FTW> > 0.5**3
02:37:47 <lambdabot>   0.125
02:37:52 <Cale> x ** y = exp (log x * y)  is roughly true
02:37:53 <ivanm> Cale: well, you can consider (^^) (from a type perspective) to be a specialised form of (**)
02:38:11 <Jonno_FTW> so which should i use to be safe?
02:38:17 <Cale> ivanm: It's also generalised in the base.
02:38:30 <Cale> Jonno_FTW: Use whichever is appropriate to what you're doing
02:38:33 <Jafet> You could just define x**y = exp (log xy), in which case it's true
02:38:43 <ivanm> Cale: oh, it allows negatives whereas (**) doesn't?
02:38:54 <ivanm> > (-0.3)^^2
02:38:55 <lambdabot>   9.0e-2
02:38:59 <ivanm> > (-0.3)**2
02:38:59 <Cale> ivanm: There's that, but for instance  x^^y works with Rational x
02:38:59 <lambdabot>   9.0e-2
02:39:10 <Cale> While x ** y doesn't.
02:39:23 <Cale> > (3 % 4) ^^ (-1)
02:39:24 <lambdabot>   4 % 3
02:42:42 <Cale> ivanm: I thought to do it after someone here asked lambdabot for the type of on, and I thought, "hey, that's a pure combinator, I should be able to write it in terms of Applicative :)"
02:43:15 <Cale> ivanm: and then I got tired of trying to construct it by hand, and wrote a program to find an expression for me
02:43:26 <shachaf> Cale: It's not really in terms of Applicative if you only use the (r ->) instance, is it? It's just S and K. :-)
02:43:30 <Jafet> "find"?
02:43:36 <Cale> shachaf: Well, yeah.
02:44:31 <Cale> shachaf: and it's pretty unambiguously that instance, since S is mostly applied to too many parameters to be anything else.
02:47:30 <Axman6> anyone know if Lennart Kolmodin or Trevor Elliott hang out in here?
02:49:25 <Cale> I'm sure that Kolmodin used to at least.
02:49:50 <Cale> I don't recall seeing that nick in a while.
02:50:57 <Ke> Axman6: there is gentoo-haskell oslt, if you are interested in that
02:51:21 <shachaf> "kolmodin": Last seen  : Dec 30 06:16:11 2009 (2 days, 04:34:21 ago)
02:51:35 <mreh> i'm too stupid to work out how to zip a list of lists with their cumulative lengths
02:51:45 <Axman6> just thought i'd let them know what i thought of the cereal package they've worked on :)
02:52:06 <mreh> i need to use "scan" to cumulate the lists lenghts
02:52:31 <Jonno_FTW> what does the tuple of types mean in this definition? f :: (Integral a, Floating a) => a -> a
02:52:47 <Cale> Jonno_FTW: Those are not types, they're classes
02:52:55 <Jonno_FTW> well classes
02:52:56 <dibblego> Jonno_FTW, they are restrictions on a (notice the arrow is different)
02:53:03 <Jonno_FTW> ok
02:53:18 <Jonno_FTW> so it will only work on integrals and floating point numbers?
02:53:23 <dibblego> it says "for all values of 'a' such that a is in the class Integral and Floating"
02:53:26 <Cale> actually, it pretty much means the function is unusable
02:53:32 <shachaf> Jonno_FTW: Only work on numbers that are both Integral and Floating.
02:53:33 <Jonno_FTW> oh
02:53:35 <Cale> Since there are no types which are instances of both of those
02:53:42 <Jonno_FTW> hmmm
02:53:50 <Cale> So you forgot a numeric conversion
02:54:01 <Cale> Probably a fromIntegral
02:54:49 <Jonno_FTW> well i guess I am stuck on the problem then
02:55:24 <Cale> If you have an integer-typed value, and you want to use it as a floating point value (or any other numeric type), just apply fromIntegral to it first
02:55:54 <Cale> What type would you like f to have, and what is your current code? Is it long?
02:56:07 <Jonno_FTW> nope
02:56:11 <Jonno_FTW> was discussing it before
02:56:13 <ivanm> Axman6: kolmodin is on holidays atm
02:56:17 <Jonno_FTW> got it down to
02:56:32 <ivanm> Cale: he usually doesn't speak here, but he does in #gentoo-haskell
02:56:37 <ivanm> (he's a bit of a lurker)
02:57:01 <ivanm> Axman6: oh, kolmodin is behind cereal? IIRC, he was behind binary as well, and isn't cereal its successor?
02:57:07 <Jonno_FTW> this is what I had
02:57:08 <Jonno_FTW> f x = foldl' (+) 0 $ map (\b -> (x**b * (fib b))) [1..50]
02:57:15 <Axman6> ivanm: quite possible
02:57:32 <ivanm> Axman6: I think his "authorship" is "we've stolen code from binary which he wrote" ;-)
02:57:34 <Cale> oh, you probably just want that to be ^
02:57:38 <ivanm> since he isn't at chalmers anymore
02:57:38 <Cale> instead of **
02:57:42 <Axman6> heh
02:58:06 <Cale> ** only works on floating point types, and my guess is that your fib doesn't.
02:58:32 <Jonno_FTW> yep
02:58:35 <ivanm> Cale: heh, looking at it I have nfi how that code of yours to generate on works ;-)
02:59:24 <Jonno_FTW> now I have this
02:59:26 <Jonno_FTW> f x = foldl' (+) 0 $ [x^b * fib b|b<-[1..200]]
02:59:38 <Jonno_FTW> but that doesn't work with floats either
02:59:57 <Jonno_FTW> let x = 0.5 in foldl' (+) 0 $ [x^b * fib b|b<-[1..200]]
03:00:08 <Jonno_FTW> > let x = 0.5 in foldl' (+) 0 $ [x^b * fib b|b<-[1..200]]
03:00:10 <lambdabot>   2.0
03:00:19 <Jonno_FTW> or not
03:00:30 <ivanm> Cale: but looking at that code gives me the first inklink of what the precedence value in showsPrec actually does... >_>
03:00:35 <Jonno_FTW> in ghci it doesn't work though
03:00:43 <Cale> x^n works with any numeric type for x, but only positive integers for n
03:00:55 <Cale> ivanm: It's handy.
03:01:01 <Jonno_FTW> i don't need to consider negative n's
03:01:17 <Jonno_FTW> only integral n
03:01:23 <ivanm> Cale: it's handy if you ever need obfuscated code? :p
03:01:32 <Jafet> What kind of twisted series is x^b * fib b
03:01:48 <Cale> It's the generating series for fib
03:02:03 <ivanm> Cale: now you need to extend it to do list function conversion (i.e. what is the Applicative version of foldr or something?)
03:02:18 * ksf dreams about cabal menuconfig
03:02:33 <Jafet> Oh boy, fib has a series
03:02:36 <Axman6> > pi :: Rational
03:02:37 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
03:02:37 <lambdabot>    arising from a us...
03:02:41 <Cale> You can also write it (exactly) as  x/(1-x-x^2)
03:02:43 <Axman6> :
03:02:46 <Axman6> :(
03:02:53 <ksf> ideally, it should support configuring dependencies, too.
03:03:07 <Jafet> > pi :: Irrational
03:03:08 <lambdabot>   Not in scope: type constructor or class `Irrational'
03:03:22 <ivanm> ksf: hmmm?
03:03:40 <ivanm> Axman6: it's transcendental, what did you expect?
03:03:48 <Cale> > let x = 0.5 in x/(1-x-x^2)
03:03:49 <lambdabot>   2.0
03:03:53 <Jafet> :t pi
03:03:54 <lambdabot> forall a. (Floating a) => a
03:03:55 <ksf> ...just a ncurses menu with all the package options listed
03:04:01 <Jafet> Nope, it looks rational to me
03:04:28 <Jafet> > pi :: CReal
03:04:29 <lambdabot>   3.1415926535897932384626433832795028841972
03:05:01 <ksf> we don't have dependencies on useflags, yet, as well as installing different versions side-by-side cleanly, so much stuff that'd be nice to have can't be done, yet.
03:05:13 <Jonno_FTW> > show pi
03:05:14 <lambdabot>   "3.141592653589793"
03:05:38 <Twey> > take 10 $  map (\x -> x / (1 - x - x ^ 2)) [1 ..]
03:05:40 <lambdabot>   [-1.0,-0.4,-0.2727272727272727,-0.21052631578947367,-0.1724137931034483,-0....
03:06:43 <Cale> Or, probably more meaningful to write it as x / (1 - (x + x^2)), so the combinatorics behind it is a little clearer :)
03:08:49 <Cale> A set of weighted objects where there are fib n objects of weight n is in weight-preserving bijection with the set {1} x {1,2}*, where the weight on any given object is just the sum of the numbers in it
03:10:24 <Cale> Which is another way of saying that fib n is the number of ways of writing n as 1 + (a sum of 1's and 2's).
03:25:25 <Cale> Haha, "CaptainRecursion" on Reddit posted a comment starting with "Can we take about 3 steps back here for a second so I can understand something?", and someone replied with "Look CaptainRecursion, taking three steps back isn't the solution to every problem."
03:25:35 <Twey> Hahaha
03:26:13 <ivanm> heh
03:26:19 <ivanm> sometimes you only need to take 2!
03:26:36 <ivanm> and coincidentally, 2! == 2
03:26:37 <ivanm> ;-)
03:28:06 <shachaf> ivanm: As long as you're using !, you might as well use =.
03:28:21 <ivanm> ssshhhh!
03:29:54 <Gracenotes> :3
03:30:01 <cocon> how can an infinite list of random numbers be obtained? something of type IO [Double]
03:30:10 <ivanm> gah, MPTCs are driving me nuts! :@
03:30:19 <ivanm> cocon: randoms
03:30:20 <Axman6> :t randomIOs
03:30:21 <lambdabot> Not in scope: `randomIOs'
03:30:22 <ivanm> @type randoms
03:30:23 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
03:30:23 <Axman6> :t randomIO
03:30:24 <lambdabot> forall a. (Random a) => IO a
03:30:34 <ivanm> @hoogle (Random a) => IO [a]
03:30:34 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
03:30:34 <lambdabot> Control.Concurrent.Chan getChanContents :: Chan a -> IO [a]
03:30:34 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
03:30:43 <Axman6> fmap randoms randomIO
03:30:47 <Gracenotes> I believe the Random instance for Double does [0, 1]
03:30:48 <Axman6> :t fmap randoms randomIO
03:30:48 <lambdabot>     Ambiguous type variable `a' in the constraints:
03:30:49 <lambdabot>       `RandomGen a'
03:30:49 <lambdabot>         arising from a use of `randoms' at <interactive>:1:5-11
03:31:00 <ivanm> Gracenotes: yea, something like that
03:31:18 <ivanm> Axman6: ummm, StdGen isn't an instance of Random AFAIK
03:31:22 <ivanm> @instances Random
03:31:22 <lambdabot> Couldn't find class `Random'. Try @instances-importing
03:31:22 <Axman6> yeah
03:31:31 <ivanm> @instances-importing System.Random Random
03:31:31 <lambdabot> Bool, Char, Double, Float, Int, Integer
03:31:37 <ivanm> @instances-importing System.Random RandomGen
03:31:37 <lambdabot> StdGen
03:31:49 <mreh> @hoogle (a -> b -> c) -> (a -> d) -> (d -> b -> c)
03:31:49 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
03:31:50 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:31:50 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
03:32:00 <ivanm> cocon: you could always do getStdGen >>= return . randoms
03:32:07 <ivanm> @type getStdGen >>= return . randoms
03:32:07 <lambdabot> forall a. (Random a) => IO [a]
03:32:11 <Gracenotes> > randoms (mkStdGen 42) :: [Double]
03:32:12 <lambdabot>   [0.11040701265689151,0.8453984927258916,0.30778213446209723,0.7813880826070...
03:32:15 <ivanm> yup, seems to work
03:32:28 <ivanm> Gracenotes: that's easy to scale though
03:32:39 <Gracenotes> scale? in the cloud??
03:32:41 <mreh> > randoms newStdGen
03:32:42 <ivanm> just map ((+) b . (*) a)
03:32:43 <lambdabot>   No instance for (System.Random.RandomGen
03:32:43 <lambdabot>                     (GHC.IOBase.IO...
03:32:45 <ivanm> Gracenotes: heh
03:32:53 <ivanm> mreh: newStdGen is IO...
03:33:07 <mreh> > randoms =<< newStdGen
03:33:08 <lambdabot>   Couldn't match expected type `[a]'
03:33:08 <lambdabot>         against inferred type `GHC.IOBas...
03:33:20 <mreh> lol, hmm
03:33:35 <Twey> :t randoms
03:33:35 <ivanm> anyone know how to resolve MPTC bugs like this? Could not deduce (SGData d n1 e1) from the context (SGData d n5 e6)
03:33:36 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
03:34:29 <ivanm> oh, wait, I might need to add a fundep...
03:37:06 <ivanm> yay, associated types to the rescue!
03:37:15 <ivanm> *type families
03:40:33 <Cale> Funny, this PE problem is stated incorrectly. The only way you could guess that they want something much simpler than they've actually asked for is by examining the examples carefully.
03:40:55 <Axman6> they tend to do that
03:44:50 <ivanm> bugger, I've stuffed up my code by trying to make it too elegant
03:45:33 <ivanm> and now I've realised that the "elegant" version (which pre-computes root nodes, etc. once rather than for each different visualisation type) won't work because if I apply a function to it... >_>
03:46:58 <Cale> function?
03:47:19 <ivanm> Cale: I often apply a function to the graph (e.g. a clustering one) before graphing it
03:47:26 <ivanm> in which case, the roots, etc. might be different...
03:47:30 <Cale> ah
03:47:32 <ivanm> so pre-computing them is useless :s
04:04:12 <Liskni_si> I wish scientific papers had comments like blogs
04:06:15 <Axman6> sounds like a great idea for a website
04:06:18 <Jafet> Write your own paper and link to it
04:06:24 <Jafet> That's how blogs work anyway
04:06:44 <Jafet> And wait for the author to update with a trackback
04:08:28 <Liskni_si> I just wanted to look whether someone else noticed the mistake or it is just me who doesn't understand that paragraph.
04:09:44 <Liskni_si> In fact, I'd love to see all "replies" to that particular paper.
04:13:46 <Jafet> What worries me now is, I can't really think of a problem with writing papers like writing blogs
04:13:55 <Jafet> Should I feel scared
04:17:57 <Jonno_FTW> Which PE problem Cale?
04:19:55 <Cale> Jonno_FTW: Oh, it turned out I was just tired, I think.
04:20:06 <Jonno_FTW> i get that sometimes
04:20:21 <Jonno_FTW> i think i've hit the wall with what i can do on PE
04:20:53 <Jonno_FTW> i can't think of any non-brute force methods or just don't know enough haskell to implement what I would like to
04:21:15 <Cale> It was asking for the longest sum of consecutive primes summing to a prime less than 10^6, and I had misread it as 'largest'
04:21:27 <Jonno_FTW> oh right
04:21:32 <Jonno_FTW> yeah i was reading that
04:21:46 <ivanm> Jafet: yes, you should!
04:21:51 <Jonno_FTW> and thought of a brute force, but that would take forever
04:21:54 * Jafet feels scared
04:21:59 <ivanm> Jafet: the main problem would be lack of formality in a blog
04:22:02 <Cale> Brute force doesn't take that long actually
04:22:09 <Cale> about 5 seconds
04:22:10 <Jafet> I've read pretty formal blogs
04:22:12 <Jonno_FTW> last one took 2 hours
04:22:15 <ivanm> Cale: heh
04:22:21 <ivanm> Jafet: in general though
04:22:31 <Jafet> It depends on the person writing it.
04:22:33 <Jonno_FTW> not under the 1 minute goal
04:22:49 <ivanm> Jafet: and if we have a general "this is a pretty cool feature of Haskell I've found" post, it's a bit weird to then find an ultra-formal paper-like post in the next one
04:23:17 <ivanm> Jonno_FTW: yes, but you don't think at it like Cale does...
04:23:23 <Jafet> "Okay, I'm done insulting Oleg's mooma. Now we apply this endofunctor lol"
04:23:32 * ivanm actually has no idea what Jonno_FTW and Cale are talking about anyway
04:23:36 <ivanm> Jafet: exactly!
04:23:51 <ivanm> Jafet: also, blog posts don't look as good as a formal paper done up in *TeX
04:24:02 <ivanm> especially if you want to include maths, etc.
04:24:13 <Jafet> You could make a blog system that uses tex
04:24:13 <ivanm> and once you've done it up and published it in pdf, ps, whatever, it's _done_
04:24:20 <Jonno_FTW> this took 2 hours
04:24:22 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15446#a15446
04:24:26 <ivanm> there's no readability issues involved due to fonts, browser incompatibility, etc.
04:24:28 <Jafet> The whole point of blogging is that it's never _done_
04:24:31 <Jonno_FTW> except with a more naiive version of fib
04:24:53 <ivanm> Jafet: right; I can see blogging being done as a drafting style system (ala writing of RWH)
04:25:12 <ivanm> but I think the final version should be in a pdf or something rather than a blog post
04:25:19 <ivanm> (easier to print off as well!)
04:25:27 <shachaf> Jonno_FTW: "ii" doesn't really count as an "ï", despite having two dots. :-)
04:25:28 <Liskni_si> but then, how do I easily find replies to a paper?
04:25:44 <Jonno_FTW> sure it does
04:25:58 <Jafet> The blog itself could give an interface to retrieving the documents
04:26:05 <shachaf> What does the "log" part have to do with it? There's no particular need for a chronological order, is there?
04:26:27 <Jafet> So you can choose to download a printed postscript file, or view using tex2html
04:26:57 <ivanm> Jafet: tex2html produces _awful_ webpages
04:27:01 <luite> Jafet: that might be an advantage... papers may contain errors too and are often published in more than one place, with minor or major corrections.
04:27:24 <Jafet> ivanm, I know
04:27:43 <Jafet> I think Sebah and Xavier's number theory website still uses it
04:28:01 <Jafet> Till this day I'm not sure what encoding it uses
04:29:19 <shachaf> Is there any non-awful way to turn TeX into HTML, by the way?
04:29:52 <medfly> pictures
04:32:18 <ivanm> shachaf: yes, a link to download a pdf
04:32:19 <ivanm> ;-)
04:33:02 <ivanm> shachaf: I'm not sure if there would be a way, since TeX is page-oriented and HTML is more "scalable" in terms of viewing sizes (ignoring manual frame placement, etc.)
04:33:33 <shachaf> ivanm: Is there anything that can produce both nice PDFs and nice HTML?
04:33:37 <Jafet> MathML!
04:33:42 <ivanm> heh
04:33:47 <ivanm> shachaf: doubt it
04:34:06 <ivanm> I've tried to use pandoc for it, but IMHO it produces abominable LaTeX (and thus PDF) documents
04:35:23 <Ke> is ghc really really painful to package or why are all distros lagging
04:35:34 <ivanm> Ke: what do you mean?
04:35:37 <ivanm> gentoo has 6.12
04:35:40 <b0fh_ua> Hi there!
04:36:02 <Ke> ivanm: perhaps in overlay
04:36:07 <ivanm> exactly
04:36:10 <ivanm> it isn't usable yet
04:36:12 <b0fh_ua> Can somebody please explain what's wrong in the code at http://pastebin.com/d33b36543 and what did I miss in undersatanding points when making a function composition?
04:36:15 <ivanm> Ke: but the big thing with 6.12 is that not all libraries work with it yet, with the haskell platform there's more of a push for "end users" to use the platform release
04:36:29 <ivanm> also, it took a hell of a lot of time to port the ebuilds to the new build system, etc.
04:36:30 <Ke> =o(
04:37:00 <ivanm> b0fh_ua: so you're the Ukrainian Bastard Operator From Hell? :p
04:37:20 <ivanm> b0fh_ua: you want "putStrLn $ firstName person"
04:37:40 <ivanm> . is for function composition, and you don't have two functions there
04:37:40 <b0fh_ua> seems "bastard zero from hell" ;)
04:37:44 <ivanm> heh
04:37:48 <mokus> b0fh_ua: or "(putStrLn . firstName) person"
04:37:52 <ivanm> the alternative is "putStrLn . firstName $ person"
04:37:57 <ivanm> or what mokus said
04:38:03 <ivanm> but generally, using $ > using parens
04:38:05 <b0fh_ua> hm
04:38:18 <b0fh_ua> that's because haskell is left-associative?
04:38:22 <ivanm> nope
04:38:29 <ivanm> it's because it's function composition
04:38:34 <ivanm> @type (.(
04:38:35 <lambdabot> parse error (possibly incorrect indentation)
04:38:35 <ivanm> @type (.)
04:38:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:38:40 <int-e> function composition is left associative, yes
04:38:42 <ivanm> @slap Cale
04:38:42 * lambdabot would never hurt Cale!
04:38:46 <ivanm> @type (Prelude..)
04:38:47 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:38:56 <shachaf> Cale++
04:39:01 <ivanm> int-e: yes, but that has nothing to do with it AFAICT; you have to "finish off" the chain of function composition
04:39:02 <ivanm> Cale--
04:39:04 <ivanm> shachaf--
04:39:08 <mokus> function application as in "firstName person" binds closer than any operator
04:39:11 <int-e> a b c = (a b) c
04:39:19 <ivanm> mokus: right, that's the problem here
04:39:25 <shachaf> Hey! What did I do?
04:39:42 <mokus> so putStrLn . firstName person is (.) (putStrLn) (firstName person) which isn't what you want
04:39:43 <int-e> ivanm: "finish off" in what sense? Partial application is allowed.
04:40:00 <shachaf> Do we need to give karma by secret ballot in here?
04:40:00 <ivanm> shachaf: was your adding of karma to Cale in response to my "@slap Cale"?
04:40:25 <b0fh_ua> got it
04:40:25 <ivanm> int-e: in the sense of finally applying the chain of functions to a value
04:40:30 <shachaf> ivanm: It was in response to «(.) :: (Functor f) => (a -> b) -> f a -> f b».
04:40:35 <ghM> hello, I have a list of lists and I want to get the list with maximum length. I don't know how to do it.
04:40:40 <ivanm> shachaf: that's why I was slapping him ;-)
04:40:47 <Heffalump> @type maximum . map length
04:40:48 <lambdabot> forall a. [[a]] -> Int
04:40:55 <Heffalump> but beware of the outer list being empty..
04:40:58 <ivanm> shachaf: and it seemed to me that you were doing it just to spite me because lambdabot refused to slap...
04:40:59 <b0fh_ua> I thought it would be (.) (putStrLn) (firstName)
04:41:02 * ivanm might be a tad paranoid...
04:41:03 <ivanm> Cale++
04:41:05 <ivanm> shachaf++
04:41:07 <ivanm> happy now? ;-)
04:41:29 <ivanm> b0fh_ua: that might be OK if you do that
04:41:32 * Heffalump wonders if he did someone's homework for them
04:41:40 <ivanm> Heffalump: that won't get the list of maximum length
04:41:43 <ivanm> so no, you didn't ;-)
04:41:48 <Heffalump> oh yes, good point :-)
04:41:50 <int-e> ivanm: well, it turns out that IO values aren't functions, so yes, ultimately you'll have to do that
04:41:59 <ivanm> int-e: heh
04:42:00 <shachaf> ivanm: But come on, that's the True Type of (.).
04:42:11 <ivanm> shachaf: the report says otherwise AFAIK...
04:42:22 <Heffalump> @type maximum `on` length
04:42:23 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a] -> c
04:42:23 <lambdabot>     Probable cause: `maximum' is applied to too many arguments
04:42:23 <lambdabot>     In the first argument of `on', namely `maximum'
04:42:36 <Heffalump> @type maximumBy (compare `on` length)
04:42:37 <lambdabot> forall a. [[a]] -> [a]
04:42:44 <ivanm> that might be the _generalised_ type of (.), but (.) is for function composition IMHO, not a shortcut for fmap
04:42:47 <shachaf> Caleskell 2011!
04:43:13 * shachaf wonders if not sleeping to this point was unwise.
04:43:16 <ivanm> Heffalump: now you _are_ doing ghM's homework ;-)
04:43:24 <Cale> b0fh_ua: Probably the most important rule about operator precedence is that function application takes precedence over *any* operator
04:43:25 <ivanm> but he's quit already before you asked if it was homework, so *shrug*
04:43:34 <ivanm> @time shachaf
04:43:35 <lambdabot> Local time for shachaf is Fri Jan  1 04:43:10 2010
04:43:37 <Heffalump> right, otherwise I might have been more careful
04:43:41 <ivanm> yeah, sleep might help ;-)
04:43:58 <shachaf> Huh, I wonder why it's right; I thought my IRC client was in EST.
04:44:05 <ivanm> Heffalump: but a schwarzian transform/decorate-undecorate would be even better for that
04:44:11 <ivanm> since length can get expensive
04:44:20 <ivanm> shachaf: heh
04:44:25 <Heffalump> ivanm: agreed, but I can't remember if there are any nice combinators for doing that
04:44:25 <ivanm> shachaf: doesn't it grab the system time?
04:44:58 <shachaf> I thought the system was in EST; clearly it's not (or thinks it isn't).
04:45:03 <ivanm> Heffalump: nope
04:45:29 <ivanm> @type map fst . maximumBy (compare `on` snd) . map (ap (,) length)
04:45:30 <lambdabot>     Couldn't match expected type `[(a, b)]'
04:45:30 <lambdabot>            against inferred type `(a1, b1)'
04:45:30 <lambdabot>     In the first argument of `(.)', namely
04:45:41 <ivanm> @type fst . maximumBy (compare `on` snd) . map (ap (,) length)
04:45:42 <lambdabot> forall a. [[a]] -> [a]
04:45:51 <ivanm> Heffalump: ^^ that's probably as neat as you're going to get
04:45:54 <ivanm> @pl fst . maximumBy (compare `on` snd) . map (ap (,) length)
04:45:54 <lambdabot> fst . maximumBy (compare `on` snd) . map (ap (,) length)
04:46:05 <ivanm> duh, of course it won't @pl it anymore...
04:46:18 <shachaf> @unpl fst . maximumBy (compare `on` snd) . map (ap (,) length)
04:46:19 <lambdabot> (\ c -> fst (maximumBy (on compare snd) (map ((,) >>= \ h -> length >>= \ g -> return (h g)) c)))
04:46:25 <Heffalump> I'd forgotten about ap.
04:46:30 * shachaf wonders if @unpl has ever made anything clearer.
04:46:30 <ivanm> but I really wish there were versions of groupBy, sortBy, etc. that already assumed you wanted (groupBy `on` f), etc.
04:46:31 <doserj> @type snd . maximum . map (length &&& id)
04:46:32 <lambdabot> forall a. (Ord a) => [[a]] -> [a]
04:46:53 * doserj is cheating...
04:46:58 <ivanm> I often end up defining: groupSortBy f = groupBy ((==) `on` f) . sortBy (compare `on` f)
04:47:14 <ivanm> Heffalump: I cheated and used lambdabot to get that ap ;-)
04:47:21 <shachaf> doserj: Ord a is not acceptable.
04:47:22 <Heffalump> doserj: yeah, that's technically incorrect (as I'm sure you realised)
04:47:29 <mokus> ivanm: Data.Ord.comparing is handy for those cases
04:47:40 <doserj> s/maximum/maximumBy (comparing fst)/
04:47:41 <ivanm> doserj: that might get you a different return value...
04:47:44 <Heffalump> comparing f is just compare `on` f
04:48:05 <ivanm> mokus: *shrug* I prefer to stick with compare `on` because I often have (==) `on` there as well when I do it
04:48:27 <ivanm> @src comparing
04:48:27 <lambdabot> Source not found. Wrong!  You cheating scum!
04:48:35 <ivanm> @src on
04:48:35 <lambdabot> (*) `on` f = \x y -> f x * f y
04:48:48 <ivanm> on is a really nice function
04:49:00 <shachaf> on++
04:49:07 * shachaf 's GHC installation is a complete mess.
04:49:07 <ivanm> on++
04:49:11 <ivanm> shachaf: :(
04:49:32 <Heffalump> blow it away and start again
04:49:32 <ivanm> shachaf: as in your ghc-pkg db is stuffed up, or the actual physical install?
04:49:36 <Heffalump> cabal makes it nice and easy
04:49:37 <mokus> yea, I've avoided it in the past because for a while it was hit or miss whether it would be in the version of ghc i was using and it seemed inelegant to always be defining it myself
04:50:00 <Heffalump> mokus: I think defining it yourself is actually preferable, because it's then trivial to remove
04:50:21 <shachaf> ivanm: I just haven't used it for anything important in a long while. It can't compile itself anymore, for some reason.
04:50:30 <shachaf> I have 18 versions of GHC installed. Hah.
04:50:32 <ivanm> :s
04:50:35 <ivanm> heh
04:50:46 <shachaf> And the last working one is 6.8.2.
04:50:46 <ivanm> I wonder how that compares to dcoutts' install count...
04:50:47 <mokus> true, and then if you use a rewrite rule to automagically do the transform you've been talking about it wouldn't be orphaned
04:50:57 <ivanm> shachaf: manual by-hand install/versioning?
04:51:31 <shachaf> ivanm: I used to have a habit of darcs pulling every so often, and I'd never uninstall.
04:51:44 <ivanm> as in the ghc HEAD?
04:51:57 <ivanm> yeah, that's probably what some people like to call _bad_ ;-)
04:52:08 <shachaf> Indeed. :-)
04:52:19 <shachaf> ghc-6.11.20090501 ghc-6.8.1 ghc-6.9.20071012 ghc-6.9.20071128 ghc-6.9.20080126 ghc-6.9.20080424 ghc-6.7.20070830 ghc-6.8.2 ghc-6.9.20071023 ghc-6.9.20071213 ghc-6.9.20080414 ghc-6.9.20080502 ghc-6.7.20070913 ghc-6.9.20071002 ghc-6.9.20071030 ghc-6.9.20080101 ghc-6.9.20080416 ghc-6.9.20080602
04:52:25 * shachaf feels pretty silly now.
04:52:34 <Axman6> ...
04:55:04 <ivanm> preflex: seen dibblego
04:55:05 <preflex>  dibblego was last seen on #haskell 2 hours, 1 minute and 41 seconds ago, saying: it says "for all values of 'a' such that a is in the class Integral and Floating"
04:55:46 * Axman6 has a new blog post: http://random.axman6.com/blog/?p=121 :O
04:55:50 * ivanm waits a while to see if the magic incantation worked or not
04:56:02 <ivanm> Axman6: are you on planet?
04:56:09 <Axman6> i believe so
04:56:28 <Axman6> yes
04:56:49 <ivanm> yup, you are
04:57:06 <ivanm> so you've just saved me from reading it tomorrow when I was going to read planet anyway... >_>
04:57:07 <Axman6> not sure how long planet takes to get new stories though
04:57:12 <Axman6> heh
04:57:29 <ivanm> I think it syncs half hourly or something
04:57:43 <Axman6> hmm, the Wordpress iPhone app is actually really nice
05:18:18 <Administrador> tired of niggers?
05:18:24 <Administrador> sick
05:18:29 <Administrador> of their monkeyshines
05:19:14 <Twey> @where ops
05:19:15 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
05:19:43 <Twey> Even the same person as last time
05:20:14 <Axman6> i'd like to know where these people come from. they all get the same script from somewhere
05:21:29 <Jafet> @faq can Haskell spam IRC channels from the type system?
05:21:30 <lambdabot> The answer is: Yes! Haskell can do that.
05:26:51 <jlouis> Some clicked to trojan and drank the kool-aid?
05:28:24 <Axman6> quite possible
05:47:44 <cytzol> > take 10 $ iterate (3**) 1
05:47:46 <lambdabot>   [1.0,3.0,27.0,7.625597484987e12,Infinity,Infinity,Infinity,Infinity,Infinit...
05:48:06 <cytzol> > take 10 $ iterate (3^) 1
05:48:12 <lambdabot>   mueval: ExitFailure 1
05:48:16 <cytzol> :(
05:48:53 <copumpkin> > take 10 $ iterate (3^) 1
05:48:58 <lambdabot>   mueval: ExitFailure 1
05:49:01 <copumpkin> that is weird
05:49:04 <copumpkin> , take 10 $ iterate (3^) 1
05:49:10 <cytzol> > take 10 [ 1, 3, 9.. ]
05:49:11 <lambdabot>   <no location info>: parse error on input `..'
05:49:14 <lunabot>  Killed.
05:49:19 <copumpkin> hm
05:49:26 <copumpkin> oh
05:49:39 <copumpkin> > iterate (3^) 1
05:49:43 <copumpkin> it's not lazy enough
05:49:44 <lambdabot>   mueval: ExitFailure 1
05:49:53 <copumpkin> > iterate (2^) 1
05:49:53 <lambdabot>   [1,2,4,16,65536,20035299304068464649790723515602557504478254755697514192650...
05:53:05 <HaskellLove> is this same as concatenation (tail ps) `mplus` findPrimeSum ?
05:54:21 <HaskellLove> about the mplus thing i mean...
05:54:41 <copumpkin> > [1,2,3] `mplus` [4,5]
05:54:42 <lambdabot>   [1,2,3,4,5]
05:54:54 <HaskellLove> ok
05:55:09 <Jonno_FTW> @src mplus
05:55:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:56:01 <cytzol> copumpkin: not lazy enough?
05:56:26 <HaskellLove> in the documents it says associaton as part of Control.Monad ... but why would you use this when you have ++
05:56:41 <copumpkin> cytzol: the showing mechanism for IRC doesn't start showing immediately, but waits until you get a few characters first, which doens't happen in time
05:58:08 <cytzol> ah
05:59:51 <cytzol> HaskellLove: if you use mplus, you can use anything with a MonadPlus instance, whereas (++) only works on lists
06:00:41 <HaskellLove> I see... It seems wierd that here the problem is solved like that and not simply with lists. look at euler 50 http://www.haskell.org/haskellwiki/Euler_problems/41_to_50
06:01:00 <copumpkin> oh no, HaskellLove discovered the euler solutions on the wiki
06:01:19 <medfly> haha
06:01:37 <HaskellLove> copumpkin seriosly, why does not he simply use ++ and lists there?
06:01:55 <medfly> why do all these mathematicians insist on using monad functions when they can
06:02:14 <medfly> they should just use functions specific to their purpose
06:02:14 <copumpkin> HaskellLove: because it isn't lists
06:02:17 <copumpkin> heh
06:02:41 <Jafet> medfly, so they can debug them later
06:02:48 <copumpkin> > Just 5 `mplus` Just 6
06:02:49 <lambdabot>   Just 5
06:02:52 <copumpkin> > Just 5 `mplus` Nothing
06:02:53 <lambdabot>   Just 5
06:02:59 <copumpkin> > Nothing `mplus` Just 6
06:03:00 <lambdabot>   Just 6
06:03:03 <HaskellLove> medfly well yeah, close to my point above
06:03:11 <medfly> I'm being sarcastic.
06:03:20 <copumpkin> anyway, ++ wouldn't have worked
06:03:23 <copumpkin> not even in caleskell
06:03:52 <medfly> HaskellLove: they love how something being a monad means you automatically get these things that work for it
06:04:25 <medfly> HaskellLove: and even non mathematicians hate repeating code
06:04:28 <HaskellLove> so basically this sorts right?
06:04:47 <medfly> that said, I suck
06:05:00 <medfly> so you shouldn't count on anything I say to be ture
06:05:12 <Jafet> TMI
06:05:12 * medfly waits to be corrected.
06:05:42 <copumpkin> HaskellLove: not really
06:06:18 <HaskellLove> copumpkin so the mplus above sorts? I mean, given 5 and 6 it took 5 and if nothing which you can compare to getting to the last element and nothing, like last element and empty list in list, and just return the element...
06:06:31 <copumpkin> > Just 6 `mplus` Just 5
06:06:32 <lambdabot>   Just 6
06:06:39 <HaskellLove> ouch
06:06:53 <copumpkin> @src Maybe mplus
06:06:53 <lambdabot> Nothing `mplus` ys = ys
06:06:53 <lambdabot> xs      `mplus` ys = xs
06:06:59 <cytzol> HaskellLove: the MonadPlus instance for Maybe returns the first non-Nothing one it finds
06:07:26 <medfly> > Nothing `mplus` Nothing
06:07:27 <lambdabot>   Nothing
06:07:48 <HaskellLove> cytzol I see... wow... this is real language power, i should start learning monads ASAP
06:21:46 <HaskellLove> I am reading this book: Concepts, Techniques, and Models of Computer Programming, if anyone has read it please pm me, we can have talk on interesting issues
06:35:01 <Jonno_FTW> the SICP is meant to be pretty good
06:36:30 <Athas> Has anyone already defined Parsec wrappers for the standard Read instances?
06:36:40 <Athas> (And SICP is pretty good no matter the context!)
06:48:14 <Codex_> How does haskell handle equations?
06:49:37 <int-e> Athas: It doesn't work very well - the main problem is that Read doesn't return the consumed part, so you have to reconstruct the current position in the stream from the remainder returned by ReadS, or make Parsec's error messages far less useful.
06:58:02 * hackagebot upload: bamboo 2010.1.1 - A simple blog engine on Hack (JinjingWang)
07:12:50 <fft> How should I write to get an integer from parsec?     i <- integer or something like this doesn't work
07:13:11 <Ke> d?
07:13:32 <paulvisschers> How can I check whether a given FilePath refers to a directory, a file or something that doesn't exist?
07:14:22 <anhe> fft: check many1 and digit
07:14:30 <chrisdone> when you guys are writing a parser and you want to write a series of test-cases that must be true e.g. parse "foo bar" == Foo Bar, or parse "foo bar" == parse "foo (bar)", what do you use?
07:15:58 <pastah_rhymez> @type doesFileExist
07:16:00 <lambdabot> Not in scope: `doesFileExist'
07:16:14 <pastah_rhymez> @hoogle FilePath -> IO Bool
07:16:15 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
07:16:15 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
07:16:15 <lambdabot> System.Console.Editline.Readline readHistory :: FilePath -> IO Bool
07:16:22 <pastah_rhymez> paulvisschers: ^^
07:16:39 <paulvisschers> fft: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15447#a15447 for naturals, wirte a wrapper to include negative integers
07:17:34 <paulvisschers> pastah_rhymez: Thanks
07:18:01 <pastah_rhymez> 's cool, bro;
07:18:43 <pastah_rhymez> chrisdone: can't you turn that around to fail earlier and then opt out?
07:19:21 <pastah_rhymez> also: is someone hacking hpaste?
07:19:27 <chrisdone> opt out
07:19:28 <pastah_rhymez> lot's of shit on the starting page...
07:19:43 <chrisdone> looks like spam
07:20:03 <pastah_rhymez> chrisdone: all i have is a little nifty hack i learnt a few weeks ago (making paste now...)
07:21:41 <pastah_rhymez> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15448#a15448 <-- chrisdone
07:22:04 <pastah_rhymez> those guards were aligned when i wrote it! gaddammit!
07:22:11 <chrisdone> oh there's an idea. a pretty printer is much easier to write than a parser. if I define a pretty printer then with quickcheck I can do (\e -> e == parse (prettyprint e))
07:22:40 <chrisdone> they line up here
07:22:59 <pastah_rhymez> first one is a little off for me (vimperator, lolbuntu)
07:23:17 <chrisdone> what if p1 v1 fails? how do you know it failed?
07:24:22 <pastah_rhymez> chrisdone: reload my paste
07:24:47 <pastah_rhymez> if you want to be REALLY nasty, you replace that 'fail' with an 'error'
07:24:56 <pastah_rhymez> though that's kinda evil :)
07:25:37 <chrisdone> you could really just use the Either Monad
07:26:04 <chrisdone> looking for "standard" ways to do it really
07:26:15 <pastah_rhymez> chrisdone: actually i'm assuming the "Error" monad here (Either String)
07:26:21 <Paczesiowa> why does ghc complain if I don't export type constructor, and don't use it in a module? It has to be defined (in H98) and thus must be exported.
07:26:28 <pastah_rhymez> (note the 'return' in 'verify')
07:29:31 <pastah_rhymez> chrisdone: if 'p1 v1' is false i'll just reach the test for 'p2 v2', isn't that telling enough?
07:29:46 <skorpan> pastah_rhymez: open the base
07:29:56 <pastah_rhymez> skorpan: you do it
07:30:00 <pastah_rhymez> i don't wanna
07:30:00 <skorpan> you're rusty
07:30:04 <pastah_rhymez> fagg u
07:38:26 <chrisdone> I meant you could just do a list rather than manually doing it
07:39:24 <chrisdone> > foldr1 mplus [Left "ok",Left "ok."] :: Either String String
07:39:24 <chrisdone> > foldr1 mplus [Left "ok",Right "fail",Left "ok."]
07:39:26 <lambdabot>   Left "ok."
07:39:26 <lambdabot>   Right "fail"
07:40:42 <chrisdone> then again I suppose the Maybe monad is better
07:40:58 <chrisdone> > foldr1 mplus [Nothing,Just "error!",Nothing]
07:40:59 <lambdabot>   Just "error!"
07:44:08 <pastah_rhymez> chrisdone: i don't think i really understand what your end game is here... paste?
07:52:38 <chrisdone> pastah_rhymez: nevermind, haha
07:52:47 <pastah_rhymez> chrisdone: that verify pattern i have there is pretty swell because once you've done your parsing you can use function compositon
07:53:09 <pastah_rhymez> verify2 . verify1 . verify0 $ runParser p input
07:53:34 <chrisdone> why would you want to do that?
07:53:37 <pastah_rhymez> which at least i find quite nice :)
07:54:25 <pastah_rhymez> well, maybe you parsed lots of stuff but then you have a composed value returned by p that is easier to check once all the subparser are done and you have the final value
07:54:33 <pastah_rhymez> (internal properties and what not)
07:55:35 <chrisdone> mk
08:07:54 <Jonno_FTW> would it be reasonable to get all the subsets of a list by taking two subsets of the original list
08:08:11 <Jonno_FTW> and then the next bigger list
08:08:39 <Jonno_FTW> then continue for all elements in the list and then repeating for the next permutation?
08:09:49 <Jonno_FTW> [1,2,3,4] -> [ ([1],[2,3,4]) , ([1,2],[3,4] ) ......
08:09:52 <Jonno_FTW> ?
08:10:29 <Heffalump> I'd suggest a simple recursive formulation where you select or don't select each element.
08:10:51 <skorpan> inb4 Cale's `select'
08:11:44 <Jonno_FTW> i don't know that one
08:12:43 <twanvl> do you want all subsets/subsequences or all partitions of a list?
08:12:56 <Jonno_FTW> all subsets
08:13:07 <twanvl> > subsequences [1,2,3,4]
08:13:08 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
08:13:15 <pastah_rhymez> @src subsequences
08:13:16 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:13:28 <pastah_rhymez> @src Data.List.subsequences
08:13:28 <lambdabot> Source not found. Maybe you made a typo?
08:13:31 <Jonno_FTW> no wait, i want a list of tuples
08:13:34 <skorpan> powerset = filterM (const [True, False])
08:13:47 <skorpan> but maybe that's not the same thing?
08:13:49 <pastah_rhymez> Jonno_FTW: example?
08:14:21 <twanvl> skorpan: that filterM trick also gives the subsequences, but the function from Data.List is faster and more lazy
08:14:22 <Jonno_FTW> where the second elements contains the elements of the original list not present in the first element
08:14:55 <pastah_rhymez> Jonno_FTW: magicFun "abc" == ??
08:14:55 <Jonno_FTW> eg [1,2,3,4,5] -> ([1,2],[3,4,5])
08:15:12 <Jonno_FTW> @src magicFun
08:15:13 <lambdabot> Source not found.
08:15:48 <pastah_rhymez> Jonno_FTW: you don't want [("a","bc"), ("b","ac"), .., ("abc","")] ?
08:16:18 <Jonno_FTW> eg [1,2,3,4,5] -> [ ([1,2],[3,4,5]) , ([1,2,3],[4,5]) .....
08:16:37 <Jonno_FTW> the sets can't be empty
08:17:27 <pastah_rhymez> Jonno_FTW: make a complete result list for "abc"... i don't see the desired end result here (or maybe "abcd" if "abc" is too small to show what you want) :)
08:17:31 <pastah_rhymez> please?
08:18:06 <skorpan> i think he means "abc" => [("a", "bc"), ("ab", "c")]
08:18:24 <Jonno_FTW> i want to split the original set into all possible subsets
08:18:47 <Jonno_FTW> such that when the 2 subsets are combined, they form the original set
08:18:54 <skorpan> if you are really talking about sets then `subsequences' is probably what you want. but you are not talking about sets.
08:19:18 <Jonno_FTW> so i get a list of tuples containing complimentary subsets
08:20:02 <Jonno_FTW> if complimentary is the right word here
08:20:23 <medfly> tuples?
08:20:49 <Jonno_FTW> (a,b)
08:20:57 <Jonno_FTW> [(a,b)]
08:21:20 <Jonno_FTW> xs -> [(a,b)]
08:21:31 <twanvl> > let f [] = [([],[])]; f (x:xs) = concat [ [(x:a,b),(a,x:b)] | (a,b) <- f xs] in f "abc"
08:21:32 <lambdabot>   [("abc",""),("bc","a"),("ac","b"),("c","ab"),("ab","c"),("b","ac"),("a","bc...
08:21:56 <Jonno_FTW> such that a++b == xs
08:22:12 <medfly> I don't think those are going to be equal
08:22:27 <medfly> > "abc" == "bac"
08:22:28 <lambdabot>   False
08:22:32 <Jonno_FTW> and such that:  b && a /= []
08:23:40 <Jonno_FTW> b /= [] && a /= []
08:23:49 <twanvl> Jonno_FTW: are you talking about sets or lists here? Usually (++) means list concatenation, so order would be significant
08:24:11 <Jonno_FTW> what's the difference?
08:24:31 <twanvl> do you want [1,2,3] -> [ ..., ([1,3],[2]), ... ]  ?
08:24:52 <twanvl> because [1,3]++[2] /= [1,2,3]
08:24:53 <Jonno_FTW> yes
08:25:27 <Jonno_FTW> order is not significant within each subset
08:26:23 <twanvl> > let f [x] = [([],[x])]; f (x:xs) = concat [ [(x:a,b),(a,x:b)] | (a,b) <- f xs]; g (x:xs) = [ (x:a,b) | (a,b) <- f xs] in g [1,2,3,4]
08:26:24 <lambdabot>   [([1,2,3],[4]),([1,3],[2,4]),([1,2],[3,4]),([1],[2,3,4])]
08:26:29 <twanvl> is that what you are looking for?
08:27:58 <Jonno_FTW> yep
08:28:20 <Jonno_FTW> thanks
08:28:47 <twanvl> do you understand how it works?
08:29:14 <Jonno_FTW> not really
08:29:44 <Jonno_FTW> please go ahead
08:30:02 <twanvl> okay, I'll try to explain
08:30:18 <twanvl> first i will look at a simpler version that does include empty lists in the output
08:30:36 <twanvl> let's call the function 'splits'
08:31:18 <twanvl> there is only one way to split the empty list, so  splits [] = ([],[])
08:31:24 <twanvl> with me so far?
08:31:34 <Jonno_FTW> yep
08:32:02 <twanvl> okay, now to calculate splits (x:xs)
08:32:39 <twanvl> first we split xs in all possible ways
08:33:17 <twanvl> then x should go in either the first or the second part of the tuple (and in fact you want both answers)
08:33:25 <Jonno_FTW> ok
08:33:50 <twanvl> so if (a,b) is a way to split xs, then  (x:a,b) and (a,x:b) are two ways to split (x:xs),  right?
08:34:07 <Jonno_FTW> yep
08:34:08 <medfly> hi
08:34:58 <twanvl> okay so:  splits (x:xs) = concat [ [(x:a,b),(a,x:b)] | (a,b) <- splits xs]
08:35:07 <medfly> I have a less mindblowing way of doing it
08:35:46 <Jonno_FTW> i got it
08:36:03 <twanvl> medfly: your function is different, it doesn't give ([1,3],[2,4])  for  subs [1,2,3,4]
08:36:19 <twanvl> Jonno_FTW: so that is splits that allows empty lists in the answer
08:36:28 <Jonno_FTW> yep
08:37:08 * twanvl just realized his function is wrong
08:37:16 <medfly> @let subse xs = [(take n xs, drop n xs) | n <- [1..(length xs - 1)]]
08:37:16 <lambdabot>  Defined.
08:37:18 <medfly> :]
08:37:20 <Jonno_FTW> D:
08:37:22 <medfly> > subse [1,2,3,4]
08:37:23 <lambdabot>   [([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4])]
08:37:37 * medfly crawls back into the hole
08:38:04 <Jonno_FTW> that
08:38:24 <Jonno_FTW> was sort of how i originally planned to do it, but didn't know how to express it
08:40:24 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=105
08:40:35 <Jonno_FTW> is what i was trying to figure out
08:42:19 <Jonno_FTW> but now i see that each subset oair doesn't necessarily contain all elements of the original list
08:42:30 <twanvl> I doubt you will be able to solve that in this way
08:42:54 <Jonno_FTW> that's what realised when i reread the question
08:43:30 <Jonno_FTW> *what I
08:46:04 <medfly> sorry for interrupting
08:50:38 <Jonno_FTW> i have this test to see if a set is special
08:50:39 <Jonno_FTW> isSpec xs =False `notElem` $ map (\(b,c)->if length a > length b then ((sum' b) > (sum' c) else (sum' b) /= (sum' c)) $ map org $ g xs
08:51:17 <Jonno_FTW> where org organises in order of most elements
08:51:32 <Jonno_FTW> *tuples in
08:51:52 <Jonno_FTW> org (a,b) | length a > length b = (a,b)   | otherwise = (b,a)
08:53:54 <Jonno_FTW> and perhaps used
08:54:30 <Jonno_FTW> subsets xs = [splitAt n xs | n<-[1..(length xs -1)]]
08:54:31 <Olathe> > let sums xs = f' [] (x:xs) where f' rs [] = [(sum rs, rs)]; f' rs (x:xs) = f' (x:rs) xs ++ f' rs xs in f' [1, 2, 3]
08:54:32 <lambdabot>   Not in scope: `f''
08:54:56 <Olathe> > let sums xs = f' [] (x:xs) where f' rs [] = [(sum rs, rs)]; f' rs (x:xs) = f' (x:rs) xs ++ f' rs xs in sums [1, 2, 3]
08:54:57 <lambdabot>   [(0 + 3 + 2 + 1 + x,[3,2,1,x]),(0 + 2 + 1 + x,[2,1,x]),(0 + 3 + 1 + x,[3,1,...
08:55:41 <Olathe> > let sums xs = f' [] xs where f' rs [] = [(sum rs, rs)]; f' rs (x:xs) = f' (x:rs) xs ++ f' rs xs in sums [1, 2, 3]
08:55:42 <lambdabot>   [(6,[3,2,1]),(3,[2,1]),(4,[3,1]),(1,[1]),(5,[3,2]),(2,[2]),(3,[3]),(0,[])]
08:56:00 <flippo> yay
08:56:22 <Olathe> > let sums xs = f' [] xs where f' rs [] = [(sum rs, rs)]; f' rs (x:xs) = f' (x:rs) xs ++ f' rs xs in sortBy (comparing fst) $ sums [1, 2, 3]
08:56:23 <lambdabot>   [(0,[]),(1,[1]),(2,[2]),(3,[2,1]),(3,[3]),(4,[3,1]),(5,[3,2]),(6,[3,2,1])]
08:56:52 <Olathe> > let sums xs = f' [] xs where f' rs [] = [(sum rs, rs)]; f' rs (x:xs) = f' (x:rs) xs ++ f' rs xs in group . sortBy (comparing fst) . sums $ [1, 2, 3]
08:56:54 <lambdabot>   [[(0,[])],[(1,[1])],[(2,[2])],[(3,[2,1])],[(3,[3])],[(4,[3,1])],[(5,[3,2])]...
08:57:04 <Olathe> > let sums xs = f' [] xs where f' rs [] = [(sum rs, rs)]; f' rs (x:xs) = f' (x:rs) xs ++ f' rs xs in groupBy (comparing fst) . sortBy (comparing fst) . sums $ [1, 2, 3]
08:57:06 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:57:06 <lambdabot>         against inferred type ...
08:57:42 <flippo> It's the ghci channel
09:01:12 <SamB_XP_> flippo: you DO know that isn't ghci, right?
09:01:23 <flippo> SamB_XP_, no I didn't, actually
09:01:38 <kmc> hehe
09:01:51 <kmc> lambdabot is way sexier than ghci
09:01:53 <SamB_XP_> @blame eval
09:01:54 <lambdabot> Unknown command, try @list
09:01:57 <kmc> can ghci do this
09:02:00 <kmc> @. elite nixon
09:02:00 <lambdabot> s0|U+ioN$ 4Re N0+ +|-|3 aNsw3r.
09:02:11 <tensorpudding> it'd be nice if ghci could do everything that lambdabot does
09:02:11 <SamB_XP_> kmc: only on acid ;-P
09:02:12 <kmc> @yhjulwwiefzojcbxybbruweejw
09:02:12 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
09:02:35 <SamB_XP_> kmc: what was that one ????
09:02:54 <SamB_XP_> I mean, I know how to get that, but is that really the name of the command ?
09:03:02 <kmc> @yhjulwwiefzojcbxybbruweejw
09:03:02 <lambdabot> Just 'J'
09:03:08 <kmc> yes
09:03:22 <SamB_XP_> > iterate show ""
09:03:24 <lambdabot>   ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\...
09:03:26 <SamB_XP_> hmm.
09:03:30 <SamB_XP_> > fix show ""
09:03:31 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
09:03:31 <lambdabot>         against inferr...
09:03:38 <SamB_XP_> > fix show
09:03:39 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
09:03:40 * SamB_XP_ silly
09:04:05 <kmc> > fix error
09:04:06 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
09:04:14 <kmc> > error error
09:04:15 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:04:15 <lambdabot>         against inferred ty...
09:04:23 <Boxo> > show undefined
09:04:25 <lambdabot>   "* Exception: Prelude.undefined
09:04:33 <kmc> > let x = error in x x
09:04:34 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:04:34 <lambdabot>         against inferred ty...
09:04:35 <copumpkin> > map length . group . fix $ show
09:04:39 <lambdabot>   mueval-core: Time limit exceeded
09:05:12 <tensorpudding> > fix map
09:05:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:06:18 <osaunders> Is it possible to have faster performing, fixed-length lists?
09:06:32 <kmc> in what sense are they lists?
09:06:39 <kmc> there are faster fixed-length sequential data structures
09:06:45 <tensorpudding> there are Arrays
09:06:47 <osaunders> Yeah, arrays I should say
09:06:48 <kmc> there are also faster non-fixed-length sequential data structures
09:06:55 <tensorpudding> which are faster in lookups, and immutable
09:07:01 <kmc> there are mutable arrays too
09:07:04 <kmc> and DiffArray
09:07:11 <tensorpudding> yes, there are a lot of different kinds of array
09:07:26 <kmc> osaunders, there's also Data.Sequence
09:07:42 <osaunders> OK, thanks
09:07:52 <kmc> i wish i had known about it earlier
09:08:05 <tensorpudding> what advantages does sequence have?
09:08:22 <kmc> log time indexing
09:08:34 <kmc> log time concat
09:08:58 <tensorpudding> i assume it's traversable
09:09:05 <kmc> yup
09:09:23 <kmc> so are lists and arrays
09:09:31 <tensorpudding> well, yes
09:09:48 <tensorpudding> lists have all the nice properties, except being slow
09:09:59 <tensorpudding> err, except they are slow
09:10:13 <kmc> lists have all the nice properties except being fast ;)
09:11:15 <tensorpudding> the advantage of lists is that it is built-in
09:11:16 <Paczesiowa> > error undefined
09:11:17 <lambdabot>   * Exception: * Exception: Prelude.undefined
09:11:29 <Paczesiowa> > undefined error
09:11:30 <lambdabot>   * Exception: Prelude.undefined
09:11:45 <kmc> lists are more useful as a control-flow structure than a datastructure
09:12:14 <tensorpudding> trying to express matrices as [[a]] is a pain
09:12:31 <kmc> list are really important in a non-strict language for this reason
09:12:54 <tensorpudding> arrays can be indexed by tuples, which makes them nicer in some ways
09:14:20 <kmc> ideally the compiler should optimize each use of lists to streams and then to nothing at all :)
09:15:35 <SamB_XP> kmc: did you read the *paper*, or just the title?
09:15:51 <tensorpudding> though getting matrix multiplication with arrays would be hairy
09:16:45 <kmc> both
09:17:02 * SamB_XP contemplates running the MS DOS 6.22 installer ;)
09:17:17 <kmc> yes i know that not all lists can be fused
09:17:24 <kmc> or rather, not all operations
09:17:24 <tensorpudding> does ghc run in dos?
09:17:28 <kmc> that's why i said "ideally"
09:17:33 <kmc> hugs probably does
09:17:40 <SamB_XP> tensorpudding: not that I've ever heard of
09:18:17 <CalJohn> is there any reason why Data.List is not being replaced with Data.List.Stream ?
09:18:31 <SamB_XP> kmc: I only said that because what you had just said was basically a restatement of the title ;-P
09:18:41 <Jonno_FTW> > let xs = [1..5] in [splitAt n xs | n <- [1..(length (xs-1))]]
09:18:42 <lambdabot>   No instance for (GHC.Num.Num [t])
09:18:42 <lambdabot>    arising from the literal `1' at <inter...
09:18:51 <kmc> yes it was a reference ;)
09:18:59 <kmc> see, i like to namedrop things
09:20:23 <Saizan_> CalJohn: i think i've read it's not as good at fusing nested concatMaps, i.e. list comprehensions
09:20:31 <Saizan_> though that was quite some time ago
09:21:29 <Jonno_FTW> > let xs = [1..5] in [splitAt n xs | n <- [1..(length xs -1)]]
09:21:30 <lambdabot>   [([1],[2,3,4,5]),([1,2],[3,4,5]),([1,2,3],[4,5]),([1,2,3,4],[5])]
09:22:16 <Paczesiowa> Saizan_: iirc foldr/build doesn't fuse them either
09:22:17 <Boxo> @type iterate (.show) show
09:22:20 <lambdabot> [String -> String]
09:22:22 <medfly> :)
09:22:23 <Boxo> @type iterate (show.) show
09:22:25 <lambdabot> forall a. (Show a) => [a -> String]
09:23:21 <Jonno_FTW> takeWhile (notAsleep) $ length $ cycle "sheep"
09:23:31 <Heffalump> length?
09:23:52 <Jonno_FTW> takeWhile (notAsleep) $ cycle "sheep"
09:24:06 <Jonno_FTW> to sleepy to be thinking about these things
09:24:19 <Heffalump> in any case, your sheep clearly have hidden side effects. Bad sheep.
09:24:55 <Boxo> will be either (cycle "sheep") or []
09:25:07 <kmc> > cycle "what "
09:25:09 <lambdabot>   "what what what what what what what what what what what what what what what...
09:25:26 <Jonno_FTW> cycle "sheep :
09:25:29 <Jonno_FTW> cycle "sheep "
09:25:30 <Jonno_FTW> > cycle "sheep "
09:25:32 <lambdabot>   "sheep sheep sheep sheep sheep sheep sheep sheep sheep sheep sheep sheep sh...
09:25:49 <Jonno_FTW> > zip [1..] $ cycle "sheep "
09:25:50 <lambdabot>   [(1,'s'),(2,'h'),(3,'e'),(4,'e'),(5,'p'),(6,' '),(7,'s'),(8,'h'),(9,'e'),(1...
09:25:52 <Paczesiowa> > "zzz"
09:25:53 <lambdabot>   "zzz"
09:26:22 <Saizan_> http://hackage.haskell.org/trac/ghc/ticket/915
09:26:32 <Botje> Jonno_FTW: you forgot "sheep shagger" in there somewhere :)
09:26:50 <Jonno_FTW> i am not a new zealander
09:32:18 <Botje> it's a joke from the fast show :)
09:43:52 <copumpkin> @hackage statistics
09:43:52 <lambdabot> http://hackage.haskell.org/package/statistics
09:46:14 <copumpkin> @ask bos have you considered making the statistics functions polymorphic and adding {-# SPECIALIZE #-} pragmas for Double and Float to not sacrifice speed for those?
09:46:15 <lambdabot> Consider it noted.
09:47:15 <edwardk> want rationals?
09:53:16 <copumpkin> edwardk: yeah, or Floats
09:53:35 <copumpkin> lots of data might not fit into memory
09:56:52 <copumpkin> especially since there are no lazy uvectors
09:57:25 <edwardk> i need to package up my statistical monoids at some point. i have them lying around in a directory somewhere
09:57:55 <copumpkin> a thousand and one monoids!
09:58:53 <Philonous> Is there something like an arrow transformer? I just noticed how my arrow library derives properties from an underlying arrow almost trivially.
10:01:34 <en0th> :t arrow
10:01:36 <lambdabot> Not in scope: `arrow'
10:02:15 <en0th> :i Arrow
10:02:45 <en0th> isnt :i for info?
10:04:19 <edwardk> Philonous: yes there is
10:04:46 <edwardk> http://hackage.haskell.org/packages/archive/arrows/0.4/doc/html/Control-Arrow-Transformer.html#t%3AArrowTransformer
10:04:52 <copumpkin> edwardk: bah, I can't even post to the bostonhaskell list to ask what's going on! I was wondering why it was so low-traffic, but I guess it's because nobody's allowed to post to it :(
10:05:44 <Philonous> edwardk: Ah, just saw it in hackage. Thanks
10:06:07 <edwardk> copumpkin: i got some email from you just now
10:06:23 <edwardk> oh you cc'd the cafe
10:06:41 <copumpkin> oh yeah
10:08:06 <edwardk> you might want to email ravi and ask what gives with the mailing list though
10:25:58 <camio> Anyone know how to set the windows icon for an executable generated with ghc?
10:26:55 <twanvl> I believe you need to link the program with a resource file
10:35:04 <ezyang> The failure ring of packages is making me feel very dumb about typeclass packaging.
10:35:09 <copumpkin> :o
10:38:05 <ezyang> specifically, where is the applicative instance for Either
10:40:00 <Saizan_> ?instances-importing Control.Applicative Applicative
10:40:02 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
10:40:22 <Saizan_> maybe nowhere :)
10:40:26 <ezyang> hoo, that's a nice command
10:40:29 <ezyang> Ick
10:41:41 <ezyang> Ok, so should I: 1. cleverly skirt around the need for applicative in my article, or 2. hack in the applicative instance for Either and hope that someone adds it by publish time?
10:42:18 <ezyang> The latter bit of (2) seems unlikely given that http://hackage.haskell.org/trac/ghc/ticket/2316 has been open for 2 years now...
10:42:30 <ezyang> ahh orphan instances :-(
10:43:02 <copumpkin> > fix f
10:43:04 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:43:04 <lambdabot>    `SimpleReflect.FromExpr ...
10:43:08 <copumpkin> > fix f :: Expr
10:43:10 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
10:44:21 <monochrom> > fix (\x -> if x==0 then 0 else f (x-1)) a :: Expr
10:44:35 <lambdabot>   No instance for (GHC.Num.Num
10:44:35 <lambdabot>                     (SimpleReflect.Expr -> Sim...
10:45:08 <therp> hi .*
10:45:13 <monochrom> > fix (\f x -> if x==0 then 0 else f (x-1)) a :: Expr
10:45:17 <lambdabot>   mueval-core: Time limit exceeded
10:45:42 <therp> does cabal have a command to uninstall packages?
10:45:47 <ezyang> I guess 3. is newtype wrap with deriving, and define the orphan instance for that.
10:45:54 <therp> (in the context of cabal install and ~/.cabal/*)
10:45:58 <ezyang> therp: You can hide them
10:46:01 <ezyang> using ghc-pkg hide
10:46:23 <therp> ezyang: hm no, I want to delete them cleanly. I want to switch to my distros version of xomnad
10:46:24 <monochrom> I think you just ghc-pkg unregister then manually delete files.
10:46:26 <Philonous> or use ghc-pkg unregister, that's not cabal, though
10:46:47 <ezyang> therp: Aw! Sadface!
10:46:57 <therp> with ghc-pkg unregister, there would be leftovers in ~/.cabal/bin which is in my $PATH
10:46:59 <ezyang> Not so long ago I switched away from my distro's xmonad
10:47:33 <therp> ezyang: I don't see a reason to stay with the dev version.. all my patches are in 0.9
10:50:53 <ezyang> ?
10:53:45 <ezyang> Hm, does anyone define a version of Either that doesn't suck, i.e. have missing typeclasses?
10:53:48 <egregor> hi, why the website is blocked to brazil?
10:54:08 <Heffalump> what website?
10:54:09 <egregor> at least it seems, (i can access is via google translate ...)
10:54:22 <egregor> what... www.haskell.org
10:54:45 <Heffalump> I'd be very surprised if it was blocked to Brazil deliberately.
10:54:58 <Heffalump> unless the Brazilian government is doing it, anyway :-)
10:55:22 <egregor> maybe, they are fucking communists
10:56:04 <egregor> and it has been some days already... ]
10:56:05 <egregor> =/
10:56:19 <Heffalump> can you do any more to diagnose the problem? e.g. can you ping the server.
10:56:49 <b_jonas> which website?
10:57:00 <b_jonas> oh, haskell.org
10:59:49 <egregor> 100% loss...
11:00:15 <koeien37> try traceroute?
11:01:09 <int-e> heh. why is www.haskell.org's CNAME bugs.haskell.org?
11:02:58 <egregor> hey, download page i can enter lol
11:04:03 <BrazilGovernment> egregor: please take a seat over here
11:05:20 <copumpkin> lol
11:07:34 <egregor> gotta go, thanks
11:16:46 <|fft|> Does parsec integer eat all whitespaces after the number according to haskellDef  rule?
11:17:19 <ezyang> ya
11:17:28 <ezyang> (I got bitten by this.)
11:17:33 <|fft|> me too)
11:19:40 <Stalafin> trigonometry in haskell is working in rads by standard... amirite/
11:19:42 <Stalafin> ?
11:20:36 <ezyang> I'd guess so, although the docs are not terribly clear
11:20:40 <ezyang> > sin 3.14
11:20:41 <lambdabot>   1.5926529164868282e-3
11:20:55 <ezyang> yep
11:21:00 <copumpkin> Stalafin: that's pretty standard, yeah
11:21:59 <kmc> > sin pi
11:22:00 <lambdabot>   1.2246467991473532e-16
11:22:05 <kmc> > sin pi :: CReal
11:22:05 <lambdabot>   0.0
11:22:31 <kmc> > cos pi :: CReal
11:22:32 <lambdabot>   -1.0
11:22:45 <Stalafin> creal?
11:22:56 <mejja> > sin 1e20
11:22:58 <lambdabot>   -0.6452512852657808
11:23:04 <copumpkin> Stalafin: computable reals
11:23:15 <Stalafin> difference to double?
11:23:21 <copumpkin> unfortunate name given the CInt/CDouble convention
11:23:28 <copumpkin> Stalafin: it's exact
11:23:29 <kmc> copumpkin, yeah, that confused me for a long time
11:23:41 <copumpkin> but unfortunately Real was stolen by a typeclass
11:23:48 <copumpkin> another unfortunate choice
11:23:59 <kmc> copumpkin, and pedantic people would complain that it's not all reals ;)
11:24:04 <ezyang> sigh typeclasses
11:24:04 <ray> but almost all reals are uncomputable
11:24:12 <kmc> then again we don't call (->) the type constructor of computable functions
11:24:13 <copumpkin> ray: what percentage?
11:24:19 <ray> almost all
11:24:21 <kmc> hehe
11:24:24 <ray> uncountably many
11:24:29 <copumpkin> 100%, that's what percentage
11:24:37 <copumpkin> !
11:24:38 <kmc> almost all reals are totally bogus
11:24:40 <b_jonas> almost 100%
11:24:50 <ray> if you accept the dubious premise that you can use a percentage, 100% is the only one you can use
11:25:01 <copumpkin> hell yeah
11:26:05 <kmc> ray, it's non-dubious to say that the uncomputable reals have measure 1, isn't it?
11:26:26 * hackagebot upload: yst 0.2.3 - Builds a static website from templates and data in YAML or  CSV files. (JohnMacFarlane)
11:27:39 <Stalafin> just curious... is smth like the law of cosines implemented in any sort of math lib, or is it so simple ppl are expected to type it by hand?
11:27:41 <Stalafin> :)
11:28:43 <Stalafin> i mean... it's cool; now i am learning how to write my own function :D
11:29:35 <kmc> Stalafin, each CReal is a function that provides a rational approximation of the number to any desired accuracy
11:30:22 <ezyang> That sort of calculation isn't really computer's forte, imo.
11:30:34 <ray> kmc: which measure?
11:30:47 <kmc> ray, hmm, don't know
11:30:52 <ray> CReals don't tend to be exactly efficient
11:30:57 <kmc> so CReals are exact, unlike Double, but due to this higher-order representation, they get slower as you compose them
11:31:13 <Stalafin> anyone ever using creal in high performance computing?
11:31:15 <b_jonas> more importantly you can't compare them
11:31:20 <kmc> Stalafin, extremely doubtful
11:31:21 <Stalafin> all i hear about is double precision
11:31:36 <kmc> people might use arbitrary precision rational numbers
11:31:42 <kmc> or extended precision floating point
11:31:46 <b_jonas> yep
11:31:52 <ray> floats are the fastest and least accurate
11:31:54 <kmc> ppc has a 128-bit float type
11:32:01 <ray> if you take accurate to mean accurately acting like real numbers
11:32:25 <b_jonas> or even computer-algebra software like mathematica that tries to do arbitraty precision computations in the smart way
11:33:06 <kmc> yeah, computers are bad at working with real numbers.  that's because "real" numbers are a ridiculous unrealistic concept
11:33:40 <kmc> it's not surprising that real numbers can't be implemented in the real world
11:35:32 <Stalafin> i allow myself to divert the attention to a noob question :p --> when i define a function, is it necessary to always provide a defintion as in # lucky :: (Integral a) => a -> String  (example from lyah)
11:35:52 <burp> x86 has quad precision too?
11:36:10 <kmc> Stalafin, you mean the type signature?
11:36:18 <kmc> it is usually not necessary to give a type signature
11:36:22 <kmc> it is frequently a good idea
11:36:28 <kmc> it's machine checkable documentation
11:36:37 <ray> they're only called real as opposed to that much more outlandish and obviously silly concept of letting certain operations be defined
11:36:42 <kmc> and it will allow the type checker to provide better error messages
11:37:27 <b_jonas> afreed with kmc about better error messages
11:37:42 <burp> it's sad ghc has no quad precision float
11:37:54 <kmc> not only for errors in that function but also in functions that use it
11:38:00 <Heffalump> it just has machine floats
11:38:14 <Stalafin> kmc: i haven't seen another way of creating a function yet... is it something along the lines of SML?
11:38:24 <Heffalump> x86 only has 80 bit floats, and that only internally, right?
11:38:42 <kmc> Stalafin, there is a lambda syntax, which is used to create anonymous functions
11:38:58 <kmc> > (\x -> x + 3) 7
11:38:59 <lambdabot>   10
11:39:20 <kmc> however we also have shorthand for partially applying an operator:
11:39:22 <kmc> > (+3) 7
11:39:23 <lambdabot>   10
11:39:37 <b_jonas> actually no
11:39:57 <kmc> anyway, if you are creating a named function
11:40:02 <kmc> you still have the option whether to give a type signature
11:40:17 <kmc> > let f x = x + 3 in f 7
11:40:18 <lambdabot>   10
11:40:22 <kmc> > let f :: Double -> Double; f x = x + 3 in f 7
11:40:23 <lambdabot>   10.0
11:40:28 <ray> or more accurately, the "real" numbers are the numbers that correspond to the prejudices of analysts
11:40:32 <kmc> note that in the first case, the type defaulted to Int
11:40:42 <kmc> this defaulting happens late
11:40:59 <kmc> locally f will still have the polymorphic type (Num a) => a -> a
11:41:21 <tensorpudding> if you turn on warnings, you will get warned every time a type defaulting occurs....
11:41:44 <koeien37> isn't it defaulting to Integer ?
11:41:50 <kmc> hmm probably
11:43:05 <_Jedai_> Well, it will only default if the monomorphism restriction is in action and then its type will depend on the default list (which is not the same between GHCi and GHC I believe)
11:43:30 <kmc> :t read . show
11:43:31 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
11:44:13 <kmc> :t fromInteger . toInteger
11:44:14 <lambdabot> forall a a1. (Num a, Integral a1) => a1 -> a
11:44:17 <kmc> :t toInteger . fromInteger
11:44:18 <lambdabot> Integer -> Integer
11:44:33 <kmc> > toInteger . fromInteger $ 7
11:44:34 <lambdabot>   7
11:45:11 <kmc> how does it decide which Integral type to use in that case?
11:45:36 <b_jonas> defaulting
11:45:48 <kmc> :(
11:46:04 <Stalafin> kmc: thanks kmc, that helped :)
11:46:40 <kmc> b_jonas, yeah, it fails with "default ()"
11:54:15 <Stalafin> aaaaaand, another question.... say in my script i have defined a variable 'alpha'; now i write a function, in where i have another variable called 'alpha', too... do they in any way interact with each other? so, is the 'alpha' in the context of the function the same alpha as in context with my script?
11:54:58 <Heffalump> fairly standard scoping rules apply
11:55:03 <Heffalump> so the innermost alpha 'wins'
11:55:17 <Heffalump> so no, to answer your question precisely.
11:55:41 <Stalafin> cool, so i don't have to give the two vars different names? that would be great!
11:56:23 <Heffalump> you may well get a warning if running with -Wall, but personally I think that warning is misguided
11:56:40 <koeien37> I disagree, i think shadowing is to be avoided
11:57:06 <hopthrisC> somebody willing to help me with my homework?
11:57:16 <hopthrisC> i have given: data State s a = St (s -> (a,s))
11:57:40 <hopthrisC> and i have to write an "extraction function" with the signature: extract :: (Eq a, Show a) => (State (Table s) a) -> a
11:57:51 <hopthrisC> i have come up with; extract (St f) = fst $ f []
11:58:00 <hopthrisC> but that strikes me as somewhat odd...
11:58:09 <hopthrisC> is there a better way to implement this?
11:58:16 <koeien37> that is somewhat odd, yes
11:58:31 <koeien37> what is Table s ?
11:58:54 <shachaf> hopthrisC: Normally, to turn State t a into a, you need to provide some value of type t (as in runState).
11:58:57 <hopthrisC> koeien37: simply [s]
11:59:20 <Botje> hopthrisC: then your definition is correct
11:59:21 <koeien37> in that case, yours is the only definition without using _|_. but i agree that the question is strange
11:59:38 <Botje> hopthrisC: although it's a bit weird that you can't specify a starting state.
11:59:38 <shachaf> hopthrisC: If you're always using [], there is perhaps not much point in using State in the first place.
12:00:16 <koeien37> Botje: yeah. no explicit starting state, and the class constraints strike me as weird
12:00:17 <hopthrisC> don't get me started on the specifications... this course has been a disaster from the beginning
12:00:38 <b_jonas> ?
12:00:56 <hopthrisC> i just spent 2 hours on debugging this mess to get even this far
12:01:09 <koeien37> debugging the question?
12:01:25 <hopthrisC> debugging the specifications to this exercise, yes
12:01:57 <hopthrisC> at first it looks very much like the monad chapter in the gentle introduction, but then it completely loses it's coherence
12:02:13 <koeien37> State s is a monad, yeah
12:02:50 <hopthrisC> for the "extraction function" there is only given the signature. nothing else
12:03:07 <koeien37> well, yours is the only definition that makes sense
12:03:08 <hopthrisC> so at first i thought it should be something like get in the State Monad
12:03:19 <koeien37> it's more like runState
12:03:36 <koeien37> get is of type State s s
12:04:51 <hopthrisC> this all has me so confused :(
12:05:18 <hopthrisC> i'd show you something funny, but the specifications are in german
12:05:25 <koeien37> I can read german
12:06:46 <hopthrisC> koeien37: shucks! they corrected the spec
12:06:48 <Veinor> I have the greatest name for a project.
12:06:51 <Veinor> Remember the Monad
12:08:22 <hopthrisC> they actually put "a^n == (a^(floor(n/2)))" in the specs
12:09:55 <Botje> *blink*
12:10:20 <mauke> solution: a = 1 or n = 0
12:10:58 <Gracenotes> I suppose that's true.. if you multiply the RHS by itself and possibly a
12:11:10 <Gracenotes> and use div
12:11:12 <koeien37> sounds like the algorithm for computing a^n
12:11:33 <hopthrisC> it should have been a hint on how to implment fast exponentiation
12:11:40 <hopthrisC> (exponentiation my squaring)
12:11:57 <koeien37> a^n = (a^(div n 2))^2 * (a^(mod n 2))
12:12:35 <hopthrisC> that should actually have read "a^n == (a^(div n 2))^2 * a if a is odd"
12:13:51 <b_jonas> what kind of course is this?
12:14:13 <hopthrisC> "functional programming", computer sciences, 5th semester
12:14:46 <mauke> btw, you misspelt hpotsirhC
12:14:57 <monochrom> Students should be taught how to write specifications. And teachers more so.
12:15:06 <hopthrisC> mauke: you fell into the trap, congrats
12:15:28 <Gracenotes> `D
12:15:36 <Gracenotes> I mean, D:
12:15:44 <Gracenotes> damn misfunctional colons. should get that checked out.
12:15:50 <hopthrisC> this time it was not as bad: they just forgot a couple of parens...
12:15:58 <mauke> what trap?
12:16:23 * SamB_XP covers the trap gate with more snow
12:16:33 <hopthrisC> mauke: the trap for nitpickers like you that think i wanted to spell my name backwards -- which i didn't
12:16:39 * monochrom provides snow from Toronto
12:16:52 <HaskellLove> let a = [5]      (5:_) == a      Why does the second thing give me error when i try to match a? isnt _ for pattern matching?
12:17:01 <hopthrisC> mauke: you can call me hop, though ;)
12:17:04 <koeien37> == is not a pattern match
12:17:11 <koeien37> (==) is just a function
12:17:16 <Gracenotes> -_-
12:17:49 <mauke> so you're the hop'th risc
12:18:02 <hopthrisC> :)
12:19:06 <McManiaC> waitForTermination = let loop = loop in finally loop $ return ()
12:19:11 <McManiaC> why doesnt this work? ^^
12:19:32 <monochrom> why should it work? can you prove it formally?
12:19:44 <Botje> McManiaC: your name is not Alan Turing. sorry.
12:19:54 <mauke> define "work"
12:20:10 <McManiaC> main = waitForTermination >> putStrLn "foo"
12:20:16 <mauke> also, isn't (`finally` return ()) a no-op?
12:21:00 <monochrom> He doesn't want to define work or prove it.
12:21:36 <McManiaC> I want to run something after main gets terminated
12:21:36 <Gracenotes> McManiaC: I'm guessing it compiles and runs, so what is the problem?
12:21:39 <b_jonas> mauke: I think it is
12:21:53 <copumpkin> McManiaC: o.O
12:22:02 <mauke> McManiaC: I don't think that makes sense
12:22:06 <McManiaC> eeehhh
12:22:06 <Gracenotes> well, you can do that with >>
12:22:11 <McManiaC> forgive, kinda hangover :>
12:22:16 <McManiaC> *me
12:22:32 <monochrom> OK then it's best to just delete everything.
12:22:34 <McManiaC> actually I want to run something after a SIGTERM (on unix)
12:22:42 <McManiaC> ^^
12:22:42 <copumpkin> then add a handler
12:22:47 <mauke> then you need a signal handler
12:22:58 <copumpkin> @hackage posix
12:22:58 <lambdabot> http://hackage.haskell.org/package/posix
12:23:27 <copumpkin> meh
12:23:30 <McManiaC> is there no portable way?
12:23:40 <mauke> posix is portable
12:24:03 <Gracenotes> http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.4.0.0/System-Posix-Signals.html#4
12:24:11 <copumpkin> oh, of course System.Posix would live in a package called unix
12:24:16 <monochrom> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2951 second program is an example of signal handler. I do SIGUSR1 but you can change it to SIGTERM.
12:24:50 <mauke> I wonder why System.Posix.Signals provides both Signal and CInt
12:25:00 <mauke> and why people consistently use the "wrong" one
12:25:25 <Gracenotes> speaking of Unix, http://www.ioccc.org/1987/korn.c
12:26:16 <monochrom> I still don't understand what korn.c does. I don't know that "unix" is a predefined thingie.
12:26:17 <Gracenotes> recently figured out. gcc -E helps a bit with it -.-
12:26:49 <tensorpudding> how do you determine if someone is using unix anyway
12:26:57 <Gracenotes> mm... in nowadays conventions, I'm guessing it should be uppercase.
12:27:25 <mauke> monochrom: info cpp System-spec
12:27:37 <mauke> Gracenotes: it should be __unix__ or __unix
12:27:45 <monochrom> Gosh, so it is predefined.
12:28:02 <Gracenotes> ah. fair enough.
12:28:32 <mauke> cpp -dM /dev/null
12:29:38 <copumpkin> :t map Cont
12:29:39 <lambdabot> forall a r. [(a -> r) -> r] -> [Cont r a]
12:29:50 <Gracenotes> mauke: that's useful. I spy with my little eye: #define __unix__ 1, #define __linux 1, #define __unix 1, #define __linux__ 1, #define __gnu_linux__ 1, #define unix 1, #define linux 1
12:29:50 <copumpkin> :t sequence . map Cont
12:29:51 <lambdabot> forall a r. [(a -> r) -> r] -> Cont r [a]
12:30:31 <mauke> -ansi gets rid of the bare names
12:30:38 <mauke> (I also have #define i386 1 here)
12:31:35 <RayNbow> copumpkin: it took me a while to understand Cale's nest function
12:32:14 <copumpkin> RayNbow: it's fun :) I was just hoping to draw some questions on it by writing parts of it in here ;)
12:32:22 <increpare> ooh nest function?
12:32:23 <lambdabot> increpare: You have 1 new message. '/msg lambdabot @messages' to read it.
12:32:28 <koeien37> I missed something?
12:32:43 <copumpkin> this trick: http://www.haskell.org/pipermail/haskell-cafe/2008-February/038963.html
12:34:14 <koeien37> ah yes
12:34:16 <koeien37> i see it
12:35:20 <koeien37> i'd make it pointfree though
12:35:32 <koeien37> not that i would come up with this trick :P
12:36:26 <copumpkin> the signature of withCString is a hint to go looking at Cont
12:37:21 <monochrom> Generally all of the with* functions. Even Control.Exception.bracket
12:37:28 <copumpkin> yeah
12:38:27 <monochrom> What happens is that someone has already written the mess inside >>= so you may as well promote code reuse.
12:38:50 <monochrom> Save the planet! Support code reuse!
12:39:29 <b_jonas> oh
12:39:39 <copumpkin> @hoogle bracket
12:39:39 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:39:39 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:39:39 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
12:39:57 <HaskellLove> What am I doing wrong? I get type errors but i dont get it why. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15456#a15456
12:40:29 <b_jonas> HaskellLove: paste the errors you get too so we don't have to try it ourselves
12:40:37 <koeien37> maybe precedence of ++ and (:), but what's the error
12:40:58 <mauke> useless use of (x:xs)
12:41:15 <HaskellLove> I want my function to do this: given a start number n, a limit number s, and I start with an empty list. Generate primes untill the sum of the acumulating list becomes bigger then s
12:41:40 <copumpkin> sounds like a mapAccum
12:41:48 <copumpkin> or possibly just a zip with a scan
12:41:52 <koeien37> head . dropWhile (<s) $ scanl (+) 0 primes
12:41:55 <koeien37> something like that
12:42:01 <koeien37> oh no
12:42:14 <HaskellLove> so, test 5 20 [0] should generate primes starting from 5 untill the sum reaches 20, that is less then 20
12:42:24 <monochrom> > [0] ++ (1:[2]) : [3,4]
12:42:25 <lambdabot>   No instance for (GHC.Num.Num [t])
12:42:26 <lambdabot>    arising from the literal `0' at <inter...
12:42:35 <monochrom> You need more parentheses.
12:43:00 <HaskellLove> b_jonas http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15457#a15457
12:43:00 <copumpkin> :t mapAccumL
12:43:02 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:43:16 <monochrom> Oh wait, it is nonsense, so is [n] ++ (x:xs) : test (getNextPrime n) s ([n]++(x:xs))
12:44:25 <koeien37> :t \s -> head . dropWhile ((<s) . fst) . mapAccumL (\acc x -> (acc + x, x)) 0
12:44:27 <lambdabot>     Couldn't match expected type `[(a, b)]'
12:44:27 <lambdabot>            against inferred type `(x, [x])'
12:44:27 <lambdabot>       Expected type: [x] -> [(a, b)]
12:44:39 <koeien37> oh. grmbl.
12:53:01 <b0fh_ua> Hi there! Can somebody please advice libraries to get free space on a mount point, and send an email message with some pre-defined template?
12:53:29 <b0fh_ua> if that template can be avaluated and some placeholders be replaced with data - that would be great
12:54:56 <HaskellLove> why nonsense monochrom? can you fix the code or it is wrong all the way?
12:54:56 <HugoDaniel> hi
12:55:06 <HugoDaniel> im currently working on a polygon mesh datatype for haskell
12:55:33 <increpare> how do I send messages with lambdabot?  does it do it automatically?
12:56:06 <copumpkin> increpare: use @tell nick message
12:56:10 <HaskellLove> HugoDaniel wow cool, can you show some code?
12:56:28 <copumpkin> HugoDaniel: you should model it after CGAL! I'd love to have some serious computational geometry in haskell
12:56:35 <copumpkin> CGAL - c++ = excellent
12:56:44 <increpare> @tell sinelaw ah that's very cool : )
12:56:45 <lambdabot> Consider it noted.
12:57:10 <|fft|> evalState is State s a -> s -> a         what function is for  State s a -> s -> s   i.e. returns final state ?
12:57:25 <mauke> @hoogle State s a -> s -> s
12:57:26 <lambdabot> Control.Monad.State.Lazy execState :: State s a -> s -> s
12:57:27 <lambdabot> Control.Monad.State.Strict execState :: State s a -> s -> s
12:57:27 <lambdabot> Control.Monad.State.Lazy evalState :: State s a -> s -> a
12:57:27 <Botje> execState
12:57:29 <koeien37> :t execState
12:57:29 <Botje> iirc :)
12:57:30 <lambdabot> forall s a. State s a -> s -> s
12:57:45 <koeien37> they are just fst . and snd . runState
12:57:49 <HugoDaniel> copumpkin: exactly, im ripping it off :D im using a slightly different mesh representation though ...
12:58:01 <copumpkin> HugoDaniel: awesome! I'm excited
12:58:02 <|fft|> hoogle ... haven't used it yet. ths
12:58:27 <HaskellLove> copumpkin can you give me example for the mapAccumulation thing, not much on hoogle about it
12:58:48 <HugoDaniel> im planing to release a 0.1 version around next week
12:59:05 <HaskellLove> HugoDaniel what are you working on
12:59:07 <egregor> haskell.org is blocked to me, at least in some specific ranges. though i can't get into the main site hackage and code.haskell are still available. its been this way for days.
13:00:05 <HugoDaniel> HaskellLove: ive finished the mesh representation structures yesterday, today im doing a wavefront obj importer/exporter
13:00:16 <shachaf> HaskellLove: Google has some examples, perhaps.
13:00:23 <copumpkin> HaskellLove: http://cale.yi.org/index.php/Fold_Diagrams is a decent description of the structure
13:01:07 <merijn> Sanity check: Monads are just a way to model things like sequential and alternative composition in mu-calculus/process algebra's (if that even makes sense to anyone)?
13:01:51 <copumpkin> merijn: hm, I'm not sure what any of that is, but monads can model composition in another category
13:02:12 <copumpkin> in fact, there are (at least) two categories you can build from any monad
13:02:18 <copumpkin> the one haskell uses most is called the kleisli one
13:02:28 <koeien37> :t (>=>)
13:02:30 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:03:31 <RayNbow> fish operator :)
13:04:13 <mauke> 5/ju=/st</ s6/ay4/in>/g :/hi2/ t3/o ;/sh9/ac1/ha5/fg
13:04:25 <koeien37> ... the hell?
13:04:56 <Botje> mauke++ # rainbow-colored warrior
13:07:33 <merijn> copumpkin: Sequential composition is just sequencing of two actions and alternative composition represents a branching between two possible operations. Which we use for modeling various possible behaviours of a system in class
13:08:04 <koeien37> @info Alternative
13:08:04 <lambdabot> Alternative
13:08:08 <increpare> hmm.  I changed some game code from using IO to using ST, and now my CPU usage goes gradually from 3% (the previous steady rate) up to 100% - my hunch is that, because I'm carrying ST data from frame to frame, that it's somehow computing the whole history each time, but I'm not sure how to show it...
13:08:23 <copumpkin> merijn: I guess monads can probably model them, but I wouldn't say "monads are just" that
13:08:40 <koeien37> merijn: I'm not entirely sure; maybe your example is less powerful than a monad
13:09:50 <merijn> koeien37: Yeah, I think that might be the case, but unless I start making some "necessary, but not sufficient" claims about them I have nowhere to start :p
13:11:33 <copumpkin> merijn: lucky for you, sigfpe just wrote another document on them
13:12:06 <merijn> copumpkin: This one you mean? http://blog.sigfpe.com/2009/12/where-do-monads-come-from.html
13:12:22 <copumpkin> nah, just now
13:12:24 <copumpkin> latest post
13:12:32 <copumpkin> literally a few minutes ago :)
13:12:44 <merijn> Ah.
13:12:56 * RayNbow just noticed sigfpe's tweet
13:13:17 <RayNbow> earlier today he already linked to a pdf on Twitter
13:13:47 <merijn> I was reading that one and most of it sounds suspiciously like a subset (or perhaps the entire set of) mu-calculus operations.
13:15:14 <copumpkin> Tree a = 1 + a + (Tree a)^2
13:19:00 <ziman> isn't that 1 + a * (Tree a)^2 ?
13:19:52 <koeien37> depends on if you have leaves with data or data at every branch point, but not at the leaves
13:20:23 <copumpkin> yeah, there are a few different tree representations
13:20:35 <RayNbow> ziman: in sigfpe's pdf on monads and grafting he uses data Tree a = Nil | Fork (Tree a) (Tree a) | Leaf a
13:20:50 <RayNbow> ( https://dl.dropbox.com/u/828035/Monads/monads.pdf )
13:21:30 <ziman> oh, i see
13:23:40 <copumpkin> I actually got that from ddarius' LtU post that sigfpe said inspired him
13:31:46 <jfhall> Does anyone know of a more efficient way to produce a list containing lists of duplicates. Right now I'm using `nub . filter ((<) 1 . length) $ map ((flip filter) xs . (==)) xs`
13:32:11 <jfhall> where xs is the initial list
13:32:19 <koeien37> "lists of duplicates"?
13:32:28 <monochrom> What is your full specification?
13:32:28 <koeien37> > group . sort $ [1,2,1,1,3,4,2]
13:32:30 <lambdabot>   [[1,1,1],[2,2],[3],[4]]
13:32:38 <jfhall> very nice
13:32:40 <jfhall> thank you
13:32:46 <skorpan> > nub . concat . group . sort $ [1,2,1,1,3,4,2]
13:32:47 <lambdabot>   [1,2,3,4]
13:32:54 <skorpan> hm, no
13:33:09 <koeien37> also (<) 1 is better written as (1<)
13:33:11 <skorpan> > nub . concat . filter ((>1) . length) . group . sort $ [1,2,1,1,3,4,2]
13:33:12 <lambdabot>   [1,2]
13:33:24 <jfhall> nub . group $ [1,2,2,3,56,2,3,]
13:33:30 <jfhall> > nub . group $ [1,2,2,3,56,2,3,]
13:33:31 <lambdabot>   <no location info>: parse error on input `]'
13:33:35 <jfhall> > nub . group $ [1,2,2,3,56,2,3]
13:33:36 <lambdabot>   [[1],[2,2],[3],[56],[2]]
13:33:38 <HugoDaniel> anyone going to the hackaton ?
13:33:50 <HugoDaniel> in switzerland
13:34:01 <jfhall> thanks for the advice
13:35:04 <BMeph> Isn't that Tree form suitable for all of the Boom Hierarchy? :)
13:35:23 <BMeph> I.e., trees, lists, bags and sets
13:35:26 <BMeph> .
13:44:55 <jdavis> if I have "import Data.Map" in a trivial program, and I do "ghc -o map map.hs" then I get "(.text+0x283): undefined reference to `__stginit_containerszm0zi2zi0zi1_DataziMap_'". What could be causing that?
13:45:05 <koeien37> add --make
13:45:07 <|fft|> does compiled programs with ghc work faster then interpreted in ghci ?
13:45:08 <Botje> ghc --make map
13:45:14 <skorpan> yes |fft|
13:45:17 <mauke> jdavis: missing -package containers
13:45:18 <Botje> |fft|: yes, lots :)
13:45:30 <|fft|> should try to )
13:45:31 <koeien37> this is such a stupid error message :(
13:45:35 <Ircownik> #efifa.pl
13:45:37 <lunabot>  luna: A section must be enclosed in parentheses thus: ($efifa . pl ||)
13:45:44 <jdavis> Ok, thanks. That worked, but I'm not sure I understand why.
13:45:56 <koeien37> jdavis: it has to link in the containers package
13:46:01 <mauke> jdavis: because Data.Map is in some library that ghc doesn't use by default
13:46:11 <mauke> --make enables automatic dependency chasing
13:47:22 <jdavis> Ok, thank you.
13:48:01 <kmc> if you are running ghc from the command line you should pretty much always use --make
13:48:32 <mauke> while you're at it, -Wall -O2
13:48:33 <Cale> |fft|: even moreso if you turn on optimisations
13:49:49 <Giarome> Happy New Year to everybuddy!
13:50:12 <mauke> that was yesterday
13:50:25 * mux fixes up -rpath handling for FreeBSD with shared libs
13:50:34 <Botje> happy newyear to everybody except mauke! :)
13:50:44 <Giarome> i need an advice on my FirstWords program http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15459#a15459. Need someone to have a look on it, it gives me an empty list error
13:51:14 <mauke> Giarome: what if there's an empty line?
13:51:38 <maartenm> hello I have problems installing the bindings for devIL
13:51:50 <Giarome> mauke, i think line 10 covers this case
13:51:53 <Giarome> doesn'*t it?
13:51:56 <|fft|> I'd like not to see stack overflow now
13:51:57 <koeien37> no
13:52:04 <Botje> Giarome: "map head" << dangerous
13:52:10 <koeien37> head is partial
13:52:12 <maartenm> Configuring Codec-Image-DevIL-0.1... cabal: Missing dependency on a foreign library: * Missing C library: IL
13:52:12 <koeien37> > head []
13:52:14 <lambdabot>   * Exception: Prelude.head: empty list
13:52:25 <Giarome> i c
13:52:25 <maartenm> but;, I have all the devIL dll's
13:52:27 <mauke> Giarome: no, that covers the case of an empty input file
13:52:31 <Botje> Giarome: use listToMaybe and catMaybe instead
13:52:36 <mauke> Giarome: which is completely unncessary :-)
13:52:41 <maartenm> anyone ever installed devIL, or is there another image library I can use?
13:52:42 <Saizan>  maartenm: you need the headers too
13:52:47 <maartenm> ah
13:52:53 <Giarome> ahh ok thanks
13:53:05 <maartenm> ok thanks
13:53:35 <|fft|> twice less memory but very far from c++ :\
13:54:47 <HugoDaniel> maartenm: try stb-image
13:54:47 <HugoDaniel> http://hackage.haskell.org/package/stb-image
13:54:48 <HugoDaniel> here
13:55:05 <maartenm> I need encoding
13:55:17 <maartenm> making a buddhabrot fractal to hang in our bedroom
13:55:41 <maartenm> I downloaded the IL includes now
13:55:50 <maartenm> specified its location with --extra-include-dirs
13:55:51 <HugoDaniel> ah ok then :)
13:55:52 <lament_> it will look good on acid
13:55:54 <maartenm> and still get the error
13:56:23 <HugoDaniel> what format do you need to encode in ?
13:56:32 <maartenm> anything, doesn't matter
13:56:35 <maartenm> maybe not ppm
13:57:38 <Giarome> hey guys, is this correct? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15459#a15460 i don't get it
13:58:10 <Cale> |fft|: What does your program do?
13:59:10 <|fft|> Cale: recursion with memoization over 1000000 elements using Map as a State
13:59:42 <|fft|> Cale: In this case array is ok as well but I wanted to make more general case
13:59:54 <maartenm> hmm, I googled for it
13:59:58 <Cale> |fft|: okay. You could also give Data.MemoCombinators a try.
14:00:03 <maartenm> and apparently there's a guy here called conal
14:00:11 <maartenm> who had the exact same problem http://129.94.242.51/~dons/code/irc-logs/09.07.22
14:00:33 <maartenm> ,lambdabot message
14:00:34 <lunabot>  luna: Not in scope: `lambdabot'
14:00:38 <maartenm> how do you do that again
14:00:56 <Stalafin> when do i have to set a class constraint for a function, and when do i have not to....?
14:00:59 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/Data-MemoCombinators.html
14:01:10 <|fft|> Cale: ok. I'll try
14:01:41 <Cale> Stalafin: You have to have a class constraint for polymorphic functions that need to know that values of the type over which they're polymorphic support certain operations
14:01:59 <dibblego> Stalafin, consider the sort function; that can't run on lists of any values right?
14:02:07 <Stalafin> dibblego: yeah, i guess so
14:02:32 <dibblego> so then it needs Ord constraint
14:03:24 <Stalafin> i mean... i have a function which is just an equation... it's supposed to take 3 floats and spit out a float... why would i need a constraint?
14:03:35 <koeien37> then? never
14:03:40 <koeien37> that function is monomorphic
14:03:41 <Cale> Stalafin: If it's monomorphic, then it doesn't need a constraint
14:03:41 <copumpkin> it can be more general than Floats
14:03:57 <Cale> The purpose of typeclasses is to limit the set of types over which type variables range.
14:03:59 <copumpkin> Stalafin: you can make it work on floats and doubles simultaneously, for example
14:04:16 <koeien37> you might be able to write f :: RealFrac a => a -> a -> a
14:04:21 <Cale> So if there are no type variables in the type, it shouldn't have any typeclass constraints.
14:05:11 <Stalafin> k... thing is... i defined it like this: float -> float -> float -> float.. ghci didn't like that... so i removed all of that, loaded it, and now ghci tells me (Floating a) => a -> a -> a -> a
14:05:13 <Stalafin> this confuses me
14:05:23 <Cale> Stalafin: It's case sensitive
14:05:29 <Cale> float means the same thing as a
14:05:39 <Cale> You want Float
14:05:41 <koeien37> Float /= float.
14:05:47 <Stalafin> oO
14:05:57 <koeien37> all types start with a capital letter
14:06:06 <Cale> Any type level identifier which starts with a lowercase letter is a type variable
14:06:06 <Stalafin> so it should have worked if i had said Float -> Float -> Float -> Float?
14:06:07 <koeien37> otherwise, it means a type variable
14:06:11 <Cale> yes
14:06:12 <Stalafin> oh
14:06:13 <koeien37> Stalafin: yes
14:06:15 <Stalafin> :D
14:06:20 * Stalafin failed epicly
14:06:22 <Stalafin> thanks lads
14:06:34 <jlouis> and learned something in the proces!
14:06:36 <copumpkin> Stalafin: I'd still follow ghci's suggestion though :)
14:06:39 <Giarome> i got the solution http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15459#a15461 if anyone is interested
14:07:02 <Stalafin> copumpkin: yeah, i bet ghci does have a point :)
14:18:15 <limpac> why am i not allowed inn
14:18:42 <Cale> limpac: ?
14:18:53 <limpac> hi
14:19:41 <limpac> whats this room all about
14:19:49 <Cale> The Haskell programming language
14:20:17 <Stalafin> there is a topic set for this room, iirc :)
14:20:36 <limpac> is it like the usual
14:20:46 <Cale> The usual what?
14:20:49 <copumpkin> limpac: a bunch of people who are interested in a programming language talking about programming?
14:20:52 <copumpkin> limpac: yep
14:21:00 <Stalafin> Cale: he appears to be on dope oO
14:21:02 <Stalafin> :D
14:21:11 <Cale> Well, we also talk about mathematics quite a lot
14:21:23 <copumpkin> yeah, and philosophy :o
14:21:31 <Stalafin> Cale: yesterday people were talking about quake and half life
14:21:33 <Cale> Seemingly often enough :)
14:22:00 <Stalafin> they were posting youtube videos of some quake tournament, where people where jumping like crazy through some map
14:22:06 <Cale> heh
14:22:12 <limpac> Alright I am Interested and seems i love dis room
14:22:23 <kmc> ahaha
14:22:23 <Cale> limpac: Going to learn Haskell?
14:22:25 <|fft|> How should I add new modules to ghc to make it find automatically on import ?
14:22:26 <BMeph> Stalafin: Quake and Half-Life are programs. So, what's your point? ;)
14:22:28 <kmc> > fix ((0:) . scanl (+) 1)
14:22:30 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:22:36 <kmc> @. elite nixon
14:22:36 <lambdabot> I Can z3e C13ARlY NoW... +H4t i W4S \/\/ROng in No+ a(+INg M0R3 D3CiSiVE|y ANd mOr3 f0RthRIg|-|+Ly In De4LiNG \/\/i7h Wa73rGaTE.
14:23:05 <limpac> yes id like to
14:23:45 <Stalafin> BMeph: a person using a program in a way it was not designed to be used to show his skill in, well, hitting keyboard buttons at the right time... now i dont know :p
14:24:31 <Cale> You'll want to get GHC installed, and then find a tutorial that you like. You might try http://learnyouahaskell.com/ or http://book.realworldhaskell.org/read/
14:24:53 * BMeph introduces limpac to HaskellLove... >;)
14:25:19 <Giarome> this chatroom is GREAT!
14:25:39 <BMeph> Stalafin: ...isn't that a textbook definition of a Python programmer? :D
14:27:35 <gwern> wonder whether I should take an hour or 3 and update to 6.12
14:27:47 <koeien37> i would wait for HP
14:27:56 <Stalafin> BMeph: i dont know :-p two days ago i had to make a decision whether to learn python or haskell... people in this room convinced me to go for haskell.... i can give you an answer after i learn python :)
14:28:08 <limpac> Cale wuld u be a friend
14:28:12 <koeien37> oh, definitely Haskell. That is an easy choice
14:28:17 <Cale> How many months away is HP anyway?
14:28:29 <adu> HP=Haskell Platform?
14:28:32 <Cale> yeah
14:28:33 <koeien37> adu: yeah
14:28:34 <Stalafin> koeien37: the choice might be easy... the learning process, however, not :)
14:28:45 <koeien37> Stalafin: that is a good thing, isn't it? :)
14:28:48 <gwern> koeien37: well, I always intall everything as deps of something via cabal-install
14:28:49 <adu> oh, at first i thought hewletpackard
14:28:53 <gwern> so HP isn't really relevant
14:29:18 <adu> i would have used HsP
14:29:24 <Cale> gwern: On the other hand, apparently there are a lot of compatibility issues left to sort out.
14:29:37 <gwern> adu: too late. and that'd near-collide with HSP or Hasp
14:29:42 <adu> not to be confused with Haskell Server Pages
14:29:49 <adu> which is HSP, not HsP
14:29:51 <adu> lol
14:29:55 <limpac> Cale
14:29:57 <gwern> Cale: true; technically I ought to be helping out with those, but not sure I want to
14:31:43 <Cale> limpac: What is it?
14:34:14 <limpac> Cale wuld u be a friend
14:34:55 <mauke> limpac: excuse me wtf r u doin
14:35:01 <copumpkin> limpac: this is not the place to be looking for friends
14:35:04 <Cale> What does that entail? Do I have to help you move?
14:35:38 <Cale> Seems like sort of an odd question to me :)
14:35:59 <copumpkin> limpac: in this channel we're all automata with no feelings, except for the occasional feeling of hate.
14:36:09 <Cale> copumpkin: hahaha
14:36:27 <koeien37> the only exception being HaskellLove?
14:36:43 <copumpkin> no, even he's a hater, he just hasn't used haskell enough to realize it yet
14:37:02 <koeien37> @remember copumpkin limpac: in this channel we're all automata with no feelings, except for the occasional feeling of hate.
14:37:03 <lambdabot> It is forever etched in my memory.
14:37:07 <Cale> Nah, we're pretty friendly, but it doesn't make sense to just ask people out of the blue if they'll be your friend. Talk about interesting stuff and get into discussions instead.
14:38:16 <adu> interesting
14:38:23 <copumpkin> facebook friends, on the other hand!
14:38:31 <adu> I'll be a friend
14:38:45 <DigitalKiwi> somebody needs a friend? coincidence, I need money, I will be you friend for money
14:38:52 <adu> I'll just run when it comes to moving furniture
14:38:55 <araujo> limpac, we can't be your friend unless you have written a Monad tutorial at least
14:39:10 <copumpkin> damn, I haven't written one yet
14:39:12 <copumpkin> I'd better get on it
14:39:19 <koeien37> skip monads, straight to arrows
14:39:38 <copumpkin> skip arrows, straight to topoi
14:39:40 <sjanssen> yes, we have hardly any terrible arrow tutorials
14:39:41 <koeien37> "arrows are like $ANALOGY"
14:39:47 <adu> araujo: I've talked to ppl about Monads, does that count?
14:40:01 <eugenn> > sqrt (-1)
14:40:02 <lambdabot>   NaN
14:40:11 <koeien37> > sqrt (-1) :: Complex Double
14:40:11 <luite> adu: real people or haskell people?
14:40:12 <lambdabot>   (-0.0) :+ 1.0
14:40:22 <koeien37> ^ it defaults to Double
14:40:26 <gwern> @quote hate
14:40:26 <lambdabot> malsyned says: (. function) wins the prize for notation I'm least sure whether I love or hate.
14:40:30 <adu> luite: real people who find Haskell worth learning, but mostly real people
14:40:33 <gwern> @flish
14:40:49 <limpac> i am new in programming so this will take little time for me to rhyme
14:41:11 <burp> oh it's good you don't know much about imperative languages yet
14:41:14 <adu> limpac: rhyme?
14:41:42 <limpac> but i am really interested
14:41:50 <gwern> adu: it takes time to jam da lambdas
14:41:54 <limpac> in it
14:41:56 <adu> limpac: do you know what a String is?
14:42:13 <gwern> gotta know before you flow with the functions coming atcher every junction
14:42:29 <adu> limpac: do you know what an Integer is?
14:42:31 <Heffalump> is there a standard way to check that a cabal package hasn't missed out any modules in the list?
14:43:15 <adu> limpac: do you know what an invertible commutative monoid is?
14:43:16 * hackagebot upload: haskell-src-exts 1.5.2 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
14:43:24 <limpac> i am on its  tutorial now
14:44:39 <adu> > "Hello " ++ "world"
14:44:40 <lambdabot>   "Hello world"
14:45:41 <copumpkin> adu: zomg
14:45:53 <copumpkin> adu: surely you mean an invertible commutative unital associative magma?
14:45:56 <Cale> invertible monoid makes it sound like the monoid itself has an inverse
14:45:59 <luite> :t (++)
14:46:00 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:46:09 <adu> copumpkin: yes, of course!
14:46:17 <Cale> Better to say monoid with inverses, or more simply, group
14:46:33 <mux> yeah, commutative monoid is redundant
14:46:38 <copumpkin> nope
14:46:39 <koeien37> no it isn't?
14:46:43 <Cale> commutative monoid isn't.
14:46:51 <koeien37> groups are not always commutative (more commonly called "abelian")
14:46:51 <mux> ah. d'oh
14:46:53 <tensorpudding> monoids are not commutative
14:47:05 <tensorpudding> in general
14:47:06 <Cale> Not required to be, anyway :)
14:47:18 <adu> copumpkin: also known as an abgroup
14:47:23 <ray> associative monoid is redundant
14:47:35 <tensorpudding> most famouse non-abelian group might be the group of n x n matrices under matrix multiplication
14:47:36 * copumpkin is going to revolutionize computational universal algebra soon, when he finishes shaving yaks
14:47:40 <mux> yeah I mixed commutativity with associativity
14:47:47 <koeien37> tensorpudding: that is not a group
14:47:50 <tensorpudding> err, non-singular of course
14:47:50 <eugenn> :t (liftM2 ($))
14:47:51 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
14:47:55 <adu> copumpkin: Yaks?
14:48:04 <copumpkin> adu: yep, lots of fun
14:48:50 <tensorpudding> GL(n) is what i meant
14:48:55 <adu> ew
14:51:14 * Cale likes permutations on 3 elements.
14:51:52 <koeien37> GL(n, F) might be more familiar for somebody with some experience in linear algebra
14:52:03 <koeien37> but the symmetric groups are obviously also very important
14:52:38 <limpac> whats the function of de compiler/ string
14:52:45 <Cale> But there are only 6 such permutations, so it doesn't take long to get a pretty complete understanding of that group :)
14:53:04 <Cale> limpac: Sorry, could you rephrase that?
14:53:27 <tensorpudding> the symmetric groups are important too
14:53:46 <tensorpudding> but people who didn't learn much math may never have seen them
14:54:28 * koeien37 wonders if groups are taught at all in most CS curricula
14:54:29 <Cale> limpac: A compiler's job in general is to turn a program written in one language into a program written in another language. In most cases, to turn a program written in a high level language like Haskell into a program which is directly executable by your computer, written as a sequence of machine instructions.
14:54:53 <copumpkin> how does universal algebra deal with structures over more than one set? modules and vector spaces have two sets for example
14:55:10 <limpac> the compiler i.e. string compiles programme, what does that mean?
14:55:14 <yaxu> byorgey: by gum, your diagrams package has saved me some time
14:55:19 <luite> koeien37: not in the netherlands at least
14:55:27 <merijn> luite: Eh, yes they are
14:55:33 <mauke> limpac: what?
14:55:33 <koeien37> merijn: which uni / program?
14:55:36 <luite> merijn: which university?
14:55:39 <Cale> limpac: Where are you reading that?
14:55:46 <merijn> koeien37: Vrije Universiteit in Amsterdam
14:55:48 <luite> I obviously don't know all :p
14:56:05 <copumpkin> koeien37: they were covered briefly in a math requirement for my CS degree, but it wasn't terribly deep stuf
14:56:16 <gwern> Heffalump: try building from sdist?
14:56:19 <koeien37> i think they are not treated in Eindhoven, but i did a double major in math/cs so i might have skipped that course in the CS program
14:56:29 <luite> merijn: in which course? and how much?
14:57:16 <merijn> luite: Algebra en Discrete Wiskunde 1 & 2 6ECTS total in the bachelor. I also did Coding & Complexity which also covered them but in less depth
14:57:38 <koeien37> "coding & complexity", strange subjects to combine
14:57:53 <merijn> koeien37: Coding as in error correcting codes
14:58:10 <Heffalump> gwern: hmm. Unfortunately sdist doesn't work for darcs (not sure why, issues with the docs in the build system I think)
14:58:33 <koeien37> merijn: yes, that's what i meant
14:58:52 <merijn> What's so odd about the combination?
14:59:10 <koeien37> coding theory and complexity theory, what's the obvious relation I'm missing?
14:59:21 <koeien37> well, the general decoding problem is NP-hard, but other than that
14:59:24 <luite> merijn: are they really treated in depth, or is the definition just given somewhere? I might have heard the definition of a group in an undergrad cs course, but I'm pretty sure anything more in depth wasn't treated
14:59:54 <copumpkin> the IB has an option covering groups in high school
15:00:01 <luite> koeien37: possibly kolmogorov complexity and the like?
15:00:05 <merijn> koeien37: Complexity as in Kolmogorov complexity etc
15:00:09 <koeien37> ahw
15:00:33 <merijn> luite: Depends on how you define in depth?
15:00:35 <koeien37> i'd call that 'information theory'
15:00:43 <copumpkin> can anyone suggest a good intro to universal algebra?
15:00:47 <koeien37> but it's not important
15:01:09 <increpare> oh someone said covering groups
15:01:20 <increpare> oh wait
15:01:24 <increpare> "an option covering groups"
15:01:27 <increpare> : (
15:01:43 * increpare likes his covering spaces.
15:02:25 <luite> merijn: hm, don't know, at least some example groups, basic group theory like generators, subgroups?
15:02:46 <merijn> luite: It starts with arithmetic in Z modulo n, then continues to groups, then rings and bodies, polynomial rings, vectorspaces over a body and lastly finite bodies.
15:02:59 <copumpkin> body?
15:03:00 <copumpkin> fields?
15:03:03 <koeien37> field
15:03:07 <luite> fields yes :)
15:03:10 <copumpkin> :)
15:03:23 <luite> the dutch words is 'lichaam', which could be literally translated as 'body'
15:03:24 <koeien37> field = lichaam, which means body
15:03:33 <tensorpudding> that sounds like a group theory book
15:03:36 <merijn> My wikipedia translation trick of going from dutch to english told me it was body >.>
15:03:37 <koeien37> in German it's Koerper
15:03:59 <luite> merijn: ah I'm pretty sure that my undergrad at utwente didn't cover those subjects
15:04:13 <tensorpudding> i heard that in german, the word for integer is Zahlen, which is where the notation Z for integers comes from
15:04:20 <koeien37> correct
15:04:22 <merijn> tensorpudding: True
15:04:27 <koeien37> Zahlen is plural
15:04:46 <tensorpudding> also, G_delta and F_sigma come from german
15:04:55 <tensorpudding> summe and durschnitt (sp?)
15:05:16 <DrTeggy> Actually, the word for integer would be "Ganze Zahlen"
15:05:16 <koeien37> probably durchschnitt
15:05:24 <merijn> luite: I'm rather pleased with the classes at the VU, if you go out of your way to pick the hard courses there is a decent combination of hacking and theory
15:05:29 <koeien37> Zahl = number, right?
15:05:33 <DrTeggy> Yes.
15:05:58 <koeien37> merijn: how much FP is taught?
15:06:07 <gwern> Heffalump: so build the docs and then do sdist?
15:06:14 <MyCatVerbs> (: ¿ʎlʇɔǝɹɹoɔ sʞɹoʍ sıɥʇ ʇou ɹo ɹǝɥʇǝɥʍ ǝɯ llǝʇ ǝuoʎuɐ uɐɔ
15:06:15 <merijn> The main part I find lacking is that there's no language theory or compiler courses. I've asked permission to do a course in compiler building at the UvA
15:06:23 <Heffalump> gwern: I don't know how :-)
15:06:26 <koeien37> MyCatVerbs: if by correctly you mean "inverted", then yes
15:06:47 <tensorpudding> then there are the obvious german phrases, nullstellansatz, gedankenproblem, entscheidungsproblem (which i think are all due to hilbert)
15:06:56 <MyCatVerbs> Oops, wrong channel. Thanks koeien37.
15:06:59 <merijn> koeien37: I had a class "Introduction to Theoretical Computer Science" which covers lambda calculus and some limited programming assignments in OCaml
15:07:17 <koeien37> I've noticed that Utrecht is the way to go for FP :)
15:07:17 <merijn> I think it's a mandatory bachelor course
15:07:23 <increpare> tensorpudding: then there's the french vocab of words if you go near algebraic geometry or topology
15:07:31 <koeien37> there is one course on functional programming in Eindhoven, I think it's 5 EC
15:07:39 <CalJohn> yes, i think Utrecht is a place to go for FP
15:07:41 <tensorpudding> yeah, i've seen the word etale bandied about
15:07:56 <luite> I'm at Utrecht now, but for some reason not in FP :p
15:07:59 <increpare> tensorpudding: etale faisceaux mmmm
15:08:28 <increpare> (faisceau étale / whatever)
15:08:30 <CalJohn> at my university the single "Theory of Computer Science" was just a (little) automata theory
15:08:44 <koeien37> due to Grothendieck, I presume?
15:08:49 <tensorpudding> probably
15:08:57 * koeien37 doesn't know much algebraic geometry
15:09:08 <tensorpudding> bourbaki would be behind some of the french influence in topology
15:10:15 <koeien37> for the dutch people here: there is a "Functional programming day" in Nijmegen next Friday
15:11:06 <merijn> koeien37: Nice, any link?
15:11:10 <koeien37> http://wiki.clean.cs.ru.nl/NL-FP_dag_2010
15:11:26 <increpare> koeien37: largely, yeah.  true about the bourbaki also
15:11:59 <limpac> what does the compiler do?
15:12:35 <koeien37> it converts programs in Haskell to programs in machine language, that your processor can execute, or it rejects your program because it's not valid Haskell (and says why)
15:13:42 <tensorpudding> the typechecking part is an important part of the compilation process, and probably the source of most compile errors i'd imagine
15:13:45 <limpac> thanks i got it
15:23:45 <adu> who here knows about Boomerang?
15:24:23 <DigitalKiwi> you throw them and they come back
15:24:32 <DigitalKiwi> what more is to know?
15:24:32 <BMeph> adu: Please define "knows about". ;)
15:24:39 <MyCatVerbs> Or they don't. Depends on whether you hit something. :)
15:24:40 <adu> hmm
15:24:57 <BMeph> adu: I've read part of the intro paper, but I haven't finished it. :)
15:26:01 <|fft|> The program crashes in runtime and complains about small stack. Options like +RTS -K512M -RTS  do not change the stack size. Why can it be ?
15:26:15 <adu> BMeph: same here, but I have some ideas I'd like to discuss
15:26:40 <Cale> |fft|: Perhaps your program is really pathologically using that much stack space?
15:27:09 <adu> I was wondering if anyone has done anything like that with haskell typeclasses
15:27:33 <|fft|> Cale: It crashes during 1 second. Too fast for such stack
15:27:44 <Cale> |fft|: Could you put it on hpaste?
15:27:51 <adu> i mean a Boomerang lens is basically a (class Lens a b)
15:28:50 <adu> is there anything like it in Applicative or anything?
15:29:48 <copumpkin> a lens? in the lenses, bananas and barbed wire sense?
15:30:05 <adu> copumpkin: a Boomerang "lens" is basically an invertible function
15:30:10 <copumpkin> ah
15:30:16 <BMeph> adu: You could be the first! After all, having probability monads didn't stop "Ominous" Dominus from re-inventing them... :)
15:30:32 <limpac> is gci  terminal designed for specifically for haskell
15:30:35 <adu> so (class Lens a b) would have to have 2 methods: (forward :: a -> b) and (backward :: b -> a)
15:30:46 <kmc> limpac, ghci?
15:31:02 <adu> Dominus?
15:31:03 <copumpkin> adu: why would you want a typeclass for that in haskell? data Lens a b = Lens (a -> b) (b -> a)
15:31:09 <limpac> yes ghc1
15:31:12 <copumpkin> instance Category Lens
15:31:15 <copumpkin> instance Arrow Lens
15:31:15 <adu> copumpkin: that works too
15:31:22 <BMeph> adu: "mjd" = Mark Jason Dominus
15:31:24 <kmc> limpac, yes
15:31:33 <adu> copumpkin: this is exactly why I wanted to discuss this
15:31:50 <DigitalKiwi> hehe, it would be hilarious if it was designed for python or some such ;DD
15:32:36 <adu> copumpkin: actually that works better, for example there are multiple functions from String -> Int, and the typeclass wouldn't account for that...
15:32:44 <copumpkin> :)
15:32:55 <copumpkin> adu: and you can compose them and it's even an ArrowApply!
15:32:55 <adu> copumpkin: you rock
15:33:08 <|fft|> Cale: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5708#a5708
15:33:21 <copumpkin> :)
15:33:24 * adu sets out to write Control.Lens
15:33:25 <kmc> limpac, ghci is a read-evaluate-print loop (REPL).  you type in Haskell expressions and it will evaluate them and print the result
15:33:51 <kmc> some people would call this an "interpreter", incorrectly i think
15:35:09 <Cale> |fft|: Ah, that's not quite the right way to apply the memo combinator
15:35:23 <Cale> |fft|: You want the recursive calls inside h to call the memoised version
15:35:47 <|fft|> Cale: I saw this in sample for fibonacci
15:35:47 <Cale> (just the first thing I see that's a problem)
15:36:25 <|fft|> Cale: by the way it worked until I added explicit type definition for h
15:36:27 <Cale> The fib example was a little different if you take a look at it again
15:37:18 <|fft|> Cale: Ah I see
15:37:53 <Cale> fib is defined by applying the Memo.integral function to fib', but fib' also calls fib
15:39:30 <|fft|> Cale: I have an idea - it places Integers in the heap and it was ok. But I still can't get why it complains Stack space overflow: current size 8388608 bytes despite having stack enlarge option
15:39:31 * hackagebot upload: restyle 0.1.0 - Convert between camel case and separated words style. (DanielFischer)
15:39:54 <Cale> Stack overflow doesn't mean what it means in strict evaluators.
15:40:11 <|fft|> Cale: What do you mean ?
15:41:28 <|fft|> Cale: Now I removed type definition and with heap it works again
15:41:29 <Cale> The stack basically consists of pattern matches (or primitive function applications) which are waiting for the thing being inspected to evaluate before they can match.
15:41:38 <Cale> hmm
15:41:57 <roconnor> when I do cabal install csv it dies with:
15:41:59 <roconnor> Registering csv-0.1.1...
15:42:00 <Cale> What's the inferred type?
15:42:01 <roconnor> Reading package info from "dist/installed-pkg-config" ... done.
15:42:02 <roconnor> csv-0.1.1: dependency parsec-2.1.0.1 doesn't exist (use --force to override)
15:42:12 <roconnor> but the dependency does exist when I do ghc-pkg list
15:42:16 <roconnor> what gives?
15:42:25 <|fft|> Cale: But I should notice the stack growing via process memory usage right?
15:42:48 <|fft|> Cale: 1 sec
15:43:08 <Cale> I think it'll probably be polymorphic?
15:43:18 <Cale> But that'll get defaulted to Integer
15:43:21 <Cale> (not Int)
15:45:34 * hackagebot upload: graphics-drawingcombinators 1.0.0 - A functional interface to 2D drawing in OpenGL (LukePalmer)
15:45:46 <|fft|> Cale: yes it's polymorphic. My realization with state got incorrect answers in particular cases. I've noticed that it was about Int overflow and changed the type  definition of h which worked correctly with Integers. And now I cannot run it because of overflow. And options seem to be not working or I misunderstood something.
15:45:47 <Cale> oh, interesting, there's an infinite loop in this
15:46:42 <|fft|> Cale: where is an infinite loop  ?
15:47:06 <copumpkin> roconnor: maybe it's registered but the files got lost? try --reinstall?
15:47:33 <Cale> one sec. I changed it to do the memoisation properly and got a <<loop>> runtime exception, which only happens if you try to evaluate the same expression while that expression is trying to evaluate
15:47:47 <Cale> I have a feeling that it has to do with the Int type
15:48:09 <|fft|> Cale: I got it )
15:48:33 <|fft|> Cale: h does not handles negative Ints which are about overflow
15:48:47 <roconnor> copumpkin: same
15:49:01 <Cale> |fft|: right.
15:49:25 <roconnor> copumpkin: is there a way to tell cabal install to keep the tmp directory?
15:49:33 <Cale> btw, Memo.arrayRange (1,10^6) or something is better.
15:49:54 <Cale> The memo table can get filled up with lots of useless large values if you don't limit it.
15:49:59 <|fft|> Cale: I'm new to this Module
15:50:14 <Cale> Well, it's mostly just for this special case
15:50:42 <Cale> The Collatz function is sort of funny, in that in some cases, the values rise for a long time
15:51:10 <Cale> and so if you memoise everything using Memo.integral, you end up adding lots of unlikely values to your memo table that you won't need.
15:51:59 <Cale> Btw, there are a few other things which are quite inefficient about this program. First of all, elemIndex is best to avoid if you can avoid it, and it's easy enough to do here.
15:52:37 <Cale> You can  zip (map h [1..n]) [1..n], and take the maximum of that
15:53:09 <|fft|> Cale: and it will be 2 list passes too
15:53:10 <Cale> Or, to write that another way,  [(h k, k) | k <- [1..n]]
15:53:26 <|fft|> |fft|: what's the difference?
15:53:37 <Cale> That's the same as the version with zip
15:53:45 <Cale> (basically)
15:54:24 <|fft|> Cale: I mean difference with elemIndex
15:54:45 <Cale> Well, the difference is that when you find the maximum pair, the pair already has the index in it.
15:54:56 <Cale> So you don't have to go looking through the list again.
15:55:24 <koeien37> :t \h n -> (h &&& id) [1..n]
15:55:26 <lambdabot> forall c t. (Num t, Enum t) => ([t] -> c) -> t -> (c, [t])
15:55:38 <koeien37> :t \h n -> map (h &&& id) [1..n]
15:55:40 <lambdabot> forall a c. (Num a, Enum a) => (a -> c) -> a -> [(c, a)]
15:55:54 <|fft|> Cale: Ah to skip 1 pass
15:56:09 <luqui> |fft|, Collatz might grow beyond 2^31, which would put it negative and get you into an infinite loop
15:56:19 <luqui> Int is not good enough, you need Integer
15:56:21 <Cale> luqui: yes, we discovered that :)
15:56:24 <luqui> ah
15:56:34 <Cale> luqui: In fact, ghc discovered it with <<loop>>
15:56:43 <Cale> in a properly memoised variant of that code :)
15:56:49 <luqui> nice :-)
15:57:54 <Stalafin> say in my test.hs function... if i define a simple equation (as a function) and a variable uses it, does the variable declaration have to be before or after the function declaration = does the hirarchy matter?
15:58:02 <koeien37> doesn't matter
15:58:05 <Stalafin> nice
15:58:09 <Stalafin> that's quite cool
15:58:39 <koeien37> it certainly is :) no forward declarations necessary
15:58:53 <Cale> Stalafin: The only place where order of declarations matters is where you have equations with various patterns for one function, or multiple guards. They're tried in order.
15:58:57 <koeien37> redefining is not possible, so x = 3 first, and later x = 4 is not possible
15:59:09 <kmc> indeed, you can have two definitions that depend on each other
15:59:09 <Stalafin> i bet i am hacking together the most ugly script imaginable in haskell :D i am gonna put it on here so people can call me names at some point
15:59:13 <koeien37> (you can shadow x, though)
15:59:18 <kmc> > let x = 'x':y; y = 'y':x in x
15:59:19 <lambdabot>   "xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy...
15:59:28 <roconnor> why does ghc-pkg say parsec isn't installed when ghc-pkg list says it is installed!
15:59:32 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
15:59:33 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
15:59:45 <Stalafin> woah
15:59:58 <Stalafin> what magic did kmc do there?
16:00:05 <koeien37> mutual recursion
16:00:07 <kmc> Stalafin, just recursion
16:00:13 <kmc> in Haskell, things other than functions can also be recursive
16:00:26 <koeien37> > let x = x + 1 in x -- loops
16:00:30 <copumpkin> > let x = 1:x in x
16:00:30 <lambdabot>   mueval-core: Time limit exceeded
16:00:31 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:00:35 <Stalafin> i don't understand, let x = 'x':y
16:00:39 <Stalafin> what is 'x' : y
16:00:45 <kmc> 'x' is a literal character
16:00:53 <kmc> (:) sticks it onto the head of a list
16:00:54 <koeien37> a list consisting of head 'x' and then the list y
16:00:55 <Cale> The string whose first character is 'x' and whose tail is y
16:00:57 <kmc> > 'x' : "foo"
16:00:58 <lambdabot>   "xfoo"
16:00:59 <Stalafin>  aaaaaah
16:01:01 <koeien37> > 1:[2,3]
16:01:02 <lambdabot>   [1,2,3]
16:01:11 <Stalafin> ok, of course :D
16:01:16 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
16:01:18 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:01:25 <copumpkin> > primes
16:01:26 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:01:29 <Stalafin> yayayaya, go away; i got it :D
16:01:30 <Cale> primes uses isPrime, isPrime uses primes
16:02:05 <Cale> But that initial 2 in the list of primes is necessary to get things started :)
16:02:09 <FunctorSalad> order does seem to matter with TH, sometimes
16:02:10 <luqui> Stalafin, recursion is when something uses itself.  a thing is a value.  %-)
16:02:11 <Stalafin> using recursion for the sake of using recursion :D
16:02:18 <koeien37> FunctorSalad: right, TH is different
16:02:25 <koeien37> google "recursion" sometime
16:02:46 <Cale> Well, not just for recursion's sake. This implementation of primes is actually pretty efficient compared to similarly naive things.
16:02:46 <SamB_XP> koeien: oh, yeah, I *love* that
16:02:52 <Stalafin> i do actually know what recursion is... still, it is magic to but for the simplest cases ^^
16:03:04 <Stalafin> to me*
16:03:27 <luqui> well i was joking, and koeien37 is referring to a joke Google made
16:03:34 <Cale> Because you're only testing each number n with *primes* p such that p*p <= n
16:03:36 <Berenlap> You're going to love corecursion :)
16:03:46 <Stalafin> haha, cool :D
16:03:49 <pantsman> heh
16:03:52 <pantsman> "Did you mean: recursion"
16:03:58 <kmc> it was quite depressing to read Joel Spolsky's opinion that recursion and pointers are advanced concepts beyond the grasp of average programmers
16:03:58 <Stalafin> pantsman: yeah ^^
16:04:16 <Cale> People have lots of silly opinions
16:04:20 <Botje> i think that's an observation, not an opinion
16:04:57 <SamB_XP> well, at least something that average programmers don't understand, depending on how you describe average
16:05:00 <Stalafin> well, at my uni those cs majors start their programming career with recursion :)
16:05:02 <Stalafin> using sml
16:05:08 <SamB_XP> er.
16:05:13 <SamB_XP> how you define programmers ;-P
16:05:18 <DrTeggy> Stalafin, what University would that be?
16:05:25 <Stalafin> jacobs uni
16:05:26 <Stalafin> in germany
16:05:29 <DrTeggy> Bremen?
16:05:31 <Stalafin> yeah
16:05:33 <DrTeggy> ok
16:05:40 <Stalafin> don't tell me you heard of it? oO
16:05:48 <DrTeggy> Of course I did.
16:05:59 <Stalafin> curious now... how come? and where?
16:06:04 <koeien37> yesterday DrTeggy was advertising for a PhD position in Germany :)
16:06:21 <Stalafin> germany is a fairly big country :p
16:06:22 <Cale> I contend that anyone smart enough to understand algorithms with mutation and loops is smart enough to understand recursion.
16:06:25 <DrTeggy> koeien37, yes -- and the position is still open ;-)
16:06:48 <Stalafin> so what's the connection between a PhD position, germany, and my uni? :D
16:07:04 <koeien37> somebody offering a PhD position in Germany is likely to know most of the universities in Germany?
16:07:11 <Cale> So maybe most people can't handle one of those two :)
16:07:19 <Giarome> http://cgi.ebay.de/ws/eBayISAPI.dll?ViewItem&Item=290386114872
16:07:26 <Stalafin> koeien37: indeed, however.... my uni opened in 2001
16:07:34 <Stalafin> so... not many people heard of it (yet :p )
16:07:48 <Berenlap> Cale: I certainly have greater problems understanding iteration and mutation than recursion
16:07:56 <Cale> Berenlap: Me too.
16:08:05 <koeien37> nowadays i think loops are confusing
16:08:08 <Giarome> i am in Dortmund
16:08:12 <Berenlap> And unlike recursion, the problem doesn't go away even if you understand it
16:08:33 <Cale> I occasionally have to translate simple imperative algorithms into clusters of mutually recursive Haskell functions to understand what's going on.
16:08:48 <Philonous> Cale: Surprisingly many CD students do not understand inductive proofs anymore. I would think they don't understand recursion, either (Though, admittedly, I doubt they truly grasp iteration )
16:09:05 <Giarome> lol
16:09:05 <Philonous> CS*
16:09:41 <Giarome> who wants to buy a notebook?
16:09:52 <Stalafin> is it the students or is it the way they are taught
16:10:01 <Giarome> it is both
16:10:11 <Giarome> and neither
16:10:17 <Stalafin> lower the standards to raise the grades ^^
16:10:19 <sshc> Giarome: how do you know?
16:10:34 <Giarome> i am a student
16:10:40 <Giarome> i can tell
16:10:43 <monochrom> He knows by selling notebooks.
16:10:43 <sshc> Giarome: and I hope you realize you just contradicted yourself
16:10:59 <Philonous> Stalafin: Inductive proofs where removed from schools curriculi. a few years ago.
16:11:20 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15110 -- I wrote up an example of the sort of thing I might do, though of course I normally wouldn't do it with this function :)
16:11:22 <Giarome> if i contradict myself i suss out everything
16:12:21 <koeien37> I saw this algorithm in a book, first they explain gcd(a, b) = gcd(b, a) = gcd(a, b-a). Then they go out of their way to derive this algorithm, when you are in fact, already finished
16:12:40 <Stalafin> Philonous: i know... i was majoring in math in school (heck, i guess it translates to a-levels in the us system)
16:13:03 <Stalafin> Philonous: thinking back, although it appeared frigging hard, the math was shit... at least compared to what i am used now :D
16:13:23 <koeien37> (of course, you note that gcd(x, 0) = x if x /= 0)
16:13:43 <Stalafin> used to*
16:14:15 <Cale> I think that gcd 0 0 ought to be 0
16:14:26 <koeien37> is there a reason for it?
16:14:32 <Giarome> not defined
16:14:35 <koeien37> i would think it is not defined
16:14:41 <Cale> If you view the term 'greatest' in terms of the divisibility lattice, then it makes sense.
16:15:14 <Berenlap> When I wrote this http://rosettacode.org/wiki/Midpoint_circle_algorithm#Haskell I was constantly looking for the actual definition of the algorithm, which I could only find an imperative version of. I was a bit painful...
16:15:31 <Cale> 0 is at the top of the lattice
16:15:37 <Cale> and 1 is at the bottom
16:15:50 <koeien37> so then you take the join of 0 and 0
16:16:03 <Cale> yeah
16:16:10 <koeien37> (or meet, i always mix those up)
16:16:31 <Cale> I guess it would be meet actually.
16:16:38 <Cale> er, no :)
16:16:54 <luqui> i have an easier time thinking in terms of lub and glb
16:16:54 <Cale> meet <-> intersection,  join <-> union
16:16:57 <luqui> vocab
16:17:18 <tensorpudding> cup and cap
16:17:44 <koeien37> sup & inf
16:17:46 <luqui> tensorpudding, and I suppose you talk about people talking italically..
16:18:14 <tensorpudding> luqui: what?
16:18:24 <koeien37> > gcd 0 0 -- does Haskella gree?
16:18:25 <lambdabot>   * Exception: Prelude.gcd: gcd 0 0 is undefined
16:18:29 <Cale> It does not :(
16:18:31 <luqui> tensorpudding, cup and cap are syntax
16:18:51 <tensorpudding> well, yes
16:18:55 <luqui> Haskella -- Haskell's wife
16:18:55 <tensorpudding> in the same sense + and * are
16:19:01 <Cale> Which is extra unfortunate because errors are so hard to catch.
16:19:13 <tensorpudding> @src gcd
16:19:14 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
16:19:14 <lambdabot> gcd x y = gcd' (abs x) (abs y)
16:19:14 <lambdabot>    where gcd' a 0  =  a
16:19:14 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
16:19:16 <koeien37> yeah, now that you see it, I agree with gcd 0 0 = 0
16:19:19 <tensorpudding> huh
16:19:23 <luqui> > gcd 0 4
16:19:23 <lambdabot>   4
16:19:27 <tensorpudding> that doesn't look so pretty as i thought
16:19:32 <koeien37> it's an extension of gcd x x = x, and gcd x 0 = x anyway
16:19:35 <luqui> eh just special case around the special case :-(
16:19:47 <Cale> They treat 0 0 as a special case rather than just leaving the code to do the obviously right thing ;)
16:20:20 <luqui> Cale, i'm glad we are all irritated by that.  that kind of thing drove me insane in the perl 6 design
16:20:32 <RayNbow> > lcm 0 0
16:20:34 <lambdabot>   0
16:20:47 <Cale> > lcm 1 1
16:20:49 <lambdabot>   1
16:21:01 <Cale> ^^ why isn't that an error too? ;)
16:21:02 <koeien37> well, you'd lose a * b / gcd a b = lcm a b
16:21:06 <luqui> > let gcd' a b = a*b/lcm a b in gcd' 0 0
16:21:07 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:21:07 <lambdabot>    `GHC.Real.Integral t'
16:21:07 <lambdabot>   ...
16:21:08 <RayNbow> > let gcd' a b = fromIntegral (a*b) / fromIntegral (lcm a b) in gcd' 0 0
16:21:09 <lambdabot>   NaN
16:21:31 <RayNbow> > let gcd' a b = (a*b) `div` (lcm a b) in gcd' 0 0
16:21:32 <lambdabot>   * Exception: divide by zero
16:21:43 <koeien37> if you see lcm x y as max { d in N : d|x, d|y }, it makes sense
16:21:56 <koeien37> that statement made no sense at all. excuse me
16:22:15 * bnijk_ burps koeien37
16:22:32 <bnijk_> somehow this feels
16:22:35 <bnijk_> inappropriate
16:23:02 <RayNbow> > let gcd' a b = (a*b) `div` (lcm a b) in gcd' 0 3
16:23:04 <lambdabot>   * Exception: divide by zero
16:23:33 <RayNbow> ah wait, that equation only holds for positive integers
16:25:48 <luqui> hackage is being really flaky recently
16:25:52 <Cale> Or if you're looking at subgroups of Z, say aZ and bZ, you have that the gcd of a and b gives you the generator of the smallest subgroup which contains both aZ and bZ
16:25:59 <luqui> not accepting uploads, so i have to bump the version and try again
16:26:18 <koeien37> well, the trivial group is generated by zero generators
16:26:49 <Cale> You might think of it as 0Z anyway
16:27:41 <RayNbow> gcd seems like a recurring topic... ( http://www.haskell.org/pipermail/haskell-cafe/2009-May/060788.html )
16:27:52 <Cale> The smallest subgroup containing both 0Z and 0Z is 0Z ;)
16:28:14 <|fft|> Cale: memoized version with Memo.integral works not much faster than with State
16:28:24 <HugoDaniel> i really dislike @
16:28:33 <HugoDaniel> f @y :(
16:28:37 <koeien37> yeah, we're lucky since Z is free on 1 generator, so its subgroups are special :)
16:28:43 <HugoDaniel> i guess its because i never understood it
16:29:23 <koeien37> > let f xs@(y:_) = y:xs in f [1]
16:29:24 <lambdabot>   [1,1]
16:29:25 <HugoDaniel> its harder than functors, applicative functors, monads, monoids, you name it...
16:29:26 <tensorpudding> > let f y@(x:xs) = y:xs in f [1,2,3,4]
16:29:27 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
16:29:39 <tensorpudding> > let f y@(x:xs) = y ++ xs in f [1,2,3,4]
16:29:41 <lambdabot>   [1,2,3,4,2,3,4]
16:29:53 <Cale> |fft|: but it's easier to write :)
16:29:58 <Zeiris> How production-ready is Data.Graph? Is it far more efficient and elegant than anything I could hope to write, or am I better off using my own graph implementation so I can optimize it later if need be?
16:30:25 <|fft|> Cale: Sure. I wanted to make sure that I understood State
16:30:45 <Cale> HugoDaniel: var@(pattern) just means to match against the pattern as usual, but to name the whole thing that it matches var
16:31:07 <SamB_XP> Zeiris: I prefer Data.Graph.Inductive, personally
16:31:11 <Cale> > let whole@(x:xs) = [1,2,3] in (whole, x, xs)
16:31:12 <lambdabot>   ([1,2,3],1,[2,3])
16:31:37 <Cale> Zeiris: I tend to use Data.Map
16:31:42 <HugoDaniel> ah, Cale, you made it easy :D
16:32:04 <Cale> Zeiris: Map Vertex (Set Vertex) and variations on it, tend to make good graph representations.
16:32:21 <Zeiris> Thank you.
16:32:33 <koeien37> for a dense graph, i'd use Array (Int,Int) Bool
16:32:48 <HugoDaniel> :)
16:33:05 <Cale> A dense graph that you didn't want to change or was small enough
16:37:24 <RayNbow> hmm, what does the notation a|b mean in http://www.haskell.org/pipermail/haskell-cafe/2009-May/060842.html ? b is a multiple of a?
16:37:36 <koeien37> that is standard, yes
16:37:53 * RayNbow hasn't encountered that notation before
16:38:48 <tensorpudding> it's standard mathematical notation
16:39:01 <hablutzel1> where is haskell being used? I live in Peru and the only known programming languages in enterprise environments are java, microsoft (.net, vfp), php
16:39:05 <hablutzel1> ???
16:39:29 <lament> ha ha ha vfp
16:39:30 <tommd> hablutzel1: You should probably look at haskell.org and find the "Haskell in Industry" link
16:39:55 <Cale> a | b means that there exists an integer k so that b = k*a
16:40:02 <hablutzel1> @lament well, it is still in production in a lot of places...
16:40:02 <lambdabot> Unknown command, try @list
16:40:10 <koeien37> so x|0 for any x, and 0|0.
16:40:20 <Cale> because you can always choose k = 0
16:40:20 <lament> hablutzel1: haskell is not a "mainstream-popular" language, you're unlikely to just randombly stumble upon a haskell job like you'd stumble upon a java job
16:40:39 <tommd> yes, you need to hunt Haskell jobs.
16:40:43 <hablutzel1> hahha
16:41:06 <RayNbow> tensorpudding: as a CS student I apparently haven't read enough math textbooks and papers :p
16:41:19 <tensorpudding> obviously not :P
16:41:30 <koeien37> nobody has
16:41:37 <tensorpudding> a book on number theory will cover a lot of that stuff
16:41:47 <tensorpudding> and i think that most CS people should be grounded in number theory
16:42:06 <shortcircuit> Berenlap: If your Haskell code is substantially more 'functional' than the imperative form described on the wiki page, you should probably note that in the discussion of the haskell code example.
16:42:11 <tensorpudding> if you want to understand cryptography it is required
16:43:04 <Berenlap> shortcircuit: It's not. I just translated the looping algorithm into a recursive function with the loop variables as arguments
16:43:08 <shortcircuit> It looks like the references the WP page uses are print publications.  I'd have to visit the library to get my hands on a copy, but it's possible that the original algorithm is imperative by definition. I don't know, though...
16:43:23 <hablutzel1> I can see... it isn't data oriented but mathematical...
16:43:36 <koeien37> Haskell is very much "data oriented"
16:43:53 <hablutzel1> database I say, like enterprise software
16:43:58 <dfdf> koeien37: how can you say very much if you doublequote the term
16:44:07 <luqui> databases aren't very data oriented
16:44:08 <luqui> :-P
16:44:21 <hablutzel1> I was referring to that...
16:44:23 <Cale> databases are frustrating for their lack of types
16:44:31 <hablutzel1> not data-driven developpment or something like that
16:44:57 <hablutzel1> well, I suppose I'm newbie after all!
16:44:57 <Berenlap> Databases are frustrating for their lack of first-class tables
16:45:26 <hablutzel1> first-class tables?
16:45:28 <Cale> Yeah, that would be a good start.
16:46:02 <Cale> hablutzel1: Tables ought to be values.
16:46:21 <Cale> You should be able to manipulate tables the same way you manipulate any other values.
16:46:26 <Cale> (like integers or strings)
16:46:46 <Stalafin> if i declare something like a = 0.142 --- why does haskell make it a double, not a float...?
16:47:05 <monochrom> defaulting
16:47:07 <Cale> Stalafin: That's just how the defaulting rule works.
16:47:14 <tensorpudding> :t 0.142
16:47:16 <lambdabot> forall t. (Fractional t) => t
16:47:25 <RayNbow> Cale: so we can have recursive tables containing tables? :p
16:47:29 <hablutzel1> are you talking about something like object oriented database?
16:47:31 <Veinor> yes!
16:47:33 <Cale> RayNbow: yes
16:47:48 <Stalafin> but this sux :( pi is a float
16:47:53 <RayNbow> :t pi
16:47:55 <lambdabot> forall a. (Floating a) => a
16:47:56 <koeien37> no
16:48:01 <koeien37> > pi :: Double
16:48:02 <RayNbow> > showCReal 100 pi
16:48:03 <lambdabot>   3.141592653589793
16:48:03 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
16:48:04 <Cale> Stalafin: pi is not a float, it's a polymorphic thing
16:48:10 <Stalafin> gna
16:48:11 <lament> :t pi
16:48:12 <lambdabot> forall a. (Floating a) => a
16:48:22 <tensorpudding> Floating is a typeclass
16:48:28 <lament> @src pi
16:48:28 <Berenlap> Float is not Floating
16:48:29 <tensorpudding> and Double is an instance of it
16:48:29 <lambdabot> Source not found. My pet ferret can type better than you!
16:48:33 <Berenlap> Doubles are Floating
16:48:37 <monochrom> > "floating" == "float"
16:48:38 <lambdabot>   False
16:48:43 <tensorpudding> and I assume Float is also an instance of Floating
16:48:54 <tensorpudding> > pi :: Float
16:48:55 <lambdabot>   3.1415927
16:48:57 <HugoDaniel> how do i say that a datatype can be either from a type class or from other ? do i have to specify an abstracted typeclass ?
16:49:02 <skorpan> @hoogle Floating a => a -> Bool
16:49:03 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
16:49:03 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
16:49:03 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
16:49:11 <kmc> HugoDaniel, you have to make one class to encompass both
16:49:27 <Cale> HugoDaniel: You could use Either
16:49:27 <HugoDaniel> hmm ok
16:49:31 <svk_> Hey, quick lazy question, sorry: is there a convenient notation to produce a copy of a value in record notation with just one (or a few) fields changed?
16:49:33 <Cale> (perhaps)
16:49:47 <kmc> svk_, r { foo = 3 ~
16:49:47 <Stalafin> okay, so say... i have a definition toDeg rad = rad * 180 / pi
16:49:48 <kmc> err
16:49:49 <kmc> svk_, r { foo = 3 }
16:49:49 <koeien37> x { field1 = 37 }
16:50:07 <Stalafin> why is that definition Floating, and why can't i set it manually to Num/
16:50:18 <koeien37> Num is not enough for pi to exist
16:50:20 <svk_> Where "r" is the old value?
16:50:20 <Cale> Unfortunately, that record syntax doesn't give you a first class function
16:50:20 <tensorpudding> you want pi as a num?
16:50:23 <koeien37> svk_: yes
16:50:27 <svk_> Okay, thanks!
16:50:27 <tensorpudding> there is a floor function
16:50:37 <Stalafin> koeien37: i don't understand
16:50:40 <Cale> (so you have to wrap it in lambda if you want the function to do that)
16:50:43 <tensorpudding> :t float
16:50:44 <lambdabot> Float -> Doc
16:50:46 <tensorpudding> err
16:50:50 <tensorpudding> :t floor
16:50:52 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:50:54 <koeien37> Stalafin: a finite field  might be a Num, but it has no pi.
16:50:59 <monochrom> Stalafin: Num doesn't even support division.
16:51:10 <kmc> svk_, whenever i use records i end up writing a lot of code like (modify (\r -> r { x = a })).  this is a "design pattern" and thus a problem to be eliminated.  see the packages fclabels, lenses, data-accessor for attempts at fixing this
16:52:12 <tensorpudding> if you really want to express pi as an integer, you can do floor pi
16:52:14 <luqui> Stalafin, Integer is a Num, and pi is not one of those, so pi can not be in Num
16:52:17 <Stalafin> koeien37: ah, i made a mistake... i mixed up some stuff i read
16:52:21 <tensorpudding> > floor pi :: Int
16:52:23 <lambdabot>   3
16:52:23 <Stalafin> yeah, got it, thx
16:52:30 <svk_> Okay, I'm sort of at the stage where I'm just worrying about getting something done (functionally) at the moment though.. will try to shape up my style later
16:52:40 <kmc> > floor (pi * 10000)
16:52:41 <lambdabot>   31415
16:52:42 <tensorpudding> > ceiling pi :: Int --maybe ceiling too
16:52:43 <lambdabot>   4
16:52:55 <sshc> > floor 3
16:52:57 <lambdabot>   3
16:53:00 <sshc> > ceiling 3
16:53:01 <lambdabot>   3
16:53:01 <ColonelJ> > round (pi * 10000)
16:53:02 <lambdabot>   31416
16:53:17 <tensorpudding> @google haskell numeric typeclasses chart
16:53:19 <sshc> , show ceiling
16:53:19 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics
16:53:19 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki
16:53:20 <lunabot>  luna: No instance for (GHC.Show.Show (a -> b))
16:53:29 <tensorpudding> hmm, don't think that was it
16:54:01 <ColonelJ> > [round 1.2, round 1.5, round 1.8, round 2.2, round 2.5, round 2.8]
16:54:02 <lambdabot>   [1,2,2,2,2,3]
16:54:14 <dibblego> @hoogle lookupBy
16:54:14 <lambdabot> No results found
16:54:19 <ColonelJ> > [round -1.2, round -1.5, round -1.8, round -2.2, round -2.5, round -2.8]
16:54:21 <lambdabot>   No instance for (GHC.Real.Fractional (a -> b))
16:54:21 <lambdabot>    arising from the literal ...
16:54:45 <ColonelJ> > [round (-1.2), round (-1.5), round (-1.8), round (-2.2), round (-2.5), round (-2.8)]
16:54:46 <lambdabot>   [-1,-2,-2,-2,-2,-3]
16:54:49 <Veinor> > show round
16:54:50 <lambdabot>   "-0.375->\n  0\n-0.75->\n  -1\n-1.5->\n  -2\n-3.0->\n  -3\n-6.0->\n  -6\n-1...
16:54:53 <tensorpudding> http://www.bucephalus.org/text/Haskell98numbers/Haskell98numbers.png
16:54:55 <Veinor> :D
16:54:57 <tensorpudding> that was what i was looking for
16:55:06 <dibblego> > round <$> [-1.2, -1.5, -1.8, -2.2, -2.5, -2.8]
16:55:07 <lambdabot>   [-1,-2,-2,-2,-2,-3]
16:55:19 <Stalafin> is there something like type conversion? i have made a function which takes a Floating... but say i wanna give it a Num... shouldn't it be able to somehow deduce that the Num should be converted to a Floating?
16:55:20 <luqui> http://photos1.blogger.com/photoInclude/blogger/3557/910/1600/annotated_monads.1.jpg  <- what a cool picture
16:55:32 <ColonelJ> anyway, looks like bankers rounding
16:55:35 <Veinor> Stalafin: there is no general way to turn a Num into a Floating.
16:55:35 <Cale> Stalafin: Floating and Num aren't types
16:55:46 <Cale> Stalafin: they're classes to which types may belong
16:55:51 <kmc> Stalafin, Haskell has no implicit conversions
16:56:09 <Stalafin> Cale: okayokay :p say then, from Integer to Double
16:56:12 <ColonelJ> > (3 :: Int) + 3.5
16:56:13 <Cale> fromIntegral
16:56:13 <luqui> a type, like Integer, can be in Num.  A value, like 4, can be in Integer.  but 4 is not in Num.
16:56:14 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
16:56:14 <lambdabot>    arising from the lit...
16:56:17 <koeien37> :t fromInteger
16:56:18 <kmc> Stalafin, fromIntegral
16:56:18 <lambdabot> forall a. (Num a) => Integer -> a
16:56:21 <kmc> :t fromIntegral
16:56:21 <Veinor> luqui: I like ListT
16:56:22 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:56:33 <Cale> fromIntegral converts from any Integer-like type to any numeric type whatsoever
16:57:06 <luqui> Veinor, yeah that one is cool!
16:57:16 <luqui> you mean ListT [] ?
16:57:18 <koeien37> fromIntegral is just fromInteger . toInteger
16:57:22 <Veinor> Yeah.
16:57:46 <Stalafin> and what happens if my function does not know in the first place whether or not it gets a Double or an Int? fromIntegral does not look like i can just throw in whatever i want
16:57:51 <|fft|> Cale: Is it hard to understand principles of the Memo Module ?
16:57:56 <monochrom> Why do the nations imagine a vain thing? Such as converting Floating to Num? Why not converting Floating to Bool?
16:58:07 <copumpkin> |fft|: no
16:58:15 <tensorpudding> > pi :: Bool
16:58:19 <lambdabot>   No instance for (GHC.Float.Floating GHC.Bool.Bool)
16:58:21 <lambdabot>    arising from a use of...
16:58:27 <koeien37> Stalafin: look at the type of (+) for example
16:58:29 <koeien37> :t (+)
16:58:34 <copumpkin> > pi :: a -> Bool
16:58:40 <lambdabot> forall a. (Num a) => a -> a -> a
16:58:42 <lambdabot>   Could not deduce (GHC.Float.Floating (a -> GHC.Bool.Bool))
16:58:44 <lambdabot>    from the cont...
16:58:47 <koeien37> this means, for any numeric type a, it is a function a -> a -> a.
16:58:48 <Cale> |fft|: It's important to understand how lazy evaluation works first, but other than that, it's not too bad.
16:58:53 <copumpkin> > pi :: Natural -> Bool
16:58:54 <Veinor> |fft|: Memo?
16:58:54 <lambdabot>   No instance for (GHC.Float.Floating
16:58:55 <lambdabot>                     (Data.Number.Natura...
16:58:59 <monochrom> Even to "convert" Double to Integer there is already an ambiguity of at least 4 different common meanings.
16:59:04 <Cale> |fft|: If you're referring to the actual implementation
16:59:07 <koeien37> so that's why you can use 2 + 3, and 3.14159 + 2.7182818284
16:59:14 <Cale> |fft|: Just learning how to use it is easy enough :)
16:59:20 <|fft|> Veinor: MemoCombinators
16:59:25 <luqui> |fft|, i explained it here, which people seem to like:  http://www.reddit.com/r/haskell/comments/a7100/datamemocombinators_and_you/
16:59:33 <tensorpudding> > let floatingToBool 0 = False; floatingToBool x = True in floatingToBool pi
16:59:34 <lambdabot>   True
16:59:38 <Veinor> I meant to put that into my post, but I never got around to it.
16:59:48 <Veinor> :D
17:00:02 <|fft|> luqui: ths
17:00:09 <luqui> i'm starting to view my posts as immutable.
17:00:16 <luqui> it is just too much work to maintain all of them
17:00:25 <luqui> let the date serve as a relevance criterion
17:00:51 <Veinor> true, I might do a separate one for an explanation of 'how' and just link that to the old one
17:01:18 <kmc> > let n = 100000 in (4*) . (/ fromIntegral n) . genericLength . filter (\(x:y:_) -> (x**2+y**2) < 1.0) . take n . iterate (drop 2) . randomRs (-1,1) $ mkStdGen 2718281828
17:01:20 <lambdabot>   3.14688
17:01:27 * hackagebot upload: graphics-drawingcombinators 1.0.1 - A functional interface to 2D drawing in OpenGL (LukePalmer)
17:01:29 * hackagebot upload: graphics-drawingcombinators 1.0.2 - A functional interface to 2D drawing in OpenGL (LukePalmer)
17:01:36 <Veinor> kmc: what
17:01:43 <Veinor> oh, heuristic pi
17:01:46 <kmc> computes pi, poorly
17:02:03 <tensorpudding> @type (^)
17:02:05 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
17:02:08 <tensorpudding> hmm
17:02:10 <ColonelJ> > pi :: CReal
17:02:11 <lambdabot>   3.1415926535897932384626433832795028841972
17:02:12 <Veinor> @src (^)
17:02:12 <lambdabot> x ^ 0            =  1
17:02:12 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
17:02:12 <lambdabot>   where f _ 0 y = y
17:02:12 <lambdabot>         f x n y = g x n
17:02:13 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
17:02:15 <lambdabot>                       | otherwise = f x (n-1) (x*y)
17:02:17 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
17:02:25 <|fft|> Cale: Just learning how to use is good. But this nice hiding of memotables is like black magic for me now and I think it would be useful to understand it.
17:02:28 <kmc> :t (^^)
17:02:30 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
17:02:30 <kmc> :t (**)
17:02:30 <micah> > let foo n = foo (n - 1) in foo 3
17:02:30 <Veinor> oh, so ^ is fast squaring
17:02:31 <lambdabot> forall a. (Floating a) => a -> a -> a
17:02:36 <lambdabot>   mueval: ExitFailure 1
17:02:42 <koeien37> Veinor: yes
17:02:56 <RayNbow> @google power function site:haskell.org wiki
17:02:57 <kmc> > let foo (n+1) = foo n in foo 3
17:02:58 <lambdabot> http://www.haskell.org/haskellwiki/Power_function
17:02:58 <lambdabot> Title: Power function - HaskellWiki
17:03:00 <lambdabot>   * Exception: <interactive>:1:145-161: Non-exhaustive patterns in function foo
17:03:07 <koeien37> oh noez! n+k patterns
17:03:15 <kmc> wait 0 is not -1+1?
17:03:15 <tensorpudding> > let real (x :+ _) = x in (real . abs) (0.0 :+ (-1.0))^2 == (-1.0)
17:03:18 <lambdabot>   False
17:03:26 <copumpkin> kmc: not on the naturals
17:03:29 * hackagebot upload: Hricket 0.1 - A Cricket scoring application. (AnthonySimpson)
17:03:37 <koeien37> kmc: no
17:03:40 <ColonelJ> > (-1) + 1
17:03:40 <tensorpudding> huh
17:03:41 <lambdabot>   0
17:03:44 <kmc> copumpkin, num has negate doesn't it?
17:03:47 <kmc> :t negate
17:03:49 <lambdabot> forall a. (Num a) => a -> a
17:03:52 <Cale> |fft|: Basically, it mostly comes down to the fact that when you call a function f with some expressions for the parameters, it won't evaluate those expressions immediately, but once the parameters get evaluated (because something pattern matches on them), they remain evaluated.
17:03:55 <kmc> > negate (17 :: Natural)
17:03:56 <tensorpudding> > (0.0 :+ (-1.0))^2
17:03:56 <lambdabot>   * Exception: Natural: (-)
17:03:57 <lambdabot>   (-1.0) :+ (-0.0)
17:04:00 <micah> > let foo (n+k) = n ** k in foo 3
17:04:01 <lambdabot>   <no location info>: Parse error in pattern
17:04:04 <kmc> the whole numeric hierarchy is kinda bad :/
17:04:07 <tensorpudding> oh wait
17:04:14 <copumpkin> kmc: Num is an abomination
17:04:15 <tensorpudding> > let real (x :+ _) = x in real (0.0 :+ (-1.0))^2 == (-1.0)
17:04:15 <micah> > let foo (n+k) = n ** k in foo (2 + 3)
17:04:15 <koeien37> k is a fixed constant
17:04:16 <lambdabot>   <no location info>: Parse error in pattern
17:04:17 <lambdabot>   False
17:04:34 <koeien37> this is very ambiguous
17:04:41 <tensorpudding> hmm
17:04:42 <micah> > foo :: Int -> Int
17:04:43 <lambdabot>   Not in scope: `foo'
17:04:51 <tensorpudding> > let real (x :+ _) = x in real (0 :+ (-1))^2 == (-1)
17:04:52 <lambdabot>   False
17:05:01 <ColonelJ> > exp ((pi :: CReal) * (0 :+ 1)) - 1
17:05:02 <micah> > import FRP.Yampa
17:05:03 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
17:05:03 <lambdabot>         against infe...
17:05:03 <lambdabot>   <no location info>: parse error on input `import'
17:05:13 <koeien37> tensorpudding: precedence of real vs ^2
17:05:17 <micah> > :m +FRP.Yampa
17:05:18 <Cale> -- | The type of a memo table for functions of a.
17:05:18 <Cale> type Memo a = forall r. (a -> r) -> (a -> r)
17:05:19 <lambdabot>   <no location info>: parse error on input `:'
17:05:26 <tensorpudding> > let real (x :+ _) = x in real $ (0 :+ (-1))^2 == (-1)
17:05:27 <|fft|> Cale: And we should store this parameters and its values somewhere
17:05:28 <lambdabot>   Couldn't match expected type `Data.Complex.Complex t'
17:05:28 <lambdabot>         against infer...
17:05:28 <ColonelJ> > (exp ((pi :: CReal) * (0 :+ 1))) - 1
17:05:29 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
17:05:30 <lambdabot>         against infe...
17:05:37 <Cale> |fft|: this basically is just a synonym saying what the type Memo a means
17:05:44 <Cale> bool :: Memo Bool
17:05:44 <Cale> bool f = cond (f True) (f False)
17:05:44 <Cale>     where
17:05:44 <Cale>     cond t f True  = t
17:05:44 <Cale>     cond t f False = f
17:05:44 <copumpkin> > (0 :+ (-1))^2 == (-1)
17:05:45 <lambdabot>   True
17:05:47 <tensorpudding> > let real (x :+ _) = x in real ((0 :+ (-1))^2) == (-1)
17:05:47 <Stalafin> can somebody tell me what the problem is here? http://pastebin.com/d2b79a627
17:05:48 <lambdabot>   True
17:06:07 <Cale> So this Memo Bool is a function which takes any function of type (Bool -> r), and produces a new function of type (Bool -> r)
17:06:10 <tensorpudding> oh right
17:06:29 <koeien37> Stalafin: try lawCos 0.1 0.1 10.0
17:06:32 <tensorpudding> ghc will default -1 to a Complex as needed
17:06:37 <Cale> Specifically, given the function f, it produces the function  cond (f True) (f False)
17:06:43 <koeien37> function application is just f x
17:06:45 <Stalafin> koeien37: that works... why? :(
17:06:48 <Stalafin> i dont understand
17:06:55 <Veinor> Stalafin: because that's not how function call syntax works
17:06:59 <koeien37> if you have more parameters, it becomes f x y z, which is ((f x) y) z
17:06:59 <micah> what is a good media library for haskell?
17:07:05 <tensorpudding> media?
17:07:07 <Stalafin> oh
17:07:13 <Veinor> (0.1, 0.1, 10.0) is called a tuple, and it represents those three numbers
17:07:18 <Stalafin> indeed
17:07:20 <koeien37> @let f x y = x + y
17:07:22 <lambdabot>  Defined.
17:07:22 <micah> media- something useful for games
17:07:22 <Cale> |fft|: cond t f  is a function which when applied to True, gives t, and when applied to False gives f
17:07:23 <koeien37> :t f
17:07:24 <lambdabot>     Ambiguous occurrence `f'
17:07:24 <lambdabot>     It could refer to either `L.f', defined at <local>:7:0
17:07:24 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:75:0-32
17:07:30 <koeien37> :t L.f
17:07:32 <lambdabot> forall a. (Num a) => a -> a -> a
17:07:40 <tensorpudding> there are opengl bindings
17:07:46 <koeien37> @let testF :: Int -> Int -> Int; testF x y = x + y
17:07:47 <lambdabot>  Defined.
17:07:50 <tensorpudding> and SDL too
17:07:50 <HugoDaniel> im reading sigfpe's tut about monads, great stuff
17:07:56 <Cale> |fft|: (sorry about the multiple occurrences of f here... that's how it's written in the code)
17:08:00 <micah> ok
17:08:02 <tensorpudding> i think
17:08:03 <koeien37> this means, testF is a function that takes an Int, and returns a Int -> Int
17:08:09 * Cale renames to preserve sanity
17:08:11 <tensorpudding> raincat used sdl i think
17:08:19 <koeien37> Int -> Int -> Int is in fact Int -> (Int -> Int)
17:08:19 <Cale> bool :: Memo Bool
17:08:19 <Cale> bool g = cond (g True) (g False)
17:08:19 <Cale>     where
17:08:19 <Cale>     cond t f True  = t
17:08:19 <Cale>     cond t f False = f
17:08:34 <HugoDaniel> i really enjoy he fits the tree metaphor with the monads
17:08:48 <micah> tensorpudding: is raincat using frp? or just imperative in IO
17:08:48 <Veinor> I'm going to be teaching an intro Haskell mini-class :D
17:08:55 <copumpkin> Veinor: nice!
17:09:14 <koeien37> somebody is going to give a talk about Haskell at the HN meetup netherlands, too
17:09:18 <Veinor> so now I have to write up the lesson plan
17:09:36 <tensorpudding> i'm decently sure that raincat doesn't use frp, but i really don't know
17:09:41 <micah> ok
17:10:10 <Veinor> so right now it's: setting up ghc and cabal, intro to syntax, IO being special, the unary negation catch, and types
17:10:15 <Veinor> in that order. and that's about the first day.
17:10:16 <Cale> |fft|: the idea here is that if you have some function like  cond (f True) (f False), it doesn't have to evaluate (f True) right away, but once it's applied to True, and that result is evaluated, suppose it's 42, the parameter t = f True will become evaluated, and the function effectively turns into  cond 42 (f False)
17:10:20 <HugoDaniel> HN meetup ?
17:10:20 <tensorpudding> http://raincat.bysusanlin.com/
17:10:24 <tensorpudding> that's the raincat site
17:10:31 <micah> yeah googled
17:10:32 <micah> thanks
17:10:32 <micah> :D
17:10:37 <koeien37> HugoDaniel: hacker news
17:11:01 <ColonelJ> Veinor: IO???  Before types??!?
17:11:07 <Veinor> :P
17:11:28 <copumpkin> ColonelJ: types???? before IO?????
17:11:33 <Cale> |fft|: I'm not sure if that explanation makes immediate sense... you kind of have to evaluate things by hand to get a complete feel for what's going on there
17:11:36 <Veinor> I'm just going to say "this is how you print stuff!"
17:11:36 <tensorpudding> you can't really do things in haskell without types
17:11:48 <Veinor> and if someone asks me what IO () is I'll just defer that to the second day!
17:11:56 <micah> types are more important than IO I'd say
17:11:58 <copumpkin> tensorpudding: you don't necessarily need to be aware of them immediately
17:11:59 <Stalafin> okay, so ... whats the correct way to type a = g(f(x,y,z))
17:12:01 <koeien37> then leave out the type sigs
17:12:02 <micah> you use them in eveyrhting, including IO
17:12:09 <Veinor> Stalafin: a = g ( f x y z)
17:12:15 <ColonelJ> I think lambda is more important than anything
17:12:15 <Veinor> or a = g . f $ x y z
17:12:18 <koeien37> Stalafin: g . f $ x y z
17:12:24 <koeien37> er, no
17:12:25 <Saizan> ?
17:12:33 <ezyang> Are typeclasses examples of AOP?
17:12:35 <Cale> |fft|: But anyway, once we can memoise a function of one bit, how about memoising over a sequence of bits? If we can do that, we'll capture a lot of things indeed :)
17:12:41 <Saizan> g . f $ x y z = g (f (x y z))
17:12:43 <Cale> list :: Memo a -> Memo [a]
17:12:43 <Cale> list m f = table (f []) (m (\x -> list m (f . (x:))))
17:12:43 <Cale>     where
17:12:43 <Cale>     table nil cons [] = nil
17:12:43 <Cale>     table nil cons (x:xs) = cons x xs
17:12:45 <copumpkin> ezyang: AOP?
17:12:45 <koeien37> g . f $ x $ y $ z if $ would have the correct associatitvity
17:12:53 <tensorpudding> (.) the function composition combinator
17:12:56 <koeien37> but g (f x y z)
17:12:59 <luqui> ColonelJ, except mature haskell code doesn't really use lambdas. it implies them all over the place, but i like to think of it as defining functions by "equations"
17:13:04 <Veinor> koeien37: I think the current associativity is the right one.
17:13:09 <Veinor> ohohohohohoh.
17:13:18 <copumpkin> Veinor: on ($)? I don't
17:13:18 <Cale> ^^ so this definition effectively does the same trick as Bool, only it does it recursively, and in terms of an arbitrary memoiser for the elements of the list
17:13:33 <ezyang> "aspect-oriented programming"
17:13:36 <koeien37> not really. Why do you want right associativity if you can replace $ by . anyway
17:13:37 <luqui> Veinor, well it is certainly not the left one
17:13:47 <koeien37> oh, now i get it :(
17:14:21 <Veinor> koeien37: because I don't think foo $ bar $ baz can be replaced with foo . bar $ baz for arbitrary expressions foo and bar
17:14:36 <Veinor> cause precedence
17:14:53 <koeien37> well, but if you want f (g x) (h y), I'd prefer being able to say f $ g x $ h y
17:15:04 <Stalafin> Veinor: what if b is not a function, but a variable which just uses functions f and g?
17:15:11 <Cale> If $ had the correct associativity, then we'd have g . f $ x $ y $ z = (g . f) x y z
17:15:21 <Veinor> koeien37: ehh.
17:15:28 <Veinor> Stalafin: explain?
17:15:35 <koeien37> functions are also values
17:15:38 <ColonelJ> is there a difference between static typing and compile-time type checking?
17:15:43 <|fft|> Cale: hmm Let the pattern match is evaluated once. As I can see for bool there are 2 possible  argument values for g. And how will it be if  | set of func arguments | = | R |  ?
17:15:49 <luqui> ColonelJ, pretty much no
17:15:59 <micah> well yes actually
17:16:00 <koeien37> ColonelJ: static typing doesn't imply that the types are actually *checked*  I guess
17:16:08 <Stalafin> b = 1/2 * sqrt(f(x,y,z)), where x and y and z are defined
17:16:11 <koeien37> just that the types of values is known statically
17:16:16 <luqui> sigh, i said pretty much for a reason.
17:16:16 <Veinor> Cale: ah, true
17:16:16 <ColonelJ> koeien37: doesn't it?
17:16:33 <dfdf> if a trees fall and nooone sees it
17:16:36 <koeien37> ColonelJ: well, in practice, I'd guess yes
17:16:40 <luqui> in any case the two terms will be interchangable in conversation
17:16:43 <Veinor> Stalafin: then b = 1/ 2 * (sqrt $ f x y z)
17:16:44 <micah> if a tree falls and no one sees it
17:16:51 <micah> the exact same sound waves are made
17:16:52 <micah> :P
17:16:59 <cygnus> Hi all; I'm running cabal-install 0.6.4, and after running "cabal install alex" (for alex 2.3.1), alex is not a registered package even though it installed successfully. Has anyone seen this happen?
17:16:59 <dfdf> is it still type-checked?
17:17:05 <Saizan> Stalafin: b = 1/2 * sqrt (f x y z)
17:17:07 <Stalafin> Veinor: xD alright, why sqrt $ f and not sqrt . f $ ?
17:17:11 <|fft|> Cale: if we can capture the sequence of bits there are 2^n variants which is ... quite much
17:17:11 <ColonelJ> micah: no because the person standing there affects the sound waves travelling
17:17:14 <Stalafin> this is madness
17:17:25 <ColonelJ> this is sparta
17:17:29 <Saizan> Stalafin: i'd stick to parentheses initially
17:17:43 <luqui> Stalafin, depends.  sqrt $ f x, or sqrt . f $ x
17:17:49 <micah> ColonelJ: so sure it's a slightly modified sound but it's still a sound
17:17:52 <Saizan> > 1 / 2 * 4
17:17:53 <lambdabot>   2.0
17:18:05 <ColonelJ> micah: well they're hardly exactly the same if they're different are they?
17:18:07 <luqui> but yeah, parens are fine until your brain learns to see $s specially
17:18:37 <Saizan> Stalafin: basically you have to use parentheses to group expressions, like in algebra/arithmetic
17:18:54 <ezyang> Ah, ok. Typeclasses are not AOP.
17:18:55 <Saizan> Stalafin: and prefix function application has always higher precedence over operators
17:19:11 <Stalafin> why does sqrt ( f x y z) work, but sqrt ( f (x y z)) not?
17:19:22 <koeien37> because f x y z is  ((f x) y) z
17:19:22 <micah> becuase funcion application is left-associative
17:19:42 <koeien37> and f (x y z) is f applied to (x y z), which is in itself a function application of x to y and z
17:19:43 <Saizan> Stalafin: in the latter you've grouped (x y z) as its own application
17:19:52 <Stalafin> i see
17:19:54 <Saizan> Stalafin: passing (x y z) as a single value to f
17:20:39 <Stalafin> Saizan: and that would only make sense if x and y actually were functions?
17:20:46 <Stalafin> Saizan: s.t. x(y(z)) ?
17:20:49 <micah> I can't get cabal install sdl to work
17:20:54 <ColonelJ> Stalafin: only x would have to be a function
17:21:00 <koeien37> (x y z) is (x y) z, not x (y z)
17:21:04 <Saizan> Stalafin: no, (x y z) is x applied to both y and z as arguments
17:21:19 <koeien37> so x is a function, but y and z are not necessarily functions
17:21:24 <koeien37> (they might be, though)
17:21:30 <ColonelJ> Stalafin: x is a function and x y is a function
17:21:42 <koeien37> :t (+)
17:21:43 <luqui> but (x y) has to be a function, basically meaning x has to take at least 2 args
17:21:43 <lambdabot> forall a. (Num a) => a -> a -> a
17:21:48 <koeien37> :t (+) 1
17:21:49 <lambdabot> forall t. (Num t) => t -> t
17:21:59 <kmc> luqui, but not 2 args syntactically
17:22:02 <koeien37> > let x = (+); y = 1; z = 2 in (x y z)
17:22:03 <lambdabot>   3
17:22:15 <Stalafin> so (x y z) reads (x y)z or x (y z) ?
17:22:19 <koeien37> the former
17:22:21 <ColonelJ> :t a b c
17:22:22 <Saizan> Stalafin: when you'd have foo(arg0, arg1, arg2) in a C-like lang, you've (foo arg0 arg1 arg2) in haskell
17:22:23 <lambdabot>     Couldn't match expected type `Expr -> Expr -> t'
17:22:23 <lambdabot>            against inferred type `Expr'
17:22:23 <lambdabot>     In the expression: a b c
17:22:27 <luqui> :t ?a ?b ?c
17:22:28 <lambdabot> forall t t1 t2. (?c::t1, ?b::t, ?a::t -> t1 -> t2) => t2
17:22:45 <Veinor> what does ?a /b ?c mean? O_o
17:22:53 <ColonelJ> :t ?a
17:22:54 <dfdf> is there a common name for the function (\f g xs ys -> f (g xs ys))
17:22:54 <lambdabot> forall t. (?a::t) => t
17:22:55 <luqui> ^ the only thing i use implcits for anymore
17:22:55 <koeien37> implicit params or so, I don't know the details
17:23:06 <koeien37> dfdf: (f.) . g
17:23:09 <Veinor> @pl (\f g xs ys -> f (g xs ys))
17:23:09 <lambdabot> (.) . (.)
17:23:12 <Veinor> ...
17:23:17 <dfdf> auch
17:23:18 <Veinor> well okay then!
17:23:23 <ColonelJ> :t curry
17:23:24 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:23:26 <luqui> Veinor, ?x is just an unbound variable that gets stuck in the context
17:23:29 <Cale> :t fmap . fmap
17:23:31 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:23:41 <Veinor> luqui: it'd help if I had a concrete example
17:23:56 <luqui> :t sin (?x + 1)
17:23:57 <lambdabot> forall a. (?x::a, Floating a) => a
17:24:07 <ezyang> famp fmap fmap
17:24:09 <Stalafin> nice
17:24:16 <Veinor> so what would I use sin (?x + 1) for
17:24:34 <luqui> Veinor, well say you had a bunch of functions which all take the same parameter and just pass it along
17:24:52 <luqui> Veinor, you could use ?x to avoid having to explicitly pass it
17:25:05 <ColonelJ> :t x = x
17:25:06 <Veinor> could I have an hpaste? :P
17:25:06 <lambdabot> parse error on input `='
17:25:10 <luqui> > let ?x = 42 in foo ; foo = bar ; bar = ?x in bar
17:25:11 <lambdabot>   <no location info>: parse error on input `;'
17:25:18 <ColonelJ> :t val x = x
17:25:19 <luqui> er..., that was a bad example anyway
17:25:20 <lambdabot> parse error on input `='
17:25:33 <Saizan> Veinor: think of it as a built-in version of the reader monad
17:25:38 <luqui> > let foo = bar ; bar = ?x in let ?x = 42 in bar
17:25:39 <lambdabot>   Unbound implicit parameter (?x::a)
17:25:39 <lambdabot>    arising from a use of implicit parame...
17:25:48 <luqui> stupid monomorhism!
17:26:02 <Cale> wait, is MR turned on?
17:26:03 <Saizan> Veinor: or as an implicit typeclass with only a method with the corresponding name define
17:26:09 <luqui> > let foo y = bar y ; bar y = ?x in let ?x = 42 in bar undefined
17:26:10 <lambdabot>   42
17:26:17 <Veinor> > let f = show
17:26:19 <lambdabot>   not an expression: `let f = show'
17:26:27 <Veinor> hm
17:26:34 <koeien37> that is not an expression
17:26:39 <koeien37> let ... in ... are expressions
17:26:46 <micah> > >
17:26:46 <ColonelJ> > let x = x in x
17:26:47 <lambdabot>   <no location info>: parse error on input `>'
17:26:51 <lambdabot>   mueval-core: Time limit exceeded
17:26:54 <micah> > (>)
17:26:55 <lambdabot>   {()->{()->False}}
17:27:05 <micah> > (>) 3 4
17:27:06 <lambdabot>   False
17:27:10 <ColonelJ> > let x y = y in x
17:27:10 <micah> > (>) 3 2
17:27:11 <lambdabot>   True
17:27:11 <Saizan> > let f = show in (f 'a', f True)
17:27:11 <lambdabot>   {()->()}
17:27:12 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:27:12 <lambdabot>         against inferred type...
17:27:17 <ColonelJ> :t let x y = y in x
17:27:19 <lambdabot> forall t. t -> t
17:27:20 <luqui> Veinor, in any case, implicits have fallen out of common usage
17:27:21 <Saizan> it seems the MR is on
17:27:26 <bd_> > ( (>) :: Ordering -> Ordering -> Bool )
17:27:26 * Veinor nods
17:27:27 <lambdabot>   No instance for (Test.SmallCheck.Serial GHC.Ordering.Ordering)
17:27:27 <lambdabot>    arising f...
17:27:35 <bd_> bah, it can't print that?
17:27:36 <monochrom> Madness.
17:27:37 <ColonelJ> :t \x -> x
17:27:39 <lambdabot> forall t. t -> t
17:28:09 <Veinor> ColonelJ: \x -> x is also known as id
17:28:20 <ColonelJ> @src id
17:28:21 <lambdabot> id x = x
17:28:30 <ColonelJ> :t id
17:28:32 <lambdabot> forall a. a -> a
17:28:39 <ColonelJ> really?
17:28:45 <koeien37> yes, really
17:28:52 <ezyang> it's the only nonpathological implementation of a -> a
17:28:54 <ColonelJ> what's with the a instead of the t
17:29:01 <koeien37> oh that's not important
17:29:03 <Veinor> yeah.
17:29:03 <copumpkin> ColonelJ: name of a variable
17:29:14 <koeien37> it is just a type variable, it could be something else
17:29:16 <crutex> heyheyhey
17:29:16 <Veinor> ezyang: how dare you call error and undefined pathological!
17:29:18 <crutex> how come if i turn a light on inside my room
17:29:20 <crutex> its light
17:29:22 <crutex> and then if i turn the light off
17:29:24 <crutex> it get sdark
17:29:27 <koeien37> :t (\x -> x) :: koeien37 -> koeien37
17:29:28 <lambdabot> forall koeien37. koeien37 -> koeien37
17:29:30 <Veinor> it could be called ilikebigbutts -> ilikebigbutts
17:29:39 <copumpkin> koeien37: so self-centered
17:29:42 <Veinor> the one restriction:
17:29:44 <luqui> > fix error
17:29:45 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
17:29:45 <ColonelJ> crutex: because there are no other light sources, and light sources are required for lightness
17:29:47 <copumpkin> Veinor: TMI
17:29:47 <ezyang> Veinor: In the words of the immortal Brent Yorgey, "They're party poopers"
17:29:50 <Veinor> :t (\x -> x) :: A -> A
17:29:51 <lambdabot> Not in scope: type constructor or class `A'
17:29:52 <lambdabot> Not in scope: type constructor or class `A'
17:30:08 <ColonelJ> :t (\x -> x) :: a -> a
17:30:08 <koeien37> right, type variables start with a lowercase character
17:30:09 <lambdabot> forall a. a -> a
17:30:11 <Veinor> yeah.
17:30:23 <crutex> ColonelJ that doesn't really answer
17:30:24 <Veinor> fix error never ceases to amuse.
17:30:29 <luqui> :-)
17:30:39 <crutex> the light source exists and makes the light
17:30:41 <crutex> where does it go
17:30:48 <Cale> crutex: The switch is hooked up to a device which sucks the dark out of the room.
17:31:00 <Veinor> also
17:31:02 <Veinor> > fix show
17:31:03 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:31:05 <monochrom> co-trolls
17:31:17 <crutex> if it gets absorbed, how much light can something absorb
17:31:18 <Veinor> cobordellos
17:31:22 <crutex> and does something absorb light at different rates
17:31:24 <crutex> etc
17:31:33 <tensorpudding> cobordellos sound fun
17:31:41 <Cale> crutex: You'll find that after a while, the bulb will have absorbed too much dark, and its filament will be all black.
17:31:48 <Cale> (and it stops working)
17:31:59 <DigitalKiwi> and then you have a blacklight and can throw parties?
17:32:00 <koeien37> Cale: that makes no sense, if something absorbes light, it should be lighter
17:32:05 <crutex> its not a troll...
17:32:16 <koeien37> but it can run out of blackness, yeah
17:32:18 <Cale> koeien37: It doesn't absorb light, it absorbs the dark.
17:32:19 <aavogt> it absorbs dark
17:32:20 <Veinor> cobordellos are like cobordism, but sexier
17:32:27 <koeien37> Cale: oh i see
17:32:32 <Veinor> http://en.wikipedia.org/wiki/File:Cobordism.svg
17:32:36 <Veinor> my god, it all makes sense!
17:32:56 <Veinor> :I
17:35:27 <aavogt> !seen dolio
17:36:46 <Cale> crutex: If it's not a troll, then it's in the wrong channel anyway ;)
17:36:58 <crutex> well that's true
17:37:04 <crutex> but #physics doesn't know either
17:37:08 <crutex> :D
17:37:24 <crutex> #haskell usually has better math answers than #math too
17:37:25 <lunabot>  luna: Not in scope: `haskell'
17:37:38 <Veinor> how many haskellians does it take to change a lightbulb?
17:37:45 <koeien37> > fix (+1)
17:37:49 <lambdabot>   mueval-core: Time limit exceeded
17:37:55 <Veinor> none, lightbulbs are immutable.
17:37:57 <dolio> aavogt: Yes?
17:38:07 <aavogt> hello
17:38:27 <DigitalKiwi> Veinor: one, but it took two more to figure out how his code worked
17:38:40 <Cale> crutex: Depends on how detailed an explanation you want.
17:38:48 <aavogt> I was considering dragging some #haskell-blah into here, but that's no good
17:38:50 <copumpkin> aavogt turns into another gio123
17:38:52 <Veinor> well, it's easy if you work in LightbulbM.
17:39:00 <copumpkin> oh
17:42:22 <Cale> crutex: I guess I could give the explanation that the switch connects the lightbulb in parallel to a circuit through which electricity is flowing, and the bulb turns the flow of electricity into light by one of a handful of mechanisms.
17:42:49 <crutex> you could even though that's not an answer to my question :D
17:43:59 <luqui> crutex, and then photons leave the lightbulb, bounce off the walls and other stuff, and hit your eye making you see it
17:44:12 <crutex> i'm not asking about perception of light
17:44:20 <Cale> An incandescent light bulb passes the electricity through a thin filament which heats up until it begins to glow. The emitted photons come from electrons in excited energy states in the tungsten atoms falling back down to ground states.
17:44:22 <luqui> you are being very vague...
17:44:48 <crutex> cale are the photons in the tungsten like
17:44:51 <crutex> bundled up
17:44:53 <crutex> and released?
17:44:56 <crutex> and is a set number?
17:45:01 <Cale> The photons aren't in the tungsten.
17:45:02 <crutex> does it take energy to actually release a photon?
17:45:05 <Cale> They're being created
17:45:14 <Veinor> what happens is that when you run electricity through tungsten, it heats up
17:45:22 <luqui> crutex, photons are a form of energy
17:45:23 <Veinor> and some tungsten atoms evaporate
17:45:31 <tela> crutex: The light is absorbed by substances in the room. When it hits electrons in those substances, the electrons jump and transfer energy. When they return to their previous state there's less energy around so it gets released in a longer wavelength: infrared, heat.
17:45:36 <Veinor> so eventually the wire gets so thin that it breaks, and breaks the circuit.
17:45:39 <luqui> so yes, because the energy that the photon is made of had to come from somewhere
17:45:40 <Cale> An electron in a tungsten atom is in an orbital which is at a higher energy level than normal
17:45:42 <Veinor> no circuit, no wire flow
17:45:44 <copumpkin> #haskell-physics
17:45:45 <lunabot>  luna: A section must be enclosed in parentheses
17:46:09 <Cale> and if there are no electrons in orbitals below that, it will want to fall into a lower energy level state
17:46:35 <crutex> is there a limit to how many times an atom can do that
17:46:39 <Cale> But that energy has to go somewhere, and it gets radiated as a new photon
17:46:45 <Cale> No
17:46:47 <Veinor> Cale: I think his question is 'why do bulbs burn out'
17:46:53 <crutex> no its not veinor
17:46:57 <Veinor> oh?
17:47:20 <hablutzel1_> what a chat ...
17:47:31 <crutex> not any limit at alll cale? what else happens when it falls into lower energy state
17:47:40 <crutex> photon emission can't be the only side effect
17:47:45 <crutex> i mean i guess it could
17:48:08 <Cale> Well, basically that's it. The electron ends up back in its lower energy state, and you have a new photon
17:48:22 <Veinor> there's no 'conservation of photons' if that's what you're thinking.
17:48:26 <crutex> if it has "emitted" energy as a photon then
17:48:34 <crutex> orly veinor?
17:48:55 <crutex> if it has emitted energy as a photon, then isn't it losing energy from somewhere else
17:49:11 <Veinor> crutex: the lost energy is the energy from the electron falling down a level
17:49:18 <monochrom> Does anyone want to ask a Haskell question?
17:49:31 <EvilMachine> lol. yeah me… remotely. ^^
17:49:32 <Cale> Yes, it's losing the energy that it originally gained from the electricity.
17:49:41 <luqui> crutex, the electron got that energy from the heat from the electricity flowing through the tungsten
17:49:50 <crutex> ooo
17:49:54 <Saizan> .oO([with a romantic tone] every time an elecrion falls into a lower energy state a new photon is born..)
17:49:55 <crutex> that's making sense now
17:49:56 <crutex> :P
17:49:59 <Cale> yeah
17:50:01 <luqui> what is a good purely functional way to model the emission of light from a lightbulb?
17:50:09 <Veinor> haha
17:50:09 <crutex> kind of
17:50:10 <lament> i'm really impressed by how successfully crutex trolls this channel, in #math he got banned immediately after asking his original question
17:50:16 <bd_> Can quantum chromodynamics be represented as a comonad?
17:50:18 <crutex> >:| i'm not trolling lament
17:50:31 <SamB_XP> who are you trolling, then ?
17:50:39 <monochrom> You may continue in #haskell-blah
17:50:39 <Cale> lament: He's not trolling, he's just being really off-topic :)
17:50:45 <Veinor> s/trolling lament/trolling, lament/
17:50:46 <crutex> i'm not trolling anyone, SamB_XP
17:50:57 --- mode: ChanServ set +o monochrom
17:50:58 <Adamant> lament: #math bans you for logging on just as a precaution
17:51:00 <matsuura> Cale: people have a tendency to call anyone they don't agree with a troll
17:51:02 <SamB_XP> crutex: yeah, I'm just teasing you for your punctuation
17:51:03 <EvilMachine> lament: what makes you think he trolls? btw: the #math channel bans anyone who allows himself to think freely, anyway. ^^
17:51:10 <monochrom> I'll start banning in 30 seconds. I don't care if you're trolling or not.
17:51:17 <crutex> wow why?
17:51:25 <matsuura> fascism
17:51:27 <Cale> crutex: This channel is about Haskell.
17:51:32 <EvilMachine> monochrom: that’s not very fair is it
17:51:32 <monochrom> Read this again: <monochrom> You may continue in #haskell-blah
17:51:36 <Cale> crutex: So you should talk about Haskell here :)
17:51:38 <monochrom> Why is reading so hard?
17:51:39 <EvilMachine> Cale: agreed
17:51:55 <stu2010> agreed, this channel is for haskell, not physics or electricity or light bulbs
17:51:57 <Cale> anyway, that's about as detailed an explanation as I'd care to give on IRC anyway
17:52:06 <crutex> i didn't see that, monochrom, please relax
17:52:07 <Cale> If you want to know more, take some physics courses :)
17:52:07 <Veinor> can someone help me implement lightbulbs in terms of zygomorphisms?
17:52:13 <crutex> thansk Cale
17:52:18 <Adamant> #physics and #electronics are more appropriate for Freenode
17:52:19 <lunabot>  luna: Not in scope: `physics'
17:52:40 <crutex> actually #physics people didn't want to try to give a serious explanation
17:52:46 <Cale> I'm understanding in that the last time I tried #physics, it was just full of trolls and cranks.
17:52:52 <matsuura> yep
17:52:57 <matsuura> as well as math
17:52:59 <EvilMachine> damn, and I just wanted to ask another question, that is based on haskell, but would be in the field of a “next step” for which there is no channel, and i would not even know how to name such a channel. :(
17:53:20 <Cale> #math has really gone downhill since I stopped watching it more carefully
17:53:20 <Veinor> :t fix
17:53:21 <lunabot>  luna: Not in scope: `math'
17:53:21 <lambdabot> forall a. (a -> a) -> a
17:53:25 <Veinor> thought so
17:53:26 <Saizan> EvilMachine: that shouldn't be a problem
17:53:32 <matsuura> EvilMachine: that doesn't make sense, if your question involves an application of physics through haskell, it should probably be relivent to haskell
17:53:34 <EvilMachine> ok then. :)
17:53:37 <Veinor> Cale: cranks? like, over-unity?
17:53:53 <Cale> Veinor: that sort of thing, yeah
17:53:59 <EvilMachine> matsuura: i did not mention physics. you don’t make sense. :)
17:54:04 <lament> Cale: I agree, i remember you banning me in #math :)
17:54:14 <crutex> anyways, i just know that #haskell is full of smart, and thought some of the people enjoy explaining anything that someone wants to understand
17:54:21 <matsuura> EvilMachine: err, misread that, but I caught physics somewhere :p
17:54:26 <dibblego> crutex, they do, in #haskell-blah, try it
17:54:36 <EvilMachine> matsuura: yeah, we all caught that infection. ;) now on to haskell talk
17:54:51 * hackagebot upload: HPath 0.0.2 - Extract Haskell declarations by name. (JasonDusek)
17:54:51 <matsuura> :p
17:54:56 <Cale> They do? I thought #haskell-blah was mostly about sex.
17:55:06 <crutex> not so many people in -blah :P but thanks
17:55:08 <crutex> for the link
17:55:15 <EvilMachine> Cale: Hey, haskell *is* sex. ;-
17:55:17 <EvilMachine> ;)
17:55:30 <Saizan> Cale: anything, really, even haskell at times!
17:55:42 <matsuura> Cale: all of the
17:56:19 <matsuura> <channel>-blah/offtipic is about EVERYTHING completely irrelated to that channel topic.. someone should fix taht
17:56:21 <monochrom> Cale: Self-fulfilling prophecy if you don't go there and change the subject.
17:56:46 * CESSMASTER . o O (wow the whole gang is in here!)
17:57:18 <copumpkin> yeah
17:57:21 <QP> hey, does anyone here have much experience of using the cairo bindings in gtk2hs?
17:57:21 <bob0> QP: no
17:57:35 <Saizan> EvilMachine: did you have a question?:)
17:57:51 <EvilMachine> Saizan: still writing on it. :)
17:58:35 <Cale> QP: I used them a long time ago
17:58:54 <QP> i'm just wondering what the easiest way to render a bitmap is
17:59:03 --- mode: monochrom set -o monochrom
17:59:09 <QP> it seems more complicated than it should be
18:00:14 <QP> i think in the python cairo bindings there's a function set_source_pixbuf or something, but I can't find the haskell equivalent
18:00:33 <EvilMachine> ok, my idea goes like this: we know that in haskell, you define the “what” instead of the “how”, correct?
18:00:40 <EvilMachine> but humans naturally plan like this: 1. the “why” (purpose), 2. the vision (imagining the final result), 3. brainstorming, 4. organization (3&4 are the “how”) and 5. starting with the first step (execution).
18:00:45 <EvilMachine> so i’m thinking: what if we try to build a language, where you just define the “why”, and maybe the vision of the final result, and let the compiler come up with the rest automatically?
18:01:19 <bd_> EvilMachine: like SQL?
18:01:19 <monochrom> I naturally do not brainstorm.
18:01:35 <CESSMASTER> now we know why you got banned from #math
18:01:46 <EvilMachine> bd_ well, SQL, like Haskell, is more like the “what”.
18:01:54 <EvilMachine> bd_: i want to go a step further
18:02:00 <troutwine> EvilMachine: What things would you try to express?
18:02:25 <EvilMachine> CESSMASTER: yeah, be cause i like to freely ponder some ideas. they don’t like that. :)
18:02:41 <Cale> Hmm, xerox!
18:02:43 <EvilMachine> troutwine: wait, i make an example
18:02:58 <Cale> Or maybe dcoutts would know the answer.
18:03:45 <EvilMachine> troutwine: say, you want your music to sound better. so you would state that goal, in detail, in a defined language. the end-resuld of what you wanted.
18:04:14 <monochrom> Just replace "let the compiler come up with the rest automatically" with "let type theory come up with the rest" and it is what people actually do.
18:04:18 <EvilMachine> troutwine: i repeat: in detail. no vague “guessing”.
18:04:23 <twanvl> EvilMachine: that sounds like a theorem prover
18:04:39 <EvilMachine> yes, i am *sure* there is something like that already out there
18:04:41 <tela> Anyone know a library besides MWC that implements normal random numbers? The ST monad is killing me.
18:05:07 <Cale> EvilMachine: I would have to see some example programs to understand what you're getting at :)
18:05:42 <BMeph> EvilMachine: What's the difference between the vision and the "what"? :)
18:05:48 <EvilMachine> you know what it also sounds like? like writing unit tests, and let the compiler automatically transform data so that it fits them. of course, yes, there is the big question on how a compiler would actually figure this out. that’s why i’m not saying that this is some concrete thing. :)
18:06:30 <EvilMachine> Cale: look up the unit tests of e.g. Wine. Or the Firefox testing suite. Imagine that would be the only code needed.
18:06:50 <Saizan> that's pretty similar to stating some theorem in e.g. Coq and having the tactics write the proof for you
18:06:58 <EvilMachine> Cale: of course not written in C but in a more fitting new language, naturally growing from haskell
18:07:20 <EvilMachine> BMeph: the vision *is* the “what”.
18:07:22 <lament> EvilMachine: I invoke Alan Perlis
18:07:23 <troutwine> EvilMachine: Sounds like you'd want some sort of theorem group in Coq relating to sound.
18:07:39 * lament gives EvilMachine a lollipop
18:07:53 <EvilMachine> troutwine: the sound was just an example.
18:07:56 <EvilMachine> lol
18:07:59 <Saizan> (though tactics only go so far)
18:08:24 <EvilMachine> ok, now i have trouble understanding what you man with Coq, Alan Perlis, etc, so I have to look it up.
18:08:36 <EvilMachine> so i think we’re done here. :)
18:08:49 <EvilMachine> ah, tactics also is something?
18:09:01 <EvilMachine> for what would i search, to learn more about this?
18:09:49 <EvilMachine> ok, I should have known the name Alan Perlis. :D
18:09:53 <Saizan> well, you know how a program can be seen as a proof of its type when seen as a statement in an appropriate logic?
18:10:09 <Saizan> i.e. the Curry-Howard correspondence
18:10:31 <EvilMachine> Saizan: partially.
18:11:09 <Saizan> well, Coq is a language with such an expressive type system that you can prove interesting mathematical theorems with it
18:11:20 <EvilMachine> Saizan: mind you, I’m no professor of mathematics or computer sciences. But I’m a very good autodidact, so I can learn it all in a short time. And I also want to. :)
18:11:22 <Saizan> actually, that's the main purpouse
18:11:40 <EvilMachine> wow, sounds interesting
18:12:13 <idnar> EvilMachine: the problem is, in order for your idea to work, you'd need to write "perfect" unit tests
18:12:19 <EvilMachine> Saizan: if only such a thing would exist for general software development…
18:12:30 <EvilMachine> idnar: agreed. :)
18:12:34 <Saizan> though it's a pain to write down all the details of proofs, so there's these "tactics" which are like macros that do the work for you, when they can
18:12:37 <idnar> EvilMachine: in the simplest case, that's a lot harder than just writing "90%" tests, and in more complex cases I think it's virtually impossible
18:12:58 <idnar> EvilMachine: (eg. when IO is involved)
18:12:58 <Berenlap> idnar: At least complete ones, which indeed becomes a proof of correctness
18:13:06 <idnar> Berenlap: well, yeah
18:13:22 <EvilMachine> idnar: good point… it should not be more than “normal” programming methods, or the whole point of it being more natural, would be gone. ^^
18:13:23 <idnar> Berenlap: and if they're not complete, then the code generator might well generate broken code
18:13:46 <Berenlap> idnar: Or, as is the case in theorem provers, they just complain that your definition is incomplete
18:13:47 <j4cbo> EvilMachine: yeah, i think you want to read up about proof languages :)
18:13:52 <j4cbo> Coq, Twelf, etc
18:13:53 <idnar> a human being won't do something silly like intentionally writing code that returns the wrong result once every 1000 calls
18:13:55 <Berenlap> Agda
18:14:03 <idnar> but an automated code generator might well accidentally do that
18:14:10 <EvilMachine> Berengal: certainly the better solution, than just generating broken code. :)
18:14:37 <McManiaC> Inf: thread blocked indefinitely
18:14:43 <Berenlap> There's also Epigram, which aims to be a _programming_ language more than a theorem prover, but it's not quite done yet
18:14:45 <idnar> Berenlap: well, "complete" in the sense of constraining everything that actually needs to be constrained
18:14:46 <McManiaC> what does that mean? code: http://npaste.de/A3/
18:14:48 <EvilMachine> j4cbo: yu mean like the Znotation?
18:14:51 <Saizan> EvilMachine: so basically in Coq you can write down the specification for your program in the type system, and then prove that your implementation meets it (or mix these two stages having the specification be simply the type of your implementation), it seems what you want is to just write down the specification :)
18:15:23 <Berenlap> idnar: I meant "complete" as in "total", as in no partial values
18:15:33 <Berenlap> As in no bottoms
18:15:36 <j4cbo> EvilMachine: sort of
18:16:44 * drdr can use haskell for basic programs (Whooo)
18:16:56 <Berenlap> McManiaC: It means you have a deadlocked thread
18:17:14 <drdr> oh theres a math equation that would help...
18:17:22 <Berenlap> McManiaC: Which you get from trying to write to an MVar several times without reading from it in the meantime
18:18:45 <McManiaC> do you always have to read before putting into an mvar?
18:19:27 <EvilMachine> ok, sorry for the pause, i had to take notes of all the things i do not know about. :)
18:19:29 <monochrom> No.
18:19:34 <EvilMachine> guys you are the best! :D
18:19:48 <drdr> :[
18:19:58 <EvilMachine> girls too? ^^
18:20:06 <drdr> :/
18:20:09 <EvilMachine> ?
18:20:16 <drdr> gah
18:20:17 <EvilMachine> neither-nor?
18:20:24 <EvilMachine> :D
18:20:27 <drdr> dolphin foo
18:20:33 <McManiaC> monochrom: no?
18:20:37 <EvilMachine> :D
18:20:54 <EvilMachine> drdr → #haskell-blah? :P
18:20:58 <monochrom> Right. To be clear, you can have someone put and someone else take.
18:21:07 <Berenlap> McManiaC: MVars are either empty or full. Reading from one empties it, and writing to it fills it. You can't read from an empty MVar, nor write to a full one (the calls block waiting for someone else to read/write)
18:21:19 <drdr> heh?
18:21:36 <monochrom> Your particular program is just putting and no one getting. The second put will wait.
18:21:48 <j4cbo> sounds like rendezvous()
18:21:54 <EvilMachine> Berenlap: so basically, a dynamic list of mvars resembles a stack/buffer? ;)
18:22:19 <monochrom> one-place buffer
18:22:21 <McManiaC> Berenlap: aaaah rgot about the full part…
18:22:26 <EvilMachine> monochrom: list
18:22:37 <monochrom> Oh I mean one MVar is a one-place buffer.
18:22:43 <EvilMachine> yep
18:23:01 <EvilMachine> although i have no idea what use there is for such a construct. ;)
18:23:02 <luqui> EvilMachine, yeah.  if you make a list-like thing out of MVars, you get Chan.
18:23:05 <Saizan> Chan is roughly a list of MVars and it's an unbounded buffer
18:23:17 <monochrom> Control.Concurrent.Chan implements unbound message queue by dynamic list of MVar's and stuff.
18:23:18 <Berenlap> EvilMachine: It's a Schrödinger's box of burritos is what it is
18:23:36 <ben0x539> Chans are all kinds of crazy
18:23:38 <EvilMachine> ahh… ok, the “concurrent” explains the usage.
18:23:47 <Berenlap> Chan is a funny datatype...
18:23:56 <monochrom> I use Control.Concurrent.Chan all the time.
18:24:12 <monochrom> Best thing since sliced mutexes.
18:24:38 <EvilMachine> hmm… *thinks about the data type (Chan, Chan, Chan, Chan)* ^^
18:24:52 <luqui> monochrom, sliced in the sense of murdered?
18:24:59 <EvilMachine> sorry. /hides
18:25:03 <monochrom> Just hijacking a meme.
18:25:06 <Berenlap> EvilMachine: It's an infinite list, with each tail wrapped in an MVar
18:25:22 <ezyang> I have a blog now. I wonder how many posts about Haskell I should make before submitting to Planet Haskell.
18:25:32 <ben0x539> monochrom: They are neat, but I am somewhat afraid of the sheer amount of mutexes in its implementation
18:25:33 <drdr> at least 100
18:25:36 <luqui> monochrom, right, but you imply that mutexes are better than chan, a point on which i am forced to disagree :-)
18:25:39 <EvilMachine> over 9000
18:25:55 * drdr slaps EvilMachine
18:26:02 <EvilMachine> *is ashamed*
18:26:02 <drdr> haskel memems oly
18:26:05 <ezyang> Oh no! I guess I should get writing.
18:26:17 <luqui> ben0x539, in the implementation of a Chan?
18:26:20 <ben0x539> yes
18:26:23 <drdr> ezyang a better idea it to write beginner user guides
18:26:27 <Berenlap> STM ftw
18:26:55 <monochrom> drdr come back when you're sober.
18:27:00 <EvilMachine> drdr: you mean yet another “yet another beginner user guide”? :D
18:27:15 <ben0x539> I mean, a Chan apparently is two MVar (MVar ...)s with more MVars stuck inbetween :I
18:27:15 <j4cbo> Berenlap: doesn't the performance on that still suck?
18:27:20 <ben0x539> That kind of synchronisation cannot be fast
18:27:24 <ezyang> Judging from the three draft posts I'm currently slapping around
18:27:25 <j4cbo> (and always will?)
18:27:40 <ezyang> My blog will be more like the ravings of a refugee from imperative land.
18:28:04 <Berenlap> j4cbo: I wouldn't say it sucks. I haven't had problems with it at least. Then again, I haven't had hard performance requirements to meet either
18:28:04 <luqui> ben0x539, how many mutexes does an MVar use?
18:28:05 <ezyang> rather than the mathematical flights I normally see on Planet Haskell :-)
18:28:29 <j4cbo> lock-free algorithms for the win <_<
18:29:06 <EvilMachine> hey, i guess it would be nasty, to just always stick a value of the TransformableToEverything class into the MVar, and therefore become free from the limit of one, without using Chan. ;))
18:29:40 <ben0x539> luqui: No idea, they are presumably hiding in the rts
18:29:56 <luqui> EvilMachine, there are no values of TransformableToEverything :-)
18:29:59 <EvilMachine> ezyang: hate to tell you, but that’s more like a pangaea supercontinent
18:30:29 <ezyang> EvilMachine: hah
18:30:33 <EvilMachine> lunabot: i can create a class that in most nasty ways implements all known classes. ;) I shall call it: PHP. ;)
18:31:04 <luqui> :t {- I call it -} undefined
18:31:05 <lambdabot> forall a. a
18:31:54 <btutt> Hrm.  I don't suppose anyone understands the TH.Syntax changes that were part of 6.12.1? Cxt changed from [Type]  to [Pred]. I'm trying to fix a haskell objetive-c (HOC) build break with 6.12.1.
18:32:00 <EvilMachine> luqui: no, i mean, actually *implement* all casts for all types in the GHC library, wether they make sense or not. that would deserver the name PHP. ;)
18:32:14 <j4cbo> no, it wouldn't?
18:32:50 <j4cbo> PHP's type system is really the least of its problems, frighteningly enough :P
18:32:52 <EvilMachine> j4cbo: ok, it would still be insulting to call Haskell code of any kind PHP. :)
18:32:58 <btutt> Pred requires a Name before [Type]
18:33:19 <drdr> meh
18:33:40 <drdr> i find the worst sin php has to its name is no standard whatsoerver
18:33:55 <luqui> EvilMachine, I disagree
18:34:15 <troutwine> drdr: Is there more than one implementation of PHP?
18:34:17 <luqui> EvilMachine, unsafeCoerce, unsafePerformIO unjudiciously used would easily be worthy of PHP
18:34:23 <EvilMachine> PHP is the reason, I tried to design a very different language… until I found out, that Haskell already did exactly that. And better too. So funnily, Haskell to me feels like the perfect natural language. (Doesn’t mean it’s not hard to learn, though.)
18:34:34 <HugoDaniel> troutwine: is there a spec of php ?!
18:34:41 <EvilMachine> HugoDaniel: ginda
18:34:42 <troutwine> Good lord, no.
18:34:43 <ezyang> "The source code"
18:34:44 <EvilMachine> HugoDaniel: kinda
18:34:56 <HugoDaniel> really ?
18:34:59 <HugoDaniel> oh
18:35:12 <j4cbo> all languages have serious flaws.
18:35:13 <HugoDaniel> i like php, its nice for dirty simple things
18:35:16 <j4cbo> more or less by definition.
18:35:20 <HugoDaniel> i think it fits its purpose
18:35:31 <idnar> what about serious floors?
18:35:37 <EvilMachine> Hey, I once managed to write plain text in between the code lines, and the interpreter did not even notice it. (turns out it created constants for whatever reason).
18:35:44 <Saizan> btutt: the Name is the one of the class
18:35:44 <luqui> here is a new language with no flaws.  I call it Unit.
18:35:54 <HugoDaniel> i actually use it when i need to hurry webpages with about 20 pages
18:36:00 <Berenlap> HugoDaniel: I still haven't done any simple thing I'd rather do in PHP than in Haskell
18:36:01 <troutwine> HugoDaniel: When I code PHP I can't help but repeat "Hackity" in my mind, as if I were a train.
18:36:02 <EvilMachine> luqui: ok, agreed. I’d just write a class with a generic implementation, that just uses unsafe casts for everything. ^^
18:36:03 <luqui> It is strongly typed, consistent, normalizing, simple
18:36:04 <idnar> luqui: Top is so much better than Unit!
18:36:08 <drdr> hugo use sinatra
18:36:25 <HugoDaniel> i have done some work for cisco europe in php, they paid very nice and it was done in about a week
18:36:28 <ezyang> PHP has pretty impressive performance building up its runtime.
18:36:31 <luqui> idnar, is that a real language?
18:36:35 <ezyang> which means that deploying PHP is easy peasy.
18:36:41 <idnar> luqui: no, I'm just being silly
18:36:44 <j4cbo> the fact that unsafe* exists or needs to exist in Haskell is a pretty serious tragedy, i think :/
18:36:48 <HugoDaniel> they said "this is not to be maintainable, it just has to work"
18:36:50 <luqui> idnar, okay.  i didn't get it :-P
18:37:14 <EvilMachine> HugoDaniel: PHP is a nice language, if you use it for its purpose: as a template language. Leaving the real code to a real language. But instead people invent stupid things like the Typo3 template language… INTERPRETED in PHP. The horrors!
18:37:21 <Saizan> btutt: in the older version you'd just (ConT "ClassName") `AppT` typearg1 `AppT` typearg2, now you do ClassP "ClassName" [typearg1, typearg2]
18:37:22 <idnar> Top as opposed to Unit or Bottom
18:37:33 <btutt> ah....
18:37:44 <HugoDaniel> EvilMachine: oh... i dont know any of those
18:37:44 <btutt> that is much more helpful! thanks!
18:37:45 <Berenlap> j4cbo: unsafe* are basically a backdoor into the runtime provided for the convenience of budding GHC hackers. At least that's my view on things
18:38:09 <HugoDaniel> stuff thats built on top of php ive worked with cakephp only
18:38:38 * drdr hates php
18:38:40 <EvilMachine> HugoDaniel: there are tons of templating systems for PHP. E.g. inside content management systems. They all implement basically their own template languages, which end up creating a “inner platform effect”.
18:38:46 <HugoDaniel> one time i was in germany without any money and i had to code in php to buy a bus ticket back to portugal
18:39:06 <ben0x539> Where are ghc's mvars implemented?
18:39:24 <Berenlap> ben0x539: Control.Concurrent.MVar has the haskell code at least
18:39:29 <j4cbo> Berenlap: even, say, unsafeRead / unsafeWrite?
18:39:39 <HugoDaniel> i would have coded in haskell, but the guys were asking for php
18:39:45 <EvilMachine> i did never feel any need to use unsafe*. so to me, it could just as well be missing. but hey, i am never a fan of leaving out possibilities.
18:39:46 <Berenlap> j4cbo: Why not?
18:40:03 <ben0x539> Berenlap: Well, that refers to GHC.MVar, and that uses a bunch of things with # in their name, I guess those are in C then?
18:40:07 <Adamant> j4cbo: at least there is truth in advertising for it
18:40:20 <EvilMachine> HugoDaniel: lool. man, i would have had tons of PHP jobs for you back then.  :)
18:40:26 <j4cbo> i don't see that as a backdoor into the runtime so much as a backdoor out of the language entirely
18:40:35 <Berenlap> ben0x539: Yes, probably. I've never looked past the haskell part of GHC, really...
18:40:39 <Adamant> j4cbo: how many other languages have dangerous features that they aren't as clear about?
18:41:01 <Berenlap> ben0x539: But GHC.MVar seems like a likely place to look
18:41:30 <HugoDaniel> :)
18:41:34 <Berenlap> j4cbo: That's basically what a backdoor into the runtime is... Ways to escape the language
18:41:52 <sshc> how does a continuation work in Haskell?
18:42:06 <copumpkin> (a -> r) -> r
18:42:09 <BMeph> sshc: Lazily? ;)
18:42:10 <EvilMachine> i think a language like Haskell should be and feel like a professional tool. you don’t expect your large industrial drill to limit your abilities with safety features for hobbyists.
18:42:14 <copumpkin> sshc: it's easy with purity :P
18:42:26 <ezyang> "modding Haskell may void your warranty"
18:42:37 <j4cbo> EvilMachine: but "correctness" is not a "safety feature for hobbyists".
18:42:43 <HugoDaniel> :)
18:42:45 <greap> Hey. I'm getting the following error a lot: ghc: unrecognised flags: -I
18:42:45 <SamB_XP> EvilMachine: but you do expect safety features!
18:43:00 <j4cbo> the existence of unsafePerformIO constitutes an admission that a purely functional language is unsuitable for real-world use.
18:43:01 <greap> I'm trying to cabal install hmatrix
18:43:13 <HugoDaniel> i really like "purity", i was thinking about writing a pure jpg decoder/encoder in haskell
18:43:16 <copumpkin> j4cbo: you aren't serious are you?
18:43:23 <Berenlap> Three of the main features of haskell; lazyness, static typing, purity. Yet we've got seq, unsafeCoerce and unsafePerformIO, breaking all three
18:43:33 <EvilMachine> j4cbo: i did not say that. my point was, that the ability to also do something improperly, is a freedom. not that it’s a good idea to use it. :)
18:43:57 <j4cbo> copumpkin: i actually am :P
18:44:03 <HugoDaniel> these kind of things (encoders/decoders) can be very well expressed in a pure language...
18:44:06 <HugoDaniel> i think
18:44:23 <lament> EvilMachine: haskell is not just a language, it's an ideology, and the existence of unsafePerformIO refutes the ideology
18:44:35 <copumpkin> j4cbo: it's an admission that the platforms we run on are imperative and that we sometimes need to interface with them in referentially transparent manners that the compiler doesn't know about
18:45:00 <Saizan> j4cbo: unsafePerformIO is used only when you can demonstrate you don't expose an API that violates referential transparency
18:45:02 <copumpkin> j4cbo: as it stands, you sound like you're reciting reddit anti-haskell talking points
18:45:05 <EvilMachine> j4cbo: actually, i even prever to have a goto in my imperative language. since, if there is a situation, where it actually *is* the best way, and the programmer knows how to properly do it, it’s a good thing to have. we should not just remove it, because some people can’t handle it correctly. after all we’re professionals.
18:45:31 <Berenlap> EvilMachine: That kind of thinking leads to PHP
18:45:42 <Axman6> j4cbo: it's more of a recognition that C has no way of telling the compiler it is pure
18:45:51 <SamB_XP> Berenlap: you might think that
18:45:56 <HugoDaniel> Axman6: gcc has :)
18:45:57 <SamB_XP> until you have to use Python!
18:46:01 <j4cbo> EvilMachine: i can think of exactly one case where 'goto' is the right thing to use, and it's a damn good case
18:46:07 <luqui> I have been programming in haskell for years.  I am still finding new things that can be done purely that I thought could not.
18:46:13 <matsuura> hahaha @ SamB_XP
18:46:16 <luqui> pure functional programming is very *different*
18:46:20 <j4cbo> copumpkin: i have no idea what reddit thinks about haskell... i'm an ML programmer :P
18:46:24 <Axman6> HugoDaniel: the language doesn't
18:46:27 <luqui> and even the most experienced programmers are not sure what it can and cannot do
18:46:28 <EvilMachine> lament: while the ideology of haskell is great imo, you should not stay limited to it like a religion. it’s the reason that that ideology was created, that you should adhere to. not the rule. :)
18:46:57 <Berenlap> SamB_XP: Python has continuations, and by extension, every other feature ever thought of ;)
18:46:58 <copumpkin> j4cbo: either way, it sounds like a superficial opinion one comes up after hearing one or two things about the language with and then presents in a channel of 600 people to get a reaction out of them
18:47:03 <SamB_XP> EvilMachine: namely, purity makes it easier to understand your code, especially if you also use laziness?
18:47:12 <luqui> Berenlap, as long as those features have to do with control flow...
18:47:13 <sshc> copumpkin: what is a continuation?
18:47:16 <SamB_XP> Berengal: it still doesn't have "goto"
18:47:22 <HugoDaniel> i actually like "limiting" myself to haskell
18:47:30 <EvilMachine> copumpkin: then you’re not understanding me. I love haskell. As I said, i came to it, by noticing that it is exactly how my mind is wired.
18:47:38 <luqui> copumpkin, well noted!
18:48:11 <matsuura> haskell needs more concubines
18:48:14 <copumpkin> EvilMachine: I thought it was j4cbo who said it?
18:48:18 <EvilMachine> ok, let’s not get to flaming here. :) i know that this is a sensitive topic.
18:48:40 <EvilMachine> and we might just misunderstand each other a little bit too much because of the sensitivity. :)
18:48:42 <j4cbo> copumpkin: this is admittedly a third-hand story, but i'm told that at least one of the designers of haskell now thinks it should have been impure
18:48:42 <matsuura> EvilMachine: flaming is the new trolling, btw..
18:49:09 <matsuura> j4cbo: just one?
18:49:10 <EvilMachine> matsuura: flaming is trolling with more than one person involved. ^^
18:49:19 <matsuura> lies
18:49:26 <luqui> j4cbo, and there are some prominent haskell programmers making real things who think it is not pure enough
18:49:37 <j4cbo> luqui, "not pure enough"?
18:50:06 <matsuura> j4cbo: you know, like space not being spacious enough
18:50:10 <matsuura> something like that
18:50:16 <luqui> j4cbo, yeah.  the IO monad, undefined (and thus non-totality), unsafe*, the module system.  all forms of impurity.
18:50:51 <copumpkin> IO is remarkably coarse
18:51:07 <copumpkin> I would definitely love to make haskell more pure :)
18:51:08 <lament> Tired of things all happening at once? Introducing TIME!
18:51:08 * j4cbo nod
18:51:51 <Berenlap> IO is a toxic dump, but we need one of those for all the quantum chromodynamic exceptions people are going to invent in the future
18:52:10 <copumpkin> Berengal: a lot of what goes in it could probably be modeled more elegantly
18:52:17 <luqui> no i don't think we need it
18:52:22 <Berenlap> copumpkin: True
18:52:44 <luqui> It is unfortunate that main :: IO ()
18:52:47 <EvilMachine> luqui, j4cbo: you can’t make everyone happy. and that’s why there is a concept of choice. so everyone can choose, and nobody is limiting anybody’s freedom. if someone wants to use unsafe*,  because that’s how he gets it done, then let him. if someone thinks it’s a failure if you use it, and it should be banned, let him. a simple compiler pragma solves the whole discussion. :)
18:53:16 <luqui> EvilMachine, compiler pragma forks haskell the one language into haskell many languages.  which is one way of doing things.
18:53:20 <ben0x539> Is there a ByteString alternative that does not use unsafe*?
18:53:29 <j4cbo> EvilMachine: i think the statement should be "you can't mae everyone happy, and that's why there are other languages." :P
18:53:37 <luqui> EvilMachine, there is choice in the fact that if haskell is too pure for somebody, they can choose not to use it at all
18:54:00 <CalJohn> mmmm...this channel is normally so interesting to read
18:54:12 <Axman6> agreed
18:54:21 * luqui splashes his head with cold water
18:54:38 <SamB_XP> CalJohn: maybe 'cause usually we don't talk about Haskell ;-P
18:54:46 <Berenlap> Zygohistomorphic prepromorphisms!
18:54:51 <EvilMachine> lamemt: mathematicians don’t like time.. ;)
18:54:54 <Saizan> there are surely many ways to keep track of effects, http://www.haskell.org/haskellwiki/DDC uses a quite different one from standard haskell
18:55:16 <j4cbo> if you're serious about proving properties of your programs, you'll write them in Coq or Twelf anyway :P
18:55:25 <luqui> EvilMachine, physicists do.  but they don't talk about it imperatively.
18:55:51 <luqui> the universe is not running on a von neumann machine
18:55:55 <luqui> (well, i can't be certain of that)
18:55:56 <Axman6> j4cbo: you really are a pretty terrible troll :/
18:56:18 <EvilMachine> j4cbo: well, technically, one could say, that trough compiler pragmas, Haskell *is* many languages. They are just so closely related that it makes sense to put them in one compiler. By the way: I’m all for merging the parts of the compiler, that is common to a set of languages. :)
18:56:20 <j4cbo> Axman6: aww, thanks <3
18:56:21 <Axman6> where did all the good trolls go?
18:56:50 <Berenlap> Axman6: I'm right here
18:56:56 <j4cbo> EvilMachine: i think you are what we call a "fanboy".
18:56:59 * copumpkin climbs out from under his bridge
18:57:19 <Axman6> we're all fanbiys
18:57:21 <EvilMachine> luqui: but reality is not black and white, either and or. sometimes, “haskell with a bit of wierdness and this feature being different” is what you need. not pure haskell, and not something else entierly. :)
18:57:24 <SamB_XP> Berenlap, copumpkin: you are trolls? since when?
18:57:34 <EvilMachine> j4cbo: uum, please?
18:57:35 * copumpkin clubs j4cbo over the head and carries him back under the bridge with him
18:57:36 <Berenlap> SamB_XP: We're the good trolls. We're ninja.
18:57:46 <j4cbo> EvilMachine, just because you can write any language in any other language doesn't mean you should
18:57:56 <EvilMachine> j4cbo: of what would that be? if i’m a fanboy of haskell, i’m proud of it. :D
18:58:06 <luqui> EvilMachine, yeah i guess.  though i would like whatever i need to be definable in terms of a common base.  every library is a language extension.
18:58:19 <dolio> I don't think you'll write your programs in twelf.
18:58:21 <copumpkin> j4cbo: are you trying to be inflammatory?
18:58:21 <luqui> lispers change their language without changing the language all the time
18:58:34 <BMeph> Coming soon to SNK: NinjaTROLL!
18:58:43 <luqui> copumpkin, haven't we already decided this?
18:59:04 <copumpkin> luqui: I'm curious if he's deliberately doing it
18:59:43 <luqui> oh: "are you *trying* to be inflammatory" rather than "are you trying to be *inflammatory*"
18:59:49 <j4cbo> i'm trying to inflame people like EvilMachine, because i'm genuinely offended by people who believe that one set of PL design decisions is The Way And The Light
19:00:00 <Axman6> can we just ban j4cbo and get it over with? he's contributibg noyhing to the discussion of any value whatsoever
19:00:07 <luqui> j4cbo, take a flamethrower to me!
19:00:07 <EvilMachine> j4cbo: i always try to use the best language for the task. the only thing i don’t like, is that I can’t combine them in one program as easily as i want to. :)
19:00:27 <copumpkin> j4cbo: there's good discussion to be had about that kind of stuff, but fire isn't the way to go about it
19:00:30 <EvilMachine> luqui: agreed about the libraries
19:00:57 * copumpkin pulls out his fire extinguisher
19:01:05 * copumpkin sprays j4cbo with it
19:01:17 <EvilMachine> luqui: but for haskell, i noticed that it’s more extreme than with other languages i know. in haskell, sometimes a library looks like a whole new language. which is kinda cool, to know that it’s that free.
19:01:23 <j4cbo> ok, discretion, better part of valour, etc
19:01:32 <lament> :-)
19:01:34 <sjanssen> I'm checking out this clutter library, looks pretty spiffy http://github.com/elliottt/clutter
19:01:47 * BMeph is now imagining copumpkin playing Adam Sandler's role in that "Chuck and Larry" movie...
19:01:48 <SamB_XP> but is discreteness the better part of value ?
19:01:59 <luqui> EvilMachine, i'm finding that Haskell is very good at doing new things if you can give them a mathematical semantics.
19:02:01 <sjanssen> I wonder if they've bound the stuff necessary to composite X windows :)
19:02:04 <Axman6> sjanssen: whats ir do?
19:02:10 <monochrom> "clutter" is a funny name for a library.
19:02:11 <lament> EvilMachine: you will love forth, the
19:02:13 <lament> then
19:02:16 <luqui> EvilMachine, its policy seems to be, if you can't give it a semantics, you shouldn't be doing it
19:02:19 <luqui> IO excepted, of course
19:02:43 <EvilMachine> j4cbo: my friend, you definitely misunderstood me. i am, just as you, offended by the idea of there being “One True Way”. I’m on your side on this. :)
19:03:03 <copumpkin> j4cbo: our main problem is that pure FP is sufficiently different from even impure FP that we tend to get a little annoyed if someone shows up and presumes to be able to speak about a language we enjoy (in sweeping generalizations, no less) without any knowledge of anything but impure FP
19:03:05 <luqui> some ways are *definitely* better than others though
19:03:06 <sjanssen> Axman6: a graphics toolkit that abstracts OpenGL
19:03:09 <luqui> in a general sense
19:03:13 * SamB_XP tries to remember if he is an adherant to the One True Brace Style
19:03:29 <Axman6> sjanssen: sounds nice
19:03:31 <sjanssen> Axman6: have you seen the new WM in GNOME?  This library is behind that
19:03:32 <EvilMachine> luqui: yes.
19:04:07 <Axman6> i try to avoid gnome and kde
19:04:12 <Nafai> Yeah, clutter is pretty cool
19:04:14 * BMeph isn't offended by people asserting a "One True Way" for things. He just wishes they would kill themselves, then come back from the dead to prove it...
19:04:15 <EvilMachine> lament: forth… it’s too low-level for me. :)
19:04:23 <theoros> :)
19:04:25 <luqui> so just because there is no One True Way (because a belief in such will stifle innovation), does not imply that all ways are equal.
19:04:26 <lament> :-)
19:04:32 <copumpkin> j4cbo: many of us don't think pure FP is the one true way (or at least, if it is, that we definitely haven't worked out all the details yet)
19:04:33 <monochrom> Oh! "clutter" is not a library for removing the need for a configure script!
19:04:42 <copumpkin> j4cbo: but it's my favorite way so far
19:05:26 <EvilMachine> BMeph: lol. ^^
19:05:27 <copumpkin> j4cbo: for what it's worth, twelf is pure too
19:05:37 <Axman6> copumpkin: quit encouraging him
19:05:43 <EvilMachine> luqui: agreed
19:06:02 <copumpkin> Axman6: how am I encouraging him? I'm trying to be reasonable with him rather than screaming "zomg you're being a troll"
19:06:08 <luqui> Axman6, some of us like firefighting :-)
19:06:13 <Berenlap> @quote least.broken
19:06:13 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
19:06:15 <theoros> :)
19:06:19 <Berenlap> ^^ My opinion
19:06:28 <lament> @quote
19:06:29 <lambdabot> <monochrom> says: All pointless debates can be settled by going polymorphic.
19:06:35 <luqui> Haskell is the worst programming language
19:06:37 <luqui> aside from all the others
19:06:42 <monochrom> Hahahaha how timely.
19:06:51 <copumpkin> :)
19:06:56 <monochrom> lambdabot has awareness of what's happening!
19:06:57 <lament> luqui: that just suggests that programming is pretty terrible
19:07:09 <Berenlap> We must now discuss language "forall a. a"
19:07:10 <SamB_XP> lament: do you deny it ?
19:07:17 <EvilMachine> Axman6: a little tip for dealing with a troll: just like the bully in the real world, the best tactic is, to befriend him. *then* you can change his behavior. ^^
19:07:20 <lament> SamB_XP: yes. I like programming
19:07:33 * CalJohn is le sigh
19:07:36 <lament> EvilMachine: let's be friends!
19:07:44 <EvilMachine> LOL
19:07:47 <SamB_XP> lament: he's trolling ?
19:07:48 <theoros> LOL
19:07:48 <copumpkin> let's be facebook friends!
19:07:54 <copumpkin> facebook.com/haskelltroll is my profile
19:07:55 <SamB_XP> lolololo
19:07:56 <luqui> o/~ why can't we be friends o/~
19:07:56 <tensorpudding> let's be friends with benefits!
19:08:07 <j4cbo> Berenlap's point about backdoors into the runtime system is interesting... a lot of nontrivial programs (especially the sorts of stuff i've been doing lately) involve some sort of manipulation across abstraction boundaries
19:08:16 * EvilMachine changes relationship status to: “it’s complicated” :D
19:08:23 <luqui> j4cbo, what sorts of stuff?
19:08:51 <j4cbo> luqui: operating system kernels
19:09:16 <copumpkin> j4cbo: not considered the most elegant examples of abstraction
19:09:26 <HugoDaniel> stuff like this: http://www.securityfocus.com/bid/37521 ?
19:09:58 <EvilMachine> So would a Haskell OS be called Hos? :D
19:10:03 <theoros> :D
19:10:03 <copumpkin> House, actually
19:10:05 <HugoDaniel> :D
19:10:10 <lament> :D
19:10:14 <copumpkin> :D
19:10:27 <Axman6> j4cbo: it's not likw there haven't been a few of those written in haskell
19:11:09 <j4cbo> copumpkin: exactly, because there isn't exactly a clean split of responsibilities or definitions between the language, the standard library, the ABI, the architecture...
19:11:22 <HugoDaniel> sleepy time for me, happy 2010 everybody
19:11:25 <copumpkin> j4cbo: I'm not sure what that really contributes to the discussion though
19:11:40 <McManiaC> Proxy: <<loop>>
19:11:53 <copumpkin> McManiaC: GHC has a halts? function
19:11:54 <McManiaC> what does this error message mean (Proxy is the programs name)
19:11:54 <EvilMachine> copumpkin: what discussion? ^^
19:12:08 <j4cbo> it's another "we definitely haven't worked out all the details yet" topic
19:12:14 <copumpkin> EvilMachine: the benefits/drawbracks of purity
19:12:18 <McManiaC> copumpkin: ?
19:12:18 <EvilMachine> ah ok.
19:12:21 <Berenlap> McManiaC: You have an infinite loop
19:12:22 <Saizan> McManiaC: it means you've an infinite loop in your program
19:12:31 <McManiaC> hm :S
19:12:31 <McManiaC> okay
19:12:34 <EvilMachine> copumpkin: i think we’re trough with that, though. :)
19:12:39 <copumpkin> oh
19:12:48 <theoros> :)
19:13:08 <EvilMachine> copumpkin: i think we agreed to not agree and go polymorphic, or something like that.
19:13:16 <Saizan> test :D
19:13:23 <copumpkin> oh, okay
19:13:23 <lament> :D
19:13:27 <copumpkin> :D
19:13:32 <theoros> :D
19:13:40 <Axman6> McManiaC: it usually means you have a loop of threads waiting on each other (through mvars or something)
19:13:41 <Saizan> ok, you are all bots.
19:13:48 * SamB_XP zaps his wand of polymorph anyway
19:13:52 <copumpkin>  /mode +o Saizan
19:13:55 <copumpkin> Saizan bans all bots
19:13:58 <McManiaC> Axman6: ok… that thread thing is tricky :S
19:14:00 <monochrom> McManiaC: the runtime can detect some very simple infinite loops such as "x=x", basically clearly cyclic definitions.
19:14:15 <EvilMachine> Saizan: How does it make you feel that, ok, we all are bots? :D
19:14:18 <j4cbo> SamB_XP: You feel shuddering vibrations.
19:14:19 <copumpkin> it's a lot simpler than that
19:14:20 <lament> :D
19:14:37 <lament> Saizan: perhaps it's you who is the bot
19:14:45 <Saizan> lament: i am
19:14:51 <copumpkin> they call him banbot
19:15:05 <monochrom> :)
19:15:06 <copumpkin> he rules with an iron fist
19:15:10 <Axman6> monochrom: i don't think it will tell you about that. it does trach mvar cas thkugh
19:15:25 <EvilMachine> do we have a captcha at hand?
19:15:25 <copumpkin> Axman6: no, it does
19:15:31 <SamB_XP> > let x = x in x
19:15:35 <lambdabot>   mueval-core: Time limit exceeded
19:15:39 <copumpkin> only when compiled :)
19:15:40 <SamB_XP> wha?
19:15:43 <SamB_XP> oh
19:15:46 <SamB_XP> dumb!
19:16:43 <Axman6> u've never been frustrated with channel until today. i'm off
19:16:53 <Axman6> i've*
19:16:55 <luqui> Axman6, is storming off in a hissy
19:16:59 <luqui> everyone pay attention
19:17:13 * EvilMachine watches
19:17:15 <Axman6> :/
19:17:16 <copumpkin> Axman6: what frustrated you?
19:17:26 <copumpkin> I thought the frustrating stuff had stopped
19:17:49 <McManiaC> does Exception.Catch also catches the threads of the children?
19:17:49 <Axman6> it has, but i need breakfast
19:17:52 <SamB_XP> lambdabot: I knew you shouldn't have drunk so much at that newyears party!
19:17:56 <McManiaC> (forkIOs)
19:18:00 <dark> there are good parallel implementations of haskell? (ocaml isn't because of the gc)
19:18:03 <monochrom> perhaps frustrated that physics is banned but language crackpotting is not
19:18:36 <luqui> monochrom, that is a good point
19:18:37 <Saizan> McManiaC: it won't catch exceptions that occur in forked threads
19:18:38 <Axman6> dark: ghc's parallel implemwntation is fantastic
19:18:40 <EvilMachine> *g*
19:18:45 <McManiaC> Saizan: ok
19:19:06 <luqui> it's okay to impassionately argue about bullshit, but for god sake DO NOT GO OFF TOPIC
19:19:34 * EvilMachine can help out with the general navigation of physics questions, and direct to the right places, though.
19:20:00 <copumpkin> luqui: so, about that tomato farming I wanted to do. Do you have any recommendations on what kind of copper sulphate to use?
19:20:01 <lament> EvilMachine: why does it become bright when i flip the light switch on?
19:20:07 <dark> Axman6, does it have a good framework for handling race conditions/deadlocks without explicit mutexes/semaphores/etc?
19:20:27 <EvilMachine> lament: do you want the short 3 hour explanation, or… ;)
19:20:31 <idnar> luqui: omg we're having an off-topic discussion RIGHT NOW!
19:21:27 <luqui> EvilMachine, the existence of physics question constitutes an admission that physics is unsuitable for real-world use
19:21:37 * EvilMachine directs lament to the wikipedia articles about electricity, newtonian mechanics (switch) [suffices], and optics [light bulb / room ] :D
19:21:44 <lament> EvilMachine: I want an epistemological explanation, if possible
19:21:52 <luqui> existential is okay too
19:21:53 <idnar> lament: nothing can travel faster than the speed of light
19:21:55 <Axman6> dark: yes
19:22:13 <luqui> I CAN!
19:22:17 <idnar> lament: in order to demonstrate this, try to open the fridge door before the light comes on
19:22:23 <dark> Axman6, :) i might learn haskell..
19:22:32 <luqui> i knew you were going to say that
19:22:35 <EvilMachine> lol
19:22:46 <idnar> shucks, I'm becoming predictable in my old age
19:22:55 <dark> Axman6, what about o'haskell? (i am reading about it right now, didn't knew about it before)
19:23:05 <copumpkin> dark: we don't talk about that here.
19:23:13 <copumpkin> dark: it's off-topic and abominable
19:23:16 <dark> why?
19:23:19 <dark> wow.
19:23:20 <copumpkin> dark: much better to talk about tomatoes :)
19:23:23 <SamB_XP> how is it off-topic ?
19:23:23 <medfly> there's always #haskell-blah
19:23:30 <dark> an object-oriented imperative language, enhanced with
19:23:32 <SamB_XP> I thought it was just not very good ?
19:23:33 <EvilMachine> well, the electron that was the first to move when you flipped the switch in the morning, will likely reach the light bulb by the time you go home from work again.
19:23:38 <dark> that's why it's abominable copumpkin?
19:23:44 <medfly> I'm told that while you can talk non-Haskell stuff, you can do that only if it's CS/mathematics.
19:23:48 <idnar> snow'haskell
19:24:02 <copumpkin> dark: absolutely. if there were a 10th ring of hell, it would be reserved for people trying to merge OO with pure FP
19:24:09 <SamB_XP> EvilMachine: why would the first electron to move have been in the switch ?
19:24:14 <monochrom> Ahem
19:24:34 <copumpkin> lucifer himself wouldn't touch it
19:24:44 <copumpkin> and trust me, he's touched a lot of nasty stuff
19:24:48 <dark> copumpkin, ... but ocaml have an *excellent* model for purely-functional OO, such as "return this same object, changing some things on it"
19:24:56 <EvilMachine> copumpkin: what if i tell you about that hidden object system in pure Haskell? will your head explode? ^^
19:24:57 <idnar> copumpkin: they don't call him the light bringer for nothing!
19:25:00 <copumpkin> dark: that's not OO
19:25:05 <dark> copumpkin, and with row types etc
19:25:05 <copumpkin> dark: we can do that too easily
19:25:06 <dark> hmmmm.
19:25:08 <j4cbo> dark: i don't think that qualifies as "an excellent model" :P
19:25:10 <EvilMachine> SamB_XP: IF it were.
19:25:28 <dark> j4cbo, ok :P
19:25:33 <idnar> Haskell has record update syntax
19:25:33 * EvilMachine was touched by lucifer. *cries*
19:25:34 <Saizan> copumpkin: we miss row types
19:25:37 <idnar> but yeah, that has nothing to do with OO
19:25:48 <roconnor> @seen dcotts
19:25:48 <lambdabot> Unknown command, try @list
19:25:53 <dark> does haskell have row types?
19:25:59 <copumpkin> dark: nope
19:26:01 <copumpkin> and we love it that way
19:26:03 <Saizan> preflex: seen dcoutts
19:26:04 <preflex>  dcoutts was last seen on #haskell 2 days, 13 hours, 27 minutes and 32 seconds ago, saying: Raevel: your main modules do not need to be called Main.hs
19:26:07 <copumpkin> I LOVE HASKELL'S RECORD SYSTEM!!!!
19:26:13 <monochrom> I don't love it that way.
19:26:16 <dark> would it broke something copumpkin?
19:26:27 <copumpkin> dark: probably.
19:26:36 <copumpkin> sorry, I'll stop being useless :)
19:26:40 * copumpkin retires
19:26:50 <dark> @.@
19:26:50 <lambdabot> Maybe you meant: . @
19:26:53 <EvilMachine> haskell has a record system?
19:27:05 <monochrom> But I wonder why we even care to talk about this. The original question was: how does o'haskell treat race conditions. Why do you bother to debate over OO.
19:27:26 <dark> monochrom, i don't bother, really.
19:27:30 <Saizan> dark: there has been a few proposals about extensible records, none that got implemented in a compiler though
19:27:36 <idnar> wait what
19:27:39 <EvilMachine> monochrom: that’s what fundamentalism does for you. :(
19:27:39 <dark> my question probably was: does o'haskell runs on ghc?
19:28:15 <monochrom> No.
19:28:29 * gwern groans at M-x butterfly
19:28:37 <gwern> I upgraded for the fonts, not M-x butterly
19:28:40 <SamB_XP> gwern: what, they added one ?
19:28:40 <dark> ok. they extended hugs, but didn't created their own compiler?
19:28:41 <EvilMachine> dark: it’s actually quite easy to get pretty much all the things that are good in OO in haskell, by slightly different means.
19:28:44 <gwern> SamB_XP: yeah
19:28:51 <roconnor> help!
19:28:51 <SamB_XP> does it WORK ?
19:28:58 <dolio> O'Haskell is dead, isn't it?
19:28:59 <SamB_XP> do you have a girlfriend now ?
19:29:01 <dark> EvilMachine, I actually don't like OO that much
19:29:06 <dolio> For years, presumably.
19:29:09 <medfly> O'Haskell appears dead.
19:29:19 <Saizan> roconnor: ?
19:29:21 <EvilMachine> dark: ok, i guess that statement wil get you friends around here. :D
19:29:21 <dolio> I mean, it was dead back when I started learning Haskell.
19:29:26 <CalJohn> i think o'haskell is very very dead
19:29:27 <SamB_XP> dolio: same ;-P
19:29:35 <SamB_XP> it's been dead for seemingly ever
19:29:38 <Cale> It lives on in Timber?
19:29:51 <Cale> Or is Timber dead too?
19:29:56 <roconnor> Saizan: ghc-pkg is failing for me
19:29:57 <EvilMachine> it is undead
19:30:09 <dolio> I don't know. But Timber is kind of domain specific, isn't it?
19:30:12 <EvilMachine> o’haskell eats your brain when you sleep
19:30:12 <Saizan> roconnor: how?
19:30:13 <gwern> SamB_XP: it's just a screen flash and a message of course
19:30:15 <medfly> is it sitting somewhere in an old persons home?
19:30:25 <Cale> timberc is on Hackage :)
19:30:25 <dark> EvilMachine, hahahahaha. I once used it on ocaml and I stopped in a part I had to do type annotations (when a object needs to pass itself to a function). I found it ugly and gave up
19:30:27 <SamB_XP> gwern: so no girlfriend ?
19:30:27 * EvilMachine spreads fear about o’haskell. ;)
19:30:33 <gwern> no
19:30:43 <gwern> guess I'll have to go back to vim
19:30:46 <roconnor> $ ghc-pkg --user update /tmp/csv-0.1.124972/csv-0.1.1/dist/installed-pkg-configReading package info from "/tmp/csv-0.1.124972/csv-0.1.1/dist/installed-pkg-config" ... done.
19:30:47 <roconnor> csv-0.1.1: dependency parsec-2.1.0.1 doesn't exist (use --force to override)
19:30:56 <roconnor> byt the
19:31:12 <roconnor> Saizan: But parsec is installed
19:31:21 <roconnor> and appears in ghc-pkg list
19:31:29 <Saizan> with that version?
19:31:45 <EvilMachine> gwern: there is a VI mode for emacs (obviously).
19:32:00 <roconnor> /nix/var/nix/profiles/per-user/roconnor/profile/bin/../lib/ghc-pkgs/ghc-6.10.4/parsec-2.1.0.1.installedconf:
19:32:01 <roconnor>     {parsec-2.1.0.1}
19:32:05 <EvilMachine> gwern: after al, Emacs is a nice OS. It only lacks a decent text editor. :D
19:32:19 <EvilMachine> +l
19:32:25 <gwern> EvilMachine: your jokes are staler than my great-grandmother's heirloom fruitcake
19:32:34 <Veinor> Guys, I heard emacs uses EIGHT WHOLE MEGABYTES of memory :O
19:32:39 <EvilMachine> gwern: i don’t care. :D
19:32:41 <Saizan> roconnor: when it's in braces like that it means it's broken iirc, see what ghc-pkg check tells you
19:32:48 <dark> Veinor, it was on 80's
19:32:52 <gwern> Veinor: blows the competition out of the water, eh?
19:32:58 <dark> Veinor, today it's more like 80mb
19:33:00 <Axman6> urgh, what has happened to this channe? >_<
19:33:00 <EvilMachine> Veinor: how many megabytes is a butterfly?
19:33:11 <Axman6> l*
19:33:14 <btutt_> Saizan: That really helped me figure out how to change the code. Thanks!
19:33:16 <Veinor> Eighty Megabytes And Constantly Swapping?
19:33:23 --- mode: ChanServ set +o monochrom
19:33:25 <medfly> 80mb? I should stick to vim!
19:33:32 <monochrom> Anyone wants the first ban of year 2010?
19:33:33 <SamB_XP> Veinor: only if you also use firefox, but yes ;-P
19:33:45 <Saizan> btutt_: np, i had to do the same for a package of mine not so long ago :)
19:33:51 <EvilMachine> Axman6: i suggest you start a new discussion about something that you think should be discussed here instead. maybe people will follow and you get it fixed. :)
19:34:00 <SamB_XP> medfly: only if you open way too many files, I *think*
19:34:10 <airbrush> you seen this? http://www.gnu.org/fun/jokes/vi.song.html
19:34:15 <gwern> he didnae deserve the first ban
19:34:21 <gwern> aweel
19:34:23 <roconnor> Saizan: oh
19:34:40 <SamB_XP> gwern: did he GET a ban?
19:34:46 <SamB_XP> I don't SEE any bannage
19:34:48 <copumpkin> nope
19:34:50 <copumpkin> just got removed
19:34:51 <monochrom> That was the first remove instead <duck>
19:34:57 <gwern> a kick or remove then, laddie
19:34:58 <roconnor> Saizan: they are all broken :(
19:34:59 <SamB_XP> just kickage
19:35:14 <SamB_XP> oh, what's "removage"?
19:35:22 <monochrom> Ahem.
19:35:54 <roconnor> Saizan: they are all missing lib64 directories .. but I don't have a 64 bit computer.
19:36:10 <Axman6> so, cereal is a fantastic package. you should all use cereal
19:36:39 * Cale guesses that it's a library for computable reals?
19:36:42 <Saizan> roconnor: not sure what would cause that
19:36:42 <Axman6> i'm thinking of releasing a package of nice combinators for use with it, to make it more parsec like
19:37:09 <Saizan> Axman6: isn't it limiting that it works only on strict bytestrings and doesn't accept input incrementally?
19:37:15 <roconnor> Saizan: but at least I'm further along
19:37:26 <monochrom> cereal is a binary serialization library. is on hackage.
19:37:28 <DigitalKiwi> monochrom: can I be the first ban but you unban me later?
19:37:33 <Axman6> Cale: it's like binary, but far more useful (having an Alternative instance for its Get monad, allowing you to easily write things like many :: Get a -> Get [a]
19:37:51 <Axman6> Saizan: yeah i do wish it would also work on lazy bytestrings
19:37:53 <SamB_XP> DigitalKiwi: you'll need to troll better than that ...
19:37:56 <Cale> Does it handle failed parses in a more useful way? :)
19:38:15 <Axman6> yes
19:38:34 <DigitalKiwi> SamB_XP: oh
19:38:49 <Axman6> Cale: the decode function returns an Either String a
19:38:58 <Cale> Cool, since that was the one thing I kept seeing Binary fall down on with various people from this channel.
19:39:02 <DigitalKiwi> monochrom: your mother was an elderberry and your father smelled of hampsters
19:39:22 <ben0x539> How does a binary parse fail?
19:39:40 <Cale> ben0x539: When the data is incomplete, for instance.
19:39:44 <SamB_XP> ben0x539: the wrong bytes were present ?
19:39:54 <monochrom> for example expect magic number but get wrong number
19:39:55 <Axman6> Cale: basically, cereal solves most of the major problems with using binary for parsing, instead of just serealising and deserealising haskell data
19:40:15 <Cale> That's a curious spelling :)
19:40:23 <ben0x539> cerealising.
19:40:32 <dark> Hugs 98 is a functional programming system based on Haskell 98, the de facto standard for non-strict functional programming languages.
19:40:37 <monochrom> ieee 754 floating point format is also binary and there are invalid bit patterns.
19:40:39 <dark> why is haskell called "non-strict"?
19:40:43 <ben0x539> (Is that not where you would wrap ErrorT around the Get monad?)
19:40:48 <tensorpudding> it's lazy
19:40:51 <medfly> dark: it's not strict. it's lazy
19:40:58 <tensorpudding> for instance
19:41:05 <dark> thank you
19:41:07 <Axman6> medfly: well, more correctly, it's non-strict
19:41:08 <Saizan> dark: lazy is a pretty specific evaluation strategy
19:41:12 <monochrom> dark: because if you define "f x = 5" then "f (infinite loop here)" gives you 5.
19:41:13 <tensorpudding> > False || undefined
19:41:15 <lambdabot>   * Exception: Prelude.undefined
19:41:15 <DigitalKiwi> strict == eager?
19:41:16 <medfly> okay, it's non-strict.
19:41:16 <Saizan> dark: non-strict is more general
19:41:22 <tensorpudding> > True || undefined
19:41:23 <lambdabot>   True
19:41:36 <Axman6> dark: being non strict allows us to work very easily with things like infinite lists
19:41:37 <dark> i was thinking of "not purely functional". i know about strict evaluation
19:41:38 <CalJohn> tensorpudding: that is True is almost any language ;)
19:41:40 <Axman6> > [1..]
19:41:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:41:43 <sshc> > True || !undefined
19:41:44 <tensorpudding> maybe so
19:41:45 <lambdabot>   <no location info>: parse error on input `!'
19:41:45 <Axman6> > [1..] !! 12345
19:41:46 <lambdabot>   12346
19:41:47 <dmhouse> dark: have a look at the first couple of paragraphs of http://en.wikibooks.org/wiki/Haskell/Laziness
19:41:47 <dark> yeah i loved it
19:41:51 <Axman6> > [1..] !! 12345789
19:41:52 <lambdabot>   12345790
19:41:53 <tensorpudding> well, not true
19:41:55 <dmhouse> *couple of sections
19:41:58 <tensorpudding> since most languages don't have undefined
19:42:00 <sshc> > True || !undefined
19:42:02 <lambdabot>   <no location info>: parse error on input `!'
19:42:12 <dark> some people say it makes program analysis harder (for human beings), especially memory requirements
19:42:17 <sshc> how do I make the second argument scrictly evaluated?
19:42:17 <Cale> Lazy refers to a specific evaluation strategy which produces non-strict semantics.  Non-strictness really refers to the fact that you can apply functions to undefined data and nonetheless get defined results. (Which roughly means that functions don't necessarily evaluate their parameters)
19:42:17 <dibblego> tensorpudding, few languages don't have undefined; they are usually theorem provers
19:42:24 <dmhouse> tensorpudding: well, you could throw an exception or something
19:42:29 <dark> but I guess your opinions about this subject would differ
19:42:37 <idnar> tensorpudding: you can write an infinite loop in most languages :P
19:42:40 * dmhouse points at http://en.wikibooks.org/wiki/Haskell/Laziness again to expand on Cale's points
19:43:01 <Cale> dark: It's not really that bad. It is a little harder, but by no means intolerable.
19:43:06 <tensorpudding> well, you can write code that returns bottom, but that doesn't mean that it is undefined
19:43:10 <dark> you can write infinite loops in any turing-complete language
19:43:13 <dmhouse> (The first 3 sections are pretty applicable to anyone that's interested.)
19:43:16 <dibblego> few languages have Prelude.(||) as a library function
19:43:21 <Cale> dark: The benefits of lazy evaluation and nonstrict semantics far outweigh the costs :)
19:43:30 <idnar> @src undefined
19:43:30 <lambdabot> undefined =  error "Prelude.undefined"
19:43:46 <dibblego> tensorpudding, undefined *is* bottom written in ASCII
19:44:12 <Cale> dark: Strict evaluation forces you to write programs in unnatural and not-very-compositional ways. Effectively lazy evaluation gives you the advantage of being able to reuse code more effectively.
19:44:24 <dark> Cale, hmmm
19:44:34 <monochrom> such as consumer-producer
19:44:43 <idnar> > (||) $! True $! undefined
19:44:44 <lambdabot>   Couldn't match expected type `a -> b'
19:44:44 <lambdabot>         against inferred type `GHC.Bo...
19:45:10 <Axman6> > (||) True $! undefined
19:45:10 <lambdabot>   * Exception: Prelude.undefined
19:45:32 <monochrom> There is a paper on how it flies for constraint satisfaction algorithms, which are full of producer-filter-consumer.
19:45:37 <caxaf> Caleskell has a left-associative $!, correct?
19:45:45 <dark> Cale, I guess this depends on the ability of the programmer on handling with this. programming might be affected by the force of habit
19:45:48 <Cale> caxaf: It would, if it existed.
19:46:01 <dark> what does Prelude.(||) do?
19:46:06 <medfly> it's OR
19:46:08 <medfly> :-)
19:46:12 <monochrom> short-ciruit
19:46:21 <Cale> @src (||)
19:46:22 <lambdabot> True  || _ =  True
19:46:22 <lambdabot> False || x =  x
19:46:26 <dark> well, many languages have the short-circuiting or as a library function... o.o
19:46:27 <Cale> ^^ the source code :)
19:46:33 <Saizan> monochrom: do you have a link to that paper?
19:46:40 <Cale> It's just a library function
19:46:41 <dark> hmm nice :)
19:46:47 <monochrom> No, I don't even remember the title and the authors!
19:46:48 <SamB_XP> dark: how so ?
19:46:52 <dark> in ocaml it's a library function too
19:46:57 <dark> i... think
19:47:08 <Cale> They might have to do something clever to get it to be lazy
19:47:11 <monochrom> I'll have to first think which keywords will help me google...
19:47:12 <j4cbo> the "strict is always better than lazy" argument is not universally accepted - in particular, the "reasoning about time and memory" problem is sometimes considered very serious
19:47:18 <j4cbo> but i will say no more :P
19:47:28 <dark> Hmmm. no. it's not a function
19:47:36 <Cale> j4cbo: The reasoning about time and memory problem that strict programming has? ;)
19:47:41 <dark> exactly because of that, Cale
19:47:51 <Cale> dark: right
19:47:59 <SamB_XP> C++ is the same
19:48:01 <Saizan> monochrom: ah, wait, it's the one which describes failfirst and similar techniques as composable tree traversals?
19:48:06 <dancapo> Hello
19:48:13 <j4cbo> Cale: you know exactly what i mean.
19:48:19 <monochrom> I don't know.
19:48:37 <idnar> I don't think reasoning about time and memory is harder in lazy programming
19:48:41 <Cale> j4cbo: Well, you said the "strict is always better than lazy" argument ;)
19:48:44 <dancapo> I'm trying to wrap my mind around an algorithm which is not doing what I expected it to. Is there any way to trace the execution of a function?
19:49:03 <dibblego> I think making mistakes with time and memory is easier in lazy programming; the solution is to stop making mistakes
19:49:10 <dark> does || evaluates from left-to-right? oh nevermind this shouldn't matter with functional languages
19:49:11 <Axman6> dancapo: ghci has a debugger
19:49:14 <Cale> But yeah, I would say that strict evaluation is what you want in around 1/4 of the cases, possibly
19:49:18 <SamB_XP> dibblego: oh, what a solution!
19:49:22 <medfly> what I like about Haskell, is that if you need strict evaluation, then you can have it, too.
19:49:23 <idnar> if you already know how to reason about time and memory in strict programming, but you haven't learned how to do it in lazy programming, then sure, that's some extra learning you need to do
19:49:36 <dibblego> SamB_XP, it seems obvious doesn't it? Yet so many choose a different option
19:49:37 <Cale> dark: Right, it *mostly* doesn't matter, but yes, it evaluates left to right
19:49:43 <monochrom> There is good chance it is "Modular Lazy Search for Constraint Satisfaction Problems" http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5440
19:49:49 <Cale> dark: It pattern matches the first parameter first, as you can see there
19:49:50 <idnar> dark: it sort of is important, if one of the arguments is bottom
19:49:56 <idnar> > undefined || True
19:49:58 <lambdabot>   * Exception: Prelude.undefined
19:50:01 <idnar> > True || undefined
19:50:03 <lambdabot>   True
19:50:03 <Cale> dark: and only if that's False, the result is the second parameter
19:50:08 <idnar> so you might say that (||) is left-biased
19:50:10 <dark> I am trying to understand if some_code_that_does_i/o || True and True || some_code_that_does_i/o does the same thing. Yeah I neve understood monads / haskell's i/o very well .-.
19:50:22 <Axman6> > False || (1/0 == 4)
19:50:22 <lambdabot>   False
19:50:25 <dark> Hmmm.
19:50:27 <Cale> dark: Evaluation of expressions doesn't (normally) cause I/O
19:50:28 <Axman6> > False || (0/0 == 4)
19:50:29 <lambdabot>   False
19:50:37 <Axman6> > False || (0/0 == NaN)
19:50:37 <Cale> dark: It just reduces expressions into other expressions.
19:50:38 <lambdabot>   Not in scope: data constructor `NaN'
19:50:41 <Axman6> :(
19:50:51 <dark> Cale, what is a function does i/o?
19:51:00 <dark> the evaluation of the function will trigger the i/o
19:51:01 <Cale> dark: We encode IO actions as values.
19:51:06 <kmc> dark, no such thing
19:51:06 <Cale> (of a different type)
19:51:09 <kmc> aside from some hacks
19:51:13 <Axman6> dancapo: you can't do someIOCode || somePureCode, the types ju7st won;t let you
19:51:14 <ben0x539> @check not . isNan
19:51:15 <lambdabot>   Not in scope: `isNan'
19:51:20 <ben0x539> @check not . isNaN
19:51:21 <Axman6> uh, dark, not dancapo
19:51:21 <lambdabot>   "OK, passed 500 tests."
19:51:25 <Cale> :t getLine
19:51:26 <lambdabot> IO String
19:51:45 <dark> [ I really don't understand - and I already read many, many monads tutorials. In OCaml too ]
19:51:48 <Cale> ^^ this is an abstract representation of an action which if you were to execute it, would get a line of text from the user, and produce a String
19:51:54 <Axman6> dark: functions can't perform IO
19:51:55 <kmc> dark, evaluation of a function cannot do IO.  but a function can return a "recipe" for doing IO
19:51:57 <Cale> Don't worry about monads
19:52:07 <Cale> The fact that IO is a monad is mostly irrelevant.
19:52:10 <dibblego> dark, monads and I/O are two very distinct matters, with a small overlap
19:52:14 <dark> So if a function can't perform i/o, who will perform i/o?
19:52:20 <kmc> dark, the execution of an IO action
19:52:23 <kmc> what i called a "recipe"
19:52:27 <kmc> execution != evaluation
19:52:41 <Cale> The important thing is that IO actions are *values*, and evaluating those values doesn't cause them to occur, any more than, say, opening the source code for a program in a text editor would cause it to run
19:52:46 <kmc> dark, your functions return descriptions of how to do some IO at a later point
19:53:11 <dark> I understand a thing: if I have an "IO status" variable, I can have a function that does IO receiving it, the thing to do IO, and returning another status
19:53:18 <idnar> dark: you assign an IO action to "main"; when you run the program, that action gets executed
19:53:20 <Cale> In a compiled program, you define an IO action value called main, and the runtime system evaluates that expression into an IO action, and executes the resulting action.
19:53:23 <kmc> function don't do IO
19:53:23 <kmc> period
19:53:25 <dark> so that the next function that will do i/o will just receive this next status and so on
19:53:27 <kmc> > let sendPacket x = "send a packet to " ++ x in map sendPacket ["google.com", "microsoft.com"]
19:53:28 <lambdabot>   ["send a packet to google.com","send a packet to microsoft.com"]
19:53:31 <Axman6> dark: it is not a function
19:53:34 <kmc> dark, notice that evaluating these strings did not send any packets
19:53:41 <j4cbo> that's a very oversimplified explanation
19:53:48 <Cale> > putStrLn "hello"
19:53:49 <dark> Axman6, so it's what?
19:53:49 <lambdabot>   <IO ()>
19:53:49 <Axman6> functions are pure
19:53:57 <idnar> erf, too many cooks
19:53:57 <Axman6> it's an IO action
19:53:58 <j4cbo> because performing IO actions and performing computation can be intertwined
19:54:00 * idnar shuts up
19:54:00 <dark> idnar, hmmmmm
19:54:02 <dancapo> So, how does one use GHCi's debugger?
19:54:10 <Cale> dark: You can think of a value of type (IO t) as being a description of some stuff to do.
19:54:22 <Axman6> dancapo: by looking at the GHC docs and finding out how :)
19:54:40 <Cale> dark: Another process, part of the runtime system, will actually carry out those instructions eventually, but evaluation won't cause them to happen.
19:54:49 <j4cbo> Cale: it's not *just* a description of stuff to do, though.
19:54:51 <dancapo> Axman6: aren't you GHC's docs??? :-)
19:54:57 <j4cbo> consider a program that continuously reads numbers and prints out their factorials.
19:55:04 <dark> i/o can be done in many parts of the source, or just in main?
19:55:11 <kmc> dark, anywhere in the source
19:55:17 <tensorpudding> you can do IO anywhere you want
19:55:17 <Axman6> j4cbo: what about it?
19:55:27 <kmc> any function anywhere can build and return an IO recipe
19:55:32 <tensorpudding> but main has to have type IO ()
19:55:33 <Cale> dark: Well, you can define IO actions anywhere, but main is the only one which actually executes.
19:55:34 <kmc> the only recipe that actually gets run is the one you call "main"
19:55:42 <Axman6> j4cbo: just in main, or IO actions it calls (either directly, or through other IO actions)
19:55:51 <kmc> but you typically build "main" by calling some other functions, getting their recipes, and gluing them together
19:55:52 <dark> may I will call an i/o action from a function?
19:55:59 <kmc> dark, you don't call IO actions
19:56:08 <j4cbo> Axman6, the point is that "evaluate" and "perform i/o" are not two separate stages
19:56:11 <dark> may i 'define' an i/o action from a function?
19:56:14 <kmc> yes
19:56:15 <kmc> of cours
19:56:16 <Axman6> j4cbo: yes they are
19:56:21 <kmc> just like you can return a string or a list
19:56:27 <kmc> IO actions are just another datatype
19:56:29 <Cale> dark: You can produce an IO action as the result of a function, but evaluating the function won't cause it to happen.
19:56:30 <j4cbo> Axman6: they are not two *sequential* stages.
19:56:37 <Axman6> so?
19:56:38 <dark> how i/o actions are passed to main?
19:56:44 <dark> "magic"?
19:56:48 <Axman6> no
19:56:49 <Cale> main is built directly by gluing together other IO actions
19:56:49 <kmc> dark, passed?
19:56:56 <kmc> j4cbo, a key operation on IO actions is to glue them together
19:56:59 <Cale> main = do x <- getLine; putStrLn x
19:57:08 <Axman6> you write your main function, and it executes the actions inside it
19:57:10 <dark> main will execute the i/o. a function wants to do i/o. how can it pass the i/o to main?
19:57:23 <Cale> dark: Return it as part or all of its result
19:57:33 <Cale> dark: For instance,  putStrLn :: String -> IO ()
19:57:34 <kmc> dark, functions don't do IO.  functions return a description of how to do IO
19:57:36 <Saizan> yeah, they are interleaved, often the IO recipe will contain a continuation to call with the result of the last operation executed, to get a new recipe.
19:57:41 <Axman6> dark: it seems it is time you started learning haskell, so you can begin to understand this all.
19:57:44 <Axman6> @where lyah
19:57:45 <lambdabot> http://www.learnyouahaskell.com/
19:57:46 <dark> hmm so I must have a whole chain of returns up to main, so that main can perform it?
19:57:48 <Axman6> dark: ^^^^^^^^^^
19:57:48 <kmc> e.g. (putStrLn "hello") is a description of how to print a string that says "hello"
19:57:52 <Cale> putStrLn is a (pure) function, whose result is an action for printing a given string
19:57:54 <dark> Axman6, :)
19:57:59 <kmc> dark, in practice, it looks exactly like imperative programming
19:58:00 <kmc> because it is
19:58:03 <dark> Axman6, reading. and yes I will learn
19:58:11 <kmc> well, not exactly... "return" doesn't mean what you'd think
19:58:15 <kmc> it's just a poorly chosen name
19:58:30 <Cale> It's like a more principled way of cutting up imperative programming into little pieces and putting it back together again :)
19:58:31 <Axman6> dark: once you've done some actually programming in haskell, it will be easier to explain this all to you
19:58:33 <kmc> dark, the "do" notation is just syntactic sugar for the operators (>>=) and (>>), which are the gluing-together operators
19:58:52 <Cale> I disagree that return is a poorly chosen name.
19:59:01 <idnar> I still don't understand how the name "return" makes any sense
19:59:07 <kmc> so e.g. Cale's example above ends up as: main = getLine >>= (\x -> putStrLn x)
19:59:12 <kmc> (>>=) is an ordinary infix operator
19:59:17 <Cale> It doesn't do what an imperative programmer would think, but most of this doesn't really do what an imperative programmer would think
19:59:17 <kmc> its left argument is an IO-recipe
19:59:25 <Axman6> i think insert would have been a better name, for how i think about what return does
19:59:32 <Cale> idnar: return x is the action which does what?
19:59:51 <kmc> Cale, i dislike using the verb "return" to describe what actions do
19:59:54 <Axman6> inserts a value into the monad >_>
19:59:55 <dark> but the basics is: a function that want's to do i/o return them to main and main will perform it; and if it's a inner function, the chain of functions that called it must store the i/o recipe and pass to main. right?
19:59:57 <kmc> because that confounds them with functions again
20:00:08 <Axman6> dark: functions don't do IO :)
20:00:13 <Cale> kmc: I don't like using return to describe what functions do ;)
20:00:22 <idnar> Cale: I guess you're going after something like "the action that does nothing and returns x"?
20:00:23 <kmc> dark, it sounds like you are assigning a special role to "main"
20:00:26 <Cale> idnar: yeah
20:00:30 <kmc> Cale, sure, because you're some kind of arch-reductionist ;P
20:00:41 <kmc> dark, main is only special because it's the one IO recipe that is actually executed
20:00:41 <Axman6> dark: not really. lgo and leave IO alone, and start reading lyah. you'll get to IO eventually
20:00:58 <dark> .-.
20:01:19 <Axman6> IO is much less important in hakell than... well everything else in haskell :)
20:01:23 <kmc> anyway, you don't need to conceptually turn your imperative code inside out
20:01:29 <Cale> dark: Mostly, you define a few IO actions at the top level of your program which act as a user interface, and do the interesting part of your program as pure functions.
20:01:31 <kmc> you write imperative code much like any other language
20:01:34 <idnar> in that case, my complaint is about talking about actions "returning" things ;P
20:02:07 <kmc> you use the "do" notation like an ordinary imperative language, but behind the scenes it's building recipes rather than actually doing stuff
20:02:07 <monochrom> I dislike words.
20:02:09 <idnar> anyhow, it's not a big deal
20:02:10 <Cale> dark: It's possible to just write everything in IO and use Haskell as an imperative programming language, and that's not even particularly bad, but you wouldn't be getting the most out of it if you did that.
20:02:11 <Saizan> dark: they don't get passed to main, main is made of these actions glued together with combinators, when the main action gets executed the combinators unfold showing the full recipe as it is needed
20:02:18 <dark> I know FP, and I know how to isolate I/O from FP in OCaml (so that only a tiny portion of the program is actually imperative)
20:02:29 <kmc> then you'll probably like Haskell
20:02:33 <Cale> dark: Then you'll be fine :)
20:02:53 <Cale> dark: The part of the program which does I/O is handled inside IO actions. The rest is pure functions.
20:02:54 <kmc> like OCaml, it's a great functional language and a great imperative language.  unlike OCaml, there's more work in integrating the two cleanly rather than just mushing them together
20:03:31 <Cale> dark: Of course, it's important to realise that IO actions can refer to pure functions in their composition.
20:03:50 <dark> what I am thinking is: is haskell really so arcane, or I am just dumb? (btw maybe this explains why FP isn't mainstream)
20:04:01 <dark> but I will read that lik Axman6, thank you
20:04:02 <Cale> For example, reverse :: String -> String is pure, and I can write something like  do x <- getLine; putStrLn (reverse x)
20:04:08 <kmc> i wouldn't say it's arcane, but it's very different from other languages
20:04:51 <kmc> not to trash on OCaml or anything.  but there is a trend of saying "i'm a FP moderate, Haskell is too extreme because they can't even do mutable state"
20:04:54 <kmc> and that's simply false
20:05:12 <Cale> dark: Another nice thing about IO actions being values which aren't executed by evaluation is that it makes it really easy to write new control structures without worrying about things going off before they're supposed to.
20:05:15 <kmc> we have a cleaner story about how mutation and functions combine than any other functional language
20:05:24 <Cale> So to a certain extent, you can do macro-like things :)
20:05:25 <dark> there are ways to have mutable state with haskell?
20:05:30 <kmc> dark, yes
20:05:36 <kmc> you know reference types from OCaml?
20:05:41 <dark> yes
20:05:45 <kmc> we have several analogues
20:05:47 <Cale> dark: Lots of them ;)
20:05:48 <Axman6> dark: haskell is not arcane, it's just different (and you will come to see, better). being forced to separate your pure and impure code makes it a hell of a lot easier to think about
20:05:52 <kmc> IORef is sort of the basic one
20:06:04 <kmc> there are atomic ones for concurrency
20:06:18 <kmc> and there's a system for software-transactional memory, for lockfree concurrency
20:06:21 <lament> when some people say something is easy, and others say the same thing is hard, i tend to believe those who say it's hard
20:06:29 <Axman6> haskell has some of the best ways to have mutable state i've ever seen personally
20:06:53 <dark> <kmc> and there's a system for software-transactional memory, for lockfree concurrency > i am actually looking for this
20:07:06 <idnar> Axman6: isn't different just another word for arcane? ;)
20:07:08 <kmc> dark, the STM chapter in Real World Haskell is really good
20:07:10 <kmc> last chapter iirc
20:07:12 <kmc> it's online
20:07:14 <kmc> @where RWH
20:07:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:07:19 <Cale> newIORef :: a -> IO (IORef a)
20:07:19 <Cale> readIORef :: IORef a -> IO a
20:07:19 <Cale> writeIORef :: IORef a -> a -> IO ()
20:07:19 <Cale> modifyIORef :: IORef a -> (a -> a) -> IO ()
20:07:25 <Axman6> kmc: stop rushing him
20:07:26 <Cale> There's the basic interface
20:07:30 <dark> i have no problem in learning more about programming, and i have lots of time
20:07:30 <kmc> Axman6, hey, he asked
20:07:34 <dolio> @wn arcane
20:07:37 <lambdabot> *** "arcane" wn "WordNet (r) 2.0"
20:07:37 <lambdabot> arcane
20:07:37 <lambdabot>      adj : requiring secret or mysterious knowledge; "the arcane
20:07:37 <lambdabot>            science of dowsing"
20:07:46 <dark> Cale, no, it's nice to know :)
20:07:47 <Axman6> yes, but to understand what he's reading, he's going to need to understand haskell somewhat
20:08:00 <dark> kmc, this book can be read on the web?
20:08:02 <Saizan> dark: if you're interested in pure parallelism rather than concurrency, there are nicer things even :)
20:08:04 <Cale> dark: So newIORef takes a value (of any type a), and produces an IO action for constructing new IORefs with that initial value
20:08:05 <kmc> yes the link is up there
20:08:09 <dark> ah.
20:08:11 <kmc> dark, much like the situation for IO, evaluation never results in reading or writing a ref
20:08:12 <Axman6> it's like trying to teach someone integration, without them knowing addition
20:08:17 <dark> nice! :)
20:08:21 <kmc> rather you build recipes which manipulate refs
20:08:23 <Cale> dark: and readIORef takes an IORef and produces an IO action for reading its value
20:08:27 <dark> kmc, hmmmm
20:08:36 <kmc> and this is not nearly as cumbersome as it sounds, but you might have to trust us on that until you start doing it
20:08:57 <dibblego> does someone have a ~/.haskeline with working home and end keys in ghci?
20:09:22 <Cale> Yeah, the code you write is straightforward, it's just that the *correct* explanation of that code is a bit longwinded because of these two interleaved processes which are driving your program forward
20:09:22 <ezyang> Bifctrable is such a terrible name :-(
20:10:07 <Cale> (and actually, how we tend to explain it, and what GHC really does in practice are two different things again)
20:10:30 <SamB_XP> ezyang: indeed!
20:10:37 <SamB_XP> how the heck is it to be pronounced?
20:10:39 <kmc> right, but what GHC really does is not part of the language
20:10:45 <Cale> right
20:11:36 <ezyang> Bi-fic-trable, I think
20:11:48 <ezyang> is it, like, functor with the vowels removed?
20:12:15 <sereven> "bifunctorable"
20:12:34 <Cale> We need a Hebrew speaker to help us put the vowels back in ;)
20:12:46 <Cale> sereven: that's a decent guess :)
20:13:31 <idnar> Cale: haha
20:13:32 <Cale> dibblego: istr that the documentation for haskeline had that as an example
20:13:51 <dolio> I somehow have working home and end keys without anything special in the config.
20:14:02 <tensorpudding> what category theory needs is more niqqud's
20:14:13 <dark> a practical question: does ghc typically perform the i/o well? in a complex program that handles mostly with i/o (say, a sed implementation), would the i/o model of haskell hurt the performance?
20:14:26 <dibblego> Cale, http://trac.haskell.org/haskeline/wiki/CustomKeyBindings ?
20:14:27 <Cale> dark: It's typically fine.
20:14:27 <dark> typically perform well*
20:14:39 <dark> hm
20:15:01 <Cale> dibblego: oh, home and end...
20:15:12 <Cale> dibblego: My home and end keys work out of the box...
20:15:15 <dh_> good evening , anybody knows where I can find a BNF diagram of haskell?
20:15:32 <dibblego> Cale, my home prints H
20:16:05 <Axman6> dh_: diagram? isn't BNF textual?
20:16:23 <monochrom> http://www.hck.sk/users/peter/HaskellEx.htm
20:16:43 <dolio> The report has some stuff.
20:16:44 <dh_> _Axman6, I might used the wrong word. I mean those diagram with arrows , circles for BNF.
20:16:53 <monochrom> and http://haskell.org/onlinereport/syntax-iso.html
20:16:53 <ezyang> Prolly not a diagram though
20:17:06 <kmc> niqqud please
20:17:10 <Axman6> ah, railroad disgrams, or whatever they're called
20:17:15 <monochrom> Oh, like Pascal books does it? No.
20:17:26 <monochrom> But http://www.hck.sk/users/peter/HaskellEx.htm is better.
20:17:30 <tensorpudding> niqqud is a great word
20:17:30 <ezyang> like http://www.json.org/
20:17:33 <dh_> monochrom: thanks for the like, it's nice
20:17:34 <kmc> dark, it should have no especial effect on performance
20:17:49 <kmc> because behind the scenes, GHC turns actions into impure functions
20:18:03 <kmc> doing so carefully of course
20:18:11 <dh_> yes, like the json.org
20:18:17 <kmc> if you are doing specialized things, there is a back door into that system
20:18:19 <Cale> dibblego: What do you get when you  ghc -e getLine  and then press home and enter?
20:18:56 <dibblego> Cale, ^[[H^[[F (I think you mean home and end)
20:19:07 <Cale> I get "\ESCOH" for home and "\ESCOF" for end
20:19:10 <kmc> dark, you should be aware that IO with Haskell's String type is very slow
20:19:17 <kmc> we have ByteString for that
20:19:29 <kmc> String is *generally* slow, because it's a singly linked list of heap-allocated characters
20:19:53 <kmc> it is just an alias for [Char]
20:19:53 <monochrom> But then it's String slow rather than IO slow.
20:19:58 <dark> and why? so that it can perform string operations faster?
20:19:59 <ezyang> kmc: aw, does that mean we can't do tricks like <http://geofft.mit.edu/blog/sipb/24>?
20:20:09 <ezyang> inside GHC?
20:20:10 <kmc> dark, why is it a singly linked list?
20:20:16 <Cale> dark: Mostly for convenience in the common case of performance not being critical
20:20:37 <kmc> [Char] is the conceptually simplest way of representing text
20:20:44 <dark> yes. i realize that some operations could be faster with a liked list
20:20:48 <dark> Hmm
20:20:52 <kmc> well, not too many of them
20:21:01 <kmc> it's not about faster, it's about being easy to work with
20:21:34 <Cale> Lists are how we express iteration, and so there are lots of useful functions for manipulating them you get for free.
20:22:29 <Cale> But we do have other libraries now for manipulating bits of text or strings of bytes, but polymorphic list functions can't work with them.
20:22:32 <dibblego> ctrl-a and ctrl-e work for home/end out of the box for some reason
20:22:41 <dark> The do notation uses layout in the same manner as let or where so we can omit braces and semicolons with proper indentation. > can these styles be mixed? what is the "standard" way of writing blocks?
20:22:52 <dark> (even C has a standard way, namely, k&r style)
20:23:00 <Cale> dibblego: Okay, so I think you can add to your .haskeline...
20:23:19 <Cale> keyseq: "\ESC[H" ctrl-a
20:23:25 <Cale> keyseq: "\ESC[F" ctrl-e
20:23:49 * dibblego smooches Cale 
20:24:12 <Cale> dark: Usually we write things without braces or semicolons
20:24:34 <dark> and idents with..?
20:24:36 <Cale> dark: It's important that you configure your editor right away to convert tabs into spaces. Tab characters mess everything up.
20:24:38 <dark> 2 spaces?
20:24:47 <Cale> Whatever is required to make things line up.
20:25:03 <Cale> I use 2 spaces usually, if there's a choice.
20:25:15 <Cale> (and have my tab key set to insert 2 spaces)
20:25:32 <kmc> dark, layout is just syntactic sugar for braces and semis.  so yeah you can mix them
20:25:34 <Cale> But mostly, nobody cares about how far things are indented as long as they line up nicely in vertical columns.
20:25:35 <dark> I think 2 spaces makes code unreadable. But, then, not many ocaml programmers like my tab-idented programs
20:25:40 <kmc> the Haskell Report describes the precise translation
20:25:54 <kmc> as a result, unlike Python we have a non-whitespace form for everything
20:26:25 <monochrom> No, I think 2 spaces is readable, another other number is unreadable.
20:26:41 <dark> I usually don't nest too much my code so tab warns me about that
20:26:41 <monochrom> s/another/any/
20:26:43 <Cale> Usually I will hang things off of whatever line they started on. Some people don't like it because it does require a bit of extra typing to straighten things out if you edit the first line.
20:26:57 <Cale> But I think it looks good and reads well, so I don't mind.
20:27:06 <ezyang> Unless you're doing HTML or something, I feel like two-spaces encourages excessive indentation. But maybe that's just me.
20:27:13 <dark> Also I don't like to go over column 79
20:27:59 <Cale> dark: That's somewhat avoidable, you can always break lines, as long as the continuation starts on a deeper column than what it continues
20:28:25 <ben0x539> At some point you run out of indentation. :<
20:28:26 <Cale> and of course, you can make definitions :)
20:28:37 <kmc> i like 2 spaces now, used to use 4
20:28:40 <kmc> 8 is a travesty
20:28:44 <kmc> as are tabs
20:28:45 <kmc> that is all.
20:28:59 <Cale> tab characters really ought to be considered lexical errors
20:29:07 <DigitalKiwi> Cale: unless you're using java, then you have function calls that are 80+ characters ;D
20:29:10 <ezyang> "Makefiles"
20:29:21 <Cale> DigitalKiwi: enterprisey goodness :)
20:29:31 <ezyang> the only language that thought distinguishing tabs and spaces was a good idea ^^
20:29:32 <Berenlap> DigitalKiwi: I wish my java functions calls were only 80 characters...
20:29:41 <monochrom> Not enterprisey. Just "meaningful" names.
20:29:41 <DigitalKiwi> http://thedailywtf.com/Articles/CodeThatDocumentsItselfSoWellItDoesNotNeedComments.aspx
20:30:00 <dark> monochrom, every symbol can be meaningful
20:30:21 <monochrom> The great thing about meaningful names is that there are so many meanings to choose from.
20:30:37 <DigitalKiwi> ezyang: what about the Whitespace language?
20:30:39 <dark> :)
20:30:40 <Berenlap> We invented pronouns for a reason. 'x' is a perfectly reasonable variable name.
20:30:46 <Cale> monochrom: Like  BeanFactoryFactoryPackageReplicatorAccessInterfaceModelFactoryBean
20:30:48 <ezyang> DigitalKiwi: Doesn't count. :-P
20:31:53 <btutt> Cale: :)
20:33:04 <kmc> beans beans, the musical fruit
20:33:06 <dark> DoTheSameChangeInShopThenDoTheSameChangeInInventoryForNotChangedDataInInventory > really, this method name needs no comments
20:34:04 <Berenlap> dark: It needs no code either. It's an implementation onto itself.
20:34:05 <dolio> You mean that comment needs no method name.
20:34:54 <ezyang> If I write data Foo = forall a. Foo a, is there a way to get the variable :: a back out in a meaningful manner?
20:35:12 <Berenlap> ezyang: No, that's impossible
20:35:33 <Cale> ezyang: The type has been forgotten, so the only thing you can do is pass that completely useless value around.
20:35:34 <ezyang> Couldn't I, like, pattern match against types or something? ^_^
20:35:49 <ezyang> *nod*
20:36:38 <monochrom> You can pattern-match against the constructor...
20:36:45 <Cale> http://hackage.haskell.org/package/PCLT <-- a great example of Enterprisey BS invading the world of Haskell :)
20:37:07 <Cale> data AddLngTpl_toPCLT_Error
20:37:07 <Cale>   = TplUniquenessViol_APSTPTE TplUniquenessViol_PCLTE
20:37:07 <Cale>   | DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_APSTPTE DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_PCLTE
20:37:13 <monochrom> haha detailization
20:37:31 <Cale> That is an actual datatype from that library
20:37:33 <ezyang> Yigh. I don't even know what it's supposed to do.
20:37:49 <Cale> data RequiredByRequirerCompositeIsMissing_PCLTE = RequiredByRequirerCompositeIsMissing_PCLTE RequirerCompositeKey RequiredCompositeIsMissing_PCLTE
20:37:55 <dark> @.@'
20:37:56 <lambdabot> Maybe you meant: . @
20:38:01 <ezyang> Localization sounds like a generally good idea, though?
20:40:02 <Axman6> conal: yeah i saw that the other dayand was appalled
20:40:26 <conal> Axman6: hi.  saw what?
20:40:39 <Axman6> sorry, that was for Cale :)
20:40:44 <monochrom> "data Foo = forall a. Foo a (a -> Int)" may be more useful. Or "data Foo = forall a. (YourTypeClass a) => Foo a" so you just use your type class methods. Control.Exception is an example.
20:40:47 <conal> oh, okay.
20:40:59 <Cale> conal: http://hackage.haskell.org/package/PCLT
20:41:11 <monochrom> saw detailizable and detailization
20:41:20 <Cale> conal: There are some wonderfully enterprisey gems in there ;)
20:41:30 <Cale> data AddLngTpl_toPCLT_Error
20:41:30 <Cale>   = TplUniquenessViol_APSTPTE TplUniquenessViol_PCLTE
20:41:30 <Cale>   | DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_APSTPTE DefaultLngTplComponentsParamsSetsDiffersFromOnesOfNondefault_PCLTE
20:41:30 <monochrom> To be fair the author is russian and gets to butcher english.
20:41:33 <Cale> ^^ like that one :)
20:42:25 <Cale> I think if I was writing a library in something other than my first language, I'd keep my identifiers as short as possible :)
20:42:52 <dark> i love unix names
20:42:55 <dark> ntohs
20:42:56 <conal> Cale: eep!
20:43:00 <mauke> creat
20:43:00 <dark> memcpy
20:43:04 <dark> yeah
20:43:07 <mauke> strcspn
20:43:09 <Cale> strfry
20:43:18 <SamB_XP> stirfry?
20:43:19 <dark> these I don't know
20:43:25 <conal> standards committee nightmare.
20:43:33 <mauke> strfry is an (unfortunately real) joke function
20:43:34 <ezyang> strfry it is.
20:43:36 * kmc <3 creat
20:43:42 <Cale> strfry - randomize a string
20:43:46 <mauke> strcspn is standard C, though
20:43:54 <SamB_XP> which C library contains strfry ?
20:44:00 <mauke> SamB_XP: glibc
20:44:11 <kmc> string processing in C gives me the willies
20:44:11 <Cale> GNU C's string.h
20:44:15 <ezyang> man 3 strfry
20:44:21 <SamB_XP> did they get THAT idea from xkcd as well ?
20:44:28 <mauke> no, it's much older
20:44:36 <mauke> see also memfrob
20:44:49 <ezyang> There's an Ulrich Drepper joke in here somewhere...
20:44:58 <SamB_XP> memfrob actually sounds almost plausible
20:45:08 <kmc> urgh xkcd
20:45:20 <Cale> I seem to recall that the code for strfry was (or maybe even still is) buggy, and someone was complaining about how they wouldn't accept his patch to fix it, since it's a joke anyway.
20:45:23 <dark> kmc, dont you like?
20:45:44 <kmc> heh don't get me started ;)
20:45:58 <dark> but.. what's the joke about randomizing a function? seems useful
20:46:06 <lament> I hated xkcd before hating xkcd was cool!
20:46:06 <dark> (for what i don't know..)
20:46:09 <Cale> It is potentially useful.
20:46:18 <dark> lament, hating xkcd is cool?
20:46:21 <dark> @.@
20:46:21 <lambdabot> Maybe you meant: . @
20:46:26 <dark> lambdabot, .-.
20:46:32 <monochrom> The joke is about the name strfry
20:46:48 <dark> lambdabot, what is th problem with my favorite emoticon? ? .-.
20:46:51 <Cale> But the algorithm they use was the one where you repeatedly pick two characters at random and swap them, so you don't get all permutations with equal probability that way
20:47:08 * CalJohn gives up reading TAPL and goes to bed
20:47:11 <dark> hmmm. i don't get it. but my english is poor anyway
20:47:14 <monochrom> Ah, someone didn't read Knuth.
20:47:18 <dark> Cale, by
20:47:24 <dark> monochrom, :)
20:47:28 <ben0x539> Is the talk on the cereal package o the web somewhere?
20:47:47 * kmc <3 TAPL
20:47:53 <dark> monochrom, never got my hand on the book. (I would read if it were on the net)
20:47:55 <Cale> It doesn't even require reading Knuth to come up with the right algorithm there.
20:48:05 <CalJohn> Cale: fisher-yates does give properly random results
20:48:20 <Cale> Heh, yeah, that's what it was called.
20:48:34 <dark> kmc, (tapl?)
20:48:43 <kmc> a book
20:48:44 <kmc> @where tapl
20:48:44 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
20:48:52 <kmc> CalJohn mentioned it
20:49:08 <mauke> perldoc -q shuffle  # problem solved
20:49:09 <Cale> Two people's names for such an obvious algorithm :)
20:49:56 <CalJohn> the annoying part is that Data.List.Shuffle (or whatever oleg's list shuffle got packaged into) is non-total in a place where oleg's comment explicitly says it should not be
20:49:58 * ezyang thinks, "Man, if only it were that easy to get an algorithm named after onesself" 
20:50:06 <CalJohn> and where i do not understand enough to correct it
20:50:08 <SamB_XP> they were probably the people who actually knew enough probability theory to write up an analysis of why it's the way to go ;-P
20:50:12 <Cale> It's kind of like the Gram-Schmidt orthogonalisation algorithm.
20:50:20 <gwern> dark:  TAPL is online
20:50:24 <kmc> really?
20:50:24 <gwern> there are 2 copies I've found so far
20:50:30 <kmc> oh not legit though
20:50:34 <gwern> well, no
20:50:37 <SamB_XP> gwern: the original ???
20:50:40 * SamB_XP covets
20:50:41 <monochrom> If we actually trace down those people who independently first wrote about the identity function, it may be a function with 20 names or something.
20:50:46 <CalJohn> the only online TAPL is a poorish quality chm
20:50:52 <dark> hmmmmm
20:50:55 <Cale> "How do you do it?" "Well, we go through the vectors one by one and subtract off the part that's not orthogonal to the vectors before." "Oh."
20:51:03 <dark> gwern, most useful books are on torrent
20:51:07 <gwern> Cale: which one are you referring to?
20:51:14 <CalJohn> TAPL has the kind of layout that makes it painful to read on a screen
20:51:16 <gwern> er. I mean CalJohn
20:51:20 <dark> gwern, and some that aren't as well
20:51:35 <gwern> dark: well, I've not yet seen TAPL on torrents, though I've looked
20:51:54 <gwern> CalJohn: the iranian one or the google books TAPL?
20:52:18 <dark> ps: on most freenode channels, talking about how obtaining copyrighted material taboo gwern
20:52:22 <dark> is
20:52:30 <CalJohn> gwern: pm
20:52:33 <SamB_XP> oh no!
20:52:51 <SamB_XP> I better not mention the fact that you can download GHC somewhere on haskell.org!
20:53:04 <dark> :)
20:53:13 <gwern> dark: better amend that to copyright violations!
20:53:24 <Cale> I have a nice clean PDF of ATTaPL, but was only able to find this horribly typeset and unusable windows help file format version of TAPL.
20:53:32 <Cale> I own the book, but it would be nice to have a PDF
20:54:00 <dark> i meant non-free copyrighted works that belongs to evil people (or to people associated with evil corporations)
20:54:01 <SamB_XP> Cale: yeah, I found the second one on the open web as well ;-)
20:54:18 <SamB_XP> dark: US corps are required by law to be evil
20:54:47 <Cale> Publishers of all kinds are more or less obsolete.
20:54:47 <dark> and in many other parts of the world it is at least advised
20:54:47 <monochrom> very thick and heavy book. not very portable.
20:54:52 <gwern> SamB_XP: they're so required in most jurisdictions - maximize shareholder value etc
20:55:17 <dark> I sometimes prefer to download something I have on paper. in order to have ctrl+f working etc
20:55:26 <SamB_XP> dark: indeed
20:55:34 <SamB_XP> I'm with you there
20:55:46 <monochrom> This is also why I have ditched postscript. Not searchable.
20:55:57 <Cale> postscript can sometimes be searched
20:56:01 <SamB_XP> also, it's handy if you left your copy at home and you're at school ;-)
20:56:09 <Cale> It depends on how it was constructed though.
20:56:11 <SamB_XP> Cale: but none of our readers do it :-(
20:56:20 <Cale> Evince does
20:56:26 <Cale> (when it's possible)
20:56:35 <ben0x539> fwiw, as someone who has not read Knuth and does not have a CS education, I came up with plenty of problems with my naive shuffling approach but this fisher-yates thing never occured to me, even without a proof
20:56:44 <mauke> monochrom: why are you +o?
20:56:50 <monochrom> I know how the tex-dvi-ps pipeline completely scrambles everything.
20:57:24 <monochrom> Because of crazy off-topic-ness earlier. Two waves.
20:57:27 <Cale> ben0x539: I guess it helps to have a good feel for what permutations are all about
20:58:15 <dark> something nice of xchat is that it doesn't show by default the @ on chat for ops (here). i didn't noticed monochrom was opped
20:58:55 <Cale> It is the first thing I'd have come up with. If you want to put some things in a random order, just keep taking random ones from whatever's left.
20:58:55 <SamB_XP> I only noticed after he removed somebody ;-P
20:59:31 <ben0x539> Cale: I figured I would end up with an unreasonable complexity that way, because I thought I would be using an array and removing elements in linear time
20:59:35 <SamB_XP> Cale: yeah, that is the naive approach that you get by thinking about the pick/choose function ;-P
20:59:43 <SamB_XP> forgot which is which, I did
21:00:05 <Cale> maybe select? :)
21:00:20 <gwern> ben0x539: couldn't you just replace every picked element with some sort of Nothing and repeat the random pick?
21:00:25 <gwern> seems to me that ought to be the same
21:00:31 <SamB_XP> no, no, select is for listening on file descriptors ;-P
21:00:39 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
21:00:39 <ben0x539> gwern: That is not even guaranteed to terminate :(
21:00:40 <lambdabot>  Defined.
21:00:51 <Cale> > select [1,2,3]
21:00:53 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
21:01:03 <gwern> ben0x539: well, anytime you invoke randomness you can expect to through out all sorts of guarantees...
21:01:27 <Veinor> ben0x539: I think its termination time EV is bounded :D
21:01:29 <ben0x539> gwern: It is probably entirely reasonable, but philosophically unsatisfying to a listless hobbyist
21:01:40 <matsuura> > seclect [123, 213, 321]
21:01:40 <gwern> philosophy bah
21:01:41 <SamB_XP> Cale: I mean the function that tells you how many n-element sets you can make from an m-element set
21:01:41 <lambdabot>   Not in scope: `seclect'
21:01:48 <SamB_XP> er.
21:01:50 <Cale> SamB_XP: Oh, that
21:01:51 <matsuura> > select [123, 213, 321]
21:01:54 <SamB_XP> no, not sets
21:01:56 <SamB_XP> sequences
21:01:59 <gwern> come back when you can tell me whether randomness changes complexities of problems :)
21:02:06 <lambdabot>   [(123,[213,321]),(213,[123,321]),(321,[123,213])]
21:02:18 <matsuura> oh you silly little.....
21:02:35 <matsuura> gwern: it does
21:02:45 <ben0x539> > map fst $ select "shuffle"
21:02:46 <lambdabot>   "shuffle"
21:02:53 <matsuura> like when you're gf you were planning to break up with tells you that she is pregnant
21:02:59 <Cale> SamB_XP: Well, n choose m, or the binomial coefficient (n;m) is the number of ways of picking a *set* of m things from a set of n. If you want to pick a permutation too, you can multiply by m!
21:03:05 <SamB_XP> matsuura: not that kind of problems!
21:03:08 <matsuura> oh
21:03:08 <matsuura> nvm
21:03:09 * gwern thinks matsuura & I speak of different complexities
21:03:17 <SamB_XP> Cale: ah, yeah, that's the one
21:03:24 <SamB_XP> the latter
21:03:29 <matsuura> still random and complex none the less
21:03:30 <matsuura> haha
21:03:33 <Cale> I forget if that has a name. Some people write it P(n,m) or some awkward thing with pre-and-post-subscripted P
21:03:45 <SamB_XP> Cale: I believe the word is "pick"
21:03:51 <SamB_XP> or maybe it's "permute"
21:03:53 <SamB_XP> dunno ;-P
21:03:57 <monochrom> If you have a mutable array, do not think of insert-remove. Think of in-place swap and remembering "this part of the array is done" "this other part still needs work". Take inspiration from quicksort.
21:04:29 <gwern> oh well. good night everyone
21:04:29 <Cale> Or from insertion sort
21:04:34 <matsuura> 'night
21:04:47 <SamB_XP> night
21:04:49 <Cale> Er, or selection sort
21:04:59 <SamB_XP> or ... should I say good morning?
21:05:28 <monochrom> say happy new year
21:11:37 <dark> happy new year =)
21:11:46 <Axman6> that was yesterday
21:11:51 <dark> .-.
21:12:07 <dark> but the year is new for people that didn't get used to it already
21:12:12 <Axman6> >_>
21:12:57 <ben0x539> Or just woke up
21:13:11 <dark> in the beginning of the year, i often don't know that the year changed, and still fill things with 2009 etc
21:13:42 <dark> well I spent many reveilons (? don't know how to spell this) just sleeping, lol
21:18:40 <dh_> Does anybody knows how to installed sqlite3 with cabal ? I have an error message :  * Missing header file: sqlite3.6
21:18:41 <dh_> and I downloaded sqlite from their webpage , and did ./configure; make; sudo make install.
21:18:56 <dh_> the header I have is sqlite3.h
21:24:16 <dh_> I fixed by mv sqlite3.h sqlite3.6  . weird...
21:26:12 <Axman6> o.O
21:26:24 <Axman6> that... should break things afaict
22:02:27 <Zeiris> If I have a set of data that's loaded on program startup from a static database, the contents of which rarely change and the format of which never changes... Then since that data set is referentially transparent, is it reasonable to unsafePerformIO the code and pretend it's pure?
22:03:22 <Zeiris> (I'd like to wrap up and abstract the data set in a module. Although I guess the -correct- way to do this would be to wrap it in a monad?)
22:05:11 <Axman6> i don't see why you'd need to
22:05:28 <Axman6> just read it in in main
22:05:37 <Axman6> and pass the then pure value around
22:06:40 <kmc> Zeiris, yes, maybe the Reader monad
22:06:50 <kmc> but i think uPIO is all right in these cases
22:07:31 <kmc> just watch out for feature creep
22:07:46 <kmc> as long as the thing derived by uPIO is a CAF and not a function, you're pretty well contained
22:30:24 <sshc> how would continuations be useful in Haskell?
22:31:12 <kmc> same as in other language
22:31:22 <kmc> e.g. for implementing coroutines
22:32:07 <kmc> however, lazy evaluation subsumes some of the use cases
22:32:30 <kmc> for example a lazy list producer piped into a lazy consumer are sort of already coroutines
22:32:55 <kmc> and we don't need continuations for backtracking nondeterminism because we can do lazy breadth-first
22:33:11 <kmc> are you considering using the Cont monad for something?
22:33:44 <sshc> kmc: not yet
22:34:13 <ben0x539> is (>>= f) not basically a continuation
22:34:27 <kmc> sshc, in languages without first-class continuations, you can emulate them by continuation passing style
22:34:39 <kmc> which is all the Cont monad does -- it's sugar for CPS
22:34:44 <sshc> ben0x539: I have no idea what you're asking or saying
22:34:56 <ben0x539> Me either
22:35:12 <kmc> and thinking about CPS is a good way to understand continuations
22:35:23 <kmc> very few languages have true first-class continuations -- Scheme is the only one i know of
22:35:36 <Cale> ben0x539: Sort of.
22:35:39 <kmc> ben0x539, sort of
22:35:54 <kmc> but there's no equivalent to callCC for a general monad
22:37:04 <sshc> ben0x539: quotation marks and end-of-sentence punctuation would let us understand you
22:37:06 <Cale> ben0x539: In x >>= f, you can think of f as being the continuation for x: it says how to continue the computation given a result from f. However, this is in terms of a funny kind of abstract machine.
22:37:28 <Cale> (corresponding to whichever monad it is that you interpret this in)
22:37:36 <ben0x539> Right
22:38:14 <Cale> For instance, in the list monad, it's a little bit strange to think of f as a continuation, though it can make sense if you think of the machine as nondeterministically splitting into many universes :)
22:38:48 <Cale> In each universe, f receives one of the elements of the list x, and decides where to go with that. :)
22:41:38 <Cale> In the Cont r monad, there's even a function (callCC) which takes as its parameter a function which will receive that f as its parameter, that decides what to do based on that.
22:41:49 <kmc> :t mapCont
22:41:50 <lambdabot> forall r a. (r -> r) -> Cont r a -> Cont r a
22:42:06 <kmc> so i hear you can't implement mapCont in terms of other stuff?
22:42:15 <ben0x539> Why does it not just return the continuation
22:42:15 <kmc> i don't understand why
22:42:59 <Cale> ben0x539: That's a little weaker, but you can do that.
22:43:07 <kmc> ben0x539, because the current continuation inside the "get the continuation" call is to return the continuation
22:43:21 <kmc> :O
22:43:30 <ben0x539> Like, callCC id?
22:43:46 * ezyang is planning on writing a blog post about how CPS in the continuation monad works. 
22:43:57 <kmc> :t callCC id
22:43:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
22:43:58 <lambdabot>     Probable cause: `id' is applied to too few arguments
22:43:58 <lambdabot>     In the first argument of `callCC', namely `id'
22:44:12 <ben0x539> @type callCC
22:44:12 <Cale> @let getCC :: MonadCont m => m (m a); getCC = callCC (\c -> let x = c x in return x)
22:44:13 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
22:44:14 <lambdabot>  Defined.
22:48:31 <Cale> > execWriter . (`runContT` return) $ do start <- getCC; lift (tell ["Hello"]); start
22:48:32 <lambdabot>   ["Hello","Hello","Hello","Hello","Hello","Hello","Hello","Hello","Hello","H...
22:48:50 <Cale> ^^ Haskell can haz goto too
22:49:24 <Jafet> Come from again?
22:49:35 <Cale> (at least the backward-jumping sort)
22:49:55 <Cale> @let getCC' :: MonadCont m => a -> m (a, a -> m b); getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f)
22:49:55 <lambdabot>   Parse error: SemiColon
22:50:24 <Cale> @let getCC' :: MonadCont m => a -> m (a, a -> m b); getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))
22:50:25 <lambdabot>  Defined.
22:50:29 <Cale> there we go :)
22:51:10 <Cale> > execWriter . (`runContT` return) $ do (n,start) <- getCC' 0; lift (tell [n]); start (n+1)
22:51:11 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
22:53:02 <Cale> kmc, ben0x539: it's kind of hard to write getCC' in terms of just getCC, if you don't also have state.
22:53:10 <ben0x539> :/
22:53:23 <Cale> Can you see what getCC' is doing there?
22:54:23 <Cale> getCC' x0  will return a pair consisting of a value, which on the first time through is x0, and a function which refers to this point in the code.
22:54:57 <Cale> If you call the function with some value and execute the result, you effectively jump back to where the getCC' finished, except with the new value instead of x0
22:56:02 <ben0x539> You are using it like setjmp/longjmp here, complete with passing an int
22:56:54 <c_wraith> @pl \y -> f x y z
22:56:54 <lambdabot> flip (f x) z
22:58:49 <Cale> I've never used those calls in C, but I believe it's something similar, yeah.
23:01:47 <c_wraith> longjmp has the disadvantage that it can never call down the call stack.  But otherwise they're the same
23:05:46 <Cale> So this is like the abstract mathematical version of something which is usually explained in terms of call stacks :)
23:06:21 <Cale> Moreover, you can use ContT to apply this to any monad :)
23:06:29 <ksf> If Perl is the perfect hammer for all those screws, then Haskell is the perfect leatherman for all those nails.
23:06:38 <ksf> (that might be too subtle for some of you)
23:06:48 <dolio> >  let goto = id in (`evalState` 0) . execWriterT . (`runContT` return) $ do loop <- getCC ; modify (+1) ; get >>= lift . tell . (:[]) ; goto loop
23:06:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:07:00 <kmc> i've used a leatherman as a hammer
23:07:03 <kmc> works all right
23:07:13 <ksf> do does Debug.Trace
23:07:18 <ksf> *so
23:07:25 <kmc> @quote oasis
23:07:26 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
23:10:30 <dolio> >  let goto = id ; x = get ; inc _ = modify (+1) ; printf m = m >>= lift . tell . (:[]) in (`evalState` 0) . execWriterT . (`runContT` return) $ do loop <- getCC ; printf x ; inc x ; goto loop
23:10:32 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
23:10:46 <Jafet> @let goto = id
23:10:48 <lambdabot>  Defined.
23:10:52 <dolio> So much easier to understand than functional programming.
23:11:27 <ben0x539> I never understood how continuations would call down the stack. I mean, there is nothing there!
23:11:51 <cads> hey all
23:11:57 <kmc> to implement it you have to save the stack to the heap
23:12:10 <Jafet> The continuation contains all the stack it needs
23:12:12 <kmc> dolio, haha
23:13:28 <Jafet> Best imperative language ever.
23:15:06 <cads> hey, anyone here have FP/type theory/semantics papers by people like meijer, moggi, mcbride, s. p. jones?
23:15:06 <bob0> cads: no
23:15:21 <cads> bobo-ma-bo?
23:15:33 <cads> what had happened was...
23:16:27 <cads> well, my home was invaded and my computers were stolen, including my FP bibliography which I'd put together over the last few years..
23:16:56 <dolio> Most of McBride's stuff can probably be found from e-pig.org
23:17:07 <dolio> Or his web site. I think he has one somewhere.
23:18:26 <cads> Well, I'm working hard to reconstruct the set of papers I was studying most recently.
23:19:26 <cads> It included a lot of exotic stuff, especially the papers dealing the categorical disciptions of computation.
23:22:54 <BMeph> cads: Wadler's site should help out with the relevant Moggi stuff as well as his own. :)
23:24:20 <manjunaths> I want to negate the output of a function that returns bool, how would I do it ?
23:24:24 <manjunaths> i.e.,
23:24:34 <manjunaths> ! f a
23:24:42 <manjunaths> ! (f a)
23:24:49 <cads> > not . not True
23:24:50 <lambdabot>   Couldn't match expected type `f GHC.Bool.Bool'
23:24:50 <lambdabot>         against inferred typ...
23:25:09 <cads> krikey :P
23:25:29 <manjunaths> > `not` ((<3) 6)
23:25:30 <lambdabot>   <no location info>: parse error on input ``'
23:25:43 <manjunaths> > `not` (<3) 6
23:25:44 <lambdabot>   <no location info>: parse error on input ``'
23:25:53 <manjunaths> > not (<3) 6
23:25:54 <lambdabot>   The section `GHC.Classes.< 3' takes one argument,
23:25:54 <lambdabot>  but its type `GHC.Bool.B...
23:26:01 <kmc> :t negate
23:26:02 <lambdabot> forall a. (Num a) => a -> a
23:26:10 <kmc> :t (not.)
23:26:11 <lambdabot> forall (f :: * -> *). (Functor f) => f Bool -> f Bool
23:26:24 <kmc> > (not . isAlpha) 'x'
23:26:25 <lambdabot>   False
23:27:07 <cads> in any case, if you have a function f : a -> Bool, you should be able to comose it with not : Bool -> Bool by saying (not . f)
23:27:53 <manjunaths> cads thanks :-)
23:30:48 <cads> BMeph, dolio, I suppose what I'd like to say is that I'd feel honored to read any Math/CS papers that you guys would find interesting enough to share :)
23:31:23 <dolio> Well, there are quite a lot in the category you mentioned.
23:31:43 <ksf> fgl is still the best graph library, isn't it?
23:35:01 <manjunaths> heh...I am trying to write a version of dropWhile using foldr and I am running around in circles
23:39:29 <cads> Dolio, what comes to mind when you try to think of the most memorable paper (or even book, say) you've ever read? For me it might be backus' turing award paper on functional programming where he builds a basic algebra of programs.. I remember being just riveted when I read it :)
23:40:59 <dolio> Well, I read through Girard's Proofs and Types fairly recently. Its pretty good.
23:44:04 <dolio> Several of the papers on epigram are very good, too.
23:44:15 <dolio> Why Dependent Types Matter, for instance.
23:44:36 <cads> heh, that paper is great
23:46:42 <cads> thanks for mentioning that paper, you reminded me I was going to lookup some of the references to it
23:46:48 <dolio> For category theory underpinning datatypes, A Tutorial on (Co)Algebras and (Co)Induction is good.
23:47:36 <cads> I'll also check out girard's book
23:48:35 <cads> hey, am I right to feel like denotational semantics is going to feel more like recursive set theory, and operational semantics feels more like graph reduction?
23:50:16 <cads> when I can actually understand moggi's notions of computation and monads I will maybe wonder abotu where functorial semantics should fit in with my views :D
23:50:29 <dolio> Probably.
23:50:58 <dolio> Denotational semantics is about associating expressions with mathematical objects, which are probably going to be grounded in set theory.
23:55:52 <cads> Operational semantics seems to deal with semantics as defined by functions that reduce terms to values, but this seems like this would be based on a set based definition of functions, and would still require some kind of heavy set machinery to define the domains for these operations - on the other hand we can study functions like that without thinking of them as based on sets - maybe we view domains as inductively generated by our operations?
23:57:04 <dolio> Well, operational semantics has something to do with operations on some abstract machine, generally.
23:58:04 <dolio> If you want to get really out-there and mathematical, you can have your 'machine' simply be something that rewrites lambda (or some fancier type of) terms according to various rules (beta, eta, whatever).
23:58:28 <dolio> Which is what you're studying when you look at normalization of such terms.
23:58:51 <cads> hmm, you can have just an arbitrary model in the sense of model that we use in logic
23:59:40 <cads> and then I bet you might construct mappings from one transition system to another?
