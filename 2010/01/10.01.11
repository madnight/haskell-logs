00:07:45 <bos> tibbe: i got the kqueue code working!
00:07:52 <tibbe> bos: yay!
00:08:04 <tibbe> bos: we're getting there :)
00:08:28 <bos> tibbe: ran into an interesting bug along the way
00:08:40 <bos> which took me hours to find
00:09:04 <bos> tibbe: see email i'll be sending shortly
00:10:04 <ivanm> what kqueue code is this?
00:10:35 <tibbe> bos: unexpected behavior from kqueue or just my bad coding? :)
00:10:54 <bos> tibbe: both :-)
00:11:05 <bos> tibbe: actually, an ABI mismatch bug, believe it or now
00:11:09 <bos> or not, i mean
00:11:26 <tibbe> bos: while I'm at it. we need to think about what to do in the case of EINTR as just retrying the system call might have us wait longer than expected
00:11:33 <tibbe> bos: that's interesting
00:11:43 <tibbe> bos: bad FFI wrapping?
00:12:01 <bos> tibbe: you should have the patch with explanation in your inbox now
00:12:24 <tibbe> bos: checking
00:13:04 <bos> tibbe: GHC just reruns the poll loop on EINTR, which is reasonable
00:13:36 <tibbe> bos: lets do that to then (see my TODO in the code)
00:13:47 <tibbe> bos: when was kqueue64 introduced?
00:13:59 <bos> tibbe: i don't know. it's there on snow leopard.
00:14:29 <tibbe> bos: I'll try to compile and see if I have it
00:14:42 <bos> tibbe: ok. if it's not there, it'll be easy to #ifdef it in.
00:14:49 <bos> tibbe: might be necessary on freebsd anyway.
00:14:57 <tibbe> bos: right
00:15:01 <manjunaths> data Maybe a = Nothing | Just a
00:15:09 <manjunaths> why is the Just needed >
00:15:09 <tibbe> bos: can we reliably detect 32 vs 64-bit systems?
00:15:16 <manjunaths> data Maybe a = Nothing | a
00:15:23 <tibbe> manjunaths: each constructor needs a name
00:15:24 <bos> tibbe: looks like freebsd doesn't have kevent64
00:15:25 <manjunaths> what's wrong with this ?
00:15:33 <manjunaths> tibbe, ok
00:15:35 <tibbe> bos: hmm, ok. ifdef it is then
00:15:36 <bos> tibbe: we could if we needed to, but i don't think we need to.
00:15:49 <bos> i guess i need to install a freebsd vm at some point.
00:15:50 <tibbe> manjunaths: consider this data Maybe a = Nothing | a | a
00:16:04 <tibbe> manjunaths: if you want to signal to different kinds of situations
00:16:19 <tibbe> bos: I should try the on OS X leopard
00:16:29 <tibbe> bos: my machine is not 64-bit I believe
00:17:05 <bos> tibbe: on plain old leopard, everything in userspace is 32-bit
00:17:42 <tibbe> bos: right, but does the *64 system call exist?
00:18:16 <bos> tibbe: dunno, you're the one with the older version of the OS, not me :-)
00:18:32 <tibbe> bos: checking right now
00:19:46 <tibbe> bos: I need to run to work so I don't miss breakfast!
00:19:51 <tibbe> (cause then I'll be cranky ;) )
00:19:57 <manjunaths> where can I find more information about 'Just' ?
00:20:06 <tibbe> bos: I'll give it a try once I'm at work and drop you an email with the result
00:21:35 <bos> tibbe: the offending bug: http://hackage.haskell.org/trac/ghc/ticket/3681
00:22:12 <tibbe> bos: thanks
00:22:15 <tibbe> bos: ttyl!
00:32:42 <quicksilver> ivanm: quicksilver always hears.
00:59:02 <bos> yay http://www.reddit.com/r/haskell/comments/ao3zd/progress_on_ghcs_io_manager/
01:01:07 <merehap> bos: exciting!
01:01:26 <merehap> though I am curious as to why you wish to avoid git altogether...
01:01:56 <bos> merehap: not using git makes me a better person.
01:02:25 <merehap> ah, that clarifies it a lot
01:02:39 <Cale> hehe
01:03:31 <c_wraith> wait, I thought it was not using svn that did that.
01:03:35 <Cale> Good work on the event stuff bos! There are a lot of people on the CC list for that ticket. :)
01:04:02 <merehap> so when will darcs be up to par performance-wise with git/mercurial
01:04:20 <merehap> I await the day that not using mercurial also makes one a better person
01:04:33 * Cale wonders if mercurial has the same merging issues that most of the other VCSes do.
01:04:44 <tensorpudding> why are we associating the character of our persons with the DVCS that we use
01:04:54 <c_wraith> because svn is evil.
01:04:58 <merehap> though I haven't worked on a project large enough to merit not using darcs
01:05:05 <merehap> well yes, but that isn't DVCS
01:05:14 <voidprayer> Excuse me. I am reading the "Guards" part in RWH. The example defines "nodesAreSame _ _ = Nothing" for returning Nothing if the former conditions are not matched. I remember that function definition are regardless of the sequence. What about here?
01:05:51 <c_wraith> I've used darcs in cases where it's gone wrong.  It's not pretty.  We have one tree that you can't do a full checkout from.  it just doesn't work.
01:05:57 <Cale> voidprayer: Within the definition of a function, pattern matches are tried in order, and their order tends to matter.
01:06:03 <ketil> bos: uh, the reddit link, I get "there doesn't seem to be anything here"?
01:06:09 <Cale> voidprayer: and guards are tried in order as well
01:06:15 <voidprayer> Cale: Thanks.
01:06:19 <c_wraith> ketil: there are no comments.  click on the title to go to the blog post
01:06:21 <merehap> bos is gone
01:06:32 <ketil> oh, wait.  I see.
01:06:38 <ketil> Sorry, new to reddit. :-/
01:06:53 <merehap> you've been missing out
01:07:00 <Cale> voidprayer: The interesting thing about guards is that if all the guards for a matching pattern fail, you fall through to trying the next pattern.
01:07:02 <Botje> @tell bos did you look at libevent? if so, any specific reason you chose not to use it? Just asking out of interest :)
01:07:02 <lambdabot> Consider it noted.
01:07:07 <tensorpudding> reddit has already gone to crap
01:07:10 <tensorpudding> for the most part
01:07:12 <Botje> yes.
01:07:17 <Botje> except for haskell.reddit
01:07:21 <tensorpudding> though /r/haskell is still pretty good
01:07:23 <ketil> merehap, yes, going via reddit sure buys a lot compared to, you know, linking directly to the blog? :-)
01:07:24 <Botje> and programming.reddit, sometimes.
01:07:27 <Cale> voidprayer: Which is something that's not easy to do with, say, nested if/then/else
01:07:29 <tensorpudding> almost 99% of that is due to dons
01:07:31 <c_wraith> Botje: Look at bos's previous posts on the topic.
01:07:48 <tensorpudding> there are a few other good subreddits
01:07:49 <merehap> well, there will be comments there eventually...
01:07:54 <voidprayer> Cale: I see. Thank you.
01:07:57 <Botje> i dont' remember seeing anything about libevent
01:08:01 <Botje> i'll check again
01:08:07 <ivanm> quicksilver: quicksilver is also very modest, isn't he? ;-)
01:08:34 <merehap> what's wrong with just unsubscribing from r/politics and r/worldnews?
01:08:40 <Botje> hmm.
01:08:42 <c_wraith> Botje: there's some discussion in the comments of his first post on the topic.
01:08:47 <Botje> yeah, i just read them.
01:08:54 <tensorpudding> there's almost no useful content on the frontpage
01:09:08 <Botje> @tell bos nevermind, i just found the comment on your previous post :)
01:09:08 <lambdabot> Consider it noted.
01:09:16 <Phyx-> never been to reddit, what is it?
01:09:31 <tensorpudding> reddit is kinda like a better digg
01:09:46 * Cale wonders where that handy page was that illustrated the problem with the majority of version control systems' merge algorithms. (That isn't a problem in darcs and camp.)
01:10:04 <int-e> It's dons' favourite URL obfuscator.
01:10:16 <merehap> ha :)
01:11:07 <Trinithis> @faq Can coding in Haskell help one program while drunk?
01:11:08 <lambdabot> The answer is: Yes! Haskell can do that.
01:11:20 <c_wraith> drunken type errors?
01:11:32 <Phyx-> Trinithis: done it a few times, got surpringly good results
01:11:44 <Phyx-> code usually works, and works well, though i usually can't understand it
01:11:46 <Trinithis> I had to ask cause I'm sipping a shot glass
01:11:48 <ketil> @faq Can drinking help one program in Haskell?
01:11:48 <lambdabot> The answer is: Yes! Haskell can do that.
01:12:38 <Trinithis> Though another certain substance does indeed help
01:12:46 * ketil thinks about the transitive closure of drinking.
01:12:50 <Phyx-> Trinithis: the while drunk part is true.. but the when hungover part no..
01:12:50 <Trinithis> lol
01:12:53 <tensorpudding> the number of subreddits with good signal to noise is unfortunately low
01:15:07 <notanyone> "Unto him that blasphemeth against the Holy Ghost it shant be forgiven" Lk12:10
01:15:07 <notanyone>     Dear JEWS, you are liars, traitors and blasphemers going to hell!
01:15:07 <notanyone>  Jesus Christ says that upon your judgement you shall be THROWN IN AN OVEN
01:15:07 <notanyone> "cast them into a FURNACE OF FIRE, there shall be wailing and gnashing" Mt13:42
01:15:07 <notanyone> Before it is too late, repent and tithe away your material wealth to the GNAA
01:15:07 <notanyone>     at irc.hardchats.com #gnaa to achieve salvation before the end of days
01:15:09 <notanyone>       REPENT YOUR SIN      The End of The World            Apologize
01:15:11 <notanyone>        JEWBOY                    Is Near                      for the
01:15:13 <notanyone>                                                        MURDER of CHRIST
01:15:14 <medfly> @where ops
01:15:15 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
01:15:38 <tensorpudding> huh, that guy was trolling #debian just ten minutes or so ago
01:15:44 <Jonno_FTW> what the hell just happened?
01:15:44 <ivanm> notanyone: kindly do everyone a favour and f*** off
01:15:48 <medfly> I guess he trolls every large channel
01:15:50 <notanyone> lambdabot: i am not trolling
01:15:53 <c_wraith> tensorpudding: they tend to target channels with lots of users
01:15:54 <notanyone> i am spreading the gospel of jesus christ
01:15:55 <tensorpudding> yes
01:15:58 <notanyone> i am trying to help you
01:16:03 <ivanm> notanyone: that isn't in the gospel at all
01:16:07 <notanyone> yes it is
01:16:07 <Jonno_FTW> GNAA?
01:16:11 <notanyone> matthew 13:42
01:16:14 <notanyone> look it up, right now
01:16:23 <ivanm> and you do realise that the apocalypse is metaphorical in nature?
01:16:24 <merehap> do we have no mods on this channel?
01:16:26 <notanyone> those who do not follow the covenant of god shall be thrown into furnaces.
01:16:27 <tensorpudding> oh, GNAA is back?
01:16:27 <ivanm> (wrt revelations)
01:16:27 <Jonno_FTW> the gay n***er asosciation of america
01:16:29 <medfly> notanyone: I doubt any religious text includes the address of an IRC server.
01:16:37 <ivanm> notanyone: there is nothing anti-jew in the bible
01:16:40 <tensorpudding> they're like the harlem globetrotters of trolling
01:16:43 <ivanm> medfly: heh
01:16:45 <notanyone> ivanm: there isnt?
01:16:46 <notanyone> john 8
01:16:51 <notanyone> jesus christ calls the jews non-abrahamic
01:16:52 <Jonno_FTW> i demand a voteban
01:17:01 <c_wraith> Jonno_FTW: this isn't a quake server
01:17:02 <notanyone> he calls them murderers and liars, as their fathers were
01:17:03 <tensorpudding> why hasn't there been a ban yet...where did Cale run to
01:17:03 <ivanm> notanyone: all jews or a specific jew?
01:17:05 <Trinithis> @faq Can Haskell98 replace the Bible?
01:17:06 <lambdabot> The answer is: Yes! Haskell can do that.
01:17:11 <medfly> hehe
01:17:12 <Jonno_FTW> hazah!
01:17:13 <Botje> if those guys weren't doing it from hacked hosts i'd say ban their IP addresses and the ISP they're trolling from.
01:17:13 <notanyone> ivanm: all good jews recognized christ as the messiah
01:17:17 <ivanm> @slap Trinithis
01:17:17 * lambdabot decomposes Trinithis into several parts using the Banach-Tarski theorem and reassembles them to get two copies of Trinithis!
01:17:24 <Jonno_FTW> bow down to the mighty lambdabot
01:17:24 <Botje> and send a small nuclear missile their way.
01:17:25 <ivanm> Trinithis: that will _really_ get the idiots going
01:17:26 --- mode: ChanServ set +o quicksilver
01:17:32 <quicksilver> notanyone: go away
01:17:34 <notanyone> anyone that still intends to fulfill deuteronomy 6:10-11
01:17:35 <notanyone> is evil
01:17:38 --- mode: quicksilver set +b *!*n=tomato@*.rains.net
01:17:38 --- kick: notanyone was kicked by quicksilver (fuck off)
01:17:38 --- mode: ChanServ set +o Cale
01:17:42 <Cale> oop
01:17:46 <Cale> too slow :)
01:17:47 <quicksilver> to early in the morning for polite kick messages
01:17:49 <ivanm> quicksilver: \o/
01:17:54 --- mode: Cale set -o Cale
01:17:54 <medfly> :)
01:17:54 <Botje> quicksilver++
01:18:00 <quicksilver> or correct spelling of 'too', apparently.
01:18:01 <Jonno_FTW> upvote
01:18:02 <tensorpudding> hmm, which one is 6:10-11
01:18:17 <Botje> the one with the letters!
01:18:40 <quicksilver> anyhow, I have work to do before we all get thrown into the furnaces.
01:19:00 <merehap> we need a biblebot on this channel so that we can answer these deep questions about scripture
01:19:06 <ivanm> he just tried to keep talking to me
01:19:08 <ivanm> ...
01:19:12 <medfly> hehehe
01:19:27 <medfly> I think he just came up with a random thing :)
01:19:30 <Jonno_FTW> don't feed the trolls, it only makes them stronger
01:19:34 <tensorpudding> it looks boring
01:19:45 <tensorpudding> i'm not sure what he had against those two verses
01:20:28 <merehap> yeah, they weren't actually anything exciting
01:26:22 <ivanm> merehap: that jews were evil apparently
01:27:58 <tensorpudding> the jews did have the whole paranoid guy in the sky thing going on
01:28:09 <merehap> I still can't see how it would follow from that passage (I'm not going to link to it here :) )
01:30:28 --- mode: quicksilver set -o quicksilver
01:32:39 <EnglishGent> morning all :)
01:35:19 <Botje> hello
01:38:14 <FauxFaux> Get the linux build to trigger the second windows build?
01:38:22 <FauxFaux> Wrong window (obviously).
01:39:11 <ivanm> EnglishGent: my window doesn't think it's morning... >_>
01:39:30 <Botje> ivanm: mine does
01:39:37 <Botje> well, it's grey
01:39:41 <Botje> not ncessarily morning
01:39:50 <ivanm> he, I can barely see anything out of mine...
01:39:58 <Niccus> mine shows the wonderful brightness of light pollution mixed with cloudy sky
01:46:15 <Cale> http://i.imgur.com/VRAKc.jpg <-- awesome :)
01:46:42 <tensorpudding> you broke the universe
01:47:15 <joga> wow
01:48:02 <Cale> Though I wonder what's going on with the half-portal there which looks disconnected.
01:48:52 <Cale> (the image of the blue portal in itself looks like it's filled with a disconnected orange portal)
01:49:04 <ivanm> Cale: seen the latest xkcd?
01:49:09 <Cale> no
01:49:15 * Cale checks
01:49:41 <ivanm> http://www.reddit.com/r/math/comments/ao2fu/touch%C3%A9_randall_munroe/ <-- someone doing independent verification
01:49:42 <Cale> haha
01:49:59 <ivanm> but wolfram alpha refuses to get the values themselves...
01:50:05 <ivanm> some knowledge engine it is!
01:50:05 <ivanm> ;-)
01:50:35 <Cale> WA has lots of issues with simple things you'd think would work.
01:50:56 <nigguboy> hello
01:51:13 <Cale> Try "dielectric constant of steel"
01:51:26 <amigoo> u alive?
01:51:37 <amigoo> Cale? or anyone else?
01:51:49 <Cale> Lots of people
01:52:08 <amigoo> ok good
01:52:13 <amigoo> I got a few question
01:52:18 <ivanm> Cale: well, I'm not!
01:52:34 * ivanm hates this "life-ist" prejudices prominent in today's society
01:52:53 <amigoo> what's a good programming language for making website?
01:53:13 <ivanm> amigoo: you do realise the people here will only really give you one answer, don't you?
01:53:14 <Cale> ivanm: Somehow it correctly interprets what "dielectric constant of steel" means, giving [steel alloy | relative static permittivity], and then gives a result consisting of a bunch of | characters.
01:53:24 <ivanm> heh
01:53:49 <ivanm> bah, how hard is it for latex/beamer to have \includegraphics do so at the correct resolution?
01:54:04 <ivanm> I have to keep manually tweaking the width I'm including them at so that they look decent :@
01:54:37 <Cale> I'm not sure, but I think that .eps files have some measure of absolute units.
01:56:05 <ivanm> well, I'm using pngs with pdflatex
01:59:13 <Cale> Ah, probably because it doesn't really have a good idea about how many pixels per unit of length to use.
01:59:50 <amigoo> sf
01:59:58 <ivanm> yeah
02:00:29 <ivanm> OK, apparently graphviz' default dpi is 96; so why does identify say they have a res of 72dpi?
02:00:36 <amigoo> I have no idea what u guys talking bout
02:00:58 <ivanm> latex atm
02:01:07 <ivanm> amigoo: what kind of channel do you think this is?
02:01:17 <Cale> hehe
02:01:25 <amigoo> oh, i am no programmer
02:01:38 <amigoo> just came to ask a quick question to you smart programming people
02:01:47 <shambler_> bwahaha
02:01:50 <shambler_> typical
02:01:59 <ivanm> amigoo: yes, but we only talk about one programming language
02:02:12 <ivanm> so coming in here to ask us about which programming language to use is a little silly...
02:02:21 <ivanm> since for the most part you can predict what answer we'd provide!
02:02:48 <amigoo> I am not that smart to predict what you guys are thinking about
02:02:50 <ivanm> (which is, of course, MIX assembly as used in TAOCP :p )
02:02:55 <ivanm> amigoo: see the channel topic?
02:02:58 <Cale> It's weird that Portal continues traversing the image of the orange portal in itself, but not the blue portal in itself.
02:03:01 <shambler_> html!..
02:03:33 <amigoo> yea but I have frontpage editor, it's just too redundand
02:03:43 <Cale> Perhaps this asymmetry is to prevent the tree from branching out too much.
02:03:46 <amigoo> every time I add a link to the side bar
02:04:01 <amigoo> for every page
02:04:10 <tensorpudding> knowing how Portal handles that stuff would be interesting
02:06:20 <Phyx-> i know i'm sleepy but... what the heck are you guys on about
02:06:41 <amigoo> I am trying to figure out what a good website programming language
02:06:52 <amigoo> other than html
02:06:59 <Phyx-> in this channel?
02:07:09 <amigoo> I thought u guys might know
02:07:09 <ivanm> amigoo: yeah, he doesn't get the hint
02:07:19 <ivanm> amigoo: html is what's used for actual web pages
02:07:20 <amigoo> since u guys are programmers
02:07:30 <ivanm> you can generate them with another language, but that's about it for static pages
02:07:39 <tensorpudding> there is xhtml
02:07:40 <ivanm> and as I've said, this channel is pretty language specific
02:07:50 <ivanm> tensorpudding: and that's easier/nicer than html _how_? ;-)
02:07:56 <ivanm> @where pandoc
02:07:56 <lambdabot> http://sophos.berkeley.edu/macfarlane/pandoc/
02:07:57 <tensorpudding> just aying
02:07:59 <bo0ts__> amigoo: Did I read FrontPage? Seriously?
02:08:00 <amigoo> I've got nowhere else to go
02:08:02 <Phyx-> ivanm: heh, what hint am i missing?
02:08:02 <ivanm> amigoo: ^^ have a look at pandoc
02:08:15 <ivanm> Phyx-: he's asking us which language we recommend
02:08:37 <tensorpudding> does frontpage produce table-ridden html still?
02:08:46 <amigoo> i was trying that ruby programming, but it was just mathematical
02:08:49 <Phyx-> ivanm: i would think the answer in this channel would be biased
02:08:49 <Phyx-> lol
02:09:00 <ivanm> Phyx-: that's my point
02:09:06 <bo0ts__> tensorpudding: Isn't FrontPage what all those geocities pages where made with? All those blink tags?
02:09:08 <ivanm> amigoo: wtf? ruby is mathematical?
02:09:21 <Cale> amigoo: Haskell progamming will be closer to mathematical than Ruby, of course.
02:09:30 <ivanm> I hate to tell you this, but _all_ programming is mathematical; however, from what I've seen of ruby, it isn't really that mathematical in comparison to other languages
02:09:31 <tensorpudding> HTML is just a markup language
02:09:35 <amigoo> is Matlab considered programming?
02:09:37 <cord> hi, correct me if i'm wrong about State monad, it's basically currying function to some state passed through runState ?
02:09:40 <amigoo> i took the class and I did pretty well
02:09:44 <tensorpudding> ruby is a turing-complete general-purpose language
02:09:49 <ivanm> amigoo: yes, for a restricted subset of programming
02:09:53 <ivanm> since it isn't turing complete
02:10:00 <ivanm> cord: something like that
02:10:03 <Cale> cord: I don't understand your sentence.
02:10:36 <tensorpudding> writing HTML is a kind of programming i guess
02:10:52 <amigoo> I use frontpage 2007
02:10:53 <Cale> cord: But basically, computations of type (State s a) are internally represented by functions  s -> (a,s)  -- that is, functions from an initial state to a result and a final state.
02:11:05 <cord> Cale, what i mean is the function should do something and return it with the new state, with the state monad all i've to do is just pass the state first and keep currying
02:11:07 <Cale> cord: (there are other ways to implement it though)
02:11:07 <amigoo> the problem is, every time I add a link to the sidebar, i have to do it for every page
02:11:08 <tensorpudding> in the same sense that writing a LaTeX document is
02:11:23 <Cale> cord: I think currying is the wrong word.
02:11:52 <cord> Cale, i think implicit state passing is the word ?
02:11:55 <Cale> cord: But it lets you avoid all the extra parameter passing and manual tupling/untupling that you'd have to do.
02:12:04 <Cale> yeah
02:12:08 <ivanm> amigoo: so use a separate page for the sidebar and load that up in all your other pages using frames or something
02:12:30 <tensorpudding> or use php to load snippets or something
02:12:32 <ivanm> amigoo: go read some HTML/web design tutorials ;-)
02:13:08 <amigoo> can haskell be used for programming websites?
02:13:10 <tensorpudding> though php will leave you feeling nice and dirty afterwards
02:13:11 <cord> Cale, okay, what about the Reader ? what is the point of passing the environment while it won't get changed ?
02:13:26 <tensorpudding> amigoo: unless apache has a mod_haskell plugin, probably not
02:13:32 <Phyx-> moment of truth, either my earphones are fixed, or i'll electrocute myself
02:13:50 <ivanm> amigoo: yes
02:14:00 <ivanm> amigoo: really basic ones with pandoc, etc.
02:14:09 <ivanm> or else you can go all the way up to happstack
02:14:19 <ivanm> Phyx-: so? what's the verdict?
02:14:22 <tensorpudding> happstack is one of those fancy web frameworks
02:14:39 <tensorpudding> though it is probably not going to be as usable as rails
02:14:48 <Phyx-> ivanm: fixed :)
02:14:55 <ivanm> \o/
02:15:05 <ivanm> we haven't lost another haskeller!
02:15:05 <ivanm> ;-)
02:15:11 <Phyx-> hehehe
02:15:32 <amigoo> so what's the big deal with haskell? what's the major use?  I don't see any other use of programming other than making websites and calculating things
02:16:00 <ivanm> amigoo: you use a computer, right?
02:16:04 <amigoo> yea
02:16:08 <ketil> amigoo: a website is also 'calculating things', so there's really only one use. :-)
02:16:24 <ivanm> amigoo: what do you use that computer for?
02:16:38 <amigoo> well, reading things online, mail, chat and stuff
02:16:44 <Cale> Everything that a computer does is secretly calculation.
02:16:52 <ivanm> amigoo: right, and what do you think lets you do all that kind of stuff?
02:16:55 <kamatsu> Axman6: hey, you said you were in sydney. Which university?
02:17:18 <tensorpudding> the operating system you run, the web browser you view webpages with, and the irc client you use to chat here at this moment all had to be coded using a programming language
02:17:19 <amigoo> ivanm: is that a trick question?
02:17:25 <tensorpudding> Cale: covert calculation?
02:17:31 <ivanm> amigoo: not at all
02:17:53 <ivanm> amigoo: if someone hadn't of programmed it, then how do you think you'd be able to use your IRC client to talk to us here?
02:18:01 <amigoo> well, program lets me do all that stuff I guess.  probably using assembly languages
02:18:01 <ivanm> kamatsu: he isn't
02:18:06 <ivanm> he's at ANU in canberra
02:18:09 <kamatsu> oh
02:18:31 <ivanm> amigoo: ummm.... the only people using assembly are for really low level things or if they desperately need a speed boost
02:18:39 <merehap> amigoo: nope, using C,C++,Java,Python,Haskell,etc.
02:18:44 <ivanm> amigoo: I doubt any software you use day to day has any hand-written assembly code in it
02:18:50 <kamatsu> he mentioned a haskell course, i was wondering if he was at UNSW, is all
02:18:52 <kamatsu> (cos I am)
02:18:57 <ivanm> besides, programming in assembly is still programming ;-)
02:19:05 <tensorpudding> there are some toy OS's that are coded in x86 assembly
02:19:05 <ivanm> kamatsu: nah, they teach that at ANU as well
02:19:09 <kamatsu> ivanm: er, kernel? surely has a little
02:19:13 <ivanm> also at some melbourne unis IIRC
02:19:21 <ivanm> kamatsu: he doesn't actually use that though
02:19:24 <amigoo> so what do YOU guys use haskell for?  give me something realistic to relate to
02:19:26 <ivanm> I meant things he actually interacts with
02:19:31 <ivanm> tensorpudding: yes, _toys_
02:19:34 <kamatsu> amigoo: writing games =D
02:19:36 <ivanm> amigoo: any programming we want to do
02:19:51 <tensorpudding> where is the haskell operating system
02:19:59 <kamatsu> tensorpudding: search for "House"
02:20:02 <ivanm> @where house
02:20:03 <lambdabot> http://programatica.cs.pdx.edu/House/
02:20:09 <amigoo> well, games sounds interesting
02:20:13 <ketil> amigoo: bioinformatics (i.e. data analysis and text manipulation)
02:20:16 <tensorpudding> i have seen it, but i thought that was pretty dead
02:20:19 <amigoo> so games like WOW is made from haskell?
02:20:22 <Eduard_Munteanu> What does the := operator mean? I'm playing with Gtk2Hs.
02:20:26 <kamatsu> amigoo: no, most games are made in C++
02:20:28 <ivanm> amigoo: WOW isn't in Haskell
02:20:33 <tensorpudding> WoW uses a lot of Lua
02:20:36 <ivanm> kamatsu: well, bigger ones maybe
02:20:40 <kamatsu> right
02:20:44 <ivanm> but a lot of smaller ones use python as well...
02:20:47 <Eduard_Munteanu> !hoogle :=
02:20:47 <tensorpudding> for scripting
02:20:51 <Cale> Eduard_Munteanu: Well, it means attribute assignment, but it's really just a data constructor
02:21:01 <kamatsu> the graphics end stuff is all still in the C world
02:21:12 <amigoo> would you guys recommend haskell for beginner programmers?
02:21:17 <ivanm> sure
02:21:19 <kamatsu> yes
02:21:24 <tensorpudding> it's fine for beginners
02:21:34 <ivanm> amigoo: a word of warning: haskell is very different from other "main-stream" programming languages
02:21:37 <kamatsu> in fact, it's *better* for beginners than for people coming from other language
02:21:40 <Eduard_Munteanu> Cale, thanks.
02:21:46 <ivanm> but we all believe that those differences provide us with more power and make it easier to program
02:21:48 <tensorpudding> if the only languages you know are imperative C-style languages, the experience you have with them might actually be detrimental
02:21:51 <ivanm> kamatsu: yup
02:21:59 <ivanm> tensorpudding: he only knows matlab AFAICT
02:22:10 <tensorpudding> because you'll have certain expectations on how things work
02:22:10 <kamatsu> ah, good start
02:22:17 <ivanm> amigoo: haskell looks a lot more like maths than other languages do (even matlab!)
02:22:27 <tensorpudding> even MATLAB has C syntax and structure
02:22:59 <kamatsu> amigoo: have you been linked to all the good haskell tutorials (lyah and rwh?)
02:23:24 <amigoo> no,not yet
02:23:33 <amigoo> I been trying ruby all night
02:23:46 <tensorpudding> amigoo: which ruby guide?
02:23:48 <Eduard_Munteanu> I have this expression and can't wrap my head around it: \row -> [ cellText := name row ]
02:23:50 <kamatsu> ruby is a nice language but in my opinion not nice for beginners
02:23:53 <merehap> amigoo: ruby is a decent language
02:23:58 <Eduard_Munteanu> "name" is a field
02:24:09 <Cale> Eduard_Munteanu: The attributes themselves consist of operations for accessing and updating some piece of mutable state relative to an object of some type, and := pairs that attribute with a value to set it to. The 'set' function goes through a list of such attribute/value pairs and performs the requested operations
02:24:10 <amigoo> i used ruby-lang
02:24:12 <kamatsu> haskell has a very pure and minimal set of semantics
02:24:25 <tensorpudding> ah
02:24:33 <Phyx-> I wonder, how an iphone breaks when you throw it in water, large stylish sparks, then a boom, or just fizzle and pop
02:24:39 <amigoo> what's a major thing anyone used haskell for?
02:24:56 <kamatsu> amigoo: writing the haskell compiler.. if you've ever used Linux, there's the xmonad window manager
02:24:57 <Gilly> the haskell compiler is a good example of a big project
02:24:59 <merehap> amigoo: XMonad, a tiling window manager is quite popular
02:25:02 <tensorpudding> xmonad, parsec, ghc
02:25:03 <kamatsu> darcs version control system
02:25:11 <Cale> Eduard_Munteanu: So that function takes a row, and produces the one-element list consisting of the AttrOp which sets cellText to the name of the row.
02:25:23 <kamatsu> also Happstack is a great web app platform
02:25:44 <kamatsu> (our answer to Ruby on Rails, i guess)
02:25:56 <Eduard_Munteanu> Cale, I see. Does 'name' even have a type?
02:26:02 <amigoo> I am thinking about giving haskell a chance, learning it that is, since you guys seems to be very convincing.  But I am not sure how useful it will be
02:26:04 <Eduard_Munteanu> The expression I mean.
02:26:06 <Cale> Eduard_Munteanu: it must.
02:26:18 <Gilly> amigoo: what do you want to do?
02:26:26 <Cale> Eduard_Munteanu: If it's a field of some record type, then it's an extractor function for that field.
02:26:32 <Eduard_Munteanu> Cale, can I pass it as a parameter from another function? Say it's not only 'name' but 'value' as well.
02:26:40 <tensorpudding> is pugs still a big deal?
02:26:48 <Cale> tensorpudding: no, it's mostly dead
02:26:53 <tensorpudding> oh
02:27:00 <idnar> was pugs ever a big deal?
02:27:02 <kamatsu> amigoo: well, the first thing you have to understand is that most programming languages are turing-complete, which means they can do everything any other programming language can. Really you should be choosing a language based on syntactic style, semantic elegance and performance considerations. In my opinion Haskell has a good balance between all three.
02:27:10 <kamatsu> Ruby favours syntactic style over everything else
02:27:18 <ivanm> idnar: it was at one stage
02:27:20 <tensorpudding> well, it was the first
02:27:25 <ivanm> but now there's other partial implementations of perl6
02:27:41 <idnar> I guess it depends on how you define "big deal"
02:27:52 <idnar> but since nobody cares about perl6, I dunno why they would care about pugs ;)
02:27:55 <kamatsu> Haskell is great for implementing programming languages
02:27:57 <tensorpudding> well, perl6 isn't a big dead on a large scale
02:28:02 <tensorpudding> agda!
02:28:14 <Cale> Implementing small programming languages is a great way to solve programming problems in general.
02:28:22 <tensorpudding> that's what ruby says too
02:28:25 <amigoo> hmm, I guess I will go through one of the tutorials.  I am on haskell org?  is that a good one?
02:28:34 <kamatsu> amigoo: haskell.org is just the haskell website
02:28:38 <Cale> amigoo: maybe start with learnyouahaskell.com
02:28:40 <kamatsu> amigoo: try www.learnyouahaskell.com
02:28:41 <tensorpudding> @where lyah
02:28:41 <lambdabot> http://www.learnyouahaskell.com/
02:28:42 <kamatsu> gah
02:28:44 <Cale> hehe
02:28:57 <tensorpudding> also if you like thorough books
02:28:59 <tensorpudding> @where rwh
02:29:00 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:29:09 <kamatsu> (second link)
02:29:11 <ivanm> craft of functional programming is one of the best intro books IMHO
02:29:24 <ivanm> kamatsu: I wouldn't give RWH to a beginning programmer
02:29:45 <tensorpudding> RWH would be appropriate to follow up LYAH
02:29:50 <kamatsu> ivanm: hm, true, but I think it can serve as a decent companion to teach things like monads which aren't covered by LYAH
02:29:51 <amigoo> glad to see you guys are very supportive of your community.  if i end up liking it, that's probably one of the reasons.  thanks, I will be off to the tutorial for now, maybe I will be back later
02:29:54 <amigoo> chao
02:29:56 <Eduard_Munteanu> I want to initialize a list by passing the column names as parameters: http://pastebin.org/74188
02:29:59 <cord> what about the Reader monad? what is the point of passing the environment while it won't get changed ?
02:30:04 <kamatsu> amigoo: ciao! let us know if you have trouble
02:30:12 <Eduard_Munteanu> Right now it does headers, but I can't add any rows (they don't appear)
02:30:16 <Eduard_Munteanu> Any ideas?
02:30:31 <Botje> cord: you could use it to keep a list of variables in scope as you traverse an AST
02:31:01 <ivanm> cord: so you don't have to provide 50 million different variables which you only use to read, etc.
02:31:11 <Cale> Eduard_Munteanu: hmm...
02:31:12 <ivanm> (well, that's what _I_ use it for, anyway)
02:31:27 <Botje> cord: and it's indeed often used to pass around static information
02:31:42 <ivanm> cord: you can consider (_very_ roughly) of Reader as a read-only State
02:31:59 <Cale> cord: Mostly the reader monad is heavier than it's worth, and I don't use it much (though I do use the unravelled version, the function monad)
02:32:24 <ivanm> Cale: how is it heavier than it's worth? :o
02:32:32 <cord> hmm i think it'll get clear with more using to compare the approaches :(
02:32:42 <Jafet> Phyx-, I doubt you can electrocute yourself with a ~1W PCM signal
02:32:43 <Cale> ivanm: Passing parameters explicitly isn't that bad.
02:33:17 <Eduard_Munteanu> Cale, the thing is I don't understand the cellLayoutSetAttributes thing. I think it's supposed to map the store into columns.
02:33:25 <Cale> (when you're only passing them forward and not having to tuple things with your results)
02:33:48 <ivanm> Cale: well, the only time I've used it for SourceGraph; and there I'm actually using RWS (not using the W bit yet though)
02:33:57 <Cale> okay, so from here: http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-ModelView-CellLayout.html#v%3AcellLayoutSetAttributes
02:34:07 <ivanm> because I do a lot of funky stuff with what values are used in the Reader (for tying the knot purposes)
02:35:31 <Eduard_Munteanu> Cale, yeah, I simply want to do the cellText := x thingy in such a way to get it automatically.
02:35:59 <Eduard_Munteanu> Because I already add columns by passing a [String] to listInit.
02:36:02 <Cale> get what automatically?
02:36:48 <Eduard_Munteanu> Cale, I don't want to write that line for every column I add. I want it to work with a list of column names.
02:37:13 <Eduard_Munteanu> I already this in main: listInit listProd prodStore [ "Name", "Contact" ]
02:37:31 <Eduard_Munteanu> And I want to be able to add rows to the list and have them visible :)
02:37:38 <andrewe_> @src (>>=) :: [a] -> (a -> [b]) -> [b]
02:37:38 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:37:39 <Eduard_Munteanu> *already do
02:38:39 <Botje> andrewe: >>= for lists is concatMap
02:38:49 <andrewe> Botje: thanks
02:38:54 <andrewe> @src concatMap
02:38:55 <lambdabot> concatMap f = foldr ((++) . f) []
02:38:58 <Botje> > [1,2,3] >>= \x -> [x,x,x]
02:38:59 <lambdabot>   [1,1,1,2,2,2,3,3,3]
02:39:28 <Cale> Eduard_Munteanu: I'm afraid I'm not really all that familiar with GTK, especially around all this listview/model stuff.
02:39:32 <Botje> (well, flip concatMap)
02:39:33 <cord> i've to go, gotta drop by the hospital :(
02:39:37 <cord> thanks everyone
02:40:37 <Eduard_Munteanu> Cale, thanks.
02:40:56 <Eduard_Munteanu> I'll try to zip colnames somehow and try to retrieve the data by index.
02:41:02 <Cale> Eduard_Munteanu: apparently those functions are deprecated though
02:41:25 <Eduard_Munteanu> Cale, hm, that's what the examples in Gtk2Hs show.
02:41:25 <Cale> Eduard_Munteanu: The documentation for Graphics.UI.Gtk.TreeList.TreeModel says:     *  This module and all other modules in TreeList are deprecated. Please use the modules in ModelView.
02:41:58 <Eduard_Munteanu> Cale, oh, I use the ModelView ones, at least that's my import.
02:42:23 <Cale> er, oh
02:42:24 <Cale> hmm
02:42:39 <Cale> how'd I get over to there, I wonder :)
02:43:17 <amigoo> ok, I am currently installing ghc
02:43:26 <amigoo> though, the website recommends haskell
02:43:38 <amigoo> but the tutorial says ghc
02:43:40 <kamatsu> amigoo: ghc is haskell
02:43:42 <ivanm> amigoo: you mean the haskell platform?
02:43:50 <amigoo> yea
02:43:58 <ivanm> amigoo: the haskell platform is ghc + a bunch of standard libraries + cabal-install to let you install other libraries
02:44:00 <merehap> ghc is the program that makes haskell files into running programs
02:44:18 <ivanm> if you're using linux, a lot of the major distros have haskell-platform available in their package managers
02:44:51 <kamatsu> if you're using OSX or Windows, haskell platform installers can be retrieved from the web
02:45:12 <amigoo> i am on windows
02:45:21 <amigoo> so haskell platform would be better for me?
02:45:25 <kamatsu> yes
02:45:51 <Phyx-> where's dons, i'm wondering when the gtk2hs installer is gonna get updated
02:45:52 <Phyx-> lol
02:46:08 <amigoo> surprisingly, the haskell platform is smaller in size than the ghc
02:46:18 <kamatsu> amigoo: really?
02:46:21 <kamatsu> =/
02:46:34 <amigoo> yes, 63 vs 54
02:46:37 <ivanm> kamatsu: ghc would come with extralibs on its own probably
02:46:38 <amigoo> mb that is
02:46:48 <kamatsu> ah, right
02:46:57 <ivanm> amigoo: you sure you're getting the correct package for windows and not the source tarballs...
02:46:59 <kamatsu> perhaps haskell platform has better compression
02:47:03 <ivanm> Phyx-: dons has nothing to do with gtk2hs...
02:47:08 <ivanm> (and he's on holidays atm)
02:47:20 <kamatsu> wasn't that chak?
02:47:24 <kamatsu> (gtk2hs)?
02:47:26 <ivanm> nope
02:47:28 <ivanm> dcoutts used to
02:47:34 <ivanm> but he's too busy with cabal, etc. nowadays
02:47:44 <kamatsu> so who maintains gtk2hs?
02:47:51 <ivanm> actually, chak might have started gtk2hs...
02:47:52 <amigoo> I think I am downloading the right thing, http://hackage.haskell.org/platform/
02:47:57 <ivanm> that said, dcoutts  has provided a patch to let gtk2hs build on 6.12...
02:48:03 <ivanm> it just hasn't been applied yet :s
02:48:13 <amigoo> I am also reading through http://learnyouahaskell.com/introduction#so-whats-haskell
02:48:18 <Phyx-> ivanm: oh, i keep getting dons and dcoutts mixed up
02:48:24 <kamatsu> amigoo: right, sounds good
02:48:38 <ivanm> Phyx-: heh
02:48:47 <ivanm> but yeah, dcoutts must be on holidays as well or something...
02:48:51 <ivanm> preflex: seen dcoutts
02:48:51 <preflex>  dcoutts was last seen on #haskell 11 days, 20 hours, 50 minutes and 20 seconds ago, saying: Raevel: your main modules do not need to be called Main.hs
02:49:23 <pozic> > :t sin
02:49:23 <lambdabot>   <no location info>: parse error on input `:'
02:49:35 <shambler_> :t sin
02:49:36 <lambdabot> forall a. (Floating a) => a -> a
02:49:49 <shambler_> @type sin
02:49:51 <lambdabot> forall a. (Floating a) => a -> a
02:50:00 <pozic> > sin 3::CReal
02:50:01 <lambdabot>   0.1411200080598672221007448028081102798469
02:50:09 <pozic> > sin 3
02:50:10 <lambdabot>   0.1411200080598672
02:51:25 <pozic> Is there any geometry code (like arrangements) in Haskell?
02:53:02 <kamatsu> so, I have a fun little problem, and it seems like it should be easy, but it's suprisingly not
02:53:21 * hackagebot upload: type-level 0.2.4 - Type-level programming library (HoseinAttarzadeh)
02:53:25 <kamatsu> I have a body of text, perhaps including newlines, and I have a table mapping characters to their width. I want to write a word wrapping algorithm
02:53:47 <kamatsu> words seems to eliminate newlines, which is annoying..
02:54:30 <kamatsu> if anyone feels like tackling it, let me know, otherwise i'll start properly nutting it out in 5.
02:55:11 <zygoloid> kamatsu: i'd suggest starting with map words . lines
02:55:45 <jaspervd1> kamatsu: hmm, I have written something similar before in python
02:56:41 <jaspervd1> kamatsu: iirc it would be some fold algorithm that starts from the top and works it's way down, gradually concatenating a result
02:57:04 <kamatsu> zygoloid: right, treat each paragraph separately
02:57:07 <kamatsu> jaspervd1: i know you did =P
02:57:13 <ramses_> how can I cast a string to an integer and properly catch the case where the string does not represent an integer?
02:57:25 <pozic> kamatsu: do you just want someone to write it for you? It seems completely trivial what you are doing.
02:57:28 <kamatsu> ramses_: "cast"?
02:57:30 <ramses_> read x :: Integer crashes the program if its not parseable
02:57:40 <pozic> kamatsu: if you don't know Haskell, read some on the subject first.
02:57:43 <kamatsu> pozic: right, i can write it, i was just having a mind blank
02:57:50 <kamatsu> pozic: dude, i know haskell, i've submitted to hackage
02:58:15 <pozic> kamatsu: you can submit all you want to hackage, that doesn't mean anything by itself.
02:58:22 <ramses_> cast looks like what I'm after :)
02:58:24 <kamatsu> pozic: i'm just going to stop talking to you now
02:58:33 <kamatsu> ramses_: oh, but I think you want "read"
02:58:33 <pozic> kamatsu: you can do that.
02:58:37 <merehap> pozic: um, ok?
02:59:08 <ramses_> kamatsu: read does not handle errors properly.. or I do not know how to catch "exceptions" in haskell
02:59:11 <zygoloid> ramses_: you want 'reads', probably.
02:59:28 <pozic> merehap: yes?
02:59:43 <zygoloid> > map reads ["foo", "123foo", "123"] :: [[(Int, String)]]
02:59:44 <lambdabot>   [[],[(123,"foo")],[(123,"")]]
03:00:04 <merehap> pozic: #haskell isn't above random personal attacks?/
03:00:07 <kamatsu> ramses_: use 'reads' if you need to handle the fail case
03:00:17 <kamatsu> yeah, i was quite confused by pozic's outburst =/
03:00:18 <pozic> merehap: you should stop the group think.
03:00:53 <pozic> merehap: and there is nothing personal about it; I don't even know kamatsu.
03:00:54 <kamatsu> ramses_: ah, beaten to the punch
03:01:12 <merehap> pozic: yup, this conversation isn't worth continuing...
03:01:17 <kamatsu> yeah
03:01:20 <ramses_> kamatsu: reads will do it :)
03:01:23 <ramses_> thanks
03:02:41 <kamatsu> ah, i'm exciting, i'm doing another course with chak next semester, i get to learn about proof assistants
03:02:45 <kamatsu> *excited
03:08:56 <zygoloid> kamatsu: it seems pretty difficult to come up with a formulation more elegant than the direct recursive one
03:10:55 <kamatsu> kamatsu: yeah, i've almost got it, i'll paste it in a minute
03:11:25 <amigoo> I opened the terminal, but it can't calculate my arithmetics, it says "not in scope '+'"
03:13:11 <merehap> > 3 + 2
03:13:12 <lambdabot>   5
03:13:15 <kamatsu> zygoloid: my technique is to calculate the width of each word, produce a list of possibilities with inits, and then select the one that fits inside
03:13:17 <merehap> this doesn't work?
03:13:26 <Eduard_Munteanu> Any idea how I can access fields in a data by field number?
03:13:44 <Eduard_Munteanu> Say data Test = Test { x :: Int, y :: Int }
03:13:56 <kamatsu> zygoloid: then special case when you have to break up a word
03:13:56 <pozic> Eduard_Munteanu: you implement it in the compiler.
03:14:00 <merehap> amigoo: type ghci first, that will open the interpreter
03:14:13 <pozic> Eduard_Munteanu: using some of the extensions you might also be able to do it.
03:14:20 <Eduard_Munteanu> pozic, oh, so it's not really possible.
03:14:23 <pozic> Eduard_Munteanu: it has however nothing to do with Haskell 98 at that point.
03:14:40 <kamatsu> Eduard_Munteanu: why do you want to do this?
03:14:47 <pozic> Eduard_Munteanu: Probably you can do it with Data or Typable.
03:15:18 <pozic> Eduard_Munteanu: but it falls probably in the "it's a bad idea"-category.
03:15:23 <Eduard_Munteanu> kamatsu, http://pastebin.org/74188
03:15:36 <Eduard_Munteanu> I want to set up columns easily, without copy & paste.
03:16:11 <merehap> amigoo: any luck?
03:16:13 <kamatsu> you could make a list of functions
03:16:14 <Eduard_Munteanu> So I thought of zipping colnames with [1..] and accessing the data structure somehow.
03:16:46 <kamatsu> yeah, sounds okay
03:16:59 <zygoloid> Eduard_Munteanu: i guess, either generate the type and the accessors with some TH, or use Data, or change your data structure to make what you want to do with it easy :)
03:17:02 <Eduard_Munteanu> kamatsu, yes, but the data structure contains fields, how do I access fields by index.
03:17:11 <kamatsu> oh
03:17:23 <kamatsu> so, if you have some function x :: something -> Int
03:17:25 <kamatsu> i.e your field
03:17:36 <kamatsu> then you can have a list of [(Int, something -> Int)]
03:17:52 <kamatsu> so then just use lookup from Data.List to give you that function
03:17:58 <kamatsu> which you can then just call as normal
03:18:01 <kamatsu> but that will be O(n)
03:18:09 <Eduard_Munteanu> Hm, yeah.
03:18:27 <kamatsu> you can use a Data.Map instead
03:18:40 <Eduard_Munteanu> Perhaps I can convert a data structure containing fields to a list.
03:19:16 <kamatsu> wait, why do you need a list at all?
03:19:30 <kamatsu> just use whatever data structure it is
03:19:32 <Eduard_Munteanu> kamatsu, so I can do (!! n) list
03:19:49 <kamatsu> or just use the lookup from whatever other data structure it is, and avoid O(n) lookup
03:19:52 <Eduard_Munteanu> kamatsu, the idea is to call the function from main to set up columns in the list.
03:19:57 <kamatsu> ah
03:20:04 <Eduard_Munteanu> And only supplying column names.
03:20:11 <Eduard_Munteanu> kamatsu, that's why I do the mapM
03:20:17 <kamatsu> well, assuming you don't have a hundred columns
03:20:21 <kamatsu> well, more
03:20:23 <kamatsu> a list is fine
03:20:25 <kamatsu> so just use a list
03:20:36 <Eduard_Munteanu> kamatsu, instead of a data type? Hm, sounds good.
03:20:50 <Eduard_Munteanu> [String] could do
03:20:55 <kamatsu> er, probably
03:21:03 <kamatsu> [object -> Int] is better, right?
03:21:10 <kamatsu> if i understand you correctly
03:21:13 <kamatsu> which i probably don't
03:21:29 <Eduard_Munteanu> kamatsu, no, I just wanted to initialize the listView properly
03:21:42 <Eduard_Munteanu> and easily.
03:21:53 <kamatsu> okay
03:22:11 <kamatsu> wait, i thought you were trying to access a record field accessor by some number?
03:22:41 <kamatsu> chances are if you're trying to do that to populate a listView, that's over-engineering it
03:23:04 <Eduard_Munteanu> data Producer = Producer { name :: String, contact :: String }
03:23:28 <Eduard_Munteanu> kamatsu, I want to add columns to the treeView (used as a plain list)
03:23:58 <kamatsu> okay, so, my technique would be to have a list of columns\
03:24:04 <Eduard_Munteanu> Yes.
03:24:23 <kamatsu> and then mapM
03:24:27 <kamatsu> wait, that's what you did
03:24:33 <Eduard_Munteanu> kamatsu, I do it like this: listInit listProd prodStore [ "Name", "Contact" ]
03:24:40 <kamatsu> seems okay
03:24:48 <kamatsu> and you wanted to make that more brief somehow?
03:24:53 <Eduard_Munteanu> kamatsu, no.
03:24:56 <kamatsu> oh
03:25:08 <Eduard_Munteanu> kamatsu, cellLayoutSetAttributes col renderer store $ \row -> [ cellText := name row ]
03:25:18 <kamatsu> ah, where "row" is the field accessor
03:25:25 <Eduard_Munteanu> kamatsu, how do I mapM so that it iterates over name and contact? :)
03:25:31 <kamatsu> similarly
03:25:47 <zygoloid> > let x !!~ n = fromDynamic $ gmapQi n toDyn x in ("Foo", "Bar", "Baz") !!~ 1 :: Maybe String
03:25:48 <lambdabot>   Just "Bar"
03:25:54 <zygoloid> Eduard_Munteanu: ^^ something like that should work
03:26:07 <kamatsu> just make a list of fields [name,contact] :: [Producer -> String]
03:26:09 <Crazyass> Yo, I'm looking for the windows distribution of GHC, not the installable package
03:26:12 <Eduard_Munteanu> zygoloid, wow, I don't really get that :)
03:26:16 <Crazyass> SOmeone mind linking me to the distribution pages?
03:26:19 <kamatsu> and MapM over it
03:26:30 <kamatsu> zygoloid: perhaps not wise
03:26:30 <Eduard_Munteanu> kamatsu, oh, that works? Nice.
03:26:46 <kamatsu> Eduard_Munteanu: yup, but the functions have to have the same type signature
03:26:55 <kamatsu> otherwise you'll have to make a boxing type
03:27:06 <zygoloid> kamatsu: perhaps not. there certainly are quite a lot of provisos
03:27:13 <Eduard_Munteanu> kamatsu, oh, you mean the list has to have homogenous types.
03:27:19 <kamatsu> Eduard_Munteanu: yes
03:27:40 <zygoloid> kamatsu: i mostly wanted to see if Data made it possible :)
03:27:43 <kamatsu> heterogeneous lists can be made using existential quantification
03:27:44 <Eduard_Munteanu> kamatsu, I think I'll just use strings for everything and convert back and forth from Ints if I need to.
03:27:57 <kamatsu> Eduard_Munteanu: seems a bit gross
03:28:08 <amigoo> the terminal does not recognize functions in my library, such as doubleMe, doubleUS.  I can't call them for som reason
03:28:17 <Eduard_Munteanu> kamatsu, it's for school, I chose Haskell to get around fast and without writing too much code. :)
03:28:33 <merehap> amigoo: have you loaded your file? :l myfile.hs
03:28:34 <kamatsu> Eduard_Munteanu: ah, cool. Good luck with it ^^
03:28:35 <Eduard_Munteanu> Basically some SQLite + GUI crap :)
03:28:57 <merehap> amigoo: while you are in the ghci interpreter
03:29:03 <Eduard_Munteanu> kamatsu, I got tired while working on the other project with wxWidgets and C++...
03:29:03 <kamatsu> cool, that'll get you right into monadic code off the bat
03:29:25 <kamatsu> Eduard_Munteanu: that combination is not pretty
03:29:39 <Eduard_Munteanu> kamatsu, I know... way too much crap.
03:30:28 <amigoo> merehap: I think I am in the interpreter.  I can do basic arithmetics.
03:30:46 <merehap> amigoo: did ":l" work?
03:30:48 <amigoo> *arithmatic
03:30:58 <merehap> amigoo: (you are in the interpreter)
03:31:13 <Cale> amigoo: try typing something like   :l myfile.hs   where "myfile.hs" is the name of the file that you're putting definitions into.
03:31:21 <Eduard_Munteanu> kamatsu, so far it's pretty swift, I only have to get over some hops.
03:31:37 <Eduard_Munteanu> with Gtk2Hs I mean.
03:31:50 <amigoo> I am doing :l baby
03:32:06 <merehap> amigoo: is there an error message?
03:32:12 <amigoo> can't find file
03:32:38 <kamatsu> Eduard_Munteanu: yeah, i'm not a fan of gui toolkits in general, i tend to prefer writing web apps
03:32:42 <Cale> amigoo: Is it in the same directory that you're running ghci from?
03:32:43 <amigoo> based on the tutorial, it's supposed to already be in the library
03:32:57 <DeadPanda> is it possible to define a class instance in terms of another class?  New to Haskell, and not quite sure how to describe it, but http://haskell.pastebin.com/dc36e9a8 shows roughly what I'm trying to achieve (ignore that the Channel/Identity types are essentially identical, that'll change soon)
03:33:18 <kamatsu> DeadPanda: without looking at your paste, yes
03:33:36 <kamatsu> but you might mean something different to what I think
03:33:40 <amigoo> cale: how do I know which directory I am in?
03:33:52 <merehap> type dir in the terminal
03:33:58 <yakov> hey
03:34:03 <merehap> you will need to quit ghci first
03:34:03 <DeadPanda> kamatsu, can you point me to the docs?  I've not had much luck searching for this :s "instance (Identifiable a) => Eq a where" doesn't do quite what I imagine it does
03:34:08 <Cale> amigoo: what OS are you running?
03:34:09 <Crazyass> Sorry to pester, but I can't find the windows GHC download. I'm positive I saw one before, (not the installer, extractable binaries)
03:34:20 <merehap> amigoo: type ":q" and then "dir"
03:34:25 <amigoo> Cale: windows
03:34:34 <Cale> http://haskell.org/ghc/dist/6.10.4/ghc-6.10.4-i386-windows.exe
03:34:40 <kamatsu> DeadPanda: not sure where the docs are, but let me just write a quick test module to make sure i got the syntax right, and i'll correct your paste
03:34:44 <Crazyass> Cale, that's the installer
03:34:49 <DeadPanda> kamatsu, thanks a lot
03:35:41 <Cale> amigoo: hmm, then it should show up in the prompt when you open a console window... or if you're running it from a shortcut... well, it's been a long long time since I've used a windows machine, but I think there's an option in the shortcut properties box
03:36:15 <zygoloid> DeadPanda: no, you can't do quite what you want. 'instance (Identifiable a) => Eq a' doesn't mean 'if a is in class Identifiable then it's in class Eq', it means 'all types 'a' are in class Eq, but if you try to use the Eq instance there must be an Identifiable instance'
03:36:23 <yakov> who knows if its safe to use gtk2hs with 6.12?
03:37:24 <Cale> dcoutts probably knows :)
03:37:34 <Crazyass> No idea then CAle? D:
03:37:40 <kamatsu> oh, right
03:37:59 <Cale> Crazyass: Well, what, you want the source?
03:38:01 <amigoo> Cale: thanks.  I only downloaded the platform, I thought the built in function files would come with it
03:38:17 <DeadPanda> zygoloid, drats, thanks for clearing it up anyway
03:38:21 <Crazyass> Cale, no there waas a windows binary package, but extractable
03:38:26 <Cale> huh...
03:38:33 <Crazyass> Excuse my horrible spelling, awful keybopard
03:38:33 <Cale> Crazyass: Maybe for some prior version.
03:38:49 <merehap> amigoo: I don't think those functions that you mentioned are built in
03:38:50 <Crazyass> Calem, downloaded 6.10 before, i'm 100% sure its' available
03:38:54 <Crazyass> I just can't track down where I found it
03:42:51 <Crazyass> Anyone? :o
03:45:05 <ivanm> Crazyass: no, AFAIK you can't get the installer on its own
03:45:21 <ivanm> since it needs stuff that isn't in the binary (guessing here; not sure how the windows binary is built)
03:45:35 <ivanm> but in general, you'll also need cpp, etc. which isn't part of ghc itself
03:45:40 <ivanm> and I think it needs perl to run
03:46:00 <Crazyass> ivanm, I'm absolutely certain it's available, as it's on my memory stick, the only reason I need it now is I've left my memory stick elsewhere
03:46:11 <ivanm> Crazyass: maybe you installed it to your memory stick?
03:46:14 <Crazyass> Nope
03:46:28 <Crazyass> It was extracted, I would check my #haskell logs as I've asked thsi same question before
03:46:36 <Crazyass> But I'm not at home, so... I can't D:
03:47:22 <ivanm> Crazyass: there's a link to logs in the topic
03:47:39 <ivanm> or else you can bring the almight powers of google to bear on your problem
03:47:40 <ivanm> ;-)
03:47:58 <Crazyass> ivanm: I did try rofl, but I've had several nicks, I'm not sure under which I asked
03:48:00 <ivanm> Crazyass: try http://ftp.uk.xemacs.org/sites/www.haskell.org/ghc/download_ghc_641.html
03:48:00 <pozic> Is there a package which does the same as data-clist, but has a O(1) length? I will implement it myself otherwise.
03:48:13 <Crazyass> Wheras the logs I have at home will have my name listed in a different format
03:48:15 <ivanm> http://www.haskell.org/ghc/download_ghc_6_10_2.html#binaries <-- 6.10.2 standalone
03:48:22 <ivanm> pozic: what is data-clist
03:48:27 <ivanm> Crazyass: google ftw! ;-)
03:48:43 <ivanm> oh, no, it's an installer...
03:48:50 <Crazyass> Rofl
03:48:51 <pozic> ivanm: a circular list based on a zipper.
03:48:53 <Crazyass> Yeahm, I looked there
03:49:01 <pozic> ivanm: trivial, but handy.
03:49:03 <ivanm> pozic: hmmmm...
03:49:35 <pozic> ivanm: I will have to build a mountain of code and a sized version of that will be a tiny piece of that.
03:51:04 <Crazyass> ivanm: if you're interested, think I found it: http://www.haskell.org/ghc/dist/6.12.1/
03:51:12 <Crazyass> ming32 dist (I thinkm anyway, downloading now)
03:51:25 <Crazyass> My damn m key is broken
03:51:46 <pozic> ivanm: ListZipper is basically the same, but not circular. I think there are lots of copies on Hackage.
03:51:58 <pozic> Crazyass: you want to download the Haskell Platform.
03:52:22 <pozic> Crazyass: (at least I think you want that)
03:52:27 <ivanm> pozic: no, he wants a single ghc binary
03:52:32 <ivanm> a "portable ghc"
03:52:39 <ivanm> (which I'm pretty sure doesn't exist)
03:52:46 <ivanm> Crazyass: sure you're not thinking of hugs or something?
03:52:52 <pozic> ivanm: oh, ok.
03:52:53 <Crazyass> A million %
03:53:14 <pozic> Crazyass: if you want a portable GHC, you just compile it yourself statically.
03:53:54 <Crazyass> pozic: Yes, but I'm so certain a package precompiled exists, let me try this one I'm downloading now
03:54:08 <pozic> Crazyass: but I am not sure how easy that is, though.
03:54:13 <ivanm> pozic: yes, but what about ghc-pkg, etc.?
03:54:48 <pozic> ivanm: that's a matter of modifying the paths, yes.
03:55:15 <pozic> I don't see why one would want to have a portable GHC, though.
03:55:29 <pozic> Buy a laptop ;)
03:55:37 <Crazyass> Rofl, yeah I do need one
03:57:53 * ksf considers writing a tutorial "imperative programming in Haskell"
03:58:41 <ksf> the Idea is to start off with Refs and concentrate on haskell-style abstraction instead of code flow, and _then_ move on to do full FP
03:59:37 <ksf> oh, ghc binaries are "portable", by default.
03:59:58 <Gracenotes> Section 2.2: Using Foreign.C
04:00:03 <ksf> ghc is a small shell script, which calls the real ghc in /foo/lib/ghc with the proper path set.
04:00:42 <ksf> er yes.
04:00:59 <Gracenotes> Section 2.3: Using Ptr vs. ForeignPtr
04:01:09 <ksf> though Ptr-based array messing isn't what I had in mind as a focus.
04:01:26 <Jafet> Exercise: implement Data.Array!
04:01:37 <Gracenotes> >_> yeah. Hm, do you think it would help to have the (=$) operator?
04:02:08 <ksf> ...in fact, I once ported code from a binary tree to binary lookup of a UArray, and it was the exact same speed.
04:02:11 <Gracenotes> to make things less verbose. in your tutorial.
04:02:35 <ksf> I think <- works just fine
04:02:54 <Crazyass> Yeah
04:03:00 <Crazyass> ming32 was exactly what I needed
04:03:09 <Crazyass> Sorry for dragging on, thanks for the help
04:03:17 <Gracenotes> ksf: I mean, modifying
04:03:35 <ksf> ref `modifyIORef` val
04:03:44 <Gracenotes> eh. it is not so pretty.
04:03:48 <ksf> yep, shortining that makes sense.
04:03:50 <Gracenotes> (and would be more writeIORef)
04:04:00 <ksf> that, too.
04:04:35 <ksf> ...and I'm kinda leaning towards using State
04:04:41 <Gracenotes> sounds like an interesting idea
04:05:12 <ksf> not so much "isolate imperative from pure code", but "isolate your different pieces of imperative code"
04:05:32 <Jafet> I wouldn't call that imperative programming
04:05:39 <Jafet> Array programming, maybe
04:05:47 <Jafet> Or mutable state programming
04:06:04 <ksf> I don't care.
04:06:13 <Gracenotes> it's pretty imperative, executing a procedure of statements which mutate values
04:06:20 <ksf> the idea is to make love haskell for its abstraction capabilities, and a truly different kind of OO
04:06:22 <pozic> ksf: if you want to convince people, you should write something non-trivial in Haskell and present that.
04:06:24 * Jafet wraps ksf in barbed wire
04:06:32 <Jafet> I still don't understand the title of that paper.
04:06:48 <ksf> pozic, there's enough of that.
04:07:13 <ksf> and everytime I try to entice you guys to write a browser, the volume of the cheers is kinda low.
04:07:28 <ivanm> is there a polite way of saying "I also chose Haskell to piss off my supervisor"? :p
04:07:37 <ivanm> (for a talk I'm giving)
04:07:41 <Jafet> Career advancement
04:07:46 <Ke> !
04:08:01 <pozic> ksf: Adrian Hey is the only one who immediately comes to mind who has written non-trivial Haskell code and published it.
04:08:35 <ksf> ivanm, "...to drive forth the positive involvement of the company with advanced technology"
04:08:44 <ivanm> ksf: this is academia! ;-)
04:08:45 <Ke> I thought using opengl from haskell in real time program was non-trivial
04:08:49 <pozic> ksf: and even that code could be written in a functional way which is not possible for everything.
04:08:49 <ivanm> supervisor for honours
04:09:06 <ksf> Ke, it's bleeding trivial.
04:09:08 <Jafet> Haskell real time program is non-trivial
04:09:10 <pozic> ivanm: what is this 'honours' you speak of?
04:09:25 <ksf> 3d programming, by itself, quickly becomes non-trivila, though.
04:09:34 <Ke> !
04:09:34 <pozic> ivanm: I thought it meant that you had to graduate with at least 8 out of 10 points.
04:09:49 <pozic> ivanm: but you use it in a different way.
04:10:06 <ivanm> pozic: http://en.wikipedia.org/wiki/Bachelor%27s_degree#Honours_Degrees_and_academic_distinctions
04:10:21 <ksf> that is, when doing games one isn't coding c++ ideomatically, too: stuff has to be optimized.
04:10:25 <kamatsu_> in my university, that's a requirement to do honours, but honours itself refers to an extra year of study, afaik
04:10:45 <ivanm> kamatsu_: exactly
04:10:49 <harlekin> How can I create static binaries with ghc?
04:10:57 <ivanm> harlekin: you already do
04:11:01 <ivanm> except for some C libraries...
04:11:10 <harlekin> ivanm, I want the C libraries to be statically linked as well.
04:11:11 <ksf> one can't for example rely much on laziness, as there's fine-grained control over caching behaviour needed and stuff.
04:11:13 <ivanm> (IIRC, you _can't_ statically link to glibc ...)
04:11:15 <pozic> ivanm: so it doesn't signify anything other than the number of years you attended.
04:11:33 <kamatsu_> pozic: and that you managed to hold a decent average before you began your honours year
04:11:34 <ivanm> pozic: it's about the level of a masters in other countries
04:11:53 <ksf> harlekin, if your system suports it, you can. just pass appropriate linker flags to ghc to pass on to ld.
04:11:58 <ivanm> pozic: it's an extra year where you do independent research (typically at least half your "course" load is towards your thesis)
04:12:25 <Jafet> ksf, you can still write games mainly in C++, with minor diversions into the shader
04:12:49 <ksf> see, in haskell you can even write the shader code in haskell.
04:12:55 <Jafet> Yay.
04:13:20 <ksf> http://www.haskell.org/haskellwiki/GPipe
04:13:20 <Jafet> Haskell should let you do interesting things easily though, like lazy terrain generation with (insert fractal buzzword here)
04:13:21 <pozic> ivanm: so your total is than 4 years of study?
04:13:49 <ivanm> pozic: well, I did two degrees + an honours, so 5
04:13:51 <sinelaw> preflex, seen PeakerWork
04:13:51 <preflex>  PeakerWork was last seen on #haskell 18 hours, 8 minutes and 33 seconds ago, saying: aavogt: Well, when you apply a function - it finds the result type on its own (that of the function) :)  And when you use polymorphic functions (e.g: Operators in C, or templated functions in C++), it has to actually infer the expression's result type, and it does
04:14:10 <ksf> Jafet, but it's not half as much fun without geometry shaders
04:14:17 <ivanm> pozic: also, in some degrees (notably engineering) your 4th (and final) year counts as an honours if your grade is good enough
04:14:25 <ivanm> so you don't do an explicit extra year
04:14:28 <ksf> iirc conal is hacking away on a cuda dsl
04:14:58 <ivanm> sounds familiar
04:15:12 * Jafet has a flashing vision of haskell on larrabee
04:15:27 * ksf has a flashing vision of himself in the shower
04:16:56 <sinelaw> ivanm, got an idea for my graph editor
04:17:29 <ivanm> oh?
04:18:13 <sinelaw> ivanm, i want to supply an fgl-compatible interface so that when you work on a graph, it builds a structure (monad?) that can be passed to an "animate" function which animates the various operations you did
04:18:36 <sinelaw> say, you add a few nodes, connect them , run some algorithm, etc..
04:18:40 <Botje> fancy.
04:19:00 <sinelaw> question is how that interface should look like
04:20:35 <Jafet> What would it be used for
04:21:03 <sinelaw> Jafet, fun
04:21:20 <Axman6> kamatsu_: i'm not in sydney, i'm in Canberra
04:21:22 <sinelaw> Jafet, but for example, documenting and demonstrating algorithms
04:21:27 <Botje> to produce those fancy animated git histories we've seen
04:21:38 <ivanm> sinelaw: ummmm..... OK...
04:21:39 <sinelaw> Botje, i haven't! where?
04:21:41 <ivanm> Axman6: yeah, I told him
04:21:53 <sinelaw> ivanm, i like your enthusiasm!
04:21:59 <Jafet> So edges and vertices just appear and disappear, or what
04:22:03 <Axman6> cheers :)
04:22:07 <Botje> http://code.google.com/p/gource/
04:22:23 <ivanm> sinelaw: I'm just not sure how you'd produce such a monad
04:22:45 <sinelaw> ivanm, neither do it. it's just an idea of what i want to supply
04:22:50 <ivanm> *nod*
04:22:54 <kamatsu_> Axman6: yeah, ivanm said
04:23:15 <sinelaw> Jafet, http://www.youtube.com/watch?v=RT87JfTYIvo
04:23:27 <Jafet> Argh, youtube
04:23:55 <CCCP> hey there. i'm just starting to learn haskell and experimenting a bit. now i have 2 variants of a function to get an arbitrary fibonacci number, one is fast, oen is a lot slower, although i dont see why they would be evaluated differently: http://codepad.org/hPUKpqqv
04:24:05 <sinelaw> Jafet, oh :( http://enough.googlecode.com/svn/trunk/media/graphui_sneak_2.mp4
04:24:09 <CCCP> can anyone explain that behaviour to me? (running the code in hugs, if that makes any difference)
04:24:13 <Jafet> thx
04:24:28 <CCCP> i just tried to merge 2 functions into one
04:25:50 <Botje> CCCP: woah. that's confusing.
04:26:59 <Jafet> CCCP, consider the recursion that results from your duplicate call to (fibs 0)
04:27:34 <Jafet> sinelaw, crude but pretteh
04:27:45 <amigoo> ok, I typed product[2...10000000000], now it won't stop.
04:27:48 <sinelaw> Jafet, that's the old pythonic prototype from several years back
04:27:54 <amigoo> my computer is pretty slow now
04:28:12 <Phyx-> amigoo: Ctrl+C
04:28:22 <sinelaw> C   t     r      l         +          C
04:28:26 <amigoo> thankslol
04:28:32 <Jafet> killall ghc
04:28:34 <CCCP> Jafet: doesnt the same happen with the first version, having a duplicate call to fibs?
04:29:00 <Jafet> CCCP, fibo is a list, so there is no function call. Both places refer to the same list.
04:29:01 <Berengal> CCCP: In the first version you're using a value `fibo' to store the list in. In the second version you're not, you're using a function instead. When you call a function it'll have to evaluate the result each time, even if you've called it with the same arguments before, but the value of `fibo' never changes, and so won't have to be recalculated each time you look at it
04:29:26 <Jafet> CCCP, you may want to experiment with using a let binding to bind the list of fibs in the second.
04:29:52 <CCCP> aah okay i thought fibo would be a function "with no arguments"
04:30:04 <Berengal> CCCP: Nope. No such thing :)
04:30:05 <CCCP> didnt realize there was a difference
04:30:14 <Jafet> There are values, and functions of one argument.
04:30:44 <zygoloid> functions of one argument are values too :)
04:30:52 <CCCP> alright, thanks! gotta read up on let bindings then :>
04:31:22 <quicksilver> if you come from other languages it may be a useful intuition to think of non-function types as functions of no arguments.
04:31:31 <quicksilver> technically it speaking it doesn't actually make sense
04:31:32 <Phyx-> Berengal: though it is only evaluated once no? CSE should have taken care of that
04:31:39 <quicksilver> but it remains a useful intuition sometimes.
04:32:04 <Jafet> quicksilver, except hugs didn't do CSE
04:32:21 <Jafet> I guess compiling with optimization will do that.
04:32:24 <zygoloid> laziness is harder to understand if you think of values as nullary functions, imo
04:32:28 <Phyx-> Jafet: you mean me?
04:32:35 <Berengal> Phyx-: GHC is very careful about CSE (and presumably hugs too). It's very easy to give your memory indigestion by doing that in lazy languages
04:32:47 <Jafet> Mean? I am a nice person
04:32:47 <quicksilver> GHC does very little CSE, indeed
04:33:10 <Phyx-> ah ok, i was wondering
04:33:28 <Phyx-> Jafet: lol, nah, i meant, were you refering to me, since i posted the CSE question
04:33:41 <Jafet> That was to quicksilver
04:33:46 <Phyx-> ok
04:35:31 <ivanm> quicksilver: would you mind looking through my slides for PEPM and making sure I haven't done any stupid haskellian faux-pas?
04:36:37 <sinelaw> PEPM?
04:37:02 <quicksilver> ivanm: sure, although it won't be until later that I have a chance to look
04:37:12 <ivanm> how much later?
04:38:10 <quicksilver> 6 hours or so
04:38:17 <ivanm> that's enough
04:38:31 <ivanm> would you prefer them to be emailed to you or uploaded somewhere for you to download?
04:39:55 <ivanm> (since that way you could check them whilst I sleep :p )
04:42:28 <quicksilver> ivanm: emailed.
04:42:37 <ivanm> good-o
04:57:44 <Baughn> elly: It is not clear to me that there is any significant difference between running in a simulation and running on raw math
04:57:46 <IceDane> My haskell is rusty =(
04:58:07 <Botje> polish it up, then :)
04:58:18 <IceDane> Do I want to use a scan if I want to take a starting value and build a list applying a function to the previous value every time?
04:58:41 <Baughn> elly: Due to the mind merging argument, it is possible to see the laws of physics as a statistical distribution, of which only a part would involve simulations
04:58:54 <Botje> IceDane: that's unfoldr / iterate
04:59:03 <IceDane> Botje: I see
04:59:48 <Baughn> elly: Or, rather, as a superposition. Not the sort of distribution where there /is/ an answer you don't know; the sort where there are multiple actual answers which you can potentially decohere.
05:00:21 <sinelaw> can someone explain in one sentence what the monomorphism restriction is?
05:00:40 <Baughn> sinelaw: A convenience for compiler implementors, yet an annoyance for programmers
05:00:41 <sinelaw> i'm getting a weird error about it
05:01:11 <Axman6> sinelaw: it usually happens when you've got something like foo = bar . baz, to fix it, use foo x = bar . baz $ x
05:01:19 <Baughn> sinelaw: An assumption that non-toplevel bindings can always be narrowed down to a concrete (with no typeclass contexts) type
05:01:30 <Axman6> it goes towards my point that pointfree code is evil :)
05:01:49 <Baughn> You can usually fix that with an explicit type signature. ;)
05:02:04 <sinelaw> should i turn on NoMonomorphismRestriction?
05:02:10 <Baughn> I don't see why not
05:02:14 <quicksilver> ivanm: I haven't received anything yet?
05:02:20 <sinelaw> ok for now it's what i'll do :)
05:02:35 <Baughn> sinelaw: But you can also most likely fix it by adding an explicit signature to the binding
05:02:37 <quicksilver> Baughn: I don't think it's convenient for compiler implementors at all.
05:02:38 <ivanm> quicksilver: I haven't finished it yet!
05:02:43 <quicksilver> ivanm: fair enough :)
05:02:47 <Baughn> quicksilver: Wasn't that the justification for having it?
05:02:52 <quicksilver> Baughn: it is for programmer's sake that it is there
05:02:56 <ivanm> since you said you weren't going to read it for another few hours at least, I figured I'd get all my notes and everything in there as well
05:02:57 <koeien37> unexpected slowdons
05:03:02 <quicksilver> it stops you accidentally violating some sharing assumptions
05:03:13 <Baughn> Well, I suppose
05:03:14 <quicksilver> ivanm: ok
05:03:16 * ivanm is quickly trying to work out how cabal-the-library specifies whether an executable is buildable or not)
05:03:37 <Baughn> sinelaw: let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) <-- What is the type of fibs, here?
05:04:01 <Baughn> (Imagine that's in a do block or something)
05:04:24 <sinelaw> the list must be some Num a => [a]
05:04:38 <Baughn> Right.
05:04:55 <sinelaw> so fibs :: Num a => [a]?
05:05:03 <Baughn> sinelaw: That's the most general possible type, yes
05:05:19 <Baughn> sinelaw: Due to the monomorphism restriction, the compiler will actually assume you want [a] for some a that's in Num
05:05:46 <Baughn> sinelaw: This means you'll be unable to use fibs in two contexts that want /different/ types
05:05:52 <sinelaw> ah
05:05:55 <sinelaw> suxorz
05:06:06 <Baughn> sinelaw: As quicksilver pointed out, the reason for this is that it'd break sharing; it'd need two separate lists.
05:06:29 <Baughn> sinelaw: You can force the compiler to do it anyway by using an explicit type signature, or by turning off the restriction.
05:06:29 <sinelaw> Baughn, well, that's life - if you want two types you want two values
05:06:58 <Baughn> Well, half the time what you'd want is 'fromIntegral <$> fibs'
05:07:02 <nainaide> http://hpaste.org/ doesn't work right now, any other site?
05:07:12 <Baughn> So I suppose it's a convenient warning - once you know what to do about it. :P
05:07:58 <sinelaw> yeah
05:10:38 <ivanm> @paste
05:10:39 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:10:41 <ivanm> nainaide: ^^
05:11:04 <sinelaw> Baughn, thanks that was enlightening. need to catch up learning more haskell...
05:13:00 <Raynes> @hpaste
05:13:00 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:18:46 <nainaide> I am confused on socket difference between Perl and Haskell.  I have a perl server, two clients one in  perl one in haskell.  It seems that haskell can not get all feed back from server socket. Any advince? Perl : http://pastebin.com/m10d5b85a  , while Haskell : http://pastebin.com/m2ec7ec7e
05:20:49 <Baughn> nainaide: You realize you're sending \n\r\n as a line terminator in write, right?
05:20:58 <Baughn> What's wrong with plain \n?
05:21:31 <nainaide> Baughn, It seems \n or \r\n doesnt matter
05:22:11 <Baughn> nainaide: The problem is \n\r\n. That implies two lines, the second of which contains a single character \r.
05:22:18 <koeien37> it works for me
05:22:20 <Baughn> nainaide: Or very schizo line ending schemes.
05:23:49 <pozic> Can you write to a certain memory address with a GPU in constant time?
05:23:57 <Baughn> What?
05:24:09 <pozic> I have the impression that GPGPU is not general purpose computing at all.
05:24:21 <Baughn> Well, not to that degree.
05:24:40 <Jafet> What does writing memory addresses in "constant time", whatever that means, have to do with general purpose computing?
05:24:40 <nainaide> Baughn, I got the info form socket in different order from perl client
05:24:44 <Baughn> OpenCL and such are still highly abstracted languages. They kind of have to be.
05:24:47 <Ke> you can't do that on cpu either
05:24:57 <pozic> Jafet: you can fake a memory with a GPGPU.
05:25:05 * Axman6 <3 OpenCL
05:25:05 <pozic> Jafet: it will only be O(n).
05:25:27 <Jafet> What's n?
05:25:30 <pozic> Jafet: so, while theoretically "general purpose". Practically, it is not.
05:25:36 <Ke> so are there any OpenCL tutorials or did you learn from the standard?
05:25:38 <pozic> Jafet: the size of the stream, I suppose.
05:25:55 <pozic> Jafet: so, vertex data, I guess.
05:26:08 <Axman6> Ke: macresearch.org has some, and the apple examples are quite handy
05:26:09 <ksf> is h98 or h10 ghc 6.12's default?
05:26:14 <Axman6> i've blogged about it a bit too
05:26:15 <Jafet> Half a century ago, everything was done on tape.
05:26:15 <pozic> Ke: yes, you can.
05:26:22 <Jafet> That was "general purpose".
05:26:29 <Jafet> So your comments don't make a lot of sense.
05:26:36 <Jafet> There is real memory and there is no memory.
05:26:57 <Baughn> ksf: ghc98
05:26:59 <ksf> oh, and cabal should understand XH10 and expand it to those gazillions of flags for 6.10
05:27:20 <Ke> so anyone making opencl wrappers for ghc
05:27:40 <Axman6> there already is one
05:27:47 <Axman6> well, a hackage library anyway
05:27:49 <ksf> does ghc run on any cl platform, in the first place?
05:28:05 <Axman6> OS X...
05:28:06 <Ke> there is opencl for linux ;oP
05:28:19 <Axman6> you sure?
05:28:24 <Ke> and I bet  for windows too
05:28:26 <Axman6> i haven't heard of any compilers
05:28:30 <Axman6> nor windows
05:28:30 <nainaide> Baughn, http://pastebin.com/m67b942f9
05:28:39 <ksf> considering that it's a bogged down gl, it should be quite easy to support.
05:28:41 <Axman6> OS X is afaik, the only platform with OpenCL so far
05:28:54 <Axman6> ksf: eh?
05:28:55 <Ke> Axman6: nvidia and amd have ones?
05:29:04 <Axman6> they have drivers
05:29:12 <Axman6> but the libraries aren't there i don't think
05:29:15 <ksf> is it a subset or are there some fundamental incompatiblities?
05:29:28 <Axman6> it's a subset of C
05:29:34 <Axman6> with some extra bits
05:29:43 <Baughn> nainaide: I'm telling you, your line endings are messe dup.
05:29:45 <ksf> C?
05:29:50 <Axman6> yes, C
05:30:08 <ksf> wait.
05:30:23 <ksf> you're not talking about the mobile version of gl, are you?
05:30:36 <Axman6> no, OpenCL
05:31:14 <ksf> oh.
05:31:19 <ksf> Ke, have a look at gpipe, too.
05:31:22 <Axman6> http://random.axman6.com/blog/?p=82 and you'll see some OpenCL
05:31:50 <ksf> ...it's a edsl that generates glsl, and is really, really cool.
05:31:54 <ivanm> grrr..... MPTCs aren't supported in haskell-src-exts ...
05:32:03 <ivanm> there goes that great visualisation I wanted :@
05:32:16 <Ke> Axman6:
05:32:19 <Ke> On September 28, 2009, NVIDIA released its own OpenCL drivers and SDK implementation.
05:32:21 * ivanm randomly wonders if this is worth a quick rewrite of graphviz to not use MPTCs...
05:32:22 <Ke> On October 13, 2009, AMD released the fourth beta of the ATI Stream SDK 2.0, which provides a complete OpenCL implementation on both R700/R800 GPUs and SSE3 capable CPUs. The SDK is available for both Linux and Windows. [17]
05:32:34 <Axman6> good to hear :)
05:33:02 <ksf> ...but then, maybe a dph backend would be a better idea.
05:33:30 <Axman6> i think there'splans for a backend for the Accelerate package
05:34:12 <Axman6> there's already a CUDA backend
05:34:33 <Axman6> and a haskell one... which is horribly slow (but understandably so)
05:34:56 <ksf> it's important to have backups, though.
05:35:16 <ksf> it's just like a missing x87, all over again.
05:36:04 <sinelaw> what's MTPC?
05:36:11 <Botje> MPTC?
05:36:21 <koeien37> multi parameter type classes
05:36:21 <Botje> it's type classes with multiple variables
05:36:36 <sinelaw> ah
05:36:51 <Botje> eg MonadState s (m a)
05:36:56 <ivanm> for some reason, haskell-src-exts wants it enabled even when ghc doesn't care...
05:39:43 <nainaide> Baughn, got it , Thanks !!!
05:45:06 <nh2> I just did the Wikipedia fibonnaci fibs example using a list. How would you compute really large numbers like fibs 1000000? Keeping the whole list in memory will exceed your RAM instantly
05:45:44 <Ke> tail recursion probably
05:46:05 <Jafet> The whole list doesn't need to be kept
05:46:07 <Ke> though there is constant time solution also
05:46:15 <koeien37> Ke: not really
05:46:30 <koeien37> there is a closed expression
05:46:30 <Axman6> > let fibs 0 (x,y) = x; fibs n (x,y) = fibs (n-1) (y,x+y) in fibs 10000 (0,1)
05:46:32 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
05:46:35 <Axman6> > let fibs 0 (x,y) = x; fibs n (x,y) = fibs (n-1) (y,x+y) in fibs 100000 (0,1)
05:46:38 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
05:46:44 <Axman6> > let fibs 0 (x,y) = x; fibs n (x,y) = fibs (n-1) (y,x+y) in fibs 1000000 (0,1)
05:46:46 <lambdabot>   * Exception: stack overflow
05:46:50 <koeien37> Ke: it requires a matrix exponentiation
05:46:58 <Axman6> > let fibs 0 (x,y) = x; fibs !n (!x,!y) = fibs (n-1) (y,x+y) in fibs 1000000 (0,1)
05:46:59 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
05:47:02 <Jafet> I don't think  let fibs = 0 : scanl (+) 1 fibs in (fibs!!) actually has to keep the whole list at any point
05:47:03 <Axman6> bah!
05:47:16 <koeien37> Jafet: no, but it does if it's a CAF
05:47:24 <Jafet> Caf?
05:47:28 <RayNbow> Constant Applicative Form
05:47:31 <koeien37> constant applicative form
05:47:33 <Ke> koeien37: I think it could be reduced to exp and such
05:47:41 <Jafet> I'm still unclued
05:47:53 <koeien37> Ke: yes, but it involves irrational numbers and exponentiation of those
05:47:53 <RayNbow> fibs = 0:1:zipWith (+) (tail fibs) fibs  -- if this is e.g. a top level definition
05:47:54 <Ke> koeien37: obviously not constant time with bignum though
05:48:06 <Jafet> Ah. This one isn't
05:48:15 <RayNbow> then the head of the list will always be in memory
05:48:25 <koeien37> Jafet: if it can be garbage collected, because it's a local definition, then it will
05:48:35 <Jafet> Yes, that was what I had in mind.
05:48:39 <koeien37> then that solution is as good as tupling (viz. Axman6's)
05:48:51 <Ke> koeien37: so constant time within machine limits, which may or may not satisfy you
05:49:04 * Axman6 doesn't like using tuples there
05:49:05 <koeien37> Ke: I still don't see how it can be constant time?
05:49:22 <Jafet> Constant number of operations in R
05:49:23 <ivanm> Axman6: I was just thinking before... does anyone actually use 37-tuples (or whatever the maximum is)?
05:49:31 <Jafet> (Three cheers for Blum)
05:49:33 <Axman6> > let fibs 0 x y = x; fibs n x y = fibs (n-1) y (x+y) in fibs 1000000 0 1
05:49:35 <lambdabot>   * Exception: stack overflow
05:49:40 <koeien37> Jafet: ah well, but that is a very unsatisfactory answer
05:49:42 <Axman6> > let fibs 0 x y = x; fibs n x y = fibs (n-1) y (x+y) in fibs 100000 0 1
05:49:45 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
05:49:56 <Axman6> ivanm:  i hope not (it's 62 i think)
05:50:03 <koeien37> > let fibs 0 x y = x; fibs n x y = n `seq` x `seq` y `seq` fibs (n-1) y (x+y) in fibs 1000000 0 1
05:50:04 <ivanm> I've used 3-tuples on occassion; realistically I feel that - for good library design if nothing else - the size of tuples should be capped at about 6 or so
05:50:05 <Cale> There's no constant time implementation of fib. Computing with real numbers isn't free.
05:50:07 <lambdabot>   mueval-core: Time limit exceeded
05:50:21 <ivanm> Cale: right, so we have to use UN-real numbers! \o/
05:50:24 <ivanm> stupid reality...
05:50:31 <koeien37> Cale: right. the answer is already of order O(5^(n/2))
05:50:46 <koeien37> so the answer is of length the logarithm of that
05:50:53 <koeien37> which is O(n)
05:51:23 <Jafet> Unless your machine natively does real number computation
05:51:25 <koeien37> hmm
05:51:26 <Jafet> > let fib n = if n == 0 then 0 else let phi = ((1 + sqrt 5) / 2)::CReal; fie = ((1 - sqrt 5) / 2)::CReal; fn = ((phi^^n - fie^^n) / sqrt 5)::CReal in read $ take (1 + floor ((log fn)/(log 10))) $ show fn in fib 10
05:51:28 <lambdabot>   55
05:51:55 <Ke> real numbers with machine limits =oP
05:52:02 <Ke> but irrelevant
05:52:38 <Ke> even n+m is'n constant time without the limits
05:53:18 <Jafet> > (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
05:53:19 <lambdabot>   No instance for (GHC.Show.Show
05:53:20 <lambdabot>                     (t,
05:53:20 <lambdabot>                     ...
05:53:27 <ivanm> :o
05:53:36 <Ke> I may be wrong still, but it has nothing to do with real numbers
05:56:40 <quicksilver> Ke: theoretically it has something to do with real numbers
05:56:56 <koeien37> I am not following?
05:56:56 <quicksilver> there is a theoretical construct for complexity analysis in which you consider real computations to be 'one step'
05:57:02 <nh2> but why isnt the the part of the list which is not needed anymore garbage-collected while doing fibs !! 1000000? I can imagine no reason for that it should be kept in memory
05:57:12 <quicksilver> and in that framework there is indeed an O(1) algorithm for fibs
05:57:14 <koeien37> nh2: because later in the program you might use it again
05:57:26 <nh2> hi
05:57:30 <quicksilver> however, that framework has no reality
05:57:37 <Ke> yes it has
05:57:38 <koeien37> nh2: but this only holds if you put this at top-level
05:57:41 <quicksilver> (that is, no real model of computation has that property)
05:57:56 <Ke> float is a real number for any continous function
05:58:01 <koeien37> no
05:58:05 <Axman6> nh2: that only happens if it's a top leveldefinition (so that things like foo = bar * baz are only evaluated once)
05:58:10 <Ke> that's why computers aren't utterly useless
05:58:15 <ksf> why oh why don't we have maybeRead :: Read a => String -> Maybe a
05:58:18 <Jafet> "All approximations are rational."
05:58:20 <koeien37> ksf: :(:(:(
05:58:25 <quicksilver> Ke: no it's not; float is a limited (and rational) approximation
05:58:26 <koeien37> ksf: you can fake it with reads
05:58:27 <Jafet> ksf, because it'd make no sense
05:58:34 <Axman6> koeien37: because that's what parsers were invented for :)
05:58:36 <quicksilver> it isn't sufficient to calculate fib beyond a certain point
05:58:37 <Cale> ksf: We do however have reads, which is close
05:58:46 <nh2> koeien37: why that, how could I re-access it if I just do fibs !! ... ?
05:58:52 <Ke> quicksilver: that's the machine limit
05:58:52 <ksf> it makes a hell a lot of sense.
05:59:13 <pozic> Ke: quicksilver is right.
05:59:25 <koeien37> nh2: to calculate fibs !! n, you calculate fibs !! i for all i, 0 <= i <= n
05:59:30 <Ke> but I guess we all know the facts, we have only difference in semantics
05:59:36 <koeien37> nh2: if fibs is a toplevel binding, it will be kept in memory
05:59:41 <quicksilver> I think maybe Ke is saying that even full integer (+) isn't constant time
05:59:45 <koeien37> this is true for all constant toplevel bindings
05:59:48 <quicksilver> that's also true, yes.
05:59:51 <quicksilver> koeien37: that's not true.
05:59:57 <quicksilver> CAFs can be garbage collected
06:00:01 <koeien37> ah, that's new for me
06:00:02 <koeien37> how?
06:00:03 <quicksilver> GHCi won't do it, admittedly
06:00:11 <quicksilver> same way anything else is garbage collected
06:00:18 <pozic> koeien37: if the compiler can prove it doesn't need it anymore :)
06:00:18 <quicksilver> if no reachable code has a live reference
06:00:21 <Jafet> With enough static analysis!
06:00:40 <pozic> koeien37: which is also in a fantasy world at this point in time.
06:00:41 <quicksilver> GHCi keeps all CAFs because top-level bindings can always be called in GHCi
06:00:48 <quicksilver> pozic: no it's not a fantasy worls
06:00:53 <koeien37> quicksilver: yeah in ghci it makes sense, obviously
06:00:54 <quicksilver> GHC can and does GC CAFs.
06:00:58 <pozic> quicksilver: ok, good.
06:01:17 <quicksilver> actually GHC turns a lot of your code into CAFs by the time the simplifier gets run
06:01:23 <quicksilver> so if it didn't GC them it would be bad indeed.
06:01:59 <Cale> Computing fibs !! 1000000 with the usual zipWith fibs isn't going to be very fast anyhow. You really need a better algorithm than the naive one for indices that high.
06:02:32 <koeien37> you can use recursion on fibs (n `div` 2) or whereabouts
06:05:04 <Jafet> > let fib n = if n == 0 then 0 else let phi = ((1 + sqrt 5) / 2)::CReal; fie = ((1 - sqrt 5) / 2)::CReal; fn = ((phi^^n - fie^^n) / sqrt 5)::CReal in read $ take (1 + floor ((log fn)/(log 10))) $ show fn in fib 1000
06:05:08 <lambdabot>   mueval-core: Time limit exceeded
06:05:31 <koeien37> CReal isn't fast, either
06:06:02 <Jafet> You can efficiently get the first few digits, if you just need an approximation
06:06:05 <RayNbow> you could perhaps use int-e's LinRec module ( http://int-e.home.tlink.de/haskell/LinRec.hs ) to compute Fibonacci numbers
06:06:20 <Jafet> ...not that many formulae depend on large values of Fibonacci numbers.
06:06:24 <koeien37> ha!
06:06:27 <koeien37> that is precisely what I needed
06:06:45 <Jafet> int-e would feel proud, or something
06:07:11 <koeien37> I am currently implementing the Berlekamp-Massey algorithm
06:07:54 <RayNbow> ( relevant link for LinRec: http://www.mail-archive.com/haskell-cafe@haskell.org/msg20882.html )
06:08:11 <Jafet> > let fib n = let phi = ((1 + sqrt 5) / 2)::CReal; fie = ((1 - sqrt 5) / 2)::CReal in ((phi^^n - fie^^n) / sqrt 5)::CReal in take 10 $ show $ fib 1000
06:08:15 <lambdabot>   mueval-core: Time limit exceeded
06:09:50 <Axman6> Jafet: showCReal :: Int -> CReal -> String, btw
06:10:14 <Jafet> Not sure if that helps the efficiency
06:10:28 <Jafet> > let fib n = let phi = ((1 + sqrt 5) / 2)::CReal; fie = ((1 - sqrt 5) / 2)::CReal in ((phi^^n - fie^^n) / sqrt 5)::CReal in showCReal 10 $ fib 1000
06:10:32 <lambdabot>   mueval-core: Time limit exceeded
06:11:08 <ksf> I'm going to do a library ex machinae and supply Control.Imperative and System.Shell
06:11:44 <ksf> ...and Haskell.MissingPreludeFunctions
06:11:57 <Jafet> Subtle.
06:12:07 <koeien37> is the Caleskell-prelude available somewhere? :P
06:12:50 <ksf> ...as I should probably get rid of . and $ alltogether.
06:12:54 <ivanm> quicksilver: I've sent you my slides, and now I"m off to hit the sack
06:13:23 <ivanm> so there's no particular rush; I probably won't be at a computer for at least 12 hours from now
06:13:24 <ivanm> and thanks!
06:13:26 <ivanm> quicksilver++
06:14:23 <Cale> > let fib' (a,b) True = (a*(a+2*b),a*a+b*b); fib' (a,b) False = (a*a+b*b,b*(2*a-b)); fib = snd . foldl' fib' (1, 0) . reverse . map odd . takeWhile (/= 0) . iterate (`div` 2) in fib 1000000
06:14:25 <lambdabot>   195328212870775773163201494759625633244354299659187339695340519457162525788...
06:15:10 <koeien37> what is the role of that boolean?
06:15:34 <Cale> Not much. It's just the nth bit of the thing.
06:16:02 <Cale> You could eliminate it and use a guard instead.
06:16:11 <koeien37> ahw now I see it. and with (!a, !b) it will be a little bit faster, but with this log n, it's not really necessary
06:16:36 <koeien37> or less memory-intensive
06:16:41 <kalven> is this haskell's "killer app"?
06:16:46 <Cale> hehe
06:16:47 <koeien37> no, not realy
06:16:52 <Cale> It's lambdabot's killer app
06:16:54 <koeien37> i hate it whenever it comes up though
06:17:07 <koeien37> "look! Haskell is so cool and expressive! Here is fibonacci!"
06:17:16 <koeien37> ** type checking line noise **
06:17:41 <Jafet> :t let fib' (a,b) True = (a*(a+2*b),a*a+b*b); fib' (a,b) False = (a*a+b*b,b*(2*a-b)); fib = snd . foldl' fib' (1, 0) . reverse . map odd . takeWhile (/= 0) . iterate (`div` 2) in fib
06:17:43 <lambdabot> forall a a1. (Integral a, Num a1) => a -> a1
06:17:50 <Jafet> Crystal clear
06:18:04 <koeien37> well it's self-contained
06:18:19 <Cale> I don't think my example is line noise though.
06:18:33 <koeien37> Cale: no, it's not. But for somebody who is just introduced to the language, it is
06:19:30 <Jafet> Well, the pointless bit is
06:19:31 <koeien37> but most of the time they give the naive, exponential version
06:21:06 <Cale> > let fib' True (a,b) = (a*(a+2*b),a*a+b*b); fib' False (a,b) = (a*a+b*b,b*(2*a-b)); fib = snd . foldr fib' (1, 0) . map odd . takeWhile (/= 0) . iterate (`div` 2) in fib 1000000
06:21:07 <lambdabot>   195328212870775773163201494759625633244354299659187339695340519457162525788...
06:22:23 <roconnor> phr: morning
06:22:24 <xerox> koeien37 there is L.hs in c.h.o/lambdabot/State/ but I guess it is not up to date
06:23:04 <Cale> > let fib' True (a,b) = (a*(a+2*b),a*a+b*b); fib' False (a,b) = (a*a+b*b,b*(2*a-b)); fib = snd . foldr fib' (1, 0) . unfoldr (\n -> guard (n > 0) >> return (odd n, n `div` 2)) in fib 1000000
06:23:06 <lambdabot>   195328212870775773163201494759625633244354299659187339695340519457162525788...
06:23:41 <koeien37> xerox: no it isn't
06:23:42 <Cale> hylomorphism :)
06:23:43 <koeien37> thx
06:23:49 <dino-> Looking at an impl of fibonacci using zipWith yesterday helped me with a problem where I needed to process a list two elements at a time.
06:24:02 <Cale> Where's Data.List.hylo ;)
06:24:11 <koeien37> tricky Maybe monad :)
06:24:32 <Cale> Too bad we can't write it as a comprehension
06:24:42 <koeien37> http://bugs.php.net/bug.php?id=50696 # the downside of success.
06:24:49 <koeien37> yes, I want monad comprehensions :(
06:24:51 <Cale> [(odd n, n`div`2) | n > 0]
06:24:56 <koeien37> why were they removed? Simplicity?
06:25:13 <Cale> "The error messages are confusing my students!"
06:25:22 <koeien37> aptitude install helium
06:25:26 <koeien37> imo that's the way to go
06:25:28 <Cale> yeah
06:25:46 <Cale> Removing monad comprehensions was actually the snowball which caused the avalanche of fail in Haskell 98.
06:25:49 <koeien37> use a simpler but similar in syntax language
06:26:54 <quicksilver> @remember Cale Removing monad comprehensions was actually the snowball which caused the avalanche of fail in Haskell 98
06:26:54 <lambdabot> It is forever etched in my memory.
06:27:18 <Cale> Monad comprehensions were removed -> "We only really needed to keep MonadZero separate from MonadPlus because of monad comprehensions, let's merge them!" -> "Oh, do-notation also used MonadZero for pattern match failure, let's change the translation and add fail to the Monad class"
06:27:37 <copumpkin> gah :)
06:27:46 <koeien37> big mistake to have fail there, yeah
06:27:55 * copumpkin wishes he had been around to scream and throw a tantrum
06:27:56 <ketil> "The rise and fail of monad comprehensions"?
06:28:02 <koeien37> lol
06:28:21 * Cale wonders if anyone who knows GHC well enough is around...
06:28:41 <tromp_> now try to write that fib using showIntAtBase 2 :)
06:28:49 <Cale> If someone implements monad comprehensions, SPJ will accept the patch. I wonder if that includes separating MonadZero and MonadPlus again?
06:29:12 <koeien37> somebody in this channel said FunctorZero > MonadZero
06:29:30 <copumpkin> Cale: I doubt it, at this point it would break a lot of code
06:29:32 <ben0x539> Does everybody who is a MonadPlus implement mzero the same way as fail?
06:29:33 <koeien37> although in current Haskell, it might be strange to have this, since Functor is not a superclass of Monad
06:29:37 <Cale> Well, yeah, perhaps we should be modern about it this time around.
06:29:51 <koeien37> ben0x539: probably not Either String
06:30:01 <Cale> ben0x539: ideally, but there are no conditions on how fail is implemented.
06:30:02 <dino-> Maybe also restructuring the classes with Functor, Applicative (also Pointed?)
06:30:16 <Cale> and yeah, there are cases like Either String where it's a bit questionable
06:30:26 <copumpkin> ugh
06:30:42 <Cale> copumpkin: I say we re-version base and push forward.
06:30:50 <copumpkin> Cale: I wish!
06:30:54 <koeien37> agreeeeeed
06:30:56 <koeien37> down with success!
06:31:01 <copumpkin> I don't even need all the radical stuff in alt-stdlib
06:31:07 <Cale> copumpkin: Besides, doing stuff like making Functor a superclass of Monad will only uncover library bugs.
06:31:11 <copumpkin> but it'd be great to just get rid of all the low-hanging fruit
06:31:16 <ben0x539> Does alt-stdlib still have a wiki page?
06:31:21 <koeien37> is there something written up on alt-stdlib?
06:31:29 <copumpkin> koeien37: it has a trac
06:31:54 <koeien37> I've joined the channel, but I've observed nothing but absolute silence
06:32:20 <copumpkin> koeien37: yeah, it goes up and down, but jmcarthur does most of the stuff right now :)
06:32:35 <Cale> koeien37: Yeah, it's been really quiet lately.
06:32:36 <copumpkin> koeien37: if you have any ideas, by all means bring them up and I'm sure at least a couple of people will pop up and tell you they suck
06:32:41 <Cale> heh
06:33:01 <Cale> I think we should make the changes that we know that we want to make.
06:33:05 <elly> Baughn: was there something I said that provoked that? heh :P
06:33:07 <lpsmith> Ok, I have a package installed with cabal-install under windows,  and ghc-pkg lists the package,  but ghci doesn't find it
06:33:28 <koeien37> there is a trac but only 4 tickets so far :(
06:33:29 <ksf> while :: (Monad m) => m Bool -> m a -> m () doesn't make much sense.
06:33:39 <copumpkin> it'd be nice to mark alt-stdlib changes as "duh, obvious now", "this would be nice", "waiting on additional features in ghc", and "wow, this is totally radical"
06:33:46 <ksf> ...one parameter too much.
06:33:56 <lpsmith> I'm using the haskell platform under windows btw
06:33:58 <koeien37> ksf: why not?
06:34:13 <copumpkin> ksf: huh?
06:34:13 <ksf> well, it could.
06:34:22 <Cale> also, it's discarding the results
06:34:26 <Cale> So it should have an _
06:34:27 <pozic> Why don't people write the complixity of the operations they provide?
06:34:33 <ksf> but a do-while loop definitely just needs one.
06:34:36 <Cale> pozic: Some libraries do.
06:34:38 <pozic> E.g. http://hackage.haskell.org/packages/archive/vector/0.4.2/doc/html/Data-Vector.html
06:34:42 <copumpkin> while2 :: Monad m => m Bool -> (a -> m a) -> m a
06:34:47 <koeien37> ksf: the first is the condition
06:34:48 <pozic> Cale: yes, a few do.
06:34:48 <ben0x539> Pft, implementation detail :V
06:35:05 <copumpkin> whoops, I'd need a starting value too
06:35:06 <pozic> Cale: but not all of them :)
06:35:11 <koeien37> while :: Monad m => m Bool -> m a -> m [a]
06:35:15 <koeien37> plus a while_
06:35:26 <Cale> pozic: People are usually too lazy to figure out what the complexities are.
06:35:27 <ksf> hey I'm trying to do imperative programming, here.
06:35:39 <copumpkin> while3 :: Monad m => (a -> m Bool) -> a -> (a -> m a) -> m a
06:35:39 <ksf> no loops that have return values, please.
06:35:41 <copumpkin> there!
06:35:43 <koeien37> but that might create an unnecessary list, so copumpkin's solution is also nice
06:35:45 <ben0x539> I wonder how far you would get with making 'return' implicit so you can do something like "while True $ do..."
06:35:52 <Cale> m [a]?
06:36:00 <Cale> :t while
06:36:01 <lambdabot> Not in scope: `while'
06:36:03 <pozic> Foe example this type copy :: Vector a -> Vector a makes no sense at all.
06:36:15 <koeien37> ben0x539: that'd be forever
06:36:15 <Cale> :t until
06:36:17 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
06:36:26 <pozic> Copy could simply be 'id' in this case.
06:36:28 <ben0x539> koeien37: But it would sound more imperative!
06:36:37 <pozic> But I am sure that's not how it is implemented.
06:36:38 <copumpkin> Cale: that's what I was going for :)
06:36:40 <koeien37>  #define forever for (;;)
06:36:45 <copumpkin> untilM
06:36:50 <ben0x539> #define ever (;;)?
06:36:51 <copumpkin> not sure why one doesn't exist actually
06:36:51 <ksf> :t untilM
06:36:52 <lunabot>  luna: Not in scope: `define'
06:36:53 <lambdabot> Not in scope: `untilM'
06:38:34 <copumpkin> :t let untilM p f x = do q <- p x; unless q (untilM p f =<< f x) in untilM
06:38:35 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> (a -> m a) -> a -> m ()
06:38:47 <lpsmith> ok,  n/m,  I'm just being silly
06:39:02 <ksf> gragh. trying to do everything monadically is just insanity.
06:39:25 <copumpkin> ksf: nothing wrong with having the function there. there are cases when it might be useful
06:40:10 <ksf> there's no way in hell anyone would ever write fac n monadically without being forced to.
06:40:46 <ksf> otoh, I might just be lacking the proper bits+pieces for a decent for loop.
06:40:53 <copumpkin> ksf: I never said it was for fac
06:41:18 <Cale> ksf: What are you trying to do?
06:41:21 <ksf> ...one has to read a ref to get the variable one wants to test, after all.
06:41:37 <ksf> imperative haskell.
06:42:07 <ksf> a tutorial starting off with imperative programming, and introducing haskell's means of abstractions inside that paradigm.
06:42:58 <ksf> first-class statements, typeclasses, etc.
06:43:17 <ksf> oh, and OOP, of course.
06:44:20 * ksf fetches his harbison+steele
06:46:34 <uorygl> @type intersperse
06:46:35 <lambdabot> forall a. a -> [a] -> [a]
06:46:48 <uorygl> > intersperse ' ' "hello"
06:46:49 <lambdabot>   "h e l l o"
06:47:44 <Jafet> > concat $ intersperse ", " $ words "foo bar baz"
06:47:46 <lambdabot>   "foo, bar, baz"
06:47:49 <bob88883> is there a good tutorial that shows computing normal forms with lambda conversions?
06:48:03 <zygoloid> > intercalate ", " $ words "foo bar baz"
06:48:04 <uorygl> > join . intersperse " " . map (("&#" ++) . (++ ";") . show) $ fix (\x -> 1 : 1 : zipWith (+) x (tail x))
06:48:04 <lambdabot>   "foo, bar, baz"
06:48:05 <lambdabot>   "&#1; &#1; &#2; &#3; &#5; &#8; &#13; &#21; &#34; &#55; &#89; &#144; &#233; ...
06:48:34 <uorygl> @type intercalate
06:48:35 <lambdabot> forall a. [a] -> [[a]] -> [a]
06:49:11 <juhp1> everytime I build pkg-version with ghc-6.12.1 it gets a new uuid?
06:49:13 <Jafet> bob, wikipedia?
06:49:18 <zygoloid> join . intersperse x == concat . intersperse x == intercalate x
06:50:18 <RayNbow> @check \x y -> (concat . intersperse x) y == intercalate (x::String) y
06:50:21 <lambdabot>   "OK, passed 500 tests."
06:50:26 <zygoloid> src intercalate
06:50:28 <zygoloid> @src intercalate
06:50:29 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
06:50:34 <Baughn> elly: Indeed.
06:50:47 <elly> Baughn: what was it, if I may ask? I forgot
06:51:16 <Baughn> @remember elly
06:51:17 <lambdabot> Incorrect arguments to quote
06:51:26 <Baughn> @quote elly
06:51:26 <lambdabot> elly says: I leave for five minutes and godel numbering of endofunctors is invokved as a potential proof that the universe is simulated. Thanks, #haskell :P
06:51:29 <Baughn> That. :P
06:51:42 * ksf wonders whether it's a good idea to lift <= etc. into monads
06:51:47 <elly> oh, I see
06:51:55 <elly> @quote elly malloc
06:51:56 <lambdabot> No quotes match. Where did you learn to type?
06:51:58 <elly> hm
06:52:01 <Phyx-_> lol
06:52:02 <elly> @quote malloc
06:52:03 <lambdabot> Elly says: Rule 1 of malloc is the same as rule 1 of air travel: "Attempt at all costs to keep your number of landings equal to your number of takeoffs."
06:52:14 <elly> oh, it matches case-sensitively? that's irritating
06:52:14 <Phyx-_> @quote Phyx-
06:52:15 <lambdabot> No quotes match. I've seen penguins that can type better than that.
06:52:17 <Phyx-_> @quote Phyx
06:52:18 <lambdabot> No quotes match.
06:52:20 <Phyx-_> @quote phyx
06:52:21 <lambdabot> No quotes match. Just what do you think you're doing Dave?
06:52:25 <Phyx-_> guess i'm not funny
06:52:48 <ksf> it's actually not even un-haskelly. I've seen + operate on applicatives more than once.
06:53:04 <copumpkin> applicative numbers!
06:53:40 <ksf> instance Num a => Num (Vec a) where ...
06:53:49 <juhp1> juhp: I guess not
06:54:11 <ksf> instance Num a => Num (IO a) where ...
06:55:10 <zygoloid> non-commutative + scares me a little :)
06:56:09 <ksf> yeah we obviously get a fixed execution order, then.
06:56:43 <ksf> but that's what you want when you're able to write (modifyIORef a (+1) + (readIORef a)
06:57:29 <koeien37> (+) should be commutative
06:57:55 <bob88883> ]anyone here care to explain function conversion to normal form?
06:57:56 <lunabot>  luna: Not in scope: `anyone'
06:58:03 <bob88883> lol
06:58:16 <ksf> (+) should be as commutative as the underlying algebraic structure.
06:58:25 <ksf> at least from an imperative pov.
06:58:52 * hackagebot upload: hint 0.3.2.2 - Runtime Haskell interpreter (GHC API wrapper) (DanielGorin)
06:59:00 <uorygl> So, the underlying algebraic structure here can be a set-with-functions.
06:59:09 <koeien37> I'm not a C wizard, but f() + g() in C does not guarantee that f() will be executed before g()
06:59:24 <ksf> ...the underlying algebraic structure is the IO Monad, which isn't commutative.
06:59:25 <uorygl> It doesn't?
06:59:45 <koeien37> not entirely sure, but afaik +does not introduce a sequence point
06:59:48 <ksf> koeien37, but we're better than C.
06:59:53 <koeien37> ksf: sure.
07:00:12 <koeien37> but defining (+) on noncommutative structures is a cardinal sin
07:00:18 <uorygl> ksf: it sounds a lot like you're saying it should be as commutative as itself.
07:00:18 <ksf> || and && do that kind of stuff.
07:00:33 <koeien37> || and && are special cases in C
07:00:43 <koeien37> in C++ it's even worse if you overload those
07:00:48 <EnglishGent> has anyone here looked at the Monad reader article 'type level instant insanity' ?
07:00:58 * EnglishGent trying to get something working
07:01:13 <ksf> I'm not saying anything, I just want to have Ord over monadic actions so predicates don't happen to be do-blocks all the time.
07:01:21 <koeien37> liftM2 (<)
07:01:27 <copumpkin> @let untilM p f x = do q <- p x; unless q (untilM p f =<< f x)
07:01:28 <lambdabot>  Defined.
07:01:48 <copumpkin> :t untilM
07:01:49 <koeien37> instance Num a => Num (IO a) is a mistake imo
07:01:49 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> (a -> m a) -> a -> m ()
07:02:02 <ksf> koeien37, it is.
07:02:07 <ufopp> @hoogle Ratio
07:02:08 <lambdabot> module Data.Ratio
07:02:08 <lambdabot> Data.Ratio data Integral a => Ratio a
07:02:08 <lambdabot> Prelude type Rational = Ratio Integer
07:02:14 <ksf> but I'm trynig to cater to imparative programming
07:02:15 <copumpkin> oh whoops, my untilM is broken
07:02:18 <copumpkin> dammit
07:02:38 <bob88883> what is meant by eager and lazy conversion?
07:02:40 <dolio> Addition of lazy Peano numerals is not commutative.
07:03:14 <copumpkin> > foldr (const . (+1)) 0 [1..] > (3 :: Natural)
07:03:15 <lambdabot>   False
07:03:29 <copumpkin> > foldr (const (+1)) 0 [1..] > (3 :: Natural)
07:03:31 <lambdabot>   * Exception: stack overflow
07:03:35 <copumpkin> > foldr (const (1+)) 0 [1..] > (3 :: Natural)
07:03:36 <lambdabot>   True
07:03:40 <PolitikerNEU> Hello everyone, is it allowed to ask homework questions here?
07:03:44 <koeien37> PolitikerNEU: sure
07:03:50 <copumpkin> PolitikerNEU: yeah, but we won't necessarily give you a straight answer
07:03:55 <koeien37> we will try to get you on your way
07:04:04 <dolio> > (undefined + 4) > (3 :: Natural)
07:04:05 <lambdabot>   * Exception: Prelude.undefined
07:04:07 <PolitikerNEU> koeien37: ok, thanks
07:04:12 <dolio> > (4 + undefined) > (3 :: Natural)
07:04:13 <lambdabot>   True
07:04:54 <ksf> bottom doesn't count.
07:04:56 <koeien37> dolio: I see your point. "Normally" (+) is also strict
07:05:05 <ksf> that is, undefined doesn't count.
07:05:12 <ksf> infinity = Succ infinity works.
07:06:02 <PolitikerNEU_> I have got this simple function: http://pastebin.com/d53fc51e6 - but I get a Type : Integer does not match: Int - error and have no clue why
07:06:14 <PolitikerNEU_> Table a is just [a]
07:06:22 <ksf> dolio, see http://www.comlab.ox.ac.uk/people/jeremy.gibbons/publications/fast+loose.pdf
07:06:36 <koeien37> PolitikerNEU_: unfortunately, length returns an Int
07:07:00 <koeien37> and not an Integer. the Integer type is unbounded, whereas Int is not (implementation-defined)
07:07:04 <PolitikerNEU_> koeien37: Can I convert an int to an integer somehow?
07:07:09 <koeien37> PolitikerNEU_: fromIntegral
07:07:22 <ksf> ...but that's not going to work with large lists.
07:07:22 <koeien37> alternatively, you can use genericLength
07:07:27 <PolitikerNEU_> koeien37: Thanks
07:07:47 <koeien37> :t genericLength
07:07:48 <lambdabot> forall b i. (Num i) => [b] -> i
07:07:54 <lpsmith> ksf:  yeah,  a list larger than your available memory :-P
07:08:09 <koeien37> lpsmith: not necessarily. the list may be garbage collected on the go
07:08:12 <ksf> well, it can work, if you don't hold a ref to its beginning.
07:08:27 <lpsmith> true enough
07:08:35 <ksf> something like counting the number of primes that are <10000000 or something.
07:09:02 <lpsmith> that won't overflow an Int thoguh
07:09:04 <copumpkin> that's way smaller than my memory
07:09:14 <PolitikerNEU_> oh - btw: Can I assume (length list) runs in constant time or in linear time? And what for list !! index and for list ++ list2 (sorry, just wanted to know that)
07:09:22 <ksf> linear
07:09:32 <ksf> if you need constant, use Data.Sequence
07:09:32 <PolitikerNEU_> oh, ok
07:09:36 <ksf> those can't be infinite, though.
07:09:37 <koeien37> PolitikerNEU_: no, length is O(n), list !! index is O(index) and list ++ list2 is O(length list)
07:09:40 <ksf> (for obvious reasons)
07:10:15 <tromp_> 664579 primes under 10000000
07:10:22 <koeien37> there are data structures like Data.Set, Data.Map and Data.Sequence that perform better for certain tasks
07:10:32 <ksf> Sequence has constant cons and head from both sides and O(log (min n, m)) append.
07:10:48 <koeien37> with lists, we prefer to pattern match on the constructors and write folds, and we want to avoid taking the length and using (!!)
07:10:59 <koeien37> there is also Data.Array, but it's not so commonly used as in other languages
07:11:16 <ksf> !! for sequence is log( n )
07:11:17 <PolitikerNEU_> ok
07:11:20 <lpsmith> actually,  you can count the number of primes up to n by finding all the primes up to (sqrt n) and applying the principle of inclusion and exclusion, appropriately truncated
07:11:47 <ksf> lpsmith, but that's numericology.
07:12:02 <medfly> you mean number theory
07:12:48 <ksf> numericology is arcane numerics.
07:12:53 <EnglishGent> @seen kfish
07:12:54 <lambdabot> Unknown command, try @list
07:12:59 <EnglishGent> @list
07:12:59 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:13:20 <lpsmith> I'm not sure what asymptotic complexity that works out to,  but in practice it seems to work pretty well.
07:14:02 <ksf> arrays have abysmal complexity for deleting.
07:14:12 <koeien37> yes, don't do that.
07:14:49 <EnglishGent> seen is on the list of lambdabot commands
07:14:54 * EnglishGent now confused :|
07:14:57 <EnglishGent> @seen
07:14:57 <lambdabot> Unknown command, try @list
07:15:02 <ksf> the nice thing about all the tree-based data structures is that they have decent bounds, and no abysmal cases in the smallprint.
07:15:15 <Jafet> I think seen is just bound to a command that prints that message
07:15:37 <ksf> ...which makes them perfect as all-round data structures to use when you're dodging premature optimization.
07:16:05 <lpsmith> koeien37:  I should rephrase that slightly:  you aren't going to overflow a 64-bit Int in a reasonable amount of time just by counting by one :-)
07:16:34 <koeien37> Int is not necessarily 64 bits
07:16:39 <koeien37> imo Int should be removed from the Prelude
07:16:43 <ksf> yep
07:17:05 <Cale> Make people import Data.Int explicitly to use Int
07:17:15 <ksf> and a hardware-accellerated Natural would be nice.
07:17:22 <koeien37> Data.Word? :)
07:17:30 <koeien37> also bounded, of course
07:17:54 <ksf> in fact, the default should be Natural unless there's a -, somewhere.
07:18:13 <Jafet> Integer is already hardware accelerated
07:18:18 <Jafet> (In ghc)
07:18:28 <lpsmith> all praise the GMP
07:18:39 <EnglishGent> oh - is hpaste down?
07:18:41 <Jafet> The GMP, that shalt not be Ctrl-Ced
07:18:58 <Jafet> But shall consume the swap partition, ever and ever.
07:19:01 <lpsmith> Speaking of,  I've been wanted an extended binding for GMP functions
07:19:06 * EnglishGent agrees with koeien (Int)
07:19:16 <EnglishGent> or at least make it PlatformDependent.Int
07:19:21 <lpsmith> So that I can call all the GMP's algorithmic goodness from Haskell
07:19:36 <Jafet> So you want a binding to mpn?
07:19:40 <ksf> or push it into Numeric
07:19:41 <copumpkin> lpsmith: I've written a couple more bindings but the patch hasn't been merged in yet
07:19:44 <lpsmith> I haven't looked into the details of how to make that happen.
07:19:48 <copumpkin> Jafet: mpn isn't really in a nicely bindable state
07:19:55 <lpsmith> Copumpkin:  Yeah, I saw that actually
07:20:04 <Jafet> That's an understatement
07:20:08 <copumpkin> GMP 5 is supposed to have a nice mpn layer too
07:20:10 <ksf> ...or Platform.Types for all that Word, Byte and Int goodness.
07:20:14 <copumpkin> with all the number theoretic functions at that level
07:20:16 <copumpkin> instead of on the mpz
07:20:20 <Jafet> GMP 5 will be released after Perl 6.
07:20:21 <copumpkin> but for now it's fugly
07:20:25 <copumpkin> Jafet: yeah :(
07:20:35 <Jafet> Which is slated to come out two months after DNF.
07:20:36 <copumpkin> I wanted to do a natural type for ghc
07:21:01 <ksf> conal's right that messing with arithmetic modes is evil, so all the prelude and default stuff should be unbounded.
07:21:09 <copumpkin> ksf: I agree
07:21:16 <Jafet> python does that, and it seems sane
07:21:27 <Jafet> They don't have to care about efficiency though
07:21:30 <copumpkin> yeah
07:21:45 <copumpkin> most list functions should be working with a Natural type
07:21:47 <lpsmith> copumpkin:  but there is still once in a while GMP functions I'd like to call, that GHC doesn't bind too.  I understand the reasoning,  as technically the GHC team is violating the GPL and they don't want to get too tied to the GMP
07:21:49 <copumpkin> not Integer or Int
07:22:02 <koeien37> ack, but then Num should be changed too
07:22:08 <Jafet> Secretly we're all wanting dependent typing
07:22:20 <Jafet> We're all secretly wanting Coq.
07:22:26 <EnglishGent> can anyone get to hpaste? I dont seem to be able to :|
07:22:30 <copumpkin> lpsmith: nah, I don't think that's a factor and they aren't violating the GPL. But a lot of the functions aren't that much faster in c than they are in haskell, mostly due to the c jumping through hoops to avoid allocating much and our allocation being super cheap
07:22:35 <ksf> gmp is lgpl, isn't it?
07:22:38 <koeien37> it is
07:22:40 <copumpkin> Jafet: I agda, and you?
07:22:52 <ksf> ...and ghc links it dynamically.
07:23:00 <copumpkin> only recently
07:23:06 <quicksilver> Jafet: GMP5 was, in fact, released on Friday.
07:23:18 <copumpkin> OMG
07:23:19 <copumpkin> really?
07:23:20 <Jafet> Which?
07:23:21 <copumpkin> sweet
07:23:21 <quicksilver> http://gmplib.org/list-archives/gmp-announce/2010-January/000024.html
07:23:33 * copumpkin starts writing a natural binding to it
07:23:34 <quicksilver> Jafet: the one which was 3 days before today, in my timezone at least.
07:23:50 <pozic> quicksilver: is there anything you are not aware of?
07:23:52 <Jafet> Aah, the parallel universe attack
07:23:57 <copumpkin> :)
07:24:09 <copumpkin> that is awesome
07:24:48 <copumpkin> bah, they didn't clean up the mpn interface
07:24:58 <quicksilver> copumpkin: well volunteered!
07:24:59 <quicksilver> ;)
07:25:09 <copumpkin> quicksilver: well, I might do it anyway
07:25:10 <lpsmith> copumpkin:  my experience has often been that the GMP is faster that what I can easily manage in haskell.   Of course, sometimes that's due to better algorithms
07:25:30 <copumpkin> lpsmith: things like the mpz_fac for factorial is only marginally faster, in my experience
07:25:41 <koeien37> why not reuse software?
07:25:42 <copumpkin> but yeah, some of the things are inherently a lot faster because we don't have a good "view"
07:25:51 <pikhq> copumpkin: ... Doesn't GHC implement Integer using GMP?
07:26:01 <copumpkin> lpsmith: I bound things like the bit testing for that reason
07:26:08 <copumpkin> because the current solution is massively inefficient
07:26:09 <lpsmith> right
07:26:09 <copumpkin> pikhq: yep
07:26:14 <lpsmith> I should study your patch
07:26:33 <lpsmith> My idea is to have a more complete GMP binding and release it on Hackage, maybe
07:26:43 <copumpkin> "New mpn functions: mpn_sqr, mpn_and_n, mpn_ior_n, mpn_xor_n, mpn_nand_n, mpn_nior_n, mpn_xnor_n, mpn_andn_n, mpn_iorn_n, mpn_com, mpn_neg, mpn_copyi, mpn_copyd, mpn_zero."
07:26:44 <quicksilver> lpsmith: definitely. The GHC overhead for GMP is higher than you'd hope.
07:26:45 <copumpkin> that's nice
07:27:21 <copumpkin> "New mpz function: mpz_powm_sec for side-channel quiet modexp computations."
07:27:24 <copumpkin> mmm
07:27:36 <koeien37> secure modexp! :)
07:27:40 <copumpkin> yeah!
07:28:06 <copumpkin> lpsmith: a more complete gmp binding might be quite hard to do
07:28:07 <copumpkin> hmm
07:28:25 <copumpkin> I guess not if you depend on integer-gmp
07:28:35 <lpsmith> yeah, I dunno,  I haven't looked into nitty-gritty details yet
07:29:18 <copumpkin> I wonder how much should be in GHC and how much should be in a separate library
07:31:20 <Jafet> Next, implement CReal with mpf
07:31:29 <copumpkin> Jafet: I wanted to do that too, but it's sort of a different goal
07:31:48 <copumpkin> CReal and mpf aren't really the same thing, but a superfast mpf binding would be really nice
07:32:13 <Jafet> You can use mpf as a backend to do the computations
07:32:20 <lpsmith> copumpkin:  what factorial algorithm does the gmp use,  and what algorithm did you compare it to?
07:32:20 <copumpkin> maybe, yeah
07:32:34 <lpsmith> because,  the gmp should be a lot faster than product [1..n]
07:33:43 <Jafet> There's an interesting thing about the C++ mpf layer as well, each expression using mpf_class actually builds a template that recursively selects the correct precision for evaluating itself
07:33:47 <copumpkin> lpsmith: maybe I just did it wrong :) we should start a real project on examining this carefully with real benchmarks, and a complete binding to the other gmp types too
07:34:24 <lpsmith> sounds like an idea :)
07:34:41 <koeien37> there are probably better algorithms than 1 * ... * n
07:34:46 <copumpkin> yeah, using primes
07:34:49 <koeien37> I don't know them, but you could use the prime factorization of n ?
07:34:52 <Jafet> GMP splits by 2, 3, 5
07:34:52 <koeien37> ah ok
07:35:15 <Jafet> And does interleaving collection (to take advantage of large-sized multiplications)
07:35:37 <Jafet> It's all in the manual really, section 4
07:35:41 <copumpkin> lpsmith: I'll set up a project page somewhere if you're interested in it. It's fairly mechanical to actually do the bindings, but there are some interesting choices and questions
07:35:58 <Baughn> > fold [(+3),(*2)]
07:35:59 <lambdabot>   Not in scope: `fold'
07:36:28 <copumpkin> > Data.Foldable.fold [Endo (+3), Endo (*2)]
07:36:30 <lambdabot>   No instance for (GHC.Show.Show (Data.Monoid.Endo a))
07:36:30 <lambdabot>    arising from a use ...
07:36:46 <copumpkin> > appEndo (Data.Foldable.fold [Endo (+3), Endo (*2)]) 5
07:36:47 <lambdabot>   13
07:37:01 <copumpkin> > Data.Foldable.foldMap Endo [(+3), (*2)] 5
07:37:03 <lambdabot>   Couldn't match expected type `t1 -> t'
07:37:03 <lambdabot>         against inferred type `Data....
07:37:03 <Jafet> It folds! (tm)
07:37:09 <Baughn> It spindles!
07:37:11 <copumpkin> > appEndo (Data.Foldable.foldMap Endo [(+3), (*2)]) 5
07:37:12 <lambdabot>   13
07:37:33 <Baughn> But what does "endo" mean, other than being a newtype wrapper for a -> a?
07:37:38 <koeien37> endomorphism
07:37:45 <copumpkin> not in hask though
07:37:45 <koeien37> a homomorphism X -> X
07:38:01 <koeien37> no, generally
07:38:03 <copumpkin> I guess it is, yeah
07:38:04 <copumpkin> sorry
07:38:33 <koeien37> depends on the category, what exactly is meant by that
07:38:37 <copumpkin> yep
07:38:41 * Baughn will creeate a purer haskell, and call it haskemm
07:39:18 <koeien37> there are epi-, mono-, homo-, iso-, auto- and endo-morphisms
07:39:26 <koeien37> i am probably forgetting a lot now
07:39:28 <EvanR-work> haskell minus minus
07:39:33 <Baughn> Are there endomorphism that aren't in some sense functions?
07:39:42 <koeien37> yes
07:39:43 <copumpkin> Baughn: in a monoid
07:39:51 <koeien37> in a category where the arrows are not functions
07:40:00 <Baughn> ..but mappend is a function
07:40:15 <koeien37> e.g. in a category associated to a poset.
07:40:24 <Baughn> Eh.. *lost*
07:40:30 <Baughn> Right. I should go study category theory.
07:40:32 <copumpkin> Baughn: if you think of a monoid as a category with one object, whose morphisms are the elements of the set and composition is the operation
07:40:42 <nainaide> :t forkIO
07:40:43 <lambdabot> Not in scope: `forkIO'
07:41:07 <Baughn> copumpkin: I need to stop provoking this sort of thing when I haven't got a clue about cat. theory. ;_;
07:41:11 <koeien37> there are endomorphisms in lots of situations, like endomorphisms of groups, modules, vector spaces, and so on
07:41:23 <copumpkin> Baughn: it's a fairly simple notion, a category :)
07:41:24 <nainaide> Why does forkIO can I have different type in do block? http://pastebin.com/m2c003e3
07:41:34 <lpsmith> copumpkin:  sure,  that sounds good.
07:41:36 <copumpkin> Baughn: if you don't mind abstract structures in general it's pretty trivial, even
07:41:45 <copumpkin> http://github.com/lpsmith is that you? :)
07:41:49 <copumpkin> lpsmith: or are you more of a darcs person?
07:41:51 <koeien37> nainaide: what's the problem with said code?
07:41:57 <Baughn> copumpkin: Categories are simple?
07:42:01 <copumpkin> Baughn: absolutely
07:42:04 <Baughn> copumpkin: Every explanation I've seen goes on for pages
07:42:07 <koeien37> the definition of a Category is very simple
07:42:09 <Baughn> And chapters, and books..
07:42:14 <copumpkin> Baughn: the definition is trivial, but what you can do with them is fascinating
07:42:27 <copumpkin> but you could pick up enough to understand what I just said about a monoid in a few minutes
07:42:35 <koeien37> yep
07:42:39 <koeien37> or the poset example
07:42:43 <copumpkin> yeah
07:42:46 <nainaide> koeien,  forkIO :: IO () -> IO ThreadId  but in that do block all others is  -> IO ()
07:42:47 <Baughn> I see
07:43:05 <koeien37> nainaide: correct. the *argument* to forkIO is of type IO ().
07:43:21 <dpratt71> copumpkin: one of the most interesting things about Category theory is that it is an existence proof of the fact that "simple" does not always equate to "easy to comprehend"
07:43:25 <copumpkin> Baughn: the actual definitions of most of these things tend to be really trivial, but sometimes they layer up in big piles of abstractions of abstractions and that can make them hard to reason about
07:43:29 <koeien37> so your do { v <- takeMVar m; putStrLn "received" } is required to be of type IO ()
07:43:32 <copumpkin> dpratt71: yeah :)
07:43:34 <uorygl> @hoogle [a] -> (a -> b) -> IO c
07:43:35 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
07:43:35 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
07:43:35 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:44:19 <nainaide> koeien,  so In do block, we can have different  type  every line?
07:44:30 <koeien37> nainaide: the forkIO call takes an IO computation, and returns a IO computation that, when performed, will fork a new thread and return the Thread ID
07:44:37 <koeien37> nainaide: yes
07:44:40 <Chaze> just curious, can I "uncurry" a function that takes n arguments to one that takes one n-tuple?
07:44:49 <Cale> nainaide: But the monad type constructor must be the same in each
07:44:50 <lpsmith> copumpkin:  it is,  and I like both,  although I don't particularly consider myself a guru of either system.
07:44:52 <koeien37> nainaide: not completely, the should all be in the same "monad" (so IO computations)
07:44:52 <ben0x539> @type (>>=)
07:44:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:44:58 <lpsmith> I have a patchtag account as well
07:45:18 <koeien37> but those IO computation may return different things, in the first line you can have a computation returning an Integer, in the next a (), and so on
07:45:25 <quicksilver> @tell mmorrow Oi! You! Hpaste! Fix it!
07:45:26 <lambdabot> Consider it noted.
07:45:34 <Baughn> @type fix unsafePerformIO
07:45:35 <lambdabot> Not in scope: `unsafePerformIO'
07:45:39 <koeien37> (if you don't know what a "monad" is, you can forget my remark  about that)
07:45:42 <nainaide> Cale, koeien I understand. Monad should be same!
07:45:45 <aledge> where is the actual definition of ()
07:45:47 <Jafet> Chaze, \(a, b, c, d, e, ..., n) -> f a b c d e ... n
07:45:53 <nainaide> Thanks !
07:45:53 <koeien37> aledge: presumably, Prelude
07:46:04 <ben0x539> @hoogle ()
07:46:04 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
07:46:05 <lambdabot> Control.Parallel.Strategies r0 :: Strategy a
07:46:05 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
07:46:07 <ben0x539> :|
07:46:19 <aledge> what I mean is, I know how to use it, but I don't really know what it means
07:46:31 <Chaze> Jafet: ah alright. but i'll have to know the number of arguments.
07:46:38 <ben0x539> You can pretend it is defined as data () = ()
07:46:41 <koeien37> aledge: () is a type with one value: ()
07:46:46 <Jafet> You already know the number of arguments.
07:46:51 <koeien37> (ignoring _|_ for the moment)
07:47:05 <aledge> hm, ok
07:47:17 <koeien37> so it is both a type and a value.
07:47:28 <koeien37> it is called "unit" for various reasons
07:47:42 <aledge> what i had always found confusing was in the definition of 'put' in MonadState
07:47:45 <aledge> (StateMonad?)
07:47:51 <koeien37> MonadState
07:48:16 <lpsmith> I always "put" should have been named "set"
07:48:18 <lpsmith> but whatever
07:48:23 <lpsmith> @def put
07:48:24 <lambdabot> Maybe you meant: bf do let
07:48:38 <ben0x539> @src put
07:48:38 <lambdabot> Source not found. Do you think like you type?
07:48:52 <koeien37> () is used in this kind of monadic computation, because it basically signals "no useful return value except for the monadic effects"
07:49:01 <koeien37> :t putStrLn "Hello world!"
07:49:02 <lambdabot> IO ()
07:49:06 <damd> > ()
07:49:07 <lpsmith> put st' = State (\_ -> ((), st'))
07:49:07 <lambdabot>   ()
07:49:14 <aledge> so the expectation is that you do something afterwards
07:49:30 <aledge> well not expectation, but in a non trivial computation you would
07:49:37 <koeien37> in the state monad, generally, yes
07:49:43 <aledge> seems reasonable
07:49:51 <koeien37> since you changed the state, you might want to observe it
07:50:04 <koeien37> get allows you to observe the state
07:50:09 <aledge> right
07:51:19 <koeien37> in the IO monad effects for the sake of effects only are often useful by themselves (viz. putStrLn)
07:51:42 <aledge> right that's how i've always understand IO ()
07:51:57 <bob88883> what would be the normal form for (lambdax.y)z?
07:52:02 <bob88883> just labdax.z?
07:52:33 <zygoloid> > (\x -> y) z
07:52:34 <lambdabot>   y
07:52:50 <koeien37> I am not fully aware of what "normal form" is, but you can probably beta-reduce that
07:53:02 <bob88883> yeah you can
07:53:11 <Jafet> You can eta-reduce that too!
07:53:15 <bob88883> im just revising for and exam just wanted to find out what the normal form of it was for sure
07:53:33 <zygoloid> bob88883: it depends whether x occurs free in y or not
07:53:33 <Cale> Yeah, it's y
07:53:45 <bob88883> just y?
07:53:47 <Cale> (given that those are just variables)
07:53:49 <koeien37> y[x <-  z] in my understanding
07:53:53 <zygoloid> bob88883: the normal form is y, with x replaced by z
07:53:56 <bob88883> is that applying beta and eta conversion?
07:54:10 <zygoloid> (well, that is, assuming that doesn't reduce any further)
07:54:34 <Cale> I'm assuming that y is just a variable and not another term
07:54:45 <bob88883> yeah i think so
07:56:37 <bob88883> so lambda. is just denotes a function x and y is the function or variable?
07:56:56 <koeien37> it loosely corresponds with \x -> y in Haskell
07:57:15 <ramses_> no (lambda x . y) is a function of x which always returns y
07:57:25 <bob88883> ok
07:57:31 <ramses_> (the no was meant at bob...)
07:57:32 <Cale> (\x. x^2) 5 = 5^2 = 25
07:57:49 <medfly> what's with all the strange notation? :)
07:58:04 <koeien37> whose?
07:58:10 <zygoloid> it's lambda-calculus-monday here in #haskell
07:58:14 <bob88883> and the beta rule simply is...
07:58:36 <koeien37> (\ x. y) z  ~> y[x := z]
07:58:50 <koeien37> so, y, with all occurrences of x replaced by z
07:59:33 <ramses_> the beta rule is really just function evaluation
07:59:58 <b0fh_ua> Hi there! I tried to rewtite the function "func2' f g l = (filter f . map g ) l" as pointsfree. What I've got is "func2' f g = filter f . map g". Is there any way to reduce it even more? And if so - can somebody please magic behind that? ;)
08:00:05 <bob88883> but if y is the return variale
08:00:15 <bob88883> why isnt it lambdax.z?
08:00:29 <koeien37> b0fh_ua: that form is the clearest form.
08:00:36 <koeien37> but you can make it even worse
08:00:46 <koeien37> func2' f = (filter f .) . map
08:01:05 <koeien37> and then you can make it even worse, but I'd need pencil & paper
08:01:11 <koeien37> @pl \f -> (filter f . ) . map
08:01:12 <lambdabot> (. map) . (.) . filter
08:01:23 <ramses_> bob: (lamba x . z) is not the same, this is a function returning always z
08:01:48 <copumpkin> lpsmith: I was thinking of doing a collection of packages/repositories. One central hgmp package which will contain the low-level cmm bindings to all gmp functions and will deal with those issues, and then natural-gmp for the mpn bindings, floating-gmp for mpf (to retain the integer-gmp style that's already in ghc). Maybe rational-gmp too, but it probably won't be worthwhile. The reasoning is that most people who want floating stuff pro
08:01:52 <EvanR-work> how come pointless form always ends up with tons of points (periods)
08:01:52 <copumpkin> aren't doing number theory and don't need the naturals, and vice versa
08:01:56 <bob88883> what happens to z in beta conversion tho
08:02:01 <bob88883> why is it just y?
08:02:28 <ramses_> it as if you have a function in mathematics f(x)=5
08:02:35 <ramses_> whathever x is, it returns 5
08:02:35 <bob88883> can z just be considering a variable you put into y?
08:02:42 <EvanR-work> bob88883: i think its that y is y and has no dependence on x
08:02:48 <medfly> @pl (\x->x^2)
08:02:49 <lambdabot> (^ 2)
08:02:53 <medfly> :]
08:03:12 <EvanR-work> bob88883: alternatively if y is something made of x, replace all x with z
08:03:22 <bob88883> ok so lambda x
08:03:26 <bob88883> oh
08:03:42 <bob88883> i thought it was like this x is a function why returns y and has some variable z?
08:03:54 <koeien37> in general, y might be an expression
08:04:11 <copumpkin> lpsmith: if you have a better name than h(s)gmp for the central package I'd love to hear it :) it's pretty boring
08:04:12 <koeien37> (\x . x^2) z  ~> z^2
08:04:19 <EvanR-work> (\x -> y x) z
08:04:24 <EvanR-work> > (\x -> y x) z
08:04:25 <lambdabot>   Couldn't match expected type `t1 -> t'
08:04:26 <lambdabot>         against inferred type `Simpl...
08:04:41 <ramses_> bob88883: (lambda x . x+x)z gives z+z
08:04:44 <medfly> > let y = (^ 2)
08:04:45 <lambdabot>   not an expression: `let y = (^ 2)'
08:04:50 <medfly> @let y = (^ 2)
08:04:51 <EvanR-work> oh, lambda bot should do lambda calculus ;)
08:04:51 <lambdabot>  Defined.
08:04:53 <lpsmith> Sounds like a good reasoning,  I'll admit my main interest is the number theory libraries myself,  and that's more a hobby than anything
08:05:06 <medfly> > (\x-> y x) 5
08:05:07 <lambdabot>   Ambiguous occurrence `y'
08:05:07 <lambdabot>  It could refer to either `L.y', defined at <local...
08:05:09 <copumpkin> lpsmith: yeah, me too :)
08:05:15 <medfly> oh, right
08:05:20 <medfly> @unlet
08:05:21 * hackagebot upload: WXDiffCtrl 0.0.1 - WXDiffCtrl (JeremyODonoghue)
08:05:21 <lambdabot>  Defined.
08:06:03 <lpsmith> gmp-exts?  :-P
08:06:07 <lpsmith> not a whole lot better
08:06:07 <copumpkin> lpsmith: anyway, I'll set up the repositories and stuff later today on github. maybe the central package can be gmp-common
08:06:18 <bob88883> if (lambda x . x+x)z gives z+z ,why not (lambda x . y)z gives z?
08:06:26 <koeien37> it gives z
08:06:29 <koeien37> erm, it gives y
08:06:31 <copumpkin> it gives y
08:06:33 <zygoloid> bob88883: because x != y
08:06:42 <copumpkin> (lambda x. x) z gives z
08:06:42 <medfly> (lambda x . x) z would give z
08:06:47 <copumpkin> :)
08:06:47 <koeien37> y is a variable, there are no occurrences of x there
08:07:25 <bob88883> i thought lambda x was irrevelant just like saying function x =
08:07:42 <ramses_> bob88883: note the difference between the bound variable x and the free variable y! (lambda x . x+x)z gives z+z but (lambda x . y+y)z gives y (assuming y is independent of x)
08:07:51 <medfly> bob88883: what's function x = y x; function z;?
08:07:58 <zygoloid> bob88883: "lambda x. E" means "the function which substitutes something else for the x's in E"
08:08:11 <bob88883> oh ok
08:08:18 <Jafet> Blargh
08:08:46 <medfly> I may be getting this one line notation thing wrong.
08:08:49 <Jafet> There are so many things ghci won't respond to C-C when running
08:08:53 <medfly> s/;/\n/
08:08:54 <yottis> there wouldn't happen to be a wishlist for haskell libraries?
08:09:21 <copumpkin> yottis: /r/haskell_proposals on reddit, maybe?
08:09:34 <Jafet> let a = b; b = a; in a -- also, for some reason, exhausts the heap!
08:09:46 * yottis saw a rant about how haskell library support is not that good and was thinking that i could implement something while taking on haskell after a longish break
08:09:48 <zygoloid> Jafet: compiled? in ghci?
08:10:04 <lpsmith> Jafet:  try compiling it with GHC 6.8
08:10:07 <Jafet> Typed at prompt
08:10:18 <Jafet> lpsmith, haha
08:10:18 <lpsmith> Err, try compiling it first :-)
08:10:28 <yottis> cool
08:10:37 <Jafet> What does compiling do, fix heap size?
08:11:02 <lpsmith> Most importantly,  -O turns on the strictness analysis
08:11:19 <zygoloid> Jafet: in ghci 6.10 it uses no heap and no cpu time for me
08:11:30 <zygoloid> and ctrl-c works
08:11:39 <lpsmith> and it does in general reduce heap allocation, sometimes substantially
08:11:41 <ramses_> Jafet: for me neither, just sits their in infinite loop
08:11:52 <zygoloid> ramses_: using cpu or not?
08:12:08 <Jafet> "The Glorious RAM Eater, version 6.10.1"
08:12:34 <lpsmith> Hey, they don't call it evaluation by allocation for nothing :-)
08:12:46 <ramses_> zygoloid: nope, cpu idles
08:13:20 <Jafet> Guess I'll just turn swap off, so linux will just kill it
08:13:30 <zygoloid> Jafet: which ghc version?
08:13:36 <Jafet> As given above
08:14:08 <lpsmith> Jafet:  keep swap on,  just remember to use ulimit -v when playing around with ghc/haskell :-D
08:14:18 <zygoloid> Jafet: try 6.10.4, i guess...
08:14:19 <koeien37> I have that in my .bashrc
08:14:31 <koeien37> this has proven not only useful for my ghci sessions
08:15:35 <lpsmith> the one obnoxious thing though is if you really want to let a command use more memory than your ulimit,   you can't increase it from the prompt,  you'd have to comment that out of your .bashrc and start a new shell
08:15:54 <koeien37> no
08:15:57 <Cale> Jafet: are you sure? I'm not seeing any memory usage...
08:15:59 <koeien37> ulimit -S sets a soft limit
08:16:15 <koeien37> after that you can reset it to unlimited
08:16:16 <Cale> (about the (let a = b; b = a in a) thing)
08:16:27 <lpsmith> ahh
08:16:28 <bob88883> what would this do:
08:16:29 <bob88883> m (x:xs) = m[y |y <- xs,y <= x] ++ [x] ++  m[y |y <- xs ,y > x}
08:16:31 <lpsmith> good to know
08:16:39 <ben0x539> You cannot kill -9 it?
08:16:40 <koeien37> ulimit -S -v 3145728 # in my .bashrc
08:16:43 <b0fh_ua> koeien37: well. I'm trying to understand pointfree things. What I still can understand, is the "func2 f = (filter f . ) . map". But I still don't see how to get rid of f there :(
08:16:52 <koeien37> why do you want that?
08:16:55 <lpsmith> I assume the "soft" limit still kills things once they allocate more than the soft limit?
08:16:56 <koeien37> it doesn't make it clearer
08:17:02 <Jafet> Cale, version 6.10.1
08:17:06 <Cale> Jafet: ah
08:17:09 <koeien37> lpsmith: it does, the difference is that you can re-increase it
08:17:12 <Cale> Jafet: So it's a bug.
08:17:12 <b0fh_ua> koeien37: just to undertand how that trick works
08:17:17 <Jafet> I guess
08:17:21 <lpsmith> gotcha
08:17:24 <Cale> 6.10.1 was astoundingly buggy
08:17:28 <lpsmith> yeah, I'm definitely adding that to my .bashrc now
08:17:29 <b0fh_ua> koeien37: to get the general idea and rules for getting this done
08:17:36 <Jafet> Yay
08:17:43 <koeien37> @pl (\f -> (filter f .) . map)
08:17:44 <lambdabot> (. map) . (.) . filter
08:17:46 <Jafet> Is that a hint to switch to 6.12?
08:17:48 <lpsmith> thanks koeien37!
08:17:53 <Cale> Jafet: 6.10.4
08:18:09 <bob88883> what does a squiggly bracket represent in haskell?
08:18:09 <EvanR-work> bob88883: merge sort?
08:18:13 <Cale> Jafet: 6.10.1 and .2 are especially bad.
08:18:28 <Cale> bob88883: Like { ?
08:18:29 <koeien37> bob88883: what is a squiggly bracket? { and } ?
08:18:34 <bob88883> }
08:18:35 <bob88883> yeah
08:18:45 <b0fh_ua> koeien37: ma I ask about some explainations of how that was transformed? )
08:18:46 <koeien37> it's used for record notation
08:18:53 <jmcarthur> depends how it's used. it's a grouping symbol
08:18:58 <Cale> bob88883: They're used as part of the syntax of blocks. You can avoid writing them by using whitespace appropriately.
08:18:59 <EvanR-work> its also used for let, do, where, case
08:19:03 <EvanR-work> etc
08:19:05 <jmcarthur> could be for records or for do notation or...
08:19:08 <koeien37> yes
08:19:31 <koeien37> b0fh_ua: well, if you start out with \f -> (filter f .) . map
08:19:31 <Jafet> Funnily enough, the web browser has stopped working too.
08:19:35 <jmcarthur> hmm, can records be written without { and }?
08:19:50 <koeien37> b0fh_ua: you need to get an expression of the form (....) f
08:19:55 <jmcarthur> i guess just no syntax sugar for that
08:19:59 <jmcarthur> normal ADT syntax
08:20:21 <koeien37> b0fh_ua: there is probably an algorithm, but normally i just fiddle around
08:20:30 <bob88883> hugs does not like m :: [Int} -> [Int]
08:20:35 <bob88883> is that a typo?
08:20:40 <Cale> bob88883: yes, that's a typo
08:20:43 <zygoloid> braces are also used for multiline comments: {- foo -}
08:20:43 <lpsmith> cale:  6.8.2 had a nasty scoping bug in ghci
08:20:44 <koeien37> so first ( .map) (filter f .)
08:20:53 <bob88883> lol thatwas in a past exam
08:21:02 <zygoloid> @type first (.map) (filter f.)
08:21:03 <lambdabot>     Couldn't match expected type `f [a] -> f [a]'
08:21:03 <lambdabot>            against inferred type `(([a1] -> [b1]) -> b, d)'
08:21:03 <lambdabot>     In the expression: first (. map) (filter f .)
08:21:18 <lpsmith> I ran across it trying to use a memo function,  and having my program run *really* *really* slow instead of fast
08:21:24 <koeien37> zygoloid: I didn't mean the function first
08:22:14 <bob88883> ok so i found out that
08:22:14 <bob88883> m (x:xs) = m[y |y <- xs,y <= x] ++ [x] ++  m[y |y <- xs ,y > x]
08:22:18 <koeien37> :t \f -> (.map) (filter f .)
08:22:19 <lambdabot> forall a a1. (a1 -> Bool) -> (a -> a1) -> [a] -> [a1]
08:22:20 <b0fh_ua> koeien37: i'm following you )
08:22:20 <bob88883> is just for sorting numbers
08:22:26 <bob88883> can someone explain how it works
08:22:29 <koeien37> :t \f -> (.map) ((.) filter f)
08:22:31 <lambdabot> forall a b a1. (([a] -> [b]) -> a1 -> Bool) -> (a -> b) -> [a1] -> [a1]
08:22:40 <koeien37> :t \f -> (.map) . ((.) filter) $ f
08:22:41 <lambdabot> forall a b a1. (([a] -> [b]) -> a1 -> Bool) -> (a -> b) -> [a1] -> [a1]
08:22:48 <koeien37> and then eta-reduce
08:23:04 <b0fh_ua> koeien37: omg
08:23:11 <b0fh_ua> thanks )
08:23:27 <koeien37> it's pretty mechanical, just don't be intimidated by all the dots and parens
08:23:39 <Bjartur> #xmonad
08:23:40 <zygoloid> @type (.)(.).(.)(.).(.)(.)(.).(.)
08:23:40 <lunabot>  luna: Not in scope: `xmonad'
08:23:41 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) (f2 :: * -> *) a1 b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a1 -> b) -> (a -> f2 (f3 a1)) -> f (f1 a) -> f (f1 (f2 (f3 b)))
08:24:35 <koeien37> b0fh_ua: hmm, the type there is pretty strange, so I probably made a mistake
08:24:46 <HOANG-PC-SQRT> 1
08:24:46 <Jafet> > (.)(.) id const succ 5$ 0xb00b135
08:24:47 <lambdabot>   6
08:24:57 <HOANG-PC-SQRT>  m
08:25:02 <koeien37> :t \f -> (.map) ((.) (filter f))
08:25:03 <lambdabot> forall a a1. (a1 -> Bool) -> (a -> a1) -> [a] -> [a1]
08:25:13 <Saizan_> bob88883: it splits the list into the elements smaller and greater than the first element, recurses over these two partitions, and concatenates them respectively before and after the first element
08:25:24 <koeien37> :t \f -> (.map) ( ( (.) . filter ) f)
08:25:26 <lambdabot> forall a a1. (a1 -> Bool) -> (a -> a1) -> [a] -> [a1]
08:25:30 <Saizan_> bob88883: it's similar to quicksort
08:25:41 <koeien37> :t \f -> (.map) . ( (.) . filter ) $ f
08:25:42 <lambdabot> forall a a1. (a1 -> Bool) -> (a -> a1) -> [a] -> [a1]
08:25:47 <koeien37> that's better
08:25:57 <bob88883> whats the ++ do?
08:26:00 <EvanR-work> Jafet: lambda porn
08:26:43 <Saizan_> bob88883: concatenates two lists
08:26:49 <Saizan_> > [1,2] ++ [3,4]
08:26:50 <lambdabot>   [1,2,3,4]
08:26:53 <b0fh_ua> yeah
08:27:08 <koeien37> I guess that's also lambdabot's answer
08:27:28 <zygoloid> nah...
08:27:28 <koeien37> @pl \f -> (filter f .) . map
08:27:29 <lambdabot> (. map) . (.) . filter
08:27:33 <zygoloid> > Nothing ++ Just 42
08:27:34 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:27:34 <lambdabot>    `GHC.Num.Num a'
08:27:34 <lambdabot>      ari...
08:27:37 <zygoloid> :(
08:27:43 <zygoloid> > Nothing ++ Just "foo"
08:27:44 <lambdabot>   Just "foo"
08:27:52 <aavogt> > Nothing ++ Just (Sum 42)
08:27:53 <lambdabot>   Just (Sum {getSum = 42})
08:27:53 <koeien37> I expected so much from Cale, yeah :)
08:27:54 <bob88883> x is the list and xs is an element from x?
08:28:07 <Saizan_> bob88883: no
08:28:19 <b0fh_ua> crazy thing
08:28:19 <bob88883> other way round?
08:28:21 <quicksilver> preflex: seen kfish
08:28:22 <preflex>  kfish was last seen on #haskell 34 days, 5 hours, 3 minutes and 9 seconds ago, saying: nice bots here :)
08:28:25 <quicksilver> EnglishGent: like that
08:28:30 <zygoloid> the anticaleskell sentiment seems to be on the rise these days
08:28:33 <ramses_> bob88883: the list is (x:xs) so x is the first element xs are the rest
08:28:41 <ramses_> bob88883: read up on patterns in haskell
08:28:42 * aavogt writes (xs:x)
08:28:45 <koeien37> zygoloid: no, I agree, (++) should be the monoid operator
08:28:46 <Saizan_> bob88883: in (x:xs) the whole thing is a list, x is the first element of it, and xs is the rest
08:28:52 <quicksilver> aavogt: pervert
08:28:59 <aavogt> I know
08:29:00 <Cale> zygoloid: Not really. It just depends on the time of day :)
08:29:31 <absentia> anyone here looking at ANIC? (the programming language?)
08:29:33 <Saizan_> ?src []
08:29:33 <lambdabot> data [] a = [] | a : [a]
08:29:49 <koeien37> absentia: I saw that on HN and proggit. I thought it was a joke, but apparently it was not :|
08:30:12 <copumpkin> absentia: looks interesting but there's only a parser for now, so all the claims seem rather vaporwareish for now
08:30:14 <Phyx-_> lambdabot: LIAR! i call you out on that one!
08:30:14 <Phyx-_> lol
08:30:21 <copumpkin> omg automatic parallelization and faster than c etc.
08:30:22 <absentia> it claims faster than C
08:30:25 <copumpkin> seems rather naive
08:30:33 <koeien37> there is no compiler
08:30:35 <copumpkin> absentia: yes, but it doesn't even have an interpreter yet
08:30:46 <medfly> no compiler and no interpreter?
08:30:49 <aavogt> copumpkin: what, no cold fusion either?
08:30:50 <copumpkin> it comes off as a well-intentioned but naive
08:30:51 * medfly looks.
08:30:54 <copumpkin> language
08:30:58 <ben0x539> I wonder how they benchmarked "faster than C"
08:31:01 <koeien37> "faster than C", means what? icc? gcc?
08:31:03 <copumpkin> the syntax is gross :)
08:31:08 <copumpkin> koeien37: C the language!
08:31:10 <copumpkin> is inherently slow
08:31:11 <copumpkin> duh
08:31:12 <absentia> icc was damn fast...
08:31:15 <koeien37> on what benchmark?
08:31:18 <copumpkin> absentia: unless you're on an AMD :P
08:31:28 <absentia> ha
08:31:29 <absentia> true
08:31:31 <Phyx-_> who uses amds? :P
08:31:32 <tibbe> dcoutts: hey, do you think you'll make it to the hackathon in March?
08:31:32 * Phyx-_ hides
08:31:36 * medfly uses one
08:31:51 <koeien37> I don't, only intels here
08:31:57 <medfly> what are hackathons about?
08:32:06 <Phyx-> i don't either, not since my AMD K6-3
08:32:07 * absentia just patiently awaits his 64bit haskell... 
08:32:09 <zygoloid> on our codebase, icc was slower than gcc and produced slower code :(
08:32:31 <koeien37> zygoloid: hmm. I don't have experience, but I hear everywhere that icc is faster generally
08:32:34 <copumpkin> absentia: there already is one, depending on your platform
08:32:35 <koeien37> i.e. produces faster code
08:32:44 <copumpkin> absentia: but I get the impression you're on Mac OS :P
08:32:45 <absentia> zyg: you should try "go"  :-)  I hear it makes really purdy web pages and only sends some of your info to google.
08:32:55 <absentia> cop:  snow leopard.
08:33:07 <zygoloid> koeien37: it's probably faster at number crunching, but we spend most of our time pulling in cache lines :)
08:33:08 <copumpkin> absentia: yeah, no 64-bit there yet :(
08:33:08 <Phyx-> i tried compiling ghc 64bits on windows
08:33:12 <Phyx-> it puked at me
08:33:33 <Phyx-> somewhere there was a check for cygwin32
08:33:35 <absentia> ok, back to opengl studies...
08:33:42 <koeien37> "ANI is lightweight like a shell script but fast like C, safe like Java, and implicitly massively parallel like a language for the parallel processing age should be."
08:33:47 <bob88883> whats do y<=x  and y<-x do?
08:34:02 <Jafet> It's everything everywhere!
08:34:14 <EvanR-work> parallel processing age my ass
08:34:17 <EvanCarroll> koeien37: it is also cooks, cleans and generates winning lottery tickets.
08:34:18 <ramses_> bob88883: read about list comprehensions. you should really just start reading a haskell tutorial
08:34:31 * hackagebot upload: event-monad 0.0.3 - Event-graph simulation monad transformer (JamesCook)
08:34:39 <koeien37> (<=) is the familiar comparison function
08:34:58 <Phyx-> hopefully familiar
08:35:57 <ben0x539> I am almost certain that they named this ANIC project so they could have http://code.google.com/p/anic/
08:36:06 <dcoutts> tibbe: definitely will be at the hackathon
08:36:09 <medfly> lol
08:36:15 <dcoutts> tibbe: I plan my year around it :-)
08:36:20 <ben0x539> which is rather what it excites in me with the first piece of example code, to be entirely honest
08:36:31 <koeien37> ben0x539: yeah
08:36:34 <Phyx-> are these hackaton fun?
08:36:34 <tibbe> dcoutts: great, do you mind registering so I can keep a count of the number of people attending. we're over 50 now!
08:36:39 <tibbe> dcoutts: :)
08:37:00 <tibbe> Phyx-: I'm biased because I'm organizing but I've had fun at the ones I've attended so far.
08:37:03 <dcoutts> tibbe: 50? crikey!
08:37:12 <tibbe> dcoutts: yes, with 2 months to go
08:37:51 <dcoutts> tibbe: can you cope with such high numbers?
08:38:00 <tibbe> dcoutts: space wise yes
08:38:01 * Saizan_ needs to look for a place to stay in zurich
08:38:12 <tibbe> dcoutts: the food budget is looking a bit low. I'll see what I can do about that
08:38:17 <koeien37> ooh, europe
08:38:40 <tibbe> Saizan_: I wish I had more advice on that front but I never stayed in a hostel/hotel in Zurich. Only in my apt.
08:38:48 <copumpkin> lpsmith: now that I look more closely, for floating stuff it's probably best to use mpfr, which is based on gmp but has a more extensive interface (sin/cos etc.) and has correct rounding modes.
08:39:13 <tibbe> dcoutts: I'm wondering if I'll have to set a limit somewhere. That's why I'm asking if you want to come. :)
08:39:54 <pozic> tibbe: the fact that Google operates there obviously has absolutely nothing to do with it... :)
08:40:07 <tibbe> pozic: right ;)
08:40:13 <tibbe> brb
08:40:21 <pozic> In reality they probably won't see anything interesting, though.
08:41:09 <copumpkin> lpsmith: I might make the common low-level library a binding to both mpfr and gmp, as they're very closely related (the former is a dependent "fork" of the latter), and then make natural-gmp and floating-mpfr
08:41:43 <dcoutts> tibbe: ok, sent, thanks for prodding me
08:42:21 <copumpkin> lpsmith: but my main priority for now is to do the natural bindings :)
08:42:22 <lpsmith> Isn't there an interface to the mpfr already?
08:43:28 <copumpkin> lpsmith: I noticed one, but it isn't very pretty and it isn't using the primitive bindings
08:44:11 <lpsmith> hmm
08:44:16 <lpsmith> fair enough :)
08:44:28 <copumpkin> anyway, not a high priority for now
08:44:31 <lpsmith> I was confused a little though,  between CReal and the MFPR
08:44:42 <lpsmith> I haven't looked at the MFPR bindings at all
08:44:50 <copumpkin> CReal is slow and pure haskell, and has infinite precision
08:45:45 <Jafet> MFPR, mpf and various other C libraries have fixed, arbitrary precision
08:45:49 <copumpkin> yeah
08:45:55 <Jafet> (which you ideally use as a backend for libraries like CReal)
08:46:08 <copumpkin> mpfr is just an expanded version of mpf as far as I can see
08:46:56 <Jafet> GMP is quirky, though. It's old, allocates strangely, barely threadsafe (don't even think about trying to interrupt it), doesn't trust gcc with machine code translation whatsoever
08:47:09 <b0fh_ua> koeien37: may be you could also explain the same about "func3 f l = l ++ map f l" ? for now I don't have an idea of how to eliminate l, if it is used in2 places
08:47:41 <koeien37> you will need something like join
08:47:47 <koeien37> join f = \x -> f x x
08:48:01 <koeien37> let's see what lambdabot makes out of it
08:48:07 <koeien37> @pl \f l -> l ++ map f l
08:48:08 <lambdabot> ap (++) . map
08:48:17 <aavogt> :t liftM2 (++) id (map ?f)
08:48:18 <lambdabot> forall b. (?f::b -> b) => [b] -> [b]
08:49:01 <aavogt> oh, ap is simpler here
08:49:05 <b0fh_ua> koeien37: ap (++) . map - what is ap there?
08:49:33 <koeien37> ap is a function that works on monads (the same as <*> for applicatives)
08:49:49 <aavogt> ap g x = ap x (g x)
08:49:58 <b0fh_ua> koeien37: ok
08:50:21 <koeien37> @src ap
08:50:21 <lambdabot> ap = liftM2 id
08:50:34 <b0fh_ua> okay
08:50:48 <aavogt> it looks better as  liftM2 ($)
08:50:55 <koeien37> I think it's easier to find the function yourself if you use join though.
08:50:56 <Saizan_> which reduces to what aavogt said, for the (->) r monad
08:52:23 <aavogt> I am confusing
08:52:33 <aavogt> ap f g x = f x (g x)
08:53:11 <xerox> > ap (f :: Expr -> Expr -> Expr) g x
08:53:12 <lambdabot>   f x (g x)
08:53:16 <aavogt> Saizan_: way to catch that ;)
08:53:17 <xerox> > (=<<) (f :: Expr -> Expr -> Expr) g x
08:53:18 <lambdabot>   f (g x) x
08:56:07 <aavogt> interesting, usually bind is different from ap, but I guess flip sort of can touch stuff that isn't usually accessible in other Monads
08:58:30 <Saizan_> uh, oops :)
08:59:54 <copumpkin> @src Real
08:59:54 <lambdabot> class  (Num a, Ord a) => Real a  where
08:59:54 <lambdabot>     toRational      ::  a -> Rational
08:59:59 <copumpkin> I find that hilarious
09:00:52 <benmachine> > toRational (sqrt 2)
09:00:54 <lambdabot>   6369051672525773 % 4503599627370496
09:00:57 <benmachine> magic.
09:01:06 <Jafet> Scandalous.
09:01:08 <copumpkin> > toRational (sqrt 2 :: CReal)
09:01:09 <lambdabot>   * Exception: CReal.toRational
09:01:23 <copumpkin> gotta love the numeric classes
09:01:23 <benmachine> > toRational (0.5 :: CReal)
09:01:25 <lambdabot>   * Exception: CReal.toRational
09:01:28 <benmachine> oh ok
09:02:05 <Cale> It probably could have just gone with some approximation
09:02:07 <burp> > 6369051672525773 / 4503599627370496 :: CReal
09:02:09 <lambdabot>   1.4142135623730951454746218587388284504414
09:02:12 <burp> > sqrt 2 :: CReal
09:02:13 <lambdabot>   1.4142135623730950488016887242096980785697
09:02:34 <copumpkin> Cale: I'd much prefer that ridiculous class to be removed :P
09:02:39 <copumpkin> or at least renamed
09:02:46 <lpsmith> You can implement toRational using continued fractions, or (basically equivalentlly) the Stern-Brocot tree
09:02:56 <lpsmith> I haven't looked at it though to figure out what it uses
09:03:06 <copumpkin> toRationals :: a -> [Rational]
09:03:10 <copumpkin> that'd be cute
09:03:48 <quicksilver> the "Rational" type doesn't support lazy precision generation in a sensible way though
09:04:06 <copumpkin> a list of them would work though
09:06:13 <Berengal> Ratio Natural
09:06:19 <Berengal> No, I guess that wouldn't work either
09:06:24 <quicksilver> Berengal: I don't think that works, no.
09:07:11 <Berengal> data LazyPrecission = LP {magnitude :: Integer, digits :: [Int]}
09:07:46 <benmachine> Integer :. [Int]
09:13:51 * hackagebot upload: loop-while 1.0.0 - A monad transformer supporting various styles of while loop (NeilBrown)
09:17:12 <tibbe> preflex: seen dons
09:17:12 <preflex>  dons was last seen on #haskell 18 days, 15 hours, 40 minutes and 27 seconds ago, saying: no serious haskell program needs hlist.
09:17:24 <tibbe> I dons still on vacation?
09:17:53 * hackagebot upload: parameterized-data 0.1.4 - Parameterized data library implementing lightweight dependent  types (HoseinAttarzadeh)
09:18:02 <lpsmith> @let half_convergent x y zs = drop 2 (fix (\as -> x : y : zipWith3 (\z a b-> a + z*b) zs as (tail as)))
09:18:03 <lambdabot>  Defined.
09:18:31 <xerox> as in faster convergence transform?
09:18:32 <copumpkin> @hackage parameterized-data
09:18:33 <lambdabot> http://hackage.haskell.org/package/parameterized-data
09:18:57 <benmachine> @hackage non-package
09:18:57 <lambdabot> http://hackage.haskell.org/package/non-package
09:19:01 <benmachine> oh ok
09:19:01 <lpsmith> @let convergents zs = zip (half_convergent 0 1 zs) (half_convergent 0 1 zs)
09:19:02 <lambdabot>  Defined.
09:19:16 <lpsmith> convergents (1 : repeat 2)
09:19:19 <xerox> or as in truncated continued fractions
09:19:24 <lpsmith> > convergents (1 : repeat 2)
09:19:25 <lambdabot>   [(1,1),(3,3),(7,7),(17,17),(41,41),(99,99),(239,239),(577,577),(1393,1393),...
09:19:34 <lpsmith> xerox: the latter, unless I botched something
09:19:50 <lpsmith> @undefine
09:20:05 <lpsmith> @let half_convergents x y zs = drop 2 (fix (\as -> x : y : zipWith3 (\z a b-> a + z*b) zs as (tail as)))
09:20:06 <lambdabot>  Defined.
09:20:15 <quicksilver> @tell dons All serious haskell programs contain an ad-hoc, informally specified, bug-ridden, reimplementation of hlist. (with apologies to greenspun)
09:20:16 <lambdabot> Consider it noted.
09:20:23 <lpsmith> @let convergents zs = zip (half_convergent 0 1 zs) (half_convergent 1 0 zs)
09:20:24 <lambdabot>  <local>:2:22: Not in scope: `half_convergent'
09:20:24 <lambdabot>  
09:20:24 <lambdabot>  <local>:2:47: Not in scope:...
09:20:32 <lpsmith> @let convergents zs = zip (half_convergents 0 1 zs) (half_convergents 1 0 zs)
09:20:33 <lambdabot>  Defined.
09:20:35 <lpsmith> > convergents (1 : repeat 2)
09:20:37 <lambdabot>   [(1,1),(3,2),(7,5),(17,12),(41,29),(99,70),(239,169),(577,408),(1393,985),(...
09:20:50 <lpsmith> > toRational (sqrt 2)
09:20:51 <lambdabot>   6369051672525773 % 4503599627370496
09:21:07 <zygoloid> > toRational pi
09:21:09 <lambdabot>   884279719003555 % 281474976710656
09:21:12 <zygoloid> i always suspected :)
09:21:34 <lpsmith> > dropWhile ((< 4503599627370496) . snd) (convergents (1: repeat 2))
09:21:35 <lambdabot>   [(14398739476117879,10181446324101389),(34761632124320657,24580185800219268...
09:21:59 <Jonno_FTW_> what do I do when ghci wants String but I gave IO String?
09:22:06 <lpsmith> heh,  not surprisingly,  toRational (sqrts 2) is not among the convergents of sqrt 2
09:22:26 <zygoloid> > toRational (pi :: CReal)
09:22:27 <lambdabot>   * Exception: CReal.toRational
09:22:28 <Berengal> Jonno_FTW_: In ghci, x <- foo -- The IO String
09:22:35 <Berengal> Jonno_FTW_: Then x is the string
09:22:51 <lpsmith> > 14398739476117879 / 10181446324101389
09:22:52 <lambdabot>   1.4142135623730954
09:22:56 <lpsmith> > sqrt 2
09:22:57 <lambdabot>   1.4142135623730951
09:23:00 <zygoloid> rather, then x is *a* string produced by foo
09:23:13 <zygoloid> if you then do 'y <- foo' you can get a different string
09:23:19 <Berengal> However you want to phrase it
09:23:48 <zygoloid> i'd say that understanding that IO String isn't a string in a box is pretty essential :)
09:23:56 <Jonno_FTW_> i want to be able to do
09:23:59 <Jonno_FTW_> words $ readFile "names.txt"
09:24:02 <Berengal> It's a String in a box with feet on :)
09:24:05 <xerox> > let agreeing_digits x y = abs . truncate $ log (x - y) / log 10 in agreeing_digits (355/113 :: Double) (pi::Double)
09:24:06 <lambdabot>   6
09:24:24 <EvanR-work> foo >> thingThatWantsString
09:24:24 <xerox> which is pretty easy to remember 113355 split 113 355 and quotient :)
09:24:37 <Berengal> zygoloid: Ever since I first heard the Maybe = Box analogy, I've thought of IO as Luggage
09:24:59 <EvanR-work> a monad is like a burrito
09:25:05 <zygoloid> Berengal: in that it has different things in it whenever you open it, and that opening it may have side effects that are dangerous to your health?
09:25:08 <aavogt> > 22/7
09:25:09 <lambdabot>   3.142857142857143
09:25:10 <lpsmith> Yummy monads
09:25:30 <Berengal> zygoloid: Very much like that, yes.
09:25:32 <lpsmith> This monad needs moar hot sauce!
09:26:04 * zygoloid hands lpsmith a spicy salsa burrito transformer
09:26:07 <Berengal> @let pi = 3
09:26:08 <lambdabot>  Defined.
09:26:21 <lispy> > pi
09:26:22 <lambdabot>   Ambiguous occurrence `pi'
09:26:23 <lambdabot>  It could refer to either `L.pi', defined at <loc...
09:26:25 <lispy> > L.pi
09:26:26 <lambdabot>   3
09:26:32 <lispy> ?check pi == L.pi
09:26:33 <lambdabot>   Not in scope: `L.pi'
09:26:44 <lispy> Oh, I thought check had everything in scope
09:26:52 <lispy> ?check pi == 3
09:26:53 <lambdabot>   "Falsifiable, after 0 tests:\n"
09:27:14 <wto> :D
09:27:26 <monochrom> Someone found lots of ants in a monad bought from a certain MacDonald's location near Toronto.  s/monad/burrito/
09:27:30 <Berengal> I love mathematics. I can just define whatever I want
09:27:31 <EvanR-work> ?check pi == 3.14
09:27:32 <lambdabot>   "Falsifiable, after 0 tests:\n"
09:27:45 <Olathe> McMonad
09:27:50 <EvanR-work> ?check pi == toRational pi
09:27:51 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
09:27:51 <lambdabot>    arising from a us...
09:28:10 <Berengal> monochrom: Ants? In my monads? It's more likely than you think.
09:28:18 <zygoloid> monochrom: that's the thing about monads. because they're functors people can always fmap some const ants in when you're not looking
09:28:58 * hackagebot upload: chp 2.0.0 - An implementation of concurrency ideas from Communicating Sequential Processes (NeilBrown)
09:29:17 <monochrom> w00 chp hits 2.0.0
09:30:51 <monochrom> @quote bind
09:30:52 <lambdabot> ghc says: Implicit parameters escape from the monomorphic top-level binding(s)
09:31:15 <tibbe> preflex: tell bos I need something better than Data.Unique to represent keys in my PSQ. I see that you started a module. Was that the intention of that module?
09:31:16 <preflex>  Consider it noted.
09:36:57 <samirov> 1
09:37:09 <byorgey> 2
09:37:22 <zygoloid> 3
09:38:07 <monochrom> :)
09:38:16 <aavogt> @bot
09:38:16 <lunabot>  :o
09:38:16 <lambdabot> :)
09:38:34 <monochrom> :)
09:38:44 <zygoloid> > fix((0:).(1:).ap(zipWith(+))tail)
09:38:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:39:30 <Deewiant> > fix((0:).scanl(+)1)
09:39:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:39:47 <Olathe> @let ffib :: Int -> Integer; ffib n = snd.foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k $!chr(124) k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p $!chr(124) p = (f*(f+2*g), ss) $!chr(124) otherwise = (ss, g*(2*f - g)) where ss = f*f+g*g --by wli
09:39:48 <lambdabot>   Parse error: LeftArrow
09:39:57 <Olathe> Bah.
09:40:10 <Olathe> One sec
09:40:41 <Olathe> @let ffib :: Int -> Integer; ffib n = snd.foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f - g)) where ss = f*f+g*g --by wli
09:40:42 <lambdabot>  Defined.
09:40:44 <Jonno_FTW_> is there an opposite function to splitAt?
09:40:58 <Saizan_> (++) ?
09:41:07 <Jonno_FTW_> hmm
09:41:11 <zygoloid> @type \n -> uncurry (++) . splitAt n
09:41:12 <lambdabot> forall a. Int -> [a] -> [a]
09:41:16 <Olathe> @type splitAt
09:41:17 <lambdabot> forall a. Int -> [a] -> ([a], [a])
09:41:23 <byorgey> Jonno_FTW_: can you give an example of what you mean?
09:41:51 <Jonno_FTW_> ("abc","xyz") -> "abcxyz
09:41:53 <Jonno_FTW_> "
09:42:05 <koeien37> :t uncurry (++)
09:42:06 <lambdabot> forall a. (Monoid a) => (a, a) -> a
09:42:07 <zygoloid> @check \n xs -> let m = n `mod` (length xs + 1) in uncurry (++) (splitAt m xs) == xs
09:42:08 <lambdabot>   "OK, passed 500 tests."
09:42:08 <Olathe> > uncurry (++) ("abc", "xyz")
09:42:09 <lambdabot>   "abcxyz"
09:42:18 <Jonno_FTW_> ok
09:42:22 <b0fh_ua> Can somebody please explain the expression "( . map) . (.) . filter" ? At least how hould I read it - from left to right, and what is the order of evaluation here
09:42:32 <Olathe> @unpl ( . map) . (.) . filter
09:42:32 <lambdabot> (\ g m d -> filter g (map m d))
09:42:57 <medfly> b0fh_ua: Twey claims to find them easy to understand
09:43:06 <copumpkin> they aren't bad
09:43:06 * hackagebot upload: chp-plus 1.0.0 - A set of high-level concurrency utilities built on Communicating Haskell Processes (NeilBrown)
09:43:08 <copumpkin> but take getting used to
09:43:12 <Saizan_> b0fh_ua: the order of evaluation would be the same as the pointful version
09:43:14 <Berengal> That one's not so bad
09:43:18 <byorgey> b0fh_ua: well, as with any chain of composed functions, data flows through it from right to left
09:43:22 <Saizan_> b0fh_ua: except for the initial expansion of the (.)s
09:43:38 <b0fh_ua> I'm confused with . (.) .
09:43:41 <koeien37> that one is quite awful
09:43:44 <copumpkin> :)
09:44:28 <copumpkin> b0fh_ua: so how does f . g $ x proceed?
09:44:35 <copumpkin> it applies g to x and passes the result to f
09:44:46 <b0fh_ua> it calls g x and then applies f to the result
09:44:46 <copumpkin> so (.) . filter
09:45:00 <copumpkin> (.) . filter $ f
09:45:13 <copumpkin> that does filter f and passes it to (.)
09:45:21 <copumpkin> effectively doing (filter f .)
09:45:52 <copumpkin> now you have (. map) . (filter f .) $ ?
09:46:02 <b0fh_ua> that one is clear enough
09:46:14 <sshc> why isn't GHC.IO.Buffer System.IO.Buffer?
09:46:15 <Jonno_FTW_> > let x = "hello" uncurry (++) $ splitAt (length$x`div`2))
09:46:16 <lambdabot>   <no location info>: parse error on input `)'
09:46:22 <copumpkin> but I would never write that code in a real module
09:46:22 <Jonno_FTW_> > let x = "hello" uncurry (++) $ splitAt (length$x`div`2)
09:46:23 <lambdabot>   not an expression: `let x = "hello" uncurry (++) $ splitAt (length$x`div`2)'
09:46:25 <b0fh_ua> but i'm not sure I will easily create such expression in nearest future )
09:46:31 <Jonno_FTW_> > let x = "hello" in uncurry (++) $ splitAt (length$x`div`2)
09:46:32 <lambdabot>   Couldn't match expected type `(a, a)'
09:46:32 <lambdabot>         against inferred type `[a1] -...
09:46:37 <Jonno_FTW_> :/
09:46:42 <b0fh_ua> KISS, as usual
09:46:49 <copumpkin> one or two partially applied (.) I can live with, but if it takes half a minute to decode the meaning it's not good
09:46:51 <copumpkin> yep
09:46:51 <Jonno_FTW_> just testing
09:46:59 <b0fh_ua> but this refusts most of cool features of a language :(
09:47:03 <b0fh_ua> *refuses
09:47:04 <Olathe> Jonno_FTW_: length $ x `div` 2 does x `div` 2 first.
09:47:07 <Saizan_> ( . map) . (.) . filter = \x -> (( . map) . (.)) (filter x) = \x -> (\y -> ( . map) ((.) y)) (filter x) = \x -> (. map) ((.) (filter x)) = \x ->  ((.) (filter x)) . map = \x -> \z -> ((.) (filter x)) (map z) = \x z -> filter x . map z = \x z w -> filter x (map z w)
09:47:12 <Berengal> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails) $ [1,0,0,1,0,0,1]
09:47:13 <Olathe> Jonno_FTW_: x isn't a number.
09:47:14 <lambdabot>   146
09:47:24 <Jonno_FTW_> > let x = "hello" in uncurry (++) $ splitAt (length x$`div`2)
09:47:25 <lambdabot>   <no location info>: parse error on input ``'
09:47:40 <Jonno_FTW_> > let x = "hello" in uncurry (++) $ splitAt ((length x)`div`2)
09:47:41 <lambdabot>   Couldn't match expected type `(a, a)'
09:47:41 <lambdabot>         against inferred type `[a1] -...
09:47:52 <Jonno_FTW_> .....
09:47:56 <copumpkin> b0fh_ua: nah, most of the language features are conceptually quite easy
09:48:03 <copumpkin> their implementations might be nightmarish though :)
09:48:05 <Olathe> > foldr ((+).(*2)) 0 [1,0,0,1,0,0,1]
09:48:06 <lambdabot>   6
09:48:07 <Saizan_> > let x = "hello" in uncurry (++) $ splitAt ((length x)`div`2) x
09:48:08 <lambdabot>   "hello"
09:48:18 <Jonno_FTW_> oh righy
09:48:49 <Olathe> > foldl' ((+).(*2)) 0 [1,0,0,1,0,0,1]
09:48:51 <lambdabot>   73
09:49:11 <Olathe> > 64 + 8 + 1
09:49:12 <lambdabot>   73
09:49:48 <Berengal> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails) $ "HTHTTHTH"
09:49:50 <lambdabot>   266
09:50:03 <Berengal> It's the average number of coin-tosses needed to get the input sequence
09:50:22 <Olathe> Jonno_FTW_: Try to test as you go instead of building it all upfront and fixing it.
09:50:33 <Olathe> > let x = "hello" in length x
09:50:34 <lambdabot>   5
09:50:43 <Olathe> > let x = "hello" in length x `div` 2
09:50:44 <lambdabot>   2
09:50:52 <Olathe> > let x = "hello" in splitAt (length x `div` 2) x
09:50:54 <lambdabot>   ("he","llo")
09:50:56 <Olathe> Etc.
09:51:03 <copumpkin> Berengal: cute
09:51:13 <Olathe> That way, you can fix things easier, since you only changed a small part.
09:51:17 <copumpkin> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails) $ "H"
09:51:18 <lambdabot>   2
09:51:29 <lpjhjdh> is anyone familiar with the accelerate dsl?
09:51:31 <copumpkin> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails) $ "HT"
09:51:32 <lambdabot>   4
09:51:44 <Twey> b0fh_ua: Right to left
09:51:44 <Berengal> copumpkin: The algorithm is really simple, and would be pretty readable in pointed form
09:51:45 <xerox> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) .  init . tails)
09:51:45 <copumpkin> lpsmith: TacticalGrace is :)
09:51:45 <lambdabot>   {[]->0;[()]->2;[(),()]->6;[(),(),()]->14}
09:51:48 <xerox> oops
09:51:49 <copumpkin> lpjhjdh:
09:52:12 <lpjhjdh> copumpkin: what's the preferred way of adding a row to an array?
09:52:14 <Berengal> copumpkin: Just find the length of every prefix of the sequence that is also a suffix, raise two to the power of each, and sum.
09:52:28 <copumpkin> Berengal: ah :)
09:52:35 <copumpkin> lpjhjdh: beats me, I've never used it :)
09:52:37 <lpsmith> copumpkin,  I think you meant lpjhjdh :-)
09:52:44 <copumpkin> lpsmith: I did :)
09:52:50 <copumpkin> I just can't get you off my mind
09:52:56 <lpsmith> hahaha
09:53:14 <lpsmith> Better not let your gf find out :-P
09:53:19 <lpjhjdh> haha
09:53:29 <lpjhjdh> damn
09:53:36 <copumpkin> she's far away! she won't know
09:56:14 <copumpkin> this gmp vs. mpfr question is bothering me
09:56:21 <Olathe> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails)
09:56:23 <lambdabot>   {[]->0;[()]->2;[(),()]->6;[(),(),()]->14}
09:56:38 <copumpkin> I feel bad making another binding to mpfr first of all, but my approach will be different from the other developer's
09:56:40 <Olathe> How do you get the arrows ?
09:56:43 <xerox> 2^n-2
09:56:49 <copumpkin> Olathe: smallcheck
09:57:05 <copumpkin> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails) :: [Bool] Int
09:57:07 <lambdabot>   Kind error: `[GHC.Bool.Bool]' is applied to too many type arguments
09:57:10 <copumpkin> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails) :: [Bool] -> Int
09:57:12 <lambdabot>   []->
09:57:12 <lambdabot>    0
09:57:12 <lambdabot>  [True]->
09:57:12 <lambdabot>    2
09:57:12 <lambdabot>  [True,True]->
09:57:14 <lambdabot> [4 @more lines]
09:57:42 <copumpkin> xerox: I don't think that's the case for lists that aren't isomorphic to naturals :)
09:57:54 <copumpkin> (and yes, I'm ignoring _|_)
09:58:39 <zygoloid> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails) [0,1,0,1,1,0,1,2]
09:58:40 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
09:58:40 <lambdabot>         against inferred typ...
09:59:04 <zygoloid> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails) $ [0,1,0,1,1,0,1,2]
09:59:05 <lambdabot>   256
09:59:17 <zygoloid> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails) $ [0,1,2]
09:59:18 <lambdabot>   8
09:59:33 <zygoloid> > sum . map ((2^).length) . filter and . (map.(flip ($)) <*> map (zipWith (==)) . init . tails) $ ["Heads", "Tails", "Edge of coin"]
09:59:34 <lambdabot>   8
10:11:53 <PolitikerNEU_> hmm ... could someone point me to a link explaining how to convert do in >>=-notation?
10:12:13 <xerox> do { let bindings; ... }  ->  let bindings in do { ... }
10:12:25 <xerox> do { x <- amb; ... }  ->  amb >>= \x -> do { ... }
10:12:29 <PolitikerNEU_> ah, thanks
10:12:35 <xerox> do { amb; ... }  ->  amb >> do { ... }
10:12:42 <xerox> do { amb }  ->  amb
10:13:25 <aavogt> @do x >>= \y -> z y
10:13:25 <lambdabot> do { y <- x; z y}
10:13:31 <Jonno_FTW_> why won't the main in this work?
10:13:40 <Jonno_FTW_> f x = uncurry (++) $ (fst (splitAt ((length x)`div`2) x)++"r",snd (splitAt ((length x)`div`2) x))
10:13:41 <zygoloid> PolitikerNEU_: and finally...
10:13:42 <Jonno_FTW_> main = print $ fmap f $ fmap words $ readFile "dictionary.txt"
10:13:53 <zygoloid> @undo do { Some pattern <- foo }
10:13:53 <lambdabot>  Parse error at "}" (column 26)
10:13:57 <zygoloid> :(
10:14:12 <zygoloid> @undo do { Some pattern <- foo; bar pattern }
10:14:13 <lambdabot> foo >>= \ a -> case a of { Some pattern -> bar pattern; _ -> fail ""}
10:14:31 <aavogt> main = print . f . words =<< readFile "dictionary.txt"
10:14:43 <Jonno_FTW_> ok
10:14:44 <xerox> oh right, patterns! darn
10:14:44 <aavogt> main = join $ print $ fmap f $ fmap words $ readFile "dictionary.txt"
10:14:48 <xerox> thanks zygoloid
10:15:03 <aavogt> main = join $ fmap print $ fmap f $ fmap words $ readFile "dictionary.txt" -- this works too
10:15:12 <zygoloid> xerox: refutable patterns are the nasty wart on the side of do desugaring :)
10:15:24 <Jonno_FTW_> what does join do?
10:15:28 <xerox> I wonder why not just  \(Some pattern) ->  instead of x
10:15:31 <Jonno_FTW_> :t join
10:15:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:15:34 <EvanR-work> @src join
10:15:35 <lambdabot> join x =  x >>= id
10:15:43 <aavogt> Jonno_FTW_: print takes something with a Show instance, but there is no instance,   Show a => Show (IO a)
10:15:47 <xerox> oh, refutable is the keyword.
10:15:48 <zygoloid> Jonno_FTW_: it takes two layers of the same monad and collapses them down to one layer
10:16:10 <Jonno_FTW_> thanks
10:16:16 <zygoloid> Jonno_FTW_: in some sense this is the opposite of what 'return' and 'liftM return' do
10:16:16 <aavogt> Jonno_FTW_: perhaps do notation is easier to have an intuition here?
10:16:37 <aavogt> @type join . liftM return
10:16:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
10:16:51 <zygoloid> Jonno_FTW_: (in fact those are restatements of monad laws: return . join == id, and liftM return . join == id)
10:17:04 <zygoloid> actually, forget that, i got it backwards
10:17:15 <zygoloid> join . return == id
10:17:48 <aavogt> well the flipped version still has to hold...
10:17:59 <aavogt> @type return . join
10:18:01 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m, Monad m1) => m1 (m1 a) -> m (m1 a)
10:18:14 <zygoloid> > return . join $ [[1,2],[3,4]]
10:18:15 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
10:18:15 <lambdabot>    arising from a use of `M56682211...
10:18:33 <aavogt> > return . join $ [[1,2],[3,4]] :: [[Int]]
10:18:34 <lambdabot>   [[1,2,3,4]]
10:18:41 <aavogt> I guess not then
10:20:21 <Jonno_FTW_> i still get an error
10:20:35 <Jonno_FTW_> of it wanting Char where i gave [Char]
10:22:04 <aledge> What kind of university programs do the kind of research that potentially ends up e.g. as a paper on some haskell feature
10:22:09 <aledge> is it always a programming language theory group?
10:22:19 <aavogt> Jonno_FTW_: depends what your f is here
10:22:35 <Jonno_FTW_> f x = uncurry (++) $ (fst (splitAt ((length x)`div`2) x)++"r",snd (splitAt ((length x)`div`2) x)) :: String
10:22:43 <Jonno_FTW_> i know it's ugly
10:22:53 <Jonno_FTW_> but it returns a string
10:22:59 <aavogt> but what type is x
10:23:06 <aavogt> f :: ???? -> String
10:23:25 <Jonno_FTW_> String -> String
10:23:28 <aavogt> :t f x = uncurry (++) $ (fst (splitAt ((length x)`div`2) x)++"r",snd (splitAt ((length x)`div`2) x))
10:23:29 <lambdabot> parse error on input `='
10:23:30 <mercury^> @pl return . join
10:23:31 <lambdabot> return . join
10:23:40 <aavogt> :t \x -> uncurry (++) $ (fst (splitAt ((length x)`div`2) x)++"r",snd (splitAt ((length x)`div`2) x))
10:23:41 <lambdabot> [Char] -> [Char]
10:23:45 <aledge> :t join
10:23:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:23:53 <aavogt> :t \x -> uncurry (++) $ (fst (splitAt ((length x)`div`2) x)++"r",snd (splitAt ((length x)`div`2) x)) . words
10:23:54 <lambdabot>     Couldn't match expected type `a1 -> a'
10:23:55 <lambdabot>            against inferred type `([Char], [Char])'
10:23:55 <lambdabot>     In the first argument of `(.)', namely
10:24:03 <aledge> :info sequence_
10:24:04 <aavogt> :t (\x -> uncurry (++) $ (fst (splitAt ((length x)`div`2) x)++"r",snd (splitAt ((length x)`div`2) x))) . words
10:24:05 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
10:24:06 <lambdabot>       Expected type: String -> [Char]
10:24:06 <lambdabot>       Inferred type: String -> [String]
10:24:16 <aavogt> Jonno_FTW_: this is what you have ^^
10:24:26 <Jonno_FTW_> ye[
10:24:31 <Jonno_FTW_> yes
10:24:51 <aavogt> what are you trying to do with  f and each word?
10:24:59 <aavogt> :t map (\x -> uncurry (++) $ (fst (splitAt ((length x)`div`2) x)++"r",snd (splitAt ((length x)`div`2) x))) . words
10:25:00 <lambdabot> String -> [[Char]]
10:25:08 <Jonno_FTW_> put an 'r' in the middle
10:25:15 <aavogt> that is one option
10:25:37 <lpsmith> copumpkin:  don't feel bad about creating another mpfr binding :)
10:26:02 <aavogt> :t map (\x -> uncurry (++) $ (splitAt ((length x)`div`2) x)++"r" ++ snd (splitAt ((length x)`div`2) x)) . words
10:26:03 <lambdabot>     Couldn't match expected type `([Char], [Char])'
10:26:03 <lambdabot>            against inferred type `[Char]'
10:26:03 <lambdabot>     In the second argument of `(++)', namely
10:26:12 <aavogt> :t map (\x -> (splitAt ((length x)`div`2) x)++"r" ++ snd (splitAt ((length x)`div`2) x)) . words
10:26:13 <lambdabot>     Couldn't match expected type `([Char], [Char])'
10:26:14 <lambdabot>            against inferred type `[Char]'
10:26:14 <lambdabot>     In the second argument of `(++)', namely
10:26:38 <aavogt> :t map (\x -> fst (splitAt ((length x)`div`2) x)++"r" ++ snd (splitAt ((length x)`div`2) x)) . words
10:26:39 <lambdabot> String -> [[Char]]
10:26:50 <jfischoff> anyone feel like helping a newb with a mutliparamter type class issue?
10:27:31 <aavogt> :t map (\x -> let (b,n) = splitAt (length x `div`2) x in b++"r"++n) . words
10:27:32 <lambdabot> String -> [[Char]]
10:27:41 <Cale> I can't help until I know what the question is ;)
10:27:45 <aavogt> Jonno_FTW_: ^^
10:28:23 <Jonno_FTW_> it was a challenge to see who could write the program with the least code
10:28:26 <Jonno_FTW_> wherein
10:28:40 <jfischoff> Cale: I can't seem to write a instance properly. It compiles but when I try to use it it fails
10:28:49 <jfischoff> Cale: here is the instance instance Coord a => Positionable (JustPositionVertex a) a
10:28:56 <Jonno_FTW_> open a dictionary file and put an "r" in the middle of each word
10:29:32 <jfischoff> Cale: so when I create a concrete version of JustPositionVertex the compiler complains when I try to use and says...
10:29:45 <jfischoff> Cale:  No instance for (Positionable (JustPositionVertex CartPoint3) c)
10:29:46 <aavogt> Jonno_FTW_: there's still lots of room for golf in the code
10:29:50 <copumpkin> lpsmith: :)
10:29:52 <Jonno_FTW_> yep
10:30:29 <jfischoff> Cale: maybe I can't write generic instances like that?
10:30:39 <Jonno_FTW_> but i'd like it working before i cut it down
10:31:22 <aavogt> here is a common pattern:     onWords f = unwords . map f . words
10:31:29 <aavogt> I think you try to do this
10:31:38 <Jonno_FTW_> ok
10:32:00 <aavogt> > unwords . words $ "\n   n    n n n       n \n\n\n aa \n" -- note this
10:32:01 <lambdabot>   "n n n n n aa"
10:32:35 <Jonno_FTW_> yep removes the newlines
10:32:44 <Jonno_FTW_> my dictionary file is delineated by newlines
10:35:31 <Jonno_FTW_> what's wrong with
10:35:34 <zygoloid> > let onWords f = unwords . map f . words; onLines f = unlines . map f . lines in onLines (onWords (intersperse ',')) "foo bar baz\nfoo2 bar2 baz2\nquux!!"
10:35:35 <lambdabot>   "f,o,o b,a,r b,a,z\nf,o,o,2 b,a,r,2 b,a,z,2\nq,u,u,x,!,!\n"
10:35:46 <Jonno_FTW_> fmap words "file.txt"?
10:36:05 <monochrom> what's right with it?
10:36:27 <aavogt> @index IsString
10:36:27 <lambdabot> bzzt
10:36:31 <aavogt> @index toString
10:36:31 <lambdabot> bzzt
10:36:33 <mental> Jonno_FTW_: what's wrong with it?
10:36:33 <Jonno_FTW_> oh right
10:36:34 <aavogt> @index fromString
10:36:35 <lambdabot> bzzt
10:36:42 <Jonno_FTW_> i forgot readFile
10:37:19 <Jonno_FTW_> fmap words $ readFile"file.txt"?
10:37:19 <monochrom> You see how "what's wrong?" solves no problem, and "what's right?" solves every problem and fixes all bugs.
10:37:36 <aavogt> instance IsString (IO String) where fromString = readFile -- context, people
10:37:42 <Jonno_FTW_> so now I have an IO list of strings
10:38:10 <Jonno_FTW_> i now want to map f over that list
10:38:15 <Traveler0> hello i want to ask a bunch of beginner questions please
10:38:20 <aavogt> @faq does haskell support abominations?
10:38:21 <lambdabot> The answer is: Yes! Haskell can do that.
10:38:38 <xerox> monochrom I object to the scientificity and reproducibility of the argument.
10:38:41 <copumpkin> Traveler0: we don't allow questions in here, sorry
10:39:05 <monochrom> fmap (map f) $ fmap words $ readFile "file.txt"
10:39:07 <copumpkin> only trollish statements eliciting responses like "haskell concurrency sucks" (read as, "how do I use concurrency in haskell?")
10:39:18 <aavogt> @quote HaskellLove
10:39:18 <lambdabot> HaskellLove says: your Phd supervisor is my uncle, watch out !
10:40:00 <Traveler0> @copumpkin hm where shouldi go then?
10:40:01 <lambdabot> Unknown command, try @list
10:40:23 <copumpkin> Traveler0: I was just kidding :) ask away
10:40:25 <HugoDaniel> is there any module for interpolation in haskell ?
10:40:27 <c_wraith> Traveler0: that was a joke.  watch out for copumpkin
10:40:37 <aavogt> HugoDaniel: what kind of interpolation?
10:40:46 <aavogt> there's a dsp library
10:40:51 <HugoDaniel> well, any kind
10:40:56 <aavogt> there's also HStringTemplate
10:40:58 <monochrom> equivalently fmap (map f . words) $ readFile "file.txt"
10:41:08 <Traveler0> i have a function with 5 guards in its body
10:41:10 <HugoDaniel> linear, quadratic, cubic, whatever
10:41:13 <aavogt> both involve interpolation
10:41:23 <HugoDaniel> interpolation between values
10:41:24 <Traveler0> the last is otherwise blah blah
10:41:34 <aavogt> @hackage dsp
10:41:35 <lambdabot> http://hackage.haskell.org/package/dsp
10:41:41 <Traveler0> is it possible to get an exception?
10:41:52 <xerox> Another idea: interact (f . words) and pipe the file in stdin
10:42:07 <copumpkin> Traveler0: depends on the patterns
10:42:28 <Trinithis> what would be a good name for a function  foo :: (a -> a -> Bool) -> a -> a -> (a, a) where foo p x y = if p x y then (x, y) else (y, x)
10:42:29 <Traveler0> yes that is what helium tells me but i dont get it exactly
10:42:52 <monochrom> Alternatively paste complete code so everyone can tell.
10:42:54 <Traveler0> otherwise is not for every other possible situation?
10:42:55 <PolitikerNEU_> ok, thanks everyone, it seems I am able to run my file ... just one question (If someone has too much time :-) ) - I dont't really like the (Leaf numb) <- St (\c -> ((Leaf c),c+1)) in my code, can it be replaced by something "better looking"? http://pastebin.com/m235774a6 (same holds for index <- St (getOrCreateIndex x)) - and btw: Even though the term has nearly finished, I still program my haskell programs like my iterative ones,
10:42:57 <PolitikerNEU_> so - if you see any strange non-haskell-like things you can tell me too
10:43:26 <sshc> I'm looking at the documentaition for System.Console.GetOpt, but it doesn't mention what I should pass as the second string for "ReqArg (String -> a) String"
10:43:34 <monochrom> Correction. Alternatively paste complete code so we don't have to say "it depends".
10:43:36 <aavogt> > case () of fail "evaluating patterns can cause haskell evaluation to diverge" -> "Traveler0"; otherwise -> "maybe?"
10:43:37 <lambdabot>   <no location info>: Parse error in pattern
10:43:44 <watermind> after years of GHCi I still find myself typing :q! to quit
10:44:01 <aavogt> > case () of _ | error "evaluating patterns can cause haskell evaluation to diverge" -> "Traveler0" | otherwise -> "maybe?"
10:44:02 <lambdabot>   "* Exception: evaluating patterns can cause haskell evaluation to diverge
10:44:05 <Cale> jfischoff: Instances are selected based on the structure of the type alone. You might want a functional dependency.
10:44:13 <mmaruseacph2> i have a question
10:44:23 <mmaruseacph2> let's suppose i have access to a server
10:44:24 <Cale> jfischoff: Something like class Positionable a b | a -> b where ...
10:44:30 <mmaruseacph2> call it server
10:44:40 <mmaruseacph2> on the server i cannot install haskell libs
10:44:41 <PolitikerNEU_> oh, sorry, this code uses another function - this is my whole code: http://pastebin.com/d557afcb9
10:44:53 <jfischoff> Cale: So the compiler is confused which instance to grab?
10:44:57 <mmaruseacph2> but i want to run a haskell program which I wrote and tested on my machine?
10:45:12 <Cale> jfischoff: yeah, because it's not sure that c = CartPoint3
10:45:16 <mmaruseacph2> can i upload to the server an executable which will not require any haskell library?
10:45:23 <Traveler0> there is no problem with maybe i think
10:45:28 <aavogt> mmaruseacph2: ghc binaries are for the most part statically linked
10:45:42 <Cale> jfischoff: and without knowing that, it can't just assume that it's going to be.
10:45:56 <aavogt> you need gmp installed, and maybe a couple other things
10:46:21 <jfischoff> Cale: cool. I'll try the functional dependency idea, and I'll try making it one parameter type class with types in the functions
10:47:05 <Jonno_FTW_> i golfed it into one line
10:47:15 <Jonno_FTW_> main = join $ fmap print $ fmap (\x->uncurry (++) $ (fst (splitAt ((length x)`div`2) x)++"r",snd (splitAt ((length x)`div`2) x)) :: String ) $ fmap words $ readFile "dictionary.txt"
10:47:21 <Jonno_FTW_> but it still doesn't work
10:48:01 <mmaruseacph2> without installing gmp, can i do this?
10:48:39 <jfischoff> Cale: Dependent types fixed it. Your the man. Thanks!
10:48:56 <Traveler0> can you explain me what you mean evaluation to diverge?
10:50:16 <Traveler0> i mean i have pretty straight forward things if list is empty if fst x == fst y
10:50:28 <Eduard_Munteanu> Hi.
10:51:32 <monochrom> PolitikerNEU_: This is because you don't have helper functions like these: put x = St (\_ -> ((),x)); get = St (\s -> (s,s)); modify f = St (\s -> ((), f s)).  For example (Leaf n) <- St (\c -> ((Leaf c),c+1)) can be written as n <- get <newline> put (n+1)
10:51:38 <Jonno_FTW_> fst applies to tuples
10:51:43 <Jonno_FTW_> first applies to lists
10:51:57 <Traveler0> y i have a list of taples
10:52:19 <Jonno_FTW_> map fst [(a,a)]
10:52:24 <Jonno_FTW_> like that?
10:52:35 <Traveler0> imagine the list is x:xs
10:52:43 <Traveler0> and y:ys
10:52:51 * Jonno_FTW_ imagines
10:52:55 <Traveler0> and i want to see if the first element of the taple
10:52:57 <mmaruseacph2> can i statically link to gmp and others?
10:52:59 <Traveler0> is the same
10:53:13 <Jonno_FTW_> taple or tuple?
10:53:28 <Traveler0> a pair
10:53:28 <Eduard_Munteanu> What is a taple?!
10:53:36 <Jonno_FTW_> that's what i thought
10:53:43 <Jonno_FTW_> a list of tuples perhaps?
10:53:45 <Jonno_FTW_> like a tape
10:53:48 <Traveler0> a list of pairs
10:54:01 <Eduard_Munteanu> Hm, never heard it that way before.
10:54:05 <Jonno_FTW_> in that case
10:54:10 <Traveler0> 2 lists of pairs
10:54:53 <Jonno_FTW_> map (\(a,b)-> fst a == fst b) $ zip (x:xs) (y:ys)
10:54:58 <Jonno_FTW_> like that?
10:55:10 <Jonno_FTW_> in fac
10:55:18 <Jonno_FTW_> map (\(a,b)-> fst a == fst b) $ zip x y
10:55:26 <Traveler0> hm i see symbols i havent been thought in my course :P
10:55:31 <Jonno_FTW_> ok
10:55:42 <Jonno_FTW_> a $ replaces parantheses
10:55:50 <Traveler0> a ok then
10:56:06 <PolitikerNEU_> monochrom: Ah, ok, thanks
10:56:08 <Traveler0> why u have zip?
10:56:25 <Jonno_FTW_> a+(b*c) == a+ $ b*c
10:56:35 <Cale> uh, that doesn't work
10:56:42 <Jonno_FTW_> :/
10:56:50 <Cale> You can't have two infix operators next to each other
10:56:59 <sshc> Hi.  upon running my program, it stops running in the middle and prints "Main: <<loop>>"
10:57:01 <aledge> hehe shouldn't a+(b*c) == a+b*c :P
10:57:02 <Jonno_FTW_> they'll do as i say
10:57:12 <Jonno_FTW_> anyway
10:57:15 <damd> (a+) $ b * c
10:57:24 <Jonno_FTW_> you zip them to get a list of pairs of tuples
10:57:27 <monochrom> So much for replacing parentheses.
10:57:30 <Cale> sshc: That means that it went into a detectable infinite loop, and GHC stopped it.
10:57:54 <Traveler0> hm i dont want to zip them i receive them as input :)
10:58:07 <sshc> Cale: how do I find where this is?
10:58:25 <Cale> sshc: It happens when in order to evaluate the value of some variable x, you end up needing to evaluate x before reaching some constructor
10:58:30 <Jonno_FTW_> you are given 2 lists of tuples as input?
10:58:31 <HugoDaniel> how do i define a datatype that only has values between 0.0 and 1.0 ?
10:58:32 <Gracenotes> do you use fix anywhere? tight recursion anywhere?
10:58:38 <Hiato> Heya all, just a qucik one: does anyone know of a haskell shell (and by shell, I mean UNIX-type shell) that is decent/not dead? There's Hash and something else, but the one is dead ant the othner is in planning...
10:58:43 <Traveler0> yes 2 lists of pairs
10:59:04 <Jonno_FTW_> f x y = map (\(a,b)-> fst a == fst b) $ zip x y
10:59:21 <Cale> Hiato: Not really. There's HSH, but it is a library for shell-programming tasks, not really a user shell.
10:59:28 <Jonno_FTW_> do you know lamba expressions?
10:59:39 <Traveler0> the basics yes
10:59:45 <HugoDaniel> i would really like to have type constraints in haskell
10:59:55 <Jonno_FTW_> so you get what it does now?
10:59:55 <Hiato> Cale: ah, bugger. Oh well, thanks though. Found rush, just thought there'd be an aewsome-r one for Haskell
11:00:07 <Traveler0> i am simply confused because u answer me before i quite end my qestion
11:00:14 <Gracenotes> Jonno_FTW_: or: f = zipWith ((==) `on` fst)
11:00:17 <Jonno_FTW_> go on then
11:00:23 <aledge> :t on
11:00:24 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:00:32 <thoughtpolice> Hiato: there's haskal
11:00:35 <Jonno_FTW_> that's a bit complicated imo
11:00:41 <thoughtpolice> Hiato: it's an old project but I updated it to work on ghc 6.10
11:00:58 <Traveler0> 2 lists of pairs received as input
11:01:09 <thoughtpolice> Hiato: I was planning on maintaining it more but I haven't gotten around to it. patches are welcome :) http://github.com/thoughtpolice/haskal
11:01:09 <Hiato> thoughtpolice: Oh? Are we talking non-cabal? But i'll check it out now, thanks
11:01:37 <Traveler0> i check how many times an element appear in the first place of the pairs and how many times it appears i nthe second
11:02:00 <Jonno_FTW_> and by element you mean?
11:02:02 <Traveler0> if they are equal i continue with the next element else i return false4
11:02:06 <Traveler0> false*
11:02:23 <Traveler0> as i have pairs of integers
11:02:26 <sshc> I'm looking at the documentaition for System.Console.GetOpt, but it doesn't mention what I should pass as the second string for "ReqArg (String -> a) String"
11:02:31 <thoughtpolice> Hiato: it's cabalized, I haven't uploaded it to hackage yet
11:02:37 <Traveler0> the list are like [(1,2),(3,4),.....
11:02:44 <monochrom> Jonno_FTW_:  main = (fmap (map (\x->uncurry (++) $ (fst (splitAt ((length x)`div`2) x)++"r",snd (splitAt ((length x)`div`2) x))) ) $ fmap words $ readFile "dictionary.txt") >>= mapM_ print
11:02:50 <knobo> Anyone who could walk me through monad transformers?
11:03:04 <Jonno_FTW_> if 2 heads at any point are equal you return false?
11:03:16 <Traveler0> no no
11:03:29 <Traveler0> if for example 1 in the example i gave you
11:03:40 <Traveler0> appears more times in the first place as in the second
11:03:49 <Traveler0> then false
11:04:34 <Hiato> thoughtpolice: looks great, gonna start bashing around soon as i finish my 6.10.4 upgrade :) Thanks
11:04:57 <Traveler0> but my main worry is to understand why i get runtime exception
11:05:21 <thoughtpolice> Hiato: it looks like it could seriously be improved by using something like dyre. maybe sometime soon I can get back to it. feel free to send me patches like I said and I can merge them :)
11:05:52 <Hiato> thoughtpolice: Cool, will do :) Yeah, I'll mess around with the libs, see what I can do :)
11:06:58 <aavogt> [13:27:09]       aavogt | :t map (\x -> let (b,n) = splitAt (length x `div`2) x in b++"r"++n) . words -- did you see this Jonno_FTW_?
11:07:39 <Jonno_FTW_> yes
11:07:59 <Hiato> thoughtpolice: wow, you've (or they've) put quite a lot into this already. Foreground/background stuff. Nice
11:12:09 <Traveler0> i think that my confusion exists because i have misunderstood otherwise. If i have 3 guardians and the last one is otherwise = ...... how is an exception possible? it occured while haskell tried to evaluate something for the previous boolean expressions of the guardiansand failed?
11:12:52 <knobo> Where do I import the MaybeT monad from?
11:13:00 <knobo> Is it included in Monad module?
11:13:07 <Traveler0> can you give me a small example with otherwise that fails during runtime?
11:13:42 <Jonno_FTW_> are you using guards or pattern matching?
11:13:53 <jmcarthur> Traveler0: foo x | undefined = "wut" ; | otherwise = "wat"
11:15:08 <monochrom> f [] | 0==0 = "good"
11:15:25 <Traveler0> i have something like: | (fst x == fst y) = func .......
11:16:01 <Ke> btw has any work been done on crosscompiling haskell
11:16:12 <monochrom> g x | case x of 0 -> True = "fun"
11:16:14 <doserj> knobo: Control.Monad.Maybe (after installing the MaybeT package)
11:16:37 <Ke> could require C crosscompiler but still should be doable
11:17:10 <Phyx-> you know.. MW2 is taking alot of time away from my coding
11:17:12 <Phyx-> and studies
11:18:06 <knobo> doserj: Installing MaybeT? what does it mean?
11:18:25 <doserj> knobo: cabal install MaybeT
11:18:50 <Eduard_Munteanu> Any idea on how to implement a list that contains elements different types? I want something like [ "Foo", 3, "Bar" ]
11:19:16 <monochrom> [Left "Foo", Right 3, Left "Bar"]
11:19:42 <benmachine> Eduard_Munteanu: the question is, what would you do with such a list?
11:19:46 <Eduard_Munteanu> monochrom, so a data type and the list spelled as [Type]?
11:19:55 <monochrom> Alternatively design your own datatype that includes all the different types.
11:20:06 <knobo> I don't have cabal installed
11:20:18 <doserj> Eduard_Munteanu: http://www.haskell.org/haskellwiki/Heterogenous_collections
11:20:26 <Eduard_Munteanu> benmachine, are you familiar with Gtk2Hs? I'm trying to connect a model store to a tree view by simply naming columns.
11:21:19 <benmachine> I have heard of gtk2hs but I don't know anything about using it
11:21:22 <benmachine> so I'll leave you to it
11:21:22 <Eduard_Munteanu> benmachine, I simply want to do initList list ["Column 1", "Column 2"] without typing stuff like cellLayoutSetAttributes col renderer store $ \row -> [ cellText := name row ]
11:21:32 <Eduard_Munteanu> doserj, hm, lemme see...
11:22:31 <Cale> Eduard_Munteanu: Why does this require heterogeneous lists?
11:23:04 <Eduard_Munteanu> Cale, we talked earlier, do you remember?
11:23:21 <Cale> Eduard_Munteanu: Yes, I don't understand why you need a heterogeneous list.
11:24:28 <monochrom> Does Gtk2Hs accept such a list as parameter from you?
11:24:36 <Eduard_Munteanu> Cale, I want to be able to write something like listInit listProd prodStore [ "Name", "Contact" ], and that function to associate columns from the store with cells in the list 1-to-1.
11:25:24 <Eduard_Munteanu> Cale, if I use a heterogenous list, I can pass a list containing all columns (strings, ints) without special handling.
11:25:29 <Jonno_FTW_> http://www.haskell.org/haskellwiki/One_week_using_Haskell
11:25:35 <Jonno_FTW_> wat?
11:25:49 <Cale> no idea
11:25:54 <Cale> Eduard_Munteanu: hmm
11:26:01 <Hiato> Quick n00b question I'm sure: what's the advantage of using any/all (cond) [lst] as opposed to and/or $ map (cond) [lst]?
11:26:04 <Eduard_Munteanu> monochrom, I want to write that myself, in effect I take that list, mapM on it and do cellLayoutSetAttributes and such
11:26:13 <Cale> Hiato: It's shorter.
11:26:19 <Hiato> heh, ok
11:26:19 <damd> @src all
11:26:20 <lambdabot> all p =  and . map p
11:26:21 <damd> @src any
11:26:22 <lambdabot> any p =  or . map p
11:26:33 <Hiato> lol :P Ok, thanks
11:26:39 <Cale> (and reads more naturally in a lot of circumstances)
11:27:40 <lpsmith> Eduard_Munteanu, what about existential types?
11:27:42 <mmaruseacph2> solved the problem with the libs
11:27:58 <mmaruseacph2> i've copied the missing ones to a local dir and used an export
11:28:01 <mmaruseacph2> thanks
11:28:23 <Traveler3> can someone help me in private please i dont think it will take more than 10 minites
11:28:23 <lpsmith> Eduard_Munteanu, or defining your own discriminated union type using "data"
11:28:33 <Eduard_Munteanu> lpsmith, I'm looking at it.
11:28:39 <Eduard_Munteanu> lpsmith, yeah, that could do it.
11:29:34 <Eduard_Munteanu> Cale, this is my code so far: http://pastebin.org/74469
11:29:37 <monochrom> existential type still does not let you write f [1, True, "three"]. At best you have to write like f [g 1, g True, g "three"]
11:29:56 <lpsmith> monochrom:  very true :)
11:29:58 <Eduard_Munteanu> Cale, I want to use the list setup function for other tree views as well (possibly with different structure)
11:30:46 <lpsmith> monochrom,  out of curiousity, how did you type your  and  characters?
11:31:04 <monochrom> Do you want the true story or the false story?
11:31:04 <Eduard_Munteanu> lpsmith, I'm thinking that's nice. If I do something like data Field = Str String | Intg Int
11:31:09 <sproingie> lpsmith: compose and hit < or > twice
11:31:39 <Eduard_Munteanu> Cale, otherwise it'd be copy-paste hell for every list/table I use in my app. :)
11:32:33 <Eduard_Munteanu> And I don't want to write C++ code :P
11:33:08 <monochrom> I guess the true story. "character palette" panel applet of gnome.
11:33:27 <Hiato> Anoter quickie: is there a non-trivial way to do a filter on an infinite list without using takewhile? Eg: sum of squares <100: sum $ takeWhile (<100) $ map (^2) [1..]... wonder if that made sense
11:34:06 <lpsmith> heh,  what would've the false story been?  :-)
11:34:14 <koeien37> that is a nice way to write it
11:34:32 <ramses_> Hiato: you must stop after 100 and that's what you express with the takeWhile, why would you want to write if differently
11:34:36 <monochrom> launch one of those programs that show the full unicode set.
11:35:11 <lpsmith> Eduard_Munteanu, you can write data Field = Str String | Int Int
11:35:34 <lpsmith> Syntactically,  data constructors and type constructors are distinct,  so you can reuse names between the two
11:35:40 <Hiato> ramses_: just out of curiosity, like say if there's a way to catch when filter fails and abor evaluation, which IS takewhile (I know), but I was just interested in Haskell syntax in this case
11:35:47 <Cale> Eduard_Munteanu: Isn't everything a String in the end anyway?
11:35:49 <Eduard_Munteanu> lpsmith, oh, I wasn't sure if Str and Int constructors can overlap with data types.
11:35:55 <aledge> Hiato, I suppose you could use a function with a continuation
11:35:58 <Cale> Eduard_Munteanu: You could just apply show to things first, couldn't you?
11:36:07 <Cale> Or is that inconvenient?
11:36:09 <lpsmith> Eduard_Munteanu, I figured,  so I clarified :-)
11:36:28 <Eduard_Munteanu> Cale, hm, actually I think you're right.
11:36:37 <Hiato> aledge: righyt-o, will do the [g/h]oogle thing with that piece of info
11:36:42 <Hiato> thanks
11:36:58 <tommd> ... no problem?
11:37:01 <Eduard_Munteanu> Cale, I wasn't sure how elegant that would be, but seems the easiest and best way, thanks.
11:37:08 <aledge> Hiato, but the only reason (most likely)to do that would be pedantic
11:37:12 <Cale> I guess that when you select things, it might be nice to get real values out, but then... how is it going to display them if it doesn't know what string to show?
11:37:16 <aledge> Hiato, not necessarily a bad thing
11:37:42 <Hiato> aledge: heh, what can I say? :P Naah, just wanna get a good understanding of this language though
11:37:55 <Eduard_Munteanu> Cale, yeah, I'd still need to do show. And as for getting real values, I can simply convert (SQLite generally returns a string anyway by default IIRC)
11:38:01 <aledge> Hiato, I haven't really seen a lot of continuation usage in haskell. Not that I'm much of an expert
11:38:19 <Eduard_Munteanu> :t Show
11:38:20 <lambdabot> Not in scope: data constructor `Show'
11:38:25 <Eduard_Munteanu> :t show
11:38:27 <lambdabot> forall a. (Show a) => a -> String
11:38:31 <aledge> but there is a continuation monad, i believe
11:38:32 <monochrom> Use Template Haskell.
11:38:39 <Hiato> Right, well unfortunately I have not the faintest what that's all about, but I'm busy (re)searching as we speak
11:38:43 <aledge> haha
11:38:44 <aledge> ok
11:39:23 <Cale> Hiato: Of course, if at some point there won't be any more elements of filter p xs, there's no way to tell in general that there won't without just computing forever.
11:40:34 <Cale> In cases where you know that xs is ordered, and you have a bound on the elements for which the predicate will succeed, you can apply takeWhile beforehand to cut the list off.
11:40:55 <Hiato> Right, I guess, but I'm looking at a more 'abort on fail' set-up Cale, but I guess that's a bad way of recursing things unless you can cathc that exception (if you can make False raise one?)
11:41:32 <EvanR-work> Hiato: arent exceptions only for handling errors, that is, exceptional situations, not routine computations
11:41:56 <Cale> Well, you can't catch exceptions from pure code by design, because they would destroy referential transparency.
11:42:02 <monochrom> everyone draws that line differently.
11:42:12 <Hiato> right, but I'm sure that they can be abused :P
11:42:21 <Eduard_Munteanu> Cale, yay, it works.
11:42:40 <ben0x539> I forget, how would it destroy referential transparency again?
11:43:17 <sproingie> every computation could potentially return a value or fail
11:43:26 <chrisdone> it's quite theraputic to have all the import statements in your file to be either imported qualified or restricted to specified symbols. no namespace pollution
11:43:35 <sproingie> of course if you account for that in the type then you're fine
11:43:59 <ben0x539> Do I not account for that by virtue of programming in a language with a type system that includes 'undefined'?
11:44:19 <EvanR-work> sproingie: every computation? :S
11:44:32 <Cale> Er, that's not why.
11:44:33 <sproingie> every one that could call something that threw
11:45:16 <Cale> Let's see if I can come up with a good example...
11:45:42 <Cale> You can expose details of evaluation order by catching exceptions.
11:46:18 <monochrom> I restrict to specified symbols, e.g., import Data.List(sort). (Exception: Prelude). This is because there are so many libs now that if I write f = sort . comp you have no idea where sort comes from or where comp comes from. But if I make it clear in the import list, you have good clues.
11:46:20 <sproingie> handling them at all implies an order.  or at least a dependency
11:46:51 <Cale> and then two functions which were otherwise equal, but happened to evaluate their parameters in a different order can behave differently because which exception gets thrown/caught is different
11:47:04 <sproingie> monochrom: i never liked the default *-import behavior of haskell
11:47:15 <zygoloid> Cale: "teaspoon :: a -> Maybe a" doesn't have that problem
11:47:30 <Cale> Right, but teaspoon isn't exactly catch
11:47:32 <zygoloid> if you can't distinguish different _|_s then i think you're still ok on that front
11:47:48 <monochrom> Maybe has the exact problem of nailing one dependency.
11:47:52 <Cale> Though teaspoon still breaks the semantics of Haskell.
11:48:05 <sproingie> i like how perl does it, you have exports that are automatic and exports that are merely allowed
11:48:18 <Cale> It makes errors different from infinite loops
11:48:19 <zygoloid> yeah, but does it violate referential transparency (i'm not sure..)
11:48:38 <Cale> I think not quite.
11:48:59 <Cale> any more information about what happened and it would
11:49:01 <zygoloid> i don't think it does make error denotationally different from loops. you have no guarantee the denotational answer will ever arrive
11:49:03 <opdolio> I thought I had an example of it violating purity.
11:49:20 <opdolio> But not referential transparency.
11:49:27 <Eduard_Munteanu> Um, how do I make some global variables? Sorry, I come from another world.
11:49:27 <Cale> knife :: a -> Either SomeException a  will definitely violate it
11:49:32 <djahandarie> Could anyone link me to a good article on finger trees?
11:49:39 <zygoloid> Cale:  absolutely :)
11:49:54 <djahandarie> Ralf Hinze's paper is a bit... verbose
11:50:01 <Cale> djahandarie: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
11:50:06 <Cale> oh
11:50:22 <Cale> Er, I don't really know of any other reference from that.
11:50:23 <cwraith> Eduard_Munteanu: do you mean global *names*, or do you mean global values that can actually change through the life of the program?
11:50:23 <opdolio> Probably "teaspoon (const undefined 5)".
11:50:24 <Eduard_Munteanu> Say I have x <- blah in main, but I want x to be global, is it possible?
11:50:33 <ben0x539> What is the harm in knowing what error a pure function runs in? :|
11:50:33 <Eduard_Munteanu> cwraith, second, see ^
11:50:35 <monochrom> (1/0 + sqrt(-1)) `catch` (\e -> case e of DivZero -> 0; Unreal -> 1)  could be 0 the first time and 1 the second time.
11:50:37 <djahandarie> Cale, hm, alright thanks. I'll just try to wade through this. >.<
11:50:39 <opdolio> That's Nothing with strict evaluation, and Just 5 with non-strict evaluation.
11:50:46 <ben0x539> into*
11:50:54 <cwraith> Eduard_Munteanu: single assignment, or do you actually plan to mutate it?
11:50:59 <Cale> djahandarie: They've only been around since 2006.
11:51:12 <Eduard_Munteanu> cwraith, it's mutable.
11:51:14 <Cale> djahandarie: It might help to understand monoidally indexed trees separately
11:51:29 <Eduard_Munteanu> cwraith, so it's not something referential or constant.
11:51:39 <Cale> djahandarie: monoidally indexed trees are an obvious idea and I'm surprised that I've never seen them outside of this paper
11:51:43 <cwraith> Eduard_Munteanu: You *could* do it with an IORef, but I'd recommend finding a different solution.  Possibly the state monad?
11:51:54 <EvanR-work> theres also MVar
11:51:58 <Cale> djahandarie: Are you familiar with monoids?
11:52:09 <zygoloid> i guess the biggest property violated by teaspoon is monotonicity
11:52:13 <Eduard_Munteanu> cwraith, hm, will look into it. The other option for me would be passing a data structure from function to function, dunno which is better.
11:52:29 <djahandarie> Cale, yeah. I think I can understand this paper, it'll just take awhile
11:52:32 <cwraith> Eduard_Munteanu: the state monad makes passing that structure around implicit, giving you nicer syntax for it
11:52:45 <EvanR-work> Eduard_Munteanu: one way is to pass it around where you need it until you see a nice way to abstract it away
11:52:52 <Eduard_Munteanu> cwraith, nice, will look at it.
11:53:03 <Eduard_Munteanu> EvanR-work, I see.
11:53:10 <EvanR-work> if you are in the IO monad all the time, IORef works for this purpose
11:53:17 <EvanR-work> but then you are writing c code! ;)
11:53:35 <zygoloid> dolio: teaspoon = const Nothing with strict evaluation :-/
11:53:41 <Eduard_Munteanu> EvanR-work, well, I'm working with Gtk2Hs, which is kinda C-ish
11:53:43 <sproingie> i'm still trying to figure out how to make callbacks work without using IOrefs
11:53:43 <ben0x539> You are writing C code when you spurn IORef in favour of Ptr and malloc and so on
11:54:14 <dolio> Eh?
11:54:32 <zygoloid> dolio: no, wait... i'm confused by your example. strict gives _|_, nonstrict gives Nothing
11:54:32 <dolio> teaspoon 5 = Just 5 regardless of evaluation order.
11:54:43 <zygoloid> const undefined 5 = undefined
11:55:11 <Cale> djahandarie: Basically the idea is that if you want to use balanced trees to speed access of operations on your collection, essentially the most general description of what you're doing is storing summaries of subcollections in the branch nodes of the tree which are combined in some fashion from the summaries on the subtrees
11:55:19 <dolio> The problem is that Sabry's purity is in part independence of evaluation order up to bottoms.
11:55:26 <sunrayser> is there any way to prevent Haskell from putting record selector functions into the global namespace? I'd like to write something like "record.member". I have many record fields with similar role (for example, "name"), and I don't want to prefix every field name like record1Name, record2Name...
11:55:27 <zygoloid> if you swap the args to "teaspoon (const 5 undefined)", strict gives _|_, nonstrict gives Just 5
11:55:37 <dolio> If you lift those bottoms up to Maybes, then you're running afoul of that.
11:55:49 <zygoloid> as usual, strict evaluation can give _|_ where nonstrict evaluation gives non-_|_
11:56:01 <ben0x539> Does allowing seq not already break that?
11:56:02 <Cale> In order that these not change when subtrees are rebalanced, the operation had better be associative, and in order to account for the empty collection, it'll need to have an identity
11:56:24 <Cale> (so a monoid is the perfect sort of structure to use -- you don't need anything more or less than that)
11:56:28 <djahandarie> Cale, ah, I see how monoids fit in then
11:56:29 <djahandarie> Yeha
11:56:32 <dolio> So it's okay if strict evaluation gives _|_ and non-strict evaluation gives non-_|_, but it's not okay if strict evaluation gives Nothing, and non-strict evaluation gives Just x.
11:56:40 * copumpkin used to be a monoidal programmer
11:56:41 <zygoloid> dolio: in a strict evaluation context, teaspoon _|_ = _|_
11:56:42 <dolio> According to that particular definition of purity.
11:56:57 <dolio> Well, teaspoon is supposed to be magic.
11:56:59 <monochrom> sunrayser: None apart from separating out the record types into their own modules.
11:56:59 <zygoloid> (because, with strict evaluation, f _|_ = _|_ independent of f)
11:57:14 <dolio> It'd be an exception to strict evaluation, catching the exception.
11:57:23 <dolio> Presumably.
11:57:25 <sunrayser> monochrom: I was afraid of that, thanks though
11:57:33 <copumpkin> y'all talking about spoon?
11:57:41 <dolio> Yes.
11:58:40 <Cale> djahandarie: So for a search tree, you might store the minimum element of each subtree in the branches. For a sequence with fast indexing, you'd store the sizes of subtrees (under addition).
11:58:48 <monochrom> chinese_teaspoon :: You -> Either SomeException You.  yields exception if you are just a chinese room, yields you if you really understand chinese.
11:58:55 <copumpkin> lol
11:58:56 <Eduard_Munteanu> :t drop
11:58:57 <lambdabot> forall a. Int -> [a] -> [a]
11:59:09 <ben0x539> Where *do* these names come from? Spoon, teaspoon?
11:59:39 <EvanR-work> spoons hold eggs...
11:59:41 <pastah_rhymez> @hayoo spoon
11:59:41 <lambdabot> Unknown command, try @list
11:59:42 <monochrom> Yeah I don't know why people can just talk about those names and pretend they know the full specifications. knife?
11:59:46 <pastah_rhymez> booooo
11:59:59 <Hiato> just going back ages in the convo, I found break, which is roughly close to my idea: sum $ fst $ break (>100) $ map (^2) [1..]. Still not the catch/eval system I would've liked... but hey :P
12:00:10 <zygoloid> dolio: ok, i see what you're saying -- but i still somewhat disagree. in order for teaspoon to exist in a strict language, teaspoon _|_ = _|_. otherwise your language is not strict.
12:01:06 <dolio> There are practically no strict languages, then.
12:01:07 <copumpkin> ben0x539: completely random banter a little while ago between me and mmorrow
12:01:32 <copumpkin> well, pseudorandom ;)
12:01:38 <Cale> monochrom: Sorry, knife is one that I introduced
12:01:50 <Cale> monochrom: knife :: a -> Either SomeException a
12:01:55 <copumpkin> ouch :)
12:01:59 <Cale> monochrom: It catches all exceptions.
12:02:04 <copumpkin> roconnor almost murdered me for mentioning that
12:02:07 <zygoloid> dolio: well, it depends on whether you're imagining teaspoon to be a real function or not i think. if it's language magic then presumably it can have any denotation you want :)
12:02:20 <Cale> Well, knives are sharp and you might cut yourself.
12:02:31 <ben0x539> The spoon package seems to have spoon and teaspoon, why do those only catch some exceptions?
12:02:38 <zygoloid> while we're at it: fork :: a -> a -> a; fork = unamb
12:02:49 <copumpkin> ben0x539: they're what we considered "safe, referentially transparent" exceptions
12:03:05 <copumpkin> as oxymoronic as that may sound
12:03:20 <zygoloid> copumpkin: isn't that dangerous, though? (given that you can have code which produces both a safe and a nonsafe exception, and the runtime could arbitrarily pick one)
12:03:43 <copumpkin> zygoloid: remember that it runs on a pure function, and assuming no unsafePerformIO it's still deterministic
12:03:50 <copumpkin> it just happens to maybe not handle a pattern
12:03:55 <copumpkin> or maybe have an array index out of bounds
12:03:57 <copumpkin> or just calls error
12:04:07 <copumpkin> those things are still in pure code, and could conceivably have been replaced with Maybe
12:04:11 <copumpkin> or Nothing
12:04:13 <monochrom> teaspoon is just as cutting, I argue. Last night I watched Godfather III. An assasin could even use the target's eyeglass frame to kill the target.
12:04:16 <zygoloid> due to imprecise exceptions, it might do that /and/ loop
12:04:18 <copumpkin> that's the kind of thing spoon catches
12:04:34 <copumpkin> zygoloid: how?
12:04:37 <monochrom> Just stuck eyeclass frame into throat main blood trunk.
12:04:37 <zygoloid> and spoon will nondeterministically return or not return depending on which exception happens first
12:04:59 <copumpkin> zygoloid: we catch pattern match failures, error/undefined calls, array bounds exceptions
12:05:07 <zygoloid> copumpkin: error "foo" `seq` infinite_loop `seq` ()
12:05:07 <copumpkin> in pure values
12:06:05 * roconnor pull out a knife
12:06:45 <copumpkin> zygoloid: I guess that one's a painful one, but the main reason it exists is to compensate for not intentionally bad programming
12:06:58 <copumpkin> but things where people use certain kinds of bottoms because they couldn't deal with error handling nicely
12:07:16 <copumpkin> zygoloid: did you follow the discussion on reddit when it was released?
12:07:20 <zygoloid> why does it not catch NoMethodError?
12:07:22 <copumpkin> http://www.reddit.com/r/haskell/comments/acasn/tired_of_functions_that_could_live_in_maybe_but/
12:07:38 <copumpkin> zygoloid: probably because I didn't know what that one did and/or didn't think of it
12:08:00 <monochrom> {-# LANGUAGE NoNoMethodErrorRestriction #-}
12:08:13 <zygoloid> it seems to me that the 'cure' is as bad as the disease here, is all.
12:08:52 <copumpkin> if you've read the discussion and still think so, that's up to you
12:09:05 <copumpkin> I don't like it, but there are many examples of libraries that don't do error handling nicely and you can't necessarily fix it easily
12:09:22 <ben0x539> Why does dcoutts say spoon is not definable within the language? Is unsafePerformIO considered an extension because it is from the FFI?
12:09:37 <copumpkin> ben0x539: yeah, basically
12:09:38 <copumpkin> it's not pure
12:09:43 <copumpkin> or rather it's not monotonic
12:09:50 <thoughtpolice> pretty much
12:09:52 <thoughtpolice> it's not monotonic
12:09:54 <thoughtpolice> yeah
12:09:54 <copumpkin> typically things only decrease in definedness
12:10:02 <copumpkin> this allows you to go the other way
12:12:27 <monochrom> Gosh you people have cool nicks on reddit. god of pumpkins, dolio rules.
12:12:37 <copumpkin> lol
12:12:51 <dolio> I signed up with dolio at first, but forgot the password.
12:13:16 <monochrom> Maybe I should sign up and call myself monochrom understands chinese
12:13:16 <aavogt> polychrom
12:13:28 <copumpkin> monoglot
12:13:31 <copumpkin> oh wait
12:13:32 <copumpkin> :)
12:13:34 <thoughtpolice> ben0x539: i.e., 'x == y', therefore 'f x == f y', if f is a function, and yet with spoon, you can have 'last [0..] = undefined', and yet, 'spoon (last [0..]) /= spoon undefined'
12:13:47 <thoughtpolice> so therefore it can be said spoon is not actually a function.
12:13:49 <ben0x539> I do not understand the use of == on 'undefined'
12:13:51 <thoughtpolice> but it's useful! :)
12:14:01 <Eduard_Munteanu> Yay,         r <- quickQuery' db "SELECT * FROM prod" []
12:14:02 <Eduard_Munteanu>         mapM (listStoreAppend store . drop 1 . map fromSql) r
12:14:08 <ben0x539> > last [0..] == undefined
12:14:12 <lambdabot>   mueval-core: Time limit exceeded
12:14:15 <Eduard_Munteanu> Me wonders how much would that have taken to write in C(++).
12:14:26 <roconnor> > undefined
12:14:27 <lambdabot>   * Exception: Prelude.undefined
12:14:28 <thoughtpolice> ben0x539: for all practical purposes, the last element of the infinite list [0..] is undefined
12:14:34 <roconnor> > last [0..]
12:14:38 <lambdabot>   mueval-core: Time limit exceeded
12:14:41 <monochrom> Take == to mean semantic equal, not Eq ==.
12:14:42 <roconnor> dont' look the same to me!
12:14:44 <thoughtpolice> they have the same semantics; that is, they diverge
12:14:48 <aavogt> > maxBound :: Int
12:14:48 <ben0x539> So they are equal?
12:14:49 <lambdabot>   9223372036854775807
12:14:52 <roconnor> undefined does not diverge
12:15:04 <roconnor> undefined crashes
12:15:08 <zygoloid> copumpkin: copumpkin ok, i've read the discussion and i still think so :)
12:15:12 <Eduard_Munteanu> Why not _|_ to catch misuse?
12:15:14 <thoughtpolice> yeah, that's a more correct way to say it
12:15:42 <ben0x539> So some bottoms crash and some diverge?
12:15:49 <jmcarthur> crashing is just the runtime proving divergence
12:16:03 <Eduard_Munteanu> ben0x539, um, I think it's not bottom in the real 'last', therefore diverges.
12:16:06 <thoughtpolice> ben0x539: they're semantically equivalent, the result is simply undefined.
12:16:07 <roconnor> no, loop exception is the runtime proving divergence
12:16:10 <copumpkin> zygoloid: it just boils down to different weightings of criteria, I guess :) as I said, I don't like it, but I do think it's useful, and it comes with fairly heavy warnings saying "ZOMG DO NOT USE THIS AS A REPLACEMENT FOR ERROR HANDLING. USE THIS FOR EXISTING FUNCTIONS THAT DON'T DO ERRORS NICELY"
12:16:28 <roconnor> thoughtpolice: who says they are semantically equivalent?
12:16:29 <thoughtpolice> copumpkin: yes, while spoon may not be a 'function', it is useful
12:16:41 <jmcarthur> roconnor: it may be accidental rather then intentional, but it's still proving divergence
12:17:06 <zygoloid> copumpkin: i don't like that it introduces a new level of _|_ to the denotational semantics, and then fails to be a function even in that new semantics
12:17:10 <roconnor> jmcarthur: who says they are semantically equivalent?
12:17:10 <monochrom> Now this really turns into semantics...
12:17:37 <jmcarthur> roconnor: they aren't, operationally
12:17:46 <jmcarthur> but there are other kinds of semantics
12:17:52 <zygoloid> i'd much rather we said that teaspoon _|_ = Nothing for /all/ _|_s, but (as currently) we cannot in general give an upper bound on the runtime to produce that Nothing
12:17:57 <roconnor> who says they are dentoationally equivalent?
12:18:08 <jmcarthur> roconnor: doesn't the spec say that?
12:18:10 <zygoloid> (and then we imagined that teaspoon tries to prove nontermination in the background even though we know it doesn't)
12:18:13 <copumpkin> zygoloid: that adds other issues, as I'm sure roconnor would like to list ;)
12:18:13 <roconnor> does it?
12:18:18 <jmcarthur> i don't know
12:18:23 <monochrom> @quote monochrom settle
12:18:23 <lambdabot> No quotes match. Where did you learn to type?
12:18:32 <monochrom> @quote monochrom debates
12:18:33 <lambdabot> No quotes match.
12:18:42 <monochrom> @quote monochrom polymorphic
12:18:43 <lambdabot> No quotes match. It can only be attributed to human error.
12:18:43 <Eduard_Munteanu> Is there no way to find if a list is infinite at runtime?
12:18:54 <monochrom> @quote monochrom pointless
12:18:55 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
12:19:00 <monochrom> Yikes, it's lost.
12:19:08 <Eduard_Munteanu> monochrom, pointfree
12:19:19 <Eduard_Munteanu> Ah, nvm.
12:19:26 <monochrom> No, this one: all pointless debates can be settled by going polymorphic
12:19:35 <Eduard_Munteanu> Heh.
12:19:35 <jmcarthur> roconnor: Errors during expression evaluation, denoted by _|_, are indistinguishable by a Haskell program from non-termination.
12:19:40 <jmcarthur> roconnor: section 3.1
12:19:42 <roconnor> zygoloid: the loop exception (which is proved non termination) is specifically not caught by this procedure.  That would cause trouble.
12:19:56 <roconnor> jmcarthur: thanks
12:20:04 <Eduard_Munteanu> Bah, non-totality.
12:20:12 <zygoloid> roconnor: how? i saw your comment but couldn't fathom what was going on
12:20:33 <copumpkin> Eduard_Munteanu: depends
12:20:52 <copumpkin> Eduard_Munteanu: you can catch some infinite lists (that is, the circular ones) by going impure
12:20:57 <copumpkin> but in general, no
12:21:19 <Eduard_Munteanu> copumpkin, yeah, I think there are trivial cases where you can do it.
12:21:32 <copumpkin> the output of repeat and cycle come to mind
12:21:38 <Eduard_Munteanu> Or [1..]
12:21:45 <roconnor> zygoloid: well fix depends on functions being monotonic on the definability lattice for fixpoints to exist.  If spoon worked on all bottoms then you could write such non-monotinic functions; however.
12:21:46 <monochrom> > let x=x in x
12:21:50 <lambdabot>   mueval-core: Time limit exceeded
12:21:52 <copumpkin> Eduard_Munteanu: even that can't be determined easily
12:21:55 <monochrom> Oh well
12:22:21 <Eduard_Munteanu> copumpkin, I see.
12:22:29 <roconnor> zygoloid: however spoon only catchs some bottoms (those that could have been Maybe) and despite what the H98 report section 3.1 says, this causes no problems (that I'm aware of)
12:22:51 <zygoloid> roconnor: its denotation is undefined. that i think is a problem.
12:23:07 <zygoloid> and due to imprecise exceptions it's not possible to give it a precise denotation
12:23:23 <roconnor> zygoloid: what's denotation is undefined?
12:23:27 <ben0x539> Who of you madpeople is '808140' on reddit again?
12:23:31 <jmcarthur> my understanding is that spoon is nothing more than an implementation-dependent hack to work around certain API flaws in certain libraries, nothing more
12:23:33 <zygoloid> roconnor: teaspoon's
12:23:38 <Eduard_Munteanu> I think I was right in going Haskell, I might finish this project by morning.
12:23:41 <monochrom> When the runtime detects divergence (by whatever dumb or smart but sound heuristic it uses), it can offer you: (a)bort, (i)gnorance is bliss, (t)hrow a party
12:23:45 <copumpkin> jmcarthur: exactly! thanks :P
12:23:53 <zygoloid> roconnor: even if you augment the denotational semantics to have two levels of _|_
12:24:02 <roconnor> zygoloid: in an alternative semantics of Haskell, with null elements as well as bottom elements, teaspoon is well defined.
12:24:23 <zygoloid> roconnor: the trouble is, we don't live in that world. imprecise exceptions smooshes together the two sorts of _|_
12:24:23 <roconnor> and even monotonic
12:24:36 <roconnor> zygoloid: what are imprecise exceptions?
12:25:05 <zygoloid> roconnor: basically: that pure code generates a set of all possible exceptions which could be generated from it, and the runtime nondeterministically picks one
12:25:31 <rfh> http://aperiodic.net/phil/scala/s-99/p07.scala
12:25:34 <roconnor> zygoloid: yes, but spoon or teaspoon or whatever it is called only return Maybe, which is a commutative monad
12:25:43 <monochrom> Control.Exception and Control.OldException are about imprecise asynchronous exceptions.
12:25:43 <rfh> how would you write this in haskell
12:25:52 <roconnor> zygoloid: so it doesn't matter which exception is generated
12:26:08 <copumpkin> roconnor: he's talking about nontermination in one side and a caught exception on the other
12:26:21 <copumpkin> I thought we'd discussed that case last time we went over all this but couldn't think what to do about it
12:26:36 <zygoloid> roconnor: yes it does. "teaspoon (error "foo" `seq` someExceptionTeaspoonDoesntCatch `seq` ())" has two possible denotations
12:26:55 <roconnor> zygoloid: only one denotation: null.
12:27:05 <zygoloid> no, two, also someExceptionTeaspoonDoesntCatch
12:27:23 <roconnor> ah
12:27:31 <roconnor> well teaspoon should catch it.
12:27:32 <Saizan_> roconnor: when you're strict in two values that throw exceptions, there's no guarantee on which one gets actually thrown
12:27:48 <zygoloid> roconnor: that was my point: it must catch all exceptions or the denotational semantics can't work
12:27:50 <copumpkin> yeah, that's a problem
12:28:08 <monochrom> "add more wheels"
12:28:15 <roconnor> zygoloid: teaspoon doesn't catch all user exceptions?
12:28:27 <Saizan_> even it if catches all of them, with the current catch it's non-deterministic which one you'll get
12:28:46 <zygoloid> roconnor: it doesn't catch NoMethodError, at least
12:28:48 <roconnor> Saizan_: it doesn't matter which is caught.  All will return nothing.
12:28:49 <copumpkin> Saizan_: doesn't matter, because it just gets flattened ot Nothing
12:28:55 <roconnor> zygoloid: it should.
12:29:09 <zygoloid> roconnor: and in any case, if someExceptionTeaspoonDoesntCatch = fix id, then you're hosed
12:29:24 <roconnor> zygoloid: that is never the case
12:29:28 <monochrom> Nondeterminism is bliss.
12:29:29 <copumpkin> it doesn't, but you're welcome to reupload it with additional user exceptions :)
12:29:37 <zygoloid> roconnor: how do you mean, that is never the case?
12:29:48 <zygoloid> teaspoon (error "foo" `seq` fix id `seq` 42)
12:29:58 <roconnor> zygoloid: loop exceptions cannot be thrown programetically.
12:30:09 <zygoloid> roconnor: they can be thrown by pure code, that is all that is needed
12:30:11 <roconnor> or shouldn't be allowed to be thrown programetically.
12:30:30 <roconnor> oh I see what you are saying
12:30:34 <zygoloid> and it's not the loop exception which matters here, it's NULL versus _|_
12:30:51 <roconnor> undefined `seq` fix id `seq` ()
12:30:53 <zygoloid> you want to distinguish NULL from _|_ but the runtime doesn't care
12:31:05 <roconnor> you are saying this could be either an undefined expection or a loop exception?
12:31:16 <zygoloid> yes, or nontermination
12:31:21 <roconnor> really?
12:31:24 <zygoloid> yes
12:31:27 <roconnor> doesn't seq say that the first one is done first
12:31:32 <dolio> No.
12:31:35 <zygoloid> not in haskell'98
12:31:41 <zygoloid> that's why we have pseq
12:31:51 <roconnor> what does seq say?
12:31:57 <zygoloid> seq is left-strict.
12:31:59 <dolio> It's strict in both its arguments.
12:32:30 <zygoloid> and indeed any binary function which the strictness analyzer determined to be strict in both arguments could introduce this problem
12:32:34 <jmcarthur> spoon violates haskell's specification. that's okay. it serves a purpose, and i don't think anybody is encouraging anybody else to use it to try solving the halting problem
12:32:45 <copumpkin> :)
12:32:59 <copumpkin> two wrongs make a right!
12:33:00 <Saizan_> you could also write "case undefined of () -> case fix id of () -> ();" and have the same effect seq is having here
12:33:00 <ben0x539> How does it violate its specification while being defined in terms of haskell :|
12:33:02 <dolio> I thought I explained all this back when the library was first announced. :)
12:33:17 <jmcarthur> ben0x539: is it fully defined in terms of the haskell specification?
12:33:20 <sproingie> unsafe* can violate you in all kinds of creative ways
12:33:25 <copumpkin> ben0x539: we pinch our nose and like to pretend that GHC stuff isn't haskell
12:33:28 <jmcarthur> surely it uses unsafePerformIO somewhere
12:33:30 <ben0x539> This is as crazy as C letting you do all sorts of pointer casts on memory that actually belongs to you and then complaining about undefined behaviour!
12:33:32 <roconnor> copumpkin: zygoloid puts forth a powerful argument
12:33:48 <ben0x539> copumpkin: But the only ghc stuff involved is that type signature for lambda parameters extension, no?
12:33:53 <zygoloid> my perspective was simply that: the simpler specification for teaspoon would have been no worse, and would have been better (it would catch NoMethod for instance)
12:33:53 <sproingie> what is pseq?
12:33:57 <copumpkin> roconnor: I've already conceded to it, yet I don't think that undermines the utility of the library
12:33:58 <monochrom> I read dons's paper on hs-plugins. It says plugin state can be associated with loader instead of (let's say) main program. It doesn't exemplify or instruct how to. Do you happen to know how to?
12:33:59 <sproingie> :t pseq
12:34:00 <lambdabot> forall a b. a -> b -> b
12:34:15 <zygoloid> sproingie: it evaluates its LHS, then returns its rhs. note "then"
12:34:24 <roconnor> zygoloid: by simpler spec, you mean one that catches all exceptions?
12:34:28 <zygoloid> roconnor: right.
12:34:30 <jmcarthur> sproingie: pseq is like seq with a deterministic evaluation order
12:34:35 <sproingie> zygoloid: wait, i thought that's what seq did
12:34:36 <copumpkin> regular seq could evaluate its RHS, then its LHS, then return the RHS
12:34:50 <jmcarthur> sproingie: seq only says the first argument is strict
12:34:51 <copumpkin> it's a misleading name
12:35:26 <Saizan_> pseq appears lazy in its left argument to the optimizer :)
12:35:29 <zygoloid> some people say this seq issue is a bug (notably, users). others say it's a feature (notably, compiler authors)
12:35:40 <dolio> Right argument.
12:35:45 <Saizan_> left.
12:35:48 <roconnor> can we repeat the definitions of seq and pseq again?
12:35:49 <copumpkin> middle.
12:35:53 <zygoloid> bottom!
12:35:56 <sproingie> charm
12:35:59 <copumpkin> :(
12:36:12 <dolio> Am I mixing up my left and right?
12:36:28 <monochrom> left wing, right wing
12:36:29 <Saizan_> uh
12:36:40 <dolio> x `pseq` y has x as a left argument, right?
12:36:46 <roconnor> in GHC does (error1 `seq` error2) ever return error2?
12:36:53 <monochrom> correct
12:36:57 <Saizan_> roconnor: it can
12:37:06 <roconnor> wow
12:37:10 <copumpkin> pseq  x y = x `seq` lazy y
12:37:11 <jmcarthur> roconnor: the optimizer is free to do whatever order it wants
12:37:21 <copumpkin> seq is a primitive
12:37:25 <roconnor> what is lazy?
12:37:25 <copumpkin> so is lazy :)
12:37:29 <jmcarthur> roconnor: as long as forcing the second argument also forces the first
12:37:41 <copumpkin> it tells the compiler to be lazier than it normally would be
12:37:58 <monochrom> "lazy" is a trick to tell the strictness analyzer "don't look".
12:38:08 <thoughtpolice> how does i lazy?
12:38:12 <roconnor> does this mean that seq cannot be used to control memory use as it is often used to do?
12:38:12 <sproingie> so seq is not really seq, it just means "evaluate both"
12:38:21 <Saizan_> dolio: right, it was the right argument, sorry :)
12:38:36 <Heffalump> does GHC actually take advantage of that latitude?
12:38:38 <dolio> I'm just glad I don't have brain damage. :)
12:38:43 <roconnor> @src foldl'
12:38:43 <lambdabot> foldl' f a []     = a
12:38:44 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:38:47 <jmcarthur> roconnor: it is encouraged to use pseq instead of seq when you must guarantee that the first argument is evaluated first. many people do indeed do it wrong
12:38:49 * Saizan_ checks if he does
12:38:58 <roconnor> so foldl' should use pseq?
12:39:30 <jmcarthur> is foldl' guarateed to evaluate the list in order?
12:39:32 <Saizan_> roconnor: just being strict makes the optimizer do the right thing there
12:39:43 <Phyx-> what's pseq?
12:39:43 <copumpkin> Saizan_: is that by accident?
12:39:55 <copumpkin> Phyx-: seq done right
12:40:00 <Phyx-> LOL
12:40:05 <Phyx-> :t pset
12:40:06 <lambdabot> Not in scope: `pset'
12:40:08 <Phyx-> :t pseq
12:40:09 <lambdabot> forall a b. a -> b -> b
12:40:13 <Phyx-> hmm
12:40:16 <Phyx-> @hoogle pseq
12:40:17 <lambdabot> Control.Parallel pseq :: a -> b -> b
12:40:26 <dolio> If the optimizer can tell it's strict, it will keep the accumulator evaluated. That's not an accident, just good optimization.
12:40:40 <sproingie> odd name since pseq would seem to be very much not parallel
12:41:10 <copumpkin> sproingie: well, it's needed for parallel things
12:41:18 <copumpkin> even it itself is not parallel :)
12:41:22 <roconnor> seq is stupid
12:41:25 <copumpkin> it itself
12:41:30 <sproingie> i guess seq' would look nasty infix
12:41:33 * copumpkin speak english good
12:41:36 <sproingie> `seq'`
12:41:44 <copumpkin> `qes`
12:41:54 <copumpkin> how about et :: a -> b -> b
12:42:45 <monochrom> What does "et" suggest?
12:42:50 <copumpkin> and! :P
12:42:58 <dolio> Using pseq in foldl' might confuse the optimizer by marking the recursive call lazy.
12:43:02 <monochrom> That sounds symmetric to me.
12:43:08 <Saizan_> Heffalump: the imprecise exceptions paper argues that this property is exploited when rearranging code in optimizations, and i remember a ticket open from the darcs dev which were using pure expcetions to report errors to the user
12:43:16 <Saizan_> Heffalump: and the wrong error was reported
12:43:16 <monochrom> cum :: a -> b -> b  -- more choices!
12:43:28 <Phyx-> WTF
12:43:35 <monochrom> FTW
12:43:49 <Phyx-> it's a very random thing to see after just switching to this window
12:44:13 <dolio> Obviously it's the Latin cum.
12:44:17 <copumpkin> ante :: a -> Accusative b -> b
12:44:25 <jmcarthur> o_O
12:44:26 <aledge> haha
12:44:33 <Phyx-> dolio: i would hope so
12:44:38 <Peaker> I'd prefer "force1"
12:44:44 <Peaker> (1 level deep)
12:44:49 <monochrom> cum Santus Spiritus...
12:45:14 <aledge> copumpkin, ante :: (Accusative a) -> a -> b
12:45:15 <aledge> no?
12:45:18 <Saizan_> shallowDeepSeq
12:45:18 <aledge> hehe
12:45:55 <copumpkin> aledge: where would you get a b from? I was thinking x `ante` Accusative y gives y
12:46:14 <copumpkin> it's more of a ante :: (Accusative b) => a -> b -> b
12:46:36 <aledge> I was just thinking ante x
12:46:42 <aledge> gives a new phrase
12:47:04 <aledge> but I think x `ante` y makes more sense
12:47:08 <copumpkin> depending on how you look at it it could be post
12:47:17 <jmcarthur> p`enta`x
12:47:19 <copumpkin> still takes the accusative though
12:47:25 <aledge> absolutely
12:47:27 <copumpkin> :)
12:47:59 <zygoloid> i like "andThen = pseq"
12:48:24 <monochrom> butFirst = flip pseq
12:48:34 <copumpkin> @let first_butDon'tForgetTo = pseq
12:48:35 <lambdabot>  Defined.
12:48:46 <copumpkin> > 5 `first_butDon'tForgetTo` ()
12:48:47 <lambdabot>   ()
12:48:51 <Saizan_> beforeOrLater = seq
12:49:09 <jmcarthur> alsoForces = flip seq
12:50:38 <monochrom> without further ado
12:52:30 <monochrom> I read dons's paper on hs-plugins. It says plugin state can be associated with loader instead of (let's say) main program. It doesn't exemplify or instruct how to. Do you happen to know how to?
12:55:47 <Twey> Isn't hs-plugins deprecated?
12:56:06 <kmc_> i thought so
12:56:12 <kmc_> you can use hint for some of the same things
12:56:56 <monochrom> hs-plugins or plugins matches better to my desire
12:57:29 <monochrom> I really want to runtime-load modules.
12:57:35 <Twey> I thought it was replaced by GHC-as-a-library
12:57:49 <kmc_> i think plugins is hs-plugins.  there's no package hs-plugins on hackage
12:57:55 <monochrom> Also even if I use hint, my question still applies.
12:59:31 <lantti> Hi people! Can someone help me bit... I need to get rid of some previously installed version of ghc but I don't know all the stuff that I need to delete.
12:59:52 <lantti> Is there a list of things ghc changes when it installs itself?
13:00:02 <Twey> lantti: Use your package manager
13:00:15 <lantti> This one was compiled by hand
13:01:07 <Twey> make uninstall
13:01:44 <lantti> I'll try.
13:02:05 <lantti> Just that I don't have the sources anymore...
13:03:43 <blackh> lantti: It creates stuff in /usr/local/bin /usr/local/lib/ghc-XXX, /usr/local/share/doc and /usr/local/share/man/man1
13:03:47 <whoppix> lantti, If you download the same version again and take a look in its manifest file, you should see which files to delete.
13:04:02 <blackh> lantti: Under bin there's a whole lot of stuff, namely: ghc                  ghci                  ghc-pkg                  haddock  hpc     runghc
13:04:02 <blackh> ghc-6.12.0.20091121  ghci-6.12.0.20091121  ghc-pkg-6.12.0.20091121  hp2ps    hsc2hs  runhaskell
13:04:25 <blackh> lantti: I know all this because I installed mine under a prefix
13:04:53 <blackh> lantti: You might also want to delete $HOME/.cabal and $HOME/.ghc
13:05:21 <orbitz> this is bad right /tmp/ghc30337_0/ghc30337_0.s: Assembler messages:
13:05:41 <copumpkin> orbitz: doing 6.10 stuff on mac os 10.6?
13:06:10 <orbitz>  2.6.18-164.10.1.el5 #1 SMP Wed Dec 30 18:35:28 EST 2009 x86_64 x86_64 x86_64 GNU/Linux
13:06:49 <copumpkin> oh
13:06:55 <copumpkin> dunno :) I'd ask in GHC
13:06:57 <copumpkin> #ghc that is
13:06:58 <lunabot>  luna: Not in scope: `ghc'
13:07:06 <orbitz> Error: suffix or operands invalid for `push'
13:08:17 <orbitz> can't wait to get a laptop here so i can have root
13:09:23 <Eduard_Munteanu> What's going on with hpaste.org?
13:10:58 <lantti> blackh: Hmh. Nothing. I had got rid of those ones already. The only way that I know that somethings wrong is actually that sometimes compiling complains about missing 6.13 files like "/usr/local/lib/ghc-6.13.20090929/hsc2hs: not found
13:11:34 <lantti> So somewhere it's still written that I had 6.13....
13:12:11 <lantti> I can get around that, but still it's a bit annoying.
13:15:10 <chrisdone> heh, I'm using formlets to generate IO actions. whodduthinkit
13:15:43 <opqdonut> formlets?
13:15:51 <aavogt> @hackage formlets
13:15:51 <lambdabot> http://hackage.haskell.org/package/formlets
13:16:11 <opqdonut> ah
13:16:56 <chrisdone> it assumes that you're going to generate markup with it, but I see no reason why you can't generate other composable things like functions and actions =)
13:17:41 <aavogt> formlets are less flexible... what do you win in terms of composability?
13:19:42 <chrisdone> well, automatic generation of unique identifiers  and validation
13:20:48 <EvanR-work> how about client side haskell
13:20:50 <chrisdone> as regards "winning", I don't know in what competition that is
13:20:56 <EvanR-work> ... nahhh *goes back to work*
13:21:46 <blackh> lantti: Check your bin directories... hsc2hs comes from a bin directory, and it looks like it's finding the wrapper script but not the guts of it.
13:21:55 <blackh> lantti: try 'which hsc2hs'
13:22:04 <blackh> lantti: cabal uses the system PATH to find things
13:22:27 <aavogt> chrisdone: as opposed to using a state monad (with MonadIO instance) for generating unique identifiers
13:25:13 <lantti> blackh: Aha. Yes, there it was still in local/bin. I seem to have missed it in the previous run. Thanks a lot!
13:25:47 <blackh> lantti: Great!
13:29:43 * hackagebot upload: http-wget 0.4.1 - Provide a simple HTTP client interface by wrapping the wget  command line tool. (MichaelSnoyman)
13:30:32 <chrisdone> aavogt: and what of validation?
13:32:57 <Gracenotes> too bad there's not a semantic difference for "bindings" in terms of what uses FFI and what just starts processes
13:33:54 <Gracenotes> although depending on whether the bound thing is a library or application... but it can be both.
13:34:47 <aavogt> chrisdone: user-defined validation functions don't have access to the unique name supply in my experience
13:35:19 <aavogt> but agreed, restricting to applicative might be necessary to propagate validation stuff correctly
13:35:44 * hackagebot upload: haskell-src-exts 1.6.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
13:37:50 <patch-tag> Did I just find a bug in System.Posix?
13:37:52 <patch-tag> liftM length System.Posix.getAllGroupEntries
13:37:53 <patch-tag> Loading package unix-2.3.2.0 ... linking ... done.
13:37:53 <patch-tag> 1819
13:37:53 <patch-tag> Prelude System.Posix Control.Monad> liftM length System.Posix.getAllGroupEntries
13:37:56 <patch-tag> 0
13:38:31 <patch-tag> the first call shows the numbe expected, subsequent calls show 0. Incidentally, this behavior is not shared by System.Posix.getAllUserEntries
13:39:28 <patch-tag> for The Glorious Glasgow Haskell Compilation System, version 6.10.3
13:41:50 <lispy> patch-tag: hmm....I see the same behavior
13:42:40 <patch-tag> I'll ping haskell cafe and libraries list.
13:43:47 <etpace> Hmm, if I have two binary search trees t1 and t2, and t1 is superseeded by t2 if for each k,v in t1 its also in t2, any ideas on an algorithm to check if t1 is superseeded by t2 in O(n1 + n2)?
13:44:42 <lispy> patch-tag: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/unix/src/System-Posix-User.html#getAllGroupEntries
13:44:46 <Cale> patch-tag: I'm seeing the same behaviour in 6.10.4
13:44:58 <lispy> -- | @getAllGroupEntries@ returns all group entries on the system by --   repeatedly calling @getgrent@
13:45:12 <lispy> I wonder if that description holds the key
13:45:34 <lispy> the 'getgrent' function stops returning things so subsequent calls return nothing also
13:45:38 <Cale> Well, getAllUserEntries does the same thing with getpwent
13:45:54 <Cale> ah, I see
13:45:58 <Cale> getAllUserEntries =
13:45:58 <Cale>     withMVar lock $ \_ -> bracket_ c_setpwent c_endpwent $ worker []
13:46:11 <Cale> getAllUserEntries is properly bracketed
13:46:12 <tomoj> how can put and get in Data.Binary be inverses with their types 't -> Put' and 'Get t' ?
13:46:45 <Cale> getAllGroupEntries =
13:46:45 <Cale>     withMVar lock $ \_ -> worker []
13:46:52 <lispy> http://linux.about.com/library/cmd/blcmdl3_getgrent.htm
13:47:14 <lispy> tomoj: the latter type is a monad
13:47:36 <tomoj> I guess I should learn what that means :(
13:47:38 <Cale> tomoj: They're not literally inverses, but that's effectively the idea.
13:48:00 <tomoj> oh, they can be nonliteral inverses even if get . put == id ?
13:48:04 <lispy> Cale: ah yes, that's exactly what I was going to recommend as a fix
13:48:18 <Cale> put will write some value as binary data, get will parse that binary data back into a value
13:48:34 <lispy> tomoj: it probably isn't identity, so much as idempotent
13:49:09 <lispy> tomoj: I hope I'm not seeming obtuse :)
13:49:29 <Cale> idempotent isn't really the word I'd use either
13:49:30 <patch-tag> Cale: thanks for looking. enlightened. Any action suggested? (bug report etc)
13:49:40 <lispy> tomoj: idempotent means that the operation can be performed (or transformation applied) without changing anything
13:49:55 <Cale> patch-tag: Well, it would be good if we could get someone to see if this bug is in 6.12
13:50:03 <tomoj> I thought it meant you could do it more than once and only the first would change
13:50:06 <lispy> if f (f x)) = x, then f is idempotent
13:50:08 <Cale> But you could just submit a trac ticket
13:50:17 <copumpkin> idimpotent!
13:50:19 <copumpkin> ;)
13:50:33 <lispy> am I spelling it incorrectly?
13:50:36 <patch-tag> ok, I'll do that.
13:50:49 <tomoj> idempotent means f(f(x)) = f(x)
13:51:04 <lispy> tomoj: ah yeah, I forgot the second f(x)
13:51:08 <opqdonut> mhmm, f(f(x))=x is a too strong condition
13:51:11 <Cale> lispy: no, copumpkin's line was a "pun"
13:51:18 <copumpkin> :(
13:51:28 <lispy> tomoj: sorry about that
13:51:38 <opqdonut> if f(f(x))=x, f is an involution
13:51:56 <tomoj> the docs say 'get . put == id'
13:52:01 <tomoj> but don't explain
13:52:04 <Cale> tomoj: do they?
13:52:06 <lispy> ah, hmm
13:52:45 <Cale> tomoj: They don't say that
13:52:53 <Cale>  decode . encode == id
13:53:07 <tomoj> hmm, is 0.4.1 old?
13:53:09 <lispy> ?unpl get . put == id
13:53:09 <lambdabot> ((\ d -> get (put d)) == \ a -> a)
13:53:10 <tibbe> dons: still on vacation?
13:53:21 <lispy> tibbe: ya he is
13:53:29 <Cale> tomoj: yes
13:53:29 <tibbe> lispy: long vacation! nice
13:53:41 <Cale> tomoj: 3 years old or so
13:53:47 <tomoj> oh I must have wound up there on google by accident
13:53:49 <tomoj> thanks
13:54:19 <tomoj> ok, that makes more sense
13:54:50 <Cale> usually when looking for documentation, I just go to hackage first, and then do text search for the packagename I'm interested in
13:55:15 <Cale> It would be nice to have a combined haddock of all the most common packages...
13:56:42 <tomoj> I was wondering earlier how I could get my docs generated by 'cabal haddock' into the index at /usr/share/doc/ghc or at least all in one place
14:00:46 <lispy> tomoj: yeah, I'd like to have cabal add the haddocks to my local hoogle instance
14:01:14 <lispy> There was talking of finding funds for that here at work, but I don't know what will happen
14:02:22 <gwern> lispy: doesn't haddock have --hoogle?
14:03:02 <lispy> gwern: perhaps, so if it does how do I incorporate that with the rest of my hoogle database?
14:03:23 <tomoj> lispy: great, I didn't even know I could have a local hoogle instance
14:03:38 <gwern> lispy: you'd use hoogle's --convert and --combine options and replace the database
14:03:42 <lispy> tomoj: yeah, I have mine setup using goa
14:04:51 <xerox> <3
14:05:52 <gwern> lispy: I'll admit, currently the integration between haddock and hoogle is poor
14:09:31 <tibbe> preflex: seen bos
14:09:33 <preflex>  bos was last seen on #haskell 13 hours, 7 minutes and 37 seconds ago, saying: merehap: not using git makes me a better person.
14:10:13 <patch-tag> system.Posix.GetAllGroupEntries bug: http://hackage.haskell.org/trac/ghc/ticket/3816     can somebody check this on ghc 6.12?
14:14:16 <Veinor> :k Mu
14:14:17 <lambdabot> (* -> *) -> *
14:15:06 <Veinor> so kind is to a type constructor as a type is to a function?
14:15:17 <Twey> Aye
14:15:40 <Twey> There are only a few different kinds, though, and it's a closed set.
14:15:56 <Twey> Er, in the linguistic sense, not the mathematical
14:16:00 <ben0x539> @src Mu
14:16:01 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
14:16:03 <patch-tag> is cabal upload broken today?
14:16:05 <patch-tag> Uploading dist/HSHHelpers-0.23.tar.gz...
14:16:08 <patch-tag> Error: dist/HSHHelpers-0.23.tar.gz: 404 Not Found
14:16:38 <Veinor> Twey: what do you mean?
14:17:01 <Twey> You can't add new kinds.
14:17:10 <Veinor> ah.
14:18:00 <Veinor> so what are some kinds that aren't allowed?
14:18:22 <aavogt> @ghc kind
14:18:22 <lambdabot> ghc says: Kinds don't match in type application
14:18:25 <aavogt> @ghc kind
14:18:26 <lambdabot> ghc says: Can't represent explicit kind signatures yet
14:18:30 <aavogt> @ghc kind
14:18:31 <lambdabot> ghc says: Kind signature on data type declaration has non-* return kind
14:18:33 <Twey> Anything except *, ?, ->, and a few others
14:18:43 <sproingie> what's ? in a kind?
14:19:33 <copumpkin> it's any kind I think
14:19:42 <Veinor> :k IO
14:19:43 <lambdabot> * -> *
14:19:46 <Veinor> right.
14:19:49 <copumpkin> :k (->)
14:19:50 <lambdabot> ?? -> ? -> *
14:19:54 <copumpkin> that's what I use to remember
14:20:02 <copumpkin> ?? is any kind minus unboxed tuples
14:20:02 <lambdabot>  is any kind minus unboxed tuples
14:20:04 <copumpkin> ? is any kind
14:20:10 <copumpkin> and * is regular types
14:20:16 <Veinor> I wish I understood arrow :p
14:20:25 <ben0x539> How is (->) ?? -> ? -> *?
14:20:26 <copumpkin> it's nothing arrowy there
14:20:39 <stepcut> is there someway that I can open a file for writing, and also open it for reading at the same time?
14:20:44 <ben0x539> I mean it kind of seems like it ought to be * -> * -> *
14:20:54 <xerox> ??
14:20:59 <copumpkin> ben0x539: it's a type function that takes a type of any kind minus unboxed tuples (the domain) a type of any kind (the codomain) and produces a type
14:21:11 <stepcut> right now I get, Server error: /var/log/happstack.com/irc-logs/happs-2010-01-11.txt: openBinaryFile: resource busy (file is locked)
14:21:11 <xerox> ?? foo
14:21:11 <lambdabot>  foo
14:21:14 <xerox> hah
14:21:32 <ben0x539> What does a value of a type look like that is constructed by applying -> to two things either of which is not a concrete type?
14:21:57 <xerox> Int# -> (Int,Int) ?
14:22:16 <opqdonut> what do you mean ben0x539
14:22:17 <ben0x539> :k (Int, Int)
14:22:18 <lambdabot> *
14:22:33 <ben0x539> opqdonut: I cannot come up with an example where (->) is not used as if of kind * -> * -> *
14:22:43 <opqdonut> :k Int#
14:22:44 <lambdabot> Not in scope: type constructor or class `Int#'
14:23:13 <ben0x539> Oh, come on, that barely counts :|
14:23:20 <medfly> :t 3#
14:23:22 <lambdabot> GHC.Prim.Int#
14:23:40 <opqdonut> well in "normal" haskell one doesn't see kinds other than *
14:23:45 <medfly> :k GHC.Prim.Int#
14:23:46 <lambdabot> #
14:23:47 <lunabot>  luna: parse error on input `]'
14:23:49 <xerox> ?kind GHC.Prim.Int#
14:23:50 <lambdabot> #
14:23:51 <lunabot>  luna: parse error on input `]'
14:23:58 <opqdonut> (and stuff like *->* of course)
14:24:13 <ben0x539> Okay, apparently I forgot about #. So does ? include things other than * and #?
14:24:18 <BONUS> no kind polymorphism :(
14:24:22 <BONUS> hence the ?
14:24:23 <xerox> so you can have Int# -> (Int,Int) but not (Int,Int) -> Int#
14:24:41 <ben0x539> (# Int, Int #) surely
14:24:52 <ben0x539> Or, uh, oh
14:24:55 <ben0x539> Nevermind
14:24:59 <opqdonut> :)
14:25:28 <ben0x539> Still, does ? include stuff like (* -> *)?
14:26:18 <ben0x539> I do not get kind signatures, I suppose.
14:26:55 <copumpkin> ben0x539: nope
14:27:36 <Gracenotes> -> is a funny looking nose
14:27:53 <copumpkin> :k (# Int , Int #)
14:27:54 <lambdabot> (#)
14:27:59 <Twey> :->
14:29:14 <medfly> (*  > *)
14:29:31 * medfly is a chick.
14:30:26 <Twey> medfly: Haha
14:30:30 <Twey> Cute :
14:30:59 <Gracenotes> (* > *) < cluck cluck
14:31:28 <copumpkin> <( @.@ )>
14:32:44 <copumpkin> _
14:32:56 <ben0x539> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes this is helpful
14:33:00 <copumpkin> _
14:34:58 <leimy> reading about IterateeIO
14:35:03 <leimy> pretty awesome stuff
14:36:28 <Twey> Yes!
14:40:44 <gwern> anyone have a quick summary of what an 'homeomorphic embedding' in program optimization contexts would mean?
14:42:10 <Cale> gwern: I only know what it means in topology
14:42:24 <lispy> gwern: according to wikipedia: Homeomorphisms are the isomorphisms in the category of topological spaces  that is, they are the mappings which preserve all the topological properties of a given space.
14:42:43 <ben0x539> That is what my linear algebra 1 tutor said
14:42:43 <xerox> aka bicontinuous mappings
14:42:57 <xerox> (bicontinuous bijective mappings)
14:42:57 <Cale> continuous, with continuous inverse
14:43:02 <gwern> darn. ndm mentioned such an embedding as an equivalent to some supercompiler operations, and I don't want to look ignorant and ask him 'what the heck is that in supero?'
14:43:07 <lispy> I'm not sure what it means for a program to be continuous
14:44:02 <Cale> Well, maybe it's continuity in the sense of preserving limits of chains in the definedness ordering
14:44:10 <lispy> Some parts of programs are topological I guess
14:44:11 <xerox> maps open sets in the output domain to open sets in the input domain?  x_x
14:44:39 <lispy> gwern: it's actually a really _good_ question
14:44:59 <gwern> lispy: but to pose it requires more knowledge than skimming papers :)
14:45:01 <lispy> Just understanding the terms should give you a lot of intuition about the problem
14:45:07 * gwern is a total poser
14:45:31 <Cale> Also, "homeomorphic embedding" seems either redundant or contradictory to me.
14:45:48 <opqdonut> might it be homomorphic?
14:46:03 <aavogt> homeopathic?
14:46:16 <xerox> I agree. embedding = injective. homeomorphism = injective, surjective, continuous, inverse continuous
14:46:24 <Cale> Oh, maybe I know what it is
14:46:46 <hatds> embedding doesn't have to be homeomorphic to it's image
14:47:11 <xerox> not a very good embedding then
14:47:15 <Cale> hatds: yeah
14:47:44 <Cale> I was going to say perhaps it's an embedding with a continuous inverse from the image back to the domain.
14:48:05 <leimy> What I don't understand about Iteratee is why the thing that runs an Iteratee over a collection is called an Enumerator and not an Iterator :-)
14:48:15 <hatds> it's an annoying issue that always happens when isomorphism \= bijective homorphism
14:48:18 <lispy> Okay, but if you say that I still don't understand what a continuous function is here
14:48:35 <hatds> yea, neither do we :)
14:48:38 <xerox> e.g. consider the theorem that says that all compact topological manifolds can be embedded into R^n for some n
14:48:43 <lispy> leimy: yeah, "enumerator" is an iteratee transformer and I get lost in terminology
14:48:58 <leimy> Yeah.
14:49:06 <leimy> The names don't help you remember what is for what :-)
14:49:34 <lispy> Well, an enumerator takes an iteratee and runs it over a stream, enumerating the output
14:49:42 <Cale> Iteratee just looks way too complicated to actually use unless under duress from some sort of bizarre combination of circumstances.
14:49:54 <leimy> Cale: Not to me.
14:50:03 <leimy> See I had to do "expect-like" serial programming
14:50:06 <Eduard_Munteanu> Can I do something like "if (condition) return ()" and write additional code after return in a function?
14:50:22 <opqdonut> Eduard_Munteanu: return isn't what you think
14:50:23 <Eduard_Munteanu> Will it actually return if the condition is true, without executing the rest?
14:50:23 <Botje> return does not actually "return" from a do block
14:50:31 <Eduard_Munteanu> opqdonut, yeah, that's why I had doubts.
14:50:31 <leimy> so bizarre end of line, detection of prompts, and other such things were being handled 1 char at a time, with no possibility to roll stuff back into the stream.
14:50:40 <leimy> I ended up with a really inefficient "expect monad" :-)
14:50:45 <opqdonut> Eduard_Munteanu: besides, you can't have an if without an else
14:50:45 <Cale> Eduard_Munteanu: return () is an action which does nothing.
14:50:54 <Cale> Eduard_Munteanu: and returns an empty tuple
14:51:10 <Eduard_Munteanu> Yeah. Can I omit the 'else' in any way?
14:51:12 <lispy> :t when
14:51:13 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:51:15 <Cale> :t when
14:51:16 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:51:16 <leimy> () is not an empty tuple though right.  I thought it was regarded as the singleton object of type "()"
14:51:22 <Eduard_Munteanu> lispy, Cale, thanks.
14:51:26 <Twey> It's also an empty tuple
14:51:33 <Cale> when's type is unfortunately stupid
14:51:51 <lispy> Cale: what type would you use
14:51:51 <Cale> It should be  when :: (Monad m) => Bool -> m a -> m ()
14:51:57 <aavogt> should it be a Maybe?
14:52:12 <Twey> With a (() <$)?
14:52:13 <Cale> Or else Maybe would also be acceptable
14:52:17 <aavogt> Monad m => Bool -> m a -> m (Maybe a)
14:52:28 <Twey> Sounds better
14:53:13 <lispy> > let when' b ma = if b then ma else (return ()) in when' True (return 1) :: [Int]
14:53:14 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:53:14 <lambdabot>         against inferred type ...
14:53:17 <amigoo> how do you create a random number between 1 and 5?
14:53:37 <Twey> :t randomRIO
14:53:39 <lambdabot> forall a. (Random a) => (a, a) -> IO a
14:53:41 <monochrom> If you don't mind IO, randomRIO (1,5)
14:54:03 <Twey> If it's a one-off, that's probably your best option
14:54:15 <xerox> > randomRs (1,5) (mkStdGen 42)
14:54:16 <lambdabot>   [2,2,3,5,2,2,4,2,4,1,1,5,2,4,5,1,3,2,4,2,2,5,3,5,2,5,1,4,4,5,5,1,3,3,2,4,5,...
14:54:26 <Twey> Shame there's no randomRIOs
14:54:33 <Gracenotes> yeah
14:54:37 <Twey> (randomRsIO?)
14:54:50 <Cale> If you do mind it, then you can get hold of a generator somehow using  newStdGen  (which is IO), or mkStdGen (which produces a generator from a given seed), and use randomR with the generator and the range
14:55:06 <Twey> Or randomRs
14:55:10 <Cale> yeah
14:55:15 <Twey> That's rather more convenient in most cases
14:55:15 <Cale> > randomR (mkStdGen 42) (1,5)
14:55:17 <lambdabot>   Couldn't match expected type `(a, a)'
14:55:17 <lambdabot>         against inferred type `System...
14:55:29 <Cale> > randomR (1,5) (mkStdGen 42)
14:55:29 <jmcarthur> IO is an instance of MonadRandom though
14:55:30 <Twey> > mkStdGen >>= flip randomRs (1, 5)
14:55:31 <lambdabot>   (2,1720602 40692)
14:55:31 <lambdabot>   Couldn't match expected type `System.Random.StdGen'
14:55:31 <lambdabot>         against inferre...
14:55:36 <Twey> D'oh
14:55:48 <Twey> > flip randomRs (1, 5) (mkStdGen 42)
14:55:48 <amigoo> thanks, that's a lot of answers
14:55:49 <lambdabot>   Couldn't match expected type `System.Random.StdGen'
14:55:50 <lambdabot>         against inferre...
14:55:53 <Twey> Er
14:55:55 <jmcarthur> so you can use getRandomRs in IO
14:55:57 <Twey> > randomRs (1, 5) (mkStdGen 42)
14:55:58 <lambdabot>   [2,2,3,5,2,2,4,2,4,1,1,5,2,4,5,1,3,2,4,2,2,5,3,5,2,5,1,4,4,5,5,1,3,3,2,4,5,...
14:56:00 <Twey> I'm embarrassed :
14:56:10 <Twey> Ugh, moreso now
14:57:24 <Cale> amigoo: Random number generation can be a bit unusual in Haskell if you're used to imperative languages, because functions in Haskell are forced to always produce the same result for the same input (a property that generally has a lot of advantages), but for random number generation, seems like the opposite of what you'd want.
14:57:25 <Gracenotes> > unfoldr (return . randomR (1, 5)) (mkStdGen 42)
14:57:27 <lambdabot>   [2,2,3,5,2,2,4,2,4,1,1,5,2,4,5,1,3,2,4,2,2,5,3,5,2,5,1,4,4,5,5,1,3,3,2,4,5,...
14:57:54 <Twey> Although it results in an interesting separation of the process.
14:57:57 <Cale> amigoo: So if our function to produce random numbers is going to produce different results, we need to vary what we give it.
14:58:40 <Cale> amigoo: and the answer is that we give it different generator states (StdGen values)
14:59:30 <amigoo> hmmm
14:59:33 <amigoo> I don't quite get that
14:59:45 <Cale> :t mkStdGen
14:59:46 <lambdabot> Int -> StdGen
15:00:13 <Cale> :t randomR (mkStdGen 42) (1,5)
15:00:14 <lambdabot>     Couldn't match expected type `(a, a)'
15:00:14 <lambdabot>            against inferred type `StdGen'
15:00:14 <lambdabot>     In the first argument of `randomR', namely `(mkStdGen 42)'
15:00:17 <Cale> er
15:00:23 <Cale> heh, keep getting it backward
15:00:26 <gwern> amigoo: you get a random *seed* somewhere up in IO, but when you combine the seed & generator, then you now have a pure function which can be passed around. from IO instance to IO instance, output is random, but within the instance, it's pure/repeatable
15:00:30 <Cale> :t randomR (1,5) (mkStdGen 42)
15:00:32 <lambdabot> forall t. (Num t, Random t) => (t, StdGen)
15:00:41 <Cale> :t randomR (1,5 :: Integer) (mkStdGen 42)
15:00:43 <lambdabot> (Integer, StdGen)
15:00:48 <gwern> "Any one who considers arithmetical methods of producing random digits is, of course, in a state of sin. For, as has been pointed out several times, there is no such thing as a random number  there are only methods to produce random numbers, and a strict arithmetic procedure of course is not such a method. "
15:01:16 <amigoo> then it is not really random
15:01:21 <amigoo> in a way
15:01:25 <Cale> Right
15:01:27 <xerox> Pseudo random number theory is hard
15:01:29 <Cale> > randomR (1,5) (mkStdGen 42)
15:01:30 <lambdabot>   (2,1720602 40692)
15:01:31 <Cale> > randomR (1,5) (mkStdGen 42)
15:01:32 <lambdabot>   (2,1720602 40692)
15:01:33 <Cale> > randomR (1,5) (mkStdGen 42)
15:01:34 <lambdabot>   (2,1720602 40692)
15:01:36 <jmcarthur> conal: "junk free" means the semantic function is onto, so does "full abstraction" mean the semantic function is one-to-one?
15:01:37 <Cale> Always the same
15:01:38 <Gracenotes> :?
15:01:50 <Cale> > randomRs (1,5) (mkStdGen 42)
15:01:52 <lambdabot>   [2,2,3,5,2,2,4,2,4,1,1,5,2,4,5,1,3,2,4,2,2,5,3,5,2,5,1,4,4,5,5,1,3,3,2,4,5,...
15:01:53 <Cale> > randomRs (1,5) (mkStdGen 42)
15:01:54 <lambdabot>   [2,2,3,5,2,2,4,2,4,1,1,5,2,4,5,1,3,2,4,2,2,5,3,5,2,5,1,4,4,5,5,1,3,3,2,4,5,...
15:01:54 <gwern> amigoo: in a useful way though!
15:01:56 <xerox> Namely things like providing long period for all the seeds.
15:02:24 <Cale> Even the whole infinite sequence of random numbers produced by iterating the process (as randomRs does) will be the same every time
15:02:43 <xerox> E.g. mersenne twister has an incredible period length: 2^19937 - 1.
15:03:14 <Cale> So it's not really random, it's pseudorandom, but this is how things go with computers.
15:03:16 <sproingie> > do { g <- newStdGen; return $ take 5 $ randomRs (1,5) g }
15:03:17 <lambdabot>   <IO [Integer]>
15:03:22 <sproingie> bah
15:03:29 <xerox> > truncate (19937*log 2 / log 10)
15:03:30 <lambdabot>   6001
15:03:34 <xerox> that's a lot of digits.
15:03:36 <conal> jmcarthur: if the semantic function were 1-1, there would be no non-trivial equational properties.
15:03:50 <hatds> randomRIO has an IO return type for the same reason randomR returns a pair of results, if that helps any
15:03:53 <jmcarthur> oh! i see
15:03:59 <conal> jmcarthur: the model would be syntatic/initial/term
15:04:12 <amigoo> i see
15:04:45 <Cale> I still think that newStdGen should be implemented by reading from /dev/random or /dev/urandom though it currently bases its result on the system clock.
15:05:04 <Twey> Why?
15:05:08 <monochrom> If only we can just ditch windows.
15:05:14 <Twey> /dev/{u,}random would be the obvious choice
15:05:17 <sproingie> windows has a rng device too
15:05:29 <Eduard_Munteanu> :t (head [])
15:05:30 <monochrom> See, the ocaml people got that right. :)
15:05:31 <lambdabot> forall a. a
15:05:41 <xerox> The same one they use for the blue screens.
15:05:45 <idnar> reading from /dev/random is problematic if people are calling newStdGen a lot
15:05:45 <Twey> Heheh.
15:05:47 <Cale> monochrom: What did they do?
15:05:51 <Twey> idnar: They shouldn't be
15:05:55 <Phyx-> monochrom: bah humbug
15:05:57 <sproingie> you use urandom
15:05:59 <idnar> and is probably unnecessary anyway; /dev/urandom should be sufficient
15:06:04 <sproingie> urandom is seeded from random
15:06:12 <idnar> if you want crypto-safe randomness, you're not going to be using a PRNG
15:06:16 <Twey> /dev/urandom should be sufficient generally, yes
15:06:26 <idnar> if you don't want crypto-safe randomness, you don't need /dev/random
15:06:34 <jmcarthur> there are cryptographically secure PRNGs
15:06:47 <sproingie> isn't System.Random also quite slow?
15:06:51 <hatds> there's more to it than crypto vs non-crypto
15:06:58 <jmcarthur> right
15:07:05 <idnar> jmcarthur: I don't even understand what that could mean
15:07:06 <monochrom> The ocaml people don't work too hard to get ocaml to work on windows. or port libs to windows. E.g., "you lack proper posix, therefore we won't provide XXX"
15:07:10 <Cale> Heh, we should switch to Blum Blum Shub and kill the performance of System.Random even further
15:07:17 <hatds> speed and "how random" are important variables for just plain simulations
15:07:19 <sproingie> ocaml on windows is cygwin
15:07:21 <gwern> @quote blum
15:07:22 <lambdabot> Baughn says: Blum Blum Shub, a PRNG derived from poking around R'Lyeh.
15:07:28 <idnar> but I'm not that much of a crypto expert
15:07:41 <tommd1> idnar: See NIST 800-90 for an example of one.
15:07:43 <monochrom> So, for example, the ocaml style to PRNG would be "no System.Random for you because you lack /dev/random"
15:07:53 <jmcarthur> idnar: http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator
15:07:56 <Adamant> Cale: BUT IT'S PROVEABLE
15:08:00 <tommd1> Secure from a number theoretic sense, not an information theoretic sense.
15:08:02 <Adamant> :P
15:08:09 <idnar> yeah, I'm reading that now
15:08:48 <idnar> apparently a CSPRNG is absolutely nothing like what I'd think of as a PRNG
15:09:01 <jmcarthur> in what sense?
15:09:01 <Adamant> monochrom: that's a bit wacky. Windows has perfectly good CSPRNG stuff.
15:09:07 <Cale> BBS is secure in the sense that determining the seed from the sequence of outputs is as hard as factoring an integer.
15:09:12 <monochrom> Yes I'm exaggerating.
15:09:53 <idnar> I think the main problem with system time is that it's too easy to get duplicate seeds and so on
15:10:38 <Adamant> it's also ridiculously slow and there are plenty of better practical CSPRNG's that have quite good overall performance.
15:10:40 <Cale> idnar: and that if people can guess the time at which you started the program, then it's easy to break
15:10:42 <monochrom> Or maybe not. There is a big gap between "window has XXX" and "windows has XXX and the API is the same as unix's"
15:10:58 <Cale> idnar: This happened to Netscape, as I recall.
15:11:06 <idnar> jmcarthur: it's probably my fault, my mental idea of "PRNG" was just too narrow
15:11:15 <idnar> jmcarthur: I'd never thought of /dev/urandom as a PRNG, for example
15:11:22 <Adamant> monochrom: Windows' stuff all uses different interfaces but the quality (in 2009) is just as good.
15:11:57 <idnar> Cale: if you're worried about that, then surely you shouldn't be using Mersenne Twister anyway?
15:11:58 <EvanR-work> idnar: if i remember correctly /dev/random and /dev/urandom on bsd are typically straight up PRNGs
15:12:02 <xerox> Mersenne twister is easier, once you have I think ~600 successive numbers of the sequence, you have the seed.
15:12:22 <Ke> there are different ones
15:12:30 <Cale> idnar: Not Mersenne Twister, no.
15:12:33 <c_wraith> a friend of mine destroyed the /dev/null nethack contest in the early 2000s by finding all the times in the contest that there would be a wand of wishing on the first level, and starting games only on those times.  Clearly, there are problems with seeding to the current time.
15:12:55 <Ke> http://www.boost.org/doc/libs/1_41_0/boost/random/mersenne_twister.hpp
15:13:21 <idnar> EvanR-work: yeah, apparently /dev/random doesn't work quite how I thought it did, either
15:13:33 <idnar> EvanR-work: I wonder where I got all of these misconceptions from :(
15:13:38 <Ke> http://www.boost.org/doc/libs/1_41_0/libs/random/random-generators.html
15:14:04 <idnar> c_wraith: that's a seriously awesome story :)
15:14:39 <c_wraith> after that, they changed the random seeding algorithm to something better. :)
15:14:49 <idnar> c_wraith: as a sort of related story, Diablo and Diablo II use a PRNG that's fed entirely by player actions in the game
15:14:52 <EvanR-work> idnar: i recently implemented this lag 1024 MWC generator, it passed all the tests that m19937 passed on dieharder... and its so much simpler
15:15:15 <idnar> c_wraith: the speed running guys use this to their advantage by deliberately manipulating the PRNG to their advantage as they progress through the game
15:15:17 <EvanR-work> but had way longer period
15:15:36 <Adamant> idnar: nice
15:15:46 <Adamant> speed running as an art
15:15:47 <idnar> c_wraith: it's quite bizarre to watch if you don't understand why the player is performing all these seemingly nonsensical actions at random
15:16:08 <c_wraith> idnar:  that's really clever.
15:16:42 <Cale> idnar: Is the speed in terms of steps or wall clock time?
15:16:44 <xerox> idnar I've seen that done with a gameboy. I mean. timing the keypress so to seed the rng with a real gameboy device and real hands. not bit fiddling.
15:17:08 <xerox> (takes many tries)
15:17:09 <c_wraith> idnar: you need frame-accurate input for that, though, so I'm assuming this is done with botting tools on local games?
15:17:11 <mental> idnar: do they use tools, or can they actually predictably influence the standard game program?
15:17:39 <idnar> Cale: time (wall clock or otherwise) doesn't affect the PRNG at all
15:17:56 <Cale> idnar: I know, but I mean for the concept of a "speed run" here
15:18:08 <idnar> Cale: oh, right; wall clock for that, I believe
15:18:18 <Veinor> xerox: O_o
15:18:29 <Cale> It seems that computing the effect of each action you take on the random number generator would waste a lot of wall clock time.
15:18:45 <idnar> I think they can do the preparation for that beforehand
15:18:48 <Veinor> I believe that the actions to take are precomputed
15:18:52 <hatds> preparing for any speedrun wastes a lot of wall clock time :)
15:18:55 <idnar> as I understand it, there's only a very limited set of actions that influence the state of the PRNG
15:19:01 <Veinor> so 'okay, do this, then that, then the other, and then you'll be in the goal state'
15:19:01 <hatds> you could say it doesn't accomplish anything at all!
15:19:20 <mental> oddly that sounds exactly like real-world magic
15:19:22 <idnar> the monster AI and so on doesn't make use of the PRNG, for example
15:19:42 <mental> you do some random motions with your hands, pronounce a few gibberish words
15:19:42 <Veinor> idnar: ?
15:20:05 <Veinor> I thought that monsters' behavior is basically driven by the PNG
15:20:06 <EvanR-work> mental: yeah, and since the game could be using microphone as seed, you have to say the words exactly ;)
15:20:07 <mental> and air molecules just happen to form themselves into a giant fireball flying towards your enemy
15:20:31 <mental> EvanR-work: i mean this could be how magic works in the real world :)
15:20:35 <Veinor> have you seen the family feud 'speedrun'?
15:20:45 <hatds> lol
15:20:49 <Veinor> http://www.youtube.com/watch?v=k5tyMXXDPX4
15:20:55 <Veinor> it's basically the guy abusing the answer recognizer
15:21:02 <EvanR-work> mental: yeah, the universe is running on a poorly coded celestial hypercomputer
15:21:05 <xerox> Veinor http://www.youtube.com/watch?v=yFHqFZubTZw
15:21:20 <idnar> Veinor: I think the monster AI is deterministic (this is not necessarily the same as *predictable*, since there's a lot going on at once), it's only things like item drops and so on that that use the RNG
15:21:41 <Adamant> mental: someone invented a flamethrower that looks and works about like Spider-man's web slinging contraption in the comic books
15:21:53 <Adamant> and has so far managed to not kill themselves
15:21:59 <Veinor> idnar: I think it depends on the game. I know that for, say, video games, there are enemies that have a pattern that's 'do a or b, then c, then do e or f, then g. repeat'
15:22:13 <idnar> Veinor: I know, I'm referring specifically to Diablo and Diablo II
15:22:17 <Veinor> ahhh.
15:22:19 <Veinor> missed that.
15:22:22 <mental> unpredictable enemies make the game boring
15:22:28 <Adamant> someone did something along these lines in real life
15:22:28 <xerox> Veinor the timing in the boot is what seeds the rng in that case (there may be other subtleties that he fixes before turning down)
15:22:45 <idnar> so the guy, say, buys and sells some items seemingly randomly at one of the merchants
15:22:59 <Veinor> I like the speedruns that involve non-RNG glitches
15:23:03 <Adamant> http://gscentral.net/larsen.htm
15:23:04 <idnar> and then goes to kill the boss, who just happens to drop an item with obscenely awesome stats
15:23:07 <Veinor> like the guy who beat some castlevania in 20 seconds
15:23:30 <idnar> because the RNG was in the right state for that drop
15:23:31 <Veinor> Adamant: ooh yeah, i remember reading about him
15:23:35 <Adamant> guy figured out a game show RNG in the 70's and proceeded to utterly control the game
15:23:35 <mental> i like speedruns that involve amazing skill
15:24:10 <Veinor> http://gscentral.net/peter.jpg
15:24:12 <Veinor> hahaha
15:24:45 <idnar> Veinor: in Quake speedrunning, there's this one level (E2M1) that you can complete in under 10 seconds by jumping across a gap at the start to arrive at the end of the level
15:25:07 <idnar> Veinor: the first time I saw that, I was so depressed, because I spent at least 30 minutes doing that level the hard way when I played the game through
15:25:21 <Veinor> that's pretty funny.
15:25:33 <Veinor> you see the run where a guy beats pokemon green in about 4 minutes?
15:26:06 <Veinor> A somewhat sad postscript to the story is that Larson eventually wound up losing all his winnings in a bad housing investment deal. In fact, he lost all the money before the show was even cancelled, prompting a call to the network asking if he could participate in a tournament of champions. Not surprisingly, the show politely declined.
15:26:11 <Veinor> :(
15:27:50 <mental> :(
15:28:12 <mental> I love doom speedruns
15:28:28 <mental> they do use all the available glitches but mostly it's just immense skill
15:28:36 <Adamant> other good examples are the Eudaemonic Pie folks, who may have been preceded by Claude Shannon himself
15:28:40 <erikc> mario speed runs too
15:28:46 <idnar>  Michael lost of all of his money quickly, including $40,000 in one dollar bills that was stolen from his home shortly after the episode aired.  At the time of his death in 1999, Michael was on the run from the law, and many members of his family weren't speaking to him.
15:28:51 <idnar> that's crazy
15:28:54 <Adamant> yes, information theory Shannon
15:28:56 <hatds> what about that Chrono Trigger speedrun which is like "manipulate programming errors in pause menu for 12 minutes.. hey you won!"
15:28:59 <Veinor> erikc: yahoo! yayayayayayayayhoo!
15:29:09 <erikc> new super mario bros wii has some really awesome speedruns you can unlock / watch
15:29:49 <Phyx-> I beleive I have never been in a more random channel topic wise than #haskell
15:29:50 <Phyx-> I love it
15:30:01 <sproingie> speed run for Oblivion is like 11 minutes
15:30:07 <mental> Phyx-: pun intended?
15:30:09 <Adamant> Phyx-: try #electronics
15:30:29 <Cale> sproingie: interesting
15:30:42 <Adamant> Morrowind is like nothing
15:30:52 <sproingie> thanks to the level scaling, you just zip off to the last oblivion gate and all the monsters are level 1
15:31:00 <Phyx-> mental: no, but i do wonder, if there's a PRNG algorithm that given the correct seed would predict you guys :P
15:31:22 <idnar> Phyx-: isn't the whole physical universe just a gigantic PRNG?
15:31:49 <Cale> sproingie: heh
15:31:59 <mental> Phyx-: ##philosophy, i'm afraid
15:32:00 <Phyx-> idnar: seed == big bang?
15:32:14 <idnar> Phyx-: something like that
15:32:36 <Veinor> Phyx-: no, because quantum mechanics is nondeterministic
15:32:37 <newsham> that larson story is great
15:32:46 <Phyx-> that would have made an interesting "philosophy of computer science" topic
15:32:53 <idnar>     latestUrl = 'http://jjrowland.com/'
15:32:53 <idnar>     imageUrl = 'http://jjrowland.com/archive/%s.html'
15:32:53 <idnar>     imageSearch = compile(r'"(/comics/.+?)"')
15:32:53 <idnar>     prevSearch = compile(r'<a href="(/archive/.+?)"[^>]+?>&nbsp;')
15:32:53 <Cale> sproingie: the way that levelling was handled is one of the things they messed up at really badly in Oblivion.
15:32:56 <mental> yes. VERY interesting.
15:32:56 <idnar> er, wrong window :(
15:32:58 <newsham> there is no big bang.. it just appears that way
15:33:51 <Phyx-> Veinor: I wonder how the universe would be if everything was lazily evaluated
15:34:06 <Ke> Phyx-: that's quantum mechanics
15:34:13 <Veinor> Haha
15:34:16 <idnar> haha
15:34:33 <Ferdirand> so quantum effects are just bugs in the strictness analyzer ?
15:34:51 <idnar> not bugs, features!
15:34:53 <sproingie> Cale: there's various overhauls to the level scaling, and they pretty much got it right with fallout3
15:35:07 <Phyx-> the whole universe is just one big let binding :)
15:35:31 <Phyx-> with occasional dead code elimination and abstractions
15:35:32 <idnar> "let binding" sounds like something kinky
15:35:40 * sproingie prefers to play FO3 with extra difficulty mods including ammo rarity.  you make every shot count.
15:36:40 <Cale> sproingie: yeah
15:36:59 <sproingie> personally i thought the fungible currency of FO3 should have been bullets, not caps
15:37:07 <Cale> sproingie: The first thing I do when playing Oblivion is install a dozen mods or so :P
15:37:29 <idnar> heh, I'm used to playing first-person shooters where there's always limited ammo for the better weapons
15:37:51 <idnar> so you end up killing the end boss with your peashooter just because you forget you have something better
15:37:52 <sproingie> yeah but this is where there's limited ammo for *every* weapon
15:38:16 <kmc_> ah, system shock 2
15:38:23 <idnar> and of course, shooting him in the shin with your peashooter isn't very effective, so you need to be efficient
15:38:29 <kmc_> damn it, killed seven zombies but used 4 bullets.  *reloads*
15:38:44 <Adamant> sproingie: clearly you have been reading too much Jeff Cooper
15:38:54 <idnar> kmc_: haha
15:38:58 <sproingie> no idea who that is
15:39:17 <monochrom> reading too much #haskell is more certain
15:39:30 <Phyx-> anyone here play MW2 on the 360?
15:39:33 <idnar> kmc_: in... Max Payne 2, I think it was, I managed to accidentally save on about 5 health, half a second from being hit one last time and dying
15:39:45 <Eduard_Munteanu> kmc_, yeah, fine game
15:39:48 <idnar> and for some reason my most recent save game besides that one was like an hour of gameplay back
15:39:52 <sproingie> i hate when i do that
15:39:58 <idnar> so I spent about 15 minutes engineering my way out of that situation without dying
15:40:00 <kmc_> in the early levels it was all about melee weapons
15:40:02 <idnar> it was pretty fun, actually :)
15:40:09 <kmc_> ammo was a luxury
15:40:17 <Adamant> sproingie: king of the US gun schools and a proponent of excessive ammo ownership in case of the post-apocalypse
15:40:32 <Adamant> (although mostly because he liked to shoot, a lot)
15:40:43 <idnar> it's really weird, usually I have save games every 5 seconds through the game just about that
15:40:59 <idnar> I was always one of those people that have 10 fingers and a few toes stuck into the book as bookmarks when reading Choose-Your-Own-Adventure stories
15:41:00 <mental> that's why nethack is good
15:41:06 <mental> can't save in nethack
15:41:15 <mental> games are much more entertaining when you can't save
15:41:17 <monochrom> hahahaha idnar
15:41:57 <sproingie> yah it's a staple of roguelikes to not let you go back to a save
15:42:14 <idnar> yeah, but that's fine for nethack, because there's very little predefined content in the game
15:42:31 <mental> point
15:42:33 <c_wraith> Heck, I play Diablo 2 in hardcore mode.  Death should be feared, not a minor hassle.
15:42:45 <idnar> most of these RPGs are almost completely scripted, so to catch all the content without ever saving is really hard
15:42:55 <idnar> unless you play the game through a thousand times
15:43:07 <idnar> c_wraith: haha
15:43:16 <idnar> c_wraith: once you get to level 90 or so, you might as well be playing hardcore
15:43:19 <Adamant> mental: sports
15:43:34 <idnar> c_wraith: if you die, you lose so much XP, you won't want to carry on playing because you'll be too depressed :P
15:43:39 <sinelaw> preflex, seen Peaker
15:43:40 <preflex>  Peaker was last seen on #haskell 2 hours, 58 minutes and 55 seconds ago, saying: (1 level deep)
15:43:41 <sinelaw> preflex, seen PeakerWork
15:43:42 <preflex>  PeakerWork was last seen on #haskell 1 day, 5 hours, 38 minutes and 24 seconds ago, saying: aavogt: Well, when you apply a function - it finds the result type on its own (that of the function) :)  And when you use polymorphic functions (e.g: Operators in C, or templated functions in C++), it has to actually infer the expression's result type, and it does
15:43:55 <sinelaw> Peaker ?
15:44:07 <sproingie> one thing i never got is the mentality of people making gamefaqs for final fantasy.  in FFXII, there's this super-weapon you can get as long as you DON'T open something like five specific chests in the game
15:44:17 <sproingie> and i had to wonder, how the hell does anyone find that out?
15:44:31 <hatds> strategy guides
15:44:46 <sproingie> yeah maybe it's ripped from one of those
15:44:46 <JohnnyDub> yoyo
15:44:49 <poucet> fun: ghc: panic! (the 'impossible' happened)
15:44:59 <Adamant> random chance, game reversing, or the developer leaking it are all strong possibilities
15:45:02 <hatds> also creators sometimes just make secrets and release them after a certain time (commonly with codes)
15:45:20 <poucet> (GHC version 6.10.4 for x86_64-unknown-linux): linkBCO: >= 64k insns in BCO
15:45:39 <monochrom> poucet: You have to DON'T open five specific files to prevent that from happening. <duck>
15:46:12 <poucet> monochrom: ETOOMANYNEGATIVES
15:46:15 <c_wraith> I got ghci to tell me the impossible happened today...  that same error poucet got, actually
15:46:21 <poucet> monochrom: this was a single flie
15:46:23 <monochrom> heh
15:46:24 <sproingie> did its brain explode?
15:46:50 <poucet> granted it was a list of > 7k tuples
15:47:15 <poucet> of the form ([3, 5], [10, 12]) (with random numbers obv, but the numbers were 0-100)
15:47:25 <poucet> s/100/1000
15:58:52 <Ferdirand> win 26
15:58:54 <Ferdirand> oops
16:01:51 <xerox> > fst . randomR (1,26) $ (mkStdGen 536684)
16:01:52 <lambdabot>   26
16:01:54 * xerox wins
16:03:18 <sinelaw> > snd (1, 26)
16:03:19 <lambdabot>   26
16:03:24 <sinelaw> hah.
16:05:21 <monochrom> "project euler problem #536684: find n such that fst . randomR (1,26) . mkStdGen $ n == 26 on GHC"
16:05:54 <rndm> i get "failed to load interface for `Network`". is that normal?
16:06:08 <Saizan_> no
16:06:14 <rndm> is my build busted?
16:06:43 <Saizan_> do you have the Network package installed?
16:07:08 <Saizan_> you can check by "ghc-pkg list network"
16:07:19 <rndm> not if it requires an additional install. 've done the stupid thing and installed haskell from ubuntu repos
16:07:44 <Saizan_> then you probably also need libghc6-network-dev iirc
16:09:16 <rndm> Saizan_: that does it. thank you
16:09:22 <Saizan_> np
16:19:32 <amigoo> why can't I :t randomRs?
16:19:36 <amigoo> says not in scope
16:20:08 <amigoo> looking to generate random numbers b/w 1 and 5
16:20:20 <Ke> you would need the imports
16:20:28 <Ke> or qualified versions
16:21:10 <amigoo> how do I get the imports?
16:22:21 <lispy> Those repo distros that split up GHC really need to provide a meta package that installs everything they split up and then make it the default/suggested/recommended package
16:22:35 <lispy> It's really frustrating to see people get stuck on it again and again
16:22:51 <Ke> that's debianism for you
16:23:19 <sshc> how do I remove a cabal package?
16:23:28 <sshc> or unregister it?
16:24:19 <lispy> sshc: I'm not sure cabal allows for destructive updates :)
16:24:50 <amigoo> lispy: what's an option to get the imports?
16:25:30 <lispy> amigoo: I'm sorry, what is the context of the question?
16:26:00 <amigoo> I can't :t randomR, and Ke said I need to get the imports
16:26:15 <xerox> ?index randomR
16:26:15 <lambdabot> System.Random
16:26:54 <lispy> amigoo: I'd use hoogle to find stuff like that
16:27:04 <lispy> ?hoogle randomR
16:27:04 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
16:27:04 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
16:27:04 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
16:27:09 <Ke> System.Random.randomR is the qualified version that is
16:27:16 <lispy> :t System.Random.randomR
16:27:17 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
16:27:32 <lispy> hoogle is your friend :)
16:36:40 <tomas_> anyone know of a hash from Storable to Word32 or Int?
16:37:02 <xerox> Data.Map or Data.IntMap
16:37:41 <sjanssen> tomas_: do you mean an actual hash function, or just a dictionary/map?
16:39:07 <tomas_> i simply want a hash
16:39:39 <tomas_> sjanssen: and then manipulate the hash via bitwise operators
16:39:54 <sjanssen> I'm not familiar with one
16:40:02 <tomas_> sjanssen: doesn't need to be secure, just a fast hash
16:40:10 <tomas_> k
16:40:21 <Twey> Heh interesting use of just there
16:40:42 <sjanssen> tomas_: you could use Data.HashTable.hashString, but that might be a bit slow
16:41:10 <tomas_> Twey: why? i set up a contrast between secure and fast... i only need fast, not secure
16:41:23 <Twey> I meant sjanssen's
16:41:42 <tomas_> I see
16:41:42 <Twey> Given that a hashtable requires a hash function, one would think that it would be the function that gets the just
16:42:30 <sjanssen> Twey: note I said "dictionary/map", not "hashtable"
16:42:47 <sjanssen> I wasn't sure if tomas_ was one of those Perl programmers that says "hash" when they mean "dictionary"
16:42:55 <tomas_> no, i mean a hash
16:43:15 <damd> smokin'...
16:43:36 <tomas_> a -> Int  or a-> Word32   or Storable a => a -> Word 32.... something like that
16:44:31 <sjanssen> tomas_: oh man, I just found http://hackage.haskell.org/packages/archive/data-hash/0.1.0.0/doc/html/Data-Hash.html#v%3AhashStorable
16:44:45 <Twey> sjanssen: Aye, but given that tomas_ said hash
16:44:47 <hatds> It'd have to have a less general type than even (Storable a) =>
16:44:51 <Twey> Well, anyway.
16:45:02 <tomas_> yeah, i found that,, it's Word64... it might work
16:45:27 <hatds> ha, proved me wrong :)
16:45:51 <sjanssen> tomas_: if you're on a 64 bit architecture, Word64 in GHC is as fast/faster than Word32
16:46:19 <Twey> hatds: Depends what Storable requires
16:46:27 <tomas_> i'm on a lowly 32... so I'll bet the Word64 is slower
16:46:35 <sjanssen> tomas_: yeah, it would be
16:46:49 <hatds> Twey: yea
16:47:06 <amigoo> how do I import the packages to the CHGi?
16:47:24 <Axman6> :m +mod
16:47:25 <tomas_> :module +
16:47:26 <sjanssen> hatds: I think Storable is enough -- it lets you view a structule as a vector of bytes, which can be hashed after all
16:47:49 <tomas_> or just load a .hs with the import statement
16:49:18 <hatds> sjanssen: apparently, wasn't apparent from the Foreign.Storable page
16:50:29 <sjanssen> tomas_: also, going via Storable will slow down your code a fair bit
16:50:37 <tomas_> huh?
16:50:52 <tomas_> i am trying to use hashStorable right now
16:51:43 <sjanssen> with Storable, you've got to allocate a chunk of memory, write the value to that memory, read the bytes of that memory, then hash the bytes
16:53:02 <tomas_> hm. what would you suggest then?
16:53:36 <sjanssen> the Hashable class from that library looks pretty good
16:54:56 <tomas_> sjanssen: oh... duh.. thanks
17:01:50 <cads> evening all!
17:10:33 <tomas_> how can i change a word64 to word32? (truncate high or low bits)
17:10:54 <dolio> fromIntegral
17:11:03 <tomas_> ahah!,, thanks
17:18:31 <gwern> ' I don't really have personal experience with using the JVM directly, but my experience with the MOO programming language led me to believe that there might be a problem with integrating tail calling and security, since sometimes security is implemented by asking "who called me?" and tail calls can mean that the apparent caller is not the real caller. So I asked my spies at Sun about this.
17:18:37 <gwern> I'm told that the original security model for Java worked the way I expected (by examining the call chain), and that concern over consequent security matters contributed to the absence of tail calling support in early releases. But apparently it was conceded a long time ago that such support should be added some day, and that day simply hasn't come yet. So perhaps there is hope.'
17:19:27 <amigoo> so randomR (1,5)(mkStdGen 2) gives me same random every time
17:20:12 <amigoo> that's not really random
17:20:15 <xerox> yes, by the choosing of 2
17:20:29 <xerox> very dilbertian
17:21:26 <Twey> amigoo: That's because mkStdGen is pure
17:21:30 <Twey> You want a new seed
17:21:31 <xerox> if you don't like that, in your main use newStdGen, and pass to your pure functions the StdGen.
17:21:39 <Twey> Although
17:21:42 <xerox> (resulting from the call)
17:21:55 <Twey> If you don't mind it being the same *sequence* every time, you can use randomRs and get a list of varying random values
17:22:03 <Twey> > randomRs (1, 5) $ mkStdGen 2
17:22:05 <lambdabot>   [2,2,3,4,3,5,5,2,4,1,2,3,4,5,1,4,5,4,5,4,1,3,3,4,3,1,3,1,4,5,3,5,2,2,4,2,4,...
17:22:43 <amigoo> randomRs(1,5)(mkStdGen 2)
17:22:57 <amigoo> randomRs (1,5)(mkStdGen 2)
17:23:06 <amigoo> so that gives me same sequence every time?
17:23:12 <Twey> Yes
17:23:13 <Twey> > randomRs (1, 5) $ mkStdGen 2
17:23:15 <lambdabot>   [2,2,3,4,3,5,5,2,4,1,2,3,4,5,1,4,5,4,5,4,1,3,3,4,3,1,3,1,4,5,3,5,2,2,4,2,4,...
17:23:17 <amigoo> how do i make it change every time I call on it?
17:23:20 <Twey> It's pure, so it has to
17:23:42 <Twey> Instead of using a constant seed 2, you should retrieve a random seed from the OS using mkStdGen
17:23:51 <xerox> that's what the seed is for.
17:23:55 <Twey> mkStdGen >>= randomRs (1, 5)
17:24:25 <amigoo> well, is the seed random?
17:24:35 <xerox> :t randomRs (1,5) `fmap` newStdGen
17:24:36 <lambdabot> forall t. (Num t, Random t) => IO [t]
17:24:49 <Twey> Oh, yeah, need a fmap
17:24:57 <Twey> :t randomRs (1, 5) <$> newStdGen
17:24:59 <lambdabot> forall t. (Num t, Random t) => IO [t]
17:25:11 <xerox> amigoo I told you, in your main = do { g <- newStdGen; ... }
17:25:16 <Twey> amigoo: It's pseudo-random, which is as close as you can get to random on a computer without a dedicated source of randomness
17:25:22 <Twey> (and maybe even then)
17:25:31 <xerox> then you supposedly call some pure functions in ... which need a seed, and for that you use g.
17:53:15 <cads> > let public int fib (int n) {int a = 0; int b = 1; int c;  for (int i = 0; i < n; i++) {c = a; a = b; b = c + b;} return a;}   in  fib(10);
17:53:16 <lambdabot>   <no location info>: parse error on input `a'
17:53:52 <Veinor> ... what'd you expect?
17:53:56 <cads> hehe, lambdabot never lets us lie to ourselves - java is terrible
17:54:03 <taruti> Is there a performance difference when calling C->Haskell between 'foreign import "wrapper"' and "foreign export" in GHC if both are possible to use?
17:54:23 * Veinor directs cads towards ##c
17:54:46 <cads> haha
17:59:02 <pastah_rhymez> hiredman: saw your quote on HWN
17:59:04 <pastah_rhymez> nice :D
17:59:12 <pastah_rhymez> HE'S EVERYWHERE!!!
18:01:17 <tommd> taruti: Your question seems confused - you call from C to Haskell if you exported a function via "foreign export".  You call from Haskell to C if use imported a C "function" via "foreign import".
18:01:32 <cads> > let fibs = 0 : scanl (+) 1 fibs in fibs!!10
18:01:33 <lambdabot>   55
18:02:01 <cads> ahhh
18:02:22 <tommd> taruti: If you are wondering if one will have better performance than the other I would expect calling C from Haskell to work better as you can declare the C function 'unsafe' meaning the RTS doesn't have to do any cleanup in expectation of that same C function calling back into Haskell.  OTOH, the Haskell function must always clean up before returning control back to a calling C program.
18:03:02 <c_wraith> @hoogle uncurry4
18:03:02 <lambdabot> No results found
18:03:08 <tommd> @hoogle hoogle
18:03:08 <lambdabot> Can't think of anything more interesting to search for?
18:03:08 <lambdabot> No results found
18:03:16 <tommd> lol
18:03:38 <c_wraith> hah.  hxt defines an uncurry4
18:04:06 <taruti> tommd: I am calling Haskell from C, not the other way round.
18:04:31 <Eduard_Munteanu> How can I use a comboBoxEntry with a specified model/store?
18:04:39 <Eduard_Munteanu> I already use another model store for a list.
18:04:42 <c_wraith> ok, other than uncurry4, is there a convenient way to package up 4 args for a functions?
18:04:48 <c_wraith> *function
18:05:20 <ClaudiusMaximus> @hoogle hoogle -> (hoogle -> moar hoogle) -> moar hoogle
18:05:21 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
18:05:21 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
18:05:21 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
18:06:40 <c_wraith> :t (($1) . ($2) . ($3) . ($4))
18:06:41 <lambdabot> forall a b a1 a2 a3. (Num a, Num a1, Num a2, Num a3) => (a3 -> a2 -> a1 -> a -> b) -> b
18:07:07 <hiredman> pastah_rhymez: huh?
18:07:10 <taruti> they create the same code in the end, so no difference there.
18:07:18 <pastah_rhymez> hiredman: http://sequence.complete.org/hwn/20100110
18:07:32 <pastah_rhymez> hiredman: under "Quotes of the week"
18:07:54 <c_wraith> :t (\a b c d -> (a,b,c,d)) (($1) . ($2) . ($3) . ($4))
18:07:55 <lambdabot> forall t t1 t2 a b a1 a2 a3. (Num a, Num a1, Num a2, Num a3) => t -> t1 -> t2 -> ((a3 -> a2 -> a1 -> a -> b) -> b, t, t1, t2)
18:08:01 <c_wraith> > (\a b c d -> (a,b,c,d)) (($1) . ($2) . ($3) . ($4))
18:08:02 <lambdabot>   ()->
18:08:03 <lambdabot>    ()->
18:08:03 <lambdabot>      ()->
18:08:03 <lambdabot>        (-3->
18:08:03 <lambdabot>          -3->
18:08:04 <lambdabot>            -3->
18:08:06 <lambdabot>          ...
18:08:10 <hiredman> oh crap, is that the dons one?
18:08:23 <elly> :t $1
18:08:24 <lambdabot> parse error on input `$'
18:08:27 <elly> :t ($1)
18:08:29 <lambdabot> forall a b. (Num a) => (a -> b) -> b
18:08:31 <elly> oh dear
18:08:45 <c_wraith> elly, it's just a section of the $ operator
18:08:50 <elly> oh, so it is
18:08:51 <hiredman> oh dear indeed
18:09:03 <elly> for some reason I did not correctly tokenize it as $ 1 :P
18:09:40 <c_wraith> > (($1) . ($2) . ($3) . ($4)) (\a b c d -> (a, b, c, d))
18:09:41 <lambdabot>   (4,3,2,1)
18:11:31 <dolio> \a b c d -> (a, b, c, d) = (,,,)
18:11:43 <c_wraith> err, yes.  thanks for that reminder
18:13:46 <c_wraith> > ($(,,,)) (($1) . ($2) . ($3) . ($4))
18:13:47 <lambdabot>   (4,3,2,1)
18:14:05 <c_wraith> I'd rather write uncurry4 than do that
18:14:12 <copumpkin> orly!
18:14:46 <SubStack> O_O
18:16:55 * SubStack wishes STM had sugar like Data.StateVar
18:20:53 <amigoo> :t randomRs (1, 5) <$> newStdGen
18:20:54 <lambdabot> forall t. (Num t, Random t) => IO [t]
18:21:14 <pastah_rhymez> @t (<$>)
18:21:14 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:21:23 <pastah_rhymez> @type (<$>)
18:21:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:22:23 <amigoo> aww man, haskell is so frustrating
18:22:37 <pastah_rhymez> amigoo: hehe;
18:22:43 <pastah_rhymez> what are you working on?
18:22:59 <amigoo> trying to make a blackjack game
18:23:08 <amigoo> I started last night
18:23:24 <pastah_rhymez> amigoo: the chalmers lab??
18:23:25 <c_wraith> @hoogle liftM4
18:23:25 <lambdabot> Control.Monad liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
18:23:53 <amigoo> no
18:23:56 <pastah_rhymez> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/lab2.html
18:24:29 <merehap> amigoo: going from not knowing programming to writing black jack is quite a leap, are you sure you don't want to try something simpler first?
18:24:42 <pastah_rhymez> merehap: it doesn't have to
18:24:52 <amigoo> I've done blackjack on matlab
18:25:01 <merehap> amigoo: ok, fair enough
18:25:09 <pastah_rhymez> merehap: that lab is what you're forced to do at CS at chalmers on your fourth week in school
18:25:35 <pastah_rhymez> amigoo: do you need some help/pointers?
18:25:39 <merehap> I didn't know how much experience he had, but 4th week seems reasonable
18:26:04 <amigoo> Pastah, yeah I need some pointers if you don't mind
18:26:11 <pastah_rhymez> amigoo:
18:26:12 <pastah_rhymez> @paste
18:26:13 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:26:18 <pastah_rhymez> gimme sum
18:26:31 <pastah_rhymez> HOT SWEET NO-PANTS ACTION!
18:26:48 <pastah_rhymez> or code
18:26:52 <pastah_rhymez> whichever you prefer
18:28:18 <pastah_rhymez> amigoo: gief datatypes etc.
18:29:10 <Veinor> u giev datateip
18:29:22 <amigoo> lol
18:30:30 <c_wraith> @hoogle maybe4
18:30:31 <lambdabot> No results found
18:30:48 <pastah_rhymez> c_wraith: how would that work?
18:31:20 <c_wraith> maybe4 x f a b c d = maybe x (uncurry4 f) $ liftM4 (,,,) a b c d
18:31:59 <c_wraith> nevermind that uncurry4 doesn't exist either
18:42:06 <Alpounet> http://hackage.haskell.org/package/empty-9 :/
18:45:03 <lpjhjdh> Has anyone had success building haskabelle with 6.12.1?
18:50:23 <absentia> crap.  apple store doesn't show any purchaes... it's like a f'n black hole
18:50:29 <absentia> oops, wrong channel. sorry.
18:50:30 <Alpounet> roconnor, your paper about functional implementation of real numbers is very interesting
18:52:51 <Runar> > describeSequence  [12,22,30,36,40,42,42,40,36,30,22,12]
18:52:52 <lambdabot>   Just "Table of LCM(x,y), where (x,y) = (1,1),(1,2),(2,1),(1,3),(2,2),(3,1),...
18:59:18 <pham> how do you install cabal in /usr/local?
18:59:25 <pham> cabal-install I mean
19:06:12 <Raevel> pham: i think it tells you how in cabal help install
19:06:16 <amigoo> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6023#a6023
19:06:50 <dino-> pham: If you're building it from source, you could configure for there.
19:08:27 <danly> Hrm
19:08:38 <danly> Are there any Haskell IDEs that do tag searching and completion?
19:09:00 <danly> MonoDevelop and Visual studio style symbol/terminal suggestion and tab-completion, I mean.
19:09:52 <Raevel> danly: scion is awesome
19:10:06 <pastah_rhymez> http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/Acme-Time-Now.html <-- now that's what i call documentation!
19:10:41 <kamatsu> hm, is it possible using TH to get a list of all functions exported by a module
19:11:00 <kamatsu> i want to programmatically generate lifted bindings for a monad transformer
19:11:07 <danly> Raevel: isn't that just GHC API wrapping?
19:11:31 <Alpounet> haskell-src-ext may be of help too
19:11:50 <Raevel> danly: perhaps
19:11:57 <Alpounet> danly, have you tried leksah ?
19:12:11 <danly> Alpounet: I've only tried Emacs and Yi ;)
19:12:34 <Alpounet> leksah aims at being a true IDE for Haskell
19:12:54 <danly> Aldwuin: that looks nice, I'll give it a try
19:12:54 <Alpounet> it may be very handy for really big libraries / applications.
19:13:17 <danly> Thanks!
19:13:27 <Alpounet> np
19:14:27 <pham> Raevel: it's easy to use cabal-install to install packages globally, but not straight forward to install cabal itself globally afaict
19:16:38 <dino-> pham: Can you install it with your distro's package manager? Mine installed cabal-install in /usr  That would be Arch Linux.
19:18:18 <dino-> Is cabal-install in the Haskell Platform?
19:18:56 <pham> I haven't found an Ubuntu package for it. I just installed it locally and then used the local version to install itself globally
19:19:19 <dino-> pham: Installed it locally using source?
19:19:44 <dino-> Sorry, built from source
19:19:49 <pham> yeah
19:20:30 <dino-> you should be able to configure for /usr/local or whatever you'd like. And do the runhaskell ./Setup.hs install step as root
19:21:07 <sshc> if I license a project under the BSD, do I need to add the BSD license as a comment to each source file?
19:23:00 <dino-> sshc: Not sure if it's required, but I do that, each source file. Unless I miss one here or there, which probably happens. :/
19:23:51 <sshc> dino-: do you use the BSD or GPL and why?
19:25:18 <dino-> sshc: I've been using BSD for all Haskell stuff. I know it's less commando and could allow creepy corp abuse, but otoh that also makes it more reasonable for well-intentioned groups.
19:28:00 <dino-> pham: Is that helping you? I wish I could find you a Debian .deb file or sources.list info. Looking too..
19:28:01 <pastah_rhymez> does matlab use types?
19:29:07 <dino-> I see that cabal-install is part of the Haskell Platform. yay
19:31:20 <sshc> dino-: what kind of abuse?
19:33:00 <sshc> is it possible to pattern match in a lambda without using case?
19:33:00 <dino-> sshc: I guess I'm thinking more of the GPL3 when I say commando. Tightened up to be pretty serious wrt making you distribute sources.
19:34:29 <dino-> sshc: I believe not, can't do multiple definitions.
19:35:07 <Twey> Of course, sshc
19:35:19 <Twey> > (\ (n + 1) -> n) 5
19:35:20 <lambdabot>   4
19:35:44 <bob0> alright, thanks
19:35:56 <uman> I read in SICP earlier today about the concept of "church numerals", a way of defining the nonnegative integers using only the concept of "function"
19:36:03 <bob0> :t (>>)
19:36:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:36:10 <uman> is this system extensible to all integers?
19:36:15 <bob0> @src (>>)
19:36:15 <lambdabot> m >> k      = m >>= \_ -> k
19:36:19 <dino-> I thought we were talking (\(Just x) -> ... [Wait, how do I get the Nothing case?]
19:36:21 <Twey> uman: Positive ones
19:36:24 <Twey> dino-: Same thing
19:36:26 <Twey> You don't
19:36:29 <Twey> Sorry
19:36:35 <uman> Twey: Yes, I said "nonnegative integers" already
19:36:55 <Twey> uman: And then you asked about extending it to all integers you can see how that might be confusing :
19:36:59 <uman> Twey: I was asking if there was a similar representation that includes negative as well as nonnegative integers
19:37:04 <Twey> Ah
19:37:12 <Twey> I don't know of one
19:37:41 <Twey> You can probably write one by using something else as the innermost function
19:38:06 <uman> (I know this has nothing to do with Haskell, per se, but I figure this is the channel most likely to contain people willing to talk about this :) )
19:38:45 <merehap> @pl zipWith (\x y -> if x then y else id)
19:38:45 <lambdabot> zipWith (flip flip id . if')
19:39:00 <mental> uman: the short answer is "of course"
19:39:23 <merehap> ooh, where is "if'" defined, so I don't have to continue using my own custom defined one?
19:39:36 <mental> uman: the slightly longer answer is - everything computable is representable as a function because lambda calculus is turing-complete
19:39:38 <uman> Twey: well, you could also just do one by brute force, doing something like making a pair represent an arbitrary integer, and if the first element of the pair is "0" then it is interpreted as positive, otherwise negative
19:39:52 <uman> but then things like the + function wouldn't be very elegant at all
19:39:54 <mental> and the even longer answer is what you said :)
19:40:14 <uman> mental: I see :)
19:40:27 <Twey> merehap: Data.HigherOrder has (??) and bool.
19:40:31 <monochrom> I would do a sign-magnitude representation. You have got naturals. You can also get bool and tuple. Now make a tuple of bool,natural.
19:40:40 <roconnor> Alpounet: which paper?
19:40:43 <Twey> Oh, that's nicer
19:40:45 <uman> monochrom: isn't that what I just said?
19:40:54 <uman> monochrom: (essentially)
19:41:07 <merehap> Twey: thanks, that will come in handy
19:41:36 <monochrom> I am lagged.
19:41:57 <uman> monochrom, accursed lag! I feel your pain.
19:42:42 <chrisf|work> uman: you can get from naturals to integers with pairs more elegantly than that; a pair (a,b) interpreted as a - b works fine.
19:42:48 <uman> mental: I keep hearing about "lambda calculus" but I'm not fully sure what it is, and the WP article is a bit high-brow. How much background is necessary to understand it?
19:43:01 <mental> uman: do you know haskell?
19:43:21 <uman> mental: No. :(
19:43:39 <mental> uman: do you know anonymous functions from any programming language?
19:43:46 <uman> mental: Yes
19:43:56 <chrisf|work> uman: if you want to extend to triples of naturals, then you've got all of Q ;)
19:43:57 <mental> uman: ok, imagine a language that has nothing except anonymous functions
19:43:57 <monochrom> is reading SICP.
19:44:52 <mental> uman: since there's nothing except functions, the arguments of your functions are all functions too, and everything a function can do is call its arguments on other arguments.
19:45:45 <mental> uman: that's lambda calculus, and it turns out it's turing-complete
19:47:17 <Twey> Unary anonymous functions
19:47:59 <mental> they're not unary in canonical lambda calculus
19:48:09 <mental> afaik
19:48:16 <mental> it doesn't really matter either way
19:50:00 <uman> mental: that was a very good overview, thanks.
19:50:07 <uman> (sorry I had to go AFK for a moment)
19:52:51 <uman> So, when I was asking about extending Church numerals from N to Z, the real reason I was asking was because I was curious about whether Scheme (or I suppose any similar language) could in principle be built up using nothing but the concept of function
19:53:07 <copumpkin> uman: yes, definitely
19:53:08 <uman> it seems that the answer is "yes", and that the result would be basically syntactic sugar for the lambda calculus
19:56:26 <uman> this is by far my favorite channel on Freenode
19:56:57 <copumpkin> :)
19:57:01 <chrisf|work> few other channels actively indulge in this level of abstract nonsense ;)
19:57:20 <dolio> Using N*N gets you a lot of redundant elements, and if you reduce to canonical forms, you get either (Z,n) or (m,Z), which is pretty close to Bool*N.
19:58:04 <chrisf|work> dolio: i didnt claim lack of redundancy.
19:58:08 <uman> chrisf|work: this could be the MS Windows support channel and I'd still like it just as much. It's more the friendliness and willingness to help of the people in here than the specific content of what's being discussed.
19:58:20 <dolio> I know, but lack of redundancy is a good thing to have.
19:58:55 <chrisf|work> dolio: sorry, i should have been more precise; the integers are equivalence classes on N*N, not elements of N*N.
19:59:27 <monochrom> Very hard in practice. Usually you must live with redundancy or junk.
19:59:44 <copumpkin> how can you be free with redundancy and junk!
20:00:09 <tomas_> quick way to add a tab character to the beginning of every line in a String?
20:00:32 <copumpkin> tomas_: unlines . map ('\t':) . lines
20:00:34 <merehap> > canPalin "make a language free from redundancy and junk?"
20:00:35 <lambdabot>   Not in scope: `canPalin'
20:00:36 <tomas_> thanks
20:00:38 <idnar> darn, beat me to it
20:00:40 <chrisf|work> copumpkin: too fast.
20:00:42 <dolio> If you had a language with quotient types, N*N/whatever could be nice.
20:00:52 <idnar> what the heck is a quotient type?
20:00:54 <xerox> chrisf|work more interesting is the next step, the rationals as equivalence classes of pairs of integers
20:00:54 <dolio> Those are in short supply, though.
20:01:03 <merehap> @let canPalin = const "You betcha!"
20:01:04 <lambdabot>  Defined.
20:01:08 <merehap> > canPalin "make a language free from redundancy and junk?"
20:01:09 <lambdabot>   "You betcha!"
20:01:16 <monochrom> ...
20:01:18 <tomas_> copumpkin: still learning...
20:01:23 <chrisf|work> xerox: i'll take rationals as equivalence classes of triples of naturals, if it's all the same to you.
20:01:28 * copumpkin was trying to make a really lame joke about free constructions
20:01:32 <copumpkin> but it was pretty weak
20:01:54 <copumpkin> chrisf|work likes redundancy
20:02:22 <monochrom> The problem with free constructions is that they are a minority among interesting constructions.
20:02:30 <xerox> chrisf|work I mean it's interesting because if you look carefully you just need some properties of the integers, namely being a ring with unity without zero divisors (a domain): so you can get a "natural" field from every domain that way, called its "field of fractions"
20:02:35 <Veinor> what's the language existention for existential types?
20:02:43 <copumpkin> ExistentialQuantification
20:02:56 <monochrom> -fglasgow-exts  <duck>
20:03:04 <copumpkin> lol
20:03:14 <copumpkin> GADTs
20:03:29 <Veinor> I'm writing something on 'how to write variadic functions'
20:03:33 <monochrom> EGADTs
20:04:30 <copumpkin> onoes
20:04:31 <monochrom> existential types have not been used for variadic functions.
20:04:46 <copumpkin> you could do it though
20:04:55 <copumpkin> sounds fugly though
20:04:59 <copumpkin> :P
20:05:21 <monochrom> Text.Printf shows how to do it with just typeclass.
20:05:51 <dolio> idnar: Quotient types are types defined by taking some existing type and identifying equivalence classes of elements according to some equivalence relation, such that every construct in the language can't distinguish one element of the equivalence class from any other.
20:05:58 <dolio> Or some similar facility.
20:06:26 <copumpkin> dolio: how does that tie in with the elementary notion of quotient?
20:06:42 <copumpkin> you're factoring out the common-ness?
20:07:32 <dolio> Something like that.
20:08:31 <xerox> what was that.. species?
20:09:22 <dolio> I mean, it's pretty obviously similar to "quotient" as used in set or group theory.
20:09:57 <copumpkin> yeah, but I have no mathematical background :)
20:10:00 <copumpkin> I'll look those up though
20:11:11 <chrisf|work> with a name like `copumpkin`, you might want to remedy that ;)
20:11:47 <monochrom> Not to mention god of copumpkins
20:11:57 <copumpkin> :) I used to be pumpkin but with all the co-this and co-that being thrown around here I accidentally got my arrows reversed in the crossfire
20:12:21 <chrisf|work> haha, well done.
20:14:55 <Philonous> 1 co- 1 contravariant pumpkin
20:16:20 <opdolio> I was going to say it seems more similar to modular arithmetic, but the notation used doesn't really support that.
20:16:22 <monochrom> god of copumpkins and cogod of pumpkins are in adjunction.
20:16:41 <copumpkin> cogod == dog?
20:17:29 <opdolio> Since from a modular viewpoint you'd probably think that {0,1} = Z mod 2. But it's typically written as the quotient group Z/2Z.
20:17:32 <copumpkin> there's a free monad and a cofree comonad, but are there free comonads and cofree monads?
20:18:06 <contrapumpkin> what is cofree?
20:18:33 <xerox> opdolio actually that is the perfect example to understand the notion in general
20:18:50 <copumpkin> contrapumpkin: I don't even know how it's represented in CT, actually
20:19:04 <copumpkin> Cofree f a = (a, f (Cofree f a)) iirc
20:19:21 <contrapumpkin> what is free then?
20:19:58 <copumpkin> Free f a = Either a (f (Free f a)) or something like that
20:20:11 <copumpkin> actually not quite?
20:20:16 <copumpkin> I can never remember how free works
20:21:45 <opdolio> Yes, that's right.
20:21:50 <Eduard_Munteanu> How do I convert a string to a number, simply do 'read' on it?
20:22:01 <copumpkin> if my piece of shit macbook air didn't overheat when browsing the web I'd load up a webpage with more on it :)
20:22:04 <contrapumpkin> yes
20:22:07 <copumpkin> and sound more edumacated
20:22:15 <Eduard_Munteanu> contrapumpkin, thanks.
20:22:44 <p_l> copumpkin: well, you got yourself Macbook Air, aka "fashion accesory". What were you expecting? ;-)
20:22:49 <copumpkin> contrapumpkin: so do you do the opposite of everything pumpkin does?
20:22:54 <xerox> ( something like Z mod 2 = { z mod 2 | z in Z } = { { 0 + 2*z } | z in Z } U { { 1 + 2*z } | z in Z } = { 0 + 2Z, 1 + 2Z } = Z mod 2Z )
20:23:14 <copumpkin> p_l: something I could at least browse the web on... not a heavy duty number crunching machine but this is ridiculous
20:23:17 <copumpkin> it's super light and I travel a lot
20:23:42 <contrapumpkin> contrapumpkin: sure
20:23:45 <p_l> copumpkin: You should have got a Toshiba or Dell then, maybe an IBM/Lenovo X-series thinkpad ;-)
20:24:07 <leimy> Toshiba's are pretty good.
20:24:14 <leimy> I like my unibody macbook though
20:24:18 <copumpkin> they don't run mac os nicely :)
20:24:25 <leimy> dual core, 64bit, 4GB of memory.
20:24:35 <leimy> I've been living on it for about 1 year.
20:24:40 <leimy> no major problems of any kind
20:26:10 * contrapumpkin runs an acer not a mac book
20:26:18 <kamatsu> ew, acer
20:26:21 <p_l> leimy: I had seen a funny sight, once, short time after Air's introduction... in a shop, a Toshiba R500 (I think it was R500) and an Air were standing side by side, Toshiba being a fully beefed-up model, Macbook I think too... Toshiba was both *smaller* and *cheaper* and *more powerful*
20:26:42 <leimy> macbook air is not designed for power users
20:26:46 <leimy> not in the slightest
20:27:00 <opdolio> Free things are produced by left adjoints (as I recall, I have trouble remembering) to forgetful functors.
20:27:04 <kamatsu> leimy: so? it's still cheaper and smaller
20:27:11 <copumpkin> leimy: I know, but I'm not trying to be a power user, I'm trying to browse the fucking web and read IRC
20:27:12 <kamatsu> (than the macbook)
20:27:13 <leimy> that said, I used to have a Toshiba Tecra 8100 that lasted forever :-)
20:27:17 <opdolio> So if there's a difference, it's probably that cofree things are produced by right adjoints.
20:27:38 <opdolio> But it might just be a naming convention that co-things are cofree. I'm not sure.
20:27:39 <leimy> kamatsu: and running what operating system? :-)
20:27:59 <p_l> that's why I call it a fashion accessory. For everything else, I can easily find a replacement (and OSX doesn't convince me)
20:28:00 <leimy> Currently the only legal way to run the OS I want is to buy a mac :-)
20:28:09 <copumpkin> opdolio: the either/(,) distinction seems to imply a product/coproduct? where would that come in?
20:28:28 <QtPlaty[HireMe]> leimy: There are hacks that allow ou to run macos on nonmacs
20:28:38 <leimy> QtPlaty[HireMe]: yes, I said "legal" :-)
20:28:43 <p_l> leimy: depends on the country, at least in some the EULA clause "only Apple hw" could be contested
20:28:44 <copumpkin> it's also not pleasant
20:28:49 <copumpkin> I used to be very involved in that scene
20:28:51 <leimy> p_l: yep
20:28:53 <kamatsu> leimy: right, it really depends on the price difference, but I would say that 99.9% of the time, OS X is just not worth it.
20:29:01 <leimy> my country is not one of them.
20:29:08 <leimy> kamatsu: that's a personal judgement call.
20:29:14 <leimy> I don't like to run linux anywhere
20:29:19 <copumpkin> kamatsu: that's objective, right? ;)
20:29:19 <kamatsu> why is that?
20:29:23 <kamatsu> copumpkin: sure
20:29:23 <leimy> so I keep FreeBSD boxes, and Mac OS X for a desktop :-)
20:29:26 <kamatsu> hence the "i would say"
20:29:28 <p_l> leimy: I'm not sure, but I think Polish reverse-engineering law would allow you to run OSX on non Apple hw... it's a kind of gray area
20:29:38 <kamatsu> leimy: you don't like xmonad :O :P
20:29:40 <copumpkin> kamatsu: oh I missed that
20:29:50 <leimy> kamatsu: nope I really don't like xmonad
20:29:55 <leimy> I actually don't hate my mouse
20:30:01 <p_l> and yes, one of the reasons why I don't like OSX is that it doesn't run XMonad well :D
20:30:01 <kamatsu> but.. but..
20:30:10 <kamatsu> all haskellers love xmonad, it's like, a rule
20:30:13 <leimy> in fact, a lot of the tools I've learned to use are mouse driven
20:30:18 <p_l> leimy: I don't hate the mouse, but I hate touchpad
20:30:21 <leimy> heh
20:30:28 <leimy> yeah they can be really annoying.
20:30:40 <leimy> I got really used to editing with Acme and Sam in Plan 9
20:30:48 <leimy> so I run those on Mac OS X sometimes
20:30:57 <leimy> (there's ports)
20:31:01 <p_l> Trackpoint is better, but it's still annoying. On a desktop, I used to run a rather mouse-involved FVWM setup
20:31:08 <kamatsu> leimy: ah, so you take your usability advice from Rob Pike?
20:31:17 <leimy> kamatsu: not all of it
20:31:26 <kamatsu> leimy: i work next to rob pike
20:31:28 <leimy> he would tell me I've lost my way if I told him I used Emacs at all :-)
20:31:37 <leimy> kamatsu: Rob Pike and I have emailed a few times :-)
20:31:43 <copumpkin> no OS wars in #haskell kthx
20:31:48 <kamatsu> leimy: you were involved in Plan 9?
20:31:50 <kamatsu> or Go?
20:32:06 <leimy> kamatsu: I'm a plan 9 user, and Rob and I are on the same google wave for plan 9 fans :-)
20:32:08 <p_l> kamatsu: I consider Acme to be a great editor, assuming you've got a chording keyboard - having one hand for mouse, another for keyboard input would be great
20:32:24 <leimy> p_l: I have a 4 button trackball that I just love.
20:32:30 <leimy> and it's good for the chording.
20:32:32 <kamatsu> rob pike comes to google sydney in summer, i'm on the wave team so i had a chat to him the other day
20:32:48 <leimy> nice.  He's a pretty reasonable fellow IMO.
20:32:51 <kamatsu> yeah
20:32:58 <opdolio> copumpkin: From what I can find on a google search (which isn't much), it sounds like my first guess was correct.
20:33:06 <kamatsu> leimy: trackballs are great
20:33:08 <leimy> I emailed him once thinking I found a bug in the source in The Practice of Programming.
20:33:12 <opdolio> Cofree things involve right adjoints instead of left adjoints.
20:33:13 <leimy> then I realized it wasn't a bug after all
20:33:16 <kamatsu> haha
20:33:22 <leimy> and I told him I was going to go hide under my desk now or something.
20:33:31 <leimy> he was like "thanks for the feedback, what bug??"
20:33:31 <copumpkin> opdolio: ah okay... I'll take a look for it myself when my computer stops being a slug
20:33:52 <kamatsu> lol
20:34:03 <opdolio> copumpkin: It was just a couple phrases from google summaries.
20:34:09 <copumpkin> yeah
20:34:53 <kamatsu> hm, so the only user group i'm aware of that features Haskell in sydney is fp-syd
20:34:58 <kamatsu> is there a haskell specific one?
20:35:06 <kamatsu> or not enough haskellers in sydney =(
20:35:47 <opdolio> copumpkin: nlab confirms, sort of. They don't actually have an article on cofree things, but it's mentioned in other articles.
20:37:18 <leimy> You know what I love best about hyperterminal?
20:37:22 <leimy> nothing at all.
20:37:34 <tommd> It often works...
20:37:38 <leimy> yeah it can
20:37:41 <tommd> Often not being a complement in the computer world.
20:37:44 <tommd> "often"
20:37:46 <leimy> heh
20:37:53 <leimy> it's working now.
20:38:01 <leimy> but i wanted to search the scrollback, silly me.
20:38:07 <tommd> minicom ftw?
20:38:19 <leimy> Hmmm maybe, if it works with Cygwin
20:38:34 <opdolio> Probably the best way to explain [linear logic] to a category theorist is to say that its models are *-autonomous categories with extra structure
20:38:41 <leimy> these people I contract with insist on having me do remote windows connections to hyperterm sessions to a VxWorks board :-)
20:38:44 <opdolio> Oops, forgot the quotation marks.
20:40:41 <leimy> I just realized one of my blog posts went to reddit :-)
20:40:47 <leimy> I did not submit
20:40:50 <leimy> someone is following me
20:40:51 <leimy> :-)
20:42:38 <felzix> what post?
20:43:10 <leimy> I was scribbling about some stuff I thought the haskell community could use.
20:43:13 <leimy> mainly documentation.
20:43:30 <leimy> not that I mind the traffic.
20:43:34 <leimy> I was just surprised.
20:43:42 <felzix> ok
20:44:26 <tensorpudding> i think i see that post
20:45:10 <tensorpudding> i've seen your blog linked to by dons before though
20:45:24 <leimy> so berlios was hacked
20:45:33 <leimy> tensorpudding: hey you're right.
20:45:41 <leimy> that's the site that hosts mercurial
20:45:49 <leimy> IRC
20:45:53 <leimy> er iirc :-)
20:47:51 <monochrom> why does haskell reddit get a unicorn fish (unicorn dolphin? unicorn whale?) for logo? :)
20:48:39 <tensorpudding> narwhal
20:48:48 <tensorpudding> it's a real marine mammal
20:49:04 <tensorpudding> and i think it's a joke because reddit really like narwhals?
20:51:54 <kamatsu> tensorpudding: yes, bacon!
20:52:01 <tensorpudding> someone made a haskell logo using a narwhal for submission into the contest, it wasn't picked but it was used for the haskell subreddit
20:52:26 <kamatsu> before we had the official logo, but dons changed it back to narwhal
20:52:47 <Veinor> why does printf have an IsChar instance
20:52:51 <Veinor> er, class
20:52:51 <amigoo> :d
20:52:53 <Veinor> whose only instance is Char
20:53:05 <tensorpudding> http://www.haskell.org/haskellwiki/Image:NarleyYeeaaahh.jpg
20:53:15 <tensorpudding> the version submitted to the haskell logo contest
20:57:26 <kamatsu> haha
20:57:30 <monochrom> Veinor: because Haskell98 doesn't like, say, instance PrintfType [Char], but accepts, say, instance MyClass c => PrintfType [c]. See PrintfType class.
20:57:38 <sshc> how do I disable morphism restrictin in a source file?
20:57:42 <kamatsu> i prefer the current logo, actually, it would go well on militiary shoulder pads
20:57:55 <kamatsu> so when we inevitably militiarize the haskell community, it'll be stylish
20:58:53 <monochrom> sshc: {-# LANGUAGE NoMonomorphismRestriction #-}
20:58:54 <tensorpudding> my first thought on the new logo was that it reminded me of trains
20:59:09 <tensorpudding> or airplanes
20:59:33 <mental> the carts symbolize monadic actions joined together
20:59:38 <kamatsu> it looks kind of like a logo for a transport company. i guess
20:59:58 <tensorpudding> "haskell on tarmac" doesn't have the same ring though
21:00:05 <mental> http://homepage.mac.com/lpetrich/www/transit/Amtrak_Logo.gif
21:00:25 <kamatsu> >>= amtrak?
21:00:25 <tensorpudding> yes, that is why
21:00:34 <kamatsu> type error
21:00:49 <kamatsu> amtrak isn't of type a -> M b afaik
21:01:08 <tensorpudding> amtrak expects type Train, inferred (Monad m) => a -> m b
21:01:13 <idnar> haha
21:01:19 <mental> it puts you inside a train cart
21:01:24 <mental> from which you cannot escape EVER
21:01:26 <tensorpudding> "a monad is like a train"
21:01:32 <kamatsu> unsafeGetOutOfTrain $
21:01:41 <mental> that's a great metaphor!
21:01:46 <mental> let's write a tutorial based on it!
21:01:47 <kamatsu> haha
21:01:53 <tensorpudding> a monad is like a comonad
21:02:15 <kamatsu> a monad is a monoidal object in a category of endofunctors /oblig
21:02:16 <idnar> unsafeEmergencyExitBreakGlass
21:02:30 <kamatsu> idnar: perfect!
21:02:33 <tensorpudding> unsafeDerailIO
21:02:46 <kamatsu> lol
21:03:03 <idnar> so what's a comonad then?
21:03:15 <tensorpudding> a comonad is like a monad
21:03:21 <kamatsu> no, in terms of trains?
21:03:31 <kamatsu> ah, hm
21:03:35 <idnar> no, I mean in category theory
21:03:41 <kamatsu> oh
21:03:59 <mental> what's the dual category of Hask?
21:04:47 <tensorpudding> the opposite category?
21:06:41 <tensorpudding> the dual category has all objects the same, and all morphisms the same except reversed
21:15:34 <mmorrow> which then turns products/sums into sums/products, pullbacks/pushouts into pushouts/pullbacks, equalizers into (co)equalizers, etc in the dual category
21:15:35 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
21:16:17 <mmorrow> hpaste is fixed now
21:17:19 <mmorrow> which is the same as saying limits/colimits become colimits/limits in the dual category
21:20:49 <tensorpudding> covariant and contravariant functors aren't exactly dual but they involve similar concepts
21:45:51 <Veinor> monochrom: that's what I thought.
21:57:13 <dfrey> Is there a standard function that negates a comparison?  eg.  LT -> GT, EQ -> EQ and GT -> LT?
21:57:51 <copumpkin> class Group a where
21:58:43 <lpjhjdh> @hoogle Ordering -> Ordering
21:58:43 <lambdabot> Prelude pred :: Enum a => a -> a
21:58:44 <lambdabot> Prelude succ :: Enum a => a -> a
21:58:44 <lambdabot> Prelude id :: a -> a
21:59:51 <dfrey> lpjhjdh: Was that for my benefit?
22:00:01 <lpjhjdh> dfrey: yeah
22:00:13 <copumpkin> dfrey: I'd guess no such function then, although you could do
22:00:14 <lpjhjdh> dfrey: and my own interest :)
22:00:29 <copumpkin> :t toEnum . (2-) . fromEnum :: Ordering -> Ordering
22:00:30 <lambdabot> Ordering -> Ordering
22:00:43 <copumpkin> > toEnum . (2-) . fromEnum $ [LT..]
22:00:44 <lambdabot>   <no location info>: parse error on input `]'
22:00:51 <aep> hm i have a list of lists ( a table) and would like to flip rows and columns. ie make [[1,2,3][1,2,3][1,2,3]]    to  [[1,1,1],[2,2,2],[3,3,3]]     any idea on that?
22:00:55 <copumpkin> > (toEnum . (2-) . fromEnum) . [LT..]
22:00:55 <lambdabot>   <no location info>: parse error on input `]'
22:01:07 <copumpkin> > (toEnum . (2-) . fromEnum) . [LT ..]
22:01:08 <lambdabot>   [* Exception: Prelude.Enum.().toEnum: bad argument
22:01:11 <dfrey> heh
22:01:15 <copumpkin> guess not :P
22:01:25 <lpjhjdh> is anyone familiar with haskabelle?  I'm getting weird results for a simple definition of a coproduct datatype
22:01:32 <copumpkin> > (toEnum . (2-) . fromEnum) . [LT ..] :: [Ordering]
22:01:33 <lambdabot>   [GT,EQ,LT]
22:01:35 <copumpkin> there
22:02:02 <tensorpudding> that is way too hackish
22:02:19 <tensorpudding> but pretty neat
22:03:18 <copumpkin> > toEnum . (2-) . fromEnum . [LT ..] :: [Ordering]
22:03:19 <lambdabot>   [GT,EQ,LT]
22:03:27 <copumpkin> for ultimate abuse
22:03:47 <Axman6> argh >_<
22:03:55 <dfrey> Depending on the order of items in an eumerated type makes me throw up in my mouth
22:04:12 <copumpkin> > toEnum . (2-) . fromEnum . [LT, EQ, GT] :: [Ordering] -- hrrmpf, there
22:04:13 <lambdabot>   [GT,EQ,LT]
22:04:24 <copumpkin> ;)
22:06:03 <kmc> > transpose [[1,2,3][1,2,3][1,2,3]] -- aep
22:06:04 <lambdabot>   Couldn't match expected type `t -> t1 -> [a]'
22:06:04 <lambdabot>         against inferred type...
22:06:09 <kmc> > transpose [[1,2,3],[1,2,3],[1,2,3]] -- aep
22:06:10 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3]]
22:07:32 <dfrey> My solution   (flip (compare `on` length)) instead of (compare `on` length)
22:07:42 <dfrey> duh
22:07:57 <kmc> nice
22:08:47 <kmc> > map (EQ `compare`) [LT, EQ, GT]
22:08:48 <lambdabot>   [GT,EQ,LT]
22:09:01 <aep> nice thanks
22:12:25 <sshc> I don't understand how Curry's paradox is paradoxical
22:12:36 <sshc> "If this statement is true, then Santa Clause exists"
22:12:43 <sshc> That statement can be false
22:13:05 <sshc> which doesn't imply the inverse
22:13:50 <kmc> if A -> B is false, then A holds and yet B is false
22:14:00 <kmc> that is the only "false" cell in the truth table for implication
22:14:13 <tensorpudding> A => B is always true for any B if A is false
22:15:06 <kmc> @djinn Not (A -> B) -> A
22:15:07 <lambdabot> Error: Undefined type A
22:15:12 <kmc> @djinn Not (a -> b) -> A
22:15:13 <lambdabot> Error: Undefined type A
22:15:15 <kmc> @djinn Not (a -> b) -> a
22:15:15 <lambdabot> -- f cannot be realized.
22:15:20 <kmc> hmm, that must be classical
22:16:21 <tensorpudding> hmm
22:16:35 <copumpkin> kmc: would make sense
22:16:55 <tensorpudding> B => (A => B)
22:17:15 <kmc> @djinn b -> (a -> b)
22:17:15 <lambdabot> f a _ = a
22:17:18 <kmc> easy enough
22:17:24 <tensorpudding> yeah, it's const
22:17:28 <tensorpudding> i think
22:17:28 <kmc> yeah
22:17:32 <Axman6> :o
22:17:33 * tensorpudding is reading TTPL
22:17:43 <copumpkin> ((a -> b) -> Void) -> a seems pretty unlikely :)
22:18:10 <kmc> copumpkin, right.  you need to be able to reason that the (a -> b) argument to ((a -> b) -> Void) is useless without an a
22:18:15 <kmc> and that's a classical sort of reasoning
22:18:19 <copumpkin> yeah
22:19:05 <kmc> @djinn Either (a -> b) (Not (a -> b)) -> Not (a -> b) -> a
22:19:05 <lambdabot> -- f cannot be realized.
22:19:44 <tensorpudding> @djinn a -> b
22:19:45 <lambdabot> -- f cannot be realized.
22:19:58 <sshc> kmc: are you implying that the antecedent (however you spell it) is always true?
22:20:10 <kmc> @coq (forall a, a \/ ~a) -> ~ (a -> b) -> a
22:20:10 <lambdabot> Maybe you meant: do faq yow
22:20:19 <kmc> sshc, if (A -> B) is false, then A is true
22:20:25 <tensorpudding> how do you get conjunction and disjunction with @djinn?
22:20:33 <kmc> (,) and Either resp.
22:20:46 <tensorpudding> hmm
22:21:02 <kmc> @djinn Either a b -> a
22:21:03 <lambdabot> -- f cannot be realized.
22:21:03 <tensorpudding> @djinn ((a -> b), a) -> b
22:21:03 <lambdabot> f (a, b) = a b
22:21:16 <kmc> :t uncurry ($)
22:21:17 <lambdabot> forall b b1. (b -> b1, b) -> b1
22:21:31 <tensorpudding> i'll ponens your modus
22:22:28 <sshc> kmc: why is that true?
22:22:51 <tensorpudding> @djinn (Either (a -> b) (c -> b), a) -> b
22:22:51 <lambdabot> -- f cannot be realized.
22:23:28 <Saizan> @djinn Not (Not (Not (a -> b) -> a))
22:23:29 <lambdabot> f a = void (a (\ b -> void (b (\ c -> void (a (\ _ -> c))))))
22:23:39 <Saizan> that's why :)
22:24:04 <tensorpudding> @djinn (Either a b, (a -> c, b -> c)) -> c
22:24:04 <lambdabot> f (a, (_, b)) =
22:24:04 <lambdabot>     case a of
22:24:04 <lambdabot>     Left c -> (_) c
22:24:04 <lambdabot>     Right d -> b d
22:24:36 <sshc> Saizan: were you responding to me?
22:24:40 * sshc looks up djinn
22:24:48 <tensorpudding> @djinn (Either (a -> b) (c -> b), (a,b)) -> b
22:24:49 <lambdabot> f (a, (_, b)) =
22:24:49 <lambdabot>     case a of
22:24:49 <lambdabot>     Left c -> c (_)
22:24:49 <lambdabot>     Right _ -> b
22:25:18 <tensorpudding> err wait
22:25:27 <tensorpudding> @djinn (Either (a -> c) (b -> c), (a,b)) -> c
22:25:28 <lambdabot> f (a, (_, b)) =
22:25:28 <lambdabot>     case a of
22:25:28 <lambdabot>     Left c -> c (_)
22:25:28 <lambdabot>     Right d -> d b
22:26:17 <Axman6> c (_)?
22:26:21 <Veinor> what does it mean when I want printf to return an IO r?
22:26:29 <tensorpudding> @djinn Not a -> a
22:26:29 <lambdabot> -- f cannot be realized.
22:26:37 <Axman6> Veinor: that it prints it
22:26:43 <Axman6> @src Not
22:26:44 <lambdabot> Source not found. Are you on drugs?
22:26:45 <Saizan> sshc: yup
22:26:47 <Axman6> no
22:26:47 <tensorpudding> hmm, how about LEM
22:27:10 <tensorpudding> @djinn (Not a, a)
22:27:10 <lambdabot> -- f cannot be realized.
22:27:11 <Veinor> Axman6: well then why is it IO r as opposed to just IO ()
22:27:22 <Saizan> sshc: basically, (a -> b) is false only when a is true and b is false, with classical reasoning you can exploit this to derive a proof of a
22:27:25 <Veinor> because I'm getting undefineds casting printf "%s" "foo" to anything but IO ()
22:27:28 <Axman6> no idea, does r have any constraints?
22:27:37 <Veinor> nope.
22:28:10 <Saizan> the results of the IO action will always be undefined
22:28:16 <Veinor> yeah.
22:28:23 <tensorpudding> @djinn Not (Not a, a)
22:28:23 <lambdabot> f (a, b) = a b
22:28:27 <Saizan> i don't remember why it's 'r' rather than (), though
22:28:35 <Veinor> . printf "%s" "fff" :: IO [Integer]
22:28:39 <Veinor> > printf "%s" "fff" :: IO [Integer]
22:28:40 <lambdabot>   <IO [Integer]>
22:28:47 <Veinor> oh yeah.
22:29:06 <Veinor> well at the end of the definition of spr for IO a, it returns undefined
22:29:13 <Veinor> so if you ever try to evaluate it, you fail.
22:29:19 <tensorpudding> @djinn ((A => B), (B => C)) => (A => C)
22:29:19 <lambdabot> Cannot parse command
22:29:27 <tensorpudding> err right
22:29:39 <kmc> :t uncurry (flip (.))
22:29:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (f a, a -> b) -> f b
22:30:00 <kmc> ffs
22:30:03 <tensorpudding> @djinn (a -> b, b -> c) -> (a -> c)
22:30:03 <lambdabot> f (a, b) c = b (a c)
22:30:30 <kmc> tensorpudding, (Not a, a) is (Not a) and a
22:30:33 <tensorpudding> @pl \(a,b) c -> b (a c)
22:30:33 <lambdabot> uncurry (flip (.))
22:30:33 <sshc> Saizan: oh, I understand now
22:30:59 <tensorpudding> yeah
22:31:20 <tensorpudding> @djinn Either a (Not a)
22:31:21 <lambdabot> -- f cannot be realized.
22:31:47 <kmc> djinn only understands rank-1 types, which means it can't do predicate logic
22:31:58 <tensorpudding> too bad
22:32:42 <Saizan> you need dependent types for predicate logic
22:33:15 <tensorpudding> @djinn (a, (Either b c)) -> Either (a, b) (a, c)
22:33:15 <lambdabot> f (a, b) =
22:33:15 <lambdabot>     case b of
22:33:15 <lambdabot>     Left c -> Left (a, c)
22:33:15 <lambdabot>     Right d -> Right (a, d)
22:34:01 <Saizan> (the use of quantifiers in haskell gives you an higher-order propositional one)
22:34:05 <tensorpudding> @djinn Either a (b, c) -> (Either a b, Either a c)
22:34:05 <lambdabot> f a =
22:34:05 <lambdabot>     case a of
22:34:05 <lambdabot>     Left b -> (Left b, Left b)
22:34:05 <lambdabot>     Right (c, d) -> (Right c, Right d)
22:34:57 <copumpkin> a + (b * c) = (a + b) * (a + c)
22:35:06 <copumpkin> nice distributive law
22:35:41 <tensorpudding> @djinn Not (a,b) -> Either (Not a) (Not b)
22:35:41 <lambdabot> -- f cannot be realized.
22:35:58 <tensorpudding> huh
22:36:00 <copumpkin> it's pretty hard to go from Not anything to something
22:36:00 <tensorpudding> no demorgan?
22:36:25 <Saizan> not all directions of demorgan hold in intuitionistic logics
22:36:51 <tensorpudding> @djinn Not (Either a b) -> (Not a, Not b)
22:36:52 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
22:36:59 <kmc> @type let peirce :: ((a -> b) -> a) -> a; peirce = undefined in peirce (\k -> Left (\a -> k (Right a)))
22:37:00 <lambdabot> forall b b1. Either (b1 -> b) b1
22:37:12 <kmc> peirce aka call/cc
22:39:18 <kmc> @type callCC (\k -> return $ Left (\a -> k (Right a)))
22:39:19 <lambdabot> forall b (m :: * -> *) b1. (MonadCont m) => m (Either (b1 -> m b) b1)
22:39:35 <tensorpudding> @type callCC
22:39:36 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
22:39:40 <kmc> now read m as a modal operator "is classically true"
22:39:43 <kmc> :O
22:40:47 <Saizan> mh, i don't like that -> m b
22:40:53 <kmc> hmm but m a -> (a -> m b) -> m b fails for that interpretation
22:41:13 <Saizan> ?djinn Not (Not (Either (Not a) a))
22:41:14 <lambdabot> f a = void (a (Left (\ b -> a (Right b))))
22:41:37 <tensorpudding> it's so freaky to compare functions in programming languages to statements of logic
22:41:51 <kmc> tensorpudding, yes
22:41:53 <Saizan> @type callCC (\k -> k $ Left (\a -> k (Right a)))
22:41:54 <lambdabot>     Occurs check: cannot construct the infinite type:
22:41:54 <lambdabot>       b = Either (b1 -> m b) b1
22:41:54 <lambdabot>       Expected type: m (Either (b1 -> m b) b1)
22:41:57 <kmc> some very smart dudes figured out that you can do this
22:42:01 <copumpkin> tensorpudding: you should play with agda :)
22:42:06 <kmc> and it's been blowing minds ever since
22:42:13 <kmc> also Coq
22:43:28 <Saizan> @type let callCC :: ((forall b. a -> m b) -> m a) -> m a in callCC (\k -> k $ Left (\a -> k (Right a)))
22:43:30 <lambdabot>     The type signature for `callCC' lacks an accompanying binding
22:43:30 <lambdabot>       (You cannot give a type signature for an imported value)
22:43:43 <Saizan> @type let callCC :: ((forall b. a -> m b) -> m a) -> m a; callCC = undefined in callCC (\k -> k $ Left (\a -> k (Right a)))
22:43:44 <lambdabot> forall (m :: * -> *) b b1. m (Either (b -> m b1) b)
22:43:55 <Saizan> d'oh
22:44:15 <ski> @djinn Either (Not a) (Not b) -> Not (a,b)
22:44:16 <lambdabot> f a =
22:44:16 <lambdabot>     case a of
22:44:16 <lambdabot>     Left b -> \ (c, _) -> b c
22:44:16 <lambdabot>     Right d -> \ (_, e) -> d e
22:44:32 * ski wonders why one can't give a type signature for an imported value
22:45:50 <Saizan> it'd be a nice way to declare precise dependencies, actually
22:47:37 <Saizan> so tools could derive which packages build together without version numbers, except for changed semantics
22:48:57 <ski> one could also possibly restrict the type signature of an imported operation
23:08:30 <mmorrow> ski, Saizan: yeah, if you were able to just require some undisclosed module to satisfy some given signature, then any module that satisfies that sig (which could possibly mean making certain functions' types more specific) could be allowed
23:09:47 <mmorrow> but unfortunately modules are untyped :(
23:09:59 <kmc> @djinn (a -> (b -> c)) -> (a -> b) -> (a -> c)
23:09:59 <lambdabot> f a b c = a c (b c)
23:10:12 <kmc> :t ap
23:10:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:10:34 <mmorrow> @type [ap,\a b c -> a c (b c)]
23:10:35 <lambdabot> forall a b t. (Monad ((->) t)) => [(t -> a -> b) -> (t -> a) -> t -> b]
23:10:55 <kmc> hmm, it is cool that two axioms of propositional calculus correspond to the S and K combinators
23:11:02 <kmc> and also probably not coincidental
23:11:15 <kmc> i guess these things were invented for logic first
23:11:45 <Saizan> yeah
