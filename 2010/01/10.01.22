00:11:03 <tomoj> "HShappstack-util-0.4.1.o: unknown symbol `QuickCheckzm1zi2zi0zi0_TestziQuickCheckziBatch_zdwa_info'"  ????
00:13:47 <Adamant> looks almost like C++ name mangling
00:15:16 <tomoj> maybe happstack-util is out of date with quickcheck?
00:22:05 <tomoj> oh happstack-util wants QuickCheck (<2)
00:22:06 <tomoj> hrmm
00:26:21 <ivanm> dibblego: I liked your response to jdh30 on reddit ;-)
00:31:35 <tomoj> huh
00:32:07 <tomoj> I get the same error whether I do -package 'QuickCheck-2.1.0.2' or -package 'QuickCheck-1.2.0.0'
00:32:29 <jrockway> seems like a link-time error
00:32:31 <jrockway> recompile.
00:33:28 <tomoj> recompile happstack-util? had just started that
00:33:44 <jrockway> yeah
00:33:54 <jrockway> did you build your packages yourself, or are you using os packages?
00:34:01 <jrockway> (or, none of the above? :)
00:34:15 <tomoj> yay, solved it
00:34:23 <tomoj> umm, I believe none of the above
00:34:31 <tomoj> I might have a couple things installed by os packages
00:34:35 <tomoj> I got happstack from hackage
00:34:38 <tomoj> (with cabal)
00:35:19 <jrockway> interesting
00:35:32 <jrockway> what was the solution?
00:36:10 <jrockway> also, #haskell-- for making me go look on reddit
00:36:19 <jrockway> that "how to deal with a smug functional programmer" is hilarious
00:36:26 <ivanm> heh
00:36:33 <ivanm> oh? which one is that one?
00:36:42 <jrockway> http://www.reddit.com/r/programming/comments/arhm0/how_to_deal_with_a_smug_functional_programmer/
00:36:45 <jrockway> handle with care
00:36:46 <jrockway> :)
00:36:50 <tomoj> jrockway: cabal install happstack-util
00:37:27 <ivanm> I was referring to http://www.reddit.com/r/programming/comments/asm7h/scala_a_postfunctional_language/c0j6pgu
00:38:27 <tensorpudding> who is jdh anyway?
00:38:51 <ivanm> tensorpudding: Jon Harrop
00:38:52 <jrockway> articles like that just make me mad
00:39:02 <ivanm> aka mega troll
00:39:13 <olsner> jdh == "a troll" :)
00:39:14 <jrockway> "people like functional programming, so here's a new definition of functional programming that fits my favorite religion perfectly"
00:39:26 <ivanm> heh
00:39:40 <ivanm> @remember jrockway "people like functional programming, so here's a new definition of functional programming that fits my favorite religion perfectly"
00:39:40 <lambdabot> I will never forget.
00:40:02 <bastl> hi, i have a problem with conflicting libraries: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6453#a6453
00:40:23 * ivanm randomly guesses mtl vs transformer without even reading the link
00:40:24 <tensorpudding> i'm told a lot he is a troll, though i haven't seen any evidence besides that he seems to have a bone to pick with haskell in particular and i don't see his motivation
00:40:32 <ivanm> oh, I was wrong
00:40:37 <ivanm> bastl: yay, someone is using my library! \o/
00:40:44 <bastl> :-)
00:40:48 <ivanm> bastl: do you use ghc 6.10?
00:40:55 <ivanm> if so, uninstall bytestring-0.9.1.5
00:40:59 <bastl> 6.10.4
00:41:00 <ivanm> and rebuild everything that built with it
00:41:22 <ivanm> tensorpudding: he keeps making stupid comments about anything that isn't OCaml or his new lovechild F#
00:41:36 <bastl> well, but i guess gtk2hs needs that version of bytestring?
00:41:36 <ivanm> bastl: bytestring is a boot library and as such shouldn't be upgraded
00:41:45 <ivanm> bastl: I doubt it
00:42:05 <ivanm> you've just upgraded bytestring and then installed gtk2hs with it installed, so it used the newest version
00:42:20 <bastl> to be honest I dont want to fiddle around with dependencies. should be managed by the respective files of the respective packages.
00:42:30 <ivanm> bastl: which distro?
00:42:34 <bastl> ubuntu
00:42:57 <ivanm> yup, the package maintainers should be shot
00:43:06 <mmaruseacph2> which is the fastest array implementation?
00:43:13 * ivanm passes bastl a shotgun
00:43:17 <dolio> jrockway: "postfix denotational semantics style" is my new favorite coding style.
00:43:25 <mmaruseacph2> without IO or other monads
00:43:31 * bastl asks himself at whom to aim ...
00:43:33 <ivanm> mark-an: what are you wanting to do with it?
00:43:54 <jrockway> dolio: yeah! :)
00:43:57 <ivanm> uvector seems to be popular though (bos uses it for criterion)
00:44:08 <ivanm> dolio: do I dare ask wtf that means?
00:44:10 <jrockway> if i knew what that meant, if anything, i would be sooo into it
00:44:28 <jrockway> my guess is he means point-free
00:44:29 <dolio> I think it means someone strung a bunch of words they'd heard together.
00:44:55 <ivanm> heh
00:45:16 <ivanm> lambdabot needs a new plugin to generate programming paradigms...
00:46:41 <jrockway> that's what programming.reddit is, right?
00:46:49 <ivanm> heh
00:47:13 <ivanm> oh, whoops, I meant mmaruseacph2, not mark-an before
00:47:31 <ivanm> damn tab completion...
00:47:34 <mmaruseacph2> oh:P
00:47:37 <ivanm> mmaruseacph2: what are you wanting to do with it?
00:47:55 <ivanm> I haven't used any of them, but uvector seems to be popular (bos uses it in criterion)
00:47:55 <mmaruseacph2> i want to make a matrix like structure
00:48:04 <mmaruseacph2> and then to define some folds on it
00:48:38 <ivanm> mmaruseacph2: have a look at hmatrix if your'e actually doing matrix stuff
00:48:57 <mmaruseacph2> i didn't knew about hmatrix, i'll look into it
00:48:58 <mmaruseacph2> thanks
00:49:09 <ivanm> no worries
00:49:17 <ivanm> it's a partial binding to gsl and lapack
00:49:28 <mmaruseacph2> i see
00:49:31 <ivanm> (though I sometimes wish the gsl part was split off into another library)
00:52:12 <o-_-o> I am trying to understand how to work with Data.Sequence
00:52:23 <o-_-o> using Data.Foldable
00:52:30 <ivanm> ok
00:52:31 <o-_-o> if I want to sqr all the elements
00:52:45 <o-_-o> how would I do this using mapM_ ?
00:52:54 <o-_-o> or some other function in Data.Foldable
00:53:18 <o-_-o> traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
00:53:19 <o-_-o> Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results.
00:53:31 <ivanm> ummm, use fmap
00:53:32 <o-_-o> what does it mean when it says ignore the results ?
00:53:36 <o-_-o> ok
00:53:54 <ivanm> o-_-o: by "ignores the results" means that you don't get anything back
00:54:11 <ivanm> functions like that are used for their side effects, not for their actual values
00:54:47 <jrockway> you can implement map in terms of a fold if you really want to, though
00:54:53 <ivanm> @ask jmillikin wrt your comment on HN about unsafePerformIO: I wasn't aware that it needed special compile-time flags, etc. ...
00:54:53 <lambdabot> Consider it noted.
00:55:09 <ivanm> jrockway: yes, but not with traverse_ or mapM_ ;-)
00:55:39 <Botje> .oO(mapM_ + IORefs)
00:55:42 <jrockway> mapM_ in a state-keeping monad, then remove the state wrapper at the end :)
00:55:50 <ivanm> @type \ f -> fmap f Seq.empty
00:55:51 <lambdabot> forall a b. (a -> b) -> Seq.Seq b
00:55:58 <ivanm> jrockway: heh
00:56:08 <ivanm> o-_-o: ^^ fmap
00:56:13 <jrockway> it's a new programming paradigm
00:56:14 <o-_-o> ivanm, ok
00:56:20 <jrockway> purely disfunctional programming
00:56:24 <ivanm> lol
00:56:47 <ivanm> @remember jrockway it's a new programming paradigm; purely disfunctional programming
00:56:47 <lambdabot> Done.
00:57:07 * ivanm is trying to keep jfredett happy by ensuring there's plenty of quotes for the HWN
00:59:29 <o-_-o> @hoogle fmap
00:59:29 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
00:59:29 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
00:59:29 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
00:59:32 <jrockway> > snd . runWriter $ mapM_ (\x -> tell [x**x]) [1..10]
00:59:33 <lambdabot>   [1.0,4.0,27.0,256.0,3125.0,46656.0,823543.0,1.6777216e7,3.87420489e8,1.0e10]
00:59:40 <jrockway> see, who needs fmap?
01:00:38 <o-_-o> o_0
01:01:09 <o-_-o> @hoogle tell
01:01:09 <lambdabot> Control.Monad.Writer.Class tell :: MonadWriter w m => w -> m ()
01:01:09 <lambdabot> System.IO hTell :: Handle -> IO Integer
01:02:10 <ivanm> why does Control.Monad export fmap? as an alternative to liftM?
01:02:21 <ivanm> @slap jrockway
01:02:21 <lambdabot> *SMACK*, *SLAM*, take that jrockway!
01:02:30 <ivanm> o-_-o: the writer monad allows you to log what happens
01:02:41 <o-_-o> ivanm, I don't know monads
01:02:51 <ivanm> jrockway: OK, get that working for Seq!
01:02:57 <o-_-o> ivanm, and I am too scared to start learning them
01:03:02 <jrockway> don't be
01:03:08 <jrockway> i did that, and it took me years to figure it out
01:03:14 <jrockway> then when i did, i realized there was nothing to realize
01:03:15 <Botje> o-_-o: just dive in.
01:03:20 <o-_-o> jrockway, ok
01:03:28 <ivanm> o-_-o: OK, consider the Writer monad a special environment but also have a special function "tell" that appends a value to a list
01:03:36 <o-_-o> Botje, ok
01:03:39 <ivanm> then you can use runWriter to get that list of appended values out
01:03:47 <o-_-o> ivanm, ok
01:03:54 <ivanm> o-_-o: maybe try out Axman6's IO blog post/tutorial as a starter
01:03:55 <Botje> once the type errors make sense you "get" monads :)
01:04:00 <ivanm> and RWH covers monads really well
01:04:18 <jrockway> yeah, RWH takes exactly the right approach
01:04:27 <ivanm> (it's the only haskell book I've read that actually covers monads properly rather than having a few pages at the end that gloss over the whole issue)
01:04:30 <jrockway> once you learn how to do the monadic computation without monads, monads make sense :)
01:04:32 <Peaker> why list/appended? Join Monoid
01:04:32 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
01:04:33 <tomoj> hmm, I wonder why happstack-state is not deleting the .lock file
01:04:43 <ivanm> jrockway: unfortunately, the "right approach" means you can't just go to the monad chapter to learn about them :s
01:04:51 <ivanm> Peaker: over simplification
01:05:11 <ivanm> to avoid throwing too many new terms at o-_-o
01:05:12 <bastl> ivanm: now it installed graphviz 2999.6.0.0 but cant find hidden module Data.GraphViz.Types.Printing. Did the API change, or is my setup still not correct.
01:05:20 <ivanm> yes
01:05:23 <jrockway> if i could go back in time, i wish someone told me what a functor was early on
01:05:26 <ivanm> it's now Data.GraphViz.Printing
01:05:34 <bastl> k
01:05:57 <ivanm> (graphviz now follows the PVP, so packages using it should have proper deps in the cabal files)
01:06:07 <ivanm> jrockway: typeclassopedia ftw!
01:06:12 <jrockway> exactly
01:06:13 * ivanm should finish reading that at some point...
01:06:15 <bastl> what is PVP ?
01:06:22 <o-_-o> jrockway, a functor is a what ?
01:06:23 <ivanm> Package Versioning Policy
01:06:28 <jrockway> o-_-o: so definitely read that... it takes multiple readings to fully grasp everything
01:06:32 <jrockway> o-_-o: a container
01:06:44 <ivanm> o-_-o: a Functor is a structure containing values that you can apply a function to without changing the "shape" of the structure
01:06:45 <o-_-o> jrockway, ok
01:06:49 <bastl> i see, you mean major version = api change ?
01:06:54 <ivanm> which you do so using fmap
01:06:58 <Peaker> o-_-o: Do you know what a parameterized type is?
01:07:07 <bastl> ok
01:07:10 <o-_-o> Peaker, no
01:07:20 <Peaker> o-_-o: Like "Maybe" is a parameterized type because you can give it a parameter.  "Maybe Int", "Maybe String"
01:07:25 <ivanm> bastl: right; with a.b.c.d (the d is optional), a and b represent backwards incompatible change, c represents addition of new features without changing what was there
01:07:27 <bastl> did you document api changes ?
01:07:29 <o-_-o> Peaker, oh..yeah I know that
01:07:40 <ivanm> bastl: yup, in the ChangeLog
01:07:43 <o-_-o> Peaker, data Color = Red |Blue |Green
01:07:49 <bastl> ivanm: innovative :-)
01:07:51 <Peaker> o-_-o: Color is not a parameterized type
01:07:55 <ivanm> bastl: heh
01:08:01 <Peaker> o-_-o: There's Color, there's no Color Int, or Color String
01:08:03 <ivanm> let me find the darcs repo online and link to it for you
01:08:10 <bastl> thanks
01:08:18 <o-_-o> Peaker, ah...
01:08:24 <Peaker> o-_-o: data Color a = Color { red, green, blue :: a } -- would be a parametrized type
01:08:28 <ivanm> bastl: http://code.haskell.org/graphviz/Changelog
01:08:38 <o-_-o> ok I need to read about them then
01:08:53 <jrockway> definitely a good idea
01:09:00 <Peaker> o-_-o: Tell me which of these types are parameterized: Int, list, IO, String, Maybe, Either
01:09:01 <jrockway> sometimes you need a few pages of uninterrupted explnation
01:09:03 <bastl> ivanm: why the heck are you using these version >= 2000 ?
01:09:05 <jrockway> and irc is not so good for that :)
01:09:24 <ivanm> bastl: when matthew-_ wrote it, he used dates for versions
01:09:45 <o-_-o> Peaker, list is
01:09:51 <o-_-o> Peaker, IO is
01:09:51 <ivanm> which means that I had to have > 2009 for the first "real" version to make sure new ones were actually newer than the old ones :s
01:09:52 <Peaker> o-_-o: right, what else?
01:09:52 <bastl> but now using PVP, getting back from there is impossible :-)
01:09:58 <jrockway> http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf#17
01:09:59 <ivanm> bastl: network has the same problem IIRC
01:10:05 <jrockway> o-_-o: please read :)
01:10:06 <ivanm> bastl: heh
01:10:07 <o-_-o> Peaker, String is, because of utf8 and utf16 ?
01:10:17 <Peaker> o-_-o: nope, String doesn't take a type parameter
01:10:19 <ivanm> o-_-o: String isn't parametrized
01:10:29 <o-_-o> jrockway, I am reading, but I don't seem to ever get there...it is like a dog chasing a car :-(
01:10:33 <dolio> How'd it get up to 2999?
01:10:34 <Peaker> o-_-o: String is a simple type, so its kind is *.  IO,Maybe and list are *->*
01:10:46 <o-_-o> Peaker, ah...ok
01:10:54 <ivanm> o-_-o: as you said, "Maybe a" is parametrized
01:10:58 <Peaker> o-_-o: That means that they are like type "functions" that take a type (*) and return a parameterized type (*), so they are *->*
01:11:08 <ivanm> Either is doubly parametrized
01:11:09 <jrockway> o-_-o: page 17 :)
01:11:22 <dolio> Is it from the future?
01:11:25 <ivanm> @slap flakey hotel internet connection
01:11:25 * lambdabot is overcome by a sudden desire to hurt flakey hotel internet connection
01:11:27 <o-_-o> jrockway, page 17 of what ?
01:11:31 <o-_-o> RWH ?
01:11:34 <jrockway> the pdf i linked you to
01:11:34 <ivanm> o-_-o: the link he gave you
01:11:44 <o-_-o> ah
01:11:45 <ivanm> o-_-o: http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf#17
01:11:49 <jrockway> 1 hour spent reading that will cut 2 years off the time it takes to get productive in haskell
01:11:49 <o-_-o> I missed that
01:12:30 <Peaker> jrockway: that assumes he already understands kinds/etc
01:12:41 <Peaker> o-_-o: #haskell-overflow -- I'll explain parameterized types and functors there :)
01:12:58 <o-_-o> Peaker, ok
01:16:17 <tomoj> wtf
01:17:09 <ivanm> tomoj: what?
01:18:06 <tomoj> .. hang on a sec
01:21:53 <tomoj> http://img42.imageshack.us/img42/3176/importantmessage.png
01:22:00 <tomoj> I added RWH on amazon and this message came up
01:22:23 <Nafai> heh
01:22:36 <rittyan> d700 is hot
01:22:45 * rittyan needs to send his old gear to CLA :<
01:22:47 <tomoj> on the same page as the important message, RWH is now in my cart
01:22:59 <tomoj> the write was successful and then something blew up and thought I wanted a camera
01:23:25 <tomoj> I haven't even looked at cameras on amazon for like 6 months
01:23:41 <ivanm> wtf?
01:24:10 <ivanm> tomoj: maybe amazon was trying to give you a hint...
01:25:00 <quicksilver> tomoj: amazon knows what you *really* want. what you think you want, and what you asked for is irrelevant.
01:25:01 <tomoj> I did just get a new canon camera
01:25:05 <tomoj> much much cheaper
01:25:10 <tomoj> they're monitoring my fucking birthday presents
01:25:15 <tomoj> my birthday is tomorrow
01:25:18 <tomoj> :O
01:25:46 <ivanm> heh
01:26:16 <idnar> tomoj: you must have had that item lying around in your cart from 6 months ago, or something
01:26:16 <Adamant> they don't run AWS for fun, their job is to predict what you want before you want it
01:26:43 <idnar> then again, AWS does use /eventual/ consistency
01:28:25 <tomoj> yeah, that's what I was thinking
01:28:31 <tomoj> because I've been trying to mimic their crap lately
01:28:50 <tomoj> some kind of intermittent failure cause a db read to go to the wrong node or something?
01:31:16 <tomoj> is fmap the only witness to its laws?
01:31:36 <quicksilver> can't quite parse that question, tomoj
01:32:15 <tomoj> I meant, Functor instances need to satisfy two laws
01:32:30 <tomoj> is fmap the only possible function with its type which satisfies those laws
01:33:46 <tomoj> oh
01:33:56 <quicksilver> tomoj: yes
01:33:56 <tomoj> that question only makes sense for a specific instance
01:34:11 <quicksilver> tomoj: fmap is unique if it exists.
01:34:15 <tomoj> oh, nice
01:34:27 <quicksilver> in fact one law determines the other in haskell
01:34:31 <quicksilver> it's enough that fmap id = id
01:34:42 <quicksilver> if that's true the composition law follows for free
01:34:46 <quicksilver> by the magic of parametricity
01:35:00 <quicksilver> (also known as "theorems for free")
01:35:04 <ivanm> what's the composition law again? fmap (f.g) = fmap f . fmap g ?
01:35:08 <quicksilver> ivanm: yes
01:35:10 <tomoj> hmm
01:35:16 <tomoj> I don't see how theorems for free applies
01:35:25 <ivanm> and the first law ensures that fmap is structure invariant?
01:35:27 <tomoj> the type of fmap for any particular instance is not parametric, is it?
01:35:35 <quicksilver> yes it is
01:35:37 <tomoj> oh, of course it is
01:35:55 <tomoj> so because you can't poke at a or b, you can only do the right thing?
01:36:01 <quicksilver> exactly
01:36:18 <quicksilver> fmap id proves you keep the shape the same
01:36:27 <quicksilver> given that you keep the shape the same, you don't really have any choice
01:36:35 <quicksilver> you have to apply the function "wherever you can"
01:36:39 <tomoj> that is beautiful
01:36:54 * ivanm goes off to explore this mystical new land known as "outside"...
01:40:05 <quicksilver> ivanm: it's not that new, actually.
01:40:09 <ivanm> :o
01:40:11 <ivanm> now you tell me!
01:40:33 <ivanm> fine, but it's still mystical (especially since I don't speak spanish...)
01:41:18 <quicksilver> una cerveza por favor
01:41:23 <quicksilver> that's pretty much all I ever needed.
01:41:44 <Veinor> that's @quote-able :P
01:42:07 <Adamant> pinche gringos
01:42:17 <Botje> you can halve the time spent ordering beer by ordering dos cervezas!
01:43:43 <quicksilver> Botje: well, subsequently you can just say "dos mas" which is pretty efficient
01:45:09 <OWD> hello
01:45:16 <OWD> can you guys teach me how to haskell?
01:45:31 <Peaker> OWD: http://learnyouahaskell.com
01:45:53 <Peaker> Apparently even elephants can do it
01:45:54 <Botje> heh :)
01:45:56 <Alpounet> anyone here built successfully the new event manager ?
01:45:58 <OWD> PROGRAMMING LANGUAGE?!
01:45:58 <Botje> laziness at work
01:46:17 <OWD> i was told it meant SKIING in GERMAN
01:46:18 <Botje> OWD: yes, that's what it says in the topic.
01:46:32 <Botje> wow. you're pretty gullible.
01:46:40 <OWD> well i was told by a german
01:46:47 <OWD> and i don't know how to ski
01:47:00 <cads> OWD, I didn't tell you to come spam here
01:47:08 <cads> though hilarious!
01:47:10 <OWD> do i konw you?
01:47:14 <OWD> know*
01:47:23 <Botje> OWD: well, now that you're here, you might as well learn haskell :)
01:47:31 <OWD> Botje: can you teach me how to ski instead?
01:47:32 <cads> actually I think there may have ben a misrecognition
01:47:54 <OWD> i keep falling when my instructor guy says snowplow
01:47:55 <cads> actually, I think lambdabot knows unlambda?
01:47:56 <Botje> OWD: skis on snow, head in air = good
01:48:00 <Botje> head in snow, skis in air = bad
01:48:11 <OWD> uh
01:48:24 <OWD> what if you're holding your skis in your hand while nomming on snow
01:49:14 <OWD> ok well lets learn the real haskell -.-"
01:49:25 <OWD> so
01:49:26 <cads> alright
01:49:28 <cads> do like me
01:49:29 <OWD> whaddya do
01:49:31 <OWD> okie
01:49:32 <cads> > 1 + 1
01:49:33 <lambdabot>   2
01:49:38 <OWD> yay
01:49:42 <OWD> 1 + 1
01:49:47 <OWD> did i win a cookie?
01:49:50 <cads> negative!
01:50:00 <OWD> crap
01:50:07 <cads> > 123^456
01:50:08 <lambdabot>   992500687720988567008314620574696326372959408198869005198162988813828671047...
01:50:16 <OWD> wao
01:50:20 <cads> oh is that all.
01:50:23 <OWD> 123^456
01:50:31 <OWD> why isn't it working?
01:50:49 <Peaker> OWD: it is working, what do you mean?
01:50:51 <cads> gotta put a > and a space before your line greeback
01:50:57 <OWD> and lambda is frequency isn't it?
01:51:07 <OWD> > 123^456
01:51:08 <lambdabot>   992500687720988567008314620574696326372959408198869005198162988813828671047...
01:51:11 <OWD> yay
01:51:15 <OWD> do i win a cookie now?
01:51:43 <gspr> Anybody got any experience with QtHaskell? I'm having real trouble compiling it - after about 10-15 minutes of running, the GHC process takes up almost 4 GB of memory. At this point, all my physical RAM is exhausted, so even after leaving it swapping like hell over night, the build was far from done...
01:51:45 <cads> no, just the first few digits of an integer that bigger than the number of grains of sand in the universe!
01:51:57 <cads> let's try multiplication
01:51:58 <OWD> yeah sure
01:52:04 <Peaker> > map pred "PXE-!ublf!b!dppljf"
01:52:05 <lambdabot>   "OWD, take a cookie"
01:52:11 <Saizan> cads: this channel is not a calculator, btw
01:52:22 <OWD> for QtHaskell you just take your pants off and start fapping. she'll orgasm soon
01:52:26 <OWD> ahaha
01:52:29 <OWD> o.o
01:52:32 <Veinor> the fuck
01:52:39 <OWD> lol
01:52:42 <OWD> Qt = cutie
01:52:42 <cads> Saizan, aw c'mon, he's a young'n
01:52:44 <OWD> o.o
01:52:51 <OWD> i be 15
01:52:53 <OWD> :]
01:52:58 <Saizan> OWD: such language and behavior can't be tolerated here
01:53:03 <cads> aahh
01:53:15 <OWD> oh
01:53:16 <cads> yeah, old boy, you do have to take this a little seriously
01:53:17 <OWD> i am sorry
01:53:33 <OWD> May I obtain a second chance?
01:53:39 <Saizan> gspr: you might try by limiting the maximum heap size
01:53:52 <gspr> Saizan: Yeah, that was my next move - thanks :)
01:54:01 <Ke> well QtHaskell might be actual haskell bindings unlike C++ ones
01:54:22 <Ke> I'm just all syntax error when I read kde stuff
01:54:52 <Ke> (All the more reason to hate Nokia)
01:54:56 <cads> well, OWD, haskell is a programming language where if you're familiar with math, you'll quickly before familiar with coding haskell
01:55:09 <gspr> I can't help wondering about the guy behind QtHaskell. I'm thinking he's got to have a LOT of RAM if he keeps building his library all the time :)
01:55:32 <quicksilver> gspr: I doubt he has more than 4G, not many people do
01:55:40 <quicksilver> gspr: presumably this doesn't happen on his machine.
01:55:40 <Ke> well 8GiB is not uncommon nowadays
01:55:41 <OWD> I am currently in Algebra 2/Trigonometry. Am I at a high enough standard to learn Haskell?
01:55:45 <cads> in fact, if you get familiar with other languages first, and then try to get haskell, you might find that those other languages have taken away whatever math intuition you had before
01:55:57 <Veinor> Ke: certainly not standard.
01:56:04 <gspr> quicksilver: Yeah, perhaps it's my specific version of GHC or something
01:56:15 <quicksilver> Ke: I disagree, it's extremely uncommon. It's not very interesting thing to argue about though.
01:56:15 <cads> > sin(2 * Pi)
01:56:16 <lambdabot>   Not in scope: data constructor `Pi'
01:56:21 <shrughes> whoa "Algebra 2/Trig" I haven't heard that exact course name in a while
01:56:30 <OWD> California.
01:56:45 <Ke> well arguing about facts is never interesting
01:56:55 <paolino> gspr, is the linking part that fills memory ?
01:57:08 <OWD> shrughes: Are you a Californian?
01:57:21 <shrughes> OWD no, never mind, I didn't know an entire state used it
01:57:49 <OWD> I'm not exactly sure. I'm pretty sure my entire school destrict uses it though.
01:57:51 <Veinor> > sin(2* pi)
01:57:52 <gspr> paolino: Nope. The GHC --make part of the compilation has to go through around 650 files. At around number 350, it has filles up all my RAM (usage growth is roughly linear up to then)
01:57:52 <lambdabot>   -2.4492935982947064e-16
01:58:02 <Veinor> this is why mathematica has chop[]!
01:58:10 <cads> OWD, to answer your question, yes haskell is okay for your level of math knowledge. You can use it at least as a calculator for trig and algebra
01:58:22 <Veinor> quick, someone teach him category theory
01:58:26 <OWD> Yay. So what do I do?
01:58:34 <shrughes> uh, you could use it as a programming language too.
01:58:40 <Saizan> gspr: http://www.mail-archive.com/haskell@haskell.org/msg22451.html <- it seems you're not alone, at least :)
01:58:49 <cads> shrughes, we're assuming he doesn't know about programs yet :D
01:58:56 <OWD> Which I don't.
01:58:58 <shrughes> why's he learning Haskell then
01:59:05 <OWD> Very intuitive, cads.
01:59:13 <Ke> because haskell is awesome
01:59:19 <cads> why _not_ learn haskell?!
01:59:20 <OWD> shrughes: I believe I told you?
01:59:22 <gspr> Saizan: Ah, hehe! Missed that one :)
01:59:24 <Saizan> > sin (2*pi)
01:59:25 <lambdabot>   -2.4492935982947064e-16
01:59:32 <gspr> Saizan: I'll see what happens if i try to limit the heap size
01:59:35 <shrughes> OWD you didn't tell me
01:59:58 <OWD> I mistook "Haskell" as German for "skiing". I came here to learn how to ski.
02:00:37 <shrughes> oh
02:01:03 <cads> we have sking here , but not of the kind you're thinking
02:01:28 <OWD> My kind has two "i"'s.
02:02:14 <ibid> you can compile haskell to ski, i think
02:02:21 <OWD> shrughes: Do you think you can teach me how to ski?
02:02:23 <shrughes> we have the kind with two i's as well
02:02:26 <ibid> at least minus the IO monad
02:02:33 <ziman> @type let s = ap; k = const; i = id in s k i i
02:02:33 <lambdabot> forall a. a -> a
02:02:39 <ziman> see? :)
02:02:50 <OWD> @type
02:02:51 <lambdabot> <no location info>: not an expression: `'
02:02:52 <OWD> o.o
02:03:05 <Veinor> sap, konst, id :D
02:03:26 <OWD> @type let s = ap; k = const,i = id in s k i i
02:03:27 <lambdabot> parse error on input `,'
02:03:59 <OWD> @type let s = ap; k = const, i = id in s k i i
02:04:00 <lambdabot> parse error on input `,'
02:04:03 <gspr> Saizan: Hmm, turns out I don't really know how to limit the maximum heap size GHC uses during compilation... Do you know?
02:04:17 <OWD> parse error on input `,'?
02:04:19 <gspr> (I didn't immediately find it in the manpages, so I thought I'd just ask)
02:04:29 <quicksilver> -M I think
02:04:38 <quicksilver> well +RTS -M
02:04:40 <OWD> No response to the term "manpages".
02:04:53 <quicksilver> if it really need the memory it will just crash though
02:05:06 <gspr> quicksilver: Yeah, I know. I'll give it a go
02:05:13 <Baughn> It'll work harder to GC first
02:05:35 <Baughn> In practice, it'll just get asymptotically close to crashing, spending more and more time on GC instead of working.
02:05:57 <Saizan> Baughn: better that than trashing your OS
02:06:12 <Baughn> Saizan: And this is why I always say GCing should be swap-aware
02:06:31 <Baughn> The OS and programs need to cooperate. I'm not quite sure how, but someone should figure it out. Someone not me. :/
02:06:31 <Saizan> yeah
02:07:15 <quicksilver> Baughn: it does, eventually, crash
02:07:24 <quicksilver> Baughn: but the asympotic last few GCs take *forever*
02:07:42 <gspr> Saizan: Aha! Good sign so far... I just restarted compilation from where I left off, and now it's building fine with little memory usage. So clearly, it doesn't need all that memory (I guess the easiest thing to do is just to now and then abort and restart  the compilation)
02:08:04 <quicksilver> gspr: that sounds like a definite bug; some kind of memory leak in ghc --make
02:08:10 <quicksilver> gspr: it would be good to report that
02:08:40 <gspr> quicksilver: OK. I'll run it by the QtHaskell guy first though, in case it's something he knows about.
02:08:44 <quicksilver> actually maybe it's not a leak exactly
02:08:54 <quicksilver> googling suggests that --make deliberately caches stuff
02:08:57 <quicksilver> to make compilation faster
02:09:01 <quicksilver> maybe it's just caching too much.
02:09:10 <gspr> yeah, 640 files is a LOT
02:09:38 <gspr> I think the files are automatically generated in 1-1 correspondence with Qt files or something
02:09:52 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/1334
02:10:10 <quicksilver> Baughn: observation of the morning's train commute - all Arrows are Applicative
02:10:44 <Baughn> quicksilver: All monads are applicative. All arrows are monads. ;)
02:10:49 <Baughn> Well, sort of
02:10:54 <Peaker> arrows are not monads..
02:11:02 <quicksilver> Baughn: no.
02:11:05 <Baughn> ..wait, that's the other way around
02:11:06 <quicksilver> Baughn: all arrows are not monad
02:11:10 <quicksilver> but all arrows *are* applicative
02:11:14 <Baughn> Arrows are a generalization of monad. So all monads are arrows.
02:11:15 <quicksilver> that's why I found it an interesting observation.
02:11:33 <Peaker> (arrow <=> applicative) => monad
02:11:37 <Baughn> Okay. Confusion aside..
02:11:42 <quicksilver> and you can use the applicative to replace the tuple stuff in the the arrow class
02:11:45 <quicksilver> which I actually prefer
02:11:50 <Baughn> Ah.
02:11:54 <quicksilver> tuples always struck me as a bit arbitrary
02:12:15 <Baughn> The "tuples" are meant to represent a stack, AIUI
02:12:27 <quicksilver> so, e.g. (***) becomes "liftA2 (,) (arr fst
02:12:33 <quicksilver> sorry, try again
02:12:51 <quicksilver> a *** b becomes liftA2 (,) (arr fst >>> a) (arr snd >>> b)
02:13:11 <Saizan> ?type \a b -> liftA2 (,) (arr fst >>> a) (arr snd >>> b)
02:13:12 <lambdabot> forall a b a1 b1 (cat :: * -> * -> *). (Arrow cat, Applicative (cat (a1, b1))) => cat a1 a -> cat b1 b -> cat (a1, b1) (a, b)
02:13:18 <quicksilver> (,) <$> (arr fst >>> a) <*> (arr snd >>> b) if you prefer that syntax
02:13:33 * Baughn thinks he prefers a *** b
02:13:40 <quicksilver> of course, me too
02:13:46 <quicksilver> I'm just saying if you can define *** that way
02:13:50 <quicksilver> it doesn't need to be a method
02:13:50 <Baughn> Also, you should really look up the arrow syntax about now. ;)
02:13:52 <OWD> I need to get some bedrest. I have a major math test tomorrow.
02:13:55 <quicksilver> it's just a cool funciton you can define.
02:14:00 <OWD> Have a good night, everyone.
02:14:04 <quicksilver> night OWD
02:14:06 <OWD> Happy late holidays.
02:14:13 <quicksilver> I never really understood why the tuple stuff needed to be methods.
02:14:24 <Saizan> quicksilver: so you need "forall a. Applicative (cat a)"?
02:14:29 <quicksilver> Saizan: yes.
02:14:38 <Saizan> yeah, that makes sense
02:14:39 <quicksilver> Saizan: I'm saying all Arrows are in fact Applicative (applied in one arg)
02:14:50 <quicksilver> Saizan: and, in some ways, I prefer giving them an applicative instance and using that
02:14:54 <quicksilver> than the arrow instance
02:14:58 <Baughn> quicksilver: Well.. they don't?
02:15:00 <quicksilver> function application is more "basic" than tuples
02:15:08 <quicksilver> it's like prefering zipWith to zip
02:15:13 <Saizan> it's the "reader applicative" over this different morphims
02:15:13 <quicksilver> precisely like that, in fact.
02:15:52 <Baughn> quicksilver: Arrow provides default implementations of second, *** and &&&, they're just methods so they can be overridden for efficiency..
02:15:59 <Saizan> though with the intention of using it with different environments in the same computation, i guess?
02:16:19 <quicksilver> Baughn: yes, but you have to define 'first'
02:16:23 <Baughn> quicksilver: As to first, its existence as a primitive is a pretty good match for the stack view of those tuples in arrow composition
02:16:35 <quicksilver> I'm saying I prefer <*> to first
02:16:42 <quicksilver> because I prefer function application to tuples.
02:17:16 <Baughn> Okay.
02:17:17 <quicksilver> instance Applicative (A a) where f <*> x = (f &&& x) >>> (arr (uncurry ($)))
02:17:28 <quicksilver> is how the applicative instance I'm talking about.
02:17:44 <Baughn> It's not obvious to me what the semantics of applicative has to be for an arrow
02:18:02 <Baughn> Hm
02:18:06 <Baughn> @type (<*>)
02:18:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:18:12 <Saizan> Baughn: just thing the reader monad with a different (->)
02:18:17 <quicksilver> well given (a ~> (x -> y)) and (a ~> x)
02:18:26 <quicksilver> you want to 'run both those arrows on the same a'
02:18:30 <quicksilver> (which is what &&& does)
02:18:36 <quicksilver> and then apply the function to the favlue
02:18:44 <quicksilver> (which is what pure (uncurry ($)) does)
02:18:50 <quicksilver> s/pure/arr/; sorry
02:18:55 <Peaker> arrows suck :-P
02:18:58 <Saizan> so it's a bit like preferring SKI calculus over concatenative languages
02:19:02 <quicksilver> I call it 'pureq'.
02:19:09 <quicksilver> hence my typo.
02:19:15 <quicksilver> (well, it did used to be called 'pure' some years ago)
02:19:40 <quicksilver> there is always a choice about which order you run the effects in, too
02:19:49 <quicksilver> but that's true for Applicative itself, and it's true for &&& and ***
02:19:58 <Peaker> I think arrows should have the product type be an abstract type - and have more combinators to extract it/etc, rather than expose the tuples
02:20:14 <quicksilver> Peaker: well I think using Applicative instead is a bit like that
02:20:14 <Peaker> then the graph structure built by the arrow can actually be extracted from the arrow composition
02:20:19 <quicksilver> Peaker: it's making the tuple abstract
02:20:24 <quicksilver> "any binary function" instead of "tuple"
02:20:30 <quicksilver> like zipWith vs zip
02:20:47 <quicksilver> with the added benefit that the Applicative instance makes it obvious that N-ary functions work just as well
02:20:50 <Peaker> quicksilver: the original parser thing that used arrows, can it use applicatives instead and retain all the qualities?
02:21:03 <quicksilver> whereas with the tuple thing you need to pack/unpack to use N-ary functions
02:21:05 <quicksilver> not hard, but clumsy.
02:21:13 <Peaker> quicksilver: I understand how arrows and applicatives can be converted to one another - but is it really equivalent in practice?
02:21:25 <quicksilver> Peaker: yes. I have just shown how to conver the methods both ways.
02:21:28 <Baughn> On a totally related note, is there a pragma to force GHC to evaluate some value at compile-time?
02:21:29 <Saizan> quicksilver: so you're using both (<*>), arr and (>>>) ?
02:21:52 <quicksilver> Saizan: Yes. So you get (>>>) from Category.
02:22:03 <Peaker> quicksilver: so there should be a context-free parser implemented with an Applicative instance, that does O(1)-per-token parsing?
02:22:12 <quicksilver> Saizan: to turn that into an Arrow, you add (arr), in a way which is consistent with Functor
02:22:21 <quicksilver> Saizan: and to get the CCC stuff you add Applicative
02:22:38 <quicksilver> Peaker: well you still need to define (>>>)
02:22:41 <Saizan> ok, so we're saying that  Category cat + forall a. Applicative (cat a) = Arrow cat
02:23:08 <quicksilver> Saizan: you need to also decide how to define 'arr'
02:23:16 <quicksilver> Saizan: (and you need to do that in a way which is consistent with fmap)
02:23:35 <ski>   instance ArrowProduct Either SP  -- ?
02:23:36 <quicksilver> fmap f = (>>> (arr f))
02:24:01 <quicksilver> Saizan: presumably you can have (>>>) and (arr) without actualy having the tuple/applicative stuff
02:24:03 <Saizan> i wonder if you can recover arr with fmap/pure ...
02:24:09 <quicksilver> but we don't have a name for that middle part
02:24:26 <quicksilver> I don't know if there any interesting things which satisfy >>>, arr laws without satisfying the tuple ones
02:24:40 <quicksilver> intuitively some kind of category with embedding but without preserving the CCC structure
02:24:43 <Peaker> quicksilver: So Applicative is not enough? I don't follow
02:24:56 <quicksilver> Peaker: Applicative replaces (&&&) (***) first second
02:25:05 <quicksilver> Peaker: (which always seemed to me 'second class citizens')
02:25:36 <Peaker> quicksilver: I see Arrow as just Category + "arr" + ***
02:25:48 <Baughn> quicksilver: Took me a minute of staring. Your applicative definition is definitely not something I could come up with on the bus.
02:25:50 <quicksilver> Saizan: I don't think so because 'pure' ignores the (a ~>) part
02:26:05 <quicksilver> Saizan: whereas 'fmap/arr' is supposed to use it.
02:26:13 <quicksilver> Peaker: agree.
02:26:19 <quicksilver> Peaker: I'm saying we can replace (***) with Applicative
02:26:29 <quicksilver> Peaker: which I like because I prefer function application to tuples
02:26:32 <quicksilver> Peaker: I prefer ($) to (,)
02:27:21 <Baughn>  :t (<*>) :: Arrow a => a b (c -> d) -> a b c -> a b d? Did I get that right?
02:27:24 <Peaker> quicksilver: how does that allow you to extract the graph structure?
02:27:41 <Saizan> ?type Control.Category.id
02:27:42 <lambdabot> forall (cat :: * -> * -> *) a. (Control.Category.Category cat) => cat a a
02:28:15 <Saizan> ?type \f -> pure f <*> Control.Category.id
02:28:16 <lambdabot> forall a b (cat :: * -> * -> *). (Applicative (cat a), Control.Category.Category cat) => (a -> b) -> cat a b
02:28:23 <Saizan> quicksilver: ^^^
02:28:37 <Saizan> maybe id is cheating :)
02:28:58 <Baughn> > (+3) >>> (*2)
02:28:59 <lambdabot>   {-3->0;-2->2;-1->4;0->6;1->8;2->10;3->12}
02:29:25 <Alpounet> :t (>>>)
02:29:26 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
02:29:37 <Peaker> quicksilver: Arrows without ArrowLoop disallow looped/recursive definitions, while Applicative does, isn't this a difference?
02:29:42 <quicksilver> Saizan: no, id isn't cheating
02:29:48 <quicksilver> Saizan: I wasn't expecting you to use <*>
02:29:51 <quicksilver> Saizan: but still, that's nice.
02:30:18 * ski wonders whether `ArrowProduct Either SP' would satisfy the laws
02:30:19 <quicksilver> Peaker: differnt kind of looping I think.
02:30:39 <quicksilver> Saizan: I was hoping to get 'arr' from merely Functor
02:30:44 <quicksilver> Saizan: but getting it from Applicative is still nice
02:30:57 <Peaker> quicksilver: different from what?
02:31:15 <quicksilver> Peaker: the kind of looping that ArrowLoop enables is different from the kind that Applicative enables, is my hunch
02:35:10 <Saizan> pure f <*> x = fmap f x, actually
02:35:23 <Saizan> ?type \f -> fmap f Control.Category.id
02:35:24 <lambdabot> forall a b (cat :: * -> * -> *). (Control.Category.Category cat, Functor (cat a)) => (a -> b) -> cat a b
02:35:53 <quicksilver> ah now *that's* what I wanted!
02:35:56 <quicksilver> Saizan++
02:36:08 <quicksilver> so, the picture is : Category + Functor gives you arr
02:36:18 <quicksilver> Category + Applicative gives you (***) and hence all of Arrow
02:36:41 <Peaker> and ArrowLoop? :(
02:36:49 <quicksilver> surely this must have been observed before but I've not seen it.
02:37:04 <quicksilver> Peaker: and ArrowChoice? is another good question.
02:37:31 <Saizan> not sure, but i think that kind of intuition is at the base of Wadler's Arrow notation (which had problems though iirc)
02:37:33 <Peaker> quicksilver: If it gives you all these, then that means that having just Arrow is not enough to give you Applicative, doesn't it?
02:38:08 <ski> Saizan : which intuition ? (and which problems ?)
02:38:51 <quicksilver> Peaker: yes it is
02:39:16 <quicksilver> Peaker: f <*> x can be defined as "(f &&& x) >>> (arr (uncurry ($)))"
02:39:44 <Saizan> ski: that you could rephrase Arrow with a notion of functiona application via something like a reader applicative, as for the problems no idea
02:40:16 <ski> (Saizan : is Wadler's Arrow notation different from the usual one ? .. or is it the usual one ?)
02:40:33 <Saizan> (different)
02:40:58 <ski> (do you know of a relevant paper ?)
02:41:34 <Saizan> ski: http://groups.inf.ed.ac.uk/links/arrows/
02:41:39 <ski> ty
02:41:58 <Peaker> quicksilver: when you convert to applicative and back - do you get the exact same arrow?
02:42:16 <quicksilver> Peaker: yes.
02:42:21 <Peaker> If so, maybe ArrowLoop is a redundant class -- because you can define ArrowLoop from Arrow
02:42:30 <quicksilver> I don't think you can
02:42:33 <quicksilver> what's the instance of Loop ?
02:42:36 <quicksilver> loop I mean
02:42:41 <quicksilver> Saizan: "Idioms are oblivious, arrows are meticulous, monads are promiscuous"
02:42:50 <quicksilver> Saizan: the abstract sounds like it covers what we have discussed
02:42:59 <quicksilver> http://homepages.inf.ed.ac.uk/wadler/topics/links.html
02:43:30 <ski> (quicksilver : is the other direction also identity ?)
02:43:37 <Peaker> we want to define:   ((a,r) ~> (b,r)) -> (a ~> b)
02:44:52 <Peaker> quicksilver: can you paste your above definitions arrow->app and back? Its hard to scroll back :)
02:44:54 <Baughn> quicksilver: http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html <-- Here, look at 7.10.1
02:44:57 * ski ponders `(a ~> b) -> ((a,r) ~> (b,r))'
02:44:59 <Peaker> quicksilver: I want to try to build the loop func
02:44:59 <Baughn> *That's* why the syntax is useful.
02:45:06 <Saizan> quicksilver: afaiu, on the relation between Arrow and Applicative that paper says that if you use the same construction we're using, but you limit yourself to the methods of Applicative, you lose expressivity
02:45:39 <Saizan> quicksilver: so it's pretty close, yeah :)
02:46:12 <Peaker> Baughn: That's like saying points-free sucks because look at what @pl produces :)
02:46:27 <Peaker> (I think with enough combinators, points-free always ends up nice :-)
02:46:35 <Baughn> Peaker: Uses lots of points, but..
02:47:04 <Baughn> Peaker: The point was, arrow syntax mostly gets rid of the tuples you were worrying about
02:47:23 <Peaker> Baughn: my problem with the tuples is that the arrow loses the structure
02:47:28 <ski> point-free is nice when the transformation is "algebraic" enough
02:47:57 <quicksilver> Peaker: a *** b = (,) <$> (arr fst >>> a) <*> (arr snd >>> b)
02:48:00 <Peaker> Baughn: say you want to propagate values throw only the relevant subset of the arrow graph, based on the dependencies
02:48:06 <Peaker> quicksilver: I meant - hpaste :)
02:48:15 <Peaker> quicksilver: I'll hpaste tho
02:48:18 <quicksilver> ;)
02:48:24 <Peaker> quicksilver: and the other direction?
02:48:34 <ski> where "algebraic" is meant in the sense of "algebraic transformations" : i.e. transformations that locally rewrites a few neighbouring nodes in the AST ..
02:48:41 <quicksilver> f <*> x = (f &&& x) >>> (arr (uncurry ($)))
02:49:02 <quicksilver> Baughn: ok will try to grok that later
02:49:11 <Peaker> quicksilver: how do you define "arr" and ">>>" ?
02:49:21 <quicksilver> Baughn: my use of arrows never uses 'first' or 'second'; I have to try to understand why what I'm doing is different.
02:49:30 <quicksilver> Peaker: (>>>) you have to be given.
02:49:30 <ski> .. as opposed to transformations that the uses non-local assumptions (often invoked by name) (not sure what to call this style)
02:49:35 <quicksilver> Peaker: you need the Category instance.
02:49:43 <Peaker> quicksilver: and "arr"?
02:49:47 <quicksilver> Peaker: Saizan managed to define arr for us
02:50:06 <quicksilver> arr f = fmap f (Control.Category.id)
02:50:09 <Baughn> quicksilver: First seems to mainly exist as plumbing for the arrow syntax, and I suppose people who hand-write its resulting code
02:50:45 <Peaker> Baughn: Any time a tuple goes into "arr" -- you lose all information of which subsets of the product were actually used/changed
02:50:51 <quicksilver> Baughn: sure, but they say "which is what you might have written by hand"
02:51:04 <Peaker> Baughn: so the problem is more deep/fundamental than the notation
02:51:12 <quicksilver> Baughn: and since I've never written anything remotely like that by hand, I"m wondering where the mismatch between my typical use and their suggested typical use is
02:51:37 <Baughn> quicksilver: Maybe the paper tells us. I'll tell you once I've read it.
02:52:54 <Baughn> Peaker: The syntax seems to imply that you should never explicitly consider tuples, or use tuple types anywhere in your own code
02:53:27 <Baughn> Peaker: Meanwhile, the syntax generator can keep track of what is used where, and project out unused variables, because it writes the arr expressions
02:53:41 <quicksilver> oh, I understand
02:53:49 <quicksilver> it's collecting together all your "inputs" into a big nested tuple
02:54:04 <quicksilver> running the arrs together, discarding unused outputs, and building what you actually wanted.
02:55:03 <quicksilver> I tend to strucutre my arrow programs as a bunch of arrows all with the same input, and a pure function to combine the results.
02:55:09 <quicksilver> which is why the Applicative instance works for me.
02:55:27 <mlesniak> Is there an equivalent of Double -> Foo as there is for Int -> Integer, i.e. I'm searching for a method to represent and calculate with an arbitrary (but defined by me) precision.
02:55:44 <quicksilver> I could instead use a big bundle of (&&&) and lift my pure function with arr
02:55:48 <quicksilver> mlesniak: CReal
02:55:54 <quicksilver> (package called numbers on hackage)
02:56:06 <mlesniak> quicksilver, Cool. Thanks!
02:56:10 <quicksilver> or 'Rational' but you don't get to limit the precision then
02:56:19 <quicksilver> it's Rational is just (Integer / Integer)
02:56:46 <shrughes> :t sin
02:56:47 <lambdabot> forall a. (Floating a) => a -> a
02:59:13 <Veinor> sin-cursed world....
02:59:24 <ski> mlesniak : note that `CReal' computes with infinite precision. if you want rounding to your precision on intermediate values, it's not for you
03:00:20 <ski> if anyone already have an account on <http://code.activestate.com/recipes>, they might want to correct the two errors at <http://code.activestate.com/recipes/231503/#c5> "Breadth first traversal of tree"
03:00:20 <Peaker> Baughn: the generator can - but the arrow instance can't
03:00:55 <Peaker> Baughn: if you write an arrow instance - promiscuous use of "arr" by the generator and your user prohibits you from having an exact data flow analysis
03:01:18 <Baughn> Peaker: True. It would be nice to fix that.
03:01:36 <ski> > fix $ \xs -> return 1 `mplus` do x <- xs; return (2*x) `mplus` return (2*x + 1)
03:01:36 <mlesniak> ski, yes, saw this, have to think if this it what I want. Background: want to calculate Pi to an arbitrary number of digits. Found http://en.literateprograms.org/Pi_with_Machin%27s_formula_%28Haskell%29 but it gets expensive (GC-wise) for huge numbers of digits.
03:01:37 <lambdabot>   No instance for (GHC.Show.Show (m t))
03:01:37 <lambdabot>    arising from a use of `M7018390505...
03:01:44 <Peaker> Baughn: abstract tuples and avoiding "arr" (with more combinators)could work
03:01:52 <ski> > fix $ \xs -> return 1 `mplus` do x <- xs; guard (x < 4); return (2*x) `mplus` return (2*x + 1)
03:01:53 <lambdabot>   No instance for (GHC.Show.Show (m t))
03:01:53 <lambdabot>    arising from a use of `M8063845441...
03:02:04 <ski> > fix $ \xs -> return 1 `mplus` do x <- xs; return (2*x) `mplus` return (2*x + 1) :: [Integer]
03:02:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:02:13 <ski> > fix $ \xs -> return 1 `mplus` do x <- xs; guard (x < 4); return (2*x) `mplus` return (2*x + 1) :: [Integer]
03:02:16 <lambdabot>   mueval-core: Time limit exceeded
03:02:33 <ski> > take 7 $ fix $ \xs -> return 1 `mplus` do x <- xs; guard (x < 4); return (2*x) `mplus` return (2*x + 1)
03:02:34 <lambdabot>   [1,2,3,4,5,6,7]
03:02:45 <yaxu> hi all, I'm trying to install hxt with cabal and get "cabal: cannot configure hxt-8.4.1. It requires base >=4.2 && <5"
03:02:55 <yaxu> i'm using the current haskell platform
03:03:20 <yaxu> is it telling me to upgrade ghc?  i'm on 6.10.4
03:03:24 <dcoutts> yaxu: looks like they made the latest hxt release require ghc-6.12, try an older hxt
03:03:25 <ski> > showCReal 200 pi  -- mlesniak
03:03:25 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
03:03:34 <yaxu> ok thanks dcoutts
03:03:43 <ski> (that might or might not be an efficient algorithm, i don't know)
03:03:47 <mlesniak> ski, :) thanks
03:04:13 <dcoutts> yaxu: for future reference, ghc-pkg list shows what you've got, and the base lib is special in that it can only be upgraded with ghc itself, not separate
03:04:42 <ski> Peaker : what do you mean by abstract tuples, here ?
03:05:37 <Peaker> ski: instead of tuples, arrows could use an abstract product type
03:05:45 <Peaker> ski: and combinators to operate on it
03:05:57 <ski> how woud that help, here ?
03:06:06 <yaxu> ok so cabal install hxt-8.3.2 does the job, thanks dcoutts
03:06:12 <Peaker> ski: well, it would prevent use of "arr" to manipulate the tuples, which forms "black boxes"
03:06:36 <ski> hm, i see .. that would be nice
03:06:43 <yaxu> I'm thinking of writing my thesis with pandoc and citeproc-hs, am I mad?
03:06:46 <opqdonut> what's the best way to have element-strict arrays of boxed data?
03:06:57 * ski was thinking you might be thinking of stuff like `ArrowProduct Either SP'
03:07:05 <opqdonut> or well, it doesn't need to be boxed but it is a custom datatype
03:07:45 <Saizan> ?src ArrowProduct
03:07:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
03:08:20 <Revelation> hi guys, can I do something like [x + y \\ x <-lista & y <-listb]? I get an error :(
03:08:44 <copumpkin> > [x + y | x <- [1..5], y <- [6..9]]
03:08:45 <lambdabot>   [7,8,9,10,8,9,10,11,9,10,11,12,10,11,12,13,11,12,13,14]
03:08:53 <Revelation> the generators are dependent
03:08:53 <gspr> If I have a module installed somewhere, and it is not registered in either the global or local package lists, how can I tell GHC where to look for it?
03:08:57 <copumpkin> Revelation: it would help if you learned Haskell's syntax first
03:09:12 <copumpkin> Revelation: doesn't make a difference
03:09:28 <Revelation> copumpkin: I am familiar with a langauge called Clean, and in that language you can have dependent generators
03:09:46 <copumpkin> dependent generators?
03:09:54 <ski> Saizan : something like `class ArrowProduct p (~>) where fstA :: p a0 a1 ~> a0; sndA :: p a0 a1 ~> a1; (&&&) :: (a ~> a0) -> (a ~> a1) -> (a ~> p a0 a1)'
03:10:06 <Revelation> the indices are incremented for both lista and listb
03:10:10 <Revelation> at the same time
03:10:24 <copumpkin> > [x + y | x <- [1..5] | y <- [6..]
03:10:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:10:28 <copumpkin> > [x + y | x <- [1..5] | y <- [6..]]
03:10:29 <lambdabot>   [7,9,11,13,15]
03:10:31 <ski> (well, add `Arrow (~>)' to that, for a reformed `Arrow' (i.e. possibly `Category' instead))
03:10:36 <copumpkin> > zipWith (+) [1..5] [6..]
03:10:37 <lambdabot>   [7,9,11,13,15]
03:10:44 <yaxu> hm now I'm getting the same compilation error as whoever pastied this; http://pastie.org/pastes/786624
03:10:46 <Revelation> that's what I want I think :)
03:11:13 <ski> Revelation : i would call that lock-step or "parallel" or simultaneous generators
03:11:15 <copumpkin> it's an extension
03:11:48 <ski> (though "parallel" is not really that good a term for this)
03:11:52 <Saizan> ski: and SP?
03:11:52 <Revelation> ski: that may be a better term yes, I couldn't find an official one in my search
03:12:20 <quicksilver> Peaker: yes, 'arr' prevents all kinds of analysis.
03:12:22 <ski> Saizan : `data SP a b = Get (a -> SP a b) | Put b (SP a b)' (`SP' standing for "Stream Processor")
03:13:11 <ski> (to be more specific, that's asychronous stream processors .. there's also (even and odd) synchronous stream processors)
03:13:15 <Peaker> quicksilver: I am trying to figure out, if there's this equivalence, why do informed individuals still find utility in arrows (even when not using arrow notation)?
03:13:52 <copumpkin> Peaker: because they're handy combinators and everybody just uses the (->) arrow anyway
03:13:56 <Saizan> ski: ah, so for each input you'd produce two outputs in (&&&) with Either and SP?
03:14:02 <ski> yes
03:14:07 <Peaker> copumpkin: the same combinators could supposedly use just category/applicative
03:14:17 <ski> but i'm not sure how much of the laws are satisfied by this
03:14:38 * Cyneox re
03:14:46 <copumpkin> Peaker: or just (->) :P more or less the same number of people would still use them
03:14:57 <ski> (partly because i don't remember exactly what laws are required on the product in `Arrow' :)
03:15:16 <Veinor> there's no way to determine whether a list is infite, I assume
03:15:40 <ski> Veinor : right
03:15:41 <copumpkin> Veinor: not purely
03:15:49 <copumpkin> and even if not purely, most of the time no
03:16:05 <Veinor> data TaggedList = Bool [a]
03:16:26 <copumpkin> Bool :: * -> *
03:16:30 <ski> Veinor : error : unbound type variable `a'
03:16:33 <quicksilver> Peaker: very very few informed individuals do find utility in using arrows.
03:16:35 <copumpkin> alias data = type
03:16:39 <Veinor> yeah, yeah :P
03:16:57 <quicksilver> Peaker: the arrow combinators not very handy and rather seldom used :)
03:17:00 <Veinor> it's 6:16 am, cut me some slack
03:17:13 <Peaker> quicksilver: well, arrowized-frp, and conal's Eros
03:17:20 <Veinor> although... it's easy to show that extracting the bool is undecidable
03:17:22 <ski> (Veinor : i might, if i understood what you were after ;)
03:17:24 <quicksilver> they weren't arrows, Peaker
03:17:27 <quicksilver> IIRC
03:17:34 <Veinor> data TaggedList a = Bool [a]
03:17:39 <quicksilver> they were just things with composition
03:17:44 <quicksilver> (Categorys, say)
03:17:46 <copumpkin> Veinor: same time here! and I've been up since 3am two days ago :P
03:17:55 <Veinor> :P
03:18:05 <Peaker> quicksilver: at least conal's eros was a "deep arrow"
03:18:08 <copumpkin> in fact, the bean bag is beckoning
03:18:11 <Veinor> oh yeah, you live ~near me, don't you
03:18:16 <Peaker> quicksilver: (arrow-without-arr but with a bunch of alternate combinators)
03:18:25 <copumpkin> Veinor: yeah! did you go to the HUG btw?
03:18:32 <Peaker> quicksilver: http://www.haskell.org/haskellwiki/DeepArrow
03:18:32 <copumpkin> I was busy cramming so couldn't go
03:18:34 <Veinor> No, I slept through it :(
03:18:37 <copumpkin> lol
03:18:39 <copumpkin> nice
03:18:45 <Veinor> planned on going, though
03:18:46 <Veinor> :P
03:18:47 <ski> Veinor : hm .. maybe you mean to have `Bool' as the type of an argument to a data constructor not named `Bool' ?
03:18:52 <copumpkin> it's the thought that counts
03:19:20 <quicksilver> Peaker: yes. so, not arrows.
03:19:32 <quicksilver> Peaker: so not relevant to what we were just talking about exactly.
03:19:35 <quicksilver> (although definitely interesting)
03:19:47 <Veinor> data TaggedList a = TaggedList Bool [a]
03:19:50 <ski> Veinor : if so, note that it is easy to create a list where you don't know beforehand whether it will be finite or not .. even one whose finiteness is undecidable :)
03:19:50 <Veinor> there we go
03:19:59 <Peaker> quicksilver: Yampa just needs Category? I don't think that's the case..
03:20:00 <quicksilver> Peaker: but not an answer to your quesiton "why do smart people find Arrows useful)
03:20:01 <Veinor> yeah.
03:20:40 <copumpkin> alright, time for some hot beanbag action
03:21:02 <quicksilver> Peaker: I don't know. I've never tried to understand yampa.
03:21:50 <Veinor> I kind of want to write a function myLiftM2 that takes a function and two lists and applies it 'diagonally'
03:22:10 <Veinor> by which I mean applies it in a way such that every combination will eventually occur, even if said lists are infinite
03:22:32 <quicksilver> Peaker: looks like yampa really is arrows, yes.
03:22:33 <copumpkin> control-monad-omega
03:22:36 * copumpkin mumbles in his sleep
03:22:41 <pao> how is the status of ghc on sparc64?
03:22:50 <yaxu> how do I downgrade a cabal installed package?  I've explicitly installed an old version of tagsoup, but the latest version is still there and is overriding it
03:23:18 <Veinor> copumpkin: oh hey, nice
03:23:39 <copumpkin> Veinor: I tried for a few days straight to prove something very similar to that correct in agda
03:23:41 <yaxu> ah, with ghc-pkg
03:23:47 <Peaker> @hoogle ApplicativeFix
03:23:47 <lambdabot> No results found
03:23:52 <copumpkin> failed miserably :)
03:23:53 <Peaker> @src MonadFix
03:23:53 <lambdabot> class (Monad m) => MonadFix m where
03:23:53 <lambdabot>     mfix :: (a -> m a) -> m a
03:23:57 <Veinor> hah
03:24:00 <Peaker> why not ApplicativeFix?
03:24:11 <copumpkin> but luckily dolio succeeded by writing a simpler function that does the same thing and is less painful to prove stuff about
03:24:14 <Saizan> yaxu: see ghc-pkg unregister
03:24:18 <Peaker> quicksilver: I think this ^^ might be the ArrowLoop equivalent
03:24:38 <Saizan> yaxu: ah, too late, cheers :)
03:25:06 <yaxu> thanks anyway Saizan :)
03:25:28 <Saizan> Peaker: f (a -> a) -> f a, probably
03:25:50 <Peaker> Saizan: isn't that just fmap fix ?
03:25:57 <Peaker> @type fmap fix
03:25:57 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
03:28:05 <Peaker> what's wrong with afix :: Applicative f => (a -> f a) -> f a ?
03:28:57 <ziman> :t mfix
03:28:58 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
03:29:06 <Saizan> that (a -> f b) is not the usual notion of function in Applicative, for my taste :)
03:29:55 <quicksilver> it wouldn't be fmap fix
03:30:00 <quicksilver> fmap fix only 'does the effects' once
03:30:08 <quicksilver> you'd want to fix the effects too wouldn't you?
03:30:13 * quicksilver hasn't really thought this through.
03:30:24 <Saizan> mfix and ArrowLoop are supposed to perform the effects once too
03:30:26 <Peaker> what does fixing the effects mean?
03:30:30 <ziman> Veinor, there's Control.Monad.Omega
03:30:33 <quicksilver> yeah, Saizan said it
03:30:35 <quicksilver> I was wrong.
03:30:37 <ski> `mfix' is meant to do the effects only once, afaiu
03:30:41 <quicksilver> maybe fmap fix is enough then?
03:30:52 <quicksilver> it's not quite what you need for arrows though
03:30:54 <opqdonut> how can I get profiling libs with cabal-install? --enable-executable-profiling doesn't seem to help...
03:31:02 <Saizan> ?type loop
03:31:03 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
03:31:16 <Saizan> opqdonut: --enable-library-profiling
03:31:18 <RayNbow> @where typeclassopedia
03:31:18 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
03:31:27 <Peaker> well, you composed a bunch of applicative values to one big  (b, d) -> (f (c, d)) -- right?
03:31:59 <quicksilver> yes
03:32:05 <Saizan> really?
03:32:07 <quicksilver> but I didn't feel the need to loop any ds
03:32:25 <quicksilver> but yes, I composed a bunch of values in that kind of way
03:32:27 <Saizan> where the arrow there is Kleisli f ?
03:32:43 <Saizan> or, at least, has that form
03:32:46 <quicksilver> has that form, yes
03:32:51 <quicksilver> but not actually using the monad instance for f
03:33:00 <opqdonut> Saizan: ah thanks, that wasn't documented
03:33:30 <quicksilver> obviously (Applicative f) => Applicative (r -> f a)
03:33:39 <quicksilver> that's "ReaderT" for applicative
03:33:47 <quicksilver> or, it just follows from composition of applicatives.
03:33:50 <Veinor> ziman: yeah, copumpkin linked me to it
03:35:18 <o-_-o> I am of for the weekend, shutting down, as I am doing an upgrade
03:35:20 <o-_-o> bye guys
03:35:33 <o-_-o> thanks a bunch Peaker, I'll catch next week
03:38:14 <ziman> Veinor, ah i see, i missed it
03:41:23 * Saizan wonders if you can write Category cat, Applicative f => Category (\a b -> cat a (f b))
03:42:36 <quicksilver> Saizan: I believe you cannot
03:42:47 <ivanm> this is atrocious: http://yumagene.livejournal.com/2752.html
03:43:09 <quicksilver> Saizan: when you try to write (>>>) you get a -> f b, b -> f c giving you a -> f (f c)
03:43:15 <quicksilver> Saizan: and of course you don't have join
03:43:21 <quicksilver> Saizan: unless I've missed something clever.
03:43:35 <quicksilver> I was thinking along these lines myself
03:43:41 <ivanm> that blog post seems to be from the "let's randomly capitalise words!" school of blogging
03:44:01 <quicksilver> my specific case does have 'join' so it is a monad, but I'm not using the applicative instance which matches ;)
03:44:05 <quicksilver> it's Either.
03:45:41 <Saizan> makes sense
03:45:49 <quicksilver> btu I want the applicative instance which combines multiple erorr messages
03:45:54 <quicksilver> instead of giving up at first failure
03:46:06 <quicksilver> but my (>>>) instance does, of course, give up on first failure
03:46:15 <quicksilver> since you have no choice there, you can't 'run' the second half if the first half failed.
03:46:22 <Saizan> yeah
03:46:41 <quicksilver> so the (>>>) instance is the one you would get from Kleisli Monad, but the Applicative instance I choose is the other one.
03:47:10 <Saizan> we can have Category (~>), Applicative f => Category (\a b -> f (a ~> b)), but that's not as much interesting
03:47:31 <quicksilver> so the implication of this is that I'm using the (>>>) from Kleisli
03:47:41 <ski> ivanm : truly, that looks horrible
03:47:41 <quicksilver> but I'm *not* using the (&&&) from Kleisli
03:47:51 <quicksilver> I'm using a 'better' one which runs both paths even if one failed
03:48:53 <Saizan> quicksilver: i wonder if Category cat + forall a. Applicative (cat a) preserves all the laws of Arrow then
03:49:22 <ski> i don't see why anyone would define a function of type `m a -> m b' of form `(f =<<)' for a monad `m', except to pass to some place expecting that interface
03:49:31 <quicksilver> Saizan: I'm pretty sure it does.
03:49:54 <quicksilver> Saizan: (f <$> C.C.id) is definitely a well-behaved arr
03:50:02 <ivanm> ski: good, I'm not the only one that thinks so
03:50:05 <quicksilver> Saizan: and I'm pretty sure that my (***) is well behaved.
03:51:33 <ivanm> @remember RossPaterson I'm afraid you voided the warranty when you used UndecidableInstances.
03:51:33 <lambdabot> It is stored.
03:53:26 <Peaker> ski: yeah, if you need an "a" and take an "m a" instead, that's pretty horrible..
03:55:20 <ivanm> ski: I started reading it but couldn't continue :s
03:56:49 <opqdonut> @src mapAccumL
03:56:49 <lambdabot> mapAccumL _ s []        =  (s, [])
03:56:49 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
03:56:49 <lambdabot>    where (s', y ) = f s x
03:56:49 <lambdabot>          (s'',ys) = mapAccumL f s' xs
03:57:23 <quicksilver> dear ross, actually I think overlapping and incoherent are much much worse, kthxbai
03:57:43 <quicksilver> undecidable just says you're smarter than the compiler and know when something will terminate.
03:57:46 <SamB_XP> quicksilver: how disjointed
03:58:15 <ivanm> quicksilver: incorehent? is that your term for flexible?
03:58:28 <quicksilver> ivanm: no, Incoherent is my term for Incoherent...
03:58:40 <ivanm> well, the email in question has {-# LANGUAGE FlexibleInstances, OverlappingInstances, UndecidableInstances #-}
03:58:42 <SamB_XP> ivanm: incoherent is where the instances overlap and disagree
03:58:46 <ivanm> s/email/code
03:58:53 <ivanm> SamB_XP: ahhh
03:58:59 <SamB_XP> and the compiler doesn't care
03:59:43 <SamB_XP> it would honestly be safer to code in C++
03:59:51 <ivanm> than...?
03:59:51 <quicksilver> undecidable just turns of the termination checker, which can be find if you're doing something clever outside of the heuristics of the GHC termination checker.
04:00:01 <quicksilver> s/find/fine/
04:00:04 <SamB_XP> then enabling incoherant instances!
04:00:11 <ivanm> ahhh
04:00:17 <quicksilver> overlapping actually shatters the language into tiny inconsistent pieces
04:00:26 * ivanm just uses whatever extensions ghci tells him he needs
04:00:43 <quicksilver> and incoherent files off the edges of the pieces so they don't even fit together any more.
04:00:46 <ivanm> overlapping is when you have something like instance Foo (a, [Int]) or something, isn't it?
04:01:00 <ivanm> so why does incorehent exist?
04:01:09 <quicksilver> (instance Foo a) as well as (instance Foo [Int]) , yes
04:01:31 <quicksilver> to let people experiment with weird type level programs which might be interesting.
04:04:30 <interferon> one thing i'm having trouble understanding with monads - why does getLine return an IO monad, but not accept one as a parameter?
04:04:53 <interferon> is it because the function just returns a command and the IO monad itself chains them together?
04:06:01 <ivanm> why should it?
04:06:10 <ivanm> it operates within the IO monad
04:06:16 <ivanm> and gets something from the environment
04:06:21 <BONUS> think of IO a as an IO action that, when executed, yields some value of type a
04:06:30 <ivanm> yeah, that's probably a better way of doing it
04:06:32 <BONUS> getLine is an IO String, so an IO action that will yield a string, that's it
04:06:55 <SamB_XP> interferon: it doesn't return "an IO monad"
04:07:14 <SamB_XP> the IO monad exists at the type level, not the value level
04:07:33 <ivanm> interferon: http://random.axman6.com/blog/?page_id=70
04:07:44 <SamB_XP> getLine *is* an action in the IO monad
04:08:17 <interferon> SamB_XP: i don't know what you mean
04:09:09 <SamB_XP> well, does [1,2,3] evaluate to the list type, or to a list?
04:19:40 <interferon> a list
04:21:07 <dmwit> interferon: What argument would you like getLine to take?
04:21:38 <interferon> something like getLine :: IO () -> IO String
04:21:52 <dmwit> interferon: Okay, that's a fine type.  But what would the meaning of the argument be?
04:21:57 <dmwit> How would getLine use that argument?
04:22:12 <dmwit> i.e. what would
04:22:25 <dmwit> getLine  (putStrLn "WTF") -- mean?
04:22:25 <dmwit> or
04:22:39 <dmwit> getLine (writeIORef referenceToSomeMemory 3) -- ?
04:22:52 <SamB_XP> maybe he's thinking of continuation-passing style ?
04:23:11 <dmwit> Maybe we should let him say what he's thinking.
04:23:13 <interferon> :)
04:23:25 <interferon> i guess i understand the IO monad as passing an IO token around
04:23:41 <interferon> so i thought actions were sort of composing the previous action into a new one
04:23:59 <dmwit> Nothing you've said so far sounds horribly wrong to me.
04:24:15 <dmwit> Although we have a specific function for this composition.
04:24:17 <BONUS> it's not really passing a token around
04:24:17 <dmwit> :t (>>)
04:24:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
04:24:22 <interferon> so i thought getLine would need the IO token from a previous action
04:24:31 <interferon> but  I guess it's the IO monad itself that does the chaining?
04:24:36 <BONUS> it's about taking actions and gluing them together
04:24:40 <Botje> yes
04:24:40 <BONUS> into bigger actions
04:24:42 <ivanm> sounds like the old pre-monad IO stuff with the explicit world state (from what I've read, anyway)
04:24:45 <dmwit> interferon: No, it's the (>>) function (or (>>=) function) that does the chaining.
04:24:46 <Eelis> interferon: you /can/ think of it as token passing, but it happens behind the scenes. you can think of   a -> IO b   as    a -> (token -> (token, b))
04:24:55 <BONUS> but yeah, the IO monad does that for you with >>=
04:25:03 <ivanm> interferon: the do block syntax is syntactic sugar for >> and >>=
04:25:22 <BONUS> so it's not entirely wrong, it's just better to think about it in terms of gluing together actions
04:26:06 <interferon> so i think i need to make a better distinction between >>= and company and the monad type itself
04:26:23 <Botje> BONUS: is there any news yet about your book?
04:27:08 <ivanm> Botje: the reviewers went insane
04:27:08 <ivanm> :p
04:27:13 <interferon> hehe
04:27:16 <BONUS> Botje: no news per se, we're still in the editing process. also no set time date but we're thinking of releasing it summer-ish
04:27:27 <Botje> can't wait to see it :)
04:27:30 <BONUS> but it's definitely coming along
04:27:43 <ivanm> oh, and Simon Thompson told me the other day that he's working on version 3 of the Craft of Functional Programming
04:27:48 <ivanm> s/version/edition/
04:28:00 <BONUS> once the editor (and mmorrow) goes over the whole thing im gonna merge that back on the web too
04:28:03 <interferon> what book are you working on?
04:28:11 <BONUS> interferon: Learn You a Haskell
04:28:16 <interferon> ah! i love that book
04:28:19 <interferon> good luck
04:28:22 <BONUS> haha thx
04:28:42 <BONUS> also i was thinking of drawing a few covers and letting the people vote which one they want on the book
04:29:15 * ivanm votes for plain text + some math
04:29:16 <ivanm> ;-)
04:29:17 <BONUS> as soon as we have a release date i'm going to turn on the hype machine, dons style :D
04:29:25 <ivanm> oh noes...
04:29:33 <Botje> change your name to BONS then :)
04:29:38 <BONUS> lol
04:29:53 <ivanm> donus? :p
04:30:02 <interferon> so i think my confusion about the IO monad arose while trying to understand Yi (wanted to see how a large haskell project was written).  and a lot of functions there return a BufferM.  i guess that those functions return an action similar to what IO functions do?
04:30:07 <BONUS> hahah
04:31:28 <interferon> (btw, any other recommendations for large Haskell projects to learn from?)
04:31:31 <SamB_XP> BONUS: do you have a website where people can scribble all over the book ?
04:31:37 <Saizan> interferon: xmonad
04:31:45 <SamB_XP> I was going to say xmonad too
04:31:52 <BONUS> scribble over my book? :O
04:31:57 <SamB_XP> I dunno about large, but it seems kinda popular for what it is
04:32:23 <shrughes> well it's a decent one
04:32:23 <SamB_XP> I mean, who would have thought that a window manager that has to be configured by writing a Haskell program would catch on so well?
04:32:40 <SamB_XP> and it sounds very clean
04:33:13 <interferon> ok cool
04:33:17 <interferon> will take a look at that too
04:33:28 <interferon> yi might actually be too large for me :)
04:33:47 <ivanm> BONUS: I'm guessing that SamB_XP means ala RWH
04:33:55 <shrughes> xmonad is more than 400 lines now though, isn't it
04:34:03 <BONUS> yeah. i thought about doing something like that but it turns out i'm just too lazy
04:34:06 <BONUS> haha
04:34:14 <interferon> shrughes: yi is like 30k :)
04:34:36 <SamB_XP> BONUS: isn't bos handing out the source for what they used to one and all ?
04:34:40 <ivanm> shrughes: definitely
04:34:45 <ivanm> especially if you include contrib...
04:35:20 <quicksilver> interferon: yes,  (BufferM a) means "returns an 'a' and also modifies a buffer in some way
04:35:28 <quicksilver> that's my understanding, at least
04:35:32 <shrughes> interferon: it might be neat to look at XMonad 0.1, 0.2, 0.3, ...
04:35:41 <interferon> shrughes: that's a good idea
04:35:46 <SamB_XP> also, SPJ did a presentation!
04:35:54 <SamB_XP> you should watch the videos maybe
04:35:54 <BONUS> SamB_XP: yeah but still i'd have to rework everything i did so far into that model
04:36:03 <ivanm> SamB_XP: about what?
04:36:20 <SamB_XP> "a taste of Haskell" or something like that
04:36:35 <SamB_XP> BONUS: oh, right, you'd need to use the same format I guess then ;-)
04:36:47 <ivanm> oh, yeah
04:36:53 <ivanm> I recall watching that one
04:36:54 <BONUS> yeah currently i have a very ad hoc writing process, i just open a text editor and bash away
04:37:04 <ivanm> that was soon after the first version of xmonad came out, wasn't it?
04:37:11 <SamB_XP> SPJ is very animated ;-)
04:37:23 <ivanm> yup
04:37:32 <SamB_XP> ivanm: I think it was probably a bit past 0.1 ...
04:37:43 <ivanm> *shrug* can't recall
04:37:48 * ivanm heads off
04:37:52 <SamB_XP> but still maybe soon past
04:38:05 <shrughes> i'm p sure it wasn't 0.1 or 0.2
04:40:16 <shrughes> No I'm wrong, it must have been 0.2
04:41:17 <ski> hm, iirc, one can get incoherence without using `IncoherentInstances'
04:42:20 <SamB_XP> ski: if you try hard enough, I guess
04:46:29 <DekuNut> Using haskell lightweight threads, how exactly does the schedular pre-emptively interupt the threads?
04:47:09 <Saizan> DekuNut: when they call back into the RTS for some reason
04:47:18 <Saizan> DekuNut: like allocation
04:47:50 <Saizan> so it's preemptive only at the source level, so to speak
04:47:57 <SamB_XP> not "so to speak"
04:47:59 <SamB_XP> in fact
04:48:13 <DekuNut> So if I spawn a thread that never calls back to the RTS, it's not going to schedule particularly well?
04:48:28 <SamB_XP> indeed
04:48:34 <DekuNut> Interesting...
04:48:40 <DekuNut> Thank you
04:48:40 <SamB_XP> there's an open bug about it
04:48:51 <DekuNut> ah
04:49:19 <Saizan> if you've more than one worker thread, e.g. passing -N2 the others should not starve though
04:49:33 <ski> e.g. define `class Foo a where foo :: a -> Bool' with `instance Foo a => Foo [a] where foo _ = False' and a function `bar xs = foo (map id xs)', then in another module, do `instance Foo Char where foo _ = undefined' and `instance Foo [Char] where foo _ = True', now try `bar "abc"' vs. `foo (map id "abc")'
04:50:13 <ski> (the problem is that the type of `bar' is `bar :: Foo a => [a] -> Bool', rather than `bar :: Foo [a] => [a] -> Bool')
04:50:19 <SamB_XP> hmm, awfully nice of GNU to have a webpage for flex to point you at the real webpage, since it turns out that they don't make flex ;-)
04:50:27 <Saizan> (with overlapping instances, right?)
04:51:01 <ski> Saizan : with overlapping (on one module), and flexible (on the other), but not using incoherent, right
04:51:17 <gio123> ski: hi
04:53:02 <quicksilver> DekuNut: however it's very hard to do that
04:53:14 <quicksilver> DekuNut: (have a thread which never calls back to the RTS)
04:53:52 <quicksilver> ski: yes, GHC's implementation separate compilation is inherently incoherent.
04:54:14 <Saizan> module A where instance Foo Char where ..; bar = foo 'a'; module B where instance Foo Char where .. -- different; baz = foo 'a'; module C where import A; import B; r = bar == baz -- r = False; -- is this incoherence too?
04:54:24 <quicksilver> ski: IIRC you don't even need overlapping to get incoherence, you just need a few modules of indirection, but I could be wrong.
04:55:08 <SamB_XP> I would have thought GHC would catch it when compiling Main
04:55:20 <ski> quicksilver : i was under the impression i didn't even need separate modules to exhibit this behaviour, but i couldn't get it through that way atm at least ..
04:56:01 <DekuNut> quicksilver, ah ok, not much to worry about then, thanks
04:57:07 <quicksilver> ski: I think it's coherent in a single module.
04:57:49 <ski> Saizan : i would assume that wouldn't get through with only `OverlappingInstances' ..
05:04:06 <Saizan> ski: it gets through with no extensions, actually
05:06:13 <ski> Saizan : .. strange
05:06:24 <quicksilver> it's a "bug" in GHC
05:06:44 <quicksilver> although SPJ seems to consider it the correct trade-off
05:06:57 <quicksilver> there is a post somewhere of augustss expressing polite astonishment
05:09:41 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/2356
05:09:48 <quicksilver> augustss is the first guest
05:12:00 <opqdonut> ah, a judiciously applied `using` saves the day again
05:15:36 <dmwit> quicksilver: Wow, the difference between the type (Ord Foo => Set Foo -> Bool) and (Set Foo -> Bool) there is quite subtle.
05:15:54 <quicksilver> dmwit: interesting isn't it?
05:17:03 <dmwit> That is the kind of thing that could make it into an Underhanded Haskell Competition submission. =)
05:17:11 <dmwit> ...if there were an Underhanded Haskell Competition.
05:17:19 <quicksilver> absolute global instances are fundamental for typeclasses to work
05:17:29 <quicksilver> this example is a clear example of why :)
05:17:45 <quicksilver> where by "work" I mean "be usable for what we use them for"
05:17:49 <quicksilver> not "be useful in some other way"
05:17:58 <quicksilver> non-global things would be useful, but not for guaranteeing invariants.
05:30:56 * ski wonders whether there is nice way to get the alternative iterative-deepening breadth-first enumeration to work on finite trees ..
06:01:41 <hcube> Hi! When will be c2hs compatible with ghc 6.12?
06:03:23 <quicksilver> wasn't jrockway muttering about c2hs the other day?
06:04:53 <hcube> i've seen a discussion about missing CLDouble problem in the mailing list
06:05:08 <hcube> but that was a couple of weeks ago
06:08:15 <mreh> do you think you could parse parallel lines of text?
06:08:31 <quicksilver> @faq Can we parse parallel lines of text?
06:08:31 <lambdabot> The answer is: Yes! Haskell can do that.
06:09:17 <mreh> parser = many1 (do { firstLine ; secondLine })
06:10:10 <Saizan> put a parseNewLineMarker in the middle there?
06:10:22 <mreh> :t parseNewLineMarker
06:10:23 <lambdabot> Not in scope: `parseNewLineMarker'
06:10:24 <Saizan> unless that's included in firstLine
06:10:29 <mreh> is that a real function?
06:10:32 <Saizan> no
06:10:51 <Saizan> i was thinking of char '\n'
06:10:59 <mreh> I didn't realise they had one, do they also have a "spaces" that doesn't eat \n
06:11:03 <Saizan> or string "\r\n" if you've that
06:12:03 <Saizan> you can make one easily, spaces = many1 (satisfy (\c -> isSpace c && c /= '\n'))
06:12:26 <mreh> that's a nice way of doing it
06:18:52 <quicksilver> satisfy(liftA2 (&&) isSpace (/='\n'))
06:28:13 <temoto> @undo do { op <- foo; return $ \x y -> bar x op y }
06:28:13 <lambdabot> foo >>= \ op -> return $ \ x y -> bar x op y
06:30:44 <mauke> @pl foo >>= \ op -> return $ \ x y -> bar x op y
06:30:44 <lambdabot> flip bar `fmap` foo
06:33:35 <temoto> wow nice :)
06:34:52 <temoto> @pl do { op <- foo; return $ \x y -> bar x op y }
06:34:52 <lambdabot> (line 1, column 4):
06:34:52 <lambdabot> unexpected "{"
06:34:52 <lambdabot> expecting variable, "(", operator or end of input
06:35:13 <mauke> @. pl undo  do { op <- foo; return $ \x y -> bar x op y }
06:35:14 <lambdabot> flip bar `fmap` foo
06:36:20 <Botje> i wonder what kind of drinks the flip bar would serve
06:37:50 <Badger> Botje: unsafePerformIO on the beach
06:38:37 <ddarius> I agree with dmwit's reaction to the class context thing.
06:40:08 <Botje> Badger: evil never tasted so good.
06:40:42 <ddarius> Well flip is the isomorphism mediating the adjunction that leads to the continuation monad.
06:40:47 <etpace> anyone know of a higher order way of doing: f t [] = return t; f t (e:es) = do { e' <- eval e []; f (g t e') es }?
06:40:58 <Baughn> > loop (\(b,d) -> (c,d)) 42
06:40:59 <lambdabot>   c
06:41:05 <Baughn> > loop (\(b,d) -> (b,d)) 42
06:41:06 <lambdabot>   42
06:41:16 <xerox> haha, c
06:41:27 <ddarius> etpace: Looks like a foldr.
06:41:34 <Baughn> > loop (\(b,d) -> ((b:d),d)) 42
06:41:38 <lambdabot>   mueval-core: Time limit exceeded
06:42:06 <Baughn> > loop (\(b,d) -> (d,b:d)) 42
06:42:07 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
06:42:10 <etpace> hmm that might have been my problem, I used foldlM
06:42:23 <ddarius> :t flip id
06:42:24 <lambdabot> forall a b. a -> (a -> b) -> b
06:42:26 <etpace> :t foldrM
06:42:27 <lambdabot> Not in scope: `foldrM'
06:42:33 <etpace> @hoogle foldrM
06:42:33 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
06:43:48 <ddarius> :t \t -> foldr (\e es' -> eval e [] >>= \e' -> return $ g t e') (return t)
06:43:49 <lambdabot> Not in scope: `eval'
06:43:59 <ddarius> :t \t -> foldr (\e es' -> ?eval e [] >>= \e' -> return $ ?g t e') (return t)
06:44:00 <lambdabot> forall a a1 a2 (m :: * -> *) a3. (?eval::a -> [a2] -> m a1, Monad m, ?g::a3 -> a1 -> a3) => a3 -> [a] -> m a3
06:45:16 <etpace> looks great, cheers
06:53:24 <temoto> http://codepad.org/nPM3sVzj could anyone help with Parsec, please?
06:55:22 <quicksilver> temoto: try parsing it as a parseApply
06:55:29 <temoto> oh right
06:55:45 <temoto> it works as expected
06:55:53 <temoto> Right (Apply (Name "foo") (Name "x"))
06:56:02 <ski> (what is `parseApply' ?)
06:56:14 <temoto> parseApply = liftM2 Apply atomexpr atomexpr
06:56:27 <quicksilver> temoto: good.
06:56:35 <quicksilver> temoto: I think its parsing as a parseInfix
06:56:44 <quicksilver> (just a parseInfix with no infix operators)
06:56:57 <quicksilver> test that (try parsing it as parseInfix)
06:57:18 <etpace> Hmm, my lambda calculator has a bug: eval (and $ true $ true) gives me (\x. \y. \x. \y. y), obviously this can be reduced to true, but if I do eval (eval (and $ true)) $ true, then I get the correct \x. y. x, bit of a vague question but where do you think would be the best place to look for it not completely beta evaluating the first, but will in the second
06:57:28 <ski> (.. ok, something application-specific .. i was thinking it was a generic thing of some sort)
06:58:00 <temoto> quicksilver: you're right.
06:58:11 <quicksilver> temoto: because (A) is a case of (A op B op C)
06:58:12 <temoto> parse parseInfix  "test" "foo x"
06:58:14 <temoto> Right (Name "foo")
06:58:17 <quicksilver> temoto: it's just the case with no ops :)
06:58:24 <temoto> But the result is what i couldn't expect.
06:58:38 <quicksilver> you could just move parseApply before parseInfix
06:59:02 <temoto> Because parseInfix chainl1 <-- *1*
06:59:11 <Saizan> etpace: what's the type of eval?
06:59:18 <temoto> chain via infixAny
06:59:30 <temoto> and my infixAny doesn't match empty string
06:59:48 <bo0ts__> Why is the speed difference between those two so large? http://codepad.org/5gdBjD4D
07:00:07 <etpace> eval is Expr -> [Expr] -> m Expr, where [Expr] a list of expressions to be applied
07:00:33 <bo0ts__> I tested it for really large values and the second version performs horrible. You can see each character being printed.
07:00:51 <quicksilver> temoto: 1 not 2 :)
07:00:58 <quicksilver> temoto: 1 means it matches at least 1, not at least 2
07:01:04 <temoto> @concatMap
07:01:05 <lambdabot> Unknown command, try @list
07:01:07 <temoto> @src concatMap
07:01:07 <lambdabot> concatMap f = foldr ((++) . f) []
07:01:08 <quicksilver> I.e. (A) is already but not just ()
07:01:16 <Saizan> etpace: i'd guess you forgot to recurse on the left argument of application to reduce it to a lambda before trying to substitute
07:01:18 <quicksilver> like many matches zero but many1 matches 1 or more
07:02:05 <temoto> quicksilver: oh well, maybe it would be better to enforce it wait for 2 somehow?
07:02:15 <quicksilver> could do, yes
07:02:28 <quicksilver> or you could just make infixApply higher priority by putting it first ;)
07:02:36 <temoto> Right.
07:03:23 <Saizan> bo0ts__: does it use a lot of memory?
07:03:33 <Saizan> bo0ts__: and, are you compiling with -O2?
07:03:42 <temoto> And another thing, i was thinking, maybe it would be better not to try parse the whole expression, but instead produce a list of atomic expressions and operators.
07:03:53 * RayNbow wonders if anyone has made an IOLINQ (IO monad) library for C#...
07:04:02 <quicksilver> you'd need to say something like "parseInfix = liftM3 Infix expr op (parseInfix')"
07:04:12 <quicksilver> where parseInfix' was the current chainl1 version.
07:04:12 <bo0ts__> Saizan: Well, I have a lot of memory so I can't really tell just by the percent. No, no -O2 i'll try.
07:04:34 <bo0ts__> Saizan: I had the feeling it could have something todo with lazyness and allocation for the list.
07:04:47 <temoto> So "foo x" would yield [Name "foo", Name "x"] and then i would analyze that in evaluator.
07:04:57 <temoto> quicksilver: what do you think on this approach?
07:05:09 <quicksilver> it can work, yes.
07:05:25 <quicksilver> Any hard parsing problem can be made easier by adding another phase
07:05:29 <Saizan> bo0ts__: since intString, and intString' are both toplevel bindings, i'm not sure if GHC realizes they can be garbage collected as soon as they get printed
07:05:29 <quicksilver> (which is what you are saying, there)
07:05:39 <temoto> Yeah, another phase.
07:05:57 <temoto> I admire how they made 1 pass parser in Go.
07:06:12 <bo0ts__> Saizan: I didn't test it with the source I provided. That was just for illustration. I could test it again with the original source.
07:06:13 <Saizan> bo0ts__: so, the slowness might just be because the heaps already got large by fully evaluating the first one, when you get to the second
07:06:36 <quicksilver> temoto: I tend to err on the side of multiple phases, I just think it makes clearer code.
07:06:50 <quicksilver> temoto: but then I've never had to be concerned about performance
07:06:54 <bo0ts__> Saizan: This shouldn't be the issue. In the original only one version was used respectively.
07:07:05 <quicksilver> temoto: (I've never used a parser in a situation where it was slow enough to care)
07:07:46 <temoto> Yeah, code readability is almost everything.
07:08:11 <Saizan> bo0ts__: and the concat
07:08:15 <ziman> Saizan, how would garbage collectino affect the speed?
07:08:22 <Saizan> bo0ts__: and the concat + map one was slower from the start?
07:08:42 <bo0ts__> Saizan: Yes, considerably.
07:09:10 <Saizan> ziman: a large heap is slower to collect in general, afaiu
07:09:34 <temoto> It's funny that i actually wanted to make a language with integrated NFA parsers. And now when i try Parsec, i realize how much features i will loose implementing much less powerfull parsers.
07:09:52 <temoto> than Parsec
07:10:00 <ziman> hmm
07:10:18 <bo0ts__> ziman: I cannot speak for Haskell but other gcs have a compacting phase. If the heap is very fragmented this will take very long.
07:10:23 <Saizan> bo0ts__: that's pretty weird, it's pretty fast even in ghci here
07:10:31 <temoto> But integrating full power parsers require non-trivial stuff. Evil circle.
07:10:45 <ziman> bo0ts__, which haskell implementation did you test it on?
07:10:49 <Saizan> bo0ts__: maybe you should paste the real code? unless you get the same problem with the one pasted.
07:11:05 <bo0ts__> ziman: The Glorious Glasgow Haskell Compilation System, version 6.12.1
07:11:34 <bo0ts__> Saizan: On my way. I'll do some clean up + testing to confirm before.
07:16:23 <bo0ts__> Saizan: How do I force evaluation of an expression without printing it?
07:17:03 <ziman> :t (seq, deepSeq)
07:17:04 <lambdabot> Not in scope: `deepSeq'
07:17:21 <temoto> @hoogle deepSeq
07:17:21 <lambdabot> No results found
07:17:34 <temoto> Where did you got it from?
07:18:57 <ziman> hm, it's in Control.Strategies.DeepSeq. you might probably as well use rnf from Control.Parallel.Strategies...
07:20:05 <temoto> quicksilver: your liftM3 wrapper works excellent, though i don't understand how it works.
07:21:27 <quicksilver> temoto: magic?
07:21:50 <quicksilver> temoto: what don't you understand? It's not that different from the liftM2 you use on Apply
07:21:57 <quicksilver> except Infix has 3 arguments, not 2
07:21:59 <Saizan> bo0ts__: either \xs -> return $! rnf xs  which for lists reduces to \xs -> return $! foldr seq () xs
07:22:16 <Saizan> s/either//
07:23:01 <temoto> quicksilver: yeah but now liftM3 consumes Infix from parseInfix'.
07:23:12 <temoto> So far i've only written functions that consume chars.
07:23:37 <quicksilver> no, it doesn't
07:23:42 <quicksilver> everythign is consuming chars
07:23:49 <quicksilver> it's just calling parseInfix' as a sub-parser
07:23:58 <quicksilver> in the same way it's calling 'op' and 'expr' as sub-parsers
07:24:20 <temoto> Ah, now i got it, thanks. :)
07:25:22 <Berengal> rnf is a bit suspect, as it has to travel entire structures even if they're already evaluated
07:25:34 <temoto> Then i got to another breakpoint. parse expr _ "foo x y" produces Apply (Name "foo") (Name "x") and that's all.
07:25:46 <Berengal> Should only be used on something after you've built something you know is just a big thunk
07:26:01 <bo0ts__> Saizan: Ok, I don't get that xD Well, somehow is fishy. I couldn't reproduce what happened the last time. Let me think about it for a while. Thanks for the help.
07:26:13 <temoto> Which means either i should fix it to some kind of chainl or really implement that 2-phase approach.
07:26:47 <quicksilver> temoto: I think you can just use 'many'
07:28:10 <quicksilver> liftM (foldl1 Apply) (many expr)
07:28:12 <quicksilver> perhaps
07:30:17 <temoto> I suppose, that's what chainl really does :)
07:30:57 <quicksilver> no, not quite
07:31:12 <quicksilver> chainl allows you to actually make the binary function depend on the parsing
07:31:16 <quicksilver> which you don't need in this simple case
07:32:25 <Saizan> chainl is also supposed to solve the problem with left recursion
07:34:30 <temoto> hm.. binary function depend on parsing?
07:34:57 <temoto> How is that different from foldl1 Apply?
07:35:16 <temoto> Apply is a data constructor but it's a binary function.
07:35:28 <quicksilver> foldl1 Apply has the type [Expr] -> Expr
07:36:04 <quicksilver> well, more importantly, Apply has type Expr -> Expr -> Expr
07:36:30 <quicksilver> whereas chainl lets you use "Parser (Expr -> Expr -> Expr)"
07:37:33 <mmaruseacph2> what do you recommend for writing an user interface in haskell?
07:37:42 <quicksilver> so the actual binary function used to combine the bits can itself depend on the token stream
07:37:43 <mmaruseacph2> gtk2hs or hswidgets?
07:38:18 <mmaruseacph2> *wxHaskell in fact (sorry for the confusion)
07:42:00 <temoto> quicksilver: i got it, thanks.
07:42:33 <temoto> chainl allows to build complex stuff like parseInfix' which parses another infixAny from token stream.
07:42:40 <temoto> parses=eats
07:42:42 <sproingie> mmaruseacph2: i think gtk2hs is better-maintained
07:43:07 <mmaruseacph2> then, the answer is clear, thanks sproingie
07:43:11 <sproingie> painful to build on windows tho.  but same goes for wxhaskell
07:43:42 <mmaruseacph2> it'll pass a long time until i'll write somethign for windows :)
07:43:53 <mmaruseacph2> no microsoft bashing intended
07:44:11 <sproingie> if cross platform isn't your goal, no prob
07:45:09 <mmaruseacph2> it is one goal, but not `elem` the important list
07:48:11 <temoto> I'm trying to convert   do { op <- foo; return $ \l r -> Infix l op r } to liftM and don't get it
07:48:34 <temoto> liftM2 (\l r -> Infix l foo r) doesn't compile
07:48:48 <benmachine> @undo do { op <- foo; return $ \l r ->  Infix l op r }
07:48:48 <lambdabot> foo >>= \ op -> return $ \ l r -> Infix l op r
07:48:57 <benmachine> that's a good place to start
07:49:03 <temoto> i saw that
07:49:12 <temoto> it even translates to a shorter fmap
07:49:24 <temoto> @pl foo >>= \ op -> return $ \ l r -> Infix l op r
07:49:24 <lambdabot> flip Infix `fmap` foo
07:49:41 <benmachine> so what's wrong with that?
07:49:44 <temoto> hm wait, that's what i need
07:49:49 <benmachine> :)
07:50:07 <benmachine> (noticing also that fmap = liftM)
07:50:21 <temoto> Previous @pl yielded fmap with l and r which i get into lambda.
07:50:22 <benmachine> (but with a different (more useful) class constraint)
07:50:32 <benmachine> oh
07:50:35 <benmachine> k
07:50:35 <temoto> That was a slightly different expression.
07:50:46 <benmachine> for bonus points:
07:50:55 <benmachine> @. pl undo do { op <- foo; return $ \l r ->  Infix l op r }
07:50:55 <lambdabot> flip Infix `fmap` foo
07:50:57 <temoto> Yeah i know what fmap is liftM.
07:51:26 <benmachine> lambdabot supports composition of things
07:51:30 <temoto> Someone introduced me into the world of Functor => Applicative => Pointed => Monad hierarchy.
07:51:42 <benmachine> er, Pointed => Applicative surely
07:51:45 <temoto> maybe i confused something
07:52:06 <temoto> but the main point is that Functor is definately more general than Monad.
07:52:11 <benmachine> yes
07:52:24 <benmachine> fmap f = (>>= return . f)
07:52:44 <kamatsu> @src fmap
07:52:44 <lambdabot> Source not found. Are you on drugs?
07:52:47 <kamatsu> aw
07:52:51 <temoto> @pl >>= return . f
07:52:51 <lambdabot> (line 1, column 1):
07:52:51 <lambdabot> unexpected ">"
07:52:51 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
07:52:56 <temoto> @pl (>>= return . f)
07:52:56 <lambdabot> (f `fmap`)
07:53:16 <benmachine> kamatsu: defined per-type
07:53:39 <benmachine> for lists, fmap = map, for maybes, fmap f = maybe Nothing (Just . f)
07:53:49 <temoto> @src fmap::Text.ParserCombinators.Parsec.Parser
07:53:49 <lambdabot> Source not found. Are you on drugs?
07:54:08 <benmachine> src doesn't have that much source
07:54:35 <benmachine> @src [] fmap
07:54:35 <lambdabot> fmap = map
07:56:11 <dv-> I'm trying to install containers-0.2.0.1 on ghc 6.12.1, but when I run cabal install, it tells me I need to add base to build-depends. But it's already there... how do I make cabal see it?
07:56:19 <temoto> fmap (*2) [1,2,4]
07:56:21 <temoto> > fmap (*2) [1,2,4]
07:56:22 <lambdabot>   [2,4,8]
07:56:29 <temoto> I wonder why we need map then.
07:56:42 <benmachine> > fmap fmap fmap (*2) Just [1,2,3]
07:56:43 <lambdabot>   No instance for (GHC.Num.Num [t])
07:56:43 <lambdabot>    arising from the literal `2' at <inter...
07:56:44 <mux> map used to be fmap in Haskell 1.4
07:56:48 <benmachine> > fmap fmap fmap (*2) (Just [1,2,3])
07:56:49 <lambdabot>   Just [2,4,6]
07:57:01 <mux> I think they went back to map being the fmap specialisation for lists to keep an understandable type signature for newcomers
07:57:13 <benmachine> silly them
07:57:22 <temoto> :t fmap (*2) [1,2,4]
07:57:23 <lambdabot> forall a. (Num a) => [a]
07:57:29 <temoto> :t fmap (*2)
07:57:30 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
07:57:45 <sproingie> could do what cale does for \bot and make . == fmap
07:57:54 <sproingie> > succ . [1..5]
07:57:55 <lambdabot>   [2,3,4,5,6]
07:58:25 <temoto> hm
07:59:12 <temoto> > head `fmap` fmap (*2) [1,2,3]
07:59:13 <lambdabot>   No instance for (GHC.Num.Num [a])
07:59:13 <lambdabot>    arising from the literal `2' at <inter...
07:59:23 <temoto> > head `fmap` (fmap (*2) [1,2,3])
07:59:24 <lambdabot>   No instance for (GHC.Num.Num [a])
07:59:24 <lambdabot>    arising from the literal `2' at <inter...
07:59:35 <temoto> > head . (fmap (*2) [1,2,3])
07:59:36 <lambdabot>   No instance for (GHC.Num.Num [a])
07:59:36 <lambdabot>    arising from the literal `2' at <inter...
07:59:41 <temoto> > head . fmap (*2) [1,2,3]
07:59:42 <lambdabot>   No instance for (GHC.Num.Num [a])
07:59:42 <lambdabot>    arising from the literal `2' at <inter...
07:59:47 <temoto> > head . fmap ((*2) [1,2,3])
07:59:48 <lambdabot>   Couldn't match expected type `a1 -> a' against inferred type `[a2]'
08:00:02 <temoto> wwow i made a2 in type infering
08:00:27 <sproingie> achievement unlocked!
08:00:43 <sproingie> haskell should come with achievements
08:00:50 <Berengal> It should
08:00:56 <Berengal> I think someone's proposed that before
08:00:59 <temoto> Yeah like a10 brings you to level 2.
08:01:39 <temoto> > head . map ((*2) [1,2,3])
08:01:40 <lambdabot>   Couldn't match expected type `a1 -> a' against inferred type `[a2]'
08:01:59 <temoto> > (head . map) (*2) [1,2,3]
08:02:00 <lambdabot>   Couldn't match expected type `[t -> t1]'
08:02:00 <lambdabot>         against inferred type `[a]...
08:02:12 <temoto> i expected it to work actually
08:03:03 <Polarina> Is it possible somehow to dynamically link a library?
08:03:14 <temoto> Hello there.
08:03:21 <Polarina> temoto, hi.
08:03:43 <temoto> Polarina: how's your learning?
08:03:52 <Polarina> temoto, going well. :)
08:04:24 <temoto> Excellent. :)
08:04:39 <Saizan> Polarina: ghc 6.12 should has support for dynamic linking, don't know the details of how you use it though :)
08:04:40 <sproingie> > (head . (map (*2)) [1,2,3]
08:04:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:05:07 <sproingie> > (head . (map (*2))) [1,2,3]
08:05:08 <lambdabot>   2
08:06:03 <Polarina> temoto, how are you doing yourself?
08:09:14 <temoto> Polarina: Well, i got flu and trying to write a parser for toy language while not at job.
08:09:14 <paolino> dons, is possible to compile and user install gtk2hs with ghc 6.12 ?
08:09:35 <Polarina> temoto, sorry to hear that, I hope you'll cure soon.
08:10:03 <temoto> Polarina: instead, i hope i'll have more time at home to write interpreter. :)
08:10:17 <Polarina> temoto, pros and cons. :D
08:12:21 <dino-> paolino: I don't have direct experience, but I see something on the Gtk2Hs page about 6.12 and a patch from dcoutts http://www.haskell.org/gtk2hs/
08:12:48 <int-e> paolino: there is a patch on the gtk2hs mailing list that will allow gtk2hs compile without split objs, and without docs.
08:13:23 <int-e> paolino: (I've actually tried that on linux. it wasn't a user install though, hmm)
08:14:00 <int-e> but in theory at least, configure --with-user-pkgconf  should do the trick.
08:14:12 <paolino> int-e: patch link ?
08:15:01 <paolino> found
08:27:00 <jaspervdj> so.. the idea behind ByteString is basically an array of Strings, or am I wrong?
08:28:21 <pozic> jaspervdj: wrong.
08:28:26 <Saizan> strict bytestrings are unboxed arrays of Word8, lazy ones are lists of strict ones
08:28:38 <Saizan> but lists strict in their contents
08:29:27 <jaspervdj> what I was wondering, has anyone ever tried to use a tree structure for this?
08:30:07 <jaspervdj> or is there an obvious reason that would not work well
08:30:08 <voker57> why?
08:30:14 <Saizan> there's been some thought about using suffix trees or fingertrees
08:30:38 <jaspervdj> voker57: mainly fast insertion I suppose
08:30:41 <Saizan> but no implementation/benchmark
08:31:48 <Saizan> jaspervdj: so it'd be cool to see how that turns out :)
08:32:11 <jaspervdj> I'll have a go at it
08:32:12 <benmachine> jaspervdj: when would you want insertion?
08:32:21 <benmachine> hmm I suppose you could
08:32:40 <Saizan> concatenation should be faster too
08:32:48 <jaspervdj> benmachine: I'm currently not really thinking about real world applications, I'm just curious ;-)
08:33:04 <benmachine> curiousity is the mother of invention
08:33:06 <benmachine> possibly
08:36:47 <int-e> does anybody have Antoine Latter's cps parsec branch? (community.h.o. is down - that's where it resides)
08:40:49 <Berengal> Haha, http://www.cs.utexas.edu/users/arvindn/misc/knuth_song_complexity.pdf
08:43:10 <Eduard_Munteanu> Hi.
08:43:43 <Eduard_Munteanu> Is there any function which computes the cartesian product of two lists?
08:43:59 <Berengal> Eduard_Munteanu: liftM2 (*)
08:44:10 <Eduard_Munteanu> Berengal, thanks.
08:44:18 <Eduard_Munteanu> Awesome.
08:44:47 <Berengal> The day is saved once again thanks to the list monad :)
08:44:56 <Eduard_Munteanu> Heh, yeah.
08:45:14 <temoto> @undo do {return a}
08:45:14 <lambdabot> return a
08:45:20 <Twey> > liftM2 (*) [1, 2, 3] [4, 5, 6]
08:45:21 <lambdabot>   [4,5,6,8,10,12,12,15,18]
08:45:28 <kmc> > liftM (,) [1,2,3] [4,5,6]
08:45:29 <lambdabot>   Couldn't match expected type `[t1] -> t'
08:45:29 <lambdabot>         against inferred type `[b ...
08:45:33 <Eduard_Munteanu> Um, not good.
08:45:34 <kmc> > liftM2 (,) [1,2,3] [4,5,6]
08:45:35 <Twey> liftM2 
08:45:35 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:45:44 <Twey> Eduard_Munteanu: Hm?
08:45:46 <Eduard_Munteanu> kmc, thanks. That's what I want
08:45:54 <Twey> Ah
08:45:55 <Twey> Yeah
08:46:10 <Berengal> Oh, yeah, I meant (*) to be an arbitrary operator...
08:46:12 <ski> > sequence [[1,2,3],[4,5,6]]
08:46:13 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
08:51:39 <quicksilver> > liftM2 f [1,2,3] [4,5,6]
08:51:40 <lambdabot>   Ambiguous type variable `r' in the constraints:
08:51:40 <lambdabot>    `SimpleReflect.FromExpr ...
08:51:45 <quicksilver> hmm
08:51:55 <quicksilver> no, that doesn't work, annoying
08:52:03 <mauke> > liftM2 f [1,2,3] [4,5,6] :: [Expr]
08:52:04 <lambdabot>   [f 1 4,f 1 5,f 1 6,f 2 4,f 2 5,f 2 6,f 3 4,f 3 5,f 3 6]
08:52:07 <quicksilver> ah, thanks.
08:52:09 <quicksilver> mauke++
08:52:44 <int-e> > replicateM 3 [0,1] -- related
08:52:45 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
08:53:39 <Eduard_Munteanu> :t liftM2 @f [1,2,3] [4,5,6]
08:53:40 <lambdabot> Pattern syntax in expression context: liftM2@f
08:53:58 <Eduard_Munteanu> :t liftM2 ?f [1,2,3] [4,5,6]
08:53:59 <lambdabot> forall a1 a2 r. (?f::a1 -> a2 -> r, Num a1, Num a2) => [r]
08:54:27 <ski> is there a nice way to get the alternative iterative-deepening breadth-first enumeration to work on finite trees ?
08:54:58 <voidprayer> i notice that (->) is not a sign like (+) or (-). but it still get 2 parameters. what is its association?
08:55:09 <voidprayer> left/right?
08:55:11 <benmachine> right
08:55:12 <Berengal> voidprayer: right
08:55:26 <benmachine> a -> b -> c is the same as a -> (b -> c) and different from (a -> b) -> c
08:55:35 <voidprayer> benmachine & Berengal: thanks.
08:57:51 <ski> @fixity ->
08:57:51 <lambdabot> Unknown command, try @list
08:57:57 <ski> hmpf !
08:58:13 <benmachine> -> is a bit magic isn't it
08:58:37 <Twey> It's a type operator, so yes :
08:59:46 <theorbtwo> That is, perhaps, the great lament of haskell -- types and values are completely seperate things.
09:00:00 <Twey> Maybe
09:01:17 <Cale> Well, they could interact a little more than they do.
09:01:17 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
09:02:02 <quicksilver> actually -> is magic in that, for other type operators you'd be allowed to have a value operator with the same name, but -> is actually syntax so it's not permitted.
09:02:09 <quicksilver> (it's used in case and lambda after all)
09:02:25 <Twey> Can you consider that the same ->?
09:02:31 <Twey> I think they're different.
09:02:34 <quicksilver> then again the notion of "other type operators" is a GHC extension
09:02:39 <Twey> Yeah
09:02:39 <quicksilver> Twey: definitely different.
09:02:41 <Twey> That's the magic bit
09:02:48 <quicksilver> Twey: except from an ASCII perspective ;)
09:02:54 <Twey> Heh
09:02:55 <mux> :k (->)
09:02:56 <lambdabot> ?? -> ? -> *
09:03:05 <quicksilver> mux: another different -> in the reply there!
09:03:12 <quicksilver> that one's a KindOperator
09:03:18 <Twey> Well, much more related.
09:03:20 <mux> wait, what?
09:03:44 <Twey> So how do we describe the type of (->) the kind operator?  :
09:03:51 * mux was hoping to generate discussion on the meaning of ? and ?? vs *
09:04:18 <Berengal> They're kinds
09:04:26 <mux> no shit :-)
09:04:31 <quicksilver> Twey: it has the sort ** -> ** -> **
09:04:59 <Twey> Nice
09:05:26 <Berengal> There's, *, # and (#), and ?? is the union of * and (#), and ? is the union of ?? and #... I think
09:05:38 <Berengal> Maybe it was the other way around for ? and ??
09:06:08 <Twey> I guess the uppermost echelon must be something consisting of only one term
09:06:44 <quicksilver> Twey: you kind of can't help (->) going all the way up
09:06:53 <Berengal> The sort ** -> ** -> ** has sort_2 *** -> *** -> ***
09:06:54 <benmachine> does there have to be an uppermost echelon? :P
09:06:59 <quicksilver> Twey: because each (->) requires the (->) in the level above to explain it.
09:07:09 <quicksilver> Twey: you either decide it's turtles all the way down
09:07:22 <quicksilver> or you decide, at some point, that that -> is 'meta' and not classifiable.
09:07:59 <Twey> Can't you have a layer such that * -> * in the level below is *?
09:08:07 <Berengal> What would * be?
09:08:17 <Twey> Anything
09:08:25 <Twey> Anything except functions in the former case
09:08:29 <Cale> Only if you want to admit type errors at that level...
09:08:30 <Berengal> So (->) and * would have the same sort?
09:08:48 <Twey> For some version of sort another level or possibly two up the stack, yes
09:08:52 <Twey> Cale: Hmm
09:09:54 <Berengal> Twey: It would allow things such as (->) -> *
09:10:44 <kmc> Omega has an infinite number of sorts
09:10:47 <kmc> (hence the name)
09:12:08 <kmc> as do Agda and Gallina, but they're dependently typed so they aren't stratified the same way
09:12:39 <MissPiggy> well in Coq you have Type[0] Type[1] etc
09:12:49 <MissPiggy> but the indices get inferred, so you don't have to deal with it
09:12:56 <Cale> Cayenne, iirc, unifies types and values.
09:13:54 <burp> > fmap (\(a,b,c) -> cos $ a+b+c ) [ (a,b,c) | a <- [-1,1], b <- [-2,2], c <- [-3,3]]
09:13:55 <lambdabot>   [0.960170286650366,1.0,-0.4161468365471424,-0.6536436208636119,-0.653643620...
09:14:01 <burp> > sum $ fmap (\(a,b,c) -> cos $ a+b+c ) [ (a,b,c) | a <- [-1,1], b <- [-2,2], c <- [-3,3]]
09:14:02 <lambdabot>   1.7807596584792234
09:14:08 <burp> > 8 * (cos 1)*(cos 2)*(cos 3)
09:14:09 <lambdabot>   1.7807596584792236
09:15:00 <thoughtpolice> Cale: yeah, I believe cayenne just bails out on type checking if it takes too long since types and values are unified
09:15:07 <thoughtpolice> (i.e. if
09:15:10 <temoto> What is common practice for tests in haskell?
09:15:23 <thoughtpolice> * (i.e. if (typechecking_time > 5min) then "sorry!")
09:16:01 <burp> > sum $ fmap (\(a,b,c,d) -> cos $ a+b+c+d ) [ (a,b,c,d) | a <- [-1,1], b <- [-2,2], c <- [-3,3], d <- [-4,4]]
09:16:02 <lambdabot>   -2.3279643821124174
09:16:19 <kmc> temoto, QuickCheck is popular
09:16:23 <burp> > 16 * (cos 1)*(cos 2)*(cos 3)*(cos 4)
09:16:24 <lambdabot>   -2.3279643821124174
09:16:26 <burp> fascinating :>
09:16:29 <sproingie> QuickCheck and HUnit
09:16:31 <Cale> temoto: QuickCheck, which is a generalisation of unit tests
09:16:37 <kmc> @check \xs -> xs == reverse (reverse xs)
09:16:38 <lambdabot>   "OK, passed 500 tests."
09:16:44 <kmc> @check \xs -> (xs :: [Char]) == reverse (reverse xs)
09:16:45 <lambdabot>   "OK, passed 500 tests."
09:16:48 <kmc> @check \xs -> (xs :: [Char]) == reverse xs
09:16:49 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\485730\\1035699\\1000605\"\n"
09:16:52 <temoto> kmc: hello. Are sources of your parsec work available now?
09:17:04 <Cale> Unit tests are the special case of QuickCheck where you don't use any function parameters.
09:17:04 <quicksilver> Cale: although quick check doesn't have any of the machinery one expects from a unit test framework
09:17:08 <temoto> oh boy another generalisation :)
09:17:16 <sproingie> HUnit for the things that aren't easily expressed as properties
09:17:27 <quicksilver> Cale: and unit test frameworks normally have ways of testing things of type IO (), also.
09:17:56 <sshc> how do I get a list of things that occur more than once in a list?
09:18:04 <sshc> I'm looking for the inverse of "nub"
09:18:07 <Cale> I think QuickCheck can test IO things now.
09:18:08 <sproingie> bun
09:18:12 <kmc> temoto, what did you want to see exactly?
09:18:35 <sproingie> sshc: what would it do, produce duplicates for values matching a criteria?
09:18:51 <kmc> > map head . filter ((>1) . length) . group . sort $ "hello world"
09:18:52 <lambdabot>   "lo"
09:18:57 <kmc> sshc, ^^^
09:19:07 <Cale> > concat . take 1 . drop 1 . group . sort $ "mississippi"
09:19:08 <lambdabot>   "m"
09:19:11 <Cale> er
09:19:18 <sproingie> ohhh show only the dups.  what a silly bunt
09:19:19 <Cale> > concat . map (take 1 . drop 1) . group . sort $ "mississippi"
09:19:20 <lambdabot>   "ips"
09:19:33 <sshc> kmc: thanks
09:19:45 <temoto> Let's put it this way: i'm writing a parser for toy language. Which is by definition a pure thing, i'm not doing any IO. So far i played a lot with things like order of parsers and this starting to grow bigger than i remember, so i want to test whether some change breaks parsing of other expressions or not.
09:19:55 <temoto> Does it fit QuickCheck or HUnit more?
09:20:05 <quicksilver> > take 1 . drop 1 =<< group . sort $ "mississippi"
09:20:05 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
09:20:07 <kmc> probably QC
09:20:17 <temoto> kmc: yesterday you mentioned you made a parser for something like haskell.
09:20:19 <sproingie> never thought of take 1 . drop 1, i always think of 'take' as being unsafe with empty lists
09:20:36 <Cale> temoto: A lovely way to test a parser is to write a pretty printer as well, and use QuickCheck to generate ASTs, and verify that pretty printing them and parsing them again results in the same thing
09:20:40 <kmc> temoto, yeah
09:21:15 <Cale> quickCheck (\x -> parse (pprint x) == x)
09:21:21 <kmc> it's not convenient to get right now though
09:21:26 <merehap> Cale: wow, I like that idea a lot
09:21:32 <kmc> you might be better off looking at stuff on hackage
09:21:44 <temoto> Alright.
09:22:10 <kmc> which has parsers for Haskell, Python, C, shell, XML, ...
09:22:13 <Saizan> Cale: or your pretty printer is as broken as your parser :)
09:22:13 <temoto> Cale: i thought that pretty printer for AST should not generate the source :)
09:22:18 <quicksilver> Cale: it's an adjunction!
09:22:19 <sproingie> using quickcheck to generate AST's sounds like a wonderful way to generate obfuscated code :)
09:22:34 <quicksilver> Cale: for which the associated monad collapses whitespace + comments, or something.
09:23:15 <saml> f ["x", "y", "a", "b", "c", "d"]   [("a", 2), ("x", 0)] , ==> (["x", "a", "b", "c"], ["y", "d"])    how would you implement f?
09:23:30 <temoto> I thought pretty printer should generate stuff like derived Show does but with proper indentation so i can see the tree in a nice way.
09:23:31 * sproingie quickcheck myLanguage.hs --> "Web browser created after 285,731 tests"
09:23:42 <quicksilver> temoto: different kind of pretty.
09:23:52 <quicksilver> temoto: both are reasonable uses of the term.
09:23:53 <saml> f takes a [String]  and [(String, Int)]    where the second list specifies valid element from first list and how many elements should be skipped afterwords
09:23:54 <kmc> sproingie, haha
09:24:04 <kmc> @remember sproingie quickcheck myLanguage.hs --> "Web browser created after 285,731 tests"
09:24:04 <lambdabot> Done.
09:24:11 <quicksilver> temoto: one is more of a pretty printer for the ADT the other is more of a pretty printer for the *language*
09:24:23 <quicksilver> (but they are both using the ADT as their source type)
09:24:42 <temoto> Okay.
09:24:43 <Cale> quicksilver: well, yeah, the property I'm testing is actually a little too strong
09:26:05 <Saizan> parse (pretty x) == x is usually what you want, pretty (parse str) == str is more questionable
09:26:13 <Cale> really you want that  pprint . parse . pprint = pprint  and that  parse . pprint . parse = parse, though the latter is hard to test directly, because you generating strings randomly which happen to parse is difficult without actually getting them from the pretty printer in the first place.
09:26:44 <quicksilver> which looks a lot like an adjunction
09:26:47 <Cale> yeah
09:26:55 <quicksilver> although it's a bit hard to work out what the categories are
09:26:58 <quicksilver> but the diagram is the right shape
09:27:01 <quicksilver> and that's all that matters :)
09:27:05 <Cale> it's the unit and counit laws for an adjunction
09:28:00 <Cale> "zig zag laws" :)
09:28:34 <MissPiggy> yes it's pretty hard to specify parsing
09:28:48 <MissPiggy> even if you take whitespace out the equation
09:30:20 <temoto> (i'm using apt-get to install haskell libraries, so it has -dev with actual library and -doc with documentation) how to use that documentation?
09:30:40 <quicksilver> that's why I like parser combinators which make your code look like the BNF grammar
09:30:52 <Saizan> temoto: a web browser
09:30:55 <quicksilver> as long as your combinators are correct then the specification *is* the program.
09:31:21 <quicksilver> actually one of the things I don't like about parsec is the 'high-level' combinators like chainl1 which make the program look less like the grammar.
09:31:44 <quicksilver> you should be able to write the grammar as-is (including left recursion) and have the combinators automatically left-factor.
09:31:52 <temoto> That's actually great for static program, but not for evolving.
09:31:54 <MissPiggy> automatically left-factor -- that sounds like fun :P
09:32:11 <quicksilver> MissPiggy: I wrote a parser "combinator" library for lua which automaticaly did its own left-factoring
09:32:21 <quicksilver> it was incomplete, but it worked well enough to parse lua
09:32:22 <MissPiggy> It makes sense in like ocaml yacc but for something like parsec you need to check pointer equality don't you?
09:32:23 <mux> we should multifix operators and be able to write a BNF grammar as-is and have haskell generate a parser :-)
09:32:38 <quicksilver> MissPiggy: yeah, it can't be like parsec
09:32:45 <quicksilver> it has to be more introspectable
09:32:51 <MissPiggy> mux (you can do that in prolog)
09:32:57 <quicksilver> in fact, my version coudl introspect first-tokens
09:33:10 <quicksilver> so it could build its own first-token tables for speed, like S-D parsers do I believe.
09:33:20 <MissPiggy> cool
09:36:37 <Saizan> well, you just need a let_ in your DSL, oleg-style
09:37:41 <lispy> A let of Olegian proportions!
09:38:13 <quicksilver> I heard you like binding so I put a language in your language so you can let_ while you let?
09:38:51 <Saizan> ahhuauha, yeah
09:39:52 <Saizan> @remember quicksilver I heard you like binding so I put a language in your language so you can let_ while you let?
09:39:52 <lambdabot> I will never forget.
09:40:04 <MissPiggy> what are Grbner basis actually for?
09:40:26 <MissPiggy> it seems like they can be used in more cases than just the obvious meaning
09:42:42 <Cale> MissPiggy: Well, computing various operations on ideals in polynomial rings, which takes on a different sort of quality when you have a little bit of algebraic geometry mixed in.
09:47:13 <dang`r`us> trying to use HXT to extract text nodes from an xml, failing: http://pastie.org/790057   (I'm on a train ride, so when you're helping me it might take a while for me to react, connection drops)
09:47:19 <Cale> One of the few things I view as mistakes in the order in which things were taught during my undergraduate degree was that Grbner bases were introduced in the course on Rings, which makes a certain amount of sense, but at the time they just seemed kind of arbitrary and unmotivated. I think if there had been even just a little bit more geometry mixed into that course, it would have been easier to motivate.
09:48:02 <Cale> (After taking a later course on algebraic curves, I'd wished that I could better remember how Grbner bases worked.)
09:48:04 <quicksilver> Cale: I think the notion of mixing geometry and algebra is, in itself, a subtle and advanced one.
09:48:18 <MissPiggy> algebraic geometry is scary
09:48:19 <quicksilver> Cale: probably many students wouldn't 'get' that in an initial course on algebra like rings.
09:48:30 <MissPiggy> that's what grothendeick does
09:48:35 <Cale> Well, it's not *that* scary.
09:48:39 <MissPiggy> and fermats last theorem
09:48:42 <MissPiggy> yes it is :P
09:48:48 <quicksilver> scariness is in the frontal lobe of the beholder
09:48:51 <Cale> All topics in mathematics end up being scary if you follow them far enough along.
09:49:03 <MissPiggy> I'm not squeamish when it comes to mathematics but this stuff is like the dark creatures from discworld
09:49:41 <MissPiggy> the starting point is lie groups?
09:49:49 <Cale> But the basics of affine algebraic varieties and the connections between ideals of polynomial rings R[x_1,...,x_n] and curves in R^n is very motivating.
09:50:44 <Cale> Let's stick to 2 dimensions.
09:51:27 <Eduard_Munteanu> Cale, btw, any use of ideals in functional programming? I see some stuff on coideals (IIRC) on category-extras.
09:51:28 <Cale> If you have some set S of polynomials in R[x,y] (R being the reals here), then you can form a subset of R^2 which is the set of roots which those polynomials have in common.
09:51:31 <EvanCarroll> aww, is cale striving to scare off people without 20 years of mathmatic foundation again?
09:52:07 <Cale> That is, define V(S) = {(x,y) in R^2: f(x,y) = 0 for all f in S}
09:52:09 <MissPiggy> Cale, well I recognize what you are saying here about the roots
09:52:24 <Cale> That's the variety corresponding to that set of polynomials.
09:52:58 <Cale> Dually, if we have some set of points in R^2, we can ask what is the set of polynomials, each of which has all those points as roots?
09:53:50 <Cale> And we define the ideal corresponding to that set of points: I(S) = {f in R[x,y]: f(x,y) = 0 for all (x,y) in S}
09:54:03 <Cale> It's easy enough to show that this really is an ideal of R[x,y]
09:54:36 <xerox> yeah, closed under sum, and the product by an arbitrary polynomial still has those points as zeros
09:54:38 <Cale> (adding any two such polynomials will result in another, and multiplying by arbitrary polynomials in R[x,y] will only create additional roots)
09:55:14 <MissPiggy> okay
09:55:41 <Saizan> dang`r`us: writeDocumentToString probably expects a tree that starts with a "root" node
09:55:55 <Cale> There are remarkable connections between the geometry of curves in R^2, and the algebraic properties of ideals in R[x,y]
09:56:12 <Cale> To begin, maximal ideals correspond to single points
09:56:30 <MissPiggy> Cale, and in general between R^n and R[x_1, ..., x_n] I presume?
09:56:44 <Saizan> dang`r`us: if you just use runX ( rs >>> deep isText) the Show instance shows you that the search worked
09:56:52 <Cale> MissPiggy: yes
09:57:17 <Cale> and actually, things are even better when you generalise to complex numbers
09:57:33 <MissPiggy> because they're algebraically closed?
09:57:38 <Cale> yeah
09:57:39 <dang`r`us> Saizan, aah! I had suspected this, but wasn't sure enough. thx!
09:58:04 * maltem likes to embed R^n into the projective space over R^(n+1) (and have the feeling to pursue a smart idea)
09:58:18 <Cale> and then you can generalise even further, and start using the intuition from these cases to construct geometries which would be attached to arbitrary rings, not just these polynomial rings
09:58:43 <Cale> Yeah, and there's projective generalisations of this as well.
09:59:00 <Cale> Probably the nicest place to do algebraic geometry is complex projective space.
09:59:18 <temoto> BTW, what is rings?
09:59:43 <temoto> Cale was talking about something like R(foo) yesterday.
09:59:46 <Cale> temoto: Rings are a specific formalisation of what we might mean by the word "number"
10:00:27 <Cale> temoto: They're sets, together with operations of addition and multiplication which satisfy properties that we'd usually expect of addition and multiplication
10:01:00 <c_wraith> rings don't guarantee a multiplicative inverse, though.
10:01:06 <Cale> (the list of properties is just long enough that it might be easier to look them up on wikipedia)
10:01:22 <Cale> Rings also don't guarantee that multiplication is commutative.
10:01:40 <temoto> abstract sets?
10:01:40 <c_wraith> ah, right.  just that it's associative
10:01:42 <Eduard_Munteanu> Umm, isn't it a group + monoid in short?
10:01:49 <Eduard_Munteanu> along with a distributive law.
10:01:52 <c_wraith> abelian group, specifically.  but yes
10:01:53 <Cale> Eduard_Munteanu: yes
10:02:06 <temoto> parametrized sets?
10:02:16 <Cale> temoto: just any sets
10:02:16 <xerox> (two distributive laws)
10:02:17 <temoto> Or set of something in particular?
10:02:29 <Eduard_Munteanu> temoto, a set and an operation.
10:02:36 <Eduard_Munteanu> temoto, that forms a group/monoid
10:02:36 <Cale> temoto: It doesn't matter what the elements "are", just how the operations work on them.
10:02:38 <xerox> (two operations :P)
10:02:48 <temoto> I see.
10:03:15 <temoto> So one could define data Ring a in Haskell?
10:03:29 <Eduard_Munteanu> I think so.
10:03:30 <MissPiggy> you could use typeclass
10:03:31 <temoto> and typeclass for operations?
10:03:36 <Cale> You could
10:03:40 <Eduard_Munteanu> In fact Num are already rings.
10:03:44 <Cale> It would be *somewhat* similar to Num
10:04:00 <Cale> But Num has some extra junk in it, and you'd be ignoring the laws.
10:04:19 <Cale> (You can't easily enforce the laws in Haskell's type system)
10:04:23 <Cale> http://en.wikipedia.org/wiki/Ring_%28mathematics%29#Formal_definition
10:05:07 <maltem> temoto, actually, the libraries *should* define Ring etc. rather than Num, but ... you know, backwards compatibility and all that boring stuff.
10:05:35 <Cale> I disagree. I think Ring doesn't really make sense in the Prelude.
10:05:56 <Eduard_Munteanu> Umm, what if rings, monoids etc. were defined at kind level?
10:06:19 <sproingie> weird, i think the last time i reattached my screen, i was seeing the exact same conversation
10:06:32 <Cale> sproingie: hehe
10:06:34 <EvanCarroll> /win 2
10:06:38 <EvanCarroll> gah
10:06:38 <dpratt71> since this has already turned into #math...what is interesting about polynomial rings?
10:06:47 <maltem> Cale, where should (+) and (*) go then? Do you actually like "Num"?
10:07:05 <Cale> The reason that I think Ring is an inappropriate name for Num is that there are instances of Num that we'd like to keep, but which are not Rings
10:07:17 <sproingie> if the abstraction is free i wouldn't care
10:07:22 <maltem> You mean floating-point arithmetics?
10:07:23 <Eduard_Munteanu> Oh.
10:07:26 <Cale> Yes.
10:07:30 <MissPiggy> Cale, I guess that I at least have an idea what the ideals are and an intuition about the link between geometry of curves with the polynomials but how does that relate to groebner basis?
10:07:36 <Cale> I think it would be very wrong to call it Ring and keep the instances for Float and Double
10:07:52 <maltem> Ok, it would at least be untidy.
10:07:56 <sproingie> i like Num because it appeals to a very common sense intuition: things that are numbers
10:08:23 <Berengal> I dislike Nums extraneous methods, which make things that are numbers not Num
10:08:24 <Cale> Num is vague enough not to actually imply a whole lot
10:08:38 <Cale> But yes, I'd want to strip out some extraneous garbage from Num
10:08:40 <Eduard_Munteanu> I don't see why Char couldn't be a Num though.
10:08:53 <Cale> Specifically, the dependencies on Eq and Show, and the abs/signum
10:09:07 <Cale> I do.
10:09:19 <Cale> Characters aren't numbers in any natural way :P
10:09:21 <Berengal> Maybe something like a Ringish class?
10:09:31 <Eduard_Munteanu> Cale, heh, I'm just too used to C :)
10:09:59 <Berengal> (Num is already pretty -ish)
10:10:02 <sproingie> not sure how you'd pull off Nat as a typeclass and still keep -
10:10:08 <Cale> Yeah, I like the name "Num"
10:10:14 <Berengal> sproingie: zero - _ = zero
10:10:19 <aconbere> What's the state of the art for simple haskell web apps, is it sill happs, or are things more focused on happstack?
10:10:28 <sproingie> 1 - 3 = zero?
10:10:31 <Cale> Maybe we should separate out negation and subtraction.
10:10:34 <Berengal> In Nat, yes
10:10:48 <Berengal> Well, sometimes
10:10:53 <Berengal> When we define it to be :)
10:11:11 <sproingie> aconbere: hack is getting a lot of development these days
10:11:15 <Cale> We should have an efficient Natural type.
10:11:15 <Eduard_Munteanu> Well they should be defined in terms of group theory, like substraction is addition with additive inverse.
10:11:19 <Berengal> It's a perfectly fine definition, but it doesn't make that much sense on nats as it does on other numbers
10:11:21 <sproingie> happstack is the successor to happs, is it not?
10:12:15 <Eduard_Munteanu> And - should be right associative so that it constructs the negation.
10:12:16 <sproingie> i can't wait for the new I/O manager so we can write a webserver that blows the doors off erlang
10:12:33 <Eduard_Munteanu> Not sure how to pull off adding the + in between.
10:12:40 <aconbere> sproingie: awesome, I've done a lot of Rack and WSGI dev so maybe something like that is a good fit for where I'm headed
10:12:56 <aconbere> sproingie: I really don't know much about happstack / happs
10:13:04 <sproingie> wsgi was one of python's better ideas, if not so much its actual spec
10:13:32 <aconbere> sproingie: IanB and Mitsushiko have been working on the next itteration on the spec, and apparently making good progress
10:13:50 <sproingie> aconbere: what i know of them comes from reading the haddock on their hackage pages :)
10:13:57 <aconbere> :)
10:13:58 <Eduard_Munteanu> I wonder... is it possible to define an "invisible" infix operator such that a b = a `op` b ?
10:13:59 <aconbere> heh
10:14:20 <sproingie> PJE is good at coming out with ideas, ianb is good at making things practical
10:14:22 <jmcarthur> Eduard_Munteanu: i wish
10:14:29 <sproingie> no idea who the other guy is
10:14:33 <c_wraith> Eduard_Munteanu: haskell already defines that operator
10:14:46 <c_wraith> Eduard_Munteanu: it's function application
10:15:07 <Twey> Maybe with some Unicode magic
10:15:07 <Eduard_Munteanu> c_wraith, hm, I wonder if it is polymorphic, so that you could do a - b and a / b in terms of it.
10:15:16 <jmcarthur> i sometimes wish it was overloadable though
10:15:17 <aconbere> sproingie: he's one of the pocoo devs (werkzeug in particular is one of his creations)
10:15:21 <Eduard_Munteanu> jmcarthur, oh.
10:15:23 <Eduard_Munteanu> :(
10:15:31 <aconbere> which along with webob is probably one of the more popular wsgi interfaces
10:15:41 <sproingie> Twey: i doubt it, haskell is pretty good at considering all unicode ws characters to be whitespace.  or at least not elegible as identifiers
10:15:58 <aconbere> (forgetting for a moment about the wsgi interfaces in things like django et. al.)
10:16:00 <Twey> hmm
10:16:02 <sproingie> aconbere: ahh werkzeug looked awful nice.  if i go back into python i'll probably switch my pylons app to it
10:16:13 <Twey> sproingie: New IO manager?
10:16:15 <aconbere> sproingie: I love werkzeug
10:16:32 <Twey> Are we talking about Iteratee here?
10:16:44 <aconbere> okay... /me heads back into haskell web territory
10:16:47 <sproingie> more likely since my pylons app already does a lot of generator-based stuff and contains a comment that says "It's like a super-verbose Haskell!", three guesses what my preferred porting target is
10:16:53 <kmc_> new IO manager is the epoll stuff?
10:16:59 <sproingie> Twey: yah it's all over reddit
10:17:06 <Eduard_Munteanu> What if every number is typed a -> b? That would make it possible to define "a b" I guess.
10:17:07 <Twey> Ah
10:17:11 <sproingie> er not iteratee, the epoll stuff
10:17:14 <Twey> Oh
10:17:23 * Twey doesn't read reddit habitually
10:17:32 <sproingie> i only read haskell.reddit
10:18:06 <Twey> What does it offer?
10:18:11 <sproingie> zoom zoom
10:18:17 <Twey> Oh
10:18:23 <Twey> Yay
10:18:30 <Twey> Good, but not exciting :
10:18:39 <sproingie> no new API, just scalability like mad
10:18:45 <Twey> Yeah
10:19:21 <Eduard_Munteanu> And every computation be expressible as (op a) . (op b) . ... . (op z) Final or something like that.
10:19:27 <Twey> Hum
10:19:51 <Eduard_Munteanu> Where forall T in a..z, T Final = some value t
10:20:09 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16442#a16442
10:20:16 <Twey> What am I supposed to do about this/
10:20:17 <Twey> ?**
10:20:17 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
10:20:19 <Eduard_Munteanu> Looks like a job for Template Haskell.
10:20:20 <Feuerbach> Eduard_Munteanu: that'd mess with priorities: a b^n = (a b)^n
10:21:16 <Eduard_Munteanu> Feuerbach, oh, right, composition is associative, that's not good.
10:21:49 * Twey is trying to build happstack, but HSP gives a useless error.
10:22:44 <Eduard_Munteanu> I think that would require polymorphic fixity... :(
10:23:09 <Eduard_Munteanu> s/fixity/precedence/
10:24:12 <Twey> Oh, path issue.  Got it.
10:28:18 <Baughn> Eduard_Munteanu: Polymorphic /precedence/? What?
10:32:29 <Eduard_Munteanu> Baughn, yeah, was thinking if there was any way to determine precedence depending on types.
10:32:41 <Eduard_Munteanu> Though I think it's bogus.
10:32:59 <Baughn> Well, it's theoretically possible in the "check every permutation of the program, figure out what typechecks" way
10:33:40 <Baughn> I wouldn't say it's very reasonable, though. For one thing, precedence depending on types would run into the types depending on precedence
10:33:59 <Eduard_Munteanu> Baughn, yeah, I'm not sure it's feasible to solve the problem Feuerbach described.
10:34:06 <Baughn> Eduard_Munteanu: Oh, it's solvable.
10:34:22 <c_wraith> the compiler could search for fixed points...  And it'd be a compile error if there were multiple fixed points. :)
10:34:23 <dschoepe> Is there a way to directly access/retrieve the individual bytes of e.g. a Double value. (I need this for some low-level stuff and am reluctant to resort to C for that)
10:34:41 <c_wraith> @src Double
10:34:42 <lambdabot> data Double = D# Double#
10:34:43 <Eduard_Munteanu> dschoepe, unsafeCoerce?
10:34:43 <Baughn> c_wraith: Right. The question is then if there is an algorithm better than brute force for that.
10:34:48 <Baughn> Which there almost certainly is.
10:35:08 <c_wraith> looks like unsafeCoerce could work....  But that's scary
10:35:15 <Eduard_Munteanu> Did we find P = NP recently? :P
10:35:15 <Baughn> unsafeCoerce would be bad
10:35:25 <Baughn> dschoepe: Ask in #ghc, I say
10:35:37 <Baughn> (I mean, what would you unsafeCoerce /to/?)
10:35:37 <Eduard_Munteanu> Because if so, I'll change my :P in :NP :)
10:35:38 <dschoepe> c_wraith: Indeed, but the pointer arithmetic I am doing in C to get the same results, is just as scary :)
10:35:38 <kmc_> dschoepe, if you're going to use unsafeCoerce it should be on the unboxed value
10:35:56 <Baughn> dschoepe: The solution I'd go for is, in fact, a C FFI call.
10:35:57 <kmc_> dschoepe, what about using the stuff from Foreign.Storable?
10:36:02 <kmc_> no FFI required
10:36:07 <kmc_> alloca + poke + pointer cast + peek
10:36:14 <Baughn> Oh yeah. That'd work.
10:36:16 <kmc_> it'll be a little slower than the unboxed value unsafe cast
10:36:24 <dschoepe> thanks, I'll try that.
10:36:26 <c_wraith> Just be sure to get the type sizes right when you do that.
10:36:28 <Baughn> kmc_: (Why?)
10:36:32 <c_wraith> Is double 64 bits on all platforms?
10:36:38 <kmc_> Baughn, because you're copying stuff around
10:36:40 <Baughn> c_wraith: It should be an IEE double
10:36:41 <Eduard_Munteanu> IIRC, yes.
10:36:42 <Baughn> *IEEE
10:36:51 <Eduard_Munteanu> long double is longer.
10:36:52 <kmc_> unsafeCoerce# is a no-op at runtime
10:37:10 <Baughn> kmc_: I figured the compiler would end up keeping that data in registers/on the stack
10:37:25 <kmc_> sure -- it's still copied
10:37:30 <Baughn> Yeah, well..
10:37:42 <Baughn> You'd probably be done within less than one memory roundtrip
10:37:49 <kmc_> yeah
10:37:56 <kmc_> not worth worrying about
10:38:31 <Eduard_Munteanu> I'd like to see monadic inline asm in Haskell :P
10:38:54 <Eduard_Munteanu> ST# :)
10:38:54 <kmc_> there's an llvm package that does that
10:39:03 <Eduard_Munteanu> kmc_, oh, neat.
10:39:14 <kmc_> portably too ;)
10:39:17 <Eduard_Munteanu> Yeah.
10:39:46 <kmc_> which is an exciting way to implement a DSL
10:40:32 <Eduard_Munteanu> I'm going to try House and see where that leads me.
10:40:50 <Baughn> To ancient GHCs, first off. :P
10:41:03 <Baughn> If you figure out how to make it run on 6.8, be sure to tell someone
10:41:07 <Eduard_Munteanu> Baughn, yeah, I noticed it requires 6.8.2...
10:41:09 <Eduard_Munteanu> I wonder why.
10:41:13 <Baughn> *6.10
10:41:17 <Baughn> Hm, I thought it was 6.6
10:41:26 <Baughn> Eduard_Munteanu: Because it's implemented as patches to GHC itself
10:41:28 <Eduard_Munteanu> Yeah, I have 6.10.4 here.
10:41:51 <Eduard_Munteanu> Baughn, lol, so it actually patches and uses the GHC runtime somehow?
10:42:19 <jmcarthur> wat you mean house doesnt work on 6.12?!?
10:42:19 <Eduard_Munteanu> Not very nice...
10:42:21 <Baughn> Eduard_Munteanu: We /are/ talkin about House, right? The haskell/ghc-based OS/
10:42:27 <Baughn> ?
10:42:32 <Eduard_Munteanu> Baughn, yes,
10:42:37 <Eduard_Munteanu> not House MD.
10:42:39 <Eduard_Munteanu> :)
10:42:49 <jmcarthur> house is basically the ghc runtime ported to run on raw hardware, as i understand it
10:42:51 <Baughn> Eduard_Munteanu: Right. Now consider that GHC is written to run on a POSIX kernel.
10:43:20 <Eduard_Munteanu> Baughn, I thought they'd try to implement low-level stuff in Haskell code somehow.
10:43:24 <jmcarthur> i want to make my coworkers cry by writing kernel modules in haskell
10:43:34 <kmc_> there was an article about that
10:43:37 <jmcarthur> yeah
10:43:52 <Baughn> Eduard_Munteanu: You can't use haskell before the haskell runtime is up, and that requires a far bit of non-haskell code. Asm and such.
10:43:59 <Eduard_Munteanu> jmcarthur, you can seriously annoy people by doing that: http://lwn.net/Articles/352432/
10:44:06 <jmcarthur> yeah i know
10:45:03 <Eduard_Munteanu> Bah, is there no way to create Haskell code with no runtime? Like do all manual memory management and stuff?
10:45:09 <jmcarthur> i've been tempted many times by the idea of a kernel designed to run a simple functional language efficiently
10:45:11 <Eduard_Munteanu> Like writing your own Prelude?
10:45:25 <jmcarthur> Eduard_Munteanu: maybe look at what JHC does and tweak it as desired?
10:45:29 <Baughn> Eduard_Munteanu: Nope. Makes no sense, even.
10:45:43 <Baughn> Eduard_Munteanu: If you want haskell, you need a runtime. You can write your own by editing GHC. ;)
10:45:51 <dschoepe> kmc_, Eduard_Munteanu, Baughn: thank you, the approach via Foreign.Storable worked perfectly
10:46:11 <kmc_> @hoogle (Storable a, Storable b) => a -> IO b
10:46:12 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
10:46:12 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
10:46:12 <lambdabot> Foreign.Marshal.Array withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b
10:46:19 <hatds> :t iterate
10:46:19 <lambdabot> forall a. (a -> a) -> a -> [a]
10:46:21 <Eduard_Munteanu> Baughn, I mean, is there no subset of Haskell that can be used with no runtime?
10:46:38 <Eduard_Munteanu> jmcarthur, nah, that's still including compiler code along.
10:46:50 <Baughn> Eduard_Munteanu: Um. "main = return ()"?
10:46:56 <Baughn> Eduard_Munteanu: ..no, that still requires calling main.
10:47:15 <jmcarthur> Eduard_Munteanu: huh? JHC can generate standalone C programs, i thought
10:47:18 <Baughn> Eduard_Munteanu: It depends on what you mean by "runtime". Even C has a fairly involved runtime - and that's not including the kernel.
10:47:24 <kmc_> "main = return ()" will actually involve quite a lot of stuff
10:47:39 <jmcarthur> Eduard_Munteanu: all you would need to do is change how it generates the C from using syscalls to using lower level things
10:47:40 <kmc_> for example, it's a redex
10:47:43 <Eduard_Munteanu> Baughn, okay, lemme explain. In C you can instruct the linker to output raw machine code and run with no libc.
10:48:09 <Eduard_Munteanu> Baughn, can you do that on Haskell?
10:48:18 <Berengal> No
10:48:22 <jmcarthur> Eduard_Munteanu: not with GHC
10:48:23 <Ke> you would still need memory allocation routine
10:48:29 <jmcarthur> Eduard_Munteanu: but you could tweak JHC to do it i bet
10:48:32 <Eduard_Munteanu> jmcarthur, yeah, but I'm specifically interested in using Haskell on bare hardware.
10:48:38 <Eduard_Munteanu> jmcarthur, oh.
10:48:49 <hatds> @src iterate
10:48:49 <lambdabot> iterate f x =  x : iterate f (f x)
10:48:51 <Baughn> Eduard_Munteanu: GHC outputs .o files, which are basically that.
10:48:57 <Eduard_Munteanu> Ke, not really.
10:49:06 <Baughn> Eduard_Munteanu: You then need to link them and add support and whatnot to get them running on raw hardware..
10:49:07 <Eduard_Munteanu> I'm thinking of some sort of ST that maps to the memory space.
10:49:07 <c_wraith> @. pl src iterate
10:49:08 <lambdabot> (line 1, column 1):
10:49:08 <lambdabot> unexpected end of input
10:49:08 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
10:49:17 <Baughn> Eduard_Munteanu: Oh, we mentioned the LLVM thing earlier, right?
10:49:18 <jmcarthur> Eduard_Munteanu: oh i think you are asking the impossible
10:49:27 <kmc_> Eduard_Munteanu, isn't any kernel an elaborate runtime?
10:49:31 * Baughn agrees with jmcarthur. Computers don't work like that.
10:49:39 <Eduard_Munteanu> kmc_, yes, but it's contained in its own code.
10:49:42 <jmcarthur> Eduard_Munteanu: haskell at its very core requires some hidden memory management
10:49:50 <jmcarthur> Eduard_Munteanu: even ST code
10:49:57 <Eduard_Munteanu> Ouch...
10:50:06 <jmcarthur> this is not a problem...
10:50:13 <Berengal> You could disallow everything outside of IO...
10:50:24 <jmcarthur> haskell is not high level assembly
10:50:25 <temoto> Eduard_Munteanu: Funny, couple of days ago, i was thinking wouldn't it be great if compilers would output a raw image capable on running under Virtualbox or Xen hypervisor or Hyperv or something.
10:50:27 <kmc_> Eduard_Munteanu, what does "contained in its own code" mean?
10:50:38 <Eduard_Munteanu> jmcarthur, heh, that's what I wanted. Lambdas and asm :)
10:50:43 <Baughn> It's a pity, I can't use House/linux for my filesystem. Too much 6.12 stuff in it. :P
10:50:44 <Berengal> It's *possible* if you poke it enough, but there's no reason you'd want to do that...
10:51:03 <jmcarthur> Eduard_Munteanu: even just a simple closure, core to implementing something like haskell, would require some machinery that you can't write in haskell
10:51:03 <kmc_> you can compile Haskell for bare metal (or virtualization).  this is totally separate issue from whether it needs a runtime
10:51:06 <Eduard_Munteanu> kmc_, when using C and inline asm, you don't get any code from the compiler into the final executable code.
10:51:25 <Baughn> > fix (h a s k e l l)
10:51:25 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:51:26 <lambdabot>    `SimpleReflect.FromExpr ...
10:51:27 <c_wraith> Eduard_Munteanu: you get library code, though.
10:51:32 <jmcarthur> Eduard_Munteanu: heck, you can't even just use C exclusively to do a kernel
10:51:39 <c_wraith> Eduard_Munteanu: how's that different than what haskell does?
10:51:47 <jmcarthur> C is not low level enough to communicate directly with hardware
10:51:51 <Eduard_Munteanu> c_wraith, no library code, why? I don't load any headers I don't write.
10:52:06 <kmc_> Eduard_Munteanu, there is lots of hidden library code
10:52:07 <Eduard_Munteanu> jmcarthur, hm, you can.
10:52:11 <c_wraith> Eduard_Munteanu: you're not doing much of anything without libraries.
10:52:11 <kmc_> like the stuff that calls main()
10:52:12 <temoto> Because C is a crossplatform assembler. :)
10:52:17 <kmc_> i think we're arguing about something illdefined here
10:52:18 <jmcarthur> Eduard_Munteanu: i'd love to see you try
10:52:22 <Berengal> jmcarthur: it is. It's perfectly acceptable to say int mouse* = 0x100;
10:52:28 <kmc_> anyway, if you really need to run Haskell "without a runtime", use an interpreter
10:52:35 <kmc_> that's either no runtime or all runtime ;)
10:52:42 <Eduard_Munteanu> jmcarthur, all you need is instruct the linker where to put your code. Apart from that, you can simply use inline asm.
10:53:00 <jmcarthur> Eduard_Munteanu: inline asm isn't C
10:53:05 <Ke> Berengal: does C standard allow giving pointers arbitrary values?
10:53:23 <Berengal> Ke: Not entirely sure, but pretty sure
10:53:26 * Berengal tries
10:53:28 <Eduard_Munteanu> [dubious/discuss] :)
10:53:33 <Ke> outside the standard that obviously works
10:53:56 <Ke> Berengal: you can't try that one out, only check
10:53:57 <Eduard_Munteanu> I'd say you can pretty much infer it from the standard.
10:54:00 <Berengal> Standards are for people who don't have compilers
10:54:06 <Eduard_Munteanu> At least on von Neumann machines.
10:54:33 <Berengal> Ke: The real standard is "It should work on my machine" :)
10:54:45 <Ke> well gcc is known not to be the worst case scenario compiler
10:55:02 <Ke> many things work on gcc but not when running on valgrind
10:55:07 <Ke> etc...
10:55:10 <Eduard_Munteanu> GCC is quite standard-compliant though.
10:55:49 <Ke> standard compilance doesn't imply worst case scenario behaviour on undefined cases
10:55:56 <Eduard_Munteanu> Oh.
10:55:59 <Eduard_Munteanu> I see what you mean.
10:56:35 <Ke> like char* p; char *a = p; is undefined behaviour
10:56:46 <kmc_> on a worst case scenario 95% of the software in the world would fire ze missiles
10:56:59 <jmcarthur> here is an example of where C alone fails for writing a kernel: you cannot load the global descriptor table without a special opcode which C does not provide access to
10:57:03 <mreh> is ghc written with Parsec?
10:57:03 <kmc_> (the other 5% being the military's missile-firing software)
10:57:09 <Ke> ie. proper compiler will install keyloggers and upload the keywords
10:57:10 <Baughn> I'd like to see a C compiler that actually aborts on any undefined behaviour
10:57:12 <kmc_> mreh, no.  iirc it uses Happy for parsers
10:57:23 <Eduard_Munteanu> jmcarthur, yeah, but as long as you have inline asm, it's fine.
10:57:26 <Vanadium> Baughn: Would you not also need a C runtime?
10:57:37 <Ke> passwords...
10:57:39 <Baughn> Vanadium: Well, yeah
10:57:48 <jmcarthur> Eduard_Munteanu: then what's the difference between that and writing a haskell runtime in assembly?
10:58:01 <kmc_> urg this argument is depressing
10:58:22 <Ke> depressing yes, argument no
10:58:42 <Eduard_Munteanu> jmcarthur, hm, yeah I guess it's only a matter of size then, as the C runtime must only set the stack and minimal stuff to run on bare hardware.
10:59:15 <Baughn> Yep. THe minimal C runtime doesn't even provide a heap.
10:59:25 <kmc_> ah.  so a minimal runtime (written in assembly) for C code will be smaller than a minimal runtime (written in assembly) for Haskell code
10:59:29 <kmc_> i'll agree with that
10:59:31 <jmcarthur> Eduard_Munteanu: come to think of it, what's the difference between "runtime" and "compiled code"? they do the same things
10:59:40 <kmc_> does this settle the question? ;)
10:59:41 <Baughn> kmc_: By, oh, four orders of magnitude
10:59:47 <Eduard_Munteanu> jmcarthur, runtime does not come from code you wrote.
11:00:03 <Eduard_Munteanu> It's simply linked in.
11:00:03 <Eduard_Munteanu> In Haskell's case, that is.
11:00:11 <jmcarthur> Eduard_Munteanu: runtime is unnecessary without code to execute though, so it does come from code you wrote in that sense
11:00:22 <Eduard_Munteanu> Yeah.
11:00:38 <jmcarthur> Eduard_Munteanu: that is, runtime code is really just a part of compiled code
11:01:10 <Eduard_Munteanu> So basically, the nice way to write a Haskell OS is to write a Haskell runtime and the proper OS code.
11:01:16 <jmcarthur> Eduard_Munteanu: even stack manipulation, being only a couple instructions here and there, can be seen as runtime code, despite it being emitted from a compiler
11:01:33 <Eduard_Munteanu> jmcarthur, hm, it's true.
11:01:39 <Berengal> A computer is a UTM running programs that quite often are UTMs themselves, and is in turn a program being run by yet another UTM (possibly one more powerful than just TC)
11:02:22 <Baughn> Berengal: How large a proportion of our measure do you think comes from computers attempting solomonoff induction? ;)
11:02:24 <Berengal> In short: Distinguishing interpreted code from "native" code is a subjective distinction
11:02:31 <Eduard_Munteanu> My question would then be, is it possible to write a Haskell runtime in Haskell? Won't the runtime itself need a runtime?
11:02:56 <kmc_> Eduard_Munteanu, it's of course possible if the target machine is "Haskell interpreter" or "mythical Haskell-executing CPU"
11:03:06 <Berengal> Baughn: About three apples, I'd think
11:03:10 <mreh> would this be a bitch to parse? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16443#a16443
11:03:14 <jmcarthur> Berengal: a computer can't be a UTM. it has bounds on what it can computer which a UTM does not have ;)
11:03:27 <jmcarthur> *what it can compute
11:03:33 <mreh> I've written a parser to parse the chords, but parsing something else in parallel...
11:03:45 <kmc_> mreh, i've no idea what this means or which parts are meaningful
11:03:48 <kmc_> i guess it's musical notation
11:03:54 <mreh> kmc_ yes
11:04:00 <lament> mreh: you're not using my parser anymore?
11:04:04 <jmcarthur> Eduard_Munteanu: you could write a haskell runtime in haskell, but the result would in turn require another haskell runtime
11:04:06 <Berengal> jmcarthur: Who knows? Perhaps it'll turn sentient and eat up the entire universe, and perhaps the universe is really infinite...
11:04:08 <kmc_> mreh, it looks like something you would not parse with Parsec or another grammar-based tool
11:04:09 <Eduard_Munteanu> kmc_, no, suppose I want to write a x86-targeted OS in C. I need a compiler and the proper OS code. What do I need if I do s/C/Haskell/ ?
11:04:10 <jmcarthur> Eduard_Munteanu: this would be like a VM
11:04:19 <kmc_> a compiler and the proper OS code
11:04:22 <mreh> lament: I'm still using it in some form, I've modified it a fair old bit
11:04:42 <jmcarthur> Berengal: well, it's not designed to do that, at least
11:04:54 <Berengal> jmcarthur: Not by us, no :P
11:04:58 <kmc_> mreh, it looks like your format is not really described by a grammar, but rather by some fixed-position fields
11:05:00 <Berengal> This argument is becoming silly...
11:05:05 <jmcarthur> :P
11:05:09 <lament> mreh: that actually seems really easy to parse
11:05:10 <mreh> kmc_ I'm listening
11:05:16 <Eduard_Munteanu> I'm not sure I understand.
11:05:17 <kmc_> indeed, could we take the metaphysics of compilation to -blah?
11:05:21 <lament> mreh: ignore all the people who say the format is prescribed by fixed-position fields
11:05:23 <Eduard_Munteanu> How come C doesn't need a VM then?
11:05:25 <mreh> lament: I wanted a way to notate a melody along with some chords too
11:05:30 <kmc_> no language "needs" a VM
11:05:34 <kmc_> there are native compilers for Java
11:05:36 <Baughn> Eduard_Munteanu: C does need a VM
11:05:39 <kmc_> a VM is an implementation strategy
11:05:48 <mreh> parsing that and checking the semantics is hard without any bars
11:05:48 <jmcarthur> Eduard_Munteanu: it does. hardware in combination with some assembler is a VM too
11:05:49 <kmc_> in another definition... C *is* a VM.  every language is an abstract machine
11:05:52 <Baughn> Eduard_Munteanu: Or, rather, an RTS. It's just that the RTS is much smaller
11:05:57 <lament> mreh: why don't you just add bars?
11:05:59 <kmc_> anyway please go to -blah
11:06:08 <kmc_> mreh, so you could do it with just basic list / Seq / array ops
11:06:13 <Baughn> Eduard_Munteanu: As I recall, I got C working in about fifty lines of assembly
11:06:22 <mreh> lament: it makes it harder to read
11:06:23 <Eduard_Munteanu> Oooh, I get it... the C runtime runs on a bare machine code vm.
11:06:29 <Baughn> Eduard_Munteanu: Then I could go and implement malloc/free in C, treating memory as a giant array
11:06:30 <Eduard_Munteanu> The same happens for Haskell code.
11:06:31 <Eduard_Munteanu> Right?
11:07:04 <Baughn> Eduard_Munteanu: For haskell code, though, you need a lot more non-haskell code than C needs non-C code
11:07:07 <lament> mreh: not by much... and it's how written music always works, anyway
11:07:19 <lament> bar lines span all the staves
11:07:20 <Eduard_Munteanu> So to write a Haskell OS, I need a OS code, a Haskell compiler and some Haskell runtime that is reproduced in that machine's code.
11:07:22 <kmc_> the bare machine is a VM too.  your code actually executes in terms of a 4-dimensional lattice of interacting quantum harmonic oscillators
11:07:30 <Baughn> Eduard_Munteanu: Hell, even 64-bit assembly needs non-64-bit-assembly startup code to get the CPU to that state in the first place
11:07:33 <jmcarthur> Eduard_Munteanu: the runtime can be the "OS code"
11:07:36 <Baughn> Eduard_Munteanu: Yeah.
11:07:38 <Eduard_Munteanu> kmc_, heh, yeah.
11:08:03 <lament> kmc_: that sounds like a good basis for a monad tutorial. A monad is like a 4-dimensional lattice of interacting quantum harmonic oscillators...
11:08:04 <Berengal> Eduard_Munteanu: Or you could redefine the language and rewrite the compiler so you could drop the OS code...
11:08:08 <kmc_> lament, indeed
11:08:14 <shambler> lament, lol
11:08:17 <Berengal> But by then you've probably reinvented forth
11:08:25 <jmcarthur> Berengal: no need to redefine the language for that
11:08:27 <mreh> lament: they do, but it's only one system of bars
11:08:29 <kmc_> i think all sides of this argument are equivalent up to alpha renaming
11:08:36 <kmc_> what's the term for an argument with this property?
11:08:49 <lament> mreh: two, surely? Chords and melody?
11:09:02 <jmcarthur> kmc_: i am unaware of an argument at all...
11:09:29 <mreh> lament: Ideally I'd have a melody annotate with chords on one staf
11:09:29 <mreh> f
11:09:38 <Eduard_Munteanu> This is terribly more complicated, because it seems I need special Haskell compilers (or linkable runtimes) to write Haskell OSes, which isn't quite true for C.
11:09:47 <lament> mreh: just give up and start writing a graphical notation engine :D
11:10:01 <Berengal> Eduard_Munteanu: Yes it is, it's just that all C compilers are special
11:10:04 <mreh> :(
11:10:07 <jmcarthur> Eduard_Munteanu: it's not true for C. you *still* have to write runtime for C
11:10:08 <Eduard_Munteanu> Yeah.
11:10:12 <kmc_> -blah
11:10:16 <Baughn> Eduard_Munteanu: It's not quite true for /compilers/
11:10:17 * kmc_ -blah
11:10:22 <Eduard_Munteanu> jmcarthur, yes, only that the C runtime is feasible for both OSes and normal programs.
11:10:28 <mreh> are we in #C? :D
11:10:36 <Baughn> Eduard_Munteanu: It's the linker that's special, you don't need a special kind of haskell compiler to do this. It's just that GHC is also the haskell linker.
11:10:42 <glguy> HaLVM uses the GHC runtime as the OS runtime
11:11:03 <lament> mreh: have you seen that chord visualization thing where the pitches are arranged on a circle as 12 equidistant dots, then the dots light up for chord notes, so you can easily see the half-step movements from one chord to the next
11:12:04 <mreh> lament: no
11:12:05 <jfoutz> kmc_: Wittgenstein i think. arguments are equivalent, but the internal meanings of the words are different for the people arguing...
11:12:11 <Eduard_Munteanu> Circle of fifths?
11:12:15 <mreh> lament: hearing them is more important :)
11:12:25 <mreh> Eduard_Munteanu, it's a chromatic thing
11:12:42 <mreh> if anyone in this room takes Wittgenstein seriously I'd be very surprised
11:12:55 <Eduard_Munteanu> IIRC, the fifths generate the chromatic scale.
11:12:58 <EnglishGent> hi Grey_Fox :)
11:13:14 <Grey_Fox> hi EnglishGent
11:13:24 <lament> Eduard_Munteanu: circle of semitones actually
11:14:42 <jfoutz> mreh: i'm only aware of him from an old paul graham essay.
11:15:20 <lament> mreh: http://www.youtube.com/watch?v=xi2_25rT0pk
11:16:39 <mreh> lament: music is math :)
11:16:56 <lament> eh
11:17:08 <lament> not really, i think this guy is just wasting time
11:20:30 <EnglishGent> wb Grey_Fox
11:20:59 <temoto> lament: thank you so much for link, it
11:21:03 <temoto> 's awesome
11:23:03 <kmc_> mreh, music has the right to children :)
11:24:12 <lament> temoto: it gives you an illusion that you understand what's going on. But ultimately it's useless because it has no predictive power - good music and bad music will all look the same
11:24:33 <Philonous> kmc_: Nice way to expose your musical preferences without anyone noticing :>
11:24:42 <kmc_> :O
11:24:44 <kmc_> i've been found out
11:25:12 <mreh> I think someone likes listening to ABBA
11:25:26 <kmc_> also, you know you're a PL nerd if you read ":>" as "supertype relation"
11:25:48 <Eduard_Munteanu> lament, not really, it lets you find ideas to "generate" music.
11:26:17 <Eduard_Munteanu> In theory, you can postulate something and test it by using it to compose a good piece.
11:27:36 <shambler> yeah, the predictive power of such things is the music itself, you construct some levels of abstraction and then use them to construct complex systems (music!)
11:27:37 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Twelve_tone
11:27:48 <Eduard_Munteanu> Serialism is more like formulas :)
11:32:19 <aconbere> so playing around with haskell and HTTP, I see there's a solid looking library Network.HTTP
11:32:30 <aconbere> but there are little to no examples of using this for server side tasks
11:32:46 <aconbere> the receiveHTTP function accepts a HandleStream
11:32:54 <aconbere> which is defined in Network.TCP
11:32:55 <mreh> do functions implement Read?
11:33:39 <mreh> > read "show \"hello\""
11:33:40 <lambdabot>   * Exception: Prelude.read: no parse
11:34:09 <aconbere> but I'm not entirely sure how this relates back to Network
11:34:13 <aconbere> and Network.Socket
11:34:45 <aconbere> Oooo... I see... Network.TCP is a child of Network.HTTP
11:34:46 <aconbere> hmmm
11:34:58 <lament> shambler: this just leads to bad music that conforms to these rules you discovered, that seem to work so well in the context of good pieces you discovered them in.
11:35:11 <lament> s/that seem/which seem
11:36:51 <lament> great composers just create music, and other people discover rules in their music after the fact :)
11:41:09 <temoto> lament: that's like 'dependent types don't predict you will write a good program'.
11:41:30 <shambler> you don't need to use formal systems to construct music, but you can use abstractions, in fact composers use them
11:41:54 <mreh> > read "show" $ "hello
11:41:55 <lambdabot>   <no location info>:
11:41:55 <lambdabot>      lexical error in string/character literal at end o...
11:42:03 <mreh> :t read "show"
11:42:04 <lambdabot> forall a. (Read a) => a
11:42:10 <shambler> like octave, tonality
11:42:12 <lament> shambler: interesting analogy
11:42:53 <temoto> mreh: you miss closing "
11:43:02 <mreh> > read "show" $ "hello"
11:43:02 <shambler> it's for temoto I guess?
11:43:02 <temoto> > read "show" $ "hello"
11:43:02 <lambdabot>   No instance for (GHC.Read.Read ([GHC.Types.Char] -> b))
11:43:03 <lambdabot>    arising from a u...
11:43:03 <lambdabot>   No instance for (GHC.Read.Read ([GHC.Types.Char] -> b))
11:43:03 <lambdabot>    arising from a u...
11:43:33 <temoto> @t read
11:43:33 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:43:36 <temoto> @typu read
11:43:37 <lambdabot> forall a. (Read a) => String -> a
11:43:45 <temoto> wwha
11:43:53 <mreh> lambdabot is clever
11:43:53 <temoto> typu?
11:43:59 <temoto> @type read
11:44:00 <lambdabot> forall a. (Read a) => String -> a
11:44:07 <temoto> integersting
11:44:16 <kmc_> mreh, to read a function you'd need to compile or interpret haskell
11:44:22 <kmc_> see the "hint" package
11:45:29 <temoto> > read "show"
11:45:30 <lambdabot>   * Exception: Prelude.read: no parse
11:45:38 <Berengal> > read "()"
11:45:39 <lambdabot>   ()
11:45:47 <temoto> > read "read"
11:45:48 <lambdabot>   * Exception: Prelude.read: no parse
11:45:59 <temoto> read is unsafe?
11:46:07 <Berengal> It's partial, yes
11:46:23 <Berengal> You should use reads if you want totality
11:46:28 <Berengal> @type reads
11:46:29 <lambdabot> forall a. (Read a) => String -> [(a, String)]
11:46:30 <c_wraith> does lambdabot have spoon and teaspoon?
11:46:40 <c_wraith> Those functions should be safe in the lambdabot context
11:47:09 <temoto> :t spoon
11:47:10 <lambdabot> Not in scope: `spoon'
11:47:15 <temoto> @hoogle spoon
11:47:15 <lambdabot> No results found
11:47:27 <temoto> I can bend the spoon.
11:47:30 <Berengal> What datastructure should I use if I want deleteFindNthMinimum :: Foo a -> (a, Foo a)?
11:48:00 <temoto> Foo a?
11:48:02 <c_wraith> teaspoon has the awesome type signature :: a -> Maybe a
11:48:20 <temoto> :t Just
11:48:21 <lambdabot> forall a. a -> Maybe a
11:48:34 <c_wraith> but sometimes teaspon returns Nothing
11:48:35 <c_wraith> :)
11:48:35 <Berengal> @type const Nothing
11:48:36 <lambdabot> forall a b. b -> Maybe a
11:48:44 <Berengal> :)
11:48:44 <temoto> ok
11:48:50 <c_wraith> and sometimes it returns Just ...
11:49:17 <temoto> > unsafePerformIO randomIO
11:49:18 <lambdabot>   Not in scope: `unsafePerformIO'
11:49:27 <temoto> > System.IO.Unsafe.unsafePerformIO randomIO
11:49:28 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
11:49:49 <temoto> @hoogle unsafePerformIO
11:49:49 <lambdabot> Foreign unsafePerformIO :: IO a -> a
11:49:49 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
11:50:15 <temoto> lambdabot must be protected from unsafePerformIO?
11:50:21 <RayNbow> of course
11:50:28 <temoto> well
11:50:35 <temoto> then we need a seed value
11:50:44 <c_wraith> > stdGen 5 28
11:50:45 <lambdabot>   Not in scope: `stdGen'
11:50:46 <Berengal> You don't want a bot running arbitrary code on your machine, do you?
11:50:50 <c_wraith> > mkStdGen 5 28
11:50:51 <lambdabot>   Couldn't match expected type `t1 -> t'
11:50:51 <lambdabot>         against inferred type `Syste...
11:50:55 <c_wraith> > mkStdGen 5
11:50:56 <lambdabot>   6 1
11:50:58 <c_wraith> there.
11:50:59 <RayNbow> > unsafePerformIO launchNukes
11:50:59 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `launchNukes'
11:51:03 <c_wraith> Now you have a seed
11:51:04 <Berengal> , evalRand
11:51:06 <lunabot>  luna: Not in scope: `evalRand'
11:51:14 <Berengal> , execRand
11:51:15 <lunabot>  luna: Not in scope: `execRand'
11:51:17 <Berengal> :/
11:51:26 <temoto> Berengal: i would allow expression "unsafePerformIO randomIO".
11:51:43 <temoto> > mkStdGen 5
11:51:44 <lambdabot>   6 1
11:51:45 <Berengal> temoto: But to do that you need to allow the expression "unsafePerformIO"
11:51:51 <temoto> :t mkStdGen
11:51:52 <lambdabot> Int -> StdGen
11:52:01 <temoto> @hoogle stdGen
11:52:01 <c_wraith> let g = mtStdGen 37 in randomR (1, 100) g
11:52:01 <lambdabot> System.Random data StdGen
11:52:01 <lambdabot> System.Random getStdGen :: IO StdGen
11:52:01 <lambdabot> System.Random mkStdGen :: Int -> StdGen
11:52:08 <temoto> @src StdGen
11:52:08 <lambdabot> Source not found. Do you think like you type?
11:52:10 <c_wraith> > let g = mtStdGen 37 in randomR (1, 100) g
11:52:11 <lambdabot>   Not in scope: `mtStdGen'
11:52:12 <Berengal> Luna had the ability to run MonadRandom monads...
11:52:17 <c_wraith> > let g = mkStdGen 37 in randomR (1, 100) g
11:52:17 <lambdabot>   (2,1520532 40692)
11:52:27 <Berengal> , runRand
11:52:28 <lunabot>  luna: Not in scope: `runRand'
11:52:30 <temoto> @hoogle stdGen
11:52:30 <Berengal> :(
11:52:31 <lambdabot> System.Random data StdGen
11:52:31 <lambdabot> System.Random getStdGen :: IO StdGen
11:52:31 <lambdabot> System.Random mkStdGen :: Int -> StdGen
11:52:41 <c_wraith> lambdabot can do random stuff.  You just need to give a seed manually
11:52:57 <temoto> so, let's get back to the teaspoon
11:53:01 <Berengal> preflex: seen mmorrow
11:53:02 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- mmorrow was last seen on #ghc 4 days, 16 hours, 55 minutes and 18 seconds ago, saying: * mmorrow is rtfm'ing
11:53:56 <RayNbow> preflex sends a notice to the channel?
11:54:07 <c_wraith> The way mueval works is by restricting the names allowed.
11:54:09 <aconbere> argh
11:54:13 <aconbere> I can't catch a break these days
11:54:16 <aconbere> http://paste.pocoo.org/show/168514/
11:54:32 <aconbere> "duplicate definition for symbol"
11:54:32 <c_wraith> It could import teaspoon, without allowing the name unsafePerformIO
11:54:32 <aconbere> ?
11:56:06 <c_wraith> > read ""
11:56:07 <lambdabot>   * Exception: Prelude.read: no parse
11:56:12 <Berengal> aconbere: ghc-pkg unregister network-2.2.1.7 && rm -rf /Users/aconbere/.cabal/lib/network-2.2.1.7/ghc-6.12.1/ && cabal install network
11:56:15 <aavogt> @hoogle Day -> CalendarTime
11:56:16 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:56:16 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:56:16 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
11:56:16 <c_wraith> > read "()"
11:56:17 <lambdabot>   ()
11:56:29 <aconbere> Berengal: thanks
11:56:34 <aavogt> > (  )
11:56:35 <lambdabot>   ()
11:56:55 <Berengal> aconbere: It's the computer equivalent to a kick in the shins
11:58:32 <MissPiggy> @hoogle (a -> Bool) -> [a] -> ([a],[a])
11:58:32 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
11:58:33 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
11:58:33 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
12:01:00 <temoto> > let choose a b = if b then Just a else Nothing; ch15 = choose 15 in (ch15 True, ch15 False)
12:01:01 <lambdabot>   (Just 15,Nothing)
12:02:40 <temoto> > let choose a b = if b then Just a else Nothing; ch15 = choose 15; int2bool n = n `mod` 2 == 0 in map int2bool [1..4]
12:02:41 <lambdabot>   [False,True,False,True]
12:03:41 <aavogt> @type partition
12:03:42 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:03:57 <aavogt> hoogle needs to get rid of the redundancies
12:04:54 <rovar> is code.haskell.org down for anyone else?
12:05:02 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0 in partition . itob [1..4]
12:05:03 <lambdabot>   Couldn't match expected type `f (a -> GHC.Bool.Bool)'
12:05:03 <lambdabot>         against infer...
12:05:09 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0 in partition $ itob [1..4]
12:05:09 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:05:10 <lambdabot>         against inferred ...
12:05:33 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0 in partition itob $ [1..4]
12:05:33 <lambdabot>   ([2,4],[1,3])
12:05:49 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0 in partition itob [1..4]
12:05:50 <lambdabot>   ([2,4],[1,3])
12:06:07 <temoto> rovar: yes
12:06:14 <Berengal> > partition even [1..4]
12:06:15 <lambdabot>   ([2,4],[1,3])
12:06:42 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0 in partition itob [1..5]
12:06:43 <lambdabot>   ([2,4],[1,3,5])
12:06:49 <temoto> ah even
12:06:59 <temoto> that's first example in every haskell book
12:07:28 <Berengal> I wish we could have symbols in identifiers...
12:07:37 <Berengal> So we could write 'even?'
12:07:42 <rovar> that would be nice
12:07:43 <aconbere> Berengal: cool that fixed me up (also had to remove an older version of network)
12:07:49 <temoto> We can write even'
12:07:55 <Berengal> aconbere: Nice.
12:07:55 <rovar> that might be the only Ruby idiom i like
12:08:00 <Berengal> We can also write evenp
12:08:15 <rovar> how about is_even :)
12:08:15 <temoto> that's pretty much a symbol, considering that it's a quote, not math symbol.
12:08:17 <Berengal> But we would also be able to write hyphenated-identifiers-like-this
12:08:29 <rovar> too lispish
12:08:36 <Berengal> Hyphens?
12:08:41 <temoto> Berengal: i'd love hyphenated identifiers!
12:08:58 <rovar> I'm sure this has been requested,  happen to know why it was not approved?
12:09:06 <Berengal> Breaks parsing
12:09:16 <Berengal> Not sure it has been requested
12:09:32 <temoto> Obviously a-b means (-) a b
12:09:36 <Berengal> But it would require every infix operator to be specified as such
12:10:01 <Berengal> But that doesn't have to be a bad thing. We could then use characters in operators as well
12:10:05 <c_wraith> > let a +- b = a + b - b in 5 +- 7
12:10:06 <lambdabot>   5
12:10:12 * c_wraith reinvents const, yet again
12:10:36 <Berengal> > let a +- b = a + b - b in 5 +- 7 :: Natural
12:10:37 <lambdabot>   Not in scope: type constructor or class `Natural'
12:10:45 <rovar> yea.. allowing - would be challenging
12:10:51 <newsham> "Haskell is a much better Fortran than the original."  :)
12:10:53 <rovar> but ? doesn't seem so bad.
12:10:59 <temoto> No it's not challenging.
12:11:01 <Berengal> ? is also an operator
12:11:07 <c_wraith> :t (?)
12:11:08 <lambdabot> Not in scope: `?'
12:11:13 <Berengal> Well, it can be
12:11:15 <rovar> it can be
12:11:20 <temoto> It's a simple change in parser.
12:11:20 <Berengal> And there are operators that use it
12:11:33 <rovar> meh
12:11:34 <temoto> Yeah like Parsec <?>
12:11:50 <rovar> let (?) = (+)
12:11:54 <rovar> > let (?) = (+)
12:11:55 <lambdabot>   not an expression: `let (?) = (+)'
12:12:42 <c_wraith> > let a ? b = \c -> if a then b else c in True ? 1 $ 2
12:12:43 <lambdabot>   1
12:12:58 <Berengal> infix _elem?_; difference xs ys = filter (\x -> x elem? ys) xs
12:13:01 <rovar> this is annoying.. the first time I've ever *needed* code from code.haskell.org and it's down
12:13:36 <c_wraith> look how easy it is to reinvent the C's ternary op in haskell.
12:13:42 <Berengal> infix if_then_else_; if True then x else y = x; if False then x else y = y
12:13:52 <c_wraith> yes, *the* C
12:14:04 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = take 10 $ fix StdGen in randoms
12:14:05 <lambdabot>   Not in scope: data constructor `StdGen'
12:14:07 <aavogt> what about the precedences?
12:14:12 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = take 10 $ fix mkStdGen in randoms
12:14:13 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:14:13 <lambdabot>         against inferred type ...
12:14:15 <c_wraith> yeah, they could be tweaked.
12:14:22 <c_wraith> But that's easy, too
12:14:23 <temoto> > iterate mkStdGen
12:14:24 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:14:24 <lambdabot>         against inferred type ...
12:14:31 <temoto> > repeat mkStdGen
12:14:32 <lambdabot>   [{-3->4 1;-2->3 1;-1->2 1;0->1 1;1->2 1;2->3 1;3->4 1},{-3->4 1;-2->3 1;-1-...
12:14:39 <temoto> > take 5 $ repeat mkStdGen
12:14:40 <lambdabot>   [{-3->4 1;-2->3 1;-1->2 1;0->1 1;1->2 1;2->3 1;3->4 1},{-3->4 1;-2->3 1;-1-...
12:14:57 <temoto> :t iterate
12:14:58 <lambdabot> forall a. (a -> a) -> a -> [a]
12:15:15 <Berengal> > runState 25 (replicateM 10 (State mkStdGen))
12:15:16 <lambdabot>   Couldn't match expected type `(a, GHC.Types.Int)'
12:15:16 <lambdabot>         against inferred ...
12:15:18 <Saizan> > randoms (mkStdGen 42)
12:15:18 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
12:15:29 <temoto> :t replicate
12:15:30 <lambdabot> forall a. Int -> a -> [a]
12:15:56 <temoto> How is replicate forever called?
12:16:06 <Berengal> repeat
12:16:11 <temoto> :t repeat
12:16:12 <lambdabot> forall a. a -> [a]
12:16:14 <temoto> Thanks.
12:16:18 <Saizan> > runState (mkStdGen 25) (replicateM 10 (State random))
12:16:19 <lambdabot>   Couldn't match expected type `Control.Monad.State.Lazy.State s a'
12:16:19 <lambdabot>         a...
12:16:30 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = take 10 $ repeat mkStdGen in randoms
12:16:31 <lambdabot>   [{-3->4 1;-2->3 1;-1->2 1;0->1 1;1->2 1;2->3 1;3->4 1},{-3->4 1;-2->3 1;-1-...
12:16:31 <Saizan> > flip runState (mkStdGen 25) (replicateM 10 (State random))
12:16:32 <lambdabot>   ([7069828573166026159,-2009037394866345205,4789312211735310470,-16094264267...
12:16:58 <Saizan> temoto: repeat mkStdGen doesn't make sense
12:17:06 <cheater2> hey guys
12:17:24 <cheater2> does haskell allow online upgrading of modules, sorta like erlang does?
12:17:38 <Heffalump> cheater2: not trivially
12:17:46 <cheater2> gotcha
12:17:54 <Saizan> temoto: mkStdGen is used to create a StdGen, which is a seed you can use to create random values with methods from the Random class
12:18:08 <Heffalump> hs-plugins or whatever is the uptodate variant of it can do that, but it's not built-in
12:18:09 <Berengal> > fix (In . map In . map repeat . out)
12:18:10 <lambdabot>   No instance for (GHC.Show.Show (L.Mu []))
12:18:10 <lambdabot>    arising from a use of `M168240...
12:18:18 <Berengal> > out $ fix (In . map In . map repeat . out)
12:18:19 <lambdabot>   No instance for (GHC.Show.Show (L.Mu []))
12:18:19 <lambdabot>    arising from a use of `M552640...
12:18:22 <Berengal> :(
12:18:36 <jfoutz> cheater2: maybe look at dyre. http://hackage.haskell.org/package/dyre
12:18:43 <jfoutz> more of a configuration thing though.
12:18:50 <cheater2> sounds cool
12:18:51 <cheater2> will do
12:18:54 <c_wraith> :t both
12:18:55 <lambdabot> Not in scope: `both'
12:19:26 <c_wraith> :t randomR . snd
12:19:27 <lambdabot> forall a g a1. (Random a, RandomGen g) => (a1, (a, a)) -> g -> (a, g)
12:19:32 <Berengal> @let both = join (***)
12:19:33 <lambdabot>  Defined.
12:19:36 <Berengal> @type both
12:19:37 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
12:19:57 <cheater2> what is CPS useful for in haskell?
12:20:10 <Berengal> cheater2: concurrency :)
12:20:31 <Berengal> Or was that CSP?
12:20:31 <Saizan> CPS as in Continuation Passing Style?
12:20:35 <cheater2> Berengal: can you explain?
12:20:40 <cheater2> Saizan: yes
12:20:47 <Berengal> Ah, then I'm mistaken
12:21:04 <Berengal> (Though you can implement single-threaded cooperative concurrency with continuations)
12:21:08 <cheater2> oh. what did you mean Berengal?
12:21:21 <Berengal> cheater2: Communication Sequential Processes
12:21:21 <c_wraith> :t randomR (lower, upper) . snd
12:21:22 <lambdabot> Not in scope: `lower'
12:21:23 <lambdabot> Not in scope: `upper'
12:21:31 <c_wraith> :t randomR (?lower, ?upper) . snd
12:21:32 <lambdabot> forall a a1 a2. (?lower::a, ?upper::a, Random a, RandomGen a1) => (a2, a1) -> (a, a1)
12:21:36 <Berengal> Communicating*
12:21:49 <cheater2> ah ok
12:22:09 <c_wraith> :t iterate (randomR (?lower, ?upper) . snd)
12:22:10 <lambdabot> forall a a1. (?lower::a, ?upper::a, Random a, RandomGen a1) => (a, a1) -> [(a, a1)]
12:22:28 <Saizan> cheater2: well, there are many uses, it mostly boils down ti efficient implementations of some monads
12:22:59 <c_wraith> :t \g -> map fst . iterate $ randomR (?lower, ?upper) . snd
12:23:00 <lambdabot>     Couldn't match expected type `[(a, b)]'
12:23:01 <lambdabot>            against inferred type `a1 -> [a1]'
12:23:01 <lambdabot>     In the second argument of `(.)', namely `iterate'
12:23:18 <cheater2> Saizan: can you give me an example?
12:23:19 <c_wraith> :t \g -> map fst . iterate (randomR (?lower, ?upper) . snd)
12:23:20 <lambdabot> forall t a b. (?lower::a, ?upper::a, Random a, RandomGen b) => t -> (a, b) -> [a]
12:23:28 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = take 10 $ map (fst $ Random.next mkStdGen) [1..] random in randoms
12:23:29 <lambdabot>   Not in scope: `Random.next'
12:23:36 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = take 10 $ map (fst $ next mkStdGen) [1..] random in randoms
12:23:37 <c_wraith> :t \g -> map fst . iterate (randomR (?lower, ?upper) . snd) $ g
12:23:37 <lambdabot>   Couldn't match expected type `a -> b'
12:23:37 <lambdabot>         against inferred type `GHC.Ty...
12:23:38 <lambdabot> forall a b. (?lower::a, ?upper::a, Random a, RandomGen b) => (a, b) -> [a]
12:23:53 <c_wraith> :t \g -> map fst . iterate (randomR (?lower, ?upper) . snd) g
12:23:54 <lambdabot>     Couldn't match expected type `[(a, b)]'
12:23:54 <lambdabot>            against inferred type `(a1, a2)'
12:23:54 <lambdabot>     In the first argument of `(.)', namely `randomR (?lower, ?upper)'
12:23:54 <jaspervdj> @src mapM
12:23:55 <lambdabot> mapM f as = sequence (map f as)
12:24:03 <c_wraith> I suck at thinking today, clearly
12:24:12 <temoto> :t next
12:24:13 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
12:24:27 <temoto> :t fst
12:24:28 <lambdabot> forall a b. (a, b) -> a
12:24:56 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = take 10 $ map (fst $ next $ mkStdGen) [1..] random in randoms
12:24:57 <lambdabot>   Couldn't match expected type `a -> b'
12:24:57 <lambdabot>         against inferred type `GHC.Ty...
12:25:11 <temoto> > fst $ next $ mkStdGen 1
12:25:12 <lambdabot>   39336
12:25:16 <temoto> > fst $ next $ mkStdGen $ 2
12:25:17 <lambdabot>   79350
12:25:50 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = take 10 (map (fst $ next $ mkStdGen) [1..]) random in randoms
12:25:50 <lambdabot>   Couldn't match expected type `a1 -> a'
12:25:51 <lambdabot>         against inferred type `GHC.T...
12:26:14 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = map (fst $ next $ mkStdGen) [1..10] random in randoms
12:26:15 <lambdabot>   Couldn't match expected type `a -> b'
12:26:15 <lambdabot>         against inferred type `GHC.Ty...
12:26:25 <Saizan> cheater2: look at the implementation of the LogicT package, it implements a monad for backtracking with failure and success continuations
12:26:26 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = map (fst $ next $ mkStdGen) [1..10] in randoms
12:26:27 <lambdabot>   Couldn't match expected type `a -> b'
12:26:27 <lambdabot>         against inferred type `GHC.Ty...
12:26:47 <cheater2> Saizan: i know cps is good for backtracking
12:27:13 <c_wraith> hmm.  There's no way to ask for an inhabitant of an arbitrary type.
12:27:19 <c_wraith> Oh, wait.  I could use use undefined
12:27:23 <Berengal> > evalState (replicateM 10 (State next)) (mkStdGen 42)
12:27:24 <lambdabot>   [1679910,620339110,2104174556,2010543953,769061955,1658303630,107494357,197...
12:27:49 <Saizan> cheater2: another thing for which you can use CPS is cooperative coroutines
12:28:04 <temoto> > let r = fst $ next $ mkStdGen in [r 1, r 2]
12:28:05 <lambdabot>   Couldn't match expected type `t1 -> t'
12:28:05 <lambdabot>         against inferred type `GHC.T...
12:28:06 <cheater2> yeah. how does that work?
12:28:09 <jfoutz> i thought resumable parsing was a super cool use of continuations.
12:28:29 <temoto> > let r = fst . next . mkStdGen in [r 1, r 2]
12:28:30 <lambdabot>   [39336,79350]
12:28:41 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = map (fst . next . mkStdGen) [1..10] in randoms
12:28:42 <lambdabot>   [39336,79350,119364,159378,199392,239406,279420,319434,359448,399462]
12:28:50 <cheater2> Saizan: just yield the continuation from one coroutine to the scheduler and then go back to the other coroutine by invoking its continuation?
12:29:01 <Berengal> cheater2: I like to think of it like this: goto ~ set instruction pointer, setjmp/longjmp ~ set instruction pointer + set stack pointer, continuations ~ set instruction pointer + set stack pointer + set stack
12:29:03 <temoto> jfoutz: yeah like web multipage forms in a single do statement.
12:29:17 <temoto> that's well.. sort of parsing of user input
12:29:45 <cheater2> Berengal: i don't mean what you mean by 'set stack'
12:29:59 <cheater2> oh
12:30:07 <cheater2> Berengal: continuations don't have separate stacks
12:30:15 <cheater2> Berengal: they use a spaghetti stack
12:30:34 <jfoutz> temoto: yeah. i was surprised to learn you can take an arbitrary monadic function and make it incremental.
12:30:53 <Berengal> cheater2: Or closures. The exact implementation may vary
12:31:11 <Berengal> cheater2: The point is, they can travel in time. goto and setjmp/longjmp can't.
12:31:58 <cheater2> Berengal: yeah
12:32:10 <c_wraith> > let chain f x = map fst . iterate (f . snd) $ (undefined, x) in chain (randomR (1, 100) (mkStdGen 63)
12:32:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:32:21 <c_wraith> > let chain f x = map fst . iterate (f . snd) $ (undefined, x) in chain (randomR (1, 100)) (mkStdGen 63)
12:32:22 <lambdabot>   [* Exception: Prelude.undefined
12:32:27 <c_wraith> bah
12:32:37 <c_wraith> > let chain f x = tail . map fst . iterate (f . snd) $ (undefined, x) in chain (randomR (1, 100)) (mkStdGen 63)
12:32:38 <lambdabot>   [66,43,1,9,94,32,38,45,27,70,81,95,68,7,49,94,67,81,26,59,86,69,83,29,9,45,...
12:33:03 <ukl> I'm a bit confused about Map, IntMap and Array.  Given I've got type Vertex = Int, what's the difference between "Array Vertex Vertex" and "Map Vertex Vertex"?  How could I use IntMap when I'm not taking the Int's to be Int's but treat them as of type Vertex?
12:33:33 <Berengal> c_wraith: What are you trying to do? Specialize repeatM on State?
12:33:38 <Saizan> ukl: you'd just use IntMap Vertex
12:33:45 <aavogt> type Vertex = Int  means you can call Ints Vertex
12:33:50 <Saizan> ukl: type just defines an alias, not a different type
12:34:06 <c_wraith> Berengal: specialize unfoldR to non-terminating lists
12:34:11 <c_wraith> err, unfoldr
12:34:13 <dolio> Arrays are linear blocks of memory, and Maps are trees.
12:34:34 <dolio> So lookup on Arrays is somewhat better asymptotically, while updates of Maps are better.
12:35:02 <ukl> Saizan, aavogt, dolio: thanks, I knew asking here would save me quite some time :)
12:35:10 <c_wraith> Which just happens to work nicely with things that use RandomGen properly
12:35:31 <dolio> Although the specific performance may be different in practice (although updating pure Arrays is a pretty bad idea in general).
12:35:37 <c_wraith> > let chain f x = tail . map fst . iterate (f . snd) $ (undefined, x) in chain (randomR ('a', 'z')) (mkStdGen 63)
12:35:38 <lambdabot>   "niacpvjwkpiyhyadwgpmfkccumlqwztlyfzklzwoqeeplkalaxeeibpvdpdtyxkqvuelsdktdx...
12:36:31 <EvilMachine> hey, it seems code.haskell.org is down. anyone here who can do something about that? or tell me who to contact? :) thank you!
12:36:36 <MissPiggy> > let chain f x = tail . map (\x -> if x == 'w' then ' ' else x) . map fst . iterate (f . snd) $ (undefined, x) in chain (randomR ('a', 'w')) (mkStdGen 63)
12:36:37 <lambdabot>   "nmucdd mtkkcuhdm p eio judftvfmtikmgudjteuercla kvldiintujuo blpoflfkvubrh...
12:37:08 <hatds> if you only need the "insert" operation for arrays, using immutable arrays isn't much worse than a C++ ish vector
12:37:34 <DekuNut> I'm curious, pure (in Applicative) looks identical to return (in Monad), other than the fact that they're there to provide for different type classes, is there any major difference between the two?
12:38:04 <mle> MissPiggy: etaoinshrdlu
12:38:06 <aavogt> DekuNut: they should be the same function
12:38:09 <MissPiggy> :p
12:38:13 <aavogt> library defect
12:38:15 <DekuNut> aavogt, good, just wanted to be sure
12:38:22 <DekuNut> Thanks
12:39:34 <Berengal> > let chain f x = tail . map fst . iterate (f . snd) $ (undefined, x) in foldl' (\m x -> M.insertWith (+) x 1 m) M.empty . take (10^5) . chain (randomR (1, 10)) $ (mkStdGen 63)
12:39:35 <lambdabot>   fromList [(1,10085),(2,10147),(3,9878),(4,9881),(5,9848),(6,10019),(7,10026...
12:46:27 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = map (fst . next . mkStdGen) [1..10] in map (a, atom a (even a)) randoms
12:46:28 <lambdabot>   Couldn't match expected type `a -> b'
12:46:29 <lambdabot>         against inferred type `(Simpl...
12:47:31 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = map (fst . next . mkStdGen) [1..10] in map (\a -> (a, atom a (even a))) randoms
12:47:32 <lambdabot>   [(39336,Just 39336),(79350,Just 79350),(119364,Just 119364),(159378,Just 15...
12:47:41 <temoto> haha
12:47:49 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = map (fst . next . mkStdGen) [1..10] in map (\a -> (atom a (even a))) randoms
12:47:50 <lambdabot>   [Just 39336,Just 79350,Just 119364,Just 159378,Just 199392,Just 239406,Just...
12:49:17 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = map (fst . next . mkStdGen) [111..120] in randoms
12:49:18 <lambdabot>   [4440876,4480890,4520904,4560918,4600932,4640946,4680960,4720974,4760988,48...
12:49:28 <temoto> all numbers are even
12:52:22 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = map (((/)10). fst . next . mkStdGen) [111..120] in randoms
12:52:23 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
12:52:23 <lambdabot>    arising from a use o...
12:52:57 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = map ((`div`10). fst . next . mkStdGen) [111..120] in randoms
12:52:58 <lambdabot>   [444087,448089,452090,456091,460093,464094,468096,472097,476098,480100]
12:53:33 <temoto> > let atom a b = if b then Just a else Nothing; itob n = n `mod` 2 == 0; randoms = map ((`div`14) . fst . next . mkStdGen) [1..10] in map (\a -> (atom a (even a))) randoms
12:53:34 <lambdabot>   [Nothing,Nothing,Just 8526,Just 11384,Just 14242,Just 17100,Just 19958,Just...
12:55:32 <aledge> hey guise
12:57:53 <temoto> c_wraith: here's your spoon
13:01:49 <mreh> can parsec parse haskell?
13:02:03 <mreh> without me writing a parser
13:02:14 <benmachine> that's an odd question
13:02:24 <benmachine> do you mean, is there a haskell parser written in parsec somewhere?
13:02:33 <mreh> benmachine: yes
13:02:48 <benmachine> I don't know, but I know of haskell parsers written in haskell
13:02:57 <benmachine> (I mean parsers, not GHC)
13:03:00 <mreh> i only want to parse some simple data structures really, i'll just write it out by hand
13:03:15 <benmachine> I used haskell-src-exts
13:03:32 <Heffalump> if you just want to parse Haskell datatype values, read should work
13:08:41 <copumpkin> preflex: seen HaskellLove
13:08:42 -preflex(n=preflex@95-88-118-220-dynip.superkabel.de)- HaskellLove was last seen on #haskell-in-depth 4 days, 7 hours, 25 minutes and 59 seconds ago, saying: ok enough theory for today time to do something practical
13:09:03 <EvilMachine> anybody? whats going on with code.haskell.org? the repository is down. :(
13:10:12 <burp> enough projecteuler :D
13:13:19 <prxq> hi
13:24:02 <mreh> how do I do an "If this is parsed return this value, else return this" (a simple bool would do) in Parsec
13:24:28 <mreh> I'd still like it to succeed if it fails to parse anything
13:24:45 <Twey> (try someParser >> return True) <|> return False
13:25:04 <Twey> If I remember my Parsec-foo
13:25:27 <mreh> foo is now a noun?
13:25:41 <mreh> I thought it was a meta-syntactic variable
13:25:42 <hiredman> fu is the noun
13:25:48 <Saizan> i guess that was supposed to be fu
13:25:55 <mreh> @wn fu
13:25:56 <lambdabot> No match for "fu".
13:26:08 <hiredman> it's chinese or something
13:26:09 <Saizan> as in kung-fu
13:26:15 <mreh> can we have @urban-dictionary
13:26:22 <mreh> @ud fu
13:26:22 <lambdabot>  fu
13:26:23 <stroan> anyone know any texts or papers on compiling functional langauges?
13:26:43 <mreh> Chinese for what?
13:26:43 <Saizan> stroan: there's a whole book from spj freely available
13:27:08 <xerox> Fu (Technology, especially computer related) (used as a suffix) - relating to a person - Possessing superior skills in an art; relating to an artifact - representing an expression of high art. code-fu, Perl-fu, C-fu, etc.
13:27:17 <jfoutz> @jargon fu
13:27:18 <lambdabot> *** "-fu" jargon "Jargon File (4.3.1, 29 Jun 2001)"
13:27:18 <lambdabot> -fu [common; generalized from `kung-fu'] Combining form denoting expert
13:27:18 <lambdabot>    practice of a skill. "That's going to take some serious code-fu." First
13:27:18 <lambdabot>    sighted in connection with the GIMP's remote-scripting facility,
13:27:18 <lambdabot>    script-fu, in 1998.
13:27:20 <lambdabot>  
13:27:33 <stroan> aye, focuses a lot of the lazy language they are building, was kind of hoping that there is a similar one targetted at a strict language
13:27:37 <mreh> heh
13:28:22 <Twey> It's often spelt -foo nowadays
13:28:33 <Twey> Not sure if that's an intentional pun or just a misanalysis
13:28:46 <Lemmih> stroan: Compiling a strict functional langauge is pretty similar to compiling any traditional language, no?
13:29:08 <stroan> I am very ignorant of these matters tbh
13:29:19 <stroan> if it is, then excellent and I'll grab a conventional text :)
13:30:16 <Lemmih> stroan: Perhaps you should read about how to implement specific features, such as closures or automatic memory management.
13:30:25 <stroan> but I was reading a very good presentation on dealing with currying in a strict language last night, and it seems that a book on compiling imperative languages isn't going to deal overly well with those kind of issues
13:30:36 <temoto> stroan: if, by 'functional' you mean lambda calculus powered, then lazyness is enforces kinda by the model of evaluation.
13:30:41 <erikc> is there a specific area of interest? parsing? high level optimization? machine-level optimization? machine mapping of language constructs? runtimes?
13:30:54 <temoto> stroan: if not, i don't know what a functional language means.
13:30:57 <solrize> stroan :
13:30:59 <solrize> @where rwh
13:30:59 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:31:02 <solrize> whoops
13:31:05 <solrize> @where pfpl
13:31:05 <lambdabot> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
13:31:10 <solrize> look at pfpl
13:31:13 <benmachine> I think functional languages both require and allow more intelligence on the part of the compiler
13:31:36 <copumpkin> they only require it if you want them to be fast
13:31:36 <Saizan> temoto: call-by-value evaluation of lambda calculus is well known, and gives you a strict language
13:31:36 <quicksilver> benmachine: and the programmer too, amusingly ;)
13:31:43 <stroan> solrize: cheers
13:31:44 <benmachine> :D
13:31:55 <temoto> Saizan: do you mean Lisp?
13:32:21 <jfoutz> solrize: that book looks awesome
13:32:53 <Saizan> temoto: that can be one example
13:32:57 <solrize> jfoutz, yeah it's good
13:33:05 <temoto> Okay.
13:33:44 <temoto> I think at least partial (controlled, say, by special keyword) lazyness is required.
13:34:27 <solrize> temoto, lazy evaluation was traditionally done in scheme with explicit closures
13:35:11 <solrize> ocaml has some kind of laziness annotation but i don't know if it does something mroe than make closures, i.e. graph reduction which is a fairly complex algo
13:35:56 <stroan> solrize: that book looks really interesting
13:37:10 <quicksilver> solrize: http://pauillac.inria.fr/ocaml/htmlman/libref/Lazy.html
13:37:18 <solrize> yeah you should also read SICP if you haven't
13:37:23 <solrize> stroan
13:37:25 <stroan> that I've read
13:37:26 <quicksilver> solrize: not exactly an annotation, but a special primitive you couldn't define on your own, exactly.
13:37:27 <solrize> Quadrescence, thanks
13:37:47 <quicksilver> although I don't think it's substnatially different from fn () =>
13:37:47 <solrize> oops i meant quicksilver not Quadrescence
13:37:57 <mreh> is there a way to adapt "read" into a parser
13:38:15 <xerox> :t reads
13:38:16 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:38:30 <mreh> a Parsec parser that is
13:38:38 <xerox> probably better suited
13:39:41 <temoto> erikc: i'm particulary interested in evaluating user defined operators, as in haskell. What's about user defined operators is that i can't use Parsec buildExpressionParser because i don't know all operators in front.
13:40:15 <temoto> so i can't know their associatiivity and order
13:41:15 <c_wraith> temoto: I think haskell parsers deal with that by making two passes.  One looks at fixity declarations and indentation, the other parses given those fixity declarations and the block data
13:41:25 <temoto> Although, enforcing all user operators to some predefined associativity and order is an interesting simplification.
13:42:39 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
13:42:39 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
13:42:45 <Cale> Actually, what happens is the initial parse ignores matters of associativity of operators, and then any fixity declarations are used to repair the resulting tree.
13:43:15 <Cale> Whitespace is a completely separate pass.
13:43:43 <Cale> But for instance, in GHC, you're allowed to have fixity declarations inside of a let, so they have local scope.
13:44:09 <mreh> > ['A'..'G']
13:44:10 <lambdabot>   "ABCDEFG"
13:44:11 <Cale> So it's not *quite* enough to completely separate them off.
13:44:25 <Cale> > ['H'..'P']
13:44:26 <lambdabot>   "HIJKLMNOP"
13:44:35 <c_wraith> ah, I see
13:44:39 <hatds> the parse-error rule though makes lexing and parsing not so separate even if you deal with fixities after the fact
13:45:31 <c_wraith> the whitespace pass is essentially conversion to {;} form instead of using whitespace?
13:45:40 <hatds> yes
13:45:43 <benmachine> Cale: btw did you have any comment on the step evaluator I showed you? it's not important but I'm idly wondering what to do with it next
13:46:02 <c_wraith> ah.  thanks for the info, cale, hatds
13:46:47 <temoto> Cale: i got a parser which produces this tree: Infix "a" "+" (Infix "b" "+" "c"). How to fix it?
13:49:16 <bscanzoni> Can someone show me the shortest way to express [[f x y | y <- b] | x <- a] w/o list comprehensions please?
13:50:02 <benmachine> > liftM2 f [a,b,c] [x,y,z] :: [Expr]
13:50:02 <lambdabot>   [f a x,f a y,f a z,f b x,f b y,f b z,f c x,f c y,f c z]
13:50:03 <MissPiggy> flip f <$> y <*> x
13:50:08 <benmachine> is that what you wanted?
13:50:18 <MissPiggy> maybe even (|(flip f) y x|) wish She
13:50:45 <bscanzoni> im sure it is, you guys just gave me a bunch to learn from
13:50:46 <bscanzoni> thanks
13:51:07 <benmachine> wait no you actually have nested lists
13:51:10 <MissPiggy> benmachine: why don't you add delimited continuations (shift/reset)
13:51:22 <benmachine> MissPiggy: what
13:51:25 <MissPiggy> oops, benmachine is right
13:51:53 <MissPiggy> sorry what I said is completely wrong
13:52:08 <MissPiggy> benmachine: re 'idly wondering what to do with it next'
13:52:16 <bscanzoni> k I will prob still mess with the expressions anyway ;)
13:52:23 <bscanzoni> but what is the right expression(s)?
13:52:32 <benmachine> bscanzoni: if you want nested lists, I guess it's two maps
13:52:47 <benmachine> would have to think a bit longer about which way round to put them though
13:53:05 <bscanzoni> let f = flip map (cols b) \n	map f a
13:53:06 <benmachine> MissPiggy: I don't know what delimited continuations are
13:53:15 <bscanzoni> I tried that
13:53:15 <Cale> benmachine: I suppose keep adding more features from Haskell into it, in whatever order you see fit. I think it's a cool project. At some point, a gui might be nice.
13:53:39 <bscanzoni> (the \n is a line, looks stupid actually)
13:54:11 <temoto> mapr?
13:54:14 <benmachine> Cale: okay
13:54:20 <benmachine> thanks
13:55:46 <Cale> benmachine: I actually need to play around with it some more. I downloaded it and poked through the source, but I was distracted the other day. I'm just building haskell-src-exts now :)
13:56:09 <benmachine> Cale: I may have fixed one or two bugs since you saw it last
13:56:10 <mreh> what's the Class for something Parseable? I want to make a generic Parser
13:56:25 <mreh> Parseable a => Parser a
13:56:44 <mreh> that's not right is it
13:57:10 <Cale> maybe   class Parseable a where parse :: Parser a
13:57:10 <Cale> ?
13:57:21 <Berengal> ContT Foo (forall s. ST s) is evading me :/
13:57:30 <Berengal> @kind ContT Int (forall s. ST s)
13:57:31 <lambdabot>     `ST s' is not applied to enough type arguments
13:57:31 <lambdabot>     Expected kind `*', but `ST s' has kind `* -> *'
13:57:31 <lambdabot>     In the type `forall s. ST s'
13:57:36 <Cale> Or perhaps you'd just like to borrow the instance of Read somehow?
13:58:10 <Cale> @kind ContT Int (ST s)
13:58:11 <lambdabot> Not in scope: type variable `s'
13:58:17 <Cale> @kind forall s. ContT Int (ST s)
13:58:18 <lambdabot>     `ContT Int (ST s)' is not applied to enough type arguments
13:58:18 <lambdabot>     Expected kind `*', but `ContT Int (ST s)' has kind `* -> *'
13:58:25 <Cale> er
13:58:42 <Cale> @kind ContT
13:58:43 <lambdabot> * -> (* -> *) -> * -> *
13:58:46 <Cale> @kind ContT Int
13:58:47 <lambdabot> (* -> *) -> * -> *
13:58:52 <Cale> @kind ST
13:58:53 <lambdabot> * -> * -> *
13:58:56 <Cale> @kind ST s
13:58:57 <lambdabot> Not in scope: type variable `s'
13:59:00 <Cale> right.
13:59:04 <Berengal> @kind forall a. (forall s. ContT Int (ST s) a)
13:59:05 <lambdabot> *
13:59:07 <Berengal> hah!
13:59:32 <Berengal> It seems you can't partially apply when universal quantification is in play
13:59:35 <Cale> Mildly annoying that @kind requires you to explicitly quantify
13:59:39 <aaronp> I'm trying to build a binary that I can run on random machines, and GHC is producing dependences on a "libffi.so.5" library...  is there a way of making GHC statically link in that library?
13:59:58 <Berengal> Cale: Not just @kind, but in type signatures as well
14:00:00 <temoto> mreh: How Parser is not generic?
14:00:21 <Berengal> @type undefined :: ContT Int (forall s. ST s) a
14:00:22 <lambdabot>     `ST s' is not applied to enough type arguments
14:00:22 <lambdabot>     Expected kind `*', but `ST s' has kind `* -> *'
14:00:22 <lambdabot>     In the type `forall s. ST s'
14:00:29 <Berengal> @type undefined :: forall a. ContT Int (forall s. ST s) a
14:00:30 <lambdabot>     `ST s' is not applied to enough type arguments
14:00:30 <lambdabot>     Expected kind `*', but `ST s' has kind `* -> *'
14:00:30 <lambdabot>     In the type `forall s. ST s'
14:00:36 <thoughtpolice> aaronp: pass the '-static' flag
14:00:48 <Berengal> @type undefined :: forall a. (forall s. ContT Int (ST s) a)
14:00:48 <thoughtpolice> aaronp: and it should build an executable that is just an elf with no outside dependencies, i think
14:00:49 <lambdabot> forall s a. ContT Int (ST s) a
14:01:06 <Berengal> But this allows s to escape :(
14:01:10 <thoughtpolice> aaronp: oh, you probably actually want to pass '-static -optl-static' to pass the flag to the linker to do a static link as well
14:01:23 <Cale> benmachine: Oh, what is foldrWithKey?
14:01:29 <benmachine> Cale: http://www.srcf.ucam.org/~bm380/stepeval.tar.gz very minorly updated
14:01:52 <Cale> oh, that's new in 6.12, I guess.
14:01:53 <benmachine> the updated version doesn't seem to have foldrWithKey, heh
14:02:17 <mreh> temoto: I want to return a generic type, like [a]
14:02:30 <benmachine> oh, yeah I am on 6.12
14:03:00 <Cale> Er, the version in that tarball uses foldrWithKey
14:03:05 <benmachine> oh, does it?
14:03:13 <Cale> In shedBinds
14:03:36 <benmachine> filterWithKey?
14:03:44 <Cale> shedBinds :: Exp -> Env -> Env
14:03:44 <Cale> shedBinds e v = foldrWithKey insertUsed Map.empty v
14:03:55 <Cale> errr
14:03:59 <Cale> oh, nevermind me
14:04:07 <benmachine> heh
14:04:20 <Cale> That was still the old one
14:04:25 <temoto> mreh: well how do you use it then?
14:05:03 <temoto> mreh: getLine is a parser of user input, it returns strictly /IO /String so you know you can apply string stuff.
14:05:06 <mreh> temoto: to parse a list of items that are written with a specific syntax
14:05:46 <mreh> a list of some type
14:06:05 <temoto> But that's already possible with Parser [a]
14:06:35 <temoto> since Parser is a parametrized type.
14:07:17 <aaronp> thoughtpolice: Thanks.  That makes it fail with a bunch of undefined references to things like pthread_create and __register_frame_info_bases.  Is there a way to do the equivalent of "-Bstatic -lffi -Bdynamic"?
14:07:34 <benmachine> Cale: there's also a .ghci included which defines a shortcut for parsing expressions, if you want to test it interactively
14:07:55 <DekuNut> Would someone be able to explain to me the kind of (<-), it's a little confusing
14:07:58 <DekuNut> :k (<-)
14:07:59 <lambdabot> parse error on input `<-'
14:08:04 <DekuNut> Er sorry
14:08:08 <DekuNut> :k (->)
14:08:09 <lambdabot> ?? -> ? -> *
14:08:18 <Cale> DekuNut: ?? and ? have to do with unboxed types
14:08:34 <Cale> DekuNut: You can read them as * if you don't care about that low-level stuff
14:08:39 <DekuNut> I guess I'll have to read about boxed and unboxed types before I get it
14:08:44 <DekuNut> Nah I care, I'll google it
14:08:52 <copumpkin> where can I find good coverage of the category of relations (I saw a note that equijoin is a fibre product but didn't find much more information)?
14:08:53 <DekuNut> Thanks Cale
14:09:30 <MissPiggy> umm makes me think of allegories?
14:09:41 <Cale> benmachine: hmm... it doesn't seem to evaluate cases?
14:09:50 <benmachine> Cale: what did you try?
14:09:55 <Cale> case 1 : [] of [] -> 0; (x:xs) -> x
14:10:01 <aaronp> thoughtpolice: Okay, I got it to work by using --make -v, then manually running collect2 with the same arguments but -Bstatic/-Bdynamic around -lffi.  I guess that will work for a short-term solution.
14:11:01 <Cale> benmachine: The moment that the scrutinee matches one of the patterns, it should match the pattern, and continue with the RHS of that pattern.
14:11:14 <benmachine> Cale: I'm surprised that doesn't work
14:11:19 <temoto> Certain solutions require some untrivial skill.
14:11:38 <benmachine> it might be that I broke that recently
14:11:41 * benmachine experiments
14:12:50 <benmachine> Cale: looks like I broke something
14:13:06 <Cale> When the evaluation stops like that, does it mean that stepeval produced NoEval?
14:13:20 <benmachine> I think it means anything other than Eval e
14:13:29 <benmachine> but yes it produces NoEval
14:13:45 <benmachine> one sec, this is probably something silly
14:14:00 <benmachine> yeah, it's silly
14:14:23 <benmachine> for some reason I am demanding further evaluation when trying to match any non-[] value against []
14:14:31 <Cale> ah
14:14:32 <benmachine> even if it obviously isn't ever going to be []
14:14:40 <benmachine> this was working in the original I gave you :P
14:15:07 <benmachine> hmm
14:15:34 <DekuNut> Cale, I'm having a little trouble finding information about the kind of boxed types, for example, if (->) is ?? -> ? -> *, and boxed types are for example Int#
14:15:42 <DekuNut> Then what happens here, the compiler automatically unboxes a type?
14:15:57 <Cale> uh, Int# is an unboxed type
14:16:21 <DekuNut> Sorry mixed that up
14:16:30 <DekuNut> I meant, unboxed types are for example Int#
14:16:46 <benmachine> Cale: if you switch the order of your case branches, it'll work >_>
14:16:49 <Cale> * means any boxed type
14:16:51 <benmachine> or I hope so
14:16:58 <Cale> # means a definitely unboxed type
14:16:58 <DekuNut> Cale yeah I know don't worry I just mixed it up
14:16:59 <lunabot>  luna: parse error on input `type'
14:17:04 <Cale> (#) means an unboxed tuple type
14:17:06 <stoop> What's stepeval?
14:17:12 <Cale> ?? means either * or #
14:17:12 <lambdabot>  means either * or #
14:17:22 <benmachine> stoop: a thing I am working on to step you through the evaluation of a haskell expression
14:17:24 <Cale>  ? means any type at all
14:17:31 <stoop> benmachine, ohh, very nice.
14:17:47 <benmachine> it is currently not very complete :P
14:17:50 <DekuNut> Cale, if ?? is * and #, and ? is any type, that means (#) is a type of its own?
14:17:54 <stoop> benmachine, I didn't read the buffer carefully, but is it broken with 6.12?
14:17:56 <Cale> benmachine: It got most of the way through the evaluation of foldr (+) 0 [1,2,3], and then fell down there :)
14:18:07 <benmachine> stoop: no
14:18:20 <benmachine> stoop: a prior version was broken with 6.10; the latest version is just plain broken
14:18:28 <DekuNut> Cale, sorry I'm forcing you to think of two things in one go, I'll let you finish with benmachine first if you don't mind helping me after :o
14:18:35 <benmachine> heh
14:18:35 <Cale> DekuNut: there was a tree diagram...
14:18:38 <stoop> benmachine, ok
14:18:39 <Cale> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
14:18:42 <Cale> ^^ there it is :)
14:19:01 <Cale> (scroll down a bit until you find the tree explaining the subkinding)
14:19:05 <DekuNut> Yeah found it
14:19:06 <DekuNut> Thank you
14:19:42 <Adamant> Cale: thought Haskell didn't do subtypes. it can do subkinds?
14:19:54 <benmachine> Cale: this actually might require a small amount of program restructuring to fix properly
14:20:04 <DekuNut> Interesting, very silly question then but, does that mean that -> can't take unboxed typles as a first 'argument' ?
14:20:10 <c_wraith> yep
14:20:14 <benmachine> Cale: but it should be fixed for most simple cases if you just make pattern matching [] against anything that is not [] always fail
14:20:20 <Cale> Adamant: a little bit of subkinding -- there are only 5 kinds in which various value-containing types reside, and there's a subkinding relation on them
14:20:25 <DekuNut> As in, hypothetically, you can do f :: # -> (#)    but not f :: (#) -> #
14:20:31 <Adamant> ah
14:20:33 <Adamant> alright
14:20:44 <DekuNut> c_wraith, is there any reason for that?
14:20:48 <c_wraith> unboxed tuples can only be return values, meaning the only thing you can do with them usefully is unpack them.
14:20:49 <benmachine> Cale: I think that would only break the case where you had let x = [] in ...
14:20:50 <Cale> DekuNut: yeah, where # and (#) represent types of those kinds respectively
14:20:53 <benmachine> I *think*
14:21:09 <benmachine> but I'm going to fix it properly by giving the thing a proper notion of whnf and that sort of thing
14:21:29 <benmachine> but... not tonight :P
14:22:05 <DekuNut> Interesting... one final question then and I'll stop pestering
14:22:11 <Cale> benmachine: How do you write (x:xs) in analogy with (List [])
14:22:27 <DekuNut> What exactly is the -> in kinds then, if (->) has a kind, the -> has to mean something else in kinds or it would be a never ending recursive thing
14:22:55 <Cale> DekuNut: It would have a "sort", I guess :)
14:23:15 <benmachine> x:xs parses to something messy
14:23:17 <DekuNut> I have no idea what that is rofl
14:23:36 <benmachine> InfixApp (Var (UnQual (Ident "x"))) (QConOp (Special Cons)) (Var (UnQual (Ident "xs")))
14:23:37 <mreh> what's wrong with this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16450#a16450
14:23:54 <Cale> DekuNut: Well, apart from the unboxed stuff, kinds are already just a glorified syntax check
14:24:23 <benmachine> mreh: at a guess, it's to do with using ; but not {}
14:24:24 <Cale> DekuNut: You could use another level of typing to give the components of kinds their own sort of types.
14:24:39 <Cale> benmachine: okay
14:24:43 <DekuNut> I imagine that would get immensely confusing though
14:24:48 <DekuNut> Has to be a cutoff poitn somewhere
14:24:48 <benmachine> mreh: noting that the ; is at a lower indentation level than the first statement of the do
14:24:55 <byorgey> DekuNut: not necessarily =)
14:25:14 <Cale> benmachine: That's a bit annoying in that infix applications look different
14:25:14 <byorgey> DekuNut: there are many reasonable systems with a countably infinite hierarchy of sorts
14:25:26 <DekuNut> Oh?
14:25:35 <benmachine> Cale: yeah, a little
14:25:39 <byorgey> for example, Coq has this
14:25:40 <Cale> benmachine: But I suppose we do want to preserve that
14:26:04 <byorgey> Agda does too, IIRC
14:26:13 <byorgey> and Omega
14:26:15 <DekuNut> Interesting
14:26:22 <DekuNut> I'll read into it
14:26:43 <Cale> patternMatch (PList []) (InfixApp u (QConOp (Special Cons)) v) = NoMatch
14:26:44 <DekuNut> Thanks again, this is definately the most helpful channel I've been in
14:26:49 <Cale> benmachine: ^^ fixed using that line
14:27:11 <benmachine> Cale: oh, that does make sense
14:27:19 <benmachine> and is much simpler than I realised it was going to be
14:27:24 <benmachine> err
14:27:30 <benmachine> much simpler than I thought it was going to be
14:28:06 <benmachine> I forgot that we're kind of assuming the code already typechecks
14:28:24 * Cale wonders why input line buffering is off...
14:29:08 <benmachine> I didn't disable input line buffering, but I did flush stdout quite a lot
14:30:09 <Cale> let foldr = ...  in (+) 1 (foldr (+) 0 [2, 3])
14:30:15 <Cale> now we get this far before stopping
14:30:18 <Cale> which is pretty good
14:30:26 <Cale> I guess it doesn't know about (+)
14:30:38 <benmachine> it doesn't have an implementation of it no
14:30:56 <benmachine> I guess that'd be a good thing to add
14:31:49 <Cale> There are also funny cases where it doesn't wrap the lambdas in parens even though it should.
14:31:57 <Cale> I'm not sure how hard that is to fix though
14:32:02 <benmachine> yeah, I have a patch for haskell-src-exts that should fix that
14:32:20 <benmachine> or I can try to wrap everything in Paren all the time
14:32:37 <benmachine> but I think letting the prettyprinter worry about that is easier
14:32:40 <Cale> Seems like fixing haskell-src-exts is the better way.
14:33:36 <benmachine> I think so, but it's debateable depending on what you expect of the prettyprinter
14:34:13 <Cale> I think the prettyprinter should as much as possible try to generate syntactically valid Haskell code.
14:34:33 <benmachine> mm
14:34:59 <Cale> If you have a function application in the tree, and the thing on the left is a lambda, it really needs to be in parens.
14:42:57 <opqdonut> i'm seeing a lot of ARR_WORDS in my -hy profile output
14:43:40 <opqdonut> seems it's because of arrays constructed with listArray...
14:44:43 <opqdonut> sigh, guess I'll try an IntMap
14:46:09 <opqdonut> anyone know whether uvector or storable vector store Bools as effectively as the standard UArray ?
14:46:25 <opdolio> Wasn't someone saying yesterday that people don't write monad tutorials anymore? There's one at the top of the haskell reddit now.
14:46:40 <jmcarthur> that's an unmonad tutorial, dummy
14:46:44 <opdolio> I believe uvector should.
14:47:05 <opdolio> I don't care what he calls it. It's a monad tutorial.
14:47:48 <dolio> That's what people do these days. They say, "I'm not going to write a tutorial on monads," and then they write one.
14:48:15 <lispy> http://downforeveryoneorjustme.com/planet.haskell.org
14:48:21 <lispy> Looks like Planet Haskell is down
14:48:24 <benmachine> I considered writing something a bit monad-tutorially
14:48:35 <benmachine> but luckily I haven't had time yet
14:48:50 <dolio> It must be a coordinated attack by F# people.
14:48:58 <dolio> I heard trac was down, too.
14:49:00 <lispy> We should write tutorials on applicative
14:49:10 <dolio> And code.haskell.org.
14:49:21 <lispy> Hmmm
14:49:28 <dolio> Maybe some of those are the same machine.
14:50:04 <aavogt> hi, would somebody be interested in helping me with a template haskell problem? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16452#a16452
14:50:38 <dolio> That's some nice highlighting.
14:50:53 <aavogt> oh, I guess this would be easier with TupleT
14:51:20 <aavogt> yeah, getting the name of a variable 'xyz is ignored
14:51:51 <lispy> There, I updated it to fix the highlighting issue :)
14:53:15 <mreh> how does Parsec know where it is in the file even after I've removed lines in preprocessing?
14:53:19 <mreh> like line comments
14:54:12 <sproingie> preprocessors insert #line directives for that sort of thing
14:54:39 <benmachine> or {-# LINE ... #-} I think is the ghc version
14:55:50 <Berengal> The direct port of my C-implementation of the sieve of eratosthenes to Haskell is alot uglier than the C version... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16418#a16454
14:55:59 <Berengal> Also a lot slower
14:56:04 <Berengal> I fear the two might be connected
14:57:00 <benmachine> Cale: http://www.srcf.ucam.org/~bm380/stepevalprime.tar.gz now works with a rather lengthy foldr/map example I've constructed
14:57:11 <benmachine> and will paste somewhere
14:57:16 <hatds> I stopped reading after "callCC"
14:57:25 <hatds> ;)
14:57:37 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16455#a16455 there we go
14:57:41 <Berengal> Hehe
14:57:46 <thoughtpolice> Berengal: /me commits hari kairi
14:57:56 <benmachine> now I should probably call this a night, but if you (or anyone else) highlights me I will read it tomorrow
14:58:04 <c_wraith> Berengal: have you seen the paper on seiving in haskell?
14:58:11 <Berengal> c_wraith: The O'Neill one?
14:58:13 <c_wraith> yes
14:58:15 <dolio> You need to use callCC to implement C's return. :)
14:58:51 <Berengal> c_wraith: Yeah, it's the reason I started doing this. Someone was wrong on the internet, claiming trial division was the sieve
14:59:13 <c_wraith> you couldn't just point that person at her paper?  It covers why trial division isn't the sieve pretty well
14:59:16 <Berengal> dolio: And break, and possibly continue, but I didn't do that
14:59:25 <benmachine> (I think it might be wise for me to allow a lambda to apply multiple arguments at once, otherwise the evaluation uses a *lot* of steps)
14:59:40 <pikhq> Berengal: Ah, callCC. The functional goto. :P
14:59:41 <hatds> are Data.Bit operations fast?
14:59:57 <Berengal> c_wraith: I did, but I also took the opportunity to thoroughly trounce his algorithm with one that was three orders of magnitude faster
14:59:58 <idnar> callCC, the fundamental flow control operator
15:00:10 <pikhq> idnar: Like I said, the functional goto.
15:00:11 <c_wraith> Berengal: well, that's good then. :)
15:00:25 <Berengal> Now I'm trying to port it to haskell
15:00:43 <idnar> IM IN UR FLOW, CONTROLLING IT
15:00:43 <Berengal> And I just wondered what the direct translation would look like
15:00:58 <dolio> You see, C has an implicit callCC around every one of its functions. That's why it's so confusing. :)
15:01:15 <Berengal> pikhq: callCC is more powerful than gotos
15:01:45 <dolio> Berengal: Yeah, I'm not sure about continue. That's probably some double-callCC madness.
15:02:07 <pikhq> Berengal: Yes, I'm aware. Still, callCC is the closest *analogue* to goto in functional-land.
15:02:35 <Adamant> c_wraith: has anyone done the fancy prime sieves in Haskell?
15:02:39 <Adamant> GNFS and such?
15:02:50 <c_wraith> Oh, that fancy?  doubt it.
15:03:05 <c_wraith> The version from O'Neill's paper is on hackage, though.
15:03:08 <c_wraith> @hackage primes
15:03:09 <lambdabot> http://hackage.haskell.org/package/primes
15:03:24 <Adamant> c_wraith: thanks
15:04:14 <Berengal> One interesting aspect of callCC is that even though it's a time traveller, you can't travel forward in time, because you don't have a reference to it. You can however go *back* in time with a reference to the *current* time, give yourself that reference and jump to the point you are now from the past, which is as close as makes no difference
15:04:57 <hatds> that didn't turn out so well in Back to the Future 2 if I remember correctly
15:05:27 <Berengal> hatds: Ah, well, but my algorithm doesn't reach 88mph yet
15:05:33 <idnar> haha
15:05:37 * Berengal bolts on boosters
15:05:46 * idnar installs callCC in a blue police box
15:06:05 * Berengal thinks the blue police box /is/ callCC
15:06:29 <idnar> so the time vortex is just an infinite cascade of lambdas?
15:06:40 <Berengal> It's lambdas all the way down
15:06:41 <tensorpudding> the TARDIS is a big box of unsafePerformIO
15:06:54 <Berengal> tensorpudding: More like unsafePerformPlot
15:07:02 <idnar> haha
15:07:15 <idnar> is Plot a monad?
15:07:43 <Berengal> In the case of Dr. Who, I'm pretty sure it's a continuation
15:07:58 <Berengal> It's been continuing for almost 50 years...
15:08:10 <sproingie> i designed something like a Plot monad for a game before i even knew what monads were
15:08:14 <idnar> @type until
15:08:15 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
15:08:28 <idnar> no
15:08:30 <idnar> @type forever
15:08:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:08:41 <Dashkal> Continuations... I think it's about time I learned what those are
15:08:45 <sproingie> you'd start with a Plot, and plotEvents would give you a new Plot, and there'd be this little language for sequencing them
15:09:24 <Berengal> Dashkal: They're the gremlins that lurk in the shadows of FP, even in pure, statically typed ones.
15:09:47 <temoto> I'm seeing this again and again and i don't get how continuations are time travel.
15:09:51 <tensorpudding> the Plot monad allow you to keep the story pure by containing all the glaring time travel silliness
15:10:10 <idnar> temoto: a continuation sort of captures a point in space and time
15:10:13 <sproingie> @remember tensorpudding the Plot monad allow you to keep the story pure by containing all the glaring time travel silliness
15:10:13 <lambdabot> I will remember.
15:10:55 <idnar> (I use "space" and "time" metaphorically)
15:10:55 <Berengal> temoto: Lets say you have a sequence of computations, a, b and c. Usually we'd just write this a . b . c in Haskell
15:11:04 <idnar> so invoking the continuation takes you back (or forward!) to that point
15:11:29 <temoto> idnar: i understand space metaphor as instruction pointer. But i don't understand time one.
15:11:37 <dolio> You know, it's amazing that that movie wasn't called Back 2 the Future. We've come a long way in movie naming since then.
15:11:49 <Berengal> temoto: However, continuations can get a hold of their own context, so 'a' could pass the rest of the computation (i.e. 'b . c') on to the rest of the computation. 'c' could later invoke it, jumping back to the end of 'a'
15:11:52 <idnar> temoto: "time" refers to the changing state of the program
15:12:45 <Berengal> temoto: goto -> change instruction pointer. setjmp/longjmp -> change instrunction pointer, change stack pointer. continuations -> change instruction pointer, change stack pointer, change stack
15:13:09 <idnar> (the metaphor breaks down a bit in functional land)
15:13:12 * RayNbow liked this video lecture on continuations: http://www.uni-koblenz.de/~laemmel/paradigms0910/resources/denotational2.html
15:13:14 <Berengal> And by stack I mean heap as well
15:13:24 <temoto> If state is called time it makes some sense, i guess.
15:13:35 <Berengal> Well, in pure situations, the heap as well
15:13:49 <Berengal> (updated references will stay updated)
15:13:50 <idnar> you can view the overall state of the program as a function from "time" to the particular state at that time
15:14:20 <temoto> idnar: :: (t -> a) -> (t -> a) ?
15:14:30 <idnar> time ticks upward as execution proceeds forward, but invoking a continuation jumps you to some other state, hence "time travel"
15:14:37 <opqdonut> what does the INHERENT_USE biography profiling state mean?
15:15:13 <idnar> temoto: I was thinking more like t -> ProgramState or something, but it doesn't really matter
15:15:33 <idnar> that's an "abstract" view, you probably wouldn't want to actually implement such a function
15:15:59 <idnar> and of course, continuations can "fork" the timeline
15:16:00 <temoto> Conal Elliot is writing a blog about that.
15:16:06 <idnar> so it's not linear anymore
15:16:22 <idnar> (because when you travel back in time, you can bring stuff from the future back with you)
15:17:09 <Adamant> idnar: shouldn't you call it state travel then? :P
15:17:18 <idnar> Adamant: indeedn
15:17:30 <idnar> Adamant: and of course, you don't /really/ travel back in time, you just replace the present with a copy of the past
15:17:35 <Adamant> yeah
15:17:39 <idnar> so "real time" is linear
15:17:53 <Adamant> when I think time, I think physical ticks
15:18:40 <idnar> Adamant: like I say, the metaphor works better in imperative land than functional land
15:19:17 <damd> what about swaziland
15:19:22 <idnar> in a functional programi, you don't really have an arrow of time
15:19:34 <Adamant> I hear Switzerland is nice this time of year
15:19:37 <idnar> *program
15:20:00 <Adamant> right, because you can't clock stuff so much
15:20:35 <damd> is ST pure?
15:20:35 <idnar> I hear Swaziland has the lowest life expectancy
15:20:47 <Berengal> damd: Depends on your definition of pure
15:20:49 <Adamant> which is why unclocked combinational circuits look a lot like functional expressions :P
15:20:57 <dobblego> @src Endo
15:20:57 <lambdabot> Source not found. Wrong!  You cheating scum!
15:21:03 <dobblego> @hoogle Endo a -> a -> a
15:21:03 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
15:21:03 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:21:03 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
15:21:05 <Berengal> damd: According to the formal definition, it's pure outside of itself, but inside it it's not
15:21:12 <dolio> But continuations represent "stuff that's going to happen after now", so if you have a continuation from earlier in the program, you're jumping back past stuff that has already happened. So it makes some sense from that perspective.
15:21:14 <Adamant> which is why Bluespec exists :P
15:21:34 <damd> Berengal: that's what i've heard, but what does that *mean*?  how does it relate to IO?  (does it at all?)
15:22:10 <temoto> So for quickcheck do they usually create some pattern named file, and put properties there?
15:22:11 <c_wraith> Berengal: ST and IO share several implementation details
15:22:14 <Berengal> damd: Well, under the hood it's very closely related to IO, but it doesn't allow function like getLine or print, only reading and writing references
15:22:20 <c_wraith> err, sorry.  that should have been at damd
15:22:30 <idnar> damd: if IO is the "Universe", then ST is a little bubble universe that only exists for the duration of runST
15:22:32 <temoto> i wander for common style for writing quickchecks
15:22:33 <Berengal> Which makes it pure as far as us programmers go
15:22:49 <c_wraith> damd:  http://research.microsoft.com/en-us/um/people/simonpj/Papers/lazy-functional-state-threads.ps.Z
15:23:01 <damd> i've never been good at reading papesr
15:23:03 <damd> papers*
15:23:04 <c_wraith> damd:  That paper describes ST and IO, as implemented in an early version of GHC
15:23:14 <c_wraith> It's pretty clear, as opposed to many
15:23:17 <Berengal> damd: There are letters, you interpret them as words :P
15:23:34 <damd> Berengal: but what do the words mean?  i wish i knew.
15:23:39 <idnar> of course, you can "cheat" and travel between the real universe and the bubble universe with unsafeIOToST and unsafeSTToIO
15:23:44 <Berengal> damd: Me too :(
15:23:53 <Berengal> IORef is actually just a newtype for STRef RealWorld...
15:24:06 <damd> Berengal: i read the first of the syb papers probably ten times and it just wouldn't click
15:24:07 <Berengal> idnar: and stToIO
15:24:15 <tommd> Berengal: But how do you interpret 
15:24:28 <idnar> oh, yeah
15:24:30 <Berengal> damd: I haven't even started reading any generics papers...
15:24:40 <c_wraith> damd: syb is a much more complicated paper than the state threads one.
15:24:45 <Berengal> tommd: Looks like an x-wing
15:24:48 <Berengal> Seen from above
15:24:54 <Berengal> Except the wings could be longer...
15:25:05 <c_wraith> damd: also, if you stuff about higher-order functions doesn't click, just skip to the part about using state threads to implement IO
15:25:12 <tommd> Berengal: I take it you've had plenty of experience in spotting those.
15:25:12 <damd> how do i unpack .Z?
15:25:17 <Twey> uncompress
15:25:39 <damd> someone (i?) should put that in hunp...
15:25:46 <idnar> what's hunp?
15:25:51 <Berengal> tommd: I'm not exactly green at it
15:25:57 <damd> idnar: my silly unpacker tool
15:26:16 <idnar> I use aunpack (which is an alias for atool -x)
15:26:29 <damd> idnar: i've heard about that, sounds neat
15:26:31 <idnar> it takes care of figuring out whether there's a top-level dir in the archive or not, and which unpacker to call
15:26:43 <damd> but alas, atool was Not Invented Here
15:26:45 <idnar> the former is very useful for not accidentally having an archive splattered all over your homedir
15:26:54 <idnar> and the latter is just extra laziness
15:27:08 <Berengal> . o O (The Managers who say NIH)
15:27:43 <idnar> haha
15:27:45 <damd> idnar: i wrote hunp because i wanted a tool which i can pass a directory to so that it would just unpack the first "known" archive in that directory
15:27:50 <damd> useful for wArEz
15:27:51 <erikc> what is the current base package v ersion?
15:28:00 <Berengal> erikc: 4.2.0.0
15:28:26 <Berengal> erikc: That's the 6.12 version at least
15:29:40 <solidsnack> damd: You work somewhere that they want you to rewrite stuff in Haskell because it was not invented here?
15:30:14 <damd> solidsnack: i wish
15:30:26 <damd> i work with .NET.........
15:30:32 <temoto> haha
15:30:43 <solidsnack> damd: Oh, you didn't write hunp.
15:30:51 <temoto> http://nelsonlaugh.com/
15:30:52 <damd> solidsnack: i did write hunp, but not for work
15:31:01 <solidsnack> Oh.
15:31:16 <solidsnack> Well, I write mostly shellscript and some Ruby :(
15:31:34 <damd> you could probably implement hunp in 20 lines of bash
15:32:02 <solidsnack> Well, I write Bourne Shell but whatever :)
15:32:24 <damd> so make that 21 then ;P
15:32:30 <solidsnack> heh
15:33:04 <solidsnack> damd: I am becoming quite curious about getting Hackage packages in to Ubuntu.
15:33:19 <dobblego> there's got to be a better way of getting (a -> a) -> (a -> a) -> a -> a than pissing about with Endo and mappend
15:33:34 <solidsnack> Since, if I can do that with some small packages of mine in a reasonably timely fashion, then I can use some of my things at work without it being a big deal.
15:33:48 <damd> solidsnack: i use arch linux which has all of the hackage packages, but i still use cabal
15:34:03 <solidsnack> Hmmm.
15:34:15 <solidsnack> Yeah, it would be nice to get us to use Arch but oh well.
15:34:25 <opqdonut> dobblego: (.) ?
15:34:32 <damd> solidsnack: why not use cabal?
15:34:41 <opqdonut> :t (.) :: (a -> a) -> (a -> a) -> a -> a
15:34:42 <lambdabot> forall a. (a -> a) -> (a -> a) -> a -> a
15:34:43 <damd> or rather cabal-install
15:34:49 <dobblego> opqdonut, of course duh@me
15:34:57 <solidsnack> damd: If I use distro packages then it doesn't matter what they were written in.
15:35:03 <opqdonut> dobblego: :)
15:35:14 <solidsnack> If I use Cabal I have to have GHC installed all over the place and it's an eye sore.
15:35:31 <solidsnack> Well, it's a big deal even if it's not an eye sore :)
15:35:44 <damd> i really don't see how to be honest
15:35:58 <solidsnack> Hmm?
15:36:04 <solidsnack> How to be honest?
15:36:12 <damd> i really don't see how it can be a big deal, to be honest
15:36:36 <sm> well, what if you're having a affair ?
15:37:38 <damd> i'm so confused
15:38:12 <solidsnack> I'm talking about shell utilities for things like assigning release numbers to git repositories or something like that.
15:38:34 <solidsnack> Things that have some appeal to a general audience, anyways.
15:39:08 <solidsnack> If I write them over the weekend and they find their way in to Multiverse or whatever, no one here will care that they were written in Haskell.
15:39:37 <solidsnack> Whereas if I'm sitting here writing little utilities in Haskell all the time, they will likely be alarmed since they are Ruby people, after all.
15:41:09 <MissPiggy> I feel a bit bad because I'm useless at programming in anything other than haskell
15:41:29 <MissPiggy> maybe it's just the type of programs I write, though
15:42:25 <damd> i suck at C#, but maybe it's not me, but C#
15:43:09 <idnar> it's not you, it's me
15:43:09 <temoto> MissPiggy: you would be an order of magnitude more useless if your only language was PHP, so cheer up! :)
15:43:22 <MissPiggy> lol
15:44:09 <temoto> Actually, pretty much every other commonly used language fits in that sentence.
15:45:09 <MissPiggy> I don't want to become one of these monogluts
15:45:30 <Adamant> MissPiggy: ow
15:45:40 <Adamant> puns so bad they are good :P
15:45:51 <idnar> haha
15:48:46 <temoto> They say finding a Haskell programmer is very hard, because he must know everything, everythingM and everythingT. But then, ultimately you hire a programmer who can replace any other in the team because his knowledge is wider. To put it for absurd, senior Haskell programmer is a superset of PHP, Lisp, C# (did i say java yet?), Erlang, etc programmers.
15:49:39 <temoto> The only "real" value you can't get by learning haskell is domain-related, like banking specifics, etc.
15:49:41 <jfoutz> but they hardly every type. just stare intently and sequent calculus and sip coffee.
15:49:49 <elly> 'superset of lisp' is a pretty bold statement there
15:49:58 <elly> I have yet to see the haskell equivalent of syntax-case :P
15:49:58 <damd> i accidentally the whole bottle
15:50:33 <temoto> elly: i'm not to say that lisp is not expressive, what jerk would i be after that!
15:50:52 <temoto> elly: what's syntax-case?
15:51:17 <elly> it lets you rewrite your program's AST in an arbitrary way after parsing and before evaluation :)
15:51:20 <jfoutz> it's like template haskell, but able to do surgery everywhere. think safe macros.
15:51:30 <elly> (actually lets you apply arbitrary functions to your AST, more or less)
15:52:32 <temoto> elly: yeah haskell needs special templating for that because it's not dynamically interpreted, but i'm interested; could you show an example?
15:52:32 <Eduard_Munteanu> data Piece = Color Pawn | Color Knight | Color Bishop | Color Rook | Color Queen | Color King deriving Show
15:52:41 <Eduard_Munteanu> Is there any way I can get that to work? ^
15:52:48 <jfoutz> the only real downside is you have to learn a whole extra language after learning scheme. not that there is a lot of scheme to learn :)
15:52:56 <Eduard_Munteanu> That is without resorting to a parametric type.
15:53:09 <Eduard_Munteanu> Color is just data Color = White | Black
15:53:13 <elly> temoto: sure: (define-syntax let-if (syntax-rules () ((let-if name cond body ...) (bind name cond (if name body ...)))))
15:53:23 <elly> temoto: that is a conditional form that binds the value of the conditional to a name as well
15:53:25 <damd> Eduard_Munteanu: in your example of Piece you use Color as a constructor
15:53:36 <damd> Eduard_Munteanu: you want data Piece = Pawn Color | Knight Color | ...
15:53:43 <elly> so (let-if v (some-function-that-returns-v-or-false) (print v))
15:53:58 <Eduard_Munteanu> damd, I see, so it isn't possible to use them in reverse?
15:54:08 <damd> Eduard_Munteanu: no, it doesn't make any sense.
15:54:18 <jfoutz> Eduard_Munteanu: i think if you flip your declarations, like data Piece = Pawn Color | Knight Color ... etc, you'll get what you want.
15:54:50 <Eduard_Munteanu> damd, thanks.
15:55:23 <jfoutz> i type slow. *blush*
15:55:27 <Eduard_Munteanu> jfoutz, hm, was just making sure I couldn't write Black Pawn :)
15:55:35 <Eduard_Munteanu> I would have liked that more.
15:56:15 <Berengal> Eduard_Munteanu: you could make data Color = White Piece | Black Piece
15:56:17 <jfoutz> you could make color take a parameter. data Color a = Black a
15:56:25 <damd> at a local grocery store they sell a drink called "power king white cola".. the receipt said "white power"
15:56:33 <jfoutz> or that!
15:57:04 <temoto> elly: i don't get it :)
15:57:10 <elly> temoto: don't get what?
15:57:17 <elly> it is the C if ((x = thing)) idiom
15:57:20 <elly> except not gross ;)
15:58:13 <temoto> Ah, now i get it :)
15:58:35 <Eduard_Munteanu> Berengal, jfoutz, yeah, not very comfy, I'll just reverse them then.
15:59:15 <temoto> elly: is epsilon actually used there?
15:59:25 <elly> er... epsilon?
15:59:30 <temoto> "..."
15:59:33 <damd> ellipsis
15:59:37 <temoto> right
16:00:18 <jfoutz> ... is the only scheme postfix operator. or it was in r5.
16:01:01 <temoto> elly: do you actually write "..." in syntax-case definitions or did you mask some irrelevant code behind it?
16:01:14 <elly> no, ... means "variadic arguments"
16:01:21 <damd> in scheme it's "...", in cl it's "***"
16:01:24 <elly> x ... in a match binds 'the rest of the arguments'
16:01:34 <elly> that is the entire implementation of let-if
16:01:40 <temoto> Ah, pythonic *args.
16:02:43 <MissPiggy> elly, I think I argued at some point (in the past) that haskell doesn't need macros
16:03:08 <MissPiggy> elly, vaugely remember it being to do with lambda and lazyness, but now-a-days I know I was wrong
16:03:50 <MissPiggy> well - I should not say that it needs macros, but there is a limitation because of not having them
16:03:55 <temoto> MissPiggy: in some sense, existence of TH constructively proves that it does need macros.
16:04:33 <c_wraith> well, due to not being lazy, lisp does need macros to have "if", where haskell doesn't need macros for that.
16:04:46 <MissPiggy> yet haskell has if syntax anyway :(
16:04:59 <c_wraith> yeah, haskell if should totally be a function, not syntax
16:05:08 <MissPiggy> temoto, yeah that's a good point
16:05:11 <temoto> That's only because of two limitations of parser.
16:05:26 <temoto> because of either of those
16:06:19 <temoto> 1) you can't define operators with more than 2 arguments
16:06:29 <temoto> 2) if is prefix in haskell.
16:07:06 <temoto> But who cares about reasons... the fact that it is a special syntax.
16:07:35 <Berengal> I want mixfix
16:07:37 <pikhq> :t let f &&& g x = f g x in (&&&)
16:07:38 <lambdabot> Parse error in pattern
16:07:41 <jfoutz> > let (*) = (\a b c -> a + b + c) in 1*2 3
16:07:42 <lambdabot>   Ambiguous type variable `t' in the constraint:
16:07:42 <lambdabot>    `GHC.Num.Num t' arising f...
16:07:55 <jfoutz> > let (*) = (\a b c -> a + b + c) in 1*2 3::Int
16:07:56 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:07:56 <lambdabot>         against inferred type ...
16:07:57 <hatds> let (+) a b c = a*b*c in (+) 2 2 2
16:08:03 <hatds> > let (+) a b c = a*b*c in (+) 2 2 2
16:08:03 <lambdabot>   8
16:08:07 <jfoutz> oh
16:08:12 <hatds> > let (+) a b c = a*b*c in 2 + 2 $ 2
16:08:12 <lambdabot>   8
16:08:15 <Berengal> In agda the definition of if looks like if_then_else_ : {A : Set} -> Bool -> A -> A -> A; if true then x else y = x; if false then x else y = y
16:08:42 <c_wraith> but backing up a level.  Lisp *needs* macros to implement if, because it's not lazy.  Haskell doesn't need macros for that sort of thing, so its need for them is at least lessened.
16:09:08 <aaronp> My boss just used "it's written in Haskell" as an argument against the maintainability of a program I wrote.  :(
16:09:24 <temoto> http://nelsonlaugh.com/
16:09:36 <c_wraith> did you tell him anyone can learn haskell in a few minutes?
16:09:49 <Berengal> aaronp: If the only maintainers available are unwilling to learn haskell that's a valid concern
16:09:50 <c_wraith> Your arguments don't need to be true.  Just loud. :)
16:10:03 <jfoutz> *cackle*
16:10:20 <Eduard_Munteanu> c_wraith, I'm not really sure that's true, except for a quick understanding of very basic stuff.
16:10:22 <aaronp> Berengal: Yeah, it's a steep learning curve so it's probably a valid argument, it just makes me sad.
16:11:08 <Berengal> c_wraith: Indeed. Lisp uses macros to write EDSLs, and therefore have them all over the code. Haskell uses TH to write generic boilerplate, and typically stows the useage in some internal module in a library
16:11:46 <Berengal> aaronp: The thing to do about such people is to make the willing to learn.
16:12:16 <Berengal> aaronp: Also, you could rewrite the program in C and prove that Haskell is twice as fast and only has a sixth of the source ;)
16:13:15 <temoto> He would need to write very very bad C to have Haskell twice as fast.
16:13:33 <hatds> is template haskell going to be moved into the haskell standard at some point?
16:13:51 <hatds> or are there still different approaches being looked at?
16:13:51 <Berengal> temoto: It's not like writing bad C is a hard thing...
16:14:04 <pikhq> Writing bad C is very easy.
16:14:34 <pikhq> Just assume you have garbage collection!
16:14:53 <temoto> pikhq: there are libraries allowing that, you know?
16:14:59 <Berengal> pikhq: It does. It's called exit
16:15:08 <pikhq> temoto: Yes, I am very well-aware of Boehm GC.
16:15:16 <temoto> ok
16:15:56 <aaronp> Berengal: Well, the fact that the binary ends up linked against libgmp and libffi are also strikes against it, so rewriting it in C is probably what I'm going to end up doing.  It's not like it'll be hard to do; it's a pretty simple program.
16:16:03 <temoto> Is there like common PrettyPrint class?
16:16:29 <Berengal> @hoogle pprint
16:16:30 <lambdabot> Language.Haskell.TH pprint :: Ppr a => a -> String
16:16:30 <lambdabot> Language.Haskell.TH.Ppr pprint :: Ppr a => a -> String
16:16:44 <Berengal> @hoogle text
16:16:44 <lambdabot> Text.Html text :: String -> HtmlAttr
16:16:44 <lambdabot> Text.PrettyPrint.HughesPJ text :: String -> Doc
16:16:44 <lambdabot> Text.XHtml.Transitional text :: String -> HtmlAttr
16:16:53 <Berengal> There we go. Text.PrettyPrint
16:17:14 <temoto> @hoogle Text.PrettyPrint
16:17:14 <lambdabot> module Text.PrettyPrint
16:17:25 <temoto> :i Text.PrettyPrint
16:17:30 <temoto> @src Text.PrettyPrint
16:17:30 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:17:39 <hatds> I think the class might be unexported
16:17:42 <Berengal> temoto: Prettyprinting is usually too context-spesific you don't want a class for it. You want combinators
16:17:58 <Berengal> That's what Text.PrettyPrint and friends provide
16:18:46 <temoto> I see.
16:22:03 <temoto> > Text.PrettyPrint.render empty
16:22:04 <lambdabot>   Not in scope: `Text.PrettyPrint.render'Ambiguous occurrence `empty'
16:22:04 <lambdabot>  It cou...
16:22:12 <temoto> > Text.PrettyPrint.render Text.PrettyPrint.empty
16:22:13 <lambdabot>   Not in scope: `Text.PrettyPrint.render'Not in scope: `Text.PrettyPrint.empty'
16:22:46 <temoto> > Text.PrettyPrint.HughesPJ.empty
16:22:47 <lambdabot>   Not in scope: `Text.PrettyPrint.HughesPJ.empty'
16:24:15 <sshc_> how do I use Parsec's <|> after a do block, without using braces and semicolons?
16:25:16 <c_wraith> sshc: outdent, if that's syntactically possible.
16:25:25 <temoto> do ends on indentation w/o braces.
16:25:27 <c_wraith> sshc: if it's not syntactically possible, parens
16:25:38 <sshc> c_wraith: I tried using parenthesis
16:25:49 <sshc> c_wraith: can you try giving me an example?
16:25:53 <c_wraith> I'll see
16:26:16 <sshc> I like my do likes to be like this
16:26:19 <sshc> foo = doo
16:26:28 <hatds> but was it indented further than the do?
16:26:30 <sshc>     bar
16:26:36 <sshc> hatds: no, it wasn't
16:26:43 <sshc> hatds: I don't like that style
16:26:51 <temoto> sshc: extracting block to separate function would not hurt.
16:26:54 <sshc> hatds: I would like to do it without indenting further than the do
16:27:01 <hatds> hatds: enclosing it in parens won't make it work unless you are trying to do it on the same line as the do block
16:27:09 <hatds> er, replying to sshc not myself :)
16:27:39 <temoto> And braces would not hurt either.
16:27:48 <hatds> it has to be indented further, the enclosing block will insert a semi-colon otherwise
16:28:00 <sshc> if I use braces, can I still omit semicolons?
16:28:13 <hatds> no
16:28:20 <temoto> Semicolons would not hurt either.
16:28:40 <sshc> yes they would; I don't like them
16:28:51 <temoto> Parsec comes with examples that are full of do blocks with braces and semicolons.
16:29:13 <temoto> sshc: well, programming is not about what we like. :)
16:29:29 <hatds> it really sounds like all you need to do is indent the '<|>' a single space
16:29:30 <c_wraith> really, assigning names to things you're alternating between doesn't hurt.
16:29:57 <mreh> Halp! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16456#a16456
16:30:00 <sshc> c_wraith: aha, that's good idea
16:30:03 <mreh> I've been staring at this for ages
16:30:23 <mreh> the parser is commented at the end with the file I'm trying to parse
16:30:28 <temoto> Actually, so clean haskell syntax eliminates so much boilerplate that any small syntax price is totally acceptable.
16:30:37 <mreh> '>' indicated a commented line in the source file
16:30:42 <sshc> I like this: biglonglinefoobarquuxaoeuaoeu = do\n    bar <- quux    \naoeu <- snth\n   <|> "thing"
16:30:52 <sshc> which doesn't work, since I want <|> outside of the do block
16:31:10 <c_wraith> Um.  that doesn't even make sense.
16:31:18 <c_wraith> You need to do something with those values
16:31:25 <c_wraith> Maybe you should consider applicative style?
16:31:30 <temoto> You could use flip and confuse things more.
16:31:35 <sshc> I also tried this: biglonglinefoobarquuxaoeuaoeu = (do\n    bar <- quux    \naoeu <- snth\n   ) <|> "thing"
16:31:48 <c_wraith> a do block can't end with a line with <- in it
16:31:54 <c_wraith> you need to do something with that value
16:32:00 <mreh> sshc, that's nonsensical
16:32:03 <hatds> hmm, if you put a semicolon as the last part of the do it might work
16:32:19 <hatds> an infix operator can't start a valid do statement, so the parse error rule should kick in
16:32:25 <temoto> Or you could extract do statement and have just  foo = foo' <|> bar where foo' = do ...
16:32:31 <sshc> mreh: of course it is
16:32:32 <c_wraith> I expect your last line is like return $ f foo bar ?
16:32:41 <sshc> c_wraith: yes
16:32:54 <damd> also, i advice you not to use do-notation, it's better to stay purely functional!
16:33:01 <c_wraith> sshc: in which case, you could just rewrite the do in applicative style f <$> quux <*> snth
16:33:07 <sshc> damd: do-notation can be purely functional
16:33:10 <temoto> damd: do-notation is purely functional :)
16:33:11 <damd> *TROLL*
16:33:16 <temoto> :)
16:33:18 <c_wraith> then you're not in a do, so you don't need to worry about its syntax
16:33:20 <sshc> damd: Parsec is itself purely functional
16:33:27 <sshc> damd: do is actually syntactic sugar
16:33:31 <mreh> @tell
16:33:31 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
16:33:42 <sshc> damd: there's a wiki page somewhere if you want to know more
16:33:48 <damd> sshc: but 'do' is only for IO, which is impure
16:33:50 <mreh> @tell lament "http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16456#a16456 this is what i've done with your parser so far"
16:33:50 <lambdabot> Consider it noted.
16:34:10 <c_wraith> damd: that sounds particularly trollish
16:34:13 <temoto> @remember sshc "there's a wiki page somewhere if you want to know more"
16:34:13 <lambdabot> I will remember.
16:34:24 <c_wraith> sshc: do you understand what I'm talking about with applicative style?
16:34:28 <sshc> <_<
16:34:32 <c_wraith> sshc: it really is better for parsers, in general
16:34:41 <sshc> c_wraith: I don't understand
16:34:43 <c_wraith> unless you actually need the monadic interface for some reason
16:34:59 <sshc> because I know how to use it?
16:35:10 <sshc> I can wrap it in let or where
16:35:14 <c_wraith> if your monad implements the applicative interface, which they all *can* (even if they don't all do)
16:35:16 <pikhq> damd: No, 'do' is not needed for IO.
16:35:48 <damd> without 'do' you can only do one IO procedure
16:35:51 <temoto> This is like COMET. A long-polling troll. :)
16:35:52 <pikhq> @undo do n <- getContents; putStr n;return ()
16:35:52 <lambdabot> getContents >>= \ n -> putStr n >> return ()
16:36:00 <pikhq> I beg to differ.
16:36:00 <damd> you need 'do' if you want a real long-lasting program
16:36:09 <c_wraith> you can re-write something that looks like do { x <- foo ; y <- bar ; return $ f x y } as f <$> foo <*> bar
16:36:10 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16456#a16456 -- I'm really stuck on this one guys, it's a large paste but it only concerns four or so functions, execution syntax and unexpected behaviour is pasted at the end along with the Parser target file
16:36:24 <sshc> damd: "do" works for the State monad, the Reader monad, the Writer monad, the Continuation monad, the Identity monad, the Maybe monad, the StateT monad, the ReaderT monad, the WriterT monad, the MaybeT monad, the IO monad, and any other monad
16:36:37 <sshc> and the list monad
16:36:40 <damd> i am so happy right now
16:36:53 <sshc> damd: I'm glad you are :)
16:37:06 <mreh> \0/ another satisfied customer
16:37:16 <xerox> \
16:37:27 <sshc> 0
16:37:28 <pikhq> Oh, heck. Why not...
16:37:33 <pikhq> :t do n <- getContents; putStr n;return ()
16:37:34 <lambdabot> IO ()
16:37:36 <c_wraith> sshc: you can re-write something that looks like "do { x <- foo ; y <- bar ; return $ f x y }" as "f <$> foo <*> bar" if the monad implements Applicative, which parsec does
16:37:38 <pikhq> :t getContents >>= \ n -> putStr n >> return ()
16:37:39 <lambdabot> IO ()
16:37:51 <pikhq> Looks the same to me.
16:38:05 <damd> pikhq: it is only the type, it only sees getContents because haskell is *lazy*
16:38:06 <sshc> c_wraith: I do not understand Applicative Functors yet
16:38:21 <temoto> Haskell-2010.04.01 should have Monad renamed to Troll so we will have IO Troll, State Troll and more Trolls :)
16:38:37 <temoto> Maybe Troll :)
16:38:43 <c_wraith> sshc:  What's to understand?  that's a translation that could have been done mechanically.  Applicative is strictly a subset of monad.
16:38:56 <hatds> f x = do\n _ <- x\n _ <- x\n ; <|> undefined  --you can do this too sshc
16:39:23 <mreh> no-one wants to help me :,(
16:39:37 <sshc> hatds: that worked! thanks!
16:39:43 <sshc> hatds: or, um
16:39:46 <sshc> hatds: no it didn't
16:39:58 <hatds> sshc: what happened
16:40:00 <damd> pikhq: i can explain it to you if you want, it is basic haskell knowledge
16:40:12 <temoto> rofl
16:40:16 <pikhq> damd: ...
16:40:34 <damd> :)
16:40:37 <pikhq> Imma go back to C lambda. :P
16:41:00 <sshc> pikhq: explain what now?
16:41:01 <temoto> damd: can you put a video on youtube with explanation?
16:41:33 <damd> temoto: i wish i had a troll response to that one :)
16:42:21 <sshc> damd: why do you wish to annoy others?
16:42:24 <hatds> the do needs to end with an expression, but other than that the above should work
16:42:56 <jfoutz> mreh: i don't have Diatonic or Analyser or Hascore... so i can't load it. but the "||" seems to indicate to me your parser isn't down in the parseMelody section, you're eating the whole file on parsekey
16:43:06 <sshc> hatds: will that work with GHC v6.10.4?
16:43:09 <pikhq> sshc: ... ?
16:43:28 <hatds> sshc: it works in mine, ghc 6.10.3
16:43:39 <pikhq> sshc: BTW, Applicatives are easier.
16:43:42 <pikhq> Erm. Easy.
16:43:47 <hatds> sshc: and it will work in any compiler that implements the layout rule correctly
16:43:49 <sshc> aha, the parse error are on the wrong line
16:43:50 <pikhq> pure = return, <*> = ap.
16:44:00 <sshc> @src ap
16:44:01 <lambdabot> ap = liftM2 id
16:44:20 <c_wraith> ok, let's try something stupid, that may get the point across
16:44:25 <mreh> jfoutz: you're a genius, sometimes you need fresh eyes, I was wondering why it was asking for a || when parseSystem asks for the key and time signature first
16:44:40 <c_wraith> > (+) <$> Just 5 <*> Just 7
16:44:41 <lambdabot>   Just 12
16:44:42 <hatds> sshc: but it only works when you put the semi-colon followed by a lexeme that can't start a pattern:  infix operators and some special characters
16:44:55 <c_wraith> > (+) <$> [5] <*> [7]
16:44:56 <lambdabot>   [12]
16:44:58 <temoto> mreh: when i had troubles with parsers today, quicksilver adviced to check out results of concrete parsers you suspect in errors.
16:44:59 <jfoutz> mreh: :) glad i could help.
16:45:29 <pikhq> :t (+) <$> (pure 5) <*> (pure 7)
16:45:30 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a
16:45:31 <mreh> temoto: yeah, it's the top level parser that's borken though :)
16:45:53 <medfly> :t liftM2
16:45:54 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:46:11 <c_wraith> sshc: <$> moves the function into the context.  <*> applies an argument in a context to a function in that same context.
16:46:18 <sshc> > let s = State (\s -> (s, s + 1)) in 0 <$> s
16:46:19 <lambdabot>   No instance for (GHC.Show.Show
16:46:19 <lambdabot>                     (Control.Monad.State.Laz...
16:46:34 <sshc> > let s = State (\s -> (s, s + 1)) in execState $ 0 <$> s
16:46:36 <lambdabot>   No instance for (GHC.Num.Num (s -> a))
16:46:36 <lambdabot>    arising from the literal `0' at <...
16:46:41 <sshc> > let s = State (\s -> (s, s + 1)) in execState $ 0 <$> s <*> s
16:46:42 <lambdabot>   No instance for (Control.Applicative.Applicative
16:46:43 <lambdabot>                     (Contr...
16:46:56 <tensorpudding> <$> is good old fmap
16:46:56 <mreh> jfoutz: it's not fixed yet, but that's a perspective I didn't even consider
16:47:07 <c_wraith> sshc: actually, pure moves anything into the context.  <$> moves a function into the context and applies an argument in that context.
16:47:21 <sshc> c_wraith: sometimes I need multpile functions
16:47:25 <mreh> <*> and <$> seem so superfluous
16:47:50 <mreh> <$> = `fmap`
16:47:51 <tensorpudding> applicative seems kinda superfluous because most of it is backported from monads, or copied from functors
16:48:04 <mreh> yes
16:48:25 <c_wraith> sshc: break them up into pieces and use applicative style for each piece.  It's good practice for factoring your pieces into small bits anyway
16:48:44 <tensorpudding> <$> is fmap, <*> is ap, liftA* and liftM*, pure is return
16:49:20 <dobblego> is there a reverseFst? e.g. reverseFst [(1, 'a'), (2, 'b'), (3, 'c')] = [(3, 'a'), (2, 'b'), (1, 'c')]
16:49:56 <medfly> write it?
16:50:01 <pikhq> The type classes seem superflous because a Monad is not an Applicative or a Functor, even though a monad is an applicative functor and a functor.
16:50:03 <mreh> dobblego: use unzip
16:50:05 <mreh> :unzip
16:50:10 <medfly> use map?
16:50:14 <mreh> :t unzip
16:50:15 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
16:50:18 <dobblego> I know how to write it
16:50:20 <medfly> oh, I saw that wrong, sorry
16:50:21 <mreh> medfly: ?
16:50:26 <mreh> :)
16:50:54 <syntaxglitch> seems to me it'd make more sense if Monads were actually Applicative automatically and all the redundant monad junk got thrown out
16:51:00 <xerox> > uncurry zip . (reverse *** id) . unzip $ [(1,'a'),(2,'b'),(3,'c')]
16:51:01 <lambdabot>   [(3,'a'),(2,'b'),(1,'c')]
16:51:10 <c_wraith> syntaxglitch: that would make more sense to everyone
16:51:24 <pikhq> syntaxglitch: The same is true of s/Applicative/Functor.
16:51:32 <medfly> will we have to make a gazillion applicative toturials now
16:51:34 <medfly> tutorials
16:51:37 <tensorpudding> it'd be nice if monads were explicitly applicatives, and all applicatives explicitly functors
16:51:41 <hatds> applicative does have a functor requirement, no?
16:51:44 <xerox> > uncurry zip . first reverse . unzip $ [(1,'a'),(2,'b'),(3,'c')]
16:51:45 <lambdabot>   [(3,'a'),(2,'b'),(1,'c')]
16:51:50 <c_wraith> @src Applicative
16:51:50 <lambdabot> class Functor f => Applicative f where
16:51:50 <lambdabot>     pure  :: a -> f a
16:51:50 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:51:52 <dobblego> s/functors/pointed and all pointed were functors
16:52:07 <pikhq> hatds: Right, yeah.
16:52:08 <c_wraith> Something doesn't need to be a functor to be pointed
16:52:19 <dobblego> pointed functor
16:52:26 <c_wraith> Though anything that can be pointed *can* be a functor
16:52:38 <dobblego> fmap+pure
16:53:07 <dobblego> xerox, cheers
16:53:16 <xerox> :^)
16:53:16 <syntaxglitch> what's the reason for the situation with Monad not being Applicative anyway? I'm assuming it's a matter of legacy code/back compat or whatnot
16:53:43 <temoto> They said it is a matter of legacy.
16:53:45 <hatds> the business of putting a  "SuperClass a =>" context to class decls is a hairy thing, in an abstract sense it's a purely restrictive change but in the subjective sense it can be quite the opposite
16:54:01 <syntaxglitch> Actually a lot of the standard library/types/classes seem kinda awkward to me
16:54:04 <temoto> Just as fail in Monad and just as Int in Prelude.
16:54:16 <hatds> Monad specifically was long before Applicative too
16:54:31 <sshc> is a "where" block allowed to be empty?
16:54:36 <dolio> fail in Monad was just a bad decision.
16:54:39 <syntaxglitch> like functions with the same name and related semantics, like huge chunks of Data.Set and Data.Map
16:54:44 <mreh> how easy is darcs to use?
16:54:47 <ddarius> type F a = a -> a, instance Pointed F where pure = const
16:54:55 <ddarius> F is not a Functor.
16:54:56 <hatds> any block can be empty I think
16:54:58 <tensorpudding> dolio: fail FAIL?
16:55:03 <sshc> > 3 where
16:55:04 <lambdabot>   <no location info>: parse error on input `where'
16:55:06 <hatds> except maybe case :)
16:55:12 <sshc> > 3 where {}
16:55:13 <lambdabot>   <no location info>: parse error on input `where'
16:55:20 <syntaxglitch> or all the []-only functions in Prelude vs. perfectly good Foldable equivalents
16:55:25 <dobblego> ddarius, I believe edwardk has named fmap+pure as Pointed in category-extras
16:55:44 <ddarius> mreh: Really
16:55:44 <sshc> mreh: it's easy to use, and wonderful
16:56:09 <sshc> mreh: I like how it does patches and stuff more than git
16:56:17 <sshc> @quote sshc
16:56:17 <lambdabot> sshc says: "there's a wiki page somewhere if you want to know more"
16:56:30 <dolio> Applicative and Foldable postdate H98 by quite a few years, by contrast.
16:56:43 <ddarius> :t let x = 3 where {} in x
16:56:44 <lambdabot> forall t. (Num t) => t
16:57:06 <temoto> > 3 where
16:57:07 <lambdabot>   <no location info>: parse error on input `where'
16:57:10 <mreh> I'm not doing anything complicated, I'd just like to store revisions of my code
16:57:15 <hatds> :t let x = 3 where in x
16:57:16 <lambdabot> forall t. (Num t) => t
16:57:18 <hatds> :)
16:57:24 <temoto> mreh: for what?
16:57:50 <mreh> temoto: in case everything goes wrong/nuclear war
16:58:39 <temoto> mreh: that's called backups. rsync -u $HOME/project /mnt/extdisk/
16:59:01 <temoto> probably, i forgot recursive option
16:59:02 <hatds> people use darcs for backups too, no?
16:59:17 <mreh> temoto: oh, I've got automatic backups at university, I'll use those
17:00:17 <temoto> hatds: people are so.. alogical... always use wrong instruments... someday those obsolete biological mistakes will be replaced by superpowerful robots.
17:01:04 <hatds> :)
17:01:19 <tensorpudding> yes
17:01:29 <hatds> darcs is not a good local backup solution then?
17:01:34 <tensorpudding> all humans will be upgraded
17:01:44 <syntaxglitch> version control and backups are not the same thing
17:02:21 <mreh> some people have their heads up their asses
17:02:26 <temoto> hatds: it's not about darcs. Version control, is a suprset of backup.
17:02:45 <syntaxglitch> backups protect you from external catastrophe, version control protects you from your own stupid mistakes
17:02:45 <blackdog_> if a program uses happy, should it express that in its dependency list?
17:03:01 <tensorpudding> version-controlling your whole computer is very costly
17:03:04 <temoto> You're using Integer when you need number, right? Not list of one Integer?
17:03:09 <mreh> blackdog_ are you uploading something to hackage?
17:03:17 <blackdog_> i've just had one of my users trip up over that... otoh, it seems to make sense to allow a pre-built version to be used
17:03:28 <blackdog_> mreh: this is for hubris, yes
17:03:30 <hatds> we were talking about revisions of code specifically though
17:03:39 <blackdog_> i don't use happy directly, but one of my deps does
17:03:46 <mreh> I think, if it works temoto, then it doesn't matter
17:04:13 <mreh> you're frighteningly and militantly utilitarian
17:05:24 <mreh> blackdog_ then sure, if it's not included in another dependency already
17:05:25 <syntaxglitch> it's also worth noting that version control on local storage is not a backup solution
17:05:26 <temoto> mreh: that's true too. Though, on a really big project dir, version control is noticably slower and take noticably more space than just backups.
17:05:47 <mreh> temoto: space is cheap :)
17:06:10 <temoto> Well, of course, if you keep only single previous version, these drawbacks are eliminated. That's when version control equals to backup.
17:06:23 <mreh> unless your harddrive dies of course
17:06:45 <tensorpudding> filesystem snapshots are basically version control
17:06:48 <temoto> Which is irrelevant to choosing between backup or version control.
17:07:18 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16418#a16457 <- Can someone explain why these two are different?
17:07:29 <temoto> Disk death is blind for its victims...
17:07:33 <blackdog_> mreh: yeah. just thinking about the difference between binary dependencies and tool dependencies
17:07:55 <blackdog_> mreh: for instance, c2hs doesn't compile on 6.12 atm, but if you can get a version compiled with 6.10 on, it all works fine
17:08:03 <temoto> :t runST
17:08:04 <lambdabot> forall a. (forall s. ST s a) -> a
17:08:04 <blackdog_> if i specified a dependency directly, i'd be hosed.
17:08:27 <mreh> blackdog_ can't you specify the dependency of GHC?
17:08:39 <MissPiggy> the proof of 'forall a. (forall s. ST s a) -> a' uses free theorems
17:08:45 <blackdog_> mreh: how do you mean?
17:08:54 <Berengal> The only things that should be different is that I've moved everything from a let to a where
17:08:56 <blackdog_> mreh: oh - well, the problem is that hubris needs 6.12
17:09:07 <mreh> blackdog_ ah
17:09:08 <blackdog_> because of all the new dynamic library stuff
17:09:20 <mreh> I dont know then
17:09:48 <sshc> Is there a way I can refer to something exported by the own module within itself?
17:10:05 <sshc> I have function foo defined in the module, but I also import foo from another module
17:10:17 <sshc> how do I refer to the module's / local foo?
17:10:21 <hatds> Berengal: possible shadowing of the identifier 'max'?
17:10:21 <lostlogic> sshc: import the second foo qualified?
17:10:25 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16456#a16456 -- this has me completely stumped
17:10:34 <sshc> lostlogic: I don't want to use the second foo
17:10:37 <mreh> problem is pasted at the end, it only concerns four functions
17:10:37 <Raevel> i imagine you will get a warning if you have colliding imports
17:10:39 <Berengal> hatds: That's on purpose
17:10:41 <jfoutz> Berengal: maybe the let inside the do is more expensive than the external where?
17:10:45 <sshc> lostlogic: I want to use foo I have defined locally
17:10:55 <Raevel> import Bar hiding (foo)
17:11:04 <Berengal> jfoutz: I seriously doubt it, since that's the faster version
17:11:11 <sshc> Raevel: I didn't know that existed. thanks!
17:11:25 <Raevel> :-)
17:11:32 <jfoutz> Berengal: oh, good point. :)
17:11:33 <sshc> can I also use something like "module Bar as B () where"?
17:12:00 <Berengal> jfoutz: But still, even if we suppose it's the other way around, they shouldn't be different
17:12:02 <sshc> in case I ever did want to refer to the other foo? (I don't in this case, but I'd like to know how I would when I did)
17:12:40 <Raevel> sshc import qualified Bar will let you type Bar.foo
17:13:16 <sshc> Raevel: is importing the outside module as quialified the *only* way to fix the ambiguity?
17:13:26 <Berengal> In both cases the definitions are local to the function, and appart from functions in the where taking the array as an argument instead of closing over it, the implementations are identical
17:14:20 <Raevel> sshc: hmmm, i think so, but what do i know
17:14:48 <Raevel> sshc in what way would you like to "fix" it?
17:15:39 <sshc> Raevel: I would like to refer to the foo inside the module by prefixing it with F.foo, and somewher else I would also like to refer to foo, preferably without any prefix.
17:16:26 <hatds> can't do that if both unqualified names are in scope, and the locally defined identifier is always available unqualified
17:17:02 <sshc> hatds: how do I make the foo inside the module qualified?
17:17:12 <sshc> hatds: can I add "as F" somewhere in the moduel declaration?
17:17:58 <hatds> sshc: import qualified module Foo(foo)
17:18:14 <sshc> hatds: can I do that inside Foo itself?
17:18:29 <hatds> import qualified Foo(foo) as F
17:19:01 <sshc> hatds: will GHC allow me to import a module's self like that?
17:19:18 <hatds> no, it has to be a different module :)
17:19:26 <Raevel> i'm thinking the local definition will always be the unqualified one
17:27:34 <jfoutz> Berengal: my next guess is crossMultiples or findHighest are inlined.
17:28:06 <sshc> > let (&&-) = liftM2 (&&) in even &&- even $ 3
17:28:07 <lambdabot>   False
17:28:59 <Berengal> jfoutz: I'll try some pragmas...
17:32:44 <Cale> benmachine: another idea for the stepwise-evaluator (which would require a bit more GUI work) would be to separate off a "heap" for holding the current state of let bindings and keeping them visually separate from the evaluating expression.
17:33:39 <sshc> is there a way to prepend several pragmas to every file when something builds with cabal?
17:37:38 <hatds> Cale: I wish ghci's :step did that
17:39:02 <hatds> or wait, it does, I was thinking of something else
17:41:59 <sshc> if I have a data type declare as "data Foo = Foo Int Int", and I want fmap f to apply f to both Int's, why does this result in a kind error?: "instance Functor Foo where fmap f (Foo a b) = Foo (f a) (f b)"
17:42:29 <Alpounet> @src Functor
17:42:30 <lambdabot> class  Functor f  where
17:42:30 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
17:42:44 <Alpounet> sshc, Foo isn't a parametrized data type
17:43:06 <Alpounet> the definition of the Functor typeclass requires 'f' to pe of kind * -> *
17:43:14 <Alpounet> that is, a parametrized data type
17:43:28 <Alpounet> (parametrized by one data type)
17:44:06 <sshc> which typeclass should I use if I want a function that behaves similar to map?
17:44:35 <dobblego> @type join (***)
17:44:36 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
17:46:06 <Philonous> @type fmap
17:46:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:50:06 <ddarius> sshc: Without multiparameter type classes or associated types, there is no way to make a reasonably general class for such an operation.
17:53:33 <Alpounet> I'd rather say your data type isn't appropriate for being an instance of such typeclasses
17:53:55 <Alpounet> and the "let's find a typeclass for that data type and that operation" approach isn't that much good in my opinion.
17:54:07 <Alpounet> just make a function that does that
17:54:12 <Alpounet> and it'll be fine
17:54:51 <sshc> how does GHC do automatic derivation?
17:55:02 <sshc> can I automatically derive Binary?
17:55:20 <Alpounet> it derives according to the types used in the data type definition
17:56:01 <Alpounet> if these types have instances for the typeclass you want to derive from, then GHC can handle that, IIRC.
17:56:59 <sshc> should I define a Vector data type with or without a paremeterised scalar type?
17:57:19 <ddarius> For certain standard classes, derivations are wired in to the compiler.  There are some extensions extending this functionality, but no way to make entirely new derivations.
17:57:48 <ddarius> There is a package], derive, that has some metaprogramming stuff to derive new classes.
17:57:50 <sshc> "data Vector = Vector Double Double Double" or "data Vector a = Vector a a a"?
17:58:05 <ddarius> sshc: It depends on what you are going for.
17:58:46 <sshc> ddarius: elaborate?
17:59:02 <ddarius> sshc: You're the one that needs to elaborate.
17:59:48 <sshc> what should I be looking for when I use a paremeterised scalar type?
18:00:15 <ddarius> sshc: What are -you- trying to accomplish?
18:06:46 <heatsink> I implemented type class inference as described in the Typing Haskell in Haskell paper.
18:06:55 <heatsink> It was unsatisfying.  I was expecting more magic.
18:07:25 <ddarius> heatsink: Type class inference is just a simple logic language.
18:07:42 <ddarius> Or rather, type class instance resolution is.
18:08:00 <pikhq> heatsink: There's surprisingly little "magic" in Haskell.
18:08:05 <heatsink> Ah, well, I never learned logic programming.
18:08:48 <pikhq> Lessee... Magic... Magic...
18:08:58 <heatsink> @quote magic
18:08:59 <lambdabot> dons says: ah, via the magic of SCIENCE
18:09:05 <pikhq> IO, State, and unboxed types. That's the magic.
18:09:08 <dolio> ddarius: Incidentally, with regard to lostman's problem about (-)A : Sets^C -> Sets having a right adjoint, is it true for arbitrary categories C, and not just discrete categories?
18:09:21 <Cale> How about getContents?
18:09:25 <Cale> That's pretty magic
18:09:31 <dolio> You said something about Yoneda, but I didn't copy it down.
18:09:36 <Cale> Though I guess that's lumped in with IO
18:09:39 <pikhq> Cale: Oh, fine, fine. unsafePerformIO and unsafeInterleaveIO.
18:09:41 <Alpounet> @src getContents
18:09:42 <lambdabot> getContents = hGetContents stdin
18:09:56 <pikhq> @src hGetContents
18:09:56 <lambdabot> Source not found.
18:10:01 <Cale> It's a bit more magic than plain IO
18:10:06 <Alpounet> hGetContents is magic.
18:10:14 <pikhq> Huh. I thought that was unsafeInterleaveIO'd.
18:10:46 <ddarius> dolio: I'm pretty confident that it is true for arbitrary categories (though I didn't try to put my proof through Agda or Coq).  I mentioned before that it looks like a pretty straightforward corollary to the so-called Yoneda isomorphisms (related to, but different than, the Yoneda lemma.)
18:10:47 <Cale> The unsafe things aren't just magic, they're part of the implementation of the magic. :)
18:11:00 <pikhq> Cale: Heheh.
18:11:59 <Alpounet> Kleisli stuffs are magic
18:12:14 <pikhq> No, they're just clever.
18:12:35 <Alpounet> heh
18:13:16 <ddarius> Given F : C^op -> Set and G : C -> D, the indexed colimit, F*G, is characterized by the universal property: Hom(F*G, -) ~ Nat(F, \X.Hom(GX, -)).
18:13:43 <ddarius> dolio: Given D = Set, it is possible to show that F*G ~ G*F.
18:14:11 <dolio> Ah, that does look quite similar.
18:14:53 <ddarius> One of the Yoneda isomorphisms is then: Hom(-,X)*F ~ FX
18:15:23 <ddarius> So (-)A is isomorphic to Hom(=,A)*-
18:21:26 <ddarius> YA*F ~ F*YA and Hom(F*YA,-) ~ Nat(F, \X.Hom(Hom(X,A), -)) where Y is the Yoneda embedding, Y = \A.\B.Hom(B,A).
18:22:11 <ddarius> So (-)A ~ YA*F ~ F*YA and that is right adjoint to \X.Hom(YAX,-).
18:23:24 <ddarius> Er that -has- the right adjoint ...
18:24:51 <dolio> I was kind of wondering if plugging in my solution to the discrete case would just work in general. I started writing it all down in Agda, but formalizing all the necessary stuff is a bit tedious.
18:25:23 <dolio> But, it looks like it does, if I'm reading your description right.
18:25:30 <ddarius> dolio: It does look like it would.  My proposed right adjoint is the same as the general one you suggested if I recall correctly.
18:27:19 <ddarius> dolio: Did you end up with your G functor in part inspired by the possibility of generalizing, or because that was just the natural route to you, or what?
18:27:52 <ddarius> dolio: As I remarked earlier, I found the fact that you arrived at the particular way of expressing G for the special case interesting.
18:28:58 <dolio> Well, I just started with the discrete-categories-are-sets thing, and wrote down the problem in using C : Set in agda, trying to figure out what G I could prove it for.
18:29:58 <dolio> Then I realized that if I had X == A, it would give me the right evidence I needed to write the function. And subsequently realized that Hom(X,A) was part of the discrete-categories-are-sets analogy.
18:30:24 <dolio> Or, Hom(X,A) was analogous to X == A.
18:30:50 <dolio> But it's not clear from that perspective that it would generalize to all categories.
18:49:29 <ddarius> I wish Agda wasn't as tied to emacs as it is.
18:50:40 <copumpkin> yeah
18:51:30 <dolio> Unfortunately, I think it's by far the easiest way to get a good interactive programming environment up and running.
18:52:03 <dolio> Especially since the people building it probably care more about working on the language end of things than the interface end.
18:53:50 <copumpkin> yeah
18:54:04 <copumpkin> now I just need an arrogant prick to make a beautiful OSX front end
18:54:47 <Loriel> Someone ought to write a gtk2hs frontend!
18:54:58 <Saizan> i wonder how couple with emacs it actually is, considering most of the work is done by the haskell api used in ghci
18:59:08 <ddarius> Saizan: It's not so tightly coupled that you can't use it at all without emacs, but there is a significant loss/barrier to using anything other than emacs.
19:00:39 <dolio> At the very least, to use it with anything else, you'd have to write a plugin that can communicate with the ghci session in the background roughly as well as the emacs mode does.
19:01:03 <dolio> Other than just running an interactive agda session, which is significantly less helpful.
19:02:02 <dolio> I don't really know how the communication works. Is it producing emacs specific commands, for instance?
19:04:05 <Saizan> i'd suspect the highlighting info is the only emacs specific output
19:04:36 <merehap> isn't there a vim plugin for emacs? would using that reduce dependence on emacs?
19:07:04 <merehap> well, at least reduce the inconvenience of having to use meacs, I mean
19:07:14 <merehap> emacs*
19:08:08 * Saizan likes emacs
19:08:28 <merehap> :(
19:08:56 <dolio> Having switched back due to Agda, I don't really miss vim.
19:09:27 <dolio> Although I still use vim for some quick editing.
19:10:30 <merehap> when I first decided upon getting a first editor, I tried emacs, but couldn't get an intuitive feel for it after a week, vim just worked for me after a day...but to each their own
19:11:36 <Philonous> merehap: http://www.informatik.uni-hamburg.de/RZ/software/emacs/viper/viper_3.html
19:11:38 <merehap> well, not a first editor, but a unix editor anyway
19:13:07 <merehap> ah nice, that will come in handy when the time to learn agda comes, thanks
19:13:52 <Quadrescence> merehap: emacs needs 10 years
19:14:00 <Quadrescence> dolio: run emacs daemon
19:15:02 <NullEntity> Is it worth learning Haskell for Project Euler?
19:15:23 <Saizan> no, learn haskell for something useful :P
19:15:27 <Quadrescence> Might as well learn haskell just to get some experience with pure func programming
19:15:27 <theorbtwo> Project Euler?
19:15:30 <Quadrescence> Then learn a better language
19:15:55 <Philonous> Like Cobol
19:16:34 <mreh> old languages have names like Cobol, and Agol
19:16:41 <Quadrescence> algol
19:16:45 <mreh> with numbers!
19:16:47 <NullEntity> Well I know C(++),but I've seen tons of people who use Haskell
19:16:47 <mreh> lots of numbers
19:16:55 <mreh> NullEntity, where?
19:16:58 <mreh> in #haskell?
19:17:16 <Quadrescence> NullEntity: haskell will be a mindfuck for you, 99%, so learn it, get it out of the way, then go back to C
19:17:20 <merehap> haskell is fun for project euler, if that is the answer you are looking for
19:17:20 <Quadrescence> (but not C++)
19:17:42 <NullEntity> Quadrescence: I noticed :P
19:18:31 <merehap> Quadrescence: so C is a better language?
19:18:50 <Philonous> C? Bah. Too much structure. too many high level concepts.
19:19:01 <merehap> I know, that gets me everytime :)
19:19:12 <hatds> Go back?  From Haskell? Whaa...
19:19:33 <theorbtwo> C and Haskell are very different things, and useful for different purposes.
19:19:45 <merehap> once you go Haskell, you can't go Backell
19:19:49 <theorbtwo> I'd never try to make a device driver for the linux kernel in haskell.
19:20:17 <Saizan> but you could if your kernel were written in haskell!
19:20:24 <merehap> there is a nice article on making linux kernel modules in Haskell, actual
19:20:24 <Philonous> theorbtwo: Others don't seem to be as disciplined: http://tommd.wordpress.com/2009/09/13/kernel-modules-in-haskell/
19:20:27 * drdr screams at the thought
19:20:47 <ddarius> theorbtwo: Hasn't stopped others.
19:22:03 <drdr> ok so in haskell a stands for any right?
19:22:16 <merehap> any type, yes
19:22:18 <medfly> did someone just say "I've seen tons of people who use Haskell"?
19:22:22 <copumpkin> b stands for bullshit
19:22:22 <medfly> do you mean like, right here?
19:22:31 <merehap> :t (+)
19:22:32 <lambdabot> forall a. (Num a) => a -> a -> a
19:22:34 <Philonous> hanyskell
19:22:48 <merehap> in the above, you have any a that is a Num, drdr
19:22:54 <drdr> ok
19:22:58 <drdr> tahts helpfull
19:23:09 <drdr> im still not understaning half of this stuff
19:23:24 <merehap> have you tried lyah, drdr?
19:23:26 <drdr> but thats never stoped me before
19:23:29 <merehap> @where lyah
19:23:29 <lambdabot> http://www.learnyouahaskell.com/
19:23:34 <Quadrescence> merehap: I am suggesting that, yes, C is a better language than Haskell
19:23:46 <drdr> thats what im useing
19:24:03 <merehap> in what sense, Quadrescence?
19:24:35 <mreh> LANGUAGE WARS!!!
19:24:36 <Quadrescence> merehap: In the total sense.
19:24:41 <merehap> drdr: cool ask away your questions here
19:24:44 <theorbtwo> Hm.  That's very interesting...
19:24:46 <drdr> ok
19:25:15 <mreh> Quadrescence, you aren't going to get many people who agree with you in here
19:25:25 <mreh> ...so why did you come in here?
19:25:35 <merehap> Quadrescence: ok, a troll, we would be happy to have a civilized discussion, you know...
19:26:12 <mreh> C doesn't look nicer than Haskell, Haskell is much prettier
19:26:17 <Quadrescence> merehap: I am not trolling. By total, I mean "the sum of all qualities and disadvantages". And I don't find such an accusation respectful.
19:26:19 <merehap> drdr: do you know what that type signature meant?
19:26:48 <merehap> uh, total sense doesn't imply that, but we would be happy for some details to get a discussion started...
19:27:03 <mreh> yes, where is this discussion going?
19:27:04 <Quadrescence> merehap: What does "total" mean? [rhetorical question[
19:27:04 <NullEntity> I think I can come to like Haskell
19:27:05 <Quadrescence> ]*
19:27:06 <NullEntity> "If you say that a is 5, you can't say it's something else later because you just said it was 5. What are you, some kind of liar?"
19:27:06 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a -> a))
19:27:20 <mreh> I may like to get off if it is going somewhere I don't want to go
19:27:25 <Quadrescence> mreh: I know I didn't come here to attempt to convince anyone that C is better.
19:27:41 <merehap> NullEntity: it is probably like the math you've learned in school, in that way
19:28:00 <merehap> then why did you say it, Quad?
19:28:15 <Quadrescence> merehap: Because you asked me
19:28:28 <NullEntity> I sort of get it. I guess I should keep reading to find out, but I'm sort of confused by the "purely functional" part. I just don't really understand it.
19:28:32 <mreh> come on guys, #haskell has a reputation for being a friendly place, be nice!
19:28:32 <merehap> not very helpful to us just making an assertion and not being willing to elaborate
19:29:00 <Quadrescence> NullEntity: Every function has an input and an output. For some input, the output must ALWAYS be the same
19:29:04 <mreh> NullEntity: it's to do with referencial transparency
19:29:12 <mreh> what Quad just said
19:29:20 <mreh> I gave you the technical definition
19:29:33 <NullEntity> Okay, I (sort of) get it
19:29:39 <Quadrescence> NullEntity: f(5) = 10. No matter when and where in the program I use f(5), it should always mean 10.
19:29:59 <Quadrescence> In C or C++ you can have static variables which can make f(5) be 6, then 7 then 8, or something else.
19:30:06 <Saizan> and a = n in haskell really means that a and b are the same
19:30:06 <merehap> NullEntity: imagine that you are building up one big math equation, in a way that is what a program is in Haskell
19:30:16 <dolio> Technically, purity is not the same as referential transparency, at least as purity has been defined in technical senses.
19:30:19 <Saizan> a = b
19:30:54 <mreh> forever!!
19:31:02 <dolio> Not that most people are specifically referring to the one (?) paper on the topic when they use the term, of course.
19:31:42 <mreh> I'm having real trouble working out how an Arrow can have state
19:31:51 <theorbtwo> A haskell program is closer to algerbra then to a description of what you want the computer to do.
19:31:54 <mreh> and how it can have a notion of time
19:32:03 <hatds> oh? what is purity in the other sense?
19:32:21 <theorbtwo> Time flies like an arrow.  Fruit flies like a bannana.
19:32:21 <mreh> theorbtwo, I *like* to think of as a description of what to do
19:32:39 <mreh> it's an executable specification
19:32:58 <theorbtwo> mreh: It more describes what you want to get out then what you want to do.
19:33:33 <mreh> no it doesn't it, it describes how to get it, not the actual steps you need to carry out to get it
19:33:36 <theorbtwo> The compiler will do things in the order it feels like doing them.  It may not do parts at all, if it doesn't think it needs to get off it's Lazy ass and do them -- if you never use the result.
19:34:20 <dolio> hatds: It has to do with results being (relatively) invariant with respect to differing evaluation strategies.
19:34:21 <mreh> what I just said was bollocks
19:34:55 <mreh> so Arrows, how can they have a state? They're just like black boxes to me, you turn the handle and something comes out immediately
19:35:13 <Quadrescence> NullEntity: In C, one is used to doing stuff in a sequential manner: assign this, call this function, increment this, loop while variable is less than 10, return,...; in Haskell, one typically makes a lot of tiny functions, and then composes the functions together to get a result. So, Haskell can deal with functions better. You can make lists of functions, you can make functions return functions, you can make functions eat functions that m
19:35:14 <Quadrescence> ake functions that spit functions. Bla bla bla.
19:35:17 <merehap> mreh: it should be only in the same way a monad can have state
19:35:34 <mreh> merehap: an implicit kind of state?
19:35:40 <Cale> theorbtwo: Well, it's not that far away from a description of what you want the computer to do if you assume lazy evaluation.
19:35:54 <Saizan> mreh: what do you mean by having a state?
19:35:59 <Cale> theorbtwo: Though GHC can and does deviate from the lazy evaluation order.
19:36:03 <NullEntity> I think I'd understand it better once I get to the examples
19:36:04 <merehap> mreh: yeah, a boring kind of state in which you are just hiding the plumbing
19:36:12 <mreh> I find that exciting
19:36:25 <dolio> hatds: So, Haskell terms will generally give you the same results whether you choose strict evaluation or lazy evaluation, except that you might get bottoms instead of well-defined values in some cases.
19:36:34 <merehap> NullEntity: yes, I think the best way to learn it is to make it intuitive through examples and practice
19:36:34 <mreh>     It is important to note that some signal functions are stateful, in that they
19:36:34 <mreh> accumulate information over time. integral is a perfect example of such a func-
19:36:34 <mreh> tion: by definition, it sums instantaneuous values of a signal over time.
19:36:40 <mreh> that's from the Yampa documentation
19:36:57 * theorbtwo thinks it's way too early to bring bottoms into this conversation.
19:37:01 <merehap> mreh: well, ok, it might be exciting, but what I meant is that it doesn't just appear out of no where
19:37:05 <dolio> But bottoms-vs-non-bottoms is allowed by the definition.
19:37:11 <Cale> Any evaluation order will give the same result if it terminates, and if any evaluation order terminates, then lazy evaluation does.
19:37:26 <Quadrescence> NullEntity: At some point you'll perhaps want to do some stuff sequentially. In C, pretend the semicolon is its own operator. doThing ; doNext ; doNext. In C, ; can mean "do the thing before me, then do the thing after me, and anything done before me affects what is done after me". Haskell makes this sort of behavior explicit. In haskell, you generalize this concept, and are able to "overload the semicolons" to do any sort of thing
19:37:28 <merehap> mreh: there isn't magic to it
19:37:46 <mreh> merehap: I know, but it's just so useful
19:38:09 <merehap> mreh: oh yeah, I fully agree with you there, I guess I regret using the word boring...
19:38:10 <mreh> Saizan, the Yampa doc goes on about integral
19:38:45 <theorbtwo> It's  not so much that Arrow is hiding the plumbing as "do" is, IIRC.
19:39:06 <Saizan> mreh: in the case of yampa each arrow is going to produce an output for every value in the stream you apply it to, what that doc is saying is that each arrow can change the way it'll react to future inputs based on the past ones
19:39:09 <mreh> it's >>= and >> that are hiding the plumbing
19:39:13 <dolio> So "purity" in that sense would be a more widely reaching attribute, since you could conceivably have a referentially transparent function that produced different results under different evaluation orders (but it'd always give the same results for a given evaluation order).
19:39:19 <dolio> Although I don't have an example of that.
19:39:40 <theorbtwo> Statements from me about mondads should be taken with a metric fuckton of salt.
19:39:45 <Saizan> mreh: so it's not like the State monad in this case
19:39:52 <dolio> Actually, copumpkin's teaspoon might (arguably) be an example.
19:40:02 <Quadrescence> dolio: Any rewrite system that isn't confluent would exhibit that property
19:40:04 <merehap> theorbtwo: are mondads like crawdads? yummy...
19:40:20 <NullEntity> I'm downloading GHC. "This is a complete build, and should work for Microsoft Windows 2000, XP and Vista. It also includes support for compiling C++ files." Why would you want it to compile C++ files?
19:40:36 <hatds> FFI?
19:40:41 <mreh> Saizan: oh, thanks
19:40:57 <theorbtwo> In essence, each statement inside the do takes a state parameter, and returns a state, which gets passed to the next statement.
19:41:00 <merehap> NullEntity: yes, it is quite nice to be able to interface your haskell code with C/C++ code
19:41:06 <mreh> Saizan: how can the integral output be useful unless you've applied it to a whole stream?
19:41:22 <merehap> NullEntity: maybe a library or maybe just memcpy...
19:41:33 <NullEntity> Okay, that makes sense
19:41:46 <theorbtwo> "Assignment" just means returning a modified version of the state you were passed in.
19:41:56 <Saizan> mreh: you apply it to a whole stream, but at each moment it'll return the integral of the values he has seen up to that point
19:42:14 <NullEntity> So can Haskell access a C++ function?
19:42:26 <theorbtwo> (Note the *copy*; it is, of course, still impossible to modify anything.)
19:42:26 <hatds> only through extern "C" I think
19:42:58 <merehap> NullEntity: yes, and this is particularly useful for Unix, but useful for Windows too, since so much code (especially older code) is written in C
19:43:56 <SamB_XP> merehap: uh, no, not C++!
19:45:02 <merehap> SamB_XP: do you mean that I am wrong about Haskell interfaces with C++ or are you just imagining the horror of using C++?
19:45:15 <dolio> There used to be a tutorial somewhere about importing C++ functions directly via the FFI.
19:45:18 <merehap> interfacing*
19:45:24 <dolio> You have to figure out the mangled names, though.
19:45:43 <mreh> that sounds like a very busy weekend
19:45:50 <merehap> dolio: oh yeah, I recall reading that
19:48:08 <merehap> NullEntity: are you sure it wasn't cpp you saw? it seems that Haskell doesn't interface with c++ easily
19:48:34 <merehap> NullEntity: cpp stands for c pre-processor
19:48:56 <NullEntity> http://www.haskell.org/ghc/download_ghc_6_12_1.html#windows
19:49:13 <NullEntity> It's definitely C++
19:49:54 <hatds> it does interface with C++ without any difficulty I can see
19:50:02 <merehap> NullEntity: huh, maybe what I was saying before was right, either way, I haven't used what is being described there
19:50:09 <hatds> I mean, up to extern "C"
19:50:40 <merehap> yeah, that seems reasonable
19:52:20 <Saizan> what that sentence means is "we bundle gcc", essentally
19:53:44 --- topic: '["msg an op if you can't talk", "find ops: /msg ChanServ access list #haskell", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
19:53:44 --- topic: set by mauke on [Mon Jan 18 11:11:51 2010]
19:54:23 <NullEntity> Oh... my... god...
19:54:26 <NullEntity> I just got it!
19:54:36 <NullEntity> It's like excel formulas, right?
19:54:45 <merehap> yes, pretty similar, actually
19:54:53 <SamB_XP> indeed
19:54:55 <merehap> Excel is a form of functional programming
19:55:05 <SamB_XP> except it's a lot nicer since you can add your own named functions easily ;-)
19:55:22 <merehap> along with a few other things :)
19:55:23 <SamB_XP> and you aren't constrained to that dumb grid
19:55:29 <NullEntity> Yay
19:55:46 <SamB_XP> that makes it hard to deal with parametrically-sized problems and so on ...
19:56:03 <merehap> I just hope that you don't hate Excel :)
19:56:15 <NullEntity> I don't :P
19:57:31 <interferon> is there a way to call lookup with a default value in case the result is nothing?
19:57:35 <NullEntity> Ah, the example bar (bar 3) will be hard for me to remember =S
19:57:36 <interferon> the case statements are unwieldy
19:57:46 <dolio> @type fromMaybe
19:57:47 <lambdabot> forall a. a -> Maybe a -> a
19:58:05 <SamB_XP> @type maybe
19:58:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:58:15 <SamB_XP> oh, yeah, fromMaybe it is
19:58:38 <interferon> thanks
19:58:42 <merehap> NullEntity: what is hard about it?
19:59:41 <NullEntity> Just remembering that coming from C-styled languages where it'd be something like bar(bar, 3)
19:59:42 <dino-> There was one time when I felt it would be clearer to frame my answer to a manager in a form that he was more comfortable with. I made an Excel spreadsheet with "No." in cell A1
19:59:55 <NullEntity> I mean, that's what I'd interpret it as.
20:00:05 <merehap> true
20:00:49 <merehap> NullEntity: I don't want to confuse you, but there is another way of writing that: bar $ bar 3
20:01:15 <merehap> $ acts in the place of those parenthesis
20:01:56 <NullEntity> I'd probably want to learn it the 'standard' way first
20:02:06 <merehap> agreed
20:02:34 <merehap> NullEntity: one of the things I like about haskell is that it uses less syntax than most languages
20:02:59 <merehap> so parenthesis aren't required for function calls
20:03:14 <Cale> (only for grouping)
20:03:20 <merehap> though obviously C-like languages use parenthesis for function calls and grouping
20:03:59 <NullEntity> Yeah, I like that obvious grouping
20:04:16 <tensorpudding> where did C syntax come from?
20:04:32 <merehap> isn't it pretty much like algol before it?
20:04:33 <ddarius> NullEntity: bar (bar 3) means bar(bar(3))
20:04:36 <merehap> I'd have to check
20:04:49 <NullEntity> Yeah, I'm starting to get that
20:05:12 <Philonous> excel seems to be a better example for FRP than for function programming in general. Because you can chance cells (and all the dependent cells change accordingly)
20:05:13 <Cale> NullEntity: and function application associates to the left, so that f x y z means ((f x) y) z
20:05:53 <ddarius> NullEntity: The equivalent to C-style syntax's bar(bar, 3) would be bar bar 3
20:05:54 <merehap> hm C syntax came from B came from BCPL
20:05:57 <SamB_XP> Philippa: what, just because you don't need to hit F5, you think it's like FRP?
20:06:09 <tensorpudding> i'm curious what motivated early language syntax
20:06:20 <tensorpudding> was it significantly easier to parse?
20:06:21 <Cale> tensorpudding: mathematics to some extent
20:06:32 <NullEntity> FRP? The only FRP I know about is fiberglass reinforced plastic :D
20:06:36 <ddarius> And hardware to a larger extent...
20:06:53 <Cale> But somehow people forgot that when you write f(x,y) in mathematics, f is really being applied to a pair.
20:07:01 <merehap> NullEntity: don't worry about FRP yet, Functional Reactive Programming
20:07:06 <Cale> and they neglected to actually make pairs values.
20:07:23 <SamB_XP> Cale: most people probably didn't really notice that
20:07:24 <Loriel> Values of R^2 or whatever?
20:07:34 <Cale> Loriel: yeah
20:07:36 <merehap> tensorpudding: http://en.wikipedia.org/wiki/BCPL#Design
20:07:44 <Gracenotes> tensorpudding: you've read http://cm.bell-labs.com/cm/cs/who/dmr/chist.html ?
20:07:54 <ddarius> Cale: Well, for side-effectful languages, the natural arrows would be from a (categorical) tensor product for multiparameter functions.
20:08:18 <SamB_XP> ddarius: what was that ?
20:08:26 <Gracenotes> although it may not deal with the curlies particularly
20:08:32 <Loriel> I am not sure that would really work for C(?)
20:08:44 <Cale> Loriel: Well, C *could* have had tuples.
20:08:55 <Loriel> But it already had structs, who needs tuples
20:08:57 <Cale> It just didn't.
20:09:03 <merehap> Cale: should have, you mean :)
20:09:09 <Cale> Loriel: Well, to make the function calling syntax more uniform
20:09:19 <Gracenotes> Cale: like structs? ._.
20:09:25 <hatds> or for return values if nothing else
20:09:33 <Cale> merehap: I prefer the past tense when referring to C. ;)
20:09:34 <SamB_XP> it'd be hecka odd, though!
20:09:43 <merehap> Cale: :)
20:09:46 <Gracenotes> pretty tuple-product-of-type-like to me. just specifically declared, not a generic synta
20:09:48 <Gracenotes> x
20:09:55 <Cale> Gracenotes: yes, like structs
20:10:25 <Loriel> I guess they could have made structs a special case of typedef'ing tuples
20:10:34 <Cale> yeah
20:10:36 <SamB_XP> except did you know that the struct member names are important for compatability of struct types according to the standard?
20:10:37 <dino-> > let bar = (+ 1) in bar bar 3
20:10:38 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
20:10:40 <dolio> SamB_XP: Functions in C tend to be like (T,U,V) ~> W.
20:10:46 <dino-> > let bar = (+ 1) in bar $ bar 3
20:10:47 <lambdabot>   5
20:10:50 <ddarius> They could have just had tuples and structs...
20:10:56 <Cale> Or yes, both
20:11:00 <ddarius> Haskell has tuples and records (and data types).
20:11:12 <dolio> More sensibly than T -> U -> V ~> W, I guess.
20:11:21 <SamB_XP> too bad C hasn't got data types
20:11:37 <Gracenotes> well, you could certainly hack something together with CPP to auto-declare tuple structs
20:11:42 <merehap> ugh, all that global state and or cruft like ref parameters that could have been avoided in C, C++, Java, C#...
20:12:10 <merehap> I think tuples would have had a big impact if they where there
20:12:20 <Loriel> But you already can return structs in C
20:12:29 <Loriel> Just nobody does that. They actually like their * parameters.
20:12:35 <merehap> well, that's the cruft I'm talking about
20:12:52 <SamB_XP> Loriel: what they don't like is having to go and name a struct just so they can return two things!
20:12:53 <merehap> though in a language without access modifiers, I guess it isn't as bad in C
20:13:03 <dolio> And in OCaml, there's weirdness about f (a -> b) vs. a -> f b.
20:13:06 <ddarius> For C, I don't think it would be such a big deal.  For, say, C#, tuples would be very nice, or at very least, a reasonably named Pair class in the standard libraries.
20:13:13 <ddarius> (There is KeyValuePair or whatever.)
20:13:18 <NullEntity> When you compare lists ([2, 4, 3] > [3, 3, 3]) how does it compare? does it compare the max values?
20:13:30 <ddarius> NullEntity: Lexicographically.
20:13:36 <merehap> ddarius: which seems to be meant for Dictionaries only
20:13:41 <ddarius> NullEntity: The same way you compare, "dad" and "dog"
20:13:59 <ddarius> (Indeed, in Haskell, "dad" is a list of characters ['d','a','d'])
20:14:08 <Loriel> The same way you compare 243 and 333 :)
20:14:17 <SamB_XP> Loriel: that doesn't work!
20:14:26 <SamB_XP> > 13 > 1562
20:14:28 <lambdabot>   False
20:14:32 <Loriel> Pad with zeros!
20:14:34 <SamB_XP> > "13" > "1562"
20:14:35 <lambdabot>   False
20:14:48 <SamB_XP> hmm
20:14:49 <hatds> > "16" > "1562"
20:14:50 <lambdabot>   True
20:14:58 <NullEntity> "dad" > "dog"
20:15:00 <NullEntity> True
20:15:00 <SamB_XP> ah, that's a better example yes
20:15:02 <NullEntity> lol
20:15:23 <Loriel> How do I tell @src to get me the instance for lists of Ord?
20:15:40 <NullEntity> So does it basically sort from smallest to largest?
20:16:06 <SamB_XP> > sort
20:16:07 <Loriel> NullEntity: It compares the first element. If they compare unequal, that is the result. If not, it moves on to the next element.
20:16:07 <lambdabot>   {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
20:16:13 <NullEntity> I'm looking at the Wikipedia artivle on Lexicographical order and I'm suffering from slight confusion  :O
20:16:19 <Philonous> > "Eiffel tower" > "Sears tower"
20:16:20 <hatds> no, it compares the 1st elements of each and if it is a tie it compares the 2nd, etc.
20:16:21 <lambdabot>   False
20:16:23 <SamB_XP> > sort :: [Bool] -> [Bool]
20:16:24 <lambdabot>   []->
20:16:24 <lambdabot>    []
20:16:24 <lambdabot>  [True]->
20:16:24 <lambdabot>    [True]
20:16:24 <lambdabot>  [True,True]->
20:16:26 <lambdabot>    [True,True]
20:16:28 <lambdabot>  [True,True,Tr...
20:16:42 <Loriel> > sort :: [[()]]->[[()]]
20:16:43 <lambdabot>   []->
20:16:43 <lambdabot>    []
20:16:43 <lambdabot>  [[]]->
20:16:43 <lambdabot>    [[]]
20:16:43 <lambdabot>  [[],[]]->
20:16:45 <lambdabot> [3 @more lines]
20:16:50 <merehap> lexicographical order is basically alphabetical order with a few more symbols thrown in
20:16:55 <merehap> like numbers
20:17:00 <Loriel> This Show instance is mysterious
20:17:09 <SamB_XP> Loriel: comes from SmallCheck
20:17:21 <Loriel> > reverse
20:17:22 <lambdabot>   {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
20:17:32 <Loriel> > id :: [()] -> [()]
20:17:33 <lambdabot>   {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
20:17:41 <SamB_XP> > id
20:17:42 <lambdabot>   {()->()}
20:17:51 <SamB_XP> > id :: Int->Int
20:17:53 <lambdabot>   {-3->-3;-2->-2;-1->-1;0->0;1->1;2->2;3->3}
20:17:53 <Philonous> > zipWith5
20:17:54 <lambdabot>   {()->{()->{()->{()->{()->()}}}}}->
20:17:54 <lambdabot>    []->
20:17:54 <Loriel> > (>>=)
20:17:55 <lambdabot>      []->
20:17:57 <lambdabot>        []->
20:17:59 <lambdabot>   No instances for (Test.SmallCheck.Serial (m a),
20:18:01 <lambdabot>          [...
20:18:03 <lambdabot>                    GHC.Show...
20:18:24 <xerox> if all the symbols were more sparse it would look like a night sky
20:18:41 <Loriel> > sequence :: [[()]] -> [[()]]
20:18:43 <lambdabot>   []->
20:18:43 <lambdabot>    [[]]
20:18:43 <lambdabot>  [[]]->
20:18:43 <lambdabot>    []
20:18:43 <lambdabot>  [[],[]]->
20:18:45 <lambdabot> [4 @more lines]
20:19:11 <merehap> xerox: that was poetic :)
20:19:24 <xerox>                .        *                 o
20:19:32 <xerox>    *     .                                      .
20:19:47 <merehap> wait, I think I just saw Sirius...
20:20:04 <xerox> whew who did write that in the sky, oh.
20:22:15 <NullEntity> Holy crap, I just got to infinite lists and take. This is powerful o_o
20:22:42 <hatds> watcha reading?
20:22:52 <xerox> > let odds = map (+1) evens; evens = 0 : map (+1) odds in (take 10 odds, take 10 evens)
20:22:54 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19],[0,2,4,6,8,10,12,14,16,18])
20:23:16 <Raynes> (take 20 (iterate inc 1))
20:23:20 <Raynes> Oops, wrong language. ;)
20:24:05 <NullEntity> Just the Learn you Haskell guide :P
20:24:23 <NullEntity> I can (easily) solve Euler 1 with this!
20:24:38 <NullEntity> Now I know why people use Haskell
20:25:08 <SamB_XP> so, what haskell did you learn ?
20:25:10 <dolio> Yes, project Euler is the main reason.
20:25:41 <SamB_XP> dolio: hahaha
20:25:46 <Raynes> NullEntity: Infinite lists and such aren't really specific to Haskell.
20:25:46 <SamB_XP> I think he didn't mean it that way ;-P
20:26:03 <SamB_XP> Raynes: they're a bit tricky to do in lisp
20:26:03 <merehap> Raynes: well, they are idiomatic to it
20:26:12 <SamB_XP> certainly the library support is lacking!
20:26:17 <NullEntity> I mean it's so simple compared to the C++ I did it in
20:26:30 <Raynes> SamB_XP: They're pretty easy to work with in Clojure, which is all I can speak for.
20:26:41 <Raynes> NullEntity: Oh certainly. You don't have to go far to get better than that. :p
20:26:47 <merehap> NullEntity: cool :)
20:27:10 <NullEntity> Quick question: how do I add together the numbers in a list?
20:27:29 <merehap> > zipWith (+) [1..] [3,5..]
20:27:30 <NullEntity> I think I might have breezed past that >.<
20:27:30 <copumpkin> > sum [1..5]
20:27:30 <lambdabot>   [4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,7...
20:27:31 <lambdabot>   15
20:27:38 <NullEntity> Yep, I did xD
20:27:39 <merehap> oops, nvm
20:27:50 <merehap> what copumpkin said
20:27:50 <Raynes> > foldl (+) 0 [1..]
20:27:58 <lambdabot>   mueval: ExitFailure 1
20:28:02 <Raynes> Heh heh.
20:28:10 <copumpkin> > foldr (+) 0 [1..] > (100 :: Natural)
20:28:12 <pikhq> > foldl (+) 0 [1..5]
20:28:14 <lambdabot>   Not in scope: type constructor or class `Natural'
20:28:14 <lambdabot>   15
20:28:17 <copumpkin> wtf
20:28:20 <copumpkin> where did Natural go?
20:28:31 <Raynes> copumpkin: The woods.
20:28:32 <merehap> I ated it
20:28:35 <Raynes> Naturally.
20:28:57 <pretsas> I get basic haskell stuff, but Monads confuse me
20:29:10 <Raynes> Of course they do. :p
20:29:14 <pretsas> Can anyone suggest some decent reading material?
20:29:17 <merehap> pretsas: don't worry about monads, hold off for a while on them
20:29:21 <NullEntity> Why can't I do sum take 2 [1..10]?
20:29:33 <merehap> > sum (take 2 [1..10])
20:29:34 <lambdabot>   3
20:29:46 <pretsas> So then how do I do IO without monad stuff?
20:29:53 <merehap> pretsas: use do notation
20:29:54 <Raynes> merehap: When you get to a point where you think you're ready, this is a great monad tutorial: http://www.muitovar.com/monad/moncow.html
20:29:56 <pikhq> NullEntity: In C-like terms, that's sum(take,2,[1..10]);
20:30:12 <pikhq> NullEntity: When what you *want* is sum(take(2,[1..10]));
20:30:18 <pikhq> So, sum (take 1 [1..10]
20:30:28 <pikhq> Erm.
20:30:33 <pikhq> sum (take 2 [1..10])
20:31:16 <hatds> when stacking functions a good habit is to get into the style of    f . g . h . k $ last_func param1 param2 param3
20:31:19 <merehap> pretsas: have you looked at do notation before? if you understand that, you can learn monads probably 4 months later and not lose out on anything
20:31:42 <pretsas> I've only looked at it a little bit
20:31:52 <pikhq> pretsas: Monads are much simpler than they appear. The only reason why it's hard is that you expect to *need* to understand them, that you think you *need* them to "just click".
20:32:00 <merehap> it should look quite similar to a standard imperative program
20:32:02 <pretsas> YAHT got into it pretty fast without explaining to much
20:32:18 <pretsas> I'm reading the LYAH on IO right now
20:32:18 <pikhq> When, in fact, all you need to know is that (>>=) and return have meaning. And that this meaning lets do notation work.
20:32:31 <merehap> pretsas: yeah, that was a mistake
20:32:35 <pretsas> I've found that I usually get the stuff explained there
20:32:38 <merehap> pretsas: the lyah way is good
20:33:00 <dino-> I absolutely loved in byorgey's Typeclassopedia he wrote "In the end, despite all the hoopla, Monad is just another type class."
20:33:03 <merehap> pretsas: imo, all of the early haskell tutorials get into monads way too soon
20:33:18 <merehap> dino-: my thoughts exactly
20:33:30 <pikhq> Monads are cool and all, but they're hard to get without fully grokking type classes.
20:33:49 <pikhq> (once you've got that, then it's pretty easy. "Oh, so >>= and return are defined? Why was I expecting more?")
20:34:20 <merehap> lyah gives you what you need to get pretty far, and it barely talks about monads at all
20:35:03 <c_wraith> lyah has a section that will cover monads, when the author writes it.  Until then, its coverage of monads is about along the lines of "they exist and will be explained later"
20:35:22 <hatds> It's really IO, List and Maybe that you'll be using 99% of the time anyway.  Monads are design-related reading material.
20:35:24 <dolio> That's because BONUS is still writing that part, right? :)
20:35:37 <merehap> that's what I thought
20:36:47 <merehap> who wants to join me in taking down all of the webservers that host haskell tutorials that get into monads too early?
20:37:16 <merehap> it's a thought anyway...
20:38:32 <NullEntity> Hah, Haskell was faster than my C++...
20:38:38 <NullEntity> for Euler 1
20:38:47 <SamB_XP> merehap: you want to destroy the blogosphere ?
20:38:51 <merehap> NullEntity: I'll admit that that is a bit surprising
20:38:57 <c_wraith> also, I barely use the list or maybe monads.  The ones I'm most likely to use outside of IO are Reader/Writer/State or various control-flow techniques
20:39:03 <NullEntity> With my horrible coding it's not...
20:39:05 <merehap> SamB_XP: well yeah, a decent portion of it
20:39:35 <SamB_XP> NullEntity: yeah, lousy Haskell would tend to be faster than lousy C++, partly on account of being a great deal less lousy
20:39:47 <merehap> snort
20:40:05 <SamB_XP> at least in part because it is a great deal LESS entirely
20:40:13 <c_wraith> to err is human, to *really* foul things up requires C++?
20:40:21 <merehap> or PHP, yeah
20:41:17 <NullEntity> Yep
20:41:20 <sohum> is there a function from Z+ -> Z+ that is exactly the opposite of monotonic?
20:41:40 <c_wraith> what's the exact opposite of monotonic?
20:42:08 <dolio> x <= y -> f y <= f x?
20:42:14 <sohum> like, f is monotonic means x < y -> f(x) < f(y). so the opposite would be x < y -> f(x) > f(y).
20:42:15 <c_wraith> and does it have to be bijective?
20:42:29 <hatds> there can't be infinitely positive numbers in a strictly decreasing sequence if that is what you mean
20:42:30 <merehap> althought to be fair to C++, at least a subset of it (C) is useful, PHP, not so much :)
20:42:35 <dino-> btw, is that there things are headed in the future with typeclass redesign? Functor >-> Pointed >-> Applicative >-> Monad  ? Or is that the common desire?
20:42:43 <c_wraith> oh.  that's still monotonic, it's just monotonically decreasing
20:42:45 <SamB_XP> hatds: oh?
20:42:56 <SamB_XP> > iterate (/2) 1
20:42:58 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
20:42:58 <sohum> oh, fair enough
20:42:59 <dino-> sorry, is that WHERE
20:43:08 <c_wraith> The exact opposite of monotonic would be consecutive differences alternating in sign.
20:43:10 <SamB_XP> > iterate (/2) 1 :: Rational
20:43:11 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
20:43:12 <lambdabot>         against inferred t...
20:43:13 <hatds> that's not what he asked
20:43:18 <SamB_XP> > iterate (/2) 1 :: Ratio Integer
20:43:19 <lambdabot>   Couldn't match expected type `GHC.Real.Ratio
20:43:19 <lambdabot>                               ...
20:43:27 <sohum> SamB_XP: in Z+, sorry
20:43:32 <hatds> dino: probably going to stay as it is
20:43:38 <SamB_XP> sohum: oh
20:43:46 <SamB_XP> but what did I do wrong ?
20:44:04 <hatds> dino: a proposal would probably get a fair amount of discussion though
20:45:00 <sohum> hatds: hrrm. fair enough.
20:45:11 <SamB_XP> hatds: but where are we going to find enough red paint for an executor-class ?
20:45:28 <hatds> what? :)
20:45:33 <interferon> in parsec, how can i accept either an end-of-line or an eof?
20:46:08 <merehap> dino-: I'd say a common desire, I can't wait for it to be the case though...
20:46:08 * SamB_XP shamelessly references pinky & the brain and Booster Terrik at the same time
20:46:28 <NullEntity> Is there a constant for phi?
20:46:30 * copumpkin hands SamB_XP some shame
20:46:39 <copumpkin> no
20:46:40 <SamB_XP> interferon: (eof <|> newline), maybe?
20:46:46 <merehap> for a language that emphasizes cleanliness, I wish we could see more progress in type class hierarchies
20:46:56 <interferon> no, eof doesn't seem to work with <|>
20:47:01 <copumpkin> merehap: so do many people
20:47:02 <dino-> This goes all the way into the mud with the rest of it. fail must go, MonadPlus needs work, bring back comprehensions, yada.
20:47:13 <SamB_XP> dino-: yada YADA
20:47:37 <merehap> I'm with dino- on this one :)
20:47:52 <hatds> I'd like to see changes too, but I'm not sure I like the direction of class aliases and lots of complications
20:48:18 <SamB_XP> hatds: I'm not sure I do either
20:48:19 <merehap> hatds: you don't see it as simplifications?
20:48:26 <SamB_XP> mostly because I've tried to implement 'em!
20:48:49 <SamB_XP> but that might be John Meacham's fault more than anything :-P
20:49:01 <SamB_XP> (the fact that it didn't go well, I mean ;-P)
20:49:20 <hatds> typeclasses aren't supposed to be backwards compatible, class aliases feel like heading down the wrong path
20:49:30 <NullEntity> How do I divide floats?
20:49:32 <hatds> it's like changing a data type
20:49:39 <SamB_XP> hatds: not so much
20:49:59 <hatds> in 10+ years I think it is okay to admit "yes, we are changing the spec in a slight way everyone"
20:50:00 <Draconx|Laptop> NullEntity, /
20:50:03 <SamB_XP> it would be nice to be able to reorganize without gratuitous breakage!
20:50:35 <NullEntity> parse error on input '\'
20:50:39 <SamB_XP> I mean, when there's nothing to change except moving some methods to classes that didn't exist before...
20:50:44 <NullEntity> oops xD
20:50:48 <NullEntity> I see what I did there
20:51:17 <dolio> Class aliases have uses other than not breaking existing code.
20:51:37 <SamB_XP> that is also true
20:51:51 <SamB_XP> but I do wish someone would figure out how to implement them!
20:52:13 <dolio> Any time you might be tempted to write "class (A t, B t) => C t where", for instance.
20:53:05 <copumpkin> you can omit the where too!
20:53:09 <dolio> Or, perhaps only when there's an associated "instance (A t, B t) => C t where".
20:54:22 <Jarrett> sorry to interrupt, n00b question -- I've installed the Haskell Platform on XP and as far as I can tell, it should have parsec installed. but if I try to import Text.Parsec or Parsec, it just fails to load the interface for it. what am I doing wrong?
20:54:44 <SamB_XP> Jarrett: you missed the ParserCombinators or whatever
20:54:45 <dolio> Especially since that instance requires UndecidableInstances.
20:54:55 <SamB_XP> @hoogle Parsec
20:54:56 <lambdabot> module Text.Parsec
20:54:56 <lambdabot> module Text.ParserCombinators.Parsec
20:54:56 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
20:55:06 <SamB_XP> Jarrett: or, I'm an old fogey?
20:55:26 <Draconx|Laptop> Text.Parsec is parsec-3.
20:55:30 <SamB_XP> or perhaps you are trying to use Parsec 3 but the Platform only comes with 2?
20:56:05 <SamB_XP> Jarrett: now get off my lawn!
20:56:07 * SamB_XP shakes fist
20:56:12 <Jarrett> I uh.. I have no idea. :I I literally just installed the platform
20:56:14 <Jarrett> XD
20:56:36 <SamB_XP> I figure if I'm an old fogey I'd better act like it ;-P
20:56:40 <Jarrett> heheh
20:57:46 <Jarrett> so I'm looking in the install directory, and there sure is a parsec directory
20:57:57 <Jarrett> it's named parsec-2.1.0.1
20:58:42 <Jarrett> ..oh, so the import has changed to Text.ParserCombinators.Parsec.
20:59:29 <NullEntity> Is there a function that rounds a float to an int?
20:59:39 <copumpkin> :t round
20:59:42 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:59:46 <copumpkin> @hoogle Float -> Int
20:59:46 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
20:59:47 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
20:59:47 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
20:59:51 <copumpkin> bah
21:00:06 <SamB_XP> Jarrett: as far as I'm concerned, that's what it always has been ;-)
21:00:23 <Jarrett> blaah http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec.html :P
21:00:32 <Jarrett> inaccurate docs are inaccurate!
21:00:49 <Jarrett> @hoogle text.parsec.prim
21:00:49 <lambdabot> No results found
21:01:03 <Jarrett> liar!
21:01:07 <xerox> do you see the version number in the url?
21:01:07 <SamB_XP> Jarrett: those are the docs for parsec-3.0.0
21:01:30 <Jarrett> ahh
21:01:56 <SamB_XP> I've never used any version of Parsec that started with a 3
21:02:06 <SamB_XP> :-)
21:02:09 <Jarrett> hehe
21:06:32 <NullEntity> Help?
21:06:33 <NullEntity> No instances for (Integral ([t] -> t1), RealFrac ([a] -> a))   arising from a use of `round' at <interactive>:1:0-43
21:07:44 <Stravant> How would I express this the right way? (getting a value from the input and returning it):  readStatement = do putStrLn "Enter a string: " getLine --but return the value, not the action?
21:08:34 <dmwit> Stravant: There is no way.
21:08:38 <pikhq> Stravant: You cannot get the value.
21:08:38 <dmwit> Actions are the only choice.
21:08:48 <pikhq> getLine won't give it to you.
21:09:04 <dmwit> Stravant: In a very real sense, the value doesn't exist.
21:09:37 <dmwit> ?hpaste the code, NullEntity
21:09:38 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
21:09:53 <dmwit> Sonuds like a pretty simple type error, though; are you applying "round" to a function?  If so, don't do that. =)
21:09:58 <Stravant> Yea, I know, what I want to know is how I can make a function, that gets a value from the input and returns it, my code is totaly wrong
21:10:14 <NullEntity> It doesn't matter, I was doing it wrong anyway
21:10:26 <dmwit> readStatement = do { putStrLn "Enter a string: "; getLine } -- looks fine to me
21:10:36 <dmwit> Or, if you don't want a string,
21:10:44 <pikhq> Stravant: Looks fine to me,  although that's not a function.
21:10:46 <dmwit> readStatement = do { putStrLn "Enter a value: "; readLn }
21:10:57 <pikhq> It's an IO action.
21:11:03 <Stravant> Well, my real problem is, I want to get the value out of the IO action without having to bind it to a varaible name with the <- operator
21:11:12 <dmwit> Stravant: tough
21:11:19 <pikhq> Stravant: Tough.
21:11:20 <Jarrett> haha
21:11:22 <c_wraith> Stravant: use >>= then.
21:11:29 <c_wraith> (it's the same thing)
21:11:56 <dmwit> You can't always get what you waaaaant, but if you try... sometimes you'll find... you might just get what you neeeed!
21:12:11 <Stravant> >>= can accomplish the same thing as <-? I'll look more closely at that then
21:12:23 <dmwit> =<< is easier to understand
21:12:23 <pikhq> Stravant: Allow me to demonstrate:
21:12:39 <pikhq> @undo do {putStrLn "Enter a string: "; getLine}
21:12:39 <lambdabot> putStrLn "Enter a string: " >> getLine
21:12:41 <dmwit> (=<<) :: Monad m => (a -> m b) -> (m a -> m b)
21:12:48 <pikhq> Oh, also:
21:12:51 <pikhq> @src (>>)
21:12:51 <lambdabot> m >> k      = m >>= \_ -> k
21:13:14 <dmwit> ?undo do { putStrLn "enter a sting: "; x <- getLine; putStr $ "you said " ++ x }
21:13:14 <lambdabot> putStrLn "enter a sting: " >> getLine >>= \ x -> putStr $ "you said " ++ x
21:13:23 <dmwit> whoa, dangerous
21:13:27 <dmwit> ?undo do { putStrLn "enter a sting: "; x <- getLine; putStr $ "you said " ++ x; return () }
21:13:28 <lambdabot> putStrLn "enter a sting: " >> getLine >>= \ x -> putStr $ "you said " ++ x >> return ()
21:13:31 <dmwit> WRONG
21:13:47 <dmwit> undo--
21:14:03 <pikhq> dmwit: undo is a bit naive regarding infix.
21:14:13 <dmwit> Yeah, I noticed. =P
21:16:45 <sshc> dmwit: I find >>= a lot easier to understand
21:16:56 <sshc> also, what's >=>?
21:17:03 <sshc> @src >>=
21:17:03 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:17:05 <dmwit> (>=>) is (.)
21:17:08 <sshc> @src (>>=)
21:17:08 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:17:09 <dmwit> or maybe flip (.)
21:17:10 <sshc> @src (>=>)
21:17:11 <lambdabot> Source not found. :(
21:17:13 <dmwit> :t (>=>)
21:17:14 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
21:17:24 <dmwit> :t flip (.)
21:17:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
21:17:29 <dmwit> urgh
21:17:39 <Jarrett> is there a way to find out lambdabot's commands without filling the channel with garbage?
21:17:41 <dmwit> flip (.) :: (a -> b) -> (b -> c) -> (a -> c)
21:17:45 <dmwit> ?list
21:17:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:17:48 <Jarrett> thanks
21:17:59 <pikhq> Jarrett: If you want to experiment with lambdabot, privmsg.
21:18:10 <Jarrett> ah ok
21:18:39 <dmwit> > sepBy "a" "ababa"
21:18:40 <lambdabot>   Not in scope: `sepBy'
21:18:48 <dmwit> > Data.List.Split.sepBy "a" "abababa"
21:18:49 <lambdabot>   Not in scope: `Data.List.Split.sepBy'
21:18:51 <sshc> @src sep
21:18:52 <lambdabot> Source not found. My mind is going. I can feel it.
21:18:53 <dmwit> oh bugger
21:19:18 <sshc> > sepBy (=='a') "ababa"
21:19:19 <lambdabot>   Not in scope: `sepBy'
21:19:43 <sshc> @src concatMap
21:19:44 <lambdabot> concatMap f = foldr ((++) . f) []
21:19:46 <sshc> @src map
21:19:46 <lambdabot> map _ []     = []
21:19:46 <lambdabot> map f (x:xs) = f x : map f xs
21:20:02 <sshc> where did all of lambdabot's functions go? :P
21:20:10 <dmwit> What do you mean?
21:20:23 <sshc> it had sepBy, but not anymore
21:20:27 <SamB_XP> all her functions are belong to base
21:20:31 <dmwit> Are you sure?
21:21:03 <sshc> yes
21:21:06 <sshc> um
21:21:07 <sshc> no
21:21:17 <dmwit> > groupBy (\x y -> x /= '-' && y /= '-') "abc-def-ghi"
21:21:21 <lambdabot>   ["abc","-","def","-","ghi"]
21:21:26 <sshc> :m Data.List
21:21:31 <dmwit> hah
21:21:32 <sshc> :m +Data.List
21:21:33 <dmwit> Yeah, right.
21:21:47 <SamB_XP> @hoogle sepBy
21:21:48 <lambdabot> Text.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
21:21:48 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
21:21:48 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
21:21:53 <dmwit> > groupBy (\x y -> y /= '-') "abc-def-ghi"
21:21:55 <lambdabot>   ["abc","-def","-ghi"]
21:22:07 <dmwit> SamB_XP: The one I wanted is in Data.List.Split.
21:22:09 <sshc> oh is sepBy the parsec?
21:22:22 <SamB_XP> @hoogle splitBy
21:22:23 <lambdabot> No results found
21:22:26 <SamB_XP> @hoogle split
21:22:26 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
21:22:27 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
21:22:27 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
21:22:28 <sshc> :m Data.List.Split
21:22:35 <sshc> :m Prelude
21:22:37 <SamB_XP> sshc: that doesn't work
21:22:45 <sshc> ok
21:22:52 <sshc> @module Data.List
21:22:52 <lambdabot> Unknown command, try @list
21:22:56 <SamB_XP> :m System.Unsafe
21:22:56 <sshc> it should!
21:23:08 <SamB_XP> > unsafePerformIO makeYourTime
21:23:08 <sshc> lambdabot could easily have that module hiddne
21:23:09 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `makeYourTime'
21:23:29 <sshc> SamB_XP: lambdabot could easily have that module hidden
21:24:46 <Jarrett> am I correct in my guess that () is Haskell's name for unit?
21:25:04 <SamB_XP> Jarrett: unless it's return, yeah!
21:25:05 <c_wraith> yes
21:25:16 <monochrom> We love reusing names.
21:25:16 <Jarrett> O__O
21:25:19 <sshc> Jarrett: Correct me if I'm wrong, but isn't Haskell's name for unit.. unit?
21:25:21 <SamB_XP> or 1
21:25:26 <Jarrett> I don't even
21:25:47 <SamB_XP> (return is also called unit sometimes ;-)
21:25:51 <Jarrett> ahh
21:25:53 <NullEntity> Stinger: lol, Skype recognizes your hostmask as a telephone number
21:26:02 <monochrom> We write like [a]->() at the type level and f [3] = () at the value level.
21:26:54 <NullEntity> Damnit, my chat window doesn't scroll automatically =(
21:26:58 <Jarrett> lllol
21:27:05 <NullEntity> Now it is...
21:27:09 <NullEntity> gawd
21:27:22 <SamB_XP> NullEntity: that happens to me sometimes!
21:28:03 <NullEntity> I'm using webchat.freenode.net.
21:28:16 <Jarrett> lol webchat is a piece
21:28:17 <NullEntity> I think it happens when the window looses foxes.
21:28:25 <NullEntity> focus*
21:28:32 <Jarrett> oh no! we're all out of foxes.
21:28:42 <SamB_XP> quick!
21:28:45 <SamB_XP> catch them foxes
21:28:50 <SamB_XP> before they escape into yon woods!
21:28:56 <NullEntity> NO! THAT MEANS IT WONT SCROLL ANYMORE!
21:29:10 <NullEntity> I don't like fox powered automatic scrollers =(
21:29:18 <Jarrett> lmao
21:29:44 <SamB_XP> lol
21:29:54 <SamB_XP> I would too, if it weren't sewn on!
21:30:41 <dmwit> > let p = (=='-'); g = map (d . dropWhile (=='>') . dropWhile p) . groupBy (\x -> not . p); d = join (.) (reverse . dropWhile (==' ')); t "()" = "void"; t x = x; u f vs = concat [t (last v), " ", f, "(", intercalate ", " (map t vs), ")"] in u "foo" . g $ "a -> b -> IO ()"
21:30:42 <lambdabot>   Couldn't match expected type `[a]'
21:30:43 <lambdabot>         against inferred type `SimpleRef...
21:32:32 <Jarrett> oh my goodness.
21:32:53 <Jarrett> I'm still at the point where stuff like that just starts looking like forth to me.
21:34:35 <drhodes> > [[x,y] | x <- ['1'..'9'], y <- ['0'..'9']]
21:34:36 <lambdabot>   ["10","11","12","13","14","15","16","17","18","19","20","21","22","23","24"...
21:34:47 <dmwit> > let p = (=='-'); g = map (d . dropWhile (=='>') . dropWhile p) . groupBy (\x -> not . p); d = join (.) (reverse . dropWhile (==' ')); t "()" = "void"; t ('I':'O':xs) = t (d xs); t x = x; u f vs = concat [t (last vs), " ", f, "(", intercalate ", " . map t . init $ vs, ")"] in u "foo" . g $ "a -> b -> IO ()"
21:34:49 <lambdabot>   "void foo(a, b)"
21:35:00 <Jarrett> ahahaha
21:35:03 <dmwit> =)
21:35:09 <Jarrett> i c wat ur doin thar!
21:36:11 <dmwit> Of course, there's a much simpler definition:
21:36:25 <drhodes> anyone have a way to produce a list of strings  0 .. 100, without the first ten starting with zero?
21:36:26 <dmwit> > let f "a -> b -> IO ()" = "void foo(a, b)" in f "a -> b -> IO ()" -- ;-)
21:36:27 <lambdabot>   "void foo(a, b)"
21:36:38 <Jarrett> f "a -> b -> IO ()"
21:36:40 <Jarrett> Fabio
21:36:43 <dmwit> > map show [0..100]
21:36:44 <lambdabot>   ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16"...
21:36:54 <drhodes> oh yeah. thanks dmwit
21:37:57 <dmwit> > map (dropWhile (=='0')) (replicateM 2 ['0'..'9'])
21:37:58 <lambdabot>   ["","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16",...
21:38:15 <dmwit> mmm
21:38:34 <copumpkin> hawt
21:38:43 <dmwit> > uncurry (++) . first (map (drop 1)) . splitAt 10 . replicateM 2 $ ['0'..'9']
21:38:44 <lambdabot>   ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16"...
21:38:57 <dmwit> Much better.
21:38:59 <Jarrett> my head asplode
21:39:13 <dmwit> It's not complete until you use monads, arrows, and currying.
21:39:17 <Jarrett> lmao
21:39:34 <monochrom> Are we in the business of converting haskell code into c code by just writing String->String functions?
21:39:36 <copumpkin> @remember dmwit It's not complete until you use monads, arrows, and currying
21:39:36 <lambdabot> Okay.
21:40:03 <NullEntity> How do I convert  an integer to a list (or just reverse it)?
21:40:20 <dmwit> > show 32767
21:40:20 <pikhq> NullEntity: In what manner would you like it converted to a list?
21:40:21 <lambdabot>   "32767"
21:40:32 <pikhq> There are many different ways of doing so.
21:40:34 <dmwit> I feel like I just answered this question...
21:40:40 <dmwit> > read . reverse . show $ "32767"
21:40:41 <lambdabot>   * Exception: Prelude.read: no parse
21:40:46 <dmwit> uh?
21:40:47 <dmwit> oh
21:40:50 <dmwit> > read . reverse . show $ "32767" :: Int
21:40:52 <lambdabot>   * Exception: Prelude.read: no parse
21:40:53 <NullEntity> I have a function that'd take an int
21:40:59 <c_wraith> fewer quotes
21:41:03 <dmwit> yarr
21:41:05 <NullEntity> > reverse show 123456
21:41:06 <lambdabot>   Couldn't match expected type `[a]'
21:41:06 <lambdabot>         against inferred type `a1 -> GHC...
21:41:08 <dmwit> > read . reverse . show $ 32767 :: Int
21:41:09 <NullEntity> aww
21:41:09 <lambdabot>   76723
21:41:20 <pikhq> :t reverse
21:41:22 <lambdabot> forall a. [a] -> [a]
21:41:30 <dmwit> c_wraith++
21:41:32 <Jarrett> > reverse . show 123456
21:41:33 <pikhq> NullEntity: Why would you pass two arguments to a 1-adic function?
21:41:33 <lambdabot>   Couldn't match expected type `[a]'
21:41:33 <lambdabot>         against inferred type `GHC.Types...
21:42:00 <NullEntity> ?
21:42:15 <pikhq> Jarrett: That's (reverse . (show 123456))
21:42:21 <Jarrett> oh dear
21:42:27 <pikhq> NullEntity: reverse takes one argument. You passed it two.
21:42:43 <pikhq> Jarrett: What you want is more like ((reverse . show) 123456)
21:42:43 <NullEntity> Well that's cause I suck at this :P
21:42:45 <dmwit> > (reverse . show) 1234567
21:42:46 <lambdabot>   "7654321"
21:42:50 <monochrom> My function returns a function so you can pass a parameter while you pass a parameter.
21:42:55 <Jarrett> ahh
21:43:07 <Jarrett> yo dawg
21:43:15 <pikhq> Jarrett: AKA (reverse . show $ 123456)
21:43:18 <dmwit> > succ . show 1234567 -- surprise!
21:43:19 <lambdabot>   "2345678"
21:43:44 <monochrom> Hahaha
21:43:48 <pikhq> dmwit: Darned Caleskell. :P
21:43:54 <kmc> > succ [False]
21:43:54 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Bool.Bool])
21:43:55 <lambdabot>    arising from a use of `G...
21:44:05 <dmwit> > succ . [False]
21:44:07 <lambdabot>   [True]
21:44:19 <NullEntity> so what does the . do?
21:44:24 <SamB_XP> `map`
21:44:27 <Jarrett> maaaaaaagic
21:44:27 <monochrom> fmap
21:44:30 <SamB_XP> or rather, `fmap`
21:44:31 <dmwit> NullEntity: In normall Haskell, it composes two functions.
21:44:38 <dmwit> NullEntity: In here, it's fmap.
21:44:44 <pikhq> NullEntity: In normal Haskell, it's function composition. In here, it's fmap.
21:44:44 <SamB_XP> but in Calaskal, it's, yeah, fmap ;-P
21:44:48 <dmwit> NullEntity: (Which is function composition for the function functor.)
21:44:52 <monochrom> OK, map is not wrong either.
21:45:05 <dmwit> pikhq: ECHO, Echo, echo... ;-)
21:45:12 <SamB_XP> monochrom: yeah, but isn't that only because Cale overloaded that too?
21:45:15 <pikhq> dmwit: Hah.
21:45:16 <SamB_XP> > map
21:45:18 <lambdabot>   {{()->()}->{[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}}
21:45:18 <monochrom> Yes.
21:45:19 <pikhq> SamB_XP: Yes.
21:45:27 <Jarrett> O__O;;
21:45:29 <SamB_XP> hmm, it still defaults right though
21:45:32 <dmwit> > (.)
21:45:33 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
21:45:33 <lambdabot>                    GHC.Show...
21:45:39 <monochrom> Actually I am not sure what my "Yes" refers to.
21:45:42 <SamB_XP> or maybe Cale reverted
21:45:48 <SamB_XP> :t map
21:45:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:45:52 <SamB_XP> :t (.)
21:45:53 <pikhq> :t map
21:45:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:45:54 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:46:03 <dmwit> :t (++)
21:46:04 <lambdabot> forall m. (Monoid m) => m -> m -> m
21:46:04 <pikhq> Hmm. Guess it's not overloaded.
21:46:05 <SamB_XP> oh, :t doesn't take that into account
21:46:09 <SamB_XP> :-(
21:46:16 <SamB_XP> or does it?
21:46:22 <kmc> > map :: (Char -> Char) -> String -> String
21:46:23 * SamB_XP confesedayray
21:46:23 <lambdabot>   {'a'->'a';'b'->'a';'c'->'a';'d'->'a'}->
21:46:23 <lambdabot>    ""->
21:46:23 <lambdabot>      ""
21:46:23 <lambdabot>    "a"->
21:46:23 <lambdabot>      "a"
21:46:25 <lambdabot>  ...
21:46:49 <dmwit> :t concat
21:46:50 <lambdabot> forall a. [[a]] -> [a]
21:47:01 <dmwit> Now, why wouldn't Cale have generalized that one? ^_^
21:47:17 <c_wraith> to join?
21:47:19 <monochrom> because the name is bad.
21:47:25 <dmwit> :t mconcat
21:47:26 <lambdabot> forall a. (Monoid a) => [a] -> a
21:47:38 <SamB_XP> hmm, should have found a lolcat pun to generaize it based on ;-P
21:47:38 <dmwit> c_wraith: The obvious analog, if (++) is mappend.
21:47:55 <c_wraith> ah
21:48:16 <monochrom> The great thing about generalizations is there are so many to choose from.
21:48:49 <SamB_XP> I thought that was the great thing about standards!
21:49:01 <dmwit> Therefore, standards = generalizations!
21:49:13 <monochrom> I generalized.
21:49:18 <SamB_XP> dmwit: you're sure that's not a false standard ?
21:49:28 <dmwit> It's got what plants crave!
21:49:42 <SamB_XP> plants crave?
21:49:57 <dmwit> You know, electrolytes.
21:50:21 <SamB_XP> I thought that was batteries
21:50:29 * monochrom wonders how to get from standards and generalizations to electrolytes.
21:50:42 <pikhq> BRAWNDO: THE THIRST MUTILATOR!
21:51:21 <Jarrett> it's like riding on a pony made of chainsaws
21:51:28 <dmwit> monochrom: via circular reasoning
21:51:31 <SamB_XP> lol
21:51:34 <NullEntity> I'm looking up the . operator. I don't understand lambda abstractions. Is there a guide to explain it?
21:51:46 <SamB_XP> dmwit: is that where the chainsaws come in?
21:51:49 <dmwit> monochrom: There is a scene in Idiocracy which is now my mental image of circular arguments.
21:52:24 <pikhq> NullEntity: You know functions?
21:52:29 <NullEntity> Yes
21:52:32 <dmwit> "Why do you water the plants with Brawndo?"  "Because it's got electrolytes?"  "Do you even know what electrolytes are?"  "It's what plants crave!"  "But WHY do they crave them?"  "Brawndo's got what plants crave!"
21:52:35 <pikhq> Take away the name.
21:52:39 <mtnviewmark> I have some code that imports Text.Regex
21:52:49 <pikhq> You now have lambda.
21:52:52 <c_wraith> NullEntity, is the explanation '"(f . g) x" is the same as "f(g(x))"' insufficient?
21:52:53 <mtnviewmark> anyone know what package that is in
21:52:59 <pikhq> From this, you can define everything else.
21:53:20 <pikhq> What more is there to know?
21:53:25 <NullEntity> eh, it's really late here :P I can't think xD
21:53:36 <NullEntity> or remember
21:53:45 <dmwit> "foo = \x -> something" and "foo x = something" are basically identical (up to the dreaded MR)
21:53:50 <adu> NullEntity: you know not of lambda?
21:53:50 <c_wraith> NullEntity: use it a bit, and you'll figure it out.  But wait 'til your more awake. :)
21:53:59 <c_wraith> *you're
21:54:02 <NullEntity> I know not of lambda
21:54:26 <adu> NullEntity: lambda is your saviour, when you least expect it, it creeps up on you in the night
21:54:33 <monochrom> The explanation "(f . g) x" is the same as "f(g(x))" is insufficent for succ . "123" evaluating to "234".
21:54:38 <NullEntity> adu: like Michael Jackson?
21:54:47 <adu> NullEntity: yes, only less creepy
21:55:00 <NullEntity> I get it!
21:55:02 <c_wraith> monochrom, that only happens in lambdabot.  Doesn't count.
21:55:06 <adu> NullEntity: actually, pikhq's was better
21:55:12 <SamB_XP> monochrom: why do you like to chop the heads off of expressions ?
21:55:26 <monochrom> But NullEntity is asking because someone did succ . "123" to lambdabot.
21:55:42 <monochrom> I didn't chop the heads of expressions.
21:55:53 <c_wraith> Oh.  lambdabot has some special cases.  Don't worry about it
21:55:59 <SamB_XP> then what's with all the guillotines ?
21:56:30 <monochrom> They are the greatest quote symbols ever.
21:56:38 <adu> NullEntity: f(x) = expr is the same as f = (\x -> expr)
21:56:46 <NullEntity> Wait, is this just because (reverse . show) a is neater that reverse ( show a )? From what I understand, their not functionaly different
21:57:11 <pikhq> NullEntity: In this case, yes.
21:57:34 <pikhq> @src (.)
21:57:34 <lambdabot> (f . g) x = f (g x)
21:57:41 <pikhq> That's all there is to it.
21:57:50 <NullEntity> okay
21:58:13 <adu> :t (fromInteger . toInteger)
21:58:14 <lambdabot> forall a a1. (Num a, Integral a1) => a1 -> a
21:58:26 <adu> :t (toInteger . fromInteger)
21:58:27 <lambdabot> Integer -> Integer
21:59:37 <pikhq> adu: ZOMG ITS id!
22:00:09 <Stinger> id_Integer
22:00:13 <adu> :t id 3
22:00:14 <lambdabot> forall t. (Num t) => t
22:00:34 <monochrom> > ((toInteger :: Int->Integer) . fromInteger) (2^40)
22:00:36 <lambdabot>   1099511627776
22:00:47 <monochrom> Darn 64-bit supercomputer.
22:00:49 <monochrom> > ((toInteger :: Int->Integer) . fromInteger) (2^400)
22:00:51 <lambdabot>   0
22:01:13 <adu> not quite
22:01:13 <SamB_XP> > ((toInteger :: Int32->Integer) . fromInteger) (2^40)
22:01:15 <lambdabot>   0
22:02:50 <adu> pikhq: btw, what's the Z for?
22:03:22 <pikhq> adu: I'm... not entirely sure.
22:03:27 <adu> lol
22:03:36 <Jarrett> Z oh my god
22:03:43 <Jarrett> :P
22:03:45 <SamB_XP> isn't that a spec language ?
22:03:48 <adu> ya, but what's the Z for?
22:04:02 <Jarrett> there is no "why", only "is"
22:04:13 <dolio> Zermello.
22:04:14 <SamB_XP> it ... came after C ?
22:04:14 <adu> SamB_XP: yes, Z is the most beautiful programming language of all time
22:04:15 <Jarrett> it exists! _a priori_
22:04:41 <monochrom> To emulate the effect of pressing the shift key (in order to get all caps) in such haste that accidentally the z key beside the shift key is also pressed.
22:04:42 <SamB_XP> Jarrett: since when does that start with a Z ?
22:04:51 <Jarrett> ha
22:05:02 <SamB_XP> but that just gives you ?
22:06:30 <tomoj> strange, z is right next to right shift for me
22:06:34 <adu> http://www.lsi.usp.br/~edualves/Material-de-Aula/Alao/zrm.pdf
22:06:39 <tomoj> we can accidentally type ZOMG whether qwerty or dvorak
22:06:56 <adu> tomoj: ZOMG
22:06:57 <monochrom> Nice, this is robust. :)
22:07:46 <adu> actually, in some respects Z is similar to GHC Core
22:09:59 <SamB_XP> full of incomprehensible, long identifiers ?
22:10:15 <sshc> why doesn't foldr1' exist for Data.List??
22:10:31 <monochrom> because I don't know how to write it. Do you?
22:10:38 <tensorpudding> a strict right fold?
22:11:20 <sshc> monochrom: yes
22:11:41 <sshc> by looking at Dat.ByteString's implementation
22:12:04 <sshc> tensorpudding: yes, a strict right fold
22:12:45 <Jarrett> quick: what does this syntax mean "import ParsecLanguage( haskellStyle )"
22:12:50 <adu> foldr1' f xs = reverse (foldr1' f (reverse xs))
22:13:05 <adu> foldr1' f xs = reverse (foldl1' f (reverse xs))
22:13:07 <adu> oops
22:13:33 <monochrom> only import the function haskellStyle from the module ParsecLanguage.
22:13:58 <sshc> @let fordr1' f ps = if null ps then error "empty lis!t" else foldr' f (last ps) (init ps)
22:13:59 <lambdabot>  <local>:4:56: Not in scope: `foldr''
22:14:01 <monochrom> Should I go look at the implementation of Data.ByteString?
22:14:03 <Jarrett> ahh
22:14:04 <Jarrett> thanks
22:14:48 <sshc> why don't any strict versions of foldr exist for Data.List?
22:15:36 <tensorpudding> @src foldr1
22:15:36 <lambdabot> foldr1 _ [x]    = x
22:15:36 <c_wraith> I don't think foldr can be strict, in a useful way.
22:15:36 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
22:15:36 <lambdabot> foldr1 _ []     = undefined
22:16:10 <monochrom> I don't actually know how strict you want it.
22:16:30 <sshc> as strict as foldl1'
22:16:32 <c_wraith> making foldr strict would make it blow the stack on most computations
22:16:39 <c_wraith> (on large lists, anyway)
22:16:44 <tensorpudding> @src foldl1'
22:16:44 <lambdabot> Source not found. Wrong!  You cheating scum!
22:16:48 <tensorpudding> bleh
22:16:51 <monochrom> But let's say you want extreme. OK, you can just write foldr (\x y -> seq x (seq y (f x y))
22:17:00 <adu> @src foldl1
22:17:00 <lambdabot> foldl1 f (x:xs) = foldl f x xs
22:17:01 <lambdabot> foldl1 _ []     = undefined
22:17:27 <tensorpudding> hmm, that's convenient
22:17:39 <monochrom> Or maybe you prefer foldr (\x y -> seq y (seq x (f x y))
22:18:22 <tensorpudding> @let foldl1' _ [] = undefined; foldl1' f (x:xs) = foldl' f x xs
22:18:24 <lambdabot>  Defined.
22:18:46 <monochrom> Or foldr (\x y -> seq y (f x y)). Or foldr (\x y -> seq x (f x y)).  There, all 4 variations are done.
22:19:11 <tensorpudding> > foldl1' (+) [1..10]
22:19:12 <lambdabot>   Ambiguous occurrence `foldl1''
22:19:12 <lambdabot>  It could refer to either `L.foldl1'', defin...
22:19:23 <tensorpudding> argh
22:19:34 <monochrom> You can't play this trick to foldl and make any difference, that is why foldl' is written. But foldr' is entirely in terms of foldr, all 4 possible meanings.
22:19:35 <sshc> if I don't care about the order in which a list is folded, should I use foldl, foldl', or foldr?
22:19:36 <tensorpudding> it did exist
22:20:07 <c_wraith> sshc: depends on what you're doing.  If you're doing something with an accumulator, use foldl'
22:20:20 <c_wraith> sshc: if you're doing something with lazy results, use foldr
22:20:43 <sshc> c_wraith: I'm using an accumulator.  Why should I use foldl' in this case?
22:21:26 <c_wraith> sshc: because it evaluates the accumulator strictly after each element of the list, so it uses the least overhead.
22:22:05 <copumpkin> the cases when you'd use foldl over foldl' are very very rare
22:22:23 <copumpkin> it's usually a decision between foldl' and foldr
22:22:56 <sshc> copumpkin: when would you use foldl?
22:23:17 <c_wraith> > foldl (+) 0 [1..1000000::Int]
22:23:19 <lambdabot>   * Exception: stack overflow
22:23:19 <NullEntity> Wow, my is_palindrome function works! Thanks guys!
22:23:26 <c_wraith> > foldl' (+) 0 [1..1000000::Int]
22:23:26 <lambdabot>   500000500000
22:23:31 <sshc> is there a function in the standard library that behaves like lookup and returns the value inside Just if Just, but returns a default value when it returns Nothing?
22:23:36 <copumpkin> sshc: if your binary operation is not (always) strict in its first parameter
22:23:38 <c_wraith> that's why you'd want foldl' over foldl most of the time
22:23:41 <copumpkin> it thus would allow bottoms in the list itself
22:24:08 <sshc> I see
22:24:16 <sshc> if there isn't, I'll roll out my on
22:24:44 <copumpkin> (fromMaybe default .) . lookup
22:24:49 <copumpkin> @hackage default
22:24:50 <lambdabot> http://hackage.haskell.org/package/default
22:24:54 <copumpkin> meh
22:24:54 <dobblego> @type fromMaybe -- sshc
22:24:55 <lambdabot> forall a. a -> Maybe a -> a
22:26:03 <monochrom> combine lookup and fromMaybe. or combine lookup and maybe.
22:26:53 <monochrom> Some functions are not in the lib because they are like just 5 keystrokes away from 2 functions in the lib.
22:27:15 <monochrom> If you really hate that, you should start a project on Prelude.Twitter.
22:27:27 <monochrom> "All functions implementable in 140 tokens or less."
22:28:04 <SamB_XP> monochrom: is that a finite collection of functions ?
22:28:10 <SamB_XP> I doubt it?
22:28:13 <monochrom> Then you won't be wasting time asking everyone rhetorically and provocatively "why isn't this so obvious function on hackage".
22:28:18 <c_wraith> > foldr (+) 0 [1..1000000::Int]
22:28:19 <lambdabot>   * Exception: stack overflow
22:28:24 <monochrom> I don't know and I don't care. Not my project.
22:28:30 <NullEntity> Has anyone googled recursion?
22:28:35 <monochrom> Someone else's complaint and someone else's problem.
22:28:36 <NullEntity> It's pretty funny
22:28:42 <SamB_XP> NullEntity: yes, most of us
22:28:42 <Jarrett> lol yes NullEntity
22:28:45 <SamB_XP> see recursion
22:28:47 <c_wraith> does it give a link to the google search for recursion?
22:28:50 <Jarrett> yeah.
22:28:52 <sshc> NullEntity: Define recursion
22:28:53 <NullEntity> yerp
22:29:02 <SamB_XP> @all-dict recursion
22:29:04 <lambdabot> *** "Recursion" gcide "The Collaborative International Dictionary of English v.0.48"
22:29:05 <lambdabot> Recursion \Re*cur"sion\ (-sh?n), n. [L. recursio. See {Recur}.]
22:29:05 <lambdabot>    The act of recurring; return. [Obs.] --Boyle.
22:29:05 <lambdabot>    [1913 Webster]
22:29:05 <lambdabot>  
22:29:06 <lambdabot> [37 @more lines]
22:29:11 <NullEntity> NullEntity: Define recursion
22:29:13 <NullEntity> NullEntity: Define recursion
22:29:14 <NullEntity> NullEntity: Define recursion
22:29:15 <SamB_XP> @foldoc recursion
22:29:16 <lambdabot> *** "recursion" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
22:29:17 <lambdabot> recursion
22:29:17 <lambdabot>  
22:29:17 <lambdabot>         <mathematics, programming> When a {function} (or {procedure})
22:29:17 <lambdabot>         calls itself.  Such a function is called "recursive".  If the
22:29:18 <lambdabot> [24 @more lines]
22:29:31 <SamB_XP> @devil recursion
22:29:32 <lambdabot> No match for "recursion".
22:29:35 <sshc> Recurring: what the act of recursion is
22:30:49 <sshc> @let recursion = recursion
22:30:50 <lambdabot>  Defined.
22:30:56 <sshc> :t recursion
22:30:57 <lambdabot> forall t. t
22:31:01 <sshc> > recursion
22:31:05 <lambdabot>   mueval-core: Time limit exceeded
22:31:15 <SamB_XP> hmm, I wonder if monochrom's meme is applicable here ?
22:31:27 <monochrom> which meme? I have a few.
22:31:36 <monochrom> But perhaps all are applicable.
22:31:45 <SamB_XP> I have a fold in my fold so I can recurse while I'm recursing ?
22:32:29 <monochrom> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6356
22:32:42 <sshc> SamB_XP: Just so that you can recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you recurse while you
22:33:00 <sshc> </mindlessandannoyingspam>
22:33:30 <c_wraith> I don't think there's any way you can make foldr strict that will prevent "> foldr (+) 0 [1..1000000::Int]" from blowing the stack.  Am I totally off base here?
22:34:49 <monochrom> Apart from passing continuations.
22:35:10 <c_wraith> Ah, that would do it
22:35:11 <copumpkin> aka building a foldl
22:35:12 <monochrom> OK, passing continuations doesn't count, you have specially foldr (+) 0 [1..1000000::Int]
22:36:16 <Jarrett> night
22:36:33 <monochrom> CPS blows the heap instead.
22:36:47 <monochrom> It also blows up some readers' heads.
22:37:41 <NullEntity> When I saw Lambda, this is the first thing I thought about: http://learnyouahaskell.com/lambda.png
22:37:53 <NullEntity> Gordon Freeman from Half Life xD
22:38:12 <dolio> No, that's Hugh Laurie.
22:38:29 <monochrom> It is a bit unsatisfactory that stack and heap receive different restrictions (as in, stack receives hard limits) and so everyone is so bent on saving the stack at the expense of heap.
22:39:36 <dolio> GHC has some heap limiting flags.
22:39:45 <dolio> Someone should enable those by default.
22:41:13 <monochrom> I guess this is just economics. Stack is fast and better off scarce. Heap is inferior goods.
22:42:20 <monochrom> If stack were both fast and abundant, we would have no economy and people would find it counterintuitive!
22:43:02 <dolio> Well, I think the contention is that people don't tend to write infinite heap-allocating loops.
22:43:27 <dolio> Although I'm not sure how accurate that is.
22:47:59 <dolio> Although, it's not uncommon for me to accidentally write something that uses up all my available memory heap-allocating before I can stop it.
22:48:21 <dolio> Maybe I just notice that more because I haven't protected against it, though. I should probably set some ulimits or something.
23:30:20 <NullEntity> How would I go about telling if a number is not prime?
23:32:03 <tensorpudding> can we please change the channel -R?
23:34:00 <NullEntity> You can't register why?
23:34:15 <djahandarie> (He is obivously registered if he is talking in here)
23:34:27 <tensorpudding> eh
23:34:31 <NullEntity> I sort of thought of that
23:34:35 <tensorpudding> i don't want to have to register my fallback nick
23:34:43 <djahandarie> tensorpudding, it is +R because of the bot attacks
23:34:49 <tensorpudding> i know
23:34:55 <djahandarie> They might not be happening now but it is pretty random
23:35:00 <djahandarie> So if an op isn't around it could be bad
23:35:14 <NullEntity> What? If your nick is registered, just /msg NickServ GHOST <nick> <oass>
23:35:17 <tensorpudding> but it's really obnoxious that i get disconnected and auto-reconnect, and because i don't have voice here i can't change my nick without parting first
23:35:39 <djahandarie> tensorpudding, yes, it is annyoing.
23:35:51 <Veinor> > let a `divs` b = (b `div` a) * a == b; isComposite n = any (`divs` n) [2..(n-1)] in isComposite 99
23:35:52 <lambdabot>   True
23:35:55 <Veinor> > let a `divs` b = (b `div` a) * a == b; isComposite n = any (`divs` n) [2..(n-1)] in isComposite 97
23:35:55 <lambdabot>   False
23:35:59 <Veinor> > let a `divs` b = (b `div` a) * a == b; isComposite n = any (`divs` n) [2..(n-1)] in isComposite 3
23:36:00 <lambdabot>   False
23:36:04 <tensorpudding> i'm trying to figure out what logic it's using to default my fallback to tensorpu`
23:36:07 <Veinor> :D
23:36:13 <tensorpudding> and change it to something i like more
23:36:22 <tensorpudding> before regging this fallback that i don't care for
23:37:59 <Veinor> although you could probably adjust that to [2.. floor $ sqrt n]
23:38:51 <NullEntity> what's the in isComposite at the end for?
23:40:01 <Veinor> I'm just showing off that isComposite works.
23:40:38 <NullEntity> So the code I want is isComposite n = any (`divs` n) [2.. floor $ sqrt n]?
23:40:42 <Veinor> so the definition of isComposite is: let a `divs` b = (b `div` a) * a == b; isComposite n = any (`divs` n) [2..floor $ sqrt n]
23:41:00 <Veinor> yeah, where you have `divs` defined in context
23:41:21 <Veinor> er, the definition of isComposite is: let a `divs` b = (b `div` a) * a == b in isComposite n = any (`divs` n) [2..floor $ sqrt n]
23:41:45 <tensorpudding> there are better primality tests than that
23:42:06 <Veinor> well yeah, but that's the most obvious one that came to mind
23:42:21 <NullEntity> I need to learn better Haskell... I would've done something with modulus
23:42:23 <tensorpudding> little fermat usually works
23:42:38 <mm_freak> Quadrescence: i think the "overloading the semicolon" metaphor doesn't really explain monads to C programmers  at least not their actual strength
23:43:21 <NullEntity> Well what I have right now is a list of prime palindromes up to 999x999
23:43:41 <NullEntity> mm_freak: are you quoting him from hours ago
23:43:44 <NullEntity> ?
23:43:46 <mm_freak> yes
23:43:57 <NullEntity> Okay, just checking
23:44:22 <mm_freak> i wanted to know what bot attack you're talking of, so i scrolled  a lot
23:54:26 <NullEntity> Veinor: how does your code work? I'm trying to understand it
23:54:47 <Veinor> NullEntity: do you understand how `divs` works?
23:54:58 <NullEntity> There's the problem
23:55:09 <Veinor> okay.
23:55:16 <adu> mm_freak: oooo i like that one
23:55:30 <Veinor> `div` is integer division. so 8 `div` 3 = 2, 10 `div` 2 = 5, 243 `div` 10 = 24
23:55:48 <NullEntity> yep
23:55:58 <adu> Veinor: sometimes, it is also true division
23:56:07 <Veinor> baby steps!
23:56:36 <Veinor> so if (b `div` a) * a == b, then b `div` a == b / a
23:56:40 <Veinor> so a evenly divides b
23:57:44 <mm_freak> adu: what do you like?  the metaphor?
23:57:49 <NullEntity> i get that
23:57:58 <Veinor> okay.
23:58:36 <adu> mm_freak: "overloading the semicolon"
23:58:44 <adu> > floor (6 / 3) == 6 `div` 3
23:58:45 <lambdabot>   True
23:59:05 <mm_freak> adu: well, it explains (>>), but not (>>=)
23:59:14 <Veinor> so, what any does is
23:59:28 <Veinor> any p xs takes the function p, and applies it to all the elements of xs
23:59:28 <adu> mm_freak: well, it explains both, imho
23:59:29 <mm_freak> adu: i rather like to overload the assignment operator
23:59:37 <Veinor> if any of those return true, any returns true
23:59:41 <Veinor> otherwise it returns false
23:59:51 <mm_freak> adu: really?  how do you explain the list monad using the semicolon?
23:59:57 <Veinor> so for example, any odd [2,4,7] == True, any odd [2,4,6] == False
